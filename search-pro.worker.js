const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:n})=>n),bt=et(V(JSON.parse("{\"/\":{\"documentCount\":1995,\"nextId\":1995,\"documentIds\":{\"0\":\"1\",\"1\":\"1#开源项目\",\"2\":\"1#社区\",\"3\":\"1#技能点\",\"4\":\"1#个人经历\",\"5\":\"1#联系我\",\"6\":\"2\",\"7\":\"2#java基础\",\"8\":\"2#jvm、jdk-和-jre-联系与区别\",\"9\":\"2#构造器-constructor-是否可被-override\",\"10\":\"2#重载和重写的区别\",\"11\":\"2#面向对象编程三大特性-封装-继承-多态\",\"12\":\"2#string-stringbuffer-和-stringbuilder-的区别是什么\",\"13\":\"2#string类为什么是不可变的\",\"14\":\"2#integer的缓存机制\",\"15\":\"2#深拷贝和浅拷贝的区别\",\"16\":\"2#接口和抽象类的区别\",\"17\":\"2#构造方法有哪些特性\",\"18\":\"2#string中hashcode的实现\",\"19\":\"2#hashcode和equals的作用\",\"20\":\"2#jdk8有哪些新特性\",\"21\":\"2#java反射有哪些作用\",\"22\":\"2#如何使用反射获取私有属性\",\"23\":\"2#创建对象有哪些方式\",\"24\":\"2#迭代器和for循环遍历的区别\",\"25\":\"2#过滤器和拦截器的区别\",\"26\":\"2#java集合\",\"27\":\"2#list、set、map三者的区别\",\"28\":\"2#hashmap实现原理\",\"29\":\"2#hashmap为什么扩容为2倍\",\"30\":\"2#为什么hashmap不用linkedlist-而是选用数组\",\"31\":\"2#jdk1-8对hashmap有哪些优化\",\"32\":\"2#为什么不直接使用红黑树-而是选择先用链表-再转红黑树\",\"33\":\"2#hashmap不使用红黑树-而是使用二叉查找树可以吗\",\"34\":\"2#为什么阈值是8\",\"35\":\"2#当链表转为红黑树-什么时候退化为链表\",\"36\":\"2#hashmap在并发编程环境下有什么问题\",\"37\":\"2#使用可变类当hashmap的key有什么问题\",\"38\":\"2#如何实现一个自定义的class作为hashmap的key\",\"39\":\"2#两个相同对象没有重写equals方法放到hashmap覆盖吗\",\"40\":\"2#hashset实现原理\",\"41\":\"2#currenthashmap的实现原理\",\"42\":\"2#arraylist的实现原理\",\"43\":\"2#java并发\",\"44\":\"2#并发编程的三要素\",\"45\":\"2#线程和进程的区别\",\"46\":\"2#守护线程和用户线程的区别\",\"47\":\"2#什么是线程安全\",\"48\":\"2#java如何开启线程-怎么保证线程安全\",\"49\":\"2#线程有哪些状态\",\"50\":\"2#如何停止一个正在运行的线程\",\"51\":\"2#notify和notifyall有什么区别\",\"52\":\"2#wait和sleep方法有什么区别\",\"53\":\"2#为什么wait和notify方法要在同步块中调用\",\"54\":\"2#thread类中的yield方法有什么作用\",\"55\":\"2#volatile和synchronized有什么区别\",\"56\":\"2#volatile变量和atomic变量什么不同\",\"57\":\"2#interrupted和isinterrupted方法的区别\",\"58\":\"2#volatile能不能保证线程安全\",\"59\":\"2#dcl单例为什么加volatile\",\"60\":\"2#死锁与活锁的区别\",\"61\":\"2#死锁与饥饿的区别\",\"62\":\"2#按照线程安全的强度来区分-分为哪几类\",\"63\":\"2#线程安全的实现方法有哪些\",\"64\":\"2#锁优化技术你了解什么\",\"65\":\"2#lock与synchronized有什么区别\",\"66\":\"2#什么是阻塞队列-阻塞队列的实现原理是什么\",\"67\":\"2#什么是callable和future\",\"68\":\"2#java线程锁机制是怎样的-偏向锁、轻量级锁、重量级锁有什么区别-锁机制是如何升级的\",\"69\":\"2#什么是可重入锁-有哪些实现\",\"70\":\"2#什么是悲观锁-什么是乐观锁\",\"71\":\"2#谈谈你对aqs的理解-aqs如何实现可重入锁\",\"72\":\"2#synchronizedmap和concurrenthashmap有什么区别\",\"73\":\"2#concurrenthashmap的并发度是什么\",\"74\":\"2#copyonwritearraylist可以用于什么应用场景\",\"75\":\"2#有a、b、c三个线程-如何保证三个线程同时执行-如何在并发情况下保证三个线程依次执行-如何保证三个线程有序交错进行\",\"76\":\"2#什么是指令重排序\",\"77\":\"2#threadlocal的作用-导致内存泄漏的原因是什么\",\"78\":\"2#使用线程池有什么好处\",\"79\":\"2#线程池中submit-和execute-方法有什么区别\",\"80\":\"2#什么是executors框架\",\"81\":\"2#线程池的拒绝策略\",\"82\":\"2#如何获取子线程的执行结果\",\"83\":\"2#如何对一个字符串快速进行排序\",\"84\":\"2#线程池的参数如何设置\",\"85\":\"2#子线程中如何获取父线程的-threadlocal-中的值、threadlocal-的数据结构\",\"86\":\"2#高并发下-如何保证接口的幂等性\",\"87\":\"2#除了lock和synchronized-还有什么方式可以保障线程安全\",\"88\":\"2#java网络通信\",\"89\":\"2#tcp和udp有什么区别\",\"90\":\"2#tcp为什么是三次握手-而不是两次\",\"91\":\"2#java有哪几种io模型-有什么区别\",\"92\":\"2#java-nio的几个核心组件是什么-分别有什么作用\",\"93\":\"2#select、poll、epoll有什么区别\",\"94\":\"2#http和https的区别\",\"95\":\"2#三次握手和四次挥手\",\"96\":\"2#java虚拟机\",\"97\":\"2#运行时数据区中包含哪些区域-哪些线程共享-哪些线程独享\",\"98\":\"2#java-创建一个对象的过程\",\"99\":\"2#如何访问对象\",\"100\":\"2#java-内存模型的原子性、可见性和有序性是通过哪些操作实现的\",\"101\":\"2#什么是双亲委派机制-有什么作用\",\"102\":\"2#java类加载的全过程是怎么样的\",\"103\":\"2#你了解分代理论吗\",\"104\":\"2#jdk-中有几种引用类型-分别的特点是什么\",\"105\":\"2#一个对象从加载到jvm-再到gc清除-都经历了什么过程\",\"106\":\"2#怎么样确定一个对象不是垃圾\",\"107\":\"2#什么是gc-root\",\"108\":\"2#jvm有哪些垃圾回收算法\",\"109\":\"2#什么是stw\",\"110\":\"2#jvm有哪些垃圾回收器\",\"111\":\"2#什么是三色标记算法\",\"112\":\"2#如何回收方法区\",\"113\":\"2#jvm-中的安全点和安全区各代表什么\",\"114\":\"2#写屏障你了解吗\",\"115\":\"2#解决并发扫描时对象消失问题的两种方案\",\"116\":\"2#cms-垃圾收集器的步骤\",\"117\":\"2#cms-有什么缺点\",\"118\":\"2#g1垃圾收集器的步骤-g1有什么优缺点\",\"119\":\"2#讲一下内存分配策略\",\"120\":\"2#内存溢出和内存泄漏的区别\",\"121\":\"2#如何进行jvm调优\",\"122\":\"2#jvm参数有哪些\",\"123\":\"2#虚拟机基础故障处理工具有哪些\",\"124\":\"2#怎么查看一个java进程的jvm参数-谈谈你了解的jvm参数\",\"125\":\"2#什么情况下堆内存会溢出-什么情况方法区会内存溢出\",\"126\":\"2#jdk8-为什么要将永久代改为元空间\",\"127\":\"2#redis\",\"128\":\"2#redis支持哪些数据类型\",\"129\":\"2#什么是缓存穿透-缓存击穿-缓存雪崩-怎么解决\",\"130\":\"2#缓存穿透\",\"131\":\"2#缓存击穿\",\"132\":\"2#缓存雪崩\",\"133\":\"2#如何保证redis与数据库的数据一致\",\"134\":\"2#先删缓存-再写数据库\",\"135\":\"2#先写数据库-再删缓存\",\"136\":\"2#如何设计一个分布式锁-如何对锁性能进行优化\",\"137\":\"2#redis的过期删除策略\",\"138\":\"2#rdb操作-子进程会全部复制父进程的数据吗\",\"139\":\"2#redis的哨兵模式\",\"140\":\"2#redis使用单线程为什么速度这么快\",\"141\":\"2#redis自增命令使用\",\"142\":\"2#redis如何实现消息队列\",\"143\":\"2#redisson实现分布式锁的原理\",\"144\":\"2#redis为什么能通过lua脚本保证并发的线程安全\",\"145\":\"2#谈一下redis事务的了解\",\"146\":\"2#pipeline有什么好处-为什么要用pipeline\",\"147\":\"2#redis延迟队列怎么实现的\",\"148\":\"2#redis在内存不足时-内存淘汰策略是怎么样的\",\"149\":\"2#如何保证redis的高可用\",\"150\":\"2#mysql\",\"151\":\"2#mysql有哪几种数据存储引擎\",\"152\":\"2#什么是脏读、不可重复读、幻读\",\"153\":\"2#事务的基本特性和隔离级别\",\"154\":\"2#mysql的锁有哪些-什么是间隙锁\",\"155\":\"2#mysql索引结构是什么样的\",\"156\":\"2#mysql的索引结构为什么使用b-树\",\"157\":\"2#聚簇索引和非聚簇索引有什么区别\",\"158\":\"2#mysql主键索引和普通索引有什么区别\",\"159\":\"2#mysql的索引覆盖和回表是什么\",\"160\":\"2#mysql集群是如何搭建的-读写分离是怎么做的\",\"161\":\"2#mysql如何进行分库分表-多大数据量需要进行分库分表-分库分表的方式和分片策略由哪些-分库分表后-sql语句执行流程是怎样的\",\"162\":\"2#mysql的三种删除方式的区别\",\"163\":\"2#慢sql的优化思路\",\"164\":\"2#limit语句会扫描全表吗\",\"165\":\"2#大数量分页查询该怎么优化\",\"166\":\"2#平时项目里面表结构是如何进行设计的\",\"167\":\"2#mysql的索引类型\",\"168\":\"2#mysql如何快速插入千万级数据\",\"169\":\"2#elasticsearch\",\"170\":\"2#什么是倒排索引-有什么好处\",\"171\":\"2#搜索引擎为什么mysql查询快\",\"172\":\"2#es了解多少-说说你们公司的es集群架构。\",\"173\":\"2#如何进行中文分词\",\"174\":\"2#es写入数据与查询数据的原理。\",\"175\":\"2#es部署时-要如何进行优化\",\"176\":\"2#spring面试题\",\"177\":\"2#spring框架中bean的创建过程是怎样的\",\"178\":\"2#spring中bean的作用域\",\"179\":\"2#spring框架中的bean是线程安全的吗-如果线程不安全-如何处理\",\"180\":\"2#spring是如何处理循环依赖问题的\",\"181\":\"2#spring如何处理事务\",\"182\":\"2#spring事务失效的场景有哪些\",\"183\":\"2#spring-mvc中的控制器是不是单例模式-如果是-如何保证线程安全\",\"184\":\"2#spring-mvc原理\",\"185\":\"2#spring中的service有多个实现类-怎么注入\",\"186\":\"2#springboot面试题\",\"187\":\"2#为什么springboot的-jar可以直接运行\",\"188\":\"2#springboot自动装配过程及实现原理\",\"189\":\"2#springboot如何防止表单重复提交\",\"190\":\"2#如何自己写一个springboot-starter\",\"191\":\"2#mybatis面试题\",\"192\":\"2#mybatis接口-mapper内的方法为什么不能重载\",\"193\":\"2#mybatis的xml映射文件中-不同的xml映射文件-id是否可以重复\",\"194\":\"2#和-的区别是什么\",\"195\":\"2#当实体类中的属性名和表中的字段名不一样怎么办\",\"196\":\"2#执行插入语句后如何该数据的主键\",\"197\":\"2#模糊查询like语句该怎么写\",\"198\":\"2#mybatis时如何进行分页的-分页插件的原理是什么\",\"199\":\"2#mybatis有哪些动态sql标签\",\"200\":\"2#mybtais动态sql有什么用-执行原理是什么\",\"201\":\"2#mapper编写有哪几种方式\",\"202\":\"2#mybatis的一级、二级缓存\",\"203\":\"2#mybatis有二级缓存-为什么还要用redis\",\"204\":\"2#mybatis如何开启二级缓存\",\"205\":\"2#netty面试题\",\"206\":\"2#netty有哪些应用场景\",\"207\":\"2#netty核心组件有哪些-分别有什么作用\",\"208\":\"2#eventloopgroup了解么-和eventloop什么关系\",\"209\":\"2#bootstrap和serverbootstrap了解么\",\"210\":\"2#nioeventloopgroup默认的构造函数会起多少线程\",\"211\":\"2#netty线程模型了解么\",\"212\":\"2#netty服务端和客户端的启动过程了解么\",\"213\":\"2#netty长连接、心跳机制了解么\",\"214\":\"2#netty的零拷贝了解么\",\"215\":\"2#网络安全\",\"216\":\"2#什么是认证和授权-如何设计一个权限认证框架\",\"217\":\"2#cookie和session有什么区别-如果没有cookie、seesion还能进行身份验证吗\",\"218\":\"2#什么是csrf攻击-如何防止\",\"219\":\"2#什么是oauth2-有哪几种认证方式\",\"220\":\"2#什么是jwt令牌-和普通令牌有什么区别\",\"221\":\"2#什么是sso-与oauth2-0有什么关系\",\"222\":\"2#如何实现单点登录系统\",\"223\":\"2#微服务\",\"224\":\"2#谈谈你对微服务的理解-微服务有哪些优缺点\",\"225\":\"2#springcloud和springcloudalibaba有哪些组件-都解决了什么问题\",\"226\":\"2#springcloud和dubbo的区别\",\"227\":\"2#分布式事务如何处理-怎么保证事务一致性\",\"228\":\"2#怎么拆分微服务-怎样设计出高内聚、低耦合的微服务\",\"229\":\"2#有没有了解通过ddd领域驱动设计\",\"230\":\"2#微服务的链路追踪、持续集成、ab发布要怎么做\",\"231\":\"2#nacos和eureka的区别\",\"232\":\"2#nacos配置中心-本地resource-jar包中同级目录的配置文件加载优先级\",\"233\":\"2#nacos的配置动态更新原理\",\"234\":\"2#使用nacos配置中心-value对应的配置项如何动态更新\",\"235\":\"2#nacos中命名空间和分组的概念及区别\",\"236\":\"2#nacos同一个namespace中的不同的group注册的服务可以相互访问吗\",\"237\":\"2#nacos服务注册的流程是怎么样的\",\"238\":\"2#微服务下服务a调用服务b的流程\",\"239\":\"2#注册中心-如何通过服务名找到服务实例\",\"240\":\"2#熔断和限流有什么区别\",\"241\":\"2#雪花算法有什么缺点\",\"242\":\"2#gateway有哪些功能-如何配置动态路由\",\"243\":\"2#如何手写一个注册中心\",\"244\":\"2#消息队列\",\"245\":\"2#mq有什么用-有哪些具体的使用场景\",\"246\":\"2#如何进行产品选型\",\"247\":\"2#如何保证消息不丢失\",\"248\":\"2#如何保证消费幂等性\",\"249\":\"2#mq如何保证消息顺序\",\"250\":\"2#如何保证消息的高效读写\",\"251\":\"2#mq-中消费时-业务逻辑出现异常怎么办\",\"252\":\"2#使用mq如何保证分布式事务的最终一致性\",\"253\":\"2#kafka如何避免重复消费\",\"254\":\"2#linux命令\",\"255\":\"2#使用cat命令如何统计文件中一个字符串出现的频率\",\"256\":\"2#如何查看一个应用的信息\",\"257\":\"2#dokcer命令\",\"258\":\"2#docker常用的命令\",\"259\":\"2#查看所有容器的命令\",\"260\":\"2#nginx\",\"261\":\"2#nginx如何保证高可用\",\"262\":\"2#设计模式\",\"263\":\"2#列举一些jdk中用到的设计模式\",\"264\":\"2#列举一些spring当中用到的设计模式\",\"265\":\"2#项目中有用过设计模式吗\",\"266\":\"2#单例模式有哪些实现方式\",\"267\":\"2#懒汉式\",\"268\":\"2#饿汉式\",\"269\":\"2#双重检查锁\",\"270\":\"2#静态内部类\",\"271\":\"2#枚举类\",\"272\":\"2#单例模式有什么应用场景\",\"273\":\"3\",\"274\":\"4\",\"275\":\"4#什么是操作系统\",\"276\":\"4#操作系统分类\",\"277\":\"4#操作系统的发展史\",\"278\":\"4#计算机组成原理\",\"279\":\"4#cpu\",\"280\":\"4#地址总线\",\"281\":\"4#dram\",\"282\":\"4#计算机的启动过程\",\"283\":\"4#bios\",\"284\":\"4#地址、section、vstart\",\"285\":\"4#地址\",\"286\":\"4#section\",\"287\":\"4#vstart\",\"288\":\"4#cpu的实模式\",\"289\":\"4#cpu的工作原理\",\"290\":\"4#实模式\",\"291\":\"4#硬盘操作\",\"292\":\"4#获取物理内存容量\",\"293\":\"4#内存分页机制\",\"294\":\"4#混合编程\",\"295\":\"4#基本内联混编\",\"296\":\"4#内联编程\",\"297\":\"4#扩展内联混编\",\"298\":\"5\",\"299\":\"5#elaticsearch快速入门\",\"300\":\"5#倒排索引\",\"301\":\"5#elaticsearch简介\",\"302\":\"5#elaticsearch基本概念\",\"303\":\"5#索引\",\"304\":\"5#文档\",\"305\":\"5#索引操作\",\"306\":\"5#文档操作\",\"307\":\"5#es文档批量操作\",\"308\":\"5#elaticsearch高级查询语法query-dsl\",\"309\":\"5#文档映射mapping\",\"310\":\"5#elaticsearch搜索技术与聚合查询\",\"311\":\"5#elaticsearch高阶功能\",\"312\":\"5#elaticsearch集群架构实战及其原理\",\"313\":\"5#logstash与filebeat详解以及efk整合\",\"314\":\"6\",\"315\":\"6#mongodb入门\",\"316\":\"7\",\"317\":\"7#mysql逻辑架构\",\"318\":\"7#连接器\",\"319\":\"7#查询缓存\",\"320\":\"7#分析器\",\"321\":\"7#优化器\",\"322\":\"7#执行器\",\"323\":\"7#sql执行流程\",\"324\":\"7#重做日志\",\"325\":\"7#归档日志\",\"326\":\"7#更新语句执行流程\",\"327\":\"7#两阶段提交\",\"328\":\"7#mysql性能分析工具\",\"329\":\"7#explain-简介\",\"330\":\"7#explain-字段\",\"331\":\"7#索引常见模型\",\"332\":\"7#哈希表\",\"333\":\"7#有序数组\",\"334\":\"7#二叉搜索树\",\"335\":\"7#b-树\",\"336\":\"7#索引的执行流程\",\"337\":\"7#回表\",\"338\":\"7#覆盖索引\",\"339\":\"7#最左前缀原则\",\"340\":\"7#索引下推\",\"341\":\"7#普通索引和唯一索引\",\"342\":\"7#查询过程\",\"343\":\"7#更新过程\",\"344\":\"7#change-buffer详解\",\"345\":\"7#change-buffer和redo-log\",\"346\":\"7#索引的选择\",\"347\":\"7#优化器逻辑\",\"348\":\"7#索引选择异常和处理\",\"349\":\"7#字符串添加索引\",\"350\":\"7#前缀索引\",\"351\":\"7#前缀索引与覆盖索引\",\"352\":\"7#其它方式\",\"353\":\"7#order-by与索引\",\"354\":\"7#全字段排序\",\"355\":\"7#rowid排序\",\"356\":\"7#全字段排序和rowid排序对比\",\"357\":\"7#索引的创建时机\",\"358\":\"7#哪些情况需要建索引\",\"359\":\"7#哪些情况不要建索引\",\"360\":\"7#索引的最佳实践\",\"361\":\"7#单表索引分析\",\"362\":\"7#两表索引分析\",\"363\":\"7#三张表索引分析\",\"364\":\"7#结论\",\"365\":\"7#索引失效\",\"366\":\"7#函数操作\",\"367\":\"7#隐式类型转换\",\"368\":\"7#隐式字符编码转换\",\"369\":\"7#索引失效的场景\",\"370\":\"7#最佳左前缀法则\",\"371\":\"7#索引列上不计算\",\"372\":\"7#范围之后全失效\",\"373\":\"7#覆盖索引尽量用\",\"374\":\"7#不等有时会失效\",\"375\":\"7#like百分加右边\",\"376\":\"7#字符要加单引号\",\"377\":\"7#索引相关题目\",\"378\":\"7#面试题分析\",\"379\":\"7#索引失效的原理分析\",\"380\":\"7#索引失效的总结\",\"381\":\"7#慢查询基础\",\"382\":\"7#请求多余的数据\",\"383\":\"7#查询不需要的记录\",\"384\":\"7#多表关联时返回全部列\",\"385\":\"7#总是取出全部列\",\"386\":\"7#重复查询相同的数据\",\"387\":\"7#扫描额外的记录\",\"388\":\"7#响应时间\",\"389\":\"7#扫描的行数和返回的行数\",\"390\":\"7#扫描的行数和访问类型\",\"391\":\"7#重构查询\",\"392\":\"7#复杂查询-or-简单查询\",\"393\":\"7#切分查询\",\"394\":\"7#分解关联查询\",\"395\":\"7#count-优化\",\"396\":\"7#count-的实现\",\"397\":\"7#使用缓存系统保存计数\",\"398\":\"7#在数据库中保存计数\",\"399\":\"7#不同count的用法\",\"400\":\"7#join语句的优化\",\"401\":\"7#index-nested-loop-join\",\"402\":\"7#simple-nested-loop-join\",\"403\":\"7#block-nested-loop-join\",\"404\":\"7#multi-range-read-优化\",\"405\":\"7#batched-key-access\",\"406\":\"7#bnl算法的性能问题\",\"407\":\"7#bnl转bka\",\"408\":\"7#hash-join\",\"409\":\"7#mysql中的临时表\",\"410\":\"7#临时表的特性\",\"411\":\"7#临时表的应用\",\"412\":\"7#重命名临时表\",\"413\":\"7#临时表和主备复制\",\"414\":\"7#使用临时表优化查询\",\"415\":\"7#group-by语句的优化\",\"416\":\"7#group-by执行流程\",\"417\":\"7#使用索引优化group-by语句\",\"418\":\"7#直接排序优化group-by语句\",\"419\":\"7#order-by-rand-优化\",\"420\":\"7#内存临时表\",\"421\":\"7#磁盘临时表\",\"422\":\"7#随机排序法\",\"423\":\"7#分区表\",\"424\":\"7#分区表简介\",\"425\":\"7#分区策略\",\"426\":\"7#分区表的应用场景\",\"427\":\"7#慢查询日志\",\"428\":\"7#基本介绍\",\"429\":\"7#日志分析工具\",\"430\":\"7#分析慢sql的步骤\",\"431\":\"7#show-profile\",\"432\":\"7#事务隔离\",\"433\":\"7#隔离性和隔离级别\",\"434\":\"7#事务隔离的实现\",\"435\":\"7#事务的启动方式\",\"436\":\"7#全局锁\",\"437\":\"7#全局锁的特点\",\"438\":\"7#全局锁对比\",\"439\":\"7#表级别的锁\",\"440\":\"7#表锁\",\"441\":\"7#元数据锁\",\"442\":\"7#行锁\",\"443\":\"7#两阶段锁\",\"444\":\"7#死锁和死锁检测\",\"445\":\"7#间隙锁\",\"446\":\"7#幻读\",\"447\":\"7#幻读的问题\",\"448\":\"7#间隙锁-1\",\"449\":\"7#防止数据丢失\",\"450\":\"7#bin-log的写入机制\",\"451\":\"7#redo-log的写入机制\",\"452\":\"7#主备一致\",\"453\":\"7#主备的基本原理\",\"454\":\"7#bin-log的三种格式\",\"455\":\"7#循环复制问题\",\"456\":\"7#主备延迟\",\"457\":\"7#主备延迟及其来源\",\"458\":\"7#可靠性优先策略\",\"459\":\"7#可用性优先策略\",\"460\":\"7#并行复制\",\"461\":\"7#按表分发策略\",\"462\":\"7#按行分发策略\",\"463\":\"7#mysql-5-7的并行复制策略\",\"464\":\"7#mariadb的并行复制策略\",\"465\":\"7#mysql-5-7的并行复制策略-1\",\"466\":\"7#一主多从\",\"467\":\"7#基于位点的主备切换\",\"468\":\"7#gtid\",\"469\":\"7#读写分离\",\"470\":\"7#强制走主库方案\",\"471\":\"7#sleep-方案\",\"472\":\"7#判断主备无延迟方案\",\"473\":\"7#等主库位点方案\",\"474\":\"7#gid方案\",\"475\":\"7#可用性判断\",\"476\":\"7#select-1判断\",\"477\":\"7#查表判断\",\"478\":\"7#更新判断\",\"479\":\"7#内部统计\",\"480\":\"7#kill命令\",\"481\":\"7#kill命令的执行过程\",\"482\":\"7#客户端缓存\",\"483\":\"7#误删数据\",\"484\":\"7#误删行\",\"485\":\"7#误删库-表\",\"486\":\"7#延迟复制备库\",\"487\":\"7#预防误删库-表的方法\",\"488\":\"7#rm删除数据\",\"489\":\"7#自增主键\",\"490\":\"7#自增主键的存储\",\"491\":\"7#自增值的修改\",\"492\":\"7#自增锁的优化\",\"493\":\"7#自增主键的上限\",\"494\":\"7#表定义自增值id\",\"495\":\"7#innodb系统自增row-id\",\"496\":\"7#xid\",\"497\":\"7#innodb-trx-id\",\"498\":\"7#thread-id\",\"499\":\"7#自增主键总结\",\"500\":\"8\",\"501\":\"8#mysql索引结构\",\"502\":\"8#b-tree\",\"503\":\"8#b-tree-1\",\"504\":\"8#hash\",\"505\":\"8#索引实现\",\"506\":\"8#explain详解\",\"507\":\"8#explain中的列\",\"508\":\"8#id列\",\"509\":\"8#type列\",\"510\":\"8#最佳实践\",\"511\":\"8#sql执行底层原理\",\"512\":\"8#连接器\",\"513\":\"8#词法分析器\",\"514\":\"8#优化器\",\"515\":\"8#执行器\",\"516\":\"8#bin-log归档\",\"517\":\"8#索引优化实践\",\"518\":\"8#索引下推\",\"519\":\"8#如何选择合适的索引\",\"520\":\"8#常见sql优化\",\"521\":\"8#索引设计原则\",\"522\":\"8#分页查询优化\",\"523\":\"8#join关联查询优化\",\"524\":\"8#嵌套循环连接算法\",\"525\":\"8#基于块的嵌套循环查询\",\"526\":\"8#count-查询优化\",\"527\":\"8#mysql数据类型的选择\",\"528\":\"8#数值类型\",\"529\":\"8#日期和时间\",\"530\":\"8#字符串\",\"531\":\"8#mysql事务与锁\",\"532\":\"8#事务及其属性\",\"533\":\"8#mysql中的锁的分类\",\"534\":\"8#表锁\",\"535\":\"8#行锁\",\"536\":\"8#间隙锁\",\"537\":\"8#临键锁\",\"538\":\"8#行锁分析\",\"539\":\"8#锁优化建议\",\"540\":\"8#mvcc与bufferpool缓冲机制\",\"541\":\"8#mvcc机制\",\"542\":\"8#undo日志版本链与read-view机制详解\",\"543\":\"8#bufferpool缓存机制\",\"544\":\"8#mysql成本分析\",\"545\":\"8#mysql查询成本\",\"546\":\"8#单表查询的成本\",\"547\":\"8#根据搜索条件-找出所有可能使用的索引\",\"548\":\"8#计算全表扫描的代价\",\"549\":\"8#计算使用不同索引执行查询的代价\",\"550\":\"8#是否有可能使用索引合并\",\"551\":\"8#对比各种方案-找出成本最低的那一个\",\"552\":\"8#基于索引统计数据的成本\",\"553\":\"8#index-dive\",\"554\":\"8#连接查询的成本\",\"555\":\"8#两表连接的成本分析\",\"556\":\"8#多表连接的成本分析\",\"557\":\"8#调节成本常数\",\"558\":\"8#innodb中的统计数据\",\"559\":\"8#更新统计数据\",\"560\":\"8#表结构设计\",\"561\":\"8#mysql-redo日志\",\"562\":\"9\",\"563\":\"9#概述\",\"564\":\"9#redis是什么\",\"565\":\"9#redis能该干什么\",\"566\":\"9#核心特性\",\"567\":\"9#基础知识\",\"568\":\"9#五大数据类型\",\"569\":\"9#redis-key\",\"570\":\"9#string-字符串\",\"571\":\"9#list-列表\",\"572\":\"9#set-集合\",\"573\":\"9#hash-哈希\",\"574\":\"9#zset-有序集合\",\"575\":\"9#三种特殊数据类型\",\"576\":\"9#geospatial-地理位置\",\"577\":\"9#hyperloglog-基数统计\",\"578\":\"9#bitmaps-位图\",\"579\":\"9#操作过程\",\"580\":\"9#事务错误\",\"581\":\"9#监控\",\"582\":\"9#jedis\",\"583\":\"9#springboot整合\",\"584\":\"9#自定义redis工具类\",\"585\":\"9#rdb持久化\",\"586\":\"9#什么是rdb\",\"587\":\"9#工作原理\",\"588\":\"9#bgsave\",\"589\":\"9#bgsave和save对比\",\"590\":\"9#优点和缺点\",\"591\":\"9#持久化aof\",\"592\":\"9#什么是aof\",\"593\":\"9#优点和缺点-1\",\"594\":\"9#rdb和aop选择\",\"595\":\"9#rdb-和-aof-对比\",\"596\":\"9#如何选择使用哪种持久化方式\",\"597\":\"9#命令\",\"598\":\"9#示例\",\"599\":\"9#原理\",\"600\":\"9#缺点\",\"601\":\"9#应用\",\"602\":\"9#非阻塞io\",\"603\":\"9#多路复用\",\"604\":\"9#指令队列\",\"605\":\"9#响应队列\",\"606\":\"9#概念\",\"607\":\"9#作用\",\"608\":\"9#为什么使用集群\",\"609\":\"9#环境配置\",\"610\":\"9#一主二从配置\",\"611\":\"9#使用规则\",\"612\":\"9#复制原理\",\"613\":\"9#复制过程\",\"614\":\"9#数据同步\",\"615\":\"9#全量复制\",\"616\":\"9#部分复制\",\"617\":\"9#心跳\",\"618\":\"9#异步复制\",\"619\":\"9#作用-1\",\"620\":\"9#单机单个哨兵\",\"621\":\"9#多哨兵模式\",\"622\":\"9#哨兵模式优缺点\",\"623\":\"9#优点\",\"624\":\"9#缺点-1\",\"625\":\"9#缓存穿透\",\"626\":\"9#概念-1\",\"627\":\"9#解决方案\",\"628\":\"9#缓存击穿\",\"629\":\"9#概念-2\",\"630\":\"9#解决方案-1\",\"631\":\"9#缓存雪崩\",\"632\":\"9#概念-3\",\"633\":\"9#解决方案-2\",\"634\":\"10\",\"635\":\"10#dubbo底层实现原理\",\"636\":\"10#dubbo3-0新特性\",\"637\":\"10#dubbo协议\",\"638\":\"10#triple协议\",\"639\":\"10#dubbo服务注册与引入底层原理\",\"640\":\"10#服务导出\",\"641\":\"10#服务引入\",\"642\":\"10#dubbo服务调用底层原理\",\"643\":\"10#http2原理解析\",\"644\":\"11\",\"645\":\"11#mybatis源码体系\",\"646\":\"11#数据操作过程源码剖析\",\"647\":\"12\",\"648\":\"12#netty特点\",\"649\":\"12#作用\",\"650\":\"12#良好的设计\",\"651\":\"12#使用简单\",\"652\":\"12#性能\",\"653\":\"12#安全\",\"654\":\"12#netty架构实现\",\"655\":\"12#netty的hello-world\",\"656\":\"12#netty模块分析\",\"657\":\"12#netty整体执行流程分析\",\"658\":\"12#netty对socket的实现\",\"659\":\"12#socket使用示例\",\"660\":\"12#消息的广播\",\"661\":\"12#心跳机制\",\"662\":\"12#netty与websocket\",\"663\":\"12#实现与原理分析\",\"664\":\"12#websocket生命周期分解\",\"665\":\"12#google-protobuf\",\"666\":\"12#简介\",\"667\":\"12#proto文件\",\"668\":\"12#解析和序列化\",\"669\":\"12#编写message\",\"670\":\"12#读取message\",\"671\":\"12#多协议消息\",\"672\":\"12#最佳实践\",\"673\":\"12#apache-thrift\",\"674\":\"12#简介-1\",\"675\":\"12#thrift文件\",\"676\":\"12#最佳实践-1\",\"677\":\"12#传输格式\",\"678\":\"12#传输方式\",\"679\":\"12#服务模型\",\"680\":\"12#多语言的支持\",\"681\":\"12#grpc\",\"682\":\"12#简介-2\",\"683\":\"12#相关示例\",\"684\":\"12#流式调用\",\"685\":\"12#io与nio\",\"686\":\"12#io与nio的区别\",\"687\":\"12#buffer\",\"688\":\"12#channel\",\"689\":\"12#selector\",\"690\":\"12#nio网络编程\",\"691\":\"12#字符编码集\",\"692\":\"12#零拷贝\",\"693\":\"12#传统的io流程\",\"694\":\"12#零拷贝实现原理\",\"695\":\"12#eventloopgroup\",\"696\":\"12#netty中的future对象\",\"697\":\"12#channelfuture\",\"698\":\"12#异步读写架构\",\"699\":\"12#promise\",\"700\":\"12#serverbootstrap\",\"701\":\"12#核心方法\",\"702\":\"12#初始化和注册方法\",\"703\":\"12#reactor模式\",\"704\":\"12#传统的模型\",\"705\":\"12#reactor模式-1\",\"706\":\"12#netty中的reactor线程模型\",\"707\":\"12#自适应缓冲区\",\"708\":\"12#channel实现原理\",\"709\":\"12#channel的四大组件\",\"710\":\"12#channel与channelpipeline\",\"711\":\"12#channeloption与attributekey\",\"712\":\"12#channelhandler与channelhandlercontext\",\"713\":\"12#channel选择器\",\"714\":\"12#channel注册流程\",\"715\":\"12#netty中的设计原则\",\"716\":\"12#设计原则\",\"717\":\"12#业务线程池\",\"718\":\"12#bytebuf实现原理\",\"719\":\"12#bytebuf使用示例\",\"720\":\"12#bytebuf数据结构\",\"721\":\"12#复合缓冲区\",\"722\":\"12#引用计数\",\"723\":\"12#实现原理\",\"724\":\"12#atomicintegerfieldupdater\",\"725\":\"12#netty中的处理器\",\"726\":\"12#自定义编解码器\",\"727\":\"12#replayingdecoder\",\"728\":\"12#lengthfieldbasedframedecoder\",\"729\":\"12#常见编解码器总结\",\"730\":\"12#tcp粘包与拆包\",\"731\":\"12#粘包与拆包\",\"732\":\"12#解决方案\",\"733\":\"12#观察者模式\",\"734\":\"12#适配器模式\",\"735\":\"12#模板方法模式\",\"736\":\"13\",\"737\":\"13#知识储备\",\"738\":\"13#java-基础部分\",\"739\":\"13#oop-部分\",\"740\":\"13#gof23-设计模式\",\"741\":\"13#spring-核心基础\",\"742\":\"13#oop局限性\",\"743\":\"13#aop常见使用场景\",\"744\":\"13#日志场景\",\"745\":\"13#统计场景\",\"746\":\"13#安防场景\",\"747\":\"13#性能场景\",\"748\":\"13#java-aop设计模式\",\"749\":\"13#代理模式\",\"750\":\"13#判断模式\",\"751\":\"13#拦截模式\",\"752\":\"13#spring-aop-功能概述\",\"753\":\"13#aop设计核心\",\"754\":\"13#spring-aop编程模型\",\"755\":\"13#spring-aop-advice类型\",\"756\":\"13#spring-aop代理实现\",\"757\":\"13#jdk动态代理\",\"758\":\"13#cglib动态代理\",\"759\":\"13#aspectj代理\",\"760\":\"13#面试题\",\"761\":\"13#spring-aop和aspectj-aop存在哪些差别\",\"762\":\"13#aspectj注解驱动\",\"763\":\"13#编程方式创建-aspectj代理\",\"764\":\"13#标准工厂api\",\"765\":\"13#aspectj-pointcut指令与表达式\",\"766\":\"13#xml配置pointcut\",\"767\":\"13#api实现pointcut\",\"768\":\"13#aspectj拦截动作\",\"769\":\"13#xml配置around-advice\",\"770\":\"13#aspectj的前置动作\",\"771\":\"13#xml配置before-advice\",\"772\":\"13#api实现before-advice\",\"773\":\"13#aspect后置动作\",\"774\":\"13#xml配置after-advice\",\"775\":\"13#api实现after-advice\",\"776\":\"13#自动动态代理\",\"777\":\"13#替换targetsource\",\"778\":\"13#面试题-1\",\"779\":\"13#spring-aop支持哪些类型的advice\",\"780\":\"13#spring-aop编程模型有哪些-代表组件有哪些\",\"781\":\"13#spring-aop三种实现方式是如何进行设计的\",\"782\":\"13#api整体设计\",\"783\":\"13#接入点接口joinpoint\",\"784\":\"13#joinpoint条件接口\",\"785\":\"13#pointcut组合实现\",\"786\":\"13#pointcut便利实现\",\"787\":\"13#pointcut-aspectj实现\",\"788\":\"13#joinpoint执行动作接口\",\"789\":\"13#before-advice标准实现\",\"790\":\"13#before-advice-aspectj实现\",\"791\":\"13#after-advice标准实现\",\"792\":\"13#after-advice-aspectj实现\",\"793\":\"13#advisor接口\",\"794\":\"13#pointcutadvisor接口\",\"795\":\"13#intorductionadvisor接口\",\"796\":\"13#advisoradapter接口\",\"797\":\"13#aopproxy接口\",\"798\":\"13#aopproxyfactory\",\"799\":\"13#jdk-aopproxy实现\",\"800\":\"13#cglib-aopproxy实现\",\"801\":\"13#advisedsupport\",\"802\":\"13#advisorchainfactory接口\",\"803\":\"13#targetsource接口\",\"804\":\"13#proxycreatorsupport\",\"805\":\"13#advisedsupportlistener\",\"806\":\"13#proxyfactory\",\"807\":\"13#proxyfactorybean\",\"808\":\"13#aspectjproxyfactory\",\"809\":\"13#abstractautoproxycreator\",\"810\":\"13#ioc容器自动代理标准实现\",\"811\":\"13#aspectjawareadvisorautoproxycreator\",\"812\":\"13#aopinfrastructurebean接口\",\"813\":\"13#aopcontext\",\"814\":\"13#aopproxyutils\",\"815\":\"13#aoputils\",\"816\":\"13#aspectj-enable模块驱动\",\"817\":\"13#aspectj-xml配置驱动实现\",\"818\":\"13#aop-config-schema-based实现\",\"819\":\"13#aop-aspect-schema-based实现\",\"820\":\"13#pointcut-schema-based实现\",\"821\":\"13#around-advice-schema-based实现\",\"822\":\"13#before-advice-schema-based实现\",\"823\":\"13#after-advice-schema-based实现\",\"824\":\"13#after-returning-advice-schema-based实现\",\"825\":\"13#after-throwing-advice-schema-based实现\",\"826\":\"13#advisor-schema-based实现\",\"827\":\"13#introduction-schema-based实现\",\"828\":\"13#作用域代理schema-based实现\",\"829\":\"13#面试题-2\",\"830\":\"13#spring-aop-advice-xml标签有哪些\",\"831\":\"13#请解释spring-enbaleaspectjautoproxy的原理\",\"832\":\"13#spring-configuration-class-cglib提升与aop类代理的关系\",\"833\":\"13#创建型模式\",\"834\":\"13#抽象工厂模式\",\"835\":\"13#构建器模式\",\"836\":\"13#工厂方法模式\",\"837\":\"13#原型模式\",\"838\":\"13#单例模式\",\"839\":\"13#结构型模式\",\"840\":\"13#适配器模式\",\"841\":\"13#组合模式\",\"842\":\"13#装饰器模式\",\"843\":\"13#享元模式\",\"844\":\"13#代理模式-1\",\"845\":\"13#行为型模式\",\"846\":\"13#模板方法模式\",\"847\":\"13#责任链模式\",\"848\":\"13#观察者模式\",\"849\":\"13#策略模式\",\"850\":\"13#命令模式\",\"851\":\"13#状态模式\",\"852\":\"13#面试题-3\",\"853\":\"13#gof-23设计模式和它的归类\",\"854\":\"13#举例装饰器模式和代理模式的区别\",\"855\":\"13#请举例说明spring-framework中使用设计模式的实现\",\"856\":\"13#spring-事件中的应用\",\"857\":\"13#spring事务中的应用\",\"858\":\"13#核心api\",\"859\":\"13#理解transactiondefinition\",\"860\":\"13#理解platformtransactionmanager\",\"861\":\"13#理解事务传播\",\"862\":\"13#spring-缓存中的应用\",\"863\":\"13#spring本地调度中的应用\",\"864\":\"13#面试题-4\",\"865\":\"13#spring-aop在spring-framework特性运用\",\"866\":\"13#spring事务传播的原理\",\"867\":\"13#spring-aop与ioc功能整合的设计模式\",\"868\":\"14\",\"869\":\"14#springbootapplication\",\"870\":\"14#注解解析\",\"871\":\"14#configuration\",\"872\":\"14#componentscan\",\"873\":\"14#enableautoconfiguration\",\"874\":\"14#启动执行流程\",\"875\":\"14#流程概览\",\"876\":\"14#启动详情\",\"877\":\"14#自动装配\",\"878\":\"14#打包过程\",\"879\":\"14#构建工具\",\"880\":\"14#spring-boot-maven-plugin\",\"881\":\"14#spotify-maven-plugin\",\"882\":\"14#jib-maven-plugin\",\"883\":\"14#修改之前\",\"884\":\"14#使用alpine镜像\",\"885\":\"14#分层构建镜像\",\"886\":\"14#maven中内置变量\",\"887\":\"14#可能存在的问题\",\"888\":\"15\",\"889\":\"16\",\"890\":\"16#spring特性总览\",\"891\":\"16#spring-中值得学习的地方\",\"892\":\"16#spring核心特性\",\"893\":\"16#spring数据存储\",\"894\":\"16#spring-web技术\",\"895\":\"16#spring技术整合\",\"896\":\"16#spring测试\",\"897\":\"16#spring版本特性\",\"898\":\"16#spring模块化设计\",\"899\":\"16#spring编程模型\",\"900\":\"16#spring的核心价值\",\"901\":\"16#面试题\",\"902\":\"16#什么是spring-framework\",\"903\":\"16#spring-framwork有哪些核心模块\",\"904\":\"16#spring-framework的优势和不足是什么\",\"905\":\"16#ioc的发展简介\",\"906\":\"16#ioc主要实现策略\",\"907\":\"16#ioc容器的职责\",\"908\":\"16#ioc的实现\",\"909\":\"16#传统ioc容器的实现\",\"910\":\"16#如何界定ioc容器是轻量级的\",\"911\":\"16#依赖查找和依赖注入\",\"912\":\"16#构造器注入和setter注入\",\"913\":\"16#面试题-1\",\"914\":\"16#什么是ioc\",\"915\":\"16#依赖查找和依赖注入的区别\",\"916\":\"16#spring作为ioc容器有什么优势\",\"917\":\"16#spring-ioc依赖查找\",\"918\":\"16#spring-ioc依赖注入\",\"919\":\"16#spring依赖注入和依赖查找的来源\",\"920\":\"16#spring-ioc配置元信息\",\"921\":\"16#beanfactory和applicationcontext\",\"922\":\"16#spring-ioc容器生命周期\",\"923\":\"16#面试题-2\",\"924\":\"16#什么是spring-ioc容器\",\"925\":\"16#beanfactory和factorybean\",\"926\":\"16#spring-ioc容器启动时做了哪些准备\",\"927\":\"16#beandefinition\",\"928\":\"16#spring-bean命名\",\"929\":\"16#beandefinition注册到ioc容器\",\"930\":\"16#实例化bean的方式\",\"931\":\"16#初始化bean的方式\",\"932\":\"16#延迟初始化bean\",\"933\":\"16#销毁bean\",\"934\":\"16#垃圾回收spring-bean\",\"935\":\"16#面试题-3\",\"936\":\"16#如何注册一个spring-bean\",\"937\":\"16#什么是spring-beandefinition\",\"938\":\"16#spring容器是怎样管理注册bean\",\"939\":\"16#依赖查找简介\",\"940\":\"16#单一类型依赖查找\",\"941\":\"16#集合类型依赖查找\",\"942\":\"16#层次性依赖查找\",\"943\":\"16#延迟依赖查找\",\"944\":\"16#安全依赖查找\",\"945\":\"16#内建可查找的依赖\",\"946\":\"16#依赖查找中典型异常\",\"947\":\"16#面试题-4\",\"948\":\"16#objectfactory与beanfactory的区别\",\"949\":\"16#beanfactory-getbean操作是否线程安全\",\"950\":\"16#spring的依赖查找和依赖注入在来源上有什么区别\",\"951\":\"16#依赖注入的模式和类型\",\"952\":\"16#自动绑定\",\"953\":\"16#setter注入\",\"954\":\"16#构造器注入\",\"955\":\"16#字段注入\",\"956\":\"16#方法注入\",\"957\":\"16#接口回调注入\",\"958\":\"16#依赖注入类型选择\",\"959\":\"16#基础类型注入\",\"960\":\"16#集合类型注入\",\"961\":\"16#限定注入\",\"962\":\"16#延迟依赖注入\",\"963\":\"16#依赖处理的过程\",\"964\":\"16#autowird注入\",\"965\":\"16#inject和-autowired联系\",\"966\":\"16#java通用注解原理\",\"967\":\"16#自定义依赖注入注解\",\"968\":\"16#面试题-5\",\"969\":\"16#有多少种依赖注入的方式\",\"970\":\"16#你偏好构造器注入还是setter注入\",\"971\":\"16#spring依赖注入的来源有哪些\",\"972\":\"16#依赖查找的来源\",\"973\":\"16#依赖注入的来源\",\"974\":\"16#spring容器管理和游离对象\",\"975\":\"16#spring-beandefinition作为依赖来源\",\"976\":\"16#单体对象作为依赖来源\",\"977\":\"16#resolvable-dependency作为依赖来源\",\"978\":\"16#外部化配置作为依赖来源\",\"979\":\"16#面试题-6\",\"980\":\"16#依赖注入和依赖查找的依赖来源是否相同\",\"981\":\"16#单例对象能在ioc容器启动后注册吗\",\"982\":\"16#spring依赖注入的来源有哪些-1\",\"983\":\"16#作用域简介\",\"984\":\"16#singleton作用域\",\"985\":\"16#prototype作用域\",\"986\":\"16#request作用域\",\"987\":\"16#session作用域\",\"988\":\"16#application作用域\",\"989\":\"16#自定义bean作用域\",\"990\":\"16#面试题-7\",\"991\":\"16#spring内建的bean的作用域有几种\",\"992\":\"16#singleton-bean是否在一个应用中是唯一的\",\"993\":\"16#application-bean是否被其他方案他替代\",\"994\":\"16#元信息配置阶段\",\"995\":\"16#元信息解析阶段\",\"996\":\"16#注册阶段\",\"997\":\"16#beandefinition合并阶段\",\"998\":\"16#bean-class加载阶段\",\"999\":\"16#实例化\",\"1000\":\"16#实例化前阶段\",\"1001\":\"16#实例化阶段\",\"1002\":\"16#bean实例化后阶段\",\"1003\":\"16#属性赋值前阶段\",\"1004\":\"16#初始化\",\"1005\":\"16#接口回调阶段\",\"1006\":\"16#初始化前阶段\",\"1007\":\"16#初始化阶段\",\"1008\":\"16#初始化后阶段\",\"1009\":\"16#初始化完成阶段\",\"1010\":\"16#销毁阶段\",\"1011\":\"16#销毁前阶段\",\"1012\":\"16#销毁阶段-1\",\"1013\":\"16#bean垃圾收集\",\"1014\":\"16#面试题-8\",\"1015\":\"16#beanpostprocess使用场景有哪些\",\"1016\":\"16#beanfactorypostprocess与beanpostprocess的区别\",\"1017\":\"16#beanfactory是怎样处理bean生命周期\",\"1018\":\"16#spring-bean配置元信息\",\"1019\":\"16#spring-bean属性元信息\",\"1020\":\"16#spring容器配置元信息\",\"1021\":\"16#基于xml资源装载spring-bean配置元信息\",\"1022\":\"16#基于properties资源装载spring-bean配置元信息\",\"1023\":\"16#基于java注解的spring-bean配置元信息\",\"1024\":\"16#spring-bean配置元信息底层实现\",\"1025\":\"16#xml资源的方式\",\"1026\":\"16#properties资源的方式\",\"1027\":\"16#java注解的方式\",\"1028\":\"16#基于xml资源装载spring-容器配置元信息\",\"1029\":\"16#基于java注解配置spring-容器配置元信息\",\"1030\":\"16#基于extensible-xml-authoring扩展spring-xml元素\",\"1031\":\"16#基于properties资源装载外部化配置\",\"1032\":\"16#基于yml资源装载外部化配置\",\"1033\":\"16#面试题-9\",\"1034\":\"16#spring内建的xml-schema常见有哪些\",\"1035\":\"16#spring配置元信息有哪些\",\"1036\":\"16#extensible-xml-authoring的缺点\",\"1037\":\"16#java标准资源管理\",\"1038\":\"16#resource接口\",\"1039\":\"16#内建的resource实现\",\"1040\":\"16#resource接口扩展\",\"1041\":\"16#spring资源加载器\",\"1042\":\"16#spring通配路径资源加载器\",\"1043\":\"16#spring通配路径资源扩展\",\"1044\":\"16#依赖注入spring-resource\",\"1045\":\"16#依赖注入resourceloader\",\"1046\":\"16#面试题-10\",\"1047\":\"16#spring配置资源中有哪些常见类型\",\"1048\":\"16#请举例不同类型的spring配置资源\",\"1049\":\"16#java标准资源管理扩展的步骤\",\"1050\":\"16#spring国际化接口\",\"1051\":\"16#层次性的messagesource\",\"1052\":\"16#java国际化标准实现\",\"1053\":\"16#java文本格式化\",\"1054\":\"16#messagesource开箱实现\",\"1055\":\"16#message的内建依赖\",\"1056\":\"16#springboot为什么要新建messagesource-bean\",\"1057\":\"16#面试题-11\",\"1058\":\"16#spring国际化接口有哪些\",\"1059\":\"16#spring有哪些messagesource的内建实现\",\"1060\":\"16#如何实现配置自动更新messagesource\",\"1061\":\"16#validator接口设计\",\"1062\":\"16#errors接口设计\",\"1063\":\"16#errors的文案来源\",\"1064\":\"16#自定义validator\",\"1065\":\"16#bean-validation\",\"1066\":\"16#面试题-12\",\"1067\":\"16#spring校验接口是哪个\",\"1068\":\"16#spring有哪些校验核心组件\",\"1069\":\"16#请通过示例演示spring-bean的校验\",\"1070\":\"16#spring-数据绑定组件\",\"1071\":\"16#databinder元数据\",\"1072\":\"16#databinder绑定控制参数\",\"1073\":\"16#spring底层java-beans替换实现\",\"1074\":\"16#beanwrapper使用场景\",\"1075\":\"16#javabeans操作属性\",\"1076\":\"16#databinder数据校验\",\"1077\":\"16#面试题-13\",\"1078\":\"16#spring数据绑定api是什么\",\"1079\":\"16#beanwrapper与javabeans之间的关系是\",\"1080\":\"16#databinder是怎么完成属性类型转换的\",\"1081\":\"16#使用场景\",\"1082\":\"16#基于javabeans接口的类型转换\",\"1083\":\"16#spring内建propertyeditor扩展\",\"1084\":\"16#自定义propertyeditor扩展\",\"1085\":\"16#propertyeditor的局限性\",\"1086\":\"16#spring3-通用类型转换接口\",\"1087\":\"16#spring内建类型转换器\",\"1088\":\"16#converter接口的局限性\",\"1089\":\"16#genericconverter接口\",\"1090\":\"16#优化genericconverter接口\",\"1091\":\"16#扩展spring类型转换器\",\"1092\":\"16#统一类型转换服务\",\"1093\":\"16#conversionservice作为依赖\",\"1094\":\"16#面试题-14\",\"1095\":\"16#spring类型转换实现有哪些\",\"1096\":\"16#spring类型转换器接口有哪些\",\"1097\":\"16#typedescriptor是如何处理泛型\",\"1098\":\"16#java泛型基础\",\"1099\":\"16#java-5类型接口\",\"1100\":\"16#spring泛型类型辅助类\",\"1101\":\"16#泛型集合类型辅助类\",\"1102\":\"16#spring方法参数封装\",\"1103\":\"16#resolvabletype\",\"1104\":\"16#面试题-15\",\"1105\":\"16#java泛型擦写是发生在编译时-还是运行时\",\"1106\":\"16#请介绍java-5-type类型的派生类或接口\",\"1107\":\"16#请说明resolvabletype的设计优势\",\"1108\":\"16#java事件-监听器编程模型\",\"1109\":\"16#面向接口的事件-监听器设计模式\",\"1110\":\"16#面向注解的事件-监听器设计模式\",\"1111\":\"16#spring标准事件-applicationevent\",\"1112\":\"16#基于接口的spring事件监听器\",\"1113\":\"16#基于注解的spring事件监听器\",\"1114\":\"16#注册spring-applicationlistener\",\"1115\":\"16#spring事件发布器\",\"1116\":\"16#spring层次性上下文事件传播\",\"1117\":\"16#spring内建事件\",\"1118\":\"16#payload事件\",\"1119\":\"16#自定义spring事件\",\"1120\":\"16#依赖注入applicationeventpublisher\",\"1121\":\"16#依赖查找applicationeventmulticaster\",\"1122\":\"16#applicationeventpublisher底层实现\",\"1123\":\"16#同步和异步spring事件广播\",\"1124\":\"16#spring事件异常处理\",\"1125\":\"16#spring事件-监听实现原理\",\"1126\":\"16#springboot事件\",\"1127\":\"16#面试题-16\",\"1128\":\"16#spring事件核心接口-组件\",\"1129\":\"16#spring同步和异步事件处理的使用场景\",\"1130\":\"16#eventlistener的工作原理\",\"1131\":\"16#spring核心注解场景分类\",\"1132\":\"16#spring注解编程模型\",\"1133\":\"16#spring元注解\",\"1134\":\"16#spring模式注解\",\"1135\":\"16#spring-组合注解\",\"1136\":\"16#spring注解属性别名\",\"1137\":\"16#spring注解属性覆盖\",\"1138\":\"16#spring-enable模块驱动\",\"1139\":\"16#spring条件注解\",\"1140\":\"16#springboot和springcloud注解\",\"1141\":\"16#面试题-17\",\"1142\":\"16#spring模式注解有哪些\",\"1143\":\"16#eventlistener的工作原理-1\",\"1144\":\"16#propertysource工作原理\",\"1145\":\"16#environment接口使用场景\",\"1146\":\"16#environment占位符处理\",\"1147\":\"16#理解条件配置spring-profiles\",\"1148\":\"16#依赖注入environment\",\"1149\":\"16#依赖查找environment\",\"1150\":\"16#依赖注入-value\",\"1151\":\"16#spring类型转换在environment中的运用\",\"1152\":\"16#spring类型转换在-value中的运用\",\"1153\":\"16#spring配置属性源propertysource\",\"1154\":\"16#spring内建的配置属性源\",\"1155\":\"16#基于注解扩展spring配置属性源\",\"1156\":\"16#基于api扩展spring配置属性源\",\"1157\":\"16#spring-测试配置属性源\",\"1158\":\"16#面试题-18\",\"1159\":\"16#简单介绍spring-environment接口\",\"1160\":\"16#如何控制propertysource的优先级\",\"1161\":\"16#environment完整的生命周期是怎样的\",\"1162\":\"16#spring应用上下文启动准备阶段\",\"1163\":\"16#beanfactory创建阶段\",\"1164\":\"16#beanfactory准备阶段\",\"1165\":\"16#beanfactory后置处理阶段\",\"1166\":\"16#beanfactory注册beanpostprocess\",\"1167\":\"16#初始化内建messagesource\",\"1168\":\"16#初始化内建spring事件广播器\",\"1169\":\"16#spring应用上下文刷新\",\"1170\":\"16#spring事件监听器注册\",\"1171\":\"16#beanfactory初始化完成阶段\",\"1172\":\"16#spring应用上下文刷新完成阶段\",\"1173\":\"16#spring-应用上下文启动阶段\",\"1174\":\"16#spring-应用上下文停止阶段\",\"1175\":\"16#spring应用上下文关闭阶段\",\"1176\":\"16#面试题-19\",\"1177\":\"16#spring应用上下文生命周期有哪些阶段\",\"1178\":\"16#environment完整的生命周期\",\"1179\":\"16#spring核心特性-1\",\"1180\":\"16#spring核心价值\",\"1181\":\"16#为什么说objectfactory提供的是延迟依赖查找\",\"1182\":\"16#依赖查找-注入-的bean会被缓存嘛\",\"1183\":\"16#bean的处理流程是怎样的\",\"1184\":\"16#beanfactory是如何处理循环依赖的\",\"1185\":\"17\",\"1186\":\"17#设计模式\",\"1187\":\"17#列举一些jdk中用到的设计模式\",\"1188\":\"17#列举一些spring当中用到的设计模式\",\"1189\":\"17#项目中有用过设计模式吗\",\"1190\":\"17#单例模式有哪些实现方式\",\"1191\":\"17#懒汉式\",\"1192\":\"17#饿汉式\",\"1193\":\"17#双重检查锁\",\"1194\":\"17#静态内部类\",\"1195\":\"17#枚举类\",\"1196\":\"17#单例模式有什么应用场景\",\"1197\":\"18\",\"1198\":\"18#网络安全\",\"1199\":\"18#什么是认证和授权-如何设计一个权限认证框架\",\"1200\":\"18#cookie和session有什么区别-如果没有cookie、seesion还能进行身份验证吗\",\"1201\":\"18#什么是csrf攻击-如何防止\",\"1202\":\"18#什么是oauth2-有哪几种认证方式\",\"1203\":\"18#什么是jwt令牌-和普通令牌有什么区别\",\"1204\":\"18#什么是sso-与oauth2-0有什么关系\",\"1205\":\"18#如何实现单点登录系统\",\"1206\":\"19\",\"1207\":\"19#mybatis面试题\",\"1208\":\"19#mybatis接口-mapper内的方法为什么不能重载\",\"1209\":\"19#mybatis的xml映射文件中-不同的xml映射文件-id是否可以重复\",\"1210\":\"19#和-的区别是什么\",\"1211\":\"19#当实体类中的属性名和表中的字段名不一样怎么办\",\"1212\":\"19#执行插入语句后如何该数据的主键\",\"1213\":\"19#模糊查询like语句该怎么写\",\"1214\":\"19#mybatis时如何进行分页的-分页插件的原理是什么\",\"1215\":\"19#mybatis有哪些动态sql标签\",\"1216\":\"19#mybtais动态sql有什么用-执行原理是什么\",\"1217\":\"19#mapper编写有哪几种方式\",\"1218\":\"19#mybatis的一级、二级缓存\",\"1219\":\"19#mybatis有二级缓存-为什么还要用redis\",\"1220\":\"19#mybatis如何开启二级缓存\",\"1221\":\"20\",\"1222\":\"20#netty面试题\",\"1223\":\"20#netty有哪些应用场景\",\"1224\":\"20#netty核心组件有哪些-分别有什么作用\",\"1225\":\"20#eventloopgroup了解么-和eventloop什么关系\",\"1226\":\"20#bootstrap和serverbootstrap了解么\",\"1227\":\"20#nioeventloopgroup默认的构造函数会起多少线程\",\"1228\":\"20#netty线程模型了解么\",\"1229\":\"20#netty服务端和客户端的启动过程了解么\",\"1230\":\"20#netty长连接、心跳机制了解么\",\"1231\":\"20#netty的零拷贝了解么\",\"1232\":\"21\",\"1233\":\"21#spring面试题\",\"1234\":\"21#spring框架中bean的创建过程是怎样的\",\"1235\":\"21#spring中bean的作用域\",\"1236\":\"21#spring框架中的bean是线程安全的吗-如果线程不安全-如何处理\",\"1237\":\"21#spring是如何处理循环依赖问题的\",\"1238\":\"21#spring如何处理事务\",\"1239\":\"21#spring事务失效的场景有哪些\",\"1240\":\"21#spring-mvc中的控制器是不是单例模式-如果是-如何保证线程安全\",\"1241\":\"21#spring-mvc原理\",\"1242\":\"21#spring中的service有多个实现类-怎么注入\",\"1243\":\"21#spring-sercuity-和-shiro有什么区别\",\"1244\":\"22\",\"1245\":\"22#springboot面试题\",\"1246\":\"22#为什么springboot的-jar可以直接运行\",\"1247\":\"22#springboot自动装配过程及实现原理\",\"1248\":\"22#springboot如何防止表单重复提交\",\"1249\":\"22#如何自己写一个springboot-starter\",\"1250\":\"23\",\"1251\":\"23#elasticsearch\",\"1252\":\"23#什么是倒排索引-有什么好处\",\"1253\":\"23#搜索引擎为什么mysql查询快\",\"1254\":\"23#es了解多少-说说你们公司的es集群架构。\",\"1255\":\"23#如何进行中文分词\",\"1256\":\"23#es写入数据与查询数据的原理。\",\"1257\":\"23#es部署时-要如何进行优化\",\"1258\":\"24\",\"1259\":\"24#mysql\",\"1260\":\"24#mysql有哪几种数据存储引擎\",\"1261\":\"24#什么是脏读、不可重复读、幻读\",\"1262\":\"24#事务的基本特性和隔离级别\",\"1263\":\"24#mysql的锁有哪些-什么是间隙锁\",\"1264\":\"24#mysql索引结构是什么样的\",\"1265\":\"24#mysql的索引结构为什么使用b-树\",\"1266\":\"24#聚簇索引和非聚簇索引有什么区别\",\"1267\":\"24#mysql主键索引和普通索引有什么区别\",\"1268\":\"24#mysql的索引覆盖和回表是什么\",\"1269\":\"24#mysql集群是如何搭建的-读写分离是怎么做的\",\"1270\":\"24#mysql如何进行分库分表-多大数据量需要进行分库分表-分库分表的方式和分片策略由哪些-分库分表后-sql语句执行流程是怎样的\",\"1271\":\"24#mysql的三种删除方式的区别\",\"1272\":\"24#慢sql的优化思路\",\"1273\":\"24#limit语句会扫描全表吗\",\"1274\":\"24#大数量分页查询该怎么优化\",\"1275\":\"24#平时项目里面表结构是如何进行设计的\",\"1276\":\"24#mysql的索引类型\",\"1277\":\"24#mysql如何快速插入千万级数据\",\"1278\":\"25\",\"1279\":\"25#redis\",\"1280\":\"25#redis支持哪些数据类型\",\"1281\":\"25#什么是缓存穿透-缓存击穿-缓存雪崩-怎么解决\",\"1282\":\"25#缓存穿透\",\"1283\":\"25#缓存击穿\",\"1284\":\"25#缓存雪崩\",\"1285\":\"25#如何保证redis与数据库的数据一致\",\"1286\":\"25#先删缓存-再写数据库\",\"1287\":\"25#先写数据库-再删缓存\",\"1288\":\"25#如何设计一个分布式锁-如何对锁性能进行优化\",\"1289\":\"25#redis的过期删除策略\",\"1290\":\"25#rdb操作-子进程会全部复制父进程的数据吗\",\"1291\":\"25#redis的哨兵模式\",\"1292\":\"25#redis使用单线程为什么速度这么快\",\"1293\":\"25#redis自增命令使用\",\"1294\":\"25#redis如何实现消息队列\",\"1295\":\"25#redisson实现分布式锁的原理\",\"1296\":\"25#redis为什么能通过lua脚本保证并发的线程安全\",\"1297\":\"25#谈一下redis事务的了解\",\"1298\":\"25#pipeline有什么好处-为什么要用pipeline\",\"1299\":\"25#redis延迟队列怎么实现的\",\"1300\":\"25#redis在内存不足时-内存淘汰策略是怎么样的\",\"1301\":\"25#如何保证redis的高可用\",\"1302\":\"26\",\"1303\":\"26#微服务\",\"1304\":\"26#谈谈你对微服务的理解-微服务有哪些优缺点\",\"1305\":\"26#springcloud和springcloudalibaba有哪些组件-都解决了什么问题\",\"1306\":\"26#springcloud和dubbo的区别\",\"1307\":\"26#分布式事务如何处理-怎么保证事务一致性\",\"1308\":\"26#怎么拆分微服务-怎样设计出高内聚、低耦合的微服务\",\"1309\":\"26#有没有了解通过ddd领域驱动设计\",\"1310\":\"26#微服务的链路追踪、持续集成、ab发布要怎么做\",\"1311\":\"26#nacos和eureka的区别\",\"1312\":\"26#nacos配置中心-本地resource-jar包中同级目录的配置文件加载优先级\",\"1313\":\"26#nacos的配置动态更新原理\",\"1314\":\"26#使用nacos配置中心-value对应的配置项如何动态更新\",\"1315\":\"26#nacos中命名空间和分组的概念及区别\",\"1316\":\"26#nacos同一个namespace中的不同的group注册的服务可以相互访问吗\",\"1317\":\"26#nacos服务注册的流程是怎么样的\",\"1318\":\"26#微服务下服务a调用服务b的流程\",\"1319\":\"26#注册中心-如何通过服务名找到服务实例\",\"1320\":\"26#熔断和限流有什么区别\",\"1321\":\"26#雪花算法有什么缺点\",\"1322\":\"26#gateway有哪些功能-如何配置动态路由\",\"1323\":\"26#如何手写一个注册中心\",\"1324\":\"27\",\"1325\":\"27#消息队列\",\"1326\":\"27#mq有什么用-有哪些具体的使用场景\",\"1327\":\"27#如何进行产品选型\",\"1328\":\"27#如何保证消息不丢失\",\"1329\":\"27#如何保证消费幂等性\",\"1330\":\"27#mq如何保证消息顺序\",\"1331\":\"27#如何保证消息的高效读写\",\"1332\":\"27#mq-中消费时-业务逻辑出现异常怎么办\",\"1333\":\"27#使用mq如何保证分布式事务的最终一致性\",\"1334\":\"27#kafka如何避免重复消费\",\"1335\":\"28\",\"1336\":\"28#java语言\",\"1337\":\"28#jvm、jdk-和-jre-联系与区别\",\"1338\":\"28#构造器-constructor-是否可被-override\",\"1339\":\"28#重载和重写的区别\",\"1340\":\"28#面向对象编程三大特性-封装-继承-多态\",\"1341\":\"28#string-stringbuffer-和-stringbuilder-的区别是什么\",\"1342\":\"28#string类为什么是不可变的\",\"1343\":\"28#integer的缓存机制\",\"1344\":\"28#深拷贝和浅拷贝的区别\",\"1345\":\"28#接口和抽象类的区别\",\"1346\":\"28#构造方法有哪些特性\",\"1347\":\"28#string中hashcode的实现\",\"1348\":\"28#hashcode和equals的作用\",\"1349\":\"28#jdk8有哪些新特性\",\"1350\":\"28#java反射有哪些作用\",\"1351\":\"28#如何使用反射获取私有属性\",\"1352\":\"28#创建对象有哪些方式\",\"1353\":\"28#迭代器和for循环遍历的区别\",\"1354\":\"28#过滤器和拦截器的区别\",\"1355\":\"28#list、set、map三者的区别\",\"1356\":\"28#hashmap实现原理\",\"1357\":\"28#hashmap为什么扩容为2倍\",\"1358\":\"28#为什么hashmap不用linkedlist-而是选用数组\",\"1359\":\"28#jdk1-8对hashmap有哪些优化\",\"1360\":\"28#为什么不直接使用红黑树-而是选择先用链表-再转红黑树\",\"1361\":\"28#hashmap不使用红黑树-而是使用二叉查找树可以吗\",\"1362\":\"28#为什么阈值是8\",\"1363\":\"28#当链表转为红黑树-什么时候退化为链表\",\"1364\":\"28#hashmap在并发编程环境下有什么问题\",\"1365\":\"28#使用可变类当hashmap的key有什么问题\",\"1366\":\"28#如何实现一个自定义的class作为hashmap的key\",\"1367\":\"28#两个相同对象没有重写equals方法放到hashmap覆盖吗\",\"1368\":\"28#hashset实现原理\",\"1369\":\"28#currenthashmap的实现原理\",\"1370\":\"28#arraylist的实现原理\",\"1371\":\"29\",\"1372\":\"29#java并发\",\"1373\":\"29#并发编程的三要素\",\"1374\":\"29#线程和进程的区别\",\"1375\":\"29#守护线程和用户线程的区别\",\"1376\":\"29#什么是线程安全\",\"1377\":\"29#java如何开启线程-怎么保证线程安全\",\"1378\":\"29#线程有哪些状态\",\"1379\":\"29#如何停止一个正在运行的线程\",\"1380\":\"29#notify和notifyall有什么区别\",\"1381\":\"29#wait和sleep方法有什么区别\",\"1382\":\"29#为什么wait和notify方法要在同步块中调用\",\"1383\":\"29#thread类中的yield方法有什么作用\",\"1384\":\"29#volatile和synchronized有什么区别\",\"1385\":\"29#volatile变量和atomic变量什么不同\",\"1386\":\"29#interrupted和isinterrupted方法的区别\",\"1387\":\"29#volatile能不能保证线程安全\",\"1388\":\"29#dcl单例为什么加volatile\",\"1389\":\"29#死锁与活锁的区别\",\"1390\":\"29#死锁与饥饿的区别\",\"1391\":\"29#按照线程安全的强度来区分-分为哪几类\",\"1392\":\"29#线程安全的实现方法有哪些\",\"1393\":\"29#锁优化技术你了解什么\",\"1394\":\"29#lock与synchronized有什么区别\",\"1395\":\"29#什么是阻塞队列-阻塞队列的实现原理是什么\",\"1396\":\"29#什么是callable和future\",\"1397\":\"29#java线程锁机制是怎样的-偏向锁、轻量级锁、重量级锁有什么区别-锁机制是如何升级的\",\"1398\":\"29#什么是可重入锁-有哪些实现\",\"1399\":\"29#什么是悲观锁-什么是乐观锁\",\"1400\":\"29#谈谈你对aqs的理解-aqs如何实现可重入锁\",\"1401\":\"29#synchronizedmap和concurrenthashmap有什么区别\",\"1402\":\"29#concurrenthashmap的并发度是什么\",\"1403\":\"29#copyonwritearraylist可以用于什么应用场景\",\"1404\":\"29#有a、b、c三个线程-如何保证三个线程同时执行-如何在并发情况下保证三个线程依次执行-如何保证三个线程有序交错进行\",\"1405\":\"29#什么是指令重排序\",\"1406\":\"29#threadlocal的作用-导致内存泄漏的原因是什么\",\"1407\":\"29#使用线程池有什么好处\",\"1408\":\"29#线程池中submit-和execute-方法有什么区别\",\"1409\":\"29#什么是executors框架\",\"1410\":\"29#线程池的拒绝策略\",\"1411\":\"29#如何获取子线程的执行结果\",\"1412\":\"29#如何对一个字符串快速进行排序\",\"1413\":\"29#线程池的参数如何设置\",\"1414\":\"29#子线程中如何获取父线程的-threadlocal-中的值、threadlocal-的数据结构\",\"1415\":\"29#高并发下-如何保证接口的幂等性\",\"1416\":\"29#除了lock和synchronized-还有什么方式可以保障线程安全\",\"1417\":\"30\",\"1418\":\"30#java网络通信\",\"1419\":\"30#tcp和udp有什么区别\",\"1420\":\"30#tcp为什么是三次握手-而不是两次\",\"1421\":\"30#java有哪几种io模型-有什么区别\",\"1422\":\"30#java-nio的几个核心组件是什么-分别有什么作用\",\"1423\":\"30#select、poll、epoll有什么区别\",\"1424\":\"30#http和https的区别\",\"1425\":\"30#三次握手和四次挥手\",\"1426\":\"31\",\"1427\":\"31#java虚拟机\",\"1428\":\"31#运行时数据区中包含哪些区域-哪些线程共享-哪些线程独享\",\"1429\":\"31#java-创建一个对象的过程\",\"1430\":\"31#如何访问对象\",\"1431\":\"31#java-内存模型的原子性、可见性和有序性是通过哪些操作实现的\",\"1432\":\"31#什么是双亲委派机制-有什么作用\",\"1433\":\"31#java类加载的全过程是怎么样的\",\"1434\":\"31#你了解分代理论吗\",\"1435\":\"31#jdk-中有几种引用类型-分别的特点是什么\",\"1436\":\"31#一个对象从加载到jvm-再到gc清除-都经历了什么过程\",\"1437\":\"31#怎么样确定一个对象不是垃圾\",\"1438\":\"31#什么是gc-root\",\"1439\":\"31#jvm有哪些垃圾回收算法\",\"1440\":\"31#什么是stw\",\"1441\":\"31#jvm有哪些垃圾回收器\",\"1442\":\"31#什么是三色标记算法\",\"1443\":\"31#如何回收方法区\",\"1444\":\"31#jvm-中的安全点和安全区各代表什么\",\"1445\":\"31#写屏障你了解吗\",\"1446\":\"31#解决并发扫描时对象消失问题的两种方案\",\"1447\":\"31#cms-垃圾收集器的步骤\",\"1448\":\"31#cms-有什么缺点\",\"1449\":\"31#g1垃圾收集器的步骤-g1有什么优缺点\",\"1450\":\"31#讲一下内存分配策略\",\"1451\":\"31#内存溢出和内存泄漏的区别\",\"1452\":\"31#如何进行jvm调优\",\"1453\":\"31#jvm参数有哪些\",\"1454\":\"31#虚拟机基础故障处理工具有哪些\",\"1455\":\"31#怎么查看一个java进程的jvm参数-谈谈你了解的jvm参数\",\"1456\":\"31#什么情况下堆内存会溢出-什么情况方法区会内存溢出\",\"1457\":\"31#jdk8-为什么要将永久代改为元空间\",\"1458\":\"32\",\"1459\":\"32#dokcer命令\",\"1460\":\"32#docker常用的命令\",\"1461\":\"32#查看所有容器的命令\",\"1462\":\"33\",\"1463\":\"33#linux命令\",\"1464\":\"33#使用cat命令如何统计文件中一个字符串出现的频率\",\"1465\":\"33#如何查看一个应用的信息\",\"1466\":\"34\",\"1467\":\"34#nginx\",\"1468\":\"34#nginx如何保证高可用\",\"1469\":\"35\",\"1470\":\"35#jmm实现原理\",\"1471\":\"35#可见性\",\"1472\":\"35#原子性\",\"1473\":\"35#有序性\",\"1474\":\"35#缓存一致性\",\"1475\":\"35#list、set、hashmap底层原理\",\"1476\":\"35#线程池底层原理\",\"1477\":\"35#深入理解java线程\",\"1478\":\"35#cas与atomic实现原理\",\"1479\":\"35#cas源码解析\",\"1480\":\"35#atomic源码解析\",\"1481\":\"35#synchronized实现原理\",\"1482\":\"35#synchronized基础\",\"1483\":\"35#monitor机制\",\"1484\":\"35#对象头\",\"1485\":\"35#偏向锁\",\"1486\":\"35#锁粗化\",\"1487\":\"35#锁消除\",\"1488\":\"35#逃逸分析\",\"1489\":\"35#synchronized的优化\",\"1490\":\"35#aqs与reentrantlock实现原理\",\"1491\":\"35#同步等待队列\",\"1492\":\"35#条件等待队列\",\"1493\":\"35#condition接口\",\"1494\":\"35#reentrantlock详解\",\"1495\":\"35#synchronized和reentrantlock\",\"1496\":\"35#semaphore与countdownlatch\",\"1497\":\"35#cylicbarrier实现原理\",\"1498\":\"35#reentrantreadwritelock\",\"1499\":\"35#blockingqueue实现原理\",\"1500\":\"35#queue队列\",\"1501\":\"35#blockingqueue\",\"1502\":\"35#arrayblockingqueue\",\"1503\":\"35#linkedblockingqueue\",\"1504\":\"35#linkedblockingdeque\",\"1505\":\"35#synchronousqueue\",\"1506\":\"35#priorityblockingqueue\",\"1507\":\"35#linkedtransferqueue\",\"1508\":\"35#delayqueue\",\"1509\":\"35#如何选择合适的阻塞队列\",\"1510\":\"35#forkjoin实现原理\",\"1511\":\"35#工作窃取\",\"1512\":\"35#工作队列\",\"1513\":\"35#forkjoinworkthread\",\"1514\":\"35#原理分析\",\"1515\":\"35#completablefuture实现原理\",\"1516\":\"35#future\",\"1517\":\"35#completionservice\",\"1518\":\"35#completablefuture\",\"1519\":\"35#高性能队列disruptor\",\"1520\":\"35#ringbuffer\",\"1521\":\"35#disruptor实战\",\"1522\":\"35#并发设计模式\",\"1523\":\"35#终止线程模式\",\"1524\":\"35#两阶段终止模式\",\"1525\":\"35#避免共享的设计模式\",\"1526\":\"35#immutability模式\",\"1527\":\"35#copy-on-write模式\",\"1528\":\"35#thread-specific-storage模式\",\"1529\":\"35#多线程版本的if模式\",\"1530\":\"35#guarded-suspension模式\",\"1531\":\"35#balking模式\",\"1532\":\"35#多线程分工模式\",\"1533\":\"35#thread-per-message模式\",\"1534\":\"35#worker-thread模式\",\"1535\":\"35#生产者-消费者模式\",\"1536\":\"35#过饱问题解决方案\",\"1537\":\"36\",\"1538\":\"36#集合的优点\",\"1539\":\"36#单列集合\",\"1540\":\"36#多列集合\",\"1541\":\"36#list\",\"1542\":\"36#arraylist源码分析\",\"1543\":\"36#linkedlist源码分析\",\"1544\":\"36#map\",\"1545\":\"36#hashmap原理分析\",\"1546\":\"36#存储方式\",\"1547\":\"36#方法实现\",\"1548\":\"36#确定哈希桶数组索引位置\",\"1549\":\"36#put方法\",\"1550\":\"36#扩容机制\",\"1551\":\"36#线程安全性\",\"1552\":\"36#concurrenthashmap源码分析\",\"1553\":\"36#jdk1-7的实现\",\"1554\":\"36#jdk1-8的实现\",\"1555\":\"36#hashtable源码分析\",\"1556\":\"36#set\",\"1557\":\"36#hashset源码分析\",\"1558\":\"36#反射的定义\",\"1559\":\"36#反射的作用\",\"1560\":\"36#核心api\",\"1561\":\"36#io基础\",\"1562\":\"36#linux网络编程io模型\",\"1563\":\"36#阻塞io模型\",\"1564\":\"36#非阻塞io\",\"1565\":\"36#io多路复用\",\"1566\":\"36#异步io\",\"1567\":\"36#阻塞、非阻塞和同步、异步\",\"1568\":\"36#io多路复用之select、poll、epoll\",\"1569\":\"36#select\",\"1570\":\"36#poll\",\"1571\":\"36#epoll\",\"1572\":\"36#java中的io模型\",\"1573\":\"36#bio\",\"1574\":\"36#nio\",\"1575\":\"36#aio\",\"1576\":\"36#io模型对比\",\"1577\":\"36#基本概念\",\"1578\":\"36#dma\",\"1579\":\"36#内核空间和用户空间\",\"1580\":\"36#io拷贝机制\",\"1581\":\"36#mmap内存映射拷贝流程\",\"1582\":\"36#linux系统sendfile拷贝流程\",\"1583\":\"36#sendfile-with-dma-scatter-gather-拷贝流程\",\"1584\":\"36#linux-系统-splice-零拷贝流程\",\"1585\":\"36#io拷贝机制对比\",\"1586\":\"36#java中的零拷贝\",\"1587\":\"36#java-nio-对mmap的支持\",\"1588\":\"36#java-nio-对sendfile的支持\",\"1589\":\"37\",\"1590\":\"38\",\"1591\":\"38#函数式编程的意义\",\"1592\":\"38#lambda表达式和匿名内部类\",\"1593\":\"38#lambda表达式和stream\",\"1594\":\"38#函数式接口定义\",\"1595\":\"38#为什么是函数式接口\",\"1596\":\"38#常见的函数式接口\",\"1597\":\"38#consumer函数式接口\",\"1598\":\"38#function函数式接口\",\"1599\":\"38#predicate函数式接口\",\"1600\":\"38#supplier函数式接口\",\"1601\":\"38#函数式接口扩展\",\"1602\":\"38#方法引用\",\"1603\":\"38#静态方法引用\",\"1604\":\"38#实例方法引用\",\"1605\":\"38#实例方法名引用\",\"1606\":\"38#构造方法引用\",\"1607\":\"38#默认方法\",\"1608\":\"38#stream类源码解析\",\"1609\":\"38#stream实例剖析\",\"1610\":\"38#stream陷阱剖析\",\"1611\":\"38#内部迭代和外部迭代\",\"1612\":\"38#流的短路与并发流\",\"1613\":\"38#分区与分组\",\"1614\":\"38#comparator源码分析及实践\",\"1615\":\"38#collector源码分析\",\"1616\":\"38#collector实践\",\"1617\":\"38#自定义collector\",\"1618\":\"38#collectors源码分析\",\"1619\":\"38#stream源码分析\",\"1620\":\"38#spliterator源码分析\",\"1621\":\"38#pipeline源码分析\",\"1622\":\"38#流调用机制与原理\",\"1623\":\"38#sink源码分析\",\"1624\":\"38#stream调用流程\",\"1625\":\"39\",\"1626\":\"40\",\"1627\":\"41\",\"1628\":\"42\",\"1629\":\"42#spring源码分析\",\"1630\":\"42#spring核心原理概览\",\"1631\":\"42#spring核心概念\",\"1632\":\"42#beandefinition\",\"1633\":\"42#annotatedbeandefinitionreader\",\"1634\":\"42#xmlbeandefinitionreader\",\"1635\":\"42#classpathbeandefinitionscanner\",\"1636\":\"42#beanfactory\",\"1637\":\"42#applicationcontext\",\"1638\":\"42#propertyeditor\",\"1639\":\"42#conversionservice\",\"1640\":\"42#typeconverter\",\"1641\":\"42#ordercomparator\",\"1642\":\"42#beanpostprocessor\",\"1643\":\"42#beanfactorypostprocessor\",\"1644\":\"42#factorybean\",\"1645\":\"42#excludefilter和includefilter\",\"1646\":\"42#metadatareader、classmetadata、annotationmetadata\",\"1647\":\"42#bean的生命周期\",\"1648\":\"42#依赖注入源码解析\",\"1649\":\"42#循环依赖解析\",\"1650\":\"42#推断构造源码解析\",\"1651\":\"42#spring启动过程\",\"1652\":\"42#配置类解析与扫描过程源码解析\",\"1653\":\"42#整合mybatis底层源码解析\",\"1654\":\"42#spring-aop源码解析\",\"1655\":\"42#spring事务源码解析\",\"1656\":\"42#spring-mvc源码分析\",\"1657\":\"42#spring-mvc执行流程\",\"1658\":\"42#spring-mvc启动过程\",\"1659\":\"42#spring和spring-mvc为什么需要父子容器-不要不行吗\",\"1660\":\"42#是否可以把所有bean都通过spring容器来管理\",\"1661\":\"42#是否可以把所有bean都交由spring-mvc容器进行管理\",\"1662\":\"42#jvm\",\"1663\":\"42#jvm类加载机制\",\"1664\":\"42#jvm内存模型\",\"1665\":\"42#jvm对象创建与内存分配机制深度剖析\",\"1666\":\"42#类加载检查\",\"1667\":\"42#分配内存\",\"1668\":\"42#划分内存的方法\",\"1669\":\"42#设置对象头\",\"1670\":\"42#class文件结构\",\"1671\":\"42#垃圾收集器\",\"1672\":\"42#jvm调优工具\",\"1673\":\"42#jvm常量池\",\"1674\":\"42#zgc详解\",\"1675\":\"42#云原生时代的java虚拟机\",\"1676\":\"42#用java实现一个jvm框架\",\"1677\":\"42#jvm如何调用java方法\",\"1678\":\"42#实现stw\",\"1679\":\"43\",\"1680\":\"44\",\"1681\":\"45\",\"1682\":\"46\",\"1683\":\"46#tomcat整体架构\",\"1684\":\"46#tomcat核心组件\",\"1685\":\"46#server组件\",\"1686\":\"46#service组件\",\"1687\":\"46#连接器connector组件\",\"1688\":\"46#protocolhandler组件\",\"1689\":\"46#tomcat线程模型\",\"1690\":\"46#tomcat类加载机制\",\"1691\":\"46#jvm类加载器\",\"1692\":\"46#双亲委托机制\",\"1693\":\"46#tomcat的类加载机制\",\"1694\":\"46#线程上下文类加载器\",\"1695\":\"46#tomcat热加载和热部署\",\"1696\":\"47\",\"1697\":\"47#内存管理\",\"1698\":\"47#垃圾回收\",\"1699\":\"47#类文件结构\",\"1700\":\"47#类加载机制\",\"1701\":\"47#运行时数据区域\",\"1702\":\"47#程序计数器\",\"1703\":\"47#虚拟机栈\",\"1704\":\"47#本地方法栈\",\"1705\":\"47#堆\",\"1706\":\"47#方法区\",\"1707\":\"47#运行时常量池\",\"1708\":\"47#直接内存\",\"1709\":\"47#hotspot虚拟机对象\",\"1710\":\"47#对象的创建\",\"1711\":\"47#对象的内存布局\",\"1712\":\"47#对象的访问定位\",\"1713\":\"47#判断对象已死\",\"1714\":\"47#引用计数算法\",\"1715\":\"47#根搜索算法\",\"1716\":\"47#对象的回收\",\"1717\":\"47#对象的引用\",\"1718\":\"47#垃圾回收算法\",\"1719\":\"47#分代收集理论\",\"1720\":\"47#标记-清除算法\",\"1721\":\"47#标记-复制算法\",\"1722\":\"47#标记-整理算法\",\"1723\":\"47#经典垃圾收集器\",\"1724\":\"47#serial收集器\",\"1725\":\"47#parnew收集器\",\"1726\":\"47#parallel-scavenge收集器\",\"1727\":\"47#serial-old收集器\",\"1728\":\"47#parallel-old收集器\",\"1729\":\"47#cms收集器\",\"1730\":\"47#cms简介\",\"1731\":\"47#cms详细步骤\",\"1732\":\"47#初始标记\",\"1733\":\"47#并发标记\",\"1734\":\"47#预清理阶段\",\"1735\":\"47#可终止的预清理\",\"1736\":\"47#重新标记\",\"1737\":\"47#并发清理\",\"1738\":\"47#并发重置\",\"1739\":\"47#garbage-first收集器\",\"1740\":\"47#g1简介\",\"1741\":\"47#重要概念\",\"1742\":\"47#region\",\"1743\":\"47#三色标记算法\",\"1744\":\"47#satb算法\",\"1745\":\"47#rset\",\"1746\":\"47#cset\",\"1747\":\"47#停顿预测模型\",\"1748\":\"47#gc过程\",\"1749\":\"47#回收算法\",\"1750\":\"47#收集过程\",\"1751\":\"47#young-gc\",\"1752\":\"47#mixed-gc\",\"1753\":\"47#global-concurrent-marking\",\"1754\":\"47#g1特点\",\"1755\":\"47#参数设置\",\"1756\":\"47#垃圾收集器参数总结\",\"1757\":\"47#hotspot的算法实现细节\",\"1758\":\"47#根节点枚举\",\"1759\":\"47#安全点\",\"1760\":\"47#安全区域\",\"1761\":\"47#记忆集与卡表\",\"1762\":\"47#并发的可达性分析\",\"1763\":\"47#空间分配担保\",\"1764\":\"47#内存屏障\",\"1765\":\"47#来源\",\"1766\":\"47#类型\",\"1767\":\"47#java内存屏障\",\"1768\":\"47#volatile语义中的内存屏障\",\"1769\":\"47#final语义中的内存屏障\",\"1770\":\"47#性能监控、故障处理工具\",\"1771\":\"47#基础故障处理工具\",\"1772\":\"47#可视化故障处理工具\",\"1773\":\"47#jvisualvm\",\"1774\":\"47#jconsole\",\"1775\":\"47#class类文件的结构\",\"1776\":\"47#魔数与class文件的版本\",\"1777\":\"47#常量池\",\"1778\":\"47#访问标志\",\"1779\":\"47#类索引、父类索引与接口索引集合\",\"1780\":\"47#字段表集合\",\"1781\":\"47#方法表集合\",\"1782\":\"47#属性表集合\",\"1783\":\"47#字节码指令\",\"1784\":\"47#字节码与数据类型\",\"1785\":\"47#类加载过程\",\"1786\":\"47#加载\",\"1787\":\"47#验证\",\"1788\":\"47#准备\",\"1789\":\"47#解析\",\"1790\":\"47#初始化\",\"1791\":\"47#类加载器\",\"1792\":\"47#类与类加载器\",\"1793\":\"47#双亲委派模型\",\"1794\":\"47#破坏双亲委派模型\",\"1795\":\"47#spi机制\",\"1796\":\"47#简介\",\"1797\":\"47#jdk-spi\",\"1798\":\"47#spring-spi\",\"1799\":\"47#运行时栈帧结构\",\"1800\":\"47#局部变量表\",\"1801\":\"47#操作数栈\",\"1802\":\"47#动态连接\",\"1803\":\"47#方法返回地址\",\"1804\":\"47#附加信息\",\"1805\":\"47#方法调用\",\"1806\":\"47#解析-1\",\"1807\":\"47#分派\",\"1808\":\"47#java内存模型\",\"1809\":\"47#主内存与工作内存\",\"1810\":\"47#volatile型变量\",\"1811\":\"47#java与线程\",\"1812\":\"47#线程的实现\",\"1813\":\"47#java线程调度\",\"1814\":\"47#线程状态\",\"1815\":\"47#线程安全\",\"1816\":\"47#互斥同步\",\"1817\":\"47#非阻塞同步\",\"1818\":\"47#无同步方案\",\"1819\":\"47#锁优化\",\"1820\":\"47#自旋锁与自适应自旋\",\"1821\":\"47#锁消除\",\"1822\":\"47#锁粗化\",\"1823\":\"47#轻量级锁\",\"1824\":\"47#偏向锁\",\"1825\":\"48\",\"1826\":\"48#概念\",\"1827\":\"48#消息模型\",\"1828\":\"48#生产者组\",\"1829\":\"48#消费者组\",\"1830\":\"48#集群消费\",\"1831\":\"48#广播消息\",\"1832\":\"48#标签\",\"1833\":\"48#队列\",\"1834\":\"48#协议\",\"1835\":\"48#特性\",\"1836\":\"48#消息顺序\",\"1837\":\"48#消息重试\",\"1838\":\"48#延迟队列\",\"1839\":\"48#死信队列\",\"1840\":\"48#技术架构\",\"1841\":\"48#集群工作流程\",\"1842\":\"48#架构设计\",\"1843\":\"48#消息存储\",\"1844\":\"48#消息存储整体架构\",\"1845\":\"48#页缓存与内存映射\",\"1846\":\"48#消息刷盘\",\"1847\":\"48#通信机制\",\"1848\":\"48#rocketmq通信类结构\",\"1849\":\"48#reactor线程设计\",\"1850\":\"48#消息过滤\",\"1851\":\"48#负载均衡\",\"1852\":\"48#生产者\",\"1853\":\"48#tags的使用\",\"1854\":\"48#keys的使用\",\"1855\":\"48#选择oneway形式发送\",\"1856\":\"48#消费者\",\"1857\":\"48#消费过程幂等\",\"1858\":\"48#提升消费速度\",\"1859\":\"48#顺序消费\",\"1860\":\"48#并发消费\",\"1861\":\"48#顺序消费-1\",\"1862\":\"48#全局有序\",\"1863\":\"48#分区有序\",\"1864\":\"48#订阅关系的一致性\",\"1865\":\"48#正确的订阅关系\",\"1866\":\"48#错误的订阅关系\",\"1867\":\"48#订阅了不同的topic\",\"1868\":\"48#订阅了不同tag\",\"1869\":\"48#订阅不同数量的topic\",\"1870\":\"48#配置管理\",\"1871\":\"48#依赖管理\",\"1872\":\"48#外部化配置\",\"1873\":\"48#配置类\",\"1874\":\"48#发送消息\",\"1875\":\"48#发送普通消息\",\"1876\":\"48#发送事务消息\",\"1877\":\"48#接收消息\",\"1878\":\"48#接收普通消息\",\"1879\":\"48#接收事务消息\",\"1880\":\"48#消息发送过程\",\"1881\":\"48#选择发送的路由\",\"1882\":\"48#向broker发送消息\",\"1883\":\"48#消息存储过程\",\"1884\":\"48#写入文件\",\"1885\":\"48#文件可以完全存储消息\",\"1886\":\"48#文件不可以完全存储消息\",\"1887\":\"48#消息刷盘-1\",\"1888\":\"48#消息接收过程\",\"1889\":\"48#消费者注册\",\"1890\":\"48#消息队列\",\"1891\":\"48#广播模式\",\"1892\":\"48#集群模式\",\"1893\":\"48#平均分配策略\",\"1894\":\"48#平均分配轮询策略\",\"1895\":\"48#一致性哈希策略\",\"1896\":\"48#broker消费队列\",\"1897\":\"48#集群模式-1\",\"1898\":\"48#广播模式-1\",\"1899\":\"48#消费消息\",\"1900\":\"48#并发消费-1\",\"1901\":\"48#有序消费\",\"1902\":\"48#消息过滤过程\",\"1903\":\"48#消息过滤类型\",\"1904\":\"48#标签匹配\",\"1905\":\"48#sql匹配\",\"1906\":\"48#注册过滤信息\",\"1907\":\"48#生成bloomfilterdata\",\"1908\":\"48#编译sql语句\",\"1909\":\"48#计算位映射\",\"1910\":\"48#存储位映射\",\"1911\":\"48#消息过滤-1\",\"1912\":\"48#自定义匹配\",\"1913\":\"48#过滤服务器\",\"1914\":\"48#过滤类\",\"1915\":\"48#过滤消息\",\"1916\":\"48#消息索引流程\",\"1917\":\"48#消息查询\",\"1918\":\"48#id-偏移量-查询\",\"1919\":\"48#消息索引服务\",\"1920\":\"48#索引文件结构\",\"1921\":\"48#添加消息\",\"1922\":\"48#查询消息\",\"1923\":\"48#唯一键查询\",\"1924\":\"48#键查询消息\",\"1925\":\"48#定时消息和重试消息\",\"1926\":\"48#定时消息\",\"1927\":\"48#定时消息存储\",\"1928\":\"48#消息重试-1\",\"1929\":\"48#producer消息发送重试\",\"1930\":\"48#consumer消息接收重试\",\"1931\":\"48#主备同步\",\"1932\":\"48#建立连接\",\"1933\":\"48#数据传输\",\"1934\":\"48#消息异步传输\",\"1935\":\"48#消息同步传输\",\"1936\":\"48#消费建议\",\"1937\":\"48#异常处理\",\"1938\":\"48#事务消息\",\"1939\":\"48#发送事务消息-1\",\"1940\":\"48#接收事务消息-1\",\"1941\":\"48#接收事务准备消息\",\"1942\":\"48#接收事务结束的消息\",\"1943\":\"48#扫描事务状态\",\"1944\":\"48#server定时扫描\",\"1945\":\"48#server检查事务状态\",\"1946\":\"48#客户端检查事务状态\",\"1947\":\"48#acl权限控制\",\"1948\":\"48#使用示例\",\"1949\":\"48#rpchook\",\"1950\":\"48#aclclientrpchook\",\"1951\":\"48#生成签名\",\"1952\":\"48#添加扩展字段\",\"1953\":\"48#broker权限验证\",\"1954\":\"48#校验权限\",\"1955\":\"48#acl权限管理器\",\"1956\":\"48#逻辑队列\",\"1957\":\"48#架构实现\",\"1958\":\"48#实现\",\"1959\":\"48#监听者模式\",\"1960\":\"49\",\"1961\":\"49#zookeeper特性与节点数据类型\",\"1962\":\"49#zookeeper经典应用场景\",\"1963\":\"49#zookeeper集群leader选举\",\"1964\":\"49#zookeeper集群与watcher监听机制\",\"1965\":\"50\",\"1966\":\"51\",\"1967\":\"52\",\"1968\":\"52#学习路线概览\",\"1969\":\"52#第一阶段-java-基础\",\"1970\":\"52#第二阶段-leetcode\",\"1971\":\"52#数据结构\",\"1972\":\"52#算法\",\"1973\":\"52#第三阶段-数据库\",\"1974\":\"52#mysql\",\"1975\":\"52#redis\",\"1976\":\"52#第四阶段-java-web\",\"1977\":\"52#web前端\",\"1978\":\"52#web后端\",\"1979\":\"52#第五阶段-主流框架\",\"1980\":\"52#maven\",\"1981\":\"52#git\",\"1982\":\"52#ssm框架\",\"1983\":\"52#spring-boot\",\"1984\":\"52#第六阶段-服务器中间件\",\"1985\":\"52#mq\",\"1986\":\"52#elasticsearch\",\"1987\":\"52#项目实践\",\"1988\":\"52#第七阶段-微服务和分布式\",\"1989\":\"52#spring-cloud\",\"1990\":\"52#dubbo\",\"1991\":\"52#zookeeper\",\"1992\":\"52#第八阶段-进阶优化\",\"1993\":\"52#end\",\"1994\":\"53\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,5],\"2\":[1,1],\"3\":[1,8],\"4\":[1,9],\"5\":[1,3],\"6\":[1],\"7\":[1],\"8\":[6],\"9\":[5],\"10\":[2],\"11\":[4],\"12\":[6],\"13\":[2],\"14\":[2],\"15\":[2],\"16\":[1],\"17\":[2],\"18\":[2],\"19\":[2],\"20\":[2],\"21\":[2],\"22\":[2],\"23\":[2],\"24\":[2],\"25\":[2],\"26\":[1],\"27\":[4],\"28\":[2],\"29\":[2],\"30\":[3],\"31\":[3],\"32\":[4],\"33\":[3],\"34\":[2],\"35\":[3],\"36\":[2],\"37\":[2],\"38\":[2],\"39\":[2],\"40\":[2],\"41\":[2],\"42\":[2],\"43\":[1],\"44\":[2],\"45\":[2],\"46\":[2],\"47\":[2],\"48\":[3],\"49\":[2],\"50\":[2],\"51\":[2],\"52\":[2],\"53\":[2],\"54\":[2],\"55\":[2],\"56\":[2],\"57\":[2],\"58\":[2],\"59\":[2],\"60\":[2],\"61\":[2],\"62\":[3],\"63\":[2],\"64\":[2],\"65\":[2],\"66\":[3],\"67\":[2],\"68\":[6],\"69\":[3],\"70\":[3],\"71\":[3],\"72\":[2],\"73\":[2],\"74\":[2],\"75\":[7],\"76\":[2],\"77\":[3],\"78\":[2],\"79\":[4],\"80\":[2],\"81\":[2],\"82\":[2],\"83\":[2],\"84\":[2],\"85\":[4],\"86\":[3],\"87\":[3],\"88\":[1],\"89\":[2],\"90\":[3],\"91\":[3],\"92\":[4],\"93\":[4],\"94\":[2],\"95\":[2],\"96\":[1],\"97\":[4],\"98\":[3],\"99\":[2],\"100\":[4],\"101\":[3],\"102\":[2],\"103\":[2],\"104\":[4],\"105\":[4],\"106\":[2],\"107\":[3],\"108\":[2],\"109\":[2],\"110\":[2],\"111\":[2],\"112\":[2],\"113\":[3],\"114\":[2],\"115\":[2],\"116\":[3],\"117\":[3],\"118\":[3],\"119\":[2],\"120\":[2],\"121\":[2],\"122\":[2],\"123\":[2],\"124\":[2],\"125\":[3],\"126\":[3],\"127\":[1],\"128\":[2],\"129\":[5],\"130\":[1],\"131\":[1],\"132\":[1],\"133\":[2],\"134\":[2],\"135\":[2],\"136\":[3],\"137\":[2],\"138\":[3],\"139\":[2],\"140\":[2],\"141\":[2],\"142\":[2],\"143\":[2],\"144\":[2],\"145\":[2],\"146\":[3],\"147\":[2],\"148\":[3],\"149\":[2],\"150\":[1],\"151\":[2],\"152\":[4],\"153\":[1],\"154\":[3],\"155\":[2],\"156\":[2],\"157\":[2],\"158\":[2],\"159\":[2],\"160\":[3],\"161\":[6],\"162\":[2],\"163\":[2],\"164\":[2],\"165\":[2],\"166\":[2],\"167\":[2],\"168\":[2],\"169\":[1],\"170\":[3],\"171\":[2],\"172\":[3],\"173\":[2],\"174\":[2],\"175\":[3],\"176\":[1],\"177\":[2],\"178\":[2],\"179\":[4],\"180\":[2],\"181\":[2],\"182\":[2],\"183\":[5],\"184\":[3],\"185\":[3],\"186\":[1],\"187\":[3],\"188\":[2],\"189\":[2],\"190\":[3],\"191\":[1],\"192\":[3],\"193\":[4],\"194\":[3],\"195\":[2],\"196\":[2],\"197\":[2],\"198\":[3],\"199\":[2],\"200\":[3],\"201\":[2],\"202\":[3],\"203\":[3],\"204\":[2],\"205\":[1],\"206\":[2],\"207\":[3],\"208\":[3],\"209\":[2],\"210\":[2],\"211\":[2],\"212\":[2],\"213\":[3],\"214\":[2],\"215\":[1],\"216\":[3],\"217\":[4],\"218\":[3],\"219\":[3],\"220\":[3],\"221\":[4],\"222\":[2],\"223\":[1],\"224\":[3],\"225\":[3],\"226\":[2],\"227\":[3],\"228\":[4],\"229\":[2],\"230\":[4],\"231\":[2],\"232\":[4],\"233\":[2],\"234\":[3],\"235\":[2],\"236\":[2],\"237\":[2],\"238\":[2],\"239\":[3],\"240\":[2],\"241\":[2],\"242\":[3],\"243\":[2],\"244\":[1],\"245\":[3],\"246\":[2],\"247\":[2],\"248\":[2],\"249\":[2],\"250\":[2],\"251\":[4],\"252\":[2],\"253\":[2],\"254\":[1],\"255\":[2],\"256\":[2],\"257\":[1],\"258\":[2],\"259\":[2],\"260\":[1],\"261\":[2],\"262\":[1],\"263\":[2],\"264\":[2],\"265\":[2],\"266\":[2],\"267\":[1],\"268\":[1],\"269\":[1],\"270\":[1],\"271\":[1],\"272\":[2],\"273\":[2,17],\"274\":[3],\"275\":[1],\"276\":[1],\"277\":[1],\"278\":[1],\"279\":[1],\"280\":[1],\"281\":[1],\"282\":[1],\"283\":[1],\"284\":[3],\"285\":[1],\"286\":[1],\"287\":[1],\"288\":[1],\"289\":[1],\"290\":[1],\"291\":[1],\"292\":[1],\"293\":[1],\"294\":[1],\"295\":[1],\"296\":[1],\"297\":[1],\"298\":[1],\"299\":[1,14],\"300\":[1,35],\"301\":[1,28],\"302\":[1,2],\"303\":[1,12],\"304\":[1,63],\"305\":[1,20],\"306\":[1,174],\"307\":[1,102],\"308\":[2,57],\"309\":[1,114],\"310\":[1],\"311\":[1],\"312\":[1,13],\"313\":[1],\"314\":[1],\"315\":[1],\"316\":[1],\"317\":[1,58],\"318\":[1,103],\"319\":[1,57],\"320\":[1,35],\"321\":[1,34],\"322\":[1,64],\"323\":[1,28],\"324\":[1,52],\"325\":[1,35],\"326\":[1,40],\"327\":[1,85],\"328\":[1],\"329\":[2,50],\"330\":[2,262],\"331\":[1,15],\"332\":[1,42],\"333\":[1,25],\"334\":[1,57],\"335\":[1,149],\"336\":[1,52],\"337\":[1,25],\"338\":[1,81],\"339\":[1,59],\"340\":[1,61],\"341\":[1,27],\"342\":[1,55],\"343\":[1,91],\"344\":[2,44],\"345\":[3,83],\"346\":[1,92],\"347\":[1,143],\"348\":[1,93],\"349\":[1,31],\"350\":[1,120],\"351\":[1,40],\"352\":[1,95],\"353\":[2,44],\"354\":[1,159],\"355\":[1,95],\"356\":[1,98],\"357\":[1,3],\"358\":[1,13],\"359\":[1,17],\"360\":[1],\"361\":[1,135],\"362\":[1,59],\"363\":[1,40],\"364\":[1,12],\"365\":[1,8],\"366\":[1,116],\"367\":[1,32],\"368\":[1,157],\"369\":[1,26],\"370\":[1,35],\"371\":[1,49],\"372\":[1,33],\"373\":[1,20],\"374\":[1,14],\"375\":[1,28],\"376\":[1,19],\"377\":[1,26],\"378\":[1,129],\"379\":[1],\"380\":[1,9],\"381\":[1,61],\"382\":[1,6],\"383\":[1,12],\"384\":[1,20],\"385\":[1,18],\"386\":[1,13],\"387\":[1,14],\"388\":[1,38],\"389\":[1,23],\"390\":[1,118],\"391\":[1],\"392\":[3,24],\"393\":[1,51],\"394\":[1,73],\"395\":[2,11],\"396\":[2,90],\"397\":[1,21],\"398\":[1],\"399\":[1,53],\"400\":[1,60],\"401\":[4,105],\"402\":[4,36],\"403\":[4,169],\"404\":[4,130],\"405\":[3,56],\"406\":[1,53],\"407\":[1,99],\"408\":[2,32],\"409\":[1,46],\"410\":[1,36],\"411\":[1,92],\"412\":[1,93],\"413\":[1,116],\"414\":[1,95],\"415\":[2],\"416\":[2,94],\"417\":[2,86],\"418\":[2,75],\"419\":[4,66],\"420\":[1,107],\"421\":[1,139],\"422\":[1,105],\"423\":[1,4],\"424\":[1,143],\"425\":[1,95],\"426\":[1,45],\"427\":[1],\"428\":[1,103],\"429\":[1,143],\"430\":[1,28],\"431\":[2,185],\"432\":[1,20],\"433\":[1,127],\"434\":[1,65],\"435\":[1,41],\"436\":[1,9],\"437\":[1,21],\"438\":[1,42],\"439\":[1,8],\"440\":[1,13],\"441\":[1,95],\"442\":[1,27],\"443\":[1,44],\"444\":[1,109],\"445\":[1],\"446\":[1,80],\"447\":[1,129],\"448\":[1,80],\"449\":[1],\"450\":[2,64],\"451\":[2,241],\"452\":[1],\"453\":[1,77],\"454\":[2,293],\"455\":[1,53],\"456\":[1,10],\"457\":[1,139],\"458\":[1,41],\"459\":[1,126],\"460\":[1,68],\"461\":[1,84],\"462\":[1,128],\"463\":[3,32],\"464\":[1,63],\"465\":[3,110],\"466\":[1,28],\"467\":[1,164],\"468\":[1,258],\"469\":[1,51],\"470\":[1,30],\"471\":[2,33],\"472\":[1,159],\"473\":[1,65],\"474\":[1,50],\"475\":[1,3],\"476\":[2,146],\"477\":[1,25],\"478\":[1,110],\"479\":[1,127],\"480\":[1,38],\"481\":[1,172],\"482\":[1,103],\"483\":[1,13],\"484\":[1,90],\"485\":[2,135],\"486\":[1,37],\"487\":[2,30],\"488\":[1,22],\"489\":[1,32],\"490\":[1,63],\"491\":[1,146],\"492\":[1,163],\"493\":[1,15],\"494\":[1,55],\"495\":[2,65],\"496\":[1,44],\"497\":[3,181],\"498\":[2,30],\"499\":[1,27],\"500\":[1],\"501\":[1,9],\"502\":[2,4],\"503\":[1,22],\"504\":[1,7],\"505\":[1,29],\"506\":[1,67],\"507\":[1],\"508\":[1,3],\"509\":[1,24],\"510\":[1,57],\"511\":[1],\"512\":[1],\"513\":[1,11],\"514\":[1,37],\"515\":[1],\"516\":[2],\"517\":[1,13],\"518\":[1,117],\"519\":[1,199],\"520\":[1,152],\"521\":[1,8],\"522\":[1,52],\"523\":[1,59],\"524\":[1,35],\"525\":[1,74],\"526\":[2,44],\"527\":[1,22],\"528\":[1,119],\"529\":[1,76],\"530\":[1,68],\"531\":[1,8],\"532\":[1,66],\"533\":[1,33],\"534\":[1,56],\"535\":[1,68],\"536\":[1,32],\"537\":[1,32],\"538\":[1,53],\"539\":[1,10],\"540\":[1,20],\"541\":[1,55],\"542\":[2,328],\"543\":[1,13],\"544\":[1,57],\"545\":[1,26],\"546\":[1,12],\"547\":[2,50],\"548\":[1,81],\"549\":[1,199],\"550\":[1,5],\"551\":[2,42],\"552\":[1],\"553\":[2,272],\"554\":[1,109],\"555\":[1,226],\"556\":[1,79],\"557\":[1,116],\"558\":[1,185],\"559\":[1,72],\"560\":[1],\"561\":[2,19],\"562\":[1],\"563\":[1],\"564\":[2,21],\"565\":[2,15],\"566\":[1,4],\"567\":[1,66],\"568\":[1,21],\"569\":[2,92],\"570\":[3,119],\"571\":[3,187],\"572\":[3,122],\"573\":[3,137],\"574\":[3,206],\"575\":[1],\"576\":[3,92],\"577\":[3,90],\"578\":[3,73],\"579\":[1,42],\"580\":[1,64],\"581\":[1,61],\"582\":[1,80],\"583\":[1,163],\"584\":[1,15],\"585\":[1],\"586\":[1,9],\"587\":[1,34],\"588\":[1,44],\"589\":[1,20],\"590\":[1,16],\"591\":[1,13],\"592\":[1,38],\"593\":[1,13],\"594\":[1],\"595\":[4,15],\"596\":[2,43],\"597\":[1,18],\"598\":[1,35],\"599\":[1,20],\"600\":[1,9],\"601\":[1,24],\"602\":[1,24],\"603\":[1,61],\"604\":[1,4],\"605\":[1,13],\"606\":[1,18],\"607\":[1,19],\"608\":[1,5],\"609\":[1,41],\"610\":[1,18],\"611\":[1,59],\"612\":[1],\"613\":[1],\"614\":[1],\"615\":[1],\"616\":[1],\"617\":[1],\"618\":[1,7],\"619\":[1,10],\"620\":[1,10],\"621\":[1,60],\"622\":[1],\"623\":[1,10],\"624\":[1,170],\"625\":[1],\"626\":[1,16],\"627\":[1,18],\"628\":[1],\"629\":[1,14],\"630\":[1,19],\"631\":[1],\"632\":[1,6],\"633\":[1,23],\"634\":[1],\"635\":[1,11],\"636\":[2],\"637\":[1,23],\"638\":[1],\"639\":[1,17],\"640\":[1],\"641\":[1],\"642\":[1],\"643\":[1,3],\"644\":[1],\"645\":[1,173],\"646\":[1,16],\"647\":[1],\"648\":[1],\"649\":[1],\"650\":[1],\"651\":[1],\"652\":[1],\"653\":[1],\"654\":[1],\"655\":[2],\"656\":[1],\"657\":[1],\"658\":[1],\"659\":[1],\"660\":[1],\"661\":[1],\"662\":[1],\"663\":[1],\"664\":[1],\"665\":[2],\"666\":[1],\"667\":[1],\"668\":[1],\"669\":[1],\"670\":[1],\"671\":[1],\"672\":[1],\"673\":[2],\"674\":[1],\"675\":[1],\"676\":[1],\"677\":[1],\"678\":[1],\"679\":[1],\"680\":[1],\"681\":[1],\"682\":[1],\"683\":[1],\"684\":[1],\"685\":[1],\"686\":[1],\"687\":[1],\"688\":[1],\"689\":[1],\"690\":[1],\"691\":[1],\"692\":[1],\"693\":[1],\"694\":[1],\"695\":[1],\"696\":[1],\"697\":[1],\"698\":[1],\"699\":[1],\"700\":[1],\"701\":[1],\"702\":[1],\"703\":[1],\"704\":[1],\"705\":[1],\"706\":[1],\"707\":[1],\"708\":[1],\"709\":[1],\"710\":[1],\"711\":[1],\"712\":[1],\"713\":[1],\"714\":[1],\"715\":[1],\"716\":[1],\"717\":[1],\"718\":[1],\"719\":[1],\"720\":[1],\"721\":[1],\"722\":[1],\"723\":[1],\"724\":[1],\"725\":[1],\"726\":[1],\"727\":[1],\"728\":[1],\"729\":[1],\"730\":[1],\"731\":[1],\"732\":[1],\"733\":[1],\"734\":[1],\"735\":[1],\"736\":[2],\"737\":[1],\"738\":[2],\"739\":[2],\"740\":[2],\"741\":[2],\"742\":[1],\"743\":[1],\"744\":[1],\"745\":[1],\"746\":[1],\"747\":[1],\"748\":[2],\"749\":[1],\"750\":[1],\"751\":[1],\"752\":[3],\"753\":[1],\"754\":[2],\"755\":[3],\"756\":[2],\"757\":[1],\"758\":[1],\"759\":[1],\"760\":[1],\"761\":[4],\"762\":[2],\"763\":[2],\"764\":[1],\"765\":[3],\"766\":[1],\"767\":[1],\"768\":[2],\"769\":[2],\"770\":[2],\"771\":[2],\"772\":[2],\"773\":[2],\"774\":[2],\"775\":[2],\"776\":[1],\"777\":[1],\"778\":[1],\"779\":[3],\"780\":[4],\"781\":[3],\"782\":[1],\"783\":[1],\"784\":[1],\"785\":[1],\"786\":[1],\"787\":[2],\"788\":[1],\"789\":[2],\"790\":[3],\"791\":[2],\"792\":[3],\"793\":[1],\"794\":[1],\"795\":[1],\"796\":[1],\"797\":[1],\"798\":[1],\"799\":[2],\"800\":[2],\"801\":[1],\"802\":[1],\"803\":[1],\"804\":[1],\"805\":[1],\"806\":[1],\"807\":[1],\"808\":[1],\"809\":[1],\"810\":[1],\"811\":[1],\"812\":[1],\"813\":[1],\"814\":[1],\"815\":[1],\"816\":[2],\"817\":[2],\"818\":[5],\"819\":[5],\"820\":[3],\"821\":[4],\"822\":[4],\"823\":[4],\"824\":[5],\"825\":[5],\"826\":[3],\"827\":[3],\"828\":[2],\"829\":[1],\"830\":[5],\"831\":[3],\"832\":[5],\"833\":[1],\"834\":[1],\"835\":[1],\"836\":[1],\"837\":[1],\"838\":[1],\"839\":[1],\"840\":[1],\"841\":[1],\"842\":[1],\"843\":[1],\"844\":[1],\"845\":[1],\"846\":[1],\"847\":[1],\"848\":[1],\"849\":[1],\"850\":[1],\"851\":[1],\"852\":[1],\"853\":[3],\"854\":[2],\"855\":[3],\"856\":[2],\"857\":[1],\"858\":[1],\"859\":[1],\"860\":[1],\"861\":[1],\"862\":[2],\"863\":[1],\"864\":[1],\"865\":[4],\"866\":[2],\"867\":[3],\"868\":[1],\"869\":[2],\"870\":[1],\"871\":[2],\"872\":[2],\"873\":[2],\"874\":[1],\"875\":[1],\"876\":[1],\"877\":[1],\"878\":[1],\"879\":[1],\"880\":[4],\"881\":[3],\"882\":[3],\"883\":[1],\"884\":[1],\"885\":[1],\"886\":[1],\"887\":[1],\"888\":[1],\"889\":[1],\"890\":[1],\"891\":[2,26],\"892\":[1,24],\"893\":[1,14],\"894\":[2,9],\"895\":[1,17],\"896\":[1,14],\"897\":[1,21],\"898\":[1,1],\"899\":[1,49],\"900\":[1,75],\"901\":[1],\"902\":[3,11],\"903\":[3,19],\"904\":[3,2],\"905\":[1,16],\"906\":[1,18],\"907\":[1,11],\"908\":[1,22],\"909\":[1,58],\"910\":[2,13],\"911\":[1,18],\"912\":[1,22],\"913\":[1],\"914\":[2,16],\"915\":[2,5],\"916\":[2,10],\"917\":[2,147],\"918\":[2,119],\"919\":[1,39],\"920\":[2,9],\"921\":[1,96],\"922\":[2,130],\"923\":[1],\"924\":[2,10],\"925\":[1,4],\"926\":[3,5],\"927\":[1,90],\"928\":[2,144],\"929\":[1,85],\"930\":[1,154],\"931\":[1,63],\"932\":[1,15],\"933\":[1,62],\"934\":[2,41],\"935\":[1],\"936\":[3,33],\"937\":[3,4],\"938\":[1,3],\"939\":[1,14],\"940\":[1,53],\"941\":[1,57],\"942\":[1,15],\"943\":[1,66],\"944\":[1,84],\"945\":[1,59],\"946\":[1,88],\"947\":[1],\"948\":[1,7],\"949\":[3,4],\"950\":[2,2],\"951\":[1,28],\"952\":[1,74],\"953\":[1,130],\"954\":[1,105],\"955\":[1,54],\"956\":[1,23],\"957\":[1,69],\"958\":[1,9],\"959\":[1,34],\"960\":[1,15],\"961\":[1,110],\"962\":[1,59],\"963\":[1,298],\"964\":[2,124],\"965\":[3,89],\"966\":[1,46],\"967\":[1,106],\"968\":[1],\"969\":[1,5],\"970\":[2,5],\"971\":[2,2],\"972\":[1,16],\"973\":[1,100],\"974\":[1,17],\"975\":[2,53],\"976\":[1,10],\"977\":[2,39],\"978\":[1,62],\"979\":[1],\"980\":[2,7],\"981\":[2,8],\"982\":[2,6],\"983\":[1,23],\"984\":[1,17],\"985\":[1,145],\"986\":[1,16],\"987\":[1,27],\"988\":[1,22],\"989\":[1,126],\"990\":[1],\"991\":[2,5],\"992\":[3,7],\"993\":[3,7],\"994\":[1,61],\"995\":[1,68],\"996\":[1,121],\"997\":[1,196],\"998\":[2,35],\"999\":[1],\"1000\":[1,92],\"1001\":[1,93],\"1002\":[1,56],\"1003\":[1,115],\"1004\":[1],\"1005\":[1,163],\"1006\":[1,90],\"1007\":[1,96],\"1008\":[1,70],\"1009\":[1,46],\"1010\":[1],\"1011\":[1,85],\"1012\":[1,59],\"1013\":[1,40],\"1014\":[1],\"1015\":[2,8],\"1016\":[1,12],\"1017\":[2,36],\"1018\":[2,12],\"1019\":[2,82],\"1020\":[1,66],\"1021\":[2,43],\"1022\":[2,133],\"1023\":[2,83],\"1024\":[2,17],\"1025\":[1,31],\"1026\":[1,21],\"1027\":[1,85],\"1028\":[2,21],\"1029\":[2,72],\"1030\":[4,119],\"1031\":[1,77],\"1032\":[1,115],\"1033\":[1],\"1034\":[3,3],\"1035\":[2,20],\"1036\":[4,30],\"1037\":[1,29],\"1038\":[1,18],\"1039\":[1,29],\"1040\":[1,61],\"1041\":[1,57],\"1042\":[1,13],\"1043\":[1,92],\"1044\":[2,46],\"1045\":[1,42],\"1046\":[1],\"1047\":[2,4],\"1048\":[1,21],\"1049\":[1,23],\"1050\":[1,13],\"1051\":[1,5],\"1052\":[1,24],\"1053\":[1,93],\"1054\":[1,10],\"1055\":[1,66],\"1056\":[3,52],\"1057\":[1],\"1058\":[2,7],\"1059\":[2,8],\"1060\":[2,27],\"1061\":[1,69],\"1062\":[1,19],\"1063\":[1,76],\"1064\":[1,80],\"1065\":[2,110],\"1066\":[1],\"1067\":[2,4],\"1068\":[2,16],\"1069\":[3,9],\"1070\":[2,38],\"1071\":[1,22],\"1072\":[1,98],\"1073\":[2,22],\"1074\":[1,15],\"1075\":[1,63],\"1076\":[1,3],\"1077\":[1],\"1078\":[2,4],\"1079\":[2,2],\"1080\":[2,10],\"1081\":[1,12],\"1082\":[1,63],\"1083\":[1,22],\"1084\":[1,157],\"1085\":[1,15],\"1086\":[2,25],\"1087\":[1,16],\"1088\":[1,16],\"1089\":[1,34],\"1090\":[1,16],\"1091\":[1,137],\"1092\":[1,30],\"1093\":[1,56],\"1094\":[1],\"1095\":[2,5],\"1096\":[2,13],\"1097\":[2,1],\"1098\":[1,23],\"1099\":[2,75],\"1100\":[1,80],\"1101\":[1,19],\"1102\":[1,25],\"1103\":[1,71],\"1104\":[1],\"1105\":[3,2],\"1106\":[4,2],\"1107\":[1,13],\"1108\":[2,58],\"1109\":[2,26],\"1110\":[2,27],\"1111\":[2,19],\"1112\":[1,40],\"1113\":[1,75],\"1114\":[2,24],\"1115\":[1,20],\"1116\":[1,74],\"1117\":[1,9],\"1118\":[1,19],\"1119\":[1,56],\"1120\":[1,43],\"1121\":[1,46],\"1122\":[1,15],\"1123\":[1,102],\"1124\":[1,41],\"1125\":[2,27],\"1126\":[1,30],\"1127\":[1],\"1128\":[3,12],\"1129\":[2,14],\"1130\":[2,15],\"1131\":[1,33],\"1132\":[1,14],\"1133\":[1,33],\"1134\":[1,81],\"1135\":[2,33],\"1136\":[1,49],\"1137\":[1,33],\"1138\":[2,113],\"1139\":[1,101],\"1140\":[1,22],\"1141\":[1],\"1142\":[2,6],\"1143\":[2,6],\"1144\":[2,16],\"1145\":[1,5],\"1146\":[1,98],\"1147\":[2,30],\"1148\":[1,47],\"1149\":[1,46],\"1150\":[2,8],\"1151\":[1,17],\"1152\":[2,22],\"1153\":[1,18],\"1154\":[1,24],\"1155\":[1,23],\"1156\":[1,68],\"1157\":[2,49],\"1158\":[1],\"1159\":[3,13],\"1160\":[2,1],\"1161\":[2,1],\"1162\":[1,85],\"1163\":[1,55],\"1164\":[1,120],\"1165\":[1,56],\"1166\":[1,115],\"1167\":[1,64],\"1168\":[1,42],\"1169\":[1,18],\"1170\":[1,74],\"1171\":[1,103],\"1172\":[1,57],\"1173\":[2,17],\"1174\":[2,62],\"1175\":[1,145],\"1176\":[1],\"1177\":[2,11],\"1178\":[2,7],\"1179\":[1],\"1180\":[1],\"1181\":[2,64],\"1182\":[4,81],\"1183\":[2,24],\"1184\":[2,90],\"1185\":[1],\"1186\":[1],\"1187\":[2],\"1188\":[2],\"1189\":[2],\"1190\":[2],\"1191\":[1,30],\"1192\":[1,14],\"1193\":[1,20],\"1194\":[1,19],\"1195\":[1,14],\"1196\":[2,4],\"1197\":[1],\"1198\":[1],\"1199\":[3,18],\"1200\":[4,33],\"1201\":[3,57],\"1202\":[3,17],\"1203\":[3,14],\"1204\":[4,13],\"1205\":[2,2],\"1206\":[1],\"1207\":[1],\"1208\":[3,16],\"1209\":[4,9],\"1210\":[3,16],\"1211\":[2,4],\"1212\":[2],\"1213\":[2,3],\"1214\":[3,4],\"1215\":[2,10],\"1216\":[3,5],\"1217\":[2,10],\"1218\":[3,12],\"1219\":[3,20],\"1220\":[2,1],\"1221\":[1],\"1222\":[1],\"1223\":[2,4],\"1224\":[3,33],\"1225\":[3],\"1226\":[2,58],\"1227\":[2,40],\"1228\":[2,4],\"1229\":[2],\"1230\":[3],\"1231\":[2,16],\"1232\":[1],\"1233\":[1],\"1234\":[2,50],\"1235\":[2,23],\"1236\":[4,31],\"1237\":[2,29],\"1238\":[2,57],\"1239\":[2,17],\"1240\":[5,12],\"1241\":[3,16],\"1242\":[3,14],\"1243\":[5],\"1244\":[1],\"1245\":[1],\"1246\":[3,4],\"1247\":[2],\"1248\":[2,64],\"1249\":[3,4],\"1250\":[1],\"1251\":[1],\"1252\":[3,9],\"1253\":[2],\"1254\":[3,34],\"1255\":[2,3],\"1256\":[2,37],\"1257\":[3,24],\"1258\":[1],\"1259\":[1],\"1260\":[2,17],\"1261\":[4,27],\"1262\":[1,65],\"1263\":[3,64],\"1264\":[2,2],\"1265\":[2,25],\"1266\":[2,21],\"1267\":[2],\"1268\":[2,6],\"1269\":[3,11],\"1270\":[6,51],\"1271\":[2,16],\"1272\":[2,5],\"1273\":[2],\"1274\":[2],\"1275\":[2],\"1276\":[2,6],\"1277\":[2,13],\"1278\":[1],\"1279\":[1],\"1280\":[2,43],\"1281\":[5],\"1282\":[1,14],\"1283\":[1,57],\"1284\":[1,9],\"1285\":[2,4],\"1286\":[2,35],\"1287\":[2,20],\"1288\":[3,96],\"1289\":[2,27],\"1290\":[3,7],\"1291\":[2,9],\"1292\":[2,34],\"1293\":[2,10],\"1294\":[2],\"1295\":[2],\"1296\":[2],\"1297\":[2,41],\"1298\":[3,5],\"1299\":[2,3],\"1300\":[3,26],\"1301\":[2],\"1302\":[1],\"1303\":[1],\"1304\":[3,47],\"1305\":[3,8],\"1306\":[2,7],\"1307\":[3,3],\"1308\":[4,14],\"1309\":[2,27],\"1310\":[4,18],\"1311\":[2,18],\"1312\":[4],\"1313\":[2,1],\"1314\":[3],\"1315\":[2],\"1316\":[2],\"1317\":[2],\"1318\":[2],\"1319\":[3],\"1320\":[2,3],\"1321\":[2],\"1322\":[3],\"1323\":[2],\"1324\":[1],\"1325\":[1],\"1326\":[3,41],\"1327\":[2,26],\"1328\":[2,74],\"1329\":[2,12],\"1330\":[2,19],\"1331\":[2,22],\"1332\":[4,1],\"1333\":[2,30],\"1334\":[2,2],\"1335\":[1],\"1336\":[1],\"1337\":[6,32],\"1338\":[5,3],\"1339\":[2,7],\"1340\":[4,20],\"1341\":[6,9],\"1342\":[2,25],\"1343\":[2,12],\"1344\":[2,10],\"1345\":[1,27],\"1346\":[2,23],\"1347\":[2,22],\"1348\":[2,1],\"1349\":[2,8],\"1350\":[2,6],\"1351\":[2,19],\"1352\":[2,8],\"1353\":[2,32],\"1354\":[2,12],\"1355\":[4,10],\"1356\":[2,6],\"1357\":[2,12],\"1358\":[3,9],\"1359\":[3,14],\"1360\":[4,16],\"1361\":[3,4],\"1362\":[2,4],\"1363\":[3,10],\"1364\":[2,4],\"1365\":[2,33],\"1366\":[2,2],\"1367\":[2,9],\"1368\":[2,27],\"1369\":[2,7],\"1370\":[2,10],\"1371\":[1],\"1372\":[1],\"1373\":[2,17],\"1374\":[2,8],\"1375\":[2,21],\"1376\":[2,5],\"1377\":[3,18],\"1378\":[2,2],\"1379\":[2,7],\"1380\":[2,3],\"1381\":[2,6],\"1382\":[2,4],\"1383\":[2,6],\"1384\":[2,5],\"1385\":[2,7],\"1386\":[2,6],\"1387\":[2,36],\"1388\":[2,21],\"1389\":[2,8],\"1390\":[2,6],\"1391\":[3,25],\"1392\":[2,5],\"1393\":[2,12],\"1394\":[2,18],\"1395\":[3,23],\"1396\":[2,5],\"1397\":[6,8],\"1398\":[3,6],\"1399\":[3,17],\"1400\":[3,11],\"1401\":[2,6],\"1402\":[2,3],\"1403\":[2,4],\"1404\":[7,80],\"1405\":[2,13],\"1406\":[3,9],\"1407\":[2,12],\"1408\":[4,11],\"1409\":[2,3],\"1410\":[2,32],\"1411\":[2,2],\"1412\":[2,26],\"1413\":[2,3],\"1414\":[4],\"1415\":[3,2],\"1416\":[3,14],\"1417\":[1],\"1418\":[1],\"1419\":[2,32],\"1420\":[3,8],\"1421\":[3,53],\"1422\":[4,14],\"1423\":[4,65],\"1424\":[2,40],\"1425\":[2,17],\"1426\":[1],\"1427\":[1],\"1428\":[4],\"1429\":[3,7],\"1430\":[2,2],\"1431\":[4,6],\"1432\":[3,87],\"1433\":[2,19],\"1434\":[2,41],\"1435\":[4,40],\"1436\":[4,29],\"1437\":[2,10],\"1438\":[3,24],\"1439\":[2,17],\"1440\":[2,16],\"1441\":[2,21],\"1442\":[2,15],\"1443\":[2,10],\"1444\":[3],\"1445\":[2],\"1446\":[2],\"1447\":[3,20],\"1448\":[3,4],\"1449\":[3,19],\"1450\":[2],\"1451\":[2,10],\"1452\":[2,2],\"1453\":[2,25],\"1454\":[2,16],\"1455\":[2,6],\"1456\":[3,9],\"1457\":[3,56],\"1458\":[1],\"1459\":[1],\"1460\":[2,4],\"1461\":[2,4],\"1462\":[1],\"1463\":[1],\"1464\":[2,16],\"1465\":[2],\"1466\":[1],\"1467\":[1],\"1468\":[2],\"1469\":[1],\"1470\":[1,28],\"1471\":[1,10],\"1472\":[1],\"1473\":[1,97],\"1474\":[1,72],\"1475\":[3,80],\"1476\":[1,63],\"1477\":[1,90],\"1478\":[1],\"1479\":[1,264],\"1480\":[1,157],\"1481\":[1],\"1482\":[1,65],\"1483\":[1,129],\"1484\":[1,94],\"1485\":[1,159],\"1486\":[1,26],\"1487\":[1,57],\"1488\":[1,30],\"1489\":[1,9],\"1490\":[1,69],\"1491\":[1,18],\"1492\":[1,7],\"1493\":[1,12],\"1494\":[1,22],\"1495\":[1,20],\"1496\":[1,23],\"1497\":[1],\"1498\":[1,108],\"1499\":[1,8],\"1500\":[1,26],\"1501\":[1,118],\"1502\":[1,123],\"1503\":[1,182],\"1504\":[1,2],\"1505\":[1,4],\"1506\":[1,43],\"1507\":[1],\"1508\":[1],\"1509\":[1,66],\"1510\":[1,111],\"1511\":[1,13],\"1512\":[1],\"1513\":[1,7],\"1514\":[1,10],\"1515\":[1],\"1516\":[1,17],\"1517\":[1,116],\"1518\":[1,65],\"1519\":[1,64],\"1520\":[1,75],\"1521\":[1,55],\"1522\":[1],\"1523\":[1],\"1524\":[1,28],\"1525\":[1],\"1526\":[1,67],\"1527\":[3,62],\"1528\":[3,59],\"1529\":[1],\"1530\":[2,47],\"1531\":[1,57],\"1532\":[1],\"1533\":[3,69],\"1534\":[2,55],\"1535\":[2,48],\"1536\":[1,34],\"1537\":[1],\"1538\":[1,23],\"1539\":[1,11],\"1540\":[1,7],\"1541\":[1],\"1542\":[1,26],\"1543\":[1],\"1544\":[1,46],\"1545\":[1,11],\"1546\":[1,148],\"1547\":[1],\"1548\":[1,100],\"1549\":[1,113],\"1550\":[1,180],\"1551\":[1,99],\"1552\":[1],\"1553\":[2,123],\"1554\":[2,330],\"1555\":[1,10],\"1556\":[1],\"1557\":[1,33],\"1558\":[1,10],\"1559\":[1,6],\"1560\":[1,13],\"1561\":[1,64],\"1562\":[1],\"1563\":[1,23],\"1564\":[1,26],\"1565\":[1,53],\"1566\":[1,17],\"1567\":[3,16],\"1568\":[3,15],\"1569\":[1,33],\"1570\":[1,38],\"1571\":[1,10],\"1572\":[1,18],\"1573\":[1,98],\"1574\":[1,151],\"1575\":[1,111],\"1576\":[1,55],\"1577\":[1],\"1578\":[1,6],\"1579\":[1,30],\"1580\":[1,43],\"1581\":[1,14],\"1582\":[1,31],\"1583\":[6,49],\"1584\":[4,37],\"1585\":[1,44],\"1586\":[1,6],\"1587\":[3,53],\"1588\":[3,47],\"1589\":[2],\"1590\":[1],\"1591\":[1,120],\"1592\":[1,58],\"1593\":[1,164],\"1594\":[1,276],\"1595\":[2,193],\"1596\":[1],\"1597\":[1,139],\"1598\":[1,272],\"1599\":[1,225],\"1600\":[1,125],\"1601\":[1,150],\"1602\":[1,38],\"1603\":[1,105],\"1604\":[1,57],\"1605\":[1,103],\"1606\":[1,38],\"1607\":[1,226],\"1608\":[1,282],\"1609\":[1,244],\"1610\":[1,165],\"1611\":[1,103],\"1612\":[1,97],\"1613\":[1,217],\"1614\":[1,194],\"1615\":[1,564],\"1616\":[1,189],\"1617\":[1,366],\"1618\":[1,529],\"1619\":[1,575],\"1620\":[1,1100],\"1621\":[1,395],\"1622\":[1,287],\"1623\":[1,587],\"1624\":[1,17],\"1625\":[2],\"1626\":[1,7],\"1627\":[2,10],\"1628\":[1],\"1629\":[1],\"1630\":[1,47],\"1631\":[1],\"1632\":[1,51],\"1633\":[1,29],\"1634\":[1,20],\"1635\":[1,24],\"1636\":[1,79],\"1637\":[1,25],\"1638\":[1,52],\"1639\":[1,42],\"1640\":[1,20],\"1641\":[1,10],\"1642\":[1],\"1643\":[1],\"1644\":[1,29],\"1645\":[1,34],\"1646\":[3,58],\"1647\":[1,781],\"1648\":[1,406],\"1649\":[1,61],\"1650\":[1,134],\"1651\":[1,181],\"1652\":[1,59],\"1653\":[1,57],\"1654\":[2,234],\"1655\":[1,238],\"1656\":[2,4],\"1657\":[2,75],\"1658\":[2,100],\"1659\":[4,17],\"1660\":[2,6],\"1661\":[3,7],\"1662\":[1],\"1663\":[1,157],\"1664\":[1,102],\"1665\":[1,2],\"1666\":[1,11],\"1667\":[1,2],\"1668\":[1,10],\"1669\":[1,8],\"1670\":[1],\"1671\":[1],\"1672\":[1],\"1673\":[1],\"1674\":[1],\"1675\":[1],\"1676\":[1],\"1677\":[1],\"1678\":[1],\"1679\":[2],\"1680\":[1],\"1681\":[2],\"1682\":[1],\"1683\":[1,67],\"1684\":[1],\"1685\":[1,7],\"1686\":[1,5],\"1687\":[1,56],\"1688\":[1,10],\"1689\":[1,57],\"1690\":[1],\"1691\":[1,8],\"1692\":[1,9],\"1693\":[1,27],\"1694\":[1],\"1695\":[1],\"1696\":[1],\"1697\":[1],\"1698\":[1],\"1699\":[1],\"1700\":[1],\"1701\":[1],\"1702\":[1],\"1703\":[1],\"1704\":[1],\"1705\":[1],\"1706\":[1],\"1707\":[1],\"1708\":[1],\"1709\":[1],\"1710\":[1],\"1711\":[1],\"1712\":[1],\"1713\":[1],\"1714\":[1],\"1715\":[1],\"1716\":[1],\"1717\":[1],\"1718\":[1],\"1719\":[1],\"1720\":[2],\"1721\":[2],\"1722\":[2],\"1723\":[1],\"1724\":[1],\"1725\":[1],\"1726\":[2],\"1727\":[2],\"1728\":[2],\"1729\":[1],\"1730\":[1],\"1731\":[1],\"1732\":[1],\"1733\":[1],\"1734\":[1],\"1735\":[1],\"1736\":[1],\"1737\":[1],\"1738\":[1],\"1739\":[2],\"1740\":[1],\"1741\":[1],\"1742\":[1],\"1743\":[1],\"1744\":[1],\"1745\":[1],\"1746\":[1],\"1747\":[1],\"1748\":[1],\"1749\":[1],\"1750\":[1],\"1751\":[2],\"1752\":[2],\"1753\":[3],\"1754\":[1],\"1755\":[1],\"1756\":[1],\"1757\":[1],\"1758\":[1],\"1759\":[1],\"1760\":[1],\"1761\":[1],\"1762\":[1],\"1763\":[1],\"1764\":[1],\"1765\":[1],\"1766\":[1],\"1767\":[1],\"1768\":[1],\"1769\":[1],\"1770\":[2],\"1771\":[1],\"1772\":[1],\"1773\":[1],\"1774\":[1],\"1775\":[1],\"1776\":[1],\"1777\":[1],\"1778\":[1],\"1779\":[2],\"1780\":[1],\"1781\":[1],\"1782\":[1],\"1783\":[1],\"1784\":[1],\"1785\":[1],\"1786\":[1],\"1787\":[1],\"1788\":[1],\"1789\":[1],\"1790\":[1],\"1791\":[1],\"1792\":[1],\"1793\":[1],\"1794\":[1],\"1795\":[1],\"1796\":[1],\"1797\":[2],\"1798\":[2],\"1799\":[1],\"1800\":[1],\"1801\":[1],\"1802\":[1],\"1803\":[1],\"1804\":[1],\"1805\":[1],\"1806\":[1],\"1807\":[1],\"1808\":[1],\"1809\":[1],\"1810\":[1],\"1811\":[1],\"1812\":[1],\"1813\":[1],\"1814\":[1],\"1815\":[1],\"1816\":[1],\"1817\":[1],\"1818\":[1],\"1819\":[1],\"1820\":[1],\"1821\":[1],\"1822\":[1],\"1823\":[1],\"1824\":[1],\"1825\":[1],\"1826\":[1],\"1827\":[1],\"1828\":[1],\"1829\":[1],\"1830\":[1],\"1831\":[1],\"1832\":[1],\"1833\":[1],\"1834\":[1],\"1835\":[1],\"1836\":[1],\"1837\":[1],\"1838\":[1],\"1839\":[1],\"1840\":[1],\"1841\":[1],\"1842\":[1],\"1843\":[1],\"1844\":[1],\"1845\":[1],\"1846\":[1],\"1847\":[1],\"1848\":[1],\"1849\":[1],\"1850\":[1],\"1851\":[1],\"1852\":[1],\"1853\":[1],\"1854\":[1],\"1855\":[1],\"1856\":[1],\"1857\":[1],\"1858\":[1],\"1859\":[1],\"1860\":[1],\"1861\":[1],\"1862\":[1],\"1863\":[1],\"1864\":[1],\"1865\":[1],\"1866\":[1],\"1867\":[1],\"1868\":[1],\"1869\":[1],\"1870\":[1],\"1871\":[1],\"1872\":[1],\"1873\":[1],\"1874\":[1],\"1875\":[1],\"1876\":[1],\"1877\":[1],\"1878\":[1],\"1879\":[1],\"1880\":[1],\"1881\":[1],\"1882\":[1],\"1883\":[1],\"1884\":[1],\"1885\":[1],\"1886\":[1],\"1887\":[1],\"1888\":[1],\"1889\":[1],\"1890\":[1],\"1891\":[1],\"1892\":[1],\"1893\":[1],\"1894\":[1],\"1895\":[1],\"1896\":[1],\"1897\":[1],\"1898\":[1],\"1899\":[1],\"1900\":[1],\"1901\":[1],\"1902\":[1],\"1903\":[1],\"1904\":[1],\"1905\":[1],\"1906\":[1],\"1907\":[1],\"1908\":[1],\"1909\":[1],\"1910\":[1],\"1911\":[1],\"1912\":[1],\"1913\":[1],\"1914\":[1],\"1915\":[1],\"1916\":[1],\"1917\":[1],\"1918\":[3],\"1919\":[1],\"1920\":[1],\"1921\":[1],\"1922\":[1],\"1923\":[1],\"1924\":[1],\"1925\":[1],\"1926\":[1],\"1927\":[1],\"1928\":[1],\"1929\":[1],\"1930\":[1],\"1931\":[1],\"1932\":[1],\"1933\":[1],\"1934\":[1],\"1935\":[1],\"1936\":[1],\"1937\":[1],\"1938\":[1],\"1939\":[1],\"1940\":[1],\"1941\":[1],\"1942\":[1],\"1943\":[1],\"1944\":[1],\"1945\":[1],\"1946\":[1],\"1947\":[1],\"1948\":[1],\"1949\":[1],\"1950\":[1],\"1951\":[1],\"1952\":[1],\"1953\":[1],\"1954\":[1],\"1955\":[1],\"1956\":[1],\"1957\":[1],\"1958\":[1],\"1959\":[1],\"1960\":[1],\"1961\":[1],\"1962\":[1],\"1963\":[1],\"1964\":[1],\"1965\":[1,17],\"1966\":[1,64],\"1967\":[1,2],\"1968\":[1,19],\"1969\":[3,73],\"1970\":[2,14],\"1971\":[1,7],\"1972\":[1,56],\"1973\":[2],\"1974\":[1,60],\"1975\":[1,33],\"1976\":[3,6],\"1977\":[1,10],\"1978\":[1,37],\"1979\":[2,20],\"1980\":[1,28],\"1981\":[1,35],\"1982\":[1,51],\"1983\":[2,42],\"1984\":[2,6],\"1985\":[1,29],\"1986\":[1,34],\"1987\":[1,42],\"1988\":[2,6],\"1989\":[2,22],\"1990\":[1,26],\"1991\":[1,13],\"1992\":[2,45],\"1993\":[1,16],\"1994\":[1,3]},\"averageFieldLength\":[1.5669172932330813,40.442265174823596],\"storedFields\":{\"0\":{\"h\":\"关于我\"},\"1\":{\"h\":\"开源项目\",\"t\":[\"软考通（Owner）\",\"代码随想录（Contributor）\"]},\"2\":{\"h\":\"社区\",\"t\":[\"掘金\"]},\"3\":{\"h\":\"技能点\",\"t\":[\"Java（⭐⭐⭐⭐⭐）\",\"Flutter（⭐⭐⭐）\",\"Vue（⭐⭐⭐）\",\"C++（⭐⭐）\"]},\"4\":{\"h\":\"个人经历\",\"t\":[\"2015-2019 中国矿业大学（北京）\",\"2019-2020 杭州\",\"2021-至今 深圳\"]},\"5\":{\"h\":\"联系我\",\"t\":[\"jycoder@163.com\"]},\"6\":{\"h\":\"Java面试题精选\"},\"7\":{\"h\":\"Java基础\"},\"8\":{\"h\":\"JVM、JDK 和 JRE 联系与区别？\"},\"9\":{\"h\":\"构造器 Constructor 是否可被 override?\"},\"10\":{\"h\":\"重载和重写的区别？\"},\"11\":{\"h\":\"面向对象编程三⼤特性: 封装 继承 多态\"},\"12\":{\"h\":\"String StringBuffer 和 StringBuilder 的区别是什么?\"},\"13\":{\"h\":\"String类为什么是不可变的?\"},\"14\":{\"h\":\"Integer的缓存机制？\"},\"15\":{\"h\":\"深拷贝和浅拷贝的区别？\"},\"16\":{\"h\":\"接口和抽象类的区别\"},\"17\":{\"h\":\"构造方法有哪些特性？\"},\"18\":{\"h\":\"String中hashCode的实现？\"},\"19\":{\"h\":\"hashCode和equals的作用？\"},\"20\":{\"h\":\"JDK8有哪些新特性？\"},\"21\":{\"h\":\"Java反射有哪些作用？\"},\"22\":{\"h\":\"如何使用反射获取私有属性？\"},\"23\":{\"h\":\"创建对象有哪些方式？\"},\"24\":{\"h\":\"迭代器和for循环遍历的区别？\"},\"25\":{\"h\":\"过滤器和拦截器的区别？\"},\"26\":{\"h\":\"Java集合\"},\"27\":{\"h\":\"List、Set、Map三者的区别？\"},\"28\":{\"h\":\"HashMap实现原理？\"},\"29\":{\"h\":\"HashMap为什么扩容为2倍？\"},\"30\":{\"h\":\"为什么HashMap不用LinkedList，而是选用数组？\"},\"31\":{\"h\":\"JDK1.8对HashMap有哪些优化？\"},\"32\":{\"h\":\"为什么不直接使用红黑树，而是选择先用链表，再转红黑树？\"},\"33\":{\"h\":\"HashMap不使用红黑树，而是使用二叉查找树可以吗？\"},\"34\":{\"h\":\"为什么阈值是8？\"},\"35\":{\"h\":\"当链表转为红黑树，什么时候退化为链表？\"},\"36\":{\"h\":\"HashMap在并发编程环境下有什么问题？\"},\"37\":{\"h\":\"使用可变类当HashMap的key有什么问题？\"},\"38\":{\"h\":\"如何实现一个自定义的Class作为HashMap的key？\"},\"39\":{\"h\":\"两个相同对象没有重写equals方法放到HashMap覆盖吗?\"},\"40\":{\"h\":\"HashSet实现原理？\"},\"41\":{\"h\":\"CurrentHashMap的实现原理？\"},\"42\":{\"h\":\"ArrayList的实现原理？\"},\"43\":{\"h\":\"Java并发\"},\"44\":{\"h\":\"并发编程的三要素？\"},\"45\":{\"h\":\"线程和进程的区别？\"},\"46\":{\"h\":\"守护线程和用户线程的区别？\"},\"47\":{\"h\":\"什么是线程安全？\"},\"48\":{\"h\":\"Java如何开启线程？怎么保证线程安全？\"},\"49\":{\"h\":\"线程有哪些状态？\"},\"50\":{\"h\":\"如何停止一个正在运行的线程？\"},\"51\":{\"h\":\"notify和notifyAll有什么区别？\"},\"52\":{\"h\":\"wait和sleep方法有什么区别？\"},\"53\":{\"h\":\"为什么wait和notify方法要在同步块中调用？\"},\"54\":{\"h\":\"Thread类中的yield方法有什么作用？\"},\"55\":{\"h\":\"volatile和synchronized有什么区别？\"},\"56\":{\"h\":\"volatile变量和atomic变量什么不同？\"},\"57\":{\"h\":\"interrupted和isInterrupted方法的区别？\"},\"58\":{\"h\":\"volatile能不能保证线程安全？\"},\"59\":{\"h\":\"DCL单例为什么加volatile？\"},\"60\":{\"h\":\"死锁与活锁的区别？\"},\"61\":{\"h\":\"死锁与饥饿的区别？\"},\"62\":{\"h\":\"按照线程安全的强度来区分，分为哪几类？\"},\"63\":{\"h\":\"线程安全的实现方法有哪些？\"},\"64\":{\"h\":\"锁优化技术你了解什么？\"},\"65\":{\"h\":\"Lock与synchronized有什么区别？\"},\"66\":{\"h\":\"什么是阻塞队列？阻塞队列的实现原理是什么？\"},\"67\":{\"h\":\"什么是Callable和Future？\"},\"68\":{\"h\":\"Java线程锁机制是怎样的？偏向锁、轻量级锁、重量级锁有什么区别？锁机制是如何升级的？\"},\"69\":{\"h\":\"什么是可重入锁？有哪些实现？\"},\"70\":{\"h\":\"什么是悲观锁？什么是乐观锁？\"},\"71\":{\"h\":\"谈谈你对AQS的理解，AQS如何实现可重入锁？\"},\"72\":{\"h\":\"SynchronizedMap和ConcurrentHashMap有什么区别？\"},\"73\":{\"h\":\"ConcurrentHashMap的并发度是什么？\"},\"74\":{\"h\":\"CopyOnWriteArrayList可以用于什么应用场景？\"},\"75\":{\"h\":\"有A、B、C三个线程，如何保证三个线程同时执行？如何在并发情况下保证三个线程依次执行？如何保证三个线程有序交错进行？\"},\"76\":{\"h\":\"什么是指令重排序？\"},\"77\":{\"h\":\"ThreadLocal的作用？导致内存泄漏的原因是什么？\"},\"78\":{\"h\":\"使用线程池有什么好处？\"},\"79\":{\"h\":\"线程池中submit()和execute()方法有什么区别？\"},\"80\":{\"h\":\"什么是Executors框架？\"},\"81\":{\"h\":\"线程池的拒绝策略？\"},\"82\":{\"h\":\"如何获取子线程的执行结果？\"},\"83\":{\"h\":\"如何对一个字符串快速进行排序？\"},\"84\":{\"h\":\"线程池的参数如何设置？\"},\"85\":{\"h\":\"子线程中如何获取父线程的 中的值、 的数据结构？\"},\"86\":{\"h\":\"高并发下，如何保证接口的幂等性？\"},\"87\":{\"h\":\"除了Lock和synchronized，还有什么方式可以保障线程安全？\"},\"88\":{\"h\":\"Java网络通信\"},\"89\":{\"h\":\"TCP和UDP有什么区别？\"},\"90\":{\"h\":\"TCP为什么是三次握手，而不是两次？\"},\"91\":{\"h\":\"Java有哪几种IO模型？有什么区别？\"},\"92\":{\"h\":\"Java NIO的几个核心组件是什么？分别有什么作用？\"},\"93\":{\"h\":\"select、poll、epoll有什么区别？\"},\"94\":{\"h\":\"HTTP和HTTPS的区别？\"},\"95\":{\"h\":\"三次握手和四次挥手？\"},\"96\":{\"h\":\"Java虚拟机\"},\"97\":{\"h\":\"运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？\"},\"98\":{\"h\":\"Java 创建一个对象的过程？\"},\"99\":{\"h\":\"如何访问对象？\"},\"100\":{\"h\":\"Java 内存模型的原子性、可见性和有序性是通过哪些操作实现的？\"},\"101\":{\"h\":\"什么是双亲委派机制？有什么作用？\"},\"102\":{\"h\":\"Java类加载的全过程是怎么样的？\"},\"103\":{\"h\":\"你了解分代理论吗？\"},\"104\":{\"h\":\"JDK 中有几种引用类型？分别的特点是什么？\"},\"105\":{\"h\":\"一个对象从加载到JVM，再到GC清除，都经历了什么过程？\"},\"106\":{\"h\":\"怎么样确定一个对象不是垃圾？\"},\"107\":{\"h\":\"什么是GC Root？\"},\"108\":{\"h\":\"JVM有哪些垃圾回收算法？\"},\"109\":{\"h\":\"什么是STW？\"},\"110\":{\"h\":\"JVM有哪些垃圾回收器？\"},\"111\":{\"h\":\"什么是三色标记算法？\"},\"112\":{\"h\":\"如何回收方法区？\"},\"113\":{\"h\":\"JVM 中的安全点和安全区各代表什么？\"},\"114\":{\"h\":\"写屏障你了解吗？\"},\"115\":{\"h\":\"解决并发扫描时对象消失问题的两种方案？\"},\"116\":{\"h\":\"CMS 垃圾收集器的步骤？\"},\"117\":{\"h\":\"CMS 有什么缺点？\"},\"118\":{\"h\":\"G1垃圾收集器的步骤，G1有什么优缺点？\"},\"119\":{\"h\":\"讲一下内存分配策略？\"},\"120\":{\"h\":\"内存溢出和内存泄漏的区别？\"},\"121\":{\"h\":\"如何进行JVM调优？\"},\"122\":{\"h\":\"JVM参数有哪些？\"},\"123\":{\"h\":\"虚拟机基础故障处理工具有哪些？\"},\"124\":{\"h\":\"怎么查看一个Java进程的JVM参数，谈谈你了解的JVM参数\"},\"125\":{\"h\":\"什么情况下堆内存会溢出，什么情况方法区会内存溢出？\"},\"126\":{\"h\":\"JDK8 为什么要将永久代改为元空间？\"},\"127\":{\"h\":\"Redis\"},\"128\":{\"h\":\"Redis支持哪些数据类型？\"},\"129\":{\"h\":\"什么是缓存穿透？缓存击穿？缓存雪崩？怎么解决？\"},\"130\":{\"h\":\"缓存穿透\"},\"131\":{\"h\":\"缓存击穿\"},\"132\":{\"h\":\"缓存雪崩\"},\"133\":{\"h\":\"如何保证Redis与数据库的数据一致？\"},\"134\":{\"h\":\"先删缓存，再写数据库\"},\"135\":{\"h\":\"先写数据库，再删缓存\"},\"136\":{\"h\":\"如何设计一个分布式锁？如何对锁性能进行优化？\"},\"137\":{\"h\":\"Redis的过期删除策略？\"},\"138\":{\"h\":\"RDB操作，子进程会全部复制父进程的数据吗？\"},\"139\":{\"h\":\"Redis的哨兵模式？\"},\"140\":{\"h\":\"Redis使用单线程为什么速度这么快？\"},\"141\":{\"h\":\"Redis自增命令使用？\"},\"142\":{\"h\":\"Redis如何实现消息队列？\"},\"143\":{\"h\":\"Redisson实现分布式锁的原理？\"},\"144\":{\"h\":\"Redis为什么能通过Lua脚本保证并发的线程安全？\"},\"145\":{\"h\":\"谈一下Redis事务的了解？\"},\"146\":{\"h\":\"Pipeline有什么好处，为什么要用pipeline？\"},\"147\":{\"h\":\"Redis延迟队列怎么实现的？\"},\"148\":{\"h\":\"Redis在内存不足时，内存淘汰策略是怎么样的？\"},\"149\":{\"h\":\"如何保证Redis的高可用？\"},\"150\":{\"h\":\"MySQL\"},\"151\":{\"h\":\"MySQL有哪几种数据存储引擎?\"},\"152\":{\"h\":\"什么是脏读、不可重复读、幻读？\"},\"153\":{\"h\":\"事务的基本特性和隔离级别\"},\"154\":{\"h\":\"MySQL的锁有哪些？什么是间隙锁？\"},\"155\":{\"h\":\"MySQL索引结构是什么样的？\"},\"156\":{\"h\":\"Mysql的索引结构为什么使用B+树？\"},\"157\":{\"h\":\"聚簇索引和非聚簇索引有什么区别？\"},\"158\":{\"h\":\"MySQL主键索引和普通索引有什么区别？\"},\"159\":{\"h\":\"MySQL的索引覆盖和回表是什么？\"},\"160\":{\"h\":\"MySQL集群是如何搭建的？读写分离是怎么做的？\"},\"161\":{\"h\":\"MySQL如何进行分库分表？多大数据量需要进行分库分表？分库分表的方式和分片策略由哪些？分库分表后，SQL语句执行流程是怎样的？\"},\"162\":{\"h\":\"Mysql的三种删除方式的区别？\"},\"163\":{\"h\":\"慢SQL的优化思路？\"},\"164\":{\"h\":\"limit语句会扫描全表吗？\"},\"165\":{\"h\":\"大数量分页查询该怎么优化？\"},\"166\":{\"h\":\"平时项目里面表结构是如何进行设计的？\"},\"167\":{\"h\":\"MySQL的索引类型？\"},\"168\":{\"h\":\"MySQL如何快速插入千万级数据？\"},\"169\":{\"h\":\"Elasticsearch\"},\"170\":{\"h\":\"什么是倒排索引？有什么好处？\"},\"171\":{\"h\":\"搜索引擎为什么MySQL查询快？\"},\"172\":{\"h\":\"ES了解多少？说说你们公司的ES集群架构。\"},\"173\":{\"h\":\"如何进行中文分词？\"},\"174\":{\"h\":\"ES写入数据与查询数据的原理。\"},\"175\":{\"h\":\"ES部署时，要如何进行优化？\"},\"176\":{\"h\":\"Spring面试题\"},\"177\":{\"h\":\"Spring框架中Bean的创建过程是怎样的？\"},\"178\":{\"h\":\"Spring中Bean的作用域？\"},\"179\":{\"h\":\"Spring框架中的Bean是线程安全的吗？如果线程不安全，如何处理？\"},\"180\":{\"h\":\"Spring是如何处理循环依赖问题的？\"},\"181\":{\"h\":\"Spring如何处理事务?\"},\"182\":{\"h\":\"Spring事务失效的场景有哪些？\"},\"183\":{\"h\":\"Spring MVC中的控制器是不是单例模式？如果是，如何保证线程安全？\"},\"184\":{\"h\":\"Spring MVC原理？\"},\"185\":{\"h\":\"Spring中的Service有多个实现类，怎么注入？\"},\"186\":{\"h\":\"SpringBoot面试题\"},\"187\":{\"h\":\"为什么SpringBoot的 jar可以直接运行？\"},\"188\":{\"h\":\"SpringBoot自动装配过程及实现原理？\"},\"189\":{\"h\":\"SpringBoot如何防止表单重复提交？\"},\"190\":{\"h\":\"如何自己写一个SpringBoot Starter？\"},\"191\":{\"h\":\"MyBatis面试题\"},\"192\":{\"h\":\"Mybatis接口 Mapper内的方法为什么不能重载？\"},\"193\":{\"h\":\"Mybatis的XML映射文件中，不同的XML映射文件，id是否可以重复？\"},\"194\":{\"h\":\"#{}和${}的区别是什么？\"},\"195\":{\"h\":\"当实体类中的属性名和表中的字段名不一样怎么办？\"},\"196\":{\"h\":\"执行插入语句后如何该数据的主键？\"},\"197\":{\"h\":\"模糊查询like语句该怎么写？\"},\"198\":{\"h\":\"Mybatis时如何进行分页的？分页插件的原理是什么?\"},\"199\":{\"h\":\"Mybatis有哪些动态sql标签？\"},\"200\":{\"h\":\"Mybtais动态sql有什么用？执行原理是什么？\"},\"201\":{\"h\":\"Mapper编写有哪几种方式？\"},\"202\":{\"h\":\"Mybatis的一级、二级缓存？\"},\"203\":{\"h\":\"Mybatis有二级缓存，为什么还要用Redis？\"},\"204\":{\"h\":\"Mybatis如何开启二级缓存？\"},\"205\":{\"h\":\"Netty面试题\"},\"206\":{\"h\":\"Netty有哪些应用场景？\"},\"207\":{\"h\":\"Netty核心组件有哪些？分别有什么作用？\"},\"208\":{\"h\":\"EventLoopGroup了解么?和EventLoop什么关系?\"},\"209\":{\"h\":\"Bootstrap和ServerBootstrap了解么？\"},\"210\":{\"h\":\"NioEventLoopGroup默认的构造函数会起多少线程？\"},\"211\":{\"h\":\"Netty线程模型了解么？\"},\"212\":{\"h\":\"Netty服务端和客户端的启动过程了解么？\"},\"213\":{\"h\":\"Netty长连接、心跳机制了解么？\"},\"214\":{\"h\":\"Netty的零拷贝了解么？\"},\"215\":{\"h\":\"网络安全\"},\"216\":{\"h\":\"什么是认证和授权？如何设计一个权限认证框架？\"},\"217\":{\"h\":\"Cookie和Session有什么区别？如果没有Cookie、Seesion还能进行身份验证吗？\"},\"218\":{\"h\":\"什么是CSRF攻击？如何防止？\"},\"219\":{\"h\":\"什么是OAuth2？有哪几种认证方式？\"},\"220\":{\"h\":\"什么是JWT令牌？和普通令牌有什么区别？\"},\"221\":{\"h\":\"什么是SSO？与OAuth2.0有什么关系？\"},\"222\":{\"h\":\"如何实现单点登录系统？\"},\"223\":{\"h\":\"微服务\"},\"224\":{\"h\":\"谈谈你对微服务的理解，微服务有哪些优缺点？\"},\"225\":{\"h\":\"SpringCloud和SpringCloudAlibaba有哪些组件？都解决了什么问题？\"},\"226\":{\"h\":\"SpringCloud和Dubbo的区别？\"},\"227\":{\"h\":\"分布式事务如何处理？怎么保证事务一致性？\"},\"228\":{\"h\":\"怎么拆分微服务？怎样设计出高内聚、低耦合的微服务？\"},\"229\":{\"h\":\"有没有了解通过DDD领域驱动设计？\"},\"230\":{\"h\":\"微服务的链路追踪、持续集成、AB发布要怎么做？\"},\"231\":{\"h\":\"Nacos和Eureka的区别？\"},\"232\":{\"h\":\"Nacos配置中心，本地Resource，jar包中同级目录的配置文件加载优先级？\"},\"233\":{\"h\":\"Nacos的配置动态更新原理？\"},\"234\":{\"h\":\"使用Nacos配置中心，@Value对应的配置项如何动态更新？\"},\"235\":{\"h\":\"Nacos中命名空间和分组的概念及区别？\"},\"236\":{\"h\":\"Nacos同一个namespace中的不同的group注册的服务可以相互访问吗？\"},\"237\":{\"h\":\"Nacos服务注册的流程是怎么样的？\"},\"238\":{\"h\":\"微服务下服务a调用服务b的流程？\"},\"239\":{\"h\":\"注册中心，如何通过服务名找到服务实例？\"},\"240\":{\"h\":\"熔断和限流有什么区别？\"},\"241\":{\"h\":\"雪花算法有什么缺点？\"},\"242\":{\"h\":\"Gateway有哪些功能？如何配置动态路由？\"},\"243\":{\"h\":\"如何手写一个注册中心？\"},\"244\":{\"h\":\"消息队列\"},\"245\":{\"h\":\"ＭＱ有什么用？有哪些具体的使用场景？\"},\"246\":{\"h\":\"如何进行产品选型？\"},\"247\":{\"h\":\"如何保证消息不丢失？\"},\"248\":{\"h\":\"如何保证消费幂等性?\"},\"249\":{\"h\":\"MQ如何保证消息顺序?\"},\"250\":{\"h\":\"如何保证消息的高效读写?\"},\"251\":{\"h\":\"MQ 中消费时，业务逻辑出现异常怎么办？\"},\"252\":{\"h\":\"使用MQ如何保证分布式事务的最终一致性？\"},\"253\":{\"h\":\"Kafka如何避免重复消费？\"},\"254\":{\"h\":\"Linux命令\"},\"255\":{\"h\":\"使用cat命令如何统计文件中一个字符串出现的频率？\"},\"256\":{\"h\":\"如何查看一个应用的信息？\"},\"257\":{\"h\":\"Dokcer命令\"},\"258\":{\"h\":\"Docker常用的命令？\"},\"259\":{\"h\":\"查看所有容器的命令？\"},\"260\":{\"h\":\"Nginx\"},\"261\":{\"h\":\"Nginx如何保证高可用？\"},\"262\":{\"h\":\"设计模式\"},\"263\":{\"h\":\"列举一些JDK中用到的设计模式？\"},\"264\":{\"h\":\"列举一些Spring当中用到的设计模式？\"},\"265\":{\"h\":\"项目中有用过设计模式吗？\"},\"266\":{\"h\":\"单例模式有哪些实现方式？\"},\"267\":{\"h\":\"懒汉式\"},\"268\":{\"h\":\"饿汉式\"},\"269\":{\"h\":\"双重检查锁\"},\"270\":{\"h\":\"静态内部类\"},\"271\":{\"h\":\"枚举类\"},\"272\":{\"h\":\"单例模式有什么应用场景？\"},\"273\":{\"h\":\"Java EE简介\",\"t\":[\"Java EE 号称有十三种核心技术。它们分别是：JDBC、JNDI、EJB、RMI、Servlet、JSP、XML、JMS、Java IDL、JTS、JTA、JavaMail和JAF。\"]},\"274\":{\"h\":\"thinking in os\"},\"275\":{\"h\":\"什么是操作系统\"},\"276\":{\"h\":\"操作系统分类\"},\"277\":{\"h\":\"操作系统的发展史\"},\"278\":{\"h\":\"计算机组成原理\"},\"279\":{\"h\":\"CPU\"},\"280\":{\"h\":\"地址总线\"},\"281\":{\"h\":\"DRAM\"},\"282\":{\"h\":\"计算机的启动过程\"},\"283\":{\"h\":\"BIOS\"},\"284\":{\"h\":\"地址、section、vstart\"},\"285\":{\"h\":\"地址\"},\"286\":{\"h\":\"section\"},\"287\":{\"h\":\"vstart\"},\"288\":{\"h\":\"CPU的实模式\"},\"289\":{\"h\":\"CPU的工作原理\"},\"290\":{\"h\":\"实模式\"},\"291\":{\"h\":\"硬盘操作\"},\"292\":{\"h\":\"获取物理内存容量\"},\"293\":{\"h\":\"内存分页机制\"},\"294\":{\"h\":\"混合编程\"},\"295\":{\"h\":\"基本内联混编\"},\"296\":{\"h\":\"内联编程\"},\"297\":{\"h\":\"扩展内联混编\"},\"298\":{\"h\":\"ElaticSearch\"},\"299\":{\"h\":\"ElaticSearch快速入门\",\"t\":[\"全文检索是指：\",\"通过一个程序扫描文本中的每一个单词，针对单词建立索引，并保存该单词在文本中的位置、以及出现的次数\",\"用户查询时，通过之前建立好的索引来查询，将索引中单词对应的文本位置、出现的次数返回给用户，因为有了具体文本的位置，所以就可以将具体的内容读取出来了\",\"例如，在csdn中搜索elaticsearch快速入门：\"]},\"300\":{\"h\":\"倒排索引\",\"t\":[\"索引类似目录，平时我们使用的都是索引，通过主键定位到某条数据，倒排索引则是数据对应到主键。\",\"这里以一个博客文章的内容为例：\",\"正排索引：\",\"文章ID\",\"文章标题\",\"文章内容\",\"1\",\"浅析Java设计模式\",\"Java设计模式是每一个Java程序员都应该掌握的进阶知识\",\"2\",\"Java多线程设计模式\",\"Java多线程与设计模式结合\",\"假设有一个站内搜索的功能，是通过某个关键词来搜索相关的文章，那么这个关键词可能出现在标题中，也可能出现在文章内容中，那我们将会在创建或修改文章的时候，建立一个关键词与文章的对应关系表，这种我们就可以称之为倒排索引。\",\"假设我们搜索关键词“Java设计模式”，那么就可以通过倒排索引，找到对应的文章的主键id。\",\"关键词\",\"文章ID\",\"Java\",\"1，2\",\"设计模式\",\"1，2\",\"多线程\",\"2\",\"简单理解，正向索引是通过key找value，反向索引则是通过value找key。ElaticSearch底层在检索时使用的就是倒排索引。\"]},\"301\":{\"h\":\"ElaticSearch简介\",\"t\":[\"ElaticSearch（简称ES）是一个分布式、RESTful风格的搜索和数据分析引擎，是用Java开发并且是当前最流行的开源的企业级搜索引擎，能够达到近实时搜索，稳定，可靠，快速，安装使用方便。\",\"ES起源于Lucene，基于Java语言开发，具有高性能，易扩展的优点，ES有以下应用场景：\",\"站内搜索\",\"日志管理与分析\",\"大数据分析\",\"应用性能监控\",\"机器学习\",\"传统的关系型数据库和ES的区别：\",\"ES：Schemaless/相关性/高性能全文检索\",\"RDMS：事务性/Join\"]},\"302\":{\"h\":\"ElaticSearch基本概念\",\"t\":[\"可以将ES中的一些基本概念映射到关系型数据库：\"]},\"303\":{\"h\":\"索引\",\"t\":[\"一个索引就是一个拥有几分相似特征的文档的集合。比如说，可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。\",\"一个索引由一个名字来表示同意（必须全部是小写字母的），并且当我们要对对应于这个索引的文档进行索引、搜索、更新和删除操作的时候，都要用到这个名字。\"]},\"304\":{\"h\":\"文档\",\"t\":[\"ES是面向文档的，文档是所有可搜索数据的最小单位。例如：\",\"日志文件中的日志项\",\"一本电影的具体信息/一张唱片的详细信息\",\"MP3播放器里的一首歌/一篇PDF文档中的具体内容\",\"文档会被序列化成JSON格式，保存在ES中：\",\"JSON对象由字段组成\",\"每个字段都有对应的字段类型（字符串/数值/布尔/日期/二进制/范围类型）\",\"每个文档都有一个Unique UD，可以自己指定ID或者通过ES自动生成。一篇文档包含了一系列字段，类似关系型数据库表中的一条记录。\",\"JSON文档，格式灵活，不需要预先定义格式：\",\"字段的类型可以指定或者通过ES自动推算\",\"支持数组/支持嵌套\",\"文档的元数据信息：\",\"其中各项含义：\",\"_index：文档所属的索引名\",\"：文档所属的类型名\",\"_id：文档唯一Id\",\"_source：文档的原始JSON数据\",\"_version：文档的版本号，修改删除操作 _version 都会自增1\",\"_seq_no：和 _version 一样，一旦数据发生更改，数据也一直是累计的。Shard级别严格递增，保证后写入的Doc的 _seq_no 大于先写入Doc的 _seq_no。\",\"_primary_term： _primary_term 主要是用来恢复数据时处理当多个文档的 _seq_no 一样时的冲突，避免Primary Shard上的写入被覆盖。每当Primary Shard发生重新分配时，比如重启，Primary选举等， _primary_term 会递增1。\"]},\"305\":{\"h\":\"索引操作\",\"t\":[\"注意：索引命名必须小写，不能以下划线开头。\",\"创建索引格式：\",\"#创建索引 PUT /es_db #创建索引时可以设置分片数和副本数 PUT /es_db { \\\"settings\\\" : { \\\"number_of_shards\\\" : 3, \\\"number_of_replicas\\\" : 2 } } #修改索引配置 PUT /es_db/_settings { \\\"index\\\": { \\\"number_of_replicas\\\": 1 } } \"]},\"306\":{\"h\":\"文档操作\",\"t\":[\"添加示例数据：\",\"PUT /es_db { \\\"settings\\\" : { \\\"index\\\" : { \\\"analysis.analyzer.default.type\\\": \\\"ik_max_word\\\" } } } PUT /es_db/_doc/1 { \\\"name\\\": \\\"张三\\\", \\\"sex\\\": 1, \\\"age\\\": 25, \\\"address\\\": \\\"广州天河公园\\\", \\\"remark\\\": \\\"java developer\\\" } PUT /es_db/_doc/2 { \\\"name\\\": \\\"李四\\\", \\\"sex\\\": 1, \\\"age\\\": 28, \\\"address\\\": \\\"广州荔湾大厦\\\", \\\"remark\\\": \\\"java assistant\\\" } PUT /es_db/_doc/3 { \\\"name\\\": \\\"王五\\\", \\\"sex\\\": 0, \\\"age\\\": 26, \\\"address\\\": \\\"广州白云山公园\\\", \\\"remark\\\": \\\"php developer\\\" } PUT /es_db/_doc/4 { \\\"name\\\": \\\"赵六\\\", \\\"sex\\\": 0, \\\"age\\\": 22, \\\"address\\\": \\\"长沙橘子洲\\\", \\\"remark\\\": \\\"python assistant\\\" } PUT /es_db/_doc/5 { \\\"name\\\": \\\"张龙\\\", \\\"sex\\\": 0, \\\"age\\\": 19, \\\"address\\\": \\\"长沙麓谷企业广场\\\", \\\"remark\\\": \\\"java architect assistant\\\" } PUT /es_db/_doc/6 { \\\"name\\\": \\\"赵虎\\\", \\\"sex\\\": 1, \\\"age\\\": 32, \\\"address\\\": \\\"长沙麓谷兴工国际产业园\\\", \\\"remark\\\": \\\"java architect\\\" } \",\"添加文档：\",\"# 创建文档,指定id # 如果id不存在，创建新的文档，否则先删除现有文档，再创建新的文档，版本会增加 PUT /es_db/_doc/1 { \\\"name\\\": \\\"张三\\\", \\\"sex\\\": 1, \\\"age\\\": 25, \\\"address\\\": \\\"广州天河公园\\\", \\\"remark\\\": \\\"java developer\\\" } #创建文档，ES生成id POST /es_db/_doc { \\\"name\\\": \\\"张三\\\", \\\"sex\\\": 1, \\\"age\\\": 25, \\\"address\\\": \\\"广州天河公园\\\", \\\"remark\\\": \\\"java developer\\\" } \",\"POST和PUT都能起到创建/更新的作用，PUT需要对一个具体的资源进行操作，也就是要确定id才能进行更新/创建；POST时可以针对整个资源集合进行操作的，如果不写id就由ES生成一个唯一id进行创建新文档，如果填了id那就针对这个id的文档进行创建/更新。\",\"使用PUT更新文档的时候，整个json都会被替换，也就是说，如果文档存在，现有文档会被删除，新的文档会被索引。\",\"# 全量更新，替换整个json PUT /es_db/_doc/1 { \\\"name\\\": \\\"张三\\\", \\\"sex\\\": 1, \\\"age\\\": 25 } #查询文档 GET /es_db/_doc/1 \",\"如果需要部分更新，可以使用 _update，格式：POST /索引名称/_update/id。_update不会删除原来的文档，而是实现真正的数据更新。\",\"# 部分更新：在原有文档上更新 # Update -文档必须已经存在，更新只会对相应字段做增量修改 POST /es_db/_update/1 { \\\"doc\\\": { \\\"age\\\": 28 } } #查询文档 GET /es_db/_doc/1 \",\"还可以使用_update_by_query更新文档：\",\"POST /es_db/_update_by_query { \\\"query\\\": { \\\"match\\\": { \\\"_id\\\": 1 } }, \\\"script\\\": { \\\"source\\\": \\\"ctx._source.age = 30\\\" } } \",\"_seq_no 和 _primary_term 是对 _version的优化，7.x版本的ES默认使用这种方式控制版本，所以当在高并发环境下使用乐观锁机制修改文档时，要带上文档的 _seq_no 和 _primary_term 进行更新：\",\"POST /es_db/_doc/2?if_seq_no=21&if_primary_term=6 { \\\"name\\\": \\\"李四xxx\\\" } \",\"如果版本号不对，就会抛出版本冲突异常，如下图：\",\"查询文档有两种方式。\",\"根据id查询文档，格式：GET /索引名称/_doc/id\",\"GET /es_db/_doc/1 \",\"条件查询_search，格式：GET /索引名称/_doc/_search\",\"# 查询前10条文档 GET /es_db/_doc/_search \",\"ES Search API提供了两种查询条件查询搜索方式：\",\"REST风格的请求URI，直接将参数带过去\",\"封装到request body中，这种方式可以定义更加易读的JSON格式\",\"#通过URI搜索，使用“q”指定查询字符串，“query string syntax” KV键值对 #条件查询, 如要查询age等于28岁的 _search?q=*:*** GET /es_db/_doc/_search?q=age:28 #范围查询, 如要查询age在25至26岁之间的 _search?q=***[** TO **] 注意: TO 必须为大写 GET /es_db/_doc/_search?q=age[25 TO 26] #查询年龄小于等于28岁的 :<= GET /es_db/_doc/_search?q=age:<=28 #查询年龄大于28前的 :> GET /es_db/_doc/_search?q=age:>28 #分页查询 from=*&size=* GET /es_db/_doc/_search?q=age[25 TO 26]&from=0&size=1 #对查询结果只输出某些字段 _source=字段,字段 GET /es_db/_doc/_search?_source=name,age #对查询结果排序 sort=字段:desc/asc GET /es_db/_doc/_search?sort=age:desc \",\"通过请求体搜索的示例：\",\"GET /es_db/_search { \\\"query\\\": { \\\"match\\\": { \\\"address\\\": \\\"广州白云\\\" } } } \",\"删除文档的格式：DELETE /索引名称/_doc/id。\",\"DELETE /es_db/_doc/1 \"]},\"307\":{\"h\":\"ES文档批量操作\",\"t\":[\"批量操作可以减少网络连接所产生的开销，提升性能。\",\"支持在一次API调用中，对不同的索引进行操作\",\"可以在URI中指定index，也可以在请求的Payload中进行\",\"操作中单条操作失败，并不会影响其他操作\",\"返回结果中包含了每一条操作执行的结果\",\"批量对文档进行写操作是通过 _bulk 的API来实现的。\",\"请求方式：POST\",\"请求地址：_bulk\",\"请求参数：通过 _bulk 操作文档，一般至少有两行参数（或偶数行参数） \",\"第一行参数为执行操作的类型及操作的对象（index，type和id）\",\"第二行参数才是操作的数据\",\"参数类似于：\",\"{\\\"actionName\\\":{\\\"_index\\\":\\\"indexName\\\", \\\"_type\\\":\\\"typeName\\\",\\\"_id\\\":\\\"id\\\"}} {\\\"field1\\\":\\\"value1\\\", \\\"field2\\\":\\\"value2\\\"} \",\"actionName表示操作类型，主要有create，index，delete和update。\",\"POST _bulk {\\\"create\\\":{\\\"_index\\\":\\\"article\\\",\\\"_type\\\":\\\"_doc\\\",\\\"_id\\\":3}} {\\\"id\\\":3,\\\"title\\\":\\\"fox老师\\\",\\\"content\\\":\\\"fox老师666\\\",\\\"tags\\\":[\\\"java\\\",\\\"面向对象\\\"],\\\"create_time\\\":1554015482530} {\\\"create\\\":{\\\"_index\\\":\\\"article\\\",\\\"_type\\\":\\\"_doc\\\",\\\"_id\\\":4}} {\\\"id\\\":4,\\\"title\\\":\\\"mark老师\\\",\\\"content\\\":\\\"mark老师NB\\\",\\\"tags\\\":[\\\"java\\\",\\\"面向对象\\\"],\\\"create_time\\\":1554015482530} \",\"如果原文档不存在，则会创建新文档，如果原文档存在，则是替换（全量修改原文档）。\",\"批量删除delete：\",\"POST _bulk {\\\"delete\\\":{\\\"_index\\\":\\\"article\\\", \\\"_type\\\":\\\"_doc\\\", \\\"_id\\\":3}} {\\\"delete\\\":{\\\"_index\\\":\\\"article\\\", \\\"_type\\\":\\\"_doc\\\", \\\"_id\\\":4}} \",\"批量修改update：\",\"POST _bulk {\\\"update\\\":{\\\"_index\\\":\\\"article\\\",\\\"_type\\\":\\\"_doc\\\",\\\"_id\\\":3}} {\\\"doc\\\":{\\\"title\\\":\\\"ES大法必修内功\\\"}} {\\\"update\\\":{\\\"_index\\\":\\\"article\\\",\\\"_type\\\":\\\"_doc\\\",\\\"_id\\\":4}} {\\\"doc\\\":{\\\"create_time\\\":1554018421008}} \",\"组合应用：\",\"POST _bulk {\\\"create\\\":{\\\"_index\\\":\\\"article\\\",\\\"_type\\\":\\\"_doc\\\",\\\"_id\\\":3}} {\\\"id\\\":3,\\\"title\\\":\\\"fox老师\\\",\\\"content\\\":\\\"fox老师666\\\",\\\"tags\\\":[\\\"java\\\",\\\"面向对象\\\"],\\\"create_time\\\":1554015482530} {\\\"delete\\\":{\\\"_index\\\":\\\"article\\\",\\\"_type\\\":\\\"_doc\\\",\\\"_id\\\":3}} {\\\"update\\\":{\\\"_index\\\":\\\"article\\\",\\\"_type\\\":\\\"_doc\\\",\\\"_id\\\":4}} {\\\"doc\\\":{\\\"create_time\\\":1554018421008}} \",\"ES的批量查询可以用mget和msearch两种，其中mget是需要我们知道它的id，可以指定不同的index，也可以指定返回值source。msearch可以通过字段查询来进行一个批量的查找。\",\"_mget 的使用方式如下：\",\"#可以通过ID批量获取不同index和type的数据 GET _mget { \\\"docs\\\": [ { \\\"_index\\\": \\\"es_db\\\", \\\"_id\\\": 1 }, { \\\"_index\\\": \\\"article\\\", \\\"_id\\\": 4 } ] } #可以通过ID批量获取es_db的数据 GET /es_db/_mget { \\\"docs\\\": [ { \\\"_id\\\": 1 }, { \\\"_id\\\": 4 } ] } #简化后 GET /es_db/_mget { \\\"ids\\\": [ \\\"1\\\", \\\"2\\\" ] } \",\"_msearch 的使用方式如下：\",\"在 _msearch 中，请求格式和bulk类似。查询一条数据需要两个对象，第一个设置index和type，第二个设置查询语句。查询语句和search相同。如果只是查询一个index，我们可以在url中带上index，这样，如果查该index可以直接用空对象表示。\",\"GET /es_db/_msearch {} {\\\"query\\\":{\\\"match_all\\\":{}},\\\"from\\\":0,\\\"size\\\":2} {\\\"index\\\":\\\"article\\\"} {\\\"query\\\":{\\\"match_all\\\":{}}} \"]},\"308\":{\"h\":\"ElaticSearch高级查询语法Query DSL\",\"t\":[\"参考链接：https://note.youdao.com/ynoteshare/index.html?id=924a9d435d78784455143b1dda4a874a&type=note&_time=1684249060388\",\"当数据写入ES时，数据将会通过分词被切分为不同的trem，ES将term与其对应的文档列表建立一种映射关系，这种结构就是倒排索引。如下图所示：\",\"为了进一步提升索引的效率，ES在term的基础上利用term的前缀或者后缀构建了term index，用于对term本身进行索引，ES实际的索引结构如下图所示：\",\"这样当我们去搜索某个关键词时，ES首先根据它的前缀或者后缀迅速缩小关键词在term dictionary中的范围，大大减少了磁盘IO的次数。\",\"单词词典（Term Dictionary）：记录所有文档的单词，记录单词到倒排所列的关联关系。\",\"倒排列表（Posting List）：记录了单词对应的文档结合，由倒排索引项组成\",\"倒排索引项（Posting）： \",\"文档ID\",\"词频TF-该单词在文档中出现的次数，用于相关性评分\",\"位置（Position）-单词在文档中的分析的位置，用于短语搜索（match phrase query）\",\"偏移（Offset）-记录单词的开始结束位置，实现高亮线显示\",\"ES的JSON文档中的每个字段，都有自己的倒排索引，可以指定对某些字段不做索引：\",\"优点：节省内存空间\",\"缺点：字段无法被搜索\"]},\"309\":{\"h\":\"文档映射mapping\",\"t\":[\"Mapping类似数据库中的schema的定义，作用如下：\",\"定义索引中的字段的名称\",\"定义字段的数据类型，例如字符串，数字，布尔等\",\"字段，倒排索引的相关配置（Analyzer）\",\"ES中Mapping映射可以分为动态映射和静态映射。\",\"在关系型数据库中，需要先创建数据库，然后在该数据库下创建数据表，并创建表字段、类型、长度、主键等，最后才能基于表插入数据。而ES中不需要预先定义Mapping映射（即关系型数据库的表、字段等），在文档写入ES时，会根据文档的字段自动识别类型，这种机制称之为动态映射。\",\"与之对应的，在ES中预先定义好映射，包含文档的各字段类型、分词器等，这种方式称之为静态映射。\",\"动态映射的机制，使得我们无需手动定义Mappings，ES会自动根据文档信息，推算出字段的类型，但是由的时候会推算的不对，例如地理位置信息。当类型如果设置的不对时，会导致一些功能无法正常运行，例如Range查询。\",\"Dynamic Mapping类型自动识别：\",\"示例：\",\"#删除原索引 DELETE /user #创建文档(ES根据数据类型, 会自动创建映射) PUT /user/_doc/1 { \\\"name\\\":\\\"fox\\\", \\\"age\\\":32, \\\"address\\\":\\\"长沙麓谷\\\" } #获取文档映射 GET /user/_mapping \",\"执行结果：\",\"对于已经创建的文档，如果要更改Mapping的字段类型，有两种情况：\",\"新增加的字段 \",\"dynamic设为true时，一旦有新增的文档写入，Mapping也同时被更新\",\"dynamic设为false，Mapping不会被更新，新增字段的数据无法被索引，但是信息会出现在 _source 中\",\"dynamic设置为strict（严格控制策略），文档写入失败，抛出异常\",\"对于已有字段，一旦已经有数据写入，就不再支持修改字段定义 \",\"Lucene实现的倒排索引，一旦生成后，就不允许修改\",\"如果希望改变字段类型，可以利用reindex API，重建索引\",\"这样设计的原因是：\",\"如果修改了字段的数据类型，会导致已经被索引的数据无法被搜索\",\"但是如果是增加新的字段，就不会有这样的影响\",\"测试用例：\",\"PUT /user { \\\"mappings\\\": { \\\"dynamic\\\": \\\"strict\\\", \\\"properties\\\": { \\\"name\\\": { \\\"type\\\": \\\"text\\\" }, \\\"address\\\": { \\\"type\\\": \\\"object\\\", \\\"dynamic\\\": \\\"true\\\" } } } } # 插入文档报错，原因为age为新增字段,会抛出异常 PUT /user/_doc/1 { \\\"name\\\":\\\"fox\\\", \\\"age\\\":32, \\\"address\\\":{ \\\"province\\\":\\\"湖南\\\", \\\"city\\\":\\\"长沙\\\" } } \",\"dynamic设置成strict，新增age字段导致文档插入失败：\",\"修改dynamic后再次插入文档成功\",\"#修改daynamic PUT /user/_mapping { \\\"dynamic\\\":true } \"]},\"310\":{\"h\":\"ElaticSearch搜索技术与聚合查询\"},\"311\":{\"h\":\"ElaticSearch高阶功能\"},\"312\":{\"h\":\"ElaticSearch集群架构实战及其原理\",\"t\":[\"链接：https://note.youdao.com/ynoteshare/index.html?id=16ca3fcfcdda46a976cfd978e20df4be&type=note&_time=1684856471454\",\"为什么说ElaticSearch是一个近实时的搜索引擎？\"]},\"313\":{\"h\":\"Logstash与FileBeat详解以及EFK整合\"},\"314\":{\"h\":\"MongoDb\"},\"315\":{\"h\":\"MongoDb入门\"},\"316\":{\"h\":\"MySQL基础\"},\"317\":{\"h\":\"MySQL逻辑架构\",\"t\":[\"让我们从最简单的情形开始，假设有一张这样的表T，表里只有一个ID字段，在执行下面这个查询语句时：\",\"select * from T where ID=10; \",\"我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程，要想更深入的了解，就需要了解MySQL的逻辑架构：\",\"大体来说，MySQL可以分为Server层和存储引擎两部分。\",\"Server层包括连接器、查询缓存、分析器、优化器、执行器，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。\",\"而存储引擎层负责数据的存储和提取，其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎，现在最常用的存储引擎是InnoDB，它从MySQL5.5.5版本开始称为了默认的存储引擎。\",\"这也就是说，在执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不过，在使用create table语句中使用engine=memory来指定存储引擎的类型来创建表，不同的存储引擎的表数据获取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。\",\"从图中不难看出，不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分。接下来我们会从上文提到的SQL语句，梳理它执行的完整的流程，了解每个组件的作用。\"]},\"318\":{\"h\":\"连接器\",\"t\":[\"执行SQL语句的第一步，总是会使用连接器连接到这个数据库上。连接器负责跟客户端建立连接、获取权限、维持和管理连接，连接命令通常如下：\",\"mysql -h$ip -P$port -u$user -p \",\"输完命令之后，就需要交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致你的密码泄露。如果你连接的是生产服务器，强烈建议你不要这么做。\",\"连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。\",\"如果用户名或密码不对，你就会收到一个“Access denied for user”的错误，然后客户端程序结束执行\",\"如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限，之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限\",\"这就意味着，一个用户成功建立连接后，即使你使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。\",\"连接完成之后，如果你没有后续的动作，这个连接就处于空闲状态，可以使用show processlist命令中看到它，其中Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。\",\"客户端如果太长时间没有动静，连接器就会自动将他断开，这个时间是由参数wait_timeout控制的，默认值是8小时。\",\"如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提示：Lost connection to MySQL Server during queery。这时候如果你要继续，就需要重连，然后再执行请求了。\",\"连接可以分为两种：长连接和短连接。长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。\",\"建立连接的过程通常是比较复杂的，所以在使用的过程中要尽量减少建立连接的动作，也就是尽量使用长连接。但是全部使用长连接后，你可能会发现，有些使用MySQL占用内存涨的特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。\",\"解决这个问题通常有两种方案：\",\"定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连\",\"如果使用的MySQL5.7或更新的版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完成时的状态\"]},\"319\":{\"h\":\"查询缓存\",\"t\":[\"连接建立完成后，就可以正式开始执行select语句了，执行逻辑就会来到第二步：查询缓存。\",\"MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句，之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存到内存中。key是查询的语句，value是查询的结果，如果查询能够直接这个缓存中找到key，那么这个value就会被直接返回给客户端。\",\"如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中，可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，效率就会很高。\",\"但是大多数情况下不要使用查询缓存，查询缓存的失效非常频繁，只要有对一个表的更新，这个表上的查询缓存都会被清空。因此很有可能费劲的把结果存起来，还没有使用，但是就被更新操作清空掉了，对于更新压力大的数据库来说，查询缓存的命中率会非常低，除非业务就是有一张静态表，很长时间才会更新依次，比如，一个系统的配置表，那这张表上的查询才适合使用查询缓存。\",\"MySQL提供了参数配置，可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存，而对于确定要使用查询缓存的语句，可以使用SQL_CACHE显式指定：\",\" select SQL_CACHE * from T where ID=10 ； \",\"MySQL8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始就彻底没有这个功能了。\"]},\"320\":{\"h\":\"分析器\",\"t\":[\"如果没有命中查询缓存，就要真正开始执行语句了。MySQL会使用分析器对SQL语句做解析，识别出SQL语句中的字符串分别是什么，代表什么。在之前的例子中，MySQL会从输入的“select”关键字识别出来，这是一个查询语句，它也要把字符串“T”识别成表名“T”，把字符串“ID”识别成“列ID”，做完了这些识别以后，就要做“语法分析”，根据词法分析的结果，语法分析器会根据语法规则，判断输入的SQL语句是否满足MySQL语法。\",\"如果语句不对，就会收到“You have an error in your SQL syntax”的错误提醒。\"]},\"321\":{\"h\":\"优化器\",\"t\":[\"经过了分析器，MySQL就知道你想要做什么了，在开始执行之前，还需要经过优化器的处理。\",\"优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序，比如执行下面的语句：\",\"select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; \",\"既可以先从表里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20\",\"也可以先从表t2里面取出d=20的记录的值，再根据ID值关联到t1，再判断t1里面c的值是否等于10\",\"这两种执行方法的逻辑结果是一样的，但是执行的效率会有所不同，而优化器的作用就是决定选择使用哪一种方案。优化器的阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。\"]},\"322\":{\"h\":\"执行器\",\"t\":[\"MySQL通过分析器知道了要做什么。通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。开始执行的时候，要先判断有没有对应的查询权限，如果没有，就会返回没有权限的错误，如下所示：\",\"mysql> select * from T where ID=10; ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T' \",\"如果有权限，就打开表继续执行，打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口，比如上述例子中表T中，ID字段没有索引，那么执行器的执行流程如下：\",\"调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中\",\"调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行\",\"执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端\",\"至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。\",\"数据库的慢查询日志中，字段rows_examined表示这个语句执行过程中扫描了多少行，这个值就是在执行器每次调用引擎获取数据行的时候累加的。不过在有些场景下，执行器调用一次，在引擎内部扫描了多行，因此引擎扫描行数跟rows_examined并不是完全相同的。\"]},\"323\":{\"h\":\"SQL执行流程\",\"t\":[\"MySQL可以借助重做日志和归档日志恢复到半个月内任意一秒的状态。为了了解它的实现原理，我们从一个表的一条更新语句开始：\",\"create table T(ID int primary key, c int); \",\"如果要将ID=2这一行的值加1，SQL如下：\",\"update T set c=c+1 where ID=2; \",\"同样的更新语句也会按照SQL语句的基本执行链路执行：\",\"与查询流程不一样的是，更新流程还设计两个重要的的日志模块：redo log（重做日志）和binlog（归档日志），这是MySQL中两个核心概念。\"]},\"324\":{\"h\":\"重做日志\",\"t\":[\"如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL会使用WAL技术（Write-Ahead Logging），先写日志，再写磁盘。\",\"具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录到磁盘里面，而这个更新往往是在系统比较空闲的时候做。InnoDB的redo log是固定大小的，比如可以配置一组4个文件，每个文件的大小是1GB，那么总共就可以记录4GB的操作。从头开始写入，到末尾又回到开头循环写入，如下图所示：\",\"其中write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头，checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。write pos和checkpoint之间还空着的部分，就可以用来记录新的操作，如果write pos追上了checkpoint，那么就表示不能再执行新的更新操作了，就得先停下来擦掉一些记录，然后将checkpoint向后移动。\",\"有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。\"]},\"325\":{\"h\":\"归档日志\",\"t\":[\"MySQL从整体上来看，大致可以分为两部分，一块是Server层，它主要负责MySQL功能层面的事情，另一块是引擎层，负责存储相关的具体事宜。上文提到的redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为bin log（归档日志）。由于最开始的MySQL并没有InnoDB引擎，MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。\",\"redo log和binlog有以下区别：\",\"redo log是InnoDB引擎所特有的，binlog是MySQL的Server层实现的，所有引擎都可以使用\",\"redo log是物理日志，记录的是“在某个数据页上做了什么修改”，binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1”\",\"redo log是循环写的，空间固定会用完，binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到写一个，并不会覆盖以前的日志\"]},\"326\":{\"h\":\"更新语句执行流程\",\"t\":[\"了解这两个日志的作用，我们再来看执行器和InnoDB引擎在执行这个update语句时的内部流程。\",\"执行器先找引擎取ID=2这一行，ID是逐渐，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回\",\"执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据\",\"引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态，然后告知执行器执行完成了，随时可以提交事务\",\"执行器生成这个操作的binlog，并把binlog写入磁盘\",\"执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成\",\"update语句的执行如下图：\",\"注意这里并不是直接写入redo log，而是将redo log的写入拆成了两个步骤：prepare和commit，这就是“两阶段提交”。\"]},\"327\":{\"h\":\"两阶段提交\",\"t\":[\"两阶段提交为了让两份日志之间的逻辑一致，要说明这个问题，我们得从文章开头的那个问题说起：怎样让数据库恢复到半个月内任意一秒的状态？\",\"上文提到过，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式，当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那么可以：\",\"首先，找到最近的一次全量备份，如果运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库\",\"然后，从备份的时候点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻\",\"这样临时库就跟误删之前的线上库一样了，然后就可以把表数据从临时库取出来，按需要恢复到线上库去。\",\"接下来我们说明为什么需要两阶段提交，由于redo log和binlog时两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序，我们来看看这两种方式会有什么问题：\",\"先写redo log后写binlog。假设在redo log写完，binlog还没有写完的时候，MySQL异常重启，上文提到过，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复这一行c的值是1，但是由于binlog没写完就crash了，这个时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句，这个时候，如果需要用binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同\",\"先写binlog后写redo log，如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志，所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行的c的值就是1，与原库的值不同\",\"可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致，不过你可能会问，碰到需要用日志恢复数据的场景是不是很少，其实，并不只是误操作以后需要用这个过程来恢复数据，当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就不会导致线上出现主从数据库不一致的情况。\",\"简单来说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。\"]},\"328\":{\"h\":\"MySQL性能分析工具\"},\"329\":{\"h\":\"explain 简介\",\"t\":[\"EXPLAIN是什么？\",\"EXPLAIN：SQL的执行计划，使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句的。\",\"EXPLAIN怎么使用？\",\"语法：explain + SQL。\",\"mysql> explain select * from pms_category \\\\G; *************************** 1. row *************************** id: 1 select_type: SIMPLE table: pms_category partitions: NULL type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 1425 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec) \",\"EXPLAIN能干嘛？\",\"可以查看以下信息：\",\"id：表的读取顺序。\",\"select_type：数据读取操作的操作类型。\",\"possible_keys：哪些索引可以使用。\",\"key：哪些索引被实际使用。\",\"ref：表之间的引用。\",\"rows：每张表有多少行被优化器查询。\"]},\"330\":{\"h\":\"explain 字段\",\"t\":[\"id\",\"id：表的读取和加载顺序。\",\"值有以下三种情况：\",\"id相同，执行顺序由上至下。\",\"id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。\",\"id相同不同，同时存在。永远是id大的优先级最高，id相等的时候顺序执行。\",\"select_type\",\"select_type：数据查询的类型，主要是用于区别，普通查询、联合查询、子查询等的复杂查询。\",\"SIMPLE：简单的SELECT查询，查询中不包含子查询或者UNION 。\",\"PRIMARY：查询中如果包含任何复杂的子部分，最外层查询则被标记为PRIMARY。\",\"SUBQUERY：在SELECT或者WHERE子句中包含了子查询。\",\"DERIVED：在FROM子句中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询，把结果放在临时表中。\",\"UNION：如果第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为DERIVED。\",\"UNION RESULT：从UNION表获取结果的SELECT。\",\"type\",\"type：访问类型排列。\",\"从最好到最差依次是：system>const>eq_ref>ref>range>index>ALL。除了ALL没有用到索引，其他级别都用到索引了。\",\"一般来说，得保证查询至少达到range级别，最好达到ref。\",\"system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计。\",\"const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转化为一个常量。\",\"eq_ref：唯一性索引扫描，读取本表中和关联表表中的每行组合成的一行，查出来只有一条记录。除 了 system 和 const 类型之外, 这是最好的联接类型。\",\"ref：非唯一性索引扫描，返回本表和关联表某个值匹配的所有行，查出来有多条记录。\",\"range：只检索给定范围的行，一般就是在WHERE语句中出现了BETWEEN、< >、in等的查询。这种范围扫描索引比全表扫描要好，因为它只需要开始于索引树的某一点，而结束于另一点，不用扫描全部索引。\",\"index：Full Index Scan，全索引扫描，index和ALL的区别为index类型只遍历索引树。也就是说虽然ALL和index都是读全表，但是index是从索引中读的，ALL是从磁盘中读取的。\",\"ALL：Full Table Scan，没有用到索引，全表扫描。\",\"possible_keys 和 key\",\"possible_keys：显示可能应用在这张表中的索引，一个或者多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。\",\"key：实际使用的索引。如果为NULL，则没有使用索引。查询中如果使用了覆盖索引，则该索引仅仅出现在key列表中。\",\"key_len\",\"key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。在不损失精度的情况下，长度越短越好。\",\"key_len计算规则：https://blog.csdn.net/qq_34930488/article/details/102931490\",\"mysql> desc pms_category; +---------------+------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +---------------+------------+------+-----+---------+----------------+ | cat_id | bigint(20) | NO | PRI | NULL | auto_increment | | name | char(50) | YES | | NULL | | | parent_cid | bigint(20) | YES | | NULL | | | cat_level | int(11) | YES | | NULL | | | show_status | tinyint(4) | YES | | NULL | | | sort | int(11) | YES | | NULL | | | icon | char(255) | YES | | NULL | | | product_unit | char(50) | YES | | NULL | | | product_count | int(11) | YES | | NULL | | +---------------+------------+------+-----+---------+----------------+ 9 rows in set (0.00 sec) mysql> explain select cat_id from pms_category where cat_id between 10 and 20 \\\\G; *************************** 1. row *************************** id: 1 select_type: SIMPLE table: pms_category partitions: NULL type: range possible_keys: PRIMARY key: PRIMARY # 用到了主键索引，通过查看表结构知道，cat_id是bigint类型，占用8个字节 key_len: 8 # 这里只用到了cat_id主键索引，所以长度就是8！ ref: NULL rows: 11 filtered: 100.00 Extra: Using where; Using index 1 row in set, 1 warning (0.00 sec) \",\"ref\",\"ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。\",\"rows\",\"rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录需要读取的行数。\",\"Extra\",\"Extra：包含不适合在其他列中显示但十分重要的额外信息。\",\"Using filesort：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作成为\\\"文件内排序\\\"。\",\"# 排序没有使用索引 mysql> explain select name from pms_category where name='Tangs' order by cat_level \\\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: pms_category partitions: NULL type: ref possible_keys: idx_name_parentCid_catLevel key: idx_name_parentCid_catLevel key_len: 201 ref: const rows: 1 filtered: 100.00 Extra: Using where; Using index; Using filesort 1 row in set, 1 warning (0.00 sec) #~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ # 排序使用到了索引 mysql> explain select name from pms_category where name='Tangs' order by parent_cid,cat_level\\\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: pms_category partitions: NULL type: ref possible_keys: idx_name_parentCid_catLevel key: idx_name_parentCid_catLevel key_len: 201 ref: const rows: 1 filtered: 100.00 Extra: Using where; Using index 1 row in set, 1 warning (0.00 sec) \",\"Using temporary：使用了临时表保存中间结果，MySQL在対查询结果排序时使用了临时表。常见于排序order by和分组查询group by。临时表対系统性能损耗很大。\",\"Using index：表示相应的SELECT操作中使用了覆盖索引，避免访问了表的数据行，效率不错！如果同时出现Using where，表示索引被用来执行索引键值的查找；如果没有同时出现Using where，表明索引用来读取数据而非执行查找动作。\",\"# 覆盖索引 # 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。 # 注意：如果要使用覆盖索引，一定不能写SELECT *，要写出具体的字段。 mysql> explain select cat_id from pms_category \\\\G; *************************** 1. row *************************** id: 1 select_type: SIMPLE table: pms_category partitions: NULL type: index possible_keys: NULL key: PRIMARY key_len: 8 ref: NULL rows: 1425 filtered: 100.00 Extra: Using index # select的数据列只用从索引中就能够取得，不必从数据表中读取 1 row in set, 1 warning (0.00 sec) \",\"Using where：表明使用了WHERE过滤。\",\"Using join buffer：使用了连接缓存。\",\"impossible where：WHERE子句的值总是false，不能用来获取任何元组。\",\"mysql> explain select name from pms_category where name = 'zs' and name = 'ls'\\\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: NULL partitions: NULL type: NULL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: NULL filtered: NULL Extra: Impossible WHERE # 不可能字段同时查到两个名字 1 row in set, 1 warning (0.00 sec) \"]},\"331\":{\"h\":\"索引常见模型\",\"t\":[\"除了数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。简单来说，索引是排好序的快速查找数据结构。\",\"索引的出现是为了提高查询效率，但是实现索引的方式却有很多中，可以用于提高读写效率的数据结构有很多中，这里我们这里讨论三种常见的数据结构：哈希表、有序数组、搜索树。\"]},\"332\":{\"h\":\"哈希表\",\"t\":[\"哈希表是一种以键-值（key-value）存储数据的结构，我们只需要输入待查找的值即key，就可以找到其对应的值即value。使用哈希算法不可避免的就会遇到哈希冲突，链地址法是解决哈希冲突比较常见的做法。\",\"假设现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：\",\"图中，User2和User4根据身份证号算出来的值都是N，但是没有关系，后面还有一个链表。假设这个时候要查ID_card_n2对应的名字是什么，首先将ID_card_n2通过哈希函数算出N，然后，按顺序遍历，找到User2。\",\"需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加，但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的，如果要查找身份证号在[ID_card_X,ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。因此，哈希表这种结构适用于只有等值查询的场景，比如Memcached及其他一些NoSQL引擎。\"]},\"333\":{\"h\":\"有序数组\",\"t\":[\"有序数组在等值查询和范围查询场景中的性能就都非常优秀。还是上面根据身份证号查询名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：\",\"这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果要查询ID_card_n2对应的名字，用二分法就可以快速得到，时间复杂度为O（logN）。同理，如果要查询区间的时间复杂度也是O（logN）。\",\"如果仅仅看查询效率，有序数组就是最好的数据结构了，但是，在需要更新数据的时候就麻烦了。往中间插入一条记录就必须得往后挪动所有的记录，成本非常高。因此，有序数组索引只适用于静态存储引擎，比如要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。\"]},\"334\":{\"h\":\"二叉搜索树\",\"t\":[\"如果我们用二叉搜索树来实现上述的例子：\",\"二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果要查询ID_card_n2的话，按照途中搜索的顺序就是按照UserA -> UserC -> UserF -> User2这个路径得到，这个时间复杂度是O（logN）。\",\"不过为了维持O（logN）的查询复杂度，更新的时间复杂度也是O（logN）。\",\"树可以有二叉，也可以有多叉，多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止在内存中，还要写到磁盘上。\",\"为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少地数据块。那么，我们就不应该使用二叉树，而是要使用“N叉树”，这里，“N叉”树中地“N”取决于数据块的大小。以InnoDB的一个整数字段为例。这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次从盘。其实，树的第二层也有很大的概率在内存中，那么访问磁盘的平均次数就更少了。\",\"由于N叉树在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。在MySQL中，索引是在存储引擎层的实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而底层的实现也可能不同。\"]},\"335\":{\"h\":\"B+树\",\"t\":[\"在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表，并且InnoDB使用了B+树索引模型，将数据存储在了B+树中，每一个索引在InnoDB中对应一颗B+树。\",\"假设我们有一个主键列为ID的表，表中有字段k，并且在k上有索引，这个表的建表语句是：\",\"CREATE TABLE T ( id int PRIMARY KEY, k int NOT NULL, name varchar(16), INDEX(k) ) ENGINE = InnoDB; \",\"然后向表中插入5条记录，表中R1~R5的（ID，K）的值分别为（100，1）、（200，2）、（300，3）、（500，5）、（600，6），两棵树的示例示意图如下：\",\"从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。主键索引的叶子节点存储的是整行数据，在InnoDB中，主键索引也被称为聚簇索引（clustered index）。非主键索引的叶子节点内容是主键的值，在InnoDB里，非主键索引也被称为二级索引（secondary index）。\",\"基于主键索引和普通索引的查询略有差别：\",\"如果语句是select * from T where ID = 500，即主键查询方式，则只需要搜索ID这颗B+树\",\"如果语句是select * from T where k = 5，即普通索引查询方式，则需要先搜索K索引树，得到ID的值为500，再到ID索引树搜索一次，这个过程称为回表\",\"也就是说，基于非主键索引的查询需要多扫描一棵索引树，因此，我们在应用中应该尽量使用主键查询。\",\"B+树为了维护索引的有序性，在插入新值的时候需要做必要的维护。以上面的图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID的值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然也受收到影响。\",\"除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。\",\"当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并，合并的过程，可以认为是分裂过程的逆过程。\",\"可能你在一些建表规范里面见到过类似的描述，要求建表语句里面一定要有自增主键。当然事无绝对，我们需要分析一下哪些场景应该使用自增主键，而哪些场景下不应该。\",\"自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的：NOT PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值作为下一条记录的ID值，也就是说，自增主键的插入数据的模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不设计到挪动其它记录，也不会触发叶子节点的分裂。而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。\",\"除了考虑性能外，我们还可以从存储空间的角度来看。假设表中确实有一个唯一的字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？\",\"由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以从性能和存储空间方面考量，自增主键往往是更合理的选择。\",\"不过在典型的KV场景，由于没有其它索引，所以就不用考虑其它索引叶子节点大小的问题了，KV场景的特点如下：\",\"只有一个索引\",\"该索引必须是唯一索引\",\"这时候我们就需要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。\"]},\"336\":{\"h\":\"索引的执行流程\",\"t\":[\"创建好索引之后，我们探讨一下索引的执行流程，以下面的表T为例，如果执行select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？\",\"CREATE TABLE T ( ID int PRIMARY KEY, k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT '', INDEX k(k) ) ENGINE = InnoDB; insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg'); \",\"此时表中的索引结构如下图所示：\"]},\"337\":{\"h\":\"回表\",\"t\":[\"此时，上述SQL语句查询的执行流程：\",\"在k索引树上找到k=3的记录，取得ID=300\",\"再到ID索引树查到ID=300对应的R3\",\"在k索引树取下一个值k=5，取得ID=500\",\"在k索引树取下一个值k=6，不满足条件，循环结束\",\"在这个过程中，回到主键索引树搜索的过程，就称为回表，可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）.\",\"在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，该如何避免回表呢？\"]},\"338\":{\"h\":\"覆盖索引\",\"t\":[\"如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询 需求，我们称为覆盖索引。\",\"由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。\",\"需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三条记录，R3~R5（对应的索引k上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2。\",\"基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？假设这个市民表的定义如下：\",\"CREATE TABLE `tuser` ( `id` int(11) NOT NULL, `id_card` varchar(32) DEFAULT NULL, `name` varchar(32) DEFAULT NULL, `age` int(11) DEFAULT NULL, `ismale` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`), KEY `id_card` (`id_card`), KEY `name_age` (`name`, `age`) ) ENGINE = InnoDB \",\"我们知道，身份证号是市民的唯一标识，也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？\",\"如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，那这个联合索引就有意义了。它可以高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。\",\"当然，索引字段的维护总是有代价的，因此，在建立冗余索引来支持索引覆盖时就需要权衡考虑了。\"]},\"339\":{\"h\":\"最左前缀原则\",\"t\":[\"如果要为每一种查询都设计一个索引，会导致索引数量激增，在B+树这种索引结构中，可以利用索引的“最左前缀”来定位记录，为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。\",\"可以看到，索引项是按照索引定义里面出现的字段顺序排序的。当需要查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。\",\"如果要查的是所有名字第一个字的是“张”的人，你的SQL语句的条件是“where name like 张%”。这时也可以用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。\",\"可以看到，不止是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。因此，在建立联合索引的时候，通常我们就会根据索引的复用能力来确定索引内的字段顺序，如果可以通过调整联合索引的顺序，就可以少维护一个索引，那么就要优先考虑建立这样顺序的索引。\",\"那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用（a，b）这个联合索引的，这个时候不得不维护另一个索引，也就是说必须同时维护（a，b）、（b）这两个索引。这种情况下，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name字段是比age字段大的，那么建议创建一个（name，age）的联合索引和一个（age）的单字段索引。\"]},\"340\":{\"h\":\"索引下推\",\"t\":[\"上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录，那么不符合最左前缀的部分，会怎么样呢？\",\"我们还是以市民表中的联合索引（name，age）为例。假设现在的需求是检索出表中“名字第一个字是张，而且年龄是10岁所有男孩”，那么，SQL语句是这么写的：\",\"select * from tuser where name like '张%' and age=10 and ismale=1; \",\"这个语句在搜索索引树的时候，只能用“张”，找到第一个满足条件的记录ID3，然后判断其它条件是否满足。在MySQL 5.6之前，只能从ID3开始一个个回表，到主键索引上找出数据行，再对比字段值，而在MySQL 5.6之后引入的索引下推优化（index condition pushdown），可以在索引遍历的过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，下面是这两个过程的执行流程图：\",\"在这两个图里面，每一个虚线箭头表示回表一次，在第一张图中，InnoDB并不会去看age的值，只是按顺序把“name”第一个字是“张”的记录一条条取出来回表，因此，需要回表4次。下一张图中，InnoDB在（name，age）索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在我们这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。\"]},\"341\":{\"h\":\"普通索引和唯一索引\",\"t\":[\"现在假设我们在维护一个市民系统，每个人都有一个唯一的身份证号，而且通过业务代码保证不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语句：\",\"select name from CUser where id_card = 'xxxxxxxyyyyyyzzzzz'; \",\"如果要在id_card字段上创建索引，由于身份证号字段比较大，作为主键并不合适，那么可以给id_card字段创建唯一索引，也可以创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的，但在性能上有所差别。\",\"接下来，我们就从这两种索引对查询语句和更新语句的性能来进行分析。\"]},\"342\":{\"h\":\"查询过程\",\"t\":[\"假设执行的查询语句是select id from T where k = 5，这个查询语句在索引树上的查找的过程，先是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。\",\"对于普通索引来说，查找到满足条件的第一个记录（5，500）后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录\",\"对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索\",\"InnoDB的数据是按数据页为到位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。由于引擎是按页读写的，所以说，当找到k=5的时候，它所在的数据页就都在内存里了，那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。\",\"当然，如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些，不过，对于整型字段，一个数据页就可以放近千个key，因此出现这种情况的概率会很低，所以在计算平均性能差异的时候，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。\",\"总而言之，对于查询的场景来说，唯一索引和普通索引并没有性能上的差距。\"]},\"343\":{\"h\":\"更新过程\",\"t\":[\"为了说明普通索引和唯一索引对更新语句性能的影响，需要首先了解change buffer。\",\"当需要更新一个数据页的时候，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。\",\"需要说明的是，虽然名字叫做change buffer，实际上它是可以持久化的数据，也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程也会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。\",\"显然，如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能避免占用内存，提高内存利用率。\",\"那么，什么情况下会使用到change buffer呢？\",\"对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入（4，400）这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。\",\"因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。\",\"change buffer用的是buffer pool里的内存，因此不能无线增大。change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。\",\"理解了change buffer的机制，我们再来看看如果要在这张表中插入一个新记录（4，400）的话，InnoDB的处理流程。\",\"第一种情况是，这个记录要更新的目标在内存中，这时，InnoDB的处理流程如下：\",\"对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束\",\"对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了\",\"将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。\"]},\"344\":{\"h\":\"change buffer详解\",\"t\":[\"上文我们说过，change buffer只限于用在普通索引的场景下，而是不适用于唯一索引，那么普通索引的所有场景，使用change buffer都可以起到加速的作用吗？\",\"由于merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer的记录变更越多（也就是这个页面上要更新的次数越多），收益就越大。因此对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。\",\"此时我们再来分析普通索引和唯一索引选择的问题。这两类索引在查询能力上没有差别，主要是对更新性能的影响，因此，尽量选择普通索引。如果所有的更新后面，都马上伴随着对这个记录的查询，那么应该关闭change buffer，而在其它情况下change buffer都能提升更新性能。\"]},\"345\":{\"h\":\"change buffer和redo log\",\"t\":[\"change buffer和redo log是两个比较容易混淆的概念，接下来我们通过实例来说明它们之间的区别，先插入两条数据：\",\"INSERT INTO t (id, k) VALUES (id1, k1), (id2, k2); \",\"这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存（InnoDB buffer pool）中，k2所在的数据页不在内存中。下图所示是带change buffer的更新状态图：\",\"这条更新语句，共涉及了四个部分：内存、redo log（ib_log_fileX）、数据表空间（t.ibd）、系统表空间（ibdata1）。\",\"这条更新语句做了如下操作：\",\"Page1在内存中，直接更新内存\",\"Page2没有在内存中，就在内存中change buffer区域，记录下“我要往Page插入一行”这个信息\",\"将上述两个动作记入redo log（图中3和4）\",\"做完上面这些，事务就可以完成了，不难看出，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的，同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。\",\"完成上述操作之后，假设要执行select * from t where k in(k1, k2)，执行的流程图如下：\",\"从图中可以看到：\",\"读Page1的时候，直接从内存返回\",\"要读Page2的时候，需要把Page2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果\",\"可以看到，直到需要读Page2的时候，这个数据页才会被读入内存，所以要简单地对比这两个机制在提升性能上地收益的话，redo log主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。\"]},\"346\":{\"h\":\"索引的选择\",\"t\":[\"MySQL中一张表可以支持多个索引，并且使用哪个索引是由MySQL来确定的，不过在某些场景下，MySQL可能会选错索引，从而导致执行速度变得很慢。\",\"首先先建一张表，表里有a、b两个字段，并分别建立索引：\",\"CREATE TABLE `t` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `b` (`b`) ) ENGINE = InnoDB ； \",\"然后执行如下SQL语句：\",\"select * from t where a between 10000 and 20000; \",\"通过explain命令可以这条语句执行的情况：\",\"我们在字段‘a’上建立了普通索引，从分析的结果来看，优化器也选择了索引a，但实际上并没有这么简单，假设这张表上包含了10万行的数据，然后做如下操作：\",\"session A开启一个事务，然后，seesion B把数据都删除后，又调用idata这个存储过程，插入了10万行数据。这时候，session B的查询语句select * from where a between 10000 and 20000就不会再选择索引a了。我们可以通过慢查询日志（show log）来查看以下具体的执行情况。为了说明优化器选择的结果是否正确，这里使用了force index(a)来让优化器强制使用索引a。\",\"set long_query_time=0; select * from t where a between 10000 and 20000; /*Q1*/ select * from t force index(a) where a between 10000 and 20000;/*Q2*/ \",\"第一句是将查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日志中\",\"第二句，Q1是session B原来的查询\",\"第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比\",\"这三条SQL语句执行完成后的慢查询日志如下：\",\"可以看到，Q1扫描了10万行，显然是走了全表扫描，执行时间是40毫秒。Q2扫描了10001行，执行了21毫秒。也就是说，我们在没有使用force index的时候，MySQL用错了索引，导致了更长的执行时间，要理解这个现象，就必须了解优化器选择索引的策略。\"]},\"347\":{\"h\":\"优化器逻辑\",\"t\":[\"优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越小，消耗的CPU资源越少。除此之外，优化器还会结合是否使用临时表、是否排序等因素进行综合判断，由于这个查询语句并没有涉及到临时表和排序，所以MySQL选错索引肯定是在判断扫描行数的时候出现了问题。\",\"MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数，这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好，而一个索引上不同的值的个数，我们称之为“基数（cardinality）”。也就是说，这个基数越大，索引的区分度就越好。\",\"我们可以使用show index方法，看到一个索引的基数，如下图所示：\",\"可以看到，虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不同，而且其实都不准确。\",\"MySQL会通过采样统计的方式来得到索引的基数，采用采样统计的原因主要是，如果把整张表取出来一行行统计，然后可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。\",\"采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。而数据表是会持续更新的，索引统计信息也不会固定不变，所以当变更的数据行超过1/M的时候，会自动触发重新做一次索引统计。\",\"在MySQL中，有两种存储索引统计的方式，可以通过设置参数innodb_stats_persistent的值来选择：\",\"设置为no的时候，表示统计信息会持久化存储，这时，默认的N是20，M是10\",\"设置为off的时候，表示统计信息只存储在内存中，这时，默认的N是8，M是16\",\"由于是采样统计，所以不管是N是20还是8，这个基数都是很容易不准的。\",\"MySQL的优化器除了会统计索引的基数，还会判断这个语句本身要扫描的行数，可以通过explain的rows列来查看：\",\"可以看到，Q2的rows的值是37116，与实际的10000相差较大，这里实际上存在两个问题，一是语句Q1优化器为什么没有选择索引‘a’，二是语句Q2为什么优化器没有选择37116行的执行计划，而是选择扫描行数是100000的执行计划，\",\"对于问题二，如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行的数据，而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价，优化器会估算这两个选择的代价，虽然从执行时间上来看，这个选择并不是最优的。\",\"使用普通索引需要把回表的代价算进去，所以，MySQL选错索引，最根本的原因是没有能准确地判断出扫描行数，我们可以使用analyze table t命令，可以用来重新统计索引信息，我们来看一下执行效果。\",\"如果explain的结果预估的rows的值跟实际情况差距比较大，都可以采用这个方法来处理。\",\"依然基于表t，执行另外一个语句：\",\"select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order b limit 1; \",\"从查询条件来看，这个查询没有符合条件的记录，因此将会返回空集合。为了方便理解这条语句的索引选择过程，首先来看一下a、b这两个索引的结构图：\",\"如果使用索引a进行查询，首先扫描索引a的前1000个值，然后取到对应的id，再到主键索引上去查出每一行，然后根据字段b来过滤，显然这样需要扫描1000行。如果使用索引b进行查询，首先扫描索引b的最后50001个值，然后取到对应的id，再回到主键索引上取值再判断，所以需要扫描50001行。显然，使用索引a，执行速度明显会快很多，我们来看看MySQL是如何选择的：\",\"可以看到，返回结果中key字段显式，这次优化器选择了索引b，而rows字段显式需要扫描的行数是50198。也就是说，扫描的行数的估计值依然不准确，并且MySQL又选错了索引。\"]},\"348\":{\"h\":\"索引选择异常和处理\",\"t\":[\"当碰到优化器选择索引错误的时候，我们应该如何处理呢？\",\"一种方法是，就像我们的第一个例子一样，采用force index强行选择一个索引。MySQL会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不会再评估其它索引的执行代价了，执行的效果如下：\",\"原本语句需要执行2.23秒，而使用force index（a）的时候，只用了0.05秒，比优化器的选择快了40多倍。但这种方法并不完美，一是这么写不足够优雅，二是如果索引改了名字，这个语句也需要同步修改，三是这个语法并不是所有的数据库都支持，迁移比较麻烦。\",\"既然优化器放弃了使用索引a，说明a还不够合适，所以第二种方法就是，修改语句，引导MySQL使用我们期望的索引。比如，在这个例子中，显然把“order by b limit 1”改成“order by b，a limit 1”，语义的逻辑是相同的，我们看一下修改之后的效果：\",\"之前优化器选择使用索引b，是因为它认为使用索引b可以避免排序（b本身是索引，已经是有序的了，如果选择索引b的话，不需要再做排序，只需要遍历），所以即使扫描的行数多，也判定为代价更小。将语句修改为order by b，a，要求按照b，a排序，就意味着使用这两个索引都需要排序。因此，扫描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描1000行的索引a。\",\"当然，这种修改并不是通用的优化手段，只是刚好在这个语句中有limit 1，因此如果有满足条件的记录，order by b limit 1和order by b，a limit 1都会返回b是最小的那一行，逻辑上一致，才可以这么做，除了这种做法，还可以将语句修改为：\",\"select * from (select * from t where (a between 1 and 1000) and (b between 50000 and 100) order by b limit 100) alias limit 1; \",\"执行的效果如下：\",\"在这个例子中，我们用limit 100让优化器意识到，使用b索引的代价是很高的，其实是我们根据数据特征诱导了一下优化器，也不具备通用性。\",\"第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。不过在这个例子中，这种方法并不适用。\"]},\"349\":{\"h\":\"字符串添加索引\",\"t\":[\"在业务开发中，我们经常会碰到要存储字符串的场景，例如邮箱、用户名等，那么如何给字符串添加合适的索引呢？\",\"假设，现在有一个支持邮箱登录的系统，用户表是这么定义的：\",\"CREATE TABLE SUser ( ID bigint UNSIGNED PRIMARY KEY, email varchar(64), ... ) ENGINE = innodb; \",\"如果要使用邮箱登录，那么业务代码中一定会出现类似这样的语句：\",\"select f1, f2 from SUser where email = 'xxx'; \"]},\"350\":{\"h\":\"前缀索引\",\"t\":[\"如果email这个字段上没有索引，那么这个语句就只能全表扫描。在MySQL中是支持前缀索引的，也就是说，可以定义字符串的一部分作为索引，如果创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。\",\"比如，这两个在email字段上创建索引的语句：\",\"alter table SUser add index index1(email); 或 alter table SUser add index index2(email(6)); \",\"第一个语句创建的index1索引里面，包含了每个记录的整个字符串，而第二个语句创建的index2索引里面，对于每个记录都是只取前6个字节，它们的示意图如下所示：\",\"从图中可以看到，由于email(6)这个索引结构中每个邮箱的字段都只取6个字节（即：zhangs），索引占用的空间会更小，这就是使用前缀索引的优势，但同时，前缀索引也可能会增加额外的记录扫描次数，通过它们的执行过程能更加清楚看到这一点。\",\"如果使用的是index1（即email整个字符串的索引结构），执行顺序如下：\",\"从index1索引树找到满足索引值是'zhangssxyz@xxx.com'的这条记录，取得ID2的值\",\"到主键上查找到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集\",\"取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email='zhangssxyz@xxx.com'的条件了，循环结束\",\"在整个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。\",\"如果使用的是index2（即email（6）索引结构），执行顺序如下：\",\"从index2索引树找到满足索引值是'zhangs'的记录，找到的第一个是ID1\",\"到主键查找到主键是ID1的行，判断出email的值不是'zhangssxyz@xxx.com'，这行记录丢弃\",\"取index2上刚刚查到的位置的下一条记录，发现仍然是'zhangs'，取出ID2，再到ID索引上取整行然后判断，这次值取对了，将这行记录加入结果集\",\"重复上一步，直到在index2上取到的值不是'zhangs'时，循环结束\",\"在这个过程中，要回主键索引取4次数据，也就是扫描了4行。\",\"通过以上两种情况的对比，可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多，但是对于这个查询语句来说，如果定义的index2不是email(6)而是email(7)，也就是说取email字段的前7个字节来构建索引的话，即满足前缀'zhangss'的记录只有一个，也能够直接查到ID2，只扫描这一行就结束了。\",\"这说明在使用前缀索引的时候，定义合理的长度，就可以做到既节省空间，又不用额外增加太多的查询成本。\",\"我们可以通过统计索引上有多少个不同的值来判断需要使用多长的前缀，首先计算这个列上有多少个不同的值：\",\"select count(distinct email) as L from SUser; \",\"然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引：\",\"select count(distinct left(email,4) ） as L4, count(distinct left(email,5) ） as L5, count(distinct left(email,6) ） as L6, count(distinct left(email,7) ） as L7, from SUser; \",\"前缀索引很可能会损失区分度，所以需要预先设定一个可以接受的损失比例，比如5%，然后在返回的L4~L7中，找出不小于L*95%的值，假设这里L6、L7都满足，就可以选择前缀长度为6。\"]},\"351\":{\"h\":\"前缀索引与覆盖索引\",\"t\":[\"前缀索引除了可能会增加扫描行数，影响到性能外，还可能会导致覆盖索引失效。\",\"假设我们要查询的语句如下：\",\"select id,email from SUser where email='zhangssxyz@xxx.com'; \",\"与前面的例子中的SQL语句：\",\"select id,name,email from SUser where email='zhangssxyz@xxx.com'; \",\"相比，这个语句只要求返回id和email字段，所以，如果使用index1（即整个email字符串的索引结构）的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再查一次。而如果使用index2（即email（6）所索引结构）的话，就不得不回到ID索引再去判断email字段的值。\",\"即使将index2的定义修改为email（18）的前缀索引，这时候，虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。也就是说前缀索引就用不上覆盖索引对查询性能的优化了，这也是在选择是否使用前缀索引时需要考虑的一个因素。\"]},\"352\":{\"h\":\"其它方式\",\"t\":[\"实际场景中，我们很有可能碰到前缀的区分度不够好的情况，例如身份证号，总共18位，其中前6位是地址码，所以同一个县的人的身份证号前6位一般会是相同的。假设维护的数据库是同一个市的公民信息系统，这时候如果对身份证号长度为6的前缀索引的话，这个索引的区分度就非常低了，需要创建长度为12位以上的前缀索引，才能够满足区分度的要求，但是索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。解决这个问题通常来说有两种方式：倒序存储和使用哈希字段。\",\"倒序存储是指如果存储身份证号码的时候把它倒过来存，每次查询的时候，可以：\",\"select field_list from t where id_card = reverse('input_id_card_string'); \",\"由于身份证号码的最后6位没有地址码这样的重复逻辑，所以最后这6位就提供了足够的区分度，实践中可以使用count(distinct)方法做个验证。\",\"使用哈希字段指的是可以在表上创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引：\",\"alter table t add id_card_crc int unsigned, add index(id_card_crc); \",\"然后每次插入新记录的时候，都同时用cr32（）这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证通过crc32（）函数得到的结果可能是相同的，所以查询语句where部分要判断id_card的值是否精确相同。这样一来，索引的长度变成了4个字节，比原来小了很多。\",\"使用倒序存储和使用哈希字段两种方式的异同点如下：\",\"首先，它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X,ID_Y]的所有市民了。同样地，哈希字段的方式也只能支持等值查询。\",\"它们的区别，主要在以下三个方面：\",\"从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而哈希字段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个哈希字段也差不多抵消了\",\"在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而哈希字段的方式需要额外调用一次crc32()函数，如果只是从这两个函数的计算复杂度来看的话，reverse函数额外消耗的CPU的资源会更小一些\",\"从查询效率上看，使用哈希字段方式的查询性能相对更稳定一些，因为crc32（）算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数\"]},\"353\":{\"h\":\"order by与索引\",\"t\":[\"在开发应用的时候，一定碰到过需要根据指定的字段排序来显示结果的需求，还是以我们前面举例用过的市民表为例，假设要查询城市是“杭州”的所有人的名字，并且按照姓名排序返回前1000个人的姓名、年龄。\",\"建表语句如下：\",\"CREATE TABLE `t` ( `id` int(11) NOT NULL, `city` varchar(16) NOT NULL, `name` varchar(16) NOT NULL, `age` int(11) NOT NULL, `addr` varchar(128) DEFAULT NULL, PRIMARY KEY (`id`), KEY `city` (`city`) ) ENGINE = InnoDB; \",\"那么查询语句：\",\"select city,name,age from t where city=' 杭州 ' order by name limit 1000; \"]},\"354\":{\"h\":\"全字段排序\",\"t\":[\"为了避免全表扫描，我们需要在city字段加上索引，city这个索引的示意图如下：\",\"在city字段上创建索引之后，使用explain查看执行情况：\",\"Extra这个字段中的“Using filesort”表示就是需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。\",\"从索引的示意图中可以看出， city='杭州'条件的行，是从 ID_X 到 ID_(X+N) 的这些记录。下面我们来分析整个语句的执行过程：\",\"初始化sort_buffer，确定放入name、city、age这三个字段\",\"从索引city找到第一个满足city='杭州'条件的主键id，也就是图中的ID_X\",\"到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中\",\"从索引city取下一个记录的主键id\",\"重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y\",\"对sort_buffer中的数据按照字段name做快速排序\",\"按照排序结果取前1000行返回给客户端\",\"这个过程就称为全字段排序，执行流程的示意图如下所示：\",\"图中“按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需要的内存和参数sort_buffer_size。sort_buffer_size就是MySQL为排序开辟的内存（sort_buffer）的大小，如果要排序的数据量小于sort_buffer_size，排序就在内存中完成，但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。可以通过如下命令来查看\",\"/* 打开 optimizer_trace ，只对本线程有效 */ SET optimizer_trace='enabled=on'; /* @a 保存 Innodb_rows_read 的初始值 */ select VARIABLE_VALUE into @a from performance_schema.session_status where variable_name = 'Innodb_rows_read'; /* 执行语句 */ select city, name,age from t where city=' 杭州 ' order by name limit 1000; /* 查看 OPTIMIZER_TRACE 输出 */ SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\\\\G /* @b 保存 Innodb_rows_read 的当前值 */ select VARIABLE_VALUE into @b from performance_schema.session_status where variable_name = 'Innodb_rows_read'; /* 计算 Innodb_rows_read 差值 */ select @b-@a; \",\"这个方法是通过查看OPTIMIZER_TRACE的结果来确认的，也可以从number_of_tmp_files中看到是否使用了临时文件。\",\"图中number_of_tmp_files表示的是，排序过程中使用的临时的文件数，之所以是12个文件，是当内存放不下时，就需要外部排序，外部排序一般使用归并排序算法，MySQL将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中，然后把这12个有序文件再合并成一个有序的大文件。如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序可以直接在内存中完成，否则就需要放在临时文件中排序。sort_buffer_size越小，需要的分成的份数就越多，number_of_tmp_files的值就越大。\",\"另外，在示例表中有4000条满足city='杭州'的记录，所以图中的examined_rows=4000，表示参与排序的行数是4000行。\",\"sort_mode里面的packed_additional_fields的意思是，排序过程中对字符串做了“紧凑处理”，即使name字段的定义是varchar(16)，在排序的过程中还是按照实际长度来分配空间的。\",\"最后的查询select @b - @a在MyISAM引擎中返回的结果是4000，而在InnoDB引擎中会返回4001，这是因为如果使用的是InnoDB引擎的话，在查询表optimizer_trace的时候，需要用到临时表，InnoDB会把数据从临时表取出来，然后让innodb_rows_read的值加1。\"]},\"355\":{\"h\":\"rowid排序\",\"t\":[\"上面的排序算法，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时表中执行的，但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数就很少，要分成很多个临时文件，排序的性能会很差，所以如果单行很大，这个方法效率不够好。\",\"我们可以通过修改参数，让MySQL换成另外一种算法：\",\"SET max_length_for_sort_data = 16; \",\"它的意思是，如果单行的长度超过了这个值，MySQL就认为单行太大，要换一个算法。city、name、age这三个字段的定义总长度是36，超过了16，这个时候，MySQL就会使用rowid排序。\",\"新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id，但这个时候，排序的结果因为少了city和age字段的值，不能直接返回了，整个执行流程如下：\",\"初始化sort_buffer，确定放入两个字段，即name和id\",\"从索引city找到第一个满足city=“杭州”条件的主键id，也就是图中的ID_X\",\"到主键id索引取出整行，取name、id这两个字段，存入sort_buffer\",\"从索引city取下一个记录的主键id\",\"重复步骤3、4直到不满足city=“杭州”条件为止，也就是图中的ID_Y\",\"对sort_buffer中的数据按照字段name进行排序\",\"遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name、age三个字段返回给客户端\",\"执行的示意图如下：\",\"对于全字段的排序流程图会发现，rowid排序多访问了一次表t的主键索引，也就是步骤7。需要说明的是，最后的“结果集”是一个逻辑概念，实际上MySQL服务端从排序后的sort_buffer中依次取出id，然后原表查到city、name和age这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的，此时的OPTIMIZER_TRACE的结果如下：\",\"可以发现：\",\"sort_mode变成了<sort_key,rowid>,表示参与排序的只有name和id这两个字段\",\"number_of_tmp_files变成10了，是因为这时候参与排序的行数虽然仍然是4000行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了\"]},\"356\":{\"h\":\"全字段排序和rowid排序对比\",\"t\":[\"当MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再会到原表去取数据；当内存太小，会影响排序效率，MySQL才会采用rowid排序算法，这样在排序过程中一次可以排序更多行，但是需要再回到原表去取数据。这体现了MySQL的一个设计理念：如果内存足够，就要多利用内存，尽量减少磁盘访问，对于InnoDB表来说，rowid排序会要求回表，因此不会优先选择。\",\"不难发现，在MySQL中，对于无序的字段，排序是一个成本比较高的操作，因此，优化order by语句的一种方式就是让原来无序的数据变的“有序”。还是以市民表为例，我们在这个市民表上创建一个city和name的联合索引，对应的SQL语句是：\",\"alter table t add index city_user(city, name); \",\"索引的示意图：\",\"在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city=\\\"杭州\\\"的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是有序的。这样整个查询过程的流程就变成了：\",\"从索引（city，name）找到第一个满足city=\\\"杭州\\\"条件的主键id\",\"到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回\",\"从索引（city，name）取下一个记录主键id\",\"重复步骤2、3，直到查到1000条记录，或者是不满足city=\\\"杭州\\\"条件时循环结束\",\"可以看到，这个查询过程不需要临时表，也不需要排序，explain的结果如下：\",\"可以看到，Extra字段中没有Using filesort了，也就是不需要排序了，而且由于（city，name）这个联合索引本身有序，所以这个查询也不用把4000行全都读一遍，只要找到满足条件的前1000条记录就可以退出了，也就是说，在这个例子中，只需要扫描1000次。\",\"还可以更进一步，使用覆盖索引：\",\"alter table t add index city_user_age(city, name, age); \",\"这时，对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询也就不再需要排序了，这样整个查询语句的执行流程就变成了：\",\"从索引（city，name，age）找到第一个满足city=\\\"杭州\\\"条件的记录，取出其中的city、name和age这三个字段的值，作为结果集的一部分直接返回\",\"从索引（city，name，age）取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回\",\"重复执行步骤2，直到查到第1000条记录，或者是不满足city=\\\"杭州\\\"条件时循环结束\",\"explain的结果如下：\",\"可以看到Extra字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多，不过索引还是有维护代价的，这是一个需要权衡的决定。\"]},\"357\":{\"h\":\"索引的创建时机\",\"t\":[\"前面我们了解了一些关于索引的理论知识，接下来我们着重了解一些索引的实践部分。\"]},\"358\":{\"h\":\"哪些情况需要建索引\",\"t\":[\"主键自动建立主键索引（唯一 + 非空）。\",\"频繁作为查询条件的字段应该创建索引。\",\"查询中与其他表关联的字段，外键关系建立索引。\",\"查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。\",\"查询中统计或者分组字段（group by也和索引有关）。\"]},\"359\":{\"h\":\"哪些情况不要建索引\",\"t\":[\"记录太少的表。\",\"经常增删改的表。\",\"频繁更新的字段不适合创建索引。\",\"Where条件里用不到的字段不创建索引。\",\"假如一个表有10万行记录，有一个字段A只有true和false两种值，并且每个值的分布概率大约为50%，那么对A字段建索引一般不会提高数据库的查询速度。索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。\"]},\"360\":{\"h\":\"索引的最佳实践\"},\"361\":{\"h\":\"单表索引分析\",\"t\":[\"数据准备\",\"DROP TABLE IF EXISTS `article`; CREATE TABLE IF NOT EXISTS `article`( `id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '主键', `author_id` INT(10) UNSIGNED NOT NULL COMMENT '作者id', `category_id` INT(10) UNSIGNED NOT NULL COMMENT '分类id', `views` INT(10) UNSIGNED NOT NULL COMMENT '被查看的次数', `comments` INT(10) UNSIGNED NOT NULL COMMENT '回帖的备注', `title` VARCHAR(255) NOT NULL COMMENT '标题', `content` VARCHAR(255) NOT NULL COMMENT '正文内容' ) COMMENT '文章'; INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(1,1,1,1,'1','1'); INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(2,2,2,2,'2','2'); INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(3,3,3,3,'3','3'); INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(1,1,3,3,'3','3'); INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(1,1,4,4,'4','4'); \",\"案例：查询category_id为1且comments大于1的情况下，views最多的article_id。\",\"1、编写SQL语句并查看SQL执行计划。\",\"# 1、sql语句 SELECT id,author_id FROM article WHERE category_id = 1 AND comments > 1 ORDER BY views DESC LIMIT 1; # 2、sql执行计划 mysql> EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments > 1 ORDER BY views DESC LIMIT 1\\\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: article partitions: NULL type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 5 filtered: 20.00 Extra: Using where; Using filesort # 产生了文件内排序，需要优化SQL 1 row in set, 1 warning (0.00 sec) \",\"2、创建索引idx_article_ccv。\",\"CREATE INDEX idx_article_ccv ON article(category_id,comments,views); \",\"3、查看当前索引。\",\"4、查看现在SQL语句的执行计划。\",\"我们发现，创建符合索引idx_article_ccv之后，虽然解决了全表扫描的问题，但是在order by排序的时候没有用到索引，MySQL居然还是用的Using filesort，为什么？\",\"5、我们试试把SQL修改为SELECT id,author_id FROM article WHERE category_id = 1 AND comments = 1 ORDER BY views DESC LIMIT 1;看看SQL的执行计划。\",\"推论：当comments > 1的时候order by排序views字段索引就用不上，但是当comments = 1的时候order by排序views字段索引就可以用上！！！所以，范围之后的索引会失效。\",\"6、我们现在知道范围之后的索引会失效，原来的索引idx_article_ccv最后一个字段views会失效，那么我们如果删除这个索引，创建idx_article_cv索引呢？？？？\",\"/* 创建索引 idx_article_cv */ CREATE INDEX idx_article_cv ON article(category_id,views); \",\"查看当前的索引\",\"7、当前索引是idx_article_cv，来看一下SQL执行计划。\"]},\"362\":{\"h\":\"两表索引分析\",\"t\":[\"数据准备\",\"DROP TABLE IF EXISTS `class`; DROP TABLE IF EXISTS `book`; CREATE TABLE IF NOT EXISTS `class`( `id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '主键', `card` INT(10) UNSIGNED NOT NULL COMMENT '分类' ) COMMENT '商品类别'; CREATE TABLE IF NOT EXISTS `book`( `bookid` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '主键', `card` INT(10) UNSIGNED NOT NULL COMMENT '分类' ) COMMENT '书籍'; \",\"两表连接查询的SQL执行计划\",\"1、不创建索引的情况下，SQL的执行计划。\",\"book和class两张表都是没有使用索引，全表扫描，那么如果进行优化，索引是创建在book表还是创建在class表呢？下面进行大胆的尝试！\",\"2、左表(book表)创建索引。\",\"创建索引idx_book_card\",\"/* 在book表创建索引 */ CREATE INDEX idx_book_card ON book(card); \",\"在book表中有idx_book_card索引的情况下，查看SQL执行计划\",\"3、删除book表的索引，右表(class表)创建索引。\",\"创建索引idx_class_card\",\"/* 在class表创建索引 */ CREATE INDEX idx_class_card ON class(card); \",\"在class表中有idx_class_card索引的情况下，查看SQL执行计划\",\"由此可见，左连接将索引创建在右表上更合适，右连接将索引创建在左表上更合适。\"]},\"363\":{\"h\":\"三张表索引分析\",\"t\":[\"数据准备\",\"DROP TABLE IF EXISTS `phone`; CREATE TABLE IF NOT EXISTS `phone`( `phone_id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '主键', `card` INT(10) UNSIGNED NOT NULL COMMENT '分类' ) COMMENT '手机'; \",\"三表连接查询SQL优化\",\"1、不加任何索引，查看SQL执行计划。\",\"2、根据两表查询优化的经验，左连接需要在右表上添加索引，所以尝试在book表和phone表上添加索引。\",\"/* 在book表创建索引 */ CREATE INDEX idx_book_card ON book(card); /* 在phone表上创建索引 */ CREATE INDEX idx_phone_card ON phone(card); \",\"再次执行SQL的执行计划\"]},\"364\":{\"h\":\"结论\",\"t\":[\"JOIN语句的优化：\",\"尽可能减少JOIN语句中的NestedLoop（嵌套循环）的总次数：永远都是小的结果集驱动大的结果集。\",\"优先优化NestedLoop的内层循环。\",\"保证JOIN语句中被驱动表上JOIN条件字段已经被索引。\",\"当无法保证被驱动表的JOIN条件字段被索引且内存资源充足的前提下，不要太吝惜Join Buffer 的设置。\"]},\"365\":{\"h\":\"索引失效\",\"t\":[\"索引看起来非常美好，能够十分有效的加快我们的查询效率，然而，在MySQL中有很多看上去逻辑相同，但是性能却差异巨大的SQL语句，对这些语句使用不当的话，就会不经意间导致整个数据库的压力变大，\"]},\"366\":{\"h\":\"函数操作\",\"t\":[\"假设现在维护的是一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员id（operator）、交易时间（t_modified）等字段，建表语句如下：\",\"CREATE TABLE `tradelog` ( `id` int(11) NOT NULL, `tradeid` varchar(32) DEFAULT NULL, `operator` int(11) DEFAULT NULL, `t_modified` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `tradeid` (`tradeid`), KEY `t_modified` (`t_modified`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; \",\"假设现在已经记录了从2016年初到2018年底的所有数据，要查询所有年份中7月份的交易记录总数，SQL语句可能如下：\",\"select count(*) from tradelog where month(t_modified)=7; \",\"执行之后就会发现这个SQL语句会比预期的慢很多，虽然在t_modified字段上已经创建了索引，但是MySQL并没有使用这个索引。下面是t_modified索引的示意图，方框上面的数字表示month()函数对应的值：\",\"如果SQL语句中条件是where t_modified='2018-7-1'的话，引擎就会按照上面绿色箭头的路线，快速定位到t_modified='2018-7-1'需要的结果，而如果计算month()函数的话，在传入7的时候已经无法定位记录了。实际上，B+树提供的这个快速定位能力，来源于同一层兄弟节点的有序性，也就是说，对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器决定放弃走树搜索功能。\",\"需要注意的是，优化器并不是要放弃使用这个索引，在这个例子中，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引t_modified，优化器对比索引大小后发现，索引t_modified更小，遍历这个索引比主键索引来得更快，因此最终还是会选择索引t_modified。\",\"这条语句的explain的结果如下：\",\"key=\\\"t_modified\\\"表示的是，使用了t_modified这个索引，这里的测试数据有10万行，rows=100335，说明这条语句扫描了整个索引的所有值，Extra字段的Using index，表示的是使用了覆盖索引，也就是说，由于在t_modified字段加上了month()函数操作，导致了全索引扫描。为了能够用上索引的快速定位能力，我们就要把SQL语句改成基于字段本身的范围查询：\",\"select count(*) from tradelog where (t_modified >= '2016-7-1' and t_modified<'2016-8-1') or (t_modified >= '2017-7-1' and t_modified<'2017-8-1') or (t_modified >= '2018-7-1' and t_modified<'2018-8-1'); \",\"如果还有其它年份的数据，都需要手动将年份补齐。实际上，只要where条件后面有函数操作都会导致无法使用索引快速定位的功能，即使不改变有序性，例如select * from tradelog where id + 1 = 10000,也需要将where条件修改为where id = 10000 - 1才可以有效的用上索引。\"]},\"367\":{\"h\":\"隐式类型转换\",\"t\":[\"假设我们执行这样一条SQL语句：\",\"select * from tradelog where tradeid = 110717; \",\"交易编号tradeid这个字段上，本来是有索引的，但是explain结果却显式，这条语句需要走全表扫描，这是由于tradeid字段类型是varchar（32），而输入的参数却是整型，所以需要做类型转换，从而导致了索引失效。实际上在MySQL中，字符串和数字做比较的话，会将字符串转换成数字，也就是说对与优化器来说，上面的SQL语句等价于：\",\"select * from tradelog where CAST(tradid AS signed int) = 110717; \",\"也就是说，这条语句触发了我们之前说到的过规则：对索引字段做函数操作，优化器会放弃走树搜索功能。\"]},\"368\":{\"h\":\"隐式字符编码转换\",\"t\":[\"假设系统里面还有另外一张表trade_detail，用来记录交易的操作细节。为了便于量化分析和复现，我们往交易日志表tradelog和交易详情表trade_detail这两个表里插入一些数据：\",\"CREATE TABLE `trade_detail` ( `id` int(11) NOT NULL, `tradeid` varchar(32) DEFAULT NULL, `trade_step` int(11) DEFAULT NULL, `step_info` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`), KEY `tradeid` (`tradeid`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8; insert into tradelog insert into tradelog values(1, 'aaaaaaaa', 1000, now()); insert into tradelog values(2, 'aaaaaaab', 1000, now()); insert into tradelog values(3, 'aaaaaaac', 1000, now()); insert into trade_detail values(1, 'aaaaaaaa', 1, 'add'); insert into trade_detail values(2, 'aaaaaaaa', 2, 'update'); insert into trade_detail values(3, 'aaaaaaaa', 3, 'commit'); insert into trade_detail values(4, 'aaaaaaab', 1, 'add'); insert into trade_detail values(5, 'aaaaaaab', 2, 'update'); insert into trade_detail values(6, 'aaaaaaab', 3, 'update again'); insert into trade_detail values(7, 'aaaaaaab', 4, 'commit'); insert into trade_detail values(8, 'aaaaaaac', 1, 'add'); insert into trade_detail values(9, 'aaaaaaac', 2, 'update'); insert into trade_detail values(10, 'aaaaaaac', 3, 'update again'); insert into trade_detail values(11, 'aaaaaaac', 4, 'commit'); \",\"这时候，如果要查询id=2的交易的所有操作步骤信息，可以使用如下SQL语句：\",\"select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2; \",\"可以看到：\",\"第一行显式优化器现在交易记录表tradelog上查到id=2的行，这个步骤用上了主键索引，rows=1表示只扫描一行\",\"第二行key=NULL，表示没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫描\",\"explain的详细过程如下：\",\"图中：\",\"第一步，是根据id在tradelog表里找到L2这一行\",\"第二步，是从L2中取出tradeid字段的值\",\"第三步，是根据tradeid的值到trade_detail表中查找条件匹配的行。explain的结果第二行的key=NULL表示的就是，这个过程是通过遍历主键索引的方式，一个一个地判断tradeid的值是否匹配\",\"可以发现，在执行第三步的时候，并没有使用trade_detail里的tradeied上的索引快速定位到等值的行。实际上，这是因为这两张表的字符集不同导致的，上面的SQL等价于：\",\"select * from trade_detail where CONVERT(traideid USING utf8mb4) = $L2.tradeid.value; \",\"CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集，这再次触发了本节开始时提到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。\",\"utf8mb4是utf8的超集，类似地，在程序设计语言里面，做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加地方向”进行转换的。\",\"接下来我们看另外一种场景：\",\"select l.operator from tradelog l , trade_detail d where d.tradeid=l.tradeid and d.id = 4; \",\"explain的结果：\",\"这个语句里trade_detail表成了驱动表，但是explain结果的第二行显示，这次的查询操作用上了被驱动表tradelog里的索引（tradeied），扫描行数是1，这也是两个tradeied字段的join操作，为什么这次能用上被驱动表的tradeied索引呢？假设驱动表trade_detail里id=4的行记为R4，那么在连接的时候。被驱动表tradelog上执行的就是类似这样的SQL语句：\",\"select operator from tradelog where traideid = $R4.tradeid.value; \",\"这个时候的$R4.tradeied.value的字符集是utf8，按照字符集转换规则，要转成utf8mb4，所以这个过程就被改写成：\",\"select operator from tradelog where traideid =CONVERT($R4.tradeid.value USING utf8mb4); \",\"由于这里CONVERT函数是加在输入参数上的，这样就可以用上被驱动表的tradeid索引了。\",\"因此，对于SQL：\",\"select d.* from tradelog l, trade_detail d where d.tradeid = l.tradeid and l.id = 2; \",\"优化的方式通常有两种：\",\"比较常见的优化方法是，把trade_detail表上的tradeid字段的字符集也改成utf8mb4，这样就没有字符集转换问题了\",\"alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null; \",\"如果数据量比较大，或者其它原因不能执行这个DDL，那么可以修改SQL语句：\",\"select d.* from tradelog l, trade_detail d where d.tradeid = CONVERT(l.tradeid USING utf8); \",\"这样主动把l.tradeid转成utf8，就避免了被驱动表上的字符编码转换。\"]},\"369\":{\"h\":\"索引失效的场景\",\"t\":[\"全值匹配我最爱。\",\"最佳左前缀法则。\",\"不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描。\",\"索引中范围条件右边的字段会全部失效。\",\"尽量使用覆盖索引（只访问索引的查询，索引列和查询列一致），减少SELECT *。\",\"MySQL在使用!=或者<>的时候无法使用索引会导致全表扫描。\",\"is null、is not null也无法使用索引。\",\"like以通配符开头%abc索引失效会变成全表扫描（使用覆盖索引就不会全表扫描了）。\",\"字符串不加单引号索引失效。\",\"少用or，用它来连接时会索引失效。\"]},\"370\":{\"h\":\"最佳左前缀法则\",\"t\":[\"案例\",\"/* 用到了idx_staffs_name_age_pos索引中的name字段 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` = 'Ringo'; /* 用到了idx_staffs_name_age_pos索引中的name, age字段 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` = 'Ringo' AND `age` = 18; /* 用到了idx_staffs_name_age_pos索引中的name，age，pos字段 这是属于全值匹配的情况！！！*/ EXPLAIN SELECT * FROM `staffs` WHERE `name` = 'Ringo' AND `age` = 18 AND `pos` = 'manager'; /* 索引没用上，ALL全表扫描 */ EXPLAIN SELECT * FROM `staffs` WHERE `age` = 18 AND `pos` = 'manager'; /* 索引没用上，ALL全表扫描 */ EXPLAIN SELECT * FROM `staffs` WHERE `pos` = 'manager'; /* 用到了idx_staffs_name_age_pos索引中的name字段，pos字段索引失效 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` = 'Ringo' AND `pos` = 'manager'; \",\"概念\",\"最佳左前缀法则：如果索引是多字段的复合索引，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的字段。\",\"口诀：带头大哥不能死，中间兄弟不能断。\"]},\"371\":{\"h\":\"索引列上不计算\",\"t\":[\"案例\",\"# 现在要查询`name` = 'Ringo'的记录下面有两种方式来查询！ # 1、直接使用 字段 = 值的方式来计算 mysql> SELECT * FROM `staffs` WHERE `name` = 'Ringo'; +----+-------+-----+---------+---------------------+ | id | name | age | pos | add_time | +----+-------+-----+---------+---------------------+ | 1 | Ringo | 18 | manager | 2020-08-03 08:30:39 | +----+-------+-----+---------+---------------------+ 1 row in set (0.00 sec) # 2、使用MySQL内置的函数 mysql> SELECT * FROM `staffs` WHERE LEFT(`name`, 5) = 'Ringo'; +----+-------+-----+---------+---------------------+ | id | name | age | pos | add_time | +----+-------+-----+---------+---------------------+ | 1 | Ringo | 18 | manager | 2020-08-03 08:30:39 | +----+-------+-----+---------+---------------------+ 1 row in set (0.00 sec) \",\"我们发现以上两条SQL的执行结果都是一样的，但是执行效率有没有差距呢？？？\",\"通过分析两条SQL的执行计划来分析性能。\",\"由此可见，在索引列上进行计算，会使索引失效。\",\"口诀：索引列上不计算。\"]},\"372\":{\"h\":\"范围之后全失效\",\"t\":[\"案例\",\"/* 用到了idx_staffs_name_age_pos索引中的name，age，pos字段 这是属于全值匹配的情况！！！*/ EXPLAIN SELECT * FROM `staffs` WHERE `name` = 'Ringo' AND `age` = 18 AND `pos` = 'manager'; /* 用到了idx_staffs_name_age_pos索引中的name，age字段，pos字段索引失效 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` = '张三' AND `age` > 18 AND `pos` = 'dev'; \",\"查看上述SQL的执行计划\",\"由此可知，查询范围的字段使用到了索引，但是范围之后的索引字段会失效。\",\"口诀：范围之后全失效。\"]},\"373\":{\"h\":\"覆盖索引尽量用\",\"t\":[\"在写SQL的不要使用SELECT *，用什么字段就查询什么字段。\",\"/* 没有用到覆盖索引 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` = 'Ringo' AND `age` = 18 AND `pos` = 'manager'; /* 用到了覆盖索引 */ EXPLAIN SELECT `name`, `age`, `pos` FROM `staffs` WHERE `name` = 'Ringo' AND `age` = 18 AND `pos` = 'manager'; \",\"口诀：查询一定不用*。\"]},\"374\":{\"h\":\"不等有时会失效\",\"t\":[\"/* 会使用到覆盖索引 */ EXPLAIN SELECT `name`, `age`, `pos` FROM `staffs` WHERE `name` != 'Ringo'; /* 索引失效 全表扫描 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` != 'Ringo'; \"]},\"375\":{\"h\":\"like百分加右边\",\"t\":[\"/* 索引失效 全表扫描 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` LIKE '%ing%'; /* 索引失效 全表扫描 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` LIKE '%ing'; /* 使用索引范围查询 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` LIKE 'Rin%'; \",\"口诀：like百分加右边。\",\"如果一定要使用%like，而且还要保证索引不失效，那么使用覆盖索引来编写SQL。\",\"/* 使用到了覆盖索引 */ EXPLAIN SELECT `id` FROM `staffs` WHERE `name` LIKE '%in%'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `name` FROM `staffs` WHERE `name` LIKE '%in%'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `age` FROM `staffs` WHERE `name` LIKE '%in%'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `pos` FROM `staffs` WHERE `name` LIKE '%in%'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `id`, `name` FROM `staffs` WHERE `name` LIKE '%in%'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `id`, `age` FROM `staffs` WHERE `name` LIKE '%in%'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `id`,`name`, `age`, `pos` FROM `staffs` WHERE `name` LIKE '%in'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `id`, `name` FROM `staffs` WHERE `pos` LIKE '%na'; /* 索引失效 全表扫描 */ EXPLAIN SELECT `name`, `age`, `pos`, `add_time` FROM `staffs` WHERE `name` LIKE '%in'; \",\"口诀：覆盖索引保两边。\"]},\"376\":{\"h\":\"字符要加单引号\",\"t\":[\"/* 使用到了覆盖索引 */ EXPLAIN SELECT `id`, `name` FROM `staffs` WHERE `name` = 'Ringo'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `id`, `name` FROM `staffs` WHERE `name` = 2000; /* 索引失效 全表扫描 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` = 2000; \",\"这里name = 2000在MySQL中会发生强制类型转换，将数字转成字符串。\",\"口诀：字符要加单引号。\"]},\"377\":{\"h\":\"索引相关题目\",\"t\":[\"假设index(a,b,c)\",\"Where语句\",\"索引是否被使用\",\"where a = 3\",\"Y，使用到a\",\"where a = 3 and b = 5\",\"Y，使用到a，b\",\"where a = 3 and b = 5\",\"Y，使用到a，b，c\",\"where b = 3 或者 where b = 3 and c = 4 或者 where c = 4\",\"N，没有用到a字段\",\"where a = 3 and c = 5\",\"使用到a，但是没有用到c，因为b断了\",\"where a = 3 and b > 4 and c = 5\",\"使用到a，b，但是没有用到c，因为c在范围之后\",\"where a = 3 and b like 'kk%' and c = 4\",\"Y，a，b，c都用到\",\"where a = 3 and b like '%kk' and c = 4\",\"只用到a\",\"where a = 3 and b like '%kk%' and c = 4\",\"只用到a\",\"where a = 3 and b like 'k%kk%' and c = 4\",\"Y，a，b，c都用到\"]},\"378\":{\"h\":\"面试题分析\",\"t\":[\"数据准备\",\"/* 创建表 */ CREATE TABLE `test03`( `id` INT PRIMARY KEY NOT NULL AUTO_INCREMENT, `c1` CHAR(10), `c2` CHAR(10), `c3` CHAR(10), `c4` CHAR(10), `c5` CHAR(10) ); /* 插入数据 */ INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES('a1','a2','a3','a4','a5'); INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES('b1','b22','b3','b4','b5'); INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES('c1','c2','c3','c4','c5'); INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES('d1','d2','d3','d4','d5'); INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES('e1','e2','e3','e4','e5'); /* 创建复合索引 */ CREATE INDEX idx_test03_c1234 ON `test03`(`c1`,`c2`,`c3`,`c4`); \",\"题目\",\"/* 最好索引怎么创建的，就怎么用，按照顺序使用，避免让MySQL再自己去翻译一次 */ /* 1.全值匹配 用到索引c1 c2 c3 c4全字段 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' AND `c3` = 'a3' AND `c4` = 'a4'; /* 2.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' AND `c4` = 'a4' AND `c3` = 'a3'; /* 3.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/ EXPLAIN SELECT * FROM `test03` WHERE `c4` = 'a4' AND `c3` = 'a3' AND `c2` = 'a2' AND `c1` = 'a1'; /* 4.用到索引c1 c2 c3字段，c4字段失效，范围之后全失效 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' AND `c3` > 'a3' AND `c4` = 'a4'; /* 5.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' AND `c4` > 'a4' AND `c3` = 'a3'; /* 6.用到了索引c1 c2 c3三个字段, c1和c2两个字段用于查找, c3字段用于排序了但是没有统计到key_len中，c4字段失效 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' AND `c4` = 'a4' ORDER BY `c3`; /* 7.用到了索引c1 c2 c3三个字段，c1和c2两个字段用于查找, c3字段用于排序了但是没有统计到key_len中*/ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' ORDER BY `c3`; /* 8.用到了索引c1 c2两个字段，c4失效，c1和c2两个字段用于查找，c4字段排序产生了Using filesort说明排序没有用到c4字段 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' ORDER BY `c4`; /* 9.用到了索引c1 c2 c3三个字段，c1用于查找，c2和c3用于排序 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c5` = 'a5' ORDER BY `c2`, `c3`; /* 10.用到了c1一个字段，c1用于查找，c3和c2两个字段索引失效，产生了Using filesort */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c5` = 'a5' ORDER BY `c3`, `c2`; /* 11.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' ORDER BY c2, c3; /* 12.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' AND `c5` = 'a5' ORDER BY c2, c3; /* 13.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 没有产生Using filesort 因为之前c2这个字段已经确定了是'a2'了，这是一个常量，再去ORDER BY c3,c2 这时候c2已经不用排序了！ 所以没有产生Using filesort 和(10)进行对比学习！ */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' AND `c5` = 'a5' ORDER BY c3, c2; /* GROUP BY 表面上是叫做分组，但是分组之前必定排序。 */ /* 14.用到c1 c2 c3三个字段，c1用于查找，c2 c3用于排序，c4失效 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c4` = 'a4' GROUP BY `c2`,`c3`; /* 15.用到c1这一个字段，c4失效，c2和c3排序失效产生了Using filesort */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c4` = 'a4' GROUP BY `c3`,`c2`; \",\"GROUP BY基本上都需要进行排序，索引优化几乎和ORDER BY一致，但是GROUP BY会有临时表的产生。\"]},\"379\":{\"h\":\"索引失效的原理分析\"},\"380\":{\"h\":\"索引失效的总结\",\"t\":[\"索引优化的一般性建议：\",\"对于单值索引，尽量选择针对当前query过滤性更好的索引。\",\"在选择复合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。\",\"在选择复合索引的时候，尽量选择可以能够包含当前query中的where子句中更多字段的索引。\",\"尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。\"]},\"381\":{\"h\":\"慢查询基础\",\"t\":[\"索引是如此的重要，以至于我们花费了不小的篇幅来介绍，这对于高性能来说是必不可少的。但这些还不够，还需要合理的设计查询，如果查询写得很糟糕，即使库表结构再合理、索引再合适，也无法实现高性能。查询优化、索引优化、库表结构优化需要多管齐下才能写出高效的SQL。\",\"如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行得更快。\",\"通常来说，查询的生命周期可以按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中“执行”可以认为是生命周期中最重要的阶段，这其中包含了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。\",\"在完成这些任务的时候，查询需要在不同的地方花费时间，包括网络，CPU计算，生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间。根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。\",\"在发生慢查询的时候，要么是某些操作被额外地重复了很多次，要么是某些操作执行得太慢。优化查询的目的就是减少和消除这些操作所花费的时间。\",\"查询性能低下最基本的原因是访问的数据太多，某些查询可能不可避免地需要筛选大量数据，但这并不常见。大部分性能低下的查询都可以通过减少访问数据量的方式进行优化，对于低效的查询，通过如下两个步骤来分析总是非常有效：\",\"确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列\",\"确认MySQL服务器层是否在分析大量超过需要的数据行\"]},\"382\":{\"h\":\"请求多余的数据\",\"t\":[\"有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃，这会给MySQL服务器带来额外的负担，并增加网络开销，离国内外i啊也会消耗应用服务器的CPU和内存资源。\"]},\"383\":{\"h\":\"查询不需要的记录\",\"t\":[\"一个常见的错误是常常会误以为MySQL只会返回需要的数据，实际上MySQL却是先返回全部结果集再进行计算。典型的场景是先使用select语句查询大量的结果，然后获取前面N行后关闭结果集（例如在新闻网站中取出100条记录，但是只是在页面上显示前面10条）。MySQL并不会只查出需要的10条数据，而是会查询出全部的结果集，客户端的应用程序会接收全部的结果集数据，然后抛弃其中的大部分数据。最简单有效的解决方法就是在这样的查询后面加上LIMIT。\"]},\"384\":{\"h\":\"多表关联时返回全部列\",\"t\":[\"如果想查询所有在电影Academy Dinosaur中出现的演员，不应该按下面的写法编写查询：\",\"SELECT * FROM sakila.actor INNER JOIN sakila.film_actor USING(actor_id) INNER JOIN sakila.film USING(film_id) WHERE sakila.film.title = 'Academy Dinosaur'; \",\"这将返回这三表的全部数据列，正确的方式应该像下面这样只取需要的列：\",\"SELECT sakila.actor.* FROM sakila.actor...; \"]},\"385\":{\"h\":\"总是取出全部列\",\"t\":[\"每次看到select *的时候都需要用怀疑的眼光审视，是不是真的需要返回全部的数据？很可能不是必须的。取出全部列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的I/O、内存和CPU的消耗，有时候还能避免某些列被修改带来的问题。\",\"不过，查询返回超过需要的数据也不总是坏事，它可以提高相同代码片段的复用性，如果应用程序使用某种缓存机制，或者有其他考虑，获取超过需要的数据也可能有其好处，但不能忘记这样做的代价是什么。\"]},\"386\":{\"h\":\"重复查询相同的数据\",\"t\":[\"如果不加以小心，很容易出现这样的错误——不断地重复执行相同的查询，然后每次都返回完全相同的数据。例如，在用户评论的地方需要查询用户头像的URL，那么用户多次评论的时候，可能就会反复查询这个数据。比较好的方案是，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样性能显然会更好。\"]},\"387\":{\"h\":\"扫描额外的记录\",\"t\":[\"在确定查询只返回需要的数据以后，接下来应该看看查询为了返回结果是否扫描了过多的数据。对于MySQL，最简单的衡量查询开销的三个指标如下：\",\"响应时间\",\"扫描的行数\",\"返回的行数\",\"没有哪个指标能够完美地衡量查询的开销，但它们大致反映了MySQL在内部执行查询时需要访问多少数据，并可以大概推算出查询运行的时间。这三个指标都会记录到MySQL的慢日志中，所以，检查慢日志记录是找出扫描行数过多的查询的好办法。\"]},\"388\":{\"h\":\"响应时间\",\"t\":[\"响应时间是两个部分之和：服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正地执行查询的时间——可能是等I/O操作完成，也可能是等待行锁，等等。遗憾的是，我们无法把响应时间细分到上面这些部分，除非有什么办法能够逐个测量上面这些消耗，不过很难做到。一般常见和重要的是等待是I/O和锁等待，但是实际情况更加复杂。\",\"所以在不同类型的应用压力下，响应时间并没有什么一致的规律或者公示。诸如存储引擎的锁（表锁、行锁）、高并发资源竞争、硬件响应等诸多因素都会影响响应时间。所以，响应时间既可能是一个问题的结果也可能是一个问题的原因，不同案例的情况不同。\",\"当看到一个查询请求的响应时间的时候，应该使用“快速上限估计”法来估算这个时间是否是一个合理的值。“快速上限估计”法概括地说，了解这个查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机I/O，再用其乘以在具体硬件下一次I/O的消耗时间，最后把这些消耗都加起来，就可以获得一个大概参考值来判断当前响应时间是不是一个合理的值。\"]},\"389\":{\"h\":\"扫描的行数和返回的行数\",\"t\":[\"分析查询时，查看该查询扫描的行数是非常有帮助的。这在一定程度上能够说明该查询找到需要的数据的效率高不高。\",\"对于找出那些“糟糕”的查询，这个指标可能还不够完美，因为并不是所有的行的访问代价都是相同的。较短的性的访问速度更快，内存中的行也比磁盘中的行的访问速度要快得多。\",\"理想情况下，扫描的行数和返回的行数应该是相同的。但实际情况中这种“美事”并不多。例如在做一个关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在1:1和10:1之间，不过有时候这个值也可能非常大。\"]},\"390\":{\"h\":\"扫描的行数和访问类型\",\"t\":[\"在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySQL有好几种访问方式可以查找并返回一行结果。有一些访问方式可能需要扫描很多行才能返回一行结果，也有些访问方式可能无需扫描就能返回结果。\",\"在explain语句中的type列反映了访问类型。访问类型有很多中，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。这里列的这些，速度从慢到快，扫描的行数也从小到大。如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引。索引让MySQL以最高效、扫描行数最少的方式找到需要的记录。\",\"例如，我们在示例数据库Sakila中的一个查询案例：\",\"SELECT * FROM sakila.film_actor WHERE film_id = 1; \",\"这个查询将返回10行数据，从explain的结果可以看到，MySQL在索引idx_fk_film_id上使用了ref访问类型来执行查询：\",\"EXPLAIN SELECT * FROM sakila.film actor WHERE film id = 1\\\\G **************************** 1. roW *************************** id: 1 select_type: SIMPLE table: film_actor type: ref possible_keys: idx_fk_film_id key: idx_fk_film_id key_len: 2 ref: const rows: 10 Extra: \",\"explain的结果也显示MySQL预估需要访问10行数据。换言之，查询优化器认为这种访问类型可以高效地完成查询。如果没有合适的索引MySQL就不得不使用一种更糟糕的访问类型。如果我们删除对应的索引再来运行这个查询：\",\" ALTER TABLE sakila.film_actor DROP FOREIGN KEY fk_film_actor_film; ALTER TABLE sakila.film_actor DROP KEY idx_fk_film_id; EXPLAIN SELECT * FROM sakila.film_actor WHERE film_id = 1\\\\G *************************** 1. row ********************* id: 1 select_type: SIMPLE table: film_actor type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 5073 Extra: Using where \",\"正如我们预测的，访问类型变成了一个全表扫描（ALL），现在MySQL预估需要扫描5073条记录来完成这个查询。这里的“Using Where”表示MySQL将通过WHERE条件来筛选存储引擎返回的记录。\",\"一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：\",\"在索引中使用WHERE条件来过滤不匹配的记录。这时存储引擎层完成的\",\"使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无需再回表查询记录\",\"从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤\",\"上面的这个例子说明了好的索引多么重要。好的索引可以让查询使用合适的访问类型，尽可能地只扫描需要的数据行。但也不是说增加索引就能让扫描的行数等于返回的行数。例如下面使用聚合函数COUNT（）的查询：\",\"SELECT actor_id, COUNT (*) FROM sakila.film_actor GROUP BY actor_id; \",\"这个查询需要读取几千行数据，但是仅返回200行结果。没有什么索引能够让这样的查询减少需要扫描的行数。\",\"不幸的是，MySQL不会告诉我们生成结果实际上需要扫描多少行数据，而只会告诉我们生成结果时一共扫描了多少行数据。扫描的行数中的大部分都很可能是被WHERE条件过滤掉的，对最终的结果集没有并没有贡献。在上面的例子中，我们删除索引后，看到MySQL需要扫描多少行和实际需要使用的行数需要先去理解这个查询背后的逻辑和思想。\",\"如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧进行优化：\",\"使用索引覆盖扫描，把所有需要的列都放到索引中，这样存储引擎无需回表获取对应行就可以返回结果了\",\"改变库表结构，例如使用单独的汇总表\",\"重写这个复杂的查询，让MySQL优化器能够以更优化的方式去执行这个查询\"]},\"391\":{\"h\":\"重构查询\"},\"392\":{\"h\":\"复杂查询 or 简单查询\",\"t\":[\"设计查询的时候一个需要考虑的重要问题时，是否需要将一个复杂的查询分成多个简单的查询。在传统的实现中，总是强调需要数据库层完成尽可能多的工作，这样做的逻辑在于以前总是认为网络通信、查询解析和优化是一件代价很高的事情。\",\"但是这样的想法对于MySQL来说并不适用，MySQL从设计上连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效。现代的网络速度比以前要快很多，无论是带宽还是延迟。在某些版本的MySQL上，即使在一个通用服务器上，也能够运行每秒超过10万的查询，即使是一个千兆网卡也能轻松满足每秒超过2000次的查询，所以运行多个小查询现在已经不是大问题了。\",\"MySQL内部每秒能够扫描内存中上百万行的数据，相比之下，MySQL响应数据给客户端就慢得多了。在其他条件都相同的时候，使用尽可能少的查询当然是更好的。但是有时候时候，将一个大查询分解为多个小查询是很有必要的。\"]},\"393\":{\"h\":\"切分查询\",\"t\":[\"有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。\",\"删除旧的数据就是一个很好的例子。定期地清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。将一个大的DELETE语句切分成多个较小的查询可以尽可能小地影响MySQL性能，同时还可以减少MySQL复制的延迟。例如，我们需要每个月运行一次下面的查询：\",\"DELETE FROM messages WHERE created < DATE_SUB(NOW(), INTERVAL 3 MONTH); \",\"那么可以用类似下面的方法来完成相同的工作：\",\"rows affected = 0 do { rows_affected = do_query( \\\"DELETE FROM messages WHERE created < DATE_SUB(NOW(),INTERVAL 3 MONTH). LIMIT 10000\\\" ) } while rows_affected > 0 \",\"一次删除一万行数据一般来说时一个比较高效而且对服务器影响也最小的做法（如果是事务型引擎，很多时候小事务能够更高效）。同时，需要注意的是，如果每次删除数据后，都暂停一会儿再做下一次删除，这样也可以将服务器上原本一次性的压力分散到一个很长的时间段中，就可以大大降低对服务器的影响，还可以大大减少删除时锁的持有时间。\"]},\"394\":{\"h\":\"分解关联查询\",\"t\":[\"很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，例如，下面这个查询：\",\"SELECT * FROM tag JOIN tag_post ON tag_post.tag_id = tag.id JOIN post ON tag_post.post_id = post.id WHERE tag.tag = 'mysql'; \",\"可以分解成下面这些查询来代替：\",\"SELECT * FROM tag WHERE tag = 'mysql'; SELECT * FROM tag_post WHERE tag_id = 1234; SELECT * FROM post WHERE post.id in (123,456,567,9098,8904); \",\"使用分解关联查询的优势如下：\",\"让缓存的效率更高。许多应用程序可以方便地缓存单表查询对应的结果对象。例如，上面查询中的tag已经被缓存了，那么应用就可以跳过第一个查询。再例如，应用中已经缓存了ID为123、567、9098的内容，那么第三个查询的IN（）中就可以少几个ID。另外，对MySQL的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了\",\"将查询分解后，执行单个查询可以减少锁的竞争\",\"在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展\",\"查询本身效率也可能会有所提升。在这个例子中，使用IN（）代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联要更高效\",\"可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构可能会减少网络和内存的消耗\",\"更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。某些场景哈希关联的效率要高很多\",\"在很多场景下，通过重构查询将关联当到应用程序中将会更加高效，这样的场景有很多，比如：当应用能够方便地缓存单个查询结果的时候，当可以将数据分布到不同的MySQL服务器上的时候，当能够使用IN（）的方式来代替关联查询的时候，当查询中使用同一个数据表的时候。\"]},\"395\":{\"h\":\"count（*）优化\",\"t\":[\"在实际的开发中，经常可能需要计算一个表中（或部分）的行数，通常可以使用select count(*) from t，但随着系统中记录数的不断增多，这条语句会执行得越来越慢。\"]},\"396\":{\"h\":\"count(*)的实现\",\"t\":[\"实际上，在不同的MySQL引擎中，count(*)有不同的实现方式：\",\"MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数（如果没有where条件），效率很高\",\"InnoDB引擎在执行count（*）的时候，需要把数据一行一行地从引擎里面读出来后，累积计数，显然，这种方式地效率很低\",\"那为什么InnoDB不跟MyISAM一样，也把数字存起来呢？这是因为即使在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的，这里，我们以一个算count（*）的例子来说明，假设表t中现在有10000条记录，并且有三个用户并行的会话：\",\"会话A先启动事务并查询一次表的总行数\",\"会话B启动事务，插入一行后记录后，查询表的总行数\",\"会话c先启动一个单独的语句，插入一行记录后，查询表的总行数\",\"这里我们假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。\",\"可以看到，在最后的同一个时刻，三个会话A、B、C会同时查询表t的总行数，但拿到的结果却不同，这和InnoDB的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是MVCC来实现的，每一行记录都要判断自己是否对这个会话可见，因此对于count（*）请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。\",\"不过，InnoDB对这个语句也做个一定程度的优化，InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于count(*)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的，因此，MySQL优化器会找到最小的那棵树来遍历，在保证逻辑正确的前题下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。\",\"也许你想到show table status命令，这个命令的输出结果也有一个TABLE_ROWS用于显示这个表当前有多少行，并且这个命令执行的速度较快，遗憾的是，TABLE_ROWS是通过采样估算的来的，因此只是一个估算值，官方文档显示误差可能达到40%到50%，因此，也无法使用它来进行统计。\",\"那么如果有一个页面经常要显示交易系统的操作记录总数，到底应该怎么办呢？答案是，只能自己计数，接下来，我们将会讨论自己计数的方法，以及每种方法优缺点。\"]},\"397\":{\"h\":\"使用缓存系统保存计数\",\"t\":[\"对常见的做法就是使用缓存，可以使用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。这种方式的缺点就在于，缓存系统可能会丢失更新。Redis的数据不能永久地留在内存中，所以需要找一个地方把这个值定期地持久化存储起来，但即使这样，仍然可能丢失更新，如果刚刚在数据表中插入了一行，Redis中保存的值也加了1，然后Redis异常重启了，重启后需要从存储Redis数据的地方把这个值读回来，而刚刚加1的这个计数操作却丢失了。\",\"实际上，将计数保存在缓存系统中的方式，还不只是丢失更新的问题，即使Redis正常工作，这个值还是逻辑上不精确的。\"]},\"398\":{\"h\":\"在数据库中保存计数\"},\"399\":{\"h\":\"不同count的用法\",\"t\":[\"count（）是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加，最后返回累计值，所以count（*）、count（主键id）和count（1）都表示返回满足条件的结果集的总行数，而count（字段）,则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。\",\"对于count（主键id）来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层，server层拿到id后，判断是不可能为空的，就按行累加；对于count（1）来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。相比较而言，count（1）执行得要比count（主键id）快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。\",\"虽然主键id一定不为空，但InnoDB并没有做相关的优化。\",\"对于count（字段）来说：\",\"如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加\",\"如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断以下，不是null才累加\",\"这些不同的方式按照效率排序：count（字段）< count（主键id） < count（1） ≈ count（*）。\"]},\"400\":{\"h\":\"join语句的优化\",\"t\":[\"在实际生产中，关于join语句使用的问题，一般会几种在以下两类：\",\"DBA不让使用join，使用join有什么问题？\",\"如果有两个大小不同的表做join，应该用哪个表做驱动表？\",\"为了便于量化分析，我们创建两个表t1和t2：\",\"CREATE TABLE `t2` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`) ) ENGINE = InnoDB; drop procedure idata; delimiter;; create procedure idata() begin declare i int; set i = 1; while(i <= 1000) do insert into t2 values (i, i, i); set i = i + 1; end while; end;; delimiter; call idata(); create table t1 like t2; insert into t1 (select * from t2 where id <= 100); \",\"这两张表都有一个主键索引id和一个索引a，字段b上无索引。存储过程idata()往表t2里面插入了1000行数据，在表t1插入的是100行数据。\"]},\"401\":{\"h\":\"Index Nested-Loop Join\",\"t\":[\"select * from t1 straight_join t2 on (t1.a=t2.a); \",\"如果直接使用join语句，MySQL优化器可能会选择表t1或t2作为驱动表，这样会影响我们分析SQL语句的执行过程，使用straight_join可以让MySQL使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去join，在这个语句里，t1是驱动表，t2是被驱动表，explain的结果如下：\",\"可以看到，在这条语句里，被驱动表t2的字段上有索引，join过程用上了这个索引，因此这个语句的执行流程如下：\",\"从表t1中读入一行数据R\",\"从数据行R中，取出字段到表t2里去查找\",\"取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分\",\"重复执行步骤1到3，直到表t1的末尾循环结束\",\"这个过程是现遍历表t1，然后根据从表t1中取出的每行数据中a的值，去表t2查找满足条件的记录，在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“Index Nested-Loop Join”，简称NLJ。对应的流程图如下：\",\"在这个流程里：\",\"对驱动表t1做了全表扫描，这个过程需要扫描100行\",\"对于每一行R，根据a字段去表t2查找，走的是树搜索过程，由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也就是总共扫描100行\",\"所以，整个执行流程，总扫描行数是200\",\"假设不使用join，那我们就只能用单表查询，要实现上述相同的需求，使用单表查询需要：\",\"执行select * from t1，查出表t1的所有数据，这里有100行\",\"循环遍历这100行数据 \",\"从每一行R取出字段a的值$R.a\",\"执行select * from where a = $R.a\",\"把返回的结果和R构成结果集的一行\",\"可以看到，在这个查询过程，也就是扫描了200行，但是总共执行了101条语句，比直接join多了100次交互，除此之外，客户端还要自己拼接SQL语句和结果，那么显然，这么做不如直接join。\",\"在这个join语句的执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索，假设被驱动表的行数是M，每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引，每次搜索一棵树近似复杂度是以2为底的M的对数，记为log2M，所以在被驱动表上查一行的时间复杂度是2*log2M。假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次，因此整个执行过程，时间复杂度近似是N+N*2log2M，显然，N对扫描行数影响更大，因此应该让小表做驱动表。\",\"通过以上的分析，我们可以得到两个结论：\",\"使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好\",\"如果使用join语句的话，需要让小表做驱动表\"]},\"402\":{\"h\":\"Simple Nested-Loop Join\",\"t\":[\"现在，我们将SQL语句修改如下：\",\"select * from t1 straight_join t2 on (t1.a = t2.b); \",\"由于表t2的字段上没有索引，因此在join的时候，每次到t2做一次匹配，就要做一次全表扫描，这种算法就被称为“Simple Nested-Loop Join”。虽然也可以得到正确的结果，但是这个SQL请求需要扫描表t2多达100次，总共扫描100*1000=10万行。如果t1和t2都是10万行的表，就需要扫描100亿行，不难想象，这个语句的执行将会非常耗时。MySQL并没有使用Simple Nested-Loop Join算法，而是使用了另一个叫做“Block Nested-Loop Join”的算法，简称BNL。\"]},\"403\":{\"h\":\"Block Nested-Loop Join\",\"t\":[\"BNL的执行流程如下：\",\"将表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整个表t1放入了内存\",\"扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回\",\"流程图如下：\",\"explain的结果如下：\",\"可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做判断的次数是100*1000=10万次。\",\"从时间复杂度上来看，Simple Nested-Loop Join和Block Nested-Loop Join算法是相同的，但是BNL算法的这10万次判断是内存操作，速度会快上很多，性能也更好。\",\"那么在这种情况下，应该使用哪个表做驱动表呢？假设小表的行数是N，大表的行数是M，那么在这个算法里：\",\"两个表都做一次全表扫描，所以总的扫描行数是M+N\",\"内存中的判断次数是M*N\",\"可以看到，调换M和N的位置，并不会影响这个算法的时间复杂度，因此这个时候选择大表或者小表做驱动表，执行耗时都是一样的。\",\"这个算法会将t1表的内容放入到join_buffer中，join_buffer的大小是由参数join_buffer_size设定的，默认值是256k。如果放不下表t1的所有数据的话，就会分段放置。现在我们将join_buffer_size改小，再执行：\",\"select * from t1 straight_join t2 on (t1.a=t2.b); \",\"此时，执行流程就变成了：\",\"扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步\",\"扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回\",\"清空join_buffer\",\"继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第二步\",\"执行的流程图如下：\",\"图中的步骤4和5表示清空join_buffer复用，这也体现出了这个算法名字中“Block”的由来，表示“分块去join”。由于表t1被分成了两次放入join_buffer中，导致表t2会被扫描两次，虽然分成两次放入join_buffer，但是判断等值条件的次数还是不变的，依然是（88+12）*1000=10万次。\",\"在这个算法里，驱动表的数据行数是N，需要分k段才能完成算法流程，其中K=λN（λ∈（0,1）），被驱动表的数据行数是M：\",\"扫描行数是N+λ*N*M\",\"内存判断是N*M次\",\"显然，内存判断次数是不受选择哪个表作为驱动表影响的，而考虑到扫描行数，在M和N大小确定的情况下，N小一些，整个算式的结果会更小，所以在这种算法下，应该让小表当驱动表。\",\"在N+λ*N*M中，还有一个关键的参数λ，可以看到λ越小越好，由定义，我们可以知道λ=K/N，那么显然，在N确定的情况下，K越小越好，也就是说，当join_buffer_size越大的时候，分成的段数也就越少，对被驱动表的全表扫描次数就越少。\",\"以上结论告诉我们，如果join语句很慢，可以尝试将join_buffer_size改大。\",\"我们回到本小节一开始的两个问题：\",\"能不能使用join语句？\",\"如果使用join语句，应该选择大表做驱动表还是选择小表做驱动表？\",\"对于第一个问题：\",\"如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，就可以用上被驱动表上的索引，其实是没问题的\",\"如果使用Block Nested-Loop Join算法，扫描行数就会过多，尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源，所以这种join尽量不要使用\",\"因此，在判断要不要使用join语句时，就是看explain的结果里面，extra字段里面有没有出现“Block Nested Loop”字样。\",\"对于第二个问题：\",\"如果是Index Nested-Loop Join算法，应该选择小表做驱动表\",\"如果是Block Nested-Loop Join算法： \",\"在join_buffer_size足够大的时候，是一样的\",\"在join_buffer_size不够大的时候（这种情况更为常见），应该选择小表做驱动表\",\"所以，这个问题的结论是，应该选择小表做驱动表。不过需要格外说明的是，在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。\"]},\"404\":{\"h\":\"Multi-Range Read 优化\",\"t\":[\"NLJ和BNL都还有优化的空间，为了说明这一点，创建表t1和t2：\",\"create table t1( id int primary key, a int, b int, index(a) ); create table t2 like t1; drop procedure idata; delimiter;; create procedure idata() begin declare i int; set i = 1; while(i <= 1000) do insert into t1 values (i, 1001 - i, i); set i = i + 1; end while; set i = 1; while(i <= 1000000) do insert into t2 values (i, i, i); set i = i + 1; end while; end;; delimiter; call idata(); \",\"在表t1里，插入了1000行数据，每一行的a=1001-id的值。也就是说，表t1中字段a是逆序的，同时，在表t2中插入了100万行数据。\",\"Multi-Range Read优化的主要目的是尽量使用顺序读盘。回表是指，InnoDB在普通索引a上查到主键id的值后，再根据一个个主键id的值到主键索引上去查整行数据的过程。\",\"select * from t1 where a >= 1 and a <= 100; \",\"由于主键索引是一颗B+树，在这棵树上，每次只能根据一个主键id查到一行数据。因此，回表肯定是一行行搜索主键索引的，基本流程如图所示：\",\"如果随着a的值递增顺序查询的话，id的值就变成随机的，那么就会出现随机访问，性能相对较差。虽然还是按行查，但是可以通过调整查询的顺序，还是可以加速查询的效率，因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。这就是MRR优化的设计思路，此时语句的执行流程就变成了这样：\",\"根据索引a，定位到满足条件的记录，将id值放入read_rnd_buffer中\",\"将read_rnd_buffer中的id进行递增排序\",\"排序后的id数组，依次到主键id索引中查记录，并作为结果返回\",\"这里，read_rnd_buffer的大小是由read_rnd_buffer参数控制的。如果步骤1中，read_rnd_buffer放满了，就会执行步骤2和3，然后清空read_rnd_buffer，之后继续找索引a的下个记录，并继续循环。\",\"如果想要稳定地使用MRR优化的话，需要设置`set optimizer_switch=\\\"mrr_cost_based=off\\\"`，因为目前的优化器会更倾向于不使用MRR，通过这个设置就可以保证一定可以使用MRR优化。\",\"explain的结果：\",\"从explain的结果来看，Extra字段多了Using MRR，表示的是用上了MRR优化，而且，由于我们在read_md_buffer中按照id做了排序，所以最后得到的结果集也是按照主键id递增顺序的，与没有适用MRR的结果集顺序刚好相反。\",\"总而言之，MRR能够提升性能的核心在于，这条查询语句在索引a上是一个范围查询（也就是说，这是一个多指查询），可以得到足够多的主键id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。\"]},\"405\":{\"h\":\"Batched Key Access\",\"t\":[\"MySQL在5.6版本后开始引入了Batched Key Acess（BKA）算法，这个算法其实就是对NLJ算法的优化。首先我们来回顾一下NLJ算法的执行流程：\",\"NLJ算法执行的逻辑是：从驱动表t1，一行行地取出a的值，再到被驱动表t2去做join。也就是说，对于表t2来说，每次都是匹配一个值，这时，MRR的优势就用不上了。那怎么才能一次性地多穿些值给表t2呢？从表t1里一次性地多拿些出来，放入到join_buffer，然后一起传给表t2，这就是BKA算法，简而言之，使用join_buffer优化的NLJ算法就是BKA算法，算法的流程图如下：\",\"图中，join_buffer中放入的数据是R1~R100，表示的是只会取查询需要的字段，如果join_buffer放不下 R1~R100 的所有数据，就会把这100行数据分成多段执行上图的流程。BKA算法并没有默认开启，如果要使用BKA优化算法的话，需要在执行SQL语句之前，先设置：\",\"set optimizer_switch = 'mrr=on,mrr_cost_based=off,batched_key_access=on'; \",\"其中，前两个参数的作用是启用MRR，这么做的原因是，BKA算法的优化要依赖于MRR。\"]},\"406\":{\"h\":\"BNL算法的性能问题\",\"t\":[\"BNL可能会对被驱动表做多次扫描，如果这个被驱动表是一个大的冷数据表，除了会导致IO压力大以外，还会对系统有什么影响呢？\",\"由于InnoDB对Buffer Pool的LRU算法做了优化，即：第一次从磁盘读入内存的数据页，会先放在old区域。如果1秒之后这个数据也不再被访问了，就不会移动到LRU链表头部，这样对Buffer Pool的命中率影响就不大。但是，如果这个冷表很大，就会出现另外一种情况：业务正常访问的数据页，没有机会进入young区域。\",\"由于这个优化机制的存在，一个正常访问的数据页，要进入young区域，需要隔1秒后再次被访问到。但是，由于我们的join语句在循环读磁盘和淘汰内存页，进入old区域的数据页，很可能在1秒内就被淘汰了。这样，就会导致MySQL实例的Buffer Pool在这段时间内，young区域的数据页没有被合理地淘汰，也就是说，这两种情况都会影响Buffer Pool的正常运作。\",\"BNL算法对系统的影响主要包括三个方面：\",\"可能会多次扫描被驱动表，占用磁盘IO资源\",\"判断join条件需要执行M*N次对比（M、N分别是两张表的行数），如果是大表就会占用非常多的CPU资源\",\"可能会导致Buffer Pool的热数据被淘汰，影响内存命中率\",\"因此，我们在执行语句之前，需要通过理论分析和查看explain结果的方式，确认是否使用BNL算法。如果确认优化器会使用BNL算法，就需要做优化。优化的常见做法是，给被驱动表的join字段加上索引，把BNL算法转成BKA算法。\"]},\"407\":{\"h\":\"BNL转BKA\",\"t\":[\"大多数情况下，我们直接在被驱动表上建立索引，就可以直接转为BKA算法了，但是也有一些并不适合在被驱动表上建索引的情况，比如下面这个语句：\",\"select * from t1 join t2 on (t1.b = t2.b) where t2.b >= 1 and t2.b <= 2000; \",\"此时，如果BNL算法来join的话，语句的执行流程如下：\",\"把表t1的所有字段取出来，存入join_buffer中，这个表只有1000行，join_buffer_size默认值是256k，可以完全存入\",\"扫描表t2，取出每一行数据跟join_buffer中的数据进行对比： \",\"如果不满足t1.b = t2.b\",\"如果满足t1.b = t2.b，再判断其它条件，也就是是否满足t2.b∈[1,2000]，如果是，就作为结果集的一部分返回，否则跳过\",\"explain的结果如下：\",\"可以发现，判断join是否满足的时候，会扫描表t2的每一行，判断条件的次数是1000*100万=10亿次，这个判断的工作量很大。但是经过where条件过滤后，需要参与join的实际上只有2000行数据。如果这条语句是一个低频的SQL语句，那么再为这个语句在表t2的字段b上创建一个索引就很浪费了。\",\"在表t2的字段b上创建索引会浪费资源，但是不创建索引的话需要判断10亿次，这个时候就可以考虑使用临时表，使用临时表的步骤如下：\",\"将表t2中满足条件的数据放在临时表tmp_t中\",\"为了让join使用BKA算法，给临时表tmp_t的字段b加上索引\",\"让表t1和tmp_t做join操作\",\"create temporary table temp_t(id int primary key, a int, b int, index(b))engine=innodb; insert into temp_t select * from t2 where b>=1 and b<=2000; select * from t1 join temp_t on (t1.b=temp_t.b); \",\"执行的流程如下：\",\"执行insert语句构造temp_t表并插入数据的过程中，对表t2做了全表扫描，这里扫描的行数是100万\",\"之后的join语句，扫描表t1，这里的扫描行数是1000，join比较过程中，做了1000次带索引的查询，相比于优化前的join语句需要做10亿次条件判断来说，这个优化效果还是很明显的\",\"执行的效果如下：\",\"总体来看，不论是在原表上加索引，还是用有索引的临时表，我们的思路都是让join语句能够用上被驱动表上的索引，来触发BKA算法，提升查询性能。\"]},\"408\":{\"h\":\"hash join\",\"t\":[\"在之前的例子中，之所以要有计算10亿次的操作，是因为在join_buffer里面维护的是一个无序数组，而不是一个哈希表，如果能够将无序数组替换为哈希表，这样只需要100万次的哈希查找，整条语句的执行速度就可以加快，但MySQL的优化器和执行器并不支持哈希join。不过，我们可以按照这个思路，在业务端实现：\",\"select * from t1;，取得表t1的全部1000行数据，在业务端存入到哈希这种数据结构的实现，比如HashMap\",\"select * from t2 where b >= 1 and b <= 2000;，获取表t2中满足条件的2000行数据\",\"把这2000行数据，一行行地取到业务端，到哈希表中寻找匹配的数据，满足匹配的条件的这行数据，就作为结果集的一行\"]},\"409\":{\"h\":\"MySQL中的临时表\",\"t\":[\"在join语句优化的章节中，我们使用了临时表：\",\"create temporary table temp_t like t1; alter table temp_t add index(b); insert into temp_t select * from t2 where b >= 1 and b <= 2000; select * from t1 join temp_t on (t1.b = temp_t.b); \",\"与临时表相类似的还有内存表，实际上这两个概念是完全不同的。\",\"内存表，指的是使用Memory引擎的表，建表语法是create table ...engine = memory。这种表的数据都保存在内存里，系统重启的时候就会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”，从其它特征上看，它就是一个正常表\",\"而临时表，可以使用各种引擎类型（包括Memory引擎），如果使用InnDB引擎或者MyISAM引擎的临时表，写数据的时候是写到磁盘上的\"]},\"410\":{\"h\":\"临时表的特性\",\"t\":[\"以下列操作序列为例：\",\"可以看到，临时表有以下几个特点：\",\"建表语法是create temporary table..\",\"一个临时表只能被创建它的session访问，对其它线程不可见，所以，图中session A创建的临时表t，对于session B就是不可见的\",\"临时表可以与普通表同名\",\"session A内有同名的临时表和普通表的时候，show create语句，以及增删改查语句访问的是临时表\",\"show tables命令不显示临时表\",\"由于临时表只能被创建它的session访问，所以在这个session结束的时候，会自动删除临时表，也正是由于这个特性，临时表特别适合join优化的场景，理由如下：\",\"不同session的临时表是可以重名的，如果有多个session同时执行join优化，无需担心表名重复导致建表失败的问题\",\"不需要担心数据删除问题。如果使用普通表，在执行流程过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作\"]},\"411\":{\"h\":\"临时表的应用\",\"t\":[\"由于不同担心线程之间的重名冲突，临时表经常会被用在复杂查询优化过程中，其中，分库分表系统的跨库查询就是一个典型的使用场景。\",\"一般分库分表的场景，就是要把一个逻辑上的大表分散到不同的数据库实例上。比如，将一个大表ht，按照字段f，拆分成1024个分表，然后分布到32个数据库实例上，如下图所示：\",\"一般情况下，这种分库分表系统都有一个中间层proxy，不过，也有一些方案会让客户端直接连接数据，也就是没有proxy这一层。在这个架构中，分区key的选择是以“减少跨库和跨表查询”为依据的。如果大部分的语句都会包含f的等值条件，那么就要用f做分区键。这样，在proxy这一层解析完SQL语句以后，就能确定将这条语句到哪个分表做查询。\",\"以下面的查询语句为例：\",\"select v from ht where f=N; \",\"这时，我们就可以通过分表规则（比如N%1024）来确认需要的数据被放在哪个分表上，这种语句只需要访问一个分表。但是，如果这个表上还有另外一个索引k，并且查询语句如下：\",\"select v from ht where k >= M order by t_modified desc limit 100; \",\"这个时候，由于查询条件里面没有用到分区字段f，只能到所有的分区中去查找满足条件的所有行，然后统一进行排序，这种情况下，有两种比较常用的思路。\",\"第一种思路是在proxy层的进程代码中实现排序。这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算，不过，这个方案的缺点也很明显：\",\"需要的开发工作量比较大。如果仅需要order by还比较简单，但是，如果涉及到复杂的操作，比如group by，甚至join这样的操作，对中间层的开发能力要求比较高\",\"对proxy端的压力比较大，尤其是很容易出现内存不够用和CPU瓶颈的问题\",\"第二种思路是，将各个分库拿到的数据，汇总到一个MySQL实例的一个表中，然后在这个汇总实例上做逻辑操作，以上这条查询语句的执行流程如下：\",\"在汇总库上创建一个临时表temp_ht，表中包含三个字段v、t、t_modified\",\"在各个分库上执行select v,k,t_modified from ht_x where k >= M order by t_modified desc limit 100;\",\"将分库执行的结果插入到temp_ht表中\",\"执行select v from temp_ht order by t_modified desc limit 100;就可以得到结果\",\"第二种思路的示意图如下：\",\"实践中，由于每个分库的计算量都不饱和，所以会直接把临时表temp_ht放到32个分库中的某一个上。\"]},\"412\":{\"h\":\"重命名临时表\",\"t\":[\"上文我们总结临时表的特性，发现不同线程可以创建同名的临时表，那么这是怎么做到的呢？\",\"假设我们执行如下语句：\",\"create temporary table temp_t(id int primary key)engine=innodb; \",\"这个时候，MySQL要给这个InnoDB表创建一个frm文件保存表结构定义，还要有地方保存表数据，这个frm文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程id}_{线程id}_序列号”，可以使用select @@tmpdir命令，来显示实例的临时文件目录。\",\"关于临时表中数据的存放方式，在不同的MySQL版本中有着不同的处理方式：\",\"在5.6以及之前的版本里，MySQL会在临时文件目录下创建一个相同前缀、以.ibd为后缀的文件，用来存放数据文件\",\"而从5.7版本开始，MySQL引入了一个临时文件表空间，专门用来存放临时文件的数据，而无需再创建idb文件\",\"示例如下：\",\"这个进程的进程号是4d2，session A的线程id是4，session B的线程id是5，所以，session A和 session B创建的临时表，在磁盘上的文件不会重名。\",\"MySQL维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个table_def_key。\",\"一个普通表的table_def_key的值是由“库名+表名”得到的，所以如果要在同一个库下创建两个同名的临时表，创建第二表的过程中就会发现table_def_key已经存在了\",\"而对于临时表，table_def_key在“库名+表名”的基础上，又加入了“server_id + thread_id”，也就是说，session A和session B创建的两个临时表t1，它们的table_def_key不同，磁盘文件名也不同，因此可以并存。\",\"在实现上，每个线程都维护了自己的临时表链表。这样，每次session内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表，在sessoin结束的时候，对链表里的每个临时表，执行“DROP TEMPARY TABLE + 表名”操作。\"]},\"413\":{\"h\":\"临时表和主备复制\",\"t\":[\"临时表只能在线程内自己访问，但在执行DROP TEMPARY TABLE命令的时候，也会将其记录到binlog中，写入到binlog中的目的是为了主备复制。为了说明这一点，假设我们执行如下语句：\",\"create table t_normal(id int primary key, c int)engine=innodb;/*Q1*/ create temporary table temp_t like t_normal;/*Q2*/ insert into temp_t values(1,1);/*Q3*/ insert into t_normal select * from temp_t;/*Q4*/ \",\"如果关于临时表的操作都不记录，那么在备库就只有create table t_normal和insert into t_normal select * from temp_t这两个语句的binlog日志，备库在执行到insert into t_normal的时候，就会报错“表temp_t不存在”。\",\"实际上可以通过设置参数binlog_format=row,那么与临时表有关的语句，就不会记录到binlog里。当参数设置为binlog_format=statment/mixedde的时候，binlog才会记录临时表的操作。\",\"当binlog是row格式的时候，创建临时表的语句会自动在备库执行，主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，需要在主库上再写一个DROP TEMPARY TABLE传给备库执行，这就是这个命令会什么会出现在binlog的原因。\",\"通常情况下，MySQL在记录binlog的时候，都会将SQL语句原封不动的记录下来，但是如果执行drop table_normal，此时binlog会被记录成：\",\"DROP TABLE `t_normal` /* generated by server */ \",\"这是因为，drop table是可以一次删除多个表的。在以上的例子中，设置binlog_format=row，如果主库上执行“drop table t_normal, temp_t”这个命令，那么binlog中就只能记录：\",\"DROP TABLE `t_normal` /* generated by server */ \",\"因为备库上并没有表tmp_t，将这个命令重写后再传到备库执行，才不会备库同步线程停止。所以，drop table命令记录binlog的时候，就必须对语句做改写， “/* generated by server */” 说明了这是一个被服务端改写过的命令。\",\"主库上不同的线程创建同名的临时表是没有关系的，但是传到备库执行时如何处理的呢？下面的序列中实例S是M的备库：\",\"主库M上的两个session创建了同名的临时表t1，这两个create temporary table t1语句都会被传到备库S上，但是，备库的应用日志线程是共用的，也就是说要在应用线程里面先后执行这个create语句两次。（即使开了多线程复制，也可能被分配到从库的同一个worker中执行），如果直接执行，那么显然可能会出现冲突。MySQL在记录binlog的时候，会把主库执行的这个语句的线程id写到binlog中，这样，在备库的应用线程就能够知道执行每个语句的主库线程id，并利用这个线程id来构造临时表的table_def_key，具体流程下：\",\"session A的临时表t1，在备库的table_def_key就是：库名+t1+“M的serverid” + “session A的thread_id”\",\"session B的临时表t1，在备库的table_def_key就是：库名+t1+“M的serverid” + “session B的thread_id”\",\"由于table_def_key不同，所以这两个表在备库的应用线程里不会冲突。\"]},\"414\":{\"h\":\"使用临时表优化查询\",\"t\":[\"union的执行就会使用临时表来完成，为了便于量化分析，我用下面的表 t1 来举例。\",\"create table t1( id int primary key, a int, b int, index(a) ); delimiter;; create procedure idata() begin declare i int; set i = 1; while(i <= 1000) do insert into t1 values (i, i, i); set i = i + 1; end while; end;; delimiter; call idata(); \",\"然后，我们执行如下语句：\",\"(select 1000 as f) union (select id from t1 order by id desc limit 2); \",\"这条语句用到了union，它的语义是，取这两个子查询结果的并集，下面是这个语句explain的结果：\",\"可以看到：\",\"第二行的key=PRIMARY，说明第二个子句用到了索引id\",\"第三行的Extra字段，表示在对子查询的结果做UNION的时候，使用了临时表（Using temporary）。\",\"这个语句的执行流程如下：\",\"创建一个内存临时表，这个临时表只有一个整型字段f，并且f是主键字段\",\"执行第一个子查询，得到1000这个值，并存入临时表中\",\"执行第二个子查询： \",\"拿到第一行id=1000，试图插入临时表中，但由于1000这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行\",\"取到第二行id=999，插入临时表成功\",\"从临时表按行取数据，返回结果，并删除临时表，结果中包含两行数据分别是1000和999\",\"这个过程的示意图如下：\",\"可以看到，这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键id的唯一性约束，实现了union的语义。如果将这个语句中的union改成union all的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端，因此也就不需要临时表了。\",\"可以看到，第二行的Extra字段显示的是Using index，表示只使用了覆盖索引，没有用临时表了。\"]},\"415\":{\"h\":\"group by语句的优化\"},\"416\":{\"h\":\"group by执行流程\",\"t\":[\"还是使用表t1执行如下SQL语句：\",\"select id % 10 as m, count(*) as c from t1 group by m; \",\"这个语句的逻辑是把表t1里的数据，按照id%10进行分组统计，并按照m的结果排序后输出，它的explain结果如下：\",\"在Extra字段里面，我们可以看到：\",\"Using index，表示这个语句使用了覆盖索引，选择了索引a，不需要回表\",\"Using temporary，表示使用了临时表\",\"Using filesort，表示需要排序\",\"这个语句的执行流程如下：\",\"创建内存临时表，表里有两个字段m和c，主键是m\",\"扫描表t1的索引a，依次取出叶子节点上id的值，计算id%10的结果，记为x \",\"如果临时表中没有主键为x的行，就插入一条记录（x，1）\",\"如果表中有主键为x的行，就将x这一行的c值加1\",\"遍历完成后，再根据字段m做排序，得到结果集返回给客户端\",\"流程图如下：\",\"其中，虚线框内表示临时表的排序过程：\",\"这条语句的执行结果如下：\",\"如果并不需要对结果进行排序，那么可以在SQL语句末尾增加order by null：\",\"select id % 10 as m, count(*) as c from t1 group by m order by null; \",\"这样就跳过了最后排序的阶段，直接从临时表中取数据返回，返回的结果如图所示：\",\"由于表t1中的id的值是从1开始的，因此返回的结果集中的第一行是id=1，扫描到id=10的时候才插入m=0这一行，因此结果集里最后一行才是m=0。\",\"这个例子中由于临时表只有10行，内存可以放得下，因此全程只使用了内存临时表。但是，内存临时表的大小是有限制的，参数tmp_table_size就是控制这个内存大小的，默认是16M。此时，如果执行如下语句：\",\"set tmp_table_size = 1024; select id % 100 as m, count(*) as c from t1 group by m order by null limit 10; \",\"把内存临时表的大小限制为最大1024字节，并把语句改为id%100，这样返回结果里有100行数据。但是，这时的内存临时表大小不够存下这100行数据，也就是说，执行过程中会发现内存临时表大小不够存下这100行数据，也就是说，执行过程中会发现内存临时表大小达到了上限（1024字节）。这个时候，MySQL就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是InnoDB，这时返回的结果如下：\",\"如果这个表t1的数据量很大，很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间。\"]},\"417\":{\"h\":\"使用索引优化group by语句\",\"t\":[\"可以看到，不论是使用内存临时表还是磁盘临时表，group by逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的，如果表的数据量比较大，上面这个group by语句执行起来就会很慢。\",\"在优化group by问题之前，我们得清楚，为什么执行group by语句需要临时表，group by的语义逻辑是统计不同的值出现的个数，但是，由于每一行的id%100的结果是无序的，所以，我们需要一个临时表，来记录并统计结果。那么，如果扫描过程中可以保证出现的数据是有序的，那么group by语句就可以不再需要临时表，假设有如下数据结构：\",\"可以看到，如果可以确保输入的数据是有序的，那么计算group by的时候，就只需要从左到右，顺序扫描，依次累加，也就是下面的这个过程：\",\"当碰到第一个1的时候，已经知道累积了X个0，结果集里的第一行就是（0，x）\",\"当碰到第一个2的时候，已经知道类及了Y个1，结果集里的第一行就是（1，Y）\",\"按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到group by的结果，不需要临时表，也不需要再额外的排序。在MySQL5.7支持了generated cloumn机制，用来实现列数据的关联更新，可以使用如下方法创建一个列z，然后在z列上创建一个索引（如果是MySQL5.6及之前的版本，可以创建普通列和索引，来解决这个问题）。\",\"alter table t1 add column z int generated always as(id % 100), add index(z); \",\"这样，索引z上的数据就是类似上图中的有序数据了，此时，上面的group by语句就可以改成：\",\"select z, count(*) as c from t1 group by z; \",\"优化后的group by语句的explain结果，如下图所示：\",\"可以看到这个语句的执行不再需要临时表，也不需要排序了。\"]},\"418\":{\"h\":\"直接排序优化group by语句\",\"t\":[\"实际上，并不是所有场景中可以通过加索引来完成group by的逻辑，如果碰到不适合创建索引的场景，还是一定要进行排序的操作。无论数据量大或小的group by语句都要先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表，我们可以在group by语句中加入SQL_BIG_RESULT这个提示（hint），就可以告诉优化器 ，这个语句涉及的数据量很大，直接使用磁盘临时表，MySQL会直接使用数组来存储这些数据，此时\",\"select SQL_BIG_RESULT id % 100 as m, count(*) as c from t1 group by m; \",\"执行流程就变成了：\",\"初始化sort_buffer，确定放入一个整型字段，记为m\",\"扫描表t1的索引a，依次取出里面的id的值，将id%100的值存入sort_buffer中\",\"扫描完成后，对sort_buffer的字段m做排序（如果sort_buffer的内存不够用，就会利用磁盘临时文件辅助排序）\",\"排序完成后，就得到了一个有序数组\",\"根据有序数组，得到数组里面的不同值，以及每个值得出现次数，执行的流程图如下：\",\"explain的结果如下：\",\"从Extra字段可以看到，这个语句的执行没有再使用临时表，而是直接使用了排序算法。\",\"这里我们对MySQL使用内部临时表做如下总结：\",\"如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果\",\"join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构\",\"如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表（之前的例子中，union还需要用到唯一索引约束，group by还需要用到另外一个字段来存累积计数）\"]},\"419\":{\"h\":\"order by rand() 优化\",\"t\":[\"假设有一个英语学习APP，用户每次访问首页的时候，都会随机滚动显示三个单词，也就是根据每个用户级别有一个单词表，假设我们的表结构如下：\",\"CREATE TABLE `words` ( `id` int(11) NOT NULL AUTO_INCREMENT, `word` varchar(64) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = InnoDB; delimiter;; create procedure idata() begin declare i int; set i = 0; while i < 10000 do insert into words(word) values ( concat( char( 97 +(i div 1000) ), char( 97 +(i % 1000 div 100) ), char( 97 +(i % 100 div 10) ), char( 97 +(i % 10) ) ) ); set i = i + 1; end while; end;; delimiter; call idata(); \",\"实现这个需求最简单的实现方式，不难想到：\",\"select word from words order by rand() limit 3; \",\"但是随着单词表的变大，这个语句的执行速度越来越慢，那么该如何优化呢？\"]},\"420\":{\"h\":\"内存临时表\",\"t\":[\"上述SQL的explain的结果如下：\",\"Extra字段显示Using temporary，表示的是需要使用临时表，Using filesort表示的是需要执行排序操作，也就是说这个SQL需要临时表，并且需要在临时表上排序。\",\"对于InnoDB表来说，执行全字段排序会会减少磁盘访问，因此会优先选择全字段排序，而对于临时内存表的排序来说，回表过程只是简单根据数据行的位置，直接访问内存得到数据，并不会导致过多的访问磁盘，因此，MySQL这时会选择rowid排序。\",\"这条语句的执行流程如下：\",\"创建一个临时表，这个临时表使用的是memory引擎，表中有两个字段，第一个字段是double类型，为了后面描述方便，记为字段R，第二个字段是varchar（64）类型，记为字段W，并且，这个表没有建索引\",\"从words表中，按主键顺序取出所有word值，对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并且把这个随机小数和word分别存入临时表的R和W字段中，到此，扫描的行数是10000\",\"接下来按照R排序\",\"初始化sort_buffer，sort_buffer中有两个字段，一个是double类型，另一个是整型\",\"从内存临时表中一行一行地取出R值和位置信息，分别存入sort_buffer中的两个字段里，这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，变成了20000\",\"在sort_buffer中根据R的值进行排序（这个过程没有涉及到表操作，所以不会增加扫描行数）\",\"排序完成后，取出前三个结果的位置信息，依次到临时表中取出word值，返回给客户端，这个过程中，访问了表的三行数据，总扫描行数变成了20003\",\"接下来，我们通过慢查询日志（show log）来验证扫描行数是否是20003：\",\"# Query_time: 0.900376 Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003 SET timestamp=1541402277; select word from words order by rand() limit 3; \",\"其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行。完整的排序的执行流程图如下：\",\"图中的pos指的是位置信息。在InnoDB中，如果创建的表没有主键，获取把一个表的主键删掉了，那么InnoDB会自己生成一个长度为6字节的rowid来作为主键，这也就是排序模式里面，rowid名字的来历，实际上它表示的就是每个引擎用来唯一标识数据行的信息。\",\"对于有主键的InnoDB表来说，这个rowid就是主键ID\",\"对于没有主键的InnoDB表磊说，这个rowid就是由系统生成的\",\"Memory引擎不是索引组织表，这个例子里面，可以认为它就是一个数组，因为rowid其实就是数组的下标\"]},\"421\":{\"h\":\"磁盘临时表\",\"t\":[\"上文我们提到，order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法，那么是不是所有的临时表都是内存表呢？其实并不是，tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。\",\"磁盘临时表使用的引擎默认是InnoDB，是由参数internal_tmp_disk_storage_engine来控制的，因此当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表排序的过程。\",\"为了复现这个过程，我们将tmp_table_size设置成1024，把sort_buffer_size设置成32768，把max_length_for_sort_data设置成16。\",\"set tmp_table_size=1024; set sort_buffer_size=32768; set max_length_for_sort_data=16; /* 打开 optimizer_trace ，只对本线程有效 */ SET optimizer_trace='enabled=on'; /* 执行语句 */ select word from words order by rand() limit 3; /* 查看 OPTIMIZER_TRACE 输出 */ SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\\\\G \",\"因为将max_length_for_sort_data设置成16，小于word字段的长度定义，所以我们看到sort_mode里面显式的是rowid排序，这个是符合预期的，参与排序的是随机值R字段和rowid段组成的行。\",\"R字段存放的随机值是8个字段，rowid是6个字节，数据总行数是10000，加起来是14000字节，超过了sort_buffer_size定义的32768字节，但是这里的number_of_tmp_files的值却是0，这里因为这里MySQL并没有使用归并排序算法，而是采用了优先队列排序算法。实际上，我们只需要取R值最小的3个rowid，但是，如果使用归并排序算法的话，虽然最终也能得到前3个值，但是这个算法会将1000行数据都排好序，然后再取前3条记录，如果使用归并算法就会浪费非常多的计算量。而优先队列算法，就可以精确地只得到三个最小值，执行流程如下：\",\"对于这10000个准备排序的（R，rowid），先取前三行，构造成一个堆\",\"取下一个行（R'，rowid'），跟当前堆里面最大地R比较，如果R'小于R，把这个（R，rowid）从堆中去掉，换成（R'，rowid'）\",\"重复第二步，直到第10000个（R'，rowid'）完成比较\",\"优先队列排序地示意图如下：\",\"图中模拟了6个（R，rowid）行，通过优先队列排序找到最小的三个R值的行的过程。整个排序过程中，为了最快地拿到当前堆的最大值，总是保持最大值在堆顶，因此这是一个最大堆。\",\"OPTIMIZER_TRACE结果中，filesort_priority_queue_optimization这个部分的chosen=true，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的number_of_tmp_files是0。\",\"select city,name,age from t where city=' 杭州 ' order by name limit 1000; \",\"排序的过程结束后，在我们构造的堆里面，就是这个10000行里面R值最小的三行。然后，依次把它们的rowid取出来，去临时表里面拿到word字段，就得到了最终的结果。\"]},\"422\":{\"h\":\"随机排序法\",\"t\":[\"清楚了order by rand（）的执行过程，那么该如何优化呢？\",\"我们先把问题简化以下，如果只随机选择1个word值，可以按照如下思路实现：\",\"取得这个表的主键id最大值M和最小值N\",\"用随机函数生成一个最大值和最小值之间的数X=（M-N）*rand（）+N\",\"取不小于X的第一个ID的行\",\"我们将这个算法暂时称作随机算法1，对应的执行语句的序列：\",\"select max(id),min(id) into @M,@N from t; set @X= floor((@M-@N+1)*rand() + @N); select * from t where id >= @X limit 1; \",\"这个方法的效率很高，因为取max（id）和min（id）都是不需要扫描索引的，而第三步的select也可以用索引快速定位，可以认为就只扫描了3行。但实际上，这个算法并不严格满足题目的随机要求，因为ID中间可能由空洞，因此选择不同行的概率不一样，不是真正的随机。假设4个id分别是1、2、4、5，如果按照这个算法，那么取到id=4的这一行的概率是取到其它行的概率的两倍。\",\"所以，为了得到严格随机的结果，可以按照如下流程：\",\"取得整个表的行数，并记为C\",\"取得Y=floor(C*rand())，floor函数在这里的作用，就是取整数部分\",\"再用limit Y,1取得一行\",\"我们将这个算法暂时称作随机算法2，对应的执行语句的序列：\",\"select count(*) into @C from t; set @Y = floor(@C * rand()); set @sql = concat(\\\"select * from t limit \\\", @Y, \\\",1\\\"); prepare stmt from @sql; execute stmt; DEALLOCATE prepare stmt; \",\"由于limit后面的参数不能直接跟变量，所以这里使用了prepare+execute的方法，实际使用时，可以将拼接SQL语句的方法写在应用程序中。\",\"MySQL处理limit Y,1的做法是按照顺序一个一个地读出来，丢掉前Y个，然后把下一个记录作为返回结果，因此这一步需要扫描Y+1行，再加上，第一个扫描地C行，总共需要扫描C+Y+1行，虽然解决了算法1里明显的概率不均匀的问题，但是执行代价要比随机算法1的代价要高，不过于order by rand（）相比，执行代价还是小很多。\",\"到这里，我们就可以按照随机算法2的思路，优化本篇一开始的语句：\",\"取得整个表的行数，记为C\",\"根据相同的随机方法得到Y1、Y2、Y3\",\"再执行三个limit Y,1语句得到三行数据\",\"完整的执行序列如下：\",\"select count(*) into @C from t; set @Y1 = floor(@C * rand()); set @Y2 = floor(@C * rand()); set @Y3 = floor(@C * rand()); select * from t limit @Y1 ， 1 ； // 在应用代码里面取 Y1 、 Y2 、 Y3 值，拼出 SQL 后执行 select * from t limit @Y2 ， 1 ； select * from t limit @Y3 ， 1 ； \"]},\"423\":{\"h\":\"分区表\",\"t\":[\"在有些公司的数据库规范中，不允许使用分区表，那么分区表有什么问题呢？\"]},\"424\":{\"h\":\"分区表简介\",\"t\":[\"为了说明分区表的组织形式，我们先创建表t：\",\"CREATE TABLE `t` ( `ftime` datetime NOT NULL, `c` int(11) DEFAULT NULL, KEY (`ftime`) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 PARTITION BY RANGE ( YEAR(ftime) ) ( PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB, PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB, PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB, PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB ); insert into t values('2017-4-1',1),('2018-4-1',1); \",\"此时表中有两行记录，按照定义的分区的规则，这两行记录分别落在p_2018和p_2019这两个分区上，可以看到，这个表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件，也就是说：\",\"对于引擎层来说，这是4个表\",\"对于Server层来说，这是1个表\",\"接下来我们通过观察分区表加间隙锁的例子来说明对于InnoDB来说，这是4个表：\",\"我们初始化表t的时候，只插入了两行数据，ftime的值分别是，'2017-4-1'和'2018-4-1'，session A的select语句对索引ftime上这两个记录之间的间隙加了锁。如果是一个普通表的话，那么T1时刻，在表t的ftime索引，间隙和加锁状态应该如下图：\",\"也就是说，'2017-4-1'和'2018-4-1'这两个记录之间的间隙是会被锁住的，那么session B的两条插入语句应该都要进入锁等待状态。但是从上面的实验效果可以看出，session B的第一个insert语句是可以执行成功，因为，对于引擎来说，p_2018和p_2019是两个不同的表，也就是说2017-4-1的下一个记录并不是2018-4-1，而是p_2018分区的supermum，所以在T1时刻，在表t的ftime索引上，间隙和加锁的状态其实是这样的：\",\"由于分区表的规则，session A的select语句其实只操作了分区p_2018，因此加锁范围就是图中深绿色的部分，所以，session B要写入一行ftime是2018-2-1的时候是可以成功的，而要写入2017-12-1这个记录，就要等session A的间隙锁。\",\"此时show engine innodb status的部分结果如下：\",\"接下来我们看看在MyISAM引擎中的情况，首先使用alter table t engine将表t改成MyISAM表，然后执行如下序列：\",\"在session A里面，使用sleep(100)将这条语句的执行时间设置为100秒，由于MyISAM引擎只支持表锁，所以这条update语句会锁住整个表t上的读，但是我们看到的结果是，session B的第一条查询语句是可以正常执行的，第二条语句才进入锁等待状态，这正是因为MyISAM的表锁是在引擎层实现的，session A加的表锁，其实是锁在分区p_2018上。因此，只会堵住在这个分区上执行的查询，落到其它分区的查询时不受影响的。\",\"此时看起来使用分区表并没有什么不妥，通常我们使用分区表的一个重要原因就是单表过大，如果不使用分区表的话，就要使用手动分表的方式，那么手动分表和分区表有什么区别？比如，按照年份来划分，我们就分别创建普通表t_2017、t_2018、t_2019等等。手工分表的逻辑，也是找到需要更新的所有分表，然后依次执行更新，在性能上，这个分区表并没有实质的差别。另外，分区表和手工分表，一个是由server层来决定使用哪个分区，一个是由应用层代码决定使用哪个分表，因此，从引擎层来看，这两种方式也是没有差别的。\",\"实际上，问题的关键在于server层，分区表最重要的问题在于：打开表的行为。\"]},\"425\":{\"h\":\"分区策略\",\"t\":[\"每当第一次访问一个分区表的时候，MySQL需要把所有的分区都访问一遍。一个典型的报错情况是这样的：如果一个分区表的分区很多，比如超过了1000个，而MySQL启动的时候，open_files_limit参数使用的默认值是1024，那么就会在访问这个表的时候，由于需要打开所有的文件，导致打开表文件的个数超过了上限而报错。\",\"下图是创建的一个包含了很多分区的表t_myisam，执行一条插入语句后报错的情况。：\",\"可以看到，这条insert语句，明显只需要访问一个分区，但语句却无法执行。实际上使用InnoDB引擎并不会出现这个问题，MyISAM分区表使用的分区策略，我们称为通用分区策略（generic partitioning），每次访问分区都由server层控制，通用分区策略，是MySQL一开始支持分区表的时候就存在的代码，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题。\",\"从MySQL5.7.9开始，InnoDB引擎引入了本地分区策略（native partitioning），这个策略是在InnoDB内部自己管理打开分区的行为。从MySQL5.7.17开始，将MyISAM分区表标记为Deprecated，从MySQL8.0版本开始，就不允许创建MyISAM分区表了，只允许创建已经实现了本地分区策略的引擎。目前来看，只有InnoDB和NDB这两个引擎支持了本地分区策略。\",\"如果从server层看的话，一个分区表就只是一个表。下面我们通过例子来说明，下面两张图分别是这个例子的操作序列和执行结果图。\",\"可以看到，虽然session B只需要操作p_2017这个分区，但是由于session A持有整个表t的MDL锁，就导致了session B的alter语句被堵住，实际上，分区表在做DDL的时候，影响会更大，但是如果是在普通的分表上操作的时候并不会出现这样的问题。\",\"我们可以对分区表做以下总结：\",\"MySQL在第一次打开分区表的时候，需要访问所有的分区\",\"在server层，认为这是同一张表，因此所有分区共用同一个MDL锁\",\"在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必要的分区\",\"其中“必要的分区”是根据SQL语句中的where条件，结合分区规则来实现的。比如，上面的例子中where ftime='2018-4-1'，根据分区规则year函数算出来的值是2018，那么就会落在p_2019这个分区，但是如果这个where条件改成where ftime>='2018-4-1'，虽然查询结果相同，但是这个时候根据where条件，就要访问p_2019和P_others这两个分区。如果查询语句的where条件中没有分区key，那么就只能访问所有分区了，不过即使是使用业务分表的方式，没有分区的key也需要访问所有的分区表。\"]},\"426\":{\"h\":\"分区表的应用场景\",\"t\":[\"分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区别的业务代码更简洁，另外，分区表可以很方便的清理历史数据。如\",\"如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求，这个时候，按照时间分区的分区表，就可以直接通过alter table t drop partition...这个语法删掉分区，从而删掉过期的历史数据，这个语句的操作时直接删除分区文件，效果跟drop普通表类似，与使用delete语句删除数据相比，优势是速度快、对系统影响小。\",\"分区表在使用的时候，有两个绕不开的问题：一个是第一次访问的时候需要访问所有分区，另一个是共用MDL锁，对于分区表的使用有以下需要注意的点：\",\"分区并不是越细越好，实际上，单表或者单分区的数据一千万行，只要没有也别大的索引，对于现在的硬件能力来说都已经是小表了\",\"分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时再把下一年度的12个新分区创建上即可，对于没有数据的历史分区，要及时drop掉\",\"至于分区表的其它问题，比如查询需要跨多个分区取数据，查询性能就会比较慢，基本上就不是分区表本身的问题，而是数据量的问题或者说时使用方式的问题了。\"]},\"427\":{\"h\":\"慢查询日志\"},\"428\":{\"h\":\"基本介绍\",\"t\":[\"慢查询日志是什么？\",\"MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。\",\"long_query_time的默认值为10，意思是运行10秒以上的语句。\",\"由慢查询日志来查看哪些SQL超出了我们的最大忍耐时间值，比如一条SQL执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒钟的SQL，结合之前explain进行全面分析。\",\"特别说明\",\"**默认情况下，MySQL数据库没有开启慢查询日志，**需要我们手动来设置这个参数。\",\"当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。\",\"查看慢查询日志是否开以及如何开启\",\"查看慢查询日志是否开启：SHOW VARIABLES LIKE '%slow_query_log%';。\",\"开启慢查询日志：SET GLOBAL slow_query_log = 1;。使用该方法开启MySQL的慢查询日志只对当前数据库生效，如果MySQL重启后会失效。\",\"# 1、查看慢查询日志是否开启 mysql> SHOW VARIABLES LIKE '%slow_query_log%'; +---------------------+--------------------------------------+ | Variable_name | Value | +---------------------+--------------------------------------+ | slow_query_log | OFF | | slow_query_log_file | /var/lib/mysql/1dcb5644392c-slow.log | +---------------------+--------------------------------------+ 2 rows in set (0.01 sec) # 2、开启慢查询日志 mysql> SET GLOBAL slow_query_log = 1; Query OK, 0 rows affected (0.00 sec) \",\"如果要使慢查询日志永久开启，需要修改my.cnf文件，在[mysqld]下增加修改参数。\",\"# my.cnf [mysqld] # 1.这个是开启慢查询。注意ON需要大写 slow_query_log=ON # 2.这个是存储慢查询的日志文件。这个文件不存在的话，需要自己创建 slow_query_log_file=/var/lib/mysql/slow.log \",\"开启了慢查询日志后，什么样的SQL才会被记录到慢查询日志里面呢？\",\"这个是由参数long_query_time控制的，默认情况下long_query_time的值为10秒。\",\"MySQL中查看long_query_time的时间：SHOW VARIABLES LIKE 'long_query_time%';。\",\"# 查看long_query_time 默认是10秒 # 只有SQL的执行时间>10才会被记录 mysql> SHOW VARIABLES LIKE 'long_query_time%'; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | long_query_time | 10.000000 | +-----------------+-----------+ 1 row in set (0.00 sec) \",\"修改long_query_time的时间，需要在my.cnf修改配置文件\",\"[mysqld] # 这个是设置慢查询的时间，我设置的为1秒 long_query_time=1 \",\"查新慢查询日志的总记录条数：SHOW GLOBAL STATUS LIKE '%Slow_queries%';。\",\"mysql> SHOW GLOBAL STATUS LIKE '%Slow_queries%'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | Slow_queries | 3 | +---------------+-------+ 1 row in set (0.00 sec) \"]},\"429\":{\"h\":\"日志分析工具\",\"t\":[\"日志分析工具mysqldumpslow：在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。\",\"# 1、mysqldumpslow --help 来查看mysqldumpslow的帮助信息 root@1dcb5644392c:/usr/bin# mysqldumpslow --help Usage: mysqldumpslow [ OPTS... ] [ LOGS... ] Parse and summarize the MySQL slow query log. Options are --verbose verbose --debug debug --help write this text to standard output -v verbose -d debug -s ORDER what to sort by (al, at, ar, c, l, r, t), 'at' is default # 按照何种方式排序 al: average lock time # 平均锁定时间 ar: average rows sent # 平均返回记录数 at: average query time # 平均查询时间 c: count # 访问次数 l: lock time # 锁定时间 r: rows sent # 返回记录 t: query time # 查询时间 -r reverse the sort order (largest last instead of first) -t NUM just show the top n queries # 返回前面多少条记录 -a don't abstract all numbers to N and strings to 'S' -n NUM abstract numbers with at least n digits within names -g PATTERN grep: only consider stmts that include this string -h HOSTNAME hostname of db server for *-slow.log filename (can be wildcard), default is '*', i.e. match all -i NAME name of server instance (if using mysql.server startup script) -l don't subtract lock time from total time # 2、 案例 # 2.1、得到返回记录集最多的10个SQL mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log # 2.2、得到访问次数最多的10个SQL mysqldumpslow -s c -t 10 /var/lib/mysql/slow.log # 2.3、得到按照时间排序的前10条里面含有左连接的查询语句 mysqldumpslow -s t -t 10 -g \\\"left join\\\" /var/lib/mysql/slow.log # 2.4、另外建议使用这些命令时结合|和more使用，否则出现爆屏的情况 mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log | more \"]},\"430\":{\"h\":\"分析慢SQL的步骤\",\"t\":[\"分析：\",\"1、观察，至少跑1天，看看生产的慢SQL情况。\",\"2、开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来。\",\"3、explain + 慢SQL分析。\",\"4、show Profile。\",\"5、运维经理 OR DBA，进行MySQL数据库服务器的参数调优。\",\"总结（大纲）：\",\"1、慢查询的开启并捕获。\",\"2、explain + 慢SQL分析。\",\"3、show Profile查询SQL在MySQL数据库中的执行细节和生命周期情况。\",\"4、MySQL数据库服务器的参数调优。\"]},\"431\":{\"h\":\"Show Profile\",\"t\":[\"Show Profile是什么？\",\"Show Profile：MySQL提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量。默认情况下，参数处于关闭状态，并保存最近15次的运行结果。\",\"分析步骤\",\"1、是否支持，看看当前的MySQL版本是否支持。\",\"# 查看Show Profile功能是否开启 mysql> SHOW VARIABLES LIKE 'profiling'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | profiling | OFF | +---------------+-------+ 1 row in set (0.00 sec) \",\"2、开启Show Profile功能，默认是关闭的，使用前需要开启。\",\"# 开启Show Profile功能 mysql> SET profiling=ON; Query OK, 0 rows affected, 1 warning (0.00 sec) \",\"3、运行SQL\",\"SELECT * FROM `emp` GROUP BY `id`%10 LIMIT 150000; SELECT * FROM `emp` GROUP BY `id`%20 ORDER BY 5; \",\"4、查看结果，执行SHOW PROFILES;\",\"Duration：持续时间。\",\"mysql> SHOW PROFILES; +----------+------------+---------------------------------------------------+ | Query_ID | Duration | Query | +----------+------------+---------------------------------------------------+ | 1 | 0.00156100 | SHOW VARIABLES LIKE 'profiling' | | 2 | 0.56296725 | SELECT * FROM `emp` GROUP BY `id`%10 LIMIT 150000 | | 3 | 0.52105825 | SELECT * FROM `emp` GROUP BY `id`%10 LIMIT 150000 | | 4 | 0.51279775 | SELECT * FROM `emp` GROUP BY `id`%20 ORDER BY 5 | +----------+------------+---------------------------------------------------+ 4 rows in set, 1 warning (0.00 sec) \",\"5、诊断SQL，SHOW PROFILE cpu,block io FOR QUERY Query_ID;\",\"# 这里的3是第四步中的Query_ID。 # 可以在SHOW PROFILE中看到一条SQL中完整的生命周期。 mysql> SHOW PROFILE cpu,block io FOR QUERY 3; +----------------------+----------+----------+------------+--------------+---------------+ | Status | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out | +----------------------+----------+----------+------------+--------------+---------------+ | starting | 0.000097 | 0.000090 | 0.000002 | 0 | 0 | | checking permissions | 0.000010 | 0.000009 | 0.000000 | 0 | 0 | | Opening tables | 0.000039 | 0.000058 | 0.000000 | 0 | 0 | | init | 0.000046 | 0.000046 | 0.000000 | 0 | 0 | | System lock | 0.000011 | 0.000000 | 0.000000 | 0 | 0 | | optimizing | 0.000005 | 0.000000 | 0.000000 | 0 | 0 | | statistics | 0.000023 | 0.000037 | 0.000000 | 0 | 0 | | preparing | 0.000014 | 0.000000 | 0.000000 | 0 | 0 | | Creating tmp table | 0.000041 | 0.000053 | 0.000000 | 0 | 0 | | Sorting result | 0.000005 | 0.000000 | 0.000000 | 0 | 0 | | executing | 0.000003 | 0.000000 | 0.000000 | 0 | 0 | | Sending data | 0.520620 | 0.516267 | 0.000000 | 0 | 0 | | Creating sort index | 0.000060 | 0.000051 | 0.000000 | 0 | 0 | | end | 0.000006 | 0.000000 | 0.000000 | 0 | 0 | | query end | 0.000011 | 0.000000 | 0.000000 | 0 | 0 | | removing tmp table | 0.000006 | 0.000000 | 0.000000 | 0 | 0 | | query end | 0.000004 | 0.000000 | 0.000000 | 0 | 0 | | closing tables | 0.000009 | 0.000000 | 0.000000 | 0 | 0 | | freeing items | 0.000032 | 0.000064 | 0.000000 | 0 | 0 | | cleaning up | 0.000019 | 0.000000 | 0.000000 | 0 | 0 | +----------------------+----------+----------+------------+--------------+---------------+ 20 rows in set, 1 warning (0.00 sec) \",\"Show Profile查询参数备注：\",\"ALL：显示所有的开销信息。\",\"BLOCK IO：显示块IO相关开销（通用）。\",\"CONTEXT SWITCHES：上下文切换相关开销。\",\"CPU：显示CPU相关开销信息（通用）。\",\"IPC：显示发送和接收相关开销信息。\",\"MEMORY：显示内存相关开销信息。\",\"PAGE FAULTS：显示页面错误相关开销信息。\",\"SOURCE：显示和Source_function。\",\"SWAPS：显示交换次数相关开销的信息。\",\"6、Show Profile查询列表，日常开发需要注意的结论：\",\"converting HEAP to MyISAM：查询结果太大，内存都不够用了，往磁盘上搬了。\",\"Creating tmp table：创建临时表（拷贝数据到临时表，用完再删除），非常耗费数据库性能。\",\"Copying to tmp table on disk：把内存中的临时表复制到磁盘，危险！！！\",\"locked：死锁。\"]},\"432\":{\"h\":\"事务隔离\",\"t\":[\"简单来说，事务就是要保证一组操作，要么全部成功，要么全部失败，事务具有ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）的特性。在MySQL中，事务支持是在引擎层实现的，但并不是所有的引擎都支持事务，比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。\"]},\"433\":{\"h\":\"隔离性和隔离级别\",\"t\":[\"当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。隔离级别越高，执行的效率就会越低，因此很多时候，都需要在二者之间寻找一个平衡点。\",\"SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable），它们的含义如下：\",\"读未提交是指，一个事务还没有提交时，它做的变更就能被别的事务看到\",\"读提交是指，一个事务提交之后，它做的变更才会被其它事务看到\",\"可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动的时候看到的数据是一致的。在可重复读的隔离级别下，未提交变更对其它事务也是不可见的\",\"串行化是指对同一行记录，“写”会加锁，“读”会“读锁”。当出现读写锁冲突的时候，后访问的事务必须等待前一个事务执行完成，才能继续执行\",\"下面我们通过实例来说明，假设数据表T中只有一列，其中一行的值为1：\",\"create table T(c int) engine = InnoDB; insert into T(c) values (1); \",\"下面是按照时间顺序执行两个事务的行为：\",\"我们来看下在不同的隔离级别下，事务A会查询到的V1、V2、V3的返回值分别是什么：\",\"若隔离级别是“读未提交”，则V1、V2、V3的值都是2。这时候事务B虽然还没有提交，但是结果已经被A看到了\",\"若隔离级别是“读提交”，则V1是1，V2的值是2，事务B的更新在提交后才能被A看到，所以V3的值也是2\",\"若隔离级别是“可重复读”，则V1、V2是1，V3是2，之所以V2还是1，是因为在这个隔离级别下，事务在执行期间看到的数据前后必须是一致的\",\"若隔离级别是“串行化”，则事务B执行“将1改成2”的时候，会被锁住，直到事务A提交之后，事务B才可以继续执行。所以，从A的角度来看，V1、V2的值是1，V3的值是2\",\"在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的，这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。\",\"在不同的隔离级别下，数据库的行为是有所不同的。Oracle数据库的默认隔离级别是“读提交”，MySQL的InnoDB默认隔离级别是“可重复读”。因此，对于一些从Oracle迁移到MySQL的应用，为了保证数据库隔离级别的一致，需要将隔离级别设置为“读提交”，将启动参数transaction-isolation的值设置为READ-COMMITTED，可以使用show variables like 'transaction_isolation';来查看当前的值。\",\"每一种隔离级别都有自己的使用场景，具体使用哪一种，需要根据业务情况来定。\"]},\"434\":{\"h\":\"事务隔离的实现\",\"t\":[\"那么事务隔离是怎么实现的呢？实际上，在MySQL中，每条记录在更新的时候都会同时记录一条回滚操作，记录上最新的值，通过回滚操作，都可以得到前一个状态的值。假设一个值从1被顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录：\",\"当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A要得到1，就必须将当前的值依次执行图中所有的回滚操作得到。\",\"回滚日志只有当没有事务需要用到这些回滚日志，也就是当系统里没有比这个回滚日志更早的read-view的时候，才会被删除，这也就是很多文章中建议不要使用长事务的原因之一。长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以在这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。在MySQL5.5及以前的版本，回滚日志是跟字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小，也许数据只有20GB，但是回滚段却有200GB。\",\"可以在information_schema库的innodb_trx这个表中，使用如下语句查询超过60s的长事务：\",\"select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started)) > 60; \"]},\"435\":{\"h\":\"事务的启动方式\",\"t\":[\"MySQL的事务启动方式有以下几种：\",\"显式启动事务语句：begin或start transaction;。配套的提交语句是commit，回滚语句是rollback\",\"set autocommit = 0;，这个命令会将这个线程的自动提交关掉，意味着如果只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务将持续存在直到主动执行commit或rollback语句，或者断开连接\",\"有些客户端框架会默认连接成功后先执行set autocommit = 0;，这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。因此，最好使用set autocommit = 1，通过显式语句的方式来启动事务，不过这样需要每次执行依次“begin”，如果不想每次都多“多一次交互”，那么可以使用commit work and chain语法。在autocommit为1的情况下，用begin显式启动事务，如果执行commit则提交事务，如果执行mmit work and chain，则是提交事务并自动启动下一个事务，这样既省去了再次执行begin语句的开销，又可以明确地直到每个语句是否处于事务中。\"]},\"436\":{\"h\":\"全局锁\",\"t\":[\"数据库锁的设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则，而锁就是用来实现这些访问规则的重要数据结构。根据加锁的范围，MySQL里面的锁大致可以分为全局锁、表级锁和行锁三类。\"]},\"437\":{\"h\":\"全局锁的特点\",\"t\":[\"顾名思义，全局锁就是对整个数据库实例加锁，MySQL提供了一个全局读锁的方法：Flush tables with read lock(FTWRL)。当需要让整个库处于只读状态的时候，可以使用这个命令，之后其它线程的更新（增删改）、数据定义语句（建表、修改表结构）和更新类事务的提交语句都会被阻塞。\",\"全局锁的典型使用场景是，做全库逻辑备份，也就是将整库的每个表都select出来存成文本。\"]},\"438\":{\"h\":\"全局锁对比\",\"t\":[\"MySQL自带的逻辑备份工具是mysqldump，当mysqldump使用参数-single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图，由于MVCC的支持，这个过程中数据是可以正常更新的。但并不是所有的存储引擎都支持一致性读的隔离级别，例如MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是取到最新的数据，那么就破坏了备份的一致性，这个时候，就只能使用FTWRL命令了，因此-single-transaction只适用于所有的表使用事务引擎的数据库，如果有的表使用了不支持事务的引擎，那么备份只能通过FTWRL方法，这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一。\",\"全库只读除了使用FTWRL，还可以使用set global readonly = true，不过如果要备份全库，还是应该使用FTWRL，原因有二：\",\"在有些系统中，readonly的值会被用来做其它逻辑，比如用来判断一个库是主库还是备库，因此，修改global变量的方式影响面更大\",\"在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一致保持readonly状态，这样会导致整库长时间处于不可写状态，风险较高\"]},\"439\":{\"h\":\"表级别的锁\",\"t\":[\"MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，简称MDL）。\"]},\"440\":{\"h\":\"表锁\",\"t\":[\"表锁的语法是lock tables ... read/write。与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意的是，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。\"]},\"441\":{\"h\":\"元数据锁\",\"t\":[\"另一类表级的锁是MDL（metadata lock）。MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。例如，一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构在做变更，删了一列，那么查询线程拿到的结果就与表结构对应不上了，这种情况就需要MDL。在MySQL5.5版本中引入了MDL，当对一个表做增删改查操作的时候，就会加上MDL读锁；当要对表结构做变更操作的时候，就会加上MDL写锁。\",\"读锁之间不互斥，因此可以有多个线程同时对一张表增删改查\",\"读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行\",\"给一个表加字段或者修改字段、添加索引，都需要扫描全表的数据，因此，操作不慎的话，就可能导致生产事故：\",\"session A先启动，这时候会对表t加上一个MDL读锁，由于session B需要的也是MDL读锁，因此可以正常执行。之后session C会被blocked，因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。之后所有在表上新申请MDL读锁的请求也会被session C阻塞，也就是说，所有对表的增删改查都需要先申请MDL读锁，都被锁住导致表完全不可读写。如果这个表上的查询语句频繁，而且客户端有重试机制，也就是超时后会再起一个新的session 再请求的话，这个库的线程很快就会爆满。\",\"事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。在给小表加字段的时候，首先要解决的是长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema库的innodb_trx表中，可以查询到当前执行中的事务，如果要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。但如果要变更的表是一个热点表，虽然数据量不大，但是请求很频繁，这个时候只kill掉可能未必管用了，因为新的请求马上就会到。\",\"因此，给小表添加字段比较合理的方案是，在alter table语句里面设定等待时间，如果在这个执行的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃，之后开发人员或者DBA再通过重试命令重复这个过程。MairaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAIT n这个语法。\",\"ALTER TABLE tbl_name NOWAIT add column ... ALTER TABLE tbl_name WAIT N add column ... \"]},\"442\":{\"h\":\"行锁\",\"t\":[\"行锁顾名思义，就是针对数据表中行记录的锁，比如事务A更新了一行，而这个时候，事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。在MySQL中有四种类型的行锁：\",\"LOCK_ORDINARY：也称为Next-Key Lock，锁一条记录及其间隙，这是RR隔离级别用的最多的锁\",\"LOCK_GAP：间隙锁，锁两个记录之间的GAP，防止记录插入\",\"LOCK_REC_NOT_GAP：只锁记录\",\"LOCK_INSERT_INTENSION：插入意向GAP锁，插入记录时使用，是LOCK_GAP的一种特例\"]},\"443\":{\"h\":\"两阶段锁\",\"t\":[\"为了更好的说明行锁，我们以下面的操作序列为例，假设id是表t的主键：\",\"这个例子中事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行，在这个过程中，事务A持有两个记录的行锁，都是在commit的时候才释放的，也就是说，在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放，这就是两阶段锁协议。基于这个协议，我们在使用事务的时候，如果事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁尽量完后放，接下来我们通过一个实例来说明这一点。\",\"假设要实现一个电影票在线交易业务，顾客A要在影院B购买电影票，这个业务需要涉及以下的操作：\",\"从顾客A账余额中扣除电影票价\",\"给影院B的账户余额增加这张电影票价\",\"记录一条交易日志\",\"也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录，为了保证交易的原子性，我们需要把这三个操作放在一个事务中。假设此时同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了，因为它们要更新同一个影院账户的余额，需要修改同一行数据。根据两阶段锁协议，无论怎样安排语句顺序，所有的操作需要行锁的都是在事务提交的时候才会释放，所以，应该把需要行锁的语句放在最后，这样可以最大程度减少事务之间的锁等待，提升并发度。\"]},\"444\":{\"h\":\"死锁和死锁检测\",\"t\":[\"当并发系统中不同线程出现循环资源以来，设计的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。\",\"这时候，事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：\",\"一种策略是，直接进入等待，直到超时，这个超时时间可以通过参数innodb_lock_wait_timeout来设置\",\"另一种策略是。发起死锁检测，发现死锁后，主动回滚锁链条的某一个事务，让其它事务得以继续执行，可以通过参数innodb_deadlock_detect=on来控制，默认开启\",\"在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其它线程才有可能继续执行。这对于在线服务来说，这个等待时间往往是无法接受的。但是，将这个时间的值设置的很小也不行，这样当出现死锁的时候，确实很快就可以解开，但是如果不是死锁，只是简单的锁等待也会释放，也会释放掉。所以，一般都会选择第二种策略，即主动死锁检测。\",\"主动死锁检测在发生死锁的时候，虽然能够快速发现并进行处理的，但是它也有额外的负担，每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。\",\"当所有事务都要更新同一行的场景时，每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O（n）的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作的时间复杂度就是百万量级的，虽然最终检测的结果是没有死锁，但是检测期间要消耗大量的CPU资源，因此，当并发量很大的时候，就会看到CPU利用率很高，但是每秒却执行不了几个事务。\",\"总而言之，死锁检测要耗费大量的CPU资源。那么，该如何解决由这种热点行更新导致的性能的问题呢？\",\"一种方法是，确保业务一定不会出现死锁，然后关掉死锁检测，但是这种操作本身带有一定的风险，因此业务设计的时候一般不会把死锁当做一个严重错误，一旦出现死锁，就可能会出现大量的超时\",\"另一种方法是控制并发度，根据上面的分析，死锁检测的时间复杂度与并发量正相关，如果可以控制并发量，那么就可以控制死锁检测的时间复杂度。需要注意的是，这个并发控制要做在数据库服务端，因为虽然每个客户端的并发量可能很小，但是汇总到数据库服务端以后，还是会很大。可以在中间件中实现，也可以在MySQL里面做（基本思路：对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作了）。\",\"最后一种方法是，可以考虑通过将一行改成逻辑上的多行来减少锁冲突。以影院的账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加，这样每次冲突概率变成原来的1/10，可以减少锁等待的个数，也减少了死锁检测的CPU消耗，需要注意的是，当一部分行记录变成0的时候，如果还要减少记录的值，需要特殊处理\"]},\"445\":{\"h\":\"间隙锁\"},\"446\":{\"h\":\"幻读\",\"t\":[\"为了说明幻读，我们初始化如下数据：\",\"CREATE TABLE `t` ( `id` INT (11) NOT NULL, `c` INT (11) DEFAULT NULL, `d` INT (11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`) ) ENGINE = INNODB; INSERT INTO t VALUES (0, 0, 0), (5, 5, 5), (10, 10, 10), (15, 15, 15), (20, 20, 20), (25, 25, 25); \",\"假设执行的场景序列如下：\",\"可以看到，session A里执行了三次查询，分别是Q1、Q2和Q3，具体的执行结果如下：\",\"Q1只返回id=5这一行\",\"在T2时刻，session B把id=0这一行的d值改成了5，因此T3时刻Q2查出来的是id=0和id=5这两行\",\"在T4时刻，session C又插入一行（1,1,5），因此T5时刻Q3查出来的是id=0、id=1和id=5的这三行\",\"其中，Q3读到id=1这一行的现象，被称为“幻读”。也就是说，幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行，关于幻读的两点说明：\",\"在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现\",\"上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读，幻读专指“新插入的行”\",\"因为这三个查询都是加了for update，都是当前读。而当前读的规则，就是要能读到所有已经提交的记录的最新值，并且，session B和session C两条语句，执行后就会提交，所以Q2和Q3就是应该看到这两个事务的操作效果，而且也看到了，这跟事务的可见性规则并不矛盾。\"]},\"447\":{\"h\":\"幻读的问题\",\"t\":[\"幻读会带来一些问题，假设时序图如下：\",\"session B的第二条语句update t set c = 5 where id = 0，语义是把id=0、d=5这一行的c的值，改成了5。由于在T1时刻，session A还只是给id=5这一行加了行锁，并没有给id=0这行加上锁。因此，session B在T2时刻，是可以执行这两条update语句的，这样，就破坏了session A里Q1语句要锁住所有d=5的行的加锁声明。session C也是相同的道理，对id=1这一行的修改，也是破坏了Q1的加锁声明。\",\"其次，还有数据一致性的问题，我们直到，锁的设计是为了保证数据的一致性，而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。为了说明这个问题，给session A在T1时刻再加上一个更新语句，即：update t set d = 100 where d = 5;，此时的序列图如下：\",\"update加锁的语义和select ... for update是一致的，所以这时候加上这条update语句也很合理。session A声明说“要给d=5的语句加上锁”，就是为了要更新数据，新加的这条update语句就是把它认为加上了锁的这一行的d的值修改成了100。\",\"执行完图中的语句之后，数据库中的情况：\",\"经过T1时刻，id=5这一行变成（5，5，100），当然这个结果最终是在T6时刻正式提交的\",\"经过T2时刻，id=0这一行变成（0，5，5）\",\"经过T4时刻，表里面多了一行（1，5，5）\",\"其它行跟这个执行序列无关，保持不变\",\"这样看起来，数据本身是没有问题的，binlog的内容如下：\",\"T2时刻，session B事务提交，写入了两条语句\",\"T4时刻，session C事务提交，写入了两条语句\",\"T6时刻，session A事务提交，写入了update t set d=100 where d=5这条语句\",\"汇总后如下：\",\"update t set d=5 where id=0; /*(0,0,5)*/ update t set c=5 where id=0; /*(0,5,5)*/ insert into t values(1,1,5); /*(1,1,5)*/ update t set c=5 where id=1; /*(1,5,5)*/ update t set d=100 where d=5;/* 所有 d=5 的行， d 改成 100*/ \",\"这个语句序列，不论是拿到备库去执行，还是以后用binlog克隆，这三行的结果，都变成了（0，5，100）、（1，5，100）和（5，5，100）。也就是说，id=0和id=1这两行，发生了数据不一致，经过分析不难发现，我们只给d=5这一行加了锁，假设我们给扫描过程中碰到的所有行都加上写锁，再观察执行效果：\",\"由于session A把所有的行都加上了写锁，所在session B在执行第一个update语句的时候就被锁住了，需要等到T6时刻session A提交以后，session B才能继续执行，这样对于id=0这一行，在数据库里的最终结果还是（0，5，5）。在binlog里面，执行的序列如下：\",\"insert into t values(1,1,5); /*(1,1,5)*/ update t set c=5 where id=1; /*(1,5,5)*/ update t set d=100 where d=5;/* 所有 d=5 的行， d 改成 100*/ update t set d=5 where id=0; /*(0,0,5)*/ update t set c=5 where id=0; /*(0,5,5)*/ \",\"可以看到，按照日志顺序执行，id=0这一行的最终结果也是（0，5，5）。所以，id=0这一行的问题解决了，但同时，id=1这一行，在数据库里面的结果是（1，5，5），而根据binlog的执行结果是（1，5，100），也就是说幻读的问题还是没有解决，那么为什么我们将所有的记录都已经上了锁，还是阻止不了id=1这一行的插入和更新呢？因为在T3时刻，我们在给所有行加锁的时候，id=1这一行还不存在，不存在也就加不上锁，也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录。\"]},\"448\":{\"h\":\"间隙锁\",\"t\":[\"产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此为了解决幻读问题，InnoDB引入了间隙锁（Gap Lock）来解决。顾名思义，间隙锁，锁的就是两个值之间的空隙，比如本节中的表t，初始化插入6个记录，就产生了7个间隙。\",\"这样。在执行select * from t where d = 5 for update;的时候，就不止是给数据库已有的6个记录加上了行锁，还同时加了7个间隙锁，这样就确保了无法再插入新的记录，也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空袭，也加上了间隙锁。\",\"虽然间隙锁也是一种锁，但是它和之前介绍过的锁都不太一样，它是加载数据行之间间隙上的，行锁的之间的冲突关系是“另外一个行锁”，但间隙锁不一样，跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作，间隙锁之间不存在冲突关系。\",\"这里的session B并不会被阻塞，因为表t中没有c=7这个记录，因此session A加的是间隙锁（5，10），而session B也是再这个间隙加的间隙锁，它们有共同的目标，即：保护这个间隙，不允许插入值，但，它们之间是不冲突的。\",\"间隙锁和行锁合称next-key lock，每个next-key lock是前后闭区间。也就是说，我们的表t初始以后，如果用select * from for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是(-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20,25]、(25,+supremum]。InnoDB给每个索引加上了一个不存在得最大值supremum，这样就都是前开后闭区间了。\"]},\"449\":{\"h\":\"防止数据丢失\"},\"450\":{\"h\":\"bin log的写入机制\",\"t\":[\"binlog的吸入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写入到binlog文件中。一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到binlog cache的保存问题，系统给binlog cache分配了一片内存，每个线程一个，参数binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。状态图如下：\",\"可以看到，每个线程有自己binlog cache，但是共用同一份binlog文件。\",\"图中的write，指的就是把日志写入到文件系统的page cache，并没有数据持久化到磁盘，所以速度比较快\",\"图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的IOPS\",\"write和fsync的时机，是由参数sync_binlog控制的：\",\"sync_binlog=0的时候，表示每次提交事务都只write，不fsync\",\"sync_binlog=1的时候，表示每次提交事务都会执行fsync\",\"sync_binlog=N（N>1）的时候，表示每次提交事务都write，但累积N个事务才fsync\",\"因此，在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N的事务的binlog日志。\"]},\"451\":{\"h\":\"redo log的写入机制\",\"t\":[\"事务在执行过程中，生成的redo log会先写入到redo log buffer中，并且并不是每次生成后都会持久化到磁盘中。这意味着如果事务执行期间MySQL发生异常重启，那么这部分日志就丢失了，由于事务没有提交，所以这时日志丢了也不会有损失，那么事务还没有提交的时候，redo log buffer中的部分日志有没有可能被持久化到磁盘呢？这就和redo log的三种状态有关：\",\"这三种状态分别是：\",\"存在redo log buffer中，物理上是在MySQL进程内存中，就是图中红色的部分\",\"写到磁盘（write），但是没有持久化（fsync），物理上是在文件系统的page cache里面，也就是图中的黄色部分\",\"持久化到磁盘，对应的是hard disk，也就是图中绿色部分\",\"日志写入到redo log buffer是很快的，write到page cache也差不多，但是持久化到磁盘的速度就慢多了。为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种可能取值：\",\"设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中\",\"设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘\",\"设置为2的时候，表示每次事务提交时都只是把redo log写入到page cache\",\"InnoDB有一个后台线程，每个1秒，就会把redo log buffer中的日志，调用write写入到文件系统的page cache，然后调用fsync持久化到磁盘。\",\"事务执行中间过程中的redo log也就是直接写在redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的redo log，也是可能持久化到磁盘的。\",\"实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中：\",\"一种是，redo log buffer占用的空间即将达到innodb_log_buffer_size一半的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘的动作只是write，而没有调用fsync，也就是只留在了文件系统的page cache\",\"并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。假设一个事务A执行到一半，已经写了一些redo log到buffer中，这个时候另外一个线程的事务B提交，如果innodb_flush_log_at_trx_commit设置的是1，那么按照这个参数的逻辑，事务B要把redo log buffer里的日志全部持久化到磁盘。这时候，就会带上事务A在redo log buffer中的日志一起持久化到磁盘。\",\"如果把innodb_flush_log_at_trx_commit设置成1，那么redo log在prepaer阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于prepare的redo log，再加上binlog来恢复的。每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到文件系统的page cache中就够了。\",\"通常我们说的MySQL的“双1”配置，指的就是sync_binlog和innodb_flush_log_at_trx_commit都设置成1，也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare阶段），一次是binlog。\",\"MySQL的TPS会高于磁盘的TPS，这是因为MySQL中使用了组提交（group commit）的机制，而要了解组提交首先要了解日志逻辑序列号（log sequence number，LSN）。LSN是单调递增的，用来对应redo log的一个个写入点，每次写入长度为length的redo log，LSN的值就会加上length，LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。\",\"下图表示的是，三个并发事务（trx1，trx2，trx3）在prepare阶段，都写完redo log buffer，持久化到磁盘的过程，对应的LSN分别是50、120和160。\",\"从图中可以看到：\",\"trx1是第一个到达得，会被选为这组的leader\",\"等trx1要开始写盘的时候，这个组里面已经有了三个事务，这时候LSN也变成了160\",\"trx1去写盘的时候，带的就是LSN=160，因此等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化磁盘\",\"这时候trx2和trx3就可以直接返回了\",\"所以，一次组提交里面，组员越多，节约磁盘IOPS效果越好，但如果只有单线程压测，那么就是一个事务对应一次持久化操作了。在并发场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能越多，节约IOPS的效果就越好，为了让一次fsync带的组员更多，MySQL还有另一个优化：拖时间。两阶段提交的示意图如下：\",\"其实，写binlog其实是分成两步的：\",\"先把binlog从binlog cache中写到磁盘上的binlog文件\",\"调用fsync持久化\",\"MySQL为了让组提交的效果更好，把redo log做fsync的时间拖到了步骤1之后。也就是说，上面的图变成了这样：\",\"这么以来，binlog也可以组提交了。在执行图5中第4步把binlog fsync到磁盘时，如果有多个事务的binlog已经写完了，也是一起持久化的，这样也可以减少IOPS的消耗。\",\"不过通常情况下第3步执行得会很快，所以binlog得write和fsync间的间隔时间端，导致能集合到一起持久化的binlog比较少，因此，binlog的组提交的效果通常不如redo log的效果那么好，如果想提升binlog组提交的效果，可以通过设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count来实现。\",\"binlog_group_commit_sync_delay表示延迟多少微妙后才调用fsync\",\"binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync\",\"这两个条件是或的关系，也就是说只要有一个满足条件就会调用fsync，所以，当binlog_group_commit_sync_delay设置为0的时候，binlog_group_commit_sync_no_delay_count也无效了。\",\"综上所述，如果MySQL出现了性能瓶颈，而且瓶颈在IO上，可以通过哪些方法来提升性能呢？\",\"设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险\",\"将sync_binlog设置为大于1的值（比较常见的是100~1000）。这样做的风险是，主机掉电时会丢binlog日志\",\"将innodb_flush_log_at_trx_commit设置为2，这样做的风险时，主机掉电的时候会丢数据\",\"不过将innodb_flush_log_at_trx_commit设置成0，当MySQL本身异常重启的话，就会丢失数据。而redo log写到文件系统的page cache的速度也是很快的，所以将这个参数设置成2跟设置0的性能相差并不多，但是设置成2，当MySQL异常重启后就不会丢失数据了。\"]},\"452\":{\"h\":\"主备一致\"},\"453\":{\"h\":\"主备的基本原理\",\"t\":[\"下图表示的是基本主备切换流程：\",\"在状态1中，客户端的读写都直接访问节点A，而节点B是A的备库，只是将A的更新都同步过来，到本地执行，这样可以保持节点B和A的数据是相同的。当需要切换的时候，就切成状态2，这时候客户端读写访问的都是节点B，而节点A是B的备库。\",\"在状态1中，虽然节点B并没有被直接访问，但是依然建议将节点B（也就是备库）设置成只读（readonly）模式，这样做，有以下考虑：\",\"有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作\",\"防止切换逻辑有bug，比如切换过程中出现双写，造成主备不一致\",\"可以用readonly状态，来判断节点的角色\",\"备库虽然设置了readonly，但readonly对超级（super）权限用户是无效的，而用于同步更新的线程，就拥有超级线程，因此，备库可以和主库保持同步更新。\",\"语句在节点A执行，然后同步到节点B的完整示意图如下：\",\"可以看到：主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。备库B和主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连接，一个事务日志同步的完整过程如下：\",\"在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量\",\"在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中io_thread和sql_thread。其中io_thread负责与主库建立连接\",\"主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B\",\"备库B拿到binlog后，写到本地文件，称为中转日志（relay log）\",\"sql_thread读取中转日志，解析出日志里的命令，并执行\",\"不过后来由于多线程复制方案的引入，sql_thread演化成为了多个线程。\"]},\"454\":{\"h\":\"bin log的三种格式\",\"t\":[\"bin log其实有三种格式：一种是statement，一种是row，还有一种叫做mixed，其实它就是前两种格式的混合。为了便于描述 binlog 的这三种格式间的区别，这里创建了一个表，并初始化几行数据：\",\"CREATE TABLE `t` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `t_modified`(`t_modified`) ) ENGINE = InnoDB; insert into t values(1,1,'2018-11-13'); insert into t values(2,2,'2018-11-12'); insert into t values(3,3,'2018-11-11'); insert into t values(4,4,'2018-11-10'); insert into t values(5,5,'2018-11-09'); \",\"如果要在表中删除一行数据的话，我们来看看这个delete语句的binlog是怎么记录的：\",\"mysql> delete from t /*comment*/ where a>=4 and t_modified<='2018-11-10' limit 1; \",\"当binlog_format=statement时，binlog里面记录的就是SQL语句的原文，可以使用命令：\",\"mysql> show binlog events in 'master.000001'; \",\"查看binlog中的内容：\",\"说明如下：\",\"第一行SET @@SESSION.GTID_NEXT='ANONYMOUS'\",\"第二行是一个BEGIN，跟第四行的commit对应，表示中间是一个事务\",\"第三行是真实执行的语句。可以看到，在真正执行的delete命令之前，还有一个“use test”命令，这是MySQL根据当前要操作的表所在的数据库自行添加的，这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确地更新到test库的表t。在“use test”命令之后的delete语句，就是我们输入的SQL原文，可以看到，binlog“忠实”地记录了SQL命令，甚至连注释也一并记录了\",\"最后一行是一个COMMIT，并且记录了xid=61\",\"为了说明statement和row格式的区别，delete命令的执行效果如下：\",\"可以看到，运行这条delete命令产生了一个warning，原因是当前binlog设置的是statement格式，并且语句中有limit，所以这个命令可能是unsafe的。为什么会这样呢？这是因为delete带limit，很可能会出现主备数据不一致的情况，比如上面的这个例子：\",\"如果delete语句使用的是索引a，那么会根据索引a找到第一个满足条件的行，也就是说删除的是a=4这一行\",\"但如果使用的是索引t_modified，那么删除的就是t_modified='2018-11-09'也就是a=5这一行\",\"由于statement格式下，记录到binlog里的是语句原文，因此可能会出现这样一种情况：在主库执行这条SQL语句的时候，用的是索引a，而在备库执行这条SQL语句的时候，却使用了索引t_modified。因此，MySQL认为这样写是有风险的。\",\"将binlog的格式修改为binlog_format='row',此时，binlog中的内容如下：\",\" 可以看到，与statement格式的binlog相比，前后的BEGIN和COMMIT是一样的。但是，row格式的binlog里没有了SQL语句的原文，而是替换成了两个event：Table_map和Delete_rows:\",\"Table_map event用于说明接下来要操作的表是test库的表t\",\"Delete_rows event用于定义删除的行为\",\"通过上图还是不能看出详细的信息，这时候需要借助mysqlbinlog工具，使用如下命令解析和查看binlog中的内容：\",\"mysqlbinlog -w data/master.000001 --start-position=8900; /** 根据上图，这个事务的binlog是从8900这个位置开始的。 */ \",\"说明如下：\",\"server id 1，表示这个事务是在server_id=1的这个库上执行的\",\"每个event都有CRC32的值，这是因为此时的参数设置binlog_checksum=CRC32\",\"Table_map event显示了接下来要打开的表，map到数字226。这里只操作了一张表，如果操作的是多张彪，每个表都有一个对应的Table_map event，都会map到一个单独的数字，用于区分不同表的操作\",\"-w的参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1=4，@2=4这些值）\",\"binlog_row_image的默认配置是FULL，因此Delete_event里面，包含了删掉的行的所有字段的值。如果把binlog_row_image设置为MINIMAL，则只会记录必要的信息，在这个例子里，只会记录id=4这个信息\",\"最后的Xid event，用于表示事务被正确地提交了\",\"可以看到，当binlog_format=row的时候，binlog里面记录了真实删除的行的主键id，这样binlog传到备库去的时候，就肯定会删除id=4的行，不会有主备删除不同行的问题。\",\"对比statement和row的优缺点，就有了mixed这种binlog格式存在的场景：\",\"因为有些statement格式的binlog可能会导致主备不一致，所以要使用row格式\",\"row格式的缺点是，很占空间。比如，使用delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但是如果row格式的binlog，就要把这10万条记录都写到binlog中，这样做，不仅会占用更大的空间，同时写binlog也要耗费IO资源，影响执行速度\",\"MySQL有一个折中的方案，也就是mixed格式的binlog。MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式\",\"总而言之，mixed格式可以利用statement格式的优点，同时又避免了数据不一致的风险。比如上文中的这个例子，设置为mixed，就会记录为row格式，而如果执行的语句去掉limit 1，就会记录为statement格式。\",\"不过，现在越来越多的场景要求将MySQL的binlog格式设置为row，这么做的理由有很多，其中可以直接看出来好处的就是：恢复数据。接下来，我们分别从delete、insert和update这三种SQL语句的角度，来看看数据恢复的问题：\",\"如果执行的是delete语句，row格式的binlog会把删掉的行的整行信息保存起来。所以，如果执行完一条delete语句以后，发现删错数据了，可以直接把binlog中记录的delete语句转为insert，把被错删的数据插入回去就可以恢复了，\",\"类似的，如果是执行错了insert语句，在row格式下，insert语句的binlog会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行。这是，直接把insert语句转成delete语句，删掉这被误插入的一行数据就可以了。\",\"如果执行的update语句，binlog里面会记录修改前整行的数据和修改后的整行数据。所以，如果误执行了update语句的话，只需要把这个event前后的两行信息对调以下，再去数据库里面执行，就能恢复这个更新操作了。\",\"在使用binlog恢复数据的时候，使用mysqlbinlog解析出日志，然后将statement语句直接拷贝出来执行，这种做法可行吗？假设binlog的格式设置为mixed，然后执行如下语句：\",\"mysql> insert into t values(10,10, now()); \",\"执行的效果如下：\",\"可以看到，MySQL此时使用的statement格式，那么，如果这个binlog过了1分钟才传给备库的话，那主备的数据不就不一致了吗？使用 mysqlbinlog工具查看执行的详情：\",\"从图中的结果可以看到，binlog在记录event的时候，会多记录SET TIMESTAMP=1546103491，它用SET TIMESTAMP命令约定了接下来now()函数的返回时间。因此，不论这个binlog是1分钟之后被备库执行，还是3天后用来恢复这个库的备库，这个insert语句插入的行，值都是固定的。也就是说，通过SET TIMESTAMP命令，MySQL就确保了主备数据的一致性。\",\"这也就是说直接执行语句的结果可能是错误的，因为有些语句的执行结果是依赖于上下文命令的，所以，使用binlog来恢复数据的标准做法是，用mysqlbinlog工具解析出来，然后把解析结果整个发给MySQL执行，类似下面的命令：\",\"mysqlbinlog master.000001 --start-position=2738 --stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd; \",\"这个命令的意思是，将master.000001文件里面从第2738字节到2973字节中间这段内容解析出来，放到MySQL去执行。\"]},\"455\":{\"h\":\"循环复制问题\",\"t\":[\"上文中主备的结构实际上是M-S结果，但实际生产上使用比较多的是双M结构，也就是下图所展示的主备切换流程：\",\"对比双M结构和M-S结构，其实区别只是多了一条线，即：节点A和B之间总是互为主备关系，这样在切换的时候就不用再修改主备关系。但是，双M结构有一个显著的问题需要解决：\",\"业务逻辑在节点A上更新了一条语句，然后再把生成的binlog发给节点B，节点B执行完这条更新语句后也会生成binlog（log_slave_updates=on），那么，如果节点A同时是节点B的备库，相当于又把节点B新生成的binlog拿过来执行了一次，然后节点A和B间，会不断地循环执行这条更新语句，也就是循环复制了，要解决这个问题，要用到上文中提到的server id：\",\"规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系\",\"一个备库接到binlog并在重放的过程中，生成与binlog的server id相同的新的binlog\",\"每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志\",\"按照这个逻辑，如果我们设置了双M结构，日志的执行流程就会变成这样：\",\"从节点A更新的事务，binlog里面记的都是A的server id\",\"传到节点B执行一次后，节点B生成的binlog的server id也是A的server id\",\"再传回给节点A，A判断这个server id与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了\"]},\"456\":{\"h\":\"主备延迟\",\"t\":[\"正常情况下，只要主库执行更新生成的所有binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终以执行，但是，MySQL要提供高可用能力，只有最终一致性是不够的，上文中提到的双M结构的主备切换流程图如下：\"]},\"457\":{\"h\":\"主备延迟及其来源\",\"t\":[\"主备切换可能是一个主动运维动作，比如软件升级、主库所在机器按计划下线等，也可能是被动操作，比如主库所在机器掉电。\",\"首先要明确的一个概念是“同步延迟”，与数据同步有关的时间点主要包括以下三个：\",\"主库A执行完成一个事务，写入binlog，我们将这个时刻记为T1\",\"之后传给备库B，我们将备库B接收完这个binlog的时刻记为T2\",\"备库B执行完成这个事务，我们将这个时刻记为T3\",\"所谓备库延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。可以在备库上执行show slave status命令，它的返回结果里面会显示：seconds_behind_master，用于表示当前备库延迟了多少秒。它的计算方式如下：\",\"每个事务的binlog里面都有一个时间字段，用于记录主库上写入的时间\",\"备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到seconds_behind_master\",\"可以看到，其实seconds_behind_master这个参数计算的就是T3-T1.所以，我们可以用seconds_behind_master来作为主备延迟的值，这个值的时间精度是秒。需要注意的是，如果主备库及其的系统时间设置不一致，并不会导致主备延迟的值不准确。因为，备库连接到主库的时候，会通过执行SELECT UNIX_TIMESTAMP()函数来获取当前主库的系统时间，如果这个时候发现主库的系统时间与自己的不一致，备库在执行seconds_behind_master计算的时候会自动扣掉这个差值。\",\"在网络正常的时候，日志从主库传给备库所需的时间是很短的，即T2-T1的值是非常小的。也就是说，网络正常的情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。所以，主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产binlog的速度要慢。\",\"接下来我们分析一下，可能导致主备延迟出现的原因。\",\"第一种情况是，有些部署条件下，备库所在的机器的性能要比主库所在的机器性能差。这里有一个误区是，既然备库没有请求，所以就使用差一点儿的机器，例如，将20个主库放在4台机器上，而把备库集中在一台机器上。但实际上，更新请求对IOPS的压力，在主库和备库是无差别的，这种“非双1”的模式，更新过程中也会触发大量的读操作，所以，当备库主机上的多个备库都在争抢资源的时候，就可能会导致主备延迟了。不过，由于，主备可能发生切换，备库随时可能变成主库，所以主备库选用相同规格的机器，并且做对称部署，是目前比较常见的做法。\",\"第二种情况是，备库的压力大。通常来说，主库提供写能力，备库提供读能力。由于主库直接影响业务，可能使用的时候会比较克制，反而忽视了备库的压力控制。这样做的结果就是，备库上的查询耗费了大量的CPU资源，影响了同步速度，造成了主备延迟。这种情况，可以如下处理：\",\"一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力\",\"通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力\",\"其中，一主多从的方式比较常用，因为作为数据库系统，必须保证要有定期全量备份的能力，而从库，就比较适合来做备份。\",\"第三种情况是大事务。由于主库上必须等事务执行完成才会写入binlog，再传给备库。所以，如果一个主库上执行10分钟，那么事务很有可能就会导致从库延迟10分钟。一次性地使用delete语句删除太多数据，就是一个典型的大事务的场景，比如，一些归档性的数据，平时没有注意删除历史数据，等到空间快满了，业务开发人员要一次性地删掉大量历史数据，这就是一种比较典型的大事务的场景。另一种比较典型的大事务场景，就是大表DDL。\",\"由于主备延迟的存在，所以在主备切换的时候，就相应的有不同的策略。\"]},\"458\":{\"h\":\"可靠性优先策略\",\"t\":[\"在双M的结构下，从状态1到状态2切换的详细过程如下：\",\"判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步\",\"把主库A改成只读状态，即readonly=true\",\"判断备库B的seconds_behind_master的值，直到这个值变成0为止\",\"把备库B改成可读写状态，也就是readonly=false\",\"把业务请求切换到备库B\",\"这个切换过程就称为可靠性优先策略，执行的流程图如下：\",\"图中SBM是seconds_behind_master的简称\",\"可以看到，这个切换流程中是有不可用时间的。因为在步骤2之后，主库A和备库B都处于readonly的状态，也就是说这个时候系统处于不可写状态，直到步骤5完成后才能恢复。在这个不可用状态中，比较耗费时间的是步骤3，可能需要耗费好几秒的时间。这也是为什么需要在步骤1先做判断，确保seconds_behind_master的值足够小。试想如果一开始主备延迟就长达30分钟，而没有先做判断直接切换的话，系统的不可用时间就会长达30分钟，这种情况一般业务都是不可接受的。\",\"如果要避免切换过程中有不可用时间的这个问题，那么可以采用可用性优先的策略，可以将不可能用时间几乎降为0。\"]},\"459\":{\"h\":\"可用性优先策略\",\"t\":[\"如果将可靠性优先策略步骤的4、5调整到最开始执行，也就是说，不等主备数据同步，直接把连接切到备库B，并且让备库可以读写，那么系统几乎没有不可用时间了，这个切换流程，就称为可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。下面我们来举例来说明这一点，假设有一个表t：\",\"CREATE TABLE `t` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `c` int(11) unsigned DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = InnoDB; insert into t(c) insert into t(c) values(1),(2),(3); \",\"这个表定义了一个字增逐渐id，初始化数据后，主库和备库上都是3行数据。接下来，业务人员要继续在表t上执行两条插入语句的命令，依次是：\",\"insert into t(c) values(4); insert into t(c) values(5); \",\"假设现在主库上有其他的数据表有大量的更新，导致主备延迟达到5秒，在插入一条c=4的语句后，发起了主备切换。下图是binlog_format=mixed时，切换的流程和结果：\",\"可以看到，由于采用了可用性优先策略，主库A和备库B上出现了两行不一致的数据。那么，如果设置binlog_format=row情况又会如何呢？\",\"因为row格式在记录binlog的时候，会记录插入的行的所有字段的值，所以最后只会有一行不一致。而且，两边的主备同步的应用线程会报错duplicate key error并停止。也就是说，这种情况下，备库B的（5，4）和主库A的（5，5）这两行数据，都不会被对方执行。详细过程如下：\",\"不难发现：\",\"使用row格式的binlog时，数据不一致的问题更容易被发现，而使用mixed或者statement格式的binlog时，数据很可能悄悄地就不一致了。如果过了很久才发现数据不一致的问题，很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致\",\"主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，都应该选择可靠性策略，数据的可靠性一般还是要优于可用性\",\"那么时候应该使用可用性优化策略呢？一种场景就是一场切换。假设主库A和备库B的主备延迟是30分钟，这时候主库A掉电了，HA系统要切换B作为主库，通常我们在主动切换的时候，需要等到主备延迟小于5秒的时候再启动切换，但这个时候已经别无选择了。\",\"采用可靠性优先策略的话，就必须等到备库B的seconds_behind_master=0之后，才能切换，但现在的情况比较严重，系统已经处于完全不可用的状态。我们就必须先切换到备库B，并且设置备库Breadonly=false。只切换备库，而不设置备只读也是不行的，因为这段时间内，中转日志还没有应用完成，如果直接发起主备切换，客户端查询看不到之前执行完成的事务，会认为有“数据丢失”。虽然随着中转日志的继续应用，这些数据会恢复回来，但是对于一些业务来说，查询到“暂时丢失数据的状态”也是不能被接受的。\",\"总而言之，在满足数据可靠性的前提下，MySQL高可用系统的可用性，是依赖于主备延迟的，延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。\"]},\"460\":{\"h\":\"并行复制\",\"t\":[\"前面的小节中我们介绍过MySQL主备流程图：\",\"图中两个黑色的箭头，一个箭头代表了客户端写入库，另一个箭头代表的是备库上sql_thread执行中转日志（relay log）。这里使用箭头的粗细来表示并行度，可以看到，第一个箭头明显粗于第二个箭头，这是由于在主库上，各种锁都会影响并发度。\",\"图中备库上sql_thread更新数据（DATA）的过程如果使用的是单线程的话，就会导致备库应用日志不够快，造成主备延迟，在5.6版本之前，MySQL只支持单线程复制，从单线程复制到最新版本的多线程复制，中间演化经历多个版本，不过，所有的多线程复制都符合下面的这个模型：\",\"上图中，coordinator就是原来的sql_thread，不过现在它并不再直接更新数据，只负责读取中转日志和分发事务，真正更新日志的，变成了worker线程，work线程的个数，是由参数slave_parallel_workers决定的。\",\"需要注意的是，事务并不能简单的按照轮询的方式分发给各个worker。当事务被分发给worker以后，不同的worker就独立执行了，但是由于CPU的调度策略，第二个事务有可能比第一个事务先执行，而如果这时候刚好这两个事务更新的是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不一致的问题。类似的，同一个事务的多个更新语句，也不能分给多个不同的worker去执行，假设一个事务更新了表t1和t2中的各一行，如果这两条更新语句被分到不同的worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的隔离性。\",\"因此，coordinator在分发的时候，需要满足以下这两个基本要求：\",\"更新同一行的事务，必须被分发到同一个worker中\",\"同一个事务不能被拆开，必须放到同一个worker中\",\"各个版本的多线程复制，都遵循了这两条基本原则。\"]},\"461\":{\"h\":\"按表分发策略\",\"t\":[\"按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行，因为数据是存储在表里的，所以按表分发，可以保证两个worker不会更新同一行。不过，如果有跨表的事务，还是要把两张表放在一起，具体如下图所示：\",\"每个worker线程对应一个哈希表，用于保存当前正在这个worker的“执行队列”里的事务所涉及到的表。哈希表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表，当有事务分配给worker的时候，事务里面涉及到的表会被加到对应的哈希表中。worker执行完成后，这个表会被从哈希表中去掉。以上图为例，hash_table_1表示，现在worker_1的“待执行事务队列”里，有4个事务涉及到db1.t1表，有一个事务涉及到db2.t2表，hash_table_2表示，现在worker_2中有一个事务会更新到表t3的数据。\",\"假设在上图的基础上，corrdinator从中转日志中读入下一个新事务T，这个事务修改的行涉及到表t1和t3，那么这个事务T的分配流程如下：\",\"由于事务T中涉及修改表t1，而worker_1队列中有事务在修改表t1，事务T和队列中的某个事务要修改同一个表的数据，这种情况下我们认为事务T和worker是冲突的\",\"按照这个逻辑，依次判断事务T和每个worker队列的冲突关系，会发现事务T跟worker_2也冲突\",\"事务T跟多余一个worker冲突，corrdinator线程就进入等待\",\"每个worker继续执行，同时修改哈希表，假设hash_table_2里面涉及到修改表t3的事务先执行完成，就会从hash_table_2中把db1.t3这一项去掉\",\"这样corrdinator会发现跟事务T冲突的worker只有worker_1了，此时，就会将事务T分配给worker_1执行\",\"corrdinator继续读下一个中转日志，继续分配事务\",\"也就是说，每个事务在分发的时候，跟所有worker的冲突关系包含以下三种情况：\",\"如果跟所有worker都不冲突，corrdinator线程就会把这个事务分配给最闲的worker\",\"如果跟多于一个worker冲突，corrdinator线程就会进入等待状态，直到和这个事务存在冲突关系的worker只剩下一个\",\"如果只跟一个worker冲突，corrdinator线程就会把这个事务分配给这个存在冲突关系的worker\",\"这个按表分发的方案，在多个表负载均衡的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到一个表的时候，所有事务都会被分配到同一个worker中，就变成单线程复制了。\"]},\"462\":{\"h\":\"按行分发策略\",\"t\":[\"要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果是两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求binlog的格式必须是row。\",\"这个时候，我们判断一个事务T和worker是否冲突，用的规则就不是“修改同一个表”，而是“修改同一行”。\",\"按行复制和按表复制的数据结构差不多，也是为每个worker，分配一个哈希表，只要实现按行分发，此时，哈希表的key就必须是“库名+表名+唯一键的值”。但是，这个“唯一键”只有主键id还是不够的，表中t1中除了主键，还有唯一索引a：\",\"CREATE TABLE `t1` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `a` (`a`) ) ENGINE = InnoDB; insert into t1 values(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5); \",\"假设，接下来我们要在主库执行下面这两个事务：\",\"可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的worker，就有可能session B的语句先执行，这时候id=1的行的a的值还是1，就会报唯一键冲突。因此，基于行的策略，事务哈希表还需要考虑唯一键，即key应该是“库名+表名+索引a的名字+a的值”，比如，在上面这个例子中，要在表t1上执行update t1 set a = 1 where id = 2语句，在binlog里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。因此，corrdinator在解析这个语句的binlog的时候，这个事务的哈希表就有三个项：\",\"key=hash_func(db1+t1+'PRIMARY'+2), value=2，这里value=2是因为修改前后的行id值不变，出现了两次\",\"key=hash_func(db1+t1+'a'+2), value=1，表示会影响到这个表a=2的行\",\"key=hash_func(db1+t1+'a'+1), value=1，表示会影响到这个表a=1的行\",\"可见，相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源，并且有以下限制：\",\"主库的binlog格式必须是row，因为要能够从binlog里面解析出表名、主键值和唯一索引值\",\"表必须有主键\",\"不能有外键，表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准备\",\"对比按表分发和按行分发这两个方案，按行分发策略的并行度会更高，不过，如果要操作多行的大事务的话，按行分发的策略有两个问题：\",\"耗费内存，例如一个语句要删除100万行数据，这时候哈希表就要记录100万个项\",\"耗费CPU，解析binlog，然后计算哈希值，对于大事务，这个成本比较高\",\"所以，按行分发这种策略会设置一个阈值，单个事务如果超过设置的行的阈值（比如，如果单个事务的行数超过10万行），就暂时退化为单线程模式，退化的逻辑大概如下：\",\"corrdinator暂时先hold住这个事务\",\"等待所有wroker都执行完成，变成空队列\",\"corrdinator直接执行这个事务\",\"恢复并行模式\",\"按表分发和按行分发策略并没有被合并到官方。\"]},\"463\":{\"h\":\"MySQL 5.7的并行复制策略\",\"t\":[\"在MySQL5.6的版本中，支持了按库并行的复制策略，在决定分发策略的哈希表中，key就是数据库名。这种策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好。\",\"相比于按表和按行分发，这个策略有两个优势：\",\"构造哈希值的时候很快，只需要库名，而且一个实例上DB数也不会很多，不会出现需要构造100万个项这种情况\",\"不要求binlog的格式，因为statement格式的binlog也可以很容易拿到库名\",\"但是，如果主库上的表都放在同一个DB里面，这个策略就没有效果了。如果不同DB的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。理论上可以创建不同的DB，把相同热度的表均匀分到这些不同的DB中，强行使用这个策略，不过，这样需要特地异动数据，因此这个策略用的并不多。\"]},\"464\":{\"h\":\"MariaDB的并行复制策略\",\"t\":[\"MariaDB利用了redo log组提交（group commit）优化，而MariaDB的并行复制策略利用这个特性：\",\"能够在同一个组里提交的事务，一定不会修改同一行\",\"主库上可以并行执行的事务，备库上也一定是可以并行执行的\",\"MariaDB中的并行复制策略：\",\"在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1\",\"commit_id直接写到binlog里面\",\"传到备库应用的时候，相同commit_id的事务分到多个worker执行\",\"这一组全部执行完成后，corrdinator再去取下一批\",\"这个策略与其他策略不同的地方在于，它的目标是“模拟主库的并行模式”，不过，它并没有实现“真正模拟主库并发度”这个目标。在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。\",\"下图中，假设了三组事务在主库的执行情况，可以看到trx1、trx2和trx3提交的时候，trx4、trx5和trx6是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进入commit状态。\",\"而按照MariaDB的并行复制策略，备库上的执行效果如下：\",\"可以看到，在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，这样系统的吞吐量就不够。另外，这个方案很容易被大事务拖后腿。假设trx2是一个超大事务，那么在备库应用的时候，trx1和trx3执行完成后，就只能等trx2完全执行完成，下一组才能开始执行，这段时间，只有一个worker线程在工作，是对资源的浪费，不过即使如此，这个策略仍然是一个令人感到惊艳的创新。\"]},\"465\":{\"h\":\"MySQL 5.7的并行复制策略\",\"t\":[\"在MariaDB实现了并行复制之后，MySQL5.7版本也提供了类似的功能，由参数slave-parallel-type来控制并行复制策略：\",\"配置为DATABASE，表示使用MySQL5.6版本的按库并行策略\",\"配置为LOGICAL_CLOCK，表示的就是类似MariaDB的策略。不过，MySQL5.7这个策略，针对并行度做了优化\",\"在redo log的两阶段提交中，其实不用等到commit阶段，只要能够达到redo log prepaer阶段，就表示事务已经通过锁冲突的检验了。因此，MySQL5.7并行复制的思想是：\",\"同时处于prepare状态的事务，在备库执行时时可以并行的\",\"处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的\",\"binlog的组提交中，有这样两个参数：\",\"binlog_group_commit_sync_delay参数，表示延迟多少微妙后才调用fsync\",\"binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync\",\"这两个参数用于故意拉长binlog从write到fsync的时间，以此来减少binlog的写盘次数，在MySQL5.7的并行复制策略里，它们可以用来制造更多的“同时处于prepare阶段的事务”，这样就增加了备库复制的并行度。也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些，在MySQL5.7处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。\",\"在MySQL5.7.22的版本里，有新增了一个基于WRITESET的并行复制，相应地，增加了一个参数binlog-transaction-dependency-tracking，用来控制是否启动这个新策略，这个参数的可选值有以下三种：\",\"COMMIT_ORDER表示根据同时进入prepare和commit来判断是否可以并行的策略\",\"WRITESET表示的对于事务涉及更新的每一行，计算出这一行的哈希值，组成集合writeset，如果两个事务没有操作相同的行，也就是说它们的writeset没有交集，就可以并行\",\"WRITESET_SESSION，是在writeset的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序\",\"当然为了唯一标识，这个哈希值是通过“库名+表名+索引名+值”计算出来的，如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert语句对应的writeset就要多增加一个哈希值。\",\"可以看到，这种策略与按行分发的策略比较类似，不过这个实现有以下优势：\",\"writeset是在主库生成后直接写入binlog里面的，这样在备库执行的时候，不需要解析binlog里面的内容（event里的行数据），节省了很多计算量\",\"不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker，更省内存\",\"由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的\",\"当然，对于“表上没有主键”和“外键约束”的场景，writeset策略也是没法并行的，也会暂时退化为单线程模型。\"]},\"466\":{\"h\":\"一主多从\",\"t\":[\"大多数的互联网应用都是读多写少，因此，在业务不断发展的过程中，很可能会先遇到读性能的问题，而在数据层解决读性能问题，就会涉及到一主多从的架构。\",\"图中，虚线箭头表示的是主备关系，也就是A和A'互为主备，从库B、C、D指向的是主库A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。\",\"在一主多从的架构下，主库故障后的主备切换流程如下：\",\"相比于一主一备的切换流程，一主多从的结构在切换完成后，A'会称为新的主库，从库B、C、D也要改接到A'，正是由于多了从库B、C、D重新指向的这个过程，所以主备切换的复杂性也相应增加了。\"]},\"467\":{\"h\":\"基于位点的主备切换\",\"t\":[\"当我们把节点B设置成节点A'的从库的时候，需要执行一条change master命令：\",\"CHANGE MASTER TO MASTER_HOST=$host_name MASTER_PORT=$port MASTER_USER=$user_name MASTER_PASSWORD=$password MASTER_LOG_FILE=$master_log_name MASTER_LOG_POS=$master_log_pos \",\"这条命令有6个参数，其中：\",\"前四个参数分别代表了A'的IP、端口、用户名和密码\",\"最后两个参数分别表示，要从主库的master_log_name文件的master_log_pos这个位置的日志继续同步，而这个位置就是我们所说的同步位点，也就是主库对应的文件名和日志偏移量。\",\"当节点B要设置成A'的从库，就要执行change master命令，就不可避免的要设置位点的这两个参数。原来节点B是A的从库，本地记录的也是A的微店，但是相同的日志，A的位点和A'的位点是不同的。因此，从库B要切换的时候，都需要经过”找同步位点“这个逻辑，但是这个位点很难精确取到，只能取到一个大概位置。\",\"考虑到切换过程中不能丢失数据，所以在确定位点的时候，总是要找一个”稍微往前“的，然后再通过判断跳过那些在从库B上已经执行过的事务，一种取位点的方法是这样的：\",\"等待新主库A'把中转日志（relay log）全部同步完成\",\"在A'上执行show master status命令，得到当前A'上最新的File和Position\",\"取原主库A故障的时刻T\",\"用mysqlbinlog工具解析A'的File，得到T时刻的位点\",\"mysqlbinlog File --stop-datetime=T --start-datetime=T \",\"图中，end_log_pos后面的值“123”，表示的就是A'这个实例，在T时刻写入新的binlog的位置，那么，我们就可以把123这个作为$master_log_pos的值。\",\"不过，这样得到的$master_log_pos的值并不精确。假设在T这个时刻，主库A已经执行完成了一个insert语句插入了一行数据R，并且已经将binlog传给了A'和B，然后在传完的瞬间主剧A的主机就掉电了。此时，系统的状态是这样的：\",\"在从库B上，由于同步了binlog，R这一行已经存在\",\"在新主库A'上，R这一行已经存在，日志是写在123这个位置之后的\",\"此时，在从库B上执行change_master命令，指向A'的File文件的123位置，就会把插入R这一行数据的binlog又同步到从库B去执行\",\"这个时候，从库B的同步线程就会出现Duplicate entry 'id_of_R' for key 'PRIMARY'错误，提示出现了主键冲突，然后停止同步。\",\"所以，通常情况下，在切换任务的时候，要先主动跳过这些错误，有两种常用的方法，一种做法是，主动跳过一个事务，跳过命令的写法是：\",\"set global sql_slave_skip_counter=1; start slave; \",\"因为切换过程中，可能会不止重复执行一个事务，所以需要在从库B刚开始接到新主库A'时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。\",\"另一方式时，通过设置slave_skip_errors参数，直接设置跳过指定的错误，在执行主备切换时，有两种比较常见的错误：\",\"1062错误是插入数据时唯一键冲突\",\"1032错误是删除数据时找不到行\",\"因此，我们可以把slave_skip_errors设置为“1032，1062”，这样中间碰到这两个错误时就直接跳过。\",\"需要注意的是，这种直接跳过指定错误的方法，针对的是主备切换时，由于找不到精确的同步位点，所以只能采用这种方法来创建从库和新主库的主备关系。这么操作的前提是，我们很清楚在主备切换过程中，直接跳过1032和1062这两类错误是无损的，才可以设置slave_skip_errors参数，等到主备间的同步关系建立完成，并稳定执行一段时间之后，我们还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。\"]},\"468\":{\"h\":\"GTID\",\"t\":[\"通过sql_slave_skip_counter跳过事务和通过slave_skip_errors忽略错误的方法，虽然都最终可以建立从库B和新主库A'的主备关系，但这两种操作都很复杂，而且容易出错。所以，MySQL5.6版本引入了GTID，彻底解决了这个问题。\",\"GTID的全称是Global Transaction Identifier，也就是全局事务ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：\",\"GTID=source_id:transaction_id \",\"其中：\",\"ƒsource_id是一个实例第一次启动时自动生成的，是一个全局唯一的值\",\"transaction_id是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1\",\"这里的transaction_id与我们通常讲的事务id有所区别，事务id是在事务执行过程中分配的，如果这个事务回滚了，事务id也会递增，而这里transaction_id只有在事务提交的时候才会分配。\",\"GTID模式的启动需要在启动MySQL实例的时候，添加参数gtid_mode=on和enforce_gtid_consistency=on。在GTID模式下，每个事务都会跟一个GTID一一对应。这个GTID有两种生成方式，而使用哪种方式取决于session变量gtid_next的值：\",\"如果gtid_nex=automatic，代表使用默认值，这时，MySQL就会把source_id:transaction_id分配给这个事务 \",\"记录binlog的时候，先记录一行SET@SESSION.GTID_NEXT='source_id:transaction_id'\",\"把这个GTID加入本实例的GTID集合\",\"如果gtid_next是一个指定的GTID的值，比如通过set gtid_next='current_gtid'指定为current_gtid，那么就有两种可能： \",\"如果current_gtid已经存在于实例的GTID集合中，接下来执行的这个事务会直接被系统忽略\",\"如果current_gtid没有存在于实例的GTID集合中，就将这个current_gtid分配给接下来要执行\",\"这样，每个MySQL实例都维护了一个GTID集合，用来对应“这个实例执行过的所有事务”，接下来我们通过例子来说明这一点。\",\"首先在实例X中创建表t：\",\"CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = InnoDB; insert into t values(1,1); \",\"可以看到，事务的BEGIN之前有一条SET SESSION.GTID_NEXT命令。这时，如果实例X有从库，那么将CREATE TABLE和insert语句的binlog同步过去执行的话，执行事务之前就会先执行这两个SET命令，这样被加入从库的GTID集合的，就是图中的这两个GTID。假设，现在这个实例X是另外一个实例Y的从库，并且此时在实例Y上执行下面的这条插入语句：\",\"insert into t values(1,1); \",\"并且，这条语句在实例Y上的GTID是“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。那么，实例X作为Y的从库，就要同步这个事务过来执行，显然会出现主键冲突，导致实例X的同步线程停止，这时，我们可以执行如下语句序列：\",\"set gtid_next='aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10'; begin; commit; set gtid_next=automatic; start slave; \",\"其中，前三条语句的作用，是通过提交一个空事务，把这个GTID加到实例X的GTID集合中。下图表示了执行完这个空事务之后的show master status的结果：\",\"可以看到实例X的Executed_Gtid_set里面，已经加入了这个GTID，这样，我再执行start slave命令让同步线程执行起来的时候，虽然实例X还是会继续执行实例Y传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”已经存在于实例X的GTID集合中了，所以实例X就会直接跳过这个事务，也就不会再出现主键冲突的错误。\",\"在上面的这个语句序列中，start slave命令之前还有一行set gtid_next=automatic。这句话的作用是“恢复GTID的默认分配行为”，也就是说如果之后有新的事务再执行，就还是按照原来的分配方式，继续分配transaction_id=3。\",\"在GTID模式下，备库B要设置为新主库A'的从库的语法如下：\",\"CHANGE MASTER TO MASTER_HOST=$host_name MASTER_PORT=$port MASTER_USER=$user_name MASTER_PASSWORD=$password master_auto_position=1 \",\"其中，master_auto_position=1就表示这个主备关系使用的是GTID协议，使用这种方式，就无须设置MASTER_LOG_FILE和MASTER_LOG_POS这两个参数了。\",\"现在，将实例A'的GTID的集合记为set_a，实例B的GTID集合记为set_b，那么在实例B上执行start slave命令，取binlog的逻辑如下：\",\"实例B指定主库A'，基于主备协议建立连接\",\"实例B吧set b发给主库A'\",\"实例A'算出set_a与set_b的差集，也就是所有存在于set_a，但是不存在于set_b的GTID的集合，判断A'本地是否包含了这个差集需要的所有binlog事务 \",\"如果不包含，表示A'已经把实例B需要的binlog给删掉了，直接返回错误\",\"如果确认包含全部，A'从自己的binlog文件里面，找出第一个不在set_b的事务，发给B\",\"之后就从这个事务开始，往后读文件，按顺序取binlog发给B去执行\",\"其实，这个逻辑里面包含了一个设计思想：在基于GTID的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的，因此，如果实例B需要的日志已经不存在，A'就拒绝把日志发给B。这跟基于位点的主备协议不同，基于位点的协议，是由备库决定的，备库指定哪个点位，主库就发哪个位点，不做日志的完整性判断。\",\"在引入GTID之后，一主多从的切换场景下，主备切换就变成了：由于不需要找位点了，所以从库B、C、D只需要分别执行change master命令执行实例A'即可。其实，严谨地说，主备切换不是不需要找位点了，而是找位点的这个工作，在实例A'内部就已经自动完成了，但由于这个工作是自动的，所以对HA系统的开发人员来说，非常友好。之后这个系统就由新主库A'写入，主库A'的自己生成的binlog中的GTID集合格式是：source_id_of_A<sup>'</sup>:1-M。如果之前从库B的GTID集合格式是source_id_of_A<sup>'</sup>:1-N，那么切换之后GTID集合的格式就变成了source_id_of_A<sup>'</sup>:1-N，source_id_of_A<sup>'</sup>:1-M。由于主库A'之前也是A的备库，因此主库A'和从库B的GTID集合是一样的。这样就达到了我们的预期。\"]},\"469\":{\"h\":\"读写分离\",\"t\":[\"读写分离的主要目标就是分摊主库的压力，上文提到的一主多从的架构师客户端主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由客户端来选择后端数据库进行查询。还有一种架构是，在MySQL和客户端之间有一个中间代理层proxy，客户端只连接proxy，由proxy根据请求类型和上下文决定请求的分发路由。\",\"客户端直连和带proxy的读写分离架构的优劣势：\",\"客户端直连方案，因为少了一层proxy转发，所以查询性能更好，并且整体架构简单，排查问题更方便。不过这种方案，由于要了解后端的部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。\",\"带proxy的结构，对客户端比较友好。客户端无需关心后端的细节，连接维护、后端信息维护等工作，都是由proxy完成。不过，这样对后端维护团队的要求会更高，而且，proxy也需要有高可用架构，因此，带proxy架构的整体就相对比较复杂\",\"不论采用哪种架构，都会碰到“过期读”的问题，即由于主从可能存在延迟，客户端执行完 一个更新事务马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。\",\"处理这种”过期读“的问题，大致有以下几种方案：\",\"强制走主库方案\",\"sleep方案\",\"判断主备无延迟方案\",\"配合semi-sync方案\",\"等主库位点方案\",\"等GTID方案\"]},\"470\":{\"h\":\"强制走主库方案\",\"t\":[\"强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为两类：\",\"对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品后，马上要返回主页面，查看商品是否发布成功，那么这个请求需要拿到最新的结果，就必须走主库\",\"对于可以读到就数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的，那么，这类请求就可以走从库\",\"当然，这个方案最大的问题在于，有时候会碰到所有的查询都不能是过期读的需求，比如一些金融类的业务。这样的话，就要放弃读写分离，所有读压力都在主库，等同于放弃了扩展性。\"]},\"471\":{\"h\":\"sleep 方案\",\"t\":[\"这个方案的做法是，在主库更新后，读从库之前先sleep一下。具体的方案就是，类似于执行一条select sleep(1)命令。这个方案的假设是，大多数情况下主备延迟在1秒内，做一个sleep可以有很大概率拿到最新的数据。\",\"还是以卖家发布商品为例，商品发布后，用Ajax直接把客户端输入的内容作为“新的商品”显示在页面上，而不是真正地去数据库查询，这样，买家就可以通过这个现实，来确认产品已经发布成功了。等到卖家再刷新页面，去查看商品的时候，其实已经过了一段时间，也就达到了sleep的目的，进而也就解决了过期读的问题。\",\"也就是说，这个sleep方案确实解决了类似场景下的过期读问题，但是也存在两个问题：\",\"如果这个查询请求本来0.5秒就可以在从库上拿到正确结果，也会等1秒\",\"如果延迟超过1秒，还是会出现过期读\"]},\"472\":{\"h\":\"判断主备无延迟方案\",\"t\":[\"要判断备库无延迟，通常有三种做法。\",\"第一种确保主备无延迟的方法是，每次从库执行查询请求前，先判断seconds_behind_master是否已经等于0，如果还不等于0，那就必须等待这个参数变为0才能执行查询请求。seconds_behind_master的单位是秒，如果觉得精度不够，就可以采用位点和GTID的方法来确保主备无延迟。\",\"第二种方法是，对比位点确保主备无延迟：\",\"Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点\",\"Relay_Master_Log_File和Exec_Master_Log_Pos，表示的是备库执行的最新位点\",\"如果Master_Log_File和Read_Master_Log_Pos，Relay_Master_Log_File和Exec_Master_Log_Pos这两组值完全相同，就表示接收到的日志已经同步完成。\",\"第三种方法是，对比GTID集合确保主备无延迟：\",\"Auto_Position=1，表示这对主备关系使用了GTID协议\",\"Retrieved_Gtid_Set，是主备收到的所有日志的GTID集合\",\"Executed_Gtid_Set，是备库所有已经执行完成的GTID集合\",\"如果这两个集合相同，也表示备库接收到的日志都已经同步完成。\",\"可见，对比位点和对比GTID这两种方法，都比判断seconds_behind_master是否为0更精确。在执行查询请求之前，先判断从库是否同步完成的方法，相比于sleep方法，准确度确实提升了不少，但还是没有达到“精确”的程度。一个事务的binlog在主备之间流转的状态如下：\",\"主库执行完成，写入binlog，并反馈给客户端\",\"binlog被从库发送给备库，备库收到\",\"在备库执行binlog完成\",\"三种讨论的判断主备无延迟的逻辑，都是“备库收到的日志都执行完成了”。但是，从binlog在主备之间状态的分析中，可以看到还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态，如下图：\",\"![image-20220325100353640](/Users/jiyongchao/Library/Application Support/typora-user-images/image-20220325100353640.png)\",\"这时，主库上执行完成了三个事务trx1、trx2和trx3，其中：\",\"trx1和trx2已经传到从库，并且已经执行完成了\",\"trx3在主库执行完成，并且已经回复给客户端，但是还没有传到从库中\",\"如果这时候在从库B上执行查询请求，按照上面提到的判断方法，从库会认为已经没有同步延迟，但还是查不到trx3的。严格地说，就是出现了过期读。\",\"要解决这个问题，就要引入半同步复制，也就是semi-sync replication，semi-sync的设计如下：\",\"事务提交的时候，主库把binlog发给从库\",\"从库收到binlog以后，发回给主库一个ack，表示收到了\",\"主库收到这个ack以后，才能给客户端返回“事务完成”的确认\",\"也就是说，如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。这样，结合前面关于位点的判断，就能够确定在从库上执行的查询请求吗，可以避免过期读。\",\"不过，semi-sync+位点判断的方案，只对一主一备的场景是成立的。在一主多从的场景中国呢，主库只要等到一个从库的ack，就开始给客户端返回确认，这时，在从库上执行查询请求，就有两种情况：\",\"如果查询是落在这个相应ack的从库上，是能确保读到最新数据\",\"但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题\",\"另外，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者GTID集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况，示意图如下：\",\"上图中备库B下的虚线框，分别表示relay log和binlog中的事务，可以看到，备库从状态1到状态4都和主库A存在延迟，如果使用上面提到的策略，必须要等到无延迟才能查询的方案，selelct语句直到状态4都不能执行。\",\"总而言之，semi-sync配合判断主备无延迟的方案，存在两个问题：\",\"一主多从的时候，在某些从库执行查询请求会存在过期读的现象\",\"在持续延迟的情况下，可能出现过度等待的问题\",\"仔细观察可以发现，客户端是在发完trx1更新后发起的select语句，其实只要确保trx1已经执行完成就可以执行select语句了，也就是说在状态3执行查询请求，得到的就是预期结果了，这就是等主库位点方案。\"]},\"473\":{\"h\":\"等主库位点方案\",\"t\":[\"要理解等主库位点方案，首先要了解一条命令：\",\"select master_pos_wait(file, pos[,timeout]); \",\"它的逻辑如下：\",\"它是在从库执行的\",\"参数file和pos指的是主库上的文件名和位置\",\"timeout可选，设置为正整数N表示这个函数最多等待N秒\",\"这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。当然，除了正常返回一个正整数M外，还会返回一些其他结果，包括：\",\"如果执行期间，备库同步线程发生异常，则返回NLL\",\"如果等待超过N秒，就返回-1\",\"如果刚开始执行的时候，就已经执行过这个位置了，则返回0\",\"上文中的例子，就可以使用这个逻辑：\",\"trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position\",\"选定一个从库执行查询语句\",\"在从库上执行select master_pos_wait(File,Position,1);\",\"如果返回值是大于等于0的正整数，则在这个从库执行查询语句\",\"否则，到主库执行查询语句\",\"这个过程的流程图如下：\",\"这里假设这条select查询最多在主库上等待1秒，那么1秒内master_pos_wait返回一个大于等于0的整数，就确保了主库上执行的这个查询结果一定包含了trx1的数据。\",\"其中步骤5到主库执行查询语句，是这类方案常用的退化机制，因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。这样带来的问题是，如果所有的从库都延迟超过1秒了，那查询的压力都会跑到主库上。在不允许过期读的要求下，只有两种选择，一种是超时放弃，一种是转到主库查询，至于具体选择哪一种，取决于业务场景。\"]},\"474\":{\"h\":\"GID方案\",\"t\":[\"如果数据库开启了GTID模式，对应的也有等待GTID的方案，MySQL中提供了一个类似的命令：\",\"select wait_for_executed_gtid_set(gtid_set,1); \",\"这条命令的逻辑是：\",\"等待，直到这个库执行的事务中包含传入的gtid_set，返回0\",\"超时返回1\",\"在等位点的方案中，我们执行完事务后，还要主动去主库执行show master status。而MySQL5.7.6版本开始，允许在执行更新类事务，把这个事务的GTID返回给客户端，这样等GTID的方案就可以减少一次查询，这时，执行流程就变成了：\",\"trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1\",\"选定一个从库执行查询语句\",\"在从库上执行select wait_for_executed_gtid_set(gtid1,1)\",\"如果返回值是0，则在这个从库执行查询语句\",\"否则，到主库执行查询语句\",\"整个过程的流程图如下：\",\"第一步中，trx1事务更新完成后，从返回包获取这个事务的GTID，需要将MySQL的参数设置为session_track_gtids=OWN_GTID，然后通过API接口mysql_session_track_get_first从返回包解析出GTID的值即可。\"]},\"475\":{\"h\":\"可用性判断\",\"t\":[\"本小节我们要讨论的是，如何判断一个主库出了问题。\"]},\"476\":{\"h\":\"select 1判断\",\"t\":[\"最简单直接的方法就是执行select 1，如果select 1成功返回了，就表示主库没有问题。实际上，select 1成功返回，只能说明这个库的进程还在，并不能说明主库没问题，为了说明这个问题，我们创建表t：\",\"set global innodb_thread_concurrency = 3; CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = InnoDB; insert into t values(1,1) \",\"这里我们设置innodb_thread_concurrency参数的目的是，控制InnoDB的并发线程上限。也就是说，一旦并发线程数达到这个值，InnoDB在接收到新请求的时候，就会进入等待状态，直到有线程退出。\",\"这里设置innodb_thread_concurrency=3表示InnoDB只允许3个线程并发执行。在这个例子中，前三个session中的sleep（100），使得这三个语句都处于“执行”状态，以此来模拟大查询。在session D中，select 1可以成功，但是查询表t的语句会被阻塞，也就是说，如果这时使用select 1是检测不出问题的。\",\"在InnoDB中，innodb_thread_concurrency这个参数的默认值是0，表示不限制并发线程数量。但是，不限制并发线程数肯定是不行的，因为，一个机器的CPU核数有限，如果不加以限制，线程数过高，会导致上下文切换的成本会过高。通常情况下，innodb_thread_concurrency可以设置为64～128之间的值。\",\"需要额外说明的是，并发连接和并发查询并不是同一个概念，使用show processlist的结果里看到的几千个连接，指的就是并发连接，而“当前正在执行”的语句，才是所谓的并发查询。并发连接数达到几千个影响并不大，就是会多占一些内存，但是并发查询过高会占用过多资源，这就是我们为什么要设置innodb_thread_concurrency参数的原因。\",\"假设我们设置innodb_thread_concurrency=128，那么如果出现同一行热点更新的问题时，会不会很快就把128消耗完呢？实际上，在线程进入锁等待以后，并发线程的计数会减一，也就是说等行锁（包括间隙锁）的线程时不算在128里面的。MySQL这样设计的原因是，进入锁等待的线程已经不吃CPU了，更重要的是，必须这么设计，才能避免整个系统锁死，假设有如下场景：\",\"线程1执行begin; update t set c = c + 1 where id = 1;，启动了事务trx1，然后保持这个状态。这时候，线程处于空闲状态，不算在并发线程里面\",\"线程2到线程129都执行update t set c = c + 1 where id = 1;，由于等行锁，进入等待状态，这样就有128个线程处于等待状态\",\"如果处于锁状态的线程技术不减一，InnoDB就会认为线程数用满了，会阻止其他语句进入引擎执行，这样线程1不能提交事务。而另外的128个线程又处于锁等待状态，整个系统就阻塞了\",\"具体过程如下图：\",\"这时候InnoDB不能响应任何请求，整个系统被锁死。而且，由于所有线程处于等待状态，此时占用的CPU却是0，而这明显不合。所以InnoDB在设计时，遇到进程进入锁等待的情况时，将并发线程的计数减1的设计，是合理而且必要的。\",\"虽然说等锁的线程不算在并发线程计数里，但如果它在真正地执行查询，比如上面例子中的select sleep(100) from t，还是要算进并发线程的计数的。\",\"在这个例子中，同时执在执行的语句超过了设置的innnodb_thread_concurrency的值，这时候系统其实已经不正常了，但是通过select 1来检测系统，会认为系统还是正常的。\"]},\"477\":{\"h\":\"查表判断\",\"t\":[\"为了能够检测InnoDB并发线程数过多导致的系统不可用的情况，我们需要找一个访问InnoDB的场景。一般的做法是，在系统库（mysql库）里创建一个表，比如命名为health_check，里面只放一行数据，然后定期执行：\",\"select * from mysql.health_check; \",\"使用这个方法，我们可以检测出由于并发线程过多导致的数据库不可用的情况。但是，这种做法也存在一个问题，更新事务要写入binlog，当binlog所在磁盘的空间占用率达到100%，那么所有的更新语句和事务提交的commit语句就都会被堵住，但是这个时候系统还是可以正常读取数据的，因此，我们需要把这条查询语句修改成更新语句。\"]},\"478\":{\"h\":\"更新判断\",\"t\":[\"既然要更新，就要放个有意义的字段，常见的做法是放一个timestamp字段，用来表示最后一次执行检测的时间：\",\"update mysql.health_check set t_modified=now(); \",\"节点可用性的检测都应该包含主库和备库。如果用来检测主库的话，那么备库也要进行更新检测。但是，备库的检测也是要写bin log的，由于我们一般会把数据库A和B的主备关系设计为双M结构，所以在备库B傻姑娘执行的检测命令，也要发回给主库A。\",\"但是，如果主库A和备库B都用相同的更新命令，就可能出现行冲入，也就是可能会导致主备同步停止，因此，mysql.health_check这个表需要再加一行。为了让主备之间的更新不产生冲突，我们可以在mysql.health_check表上存入多行数据，并且用A、B的server_id做主键。\",\"CREATE TABLE `health_check` ( `id` int(11) NOT NULL, `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE = InnoDB; /* 检测命令 */ insert into mysql.health_check(id, t_modified) values (@@server_id, now()) on duplicate key update t_modified = no \",\"由于MySQL规定了主库和备库的server_id必须不同（否则创建主备关系的时候就会报错），这样就可以保证主、备库各自的检测命令不会发生冲突。\",\"更新判断是一个相对比较常用的方案，不过依然存在一些问题，其中，“判定慢”是最主要的问题。\",\"首先，所有的检测逻辑都需要一个超时时间N，执行一条update语句，超过N秒后还不返回，就认为系统不可用。假设一个日志盘的IO利用率已经是100%了，这个时候，整个系统的响应非常慢，已经需要做主备切换了。但是IO利用率100%表示系统的IO是正在工作的，每个请求都有机会获得IO资源，执行自己的任务。而update语句，需要的资源很少，所以可能在拿到IO资源的时候就可以提交成功，并且在超时时间N秒未达到之前就返回给了检测系统。检测系统发现，update命令没有超时，于是得到了“系统正常”的结论。\",\"之所以出现这个现象，根本原因是上文中提到的所有方法，都是基于外部检测的。外部检测天然有一个问题，就是随机性。因为外部检测都需要定时轮询，所以系统可能已经出问题了，但是却需要等到下一个检测发起执行语句的时候，才有可能发现为你。而且，如果运气不够好的话，可能第一次轮询还不能发现，这就会导致切换慢的问题。\"]},\"479\":{\"h\":\"内部统计\",\"t\":[\"内部统计的方案主要是要利用磁盘利用率，在MySQL5.6以后提供的preformance_schema库，在file_summary_by_event_name表里统计了每次IO请求的时间，根据MySQL5.6内部每一次IO请求的时间来判断数据库是否出现了问题会精确的多。\",\"file_summary_by_event_name表里有很多行数据，我们主要关注event_name='wait/io/file/innodb/innodb_log_file'这一行：\",\"![image-20220327105108038](/Users/jiyongchao/Library/Application Support/typora-user-images/image-20220327105108038.png)\",\"图中，这一行统计的是redo log的写入时间，第一列EVENT_NAME表示统计的类型。接下来三组数据，显示的是redo log操作的时间统计。第一组五列，是所有IO类型的统计。其中，COUNT_STAR是所有IO的总次数，接下来四列是具体的统计项，单位是皮秒，前缀SUM、MIN、AVG、MAX，顾名思义指的就是总和、最小值、平均值和最大值。第二组六列，是读操作的统计，最后一列SUM_NUMBER_OF_BYTES_READ统计的是，总共从redo log里读了多少字节。第三组六列，统计的是写操作。最后的第四组数据，是对其他类型数据的统计。在redo log里，可以认为它们是对fsync的统计。\",\"bin log对应的是event_name = \\\"wait/io/file/sql/binlog\\\"这一行，各个字段的统计逻辑，与redo log的各个字段完全相同。\",\"由于每次操作数据库，preformance_schema都需要额外地统计这些信息，所以打开这个统计功能是有性能损耗的。如果打开所有的preformance_schema项，性能会下降10%左右，因此，只打开需要的项进行统计即可。\",\"如果打开redo log的时间监控，可以执行：\",\"update setup_instruments set ENABLED='YES', Timed='YES' where name like '%wait/io/file/innodb/innod \",\"假设已经开启了redo log和binlog这两个统计信息，就可以通过MAX_TIMER的值来判断数据库是否出问题了。比如，可以通过设定阈值，单次IO请求时间超过200毫秒属于异常，然后使用类似下面这条语句作为检测逻辑：\",\"select event_name,MAX_TIMER_WAIT FROM performance_schema.file_summary_by_event_name where EVENT_NAME = 'wait/io/file/innodb/innodb_log_file'; \",\"发现异常后，取到需要的信息，再通过下面的这条语句：\",\"truncate table performance_schema.file_summary_by_event_name; \",\"把之前的统计信息清空，这样，再次出现这个异常，就可以加入监控累积值了。\"]},\"480\":{\"h\":\"Kill命令\",\"t\":[\"在MySQL中有两个kill命令：一个是kill quey + 线程id，表示终止这个线程中正在执行的语句：一个是kill connection + 线程id，这里connection可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句。在使用kill命令的时候，可能会出现，无法断开这个连接，但是执行show processlist命令，看到这条语句的Command列显示的却是Killed。\",\"其实大多数情况下，kill query/connection命令是有效的，比如，执行一个查询的过程中，发现执行时间太久，要么放弃继续查询，这时我们就可以使用kill query命令，终止这条查询语句。还有一种情况是，语句处于锁等待的时候，直接使用kill命令也是有效的：\",\"可以看到，session C执行kill query以后，session B几乎同时就提示了语句被中断，这就是我们预期的结果。\"]},\"481\":{\"h\":\"kill命令的执行过程\",\"t\":[\"当对一个表做增删改查操作时，会在表上加MDL读锁，所以，session B虽然处于blocked状态，但还是持有MDL读锁的，如果线程直接被kill掉，那么这个MDL读锁就没有机会释放了。也就是说，kill并不是马上停止的意思，而是告诉线程，这条语句已经不需要继续执行了，可以开始“执行停止的逻辑了”。\",\"其实，这和Linux的kill命令类似。kill -N pid并不是让进程直接停止，而是给进程发一个信号，然后进程处理这个信号，进入终止逻辑。只是对于MySQL的kill命令来说，不需要传信号量参数，就只有“停止”这个命令。\",\"实现上，当用户执行kill query thread_id_B时，MySQL里处理kill命令的线程做了两件事情：\",\"把session B的运行状态改成THD::KILL_QUERY（将变量killed赋值为THD::KILL_QUERY）\",\"给session B的执行线程发一个信号\",\"需要发出信号的原因是，session B处于锁等待状态，如果只是把session B的线程状态设置THD::KILL_QUERY，线程B并不知道这个状态变化，还是会继续等待，发一个信号的目的，就是让session B退出等待，来处理这个THD::KILL_QUERY状态。\",\"上面的分析中，隐含了下面的三层意思：\",\"一个语句执行过程中有多处“埋点”，在这些买点的地方判断线程状态，如果发现线程状态是THD::KILL_QUERY，才开始进入语句终止逻辑\",\"如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处\",\"语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的\",\"接下来我们来看一个kill不掉的例子。首先，执行set global innodb_thread_concurrency = 2，将InnoDB的并发线程上限设置为2，然后执行下面的序列：\",\"可以看到：\",\"session C执行的时候被阻塞了\",\"但是session D执行kill query C命令没有效果\",\"直到session E执行了kill connection命令，才断开了session B的连接，提示“Lost connection to MySQL server during query”\",\"但是，此时如果在session E中执行show processlist，就可以看到下面这个图：\",\"这时候，id=12这个线程的Command列显示的是Killed。也就是说，客户端虽然断开了连接，但是实际上服务端上这条语句还在执行过程中。\",\"为什么在执行kill query命令时，这条语句不像第一个例子的update语句一样退出呢？在实现等行锁时，使用的是pthread_cond_timewait函数，这个等待状态可以被唤醒。但是，在这个例子中，12号线程的等待逻辑是这样的：每10毫秒判断一下是否可以进入InnoDB执行，如果不行，就调用nanosleep函数进入sleep状态。也就是说，虽然12号线程的状态已经设置成了KILL_QUERY，但是在这个等待进入InnoDB的循环过程中，并没有去判断线程的状态，因此根本不会进入终止逻辑阶段。而当session E执行kill connection命令时：\",\"把12号线程状态设置为KILL_CONNECTION\",\"关掉12号线程的网络连接，因为有这个操作，所以这时候session C收到了断开连接的提示\",\"那为什么执行show processlist的时候，会看到Command列显示为killed呢？其实，这时因为在执行show processlist的时候，有一个特别的逻辑：如果一个线程的状态是KILL_CONNECTION，就把Command列线程成Killed，所以，即使是客户端退出了，这个线程的状态仍然是在等待中，那这个线程什么时候会退出呢？\",\"只有等到满足进入InnoDB的条件后，session C的查询语句继续执行，然后才有可能判断到线程的状态已经变成了KILL_QUERY或者KILL_CONNECTION，再进入终止逻辑阶段。\",\"这是kill无效的第一类情况，即：线程没有执行到判断线程状态的逻辑，跟这种情况相同的，还有由于IO压力过大，读写IO的函数一致无法返回，导致不能及时判断线程的状态。另一类情况是，终止逻辑耗时较长，这时候，从show processlist结果上看也是Command = Killed，需要等到终止逻辑完成，语句才算真正完成，这类情况，比较常见的场景有以下几种：\",\"超大事务执行期间被kill，这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长\",\"大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待IO资源，导致耗时较长\",\"DDL命令执行到最后阶段，如果被kill，需要删除中间过程的临时文件，也可能收到IO资源影响耗时较久。\"]},\"482\":{\"h\":\"客户端缓存\",\"t\":[\"在实际使用中，有两个比较常见的误解。\",\"第一个误解是：如果库里面的表特别多，连接就会很慢。有些线上的库，会包含很多表，这时候，每次用客户端连接都会卡在下面这个界面上：\",\"而如果db1这个库里表很少的话，连接起来就会很快，可以很快进入输入命令的状态。但每个客户端在和服务端建立连接的时候，需要做的事情就是TCP握手、用户校验、获取权限。但这几个操作，显然跟库里面表的个数无关。\",\"实际上，当使用默认参数连接的时候，MySQL客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端在连接成功后，需要多做一些操作：\",\"执行show databases;\",\"切到db1库，执行show tables;\",\"把这两个命令的结果用于构建一个本地的哈希表\",\"在这些操作中，最花时间的就是第三步在本地构建哈希表的操作。所以，当一个库中的表个数非常多的时候，这一步就会花比较长的时间。也就是说，我们感知到的连接过程慢，其实并不是连接慢，也不是服务端慢，而是客户端慢。如果在连接命令中加上-A的参数，就可以关掉这个自动不全的功能，然后客户端就可以快速返回了。这里自动补全的效果是，当输入库名或者表名的时候，输入前缀，就可以使用Tab键自动补全表名或者显示提示。如果在实际使用中，自动补全功能用得不多，那么久可以加上-A的参数。\",\"除了可以添加-A的参数以外，加-quick（或简写为-q）参数，也可以跳过这个阶段。但是，这个-quick是一个更容易引起误会的参数，也是关于客户端常见的一个误解。\",\"MySQL客户端发送请求后，接收服务端返回结果的方式有两种：\",\"一种是本地缓存，也就是在本地打开一片内存，先把结果存起来。如果使用API，对应的就是mysql_store_result方法\",\"另一种是不读缓存，读一个处理一个。如果使用API开发，对应的就是mysql_use_result方法\",\"MySQL客户端默认采用第一种方式，而如果加上-quick参数，就会使用第二种不缓存的方式。采用不缓存的方式时，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。也就是说，设置了这个参数，反而会降低服务端的性能。\",\"那么，为什么这个参数要取名叫做-quick呢？这是因为：\",\"第一点，跳过了表名自动补全的功能\",\"第二点，mysql_store_result需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能\",\"第三点，不会把执行命令记录到本地的命令历史文件\",\"因此，-quick参数的意思，其实是让客户端变得更快。\"]},\"483\":{\"h\":\"误删数据\",\"t\":[\"俗话说“常在河边走，哪有不湿鞋”，大多数人都可能会碰到误删数据的场景，为了找到解决误删数据的更高效的方法，我们对MySQL相关的误删数据，做以下分类：\",\"使用delete语句误删数据行\",\"使用drop table或者truncate table语句误删数据表\",\"使用drop database语句误删数据库\",\"使用rm命令误删整个MySQL实例\"]},\"484\":{\"h\":\"误删行\",\"t\":[\"如果使用delete语句误删了数据行，可以用Flashback工具通过闪回把数据恢复回来，Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放，而能够使用这个方案的前题是，需要确保binlog_format=row和binlog_row_image=FULL。\",\"具体恢复数据时，对单个事务做如下处理：\",\"对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event即可\",\"同理，对于delete语句，也是将Delete_rows event改为Write_rows event\",\"而如果是Update_rows的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的位置即可\",\"如果误操作不是一个，而是多个，比如下面三个事务：\",\"(A)delete ... (B)insert ... (C)update... \",\"现在要把数据库恢复到这个三个事务操作之前的状态，用Flashback工具解析binlog后，写回主库的命令是：\",\"(reverse C)update ... (reverse B)delete ... (reverse A)insert... \",\"也就是说，如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。需要注意的是，不要直接在主库上执行这些操作，恢复数据比较安全的做法是，恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。这么做的原因是，一个在执行线上逻辑的主库，数据状态的变更往往是有关联的，可能由于发现数据问题的时间晚了一点，就导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其它数据，所以，如果这时候单独恢复这几行数据，而又未经确认的话，就可能出现对数据的二次破坏。\",\"比起误删数据时候进行处理，更重要的是做到事前预防：\",\"把sql_safe_updates参数设置为on，这样依赖，如果忘记在delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错\",\"代码上线前，必须经过SQL审计\",\"如果设置了sql_safe_updates=on，但是要删除一个小表的全部数据，可以在delete语句中加上where条件，比如where id >= 0。但是delete全表是很慢的，需要生成回滚日志，写redo log和bin log，所以，从性能的角度考虑，应该优先考虑使用truncate table或者drop table命令。\"]},\"485\":{\"h\":\"误删库/表\",\"t\":[\"如果使用了truncate/drop table和drop database命令删除的数据，就无法通过Flashback来恢复了，这是因为，即使我们配置了binlog_format=row，执行这三个命令时，记录的binlog还是statement格式。binlog里面就只有一个truncate/drop语句，这些信息是恢复不出来数据的。\",\"这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份binlog，在这两个条件都具备的情况下，假如有人中午12点删了一个库，恢复数据的流程如下：\",\"取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点\",\"用备份恢复出一个临时库\",\"从日志备份里面，取出凌晨0点之后的日志\",\"把这些日志，除了误删数据的语句外，全部应用到临时库\",\"这个流程的示意图如下：\",\"关于这个过程的说明：\",\"为了加速数据恢复，如果这个临时库上有多个数据库，那么可以在使用mysqlbinlog命令时，加上一个-database参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其它库日志的情况\",\"在应用日志的时候，需要跳过12点误操作的那个语句的binlog： \",\"如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用-stop-position参数执行到误操作之前的日志，然后再用-start-position从误操作之后的日志继续执行\",\"如果实例使用了GTID模式，就方便多了。假设误操作命令的GTID是gtid1，那么只需要执行set gtid_next=gtid1;begin;commit;，先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，就会自动跳过误操作的语句\",\"不过即使这样，使用mysqlbinlog方法恢复数据还是不够快，主要原因有两个：\",\"如果是误删表，最好就是只恢复这张表，也就是只重放这张表的操作，但是mysqlbinlog工具并不能指定只解析一个表的日志\",\"用mysqlbinlog解析出日志应用，应用日志的过程就只能是单线程。\",\"一种加速方式是，在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，这样：\",\"在start slave之前，先通过执行change replication filter replicate_do_table = (tbl_name) 命令，就可以让临时库只同步误操作的表\",\"这样做也可以用上并行复制技术，来加速整个数据恢复过程\",\"这个过程的示意图如下：\",\"图中binlog备份系统到线上备库有一条虚线，是指如果由于时间太久，备库上已经删除了临时实例需要的binlog的话，我们可以从binlog备份系统中找到需要的binlog，再放回备库中。假设，我们发现当前临时实例需要的binlog是从master.000005开始的，但是在备库上执行show binlogs显示的最小的binlog文件是master.000007，意味着少了两个binlog文件。这时，我们就需要去binlog备份系统中找到这两个文件，把之前删掉的binlog放回备库的操作如下：\",\"从备份系统下载master.000005和master.000006这两个文件，放到备库的日志目录下\",\"打开日志目录下的master.index文件，在文件开头加入两行，内容分别是“./master.000005”和“.、master.000006”\",\"重启备库，目的是要让备库重新识别这两个日志文件\",\"现在这个备库上就有了临时库需要的所有binlog了，建立主备关系，就可以正常同步了\",\"无论是把mysqlbinlog工具解析出的binlog文件应用到临时库，还是把临时库接到备库上，这两个方案的共同点是：误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用binlog的方式。也就是说，这两个方案都要求备份系统定期备份全量日志，而且需要确保binlog在被从本地删除之前已经做了备份，但是一个系统不可能无限制的备份日志，还需要根据成本和磁盘空间资源，设定一个日志保留的天数。\"]},\"486\":{\"h\":\"延迟复制备库\",\"t\":[\"虽然可以通过利用并行复制来加速恢复数据的过程，但是这个方案仍然存在“恢复时间不可控”的问题。如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的实例，在备份之后的第6天发生误操作，就需要恢复6天的日志，这个恢复时间可能是要按天来计算的。\",\"这种情况下，就可以考虑搭建延迟复制的备库，这个功能是MySQL5.6版本引入的。一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。\",\"延迟复制的备库是一种特殊的备库，通过CHANGE MASTER TO MASTER_DELAY=N命令，可以指定这个备库持续保持跟主库有N秒的延迟。比如将N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行，这个时候在备库上执行stop slave，再通过之前介绍的方法，跳过误操作的命令，就可以恢复出需要的数据，这样的话就得到了一个最多只需要追加1个小时，就可以恢复出数据的临时实例，也就缩短了整个数据恢复需要的时间。\"]},\"487\":{\"h\":\"预防误删库/表的方法\",\"t\":[\"账号分离。这样做的目的是，避免写错命令，比如： \",\"只给业务开发DML权限，而不给truncate/drop权限，而如果业务开发人员有DDL需求话，可以通过开发管理系统得到支持\",\"即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号\",\"制定操作规范。这样做的目的，是避免写错要删除的表名，比如： \",\"在删除数据表之前，必须先对表做改名操作，然后，观察一段时间，确保对业务无影响以后再删除这张表\",\"改表名的时候，要求给表名加固定的后缀（比如加_to_be_deleted），删除表的动作必须通过管理系统执行。并且，管理系统删除表的时候，只能删除固定后缀的表\"]},\"488\":{\"h\":\"rm删除数据\",\"t\":[\"其实，对于一个有高可用机制的MySQL集群来说，最不怕的就是rm删除数据了，只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作，这是，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。\",\"当然了，现在不止是DBA有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批量下线机器的操作，会让整个MySQL集群的所有节点都全军覆没，应对这种情况，只能尽量将备份跨机房，或者最好是跨城市保存。\"]},\"489\":{\"h\":\"自增主键\",\"t\":[\"自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑，但业务设计不应该依赖于自增主键的连续性，因为自增主键不能保证连续递增，有可能会出现“空洞”。为了便于说明，我们创建一个表t，其中id是自增主键字段，c是唯一索引：\",\"CREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), -- 注意这里设置了唯一约束 UNIQUE KEY `c` (`c`) ) ENGINE = InnoDB; \"]},\"490\":{\"h\":\"自增主键的存储\",\"t\":[\"在这个空表里面执行insert into values(null,1,1);插入一行数据，再执行show create table;命令，就可以看到如下结果：\",\"可以看到，表定义里面出现了AUTO_INCREMENT=2，表示下一次插入数时，如果需要自动生成自增值，会生成id=2。实际上，自增值并不是保存在表结构定义里的，表结构的定义是存放在后缀名为.frm的文件中，但是并不会保存自增值。\",\"不同的引擎对于自增值的保存策略是不同的：\",\"MyISAM引擎的自增值保存在数据文件中\",\"InnoDB引擎的自增值，其实是保存在了内存里，并且只有在MySQL8.0版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的值”，具体情况是： \",\"在MySQL5.7及之前的版本，自增值保存在内存里，并没有持久化，每次重启后，第一次打开表的时候，都会去找自增量的最大值max(id)，然后将max(id)+1作为这个表当前的自增值。举例来说，如果一个表当前数据行里最大的id是10，AUTO_INCREMENT=11,这个时候如果删除id=10的行，AUTO_INCREMENT还是11，但是如果马上重启实例，重启后这个表的AUTO_INCREMENT就会变成10，也就是说，MySQL重启可能会修改一个表的AUTO_INCREMENT的值\",\"在MySQL8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值\"]},\"491\":{\"h\":\"自增值的修改\",\"t\":[\"在MySQL里面，如果字段id被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：\",\"如果插入数据时id字段指定为0、null、或未指定值，那么就把这个表当前的AUTO_INCREMENT值填到自增字段\",\"如果插入数据时id字段执行了具体的值，就直接使用语句里指定的值\",\"根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同，假设某次要插入的值是X，当前的自增值是Y：\",\"如果X<Y，那么这个表的自增值不变\",\"如果X≥Y，就需要把当前自增值修改为新的自增值\",\"新的自增值的生成算法是：从auto_increment_offset开始，以auto_increment_increment为步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。其中，auto_increment_offset和auto_increment_increment是两个系统参数，分别用来表示自增的初始值和步长，默认值都是1。\",\"在一些场景下，使用的就不全是默认值。比如，双M的主备结构里要求双写的时候，我们就可能会设置auto_increment_increment=2，让一个库的自增id多是奇数，另一个库的自增id都是偶数，避免两个库生成的主键发生冲突。\",\"那么，当这两个参数都设置为1的时候，自增主键为什么还是不能保证连续呢？常见的导致自增主键的原因有：\",\"唯一键冲突\",\"事务回滚\",\"自增锁的优化\",\"接下来我们通过例子来说明这三点，假设表t里面已经有了（1，1，1）这条记录，此时执行如下插入命令：\",\"insert into t values(null, 1, 1); \",\"这条语句的执行流程如下：\",\"执行器调用InnoDB引擎接口写入一行，传入的这一行的值是（0，1，1）\",\"InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2\",\"将传入的行的值改成（2，1，1）\",\"将表的自增值改成3\",\"继续执行插入数据的操作，由于已经存在c=1的记录（字段c有唯一约束），所以报Duplicate key error，语句返回\",\"对应的流程图如下：\",\"可以看到，这个表的自增值改成3，是在真正执行插入数据的操作之前，这个语句真正执行的时候，因为碰到了唯一键c冲突，所以id=2这一行并没有插入成功，但也没有将自增值再该回去，所以，在这之后，再插入新的数据行是，拿到的自增id就是3，也就是说，出现了自增主键不连续的情况。\",\"完整的演示过程如下：\",\"可以看到，这个操作序列复现了一个自增主键id不连续的情况（没有id=2的行）。\",\"事务回滚也会发生类似的情况，以下语句序列可以说明这一点：\",\"insert into t values(null,1,1); begin; insert into t values(null,2,2); rollback; insert into t values(null,2,2); // 插入的行是 (3,2,2) \",\"那么当出现唯一键冲突和事务回滚的时候，MySQL为什么不会把表t的自增值改回去呢？答案是为了性能，假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请：\",\"假设事务A申请到了id=2，事务B申请到id=3，那么这个时候表t的自增值是4，之后继续执行\",\"事务B正确提交了，但事务A出现了唯一键冲突\",\"如果允许事务A把自增id回退，也就是把表t的当前自增值改回2，那么就会出现这样的情况：表里面已经有了id=3的行，而当前的自增id的值是2\",\"接下来，继续执行的其它事务就会申请到id=3，这时，就会出现插入语句报错“主键冲突”\",\"而为了解决这个主键冲突，有两种方法：\",\"每次申请id之前，先判断表里面是否已经存在这个id，如果存在，就跳过这个id。但是，这个方法的成本很高，因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断id是否存在\",\"把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id，这个方法的问题是锁的粒度太大，系统并发能力会大幅下降\",\"因此，InnoDB放弃了这个设计，语句执行失败也不会回退自增id，也正是这样，才只保证了自增id是递增的，但不保证是连续的。\"]},\"492\":{\"h\":\"自增锁的优化\",\"t\":[\"可以看到，自增id锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。其实，在MySQL5.1版本之前，并不是这样的，在MySQL5.0版本的时候，自增锁的范围是语句级别，也就是说，如果一个语句申请了一个表自增锁，这个锁会等执行结束以后才释放，显然，这会影响并发度。MySQL5.1.22版本引入了一个新策略，新增参数innodb_autoinc_lock_mode，默认值是1，并且：\",\"这个参数的值被设置为0时，表示采用之前MySQL5.0版本的策略，即语句执行结束后才释放锁\",\"这个参数的值被设置为1时： \",\"普通insert语句，自增锁在申请之后就马上释放\",\"类似insert...select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放\",\"这个参数的值被设置为2时，所有的申请自增主键的动作都是申请后就释放锁\",\"不难发现，insert...select语句在默认设置下，使用了语句级的锁，这主要是出于数据的一致性的考虑，假设有以下场景：\",\"在这个例子中，session A往表t1中插入了4行数据，然后session B创建了一个相同结构的表t2，然后两个session 同时执行向表t2中插入数据的操作，如果session B是申请了自增值以后马上就释放自增锁，就可能出现这样的情况：\",\"session B先插入了两个记录（1，1，1）、（2，2，2）\",\"然后，session A来申请自增id得到id=3，插入了（3，5，5）\",\"之后，session B继续执行，插入两条记录（4，3，3）、（5，4，4）\",\"假设数据库的binlog_format=statment，由于session是同时执行插入数据命令的，所以binlog里面对表t2的更新日志只有两种情况：要么先记session A的，那么先记session B的，但不论是哪一种，这个binlog在从库执行或者用来恢复临时实例，备库和临时实例里面，session B这个语句执行出来，生成的结果里面，id都是连续的，这时，这个库就发生了数据不一致。\",\"产生这个问题的原因是session B的insert语句，生成的id不连续，这个不连续的id，用statement格式的binlog来串行执行，是执行不出来的，要解决这个问题，有两种思路：\",\"让原库的批量插入数据语句，固定生成连续的id的值，所以，自增锁直到语句执行结束才释放，就是为了达到这个目的\",\"在binlog里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成，这种情况，其实就是innodb_autoinc_lock_mode设置为2，同时设置binlog_format=row\",\"因此，在生产上，尤其是有insert...select这种批量插入数据的场景时，从并发插入数据性能的角度考虑，可以考虑思路2，这样做，既能提升并发性，又不会出现数据一致性问题。\",\"普通的insert语句里面包含多个value值的情况下，即使innodb_autoinc_lock_mode设置为1，也不会等语句执行完成才释放锁，因为这类语句在申请自增id的时候，是可以精确计算出需要多少个id的，然后一次性申请，申请完成后锁就可以释放了。也就是说，批量插入数据的语句，之所以需要这么设置，是因为“不知道要预先申请多少个id”，既然预先不知道要申请多少个自增id，那么一种直接的想法就是需要一个时申请一个，但如果一个select...insert语句要插入10万行数据，按照这个逻辑的话就要申请10万次，显然，这种申请自增id的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。因此，对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：\",\"语句执行过程中，第一次申请自增id，会分配1个\",\"1个用完以后，这个语句第二次申请自增id，会分配2个\",\"2个用完以后，还是这个语句，第三次申请自增id，会分配4个\",\"以此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍\",\"insert...select，实际上往表t2插入了4行数据，但是，这四行数据是分三次申请的自增id，第一次申请到了id=1，第二次被分配了id=2和id=3，第三次被分配到id=4到id=7，由于这条语句实际只用上了4个id，所以id=5到id=7就被浪费掉了，之后，再执行insert into t2 values(null,5,)，实际上插入的数据就是（8，5，5）,这也导致出现了自增id不连续的情况。\"]},\"493\":{\"h\":\"自增主键的上限\",\"t\":[\"MySQL里有很多自增的id，每个自增id都是定义了初始值，然后不停地往上加步长，虽然自然数是没有上限的，但是在计算机里，只要定义了表示这个数的字节长度，那它就有上限。比如，无符号整型（unsigned int）是4个字节，上限就是223-1。\"]},\"494\":{\"h\":\"表定义自增值id\",\"t\":[\"表定义的自增值达到上限后的逻辑是：再申请下一个id时，得到的值保持不变，我们可以通过下面的语句序列验证：\",\"create table t(id int unsigned auto_increment primary key) auto_increment=4294967295; insert into t values(null); // 成功插入一行 4294967295 show create table t; /* CREATE TABLE `t` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4294967295; */ insert into t values(null); //Duplicate entry '4294967295' for key 'PRIMARY' \",\"可以看到，第一个insert语句插入数据成功后，这个表的AUTO_INCREMENT没有改变（还是4294967295），就导致了第二个insert语句又拿到相同的自增id值，再试图执行插入语句，报主键冲突错误。223-1（4294967295）不是一个特别大的数，对于一个频繁插入删除数据的表来说，是可能会被用完的，因此在建表的时候需要考察是否可能达到这个上限，如果有可能，就应该创建成8个字节bigint unsigned。\"]},\"495\":{\"h\":\"InnoDB系统自增row_id\",\"t\":[\"如果创建的InnoDB表没有指定主键，那么InnoDB会默认创建一个不可见的，长度为6个字节的row_id，InnoDB维护了一个全局的dict_sys.row_id的值，所有无主键的InnoDB表，每插入一行数据，都将当前的dict_sys.row_id的值作为要插入数据的row_id，然后把dict_sys.row_id的值加1。实际上，在代码实现时row_id是一个长度为8字节的无符号长整型（bigint unsigned），但是，InnoDB在设计时，给row_id留的只是6个字节的长度，这样写到数据表中只放了最后6个字节，所以row_id能写到数据表中的值，就有两个特征：\",\"row_id写入表中的值范围，是从0到248-1\",\"当dict_sys.row_id=248时，如果再有插入数据的行为要来申请row_id，拿到以后再取最后6个字节的话就是0\",\"也就是说，写入表的row_id是从0开始到248-1，达到上限后，下一个值就是0，然后继续循环，虽然248-1这个值本身已经很大了，但是如果一个MySQL实例跑得足够久得话，还是可能达到这个上限的，在InnoDB逻辑里，申请row_id=N后，就将这行数据写入表中，如果表中已经存在row_id=N的行，新写入的行就会覆盖原有的行。\",\"从这个角度来看，我们还是应该在InnoDB表中主动创建自增主键，因为表自增id达到上限后，再插入数据时报主键冲突错误，是更能被接受的，毕竟覆盖数据，就意味着数据丢失，影响的是数据可靠性，报主键冲突，是插入失败，影响的是可用性，而一般情况下，可靠性优于可用性。\"]},\"496\":{\"h\":\"Xid\",\"t\":[\"redo log和binlog有一个共同的字段叫做Xid，它在MySQL中是用来对应事务的。MySQL在内部维护了一个全局变量global_query_id，每次执行语句的时候将它赋值给Query_id，然后给这个变量加1。如果当前语句是这个事务执行的第一条语句，那么MySQL还会同时把query_id赋值给这个事务的Xid。global_query_id是一个纯内存变量，重启之后就会清零，因此，在同一个数据库实例中，不同事务的Xid也是有可能相同的。但是MySQL重启之后会生成新的binlog文件，这就保证了，同一个binlog文件里，Xid一定是唯一的。\",\"虽然MySQL重启不会导致同一个binlog里面出现两个相同的Xid，但是如果global_query_id达到上限后，就会继续从0开始计数，从理论上将，还是会出现同一个binlog里面出现相同Xid的场景。由于global_query_id定义的长度是8个字节，这个自增值得上限是264-1，要出现这样得情况，必须出现如下场景：\",\"执行一个事务，假设Xid是A\",\"接下来执行264次查询语句，让global_query_id回到A\",\"再启动一个事务，这个事务的Xid也是A\",\"不过，264这个值太大了，这种场景只会存在于理论中。\"]},\"497\":{\"h\":\"Innodb trx_id\",\"t\":[\"Xid和InnoDB的trx_id是两个容易混淆的概念。Xid是由server层维护的，InnoDB内部使用Xid，就是为了能够在InnoDB事务和server之间做关联。但是，InnoDB自己的trx_id，是另外维护的。InnoDB内部维护了一个max_trx_id全局变量，每次申请一个新的trx_id时，就获得max_trx_id的当前值，然后并将max_trx_id加1.\",\"InnoDB数据可见性的核心思想是：每一行数据都记录了更新它的trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的trx_id做对比。对于正在执行的事务，可以从infomation_schema.innodb_trx表中看到事务的trx_id。\",\"接下来，我们观察如下事务序列：\",\"session B中从innodb_trx表里查出来的两个字段，第二个字段trx_mysql_thread_id就是线程id。显示线程id，是为了说明这两次查询看到的事务对应的线程id都是5，也就是session A所在的线程。可以看到，T2时刻显示的trx_id是一个很大的数；T4时刻显示的trx_id是1289，看上去是一个比较正常的数字，这是因为，在T1时刻，session A还没有涉及到更新，是一个只读事务，而对于只读事务，InnoDB并不会分配trx_id，也就是说：\",\"在T1时刻，trx_id的值其实就是0，而这个很大的数，只是显示用的\",\"直到session A在T3时刻执行insert语句的时候，InnoDB才真正分配了trx_id。所以，T4时刻，session B查到的这个trx_id的值就是1289\",\"需要注意的是，除了显而易见的修改类语句外，如果在select语句后面加上for update，这个事务也不是只读事务。\",\"T2时刻这个数字是每次查询的时候由系统临时计算出来的。它的算法是：把当前事务的trx变量的指针地址转成整数，再加上248，使用这个算法，就可以保证两点：\",\"因为同一个只读事务在执行期间，它的指针地址是不会变的，所以不论是在innodb_trx还是在innodb_locks表里，同一个只读事务查出来的trx_id就会是一样的\",\"如果有并行的多个只读事务，每个事务trx变量的指针地址肯定不同。这样，不同的并发只读事务，查出来的trx_id就是不同的\",\"而在显示值里面加上248，目的是为了保证只读事务显示的trx_id值比较大，正常情况下就会区别于读事务的id。但是trx_id跟row_id的逻辑类似，定义长度也是8个字节。因此，在理论上还是可能出现一个读写事务于一个只读事务显示trx_id相同的情况，不过这个概率很低，并且没有什么实质危害。\",\"那么，只读事务不分配trx_id有什么好处呢？\",\"一个好处是，这样做可以减少事务视图里面活跃事务数组的大小。因为当前正在运行的只读事务，是不影响数据的可见性判断的。所以，在创建事务的一致性视图时，InnoDB就只需要拷贝读写事务的trx_id\",\"另一好处是，可以减少trx_id的申请次数。在InnoDB里，即使只是执行一个普通的select语句，在执行过程中，也是要对应一个只读事务的。所以只读事务优化后，普通的查询语句不需要申请trx_id，就大大减少了并发事务申请trx_id的锁冲突\",\"由于只读事务不分配trx_id，一个自然而然的结果就是trx_id的增加速度变慢了。但是，max_trx_id会持久化存储，重启也不会重置为0，那么从理论上讲，只要一个MySQL服务跑得足够久，就可能出现max_trx_id达到248-1的上限，然后从0开始的情况。当达到这个状态后，MySQL就会持续出现一个脏读的bug。\",\"首先我们需要把当前的max_trx_id先修成248-1。注意：这里使用的是可重复读隔离级别，具体的操作流程如下：\",\"由于此时系统的max_trx_id设置成了248-1，所以在session A启动的事务TA的低水位就是248-1，在T2时刻，session B执行第一条update语句的事务id就是248-1，而第二条update语句的事务id就是0了，这条update语句执行后生成的数据版本上的trx_id就是0，在T3时刻，session A执行select语句的时候，判断可见性发现，c=3这个数据版本的trx_id，小于事务TA的低水位，因此认为这个数据可见，但，这个是脏读，由于低水位值会持续增加，而事务id从0开始计数，就导致了系统在这个时刻之后，所有的查询都会出现脏读的。而且，MySQL重启时max_trx_id也不会清0，也就是说重启MySQL，这个bug仍然存在。\",\"假设一个MySQL实例的TPS是每秒50万，持续这个压力的话，在17.8年后，就会出现这个情况。如果TPS更高，这个年限自然也就更短了。但是，从MySQL的真正开始流行到现在，恐怕都还没有实例跑到过这个上限。不过，这个bug是只要MySQL实例服务时间够长，就必然会出现。\"]},\"498\":{\"h\":\"thread_id\",\"t\":[\"thread_id的逻辑是，系统保存了一个全局变量thread_id_counter，每新建一个连接，就将thread_id_counter赋值给这个新连接的线程变量。thread_id_counter定义的大小是4个字节，因此达到232-1后，它就会重置为0，然后继续增加。但是，但是，你不会在show processlist里看到两个相同的thread_id，这是因为MySQL设计了一个唯一数组的逻辑，给新线程分配thread_id的时候，逻辑代码如下：\",\"do { new_id = thread_id_counter++; } while (!thread_ids.insert_unique(new_id).second); \"]},\"499\":{\"h\":\"自增主键总结\",\"t\":[\"总的来说，每种自增id有各自的应用场景，在达到上限后的表现也不同：\",\"表的自增主键id达到上限后，再申请时它的值就不会改变，进而导致继续插入数据时报主键冲突的错误\",\"row_id达到上限后，则会归0再重新递增，如果出现相同的row_id，后写入的数据会覆盖之前的数据\",\"Xid只需要不在同一个binlog文件中出现重复值接口，但是概率极小，可以忽略不计\",\"InnoDB的max_trx_id递增值MySQL每次重启都会被保存起来，所以上文中脏读的例子就是一个必现的bug\",\"thread_id是使用中最常见的，也是处理的最好的自增id逻辑\",\"[1] MySQL实战45讲\",\"[2] MySQL5.7手册\"]},\"500\":{\"h\":\"MySQL性能优化\"},\"501\":{\"h\":\"MySQL索引结构\",\"t\":[\"索引是帮助MySQL高效获取数据的排好序的数据结构。\",\"常见索引的数据结构：\",\"二叉树\",\"红黑树\",\"Hash表\",\"B-Tree\",\"索引的图示：\"]},\"502\":{\"h\":\"B-Tree\",\"t\":[\"叶子结点具有相同的深度，叶子结点的指针为空\",\"所有索引元素不重复\",\"结点中的数据索引从左到右递增排列\"]},\"503\":{\"h\":\"B+Tree\",\"t\":[\"非叶子结点不存储data，只存储索引（冗余），可以放更多的索引\",\"叶子结点包含所有索引字段\",\"叶子结点用指针连接，提高区间访问的性能\",\"查询MySQL页大小：\",\"show global status like 'innodb_page_size'; \",\"默认页大小是16KB，每个非叶子结点可以放16KB/（8+6）B大约1170个元素，每个页可以放1170*1170再乘以16KB约2000多万的数据。\"]},\"504\":{\"h\":\"Hash\",\"t\":[\"对索引的key进行一次hash计算就可以定位出数据存储的位置。\",\"很多时候Hash索引要比B+树索引更高效\",\"仅能满足“=”，“IN”，不支持范围查询\",\"hash冲突问题\"]},\"505\":{\"h\":\"索引实现\",\"t\":[\"InnoDB索引实现（聚集）\",\"表数据文件本身就是按B+Tree组织的一个索引结构文件\",\"聚集索引-叶子结点包含了完整的数据记录\",\"为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？\",\"如果没有主键，InnoDB引擎会自动选择所有数据都不相等的列，如果没有所有数据都不相等的列，则会使用rowId来构建B+树。使用整型的主键可以方便的比较大小，另外整型的存储空间也比较小。不是自增的主键在插入的时候，B+树可能会出现分裂和平衡的现象，从而影响性能。\",\"为什么非主键索引结构的叶子结点存储的是主键值？\",\"主要是基于一致性和节省存储空间的考虑。\",\"MyISAM索引文件和数据文件是分离的（非聚集）：\",\"多列索引的结构：\",\"会按照索引列的顺序来维护B+树，在上面这个例子中，InnoDB会先排好name，再比较age，再比较position，如果有一个字段可以排序，就不会再看后面的字段。\"]},\"506\":{\"h\":\"EXPLAIN详解\",\"t\":[\"DROP TABLE IF EXISTS `actor`; CREATE TABLE `actor` ( `id` INT ( 11 ) NOT NULL, `name` VARCHAR ( 45 ) DEFAULT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = INNODB DEFAULT CHARSET = utf8; INSERT INTO `actor` ( `d`, `name`, `update_time` ) VALUES (1, 'a', '2017‐12‐22 15:27:18' ),(2, 'b', '2017‐12‐22 5:27:18' ), (3, 'c', '2017‐12‐22 5:27:18' ); DROP TABLE IF EXISTS `film`; CREATE TABLE `film` ( `id` INT ( 11 ) NOT NULL AUTO_INCREMENT, `name` VARCHAR ( 10 ) DEFAULT NULL, PRIMARY KEY ( `id` ), KEY `idx_name` ( `name` ) ) ENGINE = INNODB DEFAULT CHARSET = utf8; INSERT INTO `film` ( `id`, `name` ) VALUES ( 3, '=film0' ),(1,'=film1' ),( 2, 'film2' ); DROP TABLE IF EXISTS `film_actor`; CREATE TABLE `film_actor` ( `id` INT ( 11 ) NOT NULL, `film_id` INT ( 11 ) NOT NULL, `actor_id` INT ( 11 ) NOT NULL, `remark` VARCHAR ( 255 ) DEFAULT NULL, PRIMARY KEY ( `id` ), KEY `idx_film_actor_id` ( `film_id`, `actor_id` ) ) ENGINE = INNODB DEFAULT CHARSET = utf8; INSERT INTO `film_actor` ( `id`, `film_id`, `actor_id` ) VALUES( 1, 1, 1 ),(2, 1, 2 ),(3,2,1 ); \",\"Filtered/100可以估算出将要和explain中前一个表进行连接的行数（前一个表指explain中id值比当前表id值小的表）。\",\"explainpartitions：相比explain多了个partitions字段，如果查询是基于分区表的话，会显示查询将访问的分区。\"]},\"507\":{\"h\":\"EXPLAIN中的列\"},\"508\":{\"h\":\"id列\",\"t\":[\"select后面的是子查询，from后面的是派生表查询。\"]},\"509\":{\"h\":\"type列\",\"t\":[\"system>const\",\"EXPLAIN SELECT min( id ) FROM film; \",\"EXPLAIN EXTENDED SELECT * FROM( SELECT * FROM film WHERE id = 1 ) tmp; \",\"show warnings; \",\"eq_ref\",\"EXPLAIN SELECT * FROM film_actor LEFT JOIN film ON film_actor.film_id = film.id; \",\"range\",\"EXPLAIN SELECT * FROM actor WHERE id > 1; \",\"index\",\"EXPLAIN SELECT * FROM film; \"]},\"510\":{\"h\":\"最佳实践\",\"t\":[\"CREATE TABLE `employees` (`id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(24) NOT NULL DEFAULT '' COMMENT '姓名', `age` int(11) NOT NULL DEFAULT '0' COMMENT '年龄', `position` varchar(20) NOT NULL DEFAULT '' COMMENT '职位', `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '入职时间', PRIMARY KEY(`id`), KEY`idx_name_age_position` (`name`,`age`,`position`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='员工记录表'; INSERT INTO employees(name,age,position,hire_time) VALUES('LiLei',22,'manager',NOW()); INSERT INTO employees(name,age,position,hire_time) VALUES('HanMeimei', 23,'dev',NOW()); INSERT INTO employees(name,age,position,hire_time) VALUES('Lucy',23,'dev',NOW()); \"]},\"511\":{\"h\":\"SQL执行底层原理\"},\"512\":{\"h\":\"连接器\"},\"513\":{\"h\":\"词法分析器\",\"t\":[\"SQL语句的分析分为词法分析与语法分析，mysql的词法分析由MySQLLex（MySQL自己实现的）完成，语法分析由Bison生成。除了Bison外，Java当中也有开源的词法结构分析工具，例如Antlr4，ANTLR从语法生成一个解析器，可以构建和遍历解析树。\"]},\"514\":{\"h\":\"优化器\",\"t\":[\"经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要经过优化器的处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面的语句，这个语句是执行两个表的join：\",\"select * from test1 join test2 using(ID) where test1.name=jyc and test2.name=jyc; \",\"既可以从表test1里面取出name=jyc记录的ID值，再根据ID值关联到表test2，再判断test2里面的name的值是否等于jyc；也可以从表test2里面取出name=jyc的记录的ID值，再根据ID值关联到test1，再判断test1里面name的值是否等于jyc。\",\"这两种执行方法的逻辑是一样的，但是执行的效率会有所不同，而优化器的作用就是决定选择使用哪一个方案，优化器阶段完成后，这个语句的执行方法就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等。\"]},\"515\":{\"h\":\"执行器\"},\"516\":{\"h\":\"bin-log归档\"},\"517\":{\"h\":\"索引优化实践\",\"t\":[\"参考：\",\"https://note.youdao.com/ynoteshare/index.html?id=d2e8a0ae8c9dc2a45c799b771a5899f6&type=note&time=1678024153495\",\"https://note.youdao.com/share/?id=df15aba3aa76c225090d04d0dc776dd9&type=note\"]},\"518\":{\"h\":\"索引下推\",\"t\":[\"数据准备如下。\",\"CREATE TABLE `employees` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(24) NOT NULL DEFAULT '' COMMENT '姓名', `age` int(11) NOT NULL DEFAULT '0' COMMENT '年龄', `position` varchar(20) NOT NULL DEFAULT '' COMMENT '职位', `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '入职时间', PRIMARY KEY (`id`), KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='员工记录表'; INSERT INTO employees(name,age,position,hire_time) VALUES('LiLei',22,'manager',NOW()); INSERT INTO employees(name,age,position,hire_time) VALUES('HanMeimei', 23,'dev',NOW()); INSERT INTO employees(name,age,position,hire_time) VALUES('Lucy',23,'dev',NOW()); drop procedure if exists insert_emp; delimiter ;; create procedure insert_emp() begin declare i int; set i=1; while(i<=100000)do insert into employees(name,age,position) values(CONCAT('zhuge',i),i,'dev'); set i=i+1; end while; end;; delimiter ; call insert_emp(); \",\"对于辅助的联合索引（name，age、position），正常情况按照最左前缀原则，select * from employess where name like 'LiLei%' and age = 22 and position = 'manager' ，这种情况只会走name字段索引，因为根据name字段过滤完，得到的索引行里的age和position是无序的，无法很好的利用索引。\",\"在MySQL5.6之前的版本，这个查询只能在联合索引里匹配到名字是'LiLei%'开头的索引，然后用这些索引对应的主键逐个回表，到主键索引上找出相应的记录，再对比age和position这两个字段的值是否符合。\",\"MySQL5.6引入了索引下推优化，可以在索引遍历过程中，对索引包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，可以有效的减少索引下推优化后，上面那个查询在联合索引里匹配到名字是'LiLei%'开头的索引之后，同时还会在索引里过滤age和position这两个字段，然后用过滤完剩下的索引对应的主键id再回表查整行数据。\",\"索引下推会减少回表次数，对于InnoDB引擎的表索引下推只能用于二级索引，InnoDB的主键索引（聚簇索引）树叶子结点上保存的是全行数据，所以这个时候索引下推并不会减少查询全行数据的效果。\"]},\"519\":{\"h\":\"如何选择合适的索引\",\"t\":[\"set session optimizer_trace=\\\"enabled=on\\\",end_markers_in_json=on; --开启trace select * from employees where name > 'a' order by position; SELECT * FROM information_schema.OPTIMIZER_TRACE; \",\"查看trace字段：\",\"{ \\\"steps\\\": [ { \\\"join_preparation\\\": { --第一阶段：SQL准备阶段，格式化sql \\\"select#\\\": 1, \\\"steps\\\": [ { \\\"expanded_query\\\": \\\"/* select#1 */ select `employees`.`id` AS `id`,`employees`.`name` AS `name`,`employees`.`age` AS `age`,`employees`.`position` AS `position`,`employees`.`hire_time` AS `hire_time` from `employees` where (`employees`.`name` > 'a') order by `employees`.`position`\\\" } ] /* steps */ } /* join_preparation */ }, { \\\"join_optimization\\\": { --第二阶段：SQL优化阶段 \\\"select#\\\": 1, \\\"steps\\\": [ { \\\"condition_processing\\\": { --条件处理 \\\"condition\\\": \\\"WHERE\\\", \\\"original_condition\\\": \\\"(`employees`.`name` > 'a')\\\", \\\"steps\\\": [ { \\\"transformation\\\": \\\"equality_propagation\\\", \\\"resulting_condition\\\": \\\"(`employees`.`name` > 'a')\\\" }, { \\\"transformation\\\": \\\"constant_propagation\\\", \\\"resulting_condition\\\": \\\"(`employees`.`name` > 'a')\\\" }, { \\\"transformation\\\": \\\"trivial_condition_removal\\\", \\\"resulting_condition\\\": \\\"(`employees`.`name` > 'a')\\\" } ] /* steps */ } /* condition_processing */ }, { \\\"substitute_generated_columns\\\": { } /* substitute_generated_columns */ }, { \\\"table_dependencies\\\": [ --表依赖详情 { \\\"table\\\": \\\"`employees`\\\", \\\"row_may_be_null\\\": false, \\\"map_bit\\\": 0, \\\"depends_on_map_bits\\\": [ ] /* depends_on_map_bits */ } ] /* table_dependencies */ }, { \\\"ref_optimizer_key_uses\\\": [ ] /* ref_optimizer_key_uses */ }, { \\\"rows_estimation\\\": [ --预估表的访问成本 { \\\"table\\\": \\\"`employees`\\\", \\\"range_analysis\\\": { \\\"table_scan\\\": { --全表扫描情况 \\\"rows\\\": 10123, --扫描行数 \\\"cost\\\": 2054.7 --查询成本 } /* table_scan */, \\\"potential_range_indexes\\\": [ --查询可能使用的索引 { \\\"index\\\": \\\"PRIMARY\\\", --主键索引 \\\"usable\\\": false, \\\"cause\\\": \\\"not_applicable\\\" }, { \\\"index\\\": \\\"idx_name_age_position\\\", --辅助索引 \\\"usable\\\": true, \\\"key_parts\\\": [ \\\"name\\\", \\\"age\\\", \\\"position\\\", \\\"id\\\" ] /* key_parts */ } ] /* potential_range_indexes */, \\\"setup_range_conditions\\\": [ ] /* setup_range_conditions */, \\\"group_index_range\\\": { \\\"chosen\\\": false, \\\"cause\\\": \\\"not_group_by_or_distinct\\\" } /* group_index_range */, \\\"analyzing_range_alternatives\\\": { --分析各个索引使用成本 \\\"range_scan_alternatives\\\": [ { \\\"index\\\": \\\"idx_name_age_position\\\", \\\"ranges\\\": [ \\\"a < name\\\" --索引使用范围 ] /* ranges */, \\\"index_dives_for_eq_ranges\\\": true, \\\"rowid_ordered\\\": false, --使用该索引获取的记录是否按照主键排序 \\\"using_mrr\\\": false, \\\"index_only\\\": false, --是否使用覆盖索引 \\\"rows\\\": 5061, --索引扫描行数 \\\"cost\\\": 6074.2, --索引使用成本 \\\"chosen\\\": false, --是否选择该索引 \\\"cause\\\": \\\"cost\\\" } ] /* range_scan_alternatives */, \\\"analyzing_roworder_intersect\\\": { \\\"usable\\\": false, \\\"cause\\\": \\\"too_few_roworder_scans\\\" } /* analyzing_roworder_intersect */ } /* analyzing_range_alternatives */ } /* range_analysis */ } ] /* rows_estimation */ }, { \\\"considered_execution_plans\\\": [ { \\\"plan_prefix\\\": [ ] /* plan_prefix */, \\\"table\\\": \\\"`employees`\\\", \\\"best_access_path\\\": { --最优访问路径 \\\"considered_access_paths\\\": [ --最终选择的访问路径 { \\\"rows_to_scan\\\": 10123, \\\"access_type\\\": \\\"scan\\\", --访问类型：为scan，全表扫描 \\\"resulting_rows\\\": 10123, \\\"cost\\\": 2052.6, \\\"chosen\\\": true, --确定选择 \\\"use_tmp_table\\\": true } ] /* considered_access_paths */ } /* best_access_path */, \\\"condition_filtering_pct\\\": 100, \\\"rows_for_plan\\\": 10123, \\\"cost_for_plan\\\": 2052.6, \\\"sort_cost\\\": 10123, \\\"new_cost_for_plan\\\": 12176, \\\"chosen\\\": true } ] /* considered_execution_plans */ }, { \\\"attaching_conditions_to_tables\\\": { \\\"original_condition\\\": \\\"(`employees`.`name` > 'a')\\\", \\\"attached_conditions_computation\\\": [ ] /* attached_conditions_computation */, \\\"attached_conditions_summary\\\": [ { \\\"table\\\": \\\"`employees`\\\", \\\"attached\\\": \\\"(`employees`.`name` > 'a')\\\" } ] /* attached_conditions_summary */ } /* attaching_conditions_to_tables */ }, { \\\"clause_processing\\\": { \\\"clause\\\": \\\"ORDER BY\\\", \\\"original_clause\\\": \\\"`employees`.`position`\\\", \\\"items\\\": [ { \\\"item\\\": \\\"`employees`.`position`\\\" } ] /* items */, \\\"resulting_clause_is_simple\\\": true, \\\"resulting_clause\\\": \\\"`employees`.`position`\\\" } /* clause_processing */ }, { \\\"reconsidering_access_paths_for_index_ordering\\\": { \\\"clause\\\": \\\"ORDER BY\\\", \\\"steps\\\": [ ] /* steps */, \\\"index_order_summary\\\": { \\\"table\\\": \\\"`employees`\\\", \\\"index_provides_order\\\": false, \\\"order_direction\\\": \\\"undefined\\\", \\\"index\\\": \\\"unknown\\\", \\\"plan_changed\\\": false } /* index_order_summary */ } /* reconsidering_access_paths_for_index_ordering */ }, { \\\"refine_plan\\\": [ { \\\"table\\\": \\\"`employees`\\\" } ] /* refine_plan */ } ] /* steps */ } /* join_optimization */ }, { \\\"join_execution\\\": { --第三阶段：SQL执行阶段 \\\"select#\\\": 1, \\\"steps\\\": [ ] /* steps */ } /* join_execution */ } ] /* steps */ } \",\"结论：全表扫描的成本低于索引扫描，所以mysql最终选择全表扫描\",\"select * from employees where name > 'zzz' order by position; SELECT * FROM information_schema.OPTIMIZER_TRACE; \",\"查看trace字段可知索引扫描的成本低于全表扫描，所以mysql最终选择索引扫描。\",\"set session optimizer_trace=\\\"enabled=off\\\"; --关闭trace \"]},\"520\":{\"h\":\"常见SQL优化\",\"t\":[\"优化总结：\",\"filesort文件排序方式：\",\"单路排序\",\"是一次性去除满足条件行的所有字段，然后在sort buffer中进行排序；\",\"双路排序\",\"首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行ID，然后在sort buffer中进行排序，排序完后需要再次取回其它需要的字段\",\"MySQL通过比较系统变量max_length_for_sort_data（默认1024字节）的大小和需要查询的字段的总大小来判断使用哪种排序模式。\",\"如果字段的总长度小于max_length_for_sort_data，那么就会使用单路排序模式\",\"如果字段的总长度大于max_length_for_sort_data，那么就会使用双路排序模式\",\"以下面的查询为例：\",\"set session optimizer_trace=\\\"enabled=on\\\",end_markers_in_json=on; --开启trace select * from employees where name = 'zhuge' order by position; select * from information_schema.OPTIMIZER_TRACE; \",\"trace排序部分结果：\",\"\\\"join_execution\\\": { --Sql执行阶段 \\\"select#\\\": 1, \\\"steps\\\": [ { \\\"filesort_information\\\": [ { \\\"direction\\\": \\\"asc\\\", \\\"table\\\": \\\"`employees`\\\", \\\"field\\\": \\\"position\\\" } ] /* filesort_information */, \\\"filesort_priority_queue_optimization\\\": { \\\"usable\\\": false, \\\"cause\\\": \\\"not applicable (no LIMIT)\\\" } /* filesort_priority_queue_optimization */, \\\"filesort_execution\\\": [ ] /* filesort_execution */, \\\"filesort_summary\\\": { --文件排序信息 \\\"rows\\\": 10000, --预计扫描行数 \\\"examined_rows\\\": 10000, --参与排序的行 \\\"number_of_tmp_files\\\": 3, --使用临时文件的个数，这个值如果为0代表全部使用的sort_buffer内存排序，否则使用的磁盘文件排序 \\\"sort_buffer_size\\\": 262056, --排序缓存的大小，单位Byte \\\"sort_mode\\\": \\\"<sort_key, packed_additional_fields>\\\" --排序方式，这里用的单路排序 } /* filesort_summary */ } ] /* steps */ } /* join_execution */ \",\"set max_length_for_sort_data = 10; --employees表所有字段长度总和肯定大于10字节 select * from employees where name = 'zhuge' order by position; select * from information_schema.OPTIMIZER_TRACE; \",\"trace排序部分结果：\",\" \\\"join_execution\\\": { \\\"select#\\\": 1, \\\"steps\\\": [ { \\\"filesort_information\\\": [ { \\\"direction\\\": \\\"asc\\\", \\\"table\\\": \\\"`employees`\\\", \\\"field\\\": \\\"position\\\" } ] /* filesort_information */, \\\"filesort_priority_queue_optimization\\\": { \\\"usable\\\": false, \\\"cause\\\": \\\"not applicable (no LIMIT)\\\" } /* filesort_priority_queue_optimization */, \\\"filesort_execution\\\": [ ] /* filesort_execution */, \\\"filesort_summary\\\": { \\\"rows\\\": 10000, \\\"examined_rows\\\": 10000, \\\"number_of_tmp_files\\\": 2, \\\"sort_buffer_size\\\": 262136, \\\"sort_mode\\\": \\\"<sort_key, rowid>\\\" --排序方式，这里用的双路排序 } /* filesort_summary */ } ] /* steps */ } /* join_execution */ \",\" set session optimizer_trace=\\\"enabled=off\\\"; --关闭trace \",\"单路排序的详细过程：\",\"从索引name找到第一个满足name='zhuge'条件的主键id\",\"根据主键id取出整行，取出所有字段的值，存入sort buffer中\",\"从索引name找到下一个满足name='zhuge'条件的主键id\",\"重复步骤2，步骤3直到不满足name='zhuge'\",\"对sort_buffer中的数据按照字段position排序\",\"返回结果给客户端\",\"双路排序的详细过程：\",\"从索引name找到第一个满足name='zhuge'的主键id\",\"根据主键id取出整行，把排序字段position和主键id这两个字段放到sort buffer中\",\"从索引name取出下一个满足name='zhuge'记录的主键id\",\"重复3、4直到不满足name='zhuge'\",\"对sort_buffer中的字段position和主键id按照字段position进行排序\",\"遍历排序号的id和字段position，按照id的值回到原表中取出所有字段的值返回给客户端\",\"对于单路排序和双路排序两种模式，单路排序会把需要查询的字段都放到sort buffer中，而双路排序只会把主键和需要排序的字段放到sort buffer中进行排序，然后通过主键回到原表查询需要的字段。\",\"如果MySQL排序内存sort buffer配置的比较小并且没有条件继续增加了，可以适当将max_length_for_sort_data配置小点，让优化器选择使用双路排序算法，可以在sort buffer中一次排序更多的行，只是需要再根据主键回到原表取数据。如果MySQL排序内存有条件可以配置的比较大，可以适当增大max_length_for_sort_data的值，让优化器选择全字段排序（单路排序），把需要的字段放到sort buffer中，这样排序后就会直接从内存里返回查询结果了。总而言之，MySQL通过max_length_for_sort_data这个参数来控制排序，在不同场景使用不同的排序模式，从而提升排序效率。\"]},\"521\":{\"h\":\"索引设计原则\",\"t\":[\"代码线上，索引后上\",\"联合索引尽量覆盖条件\",\"不要在小基数字段上建立索引\",\"长字符串我们可以采用前缀索引\",\"where与order by冲突时优先where\",\"基于慢sql查询做优化\"]},\"522\":{\"h\":\"分页查询优化\",\"t\":[\"对于自增且连续的主键排序的分页查询：\",\"select * from employees ORDER BY name limit 90000,5; \",\"可以优化为：\",\"select * from employees where id > 90000 limit 5; \",\"需要注意的是，这样的优化策略并不实用，因为当表中某些记录被删后，主键空缺，会导致结果不一致。另外如果原SQL是order by非主键的字段，上面的方法也会导致两条SQL的结果不一致，所以这种改写得满足以下两个条件：\",\"主键自增且连续\",\"结果是按照主键排序的\",\"根据非主键字段排序的分页查询，查询的SQL如下：\",\"select * from employees ORDER BY name limit 90000,5; \",\"EXPLAIN select * from employees ORDER BY name limit 90000,5; \",\"发现并没有使用name字段的索引（key字段对应的值为null），原因在于扫描整个索引并没有查找到没索引的行（可能要遍历多个索引树）的成本比扫描全表的成本更高，所以优化器放弃使用索引。优化的关键是让排序时返回的字段经可能少，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录，将SQL改写如下：\",\"select * from employees e inner join (select id from employees order by name limit 90000,5) ed on e.id = ed.id; \",\"需要的结果与原 SQL 一致，执行时间减少了一半以上，我们再对比优化前后sql的执行计划：\"]},\"523\":{\"h\":\"Join关联查询优化\",\"t\":[\"-- 示例表： CREATE TABLE `t1` ( `id` int(11) NOT NULL AUTO_INCREMENT, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_a` (`a`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; create table t2 like t1; -- 插入一些示例数据 -- 往t1表插入1万行记录 drop procedure if exists insert_t1; delimiter ;; create procedure insert_t1() begin declare i int; set i=1; while(i<=10000)do insert into t1(a,b) values(i,i); set i=i+1; end while; end;; delimiter ; call insert_t1(); -- 往t2表插入100行记录 drop procedure if exists insert_t2; delimiter ;; create procedure insert_t2() begin declare i int; set i=1; while(i<=100)do insert into t2(a,b) values(i,i); set i=i+1; end while; end;; delimiter ; call insert_t2(); \",\"MySQL的表关联常见的有两种算法：\",\"Nested-Loop Join（嵌套循环连接）算法\",\"Block Nested-Loop Join（基于块的嵌套循环连接）算法\"]},\"524\":{\"h\":\"嵌套循环连接算法\",\"t\":[\"一次一行循环地从第一张表（成为驱动表）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（被驱动表）里取出满足条件的行，然后取出两张表的结果合集。\",\"EXPLAIN select * from t1 inner join t2 on t1.a= t2.a; \",\"一般在join语句中，如果执行计划Extra中未出现Using join buffer则表示使用的join算法是NLJ。\",\"整个过程会读取t2表的所有数据（扫描100行），然后遍历每行数据中字段a的值，根据t2表中的值索引扫描t1表中的对应行（扫描100次t1表的索引，1次扫描可以认为最终只扫描t1表一行完整数据，也就是总共t1表也扫描了100行）。因此整个过程扫描了200行。\",\"如果被驱动表的关联字段没有索引，mysql会Block Nested-Loop Join算法。\"]},\"525\":{\"h\":\"基于块的嵌套循环查询\",\"t\":[\"把驱动表的数据读入到join_buffer中，然后扫描被驱动表，把被驱动表的每一行取出来跟join_buffer中的数据做对比。\",\"EXPLAIN select * from t1 inner join t2 on t1.b= t2.b; \",\"整个过程对表t1和t2都做了一次全表扫描，因此扫描的总行数为10000（表t1的数据总量）+100（表t2的数据总量）=10100。并且join_buffer里的数据是无序的，因此对表t1中的每一行，都要做100次判断，所以内存中的判断次数是100*10000=100万次。\",\"join_buffer的大小是由参数join_buffer_size来设定的，默认值是256k。如果放不下表t2的所有数据的话，会分段放。比如t2表有1000行记录，join_buffer一次只能放800行数据，那么执行过程是先往join_buffer里放800行记录，然后从t1表里取数据跟join_buffer中的数据对比得到部分结果，然后情况buffer，再放入t2表剩余200行记录，再次从t1表里取数据跟join_buffer中数据对比，所以就多扫描了一次t1表。\",\"被驱动表的关联字段没有索引为什么会选择BNL算法而不是用NLJ呢？\",\"如果上面第二条SQL使用NLJ，那么扫描行树为100*10000=100万次，这个是磁盘扫描。\",\"很显然，用BNL磁盘扫描次数少很多，相比于磁盘扫描，BNL的内存计算也会快得多，因此MySQL对于被驱动表的关联字段没有索引的关联查询，一般都会使用BNL算法，如果有索引一般选择NLJ算法，有索引的情况下，NLJ算法比BNL算法性能更高。\",\"可以总结一下，对于关联sql的优化策略：\",\"关联字段加索引\",\"小表驱动大表·和exsits优化\",\"select * from A where id in (select id from B) \",\"优化为：\",\"select * from A where exists (select 1 from B where B.id = A.id) \",\"优化原则：小表驱动大表，即小的数据集驱动大的数据集。\"]},\"526\":{\"h\":\"count(*)查询优化\",\"t\":[\"-- 临时关闭mysql查询缓存，为了查看sql多次执行的真实时间 set global query_cache_size=0; set global query_cache_type=0; EXPLAIN select count(1) from employees; EXPLAIN select count(id) from employees; EXPLAIN select count(name) from employees; EXPLAIN select count(*) from employees; \",\"这四种查询的效率比较：\",\"字段有索引\",\"字段无索引\",\"count(1)和count(字段)执行过程类似，\",\"count(*)的优化常见优化方法有四种。\",\"查询MySQL自己维护的总行数，对于myisam存储引擎的表不做不带where条件的count查询性能是很高的，因为myisam存储的引擎的表的总行数会被mysql存储在磁盘上，查询不需要计算：\",\"对于innodb存储引擎的表mysql不会存储表的总记录行数（因为有MVCC机制），查询count需要实时计算。\",\"也可以使用show table status来优化查询，如果值需要知道表的总行数的估计值可以用如下sql查询，性能很高：\",\"也可以将总数维护到Redis里，插入或删除数据行的时候同时维护Redis里面的表总行数key的计数值（用incr或decr命令），但是这种方式可能不准，很难保证操作和Redis操作的事务的一致性。\",\"最后一种方式是，插入或删除表数据行的时候同时维护计数表，让他们在同一个事务里面操作。\"]},\"527\":{\"h\":\"MySQL数据类型的选择\",\"t\":[\"在MySQL中，选择正确的数据类型，对于性能至关重要。一般应该遵循下面两步：\",\"确定合适的大类型：数字、字符串、时间、二进制；\",\"确定具体的类型：有无符号、取值范围、变长定长等。\",\"在MySQL数据类型设置方面，尽量用更小的数据类型，因为它们通常有更好的性能，花费更少的硬件资源。并且，尽量把字段定义为NOT NULL，避免使用NULL。\"]},\"528\":{\"h\":\"数值类型\",\"t\":[\"类型\",\"大小\",\"范围（有符号）\",\"范围（无符号）\",\"用途\",\"TINYINT\",\"1 字节\",\"(-128, 127)\",\"(0, 255)\",\"小整数值\",\"SMALLINT\",\"2 字节\",\"(-32 768, 32 767)\",\"(0, 65 535)\",\"大整数值\",\"MEDIUMINT\",\"3 字节\",\"(-8 388 608, 8 388 607)\",\"(0, 16 777 215)\",\"大整数值\",\"INT或INTEGER\",\"4 字节\",\"(-2 147 483 648, 2 147 483 647)\",\"(0, 4 294 967 295)\",\"大整数值\",\"BIGINT\",\"8 字节\",\"(-9 233 372 036 854 775 808, 9 223 372 036 854 775 807)\",\"(0, 18 446 744 073 709 551 615)\",\"极大整数值\",\"FLOAT\",\"4 字节\",\"(-3.402 823 466 E+38, 1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)\",\"0, (1.175 494 351 E-38, 3.402 823 466 E+38)\",\"单精度浮点数值\",\"DOUBLE\",\"8 字节\",\"(1.797 693 134 862 315 7 E+308, 2.225 073 858 507 201 4 E-308), 0, (2.225 073 858 507 201 4 E-308, 1.797 693 134 862 315 7 E+308)\",\"0, (2.225 073 858 507 201 4 E-308, 1.797 693 134 862 315 7 E+308)\",\"双精度浮点数值\",\"DECIMAL\",\"对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2\",\"依赖于M和D的值\",\"依赖于M和D的值\",\"小数值\",\"建议：\",\"如果整形数据没有负数，如ID号，建议指定为UNSIGNED无符号类型，容量可以扩大一倍。\",\"建议使用TINYINT代替ENUM、BITENUM、SET。\",\"避免使用整数的显示宽度(参看文档最后)，也就是说，不要用INT(10)类似的方法指定字段显示宽度，直接用INT。\",\"DECIMAL最适合保存准确度要求高，而且用于计算的数据，比如价格。但是在使用DECIMAL类型的时候，注意长度设置。\",\"建议使用整形类型来运算和存储实数，方法是，实数乘以相应的倍数后再操作。\",\"整数通常是最佳的数据类型，因为它速度快，并且能使用AUTO_INCREMENT。\"]},\"529\":{\"h\":\"日期和时间\",\"t\":[\"类型\",\"大小(字节)\",\"范围\",\"格式\",\"用途\",\"DATE\",\"3\",\"1000-01-01 到 9999-12-31\",\"YYYY-MM-DD\",\"日期值\",\"TIME\",\"3\",\"'-838:59:59' 到 '838:59:59'\",\"HH:MM:SS\",\"时间值或持续时间\",\"YEAR\",\"1\",\"1901 到 2155\",\"YYYY\",\"年份值\",\"DATETIME\",\"8\",\"1000-01-01 00:00:00 到 9999-12-31 23:59:59\",\"YYYY-MM-DD HH:MM:SS\",\"混合日期和时间值\",\"TIMESTAMP\",\"4\",\"1970-01-01 00:00:00 到 2038-01-19 03:14:07\",\"YYYYMMDDhhmmss\",\"混合日期和时间值，时间戳\",\"建议：\",\"MySQL能存储的最小时间粒度为秒。\",\"建议用DATE数据类型来保存日期。MySQL中默认的日期格式是yyyy-mm-dd。\",\"用MySQL的内建类型DATE、TIME、DATETIME来存储时间，而不是使用字符串。\",\"当数据格式为TIMESTAMP和DATETIME时，可以用CURRENT_TIMESTAMP作为默认（MySQL5.6以后），MySQL会自动返回记录插入的确切时间。\",\"TIMESTAMP是UTC时间戳，与时区相关。\",\"DATETIME的存储格式是一个YYYYMMDD HH:MM:SS的整数，与时区无关，你存了什么，读出来就是什么。\",\"除非有特殊需求，一般的公司建议使用TIMESTAMP，它比DATETIME更节约空间，但是像阿里这样的公司一般会用DATETIME，因为不用考虑TIMESTAMP将来的时间上限问题。\",\"有时人们把Unix的时间戳保存为整数值，但是这通常没有任何好处，这种格式处理起来不太方便，我们并不推荐它。\"]},\"530\":{\"h\":\"字符串\",\"t\":[\"类型\",\"大小\",\"用途\",\"CHAR\",\"0-255字节\",\"定长字符串，char(n)当插入的字符数不足n时(n代表字符数)，插入空格进行补充保存。在进行检索时，尾部的空格会被去掉。\",\"VARCHAR\",\"0-65535 字节\",\"变长字符串，varchar(n)中的n代表最大字符数，插入的字符数不足n时不会补充空格\",\"TINYBLOB\",\"0-255字节\",\"不超过 255 个字符的二进制字符串\",\"TINYTEXT\",\"0-255字节\",\"短文本字符串\",\"BLOB\",\"0-65 535字节\",\"二进制形式的长文本数据\",\"TEXT\",\"0-65 535字节\",\"长文本数据\",\"MEDIUMBLOB\",\"0-16 777 215字节\",\"二进制形式的中等长度文本数据\",\"MEDIUMTEXT\",\"0-16 777 215字节\",\"中等长度文本数据\",\"LONGBLOB\",\"0-4 294 967 295字节\",\"二进制形式的极大文本数据\",\"LONGTEXT\",\"0-4 294 967 295字节\",\"极大文本数据\",\"建议：\",\"字符串的长度相差较大用VARCHAR；字符串短，且所有值都接近一个长度用CHAR。\",\"CHAR和VARCHAR适用于包括人名、邮政编码、电话号码和不超过255个字符长度的任意字母数字组合。那些要用来计算的数字不要用VARCHAR类型保存，因为可能会导致一些与计算相关的问题。换句话说，可能影响到计算的准确性和完整性。\",\"尽量少用BLOB和TEXT，如果实在要用可以考虑将BLOB和TEXT字段单独存一张表，用id关联。\",\"BLOB系列存储二进制字符串，与字符集无关。TEXT系列存储非二进制字符串，与字符集相关。\",\"BLOB和TEXT都不能有默认值。\"]},\"531\":{\"h\":\"MySQL事务与锁\",\"t\":[\"参考：http://note.youdao.com/noteshare?id=354ae85f3519bac0581919a458278a59&sub=9A8237E2B9B248B9A2F5FC5AED6CBCF1\"]},\"532\":{\"h\":\"事务及其属性\",\"t\":[\"并发事务处理带来的问题：\",\"更新丢失或脏写\",\"当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事务所做的更新。\",\"脏读\",\"事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。\",\"不可重复读\",\"事务A内部相同查询语句在不同时刻读出的结果不一致，不符合隔离性。\",\"幻读\",\"事务A读取到了事务B提交的新增数据，不符合隔离性。\",\"事务的隔离级别：\",\"隔离级别\",\"脏读(Dirty Read)\",\"不可重复读(NonRepeatable Read)\",\"幻读(Phantom Read)\",\"读未提交(Read uncommitted)\",\"可能\",\"可能\",\"可能\",\"读已提交(Read committed)\",\"不可能\",\"可能\",\"可能\",\"可重复读(Repeatableread)\",\"不可能\",\"不可能\",\"可能\",\"可串行化(Serializable)\",\"不可能\",\"不可能\",\"不可能\",\"数据库的事务隔离级别越严格，并发的副作用就越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。\",\"查看当前数据库的事务隔离级别：\",\"show variables like 'tx_isolation'; \",\"设置事务隔离级别：\",\"set tx_isolation='REPEATABLE-READ'; \",\"MySQL默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用MySQL设置的隔离级别，如果Spring设置了就用已经设置的隔离级别。\"]},\"533\":{\"h\":\"MySQL中的锁的分类\",\"t\":[\"锁是计算机协调多个进程或线程并发访问某一资源的机制。\",\"在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。\",\"从性能上分为乐观锁（用版本对比来实现）和悲观锁；\",\"从对数据操作的粒度分，分为表锁和行锁；\",\"从对数据库操作的类型分，分为读锁和写锁（都属于悲观锁），还有意向锁；\",\"读锁：\",\"写锁：\",\"意向锁：\",\"意向锁主要分为：\",\"意向共享锁，IS锁，对整个表加共享锁之前，需要先获取到意向共享锁\",\"意向拍他锁，IX锁，对整个表加拍他锁之前，需要先获取到意向排他锁\"]},\"534\":{\"h\":\"表锁\",\"t\":[\"每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；一般用在整表数据迁移的场景。\",\"--建表SQL CREATE TABLE `mylock` ( `id` INT (11) NOT NULL AUTO_INCREMENT, `NAME` VARCHAR (20) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = MyISAM DEFAULT CHARSET = utf8; --插入数据 INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES ('1', 'a'); INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES ('2', 'b'); INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES ('3', 'c'); INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES ('4', 'd'); \",\"手动增加表锁：\",\"lock table 表名称 read(write),表名称2 read(write); \",\"查看表上加过的锁：\",\"show open tables; \",\"删除表锁：\",\"unlock tables; \"]},\"535\":{\"h\":\"行锁\",\"t\":[\"每次操作锁住一行数据，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度最高。\",\"MyISAM在执行查询语句SELECT前会给涉及的所有表加读锁，在执行update、insert、delete操作会自动给涉及的表加写锁。\",\"InnoDB在执行查询语句SELECT时（非串行隔离级别），不会加锁，但是update、insert、delete操作会加行锁。简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁组会把读和写都阻塞。\",\"可以基于以下实例来分析行锁。\",\"CREATE TABLE `account` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `balance` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO `test`.`account` (`name`, `balance`) VALUES ('lilei', '450'); INSERT INTO `test`.`account` (`name`, `balance`) VALUES ('hanmei', '16000'); INSERT INTO `test`.`account` (`name`, `balance`) VALUES ('lucy', '2400'); \",\"MySQL的乐观锁：\",\"update account set balance = balance - 50 where id = 1 \",\"这主要是由于MySQL在可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本号，是当前读（当前版本）。\"]},\"536\":{\"h\":\"间隙锁\",\"t\":[\"间隙锁，锁住的是两个值之间的空隙，间隙锁在某些情况下可以解决幻读的问题。假设account表里的数据如下：\",\"如果执行下面的SQL：\",\"update account set name = 'zhuge' where id > 8 and id < 18; \",\"那么产生的间隙就有id为(3,10)，(10,20)，(20,正无穷)这三个区间。此时其他Session没法在这个范围锁包含的所有行记录（包含间隙行记录）以及行记录所在的间隙里插入或修改任何数据，即id在(3,20]区间都无法修改数据，注意20也包含在内。\",\"间隙锁只有在可重复读的隔离级别下才会生效的。\"]},\"537\":{\"h\":\"临键锁\",\"t\":[\"临键锁是行锁与间隙锁的组合，上面的例子中(3,20]的整个区间就可以叫做临键锁。\",\"在可重复读的隔离级别下，锁主要是加在索引上，如果对非索引字段更新，行锁可能会变表锁，即无索引行锁会升级为表锁。\",\"锁定某一行还可以用lock in share（共享锁）和for update（排他锁），例如：\",\"select * from test_innodb_lock where a = 2 for update; \",\"这样其他session只能读这行数据，修改则会被阻塞，直到锁定行的session提交。\"]},\"538\":{\"h\":\"行锁分析\",\"t\":[\"可以通过下面的SQL语句查询数据的行锁的情况：\",\"show status like 'innodb_row_lock%'; \",\"各个变量的含义：\",\"Innodb_row_lock_current_waits: 当前正在等待锁定的数量\",\"Innodb_row_lock_time: 从系统启动到现在锁定总时间长度\",\"Innodb_row_lock_time_avg: 每次等待所花平均时间\",\"Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花时间\",\"Innodb_row_lock_waits: 系统启动后到现在总共等待的次数\",\"其中比较重要的有Innodb_row_lock_time_avg（等待平均时长）、Innodb_row_lock_waits（等待总次数）、Innodb_row_lock_time（等待总时长）。尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。\",\"查看INFORMATION_SCHEMA系统库锁相关数据表：\",\"-- 查看事务 select * from INFORMATION_SCHEMA.INNODB_TRX; -- 查看锁 select * from INFORMATION_SCHEMA.INNODB_LOCKS; -- 查看锁等待 select * from INFORMATION_SCHEMA.INNODB_LOCK_WAITS; -- 释放锁，trx_mysql_thread_id可以从INNODB_TRX表里查看到 kill trx_mysql_thread_id -- 查看锁等待详细信息 show engine innodb status\\\\G; \"]},\"539\":{\"h\":\"锁优化建议\",\"t\":[\"尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁\",\"合理设计索引，尽量缩小锁的范围\",\"尽可能减少检索条件范围，避免间隙锁\",\"尽可能控制事务大小，减少锁定资源量和实践长度，涉及事务加锁的sql尽量放在事务的最后执行\",\"尽可能低级别事务隔离\"]},\"540\":{\"h\":\"MVCC与BufferPool缓冲机制\",\"t\":[\"参考：http://note.youdao.com/noteshare?id=b36b975188fadf7bfbfd75c0d2d6b834&sub=5A7459FE4B464EC896F9DD9A4EB64942\",\"MySQL在读已提交和可重复读的隔离级别下的隔离性都依靠MVCC（Multi-Version Concurrency Control）机制来实现，对一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性，避免了频繁加锁互斥。只有在串行化的隔离级别下，为了保证比较高的隔离性，是通过将所有操作加锁互斥来实现的。\"]},\"541\":{\"h\":\"MVCC机制\",\"t\":[\"在了解MVCC多版本并发控制之前，我们必须首先了解一下，什么是MySQL InnoDB下的当前读和快照读。\",\"当前读：读取记录最新的版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁，select lock in share mode(共享锁),select for update,update,insert,delete（排他锁），这些都是当前读。\",\"快照读：不加锁的非阻塞读。快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读，之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC，可以认为MVCC是行锁的一个变种，但是在很多情况下，避免了加锁操作，降低了开销。需要注意的是，快照读读到的并不一定是数据的最新版本，而有可能是之前的历史版本。\",\"当前读实际上是一个悲观锁的操作，而MVCC实现了快照读和写冲突不加锁。\",\"多版本并发控制（MVCC）是一种解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。所以MVCC可以为数据库解决一下问题：在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能，同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题。\"]},\"542\":{\"h\":\"undo日志版本链与read view机制详解\",\"t\":[\"数据库当中的每一行记录除了我们自定义的字段外，还有数据库隐式定义的DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR等字段，它们的含义如下：\",\"DB_ROW_ID（6byte），隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引\",\"DB_TRX_ID（6byte），最近修改（修改/插入）事务ID，记录创建这条记录/最后一次修改该记录的事务ID\",\"DB_ROLL_PTR（7byte），回滚指针，指向这条记录的上一个版本（存储于rollback segment里）\",\"DELETE_BIT（1byte），记录被更新或删除并不代表真的删除，而是删除的flag变了\",\"上图中，DB_ROW_ID是数据库默认为改行记录生成唯一隐式主键，DB_TRX_ID是当前操作该记录的事务ID，而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本。\",\"InnoDB把这些为了回滚而记录的这些东西称之为undo log，需要注意的是，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作时，并不需要记录相应的undo log。undo log主要分为3种：\",\"Insert undo log：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了\",\"Update undo log：修改一条记录时，至少要把修改这条记录之前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了\",\"Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了 \",\"删除操作都只是设置一下老记录的DELETE_BIT，并不真正将过时的记录删除\",\"为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETE_BIT为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view），如果某个记录的DELETED_BIT为true。并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。\",\"对MVCC有帮助的实质是update undo log，undo log实际上就是存在rollback segment中旧记录链，它的执行流程如下：\",\"比如有一个事务插入person表插入了一条新的记录，name为Jerry，age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL\",\"现在来了一个事务1对该记录的name做出了修改，改为Tom，修改的数据的过程如下：\",\"在事务1修改该行数据时，数据库会先对该行加排他锁\",\"然后把该行数据拷贝到undo log中，作为旧记录，即在undo log中有当前行的拷贝副本\",\"拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID，我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录\",\"事务提交后，释放锁\",\"假设又来了事务2修改person表的同一条记录，将age修改为30岁，修改数据的过程如下：\",\"在事务2修改该行数据时，数据先加行锁\",\"然后把改行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log的最前面\",\"修改该行age为30岁，并且修改隐藏字段的事务ID作为当前事务2的ID，就是2，回滚指针指向刚刚拷贝到undo log的副本记录\",\"事务提交，释放锁\",\"从上面的过程可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本先行表，即链接，undo log的链首就是最新的旧记录，链尾就是最早的旧记录。当事务提交后，purge线程会清除掉没有用的节点。\",\"MySQL会用read view来做可见性的判断，当某个事物执行快照读的时候，对该记录创建一个Read view读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，即可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。\",\"Read view遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read view维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID，那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本。\",\"/* 判断某个事务的修改对当前事务是否可见 */ bool changes_visible(){ /** * 可见的情况： * 1. 小于低水位线，即创建快照时，该事务已经提交(或回滚) * 2. 事务ID是当前事务。 */ if (id < m_up_limit_id || id == m_creator_trx_id) { return(true); } if (id >= m_low_limit_id) { /* 高于水位线不可见，即创建快照时，该事务还没有提交 */ return(false); } else if (m_ids.empty()) { /* 创建快照时，没有其它活跃的读写事务时，可见 */ return(true); } /** * 执行到这一步，说明事务ID在低水位和高水位之间，即 id ∈ [m_up_limit_id, m_low_limit_id) * 需要判断是否属于在活跃事务列表m_ids中， * 如果在，说明创建快照时，该事务处于活跃状态（未提交），修改对当前事务不可见。 */ // 获取活跃事务ID列表，并使用二分查找判断事务ID是否在 m_ids中 const ids_t::value_type* p = m_ids.data(); return(!std::binary_search(p, p + m_ids.size(), id)); } \",\"Read View有三个全局属性：\",\"trx_list未提交事务ID列表，用来维护Read View生成时刻系统正活跃的事务ID\",\"up_limit_id记录trx_list列表中事务ID最小的ID\",\"low_limit_id ReadView生成时刻系统尚未分配下一个事务ID，也就是目前已出现过的事务ID的最大值+1\",\"undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，MySQL会保留修改前的数据undo回滚日志，并且用两个隐藏字段trx_id（事务ID）和roll_pointer（上一条数据的历史版本指针）把这些undo日志串联起来形成一个历史记录版本链，具体如下图。\",\"在可重复读的隔离级别下，当事务开启后，执行任何查询sql时会生成当前事务的一致性视图read-view，该视图在事务结束之前都不会变化（如果是读已提交的隔离级别会在每次执行查询sql时都会重新生成），这个视图由执行查询时所有未提交事务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。\",\"版本链的比对规则如下：\",\"如果row的trx_id落在绿色部分（trx），表示在这个版本是由已提交的事务生成的，这个事务是可见的\",\"如果row的trx_id落在红色部分，表示这个版本是由将来启动的事务生成的，是不可见的（若row的trx_id就是当前自己的事务是可见的）\",\"如果row的trx_id落在黄色部分，此时包含两种情况： \",\"如果row的trx_id在视图数组中，表示这个版本是由还未提交的事务生成的，不可见（若row的trx_id就是当前自己的事务则是可见的）\",\"如果row的trx_id不在视图数组中，表示这个版本已经提交了的事务生成的，事务是可见的\",\"对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的trx_id，同时在该条记录的头信息（record header）里的（deleted_flag）标记位写上true，来表示当前记录已经被删除，在查询时按照上面的规则查到对应的记录如果delete_flag 标记位为true，意味着记录已被删除，则不返回数据。\",\"begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个修改InnoDB操作的语句，事务才真正启动，才会向mysql申请事务id，mysql内部是严格按照事务的启动顺序来分配事务id的。\",\"总而言之，MVCC机制的实现就是通过read-view机制与undo版本链对比机制，使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上的不同版本数据。\",\"RC，RR级别下的InnoDB快照读有什么不同？\",\"正式Read view生成时机的不同，从而造成RC、RR级别下快照读的结果不同。\",\"在RR级别下的某个事务对某条记录的第一次快照读会创建一个快照及Read View，将当前活跃的其他的事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见。即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见\",\"在RC级别下的事务中，每次读快照都会重新生成一个快照和Read View，这就是为什么我们可以在RC级别下的事务中可以看到别的事务提交的更新的原因\",\"总而言之，在RC隔离级别下，是每个快照读都会生成并获取最新的Read View，而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View，之后的快照读获取的都是同一个Read View。\"]},\"543\":{\"h\":\"BufferPool缓存机制\",\"t\":[\"为什么MySQL不直接更新磁盘上的数据而是设计了这么复杂的一套机制来执行SQL？\",\"主要是因为来一个请求就直接对磁盘文件进行随机读写，由于磁盘随机读写的相比顺序读写的性能是非常差的，所以直接更新磁盘文件里的数据性能会很差。MySQL的这套机制看起来虽然复杂，但是它可以保证每个更新请求都是更新内存中的BufferPool，然后顺序写日志文件，同时还能保证各种异常情况下的数据一致性。更新内存的数据的性能是很高的，顺序写磁盘上的日志文件的性能也是很高的，正是这两点，才能让MySQL拥有较高的并发能力。\"]},\"544\":{\"h\":\"MySQL成本分析\",\"t\":[\"在MySQL5.6之前的版本来说，只能通过EXPLAIN语句查看到最后优化器决定使用的执行计划，却无法知道它为什么做这个决策。在MySQL5.6之后的版本中，MySQL提出了optimizer trace的功能，这个功能可以让我们方便的查看优化器执行计划的整个过程。\",\"SET optimizer_trace = \\\"enabled=on\\\"; SELECT * FROM order_exp WHERE order_no IN ('DD00_6S', 'DD00_9S', 'DD00_10S') AND expire_time > '2021-03-22 18:28:28' AND expire_time <= '2021-03-22 18:35:09' AND insert_time > expire_time AND order_note LIKE '%7排1%' AND order_status = 0; SELECT * FROM information_schema.OPTIMIZER_TRACE; \",\"可以看见全表扫描的成本：2169.9：\",\"使用索引idx_order_no的成本为72.61:\",\"使用索引idx_expire_time的成本为47.81：\",\"最终MySQL使用了idx_expire_time作为这个SQL查询过程中索引：\"]},\"545\":{\"h\":\"MySQL查询成本\",\"t\":[\"参考链接：Mysql内核查询成本计算实战。\",\"一条查询语句的执行成本是由下面这两个方面组成的：\",\"IO成本：MyISAM、InnoDB存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。从磁盘到内存这个加载的过程损耗的时间称之为IO成本\",\"CPU成本：读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为CPU成本。对于InnoDB存储引擎来说，页是磁盘和内存之间交互的基本单位，MySQL规定读取一个页面花费的成本默认是1.0，读取以及检测一条记录是否符合搜索条件的成本默认是0.2。1.0、0.2这些数字称之为成本常数，这两个成本常数是我们最常用到的，也有一些其他的成本常数。\",\"注意，不管读取记录时需不需要检测是否满足搜索条件，其成本都算是0.2。\"]},\"546\":{\"h\":\"单表查询的成本\",\"t\":[\"在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的执行计划，之后才会调用存储引擎提供的接口真正的执行查询，这个过程总结一下就是这样：\",\"根据搜索条件，找出所有可能使用的索引\",\"计算全表扫描的代价\",\"计算使用不同索引执行查询的代价\",\"对比各种执行方案的代价，找出成本最低的那一个\"]},\"547\":{\"h\":\"根据搜索条件，找出所有可能使用的索引\",\"t\":[\"我们仍然使用如下查询语句来分析：\",\"SELECT * FROM order_exp WHERE order_no IN ('DD00_6S', 'DD00_9S', 'DD00_10S') AND expire_time > '2021-03-22 18:28:28' AND expire_time <= '2021-03-22 18:35:09' AND insert_time > expire_time AND order_note LIKE '%7排1%' AND order_status = 0; \",\"上述查询中涉及到几个搜索条件：\",\"order_no IN ('DD00_6S', 'DD00_9S', 'DD00_10S') ，这个搜索条件可以使用二级索引idx_order_no\",\"expire_time> '2021-03-22 18:28:28' AND expire_time<= '2021-03-22 18:35:09'，这个搜索条件可以使用二级索引idx_expire_time\",\"insert_time> expire_time，这个搜索条件的索引列由于没有和常数比较，所以并不能使用索引\",\"order_note LIKE '%hello%'，order_note即使有索引，但是通过LIKE操作符和以通配符开头的字符串做比较，不可以使用索引\",\"order_status = 0，由于该列上只有联合索引，而且不符合最左前缀原则，所以不会用到索引\",\"综上所述，上边的查询语句可能用到的索引，也就是possible keys只有idx_order_no，idx_expire_time。\"]},\"548\":{\"h\":\"计算全表扫描的代价\",\"t\":[\"对于InnoDB存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都一次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。由于查询成本=I/O成本+CPU成本，所以计算全表扫描的代价需要两个信息：聚簇索引占用的页面数、该表中的记录数。\",\"MySQL为每个表维护了一系列的统计信息，并且可以通过如下语句查询：\",\"SHOW TABLE STATUS LIKE 'order_exp'; \",\"我们需要的两个统计项：\",\"Rows：这个选项表示表中的记录条数。对于使用MyISAM存储引擎的表来说，该值是准确的，对于使用InnoDB存储引擎的表来说，该值是一个估计值。所以order_exp表实际由10567条记录，但是Rows显示有10354条记录\",\"Data_length：这个选项表示表占用的存储空间字节数。使用MyISAM存储引擎的表来说，该值就是数据文件的大小，对于使用InnoDB存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小，也就是说可以这样计算该值的大小：Data_length = 聚簇索引的页面数量✖️每个页面的大小，order_exp使用默认16KB的页面大小，通过Data_length可以聚簇索引的页面数量 = 1589248 ➗ 16 ➗ 1024 = 97，也就是说，该表的聚簇索引的记录数为97\",\"现在就可以根据聚簇索引占用的页面数量以及该表记录数的估计值，来计算全表扫描成本：\",\"IO成本 = 97 ✖️ 1.0 + 1.1 = 98.1（1.1指是加载一个页面的IO成本常数，后面的1.0是一个微调值）\",\"CPU成本 = 10354 ✖️ 0.2 + 1.0 = 2071.8（10354值的统计数据中表的记录数，对于InnoDB存储引擎来说是一个估计值，0.2指的是访问一条记录所需的CPU成本常数，后面的1.0是一个微调值）\",\"MySQL在真实计算成本时会进行一些微调，这些微调的值是直接硬编码到代码里的，没有注释而且这些微调的值十分的小，并不影响我们大方向上的分析。\",\"所以全表扫描的总成本 = 98.1 + 2071.8= 2169.9。\",\"虽然表中的记录其实都存储在聚簇索引对应B+树的叶子结点中，所以只要我们通过根节点获得了最左边的叶子节点。就可以沿着叶子节点组成的双向链表把所有记录都查看一遍。也就是说全表扫描这个过程其实有的B+树非叶子结点是不需要访问的。但是MySQL在计算全表扫描成本时直接使用聚簇索引占用的页面数作为计算IO成本的依据，是不区分非叶子结点和叶子结点的。\"]},\"549\":{\"h\":\"计算使用不同索引执行查询的代价\",\"t\":[\"从上一步分析我们可以得出，上述查询可能使用到idx_order_no，idx_expire_time这两个索引，我们需要分别分析单独使用这些索引执行查询的成本，最后还要分析是否可能会使用到索引合并。MySQL查询优化器先分析使用唯一二级索引的成本，再分析使用普通索引的成本，我们这里有两个索引，先算哪个都可以。我们先分析idx_expire_time的成本，然后再看使用idx_order_no的成本。\",\"idx_expire_time对应的搜索条件是：AND expire_time > '2021-03-22 18:28:28' AND expire_time <= '2021-03-22 18:35:09'，也就是说对应的范围区间是('2021-03-22 18:28:28' , '2021-03-22 18:35:09' )。使用idx_expire_time搜索会使用二级索引+回表方式的查询，MySQL计算这种查询的成本以来两个方面的数据：\",\"范围区间数量\",\"需要回表的记录数\",\"接下来我们分别计算这两个数据。\",\"不论某个范围区间的二级索引到底占用了多少页面，查询优化器认为读取索引的一个范围区间的IO成本和读取一个页面是相同的。本例中使用idx_expire_time的范围区间只有一个，所以相当于访问这个范围区间的二级索引付出的IO成本就是：1✖️ 1.0 = 1.0。\",\"优化器需要计算二级索引的某个范围区间到底包含多少条记录，对于本例来说就是要计算('2021-03-22 18:28:28' , '2021-03-22 18:35:09' )这个范围区间内包含多少二级索引记录，计算过程如下：\",\"先根据expire_time > '2021-03-22 18:28:28'这个条件访问id_expire_time对应的B+树索引，找到满足expire_time > '2021-03-22 18:28:28'这个条件的第一条记录，我们把这条记录称之为区间最左记录。我们前面说过在B+树中定位到一条记录的过程是很快的，是常数级别的，所以这个过程的性能消耗是可以忽略不计的\",\"然后再根据expire_time <= '2021-03-22 18:35:09这个条件继续从id_expire_time对应的B+树索引中找出最后一条满足这个条件的记录，我们把这条记录称之为区间最右记录，这个过程的性能消耗也可以忽略不计的\",\"如果区间最左记录和区间最右记录相隔不太远（在MySQL 5.7这个版本里，只要相隔不大于10个页面即可），那就可以精确统计出AND expire_time > '2021-03-22 18:28:28' AND expire_time <= '2021-03-22 18:35:09'条件的二级索引记录条数。否则只沿着区间最左记录向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以区间最左记录和区间最右记录之间的页面数量就可以了\",\"估计区间最左记录和区间最右记录之间有多少个页面，是根据B+树索引的结构来的。我们假设区间最左记录在页b中，区间最右记录在页c中，那么我们要计算区间最左记录和最右记录之间的页面数量就相当于计算页b和页c之间有多少页面，而它们父节点中记录的每一条目录项记录都对应一个数据页，所以计算页b和页c之间有多少页面就相当于计算它们父节点（也就是页a）中对应的目录项记录之间隔着几条记录。在一个页面中统计两条记录之间有几条记录的成本就很小了。\",\"不过还有一个问题，如果页b和页c之间的页面实在太多，以至于页b和页c对应的目录项记录都不在一个父页面中怎么办？既然是树，那就继续递归，B+树的层级并不会很高，所以这个统计过程页不是很耗费性能。\",\"MySQL根据上述算法得到索引项id_expire_time在区间expire_time <= '2021-03-22 18:35:09之间大约有39条记录。\",\"explain SELECT * FROM order_exp WHERE expire_time> '2021-03-22 18:28:28' AND expire_time<= '2021-03-22 18:35:09'; \",\"所以读取这39条二级索引记录需要付出的CPU成本就是：39✖️0.2 + 0.01 = 7.81。其中39是需要读取的二级索引记录条数，0.2是读取一条记录成本常数，0.01是微调。\",\"在通过二级索引获取到记录之后，还需要做两件事儿：\",\"根据这些记录中的主键值到聚簇索引中做回表操作。MySQL评估回表操作的IO成本依旧很简单粗暴，它认为每次回表操作都相当于访问一个页面，也就是说二级索引范围区间有多少记录，就需要进行多少次回表操作，也就是需要进行多少次页面IO。id_expire_time二级索引执行查询时，预计有39条二级索引记录需要进行回表操作，所以回表操作带来的IO成本就是：39✖️1.0=39.0，其中39是预计的二级索引记录数，1.0时一个页面的IO成本常数\",\"回表操作得到的完成用户记录，然后再检测其他搜索条件是否成立。由于我们通过范围区间获取到二级索引记录共39条，也就是对应着聚簇索引中39条完整的用户记录，读取并检测这些完整的用户记录是否符合其余的搜索条件的CPU成本如下：39✖️0.2=7.8。其中39是待检测记录的条数，0.2是检测一条记录是否符合给定的搜索条件的成本常数\",\"所以本例中使用id_expire_time执行查询的成本如下所示：\",\"IO成本：1.0 + 39 ✖️1.0 = 40.0 （范围区间的数量 + 预估的二级索引记录条数）\",\"CPU成本：39 ✖️ 0.2 + 0.01 + 39 ✖️ 0.2 = 15.61（读取二级索引记录的成本 + 读取并检测回表后聚簇索引的成本）\",\"综上所属，使用id_expire_time执行查询的总成本就是：40.0 + 15.6 = 55.61。\",\"按照上述思路我们计算idx_order_no执行查询的成本。\",\"idx_order_no对应的搜索条件是：order_no IN('DD00_6S', 'DD00_9S', 'DD00_10S')，也就是说相当于3个单点区间。与计算idx_expire_time的情况类似，我们也需要计算使用idx_order_no时需要访问的范围区间数量以及需要回表的记录数，计算过程与上面类似。\",\"范围区间数量：使用idx_order_no执行查询时有3个单点区间，所以访问这3个范围区间的二级索引付出的IO成本就是：3✖️1.0=3.0。\",\"需要回表的记录数：由于使用idx_expire_time时有3个单点区间，所以每个单点区间都需要查找一遍对应的二级索引记录数，三个单点区间总共需要回表的记录数是58。\",\"explain SELECT * FROM order_exp WHERE order_no IN ('DD00_6S', 'DD00_9S', 'DD00_10S'); \",\"读取这些二级索引记录的CPU成本就是：58✖️0.2 + 0.01 = 11.61。得到总共需要回表的记录数之后，就要考虑：根据这些记录里的主键值到聚簇索引中做回表操作，所需的IO成本就是：58✖️1.0 = 58.0。回表操作得到的完整用户记录，然后再比较其他搜索条件是否成立，此步骤对应的CPU成本就是：58✖️0.2 = 11.6。\",\"所以本例中使用idx_order_no执行查询的成本就如下所示：\",\"IO成本：3.0 + 58✖️1.0 = 61.0（范围区间内的数量 + 预估的二级索引记录数）\",\"CPU成本：58✖️0.2 + 58✖️0.2 + 0.01 = 23.21（读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）\",\"综上所属，使用idx_order_no执行查询的总成本就是：61.0 + 23.1 = 84.21。\"]},\"550\":{\"h\":\"是否有可能使用索引合并\",\"t\":[\"本例中SQL语句不满足索引合并的条件，所以并不会使用索引合并。而且MySQL查询优化器计算索引合并成本的算法也比较麻烦，我们不去了解。\"]},\"551\":{\"h\":\"对比各种方案，找出成本最低的那一个\",\"t\":[\"下面比较各种可执行方案以及它们对应的成本：\",\"全表扫描的成本：2169.9\",\"使用idx_expire_time的成本：55.61\",\"使用idx_order_no的成本：84.21\",\"显然，使用idx_expire_time的成本最低，所以选择idx_expire_time来执行查询。\",\"全表扫描Tracer的输出：\",\"使用idx_order_no的Tracer的输出：\",\"使用idx_expire_time的Tracer的输出：\",\"这里之所以和我们计算有点不同的原因是，在MySQL的实际计算中，在和全文扫描比较成本时，使用索引的成本会除去读取并检测回表后聚簇索引记录的成本，也就是说，我们通过MySQL看到使用idx_expire_time成本将会是：55.61 - 7.8 = 47.81，idx_order_no的成本就是：84.21 - 11.6 = 72.61。但是MySQL比较完成成本后，会再计算一次使用索引的成本，此时就会加上前面去除的成本，也就是我们计算出来的值。\"]},\"552\":{\"h\":\"基于索引统计数据的成本\"},\"553\":{\"h\":\"index dive\",\"t\":[\"有时候使用索引执行查询时会有许多单点区间，比如使用IN语句就很容易产生非常多的单点区间，比如下面这个查询：\",\"SELECT * FROM order_exp WHERE order_no IN ('aa1', 'aa2', 'aa3', ... , 'zzz'); \",\"显然，这个查询用到的索引就是idx_order_no，由于这个索引并不是唯一二级索引，所以并不能确定一个单点区间对应的二级索引记录的条数有多少，需要我们去计算。就是先把获取索引对应的B+树的区间最左记录和区间最右记录，然后再计算这两条记录之间有多少记录（记录条数少的时候可以做到精确计算，多的时候只能估算）。MySQL把这种通过直接访问索引对应的B+树来计算某个范围区间对应的索引记录条数的方式称之为index dive。\",\"有零星几个单点区间的话，使用index dive的方式去计算这些单点区间对应的记录数也不是什么问题，如果IN语句里的参数过多，比如有2000个参数怎么办？\",\"这就意味着MySQL的查询优化器为了计算这些单点区间的索引记录条数，要进行2000次的index dive操作，这样做性能损耗很大，搞不好计算这些单点区间对应的索引记录条数的成本比直接全表扫描的成本都大了。MySQL考虑到这种情况，所以提供了一个系统变量eq_range_index_dive_limit，MySQL 5.7.21中这个系统变量的默认值：\",\"show variables like '%dive%'; \",\"也就是说IN语句中的参数个数小于200的话，将使用index dive的方式计算各个单点区间对应的记录数，如果大于或等于200个的话，可就不能使用index dive了，要使用所谓的索引统计数据来进行估算。类似上述的，MySQL 会为每个表维护一份统计数据，查看某个表索引的统计数据可以使用SHOW INDEX FROM表名的语法，比如我们要查看order_exp的各个索引的统计数据可以这么写：\",\"show index from order_exp; \",\"详细含义：\",\"属性\",\"描述\",\"Table\",\"索引所属表的名称。\",\"Non_unique\",\"索引列的值是否是唯一的，聚簇索引和唯一二级索引的该列值为0，普通二级索引该列值为1。\",\"Key_name\",\"索引的名称。\",\"Seq_in_index\",\"索引列在索引中的位置，从1开始计数。比如对于联合索引u_idx_day_status，来说，insert_time, order_status, expire_time对应的位置分别是1、2、3。\",\"Column_name\",\"索引列的名称。\",\"Collation\",\"索引列中的值是按照何种排序方式存放的，值为A时代表升序存放，为NULL时代表降序存放。\",\"Cardinality\",\"索引列中不重复值的数量。后边我们会重点看这个属性的。\",\"Sub_part\",\"对于存储字符串或者字节串的列来说，有时候我们只想对这些串的前n个字符或字节建立索引，这个属性表示的就是那个n值。如果对完整的列建立索引的话，该属性的值就是NULL。\",\"Packed\",\"索引列如何被压缩，NULL值表示未被压缩。这个属性我们暂时不了解，可以先忽略掉。\",\"Null\",\"该索引列是否允许存储NULL值。\",\"Index_type\",\"使用索引的类型，我们最常见的就是BTREE，其实也就是B+树索引。\",\"Comment\",\"索引列注释信息。\",\"Index_comment\",\"索引注释信息。\",\"Cardinality属性，Cardinality直译过来就是基数的意思，表示索引列中不重复值的个数，比如对于一个一万行记录的表来说，某个索引列的Cardinality属性是10000，那意味着该列中没有重复的值，如果Cardinality属性是1的话，就意味该列的值全部是重复的。不过需要注意的是，对于InnoDB存储引擎来说，使用SHOW INDEX语句展示出来的某个索引列的Cardinality属性是一个估计值，并不是精确的。\",\"前面说过，当IN语句中的参数个数大于或等于系统变量eq_range_index_limit的值的话，就不会使用index dive的方式计算各个单点区间的索引记录条数，而是使用索引统计数据，这里所指索引统计数据指的是这两个值：\",\"使用SHOW TABLE STATUS展示出的Rows的值，也就是一个表中有多少条记录\",\"使用SHOW INDEX语句展示出的Cardinality属性\",\"结合Rows统计数据，我们可以针对索引列，计算出平均一个值重复多少次。一个值的重复次数 ≈ Rows ÷ Cardinality。\",\"以order_exp表的idx_order_no索引为例，它的Rows值是10354，它对应的Cardinality值是10225，我们可以计算order_no列平均每个值的重复次数就是10354 ÷ 10225 ≈ 1.0126（条）。此时再看上述查询语句：SELECT * FROM order_exp WHERE order_no IN ('aa1', 'aa2', 'aa3', ... , 'zzz');，假设IN语句20000个参数的话，就直接使用统计数据来估算这些参数需要单点区间对应的记录条数了，每个参数大约对应1.012条记录，所以总共需要回表的记录数就是：20000 ✖️ 1.0126 = 20252。\",\"使用统计数据来计算单点区间对应的索引记录条数比index dive的方式简单，但是它的致命缺点就是：不精确。使用统计数据算出来的查询成本与所需的成本可能相差非常大。\",\"MySQL 5.7.3以及之前的版本中，eq_range_index_dive_limit的默认值为10，之后的版本默认值为200。所以如果5.7.3以及之前的版本的话，很容易采用索引统计数据而不是index dive的方式来计算查询成本。当查询中使用到了IN查询，但是却实际没有用到索引，就可以考虑是不是由于eq_range_index_dive_limit的值太小导致的。\",\"我们可以通过如下的语句，查询成本：\",\"EXPLAIN format = json SELECT * FROM order_exp WHERE order_no IN ('DD00_6S', 'DD00_9S', 'DD00_10S') AND expire_time > '2021-03-22 18:28:28' AND expire_time <= '2021-03-22 18:35:09' AND insert_time > expire_time AND order_note LIKE '%7排1%' AND order_status = 0 \",\"这样我们就可以得到一个json格式的执行计划，里面包含计划花费的成本：\",\" { \\\"query_block\\\": { \\\"select_id\\\": 1, # 整个查询语句只有1个SELECT关键字，该关键字对应的id号为1 \\\"cost_info\\\": { \\\"query_cost\\\": \\\"55.61\\\" # 整个查询的执行成本预计为55.61 }, \\\"table\\\": { \\\"table_name\\\": \\\"order_exp\\\", \\\"access_type\\\": \\\"range\\\", \\\"possible_keys\\\": [ \\\"idx_order_no\\\", \\\"idx_expire_time\\\" ], \\\"key\\\": \\\"idx_expire_time\\\", \\\"used_key_parts\\\": [ \\\"expire_time\\\" ], \\\"key_length\\\": \\\"5\\\", \\\"rows_examined_per_scan\\\": 39, \\\"rows_produced_per_join\\\": 0, \\\"filtered\\\": \\\"0.13\\\", \\\"index_condition\\\": \\\"((`mysqladv`.`order_exp`.`expire_time` > '2021-03-22 18:28:28') and (`mysqladv`.`order_exp`.`expire_time` <= '2021-03-22 18:35:09'))\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"55.60\\\", \\\"eval_cost\\\": \\\"0.01\\\", \\\"prefix_cost\\\": \\\"55.61\\\", #单独查询表的成本，也就是：read_cost + eval_cost \\\"data_read_per_join\\\": \\\"24\\\" #和连接查询相关的数据量，单位字节，这里无用 }, \\\"used_columns\\\": [ \\\"id\\\", \\\"order_no\\\", \\\"order_note\\\", \\\"insert_time\\\", \\\"expire_duration\\\", \\\"expire_time\\\", \\\"order_status\\\" ], \\\"attached_condition\\\": \\\"((`mysqladv`.`order_exp`.`order_status` = 0) and (`mysqladv`.`order_exp`.`order_no` in ('DD00_6S','DD00_9S','DD00_10S')) and (`mysqladv`.`order_exp`.`insert_time` > `mysqladv`.`order_exp`.`expire_time`) and (`mysqladv`.`order_exp`.`order_note` like '%7排1%'))\\\" } } } \"]},\"554\":{\"h\":\"连接查询的成本\",\"t\":[\"MySQL中连接查询采用的是嵌套循环连接算法，驱动表会被访问一次，被驱动表可能会被访问多次，所以对于两表连接查询来说，它的查询成本由下面两个部分构成：\",\"单次查询驱动表的成本\",\"多次查询被驱动表的成本（具体查询多少次取决于对被驱动表查询的结果集中有多少条记录）\",\"对驱动表进行查询后得到的记录条数称之为驱动表的扇出（fanout）。很显然驱动表的扇出值越小，对于被驱动表的查询次数也就越少，连接查询的总成本也就越低。当查询优化器想计算整个连接查询所使用的成本时，就需要计算出驱动表的扇出值，有的时候计算扇出值是很容易的，比如下面几个查询。\",\"查询一：\",\"SELECT * FROM order_exp AS s1 INNER JOIN order_exp2 AS s2; \",\"假设使用s1表作为驱动表，很显然对驱动表的单表查询只能使用全表扫描的方式执行，驱动表的扇出值也很明确，那就是驱动表中有多少记录，扇出值就是多少。统计数据中s1表的记录行数是10573，也即是说优化器就直接会把10573当作s1表的扇出值。\",\"查询二：\",\"SELECT * FROM order_exp AS s1 INNER JOIN order_exp2 AS s2 WHERE s1.expire_time> '2021-03-22 18:28:28' AND s1.expire_time<= '2021-03-22 18:35:09'; \",\"仍然假设s1表是驱动表的话，很显然对驱动表的单表查询可以使用idx_expire_time索引执行查询。此时范围区间('2021-03-22 18:28:28', '2021-03-22 18:35:09')中有多少条记录，那么扇出值就是多少。但是有的时候扇出值的计算就变得很棘手，比如下面几个查询：\",\"SELECT * FROM order_exp AS s1 INNER JOIN order_exp2 AS s2 WHERE s1.order_note > 'xyz'; \",\"本查询和查询一类似，只不过对于驱动表s1多了一个order_note > 'xyz'的搜索条件。查询优化器又不会真正的去执行查询，所以它只能猜这10573记录里有多少条记录满足order_note > 'xyz'条件。\",\"查询四：\",\"SELECT * FROM order_exp AS s1 INNER JOIN order_exp2 AS s2 WHERE s1.expire_time> '2021-03-22 18:28:28' AND s1.expire_time<= '2021-03-22 18:35:09' AND s1.order_note > 'xyz'; \",\"本查询和查询二类似，只不过对于驱动表s1也多了一个order_note > 'xyz'的搜索条件。不过因为本查询可以使用idx_expire_time索引，所以只需从符合二级索引范围区间的记录中猜有多少条记录符合order_note > 'xyz'条件，也就是只需要猜39条记录中有多少符合order_note > 'xyz'条件。\",\"查询五：\",\"SELECT * FROM order_exp AS s1 INNER JOIN order_exp2 AS s2 WHERE s1.expire_time> '2021-03-22 18:28:28' AND s1.expire_time<= '2021-03-22 18:35:09' AND s1.order_no IN ('DD00_6S', 'DD00_9S', 'DD00_10S') AND s1.order_note > 'xyz'; \",\"本查询和查询四类似，不过在驱动表s1选取idx_expire_time索引执行查询后，优化器需要从符合二级索引范围内区间的记录中猜有多少条记录符合条件order_no IN ('DD00_6S', 'DD00_9S', 'DD00_10S') 和order_note > 'xyz'。也就是说优化器需要猜在39条记录中有多少符合上述两个条件。\",\"总结一下，MySQL有两种情况需要猜出扇出的值：\",\"如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条\",\"如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条\",\"在MySQL 5.7之前的版本中，查询优化器在计算驱动表扇出时，如果是使用全表扫描的话，就直接使用表中记录的数量作为扇出值，如果使用索引的话，就直接使用满足范围条件的索引记录条数作为扇出值。\",\"在MySQL 5.7中，MySQL引入了启发式规则，将上述中猜的过程称之为condition filtering。这个过程可能会使用到索引，也可能使用到统计数据。condition filtering可以让成本估算更精确，但其过程比较复杂，这里暂时不做探讨。\"]},\"555\":{\"h\":\"两表连接的成本分析\",\"t\":[\"连接查询的成本计算公式：连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本。\",\"对于左（外）连接右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要分别为驱动表和被驱动表选择成本最低的访问方法。\",\"但是对于内连接来说，驱动表和被驱动表的位置是可以互换的，不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序，然后分别为驱动表和被驱动表选择成本最低的访问方法。\",\"显然，计算内连接查询成本的方式更麻烦一些，下面我们以内连接为例来看看如何计算出最优的连接查询方案，比如对如下查询：\",\"SELECT * FROM order_exp s1 INNER JOIN order_exp2 s2 ON s1.order_no = s2.order_note WHERE s1.expire_time > '2021-03-22 18:28:28' AND s1.expire_time <= '2021-03-22 18:35:09' AND s2.expire_time > '2021-03-22 18:35:09' AND s2.expire_time <= '2021-03-22 18:35:59'; \",\"可以选择的连接顺序有两种：\",\"s1连接s2，也就是s1作为驱动表，s2作为被驱动表\",\"s2连接s1，也就是s2作为驱动表，s1作为被驱动表\",\"查询优化器需要分别考虑这两情况下的最优查询成本，然后选区成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。接下来我们分别分析一下这两种情况。\",\"接下来我们分析使用s1作为驱动表的情况。\",\"首先看一下涉及s1表单表的搜索条件有s1.expire_time > '2021-03-22 18:28:28' AND s1.expire_time <= '2021-03-22 18:35:09'，所以这个查询可能会用到idx_expire_time索引，从全表扫描和使用idx_expire_time这两个方案中选出成本最低的那个，很显然使用idx_expire_time执行查询的成本更低些。然后分析对于被驱动表的成本最低的执行方案，此时涉及到被驱动表s2的搜索条件就是：\",\"s2.order_note = 常数（这是因为对驱动表s1结果集中的每一条记录，都需要进行一次被驱动表s2的访问，此时那些设计两表的条件相当于只涉及被驱动表s2了。）\",\"s2.expire_time > '2021-03-22 18:35:09' AND s2.expire_time <= '2021-03-22 18:35:59'\",\"很显然，第一个条件由于order_note没有用到索引，所以并没有什么用，此时访问s2表时可用的方案也是全表扫描和使用idx_expire_time两种，假设使用idx_expire_time的成本更小。所以此时使用s1作为驱动表的总成本就是（暂时不考虑使用join buffer对成本的影响）：\",\"使用idx_expire_time访问s1的成本 + s1的扇出 × 使用idx_expire_time访问s2的成本。\",\"接下来我们分析使用s2作为驱动表的情况。\",\"首先看一下涉及s2表单表的搜索条件有s2.expire_time> '2021-03-22 18:35:09' AND s2.expire_time<= '2021-03-22 18:35:59'，所以这个查询可能使用到idx_expire_time索引，从全表扫描和idx_expire_time这两个方案中选出成本最低的那个，假设使用idx_expire_time执行查询的成本更低些。然后分析对于被驱动表的成本最低的执行方案，此时涉及到被驱动表s1的搜索条件就是：\",\"s1.order_no = 常数\",\"s1.expire_time> '2021-03-22 18:28:28' AND s1.expire_time<= '2021-03-22 18:35:09'\",\"使用s2作为被驱动表与使用s1作为被驱动表有一个区别就是，idx_order_no可以进行ref方式访问，使用idx_expire_time可以使用range方式的访问。那么优化器需要从全表扫描、使用idx_order_no、使用idx_expire_time这几个方案里选出一个成本最低的方案。\",\"这里有一个问题，不同于idx_expire_time的范围区间是确定的，s1.order_no=常数中的常数值我们是不知道，怎么衡量使用idx_order_no执行查询的成本呢？其实直接使用我们前面说过的索引统计数据就可以了（即索引列平均一个值重复多少次）。一般情况下，ref的访问方式要比range成本更低，这里假设使用idx_order_no进行对s1的访问。\",\"所以，使用s2作为驱动表的总成本就是：使用idx_expire_time访问s2的成本 + s2的扇出 × 使用idx_order_no访问s1的成本。\",\"最后优化器会比较这两种方式的最优访问成本，选取其中成本更低的连接顺序去真正的执行查询。从上面的计算过程也可以看出来，一般来讲，连接查询成本占大头的其实是驱动表扇出数 × 单次访问被驱动表的成本，所以我们优化的重点就是下面两个部分\",\"尽量减少驱动表的扇出\",\"对被驱动表的访问成本尽量低\",\"这一点对于我们实际书写连接查询语句时十分有用，我们需要尽量在被驱动表的连接列上建立索引，这样就可以使用ref访问方法来降低访问被驱动表的成本了。如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样就可以把访问被驱动表的成本见到更低了。\",\"连接查询的成本输出：\",\"EXPLAIN format = json SELECT * FROM order_exp s1 INNER JOIN order_exp2 s2 ON s1.order_no = s2.order_note WHERE s1.expire_time > '2021-03-22 18:28:28' AND s1.expire_time <= '2021-03-22 18:35:09' AND s2.expire_time > '2021-03-22 18:35:09' AND s2.expire_time <= '2021-03-22 18:35:59' \",\"成本数据：\",\"{ \\\"query_block\\\": { \\\"select_id\\\": 1,# 整个查询语句只有1个SELECT关键字，该关键字对应的id号为1 \\\"cost_info\\\": { \\\"query_cost\\\": \\\"840.51\\\" # 整个查询的执行成本 }, \\\"nested_loop\\\": [ # 几个表之间采用嵌套循环连接算法执行 { \\\"table\\\": { \\\"table_name\\\": \\\"s2\\\", # s2表是驱动表 \\\"access_type\\\": \\\"range\\\", # 访问方法为range \\\"possible_keys\\\": [ \\\"idx_expire_time\\\" ], \\\"key\\\": \\\"idx_expire_time\\\", \\\"used_key_parts\\\": [ \\\"expire_time\\\" ], \\\"key_length\\\": \\\"5\\\", \\\"rows_examined_per_scan\\\": 321, # 查询s2表大致需要扫描321条记录 \\\"rows_produced_per_join\\\": 321, # 驱动表s2的扇出是321 \\\"filtered\\\": \\\"100.00\\\", # condition filtering代表的百分比 \\\"index_condition\\\": \\\"((`mysqladv`.`s2`.`expire_time` > '2021-03-22 18:35:09') and (`mysqladv`.`s2`.`expire_time` <= '2021-03-22 18:35:59'))\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"386.21\\\", \\\"eval_cost\\\": \\\"64.20\\\", \\\"prefix_cost\\\": \\\"450.41\\\", # 查询s1表总共的成本，read_cost + eval_cost \\\"data_read_per_join\\\": \\\"152K\\\" # 读取的数据量 }, \\\"used_columns\\\": [ \\\"id\\\", \\\"order_no\\\", \\\"order_note\\\", \\\"insert_time\\\", \\\"expire_duration\\\", \\\"expire_time\\\", \\\"order_status\\\" ] } }, { \\\"table\\\": { \\\"table_name\\\": \\\"s1\\\", # s1表是被驱动表 \\\"access_type\\\": \\\"ref\\\", \\\"possible_keys\\\": [ \\\"idx_order_no\\\", \\\"idx_expire_time\\\" ], \\\"key\\\": \\\"idx_order_no\\\", \\\"used_key_parts\\\": [ \\\"order_no\\\" ], \\\"key_length\\\": \\\"152\\\", \\\"ref\\\": [ \\\"mysqladv.s2.order_note\\\" ], \\\"rows_examined_per_scan\\\": 1, # 查询一次s1表大致需要扫描1条记录 \\\"rows_produced_per_join\\\": 16, # 被驱动表s2的扇出是16（由于没有多余的表进行连接，所以这个值无用） \\\"filtered\\\": \\\"4.94\\\", # condition filtering代表的百分比 \\\"index_condition\\\": \\\"(`mysqladv`.`s1`.`order_no` = `mysqladv`.`s2`.`order_note`)\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"325.08\\\", \\\"eval_cost\\\": \\\"3.21\\\", \\\"prefix_cost\\\": \\\"840.51\\\", # 单次查询s2、多次查询s1表总共的成本 \\\"data_read_per_join\\\": \\\"7K\\\" }, \\\"used_columns\\\": [ \\\"id\\\", \\\"order_no\\\", \\\"order_note\\\", \\\"insert_time\\\", \\\"expire_duration\\\", \\\"expire_time\\\", \\\"order_status\\\" ], \\\"attached_condition\\\": \\\"((`mysqladv`.`s1`.`expire_time` > '2021-03-22 18:28:28') and (`mysqladv`.`s1`.`expire_time` <= '2021-03-22 18:35:09'))\\\" } } ] } } \"]},\"556\":{\"h\":\"多表连接的成本分析\",\"t\":[\"多表连接查询的成本分析首先要考虑多表连接时可能产生多少种连接顺序：\",\"对于两表连接，比如表A和表B连接，只有AB、BA两种连接顺序。其实相当于2 × 1 = 2种连接顺序\",\"对于三表连接，比如表A、表B、表C进行连接，有ABC、ACB、BAC、BCA、CAB、CBA这6种连接顺序。其实相当于3 × 2 × 1=6种连接顺序\",\"对于四表连接，则会有4 × 3 × 2 × 1 = 24 种连接顺序\",\"对于n表连接的话，则有n × (n - 1) × (n - 2) × ... × 1种连接顺序，就是n的阶乘种连接顺序，也就是n!\",\"对于n个表的连接查询，MySQL会用一些办法减少计算连接顺序的成本的方法：\",\"提前结束某种顺序的成本评估：MySQL在计算各种链接顺序的成本之前，会维护一个全局变量，这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，那就不会对该连接顺序继续往下分析了。比如有A、B、C三个表进行连接，已经得到连接顺序ABC时当前的最小连接成本，假如是10.0，在计算连接顺序BCA时，发现B和C的连接成本就已经大于10.0时，就不再继续往后分析BCA这个连接顺序的成本了\",\"系统变量\",\"为了防止无穷无尽的分析各种连接顺序的成本，MySQL提出了optimizer_search_depth系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对optimizer_search_depth值相同数量的表进行穷举分析。很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长。\",\"根据某些规则压根儿就不考虑某些连接顺序\",\"即便有上面两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以MySQL干脆提出了一些所谓的启发式规则（就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序不参与分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。MySQL提供了一个系统变量optimizer_prune_level来控制到底是不是用这些启发式规则。\"]},\"557\":{\"h\":\"调节成本常数\",\"t\":[\"前面我们提到两个成本常数：读取一个页面花费的成本默认是1.0，检测一条记录是否符合搜索条件的成本默认是0.2。其实除了这两个成本参数，MySQL还支持很多，它们被存储到MySQL的两个表中：\",\"SHOW TABLES FROM mysql LIKE '%cost%'; \",\"因为一条语句的执行其实是分为两层的：server层、存储引擎层。\",\"MySQL在server层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。也就是说一条语句在server中执行的成本是和它操作的表使用的存储引擎是没有关系的。所以关于这些操作对应的成本常数就存储在了server_cost表中，而依赖于存储引擎的一些操作对应的成本常数就存储在了engine_cost表中。\",\"首先分析一下server_cost表。\",\"SELECT * FROM mysql.server_cost; \",\"cost_value表示成本常数对应的值。如果该列的值为NULL的话，意味着对应的成本常数会采用默认值。\",\"其中每一项成本的含义：\",\"名称\",\"默认值\",\"含义\",\"disk_temptable_create_cost\",\"40.0\",\"创建基于磁盘的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表\",\"disk_temptable_row_cost\",\"1.0\",\"向基于磁盘的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表\",\"key_compare_cost\",\"0.1\",\"两条记录做比较操作的成本，多用在排序操作上，如果增大这个值的话会提升filesort的成本，让优化器尽可能的更倾向于使用索引完成排序而不是filesort\",\"memory_temptable_create_cost\",\"2.0\",\"创建基于内存的临时表写入或者读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表\",\"memory_temptable_row_cost\",\"0.2\",\"向基于内存的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表\",\"row_evaluate_cost\",\"0.2\",\"检测一条记录是否符合搜索条件的成本，增大这个值可以让优化器倾向于使用索引而不是直接全表扫描\",\"MySQL在执行诸如DISTINCT查询、分组查询、Union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，使用这个临时表来辅助完成查询。从上面的表格可以看出，创建临时表和对这个临时表进行写入和读取的操作代价还是很高的。\",\"如果要修改上述参数，首先对表中的cost_value字段值进行update操作，然后执行：\",\"FLUSH OPTIMIZER_COSTS; \",\"如果要改回默认值，将cost_value字段值更新为NULL，然后执行上述语句即可。\",\"接下来我们分析一下engine_cost表。\",\"SELECT * FROM mysql.engine_cost; \",\"与server_cost表相比，engine_cost多出了两列：\",\"engine_name：指定成本常数使用的存储引擎名称。如果该值为default，意味着对应的成本常数使用于所有的存储引擎\",\"device_type：执行存储引擎使用的设备类型，这里主要是为了区分机械硬盘和固态硬盘，不过在MySQL 5.7.X这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分，所以该值默认是0。\",\"表中每一项的含义：\",\"名称\",\"默认值\",\"含义\",\"io_block_read_cost\",\"1.0\",\"从磁盘上读取一个块对应的成本。请注意我使用的是块，而不是页这个词。对于InnoDB存储引擎来说，一个页就是一个块，不过对于MyISAM存储引擎来说，默认是以4096字节作为一个块的。增大这个值会加重I/O成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。\",\"memory_block_read_cost\",\"1.0\",\"从内存中读取一个块对应的成本\",\"怎么从内存中和从磁盘上读取一个块的默认成本是一样的？这主要是因为在MySQL目前的实现中，并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中，有哪些块还停留在磁盘上，所以MySQL简单的认为不管这个块有没有加载到内存中，使用的成本都是1.0。\"]},\"558\":{\"h\":\"InnoDB中的统计数据\",\"t\":[\"InnoDB提供了两种存储统计数据的方式：\",\"永久性的统计数据，这种统计数据存储在磁盘上，也就是说服务器重启之后这些统计数据还在\",\"非永久性的统计数据，这种统计数据存储在内存中，当服务器关闭时这些统计数据就被清除掉了，等到服务器重启之后，在某些适当的场景下才会重新收集这些统计数据\",\"MySQL为我们提供了系统变量innodb_stats_presistent来控制到底采用哪种方式去存储统计数据。在MySQL5.6.6之前，innodb_stats_presistent的值默认是OFF，也就是说InnoDB的统计数据默认是存储到内存的，之后的版本中innodb_stats_presistent的值默认是ON，也就是统计数据默认被存储到磁盘中。\",\"SHOW VARIABLES LIKE 'innodb_stats_persistent'; \",\"我们可以通过指定STATS_PERSISTENT属性来指明该表的统计数据存储方式：\",\"CREATE TABLE 表名 (...) Engine=InnoDB, STATS_PERSISTENT = (1|0); ALTER TABLE 表名 Engine=InnoDB, STATS_PERSISTENT = (1|0); \",\"当STATS_PERSISTENT=1时，表明我们想把该表的统计数据永久的存储到磁盘上，当STATS_PERSISTENT=0时，表明我们想把该表的统计数据临时的存储到内存中。如果我们在创建表时未指定STATS_PERSISTENT属性，默认会采用系统变量innodb_stats_persistent的值作为该属性的值。\",\"当我们选择把某个表以及该表索引的统计数据存放到磁盘上时，实际上是把这些统计数据存储到了两个表里：\",\"SHOW TABLES FROM mysql LIKE 'innodb%'; \",\"可以看到，这两表都位于mysql系统数据库下面，其中：\",\"innodb_table_stats存储了关于表的统计数据，每一条记录对应着一个表的统计数据\",\"Innodb_index_stats存储了关于索引的统计就数据，每一条记录对应着一个索引的一个统计项的统计数据\",\"SELECT * FROM mysql.innodb_table_stats; \",\"几个重要统计信息项的值如下：\",\"n_rows的值是10350，表明order_exp表中大约有10350条记录，这个值是估计值\",\"clustered_index_size的值是97，表明order_exp表的聚簇索引占用97页面，这个值也是一个估计值\",\"sum_of_other_index_sizes的值是81，表明order_exp表的其他索引一共占用81个页面，这个值也是一个估计值\",\"InnoDB统计一个表中有多少行记录是这样的：按照一定算法选取几个叶子结点页面，计算每个页面中主键值记录数量，然后计算平均一个页面中主键值的记录数量乘以全部叶子结点的数量就算是该表n_rows值。\",\"可以看出来这个n_rows值精确与否取决于统计时采样的页面数量，MySQL通过系统变量innodb_stats_persistent_sample_pages来控制使用永久性的统计数据时，计算统计数据时采样的页面数量。该值设置的越大，统计出的n_rows值越精确，但是统计耗时也就最久，该值设置的越小，统计出的n_rows值越不精确，但是统计耗时特别少，这个值的默认值是20。\",\"InnoDB默认是以表为单位来收集和存储统计数据的，我们可以单独设置某个表的采样页面的数量，设置方式就是在创建或修改表的时候通过STATS_SAMPLE_PAGES属性来指明该表的统计数据存储方式：\",\"CREATE TABLE 表名 (...) Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量; ALTER TABLE 表名 Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量; \",\"如果我们在创建表的语句并没有制定STATS_SAMPLE_PAGES属性的话，将默认使用系统变量innodb_stats_persistent_sample_pages的值作为该属性的值。\",\"接下来观察Innodb_index_stats表的数据：\",\"desc mysql.innodb_index_stats; \",\"各个字段的含义：\",\"字段名\",\"描述\",\"database_name\",\"数据库名\",\"table_name\",\"表名\",\"index_name\",\"索引名\",\"last_update\",\"本条记录最后更新时间\",\"stat_name\",\"统计项名称\",\"stat_value\",\"对应的统计项的值\",\"sample_size\",\"为生成统计数据而采样的页面数量\",\"stat_description\",\"对应的统计项的描述\",\"innodb_index_stats表的每条记录代表着一个索引的一个统计项。我们以order_exp表为例：\",\"SELECT * FROM mysql.innodb_index_stats WHERE table_name = 'order_exp'; \",\"从结果中可以看出，PRIMARY索引（也就是组件）占了3条记录，idx_expire_time索引占了6条记录。\",\"stat_name具体的含义：\",\"size：表示该索引共占用多少页面\",\"n_diff_pfxNN：表示对应的索引列不重复的值有多少，其中NN可以被替换为01、02、03...这样的数字，比如对于u_idx_day_status来说，u_diff_pfx01表示的是统计insert_time这单单一列不重复的值有多少，u_diff_pfx02表示insert_time、order_status这两个列组合起来不重复的值有多少，u_diff_pfx03表示的是insert_time、order_status、expire_time这三个列组合起来不重复的值有多少，u_diff_pfx04表示的是insert_time、order_status、expire_time、id这四个列组合起来不重复的值有多少。\",\"对于普通的二级索引，并不能保证它的索引列值是唯一的，比如对于idx_order_no来说，key1列就可能有很多重复的记录。此时只有在索引列上加上主键值才可以区分两条索引列值都是一样的二级索引记录。对于主键和唯一二级索引则没有这个问题，它们本身就可以保证索引列值的不重复，所以也不需要再统计一遍在索引列后加上主键值的不重复值有多少，比如u_idx_day_statu和idx_order_no。\",\"在计算某些索引列中包含多少不重复值时，需要对一些叶子节点页面进行采样，sample_size列就表明了采样的页面数量是多少。对于有多个列的联合索引来说，采样的页面数量是：innodb_stats_persistent_sampe_pages × 索引列的个数。\"]},\"559\":{\"h\":\"更新统计数据\",\"t\":[\"随着我们不断的对表进行增删改操作，表中的数据也一直在变化，innodb_table_stats和innodb_index_stats表里的统计数据也在变化，MySQL提供了自动更新和手动更新两种更新统计数据的方式。\",\"系统变量innodb_stats_auto_recale决定着服务器是否自动重新计算统计数据，它的默认值是ON，也就是该功能默认是开启的。\",\"每个表都维护了一个变量，该变量记录着对该表进行增删改的记录条数，如果发生变动的记录数量超过了表的大小10%，并且自动重新统计数据的功能是打开的，那么服务器会重新进行一次统计数据的计算，并且更新innodb_table_stats和innodb_index_stats表，不过自动重新计算统计数据的过程是异步发生的，也就是即使表中变动的记录数超过了10%，自动重新计算统计数据也不会立即发生，可能会延迟几秒才会进行计算。\",\"InnoDB默认是以表为单位来收集和存储统计数据的，我们可以单独为某个表设置是否自动重新计算统计数的属性，设置方式就是在创建或修改表的时候通过指定STATS_AUTO_RECALC属性来指明该表的统计数据存储方式：\",\"CREATE TABLE 表名 (...) Engine=InnoDB, STATS_AUTO_RECALC = (1|0); ALTER TABLE 表名 Engine=InnoDB, STATS_AUTO_RECALC = (1|0); \",\"当STATS_AUTO_RECALC=1时，表明我们想让该表自动重新计算统计数据，当STATS_AUTO_RECALC=0时，表明不想让该表自动重新计算统计数据，如果我们在创建表时未指定STATS_AUTO_RECALC属性，那默认采用系统变量innodb_stats_auto_recalc的值作为该属性的值。\",\"如果innodb_stats_auto_recalc系统变量的值为OFF的话，我们也可以手动调用ANALYZE TABLE语句来重新计算统计数据，比如我们可以这样更新关于order_exp表的统计数据：\",\"ANALYZE TABLE order_exp; \",\"ANALYZE TABLE语句会立即重新计算统计数据，这个过程是同步的，在表中索引多或者采样页面也别多的时候，这个过程可能会很慢，需要在业务不是很繁忙的时候再运行。\",\"除此之外，innodb_table_stats和innodb_index_stats表就相当于一个普通的表一样，我们能对它们多增删改查操作，这就意味着我们可以手动更新某个表或者索引的统计数据。比如我们想把order_exp表关于行数的统计数据更改一下，可以这么做：\",\"更新innodb_table_stats表\",\"使用语句FLUSH TABLE order_exp让MySQL查询优化器重新加载我们更改过的数据\"]},\"560\":{\"h\":\"表结构设计\"},\"561\":{\"h\":\"MySQL redo日志\",\"t\":[\"参考：https://blog.csdn.net/sermonlizhi/article/details/124556301\",\"事务的实现方式：\",\"WAL(预写式日志)\",\"Commit Logging(提交日志)\",\"Shadow Paging(影子分页)\"]},\"562\":{\"h\":\"Redis入门\"},\"563\":{\"h\":\"概述\"},\"564\":{\"h\":\"Redis是什么？\",\"t\":[\"Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\",\"与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。\"]},\"565\":{\"h\":\"Redis能该干什么？\",\"t\":[\"内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）\",\"高效率、用于高速缓冲\",\"发布订阅系统\",\"地图信息分析\",\"计时器、计数器(eg：浏览量)\"]},\"566\":{\"h\":\"核心特性\",\"t\":[\"多样的数据类型\",\"持久化\",\"集群\",\"事务\"]},\"567\":{\"h\":\"基础知识\",\"t\":[\"Redis是一个字典结构的存储服务器，一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将这数据存储在哪个字典中，这与在一个关系型数据库实例（以MySQL为例）中可以创建多个数据库类似，可以将其中的每个字典都理解成一个独立的数据库。\",\"16个数据库分别为：DB 0~DB 15，默认使用DB 0 ，可以使用select n切换到DB n，dbsize可以查看当前数据库的大小，与key数量相关。\",\"127.0.0.1:6379> config get databases # 命令行查看数据库数量databases 1) \\\"databases\\\" 2) \\\"16\\\" 127.0.0.1:6379> select 8 # 切换数据库 DB 8 OK 127.0.0.1:6379[8]> dbsize # 查看数据库大小 (integer) 0 # 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。 127.0.0.1:6379> set name sakura OK 127.0.0.1:6379> SELECT 8 OK 127.0.0.1:6379[8]> get name # db8中并不能获取db0中的键值对。 (nil) 127.0.0.1:6379[8]> DBSIZE (integer) 0 127.0.0.1:6379[8]> SELECT 0 OK 127.0.0.1:6379> keys * 1) \\\"counter:__rand_int__\\\" 2) \\\"mylist\\\" 3) \\\"name\\\" 4) \\\"key:__rand_int__\\\" 5) \\\"myset:__rand_int__\\\" 127.0.0.1:6379> DBSIZE # size和key个数相关 (integer) 5 \",\"keys * ：查看当前数据库中所有的key。\",\"flushdb：清空当前数据库中的键值对。\",\"flushall：清空所有数据库的键值对。\",\"keys *这个命令需要慎重使用，如果数据库中的键过多可能会造成卡顿，生产环境中应该使用dbsize\"]},\"568\":{\"h\":\"五大数据类型\",\"t\":[\"Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。\"]},\"569\":{\"h\":\"Redis-key\",\"t\":[\"在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。\",\"下面学习的命令：\",\"exists key：判断键是否存在\",\"del key：删除键值对\",\"move key db：将键值对移动到指定数据库\",\"expire key second：设置键值对的过期时间\",\"type key：查看value的数据类型\",\"127.0.0.1:6379> keys * # 查看当前数据库所有key (empty list or set) 127.0.0.1:6379> set name qinjiang # set key OK 127.0.0.1:6379> set age 20 OK 127.0.0.1:6379> keys * 1) \\\"age\\\" 2) \\\"name\\\" 127.0.0.1:6379> move age 1 # 将键值对移动到指定数据库 (integer) 1 127.0.0.1:6379> EXISTS age # 判断键是否存在 (integer) 0 # 不存在 127.0.0.1:6379> EXISTS name (integer) 1 # 存在 127.0.0.1:6379> SELECT 1 OK 127.0.0.1:6379[1]> keys * 1) \\\"age\\\" 127.0.0.1:6379[1]> del age # 删除键值对 (integer) 1 # 删除个数 127.0.0.1:6379> set age 20 OK 127.0.0.1:6379> EXPIRE age 15 # 设置键值对的过期时间 (integer) 1 # 设置成功 开始计数 127.0.0.1:6379> ttl age # 查看key的过期剩余时间 (integer) 13 127.0.0.1:6379> ttl age (integer) 11 127.0.0.1:6379> ttl age (integer) 9 127.0.0.1:6379> ttl age (integer) -2 # -2 表示key过期，-1表示key未设置过期时间 127.0.0.1:6379> get age # 过期的key 会被自动delete (nil) 127.0.0.1:6379> keys * 1) \\\"name\\\" 127.0.0.1:6379> type name # 查看value的数据类型 string \",\"关于TTL命令\",\"Redis的key，通过TTL命令返回key的过期时间，一般来说有3种：\",\"当前key没有设置过期时间，所以会返回-1.\",\"当前key有设置过期时间，而且key已经过期，所以会返回-2.\",\"当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.\",\"关于重命名RENAME和RENAMENX\",\"RENAME key newkey修改 key 的名称\",\"RENAMENX key newkey仅当 newkey 不存在时，将 key 改名为 newkey 。\",\"更多命令学习：Redis命令大全\",\"实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样Redis会在合适的场景选择合适的内部编码，如下图所示：\",\"Redis这样设计有两个好处：\",\"可以改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令\",\"多种内部编码实现可以在不同场景下发挥各自的优势\"]},\"570\":{\"h\":\"String(字符串)\",\"t\":[\"普通的set、get直接略过。\",\"命令\",\"描述\",\"示例\",\"APPEND key value\",\"向指定的key的value后追加字符串\",\"127.0.0.1:6379> set msg hello OK 127.0.0.1:6379> append msg \\\" world\\\" (integer) 11 127.0.0.1:6379> get msg “hello world”\",\"DECR/INCR key\",\"将指定key的value数值进行+1/-1(仅对于数字)\",\"127.0.0.1:6379> set age 20 OK 127.0.0.1:6379> incr age (integer) 21 127.0.0.1:6379> decr age (integer) 20\",\"INCRBY/DECRBY key n\",\"按指定的步长对数值进行加减\",\"127.0.0.1:6379> INCRBY age 5 (integer) 25 127.0.0.1:6379> DECRBY age 10 (integer) 15\",\"INCRBYFLOAT key n\",\"为数值加上浮点型数值\",\"127.0.0.1:6379> INCRBYFLOAT age 5.2 “20.2”\",\"STRLEN key\",\"获取key保存值的字符串长度\",\"127.0.0.1:6379> get msg “hello world” 127.0.0.1:6379> STRLEN msg (integer) 11\",\"GETRANGE key start end\",\"按起止位置获取字符串（闭区间，起止位置都取）\",\"127.0.0.1:6379> get msg “hello world” 127.0.0.1:6379> GETRANGE msg 3 9 “lo worl”\",\"SETRANGE key offset value\",\"用指定的value 替换key中 offset开始的值\",\"127.0.0.1:6379> SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379> get msg “tehello”\",\"GETSET key value\",\"将给定 key 的值设为 value ，并返回 key 的旧值(old value)。\",\"127.0.0.1:6379> GETSET msg test “hello world”\",\"SETNX key value\",\"仅当key不存在时进行set\",\"127.0.0.1:6379> SETNX msg test (integer) 0 127.0.0.1:6379> SETNX name sakura (integer) 1\",\"SETEX key seconds value\",\"set 键值对并设置过期时间\",\"127.0.0.1:6379> setex name 10 root OK 127.0.0.1:6379> get name (nil)\",\"MSET key1 value1 [key2 value2..]\",\"批量set键值对\",\"127.0.0.1:6379> MSET k1 v1 k2 v2 k3 v3 OK\",\"MSETNX key1 value1 [key2 value2..]\",\"批量设置键值对，仅当参数中所有的key都不存在时执行\",\"127.0.0.1:6379> MSETNX k1 v1 k4 v4 (integer) 0\",\"MGET key1 [key2..]\",\"批量获取多个key保存的值\",\"127.0.0.1:6379> MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”\",\"PSETEX key milliseconds value\",\"和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，\",\"getset key value\",\"如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值\",\"String类似的使用场景：value除了是字符串还可以是数字，用途举例：\",\"计数器\",\"统计多单位的数量：uid:123666：follow 0\",\"粉丝数\",\"对象存储缓存\"]},\"571\":{\"h\":\"List(列表)\",\"t\":[\"Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边），一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。\",\"首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等\",\"正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN\",\"命令\",\"描述\",\"LPUSH/RPUSH key value1[value2..]\",\"从左边/右边向列表中PUSH值(一个或者多个)。\",\"LRANGE key start end\",\"获取list 起止元素（索引从左往右 递增）\",\"LPUSHX/RPUSHX key value\",\"向已存在的列名中push值（一个或者多个）\",\"`LINSERT key BEFORE\",\"AFTER pivot value`\",\"LLEN key\",\"查看列表长度\",\"LINDEX key index\",\"通过索引获取列表元素\",\"LSET key index value\",\"通过索引为元素设值\",\"LPOP/RPOP key\",\"从最左边/最右边移除值 并返回\",\"RPOPLPUSH source destination\",\"将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部\",\"LTRIM key start end\",\"通过下标截取指定范围内的列表\",\"LREM key count value\",\"List中是允许value重复的 count > 0：从头部开始搜索 然后删除指定的value 至多删除count个 count < 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。\",\"BLPOP/BRPOP key1[key2] timout\",\"移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\",\"BRPOPLPUSH source destination timeout\",\"和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\",\"---------------------------LPUSH---RPUSH---LRANGE-------------------------------- 127.0.0.1:6379> LPUSH mylist k1 # LPUSH mylist=>{1} (integer) 1 127.0.0.1:6379> LPUSH mylist k2 # LPUSH mylist=>{2,1} (integer) 2 127.0.0.1:6379> RPUSH mylist k3 # RPUSH mylist=>{2,1,3} (integer) 3 127.0.0.1:6379> get mylist # 普通的get是无法获取list值的 (error) WRONGTYPE Operation against a key holding the wrong kind of value 127.0.0.1:6379> LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素 1) \\\"k2\\\" 2) \\\"k1\\\" 3) \\\"k3\\\" 127.0.0.1:6379> LRANGE mylist 0 2 1) \\\"k2\\\" 2) \\\"k1\\\" 3) \\\"k3\\\" 127.0.0.1:6379> LRANGE mylist 0 1 1) \\\"k2\\\" 2) \\\"k1\\\" 127.0.0.1:6379> LRANGE mylist 0 -1 # 获取全部元素 1) \\\"k2\\\" 2) \\\"k1\\\" 3) \\\"k3\\\" ---------------------------LPUSHX---RPUSHX----------------------------------- 127.0.0.1:6379> LPUSHX list v1 # list不存在 LPUSHX失败 (integer) 0 127.0.0.1:6379> LPUSHX list v1 v2 (integer) 0 127.0.0.1:6379> LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5 (integer) 5 127.0.0.1:6379> LRANGE mylist 0 -1 1) \\\"k5\\\" 2) \\\"k4\\\" 3) \\\"k2\\\" 4) \\\"k1\\\" 5) \\\"k3\\\" ---------------------------LINSERT--LLEN--LINDEX--LSET---------------------------- 127.0.0.1:6379> LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1 (integer) 6 127.0.0.1:6379> LRANGE mylist 0 -1 1) \\\"k5\\\" 2) \\\"k4\\\" 3) \\\"k2\\\" 4) \\\"ins_key1\\\" 5) \\\"k1\\\" 6) \\\"k3\\\" 127.0.0.1:6379> LLEN mylist # 查看mylist的长度 (integer) 6 127.0.0.1:6379> LINDEX mylist 3 # 获取下标为3的元素 \\\"ins_key1\\\" 127.0.0.1:6379> LINDEX mylist 0 \\\"k5\\\" 127.0.0.1:6379> LSET mylist 3 k6 # 将下标3的元素 set值为k6 OK 127.0.0.1:6379> LRANGE mylist 0 -1 1) \\\"k5\\\" 2) \\\"k4\\\" 3) \\\"k2\\\" 4) \\\"k6\\\" 5) \\\"k1\\\" 6) \\\"k3\\\" ---------------------------LPOP--RPOP-------------------------- 127.0.0.1:6379> LPOP mylist # 左侧(头部)弹出 \\\"k5\\\" 127.0.0.1:6379> RPOP mylist # 右侧(尾部)弹出 \\\"k3\\\" ---------------------------RPOPLPUSH-------------------------- 127.0.0.1:6379> LRANGE mylist 0 -1 1) \\\"k4\\\" 2) \\\"k2\\\" 3) \\\"k6\\\" 4) \\\"k1\\\" 127.0.0.1:6379> RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部 \\\"k1\\\" 127.0.0.1:6379> LRANGE newlist 0 -1 1) \\\"k1\\\" 127.0.0.1:6379> LRANGE mylist 0 -1 1) \\\"k4\\\" 2) \\\"k2\\\" 3) \\\"k6\\\" ---------------------------LTRIM-------------------------- 127.0.0.1:6379> LTRIM mylist 0 1 # 截取mylist中的 0~1部分 OK 127.0.0.1:6379> LRANGE mylist 0 -1 1) \\\"k4\\\" 2) \\\"k2\\\" # 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2 ---------------------------LREM-------------------------- 127.0.0.1:6379> LREM mylist 3 k2 # 从头部开始搜索 至多删除3个 k2 (integer) 3 # 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2 127.0.0.1:6379> LREM mylist -2 k2 #从尾部开始搜索 至多删除2个 k2 (integer) 2 # 删除后：mylist: k2,k2,k2,k4,k2,k2 ---------------------------BLPOP--BRPOP-------------------------- mylist: k2,k2,k2,k4,k2,k2 newlist: k1 127.0.0.1:6379> BLPOP newlist mylist 30 # 从newlist中弹出第一个值，mylist作为候选 1) \\\"newlist\\\" # 弹出 2) \\\"k1\\\" 127.0.0.1:6379> BLPOP newlist mylist 30 1) \\\"mylist\\\" # 由于newlist空了 从mylist中弹出 2) \\\"k2\\\" 127.0.0.1:6379> BLPOP newlist 30 (30.10s) # 超时了 127.0.0.1:6379> BLPOP newlist 30 # 我们连接另一个客户端向newlist中push了test, 阻塞被解决。 1) \\\"newlist\\\" 2) \\\"test\\\" (12.54s) \",\"小结：\",\"list实际上是一个链表，before Node after , left, right 都可以插入值\",\"如果key不存在，则创建新的链表\",\"如果key存在，新增内容\",\"如果移除了所有值，空链表，也代表不存在\",\"在两边插入或者改动值，效率最高！修改中间元素，效率相对较低\",\"应用：\",\"消息排队\",\"消息队列（Lpush Rpop）\",\"栈（Lpush Lpop）\"]},\"572\":{\"h\":\"Set(集合)\",\"t\":[\"Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)，集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\",\"命令\",\"描述\",\"SADD key member1[member2..]\",\"向集合中无序增加一个/多个成员\",\"SCARD key\",\"获取集合的成员数\",\"SMEMBERS key\",\"返回集合中所有的成员\",\"SISMEMBER key member\",\"查询member元素是否是集合的成员,结果是无序的\",\"SRANDMEMBER key [count]\",\"随机返回集合中count个成员，count缺省值为1\",\"SPOP key [count]\",\"随机移除并返回集合中count个成员，count缺省值为1\",\"SMOVE source destination member\",\"将source集合的成员member移动到destination集合\",\"SREM key member1[member2..]\",\"移除集合中一个/多个成员\",\"SDIFF key1[key2..]\",\"返回所有集合的差集 key1- key2 - …\",\"SDIFFSTORE destination key1[key2..]\",\"在SDIFF的基础上，将结果保存到集合中(覆盖)。不能保存到其他类型key噢！\",\"SINTER key1 [key2..]\",\"返回所有集合的交集\",\"SINTERSTORE destination key1[key2..]\",\"在SINTER的基础上，存储结果到集合中。覆盖\",\"SUNION key1 [key2..]\",\"返回所有集合的并集\",\"SUNIONSTORE destination key1 [key2..]\",\"在SUNION的基础上，存储结果到及和张。覆盖\",\"SSCAN KEY [MATCH pattern] [COUNT count]\",\"在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分\",\"---------------SADD--SCARD--SMEMBERS--SISMEMBER-------------------- 127.0.0.1:6379> SADD myset m1 m2 m3 m4 # 向myset中增加成员 m1~m4 (integer) 4 127.0.0.1:6379> SCARD myset # 获取集合的成员数目 (integer) 4 127.0.0.1:6379> smembers myset # 获取集合中所有成员 1) \\\"m4\\\" 2) \\\"m3\\\" 3) \\\"m2\\\" 4) \\\"m1\\\" 127.0.0.1:6379> SISMEMBER myset m5 # 查询m5是否是myset的成员 (integer) 0 # 不是，返回0 127.0.0.1:6379> SISMEMBER myset m2 (integer) 1 # 是，返回1 127.0.0.1:6379> SISMEMBER myset m3 (integer) 1 ---------------------SRANDMEMBER--SPOP---------------------------------- 127.0.0.1:6379> SRANDMEMBER myset 3 # 随机返回3个成员 1) \\\"m2\\\" 2) \\\"m3\\\" 3) \\\"m4\\\" 127.0.0.1:6379> SRANDMEMBER myset # 随机返回1个成员 \\\"m3\\\" 127.0.0.1:6379> SPOP myset 2 # 随机移除并返回2个成员 1) \\\"m1\\\" 2) \\\"m4\\\" # 将set还原到{m1,m2,m3,m4} ---------------------SMOVE--SREM---------------------------------------- 127.0.0.1:6379> SMOVE myset newset m3 # 将myset中m3成员移动到newset集合 (integer) 1 127.0.0.1:6379> SMEMBERS myset 1) \\\"m4\\\" 2) \\\"m2\\\" 3) \\\"m1\\\" 127.0.0.1:6379> SMEMBERS newset 1) \\\"m3\\\" 127.0.0.1:6379> SREM newset m3 # 从newset中移除m3元素 (integer) 1 127.0.0.1:6379> SMEMBERS newset (empty list or set) # 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算 # setx=>{m1,m2,m4,m6}, sety=>{m2,m5,m6}, setz=>{m1,m3,m6} -----------------------------SDIFF------------------------------------ 127.0.0.1:6379> SDIFF setx sety setz # 等价于setx-sety-setz 1) \\\"m4\\\" 127.0.0.1:6379> SDIFF setx sety # setx - sety 1) \\\"m4\\\" 2) \\\"m1\\\" 127.0.0.1:6379> SDIFF sety setx # sety - setx 1) \\\"m5\\\" -------------------------SINTER--------------------------------------- # 共同关注（交集） 127.0.0.1:6379> SINTER setx sety setz # 求 setx、sety、setx的交集 1) \\\"m6\\\" 127.0.0.1:6379> SINTER setx sety # 求setx sety的交集 1) \\\"m2\\\" 2) \\\"m6\\\" -------------------------SUNION--------------------------------------- 127.0.0.1:6379> SUNION setx sety setz # setx sety setz的并集 1) \\\"m4\\\" 2) \\\"m6\\\" 3) \\\"m3\\\" 4) \\\"m2\\\" 5) \\\"m1\\\" 6) \\\"m5\\\" 127.0.0.1:6379> SUNION setx sety # setx sety 并集 1) \\\"m4\\\" 2) \\\"m6\\\" 3) \\\"m2\\\" 4) \\\"m1\\\" 5) \\\"m5\\\" \"]},\"573\":{\"h\":\"Hash（哈希）\",\"t\":[\"Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象，Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。\",\"命令\",\"描述\",\"HSET key field value\",\"将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0\",\"HMSET key field1 value1 [field2 value2..]\",\"同时将多个 field-value (域-值)对设置到哈希表 key 中。\",\"HSETNX key field value\",\"只有在字段 field 不存在时，设置哈希表字段的值。\",\"HEXISTS key field\",\"查看哈希表 key 中，指定的字段是否存在。\",\"HGET key field value\",\"获取存储在哈希表中指定字段的值\",\"HMGET key field1 [field2..]\",\"获取所有给定字段的值\",\"HGETALL key\",\"获取在哈希表key 的所有字段和值\",\"HKEYS key\",\"获取哈希表key中所有的字段\",\"HLEN key\",\"获取哈希表中字段的数量\",\"HVALS key\",\"获取哈希表中所有值\",\"HDEL key field1 [field2..]\",\"删除哈希表key中一个/多个field字段\",\"HINCRBY key field n\",\"为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段\",\"HINCRBYFLOAT key field n\",\"为哈希表 key 中的指定字段的浮点数值加上增量 n。\",\"HSCAN key cursor [MATCH pattern] [COUNT count]\",\"迭代哈希表中的键值对。\",\"------------------------HSET--HMSET--HSETNX---------------- 127.0.0.1:6379> HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura (integer) 1 127.0.0.1:6379> HSET studentx name gyc # 重复设置field进行覆盖，并返回0 (integer) 0 127.0.0.1:6379> HSET studentx age 20 # 设置studentx的age为20 (integer) 1 127.0.0.1:6379> HMSET studentx sex 1 tel 15623667886 # 设置sex为1，tel为15623667886 OK 127.0.0.1:6379> HSETNX studentx name gyc # HSETNX 设置已存在的field (integer) 0 # 失败 127.0.0.1:6379> HSETNX studentx email 12345@qq.com (integer) 1 # 成功 ----------------------HEXISTS-------------------------------- 127.0.0.1:6379> HEXISTS studentx name # name字段在studentx中是否存在 (integer) 1 # 存在 127.0.0.1:6379> HEXISTS studentx addr (integer) 0 # 不存在 -------------------HGET--HMGET--HGETALL----------- 127.0.0.1:6379> HGET studentx name # 获取studentx中name字段的value \\\"gyc\\\" 127.0.0.1:6379> HMGET studentx name age tel # 获取studentx中name、age、tel字段的value 1) \\\"gyc\\\" 2) \\\"20\\\" 3) \\\"15623667886\\\" 127.0.0.1:6379> HGETALL studentx # 获取studentx中所有的field及其value 1) \\\"name\\\" 2) \\\"gyc\\\" 3) \\\"age\\\" 4) \\\"20\\\" 5) \\\"sex\\\" 6) \\\"1\\\" 7) \\\"tel\\\" 8) \\\"15623667886\\\" 9) \\\"email\\\" 10) \\\"12345@qq.com\\\" --------------------HKEYS--HLEN--HVALS-------------- 127.0.0.1:6379> HKEYS studentx # 查看studentx中所有的field 1) \\\"name\\\" 2) \\\"age\\\" 3) \\\"sex\\\" 4) \\\"tel\\\" 5) \\\"email\\\" 127.0.0.1:6379> HLEN studentx # 查看studentx中的字段数量 (integer) 5 127.0.0.1:6379> HVALS studentx # 查看studentx中所有的value 1) \\\"gyc\\\" 2) \\\"20\\\" 3) \\\"1\\\" 4) \\\"15623667886\\\" 5) \\\"12345@qq.com\\\" -------------------------HDEL-------------------------- 127.0.0.1:6379> HDEL studentx sex tel # 删除studentx 中的sex、tel字段 (integer) 2 127.0.0.1:6379> HKEYS studentx 1) \\\"name\\\" 2) \\\"age\\\" 3) \\\"email\\\" -------------HINCRBY--HINCRBYFLOAT------------------------ 127.0.0.1:6379> HINCRBY studentx age 1 # studentx的age字段数值+1 (integer) 21 127.0.0.1:6379> HINCRBY studentx name 1 # 非整数字型字段不可用 (error) ERR hash value is not an integer 127.0.0.1:6379> HINCRBYFLOAT studentx weight 0.6 # weight字段增加0.6 \\\"90.8\\\" \",\"Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！Hash更适合于对象的存储，Sring更加适合字符串存储！\"]},\"574\":{\"h\":\"Zset（有序集合）\",\"t\":[\"不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。score相同：按字典顺序排序，有序集合的成员是唯一的，但分数(score)却可以重复。\",\"命令\",\"描述\",\"ZADD key score member1 [score2 member2]\",\"向有序集合添加一个或多个成员，或者更新已存在成员的分数\",\"ZCARD key\",\"获取有序集合的成员数\",\"ZCOUNT key min max\",\"计算在有序集合中指定区间score的成员数\",\"ZINCRBY key n member\",\"有序集合中对指定成员的分数加上增量 n\",\"ZSCORE key member\",\"返回有序集中，成员的分数值\",\"ZRANK key member\",\"返回有序集合中指定成员的索引\",\"ZRANGE key start end\",\"通过索引区间返回有序集合成指定区间内的成员\",\"ZRANGEBYLEX key min max\",\"通过字典区间返回有序集合的成员\",\"ZRANGEBYSCORE key min max\",\"通过分数返回有序集合指定区间内的成员-inf 和 +inf分别表示最小最大值，只支持开区间()\",\"ZLEXCOUNT key min max\",\"在有序集合中计算指定字典区间内成员数量\",\"ZREM key member1 [member2..]\",\"移除有序集合中一个/多个成员\",\"ZREMRANGEBYLEX key min max\",\"移除有序集合中给定的字典区间的所有成员\",\"ZREMRANGEBYRANK key start stop\",\"移除有序集合中给定的排名区间的所有成员\",\"ZREMRANGEBYSCORE key min max\",\"移除有序集合中给定的分数区间的所有成员\",\"ZREVRANGE key start end\",\"返回有序集中指定区间内的成员，通过索引，分数从高到底\",\"ZREVRANGEBYSCORRE key max min\",\"返回有序集中指定分数区间内的成员，分数从高到低排序\",\"ZREVRANGEBYLEX key max min\",\"返回有序集中指定字典区间内的成员，按字典顺序倒序\",\"ZREVRANK key member\",\"返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序\",\"ZINTERSTORE destination numkeys key1 [key2 ..]\",\"计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score\",\"ZUNIONSTORE destination numkeys key1 [key2..]\",\"计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中\",\"ZSCAN key cursor [MATCH pattern\\\\] [COUNT count]\",\"迭代有序集合中的元素（包括元素成员和元素分值）\",\"-------------------ZADD--ZCARD--ZCOUNT-------------- 127.0.0.1:6379> ZADD myzset 1 m1 2 m2 3 m3 # 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2.. (integer) 2 127.0.0.1:6379> ZCARD myzset # 获取有序集合的成员数 (integer) 2 127.0.0.1:6379> ZCOUNT myzset 0 1 # 获取score在 [0,1]区间的成员数量 (integer) 1 127.0.0.1:6379> ZCOUNT myzset 0 2 (integer) 2 ----------------ZINCRBY--ZSCORE-------------------------- 127.0.0.1:6379> ZINCRBY myzset 5 m2 # 将成员m2的score +5 \\\"7\\\" 127.0.0.1:6379> ZSCORE myzset m1 # 获取成员m1的score \\\"1\\\" 127.0.0.1:6379> ZSCORE myzset m2 \\\"7\\\" --------------ZRANK--ZRANGE----------------------------------- 127.0.0.1:6379> ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加 (integer) 0 127.0.0.1:6379> ZRANK myzset m2 (integer) 2 127.0.0.1:6379> ZRANGE myzset 0 1 # 获取索引在 0~1的成员 1) \\\"m1\\\" 2) \\\"m3\\\" 127.0.0.1:6379> ZRANGE myzset 0 -1 # 获取全部成员 1) \\\"m1\\\" 2) \\\"m3\\\" 3) \\\"m2\\\" #testset=>{abc,add,amaze,apple,back,java,redis} score均为0 ------------------ZRANGEBYLEX--------------------------------- 127.0.0.1:6379> ZRANGEBYLEX testset - + # 返回所有成员 1) \\\"abc\\\" 2) \\\"add\\\" 3) \\\"amaze\\\" 4) \\\"apple\\\" 5) \\\"back\\\" 6) \\\"java\\\" 7) \\\"redis\\\" 127.0.0.1:6379> ZRANGEBYLEX testset - + LIMIT 0 3 # 分页 按索引显示查询结果的 0,1,2条记录 1) \\\"abc\\\" 2) \\\"add\\\" 3) \\\"amaze\\\" 127.0.0.1:6379> ZRANGEBYLEX testset - + LIMIT 3 3 # 显示 3,4,5条记录 1) \\\"apple\\\" 2) \\\"back\\\" 3) \\\"java\\\" 127.0.0.1:6379> ZRANGEBYLEX testset (- [apple # 显示 (-,apple] 区间内的成员 1) \\\"abc\\\" 2) \\\"add\\\" 3) \\\"amaze\\\" 4) \\\"apple\\\" 127.0.0.1:6379> ZRANGEBYLEX testset [apple [java # 显示 [apple,java]字典区间的成员 1) \\\"apple\\\" 2) \\\"back\\\" 3) \\\"java\\\" -----------------------ZRANGEBYSCORE--------------------- 127.0.0.1:6379> ZRANGEBYSCORE myzset 1 10 # 返回score在 [1,10]之间的的成员 1) \\\"m1\\\" 2) \\\"m3\\\" 3) \\\"m2\\\" 127.0.0.1:6379> ZRANGEBYSCORE myzset 1 5 1) \\\"m1\\\" 2) \\\"m3\\\" --------------------ZLEXCOUNT----------------------------- 127.0.0.1:6379> ZLEXCOUNT testset - + (integer) 7 127.0.0.1:6379> ZLEXCOUNT testset [apple [java (integer) 3 ------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE-------------------------------- 127.0.0.1:6379> ZREM testset abc # 移除成员abc (integer) 1 127.0.0.1:6379> ZREMRANGEBYLEX testset [apple [java # 移除字典区间[apple,java]中的所有成员 (integer) 3 127.0.0.1:6379> ZREMRANGEBYRANK testset 0 1 # 移除排名0~1的所有成员 (integer) 2 127.0.0.1:6379> ZREMRANGEBYSCORE myzset 0 3 # 移除score在 [0,3]的成员 (integer) 2 # testset=> {abc,add,apple,amaze,back,java,redis} score均为0 # myzset=> {(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)} ----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX----------- 127.0.0.1:6379> ZREVRANGE myzset 0 3 # 按score递减排序，然后按索引，返回结果的 0~3 1) \\\"m9\\\" 2) \\\"m7\\\" 3) \\\"m4\\\" 4) \\\"m3\\\" 127.0.0.1:6379> ZREVRANGE myzset 2 4 # 返回排序结果的 索引的2~4 1) \\\"m4\\\" 2) \\\"m3\\\" 3) \\\"m2\\\" 127.0.0.1:6379> ZREVRANGEBYSCORE myzset 6 2 # 按score递减顺序 返回集合中分数在[2,6]之间的成员 1) \\\"m4\\\" 2) \\\"m3\\\" 3) \\\"m2\\\" 127.0.0.1:6379> ZREVRANGEBYLEX testset [java (add # 按字典倒序 返回集合中(add,java]字典区间的成员 1) \\\"java\\\" 2) \\\"back\\\" 3) \\\"apple\\\" 4) \\\"amaze\\\" -------------------------ZREVRANK------------------------------ 127.0.0.1:6379> ZREVRANK myzset m7 # 按score递减顺序，返回成员m7索引 (integer) 1 127.0.0.1:6379> ZREVRANK myzset m2 (integer) 4 # mathscore=>{(xm,90),(xh,95),(xg,87)} 小明、小红、小刚的数学成绩 # enscore=>{(xm,70),(xh,93),(xg,90)} 小明、小红、小刚的英语成绩 -------------------ZINTERSTORE--ZUNIONSTORE----------------------------------- 127.0.0.1:6379> ZINTERSTORE sumscore 2 mathscore enscore # 将mathscore enscore进行合并 结果存放到sumscore (integer) 3 127.0.0.1:6379> ZRANGE sumscore 0 -1 withscores # 合并后的score是之前集合中所有score的和 1) \\\"xm\\\" 2) \\\"160\\\" 3) \\\"xg\\\" 4) \\\"177\\\" 5) \\\"xh\\\" 6) \\\"188\\\" 127.0.0.1:6379> ZUNIONSTORE lowestscore 2 mathscore enscore AGGREGATE MIN # 取两个集合的成员score最小值作为结果的 (integer) 3 127.0.0.1:6379> ZRANGE lowestscore 0 -1 withscores 1) \\\"xm\\\" 2) \\\"70\\\" 3) \\\"xg\\\" 4) \\\"87\\\" 5) \\\"xh\\\" 6) \\\"93\\\" \",\"应用案例：\",\"set排序 存储班级成绩表 工资表排序！\",\"普通消息，1.重要消息 2.带权重进行判断\",\"排行榜应用实现，取Top N测试\"]},\"575\":{\"h\":\"三种特殊数据类型\"},\"576\":{\"h\":\"Geospatial(地理位置)\",\"t\":[\"使用经纬度定位地理坐标并用一个有序集合zset保存，所以zset命令也可以使用。\",\"命令\",\"描述\",\"geoadd key longitud(经度) latitude(纬度) member [..]\",\"将具体经纬度的坐标存入一个有序集合\",\"geopos key member [member..]\",\"获取集合中的一个/多个成员坐标\",\"geodist key member1 member2 [unit]\",\"返回两个给定位置之间的距离。默认以米作为单位。\",\"`georadius key longitude latitude radius m\",\"km\",\"GEORADIUSBYMEMBER key member radius...\",\"功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。\",\"geohash key member1 [member2..]\",\"返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。\",\"有效经纬度\",\"有效的经度从-180度到180度。\",\"有效的纬度从-85.05112878度到85.05112878度。\",\"指定单位的参数 unit 必须是以下单位的其中一个：\",\"m 表示单位为米。\",\"km 表示单位为千米。\",\"mi 表示单位为英里。\",\"ft 表示单位为英尺。\",\"关于GEORADIUS的参数\",\"通过georadius就可以完成 附近的人功能\",\"withcoord:带上坐标\",\"withdist:带上距离，单位与半径单位相同\",\"COUNT n : 只显示前n个(按距离递增排序)\",\"----------------georadius--------------------- 127.0.0.1:6379> GEORADIUS china:city 120 30 500 km withcoord withdist # 查询经纬度(120,30)坐标500km半径内的成员 1) 1) \\\"hangzhou\\\" 2) \\\"29.4151\\\" 3) 1) \\\"120.20000249147415\\\" 2) \\\"30.199999888333501\\\" 2) 1) \\\"shanghai\\\" 2) \\\"205.3611\\\" 3) 1) \\\"121.40000134706497\\\" 2) \\\"31.400000253193539\\\" ------------geohash--------------------------- 127.0.0.1:6379> geohash china:city yichang shanghai # 获取成员经纬坐标的geohash表示 1) \\\"wmrjwbr5250\\\" 2) \\\"wtw6ds0y300\\\" \"]},\"577\":{\"h\":\"Hyperloglog(基数统计)\",\"t\":[\"Redis HyperLogLog 是用来做基数（数据集中不重复的元素的个数）统计的数据结构，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。\",\"花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。\",\"因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。\",\"应用场景：网页的访问量（UV），一个用户多次访问，也只能算作一个人。\",\"传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是计数，Hyperloglog就能帮助我们利用最小的空间完成。\",\"命令\",\"描述\",\"PFADD key element1 [elememt2..]\",\"添加指定元素到 HyperLogLog 中\",\"PFCOUNT key [key]\",\"返回给定 HyperLogLog 的基数估算值。\",\"PFMERGE destkey sourcekey [sourcekey..]\",\"将多个 HyperLogLog 合并为一个 HyperLogLog\",\"----------PFADD--PFCOUNT--------------------- 127.0.0.1:6379> PFADD myelemx a b c d e f g h i j k # 添加元素 (integer) 1 127.0.0.1:6379> type myelemx # hyperloglog底层使用String string 127.0.0.1:6379> PFCOUNT myelemx # 估算myelemx的基数 (integer) 11 127.0.0.1:6379> PFADD myelemy i j k z m c b v p q s (integer) 1 127.0.0.1:6379> PFCOUNT myelemy (integer) 11 ----------------PFMERGE----------------------- 127.0.0.1:6379> PFMERGE myelemz myelemx myelemy # 合并myelemx和myelemy 成为myelemz OK 127.0.0.1:6379> PFCOUNT myelemz # 估算基数 (integer) 17 \",\"如果允许容错，那么一定可以使用Hyperloglog !\",\"如果不允许容错，就使用set或者自己的数据类型即可 ！\"]},\"578\":{\"h\":\"BitMaps(位图)\",\"t\":[\"使用位存储，信息状态只有 0 和 1，Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。\",\"应用场景：签到统计、状态统计\",\"命令\",\"描述\",\"setbit key offset value\",\"为指定key的offset位设置值\",\"getbit key offset\",\"获取offset位的值\",\"bitcount key [start end]\",\"统计字符串被设置为1的bit数，也可以指定统计范围按字节\",\"bitop operration destkey key[key..]\",\"对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。\",\"BITPOS key bit [start] [end]\",\"返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位\",\"------------setbit--getbit-------------- 127.0.0.1:6379> setbit sign 0 1 # 设置sign的第0位为 1 (integer) 0 127.0.0.1:6379> setbit sign 2 1 # 设置sign的第2位为 1 不设置默认 是0 (integer) 0 127.0.0.1:6379> setbit sign 3 1 (integer) 0 127.0.0.1:6379> setbit sign 5 1 (integer) 0 127.0.0.1:6379> type sign string 127.0.0.1:6379> getbit sign 2 # 获取第2位的数值 (integer) 1 127.0.0.1:6379> getbit sign 3 (integer) 1 127.0.0.1:6379> getbit sign 4 # 未设置默认是0 (integer) 0 -----------bitcount---------------------------- 127.0.0.1:6379> BITCOUNT sign # 统计sign中为1的位数 (integer) 4 \",\"这样设置以后你能get到的值是：\\\\xA2\\\\x80，所以bitmaps是一串从左到右的二进制串\",\"Redis的事务就是指一组命令的集合，Redis的单条命令是保证原子性的，但是redis事务不能保证原子性，并且Redis事务没有隔离级别的概念。\",\"事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。\",\"一次性\",\"顺序性\",\"排他性\"]},\"579\":{\"h\":\"操作过程\",\"t\":[\"开启事务（multi）\",\"命令入队\",\"执行事务（exec）\",\"所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。\",\"127.0.0.1:6379> multi # 开启事务 OK 127.0.0.1:6379> set k1 v1 # 命令入队 QUEUED 127.0.0.1:6379> set k2 v2 # .. QUEUED 127.0.0.1:6379> get k1 QUEUED 127.0.0.1:6379> set k3 v3 QUEUED 127.0.0.1:6379> keys * QUEUED 127.0.0.1:6379> exec # 事务执行 1) OK 2) OK 3) \\\"v1\\\" 4) OK 5) 1) \\\"k3\\\" 2) \\\"k2\\\" 3) \\\"k1\\\" \",\"取消事务(discurd)\",\"127.0.0.1:6379> multi OK 127.0.0.1:6379> set k1 v1 QUEUED 127.0.0.1:6379> set k2 v2 QUEUED 127.0.0.1:6379> DISCARD # 放弃事务 OK 127.0.0.1:6379> EXEC (error) ERR EXEC without MULTI # 当前未开启事务 127.0.0.1:6379> get k1 # 被放弃事务中命令并未执行 (nil) \"]},\"580\":{\"h\":\"事务错误\",\"t\":[\"代码语法错误（编译时异常）所有的命令都不执行：\",\"127.0.0.1:6379> multi OK 127.0.0.1:6379> set k1 v1 QUEUED 127.0.0.1:6379> set k2 v2 QUEUED 127.0.0.1:6379> error k1 # 这是一条语法错误命令 (error) ERR unknown command `error`, with args beginning with: `k1`, # 会报错但是不影响后续命令入队 127.0.0.1:6379> get k2 QUEUED 127.0.0.1:6379> EXEC (error) EXECABORT Transaction discarded because of previous errors. # 执行报错 127.0.0.1:6379> get k1 (nil) # 其他命令并没有被执行 \",\"当代码逻辑错误 (运行时异常) ，其他命令可以正常执行，因此说Redis所以不保证事务原子性：\",\"127.0.0.1:6379> multi OK 127.0.0.1:6379> set k1 v1 QUEUED 127.0.0.1:6379> set k2 v2 QUEUED 127.0.0.1:6379> INCR k1 # 这条命令逻辑错误（对字符串进行增量） QUEUED 127.0.0.1:6379> get k2 QUEUED 127.0.0.1:6379> exec 1) OK 2) OK 3) (error) ERR value is not an integer or out of range # 运行时报错 4) \\\"v2\\\" # 其他命令正常执行 # 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。 # 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。 \"]},\"581\":{\"h\":\"监控\",\"t\":[\"使用watch key监控指定数据，相当于乐观锁加锁。\",\"正常执行：\",\"127.0.0.1:6379> set money 100 # 设置余额:100 OK 127.0.0.1:6379> set use 0 # 支出使用:0 OK 127.0.0.1:6379> watch money # 监视money (上锁) OK 127.0.0.1:6379> multi OK 127.0.0.1:6379> DECRBY money 20 QUEUED 127.0.0.1:6379> INCRBY use 20 QUEUED 127.0.0.1:6379> exec # 监视值没有被中途修改，事务正常执行 1) (integer) 80 2) (integer) 20 \",\"测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion）：\",\"我们启动另外一个客户端模拟插队线程。\",\"线程1：\",\"127.0.0.1:6379> watch money # money上锁 OK 127.0.0.1:6379> multi OK 127.0.0.1:6379> DECRBY money 20 QUEUED 127.0.0.1:6379> INCRBY use 20 QUEUED 127.0.0.1:6379> # 此时事务并没有执行 \",\"模拟线程插队，线程2：\",\"127.0.0.1:6379> INCRBY money 500 # 修改了线程一中监视的money (integer) 600 12 \",\"回到线程1，执行事务：\",\"127.0.0.1:6379> EXEC # 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败 (nil) # 没有结果，说明事务执行失败 127.0.0.1:6379> get money # 线程2 修改生效 \\\"600\\\" 127.0.0.1:6379> get use # 线程1事务执行失败，数值没有被修改 \\\"0\\\" \",\"解锁获取最新值，然后再加锁进行事务。unwatch进行解锁。注意：每次提交执行exec后都会自动释放锁，不管是否成功\"]},\"582\":{\"h\":\"Jedis\",\"t\":[\"使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。\",\"导入相关依赖：\",\"<!--导入jredis的包--> <dependency> <groupId>redis.clients</groupId> <artifactId>jedis</artifactId> <version>3.2.0</version> </dependency> <!--fastjson--> <dependency> <groupId>com.alibaba</groupId> <artifactId>fastjson</artifactId> <version>1.2.70</version> </dependency> \",\"在做好Redis相关的配置并启动后就可以进行测试：\",\"public class TestPing { public static void main(String[] args) { Jedis jedis = new Jedis(\\\"192.168.xx.xxx\\\", 6379); String response = jedis.ping(); System.out.println(response); // PONG } } \",\"测试事务：\",\"public class TestTX { public static void main(String[] args) { Jedis jedis = new Jedis(\\\"39.99.xxx.xx\\\", 6379); JSONObject jsonObject = new JSONObject(); jsonObject.put(\\\"hello\\\", \\\"world\\\"); jsonObject.put(\\\"name\\\", \\\"kuangshen\\\"); // 开启事务 Transaction multi = jedis.multi(); String result = jsonObject.toJSONString(); // jedis.watch(result) try { multi.set(\\\"user1\\\", result); multi.set(\\\"user2\\\", result); // 执行事务 multi.exec(); }catch (Exception e){ // 放弃事务 multi.discard(); } finally { // 关闭连接 System.out.println(jedis.get(\\\"user1\\\")); System.out.println(jedis.get(\\\"user2\\\")); jedis.close(); } } } \"]},\"583\":{\"h\":\"SpringBoot整合\",\"t\":[\"导入依赖\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> </dependency> \",\"springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。\",\"jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式\",\"lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式\",\"我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。\",\"那么就一定还存在一个RedisProperties类\",\"之前我们说SpringBoot2.x后默认使用Lettuce来替换Jedis，现在我们就能来验证了。\",\"先看Jedis:\",\"@ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的\",\"然后再看Lettuce：\",\"完美生效。\",\"现在我们回到RedisAutoConfiguration\",\"只有两个简单的Bean\",\"RedisTemplate\",\"StringRedisTemplate\",\"当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。\",\"在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的\",\"说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties\",\"这是一些基本的配置属性。\",\"还有一些连接池相关的配置。注意使用时一定使用Lettuce的连接池。\",\"编写配置文件\",\"# 配置redis spring.redis.host=39.99.xxx.xx spring.redis.port=6379 \",\"使用RedisTemplate\",\"@SpringBootTest class Redis02SpringbootApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test void contextLoads() { // redisTemplate 操作不同的数据类型，api和我们的指令是一样的 // opsForValue 操作字符串 类似String // opsForList 操作List 类似List // opsForHah // 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD // 获取连接对象 //RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); //connection.flushDb(); //connection.flushAll(); redisTemplate.opsForValue().set(\\\"mykey\\\",\\\"kuangshen\\\"); System.out.println(redisTemplate.opsForValue().get(\\\"mykey\\\")); } } \",\"测试结果\",\"此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出：\",\"这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。因此项目中通常需要修改RedisTemplate的序列化方式。\",\"定制RedisTemplate的模板：\",\"我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。\",\"@Configuration public class RedisConfig { @Bean public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { // 将template 泛型设置为 <String, Object> RedisTemplate<String, Object> template = new RedisTemplate(); // 连接工厂，不必修改 template.setConnectionFactory(redisConnectionFactory); /* * 序列化设置 */ // key、hash的key 采用 String序列化方式 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // value、hash的value 采用 Jackson 序列化方式 template.setValueSerializer(RedisSerializer.json()); template.setHashValueSerializer(RedisSerializer.json()); template.afterPropertiesSet(); return template; } } \",\"这样一来，只要实体类进行了序列化，我们存什么都不会有乱码的担忧了。\"]},\"584\":{\"h\":\"自定义Redis工具类\",\"t\":[\"使用RedisTemplate需要频繁调用.opForxxx然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。\",\"工具类参考博客：java redisUtils工具类很全\",\"Redis支持RDB和AOF两种持久化机制，持久化功能有效避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件即可实现数据恢复。\",\"Redis持久化文件加载的流程：\"]},\"585\":{\"h\":\"RDB持久化\"},\"586\":{\"h\":\"什么是RDB\",\"t\":[\"RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程可以分为手动触发和自动触发。默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。\"]},\"587\":{\"h\":\"工作原理\",\"t\":[\"RDB的手动触发分别对应save和bgsave命令：\",\"save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的示例会造成长时间则色，线上环境不建议使用。\",\"bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。\",\"显然bgsave命令是针对save阻塞问题做的优化。因此Redis内部所有的涉及RDB的操作都采用bgsave的方式，而save命令已经废弃，因此这里不做过多介绍。\",\"RDB的自动触发只需要在配置文件redis.conf中开启相关配置即可：\",\"save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存 save 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存 save 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存 \"]},\"588\":{\"h\":\"bgsave\",\"t\":[\"bgsave是异步进行，进行持久化的时候，Redis还可以将继续响应客户端请求 ；\",\"详细具体步骤如下：\",\"执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB/AOF子进程，如果存在bgsave命令直接返回\",\"父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位为微秒\",\"父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令\",\"父进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成RDB的时间，对应info统计的rdb_last_save_time选项\",\"进程发送信号给父进程表示完成，父进程更新统计信息\",\"这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求)。\"]},\"589\":{\"h\":\"bgsave和save对比\",\"t\":[\"命令\",\"save\",\"bgsave\",\"IO类型\",\"同步\",\"异步\",\"阻塞\",\"是\",\"是（阻塞发生在fock()，通常非常快）\",\"复杂度\",\"O(n)\",\"O(n)\",\"优点\",\"不会消耗额外的内存\",\"不阻塞客户端命令\",\"缺点\",\"阻塞客户端命令\",\"需要fork子进程，消耗内存\"]},\"590\":{\"h\":\"优点和缺点\",\"t\":[\"优点：\",\"适合大规模的数据恢复\",\"对数据的完整性要求不高\",\"Redis加载RDB恢复数据远远快于AOF的方式\",\"缺点：\",\"需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了\",\"fork进程的时候，会占用一定的内存空间\",\"RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容RDB格式的问题\",\"也可以简单的说，RDB不适合实时持久化。\"]},\"591\":{\"h\":\"持久化AOF\",\"t\":[\"AOF表示Append Only File，这种模式会将所有的命令都记录下来，恢复的时候就把这个文件全部再执行一遍。\",\"以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。\"]},\"592\":{\"h\":\"什么是AOF\",\"t\":[\"快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。\",\"AOF默认是不开启的，需要进行配置才可以：\",\"appendonly yes # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用 appendfilename \\\"appendonly.aof\\\" # appendfsync always # 每次修改都会sync 消耗性能 appendfsync everysec # 每秒执行一次 sync 可能会丢失这一秒的数据 # appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快 \"]},\"593\":{\"h\":\"优点和缺点\",\"t\":[\"优点\",\"每一次修改都会同步，文件的完整性会更加好\",\"没秒同步一次，可能会丢失一秒的数据\",\"从不同步，效率最高\",\"缺点\",\"相对于数据文件来说，AOF远远大于RDB，修复速度比RDB慢\",\"AOF运行效率也要比RDB慢，所以我们Redis默认的配置就是RDB持久化\"]},\"594\":{\"h\":\"RDB和AOP选择\"},\"595\":{\"h\":\"RDB 和 AOF 对比\",\"t\":[\"比较项\",\"RDB\",\"AOF\",\"启动优先级\",\"低\",\"高\",\"体积\",\"小\",\"大\",\"恢复速度\",\"快\",\"慢\",\"数据安全性\",\"丢数据\",\"根据策略决定\"]},\"596\":{\"h\":\"如何选择使用哪种持久化方式？\",\"t\":[\"一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。\",\"Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。\",\"下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：\",\"当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：\"]},\"597\":{\"h\":\"命令\",\"t\":[\"命令\",\"描述\",\"PSUBSCRIBE pattern [pattern..]\",\"订阅一个或多个符合给定模式的频道。\",\"PUNSUBSCRIBE pattern [pattern..]\",\"退订一个或多个符合给定模式的频道。\",\"PUBSUB subcommand [argument[argument]]\",\"查看订阅与发布系统状态。\",\"PUBLISH channel message\",\"向指定频道发布消息\",\"SUBSCRIBE channel [channel..]\",\"订阅给定的一个或多个频道。\",\"SUBSCRIBE channel [channel..]\",\"退订一个或多个频道\"]},\"598\":{\"h\":\"示例\",\"t\":[\"------------订阅端---------------------- 127.0.0.1:6379> SUBSCRIBE sakura # 订阅sakura频道 Reading messages... (press Ctrl-C to quit) # 等待接收消息 1) \\\"subscribe\\\" # 订阅成功的消息 2) \\\"sakura\\\" 3) (integer) 1 1) \\\"message\\\" # 接收到来自sakura频道的消息 \\\"hello world\\\" 2) \\\"sakura\\\" 3) \\\"hello world\\\" 1) \\\"message\\\" # 接收到来自sakura频道的消息 \\\"hello i am sakura\\\" 2) \\\"sakura\\\" 3) \\\"hello i am sakura\\\" --------------消息发布端------------------- 127.0.0.1:6379> PUBLISH sakura \\\"hello world\\\" # 发布消息到sakura频道 (integer) 1 127.0.0.1:6379> PUBLISH sakura \\\"hello i am sakura\\\" # 发布消息 (integer) 1 -----------------查看活跃的频道------------ 127.0.0.1:6379> PUBSUB channels 1) \\\"sakura\\\" \"]},\"599\":{\"h\":\"原理\",\"t\":[\"每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。\",\"客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。\"]},\"600\":{\"h\":\"缺点\",\"t\":[\"如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。\",\"这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。\"]},\"601\":{\"h\":\"应用\",\"t\":[\"消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）\",\"多人在线聊天室。\",\"稍微复杂的场景，我们就会使用消息中间件MQ处理。\",\"在从前的版本中，Redis是个单线程的程序，除了Redis之外，Node.js与Nginx也是单线程，但是它们都是高性能服务器的典范，不过从Redis6.0开始，增加了多线程的支持，以满足更高的性能，具体可以参考：支持多线程的Redis 6.0终于发布了，那么Redis是如何使用单线程处理那么多的并发客户端连接的？答案就是多路复用。\"]},\"602\":{\"h\":\"非阻塞IO\",\"t\":[\"当我们调用套节字的读写方法，默认它们是阻塞的，比如read方法要传递进去一个参数n，表示读取这么多字节后再返回，如果没有读够线程就会卡在那里，直到新的数据刀来或者连接关闭了，read方法才会返回，线程才能继续处理。而write方法一般来说不会阻塞，除非内核为套接字分配的写缓冲区已经满了，write方法就会阻塞，直到缓存区中有空闲空间挪出来了。\",\"非阻塞IO在套接字对象上提供了一个线程Non_Blocking，当这个选项打开时，读写方法不会阻塞，而是能读多少读多少，能写多少写多少。能读多少取决于内核为套接字分配的读缓冲区内部的数据字节数，能写多少取决于内核为套接字分配的写缓冲区的空闲空间字节数。读方法和写方法都会通过返回值来告知程序实际读写了多少字节。\",\"有了非阻塞IO意味着线程在读写IO时可以不必再阻塞了，读写可以瞬间完成然后程序可以继续干别的事了。\"]},\"603\":{\"h\":\"多路复用\",\"t\":[\"非阻塞IO有个问题，那就是线程要读数据，结果读了一部分就返回了，线程如何知道何时才应该继续。也就是当数据到来时，线程如何得到通知。写也是一样，如果缓冲区满了，写不完，剩下的数据何时才应该续写，线程也应该得到通知。\",\"多路复用（事件轮询）API就是用来解决这个问题的，最简单的事件轮询API是select函数，它是操作系统提供给用户程序的API。输入是读写描述符列表read_fds & write_fds，输出是与之对应的可读可写事件。同时还提供了timeout参数，如果没有任何事件到来，那么久最多等待timeout时间，线程处于阻塞状态。一旦期间有任何事情刀来，就可以立即返回。时间过了之后还是没有任何事件到来，也会立即返回。拿到事件后，线程就可以继续挨个处理相应的事件。处理完了继续过来轮询。于是线程就进入了一个死循环，我们把这个死循环称为事件循环，一个循环为一个周期。\",\"每个客户端套接字socket都有对应的读写文件描述符。\",\"read_events,write_events = select(read_fds,write_fds,timeout) for event in read_events: handle_read(event.fd) for event in write_events: handle_write(event.fd) # 处理其它事情，如定时任务等 handle_others() \",\"因为我们通过select系统调用同时处理多个通道描述符的读写事件，因此我们将这类系统调用称为多路复用API。现代操作系统的多路复用API已经不再使用使用select系统调用，而改用epoll(linux)和kqueue(freebsd & macosx)，因为select系统调用的性能再描述符特别多时性能会非常差。它使用起来可能在形式上略有差异，但是本质上都是差不多的，都可以使用上面的伪代码逻辑进行理解。\"]},\"604\":{\"h\":\"指令队列\",\"t\":[\"Redis会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务。\"]},\"605\":{\"h\":\"响应队列\",\"t\":[\"Redis同样会为每个客户端套接字关联一个响应队列。Redis服务器通过响应队列来将指令的返回结果回复给客户端。如果队列为空，那么意味着连接暂时处于空闲状态，不需要去获取写事件，也就是可以将当前的客户端描述符write_fds里面移出来。等到队列有数据了，再将描述符放进去。避免select系统调用立即返回写事件，结果发现没什么数据可以写。出现这种情况的线程会飙高CPU。\"]},\"606\":{\"h\":\"概念\",\"t\":[\"主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。\",\"默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。\"]},\"607\":{\"h\":\"作用\",\"t\":[\"数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。\",\"故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式\",\"负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。\",\"高可用基石：主从复制还是哨兵和集群能够实施的基础。\"]},\"608\":{\"h\":\"为什么使用集群\",\"t\":[\"单台服务器难以负载大量的请求\",\"单台服务器故障率高，系统崩坏概率大\",\"单台服务器内存容量有限。\"]},\"609\":{\"h\":\"环境配置\",\"t\":[\"我们在讲解配置文件的时候，注意到有一个replication模块 (见Redis.conf中第8条)\",\"查看当前库的信息：info replication\",\"127.0.0.1:6379> info replication # Replication role:master # 角色 connected_slaves:0 # 从机数量 master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 \",\"既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：\",\"端口号\",\"pid文件名\",\"日志文件名\",\"rdb文件名\",\"启动单机多服务集群：\"]},\"610\":{\"h\":\"一主二从配置\",\"t\":[\"默认情况下，每台Redis服务器都是主节点；我们一般情况下只用配置从机就好了！\",\"认老大！一主（79）二从（80，81）\",\"使用SLAVEOF host port就可以为从机配置主机了。\",\"然后主机上也能看到从机的状态：\",\"我们这里是使用命令搭建，是暂时的，==真实开发中应该在从机的配置文件中进行配置，==这样的话是永久的。\"]},\"611\":{\"h\":\"使用规则\",\"t\":[\"从机只能读，不能写，主机可读可写但是多用于写。\",\" 127.0.0.1:6381> set name sakura # 从机6381写入失败 (error) READONLY You can't write against a read only replica. 127.0.0.1:6380> set name sakura # 从机6380写入失败 (error) READONLY You can't write against a read only replica. 127.0.0.1:6379> set name sakura OK 127.0.0.1:6379> get name \\\"sakura\\\" \",\"当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。\",\"当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。\",\"第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：\",\"从机手动执行命令slaveof no one,这样执行以后从机会独立出来成为一个主机\",\"使用哨兵模式（自动选举）\",\"如果没有老大了，这个时候能不能选择出来一个老大呢？手动！\",\"如果主机断开了连接，我们可以使用SLAVEOF no one让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！\"]},\"612\":{\"h\":\"复制原理\"},\"613\":{\"h\":\"复制过程\"},\"614\":{\"h\":\"数据同步\"},\"615\":{\"h\":\"全量复制\"},\"616\":{\"h\":\"部分复制\"},\"617\":{\"h\":\"心跳\"},\"618\":{\"h\":\"异步复制\",\"t\":[\"主节点不但负责数据读写，还负责把写命令同步给从节点。写命令的发送过程是异步完成的，也就是说主节点自身处理完写命令后直接返回给客户端，并不等待从节点复制完成，如下图所示：\"]},\"619\":{\"h\":\"作用\",\"t\":[\"主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。\"]},\"620\":{\"h\":\"单机单个哨兵\",\"t\":[\"哨兵的作用：\",\"通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。\",\"当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。\"]},\"621\":{\"h\":\"多哨兵模式\",\"t\":[\"Redis的主从复制模式可以将主节点的数据改变同步给从节点，这样从节点就可以起到两个作用：\",\"作为主节点的备份，一旦主节点出了故障不可达的情况，从节点可以作为后备“顶上来”，并且保证数据尽量不丢失（主从复制时最终一致性）。第二，从节点可以扩展主节点的读能力，一旦主节点不能支撑住大并发量的读操作\",\"第二，从节点可以扩展主节点的读能力，一旦主节点不能支撑住大并发量的读操作，从节点可以在以顶程度上帮助主节点分担读压力\",\"但是主从复制也带来了以下问题：\",\"一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要人工干预\",\"主节点的写能力收到单机的限制\",\"主节点的存储能力收到单机的限制\",\"当主节点出现故障时，Redis的哨兵模式能自动完成故障发现和故障转移，并通知应用方，从而实现真正的高可用。Redis Sentinel是一个分布式架构，其中包含了若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当它发现节点不可达时，会对节点但做下线标识。如果被标识的是主节点，它还会和其他Sentinel节点进行“协商”，当大多数Sentinel节点都认为主节点不可达时，它们会选举出一个Sentinel节点来完成自动故障转移的工作，同时会将这个变化实时通知给Redis应用方。整个过程完全时自动的，不需要人工来介入，所以这套方案很有效地解决了Redis高可用的问题。\",\"哨兵模式与主从复制的区别：\",\"哨兵的核心配置\",\"sentinel monitor mymaster 127.0.0.1 6379 1 \",\"数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。\",\"测试\",\"redis-sentinel xxx/sentinel.conf \",\"成功启动哨兵模式\",\"此时哨兵监视着我们的主机6379，当我们断开主机后：\"]},\"622\":{\"h\":\"哨兵模式优缺点\"},\"623\":{\"h\":\"优点\",\"t\":[\"哨兵集群，基于主从复制模式，所有主从复制的优点，它都有\",\"主从可以切换，故障可以转移，系统的可用性更好\",\"哨兵模式是主从模式的升级，手动到自动，更加健壮\"]},\"624\":{\"h\":\"缺点\",\"t\":[\"Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦\",\"实现哨兵模式的配置其实是很麻烦的，里面有很多配置项\",\"完整的哨兵模式配置文件 sentinel.conf\",\"# Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379 port 26379 # 哨兵sentinel的工作目录 dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符\\\".-_\\\"组成。 # quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了 # sentinel monitor <master-name> <ip> <redis-port> <quorum> sentinel monitor mymaster 127.0.0.1 6379 1 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码 # 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 # sentinel auth-pass <master-name> <password> sentinel auth-pass mymaster MySUPER--secret-0123passw0rd # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒 # sentinel down-after-milliseconds <master-name> <milliseconds> sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步， 这个数字越小，完成failover所需的时间就越长， 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。 # sentinel parallel-syncs <master-name> <numslaves> sentinel parallel-syncs mymaster 1 # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。 #2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。 #3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout <master-name> <milliseconds> sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。 #对于脚本的运行结果有以下规则： #若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10 #若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。 #如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 #一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本， #这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数， #一个是事件的类型， #一个是事件的描述。 #如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。 #通知脚本 # sentinel notification-script <master-name> <script-path> sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本 # 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。 # 以下参数将会在调用脚本时传给脚本: # <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port> # 目前<state>总是“failover”, # <role>是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的 # 这个脚本应该是通用的，能被多次调用，不是针对性的。 # sentinel client-reconfig-script <master-name> <script-path> sentinel client-reconfig-script mymaster /var/redis/reconfig.sh \",\"Redis当中使用了Raft算法实现领导者选举。\"]},\"625\":{\"h\":\"缓存穿透\"},\"626\":{\"h\":\"概念\",\"t\":[\"在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。\"]},\"627\":{\"h\":\"解决方案\",\"t\":[\"布隆过滤器：对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。\",\"缓存空对象:一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。\",\"这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间\",\"即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。\"]},\"628\":{\"h\":\"缓存击穿\"},\"629\":{\"h\":\"概念\",\"t\":[\"相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。\",\"比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。\"]},\"630\":{\"h\":\"解决方案\",\"t\":[\"设置热点数据永不过期\",\"这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。\",\"加互斥锁(分布式锁)\",\"在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。\"]},\"631\":{\"h\":\"缓存雪崩\"},\"632\":{\"h\":\"概念\",\"t\":[\"大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。\"]},\"633\":{\"h\":\"解决方案\",\"t\":[\"redis高可用\",\"这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群\",\"限流降级\",\"这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。\",\"数据预热\",\"数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。\",\"[1] Redis开发与运维\",\"[2] Raft维基百科\"]},\"634\":{\"h\":\"Dubbo\"},\"635\":{\"h\":\"Dubbo底层实现原理\",\"t\":[\"链接：https://note.youdao.com/ynoteshare/index.html?id=ca746f44f16b862e3189e5f24b3a8e64&type=note&_time=1685805324275\"]},\"636\":{\"h\":\"Dubbo3.0新特性\"},\"637\":{\"h\":\"dubbo协议\",\"t\":[\"dubbo协议由于请求中没有多余的无用的字节，都是必要的字节，因此性能会更好，并且每个Dubbo请求和响应中都有一个请求ID，这样可以基于一个Socket连接同时发送多个Dubbo请求，不用担心请求和响应对不上，所以dubbo协议成为了Dubbo框架中的默认协议。\",\"但是dubbo协议一旦涉及到跨RPC框架，比如一个Dubbo服务要调用gRPC服务，就比较麻烦了。因为发一个dubbo协议的请求给一个gRPC服务，gRPC服务只会按照gRPC的格式来解析字节流，最终肯定会解析不成功的。\",\"dubbo协议虽好，但是不够通用，所以这就出现了Triple协议，Triple协议是基于HTTP2，没有性能问题，另外HTTP协议非常通用，兼容起来也比较简单，而且还有很多额外的功能，比如流式调用。\"]},\"638\":{\"h\":\"Triple协议\"},\"639\":{\"h\":\"Dubbo服务注册与引入底层原理\",\"t\":[\"参考链接：https://note.youdao.com/ynoteshare/index.html?id=bbeb46c842c84cfcdbf1d1f040fe40c7&type=note&_time=1685977459844\",\"服务导出与服务引入的流程图：https://www.processon.com/view/link/62c441e80791293dccaebded\"]},\"640\":{\"h\":\"服务导出\"},\"641\":{\"h\":\"服务引入\"},\"642\":{\"h\":\"Dubbo服务调用底层原理\"},\"643\":{\"h\":\"Http2原理解析\",\"t\":[\"Http2可以支持同时发在一个socket上送多个请求。\",\"帧长度\",\"帧类型\"]},\"644\":{\"h\":\"Mybatis源码分析\"},\"645\":{\"h\":\"Mybatis源码体系\",\"t\":[\"JDBC的缺点：\",\"sql语句耦合在代码中，维护性差\",\"JDBC频繁的创建和关闭数据库连接，连接消耗大\",\"不好设置缓存\",\"参数设置非常不方便\",\"处理查询结果集，类型转换非常麻烦\",\"Mybatis的体系结构如下：\",\"Mybatis的功能架构可以分为三层：\",\"API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操作数据库，接口层一接收到请求就会调用数据处理层来玩完成具体的数据处理\",\"数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等，它的主要目的是根据调用的请求完成一次数据库操作\",\"基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件，为上层的数据层提供最基础的支撑\",\"解析过程：https://www.processon.com/view/link/5efc2381f346fb1ae58925c1\",\"解析到的所有对象的数据会存储到：org.apache.ibatis.session.Configuration。\",\"Mybatis提供的默认的别名注册器：\",\" public TypeAliasRegistry() { registerAlias(\\\"string\\\", String.class); registerAlias(\\\"byte\\\", Byte.class); registerAlias(\\\"long\\\", Long.class); registerAlias(\\\"short\\\", Short.class); registerAlias(\\\"int\\\", Integer.class); registerAlias(\\\"integer\\\", Integer.class); registerAlias(\\\"double\\\", Double.class); registerAlias(\\\"float\\\", Float.class); registerAlias(\\\"boolean\\\", Boolean.class); registerAlias(\\\"byte[]\\\", Byte[].class); registerAlias(\\\"long[]\\\", Long[].class); registerAlias(\\\"short[]\\\", Short[].class); registerAlias(\\\"int[]\\\", Integer[].class); registerAlias(\\\"integer[]\\\", Integer[].class); registerAlias(\\\"double[]\\\", Double[].class); registerAlias(\\\"float[]\\\", Float[].class); registerAlias(\\\"boolean[]\\\", Boolean[].class); registerAlias(\\\"_byte\\\", byte.class); registerAlias(\\\"_long\\\", long.class); registerAlias(\\\"_short\\\", short.class); registerAlias(\\\"_int\\\", int.class); registerAlias(\\\"_integer\\\", int.class); registerAlias(\\\"_double\\\", double.class); registerAlias(\\\"_float\\\", float.class); registerAlias(\\\"_boolean\\\", boolean.class); registerAlias(\\\"_byte[]\\\", byte[].class); registerAlias(\\\"_long[]\\\", long[].class); registerAlias(\\\"_short[]\\\", short[].class); registerAlias(\\\"_int[]\\\", int[].class); registerAlias(\\\"_integer[]\\\", int[].class); registerAlias(\\\"_double[]\\\", double[].class); registerAlias(\\\"_float[]\\\", float[].class); registerAlias(\\\"_boolean[]\\\", boolean[].class); registerAlias(\\\"date\\\", Date.class); registerAlias(\\\"decimal\\\", BigDecimal.class); registerAlias(\\\"bigdecimal\\\", BigDecimal.class); registerAlias(\\\"biginteger\\\", BigInteger.class); registerAlias(\\\"object\\\", Object.class); registerAlias(\\\"date[]\\\", Date[].class); registerAlias(\\\"decimal[]\\\", BigDecimal[].class); registerAlias(\\\"bigdecimal[]\\\", BigDecimal[].class); registerAlias(\\\"biginteger[]\\\", BigInteger[].class); registerAlias(\\\"object[]\\\", Object[].class); registerAlias(\\\"map\\\", Map.class); registerAlias(\\\"hashmap\\\", HashMap.class); registerAlias(\\\"list\\\", List.class); registerAlias(\\\"arraylist\\\", ArrayList.class); registerAlias(\\\"collection\\\", Collection.class); registerAlias(\\\"iterator\\\", Iterator.class); registerAlias(\\\"ResultSet\\\", ResultSet.class); } \",\"二级缓存的实现采用了装饰器设计模式：org.apache.ibatis.cache.impl.PerpetualCache。过期策略可以设置：LRU、FIFO、SOFT、WEAK等，默认是LRU。\",\"每一个CRUD操作最终都会解析为一个：org.apache.ibatis.mapping.MappedStatement。\",\"sql对应的对象：\",\"Dynamic sqlSource（需要拼接参数的）\",\"Raw sqlSource（不需要拼接参数的）\",\"动态标签会被解析为：\",\"解析SQL NODE：org.apache.ibatis.scripting.xmltags.XMLScriptBuilder\",\" protected MixedSqlNode parseDynamicTags(XNode node) { List<SqlNode> contents = new ArrayList<>(); NodeList children = node.getNode().getChildNodes(); for (int i = 0; i < children.getLength(); i++) { XNode child = node.newXNode(children.item(i)); if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) { String data = child.getStringBody(\\\"\\\"); TextSqlNode textSqlNode = new TextSqlNode(data); if (textSqlNode.isDynamic()) { contents.add(textSqlNode); isDynamic = true; } else { contents.add(new StaticTextSqlNode(data)); } } else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) { // issue #628 String nodeName = child.getNode().getNodeName(); NodeHandler handler = nodeHandlerMap.get(nodeName); if (handler == null) { throw new BuilderException(\\\"Unknown element <\\\" + nodeName + \\\"> in SQL statement.\\\"); } handler.handleNode(child, contents); isDynamic = true; } } return new MixedSqlNode(contents); } \"]},\"646\":{\"h\":\"数据操作过程源码剖析\",\"t\":[\"SqlSession是一种门面设计模式。\",\"Executor的实现类：\",\"SIMPLE（默认）\",\"REUSE：执行器会重用PrepareStatement\",\"BATCH：执行器不仅重用语句还会执行批量更新\",\"拦截器的作用：\",\"分页\",\"读写分离\",\"修改SQL，拿到SQL语句\",\"动态标签解析：ongl表达式。\"]},\"647\":{\"h\":\"深入理解Netty\"},\"648\":{\"h\":\"Netty特点\"},\"649\":{\"h\":\"作用\"},\"650\":{\"h\":\"良好的设计\"},\"651\":{\"h\":\"使用简单\"},\"652\":{\"h\":\"性能\"},\"653\":{\"h\":\"安全\"},\"654\":{\"h\":\"Netty架构实现\"},\"655\":{\"h\":\"Netty的Hello world\"},\"656\":{\"h\":\"Netty模块分析\"},\"657\":{\"h\":\"Netty整体执行流程分析\"},\"658\":{\"h\":\"Netty对Socket的实现\"},\"659\":{\"h\":\"Socket使用示例\"},\"660\":{\"h\":\"消息的广播\"},\"661\":{\"h\":\"心跳机制\"},\"662\":{\"h\":\"Netty与WebSocket\"},\"663\":{\"h\":\"实现与原理分析\"},\"664\":{\"h\":\"WebSocket生命周期分解\"},\"665\":{\"h\":\"Google Protobuf\"},\"666\":{\"h\":\"简介\"},\"667\":{\"h\":\"proto文件\"},\"668\":{\"h\":\"解析和序列化\"},\"669\":{\"h\":\"编写message\"},\"670\":{\"h\":\"读取message\"},\"671\":{\"h\":\"多协议消息\"},\"672\":{\"h\":\"最佳实践\"},\"673\":{\"h\":\"Apache Thrift\"},\"674\":{\"h\":\"简介\"},\"675\":{\"h\":\"thrift文件\"},\"676\":{\"h\":\"最佳实践\"},\"677\":{\"h\":\"传输格式\"},\"678\":{\"h\":\"传输方式\"},\"679\":{\"h\":\"服务模型\"},\"680\":{\"h\":\"多语言的支持\"},\"681\":{\"h\":\"GRPC\"},\"682\":{\"h\":\"简介\"},\"683\":{\"h\":\"相关示例\"},\"684\":{\"h\":\"流式调用\"},\"685\":{\"h\":\"IO与NIO\"},\"686\":{\"h\":\"IO与NIO的区别\"},\"687\":{\"h\":\"Buffer\"},\"688\":{\"h\":\"Channel\"},\"689\":{\"h\":\"Selector\"},\"690\":{\"h\":\"NIO网络编程\"},\"691\":{\"h\":\"字符编码集\"},\"692\":{\"h\":\"零拷贝\"},\"693\":{\"h\":\"传统的IO流程\"},\"694\":{\"h\":\"零拷贝实现原理\"},\"695\":{\"h\":\"EventLoopGroup\"},\"696\":{\"h\":\"Netty中的Future对象\"},\"697\":{\"h\":\"ChannelFuture\"},\"698\":{\"h\":\"异步读写架构\"},\"699\":{\"h\":\"Promise\"},\"700\":{\"h\":\"ServerBootStrap\"},\"701\":{\"h\":\"核心方法\"},\"702\":{\"h\":\"初始化和注册方法\"},\"703\":{\"h\":\"Reactor模式\"},\"704\":{\"h\":\"传统的模型\"},\"705\":{\"h\":\"Reactor模式\"},\"706\":{\"h\":\"Netty中的Reactor线程模型\"},\"707\":{\"h\":\"自适应缓冲区\"},\"708\":{\"h\":\"Channel实现原理\"},\"709\":{\"h\":\"Channel的四大组件\"},\"710\":{\"h\":\"Channel与ChannelPipeline\"},\"711\":{\"h\":\"ChannelOption与AttributeKey\"},\"712\":{\"h\":\"ChannelHandler与ChannelHandlerContext\"},\"713\":{\"h\":\"Channel选择器\"},\"714\":{\"h\":\"Channel注册流程\"},\"715\":{\"h\":\"Netty中的设计原则\"},\"716\":{\"h\":\"设计原则\"},\"717\":{\"h\":\"业务线程池\"},\"718\":{\"h\":\"ByteBuf实现原理\"},\"719\":{\"h\":\"ByteBuf使用示例\"},\"720\":{\"h\":\"ByteBuf数据结构\"},\"721\":{\"h\":\"复合缓冲区\"},\"722\":{\"h\":\"引用计数\"},\"723\":{\"h\":\"实现原理\"},\"724\":{\"h\":\"AtomicIntegerFieldUpdater\"},\"725\":{\"h\":\"Netty中的处理器\"},\"726\":{\"h\":\"自定义编解码器\"},\"727\":{\"h\":\"ReplayingDecoder\"},\"728\":{\"h\":\"LengthFieldBasedFrameDecoder\"},\"729\":{\"h\":\"常见编解码器总结\"},\"730\":{\"h\":\"TCP粘包与拆包\"},\"731\":{\"h\":\"粘包与拆包\"},\"732\":{\"h\":\"解决方案\"},\"733\":{\"h\":\"观察者模式\"},\"734\":{\"h\":\"适配器模式\"},\"735\":{\"h\":\"模板方法模式\"},\"736\":{\"h\":\"Spring AOP\"},\"737\":{\"h\":\"知识储备\"},\"738\":{\"h\":\"Java 基础部分\"},\"739\":{\"h\":\"OOP 部分\"},\"740\":{\"h\":\"GOF23 设计模式\"},\"741\":{\"h\":\"Spring 核心基础\"},\"742\":{\"h\":\"OOP局限性\"},\"743\":{\"h\":\"AOP常见使用场景\"},\"744\":{\"h\":\"日志场景\"},\"745\":{\"h\":\"统计场景\"},\"746\":{\"h\":\"安防场景\"},\"747\":{\"h\":\"性能场景\"},\"748\":{\"h\":\"Java AOP设计模式\"},\"749\":{\"h\":\"代理模式\"},\"750\":{\"h\":\"判断模式\"},\"751\":{\"h\":\"拦截模式\"},\"752\":{\"h\":\"Spring AOP 功能概述\"},\"753\":{\"h\":\"AOP设计核心\"},\"754\":{\"h\":\"Spring AOP编程模型\"},\"755\":{\"h\":\"Spring AOP Advice类型\"},\"756\":{\"h\":\"Spring AOP代理实现\"},\"757\":{\"h\":\"JDK动态代理\"},\"758\":{\"h\":\"CGLIB动态代理\"},\"759\":{\"h\":\"AspectJ代理\"},\"760\":{\"h\":\"面试题\"},\"761\":{\"h\":\"Spring AOP和AspectJ AOP存在哪些差别？\"},\"762\":{\"h\":\"@AspectJ注解驱动\"},\"763\":{\"h\":\"编程方式创建@AspectJ代理\"},\"764\":{\"h\":\"标准工厂API\"},\"765\":{\"h\":\"@AspectJ Pointcut指令与表达式\"},\"766\":{\"h\":\"XML配置Pointcut\"},\"767\":{\"h\":\"API实现Pointcut\"},\"768\":{\"h\":\"@AspectJ拦截动作\"},\"769\":{\"h\":\"XML配置Around Advice\"},\"770\":{\"h\":\"@AspectJ的前置动作\"},\"771\":{\"h\":\"XML配置Before Advice\"},\"772\":{\"h\":\"API实现Before Advice\"},\"773\":{\"h\":\"@Aspect后置动作\"},\"774\":{\"h\":\"XML配置After Advice\"},\"775\":{\"h\":\"API实现After Advice\"},\"776\":{\"h\":\"自动动态代理\"},\"777\":{\"h\":\"替换TargetSource\"},\"778\":{\"h\":\"面试题\"},\"779\":{\"h\":\"Spring AOP支持哪些类型的Advice？\"},\"780\":{\"h\":\"Spring AOP编程模型有哪些，代表组件有哪些？\"},\"781\":{\"h\":\"Spring AOP三种实现方式是如何进行设计的？\"},\"782\":{\"h\":\"API整体设计\"},\"783\":{\"h\":\"接入点接口Joinpoint\"},\"784\":{\"h\":\"Joinpoint条件接口\"},\"785\":{\"h\":\"Pointcut组合实现\"},\"786\":{\"h\":\"Pointcut便利实现\"},\"787\":{\"h\":\"Pointcut AspectJ实现\"},\"788\":{\"h\":\"Joinpoint执行动作接口\"},\"789\":{\"h\":\"Before Advice标准实现\"},\"790\":{\"h\":\"Before Advice AspectJ实现\"},\"791\":{\"h\":\"After Advice标准实现\"},\"792\":{\"h\":\"After Advice AspectJ实现\"},\"793\":{\"h\":\"Advisor接口\"},\"794\":{\"h\":\"PointcutAdvisor接口\"},\"795\":{\"h\":\"IntorductionAdvisor接口\"},\"796\":{\"h\":\"AdvisorAdapter接口\"},\"797\":{\"h\":\"AopProxy接口\"},\"798\":{\"h\":\"AopProxyFactory\"},\"799\":{\"h\":\"JDK AopProxy实现\"},\"800\":{\"h\":\"CGLIB AopProxy实现\"},\"801\":{\"h\":\"AdvisedSupport\"},\"802\":{\"h\":\"AdvisorChainFactory接口\"},\"803\":{\"h\":\"TargetSource接口\"},\"804\":{\"h\":\"ProxyCreatorSupport\"},\"805\":{\"h\":\"AdvisedSupportListener\"},\"806\":{\"h\":\"ProxyFactory\"},\"807\":{\"h\":\"ProxyFactoryBean\"},\"808\":{\"h\":\"AspectJProxyFactory\"},\"809\":{\"h\":\"AbstractAutoProxyCreator\"},\"810\":{\"h\":\"IoC容器自动代理标准实现\"},\"811\":{\"h\":\"AspectJAwareAdvisorAutoProxyCreator\"},\"812\":{\"h\":\"AopInfrastructureBean接口\"},\"813\":{\"h\":\"AopContext\"},\"814\":{\"h\":\"AopProxyUtils\"},\"815\":{\"h\":\"AopUtils\"},\"816\":{\"h\":\"AspectJ Enable模块驱动\"},\"817\":{\"h\":\"AspectJ XML配置驱动实现\"},\"818\":{\"h\":\"<aop:config /> Schema-based实现\"},\"819\":{\"h\":\"<aop:aspect /> Schema-based实现\"},\"820\":{\"h\":\"Pointcut Schema-based实现\"},\"821\":{\"h\":\"Around Advice Schema-based实现\"},\"822\":{\"h\":\"Before Advice Schema-based实现\"},\"823\":{\"h\":\"After Advice Schema-based实现\"},\"824\":{\"h\":\"After Returning Advice Schema-based实现\"},\"825\":{\"h\":\"After Throwing Advice Schema-based实现\"},\"826\":{\"h\":\"Advisor Schema-based实现\"},\"827\":{\"h\":\"Introduction Schema-based实现\"},\"828\":{\"h\":\"作用域代理Schema-based实现\"},\"829\":{\"h\":\"面试题\"},\"830\":{\"h\":\"Spring AOP Advice XML标签有哪些？\"},\"831\":{\"h\":\"请解释Spring @EnbaleAspectJAutoProxy的原理？\"},\"832\":{\"h\":\"Spring Configuration Class CGLIB提升与AOP类代理的关系？\"},\"833\":{\"h\":\"创建型模式\"},\"834\":{\"h\":\"抽象工厂模式\"},\"835\":{\"h\":\"构建器模式\"},\"836\":{\"h\":\"工厂方法模式\"},\"837\":{\"h\":\"原型模式\"},\"838\":{\"h\":\"单例模式\"},\"839\":{\"h\":\"结构型模式\"},\"840\":{\"h\":\"适配器模式\"},\"841\":{\"h\":\"组合模式\"},\"842\":{\"h\":\"装饰器模式\"},\"843\":{\"h\":\"享元模式\"},\"844\":{\"h\":\"代理模式\"},\"845\":{\"h\":\"行为型模式\"},\"846\":{\"h\":\"模板方法模式\"},\"847\":{\"h\":\"责任链模式\"},\"848\":{\"h\":\"观察者模式\"},\"849\":{\"h\":\"策略模式\"},\"850\":{\"h\":\"命令模式\"},\"851\":{\"h\":\"状态模式\"},\"852\":{\"h\":\"面试题\"},\"853\":{\"h\":\"GOF 23设计模式和它的归类？\"},\"854\":{\"h\":\"举例装饰器模式和代理模式的区别？\"},\"855\":{\"h\":\"请举例说明Spring Framework中使用设计模式的实现？\"},\"856\":{\"h\":\"Spring 事件中的应用\"},\"857\":{\"h\":\"Spring事务中的应用\"},\"858\":{\"h\":\"核心API\"},\"859\":{\"h\":\"理解TransactionDefinition\"},\"860\":{\"h\":\"理解PlatformTransactionManager\"},\"861\":{\"h\":\"理解事务传播\"},\"862\":{\"h\":\"Spring 缓存中的应用\"},\"863\":{\"h\":\"Spring本地调度中的应用\"},\"864\":{\"h\":\"面试题\"},\"865\":{\"h\":\"Spring AOP在Spring Framework特性运用？\"},\"866\":{\"h\":\"Spring事务传播的原理？\"},\"867\":{\"h\":\"Spring AOP与IoC功能整合的设计模式？\"},\"868\":{\"h\":\"SpringBoot\"},\"869\":{\"h\":\"@SpringBootApplication\"},\"870\":{\"h\":\"注解解析\"},\"871\":{\"h\":\"@Configuration\"},\"872\":{\"h\":\"@ComponentScan\"},\"873\":{\"h\":\"@EnableAutoConfiguration\"},\"874\":{\"h\":\"启动执行流程\"},\"875\":{\"h\":\"流程概览\"},\"876\":{\"h\":\"启动详情\"},\"877\":{\"h\":\"自动装配\"},\"878\":{\"h\":\"打包过程\"},\"879\":{\"h\":\"构建工具\"},\"880\":{\"h\":\"spring-boot-maven-plugin\"},\"881\":{\"h\":\"Spotify Maven Plugin\"},\"882\":{\"h\":\"Jib Maven Plugin\"},\"883\":{\"h\":\"修改之前\"},\"884\":{\"h\":\"使用Alpine镜像\"},\"885\":{\"h\":\"分层构建镜像\"},\"886\":{\"h\":\"Maven中内置变量\"},\"887\":{\"h\":\"可能存在的问题\"},\"888\":{\"h\":\"SpringCloud\"},\"889\":{\"h\":\"SpringFramework\"},\"890\":{\"h\":\"Spring特性总览\"},\"891\":{\"h\":\"Spring 中值得学习的地方\",\"t\":[\"Java语言特性，例如反射、动态代理、枚举、泛型、注解、ARM、Lambda语法\",\"设计思想和模式的实现，如OOP，DDD，TDD，GoF23等\",\"Java API的封装与简化，如JDBC，事务，Transaction，Servlet，JPA，JMX ，Bean Validation\",\"JSR规范的适配与实现\",\"第三方框架的整合，如MyBatis整合Hibernetes和Redis\"]},\"892\":{\"h\":\"Spring核心特性\",\"t\":[\"IOC容器（IOC Container）\",\"Spring事件（Events）\",\"资源管理（Resources）\",\"国际化（i18n）\",\"校验（Validation）\",\"数据绑定（Data Binding）\",\"类型转换（Type Conversion）\",\"Spring表达式（Spring Express Language）\",\"面向切面编程（AOP）\"]},\"893\":{\"h\":\"Spring数据存储\",\"t\":[\"JDBC\",\"事务抽象（Transactions）\",\"DAO支持（DAO Support）\",\"O/R映射（O/R Mapping）\",\"XML编列（XML Marshalling）\"]},\"894\":{\"h\":\"Spring Web技术\",\"t\":[\"Web Servlet技术栈 \",\"Spring MVC\",\"WebSocket\",\"SockJS\",\"Web Reactive技术栈 \",\"Spring WebFlux\",\"WebClient\",\"WebSocket\"]},\"895\":{\"h\":\"Spring技术整合\",\"t\":[\"远程调用（Remoting）\",\"Java消息服务（JMS）\",\"Java连接架构（JCA）\",\"Java管理扩展（JMX）\",\"Java邮件客户端（Email）\",\"本地任务（Taks）\",\"本地调度（Scheduling）\",\"缓存抽象（Caching）\"]},\"896\":{\"h\":\"Spring测试\",\"t\":[\"模拟对象（Mock Objects）\",\"TestContext框架（TestContext Framework）\",\"Spring MVC测试（Spring MVC Test）\",\"Web 测试客户端（Web TestClient）\"]},\"897\":{\"h\":\"Spring版本特性\",\"t\":[\"Spring Framework版本\",\"Java标准版\",\"Java企业版\",\"1.x\",\"1.3+\",\"J2EE 1.3+\",\"2.x\",\"1.4.2+\",\"J2EE 1.3+\",\"3.x\",\"5+\",\"J2EE1.4和JavaEE5\",\"4.x\",\"6+\",\"Java EE6和7\",\"5.x\",\"8+\",\"Java EE7\"]},\"898\":{\"h\":\"Spring模块化设计\",\"t\":[\"仓库链接\"]},\"899\":{\"h\":\"Spring编程模型\",\"t\":[\"面向对象编程\",\"锲约接口：Aware、BeanPostProcessor...\",\"设计模式：观察者模式、组合模式、模板模式...\",\"对象继承：Abstract类\",\"面向切面编程\",\"动态代理：JDKDynamicAopProxy\",\"字节码提升：ASM、CGLib、AspectJ\",\"面向元编程\",\"注解：模式注解（@Component、@Service、@Respository...）\",\"配置：Environment抽象、PropertySources、BeanDefinition...\",\"泛型：Generic TypeResolver、Resolvable Type...\",\"函数驱动\",\"函数接口：ApplicationEventPublisher\",\"Reactive：Spring WebFlux\",\"模块驱动\",\"Maven Artifacts\",\"OSGI Bundies\",\"Java 9 Automatic Modules\",\"Spring @Enable*\",\"​\"]},\"900\":{\"h\":\"Spring的核心价值\",\"t\":[\"生态系统 \",\"Spring Boot\",\"Spring Cloud\",\"Spring Security\",\"Spring Data\",\"其他\",\"API抽象设计 \",\"AOP抽象\",\"事务抽象\",\"Environment抽象\",\"生命周期\",\"编程模型 \",\"面向对象编程：契约接口\",\"面向切面编程：动态代理、字节码提升\",\"面向元编程：配置元信息、注解、配置\",\"面向模块编程：Maven Artifacts、Java9 Automatic Modules\",\"Spring @Enable*注解\",\"面向函数式编程：Lambda、Reactive\",\"设计思想 \",\"Object-Oriented Programming（OOP）\",\"Ioc/DI\",\"Domain-Driven Development（DDD）\",\"Test-Driven Development（TDD）\",\"Event-Driven Programing（EDP）\",\"Functional Programing（FP）\",\"设计模式 \",\"专属模式 \",\"前缀模式：Enable模式 \",\"Configurable模式\",\"后缀模式 \",\"处理器模式（Process、Resolver、Handler）\",\"意识模式（Aware）\",\"配置器模式（Configuror）\",\"选择器模式（ImportSelector）\",\"传统GoF23\",\"用户基础 \",\"Spring用户 Spring Framework、SpringBoot、Spring Cloud\",\"传统用户 Java SE、Java EE\"]},\"901\":{\"h\":\"面试题\"},\"902\":{\"h\":\"什么是Spring Framework？\",\"t\":[\"Spring Framework提供一个完整性的编程或配置的一个现代化的基于Java的企业的应用，Spring的核心特点是在应用级别上的基础设施建设。\",\"Spring使得你的应用开发变的更容易，它可以提供任何你想要的东西，并是拥抱企业环境的Java语言，并且支持可以运行在JVM上面的其他语言，比如Groovy或者Kotlin，同时也提供一些弹性，根据软件的需要提供不同的软件架构。\"]},\"903\":{\"h\":\"Spring Framwork有哪些核心模块？\",\"t\":[\"Spring-core：Spring 基础API模块，如资源管理、泛型处理\",\"Spring-beans：Spring Bean相关，如依赖查找，依赖注入\",\"Spring-aop：Spring AOP处理，如动态代理，AOP字节码提升\",\"Spring-context：事件驱动、注解驱动、模块驱动\",\"Spring-expresson：Spring 表达式语言模块\"]},\"904\":{\"h\":\"Spring Framework的优势和不足是什么？\",\"t\":[\"待定...\"]},\"905\":{\"h\":\"IoC的发展简介\",\"t\":[\"1983年，好莱坞原则\",\"1988年，控制反转\",\"1996年，Inversion of control -> Hollywood principle\",\"2004年，Martin Fowler提出了自己对IoC以及DI的理解\",\"2005年，Martin Fowler对IoC做出了进一步的说明\"]},\"906\":{\"h\":\"IoC主要实现策略\",\"t\":[\"使用service locator pattern（服务定位模式）\",\"通过依赖注入： \",\"构造器注入\",\"参数注入\",\"Setter注入\",\"接口注入\",\"上下文的依赖查询（beancontext）\",\"模板方法设计模式（例如JDBC）\",\"策略模式\",\"IoC主要的实现策略：依赖查找、依赖注入。\"]},\"907\":{\"h\":\"IoC容器的职责\",\"t\":[\"依赖处理 \",\"依赖查找\",\"依赖注入\",\"生命周期管理 \",\"容器\",\"托管的资源（Java Beans或其他资源）\",\"配置 \",\"容器\",\"外部化配置\",\"托管的资源（Java Beans或其他资源）\"]},\"908\":{\"h\":\"IoC的实现\",\"t\":[\"Java SE \",\"Java Beans\",\"Java ServiceLoader SPI\",\"JNDI（Java Naming and Directory Interface）\",\"Java EE \",\"EJB（Enterprise Java Beans）\",\"Servlet\",\"开源 \",\"Apache Avalon\",\"PicoContainer\",\"Google Guice\",\"Spring Framework\"]},\"909\":{\"h\":\"传统IoC容器的实现\",\"t\":[\"Java Beans 作为IoC容器的特性：\",\"依赖查找\",\"生命周期管理\",\"配置元信息\",\"事件\",\"自定义\",\"资源管理\",\"持久化\",\"什么是Java Beans呢？\",\"/** * 描述人的POJO类 */ public class Person { String name; Integer age; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } \",\"我们可以打印这个Bean的元信息：\",\"public class BeanInfoDemo { public static void main(String[] args) throws Exception { BeanInfo beanInfo = Introspector.getBeanInfo(Person.class, Object.class); Stream.of(beanInfo.getPropertyDescriptors()).forEach(System.out::println); } } \",\"打印结果：\",\"java.beans.PropertyDescriptor[name=age; propertyType=class java.lang.Integer; readMethod=public java.lang.Integer beans.Person.getAge(); writeMethod=public void beans.Person.setAge(java.lang.Integer)] java.beans.PropertyDescriptor[name=name; propertyType=class java.lang.String; readMethod=public java.lang.String beans.Person.getName(); writeMethod=public void beans.Person.setName(java.lang.String)] \"]},\"910\":{\"h\":\"如何界定IoC容器是轻量级的？\",\"t\":[\"以下观点出自于《J2EE Development without EJB》\",\"管理应用代码\",\"能够快速启动\",\"容器不需要一些特殊的配置来进行操作（主要是针对于EJB）\",\"容器的内存占用小以及最小化API的一个依赖\",\"容器需要一些可以管控的一个渠道，这个渠道能够帮助我们去部署和管理一些细粒度的对象，甚至是一些粗粒度的组件\"]},\"911\":{\"h\":\"依赖查找和依赖注入\",\"t\":[\"类型\",\"依赖处理\",\"实现便利性\",\"代码入侵性\",\"API依赖性\",\"可读性\",\"依赖查找\",\"主动获取\",\"相对繁琐\",\"侵入业务逻辑\",\"依赖容器API\",\"良好\",\"依赖注入\",\"被动提供\",\"相对便利\",\"低入侵性\",\"不主动依赖容器API\",\"一般\"]},\"912\":{\"h\":\"构造器注入和Setter注入\",\"t\":[\"Spring官方推荐使用构造器注入，这样可以确保在注入时，对象不为空，但是参数过多时会影响代码的整洁性，可能需要考虑重构。\",\"Setter注入应该主要仅用于我们的可选性的注入，因为Setter的字段本身是可以为空的。\",\"而《J2EE Development without EJB》认为应该使用Setter注入，原因在于：\",\"JavaBean属性能够获取更好的IDE支持\",\"JavaBean属性通常是一个自文档的说明\",\"在类型转换上有优势\",\"大量的JavaBeans可能不经过任何修改就可以在JavaBean容器当中使用\",\"当然，Setter注入也有缺点，就是无法确定属性初始化的顺序。\"]},\"913\":{\"h\":\"面试题\"},\"914\":{\"h\":\"什么是IoC？\",\"t\":[\"简单地说，IoC是反转控制，类似于好莱坞原则，主要有依赖查找和依赖注入两种实现。按照IoC的定义，很多方面其实都是IoC，比如JavaBeans是IoC的一个容器实现，Servlet的容器也是IoC的实现，因为Servlet可以去依赖或者反向地通过JNDI的方式进行得到一些外部的一些资源，包括DataSource或者相关的EJB的组件，于此同时SpringFramework或者Peak Container的依赖注入的框架，也能帮助我们去实现IoC，除此之外，消息也可以看作是IoC的一种实现。\"]},\"915\":{\"h\":\"依赖查找和依赖注入的区别？\",\"t\":[\"依赖查找是主动或手动的依赖查找方式，通常需要依赖容器或标准API实现。而依赖注入则是手动或自动依赖绑定的方式，无需依赖特定的容器和API。\"]},\"916\":{\"h\":\"Spring作为IoC容器有什么优势？\",\"t\":[\"典型的IoC管理，依赖查找和依赖注入，AOP抽象，事务抽象，事件机制，SPI扩展，强大的第三方整合，易测试性，更好的面向对象。\"]},\"917\":{\"h\":\"Spring IoC依赖查找\",\"t\":[\"根据Bean名称查找 \",\"实时查找\",\"延迟查找\",\"根据Bean类型查找 \",\"单个Bean对象\",\"集合Bean对象\",\"根据Bean名称+类型查找\",\"根据Java注解查找\",\"新建一个用户类：\",\"/** * 用户类 */ public class User { private String id; private String name; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \\\"User{\\\" + \\\"id='\\\" + id + '\\\\'' + \\\", name='\\\" + name + '\\\\'' + '}'; } } \",\"新建一个超级用户类：\",\"/** * 超级用户 */ @Super public class SuperUser extends User{ private String address; public String getAddress() { return address; } @Override public String toString() { return \\\"SuperUser{\\\" + \\\"address='\\\" + address + '\\\\'' + \\\"} \\\" + super.toString(); } public void setAddress(String address) { this.address = address; } } \",\"新建一个注解：\",\"/** * 超级 */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Super { } \",\"向容器中注入一些Bean：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"user\\\" class=\\\"org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User\\\"> <property name=\\\"id\\\" value=\\\"1\\\"/> <property name=\\\"name\\\" value=\\\"吉永超\\\" /> </bean> <bean id=\\\"SuperUser\\\" class=\\\"org.jyc.thinking.in.spring.ioc.overview.dependency.domain.SuperUser\\\" parent=\\\"user\\\" primary=\\\"true\\\"> <property name=\\\"address\\\" value=\\\"深圳\\\" /> </bean> <bean id=\\\"objectFactory\\\" class=\\\"org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean\\\"> <property name=\\\"targetBeanName\\\" value=\\\"user\\\"></property> </bean> </beans> \",\"依赖查找的示例：\",\"public class DependencyLookupDemo { public static void main(String[] args) { // 配置XML文件 // 启动Spring应用上下文 BeanFactory beanFactory = new ClassPathXmlApplicationContext(\\\"META-INF/dependency-lookup-context.xml\\\"); // 实时查找 lookupInRealTime(beanFactory); // 延迟查找 lookupInLazy(beanFactory); // 按照类型查找 lookupByType(beanFactory); // 按照类型查找集合对象 lookupCollectionType(beanFactory); // 通过注解查找 lookupByAnnotationType(beanFactory); } /** * 通过注解查找 * @param beanFactory */ private static void lookupByAnnotationType(BeanFactory beanFactory) { if (beanFactory instanceof ListableBeanFactory) { ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory; Map<String, User> users = (Map)listableBeanFactory.getBeansWithAnnotation(Super.class); System.out.println(\\\"查找到的所有标注@Super的User集合对象：\\\" + users); } } /** * 按照类型查找集合对象 * @param beanFactory */ private static void lookupCollectionType(BeanFactory beanFactory) { if (beanFactory instanceof ListableBeanFactory) { ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory; Map<String, User> users = listableBeanFactory.getBeansOfType(User.class); System.out.println(\\\"查找到的所有的User集合对象：\\\" + users); } } /** * 按照类型查找 * @param beanFactory */ private static void lookupByType(BeanFactory beanFactory) { User user = beanFactory.getBean(User.class); System.out.println(\\\"按照类型查找 \\\" + user); } /** * 延迟查找 * * @param beanFactory */ private static void lookupInLazy(BeanFactory beanFactory) { ObjectFactory<User> objectFactory = (ObjectFactory<User>) beanFactory.getBean(\\\"objectFactory\\\"); User user = objectFactory.getObject(); System.out.println(\\\"延迟查找 \\\" + user); } /** * 实时查找 * * @param beanFactory */ private static void lookupInRealTime(BeanFactory beanFactory) { User user = (User) beanFactory.getBean(\\\"user\\\"); System.out.println(\\\"实时查找\\\" + user); } } \"]},\"918\":{\"h\":\"Spring IoC依赖注入\",\"t\":[\"根据Bean名称注入\",\"根据Bean类型注入 \",\"单个Bean对象\",\"集合Bean对象\",\"注入容器内建的Bean对象\",\"注入非Bean对象\",\"注入类型 \",\"实时注入\",\"延迟注入\",\"/** * 用户信息仓库 */ public class UserRespository { private Collection<User> users; // 自定义Bean private BeanFactory beanFactory; //内建的非Bean对象（对象） private ObjectFactory<ApplicationContext> objectFactory; public Collection<User> getUsers() { return users; } public void setUsers(Collection<User> users) { this.users = users; } public void setBeanFactory(BeanFactory beanFactory) { this.beanFactory = beanFactory; } public ObjectFactory<ApplicationContext> getObjectFactory() { return objectFactory; } public void setObjectFactory(ObjectFactory<ApplicationContext> objectFactory) { this.objectFactory = objectFactory; } public BeanFactory getBeanFactory() { return beanFactory; } } \",\"定义一个类似的资源：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:util=\\\"http://www.springframework.org/schema/util\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <!-- 通过导入复用 --> <import resource=\\\"dependency-lookup-context.xml\\\" /> <!-- Auto-wiring --> <bean id=\\\"userRespository\\\" class=\\\"org.jyc.thinking.in.spring.ioc.overview.dependency.repository.UserRespository\\\" autowire=\\\"byType\\\"> <!-- 手动配置 --> <!-- <property name=\\\"users\\\">--> <!-- <util:list>--> <!-- <ref bean=\\\"user\\\"></ref>--> <!-- <ref bean=\\\"SuperUser\\\"></ref>--> <!-- </util:list>--> <!-- </property>--> </bean> </beans> \",\"测试：\",\"public class DependencyInjectionDemo { public static void main(String[] args) { // 配置XML文件 // 启动Spring应用上下文 BeanFactory beanFactory = new ClassPathXmlApplicationContext(\\\"META-INF/dependency-injection-context.xml\\\"); UserRespository userRespository = beanFactory.getBean(\\\"userRespository\\\", UserRespository.class); // System.out.println(userRespository.getUsers()); System.out.println(userRespository.getBeanFactory()); // System.out.println(userRespository.getBeanFactory() == beanFactory); ObjectFactory<ApplicationContext> userFactory = userRespository.getObjectFactory(); System.out.println(userFactory.getObject() == beanFactory); } } \",\"对比结果可以发现依赖查找和依赖注入的来源并不一样。\"]},\"919\":{\"h\":\"Spring依赖注入和依赖查找的来源\",\"t\":[\"自定义Bean\",\"容器内建Bean对象\",\"容器内建依赖\",\"public class DependencyInjectionDemo { public static void main(String[] args) { // 配置XML文件 // 启动Spring应用上下文 BeanFactory beanFactory = new ClassPathXmlApplicationContext(\\\"META-INF/dependency-injection-context.xml\\\"); // 自定义的Bean UserRespository userRespository = beanFactory.getBean(\\\"userRespository\\\", UserRespository.class); // 依赖注入（内建依赖） System.out.println(userRespository.getBeanFactory()); // 容器内建Bean对象 Environment environment = beanFactory.getBean(Environment.class); System.out.println(\\\"获取Enviroment类型的Bean\\\" + environment); } } \"]},\"920\":{\"h\":\"Spring IoC配置元信息\",\"t\":[\"Bean定义配置 \",\"基于XML文件\",\"基于Properties文件\",\"基于Java注解\",\"基于Java API（专题讨论）\",\"IoC容器配置 \",\"基于XML文件\",\"基于Java注解\",\"基于Java API（专题讨论）\",\"外部化属性配置 \",\"基于Java注解\"]},\"921\":{\"h\":\"BeanFactory和ApplicationContext\",\"t\":[\"BeanFactory和ApplicationContext谁才是Spring IoC容器？\",\"BeanFactory是一个具有基本功能的框架，而ApplicationContext添加了更多企业级的特性，总而言之，ApplicationContext是BeanFactory的超集，并且在实现上，ApplicationContext虽然继承了BeanFactory接口，但内部的BeanFactory是采用组合的方式进行的实现，默认的实现类为DefaultListableBeanFactory。\",\"ApplicationContext除了IoC容器角色，还有提供：\",\"面向切面（AOP）\",\"配置元信息（Configuration Metadata）\",\"资源管理（Resources）\",\"事件（Events）\",\"国际化（i18n）\",\"注解（Annotations）\",\"Environment抽象（Environment Abstraction）\",\"BeanFactory的IoC容器的使用：\",\"/** * BeanFactory作为IoC容器示例 */ public class BeanFactoryAsIoCContainerDemo { public static void main(String[] args) { // 创建BeanFactory容器 DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); // 加载配置 XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory); // XML配置文件ClassPath路径 String location = \\\"classpath:/META-INF/dependency-lookup-context.xml\\\"; // 加载配置 int beanDefinitions = reader.loadBeanDefinitions(location); System.out.println(\\\"Bean定义加载的数量: \\\" + beanDefinitions); // 依赖查找集合对象.... lookupCollectionType(beanFactory); } /** * 按照类型查找集合对象 * @param beanFactory */ private static void lookupCollectionType(BeanFactory beanFactory) { if (beanFactory instanceof ListableBeanFactory) { ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory; Map<String, User> users = listableBeanFactory.getBeansOfType(User.class); System.out.println(\\\"查找到的所有的User集合对象：\\\" + users); } } } \",\"Application的IoC容器使用：\",\"/** * ApplicationA作为IoC容器示例 */ public class AnnotationApplicationAsIoCContainerDemo { public static void main(String[] args) { // 创建BeanFactory容器 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(AnnotationApplicationAsIoCContainerDemo.class); applicationContext.refresh(); // 依赖查找集合对象.... lookupCollectionType(applicationContext); } @Bean public User user() { User user = new User(); user.setId(\\\"1\\\"); user.setName(\\\"吉永超\\\"); return user; } /** * 按照类型查找集合对象 * @param beanFactory */ private static void lookupCollectionType(BeanFactory beanFactory) { if (beanFactory instanceof ListableBeanFactory) { ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory; Map<String, User> users = listableBeanFactory.getBeansOfType(User.class); System.out.println(\\\"查找到的所有的User集合对象：\\\" + users); } } } \",\"可以看到，使用BeanFactory和ApplicationContext都可以完成依赖查找的功能。\"]},\"922\":{\"h\":\"Spring IoC容器生命周期\",\"t\":[\" public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { StartupStep contextRefresh = this.applicationStartup.start(\\\"spring.context.refresh\\\"); // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); StartupStep beanPostProcess = this.applicationStartup.start(\\\"spring.context.beans.post-process\\\"); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); beanPostProcess.end(); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\\\"Exception encountered during context initialization - \\\" + \\\"cancelling refresh attempt: \\\" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); contextRefresh.end(); } } } \"]},\"923\":{\"h\":\"面试题\"},\"924\":{\"h\":\"什么是Spring IoC容器\",\"t\":[\"Spring Framework是IoC（控制反转）的一种具体的实现，主要包括了DI（dependency injection），和DL（dependency lookup）。\"]},\"925\":{\"h\":\"BeanFactory和FactoryBean\",\"t\":[\"BeanFactory是IoC底层容器，FactoryBean是创建Bean的一种方式，帮助实现复杂的初始化逻辑。\"]},\"926\":{\"h\":\"Spring IoC容器启动时做了哪些准备？\",\"t\":[\"IoC配置元信息读取和解析、IoC容器生命周期、Spring事件发布、国际化等。\"]},\"927\":{\"h\":\"BeanDefinition\",\"t\":[\"BeanDefinition时Spring Framework中定义Bean配置元信息接口，包含：\",\"Bean的类名（必须是全限定类名）\",\"Bean行为配置元素，如作用域、自动绑定的模式、生命周期回调等\",\"其他Bean引用，又可称合作者（collaborators）或者依赖（dependencies）\",\"配置设置，比如Bean属性（Properties）\",\"BeanDefinition元信息\",\"属性（Property）\",\"说明\",\"Class\",\"Bean全类名，必须是具体类，不能用抽象类或接口\",\"Name\",\"Bean的名称或者ID\",\"Scope\",\"Bean的作用域（如：singleton、prototype等）\",\"Constructor arguments\",\"Bean构造器参数（用于依赖注入）\",\"Properties\",\"Bean属性设置（用于依赖注入）\",\"Autowiring mode\",\"Bean自动绑定模式（如：通过名称byName）\",\"Lazy initialization mode\",\"Bean延迟初始化模式（延迟和非延迟）\",\"Initialization method\",\"Bean初始化回调方法名称\",\"Destruction method\",\"Bean销毁回调方法名称\",\"BeanDefinition的构建方式\",\"通过BeanDefinitionBuilder\",\"通过AbstactBeanDefinition以及派生类\",\"/** * BeanDefinition构建示例 */ public class BeanDefinitionCreationDemo { public static void main(String[] args) { // 1.通过BeanDefinitionBuilder BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class); // 通过属性设置 beanDefinitionBuilder.addPropertyValue(\\\"name\\\",\\\"jyc\\\"); beanDefinitionBuilder.addPropertyValue(\\\"age\\\",\\\"1\\\"); // 获取BeanDefinition实例 AbstractBeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition(); // BeanDefinition并非Bean的终态，可以自定义修改 // 2.通过AbstactBeanDefinition以及派生类 GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition(); // 设置Bean类型 genericBeanDefinition.setBeanClass(User.class); // 通过MutablePropertyValues批量操作属性 MutablePropertyValues propertyValues = new MutablePropertyValues(); propertyValues.addPropertyValue(\\\"id\\\",\\\"1\\\"); propertyValues.addPropertyValue(\\\"name\\\",\\\"jyc\\\"); genericBeanDefinition.setPropertyValues(propertyValues); } } \"]},\"928\":{\"h\":\"Spring Bean命名\",\"t\":[\"什么是Bean的名称？\",\"每个Bean拥有一个或多个标识符（identifiers），这些标识符在Bean所在的容器必须是唯一的。通常，一个Bean仅有一个标识符，如果需要额外的，可考虑使用别名（Alias）来扩充。\",\"在基于XML的配置元信息中，开发人员可用id或者name属性来规定Bean的标识符。通常Bean的标识符由字母组成，允许出现特殊字符，如果要想映入新的Bean的别名的话，可在name属性使用半角逗号（“,”）或分号（“;”）来间隔。\",\"Bean的id或name属性并非必须制定，如果留空的话，容器回味Bean自动生成一个唯一的名称。Bean的名称尽管没有限制，不过官方建议采用驼峰的方式，更符合Java的命名约定。\",\"Bean名称生成器（BeanNameGenerator）主要有两种实现：\",\"DefaultBeanNameGenerator（默认通用BeanNameGenerator实现）\",\"AnnotationBeanNameGenerator\",\"默认实现的核心代码：\",\" public static String generateBeanName( BeanDefinition definition, BeanDefinitionRegistry registry, boolean isInnerBean) throws BeanDefinitionStoreException { String generatedBeanName = definition.getBeanClassName(); if (generatedBeanName == null) { if (definition.getParentName() != null) { generatedBeanName = definition.getParentName() + \\\"$child\\\"; } else if (definition.getFactoryBeanName() != null) { generatedBeanName = definition.getFactoryBeanName() + \\\"$created\\\"; } } if (!StringUtils.hasText(generatedBeanName)) { throw new BeanDefinitionStoreException(\\\"Unnamed bean definition specifies neither \\\" + \\\"'class' nor 'parent' nor 'factory-bean' - can't generate bean name\\\"); } if (isInnerBean) { // Inner bean: generate identity hashcode suffix. return generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(definition); } // Top-level bean: use plain class name with unique suffix if necessary. return uniqueBeanName(generatedBeanName, registry); } \",\"如果是简单场景的Bean的名称：\",\" public static String uniqueBeanName(String beanName, BeanDefinitionRegistry registry) { String id = beanName; int counter = -1; // Increase counter until the id is unique. String prefix = beanName + GENERATED_BEAN_NAME_SEPARATOR; while (counter == -1 || registry.containsBeanDefinition(id)) { counter++; id = prefix + counter; } return id; } \",\"注解实现的核心源代码：\",\"@Override public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) { if (definition instanceof AnnotatedBeanDefinition) { String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition); if (StringUtils.hasText(beanName)) { // Explicit bean name found. return beanName; } } // Fallback: generate a unique default bean name. return buildDefaultBeanName(definition, registry); } \",\"如果是一个普通的Bean就会调用Java Beans的API：\",\" protected String buildDefaultBeanName(BeanDefinition definition) { String beanClassName = definition.getBeanClassName(); Assert.state(beanClassName != null, \\\"No bean class name set\\\"); String shortClassName = ClassUtils.getShortName(beanClassName); return Introspector.decapitalize(shortClassName); } \",\"Bean别名（Alias）的价值：\",\"复用现有的BeanDefinition\",\"更具有场景化的命名方法，比如：\",\"<alias name=\\\"myApp-dataSource\\\" alias=\\\"subsystemA-datasource\\\" /> <alias name=\\\"myApp-dataSource\\\" alias=\\\"subsystemB-datasource\\\" /> \"]},\"929\":{\"h\":\"BeanDefinition注册到IoC容器\",\"t\":[\"BeanDefinition注册的不同方式：\",\"XML配置元信息 \",\"<bean name =\\\"...\\\" ... />\",\"Java注解配置元信息 \",\"@Bean\",\"@Component\",\"@import\",\"Java API配置元信息 \",\"命名方式：BeanDefinitionRegistry#registerBeanDefinition（String，BeanDefinition）\",\"非命名方式：BeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition，BeanDefinitionRegistry)\",\"配置类方式：AnnotatedBeanDefinitionReader#register（Class）\",\"通过Java注解配置元信息：\",\"/** * 注解BeanDefinition示例 */ @Import(AnnotationBeanDefinitionDemo.Config.class) // 3.通过@Import方式导入 public class AnnotationBeanDefinitionDemo { public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); // 注册配置类（configuration class） applicationContext.register(AnnotationBeanDefinitionDemo.class); applicationContext.refresh(); System.out.println(\\\"Config类型的所有的Beans\\\" + applicationContext.getBeansOfType(Config.class)); System.out.println(\\\"user类型的所有的Beans\\\" + applicationContext.getBeansOfType(User.class)); applicationContext.close(); } // 2.通过Component方式 @Component //定义当前类作为Spring Bean（组件） public static class Config { // 1.通过@Bean方式定义 @Bean({\\\"user\\\", \\\"jyc\\\"}) public User user() { User user = new User(); user.setId(\\\"1\\\"); user.setName(\\\"吉永超\\\"); return user; } } } \",\"Java API配置元信息：\",\"/** * 命名Bean的注册方式 * @param registry * @param beanName */ public static void registerUserBeanDefinition(BeanDefinitionRegistry registry, String beanName) { BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class); beanDefinitionBuilder.addPropertyValue(\\\"id\\\", \\\"1\\\").addPropertyValue(\\\"name\\\", \\\"jiyongchao\\\"); // 判断如果beanName参数存在时 if (StringUtils.hasText(beanName)) { registry.registerBeanDefinition(beanName, beanDefinitionBuilder.getBeanDefinition()); } else { // 非命名的Bean注册方法 BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinitionBuilder.getBeanDefinition(), registry); } } \"]},\"930\":{\"h\":\"实例化Bean的方式\",\"t\":[\"Bean实例化：\",\"常规方式\",\"通过构造器（配置元信息：XML、Java注解和Java API）\",\"通过静态工厂方法（配置元信息：XML和Java API）\",\"通过Bean工厂方法（配置元信息：XML和Java API）\",\"通过FactoryBean（配置元信息：XML、Java注解和Java API）\",\"特殊方式\",\"通过ServiceLoaderFactoryBean（配置元信息：XML、Java注解和Java API）\",\"通过AutowireCapableBeanFactory#createBean（java.lang.Class，int，boolean）\",\"通过BeanDefinitionResgistry#registerBeanDefinition（String，BeanDefinition）\",\"常规方式实例化的示例：\",\"<beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <!-- 静态方法实例化Bean --> <bean id=\\\"user-by-static-method\\\" class=\\\"org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User\\\" factory-method=\\\"createUser\\\" /> <!-- 实例方法实例化Bean --> <bean id=\\\"user-by-instance-method\\\" factory-bean=\\\"userFactory\\\" factory-method=\\\"createUser\\\"/> <!-- Bean工厂实例化Bean --> <bean id=\\\"userFactory\\\" class=\\\"org.jyc.thinking.in.spring.bean.definition.factory.DefaultUserFactory\\\" /> <!-- FactoryBean实例化Bean --> <bean id=\\\"user-by-factory-bean\\\" class=\\\"org.jyc.thinking.in.spring.bean.definition.factory.UserFactoryBean\\\"/> </beans> \",\"其中UserFactoryBean为：\",\"/** * User Bean的FactoryBean的实现 */ public class UserFactoryBean implements FactoryBean { @Override public Object getObject() throws Exception { return new User(); } @Override public Class<?> getObjectType() { return null; } } \",\"测试输出：\",\"/** * Bean实例化示例 */ public class BeanInstantiationDemo { public static void main(String[] args) { BeanFactory beanFactory = new ClassPathXmlApplicationContext(\\\"classpath:/META-INF/bean-instantiation-context.xml\\\"); User user = beanFactory.getBean(\\\"user-by-static-method\\\", User.class); User userByInstanceMethod = beanFactory.getBean(\\\"user-by-instance-method\\\", User.class); User userByFactoryBean = beanFactory.getBean(\\\"user-by-instance-method\\\", User.class); System.out.println(user); System.out.println(userByInstanceMethod); System.out.println(userByFactoryBean); System.out.println(user == userByInstanceMethod); System.out.println(user == userByFactoryBean); } } \",\"特殊方式的示例：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"userFactoryServiceLoader\\\" class=\\\"org.springframework.beans.factory.serviceloader.ServiceLoaderFactoryBean\\\" > <property name=\\\"serviceType\\\" value=\\\"org.jyc.thinking.in.spring.bean.definition.factory.UserFactory\\\" /> </bean> </beans> \",\"测试输出：\",\"public class SpecialBeanInstantiationDemo { public static void main(String[] args) { BeanFactory beanFactory = new ClassPathXmlApplicationContext(\\\"classpath:/META-INF/special-bean-instantiation-context.xml\\\"); ServiceLoader serviceLoader = beanFactory.getBean(\\\"userFactoryServiceLoader\\\", ServiceLoader.class); displayServiceLoader(serviceLoader); demoServiceLoader(); } public static void demoServiceLoader() { ServiceLoader<UserFactory> serviceLoader = ServiceLoader.load(UserFactory.class, Thread.currentThread().getContextClassLoader()); displayServiceLoader(serviceLoader); } private static void displayServiceLoader(ServiceLoader<UserFactory> serviceLoader) { Iterator<UserFactory> iterator = serviceLoader.iterator(); while (iterator.hasNext()) { UserFactory userFactory = iterator.next(); System.out.println(userFactory.createUser()); } } } \",\"通过AutowireCapableBeanFactory实例化：\",\" public static void main(String[] args) { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\\\"classpath:/META-INF/special-bean-instantiation-context.xml\\\"); // 通过ApplicationContext获取AutowireCapableBeanFactory AutowireCapableBeanFactory beanFactory = applicationContext.getAutowireCapableBeanFactory(); // 通过AutowireCapableBeanFactory创建UserFactory对象 UserFactory userFactory = beanFactory.createBean(DefaultUserFactory.class); System.out.println(userFactory.createUser()); } \"]},\"931\":{\"h\":\"初始化Bean的方式\",\"t\":[\"Bean的初始化（Initialization）：\",\"@PostConstruct标注方法\",\"实现InitializingBean接口的afterPropertiesSet()方法\",\"自定义初始化方法 \",\"XML配置：<bean init-method=\\\"init\\\" ... />\",\"Java注解：@Bean(initMethod=\\\"init\\\")\",\"Java API：AbstractBeanDefinition#setInitMethodName(String)\",\"初始化的示例：\",\"public class DefaultUserFactory implements UserFactory, InitializingBean { // 1.基于@PostConstruct注解 @PostConstruct public void init() { System.out.println(\\\"@PostConstruct: UserFactory 初始化中....\\\"); } @Override public void afterPropertiesSet() throws Exception { System.out.println(\\\"afterPropertiesSet: UserFactory 初始化中....\\\"); } public void initUserFactory() { System.out.println(\\\"自定义初始化方法： initUserFactory： UserFactory 初始化中....\\\"); } } \",\"调用的结果：\",\"@Configuration public class BeanInitializationDemo { public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(BeanInitializationDemo.class); applicationContext.refresh(); UserFactory userFactory = applicationContext.getBean(UserFactory.class); applicationContext.close(); } @Bean(initMethod = \\\"initUserFactory\\\") public UserFactory userFactory() { return new DefaultUserFactory(); } } \",\"最终实际上都会调用的AbstractBeanDefinition的setInitMethodName\",\" public void setInitMethodName(@Nullable String initMethodName) { this.initMethodName = initMethodName; } \",\"三者的执行顺序：\",\"@PostConstruct: UserFactory 初始化中.... afterPropertiesSet: UserFactory 初始化中.... 自定义初始化方法： initUserFactory： UserFactory 初始化中.... \"]},\"932\":{\"h\":\"延迟初始化Bean\",\"t\":[\"Bean延迟初始化（Lazy Initialization）\",\"XML配置：<bean lazy-init=\\\"true\\\" .../>\",\"Java注解：@Lazy(true)\",\"Spring容器返回的对象和非延迟的对象存在怎样的差异？\",\"非延迟初始化在Spring应用上下文启动完成后，被初始化。而延迟初始化是在依赖查找和依赖注入的时候才会进行初始化。\"]},\"933\":{\"h\":\"销毁Bean\",\"t\":[\"Bean销毁（Destroy）\",\"@PreDestory标注方法\",\"实现DisposableBean接口的destory()方法\",\"自定义销毁方法 \",\"XML配置：<bean destory=\\\"destory\\\" .../>\",\"Java注解：@Bean(destory=\\\"destory\\\")\",\"Java API: AbstractBeanDefinition#setDestoryMethodName(String)\",\"销毁的示例：\",\"public class DefaultUserFactory implements UserFactory, DisposableBean { @PreDestroy public void preDestory() { System.out.println(\\\"@PreDestroy: UserFactory 销毁中....\\\"); } @Override public void destroy() throws Exception { System.out.println(\\\"DisposableBean#destroy: UserFactory 销毁中....\\\"); } public void doDestory() { System.out.println(\\\"自定义销毁方法：doDestory()： UserFactory 销毁中....\\\"); } } \",\"调用的结果：\",\"public class BeanDestoryDemo { public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(BeanDestoryDemo.class); applicationContext.refresh(); // 非延迟初始化在Spring应用上下文启动完成后，被初始化。 System.out.println(\\\"应用上下文已启动...\\\"); UserFactory userFactory = applicationContext.getBean(UserFactory.class); System.out.println(userFactory); System.out.println(\\\"应用上下文准备关闭...\\\"); applicationContext.close(); System.out.println(\\\"应用上下文已关闭...\\\"); } @Bean(destroyMethod = \\\"doDestory\\\") public UserFactory userFactory() { return new DefaultUserFactory(); } } \",\"通过不同时机的打印，可以观察到Bean的销毁的时机就是在应用上下文关闭的时候。\",\"三者不同方式的执行结果：\",\"应用上下文已启动... 应用上下文准备关闭... @PreDestroy: UserFactory 销毁中.... DisposableBean#destroy: UserFactory 销毁中.... 自定义销毁方法：doDestory()： UserFactory 销毁中.... 应用上下文已关闭... \"]},\"934\":{\"h\":\"垃圾回收Spring Bean\",\"t\":[\"Bean垃圾回收（GC）\",\"关闭Spring容器（应用上下文）\",\"执行GC\",\"Spring Bean覆盖的finalize()方法被回调\",\"/** * Bena垃圾回收的示例 */ public class BeanGarbageCollectionDemo { public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(BeanInitializationDemo.class); applicationContext.refresh(); applicationContext.close(); System.out.println(\\\"Spring 应用上下文已关闭\\\"); // 强制触发GC System.gc(); } } \",\"这里我们重写了DefaultUserFactory中的finalize()方法：\",\" @Override protected void finalize() throws Throwable { System.out.println(\\\"当前DefaultUserFactory 对象正在被垃圾回收\\\"); } \"]},\"935\":{\"h\":\"面试题\"},\"936\":{\"h\":\"如何注册一个Spring Bean？\",\"t\":[\"通过BeanDefinition和外部单体对象来注册。\",\"/** * 单体Bean注册示例 */ public class SingletonBeanRegistrationDemo { public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); // 注册外部单例对象 UserFactory userFactory = new DefaultUserFactory(); // 创建一个外部UserFactory对象 ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory(); // 注册外部单例对象 beanFactory.registerSingleton(\\\"userFactory\\\", userFactory); applicationContext.refresh(); UserFactory userFactoryByLookup = beanFactory.getBean(\\\"userFactory\\\", UserFactory.class); System.out.println(\\\"userFactory == userFactoryByLookup: \\\" + (userFactory == userFactoryByLookup)); applicationContext.close(); } } \"]},\"937\":{\"h\":\"什么是Spring BeanDefinition？\",\"t\":[\"BeanDefinition是关于Bean定义的元信息的接口，允许我们通过getter、setter方法方式来进行存储信息。\"]},\"938\":{\"h\":\"Spring容器是怎样管理注册Bean\",\"t\":[\"如IoC配置元信息读取和解析、依赖查找和注入以及Bean生命周期等。\"]},\"939\":{\"h\":\"依赖查找简介\",\"t\":[\"单一类型依赖查找 \",\"JNDI - javax.naming.Context#lookup(javax.naming.Name)\",\"JavaBeans - java.beans.beancontext.BeanContext\",\"集合类型依赖查找 \",\"java.beans.beancontext.BeanContext\",\"层次性依赖查找 \",\"java.beans.beancontext.BeanContext\"]},\"940\":{\"h\":\"单一类型依赖查找\",\"t\":[\"单一类型依赖查找接口-BeanFactory\",\"根据Bean名称查找 \",\"getBean(String)\",\"Spring 2.5 覆盖默认参数：getBean(String,Object...)\",\"根据Bean类型查找 \",\"Bean实时查找 \",\"Spring 3.0 getBean(Class)\",\"Spring 4.1 覆盖默认参数：getBean(Class,Object...)\",\"Spring 5.1 Bean延迟查找 \",\"getBeanProvider(Class)\",\"getBeanProvider(ResolvableType)\",\"根据Bean名称 + 类型查找：getBean(String,Class)\",\"利用ObejctProvider进行依赖查找：\",\"/** * 通过ObjectProvider进行依赖查找 */ public class ObejctProviderDemo { // @Configuration是非必须的注解 public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(ObejctProviderDemo.class); applicationContext.refresh(); lookupByObejctProvider(applicationContext); applicationContext.close(); } @Bean public String helloworld() { // 方法名就是Bean名称 = “helloworld” return \\\"helloworld\\\"; } private static void lookupByObejctProvider(AnnotationConfigApplicationContext applicationContext) { ObjectProvider<String> beanProvider = applicationContext.getBeanProvider(String.class); System.out.println(beanProvider.getObject()); } } \"]},\"941\":{\"h\":\"集合类型依赖查找\",\"t\":[\"集合类型依赖查找接口-ListableBeanFactory\",\"根据Bean类型查找 \",\"根据同类型Bean名称列表 \",\"getBeanNamesForType（Class）\",\"Spring 4.2 getBeanNamesForType（ResolvableType）\",\"获取同类型Bean实例列表 \",\"getBeanOfType（Class）以及重载方法\",\"通过注解类型查找 \",\"Spring 3.0 获取标注类型Bean名称列表 \",\"getBeanNamesForAnnotation（Class<? extends Annotation>）\",\"Spring 3.0 获取标注类型Bean实例列表 \",\"getBeansWithAnnotation（Class<? extends Annotation>）\",\"Spring 3.0 获取指定名称 + 标注类型Bean 实例\",\"相关的示例实际上在之前就已经提到过了：\",\" /** * 通过注解查找 * @param beanFactory */ private static void lookupByAnnotationType(BeanFactory beanFactory) { if (beanFactory instanceof ListableBeanFactory) { ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory; Map<String, User> users = (Map)listableBeanFactory.getBeansWithAnnotation(Super.class); System.out.println(\\\"查找到的所有标注@Super的User集合对象：\\\" + users); } } /** * 按照类型查找集合对象 * @param beanFactory */ private static void lookupCollectionType(BeanFactory beanFactory) { if (beanFactory instanceof ListableBeanFactory) { ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory; Map<String, User> users = listableBeanFactory.getBeansOfType(User.class); System.out.println(\\\"查找到的所有的User集合对象：\\\" + users); } } \"]},\"942\":{\"h\":\"层次性依赖查找\",\"t\":[\"层次性依赖查找接口-HierachicalBeanFactory\",\"双亲BeanFactory：getParentBeanFacotry\",\"层次性查找： \",\"根据Bean名称查找 \",\"基于containsLocalBean方法实现\",\"根据Bean类型查找实例列表 \",\"单一类型：BeanFactoryUtils#beanOfType\",\"集合类型BeanFactoryUtils#beanOfTypeIncludingAncestors\",\"根据Java注解查找名称列表 \",\"BeanFactoryUtils#beanNamesForTypeIncludingAncestors\"]},\"943\":{\"h\":\"延迟依赖查找\",\"t\":[\"Bean延迟依赖查找接口\",\"org.springframework.beans.factory.ObjectFactory\",\"org.springframwork.beans.factory.ObjecyProvider \",\"Spring 5 对Java8特性扩展 \",\"函数式接口 \",\"getIfAvailable(Supplier)\",\"ifAvailable(Consumer)\",\"Stream扩展-stream()\",\"相关示例：\",\"public class ObejctProviderDemo { // @Configuration是非必须的注解 public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(ObejctProviderDemo.class); applicationContext.refresh(); lookupByObejctProvider(applicationContext); lookupIfAvailable(applicationContext); lookupByStreamOps(applicationContext); applicationContext.close(); } private static void lookupByStreamOps(AnnotationConfigApplicationContext applicationContext) { ObjectProvider<String> beanProvider = applicationContext.getBeanProvider(String.class); // Iterable<String> stringIterable = beanProvider; // for (String string : stringIterable) { // System.out.println(string); // } beanProvider.stream().forEach(System.out::println); } private static void lookupIfAvailable(AnnotationConfigApplicationContext applicationContext) { // User对象并不存在 ObjectProvider<User> userObjectProvider = applicationContext.getBeanProvider(User.class); User user = userObjectProvider.getIfAvailable(User::createUser); System.out.println(\\\"当前User对象: \\\" + user); } @Bean @Primary public String helloworld() { return \\\"helloworld\\\"; } @Bean public String message() { return \\\"Message\\\"; } private static void lookupByObejctProvider(AnnotationConfigApplicationContext applicationContext) { ObjectProvider<String> beanProvider = applicationContext.getBeanProvider(String.class); System.out.println(beanProvider.getObject()); } } \"]},\"944\":{\"h\":\"安全依赖查找\",\"t\":[\"安全性指的是没有查找到Bean的时候，是否会抛出异常。有关依赖查找安全性对比如下\",\"依赖查找类型\",\"代表实现\",\"是否安全\",\"单一类型查找\",\"BeanFactory#getBean\",\"否\",\"ObjectFactory#getObject\",\"否\",\"ObjectProvider#getIfAvailable\",\"是\",\"是\",\"集合类型查找\",\"ListableBeanFactory#getBeansOfType\",\"是\",\"ObjectProvider#stream\",\"是\",\"注意：层次性依赖查找的安全性取决于其扩展的单一或集合类型的BeanFactory接口。\",\"类型安全的依赖查找的相关示例：\",\"/** * 类型安全的依赖查找示例 */ public class TypeSafetyDependencyLookupDemp { public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(TypeSafetyDependencyLookupDemp.class); applicationContext.refresh(); // 演示BeanFactory#getBean方法的安全性 displayBeanFactoryGetBean(applicationContext); // 演示ObjectFactory#getObject方法的安全性 displayBeanFactoryGetObject(applicationContext); // 演示ObjectProvider#ifAvailable方法的安全性 displayObjectProviderIfAvailable(applicationContext); // 演示ListableBeanFactory#getBeansOfTYpe方法的安全性 displayListableBeanFactoryGetBeansType(applicationContext); // 演示ObjectProvider#stream方法的安全性 displayObjectProviderStreamOps(applicationContext); applicationContext.close(); } private static void displayObjectProviderStreamOps(AnnotationConfigApplicationContext applicationContext) { ObjectProvider<User> userObjectProvider = applicationContext.getBeanProvider(User.class); printBeansException(\\\"displayObjectProviderStreamOps\\\", () -> userObjectProvider.stream().forEach(System.out::println)); } private static void displayListableBeanFactoryGetBeansType(ListableBeanFactory beanFactory) { printBeansException(\\\"displayListableBeanFactoryGetBeansType\\\",() -> beanFactory.getBeanNamesForType(User.class)); } private static void displayObjectProviderIfAvailable(AnnotationConfigApplicationContext applicationContext) { ObjectProvider<User> objectProvider = applicationContext.getBeanProvider(User.class); printBeansException(\\\"displayObjectProviderIfAvailable\\\", objectProvider::getIfAvailable); } private static void displayBeanFactoryGetObject(AnnotationConfigApplicationContext applicationContext) { // ObjectProvider is ObjectFactory ObjectFactory<User> userObjectFactory = applicationContext.getBeanProvider(User.class); printBeansException(\\\"displayBeanFactoryGetObject\\\", userObjectFactory::getObject); } public static void displayBeanFactoryGetBean(BeanFactory beanFactory) { printBeansException(\\\"displayBeanFactoryGetBean\\\", () -> beanFactory.getBean(User.class)); } private static void printBeansException(String source, Runnable runnable) { System.err.println(\\\"Source from: \\\" + source); System.err.println(\\\"============================\\\"); try { runnable.run(); } catch (BeansException exception) { exception.printStackTrace(); } } } \"]},\"945\":{\"h\":\"内建可查找的依赖\",\"t\":[\"AbastractApplicationContext内建可查找的依赖：\",\"Bean名称\",\"Bena实例\",\"使用场景\",\"environment\",\"Environment对象\",\"外部化配置以及Profiles\",\"systemProperties\",\"java.util.Properties对象\",\"Java系统属性\",\"systemEnvironment\",\"java.util.Map对象\",\"操作系统环境变量\",\"messageSource\",\"MessageSource对象\",\"国际化文案\",\"lifecycleProcessor\",\"lifecycleProcessor对象\",\"Lifecycle Bean处理器\",\"applicationEventMulticaster\",\"ApplicationEventMulticaster对象\",\"Spring事件广播器\",\"注解驱动Spring应用上下文内建可查找的依赖（部分）：\",\"Bean名称\",\"Bean实例\",\"使用场景\",\"org.springframework.context.event.internalConfigurationAnnotationProcessor\",\"ConfigurationClassPostProcessor对象\",\"处理Spring配置类\",\"org.springframework.context.event.internalAutowiredAnnotationProcessor\",\"AutowiredAnnotationBeanPostProcessor对象\",\"处理@Autowired以及@Value注解\",\"org.springframework.context.event.internalCommonAnnotationProcessor\",\"CommonAnnotationBeanPostProcessor对象\",\"（条件激活）处理JSR-250注解，如@PostConstruct等\",\"org.springframework.context.event.internalEventListenerProcessor\",\"EventListenerMethodProcessor对象\",\"处理标注@EventListener的Spring事件监听方法\",\"org.springframework.context.event.internalListenerFactory\",\"DefaultEventListenerFactory对象\",\"@EventListener事件监听方法适配为ApplicationListener\",\"org.springframework.context.event.internalPersistenceAnnotationProcessor\",\"PersistenceAnnotationProcessor对象\",\"条件激活处理JPA注解场景\",\"这些内建的Bean的初始化都是在AnnotationConfigUtils中完成的。\"]},\"946\":{\"h\":\"依赖查找中典型异常\",\"t\":[\"BeansException子类型\",\"异常类型\",\"触发条件（举例）\",\"场景举例\",\"NoSuchBeanDefinitionException\",\"当查找Bean不存在于IoC容器时\",\"BeanFactory#getBeanObjectFactory#getObject\",\"NoUniqueBeanDefinitionException\",\"类型查找时，IoC容器存在多个Bean实例\",\"BeanFactory#getBean(Class)\",\"BeanInstantiationException\",\"当Bean所对应的类型非具体类时\",\"BeanFactory#getBean\",\"BeanCreationException\",\"当Bean初始化过程中\",\"Bean初始化方法执行异常时\",\"BeanDefinitionStoreException\",\"当BeanDefinition配置元信息非法时\",\"XML配置资源无法打开时\",\"NoUniqueBeanDefinitionException示例：\",\"/** * NoUniqueBeanDefinitionException示例 */ public class NoUniqueBeanDefinitionExceptionDemo { public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(NoUniqueBeanDefinitionExceptionDemo.class); applicationContext.refresh(); try { applicationContext.getBean(String.class); } catch (NoUniqueBeanDefinitionException e) { System.err.printf(\\\"Spring应用上下文存在%d 个 %s 类型的Bean,具体原因: %s%n\\\", e.getNumberOfBeansFound(), String.class.getName(), e.getMessage()); } applicationContext.close(); } @Bean public String bean1() { return \\\"bean1\\\"; } @Bean public String bean2() { return \\\"bean2\\\"; } @Bean public String bean3() { return \\\"bean3\\\"; } } \",\"BeanInstantiationException示例：\",\"/** * BeanInstantiationException示例 */ public class BeanInstantiationExceptionDemo { public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); // 注册BeanDefinition BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(CharSequence.class); // CharSequence是一个接口，所以实例化的时候会报错 applicationContext.registerBeanDefinition(\\\"errorBean\\\", beanDefinitionBuilder.getBeanDefinition()); applicationContext.refresh(); applicationContext.close(); } } \",\"BeanCreationException示例：\",\"/** * BeanCreationException示例 */ public class BeanCreationExceptionDemo { public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); // 注册BeanDefinition BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(POJO.class); applicationContext.registerBeanDefinition(\\\"errorBean\\\", beanDefinitionBuilder.getBeanDefinition()); applicationContext.refresh(); applicationContext.close(); } static class POJO implements InitializingBean { @Bean public void init() throws Throwable{ throw new Throwable(\\\"init(): For purposers...\\\"); } @Override public void afterPropertiesSet() throws Exception { throw new Exception(\\\"afterPropertiesSet(): For purposes...\\\"); } } } \"]},\"947\":{\"h\":\"面试题\"},\"948\":{\"h\":\"ObjectFactory与BeanFactory的区别\",\"t\":[\"ObjectFactory与BeanFactory均提供依赖查找的能力，不过ObjectFactory仅关注一个或一种类型的Bean依赖查找，并且自身不具备依赖查找的能力，能力由BeanFactory输出。\",\"BeanFactory则提供了单一类型、集合类型以及层次性等多种依赖查找方式。\"]},\"949\":{\"h\":\"BeanFactory.getBean操作是否线程安全？\",\"t\":[\"BeanFactory.getBean方法的执行是线程安全的，操作过程中会增加互斥锁。\"]},\"950\":{\"h\":\"Spring的依赖查找和依赖注入在来源上有什么区别？\",\"t\":[\"待定...\"]},\"951\":{\"h\":\"依赖注入的模式和类型\",\"t\":[\"手动模式-配置或者编程的方式，提前安排注入规则 \",\"XML资源配置元信息\",\"Java注解配置元信息\",\"API配置元信息\",\"自动模式-实现方提供依赖自动关联的方式，按照内建的注入规则 \",\"Autowring(自动绑定)\",\"依赖注入类型：\",\"依赖注入类型\",\"配置元数据举例\",\"Setter方法\",\"构造器\",\"字段\",\"@AutowiredUser user;\",\"方法\",\"@Autowiredpublic void user(User user) {...}\",\"接口回调\",\"class MyBean implements BeanFactoryAware{...}\"]},\"952\":{\"h\":\"自动绑定\",\"t\":[\"Autowiring modes:\",\"模式\",\"说明\",\"no\",\"默认值，未激活Autowiring，需要手动指定依赖注入对象\",\"byName\",\"根据被注入属性的名称作为Bean名称进行依赖查找，并将对象设置到该属性\",\"byType\",\"根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性\",\"constructor\",\"特殊byType类型，用于构造器参数\",\"可以参考：org.springframework.beans.factory.annotation.Autowire。\",\"public enum Autowire { /** * Constant that indicates no autowiring at all. */ NO(AutowireCapableBeanFactory.AUTOWIRE_NO), /** * Constant that indicates autowiring bean properties by name. */ BY_NAME(AutowireCapableBeanFactory.AUTOWIRE_BY_NAME), /** * Constant that indicates autowiring bean properties by type. */ BY_TYPE(AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE); private final int value; Autowire(int value) { this.value = value; } public int value() { return this.value; } /** * Return whether this represents an actual autowiring value. * @return whether actual autowiring was specified * (either BY_NAME or BY_TYPE) */ public boolean isAutowire() { return (this == BY_NAME || this == BY_TYPE); } } \",\"自动绑定的不足之处：\",\"构造器参数以及property上面的设置通常会覆盖掉Autowiring，也不能绑定一些简单的类型，比如String、Classes、properties\",\"Autowiring无法把控注入的时候的精确性，会导致一些不确定的情况发生。\",\"wiring很难在工具上产生一些文档或者相关提示。\",\"如果应用上下文中存在多个Bean的定义，会发生歧义性，可能会抛出NoUniqueBeanDefinitionException。\"]},\"953\":{\"h\":\"Setter注入\",\"t\":[\"Setter注入实现方法：\",\"手动模式： \",\"XML资源配置元信息\",\"Java注解配置元信息\",\"API配置元信息\",\"自动模式 \",\"byName\",\"byType\",\"这里我们新建一个UserHolder：\",\"/** * {@link User} 的holder类 */ public class UserHolder { public UserHolder() { } public UserHolder(User user) { this.user = user; } private User user; public User getUser() { return user; } public void setUser(User user) { this.user = user; } @Override public String toString() { return \\\"UserHolder{\\\" + \\\"user=\\\" + user + '}'; } } \",\"通过XML的方式注入：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <import resource=\\\"classpath:/META-INF/dependency-lookup-context.xml\\\" /> <bean class=\\\"org.jyc.thinking.in.spring.ioc.dependcy.injection.UserHolder\\\"> <property name=\\\"user\\\" ref=\\\"user\\\" /> </bean> </beans> \",\"通过XML的方式注入演示的示例：\",\"/** * 基于XML资源的依赖，Setter方法注入依赖 */ public class XmlDependencySetterInjectionDemo { public static void main(String[] args) { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); String xmlResourcePath = \\\"classpath:/MTEA-INF/dependency-setter-injection.xml\\\"; // 加载XML资源，解析并且生成BeanDefinition beanDefinitionReader.loadBeanDefinitions(xmlResourcePath); //依赖查找并且创建Bean UserHolder userHolder = beanFactory.getBean(UserHolder.class); System.out.println(userHolder); } } \",\"基于注解的依赖注入的演示示例：\",\"/** * 基于注解的Setter方法注入依赖 */ public class AnnotationDependencySetterInjectionDemo { public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(AnnotationDependencySetterInjectionDemo.class); applicationContext.refresh(); XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(applicationContext); String xmlResourcePath = \\\"classpath:/MTEA-INF/dependency-lookup-context.xml\\\"; beanDefinitionReader.loadBeanDefinitions(xmlResourcePath); UserHolder userHolder = applicationContext.getBean(UserHolder.class); System.out.println(userHolder); applicationContext.close(); } @Bean public UserHolder userHolder(User user) { UserHolder userHolder = new UserHolder(); userHolder.setUser(user); return userHolder; } } \",\"基于Api的依赖注入的演示：\",\"/** * 基于API的Setter方法注入依赖 */ public class ApiDependencySetterInjectionDemo { public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); BeanDefinition userBeanDefinition = createUserBeanDefinition(); // 注册UserHolder的BeanDefinition applicationContext.registerBeanDefinition(\\\"UserHolder\\\",userBeanDefinition); applicationContext.refresh(); XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(applicationContext); String xmlResourcePath = \\\"classpath:/MTEA-INF/dependency-lookup-context.xml\\\"; beanDefinitionReader.loadBeanDefinitions(xmlResourcePath); UserHolder userHolder = applicationContext.getBean(UserHolder.class); System.out.println(userHolder); applicationContext.close(); } /** * 为{@link UserHolder} 生成{@link BeanDefinition} * @return */ public static BeanDefinition createUserBeanDefinition() { BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(UserHolder.class); beanDefinitionBuilder.addPropertyReference(\\\"user\\\",\\\"SuperUser\\\"); return beanDefinitionBuilder.getBeanDefinition(); } } \",\"自动配置的主要应用场景在XML文件当中：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <import resource=\\\"classpath:/META-INF/dependency-lookup-context.xml\\\" /> <!--这里可以通过byType或者byName进行注入--> <bean class=\\\"org.jyc.thinking.in.spring.ioc.dependcy.injection.UserHolder\\\" autowire=\\\"byType\\\"> <!-- <property name=\\\"user\\\" ref=\\\"user\\\" />--> </bean> </beans> \"]},\"954\":{\"h\":\"构造器注入\",\"t\":[\"构造器注入的实现方法：\",\"手动模式 \",\"XML资源配置元信息\",\"Java注解配置元信息\",\"API配置元信息\",\"自动模式 \",\"constructor\",\"XML资源配置的方式：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <import resource=\\\"classpath:/META-INF/dependency-lookup-context.xml\\\" /> <bean class=\\\"org.jyc.thinking.in.spring.ioc.dependcy.injection.UserHolder\\\"> <constructor-arg name=\\\"user\\\" ref=\\\"SuperUser\\\" /> </bean> </beans> \",\"XML资源配置方式的示例：\",\"/** * 基于XML资源的依赖，构造器注入依赖 */ public class XmlDependencyConstructorInjectionDemo { public static void main(String[] args) { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); String xmlResourcePath = \\\"classpath:/META-INF/dependency-constructor-injection.xml\\\"; // 加载XML资源，解析并且生成BeanDefinition beanDefinitionReader.loadBeanDefinitions(xmlResourcePath); //依赖查找并且创建Bean UserHolder userHolder = beanFactory.getBean(UserHolder.class); System.out.println(userHolder); } } \",\"Java注解方式的核心部分：\",\" @Bean public UserHolder userHolder(User user) { return new UserHolder(user); } \",\"API配置元信息的方式的核心部分：\",\" /** * 为{@link UserHolder} 生成{@link BeanDefinition} * @return */ public static BeanDefinition createUserBeanDefinition() { BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(UserHolder.class); beanDefinitionBuilder.addConstructorArgReference(\\\"SuperUser\\\"); return beanDefinitionBuilder.getBeanDefinition(); } \",\"构造器自动绑定的示例：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <import resource=\\\"classpath:/META-INF/dependency-lookup-context.xml\\\" /> <bean class=\\\"org.jyc.thinking.in.spring.ioc.dependcy.injection.UserHolder\\\" autowire=\\\"constructor\\\" /> </beans> \"]},\"955\":{\"h\":\"字段注入\",\"t\":[\"实现方法：\",\"手动模式 \",\"@Autowird\",\"@Resource\",\"@inject（可选）\",\"字段注入的示例：\",\"/** * 基于注解的字段注入依赖 */ public class AnnotationDependencyFiledInjectionDemo { @Autowired private //static @Autowired会忽略掉静态字段 UserHolder userHolder; @Resource private UserHolder userHolder2; public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); // 配置Class也是 Spring Bean applicationContext.register(AnnotationDependencyFiledInjectionDemo.class); applicationContext.refresh(); XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(applicationContext); String xmlResourcePath = \\\"classpath:/META-INF/dependency-lookup-context.xml\\\"; beanDefinitionReader.loadBeanDefinitions(xmlResourcePath); AnnotationDependencyFiledInjectionDemo demo = applicationContext.getBean(AnnotationDependencyFiledInjectionDemo.class); // Autowired字段关联 UserHolder userHolder = demo.userHolder; // @Resource UserHolder userHolder2 = demo.userHolder2; System.out.println(userHolder); System.out.println(userHolder2); System.out.println(userHolder == userHolder2); applicationContext.close(); } @Bean public UserHolder userHolder(User user) { return new UserHolder(user); } } \"]},\"956\":{\"h\":\"方法注入\",\"t\":[\"手动模式 \",\"@Autowird\",\"@Resource\",\"@inject（可选）\",\"@Bean\",\"方法注入的示例：\",\" private UserHolder userHolder; private UserHolder userHolder2; @Autowired public void initUserHolder(UserHolder userHolder) { this.userHolder = userHolder; } @Resource public void initUserHolder2(UserHolder userHolder2) { this.userHolder2 = userHolder2; } @Bean public UserHolder userHolder(User user) { return new UserHolder(user); } \"]},\"957\":{\"h\":\"接口回调注入\",\"t\":[\"Aware系列接口回调\",\"自动模式\",\"内建接口\",\"说明\",\"BeanFactoryAware\",\"获取IoC容器-BeanFactory\",\"ApplicationContextAware\",\"获取Spring应用上下文-ApplicationConetxt对象\",\"EnvironmentAware\",\"获取Environment对象\",\"ResourceLoaderAware\",\"获取资源加载器对象-ResourceLoader\",\"BeanClassLoaderAware\",\"获取加载当前Bean Class的ClassLoader\",\"BeanNameAware\",\"获取当前Bean名称\",\"MessageSourceAware\",\"获取MessageSource对象，用于Spring国际化\",\"ApplicationEventPublisherAware\",\"获取ApplicationEventPublishAware对象，用于Spring事件\",\"EmbeddedValueResolverAware\",\"获取StringValueResolver对象，用占位符处理\",\"接口回调示例：\",\"/** * 基于{@link org.springframework.beans.factory.Aware} 接口回调的示例 */ public class AwareInterfaceDependencyInjectionDemo implements BeanFactoryAware, ApplicationContextAware { private static BeanFactory beanFactory; private static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { AwareInterfaceDependencyInjectionDemo.applicationContext = applicationContext; } @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException { AwareInterfaceDependencyInjectionDemo.beanFactory = beanFactory; } public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(AwareInterfaceDependencyInjectionDemo.class); context.refresh(); System.out.println(beanFactory == context.getBeanFactory()); System.out.println(applicationContext == context); context.close(); } } \"]},\"958\":{\"h\":\"依赖注入类型选择\",\"t\":[\"注入选型\",\"低依赖：构造器注入\",\"多以来：Setter方法注入\",\"便利性：字段注入\",\"声明类：方法注入\"]},\"959\":{\"h\":\"基础类型注入\",\"t\":[\"基础类型\",\"原生类型（Primitive）：boolean、byte、char、short、int、float、long、double\",\"标量类型（Scalar）：Number、Character、Boolean、Enum、Locale、Charset、Currency、Properties、UUID\",\"常规类型（General）：Object、String、TimeZone、Calendar、Optional等\",\"Spring类型：Resource、InputSource、Formatter等。\"]},\"960\":{\"h\":\"集合类型注入\",\"t\":[\"集合类型\",\"数组类型（Array）：原生类型、标量类型、常规类型、Spring类型\",\"集合类型（Collection） \",\"Collection：List、Set（SortedSet、NavigableSet、EnumSet）\",\"Map：Properties\"]},\"961\":{\"h\":\"限定注入\",\"t\":[\"使用注解@Qualifier限定 \",\"通过Bean名称限定\",\"通过分组限定\",\"基于注解@Qualifier扩展限定 \",\"自定义注解，如Spring Cloud @LoadBalanced\",\"使用注解@Qualifer限定Bean的名称的示例：\",\"/** * {@link org.springframework.beans.factory.annotation.Qualifier} 使用示例 */ public class QualifierAnnotationDependencyInjectionDemo { @Autowired // SuperUser -> primary = true private User user; @Autowired @Qualifier(\\\"user\\\") // 指定Bean名称或者ID private User namedUser; public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(QualifierAnnotationDependencyInjectionDemo.class); applicationContext.refresh(); XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(applicationContext); String xmlResourcePath = \\\"classpath:/META-INF/dependency-lookup-context.xml\\\"; beanDefinitionReader.loadBeanDefinitions(xmlResourcePath); QualifierAnnotationDependencyInjectionDemo demo = applicationContext.getBean(QualifierAnnotationDependencyInjectionDemo.class); System.out.println(\\\"demo.user = \\\" + demo.user); System.out.println(\\\"demo.namedUser = \\\" + demo.namedUser); applicationContext.close(); } } \",\"还可以使用@Qulifier对注入的Bean可以进行逻辑上的分组：\",\"/** * {@link org.springframework.beans.factory.annotation.Qualifier} 使用示例 */ public class QualifierAnnotationDependencyInjectionDemo { @Autowired // SuperUser -> primary = true private User user; @Autowired @Qualifier(\\\"user\\\") // 指定Bean名称或者ID private User namedUser; @Autowired private Collection<User> allUsers; @Autowired @Qualifier private Collection<User> qualifierUsers; @Bean @Qualifier // 进行逻辑分组 public User user1() { User user = new User(); user.setId(\\\"7\\\"); return user; } @Bean @Qualifier public User user2() { User user = new User(); user.setId(\\\"8\\\"); return user; } public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(QualifierAnnotationDependencyInjectionDemo.class); applicationContext.refresh(); XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(applicationContext); String xmlResourcePath = \\\"classpath:/META-INF/dependency-lookup-context.xml\\\"; beanDefinitionReader.loadBeanDefinitions(xmlResourcePath); QualifierAnnotationDependencyInjectionDemo demo = applicationContext.getBean(QualifierAnnotationDependencyInjectionDemo.class); // 输出SuperUSer Bean System.out.println(\\\"demo.user = \\\" + demo.user); // 输出 user Bean System.out.println(\\\"demo.namedUser = \\\" + demo.namedUser); // 输出 SuperUSer、user,注意这里输出的不是所有的user对象 System.out.println(\\\"demo.allUsers = \\\" + demo.allUsers); // 输出 user1、user2 System.out.println(\\\"demo.qualifierUsers = \\\" + demo.qualifierUsers); applicationContext.close(); } } \",\"通过注解的定义我们可以看到@Qualifier注解还可以作用到注解上面，也就是说可以对这个注解进行一些自定义的扩展：\",\"@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface Qualifier { String value() default \\\"\\\"; } \",\"接下来我们自定义一个注解：\",\"@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented @Qualifier public @interface UserGroup { } \",\"使用自定义注解来进行分组：\",\"/** * {@link org.springframework.beans.factory.annotation.Qualifier} 使用示例 */ public class QualifierAnnotationDependencyInjectionDemo { @Autowired // SuperUser -> primary = true private User user; @Autowired @Qualifier(\\\"user\\\") // 指定Bean名称或者ID private User namedUser; @Autowired private Collection<User> allUsers; @Autowired @Qualifier private Collection<User> qualifierUsers; @Autowired @UserGroup private Collection<User> groupedUsers; @Bean @Qualifier // 进行逻辑分组 public User user1() { User user = new User(); user.setId(\\\"7\\\"); return user; } @Bean @Qualifier public User user2() { User user = new User(); user.setId(\\\"8\\\"); return user; } @Bean @UserGroup public User user3() { User user = new User(); user.setId(\\\"9\\\"); return user; } @Bean @UserGroup public User user4() { User user = new User(); user.setId(\\\"10\\\"); return user; } public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(QualifierAnnotationDependencyInjectionDemo.class); applicationContext.refresh(); XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(applicationContext); String xmlResourcePath = \\\"classpath:/META-INF/dependency-lookup-context.xml\\\"; beanDefinitionReader.loadBeanDefinitions(xmlResourcePath); QualifierAnnotationDependencyInjectionDemo demo = applicationContext.getBean(QualifierAnnotationDependencyInjectionDemo.class); // 输出SuperUSer Bean System.out.println(\\\"demo.user = \\\" + demo.user); // 输出 user Bean System.out.println(\\\"demo.namedUser = \\\" + demo.namedUser); // 输出 SuperUSer、user,注意这里输出的不是所有的user对象 System.out.println(\\\"demo.allUsers = \\\" + demo.allUsers); // 输出 user1、user2、user3和user4,这个时候这个集合元素也增加了,这种方式了类似继承 System.out.println(\\\"demo.qualifierUsers = \\\" + demo.qualifierUsers); // 输出 user3和user4 System.out.println(\\\"demo.groupedUsers = \\\" + demo.groupedUsers); applicationContext.close(); } } \",\"最后我们来查看以下@LoadBalanced注解的实现：\",\"@Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD }) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Qualifier public @interface LoadBalanced { } \"]},\"962\":{\"h\":\"延迟依赖注入\",\"t\":[\"使用API ObjectFactory延迟注入 \",\"单一类型\",\"集合类型\",\"使用API ObjectProvider延迟注入（推荐，这里主要是基于安全性的考量） \",\"单一类型\",\"集合类型\",\"使用ObjectProvider延迟注入的例子：\",\"/** * {@link org.springframework.beans.factory.ObjectProvider} 实现延迟依赖注入 */ public class LazyAnnotationDependencyInjectionDemo { @Autowired private User user; // 实时注入 @Autowired private ObjectProvider<User> userObjectProvider; //延迟注入 @Autowired private ObjectProvider<Set<User>> usersObjectFactory; public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(LazyAnnotationDependencyInjectionDemo.class); applicationContext.refresh(); XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(applicationContext); String xmlResourcePath = \\\"classpath:/META-INF/dependency-lookup-context.xml\\\"; beanDefinitionReader.loadBeanDefinitions(xmlResourcePath); LazyAnnotationDependencyInjectionDemo demo = applicationContext.getBean(LazyAnnotationDependencyInjectionDemo.class); System.out.println(\\\"demo.user = \\\" + demo.user); System.out.println(\\\"demo.userObjectProvider = \\\" + demo.userObjectProvider); System.out.println(\\\"demo.usersObjectFactory\\\" + demo.usersObjectFactory); demo.userObjectProvider.forEach(System.out::println); applicationContext.close(); } } \"]},\"963\":{\"h\":\"依赖处理的过程\",\"t\":[\"基础知识：\",\"入口-DefaultListableBeanFactory#resolveDependency\",\"依赖描述符-DependencyDescriptor\",\"自定义绑定候选对象处理器-AutowireCandidateResolver\",\"首先观察以下依赖的描述类：\",\"public class DependencyDescriptor extends InjectionPoint implements Serializable { // 被注入的容器类 private final Class<?> declaringClass; // 方法名称 @Nullable private String methodName; // 构造器参数 @Nullable private Class<?>[] parameterTypes; // 参数索引 private int parameterIndex; // 属性名称 @Nullable private String fieldName; // 是不是必须的 private final boolean required; // 是不是饥饿的，@Lazy注解 private final boolean eager; // 嵌入层次 private int nestingLevel = 1; // 包含类 @Nullable private Class<?> containingClass; // 泛型处理 @Nullable private transient volatile ResolvableType resolvableType; // 类型描述 @Nullable private transient volatile TypeDescriptor typeDescriptor; } \",\"首先改造以下我们之前看到的例子：\",\"/** * 注解驱动的依赖注入过程 */ public class AnnotationDependencyInjectionResolutionDemo { @Autowired private User user; // DependencyDescriptor -> // 必须（required=true） // 实时注入（eager=true） // 通过类型查找（User.class） // 字段名称（“user”） // 是否首要（primary=true） public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(AnnotationDependencyInjectionResolutionDemo.class); applicationContext.refresh(); XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(applicationContext); String xmlResourcePath = \\\"classpath:/META-INF/dependency-lookup-context.xml\\\"; beanDefinitionReader.loadBeanDefinitions(xmlResourcePath); AnnotationDependencyInjectionResolutionDemo demo = applicationContext.getBean(AnnotationDependencyInjectionResolutionDemo.class); System.out.println(\\\"demo.user = \\\" + demo.user); applicationContext.close(); } } \",\"我们在DefaultListableBeanFactory#resolveDependency处打个断点进行观察：\",\"方法会继续往下执行到doResolveDependency方法：\",\"集合注入和单个类型的注入略微有点差别，首先我们增加一个成员变量：\",\" @Autowired // 集合类型的依赖注入 private Map<String,User> users; // user SuperUser \",\"这个时候在返回的时候就会进行判断，判断返回的类型是什么，然后然后把结果放进去进行返回：\",\" @Nullable private Object resolveMultipleBeans(DependencyDescriptor descriptor, @Nullable String beanName, @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) { Class<?> type = descriptor.getDependencyType(); if (descriptor instanceof StreamDependencyDescriptor) { Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor); if (autowiredBeanNames != null) { autowiredBeanNames.addAll(matchingBeans.keySet()); } Stream<Object> stream = matchingBeans.keySet().stream() .map(name -> descriptor.resolveCandidate(name, type, this)) .filter(bean -> !(bean instanceof NullBean)); if (((StreamDependencyDescriptor) descriptor).isOrdered()) { stream = stream.sorted(adaptOrderComparator(matchingBeans)); } return stream; } else if (type.isArray()) { Class<?> componentType = type.getComponentType(); ResolvableType resolvableType = descriptor.getResolvableType(); Class<?> resolvedArrayType = resolvableType.resolve(type); if (resolvedArrayType != type) { componentType = resolvableType.getComponentType().resolve(); } if (componentType == null) { return null; } Map<String, Object> matchingBeans = findAutowireCandidates(beanName, componentType, new MultiElementDescriptor(descriptor)); if (matchingBeans.isEmpty()) { return null; } if (autowiredBeanNames != null) { autowiredBeanNames.addAll(matchingBeans.keySet()); } TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter()); Object result = converter.convertIfNecessary(matchingBeans.values(), resolvedArrayType); if (result instanceof Object[]) { Comparator<Object> comparator = adaptDependencyComparator(matchingBeans); if (comparator != null) { Arrays.sort((Object[]) result, comparator); } } return result; } else if (Collection.class.isAssignableFrom(type) && type.isInterface()) { Class<?> elementType = descriptor.getResolvableType().asCollection().resolveGeneric(); if (elementType == null) { return null; } Map<String, Object> matchingBeans = findAutowireCandidates(beanName, elementType, new MultiElementDescriptor(descriptor)); if (matchingBeans.isEmpty()) { return null; } if (autowiredBeanNames != null) { autowiredBeanNames.addAll(matchingBeans.keySet()); } TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter()); Object result = converter.convertIfNecessary(matchingBeans.values(), type); if (result instanceof List) { if (((List<?>) result).size() > 1) { Comparator<Object> comparator = adaptDependencyComparator(matchingBeans); if (comparator != null) { ((List<?>) result).sort(comparator); } } } return result; } // Map类型 else if (Map.class == type) { // 获取到users字段的Map的泛型信息 ResolvableType mapType = descriptor.getResolvableType().asMap(); Class<?> keyType = mapType.resolveGeneric(0); if (String.class != keyType) { return null; } Class<?> valueType = mapType.resolveGeneric(1); if (valueType == null) { return null; } Map<String, Object> matchingBeans = findAutowireCandidates(beanName, valueType, new MultiElementDescriptor(descriptor)); if (matchingBeans.isEmpty()) { return null; } if (autowiredBeanNames != null) { autowiredBeanNames.addAll(matchingBeans.keySet()); } return matchingBeans; } else { return null; } } \",\"当进行集合类型的注入时，定义Bean的顺序也就是加载Bean的顺序，也是初始化Bean的时候的顺序。\",\"在Java8之后，也可以注入Optional类型的字段：\",\" @Autowired private Optional<User> userOptional; \",\"当注入的类型时延迟查找时，实际上会返回一个代理对象：\",\" @Autowired @Lazy private User lazyUser; \",\"总的来说，依赖注入的处理主要就是由以下两个方法来完成的：\",\" @Override @Nullable public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName, @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException { descriptor.initParameterNameDiscovery(getParameterNameDiscoverer()); // 对于Optional类型的判断 if (Optional.class == descriptor.getDependencyType()) { return createOptionalDependency(descriptor, requestingBeanName); } else if (ObjectFactory.class == descriptor.getDependencyType() || ObjectProvider.class == descriptor.getDependencyType()) { return new DependencyObjectProvider(descriptor, requestingBeanName); } else if (javaxInjectProviderClass == descriptor.getDependencyType()) { return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName); } else { Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary( descriptor, requestingBeanName); if (result == null) { result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter); } return result; } } @Nullable public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName, @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException { InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor); try { Object shortcut = descriptor.resolveShortcut(this); if (shortcut != null) { return shortcut; } Class<?> type = descriptor.getDependencyType(); Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor); if (value != null) { if (value instanceof String) { String strVal = resolveEmbeddedValue((String) value); BeanDefinition bd = (beanName != null && containsBean(beanName) ? getMergedBeanDefinition(beanName) : null); value = evaluateBeanDefinitionString(strVal, bd); } TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter()); try { return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor()); } catch (UnsupportedOperationException ex) { // A custom TypeConverter which does not support TypeDescriptor resolution... return (descriptor.getField() != null ? converter.convertIfNecessary(value, type, descriptor.getField()) : converter.convertIfNecessary(value, type, descriptor.getMethodParameter())); } } Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter); if (multipleBeans != null) { return multipleBeans; } Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor); if (matchingBeans.isEmpty()) { if (isRequired(descriptor)) { raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor); } return null; } String autowiredBeanName; Object instanceCandidate; if (matchingBeans.size() > 1) { autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor); if (autowiredBeanName == null) { if (isRequired(descriptor) || !indicatesMultipleBeans(type)) { return descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans); } else { // In case of an optional Collection/Map, silently ignore a non-unique case: // possibly it was meant to be an empty collection of multiple regular beans // (before 4.3 in particular when we didn't even look for collection beans). return null; } } instanceCandidate = matchingBeans.get(autowiredBeanName); } else { // We have exactly one match. Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next(); autowiredBeanName = entry.getKey(); instanceCandidate = entry.getValue(); } if (autowiredBeanNames != null) { autowiredBeanNames.add(autowiredBeanName); } if (instanceCandidate instanceof Class) { instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this); } Object result = instanceCandidate; if (result instanceof NullBean) { if (isRequired(descriptor)) { raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor); } result = null; } if (!ClassUtils.isAssignableValue(type, result)) { throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass()); } return result; } finally { ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint); } } \"]},\"964\":{\"h\":\"@Autowird注入\",\"t\":[\"@Autowired注入总体过程：\",\"元信息解析\",\"依赖查找\",\"依赖注入（字段、方法）\",\"核心处理方法：\",\"@Override protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable { // 标注了@Autowired注解的字段 Field field = (Field) this.member; Object value; if (this.cached) { try { value = resolvedCachedArgument(beanName, this.cachedFieldValue); } catch (NoSuchBeanDefinitionException ex) { // Unexpected removal of target bean for cached argument -> re-resolve value = resolveFieldValue(field, bean, beanName); } } else { value = resolveFieldValue(field, bean, beanName); } if (value != null) { // 有可能时非public字段 ReflectionUtils.makeAccessible(field); // 最终通过反射的方式将依赖注入的对象设置到属性上 field.set(bean, value); } } \",\"在XML中配置信息解析的方法：\",\" @Override public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) { InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs); try { metadata.inject(bean, beanName, pvs); } catch (BeanCreationException ex) { throw ex; } catch (Throwable ex) { throw new BeanCreationException(beanName, \\\"Injection of autowired dependencies failed\\\", ex); } return pvs; } \",\"这个方法会在set方法执行之前就执行，并且这个时候还没有进行类型转换。当这个类有父类的时候，会进行属性合并的操作，并且是在postProcessProperties之前执行的。\",\"@Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) { InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); } \",\"一直会找到所有父类中的属性的方法：\",\" @Nullable private MergedAnnotation<?> findAutowiredAnnotation(AccessibleObject ao) { MergedAnnotations annotations = MergedAnnotations.from(ao); for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) { MergedAnnotation<?> annotation = annotations.get(type); if (annotation.isPresent()) { return annotation; } } return null; } \",\"调用上述方法的地方：\",\" ReflectionUtils.doWithLocalFields(targetClass, field -> { MergedAnnotation<?> ann = findAutowiredAnnotation(field); if (ann != null) { // 可以看到就是在这里排除掉了static的字段 if (Modifier.isStatic(field.getModifiers())) { if (logger.isInfoEnabled()) { logger.info(\\\"Autowired annotation is not supported on static fields: \\\" + field); } return; } boolean required = determineRequiredStatus(ann); currElements.add(new AutowiredFieldElement(field, required)); } }); \",\"可以看到在postProcessMergedBeanDefinition就完成了Bean的元信息的组装，并且在postProcessProperties执行的时候会包含调用DefaultListableBeanFactory#resolveDependency方法的过程。\"]},\"965\":{\"h\":\"@Inject和@Autowired联系\",\"t\":[\"@Inject注入过程\",\"如果JSR-330存在于ClassPath中，就直接复用AutowiredAnnotationBeanPostProcessor的实现。\",\"在源代码中可以看到相关的逻辑：\",\"这里首先要关注一个属性：\",\"private final Set<Class<? extends Annotation>> autowiredAnnotationTypes = new LinkedHashSet<>(4); \",\"可以看到autowiredAnnotationTypes实际上是一个有序的Set集合，接下来是具体处理的逻辑：\",\" public AutowiredAnnotationBeanPostProcessor() { // 依次插入Autowired、Value、inject this.autowiredAnnotationTypes.add(Autowired.class); this.autowiredAnnotationTypes.add(Value.class); try { this.autowiredAnnotationTypes.add((Class<? extends Annotation>) ClassUtils.forName(\\\"javax.inject.Inject\\\", AutowiredAnnotationBeanPostProcessor.class.getClassLoader())); logger.trace(\\\"JSR-330 'javax.inject.Inject' annotation found and supported for autowiring\\\"); } catch (ClassNotFoundException ex) { // JSR-330 API not available - simply skip. } } \",\"可以看到实际上还可以进行复合注解，并且在处理的时候：\",\" @Nullable private MergedAnnotation<?> findAutowiredAnnotation(AccessibleObject ao) { MergedAnnotations annotations = MergedAnnotations.from(ao); for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) { MergedAnnotation<?> annotation = annotations.get(type); if (annotation.isPresent()) { return annotation; } } return null; } \",\"因此，如果要使用@Inject注解，就需要引入依赖：\",\"<dependency> <groupId>javax.inject</groupId> <artifactId>javax.inject</artifactId> <version>1</version> </dependency> \",\"可以发现@Inject和@Autowired注解在处理的上完全一样的，都是使用AutowiredAnnotationBeanPostProcessor来处理依赖注入的过程。\"]},\"966\":{\"h\":\"Java通用注解原理\",\"t\":[\"CommonAnnotationBeanPostProcessor\",\"注入注解 \",\"javax.xml.ws.WebServiceRef\",\"javax.ejb.EJB\",\"javax.annotation.Resource\",\"生命周期注解 \",\"javax.annotation.PostConstruct\",\"javax.annotation.PreDestory\",\"CommonAnnotationBeanPostProcessor和AutowiredAnnotationBeanPostProcessor大概的实现逻辑是如出一辙的，只是在细微的地方略有差别。\",\"CommonAnnotationBeanPostProcessor实现了InitDestroyAnnotationBeanPostProcessor接口\",\"public class CommonAnnotationBeanPostProcessor extends InitDestroyAnnotationBeanPostProcessor implements InstantiationAwareBeanPostProcessor, BeanFactoryAware, Serializable { // ... } \",\"在InitDestroyAnnotationBeanPostProcessor中也可以看到postProcessMergedBeanDefinition这个方法：\",\"这里只是元信息不太一样，这主要是LifecycleMetadata中包含了初始化和销毁两个阶段。\",\"同样CommonAnnotationBeanPostProcessor也有postProcessProperties的方法：\",\"对于生命周期的注解的处理，可以从构造方法中看出：\",\"public CommonAnnotationBeanPostProcessor() { // 优先级是倒数第四位的 setOrder(Ordered.LOWEST_PRECEDENCE - 3); setInitAnnotationType(PostConstruct.class); setDestroyAnnotationType(PreDestroy.class); ignoreResourceType(\\\"javax.xml.ws.WebServiceContext\\\"); } \",\"CommonAnnotationBeanPostProcessor会在AutowiredAnnotationBeanPostProcessor之前进行处理，这一点，可以通过实现的PriorityOrdered接口，看到属性中定义的顺序来进行确认。\"]},\"967\":{\"h\":\"自定义依赖注入注解\",\"t\":[\"基于AutowiredAnnotationBeanPostProcessor实现\",\"自定义实现 \",\"生命周期处理 \",\"InstantiationAwareBeanPostProcessor\",\"MergedBeanDefinitionPostProcessor\",\"元数据 \",\"InjectedElement\",\"InjectionMetadata\",\"基于AutowiredAnnotationBeanPostProcessor实现自定义依赖注入相对比较容易，如果使用自定义实现，就比较麻烦。\",\"/** * 自定义注解 */ @Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Autowired public @interface MyAutowired { boolean required() default true; } \",\"这里我们不对@Autowired做任何的扩展，仅仅使用它进行元标注，定义完成之后使用MyAutowired进行注入：\",\" @MyAutowired private Optional<User> userOptional; \",\"发现依然可以正常地工作，接下来我们自定义一个注解：\",\"/** * 自定义依赖注入注解 */ @Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface InjectedUser { } \",\"将我们自定义的注解类型添加到AutowiredAnnotationBeanPostProcessor中：\",\" @Bean(name = AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME) //注意这里是static方法，会提前初始化方法 public static AutowiredAnnotationBeanPostProcessor beanPostProcessor() { AutowiredAnnotationBeanPostProcessor beanPostProcessor = new AutowiredAnnotationBeanPostProcessor(); // 替换原有注解处理，使用新注解@InjectedUser，原来的注解会失效 // beanPostProcessor.setAutowiredAnnotationType(InjectedUser.class); // 保留原来的方式，添加新的注解，@Autowired + @InjectedUser Set<Class<? extends Annotation>> autowiredAnnotationTypes = new LinkedHashSet<>(Arrays.asList(Autowired.class, Inject.class, InjectedUser.class)); beanPostProcessor.setAutowiredAnnotationTypes(autowiredAnnotationTypes); return beanPostProcessor; } \",\"测试我们的注解是否生效：\",\" @InjectedUser private User myInjectedUser; \",\"答案是肯定的。如何实现新老注解的兼容的注入方法呢？\",\"首先注入一个AutowiredAnnotationBeanPostProcessor，并设置我们自定义的注解\",\" @Bean @Order(Ordered.LOWEST_PRECEDENCE - 3) public static AutowiredAnnotationBeanPostProcessor beanPostProcessor() { AutowiredAnnotationBeanPostProcessor beanPostProcessor = new AutowiredAnnotationBeanPostProcessor(); beanPostProcessor.setAutowiredAnnotationType(InjectedUser.class); return beanPostProcessor; } \",\"​ 在AnnotationConfigUtils#registerAnnotationConfigProcessors中\",\"if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) { RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); } \",\"可以看到如果AutowiredAnnotationBeanPostProcessor这个Bean存在的话，就不注册，不存在的会注册一个默认的，因为我们这里注入AutowiredAnnotationBeanPostProcessor采用的static，就会首先使用我们注册的AutowiredAnnotationBeanPostProcessor来进行依赖注入，这时候，在应用上下文中有两个AutowiredAnnotationBeanPostProcessor来进行处理。\"]},\"968\":{\"h\":\"面试题\"},\"969\":{\"h\":\"有多少种依赖注入的方式\",\"t\":[\"构造器注入、Setter注入、字段注入、方法注入、接口回调注入\"]},\"970\":{\"h\":\"你偏好构造器注入还是Setter注入?\",\"t\":[\"两种依赖注入的方式均可以使用，如果是必须依赖的话，那么推荐使用构造器注入，Setter注入用于可选依赖。\"]},\"971\":{\"h\":\"Spring依赖注入的来源有哪些？\",\"t\":[\"待续...\"]},\"972\":{\"h\":\"依赖查找的来源\",\"t\":[\"查找来源：\",\"来源\",\"配置元数据\",\"Spring BeanDefinition\",\"<bean id=\\\"user\\\" class=\\\"org...User\\\">\",\"@Beanpublic User user(){...}\",\"BeanDefinitionBuilder\",\"单例对象\",\"API实现\"]},\"973\":{\"h\":\"依赖注入的来源\",\"t\":[\"注入来源：\",\"来源\",\"配置元数据\",\"Spring BeanDefinition\",\"<bean id=\\\"user\\\" class=\\\"org...User\\\">\",\"@Beanpublic User user(){...}\",\"BeanDefinitionBuilder\",\"单例对象\",\"API实现\",\"非Spring容器管理对象（游离对象）\",\"AbstractApplicationContext#refresh()方法会调用prepareBeanFactory(beanFactory)方法，这个方法中会注入一些Bean：\",\" // BeanFactory interface not registered as resolvable type in a plain factory. // MessageSource registered (and found for autowiring) as a bean. beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); // 注意接下来的都是当前ApplicationContext对象 beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); \",\"实际上，注入了四个类型，两个对象。\",\"/** * 依赖来源示例 */ public class DependencySourceDemo { // 注入在postProcessProperties方法执行，早于setter注入，也早于PostConstruct @Autowired private BeanFactory beanFactory; @Autowired private ResourceLoader resourceLoader; @Autowired private ApplicationContext applicationContext; @Autowired private ApplicationEventPublisher applicationEventPublisher; @PostConstruct public void init() { System.out.println(\\\"beanFactory == applicationContext: \\\" + (beanFactory == applicationContext)); System.out.println(\\\"beanFactory == applicationContext.getBeanFactory: \\\" + (beanFactory == applicationContext.getAutowireCapableBeanFactory())); System.out.println(\\\"resourceLoader == applicationContext: \\\" + (resourceLoader == applicationContext)); System.out.println(\\\"applicationEventMulticaster == applicationContext: \\\" + (applicationEventPublisher == applicationContext)); } @PostConstruct public void initByLookup() { getBean(BeanFactory.class); getBean(ResourceLoader.class); getBean(ApplicationContext.class); getBean(ApplicationEventPublisher.class); } private <T> T getBean(Class<T> beanType) { try { return beanFactory.getBean(beanType); } catch (NoSuchBeanDefinitionException e) { System.err.println(\\\"当前类型\\\" + beanType.getName() + \\\"无法在BeanFactory中查找\\\"); return null; } } public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(DependencySourceDemo.class); applicationContext.refresh(); DependencySourceDemo demo = applicationContext.getBean(DependencySourceDemo.class); applicationContext.close(); } } \"]},\"974\":{\"h\":\"Spring容器管理和游离对象\",\"t\":[\"依赖对象：\",\"来源\",\"Spring Bean对象\",\"生命周期管理\",\"配置元信息\",\"使用场景\",\"Spring BeanDefinition\",\"是\",\"是\",\"有\",\"依赖查找、依赖注入\",\"单体对象\",\"是\",\"否\",\"无\",\"依赖查找、依赖注入\",\"Resolvable Dependency\",\"否\",\"否\",\"无\",\"依赖注入\"]},\"975\":{\"h\":\"Spring BeanDefinition作为依赖来源\",\"t\":[\"要素：\",\"元数据：BeanDefinition\",\"注册：BeanDefinitionRegistry#registerBeanDefinition\",\"类型：延迟和非延迟\",\"顺序：Bean生命周期顺序按照注册顺序\",\"BeanDefinitionRegistry有且仅有一个实现，就是DefaultListableBeanFactory，首先有这样两个属性：\",\"// Map of bean definition objects, keyed by bean name private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256); // List of bean definition names, in registration order. private volatile List<String> beanDefinitionNames = new ArrayList<>(256); \",\"在registerBeanDefinition方法中会这样保存数据：\",\"this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); \",\"可以看到这里除了保存beanName和beanDefinition，还单独保存了beanName，这样做的原因就是ConcurrentHashMap是无序的，而ArrayList是有序的，后面在初始化的时候，会根据这个List里面的Bean的名称，按照次序依次进行初始化操作。\"]},\"976\":{\"h\":\"单体对象作为依赖来源\",\"t\":[\"要素：\",\"来源：外部普通Java对象（不一定是POJO）\",\"注册：SingletonBeanRegistry#registerSinleton\",\"限制：\",\"无生命周期管理\",\"无法实现延迟初始化Bean\"]},\"977\":{\"h\":\"Resolvable Dependency作为依赖来源\",\"t\":[\"要素：\",\"注册：ConfigurableListableBeanFactory#registerResolvableDependency\",\"限制：\",\"无生命周期管理\",\"无法延迟初始化Bean\",\"无法通过依赖查找\",\"/** * ResolvableDependency作为依赖来源 */ public class ResolvableDependencySourceDemo { @Autowired private String value; @PostConstruct public void init() { System.out.println(value); } public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(ResolvableDependencySourceDemo.class); // 只能用于类型方面的依赖注入 applicationContext.addBeanFactoryPostProcessor(beanFactory -> { beanFactory.registerResolvableDependency(String.class,\\\"hello,world\\\"); }); applicationContext.refresh(); applicationContext.close(); } } \"]},\"978\":{\"h\":\"外部化配置作为依赖来源\",\"t\":[\"要素：\",\"类型：非常规Spring对象依赖来源\",\"限制：\",\"无生命周期管理\",\"无法实现延迟初始化Bean\",\"无法通过依赖查找\",\"外部化配置的示例：\",\"/** * 外部化配置作为依赖来源示例 */ @PropertySource(value = \\\"META-INF/default.properties\\\",encoding = \\\"GBK\\\") @Configuration public class ExternalConfigurationDependencySourceDemo { @Value(\\\"${user.id}\\\") private String id; @Value(\\\"${user.resource}\\\") private Resource resource; // 如果是中文，这里会显示操作系统登录的用户名，而不是在配置文件中配置的信息。这是因为user.name是一个系统属性。 // @Value(\\\"${user.name}\\\") // private String name; // 直接输出会显示乱码,需要设置编码 @Value(\\\"${usr.name}\\\") private String name; public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(ExternalConfigurationDependencySourceDemo.class); applicationContext.refresh(); ExternalConfigurationDependencySourceDemo demo = applicationContext.getBean(ExternalConfigurationDependencySourceDemo.class); System.out.println(\\\"id: \\\" + demo.id); System.out.println(\\\"resource: \\\" + demo.resource); System.out.println(\\\"name: \\\" + demo.name); applicationContext.close(); } } \",\"实现原理就是DefaultListableBeanFactory#doResolveDependency中：\",\"会通过接下来的方法进行替换，将属性替换为配置文件中的值：\",\"String strVal = resolveEmbeddedValue((String) value); \"]},\"979\":{\"h\":\"面试题\"},\"980\":{\"h\":\"依赖注入和依赖查找的依赖来源是否相同？\",\"t\":[\"否，依赖查找的来源仅限于Spring BeanDefinition以及单例对象，而依赖注入的来源还包括了Resolvable Dependency以及@Value所标注的外部化配置。\"]},\"981\":{\"h\":\"单例对象能在IoC容器启动后注册吗？\",\"t\":[\"可以的，单例对象注册与BeanDefinition不同，BeanDefinition会被ConfigurableListableBeanFactory#freezeConfiguration()方法影响，从而冻结注册，单例对象则没有这个限制。\"]},\"982\":{\"h\":\"Spring依赖注入的来源有哪些？\",\"t\":[\"Spring BeanDefinition、单例对象、Resolvable Dependency、@Value外部化配置\"]},\"983\":{\"h\":\"作用域简介\",\"t\":[\"来源\",\"说明\",\"singleton\",\"默认Spring Bean作用域，一个BeanFactory有且仅有一个实例\",\"prototype\",\"原型作用域，每次依赖查找和依赖注入生成新Bean对象\",\"request\",\"将Spring Bean存储在ServletRequest上下文中\",\"session\",\"将Spring Bean存储在HttpSession中\",\"application\",\"将Spring Bean存储在ServletContext中\",\"笼统而言，我们只要记住单例和原型两种即可，其余三种主要是为了服务端模板引擎渲染，包括JSP、Velocity、FreeMarker。\"]},\"984\":{\"h\":\"singleton作用域\",\"t\":[\"单例模式是在一定范围内是全局共享的，但是这个范围是有限的。通过观察BeanDefinition源代码可以发现，其实只有singleton和prototype这两个作用域相关的方法：\",\" // 是否是单例 boolean isSingleton(); // 是否是原型 boolean isPrototype(); \",\"单例模式的示例图：\",\"这里有一个误区就是，singleton和prototype并没有互斥的关系，是可以同时存在的，当然，如果同时存在的话，可能行为会有一些问题。\"]},\"985\":{\"h\":\"prototype作用域\",\"t\":[\"多例模式的示意图：\",\"多例和单例比较的示例：\",\"/** * Bean的作用域示例 */ public class BeanScopeDemo { @Bean // 默认的scop就是“singleton” public static User singletonUser() { return createUser(); } @Bean @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) public static User prototypeUser() { return createUser(); } private static User createUser() { User user = new User(); user.setId(String.valueOf(System.nanoTime())); return user; } @Autowired @Qualifier(\\\"singletonUser\\\") private User singletonUser; @Autowired @Qualifier(\\\"singletonUser\\\") private User singletonUser1; @Autowired @Qualifier(\\\"prototypeUser\\\") private User prototypeUser; @Autowired @Qualifier(\\\"prototypeUser\\\") private User prototypeUser1; @Autowired @Qualifier(\\\"prototypeUser\\\") private User prototypeUser2; @Autowired private Map<String,User> users; private static void scopedBeansByInjection(AnnotationConfigApplicationContext applicationContext) { BeanScopeDemo beanScopeDemo = applicationContext.getBean(BeanScopeDemo.class); System.out.println(\\\"beanScopeDemo.singletonUser = \\\" + beanScopeDemo.singletonUser); System.out.println(\\\"beanScopeDemo.singletonUser1 = \\\" + beanScopeDemo.singletonUser1); System.out.println(\\\"beanScopeDemo.prototypeUser1 = \\\" + beanScopeDemo.prototypeUser); System.out.println(\\\"beanScopeDemo.prototypeUser2 = \\\" + beanScopeDemo.prototypeUser1); System.out.println(\\\"beanScopeDemo.prototypeUser3 = \\\" + beanScopeDemo.prototypeUser2); System.out.println(\\\"beanScopeDemo.users = \\\" + beanScopeDemo.users); } private static void scopedBeansByLookup(AnnotationConfigApplicationContext applicationContext) { for (int i = 0; i < 3; i++) { User singletonUser = applicationContext.getBean(\\\"singletonUser\\\", User.class); // singletonUser是共享的Bean对象 System.out.println(\\\"singletonUser = \\\" + singletonUser.getId()); // prototypeUser是每次依赖查找都会生成新的Bean对象 User prototypeUser = applicationContext.getBean(\\\"prototypeUser\\\", User.class); System.out.println(\\\"prototypeUser = \\\" + prototypeUser.getId()); } } public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(BeanScopeDemo.class); applicationContext.refresh(); // 结论一： // singleton Bean无论依赖查找还是依赖注入均为同一个对象 // prototype Bean无论依赖查找还是依赖注入均为新生成的对象 // 结论二： // 如果依赖注入集合类型的对象，singleton Bean和prototype Bean均会存在一个 // prototype Bean有别于其他地方的依赖注入 scopedBeansByLookup(applicationContext); scopedBeansByInjection(applicationContext); applicationContext.close(); } } \",\"注意事项：\",\"Spring容器没有办法管理prototype Bean的完整生命周期，也没有办法记录实例的存在。销毁回调方法将不会执行，可以利用BeanPostProcess进行清扫工作。\",\"public class User implements BeanNameAware { private String id; private String name; private transient String beanName; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \\\"User{\\\" + \\\"id='\\\" + id + '\\\\'' + \\\", name='\\\" + name + '\\\\'' + '}'; } public static User createUser() { User user = new User(); user.setName(\\\"createUser\\\"); user.setId(\\\"123\\\"); return user; } @PostConstruct public void init() { System.out.println(\\\"User Bean [\\\" + beanName + \\\"]初始化...\\\"); } @PreDestroy public void destory() { System.out.println(\\\"User Bean [\\\" + beanName + \\\"]销毁化...\\\"); } @Override public void setBeanName(String name) { this.beanName = name; } } \",\"运行刚才的例子不难看出，初始化的方法每次还是会被调用，但是销毁方法只有单例的Bean才会调用，那么如何销毁prototype的Bean呢？一种做法就是前面提到的BeanPostProcess：\",\" applicationContext.addBeanFactoryPostProcessor(beanFactory -> { beanFactory.addBeanPostProcessor(new BeanPostProcessor() { @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.printf(\\\"%s Bean名称: %s 在初始化后回调...%n\\\", bean.getClass().getName(), beanName); return bean; } }); }); \",\"在这个方法里面可以执行一些销毁的逻辑，但是使用这种方式，可能会有一些意想不到的结果，因为创建好的prototype的Bean通常而言都是马上要使用的，而不需要在它上面增加一些额外的操作，更为推荐的方式，是在维护prototype的Bean的类中，利用它的生命周期方法，对于所管理的prototype类型的类进行销毁：\",\"public class BeanScopeDemo implements DisposableBean { @Bean // 默认的scop就是“singleton” public static User singletonUser() { return createUser(); } @Bean @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) public static User prototypeUser() { return createUser(); } private static User createUser() { User user = new User(); user.setId(String.valueOf(System.nanoTime())); return user; } @Autowired @Qualifier(\\\"singletonUser\\\") private User singletonUser; @Autowired @Qualifier(\\\"singletonUser\\\") private User singletonUser1; @Autowired @Qualifier(\\\"prototypeUser\\\") private User prototypeUser; @Autowired @Qualifier(\\\"prototypeUser\\\") private User prototypeUser1; @Autowired @Qualifier(\\\"prototypeUser\\\") private User prototypeUser2; @Autowired private Map<String, User> users; public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(BeanScopeDemo.class); applicationContext.refresh(); applicationContext.close(); } @Override public void destroy() { System.out.println(\\\"当前BeanScopeDemo Bean 正在销毁中\\\"); this.prototypeUser.destory(); this.prototypeUser1.destory(); this.prototypeUser2.destory(); for (Map.Entry<String, User> entry : this.users.entrySet()) { String beanName = entry.getKey(); BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName); if (beanDefinition.isPrototype()) { User user = entry.getValue(); user.destory(); } } System.out.println(\\\"当前BeanScopeDemo Bean 销毁已完成...\\\"); } } \"]},\"986\":{\"h\":\"request作用域\",\"t\":[\"配置 \",\"XML - <bean class=\\\"...\\\" scope=\\\"request\\\">\",\"Java注解 - @RequestScope或@Scope（WebApplicationContext.SCOPE_REQUEST）\",\"实现 \",\"API - RequestScope\"]},\"987\":{\"h\":\"session作用域\",\"t\":[\"配置 \",\"XML - <bean class=\\\"...\\\" scope=\\\"session\\\">\",\"Java注解 - @SessionScope或@Scope（WebApplicationContext.SCOPE_SESSION）\",\"实现 \",\"API - SessionScope\",\"request作用域的对象，每次请求都会返回一个新的对象，并且对象会经历初始化和销毁两个过程，而session作用域，在同一个cookie的情况下，每次返回的都是同一个对象，这个时候对象只会经历初始化的过程，而不会对Bean进行销毁。无论是request还是session，返回的对象都是经过cglib代理的对象。\"]},\"988\":{\"h\":\"application作用域\",\"t\":[\"配置 \",\"XML - <bean class=\\\"...\\\" scope=\\\"application\\\">\",\"Java注解 - @ApplicationScope或@Scope（WebApplicationContext.APPLICATION）\",\"实现 \",\"API - ApplicationScope\",\"application作用域的Bean可以在ServletContext中直接获取到。一个JavaWeb应用只创建一个ServletContext对象，应用在启动的时候创建ServletContext对象，在服务器关闭的时候销毁，使用ServletContext获取到的Bean对象也是经过cglib代理的对象，Bean的名称为scopedTarget.beanName\"]},\"989\":{\"h\":\"自定义Bean作用域\",\"t\":[\"实现Scope\",\"org.springframework.beans.factory.config.Scope\",\"注册Scope\",\"API - org.springframework.beans.factory.config.ConfigurableBeanFactory#registerScope\",\"配置：\",\"<bean class=\\\"org.springframework.beans.factory.config.CustomScopeConfigurer\\\"> <property name=\\\"scopes\\\"> <map> <entry key=\\\"...\\\"> </entry> </map> </property> </bean> \",\"自定义作用的相关示例，首先进行定义：\",\"public class ThreadLocalScope implements Scope { public static final String SCOP_NAME = \\\"thread-local\\\"; private final NamedThreadLocal<Map<String, Object>> threadLocal = new NamedThreadLocal(\\\"thread-local-scope\\\") { @Override public Map<String, Object> initialValue() { return new HashMap<>(); } }; @Override public Object get(String name, ObjectFactory<?> objectFactory) { // 非空 Map<String, Object> context = getContext(); Object object = context.get(name); if (object == null) { object = objectFactory.getObject(); context.put(name, object); } return object; } private Map<String, Object> getContext() { return threadLocal.get(); } @Override public Object remove(String name) { Map<String, Object> context = getContext(); return context.remove(name); } @Override public void registerDestructionCallback(String name, Runnable callback) { // TODO } @Override public Object resolveContextualObject(String key) { Map<String, Object> context = getContext(); return context.get(key); } @Override public String getConversationId() { Thread thread = Thread.currentThread(); return String.valueOf(thread.getId()); } } \",\"接下来进行注册并且测试是否成功：\",\"public class ThreadLocalScopeDemo { @Bean @Scope(ThreadLocalScope.SCOP_NAME) public User user() { return createUser(); } private static User createUser() { User user = new User(); user.setId(String.valueOf(System.nanoTime())); return user; } public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(ThreadLocalScopeDemo.class); applicationContext.addBeanFactoryPostProcessor(beanFactory -> { beanFactory.registerScope(ThreadLocalScope.SCOP_NAME, new ThreadLocalScope()); } ); applicationContext.refresh(); scopedBeansByLookup(applicationContext); applicationContext.close(); } private static void scopedBeansByLookup(AnnotationConfigApplicationContext applicationContext) { // 单个线程下，返回的永远是同一个Bean // for (int i = 0; i < 3; i++) { // User user = applicationContext.getBean(\\\"user\\\", User.class); // System.out.println(\\\"user = \\\" + user.getId()); // } for (int i = 0; i < 3; i++) { Thread thread = new Thread(() -> { User user = applicationContext.getBean(\\\"user\\\", User.class); System.out.printf(\\\"[Thread id: %d] user = %s%n\\\", Thread.currentThread().getId(), user); }); thread.start(); // 强制线程执行完成 try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } } } \"]},\"990\":{\"h\":\"面试题\"},\"991\":{\"h\":\"Spring内建的Bean的作用域有几种？\",\"t\":[\"sington、prototype、request、session、application以及websocket\"]},\"992\":{\"h\":\"singleton Bean是否在一个应用中是唯一的？\",\"t\":[\"否，singleton bean仅在当前Spring IoC容器（BeanFactory）中是单例对象。\"]},\"993\":{\"h\":\"\\\"application\\\" Bean是否被其他方案他替代？\",\"t\":[\"可以的，实际上，\\\"application\\\" Bean与\\\"singleton\\\" Bean没有本质区别。\"]},\"994\":{\"h\":\"元信息配置阶段\",\"t\":[\"BeanDefinition的配置方式：\",\"面向资源 \",\"XML配置\",\"Properties资源配置\",\"面向注解\",\"面向API\",\"这里除了Properties资源配置我们没有见到过外，其他的都有相关的示例。\",\"# 注意这里必须这么写，不能写user.class user.(class) = org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User user.id = 001 user.name = 吉永超 user.city = HANGZHOU \",\"相关的演示示例：\",\"public class BeanMetadataConfigurationDemo { public static void main(String[] args) { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); // 实例化PropertiesBeanDefinitionReader PropertiesBeanDefinitionReader propertiesBeanDefinitionReader = new PropertiesBeanDefinitionReader(beanFactory); String location = \\\"classpath:/META-INF/user.properties\\\"; int beanNumbers = propertiesBeanDefinitionReader.loadBeanDefinitions(location); System.out.println(\\\"已加载的BeanDefinitiond的数量：\\\" + beanNumbers); // 通过Bean ID和类型进行依赖查找 User user = beanFactory.getBean(\\\"user\\\", User.class); System.out.println(user.toString()); } } \"]},\"995\":{\"h\":\"元信息解析阶段\",\"t\":[\"主要分为两种：\",\"面向资源BeanDefinition解析 \",\"BeanDefinitionReader\",\"XML解析器 - BeanDefinitionParser\",\"面向注解BeanDefinition解析 \",\"AnnotatedBeanDefinitionReader\",\"面向资源的情况我们在之前也有过相关的讨论，这里只介绍面向注解的BeanDefinition解析：\",\"public class AnnotatedBeanDefinitionParsingDemo { public static void main(String[] args) { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); // 基于Java 注解的 AnnotatedBeanDefinitionReader的实现 AnnotatedBeanDefinitionReader beanDefinitionReader = new AnnotatedBeanDefinitionReader(beanFactory); int beanDefinitionCountBefore = beanFactory.getBeanDefinitionCount(); // 注册当前类（非Componenet Class） beanDefinitionReader.registerBean(AnnotatedBeanDefinitionParsingDemo.class); int beanDefinitionCountAfter = beanFactory.getBeanDefinitionCount(); int beanDefinitionCount = beanDefinitionCountAfter - beanDefinitionCountBefore; System.out.println(\\\"已加载的BeanDefinitiond的数量：\\\" + beanDefinitionCount); // 普通Class作为Component注册到Spring IoC容器后，通常Bean的名称为类名的首字母小写（annotatedBeanDefinitionParsingDemo） // Bean名称生成来自于BeanNameGenerator，注解实现AnnotationBeanNameGenerator AnnotatedBeanDefinitionParsingDemo demo = beanFactory.getBean(\\\"annotatedBeanDefinitionParsingDemo\\\", AnnotatedBeanDefinitionParsingDemo.class); System.out.println(demo); } } \",\"默认生成Bean的名称的部分代码：\",\" protected String buildDefaultBeanName(BeanDefinition definition) { String beanClassName = definition.getBeanClassName(); Assert.state(beanClassName != null, \\\"No bean class name set\\\"); String shortClassName = ClassUtils.getShortName(beanClassName); return Introspector.decapitalize(shortClassName); } \"]},\"996\":{\"h\":\"注册阶段\",\"t\":[\"BeanDefinition注册的核心接口：BeanDefinitionRegistry，它有且仅有一个实现类就是DefaultListableBeanFactory。DefaultListableBeanFactory#registerBeanDefinition的逻辑如下：\",\"public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { Assert.hasText(beanName, \\\"Bean name must not be empty\\\"); Assert.notNull(beanDefinition, \\\"BeanDefinition must not be null\\\"); if (beanDefinition instanceof AbstractBeanDefinition) { try { ((AbstractBeanDefinition) beanDefinition).validate(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, \\\"Validation of bean definition failed\\\", ex); } } BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName); // 当已经存在BeanDefinition的时候 if (existingDefinition != null) { // 允许Bean重复注册 if (!isAllowBeanDefinitionOverriding()) { throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition); } else if (existingDefinition.getRole() < beanDefinition.getRole()) { // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE if (logger.isInfoEnabled()) { logger.info(\\\"Overriding user-defined bean definition for bean '\\\" + beanName + \\\"' with a framework-generated bean definition: replacing [\\\" + existingDefinition + \\\"] with [\\\" + beanDefinition + \\\"]\\\"); } } else if (!beanDefinition.equals(existingDefinition)) { if (logger.isDebugEnabled()) { logger.debug(\\\"Overriding bean definition for bean '\\\" + beanName + \\\"' with a different definition: replacing [\\\" + existingDefinition + \\\"] with [\\\" + beanDefinition + \\\"]\\\"); } } else { if (logger.isTraceEnabled()) { logger.trace(\\\"Overriding bean definition for bean '\\\" + beanName + \\\"' with an equivalent definition: replacing [\\\" + existingDefinition + \\\"] with [\\\" + beanDefinition + \\\"]\\\"); } } this.beanDefinitionMap.put(beanName, beanDefinition); } else { // 注册一个新的BeanDefinition if (hasBeanCreationStarted()) { // Cannot modify startup-time collection elements anymore (for stable iteration) synchronized (this.beanDefinitionMap) { // 这里的beanDefinitionMap的类型是Map<String, BeanDefinition>,key就是Bean的名称，value就是对应的BeanDefinition this.beanDefinitionMap.put(beanName, beanDefinition); // 这里之所以还要维护一个beanDefinitionNames是为了记住注册时候的Bean的顺序。 List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; removeManualSingletonName(beanName); } } else { // Still in startup registration phase this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); removeManualSingletonName(beanName); } this.frozenBeanDefinitionNames = null; } if (existingDefinition != null || containsSingleton(beanName)) { resetBeanDefinition(beanName); } else if (isConfigurationFrozen()) { clearByTypeCache(); } } \"]},\"997\":{\"h\":\"BeanDefinition合并阶段\",\"t\":[\"BeanDefinition合并：\",\"父子BeanDefinition合并 \",\"当前BeanFactory查找\",\"层次性BeanFactory查找\",\"相关的示例：\",\"public class MergedBeanDefinitionDemo { public static void main(String[] args) { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); // 基于XML资源BeanDefinitionReader 实现 XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); String location = \\\"META-INF/dependency-lookup-context.xml\\\"; Resource resource = new ClassPathResource(location); EncodedResource encodedResource = new EncodedResource(resource, \\\"UTF-8\\\"); int beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(encodedResource); System.out.println(\\\"已加载的BeanDefinitiond的数量：\\\" + beanNumbers); // 不需要合并BeanDefinition User user = beanFactory.getBean(\\\"user\\\", User.class); System.out.println(user.toString()); // 需要合并BeanDefinition SuperUser superUser = beanFactory.getBean(\\\"SuperUser\\\", SuperUser.class); System.out.println(superUser.toString()); } } \",\"递归查找\",\" @Override public BeanDefinition getMergedBeanDefinition(String name) throws BeansException { String beanName = transformedBeanName(name); // Efficiently check whether bean definition exists in this factory. if (!containsBeanDefinition(beanName) && getParentBeanFactory() instanceof ConfigurableBeanFactory) { return ((ConfigurableBeanFactory) getParentBeanFactory()).getMergedBeanDefinition(beanName); } // Resolve merged bean definition locally. // 当前的BeanFactory return getMergedLocalBeanDefinition(beanName); } \",\"合并的核心代码：\",\" protected RootBeanDefinition getMergedBeanDefinition( String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd) throws BeanDefinitionStoreException { synchronized (this.mergedBeanDefinitions) { RootBeanDefinition mbd = null; RootBeanDefinition previous = null; // Check with full lock now in order to enforce the same merged instance. if (containingBd == null) { mbd = this.mergedBeanDefinitions.get(beanName); } if (mbd == null || mbd.stale) { previous = mbd; if (bd.getParentName() == null) { // Use copy of given root bean definition. if (bd instanceof RootBeanDefinition) { mbd = ((RootBeanDefinition) bd).cloneBeanDefinition(); } else { mbd = new RootBeanDefinition(bd); } } else { // Child bean definition: needs to be merged with parent. BeanDefinition pbd; try { String parentBeanName = transformedBeanName(bd.getParentName()); if (!beanName.equals(parentBeanName)) { pbd = getMergedBeanDefinition(parentBeanName); } else { BeanFactory parent = getParentBeanFactory(); if (parent instanceof ConfigurableBeanFactory) { pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName); } else { throw new NoSuchBeanDefinitionException(parentBeanName, \\\"Parent name '\\\" + parentBeanName + \\\"' is equal to bean name '\\\" + beanName + \\\"': cannot be resolved without a ConfigurableBeanFactory parent\\\"); } } } catch (NoSuchBeanDefinitionException ex) { throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName, \\\"Could not resolve parent bean definition '\\\" + bd.getParentName() + \\\"'\\\", ex); } // Deep copy with overridden values. mbd = new RootBeanDefinition(pbd); mbd.overrideFrom(bd); } // Set default singleton scope, if not configured before. if (!StringUtils.hasLength(mbd.getScope())) { mbd.setScope(SCOPE_SINGLETON); } // A bean contained in a non-singleton bean cannot be a singleton itself. // Let's correct this on the fly here, since this might be the result of // parent-child merging for the outer bean, in which case the original inner bean // definition will not have inherited the merged outer bean's singleton status. if (containingBd != null && !containingBd.isSingleton() && mbd.isSingleton()) { mbd.setScope(containingBd.getScope()); } // Cache the merged bean definition for the time being // (it might still get re-merged later on in order to pick up metadata changes) if (containingBd == null && isCacheBeanMetadata()) { this.mergedBeanDefinitions.put(beanName, mbd); } } if (previous != null) { copyRelevantMergedBeanDefinitionCaches(previous, mbd); } return mbd; } } \"]},\"998\":{\"h\":\"Bean Class加载阶段\",\"t\":[\"ClassLoader类加载\",\"Java Security安全控制\",\"ConfigurableBeanFactory临时ClassLoader（场景比较有限）\",\"加载的核心代码代码：\",\" public Class<?> resolveBeanClass(@Nullable ClassLoader classLoader) throws ClassNotFoundException { String className = getBeanClassName(); if (className == null) { return null; } Class<?> resolvedClass = ClassUtils.forName(className, classLoader); this.beanClass = resolvedClass; return resolvedClass; } \",\"最开始的beanClass实际上是一个String类型，然后通过AppClassLoader加载到Class对象并赋值给beanClass这个属性，这个属性本身是一个Object类型的：\",\" @Nullable private volatile Object beanClass; \"]},\"999\":{\"h\":\"实例化\"},\"1000\":{\"h\":\"实例化前阶段\",\"t\":[\"非主流生命周期-Bena实例化前阶段\",\"InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation\",\"首先我们给出这个接口的使用示例：\",\"public class BeanInstantiationLifecycleDemo { public static void main(String[] args) { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); // 添加BeanPostProcesssor实现 beanFactory.addBeanPostProcessor(new MyInstantiationAwareBeanPostProcessor()); // 基于XML资源BeanDefinitionReader 实现 XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); String location = \\\"META-INF/dependency-lookup-context.xml\\\"; Resource resource = new ClassPathResource(location); EncodedResource encodedResource = new EncodedResource(resource, \\\"UTF-8\\\"); int beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(encodedResource); System.out.println(\\\"已加载的BeanDefinitiond的数量：\\\" + beanNumbers); // 不需要合并BeanDefinition User user = beanFactory.getBean(\\\"user\\\", User.class); System.out.println(user.toString()); // 需要合并BeanDefinition SuperUser superUser = beanFactory.getBean(\\\"SuperUser\\\", SuperUser.class); System.out.println(superUser.toString()); } static class MyInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor { @Override public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException { if (ObjectUtils.nullSafeEquals(\\\"SuperUser\\\",beanName) && SuperUser.class.equals(beanClass)) { // 把配置好的SuperUser Bean覆盖 return new SuperUser(); } return null; // 保持Spring IoC容器的实例化操作 } } } \",\"通过源码分析，可以看到postProcessBeforeInstantiation方法被调用之后返回了这个对象。\",\"protected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) { for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { Object result = bp.postProcessBeforeInstantiation(beanClass, beanName); if (result != null) { return result; } } return null; } \",\"通过调用关系，不难看出，在实例化Bean的时候，如果上述的方法返回的不是一个空对象，就直接返回，不在进行实例化的操作。\",\"Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) { return bean; } \"]},\"1001\":{\"h\":\"实例化阶段\",\"t\":[\"Spring中实例化方式：\",\"传统实例化方式 \",\"实例化策略 - InstantiationStrategy\",\"构造器注入\",\"传统的方式可以在AbstractAutowireCapableBeanFactory#instantiateBean\",\"beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, this); \",\"构造器注入，我们可以构造一个例子来进行测试：\",\"public class UserHolder { private final User user; @Override public String toString() { return \\\"UserHolder{\\\" + \\\"user=\\\" + user + '}'; } public UserHolder(User user) { this.user = user; } } \",\"可以在之前的例子上稍作修改：\",\"public class BeanInstantiationLifecycleDemo { public static void main(String[] args) { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); // 添加BeanPostProcesssor实现 beanFactory.addBeanPostProcessor(new MyInstantiationAwareBeanPostProcessor()); // 基于XML资源BeanDefinitionReader 实现 XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); String[] locations = {\\\"META-INF/dependency-lookup-context.xml\\\",\\\"META-INF/bean-constructor-dependency-injection.xml\\\"}; int beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(locations); System.out.println(\\\"已加载的BeanDefinitiond的数量：\\\" + beanNumbers); // 不需要合并BeanDefinition User user = beanFactory.getBean(\\\"user\\\", User.class); System.out.println(user.toString()); // 需要合并BeanDefinition SuperUser superUser = beanFactory.getBean(\\\"SuperUser\\\", SuperUser.class); System.out.println(superUser.toString()); // 构造器注入式按照类型注入，底层resolveDependency UserHolder userHolder = beanFactory.getBean(\\\"userHolder\\\", UserHolder.class); System.out.println(userHolder.toString()); } static class MyInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor { @Override public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException { if (ObjectUtils.nullSafeEquals(\\\"SuperUser\\\",beanName) && SuperUser.class.equals(beanClass)) { // 把配置好的SuperUser Bean覆盖 return new SuperUser(); } return null; // 保持Spring IoC容器的实例化操作 } } } \",\"这里我们可以总结一下，Bean的实例化主要有两种类型，并且使用构造器注入的时候，是按照类型来进行注入的，底层是使用的我们在依赖注入章节中介绍过的resolveDependency方法来实现的。\"]},\"1002\":{\"h\":\"Bean实例化后阶段\",\"t\":[\"对于Spring Bean实例化后阶段，我们可以理解为是Bean属性赋值（Populate）的判断：InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation。可以结合Bean实例化前阶段一起对照查看：\",\" static class MyInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor { @Override public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException { if (ObjectUtils.nullSafeEquals(\\\"SuperUser\\\", beanName) && SuperUser.class.equals(beanClass)) { // 把配置好的SuperUser Bean覆盖 return new SuperUser(); } return null; // 保持Spring IoC容器的实例化操作 } @Override public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException { if (ObjectUtils.nullSafeEquals(\\\"user\\\", beanName) && User.class.equals(bean.getClass())) { User user = (User) bean; user.setId(\\\"33\\\"); user.setName(\\\"jjjjjj\\\"); // \\\"user\\\"对象不允许属性赋值（填入）（配置元信息 -> 属性值） return false; } return true; } } \",\"这里相当于可以拦截掉所有的属性赋值，并且可以进行一些自定义的赋值，此时Bean的实例化已经完成了，但是属性赋值还没进行。\"]},\"1003\":{\"h\":\"属性赋值前阶段\",\"t\":[\"Bean属性值信息的类：\",\"PropertyValues\",\"Bean属性赋值前回调\",\"Spring1.2-5.0：InstantiationAwareBeanPostProcessor#postProcessPropertyValues\",\"Spring 5.1：InstantiationAwareBeanPostProcessor#postProcessProperties\",\"他们都是在BeanFactory赋值之前的回调操作，PropertyValues就是从配置文件里面读入的值，这个方法的作用就是可以修改从配置文件里面读入的值，默认情况下不做任何修改。\",\"default PropertyValues postProcessPropertyValues( PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException { return pvs; } \",\"需要注意的是，这里的返回值是null。\",\"default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException { return null; } \",\"还在在我们之前的例子上稍作修改：\",\" // 要注意如果postProcessAfterInstantiation返回的是false的话，这个方法不会被调用，因为相当于返回的Bean已经被替换了。 @Override public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException { if (ObjectUtils.nullSafeEquals(\\\"userHolder\\\", beanName) && UserHolder.class.equals(bean.getClass())) { // 假设<property name=\\\"number\\\" value=\\\"1\\\" />配置的话，那么在PropertyValues中就包含一个PropertyValues(number=1) final MutablePropertyValues propertyValues; if (pvs instanceof MutablePropertyValues) { propertyValues = (MutablePropertyValues) pvs; } else { propertyValues = new MutablePropertyValues(); } // 等价于<property name=\\\"number\\\" value=\\\"1\\\" /> propertyValues.addPropertyValue(\\\"number\\\", \\\"1\\\"); // if (propertyValues.contains(\\\"description\\\")) { // PropertyValue是不可变的 // PropertyValue description = propertyValues.getPropertyValue(\\\"description\\\"); propertyValues.removePropertyValue(\\\"description\\\"); propertyValues.addPropertyValue(\\\"description\\\", \\\"The user holder V2\\\"); } return propertyValues; } return null; } \",\"这里我们演示了两种情况，一种是number这个属性本来是没有值的，通过这个Api的拦截，我们手动给他赋上了值，而description这个属性，是我们在XML文件中，定义好了属性值，从结果来看，这个属性值也成功的被修改了。\",\"<bean id=\\\"userHolder\\\" class=\\\"org.jyc.thinking.in.spring.bean.lifecycle.UserHolder\\\" autowire=\\\"constructor\\\"> <!-- <property name=\\\"number\\\" value=\\\"1\\\"/>--> <property name=\\\"description\\\" value=\\\"The user holder\\\" /> </bean> \",\"修改后的UserHolder类：\",\"public class UserHolder { private final User user; private Integer number; private String description; public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public User getUser() { return user; } @Override public String toString() { return \\\"UserHolder{\\\" + \\\"user=\\\" + user + \\\", number=\\\" + number + \\\", description='\\\" + description + '\\\\'' + '}'; } public Integer getNumber() { return number; } public void setNumber(Integer number) { this.number = number; } public UserHolder(User user) { this.user = user; } } \",\"最后将准备好的pvs对象赋值给BeanWrapper：\",\"if (pvs != null) { applyPropertyValues(beanName, mbd, bw, pvs); } \"]},\"1004\":{\"h\":\"初始化\"},\"1005\":{\"h\":\"接口回调阶段\",\"t\":[\"Spring Aware接口：\",\"BeanNameAware\",\"BeanClassLoaderAware\",\"BeanFactoryAware\",\"EnvironmentAware\",\"EmbeddedValueResolverAware\",\"ResourceLoaderAware\",\"ApplicationEventPublisherAware\",\"MessageSourceAware\",\"ApplicationContextAware\",\"这里列出的顺序同时也是调用时候的顺序，这一点，源代码中也有体现：\",\"private void invokeAwareMethods(String beanName, Object bean) { if (bean instanceof Aware) { if (bean instanceof BeanNameAware) { ((BeanNameAware) bean).setBeanName(beanName); } if (bean instanceof BeanClassLoaderAware) { ClassLoader bcl = getBeanClassLoader(); if (bcl != null) { ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl); } } if (bean instanceof BeanFactoryAware) { ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); } } } \",\"另外一些相关的方法在ApplicationContextAwareProcessor#invokeAwareInterfaces：\",\"private void invokeAwareInterfaces(Object bean) { if (bean instanceof EnvironmentAware) { ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); } if (bean instanceof EmbeddedValueResolverAware) { ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver); } if (bean instanceof ResourceLoaderAware) { ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext); } if (bean instanceof ApplicationEventPublisherAware) { ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext); } if (bean instanceof MessageSourceAware) { ((MessageSourceAware) bean).setMessageSource(this.applicationContext); } if (bean instanceof ApplicationStartupAware) { ((ApplicationStartupAware) bean).setApplicationStartup(this.applicationContext.getApplicationStartup()); } if (bean instanceof ApplicationContextAware) { ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext); } } \",\"但是第二部分的回调接口无法通过BeanFacotry的方式得到回调，我们需要对之前的代码进行一定的重构：\",\"public class BeanInstantiationLifecycleDemo { public static void main(String[] args) { executeBeanFactory(); System.out.println(\\\"=============\\\"); executApplicationContext(); } public static void executeBeanFactory() { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); // 方法一：添加BeanPostProcesssor实现InstantiationAwareBeanPostProcessor // 方法二：将MyInstantiationAwareBeanPostProcessor作为Bean注册 // beanFactory.addBeanPostProcessor(new MyInstantiationAwareBeanPostProcessor()); // 基于XML资源BeanDefinitionReader 实现 XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); String[] locations = {\\\"META-INF/dependency-lookup-context.xml\\\", \\\"META-INF/bean-constructor-dependency-injection.xml\\\"}; int beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(locations); System.out.println(\\\"已加载的BeanDefinitiond的数量：\\\" + beanNumbers); // 不需要合并BeanDefinition User user = beanFactory.getBean(\\\"user\\\", User.class); System.out.println(user.toString()); // 需要合并BeanDefinition SuperUser superUser = beanFactory.getBean(\\\"SuperUser\\\", SuperUser.class); System.out.println(superUser.toString()); // 构造器注入式按照类型注入，底层resolveDependency UserHolder userHolder = beanFactory.getBean(\\\"userHolder\\\", UserHolder.class); System.out.println(userHolder.toString()); } public static void executApplicationContext() { ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(); String[] locations = {\\\"META-INF/dependency-lookup-context.xml\\\", \\\"META-INF/bean-constructor-dependency-injection.xml\\\"}; applicationContext.setConfigLocations(locations); applicationContext.refresh(); User user = applicationContext.getBean(\\\"user\\\", User.class); System.out.println(user.toString()); SuperUser superUser = applicationContext.getBean(\\\"SuperUser\\\", SuperUser.class); System.out.println(superUser.toString()); UserHolder userHolder = applicationContext.getBean(\\\"userHolder\\\", UserHolder.class); System.out.println(userHolder.toString()); applicationContext.close(); } } \",\"在XML文件中，注入MyInstantiationAwareBeanPostProcessor：\",\"<bean class=\\\"org.jyc.thinking.in.spring.bean.lifecycle.MyInstantiationAwareBeanPostProcessor\\\" /> \",\"我们可以在UserHolder中实现这些接口，进行观察：\",\"public class UserHolder implements BeanNameAware, BeanClassLoaderAware, BeanFactoryAware, EnvironmentAware { private final User user; private Integer number; private String description; private ClassLoader classLoader; private BeanFactory beanFactory; private String beanName; private Environment environment; public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public User getUser() { return user; } @Override public String toString() { return \\\"UserHolder{\\\" + \\\"user=\\\" + user + \\\", number=\\\" + number + \\\", description='\\\" + description + '\\\\'' + \\\", beanName='\\\" + beanName + '\\\\'' + '}'; } public Integer getNumber() { return number; } public void setNumber(Integer number) { this.number = number; } public UserHolder(User user) { this.user = user; } @Override public void setBeanClassLoader(ClassLoader classLoader) { this.classLoader = classLoader; } @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException { this.beanFactory = beanFactory; } @Override public void setBeanName(String name) { this.beanName = name; } @Override public void setEnvironment(Environment environment) { this.environment = environment; } } \",\"不难发现，通过BeanFacotry的方式，无法获取到EnvironmentAware对象的回调，而ApplicationContext则可以，这是因为在AbstractApplicationContext#prepareBeanFactory中，BeanFactory注册了ApplicationContextAwareProcessor这个接口：\",\"beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); \",\"而我们前面提到过，第二部分的接口的回调，需要执行ApplicationContextAwareProcessor#invokeAwareInterfaces方法，而ApplicationContextAwareProcessor又是一个非public的类，因此，在我们创建的BeanFactory无法操作这个类。总来的来说，通过BeanFactory可以获取到BeanNameAware、BeanClassLoaderAware、BeanFactoryAware这三个接口的回调，而如果使用AppliactionContext来进行操作，就可以获取到更多的回调，这也从另一个角度说明了AppliacitonContext和BeanFactory的区别。\"]},\"1006\":{\"h\":\"初始化前阶段\",\"t\":[\"方法回调：\",\"BeanPostProcessor#postProcessBeforeInitialization\",\"因为InstantiationAwareBeanPostProcessor继承了BeanPostProcessor，因此我们还是调整MyInstantiationAwareBeanPostProcessor的方法来进行观察：\",\" @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { if (ObjectUtils.nullSafeEquals(\\\"userHolder\\\", beanName) && UserHolder.class.equals(bean.getClass())) { UserHolder userHolder = (UserHolder) bean; userHolder.setDescription(\\\"The user holder V3\\\"); return userHolder; } return null; } \",\"为了跟前面加以区别，这里我们增加一个调用的示例：\",\"public class BeanInitilzationLifecycleDemo { public static void main(String[] args) { executeBeanFactory(); } public static void executeBeanFactory() { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); // 方法一：添加BeanPostProcesssor实现InstantiationAwareBeanPostProcessor // 方法二：将MyInstantiationAwareBeanPostProcessor作为Bean注册 beanFactory.addBeanPostProcessor(new MyInstantiationAwareBeanPostProcessor()); // 基于XML资源BeanDefinitionReader 实现 XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); String[] locations = {\\\"META-INF/dependency-lookup-context.xml\\\", \\\"META-INF/bean-constructor-dependency-injection.xml\\\"}; int beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(locations); System.out.println(\\\"已加载的BeanDefinitiond的数量：\\\" + beanNumbers); // 不需要合并BeanDefinition User user = beanFactory.getBean(\\\"user\\\", User.class); System.out.println(user.toString()); // 需要合并BeanDefinition SuperUser superUser = beanFactory.getBean(\\\"SuperUser\\\", SuperUser.class); System.out.println(superUser.toString()); // 构造器注入式按照类型注入，底层resolveDependency UserHolder userHolder = beanFactory.getBean(\\\"userHolder\\\", UserHolder.class); System.out.println(userHolder.toString()); } } \",\"可以看到userHolder的description属性成功的变成了v3，相关的源码的实现在AbstractAutowireCapableBeanFactory#pplyBeanPostProcessorsBeforeInitialization：\",\" @Override public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException { Object result = existingBean; for (BeanPostProcessor processor : getBeanPostProcessors()) { Object current = processor.postProcessBeforeInitialization(result, beanName); if (current == null) { return result; } // 可能返回的是一个代理对象，并不是原有的对象 result = current; } return result; } \"]},\"1007\":{\"h\":\"初始化阶段\",\"t\":[\"在之前，我们有提到过Bean初始化操作：\",\"@PostConstruct标注方法\",\"实现InitializingBean接口的afterPropertiesSet()方法\",\"自定义初始化方法\",\"@PostConstruct标注方法需要注解驱动，因为这种方式需要依赖于ApplicationContext的，并且所依赖的ApplicationContext是需要有注解驱动能力的。\",\"我们在UserHolder中添加它的初始化方法：\",\" /** * 依赖于注解驱动，当前场景：BeanFactory，因此直接运行，并不会执行 */ @PostConstruct public void initPostConstruct() { this.description = \\\"The user holder V4\\\"; System.out.println(\\\"initPostConstruct() = \\\" + description); } @Override public void afterPropertiesSet() throws Exception { this.description = \\\"The user holder V5\\\"; System.out.println(\\\"afterPropertiesSet() = \\\" + description); } public void init() { this.description = \\\"The user holder V6\\\"; System.out.println(\\\"init() = \\\" + description); } \",\"这里因为我们是BeanFactory的场景，因此需要手动添加：\",\" beanFactory.addBeanPostProcessor(new CommonAnnotationBeanPostProcessor()); \",\"相应的源码在AbstractAutowireCapableBeanFactory#invokeInitMethods方法当中：\",\"protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd) throws Throwable { // afterPropertiesSet方法： boolean isInitializingBean = (bean instanceof InitializingBean); if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod(\\\"afterPropertiesSet\\\"))) { if (logger.isTraceEnabled()) { logger.trace(\\\"Invoking afterPropertiesSet() on bean with name '\\\" + beanName + \\\"'\\\"); } if (System.getSecurityManager() != null) { try { AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> { ((InitializingBean) bean).afterPropertiesSet(); return null; }, getAccessControlContext()); } catch (PrivilegedActionException pae) { throw pae.getException(); } } else { ((InitializingBean) bean).afterPropertiesSet(); } } // 自定义初始化方法 if (mbd != null && bean.getClass() != NullBean.class) { String initMethodName = mbd.getInitMethodName(); if (StringUtils.hasLength(initMethodName) && !(isInitializingBean && \\\"afterPropertiesSet\\\".equals(initMethodName)) && !mbd.isExternallyManagedInitMethod(initMethodName)) { invokeCustomInitMethod(beanName, bean, mbd); } } } \"]},\"1008\":{\"h\":\"初始化后阶段\",\"t\":[\"方法的回调：\",\"BeanPostProcessor#postProcessAfterInitialization\",\"还是对我们的MyInstantiationAwareBeanPostProcessor进行添加：\",\" @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { if (ObjectUtils.nullSafeEquals(\\\"userHolder\\\", beanName) && UserHolder.class.equals(bean.getClass())) { UserHolder userHolder = (UserHolder) bean; userHolder.setDescription(\\\"The user holder V7\\\"); return userHolder; } return null; } \",\"总的来说，关于Bean的初始化操作，总共可以分为下面几个阶段：\",\" protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) { if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction<Object>) () -> { invokeAwareMethods(beanName, bean); return null; }, getAccessControlContext()); } else { // 接口回调 invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { // 初始化前方法 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } try { // 初始化方法 invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, \\\"Invocation of init method failed\\\", ex); } if (mbd == null || !mbd.isSynthetic()) { // 初始化后方法 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean; } \"]},\"1009\":{\"h\":\"初始化完成阶段\",\"t\":[\"方法回调：\",\"SmartInitializingSingleton#afterSingletonsInstantiated\",\"同样的，还是操作Userholder类：\",\" @Override public void afterSingletonsInstantiated() { this.description = \\\"The user holder V8\\\"; System.out.println(\\\"afterSingletonsInstantiated() = \\\" + description); } \",\"直接去运行，发现并没有打印出我们预期的结果，这是因为这个方法调用的地方在DefaultListableBeanFactory#preInstantiateSingletons，而这个方法需要显示的调用才会执行：\",\" // SmartInitializingSingleton 通常在Spring AppliactionContext场景使用 // preInstantiateSingletons将已注册的BeanDefinition初始化成Spring Bean beanFactory.preInstantiateSingletons(); \",\"在AbstractApplicationContext#finishBeanFactoryInitialization方法中，我们可以看到这里就调用了preInstantiateSingletons方法：\",\"protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) { // Instantiate all remaining (non-lazy-init) singletons. beanFactory.preInstantiateSingletons(); } \",\"提供这个方法的主要原因是之前的BeanPostProcessor接口提供的回调，可能Bean会存在初始化不完全的情况，使用这个方法的时候就不用担心有Bean初始化不完全的情况发生。\"]},\"1010\":{\"h\":\"销毁阶段\"},\"1011\":{\"h\":\"销毁前阶段\",\"t\":[\"方法回调：\",\"DestructionAwareBeanPostProcessor#postProcessBeforeDestruction\",\"实现一下这个接口：\",\"public class MyDestructionAwareBeanPostProcessor implements DestructionAwareBeanPostProcessor { @Override public void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException { if (ObjectUtils.nullSafeEquals(\\\"userHolder\\\", beanName) && UserHolder.class.equals(bean.getClass())) { UserHolder userHolder = (UserHolder) bean; userHolder.setDescription(\\\"The user holder V9\\\"); } } } \",\"关于Bean生命周期的完整的演示示例：\",\"public class BeanLifeCycleDemo { public static void main(String[] args) { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); // 方法一：添加BeanPostProcesssor实现InstantiationAwareBeanPostProcessor // 方法二：将MyInstantiationAwareBeanPostProcessor作为Bean注册 beanFactory.addBeanPostProcessor(new MyInstantiationAwareBeanPostProcessor()); beanFactory.addBeanPostProcessor(new CommonAnnotationBeanPostProcessor()); // 添加MyDestructionAwareBeanPostProcessor执行销毁前回调 beanFactory.addBeanPostProcessor(new MyDestructionAwareBeanPostProcessor()); // 基于XML资源BeanDefinitionReader 实现 XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); String[] locations = {\\\"META-INF/dependency-lookup-context.xml\\\", \\\"META-INF/bean-constructor-dependency-injection.xml\\\"}; int beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(locations); System.out.println(\\\"已加载的BeanDefinitiond的数量：\\\" + beanNumbers); beanFactory.preInstantiateSingletons(); // 不需要合并BeanDefinition User user = beanFactory.getBean(\\\"user\\\", User.class); System.out.println(user.toString()); // 需要合并BeanDefinition SuperUser superUser = beanFactory.getBean(\\\"SuperUser\\\", SuperUser.class); System.out.println(superUser.toString()); // 构造器注入式按照类型注入，底层resolveDependency UserHolder userHolder = beanFactory.getBean(\\\"userHolder\\\", UserHolder.class); // SmartInitializingSingleton 通常在Spring AppliactionContext场景使用 System.out.println(userHolder.toString()); beanFactory.destroyBean(\\\"userHolder\\\", userHolder); // Bean销毁并不意味这Bean垃圾回收了 System.out.println(userHolder.toString()); } } \",\"特别需要注意的是，这里的销毁并不是这个对象被GC掉了，GC和Bean的销毁是两个不同的概念。\"]},\"1012\":{\"h\":\"销毁阶段\",\"t\":[\"Bean销毁（Destory）：\",\"@PreDestory标注方法\",\"实现DisposableBean接口的destory()方法\",\"自定义销毁方法\",\" @PreDestroy public void preDestory() { this.description = \\\"The user holder V10\\\"; System.out.println(\\\"PreDestroy() = \\\" + description); } @Override public void destroy() throws Exception { this.description = \\\"The user holder V11\\\"; System.out.println(\\\"PreDestroy() = \\\" + description); } public void doDestory() { this.description = \\\"The user holder V12\\\"; System.out.println(\\\"PreDestroy() = \\\" + description); } \",\"在XML中指定自定义的销毁方法：\",\"<bean id=\\\"userHolder\\\" class=\\\"org.jyc.thinking.in.spring.bean.lifecycle.UserHolder\\\" autowire=\\\"constructor\\\" init-method=\\\"init\\\" destroy-method=\\\"doDestory\\\"> <!-- <property name=\\\"number\\\" value=\\\"1\\\"/>--> <property name=\\\"description\\\" value=\\\"The user holder\\\" /> </bean> \",\"在BeanFactory场景下还是需要手动进行调用，而在ApplicationContext中，是会自动调用的：\",\"beanFactory.destroyBean(\\\"userHolder\\\", userHolder); \"]},\"1013\":{\"h\":\"Bean垃圾收集\",\"t\":[\"Bean垃圾回收（GC）的过程：\",\"关闭Spring容器（应用上下文）\",\"执行GC\",\"Spring Bean覆盖的finalize()方法被回调\",\"首先在UserHolder中重写finalize()方法：\",\"@Override protected void finalize() throws Throwable { System.out.println(\\\"UserHolder is finalized ...\\\"); super.finalize(); } \",\"然后执行销毁方法：\",\" // 销毁BeanFactory中的单例Bean beanFactory.destroySingletons(); // 强制GC System.gc(); // 等待一段时间 try { Thread.sleep(3000); } catch (InterruptedException exception) { exception.printStackTrace(); } System.gc(); \"]},\"1014\":{\"h\":\"面试题\"},\"1015\":{\"h\":\"BeanPostProcess使用场景有哪些？\",\"t\":[\"BeanPostProcess提供了Spring Bean初始化前和初始化后的生命周期回调，分别对应postProcessBeforeInitialization以及postProcessAfterInitialization方法，允许对关心的Bean进行扩展，甚至是替换，\",\"其中ApplicationContext相关的Aware回调也是基于BeanPostProcess实现，即ApplicationContextAwareProcessor。\"]},\"1016\":{\"h\":\"BeanFactoryPostProcess与BeanPostProcess的区别\",\"t\":[\"BeanFactroyPostProcessor是Spring BeanFacrtory（实际为ConfigurableListableBeanFactory）的后置处理器，用于扩展BeanFacotry，或通过BeanFactory进行依赖查找和依赖注入。\",\"BeanFactroyPostProcessor必须有Spring ApplicationContext执行，BeanFactory无法与其直接交互。而BeanPostProcess直接与BeanFactory关联，属于N对1的关系。\"]},\"1017\":{\"h\":\"BeanFactory是怎样处理Bean生命周期？\",\"t\":[\"BeanFactory的默认实现为DefaultListableBeanFactory，其中Bean生命周期与方法映射如下：\",\"BeanDefinition注册阶段 - regsiterBeanDefinition\",\"BeanDefinition合并阶段 - getMergedBeanDefinition\",\"Bean实例化前阶段 - resolveBeforeInstantiation\",\"Bean实例化阶段 - createBeanInstance\",\"Bean实例化后阶段- populateBean\",\"Bean属性赋值前阶段 - populateBean\",\"Bean属性赋值阶段 - populateBean\",\"Bean Aware接口回调阶段 - initializeBean\",\"Bean初始化前阶段- initializeBean\",\"Bean初始化阶段- initializeBean\",\"Bean初始化后阶段- initializeBean\",\"Bean初始化完成阶段 - preInstantiateSingtons\",\"Bean销毁前阶段- destoryBean\",\"Bean销毁阶段 - destoryBean\",\"配置元信息主要可以分为以下五个方面：\",\"Spring Bean配置元信息 - BeanDefinition\",\"Spring Bean属性元信息 - PropertyValues\",\"Spring 容器配置元信息\",\"Spring 外部化配置元信息 - PropertySource\",\"Spring Profile 元信息 - @Profile\"]},\"1018\":{\"h\":\"Spring Bean配置元信息\",\"t\":[\"Bean的配置元信息 - BeanDefinition主要包括了：\",\"GenericBeanDefinition：通用型BeanDefinition\",\"RootBeanDefinition：无parent的BeanDefinition或者合并后BeanDefinition\",\"AnnotatedBeanDefinition：注解标注的BeanDefinition\",\"AnnotatedBeanDefinition中的AnnotationMetadata有两种具体的实现，StandardAnnotationMetadata是基于Java注解实现的，SimpleAnnotationMetadata是基于ASM实现的。\"]},\"1019\":{\"h\":\"Spring Bean属性元信息\",\"t\":[\"Bean属性元信息 - PropertyValues \",\"可修改实现 - MutablePropertyValues\",\"元素成员 - PropertyValue\",\"Bean属性上下文存储 - AttributeAccessor\",\"Bean元信息元素 - BeanMetadataElement\",\"其中第一种我们已经见过很多次了，这里主要演示第二种和第三种。\",\"public class BeanConfigurationMetadataDemo { public static void main(String[] args) { // BeanDefinition 的定义（声明） BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class); beanDefinitionBuilder.addPropertyValue(\\\"name\\\", \\\"jycoder\\\"); // 获取AbstractBeanDefinition AbstractBeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition(); // 声明BeanDefinition // 附件属性(不影响Bean 实例化、属性赋值、初始化) beanDefinition.setAttribute(\\\"name\\\", \\\"jiyongchao\\\"); // 当前BeanDefinition来自何方,也是起存储的作用 beanDefinition.setSource(BeanConfigurationMetadataDemo.class); DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); beanFactory.addBeanPostProcessor(new BeanPostProcessor() { @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { if (ObjectUtils.nullSafeEquals(\\\"user\\\", beanName) && User.class.equals(bean.getClass())) { BeanDefinition bd = beanFactory.getBeanDefinition(beanName); if (BeanConfigurationMetadataDemo.class.equals(bd.getSource())) { // 通过source来判断 // TODO } // 属性（存储）上下文 String name = (String) bd.getAttribute(\\\"jiyongchao\\\"); // 这里的name就是jiyongchao User user = (User) bean; user.setName(name); } return null; } }); beanFactory.registerBeanDefinition(\\\"user\\\", beanDefinition); User user = beanFactory.getBean(\\\"user\\\", User.class); System.out.println(user); } } \"]},\"1020\":{\"h\":\"Spring容器配置元信息\",\"t\":[\"Spring XML配置元信息 - Beans元素相关\",\"Beans元素属性\",\"默认直\",\"使用场景\",\"profile\",\"null（留空）\",\"Spring Profiles配置值\",\"default-lazt-init\",\"default\",\"当outter beans \\\"default-lazy-init\\\"属性存在时，继承该值，否则为\\\"false\\\"\",\"default-merge\",\"default\",\"当outter beans \\\"default-merge\\\"属性存在时，继承该值，否则为\\\"false\\\"\",\"default-autowire\",\"default\",\"当outter beans \\\"default-autowire\\\"属性存在时，继承该值，否则为\\\"false\\\"\",\"default-autowire-candidates\",\"null（留空）\",\"默认Spring Beans 名称pattern\",\"default-init-method\",\"null（留空）\",\"默认Spring Beans 自定义初始化方法\",\"default-destory-method\",\"null（留空）\",\"默认Spring Beans 自定义销毁方法\",\"outter beans指的是在XML文件中通过import导入资源的方法注册Bean，导入方就是外部，被导入方就是内部。\",\"Spring XML配置元信息 - 应用上下文\",\"XML元素\",\"使用场景\",\"<context:annotation-config />\",\"激活Spring注解驱动\",\"<context:componenet-scan />\",\"Spring@Component以及自定义注解扫描\",\"<context:load-time-weaver />\",\"激活Spring LoadTimeWeaver\",\"<context:mbean-export />\",\"暴露Spring Beans作为JMX Beans\",\"<context:mbean-server />\",\"将当前平台作为MBeanServer\",\"<context:property-placeholder />\",\"加载外部化配置资源作为Spring属性配置\",\"<context:property-override />\",\"利用外部化配置资源覆盖Spring属性值\",\"mbean：Java Management Extensions\",\"关于Beans的元素相关的配置可以在BeanDefinitionParserDelegate#populateDefaults中看到。\"]},\"1021\":{\"h\":\"基于XML资源装载Spring Bean配置元信息\",\"t\":[\"Spring Bean配置元信息\",\"XML元素\",\"使用场景\",\"<beans:beans />\",\"单XML资源下的多个Spring Beans配置\",\"<beans:bean />\",\"单个Spring Bean定义（BeanDefinition）配置\",\"<beans:alias />\",\"为Spring Bean定义（BeanDefinition）映射别名\",\"<beans:import />\",\"加载外部Spring XML配置资源\",\"通常情况下我们会使用默认的namespace，这里使用beans来更加明确的说明，这里的底层实现都是XmlBeanDefinitionReader。\",\"装在的核心方法在XmlBeanDefinitionReader#registerBeanDefinitions：\",\"public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore; } \"]},\"1022\":{\"h\":\"基于Properties资源装载Spring Bean配置元信息\",\"t\":[\"Spring Bean 配置元信息\",\"Properties属性名\",\"使用场景\",\"(class)\",\"Bean类全称限定名\",\"(abstract)\",\"是否为抽象的BeanDefinition\",\"(parent)\",\"指定parent BeanDefinition名称\",\"(lazy-init)\",\"是否为延迟初始化\",\"(ref)\",\"应用其他Bean的名称\",\"(scope)\",\"设置Bean的scope属性\",\"${n}\",\"n表示第n+1个构造器参数\",\"底层实现：PropertiesBeanDefinitionReader\",\"接下来我们定义一个properties文件：\",\"# User BeanDefinition 定义 user.(class) = org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User user.id = 1 user.name = jiyongchao user.city = HANGZHOU \",\"尝试获取解析：\",\"public class PropertiesBeanDefinitionReaderDemo { public static void main(String[] args) { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); PropertiesBeanDefinitionReader beanDefinitionReader = new PropertiesBeanDefinitionReader(beanFactory); String location = \\\"classpath:/META-INF/users-config-definitions.properties\\\"; // 默认通过ISO-8859-1 ResourceLoader resourceLoader = new DefaultResourceLoader(); // 通过指定的Classpath获取Resource对象 Resource resource = resourceLoader.getResource(location); // 转换成带字符编码的EncodedResource对象 EncodedResource encodedResource = new EncodedResource(resource, \\\"UTF-8\\\"); int i = beanDefinitionReader.loadBeanDefinitions(encodedResource); System.out.printf(\\\"已加载%d 个BeanDefinition\\\\n\\\", i); User user = beanFactory.getBean(User.class); System.out.println(user); } } \",\"相关核心代码在PropertiesBeanDefinitionReader#loadBeanDefinitions：\",\" public int loadBeanDefinitions(EncodedResource encodedResource, @Nullable String prefix) throws BeanDefinitionStoreException { if (logger.isTraceEnabled()) { logger.trace(\\\"Loading properties bean definitions from \\\" + encodedResource); } Properties props = new Properties(); try { try (InputStream is = encodedResource.getResource().getInputStream()) { if (encodedResource.getEncoding() != null) { getPropertiesPersister().load(props, new InputStreamReader(is, encodedResource.getEncoding())); } else { getPropertiesPersister().load(props, is); } } int count = registerBeanDefinitions(props, prefix, encodedResource.getResource().getDescription()); if (logger.isDebugEnabled()) { logger.debug(\\\"Loaded \\\" + count + \\\" bean definitions from \\\" + encodedResource); } return count; } catch (IOException ex) { throw new BeanDefinitionStoreException(\\\"Could not parse properties from \\\" + encodedResource.getResource(), ex); } } \",\"使用properties的方式读取BeanDefinition的时候，如果出现Bean重复定义的情况，Spring会忽略后面定义的Bean的相关信息。\"]},\"1023\":{\"h\":\"基于Java注解的Spring Bean配置元信息\",\"t\":[\"Spring模式注解：\",\"Spring注解\",\"场景说明\",\"起始版本\",\"@Repository\",\"数据仓储模式注解\",\"2.0\",\"@Component\",\"通用组件模式注解\",\"2.5\",\"@Service\",\"服务模式注解\",\"2.5\",\"@Controller\",\"Web控制器模式注解\",\"2.5\",\"@Configuration\",\"配置类模式注解\",\"3.0\",\"由于注解是不能集成的，所以采用元注解（元标注的方式来实现），其他注解都可以看成是@Component的\\\"派生\\\"注解。\",\"Spring Bean依赖注入注解：\",\"Spring注解\",\"场景说明\",\"起始版本\",\"@Autowired\",\"Bean依赖注入，支持多种依赖查找的方式\",\"2.5\",\"@Qualifier\",\"细粒度的@Autowired依赖查找\",\"2.5\",\"Java注解\",\"场景说明\",\"起始版本\",\"@Resource\",\"类似于@Autowired\",\"2.5\",\"@Inject\",\"类似于@Autowired\",\"2.5\",\"Spring Bean条件装配注解：\",\"Spring注解\",\"场景说明\",\"起始版本\",\"@Profile\",\"配置化条件装配\",\"3.1\",\"@Conditional\",\"编程条件装配\",\"4.0\",\"我们可以看一下@Profile注解的@Conditional：\",\"class ProfileCondition implements Condition { @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if (attrs != null) { for (Object value : attrs.get(\\\"value\\\")) { if (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) { return true; } } return false; } return true; } } \",\"最后是Spring Bean声明周期回调注解：\",\"Spring注解\",\"场景说明\",\"起始版本\",\"@PostConstruct\",\"替换XML标签或者实现接口\",\"2.5\",\"@PreDestory\",\"替换XML标签或者实现接口\",\"2.5\"]},\"1024\":{\"h\":\"Spring Bean配置元信息底层实现\",\"t\":[\"Spring BeanDefinition解析与注册的方式：\",\"实现场景\",\"实现类\",\"起始版本\",\"XML资源\",\"XmlBeanDefinitionReader\",\"1.0\",\"Properties\",\"PropertiesBeanDefinitionReader\",\"1.0\",\"Java注解\",\"AnnotatedBeanDefinitionReader\",\"3.0\",\"需要注意的是AnnotatedBeanDefinitionReader与BeanDefinition并没有任何直接的关系，而XmlBeanDefinitionReader和PropertiesBeanDefinitionReader都继承了AbstractBeanDefinitionReader。\"]},\"1025\":{\"h\":\"XML资源的方式\",\"t\":[\"Spring XML资源BeanDefinition解析与注册：\",\"核心API - XmlBeanDefinitionReader\",\"底层 - BeanDefinitionDocumentReader \",\"XML解析 - Java DOM Level 3 API\",\"BeanDefinition 解析 - BeanDefinitionParserDelegate\",\"BeanDefinition注册 - BeanDefinitionRegistry\",\"BeanDefinitionDocumentReader有且仅有一个实现，DefaultBeanDefinitionDocumentReader，它里面的preProcessXml和postProcessXml方法都是空实现，可以让我们在加载XML资源的前后做一些自定义的操作，使用的时候只需要继承DefaultBeanDefinitionDocumentReader，然后设置XmlBeanDefinitionReader所使用的加载类。\",\"private Class<? extends BeanDefinitionDocumentReader> documentReaderClass = DefaultBeanDefinitionDocumentReader.class; \"]},\"1026\":{\"h\":\"Properties资源的方式\",\"t\":[\"Spring Properties资源BeanDefinition解析与注册：\",\"核心API - PropertiesBeanDefinitionReader \",\"资源 \",\"字节流 - Resource\",\"字符流 - EncodedResource\",\"底层 \",\"存储 - java.util.Properties\",\"BeanDefinition解析 - API内部实现\",\"BeanDefinition注册 - BeanDefinitionRegistry\",\"通过这种方式装在的Bean的名称就是\\\".\\\"之前的字符。\"]},\"1027\":{\"h\":\"Java注解的方式\",\"t\":[\"Spring Java注册BeanDefintiion解析与注册：\",\"核心API - AnnotatedBeanDefinitionReader \",\"资源 \",\"类对象 - java.lang.Class\",\"底层 \",\"条件评估 - ConditionEvaluator\",\"Bean范围解析 - ScopeMetadataResolver\",\"BeanDefinition解析 - 内部API实现\",\"BeanDefinition处理 - AnnotationConfigUtils.processCommonDefinitionAnnotations\",\"BeanDefinition注册 - BeanDefinitionRegistry\",\"实现的核心源代码：\",\"private <T> void doRegisterBean(Class<T> beanClass, @Nullable String name, @Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier, @Nullable BeanDefinitionCustomizer[] customizers) { AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass); if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) { return; } abd.setInstanceSupplier(supplier); ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd); abd.setScope(scopeMetadata.getScopeName()); String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry)); // 如果Bean上面有@Lazy或者@Primary等等，这个方法会把相关的信息赋值给BeanDefinition AnnotationConfigUtils.processCommonDefinitionAnnotations(abd); if (qualifiers != null) { for (Class<? extends Annotation> qualifier : qualifiers) { if (Primary.class == qualifier) { abd.setPrimary(true); } else if (Lazy.class == qualifier) { abd.setLazyInit(true); } else { abd.addQualifier(new AutowireCandidateQualifier(qualifier)); } } } if (customizers != null) { for (BeanDefinitionCustomizer customizer : customizers) { customizer.customize(abd); } } BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry); } \"]},\"1028\":{\"h\":\"基于XML资源装载Spring 容器配置元信息\",\"t\":[\"Spring IoC容器相关XML配置：\",\"命名空间\",\"所属模块\",\"Schema资源URL\",\"beans\",\"spring-beans\",\"http://www.springframework.org/schema/beans/spring-beans.xsd\",\"context\",\"spring-context\",\"http://www.springframework.org/schema/context/beans/spring-context.xsd\",\"aop\",\"spring-aop\",\"http://www.springframework.org/schema/aop/spring-aop.xsd\",\"tx\",\"spring-tx\",\"http://www.springframework.org/schema/tx/spring-tx.xsd\",\"util\",\"spring-util\",\"http://www.springframework.org/schema/util/spring-util.xsd\",\"tool\",\"spring-beans\",\"http://www.springframework.org/schema/tool/spring-tool.xsd\",\"如果需要支持事务，需要单独引入spring-tx。\"]},\"1029\":{\"h\":\"基于Java注解配置Spring 容器配置元信息\",\"t\":[\"Spring IoC容器装配注解：\",\"Spring注解\",\"场景说明\",\"起始版本\",\"@ImportResource\",\"替换XML元素\",\"3.0\",\"@Import\",\"导入Configuration Class\",\"3.0\",\"@ComponenetScan\",\"扫描指定package下标注Spring模式注解的类\",\"3.1\",\"相关的示例：\",\"@ImportResource(\\\"classpath:/META-INF/dependency-lookup-context.xml\\\") @Import(User.class) public class AnnotatedSpringIoCContainerConfigurationDemo { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(AnnotatedSpringIoCContainerConfigurationDemo.class); context.refresh(); Map<String, User> userMap = context.getBeansOfType(User.class); for (Map.Entry<String, User> entry : userMap.entrySet()) { System.out.printf(\\\"User Bean name:%s,content: %s \\\\n\\\", entry.getKey(), entry.getValue()); } context.close(); } } \",\"Spring IoC配置属性注解：\",\"Spring注解\",\"场景说明\",\"起始版本\",\"@PropertySource\",\"配置属性抽象PropertySource注解\",\"3.1\",\"@PropertySources\",\"@PropertySource集合注解\",\"4.0\",\"@PropertySource(\\\"classpath:/META-INF/users-config-definitions.properties\\\") //Java8 + @Repeatable @PropertySource(\\\"classpath:/META-INF/users-config-definitions.properties\\\") //@PropertySources(@PropertySource(value = \\\"1\\\")) \"]},\"1030\":{\"h\":\"基于Extensible XML authoring扩展Spring XML元素\",\"t\":[\"Spring XML扩展的步骤：\",\"编写XML Schema文件：定义XML结构\",\"自定义NamespaceHandler实现：命名空间绑定\",\"定义BeanDefinitionParser实现：XML元素与BeanDefinition解析\",\"注册XML扩展：命名空间与XML Schema映射\",\"定义XML结构：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:users=\\\"http://jycoder.org/schema/users\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://jycoder.org/schema/users\\\"> <users:user id=\\\"1\\\" name=\\\"jiyongchao\\\" city=\\\"SHANGHAI\\\" /> </beans> \",\"命名空间绑定：\",\"public class UsersNamespaceHandler extends NamespaceHandlerSupport { @Override public void init() { // 将\\\"user\\\"元素注册对应的BeanDefinitionParser实现 registerBeanDefinitionParser(\\\"user\\\",new UserBeanDefinitionParser()); } } \",\"XML元素与BeanDefinition解析：\",\"public class UserBeanDefinitionParser extends AbstractSingleBeanDefinitionParser { @Override protected Class<?> getBeanClass(Element element) { return User.class; } @Override protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) { setPropertyValue(\\\"id\\\", element, builder); setPropertyValue(\\\"name\\\", element, builder); setPropertyValue(\\\"City\\\", element, builder); } private void setPropertyValue(String attributeName, Element element, BeanDefinitionBuilder builder) { String attributeValue = element.getAttribute(attributeName); if (StringUtils.hasText(attributeValue)) { builder.addPropertyValue(attributeName, attributeValue); } } } \",\"命名空间与XML Schema映射：\",\"#定义namespacehanlder http\\\\://jycoder.org/schema/users=org.jyc.thinking.in.spring.bean.metadata.UsersNamespaceHandler \",\"http\\\\://jycoder.org/schema/users.xsd=org/jyc/thinking/in/spring/bean/metadata/users.xsd \",\"测试我们编写的案例：\",\"public class ExtensibleXmlAuthoringDemo { public static void main(String[] args) { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory); reader.loadBeanDefinitions(\\\"classpath:/META-INF/users-context.xml\\\"); // 获取User Bean对象 User user = beanFactory.getBean(User.class); System.out.println(user); } } \"]},\"1031\":{\"h\":\"基于Properties资源装载外部化配置\",\"t\":[\"注解驱动： \",\"org.springframework.context.annotation.PropertySource\",\"org.springframework.context.annotation.PropertySources\",\"API编程： \",\"org.springframework.core.env.PropertySource\",\"org.springframework.core.env.PropertySources\",\"@PropertySource(\\\"classpath:/META-INF/users-config-definitions.properties\\\") public class PropertySourceDemo { @Bean public User user(@Value(\\\"${user.id}\\\") String id, @Value(\\\"${user.name}\\\") String name) { User user = new User(); user.setId(id); user.setName(name); return user; } public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); // 扩展Environment中的PropertySources // 添加PropertySources操作必须在refresh方法之前完成 Map<String, Object> propertiesSource = new HashMap<>(); propertiesSource.put(\\\"user.name\\\", \\\"xiao ji\\\"); org.springframework.core.env.PropertySource propertySource = new MapPropertySource(\\\"first-property-source\\\", propertiesSource); context.getEnvironment().getPropertySources().addFirst(propertySource); context.register(AnnotatedSpringIoCContainerConfigurationDemo.class); context.refresh(); Map<String, User> userMap = context.getBeansOfType(User.class); for (Map.Entry<String, User> entry : userMap.entrySet()) { System.out.printf(\\\"User Bean name:%s,content: %s \\\\n\\\", entry.getKey(), entry.getValue()); } System.out.println(context.getEnvironment().getPropertySources()); context.close(); } } \"]},\"1032\":{\"h\":\"基于yml资源装载外部化配置\",\"t\":[\"使用API编程：\",\"org.springframework.beans.factory.config.YamlProcessor \",\"org.springframework.beans.factory.config.YamlMapFactoryBean\",\"org.springframework.beans.factory.config.YamlPropertiesFactoryBean\",\"定义YAML文件：\",\"user: id: 100 name: 吉永超 \",\"定义XML文件：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"yamlMap\\\" class=\\\"org.springframework.beans.factory.config.YamlMapFactoryBean\\\"> <property name=\\\"resources\\\" value=\\\"classpath:/META-INF/user.yaml\\\" /> </bean> </beans> \",\"测试我们的例子：\",\"public class XmlBasedYamlPropertySourceDemo { public static void main(String[] args) { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory); reader.loadBeanDefinitions(\\\"classpath:/META-INF/yaml-property-source-context.xml\\\"); // 获取User Bean对象 User user = beanFactory.getBean(\\\"user\\\", User.class); System.out.println(user); } } \",\"PropertySource默认是没有yaml格式的实现的，我们可以自己实现一个：\",\"public class YamlPropertySourceFactory implements PropertySourceFactory { @Override public PropertySource<?> createPropertySource(String name, EncodedResource resource) throws IOException { YamlPropertiesFactoryBean yamlPropertiesFactoryBean = new YamlPropertiesFactoryBean(); yamlPropertiesFactoryBean.setResources(resource.getResource()); Properties yamlProperties = yamlPropertiesFactoryBean.getObject(); return new PropertiesPropertySource(name, yamlProperties); } } \",\"然后使用YAML的方式装载外部化配置：\",\"@PropertySource(name = \\\"yamlPropertySource\\\", value = \\\"classpath:/META-INF/user.yaml\\\", factory = YamlPropertySourceFactory.class) public class AnnotatedYamlPropertySourceDemo { @Bean public User user(@Value(\\\"${user.id}\\\") String id, @Value(\\\"${user.name}\\\") String name) { User user = new User(); user.setId(id); user.setName(name); return user; } public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(AnnotatedYamlPropertySourceDemo.class); context.refresh(); User user = context.getBean(\\\"user\\\", User.class); System.out.println(user); context.close(); } } \"]},\"1033\":{\"h\":\"面试题\"},\"1034\":{\"h\":\"Spring内建的XML Schema常见有哪些？\",\"t\":[\"见基于XML资源装载Spring 容器配置元信息章节表格。\"]},\"1035\":{\"h\":\"Spring配置元信息有哪些？\",\"t\":[\"Bean配置元信息：通过媒介（如XML、Properties）等，解析BeanDefinition\",\"IoC容器配置元信息：通过媒介（如XML、Properties等），控制IoC容器行为，比如注解驱动，AOP等\",\"外部化配置：通过资源抽象（如Properties、YAML等），控制PropertySource\",\"Spring Profile：通过外部化配置，提供条件分支流程\"]},\"1036\":{\"h\":\"Extensible XML authoring的缺点？\",\"t\":[\"高复杂度：开发人员需要熟悉XML schema、Spring.handlers，Spring.schemas以及Spring API\",\"嵌套元素支持较弱：通常需要使用方法递归或者嵌套解析的方式处理嵌套（子）元素\",\"XML处理性能较差：Spring XML基于DOM Levels API 实现，该API便于理解，然而性能较差\",\"XML框架移植性较差：很难适配高性能和便利性的XML框架，如JAXB。\",\"为什么Spring不使用Java标准资源管理，而选择重新发明轮子？\",\"Java标准资源管理强大，然而扩展复杂，资源存储方式并不统一\",\"Spring要自立门户\",\"Spring “抄”、“超”、“潮”\"]},\"1037\":{\"h\":\"Java标准资源管理\",\"t\":[\"Java标准资源定位：\",\"职责\",\"说明\",\"面向资源\",\"文件系统、artifact（jar、war、ear文件）以及远程资源（HTTP、FTP等）\",\"API整合\",\"java.lang.ClassLoader#getResource、java.io.File或java.net.URL\",\"资源定位\",\"java.net.URL或java.net.URI\",\"面向流失存储\",\"java.net.URLConnection\",\"协议扩展\",\"java.net.URLStreamHandler或java.net.URLStreamHandleFactory\"]},\"1038\":{\"h\":\"Resource接口\",\"t\":[\"资源接口：\",\"类型\",\"接口\",\"输入流\",\"org.springframework.core.io.InputStreamResource\",\"只读资源\",\"org.springframework.core.io.Resource\",\"可写资源\",\"org.springframework.core.io.WritableResource\",\"编码资源\",\"org.springframework.core.io.support.EncodedResource\",\"上下文资源\",\"org.springframework.core.io.ContextResource\"]},\"1039\":{\"h\":\"内建的Resource实现\",\"t\":[\"内建实现：\",\"资源来源\",\"资源协议\",\"实现类\",\"Bean定义\",\"无\",\"org.springframework.beans.factory.support.BeanDefinitionResource\",\"数组\",\"无\",\"org.springframework.core.io.ByteArrayResource\",\"类路径\",\"classpath:/\",\"org.springframework.core.io.ClassPathResource\",\"文件系统\",\"file:/\",\"org.springframework.core.io.FileSystemResource\",\"URL\",\"URL支持的协议\",\"org.springframework.core.io.UrlResource\",\"ServletContext\",\"无\",\"org.springframework.web.context.support.ServletContextResource\"]},\"1040\":{\"h\":\"Resource接口扩展\",\"t\":[\"可写资源接口 \",\"org.springframework.core.io.WritableResource \",\"org.springframework.core.io.FileSystemResource\",\"org.springframework.core.io.FileUrlResource（@since 5.0.2）\",\"org.springframework.core.io.PathResource（@since 4.0 & @Deprecated）\",\"编码资源接口 \",\"org.springframework.core.io.support.EncodedResource\",\"使用编码资源接口进行操作的示例：\",\"public class EncodedFileSystemResourceDemo { public static void main(String[] args) throws Exception { String currentJavaFilePath = System.getProperty(\\\"user.dir\\\") + \\\"/bean-resource/src/main/java/org/jyc/thinking/in/spring/resource/EncodedFileSystemResourceDemo.java\\\"; File currentJavaFile = new File(currentJavaFilePath); FileSystemResource fileSystemResource = new FileSystemResource(currentJavaFile); EncodedResource encodedResource = new EncodedResource(fileSystemResource, \\\"UTF-8\\\"); // 字符输入流 try (Reader reader = encodedResource.getReader()) { System.out.println(IOUtils.toString(reader)); } } } \"]},\"1041\":{\"h\":\"Spring资源加载器\",\"t\":[\"Resource加载器：\",\"org.springframework.core.io.ResourceLoader \",\"org.springframework.core.io.DefaultResourceLoader\",\"org.springframework.core.io.FileSystemResourceLoader\",\"org.springframework.core.io.ClassRelativeResourceLoader\",\"org.springframework.context.support.AbstractApplicationContext\",\"使用示例：\",\"public class EncodedFileSystemResourceLoaderDemo { public static void main(String[] args) throws Exception { String currentJavaFilePath = System.getProperty(\\\"user.dir\\\") + \\\"/bean-resource/src/main/java/org/jyc/thinking/in/spring/resource/EncodedFileSystemResourceLoaderDemo.java\\\"; FileSystemResourceLoader resourceLoader = new FileSystemResourceLoader(); Resource fileSystemResource = resourceLoader.getResource(currentJavaFilePath); EncodedResource encodedResource = new EncodedResource(fileSystemResource, \\\"UTF-8\\\"); // 字符输入流 try (Reader reader = encodedResource.getReader()) { System.out.println(IOUtils.toString(reader)); } } } \"]},\"1042\":{\"h\":\"Spring通配路径资源加载器\",\"t\":[\"通配路径ResourceLoader \",\"org.springframework.core.io.support.ResourcePatternResolver\",\"org.springframework.core.io.support.PathMatchingResourcePatternResolver\",\"路径匹配器 \",\"org.springframework.util.PathMatcher \",\"Ant模式匹配实现 - org.springframework.util.AntPathMatcher\"]},\"1043\":{\"h\":\"Spring通配路径资源扩展\",\"t\":[\"实现org.springframework.util.PathMatcher\",\"重置PathMatcher \",\"PathMatchingResourcePatternResolver#setPathMatcher\",\"相关的示例：\",\"public class CustomizedResourcePatternResolver { public static void main(String[] args) throws Exception { // 读取当前package对应的所有的.java文件 // *.java String currentPackagePath = System.getProperty(\\\"user.dir\\\") + \\\"/bean-resource/src/main/java/org/jyc/thinking/in/spring/resource/\\\"; String locationPattern = currentPackagePath + \\\"*.java\\\"; PathMatchingResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver(new FileSystemResourceLoader()); resourcePatternResolver.setPathMatcher(new JavaFilePathMatcher()); Resource[] resources = resourcePatternResolver.getResources(locationPattern); Stream.of(resources).map(ResourceUtils::getContent).forEach(System.out::println); } static class JavaFilePathMatcher implements PathMatcher { @Override public boolean isPattern(String path) { return path.endsWith(\\\".java\\\"); } @Override public boolean match(String pattern, String path) { return path.endsWith(\\\".java\\\"); } @Override public boolean matchStart(String pattern, String path) { return false; } @Override public String extractPathWithinPattern(String pattern, String path) { return null; } @Override public Map<String, String> extractUriTemplateVariables(String pattern, String path) { return null; } @Override public Comparator<String> getPatternComparator(String path) { return null; } @Override public String combine(String pattern1, String pattern2) { return null; } } } \",\"其中使用到的工具类：\",\"public interface ResourceUtils { static String getContent(Resource resource) { try { return getContent(resource, \\\"UTF-8\\\"); } catch (IOException e) { throw new RuntimeException(e); } } static String getContent(Resource resource, String encoding) throws IOException { EncodedResource encodedResource = new EncodedResource(resource, encoding); try (Reader reader = encodedResource.getReader()) { return IOUtils.toString(reader); } } } \"]},\"1044\":{\"h\":\"依赖注入Spring Resource\",\"t\":[\"可以基于@Value实现：\",\"@Value(\\\"classpath:/...\\\") private Resource resource; \",\"相关的示例：\",\"public class InjectResourceDemo { @Value(\\\"classpath:/META-INF/default.properties\\\") private Resource defaultPropertiesResource; @Value(\\\"classpath*:/META-INF/*.properties\\\") private Resource[] PropertiesResources; @Value(\\\"${user.dir}\\\") private String currentProjectRootPath; @PostConstruct public void init() { System.out.println(ResourceUtils.getContent(defaultPropertiesResource)); System.out.println(currentProjectRootPath); Stream.of(PropertiesResources).map(ResourceUtils::getContent).forEach(System.out::println); } public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(InjectResourceDemo.class); applicationContext.refresh(); // 关闭应用上下文 applicationContext.close(); } } \"]},\"1045\":{\"h\":\"依赖注入ResourceLoader\",\"t\":[\"有多种方式可以依赖注入ResourceLoader：\",\"实现ResourceLoaderAware回调\",\"@Autowired注入ResourceLoader\",\"注入ApplicationContext作为ResourceLoader\",\"public class InjectResourceLoaderDemo implements ResourceLoaderAware { private ResourceLoader awareResourceLoader; @Autowired ResourceLoader autowiredResourceLoader; @Autowired private AbstractApplicationContext applicationContext; @PostConstruct public void init() { System.out.println(\\\"awareResourceLoader == autowiredResourceLoader: \\\" + (autowiredResourceLoader == awareResourceLoader)); System.out.println(\\\"autowiredResourceLoader == applicationContext: \\\" + (awareResourceLoader == applicationContext)); } public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(InjectResourceLoaderDemo.class); applicationContext.refresh(); // 关闭应用上下文 applicationContext.close(); } @Override public void setResourceLoader(ResourceLoader resourceLoader) { this.awareResourceLoader = resourceLoader; } } \",\"这三种不同的方式最终注入的是相同的对象，都是AbstractApplicationContext。\"]},\"1046\":{\"h\":\"面试题\"},\"1047\":{\"h\":\"Spring配置资源中有哪些常见类型？\",\"t\":[\"XML资源、Properties资源、YAML资源。\"]},\"1048\":{\"h\":\"请举例不同类型的Spring配置资源\",\"t\":[\"XML资源：\",\"普通的BeanDefinition XML资源配置 - *.xml\",\"Spring Schema资源 - *.xsd\",\"Properties资源：\",\"普通Properties格式资源 - *.properties\",\"Spring Handler实现类映射文件 - META/spring.handlers\",\"Spring Schema资源映射文件 - META-INF/spring.schemas\",\"YAML资源：\",\"普通YAML资源配置 - *.yaml或 *.yml\"]},\"1049\":{\"h\":\"Java标准资源管理扩展的步骤\",\"t\":[\"简易实现：\",\"实现URLStreamHandler并放置再sun.net.www.protocol.${protocol}.Handler包下\",\"自定义实现：\",\"实现URLStreamHandler\",\"添加 -Djava.protocol.handler.pkgs启动参数，指向URLStreamHandler实现类的包下\",\"高级实现：\",\"实现URLStreamHandlerFactory并传递到URL之中\",\"Spring国际化使用场景：\",\"普通国际化文案\",\"Bean Validation校验国际化文案\",\"Web站点页面渲染\",\"Web MVC错误消息提示\"]},\"1050\":{\"h\":\"Spring国际化接口\",\"t\":[\"核心接口：\",\"org.springframework.context.MessageSource\",\"主要概念：\",\"文案模板编码（code）\",\"文案模板参数（args）\",\"区域（Locale）\"]},\"1051\":{\"h\":\"层次性的MessageSource\",\"t\":[\"Spring层次性国际化接口：\",\"org.springframework.context.HierarchicalMessageSource\"]},\"1052\":{\"h\":\"Java国际化标准实现\",\"t\":[\"核心接口：\",\"抽象实现 - java.util.ResourceBundle\",\"Properties资源实现 - java.util.PropertyResourceBundle\",\"列举实现 - java.util.ListResourceBundle\",\"ResourceBundle核心特性：\",\"Key - Value设计\",\"层次性设计\",\"缓存设计\",\"字符编码控制 - java.util.ResourceBundle.Control（@since 1.6）\",\"Control SPI扩展 - java.util.spi.ResourceBundleControlProvider（@since 1.8）\"]},\"1053\":{\"h\":\"Java文本格式化\",\"t\":[\"核心接口：\",\"java.text.MessageFormat\",\"基本用法：\",\"设置消息格式模式 - new MessageFormat(...)\",\"格式化 - format(new Objectp[]{...})\",\"消息格式模式：\",\"格式元素：{ArgumentIndex（,FormatType,（FormatStyle））}\",\"FormatType：消息格式类型，可选项，每种类型在number、date、time和choice类型选其一\",\"FormatStyle：消息格式风格，可选项，包括：short、medium、long、full、integer、currency、percent\",\"public class MessageFormatDemo { public static void main(String[] args) { int planet = 7; String event = \\\"a disturbance in the Force\\\"; String result = MessageFormat.format( \\\"At {1,time,long} on {1,date}, there was {2} on planet {0,number,integer}.\\\", planet, new Date(), event); System.out.println(result); } } \",\"Java文本格式化还有一些高级特性：\",\"重置消息格式模板\",\"重置java.util.Locale\",\"重置java.text.Format\",\"使用的示例：\",\"public class MessageFormatDemo { public static void main(String[] args) { int planet = 7; String event = \\\"a disturbance in the Force\\\"; String messageFormatPattern = \\\"At {1,time,long} on {1,date}, there was {2} on planet {0,number,integer}.\\\"; MessageFormat messageFormat = new MessageFormat(messageFormatPattern); String result = messageFormat.format(new Object[]{planet, new Date(), event}); System.out.println(result); // 重置MessageFormatPattern messageFormatPattern = \\\"This is a text: {0},{1},{2}\\\"; messageFormat.applyPattern(messageFormatPattern); result = messageFormat.format(new Object[]{\\\"hello,world\\\", \\\"666\\\"}); System.out.println(result); // 重置Locale messageFormat.setLocale(Locale.ENGLISH); messageFormatPattern = \\\"At {1,time,long} on {1,date}, there was {2} on planet {0,number,integer}.\\\"; messageFormat.applyPattern(messageFormatPattern); result = messageFormat.format(new Object[]{planet, new Date(), event}); System.out.println(result); // 重置Format // 根据参数索引来设置 Pattern messageFormat.setFormat(1, new SimpleDateFormat(\\\"YYYY-MM-dd HH:mm:ss\\\")); result = messageFormat.format(new Object[]{planet, new Date(), event}); System.out.println(result); } } \"]},\"1054\":{\"h\":\"MessageSource开箱实现\",\"t\":[\"基于ResourceBundle + MessageFormat组合MessageSource实现：\",\"org.springframework.context.support.ResourceBundleMessageSource\",\"可重载Properties + MessageFormat组合MessageSource实现：\",\"org.springframework.context.support.ReloadableResourceBundleMessageSource\"]},\"1055\":{\"h\":\"Message的内建依赖\",\"t\":[\"MessageSource内建Bean可能来源：\",\"预注册Bean名称为：\\\"messageSource\\\"，类型为：MessageSource Bean\",\"默认内建实现 - DelegatingMessageSource \",\"层次性查找MessageSource对象\",\"相关的代码实现：\",\"protected void initMessageSource() { ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) { this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class); // Make MessageSource aware of parent MessageSource. if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) { HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource; if (hms.getParentMessageSource() == null) { // Only set parent context as parent MessageSource if no parent MessageSource // registered already. hms.setParentMessageSource(getInternalParentMessageSource()); } } if (logger.isTraceEnabled()) { logger.trace(\\\"Using MessageSource [\\\" + this.messageSource + \\\"]\\\"); } } else { // Use empty MessageSource to be able to accept getMessage calls. DelegatingMessageSource dms = new DelegatingMessageSource(); dms.setParentMessageSource(getInternalParentMessageSource()); this.messageSource = dms; beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource); if (logger.isTraceEnabled()) { logger.trace(\\\"No '\\\" + MESSAGE_SOURCE_BEAN_NAME + \\\"' bean, using [\\\" + this.messageSource + \\\"]\\\"); } } } \"]},\"1056\":{\"h\":\"SpringBoot为什么要新建MessageSource Bean?\",\"t\":[\"AbstractApplicationContext的实现决定了MessageSource内建实现\",\"Spring Boot通过外部化配置简化了MessageSource Bean构建\",\"SPring Boot基于Bean Validation校验非常普遍\",\"实际上我们可以覆盖SpringBoot中自动装配的MessageSource Bean：\",\"@EnableAutoConfiguration public class CustomizedMessageSourceBeanDemo { /** * 在Spring Boot场景中，Primary Configure Sources（Classes）高于*AutoConfiguration * * @return */ @Bean public MessageSource messageSource() { return new ReloadableResourceBundleMessageSource(); } public static void main(String[] args) { ConfigurableApplicationContext applicationContext = SpringApplication.run(CustomizedMessageSourceBeanDemo.class, args); ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory(); if (beanFactory.containsBean(AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME)) { beanFactory.getBean(AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME); // 查找MessageSource Bean MessageSource messageSource = applicationContext.getBean(AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME, MessageSource.class); System.out.println(messageSource); } } } \"]},\"1057\":{\"h\":\"面试题\"},\"1058\":{\"h\":\"Spring国际化接口有哪些？\",\"t\":[\"核心接口 - MessageSource\",\"层次性接口 - org.springframework.context.HierarchicalMessageSource\"]},\"1059\":{\"h\":\"Spring有哪些MessageSource的内建实现？\",\"t\":[\"org.springframework.context.support.ResourceBundleMessageSource\",\"org.springframework.context.support.ReloadableResourceBundleMessageSource\",\"org.springframework.context.support.StaticMessageSource\",\"org.springframework.context.support.DelegatingMessageSource\"]},\"1060\":{\"h\":\"如何实现配置自动更新MessageSource？\",\"t\":[\"主要技术：\",\"Java NIO 2：java.nio.file.watchService\",\"Java Concurrency：java.util.concurrent.ExecutorService\",\"Spring：org.springframework.context.support.AbstractMessageSource\",\"Spring校验使用场景：\",\"Spring 常规校验（Validator）\",\"Spring 数据绑定（DataBinder）\",\"Spring Web参数绑定（WebDataBinder）\",\"Spring WebMVC/WebFlux处理方法参数校验\"]},\"1061\":{\"h\":\"Validator接口设计\",\"t\":[\"接口职责：\",\"Spring内部校验接口，通过编程的方式校验目标对象\",\"核心方法：\",\"supports（Class）：校验目标类能否校验\",\"validate（Object，Errors）：校验目标对象，并将校验失败的内容输出至Errors对象\",\"配套组件：\",\"错误收集器：org.springframework.validation.Errors\",\"Validator工具类：org.springframework.validation.ValidationUtils\",\"在Java Doc中的例子：\",\"public class UserLoginValidator implements Validator { private static final int MINIMUM_PASSWORD_LENGTH = 6; public boolean supports(Class clazz) { return UserLogin.class.isAssignableFrom(clazz); } public void validate(Object target, Errors errors) { ValidationUtils.rejectIfEmptyOrWhitespace(errors, \\\"userName\\\", \\\"field.required\\\"); ValidationUtils.rejectIfEmptyOrWhitespace(errors, \\\"password\\\", \\\"field.required\\\"); UserLogin login = (UserLogin) target; if (login.getPassword() != null && login.getPassword().trim().length() < MINIMUM_PASSWORD_LENGTH) { errors.rejectValue(\\\"password\\\", \\\"field.min.length\\\", new Object[]{Integer.valueOf(MINIMUM_PASSWORD_LENGTH)}, \\\"The password must be at least [\\\" + MINIMUM_PASSWORD_LENGTH + \\\"] characters in length.\\\"); } } } \"]},\"1062\":{\"h\":\"Errors接口设计\",\"t\":[\"接口职责：\",\"数据绑定和校验错误收集接口，与Java Bean和其属性有强关联性。\",\"核心方法：\",\"reject方法（重载）：收集错误文案\",\"rejectValue方法（重载）：收集对象字段中的错误文案\",\"配套组件：\",\"Java Bean错误描述：org.springframework.validation.ObjectError\",\"Java Bean属性错误描述：org.springframework.validation.FieldError\"]},\"1063\":{\"h\":\"Errors的文案来源\",\"t\":[\"Errors文案生成步骤：\",\"选择Errors实现（org.springframework.validation.BeanPropertyBindingResult）\",\"调用reject方法或rejectValue方法\",\"获取Errors对象中ObjectError或FieldError\",\"将ObjectError或FieldError中的code和args，关联MessageSource实现（如：ResourceBundleMessageSource）\",\"使用的示例：\",\"public class ErrorMessageDemo { public static void main(String[] args) { // 1.创建User对象 User user = new User(); // 2.选择Errors - BeanPropertyBindingResult Errors errors = new BeanPropertyBindingResult(user, \\\"user\\\"); // 3.调用reject或者rejectValue // reject生成ObjectError // reject生成 FildError errors.reject(\\\"user.properties.not.null\\\"); errors.rejectValue(\\\"name\\\", \\\"name.required\\\"); //4.FieldError is ObjectError List<ObjectError> globalErrors = errors.getGlobalErrors(); FieldError fieldError = errors.getFieldError(); List<ObjectError> allErrors = errors.getAllErrors(); // 5.通过ObjectError和FieldError中的code和args关联MessageSource实现 MessageSource messageSource = createMessageSource(); for (ObjectError error : allErrors) { messageSource.getMessage(error.getCode(), error.getArguments(), Locale.getDefault()); System.out.println(messageSource); } } private static MessageSource createMessageSource() { StaticMessageSource staticMessageSource = new StaticMessageSource(); staticMessageSource.addMessage(\\\"user.properties.not.null\\\", Locale.getDefault(), \\\"User 属性不能为空\\\"); staticMessageSource.addMessage(\\\"name.required\\\", Locale.getDefault(), \\\"name is not null\\\"); return staticMessageSource; } } \"]},\"1064\":{\"h\":\"自定义Validator\",\"t\":[\"实现org.springframework.validation.Validator接口，具体操作如下：\",\"实现supports方法\",\"实现validate方法 \",\"通过Errors对象收集错误 \",\"ObjectError：对象（Bean）错误：\",\"FieldError：对象（Bean）属性（Property）错误\",\"通过ObjectError和FieldError关联MessageSource实现获取最终文案\",\"自定义Validator的示例：\",\"public class ValidatorDemo { public static void main(String[] args) { // 1.创建Validator Validator validator = new UserValodator(); // 2.判断是否支持目标对象的类型 User user = new User(); System.out.println(validator.supports(user.getClass())); // 3.创建Errors对象 Errors errors = new BeanPropertyBindingResult(user, \\\"user\\\"); validator.validate(user, errors); // 4.获取MessageSource对象 MessageSource messageSource = createMessageSource(); // 5.输出所有的错误文案 for (ObjectError error : errors.getAllErrors()) { String message = messageSource.getMessage(error.getCode(), error.getArguments(), Locale.getDefault()); System.out.println(message); } } static class UserValodator implements Validator { @Override public boolean supports(Class<?> clazz) { return User.class.equals(clazz); } @Override public void validate(Object target, Errors errors) { User user = (User) target; ValidationUtils.rejectIfEmptyOrWhitespace(errors, \\\"id\\\", \\\"id.required\\\"); ValidationUtils.rejectIfEmptyOrWhitespace(errors, \\\"name\\\", \\\"name.required\\\"); String name = user.getName(); // ... } } } \"]},\"1065\":{\"h\":\"Bean Validation\",\"t\":[\"Bean Validation 与 Validator适配：\",\"核心组件 - org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\",\"依赖Bean Validation - JSR - 303 or JSR - 349 provider\",\"Bean方法参数校验 - org.springframework.validation.beanvalidation.MethodValidationPostProcessor\",\"使用示例：\",\"public class SpringBeanValidationDemo { public static void main(String[] args) { ConfigurableApplicationContext applicationContext = new ClassPathXmlApplicationContext(\\\"classpath:/META-INF/bean-validation-context.xml\\\"); // Validator validator = applicationContext.getBean(Validator.class); // System.out.println(validator instanceof LocalValidatorFactoryBean); UserProcessor userProcessor = applicationContext.getBean(UserProcessor.class); userProcessor.processUser(new User()); applicationContext.close(); } @Component @Validated static class UserProcessor { public void processUser(@Valid User user) { System.out.println(user); } } @Validated static class User { public String getName() { return name; } @Override public String toString() { return \\\"User{\\\" + \\\"name='\\\" + name + '\\\\'' + '}'; } public void setName(String name) { this.name = name; } @NotNull private String name; } } \",\"其中的XML文件：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\\\"> <context:component-scan base-package=\\\"org.jyc.thinking.in.spring.validation\\\" /> <bean id = \\\"validator\\\" class=\\\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\\\" /> <bean class=\\\"org.springframework.validation.beanvalidation.MethodValidationPostProcessor\\\"> <property name=\\\"validator\\\" ref=\\\"validator\\\" /> </bean> </beans> \",\"可以看到使用这种方式方便了很多，并且可以根据实际的需求对其进行扩展。\"]},\"1066\":{\"h\":\"面试题\"},\"1067\":{\"h\":\"Spring校验接口是哪个？\",\"t\":[\"org.springframework.validation.Validator\"]},\"1068\":{\"h\":\"Spring有哪些校验核心组件？\",\"t\":[\"校验器：org.springframework.validation.Validator\",\"错误收集器：org.springframework.validation.Errors\",\"Java Bean错误描述：org.springframework.validation.ObjectError\",\"Java Bean属性错误描述：org.springframework.validation.FieldError\",\"Bean Validation适配：org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"]},\"1069\":{\"h\":\"请通过示例演示Spring Bean的校验？\",\"t\":[\"// 待续...\",\"Spring数据绑定的使用场景：\",\"Spring BeanDefinition到Bean实例创建\",\"Spring数据绑定（DataBinder）\",\"Spring Web参数绑定（WebDataBinder）\"]},\"1070\":{\"h\":\"Spring 数据绑定组件\",\"t\":[\"标准组件： \",\"org.springframework.validation.DataBinder\",\"Web组件： \",\"org.springframework.web.bind.WebDataBinder\",\"org.springframework.web.bind.ServletRequestDataBinder\",\"org.springframework.web.bind.support.WebRequestDataBinder\",\"org.springframework.web.bind.support.WebExchangeDataBinder\",\"DataBinder的核心属性：\",\"属性\",\"说明\",\"target\",\"关联目标Bean\",\"objectName\",\"目标Bean名称\",\"bindingResult\",\"属性绑定结果\",\"typeConverter\",\"类型转化器\",\"conversionService\",\"类型转化服务\",\"messageCodesResolver\",\"校验错误文案Code处理器\",\"validators\",\"关联的Bean Validator实例集合\",\"DataBinder绑定方法bind（PropertyValues），会将PropertyValues key-Value内容映射到关联Bean（target）中的属性上。\"]},\"1071\":{\"h\":\"DataBinder元数据\",\"t\":[\"DataBinder元数据 - PropertyValues：\",\"特征\",\"说明\",\"数据来源\",\"BeanDefinition，主要来源XML资源配置BeanDefinition\",\"数据结构\",\"由一个或多个PropertyValue组成\",\"成员结构\",\"PropertyValue包含属性名称，以及属性值（包括原始值、类型转换后的值）\",\"常见实现\",\"MutablePropertyValue\",\"Web扩展实现\",\"ServletConfigPropertyValue，ServletRequestParameterPropertyValues\",\"相关生命周期\",\"InstantiationAwareBeanPostProcessor#postProcessProperties\"]},\"1072\":{\"h\":\"DataBinder绑定控制参数\",\"t\":[\"DataBinder绑定特殊场景分析：\",\"当PropertyValues中包含名称的x的PropertyValue，目标对象B不存在x属性，当bind方法执行时，会发生什么？\",\"当PropertyValues中包含名称的x的PropertyValue，目标对象B中存在x属性，当bind方法执行时，如何避免B属性x不被绑定？\",\"当PropertyValues中包含x.y的PropertyValue，目标对象B中存在x属性（嵌套y属性），当bind方法执行时，会发生什么？\",\"相关的示例代码：\",\" public class DataBinderDemo { public static void main(String[] args) { // 创建空白对象 User user = new User(); // 1.创建DataBinder DataBinder dataBinder = new DataBinder(user, \\\"user\\\"); // 2.创建PropertyValues HashMap<String, Object> source = new HashMap<>(); source.put(\\\"id\\\",\\\"1\\\"); source.put(\\\"name\\\",\\\"吉永超\\\"); // a.PropertyValues存在user中不存在的属性值 // DataBinder特性一：忽略了未知的属性 source.put(\\\"age\\\",18); // b.PropertyValues存在一个嵌套属性，company.name // DataBinder特性二：支持嵌套属性 source.put(\\\"company.name\\\",\\\"jjjj\\\"); MutablePropertyValues propertyValues = new MutablePropertyValues(source); dataBinder.bind(propertyValues); // 3.输出user System.out.println(user); } } \",\"DataBinder绑定控制参数：\",\"参数名称\",\"说明\",\"ignoreUnknownFields\",\"是否忽略未知字段，默认值：true\",\"ignoreInvalidFields\",\"是否忽略非法字段，默认值：false\",\"autoGrowNestedPaths\",\"是否自动增加嵌套路径，默认值：true\",\"allowedFields\",\"绑定字段白名单\",\"disallowedFields\",\"绑定字段黑名单\",\"requiredFields\",\"必须绑定字段\",\"相关的示例：\",\"public class DataBinderDemo { public static void main(String[] args) { // 创建空白对象 User user = new User(); // 1.创建DataBinder DataBinder dataBinder = new DataBinder(user, \\\"user\\\"); // 2.创建PropertyValues HashMap<String, Object> source = new HashMap<>(); source.put(\\\"id\\\", \\\"1\\\"); source.put(\\\"name\\\", \\\"吉永超\\\"); // a.PropertyValues存在user中不存在的属性值 // DataBinder特性一：忽略了未知的属性 source.put(\\\"age\\\", 18); // b.PropertyValues存在一个嵌套属性，company.name // DataBinder特性二：支持嵌套属性 source.put(\\\"company.name\\\", \\\"jjjj\\\"); // source.put(\\\"company\\\", new Company()); // source.put(\\\"company.name\\\",\\\"jjjj\\\"); MutablePropertyValues propertyValues = new MutablePropertyValues(source); // 1.调整ignoreUnknownFields true（默认） -> false // dataBinder.setIgnoreUnknownFields(false); // 2.调整自动增加嵌套路径true（默认） -> false dataBinder.setAutoGrowNestedPaths(false); // 3.调整ignoreInvalidFields false（默认） -> true dataBinder.setIgnoreInvalidFields(true); // 4.白名单 dataBinder.setRequiredFields(\\\"id\\\", \\\"name\\\", \\\"city\\\"); dataBinder.bind(propertyValues); // 输出user System.out.println(user); // 5.获取绑定结果（结果包含错误文案code，不会抛出异常） BindingResult result = dataBinder.getBindingResult(); System.out.println(result); } } \"]},\"1073\":{\"h\":\"Spring底层Java Beans替换实现\",\"t\":[\"Java Beans核心实现 - java.beans.BeanInfo \",\"属性（Property） \",\"java.beans.PropertyEditor\",\"方法（Method）\",\"事件（Event）\",\"表达式（Expression）\",\"Spring替代实现 - org.springframework.beans.BeanWrapper \",\"属性（Property） \",\"java.beans.PropertyEditor\",\"嵌套属性路径（nested path）\"]},\"1074\":{\"h\":\"BeanWrapper使用场景\",\"t\":[\"Spring底层JavaBeans基础设施的中心化接口\",\"通常不会直接使用，间接用于BeanFactory和DataBinder\",\"提供标准JavaBeans分析和操作，能够单独或批量存储Java Bean的属性（properties）\",\"支持嵌套属性路径（nested path）\",\"实现类 org.springframework.beans.BeanWrapperImpl\"]},\"1075\":{\"h\":\"JavaBeans操作属性\",\"t\":[\"标准的JavaBeans是如何操作属性的？\",\"API\",\"说明\",\"java.beans.Introspector\",\"JavaBeans 内省API\",\"java.beans.BeanInfo\",\"Java Bean 元信息API\",\"java.beans.BeanDescriptor\",\"Java Bean 信息描述符\",\"java.beans.PropertyDescriptor\",\"Java Bean 属性描述符\",\"java.beans.MethodDescriptor\",\"Java Bean 方法描述符\",\"java.beans.EventSetDescriptor\",\"Java Bean 事件集合描述符\",\"PropertyDescriptor并不要求setter、getter方法均存在。\",\"可以使用如下示例进行观察：\",\"public class JavaBeansDemo { public static void main(String[] args) throws Exception { // stopClass排除（截止）类 BeanInfo beanInfo = Introspector.getBeanInfo(User.class, Object.class); // 属性描述符 PropertyDescriptor // 所有的Java类均继承 java.lang.Object方法 // Class属性来自于Object#getClass() 方法 Stream.of(beanInfo.getPropertyDescriptors()).forEach(propertyDescriptor -> { propertyDescriptor.getReadMethod(); // Getter方法 propertyDescriptor.getWriteMethod(); // Setter方法 System.out.println(propertyDescriptor); }); // 输出User定义的方法 MethodDescriptor Stream.of(beanInfo.getMethodDescriptors()).forEach(System.out::println); } } \"]},\"1076\":{\"h\":\"DataBinder数据校验\",\"t\":[\"DataBinder与BeanWrapper的联系：\",\"bind方法生成BeanPropertyBindingResult\",\"BeanPropertyBindingResult关联BeanWrapper\"]},\"1077\":{\"h\":\"面试题\"},\"1078\":{\"h\":\"Spring数据绑定API是什么？\",\"t\":[\"org.springframework.validation.DataBinder\"]},\"1079\":{\"h\":\"BeanWrapper与JavaBeans之间的关系是？\",\"t\":[\"BeanWrapper是Spring底层JavaBeans基础设施的中心化接口。\"]},\"1080\":{\"h\":\"DataBinder是怎么完成属性类型转换的？\",\"t\":[\"// ...\",\"Spring类型转换的实现方案：\",\"基于JavaBeans接口的类型转换实现 \",\"基于java.beans.PropertyEditor扩展\",\"Spring 3.0+ 通用类型转换实现\"]},\"1081\":{\"h\":\"使用场景\",\"t\":[\"场景分析：\",\"场景\",\"基于JavaBeans接口的类型转换实现\",\"Spring 3.0+通用类型转换实现\",\"数据绑定\",\"YES\",\"YES\",\"BeanWrapper\",\"YES\",\"YES\",\"Bean属性类型转换\",\"YES\",\"YES\",\"外部化属性类型转换\",\"NO\",\"YES\"]},\"1082\":{\"h\":\"基于JavaBeans接口的类型转换\",\"t\":[\"核心职责： \",\"将String类型转化为目标类型的对象\",\"扩展原理： \",\"Spring框架将文本内容传递到PropertyEditor实现的setAsText(String)方法\",\"PropertyEditor#setAsText(String)方法实现将String类型转化为目标类型的对象\",\"将目标类型的对象传入PropertyEditor#setAsValue(Object)方法\",\"PropertyEditor#setAsValue(Object)方法实现需要临时存储传入对象\",\"Spring框架将通过PropertyEditor#getValue()获取类型转换后的对象\",\"我们可以模拟一下整个过程：\",\"public class StringToPropertiesPropertyEditor extends PropertyEditorSupport implements PropertyEditor { // 1.实现setAsText方法 @Override public void setAsText(String text) throws IllegalArgumentException { // 2.将String类型转换成Properties类型 Properties properties = new Properties(); try { properties.load(new StringReader(text)); } catch (IOException e) { e.printStackTrace(); } // 3.临时存储Properties对象 setValue(properties); // next 获取临时Properties对象 # getValue } } \",\"然后观察输出：\",\"public class PropertyEditorDemo { public static void main(String[] args) { // 模拟Spring Framework的操作 // 有一段文本name = \\\"吉永超\\\"; String text = \\\"name = 吉永超\\\"; PropertyEditor propertyEditor = new StringToPropertiesPropertyEditor(); propertyEditor.setAsText(text); System.out.println(propertyEditor.getValue()); } } \"]},\"1083\":{\"h\":\"Spring内建PropertyEditor扩展\",\"t\":[\"内建扩展（org.springframework.beans.propertyeditors）：\",\"转换场景\",\"实现类\",\"String -> Byte数组\",\"org.springframework.beans.propertyeditors.ByteArrayPropertyEditor\",\"String -> Char\",\"org.springframework.beans.propertyeditors.CharacterEditor\",\"String -> Char 数组\",\"org.springframework.beans.propertyeditors.CharArrayPropertyEditor\",\"String -> Charset\",\"org.springframework.beans.propertyeditors.CharsetEditor\",\"String -> Class\",\"org.springframework.beans.propertyeditors.ClassEditor\",\"String -> Currency\",\"org.springframework.beans.propertyeditors.CurrencyEditor\",\"...\",\"...\"]},\"1084\":{\"h\":\"自定义PropertyEditor扩展\",\"t\":[\"实现步骤如下：\",\"扩展模式： \",\"扩展java.beans.PropertyEditorSupport类\",\"实现org.springframework.beans.PropertyEditorRegistrar \",\"实现registerCustomEditor（org.springframework.beans.PropertyEditorRegistry）方法\",\"将PropertyEditorRegistry实现注册为Spring Bean\",\"向org.springframework.beans.PropertyEditorRegistry注册自定义PropertyEditor实现 \",\"通用类型实现：registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor);\",\"Java Bean属性类型实现：registerCustomEditor(Class<?> requiredType, String propertyPath, PropertyEditor propertyEditor);\",\"相关的示例，第一步：\",\"public class StringToPropertiesPropertyEditor extends PropertyEditorSupport implements PropertyEditor { // 1.实现setAsText方法 @Override public void setAsText(String text) throws IllegalArgumentException { // 2.将String类型转换成Properties类型 Properties properties = new Properties(); try { properties.load(new StringReader(text)); } catch (IOException e) { e.printStackTrace(); } // 3.临时存储Properties对象 setValue(properties); // next 获取临时Properties对象 # getValue } @Override public String getAsText() { Properties properties = (Properties) getValue(); StringBuilder textBuilder = new StringBuilder(); for (Map.Entry<Object, Object> entry : properties.entrySet()) { textBuilder.append(entry.getKey()).append(\\\"=\\\").append(entry.getValue()).append(System.getProperty(\\\"line.separator\\\")); } return textBuilder.toString(); } } \",\"第二步和第三步：\",\"// @Component // 3.将其声明为Spring Bean public class CustomizedPropertyEditorRegistrar implements PropertyEditorRegistrar { @Override public void registerCustomEditors(PropertyEditorRegistry registry) { // 1.通用类型转换 // 2.Java Bean属性类型转换 registry.registerCustomEditor(User.class, \\\"context\\\", new StringToPropertiesPropertyEditor()); } } \",\"这里我们不采用注解的方式，而是采用XML的方式进行配置，将CustomizedPropertyEditorRegistrar声明为Spring Bean：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"user\\\" class=\\\"org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User\\\"> <property name=\\\"id\\\" value=\\\"1\\\"/> <property name=\\\"name\\\" value=\\\"吉永超\\\"/> <property name=\\\"context\\\"> <!-- Properties类型 --> <value> id = 1 name = 吉永超 </value> </property> </bean> <bean class=\\\"org.jyc.thinking.in.spring.conversion.CustomizedPropertyEditorRegistrar\\\"/> </beans> \",\"测试类：\",\"public class SpringCustomizedPropertyEditorDemo { public static void main(String[] args) { ConfigurableApplicationContext applicationContext = new ClassPathXmlApplicationContext(\\\"classpath:/META-INF/property-editors-context.xml\\\"); User user = applicationContext.getBean(\\\"user\\\", User.class); System.out.println(user); // 关闭应用上下文 applicationContext.close(); } } \"]},\"1085\":{\"h\":\"PropertyEditor的局限性\",\"t\":[\"违反单一原则 \",\"java.beans.PropertyEditor接口职责太多，除了类型转换，还包括Java Beans事件和Java GUI交互\",\"java.beans.PropertyEditor实现类型局限 \",\"来源类型只能为java.lang.String类型\",\"java.beans.PropertyEditor实现缺少类型安全 \",\"除了实现类名可以表达语义，实现类无法感知目标转换类型\"]},\"1086\":{\"h\":\"Spring3 通用类型转换接口\",\"t\":[\"类型转换接口 - org.springframework.core.convert.converter.Converter<S, T> \",\"泛型参数S：来源类型，参数T：目标类型\",\"核心方法：T convert(S)\",\"通用类型转换接口 - org.springframework.core.convert.converter.GenericConverter \",\"核心方法：convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);\",\"配对类型：org.springframework.core.convert.converter.GenericConverter.ConvertiblePair\",\"类型描述：org.springframework.core.convert.TypeDescriptor\"]},\"1087\":{\"h\":\"Spring内建类型转换器\",\"t\":[\"转换场景\",\"实现类所在包名(package)\",\"日期/时间相关\",\"org.springframework.format.datetime\",\"Java 8 日期/时间相关\",\"org.springframework.format.datetime.standard\",\"通用实现\",\"org.springframework.core.convert.support\"]},\"1088\":{\"h\":\"Converter接口的局限性\",\"t\":[\"局限一：缺少Source Type和Target Type前置判断 \",\"应对：增加org.springframework.core.convert.converter.ConditionalConverter实现\",\"局限二：仅能转换单一的Source Type和Target Type \",\"应对：使用org.springframework.core.convert.converter.GenericConverter代替\"]},\"1089\":{\"h\":\"GenericConverter接口\",\"t\":[\"org.springframework.core.convert.converter.GenericConverter的介绍：\",\"核心要素\",\"说明\",\"使用场景\",\"用于\\\"复合\\\"类型转换场景，比如Collection、Map、数组等\",\"转换范围\",\"Set<ConvertiblePair> getConvertibleTypes()\",\"配对类型\",\"org.springframework.core.convert.converter.GenericConverter.ConvertiblePair\",\"转换方法\",\"convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)\",\"类型描述\",\"org.springframework.core.convert.TypeDescriptor\",\"\\\"复合\\\"类型在进行转换的时候，可以利用Converter接口，对集合（或其他类型）中的元素进行转换。\"]},\"1090\":{\"h\":\"优化GenericConverter接口\",\"t\":[\"GenericConverter局限性：\",\"缺少Source TYpe和Target Type前置判断\",\"单一类型转换实现复杂\",\"GenericConverter优化接口 - ConditionalGenericConverter\",\"复合类型转换 ：org.springframework.core.convert.converter.GenericConverter\",\"类型条件判断：org.springframework.core.convert.converter.ConditionalConverter\"]},\"1091\":{\"h\":\"扩展Spring类型转换器\",\"t\":[\"扩展的步骤：\",\"实现转换器接口 \",\"org.springframework.core.convert.converter.Converter\",\"org.springframework.core.convert.converter.ConverterFatory\",\"org.springframework.core.convert.converter.GenericConverter\",\"注册转换器实现 \",\"通过ConversionServiceFactoryBean（Spring Bean）\",\"通过org.springframework.core.convert.ConversionService（API）\",\"相关的示例如下，步骤一：\",\"public class PropertiesToStringConverter implements ConditionalGenericConverter { @Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return Properties.class.equals(sourceType.getObjectType()) && String.class.equals(targetType.getObjectType()); } @Override public Set<ConvertiblePair> getConvertibleTypes() { return Collections.singleton(new ConvertiblePair(Properties.class, String.class)); } @Override public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { Properties properties = (Properties) source; StringBuilder textBuilder = new StringBuilder(); for (Map.Entry<Object, Object> entry : properties.entrySet()) { textBuilder.append(entry.getKey()).append(\\\"=\\\").append(entry.getValue()).append(System.getProperty(\\\"line.separator\\\")); } return textBuilder.toString(); } } \",\"步骤二：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:util=\\\"http://www.springframework.org/schema/util\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd' http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\\\"> <bean id=\\\"user\\\" class=\\\"org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User\\\"> <property name=\\\"id\\\" value=\\\"1\\\"/> <property name=\\\"name\\\" value=\\\"吉永超\\\"/> <property name=\\\"context\\\"> <!-- Properties类型 --> <value> id = 1 name = 吉永超 </value> </property> <property name=\\\"contextAsText\\\" ref=\\\"context\\\"/> <!--properties类型要转成String --> </bean> <util:properties id=\\\"context\\\"> <prop key=\\\"id\\\">1</prop> <prop key=\\\"name\\\">jiyongchao</prop> </util:properties> <!-- 声明ConversionServiceFactoryBean--> <bean id=\\\"conversionService\\\" class=\\\"org.springframework.context.support.ConversionServiceFactoryBean\\\"> <property name=\\\"converters\\\" value=\\\"org.jyc.thinking.in.spring.conversion.PropertiesToStringConverter\\\"/> </bean> </beans> \",\"需要格外注意的是，在注册ConversionServiceFactoryBean的时候，一定要指定名称为conversionService，因为在beanFactory进行查找的时候，会根据名称和类型共同查找，名称固定为conversionService。\"]},\"1092\":{\"h\":\"统一类型转换服务\",\"t\":[\"org.springframework.core.convert.ConversionService说明：\",\"实现类型\",\"说明\",\"GenericConversionService\",\"通用ConversionService模板实现，不内置转化器实现\",\"DefaultConversionService\",\"基础ConversionService实现，内置常用转化器实现\",\"FormattingConversionService\",\"通用Formatter + GenericConversionService实现，不内置转化器和Formatter实现\",\"DefaultFormattingConversionService\",\"DefaultConversionService + 格式化 实现（如：JSR-354 Money & Currency，JSR-310 Date-Time）\"]},\"1093\":{\"h\":\"ConversionService作为依赖\",\"t\":[\"类型转换器底层接口 - org.springframework.beans.TypeConverter\",\"起始版本：Spring 2.0\",\"核心方法 - convertlfNecessary重载方法\",\"抽象实现 - org.springframework.beans.TypeConverterSupport\",\"简单实现 - org.springframework.beans.SimpleTypeConverter\",\"类型转换器底层抽象实现 - org.springframework.beans.TypeConverterSupport\",\"实现接口 - org.springframework.beans.TypeConverter\",\"扩展实现 - org.springframework.beans.PropertyEditorRegistrySupport\",\"委派实现 - org.springframework.beans.TypeConverterDelegate\",\"类型转换器底层委派实现 - org.springframework.beans.TypeConverterDelegate\",\"构造来源 - org.springframework.beans.AbstractNestablePropertyAccessor实现 \",\"org.springframework.beans.BeanWrapperImpl\",\"依赖 - java.beans.PropertyEditor实现 \",\"默认内建时间 - org.springframework.beans.PropertyEditorRegistrySupport#registerDefaultEditors\",\"可选依赖 - org.springframework.core.convert.ConversionService实现\",\"整体的流程关键节点如下：\",\"AbstractApplicationContext -> \\\"conversionService\\\" ConversionService Bean -> configurableBeanFactory#setConversionService(conversionService) -> AbstractAutowireCapableBeanFactory#instantiateBean -> AbstractBeanFactory#getConversionServicee -> BeanDefinition -> BeanWrapper -> 属性转换(数据来源：PropertyValues) -> setPropertyValues(PropertyValues) -> TypeConvert#convertIfNecessnary -> TypeConverterDelegate -> PropertyEditor or ConversionService\"]},\"1094\":{\"h\":\"面试题\"},\"1095\":{\"h\":\"Spring类型转换实现有哪些？\",\"t\":[\"基于JavaBeans PropertyEditor接口实现\",\"Spring 3.0+通用类型转换实现\"]},\"1096\":{\"h\":\"Spring类型转换器接口有哪些？\",\"t\":[\"类型转换接口 - org.springframework.core.convert.converter.Converter\",\"通用类型转换接口 - org.springframework.core.convert.converter.GenericConverter\",\"类型条件接口 - org.springframework.core.convert.converter.ConditionalConverter\",\"综合类型转换接口 - org.springframework.core.convert.converter.ConditionalGenericConverter\"]},\"1097\":{\"h\":\"TypeDescriptor是如何处理泛型？\",\"t\":[\"// ...\"]},\"1098\":{\"h\":\"Java泛型基础\",\"t\":[\"泛型类型：\",\"泛型类型是在类型上参数化的泛型类或接口\",\"泛型的使用场景：\",\"编译时强制类型检查\",\"避免类型强转\",\"实现通用算法\",\"泛型类型擦写：\",\"泛型被引入到Java语言中，以便在编译时提供更严格的类型检查并支持泛型编程。类型擦除确保不会为参数化类型创建新类；因此，泛型不会产生运行时开销。为了实现泛型，编译器将类型擦除应用于： \",\"将泛型类型中的所有类型参数替换为其边界，如果类型参数是无边界的，则将其替换为\\\"Object\\\"。因为，生成的字节码只包含普通类、接口和方法\",\"必要时插入类型转换以保持类型安全\",\"生成桥方法以保留扩展泛型类中的多态性\"]},\"1099\":{\"h\":\"Java 5类型接口\",\"t\":[\"Java 5类型接口 - java.lang.reflect.Type\",\"派生类或接口\",\"说明\",\"java.lang.Class\",\"Java类API，如java.lang.String\",\"java.lang.reflect.GenericArrayType\",\"泛型数组类型\",\"java.lang.reflect.ParameterizedType\",\"泛型参数类型\",\"java.lang.reflect.TypeVariable\",\"泛型类型变量，如Collection<E> 中的E\",\"java.lang.reflect.WildcardType\",\"泛型统配类型\",\"Java泛型反射API：\",\"类型\",\"API\",\"泛型信息\",\"java.lang.Class#getGenericInfo\",\"泛型参数\",\"java.lang.reflect#ParameterizedType\",\"泛型父类\",\"java.lang.Class#getGenericSuperclass\",\"泛型接口\",\"java.lang.Class#getGenericInterfaces\",\"泛型声明\",\"java.lang.reflect#GenericDeclaration\",\"相关的示例：\",\"public class GenericAPIDemo { public static void main(String[] args) { // 原生类型 int long float Class intClass = int.class; // 数组类型 int[],Object[] Class objectArrayClass = Object[].class; // 原始类型 raw types: java.lang.String Class rawClass = String.class; // 泛型参数类型 parameterized Type ParameterizedType parameterizedType = (ParameterizedType) ArrayList.class.getGenericSuperclass(); // parameterizedType.getRawType() = java.util.AbstractList; //泛型类型变量 Type Variable System.out.println(parameterizedType.toString()); // <E> Type[] typeVariables = parameterizedType.getActualTypeArguments(); // Stream.of(parameterizedType.getActualTypeArguments()).forEach(System.out::println); Stream.of(typeVariables).map(TypeVariable.class::cast).forEach(System.out::println); } } \"]},\"1100\":{\"h\":\"Spring泛型类型辅助类\",\"t\":[\"核心API - org.springframework.core.GenericTypeResolver\",\"版本支持[2.5.2,）\",\"处理类型相关（Type）相关方法\",\"resolveReturnType\",\"resolveType\",\"处理泛型参数类型（ParameterizedType）相关方法\",\"resolveReturnTypeArgument\",\"resolveTypeArgument\",\"resolveTypeArguments\",\"处理泛型类型变量（TypeVariable）相关方法\",\"getTypeVariableMap\",\"相关的示例：\",\"public class GenericTypeResolverDemo { public static void main(String[] args) throws Exception { // String Comparable<String> 具体化 displayReturnTypeGenericInfo(GenericTypeResolverDemo.class, Comparable.class, \\\"getString\\\"); // ArrayList<Object>是List泛型参数类型的具体化 displayReturnTypeGenericInfo(GenericTypeResolverDemo.class, List.class, \\\"getList\\\"); // StringList也是List泛型类型的具体化 displayReturnTypeGenericInfo(GenericTypeResolverDemo.class, List.class, \\\"getStringList\\\"); // 具备 ParameterizedType返回。否则null // TypeVariable Map<TypeVariable, Type> typeVariableMap = GenericTypeResolver.getTypeVariableMap(StringList.class); System.out.println(typeVariableMap); } public static StringList getStringList() { return null; } public static ArrayList<Object> getList() { // 泛型参数具体化（字节码有记录） return null; } public static String getString() { return null; } private static void displayReturnTypeGenericInfo(Class<?> containingClass, Class<?> generic, String methodName, Class... argumentTypes) throws Exception { Method method = containingClass.getMethod(methodName, argumentTypes); Class<?> returnType = GenericTypeResolver.resolveReturnType(method, containingClass); Class<?> returnTypeArgument = GenericTypeResolver.resolveReturnTypeArgument(method, generic); // 常规类作为方法返回值 System.out.printf(\\\"GenericTypeResolver.resolveReturnType(%s,%s) = %s\\\\n\\\", methodName, containingClass.getSimpleName(), returnType); // 常规类型不具备泛型参数类型List<E> System.out.printf(\\\"GenericTypeResolver.resolveReturnTypeArgument(%s,%s) = %s\\\\n\\\", methodName, containingClass.getSimpleName(), returnTypeArgument); } static class StringList extends ArrayList<String> { // 泛型参数具体化（字节码有记录） } } \"]},\"1101\":{\"h\":\"泛型集合类型辅助类\",\"t\":[\"核心API - org.springframework.core.GenericCollectionTypeSolver\",\"版本支持：[2.0,4.3]\",\"替换实现：org.springframework.core.ResolvableType\",\"处理Collection相关\",\"getCollection*Type\",\"getMapValue*Type\",\"GenericCollectionTypeSolver在高版本的Spring中已经移除，建议使用它的替换实现ResolvableType。\"]},\"1102\":{\"h\":\"Spring方法参数封装\",\"t\":[\"核心API - org.springframework.core.MethodParameter\",\"起始版本：[2.0,)\",\"元信息\",\"关联的方法 - Method\",\"关联的构造器 - Constuctor\",\"构造器或方法参数索引 - parameterIndex\",\"构造器或方法参数类型 - parameterType\",\"构造器或方法参数泛型类型 - genericParameterType\",\"构造器或方法参数名称 - parameterName\",\"所在的类 - containingClass\",\"parameterName是java8之后才存在。\"]},\"1103\":{\"h\":\"ResolvableType\",\"t\":[\"核心API - org.springframework.core.ResolvableType\",\"起始版本：[4.0,)\",\"扮演角色：GenericTypeResolver和GenericCollectionTypeResolver替代者\",\"工厂方法：for*方法\",\"转换方法：as*方法\",\"处理方法：resolve*方法\",\"官方给出的示例：\",\" private HashMap<Integer, List<String>> myMap; public void example() { ResolvableType t = ResolvableType.forField(getClass().getDeclaredField(\\\"myMap\\\")); t.getSuperType(); // AbstractMap<Integer, List<String>> t.asMap(); // Map<Integer, List<String>> t.getGeneric(0).resolve(); // Integer t.getGeneric(1).resolve(); // List t.getGeneric(1); // List<String> t.resolveGeneric(1, 0); // String } \",\"我们来使用相关的API：\",\"public class ResolvableTypeDemo { public static void main(String[] args) throws Exception { // 工厂创建 // StringList <- ArrayList <- AbstractList <- list ResolvableType resolvableType = ResolvableType.forClass(GenericTypeResolverDemo.StringList.class); resolvableType.getSuperType(); //ArrayList resolvableType.getSuperType().getSuperType(); // AbstractList System.out.println(resolvableType.asCollection().resolve()); //获取Raw Type System.out.println(resolvableType.asCollection().resolveGeneric(0)); // 获取泛型参数类型 } } \",\"ResolvableType也有两个局限性，第一，ResolvableType无法处理泛型擦写，第二，ResolvableType无法处理非具体化的ParameterizedType。\"]},\"1104\":{\"h\":\"面试题\"},\"1105\":{\"h\":\"Java泛型擦写是发生在编译时，还是运行时？\",\"t\":[\"运行时。\"]},\"1106\":{\"h\":\"请介绍Java 5 Type类型的派生类或接口?\",\"t\":[\"见Java5 类型接口\"]},\"1107\":{\"h\":\"请说明ResolvableType的设计优势\",\"t\":[\"简化Java5 Type API开发，屏蔽复杂API的运用，如ParameterizedType\",\"不变性设计（Immutability）\",\"Fluent API设计（Builder模式），链式（流式）编程\"]},\"1108\":{\"h\":\"Java事件/监听器编程模型\",\"t\":[\"设计模式 - 观察者模式扩展 \",\"可观者对象（消息发送者） - java.util.Observable\",\"观察者 - java.util.Observer\",\"标准化接口 \",\"事件对象 - java.util.EventObject\",\"事件监听器 - java.util.EventListener\",\"使用的示例：\",\"public class ObserverDemo { public static void main(String[] args) { Observable observable = new EventObservable(); // 添加观察者（监听者） observable.addObserver(new EventObserver()); observable.notifyObservers(\\\"hello world\\\"); } static class EventObservable extends Observable { @Override public synchronized void setChanged() { super.setChanged(); } @Override public void notifyObservers(Object arg) { setChanged(); super.notifyObservers(new EventObject(arg)); clearChanged(); } } static class EventObserver implements Observer, EventListener { @Override public void update(Observable o, Object event) { EventObject eventObject = (EventObject) event; System.out.println(\\\"收到事件\\\" + eventObject); } } } \",\"这里由于Observable的setChanged是protected，所以需要实现子类，重写这个方法，并且为了更方便的操作，我们一般也会扩充notifyObservers的实现逻辑。\"]},\"1109\":{\"h\":\"面向接口的事件/监听器设计模式\",\"t\":[\"事件/监听器场景举例\",\"Java技术规范\",\"事件接口\",\"监听器接口\",\"JavaBeans\",\"java.beans.PropertyChangeEvent\",\"java.beans.PropertyChangeListener\",\"Java AWT\",\"java.awt.event.MouseEvent\",\"java.awt.event.MouseListener\",\"Java Swing\",\"javax.swing.event.MenuEvent\",\"javax.swing.event.MenuListener\",\"Java Preference\",\"java.util.prefs.PreferenceChangeEvent\",\"java.util.prefs.PreferenceChangeListener\"]},\"1110\":{\"h\":\"面向注解的事件/监听器设计模式\",\"t\":[\"事件/监听器注解场景举例\",\"Java 技术规范\",\"事件注解\",\"监听器注解\",\"Servlet 3.0+\",\"@javax.servlet.annotation.WebListener\",\"JPA 1.0+\",\"@javax.persistence.PostPersist\",\"Java Common\",\"@PostConstruct\",\"EJB 3.0+\",\"@javax.ejb.PrePassivate\",\"JSF 2.0+\",\"@javax.faces.event.ListenerFor\"]},\"1111\":{\"h\":\"Spring标准事件 ApplicationEvent\",\"t\":[\"Java标准事件 java.util.EventObject扩展：\",\"扩展特性：事件发生事件戳\",\"Spring应用上下文ApplicationEvent扩展 - ApplicationContextEvent\",\"Spring应用上下文（ApplicationContext作为事件源）\",\"具体实现： \",\"org.springframework.context.event.ContextClosedEvent\",\"org.springframework.context.event.ContextRefreshedEvent\",\"org.springframework.context.event.ContextStartedEvent\",\"org.springframework.context.event.ContextStoppedEvent\"]},\"1112\":{\"h\":\"基于接口的Spring事件监听器\",\"t\":[\"Java标准事件监听器java.util.EventListener扩展\",\"扩展接口 - org.springframework.context.ApplicationListener\",\"设计特点：单一类型事件处理\",\"处理方法：onApplicationEvent(ApplicationEvent event);\",\"事件类型：org.springframework.context.ApplicationEvent\",\"相关的示例：\",\"public class ApplicationListenerDemo { public static void main(String[] args) { GenericApplicationContext context = new GenericApplicationContext(); // 向Spring应用上下文注册事件 context.addApplicationListener(new ApplicationListener<ApplicationEvent>() { @Override public void onApplicationEvent(ApplicationEvent event) { System.out.println(\\\"接收到Spring事件： \\\" + event); } }); context.refresh(); context.start(); context.close(); } } \"]},\"1113\":{\"h\":\"基于注解的Spring事件监听器\",\"t\":[\"Spring注解 - @org.springframework.context.event.EventListener\",\"特性\",\"说明\",\"设计特点\",\"支持多ApplicationEvent类型，无需接口约束\",\"注解目标\",\"方法\",\"是否支持异步执行\",\"支持\",\"是否支持泛型类型事件\",\"支持\",\"是指支持顺序控制\",\"支持，配合@Order注解控制\",\"相关的示例：\",\"@EnableAsync public class ApplicationListenerDemo { public static void main(String[] args) { // GenericApplicationContext context = new GenericApplicationContext(); AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); // 将引导类作为配置类 context.register(ApplicationListenerDemo.class); // 方法一：基于Spring接口：向Spring应用上下文注册事件 context.addApplicationListener(new ApplicationListener<ApplicationEvent>() { @Override public void onApplicationEvent(ApplicationEvent event) { println(\\\"ApplicationListene接收到Spring事件： \\\" + event); } }); // 方法二：基于Spring注解@EventListener context.refresh(); context.start(); context.close(); } @EventListener @Order(1) public void onApplicationEvent(ContextRefreshedEvent event) { println(\\\"@EventListener1接收到Spring事件\\\"); } @EventListener @Order(2) public void onApplicationEvent1(ContextRefreshedEvent event) { println(\\\"@EventListener2接收到Spring事件\\\"); } @EventListener @Async public void onApplicationEvent(ContextStartedEvent event) { println(\\\"@EventListener接收到Spring事件（异步）\\\"); } @EventListener public void onApplicationEvent(ContextClosedEvent event) { println(\\\"@EventListener接收到Spring事件\\\"); } private static void println(Object printable) { System.out.printf(\\\"[线程：%s] : %s\\\\n\\\", Thread.currentThread(), printable); } } \"]},\"1114\":{\"h\":\"注册Spring ApplicationListener\",\"t\":[\"方法一：ApplicationListener作为Spring Bean注册\",\"方法二：通过ConfigurableApplicationContext API注册\",\"第二种方式在之前我们已经讨论过了，这里第一种方式也比较容易：\",\" static class MyApplicationListener implements ApplicationListener { @Override public void onApplicationEvent(ApplicationEvent event) { println(\\\"MyApplicationListener接收到Spring事件\\\"); } } \",\"然后将MyApplicationListener标注为Spring Bean即可。\"]},\"1115\":{\"h\":\"Spring事件发布器\",\"t\":[\"方法一：通过ApplicationEventPublisher发布Spring事件 \",\"获取ApplicationEventPublisher \",\"依赖注入\",\"方法二：通过ApplicationEventPublisher发布Spring事件 \",\"获取ApplicationEventMulticaster \",\"依赖注入\",\"依赖查找\",\"使用ApplicationListenerDemo实现ApplicationEventPublisherAware接口：\",\" @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) { applicationEventPublisher.publishEvent(new ApplicationEvent(\\\"hello world\\\") { }); applicationEventPublisher.publishEvent(\\\"hello world\\\"); } \"]},\"1116\":{\"h\":\"Spring层次性上下文事件传播\",\"t\":[\"发生说明\",\"当Spring应用出现多层次Spring应用上下文（ApplicationContext）时，如Spring WebMVC、Spring Boot或Spring Cloud场景下，由子ApplicationContext发起Spring事件可能会传递到其Parent ApplicationContext（直到Root）的过程。\",\"如何避免\",\"定位Spring事件源（ApplicationContext）进行过滤处理\",\"public class HierarchicalSpringEventPropagateDemo { public static void main(String[] args) { // 1.创建parent Spring应用上下文 AnnotationConfigApplicationContext parentContent = new AnnotationConfigApplicationContext(); // 2.创建current Spring应用上下文 parentContent.setId(\\\"parent-context\\\"); parentContent.register(MyListener.class); // 3.current -> parent AnnotationConfigApplicationContext currentContent = new AnnotationConfigApplicationContext(); parentContent.setId(\\\"current-context\\\"); currentContent.setParent(parentContent); currentContent.register(MyListener.class); parentContent.refresh(); // 这里会触发两次，因为会出发父应用上下文的事件 currentContent.refresh(); // 注意这里的顺序，不能颠倒 currentContent.close(); parentContent.close(); } static class MyListener implements ApplicationListener<ApplicationContextEvent> { // 这里必须是静态字段 private static Set<ApplicationEvent> processedEvents = new LinkedHashSet<>(); @Override public void onApplicationEvent(ApplicationContextEvent event) { if (processedEvents.add(event)) { System.out.printf(\\\"监听到 Spring应用上下文[ID：%s]事件： %s\\\\n\\\", event.getApplicationContext().getId(), event.getClass().getSimpleName()); } } } } \"]},\"1117\":{\"h\":\"Spring内建事件\",\"t\":[\"ApplicationContextEvent派生事件：\",\"ContextRefreshedEvent：Spring应用上下文就绪事件\",\"ContextStartedEvent：Spring应用上下文启动事件\",\"ContextStoppedEvent：Spring应用上下文停止事件\",\"ContextClosedEvent：Spring应用上下文关闭事件\"]},\"1118\":{\"h\":\"Payload事件\",\"t\":[\"Spring Payload事件 - org.springframework.context.PayloadApplicationEvent\",\"使用场景：简化Spring事件发送，关注事件源主体\",\"发送方法：ApplicationEventPublisher#publishEvent(Object event)\",\"这个事件使用的很少，并且对于泛型的处理还存在Bug，可以使用ApplicationEventPublisher#publishEvent方法。\"]},\"1119\":{\"h\":\"自定义Spring事件\",\"t\":[\"扩展 org.springframework.context.ApplicationEvent\",\"实现 org.springframework.context.ApplicationListener\",\"注册 org.springframework.context.ApplicationListener\",\"我们来实现一个自定义的Spring事件，第一步：\",\"public class MySpringEvent extends ApplicationEvent { public MySpringEvent(String message) { super(message); } @Override public Object getSource() { return (String) super.getSource(); } @Override public String toString() { return super.toString(); } } \",\"第二步，实现自定义的事件监听器：\",\"public class MySpringEventListener implements ApplicationListener<MySpringEvent> { @Override public void onApplicationEvent(MySpringEvent event) { System.out.printf(\\\"[线程：%s] :监听到事件 %s\\\\n\\\", Thread.currentThread().getName(), event); } } \",\"第三步，注册自定义事件监听器：\",\"public class CustomizedSpringEventDemo { public static void main(String[] args) { GenericApplicationContext context = new GenericApplicationContext(); context.addApplicationListener(new MySpringEventListener()); context.refresh(); context.publishEvent(new MySpringEvent(\\\"hello,world\\\")); context.close(); } } \"]},\"1120\":{\"h\":\"依赖注入ApplicationEventPublisher\",\"t\":[\"通过ApplicationEventPublisherAware回调接口\",\"通过@Autowired ApplicationEventPublisher\",\"相关的示例：\",\"public class InjectingApplicationEventPublisherDemo implements ApplicationEventPublisherAware { @Autowired private ApplicationEventPublisher applicationEventPublisher; @Autowired private ApplicationContext applicationContext; @PostConstruct public void init() { // #3 applicationEventPublisher.publishEvent(new MySpringEvent(\\\"the event from @Autowired ApplicationEventPublisher\\\")); // #4 applicationContext.publishEvent(new MySpringEvent(\\\"the event from @Autowired ApplicationContext\\\")); } public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(InjectingApplicationEventPublisherDemo.class); context.addApplicationListener(new MySpringEventListener()); context.refresh(); context.close(); } @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) { applicationEventPublisher.publishEvent(new MySpringEvent(\\\"the event from ApplicationEventPublisher\\\")); //#1 } public void setApplicationContext(ApplicationContext applicationContext) { //#2 applicationEventPublisher.publishEvent(\\\"the event from ApplicationContext\\\"); } } \"]},\"1121\":{\"h\":\"依赖查找ApplicationEventMulticaster\",\"t\":[\"查找条件：\",\"Bean名称：\\\"applicationEventMulticaster\\\"\",\"Bean类型：org.springframework.context.event.ApplicationEventMulticaster\",\"依赖查找的细节可以在AbstractApplicationContext#initApplicationEventMulticaster中看到：\",\"protected void initApplicationEventMulticaster() { ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) { this.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class); if (logger.isTraceEnabled()) { logger.trace(\\\"Using ApplicationEventMulticaster [\\\" + this.applicationEventMulticaster + \\\"]\\\"); } } else { // 如果不存在会直接new一个，也就是说初始化之后，ApplicationEventMulticaster不会为空 this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory); beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster); if (logger.isTraceEnabled()) { logger.trace(\\\"No '\\\" + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + \\\"' bean, using \\\" + \\\"[\\\" + this.applicationEventMulticaster.getClass().getSimpleName() + \\\"]\\\"); } } } \"]},\"1122\":{\"h\":\"ApplicationEventPublisher底层实现\",\"t\":[\"底层实现：\",\"接口：org.springframework.context.event.ApplicationEventMulticaster\",\"抽象类：org.springframework.context.event.AbstractApplicationEventMulticaster\",\"实现类：org.springframework.context.event.SimpleApplicationEventMulticaster\",\"早期的Spring，ApplicationEventPublisherAware与BeanPostProcessor不能同时使用，后面的版本采用了事件回放的机制修复了这个BUG。\"]},\"1123\":{\"h\":\"同步和异步Spring事件广播\",\"t\":[\"基本实现类 - org.springframework.context.event.SimpleApplicationEventMulticaster\",\"模式切换： setTaskExecutor(Executor taskExecutor) \",\"默认模式：同步\",\"异步模式：如java.util.concurrent.ThreadPoolExecutor\",\"设计缺陷：非基于接口契约编程\",\"基于编码的同步和异步事件广播示例：\",\"public class AsyncEventHandlerDemo { public static void main(String[] args) { GenericApplicationContext context = new GenericApplicationContext(); context.addApplicationListener(new MySpringEventListener()); context.refresh(); // 初始化 ApplicationEventMulticaster // 依赖查找 ApplicationEventMulticaster ApplicationEventMulticaster applicationEventMulticaster = context.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class); if (applicationEventMulticaster instanceof SimpleApplicationEventMulticaster) { SimpleApplicationEventMulticaster simpleApplicationEventMulticaster = (SimpleApplicationEventMulticaster) applicationEventMulticaster; //切换 taskExecutor ExecutorService taskExecutor = Executors.newSingleThreadExecutor(new CustomizableThreadFactory(\\\"my-spring-event-thread-pool\\\")); // 同步 -> 异步 simpleApplicationEventMulticaster.setTaskExecutor(taskExecutor); // 添加ContextClosedEvent事件处理 applicationEventMulticaster.addApplicationListener(new ApplicationListener<ContextClosedEvent>() { @Override public void onApplicationEvent(ContextClosedEvent event) { if (!taskExecutor.isShutdown()) { taskExecutor.shutdown(); } } }); } context.publishEvent(new MySpringEvent(\\\"hello,world\\\")); context.close(); } } \",\"除了这种编码的方式，还可以通过注解的方式。\",\"基于注解 - org.springframework.context.event.EventListener\",\"模式切换 \",\"默认模式：同步\",\"异步模式：标注@org.springframework.scheduling.annotation.Async\",\"实现限制：无法直接实现同步/异步动态切换\",\"基于注解方式的示例：\",\"@EnableAsync // 激活Spring异步特性 public class AnnotatedAsyncEventHandlerDemo { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(AnnotatedAsyncEventHandlerDemo.class); context.addApplicationListener(new MySpringEventListener()); context.refresh(); // 初始化 ApplicationEventMulticaster context.publishEvent(new MySpringEvent(\\\"hello,world\\\")); context.close(); } @EventListener @Async public void onEvent(MySpringEvent event) { System.out.printf(\\\"[线程：%s] : %s\\\\n\\\", Thread.currentThread().getName(), event); } @Bean public Executor taskExecutor() { ExecutorService taskExecutor = newSingleThreadExecutor(new CustomizableThreadFactory(\\\"my-spring-event-thread-pool-a\\\")); return taskExecutor; } } \"]},\"1124\":{\"h\":\"Spring事件异常处理\",\"t\":[\"Spring3.0错误处理接口 - org.springframework.util.ErrorHandler\",\"使用场景：\",\"Spring事件（Events） \",\"SimpleApplicationEventMulticaster Spring 4.1开始支持\",\"Spring本地调度（Scheduling） \",\"org.springframework.scheduling.concurrent.ConcurrentTaskScheduler\",\"org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler\",\"实现的核心代码在SimpleApplicationEventMulticaster#invokeListener：\",\"protected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event) { ErrorHandler errorHandler = getErrorHandler(); if (errorHandler != null) { try { doInvokeListener(listener, event); } catch (Throwable err) { errorHandler.handleError(err); } } else { doInvokeListener(listener, event); } } \"]},\"1125\":{\"h\":\"Spring事件/监听实现原理\",\"t\":[\"核心类 - org.springframework.context.event.SimpleApplicationEventMulticaster\",\"设计模式：观察者模式扩展 \",\"被观察者 - org.springframework.context.ApplicationListener \",\"API添加\",\"依赖查找\",\"通知对象 - org.springframework.context.ApplicationEvent\",\"执行模式：同步/异步\",\"异常处理：org.springframework.util.ErrorHandler\",\"泛型处理：org.springframework.core.ResolvableType\",\"监听事件的时候，Spring还会处理ApplicationEvent的子孙类，包含所有层次的事件。\"]},\"1126\":{\"h\":\"SpringBoot事件\",\"t\":[\"SpringBoot事件\",\"事件类型\",\"发生时机\",\"ApplicationStartingEvent\",\"当SpringBoot应用已启动时\",\"ApplicationStartedEvent\",\"当SpringBoot应用已启动时\",\"ApplicationEnvironmentPreparedEvent\",\"当SpringBoot Environment实例已准备时\",\"ApplicationPreparedEvent\",\"当SpringBoot应用预备时\",\"ApplicationReadyEvent\",\"当SpringBoot应用完全可用时\",\"ApplicationFailedEvent\",\"当SpringBoot应用启动失败时\",\"SpringCloud事件\",\"事件类型\",\"发生时机\",\"EnvironmentChangeEvent\",\"当Environment示例配置属性发生变化时\",\"HeartbeatEvent\",\"当DiscoveryClient客户端发送心跳时\",\"InstancePreRegisteredEvent\",\"当服务实例注册前\",\"InstanceRegisteredEvent\",\"当服务实例注册后\",\"RefreshEvent\",\"当RefreshEndpoint被调用时\",\"RefreshScopedRefreshedEvent\",\"当Refresh Scope Bean刷新后\"]},\"1127\":{\"h\":\"面试题\"},\"1128\":{\"h\":\"Spring事件核心接口/组件？\",\"t\":[\"Spring事件 - org.springframework.context.ApplicationEvent\",\"Spring事件监听器 - org.springframework.context.ApplicationListener\",\"Spring事件发布器 - org.springframework.context.ApplicationEventPublisher\",\"Spring事件广播器 - org.springframework.context.event.ApplicationEventMulticaster\"]},\"1129\":{\"h\":\"Spring同步和异步事件处理的使用场景？\",\"t\":[\"Spring同步事件 - 绝大部分Spring使用场景，如ContextRefreshedEvent\",\"Spring异步事件 - 主要 @EventListener与@Async配合，实现异步处理，不阻塞主线程，比如长时间的数据计算任务等。不要轻易调整SimpleApplicationEventMulticaster中关联的taskExecutor对象，除非使用者非常了解Spring事件机制，否则容易出现异常行为。\"]},\"1130\":{\"h\":\"@EventListener的工作原理\",\"t\":[\"// ...\",\"Spring注解驱动的编程发展的大概历程：\",\"注解驱动的启蒙时代：Spring Framework 1.x\",\"注解驱动的过渡时代：Spring Framework 2.x\",\"注解驱动的黄金时代：Spring Framework 3.x\",\"注解驱动的完善时代：Spring Framework 4.x\",\"注解驱动的当下时代：Spring Framework 5.x\"]},\"1131\":{\"h\":\"Spring核心注解场景分类\",\"t\":[\"Spring模式注解：\",\"Spring注解\",\"场景说明\",\"起始版本\",\"@Repository\",\"数据仓库模式注解\",\"2.0\",\"@Component\",\"通用组件模式注解\",\"2.5\",\"@Service\",\"服务模式注解\",\"2.5\",\"@Controller\",\"Web控制器模式注解\",\"2.5\",\"@Configuration\",\"配置类模式注解\",\"3.0\",\"装配注解：\",\"Spring注解\",\"场景说明\",\"起始版本\",\"@ImportResource\",\"替换XML元素\",\"2.5\",\"@Import\",\"导入Configuration类\",\"2.5\",\"@ComponentScan\",\"扫描指定package下标注Spring模式注解的类\",\"3.1\",\"依赖注入注解：\",\"Spring注解\",\"场景说明\",\"起始版本\",\"@Autowired\",\"Bean依赖注入，支持多种依赖查找方式\",\"2.5\",\"@Qualifer\",\"细粒度的@Autowired依赖查找\",\"2.5\"]},\"1132\":{\"h\":\"Spring注解编程模型\",\"t\":[\"编程模型概览：\",\"元注解（Meta-Annotations）\",\"Spring模式注解（Stereotype Annotations）\",\"Spring组合注解（Composed Annotations）\",\"Spring注解属性别名和覆盖（Attribute Aliases and Overrides）\"]},\"1133\":{\"h\":\"Spring元注解\",\"t\":[\"除了直接使用JDK 定义好的注解，我们还可以自定义注解，在JDK 1.5中提供了4个标准的用来对注解类型进行注解的注解类，我们称之为 meta-annotation（元注解），他们分别是：\",\"@Target\",\"@Retention\",\"@Documented\",\"@Inherited\",\"Target注解的作用是描述注解的使用范围。Reteniton注解的作用是，描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时）。Documented注解的作用是，描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。Inherited注解的作用是，使被它修饰的注解具有继承性（如果某个类使用了被@Inherited修饰的注解，则其子类将自动具有该注解）。\",\"除了以上四种标准，还有我们之前提到过的@Repeatable。\"]},\"1134\":{\"h\":\"Spring模式注解\",\"t\":[\"模式注解是一种注解，这种注解是用于去声明应用中扮演\\\"组件\\\"角色的类，@Component是一种通用的组件注解，标注这个注解的类会被Spring扫描。\",\"由于注解无法像接口或者类一样继承，因此只能采用使用注解描述注解的方式。\",\"@Component\\\"派生性\\\"原理：\",\"核心组件 - org.springframework.context.annotation.ClassPathBeanDefinitionScanner \",\"org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider\",\"资源处理 - org.springframework.core.io.support.ResourcePatternResolver\",\"资源 - 类元信息 \",\"org.springframework.core.type.classreading.MetadataReaderFactory\",\"类元信息 - org.springframework.core.type.ClassMetadata \",\"ASM实现 - org.springframework.core.type.classreading.ClassMetadataReadingVisitor\",\"反射实现 - org.springframework.core.type.StandardAnnotationMetadata\",\"注解元信息 - org.springframework.core.type.AnnotationMetadata \",\"ASM实现 - org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor\",\"反射实现 - org.springframework.core.type.StandardAnnotationMetadata\",\"我们定义一个测试类：\",\"@MyComponent public class TestClass { } \",\"定义一个具有\\\"派生性\\\"的注解：\",\"@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Component // 元注解，实现@Component public @interface MyComponent { } \",\"测试是否生效：\",\"@ComponentScan(basePackages = \\\"org.jyc.thinking.in.spring.annotation\\\") public class ComponentScanDemo { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(ComponentScanDemo.class); context.refresh(); // 从Spring 4.0开始支持多层次@Component派生 TestClass bean = context.getBean(TestClass.class); System.out.println(bean); context.close(); } } \"]},\"1135\":{\"h\":\"Spring 组合注解\",\"t\":[\"Spring组合注解（Composed Annotations）中的元注允许是Spring模式注解（Stereotype Annotation）与其他Spring功能性注解的任意组合。\",\"比较典型的例子就是在SpringBoot场景中的SpringBootApplication：\",\"@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { } \"]},\"1136\":{\"h\":\"Spring注解属性别名\",\"t\":[\"注解属性的别名实际上总共有两种，一种是显性的别名，一种是隐性的别名。\",\"显性的别名比较容易理解，在@ComponentScan中：\",\" @AliasFor(\\\"basePackages\\\") String[] value() default {}; @AliasFor(\\\"value\\\") String[] basePackages() default {}; \",\"此时basePackages和value就互为显性别名，下面是隐性别名的例子：\",\"@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @ComponentScan public @interface MyComponentScan { /** * 隐形别名,当被元标注的注解中的属性无法表达语义的时候，就需要额外增加attribute属性，如果没有attribute属性，就表示\\\"继承\\\" @AliasFor中的注解的属性 * <p> * 是注解的一种\\\"多态\\\"，子注解提供了新的属性方法引用\\\"父\\\"（元）注解中的属性方法 * * @return */ @AliasFor(annotation = ComponentScan.class, attribute = \\\"basePackages\\\") String[] scanBasePackages() default {}; /** * scanBasePackages -> @AliasFor ComponentScan.basePackages.value(显性别名) * * @AliasFor ComponentScan.basePackages.value 传递隐形别名,而且这种方式是支持多层次的 */ // @AliasFor(annotation = ComponentScan.class, attribute = \\\"value\\\") // String[] scanBasePackages() default {}; } \"]},\"1137\":{\"h\":\"Spring注解属性覆盖\",\"t\":[\"属性覆盖也有两种，一种是显性覆盖，一种是隐形覆盖：\",\"@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @MyComponentScan public @interface MyComponentScan2 { @AliasFor(annotation = MyComponentScan.class, attribute = \\\"scanBasePackages\\\") String[] BasePackages() default {}; /** * 隐形覆盖 * 在@MyComponentScan中也有scanBasePackages属性，如果注解中存在同名的就会覆盖掉元标注注解中的属性 * * @return */ String[] scanBasePackages() default {}; /** * 显性覆盖 * packages覆盖了scanBasePackages 同时覆盖了@MyComponentScan.scanBasePackages * * @return */ @AliasFor(\\\"scanBasePackages\\\") String[] packages() default {}; } \"]},\"1138\":{\"h\":\"Spring @Enable模块驱动\",\"t\":[\"@Eanable模块驱动是以@Enabke为前缀的注解驱动编程模型。所谓\\\"模块\\\"是指具备相同领域的功能组件的集合，组合形成一个独立的单元，比如Web MVC模块、AspectJ代理模块、Caching（缓存）模块、JMX（Java 扩展模块）、Async（异步处理）模块等。\",\"举例说明：\",\"@EnableWebMvc\",\"@EnableTranscationManagement\",\"@EnableCaching\",\"@EnableMBeanExport\",\"@EnaleAsync\",\"除了框架内建的这些实现，我们还可以自定义@Eanable模块：\",\"驱动注解：@Enable***\",\"导入注解：@Import具体实现\",\"具体以下三种实现均可： \",\"基于Configuration Class\",\"基于@ImportSelector\",\"基于@ImportBeanDefinitionRegistar接口实现\",\"首先演示第一种基于配置类实现，首先定义一个注解：\",\"@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(HelloWorldConfiguration.class) public @interface EnableHelloWorld { } \",\"然后定义相对应的配置类：\",\"@Configuration public class HelloWorldConfiguration { @Bean public String helloWorld() { return \\\"HelloWorld\\\"; } } \",\"最后进行测试：\",\"@EnableHelloWorld public class EnableModuleDemo { // 第一步：通过@Enable**命名 public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(EnableModuleDemo.class); context.refresh(); String bean = context.getBean(\\\"helloWorld\\\", String.class); System.out.println(bean); context.close(); } } \",\"第二种实现，首先定义ImportSelector的实现类：\",\"public class HelloWorldImportSelector implements ImportSelector { @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) { return new String[]{\\\"org.jyc.thinking.in.spring.annotation.HelloWorldConfiguration\\\"}; } } \",\"添加到@Enable注解：\",\"@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented // 第二步：通过@Import注解导入具体实现 //@Import(HelloWorldConfiguration.class) // 方法二：通过@ImportSelector接口实现 @Import(HelloWorldImportSelector.class) public @interface EnableHelloWorld { } \",\"第三种实现：\",\"public class HelloWorldImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { AnnotatedGenericBeanDefinition beanDefinition = new AnnotatedGenericBeanDefinition(HelloWorldConfiguration.class); BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition,registry); } } \",\"同样的，添加到@Enable注解上面：\",\"@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented // 第二步：通过@Import注解导入具体实现 //@Import(HelloWorldConfiguration.class) // 方法二：通过@ImportSelector接口实现 //@Import(HelloWorldImportSelector.class) //方法三：通过 ImportBeanDefinitionRegistrar @Import(HelloWorldImportBeanDefinitionRegistrar.class) public @interface EnableHelloWorld { } \"]},\"1139\":{\"h\":\"Spring条件注解\",\"t\":[\"Spring的条件注解主要有两种：\",\"基于配置条件注解 - @org.springframework.context.annotation.Profile \",\"关联对象 - org.springframework.core.env.Environment\",\"实现变化：从Spring 4.0开始，@Profile基于@Conditional实现\",\"基于编程条件注解 - org.springframework.context.annotation.Conditional \",\"关联对象 - org.springframework.context.annotation.Condition具体实现\",\"@Condtional实现原理大致如下：\",\"上下文对象 - org.springframework.context.annotation.ConditionContext\",\"条件判断 - org.springframework.context.annotation.ConditionEvaluator\",\"配置阶段 - org.springframework.context.annotation.ConfigurationCondition.ConfigurationPhase\",\"判断入口 - org.springframework.context.annotation.ConfigurationClassPostProcessor \",\"org.springframework.context.annotation.ConfigurationClassParser\",\"Profile注解的示例：\",\"public class ProfileDemo { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(ProfileDemo.class); // 获取Environment对象 ConfigurableEnvironment environment = context.getEnvironment(); // 默认的Profiles = [\\\"odd\\\"] environment.setDefaultProfiles(\\\"odd\\\"); // 添加活跃的Profiles environment.setActiveProfiles(\\\"even\\\"); context.refresh(); Integer number = context.getBean(\\\"number\\\", Integer.class); System.out.println(number); context.close(); } @Bean(name = \\\"number\\\") @Profile(\\\"odd\\\") public Integer odd() { return 1; } @Bean(name = \\\"number\\\") // @Profile(\\\"even\\\") @Conditional(EventProfileCondition.class) public Integer even() { return 2; } } \",\"实际上@Conditional注解的使用也可能会用到Profile属性：\",\"public class EventProfileCondition implements Condition { @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { // 条件上下文 Environment environment = context.getEnvironment(); return environment.acceptsProfiles(\\\"even\\\"); } } \",\"@Profile在Spring 4当中的实现方式：\",\"基于org.springframework.context.annotation.Condition接口实现：org.springframework.context.annotation.ProfileCondition，实现的源码如下：\",\"class ProfileCondition implements Condition { @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if (attrs != null) { for (Object value : attrs.get(\\\"value\\\")) { if (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) { return true; } } return false; } return true; } } \"]},\"1140\":{\"h\":\"SpringBoot和SpringCloud注解\",\"t\":[\"SpringBoot注解：\",\"注解\",\"场景说明\",\"起始版本\",\"@SpringBootConfiguration\",\"Spring Boot配置类\",\"1.4.0\",\"@SpringBootApplication\",\"Spring Boot应用引导注解\",\"1.2.0\",\"@EnableAutoConfiguration\",\"Spring Boot激活自动装配\",\"1.0.0\",\"SpringCloud注解：\",\"注解\",\"场景说明\",\"起始版本\",\"@SpringCloudApplication\",\"Spring Cloud应用引导注解\",\"1.0.0\",\"@EnableDiscovertClient\",\"Spring Cloud激活服务发现客户端注解\",\"1.0.0\",\"@EnableCircuitBreaker\",\"Spring Cloud激活熔断注解\",\"1.0.0\"]},\"1141\":{\"h\":\"面试题\"},\"1142\":{\"h\":\"Spring模式注解有哪些？\",\"t\":[\"@Compenent\",\"@Resository\",\"@Service\",\"@Controller\",\"@Configuration\"]},\"1143\":{\"h\":\"@EventListener的工作原理？\",\"t\":[\"源码导读 - org.springframework.context.event.EventListenerMethodProcessor\"]},\"1144\":{\"h\":\"@PropertySource工作原理\",\"t\":[\"// ...\",\"Environment接口主要有以下两个作用：\",\"统一的Spring配置属性管理\",\"SpringFramework 3.1开始引入Environment抽象，它统一Spring配置属性的存储，包括占位符处理和类型转换，不仅完整地替换PropertyPlaceholderConfigurer，而且还支持更丰富的配置属性源（PropertySource）\",\"条件化Spring Bean装配管理\",\"通过Environment Profiles信息，帮助Spring容器提供条件化地装配Bean\"]},\"1145\":{\"h\":\"Environment接口使用场景\",\"t\":[\"用于属性占位符处理\",\"用于转换Spring配置属性类型\",\"用于存储Spring配置属性源（PropertySource）\",\"用于Profiles状态维护\"]},\"1146\":{\"h\":\"Environment占位符处理\",\"t\":[\"不同Spring版本Environment对于占位符处理有所差异：\",\"Spring 3.1前占位符处理 \",\"组件：org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\",\"接口：org.springframework.util.StringValueResolver\",\"Spring 3.1+占位符处理： \",\"组件：org.springframework.context.support.PropertySourcesPlaceholderConfigurer\",\"接口：org.springframework.beans.factory.config.EmbeddedValueResolver\",\"我们可以来看以下具体地使用场景，首先定义一个properties文件：\",\"user.id=11111 user.name=jjjj user.city=HANGZHOU \",\"紧接着定义需要注入的Bean：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <!-- <bean class=\\\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\\\">--> <!-- <property name=\\\"location\\\" value=\\\"classpath:/META-INF/default.properties\\\"/>--> <!-- <property name=\\\"fileEncoding\\\" value=\\\"UTF-8\\\"/>--> <!-- </bean>--> <bean class=\\\"org.springframework.context.support.PropertySourcesPlaceholderConfigurer\\\"> <property name=\\\"location\\\" value=\\\"classpath:/META-INF/default.properties\\\"/> <property name=\\\"fileEncoding\\\" value=\\\"UTF-8\\\"/> </bean> <bean id=\\\"user\\\" class=\\\"org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User\\\"> <property name=\\\"id\\\" value=\\\"${user.id}\\\"/> <property name=\\\"name\\\" value=\\\"${user.name}\\\"/> <property name=\\\"city\\\" value=\\\"${user.city}\\\"/> </bean> </beans> \",\"最后观察输出：\",\"public class PropertyPlaceholderConfigurerDemo { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\\\"classpath:/META-INF/placeholders-resolver.xml\\\"); User user = context.getBean(\\\"user\\\", User.class); System.out.println(user); context.close(); } } \",\"可以看到占位符已经被成功的替换。\"]},\"1147\":{\"h\":\"理解条件配置Spring Profiles\",\"t\":[\"Spring3.1的条件配置：\",\"API：org.springframework.core.env.ConfigurableEnvironment \",\"修改：addActiveProfile(String)、SetActiveProfiles(String...)和setDefaultProfiles(String....)\",\"获取：getActiveProfiles()和getDefaultProfiles\",\"匹配：#acceptsProfiles(String...)和acceptsProfiles(Profiles)\",\"注解：org.springframework.context.annotation.Profile\",\"在Spring当中，也可以通过-Dspring.profiles.active来修改当前的激活环境。\"]},\"1148\":{\"h\":\"依赖注入Environment\",\"t\":[\"注解注入： \",\"通过EnvironmentAware接口回调\",\"通过@Autowired注入Environment\",\"间接依赖注入： \",\"通过ApplicationAware接口回调\",\"通过@Autowired注入ApplicationContext\",\"相关的示例：\",\"public class InjectingEnvironmentDemo implements EnvironmentAware, ApplicationContextAware { private ApplicationContext applicationContext; private Environment environment; @Autowired private Environment environment2; public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(InjectingEnvironmentDemo.class); context.refresh(); InjectingEnvironmentDemo injectingEnvironmentDemo = context.getBean(InjectingEnvironmentDemo.class); System.out.println(injectingEnvironmentDemo.environment); System.out.println(injectingEnvironmentDemo.environment == injectingEnvironmentDemo.environment2); System.out.println(context == injectingEnvironmentDemo.applicationContext); System.out.println(injectingEnvironmentDemo.environment == context.getEnvironment()); context.close(); } @Override public void setEnvironment(Environment environment) { this.environment = environment; } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; } } \"]},\"1149\":{\"h\":\"依赖查找Environment\",\"t\":[\"直接依赖查找 \",\"通过org.springframework.context.ConfigurableApplicationContext#ENVIRONMENT_BEAN_NAME\",\"直接查找 \",\"通过org.springframework.context.ConfigurableApplicationContext#getEnvironment\",\"相关的示例：\",\"public class LookupEnvironmentDemo implements EnvironmentAware { private Environment environment; public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(LookupEnvironmentDemo.class); context.refresh(); LookupEnvironmentDemo injectingEnvironmentDemo = context.getBean(LookupEnvironmentDemo.class); // 通过Environment Bean名称依赖查找 Environment environment = context.getBean(ConfigurableApplicationContext.ENVIRONMENT_BEAN_NAME, Environment.class); System.out.println(injectingEnvironmentDemo.environment); System.out.println(injectingEnvironmentDemo.environment == environment); context.close(); } @Override public void setEnvironment(Environment environment) { this.environment = environment; } } \",\"可以发现依赖查找和依赖注入的Environment都是同一个，Environment对象本身隶属于ApplicationContext，但是在容器启动的时候，会注册一个单例的Environment对象到BeanFactory中。\"]},\"1150\":{\"h\":\"依赖注入@Value\",\"t\":[\"@Value注解的实现类：org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\"]},\"1151\":{\"h\":\"Spring类型转换在Environment中的运用\",\"t\":[\"Environment底层实现：\",\"底层实现 - org.springframework.core.env.PropertySourcesPropertyResolver \",\"核心方法 - convertValueIfNecessary\",\"底层服务 - org.springframework.core.convert.ConversionService \",\"默认实现 - org.springframework.core.convert.support.DefaultConversionService\",\"相关的核心源代码：\"]},\"1152\":{\"h\":\"Spring类型转换在@Value中的运用\",\"t\":[\"@Value底层实现：\",\"底层实现：org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor \",\"org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency\",\"底层服务：org.springframework.beans.TypeConverter \",\"默认实现：org.springframework.beans.TypeConverterDelegate \",\"java.beans.PropertyEditor\",\"org.springframework.core.convert.ConversionService\",\"相关的核心源代码：\"]},\"1153\":{\"h\":\"Spring配置属性源PropertySource\",\"t\":[\"API\",\"单配置属性源：org.springframework.core.env.PropertySource\",\"多配置属性源：org.springframework.core.env.PropertySources\",\"注解\",\"单配置属性源：org.springframework.context.annotation.PropertySource\",\"多配置属性源：org.springframework.context.annotation.PropertySources\",\"关联\",\"存储对象：org.springframework.core.env.MutablePropertySources\",\"关联方法：org.springframework.core.env.ConfigurableEnvironment#getPropertySources\"]},\"1154\":{\"h\":\"Spring内建的配置属性源\",\"t\":[\"内建的PropertySource:\",\"PropertySource类型\",\"说明\",\"org.springframework.core.env.CommandLinePropertySource\",\"命令行配置属性源\",\"org.springframework.jndi.JndiPropertySource\",\"JNDI配置属性源\",\"org.springframework.core.env.PropertiesPropertySource\",\"Properties配置属性源\",\"org.springframework.web.context.support.ServletConfigPropertySource\",\"Servlet配置属性源\",\"org.springframework.web.context.support.ServletContextPropertySource\",\"ServletContext配置属性源\",\"org.springframework.core.env.SystemEnvironmentPropertySource\",\"环境变量配置属性源\",\"......\"]},\"1155\":{\"h\":\"基于注解扩展Spring配置属性源\",\"t\":[\"@org.springframework.context.annotation.PropertySource实现原理：\",\"入口 - org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass \",\"org.springframework.context.annotation.ConfigurationClassParser#processPropertySource\",\"4.3新增语义 \",\"配置属性字符编码 - encoding\",\"org.springframework.core.io.support.PropertySourceFactory\",\"适配对象 - org.springframework.core.env.CompositePropertySource\",\"默认只支持properties格式的文件，可以通过PropertySourceFactory进行扩展。\"]},\"1156\":{\"h\":\"基于API扩展Spring配置属性源\",\"t\":[\"PropertySource的配置实际上有两种类型：\",\"Spring应用上下文启动前装配PropertySource\",\"Spring应用上下文启动后装配PropertySource\",\"基于API扩展的示例：\",\"public class EnvironmentPropertySourceChangeDemo { @Value(\\\"${user.name}\\\") private String UserName; // 不具备动态更新地能力 // propertySource(“first-property-source”) {user.name = 吉永超} // propertySource(Java System Properties) {user.name = jyc} public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(EnvironmentPropertySourceChangeDemo.class); // 在Spring应用上下文启动之前，调整Environment中的PropertySource ConfigurableEnvironment environment = context.getEnvironment(); // 获取MutablePropertySources 对象 MutablePropertySources propertySources = environment.getPropertySources(); // 动态地插入PropertySource到PropertySources HashMap<String, Object> source = new HashMap<>(); source.put(\\\"user.name\\\", \\\"吉永超\\\"); MapPropertySource propertySource = new MapPropertySource(\\\"first-property-source\\\", source); propertySources.addFirst(propertySource); context.refresh(); source.put(\\\"user.name\\\", \\\"007\\\"); EnvironmentPropertySourceChangeDemo environmentPropertySourceChangeDemo = context.getBean(EnvironmentPropertySourceChangeDemo.class); System.out.println(environmentPropertySourceChangeDemo.UserName); for (PropertySource ps : propertySources) { System.out.printf(\\\"PropertySource(name=%s),'user.name'属性=%s\\\\n\\\", ps.getName(), ps.getProperty(\\\"user.name\\\")); } context.close(); } } \"]},\"1157\":{\"h\":\"Spring 测试配置属性源\",\"t\":[\"Spring 4.1测试配置属性源 - @TestPropertySource\",\"相关的示例：\",\"@RunWith(SpringRunner.class) @ContextConfiguration(classes = TestPropertySourceDemo.class) //Spring 注解驱动测试注解 @TestPropertySource(properties = \\\"user.name=吉永超\\\") // PropertySource(name=Inlined Test Properties) public class TestPropertySourceDemo { @Value(\\\"${user.name}\\\") private String userName; @Autowired private ConfigurableEnvironment environment; @Test public void testUserName() { System.out.println(new TestPropertySourceDemo().userName); for (PropertySource ps : environment.getPropertySources()) { System.out.printf(\\\"PropertySource(name=%s),'user.name'属性=%s\\\\n\\\", ps.getName(), ps.getProperty(\\\"user.name\\\")); } } } \",\"可以看到@TestPropertySource来源的优先级相当的高。\"]},\"1158\":{\"h\":\"面试题\"},\"1159\":{\"h\":\"简单介绍Spring Environment接口？\",\"t\":[\"核心接口 - org.springframework.core.env.Environment\",\"父接口 - org.springframework.core.env.PropertyResolver\",\"可配置接口 - org.springframework.core.env.ConfigurableEnvironment\",\"职责： \",\"管理Spring配置属性源\",\"管理Profiles\"]},\"1160\":{\"h\":\"如何控制PropertySource的优先级？\",\"t\":[\"可以通过相关的Spring相关的API进行操作\"]},\"1161\":{\"h\":\"Environment完整的生命周期是怎样的？\",\"t\":[\"// ...\"]},\"1162\":{\"h\":\"Spring应用上下文启动准备阶段\",\"t\":[\"org.springframework.context.support.AbstractApplicationContext#prepareRefresh方法：\",\"启动时间 - startupDate\",\"状态标志 - closed(false)、active(true)\",\"初始化 PropertySources - initPropertySources()\",\"校验Environment中必须属性\",\"初始化事件监听器集合\",\"初始化早期Spring事件集合\",\"相关的源代码：\",\" protected void prepareRefresh() { // Switch to active. this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); // Initialize any placeholder property sources in the context environment. initPropertySources(); // Validate that all properties marked as required are resolvable: // see ConfigurablePropertyResolver#setRequiredProperties getEnvironment().validateRequiredProperties(); // Store pre-refresh ApplicationListeners... if (this.earlyApplicationListeners == null) { this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners); } else { // Reset local application listeners to pre-refresh state. this.applicationListeners.clear(); this.applicationListeners.addAll(this.earlyApplicationListeners); } // Allow for the collection of early ApplicationEvents, // to be published once the multicaster is available... this.earlyApplicationEvents = new LinkedHashSet<>(); } \"]},\"1163\":{\"h\":\"BeanFactory创建阶段\",\"t\":[\"AbstractApplicationContext#obtainFreshBeanFactory方法：\",\"刷新Spring应用上下文底层BeanFactory - refreshBeanFactory() \",\"销毁或关闭BeanFactory，如果已存在的话\",\"创建BeanFactory - createBeanFactory()\",\"设置BeanFactory Id\",\"设置\\\"是否允许BeanDefinition重复定义\\\" - customizeBeanFactory(DefaultListableBeanFactory)\",\"设置\\\"是否允许循环应用（依赖）\\\" - customizeBeanFactory(DefaultListableBeanFactory)\",\"加载BeanDefinition - loadBeanDefinitions(DefaultListableBeanFactory beanFactory)\",\"关联新建BeanFactory到Spring应用上下文\",\"返回Spring应用上下文底层BeanFactory - getBeanFactory\",\"可以在AbstractRefreshableApplicationContext看到具体的实现：\",\" @Override protected final void refreshBeanFactory() throws BeansException { if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); loadBeanDefinitions(beanFactory); this.beanFactory = beanFactory; } catch (IOException ex) { throw new ApplicationContextException(\\\"I/O error parsing bean definition source for \\\" + getDisplayName(), ex); } } \"]},\"1164\":{\"h\":\"BeanFactory准备阶段\",\"t\":[\"AbstractApplicationContext#prepareBeanFactory(ConfigurableListableBeanFactory)方法：\",\"关联ClassLoader\",\"设置Bean表达式处理器\",\"添加PropertyEdittorRegistrar实现 - ResourceEditorRegistrar\",\"添加Aware回调接口BeanPostProcessor实现 - ApplicationContextAwareProcessor\",\"忽略Aware回调接口作为依赖注入接口\",\"注册ResolvableDependency对象 - BeanFactory、ResourceLoader、ApplicationEventPublisher以及ApplicationContext\",\"注册ApplicationListenerDetector对象\",\"注册LoadTimeWeaverAwareProcessor对象\",\"注册单例对象 - Environment、Java System Properties、以及OS环境变量\",\"相关的源代码：\",\" protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) { // Tell the internal bean factory to use the context's class loader etc. beanFactory.setBeanClassLoader(getClassLoader()); if (!shouldIgnoreSpel) { beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); } beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // Configure the bean factory with context callbacks. beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class); // BeanFactory interface not registered as resolvable type in a plain factory. // MessageSource registered (and found for autowiring) as a bean. beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // Register early post-processor for detecting inner beans as ApplicationListeners. beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // Detect a LoadTimeWeaver and prepare for weaving, if found. if (!NativeDetector.inNativeImage() && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } // Register default environment beans. if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); } if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); } if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); } if (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) { beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup()); } } \"]},\"1165\":{\"h\":\"BeanFactory后置处理阶段\",\"t\":[\"AbstractApplicationContext#postProcessBeanFactory(ConfigurableListableBeanFactory)方法\",\"由子类覆盖该方法\",\"AbstractApplicationContext#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory)方法：\",\"调用BeanFactoryPostProcessor或BeanDefinitionPostProcessorRegistry后置处理方法\",\"注册LoadTimeWeaverAwareProcessor对象\",\"通常情况下，我们应该选择第二种方式，组合优先于继承。\",\"相关的源代码：\",\"protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (!NativeDetector.inNativeImage() && beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } } \"]},\"1166\":{\"h\":\"BeanFactory注册BeanPostProcess\",\"t\":[\"AbstractApplicationContext#registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory)方法：\",\"注册PriorityOrdered类型的BeanPostProcessor Beans\",\"注册Ordered类型的BeanPostProcessor Beans\",\"注册普通BeanPostProcessor Beans\",\"注册MergedBeanDefinitionPostProcessor Beans\",\"注册ApplicationListenerDetector对象\",\"相应的源代码：\",\"public static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) { String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); // Register BeanPostProcessorChecker that logs an info message when // a bean is created during BeanPostProcessor instantiation, i.e. when // a bean is not eligible for getting processed by all BeanPostProcessors. int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length; beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount)); // Separate between BeanPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>(); List<BeanPostProcessor> internalPostProcessors = new ArrayList<>(); List<String> orderedPostProcessorNames = new ArrayList<>(); List<String> nonOrderedPostProcessorNames = new ArrayList<>(); for (String ppName : postProcessorNames) { if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { // 特别要注意，这里会导致Bean的提前初始化 BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); priorityOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) { internalPostProcessors.add(pp); } } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { orderedPostProcessorNames.add(ppName); } else { nonOrderedPostProcessorNames.add(ppName); } } // First, register the BeanPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors); // Next, register the BeanPostProcessors that implement Ordered. List<BeanPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size()); for (String ppName : orderedPostProcessorNames) { // 这里也会初始化 BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); orderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) { internalPostProcessors.add(pp); } } sortPostProcessors(orderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, orderedPostProcessors); // Now, register all regular BeanPostProcessors. List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size()); for (String ppName : nonOrderedPostProcessorNames) { BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); nonOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) { internalPostProcessors.add(pp); } } registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors); // Finally, re-register all internal BeanPostProcessors. sortPostProcessors(internalPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, internalPostProcessors); // Re-register post-processor for detecting inner beans as ApplicationListeners, // moving it to the end of the processor chain (for picking up proxies etc). beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext)); } \"]},\"1167\":{\"h\":\"初始化内建MessageSource\",\"t\":[\"AbstractApplicationContext#initMessageSource方法：\",\"第十二章Spring国际化 - MessageSource内建依赖\",\"相应的源代码：\",\" protected void initMessageSource() { ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) { this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class); // Make MessageSource aware of parent MessageSource. if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) { HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource; if (hms.getParentMessageSource() == null) { // Only set parent context as parent MessageSource if no parent MessageSource // registered already. hms.setParentMessageSource(getInternalParentMessageSource()); } } if (logger.isTraceEnabled()) { logger.trace(\\\"Using MessageSource [\\\" + this.messageSource + \\\"]\\\"); } } else { // Use empty MessageSource to be able to accept getMessage calls. DelegatingMessageSource dms = new DelegatingMessageSource(); dms.setParentMessageSource(getInternalParentMessageSource()); this.messageSource = dms; beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource); if (logger.isTraceEnabled()) { logger.trace(\\\"No '\\\" + MESSAGE_SOURCE_BEAN_NAME + \\\"' bean, using [\\\" + this.messageSource + \\\"]\\\"); } } } \"]},\"1168\":{\"h\":\"初始化内建Spring事件广播器\",\"t\":[\"AbstractApplicationContext#initApplicationEventMulticaster方法：\",\"第十七章Spring事件 - ApplicationEventMulticaster底层实现\",\"相应的源代码：\",\"protected void initApplicationEventMulticaster() { ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) { this.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class); if (logger.isTraceEnabled()) { logger.trace(\\\"Using ApplicationEventMulticaster [\\\" + this.applicationEventMulticaster + \\\"]\\\"); } } else { this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory); beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster); if (logger.isTraceEnabled()) { logger.trace(\\\"No '\\\" + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + \\\"' bean, using \\\" + \\\"[\\\" + this.applicationEventMulticaster.getClass().getSimpleName() + \\\"]\\\"); } } } \",\"可以看到在Spring的应用上下文中，ApplicationEventMulticaster这个对象一定会存在，因此我们可以使用依赖注入的方式获取到唯一的对象ApplicationEventMulticaster的对象。\"]},\"1169\":{\"h\":\"Spring应用上下文刷新\",\"t\":[\"AbstractApplicationContext#onRefresh方法：\",\"org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#onRefresh\",\"org.springframework.web.context.support.GenericWebApplicationContext#onRefresh\",\"org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#onRefresh\",\"org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#onRefresh\",\"org.springframework.web.context.support.StaticWebApplicationContext#onRefresh\",\"onRefresh()方法只有在Web的场景下才会进行扩展。\"]},\"1170\":{\"h\":\"Spring事件监听器注册\",\"t\":[\"AbstractApplicationContext#registerListeners方法：\",\"添加当前应用上下文所关联的ApplicationListeners对象（集合）\",\"添加BeanFactory所注册ApplicationListeners Beans\",\"广播早期Spring事件\",\"相应的源代码：\",\"protected void registerListeners() { // Register statically specified listeners first. for (ApplicationListener<?> listener : getApplicationListeners()) { getApplicationEventMulticaster().addApplicationListener(listener); } // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let post-processors apply to them! String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String listenerBeanName : listenerBeanNames) { getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); } // Publish early application events now that we finally have a multicaster... Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents; this.earlyApplicationEvents = null; if (!CollectionUtils.isEmpty(earlyEventsToProcess)) { for (ApplicationEvent earlyEvent : earlyEventsToProcess) { getApplicationEventMulticaster().multicastEvent(earlyEvent); } } } \"]},\"1171\":{\"h\":\"BeanFactory初始化完成阶段\",\"t\":[\"AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory)方法：\",\"BeanFactory关联ConversionService Bean，如果存在\",\"添加StringValueResolver对象\",\"依赖查找LoadTimeWeaverAware Bean\",\"BeanFactory临时ClassLoader置为null\",\"BeanFactory冻结配置\",\"BeanFactory初始化非延迟单例Beans\",\"相应的源代码：\",\" protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) { // Initialize conversion service for this context. if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) && beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) { beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); } // Register a default embedded value resolver if no BeanFactoryPostProcessor // (such as a PropertySourcesPlaceholderConfigurer bean) registered any before: // at this point, primarily for resolution in annotation attribute values. if (!beanFactory.hasEmbeddedValueResolver()) { beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal)); } // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early. String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) { getBean(weaverAwareName); } // Stop using the temporary ClassLoader for type matching. beanFactory.setTempClassLoader(null); // Allow for caching all bean definition metadata, not expecting further changes. beanFactory.freezeConfiguration(); // Instantiate all remaining (non-lazy-init) singletons. beanFactory.preInstantiateSingletons(); } \"]},\"1172\":{\"h\":\"Spring应用上下文刷新完成阶段\",\"t\":[\"AbstractApplicationContext#finishRefresh方法：\",\"清除ResourceLoader缓存 - clearResourceCaches() @since 5.0\",\"初始化LifecycleProcessor对象 - initLifecycleProcessor()\",\"调用LifecycleProcessor().onRefresh()方法\",\"发布Spring应用上下文已刷新事件 - ContextRefreshedEvent\",\"向MBeanServer托管Live Beans\",\"相应的源代码：\",\"protected void finishRefresh() { // Clear context-level resource caches (such as ASM metadata from scanning). clearResourceCaches(); // Initialize lifecycle processor for this context. initLifecycleProcessor(); // Propagate refresh to lifecycle processor first. getLifecycleProcessor().onRefresh(); // Publish the final event. publishEvent(new ContextRefreshedEvent(this)); // Participate in LiveBeansView MBean, if active. if (!NativeDetector.inNativeImage()) { LiveBeansView.registerApplicationContext(this); } } \"]},\"1173\":{\"h\":\"Spring 应用上下文启动阶段\",\"t\":[\"AbstractApplicationContext#start方法\",\"启动LifecycleProcessor \",\"依赖查找Lifecycle Beans\",\"启动Lifecycle Beans\",\"发布Spring应用上下文已启动事件 - ContextStartedEvent\",\"相应的源代码：\",\"public void start() { getLifecycleProcessor().start(); publishEvent(new ContextStartedEvent(this)); } \"]},\"1174\":{\"h\":\"Spring 应用上下文停止阶段\",\"t\":[\"AbstractApplicationContext#stop方法\",\"停止LifecycleProcessor \",\"依赖查找Lifecycle Beans\",\"停止Lifecycle Beans\",\"发布Spring应用上下文已停止事件 - ContextStoppedEvent\",\"相应的源代码：\",\"public void stop() { getLifecycleProcessor().stop(); publishEvent(new ContextStoppedEvent(this)); } \",\"我们可以自定义一个Lifecycle：\",\"public class MyLifecycle implements Lifecycle { private boolean running = false; @Override public void start() { running = true; System.out.println(\\\"org.jyc.thinking.in.spring.lifecycle.MyLifecycle 启动...\\\"); } @Override public void stop() { running = false; System.out.println(\\\"org.jyc.thinking.in.spring.lifecycle.MyLifecycle 停止...\\\"); } @Override public boolean isRunning() { return running; } } \",\"测试输出：\",\"public class LifecycleDemo { public static void main(String[] args) { GenericApplicationContext context = new GenericApplicationContext(); // 注册MyLifecycle成为一个Spring Bean context.registerBeanDefinition(\\\"myLifecycle\\\", BeanDefinitionBuilder.rootBeanDefinition(MyLifecycle.class).getBeanDefinition()); context.refresh(); // 启动应用上下文 context.start(); // 关闭Spring应用 context.stop(); context.close(); } } \"]},\"1175\":{\"h\":\"Spring应用上下文关闭阶段\",\"t\":[\"AbstractApplicationContext#close方法:\",\"状态标识：active(false)、closed(true)\",\"Live Beans JMX撤销托管 \",\"LiveBeansView.unregisterApplicationContext(ConfigurableApplicationContext)\",\"发布Spring应用上下文已关闭事件 - ContextClosedEvent\",\"关闭LifecycleProcessor \",\"依赖查找Lifecycle Beans\",\"停止Lifecycle Beans\",\"销毁Lifecycle Beans\",\"关闭BeanFactory\",\"回调onClose()\",\"注册Shutdown Hook线程（如果曾注册）\",\"相应的源代码：\",\" protected void doClose() { // Check whether an actual close attempt is necessary... if (this.active.get() && this.closed.compareAndSet(false, true)) { if (logger.isDebugEnabled()) { logger.debug(\\\"Closing \\\" + this); } if (!NativeDetector.inNativeImage()) { LiveBeansView.unregisterApplicationContext(this); } try { // Publish shutdown event. publishEvent(new ContextClosedEvent(this)); } catch (Throwable ex) { logger.warn(\\\"Exception thrown from ApplicationListener handling ContextClosedEvent\\\", ex); } // Stop all Lifecycle beans, to avoid delays during individual destruction. if (this.lifecycleProcessor != null) { try { this.lifecycleProcessor.onClose(); } catch (Throwable ex) { logger.warn(\\\"Exception thrown from LifecycleProcessor on context close\\\", ex); } } // Destroy all cached singletons in the context's BeanFactory. destroyBeans(); // Close the state of this context itself. closeBeanFactory(); // Let subclasses do some final clean-up if they wish... onClose(); // Reset local application listeners to pre-refresh state. if (this.earlyApplicationListeners != null) { this.applicationListeners.clear(); this.applicationListeners.addAll(this.earlyApplicationListeners); } // Switch to inactive. this.active.set(false); } } \",\"这里补充一个关于ShutdownHook的示例，通过这种方式可以优雅的停止线程：\",\"public class ShutdownHookThreadDemo { public static void main(String[] args) throws IOException { GenericApplicationContext context = new GenericApplicationContext(); context.addApplicationListener(new ApplicationListener<ContextClosedEvent>() { @Override public void onApplicationEvent(ContextClosedEvent event) { System.out.printf(\\\"[线程 %s] ContextClosedEvent 处理\\\\n\\\", Thread.currentThread().getName()); } }); context.refresh(); context.registerShutdownHook(); System.out.println(\\\"按任意键继续并且关闭Spring 应用上下文\\\"); System.in.read(); context.close(); } } \"]},\"1176\":{\"h\":\"面试题\"},\"1177\":{\"h\":\"Spring应用上下文生命周期有哪些阶段？\",\"t\":[\"可以简单的回答为：\",\"刷新阶段 - ConfigurableApplicationContext#refresh()\",\"启动阶段 - ConfigurableApplicationContext#start()\",\"停止阶段 - ConfigurableApplicationContext#stop()\",\"关闭阶段 - ConfigurableApplicationContext#close()\"]},\"1178\":{\"h\":\"Environment完整的生命周期？\",\"t\":[\"主要分为refresh()方法之前和refresh()方法之后，在refresh()方法之前可以主动填充自定义的Environment对象，在refresh()方法之后会创建默认的Environment对象。\"]},\"1179\":{\"h\":\"Spring核心特性\"},\"1180\":{\"h\":\"Spring核心价值\"},\"1181\":{\"h\":\"为什么说ObjectFactory提供的是延迟依赖查找？\",\"t\":[\"原因：\",\"ObjectFactory（或ObjectProvider）可关联某一类型Bean\",\"ObjectFactory（或ObjectProvider）对象在被依赖注入和依赖查询时并未实时查找关联类型Bean\",\"ObjectFactory（或ObjectProvider）调用getObject()方法时，目标Bean才被依赖查找\",\"总结：ObjectFactory（或ObjectProvider）相当于某一类型Bean依赖查找代理对象。\",\"这里我们可以编写一个示例：\",\"public class ObjectFactoryLazyLookupDemo { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(ObjectFactoryLazyLookupDemo.class); context.refresh(); ObjectFactoryLazyLookupDemo demo = context.getBean(ObjectFactoryLazyLookupDemo.class); // 代理对象 ObjectProvider<User> objectProvider = demo.objectProvider; ObjectFactory<User> userObjectFactory = demo.userObjectFactory; // ObjectFactory和ObjectProvider System.out.println(\\\"userObjectFactory == objectProvider: \\\" + (userObjectFactory == objectProvider)); // 结果为true，说明两者的底层实现是一样的。 System.out.println(\\\"userObjectFactory.getClass() == objectProvider.getClass(): \\\" + (userObjectFactory.getClass() == objectProvider.getClass())); // 实际对象(延迟查找) System.out.println(userObjectFactory.getObject()); System.out.println(objectProvider.getObject()); System.out.println(context.getBean(User.class)); context.close(); } @Autowired private ObjectFactory<User> userObjectFactory; @Autowired private ObjectProvider<User> objectProvider; @Bean @Lazy public User user() { User user = new User(); user.setId(\\\"111111\\\"); user.setName(\\\"吉永超\\\"); return user; } } \",\"也可以在DefaultListableBeanFactory.DependencyObjectProvider中看到相关的原理，只有在调用getObject的时候，才会根据泛型的具体化进行依赖查找，创建对象，而不是直接去查找，也就是所谓的延迟依赖查找。\"]},\"1182\":{\"h\":\"依赖查找（注入）的Bean会被缓存嘛？\",\"t\":[\"单例Bean（Singleton）- 会 \",\"缓存位置：org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonObjects属性\",\"原型Bean（Prototype）- 不会 \",\"当依赖查询或依赖注入时，根据BeanDefinition每次创建\",\"其他Scope Bean \",\"request：每个ServletRequest内部缓存，生命周期维持在每次HTTP请求\",\"session：每个HttpSeesion内部缓存，生命周期维持在每个用户HTTP会话\",\"application：当前Servlet应用内部缓存\",\"相关的示例代码：\",\"public class BeanCachingDemo { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.register(BeanCachingDemo.class); context.refresh(); BeanCachingDemo beanCachingDemo = context.getBean(BeanCachingDemo.class); for (int i = 0; i < 9; i++) { // singletonBean会被缓存 System.out.println(beanCachingDemo == context.getBean(BeanCachingDemo.class)); } User user = context.getBean(User.class); for (int i = 0; i < 9; i++) { // prototype不会被缓存 System.out.println(user == context.getBean(User.class)); } context.close(); } @Bean @Scope(\\\"prototype\\\") public static User user() { User user = new User(); user.setId(\\\"111111\\\"); user.setName(\\\"吉永超\\\"); return user; } } \",\"其中单例对象的最为复杂，在DefaultSingletonBeanRegistry#getSingleton中可以看到核心的逻辑：\",\"在每次进行依赖查找（注入）的时候不是直接创建对象，而是会现在缓存的字段singletonObjects中进行获取。\",\"原型作用域的Bean每次在依赖查找（注入）的时候都会根据BeanDefinition重新构建Bean。\",\"总而言之，只有Prototype的Bean不会进行缓存，其他情况下均会进行缓存。Prototype的Bean在被容器创建之后就会与容器脱钩，不再有生命周期等特性。\"]},\"1183\":{\"h\":\"@Bean的处理流程是怎样的？\",\"t\":[\"解析范围 - Configuration Class中的@Bean方法\",\"方法类型 - 静态@Bean方法和实例@Bean方法\",\"在找到标注了@Configuration Class的类之后，会获取到所有的@Bean的方法，根据标注的@Bean的方法解析出相应的BeanDefinition，然后创建对象，相关的逻辑在\",\"ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod方法中，另外在解析静态方法和实例方法的时候，有一些差别：\",\"可以看到，如果是实例方法，那么首先要获取到实例方法所在的类的实例，静态方法的初始化会更早。\"]},\"1184\":{\"h\":\"BeanFactory是如何处理循环依赖的？\",\"t\":[\"预备知识：\",\"循环依赖开关（方法）- AbstractAutowireCapableBeanFactory#setAllowCircularReferences\",\"单例工程（属性）- DefaultSingletonBeanRegistry#singletonFactories\",\"获取早期未处理Bean（方法） - AbstractAutowireCapableBeanFactory#getEarlyBeanReference\",\"早期未处理Bean（属性） - DefaultSingletonBeanRegistry#earlySingletonObjects\",\"循环依赖的示例，首先定义一个学生类：\",\"public class Student { private Long id; private String name; @Autowired private ClassRoom classRoom; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public ClassRoom getClassRoom() { return classRoom; } public void setClassRoom(ClassRoom classRoom) { this.classRoom = classRoom; } @Override public String toString() { return \\\"Student{\\\" + \\\"id=\\\" + id + \\\", name='\\\" + name + '\\\\'' + \\\", classRoom.name=\\\" + classRoom.getName() + '}'; } } \",\"然后定义一个教室类：\",\"public class ClassRoom { private String name; @Autowired private Collection<Student> students; public String getName() { return name; } public void setName(String name) { this.name = name; } public Collection<Student> getStudents() { return students; } public void setStudents(Collection<Student> students) { this.students = students; } @Override public String toString() { return \\\"ClassRoom{\\\" + \\\"name='\\\" + name + '\\\\'' + \\\", students=\\\" + students + '}'; } } \",\"测试示例：\",\"public class CircularReferencesDemo { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); // 注册 Configuration Class context.register(CircularReferencesDemo.class); // 如果设置为 false，则抛出异常信息如：currently in creation: Is there an unresolvable circular reference? // 默认值为 true context.setAllowCircularReferences(true); // 启动 Spring 应用上下文 context.refresh(); System.out.println(\\\"Student : \\\" + context.getBean(Student.class)); System.out.println(\\\"ClassRoom : \\\" + context.getBean(ClassRoom.class)); // 关闭 Spring 应用上下文 context.close(); } @Bean public static Student student() { Student student = new Student(); student.setId(1L); student.setName(\\\"张三\\\"); return student; } @Bean public static ClassRoom classRoom() { ClassRoom classRoom = new ClassRoom(); classRoom.setName(\\\"C122\\\"); return classRoom; } } \",\"处理循环依赖的核心代码：\"]},\"1185\":{\"h\":\"\"},\"1186\":{\"h\":\"设计模式\"},\"1187\":{\"h\":\"列举一些JDK中用到的设计模式？\"},\"1188\":{\"h\":\"列举一些Spring当中用到的设计模式？\"},\"1189\":{\"h\":\"项目中有用过设计模式吗？\"},\"1190\":{\"h\":\"单例模式有哪些实现方式？\"},\"1191\":{\"h\":\"懒汉式\",\"t\":[\"public class Singleton { private static Singleton uniqueInstance; private Singleton() { } public static Singleton getUniqueInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } \",\"说明：先不创建实例，当第一次被调用的时候，再创建实例，所以被称为懒汉式。\",\"优点：延迟了实例化，如果不需要使用该类，就不会被实例化，节约了系统资源。\",\"缺点：线程不安全，如果多个线程同时进入了if(uniqueInstance == null)，若此时还未实例化，就会有多个线程同时执行uniqueInstance = new Singleton()，会实例化多个对象。\"]},\"1192\":{\"h\":\"饿汉式\",\"t\":[\"public class Singleton { private static Singleton uniqueInstance = new Singleton(); private Singleton() { } public static Singleton getUniqueInstance() { return uniqueInstance; } } \",\"说明：\",\"优点：\",\"缺点：\"]},\"1193\":{\"h\":\"双重检查锁\",\"t\":[\"public class Singleton { private volatile Singleton uniqueInstance; private Singleton() {} public Singleton getInstance() { if (null == this.uniqueInstance) { synchronized (Singleton.class) { if (null == this.singleDemo) { uniqueInstance = new Singleton(); } } Singleton = new Singleton(); return uniqueInstance; } } \",\"说明：\",\"优点：\",\"缺点：\"]},\"1194\":{\"h\":\"静态内部类\",\"t\":[\"public class Singleton { private Singleton() { } public static Singleton getUniqueInstance() { return SingletonHolder.uniqueInstance; } private static class SingletonHolder { private static final Singleton uniqueInstance = new Singleton(); } } \",\"说明：\",\"优点：延迟实例化，节约了资源，且线程安全，性能也提高了。\"]},\"1195\":{\"h\":\"枚举类\",\"t\":[\"public enum Singleton { UNIQUE_INSTANCE; // 添加自己需要的操作 public void doSomething() { } } \",\"说明：枚举类的实例就是线程安全的，且在任何情况下都是单例的。\",\"优点：写法简单且线程安全。\"]},\"1196\":{\"h\":\"单例模式有什么应用场景？\",\"t\":[\"数据库连接池\",\"线程池\",\"网站计数器\",\"应用的配置\"]},\"1197\":{\"h\":\"\"},\"1198\":{\"h\":\"网络安全\"},\"1199\":{\"h\":\"什么是认证和授权？如何设计一个权限认证框架？\",\"t\":[\"认证：就是对系统访问者的身份进行确认（用户名密码登录、二维码登录、指纹、刷脸...）。\",\"授权：就是对系统访问者的行为进行控制，授权通常是在认证之后，对系统内的隐私数据进行保护，后台接口访问权限，前台控件的访问权限。\",\"通常情况下我们通过RBAC模型，也就是用户关联角色 ，而角色访问不同的资源，从而控制用户访问系统的行为。\",\"认证和授权也是对一个权限认证框架进行评估的两个主要的方面。\"]},\"1200\":{\"h\":\"Cookie和Session有什么区别？如果没有Cookie、Seesion还能进行身份验证吗？\",\"t\":[\"当服务器tomcat第一次接收到客户端的请求时，会开辟一块独立的session空间，建立一个session对象，同时会生成session id，通过响应头的方式保存到客户端浏览器的cookie当中，以后客户端的每次请求，都会在请求头部带上这个session id，这样就可以对应上服务端的一些会话信息，比如用户的登录状态。\",\"如果没有客户端的cookie，session是无法进行身份验证的。\",\"当服务端从单体应用升级为分布式之后，cookie + session要如何扩展？\",\"session黏贴，在负载均衡中，通过某种机制，保证同一个客户端的所有请求都会转发到同一个tomcat实例当中。当这个tomcat实例出现问题之后，请求就会被转发到其他实例，这时候用户的session用户信息就丢失了。\",\"session复制：当一个tomcat实例上保存了session信息后，主动将session复制到集群中的其他实例。问题：复制是需要时间的，在复制的过程中，容器产生session信息丢失。\",\"session共享，就是将服务端的session信息保存到一个第三方中，比如Redis\"]},\"1201\":{\"h\":\"什么是CSRF攻击？如何防止？\",\"t\":[\"CSRF：Cross Site Request Forgery 跨站请求伪造。\",\"一个正常的请求会将合法用户的session id保存到浏览器的cookie，这时候，如果用户在浏览器中打开另一个Tab页，那这个tab页也是可以获得浏览器的cookie，黑客就可以利用这个cookie信息进行攻击\",\"攻击过程：\",\"某银行网站A可以以GET请求的方式发起转账操作。www.xxx.com/transfor.do?accountNum=100&money=1000 accountNum表示目标账户，这个请求肯定是需要登录才可以正常访问的，\",\"攻击者在某个论坛或者网站上上传一个图片，链接地址是 www.xxx.com/transfor.do?accountNum=100&money=1000，其中accountNum就是攻击者自己的银行账户。\",\"如果有一个用户，登录了银行网站，然后又打开浏览器的另一个Tab页，点击了这个图片，这时，银行就会受理到一个带了正确的cookie的请求，就会完成转账，用户的钱就被盗了。\",\"防止CSRF的方式：\",\"尽量使用POST请求，限制GET请求，POST请求可以带请求体，攻击者就不容易伪造出请求。\",\"将cookie设置为HttpOnly：response.setHeader(\\\"Set-Cookie\\\",\\\"cookiename=cookievalue;HttpOnly\\\")。\",\"增加token：在请求中放入一个攻击者无法伪造的信息，并且该信息不存在于cookie当中。\",\"增加一个额外的隐藏信息<input type='hidden' value='demo'>这也是Spring Security框架中采用的防范方式。\"]},\"1202\":{\"h\":\"什么是OAuth2？有哪几种认证方式？\",\"t\":[\"OAuth2.0是一个开放标准，允许用户授权在第三方应用程序访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方应用分享他们数据的所有内容。\",\"OAuth2.0的协议认证流程，简单理解，就是允许我们将之前的授权和认证过程交给一个独立的第三方进行担保。\",\"OAuth2.0协议有四种模式：\",\"授权码模式：\",\"简化模式：\",\"密码模式：\",\"客户端模式：\",\"在梳理OAuth2.0协议流程的过程中，其实有一个主线，就是三方参与者的信任程度。\"]},\"1203\":{\"h\":\"什么是JWT令牌？和普通令牌有什么区别？\",\"t\":[\"普通令牌只是一个普通的字符串，没有特殊的意义，这就意味着，当客户端带上令牌去访问应用的接口时，应用本身无法判断这个令牌是否正确，他就需要到授权服务器上去拍段令牌是否有效，在高并发的场景下，检查令牌的网络请求就有可能成为一个性能瓶颈。\",\"改良的方式就是JWT令牌，将令牌对应的相关信息全部冗余到令牌本身，这样资源服务器就不再需要发送求请给授权服务器去检查令牌了，他自己就可以读取到令牌的授权信息。JWT令牌的本质就是一个加密的字符串。\"]},\"1204\":{\"h\":\"什么是SSO？与OAuth2.0有什么关系？\",\"t\":[\"OAuth2.0的使用场景通常称为联合登录，一处注册，多处使用。\",\"SSO：Single Sign ON：一处登录，多处同时登录。\",\"SSO的实现关键是将Seesion信息几种存储，通常使用Spring Security实现\"]},\"1205\":{\"h\":\"如何实现单点登录系统？\",\"t\":[\"单点登录系统是怎么做的？\"]},\"1206\":{\"h\":\"\"},\"1207\":{\"h\":\"MyBatis面试题\"},\"1208\":{\"h\":\"Mybatis接口 Mapper内的方法为什么不能重载？\",\"t\":[\"Mybatis在XML文件中寻找对应的SQL语句的时候，会根据StrictMap<String, MappedStatement>中查找对应的MappedStatement，这里Map的key就是根据Mapper的全类名 + \\\".\\\" + 方法名。一方面，StrictMap如果出现重复的key会直接抛出异常，另一方面，如果允许key重复，也就是允许Mapper内的方法重载，则无法定位到XML文件内唯一的SQL语句。\",\"更多内容可以参考：Mybatis接口 Mapper内的方法为什么不能重载？\"]},\"1209\":{\"h\":\"Mybatis的XML映射文件中，不同的XML映射文件，id是否可以重复？\",\"t\":[\"同一个namespace下的id不能重复，原因是 namespace + id 会作为Map<String，MapperStatement>的key使用，如果id重复会导致数据互相覆盖。\"]},\"1210\":{\"h\":\"#{}和${}的区别是什么？\",\"t\":[\"#{} 是预编译处理，${}是字符串替换。\",\"Mybatis在处理#{}时，会将sql中的#{}替换为“？”号，调用PreparedStatement的set方法来赋值\",\"Mybatis在处理${}时，就是把${}替换程变量的值\",\"使用#{}可以有效的放置SQL注入，提高系统的安全性。\"]},\"1211\":{\"h\":\"当实体类中的属性名和表中的字段名不一样怎么办？\",\"t\":[\"通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致\",\"通过<resultMap>来映射字段名和实体类属性名的一一对应的关系。\"]},\"1212\":{\"h\":\"执行插入语句后如何该数据的主键？\"},\"1213\":{\"h\":\"模糊查询like语句该怎么写？\",\"t\":[\"在java代码中添加sql通配符\",\"在sql语句中拼接通配符，会引起sql注入\"]},\"1214\":{\"h\":\"Mybatis时如何进行分页的？分页插件的原理是什么?\",\"t\":[\"Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。\"]},\"1215\":{\"h\":\"Mybatis有哪些动态sql标签？\",\"t\":[\"tirm、where、set、foreach、if、choose、when、otherwise、bind。\"]},\"1216\":{\"h\":\"Mybtais动态sql有什么用？执行原理是什么？\",\"t\":[\"MyBatis动态sql可以在XML映射文件内，以标签的形式编写动态sql，执行原理时根据表达式的值，完成逻辑判断并动态拼接sql的功能。\"]},\"1217\":{\"h\":\"Mapper编写有哪几种方式？\",\"t\":[\"接口实现类继承SqlSessionDaoSupport，需要编写mapper接口，mapper接口实现类、mapper.xml文件\",\"使用org.mybatis.spring.mapper.MapperFactoryBean;\",\"使用mapper扫描器\"]},\"1218\":{\"h\":\"Mybatis的一级、二级缓存？\",\"t\":[\"一级缓存：基于PerpetuaCache的HashMap本地缓存，其存储作作用域为Session，默认打开一级缓存\",\"二级缓存与一级缓存机制相同，不做其作用域为Sessionfactory，该缓存是以namespace为单位的（也就是一个Mapper.xml文件），不同namespace下的操作互不影响。\",\"使用二级缓存需要实现序列化接口。\"]},\"1219\":{\"h\":\"Mybatis有二级缓存，为什么还要用Redis？\",\"t\":[\"使用Mybatis的二级缓存可能会存在如下两个问题：\",\"所有对数据表的改变都会刷新缓存，但是一般不要使用二级缓存，例如在UserMappper.xml中有大多数针对user表的操作，但是在另一个Mapper.xml中，还有针对user单表的操作，这会导致user在两个命名空间下的数据不一致\",\"如果在UserMappper.xml做了刷新缓存的操作，在Mapper.xml中缓存仍然有效，如果有针对user的单表查询，使用缓存的结果可能会不正确\",\"而Redis很好的解决了这个问题，并且还有其它的特性，例如可以搭建在其它服务器上，缓存的容量可扩展等。\"]},\"1220\":{\"h\":\"Mybatis如何开启二级缓存？\",\"t\":[\"MyBatis的缓存机制\"]},\"1221\":{\"h\":\"\"},\"1222\":{\"h\":\"Netty面试题\"},\"1223\":{\"h\":\"Netty有哪些应用场景？\",\"t\":[\"作为RPC框架的网络通信工具\",\"实现Http服务器\",\"实现即时通讯系统\",\"实现消息推送系统\"]},\"1224\":{\"h\":\"Netty核心组件有哪些？分别有什么作用？\",\"t\":[\"核心组件\",\"作用\",\"Channel\",\"Channel接口是Netty对网络操作的抽象类，它包含了基本的I/O操作，如bind()、connect()、read()、write()等\",\"EventLoop\",\"EventLoop（事件循环）定义了Netty的核心抽象，用于处理连接的生命周期中所发生的事件，他的主要作用是负责监听网络事件并调用事件处理器进行相关I/O操作的处理\",\"ChannelFuture\",\"用于注册异步执行结果的监听器\",\"ChannelHandler\",\"消息的具体处理器，负责读写操作、客户端连接等事情\",\"ChannelPipeline\",\"ChannelPipeline为ChannelHandler的链，提供了一个容器并定义了用于沿着链传播入站和出战事件流的API。当Channel被创建时，它会被自动地分配到它专属的ChannelPipeline。使用者可以在ChannelPipeline上通过addLast()方法添加一个或者多个ChannelHandler，因为一个数据或事件可能需要多个ChannelHandler来进行处理，在ChannelPipeline中，当一个ChannelHandler处理完之后就会将数据交给下一个ChannelHandler\"]},\"1225\":{\"h\":\"EventLoopGroup了解么?和EventLoop什么关系?\"},\"1226\":{\"h\":\"Bootstrap和ServerBootstrap了解么？\",\"t\":[\"BootStrap是客户端的启动引导类/辅助类，具体使用如下：\",\" EventLoopGroup group = new NioEventLoopGroup(); try { //创建客户端启动引导/辅助类：Bootstrap Bootstrap b = new Bootstrap(); //指定线程模型 b.group(group). ...... // 尝试建立连接 ChannelFuture f = b.connect(host, port).sync(); f.channel().closeFuture().sync(); } finally { // 优雅关闭相关线程组资源 group.shutdownGracefully(); } \",\"ServerBootStrap是客户端的启动引导类/辅助类，具体使用如下：\",\" // 1.bossGroup 用于接收连接，workerGroup 用于具体的处理 EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { //2.创建服务端启动引导/辅助类：ServerBootstrap ServerBootstrap b = new ServerBootstrap(); //3.给引导类配置两大线程组,确定了线程模型 b.group(bossGroup, workerGroup). ...... // 6.绑定端口 ChannelFuture f = b.bind(port).sync(); // 等待连接关闭 f.channel().closeFuture().sync(); } finally { //7.优雅关闭相关线程组资源 bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } \",\"可以看出：\",\"BootStrap通常使用connet()方法连接到远程的主机和端口，作为Netty TCP协议通信中的客户端。另外，Bootstrap也可以通过bind()方法绑定本地的一个端口，作为UDP协议通信中的一段\",\"ServerBootStrap通常使用bind()方法绑定在本地的端口上，然后等待客户端的连接\",\"BootStrap只需要配置一个事件循环组，而ServerBootStrap需要配置两个事件循环组，一个用于接收连接，一个用于具体的处理\"]},\"1227\":{\"h\":\"NioEventLoopGroup默认的构造函数会起多少线程？\",\"t\":[\"CPU核心线程数*2：\",\" // 从1，系统属性，CPU核心数*2 这三个值中取出一个最大的 //可以得出 DEFAULT_EVENT_LOOP_THREADS 的值为CPU核心数*2 private static final int DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(\\\"io.netty.eventLoopThreads\\\", NettyRuntime.availableProcessors() * 2)); // 当指定的线程数nThreads为0时，使用默认的线程数DEFAULT_EVENT_LOOP_THREADS protected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory, Object... args) { super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args); } \"]},\"1228\":{\"h\":\"Netty线程模型了解么？\",\"t\":[\"基于Reactor线程模型，Reactor采用多路复用将事件分发给相应的Handler处理，非常适合处理海量IO的场景。\"]},\"1229\":{\"h\":\"Netty服务端和客户端的启动过程了解么？\"},\"1230\":{\"h\":\"Netty长连接、心跳机制了解么？\"},\"1231\":{\"h\":\"Netty的零拷贝了解么？\",\"t\":[\"零拷贝是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域，这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。在OS层面上的零拷贝技术通常指避免在用户态和内核态之间来回拷贝数据。在Netty中，零拷贝主要体现在：\",\"使用Netty提供的CompositeByteBuf类，可以将多个ByteBuf合并为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝\",\"ByteBuf支持slice操作，因此可以将ByteBuf分为多个共享同一个存储区域的ByteBuf，避免了内存的拷贝\",\"通过FileRegion包装的FileChannel.tranferTo实现文件传输，可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题\"]},\"1232\":{\"h\":\"\"},\"1233\":{\"h\":\"Spring面试题\"},\"1234\":{\"h\":\"Spring框架中Bean的创建过程是怎样的？\",\"t\":[\"首先，简单来说，Spring框架中的Bean经历过四个阶段：实例化 -> 属性赋值 -> 初始化 -> 销毁\",\"然后，具体来说Spring中Bean经过了以下几个步骤：\",\"实例化：new **()两个时机，1、当客户端向容器申请一个Bean时，2、当容器在初始化一个Bean时还需要依赖一个Bean，BeanDefinition对象保存。\",\"设置对象属性（依赖注入）：Spring通过BeanDefinition找到对象依赖的其他对象，并将这些对象赋予当前对象。\",\"处理Aware接口，Spring会检测对象是否实现了***Aware接口，如果实现了，就会调用对应的方法。BeanNameAware、BeanClassLoaderAware、BeanFactoryAware、ApplicationContextAware。\",\"BeanPostProcess，Bean创建的前置处理。调用BeanPostProcess的初始化前的方法。\",\"InitializingBean：Spring检测对象如果实现了这个接口，就会执行afterPropertiesSet()方法\",\"init-method：自定义的初始化回调方法\",\"BeanPorcess的后处理的方法，到这里，这个Bean创建过程就完成了，Bean就可以正常使用了。\",\"DisposableBean，当Bena实现了这个接口，在对象销毁前就会调用destory()方法。\",\"destory-method：自定义Bean销毁的回调方法。\"]},\"1235\":{\"h\":\"Spring中Bean的作用域？\",\"t\":[\"来源\",\"说明\",\"singleton\",\"默认Spring Bean作用域，一个BeanFactory有且仅有一个实例\",\"prototype\",\"原型作用域，每次依赖查找和依赖注入生成新Bean对象\",\"request\",\"将Spring Bean存储在ServletRequest上下文中\",\"session\",\"将Spring Bean存储在HttpSession中\",\"application\",\"将Spring Bean存储在ServletContext中\",\"笼统而言，我们只要记住单例和原型两种即可，其余三种主要是为了服务端模板引擎渲染，包括JSP、Velocity、FreeMarker。\"]},\"1236\":{\"h\":\"Spring框架中的Bean是线程安全的吗？如果线程不安全，如何处理？\",\"t\":[\"Spring容器本身没有提供Bean的线程安全策略，因此，也可以说Spring容器中的Bean不是线程安全的。要如何处理线程安全问题。就要分情况来分析。对于线程安全问题：\",\"对于prototype作用域，每次都生成一个新的对象，所以不存在线程安全问题\",\"对于sington作用域，默认就是线程不安全的。但是对于开发中大部分的Bean，其实是无状态的，不需要保证线程安全\",\"无状态表示这个实例没有属性对象，不能保存数据，是不变的，比如：controller、service、dao；有状态表示实例有属性对象，可以保存数据，是线程不安全的，比如POJO。\",\"如果要保证线程安全，可以将Bean的作用改为prototype。也可以采用ThreadLocal来解决线程安全的问题，ThreadLocal为每一个线程保存一个副本变量，每个线程只操作自己的副本变量。\"]},\"1237\":{\"h\":\"Spring是如何处理循环依赖问题的？\",\"t\":[\"一种是使用@Lazy注解，另一种是使用三级缓存。\",\"循环依赖：多个对象之间存在循环的引用关系。在初始化过程中，就会出现”先有蛋还是先有鸡“的问题。\",\"@Lazy注解：解决构造方法造成的循环依赖问题\",\"对于对象之前的普通引用，二级缓存会保存new出来的不完整对象，这样当单例池中找不到依赖的属性时，就可以先从二级缓存中获取到不完整对象，完成对象的创建，在后续的依赖注入过程中，将单例池中对象的引用关系调整完成。\",\"三级缓存：如果引用的对象配置了AOP，那在单例池中最终就会需要注入动态代理对象，而不是原对象，而生成动态代理是要在对象初始化完成之后才开始的。于是Spring增加了三级缓存，保存所有对象的动态代理配置信息，在发现有循环依赖时，将这个对象的动态代理信息获取出来，提前进行AOP，生成动态代理。\"]},\"1238\":{\"h\":\"Spring如何处理事务?\",\"t\":[\"Spring当中支持编程式事务管理和声明式事务管理两种方式。\",\"1、编程式事务可以用TransactionTemlate\",\"2、声明式事务：是Spring在AOP基础上提供的事务实现机制，他的最大优点是不需要在业务代码中添加事务管理的代码，只需要在配置文件中做相关的事务规则声明就可以了，但是声明式事务只能针对方法级别，无法控制代码块级别的事务管理。Spring中对事务定义了不同的传播级别：\",\"PROPAGATION_REQUIRED：默认传播行为。如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入到事务中\",\"PROPAGATION_SUPPORTS：如果当前存在事务，就加入到该事务，如果当前不存在事务，就以非事务方式运行\",\"PROPAGATION_MANDATORY:如果当前存在事务，就加入到该事务，如果当前不存在事务，就抛出异常\",\"PROPAGATION_REQUIRES_NEW：无论当前存不存在事务，都创建新事务进行执行\",\"PROPAGATION_NOT_SUPPORTS：以非事务方式运行，如果当前存在事务，就将当前事务挂起\",\"PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，就抛出异常\",\"PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则按REQUIRED属性执行\",\"Spring中事务的隔离级别：\",\"ISOLATIUON_DEFAULT：使用数据库默认的事务隔离级别。\",\"ISOLATION_READ_UNCOMMITED：读未提交，允许事务在执行过程中，读取其他事务未提交的数据\",\"ISOLATION_READ_COMMITED：读已提交，允许事务在执行过程中，独去其他事务已经提交的数据\",\"ISOLATION_REPEATABLE_UNCOMMITED：可重复度，在同一个事务内，任意时刻的查询结果是一致的\",\"ISOLATION_READ_SERIALIZABLE：所有事务依次执行\",\"更多内容参考：深入浅出Spring事务的实现原理。\"]},\"1239\":{\"h\":\"Spring事务失效的场景有哪些？\",\"t\":[\"注解@Transactional配置的方法并非public权限修饰\",\"注解@Transactional所在类非Spring容器管理的Bean\",\"注解@Transactional所在类中，注解修饰的方法被类内部方法调用\",\"业务代码抛出异常类型非RuntimeException，事务失效\",\"业务代码中存在异常时，使用try...catch...语句块捕获，而catch语句块没有throw new RuntimeException异常\",\"注解@Transactional中Propagation属性值设置错误即Propagation.NOT_SUPPORTED\"]},\"1240\":{\"h\":\"Spring MVC中的控制器是不是单例模式？如果是，如何保证线程安全？\",\"t\":[\"控制器是单例模式，单例模式下就会有线程安全问题。\",\"Spring中保证线程安全的方法\",\"1、将scope设置成singleton，propotype，request。\",\"2、最好的方式是将控制器设计成无状态模式。在控制器中不要携带数据，但是可以引用无状态的service和dao。\"]},\"1241\":{\"h\":\"Spring MVC原理？\",\"t\":[\"核心原理的示意图：\",\"过程描述：\",\"将Spring MVC处理的请求映射到DispatcherServlet的servlet上\",\"DispatcherServlet通过HandlerMapping去查找当前请求URL对应的Handler（通常是Controller中对应的一个方法）\",\"执行对应的Handler方法\",\"执行的过程中可能会调用若干的Service来完成业务的处理\",\"DispatcherServlet根据ModelAndView中的ViewResolver（视图解析器）中找到对应的视图\",\"DispatcherServlet将ModelAndView中的Model交给对应的View进行视图的渲染\",\"渲染后，将视图转为HTTP响应流返回给客户端\",\"详细的示意图：\"]},\"1242\":{\"h\":\"Spring中的Service有多个实现类，怎么注入？\",\"t\":[\"使用@Qualifier(\\\"BeanId\\\")来指定注入哪一个\",\"使用@Resource(type=\\\"类名.class\\\")来指定注入哪一个\",\"每个Service的impl都可以指定名称（使用@Service(\\\"名称\\\")），在Controller中注入service的时候使用名称来指定注入哪一个（使用@Resource(name=\\\"名称\\\")）\"]},\"1243\":{\"h\":\"Spring Sercuity 和 Shiro有什么区别？\"},\"1244\":{\"h\":\"\"},\"1245\":{\"h\":\"SpringBoot面试题\"},\"1246\":{\"h\":\"为什么SpringBoot的 jar可以直接运行？\",\"t\":[\"详细参见：SpringBoot的 jar可以直接运行。\"]},\"1247\":{\"h\":\"SpringBoot自动装配过程及实现原理？\"},\"1248\":{\"h\":\"SpringBoot如何防止表单重复提交？\",\"t\":[\"幂等性，通俗的说就是一个接口，多次发起同一个请求，必须保证操作只能执行一次。\",\"需要幂等性的场景：\",\"订单接口，不能多次创建订单\",\"支付接口，重复支付同一笔订单只能扣一次钱\",\"支付宝回调接口，可能会多次回调，必须处理重复回调\",\"普通表单提交接口，因为网络超时、卡顿等原因多次点击提交，只能成功一次等等\",\"常见的方案：\",\"从数据库方面考虑，数据设计的时候，如果有唯一性，考虑建立唯一索引\",\"从应用层面考虑，首先判断是单机服务还是分布式服务\",\"单机服务：考虑一些缓存Cache，利用缓存，来保证数据的重复提交\",\"分布式服务：考虑将用户的信息，例如token和请求的url进行组装在一起形成令牌，存储到缓存中，例如redis，并设置超时时间为**秒，如此来保证数据的唯一性（利用了redis的分布式锁）\",\"解决方案大致总结如下：\",\"唯一索引：防止新增脏数据\",\"token机制：防止页面重复提交，实现接口的幂等性校验\",\"分布式锁：redis（jredis、redisson）或zookeeper实现\",\"悲观锁：获取数据的时候加锁（锁表或锁行）\",\"乐观锁：基于版本号version实现，在更新数据那一刻校验数据\",\"状态机：状态变更，更新数据时判断状态\",\"其中，前三种最为常见，更多内容可以参考：SpringBoot/Web项目防止表单/请求重复提交（单体和分布式）\"]},\"1249\":{\"h\":\"如何自己写一个SpringBoot Starter？\",\"t\":[\"参见：手把手教你写一个 Starter。\"]},\"1250\":{\"h\":\"\"},\"1251\":{\"h\":\"Elasticsearch\"},\"1252\":{\"h\":\"什么是倒排索引？有什么好处？\",\"t\":[\"索引：从id到内容。\",\"倒排索引：从内容到id。好处：比较适合做关键字检索。可以控制数据的总量。提高查询效率。\"]},\"1253\":{\"h\":\"搜索引擎为什么MySQL查询快？\"},\"1254\":{\"h\":\"ES了解多少？说说你们公司的ES集群架构。\",\"t\":[\"是一个基于Lucene框架（是一个非常高效的全文检索引擎框架）的搜索引擎产品，you know for search,提供了restful风格的操作接口。\",\"ES包含了一些核心概念：\",\"索引 index：类似关系型数据库中的table\",\"文档 document：row\",\"字段 field text\\\\keyword\\\\byte：列\",\"映射Mapping：Schema\",\"查询方式：DSL（ES的新版本也支持SQL）\",\"分片sharding和副本replicas：index都是由sharding组成的。每个sharding都有一个或者多个备份。\",\"另外关于ES的使用场景：ES可以用在大数量的搜索场景下，另外ES也有很强大的计算能力，可以用在用户画像等场景。\"]},\"1255\":{\"h\":\"如何进行中文分词？\",\"t\":[\"IK分词器。HanLp中文分词器。\"]},\"1256\":{\"h\":\"ES写入数据与查询数据的原理。\",\"t\":[\"写入数据的原理：\",\"客户端发写数据的请求是，可以发往任意节点，这个节点就会成为coordinating node 协调节点\",\"计算的点文档要写入的分片：计算时就采用hash取模的方式计算\",\"协调节点就会进行路由，将请求转发给对应的primary sharding所在的datanode。\",\"datanode节点上的primary sharding处理请求，写入数据到索引库，并且将数据同步到对应的replica sharding\",\"等promary sharding 和 replica sharding都保存好文档了之后，返回客户端响应\",\"查询数据的原理：\",\"客户端发送请求可发给任意节点，这个节点就成为协调节点；\",\"协调节点将查询请求广播到每一个数据节点，这些数据节点的分片就会处理该查询请求；\",\"每个分片进行数据查询，将符合条件的数据放在一个队列当中，并将这些数据的文档ID、节点信息、分片信息都返回给协调节点；\",\"由协调节点将所有的返回结果进行汇总，并排序；\",\"协调节点向包含这些文档ID的分片发送get请求，对应的分片将文档数据返回给协调节点，最后协调节点将数据整合返回给客户端。\"]},\"1257\":{\"h\":\"ES部署时，要如何进行优化？\",\"t\":[\"集群部署优化\",\"调整ES的一些重要参数。path.data尽量使用固态硬盘，定制JVM堆内存大小，ES的参数，实际上大部分情况下是不需要调优的，如果有性能问题，最好的办法是安排更合里的sharding布局并且增加节点数据。\",\"更合理的sharding布局，让sharding对应的replica sharding尽量在同一个机房。\",\"Linux服务器上一些优化策略，不要用root用户：修改虚拟内存大小，修改普通用户可以创建的最大线程数。\",\"ES生态：ELK日志收集解决方案：filebeat -> logstash -> elaticsearch -> kibana。\"]},\"1258\":{\"h\":\"\"},\"1259\":{\"h\":\"MySQL\"},\"1260\":{\"h\":\"MySQL有哪几种数据存储引擎?\",\"t\":[\"可以使用SQL查看支持的数据存储引擎：\",\"show ENGINES; \",\"其中最为常用的是InnoDB和MyISAM两种，\",\"MyISAM和InnoDB的区别：\",\"存储文件，MyISAM每个表有两个文件，MYD和MyISAM文件，MYD是数据文件，MYI是索引文件，而InnoDB每个表只有一个文件，idb\",\"InnoDB支持事务，支持行锁，支持外键。\",\"InnoDB支持XA事务。\",\"InnoDB支持事务的savePoints\"]},\"1261\":{\"h\":\"什么是脏读、不可重复读、幻读？\",\"t\":[\"脏读、不可重复读、幻读的概念：\",\"脏读：在事务进行过程中，读到了其他事务未提交的数据。\",\"不可重复读：在一个事务过程中，多次查询的结果不一致。（update）\",\"幻读：在同一个事务中，用同样的操作查询数据，得到的记录数不相同。(insert)\",\"处理的方式有很多种：加锁、事务隔离、MVCC，这里只介绍使用加锁来解决这些问题：\",\"类型\",\"处理方式\",\"脏读\",\"在修改时加排他锁，直到事务提交提交才释放，读取时加共享锁，读完释放锁\",\"不可重复读\",\"读数据时加共享锁，写数据时加排他锁\",\"幻读\",\"加范围锁\"]},\"1262\":{\"h\":\"事务的基本特性和隔离级别\",\"t\":[\"事务：表示多个数据操作组成一个完整的事务单元，这个事务内的所有数据操作要么同时成功，要么同时失败。\",\"事务的特性：ACID\",\"原子性：事务是不可分割的，要么完全成功，要么完全失败。\",\"一致性：事务无论是完成还是失败。都必须保持事务内操作的一致性。当失败是，都要对前面的操作进行会滚，不管中途是否成功。\",\"隔离性：当多个事务操作一个数据的时候，为防止数据损坏，需要将每个事务进行隔离，互相不干扰\",\"持久性：事务开始就不会终止，他的结果不受其他外在因素的影响\",\"在MySQL中可以设置事务的隔离级别：\",\"SQL语句\",\"含义\",\"SHOW VARIABLES like '%transaction'\",\"显示事务的隔离级别\",\"set transction level **\",\"设置隔离级别\",\"set session transaction level **\",\"当前会话的事务隔离级别\",\"set global transaction level **\",\"当前全局的事务隔离级别\",\"MySQL当中有五种隔离级别：\",\"隔离级别\",\"具体含义\",\"NONE\",\"不使用事务\",\"READ UNCOMMITED\",\"允许脏读\",\"READ COMMITED\",\"防止脏读，是最常用的隔离级别\",\"REPEATABLE READ\",\"防止脏读和不可重复读，MySQL默认\",\"SERIALIZABLE\",\"事务串行，可以防止脏读、幻读、不可重复度\",\"五种隔离级别，级别越高，事务的安全性是更高的，但是，事务的并发性能也会越低。\"]},\"1263\":{\"h\":\"MySQL的锁有哪些？什么是间隙锁？\",\"t\":[\"从锁的粒度来区分：\",\"1）行锁：加锁粒度小，但是加锁的资源开销比较大。InnoDB支持\",\"共享锁：读锁，表示多个事务可以对同一个数据共享同一把锁，持有锁的事务都可以访问数据，但是只读不能修改。 select ** LOCK IN SHARE MODE\",\"排他锁：写锁，只有一个事务能够获得排他锁，其他事务都不能获取该行的锁。InnoDB会对update，delete、insert语句自动添加排他锁。select ** for update。\",\"自增锁：通常是针对MySQL当中的自增字段。如果有事务会滚这种情况，数据会回滚，但是自增序列不会回滚。\",\"2）表锁：加锁粒度大，加锁资源开销比较小，MyIAM和InnoDB都支持。\",\"表共享读锁，表排他写锁\",\"意向锁：是InnoDB自动添加的一种锁，不需要用户干预。\",\"3）全局锁：Flush tables with read lock，加锁之后整个数据库实例都处于只读状态，所有的数据变更操作都会被挂起，一般用于全库备份的时候\",\"常见的锁算法：\",\"1、记录锁：锁一条具体的数据。\",\"2、间隙锁：RR隔离级别下，会加间隙锁。锁一定的范围，而不是锁具体的记录，是为了防止产生幻读。\",\"3、Next-key：间隙锁 + 右记录锁。\"]},\"1264\":{\"h\":\"MySQL索引结构是什么样的？\",\"t\":[\"MySQL采用B+树作为存储索引的数据结构。\"]},\"1265\":{\"h\":\"Mysql的索引结构为什么使用B+树？\",\"t\":[\"总体来说有以下好处：\",\"可以减少磁盘IO的次数\",\"能够很好的同时支持等值查询和范围查询 \",\"等值查询：哈希表、跳表不适合范围查询\",\"范围查询：二叉树/红黑树可以很好的满足范围查询，但当树过高时，会带来磁盘IO过高的问题；B树的范围查询，会一直到根节点再到叶子节点查询，B+树解决了范围查询的带来的问题\",\"B树的查询效率不稳定，在O(1-logN)之间，而B+树可以稳定在O(logN)\",\"完整链接：MySQL 为什么采用 B+树作为索引。\"]},\"1266\":{\"h\":\"聚簇索引和非聚簇索引有什么区别？\",\"t\":[\"聚簇索引：数据和索引是在一起。\",\"非聚簇索引：数据和索引不在一起。\",\"MyISAM使用的非聚簇索引，树的子节点上的data不是数据本身，而是数据存放的地址，InnoDB采用的是聚簇索引，树的叶子节点上的data就是数据本身。\",\"聚簇索引的数据是物理存放顺序和索引顺序是一致的，所以一个表中只能有一个聚簇索引，而非聚簇索引可以有多个。\",\"InnoDB中，如果表定义了PK，那PK就是聚簇索引，如果没有PK，就会找一个非空的unique列作为聚簇索引。否则，InnoDB会创建一个隐藏的row-id作为聚簇索引。\"]},\"1267\":{\"h\":\"MySQL主键索引和普通索引有什么区别？\"},\"1268\":{\"h\":\"MySQL的索引覆盖和回表是什么？\",\"t\":[\"如果只需要在一颗索引树上就可以获取SQL所需要的所有列，就不需要再回表查询，这样查询速度就可以更快。\",\"实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引当中。\"]},\"1269\":{\"h\":\"MySQL集群是如何搭建的？读写分离是怎么做的？\",\"t\":[\"MySQL主从结构原理：\",\"MySQL通过将主节点的Binlog同步给从节点完成主从之间的数据同步。\",\"MySQL的主从集群只会讲Binlog从主节点同步到从节点，而不会反过来同步问题。\",\"因为要保证主从之间的数据一致，写数据的操作只能在主节点完成。而读数据的操作，可以在主节点或者从节点上完成。\",\"这种方式有丢失数据的风险，可以采用半同步的方式：\"]},\"1270\":{\"h\":\"MySQL如何进行分库分表？多大数据量需要进行分库分表？分库分表的方式和分片策略由哪些？分库分表后，SQL语句执行流程是怎样的？\",\"t\":[\"什么是分库分表：就是当表中的数据量过大时，整个查询效率就会降低的非常明显，这是为了提升查询效率，就要将一个表中的数据分散到多个数据库的多个表当中。\",\"数据分片的方式有垂直分片和水平分片。垂直分片就是从业务角度将不同的表拆分到不同的表中，能够解决数据库数据文件过大的问题，但是不能从根本上解决查询问题。水平分片就是从数据角度将一个表中的数据拆分到不同的库或者表中，这样可以从根本上解决数据量过大造成的查询效率低的问题。\",\"常见的分片策略有：\",\"取余/取模：优点：均匀存放数据，缺点，扩容非常麻烦\",\"按照范围分片：比较好扩容，数据分布不够均匀\",\"按照时间分片：比较容易将热点数据区分出来\",\"按照枚举值分片：例如按地区分片\",\"按照目标字段前缀指定进行分区：自定义业务规则分片\",\"建议：一个表的数据量超过500W或者数据文件超过2G，就要考虑分库分表了，分库分表最常用的组件：MyCat、ShardingSphere\",\"ShardingSphere分库分表的执行流程：\",\"与之相关的会衍生出一系列的问题，例如一个user表，按照userid进行了分片，然后我需要按照sex字段去查，这样怎么查？强制指定只查一个数据库，要怎么做？查询结果按照userid来排序，要怎么排？\",\"分库分表也并不是完美的，在解决了一些问题的同时，也带来了一定的缺点：\",\"事务一致性问题\",\"跨节点关联查询问题\",\"跨节点分页、排序函数\",\"主键避重\"]},\"1271\":{\"h\":\"Mysql的三种删除方式的区别？\",\"t\":[\"删除方式\",\"区别\",\"delete\",\"删除数据，保留表结构，可以有条件的删除，也可以回滚数据，删除数据时进行两个动作：删除与备份\",\"truncate\",\"删除所有数据，无条件选择删除，不可回滚，保留表结构\",\"drop\",\"删除数据和表结构 删除速度最快\"]},\"1272\":{\"h\":\"慢SQL的优化思路？\",\"t\":[\"SQL优化的思路：\",\"定位优化对象的性能瓶颈，确定时IO还是CPU瓶颈\",\"从Explain入手，保证索引生效\"]},\"1273\":{\"h\":\"limit语句会扫描全表吗？\"},\"1274\":{\"h\":\"大数量分页查询该怎么优化？\"},\"1275\":{\"h\":\"平时项目里面表结构是如何进行设计的？\"},\"1276\":{\"h\":\"MySQL的索引类型？\",\"t\":[\"MySQL目前主要有以下几种索引类型：\",\"普通索引\",\"唯一索引\",\"主键索引\",\"组合索引\",\"全文索引\"]},\"1277\":{\"h\":\"MySQL如何快速插入千万级数据？\",\"t\":[\"参见：大批量数据高效插入数据库表\",\"要点总结：\",\"使用批处理语句（可能需要修改MySQL的Max_allowed_packet配置项）\",\"开启事务，在事务内进行插入操作\",\"数据有序插入，避免B+树出现分裂合并\",\"补充：\",\"避免使用ORM框架\"]},\"1278\":{\"h\":\"\"},\"1279\":{\"h\":\"Redis\"},\"1280\":{\"h\":\"Redis支持哪些数据类型？\",\"t\":[\"Redis支持以下几种数据类型：\",\"String（字符串）：最基本的数据类型，可以存储字符串、整数或浮点数。\",\"Hash（哈希）：存储键值对的无序散列表，适合存储对象。\",\"List（列表）：有序的字符串列表，可以在列表的两端进行插入和删除操作，支持对列表进行修剪和范围查询。\",\"Set（集合）：无序且唯一的字符串集合，支持对集合进行添加、删除和成员判断等操作。\",\"Sorted Set（有序集合）：与集合类似，每个成员关联一个分数，根据分数进行排序。支持添加、删除、按分数范围获取成员等操作。\",\"Bitmap（位图）：可以对位进行设置或获取，常用于记录用户行为、统计等场景。\",\"HyperLogLog：使用极小的内存空间对大量的唯一元素进行基数估算，用于统计独立用户数量等。\",\"Geospatial（地理位置）：存储地理位置信息（经度和纬度），支持查询附近位置、计算距离等操作。\"]},\"1281\":{\"h\":\"什么是缓存穿透？缓存击穿？缓存雪崩？怎么解决？\"},\"1282\":{\"h\":\"缓存穿透\",\"t\":[\"缓存穿透：缓存中查不到，数据库中也查询不到。\",\"解决方案：\",\"对参数进行合法性校验\",\"将数据库中没有查到的结果的数据也写入到缓存，这时要注意为了防止Redis被无用的key占满，这一类缓存的有效期要设置得短一点\",\"引入布隆过滤器，在访问Redis之前判断数据是否存在。要注意布隆过滤器存在一定的误判率，并且，不空过滤器只能加数据不能删数据。\"]},\"1283\":{\"h\":\"缓存击穿\",\"t\":[\"缓存击穿：缓存中没有，数据库中有，一般是出现在数据初始化以及key过期了的情况，他的问题在于，重新写入缓存需要一定的时间，如果是在高并发场景下，过多的请求就会瞬间写到DB上，给DB造成了很大的压力。\",\"解决方案：\",\"使用二级缓存：在系统架构中引入二级缓存，将热点数据缓存在内存中的一级缓存中，同时使用持久化存储作为二级缓存，当一级缓存失效时，可以从二级缓存中获取数据，避免直接访问后端服务\",\"使用热点数据预加载（Cache Pre-warm）：在系统启动或热点数据即将过期之前，提前主动加载热点数据到缓存中，避免在热点数据失效时出现大量请求。通过定时任务或异步线程更新缓存，确保热点数据的实时性\",\"设置热点数据永不过期：对于一些热点数据，可以设置其过期时间为永不过期，或者设置一个相对较长的过期时间，以确保热点数据不会过期失效。但是需要注意，这种方式可能会导致缓存数据与数据库的数据不一致，需要在后端服务更新数据时同时更新缓存\",\"添加互斥锁（Mutex Lock）：在缓存失效的情况下，只允许一个请求访问后端服务或数据库，并将结果缓存起来。其他请求在等待该请求的执行结果时，直接从缓存中获取数据，避免对后端服务的重复访问。这种方式可以防止大量请求同时访问后端服务，减轻服务压力\",\"使用布隆过滤器（Bloom Filter）：布隆过滤器是一种高效的数据结构，用于判断某个元素是否存在于集合中。可以将热点数据的键存储在布隆过滤器中，当请求到来时，先通过布隆过滤器判断该键是否存在于缓存中，如果不存在，就不再访问后端服务，避免缓存穿透和击穿。\"]},\"1284\":{\"h\":\"缓存雪崩\",\"t\":[\"缓存雪崩：缓存大面积过期，导致请求都被转发DB。\",\"解决方案：\",\"把缓存的失效时间分散开，例如，在原有的统一失效时间基础上，增加一个随机值。\"]},\"1285\":{\"h\":\"如何保证Redis与数据库的数据一致？\",\"t\":[\"当我们对数据进行修改的时候，到底是先删缓存，还是先写数据库？\"]},\"1286\":{\"h\":\"先删缓存，再写数据库\",\"t\":[\"在高并发场景下，当第一个线程删除了缓存，还没有来得及的写数据库，第二个线程来独去数据，会发现缓存中的数据为空，那就会去读数据库中的数据（旧值、脏数据）读完之后，把读到的结果写入缓存（此时，第一个线程已经将新的值写到缓存里面了），这样缓存中的值就会被覆盖为修改前的脏数据。\",\"总结：在这种方式下，通常要求写操作不会太频繁。\",\"解决方案：\",\"先操作缓存，但是不删除缓存，将缓存修改为一个特殊值（-999），客户端读缓存时，发现是默认直，就休眠一小会，再去查一次Redis，特殊值对业务有侵入，可能会多次重复\",\"延时双删，先删除缓存，再写数据库，休眠一小会，再次删除缓存。如果数据写操作很频繁，同样还是会有脏数据的问题。\"]},\"1287\":{\"h\":\"先写数据库，再删缓存\",\"t\":[\"先写数据库，再删缓存，如果数据库写完了之后，缓存删除失败，数据就会不一致， 总结：始终只能保证一定时间内的最终一致性。\",\"解决方案：\",\"给缓存设置一个过期时间，问题：过期时间内，缓存数据不会更新\",\"引入MQ，保证原子操作。将热点数据缓存设置为永不过期，但是在value当中写入一个逻辑上的过期时间，另起一个后台线程，扫描这些key，对于已逻辑上过期的缓存，进行删除\"]},\"1288\":{\"h\":\"如何设计一个分布式锁？如何对锁性能进行优化？\",\"t\":[\"分布式锁的本质：就是在所有进程都能访问到的一个地方，设置一个锁资源，让这些进程都来竞争锁的资源，数据库、zookeeper、Redis，通常对于分布式锁，会要求响应快、性能高与业务无关。\",\"Redis实现分布式锁：SETNX key value 当key不存在时，就将key设置为value，并返回1，如果key存在就返回0。EXPIRE key locktime 设置key的有效市场，DEL key 删除。 GETSET key value 先GET，再SET，先返回key对应的值，如果没有就返回空，然后再将key设置成value。\",\"最简单的分布式锁：SETNX 加锁。DEL解锁。问题：如果获取到锁的进程执行失败，他就永远不会主动解锁，那这个锁就被锁死了。\",\"给锁设置过期时长。问题：SETNX和EXPIRE并不是原子性的，所以获取到锁的进程有可能还没有执行EXPIRE指令，就挂了，这时锁还是会被锁死。\",\"将锁的内容设置为过期时间（客户端时间+过期时长），SETNX获取锁失败时，拿这个时间跟当前时间比对，如果是过期的锁，就先删除锁，再重新上锁。问题：在高并发场景下，会产生多个进程同时拿到锁的情况\",\"setNX失败后，获取锁上的时间戳，然后用getset，将自己的过期时间更新上去，并获取旧值，如果这个旧值，跟之前获得的时间戳是不一致的，就表示这个锁已经被其他进程占用了，自己要放弃竞争锁。\",\"public boolean tryLock(RedisConnection conn) { long newTime = System.currentTimeMillis(); long expireTime = nowTime + 100; if(conn.SETNX(\\\"mykey\\\"),\\\"1\\\") == 1) { conn.EXPIRE(\\\"mykey\\\",1000) return true; }else { long oldVal = conn.get(\\\"mykey\\\") if(oldVal == null && oldVal < nowTime) { long currentVal = conn.GETSET(\\\"mykey\\\",expireTime) if(oldVal == currentVal) { conn.EXPIRE(\\\"mykey\\\",1000); return true; } return false; } return false; } } \",\"上面就形成了一个比较高效的分布式锁。分析一下，上面优化的各种问题，在于SETNX和EXPIRE两个指令无法保证原子性。Redis2.6提供了直接执行lua脚本的方式，通过lua脚本来保证原子性，redission。\"]},\"1289\":{\"h\":\"Redis的过期删除策略？\",\"t\":[\"redis设置key的过期时间：\",\"$ EXPIRE | SETEX \",\"实现原理：\",\"定期删除：每隔一段时间，执行一次删除过期key的操作，平衡执行效率和执行时长。定期删除会遍历每个database（默认16个），检查当前库中指定个数的key（默认是20个），随机抽查这些key，如果有过期的，就删除。程序中有一个全局变量扫描到了哪个数据库。\",\"懒汉式删除：当使用get、getset等指令去获取数据时，判断key是否过期，过期后，就先把key删除，再执行后面的操作。\",\"Redis是将两种方式结合来使用的。\"]},\"1290\":{\"h\":\"RDB操作，子进程会全部复制父进程的数据吗？\",\"t\":[\"RDB快照是一次全量备份，当进行快照持久化的时候会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以快照持久化期间修改的数据不会保存，存在丢失数据的可能性。\"]},\"1291\":{\"h\":\"Redis的哨兵模式？\",\"t\":[\"哨兵模式是Redis一种特殊的模式，Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。\"]},\"1292\":{\"h\":\"Redis使用单线程为什么速度这么快？\",\"t\":[\"严格意义上来说，Redis Server是多线程的，只是它的请求处理整个流程是单线程处理的，我们平常说的Redis单线程快是指它的请求处理非常地块。\",\"Redis每秒可以承受10w+的QPS，它如此优秀的性能主要取决于以下几个方面：\",\"纯内存操作\",\"所有的数据都存储在内存当中，这意味着读写数据都是在内存中完成，并且使用哈希表的数据结构，只需要O(1)的时间复杂度。\",\"使用IO多路复用技术\",\"Redis采用IO多路复用计数和非阻塞IO，Redis可以在单线程中监听多个Socket的请求，在任意一个Socket可读/可写时，Redis去读取客户端请求，在内存中操作对应的数据，然后再写回到Socket中。\",\"非CPU密集型任务\",\"Redis的大部分操作并不是CPU密集型任务，而Redis的瓶颈在于内存和网络带宽，如果单个Redis实例的性能不足以支撑业务，推荐部署多个Redis节点，组成集群的方式来利用多核CPU的能力。\",\"单线程的优势\",\"没有了线程上下文切换的性能耗损，也没有了访问共享资源加锁的性能损耗，开发和调试非常友好，可维护性高。\"]},\"1293\":{\"h\":\"Redis自增命令使用？\",\"t\":[\"每当有原子性自增的操作就可以使用INCR命令，主要在计数器场景使用，可以INCR和EXPIRE，来达到规定的生存时间内进行计数的目的，客户端也可以通过使用GETSET命令原子性地获取计数器的当前值并将计数器清零。\",\"使用其他自增/自减操作，比如DECR和INCRBY，用户可以通过执行不同的操作增加或者减少计数器的值。\"]},\"1294\":{\"h\":\"Redis如何实现消息队列？\"},\"1295\":{\"h\":\"Redisson实现分布式锁的原理？\"},\"1296\":{\"h\":\"Redis为什么能通过Lua脚本保证并发的线程安全？\"},\"1297\":{\"h\":\"谈一下Redis事务的了解？\",\"t\":[\"Redis中事务的实现特征：\",\"在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行\",\"和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行\",\"我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为\\\"BEGIN TRANSACTION\\\"语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行EXEC/DISCARD命令来提交/回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT/ROLLBACK语句\",\"在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行\",\"当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了\"]},\"1298\":{\"h\":\"Pipeline有什么好处，为什么要用pipeline？\",\"t\":[\"可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。\"]},\"1299\":{\"h\":\"Redis延迟队列怎么实现的？\",\"t\":[\"详细参见：Redis延迟队列。\"]},\"1300\":{\"h\":\"Redis在内存不足时，内存淘汰策略是怎么样的？\",\"t\":[\"以下是Redis的内存淘汰策略：\",\"noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错并返回错误信息\",\"allkeys-lru：Least Recently Used (LRU) 最近最少使用策略，从所有的键中选择最近最少使用的键进行删除\",\"volatile-lru：从设置了过期时间的键中选择最近最少使用的键进行删除\",\"allkeys-random：随机选择要删除的键\",\"volatile-random：从设置了过期时间的键中随机选择要删除的键\",\"volatile-ttl：根据键的剩余过期时间来选择删除键，越早过期的键优先删除\",\"volatile-lfu：Least Frequently Used (LFU) 最不经常使用策略，从设置了过期时间的键中选择使用频率最低的键进行删除\"]},\"1301\":{\"h\":\"如何保证Redis的高可用？\"},\"1302\":{\"h\":\"\"},\"1303\":{\"h\":\"微服务\"},\"1304\":{\"h\":\"谈谈你对微服务的理解，微服务有哪些优缺点？\",\"t\":[\"微服务是由Martin Flowler大师提出的。微服务是一种架构风格，通过将大型的单体应用划分为比较小的服务单元，从而降低整个系统的复杂度。\",\"具有以下优点：\",\"服务部署更灵活：每个应用都可以是一个独立的项目，可以独立部署，不依赖其他服务，耦合性降低。\",\"技术选型更加灵活，在大型大体应用中，技术要进行更新，往往是非常困难的。而微服务可以根据业务特点，灵活选择技术栈。\",\"应用的性能得到提高，大型单体应用中，往往启动就会成为一个很大的难关，而采用微服务之后，整个系统的性能是能够提高的。\",\"更容易组合专门的团队，在单体应用中，团队成员往往需要对系统的各个部分都要有深入的了解，门槛是很高的。而采用微服务之后，可以给每个微服务组件专门的团队\",\"代码复用：很多底层服务可以以REST API的方式对外提供统一的服务，所有基础服务可以在整个微服务系统中调用。\",\"对应的有以下缺点：\",\"服务调用的复杂性提高了，面临网络问题、容错问题、负载问题、高并发等等问题\",\"分布式事务，尽量不要使用微服务的分布式事务\",\"测试的难度提升了\",\"运维的难度提升了，单体架构只要维护一个环节，而到了微服务是很多个环境，并且运维方式还都不一样。所以对部署、监控、告警等要求就会变得非常困难\"]},\"1305\":{\"h\":\"SpringCloud和SpringCloudAlibaba有哪些组件？都解决了什么问题？\",\"t\":[\"SpringCloud是提供了构建微服务系统所需要的一组通用开发模式以及一系列快速实现这些开发模式的工具。通常所说的SpringCloud是指SpringCloud NetFlix，它和SpringCloudAlibaba都是SpringCloud这一系列开发模式的具体实现。\",\"SpringCloud NetFlix架构图：\",\"SpringCloudAlibaba架构图：\"]},\"1306\":{\"h\":\"SpringCloud和Dubbo的区别？\",\"t\":[\"SpringCloud使用基于HTTP的REST方式，而Dubbo采用RPC通信。这两种方式各有优劣，前者牺牲了服务调用的性能，但也能避免原生RPC带来的问题，不存在代码级别的强依赖。\"]},\"1307\":{\"h\":\"分布式事务如何处理？怎么保证事务一致性？\",\"t\":[\"详细参见：深入浅出分布式事务的实现原理。\"]},\"1308\":{\"h\":\"怎么拆分微服务？怎样设计出高内聚、低耦合的微服务？\",\"t\":[\"拆分微服务的时候，为了保证微服务的稳定，会有一些基本的准则：\",\"微服务之间尽量不要有业务交叉。\",\"微服务之间只能通过接口进行服务调用，而不能绕过接口直接访问对方的数据\",\"高内聚，低耦合。\",\"高内聚低耦合，是一种从上而下指导微服务设计的方法。·实现高内聚低耦合的工具主要有同步的接口调用和异步的事件驱动（MQ）两种方式。\"]},\"1309\":{\"h\":\"有没有了解通过DDD领域驱动设计？\",\"t\":[\"什么是DDD：在2004年，由Eric Evans提出的，DDD是面对软件复杂之道。Domain-Driven-Design\",\"Martin Flowler - 贫血模型 - 贫血失忆症 充血模型\",\"MVC架构 -> 领域优先的四层架构\",\"大泥团：不利于微服务的拆分，大泥团结构拆分出来的微服务就是泥团结构，当服务业务逐渐复杂，这个泥团又会膨胀成为大泥团。\",\"DDD只是一种方法论，没有一个稳定的技术框架。DDD要求领域是跟技术无关、跟存储无关、跟通信无关。\"]},\"1310\":{\"h\":\"微服务的链路追踪、持续集成、AB发布要怎么做？\",\"t\":[\"链路追踪：\",\"基于日志，形成全局事务ID，落地到日志文件。filebeat -logstash- Elaticsearch形成大型报表\",\"基于MQ，往往需要架构支持，经过流式计算形成一些可视化的结果\",\"持续集成：通过jenkins自动化构建任务\",\"AB发布：\",\"AB发布又称蓝绿发布：红黑发布。老版本和新版本是同时存在的\",\"灰度发布：金丝雀发布\"]},\"1311\":{\"h\":\"Nacos和Eureka的区别？\",\"t\":[\"Nacos提供了服务的注册与发现，同时也提供了配置中心，而Eureka只提供了服务注册与发现\",\"Nacos本身支持负载均衡，而Eureka不支持\",\"Nacos同时支持AP和CP模式，而Eureka只满足AP模式\",\"CAP原则又称为CAP定理，指的是在一个分布式系统中，Consistency（一致性），Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。\"]},\"1312\":{\"h\":\"Nacos配置中心，本地Resource，jar包中同级目录的配置文件加载优先级？\"},\"1313\":{\"h\":\"Nacos的配置动态更新原理？\",\"t\":[\"nacos配置动态更新原理\"]},\"1314\":{\"h\":\"使用Nacos配置中心，@Value对应的配置项如何动态更新？\"},\"1315\":{\"h\":\"Nacos中命名空间和分组的概念及区别？\"},\"1316\":{\"h\":\"Nacos同一个namespace中的不同的group注册的服务可以相互访问吗？\"},\"1317\":{\"h\":\"Nacos服务注册的流程是怎么样的？\"},\"1318\":{\"h\":\"微服务下服务a调用服务b的流程？\"},\"1319\":{\"h\":\"注册中心，如何通过服务名找到服务实例？\"},\"1320\":{\"h\":\"熔断和限流有什么区别？\",\"t\":[\"降级-熔断-限流\"]},\"1321\":{\"h\":\"雪花算法有什么缺点？\"},\"1322\":{\"h\":\"Gateway有哪些功能？如何配置动态路由？\"},\"1323\":{\"h\":\"如何手写一个注册中心？\"},\"1324\":{\"h\":\"\"},\"1325\":{\"h\":\"消息队列\"},\"1326\":{\"h\":\"ＭＱ有什么用？有哪些具体的使用场景？\",\"t\":[\"队列是一种FIFO先进先出的数据结构，而MQ（Message Queue）即消息队列消息，主要作用就是由生产者发送到ＭＱ进行排队，然后由消费者对消息进行处理，具体使用场景如下：\",\"异步：作用能提高系统的响应速度和吞吐量。\",\"解耦：服务之间解耦，可以减少服务之间的影响，提高系统的稳定性和可扩展性，另外，解耦之后可以实现数据分发，生产者发送一个消息后，可以由多个消费者来处理。\",\"削峰：以稳定的系统资源应对突发的流量冲击。\",\"不过，ＭＱ也有一些缺点：\",\"系统的可用性降低：一旦ＭＱ宕机，整个服务就会产生影响。\",\"系统的复杂度提高：引入ＭＱ之后，数据链路就会变得很复杂，并伴随着很多的问题，例如如何保证消息不丢失？消息不会重复调用？怎么保证消息的顺序性？等等\",\"数据一致性：Ａ系统发消息，需要B、Ｃ两个系统一同处理。如果Ｂ系统处理成功，Ｃ系统处理失败，这就会造成数据一致性的问题。\"]},\"1327\":{\"h\":\"如何进行产品选型？\",\"t\":[\"Kafka\",\"RabbitMQ\",\"RocketMQ\",\"优点\",\"吞吐量非常大，性能非常好，集群高可用\",\"消息可靠性高，功能全面\",\"高吞吐，高性能，高可用，功能非常全面\",\"缺点\",\"会丢数据，功能比较单一\",\"吞吐量比较低，消息积累会严重影响性能\",\"开源版功能不如云上商业版。官方文档和周边生态还不够成熟。客户端只支持Java\",\"适用场景\",\"日志分析、大数据采集\",\"小规模场景\",\"几乎是全场景\"]},\"1328\":{\"h\":\"如何保证消息不丢失？\",\"t\":[\"这个问题主要分为两个方面，第一，哪些环节会造成消息丢失？第二，在这些可能会造成消息丢失的场景下，如何保证不丢失。\",\"总的来说，消息传递过程中如果存在跨网络的请求，或者由IO操作，就有可能会造成消息丢失，具体如下图：\",\"那么如何保证消息不丢失呢？需要按照上面不同场景来单独处理\",\"生产者发送消息不丢失\",\"产品类型\",\"保证生产者发送消息不丢失策略\",\"kafka\",\"消息发送+回调\",\"RocketMQ\",\"事务消息\",\"RabbitMQ\",\"消息发送+回调\",\"手动事务：Channel：txSelect()开启事务，Channel.txCommit()提交事务，Channel.txRollback()回滚事务，这种方式对channel是会产生阻塞的，造成吞吐量下降\",\"publisher confirms。整个处理流程跟RocketMQ的事务消息，基本是一样的。\",\"具体见下图：\",\"MQ主从消息同步不丢失\",\"产品类型\",\"主从消息不丢失策略\",\"RoctMQ\",\"在普通集群中，同步同步、异步同步。异步同步效率更高，但是有丢消息的风险，同步同步就不会丢消息\",\"Rabbit MQ\",\"普通集群：消息是分散存储的，节点之间不会主动进行消息同步，是有可能丢失消息的\",\"镜像集群：镜像集群会在节点之间主动进行数据同步，这样数据安全性得到提高。\",\"Kafka\",\"通常都是用在允许消息少量丢失的场景，可以通过参数配置：acks：0，1，all\",\"MQ消息存盘不丢失\",\"RocketMQ：同步刷盘、异步刷盘：异步刷盘效率更高，但是有可能丢消息，同步刷盘消息安全性更高，但是效率会降低。\",\"RabbitMQ：将队列配置成持久化队列\",\"消费者消费消息不丢失\",\"RocketMQ:使用默认的方式消费就行，不要采用异步方式\",\"RabbitMQ：autoCommit\",\"Kafka：手动提交offset\"]},\"1329\":{\"h\":\"如何保证消费幂等性?\",\"t\":[\"其实就是要防止消费者重复消费的问题。\",\"所有MQ产品都没有提供主动解决幂等性的机制，需要由消费者自行控制。\",\"RocketMQ：给每个消息分配了MessagesID，这个MessagesID可以作为消费者判断幂等的依据，这种方式不太建议。\",\"最好的方式就是自己带一个有业务标识的id，来进行幂等判断，例如在订单中OrderID\",\"还可以统一ID分配。\"]},\"1330\":{\"h\":\"MQ如何保证消息顺序?\",\"t\":[\"消息的顺序分为全局有序和局部有序，通常来说，MQ只需要保证局部有序，不需要保证全局有序。\",\"Java当中对零拷贝进行了封装，Mmap方式通过MappedByteBuffer对象进行操作，而transfer通过FileChannel来进行操作。\",\"Mmap适合比较小的文件，通常文件大小不要超过1.5G-2G，transfile没有文件大小限制。\",\"RocketMQ当中使用Mmap方式对它的文件进行读写。\",\"在Kafka当中，它的index日志文件也是通过Mmap的方式来读写的。在其他的日志文件当中，并没有使用零拷贝的方式，Kafka使用transfile方式将硬盘数据加载到网卡。\"]},\"1331\":{\"h\":\"如何保证消息的高效读写?\",\"t\":[\"零拷贝：Kafka和RocketMQ都是通过零拷贝技术来优化文件读写。\",\"传统文件复制方式：需要对文件在内存中进行四次拷贝。\",\"零拷贝：有两种方式：mmap和 transfile\",\"Java当中对零拷贝进行了封装，Mmap方式通过MappedByteBuffer对象进行操作，而transfer通过FileChannel来进行操作。\",\"Mmap适合比较小的文件，通常文件大小不要超过1.5G-2G，transfile没有文件大小限制。\",\"RocketMQ当中使用Mmap方式对它的文件进行读写。\",\"在Kafka当中，它的index日志文件也是通过Mmap的方式来读写的。在其他的日志文件当中，并没有使用零拷贝的方式，Kafka使用transfile方式将硬盘数据加载到网卡。\"]},\"1332\":{\"h\":\"MQ 中消费时，业务逻辑出现异常怎么办？\",\"t\":[\"RabbitMQ消息消费失败后的处理方案\"]},\"1333\":{\"h\":\"使用MQ如何保证分布式事务的最终一致性？\",\"t\":[\"分布式事务指的是业务相关的多个操作，保证他们同时成功或者同时失败。最终一致性指的是保证事务在最后阶段，能够达到一致性即可，与之对应的就是强一致性。\",\"MQ中要保护事务的最终一致性，就需要做到两点：\",\"生产者要保证100%的消息投递（使用事务消息机制）\",\"消费者这一段需要保证幂等消费（唯一ID + 业务自己实现幂等）\",\"分布式MQ的三种语义：at least once、at most once、exactly once\",\"Rocket MQ并不能保证exactly once，商业版本中提供了exactly once的实现机制。\",\"Kafka：在最新版本的饿源码当中，提供了exactly once的demo。\",\"RabbitMQ：使用erlang语言天生就成为了一种屏障\"]},\"1334\":{\"h\":\"Kafka如何避免重复消费？\",\"t\":[\"详细参见：一文理解Kafka重复消费的原因和解决方案\"]},\"1335\":{\"h\":\"\"},\"1336\":{\"h\":\"Java语言\"},\"1337\":{\"h\":\"JVM、JDK 和 JRE 联系与区别？\",\"t\":[\"JVM（Java虚拟机）是运行Java字节码的虚拟机，JVM针对于不同的操作系统有不同的实现（Windows,Linux,Mac os），在不同的操作系统上使用相同的字节码文件可以得到相同的结果。\",\"Java程序从源代码到运行一般经历下面3个步骤：\",\"JDK（Java Development Kit）是功能齐全的Java SDK，它不止有JRE，还有编译器（Javac）和工具（例如Java doc 和Jdb），它可以创建和编译程序。\",\"JRE是Java运行时环境，它是运行已经编译的Java程序所需的内容的集合，包括Java虚拟机、Java类库、Java命令和其他的一些基础构件，但是，它不能用来创建新的程序。\"]},\"1338\":{\"h\":\"构造器 Constructor 是否可被 override?\",\"t\":[\"构造器无法被重写，但可以重载。\"]},\"1339\":{\"h\":\"重载和重写的区别？\",\"t\":[\"重载发生在同一个类中，方法名必须相同，参数类型、个数、顺序不同，方法返回值和修饰值可以不同。\"]},\"1340\":{\"h\":\"面向对象编程三⼤特性: 封装 继承 多态\",\"t\":[\"封装\",\"封装是把一个对象的属性私有化，根据需要提供一些可以被外界访问属性的方法\",\"继承\",\"继承是使用已经存在的类的定义作为基础建立新的类，新类的定义可以增加新的数据或功能，也可以使用父类的功能，子类拥有父类所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，子类可以拥有自己的属性和方法，即子类可以对父类进行扩展，子类也可以重写父类的方法。\",\"多态\",\"多态是值程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须是在程序运行期间才能决定。\"]},\"1341\":{\"h\":\"String StringBuffer 和 StringBuilder 的区别是什么?\",\"t\":[\"String：不可变字符序列\",\"StringBuffer：可变字符序列，效率低，线程安全\",\"StringBuilder：可变字符序列，效率高，线程不安全\"]},\"1342\":{\"h\":\"String类为什么是不可变的?\",\"t\":[\"在Java中，String被设计成一个不可变的类，也就是常量对象，理由如下：\",\"String常量池需要\",\"JVM为了提升性能和减少内存开销，设计了字符串常量池，字符串不可变的特性就是其设计基础。\",\"缓存Hashcode\",\"可以将Hash值存储起来，不用每次都计算，会给String作为key的数据结构，例如HashMap、HashTable等带来性能提升。\",\"安全\",\"可以防止通过反射机制等有意或者恶意修改，从而预防安全问题。\",\"线程安全\",\"不可变的对象意味着天生就是线程安全的，可以被多个线程共享。\",\"缺点：对于字符串拼接操作会带来极大的性能消耗，这种情况可以使用StringBuffer、StringBuilder来替代String。\"]},\"1343\":{\"h\":\"Integer的缓存机制？\",\"t\":[\"Integer 是对小数据（-128到127）是有缓存的，在JVM初始化的时候，数据-128到127之间的数字便被缓存到了本地内存中，如果初始化-128到127之间的数字，会直接从内存中取出，不需要新建一个对象。\"]},\"1344\":{\"h\":\"深拷贝和浅拷贝的区别？\",\"t\":[\"浅拷贝：对于基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝；\",\"深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。\"]},\"1345\":{\"h\":\"接口和抽象类的区别\",\"t\":[\"接口的方法默认都是public，所有的方法在接口中不能有实现；\",\"接口中除了static、final变量，不能有其他变量，而抽象类中则不一定；\",\"一个类可以实现多个接口，但只能实现一个抽象类。但接口本身可以多继承。\",\"接口方法的默认修饰符是public，抽象类的方法的修复可以是public、protected和default这些修饰符（不能是private）；\",\"从设计的层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。\",\"以上对JDK8之前的定义和规范，从JDK8开始接口的概念有了一些变化，在JDK7或更早的版本中，接口里面只能由常量、变量和抽象方法，实现接口类必须重写接口中的抽象方法，JDK8接口中增加了默认方法和静态方法，JDK9接口中增加了私有方法和私有静态方法。\"]},\"1346\":{\"h\":\"构造方法有哪些特性？\",\"t\":[\"名称与类名相同\",\"没有返回值，但不能用void声明构造方法\",\"生成类的对象时自动执行，无需调用\",\"默认有一个不带参数的构造方法\",\"如果显式的指定了带参的构造方法，默认不再提供无参的构造方法\",\"总的来说构造方法与普通方法的区别如下：\",\"Java构造函数\",\"Java方法\",\"构造器用于初始化对象的状态（状态）\",\"方法用于暴露对象的行为\",\"构造函数不能有返回类型\",\"方法一般都有返回类型\",\"构造函数隐式调用\",\"方法要显式的调用\",\"如果没有指定任何构造函数，java编译器提供一个默认的构造函数\",\"在任何情况下编译器都不会提供默认的方法调用\",\"构造函数名称必须与类名称相同\",\"方法名称可以或可以不与类名称相同\"]},\"1347\":{\"h\":\"String中hashCode的实现？\",\"t\":[\" public int hashCode() { int h = hash; if (h == 0 && value.length > 0) { char val[] = value; for (int i = 0; i < value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } \"]},\"1348\":{\"h\":\"hashCode和equals的作用？\",\"t\":[\"两个相同对象\"]},\"1349\":{\"h\":\"JDK8有哪些新特性？\",\"t\":[\"Lambda表达式\",\"函数式接口\",\"方法引用\",\"Stream API\",\"接口中的默认方法和静态\",\"新的时间和日期API\",\"Optional\"]},\"1350\":{\"h\":\"Java反射有哪些作用？\",\"t\":[\"Java的反射机制主要用于实现以下功能：\",\"在运行时判断任意一个对象所属的类型\",\"在运行时构造任意一个类的对象\",\"在运行判断任意一个类所具有的成员变量和方法\",\"在运行时调用任意一个对象的方法，包括private方法\"]},\"1351\":{\"h\":\"如何使用反射获取私有属性？\",\"t\":[\"// 1.获取私有属性 Field[] fields = clz.getDeclaredFields(); // 2.获取私有构造方法 Constructor cons = clazz.getDeclaredConstructor(null); // 必须要设置之后才可以访问 cons.setAccessible(true); cons.newInstance(null); \"]},\"1352\":{\"h\":\"创建对象有哪些方式？\",\"t\":[\"共有五种方式：\",\"new关键字\",\"反射API\",\"Constructor.newInstance\",\"Clone()方法\",\"反序列化\"]},\"1353\":{\"h\":\"迭代器和for循环遍历的区别？\",\"t\":[\"迭代器是一种设计模式，可以使得序列类型的数据结构的遍历行为与被遍历的对象分离，即我们无需关心该序列的底层结构是什么样子的。只要拿到这个对象，使用迭代器可以遍历这个对象的内部。\",\"迭代器实现了Iterabale接口的集合都可以使用迭代器来遍历。使用迭代器遍历元素时，除了查看之外，只能做remove操作。\",\"增强for循环，内部使用的是迭代器，所以它的操作对象是数组和可以迭代器的结合。遍历时只能查看，无法修改、删除、增加。\",\"迭代出来的元素都是原来集合元素的拷贝，Java集合元素实质是对象的引用，而非对象本身，迭代出的对象也是引用的拷贝，结果还是引用。那么如果集合中保存的元素是可变类型的，那么可以通过迭代出的元素修改原集合中的对象\",\"总的来说，两者的区别主要在于遍历和集合本身是否分离，从数据结构的角度分析，如果使用Iterator来遍历集合的元素，并不需要考虑集合类的内部实现（只要），而如果使用for循环进行遍历，那么遍历此集合的算法都得做相应的调整。\"]},\"1354\":{\"h\":\"过滤器和拦截器的区别？\",\"t\":[\"过滤器指的是，在java web中，传入的request、response提前过滤一些信息，或者提前设置一些参数，然后传入servlet或者struts的action进行业务逻辑，比如过滤掉非法url。\",\"拦截器指的是，是在面向切面编程的时候，使用动态代理拦截方法等。\"]},\"1355\":{\"h\":\"List、Set、Map三者的区别？\",\"t\":[\"List用来存储一组不唯一（可以重复），有序的对象；\",\"Set用来存储不允许重复的集合，不会有多个元素引用相同集合的对象；\",\"Map是用来存储键值对的，Map会维护与Key有关联的值，两个不同的Key可以引用相同的对象，Key不能重复。\"]},\"1356\":{\"h\":\"HashMap实现原理？\",\"t\":[\"Java 8系列之重新认识HashMap - 美团技术团队 (meituan.com)\"]},\"1357\":{\"h\":\"HashMap为什么扩容为2倍？\",\"t\":[\"HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，使用的算法是：hash & (length - 1)，实际上hash & (length - 1) = hash % length，主要考虑到模运算的速度比位运算的的快。\"]},\"1358\":{\"h\":\"为什么HashMap不用LinkedList，而是选用数组？\",\"t\":[\"在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到，此时已知桶的位置，使用数组查询的效率会LinkedList大；不使用ArrayList的原因是，ArrayList的扩容机制是1.5倍扩容，无法自定义扩容机制。\"]},\"1359\":{\"h\":\"JDK1.8对HashMap有哪些优化？\",\"t\":[\"由数组 + 链表的结构改为了数组 + 链表 + 红黑树\",\"优化了高位运算的hash算法：h^(h >>> 16)\",\"扩容后，元素要么是在原来的位置，要么是在原位置再移动2次幂的位置，且链表顺序不变\"]},\"1360\":{\"h\":\"为什么不直接使用红黑树，而是选择先用链表，再转红黑树？\",\"t\":[\"因为红黑树需要进行左旋、右旋、变色这些操作来保持平衡，而单链表不需要，当元素小于8个的时候，此时做查询操作，链表结构已经能保证查询性能，当元素大于8个的时候，此时需要红黑树来加速查询速度，但是新增节点的效率变慢了，因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。\"]},\"1361\":{\"h\":\"HashMap不使用红黑树，而是使用二叉查找树可以吗？\",\"t\":[\"可以，但是二叉查找树在特殊情况下会变成一条线性结构，此时遍历查找会非常慢。\"]},\"1362\":{\"h\":\"为什么阈值是8？\",\"t\":[\"hashcode碰撞次数与泊松分布有关，选择8是根据概率统计而选择的。泊松分布的示意图：\"]},\"1363\":{\"h\":\"当链表转为红黑树，什么时候退化为链表？\",\"t\":[\"等于6的时候退转为链表。中间有差值7可以防止链表和树之间频繁的转换。假设这个互相转换的界限都是8，那么如果一个HashMap不停的插入、删除元素，链表个数会在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。\"]},\"1364\":{\"h\":\"HashMap在并发编程环境下有什么问题？\",\"t\":[\"多线程扩容，引起的死循环问题\",\"多线程put的时候可能导致元素丢失\",\"put非null元素后get出来的却是null\"]},\"1365\":{\"h\":\"使用可变类当HashMap的key有什么问题？\",\"t\":[\"hashCode可能发生改变，导致put进去的值，无法get出，如下所示：\",\"public class HashMapDemo { public static void main(String[] args) { HashMap<List<String>, Object> changeMap = new HashMap<>(); List<String> list = new ArrayList<>(); list.add(\\\"hello\\\"); Object objectValue = new Object(); changeMap.put(list, objectValue); System.out.println(changeMap.get(list)); //hashcode发生了改变 list.add(\\\"hello world\\\"); System.out.println(changeMap.get(list)); } } \"]},\"1366\":{\"h\":\"如何实现一个自定义的Class作为HashMap的key？\",\"t\":[\"重写hashcode和equals\",\"如何设计一个不可变类\"]},\"1367\":{\"h\":\"两个相同对象没有重写equals方法放到HashMap覆盖吗?\",\"t\":[\"不会覆盖，HashMap使用对象的hashCode方法确定对象在哈希表中的存储位置，并使用equals方法来比较key是否相等，如果对象不重写equals方法，将对象放到HashMap的时候就会调用Object的equals方法，比较地址，这时候就会认为是两个不同的对象，所以不会覆盖。\"]},\"1368\":{\"h\":\"HashSet实现原理？\",\"t\":[\"底层使用HashMap实现：\",\"// hashMap的value是Object类型 private transient HashMap<E,Object> map; private static final Object PRESENT = new Object(); // HashSet添加元素的方法 public boolean add(E e) { return map.put(e, PRESENT)==null; } // HashSet删除元素的方法 public boolean remove(Object o) { return map.remove(o)==PRESENT; } \"]},\"1369\":{\"h\":\"CurrentHashMap的实现原理？\",\"t\":[\"JDK1.7分段锁的设计，JDK1.8：Node + CAS + Synchronized\"]},\"1370\":{\"h\":\"ArrayList的实现原理？\",\"t\":[\"ArrayList底层使用一个支持自动扩容的数组来保存所有元素。ArrayList并不是线程安全的，只能在单线程环境下使用，多线程环境下可以使用java.util.Collections.SynchronizedList或java.util.concurrent.CopyOnWriteArrayList来代替。\"]},\"1371\":{\"h\":\"\"},\"1372\":{\"h\":\"Java并发\"},\"1373\":{\"h\":\"并发编程的三要素？\",\"t\":[\"线程安全性的问题主要体现在：\",\"原子性\",\"有序性\",\"可见性\",\"出现线程安全问题的原因：\",\"线程切换带来的原子性问题\",\"缓存导致的可见性问题\",\"编译优化带来的有序性问题\",\"解决办法：\",\"JDK Atomic开头的原子类、synchronized、Lock可以解决原子性的问题\",\"synchronized、volatile、Lock可以解决可见性的问题\",\"Happers-before规则可以解决有序性的问题\"]},\"1374\":{\"h\":\"线程和进程的区别？\",\"t\":[\"进程是程序运行时的状态，是操作系统分配资源的最小单元，进程的主要作用是管理资源。线程是操作系统调度的最小的单元，一个程序至少有一个进程，一个进程至少有一个线程，线程是进程当中的一条执行流程。\"]},\"1375\":{\"h\":\"守护线程和用户线程的区别？\",\"t\":[\"Java中的线程分为两种：守护线程（Daemon）和用户线程（User），其中用户线程又称本地线程。守护线程可以理解为JVM自动创建的线程（通常），用户线程是程序创建的线程。一般情况下，两者的区别在于，当JVM中所有的线程都是守护线程的时候，JVM就可以退出，如果还有一个或以上的非守护线程则不会退出。\",\"可以通过 java.lang.Thread#setDaemon 方法设置线程为守护线程或者用户线程。\"]},\"1376\":{\"h\":\"什么是线程安全？\",\"t\":[\"指某个函数、函数库在多线程的环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。\"]},\"1377\":{\"h\":\"Java如何开启线程？怎么保证线程安全？\",\"t\":[\"这里首先得明确一下线程和进程的区别，进程是操作系统进行资源分配的最小单位，线程是操作系统任务分配的最小单位，线程隶属于进程。\",\"开启线程的具体方式：\",\"继承Thread类，重写run方法\",\"实现Runnable接口，实现run方法\",\"实现Callable接口，实现call方法，通过FutureTask创建一个线程，获取到线程执行的返回值\",\"通过线程池来开启线程\",\"那么如何保证线程安全呢？\",\"采用加锁的方式：使用JVM提供的Synchronized关键字或者JDK提供的各种锁Lock。\"]},\"1378\":{\"h\":\"线程有哪些状态？\",\"t\":[\"如图：\"]},\"1379\":{\"h\":\"如何停止一个正在运行的线程？\",\"t\":[\"在java中有以下3种方法可以终止正在运行的线程：\",\"使用退出标志，使线程正常退出，也就是当run方法完成后线程终止\",\"使用stop方法强行终止，但是这个方法并不安全\",\"使用interrupt方法中断线程\"]},\"1380\":{\"h\":\"notify和notifyAll有什么区别？\",\"t\":[\"notify会随机唤醒一个阻塞的线程，而notifyAll会唤醒所有线程。\"]},\"1381\":{\"h\":\"wait和sleep方法有什么区别？\",\"t\":[\"调用wait方法之前，线程必须持有对象的锁，在调用wait方法之后，线程就会释放锁，而sleep方法则不会释放掉锁。\"]},\"1382\":{\"h\":\"为什么wait和notify方法要在同步块中调用？\",\"t\":[\"使用wait和notify方法首先要必须要获取到当前对象的锁，如果没有获取到锁会抛出异常，因此需要在同步块中调用。\"]},\"1383\":{\"h\":\"Thread类中的yield方法有什么作用？\",\"t\":[\"当一个线程调用yield方法时，当前线程会让出CPU使用权，然后处于就绪状态，线程调度器会从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到刚刚让出CPU的那个线程来获取CPU执行权。\"]},\"1384\":{\"h\":\"volatile和synchronized有什么区别？\",\"t\":[\"synchronized关键是用来加锁，volatile只是保持变量的线程可见性，通常适用于一个线程写，多个线程读的场景。\"]},\"1385\":{\"h\":\"volatile变量和atomic变量什么不同？\",\"t\":[\"volatile变量可以确保写操作发生在后续的读操作之前，但它并不能保证原子性，例如，即便是使用volatile修饰，count++的操作也不是原子性的，而atomic变量可以让这种操作具有原子性。\"]},\"1386\":{\"h\":\"interrupted和isInterrupted方法的区别？\",\"t\":[\"interrupted与isInterrupted方法不同是，interrupted方法会清除中断标志，而isInterrupted方法则不会，并且interrupted方法是static方法，可以通过Thread类直接调用。\"]},\"1387\":{\"h\":\"volatile能不能保证线程安全？\",\"t\":[\"不能。volatile关键字只能保证线程可见性，不能保证原子性，相关的示例：\",\"public class VolatileDemo { private static volatile boolean flag = true; // private static boolean flag = true; public static void main(String[] args) { new Thread(() -> { while (flag) { // .. } System.out.println(\\\"=============\\\"); }).start(); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } flag = false; } } \"]},\"1388\":{\"h\":\"DCL单例为什么加volatile？\",\"t\":[\"volatile防止指令重排，在DCL中，防止高并发情况，指令重排造成的线程安全问题，相关示例代码：\",\"public class SingleDemo { private volatile SingleDemo singleDemo; private SingleDemo() {} public SingleDemo getInstance() { if (null == this.singleDemo) { synchronized (SingleDemo.class) { if (null == this.singleDemo) { singleDemo = new SingleDemo(); } } singleDemo = new SingleDemo(); return singleDemo; } } \"]},\"1389\":{\"h\":\"死锁与活锁的区别？\",\"t\":[\"死锁：线程1等待线程2互斥持有的资源，而线程2也在等待线程1互斥持有的资源，两个线程都无法继续执行。\",\"活锁：线程持续重试一个总是失败的操作，导致无法继续执行；\"]},\"1390\":{\"h\":\"死锁与饥饿的区别？\",\"t\":[\"饥饿：线程一直被调度器延迟访问其赖以执行的资源，也许是调度器先于低优先级的线程而执行高优先级的线程，同时总是会有一个高优先级的线程可以执行，饿死也叫做无限延迟。\"]},\"1391\":{\"h\":\"按照线程安全的强度来区分，分为哪几类？\",\"t\":[\"分类\",\"特点\",\"不可变\",\"不可变的对象一定是线程安全的，并且永远也不需要额外的同步。Java类库中大多数基本数值类如Integer、String、BigInteger都是不可变的。\",\"绝对线程安全\",\"由类的规格说明所规定的约束在对象被多个线程访问时仍然有效，不管运行时环境如何排列，线程都不需要任何额外的同步。\",\"相对线程安全\",\"相对线程安全类对于单独的操作可以是线程安全的，但是某些操作序列可能需要外部同步。\",\"线程兼容\",\"线程兼容类不是线程安全的，但是可以通过正确使用同步而在并发环境中安全地使用，例如使用sychronized代码块。\",\"线程对立\",\"线程对立是那些不管是否采用了同步措施，都不能在多线程环境中并发使用的代码，这通常是有害的，应当尽量避免。\"]},\"1392\":{\"h\":\"线程安全的实现方法有哪些？\",\"t\":[\"互斥同步\",\"非阻塞同步\",\"无同步方案 \",\"可重入代码\",\"线程本地存储\"]},\"1393\":{\"h\":\"锁优化技术你了解什么？\",\"t\":[\"锁优化技术主要有锁消除与锁粗化两种。\",\"通过逃逸分析技术判别程序中所使用的锁对象是否只被一个线程所使用，而没有散布到其他线程当中，如果情况就是这样的话，那么JIT编译器在编译这个同步代码时就不会生成synchronized关键字所标识的锁的申请与释放机器码，从而消除了锁的使用流程，这就是锁的消除。\",\"JIT编译器在执行动态编译时，若发现前后相邻的synchronized块使用的是同一个锁对象，那么它就会把这几个synchronized块合并为一个较大的同步块，这就是锁的粗化。\"]},\"1394\":{\"h\":\"Lock与synchronized有什么区别？\",\"t\":[\"锁的获取方式：Lock是通过程序代码的方式由开发者手工获取，而synchronized是通过JVM来获取的（无需开发者干预）。\",\"具体的实现方式：Lock是通过Java代码的方式来实现，synchronized是通过JVM底层来实现（无需开发者关注）。\",\"锁的释放方式：Lock务必通过unlock()方法在finally块中手工释放，synchronized是通过JVM来释放（无需开发者关注）。\",\"锁的具体类型：Lock提供了多种，如公平锁、非公平锁，synchronized与Lock都提供了可重入锁。\"]},\"1395\":{\"h\":\"什么是阻塞队列？阻塞队列的实现原理是什么？\",\"t\":[\"阻塞队列是一个支持两个附加操作的队列。这两个附加的操作是：\",\"当队列为空时，获取元素的线程会等待队列变为非空\",\"当队列满时，存储的线程会等待队列可用\",\"阻塞队列一览：\",\"类型\",\"特点\",\"ArrayBlockingQueue\",\"一个由数组结构组成的有界阻塞队列\",\"LinkedBlockingQueue\",\"一个由链表结构组成的有界阻塞队列\",\"PriorityBlockingQueue\",\"一个支持优先级排序的无界阻塞队列\",\"DelayQueue\",\"一个使用优先级队列实现的无界阻塞队列\",\"SynchronousQueue\",\"一个不存储元素的阻塞队列\",\"LinkedTransferQueue\",\"一个由链表结构组成的无界阻塞队列\",\"LinkedBlockingDeque\",\"一个由链表结构组成的双向阻塞队列\"]},\"1396\":{\"h\":\"什么是Callable和Future？\",\"t\":[\"Future接口标识异步任务，是还没有完成的任务给出的未来结果，Callable用于产生结果，Future用来获取结果。\"]},\"1397\":{\"h\":\"Java线程锁机制是怎样的？偏向锁、轻量级锁、重量级锁有什么区别？锁机制是如何升级的？\",\"t\":[\"Java的锁就是在对象的MarkWord中记录一个锁状态、无锁、偏向锁、轻量级锁、重量级锁对应不同锁状态，Java的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程。\",\"偏向锁、轻量级锁、重量级锁及锁机制具体如下图：\"]},\"1398\":{\"h\":\"什么是可重入锁？有哪些实现？\",\"t\":[\"相同的线程可以直接进入已经获取锁的同步代码块，而无需重复获取锁。代表实现：synchronized、ReentrantLock。\"]},\"1399\":{\"h\":\"什么是悲观锁？什么是乐观锁？\",\"t\":[\"悲观锁：总是假设最坏的情况，每次获取数据都认为其它线程会修改，所以都会加锁（读锁、写锁、行锁等），当其它线程想要访问数据时，都需要阻塞挂起，例如synchronized。\",\"乐观锁：总是认为不会产生并发问题，每次获取数据的时候总认为不会有其它线程对数据进行修改，因此不会上锁，但是在更新是会判断其它线程在这之前有没有对数据进行修改，一般使用版本号机制或CAS操作实现。\"]},\"1400\":{\"h\":\"谈谈你对AQS的理解，AQS如何实现可重入锁？\",\"t\":[\"队列同步器AQS，是Lock实现的模板类。它使用一个int类型的成员变量表示同步状态，通过内置的双向链表来完成资源获取的线程的排队工作。AQS使用模板方法的设计模式，使用者需要继承AQS并重写指定的方法（通常是获取锁和释放锁的方法）。随后AQS会调用重写的模板方法，完成对数据的加锁/解锁操作。\"]},\"1401\":{\"h\":\"SynchronizedMap和ConcurrentHashMap有什么区别？\",\"t\":[\"SynchronizedMap依次锁住整张表来保证线程安全，所以每次只能有一个线程来访问map，而ConcurrentHashMap使用分段锁来保证在多线程下的性能（JDK1.7）。\"]},\"1402\":{\"h\":\"ConcurrentHashMap的并发度是什么？\",\"t\":[\"默认值是16，这样能在多线程情况下避免争用。\"]},\"1403\":{\"h\":\"CopyOnWriteArrayList可以用于什么应用场景？\",\"t\":[\"读多写少，并且写入慢也没有关系的场景。本质上是使用ReentrantLock完成并发操作。\"]},\"1404\":{\"h\":\"有A、B、C三个线程，如何保证三个线程同时执行？如何在并发情况下保证三个线程依次执行？如何保证三个线程有序交错进行？\",\"t\":[\"可以使用三大工具：CountDownLatch，CylicBarrier，Semaphore\",\"保证三个线程同时执行的示例：\",\"public class ThreadSafeDemo { private int count = 0; private void add() { count ++; } public static void main(String[] args) throws InterruptedException { int size = 3; ThreadSafeDemo threadSafeDemo = new ThreadSafeDemo(); CountDownLatch countDownLatch = new CountDownLatch(1); for (int i = 0; i < size; i++) { new Thread(() -> { try { countDownLatch.await(); System.out.println(System.currentTimeMillis()); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } System.out.println(\\\"wait\\\"); Thread.sleep(5000); countDownLatch.countDown(); } \",\"保证三个线程依次执行的示例\",\"public class OrderThread2 { static volatile int ticket = 1; public static void main(String[] args) { Thread t1 = new Thread(() -> { while (true) { if (ticket == 1) { try { Thread.sleep(100); for (int i = 0; i < 10; i++) { System.out.println(\\\"a\\\" + i); } } catch (InterruptedException e) { e.printStackTrace(); } ticket = 2; return; } } }); Thread t2 = new Thread(() -> { while (true) { if (ticket == 2) { try { Thread.sleep(100); for (int i = 0; i < 10; i++) { System.out.println(\\\"b\\\" + i); } } catch (InterruptedException e) { e.printStackTrace(); } ticket = 3; return; } } }); Thread t3 = new Thread(() -> { while (true) { if (ticket == 3) { try { Thread.sleep(100); for (int i = 0; i < 10; i++) { System.out.println(\\\"c\\\" + i); } } catch (InterruptedException e) { e.printStackTrace(); } return; } } }); t1.start(); t2.start(); t3.start(); } } \",\"保证三个线程有序交错进行的示例：\",\"public class OrderThread { // 利用信号量来限制 private static Semaphore s1 = new Semaphore(1); private static Semaphore s2 = new Semaphore(1); private static Semaphore s3 = new Semaphore(1); public static void main(String[] args) { try { s1.acquire(); s2.acquire(); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -> { while (true) { try { s1.acquire(); } catch (InterruptedException e) { e.printStackTrace(); } try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"A\\\"); s2.release(); } }).start(); new Thread(() -> { while (true) { try { s2.acquire(); } catch (InterruptedException e) { e.printStackTrace(); } try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"B\\\"); s3.release(); } }).start(); new Thread(() -> { while (true) { try { s3.acquire(); } catch (InterruptedException e) { e.printStackTrace(); } try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"C\\\"); s1.release(); } }).start(); } } \"]},\"1405\":{\"h\":\"什么是指令重排序？\",\"t\":[\"为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入的代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，并确保这一结果和顺序执行的结果是一直的，但是这个过程并不保证各个语句计算的先后顺序和输入代码中的顺序一致，简单来说，就是指程序中写的代码，在执行时并不一定按照写的顺序就叫做指令重排序。\",\"Java中的指令重排序有两次，第一次发生在将字节码编译成机器码的阶段，第二次发生在CPU执行的时候，也会适当对指令进行重排。\"]},\"1406\":{\"h\":\"ThreadLocal的作用？导致内存泄漏的原因是什么？\",\"t\":[\"ThreadLocal可以为每一个线程拷贝变量的副本，让变量“私有化”，导致内存泄漏的主要原因是在内部维护的Map结构，当key被GC之后，value还存在，无法自动进行GC，就会导致内存泄漏。\"]},\"1407\":{\"h\":\"使用线程池有什么好处？\",\"t\":[\"降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗\",\"提高响应速度：当任务到达时，可以不需要等待线程创建就能立即执行\",\"提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行同一的分配，监控和调优\"]},\"1408\":{\"h\":\"线程池中submit()和execute()方法有什么区别？\",\"t\":[\"execute和submit都属于线程池的方法，两者的区别在于：\",\"execute只能提交Runnable类型的任务，而submit既能提交Runnable类型的任务也能提交Callable类型任务\",\"execute会直接抛出任务运行时的异常，submit会吃掉异常，可通过Future的get方法将任务执行时的异常重新抛出\",\"execute所属顶层接口时Executor，submit所属顶层接口是ExecutorService，实现类ThreadPoolExecutor重写了execute方法，抽象类AbstractExecutorService重写了submit方法\"]},\"1409\":{\"h\":\"什么是Executors框架？\",\"t\":[\"Executor工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。\"]},\"1410\":{\"h\":\"线程池的拒绝策略？\",\"t\":[\"当提交的线程填满核心线程数，并且塞满了队列缓冲区，并且超过了最大线程数时，就会触发拒绝策略，具体有以下几种：\",\"拒绝策略\",\"含义\",\"AbortPolicy\",\"当任务添加到线程池中被拒绝时，它将抛出RejectedExecutionException异常\",\"CallerRunsPolicy\",\"当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务\",\"DiscardOldestPolicy\",\"当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中\",\"DiscardPolicy\",\"当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务\",\"什么时候触发拒绝策略，是三个参数总体协调的结果，当提交的任务大于corePoolSize时，会优化放到队列缓冲区，值由填满了缓冲区之后，才会判断当前任务是否大于maxPoolSize，小于的时候会创建新的线程进行处理，大于时就触发了拒绝策略。简单来说，当前提交任务数大于(maxPoolSize + queueCapacity)时就会触发线程的拒绝策略。\"]},\"1411\":{\"h\":\"如何获取子线程的执行结果？\",\"t\":[\"使用join方法变量传递\",\"FutureTask\"]},\"1412\":{\"h\":\"如何对一个字符串快速进行排序？\",\"t\":[\"可以使用Fork/Join框架来完成，相关代码示例：\",\"class Fibonacci extends RecursiveTask<Integer> { final int n; Fibonacci(int n) { this.n = n; } Integer compute() { if (n <= 1) return n; Fibonacci f1 = new Fibonacci(n - 1); f1.fork(); Fibonacci f2 = new Fibonacci(n - 2); return f2.compute() + f1.join(); } } \"]},\"1413\":{\"h\":\"线程池的参数如何设置？\",\"t\":[\"详细参见：Java线程池实现原理及其在美团业务中的实践。\"]},\"1414\":{\"h\":\"子线程中如何获取父线程的 中的值、 的数据结构？\"},\"1415\":{\"h\":\"高并发下，如何保证接口的幂等性？\",\"t\":[\"高并发下如何保证接口的幂等性？\"]},\"1416\":{\"h\":\"除了Lock和synchronized，还有什么方式可以保障线程安全？\",\"t\":[\"使用Atomic原子类，它通过CAS操作，保障线程安全\",\"使用线程安全的集合类，例如ConcurrentHashMap、CopyOnWriteArrayList\",\"使用volatile，如果是共享变量引起的线程安全问题，volatile可以共享保障变量的可见性\",\"使用ThreadLocal，使得每个线程都可以独立地访问和修改自己的变量副本\",\"使用不可变的变量，例如String，使用final关键字修饰的变量等\"]},\"1417\":{\"h\":\"\"},\"1418\":{\"h\":\"Java网络通信\"},\"1419\":{\"h\":\"TCP和UDP有什么区别？\",\"t\":[\"TCP（Transfer Control Protocol）是一种面向连接的、可靠的、传输层通讯协议。\",\"TCP的特点：类似打电话，面向连接的、点对点的通信、高可靠的，效率比较低，占用的系统资源比较多。\",\"UDP（User Datagram Protocol）是一种无连接的、不可靠的、传输层的通讯协议。\",\"UDP的特点：类似广播，不需要连接，发送方不管接受方有没有准备好，直接发消息，可以进行广播发送的，传输不可靠，有可能丢失消息，效率比较高，协议比较简单，占用的系统资源比较少。\"]},\"1420\":{\"h\":\"TCP为什么是三次握手，而不是两次？\",\"t\":[\"TCP建立连接三次握手，断开连接四次挥手。 如果是两次握手，可能会造成连接资源浪费的情况，server端会建立通道一直等待连接，但是client端会认为连接失败，放弃本次通信。\"]},\"1421\":{\"h\":\"Java有哪几种IO模型？有什么区别？\",\"t\":[\"有BIO 同步阻塞IO、NIO 同步非阻塞IO、AIO异步非阻塞IO模型。\",\"这里的同步、异步针对请求，阻塞和非阻塞针对客户端。\",\"在一个网络请求中，客户端会发一个请求到服务端：\",\"客户端发了请求后，就一直等着服务端响应，客户端：阻塞。请求：同步\",\"客户端发了请求后，就去干别的事情了，是不是的过来检查服务端是否给出了响应，客户端：非阻塞，请求：同步\",\"换成异步请求，客户端发了请求后，就坐在椅子上，等着服务端返回响应。客户端：阻塞，请求：异步。\",\"客户端发了请求后，就去干别的事情了，等到服务端给出响应后，再来处理业务逻辑。客户端：非阻塞。请求：异步\",\"具体区别如下：\",\"BIO模式：可靠性差，吞吐量低，适用于连接比较少且比较固定的场景，JDK1.4之前唯一的选择。编程模型最简单。\",\"NIO模型：可靠性比较好，吞吐量比较高，适用于连接多，并且连接比较短（轻操作），例如聊天室，JDK1.4开始支持，编程模型最复杂。\",\"AIO模型：可靠性是最好的，吞吐量也是最高的，适用于连接比较多，并且连接比较长（重操作），例如相册服务器，JDK7开始支持的，编程模型相对简单，但是需要操作系统支持。\"]},\"1422\":{\"h\":\"Java NIO的几个核心组件是什么？分别有什么作用？\",\"t\":[\"Java NIO的几个核心组件有：Channel、Buffer、Selector，它们之间的关系如下：\",\"Channel类似于流，每个Channel对应一个Buffer缓冲区，Channel会注册到Selector，Selector会根据Channel上发生的读写时间，将请求交由某个空闲的线程处理，Selector对应一个或者多个线程。Buffer和Channel都是可读可写的。\"]},\"1423\":{\"h\":\"select、poll、epoll有什么区别？\",\"t\":[\"他们是NIO中多路复用的三种实现机制，是由linux操作系统提供的。\",\"用户空间和内核空间：操作系统为了保护系统安全，将内核划分为两个部分，一个是用户空间，一个是内核空间。用户空间不能直接访问底层的硬件设备，必须通过内核空间。\",\"文件描述符 File Descriptor（FD）：是一个抽象的概念，形式上是一个整数，实际上是一个索引值。指向内核中为每个进程维护进程所打开的文件的记录表。当程序打开一个文件或者创建一个文件时，内核就会向进程返回一个FD，Unix、Linux。\",\"select机制：会维护一个FD的结合fd_set。将fd_set从用户空间复制到内核空间，激活socket。\",\"poll机制：和select机制差不多的。把fd_set结构进行了优化，FD集合的大小就突破了操作系统的限制，poll fd结构来代替fd_set，通过链表实现\",\"epoll(Event poll)：epoll中不再扫描所有的FD，而是只将用户关心的FD的事件存放到内核的一个事件表当中。这样就可以减少用户空间与内核空间之前需要拷贝的数据。\",\"总结如下表：\",\"操作方式\",\"底层实现\",\"最大连接数\",\"IO效率\",\"select\",\"遍历\",\"数组\",\"受限于内核\",\"一般\",\"poll\",\"遍历\",\"链表\",\"无上限\",\"一般\",\"epoll\",\"事件回调\",\"红黑树\",\"无上限\",\"高\",\"那Java的NIO当中时使用的哪种机制呢？\",\"这与操作系统有关，在windows下，WindowsSelectorProvider。而linux下，根据linux的内核版本，2.6内核版本以上，就是EpollSelectorProvider，默认使用的是PollSelectorProvider\"]},\"1424\":{\"h\":\"HTTP和HTTPS的区别？\",\"t\":[\"HTTP：是互联网上应用最为广泛的一种网络通信协议，基于TCP协议，可以使用浏览器工作更为高效，减少网络传输。\",\"HTTPS：是HTTP的加强版，可以认为是HTTP + SSL（Secure Socket Layer）。在HTTP的基础上增加了一系列的安全机制，一方面保证数据传输安全，另一方面对访问者增加了验证机制。是目前现行架构下，最为安全的解决方案。\",\"主要区别：\",\"HTTP的连接时简单无状态的，HTTPS的数据传输时经过证书加密的，安全性更高。\",\"HTTP是免费的，而HTTPS需要申请证书，而证书通常是收费的，并且费用一般不低。\",\"他们的传输协议不同，所以他们使用的端口也是不一样的，HTTP默认端口是80，而HTTPS默认是443端口\",\"HTTPS的缺点：\",\"HTTPS的握手协议比较费时，所以会影响服务的响应速度以及吞吐量。\",\"HTTPS也并不是完全安全的，他的证书体系并不是完全安全的。 并且HTTPS在面对DDOS这样的攻击时，几乎起不到任何作用。\",\"证书不免费，并且功能越强大的证书费用越高。\"]},\"1425\":{\"h\":\"三次握手和四次挥手？\",\"t\":[\"所谓三次握手，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包，三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。\",\"在socket编程中，客户端执行connect时，将触发三次握手：\",\"TCP的连接的拆除需要发送四个包，因此称为四次握手，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作：\"]},\"1426\":{\"h\":\"\"},\"1427\":{\"h\":\"Java虚拟机\"},\"1428\":{\"h\":\"运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？\"},\"1429\":{\"h\":\"Java 创建一个对象的过程？\",\"t\":[\"检查类是否已经被加载\",\"为对象分配内存空间\",\"为分配的内存空间初始化零值（为对象字段设置零值）\",\"对对象进行其它设置（设置对象头）\",\"执行构造方法\"]},\"1430\":{\"h\":\"如何访问对象？\",\"t\":[\"使用句柄的方式\",\"使用直接指针的方式\"]},\"1431\":{\"h\":\"Java 内存模型的原子性、可见性和有序性是通过哪些操作实现的？\",\"t\":[\"原子性：synchronized\",\"可见性：volatile\",\"有序性：volatile和synchronized\"]},\"1432\":{\"h\":\"什么是双亲委派机制？有什么作用？\",\"t\":[\"Java的类加载器：AppClassLoader -> ExtClassLoader -> BootStrapClassLoader\",\"每一种类加载器都有自己的加载目录，Java中的AppClassLoader、ExtClassLoader 都继承了URLClassLoader，URLClassLoader继承了SecureClassLoader，SecureClassLoader又继承了ClassLoader，每个类加载器对他加载过的类，都是有一个缓存的：\",\"双亲委派：向上委托查找，向下委托，作用：保护Java的层的类不会被应用程序覆盖\",\"核心代码：\",\"protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class<?> c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } \"]},\"1433\":{\"h\":\"Java类加载的全过程是怎么样的？\",\"t\":[\"类加载过程：加载 -> 连接 -> 初始化 -> 使用 -> 卸载\",\"加载：把Java的字节码数据加载到JVM内存当中，并映射成JVM认可的数据结构\",\"连接：可以分为三个小的阶段： \",\"验证：检查加载到的字节码信息是否符合JVM规范\",\"准备：创建类或接口的静态变量，并赋初始值，半初始化状态\",\"解析：将符号引用转为直接引用\",\"初始化：创建对象\"]},\"1434\":{\"h\":\"你了解分代理论吗？\",\"t\":[\"目前绝大部分的JJVM，在针对对象进行垃圾收集的时候，会将对象熬过垃圾收集的次数，视为对象的年龄，依次将对象至少划分为新生代和老年代。分代收集理论基于以下三种假说和经验法则：\",\"弱分代假说\",\"绝大数对象，在第一次垃圾收集时就会被回收，按照经验法则，这个值高达百分之九十八\",\"强分代假说\",\"熬过越多次收集过程的对象就越难以消亡\",\"跨代引用假说\",\"该假说认为只会存在很少的跨代引用。因为只要经过一些次数的垃圾收集，即使还存在跨代引用，新生代会变成老年代，跨代引用也就自然小时了，所以跨代引用的数量不会多\",\"Java堆分为新生代和老年代，针对收集对象处于哪一代，一共有以下四种收集方式：\",\"部分收集\",\"新生代收集（Minor GC/Young GC），只收集新生代垃圾对象\",\"老年代收集（Major GC/Old GC），只收集老年代垃圾对象，目前只有CMS收集器会单独收集老年代对象\",\"混合收集（Mixed GC），收集来自整个新生代以及部分老年代中的垃圾对象，目前只有G1会有这种行为\",\"整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集\"]},\"1435\":{\"h\":\"JDK 中有几种引用类型？分别的特点是什么？\",\"t\":[\"在JDK1.2之前，一个对象只有“被引用”或者“未被引用”两种状态，但这种描述方式不能满足所有的场景，譬如我们希望描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在垃圾收集器后仍然非常警长，那就可以抛弃这些对象，这个时候就需要对引用的概念进行扩充。\",\"引用类型\",\"定义\",\"特点\",\"强引用（Strong Reference）\",\"通过new关键赋值的引用\",\"只要强引用关系还存在，垃圾收集器永远不会回收掉引用的对象\",\"软引用（Soft Reference）\",\"还有用，但非必须的对象\",\"内存不够时一定会被GC，长期不用也会被GC\",\"弱引用（Weak Reference）\",\"非必须对象\",\"被弱引用关联的对象只能生存到下一次垃圾收集发生为止。无论当前内存是否足够，都会回收\",\"虚引用（Phantom Reference）\",\"“幽灵引用”或者“幻影引用”\",\"对象被垃圾收集器回收时收到一个系统通知\"]},\"1436\":{\"h\":\"一个对象从加载到JVM，再到GC清除，都经历了什么过程？\",\"t\":[\"详细步骤说明：\",\"用户创建一个对象，JVM首先需要到方法区去找对象的类型信息，然后再创建对象。\",\"JVM要实例化一个对象，首先要在堆中先创建一个对象 -> 半初始化状态\",\"对象首先会分配在堆内存中新生代的Eden区，然后经过一次Minor GC，对象如果存活，就会进入S区，在后续的每次GC中，如果对象一直存活，就会在S区来回拷贝，每移动一次，年龄加1，年龄最大值是15，默认就是最大年龄是15。超过年龄先之后，对象转入老年代。\",\"当方法执行结束后，栈中的指针会先移除掉。\",\"堆中的对象，经过Full GC就会被标记为垃圾，然后被GC线程清理掉。\"]},\"1437\":{\"h\":\"怎么样确定一个对象不是垃圾？\",\"t\":[\"有两种定位垃圾的方式：\",\"引用计数法：这种方式是给堆内存当中的每个对象记录一个引用个数，引用个数为0的就认为是垃圾。这是早期JDK采用的方式，引用计数无法解决循环引用的问题\",\"根可达算法：这种方式是在内存中，从引用根对象向下一直找引用，找不到的对象就是垃圾\"]},\"1438\":{\"h\":\"什么是GC Root？\",\"t\":[\"在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。\",\"在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量\",\"在方法区中常量引用的对象，譬如字符串常量池里的引用。\",\"在本地方法栈中JNI（即通常所说的Native方法）引用的对象\",\"Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointException），还有系统类加载器。\",\"所有被同步锁（synchronized关键字）持有的对象\",\"反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等\"]},\"1439\":{\"h\":\"JVM有哪些垃圾回收算法？\",\"t\":[\"算法\",\"速度\",\"空间开销\",\"移动对象\",\"Mark-Sweep\",\"中等\",\"少（但会堆积碎片）\",\"否\",\"Mark-Compact\",\"最慢\",\"少（不堆积碎片）\",\"是\",\"Copying\",\"最快\",\"通常需要活对象的2倍大小（不堆积碎片）\",\"是\"]},\"1440\":{\"h\":\"什么是STW？\",\"t\":[\"STW：stop the world，是在垃圾回收算法执行过程当中，需要将JVM内存冻结的一种状态，在STW状态下，Java所有的线程都是停止执行的，GC线程除外，只有native方法可以执行，但是，不能与JVM交互，GC各种算法优化的重点，就是减少STW，同时这也是JVM调优的重点。\"]},\"1441\":{\"h\":\"JVM有哪些垃圾回收器？\",\"t\":[\"收集器\",\"串行、并行或并发\",\"新生代、老年代\",\"算法\",\"Serial\",\"串行\",\"新生代\",\"复制算法\",\"Serial Old\",\"串行\",\"老年代\",\"标记-整理\",\"ParNew\",\"并行\",\"新生代\",\"复制算法\",\"Parallel Scavenge\",\"并行\",\"新生代\",\"复制算法\",\"Parallel Old\",\"并行\",\"老年代\",\"标记-整理\",\"CMS\",\"并发\",\"老年代\",\"标记-清除\",\"G1\",\"并发\",\"不区分\",\"标记-整理+复制算法\"]},\"1442\":{\"h\":\"什么是三色标记算法？\",\"t\":[\"CMS的核心算法就是三色标记。\",\"三色标记：是一种逻辑上的抽象，将每个内存对象分成三种颜色：黑色：表示自己和成员变量都已经标记完毕。灰色：自己标记完了，但是成员变量还没有完全标记完。白色：自己未标记完。\",\"CMS通过增量标记increment update的方式来解决漏标的问题。\",\"在G1当中采用SATB的方式来避免错标和漏标的情况。\"]},\"1443\":{\"h\":\"如何回收方法区？\",\"t\":[\"方法区的垃圾回收主要有两种，废弃的常量和无用的类，其中要称为无用的类，要同时满足下面三个条件：\",\"Java堆中不存在该类的任何实例对象\",\"加载该类的类加载器已经被回收\",\"该类对应的java.lang.Class对象不在任何地方被引用，且无法在任何地方通过反射访问该类的方法\"]},\"1444\":{\"h\":\"JVM 中的安全点和安全区各代表什么？\"},\"1445\":{\"h\":\"写屏障你了解吗？\"},\"1446\":{\"h\":\"解决并发扫描时对象消失问题的两种方案？\"},\"1447\":{\"h\":\"CMS 垃圾收集器的步骤？\",\"t\":[\"1、初始标记阶段：STW 只标记出根对象直接引用的对象\",\"2、并发标记：继续标记其他对象，与应用程序时并发执行\",\"3、重新标记：STW对并发执行阶段的对象进行重新标记\",\"4、并发清除：并行。将产生的垃圾清除。清除过程中，应用程序又会不断的产生新的垃圾，叫做浮动垃圾。这些垃圾就要留到下一次GC过程中清除。\"]},\"1448\":{\"h\":\"CMS 有什么缺点？\",\"t\":[\"CMS收集器对CPU资源非常敏感\",\"CMS处理器无法处理浮动垃圾\",\"在收集结束的时候，会产生大量的空间碎片\"]},\"1449\":{\"h\":\"G1垃圾收集器的步骤，G1有什么优缺点？\",\"t\":[\"G1的优点：\",\"停顿时间短\",\"用户可以指定最大的停顿时间\",\"不会产生内存碎片：G1的内存布局并不是固定大小以及固定数量的分代区域划分\",\"缺点：\",\"G1需要记忆集（卡表）来记录新生代和老年代之间的引用关系，这种数据结构在G1中需要占用大量的内存，可能达到整个堆内存容量的20%甚至更多。而且G1中维护记忆集的成本较高，带来了更高的执行负载，影响效率。\",\"CMS在小内存应用上的表现要优于G1，而大内存应用上G1更有优化，大小内存的界限是6GB到8GB。\"]},\"1450\":{\"h\":\"讲一下内存分配策略？\"},\"1451\":{\"h\":\"内存溢出和内存泄漏的区别？\",\"t\":[\"内存溢出（Out of Memory）是指程序在申请内存时，没有足够的空间供其使用\",\"内存泄漏（Memory Leak）是指程序在申请内存后，无法释放已申请的内存空间\"]},\"1452\":{\"h\":\"如何进行JVM调优？\",\"t\":[\"JVM调优主要是通过定制JVM运行参数来提高Java应用程序的运行速度。\"]},\"1453\":{\"h\":\"JVM参数有哪些？\",\"t\":[\"JVM参数大致可以分为三类：\",\"１、标准指令：-开头，这些是所有的HotSpot都支持的参数。可以用Java -help打印出来。\",\"２、非标准指令：-开头，这些指令通常是跟特定的HotSpot版本对应的，可以用Java -X打印出来\",\"３、不稳定参数：-XX开头，这一类参数是跟特定HotSpot版本对应的，并且变化非常大，详细的文档资料非常少，在JDK1.8版本下，有几个常用的不稳定指令：Java -XX:+PrintCommandLineFlags：查看当前命令的不稳定指令。\"]},\"1454\":{\"h\":\"虚拟机基础故障处理工具有哪些？\",\"t\":[\"工具\",\"作用\",\"jps\",\"虚拟机进程状况工具\",\"jstat\",\"虚拟机统计信息监视工具\",\"jinfo\",\"Java配置信息工具\",\"jmap\",\"Java内存映射工具\",\"jstack\",\"Java堆栈跟踪工具\",\"JVisualVM\",\"图形化展示\",\"JConsole\",\"远程控制\"]},\"1455\":{\"h\":\"怎么查看一个Java进程的JVM参数，谈谈你了解的JVM参数\",\"t\":[\"打印出所有不稳定参数所有默认值：java -XX:+PrintFlagsInitial\",\"打印出所有最终生效的不稳定指令：java -XX:+PrintFlagsFinal\"]},\"1456\":{\"h\":\"什么情况下堆内存会溢出，什么情况方法区会内存溢出？\",\"t\":[\"栈溢出的典型例子：\",\" private static void fun() { //递归，调用自己 fun(); } \",\"方法区内存溢出的例子：\",\" private static void fun() { //递归，调用自己 fun(); } \"]},\"1457\":{\"h\":\"JDK8 为什么要将永久代改为元空间？\",\"t\":[\"在JDK8之前，Java虚拟机中的永久代（Permanent Generation）用于存储类的元数据信息、静态变量、常量等。然而，永久代存在一些问题，例如固定大小、难以调优、容易导致内存溢出等。\",\"为了解决这些问题，并引入更灵活和可调整大小的内存区域，JDK8将永久代（Permanent Generation）替换为元空间（Metaspace），并将其定义为方法区（Method Area）的一部分。\",\"以下是一些原因解释为什么JDK8将永久代改为元空间，并将其归类为方法区：\",\"内存动态分配：永久代的大小是固定的，无法动态调整，这在一些场景下可能会导致内存溢出。元空间通过使用本地内存（Native Memory）来存储元数据，可以根据应用程序的需要进行动态分配和释放，更加灵活。\",\"类元数据卸载：永久代存储的类元数据在应用程序运行期间是不可卸载的，即使类已经不再使用。而元空间中的类元数据可以进行卸载，当类不再被引用时，虚拟机可以回收其占用的内存，避免了永久代中的内存泄漏问题。\",\"自动调整空间大小：元空间可以根据应用程序的需要自动调整大小，避免了调整永久代大小的繁琐工作。在元空间中，可以通过设置参数来控制元数据的大小和增长策略，以满足应用程序的需求。\",\"元数据分配效率：元空间使用本地内存存储元数据，相较于永久代，元空间的元数据分配效率更高。在永久代中，由于采用传统的JVM对象分配方式，需要进行内存分配和垃圾回收等操作，而元空间中的元数据分配是基于本地内存的，更加高效。\"]},\"1458\":{\"h\":\"\"},\"1459\":{\"h\":\"Dokcer命令\"},\"1460\":{\"h\":\"Docker常用的命令？\",\"t\":[\"查看容器情况：\",\"docker ps \"]},\"1461\":{\"h\":\"查看所有容器的命令？\",\"t\":[\"docker ps -a \"]},\"1462\":{\"h\":\"\"},\"1463\":{\"h\":\"Linux命令\"},\"1464\":{\"h\":\"使用cat命令如何统计文件中一个字符串出现的频率？\",\"t\":[\"cat 文件名 | grep -o \\\"要统计的字符串\\\" | wc -l \",\"命令含义：\",\"cat命令用于将文件内容输出到标准输出。\",\"grep -o \\\"要统计的字符串\\\"命令用于从标准输入中匹配并提取指定字符串（使用-o选项只输出匹配的部分）。\",\"wc -l命令用于统计行数（-l选项只统计行数）。\"]},\"1465\":{\"h\":\"如何查看一个应用的信息？\"},\"1466\":{\"h\":\"\"},\"1467\":{\"h\":\"Nginx\"},\"1468\":{\"h\":\"Nginx如何保证高可用？\"},\"1469\":{\"h\":\"Java并发编程\"},\"1470\":{\"h\":\"JMM实现原理\",\"t\":[\"JMM即Java多线程通信模型-共享内存模型，包含三个方面：\",\"Java层面\",\"Jvm层面\",\"硬件层面\",\"并发与并行：\",\"并行：指同一时刻，有多条指令在多个处理器上同时执行。无论从微观还是宏观来看，二者都是一起执行的\",\"并发：指同一时刻，只能有一条执行执行，但多个进程指令会被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使得多个进程快速交替的执行\",\"并发三大特性：可见性、有序性、原子性；并发要解决的三大问题：同步问题、互斥问题、分工问题。\"]},\"1471\":{\"h\":\"可见性\",\"t\":[\"当一个线程修改了共享变量的值，其他线程能够看到修改的值。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递没接的方法来实现可见性的。\",\"保证可见性的方法：\",\"通过volatile关键字保证可见性\",\"通过内存屏障保障可见性\",\"通过sychronized关键字保证可见性\",\"通过Lock保证可见性\",\"通过final关键字保证可见性\"]},\"1472\":{\"h\":\"原子性\"},\"1473\":{\"h\":\"有序性\",\"t\":[\"Java虚拟机规范中定义了Java内存模型，用于屏蔽掉各种硬件和操作系统内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的，即一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。JMM描述的是一种抽象的概念，一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性、有序性、可见性展开的。\",\"Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示，Java内存模型和计算机硬件内存架构是一个交叉关系：\",\"关于主内存和工作内存之间的具体交互协议，即一个变量如何才主内存拷贝到工作内存、如何从工作内存到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成；\",\"lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态\",\"unlock（解锁）作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\",\"read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用\",\"load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中\",\"use（使用）：作用于工作内存的变量，把工作内存中一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作\",\"assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作\",\"store（存储）；作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作\",\"write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中\",\"volatile关键字的C++实现源码：\",\"可以发现当变量被volitle关键字修饰后，在变量被修改后，会添加一个内存屏障。\",\"内存屏障在Linux系统x86中的实现：\",\"汇编层面volatile的实现：\",\"lock;addl $0,0(%%rsp) \",\"模板解释器(templateInterpreter)，其对每个指令都写了一段对应的汇编代码，启动时将每个指令与对应汇编代码入口绑定，可以说是效率做到了极致。\",\"lock前缀指令的作用：\",\"确保后续指令执行的原子性。在Pentium及之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其它处理器暂时无法通过总线访问内存，很显然，这个开销很大。在新的处理器中，Intel使用缓存锁定来保证指令执行的原子性，缓存锁定将大大降低lock前缀指令的执行开销\",\"lock前缀指令具有类似内存屏障的功能，禁止该指令与前面和后面的读写指令重排序\",\"lock前缀指令会等待它之前所有的指令完成、并且所有缓冲的写操作写回内存（也就是将store buffer中的内容写入内存）之后才开始执行，并且根据缓存一执行协议，刷新store buffer的操作会导致其他cache中的副本失效。\",\"Java中，保证可见性的方式有两种，一种是内存屏障（JVM利用storeLoad，硬件层面利用lock或mfence），另一种是利用上下文切换。\"]},\"1474\":{\"h\":\"缓存一致性\",\"t\":[\"CPU缓存即高速缓冲存储器，是位于CPU与主存之间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据需要等待一定时间周期，Cache中保存着CPU刚刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可以从Cache中直接调用，减少CPU等待时间，提高了系统的效率。\",\"三级缓存的示意图：\",\"计算机体系结构中，缓存一致性是共享资源数据的一致性，这些数据最终存储在多个本地缓存中。当系统中的客户机维护公共内存资源的缓存时，可能会出现数据不一致的问题，这在多处理系统中的CPU尤其如此。\",\"在共享内存多处理器系统中，每个处理器都有一个单独的缓存内存，共享数据可能有多个副本：一个副本在主内存中，一个副本在请求它的每个处理器的本地缓存中。当数据的一个副本发生更改时，其他副本必须反映该更改。缓存一致性是确保共享操作数（数据）值的变化能够及时地在整个系统中传播的规程。\",\"缓存一致性的要求：\",\"写传播\",\"对任何缓存中的数据的更改都必须传播到对等缓冲中的其他副本（该缓存中的副本）\",\"事务串行化\",\"对单个内存位置的读/写必须被所有处理器以相同的顺序看到。理论上，一致性可以在加载/存储粒度上执行。然而，在实践中，它通常在缓存块的粒度上执行\",\"一致性机制\",\"确保一致性的两种最常见的机制是窥探机制和基于目录的机制，这两种机制各有优缺点。如果有足够的带宽可用，基于协议的窥探往往会更快，因为所有事务都是处理器看到的请求/响应。其缺点是窥探是不可扩展的。每个请求都必须广播到系统中的所有节点，这意味着随着系统变大，（逻辑或物理）总线的大小及其提供的带宽也必须增加。另一方面，目录往往有更长的延迟（3跳 请求/转发/响应），但使用更少的带宽，因为消息是点对点的，而不是广播的。由于这个原因，许多较大的系统（大于64位处理器）使用这种类型的缓存一致性\",\"JMM的内存可见性保证：\",\"单线程程序\",\"正确同步的多线程程序\",\"未同步/未正确同步的多线程程序\",\"volatile的内存语义总结：\",\"可见性：\",\"原子性：\",\"有序性：\"]},\"1475\":{\"h\":\"List、Set、HashMap底层原理\",\"t\":[\"数组查找公式：a[n]=起始地址+（n∗字节数）。\",\"数组的底层实现：\",\"transient Object[] elementData; \",\"ArrayList的扩容机制：\",\"private Object[] grow(int minCapacity) { return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); } \",\"主要思想：空间换时间。\",\"集合类实现序列化接口的目的：\",\"网络传输\",\"硬盘持久化\",\" LinkedList是双向链表。\",\"添加元素效率的对比：如果ArrayList指定了初始容量，那么效率会比LinkedList高，如果ArrayList没有指定初始容量，添加效率会比LinkedList低。\",\"HashMap的特点：key、value存储，key可以为null，同样的key会被覆盖掉。\",\"HashMap的底层存储结构：底层采用数据、链表、红黑树来实现。\",\"用链表是来解决数组小表覆盖的问题（哈希冲突的问题），红黑树是为了解决当哈希冲突比较多的时候，查询效率降低的问题。\",\"HashMap插入元素的方式，JDK7之前：头插法，JDK8以后：尾插法。\",\"头插法和尾插法的对比：HashMap 链表插入方式。\",\"链表转红黑树的阈值：\",\"static final int TREEIFY_THRESHOLD = 8; \",\"当红黑树的元素小于6的时候，又会退化成链表结构：\",\"static final int TREEIFY_THRESHOLD = 8; \",\"扩容因子：\",\"static final float DEFAULT_LOAD_FACTOR = 0.75f; \",\"JDK8 HashMap put的流程图：\",\"并发安全的HashMap主要有两个，HashTable和ConcurrentHashMap，HashTable是基于方法级别的synchronized的来实现的。ConcurrentHashMap是基于Node + CAS + Synchronized来实现的。\",\"ConcurrentHashMap在JDK1.7分段锁来实现。ConcurrentHashMap只是在链表的头结点加锁，锁的粒度更小了。\"]},\"1476\":{\"h\":\"线程池底层原理\",\"t\":[\"线程池执行过程示意图：\",\"线程池底层原理：\",\" public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { } \",\"线程池参数解析：\",\"corePoolSize：核心线程数\",\"maximumPoolSize：最大线程数\",\"keepAliveTime：最大线程数的存活时间\",\"unit：时间单位\",\"workQueue：阻塞队列\",\"threadFactory：线程工厂\",\"handler：拒绝策略\",\"提交任务的源码：\",\"public void execute(Runnable command) { if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) < corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } // offer方法和add方法的区别在于，add方法会抛出非法一场，offer方法则会返回false if (isRunning(c) && workQueue.offer(command)) { int recheck = ctl.get(); // 双重检测 if (! isRunning(recheck) && remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); } else if (!addWorker(command, false)) // 拒绝方法 reject(command); } \",\"ThreadPoolExecutor的拒绝策略：\",\"AbortPolicy\",\"CallerRunsPolicy\",\"DiscardOldestPolicy\",\"DiscardPolicy\"]},\"1477\":{\"h\":\"深入理解Java线程\",\"t\":[\"一个线程就是一个CPU可以执行的指令序列。\",\"从操作系统的视角来看，分配资源的最小单位是进程，线程是CPU调度的最小单位。\",\"进程间通信方式：\",\"管道及有名管道\",\"信号\",\"消息队列\",\"共享内存\",\"信号量\",\"套接字\",\"线程同步：是指线程之间所具有的一种制约关系，一个线程的执行依赖于另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。\",\"线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排他性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其他要使用该资源的线程必须等待，直到占用资源者释放该资源，线程互斥可以看成是一种特殊的线程同步。\",\"四种线程同步互斥的控制方法：\",\"临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问（在一段时间内只允许一个线程访问的资源就称为临界资源）\",\"互斥量：为协调共同对一个共享资源的单独访问而设计的\",\"信号量：为控制一个具有有限数量用户资源而设计\",\"事件：用来通知线程有一些事件已发生，从而启动后继任务的开始\",\"操作系统层面的线程生命周期可以用“五态模型”来描述，这个五种状态分别是：初始状态、可运行状态、运行状态、休眠状态和终止状态。\",\"Java层面线程共有六种状态：\",\"Java中创建线程的方式：\",\"Thread\",\"Runnable\",\"Callable\",\"本质上都是调用Thread#start方法，线程真正创建线程的过程如下：\",\"Java的线程是内核级别的线程，而不是用户态的线程，这就是为什么说Java的线程比较重的原因。\",\"协程是轻量级的线程，是用户态的，不会切换到内核态。\",\"优雅的停止线程：\",\"stop方法，过于暴力，会释放对象锁，可能会造成数据不一致的问题。\",\"interrupt，将线程的中断标志和设置为true，不会停止线程\",\"java.lang.Thread#isInterrupted()，判断当前线程的中断标志位是否位true，并清除中断标志位，重置为fasle\",\"可以手动判断线程的中断标识位，停止线程。\",\"Thread#sleep方法会清除中断标识。\",\"Java线程间通信主要有两种：\",\"volatile\",\"等待唤醒机制 \",\"wait和notify\",\"AQS中的await和signal\",\"管道输入输出流\",\"Thread#join（基于等待唤醒机制）\",\"notify主要两个缺陷：一个是必须配合sychronized使用，另一个是无法指令唤醒的线程具体是哪一个，但LockSupport可以解决这两个问题：\",\"LockSupport.unpark(threadName); \"]},\"1478\":{\"h\":\"CAS与Atomic实现原理\"},\"1479\":{\"h\":\"CAS源码解析\",\"t\":[\"CAS通常指的是这样一种原子操作，针对一个变量，首先比较它的内存值与某个期望值是否相同，如果相同，就给他赋一个新值。\",\"CAS的伪代码如下：\",\"if (value == expectedValue) { value = newValue; } \",\"CAS的过程如下：\",\"Java中的CAS操作：\",\"Hotspot 虚拟机对compareAndSwapInt 方法的实现如下：\",\"#unsafe.cpp UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) UnsafeWrapper(\\\"Unsafe_CompareAndSwapInt\\\"); oop p = JNIHandles::resolve(obj); // 根据偏移量，计算value的地址 jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); // Atomic::cmpxchg(x, addr, e) cas逻辑 x:要交换的值 e:要比较的值 //cas成功，返回期望值e，等于e,此方法返回true //cas失败，返回内存中的value值，不等于e，此方法返回false return (jint)(Atomic::cmpxchg(x, addr, e)) == e; \",\"核心逻辑在Atomic::cmpxchg方法中，这个根据不同操作系统和不同CPU会有不同的实现。这里我们以linux_64x的为例，查看Atomic::cmpxchg的实现：\",\"#atomic_linux_x86.inline.hpp inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) { //判断当前执行环境是否为多处理器环境 int mp = os::is_MP(); //LOCK_IF_MP(%4) 在多处理器环境下，为 cmpxchgl 指令添加 lock 前缀，以达到内存屏障的效果 //cmpxchgl 指令是包含在 x86 架构及 IA-64 架构中的一个原子条件指令， //它会首先比较 dest 指针指向的内存值是否和 compare_value 的值相等， //如果相等，则双向交换 dest 与 exchange_value，否则就单方面地将 dest 指向的内存值交给exchange_value。 //这条指令完成了整个 CAS 操作，因此它也被称为 CAS 指令。 __asm__ volatile (LOCK_IF_MP(%4) \\\"cmpxchgl %1,(%3)\\\" : \\\"=a\\\" (exchange_value) : \\\"r\\\" (exchange_value), \\\"a\\\" (compare_value), \\\"r\\\" (dest), \\\"r\\\" (mp) : \\\"cc\\\", \\\"memory\\\"); return exchange_value; \",\"cmpxchgl的详细执行过程：\",\"首先，输入是\\\"r\\\" (exchange_value), “a” (compare_value), “r” (dest), “r” (mp)，表示compare_value存入eax寄存器，而exchange_value、dest、mp的值存入任意的通用寄存器。嵌入式汇编规定把输出和输入寄存器按统一顺序编号，顺序是从输出寄存器序列从左到右从上到下以“%0”开始，分别记为%0、%1···%9。也就是说，输出的eax是%0，输入的exchange_value、compare_value、dest、mp分别是%1、%2、%3、%4。\",\"因此，cmpxchg %1,(%3)实际上表示cmpxchg exchange_value,(dest)\",\"需要注意的是cmpxchg有个隐含操作数eax，其实际过程是先比较eax的值(也就是compare_value)和dest地址所存的值是否相等，\",\"输出是\\\"=a\\\" (exchange_value)，表示把eax中存的值写入exchange_value变量中。\",\"Atomic::cmpxchg这个函数最终返回值是exchange_value，也就是说，如果cmpxchgl执行时compare_value和dest指针指向内存值相等则会使得dest指针指向内存值变成exchange_value，最终eax存的compare_value赋值给了exchange_value变量，即函数最终返回的值是原先的compare_value。此时Unsafe_CompareAndSwapInt的返回值(jint)(Atomic::cmpxchg(x, addr, e)) == e就是true，表明CAS成功。如果cmpxchgl执行时compare_value和(dest)不等则会把当前dest指针指向内存的值写入eax，最终输出时赋值给exchange_value变量作为返回值，导致(jint)(Atomic::cmpxchg(x, addr, e)) == e得到false，表明CAS失败。\",\"现代处理器指令集架构基本上都会提供 CAS 指令，例如 x86 和 IA-64 架构中的 cmpxchgl 指令和 comxchgq 指令，sparc 架构中的 cas 指令和 casx 指令。\",\"不管是 Hotspot 中的 Atomic::cmpxchg 方法，还是 Java 中的 compareAndSwapInt 方法，它们本质上都是对相应平台的 CAS 指令的一层简单封装。CAS 指令作为一种硬件原语，有着天然的原子性，这也正是 CAS 的价值所在。\",\"CAS 虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方面：\",\"自旋 CAS 长时间地不成功，则会给 CPU 带来非常大的开销\",\"只能保证一个共享变量原子操作\",\"ABA 问题\",\"ABA问题：当有多个线程对一个原子类进行操作的时候，某个线程在短时间内将原子类的值A修改为B，又马上将其修改为A，此时其他线程不感知，还是会修改成功。\",\"ABA问题示例：\",\"package com.concurrent; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.atomic.AtomicMarkableReference; import java.util.concurrent.atomic.AtomicStampedReference; import java.util.concurrent.locks.LockSupport; /** * 与钱相关的业务 ABA问题比较重要 * 也可以使用{@link AtomicMarkableReference} 简化，这样可以不关心修改过几次，仅仅关心是否修改过。因此变量mark是boolean类型，仅记录值是否有过修改。 */ @Slf4j public class AtomicStampedReferenceTest { public static void main(String[] args) { // 定义AtomicStampedReference Pair.reference值为1, Pair.stamp为1 AtomicStampedReference atomicStampedReference = new AtomicStampedReference(1, 1); new Thread(() -> { int[] stampHolder = new int[1]; int value = (int) atomicStampedReference.get(stampHolder); int stamp = stampHolder[0]; log.debug(\\\"Thread1 read value: \\\" + value + \\\", stamp: \\\" + stamp); // 阻塞1s LockSupport.parkNanos(1000000000L); // Thread1通过CAS修改value值为3 if (atomicStampedReference.compareAndSet(value, 3, stamp, stamp + 1)) { log.debug(\\\"Thread1 update from \\\" + value + \\\" to 3\\\"); } else { log.debug(\\\"Thread1 update fail!\\\"); } }, \\\"Thread1\\\").start(); new Thread(() -> { int[] stampHolder = new int[1]; int value = (int) atomicStampedReference.get(stampHolder); int stamp = stampHolder[0]; log.debug(\\\"Thread2 read value: \\\" + value + \\\", stamp: \\\" + stamp); // Thread2通过CAS修改value值为2 if (atomicStampedReference.compareAndSet(value, 2, stamp, stamp + 1)) { log.debug(\\\"Thread2 update from \\\" + value + \\\" to 2\\\"); // do something value = (int) atomicStampedReference.get(stampHolder); stamp = stampHolder[0]; log.debug(\\\"Thread2 read value: \\\" + value + \\\", stamp: \\\" + stamp); // Thread2通过CAS修改value值为1 if (atomicStampedReference.compareAndSet(value, 1, stamp, stamp + 1)) { log.debug(\\\"Thread2 update from \\\" + value + \\\" to 1\\\"); } } }, \\\"Thread2\\\").start(); } } \"]},\"1480\":{\"h\":\"Atomic源码解析\",\"t\":[\"在java.util.concurrent.atomic包里提供了一组原子操作类：\",\"基本类型：AtomicInteger、AtomicLong、AtomicBoolean；\",\"引用类型：AtomicReference、AtomicStampedRerence、AtomicMarkableReference；\",\"数组类型：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray\",\"对象属性原子修改器：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater\",\"原子类型累加器（jdk1.8增加的类）：DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder、Striped64\",\"LongAdder和DoubleAdder在高并发的情况下，性能提升明显：\",\"LongAdder内部有一个base变量，一个cell[]数组：\",\"base变量：非竞态条件下，直接累加到该变量上\",\"Cell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中\",\"/** Number of CPUS, to place bound on table size */ // CPU核数，用来决定槽数组的大小 static final int NCPU = Runtime.getRuntime().availableProcessors(); /** * Table of cells. When non-null, size is a power of 2. */ // 数组槽，大小为2的次幂 transient volatile Cell[] cells; /** * Base value, used mainly when there is no contention, but also as * a fallback during table initialization races. Updated via CAS. */ /** * 基数，在两种情况下会使用： * 1. 没有遇到并发竞争时，直接使用base累加数值 * 2. 初始化cells数组时，必须要保证cells数组只能被初始化一次（即只有一个线程能对cells初始化）， * 其他竞争失败的线程会讲数值累加到base上 */ transient volatile long base; /** * Spinlock (locked via CAS) used when resizing and/or creating Cells. */ \",\"定义了一个内部Cell类，这就是我们之前所说的槽，每个Cell对象存有一个value值，可以通过Unsafe来CAS操作它的值：\",\"添加方法的源代码：\",\" public void add(long x) { Cell[] cs; long b, v; int m; Cell c; if ((cs = cells) != null || !casBase(b = base, b + x)) { boolean uncontended = true; if (cs == null || (m = cs.length - 1) < 0 || (c = cs[getProbe() & m]) == null || !(uncontended = c.cas(v = c.value, v + x))) longAccumulate(x, null, uncontended); } } \",\"LongAdder#add方法的逻辑如下图：\",\"只有从未出现过并发冲突的时候，base基数才会使用到，一旦出现了并发冲突，之后所有的操作都只针对Cell[]数组中的单元Cell。\",\"如果Cell[]数组未初始化，会调用父类的longAccumelate去初始化Cell[]，如果Cell[]已经初始化但是冲突发生在Cell单元内，则也调用父类的longAccumelate，此时可能就需要对Cell[]扩容了。\",\"这也是LongAdder设计的精妙之处：尽量减少热点冲突，不到最后万不得已，尽量将CAS操作延迟。\",\"整个Striped64#longAccumulate的流程图如下：\"]},\"1481\":{\"h\":\"synchronized实现原理\"},\"1482\":{\"h\":\"synchronized基础\",\"t\":[\"Java中对静态变量的自增、自减并不是原子操作。\",\"i++的JVM字节码指令：\",\"getstatic i // 获取静态变量i的值 iconst_1 // 将int常量1压入操作数栈 iadd // 自增 \",\"i--的JVM字节码指令：\",\"getstatic i // 获取静态变量i的值 iconst_1 // 将int常量1压入操作数栈 isub // 自减 \",\"一个程序运行多个线程本身是没有问题的，问题出在多个线程访问共享资源：\",\"多个线程读共享其实也没有问题\",\"在多个线程对共享资源读写操作时发生指令交错，就会出现问题\",\"一段代码块如果存在对共享资源的多线程读写操作，就称这段代码块为临界区，其共享资源为临界资源。\",\"//临界资源 private static int counter = 0; public static void increment() { //临界区 counter++; } public static void decrement() {//临界区 counter--; } \",\"多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件，为了避免临界区的竞态条件发生，有多种手段可以达到目的：\",\"阻塞式的解决方案：synchronized、Lock\",\"非阻塞式的解决方案：原子变量（CAS）\",\"虽然Java中互斥和同步都可以采用synchronized关键字来完成，但它们还是有区别的：互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码，同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点。\",\"synchronized同步块是Java提供的一种原子性内置锁，Java中的每个对象都可以把它当作一个同步锁来使用，这些Java内置的使用者看不到的锁被称为内置锁，也叫做监视器锁。\",\"synchronized加锁方式：\",\"对于上面的例子，可以使用synchroized来解决临界区资源共享的问题：\",\"/********************* * 方式一 *******************/ public static synchronized void increment() { counter++; } public static synchronized void decrement() { counter--; } /********************* * 方式二 *******************/ private static String lock = \\\"\\\"; public static void increment() { synchronized (lock){ counter++; } } public static void decrement() { synchronized (lock) { counter--; } } \"]},\"1483\":{\"h\":\"Monitor机制\",\"t\":[\"synchronized是JVM内置锁，基于Monitor机制实现，依赖底层操作系统的互斥原语Mutex（互斥量），它是一个重量级锁，性能较低。后来，synchronized在JDK1.5之后版本做了重大的优化，如锁粗化、锁消除、轻量级锁、偏向锁、自适应自旋等技术来减少锁操作的开销，内置锁的并发性能已经基本与Lock持平。\",\"同步方法是通过方法中的access_flags中设置ACC_SYNCHRONIZED标志来实现；同步代码块是通过monitorenter和monitorexit来实现。两个指令的执行是JVM通过调用操作系统的互斥源于meutex来实现。被阻塞的线程会被挂起、等待重新调度，会导致“用户态”和“内核态”两个态之间来回切换，对性能有较大影响。\",\"Monitor，直译为“监视器”，在操作系统领域一般翻译为“管程“。管程是指管理共享变量以及对共享变量操作的过程，让它们支持并发。在Java1.5之前，Java语言提供的唯一并发语言就是管程，Java1.5之后提供的SDK并发包也是以管程为基础的。除了Java之外，C/C++、C#等高级语言也都是支持管程的。sychronized关键字和wait()、notify()、notifyAll()这三个方法是Java中管程技术的组成部分。\",\"在管程的发展史上，先后出现过三种不同的管程模型，分别是Hasen模型、Hoare模型和MESA模型。现在广泛使用的是MESA模型。\",\"管程中引入了条件变量的概念，而且每个条件变量都对应有一个等待队列。条件变量个等待队列的作用是解决线程之间的同步问题。\",\"对于MESA管程来说，有一个编程范式：\",\"while(条件不满足) { wait(); } \",\"唤醒时间和获取到锁继续执行的时间是不一致的，被唤醒的线程再次执行时可能条件又不满足了，所以循环校验条件。MESA模型的wait()方法还有一个超时参数，为了避免线程进入等待队列永久阻塞。\",\"notify和notifyAll分别何时使用：\",\"所有等待线程拥有相同的等待条件\",\"所有等待线程被唤醒后，执行相同的操作\",\"只需要唤醒一个线程\",\"ObjectMonitor() { _header = NULL; //对象头 markOop _count = 0; _waiters = 0, _recursions = 0; // 锁的重入次数 _object = NULL; //存储锁对象 _owner = NULL; // 标识拥有该monitor的线程（当前获取锁的线程） _WaitSet = NULL; // 等待线程（调用wait）组成的双向循环链表，_WaitSet是第一个节点 _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; //多线程竞争锁会先存到这个单向链表中 （FILO栈结构） FreeNext = NULL ; _EntryList = NULL ; //存放在进入或重新进入时被阻塞(blocked)的线程 (也是存竞争锁失败的线程) _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; _previous_owner_tid = 0; } \",\"Java中Monitor的工作流程：\",\"在获取锁时，是将当前线程插入到cxq的头部，而释放锁时，默认策略（QMode=0）是：如果EntryList为空，则将cxq中的元素按原有顺序插入到EntryList，并唤醒第一个线程，也就是当EntryList为空时，是后来的线程先获取锁。_EntryList不为空，直接从_EntryList中唤醒线程。\",\"重量级锁阻塞挂起的方法：pthread_cond_wait。\"]},\"1484\":{\"h\":\"对象头\",\"t\":[\"Hotspot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对其填充（Padding）。\",\"对象头：比如hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象才有）等\",\"实例数据：存放类的属性数据信息，包括父类的属性信息\",\"对其填充：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐\",\"HotSpot虚拟机的对象头包括：\",\"Mark Word\",\"用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位虚拟机中分别为32bit和64bit，官方称它为“Mark Word”\",\"Klass Pointer\",\"对象头的另一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。32位4字节，64位开启指针压缩或最大堆内存<32g时4字节，否则8字节。JDK默认开启指针压缩后位4字节，当在JVM参数中关闭指针压缩（-XX:-UseCompressedOops）后，长度为8字节\",\"数组长度（只有数组对象有）\",\"如果对象是一个数组，那还在对象头中还必须有一块数据用于记录数组长度。占据4字节\",\"new Object()在64位的操作系统的内存中占几8（对象头）+4（元数据指针）+4（对齐填充）=16个字节。\",\"32位JVM下的对象结构描述：\",\"64位JVM下的对象结构描述：\",\"Mark Word中锁标记枚举：\",\"enum { locked_value = 0, //00 轻量级锁 unlocked_value = 1, //001 无锁 monitor_value = 2, //10 监视器锁，也叫膨胀锁，也叫重量级锁 marked_value = 3, //11 GC标记 biased_lock_pattern = 5 //101 偏向锁 } \",\"含义如下：\"]},\"1485\":{\"h\":\"偏向锁\",\"t\":[\"偏向锁是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了消除数据在无竞争情况下锁重入（CAS操作）的开销而引入偏向锁。对于没有锁竞争的场合，偏向锁有很好的优化效果。\",\"/***StringBuffer内部同步***/ public synchronized int length() { return count; } //System.out.println 无意识的使用锁 public void println(String x) { synchronized (this) { print(x); newLine(); } } \",\"当JVM启用了偏向锁模式（jdk6默认开启），新创建对象的Mark Word中的Thread ID为0，说明此时处于可偏向但未偏向任何线程，也叫做匿名偏向状态。\",\"偏向锁模式存在偏向锁延迟机制：HotSpot虚拟机在启动后有4s的延迟才会对每个新建的对象开启偏向锁模式。JVM启动时会进行一系列的复杂活动，比如装在配置，系统类初始化等等。在这个过程中会使用大量synchronized关键字对对象加锁，且这些锁大多数都不是偏向锁。为了减少初始化时间，JVM默认延时加载偏向锁。\",\"/关闭延迟开启偏向锁 -XX:BiasedLockingStartupDelay=0 //禁止偏向锁 -XX:-UseBiasedLocking //启用偏向锁 -XX:+UseBiasedLocking \",\"倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段，此时Mark Word的结构也变为轻量级锁的结构。轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间多个线程访问同一把锁的场合，就会导致轻量级锁膨胀为重量级锁。\",\"锁升级过程：\",\"从偏向锁的加锁和解锁过程中可以看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获取锁时，JVM就需要等到安全点时，再将偏向锁撤销为无锁状态或升级为轻量级锁，这个过程会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。\",\"以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向锁撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。\",\"每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正在加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发生当前对象的epoch值和class的epoch不想等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id改成当前线程Id。\",\"当达到重偏向阈值（默认20）后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。\",\"设置JVM参数-XX:+PrintFlagsFinal，在项目启动时即可输出JVM的默认参数值\",\"intx BiasedLockingBulkRebiasThreshold = 20 // 默认偏向锁批量重偏向阈值 intx BiasedLockingBulkRevokeThreshold = 40 //默认偏向锁批量撤销阈值 \",\"可以通过JVM参数XX:BiasedLockingBulkRebiasThreshold和XX:BiasedLockingBulkRevokeThreshold来手动设置阈值。\",\"当撤销偏向锁阈值超过40次后，JVM会认为不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的。\",\"注意；时间-XX:BiasedLockingDecayTime=25000ms范围内没有达到40次，撤销次数清0，重新计时。\",\"批量重偏向和批量撤销的总结：\",\"批量重偏向和批量撤销是针对类的优化，和对象无关\",\"偏向锁重偏向一次之后不可再次重偏向\",\"当某个类已经触发批量撤销机制后，JVM会默认当前类产生了严重的问题，剥夺了该类的新实例对象使用偏向锁的权利\",\"重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候线持有锁的线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。\",\"自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势\",\"在Java6之后自旋是自适应的，比如对象刚刚一次自旋操作成功过，那么认为这次自旋成功的可能性高，就会多自旋几次；繁殖，就少自旋身之不自旋，比较智能\",\"Java7之后不能控制是否开启自旋功能\",\"自旋的目的是为了减少线程挂起的次数，尽量避免直接挂起线程（挂起操作涉及系统调用，存在用户态和内核态切换，这才是重量级锁最大的开销）。\"]},\"1486\":{\"h\":\"锁粗化\",\"t\":[\"假设一系列的连续操作都会对同一个对象反复加锁及解锁，甚至加锁的操作是出现在循环体中的，即使没有出现线程竞争，频繁地互斥同步操作也会导致不必要的性能损耗。如果JVM检测到有一连串零碎的操作都是对同一对象的加锁，将会扩大加锁同步的范围（即锁粗化）到整个操作序列的外部。\",\"StringBuffer buffer = new StringBuffer(); /** * 锁粗化 */ public void append(){ buffer.append(\\\"aaa\\\").append(\\\" bbb\\\").append(\\\" ccc\\\"); } \",\"上述代码每次调用buffer.append方法都需要加锁和解锁，如果JVM检测到有一连串的对同一个对象的加锁和解锁的操作，就会将其合并称一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。\"]},\"1487\":{\"h\":\"锁消除\",\"t\":[\"锁消除即删除不必要的加锁操作。锁消除是Java虚拟机在JIT编译期间，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间。\",\"public class LockEliminationTest { /** * 锁消除 * -XX:+EliminateLocks 开启锁消除(jdk8默认开启） * -XX:-EliminateLocks 关闭锁消除 * @param str1 * @param str2 */ public void append(String str1, String str2) { StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(str1).append(str2); } public static void main(String[] args) throws InterruptedException { LockEliminationTest demo = new LockEliminationTest(); long start = System.currentTimeMillis(); for (int i = 0; i < 100000000; i++) { demo.append(\\\"aaa\\\", \\\"bbb\\\"); } long end = System.currentTimeMillis(); System.out.println(\\\"执行时间：\\\" + (end - start) + \\\" ms\\\"); } } \",\"StringBuffer的append是个同步方法，但是append方法中的StringBuffer属于一个局部变量，不可能从该方法中逃逸出去，因此其实这个过程是线程安全的，可以将锁消除。\"]},\"1488\":{\"h\":\"逃逸分析\",\"t\":[\"逃逸分析，是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java HotSpot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域。\",\"逃逸分析分为方法逃逸和线程逃逸：\",\"方法逃逸：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中\",\"线程逃逸：这个对象甚至可能被其它线程访问到，例如赋值给类变量或可以在其它线程中访问的实例变量\",\"使用逃逸分析，编译器可以对代码做如下优化：\",\"同步省略或锁消除。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步\",\"将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配\",\"分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中\"]},\"1489\":{\"h\":\"synchronized的优化\",\"t\":[\"JVM对synchronized做了如下优化：\",\"针对偏向锁（偏向锁撤销存在性能问题），有批量重偏向，批量撤销\",\"针对重量级锁，有自旋优化，自适应自旋\",\"锁的粗化和锁的消除\"]},\"1490\":{\"h\":\"AQS与ReentrantLock实现原理\",\"t\":[\"AQS的核心：\",\"同步等待队列（单向链表）：主要用于维护获取锁失败时的入队的线程\",\"条件等待队列（双向链表）：调用await()的时候会释放锁，然后线程会加入到条件队列，调用signal唤醒的时候会把条件队列中的线程节点移动到同步队列中，等待再次获得锁\",\"JUC包中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列，条件队列，独占获取，共享获取等，而这些行为的抽象就是基于AbstractQueuedSynchronizer实现的，AQS是一个抽象同步框架，可以用来实现一个依赖状态的同步器。\",\"JDK中提供的大多数的同步器如Lock，Latch，Barrier等，都是基于AQS框架来实现的\",\"一般是通过一个内部类Sync继承AQS\",\"将同步器所有调用都映射到Sync对应的方法\",\"AQS具备的特性：\",\"阻塞等待队列\",\"共享/独占\",\"公平/非公平\",\"可重入\",\"允许中断\",\"AQS内部维护属性volatile int state：\",\"state表示资源的可用状态\",\"state属性三种访问方式：\",\"getState()\",\"setState()\",\"compareAndSetState()\",\"AQS定义两种资源共享方式：\",\"Exclusive-独占，只有一个线程能执行，如ReentrantLock\",\"Share-共享，多个线程可以同时执行，如Semaphore/CountDownLatch\",\"AQS定义了5个队列中节点的状态：\",\"值为0，初始化状态，表示当前节点在sync队列中，等到着获取锁。\",\"CANCELLED，值为1，表示当前的线程被取消\",\"SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark\",\"CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中\",\"PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行\"]},\"1491\":{\"h\":\"同步等待队列\",\"t\":[\"AQS当中的同步等待队列也称CLH队列，CLH队列是一种基于双向链表数据结构的队列，是FIFO先进先出线程等待队列，Java中的CLH队列是原CLH队列的一个变种，线程由原自旋机制改为阻塞机制。\",\"AQS依赖CLH同步队列来完成同步状态的管理：\",\"当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程\",\"当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态\",\"通过signal或signalAll将条件队列中的节点转移到同步队列（由条件队列转移到同步队列）\"]},\"1492\":{\"h\":\"条件等待队列\",\"t\":[\"AQS中条件队列是使用单向列表保存的，用nextWaiter来连接：\",\"调用await方法阻塞线程\",\"当前线程存在于同步队列的头结点，调用await方法进行阻塞（从同步队列转移到条件队列）\"]},\"1493\":{\"h\":\"Condition接口\",\"t\":[\"调用Condition#await方法会释放当前持有的锁，然后阻塞当前线程，同时向Condition队列尾部添加一个节点，所以调用Condition#await方法的时候必须持有锁\",\"调用Condition#signal方法会将Condition队列的首节点移动到阻塞队列尾部，然后唤醒因调用Condition#await方法而阻塞的线程（唤醒之后这个线程就可以去竞争锁了），所以调用Condition#signal方法的时候必须持有锁，持有锁的线程唤醒被因调用Condition#await方法而阻塞的线程\"]},\"1494\":{\"h\":\"ReentrantLock详解\",\"t\":[\"ReentrantLock是一种互斥锁，相比于synchronized，ReentrantLock具备如下特点：\",\"可中断\",\"可以设置超时时间\",\"可以设置为公平锁\",\"支持多个条件变量\",\"与synchronized一样，都支持可重入\",\"我们主要的关注点：\",\"ReentrantLock加锁解锁的逻辑\",\"公平和非公平，可重入锁的实现\",\"线程竞争锁失败入队阻塞逻辑和获取锁的线程释放锁唤醒阻塞线程竞争锁的逻辑实现\",\"完成的流程图：https://www.processon.com/view/link/6191f070079129330ada1209\"]},\"1495\":{\"h\":\"synchronized和ReentrantLock\",\"t\":[\"synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现；\",\"synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过ReentrantLock#isLocked判断；\",\"synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；\",\"synchronized是不可以被中断的，而ReentrantLock#lockInterruptibly方法是可以被中断的；\",\"在发生异常时synchronized会自动释放锁，而ReentrantLock需要开发者在finally块中显示释放锁；\",\"ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock(),以及等待指定时长的获取，更加灵活；\",\"synchronized在特定的情况下对于已经在等待的线程是后来的线程先获得锁（回顾一下sychronized的唤醒策略），而ReentrantLock对于已经在等待的线程是先来的线程先获得锁；\"]},\"1496\":{\"h\":\"Semaphore与CountDownLatch\",\"t\":[\"Semaphore，俗称信号量，它是操作系统中PV操作的源语在Java中的实现，它也是基于AQS来实现的。\",\"Semaphore可以用于做流量控制，特别是公共资源有限的应用场景。\",\"Semaphore与ReentantLock的逻辑实现区别在于Semaphore是共享锁。\",\"共享锁的模式，会一直尝试唤醒后续节点。\",\"CyclicBarrier与CountDownLatch的区别：\",\"CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次\",\"CyclicBarrier是通过ReentranLock的“独占锁”和Condition来实现一组线程的阻塞唤醒的，而CountDownLatch则是通过AQS的“共享锁”实现\"]},\"1497\":{\"h\":\"CylicBarrier实现原理\"},\"1498\":{\"h\":\"ReentrantReadWriteLock\",\"t\":[\"在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源（读读可以并发）；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写操作了（读写，写读，写写互斥）。在读多写少的情况下，读写锁能够提供比拍他锁更好的并发性和吞吐量。\",\"针对这种场景，Java并发包提供了读写锁ReentrantReadWriteLock，在它内部，维护了一对相关的锁，一个用于只读操作；一个用于写入操作，成为写锁。\",\"线程进入读锁的前提条件：\",\"没有其他线程的写锁\",\"没有写请求或者有写请求，但是调用线程和持有锁的线程是同一个\",\"线程进入写锁的前提条件：\",\"没有其他线程的读锁\",\"没有其他线程的写锁\",\"读写锁有一下三个重要的特性：\",\"公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平\",\"可重入：读锁和写锁都支持线程重入。读线程获取读锁后，能够再次获取读锁。写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁\",\"锁降级：遵循获取写锁、再获取读锁最后释放写锁的次序，写锁能够降级成为读锁\",\"ReentrantReadWriteLock是可重入的读写锁实现类。在它内部，维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有Writer线程，读锁可以由多个Reader线程同时持有。也就是说，写锁是独占的，读锁是共享的。\",\"锁降级中的读锁获取是否必要呢？必要，这样做的目的是为了保证数据的可见性。如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记为线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到线程使用的数据并释放读锁之后，线程T才能获取写锁进行数据更新。\",\"ReentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的也是保证数据的可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其对其他获取到读锁的线程是不可见的。\",\"悲观锁：考虑最坏的场景，为了保证线程安全，每次操作都会上锁；\",\"乐观锁的例子：\",\"select count, version from table where id = ? version = 100; update table set count = count - 1, version = version + 1 where id = ? and version = 100; \",\"此时假设有三个线程同时执行这条更新语句：\",\"# T1 操作 update success 返回值为1，version此时为101 # T2 操作 update success 返回值为0，这意味着加锁失败，返回的成功的行数值可以作为加锁成功的依据，可以在业务逻辑里面判断是否返回0 # T3操作 update 成功 返回值为0 \",\"乐观锁又被称为无锁算法。\",\"JDK乐观锁的实现：java.util.concurrent.locks.StampedLock。\"]},\"1499\":{\"h\":\"BlockingQueue实现原理\",\"t\":[\"阻塞队列的总结：https://www.processon.com/view/link/618ce3941e0853689b0818e2\"]},\"1500\":{\"h\":\"Queue队列\",\"t\":[\"public interface Queue<E> extends Collection<E> { //添加一个元素，添加成功返回true, 如果队列满了，就会抛出异常 boolean add(E e); //添加一个元素，添加成功返回true, 如果队列满了，返回false boolean offer(E e); //返回并删除队首元素，队列为空则抛出异常 E remove(); //返回并删除队首元素，队列为空则返回null E poll(); //返回队首元素，但不移除，队列为空则抛出异常 E element(); //获取队首元素，但不移除，队列为空则返回null E peek(); } \"]},\"1501\":{\"h\":\"BlockingQueue\",\"t\":[\"BlockingQueue和JDK集合包中的Queue接口兼容，同时在其基础上增加了阻塞功能。\",\"入队：\",\"（1）offer(E e)：如果队列没满，返回true，如果队列已满，返回false（不阻塞）\",\"（2）offer(E e, long timeout, TimeUnit unit)：可以设置阻塞时间，如果队列已满，则进行阻塞。超过阻塞时间，则返回false\",\"（3）put(E e)：队列没满的时候是正常的插入，如果队列已满，则阻塞，直至队列空出位置\",\"出队：\",\"（1）poll()：如果有数据，出队，如果没有数据，返回null （不阻塞）\",\"（2）poll(long timeout, TimeUnit unit)：可以设置阻塞时间，如果没有数据，则阻塞，超过阻塞时间，则返回null\",\"（3）take()：队列里有数据会正常取出数据并删除；但是如果队列里无数据，则阻塞，直到队列里有数据\",\"当队列满了无法添加元素，或者是队列空了无法移除元素时：\",\"抛出异常：add、remove、element\",\"返回结果但不抛出异常：offer、poll、peek\",\"阻塞：put、take\",\"方法\",\"抛出异常\",\"返回特定值\",\"阻塞\",\"阻塞特定时间\",\"入队\",\"add(e)\",\"offer(e)\",\"put(e)\",\"offer(e, time, unit)\",\"出队\",\"remove()\",\"poll()\",\"take()\",\"poll(time, unit)\",\"获取队首元素\",\"element()\",\"peek()\",\"不支持\",\"不支持\",\"阻塞队列出了阻塞外还有一个非常重要的属性，那就是容量的大小，分为有界和无界两种。无界队列意味着里面可以容纳非常多的元素，例如LinkedBlockingQueue的上限是Integer.MAX_VALUE，是非常大的一个数，可以近似认为是无限容量，因为我们几乎无法把这个容量装满。但是有的阻塞队列是有界的，例如ArrayBlockingQueue如果容量满了，也不会扩容，所以一旦满了就无法再往里放数据了。\",\"public LinkedBlockingQueue() { this(Integer.MAX_VALUE); } \",\"BlockingQueue是线程安全的，我们在很多场景下都可以利用线程安全的队列来优雅地解决我们业务自身的线程安全问题。比如说，使用生产者/消费者模式的时候，我们生产者只需要从队列里取出它们就可以了，如图所示；\",\"因为阻塞队列是线程安全的，所以生产者和消费者都可以是多线程的，不会发生线程安全问题。生产者/消费者直接使用线程安全的队列就可以，而不需要自己去考虑更多的线程安全问题。这也就意味着，考虑锁等线程安全问题的重任从开发者转移到了“队列”上，降低了我们开发的难度和工作量。\",\"同时，队列它还能起到一个隔离的作用。比如说我们开发一个银行转账的程序，那么生产者不需要关心具体的转账逻辑，只需要把转帐任务，如账户和金额等信息放到队列中就可以，而不需要去关心银行这个类如何实现具体的转账业务。而作为银行这个类来讲，它会从队列里取出来将要执行的具体任务，再去通过自己的各种方式来完成本次转账。这样就实现了具体任务与执行任务类之间的结偶，任务被放在了阻塞队列中，而负责放任务的线程是无法直接访问到我们银行具体实现转账操作的对象的，实现了隔离，提高了安全性。\",\"常见的阻塞队列：\",\"队列\",\"描述\",\"ArrayBlockingQueue\",\"基于数组结构实现的一个有界阻塞队列\",\"LinkedBlockingQueue\",\"基于链表结构实现的一个有界阻塞队列\",\"PriorityBlockingQueue\",\"支持按优先级排序的无界阻塞队列\",\"DelayQueue\",\"基于优先级队列（PriorityBlockingQueue）实现的无界阻塞队列\",\"SynchronousQueue\",\"不存储元素的阻塞队列\",\"LinkedTransferQueue\",\"基于链表结构实现的一个无界阻塞队列\",\"LinkedBlockingDeque\",\"基于链表结构实现的一个双端阻塞队列\"]},\"1502\":{\"h\":\"ArrayBlockingQueue\",\"t\":[\"ArrayBlockingQueue是典型的有界阻塞队列，其内部是用数组存储元素的，初始化时需要指定容量大小，利用ReentrantLock实现线程安全。\",\"在生产者-消费者模型中使用时，如果生产速度和消费速度基本匹配的情况下，使用ArrayBlockingQueue是个不错的选择；当如果生产速度远远大于消费速度，则会导致队列填满，大量生产线程被阻塞。\",\"使用独占锁ReentrantLock实现线程安全，入队和出队操作使用同一个锁对象，也就是说只能有一个线程可以进行入队或者出队操作；这也就意味着生产者和消费者无法并行操作，在高并发场景下会成为性能瓶颈。\",\"数据结构如下：\",\"//数据元素数组 final Object[] items; //下一个待取出元素索引 int takeIndex; //下一个待添加元素索引 int putIndex; //元素个数 int count; //内部锁 final ReentrantLock lock; //消费者 private final Condition notEmpty; //生产者 private final Condition notFull; public ArrayBlockingQueue(int capacity) { this(capacity, false); } public ArrayBlockingQueue(int capacity, boolean fair) { ... lock = new ReentrantLock(fair); //公平，非公平 notEmpty = lock.newCondition(); notFull = lock.newCondition(); } \",\"入队put方法：\",\"public void put(E e) throws InterruptedException { //检查是否为空 checkNotNull(e); final ReentrantLock lock = this.lock; //加锁，如果线程中断抛出异常 lock.lockInterruptibly(); try { //阻塞队列已满，则将生产者挂起，等待消费者唤醒 //设计注意点： 用while不用if是为了防止虚假唤醒 while (count == items.length) notFull.await(); //队列满了，使用notFull等待（生产者阻塞） // 入队 enqueue(e); } finally { lock.unlock(); // 唤醒消费者线程 } } private void enqueue(E x) { final Object[] items = this.items; //入队 使用的putIndex items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; //设计的精髓： 环形数组，putIndex指针到数组尽头了，返回头部 count++; //notEmpty条件队列转同步队列，准备唤醒消费者线程，因为入队了一个元素，肯定不为空了 notEmpty.signal(); } \",\"出队操作：\",\"public E take() throws InterruptedException { final ReentrantLock lock = this.lock; //加锁，如果线程中断抛出异常 lock.lockInterruptibly(); try { //如果队列为空，则消费者挂起 while (count == 0) notEmpty.await(); //出队 return dequeue(); } finally { lock.unlock();// 唤醒生产者线程 } } private E dequeue() { final Object[] items = this.items; @SuppressWarnings(\\\"unchecked\\\") E x = (E) items[takeIndex]; //取出takeIndex位置的元素 items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; //设计的精髓： 环形数组，takeIndex 指针到数组尽头了，返回头部 count--; if (itrs != null) itrs.elementDequeued(); //notFull条件队列转同步队列，准备唤醒生产者线程，此时队列有空位 notFull.signal(); return x; } \",\"这里设计成环形链表的原因是基于效率的考量，这样，当去除takeIndex对应的元素之后，就不需要移动它后面的元素，而是直接移动takeIndex的指针，即takeIndex++，这样的话，删除元素的时间复杂度也变为了O(1)。\"]},\"1503\":{\"h\":\"LinkedBlockingQueue\",\"t\":[\"LinkedBlockingQueue是一个基于链表实现的阻塞队列，默认情况下，该阻塞队列的大小为Integer.MAX_VALUE，由于这个数值特别大，所以LinkedBlockingQueue也被称作无界队列，代表它几乎没有界限，队列可以随着元素的添加而动态增长，但是如果没有剩余内存，则队列抛出OOM错误。所以为了避免队列过大造成机器负载或者内存爆满的情况出现，我们在使用的时候建议手动传一个队列的大小。\",\"LinkedBlockingQueue内存由单链表实现，只能从head取元素，从tail添加元素。LinkedBlockingQueue采用两把锁的锁分离技术实现入队出队互不阻塞，添加元素和获取元素都有独立的锁，也就是说LinkedBlockingQueue是读写分离的，读写操作可以并发执行。\",\"LinkedBlockingQueue使用：\",\"//指定队列的大小创建有界队列 BlockingQueue<Integer> boundedQueue = new LinkedBlockingQueue<>(100); //无界队列 BlockingQueue<Integer> unboundedQueue = new LinkedBlockingQueue<>(); \",\"数据结构：\",\"// 容量,指定容量就是有界队列 private final int capacity; // 元素数量 private final AtomicInteger count = new AtomicInteger(); // 链表头 本身是不存储任何元素的，初始化时item指向null transient Node<E> head; // 链表尾 private transient Node<E> last; // take锁 锁分离，提高效率 private final ReentrantLock takeLock = new ReentrantLock(); // notEmpty条件 // 当队列无元素时，take锁会阻塞在notEmpty条件上，等待其它线程唤醒 private final Condition notEmpty = takeLock.newCondition(); // put锁 private final ReentrantLock putLock = new ReentrantLock(); // notFull条件 // 当队列满了时，put锁会会阻塞在notFull上，等待其它线程唤醒 private final Condition notFull = putLock.newCondition(); //典型的单链表结构 static class Node<E> { E item; //存储元素 Node<E> next; //后继节点 单链表结构 Node(E x) { item = x; } } \",\"构造器：\",\"public LinkedBlockingQueue() { // 如果没传容量，就使用最大int值初始化其容量 this(Integer.MAX_VALUE); } public LinkedBlockingQueue(int capacity) { if (capacity <= 0) throw new IllegalArgumentException(); this.capacity = capacity; // 初始化head和last指针为空值节点 last = head = new Node<E>(null); } \",\"入队put方法：\",\"public void put(E e) throws InterruptedException { // 不允许null元素 if (e == null) throw new NullPointerException(); int c = -1; // 新建一个节点 Node<E> node = new Node<E>(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; // 使用put锁加锁 putLock.lockInterruptibly(); try { // 如果队列满了，就阻塞在notFull上等待被其它线程唤醒（阻塞生产者线程） while (count.get() == capacity) { notFull.await(); } // 队列不满，就入队 enqueue(node); c = count.getAndIncrement();// 队列长度加1，返回原值 // 如果现队列长度小于容量，notFull条件队列转同步队列，准备唤醒一个阻塞在notFull条件上的线程(可以继续入队) // 这里为啥要唤醒一下呢？ // 因为可能有很多线程阻塞在notFull这个条件上,而取元素时只有取之前队列是满的才会唤醒notFull,此处不用等到取元素时才唤醒 if (c + 1 < capacity) notFull.signal(); } finally { putLock.unlock(); // 真正唤醒生产者线程 } // 如果原队列长度为0，现在加了一个元素后立即唤醒阻塞在notEmpty上的线程 if (c == 0) signalNotEmpty(); } private void enqueue(Node<E> node) { // 直接加到last后面,last指向入队元素 last = last.next = node; } private void signalNotEmpty() { final ReentrantLock takeLock = this.takeLock; takeLock.lock();// 加take锁 try { notEmpty.signal();// notEmpty条件队列转同步队列，准备唤醒阻塞在notEmpty上的线程 } finally { takeLock.unlock(); // 真正唤醒消费者线程 } \",\"出队方法：\",\"public E take() throws InterruptedException { E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; // 使用takeLock加锁 takeLock.lockInterruptibly(); try { // 如果队列无元素，则阻塞在notEmpty条件上（消费者线程阻塞） while (count.get() == 0) { notEmpty.await(); } // 否则，出队 x = dequeue(); c = count.getAndDecrement();//长度-1，返回原值 if (c > 1)// 如果取之前队列长度大于1，notEmpty条件队列转同步队列，准备唤醒阻塞在notEmpty上的线程，原因与入队同理 notEmpty.signal(); } finally { takeLock.unlock(); // 真正唤醒消费者线程 } // 为什么队列是满的才唤醒阻塞在notFull上的线程呢？ // 因为唤醒是需要加putLock的，这是为了减少锁的次数,所以，这里索性在放完元素就检测一下，未满就唤醒其它notFull上的线程, // 这也是锁分离带来的代价 // 如果取之前队列长度等于容量（已满），则唤醒阻塞在notFull的线程 if (c == capacity) signalNotFull(); return x; } private E dequeue() { // head节点本身是不存储任何元素的 // 这里把head删除，并把head下一个节点作为新的值 // 并把其值置空，返回原来的值 Node<E> h = head; Node<E> first = h.next; h.next = h; // 方便GC head = first; E x = first.item; first.item = null; return x; } private void signalNotFull() { final ReentrantLock putLock = this.putLock; putLock.lock(); try { notFull.signal();// notFull条件队列转同步队列，准备唤醒阻塞在notFull上的线程 } finally { putLock.unlock(); // 解锁，这才会真正的唤醒生产者线程 } \",\"LinkedBlockingQueue的总结：\"]},\"1504\":{\"h\":\"LinkedBlockingDeque\",\"t\":[\"LinkedBlockingDeque的总结：\"]},\"1505\":{\"h\":\"SynchronousQueue\",\"t\":[\"SynchronousQueue非常适合传递性场景做交换工作，生产者的线程和消费者的线程同步传递某些信息、事件或者任务。\"]},\"1506\":{\"h\":\"PriorityBlockingQueue\",\"t\":[\"优先级队列采用二叉堆的数据结构。\",\"大顶堆和小顶堆：\",\"大顶堆：父结点的键值总是大于或等于任何一个子结点的键值\",\"小顶堆：父结点的键值总是小于或等于任何一个子结点的键值\",\"扩容的算法：\",\"int newCap = oldCap + ((oldCap < 64) ? (oldCap + 2) : (oldCap >> 1)); \",\"构造小顶堆的方法：\",\" private static <T> void siftUpComparable(int k, T x, Object[] es) { Comparable<? super T> key = (Comparable<? super T>) x; while (k > 0) { int parent = (k - 1) >>> 1; Object e = es[parent]; if (key.compareTo((T) e) >= 0) break; es[k] = e; k = parent; } es[k] = key; } \"]},\"1507\":{\"h\":\"LinkedTransferQueue\"},\"1508\":{\"h\":\"DelayQueue\"},\"1509\":{\"h\":\"如何选择合适的阻塞队列\",\"t\":[\"通常我们可以从以下5个角度考虑，来选择合适的阻塞队列：\",\"功能：首先需要考虑的就是功能层面，比如是否需要阻塞队列帮我们排序，如优先级队列、延迟执行等。如果有这个需要，我们就必须选择类似于PriorityBlockingQueue之类的有序排序能力的阻塞队列\",\"容量：其次要 考虑的是容量，或者说是否有存储的要求，还是只需要“直接传递”。在考虑这一点的时候，我们知道前面介绍的那几种阻塞队列，有的是容量固定的，如ArrayBlockingQueue；有的默认是容量无限的，如LinkedBlockingQueue；而有的里面没有任何容量，如SynchronousQueue；而对于DelayQueue而言，它的容量固定就是Integer.MAX_VALUE。所以不同阻塞队列的容量是千差万别的，我们需要根据任务数量来推算出合适的容量，从而去选择合适的BlockingQueue\",\"能否扩容：接着要考虑的就是能否扩容，因为有时我们并不能在出事的时候很好的准确估计队列的大小，因为业务可能有高峰期、低谷期。如果一开始就固定一个容量，可能无法应对所有的情况，也是不合适的，有可能需要动态扩容。如果我们需要动态扩容的话，那么就不能选择ArrrayBlockingQueue，因为它的容量在创建时就确定了，无法扩容。相反，PriorityBlockingQueue即使在指定了初始容量之后，后续如果有需要，也可以自动扩容。所以我们可以根据是否需要扩容来选择合适的队列\",\"内存结构：相对使用数组实现的阻塞队列，使用链表实现需要额外的“节点”，因此空间利用率更高\",\"性能：最后一点是从性能的角度去考虑，比如LinkedBlockingQueue，由于拥有两把锁，它的操作力度更细，在并发程度高的时候，相对于只有一把锁的ArrayBlockingQueue性能会更好。另外，SynchronousQueue性能往往优于其他实现，因为它只需要“直接传递”，而不需要存储过程。如果我们的场景需要直接传递的话，可以优先考虑SynchronousQueue\"]},\"1510\":{\"h\":\"ForkJoin实现原理\",\"t\":[\"任务类型：\",\"CPU密集型任务\",\"IO密集型任务\",\"CPU密集型任务也叫计算密集型任务，比如加密、解密、压缩、计算等一系列需要大量耗费CPU资源的任务。对于这样的任务最佳的线程数为CPU核心数的1～2倍，如果设置过多的线程数，实际上并不会起到很好的效果。此时假设我们设置的线程数量是CPU核心数的2倍以上，因为计算任务非常重，会占用大量的CPU资源，所以这时CPU的每个核心工作基本都是满负荷的，而我们又设置了过多的线程，每个线程都想去利用CPU资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。\",\"IO密集型任务，比如数据库、文件的读写，网络通信等任务，这种任务的特点是并不会特别消耗CPU资源，但是IO操作很耗时，总体会占用比较多的时间。对于这种任务最大线程数一般会大于CPU核心数很多倍，因为IO读写速度相比于CPU的速度是比较慢的，如果我们设置过少的线程数，就可能导致CPU资源的浪费。而如果我们设置更多的线程数，那么当一部分线程正在等待IO的时候，它们此时并不需要CPU来计算，那么另外的线程边可以利用CPU去执行其他的任务，互不影响，这样的话在工作队列中等待的任务就会减少，可以更好地利用资源。\",\"线程数计算方法：线程数=CPU核心线程数∗（1+平均等待时间/平均工作时间）。\",\"这个公式的含义是，如果任务的平均等待时间长，线程数就随之增加，而如果平均工作时间长，也就是对于CPU密集型任务，线程数就随之减少。\",\"太少的线程数会使得程序整体性能降低，而过多的线程的也会消耗内存等其他资源。\",\"ForkJoin的基本思想是分治：\",\"分解：将要解决的问题划分为若干规模较小的同类问题\",\"求解：当子问题划分得足够小时，用较简单的方法解决\",\"合并：按原问题的要求，将子问题的解逐层合并构成原问题的解\",\"传统线程池ThreadPoolExecutor有两个明显的缺点：一是无法对大任务进行拆分，对于某些任务只能单线程执行；二是工作线程从队列中获取任务时存在竞争情况。这两个缺点都会影响任务的执行效率。为了解决传统线程池的缺陷，Java7中引入了Fork/Join框架，并在Java8中得到广泛应用。Fork/Join框架的核心是ForkJoinPool类，它是对AbstractExecutorService类的扩展。ForkJoinPool允许其他线程向它提交任务，并根据设定将这些任务拆分为粒度更细的子任务，这些子任务将由ForkJoinPool内部的工作线程来并行执行，并且工作线程之间可以窃取彼此之间的任务。\",\"ForkJoinPool最适合计算密集型任务，而且最好是非阻塞任务。ForkJoinPool是ThreadPoolExecutor线程池的一种补充，是对计算密集型场景的加强。\",\"根据经验和实验，任务总数，单任务执行耗时以及并行数都会影响到Fork/Join的性能。所以，当使用Fork/Join框架时，需要谨慎评估这三个指标，最好能通过模拟对比评估，不要冒然在生产环境中使用。\",\"ForkJoinPool中有四个核心参数，用于控制线程池的并行数、工作线程的创建、异常处理和模式指定。各种参数解释如下：\",\"int parallelism：\",\"ForkJoinWorkerThreadFactory factory：\",\"UncaughtExceptionHandler handler：指定异常处理器，当任务在运行中出错时，将由设定的处理器处理\",\"boolean asyncMode：设置队列的工作模式：asyncMode？FIDO_QUEUE:LIFO_QUEUE。\",\"ForkJoinPool多个线程，每个线程维护一个队列workQueue。\"]},\"1511\":{\"h\":\"工作窃取\",\"t\":[\"ForkJoinPool与ThreadPoolExecutor有个很大的不同之处在于，ForkJoinPool引入了工作窃取设计，它是性能保证的关键之一。工作窃取，就是允许空闲线程从繁忙的双端队列中窃取任务。默认情况下，工作线程从它自己的双端队列的头部获取任务。但是，当自己的任务为空时，线程会从其他繁忙线程双端队列的尾部中获取任务。这种方法，最大限度地减少了线程竞争任务的可能性。\"]},\"1512\":{\"h\":\"工作队列\"},\"1513\":{\"h\":\"ForkJoinWorkThread\",\"t\":[\"ForkJoinWorkThread是用于执行任务的线程，用于区别使用非ForkJoinWorkThread线程提交task，启动一个该Thread，会自动注册一个WorkQueue到Pool，拥有Thread的WorkQueue只能出现在WorkQueues[]的奇数位。\"]},\"1514\":{\"h\":\"原理分析\",\"t\":[\"ForkJoin是一种基于分治算法的模型，在并发处理计算型任务时有着显著的优势。其效率的提升主要得益于两个方面：\",\"任务切分：将大的任务分割为更小力度的小任务，让更多的线程参与执行\",\"任务窃取：通过任务窃取，充分地利用空闲线程，并减少竞争\"]},\"1515\":{\"h\":\"CompletableFuture实现原理\"},\"1516\":{\"h\":\"Future\",\"t\":[\"Future的局限性：\",\"并发执行多任务：Future只提供了get()方法来获取结果，并且是阻塞的。所以，除了等待没有其他方式\",\"无法对多个任务进行链式调用：如果希望在计算任务完成后执行特定动作，比如发邮件，但Future没有提供这样的能力\",\"无法组合多个任务：如果运行了10个任务，并期望它们全部执行结束后执行特定动作，那么在Future也没有办法做到\",\"没有异常处理：Future接口中没有关于异常处理的方法\"]},\"1517\":{\"h\":\"CompletionService\",\"t\":[\"CompletionService内部通过阻塞队列+FutureTask，实现了任务先完成可以优先获取到，即记过按照完成先后顺序排序，内部有一个先进先出的阻塞队列，用于保存已经执行完成的Future，通过调用它的take方法或poll方法可以获取到一个已经执行完成的Future，进而通过调用Future接口实现类的get方法获取最终的结果。\",\"使用场景：向不同的电商平台询价，并保存价格。\",\"假设我们采用线程池+Future的方案，异步执行询价然后再保存：\",\"// 创建线程池 ExecutorService executor = Executors.newFixedThreadPool(3); // 异步向电商S1询价 Future<Integer> f1 = executor.submit(()->getPriceByS1()); // 异步向电商S2询价 Future<Integer> f2= executor.submit(()->getPriceByS2()); // 获取电商S1报价并异步保存 executor.execute(()->save(f1.get())); // 获取电商S2报价并异步保存 executor.execute(()->save(f2.get()); \",\"如果获取电商s1报价的耗时很长，那么即便获取电商s2报价的耗时很短，也无法让保存s2报价的操作先执行，因为这个线程都阻塞在了f1.get()操作上。\",\"使用CompetionService实现先获取的报价先保存到数据库：\",\"//创建线程池 ExecutorService executor = Executors.newFixedThreadPool(10); //创建CompletionService CompletionService<Integer> cs = new ExecutorCompletionService<>(executor); //异步向电商S1询价 cs.submit(() -> getPriceByS1()); //异步向电商S2询价 cs.submit(() -> getPriceByS2()); //异步向电商S3询价 cs.submit(() -> getPriceByS3()); //将询价结果异步保存到数据库 for (int i = 0; i < 3; i++) { Integer r = cs.take().get(); executor.execute(() -> save(r)); } \",\"如果我们只需要最快的那一个结果，就可以：\",\"// 创建线程池 ExecutorService executor = Executors.newFixedThreadPool(3); // 创建CompletionService CompletionService<Integer> cs = new ExecutorCompletionService<>(executor); // 用于保存Future对象 List<Future<Integer>> futures = new ArrayList<>(3); //提交异步任务，并保存future到futures futures.add(cs.submit(()->geocoderByS1())); futures.add(cs.submit(()->geocoderByS2())); futures.add(cs.submit(()->geocoderByS3())); // 获取最快返回的任务执行结果 Integer r = 0; try { // 只要有一个成功返回，则break for (int i = 0; i < 3; ++i) { r = cs.take().get(); //简单地通过判空来检查是否成功返回 if (r != null) { break; } } } finally { //取消所有任务 for(Future<Integer> f : futures) f.cancel(true); } // 返回结果 \",\"Dubbo中有一种叫做Forking的集群模式，这种集群模式下，支持并行地调用度多个服务实例，只要有一个成功就返回结果。\",\"geocoder(addr) { //并行执行以下3个查询服务， r1=geocoderByS1(addr); r2=geocoderByS2(addr); r3=geocoderByS3(addr); //只要r1,r2,r3有一个返回 //则返回 return r1|r2|r3; } \",\"CompletionService的应用场景总结：\",\"当需要批量提交异步任务的时候建议使用CompletionService，CompletionService将线程池和阻塞队列BlockingQueue的功能融合在了一起，能够让批量异步任务的管理更简单\",\"CompletionService能够让异步任务的执行结果有序化。先执行完的先进入阻塞队列，利用这个特性，可以轻松实现后续处理的有序性\",\"线程池隔离：CompletionService支持自己创建线程池，这种隔离性能避免几个特别耗时的任务拖垮整个应用的风险。\"]},\"1518\":{\"h\":\"CompletableFuture\",\"t\":[\"简单的任务，用Future获取结果还好，但是并行提交多个异步任务，往往并不是独立的，很多时候业务逻辑处理存在串行[依赖]、并行、聚合的关系。如果要我们手动用Future实现，是非常麻烦的。\",\"CompletableFuture是Future接口的扩展和增强。CompletableFuture实现了Future接口，并在此基础上进行了丰富地扩展，完美地弥补了Future上述的种种问题，更为重要的是，CompletableFuture实现了对任务的编排能力。借助这项能力，我们可以轻松地组织不同任务的运行顺序、规则以及方式。从某种程度上说，这项能力是它的核心能力。而在以往，虽然通过CountDownLatch等工具类也可以实现任务的编排，但需要复杂的逻辑处理，不仅耗费精力且难以维护。\",\"CompletionStage接口：执行某一个阶段，可向下执行后续阶段。异步执行，默认线程池是ForkJoinPool.commonPool()。\",\"应用场景：\",\"描述依赖关系\",\"thenApply()：把前面异步任务的结果，交给后面的Function\",\"thenCompose()：用来连接两个有依赖关系的任务，结果由第二个任务返回\",\"描述and聚合关系\",\"thenCombine：任务合并，有返回值\",\"thenAcceptBoth：两个任务执行完成后，将结果交给thenAcceptBoth消耗，无返回值\",\"runAfterBothEither：两个任务都执行完成后，执行下一步操作（Runnable）\",\"描述or聚合关系\",\"applyToEither：两个任务谁执行的快，就使用那一个结果，有返回值\",\"acceptEither：两个任务谁执行的快，就消耗那一个结果，无返回值\",\"runAfterEither：任意一个任务执行完成，进行下一步操作\",\"并行执行\",\"CompletableFuture类自己也提供了anyOf()和allOf用于支持多个CompletableFuture并行执行\",\"常用方法总结：\"]},\"1519\":{\"h\":\"高性能队列Disruptor\",\"t\":[\"Disruptor是一个高性能的队列，研发的初衷是为了解决内存队列的延迟问题，基于Disruptor开发的系统但线程能支撑每秒600万订单。目前Apache Storm、Camel、Log4j在内的很多知名项目都应用了Disruptor以获取高性能。注意，这里所说的队列是系统内存的内存队列，而不是Kafka这样的分布式队列。\",\"Disruptor本质上是一个有界队列，可以用于生产者-消费者模型。\",\"JUC下的队列大部分采用ReentrantLock锁的方式保证线程安全。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列。加锁的方式通常会严重影响性能，线程会因为竞争不到锁而被挂起，等待其他线程释放锁而唤醒，这个过程存在很大的开销，而且存在死锁的隐患。有界队列通常采用数组实现，但是采用数组实现引发另外一个问题false sharing（伪共享）。\",\"CPU缓存是以缓存行为最小数据单位，缓存行是2的整数幂个连续字节，主流大小是64个字节。如果多个变量同属于一个缓存行，在并发环境下同时修改，因为写屏障即内存一致性协议会导致同一时间只能一个线程操作该缓存行，进而因为竞争导致性能下降，这就是“伪共享”。“伪共享”是高并发场景下一个底层细节问题。\",\"Disruptor通过以下设计来解决队列速度慢的问题：\",\"环形数组结构\",\"为了避免垃圾回收，采用数组而非链表。同时，数组对于处理器的缓存机制更加友好（空间局部性原理）\",\"元素位置定位\",\"数组长度2n，通过位运算，加速定位的速度，下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完\",\"无锁设计\",\"每个生产者或消费者线程，会先申请可以操作的元素在数组中的问题，申请到之后，直接在该位置写入或者读取数据\",\"利用缓存行填充解决伪共享的问题\",\"实现了基于事件驱动的生产者消费者模型（观察者模式）\",\"消费者时刻关注着队列里有没有消息，一旦有新消息产生，消费者线程就会立刻消费。\"]},\"1520\":{\"h\":\"RingBuffer\",\"t\":[\"使用RingBuffer来作为队列的数据结构，RingBuffer就是一个可自定义大小的环形数组。除数组之外还有一个序列号（sequence），用以指向下一个可用的元素，供生产者与消费者使用，原理图如下所示：\",\"当需要覆盖数据时，会执行一个策略，Disruptor会提供多种策略，比较常用的有：\",\"BlockingWaitStrategy策略，常见且默认的等待测了，当这个队列满了，不执行覆盖，而是阻塞等待。使用ReentrantLock+Condition实现阻塞，最节省CPU，但高并发场景下性能最差。适合CPU资源紧缺，吞吐量和延迟并不重要的场景\",\"SleepingWaitStrategy策略，会在循环中不断等待数据。先进行自旋等待，如果不成功，则使用Thread.yield()并让出CPU，并最终使用LockSupport.parkNanos(1L)进行线程休眠，以确保不占用太多的CPU资源。因此这个策略会产生比较高的平均延时。典型的应用场景就是异步日志\",\"YieldingWaitStrategy策略，这个策略用于低延时的场合。消费者线程会不断地监控缓冲区变化，在循环内部使用Thread.yield()让出CPU给别的线程执行时间。如果需要一个高性能的系统，并且对延时有比较严格的要求，可以考虑这种策略。\",\"BusySpinWaitStrategy策略，采用死循环，消费者线程会尽最大努力监控缓冲区的变化。适用于对延时要求非常苛刻的场景，CPU核数大于消费者线程数量。推荐在线程绑定到固定的CPU的场景下使用\",\"Disruptor的核心概念：\",\"Disruptor的构造方法：\",\"public Disruptor( final EventFactory<T> eventFactory, final int ringBufferSize, final ThreadFactory threadFactory, final ProducerType producerType, final WaitStrategy WaitStrategy } \",\"EventFactory：创建事件（任务）的工厂类\",\"ringBufferSize：容器的长度\",\"ThreadFatory：用于创建执行任务的线程\",\"ProductType：生产者类型：单生产者、多生产者\",\"WaitStrategy：等待策略\"]},\"1521\":{\"h\":\"Disruptor实战\",\"t\":[\"使用案例：\",\"public class DisruptorDemo { public static void main(String[] args) throws Exception { //创建disruptor Disruptor<OrderEvent> disruptor = new Disruptor<>( OrderEvent::new, 1024 * 1024, Executors.defaultThreadFactory(), ProducerType.SINGLE, //单生产者 new YieldingWaitStrategy() //等待策略 ); //设置消费者用于处理RingBuffer的事件 disruptor.handleEventsWith(new OrderEventHandler()); //设置多消费者,消息会被重复消费 //disruptor.handleEventsWith(new OrderEventHandler(),new OrderEventHandler()); //设置多消费者,消费者要实现WorkHandler接口，一条消息只会被一个消费者消费 //disruptor.handleEventsWithWorkerPool(new OrderEventHandler(), new OrderEventHandler()); //启动disruptor disruptor.start(); //创建ringbuffer容器 RingBuffer<OrderEvent> ringBuffer = disruptor.getRingBuffer(); //创建生产者 OrderEventProducer eventProducer = new OrderEventProducer(ringBuffer); // 发送消息 for(int i=0;i<100;i++){ eventProducer.onData(i,\\\"Fox\\\"+i); } disruptor.shutdown(); } } \"]},\"1522\":{\"h\":\"并发设计模式\"},\"1523\":{\"h\":\"终止线程模式\"},\"1524\":{\"h\":\"两阶段终止模式\",\"t\":[\"两阶段终止模式，将终止过程分成两个阶段，其中第一个阶段主要是线程T1向线程T2发送终止指令，而第二阶段则是线程T2响应终止指令。\",\"Java线程进入终止状态的前提是线程进入RUNNABLE状态，而利用java线程中断机制的interrupt()方法，可以让线程从休眠状态转换到RUNNABLE状态。RUNNABLE状态转换到终止状态，优雅的方式是让Java线程自己执行完run()方法，所以一般我们采用的方法是设置一个标志位，然后线程会在合适的时机检查这个标志位，如果发现符合终止条件，则自动退出run()方法。\",\"两阶段终止模式是一种应用很广泛的并发设计模式，在Java语言中使用两阶段终止模式来优雅地终止线程，需要注意两个关键点：一个是仅检查终止标志位是不够的，因为线程的状态可能处于休眠态；另一个是仅检查线程的中断状态也是不够的，因为我们依赖的第三方库很可能没有正确处理中断一场，例如第三方库在捕获到Thread.sleep()方法抛出的中断异常后，没有重新设置线程的中断状态，那么就会导致线程不能够正常终止。所以我们可以自定义线程的终止标志位用于终止线程。\"]},\"1525\":{\"h\":\"避免共享的设计模式\"},\"1526\":{\"h\":\"Immutability模式\",\"t\":[\"Immutability模式即不变性模式，“多个线程同时读写同一共享变量存在并发问题”，这里的必要条件之一是读写，如果只有读，而没有写，是没有并发问题的。解决并发问题，其实最简单的办法是让共享变量只有读操作，而没有写操作，这种解决并发问题的设计模式被称为不变性模式。所谓不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化。换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。\",\"JDK中很多类都具备不变性，例如常用的String、Long、Integer和Double等基础类型的包装类都具备不可变性，这些对象的线程安全性都是靠不可变性来保证的。它们都严格遵守了不可变类的三点要求：类和属性都是final的，所有方法均是只读的。\",\"在使用不变性模式的时候，需要注意以下两点：\",\"对象的所有属性都是final的，并不能保证不可变性\",\"不可变对象也需要正确发布\",\"在使用不可变性模式的时候一定要确认保持不变性的边界在哪里，是否要求属性对象也具备不可变性。\",\"下面的代码中，Bar的属性foo虽然是final的，但是依然可以通过setAge()方法来设置foo的属性age。\",\"class Foo { int age=0; int name=\\\"abc\\\"; } final class Bar { final Foo foo; void setAge(int a){ foo.age=a; } \",\"可变对象虽然是线程安全的，但是并不意味着引用这些不可变对象的对象就是线程安全的。下面的代码中，Foo具备不可变性，线程安全，但是类Bar并不是线程安全的，类Bar中持有对Foo的引用foo，对foo这个引用的修改在多线程中并不能保证可见性和原子性。\",\"//Foo线程安全 final class Foo { final int age=0; final String name=\\\"abc\\\"; } //Bar线程不安全 class Bar { Foo foo; void setFoo(Foo f){ this.foo=f; } } \"]},\"1527\":{\"h\":\"Copy-on-Write模式\",\"t\":[\"写时复制模式。Java中的String在实现replace()方法的时候，并没有更改原字符串里面value[]数组的内容，而是创建了一个新字符串，这种方法在解决不可变对象的修改问题时经常用到。它本质上是一种Copy-on-Write方法。所谓Copy-on-Write，经常被缩写为COW，或者CoW。\",\"Copy-on-Write缺点就是消耗内存，每次修改都需要复制一个新的对象出来，好在随着自动垃圾回收（GC）算法的成熟以及硬件的发展，这种内存消耗已经渐渐可以接受了。所以在实际工作中，如果写操作非常少（读多写少的场景），可以尝试使用Copy-on-Write。\",\"在Java中，CopyOnWriteArrayList和CopyOnWriteArraySet这两个Copy-on-Write容器，它们背后的设计思想就是Copy-on-Write，通过Copy-on-Write这两个容器实现读操作是无锁的，由于无锁，所以将读操作的性能发挥到了极致。\",\"Copy-on-Write在操作系统领域中也有广泛的应用。类Unix的操作系统中创建进行的API是fork()，传统的fork()函数会创建父进程的一个完整副本，例如父进程的地址空间用到了1G的内存，那么fork()子进程的时候要复制父进程整个进程的地址空间（占有1G内存）给子进程，这个过程是很耗时的。而Linux中fork()子进程的时候，并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间；只有在父进程或者子进程需要写入的时候才会复制地址空间，从而使父子进程拥有各自的地址空间。\",\"Copy-on-Write最大的应用领域还是在函数式编程领域。函数式编程的基础是不可变性，所以函数式编程的所有的修改操作都需要Copy-on-Write来解决。\",\"像一些RPC框架还有服务注册中心，也会利用Copy-on-Write设计思想维护服务路由表。路由表是典型的读多写少，而且路由表对数据的一致性要求并不高，一个服务提供方从上线到反馈到客户端的路由表里，即便有5秒钟延迟，很多时候也是能够接受的。\"]},\"1528\":{\"h\":\"Thread-Specific Storage模式\",\"t\":[\"线程本地存储模式，即只有一个入口，也会在内部为每个线程分配持有的存储空间的模式。在Java中，ThreadLocal类实现了该模式。\",\"线程本地存储模式本质上就是一种避免共享的方法，由于没有共享，所以自然也就没有并发问题。如果需要在并发场景中使用一个线程不安全的工具类，最简单的方案就是避免共享。避免共享有两种方案，一种方案是将这个工具类作为局部变量使用，另外一种方案就是线程本地存储模式。这两种方案，局部变量方案的缺点是在高并发场景下会频繁创建对象，而线程本地存储方案，每个线程只需要创建一个工具类的实例，所以不存在频繁创建对象的问题。\",\"static class SafeDateFormat { //定义ThreadLocal变量 static final ThreadLocal<DateFormat> tl=ThreadLocal.withInitial( ()-> new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\")); static DateFormat get(){ return tl.get(); } } //不同线程执行下面代码，返回的df是不同的 DateFormat df = SafeDateFormat.get()； // 注意：在线程池中使用ThreadLocal 需要避免内存泄漏和线程安全的问题 ExecutorService es; ThreadLocal tl; es.execute(()->{ //ThreadLocal增加变量 tl.set(obj); try { // 省略业务逻辑代码 } finally { //手动清理ThreadLocal tl.remove(); } }); \"]},\"1529\":{\"h\":\"多线程版本的if模式\"},\"1530\":{\"h\":\"Guarded Suspension模式\",\"t\":[\"保护性暂停模式，是通过让线程等待来保护实例的安全性，即守护-挂起模式。在多线程开发中，常常为了提高应用程序的并发性，会将一个任务分解为多个子任务交给多分线程并行执行，而多个线程之间相互协作时，仍然会存在一个线程需要等待另外的线程完成后继续下一步操作。而保护性暂停模式可以帮助我们解决上述的等待问题。\",\"Guarded Suspension模式允许多个线程对实例资源进行访问，但是实例资源需要对资源的分配做出管理。\",\"Guarded Suspension模式也常被称为Guarded Wait模式、Spin Lock模式（因为使用了while循环去等待），也被称为多线程版本的if。\",\"有一个结果需要从一个线程传递到另一个线程，让它们关联同一个GuardedObject\",\"如果有结果不断从一个线程到另一个线程那么可以使用消息队列\",\"JDK中，join实现，Future的实现，采用的就是此模式\",\"等待唤醒机制规范实现，此模式依赖于Java线程的阻塞唤醒机制 \",\"sychronized+wait/notify/notifyAll\",\"ReentrantLock+Condition（await/singal/singalAll）\",\"cas+park/unpark\",\"阻塞唤醒机制机制底层原理：在linux操作系统中，pthread_mutex_lock/unlock，pthread_cond_wait/singal。\",\"解决线程之间的协作不可避免会用到阻塞唤醒机制。\"]},\"1531\":{\"h\":\"Balking模式\",\"t\":[\"Balking是“退缩不前”的意思。如果现在不适合执行这个操作，或者没必要执行这个操作，就停止处理，直接返回。当流程的执行顺序依赖于某个共享变量的场景，可以归纳为多线程if模式。Balking模式常用于一个线程发现另一个线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回。\",\"Balking模式一种多个线程执行同一操作A时可以考虑的模式；在某一个线程B被阻塞或者执行其他操作时，其他线程同样可以完成操作A，而当线程B恢复执行或者执行操作A时，因A已被执行，而无需线程B再执行，从而提高了B的执行效率。\",\"Balking模式和Guard Suspension模式一样，存在守护条件，如果守护条件不满足，则中断处理；这与Guard Suspension模式不同，Guard Suspension模式在守护条件不满足的时候会一直等待至可以运行，\",\"boolean changed=false; // 自动存盘操作 void autoSave(){ synchronized(this){ if (!changed) { return; } changed = false; } // 执行存盘操作 // 省略且实现 this.execSave(); } // 编辑操作 void edit(){ // 省略编辑逻辑 ...... change(); } // 改变状态 void change(){ synchronized(this){ changed = true; } } Balking 模式有一个非常典型的应用场景就是单次初始化。 boolean inited = false; synchronized void init(){ if(inited){ return; } //省略doInit的实现 doInit(); inited=true; } \"]},\"1532\":{\"h\":\"多线程分工模式\"},\"1533\":{\"h\":\"Thread-Per-Message模式\",\"t\":[\"一个线程处理一个任务，Thread-Per-Message 模式的一个最经典的应用场景是网络编程里服务端的实现，服务端为每个客户端请求创建一个独立的线程，当线程处理完请求后，自动销毁，这是一种最简单的并发处理网络请求的方法。\",\"final ServerSocketChannel ssc= ServerSocketChannel.open().bind(new InetSocketAddress(8080)); //处理请求 try { while (true) { // 接收请求 SocketChannel sc = ssc.accept(); // 每个请求都创建一个线程 new Thread(()->{ try { // 读Socket ByteBuffer rb = ByteBuffer.allocateDirect(1024); sc.read(rb); //模拟处理请求 Thread.sleep(2000); // 写Socket ByteBuffer wb = (ByteBuffer)rb.flip(); sc.write(wb); // 关闭Socket sc.close(); }catch(Exception e){ throw new UncheckedIOException(e); } }).start(); } } finally { ssc.close(); } \",\"Thread-Per-Message模式作为一种最简单的分工方案，Java中使用会存在性能缺陷。在Java中的线程是一个重量级的对象，创建成本很高，一方面创建线程比较耗时，另一方面线程占用的内存也比较大。所以为每个请求创建一个新的线程并不适合高并发场景。为了解决这个缺点，Java并发包里提供了线程池等工具类。\",\"在其他编程语言里，例如Go语言，基于轻量级线程实现Thread-Per-Message模式就完全没有问题。\",\"对于一些并发度没那么高的异步场景，例如定时任务，采用Thread-Per-Message模式是完全没有问题的。\"]},\"1534\":{\"h\":\"Worker Thread模式\",\"t\":[\"线程工厂模式，能避免线程频繁创建、销毁的问题，而且能够限制线程的最大数量。Java语言中可以直接使用线程池来实现Worker Thread模式。\",\"ExecutorService es = Executors.newFixedThreadPool(200); final ServerSocketChannel ssc = ServerSocketChannel.open().bind(new InetSocketAddress(8080)); //处理请求 try { while (true) { // 接收请求 SocketChannel sc = ssc.accept(); // 将请求处理任务提交给线程池 es.execute(()->{ try { // 读Socket ByteBuffer rb = ByteBuffer.allocateDirect(1024); sc.read(rb); //模拟处理请求 Thread.sleep(2000); // 写Socket ByteBuffer wb = (ByteBuffer)rb.flip(); sc.write(wb); // 关闭Socket sc.close(); }catch(Exception e){ throw new UncheckedIOException(e); } }); } } finally { ssc.close(); es.shutdown(); } \"]},\"1535\":{\"h\":\"生产者-消费者模式\",\"t\":[\"生产者-消费者模式的核心是一个任务队列，生产者线程生产任务，并将任务添加到任务队列中，而消费者线程从任务队列中获取任务并执行。\",\"public class Test { public static void main(String[] args) { // 生产者线程池 ExecutorService producerThreads = Executors.newFixedThreadPool(3); // 消费者线程池 ExecutorService consumerThreads = Executors.newFixedThreadPool(2); // 任务队列，长度为10 ArrayBlockingQueue<Task> taskQueue = new ArrayBlockingQueue<Task>(10); // 生产者提交任务 producerThreads.submit(() -> { try { taskQueue.put(new Task(\\\"任务\\\")); } catch (InterruptedException e) { e.printStackTrace(); } }); // 消费者处理任务 consumerThreads.submit(() -> { try { Task task = taskQueue.take(); } catch (InterruptedException e) { e.printStackTrace(); } }); } static class Task { // 任务名称 private String taskName; public Task(String taskName) { this.taskName = taskName; } } } \"]},\"1536\":{\"h\":\"过饱问题解决方案\",\"t\":[\"在实际生产项目中会有些极端的情况，导致生产者/消费者模式可能出现过饱的问题。单位时间内，生产者生产的速度大于消费者消费的速度，导致任务不断堆积到阻塞队列中，队列堆满只是时间问题。\",\"场景一：消费者每天能处理的量比生产者生产的少；如生产者每天1万条，消费者每天只能消费5千条。\",\"解决办法：消费者加机器\",\"原因：生产者没法限流，因为要一天内处理完，只能消费者加机器\",\"场景二：消费者每天能处理的量比生产者生产的多。系统高峰期生产者速度太快，把队列塞爆了\",\"解决办法：适当的加大队列\",\"原因：消费者一天的消费能力已经高于生产者，那说明一天之内肯定能处理完，保证高峰期别把队列塞满就好\",\"场景三：消费者每天能处理的量比生产者生产的多。条件有限或其他原因，队列没法设置特别大。系统高峰期生产者速度太快，把队列塞爆了\",\"解决办法：生产者限流\",\"原因：消费者一天的消费能力高于生产者，说明一天内能处理完，队列又太小，那只能限流生产者，让高峰期塞队列的速度慢点\"]},\"1537\":{\"h\":\"集合\"},\"1538\":{\"h\":\"集合的优点\",\"t\":[\"数组的缺点：\",\"长度开始时必须指定，而且一旦指定，不能更改\",\"保存的必须为同一类型的元素\",\"使用数组进行增加元素、删除元素、插入元素等相对复杂\",\"使用集合的好处：\",\"可以动态保存任意多个对象，使用比较方法\",\"提供了一系列方便操作对象的方法：add、remove、set、get等\",\"在Java中，集合主要分为两大类：单例集合和多列集合，其中单例集合有List、Set，双列集合有Map。\"]},\"1539\":{\"h\":\"单列集合\",\"t\":[\"核心API - java.util.List\",\"java.util.ArrayList\",\"java.util.Vector（线程安全）\",\"java.util.LinkedList\",\"核心API - java.util.Set\",\"java.util.HashSet\",\"java.util.TreeSet\"]},\"1540\":{\"h\":\"多列集合\",\"t\":[\"核心API - java.util.Map\",\"java.util.Hashtable\",\"java.util.HashMap\",\"java.util.TreeMap\"]},\"1541\":{\"h\":\"List\"},\"1542\":{\"h\":\"ArrayList源码分析\",\"t\":[\"核心特点：\",\"ArrayList中维护了一个Object类型的数组elementData：\",\"transient Object[] elementData; // non-private to simplify nested class access \",\"当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5倍\",\"如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍\",\"transient表示该属性不会被序列化。\"]},\"1543\":{\"h\":\"LinkedList源码分析\"},\"1544\":{\"h\":\"Map\",\"t\":[\"Map接口的不同实现之间的关系：\",\"具体实现类特点的说明：\",\"HashMap：它根据键的hashCode值缓存数据，大多数情况下可以直接定位它的值，因而具有很快的访问速度，但是遍历顺序却是不确定的。HashMap最多只允许一条记录的键位null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致，如果需要满足线程安全，可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap\",\"Hashtable：Hashtable是历史遗留类，官方建议使用HashMap替代它，与HashMap不同的是，它继承自Dictionary类，并且是线程安全的，如果需要在线程安全的场合下使用，建议使用ConcurrentHashMap\",\"LinkedHashMap：LinkedHashMap保存了记录的插入顺序，可以按照插入的顺序使用Iterator遍历\",\"TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排列，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap，在使用TreeMao的时候，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常\",\"对于上述四种类型的类，要求映射种的key是不可变对象。不可变对象可以保证该对象在创建后它的哈希值不会被改变，如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。\"]},\"1545\":{\"h\":\"HashMap原理分析\",\"t\":[\"HashMap是Java程序员使用频率最高的用于映射（键值对）处理的数据类型。JDK1.8对HashMap底层的实现进行了优化，例如引入了红黑树的数据结构和扩容优化等，因此，分析HashMap需要注意区别JDK1.7和JDK1.8的区别。\"]},\"1546\":{\"h\":\"存储方式\",\"t\":[\"从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加红黑树部分）实现的，如下图所示：\",\"在HashMap的底层存储实现上是存储在：\",\" transient Node<K,V>[] table; \",\"其中Node具体如下：\",\"static class Node<K,V> implements Map.Entry<K,V> { final int hash; //用来定位数组索引位置 final K key; V value; Node<K,V> next; //链表的下一个node Node(int hash, K key, V value, Node<K,V> next) { ... } public final K getKey(){ ... } public final V getValue() { ... } public final String toString() { ... } public final int hashCode() { ... } public final V setValue(V newValue) { ... } public final boolean equals(Object o) { ... } } \",\"Node是HashMap的一个内部类，实现了Map.Enrty接口，本质就是一个映射（键值对）。上图中每个黑色圆点就是一个Node对象。\",\"HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，HashMap就是采用了链地址法，即数组加链表的方式，在每个数组元素上都加上一个链表结构，当数据被Hash后，得到数组下标，把数据房子啊对应下标元素的链表上，例如程序执行如下代码：\",\"map.put(\\\"jycoder\\\",\\\"吉永超\\\"); \",\"系统将调用“jycoder”这个key的hashCode方法得到其哈希值，然后通过哈希算法的后两步运算（高位运算和取模运算）来定位该键值对的存储位置，有时两个key会定位到相同的问题，这个时候就发生了哈希碰撞。对于哈希算法而言，计算的结果越分散，哈希碰撞的概率就越小，Map的存取效率就会越高。\",\"如果哈希桶的数组很大，即使较差的哈希算法也会比较分散，如果哈希桶的数组很小，即使再好的哈希算法也会出现较多碰撞，所以就需要根据实际情况确定哈希桶数组的大小，并且在此基础上设计好的哈希算法来减少哈希碰撞。\",\"HashMap中有几个非常重要的属性：\",\"int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子 int modCount; // HashMap内部结构发生变化的次数 int size; // HashMap中实际存在的键值对数量 \",\"其中，Node[] table的初始长度length默认值是16，负载因子loadFactor默认值是0.75，threshold是HashMap所能容纳的最大数量的Node（键值对）的个数。它们之间的关系是：threshold=length∗loadFactor，也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数就越多。\",\"当超过threshold所能容纳的数量，HashMap就需要重新resize（扩容），扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的平衡选择，一般不要轻易修改，如果内存很多而又对时间效率要求很高，可以降低负载因子loadFactor的值；相反，如果内存紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。\",\"size这个字段的含义就是HashMap中实际存在的键值对数量，而modCount主要记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。这里的内部结构发生变化指的是强调的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖步属于结构变化。\",\"在HashMap中，哈希桶数组table的长度length大小必须为2n，HashMap采用这种设计，主要是为了取模和扩容时做优化，同时为了减少冲突，具体可以参考：关于hashMap的容量为什么是2的幂次方。定位哈希桶索引位置时，也加入例如高位参与运算的过程。\",\"不过，即使负载因子和哈希算法设计的再合理，也避免不了拉链过长的情况，一旦拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8中，对数据结构做了进一步的优化，引入了红黑树，当链表长度太长（默认超过8）时，链表就转换为了红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会运用到红黑树的插入、删除、查找等算法。具体可以参考红黑树。\"]},\"1547\":{\"h\":\"方法实现\"},\"1548\":{\"h\":\"确定哈希桶数组索引位置\",\"t\":[\"不管增加、删除、查找键值对，定位到哈希桶数组的都是很关键的第一步，前面提到过HashMap的数据结构是数组和链表的结合， 如果每个位置上的元素数量只有一个，那么当我们使用哈希算法求得这个位置的时候，马上就可以获取对应位置的元素，而不需要遍历整个链表。HashMap定位数组索引位置的方法，直接决定了哈希方法的离散性能，源码的实现如下：\",\"// 方法一 static final int hash(Object key) { //jdk1.8 & jdk1.7 int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h >>> 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } // 方法二 static int indexFor(int h, int length) { //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 return h & (length - 1); //第三步 取模运算，JDK1.8在计算位置的时候采用方法一返回的哈希值 & 长度-1 } \",\"可以发现，在JDK1.8中，哈希算法基本步骤就是三步：取key的hashCode值、高位运算、取模运算。\",\"对于任意给定的对象，只要它的hashCode方法返回值相同，那么程序调用方法所计算得到的Hash码值总是相同的。其中一种方式对将哈希值对数组长度取模运算，这样做的好处是元素的分布会相对来说比较均匀，但是，模运算的消耗还是比较大的。在HashMap中会调用方法二来计算对象应该保存在table数组的哪个索引处。\",\"这个方法非常巧妙，它通过h&(table.length-1)来得到该对象的保存位，而HashMap的长度length总是为2n，此时，h&(table.length-1)与h%length这两种运算结果式等价的，但是&比%具有更高的效率。\",\"假设容量为2的n次幂的化，那么table.length的二进制就是一个1后面n个0，而length - 1就是一个0后面n个1，那么在计算为了说明h & (table.length - 1)，由于length - 1的二进制前面都是0，相当于舍弃了高位，只保留了后面的n位，后面的n刚好在0到length之间，也就是等于h % length取余。\",\"在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高位异或低16位实现的：(h = k.hashcode())^(h >>> 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。\",\"下面举例说明，n位table的长度：\"]},\"1549\":{\"h\":\"put方法\",\"t\":[\"put方法的整体执行过程如下图：\",\"JDK1.8put方法的源代码如下：\",\" public V put(K key, V value) { // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node<K,V>[] tab; Node<K,V> p; int n, i; // 步骤1：table位空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 步骤2：计算index，并对null做处理 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node<K,V> e; K k; // 步骤3：节点key存在，直接value if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; // 步骤4：判断该链表为红黑树 else if (p instanceof TreeNode) e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); // 步骤5：该链为链表 else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 链表长度大于8转换为红黑树进行处理 if (binCount >= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; } // key已经存在直接覆盖value if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 步骤6：超过最大容量就扩容 if (++size > threshold) resize(); afterNodeInsertion(evict); return null; } \",\"详细说明如下：\",\"判断键值对数组table[i]是否为空或者为null，否则执行resize()进行扩容\",\"根据键值key计算hash值得到插入元素数组的索引i，如果table[i] == null，直接新建节点添加，转向步骤6，否则转向步骤3\",\"判断table[i]的首个元素是否和key一样，如果相同（hashCode && equals）直接覆盖value，否则转向步骤4\",\"判断table[i]是否为treeNode，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向步骤5\",\"遍历table[i]，判断链表的长度是否大于8，大于8的话就把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作，遍历过程中若发现key已经存在直接覆盖value即可\",\"插入成功后，判断实际存在的键值对数量size是否超过了最大容量，如果超过，就进行扩容操作\"]},\"1550\":{\"h\":\"扩容机制\",\"t\":[\"扩容就是重新计算容量。在向HashMap对象中不断地添加元素，而HashMap对象内部地数组无法装在更多地元素时，对象就需要扩大数组的长度，以便能装入更多的元素。\",\"JDK1.7中的扩容过程：\",\" void resize(int newCapacity) { //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; } Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 } \",\"newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上的新元素总会被放在链表的头部位置，这样先放一个索引上的元素会被放到Entry链的尾部（如果发生了哈希冲突的话），在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。\",\"下面通过具体的例子来说明扩容过程。假设我们所使用的哈希算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size等于2，所以key3、5、7，put顺序依次为5、7、3/在mod 2以后冲突都在table[1]这里了。这里假设负载因子loadFactor=1，即当键值对的实际大小size大于table的实际大小时进行扩容。接下来三个步骤时哈希桶数组resize成4，然后所有的Node重新rehash的过程。\",\"在JDK1.8中，由于融入了红黑树，相对而言就比较复杂：\",\" final Node<K,V>[] resize() { Node<K,V>[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { // 超过最大值就不再扩充 if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) newThr = oldThr << 1; // double threshold } else if (oldThr > 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 计算新的resize上限 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\\\"rawtypes\\\",\\\"unchecked\\\"}) Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; table = newTab; if (oldTab != null) { // 把每个bucket都移动到新的buckets中 for (int j = 0; j < oldCap; ++j) { Node<K,V> e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash & (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode<K,V>)e).split(this, newTab, j, oldCap); else { // 链表优化重hash的代码块 Node<K,V> loHead = null, loTail = null; Node<K,V> hiHead = null, hiTail = null; Node<K,V> next; do { next = e.next; // 原索引 if ((e.hash & oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } // 原索引 + oldCap else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } // 原索引 + oldCap放到bucket里 if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } \",\"JDK1.8中对扩容做了一些优化，经过观察可以发现，我们每次扩容都会将长度扩容为原来的2倍，所以，元素的位置要么是在原来的位置，要么就是在原位置再移动2次幂的位置。在下图中，n为table的长度，图（a）表示扩容前key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算的结果。\",\"元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit（红色），因此新的index就会发生这样的变化：\",\"因此，我们在扩充HashMap的时候，不再需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的哪个bit是1还是0就好了，是0就表示索引没有变化，是1就表示索引变成了“原索引+oldCap”，下图为16扩充至32的过程的示意图：\",\"这个设计非常的巧妙，既省去了重新计算hash值得时间，同时，由于新增的1bit是0还是1可以认为是随机的，因为resize的过程，均匀的把之前的冲突节点分散到新的bucket了。需要注意的是，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但从上图可以看出，JDK1.8不会倒置。\"]},\"1551\":{\"h\":\"线程安全性\",\"t\":[\"在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。HashMap线程不安全的主要原因是在多线程的使用场景下可能会造成死循环，如果多个线程同时put时，如果同时触发了rehash操作，会导致HashMap中的链表中出现循环节点，进而使得后面get的时候，会出现死循环。\",\"JDK1.7的示例如下：\",\"public class HashMapInfiniteLoop { private static HashMap<Integer,String> map = new HashMap<Integer,String>(2，0.75f); public static void main(String[] args) { map.put(5， \\\"C\\\"); new Thread(\\\"Thread1\\\") { public void run() { map.put(7, \\\"B\\\"); System.out.println(map); }; }.start(); new Thread(\\\"Thread2\\\") { public void run() { map.put(3, \\\"A); System.out.println(map); }; }.start(); } } \",\"其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个元素的时候，map就需要进行resize了。\",\"通过设置断点让线程1和线程2同时debug到transfer方法的首行，注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的Entry next = e.next，这一行，然后放开线程2的断点，让线程2进行resize，结果如下图：\",\"注意，Thread1的e指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。\",\"线程一被调度回来执行，先是执行newTable[i] = e，然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。\",\"e.next = newTable[i]导致key(3)指向了key(7)。注意：此时的key(7).next已经指向了key(3)，环形链表就这样出现了。\",\"此时，再对map做索引位置为3的get操作，就会死循环在这里，CPU成功达到100%，比如，调用map.get(11)，即会引起死循环，而且map中还丢失了元素，(5,“c”)也已经不再map中了。\",\"以上是JDK7的情况，JDK8虽然不会出现死循环的情况，但是会发生数据被覆盖的情况。\",\"https://zhuanlan.zhihu.com/p/76735726\"]},\"1552\":{\"h\":\"ConcurrentHashMap源码分析\"},\"1553\":{\"h\":\"JDK1.7的实现\",\"t\":[\"ConcurrentHashMap的成员变量中，包含了一个Segment的数组，Segment是ConcurrentHashMap的内部类，然后在Segment这个类中，包含了一个HashEntry数组，而HashEntry也是ConcurrentHashMap的内部类。HashEntry中，包含了key和value以及next指针（类似于HashMap中的Entry），所以HashEntry可以构成一个链表。\",\"简单来说，ConcurrentHashMap数据结构为一个Segment数组，Segment的数组结构为HashEntry的数组，而HashEntry存放的就是我们的键值对，可以构成链表，它们之间的关系如下图：\",\"它的put方法：\",\" public V put(K key, V value) { Segment<K,V> s; if (value == null) throw new NullPointerException(); // 二次哈希，以保证数据的分散性，避免哈希冲突 int hash = hash(key.hashCode()); int j = (hash >>> segmentShift) & segmentMask; // Unsafe 调用方式，直接获取相应的 Segment if ((s = (Segment<K,V>)UNSAFE.getObject // nonvolatile; recheck (segments, (j << SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false); } \",\"在put方法中，首先是通过二次哈希减小哈希冲突的可能性，根据hash值以Unsafe调用方式，直接获取响应的Segment，最终将数据添加到容器中是由segment对象的put方法来完成。Segment对象的put方法源代码如下：\",\"final V put(K key, int hash, V value, boolean onlyIfAbsent) { // 无论如何，确保获取锁 scanAndLockForPut会去查找是否有key相同Node ConcurrentHashMap.HashEntry<K,V> node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try { ConcurrentHashMap.HashEntry<K,V>[] tab = table; int index = (tab.length - 1) & hash; ConcurrentHashMap.HashEntry<K,V> first = entryAt(tab, index); for (ConcurrentHashMap.HashEntry<K,V> e = first;;) { // 更新已存在的key if (e != null) { K k; if ((k = e.key) == key || (e.hash == hash && key.equals(k))) { oldValue = e.value; if (!onlyIfAbsent) { e.value = value; ++modCount; } break; } e = e.next; } else { if (node != null) node.setNext(first); else node = new ConcurrentHashMap.HashEntry<K,V>(hash, key, value, first); int c = count + 1; // 判断是否需要扩容 if (c > threshold && tab.length < MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; } } } finally { unlock(); } return oldValue; } \",\"由于Segment对象本身就是一把锁，所以在新增数据的时候，相应的Segment对象块是被锁住的，其它线程并不能操作这个Segment对象，这样就保证了数据的安全性，在扩容的时候也是这样的，在JDK1.7中的ConcurrentHashMap扩容只是针对Segment对象中的HashEntry数组进行扩容，这个时候，由于Segment对象是一把锁，所以在rehash的过程中，其他线程无法对Segment的hash表做操作，这就解决了HashMap中由于put数据引起的闭环问题。\"]},\"1554\":{\"h\":\"JDK1.8的实现\",\"t\":[\"在容器的安全上，1.8中的ConcurrentHashMap放弃了JDK1.7的分段技术，而是采用了CAS机制 + synchronized来保证并发安全性，但是在ConcurrentHashMap实现里保留了Segment定义，这仅仅是为了保证序列化时的兼容性，并没有结构上的用处。\",\"在存储结构上，JDK1.8中ConcurrentHashMap放弃了HashEntry结构而是采用了跟HashMap结构非常相似，采用Node数组加链表（链表长度大于8的时候转为红黑树）的形式，Node节点设计如下：\",\"static class Node<K,V> implements Map.Entry<K,V> { final int hash; final K key; volatile V val; volatile Node<K,V> next; ...省略... } \",\"JDK1.8的ConcurrentHashMap的示意图如下：\",\"ConcurrentHashMap新增的核心方法有两个：putVal（新增）和transfer（扩容）。\",\"public V put(K key, V value) { return putVal(key, value, false); } \",\"可以看到put方法本身也是调用putVal方法：\",\" final V putVal(K key, V value, boolean onlyIfAbsent) { // 如果 key 为空，直接返回 if (key == null || value == null) throw new NullPointerException(); // 两次 hash ，减少碰撞次数 int hash = spread(key.hashCode()); // 记录链表节点得个数 int binCount = 0; // 无条件得循环遍历整个 node 数组，直到成功 for (ConcurrentHashMap.Node<K,V>[] tab = table;;) { ConcurrentHashMap.Node<K,V> f; int n, i, fh; // lazy-load 懒加载的方式，如果当前 tab 容器为空，则初始化 tab 容器 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 通过Unsafe.getObjectVolatile()的方式获取数组对应index上的元素，如果元素为空，则直接无所插入 else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { //// 利用CAS去进行无锁线程安全操作 if (casTabAt(tab, i, null, new ConcurrentHashMap.Node<K,V>(hash, key, value, null))) break; // no lock when adding to empty bin } // 如果 fh == -1 ，说明正在扩容，那么该线程也去帮扩容 else if ((fh = f.hash) == MOVED) // 协作扩容操作 tab = helpTransfer(tab, f); else { // 如果上面都不满足，说明存在 hash 冲突，则使用 synchronized 加锁。锁住链表或者红黑树的头结点，来保证操作安全 V oldVal = null; synchronized (f) { if (tabAt(tab, i) == f) { if (fh >= 0) {// 表示该节点是链表 binCount = 1; // 遍历该节点上的链表 for (ConcurrentHashMap.Node<K,V> e = f;; ++binCount) { K ek; //这里涉及到相同的key进行put就会覆盖原先的value if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } ConcurrentHashMap.Node<K,V> pred = e; if ((e = e.next) == null) {//插入链表尾部 pred.next = new ConcurrentHashMap.Node<K,V>(hash, key, value, null); break; } } } else if (f instanceof ConcurrentHashMap.TreeBin) {// 该节点是红黑树节点 ConcurrentHashMap.Node<K,V> p; binCount = 2; if ((p = ((ConcurrentHashMap.TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } // 插入完之后，判断链表长度是否大于8，大于8就需要转换为红黑树 if (binCount != 0) { if (binCount >= TREEIFY_THRESHOLD) treeifyBin(tab, i); // 如果存在相同的key ，返回原来的值 if (oldVal != null) return oldVal; break; } } } //统计 size，并且检测是否需要扩容 addCount(1L, binCount); return null; } \",\"详细说明：\",\"在ConcurrentHashMap中不允许key val字段为空，所以第一步先校验key value的值。key、val两个字段都不是null才继续往下走，否则直接抛出了NullPointerException异常，这是与HashMap有区别的地方，HashMap是可以允许为空的\",\"判断容器是否初始化，如果容器没有初始化，则调用initTable方法初始化\",\"initTable方法具体如下：\",\" /** * Initializes table, using the size recorded in sizeCtl. */ private final Node<K,V>[] initTable() { Node<K,V>[] tab; int sc; while ((tab = table) == null || tab.length == 0) { // 负数表示正在初始化或扩容，等待 if ((sc = sizeCtl) < 0) // 自旋等待 Thread.yield(); // lost initialization race; just spin // 执行 CAS 操作，期望将 sizeCtl 设置为 -1，-1 是正在初始化的标识 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { // CAS 抢到了锁 try { // 对 table 进行初始化，初始化长度为指定值，或者默认值 16 if ((tab = table) == null || tab.length == 0) { // sc 在初始化的时候用户可能会自定义，如果没有自定义，则是默认的 int n = (sc > 0) ? sc : DEFAULT_CAPACITY; // 创建数组 Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n]; table = tab = nt; // 指定下次扩容的大小，相当于 0.75 × n sc = n - (n >>> 2); } } finally { sizeCtl = sc; } break; } } return tab; } \",\"Table本质上就是一个Node数组，其初始化过程也就是对Node数组的初始化过程，方法中使用了CAS策略执行初始化操作。初始化流程为：\",\"判断sizeCtl值是否小于0，如果小于0表示ConcurrentHashMap正在执行初始化操作，所以需要先等待一会，如果其他线程初始化失败还可以顶替上去\",\"如果sizeCtl值大于等于0，则基于CAS策略抢占标记sizeCtl为-1，表示ConcurrentHashMap正在执行初始化，然后构造table，并更新sizeCtl的值\",\"初始化号table之后继续添加元素：\",\"根据双哈希之后的hash值找到数组对应的小标位置，如果该位置未存放节点，也就是说不存在哈希冲突，则使用CAS无锁的方法将数据添加到容器中，并且结束循环\",\"如果并未满足第三步，加入到扩容大军中（ConcurrentHashMap扩容采用的是多线程的方式），扩容时并未跳出死循环，这一点就保证了容器在扩容的时候并不会有其他的线程进行数据添加操作，这也保证了容器的安全性\",\"如果哈希冲突，则进行链表操作或者红黑树操作（如果链表树超过8，则修改链表为红黑树），在进行链表或者红黑树操作时，会使用synchronized锁把头结点锁住，保证了同时只有一个线程修改链表，防止出现链表成环\",\"进行addCount（1L，binCount）操作，该操作会更新size大小，判断是否需要扩容\",\"addCount方法的源码如下：\",\" // X传入的是1，check 传入的是 putVal 方法里的 binCount，没有hash冲突的话为0，冲突就会大于1 private final void addCount(long x, int check) { ConcurrentHashMap.CounterCell[] as; long b, s; // 统计ConcurrentHashMap里面节点个数 if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) { ConcurrentHashMap.CounterCell a; long v; int m; boolean uncontended = true; if (as == null || (m = as.length - 1) < 0 || (a = as[ThreadLocalRandom.getProbe() & m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) { fullAddCount(x, uncontended); return; } if (check <= 1) return; s = sumCount(); } // check就是binCount，binCount 最小都为0，所以这个条件一定会为true if (check >= 0) { ConcurrentHashMap.Node<K,V>[] tab, nt; int n, sc; // 这儿是自旋，需同时满足下面的条件 // 1. 第一个条件是map.size 大于 sizeCtl，也就是说需要扩容 // 2. 第二个条件是`table`不为null // 3. 第三个条件是`table`的长度不能超过最大容量 while (s >= (long)(sc = sizeCtl) && (tab = table) != null && (n = tab.length) < MAXIMUM_CAPACITY) { int rs = resizeStamp(n); // 该判断表示已经有线程在进行扩容操作了 if (sc < 0) { if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex <= 0) break; // 如果可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); } // 如果不在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2 else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs << RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); } } \",\"addCount 方法做了两个工作：\",\"对 map 的 size 加一\",\"检查是否需要扩容，或者是否正在扩容。如果需要扩容，就调用扩容方法，如果正在扩容，就帮助其扩容。\",\"最后是ConcurrentHashMap的扩容过程：\"]},\"1555\":{\"h\":\"HashTable源码分析\",\"t\":[\"HashTable底层基于数组与链表实现，通过synchronized关键字保证线程安全，但作为已经废弃的类，建议使用ConcurrentHashMap。\",\"HashTable的默认构造函数，容量为11，加载因子为0.75，扩容大小2倍+1。\"]},\"1556\":{\"h\":\"Set\"},\"1557\":{\"h\":\"HashSet源码分析\",\"t\":[\"HashSet实现了Set接口，在底层就是在HashMap的基础上包了一层，只不过存储的时候value默认存储了一个Object的静态变量，取的时候也是只返回key：\",\" private static final Object PRESENT = new Object(); \",\"核心方法的实现：\",\"public boolean add(E e) { return map.put(e, PRESENT)==null; } public boolean remove(Object o) { return map.remove(o)==PRESENT; } public boolean contains(Object o) { return map.containsKey(o); } \",\"HashSet是调用HashMap的put()方法，而put方法中有这样的逻辑，如果哈希值和key都一样，就会直接拿新的值覆盖旧值，而HashSet就是利用这个特性来保证唯一性的。\"]},\"1558\":{\"h\":\"反射的定义\",\"t\":[\"反射主要指程序可以访问、检测和修改其本身状态或行为的一种能力，在Java环境中，反射机制允许程序在执行时获取类自身的定义信息，例如实现动态创建属性、方法和类的对象、变更属性的内容和执行特定的方法的功能，从而使Java具有动态语言的特性，增强了程序的灵活性可移植性。\"]},\"1559\":{\"h\":\"反射的作用\",\"t\":[\"Java反射机制的主要用于实现以下功能：\",\"在运行时判断任意一个对象所属的类型\",\"在运行时构造任意一个类的对象\",\"在运行时判断任意一个类所具有的成员变量和方法\",\"在运行时调用任意一个对象的方法，哪怕可以调用private方法\"]},\"1560\":{\"h\":\"核心API\",\"t\":[\"核心包 - java.lang.reflect\",\"java.lang.Class：代表一个类\",\"java.lang.reflect.Method：代表类的方法\",\"java.lang.reflect.Constructor：代表类的构造方法\",\"java.lang.reflect.Array：提供了动态创建数组及访问数组元素的静态方法。该类中的所有方法都是静态的\"]},\"1561\":{\"h\":\"IO基础\",\"t\":[\"参考：Linux IO模式及select poll epoll详解。\",\"文件描述符：是计算机科学中的一个术语，用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。\",\"关于句柄的解释；牧童的手为指针，杏花村的牌子为句柄，杏花村酒店为对象的实例。句柄是资源在创建过程中由Windows赋予的，它就是代表这个资源的。而指针实质上是某个变量或者对象所在内存位置的首地址，是指向对象的。一个是指向，一个是代表，二者是不同的。一个是直接找到对象（指针），一个是间接找到对象（句柄）。例如，杏花村可以搬家（实际上程序运行过程中，资源在内存中的地址是变化的），那么牧童的手的指向也就不同（指针）了，然而即使搬了家，“杏花村”这块牌匾是不变的，通过打听“杏花村”这个名称，还是可以间接找到它的（地址）。HANDLE的本意是把柄，把手的意思，是你与操作系统打交道的东西。\",\"对于一次IO访问（以read为例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：\",\"等待数据准备\",\"将数据从内核拷贝至进程中\",\"基于这两个阶段，Linux操作系统有以下四种IO模型的方案：\",\"阻塞IO\",\"非阻塞IO\",\"IO多路复用\",\"异步IO\"]},\"1562\":{\"h\":\"Linux网络编程IO模型\"},\"1563\":{\"h\":\"阻塞IO模型\",\"t\":[\"这是最传统的IO模型，即在读写数据的过程中会阻塞，一个典型的读操作流程大致如下：\",\"当用户进程调用了recvfrom这个系统调用，kernel就开始IO的第一个阶段：准备数据（对于网络IO来说，很多时候一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区是需要一个过程的。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。\",\"也就是说，阻塞IO的特点就是在IO执行的两个阶段都被block了。\"]},\"1564\":{\"h\":\"非阻塞IO\",\"t\":[\"linux下，可以通过设置socket使其变为non-blocking。当对于一个non-blocking socket 执行读操作时，流程大致如下：\",\"当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。\",\"也就是说，非阻塞IO的特点是用户进行需要不断的主动询问kernel数据好了没有。\"]},\"1565\":{\"h\":\"IO多路复用\",\"t\":[\"IO多路复用就是我们通常说的select、poll、epoll，有些地方也称这种IO方式为event driven IO。\",\"select/epoll的好处在于单个process就可以同时处理多个网络连接的IO。它的基本原来就是select、poll、epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。\",\"当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。\",\"总结来看，IO多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。\",\"IO多路复用模型与阻塞IO其实并没有太大的区别，事实上，还更差一些。因为这里需要使用两个system call(select 和 recvfrom分别调用一次)，而阻塞IO值调用了一次system call(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。\",\"所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用mutli-threading+blocking的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。\",\"在IO多路复用模型中，一般会将socket都设置为非阻塞，但是用户进程会被select函数阻塞。\"]},\"1566\":{\"h\":\"异步IO\",\"t\":[\"Linux下的异步IO其实用的很少，整体流程大致如下：\",\"用户进程发起read操作之后，立刻就可以开始去做其它的事，而另一方面，从kernel的角度，当它收到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。\"]},\"1567\":{\"h\":\"阻塞、非阻塞和同步、异步\",\"t\":[\"阻塞、非阻塞说的是调用者。同步、异步说的是被调用者。\",\"同步IO和异步IO的区别：\",\"同步IO：真实IO 操作的时候会将process阻塞\",\"异步IO：真实IO 操作的时候不会将process阻塞\",\"按照如上定义，阻塞IO、非阻塞IO、IO多路复用均属于同步IO。\",\"五种线程模型对比：\"]},\"1568\":{\"h\":\"IO多路复用之select、poll、epoll\",\"t\":[\"select、poll和epoll都是IO多路复用的机制。IO多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select、poll、epoll本质上都是同步IO，因为它们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步IO则无需自己负责进行读写，异步IO的实现会负责把数据从内核拷贝到用户空间。\"]},\"1569\":{\"h\":\"select\",\"t\":[\"int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); \",\"select函数监视的文件描述符分为3类，分别是readfds、writefds和exceptfds。调用select函数会阻塞，直到有描述符就绪（有数据可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。\",\"select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。\"]},\"1570\":{\"h\":\"poll\",\"t\":[\"int poll (struct pollfd *fds, unsigned int nfds, int timeout); \",\"不同于select使用三个位图来表示三个fdset的方式，poll使用一个pollfd的指针实现。\",\"struct pollfd { int fd; /* file descriptor */ short events; /* requested events to watch */ short revents; /* returned events witnessed */ }; \",\"pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时pollfd并没有最大数量限制（但是数量过大后性能也会下降）。和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。\",\"select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。实际上，同时连接的大量客户端在同一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线程下降。\"]},\"1571\":{\"h\":\"epoll\",\"t\":[\"epoll是在Linux内核2.6版本中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的时间存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需要一次。\"]},\"1572\":{\"h\":\"Java中的IO模型\",\"t\":[\"在JDK1.4之前，基于Java的所有socket通信都使用了同步阻塞模式（bloking IO），这种一请求一应答的通信模型简化了上层开发，但性能可能性存在巨大瓶颈，对高并发和低时延支持不好。\",\"在JDK1.4之后，提供了新的NIO类库，Java开始支持非阻塞IO。在JDK1.7以后，将原来的NIO类库进行了升级，提供了AIO功能，支持基于文件的异步IO操作和针对套接字的异步IO操作等功能。\",\"JDK1.7之后，将原来的NIO类库进行了升级，提供了AIO功能，支持基于文件的异步IO操作和针对套接字的异步IO操作等功能。\"]},\"1573\":{\"h\":\"BIO\",\"t\":[\"使用BIO通信模型的服务端，通常通过一个独立的Acceptor线程负责监听客户端的连接，监听到客户端连接请求后为每一个客户端创建一个新的线程链路进行处理，处理完成通过输出流回应客户端，线程消耗，这就是典型一对一答模型，下面我们通过代码对BIO模型进行具体分析，我们实现客户端发送消息服务端将消息回传我们的功能。\",\"服务端：\",\" int port = 3000; try(ServerSocket serverSocket = new ServerSocket(port)) { Socket socket = null; while (true) { //主程序阻塞在accept操作上 socket = serverSocket.accept(); new Thread(new BioExampleServerHandle(socket)).start(); } } catch (Exception e) { e.printStackTrace(); } \",\" private Socket socket; public BioExampleServerHandle(Socket socket) { this.socket = socket; } @Override public void run() { try(BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter writer = new PrintWriter(socket.getOutputStream(), true)) { String message = reader.readLine(); System.out.println(\\\"收到客户端消息：\\\" + message); writer.println(\\\"answer: \\\" + message); } catch (Exception e) { e.printStackTrace(); } } \",\"客户端：\",\" String host = \\\"127.0.0.1\\\"; int port = 3000; try(Socket socket = new Socket(host, port); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter writer = new PrintWriter(socket.getOutputStream(), true)) { Scanner input = new Scanner(System.in); System.out.println(\\\"输入你想说的话：\\\"); String message = input.nextLine(); writer.println(message); String answer = reader.readLine(); System.out.println(answer); } catch (Exception e) { e.printStackTrace(); } \",\"通过代码我们可以发现BIO的主要问题在于，每当一个连接接入时我们都需要new一个线程进行处理，这显然是不合适的，因为一个线程功能只能处理一个连接，这显然是不合适的，因为一个线程只能处理一个连接，如果在高并发的情况下，我们的程序肯定无法满足性能需求，同时我们对线程创建也缺乏管理。为了改进这种模型我们可以通过消息队列和线程池技术对它加以优化，我们称它为伪异步IO，代码如下：\",\" int port = 3000; ThreadPoolExecutor socketPool = null; try(ServerSocket serverSocket = new ServerSocket(port)) { Socket socket = null; int cpuNum = Runtime.getRuntime().availableProcessors(); socketPool = new ThreadPoolExecutor(cpuNum, cpuNum * 2, 1000, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1000)); while (true) { socket = serverSocket.accept(); socketPool.submit(new BioExampleServerHandle(socket)); } } catch (Exception e) { e.printStackTrace(); } finally { socketPool.shutdown(); } \",\"可以看到每当有新的连接接入，我们都将他投递给线程池处理，由于我们设置了线程池大小和阻塞队列大小，因此在并发情况下都不会导致服务崩溃，但是如果并发数大于阻塞队列大小，或服务端处理连接缓慢时，阻塞队列无法继续处理，会导致客户端连接超时，影响用户体验。\"]},\"1574\":{\"h\":\"NIO\",\"t\":[\"NIO弥补了同步阻塞IO的不足，它提供了高速、面向块的IO，NIO中的一些概念：\",\"Buffer：Buffer用于和NIO通道进行交互。数据从通道读入缓冲区，从缓冲区写入到通道中，它的主要作用就是和channel进行交互\",\"Channel：Channel是一个通道，可以通过它读取和写入数据，通道是双向的，通道可以用户读、写或者同时读写\",\"Selector：Selector会不断的轮询注册在它上面的Channel，如果Channel上面有新的连接读写事件的时候就会被轮询出来，一个Selector可以注册多个Channel，只需要一个线程负责Selector轮询，就可以支持成千上万的连接，可以说为高并发服务器的开发提供了很好的支撑\",\"服务端：\",\" int port = 3000; ServerSocketChannel socketChannel = null; Selector selector = null; try { selector = Selector.open(); socketChannel = ServerSocketChannel.open(); //设置连接模式为非阻塞模式 socketChannel.configureBlocking(false); socketChannel.socket().bind(new InetSocketAddress(port)); //在selector上注册通道，监听连接事件 socketChannel.register(selector, SelectionKey.OP_ACCEPT); while (true) { //设置selector 每隔一秒扫描所有channel selector.select(1000); Set<SelectionKey> selectionKeys = selector.selectedKeys(); Iterator<SelectionKey> iterable = selectionKeys.iterator(); SelectionKey key = null; while (iterable.hasNext()) { key = iterable.next(); //对key进行处理 try { handlerKey(key, selector); } catch (Exception e) { if (null != key) { key.cancel(); if (null != key.channel()) { key.channel().close(); } } } } } } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != selector) { selector.close(); } if (null != socketChannel) { socketChannel.close(); } } catch (Exception e) { throw new RuntimeException(e); } } \",\"handlerKey代码如下：\",\" private void handlerKey(SelectionKey key, Selector selector) throws IOException { if (key.isValid()) { //判断是否是连接请求，对所有连接请求进行处理 if (key.isAcceptable()) { ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel(); SocketChannel channel = serverSocketChannel.accept(); channel.configureBlocking(false); //在selector上注册通道，监听读事件 channel.register(selector, SelectionKey.OP_READ); } else if (key.isReadable()) { SocketChannel channel = (SocketChannel) key.channel(); //分配一个1024字节的缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int readBytes = channel.read(byteBuffer); if (readBytes > 0) { //从写模式切换到读模式 byteBuffer.flip(); byte[] bytes = new byte[byteBuffer.remaining()]; byteBuffer.get(bytes); String message = new String(bytes, \\\"UTF-8\\\"); System.out.println(\\\"收到客户端消息: \\\" + message); //回复客户端 message = \\\"answer: \\\" + message; byte[] responseByte = message.getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(responseByte.length); writeBuffer.put(responseByte); writeBuffer.flip(); channel.write(writeBuffer); } } } } \",\"客户端代码：\",\" int port = 3000; String host = \\\"127.0.0.1\\\"; SocketChannel channel = null; Selector selector = null; try { selector = Selector.open(); channel = SocketChannel.open(); channel.configureBlocking(false); if (channel.connect(new InetSocketAddress(host, port))) { channel.register(selector, SelectionKey.OP_READ); write(channel); } else { channel.register(selector, SelectionKey.OP_CONNECT); } while (true) { selector.select(1000); Set<SelectionKey> selectionKeys = selector.selectedKeys(); Iterator<SelectionKey> iterator = selectionKeys.iterator(); SelectionKey key = null; while (iterator.hasNext()) { try { key = iterator.next(); handle(key, selector); } catch (Exception e) { e.printStackTrace(); if (null != key.channel()) { key.channel().close(); } if (null != key) { key.cancel(); } } } } } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != channel) { channel.close(); } if (null != selector) { selector.close(); } } catch (Exception e) { throw new RuntimeException(e); } } \",\"write 方法：\",\" private void write(SocketChannel channel) throws IOException { Scanner in = new Scanner(System.in); System.out.println(\\\"输入你想说的话：\\\"); String message = in.next(); byte[] bytes = message.getBytes(); ByteBuffer byteBuffer = ByteBuffer.allocate(bytes.length); byteBuffer.put(bytes); byteBuffer.flip(); channel.write(byteBuffer); } \",\"handle 方法：\",\" private void handle(SelectionKey key, Selector selector) throws IOException { if (key.isValid()) { SocketChannel channel = (SocketChannel) key.channel(); if (key.isConnectable()) { if (channel.finishConnect()) { channel.register(selector, SelectionKey.OP_READ); write(channel); } } else if (key.isReadable()) { ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int readBytes = channel.read(byteBuffer); if (readBytes > 0) { byteBuffer.flip(); byte[] bytes = new byte[byteBuffer.remaining()]; byteBuffer.get(bytes); String message = new String(bytes, \\\"UTF-8\\\"); System.out.println(message); } else if (readBytes < 0) { key.cancel(); channel.close(); } } } } \",\"通过代码我们会发现，NIO比BIO复杂很多。NIO虽然编码复杂，但优势同样明显，比起BIO客户端连接操作时异步的，我们可以注册OP_CONNET事件等待结果而不用像BIO那样被同步阻塞，Channel的读写操作都是异步的，没有等待数据它不会等待，而是直接返回。比起BIO我们不需要频繁的创建线程来处理客户端连接，而是通过一个Selector处理多个客户端连接，而且性能也可以得到保证，适合做高性能服务器开发。\"]},\"1575\":{\"h\":\"AIO\",\"t\":[\"通过对比，AIO要比BIO简单，这是因为我们不需要创建一个独立的IO线程来处理读写操作，AsynchronousSocketchannel、AsynchronousServerSocketChannel由JDK底层线程池负责回调驱动读写操作。\",\"服务端：\",\" int port = 3000; AsynchronousServerSocketChannel socketChannel = null; try { socketChannel = AsynchronousServerSocketChannel.open(); socketChannel.bind(new InetSocketAddress(port)); //接收客户端连接，传入AcceptCompletionHandler作为回调来接收连接消息 socketChannel.accept(socketChannel, new AcceptCompletionHandler()); Thread.currentThread().join(); } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != socketChannel) { socketChannel.close(); } } catch (Exception e1) { throw new RuntimeException(e1); } } \",\"AcceptCompletionHandler 类：\",\"public class AcceptCompletionHandler implements CompletionHandler<AsynchronousSocketChannel, AsynchronousServerSocketChannel> { @Override public void completed(AsynchronousSocketChannel result, AsynchronousServerSocketChannel attachment) { //继续接受其他客户端的连接请求，形成一个循环 attachment.accept(attachment, this); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //调用read操作进行异步读取操作，传入ReadCompletionHandler作为回调 result.read(byteBuffer, byteBuffer, new ReadCompletionHandler(result)); } @Override public void failed(Throwable exc, AsynchronousServerSocketChannel attachment) { //异常失败处理在这里 } } \",\"ReadCompletionHandler 类\",\"public class ReadCompletionHandler implements CompletionHandler<Integer, ByteBuffer> { private AsynchronousSocketChannel channel; public ReadCompletionHandler(AsynchronousSocketChannel channel) { this.channel = channel; } @Override public void completed(Integer result, ByteBuffer byteBuffer) { try { byteBuffer.flip(); byte[] bytes = new byte[byteBuffer.remaining()]; byteBuffer.get(bytes); String message = new String(bytes, \\\"UTF-8\\\"); System.out.println(\\\"收到客户端消息：: \\\" + message); write(message); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } @Override public void failed(Throwable exc, ByteBuffer attachment) { try { channel.close(); } catch (Exception e) { throw new RuntimeException(e); } } private void write(String message) { message = \\\"answer: \\\" + message; byte[] bytes = message.getBytes(); ByteBuffer byteBuffer = ByteBuffer.allocate(bytes.length); byteBuffer.put(bytes); byteBuffer.flip(); channel.write(byteBuffer, byteBuffer, new WriteCompletionHandler(channel)); } } \",\"客户端：\",\" int port = 3000; String host = \\\"127.0.0.1\\\"; AsynchronousSocketChannel channel = null; try { channel = AsynchronousSocketChannel.open(); channel.connect(new InetSocketAddress(host, port), channel, new AioClientHandler()); Thread.currentThread().join(); } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != channel) { channel.close(); } } catch (Exception e) { throw new RuntimeException(e); } } \",\"AioClientHandler 类(由于客户端比较简单我这里使用了嵌套类部类)：\",\"public class AioClientHandler implements CompletionHandler<Void, AsynchronousSocketChannel> { @Override public void completed(Void result, AsynchronousSocketChannel channel) { Scanner in = new Scanner(System.in); System.out.println(\\\"输入你想说的话：\\\"); String message = in.next(); byte[] bytes = message.getBytes(); ByteBuffer byteBuffer = ByteBuffer.allocate(bytes.length); byteBuffer.put(bytes); byteBuffer.flip(); channel.write(byteBuffer, byteBuffer, new CompletionHandler<Integer, ByteBuffer>() { @Override public void completed(Integer result, ByteBuffer buffer) { //判断是否写完如果没有继续写 if (buffer.hasRemaining()) { channel.write(buffer, buffer, this); } else { ByteBuffer readBuffer = ByteBuffer.allocate(1024); channel.read(readBuffer, readBuffer, new CompletionHandler<Integer, ByteBuffer>() { @Override public void completed(Integer result, ByteBuffer attachment) { try { attachment.flip(); byte[] bytes1 = new byte[attachment.remaining()]; attachment.get(bytes1); String message = new String(bytes1, \\\"UTF-8\\\"); System.out.println(message); System.exit(1); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } @Override public void failed(Throwable exc, ByteBuffer attachment) { try { channel.close(); } catch (Exception e) { throw new RuntimeException(e); } } }); } } @Override public void failed(Throwable exc, ByteBuffer attachment) { try { channel.close(); } catch (Exception e) { throw new RuntimeException(e); } } }); } @Override public void failed(Throwable exc, AsynchronousSocketChannel attachment) { } \"]},\"1576\":{\"h\":\"IO模型对比\",\"t\":[\"同步阻塞I/O(BIO)\",\"伪异步I/O\",\"非阻塞I/O(NIO)\",\"异步I/O(AIO)\",\"是否阻塞\",\"是\",\"是\",\"否\",\"否\",\"是否同步\",\"是\",\"是\",\"是\",\"否(异步)\",\"程序员友好程度\",\"简单\",\"简单\",\"非常难\",\"比较难\",\"可靠性\",\"非常差\",\"差\",\"高\",\"高\",\"吞吐量\",\"低\",\"中\",\"高\",\"高\",\"零拷贝从字面上来看包含两个意思：\",\"拷贝：就是指数据从一个存储区域转移到另一个存储区域\",\"零：它表示拷贝数据的次数为0\",\"合起来理解，零拷贝就是不需要将数据从一个存储区域复制到另一个存储区域。实际上，最早零拷贝的定义，来源于Linux系统的sendfile方法逻辑。\",\"在Linux 2.4内核中，sendfile系统调用方法，可以将磁盘数据通过DMA拷贝到内核态Buffer后，再通过DMA拷贝到NIC Buffer（socket buffer 即网卡），无需CPU拷贝，这个过程被称之为零拷贝。也就是说，站在操作系统的角度，零拷贝并不是不需要拷贝数据，而是省掉了CPU拷贝环节，减少了不必要的拷贝次数，提升数据拷贝效率。要想深入了解这其中的原理，就得从IO拷贝机制说起。\"]},\"1577\":{\"h\":\"基本概念\"},\"1578\":{\"h\":\"DMA\",\"t\":[\"DMA，即直接内存访问。DMA本质上是主板上一块独立的芯片，允许外设设备和内存存储器之间直接进行IO数据传输，其过程不需要CPU的参与。\"]},\"1579\":{\"h\":\"内核空间和用户空间\",\"t\":[\"操作系统的核心是内核，与普通的应用程序不同，它可以访问受保护的内核空间，也有访问底层硬件设备的权限。\",\"为了避免用户进程直接操作内核，保证内核安全，操作系统将虚拟内存划分为两个部分，一部分是内核空间，一部分是用户空间。在Linux系统中，内核模块运行在内核空间，对应的进程处于内核态；而用户程序运行在用户空间，对应的进程处于用户态。\",\"内核空间总是驻留在内存中，它是为操作系统的内核保留的。应用程序是不允许直接在该区域进行读写或者直接调用内核代码定义的函数。\",\"当启动某个应用程序时，操作系统会给应用程序分配一个单独的用户空间，其实就是一个用户独享的虚拟内存，每个普通的用户进程之间的用户空间是完全隔离的、不共享的，当用户进程结束的时候，用户空间的虚拟内存也会随之释放。\",\"同时处于用户态的进程不能访问内核空间中的数据，也不能直接调用内核函数的，如果要调用系统资源，就要将进程切换到内核态，由内核程序来进行操作。\"]},\"1580\":{\"h\":\"IO拷贝机制\",\"t\":[\"以客户端从服务器下载文件为例，服务端需要做两件事：\",\"从磁盘读取文件内容\",\"将文件内容通过网络传输给客户端\",\"实际上，这个看似简单的操作，里面的流程却没有那么简单，应用程序从磁盘中读取文件内容的操作，大体会经过以下几个流程：\",\"用户应用程序调用read方法，向操作系统发起IO请求，CPU上下文从用户态转为内核态，完成第一次CPU切换\",\"操作系统通过DMA控制器从磁盘中读取数据，并把数据存储到内核缓冲区\",\"CPU把内核缓冲区的数据，拷贝到用户缓冲区，同时上下文从内核态转为用户态，完成第二次CPU切换\",\"整个读取的数据的过程，完成了1次DMA拷贝，1次CPU拷贝，2次CPU切换，反之写入的过程，也是一样的。整个拷贝的过程，可以用如下流程图来描述：\",\"从上图，我们可以得出如下结论，4次拷贝次数，4次上下文切换次数。\",\"数据拷贝次数：2次DMA拷贝，2次CPU拷贝\",\"CPU切换次数：4次用户态和内核态切换\",\"而实际IO读写，有时候需要进行IO中断，同时也需要CPU响应中断，拷贝次数和切换次数比预期的还要多，以至于当客户端进行资源文件下载的时候，传输速度总是不尽人意。\"]},\"1581\":{\"h\":\"mmap内存映射拷贝流程\",\"t\":[\"mmap内存映射的拷贝，指的是将用户应用程序的缓冲区和操作系统的内核缓冲区进行映射处理，数据在内核缓冲区和用户缓冲区之间的CPU拷贝将其省略，进而加快资源拷贝效率。\",\"mmap内存映射拷贝流程：\",\"数据拷贝次数：2次DMA拷贝，1次CPU拷贝\",\"CPU切换次数：4次用户态和内核态的切换\",\"整个过程省掉了数据在内核缓冲区和用户缓冲区之间的CPU拷贝环节，在实际的应用中，对资源的拷贝速度性能提升不少。\"]},\"1582\":{\"h\":\"Linux系统sendfile拷贝流程\",\"t\":[\"在Linux 2.1 内核版本中，引入了一个系统调用方法：sendfile。\",\"当调用sendfile()时，DMA将磁盘数据复制到内核缓冲区kernel buffer；然后将内核中kernel buffer直接拷贝到socket buffer，最后利用DMA将socket buffer通过网卡传输给客户端。整个拷贝过程，可以用如下流程图来描述：\",\"Linux 系统 sendfile 拷贝流程：\",\"数据拷贝次数：2 次 DMA 拷贝，1 次 CPU 拷贝\",\"CPU 切换次数：2 次用户态和内核态的切换\",\"相比mmap内存映射方式，sendfile拷贝流程省掉了2次用户态和内核态的切换，同时内核缓冲区和用户缓冲区也无需建立内存映射，对资源的拷贝性能提升不少。\"]},\"1583\":{\"h\":\"sendfile With DMA scatter/gather 拷贝流程\",\"t\":[\"在 Linux 2.4 内核版本中，对 sendfile 系统方法做了优化升级，引入 SG-DMA 技术，需要 DMA 控制器支持。\",\"其实就是对 DMA 拷贝加入了 scatter/gather 操作，它可以直接从内核空间缓冲区中将数据读取到网卡。使用这个特点来实现数据拷贝，可以多省去一次 CPU 拷贝。\",\"整个拷贝过程，可以用如下流程图来描述：\",\"Linux 系统 sendfile With DMA scatter/gather 拷贝流程，从上图可以得出如下结论：\",\"数据拷贝次数：2 次 DMA 拷贝，0 次 CPU 拷贝\",\"CPU 切换次数：2 次用户态和内核态的切换\",\"可以发现，sendfile With DMA scatter/gather 实现的拷贝，其中 2 次数据拷贝都是 DMA 拷贝，全程都没有通过 CPU 来拷贝数据，所有的数据都是通过 DMA 来进行传输的，这就是操作系统真正意义上的零拷贝（Zero-copy) 技术，相比其他拷贝方式，传输效率最佳。\"]},\"1584\":{\"h\":\"Linux 系统 splice 零拷贝流程\",\"t\":[\"在 Linux 2.6.17 内核版本中，引入了 splice 系统调用方法，和 sendfile 方法不同的是，splice 不需要硬件支持。\",\"它将数据从磁盘读取到 OS 内核缓冲区后，内核缓冲区和 socket 缓冲区之间建立管道来传输数据，避免了两者之间的 CPU 拷贝操作。\",\"整个拷贝过程，可以用如下流程图来描述：\",\"Linux 系统 splice 拷贝流程，从上图可以得出如下结论：\",\"数据拷贝次数：2 次 DMA 拷贝，0 次 CPU 拷贝\",\"CPU 切换次数：2 次用户态和内核态的切换\",\"Linux 系统 splice 方法逻辑拷贝，也是操作系统真正意义上的零拷贝。\"]},\"1585\":{\"h\":\"IO拷贝机制对比\",\"t\":[\"从上面的IO拷贝机制中可以看出，无论是传统的IO方式，还是引入零拷贝之后，2次DMA copy都是少不了的，唯一的区别就是省掉CPU参与环节的方式不同。\",\"以Linux系统为例，拷贝机制对比的结果如下：\",\"拷贝机制\",\"系统调用\",\"CPU拷贝次数\",\"CPU拷贝次数\",\"上下文切换次数\",\"特点\",\"传统拷贝方式\",\"read/write\",\"2\",\"2\",\"4\",\"消耗资源比较多，拷贝数据效率慢\",\"mmap\",\"mmap/write\",\"1\",\"2\",\"4\",\"相比传统方法，少了用户缓冲区与内核缓冲区的数据拷贝，效率更高\",\"sendfile\",\"sendfile\",\"1\",\"2\",\"2\",\"相比mmap方式，少了内存文件映射步骤，效率更高\",\"sendfile With DMA scatter/gather\",\"sendfile\",\"0\",\"2\",\"2\",\"需要DMA控制器支持，没有CPU拷贝数据环节，真正的零拷贝\",\"splice\",\"splice\",\"0\",\"2\",\"2\",\"没有CPU拷贝数据环节，真正的零拷贝，编程逻辑复杂\",\"需要主要的是，零拷贝所有的方式，都需要操作系统的支持，具体采用哪种方式，是由操作系统来决定的。\"]},\"1586\":{\"h\":\"Java中的零拷贝\",\"t\":[\"Linux提供的零拷贝技术，Java并不是全部支持，目前只支持一下两种；\",\"mmap（内存映射）\",\"sendfile\"]},\"1587\":{\"h\":\"Java NIO 对mmap的支持\",\"t\":[\"Java NIO有一个MappedByteBuffer的类，可以用来实现内存映射，它的底层时调用了Linux内核的mmap的API。\",\"实现代码如下：\",\"public static void main(String[] args) { try { FileChannel readChannel = FileChannel.open(Paths.get(\\\"a.txt\\\"), StandardOpenOption.READ); // 建立内存文件映射 MappedByteBuffer data = readChannel.map(FileChannel.MapMode.READ_ONLY, 0, 1024 * 1024 * 40); FileChannel writeChannel = FileChannel.open(Paths.get(\\\"b.txt\\\"), StandardOpenOption.WRITE, StandardOpenOption.CREATE); // 拷贝数据 writeChannel.write(data); // 关闭通道 readChannel.close(); writeChannel.close(); }catch (Exception e){ System.out.println(e.getMessage()); } } \",\"其中MappedByteBuffer的作用，就是将内核缓冲区的内存和用户缓冲区的内存做了一个地址映射，读取小文件，效率并不高，但是读取大文件，效率很高。\"]},\"1588\":{\"h\":\"Java NIO 对sendfile的支持\",\"t\":[\"Java NIO 中的FileChannel.transferTo方法，底层调用的就是Linux内核的sendfile系统调用方法。实例代码如下：\",\"public static void main(String[] args) { try { // 原始文件 FileChannel srcChannel = FileChannel.open(Paths.get(\\\"a.txt\\\"), StandardOpenOption.READ); // 目标文件 FileChannel destChannel = FileChannel.open(Paths.get(\\\"b.txt\\\"), StandardOpenOption.WRITE, StandardOpenOption.CREATE); // 拷贝数据 srcChannel.transferTo(0, srcChannel.size(), destChannel); // 关闭通道 srcChannel.close(); destChannel.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } \",\"Java NIO 提供的FileChannel.transferTo并不保证一定能使用零拷贝。只有操作系统提供sendfile这样的零拷贝系统调用方法，才可以用的上零拷贝。\"]},\"1589\":{\"h\":\"EJB 简介\"},\"1590\":{\"h\":\"函数式编程概览\"},\"1591\":{\"h\":\"函数式编程的意义\",\"t\":[\"JDK8或者说Java8是目前企业开发中最常用的JDK版本，Java8可谓Java语言历史上变化最大的一个版本，从这个版本开始，Java的编程向着函数式风格迈进，这有助于编写出更为简洁、表达力更强，并且在很多情况下能够利用并行运行的代码。但是很多人在使用Java8的时候，还是使用传统的面向对象的编程方式，这样在使用Java8的好处也仅仅停留在JVM带来的性能上的提升，而事实上Java8的新特性可以极大提升我们的开发效率。不仅如此，几乎所有的高级编程语言都支持了函数式编程的特性，掌握其中一门的设计理念与思想，在面对其他任何编程语言的函数式编程时，都能做到游刃有余。\",\"在以往的使用传统面向对象的编程中，我们可能会编写这样的代码：\",\"import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class anonymousTest { public static void main(String[] args) { JFrame jFrame = new JFrame(\\\"My JFrame\\\"); JButton jButton = new JButton(\\\"My Button\\\"); // 使用匿名内部类编程 jButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.out.println(\\\"Button Pressed\\\"); } }); jFrame.add(jButton); jFrame.pack(); jFrame.setVisible(true); jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } \",\"这段代码我们实际上需要的其实只有System.out.println(\\\"Button Pressed\\\")这一行，但却不得不编写很多没有实际意义的代码，如果改用函数式风格编程，我们的代码就变成了：\",\"import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class anonymousTest { public static void main(String[] args) { JFrame jFrame = new JFrame(\\\"My JFrame\\\"); JButton jButton = new JButton(\\\"My Button\\\"); // 使用函数式编程 jButton.addActionListener(e -> System.out.println(\\\"Button Pressed\\\")); jFrame.add(jButton); jFrame.pack(); jFrame.setVisible(true); jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } \",\"可以看到，瞬间代码的易读性提高了很多。再比如我们经常会用到的创建线程的例子：\",\"package com.czxy.test; import java.io.FileOutputStream; import java.io.IOException; /** * Lambda 在创建线程方面可以简化写法 */ public class Lambda { //原来的写法 public static void main(String[] args) throws IOException { //获取执行前的毫秒值 long old = System.currentTimeMillis(); //执行一百千次 for (int a = 0; a < 100000; a++) { //原来的方式创建线程 实现Runnable接口 重写run方法 Thread thread = new Thread(new Runnable() { @Override public void run() { } }); thread.start(); } //获取执行后的毫秒值 long newTime = System.currentTimeMillis(); //获得消耗的时间 long i = newTime - old; System.out.println(\\\"创建100000个花费的总毫秒值\\\"+i); /* 使用Lambda表达式的新写法 */ //获取执行前的毫秒值 long old1 = System.currentTimeMillis(); for (int a =0; a<100000; a++){ Thread threadLambda = new Thread(()-> System.out.println(\\\"使用Lambda创建了线程了\\\")); threadLambda.start(); } //获取执行后的毫秒值 long newTime1 = System.currentTimeMillis(); //获得消耗的时间 long i1 = newTime1 - old1; System.out.println(\\\"Lambda创建100000个花费的总毫秒值\\\"+i1); } } \",\"不难看出，Lambda表达式在简化代码上，是非常有效的。\"]},\"1592\":{\"h\":\"Lambda表达式和匿名内部类\",\"t\":[\"Lambda表达式看起来特别像是Java中匿名内部类的一种特殊写法，对于初学者而言，暂时不妨可以认为Lambda表达式就是匿名内部类的一种新的写法，或者说是一种语法糖。下面通过一个例子来说明，Lambda表达式就是一种全新的语法：\",\"public class LambdaTest { Runnable r1 = () -> System.out.println(this); Runnable r2 = new Runnable() { @Override public void run() { System.out.println(this); } }; public static void main(String[] args) { LambdaTest lambdaTest = new LambdaTest(); Thread t1 = new Thread(lambdaTest.r1); t1.start(); System.out.println(\\\"================\\\"); Thread t2 = new Thread(lambdaTest.r2); t2.start(); } } \",\"控制台输出：\",\"Stream2.LambdaTest@362872a1 Stream2.LambdaTest$1@60c8c409 \",\"首先来看第二行，它表示当前对象指的是LambdaTest$1，在Java中表示匿名内部类会使用类名称+\\\"$\\\"+顺序的方式来表示，\\\"@\\\"后面的表示类的哈希值，而第一个Lamda表达式所打印的就是当前类LambdaTest的地址，这说明使用Lambda表达式的这种方式与它所在的类是同一个作用域。\",\"通过这个例子说明了Lambda表达式与匿名内部类有着本质的区别，两者是完全不同的，并不是匿名内部类的语法糖或者另一种表达形式，只不过在某些场景下，可以使用Lambda表达式来替代匿名内部类完成相同的功能。\",\"实际上，使用Lambda表达式所带来的好处其实远不止简化代码，它还可以为我们带来代码执行效率上的提升，所以，无论是出于开发效率，还是代码的执行速度上来看，都应该使用Lambda表达式。\"]},\"1593\":{\"h\":\"Lambda表达式和Stream\",\"t\":[\"在实际使用中，Lambda表达式往往与Stream相互配合，才会发挥其特性，通常用来高效的处理一些集合的运算。\",\"我们首先从遍历打印集合中元素这样非常常见的例子开始，以往遍历集合通常的做法是：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); for (String string : list) { System.out.println(string); } } } \",\"或者使用传统的for循环来遍历：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); for (int i = 0; i < list.size(); i++) { System.out.println(list.get(i)); } } } \",\"通过Lambda表达式我们可以将上述代码优雅的表示为：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\",\\\"world\\\",\\\"hello world\\\");\\\\ list.forEach((String x) -> System.out.println(x)); } } \",\"实际上，对于变量前面的类型，也是可以省略的。\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); list.forEach(x-> System.out.println(x)); } } \",\"因为编译器可以自动推断出当前遍历集合当前元素的类型，但并不是在所有的场景下，编译器都可以自动推断类型，在后续的文章中，我们就会遇到编译器无法自动推断，需要我们手动声明变量类型的情况。\",\"这里我们先不去考虑Lambda表达式具体的语法，先从直观的角度来感受函数式编程带来的好处，原本三行的代码现在仅仅需要一行就能实现，如果使用方法引用甚至能够让代码变的更加简洁：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); strings.forEach(System.out::println); } } \",\"这里的\",\":: \",\"也是java8中新增的一个语法糖。后续的文章我们有专门的篇幅来介绍方法引用，使用方法引用可以写出更加简洁优雅的代码。\",\"看了这么几个例子，你可能很疑惑，到底什么是Lambda表达式呢？在回答这个问题之前，我们首先需要了解我们为什么需要需要Lambda表达式。\",\"在以往的Java中，方法可以参数的传递总共有两种，一种是传递值，另有一种是传递引用，或者说对象的地址，但是我们无法将函数作为参数传递给一个方法，也无法声明返回一个函数的方法，而在其他语言中，比如面向函数式编程语言JavaScript中，函数的参数是一个函数，返回值是另一个函数的情况是非常常见的（回调函数），例如：\",\"images_upload_handler: function(blobInfo, success, failure) { success(...) failure(...) } \",\"这个函数总共接收三个参数，第一个参数就是一个普通的变量，success就是这个函数执行成功的回调函数，failure就是这个函数执行失败的回调函数。可以说，JavaScript是一门非常典型的函数式语言。而使用Lambda表达式就可以实现传递行为这种高阶函数（参数可以接收行为的方法们就称这个方法为高阶函数）的使用。\",\"当然Lambda表达式肯定不止只是能用来遍历集合这个简单，实际上，更多的情况下，我们都是需要配合Stream（流）来实现各种各样的操作。对于前面使用Lambda表达式来实现集合遍历的例子还可以这样做：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\",\\\"world\\\",\\\"hello world\\\"); list.forEach(item-> System.out.println(item)); list.stream().forEach(System.out::println); } } \",\"看起来只是增加了一步，将list这个集合转化为了Stream，但是两者的实现有着本质的区别。我们可以简单的了解一下他们之前的区别。 对于第一种： 可以看到list.forEach实际上是调用Iterable这个类中jdk1.8新增的forEach方法，我们都知道List本身继承了Collection集合接口，而Collection接口又继承了Iterable这个类，所以可以完成调用，方法实现本身并没有特别复杂的地方，其实本质上看起来和我们传统的使用迭代器的方式并没有区别，接下来，我们查看一下第二种方式： 首先同样的是在Collection接口中新增加了一个default method（我们称之为默认方法），在jdk1.8中接口是又具体的方法实现，实际上对于java这一门非常庞大臃肿的语言，为了向函数式编程迈进，jdk的设计者匠心独具，设计非常巧妙。这个方法将返回了一个新的对象Stream，并且调用了StreamSupport这个类中的stream（）方法： 追踪下去，我们也可以看到，同样的也是一个名叫forEach的方法，但其实这里的forEach()方法与之前的forEach（）方法存在本质的差别，这里的forEach实际上表示一种终止操作，而jdk会在集合进行流操作的时候，调用终止操作。\",\"在这两个方法中都接受一个Consumer<? super T> action 这样的一个参数，实际上，对于java而言，为了实现函数式编程，java引入了一个全新的概念：函数式接口，它是java实现整个函数式编程的手段，也是函数式编程中一个及其重要的概念，这个概念会贯穿整个函数式编程的全过程，理解了函数式接口，才能Lambda表达式真正的含义，接下来的时间，我们非常有必要首来认识一下，什么是函数式接口。\",\"函数式接口是函数式编程中最重要的概念，函数式编程与传统的编码方式相比最明显的区别就是，它允许把函数（或者说表达式）当成参数传递给另一个函数，在其他编程语言中，Lambda表达式的类型是函数，但在Java中，Lambda表达式是对象，他们必须依附于一类特别的对象--函数式接口（functional interface）。\"]},\"1594\":{\"h\":\"函数式接口定义\",\"t\":[\"在之前的这个例子中：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\",\\\"world\\\",\\\"hello world\\\"); list.forEach(item-> System.out.println(item)); } } \",\"点击箭头就会进入到一个接口当中：\",\"@FunctionalInterface public interface Consumer<T> { void accept(T t); default Consumer<T> andThen(Consumer<? super T> after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } } \",\"可以看到这个接口上有一个@FunctionInterface的注解，点击这个注解进入，就可以看到这样一段JavaDoc:\",\"/** * An informative annotation type used to indicate that an interface * type declaration is intended to be a <i>functional interface</i> as * defined by the Java Language Specification. * * Conceptually, a functional interface has exactly one abstract * method. Since {@linkplain java.lang.reflect.Method#isDefault() * default methods} have an implementation, they are not abstract. If * an interface declares an abstract method overriding one of the * public methods of {@code java.lang.Object}, that also does * <em>not</em> count toward the interface's abstract method count * since any implementation of the interface will have an * implementation from {@code java.lang.Object} or elsewhere. * * <p>Note that instances of functional interfaces can be created with * lambda expressions, method references, or constructor references. * * <p>If a type is annotated with this annotation type, compilers are * required to generate an error message unless: * * <ul> * <li> The type is an interface type and not an annotation type, enum, or class. * <li> The annotated type satisfies the requirements of a functional interface. * </ul> * * <p>However, the compiler will treat any interface meeting the * definition of a functional interface as a functional interface * regardless of whether or not a {@code FunctionalInterface} * annotation is present on the interface declaration. * * @jls 4.3.2. The Class Object * @jls 9.8 Functional Interfaces * @jls 9.4.3 Interface Method Body * @since 1.8 */ @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface FunctionalInterface {} \",\"我们一行一行来仔细阅读一下这段文档：\",\" An informative annotation type used to indicate that an interface type declaration is intended to be a <i>functional interface</i> as defined by the Java Language Specification. \",\"这里说，@FunctionInterface这个注解，它使用Java语言规范定义，使用通知性的annotation,来声明函数式接口，换言之，如果一个接口上使用了@FunctionInterface这个注解，那么这个接口就是函数式接口。\",\"那么到底什么是函数式接口呢？继续往下看：\",\" Conceptually, a functional interface has exactly one abstract method. Since {@linkplain java.lang.reflect.Method#isDefault() default methods} have an implementation, they are not abstract. If an interface declares an abstract method overriding one of the public methods of {@code java.lang.Object}, that also does <em>not</em> count toward the interface's abstract method count since any implementation of the interface will have an implementation from {@code java.lang.Object} or elsewhere. \",\"一个函数式接口，它只有一个精确的抽象方法，也就是说，有且仅有一个抽象方法，那么这个接口就被称为函数式接口（在jdk8中，除了抽象方法外还可以定义default method和static method，不一定都是抽象方法），并且如果这个抽象方法是Object类中的方法，不会计入这个接口的抽象方法数量。需要注意的是，可以通过Lambda表达式来创建，方法引用来创建，或者构造方法的引用来创建函数式接口的实例。\",\"关于Lambda表达式的创建会在后续的文章中详细讲解，这里只需要大概了解函数式接口实例创建的方式有这么三种。我们继续往下：\",\" <p>Note that instances of functional interfaces can be created with lambda expressions, method references, or constructor references. <p>If a type is annotated with this annotation type, compilers are required to generate an error message unless: <ul> <li> The type is an interface type and not an annotation type, enum, or class. <li> The annotated type satisfies the requirements of a functional interface. </ul> <p>However, the compiler will treat any interface meeting the definition of a functional interface as a functional interface regardless of whether or not a {@code FunctionalInterface} annotation is present on the interface declaration. \",\"如果一个接口上有@FunctionInterface这个注解，如果不满足以下情况编译器会报错：\",\"被注解的是一个接口类型，而不是一个注解类型，而是枚举或者类；\",\"被注解的类型满足函数式接口的定义；\",\"例如，创建线程时需要用到的Runnable接口：\",\"@FunctionalInterface public interface Runnable { public abstract void run(); } \",\"可以看到这个接口从JDK8开始就加上了@FunctionalInterface这个注解，换句话说，Runnable接口现在变成了函数式接口，我们可以通过Lambda表达式来创建Runnable接口的实例。\",\"在上面的文档中，还有最后一段话：\",\" <p>However, the compiler will treat any interface meeting the definition of a functional interface as a functional interface regardless of whether or not a {@code FunctionalInterface} annotation is present on the interface declaration \",\"然而，编译器其实会自动为满足函数式接口定义的接口添加@FunctionalInterface注解，也就是说，如果一个接口满足了函数式接口的定义，即便我们没有给他加上@FunctionalInterface这个注解，编译器会自动将它看成是函数式接口。\",\"总的来说，关于函数式接口的定义如下：\",\"1.如果一个接口只有一个抽象方法，那么该接口就是一个函数式接口 2.如果我们在某个接口上声明了FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口 3.如果某个接口只有一个抽象方法，但我们并没有对该接口声明FunctionalInterface注解，编译器依旧会将该接口看作是函数式接口。\",\"再以这个接口为例：\",\"@FunctionalInterface public interface Consumer<T> { void accept(T t); default Consumer<T> andThen(Consumer<? super T> after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } } \",\"可以看到，在这个接口中，除了一个抽象方法accept()方法外，还有一个default默认方法andThen()，但是总的来说还是只有一个抽象方法，所以满足函数式接口的定义。\",\"再比如：\",\"@FunctionalInterface public interface Predicate<T> { boolean test(T t); default Predicate<T> and(Predicate<? super T> other) { Objects.requireNonNull(other); return (t) -> test(t) && other.test(t); } default Predicate<T> negate() { return (t) -> !test(t); } default Predicate<T> or(Predicate<? super T> other) { Objects.requireNonNull(other); return (t) -> test(t) || other.test(t); } static <T> Predicate<T> isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -> targetRef.equals(object); } } \",\"同样的，这个接口中只有一个抽象方法test()，除此之外，有3个default默认方法，有一个static方法，因此同样满足函数式接口的定义。\",\"再比如：\",\"@FunctionalInterface public interface MyInterface { void test(); String toString(); } \",\"这个接口中看起来有两个抽象方法，但toString()方法是基类Object中的方法，因此在检查函数式接口的定义的时候，它并不算数，因为Object类是所有类的父类，所有的类默认已经有了这个方法，如果算的话，其实是没有意义的，所以在定义函数式接口的时候，Object类中方法并不会对函数式接口的方法的数量变化。\",\"在JDK8中的提供了大量的现成的函数式接口供我们使用，以之前我们使用forEach()为例：\",\" default void forEach(Consumer<? super T> action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } \",\"其实forEach()方法接收的函数式接口就是我们上面举得第一个例子Consumer，然后调用Consumer接口中的accept方法，诸多的函数式接口，为我们方便的传递各种不同需求的行为提供了可能。\"]},\"1595\":{\"h\":\"为什么是函数式接口？\",\"t\":[\"在前面我们了解了函数式接口的概念之后，我们来具体看一个例子：\",\"@FunctionalInterface interface MyInterface { void test(); @Override String toString(); } public class FunctionalInterfaceTest { public static void main(String[] args) { } } \",\"我们定义了一个接口，MyInterface，这个接口中有两个抽象方法，但由于toString()是继承自Obeject类中的方法，所以并不会对这个接口的抽象方法的总数有影响，还是只有一个抽象方法，那么显然，它满足函数式接口的定义。\",\"首先我们使用传统的匿名内部类的方式来实现MyInterface中的test()方法：\",\"@FunctionalInterface interface MyInterface { void test(); @Override String toString(); } public class FunctionalInterfaceTest { public void MyTest(MyInterface myInterface) { System.out.println(1); myInterface.test(); System.out.println(2); } public static void main(String[] args) { FunctionalInterfaceTest functionalInterfaceTest = new FunctionalInterfaceTest(); functionalInterfaceTest.MyTest(new MyInterface() { @Override public void test() { System.out.println(\\\"myTest\\\"); } }); } } \",\"MyInterface既然满足函数式接口的定义，那么就意味着我们可以使用Lambda表达式的方式来创建MyInterface的实例：\",\"@FunctionalInterface interface MyInterface { void test(); @Override String toString(); } public class FunctionalInterfaceTest { public void MyTest(MyInterface myInterface) { System.out.println(1); myInterface.test(); System.out.println(2); } public static void main(String[] args) { FunctionalInterfaceTest functionalInterfaceTest = new FunctionalInterfaceTest(); functionalInterfaceTest.MyTest(() -> System.out.println(\\\"myTest\\\")); } } \",\"这两种写法的运行结果完全是等价的，编译器会自动根据上下文，来推测出 functionalInterfaceTest.MyTest()中需要接收的参数的类型，也就是说，() -> System.out.println(\\\"myTest\\\")就是MyInterface 的一个实例，由于函数式接口中只会有一个抽象方法，那么对于这个Lambda表达式而言，箭头左边的部分，一定就是MyInterface 这个接口中唯一的抽象方法test()的参数，右边的部分，一定就是MyInterface 这个接口中唯一的抽象方法test()的实现，由于test()方法的参数是空值，所以左边的括号是空值。\",\"这样看起来，其实MyInterface 这个接口中的抽象方法，具体叫什么名字，反而没有那么重要了，当然虽然这个函数的名字我们并不会直接去调用，但在起名字的时候，最好还是要有意义。\",\"可能初学者并不能直观的认识到() -> System.out.println(\\\"myTest\\\")表达的具体含义，我们可以换一种写法：\",\"interface MyInterface { void test(); @Override String toString(); } public class FunctionalInterfaceTest { public void MyTest(MyInterface myInterface) { System.out.println(1); myInterface.test(); System.out.println(2); } public static void main(String[] args) { FunctionalInterfaceTest functionalInterfaceTest = new FunctionalInterfaceTest(); MyInterface myInterface = () -> System.out.println(\\\"myTest\\\") functionalInterfaceTest.MyTest(myInterface); } } \",\"程序运行的效果是完全等价的，使用这种写法，我们就更能直观的体会到，() -> System.out.println(\\\"myTest\\\")其实就是MyInterface的一个具体实现。\",\"前面我们提到过，在Java中，Lambda表达式需要依赖于函数式接口这样一种特殊的形式，所以为什么是函数式接口呢？或者说为什么需要函数式接口呢？简而言之，Java是纯面向对象的语言，方法无法脱离类或者接口单独存在，因此在Java中，函数式编程必须依附这样一类特殊的对象：函数式接口。\",\"实际上，对于一个特定的Lambda表达式是什么类型的，是需要上下文才能解读的，来看这样一个例子：\",\"public class Essence { public static void main(String[] args) { InterfaceTestA interfaceTestA = () -> {}; InterfaceTestB interfaceTestB = () -> {}; } } interface InterfaceTestA { void myMethod(); } interface InterfaceTestB { void myMethod2(); } \",\"可以看到，对于这两个不同的函数式接口的实现都是() -> {}这同一种实现，对于这个特定的Lambda表达式，必须要联系他的上下文才能知道：\",\" InterfaceTestA interfaceTestA \",\"和\",\" InterfaceTestB interfaceTestB \",\"就是这两个Lambda表达式的上下文。\",\"我们再回到遍历List集合的例子中：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\",\\\"world\\\",\\\"hello world\\\"); list.forEach(item-> System.out.println(item)); } } \",\"点击forEach方法，就会自动跳转到：\",\" /** * Performs the given action for each element of the {@code Iterable} * until all elements have been processed or the action throws an * exception. Unless otherwise specified by the implementing class, * actions are performed in the order of iteration (if an iteration order * is specified). Exceptions thrown by the action are relayed to the * caller. * * @implSpec * <p>The default implementation behaves as if: * <pre>{@code * for (T t : this) * action.accept(t); * }</pre> * * @param action The action to be performed for each element * @throws NullPointerException if the specified action is null * @since 1.8 */ default void forEach(Consumer<? super T> action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } \",\"首先它是一个默认方法，接收的参数类型是Consumer，遍历这个集合，对集合中的每个元素执行Consumer中的accept()方法。\",\"不妨来读一下这段文档：\",\" Performs the given action for each element of the {@code Iterable} until all elements have been processed or the action throws an exception. Unless otherwise specified by the implementing class, actions are performed in the order of iteration (if an iteration order is specified). Exceptions thrown by the action are relayed to the caller \",\"针对于Iterable每一个元素去执行给定的动作，换句话说，这里并不是将值作为参数，而是将行为作为参数进行传递，执行到集合中所有的元素执行完或者抛出异常为止，如果没有被实现类所指定的话，那么动作就会按照迭代的顺序去执行，是不是抛出异常取决于调用者。\",\"其实这里最关键的就是Consumer这个参数，接下来我们重点分析Consumer这个函数式接口。\"]},\"1596\":{\"h\":\"常见的函数式接口\"},\"1597\":{\"h\":\"Consumer函数式接口\",\"t\":[\"首先我们观察Consumer这个接口的定义：\",\"package java.util.function; import java.util.Objects; /** * Represents an operation that accepts a single input argument and returns no * result. Unlike most other functional interfaces, {@code Consumer} is expected * to operate via side-effects. * * <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> * whose functional method is {@link #accept(Object)}. * * @param <T> the type of the input to the operation * * @since 1.8 */ @FunctionalInterface public interface Consumer<T> { /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); /** * Returns a composed {@code Consumer} that performs, in sequence, this * operation followed by the {@code after} operation. If performing either * operation throws an exception, it is relayed to the caller of the * composed operation. If performing this operation throws an exception, * the {@code after} operation will not be performed. * * @param after the operation to perform after this operation * @return a composed {@code Consumer} that performs in sequence this * operation followed by the {@code after} operation * @throws NullPointerException if {@code after} is null */ default Consumer<T> andThen(Consumer<? super T> after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } } \",\"可以看到：\",\"@since 1.8 \",\"这个接口是从JDK1.8才开始有的，consumer这个单词本身的意思是消费者\",\" Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, {@code Consumer} is expected to operate via side-effects. \",\"Consumer代表了一种接收单个输入并且不返回结果的操作，与大多数其他的函数式接口不同的是，它可能会有副作用。\",\"这里的副作用指的是可能会修改传入参数的值。\",\"This is a functional interface whose functional method is {@link #accept(Object)}. \",\"这是一个函数式接口，接口中的抽象方法是accept()。 对于前面List集合遍历的例子， 我们可以通过匿名内部类的方式来操作：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\",\\\"world\\\",\\\"hello world\\\"); list.forEach(new Consumer<String>() { @Override public void accept(String s) { System.out.println(s); } }); } } \",\"由于所有的匿名内部类又可以使用Lambda表达式来进行替换，所以：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\",\\\"world\\\",\\\"hello world\\\"); list.forEach(item-> System.out.println(item)); } } \",\"这里因为类型推断的原因，编译器会自动推断Item的数据类型，所以无需说明item的类型。\"]},\"1598\":{\"h\":\"Function函数式接口\",\"t\":[\"java8为我们了提供了很多的函数式接口，Function就是其中一个，首先我们来读一下它的javaDoc：\",\"package java.util.function; import java.util.Objects; /** * Represents a function that accepts one argument and produces a result. * * <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> * whose functional method is {@link #apply(Object)}. * * @param <T> the type of the input to the function * @param <R> the type of the result of the function * * @since 1.8 */ @FunctionalInterface public interface Function<T, R> { /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); /** * Returns a composed function that first applies the {@code before} * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param <V> the type of input to the {@code before} function, and to the * composed function * @param before the function to apply before this function is applied * @return a composed function that first applies the {@code before} * function and then applies this function * @throws NullPointerException if before is null * * @see #andThen(Function) */ default <V> Function<V, R> compose(Function<? super V, ? extends T> before) { Objects.requireNonNull(before); return (V v) -> apply(before.apply(v)); } /** * Returns a composed function that first applies this function to * its input, and then applies the {@code after} function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param <V> the type of output of the {@code after} function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the {@code after} function * @throws NullPointerException if after is null * * @see #compose(Function) */ default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) { Objects.requireNonNull(after); return (T t) -> after.apply(apply(t)); } /** * Returns a function that always returns its input argument. * * @param <T> the type of the input and output objects to the function * @return a function that always returns its input argument */ static <T> Function<T, T> identity() { return t -> t; } } \",\"同样的，与之前介绍的Consumer函数一样，都是一个函数式接口，都是从JDK8开始提供的。\",\" Represents a function that accepts one argument and produces a result. <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> whose functional method is {@link #apply(Object)}. @param <T> the type of the input to the function @param <R> the type of the result of the function \",\"Function提供了一个接收一个参数并且返回一个结果的函数，它的抽象方法是apply()，<T,R>分别表示输入参数的类型和返回结果的类型。\",\"我们来看一个具体的例子：\",\"public class FunctionTest { public static void main(String[] args) { FunctionTest functionTest = new FunctionTest(); System.out.println(functionTest.compute(1, value -> 2 * value)); } public int compute(int a, Function<Integer, Integer> function) { int result = function.apply(a); return result; } } \",\"这其中最关键的地方在于，compute的function参数传递的是一种行为，而不再是传统的值。\",\"public class FunctionTest { public static void main(String[] args) { FunctionTest functionTest = new FunctionTest(); System.out.println(functionTest.compute(1, value -> 2 * value)); System.out.println(functionTest.compute(2, value -> value * value)); System.out.println(functionTest.compute(3, value -> 3 + value)); } public int compute(int a, Function<Integer, Integer> function) { int result = function.apply(a); return result; } } \",\"可以看到我们其实只定义了一个函数，每次只需要将我们的所定义好的行为，传入即可，这是与非函数式编程最大的区别。\",\"来看一个输入参数与返回结果参数类型不一致的例子：\",\"public class FunctionTest { public int method1(int a) { return 2 * a; } public int method2(int a) { return a * a; } public int method3(int a) { return 3 + a; } } \",\"每当有一种新的操作，我们就不得不定义一个新的函数，因为行为总是被预先定义好的，定义好行为之后我们再去调用。但是使用Lambda表达式，行为是调用的时候才动态的调用执行，这与之前的面向对象的编程方式是完全不同的。\",\"这里还需要简单提及一下高阶函数，如果一个函数接收一个函数作为参数，或者返回一个函数作为返回值，那么该函数就叫做高阶函数。\",\"比如我们上面给出的例子中的compute()方法，convert()方法就是高阶函数。\",\"在Function接口中，还有两个默认方法：\",\" /** * Returns a composed function that first applies the {@code before} * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param <V> the type of input to the {@code before} function, and to the * composed function * @param before the function to apply before this function is applied * @return a composed function that first applies the {@code before} * function and then applies this function * @throws NullPointerException if before is null * * @see #andThen(Function) */ default <V> Function<V, R> compose(Function<? super V, ? extends T> before) { Objects.requireNonNull(before); return (V v) -> apply(before.apply(v)); } \",\"compose()这个函数返回的是一个复合函数，这个复合函数首先应用before这个Function，然后再去对这个结果应用当前的Function，如果当中任何一个Function抛出了异常，它取决于调用这个怎么去处理这个异常。\",\"参数before指的是在应用这个函数之前所要应用的当前的函数的函数，首先会应用before这个Function，然后再应用当前的Function。\",\"cmpose()这个方法其实是将两个Function进行了组合，首先调用传入的Function的apply()方法，然后再调用当前的Function的apply()方法。这么做实现了两个函数式接口的串联，实际上也可以n个的串联。\",\" /** * Returns a composed function that first applies this function to * its input, and then applies the {@code after} function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param <V> the type of output of the {@code after} function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the {@code after} function * @throws NullPointerException if after is null * * @see #compose(Function) */ default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) { Objects.requireNonNull(after); return (T t) -> after.apply(apply(t)); } \",\"andThen()这个方法刚好是反过来的，首先会应用当前的Function，然后再去对应用当前的这个对象的Function。\",\"最后这个方法就比较简单了：\",\" /** * Returns a function that always returns its input argument. * * @param <T> the type of the input and output objects to the function * @return a function that always returns its input argument */ static <T> Function<T, T> identity() { return t -> t; } \",\"它总是返回输入的变量。identity本身的意思也就是同一性，下面我们通过具体的例子来说明：\",\"public class FunctionTest { public static void main(String[] args) { FunctionTest functionTest = new FunctionTest(); System.out.println(functionTest.compute(2, value -> value * 3, value -> value * value)); System.out.println(functionTest.compute2(2, value -> value * 3, value -> value * value)); } public int compute(int a, Function<Integer, Integer> function1, Function<Integer, Integer> function2) { return function1.compose(function2).apply(a); } public int compute2(int a, Function<Integer, Integer> function1, Function<Integer, Integer> function2) { return function1.andThen(function2).apply(a); } } \",\"对于Function接口中的apply()方法而言，它只接受一个参数，并返回一个结果，如果想输入两个参数并返回结果，显然它是做不到的，再JDK中有这样一个函数式接口BiFunction：\",\"@FunctionalInterface public interface BiFunction<T, U, R> { /** * Applies this function to the given arguments. * * @param t the first function argument * @param u the second function argument * @return the function result */ R apply(T t, U u); /** * Returns a composed function that first applies this function to * its input, and then applies the {@code after} function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param <V> the type of output of the {@code after} function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the {@code after} function * @throws NullPointerException if after is null */ default <V> BiFunction<T, U, V> andThen(Function<? super R, ? extends V> after) { Objects.requireNonNull(after); return (T t, U u) -> after.apply(apply(t, u)); } } \",\"Bi实际上是Bidirectional的缩写，这个单词本身的含义是双向的意思。BiFunction这个函数式接口的定义：\",\" /** * Represents a function that accepts two arguments and produces a result. * This is the two-arity specialization of {@link Function}. * * <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> * whose functional method is {@link #apply(Object, Object)}. * * @param <T> the type of the first argument to the function * @param <U> the type of the second argument to the function * @param <R> the type of the result of the function * * @see Function * @since 1.8 */ \",\"接收两个参数并且返回一个结果，它是Function接口的一种特殊形式，有三个泛型，T，U分别是两个接收的参数的类型，R是返回的结果的类型。\",\"如果我们想定义四则运算的话，使用传统的方式，我们可能会写出如下代码：\",\"public class BiFunctionTest { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } ... } \",\"观察不难发现，四则运算正好就是输入两个参数，返回一个结果，正好满足BiFunction的定义，现在我们使用BiFunction来实现同样的功能：\",\"public class BiFunctionTest { public static void main(String[] args) { BiFunctionTest biFunctionTest = new BiFunctionTest(); System.out.println(biFunctionTest.compute(1, 2, (value1, value2) -> value1 + value2)); System.out.println(biFunctionTest.compute(1, 2, (value1, value2) -> value1 - value2)); System.out.println(biFunctionTest.compute(1, 2, (value1, value2) -> value1 * value2)); System.out.println(biFunctionTest.compute(1, 2, (value1, value2) -> value1 / value2)); } public int compute(int a, int b, BiFunction<Integer, Integer, Integer> biFunction) { return biFunction.apply(a, b); } } \",\"但是需要注意的是，在Bifunction中只有一个默认方法andThen()，而没有compose()方法:\",\" /** * Returns a composed function that first applies this function to * its input, and then applies the {@code after} function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param <V> the type of output of the {@code after} function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the {@code after} function * @throws NullPointerException if after is null */ default <V> BiFunction<T, U, V> andThen(Function<? super R, ? extends V> after) { Objects.requireNonNull(after); return (T t, U u) -> after.apply(apply(t, u)); } \",\"原因是显而易见的，如果有的话，只能返回一个结果，而Bifunction要求接收两个参数，返回一个结果，这显然是不行的，但是对于andThen()方法，after这个Function类型的参数，正好可以接收BiFunction这个接口的返回的结果作为参数。\",\"同样的我们可以举一个例子：\",\"public class BiFunctionTest { public static void main(String[] args) { BiFunctionTest biFunctionTest = new BiFunctionTest(); System.out.println(biFunctionTest.compute(1, 2, (value1, value2) -> value1 + value2, value -> value * value)); } public int compute(int a, int b, BiFunction<Integer, Integer, Integer> biFunction, Function<Integer, Integer> function) { return biFunction.andThen(function).apply(a, b); } } \",\"public class PersonTest { public static void main(String[] args) { Person person1 = new Person(\\\"zhangsan\\\", 20); Person person2 = new Person(\\\"lisi\\\", 30); Person person3 = new Person(\\\"wangwu\\\", 40); List<Person> persons = Arrays.asList(person1, person2, person3); PersonTest personTest = new PersonTest(); List<Person> persons2 = personTest.getPersonByAge(25, persons); persons2.forEach(System.out::println); } public List<Person> getPersonByUsername(String username, List<Person> persons) { return persons.stream().filter(person -> person.getUsername().equals(username)).collect(Collectors.toList()); } public List<Person> getPersonByAge(int age, List<Person> persons) { BiFunction<Integer, List<Person>, List<Person>> biFunction = (ageOfPerson, personList) -> { return personList.stream().filter(person -> person.getAge() > age).collect(Collectors.toList()); }; return biFunction.apply(age, persons); } } \"]},\"1599\":{\"h\":\"Predicate函数式接口\",\"t\":[\"同样的方式，我们首先类阅读一下Predicate的JavaDoc：\",\"/** * Represents a predicate (boolean-valued function) of one argument. * * <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> * whose functional method is {@link #test(Object)}. * * @param <T> the type of the input to the predicate * * @since 1.8 */ @FunctionalInterface public interface Predicate<T> { /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return {@code true} if the input argument matches the predicate, * otherwise {@code false} */ boolean test(T t); /** * Returns a composed predicate that represents a short-circuiting logical * AND of this predicate and another. When evaluating the composed * predicate, if this predicate is {@code false}, then the {@code other} * predicate is not evaluated. * * <p>Any exceptions thrown during evaluation of either predicate are relayed * to the caller; if evaluation of this predicate throws an exception, the * {@code other} predicate will not be evaluated. * * @param other a predicate that will be logically-ANDed with this * predicate * @return a composed predicate that represents the short-circuiting logical * AND of this predicate and the {@code other} predicate * @throws NullPointerException if other is null */ default Predicate<T> and(Predicate<? super T> other) { Objects.requireNonNull(other); return (t) -> test(t) && other.test(t); } /** * Returns a predicate that represents the logical negation of this * predicate. * * @return a predicate that represents the logical negation of this * predicate */ default Predicate<T> negate() { return (t) -> !test(t); } /** * Returns a composed predicate that represents a short-circuiting logical * OR of this predicate and another. When evaluating the composed * predicate, if this predicate is {@code true}, then the {@code other} * predicate is not evaluated. * * <p>Any exceptions thrown during evaluation of either predicate are relayed * to the caller; if evaluation of this predicate throws an exception, the * {@code other} predicate will not be evaluated. * * @param other a predicate that will be logically-ORed with this * predicate * @return a composed predicate that represents the short-circuiting logical * OR of this predicate and the {@code other} predicate * @throws NullPointerException if other is null */ default Predicate<T> or(Predicate<? super T> other) { Objects.requireNonNull(other); return (t) -> test(t) || other.test(t); } /** * Returns a predicate that tests if two arguments are equal according * to {@link Objects#equals(Object, Object)}. * * @param <T> the type of arguments to the predicate * @param targetRef the object reference with which to compare for equality, * which may be {@code null} * @return a predicate that tests if two arguments are equal according * to {@link Objects#equals(Object, Object)} */ static <T> Predicate<T> isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -> targetRef.equals(object); } } \",\"Predicate也是一个重要的函数式接口\",\"/** * Represents a predicate (boolean-valued function) of one argument. * * <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> * whose functional method is {@link #test(Object)}. * * @param <T> the type of the input to the predicate * * @since 1.8 */ \",\"predicate这个单词本身是谓词， 阐明， 断言的意思，这里说，Predicate代表了一个接收一个参数，返回一个boolean值类型的函数式接口，其中方法名叫test()。\",\" /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return {@code true} if the input argument matches the predicate, * otherwise {@code false} */ \",\"针对于给定的T类型的参数t来计算，如果与predicate相匹配，则返回一个true,否则返回false。\",\"针对于Predicate可以定义，我们可以给出例子：\",\"public class PredicateTest { public static void main(String[] args) { Predicate<String> predicate = p -> p.length() > 5; System.out.println(predicate.test(\\\"hello\\\")); } } \",\"Predicate在集合与stream中有大量的应用，再来看一些具体的例子：\",\"public class PredicateTest2 { public static void main(String[] args) { List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); PredicateTest2 predicateTest2 = new PredicateTest2(); // 找到集合中所有的偶数 predicateTest2.conditionFilter(list, item -> item % 2 == 0); // 找到集合中所有的奇数 predicateTest2.conditionFilter(list, item -> item % 2 != 0); // 找到集合中所有大于5的数 predicateTest2.conditionFilter(list, item -> item > 5); // 找到集合中所有小于3的数 predicateTest2.conditionFilter(list, item -> item < 3); } public void conditionFilter(List<Integer> list, Predicate<Integer> predicate) { for (Integer integer : list) { if (predicate.test(integer)) { System.out.println(integer); } } } } \",\"可以想象，如果要使用传统的方式实现这些需求，我们就必须要编写很多个具体的方法，但是如果使用Lambda表达式，我们就可以定义一个通用的函数，具体的行为在调用的时候再传入。\",\"Predicate中除了抽象方法test()，还有：\",\" /** * Returns a composed predicate that represents a short-circuiting logical * AND of this predicate and another. When evaluating the composed * predicate, if this predicate is {@code false}, then the {@code other} * predicate is not evaluated. * * <p>Any exceptions thrown during evaluation of either predicate are relayed * to the caller; if evaluation of this predicate throws an exception, the * {@code other} predicate will not be evaluated. * * @param other a predicate that will be logically-ANDed with this * predicate * @return a composed predicate that represents the short-circuiting logical * AND of this predicate and the {@code other} predicate * @throws NullPointerException if other is null */ default Predicate<T> and(Predicate<? super T> other) { Objects.requireNonNull(other); return (t) -> test(t) && other.test(t); } \",\"这个函数表示当前的Predicate与另一个Predicate的短路与，当计算这个复合函数的时候，如果前面的Predicate的值为false,那么后面的将不再会被计算，如果在计算过程中，任何一个Predicate会抛出异常的话，怎么做取决于调用者，如果当前的Predicate抛出了异常，那么后者也不会被计算。\",\" /** * Returns a predicate that represents the logical negation of this * predicate. * * @return a predicate that represents the logical negation of this * predicate */ default Predicate<T> negate() { return (t) -> !test(t); } \",\"negate本身是否定的意思，表示返回当前Predicate的逻辑非。\",\" /** * Returns a composed predicate that represents a short-circuiting logical * OR of this predicate and another. When evaluating the composed * predicate, if this predicate is {@code true}, then the {@code other} * predicate is not evaluated. * * <p>Any exceptions thrown during evaluation of either predicate are relayed * to the caller; if evaluation of this predicate throws an exception, the * {@code other} predicate will not be evaluated. * * @param other a predicate that will be logically-ORed with this * predicate * @return a composed predicate that represents the short-circuiting logical * OR of this predicate and the {@code other} predicate * @throws NullPointerException if other is null */ default Predicate<T> or(Predicate<? super T> other) { Objects.requireNonNull(other); return (t) -> test(t) || other.test(t); } \",\"类似的，这个方法是计算逻辑或的操作，如果当前的Predicate是true的话，后面的将不会再被计算，关于Predicate的三个默认方法，我们来看具体例子：\",\"public class PredicateTest2 { public static void main(String[] args) { List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); PredicateTest2 predicateTest2 = new PredicateTest2(); // 找到集合中所有的偶数 predicateTest2.conditionFilter(list, item -> item % 2 == 0); // 找到集合中所有的奇数 predicateTest2.conditionFilter(list, item -> item % 2 != 0); // 找到集合中所有大于5的数 predicateTest2.conditionFilter(list, item -> item > 5); // 找到集合中所有小于3的数 predicateTest2.conditionFilter(list, item -> item < 3); // 找到集合中所有大于5并且是偶数的数 predicateTest2.conditionFilter2(list, item -> item > 5, item -> item % 2 == 0); // 找到集合中所有大于5或者是偶数的数 predicateTest2.conditionFilter3(list, item -> item > 5, item -> item % 2 == 0); predicateTest2.conditionFilter4(list, item -> item > 5, item -> item % 2 == 0); } public void conditionFilter(List<Integer> list, Predicate<Integer> predicate) { for (Integer integer : list) { if (predicate.test(integer)) { System.out.println(integer); } } } public void conditionFilter2(List<Integer> list, Predicate<Integer> predicate, Predicate<Integer> predicate2) { for (Integer integer : list) { if (predicate.and(predicate2).test(integer)) { System.out.println(integer); } } } public void conditionFilter3(List<Integer> list, Predicate<Integer> predicate, Predicate<Integer> predicate2) { for (Integer integer : list) { if (predicate.or(predicate2).test(integer)) { System.out.println(integer); } } } public void conditionFilter4(List<Integer> list, Predicate<Integer> predicate, Predicate<Integer> predicate2) { for (Integer integer : list) { if (predicate.or(predicate2).negate().test(integer)) { System.out.println(integer); } } } } \",\"最后我们来看一下它唯一的static方法：\",\" /** * Returns a predicate that tests if two arguments are equal according * to {@link Objects#equals(Object, Object)}. * * @param <T> the type of arguments to the predicate * @param targetRef the object reference with which to compare for equality, * which may be {@code null} * @return a predicate that tests if two arguments are equal according * to {@link Objects#equals(Object, Object)} */ static <T> Predicate<T> isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -> targetRef.equals(object); } \",\"用来根据Objects类中的equals()方法判断两个参数是不是相等，注意，这里并不是Object类，而是Objects，这是从JDK1.7之后新增加的类。 Objects::isNull是一个静态方法的方法引用，\",\" public static boolean isNull(Object obj) { return obj == null; } \",\"来看具体的例子：\",\"public class PredicateTest3 { public static void main(String[] args) { PredicateTest3 predicateTest3 = new PredicateTest3(); System.out.println(predicateTest3.isEqual(\\\"test\\\").test(new Date())); } public Predicate<Date> isEqual(Object object) { return Predicate.isEqual(object); } } \",\"本质上这个其实\\\"test\\\".equals(new Date())，那么显然结果是false。\"]},\"1600\":{\"h\":\"Supplier函数式接口\",\"t\":[\"同样的，我们来看一下Supplier函数式接口的文档：\",\"/** * Represents a supplier of results. * * <p>There is no requirement that a new or distinct result be returned each * time the supplier is invoked. * * <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> * whose functional method is {@link #get()}. * * @param <T> the type of results supplied by this supplier * * @since 1.8 */ @FunctionalInterface public interface Supplier<T> { /** * Gets a result. * * @return a result */ T get(); } \",\"首先来看类的说明：\",\"Represents a supplier of results. There is no requirement that a new or distinct result be returned each time the supplier is invoked. \",\"Supplier表示提供结果的供应者，它每次被调用的时候无需保证返回不同的结果，换言之，每次被调用的结果可能是相同的。\",\"Supplier不接受参数，并返回一个结果。\",\"我们来新建一个测试类：\",\"public class SupplierJyc { public static void main(String[] args) { Supplier<String> supplierJyc = () -> \\\"hello word\\\"; System.out.println(supplierJyc.get()); } } \",\"显然，控制台会打印出以下结果：\",\"> Task :SupplierJyc.main() hello word \",\"实际上，Supplier更多的适用于工厂创建对象，下面我们用具体的例子来说明，首先创建一个Student类，并生成无参构造方法和setter及getter方法：\",\"public class Student { private String name = \\\"zhangsan\\\"; private int age = 20; public Student() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } \",\"下面我们使用Supplier来创建一个对象：\",\"public class StudentTest { public static void main(String[] args) { Supplier<Student> supplier = () -> new Student(); System.out.println(supplier.get().getName()); } } \",\"正式由于Supplier这个函数式接口不接收参数，并且返回一个泛型T类型的对象，所以() -> new Student()就是Supplier函数式接口的一个实例。除了通过这种方式创建实例外，我们还可以使用一种特殊的方式来创建Supplier的实例，即对象引用：\",\"public class StudentTest { public static void main(String[] args) { Supplier<Student> supplier = () -> new Student(); System.out.println(supplier.get().getName()); System.out.println(\\\"--------------\\\"); Supplier<Student> supplier2 = Student::new; System.out.println(supplier2.get().getName()); } } \",\"这会与上面的代码得到相同的结果，如果点击Student::new中的new的话，会自动跳转到Student的无参构造的地方：\",\" public Student() { } \",\"说明这个新的语法就是在调用Student的无参构造来创建对象，而这个无参构造刚好满足不接受参数，只返回对象的Supplier函数式接口的要求，所以创建了Student的实例。\",\"当我们修改这个类的默认构造方法，去掉没有参数的构造方法：\",\" public Student(String name) { this.name = name; } \",\"编译器就会提示我们不能解析构造方法,这也验证了我们之前的说法。\",\"以上就是几个最基础也是最重要的几个函数式接口，在此基础上，JDK还为我们提供了一些其他的函数式接口，例如BinaryOperator，他们可以看成是前面几个函数式接口的扩展。\"]},\"1601\":{\"h\":\"函数式接口扩展\",\"t\":[\"相同的方式，我们首先来阅读一下BinaryOperator这个函数式接口的文档：\",\"/** * Represents an operation upon two operands of the same type, producing a result * of the same type as the operands. This is a specialization of * {@link BiFunction} for the case where the operands and the result are all of * the same type. * * <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> * whose functional method is {@link #apply(Object, Object)}. * * @param <T> the type of the operands and result of the operator * * @see BiFunction * @see UnaryOperator * @since 1.8 */ @FunctionalInterface public interface BinaryOperator<T> extends BiFunction<T,T,T> { /** * Returns a {@link BinaryOperator} which returns the lesser of two elements * according to the specified {@code Comparator}. * * @param <T> the type of the input arguments of the comparator * @param comparator a {@code Comparator} for comparing the two values * @return a {@code BinaryOperator} which returns the lesser of its operands, * according to the supplied {@code Comparator} * @throws NullPointerException if the argument is null */ public static <T> BinaryOperator<T> minBy(Comparator<? super T> comparator) { Objects.requireNonNull(comparator); return (a, b) -> comparator.compare(a, b) <= 0 ? a : b; } /** * Returns a {@link BinaryOperator} which returns the greater of two elements * according to the specified {@code Comparator}. * * @param <T> the type of the input arguments of the comparator * @param comparator a {@code Comparator} for comparing the two values * @return a {@code BinaryOperator} which returns the greater of its operands, * according to the supplied {@code Comparator} * @throws NullPointerException if the argument is null */ public static <T> BinaryOperator<T> maxBy(Comparator<? super T> comparator) { Objects.requireNonNull(comparator); return (a, b) -> comparator.compare(a, b) >= 0 ? a : b; } } \",\"首先来看类的说明：\",\"Represents an operation upon two operands of the same type, producing a result of the same type as the operands. This is a specialization of BiFunction for the case where the operands and the result are all of the same type. This is a functional interface whose functional method is apply(Object, Object). \",\"BinaryOperator表示针对于两个相同运算对象的操作，并且生成与运算对象相同类型的结果类型，这是当使用BiFunction运算对象与结果类型相同时候的一个特例，我们知道，在BiFunction中，类型可以是不相同的：\",\"BiFunction<T, U, R> \",\"同时其中的抽象方法apply()，也接收了两个不同类型的参数，并且返回了不同类型的结果：\",\"R apply(T t, U u); \",\"当类型相同的时候，就变成了：\",\" BinaryOperator<T> extends BiFunction<T,T,T> \",\"apply()方法也就变成了：\",\"T apply(T t, T u); \",\"BinaryOperator中还有两个静态方法，首先来看minBy()的说明：\",\"Returns a BinaryOperator which returns the lesser of two elements according to the specified Comparator. \",\"minBy()方法会根据比较器Comparator返回两个元素中比较小的那一个，来看一个具体的例子，我们给定两个字符串，来返回比较小的那一个：\",\"public class BinaryOperatorTest { public static void main(String[] args) { BinaryOperatorTest binaryOperatorTest = new BinaryOperatorTest(); System.out.println(binaryOperatorTest.getShort(\\\"hellohello\\\", \\\"hello\\\", (a, b) -> a.length() - b.length())); System.out.println(binaryOperatorTest.getShort(\\\"hellohello\\\", \\\"hello\\\", (a, b) -> a.charAt(0) - b.charAt(0))); } public String getShort(String a, String b, Comparator<String> comparator) { return BinaryOperator.minBy(comparator).apply(a, b); } } \",\"显然使用maxBy()方法会获得相反的结果。\",\"其实在java.util.function这个包下面，还有很多的其他的函数式接口，比如BiConsumer，BiFunction，LongPredicate，IntSupplier等等，这些都是对于这几个基础的函数式接口的有力的补充，也是这几个基础的函数式接口的特例。\"]},\"1602\":{\"h\":\"方法引用\",\"t\":[\"public class MethodReferenceDemo { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); list.forEach(System.out::println); } } \",\"这个例子中的::就是JDK8中新增的语法，叫做方法引用，它可以看成是Lambda表达式的一种语法糖，如果所使用的Lambda表达式恰好被实现过的话，就可以使用方法引用来写出更加简洁的代码，我们可以将方法引用看作是一个【函数指针（function pointer）】。\",\"方法引用共分为4类：静态方法引用、构造方法引用、类的任意对象的实例方法引用、特定对象的实例方法引用，对于其中的每一种，我们都会给出Lambda表达式的方式和方法引用的方式实现相同的功能，以此来对照学习。\"]},\"1603\":{\"h\":\"静态方法引用\",\"t\":[\"首先定义一个类：\",\"public class Student { private String name; private int score; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getScore() { return score; } public void setScore(int score) { this.score = score; } public static int compareStudentByScore(Student student1, Student student2) { return student1.score - student2.score; } private static int compareStudentByName(Student student1, Student student2) { return student1.getName().compareToIgnoreCase(student2.getName()); } } \",\"接下来我们使用List集合中新增加的sort方法进行排序：\",\"public class MethodReferenceDemo { public static void main(String[] args) { Student student1 = new Student(\\\"zhangsan\\\", 10); Student student2 = new Student(\\\"lisi\\\", 90); Student student3 = new Student(\\\"wangwu\\\", 50); Student student4 = new Student(\\\"zhaoliu\\\", 40); List<Student> students = Arrays.asList(student1, student2, student3, student4); students.sort((studentParam1, studentParam2) -> Student.compareStudentByScore(studentParam1, studentParam2)); students.forEach(student -> System.out.println(student.getScore())); } } \",\"这里我们排序的时候直接调用的是List集合中的默认方法sort（），这也是在JDK8中新增加的方法：\",\" default void sort(Comparator<? super E> c) { Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator<E> i = this.listIterator(); for (Object e : a) { i.next(); i.set((E) e); } } \",\"可以看到其接收Comparator作为参数，我们再来看一下Comparator的类定义情况：\",\"@FunctionalInterface public interface Comparator<T> { int compare(T o1, T o2); } \",\"可以看到这是一个函数式接口，并且接收两个相同类型的参数，并且返回一个Int值，它会根据定义好的排序规则，如果第一个参数大于第二个参数，那么会返回正数，相等会返回0，小于会返回负数，针对于以上的例子，Student类中的静态方法compareStudentByScore恰好是接收两个参数，并且返回一个结果，所以可以作为Comparator这个Lambda表达式的方法体，其实我们还可以使用方法引用的方式，来完成相同的功能：\",\"public class MethodReferenceDemo { public static void main(String[] args) { Student student1 = new Student(\\\"zhangsan\\\", 10); Student student2 = new Student(\\\"lisi\\\", 90); Student student3 = new Student(\\\"wangwu\\\", 50); Student student4 = new Student(\\\"zhaoliu\\\", 40); List<Student> students = Arrays.asList(student1, student2, student3, student4); // students.sort((studentParam1, studentParam2) -> Student.compareStudentByScore(studentParam1, studentParam2)); // students.forEach(student -> System.out.println(student.getScore())); System.out.println(\\\"==================================\\\"); students.sort(Student::compareStudentByScore); students.forEach(student -> System.out.println(student.getScore())); } } \",\"这两种方式的效果完全等价，换言之，在这个场景下，方法引用与Lambda表达式完全等价，方法引用是Lambda表达式的一种语法糖，只有当某一个已经存在的方法，恰好满足了Lambda表达式的要求，才可以使用方法引用，Lambda表达式其实是一种更为通用的形式，而方法引用则需要满足一些条件才能使用。\"]},\"1604\":{\"h\":\"实例方法引用\",\"t\":[\"我们依然使用排序这个例子，这次我们使用另一种写法来完成这个功能，首先定义一个这样的类：\",\"public class StudentComparator { public int compareStudentByScore(Student student1, Student student2) { return student1.getScore() - student2.getScore(); } public int compareStudentByName(Student student1, Student student2) { return student1.getName().compareToIgnoreCase(student2.getName()); } } \",\"然后来实现对于Student的排序：\",\"public class MethodReferenceDemo { public static void main(String[] args) { Student student1 = new Student(\\\"zhangsan\\\", 10); Student student2 = new Student(\\\"lisi\\\", 90); Student student3 = new Student(\\\"wangwu\\\", 50); Student student4 = new Student(\\\"zhaoliu\\\", 40); StudentComparator studentComparator = new StudentComparator(); students.sort((studentParam1, studentParam2) -> studentComparator. compareStudentByScore(studentParam1, studentParam2)); students.forEach(student -> System.out.println(student.getScore())); } } \",\"这里我们直接使用StudentComparator实例中的compareStudentByScore来进行排序，事实上，这种场景下，也可以使用方法引用来替代：\",\"public class MethodReferenceDemo { public static void main(String[] args) { Student student1 = new Student(\\\"zhangsan\\\", 10); Student student2 = new Student(\\\"lisi\\\", 90); Student student3 = new Student(\\\"wangwu\\\", 50); Student student4 = new Student(\\\"zhaoliu\\\", 40); List<Student> students = Arrays.asList(student1, student2, student3, student4); StudentComparator studentComparator = new StudentComparator(); students.sort(studentComparator::compareStudentByScore); students.forEach(student -> System.out.println(student.getScore())); System.out.println(\\\"==================================\\\"); students.sort(studentComparator::compareStudentByName); students.forEach(student -> System.out.println(student.getName())); } } \",\"与静态方法引用的不同的是，这里我们调用的是类实例的方法。\"]},\"1605\":{\"h\":\"实例方法名引用\",\"t\":[\"首先，在Student类中，我们增加一个方法：\",\"package lambda; /** * 2 * @Author: jiyongchao * 3 * @Date: 2020/8/20 23:56 * 4 */ public class Student { private String name; private int score; public Student(String name, int score) { this.name = name; this.score = score; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getScore() { return score; } public void setScore(int score) { this.score = score; } public static int compareStudentByScore(Student student1, Student student2) { return student1.score - student2.score; } private static int compareStudentByName(Student student1, Student student2) { return student1.getName().compareToIgnoreCase(student2.getName()); } public int compareByScore(Student student) { return this.getScore() - student.getScore(); } public int compareByName(Student student) { return this.getName().compareToIgnoreCase(student.getName()); } } \",\"在之前的例子中，compareStudentByScore与compareStudentByName方法实际上是我们有意为之的，实际上这两个静态方法放在任何一个类中，都是可以调用的，通常我们比较两个对象时，更多的情况是，传入一个对象，并与当前对象进行比较，这也是新增加的compareByScore和compareByName的作用，在这种情况下，排序规则又可以做出如下修改：\",\"public class MethodReferenceDemo { public static void main(String[] args) { Student student1 = new Student(\\\"zhangsan\\\", 10); Student student2 = new Student(\\\"lisi\\\", 90); Student student3 = new Student(\\\"wangwu\\\", 50); Student student4 = new Student(\\\"zhaoliu\\\", 40); List<Student> students = Arrays.asList(student1, student2, student3, student4); students.sort(Student::compareByName); students.forEach(student -> System.out.println(student.getName())); } } \",\"我们再举一个例子，来加深对于实例方法名引用的理解：\",\"public class MethodReferenceDemo { public static void main(String[] args) { List<String> cities = Arrays.asList(\\\"qingdao\\\", \\\"chongqing\\\", \\\"tianjin\\\", \\\"beijing\\\"); Collections.sort(cities, (city1, city2) -> city1.compareToIgnoreCase(city2)); cities.forEach(city -> System.out.println(city)); Collections.sort(cities, String::compareToIgnoreCase); cities.forEach(city -> System.out.println(city)); } } \",\"这个时候，再回到集合遍历的例子当中：\",\"System.out::println() \",\"实际上，查看System源码可以发现out实际上是PrintStream的一个对象：\",\" public final static PrintStream out = null; \",\"而println()方法就是PrintStream中的一个方法：\",\" public void println(double x) { synchronized (this) { print(x); newLine(); } } \"]},\"1606\":{\"h\":\"构造方法引用\",\"t\":[\"前面我们介绍过的Supplier函数式接口其中一个很重要的应用就是构造方法引用，因为其不接收参数，返回值的特性正好与构造方法的作用不谋而合，所以，我们可以很轻松的写出如下代码：\",\"public class MethodReferenceDemo { public String getString(Supplier<String> supplier) { return supplier.get() + \\\"test\\\"; } public static void main(String[] args) { MethodReferenceDemo methodReferenceDemo = new MethodReferenceDemo(); System.out.println(methodReferenceDemo.getString(String::new)); } } \",\"除了无参构造，还可以调用有参数的构造方法，这个时候就变成了接收一个参数，返回值：\",\"public class MethodReferenceDemo { public String getString2(String str, Function<String, String> function) { return function.apply(str); } public static void main(String[] args) { MethodReferenceDemo methodReferenceDemo = new MethodReferenceDemo(); System.out.println(methodReferenceDemo.getString2(\\\"hello\\\", String::new)); } } \"]},\"1607\":{\"h\":\"默认方法\",\"t\":[\"在方法引用的最后，我们补充一些关于JDK8中默认方法的相关介绍，首先定义这样两个接口，接口中有同名的默认方法：\",\"public interface MyInterface1 { default void myMethod() { System.out.println(\\\"MyInterface1\\\"); } } \",\"public interface MyInterface2 { default void myMethod() { System.out.println(\\\"MyInterface2\\\"); } } \",\"这个时候，假设有一个类，要实现这两个接口，但是由于这两个接口中有同名的默认方法，所以，编译器无法自动推断出要继承哪一个接口中的默认方法，一般这个时候，处理方式有两种，一种是在实现类中重写方法：\",\"public class MyClass implements MyInterface1, MyInterface2 { @Override public void myMethod() { System.out.println(\\\"MyInterface1\\\"); } public static void main(String[] args) { MyClass myClass = new MyClass(); myClass.myMethod(); } } \",\"这种方式的弊端在于，我们需要将某一个子类中的默认方法实现重写一遍，如果代码很多，既费时，可维护性也比较差，好在JDK为我们提供了另一种方式来完成：\",\"public class MyClass implements MyInterface1, MyInterface2 { @Override public void myMethod() { MyInterface1.super.myMethod(); } public static void main(String[] args) { MyClass myClass = new MyClass(); myClass.myMethod(); } } \",\"对于以上例子我们再做一个小的扩展，增加一个MyInterface1的实现类：\",\"public class MyInterface1Impl implements MyInterface1 { @Override public void myMethod() { System.out.println(\\\"MyInterface1Impl\\\"); } } \",\"这个时候，我们再定义一个类，这个类继承MyInterface1Impl，并且实现MyInterface2：\",\"public class MyClass2 extends MyInterface1Impl implements MyInterface2 { public static void main(String[] args) { MyClass2 myClass2 = new MyClass2(); myClass2.myMethod(); } } \",\"这个时候调用当前类的myMethod()方法并不会报错，也就是说，编译器自动推断出了我们要想调用MyInterface1Impl中的myMethod()方法，还是MyInterface2中的默认方法myMethod()，这实际上是JDK中的一个约定，编译器会认为继承的优先级大于实现，类中的方法才表示具体的行为，而接口更多的时候还是表示一种模板或者契约。\",\"增加默认方法的特性是Java对于支持函数式编程一个非常重要的改变，在上面排序的例子中可以看到，List这样一个顶层的集合增加了排序的方法，试想，如果没有默认方法，那对于想从JDK7升级到JDK8的人无疑是一场灾难，如果一旦在自己的代码实现过List，那意味你需要重写所有的子类，而JDK在很多的接口中都增加了默认方法，为了升级JDK还需要入侵式的修改客户端的代码，这显然是不合适的，那为什么还会增加默认方法的机制呢？其目的，就是为了更为方便的编写函数式的代码，同时也是为了向后兼容的一种妥协，从这一个层面来说，Java的函数式编程并不是完美无暇的，更像是一个裹足前行的人，这也是面向对象带来限制，但我们还是非常振奋，JDK8使我们看到了Java这门古老的语言的全新面貌。\",\"增加默认方法也可以看到，接口和抽象类的区别越来越小了。\",\"在前面的章节我们花费了不少的章节整理了Lambda表达式的相关特性，也举出了不少的例子来展示了Lambda表达式的应用，但总有种纸上谈兵的感觉，还是无法理解Lambda表达式到底可以帮我们做哪些事情？函数式编程又指的是什么？在接下来的章节中，我们就会围绕这两个问题展开。\",\"实际上，Lambda表达式在大多数的场景下，都是与Stream相伴出现的，两个配合使用，更加高效、简洁、优雅的处理集合相关的问题。\",\"首先我们需要了解一些Stream的基本概念，学会新的API使用，在不断的实践中，最后探究Stream的实现原理。一般而言Stream由3个部分组成：\",\"源\",\"零个或多个中间操作\",\"终止操作\",\"流操作的分类又有两种：\",\"惰性求值\",\"及早求值\",\"Stream也可以分为并行流和串行流，可以通过非常简单的方式，就是使用并发来加快运行的效率。\",\"我们首先使用不同的方式来创建一个Stream对象：\",\"public class StreamTest { public static void main(String[] args) { Stream stream1 = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); } } \",\"为什么可以这样创建呢？不妨查看一下Stream这个类中的of()方法：\",\" public static<T> Stream<T> of(T... values) { return Arrays.stream(values); } \",\"可以看到这是一个静态方法，本身接受的是可变参数，并且会调用Arrays中的stream方法：\",\" public static <T> Stream<T> stream(T[] array) { return stream(array, 0, array.length); } \",\"其中的\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"就称之为源，源的意思就是要操作的数据对象，使用相似的方式，我们还可以这样创建Stream：\",\"public class StreamTest { public static void main(String[] args) { Stream stream1 = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); String[] myArray = new String[]{\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"}; Stream stream2 = Stream.of(myArray); Stream stream3 = Arrays.stream(myArray); } } \",\"本质上而言，这几种创建Stream的方式并没有什么区别，其实最常见的，是采用下面的方式来创建流：\",\"public class StreamTest { public static void main(String[] args) { List<String> list = Arrays.asList(myArray); Stream stream = list.stream(); } } \",\"以上就是关于如何创建流的对象的例子，接下来我们看看引入Stream会为我们的编码带来什么样的改变，首先我们创建一个Stream，并且调用它的forEach（）方法：\",\"public class StreamTest2 { public static void main(String[] args) { Stream.of(new int[]{5, 6, 7}).forEach(System.out::println); } } \",\"在这段代码中，我们首先创建了一个元素为5，6，7的Stream对象，并且调用forEach()方法，对流中的每一个元素执行打印的操作。\",\"Stream本身其实也提供了针对与特定数据类型的具化的Stream对象，用来避免自动拆箱装箱带来的性能的损耗，所以这段代码也可以这么写：\",\"public class StreamTest2 { public static void main(String[] args) { IntStream.of(new int[]{5, 6, 7,}).forEach(System.out::println); } } \",\"再举一个例子：\",\"public class StreamTest2 { public static void main(String[] args) { IntStream.range(3, 8).forEach(System.out::println); } } \",\"这样我们就在控制台打印了3到7，我们可以来了解一下这个range()方法：\",\" public static IntStream range(int startInclusive, int endExclusive) { if (startInclusive >= endExclusive) { return empty(); } else { return StreamSupport.intStream( new Streams.RangeIntSpliterator(startInclusive, endExclusive, false), false); } } \",\"可以看到这个方法返回的是包含最小值，不包含最大值的IntStream对象，那如果要包含最大值改怎么做呢？一种方式当然可以调整范围，比如，可以设置范围是（3，9）就可以打印3到8的内容，也可以调用另一个方法：\",\"IntStream.rangeClosed(3, 8).forEach(System.out::println); \",\"我们不妨来看一下这个方法的源码：\",\" public static IntStream rangeClosed(int startInclusive, int endInclusive) { if (startInclusive > endInclusive) { return empty(); } else { return StreamSupport.intStream( new Streams.RangeIntSpliterator(startInclusive, endInclusive, true), false); } } \",\"这样，就顺利的同时包含了较小的值和较大的值。\",\"上面的例子看起来还是相对而言比较简陋的，接下来我们给出一个稍微复杂一点的示例：\",\"public class StreamTest3 { public static void main(String[] args) { List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6); System.out.println(list.stream().map(i -> 2 * i).reduce(0, Integer::sum)); } } \",\"这里我们对于集合中的元素先乘以2，然后求和，这里的map描述的是一种映射，而reduce描述的一种聚合，只有当表达式中具有reduce这样的终止操作的方法的时候，流才会被真正的执行，这就是所谓的终止操作，而map就称之为中间操作。不难看出，与传统的方式，使用函数式的方式，代码变的异常简洁和优雅。\"]},\"1608\":{\"h\":\"Stream类源码解析\",\"t\":[\"在初步了解了Sream给我们来了些什么之后，我们来了解一些关于流的特性：\",\"Collection提供了新的Stream()方法\",\"流不存储值，通过管道的方式获取值\",\"本质是函数式的，对流的操作会生成一个结果，不过并不会修改底层的数据源，集合可以作为流的底层数据源\",\"延迟查找，很多流操作（过滤、映射、排序等）都可以延迟实现\",\"接下来再通过一些实际的例子，来加深对于Stream的理解：\",\"public class StreamTest4 { public static void main(String[] args) { Stream<String> stream = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"helloworld\\\"); String[] stringArray = stream.toArray(length -> new String[length]); String[] strings = stream.toArray(String[]::new); Arrays.asList(stringArray).forEach(System.out::println); } } \",\"上面的例子创建Stream的，那Stream是如何转变成我们常用的List集合呢？这里就要说明一个及其重要的方法collect()：\",\"public class StreamTest4 { public static void main(String[] args) { Stream<String> stream = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"helloworld\\\"); List<String> list = stream.collect(Collectors.toList()); list.forEach(System.out::println); } } \",\"collect()方法是有几个重载的方法，我们来看接收参数最多的这个：\",\" /** * Performs a <a href=\\\"package-summary.html#MutableReduction\\\">mutable * reduction</a> operation on the elements of this stream. A mutable * reduction is one in which the reduced value is a mutable result container, * such as an {@code ArrayList}, and elements are incorporated by updating * the state of the result rather than by replacing the result. This * produces a result equivalent to: * <pre>{@code * R result = supplier.get(); * for (T element : this stream) * accumulator.accept(result, element); * return result; * }</pre> * * <p>Like {@link #reduce(Object, BinaryOperator)}, {@code collect} operations * can be parallelized without requiring additional synchronization. * * <p>This is a <a href=\\\"package-summary.html#StreamOps\\\">terminal * operation</a>. * * @apiNote There are many existing classes in the JDK whose signatures are * well-suited for use with method references as arguments to {@code collect()}. * For example, the following will accumulate strings into an {@code ArrayList}: * <pre>{@code * List<String> asList = stringStream.collect(ArrayList::new, ArrayList::add, * ArrayList::addAll); * }</pre> * * <p>The following will take a stream of strings and concatenates them into a * single string: * <pre>{@code * String concat = stringStream.collect(StringBuilder::new, StringBuilder::append, * StringBuilder::append) * .toString(); * }</pre> * * @param <R> type of the result * @param supplier a function that creates a new result container. For a * parallel execution, this function may be called * multiple times and must return a fresh value each time. * @param accumulator an <a href=\\\"package-summary.html#Associativity\\\">associative</a>, * <a href=\\\"package-summary.html#NonInterference\\\">non-interfering</a>, * <a href=\\\"package-summary.html#Statelessness\\\">stateless</a> * function for incorporating an additional element into a result * @param combiner an <a href=\\\"package-summary.html#Associativity\\\">associative</a>, * <a href=\\\"package-summary.html#NonInterference\\\">non-interfering</a>, * <a href=\\\"package-summary.html#Statelessness\\\">stateless</a> * function for combining two values, which must be * compatible with the accumulator function * @return the result of the reduction */ <R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner); \",\"collect方法接收三个参数，其中的BiConsumer是接收两个参数，并且没有返回值的函数式接口：\",\"@FunctionalInterface public interface BiConsumer<T, U> void accept(T t, U u); } \",\"我们来阅读一下collect方法的说明：\",\"Performs a mutable reduction operation on the elements of this stream. A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList, and elements are incorporated by updating the state of the result rather than by replacing the result. This produces a result equivalent to: \",\"对流当中的元素进行可变的汇聚操作，一个可变的汇聚操作指的是将值汇聚到可变的结果容器，比如ArrayList，并且这个容器是通过更新结果的状态来进行合并的，而不是通过替换结果进行合并的，这个结果相当于下面这段代码：\",\" R result = supplier.get(); for (T element : this stream) accumulator.accept(result, element); return result; \",\"首先会通过supplier.get()方法获取到结果集，然后对流中的元素进行遍历，遍历执行累加器accumulator中的accept，最后返回结果，这里总共有三个步骤，对应的就是collect方法的三个函数式接口：\",\" <R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner); \",\"我们来举一个具体的例子来说明，这段文字的含义：\",\"public class StreamTest4 { public static void main(String[] args) { Stream<String> stream = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"helloworld\\\"); List<String> list = stream.collect(() -> new ArrayList<String>(), (theList, item) -> theList.add(item),(theList1, theList2) -> theList1.addAll(theList2)); } } \",\"supplier就是我们要返回的结果，这里我们选择new一个ArrayList作为返回的容器，accumulator是我们要把流中的元素添加到要返回的结果容器当中，所以这里调用List的add()方法，将流中的元素依次添加到我们新new出来的ArrayList当中，每次将流中的元素添加到的ArrayList时都会新newArrayList，combiner是将上一次返回的结果，添加到的最终的结果theList1当中，当然，这个方法我们也可以用方法引用来完成：\",\" stream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll); \",\"理解了三个参数具体的作用我们具体再往下看：\",\"Like reduce(Object, BinaryOperator), collect operations can be parallelized without requiring additional synchronization.This is a terminal operation. \",\"就像reduce一样，collect无需其他操作就可以很好的支持并行流，并且也是一个终止操作，这也是流式编程给我们带来的好处。\",\"There are many existing classes in the JDK whose signatures are well-suited for use with method references as arguments to collect(). \",\"在JDK中有很多的方法都可以采用方法引用的方式，作为collect()的参数，这里举了两个例子，一个正是我们前面举出的例子：\",\" List<String> asList = stringStream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll); \",\"还有一个例子：\",\" String concat = stringStream.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString(); \",\"这里使用StringBuilder作为最终返回的结果容器，遍历集合中的单个的字符串，最终将他们拼接起来。\",\"最后我们来看一下对于参数的说明：\",\"supplier – a function that creates a new result container. For a parallel execution, this function may be called multiple times and must return a fresh value each time.\",\"accumulator – an associative, non-interfering, stateless function for incorporating an additional element into a result\",\"combiner – an associative, non-interfering, stateless function for combining two values, which must be compatible with the accumulator function\",\"supplier会创建一个新的结果容器，在并行流中可能会多次调用，所以它每次返回的一定是一个新的结果容器，accumulator，它是一个相关的，不冲突的，可关联的一个无状态的一个函数，用于将一个额外的元素合并到结果容器当中，combiner用于合并两个值，它必须和accumulator 是兼容的。\",\"最后我们可以看一个JDK实现的一个例子：\",\" public static <T> Collector<T, ?, List<T>> toList() { return new CollectorImpl<>((Supplier<List<T>>) ArrayList::new, List::add, (left, right) -> { left.addAll(right); return left; }, CH_ID); } \"]},\"1609\":{\"h\":\"Stream实例剖析\",\"t\":[\"首先来看一个具体的例子：\",\"public class StreamTest4 { public static void main(String[] args) { Stream<String> stream = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"helloworld\\\"); ArrayList<String> list = stream.collect(Collectors.toCollection(ArrayList::new)); list.forEach(System.out::println); } } \",\"这里我们使用的Collectors类中的toCollection()方法：\",\"public static <T, C extends Collection<T>> Collector<T, ?, C> toCollection(Supplier<C> collectionFactory) { return new CollectorImpl<>(collectionFactory, Collection<T>::add, (r1, r2) -> { r1.addAll(r2); return r1; }, CH_ID); } \",\"可以看到，它接受一个Supplier参数，这里我们使用构方法引用的方式，这实际上是一种比起toList()更为通用的写法，使用toCollection可以很方便的自定义返回结果容器的类型，比如我们要返回一个LinkedList，我们只需要：\",\"LinkedList<String> list = stream.collect(Collectors.toCollection(LinkedList::new)); \",\"除了将流转化为List，我们也可以转化为Set、Map等，例如：\",\"public class StreamTest4 { public static void main(String[] args) { TreeSet<String> set = stream.collect(Collectors.toCollection(TreeSet::new)); set.forEach(System.out::println); } } \",\"上一章节中，JDK中举出的拼接字符串的例子，实际上在Collectors中有一种更为简洁的实现方案：\",\"public class StreamTest4 { public static void main(String[] args) { Stream<String> stream = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"helloworld\\\"); String str = stream.collect(Collectors.joining()).toString(); } } \",\"之前我们举的例子要么是将集合转化为Stream，要么是将Stream转化为集合，实际使用的时候，需要两者配合使用，举一个这样的例子，将集合中的字符串传化为大写并打印：\",\"public class StreamTest5 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"helloworld\\\", \\\"test\\\"); list.stream().map(String::toUpperCase).collect(Collectors.toList()). forEach(System.out::println); } } \",\"类似这样的代码，才是在实际应用中使用的最多的，其中的map()是JDK为我们提供的API，表示一种映射关系，将集合中的元素映射成后面表达式的结果的操作，再比如，要求出集合中每一个元素的平方并打印：\",\"public class StreamTest5 { public static void main(String[] args) { List<Integer> list2 = Arrays.asList(1, 2, 3, 4); list2.stream().map(item -> item * item).collect(Collectors.toList()). forEach(System.out::println); } } \",\"与map比较类似的还有一个flatmap()方法，它表示将流中元素的界限打破，最终返回一个整体，举个例子：\",\"public class StreamTest5 { public static void main(String[] args) { Stream<List<Integer>> stream = Stream.of(Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6)); stream.flatMap(theList -> theList.stream().map(item -> item * item)).forEach(System.out::println); } } \",\"这里我们首先对于流中的集合进行了平方的操作，然后将所有的元素作为一个整体进行打印。\",\"再来看一个map和flatMap例子，假设我们要对一个集合中的元素提取出单词并去重：\",\"public class StreamTest11 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello welcome\\\", \\\"world hello\\\", \\\"hello world hello\\\", \\\"hello welcome\\\"); list.stream().map(item -> item.split(\\\" \\\")).distinct().collect(Collectors.toList()).forEach(System.out::println); } } \",\"运行的结果：\",\"[Ljava.lang.String;@4eec7777 [Ljava.lang.String;@3b07d329 [Ljava.lang.String;@41629346 [Ljava.lang.String;@404b9385 \",\"这显然是不对的，原因就在于这里我们使用map返回的类型实际上变成了String[]，自然的，后续的去重操作当然也都失败了，那如果要实现这个需求改怎么做呢？就需要调用flatMap方法：\",\"public class StreamTest11 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello welcome\\\", \\\"world hello\\\", \\\"hello world hello\\\", \\\"hello welcome\\\"); list.stream().map(item -> item.split(\\\" \\\")).flatMap(Arrays::stream).distinct(). collect(Collectors.toList()).forEach(System.out::println); } } \",\"再举这样一个例子来加深对于flatMap理解的场景，比如我们要获取两个集合的笛卡尔积，我们就可以：\",\"public class StreamTest12 { public static void main(String[] args) { List<String> list1 = Arrays.asList(\\\"Hi\\\", \\\"Hello\\\", \\\"你好\\\"); List<String> list2 = Arrays.asList(\\\"zhangsan\\\", \\\"lisi\\\", \\\"wangwu\\\", \\\"zhaoliu\\\"); list1.stream().flatMap(item -> list2.stream().map(item2 -> item + \\\" \\\" + item2)). collect(Collectors.toList()).forEach(System.out::println); } } \",\"接下来介绍generate和iterate这两个特殊的方法：\",\"public class StreamTest6 { public static void main(String[] args) { Stream<String> stream = Stream.generate(UUID.randomUUID()::toString); stream.findFirst().ifPresent(System.out::println); } } \",\"接下来介绍iterate方法：\",\"public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) { Objects.requireNonNull(f); final Iterator<T> iterator = new Iterator<T>() { @SuppressWarnings(\\\"unchecked\\\") T t = (T) Streams.NONE; @Override public boolean hasNext() { return true; } @Override public T next() { return t = (t == Streams.NONE) ? seed : f.apply(t); } }; return StreamSupport.stream(Spliterators.spliteratorUnknownSize( iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE), false); } \",\"它的参数UnaryOperator可以简单的看一下：\",\"@FunctionalInterface public interface UnaryOperator<T> extends Function<T, T> { static <T> UnaryOperator<T> identity() { return t -> t; } } \",\"Function这个函数式接口本身接口T类型的参数，返回R类型的结果，这里的UnaryOperator表示接收参数与返回结果类型相同的情况，接下来我们阅读一下iterate的文档：\",\"Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc. The first element (position 0) in the Stream will be the provided seed. For n > 0, the element at position n, will be the result of applying the function f to the element at position n - 1. \",\"这个方法返回无限的、串行的、有序的一个Stream，它是由迭代函数f对于初始值seed的不断迭代，第一个元素作为seed（种子）,而对于n>0，会不断应用n-1次迭代函数f，比如f(seed)、f(f(seed))等等。\",\"举个例子：\",\"public class StreamTest6 { public static void main(String[] args) { Stream.iterate(1, item -> item + 2).limit(10).forEach(System.out::println); } } \",\"需要注意的是，这里之所以使用limit是因为如果不加限制，程序将一直运行下去，这是因为iterate他是无限的。\"]},\"1610\":{\"h\":\"Stream陷阱剖析\",\"t\":[\"首先来看这样一个例子，假设有这样一个流，流中的元素为1，3，5，6，7，11，我们要找出流中大于2的元素，然后将每个元素乘以2，忽略掉流中的前两个元素之后，再取出流中的前两个元素，然后求出流中元素的总和：\",\"public class StreamTest6 { public static void main(String[] args) { Stream<Integer> stream = Stream.iterate(1, item -> item + 2).limit(6); int sum = stream.filter(item -> item > 2).mapToInt(item -> item * 2).skip(2).limit(2).sum(); System.out.println(sum); } } \",\"这里有两个新的方法，skip()表示跳过，而limit()表示取前几个元素。\",\"如果我们改一下需求，把求出流中元素的总和改为求出流中元素的最小值，我们猜想代码可能是这样的：\",\"stream.filter(item -> item > 2).mapToInt(item -> item * 2).skip(2).limit(2).min(); \",\"但是运行之后控制台的输出却不是我们想要的结果，而是这样的：\",\"OptionalInt[14] \",\"原来min()方法的源码是这样的：\",\"OptionalInt min(); \",\"返回的是一个Optional对象，而不是一个普通的Int，类似的max()方法返回的也是Optional对象，原因就在于，求最大值和最小值有可能为空，而求和则不会，如果流中没有元素返回0即可，从本质上来说，是否会直接返回值，还是返回Optional对象，就是取决于是否可能会出现空指针的情况。\",\"public class StreamTest6 { public static void main(String[] args) { Stream<Integer> stream = Stream.iterate(1, item -> item + 2).limit(10); stream.filter(item -> item > 2).mapToInt(item -> item * 2).skip(2).limit(2).max().ifPresent(System.out::println); } } \",\"那如果既想求出最大值，也想求出最小值，也想求出总和，改怎么办呢？\",\"public class StreamTest6 { public static void main(String[] args) { IntSummaryStatistics intSummaryStatistics = stream.filter(item -> item > 2).mapToInt(item -> item * 2).skip(2).limit(2).summaryStatistics(); System.out.println(intSummaryStatistics.getMax()); System.out.println(intSummaryStatistics.getMin()); System.out.println(intSummaryStatistics.getSum()); } } \",\"答案就是调用summaryStatistics()方法。\",\"Stream实际上和文件系统中的IO流有很多类似的性质，比如，Stream只能使用一次：\",\"public class StreamTest6 { public static void main(String[] args) { Stream<Integer> stream = Stream.iterate(1, item -> item + 2).limit(6); System.out.println(stream); System.out.println(stream.filter(item -> item > 2)); System.out.println(stream.distinct()); } } \",\"运行程序，会得到如下的输出：\",\"java.util.stream.SliceOps$1@816f27d java.util.stream.ReferencePipeline$2@53d8d10a Exception in thread \\\"main\\\" java.lang.IllegalStateException: stream has already been operated upon or closed \",\"可以看到我们在调用filter方法之后，就会抛出Stream已经被使用的异常，即便我们使用的不是终止操作，而只是一个中间操作，或者说，对于Stream的操作我们只能进行一次，其实中间操作都会返回一个新的Stream对象，为了说明这一点，我们来举个例子：\",\"public class StreamTest6 { public static void main(String[] args) { Stream<Integer> stream = Stream.iterate(1, item -> item + 2).limit(6); System.out.println(stream); Stream<Integer> stream2 = stream.filter(item -> item > 2); System.out.println(stream2); Stream<Integer> stream3 = stream2.distinct(); System.out.println(stream3); } } \",\"这次我们顺利的打印出了Stream对象，但其实每次打印的Stream对象都是不同的，实际使用的时候，我们更多的是使用链式的写法：\",\"stream.filter(item -> item > 2).distinct(); \",\"接下来我们再了解流的另一个特性：\",\"public class StreamTest7 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); list.stream().map((item->{ String result = item.substring(0, 1).toUpperCase() + item.substring(1); System.out.println(result); return result; })); } } \",\"这段代码会输出什么呢？答案是什么都不会，如果修改成如下：\",\"public class StreamTest7 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); list.stream().map(item -> item.substring(0, 1).toUpperCase() + item.substring(1)).forEach(System.out::println); list.stream().map((item -> { String result = item.substring(0, 1).toUpperCase() + item.substring(1); System.out.println(result); return result; })).forEach(System.out::println); } } \",\"就会顺利的再控制台打印出我们想要的结果了。\",\"这也是流的另一个重要的特性——流是惰性的，流只有在遇到终止操作的时候，才会真正的执行，而map是中间操作，因此流并没有被真正的调用，而forEach是终止操作，所以流会被正常的调用执行。\",\"再来看一个例子：\",\"public class StreamTest8 { public static void main(String[] args) { IntStream.iterate(0, i -> (i + 1) % 2).distinct().limit(6).forEach(System.out::println); } } \",\"在控制台输出了：\",\"0 1 \",\"但程序并没有停止，而是在不停的运行，这是为什么呢？这是因为前面在不断的迭代产生0，1，而去重也并没有等待到新的值，所以程序会无限的运行下去，如果我们将刚才的操作反过来：\",\"IntStream.iterate(0, i -> (i + 1) % 2).limit(6).distinct().forEach(System.out::println); \",\"可以看到，控制台在输出了0，1之后就停止了，这是因为我们限制了只取流中的前六个元素，这提示我们在使用流的使用后一定要注意编写的顺序和流的相关特性。\"]},\"1611\":{\"h\":\"内部迭代和外部迭代\",\"t\":[\"Stream和SQL语句其实非常的相似，例如，要完成这样的一个SQL的功能，使用SQL语句：\",\"select name from student where age > 20 and address = ‘beijing’ order by age desc; \",\"该简单的sql所要表达的意思是：从student这张表中查询出年龄>20并且地址=北京的记录，并且对年龄进行降序排序，排序之后将其名字查找出来。对于sql其实是一个描述性的语言，只描述其行为，而具体如何让db完成这个行为是没有暴露出来的，对于该sql所做的工作如果换成咱们的stream来实现那会是个什么样子呢，伪代码可能是这样的：\",\" students.stream().filter(student -> student.getAge() > 20).filter(student -> student.getAddress().equals(“beijing”)) .sorted(…).forEach(student -> System.out.println(student.getName())); \",\"从表现形式上而言，Stream和SQL非常的类似，这是因为Stream也是属于一种描述性的语句， 整个语句并没有告诉底层Stream要如何去做，等于只要发一些指令给底层就可以了，具体底层怎么做完全不用关心。\",\"如果使用原来传统的方式又该怎么做呢？\",\" List list = new ArrayList<>(); for(int i=0; i < students.size();i++){ Student student = students.get(i); if(student.getAge() > 20 && student.getAddress().equals(“beijing”)){ list.add(student); } } Collections.sort(list. Comparator()…); for(Student student : list){ System.out.println(student.getName()); } \",\"可以看到，使用传统的方式，代码还相当冗余的，并且从易读性上而言，还是Stream的方式更加简洁明了，那什么是外部迭代，什么是内部迭代呢？实际上在Stream出现之前的都称之为外部迭代，使用Stream的就称之为内部迭代。\",\"针对一个集合：\",\"对于上面的例子而言：\",\"集合与我们编写的处理逻辑之间是有清晰的划分的：\",\"那对于Stream内部迭代的方式呢？\",\"总的来说，集合关注的是数据与数据存储本身；而流关注的则是对数据的计算。流与迭代器类似的一点是：流是无法重复使用或消费的，并且流在调用的时候，并不是对于集合中所有的元素先调用第一个filter方法，再调用第二个filter方法，再调用其他方法，实际上并不是这样的，流会将执行的调用链的时候，会有一个容器将所有的操作保存下来，并且针对具体的操作，会优化调用顺序，这一点，在后面源代码分析的时候，就可以看到。\",\"我们一直再说中间操作和终止操作，那如何判断一个操作是中间操作还是终止操作呢？简单来说，中间操纵都会返回一个Stream对象，而终止操作则不会返回Stream类型，可能不返回值，也可能返回其他类型的单个值。\"]},\"1612\":{\"h\":\"流的短路与并发流\",\"t\":[\"单从使用的角度而言，并发流与串行流的区别并不是很大，但在底层实现上是完全不同的。\",\"public class StreamTest9 { public static void main(String[] args) { List<String> list = new ArrayList<>(50000000); for (int i = 0; i < list.size(); i++) { list.add(UUID.randomUUID().toString()); } System.out.println(\\\"==================\\\"); long startTime = System.nanoTime(); list.stream().sorted().count(); long endTime = System.nanoTime(); long millis = TimeUnit.NANOSECONDS.toMillis(endTime - startTime); System.out.println(\\\"=======================\\\"); System.out.println(millis); } } \",\"如果要改用串行流改怎么做呢？仅仅需要将我们调用的方法修改为：\",\" list.parallelStream().sorted().count(); \",\"这也是使用内部迭代给我们带来的另一个好处，至于底层如何充分利用计算机资源帮助我们快速迭代，实际上在框架的底层就已经帮我们实现了，复杂性永远都是存在的，区别在于框架帮助我们实现了多少。当然，你可能会说，既然调用并行流这么方便，那是不是所有的场景下，都可以使用并行流来代替串行流？答案是否定的，并流行并不一定就比串行流的效率高，这取决于解决的实际问题，需要选择合适的方法，才能效率最高，这一点，在后续分析源码的时候就可以看到。\",\"接下来我们讨论有关流的短路问题，首先来看这样一个例子：\",\"public class StreamTest10 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); list.stream().mapToInt(String::length).filter(length -> length == 5).findFirst().ifPresent(System.out::println); } } \",\"显然，如果有长度为5的字符串，就会在控制台打印字符5，将这个例子做如下修改：\",\"public class StreamTest10 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); list.stream().mapToInt(item -> { int length = item.length(); System.out.println(item); return length; }).filter(length -> length == 5).findFirst().ifPresent(System.out::println); } } \",\"控制台会打印什么呢？答案是会在控制台打印出：\",\"hello \",\"为什么会只打印hello呢？原因就在于虽然我们采用的是链式的调用，但其实在调用这些方法的时候并没有先后的顺序，对于流中元素进行处理的时候，会从流中的第一个元素开始应用所有对于流元素的操作，并且对于流的操作也有短路的特性，我们要找到长度为5的字符串，第一个元素就已经满足了所有的操作，所以后面的就不再执行了。\"]},\"1613\":{\"h\":\"分区与分组\",\"t\":[\"我们曾经在内部迭代与外部迭代的章节中提到过，使用Stream的API很像在使用SQL语句，使用SQL语句进行分组的查询是一个很常见的需求，实际上，Stream也对分组提供了强有力的支持。\",\"同样的，我们先创建一个学生类，并生成构造方法、setter、getter方法：\",\"public class Student { private String name; private int score; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getScore() { return score; } public void setScore(int score) { this.score = score; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Student(String name, int score, int age) { this.name = name; this.score = score; this.age = age; } } \",\"然后来创建一些对象：\",\"public class StreamTest13 { public static void main(String[] args) { Student student1 = new Student(\\\"zhangsan\\\", 100, 20); Student student2 = new Student(\\\"lisi\\\", 90, 20); Student student3 = new Student(\\\"wangwu\\\", 90, 30); Student student4 = new Student(\\\"zhangsan\\\", 80, 40); List<Student> students = Arrays.asList(student1, student2, student3, student4); } } \",\"如果我们使用传统的编码方式来实现对于名字的分组操作，大概要经历如下的步骤：\",\"循环列表\",\"取出学生的名字\",\"检查Map中是否存在该名字，不存在则直接添加到该Map中，存在则将Map中的List对象取出来，然后将该Student对象添加到List中\",\"返回Map对象\",\"那如果我们使用函数式的编程方式呢？\",\"students.stream().collect(Collectors.groupingBy(Student::getName)); \",\"只需要这一行代码就可以完成根据姓名对于学生的分组操作，这里面用到了Collectors这个类提供的静态方法groupingBy()，我们可以简单的看一下这个方法接收的参数以及它要完成的事情：\",\" public static <T, K> Collector<T, ?, Map<K, List<T>>> groupingBy(Function<? super T, ? extends K> classifier) { return groupingBy(classifier, toList()); } \",\"这个方法本身是一个Function的函数式接口，Function我们都知道它接收一个参数，并且有返回值，正如它的方法名称那样描述的，我们需要提供分组的依据，这个方法的文档如下：\",\"Returns a Collector implementing a \\\"group by\\\" operation on input elements of type T, grouping elements according to a classification function, and returning the results in a Map. \",\"这个方法对于给定的输入元素进行了排序的操作，并且返回了一个Map集合，看到这里我们就明白了，T实际上表示的就是流中的每个元素的类型，而我们通过方法引用的方式，返回了流中Student的姓名字段，流就会自动的为我们根据姓名来进行分类了,并且姓名这个字段会作为分组的key。\",\"如果要根据年龄来分组呢，显然只要将分组的key换成分数就可以了：\",\"students.stream().collect(Collectors.groupingBy(Student::getScore)); \",\"接下来，我们尝试实现一个稍微复杂的需求，假设我们要实现与这样的SQL语句相同的功能：\",\"select name,count(*) from student group by name; \",\"这里我们就要调用groupingBy的一个重载的方式来实现：\",\" students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.counting())); \",\"我们首先来看一下这里面调用的counting()方法：\",\" public static <T> Collector<T, ?, Long> counting() { return reducing(0L, e -> 1L, Long::sum); } \",\"它的相关说明：\",\"Returns a Collector accepting elements of type T that counts the number of input elements. If no elements are present, the result is 0. \",\"这个方法会统计流中元素的个数，如果没有元素，就会返回0。\",\"我们通过这种方式就实现了上述SQL的需求，运行程序就会在控制台打印：\",\"{lisi=1, zhangsan=2, wangwu=1} \",\"我们再举一个例子，之前我们是对于分组中的元素个数进行统计，那如果我们想分组的时候也统计分数的平均值，这里我们也是需要使用另一个Collectors中的方法：\",\"students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.averagingDouble(Student::getScore))); \",\"运行效果如下：\",\"{lisi=90.0, zhangsan=90.0, wangwu=90.0} \",\"与分组相关的实际上还有一个概念叫做分区，分区可以认为是特殊的分组，它只会分成两组，调用的Api分别是：\",\"分组：group by\",\"分区：partition by\",\"比如，90分以上的分成一组，90分以下的分成一组：\",\"students.stream().collect(Collectors.partitioningBy(student -> student.getScore() >= 90)); \",\"运行的结果：\",\"{false=[stream.Student@3d494fbf], true=[stream.Student@1ddc4ec2, stream.Student@133314b, stream.Student@b1bc7ed]} \",\"至此，对于JDK8中的重要的API全部都介绍完成，学会使用是第一步也是非常重要的一步，在长时间的练习和记忆中，我们才能体会到函数式编程带给我们巨大好处，如果只是从使用的角度而言，掌握本章及之前的内容对于一般的开发者，完全是够用的，然而我想这是远远不够的，学习JDK中优秀的源码，反过来加深我们使用的时候的理解，达到相互促进的作用，这才是更重要的，因此，从下一章节开始，我们将系统而全面的分析JDK是如何实现函数式编程，以及我们之前使用的诸多的API在底层到底是如何实现的。\",\"Stream的源码复杂而多变，要掌握整个的流程，我们就不得不先要理清楚一些及其重要的概念和几个核心类的作用，当然一开始这是不太容易能够理解的，但是，这会为后面我们能完整的看到流的整个调用顺序打下良好的基础。\",\"首先我们为接下来的部分提前定义好一个学生类作为我们分析源码的入口：\",\"public class Student { private String name; private int score; public String getName() { return name; } public Student(String name, int score) { this.name = name; this.score = score; } @Override public String toString() { return \\\"Student{\\\" + \\\"name='\\\" + name + '\\\\'' + \\\", score=\\\" + score + '}'; } public void setName(String name) { this.name = name; } public int getScore() { return score; } public void setScore(int score) { this.score = score; } } \"]},\"1614\":{\"h\":\"Comparator源码分析及实践\",\"t\":[\"Comparator并不是JDK8新增加的内容，但是JDK8对它做了一定程度的增强，在函数式编程中非常的常见，所以也非常的重要，在正式进入Stream源码分析之前，有必要了解关于Comparator比较器的内容。\",\"@FunctionalInterface public interface Comparator<T> { int compare(T o1, T o2); } \",\"首先可以看到这是一个函数式接口，拥有唯一的抽象方法compare，这个方法接口两个参数并且有返回值，并且在这个类中，JDK从1.8开始增加了若干个默认方法。\",\"假如我们要对一个字符串数据按照首字母进行排序：\",\"public class MyComparatorTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"nihao\\\", \\\"hello\\\", \\\"world\\\", \\\"welcome\\\"); Collections.sort(list); System.out.println(list); } } \",\"如果要按照长度来进行排序：\",\"Collections.sort(list, (item1, item2) -> item1.length() - item2.length()); \",\"也可以使用方法引用的方式来实现：\",\"Collections.sort(list, Comparator.comparingInt(String::length)); \",\"如果是降序则：\",\"Collections.sort(list, (item1, item2) -> item2.length() - item1.length()); \",\"同样的，也可以使用方法引用的方式来实现，只是这里我们调用新的方法reversed：\",\"Collections.sort(list, Comparator.comparingInt(String::length).reversed()); \",\"但是如果你这么写的话，就会发现有问题：\",\"Collections.sort(list, Comparator.comparingInt(item -> item.length()).reversed()); \",\"看起来与上面的写法是完全等价的，但IDE却会提示：\",\"cannot resolve method 'length()' \",\"原因就在于，编译器会认为此时的item是一个Object类型的对象，如果要正常编译运行，就需要显示的声明类型：\",\"Collections.sort(list, Comparator.comparingInt((String item) -> item.length()).reversed()); \",\"在我们之前的所有的例子当中，编译器都可以自动的推断出元素的类型，在这个例子当中，接收的参数ToIntFunction<? super T>由于没有明确的上下文（可能是T类型，也有可能是T类型以上的类型），并且由于调用了reversed获取了新的比较器，所以编译器没有办法准确的推断出类型：\",\" public static <T> Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor) { Objects.requireNonNull(keyExtractor); return (Comparator<T> & Serializable) (c1, c2) -> Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2)); } \",\"这里为什么会是T类型以及T类型以上的类型呢？简而言之，就是可以传入自己本身以及父类的比较器，而如果传入的是父类型的比较器，比较完成之后还是会强转会原来的类型。\",\"其实我们也可以直接调用list的sort方法：\",\"list.sort(Comparator.comparingInt(String::length).reversed()); \",\"上面的方法都是一次排序，接下来我们看多次排序的方法，比如现根据名称排序，排好序之后对于名称相同的再根据分数进行排序：\",\"Collections.sort(list, Comparator.comparingInt(String::length).thenComparing((item1, item2) -> item1.compareToIgnoreCase(item2))); \",\"其实我们也可以这样调用：\",\"Collections.sort(list,Comparator.comparingInt(String::length).thenComparing(String.CASE_INSENSITIVE_ORDER)); \",\"这里我们使用的静态的常量是：\",\" public static final Comparator<String> CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator(); \",\"这个类本身就定义在String类当中：\",\" private static class CaseInsensitiveComparator implements Comparator<String>, java.io.Serializable { // use serialVersionUID from JDK 1.2.2 for interoperability private static final long serialVersionUID = 8575799808933029326L; public int compare(String s1, String s2) { int n1 = s1.length(); int n2 = s2.length(); int min = Math.min(n1, n2); for (int i = 0; i < min; i++) { char c1 = s1.charAt(i); char c2 = s2.charAt(i); if (c1 != c2) { c1 = Character.toUpperCase(c1); c2 = Character.toUpperCase(c2); if (c1 != c2) { c1 = Character.toLowerCase(c1); c2 = Character.toLowerCase(c2); if (c1 != c2) { // No overflow because of numeric promotion return c1 - c2; } } } } return n1 - n2; } \",\"而对于thenComparing方法而言：\",\"Returns a lexicographic-order comparator with another comparator. If this Comparator considers two elements equal, i.e. compare(a, b) == 0, other is used to determine the order. \",\"与另一个比较器相比，它返回一个字典顺序的比较器，如果它的前一个比较器返回是元素的相等的情况，即compare(a, b) == 0的情况下，当前传入的比较器就会发挥作用，进行二次排序，这意味着，如果前面的比较器返回的结果不是0，那么后面的比较器就不会再调用，这一点在源代码中也有体现：\",\" default Comparator<T> thenComparing(Comparator<? super T> other) { Objects.requireNonNull(other); return (Comparator<T> & Serializable) (c1, c2) -> { int res = compare(c1, c2); // 当比较的结果不为0的时候直接返回，相等再执行传入的比较器。 return (res != 0) ? res : other.compare(c1, c2); }; } \",\"当然，你还可以这么做：\",\"Collections.sort(list,Comparator.comparingInt(String::length).thenComparing(Comparator.comparing(String::toLowerCase))); \",\"类似的，比较器也可以进行复合：\",\"Collections.sort(list, Comparator.comparingInt(String::length).thenComparing(String::toLowerCase, Comparator.reverseOrder())); \",\"比这个例子稍微复杂一个例子：\",\"Collections.sort(list,Comparator.comparingInt(String::length).reversed().thenComparing(String::toLowerCase, Comparator.reverseOrder())); \"]},\"1615\":{\"h\":\"Collector源码分析\",\"t\":[\"Collector无疑是整个Stream源码中及其重要的一个类，了解它对于我们认识Stream类有着及其关键的作用，首先回到我们之前的例子当中：\",\"public class StreamTest1 { public static void main(String[] args) { Student student1 = new Student(\\\"zhangsan\\\", 80); Student student2 = new Student(\\\"lisi\\\", 90); Student student3 = new Student(\\\"wangwu\\\", 100); Student student4 = new Student(\\\"zhaoliu\\\", 90); List<Student> students = Arrays.asList(student1, student2, student3, student4); List<Student> studentList = students.stream().collect(Collectors.toList()); studentList.forEach(System.out::println); } } \",\"毫无疑问，到目前这个阶段，这样的代码我们应该已经掌握的非常的熟练了，现在假设说要求使用流的方式求出列表的长度改怎么做呢？你可以使用Collectors中的静态方法：\",\" System.out.println(\\\"count: \\\" + students.stream().collect(Collectors.counting())); \",\"可以看到，实际使用的时候，使用collect（收集器）的频率非常的高，collect本身的定义是这样的：\",\"<R, A> R collect(Collector<? super T, A, R> collector); \",\"它本身接收一个参数叫做collector，是Collector类型的，接下来的章节重点分析这个类。\",\"A mutable reduction operation that accumulates input elements into a mutable result container, optionally transforming the accumulated result into a final representation after all input elements have been processed. Reduction operations can be performed either sequentially or in parallel. Examples of mutable reduction operations include: accumulating elements into a Collection; concatenating strings using a StringBuilder; computing summary information about elements such as sum, min, max, or average; computing \\\"pivot table\\\" summaries such as \\\"maximum valued transaction by seller\\\", etc. The class Collectors provides implementations of many common mutable reductions. \",\"它是一个可变的汇聚操作，作用是将输入元素累积到一个可变的结果容器当中。它可以在所有的元素都处理完毕后，将累积的结果转换为一个最终的表示（这是一个可选的操作），它支持串行与并行两种方式执行。什么是可变的汇聚操作呢？比如将集合中的元素添加到Collection当中，再比如使用StringBuilder将字符串拼接起来，计算关于元素的求和、最小值、最大值、平均值，这也是一种可变操作，计算“数据透视图”的时候一些汇总信息，比如计算卖方交易数量的最大值，Collectors提供了很多对于常见的可变的汇聚操作的实现（Collectors是Collector的实现类，而Collectors本身实际上是一个工厂）。\",\"A Collector is specified by four functions that work together to accumulate entries into a mutable result container, and optionally perform a final transform on the result. They are: \",\"Collector是由以下四个方法构成，用来完成向一个可变结果容器当中添加元素的，并且对于结果进行最终的转换：\",\"creation of a new result container (supplier())\",\"incorporating a new data element into a result container (accumulator())\",\"combining two result containers into one (combiner())\",\"performing an optional final transform on the container (finisher())\",\"A function that creates and returns a new mutable result container. \",\"supplier()是用来创建新的可变的结果容器。\",\"A function that folds a value into a mutable result container. \",\"accumulator()是用来将一个新的数据元素添加到结果容器当中。\",\"A function that accepts two partial results and merges them. The combiner function may fold state from one argument into the other and return that, or may return a new result container. \",\"combiner函数接收两个部分的结果并且合并它们，combiner函数可以将状态从一个折叠成为另一个，并且返回它们，也可能返回一个新的结果容器，实际上这个是在并行中使用的。\",\"Perform the final transformation from the intermediate accumulation type A to the final result type R. If the characteristic IDENTITY_TRANSFORM is set, this function may be presumed to be an identity transform with an unchecked cast from A to R. \",\"是将中间的累积类型转换称为最终的结果类型，如果设置了IDENTITY_TRANSFORM这个特性，那么这个函数就会直接将A转型为R。\",\"Collectors also have a set of characteristics, such as Collector.Characteristics.CONCURRENT, that provide hints that can be used by a reduction implementation to provide better performance. \",\"Collectors还有一个描述特征的的集合，比如Collector.Characteristics.CONCURRENT，它可以通过不同的枚举值来提高并发流的执行效率。\",\" enum Characteristics { CONCURRENT， UNORDERED, IDENTITY_FINISH } \",\"这个枚举是定义在Collector这个接口当中的，首先来看一下类的说明：\",\"Characteristics indicating properties of a Collector, which can be used to optimize reduction implementations. \",\"Characteristics是Collector的一个属性，能够优化汇聚操作。\",\"A sequential implementation of a reduction using a collector would create a single result container using the supplier function, and invoke the accumulator function once for each input element. A parallel implementation would partition the input, create a result container for each partition, accumulate the contents of each partition into a subresult for that partition, and then use the combiner function to merge the subresults into a combined result. \",\"对于流的串行实现会创建一个单个的结果容器，并且每个元素会调用accumulator方法一次，而对于并行实现将会对输入进行分区，对于每一个分区都会创建一个结果容器，然后使用combiner方法将每个分区的结果容器当中的内容进行合并。\",\"To ensure that sequential and parallel executions produce equivalent results, the collector functions must satisfy an identity and an associativity constraints. \",\"为了确保串行与并行生成等价的结果，collector必须满足两个条件，即identity（同一性）和associativity（结合性）。\",\"The identity constraint says that for any partially accumulated result, combining it with an empty result container must produce an equivalent result. That is, for a partially accumulated result a that is the result of any series of accumulator and combiner invocations, a must be equivalent to combiner.apply(a, supplier.get()). \",\"同一性指的是，部分累积的结果与一个空的结果容器运算之后还是它本身，这也就是说，对于一个部分累积的结果a而言，它要满足combiner.apply(a, supplier.get())等于a。\",\"The associativity constraint says that splitting the computation must produce an equivalent result. That is, for any input elements t1 and t2, the results r1 and r2 in the computation below must be equivalent: \",\"结合性指的是分割计算也会得到一个等价的结果，也就是说对于任意的输入t1和t2，和产生的结果r1和r2，下面的计算是等价的。\",\" // 串行操作 A a1 = supplier.get(); accumulator.accept(a1, t1); accumulator.accept(a1, t2); R r1 = finisher.apply(a1); // 并行操作 A a2 = supplier.get(); accumulator.accept(a2, t1); A a3 = supplier.get(); accumulator.accept(a3, t2); R r2 = finisher.apply(combiner.apply(a2, a3)); \",\"也就是说无论对于串行操作还是并行操作，最终生成的结果必须是等价的。\",\"For collectors that do not have the UNORDERED characteristic, two accumulated results a1 and a2 are equivalent if finisher.apply(a1).equals(finisher.apply(a2)). For unordered collectors, equivalence is relaxed to allow for non-equality related to differences in order. (For example, an unordered collector that accumulated elements to a List would consider two lists equivalent if they contained the same elements, ignoring order.) \",\"对于没有UNORDERED特性的collectors来说，如果finisher.apply(a1).equals(finisher.apply(a2))，这两种累加的结果是等价的，对于无序的要求就被放松了，它会考虑到顺序上的区别带来的不相等性，比如无序的collector它累积元素到一个List当中，就会两个List是相同的，他们包含了相同的元素，忽略了顺序。\",\"Libraries that implement reduction based on Collector, such as Stream.collect(Collector), must adhere to the following constraints: \",\"基于Collector实现汇聚操作的库，比如Stream.collect(Collector)，必须要遵守下面的约定。\",\"The first argument passed to the accumulator function, both arguments passed to the combiner function, and the argument passed to the finisher function must be the result of a previous invocation of the result supplier, accumulator, or combiner functions. \",\"传递给accumulator方法的第一个参数，以及传递给combiner方法的两个参数，以及传递给finisher的参数，它们必须都是result supplier, accumulator, combiner上一次调用的结果。\",\"看到这里还是比较难以理解的，我们首先需要理解Collector泛型的含义：\",\"<T> – the type of input elements to the reduction operation <A> – the mutable accumulation type of the reduction operation (often hidden as an implementation detail) <R> – the result type of the reduction operation \",\"T类型表示进行汇聚操作的输入元素的类型，即流中的每一个元素的类型，A类型表示汇聚操作的可变的累积类型，可以认为是每次中间结果容器的类型，R类型表示汇聚操作的结果类型，这个时候我们再来分析一个这四个方法对应的泛型：\",\"Supplier<A> supplier(); BiConsumer<A, T> accumulator(); BinaryOperator<A> combiner(); Function<A, R> finisher(); \",\"BinaryOperator是因为合并的是两个部分的结果容器的类型，那最终的结果一定也是A类型，从泛型的角度就可以清楚的认识到，对于每一次的调用，supplier提供的结果容器就会传递给accumulator，而accumulator将流中待处理的元素添加到结果容器之后，又将这个部分结果传递给combiner，依次类推。\",\"The implementation should not do anything with the result of any of the result supplier, accumulator, or combiner functions other than to pass them again to the accumulator, combiner, or finisher functions, or return them to the caller of the reduction operation. \",\"对于具体的实现不应该对生成的supplier、accumulator、combiner做任何的事情，除了将他们再一次传递给accumulator、combiner或者finisher方法，否则将他们返回给汇聚操作的调用者。\",\"If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again. \",\"如果一个结果被传递给combiner或者finisher函数了，并没有返回相同的类型的对象，那么它就再也不会被使用了。\",\"Once a result is passed to the combiner or finisher function, it is never passed to the accumulator function again. \",\"一旦一个结果被传递给了combiner或者finisher方法，它就不会再被accumulator方法使用了（这是因为调用顺序的原因）。\",\"For non-concurrent collectors, any result returned from the result supplier, accumulator, or combiner functions must be serially thread-confined. This enables collection to occur in parallel without the Collector needing to implement any additional synchronization. The reduction implementation must manage that the input is properly partitioned, that partitions are processed in isolation, and combining happens only after accumulation is complete. \",\"对于非并发的collectors，从supplier, accumulator, 或者 combiner中返回的结果都一定是线程封闭的，不会被其他线程使用，这样在并发的情况下，就不用再做其他的操作来保证线程安全，每一个部分的操作都是独立的，并且只有当部分完成之后猜会进行合并的操作。\",\"For concurrent collectors, an implementation is free to (but not required to) implement reduction concurrently. A concurrent reduction is one where the accumulator function is called concurrently from multiple threads, using the same concurrently-modifiable result container, rather than keeping the result isolated during accumulation. A concurrent reduction should only be applied if the collector has the Collector.Characteristics.UNORDERED characteristics or if the originating data is unordered. \",\"对于并发的collectors，实现是可以自由的实现，一个多线程的汇聚操作指的是accumulator同时被多个线程调用，他们可以使用相同的可以并发修改的结果容器，而不是保持独立，一个并发的结果容器在什么情况下使用呢？只有当特性值设置为UNORDERED的时候，或者数据源本身不要求有序。\",\"In addition to the predefined implementations in Collectors, the static factory methods of(Supplier, BiConsumer, BinaryOperator, Characteristics...) can be used to construct collectors. For example, you could create a collector that accumulates widgets into a TreeSet with: \",\"除了在Collectors预先定义好的静态工厂方法可以创建一个收集器之外，还可以使用Collector中的of方法，比如你可以使用下面的方式将widget累积到TreeSet当中：\",\"Collector<Widget, ?, TreeSet<Widget>> intoSet = Collector.of(TreeSet::new, TreeSet::add, (left, right) -> { left.addAll(right); return left; }); \",\"实际上就是除了预先定义好的收集器，我们可以通过Collector中的of方法实现自定的收集器。\",\"Performing a reduction operation with a Collector should produce a result equivalent to: \",\"使用一个Collector执行汇聚操作会生成的结果应该和下面的结果等价:\",\"R container = collector.supplier().get(); for (T t : data) collector.accumulator().accept(container, t); return collector.finisher().apply(container); \",\"这其实就是汇聚操作的整个过程。\",\"However, the library is free to partition the input, perform the reduction on the partitions, and then use the combiner function to combine the partial results to achieve a parallel reduction. (Depending on the specific reduction operation, this may perform better or worse, depending on the relative cost of the accumulator and combiner functions.) \",\"然而，库可以自由的对输入元素分组与分区，在每一个分区上执行这种汇聚操作，然后使用combiner方法合并部分的结果执行一个并行的汇聚操作（取决于具体的并行操作的类型，这可能效率高，也可能效率会变低，这取决于accumulator和combiner消耗的成本和代价）。\",\"Collectors are designed to be composed; many of the methods in Collectors are functions that take a collector and produce a new collector. For example, given the following collector that computes the sum of the salaries of a stream of employees: \",\"收集器是被设计成可以组合的，这意味着，Collectors很多方法可以接收collector作为参数返回一个新的collector，例如一个员工构成的流的工资的总数：\",\" Collector<Employee, ?, Integer> summingSalaries = Collectors.summingInt(Employee::getSalary)) \",\"如果我们想实现收集器的复合改怎么做呢？\",\"If we wanted to create a collector to tabulate the sum of salaries by department, we could reuse the \\\"sum of salaries\\\" logic using Collectors.groupingBy(Function, Collector): \",\"如果以向创建一个根据部门对于工资的总和表格化，我们就可以重用“工资总和”逻辑，然后使用分组方法Collectors.groupingBy(Function, Collector):\",\" Collector<Employee, ?, Map<Department, Integer>> summingSalariesByDept = Collectors.groupingBy(Employee::getDepartment, summingSalaries); \",\"这里的第二个参数就是我们上面定义过的收集器，这就实现了收集器的复合。\"]},\"1616\":{\"h\":\"Collector实践\",\"t\":[\"Collector接口有且仅有唯一的实现类CollectorImpl：\",\" static class CollectorImpl<T, A, R> implements Collector<T, A, R> { private final Supplier<A> supplier; private final BiConsumer<A, T> accumulator; private final BinaryOperator<A> combiner; private final Function<A, R> finisher; private final Set<Characteristics> characteristics; CollectorImpl(Supplier<A> supplier, BiConsumer<A, T> accumulator, BinaryOperator<A> combiner, Function<A,R> finisher, Set<Characteristics> characteristics) { this.supplier = supplier; this.accumulator = accumulator; this.combiner = combiner; this.finisher = finisher; this.characteristics = characteristics; } CollectorImpl(Supplier<A> supplier, BiConsumer<A, T> accumulator, BinaryOperator<A> combiner, Set<Characteristics> characteristics) { this(supplier, accumulator, combiner, castingIdentity(), characteristics); } @Override public BiConsumer<A, T> accumulator() { return accumulator; } @Override public Supplier<A> supplier() { return supplier; } @Override public BinaryOperator<A> combiner() { return combiner; } @Override public Function<A, R> finisher() { return finisher; } @Override public Set<Characteristics> characteristics() { return characteristics; } } \",\"需要注意的是，这个类没有定义在一个单独的文件当中，而是定义在Collectors当中，这个类本身并没有做任何事情，只是根据Collector接口的要求，将需要的属性和方法定义好。这么做的理由是什么呢？实际上是一种设计上的考量，Collectors类被用来生产一些常见的方法，它绝大部分的方法都是静态方法，可以直接调用，而作为Collector的工厂，所有的方法一定会返回CollectorImpl类型，而在别的地方，又不会用到CollectorImpl，所以设计者直接将这个类作为一个静态的内部类。\",\"接下来我们就围绕Collectors为我们提供的诸多的静态方法展开，了解这些方法的使用以及实现细节。\",\"Implementations of Collector that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc. \",\"Collectors实现了Collector接口并提供了很多很有用的汇聚操作，比如将元素累积到一个集合当中，比如摘要（最大值、最小值、平均值等等）。\",\"The following are examples of using the predefined collectors to perform common mutable reduction tasks: \",\"下面的例子就是使用JDK预先定义好的方法来执行可变的汇聚任务：\",\" // Accumulate names into a List List<String> list = people.stream().map(Person::getName).collect(Collectors.toList()); // Accumulate names into a TreeSet Set<String> set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new)); // Convert elements to strings and concatenate them, separated by commas String joined = things.stream() .map(Object::toString) .collect(Collectors.joining(\\\", \\\")); // Compute sum of salaries of employee int total = employees.stream() .collect(Collectors.summingInt(Employee::getSalary))); // Group employees by department Map<Department, List<Employee>> byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment)); // Compute sum of salaries by department Map<Department, Integer> totalByDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary))); // Partition students into passing and failing Map<Boolean, List<Student>> passingFailing = students.stream() .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD)); \",\"在完整的理解了收集器相关的概念之后，我们可以看一些具体的例子，针对于之前的学生的集合，如果我们想求出学生分数的最小值：\",\"students.stream().collect(Collectors.minBy(Comparator.comparingInt(Student::getScore))).ifPresent(System.out::println); \",\"如果是最大值呢？\",\"students.stream().collect(Collectors.maxBy(Comparator.comparingInt(Student::getScore))).ifPresent(System.out::println); \",\"如果是平均值呢？\",\"System.out.println( students.stream().collect(Collectors.averagingInt(Student::getScore))); \",\"如果是求出分数的总和呢？\",\"System.out.println(students.stream().collect(Collectors.summingInt(Student::getScore))); \",\"当然也可以调用统计的方法一次将这些特征值都求出来：\",\"System.out.println(students.stream().collect(Collectors.summarizingInt(Student::getScore))); \",\"如果想将学生的名字使用字符串拼接呢？\",\"System.out.println(students.stream().map(Student::getName).collect(Collectors.joining())); \",\"还可以使用逗号分隔：\",\"System.out.println(students.stream().map(Student::getName).collect(Collectors.joining(\\\",\\\"))); \",\"还可以拼接前缀和后缀：\",\"System.out.println(students.stream().map(Student::getName).collect(Collectors.joining(\\\",\\\",\\\"<begin>\\\",\\\"<end>\\\"))); \",\"除了这些常规的操作，其实对于分组的操作还可以进行二级分组：\",\"students.stream().collect(Collectors.groupingBy(Student::getScore,Collectors.groupingBy(Student::getName))); \",\"类似的对于分区的操作也可以进行二级分区：\",\"students.stream().collect(Collectors.partitioningBy(student -> student.getScore() > 90, Collectors. partitioningBy(student -> student.getScore() > 80))); \",\"分组和分区还可以互相嵌套：\",\"students.stream().collect(Collectors.partitioningBy(student -> student.getScore() > 80, Collectors.counting())); \",\"下面我们来看一个稍微复杂一点的例子：\",\"students.stream().collect(Collectors.groupingBy(Student::getName,Collectors.collectingAndThen(Collectors.minBy(Comparator.comparingInt(Student::getScore)), Optional::get))); \"]},\"1617\":{\"h\":\"自定义Collector\",\"t\":[\"在进行Collector源码分析的时候，我们提到过Characteristics这个内部枚举类，接下来我们首先分析每一个枚举项代表的含义：\",\"1、CONCURRENT\",\"Indicates that this collector is concurrent, meaning that the result container can support the accumulator function being called concurrently with the same result container from multiple threads. If a CONCURRENT collector is not also UNORDERED, then it should only be evaluated concurrently if applied to an unordered data source. \",\"CONCURRENT表示当前的收集器是并发的，这意味着中间结果容器支持使用多线程进行并发访问，CONCURRENT并不是UNORDERED，只有无序的数据源才可以使用这个属性。\",\"2、UNORDERED\",\"Indicates that the collection operation does not commit to preserving the encounter order of input elements. (This might be true if the result container has no intrinsic order, such as a Set.) \",\"UNORDERED意味着收集的操作并不确保保留输入元素的顺序（可以用在结果容器不要求有序的场景下，比如Set）\",\"3、IDENTITY_FINISH\",\"Indicates that the finisher function is the identity function and can be elided. If set, it must be the case that an unchecked cast from A to R will succeed. \",\"IDENTITY_FINISH表示finisher方法就是identity方法，可以被省略掉，如果设置了这个属性，那么就要确保从A类型到R类型的强制转换是可以成功的。\",\"接下来我们实现一个自定义的收集器：\",\"public class MySetCollector<T> implements Collector<T, Set<T>, Set<T>> { @Override public Supplier<Set<T>> supplier() { System.out.println(\\\"supplier invoked!\\\"); return HashSet::new; } @Override public BiConsumer<Set<T>, T> accumulator() { System.out.println(\\\"accmulator invoked!\\\"); // 这里不能调用HashSet::add，因为无法保证与supplier()方法返回的中间结果容器类型相同 return Set::add; } @Override public BinaryOperator<Set<T>> combiner() { System.out.println(\\\"combiner invoked!\\\"); return (set1, set2) -> { set1.addAll(set2); return set1; }; } @Override public Function<Set<T>, Set<T>> finisher() { System.out.println(\\\"finisher invoked!\\\"); return Function.identity(); } @Override public Set<Characteristics> characteristics() { System.out.println(\\\"characteristics invoked!\\\"); return Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH, Characteristics.UNORDERED)); } public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"welcome\\\"); Set<String> set = list.stream().collect(new MySetCollector<>()); System.out.println(set); } } \",\"程序运行的结果如下：\",\"supplier invoked! accmulator invoked! combiner invoked! characteristics invoked! characteristics invoked! [world, hello, welcome] \",\"可以看到supplier、accumulator、combiner分别执行了一次，而characteristics执行了两次，只有finisher没有被调用。\",\" public final <R, A> R collect(Collector<? super P_OUT, A, R> collector) { A container; // 如果是并行流 if (isParallel() && (collector.characteristics().contains(Collector.Characteristics.CONCURRENT)) && (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) { container = collector.supplier().get(); BiConsumer<A, ? super P_OUT> accumulator = collector.accumulator(); forEach(u -> accumulator.accept(container, u)); } else { container = evaluate(ReduceOps.makeRef(collector)); } // characteristics()在这里被第二次调用，用于判断中间结果容器与最终返回的类型是否相同,如果包含了IDENTITY_FINISH这个特性，直接进行强制类型转换，会将中间结果容器强制转换为最终的结果类型。 return collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH) ? (R) container : collector.finisher().apply(container); } \",\"这里我们显然是串行流，所以直接进入到第二种情况，首先我们来看一下ReduceOps的makeRef方法：\",\" public static <T, I> TerminalOp<T, I> makeRef(Collector<? super T, I, ?> collector) { // 我们的方法就是在这里被调用了，返回了supplier、accumulator、combiner三个对象。 Supplier<I> supplier = Objects.requireNonNull(collector).supplier(); BiConsumer<I, ? super T> accumulator = collector.accumulator(); BinaryOperator<I> combiner = collector.combiner(); class ReducingSink extends Box<I> implements AccumulatingSink<T, I, ReducingSink> { @Override public void begin(long size) { state = supplier.get(); } @Override public void accept(T t) { accumulator.accept(state, t); } @Override public void combine(ReducingSink other) { state = combiner.apply(state, other.state); } } return new ReduceOp<T, I, ReducingSink>(StreamShape.REFERENCE) { @Override public ReducingSink makeSink() { return new ReducingSink(); } // Characteristics()在这里被第一次调用，用于判断是否有序 @Override public int getOpFlags() { return collector.characteristics().contains(Collector.Characteristics.UNORDERED) ? StreamOpFlag.NOT_ORDERED : 0; } }; } \",\"为了验证关于Characteristics方法的调用逻辑，我们去掉characteristics方法中的枚举项IDENTITY_FINISH：\",\" @Override public Set<Characteristics> characteristics() { System.out.println(\\\"characteristics invoked!\\\"); return Collections.unmodifiableSet(EnumSet.of( Characteristics.UNORDERED)); } \",\"观察结果，finsher就得到了调用：\",\"supplier invoked! accmulator invoked! combiner invoked! characteristics invoked! characteristics invoked! finisher invoked! [world, hello, welcome] \",\"接下来我们定义一个中间结果容器需要进行类型转换的例子：\",\"public class MySetCollector2<T> implements Collector<T, Set<T>, Map<T, T>> { @Override public Supplier<Set<T>> supplier() { System.out.println(\\\"supplier invoked!\\\"); return HashSet::new; } @Override public BiConsumer<Set<T>, T> accumulator() { System.out.println(\\\"accmulator invoked!\\\"); return (set, item) -> set.add(item); } @Override public BinaryOperator<Set<T>> combiner() { System.out.println(\\\"combiner invoked!\\\"); return (set1, set2) -> { set1.addAll(set2); return set1; }; } @Override public Function<Set<T>, Map<T, T>> finisher() { System.out.println(\\\"finisher invoked!\\\"); return set -> { Map<T, T> map = new HashMap<>(10); set.forEach(item -> map.put(item, item)); return map; }; } @Override public Set<Characteristics> characteristics() { System.out.println(\\\"characteristics invoked!\\\"); return Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED)); } public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"welcome\\\", \\\"hello\\\", \\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\", \\\"e\\\", \\\"f\\\", \\\"g\\\"); Set<String> set = new HashSet<>(); set.addAll(list); System.out.println(\\\"set: \\\" + set); Map<String, String> map = set.stream().collect(new MySetCollector2<>()); System.out.println(map); } } \",\"执行的结果：\",\"supplier invoked! accmulator invoked! combiner invoked! characteristics invoked! characteristics invoked! finisher invoked! {a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome} \",\"如果将这个枚举值修改为：\",\"return Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED,Characteristics.IDENTITY_FINISH)); \",\"就会抛出异常：\",\"Exception in thread \\\"main\\\" java.lang.ClassCastException: java.util.HashSet cannot be cast to java.util.Map \",\"这就是因为我们的中间结果类型是Set类型，而最终的结果类型是Map类型，同时也说明了characteristics就定义了中间结果容器和最终结果的结果容器类型的关系，在运行期间，JDK会根据这个枚举项类判断他们之间的关系，如果编写错误了，就可能会出现错误。\",\"另外如果中间结果容器和最终结果的结果容器类型相同，但是需要对于中间结果容器做一些处理才返回结果，这个时候也要去掉IDENTITY_FINISH这个枚举值，因为在执行过程中，会直接转换类型，而不会操作里面的值。\",\"如果我们在accumulator中打印当前线程的名称：\",\" @Override public BiConsumer<Set<T>, T> accumulator() { System.out.println(\\\"accmulator invoked!\\\"); return (set, item) -> { set.add(item); System.out.println(\\\"accmulator: \\\" + Thread.currentThread().getName()); }; } \",\"控制台就会打印十次：\",\"accmulator: main accmulator: main accmulator: main accmulator: main accmulator: main accmulator: main accmulator: main accmulator: main accmulator: main accmulator: main \",\"去掉集合中重复的元素\\\"hello\\\",正好是十个元素，执行了十次累积的操作，并且都是主线程的，如果我们使用并行流：\",\"Map<String, String> map = set.parallelStream().collect(new MySetCollector2<>()); \",\"运行的结果就变成了：\",\"set: [a, b, world, c, d, e, f, g, hello, welcome] characteristics invoked! supplier invoked! accmulator invoked! combiner invoked! characteristics invoked! accmulator: main accmulator: ForkJoinPool.commonPool-worker-5 accmulator: ForkJoinPool.commonPool-worker-4 accmulator: ForkJoinPool.commonPool-worker-3 accmulator: ForkJoinPool.commonPool-worker-1 accmulator: ForkJoinPool.commonPool-worker-1 accmulator: ForkJoinPool.commonPool-worker-3 accmulator: ForkJoinPool.commonPool-worker-3 accmulator: ForkJoinPool.commonPool-worker-5 accmulator: ForkJoinPool.commonPool-worker-2 characteristics invoked! finisher invoked! {a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome} \",\"为了方便观察并行流和串行流的区别，我们打印一下，进行累积操作的集合中的元素，再次运行，就会发现：\",\"set: [a, b, world, c, d, e, f, g, hello, welcome] characteristics invoked! supplier invoked! accmulator invoked! combiner invoked! characteristics invoked! [hello] [b] accmulator: ForkJoinPool.commonPool-worker-2 accmulator: main [f] accmulator: ForkJoinPool.commonPool-worker-3 [d] accmulator: ForkJoinPool.commonPool-worker-1 [d, e] accmulator: ForkJoinPool.commonPool-worker-1 [welcome] accmulator: ForkJoinPool.commonPool-worker-4 [f, g] accmulator: ForkJoinPool.commonPool-worker-3 [b, world] accmulator: ForkJoinPool.commonPool-worker-2 [b, world, c] accmulator: ForkJoinPool.commonPool-worker-2 [a] accmulator: ForkJoinPool.commonPool-worker-5 characteristics invoked! finisher invoked! {a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome} \",\"这里就会开启多个线程，这个时候如果再设置CONCURRENT特性：\",\"return Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED, Characteristics.CONCURRENT)); \",\"控制台输出：\",\"set: [a, b, world, c, d, e, f, g, hello, welcome] characteristics invoked! supplier invoked! ==================================== accmulator invoked! [hello] accmulator: main [hello, welcome] accmulator: ForkJoinPool.commonPool-worker-2 [f, hello, welcome] [b, f, hello, welcome] accmulator: ForkJoinPool.commonPool-worker-2 accmulator: ForkJoinPool.commonPool-worker-3 [a, b, f, hello, welcome] accmulator: ForkJoinPool.commonPool-worker-4 [a, b, world, d, f, g, hello, welcome] accmulator: ForkJoinPool.commonPool-worker-3 [a, b, world, d, f, hello, welcome] accmulator: ForkJoinPool.commonPool-worker-2 [a, b, d, f, hello, welcome] accmulator: ForkJoinPool.commonPool-worker-1 [a, b, world, c, d, e, f, g, hello, welcome] accmulator: ForkJoinPool.commonPool-worker-1 [a, b, world, c, d, f, g, hello, welcome] accmulator: ForkJoinPool.commonPool-worker-2 characteristics invoked! finisher invoked! {a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome} \",\"如果执行的次数过多，还有可能会出现如下报错：\",\"Exception in thread \\\"main\\\" java.util.ConcurrentModificationException: java.util.ConcurrentModificationException \",\"这是因为设置了CONCURRENT特性，多个线程就会操作同一个中间结果容器，而在我们的程序中，除了往集合中不断累加元素之外，还在打印集合中的元素：\",\" public BiConsumer<Set<T>, T> accumulator() { System.out.println(\\\"accmulator invoked!\\\"); return (set, item) -> { set.add(item); System.out.println(\\\"accmulator: \\\" + Thread.currentThread().getName()); }; } \",\"这将导致，偶发的情况下就会出现并发修改的异常，这就要求在在定义Collector的是偶，如果设置了CONCURRENT特性，accumulator方法只能进行累积的操作，而尽量不要进行其他的操作。\",\"总结一下，在使用并行流的时候，如果设置了CONCURRENT特性，那么多个线程就会操作操作同一个中间结果容器，而这个唯一的结果容器就是最终的结果容器，如果没有设置这个特性，那么就会操作不同的中间结果容器，换言之，如果设置了CONCURRENT特性，那么combiner就不会被调用，因为无需进行最后的合并操作，而如果没有设置，那么combiner就会得到调用。\",\"总而言之combiner被调用有两个条件，一个是并行流，一个是没有设置CONCURRENT特性，中间结果容器的个数也是类似的，只有当开启并行流，并且没有设置过CONCURRENT特性的时候才会创建和流中元素个数相同的中间结果容器。\",\"开启并行流的方式除了之前我们使用过的parallelStream，其实还可以这样：\",\"Map<String, String> map = set.stream().parallel().collect(new MySetCollector2<>()); \",\"如果要使用串行流，你也可以：\",\"Map<String, String> map = set.stream().sequential().collect(new MySetCollector2<>()); \",\"甚至可以：\",\"Map<String, String> map = set.stream().sequential().parallel().sequential().collect(new MySetCollector2<>()); \",\"但需要注意的是，这里程序并不会依次的调用，而是会调用最后指定的方式，也就是说，上面的代码其实等价于：\",\"Map<String, String> map = set.stream().sequential().collect(new MySetCollector2<>()); \",\"这两种写法完全是等价的，这是因为，选择并行流还是串行流，仅仅是由一个布尔值来控制的：\",\" /** * True if pipeline is parallel, otherwise the pipeline is sequential; only * valid for the source stage. */ private boolean parallel; \"]},\"1618\":{\"h\":\"Collectors源码分析\",\"t\":[\"自定义Collector的过程帮助我们很好的理解了关于Collector的基本概念，我们也尝试着自己实现了两个相对比较简单的例子，Collectors作为生产Collector的静态工厂类，里面有大量的关于Collector的实现，本节我们就分析JDK已经帮我们实现的Collector的例子，学习这些例子，有助于我们强化对于Collector的理解。\",\"对于Collectors静态工厂来说，实现Collector，总的来说分为两种情况：\",\"通过CollectorImpl来实现\",\"通过reducing方法来实现，而reducing方法本身又是通过CollectorImpl来实现的。\",\"首先我们来分析一下我们使用过的最多的toList方法：\",\" public static <T> Collector<T, ?, List<T>> toList() { return new CollectorImpl<>((Supplier<List<T>>) ArrayList::new, List::add, (left, right) -> { left.addAll(right); return left; }, CH_ID); } \",\"这里的(Supplier<List<T>>) ArrayList::new也可以写成ArrayList<T>::new，这里的第四个参数是：\",\" static final Set<Collector.Characteristics> CH_ID = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH)); \",\"这里的属性值是IDENTITY_FINISH，意味着中间结果容器的类型和最终返回的结果类型相同，所以无需定义finisher。对于toList还有一个接受的更宽广的toCollection：\",\" public static <T, C extends Collection<T>> Collector<T, ?, C> toCollection(Supplier<C> collectionFactory) { return new CollectorImpl<>(collectionFactory, Collection<T>::add, (r1, r2) -> { r1.addAll(r2); return r1; }, CH_ID); } \",\"这里只是提供了创建结果容器的入口，例如，要使用LinkedList，你只需要：\",\"list.stream().collect(Collectors.toCollection(LinkedList::new)); \",\"对于toSet方法：\",\" public static <T> Collector<T, ?, Set<T>> toSet() { return new CollectorImpl<>((Supplier<Set<T>>) HashSet::new, Set::add, (left, right) -> { left.addAll(right); return left; }, CH_UNORDERED_ID); } \",\"由于Set集合本身是无序的，并且最终返回的结果也是Set类型，所以它的特性值是：\",\" static final Set<Collector.Characteristics> CH_UNORDERED_ID = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.UNORDERED, Collector.Characteristics.IDENTITY_FINISH)); \",\"对于joining方法：\",\" public static Collector<CharSequence, ?, String> joining() { return new CollectorImpl<CharSequence, StringBuilder, String>( StringBuilder::new, StringBuilder::append, (r1, r2) -> { r1.append(r2); return r1; }, StringBuilder::toString, CH_NOID); } \",\"joining方法与之前的方法不同的是，它还调用了finisher方法，这是因为需要将StringBuilder转为String类型。这里的第四个参数指的是：\",\"static final Set<Collector.Characteristics> CH_NOID = Collections.emptySet(); \",\"返回的是一个空的集合，说明三个特性都不具备。\",\"joining还有一个重载的方法，可以增加前缀和后缀：\",\" public static Collector<CharSequence, ?, String> joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) { return new CollectorImpl<>( () -> new StringJoiner(delimiter, prefix, suffix), StringJoiner::add, StringJoiner::merge, StringJoiner::toString, CH_NOID); } \",\"StringJoiner是JDK1.8提供的一个新的类，用于完成字符串的拼接操作。\",\" public static <T, U, A, R> Collector<T, ?, R> mapping(Function<? super T, ? extends U> mapper, Collector<? super U, A, R> downstream) { BiConsumer<A, ? super U> downstreamAccumulator = downstream.accumulator(); return new CollectorImpl<>(downstream.supplier(), (r, t) -> downstreamAccumulator.accept(r, mapper.apply(t)), downstream.combiner(), downstream.finisher(), downstream.characteristics()); } \",\"这是一个相对比较复杂的例子，我们先来读一下方法说明：\",\"Adapts a Collector accepting elements of type U to one accepting elements of type T by applying a mapping function to each input element before accumulation. \",\"mapping方法被用来在累积操作之前对每个输入元素都应用mapping方法，将接收的U类型映射为T类型，从而实现收集器的映射。\",\"方法本身接收两个参数：\",\"mapper – a function to be applied to the input elements downstream – a collector which will accept mapped values \",\"这里的下游指的是，将要被映射的值，给出了一个具体的案例：\",\" Map<City, Set<String>> lastNamesByCity = people.stream().collect(groupingBy(Person::getCity, mapping(Person::getLastName, toSet()))); \",\"比这个例子稍微复杂一点的例子：\",\" public static<T,A,R,RR> Collector<T,A,RR> collectingAndThen(Collector<T,A,R> downstream, Function<R,RR> finisher) { Set<Collector.Characteristics> characteristics = downstream.characteristics(); if (characteristics.contains(Collector.Characteristics.IDENTITY_FINISH)) { if (characteristics.size() == 1) // 如果只有IDENTITY_FINISH特性，就将特性值设置为空 characteristics = Collectors.CH_NOID; else { // 将IDENTITY_FINISH去掉 characteristics = EnumSet.copyOf(characteristics); characteristics.remove(Collector.Characteristics.IDENTITY_FINISH); characteristics = Collections.unmodifiableSet(characteristics); } } return new CollectorImpl<>(downstream.supplier(), downstream.accumulator(), downstream.combiner(), downstream.finisher().andThen(finisher), characteristics); } \",\"首先来读一下方法的说明：\",\"Adapts a Collector to perform an additional finishing transformation. For example, one could adapt the toList() collector to always produce an immutable list with: \",\"适配一个Collector来执行finisher方法的转换，例如，我们可以使用这个方法将使用toList收集的方法来转换为一个不可变的集合，例如：\",\" List<String> people = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList)); \",\"toList本身方法返回的是一个ArrayList对象，本身是可变的，通过这种方式就可以得到一个不可变的集合列表，方法实现中将原来流中的IDENTITY_FINISH特性去掉的原因在于，如果设置了这个特性值，finisher方法就不会得到执行，而collectingAndThen方法的目的就在于转换最终的结果类型，关键就在于需要执行的finisher方法。\",\"接下来我们看一个之前使用的方法，summingInt的实现：\",\" public static <T> Collector<T, ?, Integer> summingInt(ToIntFunction<? super T> mapper) { return new CollectorImpl<>( () -> new int[1], (a, t) -> { a[0] += mapper.applyAsInt(t); }, (a, b) -> { a[0] += b[0]; return a; }, a -> a[0], CH_NOID); } \",\"summingInt方法的说明：\",\"Returns a Collector that produces the sum of a integer-valued function applied to the input elements. If no elements are present, the result is 0. \",\"返回的Collector是对流中的每一个元素执行传入的整型值函数，如果流中没有元素，就返回0。\",\"需要说明的是，这里为什么不直接使用数字，而是new了一个int类型的数组，原因在于数字是值类型的，而数组是引用类型的，值类型的参数无法进行传递，数组本身也符合容器的定义，只不过这里每次只是取出来数组中唯一的元素，对数组中唯一的元素进行累加的操作。\",\"以上都是通过CollectorImpl来实现的Collector，接下来我们看一下通过reducing来实现的例子，首先来查看reducing方法的定义：\",\" public static <T, U> Collector<T, ?, U> reducing(U identity, Function<? super T, ? extends U> mapper, BinaryOperator<U> op) { return new CollectorImpl<>( boxSupplier(identity), (a, t) -> { a[0] = op.apply(a[0], mapper.apply(t)); }, (a, b) -> { a[0] = op.apply(a[0], b[0]); return a; }, a -> a[0], CH_NOID); } \",\"reducing方法也是借助CollectorImpl来实现的Collector的，我们来阅读一下reducing方法的说明：\",\"Returns a Collector which performs a reduction of its input elements under a specified mapping function and BinaryOperator. This is a generalization of reducing(Object, BinaryOperator) which allows a transformation of the elements before reduction. \",\"groupingBy和partitioningBy是整个Collectors类中比较难以理解的两部分，关键的部分在于，理解每个泛型代表的含义以及每个参数的作用，在有了前面的基础之后，我们有必要了解一下有关分区和分组的实现。首先来看一下groupingBy方法的定义：\",\" public static <T, K> Collector<T, ?, Map<K, List<T>>> groupingBy(Function<? super T, ? extends K> classifier) { return groupingBy(classifier, toList()); } \",\"T类型表示流中元素的类型，？表示的是中间结果容器的类型，Map是最终的结果类型，K表示分类的时候的key的类型，List<T>就表示根据分类依据K分类之后的列表集合，方法本身的参数并没有直接使用T和K，而是使用T类型以及T以上的类型，K类型以及K类型以下的类型，并且只接受一个参数，调用了另一个重载的groupingBy方法：\",\" public static <T, K, A, D> Collector<T, ?, Map<K, D>> groupingBy(Function<? super T, ? extends K> classifier, Collector<? super T, A, D> downstream) { return groupingBy(classifier, HashMap::new, downstream); } \",\"方法的第一个参数是一个Function类型，第二个参数是Collector类型的，同样的，我们需要搞清楚这里每一个泛型的含义，T表示流中元素的类型，K表示分类器返回的结果的类型，或者说是返回的Map的key的类型，D表示Map返回的值的类型，方法要完成的事情实际上就是要将downstream在收集的时候，应用分类器classifier。它本身又调用一个重载的方法，在查看之前首先需要了解一个JDK中新增加的方法，在最终构造返回的accumulator的时候，我们要用到Map接口中所新增加的默认方法computeIfAbsent：\",\"default V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) { Objects.requireNonNull(mappingFunction); // V表示当前map的值的类型 V v; if ((v = get(key)) == null) { V newValue; if ((newValue = mappingFunction.apply(key)) != null) { put(key, newValue); return newValue; } } return v; } \",\"方法的说明：\",\"If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null. \",\"如果给定一个key与值没有关联起来（或者键映射为空），直接返回结果，如果它不为空的话，将尝试着计算他们的值使用给定的映射方法，就将他放入到map里面。总而言之，如果key不存在，则返回，如果存在，就执行mappingFunction，然后将映射之后的值放入到map当中。\",\"下面的方式是groupingBy真正执行的方法：\",\"public static <T, K, D, A, M extends Map<K, D>> Collector<T, ?, M> groupingBy(Function<? super T, ? extends K> classifier, Supplier<M> mapFactory, Collector<? super T, A, D> downstream) { // A表示下游收集器的中间结果容器类型 Supplier<A> downstreamSupplier = downstream.supplier(); // T表示流中元素的类型 BiConsumer<A, ? super T> downstreamAccumulator = downstream.accumulator(); // 构造最终所返回的累加器对象 BiConsumer<Map<K, A>, T> accumulator = (m, t) -> { K key = Objects.requireNonNull(classifier.apply(t), \\\"element cannot be mapped to a null key\\\"); A container = m.computeIfAbsent(key, k -> downstreamSupplier.get()); downstreamAccumulator.accept(container, t); }; // 完成两个Map的合并操作 BinaryOperator<Map<K, A>> merger = Collectors.<K, A, Map<K, A>>mapMerger(downstream.combiner()); // 将M类型强转为<K,A>类型，M本身是<K,D>类型，由于中间结果类型一定是<K,A>类型，所以可以强转成功。 @SuppressWarnings(\\\"unchecked\\\") Supplier<Map<K, A>> mangledFactory = (Supplier<Map<K, A>>) mapFactory; if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) { return new CollectorImpl<>(mangledFactory, accumulator, merger, CH_ID); } else { // 下游收集器本身返回的是<A,D>类型的，这里也是由于一定是<A,A>类型的，所以可以强转成功。 @SuppressWarnings(\\\"unchecked\\\") Function<A, A> downstreamFinisher = (Function<A, A>) downstream.finisher(); // 将Map中的键值对替换 Function<Map<K, A>, M> finisher = intermediate -> { intermediate.replaceAll((k, v) -> downstreamFinisher.apply(v)); @SuppressWarnings(\\\"unchecked\\\") M castResult = (M) intermediate; return castResult; }; return new CollectorImpl<>(mangledFactory, accumulator, merger, finisher, CH_NOID); } } \",\"第一个参数是一个分类器，输入类型是T，返回的是K类型，第二个参数是accumulator累加器的类型，对应上面例子中的HashMap::new，第三个参数是下游收集器，其中的A表示的是中间结果的容器类型，在整个方法的返回类型中，泛型M的定义是M extends Map<K, D>。首先我们来阅读以下这个方法的说明：\",\"Returns a Collector implementing a cascaded \\\"group by\\\" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector. The Map produced by the Collector is created with the supplied factory function. \",\"groupingBy方法返回了完成对于给定T类型的层叠的分组操作的Collector，它是根据提供的分类器来对元素进行分组的，然后会对于给定的key所关联的值（即Map）使用给定的下游收集器执行汇聚操作，Collector所使用的Map是由supplied工厂函数提供的。\",\"The classification function maps elements to some key type K. The downstream collector operates on elements of type T and produces a result of type D. The resulting collector produces a Map<K, D>. \",\"分类器方法会将元素映射成某个k类型，然后下游收集器会对流中T类型的元素生成一个D类型的结果，所生成的collector类型是Map<K,D>。\",\"For example, to compute the set of last names of people in each city, where the city names are sorted: \",\"比如要根据城市的名字对城市中每个人的姓进行分组，并且返回的结果要求带有排序的功能：\",\" Map<City, Set<String>> namesByCity = people.stream().collect(groupingBy(Person::getCity, TreeMap::new, mapping(Person::getLastName, toSet()))); \",\"关于分组的方法还有另外的说明：\",\"The returned Collector is not concurrent. For parallel stream pipelines, the combiner function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using groupingByConcurrent(Function, Supplier, Collector) may offer better parallel performance. \",\"groupingBy方法返回的Collector不是并发的，对于并行流管道，combiner方法会将一个map的key合并到另一个当中，这可能是一个昂贵的操作，如果对于下游收集器而言，元素的顺序不是很重要的话，建议使用groupingByConcurrent，它可以提供更好的并发的性能：\",\" public static <T, K, A, D> Collector<T, ?, ConcurrentMap<K, D>> groupingByConcurrent(Function<? super T, ? extends K> classifier, Collector<? super T, A, D> downstream) { return groupingByConcurrent(classifier, ConcurrentHashMap::new, downstream); } \",\"原因就在于groupingByConcurrent使用的是ConcurrentHashMap。\",\"与groupingBy相关联的另一个方法就是分区partitioningBy：\",\" public static <T> Collector<T, ?, Map<Boolean, List<T>>> partitioningBy(Predicate<? super T> predicate) { return partitioningBy(predicate, toList()); } \",\"它也有两个重载的方法：\",\" public static <T, D, A> Collector<T, ?, Map<Boolean, D>> partitioningBy(Predicate<? super T> predicate, Collector<? super T, A, D> downstream) { BiConsumer<A, ? super T> downstreamAccumulator = downstream.accumulator(); BiConsumer<Partition<A>, T> accumulator = (result, t) -> downstreamAccumulator.accept(predicate.test(t) ? result.forTrue : result.forFalse, t); BinaryOperator<A> op = downstream.combiner(); BinaryOperator<Partition<A>> merger = (left, right) -> new Partition<>(op.apply(left.forTrue, right.forTrue), op.apply(left.forFalse, right.forFalse)); Supplier<Partition<A>> supplier = () -> new Partition<>(downstream.supplier().get(), downstream.supplier().get()); if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) { return new CollectorImpl<>(supplier, accumulator, merger, CH_ID); } else { Function<Partition<A>, Map<Boolean, D>> finisher = par -> new Partition<>(downstream.finisher().apply(par.forTrue), downstream.finisher().apply(par.forFalse)); return new CollectorImpl<>(supplier, accumulator, merger, finisher, CH_NOID); } } \",\"这里的Partition是用来定义分组结果的一个静态内部类：\",\" private static final class Partition<T> extends AbstractMap<Boolean, T> implements Map<Boolean, T> { final T forTrue; final T forFalse; Partition(T forTrue, T forFalse) { this.forTrue = forTrue; this.forFalse = forFalse; } @Override public Set<Map.Entry<Boolean, T>> entrySet() { return new AbstractSet<Map.Entry<Boolean, T>>() { @Override public Iterator<Map.Entry<Boolean, T>> iterator() { Map.Entry<Boolean, T> falseEntry = new SimpleImmutableEntry<>(false, forFalse); Map.Entry<Boolean, T> trueEntry = new SimpleImmutableEntry<>(true, forTrue); return Arrays.asList(falseEntry, trueEntry).iterator(); } @Override public int size() { return 2; } }; } } \",\"之所以这么做的原因是，分区一定是固定的两组结果，如果再使用Map类描述的话并不是特别清晰。\",\"收集器是我们认识整个Stream的第一步，在了解了有关收集器的内容之后，可以为我们了解Stream打下良好的基础，这一部分是整个函数式编程最核心的部分，我们将会看到JDK在底层到底是如何巧妙的实现函数式编程。\"]},\"1619\":{\"h\":\"Stream源码分析\",\"t\":[\"在正式开始介绍之前，需要有一些预备的知识，从JDK1.7开始增加了这样一个接口：\",\"public interface AutoCloseable { void close() throws Exception; } \",\"方法的说明：\",\"An object that may hold resources (such as file or socket handles) until it is closed. The close() method of an AutoCloseable object is called automatically when exiting a try-with-resources block for which the object has been declared in the resource specification header. This construction ensures prompt release, avoiding resource exhaustion exceptions and errors that may otherwise occur. \",\"这是一个关闭之前可能持有一些资源（比如文件、socket句柄）的对象，它的close方法会在退出 try-with-resources代码块的时候自动得到调用，这种调用的机制被声明在资源的规范的头里面，这种设置确保了可以适当的释放一些资源，避免了资源被消耗尽造异常外和错误。\",\"举个例子：\",\"public class AutoCloseableTest implements AutoCloseable { @Override public void close() throws Exception { System.out.println(\\\"close invoked!\\\"); } public void doSomething() { System.out.println(\\\"doSomething invoked!\\\"); } public static void main(String[] args) throws Exception { try (AutoCloseableTest autoCloseableTest = new AutoCloseableTest()) { autoCloseableTest.doSomething(); } } } \",\"使用这种方式可以替换原来的需要人为的显示关闭各种流的操作，close方法会自动的得到调用：\",\"doSomething invoked! close invoked! \",\"接下来我们就完整的梳理一下关于Sream类本身的内容：\",\"A sequence of elements supporting sequential and parallel aggregate operations. The following example illustrates an aggregate operation using Stream and IntStream: \",\"首先Stream是一个支持并行与串行聚合操作的元素的序列，下面的示例演示了如何让使用Stream和IntStream进行聚合操作：\",\"int sum = widgets.stream() .filter(w -> w.getColor() == RED) .mapToInt(w -> w.getWeight()) .sum(); \",\"对于这个例子的说明：\",\"In this example, widgets is a Collection<Widget>. We create a stream of Widget objects via Collection.stream(), filter it to produce a stream containing only the red widgets, and then transform it into a stream of int values representing the weight of each red widget. Then this stream is summed to produce a total weight. \",\"在这个例子当中，widgets是Widget类型的集合，我们通过使用Collection的stream方法创建了一个Widget对象的流，生成了一个新的只包含红色的Widget的流，然后将它转换成int值的Stream对象，代表了每个红色Widget的重量，最后流被汇总起来生成一个总的重量。\",\"In addition to Stream, which is a stream of object references, there are primitive specializations for IntStream, LongStream, and DoubleStream, all of which are referred to as \\\"streams\\\" and conform to the characteristics and restrictions described here. \",\"Stream本身是一个对象引用流，除了他还有一些原生的、特化的版本。比如IntStream、LongStream、DoubleStream，他们都被称之为Stream，满足Stream的特性，遵循Stream的相关约束。\",\"To perform a computation, stream operations are composed into a stream pipeline. A stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more intermediate operations (which transform a stream into another stream, such as filter(Predicate)), and a terminal operation (which produces a result or side-effect, such as count() or forEach(Consumer)). Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed. \",\"为了进行计算，Stream会被组合成一个Stream pipeline（流管道）当中，一个流管道包含了一个元（可以是一个数组，一个集合，一个生成器法，一个I/O通道等等），包含0个或多个中间操作（会将一个Stream转换为另一个Stream，比如filter(Predicate)），包含一个终止操作（将会产生一个结果或者是有副作用的，比如count() 或者forEach(Consumer)），流是延迟的，只有当终止操作开始的时候，才会对元数据的计算才会真正的进行执行，元的数据只有在需要的时候才会被消费。\",\"Collections and streams, while bearing some superficial similarities, have different goals. Collections are primarily concerned with the efficient management of, and access to, their elements. By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. However, if the provided stream operations do not offer the desired functionality, the iterator() and spliterator() operations can be used to perform a controlled traversal. \",\"集合与流，他们有一些相似性，但是有不同的目标，集合主要考虑的是高效的访问和管理他们的元素，与之相反，流并不会直接提供直接的去操作元素的方式，而是通过声明式的方式来描述他们元以及操作，这些操作会被聚合起来应用到他们的元上面，流关注的是元的计算。然而，如果提供的流操作并没有所需要的功能，那么iterator()和spliterator() 就可以执行控制性的遍历（即采用传统的方式来进行一些流的操作）。\",\"A stream pipeline, like the \\\"widgets\\\" example above, can be viewed as a query on the stream source. Unless the source was explicitly designed for concurrent modification (such as a ConcurrentHashMap), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried. \",\"一个流管道，比如刚才的widgets，它可以被看成是一种对于流元的查询，除非这个流被显示的设计成可以并发修改的（比如ConcurrentHashMap），否则一些错误的型为就可能会产生并发修改的异常。\",\"Most stream operations accept parameters that describe user-specified behavior, such as the lambda expression w -> w.getWeight() passed to mapToInt in the example above. To preserve correct behavior, these behavioral parameters: \",\"大多数的流都会接收用户指定的一种行为，比如Lambda表达式 w -> w.getWeight()，为了保证最终结果的正确性，这些行为参数都要满足下面的这些条件特性：\",\"must be non-interfering (they do not modify the stream source); and in most cases must be stateless (their result should not depend on any state that might change during execution of the stream pipeline). \",\"他们必须是冲突非干扰的，\",\"在大多数情况下都是一种无状态的操作（结果不应该依赖于在流管道执行过程当中可能会修改的任意状态）,即执行的结果与执行的顺序是无关的\",\"Such parameters are always instances of a functional interface such as Function, and are often lambda expressions or method references. Unless otherwise specified these parameters must be non-null. \",\"这些参数总是一个函数式接口的实例。比如说Lamda表达式，除特殊情况外，参数都是非空的。\",\"stream should be operated on (invoking an intermediate or terminal stream operation) only once. This rules out, for example, \\\"forked\\\" streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream. A stream implementation may throw IllegalStateException if it detects that the stream is being reused. However, since some stream operations may return their receiver rather than a new stream object, it may not be possible to detect reuse in all cases. \",\"一个流调用中间操作或者终止操作只能被操作一次，这并不是绝对的，比如”派生“的流，相同的元会提供两个或多个流管道，或者对相同的元执行多次的遍历，如果检测到流被重用了，就会抛出IllegalStateException，然而有些流操作可能会返回他们的接收者而并不是一个新的Stream对象，这种情况下是无法检测到被重用的。\",\"Streams have a close() method and implement AutoCloseable, but nearly all stream instances do not actually need to be closed after use. Generally, only streams whose source is an IO channel (such as those returned by Files.lines(Path, Charset)) will require closing. Most streams are backed by collections, arrays, or generating functions, which require no special resource management. (If a stream does require closing, it can be declared as a resource in a try-with-resources statement.) \",\"流都实现了AutoCloseable接口，因此都会自动的调用close方法，但是几乎所有的流实例在使用完成之后都不需要关闭，只有当流的元是一个IO通道的时候（比如从Files.lines返回对象）需要被关闭，大多数流的元都是集合、数组、或者生成器函数，他们并不需要特殊的资源管理（如果一个流确实需要关闭，它会使用try-with-resources声明成一个资源）。\",\"Stream pipelines may execute either sequentially or in parallel. This execution mode is a property of the stream. Streams are created with an initial choice of sequential or parallel execution. (For example, Collection.stream() creates a sequential stream, and Collection.parallelStream() creates a parallel one.) This choice of execution mode may be modified by the sequential() or parallel() methods, and may be queried with the isParallel() method. \",\"流管道可以通过并行或者是串行的方式来去执行，这种执行方式只是流里面的一个属性而已，流初始被创建的时候就会选择串行还是并行的（比如Collection.stream() 创建的就是串行流，Collection.parallelStream()创建的就是并行流），这种执行模式的选择，还可以通过sequential()或者parallel() 方法进行修改，并且还可以通过isParallel() 方法来查询流的类型。\",\"以上就是关于Stream这个类的内容，Stream本身又继承了BaseStream类，BaseStream定义了所有流、流的操作、流管道以及并行流的行为和种类，我们首先来看一下BaseStream类的定义：\",\"public interface BaseStream<T, S extends BaseStream<T, S>> extends AutoCloseable { // 返回针对于流中元素的迭代器 Iterator<T> iterator(); // 这是流的终止操作，返回流中元素的分割迭代器 Spliterator<T> spliterator(); // 判断流是否是并行流，只能在流的终止操作之前进行调用 boolean isParallel(); // 返回一个等价的串行流，有可能会返回流本身，也有可能会将底层的流修改为串行流，这是一个中间操作 S sequential(); // 返回一个等价的并行流，有可能返回流本身，也有可能将底层的流修改为并行流，这是一个中间操作 S parallel(); // 返回一个无序的流，有可能返回流本身，原因是流本身就是无序的，这是一个中间操作 S unordered(); // 返回一个额外带有关闭处理器的流，当流的close方法被调用的时候，就会按照被添加进去的顺序得到调用，所有的关闭处理器都会得到调用而无论它之前的关闭处理器是否抛出了异常，如果任意的关闭处理器抛出了异常，那么抛出的第一个异常就会被抛给close方法的调用者，其余的异常就会作为被压制的异常（除非其余的异常是与第一个异常相同的异常，因为一个异常不能压制它本身），同样的，他也有可能返回自己 S onClose(Runnable closeHandler); // 关闭这个流，所有的流管道处理器都会得到调用 @Override void close(); } \",\"这里的泛型T代表流中元素的类型，S指的是实现了BaseStream类型的流对象，实际上指的就是中间操作返回的新的流对象，回到Stream类的定义：\",\"public interface Stream<T> extends BaseStream<T, Stream<T>> \",\"对照BaseStream的定义不难发现，这里的泛型S指的就是Stream<T>,而Stream<T>又正好继承了BaseStream，所以这个泛型是成立的。\",\"关于关闭处理器可以举一个简单的例子：\",\"public class StreamTest2 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); // 使用这种方式是为了执行Stream的close方法 try (Stream<String> stream = list.stream()) { stream.onClose(() -> { System.out.println(\\\"aaa\\\"); }).onClose(() -> { System.out.println(\\\"bbb\\\"); }).forEach(System.out::println); } } } \",\"控制台输出：\",\"hello world hello world aaa bbb \",\"修改一下程序，观察有异常发生的情况：\",\" try (Stream<String> stream = list.stream()) { stream.onClose(() -> { System.out.println(\\\"aaa\\\"); throw new NullPointerException(\\\"first exception\\\"); }).onClose(() -> { System.out.println(\\\"bbb\\\"); }).forEach(System.out::println); } \",\"就会输出：\",\"Exception in thread \\\"main\\\" hello world hello world aaa bbb java.lang.NullPointerException: first exception at Stream2.StreamTest2.lambda$main$0(StreamTest2.java:18) at java.util.stream.Streams$1.run(Streams.java:850) at java.util.stream.AbstractPipeline.close(AbstractPipeline.java:323) at Stream2.StreamTest2.main(StreamTest2.java:22) FAILURE: Build failed with an exception. \",\"可以看到虽然抛出了异常，但是后面的关闭处理器依然得到了执行。\",\"hello Exception in thread \\\"main\\\" world hello world aaa bbb java.lang.NullPointerException: first exception at Stream2.StreamTest2.lambda$main$0(StreamTest2.java:18) at java.util.stream.Streams$1.run(Streams.java:850) at java.util.stream.AbstractPipeline.close(AbstractPipeline.java:323) at Stream2.StreamTest2.main(StreamTest2.java:23) Suppressed: java.lang.NullPointerException: second exception at Stream2.StreamTest2.lambda$main$1(StreamTest2.java:21) at java.util.stream.Streams$1.run(Streams.java:854) ... 2 more \",\"这里的Suppressed就是压制的异常信息，可以看到后续的异常都被压制了,针对于文档中提到相同的异常，就不会被压制，指的是：\",\" NullPointerException nullPointerException = new NullPointerException(\\\"exception\\\"); try (Stream<String> stream = list.stream()) { stream.onClose(() -> { System.out.println(\\\"aaa\\\"); throw nullPointerException; }).onClose(() -> { System.out.println(\\\"bbb\\\"); throw nullPointerException; }).forEach(System.out::println); } \",\"控制台输出：\",\"hello Exception in thread \\\"main\\\" world hello world aaa bbb java.lang.NullPointerException: exception at Stream2.StreamTest2.main(StreamTest2.java:15) FAILURE: Build failed with an exception. \"]},\"1620\":{\"h\":\"Spliterator源码分析\",\"t\":[\"Spliterator被称之为分割迭代器，是整个流实现非常重要的一环，从本节开始，就正式进入的流源码的分析。\",\"首先还是定义一个非常简单的例子：\",\"public class StreamTest3 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); list.stream().forEach(System.out::println); } } \",\"这里调用的Collection接口中的stream方法：\",\"default Stream<E> stream() { return StreamSupport.stream(spliterator(), false); } \",\"我们来阅读一下方法的说明：\",\"Returns a sequential Stream with this collection as its source. This method should be overridden when the spliterator() method cannot return a spliterator that is IMMUTABLE, CONCURRENT, or late-binding. (See spliterator() for details.) \",\"stream方法会调用的将集合作为流的元，并且返回一个串行流，当spliterator方法无法返回IMMUTABLE（不可变的）、CONCURRENT（并行的）、late-binding（延迟绑定的）的分割迭代器，那么这个方法应该当被重写。\",\"stream方法的参数也是定义在Collection集合中的默认方法：\",\" default Spliterator<E> spliterator() { return Spliterators.spliterator(this, 0); } \",\"我们来看一下这个方法的说明：\",\"Creates a Spliterator over the elements in this collection. Implementations should document characteristic values reported by the spliterator. Such characteristic values are not required to be reported if the spliterator reports Spliterator.SIZED and this collection contains no elements. The default implementation should be overridden by subclasses that can return a more efficient spliterator. In order to preserve expected laziness behavior for the stream() and parallelStream()} methods, spliterators should either have the characteristic of IMMUTABLE or CONCURRENT, or be late-binding. If none of these is practical, the overriding class should describe the spliterator's documented policy of binding and structural interference, and should override the stream() and parallelStream() methods to create streams using a Supplier of the spliterator, as in: \",\"创建一个针对于这个集合的元素分割迭代器，实现应该对于spliterator方法所返回的Spliterator特性值进行文档化（记录下来），这些特性值并不要求去报告，如果这个Spliterator报告了Spliterator.SIZED，并且这个集合不包含任何元素，默认的实现应该要被子类所重写，目的是为了返回一个效率更高的分割迭代器，为了保留stream、parallelStream两个方法的延迟特性，spliterators的特性值要么是IMMUTABLE或者CONCURRENT，要么就是late-binding，如果上面这些都无法实现，重写的类需要文档化spliterator的绑定策略，并且使用spliterator的Supplier重写stream和parallelStream方法，例如：\",\" Stream<E> s = StreamSupport.stream(() -> spliterator(), spliteratorCharacteristics) \",\"应该使用这种方式来定义。\",\"These requirements ensure that streams produced by the stream() and parallelStream() methods will reflect the contents of the collection as of initiation of the terminal stream operation. \",\"这些要求确保了由stream和parallelStream方法生成的流从终止流操作开始发起的时候就反应出流的内容。\",\"The default implementation creates a late-binding spliterator from the collections's Iterator. The spliterator inherits the fail-fast properties of the collection's iterator. The created Spliterator reports Spliterator.SIZED. \",\"默认的实现会从集合的迭代器创建一个延迟绑定的分割迭代器，创建出来的分割迭代器继承了集合迭代器的快速失败（如果碰到问题，程序不再往下执行，直接抛出异常）的属性，创建出来的分割迭代器具有 Spliterator.SIZED（固定大小）的特性。\",\"The created Spliterator additionally reports Spliterator.SUBSIZED. \",\"所创建出来的Spliterator还有一个额外的特性：Spliterator.SUBSIZED（所分割出来的每个块的大小是固定的）。\",\"If a spliterator covers no elements then the reporting of additional characteristic values, beyond that of SIZED and SUBSIZED, does not aid clients to control, specialize or simplify computation. However, this does enable shared use of an immutable and empty spliterator instance (see Spliterators.emptySpliterator()) for empty collections, and enables clients to determine if such a spliterator covers no elements. \",\"如果分割迭代器中没有任何元素，那么除了IZED和SUBSIZED其他的特性值并不会简化客户端的计算，但是可以重用一个空的、不可变的分割迭代器，是不是里面没有元素，并且对于空的集合，可以帮助客户端来判断spliterator里面是不是没有元素。\",\"Spliterator和Spliterators的关系就好像Collector和Collectors的关系一样，Spliterators针对于Spliterator提供了若干的静态方法，接下来就正式开始了解有关Spliterator的内容。\",\"An object for traversing and partitioning elements of a source. The source of elements covered by a Spliterator could be, for example, an array, a Collection, an IO channel, or a generator function. \",\"Spliterator是一个对于元中的元素进行遍历和分区的对象，Spliterator 元中的元素可以是数组，可以是集合，可以是IO通道，也可以是一个生成器函数。\",\"A Spliterator may traverse elements individually (tryAdvance()) or sequentially in bulk (forEachRemaining()). \",\"一个Spliterator可以使用tryAdvance单个的遍历元素，也可以使用forEachRemaining成块的遍历元素。\",\"A Spliterator may also partition off some of its elements (using trySplit) as another Spliterator, to be used in possibly-parallel operations. Operations using a Spliterator that cannot split, or does so in a highly imbalanced or inefficient manner, are unlikely to benefit from parallelism. Traversal and splitting exhaust elements; each Spliterator is useful for only a single bulk computation. \",\"一个Spliterator也可以对它的元素使用trySplit进行分区，形成另外的Spliterator，并且可以被并行的使用。如果使用Spliterator不能进行分割，或者分割的不平衡或者效率非常低的方式，那使用并行就并没有带来多少的好处。遍历和分割都会消耗元素，每一个Spliterator仅仅是对一个单块的计算是有用的（每一块元素都有自己的分割迭代器）。\",\"A Spliterator also reports a set of characteristics() of its structure, source, and elements from among ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, and SUBSIZED. These may be employed by Spliterator clients to control, specialize or simplify computation. For example, a Spliterator for a Collection would report SIZED, a Spliterator for a Set would report DISTINCT, and a Spliterator for a SortedSet would also report SORTED. Characteristics are reported as a simple unioned bit set. Some characteristics additionally constrain method behavior; for example if ORDERED, traversal methods must conform to their documented ordering. New characteristics may be defined in the future, so implementors should not assign meanings to unlisted values. \",\"Spliterator还会报告它的结构、元、元素的特性值ORDERED（有序的）、DISTINCT（不同的）、SORTED（排序的）、SIZED（确定大小的）、NONNULL（不为空的）、IMMUTABLE（不可变的）、CONCURRENT（并放大的）、SUBSIZED（子部分固定大小的），这些可以被Spliterator的客户端使用，使用他们来简化一些计算，比如说，如果元是Collection集合，那么它就会报告SIZED的特性值，如果元是Set集合，那么就会报告DISTINCT，如果元是SortedSet集合，那么就会报告SORTED，Characteristics会作为一个位操作来标识的，有一些特性值会额外限制方法的行为，比如ORDERED，那么遍历的时候就必须遵循遍历时候的顺序，未来可能会定义一些新的characteristics，所以不要使用这些特性值之外的值，可能会引起冲突。\",\"A Spliterator that does not report IMMUTABLE or CONCURRENT is expected to have a documented policy concerning: when the spliterator binds to the element source; and detection of structural interference of the element source detected after binding. A late-binding Spliterator binds to the source of elements at the point of first traversal, first split, or first query for estimated size, rather than at the time the Spliterator is created. A Spliterator that is not late-binding binds to the source of elements at the point of construction or first invocation of any method. Modifications made to the source prior to binding are reflected when the Spliterator is traversed. After binding a Spliterator should, on a best-effort basis, throw ConcurrentModificationException if structural interference is detected. Spliterators that do this are called fail-fast. The bulk traversal method (forEachRemaining()) of a Spliterator may optimize traversal and check for structural interference after all elements have been traversed, rather than checking per-element and failing immediately. \",\"当分割迭代器绑定到元上元素的时候，如果Spliterator没有报告IMMUTABLE或者CONCURRENT，期望可以文档化。并且在绑定之后，要对元素的结构上一些修改进行相应检测，延迟绑定的Spliterator会在元素第一次分割、遍历的，或者笫一次查询元素大小的时候绑定。而不是在Spliterator创建的时候绑定的，如果不是延迟绑定的Spliterator，就会在元创建的时候或者说第一次调用方法时候进行绑定。如果在绑定元之前对元进行了修改的话，这种修改就会在分割迭代器遍历的时候反映出来，如果绑定之后对元进行了修改，就会抛出ConcurrentModificationException的异常，按照这种方式我们称之为\\\"快速失败\\\"，块的遍历方法（例如forEachRemaining）会优化遍历并检测结构上的修改，在所有的元素都遍历之后，而不是对每个元素一次检测。\",\"Spliterators can provide an estimate of the number of remaining elements via the estimateSize method. Ideally, as reflected in characteristic SIZED, this value corresponds exactly to the number of elements that would be encountered in a successful traversal. However, even when not exactly known, an estimated value may still be useful to operations being performed on the source, such as helping to determine whether it is preferable to split further or traverse the remaining elements sequentially. \",\"Spliterators通过estimateSize方法来估算剩余元素的个数，理想情况下，通过特性值SIZED获取到的值就是之后遍历元素个数的值，不过，即便不是精确的知道待遍历元素的数量，一个估算的值，对于元的操作也是很有用的，比如可以帮助对元进行进一步的分割或者对于剩余的元素进行串行的遍历。\",\"Despite their obvious utility in parallel algorithms, spliterators are not expected to be thread-safe; instead, implementations of parallel algorithms using spliterators should ensure that the spliterator is only used by one thread at a time. This is generally easy to attain via serial thread-confinement, which often is a natural consequence of typical parallel algorithms that work by recursive decomposition. A thread calling trySplit() may hand over the returned Spliterator to another thread, which in turn may traverse or further split that Spliterator. The behaviour of splitting and traversal is undefined if two or more threads operate concurrently on the same spliterator. If the original thread hands a spliterator off to another thread for processing, it is best if that handoff occurs before any elements are consumed with tryAdvance(), as certain guarantees (such as the accuracy of estimateSize() for SIZED spliterators) are only valid before traversal has begun. \",\"尽管他们显著的功能在算法当中，分割迭代器并不被要求是线程安全的，相反，使用了spliterators并行算法的实现，应该确保了分割迭代器在某个时候一次只有一个线程使用，这可以使用serial thread-confinement这种模式来实现。这是一个通过递归解耦得到的自然的结果。一个调用了trySplit的一个线程，它可以将返回的Spliterator交由另一个线程接管，另一个线程可能会进一步的分割，分割以及遍历的行为是不确定的，如果两个或者多个线程操作同一个Spliterator，如果原来的线程将Spliterator交由另外一个线程处理的话，那么最好这种传递是发生在任何元素在使用tryAdvance方法消费之前完成，因为某些保证实在执行之前才是有效的（比如统计元素个数的estimateSize方法，SIZED特性值）。\",\"Primitive subtype specializations of Spliterator are provided for int, long, and double values. The subtype default implementations of tryAdvance(Consumer) and forEachRemaining(Consumer) box primitive values to instances of their corresponding wrapper class. Such boxing may undermine any performance advantages gained by using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, Spliterator.OfInt.tryAdvance(IntConsumer) and Spliterator.OfInt.forEachRemaining(IntConsumer) should be used in preference to Spliterator.OfInt.tryAdvance(Consumer) and Spliterator.OfInt.forEachRemaining(Consumer). Traversal of primitive values using boxing-based methods tryAdvance() and forEachRemaining() does not affect the order in which the values, transformed to boxed values, are encountered. \",\"原生的子类型的特化也提供了。比如int、long、double，普通的方法接收的参数tryAdvance(Consumer) and forEachRemaining(Consumer)，这些参数就会使用包装类型，这样就有可能影响了性能上的优势，为了避免装箱拆箱操作带来的性能消耗，就应该使用Spliterator.OfInt.tryAdvance(IntConsumer) 和Spliterator.OfInt.forEachRemaining(IntConsumer) ，如果可以使用特化版本就不要使用通用版本。无论使用哪种方式，元素的顺序与之前的保持一致。\",\"Spliterators, like Iterators, are for traversing the elements of a source. The Spliterator API was designed to support efficient parallel traversal in addition to sequential traversal, by supporting decomposition as well as single-element iteration. In addition, the protocol for accessing elements via a Spliterator is designed to impose smaller per-element overhead than Iterator, and to avoid the inherent race involved in having separate methods for hasNext() and next(). \",\"Spliterators就像Iterators一样，也是用来遍历元当中的元素的，Spliterator的API设计为串行和高效的并行方式来进行元素的遍历，通过支持解耦、分解、单元素的遍历迭代，此外，相对于Iterator，使用Spliterator来遍历元素的成本是更低的，因为避免了在使用hasNext和next方法的竞争的出现（使用Iterators遍历元素通常需要两者搭配使用，但Spliterator只需要通过一个方法tryAdvance）。\",\"For mutable sources, arbitrary and non-deterministic behavior may occur if the source is structurally interfered with (elements added, replaced, or removed) between the time that the Spliterator binds to its data source and the end of traversal. For example, such interference will produce arbitrary, non-deterministic results when using the java.util.stream framework. \",\"对于可变的元来说，如果元在绑定了Spliterator之后，遍历结束之前在结构上被修改了（元素的添加、替换、移除）就可能出现一些不确定的行为，比如说，在使用java.util.stream 框架的这种修改可能出现这些不确定的结果。\",\"Structural interference of a source can be managed in the following ways (in approximate order of decreasing desirability): \",\"一个元在结构上的改变是可以通过如下的几种方式来进行管理的：\",\"The source cannot be structurally interfered with. For example, an instance of java.util.concurrent.CopyOnWriteArrayList is an immutable source. A Spliterator created from the source reports a characteristic of IMMUTABLE. \",\"1、元的结构是不能被修改的，例如，java.util.concurrent.CopyOnWriteArrayLis就是一个不可变的元，通过这种元创建的Spliterator会返回一个IMMUTABLE的特性值。\",\"The source manages concurrent modifications. For example, a key set of a java.util.concurrent.ConcurrentHashMap is a concurrent source. A Spliterator created from the source reports a characteristic of CONCURRENT. \",\"2、元本身管理并发修改，例如java.util.concurrent.ConcurrentHashMap键的集合就是一个并发的元，通过这种元创建的Spliterator会返回一个CONCURRENT的特性值。\",\"The mutable source provides a late-binding and fail-fast Spliterator. Late binding narrows the window during which interference can affect the calculation; fail-fast detects, on a best-effort basis, that structural interference has occurred after traversal has commenced and throws ConcurrentModificationException. For example, ArrayList, and many other non-concurrent Collection classes in the JDK, provide a late-binding, fail-fast spliterator. \",\"3、可变的元提供了一种延迟绑定和快速失败的Spliterator，延迟绑定会限制修改影响计算的时间间隔，可变的元\",\"The mutable source provides a non-late-binding but fail-fast Spliterator. The source increases the likelihood of throwing ConcurrentModificationException since the window of potential interference is larger. \",\"4、可变的元提供了非延迟绑定但是快速失败的Spliterator，发生ConcurrentModificationException可能性就会增加，因为时间间隔增大了。\",\"The mutable source provides a late-binding and non-fail-fast Spliterator. The source risks arbitrary, non-deterministic behavior after traversal has commenced since interference is not detected. \",\"5、可变的元提供了延迟绑定但是非快速失败的Spliterator，这个时候元就有一些风险，在遍历已经开始之后就可能发生一些不确定的行为。\",\"The mutable source provides a non-late-binding and non-fail-fast Spliterator. The source increases the risk of arbitrary, non-deterministic behavior since non-detected interference may occur after construction. \",\"6、可变的元提供了延迟绑定并且快速失败的Spliterator，也会增加不确定的风险，在构造之后增加不确定的行为的可能。\",\"Example. Here is a class (not a very useful one, except for illustration) that maintains an array in which the actual data are held in even locations, and unrelated tag data are held in odd locations. Its Spliterator ignores the tags. \",\"这里给出了一个例子（并不具有实用性，只是为了说明问题），数据实际上是存储在数组的偶数位置上，不相关的标签数据是存放在基数的位置上的，它对应的Spliterator会忽略掉标签，即只关心偶书位置上的数据：\",\" class TaggedArray<T> { // 构造之后就是一个不可变的数组 private final Object[] elements; TaggedArray(T[] data, Object[] tags) { int size = data.length; // 数据和标签的个数应该相同 if (tags.length != size) throw new IllegalArgumentException(); this.elements = new Object[2 * size]; for (int i = 0, j = 0; i < size; ++i) { elements[j++] = data[i]; elements[j++] = tags[i]; } } public Spliterator<T> spliterator() { return new TaggedArraySpliterator<>(elements, 0, elements.length); } static class TaggedArraySpliterator<T> implements Spliterator<T> { private final Object[] array; // 当前的索引，在遍历的时候会自增 private int origin; // 超过最大索引值加1 private final int fence; TaggedArraySpliterator(Object[] array, int origin, int fence) { this.array = array; this.origin = origin; this.fence = fence; } public void forEachRemaining(Consumer<? super T> action) { for (; origin < fence; origin += 2) action.accept((T) array[origin]); } public boolean tryAdvance(Consumer<? super T> action) { if (origin < fence) { action.accept((T) array[origin]); // tag中的数据不需要 origin += 2; return true; } else return false; } public Spliterator<T> trySplit() { // 分开一半的范围 int lo = origin; // 取中点 int mid = ((lo + fence) >>> 1) & ~1; // 分割左侧的 if (lo < mid) { // 重新设置范围 origin = mid; return new TaggedArraySpliterator<>(array, lo, mid); } else // 太小了，无法分割 return null; } public long estimateSize() { return (long)((fence - origin) / 2); } public int characteristics() { return ORDERED | SIZED | IMMUTABLE | SUBSIZED; } } } \",\"上面的例子是一个串行的例子，接下来还提供了一个并行的例子。\",\"As an example how a parallel computation framework, such as the java.util.stream package, would use Spliterator in a parallel computation, here is one way to implement an associated parallel forEach, that illustrates the primary usage idiom of splitting off subtasks until the estimated amount of work is small enough to perform sequentially. Here we assume that the order of processing across subtasks doesn't matter; different (forked) tasks may further split and process elements concurrently in undetermined order. This example uses a java.util.concurrent.CountedCompleter; similar usages apply to other parallel task constructions. \",\"如何使用并行框架来尽心给计算，例如使用java.util.stream package，在并行情况下使用Spliterator，它描述了对于分割子任务的分割方法，如何将子任务进行分割，如果分割的足够小的话，再以串行的方式去执行，下面的例子使用了java.util.concurrent.CountedCompleter：\",\"static <T> void parEach(TaggedArray<T> a, Consumer<T> action) { Spliterator<T> s = a.spliterator(); long targetBatchSize = s.estimateSize() / (ForkJoinPool.getCommonPoolParallelism() * 8); new ParEach(null, s, action, targetBatchSize).invoke(); } static class ParEach<T> extends CountedCompleter<Void> { final Spliterator<T> spliterator; final Consumer<T> action; final long targetBatchSize; ParEach(ParEach<T> parent, Spliterator<T> spliterator, Consumer<T> action, long targetBatchSize) { super(parent); this.spliterator = spliterator; this.action = action; this.targetBatchSize = targetBatchSize; } public void compute() { Spliterator<T> sub; while (spliterator.estimateSize() > targetBatchSize && (sub = spliterator.trySplit()) != null) { addToPendingCount(1); new ParEach<>(this, sub, action, targetBatchSize).fork(); } spliterator.forEachRemaining(action); propagateCompletion(); } } \",\"If the boolean system property org.openjdk.java.util.stream.tripwire is set to true then diagnostic warnings are reported if boxing of primitive values occur when operating on primitive subtype specializations. \",\"如果系统变量org.openjdk.java.util.stream.tripwire被设置成true的话，如果在操作原生子类型特化的时候，对原生的子类型进行装箱操作，系统就会给出警告。\",\"以上是关于Spliterator这个类本身的说明，接下来Spliterator接口本身提供的一些方法进行说明：\",\"首先是tryAdvance方法：\",\"boolean tryAdvance(Consumer<? super T> action); \",\"方法的说明：\",\"If a remaining element exists, performs the given action on it, returning true; else returns false. If this Spliterator is ORDERED the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller. \",\"如果元素存在，就会对元素执行给定的action方法，同时true，否则返回false，如果这个Spliterator是ORDERED，就会对的下一个元素去执行action方法，由这个动作执行产生的任何的异常都会传递给调用者。\",\"接下来是forEachRemaining方法：\",\" default void forEachRemaining(Consumer<? super T> action) { do { } while (tryAdvance(action)); } \",\"方法的说明：\",\"Performs the given action for each remaining element, sequentially in the current thread, until all elements have been processed or the action throws an exception. If this Spliterator is ORDERED, actions are performed in encounter order. Exceptions thrown by the action are relayed to the caller.The default implementation repeatedly invokes tryAdvance until it returns false. It should be overridden whenever possible. \",\"对剩下的元素都执行action方法，在当前的线程是以串行的方式执行，知道所有的元素都已经被处理了，或者动作本身抛出了异常，如果Spliterator是ORDERED，action会以遇到元素的顺序去执行，由这个动作抛出的异常会被传递给调用者。默认的实现是不断的调用tryAdvance方法直到返回false，在合适的时候应该被重写。\",\"接下来是trySplit方法：\",\" Spliterator<T> trySplit(); \",\"方法的说明：\",\"If this spliterator can be partitioned, returns a Spliterator covering elements, that will, upon return from this method, not be covered by this Spliterator. If this Spliterator is ORDERED, the returned Spliterator must cover a strict prefix of the elements. Unless this Spliterator covers an infinite number of elements, repeated calls to trySplit() must eventually return null. Upon non-null return: \",\"如果这个Spliterator是可以被分割的，就会返回一个新的Spliterator对象，新的Spliterator可能可以进一步分割，剩余的元素是由当前的Spliterator继续涵盖的。\",\"如果这个Spliterator是ORDERED，所返回的Spliterator必须也是ORDERED，除了Spliterator涵盖的是一个无限元素的对象的情况，重复调用trySplit最终得到的结果一定是空，当不为空的情况出现的时候：\",\"the value reported for estimateSize() before splitting, must, after splitting, be greater than or equal to estimateSize() for this and the returned Spliterator; and \",\"1、在分割之前estimateSize方法所估算的元的大小的值，必须在分割之后，一定要大于或者等于当前的和返回的新的Spliterator的estimateSize方法所返回的值。\",\"if this Spliterator is SUBSIZED, then estimateSize() for this spliterator before splitting must be equal to the sum of estimateSize() for this and the returned Spliterator after splitting. \",\"2、如果Spliterator是SUBSIZED，那么在分割之前Spliterator的estimateSize的值必须等于分割之后所剩下的estimateSize以及剩下的Spliteratord的estimateSize加起来必须相等。\",\"This method may return null for any reason, including emptiness, inability to split after traversal has commenced, data structure constraints, and efficiency considerations. \",\"这个方法有可能会返回一个空值，包括原来的就是Spliterator就是空的，在遍历开始之后无法分割，数据结构上的限制，效率上的考量等等。\",\"n ideal trySplit method efficiently (without traversal) divides its elements exactly in half, allowing balanced parallel computation. Many departures from this ideal remain highly effective; for example, only approximately splitting an approximately balanced tree, or for a tree in which leaf nodes may contain either one or two elements, failing to further split these nodes. However, large deviations in balance and/or overly inefficient trySplit mechanics typically result in poor parallel performance. \",\"一种理想的trySplit方法在没有进行遍历的情况下，它会恰好就元素分成等量的两部分，这样并行计算的时候工作量是比较平均的。但更多的时候无法达到理想状态，比如说，只是分割一个近似平衡的树，或者对一个树，树中的叶子节点包含了一两个元素，没法再对这些节点进行进一步的分割，对于这种极度不平衡的树，没有效率的trySplit会是的并发执行的效率急剧下降。\",\"接下来是estimateSize方法：\",\"long estimateSize(); \",\"方法的说明：\",\"Returns an estimate of the number of elements that would be encountered by a forEachRemaining traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute. \",\"返回对于遍历可能会遇到的元中的元素的数量的估算值，如果元的元素是无限的、未知的、或者计算成本非常昂贵的时候，就会返回Long.MAX_VALUE。\",\"If this Spliterator is SIZED and has not yet been partially traversed or split, or this Spliterator is SUBSIZED and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of trySplit. \",\"如果这个Spliterator是SIZED，并且还没有被分割或者迭代，或者Spliterator是SUBSIZED的，但还没有被部分遍历，那么estimate返回的就一定是一个精确的值，就是要被遍历的元素的个数，否则，estimate估算就可能是不精确的，但是必须要随着trySplit方法的调用次数不断减少。\",\"Even an inexact estimate is often useful and inexpensive to compute. For example, a sub-spliterator of an approximately balanced binary tree may return a value that estimates the number of elements to be half of that of its parent; if the root Spliterator does not maintain an accurate count, it could estimate size to be the power of two corresponding to its maximum depth. \",\"estimate方法估算的值通常而言也是有用的，并且计算起来成本也不高，对一个近似平衡的二叉树的sub-spliterator，它会估算父亲节点的元素的一般，如果根Spliterator没有保存正确的计算结果，那么他就会根据树的深度返回2的指数次方，以此来估算元中元素的个数。\",\"接下来是getExactSizeIfKnown方法：\",\" default long getExactSizeIfKnown() { return (characteristics() & SIZED) == 0 ? -1L : estimateSize(); } \",\"方法的说明：\",\"Convenience method that returns estimateSize() if this Spliterator is SIZED, else -1. \",\"如果Spliterator是SIZED就会返回estimateSize的值，否则返回-1。\",\"接下来是characteristics方法：\",\"int characteristics(); \",\"方法的说明：\",\"Returns a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result. \",\"返回Spliterator和它的元素特性值的集合，这种结果用ORed值来表示的，共有八个，在trySplit调用之前和调用当中重复地调用这个方法，永远都会返回相同的结果。\",\"If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator. \",\"如果返回了不同的特性值的集合（分割之前和分割之后有可能特性值会不同），那么对于Spliterator的任何计算都是不受保障。\",\"接下来是hasCharacteristics方法：\",\" default boolean hasCharacteristics(int characteristics) { return (characteristics() & characteristics) == characteristics; } \",\"方法的说明：\",\"Returns true if this Spliterator's characteristics contain all of the given characteristics. \",\"判断当前的Spliterator是否包含传入的characteristics特性值。\",\"接下来是getComparator方法：\",\" default Comparator<? super T> getComparator() { throw new IllegalStateException(); } \",\"方法的说明：\",\"If this Spliterator's source is SORTED by a Comparator, returns that Comparator. If the source is SORTED in natural order, returns null. Otherwise, if the source is not SORTED, throws IllegalStateException. \",\"如果这个Spliterator的元通过Comparator是SORTED，那么返回用于排序的比较器，如果元在自然序列下是SORTED，返回null，如果元不是有序的，抛出IllegalStateException异常。\",\"接下来是八个特性值：\",\" public static final int ORDERED = 0x00000010; public static final int DISTINCT = 0x00000001; public static final int SORTED = 0x00000004; public static final int SIZED = 0x00000040; public static final int NONNULL = 0x00000100; public static final int IMMUTABLE = 0x00000400; // 不能同时返回SIZED和CONCURRENT，如果多个线程访问元，就有可能修改元的大小 public static final int CONCURRENT = 0x00001000; public static final int SUBSIZED = 0x00004000; \",\"除了以上非常核心的方法，Spliterator中还有两个接口OfPrimitive和OfInt。\",\"public interface OfPrimitive<T, T_CONS, T_SPLITR extends Spliterator.OfPrimitive<T, T_CONS, T_SPLITR>> extends Spliterator<T> { @Override T_SPLITR trySplit(); @SuppressWarnings(\\\"overloads\\\") boolean tryAdvance(T_CONS action); @SuppressWarnings(\\\"overloads\\\") default void forEachRemaining(T_CONS action) { do { } while (tryAdvance(action)); } } \",\"相关说明：\",\"A Spliterator specialized for primitive values. <T> – the type of elements returned by this Spliterator. The type must be a wrapper type for a primitive type, such as Integer for the primitive int type. <T_CONS> – the type of primitive consumer. The type must be a primitive specialization of Consumer for T, such as IntConsumer for Integer. <T_SPLITR> – the type of primitive Spliterator. The type must be a primitive specialization of Spliterator for T, such as Spliterator.OfInt for Integer. \",\"这是一个针对原生值设定的Spliterator，T表示由当前的Spliterator所返回的元素的类型，类型必须要是原生类型的包装类型，比如int类型的包装类型Integer。T_CONS是原生的consumer特化的类型，这个类型必须是java.util.function.Consumer原生类型的特化，比如对于Integer的IntConsumer，T_SPLITR是原生的Spliterator分割迭代器的类型，必须是对于T类型的原生类型的特化，比如对于Integer的OfInt。\",\" public interface OfInt extends OfPrimitive<Integer, IntConsumer, OfInt> { @Override OfInt trySplit(); // 重写的OfPrimitive中的tryAdvance方法 @Override boolean tryAdvance(IntConsumer action); @Override default void forEachRemaining(IntConsumer action) { do { } while (tryAdvance(action)); } // 重写的Spliterator中的tryAdvance方法 @Override default boolean tryAdvance(Consumer<? super Integer> action) { if (action instanceof IntConsumer) { // IntConsumer和Consumer类型并没有直接继承的关系，这可以强转的原因是如果参数是Integer类型的，由于自动拆箱和自动装箱的原因存在，传递的action如果是Lambda表达式就既满足了Consumer的要求，也满足了IntConsumer的要求，另外是由于Lambda表达式中的类型判断是需要结合具体的上下文的。 return tryAdvance((IntConsumer) action); } else { if (Tripwire.ENABLED) Tripwire.trip(getClass(), \\\"{0} calling Spliterator.OfInt.tryAdvance((IntConsumer) action::accept)\\\"); return tryAdvance((IntConsumer) action::accept); } } @Override default void forEachRemaining(Consumer<? super Integer> action) { if (action instanceof IntConsumer) { forEachRemaining((IntConsumer) action); } else { if (Tripwire.ENABLED) Tripwire.trip(getClass(), \\\"{0} calling Spliterator.OfInt.forEachRemaining((IntConsumer) action::accept)\\\"); forEachRemaining((IntConsumer) action::accept); } } } \",\"相关说明：\",\"A Spliterator specialized for int values. \",\"针对于int值的分割迭代器。\",\"这其中比较重要的是第二个tryAdvance方法，首先来看方法的说明\",\"If the action is an instance of IntConsumer then it is cast to IntConsumer and passed to tryAdvance(IntConsumer); otherwise the action is adapted to an instance of IntConsumer, by boxing the argument of IntConsumer, and then passed to tryAdvance(IntConsumer). \",\"如果action是IntConsumer的一个实例，那么就会被强转为IntConsumer并传递给tryAdvance(IntConsumer)，否则，action会被适配成IntConsumer实例，方式是通过IntConsumer的参数进行装箱操作，然后再传递给tryAdvance(IntConsumer)。\",\"对于上面注释中提到的为什么可以强转，我们通过一个具体的例子来说明：\",\"public class ConsumerTest { public void test(Consumer<Integer> consumer) { consumer.accept(100); } public static void main(String[] args) { ConsumerTest consumerTest = new ConsumerTest(); // 两个相同的Lambda表达式 Consumer<Integer> consumer = i -> System.out.println(i); IntConsumer intConsumer = i -> System.out.println(i); // 面向对象的方式 consumerTest.test(consumer); // 编译通过但执行报错 consumerTest.test((Consumer<Integer>) intConsumer); // 传递行为，函数式的方式 consumerTest.test(consumer::accept); consumerTest.test(intConsumer::accept); } } \",\"除了OfInt之外还有其他两种OfLong、OfDouble，原理和功能都是类似的。\"]},\"1621\":{\"h\":\"Pipeline源码分析\",\"t\":[\"分割迭代器无疑是函数式编程中一个相当核心的概念，其地位与收集器相同，在了解了分割迭代器的相关内容之后，我们再回到一开始的例子当中，看看JDK是如何使用分割迭代器来构造流源的，还是回到最开始的入口这里：\",\"default Stream<E> stream() { return StreamSupport.stream(spliterator(), false); } \",\"这里的spliterator方法是定义Collection接口当中的一个默认方法：\",\" default Spliterator<E> spliterator() { // 这里的this表示的是当前集合的引用，当前集合的引用就是在这个时候被传递进去的 return Spliterators.spliterator(this, 0); } \",\"Spliterators中静态方法spliterator返回了一个Spliterator实现：\",\" public static <T> Spliterator<T> spliterator(Collection<? extends T> c, int characteristics) { return new IteratorSpliterator<>(Objects.requireNonNull(c), characteristics); } \",\"可以看到我们实际上使用的分割迭代器是IteratorSpliterator，IteratorSpliterator是实现了Spliterator接口的一个实现类，它本身持有了元数据集合的引用。\",\"创建流元的过程是由StreamSupport这个类来完成的，以下是关于StreamSupport这个类的说明：\",\"Low-level utility methods for creating and manipulating streams. This class is mostly for library writers presenting stream views of data structures; most static stream methods intended for end users are in the various Stream classes. \",\"提供了一些创建和操作流的底层方法。这个类是给类库的编写者提供的，用于呈现流的数据视图，为用户所设计的大多数的静态的流的方法大多都在stream类中提的方法。\",\"StreamSupport中的stream方法：\",\" public static <T> Stream<T> stream(Spliterator<T> spliterator, boolean parallel) { Objects.requireNonNull(spliterator); return new ReferencePipeline.Head<>(spliterator, StreamOpFlag.fromCharacteristics(spliterator), parallel); } \",\"方法的说明：\",\"Creates a new sequential or parallel Stream from a Spliterator. The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences. It is strongly recommended the spliterator report a characteristic of IMMUTABLE or CONCURRENT, or be late-binding. Otherwise, stream(Supplier, int, boolean) should be used to reduce the scope of potential interference with the source. See Non-Interference for more details. \",\"从一个分割迭代器对象创建一个串行或者并行的流，spliterator在流管道开启之后仅仅是完成遍历、分割、查询、大小的等功能，强烈建议spliterator返回IMMUTABLE、CONCURRENT或者late-binding这样一些特性，否则，stream应该用于减少潜在的干扰，查看Non-Interference获取更多信息。\",\"这里引出了另外一个及其重要的类ReferencePipeline，用于描述中间的管道阶段和管道源阶段的的类，它与流的操作息息相关，Head是ReferencePipeline的一个静态内部类，描述的是管道的源阶段，二者在大部分属性的设定上都是类似的，但存在一些属性是不同的，比如说Head是没有previousStage的，而ReferencePipeline则是存在previousStage的，等等。接下来就需要重点了解管道流相关的内容。\",\"首先是定义在ReferencePipeline类当中的内部类Head：\",\" static class Head<E_IN, E_OUT> extends ReferencePipeline<E_IN, E_OUT> { Head(Supplier<? extends Spliterator<?>> source, int sourceFlags, boolean parallel) { super(source, sourceFlags, parallel); } // 这里Spliterator作为流的源 Head(Spliterator<?> source, int sourceFlags, boolean parallel) { super(source, sourceFlags, parallel); } @Override final boolean opIsStateful() { throw new UnsupportedOperationException(); } @Override final Sink<E_IN> opWrapSink(int flags, Sink<E_OUT> sink) { throw new UnsupportedOperationException(); } @Override public void forEach(Consumer<? super E_OUT> action) { if (!isParallel()) { sourceStageSpliterator().forEachRemaining(action); } else { super.forEach(action); } } @Override public void forEachOrdered(Consumer<? super E_OUT> action) { if (!isParallel()) { sourceStageSpliterator().forEachRemaining(action); } else { super.forEachOrdered(action); } } } \",\"Head类本身有两个泛型：\",\"<E_IN> – type of elements in the upstream source <E_OUT> – type of elements in produced by this stage \",\"E_IN表示上游流源的元素类型，E_OUT表示这个阶段生成的元素类型。\",\"真正在创建的时候又是调用了ReferencePipeline的构造方法：\",\" ReferencePipeline(Supplier<? extends Spliterator<?>> source, int sourceFlags, boolean parallel) { super(source, sourceFlags, parallel); } \",\"而ReferencePipeline的构造方法又调用了它的父类AbstractPipeline的构造方法：\",\" AbstractPipeline(Supplier<? extends Spliterator<?>> source, int sourceFlags, boolean parallel) { this.previousStage = null; this.sourceSupplier = source; this.sourceStage = this; this.sourceOrOpFlags = sourceFlags & StreamOpFlag.STREAM_MASK; // The following is an optimization of: // StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE); this.combinedFlags = (~(sourceOrOpFlags << 1)) & StreamOpFlag.INITIAL_OPS_VALUE; this.depth = 0; this.parallel = parallel; } \",\"AbstractPipeline的说明如下：\",\"Abstract base class for \\\"pipeline\\\" classes, which are the core implementations of the Stream interface and its primitive specializations. Manages construction and evaluation of stream pipelines. \",\"AbstractPipeline是对于管道类抽象出来的一个父类，管道类指的是流接口以及其原生特化的核心的实现，它会管理流管道的构建以及计算。\",\"An AbstractPipeline represents an initial portion of a stream pipeline, encapsulating a stream source and zero or more intermediate operations. The individual AbstractPipeline objects are often referred to as stages, where each stage describes either the stream source or an intermediate operation. \",\"AbstractPipeline代表了流管道初始的阶段，它封装了一个流源和0个或者多个中间操作，每一个单个的AbstractPipeline通常称为stages（阶段），这个阶段要么描述的是流的源，要么描述的是中间操作。\",\"A concrete intermediate stage is generally built from an AbstractPipeline, a shape-specific pipeline class which extends it (e.g., IntPipeline) which is also abstract, and an operation-specific concrete class which extends that. AbstractPipeline contains most of the mechanics of evaluating the pipeline, and implements methods that will be used by the operation; the shape-specific classes add helper methods for dealing with collection of results into the appropriate shape-specific containers. \",\"一个具体的中间阶段通常是通过AbstractPipeline构建出来的，特化的管道类（IntPipeline、LongPipeline）操作都是类似的，AbstractPipeline包含了大多数计算管道的机制，并且实现了操作的时候要使用的方法，与原生特定相关的类增加了用来处理结果集合添加到特定的特化的管道。\",\"After chaining a new intermediate operation, or executing a terminal operation, the stream is considered to be consumed, and no more intermediate or terminal operations are permitted on this stream instance. \",\"当链接一个新的中间操作，或者执行一个终止操作，流就会被认为被消费掉了，不会再有中间操作和终止操作添加到这个流实例上了。\",\"For sequential streams, and parallel streams without stateful intermediate operations, parallel streams, pipeline evaluation is done in a single pass that \\\"jams\\\" all the operations together. For parallel streams with stateful operations, execution is divided into segments, where each stateful operations marks the end of a segment, and each segment is evaluated separately and the result used as the input to the next segment. In all cases, the source data is not consumed until a terminal operation begins. \",\"对于串行流和中间操作都是无状态的并行流，管道的计算是在单个的过程中完成的（即不是通过链式调用，而是拿出一个元素执行所有的中间操作），对于有状态的并行流，管道的计算就会分成不同的段来执行，其中每一个有状态的都会标识一个段的结尾，每个段都会被单独的执行，而且每个段的执行结果会作为下一个段的输入（表示是有顺序的），直到一个终止操作开始的时候，源数据才会被消费。\",\"接下来是AbstractPipeline类中的一些属性：\",\" private final AbstractPipeline previousStage; \",\"属性的说明：\",\"The \\\"upstream\\\" pipeline, or null if this is the source stage. \",\"上游的pipline，如果是源阶段的话就是null。\",\" private final AbstractPipeline sourceStage; \",\"属性的说明：\",\"Backlink to the head of the pipeline chain (self if this is the source stage). \",\"表示管道反向链接的头（如果是源阶段就是它自身）。\",\" private int depth; \",\"属性的说明：\",\"The number of intermediate operations between this pipeline object and the stream source if sequential, or the previous stateful if parallel. Valid at the point of pipeline preparation for evaluation. \",\"当前的管道对象和流元的管道对象的中间操作的个数，在流准备进行计算的时候是有效的。\",\" private boolean parallel; \",\"属性的说明：\",\"True if pipeline is parallel, otherwise the pipeline is sequential; only valid for the source stage. \",\"如果是true表示并行，如果是false，表示串行，只有在流源这个阶段才有效。\",\" private Spliterator<?> sourceSpliterator; \",\"属性的说明：\",\"The source spliterator. Only valid for the head pipeline. Before the pipeline is consumed if non-null then sourceSupplier must be null. After the pipeline is consumed if non-null then is set to null. \",\"是针对于元的分割迭代器，只会head pipeline起作用，在管道被消费之前，如果sourceSpliterator是非空的话，那么sourceSupplier必须是null，管道被消费之后sourceSpliterator就要设置为空。\",\" private Supplier<? extends Spliterator<?>> sourceSupplier; \",\"属性的说明：\",\"The source supplier. Only valid for the head pipeline. Before the pipeline is consumed if non-null then sourceSpliterator must be null. After the pipeline is consumed if non-null then is set to null. \",\"supplier的元，只会head pipeline起作用，在管道被消费之前，如果sourceSupplier是空的，那么sourceSpliterator必须为空，在管道被消费之后，就要将sourceSupplier置为null。\",\"可以看到这两个成员变量可以认为是互斥的，必须要保证其中一个不为空，在流消费之后都要置为空，表示流已经消费完成，至此为止，流源的对象也已经构造完成。\"]},\"1622\":{\"h\":\"流调用机制与原理\",\"t\":[\"回到一开始的例子当中：\",\"list.stream().forEach(System.out::println); \",\"这里调用的第一个stream方法，使用分割迭代器来构造流源的这一步我们已经完成了，接下来我们来查看一下forEach方法的说明：\",\"Performs an action for each element of this stream. This is a terminal operation. \",\"它表示要对于流中每个元素都执行action操作，并且这是一个终止操作。\",\"The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does not guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library chooses. If the action accesses shared state, it is responsible for providing the required synchronization. \",\"这个操作的行为是不确定的，对于并行流管道来说，这个操作并不会保证它会遵循流当中元素的顺序，因为如果遵循的话，就会牺牲并行的优势，对于任意给定的元素，这个action可能会在任意的时间或者库所选择的任意线程中去执行，如果库访问了共享的状态，那么它就需要提供完整的同步机制。\",\"list.parallelStream().forEach(System.out::println); \",\"这其实指的就是如果使用并行流，那么就无法再保证执行给定的Lambda表达式的元素的顺序了，这个方法实际上在ReferencePipeline中是有两个实现的，一个是在它的静态内部类Head中：\",\" @Override public void forEach(Consumer<? super E_OUT> action) { // 对串行流进行优化 if (!isParallel()) { sourceStageSpliterator().forEachRemaining(action); } else { // 如果是并行流，调用ReferencePipeline中的forEach方法 super.forEach(action); } } \",\"这个是针对于管道源的有过优化的实现，换句话说，如果被流的源调用的话，就是直接进入这个方法，另一个forEach方法是在ReferencePipeline当中：\",\" @Override public void forEach(Consumer<? super P_OUT> action) { evaluate(ForEachOps.makeRef(action, false)); } \",\"当有中间操作的时候，都会进入这个方法，之所以会有这个差异，就是为了效率上的考量，如果有中间操作的话，就需要对于中间操作进行一般化的处理，如果没有的话，就可以直接对流源进行操作。\",\"我们不妨来看一下优化的时候调用的sourceStageSpliterator方法，它是定义在AbstractPipeline当中的\",\" final Spliterator<E_OUT> sourceStageSpliterator() { if (this != sourceStage) throw new IllegalStateException(); // 被链接或者被消费，为了保证是在源阶段 if (linkedOrConsumed) // MSG_STREAM_LINKED = \\\"stream has already been operated upon or closed\\\"; throw new IllegalStateException(MSG_STREAM_LINKED); linkedOrConsumed = true; // 流源可能通过两种方式来构建，因此有两种情况，并且这两种情况是互斥的 if (sourceStage.sourceSpliterator != null) { @SuppressWarnings(\\\"unchecked\\\") Spliterator<E_OUT> s = sourceStage.sourceSpliterator; sourceStage.sourceSpliterator = null; return s; } else if (sourceStage.sourceSupplier != null) { @SuppressWarnings(\\\"unchecked\\\") Spliterator<E_OUT> s = (Spliterator<E_OUT>) sourceStage.sourceSupplier.get(); sourceStage.sourceSupplier = null; return s; } else { // MSG_CONSUMED = \\\"source already consumed or closed\\\"; throw new IllegalStateException(MSG_CONSUMED); } } \",\"方法的说明：\",\"Gets the source stage spliterator if this pipeline stage is the source stage. The pipeline is consumed after this method is called and returns successfully. \",\"如果管道的阶段是源阶段的话，就会返回源阶段的分割迭代器，这个管道在被调用之后，就会返回并且销毁。\",\"我们知道一般情况下分割迭代器返回的是IteratorSpliterator实现，我们来看一下IteratorSpliterator中对于forEachRemaining的实现：\",\" @Override public void forEachRemaining(Consumer<? super T> action) { if (action == null) throw new NullPointerException(); Iterator<? extends T> i; // it是Spliterator中定义的迭代器 if ((i = it) == null) { // 当前集合的迭代器 i = it = collection.iterator(); est = (long)collection.size(); } i.forEachRemaining(action); } \",\"这里将集合中的迭代器找出来并且估算元素的大小，然后再调用Iterator中的新增加的forEachRemaining方法：\",\" default void forEachRemaining(Consumer<? super E> action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); } \",\"看到这里我们就明白了，对于简单的遍历，使用传统的Iterator遍历的效率是要比流的方式效率要高的，当然这是因为我们是没有任何的中间操作，如果有了一系列的中间操作，那么使用流的方式效率还是比传统的方式要高的。\",\"list.stream().map(item -> item).forEach(System.out::println); \",\"在ReferencePipeline当中，map方法只有唯一的实现：\",\" public final <R> Stream<R> map(Function<? super P_OUT, ? extends R> mapper) { Objects.requireNonNull(mapper); // 返回StatelessOp的匿名内部类对象，this表示ReferencePipeline，第二个参数表示流的类型是引用类型的，第三个是流的特性值 return new StatelessOp<P_OUT, R>(this, StreamShape.REFERENCE, StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) { @Override Sink<P_OUT> opWrapSink(int flags, Sink<R> sink) { return new Sink.ChainedReference<P_OUT, R>(sink) { // 真正执行传入Lambda表达式的地方 @Override public void accept(P_OUT u) { downstream.accept(mapper.apply(u)); } }; } }; } \",\"这里的StatelessOp也是定义在ReferencePipeline当中的一个静态内部类：\",\" abstract static class StatelessOp<E_IN, E_OUT> extends ReferencePipeline<E_IN, E_OUT> { StatelessOp(AbstractPipeline<?, E_IN, ?> upstream, StreamShape inputShape, int opFlags) { super(upstream, opFlags); assert upstream.getOutputShape() == inputShape; } @Override final boolean opIsStateful() { return false; } } \",\"相关说明：\",\"Construct a new Stream by appending a stateless intermediate operation to an existing stream. \",\"构造一个针对无状态的中间的阶段的流，这里的构造方法又调用了ReferencePipeline的构造方法：\",\" ReferencePipeline(AbstractPipeline<?, P_IN, ?> upstream, int opFlags) { super(upstream, opFlags); } \",\"方法的说明：\",\"Constructor for appending an intermediate operation onto an existing pipeline. \",\"这个构造方法完成的就是对于已经存在的管道追加一个中间操作，upstream表示上游元素的源。\",\"这里又调用了AbstractPipeline的构造方法：\",\"AbstractPipeline(AbstractPipeline<?, E_IN, ?> previousStage, int opFlags) { if (previousStage.linkedOrConsumed) throw new IllegalStateException(MSG_STREAM_LINKED); // 标识为已经消费 previousStage.linkedOrConsumed = true; previousStage.nextStage = this; this.previousStage = previousStage; this.sourceOrOpFlags = opFlags & StreamOpFlag.OP_MASK; this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags); this.sourceStage = previousStage.sourceStage; if (opIsStateful()) sourceStage.sourceAnyStateful = true; // 深度加1 this.depth = previousStage.depth + 1; } \",\"方法的说明：\",\"Constructor for appending an intermediate operation stage onto an existing pipeline. \",\"向一个已有的管道用于追加一个中间操作。\",\"这里也可以看到这个构造方法与我们之前见过的有关构造流源的构造方法的作用完全不同，回到刚才的例子当中，除了上面追加中间操作的部分，还涉及到了另外一个及其重要的类Sink，一般翻译为饮水槽，这是我们了解整个流调用机制的最后一个类。\"]},\"1623\":{\"h\":\"Sink源码分析\",\"t\":[\"An extension of Consumer used to conduct values through the stages of a stream pipeline, with additional methods to manage size information, control flow, etc. Before calling the accept() method on a Sink for the first time, you must first call the begin() method to inform it that data is coming (optionally informing the sink how much data is coming), and after all data has been sent, you must call the end() method. After calling end(), you should not call accept() without again calling begin(). Sink also offers a mechanism by which the sink can cooperatively signal that it does not wish to receive any more data (the cancellationRequested() method), which a source can poll before sending more data to the Sink. \",\"Sink是Consumer接口的一个扩展，用于在整个流管道阶段处理值，还提供了一些额外的信息，比如管理大小的信息，控制流程，等等。在首次调用Sink的accept之前必须先调用begin方法来通知数据即将到达，同时你也可以通知Sink需要处理的数据量是多少，在所有的数据发送完成之后，必须调用end方法，在调用完end方法，你就不应该再去调用accept方法，如果还想调用，就需要再调用一次begin方法，Sink本身可以通过cancellationRequested方法来发出不要再接收数据的信号，那么源在发送数据之前就可以根据判断是否要向Sink发送数据。\",\"A sink may be in one of two states: an initial state and an active state. It starts out in the initial state; the begin() method transitions it to the active state, and the end() method transitions it back into the initial state, where it can be re-used. Data-accepting methods (such as accept() are only valid in the active state. \",\"一个Sink一定是处于两种状态之一的，一种是初始状态，另一种是激活状态，首先它是从初始状态开始的，使用begin方法可以将它从初始状态转换成激活状态，使用end方法可以将它从激活状态转换成初始状态，这样调用完之后就可以重用了，对于Sink来说，只有在激活状态下才可以接收数据。\",\"A stream pipeline consists of a source, zero or more intermediate stages (such as filtering or mapping), and a terminal stage, such as reduction or for-each. For concreteness, consider the pipeline: \",\"一个流管道包含了0个或多个中间阶段（比如过滤、映射），还有一个终止阶段，比如汇聚等等，具体考虑下面这个pipeline：\",\"int longestStringLengthStartingWithA = strings.stream() .filter(s -> s.startsWith(\\\"A\\\")) .mapToInt(String::length) .max(); \",\"继续往下：\",\"Here, we have three stages, filtering, mapping, and reducing. The filtering stage consumes strings and emits a subset of those strings; the mapping stage consumes strings and emits ints; the reduction stage consumes those ints and computes the maximal value. \",\"这里对我们而言有三个阶段，过滤，映射，汇聚，过滤阶段会消耗字符串集合，会输出字符串的子集，映射阶段会消耗字符串集合，映射成整型值，汇聚阶段会消耗这个整型值并求出最大值。\",\"A Sink instance is used to represent each stage of this pipeline, whether the stage accepts objects, ints, longs, or doubles. Sink has entry points for accept(Object), accept(int), etc, so that we do not need a specialized interface for each primitive specialization. (It might be called a \\\"kitchen sink\\\" for this omnivorous tendency.) The entry point to the pipeline is the Sink for the filtering stage, which sends some elements \\\"downstream\\\" -- into the Sink for the mapping stage, which in turn sends integral values downstream into the Sink for the reduction stage. The Sink implementations associated with a given stage is expected to know the data type for the next stage, and call the correct accept method on its downstream Sink. Similarly, each stage must implement the correct accept method corresponding to the data type it accepts. \",\"Sink实例是用来表示管道的每一个阶段，而无论这个阶段接收的类型，比如 ints, longs, or doubles，Sink对于accept有一个入口点，这样我们就不需要针对于原生类型的特化版本，上面的例子当中，就是一个过滤阶段，Sink会将值映射成整型值向下游发送，最后进行汇聚操作。\",\"Sink中的方法说明：\",\" default void begin(long size) {} \",\"方法的说明：\",\"Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling end(), you may call this method to reset the sink for another calculation. \",\"会重新设置Sink的状态并且刷新数据集，向Sink发送任何数据之前一定要调用这个方法，调用完end方法之后，可以再次调用这个方法来重置Sink来进行其他的计算。\",\" static abstract class ChainedReference<T, E_OUT> implements Sink<T> { // 表示下游的操作 protected final Sink<? super E_OUT> downstream; // 会保存下游的对象 public ChainedReference(Sink<? super E_OUT> downstream) { this.downstream = Objects.requireNonNull(downstream); } @Override public void begin(long size) { downstream.begin(size); } @Override public void end() { downstream.end(); } @Override public boolean cancellationRequested() { return downstream.cancellationRequested(); } } \",\"类的说明：\",\"Abstract Sink implementation for creating chains of sinks. The begin, end, and cancellationRequested methods are wired to chain to the downstream Sink. This implementation takes a downstream Sink of unknown input shape and produces a Sink<T>. The implementation of the accept() method must call the correct accept() method on the downstream Sink. \",\"它是Sink的一个抽象实现，用于创建Sink的一个链，begin, end, 和cancellationRequested方法都会链接起来，这个实现会接收下游的Sink。\",\" abstract Sink<E_IN> opWrapSink(int flags, Sink<E_OUT> sink); \",\"Accepts a Sink which will receive the results of this operation, and return a Sink which accepts elements of the input type of this operation and which performs the operation, passing the results to the provided Sink. \",\"它会接收一个Sink作为当前操作的结果(E_OUT)，并且返回一个Sink，返回的Sink（E_IN）会接收这个操作的所对应的输入元素的类型并且执行这个操作，然后将结果传递给所提供的Sink。\",\"a sink which accepts elements, perform the operation upon each element, and passes the results (if any) to the provided Sink. \",\"返回的Sink会接收一个元素，并且对每个元素进行操作，最后将执行的结果（如果有的话）传递给提供的Sink。\",\"正是因为将执行的结果传递给了方法参数的Sink，才将一系列的Sink有机的串联了起来。\",\"The implementation may use the flags parameter to optimize the sink wrapping. For example, if the input is already DISTINCT, the implementation for the Stream#distinct() method could just return the sink it was passed. \",\"可以使用flags来优化sink，例如，如果输入一定是不同，那么实现的时候，stream.distinct()方法就可以不用再去执行。\",\"总的来说在进行中间操作的时候，StatelessOp继承了ReferencePipeline，而ReferencePipeline又实现了Stream接口，通过StatelessOp创建饮水槽，将中间操作串联起来。\",\"public static <T> TerminalOp<T, Void> makeRef(Consumer<? super T> action, boolean ordered) { Objects.requireNonNull(action); return new ForEachOp.OfRef<>(action, ordered);} \",\"actory for creating instances of TerminalOp that perform an action for every element of a stream. Supported variants include unordered traversal (elements are provided to the Consumer as soon as they are available), and ordered traversal (elements are provided to the Consumer in encounter order.) \",\"这是一个工厂，用来创建终止操作的实例，终止操作会对流中的每个元素执行action，支持的变化包括无序的遍历（只要还有元素，就将元素提供给Consumer）还有一种有序的遍历（按照元素输入的顺序提供给Consumer）\",\"Elements are provided to the Consumer on whatever thread and whatever order they become available. For ordered traversals, it is guaranteed that processing an element happens-before processing subsequent elements in the encounter order. \",\"在可用的任意的顺序，任意线程都会将元素提供给Consumer ，对于有序的遍历而言，会保证处理一个元素一定是happens-before（某一件事情一定是发生在另外一件事情之前）处理后续的元素之前，即先遇到的先遍历。\",\"makeRef方法的说明：\",\"Constructs a TerminalOp that perform an action for every element of a stream. \",\"构造了一个终止操作，并且对流中的每个元素都执行给定的动作。\",\"interface TerminalOp<E_IN, R> { // 默认是引用类型 default StreamShape inputShape() { return StreamShape.REFERENCE; } default int getOpFlags() { return 0; } // 并行的方式 default <P_IN> R evaluateParallel(PipelineHelper<E_IN> helper, Spliterator<P_IN> spliterator) { if (Tripwire.ENABLED) Tripwire.trip(getClass(), \\\"{0} triggering TerminalOp.evaluateParallel serial default\\\"); return evaluateSequential(helper, spliterator); } // 串行的方式 <P_IN> R evaluateSequential(PipelineHelper<E_IN> helper, Spliterator<P_IN> spliterator); } \",\"类的说明：\",\"An operation in a stream pipeline that takes a stream as input and produces a result or side-effect. A TerminalOp has an input type and stream shape, and a result type. A TerminalOp also has a set of operation flags that describes how the operation processes elements of the stream (such as short-circuiting or respecting encounter order; see StreamOpFlag). \",\"这是流管道中的一个操作，它会接收一个流作为输入，生成一个结果或者拥有副作用（修改传入参数的引用），一个终止操作会拥有一个输入类型和一个流的类型（引用、整型、长整型等）和一个结果类型，一个终止操作描述了描述了流是如何处理流中元素的（比如短路、有序的执行）。\",\"A TerminalOp must provide a sequential and parallel implementation of the operation relative to a given stream source and set of intermediate operations. \",\"终止操作对于给定的流源和中间操作一定要提供并行和串行的实现。\",\"实际上，终止操作的数量并不是特别多。\",\"A TerminalOp that evaluates a stream pipeline and sends the output to itself as a TerminalSink. Elements will be sent in whatever thread they become available. If the traversal is unordered, they will be sent independent of the stream's encounter order. \",\"这是一个终止操作，它会计算一个流福安到并且将结果发送给自身作为一个TerminalSink，元素如果可用的话会发送给任意一个线程，如果遍历是无序的，那么在遍历的时候就会独立于流中输入的顺序。\",\"This terminal operation is stateless. For parallel evaluation, each leaf instance of a ForEachTask will send elements to the same TerminalSink reference that is an instance of this class. \",\"这个终止操作是无状态的，对于并行计算，每一个叶子节点都会发送个这个类的同一个TerminalSink实例。\",\"Evaluate the pipeline with a terminal operation to produce a result. \",\"执行一个终止的操作，并且返回一个结果。\",\" final <R> R evaluate(TerminalOp<E_OUT, R> terminalOp) { assert getOutputShape() == terminalOp.inputShape(); if (linkedOrConsumed) throw new IllegalStateException(MSG_STREAM_LINKED); linkedOrConsumed = true; return isParallel() ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags())) : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags())); } \",\"串行的实现：\",\" @Override public <S> Void evaluateSequential(PipelineHelper<T> helper, Spliterator<S> spliterator) { return helper.wrapAndCopyInto(this, spliterator).get(); } \",\"Helper class for executing stream pipelines, capturing all of the information about a stream pipeline (output shape, intermediate operations, stream flags, parallelism, etc) in one place. \",\"这是一个执行流管道的辅助类，它会在一个地方捕获关于流管道的所有信息（输出种类，中间操作，特性值，并行或者串行）。\",\"A PipelineHelper describes the initial segment of a stream pipeline, including its source, intermediate operations, and may additionally incorporate information about the terminal (or stateful) operation which follows the last intermediate operation described by this PipelineHelper. The PipelineHelper is passed to the TerminalOp. evaluateParallel(PipelineHelper, Spliterator), TerminalOp.evaluateSequential(PipelineHelper, Spliterator), and AbstractPipeline.opEvaluateParallel(PipelineHelper, Spliterator, IntFunction), methods, which can use the PipelineHelper to access information about the pipeline such as head shape, stream flags, and size, and use the helper methods such as wrapAndCopyInto(Sink, Spliterator), copyInto(Sink, Spliterator), and wrapSink(Sink) to execute pipeline operations. \",\"PipelineHelper描述了一个流管道最开始的阶段，包括它的源，中间操作，以及一些附加的信息关于终止的有状态的操作。\",\"abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT, S>> extends PipelineHelper<E_OUT> implements BaseStream<E_OUT, S> \",\" @Override public <S> Void evaluateParallel(PipelineHelper<T> helper, Spliterator<S> spliterator) { if (ordered) new ForEachOrderedTask<>(helper, spliterator, this).invoke(); else new ForEachTask<>(helper, spliterator, helper.wrapSink(this)).invoke(); return null; } \",\" abstract<P_IN, S extends Sink<P_OUT>> S wrapAndCopyInto(S sink, Spliterator<P_IN> spliterator); \",\"方法的说明：\",\"Applies the pipeline stages described by this PipelineHelper to the provided Spliterator and send the results to the provided Sink. \",\"将PipelineHelper所描述的管道阶段应用到所提供的Spliterator同时把结果发送给提供的Sink。\",\"这个方法在AbstractPipeline中有唯一的实现：\",\" @Override final <P_IN, S extends Sink<E_OUT>> S wrapAndCopyInto(S sink, Spliterator<P_IN> spliterator) { copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator); return sink; } \",\"这里的wrapSink方法如下：\",\" abstract<P_IN> Sink<P_IN> wrapSink(Sink<P_OUT> sink); \",\"方法的说明：\",\"Takes a Sink that accepts elements of the output type of the PipelineHelper, and wrap it with a Sink that accepts elements of the input type and implements all the intermediate operations described by this PipelineHelper, delivering the result into the provided Sink. \",\"它会接收PipelineHelper输出类型的元素，使用Sink对于接收到的所有的元素进行包装成由PipelineHelper所描述的中间操作，并且将结果传递给提供的Sink。\",\"这个方法就是对流中的中间操作进行串联的方法，具体的实现如下：\",\" @Override @SuppressWarnings(\\\"unchecked\\\") final <P_IN> Sink<P_IN> wrapSink(Sink<E_OUT> sink) { Objects.requireNonNull(sink); // 深度大于0说明有中间操作。 for ( @SuppressWarnings(\\\"rawtypes\\\") AbstractPipeline p=AbstractPipeline.this; p.depth > 0; p=p.previousStage) { // opWrapSink是map等方法中实现的 sink = p.opWrapSink(p.previousStage.combinedFlags, sink); } return (Sink<P_IN>) sink; } \",\" abstract<P_IN> void copyInto(Sink<P_IN> wrappedSink, Spliterator<P_IN> spliterator); \",\"方法的说明：\",\"Pushes elements obtained from the Spliterator into the provided Sink. If the stream pipeline is known to have short-circuiting stages in it (see StreamOpFlag.SHORT_CIRCUIT), the Sink.cancellationRequested() is checked after each element, stopping if cancellation is requested. \",\"将从Spliterator获取到元素推送到Sink当中，如果这个流管道已经知道了拥有短路的阶段，就会进入短路逻辑的判断，方法的实现如下：\",\" @Override final <P_IN> void copyInto(Sink<P_IN> wrappedSink, Spliterator<P_IN> spliterator) { Objects.requireNonNull(wrappedSink); if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) { wrappedSink.begin(spliterator.getExactSizeIfKnown()); spliterator.forEachRemaining(wrappedSink); wrappedSink.end(); } else { copyIntoWithCancel(wrappedSink, spliterator); } } \",\"TerminalSink是Sink最终的形态。\"]},\"1624\":{\"h\":\"Stream调用流程\",\"t\":[\"BaseStream->Stream->AbstractPipline->ReferencePipline->(Head（流源）、StatelessOp（无状态的中间操作）、StatefulOp（有状态的中间操作））\",\"Terminalop->(FindOp、ForeachOp、MatchOp、ReduceOp)\"]},\"1625\":{\"h\":\"JMS 简介\"},\"1626\":{\"h\":\"JMX\",\"t\":[\"https://www.wdbyte.com/java/jmx/\"]},\"1627\":{\"h\":\"JNDI 简介\",\"t\":[\"官方文档：https://docs.oracle.com/javase/jndi/tutorial/TOC.html\"]},\"1628\":{\"h\":\"框架源码分析\"},\"1629\":{\"h\":\"Spring源码分析\"},\"1630\":{\"h\":\"Spring核心原理概览\",\"t\":[\"Spring Framework的核心知识点：\",\"Bean的生命周期底层原理\",\"依赖注入底层实现原理\",\"初始化底层原理\",\"推断构造方法底层原理\",\"AOP底层原理\",\"Spring事务底层原理\",\"推断构造方法：先根据类型进行依赖查找，如果找到多个，那么再根据名称查找，直到找到唯一的Bean，如果要指定构造方法，需要添加@Autowried注解来实现。\",\"AOP大致的实现原理：先使用cglib生成代理类，将代理对象的target属性赋值为IOC容器中的普通对象（普通对象是依赖注入的后的对象），然后再执行切面的逻辑，最后调用普通对象的方法。\",\"如何判断当前Bean对象需不需要进行AOP：\",\"找出所有的切面Bean\",\"遍历切面中的每个方法，查看是否有@Before、@After等注解\",\"如果有，则判断对应的Pointcut是否和当前Bean对象的类是否匹配\",\"如果匹配则表示当前Bean对象有匹配的Pointcut，表示需要进行AOP，会将AOP需要执行的方法缓存\",\"Spring 自动事务的大致实现过程：\",\"判读方法是否含有@Transactional注解\",\"通过事务管理器（dataSource）创建一个数据库连接\",\"设置conn.autocommit=false\",\"执行目标方法，提交事务结果\",\"解决事务失效的核心思路：只要是调用代理对象的方法，事务就可以生效。\"]},\"1631\":{\"h\":\"Spring核心概念\"},\"1632\":{\"h\":\"BeanDefinition\",\"t\":[\"BeanDefinition表示Bean的元信息定义，BeanDefition中存在很多属性用来描述一个Bean的特点。比如：\",\"class，表示Bean的类型\",\"scope，表示Bean的作用域（单例或圆形）\",\"lazyInit：表示Bean是否是懒加载\",\"initMethodName：表示Bean初始化时要执行的方法\",\"destoreMethodName：表示Bean销毁时要执行的方法\",\"......\",\"通过XML方式配置和使用注解等方式声明的Bean，都会被Spring解析为对应的BeanDefinition对象，并放入Spring容器中。\",\"通过编程式声明Bean对象：\",\"AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); // 生成一个BeanDefinition对象，并设置beanClass为User.class，并注册到ApplicationContext中 AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition(); beanDefinition.setBeanClass(User.class); context.registerBeanDefinition(\\\"user\\\", beanDefinition); System.out.println(context.getBean(\\\"user\\\")); \",\"BeanDefinition的典型实现：\",\"org.springframework.beans.factory.support.GenericBeanDefinition\",\"org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition\",\"org.springframework.context.annotation.ScannedGenericBeanDefinition\",\"org.springframework.beans.factory.support.RootBeanDefinition\",\"org.springframework.beans.factory.support.ChildBeanDefinition\"]},\"1633\":{\"h\":\"AnnotatedBeanDefinitionReader\",\"t\":[\"AnnotatedBeanDefinitionReader可以直接把某个类转换为BeanDefition，并且会解析该类上的注解，比如：\",\"AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); AnnotatedBeanDefinitionReader annotatedBeanDefinitionReader = new AnnotatedBeanDefinitionReader(context); // 将User.class解析为BeanDefinition annotatedBeanDefinitionReader.register(User.class); System.out.println(context.getBean(\\\"user\\\")); \",\"注意，它能解析的注解有：@Conditional、@Scope、@Lazy、@Primary、@DependsOn、@Role、@Description\"]},\"1634\":{\"h\":\"XmlBeanDefinitionReader\",\"t\":[\"XmlBeanDefinitionReader可以用来解析\",\"AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(context); int i = xmlBeanDefinitionReader.loadBeanDefinitions(\\\"spring.xml\\\"); System.out.println(context.getBean(\\\"user\\\")); \"]},\"1635\":{\"h\":\"ClassPathBeanDefinitionScanner\",\"t\":[\"ClassPathBeanDefinitionScanner是扫描器，作用和BeanDefinitionReader类似，它可以扫描某个包路径，对扫描到的类进行解析，比如，扫描到的类上如果存在@Component注解，那么就会把这个类解析为一个BeanDefition，比如：\",\"AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.refresh(); ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(context); scanner.scan(\\\"com.jyc\\\"); System.out.println(context.getBean(\\\"userService\\\")); \"]},\"1636\":{\"h\":\"BeanFactory\",\"t\":[\"BeanFactory表示Bean工厂，BeanFactory会负责创建Bean，并且提供获取Bean的API。\",\"ApplicationContext继承了BeanFactory，ApplicationContext除了BeanFactory提供的基础功能外，还提供了国际化、事件发布、获取环境变量等功能。\",\"BeanFactory的类图如下：\",\"其中DefaultListableBeanFactory是最重要的实现之一。其余接口的主要功能如下：\",\"AliasRegistry：支持别名功能，一个名字可以对应多个别名\",\"BeanDefinitionRegistry：可以注册、保存、移除、获取某个BeanDefinition\",\"BeanFactory：Bean工厂，可以根据某个bean的名字、或类型、或别名获取某个Bean对象\",\"SingletonBeanRegistry：可以直接注册、获取某个单例Bean\",\"SimpleAliasRegistry：它是一个类，实现了AliasRegistry接口中所定义的功能，支持别名功能\",\"ListableBeanFactory：在BeanFactory的基础上，增加了其他功能，可以获取所有BeanDefinition的beanNames，可以根据某个类型获取对应的beanNames，可以根据某个类型获取{类型：对应的Bean}的映射关系\",\"HierarchicalBeanFactory：在BeanFactory的基础上，添加了获取父BeanFactory的功能\",\"DefaultSingletonBeanRegistry：它是一个类，实现了SingletonBeanRegistry接口，拥有了直接注册、获取某个单例Bean的功能\",\"ConfigurableBeanFactory：在HierarchicalBeanFactory和SingletonBeanRegistry的基础上，添加了设置父BeanFactory、类加载器（表示可以指定某个类加载器进行类的加载）、设置Spring EL表达式解析器（表示该BeanFactory可以解析EL表达式）、设置类型转化服务（表示该BeanFactory可以进行类型转化）、可以添加BeanPostProcessor（表示该BeanFactory支持Bean的后置处理器），可以合并BeanDefinition，可以销毁某个Bean等等功能\",\"FactoryBeanRegistrySupport：支持了FactoryBean的功能\",\"AutowireCapableBeanFactory：是直接继承了BeanFactory，在BeanFactory的基础上，支持在创建Bean的过程中能对Bean进行自动装配\",\"AbstractBeanFactory：实现了ConfigurableBeanFactory接口，继承了FactoryBeanRegistrySupport，这个BeanFactory的功能已经很全面了，但是不能自动装配和获取beanNames\",\"ConfigurableListableBeanFactory：继承了ListableBeanFactory、AutowireCapableBeanFactory、ConfigurableBeanFactory\",\"AbstractAutowireCapableBeanFactory：继承了AbstractBeanFactory，实现了AutowireCapableBeanFactory，拥有了自动装配的功能\",\"DefaultListableBeanFactory：继承了AbstractAutowireCapableBeanFactory，实现了ConfigurableListableBeanFactory接口和BeanDefinitionRegistry接口，所以DefaultListableBeanFactory的功能很强大\"]},\"1637\":{\"h\":\"ApplicationContext\",\"t\":[\"ApplicationContext提供了如下功能：\",\"HierachicalBeanFactory：拥有获取父BeanFactory的功能\",\"ListableBeanFactory：拥有获取beanNames的功能\",\"ResourcePatternResolver：资源加载器，可以一次性获取多个资源（文件资源等等）\",\"EnvironmentCapable：可以获取运行时环境（没有设置运行时环境的功能）\",\"ApplicationEventPublisher：拥有广播事件的功能（没有添加事件监听器的功能）\",\"MessageSource：拥有国际化功能\",\"ApplicationContext的典型实现：\",\"org.springframework.context.annotation.AnnotationConfigApplicationContext\",\"org.springframework.context.support.ClassPathXmlApplicationContext\"]},\"1638\":{\"h\":\"PropertyEditor\",\"t\":[\"PropertyEditor是JDK中提供的类型转化工具类。\",\"通常我们会定义一个类型转换器：\",\"// 继承PropertyEditorSupport public class StringToUserPropertyEditor extends PropertyEditorSupport { @Override public void setAsText(String text) throws IllegalArgumentException { User user = new User(); user.setName(text); this.setValue(user); } } \",\"向Spring中注册PropertyEditor：\",\"@Bean public CustomEditorConfigurer customEditorConfigurer() { CustomEditorConfigurer customEditorConfigurer = new CustomEditorConfigurer(); Map<Class<?>, Class<? extends PropertyEditor>> propertyEditorMap = new HashMap<>(); // 表示StringToUserPropertyEditor可以将String转化成User类型，在Spring源码中，如果发现当前对象是String，而需要的类型是User，就会使用该PropertyEditor来做类型转化 propertyEditorMap.put(User.class, StringToUserPropertyEditor.class); customEditorConfigurer.setCustomEditors(propertyEditorMap); return customEditorConfigurer; } \",\"假设有如下Bean：\",\"@Component public class UserService { @Value(\\\"xxx\\\") private User user; public void test() { System.out.println(user); } } \",\"那么user这个属性就会按照StringToUserPropertyEditor中定义好的规则来进行属性赋值。\"]},\"1639\":{\"h\":\"ConversionService\",\"t\":[\"ConversionService是Spring中提供的类型转化服务，它比PropertyEditor更加强大。与PropertyEditor类似，首先定义一个转换器。\",\" public class StringToUserConverter implements ConditionalGenericConverter { @Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return sourceType.getType().equals(String.class) && targetType.getType().equals(User.class); } @Override public Set<ConvertiblePair> getConvertibleTypes() { return Collections.singleton(new ConvertiblePair(String.class, User.class)); } @Override public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { User user = new User(); user.setName((String)source); return user; } } \",\"与PropertyEditor相比，conversionService可以自定义转换类型，PropertyEditor仅仅支持String类型转换成其他的类型。\",\"向Spring中注册conversionService：\",\"@Bean public ConversionServiceFactoryBean conversionService() { ConversionServiceFactoryBean conversionServiceFactoryBean = new ConversionServiceFactoryBean(); conversionServiceFactoryBean.setConverters(Collections.singleton(new StringToUserConverter())); return conversionServiceFactoryBean; } \"]},\"1640\":{\"h\":\"TypeConverter\",\"t\":[\"TypeConverter整合了PropertyEditor和conversionService的功能，在Spring内部使用：\",\"SimpleTypeConverter typeConverter = new SimpleTypeConverter(); typeConverter.registerCustomEditor(User.class, new StringToUserPropertyEditor()); User value = typeConverter.convertIfNecessary(\\\"1\\\", User.class); System.out.println(value); \",\"typeConverter本身使用了委托的设计模式，其类型转换的功能实际上委托给了内部的propertyEditor和conversionService对象，这样做的好处是使用者无需关心内部转换细节。\"]},\"1641\":{\"h\":\"OrderComparator\",\"t\":[\"OrderComparator是Spring所提供的一种比较器，可以根据@Order注解或实现Ordered接口来执行值进行比较，从而可以进行排序。\",\"另外，Spring中还提供了OrderComparator的子类：AnnotationAwareOrderComparator，它支持使用注解@Order来指定order的值。\"]},\"1642\":{\"h\":\"BeanPostProcessor\"},\"1643\":{\"h\":\"BeanFactoryPostProcessor\"},\"1644\":{\"h\":\"FactoryBean\",\"t\":[\"除了可以通过BeanPostProcessor来自定义Spring创建Bean的过程，但是如果我们想要一个Bean完全由我们自己来创造，就可以通过FactoryBean来实现：\",\"@Component public class JycFactoryBean implements FactoryBean { @Override public Object getObject() throws Exception { UserService userService = new UserService(); return userService; } @Override public Class<?> getObjectType() { return UserService.class; } } \",\"在大多数场景下可以与@Bean替换使用，唯一的区别在于，这样产生的Bean不会经过Spring的生命周期步骤，只会进入初始化后的阶段，以便AOP操作。\"]},\"1645\":{\"h\":\"ExcludeFilter和IncludeFilter\",\"t\":[\"这两个Filter是Spring扫描过程中用来过滤的。ExcludeFilter表示排除过滤器，IncludeFilter表示包含过滤器。\",\"在如下配置中，表示扫描com.jyc这个包下面所有的类，但是排除UserService类，即便它上面有@Component注解也不会注册为Bean。\",\"@ComponentScan(value = \\\"com.jyc\\\", excludeFilters = {@ComponentScan.Filter( type = FilterType.ASSIGNABLE_TYPE, classes = UserService.class)}.) public class AppConfig { } \",\"在如下配置中，即便Uservice类上没有@Component注解，它也会扫描成为一个Bean。\",\"@ComponentScan(value = \\\"com.jyc\\\", includeFilters = {@ComponentScan.Filter( type = FilterType.ASSIGNABLE_TYPE, classes = UserService.class)}) public class AppConfig { } \",\"在Spring的扫描逻辑中，默认会添加一个AnnotationTypeFilter给includeFilters，表示默认情况下Spring扫描过程中会认为类上有@Component注解的就是Bean。\"]},\"1646\":{\"h\":\"MetadataReader、ClassMetadata、AnnotationMetadata\",\"t\":[\"在Spring中需要去解析类的信息，比如类名，类中的方法、类上的注解，这些都可以称之为类的元数据，所以Spring中对类的元数据做了抽象，并提供了一些工具类。\",\"MetadataReader表示类的元数据读取器，默认实现类为SimpleMetadataReader。比如：\",\"public class Test { public static void main(String[] args) throws IOException { SimpleMetadataReaderFactory simpleMetadataReaderFactory = new SimpleMetadataReaderFactory(); // 构造一个MetadataReader MetadataReader metadataReader = simpleMetadataReaderFactory.getMetadataReader(\\\"com.jyc.service.UserService\\\"); // 得到一个ClassMetadata，并获取了类名 ClassMetadata classMetadata = metadataReader.getClassMetadata(); System.out.println(classMetadata.getClassName()); // 获取一个AnnotationMetadata，并获取类上的注解信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); for (String annotationType : annotationMetadata.getAnnotationTypes()) { System.out.println(annotationType); } } } \",\"需要注意的是，SimpleMetadataReader去解析类时，使用的是ASM技术。使用ASM技术的原因是，Spring启动的时候需要去扫描，如果指定的包路径比较宽泛，那么扫描的类是非常多的，这样会把这些类全部加载进JVM。\"]},\"1647\":{\"h\":\"Bean的生命周期\",\"t\":[\"生命周期的整体流程：\",\"过程描述如下：\",\"InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation\",\"实例化\",\"MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition\",\"InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation\",\"属性赋值（Spring自带的依赖注入）\",\"InstantiationAwareBeanPostProcessor#postProcessProperties\",\"初始化前\",\"初始化\",\"初始化后\",\" public AnnotationConfigApplicationContext() { // JFR 特性，用来记录时间 StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start(\\\"spring.context.annotated-bean-reader.create\\\"); // 构造一个reader和scanner this.reader = new AnnotatedBeanDefinitionReader(this); createAnnotatedBeanDefReader.end(); this.scanner = new ClassPathBeanDefinitionScanner(this); } \",\" public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { StartupStep contextRefresh = this.applicationStartup.start(\\\"spring.context.refresh\\\"); // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); StartupStep beanPostProcess = this.applicationStartup.start(\\\"spring.context.beans.post-process\\\"); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); beanPostProcess.end(); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\\\"Exception encountered during context initialization - \\\" + \\\"cancelling refresh attempt: \\\" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); contextRefresh.end(); } } } \",\"扫描的整体过程：\",\" protected Set<BeanDefinitionHolder> doScan(String... basePackages) { Assert.notEmpty(basePackages, \\\"At least one base package must be specified\\\"); Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>(); for (String basePackage : basePackages) { Set<BeanDefinition> candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) { ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } // 为BeanDefinition设置属性的初始值，当命名出现重复，如果不是扫描出现的情况，就会直接抛出异常，否则，则会判断新扫描的BeanDefinition与原来的BeanDefinition是否兼容 if (candidate instanceof AnnotatedBeanDefinition) { AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); } // 检查Spring容器中是否已经含有这个名字的Bean if (checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // 将BeanDefinition注册到beanDefinitionMap中 registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } \",\"扫描的核心方法：\",\" private Set<BeanDefinition> scanCandidateComponents(String basePackage) { Set<BeanDefinition> candidates = new LinkedHashSet<>(); try { String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; // 获取给定包路径下面的Class文件的Resource对象 Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); for (Resource resource : resources) { try { // 元数据读取器，使用ASM技术读取当前类的名称、注解等信息 MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); // 是否是一个Bean if (isCandidateComponent(metadataReader)) { // 扫描的时候并不会解析，此时只会将Bean的名称设置给beanClass属性，后续真正加载的时候会被替换为Class对象，因此beanClass是Object类型的属性 ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setSource(resource); // 有可能是内部类或其他虽然有@Component注解，但不是一个Bean的情况 if (isCandidateComponent(sbd)) { candidates.add(sbd); } } } catch (FileNotFoundException ignored) { } catch (Throwable ex) { throw new BeanDefinitionStoreException( \\\"Failed to read candidate component class: \\\" + resource, ex); } } } catch (IOException ex) { throw new BeanDefinitionStoreException(\\\"I/O failure during classpath scanning\\\", ex); } return candidates; } \",\"其中isCandidateComponent方法表示当前类是否是一个Bean：\",\" protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException { // 处理排除过滤器和包含过滤器，默认会有一个@Component注解的包含过滤器 for (TypeFilter tf : this.excludeFilters) { if (tf.match(metadataReader, getMetadataReaderFactory())) { return false; } } for (TypeFilter tf : this.includeFilters) { if (tf.match(metadataReader, getMetadataReaderFactory())) { // 条件匹配，条件注解@Condition return isConditionMatch(metadataReader); } } return false; } \",\"判断BeanDefinition是否是一个Bean：\",\" protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) { AnnotationMetadata metadata = beanDefinition.getMetadata(); // 1.不是内部类或static类 // 2.不是接口或抽象类 // 3.如果是抽象类的话方法上面需要有@Lookup注解的方法 return (metadata.isIndependent() && (metadata.isConcrete() || (metadata.isAbstract() && metadata.hasAnnotatedMethods(Lookup.class.getName())))); } \",\"创建非懒加载的单例Bean：\",\" @Override public void preInstantiateSingletons() throws BeansException { // 扫描的时候也会把Bean的名字也存下来 List<String> beanNames = new ArrayList<>(this.beanDefinitionNames); for (String beanName : beanNames) { // 合并BeanDefition，将父BeanDefinition的属性继承，合并会生成一个新的BeanDefition，存储在mergedBeanDefinitions这个Map中 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 如果是抽象的BeanDefinition不会创建Bean，abstractFlag是BeanDefinition的内部属性，抽象的BeanDifition表示BeanDifition之间有父子关系 if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) { // FactoryBean的处理逻辑，如果在当前的beanFactory中没有找到，就会递归在父beanFactory中查找 if (isFactoryBean(beanName)) { // 创建实现FactoryBean的实例对象 Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); if (bean instanceof FactoryBean) { FactoryBean<?> factory = (FactoryBean<?>) bean; boolean isEagerInit; if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) { isEagerInit = AccessController.doPrivileged( (PrivilegedAction<Boolean>) ((SmartFactoryBean<?>) factory)::isEagerInit, getAccessControlContext()); } else { isEagerInit = (factory instanceof SmartFactoryBean && ((SmartFactoryBean<?>) factory).isEagerInit()); } if (isEagerInit) { // 调用getBean方法才会调用FactoryBean#getObject方法 getBean(beanName); } } } else { // 创建Bean getBean(beanName); } } } // 在单例池中查找单例Bean，这里会处理循环依赖问题 for (String beanName : beanNames) { Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) { StartupStep smartInitialize = this.getApplicationStartup().start(\\\"spring.beans.smart-initialize\\\") .tag(\\\"beanName\\\", beanName); SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction<Object>) () -> { smartSingleton.afterSingletonsInstantiated(); return null; }, getAccessControlContext()); } else { // 所有的非懒加载的单例Bean都创建完成之后，会调用每个单例Bean的afterSingletonsInstantiated方法 smartSingleton.afterSingletonsInstantiated(); } smartInitialize.end(); } } } \",\"合并BeanDifinition的方法：\",\" protected RootBeanDefinition getMergedBeanDefinition( String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd) throws BeanDefinitionStoreException { synchronized (this.mergedBeanDefinitions) { RootBeanDefinition mbd = null; RootBeanDefinition previous = null; // Check with full lock now in order to enforce the same merged instance. if (containingBd == null) { mbd = this.mergedBeanDefinitions.get(beanName); } if (mbd == null || mbd.stale) { previous = mbd; if (bd.getParentName() == null) { // 如果能在mergedBeanDefinitions找得到父BeanDifinition，直接新建一个RootBeanDefinition if (bd instanceof RootBeanDefinition) { mbd = ((RootBeanDefinition) bd).cloneBeanDefinition(); } else { mbd = new RootBeanDefinition(bd); } } else { // Child bean definition: needs to be merged with parent. BeanDefinition pbd; try { String parentBeanName = transformedBeanName(bd.getParentName()); // 递归查找合并 if (!beanName.equals(parentBeanName)) { pbd = getMergedBeanDefinition(parentBeanName); } else { BeanFactory parent = getParentBeanFactory(); if (parent instanceof ConfigurableBeanFactory) { pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName); } else { throw new NoSuchBeanDefinitionException(parentBeanName, \\\"Parent name '\\\" + parentBeanName + \\\"' is equal to bean name '\\\" + beanName + \\\"': cannot be resolved without a ConfigurableBeanFactory parent\\\"); } } } catch (NoSuchBeanDefinitionException ex) { throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName, \\\"Could not resolve parent bean definition '\\\" + bd.getParentName() + \\\"'\\\", ex); } // 先合并父的BeanDefinition，然后合并子类的BeanDifition mbd = new RootBeanDefinition(pbd); // 属性覆盖，子类中有的属性设置会父类的属性 mbd.overrideFrom(bd); } // Set default singleton scope, if not configured before. if (!StringUtils.hasLength(mbd.getScope())) { mbd.setScope(SCOPE_SINGLETON); } // A bean contained in a non-singleton bean cannot be a singleton itself. // Let's correct this on the fly here, since this might be the result of // parent-child merging for the outer bean, in which case the original inner bean // definition will not have inherited the merged outer bean's singleton status. if (containingBd != null && !containingBd.isSingleton() && mbd.isSingleton()) { mbd.setScope(containingBd.getScope()); } // Cache the merged bean definition for the time being // (it might still get re-merged later on in order to pick up metadata changes) if (containingBd == null && isCacheBeanMetadata()) { this.mergedBeanDefinitions.put(beanName, mbd); } } if (previous != null) { copyRelevantMergedBeanDefinitionCaches(previous, mbd); } return mbd; } } \",\"doGetBean方法是创建Bean的核心方法：\",\" @SuppressWarnings(\\\"unchecked\\\") protected <T> T doGetBean( String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException { // 如果传入的名称是“&***”，表示要获取的对象是FactoryBean本身的对象，它存储在单例池中，如果传入的是普通名称，则表示要获取的对象是Factory#getObject方法返回的对象 String beanName = transformedBeanName(name); Object beanInstance; // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null && args == null) { if (logger.isTraceEnabled()) { if (isSingletonCurrentlyInCreation(beanName)) { logger.trace(\\\"Returning eagerly cached instance of singleton bean '\\\" + beanName + \\\"' that is not fully initialized yet - a consequence of a circular reference\\\"); } else { logger.trace(\\\"Returning cached instance of singleton bean '\\\" + beanName + \\\"'\\\"); } } beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null); } else { // Fail if we're already creating this bean instance: // We're assumably within a circular reference. if (isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null && !containsBeanDefinition(beanName)) { // Not found -> check parent. String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) { return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); } else if (args != null) { // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); } else if (requiredType != null) { // No args -> delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); } else { return (T) parentBeanFactory.getBean(nameToLookup); } } if (!typeCheckOnly) { markBeanAsCreated(beanName); } StartupStep beanCreation = this.applicationStartup.start(\\\"spring.beans.instantiate\\\") .tag(\\\"beanName\\\", name); try { if (requiredType != null) { beanCreation.tag(\\\"beanType\\\", requiredType::toString); } // 拿到合并后的Beanfinition RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 处理@Depensdon注解，查看当前指定的所依赖的Bean是否都已经注入完成 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) { for (String dep : dependsOn) { if (isDependent(beanName, dep)) { // 这也是循环依赖的一种情况 throw new BeanCreationException(mbd.getResourceDescription(), beanName, \\\"Circular depends-on relationship between '\\\" + beanName + \\\"' and '\\\" + dep + \\\"'\\\"); } // 还没有的话，就注册到depentBeanMap中 registerDependentBean(dep, beanName); try { // getBean会首先创建所依赖的Bean getBean(dep); } catch (NoSuchBeanDefinitionException ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \\\"'\\\" + beanName + \\\"' depends on missing bean '\\\" + dep + \\\"'\\\", ex); } } } // Create bean instance. if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -> { try { return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } else if (mbd.isPrototype()) { // It's a prototype -> create a new instance. Object prototypeInstance = null; try { beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } else { // 除了singleton和prototype，还有request、session、application作用域 String scopeName = mbd.getScope(); if (!StringUtils.hasLength(scopeName)) { throw new IllegalStateException(\\\"No scope name defined for bean '\\\" + beanName + \\\"'\\\"); } Scope scope = this.scopes.get(scopeName); if (scope == null) { throw new IllegalStateException(\\\"No Scope registered for scope name '\\\" + scopeName + \\\"'\\\"); } try { Object scopedInstance = scope.get(beanName, () -> { beforePrototypeCreation(beanName); try { return createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } }); beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException ex) { throw new ScopeNotActiveException(beanName, scopeName, ex); } } } catch (BeansException ex) { beanCreation.tag(\\\"exception\\\", ex.getClass().toString()); beanCreation.tag(\\\"message\\\", String.valueOf(ex.getMessage())); cleanupAfterBeanCreationFailure(beanName); throw ex; } finally { beanCreation.end(); } } // 检查通过name查找到的Bean是否是requiredType类型的Bean return adaptBeanInstance(name, beanInstance, requiredType); } } \",\"创建Bean的方法：\",\" @Override protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { RootBeanDefinition mbdToUse = mbd; // Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition. // 类加载，这里可以使用自定义的ClassLoader，默认是APP ClassLoader Class<?> resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) { mbdToUse = new RootBeanDefinition(mbd); // 将加载到的Class对象设置给beanClass属性 mbdToUse.setBeanClass(resolvedClass); } // Prepare method overrides. try { // 与@Lookup注解有关 mbdToUse.prepareMethodOverrides(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, \\\"Validation of method overrides failed\\\", ex); } try { // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. // 实例化前 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) { return bean; } } catch (Throwable ex) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \\\"BeanPostProcessor before instantiation of bean failed\\\", ex); } try { // 实例化 Object beanInstance = doCreateBean(beanName, mbdToUse, args); return beanInstance; } catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) { // A previously detected exception with proper bean creation context already, // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry. throw ex; } catch (Throwable ex) { throw new BeanCreationException( mbdToUse.getResourceDescription(), beanName, \\\"Unexpected exception during bean creation\\\", ex); } } \",\"实例化前方法：\",\" // 支持BeanPostPropcessor protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) { Object bean = null; if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) { // Make sure bean class is actually resolved at this point. if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) { Class<?> targetType = determineTargetType(beanName, mbd); if (targetType != null) { bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); if (bean != null) { bean = applyBeanPostProcessorsAfterInitialization(bean, beanName); } } } mbd.beforeInstantiationResolved = (bean != null); } return bean; } \",\"实例化方法：\",\" protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { instanceWrapper = createBeanInstance(beanName, mbd, args); } Object bean = instanceWrapper.getWrappedInstance(); Class<?> beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { try { applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \\\"Post-processing of merged bean definition failed\\\", ex); } mbd.postProcessed = true; } } // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isTraceEnabled()) { logger.trace(\\\"Eagerly caching bean '\\\" + beanName + \\\"' to allow for resolving potential circular references\\\"); } addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); } // Initialize the bean instance. Object exposedObject = bean; try { // 填充属性 populateBean(beanName, mbd, instanceWrapper); // 初始化 exposedObject = initializeBean(beanName, exposedObject, mbd); } catch (Throwable ex) { if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \\\"Initialization of bean failed\\\", ex); } } if (earlySingletonExposure) { Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { if (exposedObject == bean) { exposedObject = earlySingletonReference; } else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length); for (String dependentBean : dependentBeans) { if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, \\\"Bean with name '\\\" + beanName + \\\"' has been injected into other beans [\\\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \\\"] in its raw version as part of a circular reference, but has eventually been \\\" + \\\"wrapped. This means that said other beans do not use the final version of the \\\" + \\\"bean. This is often the result of over-eager type matching - consider using \\\" + \\\"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.\\\"); } } } } // Register bean as disposable. try { // Bean销毁的逻辑，当Spring容器关闭的时候，会调用销毁方法 registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \\\"Invalid destruction signature\\\", ex); } return exposedObject; } \",\"属性绑定：\",\" protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) { if (bw == null) { if (mbd.hasPropertyValues()) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \\\"Cannot apply property values to null instance\\\"); } else { // Skip property population phase for null instance. return; } } // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the // state of the bean before properties are set. This can be used, for example, // to support styles of field injection. if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) { for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { if (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { return; } } } PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null); int resolvedAutowireMode = mbd.getResolvedAutowireMode(); // Spring内建的依赖注入，可以根据类型或者名称进行查找，但由于过于灵活，现已废弃 if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) { MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // Add property values based on autowire by name if applicable. if (resolvedAutowireMode == AUTOWIRE_BY_NAME) { autowireByName(beanName, mbd, bw, newPvs); } // Add property values based on autowire by type if applicable. if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) { autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE); PropertyDescriptor[] filteredPds = null; if (hasInstAwareBpps) { if (pvs == null) { pvs = mbd.getPropertyValues(); } for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { // 处理属性回调，会检查BeanDefinition的属性是否已经被赋值过了 PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { if (filteredPds == null) { filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { return; } } pvs = pvsToUse; } } if (needsDepCheck) { if (filteredPds == null) { filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } checkDependencies(beanName, mbd, filteredPds, pvs); } if (pvs != null) { applyPropertyValues(beanName, mbd, bw, pvs); } } \",\"销毁方法只是针对于单例的Bean而言，原型Bean的销毁方法并不会被Spring所调用。\"]},\"1648\":{\"h\":\"依赖注入源码解析\",\"t\":[\"@Autowired注解的实现类：org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor：\",\"public class AutowiredAnnotationBeanPostProcessor implements SmartInstantiationAwareBeanPostProcessor, MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware { @Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) { // 查找注入点： InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); } @Override public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) { // 给字段赋值 InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs); try { // 处理@Value注解的方法 metadata.inject(bean, beanName, pvs); } catch (BeanCreationException ex) { throw ex; } catch (Throwable ex) { throw new BeanCreationException(beanName, \\\"Injection of autowired dependencies failed\\\", ex); } return pvs; } } \",\"静态属性和静态方法会跳过，无法依赖注入。\",\" private InjectionMetadata buildAutowiringMetadata(Class<?> clazz) { // 当前类是否 if (!AnnotationUtils.isCandidateClass(clazz, this.autowiredAnnotationTypes)) { return InjectionMetadata.EMPTY; } List<InjectionMetadata.InjectedElement> elements = new ArrayList<>(); Class<?> targetClass = clazz; do { final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>(); ReflectionUtils.doWithLocalFields(targetClass, field -> { MergedAnnotation<?> ann = findAutowiredAnnotation(field); if (ann != null) { // 静态属性跳过 if (Modifier.isStatic(field.getModifiers())) { if (logger.isInfoEnabled()) { logger.info(\\\"Autowired annotation is not supported on static fields: \\\" + field); } return; } boolean required = determineRequiredStatus(ann); currElements.add(new AutowiredFieldElement(field, required)); } }); ReflectionUtils.doWithLocalMethods(targetClass, method -> { // 处理桥接方法，找到被桥接的方法，然后处理 Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) { return; } MergedAnnotation<?> ann = findAutowiredAnnotation(bridgedMethod); if (ann != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) { // 静态方法跳过 if (Modifier.isStatic(method.getModifiers())) { if (logger.isInfoEnabled()) { logger.info(\\\"Autowired annotation is not supported on static methods: \\\" + method); } return; } if (method.getParameterCount() == 0) { if (logger.isInfoEnabled()) { logger.info(\\\"Autowired annotation should only be used on methods with parameters: \\\" + method); } } boolean required = determineRequiredStatus(ann); PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz); currElements.add(new AutowiredMethodElement(method, required, pd)); } }); elements.addAll(0, currElements); targetClass = targetClass.getSuperclass(); } while (targetClass != null && targetClass != Object.class); return InjectionMetadata.forElements(elements, clazz); } \",\"注入字段：\",\" @Nullable private Object resolveFieldValue(Field field, Object bean, @Nullable String beanName) { DependencyDescriptor desc = new DependencyDescriptor(field, this.required); desc.setContainingClass(bean.getClass()); Set<String> autowiredBeanNames = new LinkedHashSet<>(1); Assert.state(beanFactory != null, \\\"No BeanFactory available\\\"); TypeConverter typeConverter = beanFactory.getTypeConverter(); Object value; try { // 找到需要注入的字段的值 value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter); } catch (BeansException ex) { throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex); } synchronized (this) { if (!this.cached) { Object cachedFieldValue = null; if (value != null || this.required) { cachedFieldValue = desc; registerDependentBeans(beanName, autowiredBeanNames); if (autowiredBeanNames.size() == 1) { String autowiredBeanName = autowiredBeanNames.iterator().next(); if (beanFactory.containsBean(autowiredBeanName) && beanFactory.isTypeMatch(autowiredBeanName, field.getType())) { cachedFieldValue = new ShortcutDependencyDescriptor( desc, autowiredBeanName, field.getType()); } } } this.cachedFieldValue = cachedFieldValue; this.cached = true; } } return value; } } \",\"类似的，也有注入方法的方法：org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredMethodElement。\",\"其中核心方法就是beanFactory的resolveDependency方法：\",\" public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName, @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException { // 用来获取方法入参名称 descriptor.initParameterNameDiscovery(getParameterNameDiscoverer()); // 所需要的类型是Optional类型的 if (Optional.class == descriptor.getDependencyType()) { return createOptionalDependency(descriptor, requestingBeanName); } // 所需要的类型是ObectFactory或ObjectProvider的 else if (ObjectFactory.class == descriptor.getDependencyType() || ObjectProvider.class == descriptor.getDependencyType()) { return new DependencyObjectProvider(descriptor, requestingBeanName); } else if (javaxInjectProviderClass == descriptor.getDependencyType()) { return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName); } else { // 在属性或set方法上使用了@Lazy注解，那么则构造一个代理对象并返回，真正使用该代理对象时才进行类型筛选Bean Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary( descriptor, requestingBeanName); if (result == null) { result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter); } return result; } } \",\"方法形参名称获取：\",\"public class DefaultParameterNameDiscoverer extends PrioritizedParameterNameDiscoverer { public DefaultParameterNameDiscoverer() { // JDK1.8以后可以获取方法的形参名称，1.8之前可以通过字节码的本地变量表来获取 addDiscoverer(new StandardReflectionParameterNameDiscoverer()); addDiscoverer(new LocalVariableTableParameterNameDiscoverer()); } } \",\"核心方法doResolveDependency的源代码：\",\" @Nullable public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName, @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException { InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor); try { Object shortcut = descriptor.resolveShortcut(this); if (shortcut != null) { return shortcut; } Class<?> type = descriptor.getDependencyType(); // 处理@Value注解 Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor); if (value != null) { if (value instanceof String) { // 占位符的填充（${}） String strVal = resolveEmbeddedValue((String) value); BeanDefinition bd = (beanName != null && containsBean(beanName) ? getMergedBeanDefinition(beanName) : null); // 解析Spring表达式（#{}，也可以用来以来注入） value = evaluateBeanDefinitionString(strVal, bd); } // 将value转化为descriptor所对应的类型 TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter()); try { return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor()); } catch (UnsupportedOperationException ex) { return (descriptor.getField() != null ? converter.convertIfNecessary(value, type, descriptor.getField()) : converter.convertIfNecessary(value, type, descriptor.getMethodParameter())); } } // 如果descriptor所对应的类型是数组、Map、List等类型，就将descriptor对应的类型所匹配的所有Bean方法，不用进一步做筛选了 Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter); if (multipleBeans != null) { return multipleBeans; } // 找到所有Bean，key是beanName，value有可能是bean对象，有可能是beanClass Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor); if (matchingBeans.isEmpty()) { // 如果没有找到Bean，但是required属性为true，则直接抛出异常 if (isRequired(descriptor)) { raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor); } return null; } String autowiredBeanName; Object instanceCandidate; // 找到的是多个，再根据名称进行过滤 if (matchingBeans.size() > 1) { // 这里会处理@Primary注解，如果有一个bean有@Primary注解，则返回，也会处理@Priority注解，优先级 autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor); if (autowiredBeanName == null) { if (isRequired(descriptor) || !indicatesMultipleBeans(type)) { return descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans); } else { return null; } } instanceCandidate = matchingBeans.get(autowiredBeanName); } else { // We have exactly one match. Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next(); autowiredBeanName = entry.getKey(); instanceCandidate = entry.getValue(); } if (autowiredBeanNames != null) { autowiredBeanNames.add(autowiredBeanName); } // 有可能筛选出来的是某个bean的类型，此处就进行实例化，调用getBean if (instanceCandidate instanceof Class) { instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this); } Object result = instanceCandidate; if (result instanceof NullBean) { if (isRequired(descriptor)) { raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor); } result = null; } if (!ClassUtils.isAssignableValue(type, result)) { throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass()); } return result; } finally { ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint); } } \",\"当找到多个对象的时候，并不是所有的都需要实例化，如果不需要创建，findAutowireCandidates方法会返回Class对象。\",\" protected Map<String, Object> findAutowireCandidates( @Nullable String beanName, Class<?> requiredType, DependencyDescriptor descriptor) { // 在所有的beanDefinition找到符合这个类型的所有bean的名称 String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this, requiredType, true, descriptor.isEager()); Map<String, Object> result = CollectionUtils.newLinkedHashMap(candidateNames.length); for (Map.Entry<Class<?>, Object> classObjectEntry : this.resolvableDependencies.entrySet()) { Class<?> autowiringType = classObjectEntry.getKey(); if (autowiringType.isAssignableFrom(requiredType)) { Object autowiringValue = classObjectEntry.getValue(); autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType); if (requiredType.isInstance(autowiringValue)) { result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue); break; } } } // candidateNames存的就是找到的和所给类型匹配的所有的bean for (String candidate : candidateNames) { // 如果有多个，优先考虑注入不是自己的那个bean if (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, descriptor)) { addCandidateEntry(result, candidate, descriptor, requiredType); } } if (result.isEmpty()) { boolean multiple = indicatesMultipleBeans(requiredType); // Consider fallback matches if the first pass failed to find anything... DependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch(); for (String candidate : candidateNames) { if (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, fallbackDescriptor) && (!multiple || getAutowireCandidateResolver().hasQualifier(descriptor))) { addCandidateEntry(result, candidate, descriptor, requiredType); } } if (result.isEmpty() && !multiple) { // Consider self references as a final pass... // but in the case of a dependency collection, not the very same bean itself. for (String candidate : candidateNames) { if (isSelfReference(beanName, candidate) && (!(descriptor instanceof MultiElementDescriptor) || !beanName.equals(candidate)) && isAutowireCandidate(candidate, fallbackDescriptor)) { addCandidateEntry(result, candidate, descriptor, requiredType); } } } } return result; } \",\"isAutowireCandidate方法的作用是用来判断给定的bean是否可以用来依赖注入：\",\" protected boolean isAutowireCandidate( String beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver) throws NoSuchBeanDefinitionException { String bdName = BeanFactoryUtils.transformedBeanName(beanName); // 根据BeanDefinition的autowireCandidate属性来判断是否可以用来依赖注入 if (containsBeanDefinition(bdName)) { return isAutowireCandidate(beanName, getMergedLocalBeanDefinition(bdName), descriptor, resolver); } else if (containsSingleton(beanName)) { return isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor, resolver); } BeanFactory parent = getParentBeanFactory(); if (parent instanceof DefaultListableBeanFactory) { // No bean definition found in this factory -> delegate to parent. return ((DefaultListableBeanFactory) parent).isAutowireCandidate(beanName, descriptor, resolver); } else if (parent instanceof ConfigurableListableBeanFactory) { // If no DefaultListableBeanFactory, can't pass the resolver along. return ((ConfigurableListableBeanFactory) parent).isAutowireCandidate(beanName, descriptor); } else { return true; } } \",\"依赖注入的判断条件：\",\"BeanDefinition的autowireCandidate属性\",\"泛型条件判断\",\"@Qualifier\",\"@Primary\",\"@Priority\",\"bean的名称\",\"Spring会在找到注入点之后，将其beanName缓存起来。对于单例bean，并不会触发这个缓存，对于原型bean，在第二次调用getBean方法的时候就会触发。之所以只缓存beanName，是因为依赖注入的可能也是原型bean，这种情况下，每次依赖注入获取bean都应该是一个新的bean。\",\"@Resource和@Autowired注解的区别在于，@Resource是Java规范支持的注解，主要是通过CommonAnnotationBeanPostProcessor来实现，而@Autowired是Spring的注解。之所以会支持@Resource注解是因为，Spring考虑到如果开发者要迁移到其他支持依赖注入的框架，使用Java标准的@Resource注解可以在不修改源码的情况下完成迁移。\"]},\"1649\":{\"h\":\"循环依赖解析\",\"t\":[\"解决循环依赖，主要思路是利用三级缓存：\",\"singletonObjects（经历过完整生命周期的Bean对象）\",\"earlySingletonObjects（用于缓存AOP对象，里面存的是部分属性为空的对象，）\",\"singletonFactories（key是beanName，value是一段lamda表达式，用来获取原始对象）\",\"额外辅助：singletonCurrentlyIncreation，可以通过这个集合查找到正在创建的bean。\",\"之所以需要第三个Map才能解决循环依赖的根本原因是存在代理。原本Spring会在初始化后进行AOP操作，但因为循环依赖的存在，不得不提前缓存AOP的对象。\",\"详细解析：https://blog.csdn.net/hao134838/article/details/121239018\",\"第三个Map，singletonFactories的主要逻辑：\",\" boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { // 判断是否需要进行AOP，如果需要进行AOP，则返回代理对象，如果不需要，则返回原始对象，执行完这个lambda表达式，会将返回的对象放置到earlySingletonObjects中。 // 之后进行AOP的操作的时候，会根据earlyProxyReferences这个Map来判断是否需要AOP操作。 addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); } \",\"打破循环最关键的点是singletonFactories。\",\"@Lazy注解的作用，是在属性填充的时候会直接生成一个代理对象，在使用这个代理对象的方法的时候才会去创建属性的实例对象。\",\"@Transactional注解并不会影响循环依赖，因为@Transactional注解并不会注入一个新的BeanPostProcessor，而是向Spring容器中添加了一个advisor。\"]},\"1650\":{\"h\":\"推断构造源码解析\",\"t\":[\"Spring使用构造方法的原则如下：\",\"默认情况下，使用无参构造方法，或者只要一个构造方法的情况下，就使用唯一的构造方法\",\"如果制定了构造方法的入参值，通过getBean()或者BeanDefinition.getConstructorArgumentValues()指定，那么就会使用所匹配的构造方法\",\"如果想让Spring自动选择构造方法以及构造方法的入参值，可以通过设置autowire=\\\"constructor\\\"来实现\",\"如果使用@Autowired注解制定了某个构造方法，但是希望Spring自动找该构造方法的入参值\",\"推断构造方法的核心源码如下：\",\" protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) { // Make sure bean class is actually resolved at this point. Class<?> beanClass = resolveBeanClass(mbd, beanName); if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \\\"Bean class isn't public, and non-public access not allowed: \\\" + beanClass.getName()); } Supplier<?> instanceSupplier = mbd.getInstanceSupplier(); if (instanceSupplier != null) { return obtainFromSupplier(instanceSupplier, beanName); } // 处理@Bean对应的BeanDefinition if (mbd.getFactoryMethodName() != null) { return instantiateUsingFactoryMethod(beanName, mbd, args); } // Shortcut when re-creating the same bean... boolean resolved = false; boolean autowireNecessary = false; if (args == null) { synchronized (mbd.constructorArgumentLock) { // 缓存BeanDefition的属性，缓存好的构造方法和参数值 if (mbd.resolvedConstructorOrFactoryMethod != null) { resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; } } } if (resolved) { // 如果确定了当前BeanDefinition的构造方法，那么看是否需要进行对构造方法进行参数的依赖注入（构造方法注入） if (autowireNecessary) { // 这里会拿到缓存好的构造方法入参，实例化bean对象 return autowireConstructor(beanName, mbd, null, null); } else { // 构造方法已经找到了，但是没有参数，直接进行实例化 return instantiateBean(beanName, mbd); } } // 这里主要是通过AutowiredAnnotationBeanPostProcessor查找构造方法，当有多个构造方法和只有一个无参的构造方法都会返回null，这个时候，Spring会优先使用无参的构造方法。 Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) { return autowireConstructor(beanName, mbd, ctors, args); } // Preferred constructors for default construction? ctors = mbd.getPreferredConstructors(); if (ctors != null) { return autowireConstructor(beanName, mbd, ctors, null); } // No special handling: simply use no-arg constructor. return instantiateBean(beanName, mbd); } \",\"有@Lookup注解的时候，在推断构造方法之后，会生成cglib的代理对象。\"]},\"1651\":{\"h\":\"Spring启动过程\",\"t\":[\"Spring启动的过程其实就是需要做一些准备工作，好方便后续的相关操作。\",\"创建BeanFactory实例对象，DefaultListableBeanFactory\",\"解析配置类\",\"扫描得到BeanDefinition，存入beanDefitionMap\",\"beanBostprocess\",\"单例池\",\"创建BeanFactory的实例对象：\",\"public GenericApplicationContext() { this.beanFactory = new DefaultListableBeanFactory(); } \",\"于此同时，DefaultListableBeanFactory的父类AbstractAutowireCapableBeanFactory的构造方法：\",\" public AbstractAutowireCapableBeanFactory() { super(); ignoreDependencyInterface(BeanNameAware.class); ignoreDependencyInterface(BeanFactoryAware.class); ignoreDependencyInterface(BeanClassLoaderAware.class); if (NativeDetector.inNativeImage()) { this.instantiationStrategy = new SimpleInstantiationStrategy(); } else { // 初始化cglib策略 this.instantiationStrategy = new CglibSubclassingInstantiationStrategy(); } } \",\"public AnnotationConfigApplicationContext() { StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start(\\\"spring.context.annotated-bean-reader.create\\\"); // 创建读取器，同时也会创建StandardEnvironment对象 this.reader = new AnnotatedBeanDefinitionReader(this); createAnnotatedBeanDefReader.end(); this.scanner = new ClassPathBeanDefinitionScanner(this); } \",\"可以重复调用refresh方法的ApplicationContext的执行逻辑是，先执行bean的销毁方法，然后将beanFactory关闭，最后创建一个新的beanFactory。\",\"protected final void refreshBeanFactory() throws BeansException { if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); loadBeanDefinitions(beanFactory); this.beanFactory = beanFactory; } catch (IOException ex) { throw new ApplicationContextException(\\\"I/O error parsing bean definition source for \\\" + getDisplayName(), ex); } } \",\"启动过程的完整代码：\",\" @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { StartupStep contextRefresh = this.applicationStartup.start(\\\"spring.context.refresh\\\"); // 准备一些资源，设置一些基础属性，主要是加载Properties资源 prepareRefresh(); // 是否可以重复刷新的应用上下文 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 往BeanFactory工厂中添加如下对象： // 1.设置BeanFactory的类加载器，Spring EL表达式解析器，类型转化注册器 // 2.添三个BeanPostProcessor，注意是具体的BeanPostProcessor实例对象 // 3.记录ignoreDependencyInterface // 4.记录ResolvableDependency // 5. 添加三个单例Bean prepareBeanFactory(beanFactory); try { // 模版方法，供子类调用 postProcessBeanFactory(beanFactory); StartupStep beanPostProcess = this.applicationStartup.start(\\\"spring.context.beans.post-process\\\"); // 扫描得到BeanDefinition，放到Bean工厂当中 invokeBeanFactoryPostProcessors(beanFactory); // 将扫描到的BeanPostProcessors实例化并排序，并添加到BeanFactory的BeanPostProcessors属性中去 registerBeanPostProcessors(beanFactory); beanPostProcess.end(); // 初始化国际化相关的内容 initMessageSource(); // 初始化事件广播器 initApplicationEventMulticaster(); // 模版方法，给子类扩展 onRefresh(); // 注册时间监听器 registerListeners(); // 实例化懒加载的Bean finishBeanFactoryInitialization(beanFactory); // Spring容器生命周期处理 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\\\"Exception encountered during context initialization - \\\" + \\\"cancelling refresh attempt: \\\" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); contextRefresh.end(); } } } \",\"处理Spring容器的生命周期：\"]},\"1652\":{\"h\":\"配置类解析与扫描过程源码解析\",\"t\":[\"BeanDefinitionRegistryPostProcessor与BeanFactoryPostProcessor的区别在于，BeanDefinitionRegistryPostProcessor可以向BeanFactory中注册BeanDefinition，BeanFactoryPostProcessor只可以拿到BeanDifinition。通常会先先执行postProcessBeanDefinitionRegistry方法，然后再执行postProcessBeanFactory方法。\",\"扫描的整个过程说白了，其实就是向BeanFatory中添加各种各样的BeanDifinition。\",\"配置类加载的主要的类：org.springframework.context.annotation.ConfigurationClassPostProcessor\",\"实现了MergedBeanDefinitionPostProcessor接口的BeanPostProcessor的postProcessMergedBeanDefinition会被放到最后再执行。\",\"完整的解析配置类流程图：https://www.processon.com/view/link/5f9512d5e401fd06fda0b2dd\",\"只要给定的Bean对象，有以下四个注解之一，就可以认为是配置类。\",\"static { candidateIndicators.add(Component.class.getName()); candidateIndicators.add(ComponentScan.class.getName()); candidateIndicators.add(Import.class.getName()); candidateIndicators.add(ImportResource.class.getName()); } \",\"除了上述的情况外，在类（也可以是接口的实现类或者内部类）的任意一个方法上面添加了@Bean的也是配置类。\",\"扫描处理的核心类：\",\"org.springframework.context.annotation.ConfigurationClassParser\",\"@Import注解的处理过程如下：\",\"整个完整的解析过程如下：\",\"在解析的时候，是一批一批进行解析的，实现DeferredImportSelector接口的类，会在每一批的最后执行selectImports方法。\",\"默认情况下，@Bean的会覆盖掉@Component的BeanDefinition。\",\"@Configuration(proxyBeanMethods = true)表示要增强这个配置类，会生成代理类，主要是为了解决@Bean注解方法返回的单例对象的问题。\"]},\"1653\":{\"h\":\"整合Mybatis底层源码解析\",\"t\":[\"Spring整合其他的框架本质上就是让其他的框架所产生的对象成为Spring IOC容器中的Bean。\",\"通过@MapperScan导入了MapperScannerRegistrar类\",\"MapperScannerRegistrar类实现了ImportBeanDefinitionRegistrar接口，所以Spring在启动时会调用MapperScannerRegistrar类中的registerBeanDefinitions方法\",\"在registerBeanDefinitions方法中定义了一个ClassPathMapperScanner对象，用来扫描mapper\",\"设置ClassPathMapperScanner对象可以扫描到接口，因为在Spring中是不会扫描接口的\",\"同时因为ClassPathMapperScanner中重写了isCandidateComponent方法，导致isCandidateComponent只会认为接口是备选者Component\",\"通过利用Spring的扫描后，会把接口扫描出来并且得到对应的BeanDefinition\",\"接下来把扫描得到的BeanDefinition进行修改，把BeanClass修改为MapperFactoryBean，把AutowireMode修改为byType\",\"扫描完成后，Spring就会基于BeanDefinition去创建Bean了，相当于每个Mapper对应一个FactoryBean\",\"在MapperFactoryBean中的getObject方法中，调用了getSqlSession()去得到一个sqlSession对象，然后根据对应的Mapper接口生成一个Mapper接口代理对象，这个代理对象就成为Spring容器中的Bean\",\"sqlSession对象是Mybatis中的，一个sqlSession对象需要SqlSessionFactory来产生\",\"MapperFactoryBean的AutowireMode为byType，所以Spring会自动调用set方法，有两个set方法，一个setSqlSessionFactory，一个setSqlSessionTemplate，而这两个方法执行的前提是根据方法参数类型能找到对应的bean，所以Spring容器中要存在SqlSessionFactory类型的bean或者SqlSessionTemplate类型的bean。\",\"如果你定义的是一个SqlSessionFactory类型的bean，那么最终也会被包装为一个SqlSessionTemplate对象，并且赋值给sqlSession属性\",\"而在SqlSessionTemplate类中就存在一个getMapper方法，这个方法中就产生一个Mapper接口代理对象\",\"到时候，当执行该代理对象的某个方法时，就会进入到Mybatis框架的底层执行流程，详细的请看下图\",\"Spring整合Mybatis之后SQL执行流程：https://www.processon.com/view/link/6152cc385653bb6791db436c\",\"如果Spring整合Mybatis之后，开启了事务，则一级缓存生效，如果没有开启事务，一级缓存就会失效。\"]},\"1654\":{\"h\":\"Spring AOP源码解析\",\"t\":[\"CGLIB和JDK的动态代理示例：\",\"public class ProxyTest { public static void main(String[] args) { /*********************** * CGLIB动态代理 ***********************/ UserService target = new UserService(); // 通过cglib技术 Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(UserService.class); // 定义额外逻辑，也就是代理逻辑 enhancer.setCallbacks(new Callback[]{new MethodInterceptor() { // o表示的就是代理对象，target是被代理的对象爱过你 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(\\\"before...\\\"); // 被代理的方法，目标对象 Object result = methodProxy.invoke(target, objects); // 执行原始对象的方法 // Object result = methodProxy.invokeSuper(target, objects); System.out.println(\\\"after...\\\"); return result; } }, NoOp.INSTANCE}); // 设置哪些方法不被代理 enhancer.setCallbackFilter(new CallbackFilter() { @Override public int accept(Method method) { if (method.getName().equals(\\\"test\\\")) { return 0; } else { return 1; } } }); // 动态代理所创建出来的UserService对象 UserService userService = (UserService) enhancer.create(); // 执行这个userService的test方法时，就会额外会执行一些其他逻辑 userService.test(); /*********************** * JDK动态代理 ***********************/ UserService target2 = new UserService(); // UserInterface接口的代理对象 Object proxy = Proxy.newProxyInstance(UserService.class.getClassLoader(), new Class[]{UserInterface.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\\\"before...\\\"); Object result = method.invoke(target2, args); System.out.println(\\\"after...\\\"); return result; } }); // 这里只能是UserInterface类型的，产生的代理对象一定是传入的接口的类型 UserInterface userService2 = (UserInterface) proxy; userService2.test(); } } \",\"在Spring中，对这两项技术做了一定程度的封装，使用ProxyFactory获取代理对象。\",\"public class SpringProxyTest { public static void main(String[] args) { UserService target = new UserService(); ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.setTarget(target); // 指定接口的时候，就会返回JDK动态代理的对象 // proxyFactory.setInterfaces(UserInterface.class); // 会被封装成MethodInterceptor，有多个Advice会按照顺序进行执行 proxyFactory.addAdvice(new MethodBeforeAdvice() { @Override public void before(Method method, Object[] args, Object target) throws Throwable { } }); UserService proxy = (UserService) proxyFactory.getProxy(); proxy.test(); } } \",\"除了直接使用API的方式来生成代理对象，也可以使用@Bean的方式代理对象：\",\" @Bean public DefaultPointcutAdvisor defaultPointcutAdvisor(){ NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut(); pointcut.addMethodName(\\\"test\\\"); DefaultPointcutAdvisor defaultPointcutAdvisor = new DefaultPointcutAdvisor(); defaultPointcutAdvisor.setPointcut(pointcut); defaultPointcutAdvisor.setAdvice(new AfterReturningAdvice() { @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { } }); return defaultPointcutAdvisor; } @Bean public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() { DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator(); return defaultAdvisorAutoProxyCreator; } \",\"DefaultAdvisorAutoProxyCreator实际上是一个BeanPostProcessor，会查找Advisor类型的Bean，就确定了哪些对象是需要生成代理对象的。\",\"AOP还有一种AspectJ的实现，Spring AOP参照了AspectJ的实现，复用了AspectJ中的几个核心注解，AspectJ是在编译期间就增强了对应的方法，Spring 则是在启动的过程中，通过CGLIB或者JDK的动态代理来实现AOP。Spring 会通过AnnotationAwareAspectJAutoProxyCreator将@Aspect注解扫描到Spring容器中。\",\"被代理的对象通常称为target，被代理的方法通常被称为Join point（连接点）。\",\"除了增强某个类中的某个方法，还可以通过@DeclareParents动态的为被代理对象增加接口和接口中定义的方法。但是这么做的缺点是，代码的可读性较差。\",\"创建代理对象的核心方法：\",\"可以通过设置exposeProxy=true，将代理对象暴露在ThreadLocal中，通过AopContext.currentProxy()就可以获取到被代理的对象。\",\"在ProxyFactory筛选代理对象的被代理的方法：\",\" List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); \",\"Advice的底层是通过MethodInterceptor来实现的。\",\"@Override public List<Object> getInterceptorsAndDynamicInterceptionAdvice( Advised config, Method method, @Nullable Class<?> targetClass) { AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); // config 其实就是ProxyFactory Advisor[] advisors = config.getAdvisors(); List<Object> interceptorList = new ArrayList<>(advisors.length); Class<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass()); Boolean hasIntroductions = null; for (Advisor advisor : advisors) { if (advisor instanceof PointcutAdvisor) { // 取出Pointcut，根据ClassFilter和MethodMatcher来进行过滤 PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor; if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) { MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher(); boolean match; if (mm instanceof IntroductionAwareMethodMatcher) { if (hasIntroductions == null) { hasIntroductions = hasMatchingIntroductions(advisors, actualClass); } match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions); } else { match = mm.matches(method, actualClass); } if (match) { // 适配成MethodInterceptor，通常情况都是一对一的，interceptors只会有一个元素 MethodInterceptor[] interceptors = registry.getInterceptors(advisor); // 运行时会封装成为InterceptorAndDynamicMethodMatcher // 真正执行的时候，会再检查MethodMatcher里带参数matches的方法是否返回true if (mm.isRuntime()) { for (MethodInterceptor interceptor : interceptors) { interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm)); } } else { interceptorList.addAll(Arrays.asList(interceptors)); } } } } else if (advisor instanceof IntroductionAdvisor) { IntroductionAdvisor ia = (IntroductionAdvisor) advisor; if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) { Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } else { Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } return interceptorList; } \",\"一个切面中 ，有@Before，@After（只有AspectJ才有），@Around等注解的方法，他们的执行顺序是由一个比较器来决定的：\",\"static { Comparator<Method> adviceKindComparator = new ConvertingComparator<>( new InstanceComparator<>( Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class), (Converter<Method, Annotation>) method -> { AspectJAnnotation<?> ann = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method); return (ann != null ? ann.getAnnotation() : null); }); Comparator<Method> methodNameComparator = new ConvertingComparator<>(Method::getName); adviceMethodComparator = adviceKindComparator.thenComparing(methodNameComparator); } \",\"即按照Around、Before、After、AfterReturning、AfterThrowing的顺序进行执行。出现重复的注解修饰的方法，会按照自然排序进行执行。\"]},\"1655\":{\"h\":\"Spring事务源码解析\",\"t\":[\"开启Spring事务本质上就是增加了一个Advisor，但我们使用@EnableTransactionManagement注解来开启Spring事务是，该注解代理的功能就是向Spring容器中添加了两个Bean：\",\"AutoProxyRegistrar\",\"ProxyTransactionManagementConfiguration\",\"AutoProxyRegistrar主要的作用是向Spring容器中注册了一个InfrastructureAdvisorAutoProxyCreator的Bean。\",\"而InfrastructureAdvisorAutoProxyCreator继承了AbstractAdvisorAutoProxyCreator，所以这个类的主要作用就是开启自动代理的作用，也就是一个BeanPostProcessor，会在初始化后步骤中去寻找Advisor类型的Bean，并判断当前某个Bean是否有匹配的Advisor，是否需要利用动态代理产生一个代理对象。\",\"ProxyTransactionManagementConfiguration是一个配置类，它又定义了另外三个bean：\",\"BeanFactoryTransactionAttributeSourceAdvisor：一个Advisor\",\"AnnotationTransactionAttributeSource：相当于BeanFactoryTransactionAttributeSourceAdvisor中的Pointcut\",\"TransactionInterceptor：相当于BeanFactoryTransactionAttributeSourceAdvisor中的Advice\",\"AnnotationTransactionAttributeSource就是用来判断某个类上是否存在@Transactional注解，或者判断某个方法上是否存在@Transactional注解的。\",\"TransactionInterceptor就是代理逻辑，当某个类中存在@Transactional注解时，到时就产生一个代理对象作为Bean，代理对象在执行某个方法时，最终就会进入到TransactionInterceptor的invoke()方法。\",\"核心API：org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration#transactionInterceptor\",\"事务的执行过程：\",\"Spring事务管理器，创建数据库连接conn\",\"conn.autocommit=flase\",\"将数据库连接conn放入ThreadLocal（key是DataSource，value是conn连接，这就要求Spring事务管理器中的DataSource和JDBC Tmeplate中的DataSource是同一个，否则，事务可能就会失效）\",\"执行业务方法\",\"如果执行成功，则提交事务\",\"如果抛出了异常，则回滚\",\"隔离级别会依赖于数据库，传播行为是Spring事务管理中的难点。\",\"同一个数据连接（或事务），要么一起提交，要么一起回滚。\",\"执行的核心逻辑：\",\" @Nullable protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass, final TransactionAspectSupport.InvocationCallback invocation) throws Throwable { // If the transaction attribute is null, the method is non-transactional. TransactionAttributeSource tas = getTransactionAttributeSource(); // 获取@Transactional注解的属性值 final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null); // 获取Spring 容器中的事务管理器 final TransactionManager tm = determineTransactionManager(txAttr); // ReactiveTransactionManager用的比较少，通常都走else的逻辑 if (this.reactiveAdapterRegistry != null && tm instanceof ReactiveTransactionManager) { boolean isSuspendingFunction = KotlinDetector.isSuspendingFunction(method); boolean hasSuspendingFlowReturnType = isSuspendingFunction && COROUTINES_FLOW_CLASS_NAME.equals(new MethodParameter(method, -1).getParameterType().getName()); if (isSuspendingFunction && !(invocation instanceof TransactionAspectSupport.CoroutinesInvocationCallback)) { throw new IllegalStateException(\\\"Coroutines invocation not supported: \\\" + method); } TransactionAspectSupport.CoroutinesInvocationCallback corInv = (isSuspendingFunction ? (TransactionAspectSupport.CoroutinesInvocationCallback) invocation : null); TransactionAspectSupport.ReactiveTransactionSupport txSupport = this.transactionSupportCache.computeIfAbsent(method, key -> { Class<?> reactiveType = (isSuspendingFunction ? (hasSuspendingFlowReturnType ? Flux.class : Mono.class) : method.getReturnType()); ReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(reactiveType); if (adapter == null) { throw new IllegalStateException(\\\"Cannot apply reactive transaction to non-reactive return type: \\\" + method.getReturnType()); } return new TransactionAspectSupport.ReactiveTransactionSupport(adapter); }); TransactionAspectSupport.InvocationCallback callback = invocation; if (corInv != null) { callback = () -> CoroutinesUtils.invokeSuspendingFunction(method, corInv.getTarget(), corInv.getArguments()); } Object result = txSupport.invokeWithinTransaction(method, targetClass, callback, txAttr, (ReactiveTransactionManager) tm); if (corInv != null) { Publisher<?> pr = (Publisher<?>) result; return (hasSuspendingFlowReturnType ? TransactionAspectSupport.KotlinDelegate.asFlow(pr) : TransactionAspectSupport.KotlinDelegate.awaitSingleOrNull(pr, corInv.getContinuation())); } return result; } PlatformTransactionManager ptm = asPlatformTransactionManager(tm); // 会将执行的方法名称设置为事务的名称 final String joinpointIdentification = methodIdentification(method, targetClass, txAttr); if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) { // 开启一个事务 TransactionAspectSupport.TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification); Object retVal; try { // 执行被代理对象中的方法 retVal = invocation.proceedWithInvocation(); } catch (Throwable ex) { // 抛出异常，则回滚 completeTransactionAfterThrowing(txInfo, ex); throw ex; } finally { cleanupTransactionInfo(txInfo); } if (retVal != null && vavrPresent && TransactionAspectSupport.VavrDelegate.isVavrTry(retVal)) { // Set rollback-only in case of Vavr failure matching our rollback rules... TransactionStatus status = txInfo.getTransactionStatus(); if (status != null && txAttr != null) { retVal = TransactionAspectSupport.VavrDelegate.evaluateTryFailure(retVal, txAttr, status); } } // 提交事务 commitTransactionAfterReturning(txInfo); return retVal; } else { Object result; final TransactionAspectSupport.ThrowableHolder throwableHolder = new TransactionAspectSupport.ThrowableHolder(); // It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in. try { result = ((CallbackPreferringPlatformTransactionManager) ptm).execute(txAttr, status -> { TransactionAspectSupport.TransactionInfo txInfo = prepareTransactionInfo(ptm, txAttr, joinpointIdentification, status); try { Object retVal = invocation.proceedWithInvocation(); if (retVal != null && vavrPresent && TransactionAspectSupport.VavrDelegate.isVavrTry(retVal)) { // Set rollback-only in case of Vavr failure matching our rollback rules... retVal = TransactionAspectSupport.VavrDelegate.evaluateTryFailure(retVal, txAttr, status); } return retVal; } catch (Throwable ex) { if (txAttr.rollbackOn(ex)) { // A RuntimeException: will lead to a rollback. if (ex instanceof RuntimeException) { throw (RuntimeException) ex; } else { throw new TransactionAspectSupport.ThrowableHolderException(ex); } } else { // A normal return value: will lead to a commit. throwableHolder.throwable = ex; return null; } } finally { cleanupTransactionInfo(txInfo); } }); } catch (TransactionAspectSupport.ThrowableHolderException ex) { throw ex.getCause(); } catch (TransactionSystemException ex2) { if (throwableHolder.throwable != null) { logger.error(\\\"Application exception overridden by commit exception\\\", throwableHolder.throwable); ex2.initApplicationException(throwableHolder.throwable); } throw ex2; } catch (Throwable ex2) { if (throwableHolder.throwable != null) { logger.error(\\\"Application exception overridden by commit exception\\\", throwableHolder.throwable); } throw ex2; } // Check result state: It might indicate a Throwable to rethrow. if (throwableHolder.throwable != null) { throw throwableHolder.throwable; } return result; } } \"]},\"1656\":{\"h\":\"Spring MVC源码分析\",\"t\":[\"Spring MVC本质上是基于Servlet API构建的原始Web框架。\"]},\"1657\":{\"h\":\"Spring MVC执行流程\",\"t\":[\"最典型的MVC就是JSP+Servlet+javabean的模式。\",\"所有的请求都会经过DispatcherServlet。\",\"Spring MVC的请求执行过程：\",\"HandlerMapping的典型实现：\",\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\",\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\",\"HandlerAdapter的典型实现：\",\"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter\",\"ViewResoler的典型实现：\",\"org.springframework.web.servlet.view.BeanNameViewResolver\",\"处理请求的方法：\",\"可以发现，一旦有一个Handler成功匹配，就会直接返回，不会再往下匹配了。\",\"@RequestMapping的完成流程：https://www.processon.com/view/link/615ea79e1efad4070b2d6707\",\"参数解析转换核心API：\",\"org.springframework.http.converter.HttpMessageConverter\",\"扩展点：前、后拦截器：\",\"public class JycInterceptor implements HandlerInterceptor { /** * 在 HandlerMapping 确定合适的处理程序对象之后，但在 HandlerAdapter 调用处理程序之前调用 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return HandlerInterceptor.super.preHandle(request, response, handler); } /** * 拦截处理程序的执行。在 HandlerAdapter 实际上调用处理程序之后调用，但在 DispatcherServlet 呈现视图之前调用 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); } /** * 请求处理完成后的回调，即渲染视图后。将在处理程序执行的任何结果上调用，从而允许进行适当的资源清理。 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { HandlerInterceptor.super.afterCompletion(request, response, handler, ex); } } \"]},\"1658\":{\"h\":\"Spring MVC启动过程\",\"t\":[\"容器之间的关系：\",\"SPI机制：服务提供者接口，Tomcat提供了WebApplicationInitializer的接口，实现者必须按照Servlet规范实现接口，然后在MTEA-INF/services目录下放置一个名称为javax.servlet接口名，里面的内容是实现者实现的类的完整的类限定名。\",\"Tomcat除了会帮我们实例化我们所实现的WebApplicationInitializer的类以外，还提供了@HandlerTypes，他会将@HandlerTypes执行的接口的实现类，传递到onStartup方法的第一个参数上面（webAppInitializerClasses）去。\",\" protected void registerDispatcherServlet(ServletContext servletContext) { String servletName = getServletName(); Assert.hasLength(servletName, \\\"getServletName() must not return null or empty\\\"); // 创建Servlet容器 WebApplicationContext servletAppContext = createServletApplicationContext(); Assert.notNull(servletAppContext, \\\"createServletApplicationContext() must not return null\\\"); // 创建DispatcherServlet FrameworkServlet dispatcherServlet = createDispatcherServlet(servletAppContext); Assert.notNull(dispatcherServlet, \\\"createDispatcherServlet(WebApplicationContext) must not return null\\\"); dispatcherServlet.setContextInitializers(getServletApplicationContextInitializers()); ServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet); if (registration == null) { throw new IllegalStateException(\\\"Failed to register servlet with name '\\\" + servletName + \\\"'. \\\" + \\\"Check if there is another servlet registered under the same name.\\\"); } // 启动时加载 registration.setLoadOnStartup(1); // 映射 registration.addMapping(getServletMappings()); // 是否支持异步 registration.setAsyncSupported(isAsyncSupported()); // 设置DispatcherServlet的过滤器 Filter[] filters = getServletFilters(); if (!ObjectUtils.isEmpty(filters)) { for (Filter filter : filters) { registerServletFilter(servletContext, filter); } } // 模版方法 customizeRegistration(registration); } \",\"启动核心API：\",\"org.springframework.web.context.ContextLoader\",\"添加配置类：\",\"org.springframework.web.servlet.config.annotation.WebMvcConfigurer\"]},\"1659\":{\"h\":\"Spring和Spring MVC为什么需要父子容器？不要不行吗？\",\"t\":[\"就实现层面来说，不用父子容器也可以完成所需功能。之所以设置了父子容器：\",\"为了与Spring划分边界，将Controller交由Spring mvc的容器管理，其他则交由Spring管理\",\"规范整体框架，使得父容器（Spring容器）无法访问子容器（Spring MVC容器）\",\"为了方便子容器的切换，可以很方便的将Spring MVC替换为struts\",\"为了节省重复创建Bean的开销\"]},\"1660\":{\"h\":\"是否可以把所有Bean都通过Spring容器来管理？\",\"t\":[\"不可以，因为HandleMethod需要在Spring MVC容器中查找Controller，如果交由Spring管理，会找不到对应的Controller。\"]},\"1661\":{\"h\":\"是否可以把所有Bean都交由Spring MVC容器进行管理？\",\"t\":[\"可以，因为doGetBean方法的逻辑是，子容器中找不到，会在父容器查找Bean，都放到子容器中，可以直接查找到。\"]},\"1662\":{\"h\":\"JVM\"},\"1663\":{\"h\":\"JVM类加载机制\",\"t\":[\"参考链接：http://note.youdao.com/noteshare?id=35faf7c95e69943cdbff4642fcfd5318&sub=F6E1EB8E778044EC9BB87BA05DCE5E4B\",\"通过Java命令执行代码的大体流程如下：\",\"其中类加载过程有加载、验证、准备、解析、初始化、使用、卸载：\",\"加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\",\"验证：校验字节码文件的正确性\",\"准备：给类的静态变量分配内存，并赋予默认值\",\"解析：将符号引用替换为直接引用，该阶段会把一些静态方法（符号引用，比如main()方法）替换为指向数据所存内存的指针或句柄等（直接引用），这就是所谓的静态链接过程（类加载期间完成），动态链接是在程序运行期间完成的将符号引用替换为直接引用\",\"初始化：对类的静态变量初始化为指定的值，执行静态代码块\",\"类被加载到方法区中后主要包含运行时常量池、类型信息、字段信息、方法信息、类加载的引用、对应Class实例的引用等信息。\",\"类加载器的引用：这个类到类加载器实例的引用。\",\"对应Class实例的引用：类加载器在加载类信息放到方法区中后，会创建一个对应的Class类型的对象实例放到堆中，作为开发人员访问方法区中类定义的入口和切入点。\",\"Java中有以下几种类加载器：\",\"引导类加载器：负载加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、chatset.jar等\",\"扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext目录下的类库，比如JAR类包\",\"应用类加载器：负责加载ClassPath路径下的类包，主要就是加载自己写的那些类\",\"自定义类加载器：负载加载用户自定义路径下的类包\",\"Java类加载器是有亲子层级结构的，具体如下图。\",\"为什么要设计双亲委托机制？\",\"沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改\",\"避免类的重复加载：当父亲已经加载了该类时，就没有必要子类加载器再加载一次，保证加载类的唯一性\",\"双亲委派机制简单来说就是，先找父亲加载，不行再由儿子自己加载。\",\"//ClassLoader的loadClass方法，里面实现了双亲委派机制 protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 检查当前类加载器是否已经加载了该类 Class<?> c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { //如果当前加载器父加载器不为空则委托父加载器加载该类 c = parent.loadClass(name, false); } else { //如果当前加载器父加载器为空则委托引导类加载器加载该类 c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); //都会调用URLClassLoader的findClass方法在加载器的类路径里查找并加载该类 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { //不会执行 resolveClass(c); } return c; } } \",\"全盘负责委托机制：全盘负责是指当一个ClassLoader装在一个类时，除非显示的使用另外一个ClassLoader，该类所依赖及引用的类也由这个ClassLoader载入。\",\"Tomcat自定义类加载器：\"]},\"1664\":{\"h\":\"JVM内存模型\",\"t\":[\"JDK的体系结构：\",\"JVM整体架构及内存模型：\",\"栈（线程）的作用：保存局部变量的地方。\",\"栈帧：一个方法对应一块独立的栈帧内存区域。\",\"局部变量表：在类似数组的数据结构里存放局部变量\",\"操作数栈：程序运行过程中，进行加法（或其他）运算的一块临时内存，是一种栈结构\",\"动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期间调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接\",\"方法出口： 用来记录回到调用的地方继续执行程序的地方\",\"方法区使用的直接内存。\",\"JVM参数设置：\",\"SpringBoot程序的JVM参数设置格式：\",\"java -Xms2048M -Xmx2048M -Xmn1024M -Xss512K -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -jar microservice-eureka-server.jar \",\"各个参数对应的含义：\",\"-Xss：每个线程的栈大小\",\"-Xms：设置堆的初始可用大小，默认是物理内存的1/64\",\"-Xmx：设置堆的最大可用大小，默认物理内存的1/4\",\"-Xmn：新生代大小\",\"-XX：NewRatio：默认值2代表新生代占老年代的1/2，占整个堆内存的1/3\",\"-XX：SurvivorRatio：默认8表示一个Survivor区占用1/8的Eden内存，即1/10的新生代内存\",\"关于元空间的JVM参数。有两个：-XX：MetaspaceSize=N和-XX：MAXMetaspaceSize=N。\",\"-XX：MAXMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存的大小。\",\"-XX：MetaspaceSize：指定元空间触发Full GC初始阈值（元空间无固定初始大小），以字节为单位，默认是21M左右，达到该值就会触发full gc进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很多空间，那么在不超过-XX：MAXMetaspaceSize（如果设置了的话）的情况下，适当提高该值。这个跟早期JDK版本的-XX:PermSize参数意思不一样，-XX:PermSize代表永久带的初始容量。\",\"由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MAXMetaspaceSize设置成一样的值，并设置得比初始值要大，对于8G物理内存的机器来说，一般会将这两个值设置成256M。\"]},\"1665\":{\"h\":\"JVM对象创建与内存分配机制深度剖析\",\"t\":[\"对象创建的过程：\"]},\"1666\":{\"h\":\"类加载检查\",\"t\":[\"虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\",\"new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。\"]},\"1667\":{\"h\":\"分配内存\",\"t\":[\"在类加载检查通过后，接下来\"]},\"1668\":{\"h\":\"划分内存的方法\",\"t\":[\"解决并发问题的方法：\",\"CAS：虚拟机采用CAS分配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。\",\"本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）：\"]},\"1669\":{\"h\":\"设置对象头\",\"t\":[\"大对象：-XX:PretenureSizeThreshold=1000000（单位是字节）。需要配合具体的垃圾收集器一起使用：-XX:+UseSerialGC。\",\"这样做的目的是为了避免大对象分配内存时的复制操作而降低效率。\"]},\"1670\":{\"h\":\"Class文件结构\"},\"1671\":{\"h\":\"垃圾收集器\"},\"1672\":{\"h\":\"JVM调优工具\"},\"1673\":{\"h\":\"JVM常量池\"},\"1674\":{\"h\":\"ZGC详解\"},\"1675\":{\"h\":\"云原生时代的Java虚拟机\"},\"1676\":{\"h\":\"用Java实现一个JVM框架\"},\"1677\":{\"h\":\"JVM如何调用Java方法\"},\"1678\":{\"h\":\"实现STW\"},\"1679\":{\"h\":\"Java 日志体系\"},\"1680\":{\"h\":\"Java监控简介\"},\"1681\":{\"h\":\"RMI 简介\"},\"1682\":{\"h\":\"Tomcat\"},\"1683\":{\"h\":\"Tomcat整体架构\",\"t\":[\"Tomcat是Java Web应用服务器，实现Java EE（Java Platform Enterprise Edition）的部分技术规范，比如Java Servlet、JavaServer Pages、Java Expression Language、Java WebSocket等。\",\"Tomcat的核心：Http服务器+Serverlet容器\",\"我们可以通过Tomcat的server.xml配置文件来加深对Tomcat架构的理解。Tomcat采用了组件化的设计，它的构成组件都是可配置的，其中最外层的是Server，其他组件按照一定的格式要求配置在这个顶层容器中。\",\"<Server> //顶层组件，可以包括多个Service <Service> //顶层组件，可包含一个Engine，多个连接器 <Connector/>//连接器组件，代表通信接口 <Engine>//容器组件，一个Engine组件处理Service中的所有请求，包含多个Host <Host> //容器组件，处理特定的Host下客户请求，可包含多个Context <Context/> //容器组件，为特定的Web应用处理所有的客户请求 </Host> </Engine> </Service> </Server> \",\"Tomcat启动期间会通过解析server.xml，利用反射创建相应的组件，所以xml的标签和源码一一对应。\",\"Tomcat的架构图如下：\",\"简化之后的图：\",\"Tomcat要实现2个核心功能：\",\"处理Socket连接，负责网络字节流与Request和Response对象的转化\",\"加载和管理Servlet，以及具体处理Request请求\",\"因此Tomcat设计了两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情。连接器负责对外交流，容器负责内部处理。\"]},\"1684\":{\"h\":\"Tomcat核心组件\"},\"1685\":{\"h\":\"Server组件\",\"t\":[\"Server组件指的就是整个Tomcat服务器，包含多组服务（Service），负责管理和启动各个Service，同时监听8005端口发过来的shutdown命令，用于关闭整个容器。\"]},\"1686\":{\"h\":\"Service组件\",\"t\":[\"每个Service组件都包含了若干接收客户端消息的Connector组件和处理请求的Engine组件。Service组件还包含了若干Executor组件，每个Executor都是一个线程池，它可以为Service内所有组件提供线程池执行任务。\"]},\"1687\":{\"h\":\"连接器Connector组件\",\"t\":[\"Tomcat与外部世界的连接器，监听固定端口接收外部请求，传递给Container，并将Container处理的结果返回给外部。连接器对Servlet容器屏蔽了不同的应用层协议及I/O模型，无论是HTTP还是AJP，在容器中获取到的都是一个标准的ServletRequest对象。连接器需要实现的功能：\",\"监听网络端口\",\"接收网络连接请求\",\"获取请求网络字节流\",\"根据具体应用协议（HTTP/AJP）解析字节流，生成统一的Tomcat Request对象\",\"将Tomcat Request对象转成标准的Servlet Request\",\"调用Servlet容器，得到ServletResponse\",\"将Tomcat Response转成网络字节流\",\"将响应字节流写会给浏览器\",\"分析连接器的功能列表，会发现连接器需要完成3个高内聚的功能：\",\"网络通信\",\"应用层协议解析\",\"Tomcat Request/Response 与ServletRequest/ServletResponse的转化\",\"因此，Tomcat的设计者分别设计了3个组件来实现这3个功能，分别是EndPoint、Processor和Adapter：\",\"EndPoint负责提供字节流给Processor\",\"Processor负责提供Tomcat Request对象给Adapter\",\"Adapter负责提供ServletRequest对象给容器\",\"由于I/O模型和应用层协议可以自由组合，比如NIO+HTTP或者NIO2+AJP。Tomcat的设计者将网络通信和应用层协议解析放在一起考虑，设计了一个ProtocolHandler的接口来封装这两种变化点。各种协议和通信模型的组合有相应的具体实现类。比如Http11NioProtocol和AjpNioProtocol。\",\"除了这些变化点，系统也存在一些相对稳定的部分，因此Tomcat设计了一系列抽象基类来封装这些稳定的部分，抽象基类AbstractProtocol实现了ProtocolHandler接口。每一种应用层协议都有自己的抽象基类，比如AbstractAjpProtocol和AbstractHttp11Protocol，具体协议的实现类扩展了协议层抽象基类。\"]},\"1688\":{\"h\":\"ProtocolHandler组件\",\"t\":[\"连接器用ProtocolHandler来处理网络连接和应用层协议，包含两个重要部件：EndPoint和Processor。\",\"连接器用ProtocolHandler接口来封装通信协议个I/O模型的差异，ProtocolHandler内部又分为EndPoint和Processor模块，EndPoint负责底层Sokcet通信，Processor负责应用层协议解析。连接器通过适配器Adapter调用容器。\"]},\"1689\":{\"h\":\"Tomcat线程模型\",\"t\":[\"MMU内存管理模型。\",\"Tomcat对JDK线程池的扩展TaskQueue#offer：\",\"@Override public boolean offer(Runnable o) { //we can't do any checks if (parent==null) { return super.offer(o); } //we are maxed out on threads, simply queue the object if (parent.getPoolSize() == parent.getMaximumPoolSize()) { return super.offer(o); } //we have idle threads, just add it to the queue if (parent.getSubmittedCount()<=(parent.getPoolSize())) { return super.offer(o); } //if we have less threads than maximum force creation of a new thread if (parent.getPoolSize()<parent.getMaximumPoolSize()) { return false; } //if we reached here, we need to add it to the queue return super.offer(o); } \",\"这样在未达到最大线程数的时候，会首先创建线程，只有在达到了线程池最大线程数的时候才会将任务放入到阻塞队列。\"]},\"1690\":{\"h\":\"Tomcat类加载机制\"},\"1691\":{\"h\":\"JVM类加载器\",\"t\":[\"BootStrapClassLoader（启动类加载器），\",\"ExtClassLoader（扩展类加载器），\",\"AppClassLoader（系统类加载器）\",\"自定义类加载器，用来加载自定义路径下的类\"]},\"1692\":{\"h\":\"双亲委托机制\",\"t\":[\"加载某个类会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类。这就是双亲委托机制。\",\"类加载过程\",\"为什么要设计双亲委托机制？\",\"沙箱安全机制\",\"避免类的重复加载\"]},\"1693\":{\"h\":\"Tomcat的类加载机制\",\"t\":[\"Tomcat作为Servlet容器，它负责加载Servlet类，此外它还负责加载Servlet所依赖的Jar包。并且Tomcat本身也是一个Java程序，因此它需要加载自己的类和依赖的jar包。\",\"Tomcat中自定义了一个类加载器WebAppClassLoader，并且给每个Web应用创建一个类加载器实例，每个Context容器负责创建和维护一个WebAppClassLoader加载器实例。其实现的原理就是不同的类加载器实例加载的类被认为是不同的类，即使它们的类名相同（不同类加载器实例加载的类是互相隔离的）。\",\"Tomcat拥有不同的自定义类加载器，以实现对各种资源库的控制。Tomcat主要用类加载器解决以下4个问题：\",\"同一个Web服务器里，各个Web项目各自使用的Java类库要相互隔离\",\"同一个Web服务器里，各个Web项目之间可以提供共享的Java类库\",\"为了使服务器不受Web项目的影响，应该使服务器的类库与应用程序的类库相互独立\",\"对于支持JSP的Web服务器，应该支持热插拔（HotSwap）功能\",\"Tomcat提供了四组目录供用户存放第三方类库：\",\"放置在/common目录中：类库可被Tomcat和所有的Web应用程序共同使用\"]},\"1694\":{\"h\":\"线程上下文类加载器\"},\"1695\":{\"h\":\"Tomcat热加载和热部署\"},\"1696\":{\"h\":\"深入理解JVM\"},\"1697\":{\"h\":\"内存管理\"},\"1698\":{\"h\":\"垃圾回收\"},\"1699\":{\"h\":\"类文件结构\"},\"1700\":{\"h\":\"类加载机制\"},\"1701\":{\"h\":\"运行时数据区域\"},\"1702\":{\"h\":\"程序计数器\"},\"1703\":{\"h\":\"虚拟机栈\"},\"1704\":{\"h\":\"本地方法栈\"},\"1705\":{\"h\":\"堆\"},\"1706\":{\"h\":\"方法区\"},\"1707\":{\"h\":\"运行时常量池\"},\"1708\":{\"h\":\"直接内存\"},\"1709\":{\"h\":\"HotSpot虚拟机对象\"},\"1710\":{\"h\":\"对象的创建\"},\"1711\":{\"h\":\"对象的内存布局\"},\"1712\":{\"h\":\"对象的访问定位\"},\"1713\":{\"h\":\"判断对象已死\"},\"1714\":{\"h\":\"引用计数算法\"},\"1715\":{\"h\":\"根搜索算法\"},\"1716\":{\"h\":\"对象的回收\"},\"1717\":{\"h\":\"对象的引用\"},\"1718\":{\"h\":\"垃圾回收算法\"},\"1719\":{\"h\":\"分代收集理论\"},\"1720\":{\"h\":\"标记-清除算法\"},\"1721\":{\"h\":\"标记-复制算法\"},\"1722\":{\"h\":\"标记-整理算法\"},\"1723\":{\"h\":\"经典垃圾收集器\"},\"1724\":{\"h\":\"Serial收集器\"},\"1725\":{\"h\":\"ParNew收集器\"},\"1726\":{\"h\":\"Parallel Scavenge收集器\"},\"1727\":{\"h\":\"Serial Old收集器\"},\"1728\":{\"h\":\"Parallel Old收集器\"},\"1729\":{\"h\":\"CMS收集器\"},\"1730\":{\"h\":\"CMS简介\"},\"1731\":{\"h\":\"CMS详细步骤\"},\"1732\":{\"h\":\"初始标记\"},\"1733\":{\"h\":\"并发标记\"},\"1734\":{\"h\":\"预清理阶段\"},\"1735\":{\"h\":\"可终止的预清理\"},\"1736\":{\"h\":\"重新标记\"},\"1737\":{\"h\":\"并发清理\"},\"1738\":{\"h\":\"并发重置\"},\"1739\":{\"h\":\"Garbage First收集器\"},\"1740\":{\"h\":\"G1简介\"},\"1741\":{\"h\":\"重要概念\"},\"1742\":{\"h\":\"Region\"},\"1743\":{\"h\":\"三色标记算法\"},\"1744\":{\"h\":\"SATB算法\"},\"1745\":{\"h\":\"RSet\"},\"1746\":{\"h\":\"CSet\"},\"1747\":{\"h\":\"停顿预测模型\"},\"1748\":{\"h\":\"GC过程\"},\"1749\":{\"h\":\"回收算法\"},\"1750\":{\"h\":\"收集过程\"},\"1751\":{\"h\":\"Young GC\"},\"1752\":{\"h\":\"Mixed GC\"},\"1753\":{\"h\":\"global concurrent marking\"},\"1754\":{\"h\":\"G1特点\"},\"1755\":{\"h\":\"参数设置\"},\"1756\":{\"h\":\"垃圾收集器参数总结\"},\"1757\":{\"h\":\"HotSpot的算法实现细节\"},\"1758\":{\"h\":\"根节点枚举\"},\"1759\":{\"h\":\"安全点\"},\"1760\":{\"h\":\"安全区域\"},\"1761\":{\"h\":\"记忆集与卡表\"},\"1762\":{\"h\":\"并发的可达性分析\"},\"1763\":{\"h\":\"空间分配担保\"},\"1764\":{\"h\":\"内存屏障\"},\"1765\":{\"h\":\"来源\"},\"1766\":{\"h\":\"类型\"},\"1767\":{\"h\":\"Java内存屏障\"},\"1768\":{\"h\":\"volatile语义中的内存屏障\"},\"1769\":{\"h\":\"final语义中的内存屏障\"},\"1770\":{\"h\":\"性能监控、故障处理工具\"},\"1771\":{\"h\":\"基础故障处理工具\"},\"1772\":{\"h\":\"可视化故障处理工具\"},\"1773\":{\"h\":\"jvisualvm\"},\"1774\":{\"h\":\"jconsole\"},\"1775\":{\"h\":\"Class类文件的结构\"},\"1776\":{\"h\":\"魔数与Class文件的版本\"},\"1777\":{\"h\":\"常量池\"},\"1778\":{\"h\":\"访问标志\"},\"1779\":{\"h\":\"类索引、父类索引与接口索引集合\"},\"1780\":{\"h\":\"字段表集合\"},\"1781\":{\"h\":\"方法表集合\"},\"1782\":{\"h\":\"属性表集合\"},\"1783\":{\"h\":\"字节码指令\"},\"1784\":{\"h\":\"字节码与数据类型\"},\"1785\":{\"h\":\"类加载过程\"},\"1786\":{\"h\":\"加载\"},\"1787\":{\"h\":\"验证\"},\"1788\":{\"h\":\"准备\"},\"1789\":{\"h\":\"解析\"},\"1790\":{\"h\":\"初始化\"},\"1791\":{\"h\":\"类加载器\"},\"1792\":{\"h\":\"类与类加载器\"},\"1793\":{\"h\":\"双亲委派模型\"},\"1794\":{\"h\":\"破坏双亲委派模型\"},\"1795\":{\"h\":\"SPI机制\"},\"1796\":{\"h\":\"简介\"},\"1797\":{\"h\":\"JDK SPI\"},\"1798\":{\"h\":\"Spring SPI\"},\"1799\":{\"h\":\"运行时栈帧结构\"},\"1800\":{\"h\":\"局部变量表\"},\"1801\":{\"h\":\"操作数栈\"},\"1802\":{\"h\":\"动态连接\"},\"1803\":{\"h\":\"方法返回地址\"},\"1804\":{\"h\":\"附加信息\"},\"1805\":{\"h\":\"方法调用\"},\"1806\":{\"h\":\"解析\"},\"1807\":{\"h\":\"分派\"},\"1808\":{\"h\":\"Java内存模型\"},\"1809\":{\"h\":\"主内存与工作内存\"},\"1810\":{\"h\":\"volatile型变量\"},\"1811\":{\"h\":\"Java与线程\"},\"1812\":{\"h\":\"线程的实现\"},\"1813\":{\"h\":\"Java线程调度\"},\"1814\":{\"h\":\"线程状态\"},\"1815\":{\"h\":\"线程安全\"},\"1816\":{\"h\":\"互斥同步\"},\"1817\":{\"h\":\"非阻塞同步\"},\"1818\":{\"h\":\"无同步方案\"},\"1819\":{\"h\":\"锁优化\"},\"1820\":{\"h\":\"自旋锁与自适应自旋\"},\"1821\":{\"h\":\"锁消除\"},\"1822\":{\"h\":\"锁粗化\"},\"1823\":{\"h\":\"轻量级锁\"},\"1824\":{\"h\":\"偏向锁\"},\"1825\":{\"h\":\"RocketMQ从实践到原理\"},\"1826\":{\"h\":\"概念\"},\"1827\":{\"h\":\"消息模型\"},\"1828\":{\"h\":\"生产者组\"},\"1829\":{\"h\":\"消费者组\"},\"1830\":{\"h\":\"集群消费\"},\"1831\":{\"h\":\"广播消息\"},\"1832\":{\"h\":\"标签\"},\"1833\":{\"h\":\"队列\"},\"1834\":{\"h\":\"协议\"},\"1835\":{\"h\":\"特性\"},\"1836\":{\"h\":\"消息顺序\"},\"1837\":{\"h\":\"消息重试\"},\"1838\":{\"h\":\"延迟队列\"},\"1839\":{\"h\":\"死信队列\"},\"1840\":{\"h\":\"技术架构\"},\"1841\":{\"h\":\"集群工作流程\"},\"1842\":{\"h\":\"架构设计\"},\"1843\":{\"h\":\"消息存储\"},\"1844\":{\"h\":\"消息存储整体架构\"},\"1845\":{\"h\":\"页缓存与内存映射\"},\"1846\":{\"h\":\"消息刷盘\"},\"1847\":{\"h\":\"通信机制\"},\"1848\":{\"h\":\"RocketMQ通信类结构\"},\"1849\":{\"h\":\"Reactor线程设计\"},\"1850\":{\"h\":\"消息过滤\"},\"1851\":{\"h\":\"负载均衡\"},\"1852\":{\"h\":\"生产者\"},\"1853\":{\"h\":\"Tags的使用\"},\"1854\":{\"h\":\"Keys的使用\"},\"1855\":{\"h\":\"选择oneway形式发送\"},\"1856\":{\"h\":\"消费者\"},\"1857\":{\"h\":\"消费过程幂等\"},\"1858\":{\"h\":\"提升消费速度\"},\"1859\":{\"h\":\"顺序消费\"},\"1860\":{\"h\":\"并发消费\"},\"1861\":{\"h\":\"顺序消费\"},\"1862\":{\"h\":\"全局有序\"},\"1863\":{\"h\":\"分区有序\"},\"1864\":{\"h\":\"订阅关系的一致性\"},\"1865\":{\"h\":\"正确的订阅关系\"},\"1866\":{\"h\":\"错误的订阅关系\"},\"1867\":{\"h\":\"订阅了不同的Topic\"},\"1868\":{\"h\":\"订阅了不同Tag\"},\"1869\":{\"h\":\"订阅不同数量的Topic\"},\"1870\":{\"h\":\"配置管理\"},\"1871\":{\"h\":\"依赖管理\"},\"1872\":{\"h\":\"外部化配置\"},\"1873\":{\"h\":\"配置类\"},\"1874\":{\"h\":\"发送消息\"},\"1875\":{\"h\":\"发送普通消息\"},\"1876\":{\"h\":\"发送事务消息\"},\"1877\":{\"h\":\"接收消息\"},\"1878\":{\"h\":\"接收普通消息\"},\"1879\":{\"h\":\"接收事务消息\"},\"1880\":{\"h\":\"消息发送过程\"},\"1881\":{\"h\":\"选择发送的路由\"},\"1882\":{\"h\":\"向Broker发送消息\"},\"1883\":{\"h\":\"消息存储过程\"},\"1884\":{\"h\":\"写入文件\"},\"1885\":{\"h\":\"文件可以完全存储消息\"},\"1886\":{\"h\":\"文件不可以完全存储消息\"},\"1887\":{\"h\":\"消息刷盘\"},\"1888\":{\"h\":\"消息接收过程\"},\"1889\":{\"h\":\"消费者注册\"},\"1890\":{\"h\":\"消息队列\"},\"1891\":{\"h\":\"广播模式\"},\"1892\":{\"h\":\"集群模式\"},\"1893\":{\"h\":\"平均分配策略\"},\"1894\":{\"h\":\"平均分配轮询策略\"},\"1895\":{\"h\":\"一致性哈希策略\"},\"1896\":{\"h\":\"Broker消费队列\"},\"1897\":{\"h\":\"集群模式\"},\"1898\":{\"h\":\"广播模式\"},\"1899\":{\"h\":\"消费消息\"},\"1900\":{\"h\":\"并发消费\"},\"1901\":{\"h\":\"有序消费\"},\"1902\":{\"h\":\"消息过滤过程\"},\"1903\":{\"h\":\"消息过滤类型\"},\"1904\":{\"h\":\"标签匹配\"},\"1905\":{\"h\":\"SQL匹配\"},\"1906\":{\"h\":\"注册过滤信息\"},\"1907\":{\"h\":\"生成BloomFilterData\"},\"1908\":{\"h\":\"编译SQL语句\"},\"1909\":{\"h\":\"计算位映射\"},\"1910\":{\"h\":\"存储位映射\"},\"1911\":{\"h\":\"消息过滤\"},\"1912\":{\"h\":\"自定义匹配\"},\"1913\":{\"h\":\"过滤服务器\"},\"1914\":{\"h\":\"过滤类\"},\"1915\":{\"h\":\"过滤消息\"},\"1916\":{\"h\":\"消息索引流程\"},\"1917\":{\"h\":\"消息查询\"},\"1918\":{\"h\":\"ID (偏移量) 查询\"},\"1919\":{\"h\":\"消息索引服务\"},\"1920\":{\"h\":\"索引文件结构\"},\"1921\":{\"h\":\"添加消息\"},\"1922\":{\"h\":\"查询消息\"},\"1923\":{\"h\":\"唯一键查询\"},\"1924\":{\"h\":\"键查询消息\"},\"1925\":{\"h\":\"定时消息和重试消息\"},\"1926\":{\"h\":\"定时消息\"},\"1927\":{\"h\":\"定时消息存储\"},\"1928\":{\"h\":\"消息重试\"},\"1929\":{\"h\":\"Producer消息发送重试\"},\"1930\":{\"h\":\"Consumer消息接收重试\"},\"1931\":{\"h\":\"主备同步\"},\"1932\":{\"h\":\"建立连接\"},\"1933\":{\"h\":\"数据传输\"},\"1934\":{\"h\":\"消息异步传输\"},\"1935\":{\"h\":\"消息同步传输\"},\"1936\":{\"h\":\"消费建议\"},\"1937\":{\"h\":\"异常处理\"},\"1938\":{\"h\":\"事务消息\"},\"1939\":{\"h\":\"发送事务消息\"},\"1940\":{\"h\":\"接收事务消息\"},\"1941\":{\"h\":\"接收事务准备消息\"},\"1942\":{\"h\":\"接收事务结束的消息\"},\"1943\":{\"h\":\"扫描事务状态\"},\"1944\":{\"h\":\"Server定时扫描\"},\"1945\":{\"h\":\"Server检查事务状态\"},\"1946\":{\"h\":\"客户端检查事务状态\"},\"1947\":{\"h\":\"ACL权限控制\"},\"1948\":{\"h\":\"使用示例\"},\"1949\":{\"h\":\"RPCHook\"},\"1950\":{\"h\":\"AclClientRPCHook\"},\"1951\":{\"h\":\"生成签名\"},\"1952\":{\"h\":\"添加扩展字段\"},\"1953\":{\"h\":\"Broker权限验证\"},\"1954\":{\"h\":\"校验权限\"},\"1955\":{\"h\":\"ACL权限管理器\"},\"1956\":{\"h\":\"逻辑队列\"},\"1957\":{\"h\":\"架构实现\"},\"1958\":{\"h\":\"实现\"},\"1959\":{\"h\":\"监听者模式\"},\"1960\":{\"h\":\"Zookeeper\"},\"1961\":{\"h\":\"Zookeeper特性与节点数据类型\"},\"1962\":{\"h\":\"Zookeeper经典应用场景\"},\"1963\":{\"h\":\"Zookeeper集群Leader选举\"},\"1964\":{\"h\":\"Zookeeper集群与Watcher监听机制\"},\"1965\":{\"h\":\"\",\"t\":[\"云原生时代，Java 的危与机\",\"从Linux内核角度探秘JDK NIO文件读写本质\",\"MVCC机制\",\"76 张图，剖析 Spring AOP 源码\",\"系统日志规范及最佳实践\",\"一个高并发项目到落地的心酸路\",\"硬核Redis\",\"万亿级日访问量下，Redis在微博的9年优化历程\"]},\"1966\":{\"h\":\"\",\"t\":[\"Java\",\"语言基础\",\" Java编程开发入门\",\"Java面向对象编程\",\"Java高级编程\",\"深入理解Java8\",\"常用框架\",\"SSM框架\",\"MyBatisPlus\",\"跟我学SpringBoot\",\"SpringBoot与SpringCloud\",\"Spring核心编程思想\",\"Spring AOP\",\"深入理解Netty\",\"核心原理\",\"精通Java并发\",\"Java并发编程之美\",\"Java并发编程的艺术\",\"深入理解JVM\",\"中间件\",\"MySQL高级教程\",\"MySQL实战45讲\",\"Redis入门\",\"Redis开发与运维\",\"RabbitMQ\",\"RocketMq\",\"C/C++\",\"语言基础 \",\"C++面向对象编程\",\"C++ 11 新特性\",\"核心原理 \",\"C++内存管理\",\"STL源码剖析\",\"跨平台\",\"flutter \",\"flutter实战\",\"部署运维\",\"linux\",\"鸟哥的私房菜\",\"deepin\",\"Linux内核之旅\",\"docker\",\"第一本docker书\",\"Spring Cloud与Docker微服务架构实战\",\"docker compose与docker swarm\",\"必备技能\",\"计算机基础\",\"计算机组成原理\",\"操作系统\",\"编译原理\",\"常用工具\",\"深入理解git\",\"设计模式\",\"高鹏-设计模式\",\"大话设计模式\",\"数据结构和算法\",\"大话数据结构\",\"算法训练营\",\"leetCode\",\"牛客网\",\"相关证书\",\"软件设计师\"]},\"1967\":{\"h\":\"Java学习路线\",\"t\":[\"一入Java深似海。\"]},\"1968\":{\"h\":\"学习路线概览\",\"t\":[\"首先，我先分享下自己对不同学习方式的理解，小伙伴们可以根据自己情况选择。\",\"看视频系统学习，比如培训机构的课程、MOOC的课程等。看视频的好处就是有老师带着，易于理解和掌握，非常适合初学者。\",\"看书学习，如《Redis设计与实现》、《 Java 并发编程的艺术》，便于了解技术脉络和深入学习知识点。\",\"看博客和源码精进学习。博客的好处是有些知识点会以很通俗的方式讲解出来，我们很好理解。\"]},\"1969\":{\"h\":\"第一阶段：Java 基础\",\"t\":[\"最开始要学习的是 Java 基础，学习了这部分，就会对 Java 语言有一个初步的了解。其实大部分语言的基础知识都是大同小异，如果之前已经学习过其他语言如C、C++，那学习这部分会更快。\",\"这部分主要学习的内容有：基本程序结构，类与对象，接口，泛型，反射，集合，异常， Java 网络编程， Java I/O和多线程。对于实习和校招的小伙伴来讲一定要好好学这部分的内容，前面学的越好，后面会越轻松，并且这部分内容面试也经常被问到。\",\"学 Java 基础，推荐大家看尚硅谷宋红康老师的 Java 教程，宋老师的课程更适合零基础学员，从 Java 语言起源开始，循序渐进，知识点剖析细致。\",\"宋老师的 Java 基础教程：https://www.bilibili.com/video/BV1Kb411W75N\",\"除此之外，还可以阅读《 Java 核心技术 卷I》，这本书偏向实用，广度和深度都恰到好处。其中，第7-9章讲述了 Java 的GUI编程， Java 的GUI开发使用并不多，这部分可以先跳过。\",\"网上也有一些不错的文档教程网站，可以辅助学习：\",\"廖雪峰 Java 教程：https://www.liaoxuefeng.com/wiki/1252599548343744\",\"菜鸟教程 Java ：https://www.runoob.com/Java/Java-tutorial.html\",\"当学完了这部分，就可以做个图书管理系统、学生管理系统这样的小项目了。\",\"当然，时间有限的小伙伴，可以不用做这块的项目，直接做 Java Web 项目就好了。\"]},\"1970\":{\"h\":\"第二阶段：LeetCode\",\"t\":[\"学完 Java 基础之后，就可以开始刷算法啦！这部分内容对于想要进好一点的公司的同学来说非常重要，普通公司也有可能会有算法的笔试环节。\",\"好在对于 Java 程序员来说，算法的要求并不算特别高，只要掌握最常用的数据结构以及一些经典的算法题目即可。\",\"由于算法会用到数据结构的相关知识，所以在学习算法之前，我们需要先了解数据结构相关的内容。\"]},\"1971\":{\"h\":\"数据结构\",\"t\":[\"数据结构推荐大家看《大话数据结构》这本书，通俗易懂，内容全面，非常适合入门。\"]},\"1972\":{\"h\":\"算法\",\"t\":[\"直接自己从开始学算法，还是比较吃力的，也难以形成自己的知识体系，了解学习的重难点和掌握合适的学习方法非常重要，这里我推荐极客时间的课程，算法训练营：\",\"算法训练营：https://pan.baidu.com/s/1FRIIC-H5DPVd6Sy8uW-SpA?pwd=h4v2\",\"你也可以按照代码随想录整理的路线刷题：\",\"代码随想录：https://programmercarl.com/\",\"一般来说，应届生一般只要掌握热题100里面的题目即可：\",\"leetcode热题100：https://leetcode.cn/studyplan/top-100-liked/\",\"算法部分并不是要完全学完所有的题目才开始学下一个阶段，而是刷个10来道题目之后，就可以开始下一阶段的学习了。剩下的题目可以在每天开始学其他内容之前，做1-2道题目，保持刷题的节奏感。\",\"算法是学习任何一门编程语言都绕不开的知识，也是最有难度的知识。如果你学的过程中，感到无从下手，看了答案也不知道该怎么做，或者刷了很多题目了，碰到某些题目还是没有任何思路，相信我，这是正常现象，没有人可以一开始，就搞的懂这么难的东西。\",\"你需要做的就是过遍数，不断的过遍数，在面试之前将常考的题目解题思路和代码印在脑子里，形成肌肉记忆，达到基本不怎么用思考，也能把这些题目都顺利的写出来。\",\"刷题过程中，最好做笔记，把题目的解题思路和解法都写一下，方便在面试复习之前刷过的题目。\"]},\"1973\":{\"h\":\"第三阶段：数据库\"},\"1974\":{\"h\":\"MySQL\",\"t\":[\"MySQL 和 Oracle 都是广受企业欢迎的数据库，其中 MySQL 是目前应用最广泛的开源关系数据库，对于新手或者校招的小伙伴，我们目前只学习 MySQL 就可以了。\",\"这部分主要学习的内容有：数据库的CRUD操作、JDBC API、数据库特性和数据库连接池。\",\"其中，数据库连接池是为了避免频繁地创建和销毁 JDBC 连接，常见连接池包括 C3P0，Druid 和 HikariCP，目前使用最广泛的是Druid。\",\"尚硅谷的MySQL入门视频：https://www.bilibili.com/video/BV12b411K7Zu\",\"学完基本知识之后，一定要找一些题目练习一下，巩固成果，下面的SQL问题经常出现在面试当中。\",\"SQL经典练习题（老师、学生、成绩）：https://segmentfault.com/a/1190000022279128\",\"书籍方面，推荐入门的小伙伴看《MySQL必知必会》，是一本小册子，这本书实践性很强，基本没有什么理论的堆砌，非常适合入门。\",\"如果想要深入学习，可以看《高性能 MySQL》，这本书是MySQL领域的经典之作，不过就是太厚了，面试重点看索引部分就可以了。\",\"除此之外，如果要深入学习MySQL的使用和原理，可以看极客时间的专栏《MySQL实战45讲》，阿里资深技术专家讲解的课程，有很多生产经常遇到的问题，非常有深度。\"]},\"1975\":{\"h\":\"Redis\",\"t\":[\"Redis 是一个 key-value 存储系统，是跨平台的非关系型数据库，可用作数据库，高速缓存和消息队列代理。\",\"Redis作为当下主流的缓存技术，已经成为互联网企业的不二首选。\",\"Redis入门到精通课程：https://www.bilibili.com/video/BV1CJ411m7Gc\",\"想深入学习的小伙伴，推荐阅读《Redis设计与实现》，知识点非常丰富，讲了很多底层的原理，我曾经看了三遍，对我面试帮助很大，非常推荐！\",\"Redis 设计与实现在线版：http://redisbook.com/\",\"查询Redis命令的中文网站：https://www.redis.com.cn/tutorial.html\"]},\"1976\":{\"h\":\"第四阶段：Java Web\",\"t\":[\"这一阶段的内容均以了解为主，不作为学习的重点，很少有公司需要前后端都掌握，大概了解每种技术有什么作用即可，可以不用学的特别细致。\"]},\"1977\":{\"h\":\"web前端\",\"t\":[\"前端有三大基础技术 Html、CSS和 Java Script，初学的话，学习这些就可以了。如果想做出更好的交互式效果，可以再学习Vue和React等前端技术。\"]},\"1978\":{\"h\":\"web后端\",\"t\":[\"后端 Java 技术包括 Servlet、Filter、Listener、Session、Cookie、JSP、EL 表达式和 JSTL 等。\",\"其中，像 JSP 这样比较老的技术，目前在各大互联网公司基本不再使用，已经被 Freemark、Thymeleaf 这样的模板引擎所替代，我们只需要了解基本使用即可。\",\"入门 Java Web，推荐尚硅谷的 Java Web 教程，教程不仅包括前端三大技术，还有后端 Java 技术，最后还会带大家做一个书城项目。\",\"Java Web教程：https://www.bilibili.com/video/BV1Y7411K7zz\"]},\"1979\":{\"h\":\"第五阶段：主流框架\",\"t\":[\"这部分我们要学习的主流框架主要有 Spring、Spring MVC 和 MyBatis，俗称 SSM 框架。\",\"曾经的 SSH 框架，即 Struts2、Spring、Hibernate 框架，已经逐渐被 SSM 替代，现在可以不用再学 Struts2 和 Hibernate 框架了。\",\"学习这些框架之前，我们先来学习项目管理利器Maven和Git。\"]},\"1980\":{\"h\":\"Maven\",\"t\":[\"Maven 是一个项目管理工具，它基于项目对象模型(POM)的概念，它可以管理项目的构建、报告和文档。\",\"Maven 本质就是一个巨大的 jar 包资源库，使用 Maven 构建项目，只需在项目的 pom.xml 中配置相关依赖后，就可以直接从远程仓库同步到本地，再也不用满世界搜索下载 jar 包了，省了很多查找和下载的烦恼。\",\"动力结点的Maven实战入门视频：https://www.bilibili.com/video/BV1dp4y1Q7Hf?p=29\"]},\"1981\":{\"h\":\"Git\",\"t\":[\"Git 是一个开源的分布式版本控制系统，最大作用就是对文件进行版本管理，方便在不同版本进行切换修改，还可以很方便的协作开发。\",\"GitHub 是基于 Git 的代码库托管站，学会了 Git ，我们就能愉快地上 Github 交友了。\",\"狂神说的 Git 视频： https://www.bilibili.com/video/BV1FE411P7B3\",\"喜欢文字版的小伙伴，推荐看廖雪峰的 Git 教程，很浅显易懂\",\"廖雪峰的 Git 教程：https://www.liaoxuefeng.com/wiki/896043488029600\",\"方便查阅的 Git 中文手册：https://git-scm.com/book/zh/v2\"]},\"1982\":{\"h\":\"SSM框架\",\"t\":[\"Spring 是一个轻量级的 Java 开发框架，现在已经是最受欢迎的企业级 Java 应用程序开发框架，也是 Java 能在服务端具有统治地位的重要原因之一。\",\"Spring 框架的核心特性是依赖注入(DI)与面向切面编程(AOP)，Spring 框架的组成结构图如下所示：\",\"Spring MVC 是一个基于MVC架构，用来简化web应用程序开发的框架，它是 Spring 的一部分，SpringMVC 已经成为目前最主流的 MVC 框架之一。\",\"MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。\",\"在使用传统JDBC时，往往需要写很多JDBC代码，需要自己写SQL语句以及自己装配参数，然后自己对结果集进行封装处理。\",\"而Mybatis则帮我们简化了以上功能，只需要一些配置文件（xml）或是注解即可完成对数据库的查询以及结果的映射封装。\",\"学习SSM框架，推荐使用一整套课程进行学习，会有更好的连贯性，而且还会学习整合SSM框架。\",\"SSM框架视频：https://www.bilibili.com/video/BV1Tv411b7Dp\",\"整合SSM框架还是比较繁琐的，时间紧张的小伙伴可以不用在整合这里花费时间，因为这种整合方式目前也不在流行了，现在直接使用更强大的利器Spring Boot就可以了。\"]},\"1983\":{\"h\":\"Spring Boot\",\"t\":[\"Spring Boot 采用约定大约配置的方式，大量的减少了配置文件的使用，从而使开发人员不再需要定义样板化的配置。\",\"学习 Spring Boot，推荐雷丰阳老师的 Spring Boot 课程，课程基于 SpringBoot2.3与2.4 版本，包含核心基础、Web原理、单元测试、数据访问、指标监控等章节。\",\"那要不要跳过了 SSM 直接去学习 Spring Boot呢？\",\"如果只是为了使用 Spring Boot，当然可以跳过，毕竟 SSM 配置太繁琐了。\",\"如果想深入学习，尤其是找 Java 开发的工作，面试中会出现很多 Spring 的底层问题，因此还是要学习 SSM 的，如果跳过了不利于学习原理。\",\"雷老师的 Spring Boot 课程：https://www.bilibili.com/video/BV19K4y1L7MT\"]},\"1984\":{\"h\":\"第六阶段：服务器中间件\",\"t\":[\"学完上面的内容，我们已经具备实际项目的开发能力了，但是要解决些复杂的业务场景，我们还要学习MQ、Elasticsearch这些中间件。\"]},\"1985\":{\"h\":\"MQ\",\"t\":[\"MQ（Message Queue）是一种跨进程的通信机制，用于传递消息。通俗点说，就是一个先进先出的数据结构。MQ有三大主要作用分别为解耦、异步、削峰/限流。\",\"目前业界有很多MQ产品，比较出名的有以下四种：\",\"我最开始学习的是Kafka，因为做的项目中使用到了，小伙伴们根据喜好或者项目需要，选择一款MQ学习就可以了。\",\"Kafka 教程：https://www.bilibili.com/video/BV1a4411B7V9\",\"RabbitMQ教程：https://www.bilibili.com/video/BV14A411q7pF\",\"目前企业里用的比较多的是RocketMQ和Kafka。\"]},\"1986\":{\"h\":\"Elasticsearch\",\"t\":[\"全文搜索属于最常见的需求，开源的 Elasticsearch是目前全文搜索引擎的首选，这个作为学习的可选项，因为并不是所有的公司都有全文检索的需求，面试中Elasticsearch出现的概率也不高。\",\"它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。\",\"Elasticsearch的底层是开源库 Lucene。但是，必须自己写代码去调用Lucene的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。\",\"ElasticSearch7.6.x最新完整教程：https://www.bilibili.com/video/BV17a4y1x7zq\"]},\"1987\":{\"h\":\"项目实践\",\"t\":[\"学完了这些，就可以把这些技术整合起来做个项目，这里推荐个我做过的社区论坛项目。\",\"这个论坛项目不仅实现了基本的注册，登录，发帖，评论，点赞，回复功能，同时使用前缀树实现敏感词过滤，使用wkhtmltopdf生成长图和pdf，实现网站UV和DAU统计，并将用户头像等信息存于七牛云服务器。\",\"这是项目使用到的相关技术：\",\"这个项目作为Spring Boot实战练手很不错，老师讲解的很清晰，课程的深度和广度都有，而且课程最后还会手把手教大家将项目部署在云服务器。\",\"课程中也会简要讲解Redis、Kafka和Elasticsearch，即使没有学过这些技术，仍然可以学习这个项目。\",\"社区论坛项目：https://www.bilibili.com/video/BV1AZ4y1u7n3\",\"补充一点，现在的服务器基本都是Linux系统，将项目部署在服务器，学习些基本的Linux命令是必不可少的。\",\"韩顺平 一周学会Linux视频：https://www.bilibili.com/video/BV1Sv411r7vd\",\"Linux命令在线查询：https://wangchujiang.com/linux-command/\"]},\"1988\":{\"h\":\"第七阶段：微服务和分布式\",\"t\":[\"对于实习和校招的小伙伴来讲，学好前五阶段的技术知识，再深入学习个技术点就可以了，如果还有时间和精力的小伙伴，可以学习微服务和分布式的内容。\"]},\"1989\":{\"h\":\"Spring Cloud\",\"t\":[\"Spring Cloud 是一套完整的微服务解决方案，基于 Spring Boot框架。\",\"准确的说，Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性简化了分布式系统的开发，比如服务发现、服务网关、服务路由、链路追踪等。\",\"SpringCloud alibaba框架开发教程：https://www.bilibili.com/video/BV18E411x7eT\"]},\"1990\":{\"h\":\"Dubbo\",\"t\":[\"值得一提的是，还有阿里开源Dubbo，Dubbo一个高性能优秀的服务框架。简单地说，Dubbo是一个基于Spring的RPC（远程过程调用）框架，能够实现服务的远程调用、服务的治理。\",\"至于Spring Cloud 和Dubbo 有什么区别，大家可以搜索下。这里用网络上一个台式电脑的比喻来说就是：Dubbo 是品牌机，Spring Cloud 是组装机。\",\"Dubbo 视频：https://www.bilibili.com/video/BV1Gb411T7Ha\"]},\"1991\":{\"h\":\"ZooKeeper\",\"t\":[\"ZooKeeper是一个高可用的分布式管理与协调框架，基于ZAB算法（原子消息广播协议）的实现。该框架能够保证分布式环境中数据的一致性，使得ZooKeeper成为了解决分布式一致性问题的利器。\",\"zookeeper视频：https://www.bilibili.com/video/BV1M741137qY\"]},\"1992\":{\"h\":\"第八阶段：进阶优化\",\"t\":[\"学会前面这些，我们就可以独立完成一个小项目，独立完成项目组分配给你的开发任务。\",\"但是这还不足以写出好的代码，我们要想写出好的代码，还需要学习设计模式，学习多线程，以及JVM的内部原理等。同样，这些也是面试的必考点。\",\"设计模式的书籍推荐《HeadFirst设计模式》，这是一本图文并茂的书籍，适合入门。\",\"JVM 的书籍推荐《深入理解 Java 虚拟机》，这本书是 Java 开发者必看的书，很多 JVM 的文章都是来自这本书。\",\"Java 并发方面，可以看《 Java 并发编程的艺术》，这本书深入到JVM、CPU层面讲解了 Java 并发框架、线程池的原理等，面对面试足够了；还有《并发编程实战》，这是一本不错的 Java 并发参考手册。\",\"部分视频课程如下：\",\"Java 并发编程视频：https://www.bilibili.com/video/BV16J411h7Rd\",\"JVM教程：https://www.bilibili.com/video/BV1PJ411n7xZ\"]},\"1993\":{\"h\":\"End\",\"t\":[\"以上就是 Java 路线的全部内容了，刚入门的小伙伴可能都看头晕了，觉得好多知识点要学。\",\"Java 技术栈知识的确是多，但只要按部就班、由浅入深的学习就会轻松一些，还会比较有成就感，即先学会用这个技术，再做个系统性的项目把技术融合起来，最后再来看原理部分。\",\"特别感谢：零基础Java学习路线 提供的资料。\"]},\"1994\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"觉得好多知识点要学\",{\"1\":{\"1993\":1}}],[\"刚入门的小伙伴可能都看头晕了\",{\"1\":{\"1993\":1}}],[\"韩顺平\",{\"1\":{\"1987\":1}}],[\"评论\",{\"1\":{\"1987\":1}}],[\"登录\",{\"1\":{\"1987\":1}}],[\"登录了银行网站\",{\"1\":{\"1201\":1}}],[\"雷老师的\",{\"1\":{\"1983\":1}}],[\"毕竟\",{\"1\":{\"1983\":1}}],[\"毕竟覆盖数据\",{\"1\":{\"495\":1}}],[\"课程中也会简要讲解redis\",{\"1\":{\"1987\":1}}],[\"课程的深度和广度都有\",{\"1\":{\"1987\":1}}],[\"课程基于\",{\"1\":{\"1983\":1}}],[\"课程\",{\"1\":{\"1983\":2}}],[\"喜欢文字版的小伙伴\",{\"1\":{\"1981\":1}}],[\"狂神说的\",{\"1\":{\"1981\":1}}],[\"动力结点的maven实战入门视频\",{\"1\":{\"1980\":1}}],[\"动态连接\",{\"0\":{\"1802\":1}}],[\"动态链接\",{\"1\":{\"1664\":1}}],[\"动态链接是在程序运行期间完成的将符号引用替换为直接引用\",{\"1\":{\"1663\":1}}],[\"动态地插入propertysource到propertysources\",{\"1\":{\"1156\":1}}],[\"动态代理所创建出来的userservice对象\",{\"1\":{\"1654\":1}}],[\"动态代理\",{\"1\":{\"891\":1,\"899\":1,\"900\":1}}],[\"动态标签解析\",{\"1\":{\"646\":1}}],[\"动态标签会被解析为\",{\"1\":{\"645\":1}}],[\"动态映射的机制\",{\"1\":{\"309\":1}}],[\"省了很多查找和下载的烦恼\",{\"1\":{\"1980\":1}}],[\"省略\",{\"1\":{\"1554\":1}}],[\"省略doinit的实现\",{\"1\":{\"1531\":1}}],[\"省略编辑逻辑\",{\"1\":{\"1531\":1}}],[\"省略且实现\",{\"1\":{\"1531\":1}}],[\"省略业务逻辑代码\",{\"1\":{\"1528\":1}}],[\"报告和文档\",{\"1\":{\"1980\":1}}],[\"报主键冲突\",{\"1\":{\"495\":1}}],[\"报主键冲突错误\",{\"1\":{\"494\":1}}],[\"替代\",{\"1\":{\"1979\":1}}],[\"替换程变量的值\",{\"1\":{\"1210\":1}}],[\"替换为指向数据所存内存的指针或句柄等\",{\"1\":{\"1663\":1}}],[\"替换为元空间\",{\"1\":{\"1457\":1}}],[\"替换为\",{\"1\":{\"1210\":1}}],[\"替换实现\",{\"1\":{\"1101\":1}}],[\"替换xml元素\",{\"1\":{\"1029\":1,\"1131\":1}}],[\"替换xml标签或者实现接口\",{\"1\":{\"1023\":2}}],[\"替换原有注解处理\",{\"1\":{\"967\":1}}],[\"替换targetsource\",{\"0\":{\"777\":1}}],[\"替换\",{\"1\":{\"583\":1,\"1620\":1}}],[\"替换key中\",{\"1\":{\"570\":1}}],[\"替换整个json\",{\"1\":{\"306\":1}}],[\"曾经的\",{\"1\":{\"1979\":1}}],[\"像\",{\"1\":{\"1978\":1}}],[\"像一些rpc框架还有服务注册中心\",{\"1\":{\"1527\":1}}],[\"初学的话\",{\"1\":{\"1977\":1}}],[\"初始标记\",{\"0\":{\"1732\":1}}],[\"初始标记阶段\",{\"1\":{\"1447\":1}}],[\"初始状态\",{\"1\":{\"1477\":1}}],[\"初始\",{\"1\":{\"571\":1}}],[\"初始值是1\",{\"1\":{\"468\":1}}],[\"初始化事件广播器\",{\"1\":{\"1651\":1}}],[\"初始化事件监听器集合\",{\"1\":{\"1162\":1}}],[\"初始化国际化相关的内容\",{\"1\":{\"1651\":1}}],[\"初始化cglib策略\",{\"1\":{\"1651\":1}}],[\"初始化cells数组时\",{\"1\":{\"1480\":1}}],[\"初始化底层原理\",{\"1\":{\"1630\":1}}],[\"初始化号table之后继续添加元素\",{\"1\":{\"1554\":1}}],[\"初始化流程为\",{\"1\":{\"1554\":1}}],[\"初始化长度为指定值\",{\"1\":{\"1554\":1}}],[\"初始化一个新的entry数组\",{\"1\":{\"1550\":1}}],[\"初始化head和last指针为空值节点\",{\"1\":{\"1503\":1}}],[\"初始化时item指向null\",{\"1\":{\"1503\":1}}],[\"初始化时需要指定容量大小\",{\"1\":{\"1502\":1}}],[\"初始化状态\",{\"1\":{\"1490\":1}}],[\"初始化lifecycleprocessor对象\",{\"1\":{\"1172\":1}}],[\"初始化内建spring事件广播器\",{\"0\":{\"1168\":1}}],[\"初始化内建messagesource\",{\"0\":{\"1167\":1}}],[\"初始化早期spring事件集合\",{\"1\":{\"1162\":1}}],[\"初始化完成阶段\",{\"0\":{\"1009\":1}}],[\"初始化后\",{\"1\":{\"1647\":1}}],[\"初始化后方法\",{\"1\":{\"1008\":1}}],[\"初始化后阶段\",{\"0\":{\"1008\":1}}],[\"初始化方法\",{\"1\":{\"1008\":1}}],[\"初始化前\",{\"1\":{\"1647\":1}}],[\"初始化前方法\",{\"1\":{\"1008\":1}}],[\"初始化前阶段\",{\"0\":{\"1006\":1}}],[\"初始化阶段\",{\"0\":{\"1007\":1}}],[\"初始化的方法每次还是会被调用\",{\"1\":{\"985\":1}}],[\"初始化的示例\",{\"1\":{\"931\":1}}],[\"初始化\",{\"0\":{\"1004\":1,\"1790\":1},\"1\":{\"985\":1,\"1019\":1,\"1123\":2,\"1162\":1,\"1234\":1,\"1433\":2,\"1647\":2,\"1663\":2}}],[\"初始化中\",{\"1\":{\"931\":6}}],[\"初始化bean的方式\",{\"0\":{\"931\":1}}],[\"初始化和注册方法\",{\"0\":{\"702\":1}}],[\"初始化数据后\",{\"1\":{\"459\":1}}],[\"初始化插入6个记录\",{\"1\":{\"448\":1}}],[\"初始化sort\",{\"1\":{\"354\":1,\"355\":1,\"418\":1,\"420\":1}}],[\"讲了很多底层的原理\",{\"1\":{\"1975\":1}}],[\"讲一下内存分配策略\",{\"0\":{\"119\":1,\"1450\":1}}],[\"想深入学习的小伙伴\",{\"1\":{\"1975\":1}}],[\"阿里资深技术专家讲解的课程\",{\"1\":{\"1974\":1}}],[\"巩固成果\",{\"1\":{\"1974\":1}}],[\"尚硅谷的mysql入门视频\",{\"1\":{\"1974\":1}}],[\"碰到某些题目还是没有任何思路\",{\"1\":{\"1972\":1}}],[\"碰到需要用日志恢复数据的场景是不是很少\",{\"1\":{\"327\":1}}],[\"感到无从下手\",{\"1\":{\"1972\":1}}],[\"项目实践\",{\"0\":{\"1987\":1}}],[\"项目就好了\",{\"1\":{\"1969\":1}}],[\"项目中有用过设计模式吗\",{\"0\":{\"265\":1,\"1189\":1}}],[\"菜鸟教程\",{\"1\":{\"1969\":1}}],[\"廖雪峰的\",{\"1\":{\"1981\":1}}],[\"廖雪峰\",{\"1\":{\"1969\":1}}],[\"卷i\",{\"1\":{\"1969\":1}}],[\"宋老师的\",{\"1\":{\"1969\":1}}],[\"宋老师的课程更适合零基础学员\",{\"1\":{\"1969\":1}}],[\"循序渐进\",{\"1\":{\"1969\":1}}],[\"循环列表\",{\"1\":{\"1613\":1}}],[\"循环依赖解析\",{\"0\":{\"1649\":1}}],[\"循环依赖\",{\"1\":{\"1237\":1}}],[\"循环依赖的示例\",{\"1\":{\"1184\":1}}],[\"循环依赖开关\",{\"1\":{\"1184\":1}}],[\"循环复制问题\",{\"0\":{\"455\":1}}],[\"循环遍历这100行数据\",{\"1\":{\"401\":1}}],[\"循环结束\",{\"1\":{\"337\":1,\"350\":2}}],[\"教程不仅包括前端三大技术\",{\"1\":{\"1978\":1}}],[\"教程\",{\"1\":{\"1969\":2,\"1978\":1,\"1981\":2,\"1985\":1}}],[\"博客的好处是有些知识点会以很通俗的方式讲解出来\",{\"1\":{\"1968\":1}}],[\"便于了解技术脉络和深入学习知识点\",{\"1\":{\"1968\":1}}],[\"便利性\",{\"1\":{\"958\":1}}],[\"牛客网\",{\"1\":{\"1966\":1}}],[\"鸟哥的私房菜\",{\"1\":{\"1966\":1}}],[\"部署运维\",{\"1\":{\"1966\":1}}],[\"部分视频课程如下\",{\"1\":{\"1992\":1}}],[\"部分累积的结果与一个空的结果容器运算之后还是它本身\",{\"1\":{\"1615\":1}}],[\"部分线程栈和堆可能有时候会出现在cpu缓存中和cpu内部的寄存器中\",{\"1\":{\"1473\":1}}],[\"部分收集\",{\"1\":{\"1434\":1}}],[\"部分\",{\"0\":{\"739\":1},\"1\":{\"945\":1}}],[\"部分复制\",{\"0\":{\"616\":1}}],[\"部分更新\",{\"1\":{\"306\":1}}],[\"精通java并发\",{\"1\":{\"1966\":1}}],[\"精确\",{\"1\":{\"472\":1}}],[\"万亿级日访问量下\",{\"1\":{\"1965\":1}}],[\"剖析\",{\"1\":{\"1965\":1}}],[\"云原生时代\",{\"1\":{\"1965\":1}}],[\"云原生时代的java虚拟机\",{\"0\":{\"1675\":1}}],[\"键查询消息\",{\"0\":{\"1924\":1}}],[\"键值对\",{\"1\":{\"1545\":1,\"1546\":2}}],[\"键值对并设置过期时间\",{\"1\":{\"570\":1}}],[\"破坏双亲委派模型\",{\"0\":{\"1794\":1}}],[\"破坏了事务逻辑的隔离性\",{\"1\":{\"460\":1}}],[\"魔数与class文件的版本\",{\"0\":{\"1776\":1}}],[\"堆\",{\"0\":{\"1705\":1}}],[\"堆中的对象\",{\"1\":{\"1436\":1}}],[\"顶层组件\",{\"1\":{\"1683\":2}}],[\"顶上来\",{\"1\":{\"621\":1}}],[\"划分内存的方法\",{\"0\":{\"1668\":1}}],[\"沙箱安全机制\",{\"1\":{\"1663\":1,\"1692\":1}}],[\"符号引用\",{\"1\":{\"1663\":1}}],[\"呈现视图之前调用\",{\"1\":{\"1657\":1}}],[\"供子类调用\",{\"1\":{\"1651\":1}}],[\"供生产者与消费者使用\",{\"1\":{\"1520\":1}}],[\"添三个beanpostprocessor\",{\"1\":{\"1651\":1}}],[\"添加扩展字段\",{\"0\":{\"1952\":1}}],[\"添加消息\",{\"0\":{\"1921\":1}}],[\"添加配置类\",{\"1\":{\"1658\":1}}],[\"添加三个单例bean\",{\"1\":{\"1651\":1}}],[\"添加了设置父beanfactory\",{\"1\":{\"1636\":1}}],[\"添加了获取父beanfactory的功能\",{\"1\":{\"1636\":1}}],[\"添加成功返回true\",{\"1\":{\"1500\":2}}],[\"添加一个元素\",{\"1\":{\"1500\":2}}],[\"添加方法的源代码\",{\"1\":{\"1480\":1}}],[\"添加效率会比linkedlist低\",{\"1\":{\"1475\":1}}],[\"添加互斥锁\",{\"1\":{\"1283\":1}}],[\"添加自己需要的操作\",{\"1\":{\"1195\":1}}],[\"添加stringvalueresolver对象\",{\"1\":{\"1171\":1}}],[\"添加beanfactory所注册applicationlisteners\",{\"1\":{\"1170\":1}}],[\"添加beanpostprocesssor实现instantiationawarebeanpostprocessor\",{\"1\":{\"1005\":1,\"1006\":1,\"1011\":1}}],[\"添加beanpostprocesssor实现\",{\"1\":{\"1000\":1,\"1001\":1}}],[\"添加当前应用上下文所关联的applicationlisteners对象\",{\"1\":{\"1170\":1}}],[\"添加aware回调接口beanpostprocessor实现\",{\"1\":{\"1164\":1}}],[\"添加propertyedittorregistrar实现\",{\"1\":{\"1164\":1}}],[\"添加propertysources操作必须在refresh方法之前完成\",{\"1\":{\"1031\":1}}],[\"添加活跃的profiles\",{\"1\":{\"1139\":1}}],[\"添加到的最终的结果thelist1当中\",{\"1\":{\"1608\":1}}],[\"添加到\",{\"1\":{\"1138\":2}}],[\"添加contextclosedevent事件处理\",{\"1\":{\"1123\":1}}],[\"添加观察者\",{\"1\":{\"1108\":1}}],[\"添加\",{\"1\":{\"1049\":1}}],[\"添加mydestructionawarebeanpostprocessor执行销毁前回调\",{\"1\":{\"1011\":1}}],[\"添加新的注解\",{\"1\":{\"967\":1}}],[\"添加元素和获取元素都有独立的锁\",{\"1\":{\"1503\":1}}],[\"添加元素效率的对比\",{\"1\":{\"1475\":1}}],[\"添加元素\",{\"1\":{\"577\":1}}],[\"添加指定元素到\",{\"1\":{\"577\":1}}],[\"添加参数gtid\",{\"1\":{\"468\":1}}],[\"添加索引\",{\"1\":{\"441\":1}}],[\"添加文档\",{\"1\":{\"306\":1}}],[\"添加示例数据\",{\"1\":{\"306\":1}}],[\"额外辅助\",{\"1\":{\"1649\":1}}],[\"额外的故意等待\",{\"1\":{\"451\":1}}],[\"框架之一\",{\"1\":{\"1982\":1}}],[\"框架的组成结构图如下所示\",{\"1\":{\"1982\":1}}],[\"框架的核心特性是依赖注入\",{\"1\":{\"1982\":1}}],[\"框架的这种修改可能出现这些不确定的结果\",{\"1\":{\"1620\":1}}],[\"框架了\",{\"1\":{\"1979\":1}}],[\"框架\",{\"1\":{\"1979\":3,\"1990\":1}}],[\"框架源码分析\",{\"0\":{\"1628\":1}}],[\"阶段\",{\"1\":{\"1621\":1}}],[\"抛出illegalstateexception异常\",{\"1\":{\"1620\":1}}],[\"抛出异常\",{\"1\":{\"309\":1,\"1501\":2,\"1655\":1}}],[\"剩余的元素是由当前的spliterator继续涵盖的\",{\"1\":{\"1620\":1}}],[\"剩下的题目可以在每天开始学其他内容之前\",{\"1\":{\"1972\":1}}],[\"剩下的数据何时才应该续写\",{\"1\":{\"603\":1}}],[\"剩下的操作都是在sort\",{\"1\":{\"355\":1}}],[\"知识点非常丰富\",{\"1\":{\"1975\":1}}],[\"知识点剖析细致\",{\"1\":{\"1969\":1}}],[\"知识储备\",{\"0\":{\"737\":1}}],[\"知道所有的元素都已经被处理了\",{\"1\":{\"1620\":1}}],[\"太小了\",{\"1\":{\"1620\":1}}],[\"太少的线程数会使得程序整体性能降低\",{\"1\":{\"1510\":1}}],[\"块的遍历方法\",{\"1\":{\"1620\":1}}],[\"期望可以文档化\",{\"1\":{\"1620\":1}}],[\"期望将\",{\"1\":{\"1554\":1}}],[\"固定大小\",{\"1\":{\"1620\":1}}],[\"固定生成连续的id的值\",{\"1\":{\"492\":1}}],[\"遵循stream的相关约束\",{\"1\":{\"1619\":1}}],[\"遵循获取写锁\",{\"1\":{\"1498\":1}}],[\"偶发的情况下就会出现并发修改的异常\",{\"1\":{\"1617\":1}}],[\"毫无疑问\",{\"1\":{\"1615\":1}}],[\"拥有国际化功能\",{\"1\":{\"1637\":1}}],[\"拥有广播事件的功能\",{\"1\":{\"1637\":1}}],[\"拥有获取beannames的功能\",{\"1\":{\"1637\":1}}],[\"拥有获取父beanfactory的功能\",{\"1\":{\"1637\":1}}],[\"拥有了自动装配的功能\",{\"1\":{\"1636\":1}}],[\"拥有了直接注册\",{\"1\":{\"1636\":1}}],[\"拥有唯一的抽象方法compare\",{\"1\":{\"1614\":1}}],[\"拥有thread的workqueue只能出现在workqueues\",{\"1\":{\"1513\":1}}],[\"达到基本不怎么用思考\",{\"1\":{\"1972\":1}}],[\"达到该值就会触发full\",{\"1\":{\"1664\":1}}],[\"达到相互促进的作用\",{\"1\":{\"1613\":1}}],[\"达到上限后\",{\"1\":{\"495\":1}}],[\"学好前五阶段的技术知识\",{\"1\":{\"1988\":1}}],[\"学生\",{\"1\":{\"1974\":1}}],[\"学生管理系统这样的小项目了\",{\"1\":{\"1969\":1}}],[\"学完了这些\",{\"1\":{\"1987\":1}}],[\"学完上面的内容\",{\"1\":{\"1984\":1}}],[\"学完基本知识之后\",{\"1\":{\"1974\":1}}],[\"学完\",{\"1\":{\"1970\":1}}],[\"学\",{\"1\":{\"1969\":1}}],[\"学习多线程\",{\"1\":{\"1992\":1}}],[\"学习些基本的linux命令是必不可少的\",{\"1\":{\"1987\":1}}],[\"学习\",{\"1\":{\"1983\":1}}],[\"学习ssm框架\",{\"1\":{\"1982\":1}}],[\"学习这些框架之前\",{\"1\":{\"1979\":1}}],[\"学习这些就可以了\",{\"1\":{\"1977\":1}}],[\"学习这些例子\",{\"1\":{\"1618\":1}}],[\"学习了这部分\",{\"1\":{\"1969\":1}}],[\"学习路线概览\",{\"0\":{\"1968\":1}}],[\"学习jdk中优秀的源码\",{\"1\":{\"1613\":1}}],[\"学会前面这些\",{\"1\":{\"1992\":1}}],[\"学会了\",{\"1\":{\"1981\":1}}],[\"学会使用是第一步也是非常重要的一步\",{\"1\":{\"1613\":1}}],[\"学会新的api使用\",{\"1\":{\"1607\":1}}],[\"掌握本章及之前的内容对于一般的开发者\",{\"1\":{\"1613\":1}}],[\"掌握其中一门的设计理念与思想\",{\"1\":{\"1591\":1}}],[\"种子\",{\"1\":{\"1609\":1}}],[\"种连接顺序\",{\"1\":{\"556\":1}}],[\"举个例子\",{\"1\":{\"1609\":2,\"1619\":1}}],[\"举一个这样的例子\",{\"1\":{\"1609\":1}}],[\"举例说明\",{\"1\":{\"1138\":1}}],[\"举例\",{\"1\":{\"946\":1}}],[\"举例装饰器模式和代理模式的区别\",{\"0\":{\"854\":1}}],[\"举例来说\",{\"1\":{\"490\":1}}],[\"及早求值\",{\"1\":{\"1607\":1}}],[\"惰性求值\",{\"1\":{\"1607\":1}}],[\"恰好满足了lambda表达式的要求\",{\"1\":{\"1603\":1}}],[\"叫做方法引用\",{\"1\":{\"1602\":1}}],[\"叫做浮动垃圾\",{\"1\":{\"1447\":1}}],[\"断言的意思\",{\"1\":{\"1599\":1}}],[\"断开连接四次挥手\",{\"1\":{\"1420\":1}}],[\"断开连接\",{\"1\":{\"318\":1}}],[\"阐明\",{\"1\":{\"1599\":1}}],[\"四则运算正好就是输入两个参数\",{\"1\":{\"1598\":1}}],[\"四种线程同步互斥的控制方法\",{\"1\":{\"1477\":1}}],[\"箭头左边的部分\",{\"1\":{\"1595\":1}}],[\"诸多的函数式接口\",{\"1\":{\"1594\":1}}],[\"诸如存储引擎的锁\",{\"1\":{\"388\":1}}],[\"追踪下去\",{\"1\":{\"1593\":1}}],[\"追加写\",{\"1\":{\"325\":1,\"327\":1}}],[\"获得消耗的时间\",{\"1\":{\"1591\":2}}],[\"获取请求网络字节流\",{\"1\":{\"1687\":1}}],[\"获取给定包路径下面的class文件的resource对象\",{\"1\":{\"1647\":1}}],[\"获取一个annotationmetadata\",{\"1\":{\"1646\":1}}],[\"获取某个单例bean的功能\",{\"1\":{\"1636\":1}}],[\"获取某个单例bean\",{\"1\":{\"1636\":1}}],[\"获取某个beandefinition\",{\"1\":{\"1636\":1}}],[\"获取环境变量等功能\",{\"1\":{\"1636\":1}}],[\"获取执行后的毫秒值\",{\"1\":{\"1591\":2}}],[\"获取执行前的毫秒值\",{\"1\":{\"1591\":2}}],[\"获取最快返回的任务执行结果\",{\"1\":{\"1517\":1}}],[\"获取电商s2报价并异步保存\",{\"1\":{\"1517\":1}}],[\"获取电商s1报价并异步保存\",{\"1\":{\"1517\":1}}],[\"获取队首元素\",{\"1\":{\"1500\":1,\"1501\":1}}],[\"获取写锁\",{\"1\":{\"1498\":1}}],[\"获取了写锁并修改了数据\",{\"1\":{\"1498\":1}}],[\"获取静态变量i的值\",{\"1\":{\"1482\":2}}],[\"获取元素的线程会等待队列变为非空\",{\"1\":{\"1395\":1}}],[\"获取到线程执行的返回值\",{\"1\":{\"1377\":1}}],[\"获取到users字段的map的泛型信息\",{\"1\":{\"963\":1}}],[\"获取私有构造方法\",{\"1\":{\"1351\":1}}],[\"获取私有属性\",{\"1\":{\"1351\":1}}],[\"获取锁上的时间戳\",{\"1\":{\"1288\":1}}],[\"获取数据的时候加锁\",{\"1\":{\"1248\":1}}],[\"获取早期未处理bean\",{\"1\":{\"1184\":1}}],[\"获取mutablepropertysources\",{\"1\":{\"1156\":1}}],[\"获取messagesource对象\",{\"1\":{\"957\":1,\"1064\":1}}],[\"获取\",{\"1\":{\"1147\":1,\"1655\":1}}],[\"获取泛型参数类型\",{\"1\":{\"1103\":1}}],[\"获取raw\",{\"1\":{\"1103\":1}}],[\"获取临时properties对象\",{\"1\":{\"1082\":1,\"1084\":1}}],[\"获取类型转换后的对象\",{\"1\":{\"1082\":1}}],[\"获取绑定结果\",{\"1\":{\"1072\":1}}],[\"获取errors对象中objecterror或fielderror\",{\"1\":{\"1063\":1}}],[\"获取environment对象\",{\"1\":{\"957\":1,\"1139\":1}}],[\"获取enviroment类型的bean\",{\"1\":{\"919\":1}}],[\"获取user\",{\"1\":{\"1030\":1,\"1032\":1}}],[\"获取applicationeventmulticaster\",{\"1\":{\"1115\":1}}],[\"获取applicationeventpublisher\",{\"1\":{\"1115\":1}}],[\"获取applicationeventpublishaware对象\",{\"1\":{\"957\":1}}],[\"获取abstractbeandefinition\",{\"1\":{\"1019\":1}}],[\"获取当前bean名称\",{\"1\":{\"957\":1}}],[\"获取加载当前bean\",{\"1\":{\"957\":1}}],[\"获取资源加载器对象\",{\"1\":{\"957\":1}}],[\"获取ioc容器\",{\"1\":{\"957\":1}}],[\"获取指定名称\",{\"1\":{\"941\":1}}],[\"获取标注类型bean实例列表\",{\"1\":{\"941\":1}}],[\"获取标注类型bean名称列表\",{\"1\":{\"941\":1}}],[\"获取同类型bean实例列表\",{\"1\":{\"941\":1}}],[\"获取beandefinition实例\",{\"1\":{\"927\":1}}],[\"获取连接对象\",{\"1\":{\"583\":1}}],[\"获取第2位的数值\",{\"1\":{\"578\":1}}],[\"获取offset位的值\",{\"1\":{\"578\":1}}],[\"获取成员经纬坐标的geohash表示\",{\"1\":{\"576\":1}}],[\"获取成员m1的索引\",{\"1\":{\"574\":1}}],[\"获取成员m1的score\",{\"1\":{\"574\":1}}],[\"获取全部成员\",{\"1\":{\"574\":1}}],[\"获取全部元素\",{\"1\":{\"571\":1}}],[\"获取索引在\",{\"1\":{\"574\":1}}],[\"获取spring\",{\"1\":{\"1655\":1}}],[\"获取spring应用上下文\",{\"1\":{\"957\":1}}],[\"获取stringvalueresolver对象\",{\"1\":{\"957\":1}}],[\"获取studentx中所有的field及其value\",{\"1\":{\"573\":1}}],[\"获取studentx中name\",{\"1\":{\"573\":1}}],[\"获取studentx中name字段的value\",{\"1\":{\"573\":1}}],[\"获取score在\",{\"1\":{\"574\":1}}],[\"获取有序集合的成员数\",{\"1\":{\"574\":2}}],[\"获取哈希表中所有值\",{\"1\":{\"573\":1}}],[\"获取哈希表中字段的数量\",{\"1\":{\"573\":1}}],[\"获取哈希表key中所有的字段\",{\"1\":{\"573\":1}}],[\"获取在哈希表key\",{\"1\":{\"573\":1}}],[\"获取所有给定字段的值\",{\"1\":{\"573\":1}}],[\"获取存储在哈希表中指定字段的值\",{\"1\":{\"573\":1}}],[\"获取集合中的一个\",{\"1\":{\"576\":1}}],[\"获取集合中所有成员\",{\"1\":{\"572\":1}}],[\"获取集合的成员数目\",{\"1\":{\"572\":1}}],[\"获取集合的成员数\",{\"1\":{\"572\":1}}],[\"获取下标为3的元素\",{\"1\":{\"571\":1}}],[\"获取起止位置范围内的元素\",{\"1\":{\"571\":1}}],[\"获取list\",{\"1\":{\"571\":1}}],[\"获取原来的值\",{\"1\":{\"570\":1}}],[\"获取key保存值的字符串长度\",{\"1\":{\"570\":1}}],[\"获取活跃事务id列表\",{\"1\":{\"542\":1}}],[\"获取表t当前的自增值2\",{\"1\":{\"491\":1}}],[\"获取表t2中满足条件的2000行数据\",{\"1\":{\"408\":1}}],[\"获取把一个表的主键删掉了\",{\"1\":{\"420\":1}}],[\"获取超过需要的数据也可能有其好处\",{\"1\":{\"385\":1}}],[\"获取权限\",{\"1\":{\"318\":1,\"482\":1}}],[\"获取文档映射\",{\"1\":{\"309\":1}}],[\"获取物理内存容量\",{\"0\":{\"292\":1}}],[\"瞬间代码的易读性提高了很多\",{\"1\":{\"1591\":1}}],[\"缓冲区之间建立管道来传输数据\",{\"1\":{\"1584\":1}}],[\"缓存好的构造方法和参数值\",{\"1\":{\"1650\":1}}],[\"缓存beandefition的属性\",{\"1\":{\"1650\":1}}],[\"缓存行是2的整数幂个连续字节\",{\"1\":{\"1519\":1}}],[\"缓存一致性的要求\",{\"1\":{\"1474\":1}}],[\"缓存一致性是确保共享操作数\",{\"1\":{\"1474\":1}}],[\"缓存一致性是共享资源数据的一致性\",{\"1\":{\"1474\":1}}],[\"缓存一致性\",{\"0\":{\"1474\":1}}],[\"缓存锁定将大大降低lock前缀指令的执行开销\",{\"1\":{\"1473\":1}}],[\"缓存导致的可见性问题\",{\"1\":{\"1373\":1}}],[\"缓存hashcode\",{\"1\":{\"1342\":1}}],[\"缓存数据不会更新\",{\"1\":{\"1287\":1}}],[\"缓存删除失败\",{\"1\":{\"1287\":1}}],[\"缓存大面积过期\",{\"1\":{\"1284\":1}}],[\"缓存中没有\",{\"1\":{\"1283\":1}}],[\"缓存中查不到\",{\"1\":{\"1282\":1}}],[\"缓存中的应用\",{\"0\":{\"862\":1}}],[\"缓存的容量可扩展等\",{\"1\":{\"1219\":1}}],[\"缓存位置\",{\"1\":{\"1182\":1}}],[\"缓存\",{\"1\":{\"1138\":1}}],[\"缓存设计\",{\"1\":{\"1052\":1}}],[\"缓存抽象\",{\"1\":{\"895\":1}}],[\"缓存空对象\",{\"1\":{\"627\":1}}],[\"缓存都没有命中的话\",{\"1\":{\"626\":1}}],[\"缓存系统可能会丢失更新\",{\"1\":{\"397\":1}}],[\"缓存穿透\",{\"0\":{\"130\":1,\"625\":1,\"1282\":1},\"1\":{\"1282\":1}}],[\"缓存雪崩\",{\"0\":{\"129\":1,\"132\":1,\"631\":1,\"1281\":1,\"1284\":1},\"1\":{\"1284\":1}}],[\"缓存击穿的目的性更强\",{\"1\":{\"629\":1}}],[\"缓存击穿\",{\"0\":{\"129\":1,\"131\":1,\"628\":1,\"1281\":1,\"1283\":1},\"1\":{\"1283\":1}}],[\"次数据拷贝都是\",{\"1\":{\"1583\":1}}],[\"次用户态和内核态的切换\",{\"1\":{\"1582\":1,\"1583\":1,\"1584\":1}}],[\"次\",{\"1\":{\"1582\":2,\"1583\":2,\"1584\":2}}],[\"站在操作系统的角度\",{\"1\":{\"1576\":1}}],[\"站内搜索\",{\"1\":{\"301\":1}}],[\"零基础java学习路线\",{\"1\":{\"1993\":1}}],[\"零个或多个中间操作\",{\"1\":{\"1607\":1}}],[\"零\",{\"1\":{\"1576\":1}}],[\"零拷贝所有的方式\",{\"1\":{\"1585\":1}}],[\"零拷贝流程\",{\"0\":{\"1584\":1}}],[\"零拷贝并不是不需要拷贝数据\",{\"1\":{\"1576\":1}}],[\"零拷贝就是不需要将数据从一个存储区域复制到另一个存储区域\",{\"1\":{\"1576\":1}}],[\"零拷贝从字面上来看包含两个意思\",{\"1\":{\"1576\":1}}],[\"零拷贝主要体现在\",{\"1\":{\"1231\":1}}],[\"零拷贝是指计算机执行操作时\",{\"1\":{\"1231\":1}}],[\"零拷贝实现原理\",{\"0\":{\"694\":1}}],[\"零拷贝\",{\"0\":{\"692\":1},\"1\":{\"1331\":2}}],[\"差\",{\"1\":{\"1576\":1}}],[\"差值\",{\"1\":{\"354\":1}}],[\"程序员来说\",{\"1\":{\"1970\":1}}],[\"程序员友好程度\",{\"1\":{\"1576\":1}}],[\"程序计数器\",{\"0\":{\"1702\":1}}],[\"程序运行过程中\",{\"1\":{\"1664\":1}}],[\"程序运行的结果如下\",{\"1\":{\"1617\":1}}],[\"程序运行的效果是完全等价的\",{\"1\":{\"1595\":1}}],[\"程序不再往下执行\",{\"1\":{\"1620\":1}}],[\"程序将一直运行下去\",{\"1\":{\"1609\":1}}],[\"程序中有一个全局变量扫描到了哪个数据库\",{\"1\":{\"1289\":1}}],[\"伪代码可能是这样的\",{\"1\":{\"1611\":1}}],[\"伪异步i\",{\"1\":{\"1576\":1}}],[\"伪共享\",{\"1\":{\"1519\":3}}],[\"真实io\",{\"1\":{\"1567\":2}}],[\"真正执行的时候\",{\"1\":{\"1654\":1}}],[\"真正执行传入lambda表达式的地方\",{\"1\":{\"1622\":1}}],[\"真正使用该代理对象时才进行类型筛选bean\",{\"1\":{\"1648\":1}}],[\"真正在创建的时候又是调用了referencepipeline的构造方法\",{\"1\":{\"1621\":1}}],[\"真正的零拷贝\",{\"1\":{\"1585\":2}}],[\"真正唤醒消费者线程\",{\"1\":{\"1503\":2}}],[\"真正唤醒生产者线程\",{\"1\":{\"1503\":1}}],[\"真正模拟主库并发度\",{\"1\":{\"464\":1}}],[\"真正更新日志的\",{\"1\":{\"460\":1}}],[\"告诉它read操作完成了\",{\"1\":{\"1566\":1}}],[\"告警等要求就会变得非常困难\",{\"1\":{\"1304\":1}}],[\"立刻就可以开始去做其它的事\",{\"1\":{\"1566\":1}}],[\"句柄\",{\"1\":{\"1561\":1}}],[\"句柄是资源在创建过程中由windows赋予的\",{\"1\":{\"1561\":1}}],[\"杏花村\",{\"1\":{\"1561\":2}}],[\"杏花村可以搬家\",{\"1\":{\"1561\":1}}],[\"杏花村酒店为对象的实例\",{\"1\":{\"1561\":1}}],[\"杏花村的牌子为句柄\",{\"1\":{\"1561\":1}}],[\"牧童的手为指针\",{\"1\":{\"1561\":1}}],[\"抢到了锁\",{\"1\":{\"1554\":1}}],[\"冲突就会大于1\",{\"1\":{\"1554\":1}}],[\"冲突\",{\"1\":{\"1554\":1}}],[\"懒加载的方式\",{\"1\":{\"1554\":1}}],[\"懒汉式删除\",{\"1\":{\"1289\":1}}],[\"懒汉式\",{\"0\":{\"267\":1,\"1191\":1}}],[\"旧链表迁移新链表的时候\",{\"1\":{\"1550\":1}}],[\"旧值\",{\"1\":{\"1286\":1}}],[\"均匀的把之前的冲突节点分散到新的bucket了\",{\"1\":{\"1550\":1}}],[\"均匀存放数据\",{\"1\":{\"1270\":1}}],[\"红色\",{\"1\":{\"1550\":1}}],[\"红黑发布\",{\"1\":{\"1310\":1}}],[\"红黑树是为了解决当哈希冲突比较多的时候\",{\"1\":{\"1475\":1}}],[\"红黑树来实现\",{\"1\":{\"1475\":1}}],[\"红黑树可以很好的满足范围查询\",{\"1\":{\"1265\":1}}],[\"红黑树\",{\"1\":{\"501\":1,\"1359\":1,\"1423\":1}}],[\"质量来考虑的\",{\"1\":{\"1548\":1}}],[\"功效\",{\"1\":{\"1548\":1}}],[\"功能\",{\"1\":{\"1509\":1,\"1693\":1}}],[\"功能比较单一\",{\"1\":{\"1327\":1}}],[\"功能非常全面\",{\"1\":{\"1327\":1}}],[\"功能全面\",{\"1\":{\"1327\":1}}],[\"功能概述\",{\"0\":{\"752\":1}}],[\"功能与georadius相同\",{\"1\":{\"576\":1}}],[\"^\",{\"1\":{\"1548\":3}}],[\"挂起模式\",{\"1\":{\"1530\":1}}],[\"挂起操作涉及系统调用\",{\"1\":{\"1485\":1}}],[\"路线的全部内容了\",{\"1\":{\"1993\":1}}],[\"路由表是典型的读多写少\",{\"1\":{\"1527\":1}}],[\"路径匹配器\",{\"1\":{\"1042\":1}}],[\"研发的初衷是为了解决内存队列的延迟问题\",{\"1\":{\"1519\":1}}],[\"规范整体框架\",{\"1\":{\"1659\":1}}],[\"规则以及方式\",{\"1\":{\"1518\":1}}],[\"规定两个库的server\",{\"1\":{\"455\":1}}],[\"借助这项能力\",{\"1\":{\"1518\":1}}],[\"充分地利用空闲线程\",{\"1\":{\"1514\":1}}],[\"充血模型\",{\"1\":{\"1309\":1}}],[\"压缩\",{\"1\":{\"1510\":1}}],[\"压力骤增\",{\"1\":{\"629\":1,\"632\":1}}],[\"肯定不为空了\",{\"1\":{\"1502\":1}}],[\"肯定要加锁\",{\"1\":{\"491\":1}}],[\"环形链表就这样出现了\",{\"1\":{\"1551\":1}}],[\"环形数组结构\",{\"1\":{\"1519\":1}}],[\"环形数组\",{\"1\":{\"1502\":2}}],[\"环境变量配置属性源\",{\"1\":{\"1154\":1}}],[\"环境配置\",{\"0\":{\"609\":1}}],[\"出队方法\",{\"1\":{\"1503\":1}}],[\"出队操作\",{\"1\":{\"1502\":1}}],[\"出队\",{\"1\":{\"1501\":3,\"1502\":1,\"1503\":1}}],[\"出现重复的注解修饰的方法\",{\"1\":{\"1654\":1}}],[\"出现线程安全问题的原因\",{\"1\":{\"1373\":1}}],[\"出现这种情况的线程会飙高cpu\",{\"1\":{\"605\":1}}],[\"出现了自增主键不连续的情况\",{\"1\":{\"491\":1}}],[\"出现了两次\",{\"1\":{\"462\":1}}],[\"出现的次数返回给用户\",{\"1\":{\"299\":1}}],[\"俗称\",{\"1\":{\"1979\":1}}],[\"俗称信号量\",{\"1\":{\"1496\":1}}],[\"俗话说\",{\"1\":{\"483\":1}}],[\"唤醒生产者线程\",{\"1\":{\"1502\":1}}],[\"唤醒消费者线程\",{\"1\":{\"1502\":1}}],[\"唤醒之后这个线程就可以去竞争锁了\",{\"1\":{\"1493\":1}}],[\"唤醒时间和获取到锁继续执行的时间是不一致的\",{\"1\":{\"1483\":1}}],[\"公平选择性\",{\"1\":{\"1498\":1}}],[\"公平和非公平\",{\"1\":{\"1494\":1}}],[\"公平锁\",{\"1\":{\"1491\":1}}],[\"公平\",{\"1\":{\"1490\":1,\"1502\":1}}],[\"公众号订阅\",{\"1\":{\"601\":1}}],[\"独立完成项目组分配给你的开发任务\",{\"1\":{\"1992\":1}}],[\"独占锁\",{\"1\":{\"1496\":1}}],[\"独占\",{\"1\":{\"1490\":2}}],[\"独占获取\",{\"1\":{\"1490\":1}}],[\"独去其他事务已经提交的数据\",{\"1\":{\"1238\":1}}],[\"逃逸分析分为方法逃逸和线程逃逸\",{\"1\":{\"1488\":1}}],[\"逃逸分析的基本行为就是分析对象动态作用域\",{\"1\":{\"1488\":1}}],[\"逃逸分析\",{\"0\":{\"1488\":1},\"1\":{\"1488\":1}}],[\"繁殖\",{\"1\":{\"1485\":1}}],[\"剥夺了该类的新实例对象使用偏向锁的权利\",{\"1\":{\"1485\":1}}],[\"撤销次数清0\",{\"1\":{\"1485\":1}}],[\"倘若偏向锁失败\",{\"1\":{\"1485\":1}}],[\"启用偏向锁\",{\"1\":{\"1485\":1}}],[\"启动类加载器\",{\"1\":{\"1691\":1}}],[\"启动核心api\",{\"1\":{\"1658\":1}}],[\"启动过程的完整代码\",{\"1\":{\"1651\":1}}],[\"启动disruptor\",{\"1\":{\"1521\":1}}],[\"启动一个该thread\",{\"1\":{\"1513\":1}}],[\"启动时加载\",{\"1\":{\"1658\":1}}],[\"启动时将每个指令与对应汇编代码入口绑定\",{\"1\":{\"1473\":1}}],[\"启动时间\",{\"1\":{\"1162\":1}}],[\"启动阶段\",{\"1\":{\"1177\":1}}],[\"启动应用上下文\",{\"1\":{\"1174\":1}}],[\"启动\",{\"1\":{\"1174\":1,\"1184\":1}}],[\"启动lifecycle\",{\"1\":{\"1173\":1}}],[\"启动lifecycleprocessor\",{\"1\":{\"1173\":1}}],[\"启动spring应用上下文\",{\"1\":{\"917\":1,\"918\":1,\"919\":1}}],[\"启动详情\",{\"0\":{\"876\":1}}],[\"启动执行流程\",{\"0\":{\"874\":1}}],[\"启动单机多服务集群\",{\"1\":{\"609\":1}}],[\"启动优先级\",{\"1\":{\"595\":1}}],[\"启动了事务trx1\",{\"1\":{\"476\":1}}],[\"禁止偏向锁\",{\"1\":{\"1485\":1}}],[\"禁止该指令与前面和后面的读写指令重排序\",{\"1\":{\"1473\":1}}],[\"填充属性\",{\"1\":{\"1647\":1}}],[\"填充数据不是必须存在的\",{\"1\":{\"1484\":1}}],[\"填入\",{\"1\":{\"1002\":1}}],[\"称之为发生了竞态条件\",{\"1\":{\"1482\":1}}],[\"称为中转日志\",{\"1\":{\"453\":1}}],[\"称为死锁\",{\"1\":{\"444\":1}}],[\"称为sort\",{\"1\":{\"354\":1}}],[\"称为bin\",{\"1\":{\"325\":1}}],[\"竞态条件下\",{\"1\":{\"1480\":1}}],[\"架构实现\",{\"0\":{\"1957\":1}}],[\"架构设计\",{\"0\":{\"1842\":1}}],[\"架构中的\",{\"1\":{\"1479\":2}}],[\"架构中的一个原子条件指令\",{\"1\":{\"1479\":1}}],[\"架构及\",{\"1\":{\"1479\":1}}],[\"休眠状态和终止状态\",{\"1\":{\"1477\":1}}],[\"休眠一小会\",{\"1\":{\"1286\":1}}],[\"套接字描述符\",{\"1\":{\"1565\":1}}],[\"套接字\",{\"1\":{\"1477\":1}}],[\"信号量\",{\"1\":{\"1477\":2}}],[\"信号\",{\"1\":{\"1477\":1}}],[\"信息描述符\",{\"1\":{\"1075\":1}}],[\"信息并不再阻塞父进程\",{\"1\":{\"588\":1}}],[\"信息状态只有\",{\"1\":{\"578\":1}}],[\"管程中引入了条件变量的概念\",{\"1\":{\"1483\":1}}],[\"管程是指管理共享变量以及对共享变量操作的过程\",{\"1\":{\"1483\":1}}],[\"管程\",{\"1\":{\"1483\":1}}],[\"管道被消费之后sourcespliterator就要设置为空\",{\"1\":{\"1621\":1}}],[\"管道的计算就会分成不同的段来执行\",{\"1\":{\"1621\":1}}],[\"管道的计算是在单个的过程中完成的\",{\"1\":{\"1621\":1}}],[\"管道类指的是流接口以及其原生特化的核心的实现\",{\"1\":{\"1621\":1}}],[\"管道输入输出流\",{\"1\":{\"1477\":1}}],[\"管道及有名管道\",{\"1\":{\"1477\":1}}],[\"管理profiles\",{\"1\":{\"1159\":1}}],[\"管理spring配置属性源\",{\"1\":{\"1159\":1}}],[\"管理应用代码\",{\"1\":{\"910\":1}}],[\"管理系统删除表的时候\",{\"1\":{\"487\":1}}],[\"拒绝方法\",{\"1\":{\"1476\":1}}],[\"拒绝策略\",{\"1\":{\"1410\":1,\"1476\":1}}],[\"尾插法\",{\"1\":{\"1475\":1}}],[\"尾部\",{\"1\":{\"571\":1}}],[\"尾部的空格会被去掉\",{\"1\":{\"530\":1}}],[\"头插法和尾插法的对比\",{\"1\":{\"1475\":1}}],[\"头插法\",{\"1\":{\"1475\":1}}],[\"头部\",{\"1\":{\"571\":1}}],[\"许多较大的系统\",{\"1\":{\"1474\":1}}],[\"许多应用程序可以方便地缓存单表查询对应的结果对象\",{\"1\":{\"394\":1}}],[\"汇聚阶段会消耗这个整型值并求出最大值\",{\"1\":{\"1623\":1}}],[\"汇聚\",{\"1\":{\"1623\":1}}],[\"汇编层面volatile的实现\",{\"1\":{\"1473\":1}}],[\"汇总后如下\",{\"1\":{\"447\":1}}],[\"汇总到一个mysql实例的一个表中\",{\"1\":{\"411\":1}}],[\"赋值\",{\"1\":{\"1473\":1}}],[\"载入\",{\"1\":{\"1473\":1}}],[\"释放了锁\",{\"1\":{\"1485\":1}}],[\"释放后的变量才可以被其他线程锁定\",{\"1\":{\"1473\":1}}],[\"释放锁\",{\"1\":{\"538\":1,\"542\":2}}],[\"难以调优\",{\"1\":{\"1457\":1}}],[\"远程过程调用\",{\"1\":{\"1990\":1}}],[\"远程控制\",{\"1\":{\"1454\":1}}],[\"远程调用\",{\"1\":{\"895\":1}}],[\"图\",{\"1\":{\"1550\":2}}],[\"图形化展示\",{\"1\":{\"1454\":1}}],[\"图中binlog备份系统到线上备库有一条虚线\",{\"1\":{\"485\":1}}],[\"图中备库上sql\",{\"1\":{\"460\":1}}],[\"图中两个黑色的箭头\",{\"1\":{\"460\":1}}],[\"图中sbm是seconds\",{\"1\":{\"458\":1}}],[\"图中session\",{\"1\":{\"410\":1}}],[\"图中模拟了6个\",{\"1\":{\"421\":1}}],[\"图中的fsync\",{\"1\":{\"450\":1}}],[\"图中的write\",{\"1\":{\"450\":1}}],[\"图中的pos指的是位置信息\",{\"1\":{\"420\":1}}],[\"图中的步骤4和5表示清空join\",{\"1\":{\"403\":1}}],[\"图中的两个虚线箭头\",{\"1\":{\"345\":1}}],[\"图中number\",{\"1\":{\"354\":1}}],[\"图中3和4\",{\"1\":{\"345\":1}}],[\"图中四个id\",{\"1\":{\"332\":1}}],[\"图中\",{\"1\":{\"332\":1,\"354\":1,\"368\":1,\"405\":1,\"466\":1,\"467\":1,\"479\":1}}],[\"３\",{\"1\":{\"1453\":1}}],[\"２\",{\"1\":{\"1453\":1}}],[\"１\",{\"1\":{\"1453\":1}}],[\"卡表\",{\"1\":{\"1449\":1}}],[\"卡顿等原因多次点击提交\",{\"1\":{\"1248\":1}}],[\"停顿预测模型\",{\"0\":{\"1747\":1}}],[\"停顿时间短\",{\"1\":{\"1449\":1}}],[\"停止线程\",{\"1\":{\"1477\":1}}],[\"停止阶段\",{\"1\":{\"1177\":1}}],[\"停止lifecycle\",{\"1\":{\"1174\":1,\"1175\":1}}],[\"停止lifecycleprocessor\",{\"1\":{\"1174\":1}}],[\"停止\",{\"1\":{\"481\":1,\"1174\":1}}],[\"废弃的常量和无用的类\",{\"1\":{\"1443\":1}}],[\"白色\",{\"1\":{\"1442\":1}}],[\"白名单\",{\"1\":{\"1072\":1}}],[\"灰色\",{\"1\":{\"1442\":1}}],[\"灰度发布\",{\"1\":{\"1310\":1}}],[\"黑色\",{\"1\":{\"1442\":1}}],[\"黑客就可以利用这个cookie信息进行攻击\",{\"1\":{\"1201\":1}}],[\"少了内存文件映射步骤\",{\"1\":{\"1585\":1}}],[\"少了用户缓冲区与内核缓冲区的数据拷贝\",{\"1\":{\"1585\":1}}],[\"少\",{\"1\":{\"1439\":2}}],[\"少用or\",{\"1\":{\"369\":1}}],[\"局部变量表\",{\"0\":{\"1800\":1},\"1\":{\"1664\":1}}],[\"局部变量方案的缺点是在高并发场景下会频繁创建对象\",{\"1\":{\"1528\":1}}],[\"局部变量\",{\"1\":{\"1438\":1}}],[\"局限二\",{\"1\":{\"1088\":1}}],[\"局限一\",{\"1\":{\"1088\":1}}],[\"譬如字符串常量池里的引用\",{\"1\":{\"1438\":1}}],[\"譬如java类的引用类型静态变量\",{\"1\":{\"1438\":1}}],[\"譬如各个线程被调用的方法堆栈中使用到的参数\",{\"1\":{\"1438\":1}}],[\"譬如我们希望描述一类对象\",{\"1\":{\"1435\":1}}],[\"幻影引用\",{\"1\":{\"1435\":1}}],[\"幻读的概念\",{\"1\":{\"1261\":1}}],[\"幻读的问题\",{\"0\":{\"447\":1}}],[\"幻读会带来一些问题\",{\"1\":{\"447\":1}}],[\"幻读专指\",{\"1\":{\"446\":1}}],[\"幻读在\",{\"1\":{\"446\":1}}],[\"幻读指的是一个事务在前后两次查询同一个范围的时候\",{\"1\":{\"446\":1}}],[\"幻读\",{\"0\":{\"152\":1,\"446\":1,\"1261\":1},\"1\":{\"433\":1,\"446\":1,\"532\":3,\"541\":1,\"1261\":2,\"1262\":1}}],[\"幽灵引用\",{\"1\":{\"1435\":1}}],[\"弱引用\",{\"1\":{\"1435\":1}}],[\"弱分代假说\",{\"1\":{\"1434\":1}}],[\"软件设计师\",{\"1\":{\"1966\":1}}],[\"软引用\",{\"1\":{\"1435\":1}}],[\"软考通\",{\"1\":{\"1\":1}}],[\"老师讲解的很清晰\",{\"1\":{\"1987\":1}}],[\"老师\",{\"1\":{\"1974\":1}}],[\"老年代\",{\"1\":{\"1441\":4}}],[\"老年代收集\",{\"1\":{\"1434\":1}}],[\"老版本和新版本是同时存在的\",{\"1\":{\"1310\":1}}],[\"熬过越多次收集过程的对象就越难以消亡\",{\"1\":{\"1434\":1}}],[\"视频\",{\"1\":{\"1981\":1,\"1990\":1}}],[\"视为对象的年龄\",{\"1\":{\"1434\":1}}],[\"视图解析器\",{\"1\":{\"1241\":1}}],[\"视图等\",{\"1\":{\"317\":1}}],[\"半初始化状态\",{\"1\":{\"1433\":1,\"1436\":1}}],[\"准确的说\",{\"1\":{\"1989\":1}}],[\"准确度确实提升了不少\",{\"1\":{\"472\":1}}],[\"准备一些资源\",{\"1\":{\"1651\":1}}],[\"准备数据\",{\"1\":{\"1563\":1}}],[\"准备唤醒阻塞在notfull上的线程\",{\"1\":{\"1503\":1}}],[\"准备唤醒阻塞在notempty上的线程\",{\"1\":{\"1503\":2}}],[\"准备唤醒一个阻塞在notfull条件上的线程\",{\"1\":{\"1503\":1}}],[\"准备唤醒生产者线程\",{\"1\":{\"1502\":1}}],[\"准备唤醒消费者线程\",{\"1\":{\"1502\":1}}],[\"准备\",{\"0\":{\"1788\":1},\"1\":{\"1433\":1,\"1663\":2}}],[\"验证\",{\"0\":{\"1787\":1},\"1\":{\"1433\":1,\"1663\":2}}],[\"卸载\",{\"1\":{\"1433\":1,\"1663\":1}}],[\"任意线程都会将元素提供给consumer\",{\"1\":{\"1623\":1}}],[\"任意一个任务执行完成\",{\"1\":{\"1518\":1}}],[\"任意时刻的查询结果是一致的\",{\"1\":{\"1238\":1}}],[\"任务名称\",{\"1\":{\"1535\":1}}],[\"任务队列\",{\"1\":{\"1535\":1}}],[\"任务\",{\"1\":{\"1520\":1,\"1535\":1}}],[\"任务合并\",{\"1\":{\"1518\":1}}],[\"任务窃取\",{\"1\":{\"1514\":1}}],[\"任务切分\",{\"1\":{\"1514\":1}}],[\"任务总数\",{\"1\":{\"1510\":1}}],[\"任务类型\",{\"1\":{\"1510\":1}}],[\"任务被放在了阻塞队列中\",{\"1\":{\"1501\":1}}],[\"任何一个predicate会抛出异常的话\",{\"1\":{\"1599\":1}}],[\"任何一方执行close\",{\"1\":{\"1425\":1}}],[\"任何时刻最多只允许一个线程去使用\",{\"1\":{\"1477\":1}}],[\"证书不免费\",{\"1\":{\"1424\":1}}],[\"受限于内核\",{\"1\":{\"1423\":1}}],[\"激活socket\",{\"1\":{\"1423\":1}}],[\"激活spring异步特性\",{\"1\":{\"1123\":1}}],[\"激活spring\",{\"1\":{\"1020\":1}}],[\"激活spring注解驱动\",{\"1\":{\"1020\":1}}],[\"形成肌肉记忆\",{\"1\":{\"1972\":1}}],[\"形成另外的spliterator\",{\"1\":{\"1620\":1}}],[\"形成一个循环\",{\"1\":{\"1575\":1}}],[\"形成全局事务id\",{\"1\":{\"1310\":1}}],[\"形式上是一个整数\",{\"1\":{\"1423\":1}}],[\"轻操作\",{\"1\":{\"1421\":1}}],[\"轻量级锁所适应的场景是线程交替执行同步块的场合\",{\"1\":{\"1485\":1}}],[\"轻量级锁\",{\"0\":{\"68\":1,\"1397\":1,\"1823\":1},\"1\":{\"1397\":2,\"1483\":1,\"1484\":1}}],[\"点赞\",{\"1\":{\"1987\":1}}],[\"点击foreach方法\",{\"1\":{\"1595\":1}}],[\"点击这个注解进入\",{\"1\":{\"1594\":1}}],[\"点击箭头就会进入到一个接口当中\",{\"1\":{\"1594\":1}}],[\"点击了这个图片\",{\"1\":{\"1201\":1}}],[\"点对点的通信\",{\"1\":{\"1419\":1}}],[\"私有化\",{\"1\":{\"1406\":1}}],[\"队列又太小\",{\"1\":{\"1536\":1}}],[\"队列没法设置特别大\",{\"1\":{\"1536\":1}}],[\"队列没满的时候是正常的插入\",{\"1\":{\"1501\":1}}],[\"队列堆满只是时间问题\",{\"1\":{\"1536\":1}}],[\"队列长度加1\",{\"1\":{\"1503\":1}}],[\"队列不满\",{\"1\":{\"1503\":1}}],[\"队列可以随着元素的添加而动态增长\",{\"1\":{\"1503\":1}}],[\"队列满了\",{\"1\":{\"1502\":1}}],[\"队列它还能起到一个隔离的作用\",{\"1\":{\"1501\":1}}],[\"队列\",{\"0\":{\"1833\":1},\"1\":{\"1501\":2}}],[\"队列里有数据会正常取出数据并删除\",{\"1\":{\"1501\":1}}],[\"队列为空则返回null\",{\"1\":{\"1500\":2}}],[\"队列为空则抛出异常\",{\"1\":{\"1500\":2}}],[\"队列同步器aqs\",{\"1\":{\"1400\":1}}],[\"队列是一种fifo先进先出的数据结构\",{\"1\":{\"1326\":1}}],[\"绝大数对象\",{\"1\":{\"1434\":1}}],[\"绝大部分spring使用场景\",{\"1\":{\"1129\":1}}],[\"绝对线程安全\",{\"1\":{\"1391\":1}}],[\"饿死也叫做无限延迟\",{\"1\":{\"1390\":1}}],[\"饿汉式\",{\"0\":{\"268\":1,\"1192\":1}}],[\"饥饿\",{\"1\":{\"1390\":1}}],[\"活锁\",{\"1\":{\"1389\":1}}],[\"守护线程可以理解为jvm自动创建的线程\",{\"1\":{\"1375\":1}}],[\"守护线程\",{\"1\":{\"1375\":1}}],[\"守护线程和用户线程的区别\",{\"0\":{\"46\":1,\"1375\":1}}],[\"泊松分布的示意图\",{\"1\":{\"1362\":1}}],[\"美团技术团队\",{\"1\":{\"1356\":1}}],[\"美事\",{\"1\":{\"389\":1}}],[\"浅拷贝\",{\"1\":{\"1344\":1}}],[\"浅析java设计模式\",{\"1\":{\"300\":1}}],[\"商业版本中提供了exactly\",{\"1\":{\"1333\":1}}],[\"商品发布后\",{\"1\":{\"471\":1}}],[\"商品类别\",{\"1\":{\"362\":1}}],[\"镜像集群会在节点之间主动进行数据同步\",{\"1\":{\"1328\":1}}],[\"镜像集群\",{\"1\":{\"1328\":1}}],[\"产品类型\",{\"1\":{\"1328\":2}}],[\"产生的代理对象一定是传入的接口的类型\",{\"1\":{\"1654\":1}}],[\"产生这个问题的原因是session\",{\"1\":{\"492\":1}}],[\"产生幻读的原因是\",{\"1\":{\"448\":1}}],[\"产生了using\",{\"1\":{\"378\":1}}],[\"产生了文件内排序\",{\"1\":{\"361\":1}}],[\"几乎所有的高级编程语言都支持了函数式编程的特性\",{\"1\":{\"1591\":1}}],[\"几乎起不到任何作用\",{\"1\":{\"1424\":1}}],[\"几乎是全场景\",{\"1\":{\"1327\":1}}],[\"几个重要统计信息项的值如下\",{\"1\":{\"558\":1}}],[\"几个表之间采用嵌套循环连接算法执行\",{\"1\":{\"555\":1}}],[\"吞吐量\",{\"1\":{\"1576\":1}}],[\"吞吐量和延迟并不重要的场景\",{\"1\":{\"1520\":1}}],[\"吞吐量还是非公平优于公平\",{\"1\":{\"1498\":1}}],[\"吞吐量也是最高的\",{\"1\":{\"1421\":1}}],[\"吞吐量比较高\",{\"1\":{\"1421\":1}}],[\"吞吐量比较低\",{\"1\":{\"1327\":1}}],[\"吞吐量低\",{\"1\":{\"1421\":1}}],[\"吞吐量非常大\",{\"1\":{\"1327\":1}}],[\"ｃ系统处理失败\",{\"1\":{\"1326\":1}}],[\"ｃ两个系统一同处理\",{\"1\":{\"1326\":1}}],[\"ａ系统发消息\",{\"1\":{\"1326\":1}}],[\"ｍｑ也有一些缺点\",{\"1\":{\"1326\":1}}],[\"ｍｑ有什么用\",{\"0\":{\"245\":1,\"1326\":1}}],[\"削峰\",{\"1\":{\"1326\":1,\"1985\":1}}],[\"熔断\",{\"1\":{\"1320\":1}}],[\"熔断和限流有什么区别\",{\"0\":{\"240\":1,\"1320\":1}}],[\"降低了我们开发的难度和工作量\",{\"1\":{\"1501\":1}}],[\"降低了开销\",{\"1\":{\"541\":1}}],[\"降低资源消耗\",{\"1\":{\"1407\":1}}],[\"降级\",{\"1\":{\"1320\":1}}],[\"金丝雀发布\",{\"1\":{\"1310\":1}}],[\"落地到日志文件\",{\"1\":{\"1310\":1}}],[\"落到其它分区的查询时不受影响的\",{\"1\":{\"424\":1}}],[\"领域优先的四层架构\",{\"1\":{\"1309\":1}}],[\"贫血失忆症\",{\"1\":{\"1309\":1}}],[\"贫血模型\",{\"1\":{\"1309\":1}}],[\"拆分微服务的时候\",{\"1\":{\"1308\":1}}],[\"拆分成1024个分表\",{\"1\":{\"411\":1}}],[\"门槛是很高的\",{\"1\":{\"1304\":1}}],[\"团队成员往往需要对系统的各个部分都要有深入的了解\",{\"1\":{\"1304\":1}}],[\"灵活选择技术栈\",{\"1\":{\"1304\":1}}],[\"耦合性降低\",{\"1\":{\"1304\":1}}],[\"纯内存操作\",{\"1\":{\"1292\":1}}],[\"始终只能保证一定时间内的最终一致性\",{\"1\":{\"1287\":1}}],[\"延时双删\",{\"1\":{\"1286\":1}}],[\"延迟队列\",{\"0\":{\"1838\":1}}],[\"延迟绑定会限制修改影响计算的时间间隔\",{\"1\":{\"1620\":1}}],[\"延迟绑定的spliterator会在元素第一次分割\",{\"1\":{\"1620\":1}}],[\"延迟绑定的\",{\"1\":{\"1620\":1}}],[\"延迟执行等\",{\"1\":{\"1509\":1}}],[\"延迟实例化\",{\"1\":{\"1194\":1}}],[\"延迟了实例化\",{\"1\":{\"1191\":1}}],[\"延迟依赖注入\",{\"0\":{\"962\":1}}],[\"延迟依赖查找\",{\"0\":{\"943\":1}}],[\"延迟初始化bean\",{\"0\":{\"932\":1}}],[\"延迟和非延迟\",{\"1\":{\"927\":1,\"975\":1}}],[\"延迟注入\",{\"1\":{\"918\":1,\"962\":1}}],[\"延迟查找\",{\"1\":{\"917\":4,\"1181\":1,\"1608\":1}}],[\"延迟复制的备库是一种特殊的备库\",{\"1\":{\"486\":1}}],[\"延迟复制备库\",{\"0\":{\"486\":1}}],[\"延迟的时间越小\",{\"1\":{\"459\":1}}],[\"脏数据\",{\"1\":{\"1286\":1}}],[\"脏读\",{\"1\":{\"532\":2,\"1261\":3}}],[\"补充一点\",{\"1\":{\"1987\":1}}],[\"补充\",{\"1\":{\"1277\":1}}],[\"跨平台\",{\"1\":{\"1966\":1}}],[\"跨代引用也就自然小时了\",{\"1\":{\"1434\":1}}],[\"跨代引用假说\",{\"1\":{\"1434\":1}}],[\"跨节点分页\",{\"1\":{\"1270\":1}}],[\"跨节点关联查询问题\",{\"1\":{\"1270\":1}}],[\"跨站请求伪造\",{\"1\":{\"1201\":1}}],[\"扩容大小2倍+1\",{\"1\":{\"1555\":1}}],[\"扩容时并未跳出死循环\",{\"1\":{\"1554\":1}}],[\"扩容前的数组大小如果已经达到最大\",{\"1\":{\"1550\":1}}],[\"扩容就是重新计算容量\",{\"1\":{\"1550\":1}}],[\"扩容机制\",{\"0\":{\"1550\":1}}],[\"扩容\",{\"1\":{\"1546\":1,\"1554\":1}}],[\"扩容的算法\",{\"1\":{\"1506\":1}}],[\"扩容了\",{\"1\":{\"1480\":1}}],[\"扩容因子\",{\"1\":{\"1475\":1}}],[\"扩容后的hashmap容量是之前容量的两倍\",{\"1\":{\"1546\":1}}],[\"扩容后\",{\"1\":{\"1359\":1}}],[\"扩容非常麻烦\",{\"1\":{\"1270\":1}}],[\"扩展类加载器\",{\"1\":{\"1663\":1,\"1691\":1}}],[\"扩展点\",{\"1\":{\"1657\":1}}],[\"扩展模块\",{\"1\":{\"1138\":1}}],[\"扩展模式\",{\"1\":{\"1084\":1}}],[\"扩展\",{\"1\":{\"1119\":1}}],[\"扩展接口\",{\"1\":{\"1112\":1}}],[\"扩展特性\",{\"1\":{\"1111\":1}}],[\"扩展实现\",{\"1\":{\"1093\":1}}],[\"扩展的步骤\",{\"1\":{\"1091\":1}}],[\"扩展spring类型转换器\",{\"0\":{\"1091\":1}}],[\"扩展java\",{\"1\":{\"1084\":1}}],[\"扩展原理\",{\"1\":{\"1082\":1}}],[\"扩展environment中的propertysources\",{\"1\":{\"1031\":1}}],[\"扩展内联混编\",{\"0\":{\"297\":1}}],[\"水平分片就是从数据角度将一个表中的数据拆分到不同的库或者表中\",{\"1\":{\"1270\":1}}],[\"垂直分片就是从业务角度将不同的表拆分到不同的表中\",{\"1\":{\"1270\":1}}],[\"跳表不适合范围查询\",{\"1\":{\"1265\":1}}],[\"跳过误操作的命令\",{\"1\":{\"486\":1}}],[\"跳过了表名自动补全的功能\",{\"1\":{\"482\":1}}],[\"跳过命令的写法是\",{\"1\":{\"467\":1}}],[\"级别越高\",{\"1\":{\"1262\":1}}],[\"级联更新的行不会记录在binlog中\",{\"1\":{\"462\":1}}],[\"五种线程模型对比\",{\"1\":{\"1567\":1}}],[\"五种隔离级别\",{\"1\":{\"1262\":1}}],[\"五态模型\",{\"1\":{\"1477\":1}}],[\"五大数据类型\",{\"0\":{\"568\":1}}],[\"映射成整型值\",{\"1\":{\"1623\":1}}],[\"映射阶段会消耗字符串集合\",{\"1\":{\"1623\":1}}],[\"映射\",{\"1\":{\"1608\":1,\"1623\":2,\"1658\":1}}],[\"映射mapping\",{\"1\":{\"1254\":1}}],[\"映射别名\",{\"1\":{\"1021\":1}}],[\"乐观锁又被称为无锁算法\",{\"1\":{\"1498\":1}}],[\"乐观锁的例子\",{\"1\":{\"1498\":1}}],[\"乐观锁\",{\"1\":{\"1248\":1,\"1399\":1}}],[\"悲观锁\",{\"1\":{\"1248\":1,\"1399\":1,\"1498\":1}}],[\"秒\",{\"1\":{\"1248\":1}}],[\"秒内如果至少有\",{\"1\":{\"587\":3}}],[\"考虑的是容量\",{\"1\":{\"1509\":1}}],[\"考虑锁等线程安全问题的重任从开发者转移到了\",{\"1\":{\"1501\":1}}],[\"考虑最坏的场景\",{\"1\":{\"1498\":1}}],[\"考虑将用户的信息\",{\"1\":{\"1248\":1}}],[\"考虑一些缓存cache\",{\"1\":{\"1248\":1}}],[\"考虑建立唯一索引\",{\"1\":{\"1248\":1}}],[\"考虑到切换过程中不能丢失数据\",{\"1\":{\"467\":1}}],[\"考虑到丢失日志量的可控性\",{\"1\":{\"450\":1}}],[\"考虑到树根的数据块总是在内存中的\",{\"1\":{\"334\":1}}],[\"订单接口\",{\"1\":{\"1248\":1}}],[\"订阅不同数量的topic\",{\"0\":{\"1869\":1}}],[\"订阅了不同tag\",{\"0\":{\"1868\":1}}],[\"订阅了不同的topic\",{\"0\":{\"1867\":1}}],[\"订阅关系的一致性\",{\"0\":{\"1864\":1}}],[\"订阅成功的消息\",{\"1\":{\"598\":1}}],[\"订阅sakura频道\",{\"1\":{\"598\":1}}],[\"订阅端\",{\"1\":{\"598\":1}}],[\"订阅给定的一个或多个频道\",{\"1\":{\"597\":1}}],[\"订阅一个或多个符合给定模式的频道\",{\"1\":{\"597\":1}}],[\"订阅者\",{\"1\":{\"596\":1}}],[\"幂等性\",{\"1\":{\"1248\":1}}],[\"渲染后\",{\"1\":{\"1241\":1}}],[\"绑定端口\",{\"1\":{\"1226\":1}}],[\"绑定字段黑名单\",{\"1\":{\"1072\":1}}],[\"绑定字段白名单\",{\"1\":{\"1072\":1}}],[\"尝试建立连接\",{\"1\":{\"1226\":1}}],[\"尝试获取解析\",{\"1\":{\"1022\":1}}],[\"辅助类\",{\"1\":{\"1226\":4}}],[\"辅助索引\",{\"1\":{\"519\":1}}],[\"号\",{\"1\":{\"1210\":1}}],[\"号称有十三种核心技术\",{\"1\":{\"273\":1}}],[\"他会将\",{\"1\":{\"1658\":1}}],[\"他也有可能返回自己\",{\"1\":{\"1619\":1}}],[\"他就永远不会主动解锁\",{\"1\":{\"1288\":1}}],[\"他就需要到授权服务器上去拍段令牌是否有效\",{\"1\":{\"1203\":1}}],[\"他的证书体系并不是完全安全的\",{\"1\":{\"1424\":1}}],[\"他的问题在于\",{\"1\":{\"1283\":1}}],[\"他的结果不受其他外在因素的影响\",{\"1\":{\"1262\":1}}],[\"他的最大优点是不需要在业务代码中添加事务管理的代码\",{\"1\":{\"1238\":1}}],[\"他的主要作用是负责监听网络事件并调用事件处理器进行相关i\",{\"1\":{\"1224\":1}}],[\"他自己就可以读取到令牌的授权信息\",{\"1\":{\"1203\":1}}],[\"他们的执行顺序是由一个比较器来决定的\",{\"1\":{\"1654\":1}}],[\"他们的传输协议不同\",{\"1\":{\"1424\":1}}],[\"他们并不需要特殊的资源管理\",{\"1\":{\"1619\":1}}],[\"他们必须是冲突非干扰的\",{\"1\":{\"1619\":1}}],[\"他们必须依附于一类特别的对象\",{\"1\":{\"1593\":1}}],[\"他们有一些相似性\",{\"1\":{\"1619\":1}}],[\"他们都被称之为stream\",{\"1\":{\"1619\":1}}],[\"他们都是在beanfactory赋值之前的回调操作\",{\"1\":{\"1003\":1}}],[\"他们可以使用相同的可以并发修改的结果容器\",{\"1\":{\"1615\":1}}],[\"他们可以看成是前面几个函数式接口的扩展\",{\"1\":{\"1600\":1}}],[\"他们包含了相同的元素\",{\"1\":{\"1615\":1}}],[\"他们是nio中多路复用的三种实现机制\",{\"1\":{\"1423\":1}}],[\"他们分别是\",{\"1\":{\"1133\":1}}],[\"银行就会受理到一个带了正确的cookie的请求\",{\"1\":{\"1201\":1}}],[\"攻击者就不容易伪造出请求\",{\"1\":{\"1201\":1}}],[\"攻击者在某个论坛或者网站上上传一个图片\",{\"1\":{\"1201\":1}}],[\"攻击过程\",{\"1\":{\"1201\":1}}],[\"问题出在多个线程访问共享资源\",{\"1\":{\"1482\":1}}],[\"问题\",{\"1\":{\"1200\":1,\"1287\":1,\"1288\":3,\"1479\":1}}],[\"问题的关键在于server层\",{\"1\":{\"424\":1}}],[\"授权码模式\",{\"1\":{\"1202\":1}}],[\"授权通常是在认证之后\",{\"1\":{\"1199\":1}}],[\"授权\",{\"1\":{\"1199\":1}}],[\"授权密码\",{\"1\":{\"624\":1}}],[\"刷题过程中\",{\"1\":{\"1972\":1}}],[\"刷脸\",{\"1\":{\"1199\":1}}],[\"刷新store\",{\"1\":{\"1473\":1}}],[\"刷新spring应用上下文底层beanfactory\",{\"1\":{\"1163\":1}}],[\"刷新阶段\",{\"1\":{\"1177\":1}}],[\"广度和深度都恰到好处\",{\"1\":{\"1969\":1}}],[\"广播模式\",{\"0\":{\"1891\":1,\"1898\":1}}],[\"广播消息\",{\"0\":{\"1831\":1}}],[\"广播早期spring事件\",{\"1\":{\"1170\":1}}],[\"广州白云\",{\"1\":{\"306\":1}}],[\"广州白云山公园\",{\"1\":{\"306\":1}}],[\"广州荔湾大厦\",{\"1\":{\"306\":1}}],[\"广州天河公园\",{\"1\":{\"306\":3}}],[\"忽略了顺序\",{\"1\":{\"1615\":1}}],[\"忽略了未知的属性\",{\"1\":{\"1072\":2}}],[\"忽略掉流中的前两个元素之后\",{\"1\":{\"1610\":1}}],[\"忽略aware回调接口作为依赖注入接口\",{\"1\":{\"1164\":1}}],[\"匹配\",{\"1\":{\"1147\":1}}],[\"紧接着定义需要注入的bean\",{\"1\":{\"1146\":1}}],[\"紧凑处理\",{\"1\":{\"354\":1}}],[\"帮助spring容器提供条件化地装配bean\",{\"1\":{\"1144\":1}}],[\"帮助实现复杂的初始化逻辑\",{\"1\":{\"925\":1}}],[\"源数据才会被消费\",{\"1\":{\"1621\":1}}],[\"源的意思就是要操作的数据对象\",{\"1\":{\"1607\":1}}],[\"源\",{\"1\":{\"1607\":1}}],[\"源码\",{\"1\":{\"1965\":1}}],[\"源码的实现如下\",{\"1\":{\"1548\":1}}],[\"源码导读\",{\"1\":{\"1143\":1}}],[\"源代码中也有体现\",{\"1\":{\"1005\":1}}],[\"驱动注解\",{\"1\":{\"1138\":1}}],[\"驱动表s2的扇出是321\",{\"1\":{\"555\":1}}],[\"驱动表和被驱动表的位置是可以互换的\",{\"1\":{\"555\":1}}],[\"驱动表扇出数\",{\"1\":{\"555\":1}}],[\"驱动表的扇出值也很明确\",{\"1\":{\"554\":1}}],[\"驱动表的数据行数是n\",{\"1\":{\"403\":1}}],[\"驱动表会被访问一次\",{\"1\":{\"554\":1}}],[\"驱动表是走全表扫描\",{\"1\":{\"401\":1}}],[\"早期未处理bean\",{\"1\":{\"1184\":1}}],[\"早期的spring\",{\"1\":{\"1122\":1}}],[\"早于setter注入\",{\"1\":{\"973\":1}}],[\"技术栈知识的确是多\",{\"1\":{\"1993\":1}}],[\"技术包括\",{\"1\":{\"1978\":1}}],[\"技术架构\",{\"0\":{\"1840\":1}}],[\"技术\",{\"1\":{\"1583\":2,\"1978\":1}}],[\"技术要进行更新\",{\"1\":{\"1304\":1}}],[\"技术选型更加灵活\",{\"1\":{\"1304\":1}}],[\"技术规范\",{\"1\":{\"1110\":1}}],[\"技能点\",{\"0\":{\"3\":1}}],[\"屏蔽复杂api的运用\",{\"1\":{\"1107\":1}}],[\"官方建议使用hashmap替代它\",{\"1\":{\"1544\":1}}],[\"官方称它为\",{\"1\":{\"1484\":1}}],[\"官方文档\",{\"1\":{\"1627\":1}}],[\"官方文档和周边生态还不够成熟\",{\"1\":{\"1327\":1}}],[\"官方文档显示误差可能达到40\",{\"1\":{\"396\":1}}],[\"官方给出的示例\",{\"1\":{\"1103\":1}}],[\"扮演角色\",{\"1\":{\"1103\":1}}],[\"综合类型转换接口\",{\"1\":{\"1096\":1}}],[\"综上所属\",{\"1\":{\"549\":2}}],[\"综上所述\",{\"1\":{\"451\":1,\"547\":1}}],[\"委派实现\",{\"1\":{\"1093\":1}}],[\"统一的spring配置属性管理\",{\"1\":{\"1144\":1}}],[\"统一类型转换服务\",{\"0\":{\"1092\":1}}],[\"统计concurrenthashmap里面节点个数\",{\"1\":{\"1554\":1}}],[\"统计\",{\"1\":{\"1554\":1}}],[\"统计等场景\",{\"1\":{\"1280\":1}}],[\"统计场景\",{\"0\":{\"745\":1}}],[\"统计sign中为1的位数\",{\"1\":{\"578\":1}}],[\"统计字符串被设置为1的bit数\",{\"1\":{\"578\":1}}],[\"统计的数据结构\",{\"1\":{\"577\":1}}],[\"统计的是写操作\",{\"1\":{\"479\":1}}],[\"统计多单位的数量\",{\"1\":{\"570\":1}}],[\"统计项名称\",{\"1\":{\"558\":1}}],[\"统计出的n\",{\"1\":{\"558\":2}}],[\"统计数据中s1表的记录行数是10573\",{\"1\":{\"554\":1}}],[\"统计这些页面上的不同值\",{\"1\":{\"347\":1}}],[\"缺少source\",{\"1\":{\"1088\":1,\"1090\":1}}],[\"缺点\",{\"0\":{\"600\":1,\"624\":1},\"1\":{\"308\":1,\"589\":1,\"590\":1,\"593\":1,\"1191\":1,\"1192\":1,\"1193\":1,\"1270\":1,\"1327\":1,\"1342\":1,\"1449\":1}}],[\"违反单一原则\",{\"1\":{\"1085\":1}}],[\"违反了唯一性约束\",{\"1\":{\"414\":1}}],[\"截止\",{\"1\":{\"1075\":1}}],[\"截取mylist中的\",{\"1\":{\"571\":1}}],[\"间接依赖注入\",{\"1\":{\"1148\":1}}],[\"间接用于beanfactory和databinder\",{\"1\":{\"1074\":1}}],[\"间隙\",{\"1\":{\"448\":1}}],[\"间隙锁只有在可重复读的隔离级别下才会生效的\",{\"1\":{\"536\":1}}],[\"间隙锁在某些情况下可以解决幻读的问题\",{\"1\":{\"536\":1}}],[\"间隙锁和行锁合称next\",{\"1\":{\"448\":1}}],[\"间隙锁之间不存在冲突关系\",{\"1\":{\"448\":1}}],[\"间隙锁\",{\"0\":{\"445\":1,\"448\":1,\"536\":1},\"1\":{\"442\":1,\"448\":1,\"536\":1,\"1263\":2}}],[\"间隙和加锁的状态其实是这样的\",{\"1\":{\"424\":1}}],[\"间隙和加锁状态应该如下图\",{\"1\":{\"424\":1}}],[\"收到客户端消息\",{\"1\":{\"1573\":1,\"1574\":1,\"1575\":1}}],[\"收到事件\",{\"1\":{\"1108\":1}}],[\"收集过程\",{\"0\":{\"1750\":1}}],[\"收集器是我们认识整个stream的第一步\",{\"1\":{\"1618\":1}}],[\"收集器是被设计成可以组合的\",{\"1\":{\"1615\":1}}],[\"收集器\",{\"1\":{\"1441\":1,\"1615\":1}}],[\"收集整个java堆和方法区的垃圾收集\",{\"1\":{\"1434\":1}}],[\"收集来自整个新生代以及部分老年代中的垃圾对象\",{\"1\":{\"1434\":1}}],[\"收集对象字段中的错误文案\",{\"1\":{\"1062\":1}}],[\"收集错误文案\",{\"1\":{\"1062\":1}}],[\"收益就越大\",{\"1\":{\"344\":1}}],[\"抽象基类abstractprotocol实现了protocolhandler接口\",{\"1\":{\"1687\":1}}],[\"抽象的beandifition表示beandifition之间有父子关系\",{\"1\":{\"1647\":1}}],[\"抽象是对类的抽象\",{\"1\":{\"1345\":1}}],[\"抽象类abstractexecutorservice重写了submit方法\",{\"1\":{\"1408\":1}}],[\"抽象类的方法的修复可以是public\",{\"1\":{\"1345\":1}}],[\"抽象类\",{\"1\":{\"1122\":1}}],[\"抽象实现\",{\"1\":{\"1052\":1,\"1093\":1}}],[\"抽象工厂模式\",{\"0\":{\"834\":1}}],[\"协作扩容操作\",{\"1\":{\"1554\":1}}],[\"协程是轻量级的线程\",{\"1\":{\"1477\":1}}],[\"协议\",{\"0\":{\"1834\":1}}],[\"协议比较简单\",{\"1\":{\"1419\":1}}],[\"协议扩展\",{\"1\":{\"1037\":1}}],[\"协调节点向包含这些文档id的分片发送get请求\",{\"1\":{\"1256\":1}}],[\"协调节点将查询请求广播到每一个数据节点\",{\"1\":{\"1256\":1}}],[\"协调节点就会进行路由\",{\"1\":{\"1256\":1}}],[\"协调节点\",{\"1\":{\"1256\":1}}],[\"协商\",{\"1\":{\"621\":1}}],[\"职责\",{\"1\":{\"1037\":1,\"1159\":1}}],[\"职位\",{\"1\":{\"510\":1,\"518\":1}}],[\"潮\",{\"1\":{\"1036\":1}}],[\"抄\",{\"1\":{\"1036\":1}}],[\"见java5\",{\"1\":{\"1106\":1}}],[\"见基于xml资源装载spring\",{\"1\":{\"1034\":1}}],[\"见redis\",{\"1\":{\"609\":1}}],[\"资源加载器\",{\"1\":{\"1637\":1}}],[\"资源在内存中的地址是变化的\",{\"1\":{\"1561\":1}}],[\"资源处理\",{\"1\":{\"1134\":1}}],[\"资源协议\",{\"1\":{\"1039\":1}}],[\"资源来源\",{\"1\":{\"1039\":1}}],[\"资源接口\",{\"1\":{\"1038\":1}}],[\"资源定位\",{\"1\":{\"1037\":1}}],[\"资源存储方式并不统一\",{\"1\":{\"1036\":1}}],[\"资源\",{\"1\":{\"1026\":1,\"1027\":1,\"1134\":1}}],[\"资源管理\",{\"1\":{\"892\":1,\"909\":1,\"921\":1}}],[\"细粒度的\",{\"1\":{\"1023\":1,\"1131\":1}}],[\"派生性\",{\"1\":{\"1134\":2}}],[\"派生类或接口\",{\"1\":{\"1099\":1}}],[\"派生\",{\"1\":{\"1023\":1,\"1619\":1}}],[\"转向步骤6\",{\"1\":{\"1549\":1}}],[\"转发\",{\"1\":{\"1474\":1}}],[\"转换方法\",{\"1\":{\"1089\":1,\"1103\":1}}],[\"转换范围\",{\"1\":{\"1089\":1}}],[\"转换场景\",{\"1\":{\"1083\":1,\"1087\":1}}],[\"转换成带字符编码的encodedresource对象\",{\"1\":{\"1022\":1}}],[\"转成顺序写\",{\"1\":{\"345\":1}}],[\"装配注解\",{\"1\":{\"1131\":1}}],[\"装在的核心方法在xmlbeandefinitionreader\",{\"1\":{\"1021\":1}}],[\"装饰器模式\",{\"0\":{\"842\":1}}],[\"暴露spring\",{\"1\":{\"1020\":1}}],[\"留空\",{\"1\":{\"1020\":4}}],[\"附加信息\",{\"0\":{\"1804\":1}}],[\"附件属性\",{\"1\":{\"1019\":1}}],[\"附近的人功能\",{\"1\":{\"576\":1}}],[\"声明式事务\",{\"1\":{\"1238\":1}}],[\"声明conversionservicefactorybean\",{\"1\":{\"1091\":1}}],[\"声明beandefinition\",{\"1\":{\"1019\":1}}],[\"声明\",{\"1\":{\"1019\":1}}],[\"声明类\",{\"1\":{\"958\":1}}],[\"属于n对1的关系\",{\"1\":{\"1016\":1}}],[\"属性表集合\",{\"0\":{\"1782\":1}}],[\"属性绑定\",{\"1\":{\"1647\":1}}],[\"属性绑定结果\",{\"1\":{\"1070\":1}}],[\"属性覆盖\",{\"1\":{\"1647\":1}}],[\"属性覆盖也有两种\",{\"1\":{\"1137\":1}}],[\"属性的说明\",{\"1\":{\"1621\":6}}],[\"属性=\",{\"1\":{\"1156\":1,\"1157\":1}}],[\"属性转换\",{\"1\":{\"1093\":1}}],[\"属性描述符\",{\"1\":{\"1075\":2}}],[\"属性不能为空\",{\"1\":{\"1063\":1}}],[\"属性存在时\",{\"1\":{\"1020\":3}}],[\"属性赋值\",{\"1\":{\"1019\":1,\"1234\":1,\"1647\":1}}],[\"属性赋值前阶段\",{\"0\":{\"1003\":1}}],[\"属性值\",{\"1\":{\"1002\":1}}],[\"属性名称\",{\"1\":{\"963\":1}}],[\"属性是一个字典\",{\"1\":{\"599\":1}}],[\"属性\",{\"1\":{\"553\":1,\"927\":1,\"1019\":1,\"1064\":1,\"1070\":1,\"1073\":2,\"1184\":2}}],[\"底层调用的就是linux内核的sendfile系统调用方法\",{\"1\":{\"1588\":1}}],[\"底层采用数据\",{\"1\":{\"1475\":1}}],[\"底层使用hashmap实现\",{\"1\":{\"1368\":1}}],[\"底层服务\",{\"1\":{\"1151\":1,\"1152\":1}}],[\"底层\",{\"1\":{\"1025\":1,\"1026\":1,\"1027\":1}}],[\"底层实现\",{\"1\":{\"1022\":1,\"1122\":1,\"1151\":1,\"1152\":1,\"1423\":1}}],[\"底层是使用的我们在依赖注入章节中介绍过的resolvedependency方法来实现的\",{\"1\":{\"1001\":1}}],[\"底层resolvedependency\",{\"1\":{\"1001\":1,\"1005\":1,\"1006\":1,\"1011\":1}}],[\"场景三\",{\"1\":{\"1536\":1}}],[\"场景二\",{\"1\":{\"1536\":1}}],[\"场景一\",{\"1\":{\"1536\":1}}],[\"场景\",{\"1\":{\"1081\":1}}],[\"场景分析\",{\"1\":{\"1081\":1}}],[\"场景说明\",{\"1\":{\"1023\":5,\"1029\":2,\"1131\":3,\"1140\":2}}],[\"场景比较有限\",{\"1\":{\"998\":1}}],[\"场景举例\",{\"1\":{\"946\":1}}],[\"递归\",{\"1\":{\"1456\":2}}],[\"递归查找合并\",{\"1\":{\"1647\":1}}],[\"递归查找\",{\"1\":{\"997\":1}}],[\"递增\",{\"1\":{\"571\":1}}],[\"已满\",{\"1\":{\"1503\":1}}],[\"已加载\",{\"1\":{\"1022\":1}}],[\"已加载的beandefinitiond的数量\",{\"1\":{\"994\":1,\"995\":1,\"997\":1,\"1000\":1,\"1001\":1,\"1005\":1,\"1006\":1,\"1011\":1}}],[\"已经成为目前最主流的\",{\"1\":{\"1982\":1}}],[\"已经成为互联网企业的不二首选\",{\"1\":{\"1975\":1}}],[\"已经逐渐被\",{\"1\":{\"1979\":1}}],[\"已经被\",{\"1\":{\"1978\":1}}],[\"已经被广泛应用在数据库引擎中了\",{\"1\":{\"334\":1}}],[\"已经初始化但是冲突发生在cell单元内\",{\"1\":{\"1480\":1}}],[\"已经得到连接顺序abc时当前的最小连接成本\",{\"1\":{\"556\":1}}],[\"已经需要做主备切换了\",{\"1\":{\"478\":1}}],[\"已经把实例b需要的binlog给删掉了\",{\"1\":{\"468\":1}}],[\"已经存在于实例x的gtid集合中了\",{\"1\":{\"468\":1}}],[\"已经加入了这个gtid\",{\"1\":{\"468\":1}}],[\"已经写了一些redo\",{\"1\":{\"451\":1}}],[\"已经知道类及了y个1\",{\"1\":{\"417\":1}}],[\"已经知道累积了x个0\",{\"1\":{\"417\":1}}],[\"已经没有办法利用索引方式查出身份证号码在\",{\"1\":{\"352\":1}}],[\"已经是有序的了\",{\"1\":{\"348\":1}}],[\"笼统而言\",{\"1\":{\"983\":1,\"1235\":1}}],[\"游离对象\",{\"1\":{\"973\":1}}],[\"元本身管理并发修改\",{\"1\":{\"1620\":1}}],[\"元的结构是不能被修改的\",{\"1\":{\"1620\":1}}],[\"元的数据只有在需要的时候才会被消费\",{\"1\":{\"1619\":1}}],[\"元中的元素可以是数组\",{\"1\":{\"1620\":1}}],[\"元空间无固定初始大小\",{\"1\":{\"1664\":1}}],[\"元空间的元数据分配效率更高\",{\"1\":{\"1457\":1}}],[\"元空间使用本地内存存储元数据\",{\"1\":{\"1457\":1}}],[\"元空间可以根据应用程序的需要自动调整大小\",{\"1\":{\"1457\":1}}],[\"元空间通过使用本地内存\",{\"1\":{\"1457\":1}}],[\"元\",{\"1\":{\"1136\":1,\"1620\":1}}],[\"元注解\",{\"1\":{\"1132\":1,\"1133\":1,\"1134\":1}}],[\"元素如果可用的话会发送给任意一个线程\",{\"1\":{\"1623\":1}}],[\"元素的添加\",{\"1\":{\"1620\":1}}],[\"元素的顺序与之前的保持一致\",{\"1\":{\"1620\":1}}],[\"元素的顺序不是很重要的话\",{\"1\":{\"1618\":1}}],[\"元素的特性值ordered\",{\"1\":{\"1620\":1}}],[\"元素的位置要么是在原来的位置\",{\"1\":{\"1550\":1}}],[\"元素在重新计算hash之后\",{\"1\":{\"1550\":1}}],[\"元素位置定位\",{\"1\":{\"1519\":1}}],[\"元素数量\",{\"1\":{\"1503\":1}}],[\"元素个数\",{\"1\":{\"1502\":1}}],[\"元素太少\",{\"1\":{\"1360\":1}}],[\"元素要么是在原来的位置\",{\"1\":{\"1359\":1}}],[\"元素\",{\"1\":{\"1036\":1}}],[\"元素注册对应的beandefinitionparser实现\",{\"1\":{\"1030\":1}}],[\"元素成员\",{\"1\":{\"1019\":1}}],[\"元标注的方式来实现\",{\"1\":{\"1023\":1}}],[\"元信息api\",{\"1\":{\"1075\":1}}],[\"元信息\",{\"1\":{\"1017\":1,\"1102\":1}}],[\"元信息配置阶段\",{\"0\":{\"994\":1}}],[\"元信息解析阶段\",{\"0\":{\"995\":1}}],[\"元信息解析\",{\"1\":{\"964\":1}}],[\"元数据读取器\",{\"1\":{\"1647\":1}}],[\"元数据指针\",{\"1\":{\"1484\":1}}],[\"元数据分配效率\",{\"1\":{\"1457\":1}}],[\"元数据\",{\"1\":{\"967\":1,\"975\":1}}],[\"元数据锁\",{\"0\":{\"441\":1}}],[\"嵌入式汇编规定把输出和输入寄存器按统一顺序编号\",{\"1\":{\"1479\":1}}],[\"嵌入层次\",{\"1\":{\"963\":1}}],[\"嵌套属性路径\",{\"1\":{\"1073\":1}}],[\"嵌套y属性\",{\"1\":{\"1072\":1}}],[\"嵌套元素支持较弱\",{\"1\":{\"1036\":1}}],[\"嵌套循环连接算法\",{\"0\":{\"524\":1}}],[\"嵌套循环连接\",{\"1\":{\"523\":1}}],[\"嵌套循环\",{\"1\":{\"364\":1}}],[\"入门\",{\"1\":{\"1978\":1}}],[\"入队put方法\",{\"1\":{\"1502\":1,\"1503\":1}}],[\"入队和出队操作使用同一个锁对象\",{\"1\":{\"1502\":1}}],[\"入队\",{\"1\":{\"1501\":2,\"1502\":2}}],[\"入口\",{\"1\":{\"963\":1,\"1155\":1}}],[\"入职时间\",{\"1\":{\"510\":1,\"518\":1}}],[\"限流\",{\"1\":{\"1320\":1,\"1985\":1}}],[\"限流降级\",{\"1\":{\"633\":1}}],[\"限制get请求\",{\"1\":{\"1201\":1}}],[\"限制\",{\"1\":{\"976\":1,\"977\":1,\"978\":1}}],[\"限定注入\",{\"0\":{\"961\":1}}],[\"异常\",{\"1\":{\"1969\":1}}],[\"异常失败处理在这里\",{\"1\":{\"1575\":1}}],[\"异常处理和模式指定\",{\"1\":{\"1510\":1}}],[\"异常处理\",{\"0\":{\"1937\":1},\"1\":{\"1125\":1}}],[\"异常类型\",{\"1\":{\"946\":1}}],[\"异步i\",{\"1\":{\"1576\":1}}],[\"异步io的实现会负责把数据从内核拷贝到用户空间\",{\"1\":{\"1568\":1}}],[\"异步io\",{\"0\":{\"1566\":1},\"1\":{\"1561\":1,\"1567\":1}}],[\"异步说的是被调用者\",{\"1\":{\"1567\":1}}],[\"异步执行\",{\"1\":{\"1518\":1}}],[\"异步执行询价然后再保存\",{\"1\":{\"1517\":1}}],[\"异步向电商s3询价\",{\"1\":{\"1517\":1}}],[\"异步向电商s2询价\",{\"1\":{\"1517\":2}}],[\"异步向电商s1询价\",{\"1\":{\"1517\":2}}],[\"异步针对请求\",{\"1\":{\"1421\":1}}],[\"异步刷盘效率更高\",{\"1\":{\"1328\":1}}],[\"异步刷盘\",{\"1\":{\"1328\":1}}],[\"异步同步效率更高\",{\"1\":{\"1328\":1}}],[\"异步同步\",{\"1\":{\"1328\":1}}],[\"异步处理\",{\"1\":{\"1138\":1}}],[\"异步动态切换\",{\"1\":{\"1123\":1}}],[\"异步模式\",{\"1\":{\"1123\":2}}],[\"异步读写架构\",{\"0\":{\"698\":1}}],[\"异步复制\",{\"0\":{\"618\":1}}],[\"异步\",{\"0\":{\"1567\":1},\"1\":{\"589\":1,\"1113\":1,\"1123\":1,\"1125\":1,\"1326\":1,\"1421\":2,\"1576\":1,\"1985\":1}}],[\"演示listablebeanfactory\",{\"1\":{\"944\":1}}],[\"演示objectprovider\",{\"1\":{\"944\":2}}],[\"演示objectfactory\",{\"1\":{\"944\":1}}],[\"演示beanfactory\",{\"1\":{\"944\":1}}],[\"层次性接口\",{\"1\":{\"1058\":1}}],[\"层次性设计\",{\"1\":{\"1052\":1}}],[\"层次性的messagesource\",{\"0\":{\"1051\":1}}],[\"层次性beanfactory查找\",{\"1\":{\"997\":1}}],[\"层次性查找messagesource对象\",{\"1\":{\"1055\":1}}],[\"层次性查找\",{\"1\":{\"942\":1}}],[\"层次性依赖查找的安全性取决于其扩展的单一或集合类型的beanfactory接口\",{\"1\":{\"944\":1}}],[\"层次性依赖查找接口\",{\"1\":{\"942\":1}}],[\"层次性依赖查找\",{\"0\":{\"942\":1},\"1\":{\"939\":1}}],[\"利用反射创建相应的组件\",{\"1\":{\"1683\":1}}],[\"利用cas去进行无锁线程安全操作\",{\"1\":{\"1554\":1}}],[\"利用红黑树快速增删改查的特点提高hashmap的性能\",{\"1\":{\"1546\":1}}],[\"利用这个特性\",{\"1\":{\"1517\":1}}],[\"利用reentrantlock实现线程安全\",{\"1\":{\"1502\":1}}],[\"利用信号量来限制\",{\"1\":{\"1404\":1}}],[\"利用了redis的分布式锁\",{\"1\":{\"1248\":1}}],[\"利用缓存行填充解决伪共享的问题\",{\"1\":{\"1519\":1}}],[\"利用缓存\",{\"1\":{\"1248\":1}}],[\"利用外部化配置资源覆盖spring属性值\",{\"1\":{\"1020\":1}}],[\"利用它的生命周期方法\",{\"1\":{\"985\":1}}],[\"利用obejctprovider进行依赖查找\",{\"1\":{\"940\":1}}],[\"利用率很低之后\",{\"1\":{\"335\":1}}],[\"垃圾回收算法\",{\"0\":{\"1718\":1}}],[\"垃圾回收\",{\"0\":{\"1698\":1}}],[\"垃圾回收spring\",{\"0\":{\"934\":1}}],[\"垃圾收集器参数总结\",{\"0\":{\"1756\":1}}],[\"垃圾收集器\",{\"0\":{\"1671\":1}}],[\"垃圾收集器永远不会回收掉引用的对象\",{\"1\":{\"1435\":1}}],[\"垃圾收集器的步骤\",{\"0\":{\"116\":1,\"1447\":1}}],[\"销毁方法只是针对于单例的bean而言\",{\"1\":{\"1647\":1}}],[\"销毁的问题\",{\"1\":{\"1534\":1}}],[\"销毁的示例\",{\"1\":{\"933\":1}}],[\"销毁\",{\"1\":{\"1234\":1}}],[\"销毁lifecycle\",{\"1\":{\"1175\":1}}],[\"销毁或关闭beanfactory\",{\"1\":{\"1163\":1}}],[\"销毁前阶段\",{\"0\":{\"1011\":1}}],[\"销毁阶段\",{\"0\":{\"1010\":1,\"1012\":1}}],[\"销毁已完成\",{\"1\":{\"985\":1}}],[\"销毁化\",{\"1\":{\"985\":1}}],[\"销毁回调方法将不会执行\",{\"1\":{\"985\":1}}],[\"销毁中\",{\"1\":{\"933\":6}}],[\"销毁beanfactory中的单例bean\",{\"1\":{\"1013\":1}}],[\"销毁bean\",{\"0\":{\"933\":1}}],[\"静态属性跳过\",{\"1\":{\"1648\":1}}],[\"静态属性和静态方法会跳过\",{\"1\":{\"1648\":1}}],[\"静态变量\",{\"1\":{\"1457\":1}}],[\"静态方法跳过\",{\"1\":{\"1648\":1}}],[\"静态方法引用\",{\"0\":{\"1603\":1},\"1\":{\"1602\":1}}],[\"静态方法的初始化会更早\",{\"1\":{\"1183\":1}}],[\"静态方法实例化bean\",{\"1\":{\"930\":1}}],[\"静态\",{\"1\":{\"1183\":1}}],[\"静态内部类\",{\"0\":{\"270\":1,\"1194\":1}}],[\"特化的管道类\",{\"1\":{\"1621\":1}}],[\"特化的版本\",{\"1\":{\"1619\":1}}],[\"特定对象的实例方法引用\",{\"1\":{\"1602\":1}}],[\"特点\",{\"1\":{\"1391\":1,\"1395\":1,\"1435\":1,\"1585\":1}}],[\"特性值\",{\"1\":{\"1623\":1}}],[\"特性\",{\"0\":{\"1835\":1},\"1\":{\"1113\":1,\"1647\":1}}],[\"特征\",{\"1\":{\"1071\":1}}],[\"特别感谢\",{\"1\":{\"1993\":1}}],[\"特别是公共资源有限的应用场景\",{\"1\":{\"1496\":1}}],[\"特别要注意\",{\"1\":{\"1166\":1}}],[\"特别需要注意的是\",{\"1\":{\"1011\":1}}],[\"特别说明\",{\"1\":{\"428\":1}}],[\"特殊值对业务有侵入\",{\"1\":{\"1286\":1}}],[\"特殊bytype类型\",{\"1\":{\"952\":1}}],[\"特殊方式的示例\",{\"1\":{\"930\":1}}],[\"特殊方式\",{\"1\":{\"930\":1}}],[\"命名\",{\"1\":{\"1138\":1}}],[\"命名空间与xml\",{\"1\":{\"1030\":2}}],[\"命名空间绑定\",{\"1\":{\"1030\":2}}],[\"命名空间\",{\"1\":{\"1028\":1}}],[\"命名bean的注册方式\",{\"1\":{\"929\":1}}],[\"命名方式\",{\"1\":{\"929\":1}}],[\"命令用于从标准输入中匹配并提取指定字符串\",{\"1\":{\"1464\":1}}],[\"命令含义\",{\"1\":{\"1464\":1}}],[\"命令行配置属性源\",{\"1\":{\"1154\":1}}],[\"命令行查看数据库数量databases\",{\"1\":{\"567\":1}}],[\"命令模式\",{\"0\":{\"850\":1}}],[\"命令发送给频道\",{\"1\":{\"596\":1}}],[\"命令入队\",{\"1\":{\"579\":2}}],[\"命令相似\",{\"1\":{\"570\":1}}],[\"命令并不是一个事务的起点\",{\"1\":{\"542\":1}}],[\"命令之后的delete语句\",{\"1\":{\"454\":1}}],[\"命令\",{\"0\":{\"597\":1},\"1\":{\"454\":1,\"471\":1,\"485\":1,\"490\":1,\"570\":1,\"571\":1,\"572\":1,\"573\":1,\"574\":1,\"576\":1,\"577\":1,\"578\":1,\"589\":1,\"597\":1}}],[\"允许外设设备和内存存储器之间直接进行io数据传输\",{\"1\":{\"1578\":1}}],[\"允许多条记录的值为null\",{\"1\":{\"1544\":1}}],[\"允许中断\",{\"1\":{\"1490\":1}}],[\"允许脏读\",{\"1\":{\"1262\":1}}],[\"允许事务在执行过程中\",{\"1\":{\"1238\":2}}],[\"允许用户授权在第三方应用程序访问他们存储在另外的服务提供者上的信息\",{\"1\":{\"1202\":1}}],[\"允许对关心的bean进行扩展\",{\"1\":{\"1015\":1}}],[\"允许bean重复注册\",{\"1\":{\"996\":1}}],[\"允许我们通过getter\",{\"1\":{\"937\":1}}],[\"允许出现特殊字符\",{\"1\":{\"928\":1}}],[\"允许在执行更新类事务\",{\"1\":{\"474\":1}}],[\"吉永超\",{\"1\":{\"917\":1,\"921\":1,\"929\":1,\"994\":1,\"1032\":1,\"1072\":2,\"1082\":2,\"1084\":2,\"1091\":2,\"1156\":2,\"1181\":1,\"1182\":1,\"1546\":1}}],[\"易于理解和掌握\",{\"1\":{\"1968\":1}}],[\"易测试性\",{\"1\":{\"916\":1}}],[\"易扩展的优点\",{\"1\":{\"301\":1}}],[\"典型的应用场景就是异步日志\",{\"1\":{\"1520\":1}}],[\"典型的单链表结构\",{\"1\":{\"1503\":1}}],[\"典型的ioc管理\",{\"1\":{\"916\":1}}],[\"典型的场景是先使用select语句查询大量的结果\",{\"1\":{\"383\":1}}],[\"于此同时\",{\"1\":{\"1651\":1}}],[\"于此同时springframework或者peak\",{\"1\":{\"914\":1}}],[\"于是它可以再次发送read操作\",{\"1\":{\"1564\":1}}],[\"于是整个类的所有对象都会变为不可偏向的\",{\"1\":{\"1485\":1}}],[\"于是\",{\"1\":{\"1485\":1,\"1546\":1}}],[\"于是spring增加了三级缓存\",{\"1\":{\"1237\":1}}],[\"于是线程就进入了一个死循环\",{\"1\":{\"603\":1}}],[\"于是得到了\",{\"1\":{\"478\":1}}],[\"于是此时优化器选了只需要扫描1000行的索引a\",{\"1\":{\"348\":1}}],[\"于是就进入了执行器阶段\",{\"1\":{\"322\":1}}],[\"良好\",{\"1\":{\"911\":1}}],[\"良好的设计\",{\"0\":{\"650\":1}}],[\"侵入业务逻辑\",{\"1\":{\"911\":1}}],[\"托管的资源\",{\"1\":{\"907\":2}}],[\"容量为11\",{\"1\":{\"1555\":1}}],[\"容量\",{\"1\":{\"1503\":1,\"1509\":1}}],[\"容量可以扩大一倍\",{\"1\":{\"528\":1}}],[\"容易导致内存溢出等\",{\"1\":{\"1457\":1}}],[\"容错问题\",{\"1\":{\"1304\":1}}],[\"容器负责内部处理\",{\"1\":{\"1683\":1}}],[\"容器组件\",{\"1\":{\"1683\":3}}],[\"容器之间的关系\",{\"1\":{\"1658\":1}}],[\"容器中的事务管理器\",{\"1\":{\"1655\":1}}],[\"容器为空\",{\"1\":{\"1554\":1}}],[\"容器的长度\",{\"1\":{\"1520\":1}}],[\"容器的内存占用小以及最小化api的一个依赖\",{\"1\":{\"910\":1}}],[\"容器产生session信息丢失\",{\"1\":{\"1200\":1}}],[\"容器配置元信息章节表格\",{\"1\":{\"1034\":1}}],[\"容器配置元信息\",{\"0\":{\"1028\":1,\"1029\":1},\"1\":{\"1017\":1}}],[\"容器回味bean自动生成一个唯一的名称\",{\"1\":{\"928\":1}}],[\"容器内建依赖\",{\"1\":{\"919\":1}}],[\"容器内建bean对象\",{\"1\":{\"919\":2}}],[\"容器需要一些可以管控的一个渠道\",{\"1\":{\"910\":1}}],[\"容器不需要一些特殊的配置来进行操作\",{\"1\":{\"910\":1}}],[\"容器\",{\"1\":{\"907\":2,\"1554\":1}}],[\"控制流程\",{\"1\":{\"1623\":1}}],[\"控制台就会打印十次\",{\"1\":{\"1617\":1}}],[\"控制台会打印什么呢\",{\"1\":{\"1612\":1}}],[\"控制台会打印出以下结果\",{\"1\":{\"1600\":1}}],[\"控制台在输出了0\",{\"1\":{\"1610\":1}}],[\"控制台输出\",{\"1\":{\"1592\":1,\"1617\":1,\"1619\":2}}],[\"控制器支持\",{\"1\":{\"1583\":1}}],[\"控制器是单例模式\",{\"1\":{\"1240\":1}}],[\"控制propertysource\",{\"1\":{\"1035\":1}}],[\"控制ioc容器行为\",{\"1\":{\"1035\":1}}],[\"控制innodb的并发线程上限\",{\"1\":{\"476\":1}}],[\"控制反转\",{\"1\":{\"905\":1,\"924\":1}}],[\"好方便后续的相关操作\",{\"1\":{\"1651\":1}}],[\"好在对于\",{\"1\":{\"1970\":1}}],[\"好在jdk为我们提供了另一种方式来完成\",{\"1\":{\"1607\":1}}],[\"好在随着自动垃圾回收\",{\"1\":{\"1527\":1}}],[\"好处\",{\"1\":{\"1252\":1}}],[\"好莱坞原则\",{\"1\":{\"905\":1}}],[\"好的索引可以让查询使用合适的访问类型\",{\"1\":{\"390\":1}}],[\"待续\",{\"1\":{\"971\":1,\"1069\":1}}],[\"待定\",{\"1\":{\"904\":1,\"950\":1}}],[\"待执行事务队列\",{\"1\":{\"461\":1}}],[\"专题讨论\",{\"1\":{\"920\":2}}],[\"专属模式\",{\"1\":{\"900\":1}}],[\"专门用于服务备库b的这个长连接\",{\"1\":{\"453\":1}}],[\"专门用来存放临时文件的数据\",{\"1\":{\"412\":1}}],[\"契约接口\",{\"1\":{\"900\":1}}],[\"​\",{\"1\":{\"899\":1,\"967\":1}}],[\"锲约接口\",{\"1\":{\"899\":1}}],[\"仓库链接\",{\"1\":{\"898\":1}}],[\"校验权限\",{\"0\":{\"1954\":1}}],[\"校验字节码文件的正确性\",{\"1\":{\"1663\":1}}],[\"校验environment中必须属性\",{\"1\":{\"1162\":1}}],[\"校验错误文案code处理器\",{\"1\":{\"1070\":1}}],[\"校验器\",{\"1\":{\"1068\":1}}],[\"校验目标对象\",{\"1\":{\"1061\":1}}],[\"校验目标类能否校验\",{\"1\":{\"1061\":1}}],[\"校验\",{\"1\":{\"892\":1}}],[\"校验不通过直接打回\",{\"1\":{\"627\":1}}],[\"国际化文案\",{\"1\":{\"945\":1}}],[\"国际化等\",{\"1\":{\"926\":1}}],[\"国际化\",{\"1\":{\"892\":1,\"921\":1}}],[\"泛型条件判断\",{\"1\":{\"1648\":1}}],[\"泛型m的定义是m\",{\"1\":{\"1618\":1}}],[\"泛型集合类型辅助类\",{\"0\":{\"1101\":1}}],[\"泛型声明\",{\"1\":{\"1099\":1}}],[\"泛型接口\",{\"1\":{\"1099\":1}}],[\"泛型父类\",{\"1\":{\"1099\":1}}],[\"泛型信息\",{\"1\":{\"1099\":1}}],[\"泛型统配类型\",{\"1\":{\"1099\":1}}],[\"泛型参数具体化\",{\"1\":{\"1100\":2}}],[\"泛型参数\",{\"1\":{\"1099\":1}}],[\"泛型参数类型\",{\"1\":{\"1099\":2}}],[\"泛型参数s\",{\"1\":{\"1086\":1}}],[\"泛型数组类型\",{\"1\":{\"1099\":1}}],[\"泛型不会产生运行时开销\",{\"1\":{\"1098\":1}}],[\"泛型被引入到java语言中\",{\"1\":{\"1098\":1}}],[\"泛型的使用场景\",{\"1\":{\"1098\":1}}],[\"泛型类型变量\",{\"1\":{\"1099\":2}}],[\"泛型类型擦写\",{\"1\":{\"1098\":1}}],[\"泛型类型是在类型上参数化的泛型类或接口\",{\"1\":{\"1098\":1}}],[\"泛型类型\",{\"1\":{\"1098\":1}}],[\"泛型处理\",{\"1\":{\"903\":1,\"963\":1,\"1125\":1}}],[\"泛型\",{\"1\":{\"891\":1,\"899\":1,\"1969\":1}}],[\"泛型设置为\",{\"1\":{\"583\":1}}],[\"枚举\",{\"1\":{\"891\":1}}],[\"枚举类的实例就是线程安全的\",{\"1\":{\"1195\":1}}],[\"枚举类\",{\"0\":{\"271\":1,\"1195\":1}}],[\"打破循环最关键的点是singletonfactories\",{\"1\":{\"1649\":1}}],[\"打印出所有最终生效的不稳定指令\",{\"1\":{\"1455\":1}}],[\"打印出所有不稳定参数所有默认值\",{\"1\":{\"1455\":1}}],[\"打印结果\",{\"1\":{\"909\":1}}],[\"打包过程\",{\"0\":{\"878\":1}}],[\"打开日志目录下的master\",{\"1\":{\"485\":1}}],[\"打开表的行为\",{\"1\":{\"424\":1}}],[\"打开表的时候\",{\"1\":{\"322\":1}}],[\"打开\",{\"1\":{\"354\":1,\"421\":1}}],[\"策略模式\",{\"0\":{\"849\":1},\"1\":{\"906\":1}}],[\"责任链模式\",{\"0\":{\"847\":1}}],[\"享元模式\",{\"0\":{\"843\":1}}],[\"构建项目\",{\"1\":{\"1980\":1}}],[\"构建工具\",{\"0\":{\"879\":1}}],[\"构建器模式\",{\"0\":{\"835\":1}}],[\"构造一个reader和scanner\",{\"1\":{\"1647\":1}}],[\"构造一个metadatareader\",{\"1\":{\"1646\":1}}],[\"构造一个针对无状态的中间的阶段的流\",{\"1\":{\"1622\":1}}],[\"构造了一个终止操作\",{\"1\":{\"1623\":1}}],[\"构造之后就是一个不可变的数组\",{\"1\":{\"1620\":1}}],[\"构造最终所返回的累加器对象\",{\"1\":{\"1618\":1}}],[\"构造方法已经找到了\",{\"1\":{\"1650\":1}}],[\"构造方法注入\",{\"1\":{\"1650\":1}}],[\"构造方法引用\",{\"0\":{\"1606\":1},\"1\":{\"1602\":1}}],[\"构造方法有哪些特性\",{\"0\":{\"17\":1,\"1346\":1}}],[\"构造小顶堆的方法\",{\"1\":{\"1506\":1}}],[\"构造函数名称必须与类名称相同\",{\"1\":{\"1346\":1}}],[\"构造函数隐式调用\",{\"1\":{\"1346\":1}}],[\"构造函数不能有返回类型\",{\"1\":{\"1346\":1}}],[\"构造来源\",{\"1\":{\"1093\":1}}],[\"构造哈希值的时候很快\",{\"1\":{\"463\":1}}],[\"构造成一个堆\",{\"1\":{\"421\":1}}],[\"构造器用于初始化对象的状态\",{\"1\":{\"1346\":1}}],[\"构造器无法被重写\",{\"1\":{\"1338\":1}}],[\"构造器或方法参数名称\",{\"1\":{\"1102\":1}}],[\"构造器或方法参数泛型类型\",{\"1\":{\"1102\":1}}],[\"构造器或方法参数类型\",{\"1\":{\"1102\":1}}],[\"构造器或方法参数索引\",{\"1\":{\"1102\":1}}],[\"构造器参数\",{\"1\":{\"963\":1}}],[\"构造器参数以及property上面的设置通常会覆盖掉autowiring\",{\"1\":{\"952\":1}}],[\"构造器自动绑定的示例\",{\"1\":{\"954\":1}}],[\"构造器注入式按照类型注入\",{\"1\":{\"1001\":1,\"1005\":1,\"1006\":1,\"1011\":1}}],[\"构造器注入依赖\",{\"1\":{\"954\":1}}],[\"构造器注入的实现方法\",{\"1\":{\"954\":1}}],[\"构造器注入和setter注入\",{\"0\":{\"912\":1}}],[\"构造器注入\",{\"0\":{\"954\":1},\"1\":{\"906\":1,\"958\":1,\"969\":1,\"1001\":2}}],[\"构造器\",{\"0\":{\"9\":1,\"1338\":1},\"1\":{\"951\":1,\"1503\":1}}],[\"拦截处理程序的执行\",{\"1\":{\"1657\":1}}],[\"拦截器指的是\",{\"1\":{\"1354\":1}}],[\"拦截器的作用\",{\"1\":{\"646\":1}}],[\"拦截模式\",{\"0\":{\"751\":1}}],[\"适当提高该值\",{\"1\":{\"1664\":1}}],[\"适当的加大队列\",{\"1\":{\"1536\":1}}],[\"适用于对延时要求非常苛刻的场景\",{\"1\":{\"1520\":1}}],[\"适用于连接比较多\",{\"1\":{\"1421\":1}}],[\"适用于连接比较少且比较固定的场景\",{\"1\":{\"1421\":1}}],[\"适用于连接多\",{\"1\":{\"1421\":1}}],[\"适用场景\",{\"1\":{\"1327\":1}}],[\"适合入门\",{\"1\":{\"1992\":1}}],[\"适合做高性能服务器开发\",{\"1\":{\"1574\":1}}],[\"适合cpu资源紧缺\",{\"1\":{\"1520\":1}}],[\"适合控制数据访问\",{\"1\":{\"1477\":1}}],[\"适合存储对象\",{\"1\":{\"1280\":1}}],[\"适合大规模的数据恢复\",{\"1\":{\"590\":1}}],[\"适配成methodinterceptor\",{\"1\":{\"1654\":1}}],[\"适配一个collector来执行finisher方法的转换\",{\"1\":{\"1618\":1}}],[\"适配对象\",{\"1\":{\"1155\":1}}],[\"适配器模式\",{\"0\":{\"734\":1,\"840\":1}}],[\"粘包与拆包\",{\"0\":{\"731\":1}}],[\"核心技术\",{\"1\":{\"1969\":1}}],[\"核心原理\",{\"1\":{\"1966\":2}}],[\"核心原理的示意图\",{\"1\":{\"1241\":1}}],[\"核心包\",{\"1\":{\"1560\":1}}],[\"核心特点\",{\"1\":{\"1542\":1}}],[\"核心特性\",{\"0\":{\"566\":1}}],[\"核心逻辑在atomic\",{\"1\":{\"1479\":1}}],[\"核心线程数\",{\"1\":{\"1476\":1}}],[\"核心代码\",{\"1\":{\"1432\":1}}],[\"核心类\",{\"1\":{\"1125\":1}}],[\"核心要素\",{\"1\":{\"1089\":1}}],[\"核心职责\",{\"1\":{\"1082\":1}}],[\"核心组件\",{\"1\":{\"1065\":1,\"1134\":1,\"1224\":1}}],[\"核心接口\",{\"1\":{\"1050\":1,\"1052\":1,\"1053\":1,\"1058\":1,\"1159\":1}}],[\"核心处理方法\",{\"1\":{\"964\":1}}],[\"核心api\",{\"0\":{\"858\":1,\"1560\":1},\"1\":{\"1025\":1,\"1026\":1,\"1027\":1,\"1100\":1,\"1101\":1,\"1102\":1,\"1103\":1,\"1539\":2,\"1540\":1,\"1655\":1}}],[\"核心基础\",{\"0\":{\"741\":1}}],[\"核心方法doresolvedependency的源代码\",{\"1\":{\"1648\":1}}],[\"核心方法的实现\",{\"1\":{\"1557\":1}}],[\"核心方法\",{\"0\":{\"701\":1},\"1\":{\"1061\":1,\"1062\":1,\"1086\":2,\"1093\":1,\"1151\":1}}],[\"流源\",{\"1\":{\"1624\":1}}],[\"流源可能通过两种方式来构建\",{\"1\":{\"1622\":1}}],[\"流源的对象也已经构造完成\",{\"1\":{\"1621\":1}}],[\"流调用机制与原理\",{\"0\":{\"1622\":1}}],[\"流就会被认为被消费掉了\",{\"1\":{\"1621\":1}}],[\"流就会自动的为我们根据姓名来进行分类了\",{\"1\":{\"1613\":1}}],[\"流的操作\",{\"1\":{\"1619\":1}}],[\"流的短路与并发流\",{\"0\":{\"1612\":1}}],[\"流初始被创建的时候就会选择串行还是并行的\",{\"1\":{\"1619\":1}}],[\"流都实现了autocloseable接口\",{\"1\":{\"1619\":1}}],[\"流关注的是元的计算\",{\"1\":{\"1619\":1}}],[\"流并不会直接提供直接的去操作元素的方式\",{\"1\":{\"1619\":1}}],[\"流管道以及并行流的行为和种类\",{\"1\":{\"1619\":1}}],[\"流管道可以通过并行或者是串行的方式来去执行\",{\"1\":{\"1619\":1}}],[\"流管道\",{\"1\":{\"1619\":1}}],[\"流会将执行的调用链的时候\",{\"1\":{\"1611\":1}}],[\"流是延迟的\",{\"1\":{\"1619\":1}}],[\"流是无法重复使用或消费的\",{\"1\":{\"1611\":1}}],[\"流是惰性的\",{\"1\":{\"1610\":1}}],[\"流与迭代器类似的一点是\",{\"1\":{\"1611\":1}}],[\"流只有在遇到终止操作的时候\",{\"1\":{\"1610\":1}}],[\"流中的元素为1\",{\"1\":{\"1610\":1}}],[\"流不存储值\",{\"1\":{\"1608\":1}}],[\"流才会被真正的执行\",{\"1\":{\"1607\":1}}],[\"流操作的分类又有两种\",{\"1\":{\"1607\":1}}],[\"流\",{\"1\":{\"1593\":1}}],[\"流式\",{\"1\":{\"1107\":1}}],[\"流式调用\",{\"0\":{\"684\":1}}],[\"流程大致如下\",{\"1\":{\"1564\":1}}],[\"流程概览\",{\"0\":{\"875\":1}}],[\"流程图如下\",{\"1\":{\"403\":1,\"416\":1}}],[\"安防场景\",{\"0\":{\"746\":1}}],[\"安全区域\",{\"0\":{\"1760\":1}}],[\"安全点\",{\"0\":{\"1759\":1}}],[\"安全性更高\",{\"1\":{\"1424\":1}}],[\"安全性指的是没有查找到bean的时候\",{\"1\":{\"944\":1}}],[\"安全依赖查找\",{\"0\":{\"944\":1}}],[\"安全\",{\"0\":{\"653\":1},\"1\":{\"1342\":1}}],[\"安装使用方便\",{\"1\":{\"301\":1}}],[\"维基百科\",{\"1\":{\"1986\":1}}],[\"维护了一对相关的锁\",{\"1\":{\"1498\":2}}],[\"维护性差\",{\"1\":{\"645\":1}}],[\"维持和管理连接\",{\"1\":{\"318\":1}}],[\"帧类型\",{\"1\":{\"643\":1}}],[\"帧长度\",{\"1\":{\"643\":1}}],[\"兼容起来也比较简单\",{\"1\":{\"637\":1}}],[\"减轻服务压力\",{\"1\":{\"1283\":1}}],[\"减轻了存储系统的压力\",{\"1\":{\"627\":1}}],[\"减少了不必要的拷贝次数\",{\"1\":{\"1576\":1}}],[\"减少碰撞次数\",{\"1\":{\"1554\":1}}],[\"减少cpu等待时间\",{\"1\":{\"1474\":1}}],[\"减少网络传输\",{\"1\":{\"1424\":1}}],[\"减少锁定资源量和实践长度\",{\"1\":{\"539\":1}}],[\"减少binlog的写盘次数\",{\"1\":{\"451\":1}}],[\"减少跨库和跨表查询\",{\"1\":{\"411\":1}}],[\"减少select\",{\"1\":{\"369\":1}}],[\"减少读磁盘\",{\"1\":{\"343\":1}}],[\"减少回表次数\",{\"1\":{\"340\":1}}],[\"减少语句的执行时间\",{\"1\":{\"338\":1}}],[\"布隆过滤器是一种高效的数据结构\",{\"1\":{\"1283\":1}}],[\"布隆过滤器\",{\"1\":{\"627\":1}}],[\"布尔等\",{\"1\":{\"309\":1}}],[\"布尔\",{\"1\":{\"304\":1}}],[\"脚本将会被一个sigkill信号终止\",{\"1\":{\"624\":1}}],[\"脚本将不会重复执行\",{\"1\":{\"624\":1}}],[\"客观上认为主节点失联了\",{\"1\":{\"624\":1}}],[\"客户端检查事务状态\",{\"0\":{\"1946\":1}}],[\"客户端代码\",{\"1\":{\"1574\":1}}],[\"客户端或服务器均可主动发起挥手动作\",{\"1\":{\"1425\":1}}],[\"客户端执行connect时\",{\"1\":{\"1425\":1}}],[\"客户端执行完\",{\"1\":{\"469\":1}}],[\"客户端\",{\"1\":{\"1421\":4,\"1573\":1,\"1575\":1}}],[\"客户端会发一个请求到服务端\",{\"1\":{\"1421\":1}}],[\"客户端只支持java\",{\"1\":{\"1327\":1}}],[\"客户端只连接proxy\",{\"1\":{\"469\":1}}],[\"客户端也可以通过使用getset命令原子性地获取计数器的当前值并将计数器清零\",{\"1\":{\"1293\":1}}],[\"客户端时间+过期时长\",{\"1\":{\"1288\":1}}],[\"客户端读缓存时\",{\"1\":{\"1286\":1}}],[\"客户端发了请求后\",{\"1\":{\"1421\":4}}],[\"客户端发送请求可发给任意节点\",{\"1\":{\"1256\":1}}],[\"客户端发写数据的请求是\",{\"1\":{\"1256\":1}}],[\"客户端连接等事情\",{\"1\":{\"1224\":1}}],[\"客户端模式\",{\"1\":{\"1202\":1}}],[\"客户端重新配置主节点参数脚本\",{\"1\":{\"624\":1}}],[\"客户端订阅\",{\"1\":{\"599\":1}}],[\"客户端可以指定将这数据存储在哪个字典中\",{\"1\":{\"567\":1}}],[\"客户端在连接成功后\",{\"1\":{\"482\":1}}],[\"客户端缓存\",{\"0\":{\"482\":1}}],[\"客户端虽然断开了连接\",{\"1\":{\"481\":1}}],[\"客户端是在发完trx1更新后发起的select语句\",{\"1\":{\"472\":1}}],[\"客户端无需关心后端的细节\",{\"1\":{\"469\":1}}],[\"客户端都会感知到\",{\"1\":{\"469\":1}}],[\"客户端直连方案\",{\"1\":{\"469\":1}}],[\"客户端直连和带proxy的读写分离架构的优劣势\",{\"1\":{\"469\":1}}],[\"客户端查询看不到之前执行完成的事务\",{\"1\":{\"459\":1}}],[\"客户端的指令通过队列来排队进行顺序处理\",{\"1\":{\"604\":1}}],[\"客户端的读写都直接访问节点a\",{\"1\":{\"453\":1}}],[\"客户端的应用程序会接收全部的结果集数据\",{\"1\":{\"383\":1}}],[\"客户端还要自己拼接sql语句和结果\",{\"1\":{\"401\":1}}],[\"客户端再次发送请求的话\",{\"1\":{\"318\":1}}],[\"客户端如果太长时间没有动静\",{\"1\":{\"318\":1}}],[\"哨兵是一个独立的进程\",{\"1\":{\"1291\":1}}],[\"哨兵主观上认为主节点下线\",{\"1\":{\"624\":1}}],[\"哨兵sentinel监控的redis主节点的\",{\"1\":{\"624\":1}}],[\"哨兵sentinel的工作目录\",{\"1\":{\"624\":1}}],[\"哨兵sentinel实例运行的端口\",{\"1\":{\"624\":1}}],[\"哨兵集群\",{\"1\":{\"623\":1}}],[\"哨兵模式是redis一种特殊的模式\",{\"1\":{\"1291\":1}}],[\"哨兵模式是主从模式的升级\",{\"1\":{\"623\":1}}],[\"哨兵模式优缺点\",{\"0\":{\"622\":1}}],[\"哨兵模式与主从复制的区别\",{\"1\":{\"621\":1}}],[\"哨兵的核心配置\",{\"1\":{\"621\":1}}],[\"哨兵的作用\",{\"1\":{\"620\":1}}],[\"费事费力\",{\"1\":{\"619\":1}}],[\"心跳机制\",{\"0\":{\"661\":1}}],[\"心跳机制了解么\",{\"0\":{\"213\":1,\"1230\":1}}],[\"心跳\",{\"0\":{\"617\":1}}],[\"认证和授权也是对一个权限认证框架进行评估的两个主要的方面\",{\"1\":{\"1199\":1}}],[\"认证\",{\"1\":{\"1199\":1}}],[\"认为应该使用setter注入\",{\"1\":{\"912\":1}}],[\"认为这是不同的表\",{\"1\":{\"425\":1}}],[\"认为这是同一张表\",{\"1\":{\"425\":1}}],[\"认老大\",{\"1\":{\"610\":1}}],[\"角色的类\",{\"1\":{\"1134\":1}}],[\"角色\",{\"1\":{\"609\":1}}],[\"负数表示正在初始化或扩容\",{\"1\":{\"1554\":1}}],[\"负载加载用户自定义路径下的类包\",{\"1\":{\"1663\":1}}],[\"负载加载支撑jvm运行的位于jre的lib目录下的核心类库\",{\"1\":{\"1663\":1}}],[\"负载因子越大\",{\"1\":{\"1546\":1}}],[\"负载因子loadfactor默认值是0\",{\"1\":{\"1546\":1}}],[\"负载因子\",{\"1\":{\"1546\":1}}],[\"负载问题\",{\"1\":{\"1304\":1}}],[\"负载均衡\",{\"0\":{\"1851\":1},\"1\":{\"607\":1}}],[\"负责管理和启动各个service\",{\"1\":{\"1685\":1}}],[\"负责网络字节流与request和response对象的转化\",{\"1\":{\"1683\":1}}],[\"负责加载classpath路径下的类包\",{\"1\":{\"1663\":1}}],[\"负责加载支撑jvm运行的位于jre的lib目录下的ext目录下的类库\",{\"1\":{\"1663\":1}}],[\"负责读写操作\",{\"1\":{\"1224\":1}}],[\"负责最基础的功能支撑\",{\"1\":{\"645\":1}}],[\"负责具体的sql查找\",{\"1\":{\"645\":1}}],[\"负责存储相关的具体事宜\",{\"1\":{\"325\":1}}],[\"复用了aspectj中的几个核心注解\",{\"1\":{\"1654\":1}}],[\"复用现有的beandefinition\",{\"1\":{\"928\":1}}],[\"复合类型转换\",{\"1\":{\"1090\":1}}],[\"复合\",{\"1\":{\"1089\":2}}],[\"复合缓冲区\",{\"0\":{\"721\":1}}],[\"复制算法\",{\"0\":{\"1721\":1},\"1\":{\"1441\":3}}],[\"复制是需要时间的\",{\"1\":{\"1200\":1}}],[\"复制过程\",{\"0\":{\"613\":1}}],[\"复制原理\",{\"0\":{\"612\":1}}],[\"复制到其他的redis服务器\",{\"1\":{\"606\":1}}],[\"复杂性永远都是存在的\",{\"1\":{\"1612\":1}}],[\"复杂度\",{\"1\":{\"589\":1}}],[\"复杂查询\",{\"0\":{\"392\":1}}],[\"响应\",{\"1\":{\"1474\":2}}],[\"响应队列\",{\"0\":{\"605\":1}}],[\"响应时间既可能是一个问题的结果也可能是一个问题的原因\",{\"1\":{\"388\":1}}],[\"响应时间并没有什么一致的规律或者公示\",{\"1\":{\"388\":1}}],[\"响应时间是两个部分之和\",{\"1\":{\"388\":1}}],[\"响应时间\",{\"0\":{\"388\":1},\"1\":{\"387\":1}}],[\"事实上\",{\"1\":{\"1565\":1,\"1604\":1}}],[\"事件发布\",{\"1\":{\"1636\":1}}],[\"事件发生事件戳\",{\"1\":{\"1111\":1}}],[\"事件或者任务\",{\"1\":{\"1505\":1}}],[\"事件回调\",{\"1\":{\"1423\":1}}],[\"事件循环\",{\"1\":{\"1224\":1}}],[\"事件类型\",{\"1\":{\"1112\":1,\"1126\":2}}],[\"事件注解\",{\"1\":{\"1110\":1}}],[\"事件接口\",{\"1\":{\"1109\":1}}],[\"事件监听器\",{\"1\":{\"1108\":1}}],[\"事件对象\",{\"1\":{\"1108\":1}}],[\"事件集合描述符\",{\"1\":{\"1075\":1}}],[\"事件机制\",{\"1\":{\"916\":1}}],[\"事件\",{\"1\":{\"909\":1,\"921\":1,\"1073\":1,\"1109\":1,\"1110\":1,\"1116\":1,\"1477\":1}}],[\"事件驱动\",{\"1\":{\"903\":1}}],[\"事件中的应用\",{\"0\":{\"856\":1}}],[\"事件轮询\",{\"1\":{\"603\":1}}],[\"事务可能就会失效\",{\"1\":{\"1655\":1}}],[\"事务消息\",{\"0\":{\"1938\":1},\"1\":{\"1328\":1}}],[\"事务一致性问题\",{\"1\":{\"1270\":1}}],[\"事务串行化\",{\"1\":{\"1474\":1}}],[\"事务串行\",{\"1\":{\"1262\":1}}],[\"事务开始就不会终止\",{\"1\":{\"1262\":1}}],[\"事务无论是完成还是失败\",{\"1\":{\"1262\":1}}],[\"事务是不可分割的\",{\"1\":{\"1262\":1}}],[\"事务是可见的\",{\"1\":{\"542\":1}}],[\"事务失效\",{\"1\":{\"1239\":1}}],[\"事务抽象\",{\"1\":{\"893\":1,\"900\":1,\"916\":1}}],[\"事务管理\",{\"1\":{\"645\":1}}],[\"事务正常执行\",{\"1\":{\"581\":1}}],[\"事务错误\",{\"0\":{\"580\":1}}],[\"事务中每条命令都会被序列化\",{\"1\":{\"578\":1}}],[\"事务中的mdl锁\",{\"1\":{\"441\":1}}],[\"事务以及不同级别磁盘持久化功能\",{\"1\":{\"568\":1}}],[\"事务\",{\"1\":{\"566\":1,\"891\":1,\"1262\":1}}],[\"事务才真正启动\",{\"1\":{\"542\":1}}],[\"事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read\",{\"1\":{\"542\":1}}],[\"事务里面涉及到的表会被加到对应的哈希表中\",{\"1\":{\"461\":1}}],[\"事务提交\",{\"1\":{\"542\":1}}],[\"事务提交后\",{\"1\":{\"542\":1}}],[\"事务提交的时候\",{\"1\":{\"450\":2,\"472\":1}}],[\"事务及其属性\",{\"0\":{\"532\":1}}],[\"事务回滚也会发生类似的情况\",{\"1\":{\"491\":1}}],[\"事务回滚\",{\"1\":{\"491\":1}}],[\"事务完成\",{\"1\":{\"472\":1}}],[\"事务id是当前事务\",{\"1\":{\"542\":1}}],[\"事务id是在事务执行过程中分配的\",{\"1\":{\"468\":1}}],[\"事务id和回滚指针\",{\"1\":{\"542\":1}}],[\"事务id\",{\"1\":{\"542\":2}}],[\"事务id也会递增\",{\"1\":{\"468\":1}}],[\"事务哈希表还需要考虑唯一键\",{\"1\":{\"462\":1}}],[\"事务t跟多余一个worker冲突\",{\"1\":{\"461\":1}}],[\"事务t和队列中的某个事务要修改同一个表的数据\",{\"1\":{\"461\":1}}],[\"事务并不能简单的按照轮询的方式分发给各个worker\",{\"1\":{\"460\":1}}],[\"事务执行期间\",{\"1\":{\"1297\":1}}],[\"事务执行\",{\"1\":{\"579\":1}}],[\"事务执行中间过程中的redo\",{\"1\":{\"451\":1}}],[\"事务执行过程中\",{\"1\":{\"450\":1}}],[\"事务在执行过程中\",{\"1\":{\"451\":1}}],[\"事务在执行期间看到的数据前后必须是一致的\",{\"1\":{\"433\":1}}],[\"事务a读取到了事务b提交的新增数据\",{\"1\":{\"532\":1}}],[\"事务a读取到了事务b已经修改但尚未提交的数据\",{\"1\":{\"532\":1}}],[\"事务a内部相同查询语句在不同时刻读出的结果不一致\",{\"1\":{\"532\":1}}],[\"事务a和事务b在互相等待对方的资源释放\",{\"1\":{\"444\":1}}],[\"事务a在等待事务b释放id=2的行锁\",{\"1\":{\"444\":1}}],[\"事务a持有两个记录的行锁\",{\"1\":{\"443\":1}}],[\"事务a会查询到的v1\",{\"1\":{\"433\":1}}],[\"事务不提交\",{\"1\":{\"441\":1}}],[\"事务的执行过程\",{\"1\":{\"1655\":1}}],[\"事务的并发性能也会越低\",{\"1\":{\"1262\":1}}],[\"事务的安全性是更高的\",{\"1\":{\"1262\":1}}],[\"事务的特性\",{\"1\":{\"1262\":1}}],[\"事务的实现方式\",{\"1\":{\"561\":1}}],[\"事务的隔离级别\",{\"1\":{\"532\":1}}],[\"事务的begin之前有一条set\",{\"1\":{\"468\":1}}],[\"事务的启动方式\",{\"0\":{\"435\":1}}],[\"事务的基本特性和隔离级别\",{\"0\":{\"153\":1,\"1262\":1}}],[\"事务b正确提交了\",{\"1\":{\"491\":1}}],[\"事务b申请到id=3\",{\"1\":{\"491\":1}}],[\"事务b要把redo\",{\"1\":{\"451\":1}}],[\"事务b才能继续执行\",{\"1\":{\"443\":1}}],[\"事务b才可以继续执行\",{\"1\":{\"433\":1}}],[\"事务b也要更新同一行\",{\"1\":{\"442\":1}}],[\"事务b的更新在提交后才能被a看到\",{\"1\":{\"433\":1}}],[\"事务支持是在引擎层实现的\",{\"1\":{\"432\":1}}],[\"事务具有acid\",{\"1\":{\"432\":1}}],[\"事务就可以生效\",{\"1\":{\"1630\":1}}],[\"事务就可以完成了\",{\"1\":{\"345\":1}}],[\"事务就是要保证一组操作\",{\"1\":{\"432\":1}}],[\"事务隔离的实现\",{\"0\":{\"434\":1}}],[\"事务隔离\",{\"0\":{\"432\":1},\"1\":{\"1261\":1}}],[\"事务性\",{\"1\":{\"301\":1}}],[\"答案就是调用summarystatistics\",{\"1\":{\"1610\":1}}],[\"答案就是多路复用\",{\"1\":{\"601\":1}}],[\"答案是会在控制台打印出\",{\"1\":{\"1612\":1}}],[\"答案是否定的\",{\"1\":{\"1612\":1}}],[\"答案是什么都不会\",{\"1\":{\"1610\":1}}],[\"答案是肯定的\",{\"1\":{\"967\":1}}],[\"答案是为了性能\",{\"1\":{\"491\":1}}],[\"答案是\",{\"1\":{\"396\":1}}],[\"稍微复杂的场景\",{\"1\":{\"601\":1}}],[\"稍微往前\",{\"1\":{\"467\":1}}],[\"起始版本\",{\"1\":{\"1023\":5,\"1024\":1,\"1029\":2,\"1093\":1,\"1102\":1,\"1103\":1,\"1131\":3,\"1140\":2}}],[\"起始更多是使用消息队列来进行实现\",{\"1\":{\"601\":1}}],[\"起止元素\",{\"1\":{\"571\":1}}],[\"起止位置都取\",{\"1\":{\"570\":1}}],[\"微博关注等等\",{\"1\":{\"601\":1}}],[\"微服务和分布式\",{\"0\":{\"1988\":1}}],[\"微服务之间只能通过接口进行服务调用\",{\"1\":{\"1308\":1}}],[\"微服务之间尽量不要有业务交叉\",{\"1\":{\"1308\":1}}],[\"微服务是一种架构风格\",{\"1\":{\"1304\":1}}],[\"微服务是由martin\",{\"1\":{\"1304\":1}}],[\"微服务下服务a调用服务b的流程\",{\"0\":{\"238\":1,\"1318\":1}}],[\"微服务的链路追踪\",{\"0\":{\"230\":1,\"1310\":1}}],[\"微服务有哪些优缺点\",{\"0\":{\"224\":1,\"1304\":1}}],[\"微服务\",{\"0\":{\"223\":1,\"1303\":1}}],[\"退缩不前\",{\"1\":{\"1531\":1}}],[\"退订则就是将客户端节点从链表中移除\",{\"1\":{\"599\":1}}],[\"退订一个或多个频道\",{\"1\":{\"597\":1}}],[\"退订一个或多个符合给定模式的频道\",{\"1\":{\"597\":1}}],[\"退化的逻辑大概如下\",{\"1\":{\"462\":1}}],[\"丢数据\",{\"1\":{\"595\":1}}],[\"丢掉前y个\",{\"1\":{\"422\":1}}],[\"体积\",{\"1\":{\"595\":1}}],[\"低谷期\",{\"1\":{\"1509\":1}}],[\"低耦合\",{\"1\":{\"1308\":1}}],[\"低耦合的微服务\",{\"0\":{\"228\":1,\"1308\":1}}],[\"低依赖\",{\"1\":{\"958\":1}}],[\"低入侵性\",{\"1\":{\"911\":1}}],[\"低\",{\"1\":{\"595\":1,\"1554\":1,\"1576\":1}}],[\"修复之后我们就可以再次重新启动redis服务器了\",{\"1\":{\"1297\":1}}],[\"修复速度比rdb慢\",{\"1\":{\"593\":1}}],[\"修改传入参数的引用\",{\"1\":{\"1623\":1}}],[\"修改一下程序\",{\"1\":{\"1619\":1}}],[\"修改一条记录时\",{\"1\":{\"542\":1}}],[\"修改阈值\",{\"1\":{\"1550\":1}}],[\"修改阈值为int的最大值\",{\"1\":{\"1550\":1}}],[\"修改普通用户可以创建的最大线程数\",{\"1\":{\"1257\":1}}],[\"修改虚拟内存大小\",{\"1\":{\"1257\":1}}],[\"修改后的userholder类\",{\"1\":{\"1003\":1}}],[\"修改之前\",{\"0\":{\"883\":1}}],[\"修改sql\",{\"1\":{\"646\":1}}],[\"修改配置文件\",{\"1\":{\"620\":1}}],[\"修改生效\",{\"1\":{\"581\":1}}],[\"修改了线程一中监视的money\",{\"1\":{\"581\":1}}],[\"修改中间元素\",{\"1\":{\"571\":1}}],[\"修改对当前事务不可见\",{\"1\":{\"542\":1}}],[\"修改该行age为30岁\",{\"1\":{\"542\":1}}],[\"修改该行name为tom\",{\"1\":{\"542\":1}}],[\"修改数据的过程如下\",{\"1\":{\"542\":1}}],[\"修改的数据的过程如下\",{\"1\":{\"542\":1}}],[\"修改\",{\"1\":{\"542\":1,\"1147\":1}}],[\"修改则会被阻塞\",{\"1\":{\"537\":1}}],[\"修改同一行\",{\"1\":{\"462\":1}}],[\"修改同一个表\",{\"1\":{\"462\":1}}],[\"修改global变量的方式影响面更大\",{\"1\":{\"438\":1}}],[\"修改表结构\",{\"1\":{\"437\":1}}],[\"修改long\",{\"1\":{\"428\":1}}],[\"修改语句\",{\"1\":{\"348\":1}}],[\"修改完成后\",{\"1\":{\"318\":1}}],[\"修改daynamic\",{\"1\":{\"309\":1}}],[\"修改dynamic后再次插入文档成功\",{\"1\":{\"309\":1}}],[\"修改索引配置\",{\"1\":{\"305\":1}}],[\"修改删除操作\",{\"1\":{\"304\":1}}],[\"没法再对这些节点进行进一步的分割\",{\"1\":{\"1620\":1}}],[\"没超过最大值\",{\"1\":{\"1550\":1}}],[\"没秒同步一次\",{\"1\":{\"593\":1}}],[\"没有人可以一开始\",{\"1\":{\"1972\":1}}],[\"没有添加事件监听器的功能\",{\"1\":{\"1637\":1}}],[\"没有设置运行时环境的功能\",{\"1\":{\"1637\":1}}],[\"没有效率的trysplit会是的并发执行的效率急剧下降\",{\"1\":{\"1620\":1}}],[\"没有cpu拷贝数据环节\",{\"1\":{\"1585\":2}}],[\"没有等待数据它不会等待\",{\"1\":{\"1574\":1}}],[\"没有描述符限制\",{\"1\":{\"1571\":1}}],[\"没有hash冲突的话为0\",{\"1\":{\"1554\":1}}],[\"没有修改操作\",{\"1\":{\"1526\":1}}],[\"没有写操作\",{\"1\":{\"1526\":1}}],[\"没有写请求或者有写请求\",{\"1\":{\"1498\":1}}],[\"没有重新设置线程的中断状态\",{\"1\":{\"1524\":1}}],[\"没有异常处理\",{\"1\":{\"1516\":1}}],[\"没有其他线程的读锁\",{\"1\":{\"1498\":1}}],[\"没有其他线程的写锁\",{\"1\":{\"1498\":2}}],[\"没有其它活跃的读写事务时\",{\"1\":{\"542\":1}}],[\"没有遇到并发竞争时\",{\"1\":{\"1480\":1}}],[\"没有足够的空间供其使用\",{\"1\":{\"1451\":1}}],[\"没有返回值\",{\"1\":{\"1346\":1}}],[\"没有一个稳定的技术框架\",{\"1\":{\"1309\":1}}],[\"没有了线程上下文切换的性能耗损\",{\"1\":{\"1292\":1}}],[\"没有特殊的意义\",{\"1\":{\"1203\":1}}],[\"没有性能问题\",{\"1\":{\"637\":1}}],[\"没有结果\",{\"1\":{\"581\":1}}],[\"没有注释而且这些微调的值十分的小\",{\"1\":{\"548\":1}}],[\"没有id=2的行\",{\"1\":{\"491\":1}}],[\"没有视图概念\",{\"1\":{\"433\":1}}],[\"没有分区的key也需要访问所有的分区表\",{\"1\":{\"425\":1}}],[\"没有用临时表了\",{\"1\":{\"414\":1}}],[\"没有用到a字段\",{\"1\":{\"377\":1}}],[\"没有用到覆盖索引\",{\"1\":{\"373\":1}}],[\"没有用到索引\",{\"1\":{\"330\":1}}],[\"没有机会进入young区域\",{\"1\":{\"406\":1}}],[\"没有什么索引能够让这样的查询减少需要扫描的行数\",{\"1\":{\"390\":1}}],[\"没有哪个指标能够完美地衡量查询的开销\",{\"1\":{\"387\":1}}],[\"没有产生using\",{\"1\":{\"378\":1}}],[\"没有额外的代价\",{\"1\":{\"347\":1}}],[\"父类索引与接口索引集合\",{\"0\":{\"1779\":1}}],[\"父结点的键值总是小于或等于任何一个子结点的键值\",{\"1\":{\"1506\":1}}],[\"父结点的键值总是大于或等于任何一个子结点的键值\",{\"1\":{\"1506\":1}}],[\"父接口\",{\"1\":{\"1159\":1}}],[\"父\",{\"1\":{\"1136\":1}}],[\"父子beandefinition合并\",{\"1\":{\"997\":1}}],[\"父进程修改内存子进程不会反应出来\",{\"1\":{\"1290\":1}}],[\"父进程更新统计信息\",{\"1\":{\"588\":1}}],[\"父进程创建rdb文件\",{\"1\":{\"588\":1}}],[\"父进程fork完成后\",{\"1\":{\"588\":1}}],[\"父进程执行fork操作创建子进程\",{\"1\":{\"588\":1}}],[\"父节点又小于右儿子\",{\"1\":{\"334\":1}}],[\"线上环境不建议使用\",{\"1\":{\"587\":1}}],[\"线程状态\",{\"0\":{\"1814\":1}}],[\"线程的实现\",{\"0\":{\"1812\":1}}],[\"线程上下文类加载器\",{\"0\":{\"1694\":1}}],[\"线程消耗\",{\"1\":{\"1573\":1}}],[\"线程一被调度回来执行\",{\"1\":{\"1551\":1}}],[\"线程一直被调度器延迟访问其赖以执行的资源\",{\"1\":{\"1390\":1}}],[\"线程会因为竞争不到锁而被挂起\",{\"1\":{\"1519\":1}}],[\"线程会从其他繁忙线程双端队列的尾部中获取任务\",{\"1\":{\"1511\":1}}],[\"线程数就随之减少\",{\"1\":{\"1510\":1}}],[\"线程数就随之增加\",{\"1\":{\"1510\":1}}],[\"线程数=cpu核心线程数∗\",{\"1\":{\"1510\":1}}],[\"线程数计算方法\",{\"1\":{\"1510\":1}}],[\"线程数过高\",{\"1\":{\"476\":1}}],[\"线程t才能获取写锁进行数据更新\",{\"1\":{\"1498\":1}}],[\"线程进入写锁的前提条件\",{\"1\":{\"1498\":1}}],[\"线程进入读锁的前提条件\",{\"1\":{\"1498\":1}}],[\"线程竞争锁失败入队阻塞逻辑和获取锁的线程释放锁唤醒阻塞线程竞争锁的逻辑实现\",{\"1\":{\"1494\":1}}],[\"线程由原自旋机制改为阻塞机制\",{\"1\":{\"1491\":1}}],[\"线程逃逸\",{\"1\":{\"1488\":1}}],[\"线程持有的锁\",{\"1\":{\"1484\":1}}],[\"线程持续重试一个总是失败的操作\",{\"1\":{\"1389\":1}}],[\"线程真正创建线程的过程如下\",{\"1\":{\"1477\":1}}],[\"线程互斥可以看成是一种特殊的线程同步\",{\"1\":{\"1477\":1}}],[\"线程互斥是指对于共享的进程系统资源\",{\"1\":{\"1477\":1}}],[\"线程同步\",{\"1\":{\"1477\":1}}],[\"线程工厂模式\",{\"1\":{\"1534\":1}}],[\"线程工厂\",{\"1\":{\"1476\":1}}],[\"线程本地存储模式本质上就是一种避免共享的方法\",{\"1\":{\"1528\":1}}],[\"线程本地存储模式\",{\"1\":{\"1528\":1}}],[\"线程本地存储\",{\"1\":{\"1392\":1}}],[\"线程对立是那些不管是否采用了同步措施\",{\"1\":{\"1391\":1}}],[\"线程对立\",{\"1\":{\"1391\":1}}],[\"线程兼容类不是线程安全的\",{\"1\":{\"1391\":1}}],[\"线程兼容\",{\"1\":{\"1391\":1}}],[\"线程都不需要任何额外的同步\",{\"1\":{\"1391\":1}}],[\"线程调度器会从线程就绪队列里面获取一个线程优先级最高的线程\",{\"1\":{\"1383\":1}}],[\"线程就会释放锁\",{\"1\":{\"1381\":1}}],[\"线程就可以继续挨个处理相应的事件\",{\"1\":{\"603\":1}}],[\"线程必须持有对象的锁\",{\"1\":{\"1381\":1}}],[\"线程隶属于进程\",{\"1\":{\"1377\":1}}],[\"线程是cpu调度的最小单位\",{\"1\":{\"1477\":1}}],[\"线程是稀缺资源\",{\"1\":{\"1407\":1}}],[\"线程是操作系统任务分配的最小单位\",{\"1\":{\"1377\":1}}],[\"线程是操作系统调度的最小的单元\",{\"1\":{\"1374\":1}}],[\"线程是进程当中的一条执行流程\",{\"1\":{\"1374\":1}}],[\"线程切换带来的原子性问题\",{\"1\":{\"1373\":1}}],[\"线程安全性\",{\"0\":{\"1551\":1}}],[\"线程安全性的问题主要体现在\",{\"1\":{\"1373\":1}}],[\"线程安全\",{\"0\":{\"1815\":1},\"1\":{\"1341\":1,\"1342\":1,\"1526\":1,\"1539\":1}}],[\"线程安全的实现方法有哪些\",{\"0\":{\"63\":1,\"1392\":1}}],[\"线程不安全\",{\"1\":{\"1191\":1,\"1341\":1}}],[\"线程\",{\"1\":{\"1113\":1,\"1119\":1,\"1123\":1,\"1175\":1,\"1484\":1,\"1664\":1}}],[\"线程处于阻塞状态\",{\"1\":{\"603\":1}}],[\"线程处于空闲状态\",{\"1\":{\"476\":1}}],[\"线程也应该得到通知\",{\"1\":{\"603\":1}}],[\"线程如何得到通知\",{\"1\":{\"603\":1}}],[\"线程如何知道何时才应该继续\",{\"1\":{\"603\":1}}],[\"线程才能继续处理\",{\"1\":{\"602\":1}}],[\"线程2\",{\"1\":{\"581\":2}}],[\"线程2到线程129都执行update\",{\"1\":{\"476\":1}}],[\"线程1等待线程2互斥持有的资源\",{\"1\":{\"1389\":1}}],[\"线程1事务执行失败\",{\"1\":{\"581\":1}}],[\"线程1\",{\"1\":{\"581\":1}}],[\"线程1执行begin\",{\"1\":{\"476\":1}}],[\"线程没有执行到判断线程状态的逻辑\",{\"1\":{\"481\":1}}],[\"线程b并不知道这个状态变化\",{\"1\":{\"481\":1}}],[\"线程id\",{\"1\":{\"412\":1,\"480\":2}}],[\"线程池隔离\",{\"1\":{\"1517\":1}}],[\"线程池参数解析\",{\"1\":{\"1476\":1}}],[\"线程池执行过程示意图\",{\"1\":{\"1476\":1}}],[\"线程池底层原理\",{\"0\":{\"1476\":1},\"1\":{\"1476\":1}}],[\"线程池将丢弃被拒绝的任务\",{\"1\":{\"1410\":1}}],[\"线程池会放弃等待队列中最旧的未处理任务\",{\"1\":{\"1410\":1}}],[\"线程池\",{\"1\":{\"1196\":1}}],[\"线程池的原理等\",{\"1\":{\"1992\":1}}],[\"线程池的参数如何设置\",{\"0\":{\"84\":1,\"1413\":1}}],[\"线程池的拒绝策略\",{\"0\":{\"81\":1,\"1410\":1}}],[\"线程池中submit\",{\"0\":{\"79\":1,\"1408\":1}}],[\"线程有哪些状态\",{\"0\":{\"49\":1,\"1378\":1}}],[\"线程和进程的区别\",{\"0\":{\"45\":1,\"1374\":1}}],[\"触发条件\",{\"1\":{\"946\":1}}],[\"触发rdb持久化过程可以分为手动触发和自动触发\",{\"1\":{\"586\":1}}],[\"触发器\",{\"1\":{\"317\":1}}],[\"工资总和\",{\"1\":{\"1615\":1}}],[\"工资表排序\",{\"1\":{\"574\":1}}],[\"工具\",{\"1\":{\"1454\":1}}],[\"工具为类生成帮助文档时是否要保留其注解信息\",{\"1\":{\"1133\":1}}],[\"工具类参考博客\",{\"1\":{\"584\":1}}],[\"工厂创建\",{\"1\":{\"1103\":1}}],[\"工厂方法\",{\"1\":{\"1103\":1}}],[\"工厂方法模式\",{\"0\":{\"836\":1}}],[\"工作队列\",{\"0\":{\"1512\":1}}],[\"工作线程从它自己的双端队列的头部获取任务\",{\"1\":{\"1511\":1}}],[\"工作线程的创建\",{\"1\":{\"1510\":1}}],[\"工作窃取\",{\"0\":{\"1511\":1},\"1\":{\"1511\":1}}],[\"工作原理\",{\"0\":{\"587\":1}}],[\"工作中一般不会这样使用\",{\"1\":{\"584\":1}}],[\"序列化方式\",{\"1\":{\"583\":1}}],[\"序列化设置\",{\"1\":{\"583\":1}}],[\"序列号\",{\"1\":{\"412\":1}}],[\"否\",{\"1\":{\"944\":2,\"974\":3,\"980\":1,\"992\":1,\"1439\":1,\"1576\":3}}],[\"否者就全是乱码\",{\"1\":{\"583\":1}}],[\"否则返回\",{\"1\":{\"1620\":1}}],[\"否则返回false\",{\"1\":{\"1599\":1,\"1620\":1}}],[\"否则一些错误的型为就可能会产生并发修改的异常\",{\"1\":{\"1619\":1}}],[\"否则将他们返回给汇聚操作的调用者\",{\"1\":{\"1615\":1}}],[\"否则直接抛出了nullpointerexception异常\",{\"1\":{\"1554\":1}}],[\"否则进行链表的插入操作\",{\"1\":{\"1549\":1}}],[\"否则转向步骤5\",{\"1\":{\"1549\":1}}],[\"否则转向步骤4\",{\"1\":{\"1549\":1}}],[\"否则转向步骤3\",{\"1\":{\"1549\":1}}],[\"否则执行resize\",{\"1\":{\"1549\":1}}],[\"否则会在运行时抛出java\",{\"1\":{\"1544\":1}}],[\"否则8字节\",{\"1\":{\"1484\":1}}],[\"否则容易出现异常行为\",{\"1\":{\"1129\":1}}],[\"否则null\",{\"1\":{\"1100\":1}}],[\"否则为\",{\"1\":{\"1020\":3}}],[\"否则sentinel无法正常启动成功\",{\"1\":{\"624\":1}}],[\"否则只对optimizer\",{\"1\":{\"556\":1}}],[\"否则只沿着区间最左记录向右读10个页面\",{\"1\":{\"549\":1}}],[\"否则使用的磁盘文件排序\",{\"1\":{\"520\":1}}],[\"否则根本不会执行到\",{\"1\":{\"481\":1}}],[\"否则创建主备关系的时候就会报错\",{\"1\":{\"478\":1}}],[\"否则持续重试这一步\",{\"1\":{\"458\":1}}],[\"否则就单方面地将\",{\"1\":{\"1479\":1}}],[\"否则就用statement格式\",{\"1\":{\"454\":1}}],[\"否则就需要额外的内存\",{\"1\":{\"418\":1}}],[\"否则就需要放在临时文件中排序\",{\"1\":{\"354\":1}}],[\"否则出现爆屏的情况\",{\"1\":{\"429\":1}}],[\"否则跳过\",{\"1\":{\"407\":1}}],[\"否则不加\",{\"1\":{\"399\":1}}],[\"否则\",{\"1\":{\"326\":1,\"473\":1,\"474\":1,\"1266\":1,\"1503\":1,\"1620\":2,\"1621\":1,\"1647\":1,\"1655\":1}}],[\"否则先删除现有文档\",{\"1\":{\"306\":1}}],[\"惊奇发现全是乱码\",{\"1\":{\"583\":1}}],[\"测试的难度提升了\",{\"1\":{\"1304\":1}}],[\"测试示例\",{\"1\":{\"1184\":1}}],[\"测试配置属性源\",{\"0\":{\"1157\":1}}],[\"测试是否生效\",{\"1\":{\"1134\":1}}],[\"测试类\",{\"1\":{\"1084\":1}}],[\"测试我们的例子\",{\"1\":{\"1032\":1}}],[\"测试我们的注解是否生效\",{\"1\":{\"967\":1}}],[\"测试我们编写的案例\",{\"1\":{\"1030\":1}}],[\"测试输出\",{\"1\":{\"930\":2,\"1174\":1}}],[\"测试客户端\",{\"1\":{\"896\":1}}],[\"测试\",{\"1\":{\"621\":1,\"918\":1}}],[\"测试结果\",{\"1\":{\"583\":1}}],[\"测试事务\",{\"1\":{\"582\":1}}],[\"测试多线程修改值\",{\"1\":{\"581\":1}}],[\"测试用例\",{\"1\":{\"309\":1}}],[\"监听网络端口\",{\"1\":{\"1687\":1}}],[\"监听固定端口接收外部请求\",{\"1\":{\"1687\":1}}],[\"监听读事件\",{\"1\":{\"1574\":1}}],[\"监听连接事件\",{\"1\":{\"1574\":1}}],[\"监听事件的时候\",{\"1\":{\"1125\":1}}],[\"监听实现原理\",{\"0\":{\"1125\":1}}],[\"监听到客户端连接请求后为每一个客户端创建一个新的线程链路进行处理\",{\"1\":{\"1573\":1}}],[\"监听到事件\",{\"1\":{\"1119\":1}}],[\"监听到\",{\"1\":{\"1116\":1}}],[\"监听器注解\",{\"1\":{\"1110\":1}}],[\"监听器注解场景举例\",{\"1\":{\"1110\":1}}],[\"监听器接口\",{\"1\":{\"1109\":1}}],[\"监听器场景举例\",{\"1\":{\"1109\":1}}],[\"监听器设计模式\",{\"0\":{\"1109\":1,\"1110\":1}}],[\"监听器编程模型\",{\"0\":{\"1108\":1}}],[\"监听者模式\",{\"0\":{\"1959\":1}}],[\"监听者\",{\"1\":{\"1108\":1}}],[\"监视\",{\"1\":{\"1565\":1}}],[\"监视器锁\",{\"1\":{\"1484\":1}}],[\"监视器\",{\"1\":{\"1483\":1}}],[\"监视值没有被中途修改\",{\"1\":{\"581\":1}}],[\"监视money\",{\"1\":{\"581\":1}}],[\"监控和调优\",{\"1\":{\"1407\":1}}],[\"监控\",{\"0\":{\"581\":1},\"1\":{\"1304\":1}}],[\"支付宝回调接口\",{\"1\":{\"1248\":1}}],[\"支付接口\",{\"1\":{\"1248\":1}}],[\"支出使用\",{\"1\":{\"581\":1}}],[\"支持beanpostpropcessor\",{\"1\":{\"1647\":1}}],[\"支持在创建bean的过程中能对bean进行自动装配\",{\"1\":{\"1636\":1}}],[\"支持在一次api调用中\",{\"1\":{\"307\":1}}],[\"支持了factorybean的功能\",{\"1\":{\"1636\":1}}],[\"支持了按库并行的复制策略\",{\"1\":{\"463\":1}}],[\"支持别名功能\",{\"1\":{\"1636\":2}}],[\"支持的变化包括无序的遍历\",{\"1\":{\"1623\":1}}],[\"支持的功能也不同\",{\"1\":{\"317\":1}}],[\"支持基于文件的异步io操作和针对套接字的异步io操作等功能\",{\"1\":{\"1572\":2}}],[\"支持并行地调用度多个服务实例\",{\"1\":{\"1517\":1}}],[\"支持按优先级排序的无界阻塞队列\",{\"1\":{\"1501\":1}}],[\"支持非公平\",{\"1\":{\"1498\":1}}],[\"支持查询附近位置\",{\"1\":{\"1280\":1}}],[\"支持添加\",{\"1\":{\"1280\":1}}],[\"支持对集合进行添加\",{\"1\":{\"1280\":1}}],[\"支持对列表进行修剪和范围查询\",{\"1\":{\"1280\":1}}],[\"支持外键\",{\"1\":{\"1260\":1}}],[\"支持行锁\",{\"1\":{\"1260\":1}}],[\"支持\",{\"1\":{\"1113\":3}}],[\"支持多个条件变量\",{\"1\":{\"1494\":1}}],[\"支持多种依赖查找方式\",{\"1\":{\"1131\":1}}],[\"支持多种依赖查找的方式\",{\"1\":{\"1023\":1}}],[\"支持多applicationevent类型\",{\"1\":{\"1113\":1}}],[\"支持多线程的redis\",{\"1\":{\"601\":1}}],[\"支持网络\",{\"1\":{\"564\":1}}],[\"支持innodb\",{\"1\":{\"317\":1}}],[\"支持嵌套属性路径\",{\"1\":{\"1074\":1}}],[\"支持嵌套属性\",{\"1\":{\"1072\":2}}],[\"支持嵌套\",{\"1\":{\"304\":1}}],[\"支持数组\",{\"1\":{\"304\":1}}],[\"编辑操作\",{\"1\":{\"1531\":1}}],[\"编译原理\",{\"1\":{\"1966\":1}}],[\"编译sql语句\",{\"0\":{\"1908\":1}}],[\"编译通过但执行报错\",{\"1\":{\"1620\":1}}],[\"编译器都可以自动的推断出元素的类型\",{\"1\":{\"1614\":1}}],[\"编译器都可以自动推断类型\",{\"1\":{\"1593\":1}}],[\"编译器会认为此时的item是一个object类型的对象\",{\"1\":{\"1614\":1}}],[\"编译器会认为继承的优先级大于实现\",{\"1\":{\"1607\":1}}],[\"编译器会自动推断item的数据类型\",{\"1\":{\"1597\":1}}],[\"编译器会自动根据上下文\",{\"1\":{\"1595\":1}}],[\"编译器会自动将它看成是函数式接口\",{\"1\":{\"1594\":1}}],[\"编译器自动推断出了我们要想调用myinterface1impl中的mymethod\",{\"1\":{\"1607\":1}}],[\"编译器无法自动推断出要继承哪一个接口中的默认方法\",{\"1\":{\"1607\":1}}],[\"编译器就会提示我们不能解析构造方法\",{\"1\":{\"1600\":1}}],[\"编译器依旧会将该接口看作是函数式接口\",{\"1\":{\"1594\":1}}],[\"编译器其实会自动为满足函数式接口定义的接口添加\",{\"1\":{\"1594\":1}}],[\"编译器可以对代码做如下优化\",{\"1\":{\"1488\":1}}],[\"编译器将类型擦除应用于\",{\"1\":{\"1098\":1}}],[\"编译优化带来的有序性问题\",{\"1\":{\"1373\":1}}],[\"编译时强制类型检查\",{\"1\":{\"1098\":1}}],[\"编译时异常\",{\"1\":{\"580\":1}}],[\"编码资源接口\",{\"1\":{\"1040\":1}}],[\"编码资源\",{\"1\":{\"1038\":1}}],[\"编程逻辑复杂\",{\"1\":{\"1585\":1}}],[\"编程式事务可以用transactiontemlate\",{\"1\":{\"1238\":1}}],[\"编程\",{\"1\":{\"1107\":1}}],[\"编程条件装配\",{\"1\":{\"1023\":1}}],[\"编程模型相对简单\",{\"1\":{\"1421\":1}}],[\"编程模型最复杂\",{\"1\":{\"1421\":1}}],[\"编程模型最简单\",{\"1\":{\"1421\":1}}],[\"编程模型概览\",{\"1\":{\"1132\":1}}],[\"编程模型\",{\"1\":{\"900\":1}}],[\"编程方式创建\",{\"0\":{\"763\":1}}],[\"编写xml\",{\"1\":{\"1030\":1}}],[\"编写message\",{\"0\":{\"669\":1}}],[\"编写配置文件\",{\"1\":{\"583\":1}}],[\"编写sql语句并查看sql执行计划\",{\"1\":{\"361\":1}}],[\"未知的\",{\"1\":{\"1620\":1}}],[\"未来可能会定义一些新的characteristics\",{\"1\":{\"1620\":1}}],[\"未满就唤醒其它notfull上的线程\",{\"1\":{\"1503\":1}}],[\"未正确同步的多线程程序\",{\"1\":{\"1474\":1}}],[\"未同步\",{\"1\":{\"1474\":1}}],[\"未被引用\",{\"1\":{\"1435\":1}}],[\"未激活autowiring\",{\"1\":{\"952\":1}}],[\"未设置默认是0\",{\"1\":{\"578\":1}}],[\"未提交\",{\"1\":{\"542\":1}}],[\"未提交变更对其它事务也是不可见的\",{\"1\":{\"433\":1}}],[\"签到统计\",{\"1\":{\"578\":1}}],[\"估算基数\",{\"1\":{\"577\":1}}],[\"估算myelemx的基数\",{\"1\":{\"577\":1}}],[\"估计区间最左记录和区间最右记录之间有多少个页面\",{\"1\":{\"549\":1}}],[\"网上也有一些不错的文档教程网站\",{\"1\":{\"1969\":1}}],[\"网站计数器\",{\"1\":{\"1196\":1}}],[\"网页的访问量\",{\"1\":{\"577\":1}}],[\"网络编程\",{\"1\":{\"1969\":1}}],[\"网络通信\",{\"1\":{\"1687\":1}}],[\"网络通信等任务\",{\"1\":{\"1510\":1}}],[\"网络传输\",{\"1\":{\"1475\":1}}],[\"网络正常的情况下\",{\"1\":{\"457\":1}}],[\"网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击\",{\"1\":{\"626\":1}}],[\"网络安全\",{\"0\":{\"215\":1,\"1198\":1}}],[\"花费\",{\"1\":{\"577\":1}}],[\"花费更少的硬件资源\",{\"1\":{\"527\":1}}],[\"坐标500km半径内的成员\",{\"1\":{\"576\":1}}],[\"纬度\",{\"1\":{\"576\":1}}],[\"失败\",{\"1\":{\"573\":1}}],[\"迭代出的对象也是引用的拷贝\",{\"1\":{\"1353\":1}}],[\"迭代出来的元素都是原来集合元素的拷贝\",{\"1\":{\"1353\":1}}],[\"迭代器实现了iterabale接口的集合都可以使用迭代器来遍历\",{\"1\":{\"1353\":1}}],[\"迭代器是一种设计模式\",{\"1\":{\"1353\":1}}],[\"迭代器和for循环遍历的区别\",{\"0\":{\"24\":1,\"1353\":1}}],[\"迭代有序集合中的元素\",{\"1\":{\"574\":1}}],[\"迭代哈希表中的键值对\",{\"1\":{\"573\":1}}],[\"域\",{\"1\":{\"573\":1}}],[\"求最大值和最小值有可能为空\",{\"1\":{\"1610\":1}}],[\"求解\",{\"1\":{\"1510\":1}}],[\"求setx\",{\"1\":{\"572\":1}}],[\"求\",{\"1\":{\"572\":1}}],[\"交友了\",{\"1\":{\"1981\":1}}],[\"交给后面的function\",{\"1\":{\"1518\":1}}],[\"交换tcp窗口大小信息\",{\"1\":{\"1425\":1}}],[\"交集\",{\"1\":{\"572\":1}}],[\"交易编号tradeid这个字段上\",{\"1\":{\"367\":1}}],[\"交易时间\",{\"1\":{\"366\":1}}],[\"交易员id\",{\"1\":{\"366\":1}}],[\"移动对象\",{\"1\":{\"1439\":1}}],[\"移除\",{\"1\":{\"1620\":1,\"1636\":1}}],[\"移除score在\",{\"1\":{\"574\":1}}],[\"移除排名0~1的所有成员\",{\"1\":{\"574\":1}}],[\"移除字典区间\",{\"1\":{\"574\":1}}],[\"移除成员abc\",{\"1\":{\"574\":1}}],[\"移除有序集合中给定的分数区间的所有成员\",{\"1\":{\"574\":1}}],[\"移除有序集合中给定的排名区间的所有成员\",{\"1\":{\"574\":1}}],[\"移除有序集合中给定的字典区间的所有成员\",{\"1\":{\"574\":1}}],[\"移除有序集合中一个\",{\"1\":{\"574\":1}}],[\"移除集合中一个\",{\"1\":{\"572\":1}}],[\"移出并获取列表的第一个\",{\"1\":{\"571\":1}}],[\"弹出\",{\"1\":{\"571\":4}}],[\"栈帧\",{\"1\":{\"1664\":1}}],[\"栈帧中的本地变量表\",{\"1\":{\"1438\":1}}],[\"栈溢出的典型例子\",{\"1\":{\"1456\":1}}],[\"栈中的指针会先移除掉\",{\"1\":{\"1436\":1}}],[\"栈\",{\"1\":{\"571\":2,\"1664\":1}}],[\"粉丝数\",{\"1\":{\"570\":1}}],[\"闭区间\",{\"1\":{\"570\":1}}],[\"仅记录值是否有过修改\",{\"1\":{\"1479\":1}}],[\"仅仅是由一个布尔值来控制的\",{\"1\":{\"1617\":1}}],[\"仅仅是为了字节对齐\",{\"1\":{\"1484\":1}}],[\"仅仅需要将我们调用的方法修改为\",{\"1\":{\"1612\":1}}],[\"仅仅关心是否修改过\",{\"1\":{\"1479\":1}}],[\"仅仅使用它进行元标注\",{\"1\":{\"967\":1}}],[\"仅能转换单一的source\",{\"1\":{\"1088\":1}}],[\"仅能满足\",{\"1\":{\"504\":1}}],[\"仅当参数中所有的key都不存在时执行\",{\"1\":{\"570\":1}}],[\"仅当key不存在时进行set\",{\"1\":{\"570\":1}}],[\"仅对于数字\",{\"1\":{\"570\":1}}],[\"向broker发送消息\",{\"0\":{\"1882\":1}}],[\"向spring中注册conversionservice\",{\"1\":{\"1639\":1}}],[\"向spring中注册propertyeditor\",{\"1\":{\"1638\":1}}],[\"向spring应用上下文注册事件\",{\"1\":{\"1112\":1,\"1113\":1}}],[\"向sink发送任何数据之前一定要调用这个方法\",{\"1\":{\"1623\":1}}],[\"向一个已有的管道用于追加一个中间操作\",{\"1\":{\"1622\":1}}],[\"向操作系统发起io请求\",{\"1\":{\"1580\":1}}],[\"向不同的电商平台询价\",{\"1\":{\"1517\":1}}],[\"向下委托\",{\"1\":{\"1432\":1}}],[\"向上委托查找\",{\"1\":{\"1432\":1}}],[\"向mbeanserver托管live\",{\"1\":{\"1172\":1}}],[\"向myset中增加成员\",{\"1\":{\"572\":1}}],[\"向mylist中\",{\"1\":{\"571\":1}}],[\"向org\",{\"1\":{\"1084\":1}}],[\"向容器中注入一些bean\",{\"1\":{\"917\":1}}],[\"向指定频道发布消息\",{\"1\":{\"597\":1}}],[\"向指定的key的value后追加字符串\",{\"1\":{\"570\":1}}],[\"向有序集合myzset中添加成员m1\",{\"1\":{\"574\":1}}],[\"向有序集合添加一个或多个成员\",{\"1\":{\"574\":1}}],[\"向集合中无序增加一个\",{\"1\":{\"572\":1}}],[\"向已存在的列名中push值\",{\"1\":{\"571\":1}}],[\"向基于内存的临时表写入或读取一条记录的成本\",{\"1\":{\"557\":1}}],[\"向基于磁盘的临时表写入或读取一条记录的成本\",{\"1\":{\"557\":1}}],[\"故障处理工具\",{\"0\":{\"1770\":1}}],[\"故障转移的超时时间\",{\"1\":{\"624\":1}}],[\"故障可以转移\",{\"1\":{\"623\":1}}],[\"故障恢复\",{\"1\":{\"607\":1}}],[\"故会返回key的正常剩余时间\",{\"1\":{\"569\":1}}],[\"故意\",{\"1\":{\"465\":1}}],[\"且这些锁大多数都不是偏向锁\",{\"1\":{\"1485\":1}}],[\"且无法在任何地方通过反射访问该类的方法\",{\"1\":{\"1443\":1}}],[\"且链表顺序不变\",{\"1\":{\"1359\":1}}],[\"且在任何情况下都是单例的\",{\"1\":{\"1195\":1}}],[\"且线程安全\",{\"1\":{\"1194\":1}}],[\"且key还没有过期\",{\"1\":{\"569\":1}}],[\"且所有值都接近一个长度用char\",{\"1\":{\"530\":1}}],[\"位初始是\",{\"1\":{\"1554\":1}}],[\"位是标识符\",{\"1\":{\"1554\":1}}],[\"位\",{\"1\":{\"1554\":1}}],[\"位图\",{\"0\":{\"578\":1},\"1\":{\"568\":1,\"1280\":1}}],[\"位置越靠前越好\",{\"1\":{\"380\":1}}],[\"位置\",{\"1\":{\"308\":1}}],[\"集合主要考虑的是高效的访问和管理他们的元素\",{\"1\":{\"1619\":1}}],[\"集合主要分为两大类\",{\"1\":{\"1538\":1}}],[\"集合与流\",{\"1\":{\"1619\":1}}],[\"集合与我们编写的处理逻辑之间是有清晰的划分的\",{\"1\":{\"1611\":1}}],[\"集合关注的是数据与数据存储本身\",{\"1\":{\"1611\":1}}],[\"集合可以作为流的底层数据源\",{\"1\":{\"1608\":1}}],[\"集合的优点\",{\"0\":{\"1538\":1}}],[\"集合类实现序列化接口的目的\",{\"1\":{\"1475\":1}}],[\"集合类型的依赖注入\",{\"1\":{\"963\":1}}],[\"集合类型\",{\"1\":{\"960\":2,\"962\":2}}],[\"集合类型注入\",{\"0\":{\"960\":1}}],[\"集合类型以及层次性等多种依赖查找方式\",{\"1\":{\"948\":1}}],[\"集合类型查找\",{\"1\":{\"944\":1}}],[\"集合类型beanfactoryutils\",{\"1\":{\"942\":1}}],[\"集合类型依赖查找接口\",{\"1\":{\"941\":1}}],[\"集合类型依赖查找\",{\"0\":{\"941\":1},\"1\":{\"939\":1}}],[\"集合注入和单个类型的注入略微有点差别\",{\"1\":{\"963\":1}}],[\"集合bean对象\",{\"1\":{\"917\":1,\"918\":1}}],[\"集合中最大的成员数为\",{\"1\":{\"572\":1}}],[\"集合成员是唯一的\",{\"1\":{\"572\":1}}],[\"集合\",{\"0\":{\"572\":1,\"1537\":1},\"1\":{\"568\":1,\"1170\":1,\"1280\":1,\"1969\":1}}],[\"集群模式\",{\"0\":{\"1892\":1,\"1897\":1}}],[\"集群工作流程\",{\"0\":{\"1841\":1}}],[\"集群消费\",{\"0\":{\"1830\":1}}],[\"集群高可用\",{\"1\":{\"1327\":1}}],[\"集群部署优化\",{\"1\":{\"1257\":1}}],[\"集群容量一旦达到上限\",{\"1\":{\"624\":1}}],[\"集群中只是失去了写操作\",{\"1\":{\"611\":1}}],[\"集群\",{\"1\":{\"566\":1}}],[\"生产者组\",{\"0\":{\"1828\":1}}],[\"生产者限流\",{\"1\":{\"1536\":1}}],[\"生产者没法限流\",{\"1\":{\"1536\":1}}],[\"生产者生产的速度大于消费者消费的速度\",{\"1\":{\"1536\":1}}],[\"生产者提交任务\",{\"1\":{\"1535\":1}}],[\"生产者线程池\",{\"1\":{\"1535\":1}}],[\"生产者线程生产任务\",{\"1\":{\"1535\":1}}],[\"生产者类型\",{\"1\":{\"1520\":1}}],[\"生产者的线程和消费者的线程同步传递某些信息\",{\"1\":{\"1505\":1}}],[\"生产者阻塞\",{\"1\":{\"1502\":1}}],[\"生产者\",{\"0\":{\"1535\":1,\"1852\":1},\"1\":{\"1501\":1,\"1502\":1,\"1535\":1}}],[\"生产者要保证100\",{\"1\":{\"1333\":1}}],[\"生产者发送消息不丢失\",{\"1\":{\"1328\":1}}],[\"生产者发送一个消息后\",{\"1\":{\"1326\":1}}],[\"生产环境中应该使用dbsize\",{\"1\":{\"567\":1}}],[\"生命周期的整体流程\",{\"1\":{\"1647\":1}}],[\"生命周期维持在每个用户http会话\",{\"1\":{\"1182\":1}}],[\"生命周期维持在每次http请求\",{\"1\":{\"1182\":1}}],[\"生命周期处理\",{\"1\":{\"967\":1}}],[\"生命周期注解\",{\"1\":{\"966\":1}}],[\"生命周期回调等\",{\"1\":{\"927\":1}}],[\"生命周期管理\",{\"1\":{\"907\":1,\"909\":1,\"974\":1}}],[\"生命周期\",{\"1\":{\"900\":1}}],[\"生态系统\",{\"1\":{\"900\":1}}],[\"生成签名\",{\"0\":{\"1951\":1}}],[\"生成bloomfilterdata\",{\"0\":{\"1907\":1}}],[\"生成统一的tomcat\",{\"1\":{\"1687\":1}}],[\"生成统计信息和执行计划\",{\"1\":{\"381\":1}}],[\"生成一个beandefinition对象\",{\"1\":{\"1632\":1}}],[\"生成一个结果或者拥有副作用\",{\"1\":{\"1623\":1}}],[\"生成一个正确的版本并返回结果\",{\"1\":{\"345\":1}}],[\"生成了一个新的只包含红色的widget的流\",{\"1\":{\"1619\":1}}],[\"生成类的对象时自动执行\",{\"1\":{\"1346\":1}}],[\"生成动态代理\",{\"1\":{\"1237\":1}}],[\"生成桥方法以保留扩展泛型类中的多态性\",{\"1\":{\"1098\":1}}],[\"生成\",{\"1\":{\"953\":1,\"954\":1}}],[\"生成的字节码只包含普通类\",{\"1\":{\"1098\":1}}],[\"生成的id不连续\",{\"1\":{\"492\":1}}],[\"生成的结果里面\",{\"1\":{\"492\":1}}],[\"生成的redo\",{\"1\":{\"451\":1}}],[\"生成与binlog的server\",{\"1\":{\"455\":1}}],[\"生成执行计划\",{\"1\":{\"381\":1}}],[\"浏览量\",{\"1\":{\"565\":1}}],[\"计数器\",{\"1\":{\"565\":1,\"570\":1}}],[\"计时器\",{\"1\":{\"565\":1}}],[\"计算位映射\",{\"0\":{\"1909\":1}}],[\"计算关于元素的求和\",{\"1\":{\"1615\":1}}],[\"计算新的resize上限\",{\"1\":{\"1550\":1}}],[\"计算index\",{\"1\":{\"1549\":1}}],[\"计算id\",{\"1\":{\"416\":1}}],[\"计算的结果越分散\",{\"1\":{\"1546\":1}}],[\"计算的点文档要写入的分片\",{\"1\":{\"1256\":1}}],[\"计算等一系列需要大量耗费cpu资源的任务\",{\"1\":{\"1510\":1}}],[\"计算value的地址\",{\"1\":{\"1479\":1}}],[\"计算距离等操作\",{\"1\":{\"1280\":1}}],[\"计算时就采用hash取模的方式计算\",{\"1\":{\"1256\":1}}],[\"计算基数所需的空间总是固定的\",{\"1\":{\"577\":1}}],[\"计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合\",{\"1\":{\"574\":2}}],[\"计算在有序集合中指定区间score的成员数\",{\"1\":{\"574\":1}}],[\"计算统计数据时采样的页面数量\",{\"1\":{\"558\":1}}],[\"计算每个页面中主键值记录数量\",{\"1\":{\"558\":1}}],[\"计算内连接查询成本的方式更麻烦一些\",{\"1\":{\"555\":1}}],[\"计算过程与上面类似\",{\"1\":{\"549\":1}}],[\"计算过程如下\",{\"1\":{\"549\":1}}],[\"计算平均每个页面中包含多少记录\",{\"1\":{\"549\":1}}],[\"计算使用不同索引执行查询的代价\",{\"0\":{\"549\":1},\"1\":{\"546\":1}}],[\"计算全表扫描的代价\",{\"0\":{\"548\":1},\"1\":{\"546\":1}}],[\"计算出平均一个值重复多少次\",{\"1\":{\"553\":1}}],[\"计算出来的\",{\"1\":{\"465\":1}}],[\"计算出这一行的哈希值\",{\"1\":{\"465\":1}}],[\"计算它与当前系统时间的差值\",{\"1\":{\"457\":1}}],[\"计算参与join的各个字段的总数据量\",{\"1\":{\"403\":1}}],[\"计算\",{\"1\":{\"354\":1,\"369\":1,\"1615\":1}}],[\"计算机基础\",{\"1\":{\"1966\":1}}],[\"计算机体系结构中\",{\"1\":{\"1474\":1}}],[\"计算机的启动过程\",{\"0\":{\"282\":1}}],[\"计算机组成原理\",{\"0\":{\"278\":1},\"1\":{\"1966\":1}}],[\"概述\",{\"0\":{\"563\":1}}],[\"概念\",{\"0\":{\"606\":1,\"626\":1,\"629\":1,\"632\":1,\"1826\":1},\"1\":{\"370\":1}}],[\"永久代存储的类元数据在应用程序运行期间是不可卸载的\",{\"1\":{\"1457\":1}}],[\"永久代存在一些问题\",{\"1\":{\"1457\":1}}],[\"永久代的大小是固定的\",{\"1\":{\"1457\":1}}],[\"永久性的统计数据\",{\"1\":{\"558\":1}}],[\"永远都会返回相同的结果\",{\"1\":{\"1620\":1}}],[\"永远都是小的结果集驱动大的结果集\",{\"1\":{\"364\":1}}],[\"永远是id大的优先级最高\",{\"1\":{\"330\":1}}],[\"请说明resolvabletype的设计优势\",{\"0\":{\"1107\":1}}],[\"请介绍java\",{\"0\":{\"1106\":1}}],[\"请通过示例演示spring\",{\"0\":{\"1069\":1}}],[\"请举例不同类型的spring配置资源\",{\"0\":{\"1048\":1}}],[\"请举例说明spring\",{\"0\":{\"855\":1}}],[\"请解释spring\",{\"0\":{\"831\":1}}],[\"请注意我使用的是块\",{\"1\":{\"557\":1}}],[\"请求处理完成后的回调\",{\"1\":{\"1657\":1}}],[\"请求\",{\"1\":{\"1421\":4,\"1474\":1}}],[\"请求重复提交\",{\"1\":{\"1248\":1}}],[\"请求就会被转发到其他实例\",{\"1\":{\"1200\":1}}],[\"请求来说\",{\"1\":{\"396\":1}}],[\"请求多余的数据\",{\"0\":{\"382\":1}}],[\"请求格式和bulk类似\",{\"1\":{\"307\":1}}],[\"请求参数\",{\"1\":{\"307\":1}}],[\"请求地址\",{\"1\":{\"307\":1}}],[\"请求方式\",{\"1\":{\"307\":1}}],[\"含义如下\",{\"1\":{\"1484\":1}}],[\"含义\",{\"1\":{\"557\":2,\"1262\":1,\"1410\":1}}],[\"名称与类名相同\",{\"1\":{\"1346\":1}}],[\"名称固定为conversionservice\",{\"1\":{\"1091\":1}}],[\"名称pattern\",{\"1\":{\"1020\":1}}],[\"名称\",{\"1\":{\"557\":2,\"1242\":2}}],[\"名字第一个字是张\",{\"1\":{\"340\":1}}],[\"凡是不满足这些规则的连接顺序不参与分析\",{\"1\":{\"556\":1}}],[\"越早过期的键优先删除\",{\"1\":{\"1300\":1}}],[\"越容易得到好的执行计划\",{\"1\":{\"556\":1}}],[\"越先被执行\",{\"1\":{\"330\":1}}],[\"×\",{\"1\":{\"555\":3,\"556\":10,\"558\":1,\"1554\":1}}],[\"暂时不妨可以认为lambda表达式就是匿名内部类的一种新的写法\",{\"1\":{\"1592\":1}}],[\"暂时不考虑使用join\",{\"1\":{\"555\":1}}],[\"暂时丢失数据的状态\",{\"1\":{\"459\":1}}],[\"扇出值就是多少\",{\"1\":{\"554\":1}}],[\"条\",{\"1\":{\"553\":1}}],[\"条件注解\",{\"1\":{\"1647\":1}}],[\"条件匹配\",{\"1\":{\"1647\":1}}],[\"条件有限或其他原因\",{\"1\":{\"1536\":1}}],[\"条件队列\",{\"1\":{\"1490\":1}}],[\"条件等待队列\",{\"0\":{\"1492\":1},\"1\":{\"1490\":1}}],[\"条件不满足\",{\"1\":{\"1483\":1}}],[\"条件变量个等待队列的作用是解决线程之间的同步问题\",{\"1\":{\"1483\":1}}],[\"条件化spring\",{\"1\":{\"1144\":1}}],[\"条件上下文\",{\"1\":{\"1139\":1}}],[\"条件判断\",{\"1\":{\"1139\":1}}],[\"条件评估\",{\"1\":{\"1027\":1}}],[\"条件激活处理jpa注解场景\",{\"1\":{\"945\":1}}],[\"条件激活\",{\"1\":{\"945\":1}}],[\"条件\",{\"1\":{\"554\":3}}],[\"条件处理\",{\"1\":{\"519\":1}}],[\"条件时循环结束\",{\"1\":{\"356\":2}}],[\"条件为止\",{\"1\":{\"355\":1}}],[\"条件的二级索引记录条数\",{\"1\":{\"549\":1}}],[\"条件的记录\",{\"1\":{\"356\":1}}],[\"条件的主键id\",{\"1\":{\"354\":1,\"355\":1,\"356\":1,\"520\":2}}],[\"条件的行\",{\"1\":{\"354\":1}}],[\"条件查询\",{\"1\":{\"306\":2}}],[\"÷\",{\"1\":{\"553\":2}}],[\"某一件事情一定是发生在另外一件事情之前\",{\"1\":{\"1623\":1}}],[\"某个线程在短时间内将原子类的值a修改为b\",{\"1\":{\"1479\":1}}],[\"某个索引列的cardinality属性是10000\",{\"1\":{\"553\":1}}],[\"某银行网站a可以以get请求的方式发起转账操作\",{\"1\":{\"1201\":1}}],[\"某些场景哈希关联的效率要高很多\",{\"1\":{\"394\":1}}],[\"某些查询可能不可避免地需要筛选大量数据\",{\"1\":{\"381\":1}}],[\"描述的是管道的源阶段\",{\"1\":{\"1621\":1}}],[\"描述or聚合关系\",{\"1\":{\"1518\":1}}],[\"描述and聚合关系\",{\"1\":{\"1518\":1}}],[\"描述依赖关系\",{\"1\":{\"1518\":1}}],[\"描述在使用\",{\"1\":{\"1133\":1}}],[\"描述注解保留的时间范围\",{\"1\":{\"1133\":1}}],[\"描述人的pojo类\",{\"1\":{\"909\":1}}],[\"描述\",{\"1\":{\"553\":1,\"558\":1,\"570\":1,\"571\":1,\"572\":1,\"573\":1,\"574\":1,\"576\":1,\"577\":1,\"578\":1,\"597\":1,\"1501\":1}}],[\"详细解析\",{\"1\":{\"1649\":1}}],[\"详细说明\",{\"1\":{\"1554\":1}}],[\"详细说明如下\",{\"1\":{\"1549\":1}}],[\"详细的请看下图\",{\"1\":{\"1653\":1}}],[\"详细的文档资料非常少\",{\"1\":{\"1453\":1}}],[\"详细的示意图\",{\"1\":{\"1241\":1}}],[\"详细步骤说明\",{\"1\":{\"1436\":1}}],[\"详细参见\",{\"1\":{\"1246\":1,\"1299\":1,\"1307\":1,\"1334\":1,\"1413\":1}}],[\"详细具体步骤如下\",{\"1\":{\"588\":1}}],[\"详细含义\",{\"1\":{\"553\":1}}],[\"详细过程如下\",{\"1\":{\"459\":1}}],[\"搞不好计算这些单点区间对应的索引记录条数的成本比直接全表扫描的成本都大了\",{\"1\":{\"553\":1}}],[\"✖️1\",{\"1\":{\"549\":1}}],[\"✖️\",{\"1\":{\"548\":2,\"549\":2,\"553\":1}}],[\"➗\",{\"1\":{\"548\":2}}],[\"此处就进行实例化\",{\"1\":{\"1648\":1}}],[\"此处不用等到取元素时才唤醒\",{\"1\":{\"1503\":1}}],[\"此外它还负责加载servlet所依赖的jar包\",{\"1\":{\"1693\":1}}],[\"此外\",{\"1\":{\"1620\":1}}],[\"此模式依赖于java线程的阻塞唤醒机制\",{\"1\":{\"1530\":1}}],[\"此方法返回false\",{\"1\":{\"1479\":1}}],[\"此方法返回true\",{\"1\":{\"1479\":1}}],[\"此为深拷贝\",{\"1\":{\"1344\":1}}],[\"此步骤对应的cpu成本就是\",{\"1\":{\"549\":1}}],[\"此后在调用快照读的时候\",{\"1\":{\"542\":1}}],[\"此时只会将bean的名称设置给beanclass属性\",{\"1\":{\"1647\":1}}],[\"此时只有在索引列上加上主键值才可以区分两条索引列值都是一样的二级索引记录\",{\"1\":{\"558\":1}}],[\"此时线程数的增多并没有让性能提升\",{\"1\":{\"1510\":1}}],[\"此时假设我们设置的线程数量是cpu核心数的2倍以上\",{\"1\":{\"1510\":1}}],[\"此时假设有三个线程同时执行这条更新语句\",{\"1\":{\"1498\":1}}],[\"此时队列有空位\",{\"1\":{\"1502\":1}}],[\"此时mark\",{\"1\":{\"1485\":1}}],[\"此时可能就需要对cell\",{\"1\":{\"1480\":1}}],[\"此时其他线程不感知\",{\"1\":{\"1479\":1}}],[\"此时其他session没法在这个范围锁包含的所有行记录\",{\"1\":{\"536\":1}}],[\"此时unsafe\",{\"1\":{\"1479\":1}}],[\"此时遍历查找会非常慢\",{\"1\":{\"1361\":1}}],[\"此时需要红黑树来加速查询速度\",{\"1\":{\"1360\":1}}],[\"此时做查询操作\",{\"1\":{\"1360\":1}}],[\"此时已知桶的位置\",{\"1\":{\"1358\":1}}],[\"此时basepackages和value就互为显性别名\",{\"1\":{\"1136\":1}}],[\"此时bean的实例化已经完成了\",{\"1\":{\"1002\":1}}],[\"此时binlog会被记录成\",{\"1\":{\"413\":1}}],[\"此时哨兵监视着我们的主机6379\",{\"1\":{\"621\":1}}],[\"此时我们回到redis查看数据时候\",{\"1\":{\"583\":1}}],[\"此时我们再来分析普通索引和唯一索引选择的问题\",{\"1\":{\"344\":1}}],[\"此时事务并没有执行\",{\"1\":{\"581\":1}}],[\"此时涉及到被驱动表s1的搜索条件就是\",{\"1\":{\"555\":1}}],[\"此时涉及到被驱动表s2的搜索条件就是\",{\"1\":{\"555\":1}}],[\"此时访问s2表时可用的方案也是全表扫描和使用idx\",{\"1\":{\"555\":1}}],[\"此时那些设计两表的条件相当于只涉及被驱动表s2了\",{\"1\":{\"555\":1}}],[\"此时范围区间\",{\"1\":{\"554\":1}}],[\"此时再看上述查询语句\",{\"1\":{\"553\":1}}],[\"此时就会加上前面去除的成本\",{\"1\":{\"551\":1}}],[\"此时包含两种情况\",{\"1\":{\"542\":1}}],[\"此时执行如下插入命令\",{\"1\":{\"491\":1}}],[\"此时如果在session\",{\"1\":{\"481\":1}}],[\"此时占用的cpu却是0\",{\"1\":{\"476\":1}}],[\"此时看起来使用分区表并没有什么不妥\",{\"1\":{\"424\":1}}],[\"此时show\",{\"1\":{\"424\":1}}],[\"此时表中有两行记录\",{\"1\":{\"424\":1}}],[\"此时表中的索引结构如下图所示\",{\"1\":{\"336\":1}}],[\"此时扫描行数增加10000\",{\"1\":{\"420\":1}}],[\"此时语句的执行流程就变成了这样\",{\"1\":{\"404\":1}}],[\"此时的key\",{\"1\":{\"1551\":1}}],[\"此时的序列图如下\",{\"1\":{\"447\":1}}],[\"此时的查询也就不再需要排序了\",{\"1\":{\"356\":1}}],[\"此时的optimizer\",{\"1\":{\"355\":1}}],[\"此时change\",{\"1\":{\"344\":1}}],[\"此时\",{\"1\":{\"337\":1,\"403\":1,\"407\":1,\"416\":1,\"417\":1,\"418\":1,\"454\":1,\"461\":1,\"462\":1,\"467\":2,\"532\":1,\"624\":1,\"1286\":1,\"1297\":1,\"1548\":1,\"1551\":1}}],[\"此时redo\",{\"1\":{\"326\":1}}],[\"标签匹配\",{\"0\":{\"1904\":1}}],[\"标签\",{\"0\":{\"1832\":1}}],[\"标识为已经消费\",{\"1\":{\"1622\":1}}],[\"标识符左移\",{\"1\":{\"1554\":1}}],[\"标识拥有该monitor的线程\",{\"1\":{\"1483\":1}}],[\"标记\",{\"0\":{\"1720\":1,\"1721\":1,\"1722\":1},\"1\":{\"1441\":4}}],[\"标记位为true\",{\"1\":{\"542\":1}}],[\"标记位写上true\",{\"1\":{\"542\":1}}],[\"标准指令\",{\"1\":{\"1453\":1}}],[\"标准化接口\",{\"1\":{\"1108\":1}}],[\"标准的javabeans是如何操作属性的\",{\"1\":{\"1075\":1}}],[\"标准组件\",{\"1\":{\"1070\":1}}],[\"标准工厂api\",{\"0\":{\"764\":1}}],[\"标注这个注解的类会被spring扫描\",{\"1\":{\"1134\":1}}],[\"标注\",{\"1\":{\"1123\":1}}],[\"标注了\",{\"1\":{\"964\":1}}],[\"标注类型bean\",{\"1\":{\"941\":1}}],[\"标量类型\",{\"1\":{\"959\":1,\"960\":1}}],[\"标题\",{\"1\":{\"361\":1}}],[\"∈\",{\"1\":{\"542\":1}}],[\"插在该行记录的undo\",{\"1\":{\"542\":1}}],[\"插入完之后\",{\"1\":{\"1554\":1}}],[\"插入链表尾部\",{\"1\":{\"1554\":1}}],[\"插入成功后\",{\"1\":{\"1549\":1}}],[\"插入元素等相对复杂\",{\"1\":{\"1538\":1}}],[\"插入ins\",{\"1\":{\"571\":1}}],[\"插入\",{\"1\":{\"542\":1}}],[\"插入的字符数不足n时不会补充空格\",{\"1\":{\"530\":1}}],[\"插入的行是\",{\"1\":{\"491\":1}}],[\"插入空格进行补充保存\",{\"1\":{\"530\":1}}],[\"插入或删除表数据行的时候同时维护计数表\",{\"1\":{\"526\":1}}],[\"插入或删除数据行的时候同时维护redis里面的表总行数key的计数值\",{\"1\":{\"526\":1}}],[\"插入两条记录\",{\"1\":{\"492\":1}}],[\"插入了\",{\"1\":{\"492\":1}}],[\"插入了1000行数据\",{\"1\":{\"404\":1}}],[\"插入了10万行数据\",{\"1\":{\"346\":1}}],[\"插入记录时使用\",{\"1\":{\"442\":1}}],[\"插入意向gap锁\",{\"1\":{\"442\":1}}],[\"插入一条记录时\",{\"1\":{\"542\":1}}],[\"插入一些示例数据\",{\"1\":{\"523\":1}}],[\"插入一部分数据后\",{\"1\":{\"418\":1}}],[\"插入一行数据\",{\"1\":{\"490\":1}}],[\"插入一行记录后\",{\"1\":{\"396\":1}}],[\"插入一行后记录后\",{\"1\":{\"396\":1}}],[\"插入临时表成功\",{\"1\":{\"414\":1}}],[\"插入数据\",{\"1\":{\"378\":1,\"534\":1}}],[\"插入这个值\",{\"1\":{\"343\":1}}],[\"插入新记录的时候可以不指定id的值\",{\"1\":{\"335\":1}}],[\"插入文档报错\",{\"1\":{\"309\":1}}],[\"拷贝数据\",{\"1\":{\"1587\":1,\"1588\":1}}],[\"拷贝数据效率慢\",{\"1\":{\"1585\":1}}],[\"拷贝数据到临时表\",{\"1\":{\"431\":1}}],[\"拷贝机制\",{\"1\":{\"1585\":1}}],[\"拷贝机制对比的结果如下\",{\"1\":{\"1585\":1}}],[\"拷贝操作\",{\"1\":{\"1584\":1}}],[\"拷贝加入了\",{\"1\":{\"1583\":1}}],[\"拷贝流程\",{\"0\":{\"1583\":1},\"1\":{\"1582\":1,\"1583\":1,\"1584\":1}}],[\"拷贝次数和切换次数比预期的还要多\",{\"1\":{\"1580\":1}}],[\"拷贝到用户缓冲区\",{\"1\":{\"1580\":1}}],[\"拷贝\",{\"1\":{\"1576\":1,\"1582\":2,\"1583\":4,\"1584\":2}}],[\"拷贝完毕后\",{\"1\":{\"542\":1}}],[\"版本\",{\"1\":{\"1983\":1}}],[\"版本支持\",{\"1\":{\"1100\":1,\"1101\":1}}],[\"版本开始\",{\"1\":{\"592\":1}}],[\"版本链的比对规则如下\",{\"1\":{\"542\":1}}],[\"版本与事务时间戳关联\",{\"1\":{\"541\":1}}],[\"版本会增加\",{\"1\":{\"306\":1}}],[\"串行操作\",{\"1\":{\"1615\":1}}],[\"串行的实现\",{\"1\":{\"1623\":1}}],[\"串行的方式\",{\"1\":{\"1623\":1}}],[\"串行的\",{\"1\":{\"1609\":1}}],[\"串行\",{\"1\":{\"1441\":3}}],[\"串行级别下的快照读会退化成当前读\",{\"1\":{\"541\":1}}],[\"串行化\",{\"1\":{\"433\":2,\"532\":1}}],[\"串行化是指对同一行记录\",{\"1\":{\"433\":1}}],[\"机制中获益\",{\"1\":{\"588\":1}}],[\"机制来实现\",{\"1\":{\"540\":1}}],[\"机器学习\",{\"1\":{\"301\":1}}],[\"涉及事务加锁的sql尽量放在事务的最后执行\",{\"1\":{\"539\":1}}],[\"合起来理解\",{\"1\":{\"1576\":1}}],[\"合并beandifinition的方法\",{\"1\":{\"1647\":1}}],[\"合并beandefition\",{\"1\":{\"1647\":1}}],[\"合并会生成一个新的beandefition\",{\"1\":{\"1647\":1}}],[\"合并\",{\"1\":{\"1510\":1}}],[\"合并的核心代码\",{\"1\":{\"997\":1}}],[\"合并的过程\",{\"1\":{\"335\":1}}],[\"合并myelemx和myelemy\",{\"1\":{\"577\":1}}],[\"合并为一个\",{\"1\":{\"577\":1}}],[\"合并后的score是之前集合中所有score的和\",{\"1\":{\"574\":1}}],[\"合理设计索引\",{\"1\":{\"539\":1}}],[\"共有八个\",{\"1\":{\"1620\":1}}],[\"共有五种方式\",{\"1\":{\"1352\":1}}],[\"共享\",{\"1\":{\"1490\":2}}],[\"共享获取等\",{\"1\":{\"1490\":1}}],[\"共享内存\",{\"1\":{\"1477\":1}}],[\"共享内存模型\",{\"1\":{\"1470\":1}}],[\"共享数据可能有多个副本\",{\"1\":{\"1474\":1}}],[\"共享锁的模式\",{\"1\":{\"1496\":1}}],[\"共享锁\",{\"1\":{\"537\":1,\"541\":1,\"1263\":1,\"1496\":1}}],[\"共同关注\",{\"1\":{\"572\":1}}],[\"共涉及了四个部分\",{\"1\":{\"345\":1}}],[\"临界资源\",{\"1\":{\"1482\":1}}],[\"临界区\",{\"1\":{\"1477\":1,\"1482\":2}}],[\"临键锁是行锁与间隙锁的组合\",{\"1\":{\"537\":1}}],[\"临键锁\",{\"0\":{\"537\":1}}],[\"临时变量等\",{\"1\":{\"1438\":1}}],[\"临时存储properties对象\",{\"1\":{\"1082\":1,\"1084\":1}}],[\"临时关闭mysql查询缓存\",{\"1\":{\"526\":1}}],[\"临时表是二维表结构\",{\"1\":{\"418\":1}}],[\"临时表只能在线程内自己访问\",{\"1\":{\"413\":1}}],[\"临时表和主备复制\",{\"0\":{\"413\":1}}],[\"临时表经常会被用在复杂查询优化过程中\",{\"1\":{\"411\":1}}],[\"临时表的应用\",{\"0\":{\"411\":1}}],[\"临时表的特性\",{\"0\":{\"410\":1}}],[\"临时表特别适合join优化的场景\",{\"1\":{\"410\":1}}],[\"临时表可以与普通表同名\",{\"1\":{\"410\":1}}],[\"临时表有以下几个特点\",{\"1\":{\"410\":1}}],[\"临时表対系统性能损耗很大\",{\"1\":{\"330\":1}}],[\"区别在于框架帮助我们实现了多少\",{\"1\":{\"1612\":1}}],[\"区别\",{\"1\":{\"1271\":1}}],[\"区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件\",{\"1\":{\"564\":1}}],[\"区域\",{\"1\":{\"1050\":1}}],[\"区间内的成员\",{\"1\":{\"574\":1}}],[\"区间的成员数量\",{\"1\":{\"574\":1}}],[\"区间最右记录在页c中\",{\"1\":{\"549\":1}}],[\"区间都无法修改数据\",{\"1\":{\"536\":1}}],[\"区分度\",{\"1\":{\"347\":1}}],[\"历史版本\",{\"1\":{\"535\":1}}],[\"电话号码和不超过255个字符长度的任意字母数字组合\",{\"1\":{\"530\":1}}],[\"邮政编码\",{\"1\":{\"530\":1}}],[\"极大文本数据\",{\"1\":{\"530\":1}}],[\"极大整数值\",{\"1\":{\"528\":1}}],[\"短文本字符串\",{\"1\":{\"530\":1}}],[\"短连接则是指每次执行完很少的几次查询就断开连接\",{\"1\":{\"318\":1}}],[\"个数\",{\"1\":{\"1339\":1}}],[\"个beandefinition\",{\"1\":{\"1022\":1}}],[\"个\",{\"1\":{\"587\":3,\"946\":1}}],[\"个不同元素的基数\",{\"1\":{\"577\":1}}],[\"个元素\",{\"1\":{\"571\":1}}],[\"个字符的二进制字符串\",{\"1\":{\"530\":1}}],[\"个人经历\",{\"0\":{\"4\":1}}],[\"混合收集\",{\"1\":{\"1434\":1}}],[\"混合日期和时间值\",{\"1\":{\"529\":2}}],[\"混合编程\",{\"0\":{\"294\":1}}],[\"年份值\",{\"1\":{\"529\":1}}],[\"年龄最大值是15\",{\"1\":{\"1436\":1}}],[\"年龄加1\",{\"1\":{\"1436\":1}}],[\"年龄\",{\"1\":{\"353\":1,\"510\":1,\"518\":1}}],[\"变更属性的内容和执行特定的方法的功能\",{\"1\":{\"1558\":1}}],[\"变色这些操作来保持平衡\",{\"1\":{\"1360\":1}}],[\"变量和抽象方法\",{\"1\":{\"1345\":1}}],[\"变长字符串\",{\"1\":{\"530\":1}}],[\"变长定长等\",{\"1\":{\"527\":1}}],[\"变成空队列\",{\"1\":{\"462\":1}}],[\"变成了worker线程\",{\"1\":{\"460\":1}}],[\"变成了20000\",{\"1\":{\"420\":1}}],[\"预清理阶段\",{\"0\":{\"1734\":1}}],[\"预备知识\",{\"1\":{\"1184\":1}}],[\"预注册bean名称为\",{\"1\":{\"1055\":1}}],[\"预写式日志\",{\"1\":{\"561\":1}}],[\"预估的二级索引记录数\",{\"1\":{\"549\":1}}],[\"预估的二级索引记录条数\",{\"1\":{\"549\":1}}],[\"预估表的访问成本\",{\"1\":{\"519\":1}}],[\"预计有39条二级索引记录需要进行回表操作\",{\"1\":{\"549\":1}}],[\"预计扫描行数\",{\"1\":{\"520\":1}}],[\"预防误删库\",{\"0\":{\"487\":1}}],[\"词法分析器\",{\"0\":{\"513\":1}}],[\"词频tf\",{\"1\":{\"308\":1}}],[\"员工记录表\",{\"1\":{\"510\":1,\"518\":1}}],[\"聚合的关系\",{\"1\":{\"1518\":1}}],[\"聚簇索引的数据是物理存放顺序和索引顺序是一致的\",{\"1\":{\"1266\":1}}],[\"聚簇索引的页面数量✖️每个页面的大小\",{\"1\":{\"548\":1}}],[\"聚簇索引和唯一二级索引的该列值为0\",{\"1\":{\"553\":1}}],[\"聚簇索引和非聚簇索引有什么区别\",{\"0\":{\"157\":1,\"1266\":1}}],[\"聚簇索引占用的页面数\",{\"1\":{\"548\":1}}],[\"聚簇索引\",{\"1\":{\"518\":1,\"1266\":1}}],[\"聚集索引\",{\"1\":{\"505\":1}}],[\"聚集\",{\"1\":{\"505\":1}}],[\"冗余\",{\"1\":{\"503\":1}}],[\"叶子结点包含了完整的数据记录\",{\"1\":{\"505\":1}}],[\"叶子结点包含所有索引字段\",{\"1\":{\"503\":1}}],[\"叶子结点用指针连接\",{\"1\":{\"503\":1}}],[\"叶子结点的指针为空\",{\"1\":{\"502\":1}}],[\"叶子结点具有相同的深度\",{\"1\":{\"502\":1}}],[\"逻辑队列\",{\"0\":{\"1956\":1}}],[\"逻辑\",{\"1\":{\"1615\":1}}],[\"逻辑或物理\",{\"1\":{\"1474\":1}}],[\"逻辑代码如下\",{\"1\":{\"498\":1}}],[\"逻辑上一致\",{\"1\":{\"348\":1}}],[\"恐怕都还没有实例跑到过这个上限\",{\"1\":{\"497\":1}}],[\"申请到之后\",{\"1\":{\"1519\":1}}],[\"申请row\",{\"1\":{\"495\":1}}],[\"申请完成后锁就可以释放了\",{\"1\":{\"492\":1}}],[\"成绩\",{\"1\":{\"1974\":1}}],[\"成员结构\",{\"1\":{\"1071\":1}}],[\"成员的分数值\",{\"1\":{\"574\":1}}],[\"成为写锁\",{\"1\":{\"1498\":1}}],[\"成为myelemz\",{\"1\":{\"577\":1}}],[\"成为驱动表\",{\"1\":{\"524\":1}}],[\"成功启动哨兵模式\",{\"1\":{\"621\":1}}],[\"成功\",{\"1\":{\"573\":1,\"1498\":1}}],[\"成功插入一行\",{\"1\":{\"494\":1}}],[\"成本分析的越精确\",{\"1\":{\"556\":1}}],[\"成本数据\",{\"1\":{\"555\":1}}],[\"成本非常高\",{\"1\":{\"333\":1}}],[\"制定操作规范\",{\"1\":{\"487\":1}}],[\"账号分离\",{\"1\":{\"487\":1}}],[\"目的也是保证数据的可见性\",{\"1\":{\"1498\":1}}],[\"目的是为了返回一个效率更高的分割迭代器\",{\"1\":{\"1620\":1}}],[\"目的是为了保证只读事务显示的trx\",{\"1\":{\"497\":1}}],[\"目的是要让备库重新识别这两个日志文件\",{\"1\":{\"485\":1}}],[\"目录往往有更长的延迟\",{\"1\":{\"1474\":1}}],[\"目标对象\",{\"1\":{\"1654\":1}}],[\"目标对象b中存在x属性\",{\"1\":{\"1072\":2}}],[\"目标对象b不存在x属性\",{\"1\":{\"1072\":1}}],[\"目标文件\",{\"1\":{\"1588\":1}}],[\"目标bean才被依赖查找\",{\"1\":{\"1181\":1}}],[\"目标bean名称\",{\"1\":{\"1070\":1}}],[\"目标类型\",{\"1\":{\"1086\":1}}],[\"目前企业里用的比较多的是rocketmq和kafka\",{\"1\":{\"1985\":1}}],[\"目前业界有很多mq产品\",{\"1\":{\"1985\":1}}],[\"目前在各大互联网公司基本不再使用\",{\"1\":{\"1978\":1}}],[\"目前使用最广泛的是druid\",{\"1\":{\"1974\":1}}],[\"目前只支持一下两种\",{\"1\":{\"1586\":1}}],[\"目前只有g1会有这种行为\",{\"1\":{\"1434\":1}}],[\"目前只有cms收集器会单独收集老年代对象\",{\"1\":{\"1434\":1}}],[\"目前apache\",{\"1\":{\"1519\":1}}],[\"目前绝大部分的jjvm\",{\"1\":{\"1434\":1}}],[\"目前<state>总是\",{\"1\":{\"624\":1}}],[\"目前来看\",{\"1\":{\"425\":1}}],[\"误删库或者表后\",{\"1\":{\"485\":1}}],[\"误删库\",{\"0\":{\"485\":1}}],[\"误删行\",{\"0\":{\"484\":1}}],[\"误删数据\",{\"0\":{\"483\":1}}],[\"哪怕可以调用private方法\",{\"1\":{\"1559\":1}}],[\"哪有不湿鞋\",{\"1\":{\"483\":1}}],[\"哪些环节会造成消息丢失\",{\"1\":{\"1328\":1}}],[\"哪些情况不要建索引\",{\"0\":{\"359\":1}}],[\"哪些情况需要建索引\",{\"0\":{\"358\":1}}],[\"哪些列或常量被用于查找索引列上的值\",{\"1\":{\"330\":1}}],[\"哪些索引被实际使用\",{\"1\":{\"329\":1}}],[\"哪些索引可以使用\",{\"1\":{\"329\":1}}],[\"哪些线程独享\",{\"0\":{\"97\":1,\"1428\":1}}],[\"哪些线程共享\",{\"0\":{\"97\":1,\"1428\":1}}],[\"加一\",{\"1\":{\"1554\":1}}],[\"加入到扩容大军中\",{\"1\":{\"1554\":1}}],[\"加入到newlist的头部\",{\"1\":{\"571\":1}}],[\"加速定位的速度\",{\"1\":{\"1519\":1}}],[\"加take锁\",{\"1\":{\"1503\":1}}],[\"加范围锁\",{\"1\":{\"1261\":1}}],[\"加载某个类会先委托父加载器寻找目标类\",{\"1\":{\"1692\":1}}],[\"加载和管理servlet\",{\"1\":{\"1683\":1}}],[\"加载因子为0\",{\"1\":{\"1555\":1}}],[\"加载该类的类加载器已经被回收\",{\"1\":{\"1443\":1}}],[\"加载\",{\"0\":{\"1786\":1},\"1\":{\"1433\":2,\"1663\":1}}],[\"加载beandefinition\",{\"1\":{\"1163\":1}}],[\"加载外部spring\",{\"1\":{\"1021\":1}}],[\"加载外部化配置资源作为spring属性配置\",{\"1\":{\"1020\":1}}],[\"加载的核心代码代码\",{\"1\":{\"998\":1}}],[\"加载xml资源\",{\"1\":{\"953\":1,\"954\":1}}],[\"加载配置\",{\"1\":{\"921\":2}}],[\"加互斥锁\",{\"1\":{\"630\":1}}],[\"加锁的方式通常会严重影响性能\",{\"1\":{\"1519\":1}}],[\"加锁之后整个数据库实例都处于只读状态\",{\"1\":{\"1263\":1}}],[\"加锁资源开销比较小\",{\"1\":{\"1263\":1}}],[\"加锁粒度大\",{\"1\":{\"1263\":1}}],[\"加锁粒度小\",{\"1\":{\"1263\":1}}],[\"加锁\",{\"1\":{\"1261\":1,\"1288\":1,\"1502\":2,\"1554\":1}}],[\"加锁慢\",{\"1\":{\"535\":1}}],[\"加锁快\",{\"1\":{\"534\":1}}],[\"加上一个\",{\"1\":{\"485\":1}}],[\"加上此时文件系统压力大\",{\"1\":{\"481\":1}}],[\"加增量日志的方式了\",{\"1\":{\"485\":1}}],[\"加\",{\"1\":{\"482\":1,\"1554\":1}}],[\"加起来是14000字节\",{\"1\":{\"421\":1}}],[\"终止操作的数量并不是特别多\",{\"1\":{\"1623\":1}}],[\"终止操作对于给定的流源和中间操作一定要提供并行和串行的实现\",{\"1\":{\"1623\":1}}],[\"终止操作会对流中的每个元素执行action\",{\"1\":{\"1623\":1}}],[\"终止操作\",{\"1\":{\"1607\":1}}],[\"终止线程模式\",{\"0\":{\"1523\":1}}],[\"终止逻辑耗时较长\",{\"1\":{\"481\":1}}],[\"终止这条查询语句\",{\"1\":{\"480\":1}}],[\"埋点\",{\"1\":{\"481\":2}}],[\"隐形覆盖\",{\"1\":{\"1137\":1}}],[\"隐形别名\",{\"1\":{\"1136\":1}}],[\"隐藏主键\",{\"1\":{\"542\":1}}],[\"隐含的自增id\",{\"1\":{\"542\":1}}],[\"隐含了下面的三层意思\",{\"1\":{\"481\":1}}],[\"隐式主键是1\",{\"1\":{\"542\":1}}],[\"隐式字符编码转换\",{\"0\":{\"368\":1}}],[\"隐式类型转换\",{\"0\":{\"367\":1}}],[\"根节点枚举\",{\"0\":{\"1758\":1}}],[\"根搜索算法\",{\"0\":{\"1715\":1}}],[\"根可达算法\",{\"1\":{\"1437\":1}}],[\"根本原因是上文中提到的所有方法\",{\"1\":{\"478\":1}}],[\"根据具体应用协议\",{\"1\":{\"1687\":1}}],[\"根据classfilter和methodmatcher来进行过滤\",{\"1\":{\"1654\":1}}],[\"根据双哈希之后的hash值找到数组对应的小标位置\",{\"1\":{\"1554\":1}}],[\"根据hash值以unsafe调用方式\",{\"1\":{\"1553\":1}}],[\"根据键值key计算hash值得到插入元素数组的索引i\",{\"1\":{\"1549\":1}}],[\"根据键的剩余过期时间来选择删除键\",{\"1\":{\"1300\":1}}],[\"根据经验和实验\",{\"1\":{\"1510\":1}}],[\"根据偏移量\",{\"1\":{\"1479\":1}}],[\"根据linux的内核版本\",{\"1\":{\"1423\":1}}],[\"根据需要提供一些可以被外界访问属性的方法\",{\"1\":{\"1340\":1}}],[\"根据分数进行排序\",{\"1\":{\"1280\":1}}],[\"根据分区规则year函数算出来的值是2018\",{\"1\":{\"425\":1}}],[\"根据标注的\",{\"1\":{\"1183\":1}}],[\"根据参数索引来设置\",{\"1\":{\"1053\":1}}],[\"根据被注入属性的类型作为依赖类型进行查找\",{\"1\":{\"952\":1}}],[\"根据被注入属性的名称作为bean名称进行依赖查找\",{\"1\":{\"952\":1}}],[\"根据同类型bean名称列表\",{\"1\":{\"941\":1}}],[\"根据java注解查找名称列表\",{\"1\":{\"942\":1}}],[\"根据java注解查找\",{\"1\":{\"917\":1}}],[\"根据beandefinition的autowirecandidate属性来判断是否可以用来依赖注入\",{\"1\":{\"1648\":1}}],[\"根据beandefinition每次创建\",{\"1\":{\"1182\":1}}],[\"根据bean类型注入\",{\"1\":{\"918\":1}}],[\"根据bean类型查找实例列表\",{\"1\":{\"942\":1}}],[\"根据bean类型查找\",{\"1\":{\"917\":1,\"940\":1,\"941\":1}}],[\"根据bean名称\",{\"1\":{\"940\":1}}],[\"根据bean名称注入\",{\"1\":{\"918\":1}}],[\"根据bean名称+类型查找\",{\"1\":{\"917\":1}}],[\"根据bean名称查找\",{\"1\":{\"917\":1,\"940\":1,\"942\":1}}],[\"根据b+树的算法\",{\"1\":{\"335\":1}}],[\"根据软件的需要提供不同的软件架构\",{\"1\":{\"902\":1}}],[\"根据策略决定\",{\"1\":{\"595\":1}}],[\"根据父进程内存生成临时快照文件\",{\"1\":{\"588\":1}}],[\"根据某些规则压根儿就不考虑某些连接顺序\",{\"1\":{\"556\":1}}],[\"根据这些记录里的主键值到聚簇索引中做回表操作\",{\"1\":{\"549\":1}}],[\"根据这些记录中的主键值到聚簇索引中做回表操作\",{\"1\":{\"549\":1}}],[\"根据搜索条件\",{\"0\":{\"547\":1},\"1\":{\"546\":1}}],[\"根据t2表中的值索引扫描t1表中的对应行\",{\"1\":{\"524\":1}}],[\"根据关联字段在另一张表\",{\"1\":{\"524\":1}}],[\"根据非主键字段排序的分页查询\",{\"1\":{\"522\":1}}],[\"根据主键id取出整行\",{\"1\":{\"520\":2}}],[\"根据要插入的值和当前自增值的大小关系\",{\"1\":{\"491\":1}}],[\"根据mysql5\",{\"1\":{\"479\":1}}],[\"根据上图\",{\"1\":{\"454\":1}}],[\"根据上面的分析\",{\"1\":{\"444\":1}}],[\"根据两阶段锁协议\",{\"1\":{\"443\":1}}],[\"根据两表查询优化的经验\",{\"1\":{\"363\":1}}],[\"根据加锁的范围\",{\"1\":{\"436\":1}}],[\"根据相同的随机方法得到y1\",{\"1\":{\"422\":1}}],[\"根据有序数组\",{\"1\":{\"418\":1}}],[\"根据索引a\",{\"1\":{\"404\":1}}],[\"根据a字段去表t2查找\",{\"1\":{\"401\":1}}],[\"根据存储引擎不同\",{\"1\":{\"381\":1}}],[\"根据叶子节点的内容\",{\"1\":{\"335\":1}}],[\"根据表统计信息及索引选用情况\",{\"1\":{\"330\":1}}],[\"根据词法分析的结果\",{\"1\":{\"320\":1}}],[\"根据id查询文档\",{\"1\":{\"306\":1}}],[\"判读方法是否含有\",{\"1\":{\"1630\":1}}],[\"判定慢\",{\"1\":{\"478\":1}}],[\"判断对象已死\",{\"0\":{\"1713\":1}}],[\"判断beandefinition是否是一个bean\",{\"1\":{\"1647\":1}}],[\"判断流是否是并行流\",{\"1\":{\"1619\":1}}],[\"判断sizectl值是否小于0\",{\"1\":{\"1554\":1}}],[\"判断容器是否初始化\",{\"1\":{\"1554\":1}}],[\"判断链表长度是否大于8\",{\"1\":{\"1554\":1}}],[\"判断链表的长度是否大于8\",{\"1\":{\"1549\":1}}],[\"判断实际存在的键值对数量size是否超过了最大容量\",{\"1\":{\"1549\":1}}],[\"判断table\",{\"1\":{\"1549\":2}}],[\"判断键值对数组table\",{\"1\":{\"1549\":1}}],[\"判断键是否存在\",{\"1\":{\"569\":2}}],[\"判断该链表为红黑树\",{\"1\":{\"1549\":1}}],[\"判断当前的spliterator是否包含传入的characteristics特性值\",{\"1\":{\"1620\":1}}],[\"判断当前执行环境是否为多处理器环境\",{\"1\":{\"1479\":1}}],[\"判断当前线程的中断标志位是否位true\",{\"1\":{\"1477\":1}}],[\"判断key是否过期\",{\"1\":{\"1289\":1}}],[\"判断入口\",{\"1\":{\"1139\":1}}],[\"判断是否需要进行aop\",{\"1\":{\"1649\":1}}],[\"判断是否需要扩容\",{\"1\":{\"1553\":1,\"1554\":1}}],[\"判断是否写完如果没有继续写\",{\"1\":{\"1575\":1}}],[\"判断是否是连接请求\",{\"1\":{\"1574\":1}}],[\"判断是否支持目标对象的类型\",{\"1\":{\"1064\":1}}],[\"判断是不可能为空的\",{\"1\":{\"399\":2}}],[\"判断返回的类型是什么\",{\"1\":{\"963\":1}}],[\"判断如果beanname参数存在时\",{\"1\":{\"929\":1}}],[\"判断模式\",{\"0\":{\"750\":1}}],[\"判断某个事务的修改对当前事务是否可见\",{\"1\":{\"542\":1}}],[\"判断可见性发现\",{\"1\":{\"497\":1}}],[\"判断这个数据是否可见的方法\",{\"1\":{\"497\":1}}],[\"判断同步位点的方案还有另外一个潜在的问题\",{\"1\":{\"472\":1}}],[\"判断主备无延迟方案\",{\"0\":{\"472\":1},\"1\":{\"469\":1}}],[\"判断a\",{\"1\":{\"468\":1}}],[\"判断备库b的seconds\",{\"1\":{\"458\":1}}],[\"判断备库b现在的seconds\",{\"1\":{\"458\":1}}],[\"判断条件的次数是1000\",{\"1\":{\"407\":1}}],[\"判断join是否满足的时候\",{\"1\":{\"407\":1}}],[\"判断join条件需要执行m\",{\"1\":{\"406\":1}}],[\"判断到有可能是null\",{\"1\":{\"399\":1}}],[\"判断到没有冲突\",{\"1\":{\"343\":1}}],[\"判断不能为null\",{\"1\":{\"399\":1}}],[\"判断出email的值不是\",{\"1\":{\"350\":1}}],[\"判断email的值是正确的\",{\"1\":{\"350\":1}}],[\"判断id值是不是10\",{\"1\":{\"322\":1}}],[\"判断输入的sql语句是否满足mysql语法\",{\"1\":{\"320\":1}}],[\"检测和修改其本身状态或行为的一种能力\",{\"1\":{\"1558\":1}}],[\"检测一条记录是否符合搜索条件的成本\",{\"1\":{\"557\":1}}],[\"检测一条记录是否符合搜索条件的成本默认是0\",{\"1\":{\"557\":1}}],[\"检测系统发现\",{\"1\":{\"478\":1}}],[\"检测命令\",{\"1\":{\"478\":1}}],[\"检查当前类加载器是否已经加载了该类\",{\"1\":{\"1663\":1}}],[\"检查当前库中指定个数的key\",{\"1\":{\"1289\":1}}],[\"检查通过name查找到的bean是否是requiredtype类型的bean\",{\"1\":{\"1647\":1}}],[\"检查spring容器中是否已经含有这个名字的bean\",{\"1\":{\"1647\":1}}],[\"检查map中是否存在该名字\",{\"1\":{\"1613\":1}}],[\"检查是否需要扩容\",{\"1\":{\"1554\":1}}],[\"检查是否为空\",{\"1\":{\"1502\":1}}],[\"检查是否有这个名字的临时表\",{\"1\":{\"412\":1}}],[\"检查加载到的字节码信息是否符合jvm规范\",{\"1\":{\"1433\":1}}],[\"检查类是否已经被加载\",{\"1\":{\"1429\":1}}],[\"检查令牌的网络请求就有可能成为一个性能瓶颈\",{\"1\":{\"1203\":1}}],[\"检查慢日志记录是找出扫描行数过多的查询的好办法\",{\"1\":{\"387\":1}}],[\"遇到进程进入锁等待的情况时\",{\"1\":{\"476\":1}}],[\"超\",{\"1\":{\"1036\":1}}],[\"超级\",{\"1\":{\"917\":1}}],[\"超级用户\",{\"1\":{\"917\":1}}],[\"超时了\",{\"1\":{\"571\":1}}],[\"超时返回1\",{\"1\":{\"474\":1}}],[\"超大事务执行期间被kill\",{\"1\":{\"481\":1}}],[\"超过最大索引值加1\",{\"1\":{\"1620\":1}}],[\"超过最大值就不再扩充\",{\"1\":{\"1550\":1}}],[\"超过最大容量就扩容\",{\"1\":{\"1549\":1}}],[\"超过阻塞时间\",{\"1\":{\"1501\":2}}],[\"超过年龄先之后\",{\"1\":{\"1436\":1}}],[\"超过n秒后还不返回\",{\"1\":{\"478\":1}}],[\"超过了sort\",{\"1\":{\"421\":1}}],[\"超过了16\",{\"1\":{\"355\":1}}],[\"选取其中成本更低的连接顺序去真正的执行查询\",{\"1\":{\"555\":1}}],[\"选择一款mq学习就可以了\",{\"1\":{\"1985\":1}}],[\"选择发送的路由\",{\"0\":{\"1881\":1}}],[\"选择oneway形式发送\",{\"0\":{\"1855\":1}}],[\"选择并行流还是串行流\",{\"1\":{\"1617\":1}}],[\"选择8是根据概率统计而选择的\",{\"1\":{\"1362\":1}}],[\"选择errors\",{\"1\":{\"1063\":1}}],[\"选择errors实现\",{\"1\":{\"1063\":1}}],[\"选择器模式\",{\"1\":{\"900\":1}}],[\"选择正确的数据类型\",{\"1\":{\"527\":1}}],[\"选择了索引a\",{\"1\":{\"416\":1}}],[\"选出一个新的主库\",{\"1\":{\"488\":1}}],[\"选定一个从库执行查询语句\",{\"1\":{\"473\":1,\"474\":1}}],[\"马上就可以获取对应位置的元素\",{\"1\":{\"1548\":1}}],[\"马上执行show\",{\"1\":{\"473\":1}}],[\"马上要返回主页面\",{\"1\":{\"470\":1}}],[\"仔细观察可以发现\",{\"1\":{\"472\":1}}],[\"买家就可以通过这个现实\",{\"1\":{\"471\":1}}],[\"买家来逛商铺页面\",{\"1\":{\"470\":1}}],[\"卖家发布商品后\",{\"1\":{\"470\":1}}],[\"处理socket连接\",{\"1\":{\"1683\":1}}],[\"处理spring容器的生命周期\",{\"1\":{\"1651\":1}}],[\"处理spring配置类\",{\"1\":{\"945\":1}}],[\"处理特定的host下客户请求\",{\"1\":{\"1683\":1}}],[\"处理桥接方法\",{\"1\":{\"1648\":1}}],[\"处理属性回调\",{\"1\":{\"1647\":1}}],[\"处理排除过滤器和包含过滤器\",{\"1\":{\"1647\":1}}],[\"处理后续的元素之前\",{\"1\":{\"1623\":1}}],[\"处理完成通过输出流回应客户端\",{\"1\":{\"1573\":1}}],[\"处理完了继续过来轮询\",{\"1\":{\"603\":1}}],[\"处理的数据类型\",{\"1\":{\"1545\":1}}],[\"处理的方式有很多种\",{\"1\":{\"1261\":1}}],[\"处理请求的方法\",{\"1\":{\"1657\":1}}],[\"处理请求\",{\"1\":{\"1533\":1,\"1534\":1}}],[\"处理器会在计算之后将乱序执行的结果重组\",{\"1\":{\"1405\":1}}],[\"处理器可能会对输入的代码进行乱序执行优化\",{\"1\":{\"1405\":1}}],[\"处理器模式\",{\"1\":{\"900\":1}}],[\"处理方式有两种\",{\"1\":{\"1607\":1}}],[\"处理方式\",{\"1\":{\"1261\":1}}],[\"处理方法\",{\"1\":{\"1103\":1,\"1112\":1}}],[\"处理aware接口\",{\"1\":{\"1234\":1}}],[\"处理循环依赖的核心代码\",{\"1\":{\"1184\":1}}],[\"处理collection相关\",{\"1\":{\"1101\":1}}],[\"处理泛型类型变量\",{\"1\":{\"1100\":1}}],[\"处理泛型参数类型\",{\"1\":{\"1100\":1}}],[\"处理类型相关\",{\"1\":{\"1100\":1}}],[\"处理标注\",{\"1\":{\"945\":1}}],[\"处理jsr\",{\"1\":{\"945\":1}}],[\"处理\",{\"1\":{\"945\":1,\"1175\":1,\"1647\":1,\"1648\":2,\"1650\":1}}],[\"处理查询结果集\",{\"1\":{\"645\":1}}],[\"处理其它事情\",{\"1\":{\"603\":1}}],[\"处理这种\",{\"1\":{\"469\":1}}],[\"处\",{\"1\":{\"481\":1}}],[\"处于不能处理命令请求的状态\",{\"1\":{\"624\":1}}],[\"处于客户端已经收到提交确认\",{\"1\":{\"472\":1}}],[\"处于prepare状态的事务\",{\"1\":{\"465\":1}}],[\"过饱问题解决方案\",{\"0\":{\"1536\":1}}],[\"过于暴力\",{\"1\":{\"1477\":1}}],[\"过多的请求就会瞬间写到db上\",{\"1\":{\"1283\":1}}],[\"过程描述如下\",{\"1\":{\"1647\":1}}],[\"过程描述\",{\"1\":{\"1241\":1}}],[\"过期后\",{\"1\":{\"1289\":1}}],[\"过期时间内\",{\"1\":{\"1287\":1}}],[\"过期策略可以设置\",{\"1\":{\"645\":1}}],[\"过期的key\",{\"1\":{\"569\":1}}],[\"过期读\",{\"1\":{\"469\":2}}],[\"过滤消息\",{\"0\":{\"1915\":1}}],[\"过滤类\",{\"0\":{\"1914\":1}}],[\"过滤服务器\",{\"0\":{\"1913\":1}}],[\"过滤阶段会消耗字符串集合\",{\"1\":{\"1623\":1}}],[\"过滤\",{\"1\":{\"1608\":1,\"1623\":1}}],[\"过滤器指的是\",{\"1\":{\"1354\":1}}],[\"过滤器和拦截器的区别\",{\"0\":{\"25\":1,\"1354\":1}}],[\"过滤掉不符合条件的记录之后再回表\",{\"1\":{\"518\":1}}],[\"过滤完成之后\",{\"1\":{\"403\":1}}],[\"严格意义上来说\",{\"1\":{\"1292\":1}}],[\"严格地说\",{\"1\":{\"472\":1}}],[\"严格控制策略\",{\"1\":{\"309\":1}}],[\"严谨地说\",{\"1\":{\"468\":1}}],[\"ƒsource\",{\"1\":{\"468\":1}}],[\"彻底解决了这个问题\",{\"1\":{\"468\":1}}],[\"错误的订阅关系\",{\"0\":{\"1866\":1}}],[\"错误收集器\",{\"1\":{\"1061\":1,\"1068\":1}}],[\"错误\",{\"1\":{\"467\":1,\"1064\":2}}],[\"互不影响\",{\"1\":{\"1510\":1}}],[\"互斥是保证临界区的竞态条件发生\",{\"1\":{\"1482\":1}}],[\"互斥量\",{\"1\":{\"1477\":1,\"1483\":1}}],[\"互斥问题\",{\"1\":{\"1470\":1}}],[\"互斥同步\",{\"0\":{\"1816\":1},\"1\":{\"1392\":1}}],[\"互斥等待\",{\"1\":{\"381\":1}}],[\"互相不干扰\",{\"1\":{\"1262\":1}}],[\"互为主备\",{\"1\":{\"466\":1}}],[\"增强了程序的灵活性可移植性\",{\"1\":{\"1558\":1}}],[\"增强for循环\",{\"1\":{\"1353\":1}}],[\"增加默认方法也可以看到\",{\"1\":{\"1607\":1}}],[\"增加默认方法的特性是java对于支持函数式编程一个非常重要的改变\",{\"1\":{\"1607\":1}}],[\"增加\",{\"1\":{\"1353\":1}}],[\"增加一个myinterface1的实现类\",{\"1\":{\"1607\":1}}],[\"增加一个随机值\",{\"1\":{\"1284\":1}}],[\"增加一个额外的隐藏信息<input\",{\"1\":{\"1201\":1}}],[\"增加token\",{\"1\":{\"1201\":1}}],[\"增加org\",{\"1\":{\"1088\":1}}],[\"增加了其他功能\",{\"1\":{\"1636\":1}}],[\"增加了多线程的支持\",{\"1\":{\"601\":1}}],[\"增加了一种完全耐久的持久化方式\",{\"1\":{\"592\":1}}],[\"增加了一个参数binlog\",{\"1\":{\"465\":1}}],[\"增大这个值会加重i\",{\"1\":{\"557\":1}}],[\"增大这个值可以让优化器倾向于使用索引而不是直接全表扫描\",{\"1\":{\"557\":1}}],[\"增删改\",{\"1\":{\"437\":1}}],[\"针对一个集合\",{\"1\":{\"1611\":1}}],[\"针对一个变量\",{\"1\":{\"1479\":1}}],[\"针对于int值的分割迭代器\",{\"1\":{\"1620\":1}}],[\"针对于iterable每一个元素去执行给定的动作\",{\"1\":{\"1595\":1}}],[\"针对于文档中提到相同的异常\",{\"1\":{\"1619\":1}}],[\"针对于之前的学生的集合\",{\"1\":{\"1616\":1}}],[\"针对于以上的例子\",{\"1\":{\"1603\":1}}],[\"针对于predicate可以定义\",{\"1\":{\"1599\":1}}],[\"针对于给定的t类型的参数t来计算\",{\"1\":{\"1599\":1}}],[\"针对这种场景\",{\"1\":{\"1498\":1}}],[\"针对重量级锁\",{\"1\":{\"1489\":1}}],[\"针对偏向锁\",{\"1\":{\"1489\":1}}],[\"针对收集对象处于哪一代\",{\"1\":{\"1434\":1}}],[\"针对的是主备切换时\",{\"1\":{\"467\":1}}],[\"针对并行度做了优化\",{\"1\":{\"465\":1}}],[\"针对单词建立索引\",{\"1\":{\"299\":1}}],[\"强烈建议spliterator返回immutable\",{\"1\":{\"1621\":1}}],[\"强烈建议你不要这么做\",{\"1\":{\"318\":1}}],[\"强引用\",{\"1\":{\"1435\":1}}],[\"强分代假说\",{\"1\":{\"1434\":1}}],[\"强大的第三方整合\",{\"1\":{\"916\":1}}],[\"强制指定只查一个数据库\",{\"1\":{\"1270\":1}}],[\"强制gc\",{\"1\":{\"1013\":1}}],[\"强制线程执行完成\",{\"1\":{\"989\":1}}],[\"强制触发gc\",{\"1\":{\"934\":1}}],[\"强制将其发到主库上\",{\"1\":{\"470\":1}}],[\"强制走主库方案其实就是\",{\"1\":{\"470\":1}}],[\"强制走主库方案\",{\"0\":{\"470\":1},\"1\":{\"469\":1}}],[\"强行使用这个策略\",{\"1\":{\"463\":1}}],[\"耗时很长\",{\"1\":{\"481\":1}}],[\"耗费cpu\",{\"1\":{\"462\":1}}],[\"耗费内存\",{\"1\":{\"462\":1}}],[\"耗尽系统资源\",{\"1\":{\"393\":1}}],[\"里面实现了双亲委派机制\",{\"1\":{\"1663\":1}}],[\"里面的内容是实现者实现的类的完整的类限定名\",{\"1\":{\"1658\":1}}],[\"里面的流程却没有那么简单\",{\"1\":{\"1580\":1}}],[\"里面存的是部分属性为空的对象\",{\"1\":{\"1649\":1}}],[\"里面有大量的关于collector的实现\",{\"1\":{\"1618\":1}}],[\"里面有很多配置项\",{\"1\":{\"624\":1}}],[\"里面包含计划花费的成本\",{\"1\":{\"553\":1}}],[\"里面只放一行数据\",{\"1\":{\"477\":1}}],[\"里的\",{\"1\":{\"542\":1}}],[\"里的事务所涉及到的表\",{\"1\":{\"461\":1}}],[\"里取出满足条件的行\",{\"1\":{\"524\":1}}],[\"里创建一个表\",{\"1\":{\"477\":1}}],[\"里\",{\"1\":{\"461\":1}}],[\"各种协议和通信模型的组合有相应的具体实现类\",{\"1\":{\"1687\":1}}],[\"各种参数解释如下\",{\"1\":{\"1510\":1}}],[\"各种锁都会影响并发度\",{\"1\":{\"460\":1}}],[\"各个web项目之间可以提供共享的java类库\",{\"1\":{\"1693\":1}}],[\"各个web项目各自使用的java类库要相互隔离\",{\"1\":{\"1693\":1}}],[\"各个参数对应的含义\",{\"1\":{\"1664\":1}}],[\"各个字段的含义\",{\"1\":{\"558\":1}}],[\"各个字段的统计逻辑\",{\"1\":{\"479\":1}}],[\"各个变量的含义\",{\"1\":{\"538\":1}}],[\"各个版本的多线程复制\",{\"1\":{\"460\":1}}],[\"切换次数\",{\"1\":{\"1582\":1,\"1583\":1,\"1584\":1}}],[\"切换\",{\"1\":{\"1123\":1}}],[\"切换数据库\",{\"1\":{\"567\":1}}],[\"切换的流程和结果\",{\"1\":{\"459\":1}}],[\"切到db1库\",{\"1\":{\"482\":1}}],[\"切分查询\",{\"0\":{\"393\":1}}],[\"试想\",{\"1\":{\"1607\":1}}],[\"试想如果一开始主备延迟就长达30分钟\",{\"1\":{\"458\":1}}],[\"试图插入临时表中\",{\"1\":{\"414\":1}}],[\"造成吞吐量下降\",{\"1\":{\"1328\":1}}],[\"造成瞬时db请求量大\",{\"1\":{\"629\":1,\"632\":1}}],[\"造成数据库极大的压力\",{\"1\":{\"626\":1}}],[\"造成主备延迟\",{\"1\":{\"460\":1}}],[\"造成主备不一致\",{\"1\":{\"453\":1}}],[\"造成了主备延迟\",{\"1\":{\"457\":1}}],[\"死信队列\",{\"0\":{\"1839\":1}}],[\"死循环在这里就断掉了\",{\"1\":{\"455\":1}}],[\"死锁检测的时间复杂度与并发量正相关\",{\"1\":{\"444\":1}}],[\"死锁检测要耗费大量的cpu资源\",{\"1\":{\"444\":1}}],[\"死锁和死锁检测\",{\"0\":{\"444\":1}}],[\"死锁\",{\"1\":{\"431\":1,\"1389\":1}}],[\"死锁与饥饿的区别\",{\"0\":{\"61\":1,\"1390\":1}}],[\"死锁与活锁的区别\",{\"0\":{\"60\":1,\"1389\":1}}],[\"传播行为是spring事务管理中的难点\",{\"1\":{\"1655\":1}}],[\"传递到onstartup方法的第一个参数上面\",{\"1\":{\"1658\":1}}],[\"传递给container\",{\"1\":{\"1687\":1}}],[\"传递给提供的sink\",{\"1\":{\"1623\":1}}],[\"传递给accumulator方法的第一个参数\",{\"1\":{\"1615\":1}}],[\"传递行为\",{\"1\":{\"1620\":1}}],[\"传递的action如果是lambda表达式就既满足了consumer的要求\",{\"1\":{\"1620\":1}}],[\"传递的方式\",{\"1\":{\"1570\":1}}],[\"传递隐形别名\",{\"1\":{\"1136\":1}}],[\"传入一个对象\",{\"1\":{\"1605\":1}}],[\"传入即可\",{\"1\":{\"1598\":1}}],[\"传入readcompletionhandler作为回调\",{\"1\":{\"1575\":1}}],[\"传入acceptcompletionhandler作为回调来接收连接消息\",{\"1\":{\"1575\":1}}],[\"传入新的容量\",{\"1\":{\"1550\":1}}],[\"传入的是\",{\"1\":{\"1554\":1}}],[\"传入的request\",{\"1\":{\"1354\":1}}],[\"传入的这一行的值是\",{\"1\":{\"491\":1}}],[\"传输效率最佳\",{\"1\":{\"1583\":1}}],[\"传输速度总是不尽人意\",{\"1\":{\"1580\":1}}],[\"传输不可靠\",{\"1\":{\"1419\":1}}],[\"传输层的通讯协议\",{\"1\":{\"1419\":1}}],[\"传输层通讯协议\",{\"1\":{\"1419\":1}}],[\"传输方式\",{\"0\":{\"678\":1}}],[\"传输格式\",{\"0\":{\"677\":1}}],[\"传统拷贝方式\",{\"1\":{\"1585\":1}}],[\"传统线程池threadpoolexecutor有两个明显的缺点\",{\"1\":{\"1510\":1}}],[\"传统文件复制方式\",{\"1\":{\"1331\":1}}],[\"传统实例化方式\",{\"1\":{\"1001\":1}}],[\"传统实现\",{\"1\":{\"577\":1}}],[\"传统ioc容器的实现\",{\"0\":{\"909\":1}}],[\"传统用户\",{\"1\":{\"900\":1}}],[\"传统gof23\",{\"1\":{\"900\":1}}],[\"传统的fork\",{\"1\":{\"1527\":1}}],[\"传统的方式可以在abstractautowirecapablebeanfactory\",{\"1\":{\"1001\":1}}],[\"传统的模型\",{\"0\":{\"704\":1}}],[\"传统的io流程\",{\"0\":{\"693\":1}}],[\"传统的关系型数据库和es的区别\",{\"1\":{\"301\":1}}],[\"传到备库应用的时候\",{\"1\":{\"464\":1}}],[\"传到节点b执行一次后\",{\"1\":{\"455\":1}}],[\"恢复的速度要快\",{\"1\":{\"596\":1}}],[\"恢复的时候就把这个文件全部再执行一遍\",{\"1\":{\"591\":1}}],[\"恢复速度\",{\"1\":{\"595\":1}}],[\"恢复时间不可控\",{\"1\":{\"486\":1}}],[\"恢复回主库\",{\"1\":{\"484\":1}}],[\"恢复出一个备份\",{\"1\":{\"484\":1}}],[\"恢复出来的这一行的c的值就是1\",{\"1\":{\"327\":1}}],[\"恢复出来的这一行c的值就是0\",{\"1\":{\"327\":1}}],[\"恢复gtid的默认分配行为\",{\"1\":{\"468\":1}}],[\"恢复并行模式\",{\"1\":{\"462\":1}}],[\"恢复数据集的速度也要比\",{\"1\":{\"596\":1}}],[\"恢复数据的思路主要就是通过备份\",{\"1\":{\"485\":1}}],[\"恢复数据的流程如下\",{\"1\":{\"485\":1}}],[\"恢复数据比较安全的做法是\",{\"1\":{\"484\":1}}],[\"恢复数据\",{\"1\":{\"454\":1}}],[\"却可以重复\",{\"1\":{\"574\":1}}],[\"却无法知道它为什么做这个决策\",{\"1\":{\"544\":1}}],[\"却使用了索引t\",{\"1\":{\"454\":1}}],[\"却不知道这条语句在mysql内部的执行过程\",{\"1\":{\"317\":1}}],[\"甚至可以\",{\"1\":{\"1617\":1}}],[\"甚至加锁的操作是出现在循环体中的\",{\"1\":{\"1486\":1}}],[\"甚至更多\",{\"1\":{\"1449\":1}}],[\"甚至是替换\",{\"1\":{\"1015\":1}}],[\"甚至是一些粗粒度的组件\",{\"1\":{\"910\":1}}],[\"甚至直接崩溃\",{\"1\":{\"600\":1}}],[\"甚至连注释也一并记录了\",{\"1\":{\"454\":1}}],[\"甚至join这样的操作\",{\"1\":{\"411\":1}}],[\"地理位置\",{\"0\":{\"576\":1},\"1\":{\"1280\":1}}],[\"地图信息分析\",{\"1\":{\"565\":1}}],[\"地记录了sql命令\",{\"1\":{\"454\":1}}],[\"地址\",{\"0\":{\"284\":1,\"285\":1},\"1\":{\"1561\":1}}],[\"地址总线\",{\"0\":{\"280\":1}}],[\"忠实\",{\"1\":{\"454\":1}}],[\"解密\",{\"1\":{\"1510\":1}}],[\"解锁\",{\"1\":{\"1473\":1,\"1503\":1}}],[\"解锁操作\",{\"1\":{\"1400\":1}}],[\"解锁获取最新值\",{\"1\":{\"581\":1}}],[\"解耦之后可以实现数据分发\",{\"1\":{\"1326\":1}}],[\"解耦\",{\"1\":{\"1326\":1}}],[\"解析字节流\",{\"1\":{\"1687\":1}}],[\"解析和初始化过\",{\"1\":{\"1666\":1}}],[\"解析和序列化\",{\"0\":{\"668\":1}}],[\"解析配置类\",{\"1\":{\"1651\":1}}],[\"解析spring表达式\",{\"1\":{\"1648\":1}}],[\"解析sql\",{\"1\":{\"645\":1}}],[\"解析范围\",{\"1\":{\"1183\":1}}],[\"解析beandefinition\",{\"1\":{\"1035\":1}}],[\"解析binlog\",{\"1\":{\"462\":1}}],[\"解析\",{\"0\":{\"1789\":1,\"1806\":1},\"1\":{\"1025\":1,\"1433\":1,\"1663\":2}}],[\"解析并且生成beandefinition\",{\"1\":{\"953\":1,\"954\":1}}],[\"解析到的所有对象的数据会存储到\",{\"1\":{\"645\":1}}],[\"解析过程\",{\"1\":{\"645\":1}}],[\"解析出日志里的命令\",{\"1\":{\"453\":1}}],[\"解决循环依赖\",{\"1\":{\"1649\":1}}],[\"解决事务失效的核心思路\",{\"1\":{\"1630\":1}}],[\"解决线程之间的协作不可避免会用到阻塞唤醒机制\",{\"1\":{\"1530\":1}}],[\"解决并发问题的方法\",{\"1\":{\"1668\":1}}],[\"解决并发问题\",{\"1\":{\"1526\":1}}],[\"解决并发扫描时对象消失问题的两种方案\",{\"0\":{\"115\":1,\"1446\":1}}],[\"解决办法\",{\"1\":{\"1373\":1,\"1536\":3}}],[\"解决构造方法造成的循环依赖问题\",{\"1\":{\"1237\":1}}],[\"解决这个缺陷的方式就是设置较短过期时间\",{\"1\":{\"627\":1}}],[\"解决这个问题通常来说有两种方式\",{\"1\":{\"352\":1}}],[\"解决这个问题通常有两种方案\",{\"1\":{\"318\":1}}],[\"解决方案大致总结如下\",{\"1\":{\"1248\":1}}],[\"解决方案\",{\"0\":{\"627\":1,\"630\":1,\"633\":1,\"732\":1},\"1\":{\"1282\":1,\"1283\":1,\"1284\":1,\"1286\":1,\"1287\":1}}],[\"密码模式\",{\"1\":{\"1202\":1}}],[\"密码后\",{\"1\":{\"453\":1}}],[\"密码\",{\"1\":{\"453\":1}}],[\"端口号\",{\"1\":{\"609\":1}}],[\"端口\",{\"1\":{\"453\":1,\"467\":1}}],[\"权限用户是无效的\",{\"1\":{\"453\":1}}],[\"模版方法\",{\"1\":{\"1651\":2,\"1658\":1}}],[\"模运算的消耗还是比较大的\",{\"1\":{\"1548\":1}}],[\"模块等\",{\"1\":{\"1138\":1}}],[\"模块\",{\"1\":{\"1138\":2}}],[\"模块驱动\",{\"1\":{\"899\":1,\"903\":1}}],[\"模板解释器\",{\"1\":{\"1473\":1}}],[\"模板方法设计模式\",{\"1\":{\"906\":1}}],[\"模板方法模式\",{\"0\":{\"735\":1,\"846\":1}}],[\"模板模式\",{\"1\":{\"899\":1}}],[\"模拟处理请求\",{\"1\":{\"1533\":1,\"1534\":1}}],[\"模拟spring\",{\"1\":{\"1082\":1}}],[\"模拟对象\",{\"1\":{\"896\":1}}],[\"模拟线程插队\",{\"1\":{\"581\":1}}],[\"模拟主库的并行模式\",{\"1\":{\"464\":1}}],[\"模式的一个最经典的应用场景是网络编程里服务端的实现\",{\"1\":{\"1533\":1}}],[\"模式有一个非常典型的应用场景就是单次初始化\",{\"1\":{\"1531\":1}}],[\"模式切换\",{\"1\":{\"1123\":2}}],[\"模式注解是一种注解\",{\"1\":{\"1134\":1}}],[\"模式注解\",{\"1\":{\"899\":1}}],[\"模式\",{\"1\":{\"453\":1,\"952\":1}}],[\"模糊查询like语句该怎么写\",{\"0\":{\"197\":1,\"1213\":1}}],[\"拖时间\",{\"1\":{\"451\":1}}],[\"节省了很多计算量\",{\"1\":{\"465\":1}}],[\"节省内存空间\",{\"1\":{\"308\":1}}],[\"节点key存在\",{\"1\":{\"1549\":1}}],[\"节点\",{\"1\":{\"1509\":1}}],[\"节点之间不会主动进行消息同步\",{\"1\":{\"1328\":1}}],[\"节点信息\",{\"1\":{\"1256\":1}}],[\"节点可用性的检测都应该包含主库和备库\",{\"1\":{\"478\":1}}],[\"节点b生成的binlog的server\",{\"1\":{\"455\":1}}],[\"节点b执行完这条更新语句后也会生成binlog\",{\"1\":{\"455\":1}}],[\"节点a和b之间总是互为主备关系\",{\"1\":{\"455\":1}}],[\"节约了资源\",{\"1\":{\"1194\":1}}],[\"节约了系统资源\",{\"1\":{\"1191\":1}}],[\"节约iops的效果就越好\",{\"1\":{\"451\":1}}],[\"节约磁盘iops效果越好\",{\"1\":{\"451\":1}}],[\"组件\",{\"0\":{\"1128\":1},\"1\":{\"929\":1,\"1134\":1,\"1146\":2}}],[\"组合索引\",{\"1\":{\"1276\":1}}],[\"组合优先于继承\",{\"1\":{\"1165\":1}}],[\"组合形成一个独立的单元\",{\"1\":{\"1138\":1}}],[\"组合注解\",{\"0\":{\"1135\":1}}],[\"组合模式\",{\"0\":{\"841\":1},\"1\":{\"899\":1}}],[\"组合应用\",{\"1\":{\"307\":1}}],[\"组成的双向循环链表\",{\"1\":{\"1483\":1}}],[\"组成集群的方式来利用多核cpu的能力\",{\"1\":{\"1292\":1}}],[\"组成集合writeset\",{\"1\":{\"465\":1}}],[\"组成\",{\"1\":{\"542\":1,\"624\":1}}],[\"组员可能越多\",{\"1\":{\"451\":1}}],[\"组员越多\",{\"1\":{\"451\":1}}],[\"带来非常大的开销\",{\"1\":{\"1479\":1}}],[\"带来了更高的执行负载\",{\"1\":{\"1449\":1}}],[\"带有lock前缀的指令在执行期间会锁住总线\",{\"1\":{\"1473\":1}}],[\"带上距离\",{\"1\":{\"576\":1}}],[\"带上坐标\",{\"1\":{\"576\":1}}],[\"带权重进行判断\",{\"1\":{\"574\":1}}],[\"带proxy架构的整体就相对比较复杂\",{\"1\":{\"469\":1}}],[\"带proxy的结构\",{\"1\":{\"469\":1}}],[\"带的就是lsn=160\",{\"1\":{\"451\":1}}],[\"带头大哥不能死\",{\"1\":{\"370\":1}}],[\"配对类型\",{\"1\":{\"1086\":1,\"1089\":1}}],[\"配套组件\",{\"1\":{\"1061\":1,\"1062\":1}}],[\"配套的提交语句是commit\",{\"1\":{\"435\":1}}],[\"配合\",{\"1\":{\"1113\":1}}],[\"配合读写分离\",{\"1\":{\"607\":1}}],[\"配合semi\",{\"1\":{\"469\":1}}],[\"配置太繁琐了\",{\"1\":{\"1983\":1}}],[\"配置管理\",{\"0\":{\"1870\":1}}],[\"配置属性字符编码\",{\"1\":{\"1155\":1}}],[\"配置属性抽象propertysource注解\",{\"1\":{\"1029\":1}}],[\"配置阶段\",{\"1\":{\"1139\":1}}],[\"配置化条件装配\",{\"1\":{\"1023\":1}}],[\"配置类\",{\"0\":{\"1873\":1}}],[\"配置类加载的主要的类\",{\"1\":{\"1652\":1}}],[\"配置类解析与扫描过程源码解析\",{\"0\":{\"1652\":1}}],[\"配置类模式注解\",{\"1\":{\"1023\":1,\"1131\":1}}],[\"配置类方式\",{\"1\":{\"929\":1}}],[\"配置class也是\",{\"1\":{\"955\":1}}],[\"配置元数据\",{\"1\":{\"972\":1,\"973\":1}}],[\"配置元数据举例\",{\"1\":{\"951\":1}}],[\"配置元信息主要可以分为以下五个方面\",{\"1\":{\"1017\":1}}],[\"配置元信息\",{\"1\":{\"900\":1,\"909\":1,\"921\":1,\"930\":5,\"974\":1,\"1002\":1,\"1022\":1}}],[\"配置或者编程的方式\",{\"1\":{\"951\":1}}],[\"配置设置\",{\"1\":{\"927\":1}}],[\"配置xml文件\",{\"1\":{\"917\":1,\"918\":1,\"919\":1}}],[\"配置器模式\",{\"1\":{\"900\":1}}],[\"配置加载和缓存处理\",{\"1\":{\"645\":1}}],[\"配置当某一事件发生时所需要执行的脚本\",{\"1\":{\"624\":1}}],[\"配置所有slaves指向新的master所需的最大时间\",{\"1\":{\"624\":1}}],[\"配置redis\",{\"1\":{\"583\":1}}],[\"配置为logical\",{\"1\":{\"465\":1}}],[\"配置为database\",{\"1\":{\"465\":1}}],[\"配置\",{\"1\":{\"451\":1,\"899\":1,\"900\":1,\"907\":1,\"986\":1,\"987\":1,\"988\":1,\"989\":1,\"1021\":1}}],[\"双列集合有map\",{\"1\":{\"1538\":1}}],[\"双向链表\",{\"1\":{\"1490\":1}}],[\"双重检测\",{\"1\":{\"1476\":1}}],[\"双重检查锁\",{\"0\":{\"269\":1,\"1193\":1}}],[\"双亲委托机制\",{\"0\":{\"1692\":1}}],[\"双亲委派模型\",{\"0\":{\"1793\":1}}],[\"双亲委派机制简单来说就是\",{\"1\":{\"1663\":1}}],[\"双亲委派\",{\"1\":{\"1432\":1}}],[\"双亲beanfactory\",{\"1\":{\"942\":1}}],[\"双端队列等\",{\"1\":{\"571\":1}}],[\"双精度浮点数值\",{\"1\":{\"528\":1}}],[\"双路排序的详细过程\",{\"1\":{\"520\":1}}],[\"双路排序\",{\"1\":{\"520\":1}}],[\"双m的主备结构里要求双写的时候\",{\"1\":{\"491\":1}}],[\"双m结构有一个显著的问题需要解决\",{\"1\":{\"455\":1}}],[\"双1\",{\"1\":{\"451\":1}}],[\"顺带将这个事务的redo\",{\"1\":{\"451\":1}}],[\"顺序消费\",{\"0\":{\"1859\":1,\"1861\":1}}],[\"顺序是从输出寄存器序列从左到右从上到下以\",{\"1\":{\"1479\":1}}],[\"顺序不同\",{\"1\":{\"1339\":1,\"1482\":1}}],[\"顺序\",{\"1\":{\"975\":1}}],[\"顺序写磁盘上的日志文件的性能也是很高的\",{\"1\":{\"543\":1}}],[\"顺序扫描\",{\"1\":{\"417\":1}}],[\"顺序性\",{\"1\":{\"404\":1,\"578\":1}}],[\"顺序读取最后的12行数据放入join\",{\"1\":{\"403\":1}}],[\"顺序读取数据行放入join\",{\"1\":{\"403\":1}}],[\"物理上是在文件系统的page\",{\"1\":{\"451\":1}}],[\"物理上是在mysql进程内存中\",{\"1\":{\"451\":1}}],[\"防止出现链表成环\",{\"1\":{\"1554\":1}}],[\"防止高并发情况\",{\"1\":{\"1388\":1}}],[\"防止脏读和不可重复读\",{\"1\":{\"1262\":1}}],[\"防止脏读\",{\"1\":{\"1262\":1}}],[\"防止页面重复提交\",{\"1\":{\"1248\":1}}],[\"防止新增脏数据\",{\"1\":{\"1248\":1}}],[\"防止csrf的方式\",{\"1\":{\"1201\":1}}],[\"防止切换逻辑有bug\",{\"1\":{\"453\":1}}],[\"防止数据丢失\",{\"0\":{\"449\":1}}],[\"防止记录插入\",{\"1\":{\"442\":1}}],[\"∞\",{\"1\":{\"448\":1}}],[\"影子分页\",{\"1\":{\"561\":1}}],[\"影院的账户总额等于这10个记录的值的总和\",{\"1\":{\"444\":1}}],[\"影响用户体验\",{\"1\":{\"1573\":1}}],[\"影响效率\",{\"1\":{\"1449\":1}}],[\"影响的是可用性\",{\"1\":{\"495\":1}}],[\"影响的是数据可靠性\",{\"1\":{\"495\":1}}],[\"影响了同步速度\",{\"1\":{\"457\":1}}],[\"影响执行速度\",{\"1\":{\"454\":1}}],[\"影响会更大\",{\"1\":{\"425\":1}}],[\"影响内存命中率\",{\"1\":{\"406\":1}}],[\"影响到性能外\",{\"1\":{\"351\":1}}],[\"顾客a要在影院b购买电影票\",{\"1\":{\"443\":1}}],[\"顾名思义指的就是总和\",{\"1\":{\"479\":1}}],[\"顾名思义\",{\"1\":{\"437\":1,\"448\":1}}],[\"拿这个时间跟当前时间比对\",{\"1\":{\"1288\":1}}],[\"拿回原库重放\",{\"1\":{\"484\":1}}],[\"拿不到也不要阻塞后面的业务语句\",{\"1\":{\"441\":1}}],[\"拿到合并后的beanfinition\",{\"1\":{\"1647\":1}}],[\"拿到sql语句\",{\"1\":{\"646\":1}}],[\"拿到事件后\",{\"1\":{\"603\":1}}],[\"拿到以后再取最后6个字节的话就是0\",{\"1\":{\"495\":1}}],[\"拿到的自增id就是3\",{\"1\":{\"491\":1}}],[\"拿到第一行id=1000\",{\"1\":{\"414\":1}}],[\"拿到分库的数据以后\",{\"1\":{\"411\":1}}],[\"删掉这被误插入的一行数据就可以了\",{\"1\":{\"454\":1}}],[\"删了一列\",{\"1\":{\"441\":1}}],[\"删除元素的时间复杂度也变为了o\",{\"1\":{\"1502\":1}}],[\"删除元素\",{\"1\":{\"1363\":1,\"1538\":1}}],[\"删除和成员判断等操作\",{\"1\":{\"1280\":1}}],[\"删除速度最快\",{\"1\":{\"1271\":1}}],[\"删除所有数据\",{\"1\":{\"1271\":1}}],[\"删除与备份\",{\"1\":{\"1271\":1}}],[\"删除数据和表结构\",{\"1\":{\"1271\":1}}],[\"删除数据时进行两个动作\",{\"1\":{\"1271\":1}}],[\"删除数据\",{\"1\":{\"1271\":1}}],[\"删除方式\",{\"1\":{\"1271\":1}}],[\"删除studentx\",{\"1\":{\"573\":1}}],[\"删除哈希表key中一个\",{\"1\":{\"573\":1}}],[\"删除\",{\"1\":{\"572\":1,\"1280\":1,\"1288\":1,\"1353\":1,\"1546\":1,\"1548\":1}}],[\"删除后\",{\"1\":{\"571\":2}}],[\"删除列表中所有的指定value\",{\"1\":{\"571\":1}}],[\"删除个数\",{\"1\":{\"569\":1}}],[\"删除键值对\",{\"1\":{\"569\":2}}],[\"删除操作都只是设置一下老记录的delete\",{\"1\":{\"542\":1}}],[\"删除一条记录时\",{\"1\":{\"542\":1}}],[\"删除表锁\",{\"1\":{\"534\":1}}],[\"删除表的动作必须通过管理系统执行\",{\"1\":{\"487\":1}}],[\"删除临时文件可能需要等待io资源\",{\"1\":{\"481\":1}}],[\"删除旧的数据就是一个很好的例子\",{\"1\":{\"393\":1}}],[\"删除book表的索引\",{\"1\":{\"362\":1}}],[\"删除原索引\",{\"1\":{\"309\":1}}],[\"删除文档的格式\",{\"1\":{\"306\":1}}],[\"风险较高\",{\"1\":{\"438\":1}}],[\"导入注解\",{\"1\":{\"1138\":1}}],[\"导入configuration类\",{\"1\":{\"1131\":1}}],[\"导入configuration\",{\"1\":{\"1029\":1}}],[\"导入方就是外部\",{\"1\":{\"1020\":1}}],[\"导入依赖\",{\"1\":{\"583\":1}}],[\"导入jredis的包\",{\"1\":{\"582\":1}}],[\"导入相关依赖\",{\"1\":{\"582\":1}}],[\"导数据之前就会启动一个事务\",{\"1\":{\"438\":1}}],[\"导致iscandidatecomponent只会认为接口是备选者component\",{\"1\":{\"1653\":1}}],[\"导致key\",{\"1\":{\"1551\":1}}],[\"导致任务不断堆积到阻塞队列中\",{\"1\":{\"1536\":1}}],[\"导致生产者\",{\"1\":{\"1536\":1}}],[\"导致内存溢出\",{\"1\":{\"1519\":1}}],[\"导致内存泄漏的主要原因是在内部维护的map结构\",{\"1\":{\"1406\":1}}],[\"导致内存泄漏的原因是什么\",{\"0\":{\"77\":1,\"1406\":1}}],[\"导致\",{\"1\":{\"1479\":1}}],[\"导致无法继续执行\",{\"1\":{\"1389\":1}}],[\"导致put进去的值\",{\"1\":{\"1365\":1}}],[\"导致请求都被转发db\",{\"1\":{\"1284\":1}}],[\"导致在缓存在同一时刻全部失效\",{\"1\":{\"632\":1}}],[\"导致耗时较长\",{\"1\":{\"481\":1}}],[\"导致不能及时判断线程的状态\",{\"1\":{\"481\":1}}],[\"导致实例x的同步线程停止\",{\"1\":{\"468\":1}}],[\"导致主备延迟达到5秒\",{\"1\":{\"459\":1}}],[\"导致能集合到一起持久化的binlog比较少\",{\"1\":{\"451\":1}}],[\"导致打开表文件的个数超过了上限而报错\",{\"1\":{\"425\":1}}],[\"导致表t2会被扫描两次\",{\"1\":{\"403\":1}}],[\"导致了e指向了key\",{\"1\":{\"1551\":1}}],[\"导致了全索引扫描\",{\"1\":{\"366\":1}}],[\"导致了更长的执行时间\",{\"1\":{\"346\":1}}],[\"若发现前后相邻的synchronized块使用的是同一个锁对象\",{\"1\":{\"1393\":1}}],[\"若此时还未实例化\",{\"1\":{\"1191\":1}}],[\"若此时重新配置称为从机\",{\"1\":{\"611\":1}}],[\"若没找到即缓存未命中\",{\"1\":{\"626\":1}}],[\"若脚本执行后返回2\",{\"1\":{\"624\":1}}],[\"若脚本执行后返回1\",{\"1\":{\"624\":1}}],[\"若不是使用配置文件配置的从机\",{\"1\":{\"611\":1}}],[\"若row的trx\",{\"1\":{\"542\":2}}],[\"若隔离级别是\",{\"1\":{\"433\":4}}],[\"若union包含在from子句的子查询中\",{\"1\":{\"330\":1}}],[\"隔离级别会依赖于数据库\",{\"1\":{\"1655\":1}}],[\"隔离级别下直接用加锁的方式来避免并行访问\",{\"1\":{\"433\":1}}],[\"隔离级别下直接返回记录上的最新值\",{\"1\":{\"433\":1}}],[\"隔离级别下\",{\"1\":{\"433\":2}}],[\"隔离级别越高\",{\"1\":{\"433\":1}}],[\"隔离级别\",{\"1\":{\"433\":1,\"532\":1,\"1262\":1}}],[\"隔离性和隔离级别\",{\"0\":{\"433\":1}}],[\"隔离性\",{\"1\":{\"432\":1,\"1262\":1}}],[\"持有锁的线程唤醒被因调用condition\",{\"1\":{\"1493\":1}}],[\"持有锁的事务都可以访问数据\",{\"1\":{\"1263\":1}}],[\"持有的对象\",{\"1\":{\"1438\":1}}],[\"持久化aof\",{\"0\":{\"591\":1}}],[\"持久化功能有效避免因进程退出造成的数据丢失问题\",{\"1\":{\"584\":1}}],[\"持久化\",{\"1\":{\"565\":1,\"566\":1,\"592\":1,\"596\":2,\"909\":1}}],[\"持久化到磁盘的过程\",{\"1\":{\"451\":1}}],[\"持久化到磁盘\",{\"1\":{\"451\":1}}],[\"持久性\",{\"1\":{\"432\":1,\"1262\":1}}],[\"持续这个压力的话\",{\"1\":{\"497\":1}}],[\"持续叠加\",{\"1\":{\"491\":1}}],[\"持续观察\",{\"1\":{\"467\":1}}],[\"持续时间\",{\"1\":{\"431\":1}}],[\"持续集成\",{\"0\":{\"230\":1,\"1310\":1},\"1\":{\"1310\":1}}],[\"危险\",{\"1\":{\"431\":1}}],[\"诊断sql\",{\"1\":{\"431\":1}}],[\"运算的一块临时内存\",{\"1\":{\"1664\":1}}],[\"运维的难度提升了\",{\"1\":{\"1304\":1}}],[\"运维经理\",{\"1\":{\"430\":1}}],[\"运行效果如下\",{\"1\":{\"1613\":1}}],[\"运行程序就会在控制台打印\",{\"1\":{\"1613\":1}}],[\"运行程序\",{\"1\":{\"1610\":1}}],[\"运行的结果就变成了\",{\"1\":{\"1617\":1}}],[\"运行的结果\",{\"1\":{\"1609\":1,\"1613\":1}}],[\"运行状态\",{\"1\":{\"1477\":1}}],[\"运行刚才的例子不难看出\",{\"1\":{\"985\":1}}],[\"运行时栈帧结构\",{\"0\":{\"1799\":1}}],[\"运行时常量池\",{\"0\":{\"1707\":1}}],[\"运行时数据区域\",{\"0\":{\"1701\":1}}],[\"运行时数据区中包含哪些区域\",{\"0\":{\"97\":1,\"1428\":1}}],[\"运行时会封装成为interceptoranddynamicmethodmatcher\",{\"1\":{\"1654\":1}}],[\"运行时\",{\"1\":{\"1105\":1}}],[\"运行时报错\",{\"1\":{\"580\":1}}],[\"运行时异常\",{\"1\":{\"580\":1}}],[\"运行这条delete命令产生了一个warning\",{\"1\":{\"454\":1}}],[\"运行sql\",{\"1\":{\"431\":1}}],[\"观察有异常发生的情况\",{\"1\":{\"1619\":1}}],[\"观察结果\",{\"1\":{\"1617\":1}}],[\"观察不难发现\",{\"1\":{\"1598\":1}}],[\"观察者\",{\"1\":{\"1108\":1}}],[\"观察者模式扩展\",{\"1\":{\"1108\":1,\"1125\":1}}],[\"观察者模式\",{\"0\":{\"733\":1,\"848\":1},\"1\":{\"899\":1,\"1519\":1}}],[\"观察一段时间\",{\"1\":{\"487\":1}}],[\"观察\",{\"1\":{\"430\":1}}],[\"平衡执行效率和执行时长\",{\"1\":{\"1289\":1}}],[\"平均分配轮询策略\",{\"0\":{\"1894\":1}}],[\"平均分配策略\",{\"0\":{\"1893\":1}}],[\"平均值等等\",{\"1\":{\"1616\":1}}],[\"平均值\",{\"1\":{\"1615\":1}}],[\"平均值和最大值\",{\"1\":{\"479\":1}}],[\"平均工作时间\",{\"1\":{\"1510\":1}}],[\"平均查询时间\",{\"1\":{\"429\":1}}],[\"平均返回记录数\",{\"1\":{\"429\":1}}],[\"平均锁定时间\",{\"1\":{\"429\":1}}],[\"平时没有注意删除历史数据\",{\"1\":{\"457\":1}}],[\"平时不会出现\",{\"1\":{\"330\":1}}],[\"平时我们使用的都是索引\",{\"1\":{\"300\":1}}],[\"平时项目里面表结构是如何进行设计的\",{\"0\":{\"166\":1,\"1275\":1}}],[\"希望能收集超过5秒钟的sql\",{\"1\":{\"428\":1}}],[\"意识模式\",{\"1\":{\"900\":1}}],[\"意向拍他锁\",{\"1\":{\"533\":1}}],[\"意向共享锁\",{\"1\":{\"533\":1}}],[\"意向锁主要分为\",{\"1\":{\"533\":1}}],[\"意向锁\",{\"1\":{\"533\":1,\"1263\":1}}],[\"意思是运行10秒以上的语句\",{\"1\":{\"428\":1}}],[\"意味着中间结果容器的类型和最终返回的结果类型相同\",{\"1\":{\"1618\":1}}],[\"意味着对应的成本常数使用于所有的存储引擎\",{\"1\":{\"557\":1}}],[\"意味着对应的成本常数会采用默认值\",{\"1\":{\"557\":1}}],[\"意味着对于某条记录应用只需要查询一次\",{\"1\":{\"394\":1}}],[\"意味着记录已被删除\",{\"1\":{\"542\":1}}],[\"意味着少了两个binlog文件\",{\"1\":{\"485\":1}}],[\"意味着如果采用第一个策略\",{\"1\":{\"444\":1}}],[\"意味着如果只执行一个select语句\",{\"1\":{\"435\":1}}],[\"意味着访问磁盘数据的次数越小\",{\"1\":{\"347\":1}}],[\"效果跟drop普通表类似\",{\"1\":{\"426\":1}}],[\"效率上的考量等等\",{\"1\":{\"1620\":1}}],[\"效率并不高\",{\"1\":{\"1587\":1}}],[\"效率更高\",{\"1\":{\"1585\":2}}],[\"效率比较高\",{\"1\":{\"1419\":1}}],[\"效率比较低\",{\"1\":{\"1419\":1}}],[\"效率会很低\",{\"1\":{\"1363\":1}}],[\"效率高\",{\"1\":{\"1341\":1}}],[\"效率低\",{\"1\":{\"1341\":1}}],[\"效率相对较低\",{\"1\":{\"571\":1}}],[\"效率最高\",{\"1\":{\"571\":1,\"593\":1}}],[\"效率很高\",{\"1\":{\"396\":1,\"1587\":1}}],[\"效率不错\",{\"1\":{\"330\":1}}],[\"效率就会很高\",{\"1\":{\"319\":1}}],[\"必备技能\",{\"1\":{\"1966\":1}}],[\"必要\",{\"1\":{\"1498\":1}}],[\"必要时插入类型转换以保持类型安全\",{\"1\":{\"1098\":1}}],[\"必要的时候才使用有更新权限的账号\",{\"1\":{\"487\":1}}],[\"必要的分区\",{\"1\":{\"425\":1}}],[\"必须自己写代码去调用lucene的接口\",{\"1\":{\"1986\":1}}],[\"必须调用end方法\",{\"1\":{\"1623\":1}}],[\"必须在分割之后\",{\"1\":{\"1620\":1}}],[\"必须通过内核空间\",{\"1\":{\"1423\":1}}],[\"必须要保证其中一个不为空\",{\"1\":{\"1621\":1}}],[\"必须要保证cells数组只能被初始化一次\",{\"1\":{\"1480\":1}}],[\"必须要遵守下面的约定\",{\"1\":{\"1615\":1}}],[\"必须要联系他的上下文才能知道\",{\"1\":{\"1595\":1}}],[\"必须要设置之后才可以访问\",{\"1\":{\"1351\":1}}],[\"必须要等到无延迟才能查询的方案\",{\"1\":{\"472\":1}}],[\"必须处理重复回调\",{\"1\":{\"1248\":1}}],[\"必须保证操作只能执行一次\",{\"1\":{\"1248\":1}}],[\"必须保证要有定期全量备份的能力\",{\"1\":{\"457\":1}}],[\"必须绑定字段\",{\"1\":{\"1072\":1}}],[\"必须\",{\"1\":{\"963\":1}}],[\"必须是对于t类型的原生类型的特化\",{\"1\":{\"1620\":1}}],[\"必须是在程序运行期间才能决定\",{\"1\":{\"1340\":1}}],[\"必须是具体类\",{\"1\":{\"927\":1}}],[\"必须是全限定类名\",{\"1\":{\"927\":1}}],[\"必须是以下单位的其中一个\",{\"1\":{\"576\":1}}],[\"必须是一个可以被唤醒的等待\",{\"1\":{\"481\":1}}],[\"必须出现如下场景\",{\"1\":{\"496\":1}}],[\"必须等到一个事务执行完成并提交\",{\"1\":{\"491\":1}}],[\"必须先对表做改名操作\",{\"1\":{\"487\":1}}],[\"必须经过sql审计\",{\"1\":{\"484\":1}}],[\"必须这么设计\",{\"1\":{\"476\":1}}],[\"必须放到同一个worker中\",{\"1\":{\"460\":1}}],[\"必须被分发到同一个worker中\",{\"1\":{\"460\":1}}],[\"必须读取下一个数据页\",{\"1\":{\"342\":1}}],[\"必须为大写\",{\"1\":{\"306\":1}}],[\"必须全部是小写字母的\",{\"1\":{\"303\":1}}],[\"明显只需要访问一个分区\",{\"1\":{\"425\":1}}],[\"手把手教你写一个\",{\"1\":{\"1249\":1}}],[\"手动清理threadlocal\",{\"1\":{\"1528\":1}}],[\"手动提交offset\",{\"1\":{\"1328\":1}}],[\"手动事务\",{\"1\":{\"1328\":1}}],[\"手动模式\",{\"1\":{\"951\":1,\"953\":1,\"954\":1,\"955\":1,\"956\":1}}],[\"手动配置\",{\"1\":{\"918\":1}}],[\"手动到自动\",{\"1\":{\"623\":1}}],[\"手动\",{\"1\":{\"611\":2}}],[\"手动增加表锁\",{\"1\":{\"534\":1}}],[\"手工分表的逻辑\",{\"1\":{\"424\":1}}],[\"手机\",{\"1\":{\"363\":1}}],[\"拼出\",{\"1\":{\"422\":1}}],[\"清除算法\",{\"0\":{\"1720\":1}}],[\"清除过程中\",{\"1\":{\"1447\":1}}],[\"清除\",{\"1\":{\"1441\":1}}],[\"清除resourceloader缓存\",{\"1\":{\"1172\":1}}],[\"清空所有数据库的键值对\",{\"1\":{\"567\":1}}],[\"清空当前数据库中的键值对\",{\"1\":{\"567\":1}}],[\"清空join\",{\"1\":{\"403\":1}}],[\"清楚了order\",{\"1\":{\"422\":1}}],[\"随后aqs会调用重写的模板方法\",{\"1\":{\"1400\":1}}],[\"随着我们不断的对表进行增删改操作\",{\"1\":{\"559\":1}}],[\"随机选择要删除的键\",{\"1\":{\"1300\":1}}],[\"随机选其中一条记录来加\",{\"1\":{\"444\":1}}],[\"随机抽查这些key\",{\"1\":{\"1289\":1}}],[\"随机移除并返回2个成员\",{\"1\":{\"572\":1}}],[\"随机移除并返回集合中count个成员\",{\"1\":{\"572\":1}}],[\"随机返回1个成员\",{\"1\":{\"572\":1}}],[\"随机返回3个成员\",{\"1\":{\"572\":1}}],[\"随机返回集合中count个成员\",{\"1\":{\"572\":1}}],[\"随机排序法\",{\"0\":{\"422\":1}}],[\"随时可以提交事务\",{\"1\":{\"326\":1}}],[\"行为是调用的时候才动态的调用执行\",{\"1\":{\"1598\":1}}],[\"行为型模式\",{\"0\":{\"845\":1}}],[\"行\",{\"1\":{\"421\":1}}],[\"行锁等\",{\"1\":{\"1399\":1}}],[\"行锁分析\",{\"0\":{\"538\":1}}],[\"行锁可能会变表锁\",{\"1\":{\"537\":1}}],[\"行锁的之间的冲突关系是\",{\"1\":{\"448\":1}}],[\"行锁只能锁住行\",{\"1\":{\"448\":1}}],[\"行锁是在需要的时候才加上的\",{\"1\":{\"443\":1}}],[\"行锁顾名思义\",{\"1\":{\"442\":1}}],[\"行锁\",{\"0\":{\"442\":1,\"535\":1},\"1\":{\"388\":1,\"1263\":1}}],[\"小伙伴们根据喜好或者项目需要\",{\"1\":{\"1985\":1}}],[\"小伙伴们可以根据自己情况选择\",{\"1\":{\"1968\":1}}],[\"小顶堆\",{\"1\":{\"1506\":1}}],[\"小规模场景\",{\"1\":{\"1327\":1}}],[\"小\",{\"1\":{\"595\":1}}],[\"小刚的英语成绩\",{\"1\":{\"574\":1}}],[\"小刚的数学成绩\",{\"1\":{\"574\":1}}],[\"小红\",{\"1\":{\"574\":2}}],[\"小明\",{\"1\":{\"574\":2}}],[\"小结\",{\"1\":{\"571\":1}}],[\"小数值\",{\"1\":{\"528\":1}}],[\"小整数值\",{\"1\":{\"528\":1}}],[\"小于会返回负数\",{\"1\":{\"1603\":1}}],[\"小于的时候会创建新的线程进行处理\",{\"1\":{\"1410\":1}}],[\"小于低水位线\",{\"1\":{\"542\":1}}],[\"小于事务ta的低水位\",{\"1\":{\"497\":1}}],[\"小于r\",{\"1\":{\"421\":1}}],[\"小于word字段的长度定义\",{\"1\":{\"421\":1}}],[\"小表驱动大表\",{\"1\":{\"525\":2}}],[\"小表\",{\"1\":{\"403\":1}}],[\"完全是够用的\",{\"1\":{\"1613\":1}}],[\"完美地弥补了future上述的种种问题\",{\"1\":{\"1518\":1}}],[\"完美生效\",{\"1\":{\"583\":1}}],[\"完整链接\",{\"1\":{\"1265\":1}}],[\"完整的解析配置类流程图\",{\"1\":{\"1652\":1}}],[\"完整的哨兵模式配置文件\",{\"1\":{\"624\":1}}],[\"完整的演示过程如下\",{\"1\":{\"491\":1}}],[\"完整的执行序列如下\",{\"1\":{\"422\":1}}],[\"完整的排序的执行流程图如下\",{\"1\":{\"420\":1}}],[\"完成两个map的合并操作\",{\"1\":{\"1618\":1}}],[\"完成了1次dma拷贝\",{\"1\":{\"1580\":1}}],[\"完成第二次cpu切换\",{\"1\":{\"1580\":1}}],[\"完成第一次cpu切换\",{\"1\":{\"1580\":1}}],[\"完成的流程图\",{\"1\":{\"1494\":1}}],[\"完成对数据的加锁\",{\"1\":{\"1400\":1}}],[\"完成对象的创建\",{\"1\":{\"1237\":1}}],[\"完成逻辑判断并动态拼接sql的功能\",{\"1\":{\"1216\":1}}],[\"完成failover所需的时间就越长\",{\"1\":{\"624\":1}}],[\"完成后对原有文件进行原子替换\",{\"1\":{\"588\":1}}],[\"完成后自动结束\",{\"1\":{\"587\":1}}],[\"完成\",{\"1\":{\"513\":1}}],[\"完成比较\",{\"1\":{\"421\":1}}],[\"完成上述操作之后\",{\"1\":{\"345\":1}}],[\"访问标志\",{\"0\":{\"1778\":1}}],[\"访问结束再删除该短期key\",{\"1\":{\"630\":1}}],[\"访问方法为range\",{\"1\":{\"555\":1}}],[\"访问的时候以视图的逻辑结果为准\",{\"1\":{\"433\":1}}],[\"访问次数\",{\"1\":{\"429\":1}}],[\"访问了表的三行数据\",{\"1\":{\"420\":1}}],[\"访问类型\",{\"1\":{\"519\":1}}],[\"访问类型变成了一个全表扫描\",{\"1\":{\"390\":1}}],[\"访问类型有很多中\",{\"1\":{\"390\":1}}],[\"访问类型排列\",{\"1\":{\"330\":1}}],[\"磁盘临时表使用的引擎默认是innodb\",{\"1\":{\"421\":1}}],[\"磁盘临时表\",{\"0\":{\"421\":1}}],[\"磁盘临时表默认使用的引擎是innodb\",{\"1\":{\"416\":1}}],[\"磁盘文件名也不同\",{\"1\":{\"412\":1}}],[\"虚拟机\",{\"1\":{\"1992\":1}}],[\"虚拟机栈\",{\"0\":{\"1703\":1}}],[\"虚拟机采用cas分配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理\",{\"1\":{\"1668\":1}}],[\"虚拟机遇到一条new指令时\",{\"1\":{\"1666\":1}}],[\"虚拟机并不会立即升级为重量级锁\",{\"1\":{\"1485\":1}}],[\"虚拟机通过这个指针来确定这个对象是哪个类的实例\",{\"1\":{\"1484\":1}}],[\"虚拟机对compareandswapint\",{\"1\":{\"1479\":1}}],[\"虚拟机可以回收其占用的内存\",{\"1\":{\"1457\":1}}],[\"虚拟机统计信息监视工具\",{\"1\":{\"1454\":1}}],[\"虚拟机进程状况工具\",{\"1\":{\"1454\":1}}],[\"虚拟机基础故障处理工具有哪些\",{\"0\":{\"123\":1,\"1454\":1}}],[\"虚引用\",{\"1\":{\"1435\":1}}],[\"虚线箭头表示的是主备关系\",{\"1\":{\"466\":1}}],[\"虚线框内表示临时表的排序过程\",{\"1\":{\"416\":1}}],[\"发帖\",{\"1\":{\"1987\":1}}],[\"发布spring应用上下文已关闭事件\",{\"1\":{\"1175\":1}}],[\"发布spring应用上下文已停止事件\",{\"1\":{\"1174\":1}}],[\"发布spring应用上下文已启动事件\",{\"1\":{\"1173\":1}}],[\"发布spring应用上下文已刷新事件\",{\"1\":{\"1172\":1}}],[\"发布消息\",{\"1\":{\"598\":1}}],[\"发布消息到sakura频道\",{\"1\":{\"598\":1}}],[\"发布订阅\",{\"1\":{\"596\":1}}],[\"发布订阅系统\",{\"1\":{\"565\":1}}],[\"发送事务消息\",{\"0\":{\"1876\":1,\"1939\":1}}],[\"发送普通消息\",{\"0\":{\"1875\":1}}],[\"发送方不管接受方有没有准备好\",{\"1\":{\"1419\":1}}],[\"发送方法\",{\"1\":{\"1118\":1}}],[\"发送消息\",{\"0\":{\"1874\":1},\"1\":{\"596\":1,\"1521\":1}}],[\"发送者\",{\"1\":{\"596\":1}}],[\"发生concurrentmodificationexception可能性就会增加\",{\"1\":{\"1620\":1}}],[\"发生当前对象的epoch值和class的epoch不想等\",{\"1\":{\"1485\":1}}],[\"发生时机\",{\"1\":{\"1126\":2}}],[\"发生说明\",{\"1\":{\"1116\":1}}],[\"发生锁冲突的概率最低\",{\"1\":{\"535\":1}}],[\"发生锁冲突的概率最高\",{\"1\":{\"534\":1}}],[\"发生了数据不一致\",{\"1\":{\"447\":1}}],[\"发一个信号的目的\",{\"1\":{\"481\":1}}],[\"发回给主库一个ack\",{\"1\":{\"472\":1}}],[\"发起了主备切换\",{\"1\":{\"459\":1}}],[\"发起死锁检测\",{\"1\":{\"444\":1}}],[\"发给b\",{\"1\":{\"453\":1,\"468\":1}}],[\"发给客户端\",{\"1\":{\"414\":1}}],[\"发现是默认直\",{\"1\":{\"1286\":1}}],[\"发现并没有打印出我们预期的结果\",{\"1\":{\"1009\":1}}],[\"发现并没有使用name字段的索引\",{\"1\":{\"522\":1}}],[\"发现依然可以正常地工作\",{\"1\":{\"967\":1}}],[\"发现b和c的连接成本就已经大于10\",{\"1\":{\"556\":1}}],[\"发现该行记录已经有undo\",{\"1\":{\"542\":1}}],[\"发现执行时间太久\",{\"1\":{\"480\":1}}],[\"发现异常后\",{\"1\":{\"479\":1}}],[\"发现删错数据了\",{\"1\":{\"454\":1}}],[\"发现死锁后\",{\"1\":{\"444\":1}}],[\"发现内存临时表不够用了再转成磁盘临时表\",{\"1\":{\"418\":1}}],[\"发现不同线程可以创建同名的临时表\",{\"1\":{\"412\":1}}],[\"发现仍然是\",{\"1\":{\"350\":1}}],[\"发现已经不满足email=\",{\"1\":{\"350\":1}}],[\"备库和临时实例里面\",{\"1\":{\"492\":1}}],[\"备库各自的检测命令不会发生冲突\",{\"1\":{\"478\":1}}],[\"备库同步线程发生异常\",{\"1\":{\"473\":1}}],[\"备库从状态1到状态4都和主库a存在延迟\",{\"1\":{\"472\":1}}],[\"备库收到的日志都执行完成了\",{\"1\":{\"472\":1}}],[\"备库收到\",{\"1\":{\"472\":1}}],[\"备库指定哪个点位\",{\"1\":{\"468\":1}}],[\"备库上已经删除了临时实例需要的binlog的话\",{\"1\":{\"485\":1}}],[\"备库上的执行效果如下\",{\"1\":{\"464\":1}}],[\"备库上的查询耗费了大量的cpu资源\",{\"1\":{\"457\":1}}],[\"备库上也一定是可以并行执行的\",{\"1\":{\"464\":1}}],[\"备库上有一个查询\",{\"1\":{\"460\":1}}],[\"备库提供读能力\",{\"1\":{\"457\":1}}],[\"备库的检测也是要写bin\",{\"1\":{\"478\":1}}],[\"备库的压力大\",{\"1\":{\"457\":1}}],[\"备库的应用日志线程是共用的\",{\"1\":{\"413\":1}}],[\"备库随时可能变成主库\",{\"1\":{\"457\":1}}],[\"备库所在的机器的性能要比主库所在的机器性能差\",{\"1\":{\"457\":1}}],[\"备库消费中转日志\",{\"1\":{\"457\":1}}],[\"备库在执行seconds\",{\"1\":{\"457\":1}}],[\"备库在执行到insert\",{\"1\":{\"413\":1}}],[\"备库连接到主库的时候\",{\"1\":{\"457\":1}}],[\"备库取出当前正在执行的事务的时间字段的值\",{\"1\":{\"457\":1}}],[\"备库就能达到跟主库一致的状态\",{\"1\":{\"456\":1}}],[\"备库b要设置为新主库a\",{\"1\":{\"468\":1}}],[\"备库b的\",{\"1\":{\"459\":1}}],[\"备库b执行完成这个事务\",{\"1\":{\"457\":1}}],[\"备库b拿到binlog后\",{\"1\":{\"453\":1}}],[\"备库b和主库a之间维持了一个长连接\",{\"1\":{\"453\":1}}],[\"备库可以和主库保持同步更新\",{\"1\":{\"453\":1}}],[\"备库虽然设置了readonly\",{\"1\":{\"453\":1}}],[\"库可以自由的对输入元素分组与分区\",{\"1\":{\"1615\":1}}],[\"库迁移等操作的时候\",{\"1\":{\"469\":1}}],[\"库名\",{\"1\":{\"461\":1}}],[\"库名+t1+\",{\"1\":{\"413\":2}}],[\"库名+表名+索引名+值\",{\"1\":{\"465\":1}}],[\"库名+表名+索引a的名字+a的值\",{\"1\":{\"462\":1}}],[\"库名+表名+唯一键的值\",{\"1\":{\"462\":1}}],[\"库名+表名\",{\"1\":{\"412\":2}}],[\"库表结构优化需要多管齐下才能写出高效的sql\",{\"1\":{\"381\":1}}],[\"无状态的中间操作\",{\"1\":{\"1624\":1}}],[\"无状态表示这个实例没有属性对象\",{\"1\":{\"1236\":1}}],[\"无条件得循环遍历整个\",{\"1\":{\"1554\":1}}],[\"无条件选择删除\",{\"1\":{\"1271\":1}}],[\"无返回值\",{\"1\":{\"1518\":2}}],[\"无界队列\",{\"1\":{\"1503\":1}}],[\"无界队列意味着里面可以容纳非常多的元素\",{\"1\":{\"1501\":1}}],[\"无意识的使用锁\",{\"1\":{\"1485\":1}}],[\"无上限\",{\"1\":{\"1423\":2}}],[\"无锁设计\",{\"1\":{\"1519\":1}}],[\"无锁\",{\"1\":{\"1397\":1,\"1484\":1}}],[\"无同步方案\",{\"0\":{\"1818\":1},\"1\":{\"1392\":1}}],[\"无疑这是浪费性能的\",{\"1\":{\"1360\":1}}],[\"无序且唯一的字符串集合\",{\"1\":{\"1280\":1}}],[\"无parent的beandefinition或者合并后beandefinition\",{\"1\":{\"1018\":1}}],[\"无生命周期管理\",{\"1\":{\"976\":1,\"977\":1,\"978\":1}}],[\"无\",{\"1\":{\"974\":2,\"1039\":3}}],[\"无需cpu拷贝\",{\"1\":{\"1576\":1}}],[\"无需开发者关注\",{\"1\":{\"1394\":2}}],[\"无需开发者干预\",{\"1\":{\"1394\":1}}],[\"无需调用\",{\"1\":{\"1346\":1}}],[\"无需接口约束\",{\"1\":{\"1113\":1}}],[\"无需依赖特定的容器和api\",{\"1\":{\"915\":1}}],[\"无需改动外部数据结构和命令\",{\"1\":{\"569\":1}}],[\"无需担心表名重复导致建表失败的问题\",{\"1\":{\"410\":1}}],[\"无符号\",{\"1\":{\"528\":1}}],[\"无符号整型\",{\"1\":{\"493\":1}}],[\"无法访问子容器\",{\"1\":{\"1659\":1}}],[\"无法依赖注入\",{\"1\":{\"1648\":1}}],[\"无法分割\",{\"1\":{\"1620\":1}}],[\"无法组合多个任务\",{\"1\":{\"1516\":1}}],[\"无法对多个任务进行链式调用\",{\"1\":{\"1516\":1}}],[\"无法扩容\",{\"1\":{\"1509\":1}}],[\"无法动态调整\",{\"1\":{\"1457\":1}}],[\"无法释放已申请的内存空间\",{\"1\":{\"1451\":1}}],[\"无法自动进行gc\",{\"1\":{\"1406\":1}}],[\"无法自定义扩容机制\",{\"1\":{\"1358\":1}}],[\"无法get出\",{\"1\":{\"1365\":1}}],[\"无法修改\",{\"1\":{\"1353\":1}}],[\"无法控制代码块级别的事务管理\",{\"1\":{\"1238\":1}}],[\"无法直接实现同步\",{\"1\":{\"1123\":1}}],[\"无法获取到environmentaware对象的回调\",{\"1\":{\"1005\":1}}],[\"无法通过依赖查找\",{\"1\":{\"977\":1,\"978\":1}}],[\"无法延迟初始化bean\",{\"1\":{\"977\":1}}],[\"无法实现延迟初始化bean\",{\"1\":{\"976\":1,\"978\":1}}],[\"无法在beanfactory中查找\",{\"1\":{\"973\":1}}],[\"无法很好的利用索引\",{\"1\":{\"518\":1}}],[\"无法断开这个连接\",{\"1\":{\"480\":1}}],[\"无论使用哪种方式\",{\"1\":{\"1620\":1}}],[\"无论如何\",{\"1\":{\"1553\":1}}],[\"无论从微观还是宏观来看\",{\"1\":{\"1470\":1}}],[\"无论当前内存是否足够\",{\"1\":{\"1435\":1}}],[\"无论当前存不存在事务\",{\"1\":{\"1238\":1}}],[\"无论是http还是ajp\",{\"1\":{\"1687\":1}}],[\"无论是出于开发效率\",{\"1\":{\"1592\":1}}],[\"无论是传统的io方式\",{\"1\":{\"1585\":1}}],[\"无论是request还是session\",{\"1\":{\"987\":1}}],[\"无论是把mysqlbinlog工具解析出的binlog文件应用到临时库\",{\"1\":{\"485\":1}}],[\"无论是带宽还是延迟\",{\"1\":{\"392\":1}}],[\"无论怎样安排语句顺序\",{\"1\":{\"443\":1}}],[\"无论数据量大或小的group\",{\"1\":{\"418\":1}}],[\"奇怪\",{\"1\":{\"409\":1}}],[\"给类的静态变量分配内存\",{\"1\":{\"1663\":1}}],[\"给子类扩展\",{\"1\":{\"1651\":1}}],[\"给子进程\",{\"1\":{\"1527\":1}}],[\"给字段赋值\",{\"1\":{\"1648\":1}}],[\"给出了一个具体的案例\",{\"1\":{\"1618\":1}}],[\"给每个消息分配了messagesid\",{\"1\":{\"1329\":1}}],[\"给锁设置过期时长\",{\"1\":{\"1288\":1}}],[\"给缓存设置一个过期时间\",{\"1\":{\"1287\":1}}],[\"给db造成了很大的压力\",{\"1\":{\"1283\":1}}],[\"给引导类配置两大线程组\",{\"1\":{\"1226\":1}}],[\"给新线程分配thread\",{\"1\":{\"498\":1}}],[\"给row\",{\"1\":{\"495\":1}}],[\"给session\",{\"1\":{\"447\":1,\"481\":1}}],[\"给影院b的账户余额增加这张电影票价\",{\"1\":{\"443\":1}}],[\"给小表添加字段比较合理的方案是\",{\"1\":{\"441\":1}}],[\"给一个表加字段或者修改字段\",{\"1\":{\"441\":1}}],[\"给临时表tmp\",{\"1\":{\"407\":1}}],[\"给被驱动表的join字段加上索引\",{\"1\":{\"406\":1}}],[\"给id=2这一行的c字段加1\",{\"1\":{\"325\":1}}],[\"业务自己实现幂等\",{\"1\":{\"1333\":1}}],[\"业务代码中存在异常时\",{\"1\":{\"1239\":1}}],[\"业务代码抛出异常类型非runtimeexception\",{\"1\":{\"1239\":1}}],[\"业务代码逻辑又继续修改了其它数据\",{\"1\":{\"484\":1}}],[\"业务线程池\",{\"0\":{\"717\":1}}],[\"业务人员要继续在表t上执行两条插入语句的命令\",{\"1\":{\"459\":1}}],[\"业务开发人员要一次性地删掉大量历史数据\",{\"1\":{\"457\":1}}],[\"业务逻辑在节点a上更新了一条语句\",{\"1\":{\"455\":1}}],[\"业务逻辑出现异常怎么办\",{\"0\":{\"251\":1,\"1332\":1}}],[\"业务正常访问的数据页\",{\"1\":{\"406\":1}}],[\"算出set\",{\"1\":{\"468\":1}}],[\"算出来的值虽然有冲突的概率\",{\"1\":{\"352\":1}}],[\"算法是学习任何一门编程语言都绕不开的知识\",{\"1\":{\"1972\":1}}],[\"算法部分并不是要完全学完所有的题目才开始学下一个阶段\",{\"1\":{\"1972\":1}}],[\"算法训练营\",{\"1\":{\"1966\":1,\"1972\":2}}],[\"算法的要求并不算特别高\",{\"1\":{\"1970\":1}}],[\"算法的成熟以及硬件的发展\",{\"1\":{\"1527\":1}}],[\"算法的流程图如下\",{\"1\":{\"405\":1}}],[\"算法\",{\"0\":{\"1972\":1},\"1\":{\"405\":1,\"523\":2,\"1439\":1,\"1441\":1}}],[\"尤其是找\",{\"1\":{\"1983\":1}}],[\"尤其是在多读少写的场景下\",{\"1\":{\"607\":1}}],[\"尤其是在大表上的join操作\",{\"1\":{\"403\":1}}],[\"尤其是用户信息之类的\",{\"1\":{\"573\":1}}],[\"尤其是当等待次数很高\",{\"1\":{\"538\":1}}],[\"尤其是有insert\",{\"1\":{\"492\":1}}],[\"尤其是很容易出现内存不够用和cpu瓶颈的问题\",{\"1\":{\"411\":1}}],[\"尤其是向底层存储引擎检索数据的调用操作\",{\"1\":{\"381\":1}}],[\"能在服务端具有统治地位的重要原因之一\",{\"1\":{\"1982\":1}}],[\"能避免线程频繁创建\",{\"1\":{\"1534\":1}}],[\"能否扩容\",{\"1\":{\"1509\":1}}],[\"能保留在内存之中\",{\"1\":{\"1435\":1}}],[\"能力由beanfactory输出\",{\"1\":{\"948\":1}}],[\"能被多次调用\",{\"1\":{\"624\":1}}],[\"能写多少取决于内核为套接字分配的写缓冲区的空闲空间字节数\",{\"1\":{\"602\":1}}],[\"能写多少写多少\",{\"1\":{\"602\":1}}],[\"能读多少取决于内核为套接字分配的读缓冲区内部的数据字节数\",{\"1\":{\"602\":1}}],[\"能不能使用join语句\",{\"1\":{\"403\":1}}],[\"能够实现服务的远程调用\",{\"1\":{\"1990\":1}}],[\"能够优化汇聚操作\",{\"1\":{\"1615\":1}}],[\"能够通知程序进行相应的读写操作\",{\"1\":{\"1568\":1}}],[\"能够把它保存的记录根据键排序\",{\"1\":{\"1544\":1}}],[\"能够让批量异步任务的管理更简单\",{\"1\":{\"1517\":1}}],[\"能够再次获取读锁\",{\"1\":{\"1498\":1}}],[\"能够正确地处理多个线程之间的共享变量\",{\"1\":{\"1376\":1}}],[\"能够达到一致性即可\",{\"1\":{\"1333\":1}}],[\"能够达到近实时搜索\",{\"1\":{\"301\":1}}],[\"能够解决数据库数据文件过大的问题\",{\"1\":{\"1270\":1}}],[\"能够很好的同时支持等值查询和范围查询\",{\"1\":{\"1265\":1}}],[\"能够单独或批量存储java\",{\"1\":{\"1074\":1}}],[\"能够快速启动\",{\"1\":{\"910\":1}}],[\"能够在同一个组里提交的事务\",{\"1\":{\"464\":1}}],[\"能够提升读性能\",{\"1\":{\"404\":1}}],[\"能够十分有效的加快我们的查询效率\",{\"1\":{\"365\":1}}],[\"λ∈\",{\"1\":{\"403\":1}}],[\"继续往下\",{\"1\":{\"1623\":1}}],[\"继续往下看\",{\"1\":{\"1594\":1}}],[\"继续接受其他客户端的连接请求\",{\"1\":{\"1575\":1}}],[\"继续标记其他对象\",{\"1\":{\"1447\":1}}],[\"继续执行的其它事务就会申请到id=3\",{\"1\":{\"491\":1}}],[\"继续执行插入数据的操作\",{\"1\":{\"491\":1}}],[\"继续执行第二步\",{\"1\":{\"403\":1}}],[\"继续分配transaction\",{\"1\":{\"468\":1}}],[\"继续分配事务\",{\"1\":{\"461\":1}}],[\"继续下一步\",{\"1\":{\"458\":1}}],[\"继续扫描表t1\",{\"1\":{\"403\":1}}],[\"继续第2步\",{\"1\":{\"403\":1}}],[\"继承propertyeditorsupport\",{\"1\":{\"1638\":1}}],[\"继承了abstractautowirecapablebeanfactory\",{\"1\":{\"1636\":1}}],[\"继承了abstractbeanfactory\",{\"1\":{\"1636\":1}}],[\"继承了listablebeanfactory\",{\"1\":{\"1636\":1}}],[\"继承了factorybeanregistrysupport\",{\"1\":{\"1636\":1}}],[\"继承thread类\",{\"1\":{\"1377\":1}}],[\"继承是使用已经存在的类的定义作为基础建立新的类\",{\"1\":{\"1340\":1}}],[\"继承该值\",{\"1\":{\"1020\":3}}],[\"继承\",{\"0\":{\"11\":1,\"1340\":1},\"1\":{\"1136\":1,\"1340\":1}}],[\"调整es的一些重要参数\",{\"1\":{\"1257\":1}}],[\"调整environment中的propertysource\",{\"1\":{\"1156\":1}}],[\"调整ignoreinvalidfields\",{\"1\":{\"1072\":1}}],[\"调整ignoreunknownfields\",{\"1\":{\"1072\":1}}],[\"调整自动增加嵌套路径true\",{\"1\":{\"1072\":1}}],[\"调节成本常数\",{\"0\":{\"557\":1}}],[\"调换m和n的位置\",{\"1\":{\"403\":1}}],[\"调用处理程序之前调用\",{\"1\":{\"1657\":1}}],[\"调用了getsqlsession\",{\"1\":{\"1653\":1}}],[\"调用了另一个重载的groupingby方法\",{\"1\":{\"1618\":1}}],[\"调用getbean\",{\"1\":{\"1648\":1}}],[\"调用getbean方法才会调用factorybean\",{\"1\":{\"1647\":1}}],[\"调用getobject\",{\"1\":{\"1181\":1}}],[\"调用完end方法之后\",{\"1\":{\"1623\":1}}],[\"调用的api分别是\",{\"1\":{\"1613\":1}}],[\"调用的结果\",{\"1\":{\"931\":1,\"933\":1}}],[\"调用终止操作\",{\"1\":{\"1593\":1}}],[\"调用servlet容器\",{\"1\":{\"1687\":1}}],[\"调用select函数会阻塞\",{\"1\":{\"1569\":1}}],[\"调用signal唤醒的时候会把条件队列中的线程节点移动到同步队列中\",{\"1\":{\"1490\":1}}],[\"调用方式\",{\"1\":{\"1553\":1}}],[\"调用map\",{\"1\":{\"1551\":1}}],[\"调用condition\",{\"1\":{\"1493\":2}}],[\"调用await方法进行阻塞\",{\"1\":{\"1492\":1}}],[\"调用await方法阻塞线程\",{\"1\":{\"1492\":1}}],[\"调用await\",{\"1\":{\"1490\":1}}],[\"调用自己\",{\"1\":{\"1456\":2}}],[\"调用wait\",{\"1\":{\"1483\":1}}],[\"调用wait方法之前\",{\"1\":{\"1381\":1}}],[\"调用write写入到文件系统的page\",{\"1\":{\"451\":1}}],[\"调用beanpostprocess的初始化前的方法\",{\"1\":{\"1234\":1}}],[\"调用beanfactorypostprocessor或beandefinitionpostprocessorregistry后置处理方法\",{\"1\":{\"1165\":1}}],[\"调用preparedstatement的set方法来赋值\",{\"1\":{\"1210\":1}}],[\"调用lifecycleprocessor\",{\"1\":{\"1172\":1}}],[\"调用referencepipeline中的foreach方法\",{\"1\":{\"1622\":1}}],[\"调用read操作进行异步读取操作\",{\"1\":{\"1575\":1}}],[\"调用reject或者rejectvalue\",{\"1\":{\"1063\":1}}],[\"调用reject方法或rejectvalue方法\",{\"1\":{\"1063\":1}}],[\"调用rand\",{\"1\":{\"420\":1}}],[\"调用上述方法的地方\",{\"1\":{\"964\":1}}],[\"调用该脚本时\",{\"1\":{\"624\":1}}],[\"调用fsync持久化\",{\"1\":{\"451\":1}}],[\"调用引擎接口取\",{\"1\":{\"322\":1}}],[\"调用innodb引擎接口取这个表的第一行\",{\"1\":{\"322\":1}}],[\"速度快\",{\"1\":{\"1477\":1}}],[\"速度\",{\"1\":{\"1439\":1}}],[\"速度最快\",{\"1\":{\"592\":1}}],[\"速度会快上很多\",{\"1\":{\"403\":1}}],[\"速度从慢到快\",{\"1\":{\"390\":1}}],[\"满足stream的特性\",{\"1\":{\"1619\":1}}],[\"满足匹配的条件的这行数据\",{\"1\":{\"408\":1}}],[\"满足join条件的\",{\"1\":{\"403\":2}}],[\"满足条件的下一行\",{\"1\":{\"322\":1}}],[\"跟我学springboot\",{\"1\":{\"1966\":1}}],[\"跟通信无关\",{\"1\":{\"1309\":1}}],[\"跟存储无关\",{\"1\":{\"1309\":1}}],[\"跟之前获得的时间戳是不一致的\",{\"1\":{\"1288\":1}}],[\"跟这种情况相同的\",{\"1\":{\"481\":1}}],[\"跟所有worker的冲突关系包含以下三种情况\",{\"1\":{\"461\":1}}],[\"跟第四行的commit对应\",{\"1\":{\"454\":1}}],[\"跟间隙锁存在冲突关系的\",{\"1\":{\"448\":1}}],[\"跟当前堆里面最大地r比较\",{\"1\":{\"421\":1}}],[\"跟join\",{\"1\":{\"403\":2}}],[\"跟r组成一行\",{\"1\":{\"401\":1}}],[\"记忆集与卡表\",{\"0\":{\"1761\":1}}],[\"记为线程t\",{\"1\":{\"1498\":1}}],[\"记为gtid1\",{\"1\":{\"474\":1}}],[\"记为c\",{\"1\":{\"422\":1}}],[\"记为字段w\",{\"1\":{\"420\":1}}],[\"记为字段r\",{\"1\":{\"420\":1}}],[\"记为m\",{\"1\":{\"418\":1}}],[\"记为x\",{\"1\":{\"416\":1}}],[\"记为log2m\",{\"1\":{\"401\":1}}],[\"记录resolvabledependency\",{\"1\":{\"1651\":1}}],[\"记录ignoredependencyinterface\",{\"1\":{\"1651\":1}}],[\"记录链表节点得个数\",{\"1\":{\"1554\":1}}],[\"记录锁\",{\"1\":{\"1263\":1}}],[\"记录条数少的时候可以做到精确计算\",{\"1\":{\"553\":1}}],[\"记录被更新或删除并不代表真的删除\",{\"1\":{\"542\":1}}],[\"记录创建这条记录\",{\"1\":{\"542\":1}}],[\"记录的主键id\",{\"1\":{\"520\":1}}],[\"记录的binlog还是statement格式\",{\"1\":{\"485\":1}}],[\"记录的是这个语句的原始逻辑\",{\"1\":{\"325\":1}}],[\"记录的是\",{\"1\":{\"325\":1}}],[\"记录binlog的时候\",{\"1\":{\"468\":1}}],[\"记录到binlog里的是语句原文\",{\"1\":{\"454\":1}}],[\"记录一条交易日志\",{\"1\":{\"443\":1}}],[\"记录上最新的值\",{\"1\":{\"434\":1}}],[\"记录太少的表\",{\"1\":{\"359\":1}}],[\"记录下来\",{\"1\":{\"1620\":1}}],[\"记录下\",{\"1\":{\"345\":1}}],[\"记录单词的开始结束位置\",{\"1\":{\"308\":1}}],[\"记录单词到倒排所列的关联关系\",{\"1\":{\"308\":1}}],[\"记录了单词对应的文档结合\",{\"1\":{\"308\":1}}],[\"记录所有文档的单词\",{\"1\":{\"308\":1}}],[\"走的是树搜索过程\",{\"1\":{\"401\":1}}],[\"去\",{\"1\":{\"1658\":1}}],[\"去得到一个sqlsession对象\",{\"1\":{\"1653\":1}}],[\"去掉集合中重复的元素\",{\"1\":{\"1617\":1}}],[\"去掉没有参数的构造方法\",{\"1\":{\"1600\":1}}],[\"去除不可能存在共享资源竞争的锁\",{\"1\":{\"1487\":1}}],[\"去查看商品的时候\",{\"1\":{\"471\":1}}],[\"去临时表里面拿到word字段\",{\"1\":{\"421\":1}}],[\"去重\",{\"1\":{\"414\":1}}],[\"去表t2查找满足条件的记录\",{\"1\":{\"401\":1}}],[\"去使用这个引擎提供的接口\",{\"1\":{\"322\":1}}],[\"往beanfactory工厂中添加如下对象\",{\"1\":{\"1651\":1}}],[\"往往需要写很多jdbc代码\",{\"1\":{\"1982\":1}}],[\"往往需要架构支持\",{\"1\":{\"1310\":1}}],[\"往往并不是独立的\",{\"1\":{\"1518\":1}}],[\"往往启动就会成为一个很大的难关\",{\"1\":{\"1304\":1}}],[\"往往是非常困难的\",{\"1\":{\"1304\":1}}],[\"往往就会有根据时间删除历史数据的需求\",{\"1\":{\"426\":1}}],[\"往t2表插入100行记录\",{\"1\":{\"523\":1}}],[\"往t1表插入1万行记录\",{\"1\":{\"523\":1}}],[\"往后读文件\",{\"1\":{\"468\":1}}],[\"往这个间隙中插入一个记录\",{\"1\":{\"448\":1}}],[\"往磁盘上搬了\",{\"1\":{\"431\":1}}],[\"往表t2里面插入了1000行数据\",{\"1\":{\"400\":1}}],[\"往中间插入一条记录就必须得往后挪动所有的记录\",{\"1\":{\"333\":1}}],[\"≈\",{\"1\":{\"399\":1,\"553\":2}}],[\"快照\",{\"1\":{\"596\":1}}],[\"快照功能\",{\"1\":{\"592\":1}}],[\"快照读生成read\",{\"1\":{\"542\":1}}],[\"快照读读到的并不一定是数据的最新版本\",{\"1\":{\"541\":1}}],[\"快照读的实现是基于多版本并发控制\",{\"1\":{\"541\":1}}],[\"快照读的前提是隔离级别不是串行级别\",{\"1\":{\"541\":1}}],[\"快照读\",{\"1\":{\"541\":1}}],[\"快\",{\"1\":{\"399\":1,\"595\":1}}],[\"快速失败\",{\"1\":{\"1620\":1}}],[\"快速上限估计\",{\"1\":{\"388\":2}}],[\"快速定位到t\",{\"1\":{\"366\":1}}],[\"快速\",{\"1\":{\"301\":1}}],[\"进阶优化\",{\"0\":{\"1992\":1}}],[\"进程间通信方式\",{\"1\":{\"1477\":1}}],[\"进程是操作系统进行资源分配的最小单位\",{\"1\":{\"1377\":1}}],[\"进程是程序运行时的状态\",{\"1\":{\"1374\":1}}],[\"进程的主要作用是管理资源\",{\"1\":{\"1374\":1}}],[\"进程发送信号给父进程表示完成\",{\"1\":{\"588\":1}}],[\"进程id\",{\"1\":{\"412\":1}}],[\"进而加快资源拷贝效率\",{\"1\":{\"1581\":1}}],[\"进而使得后面get的时候\",{\"1\":{\"1551\":1}}],[\"进而因为竞争导致性能下降\",{\"1\":{\"1519\":1}}],[\"进而通过调用future接口实现类的get方法获取最终的结果\",{\"1\":{\"1517\":1}}],[\"进而导致继续插入数据时报主键冲突的错误\",{\"1\":{\"499\":1}}],[\"进而导致所有从库的数据表也都一起被误删了\",{\"1\":{\"486\":1}}],[\"进而也就解决了过期读的问题\",{\"1\":{\"471\":1}}],[\"进入终止逻辑\",{\"1\":{\"481\":1}}],[\"进入等待状态\",{\"1\":{\"476\":1}}],[\"进入锁等待的线程已经不吃cpu了\",{\"1\":{\"476\":1}}],[\"进入old区域的数据页\",{\"1\":{\"406\":1}}],[\"进去\",{\"1\":{\"399\":1}}],[\"进行加法\",{\"1\":{\"1664\":1}}],[\"进行累积操作的集合中的元素\",{\"1\":{\"1617\":1}}],[\"进行二次排序\",{\"1\":{\"1614\":1}}],[\"进行addcount\",{\"1\":{\"1554\":1}}],[\"进行初始化\",{\"1\":{\"1554\":1}}],[\"进行扩容\",{\"1\":{\"1549\":1}}],[\"进行线程休眠\",{\"1\":{\"1520\":1}}],[\"进行下一步操作\",{\"1\":{\"1518\":1}}],[\"进行删除\",{\"1\":{\"1287\":1}}],[\"进行过滤处理\",{\"1\":{\"1116\":1}}],[\"进行观察\",{\"1\":{\"1005\":1}}],[\"进行逻辑分组\",{\"1\":{\"961\":2}}],[\"进行持久化的时候\",{\"1\":{\"588\":1}}],[\"进行位元操作\",{\"1\":{\"578\":1}}],[\"进行\",{\"1\":{\"532\":1}}],[\"进行mysql数据库服务器的参数调优\",{\"1\":{\"430\":1}}],[\"进行对比学习\",{\"1\":{\"378\":1}}],[\"进行转换的\",{\"1\":{\"368\":1}}],[\"进行了全表扫描\",{\"1\":{\"368\":1}}],[\"进行更新\",{\"1\":{\"306\":1}}],[\"放置在\",{\"1\":{\"1693\":1}}],[\"放开thread1的断点至transfer方法的entry\",{\"1\":{\"1551\":1}}],[\"放弃本次通信\",{\"1\":{\"1420\":1}}],[\"放弃事务\",{\"1\":{\"579\":1,\"582\":1}}],[\"放弃了树搜索功能\",{\"1\":{\"366\":1}}],[\"放到bean工厂当中\",{\"1\":{\"1651\":1}}],[\"放到备库的日志目录下\",{\"1\":{\"485\":1}}],[\"放到mysql去执行\",{\"1\":{\"454\":1}}],[\"放入到join\",{\"1\":{\"405\":1}}],[\"放完第88行join\",{\"1\":{\"403\":1}}],[\"放一个数字\",{\"1\":{\"399\":1}}],[\"累加个各个线程自己的槽cell\",{\"1\":{\"1480\":1}}],[\"累计值就加1\",{\"1\":{\"399\":1}}],[\"累积计数\",{\"1\":{\"396\":1}}],[\"更为通用的写法\",{\"1\":{\"1609\":1}}],[\"更为重要的是\",{\"1\":{\"1518\":1}}],[\"更为推荐的方式\",{\"1\":{\"985\":1}}],[\"更加高效\",{\"1\":{\"1457\":1,\"1607\":1}}],[\"更加灵活\",{\"1\":{\"1457\":1,\"1495\":1}}],[\"更加健壮\",{\"1\":{\"623\":1}}],[\"更容易组合专门的团队\",{\"1\":{\"1304\":1}}],[\"更容易做到高性能和可扩展\",{\"1\":{\"394\":1}}],[\"更合理的sharding布局\",{\"1\":{\"1257\":1}}],[\"更具有场景化的命名方法\",{\"1\":{\"928\":1}}],[\"更符合java的命名约定\",{\"1\":{\"928\":1}}],[\"更好的面向对象\",{\"1\":{\"916\":1}}],[\"更多的情况是\",{\"1\":{\"1605\":1}}],[\"更多的情况下\",{\"1\":{\"1593\":1}}],[\"更多内容参考\",{\"1\":{\"1238\":1}}],[\"更多内容可以参考\",{\"1\":{\"1208\":1,\"1248\":1}}],[\"更多时候\",{\"1\":{\"619\":1}}],[\"更多命令学习\",{\"1\":{\"569\":1}}],[\"更像是一个裹足前行的人\",{\"1\":{\"1607\":1}}],[\"更像nio模式\",{\"1\":{\"583\":1}}],[\"更像bio模式\",{\"1\":{\"583\":1}}],[\"更重要的是做到事前预防\",{\"1\":{\"484\":1}}],[\"更重要的是\",{\"1\":{\"476\":1}}],[\"更省内存\",{\"1\":{\"465\":1}}],[\"更进一步\",{\"1\":{\"394\":1}}],[\"更新已存在的key\",{\"1\":{\"1553\":1}}],[\"更新数据时判断状态\",{\"1\":{\"1248\":1}}],[\"更新innodb\",{\"1\":{\"559\":1}}],[\"更新统计数据\",{\"0\":{\"559\":1}}],[\"更新内存的数据的性能是很高的\",{\"1\":{\"543\":1}}],[\"更新丢失或脏写\",{\"1\":{\"532\":1}}],[\"更新判断是一个相对比较常用的方案\",{\"1\":{\"478\":1}}],[\"更新判断\",{\"0\":{\"478\":1}}],[\"更新事务要写入binlog\",{\"1\":{\"477\":1}}],[\"更新同一行的事务\",{\"1\":{\"460\":1}}],[\"更新了一半的结果\",{\"1\":{\"460\":1}}],[\"更新请求对iops的压力\",{\"1\":{\"457\":1}}],[\"更新过程中也会触发大量的读操作\",{\"1\":{\"457\":1}}],[\"更新过程\",{\"0\":{\"343\":1}}],[\"更新的时间复杂度也是o\",{\"1\":{\"334\":1}}],[\"更新的作用\",{\"1\":{\"306\":1}}],[\"更新完成\",{\"1\":{\"326\":1}}],[\"更新语句执行流程\",{\"0\":{\"326\":1}}],[\"更新流程还设计两个重要的的日志模块\",{\"1\":{\"323\":1}}],[\"更新只会对相应字段做增量修改\",{\"1\":{\"306\":1}}],[\"更新\",{\"1\":{\"306\":1,\"1554\":1}}],[\"更新和删除操作的时候\",{\"1\":{\"303\":1}}],[\"阻塞io的特点就是在io执行的两个阶段都被block了\",{\"1\":{\"1563\":1}}],[\"阻塞io模型\",{\"0\":{\"1563\":1}}],[\"阻塞io\",{\"1\":{\"1561\":1,\"1567\":1}}],[\"阻塞唤醒机制机制底层原理\",{\"1\":{\"1530\":1}}],[\"阻塞生产者线程\",{\"1\":{\"1503\":1}}],[\"阻塞特定时间\",{\"1\":{\"1501\":1}}],[\"阻塞等待队列\",{\"1\":{\"1490\":1}}],[\"阻塞式的解决方案\",{\"1\":{\"1482\":1}}],[\"阻塞1s\",{\"1\":{\"1479\":1}}],[\"阻塞和非阻塞针对客户端\",{\"1\":{\"1421\":1}}],[\"阻塞队列无法继续处理\",{\"1\":{\"1573\":1}}],[\"阻塞队列已满\",{\"1\":{\"1502\":1}}],[\"阻塞队列出了阻塞外还有一个非常重要的属性\",{\"1\":{\"1501\":1}}],[\"阻塞队列的总结\",{\"1\":{\"1499\":1}}],[\"阻塞队列的实现原理是什么\",{\"0\":{\"66\":1,\"1395\":1}}],[\"阻塞队列\",{\"1\":{\"1476\":1}}],[\"阻塞队列一览\",{\"1\":{\"1395\":1}}],[\"阻塞队列是一个支持两个附加操作的队列\",{\"1\":{\"1395\":1}}],[\"阻塞客户端命令\",{\"1\":{\"589\":1}}],[\"阻塞发生在fock\",{\"1\":{\"589\":1}}],[\"阻塞\",{\"0\":{\"1567\":1},\"1\":{\"589\":1,\"1421\":2,\"1501\":2,\"1567\":1}}],[\"阻塞只发生在fork阶段\",{\"1\":{\"587\":1}}],[\"阻塞当前redis服务器\",{\"1\":{\"587\":1}}],[\"阻塞被解决\",{\"1\":{\"571\":1}}],[\"阻塞很多小的但重要的查询\",{\"1\":{\"393\":1}}],[\"占整个堆内存的1\",{\"1\":{\"1664\":1}}],[\"占位符的填充\",{\"1\":{\"1648\":1}}],[\"占有1g内存\",{\"1\":{\"1527\":1}}],[\"占据4字节\",{\"1\":{\"1484\":1}}],[\"占了3条记录\",{\"1\":{\"558\":1}}],[\"占满整个事务日志\",{\"1\":{\"393\":1}}],[\"占用的系统资源比较少\",{\"1\":{\"1419\":1}}],[\"占用的系统资源比较多\",{\"1\":{\"1419\":1}}],[\"占用的磁盘空间就越大\",{\"1\":{\"352\":1}}],[\"占用几十个字节的空间\",{\"1\":{\"454\":1}}],[\"占用磁盘io资源\",{\"1\":{\"406\":1}}],[\"占用8个字节\",{\"1\":{\"330\":1}}],[\"改怎么办呢\",{\"1\":{\"1610\":1}}],[\"改变状态\",{\"1\":{\"1531\":1}}],[\"改变库表结构\",{\"1\":{\"390\":1}}],[\"改良的方式就是jwt令牌\",{\"1\":{\"1203\":1}}],[\"改名为\",{\"1\":{\"569\":1}}],[\"改为tom\",{\"1\":{\"542\":1}}],[\"改表名的时候\",{\"1\":{\"487\":1}}],[\"改成了5\",{\"1\":{\"447\":1}}],[\"改成\",{\"1\":{\"348\":1,\"447\":2}}],[\"换句话说\",{\"1\":{\"530\":1,\"1526\":1,\"1594\":1,\"1595\":1,\"1622\":1}}],[\"换句话说查询列要被所使用的索引覆盖\",{\"1\":{\"330\":1}}],[\"换成异步请求\",{\"1\":{\"1421\":1}}],[\"换成\",{\"1\":{\"421\":1}}],[\"换言之\",{\"1\":{\"390\":1,\"591\":1,\"1594\":1,\"1600\":1,\"1603\":1,\"1617\":1}}],[\"常量池\",{\"0\":{\"1777\":1}}],[\"常量等\",{\"1\":{\"1457\":1}}],[\"常常为了提高应用程序的并发性\",{\"1\":{\"1530\":1}}],[\"常用工具\",{\"1\":{\"1966\":1}}],[\"常用框架\",{\"1\":{\"1966\":1}}],[\"常用方法总结\",{\"1\":{\"1518\":1}}],[\"常用于记录用户行为\",{\"1\":{\"1280\":1}}],[\"常规类作为方法返回值\",{\"1\":{\"1100\":1}}],[\"常规类型不具备泛型参数类型list<e>\",{\"1\":{\"1100\":1}}],[\"常规类型\",{\"1\":{\"959\":1,\"960\":1}}],[\"常规校验\",{\"1\":{\"1060\":1}}],[\"常规方式实例化的示例\",{\"1\":{\"930\":1}}],[\"常规方式\",{\"1\":{\"930\":1}}],[\"常数\",{\"1\":{\"555\":2}}],[\"常数引用等\",{\"1\":{\"390\":1}}],[\"常在河边走\",{\"1\":{\"483\":1}}],[\"常见连接池包括\",{\"1\":{\"1974\":1}}],[\"常见且默认的等待测了\",{\"1\":{\"1520\":1}}],[\"常见实现\",{\"1\":{\"1071\":1}}],[\"常见编解码器总结\",{\"0\":{\"729\":1}}],[\"常见sql优化\",{\"0\":{\"520\":1}}],[\"常见索引的数据结构\",{\"1\":{\"501\":1}}],[\"常见的函数式接口\",{\"0\":{\"1596\":1}}],[\"常见的阻塞队列\",{\"1\":{\"1501\":1}}],[\"常见的分片策略有\",{\"1\":{\"1270\":1}}],[\"常见的锁算法\",{\"1\":{\"1263\":1}}],[\"常见的方案\",{\"1\":{\"1248\":1}}],[\"常见的导致自增主键的原因有\",{\"1\":{\"491\":1}}],[\"常见的做法是放一个timestamp字段\",{\"1\":{\"478\":1}}],[\"常见于排序order\",{\"1\":{\"330\":1}}],[\"服务的治理\",{\"1\":{\"1990\":1}}],[\"服务路由\",{\"1\":{\"1989\":1}}],[\"服务网关\",{\"1\":{\"1989\":1}}],[\"服务提供者接口\",{\"1\":{\"1658\":1}}],[\"服务端需要做两件事\",{\"1\":{\"1580\":1}}],[\"服务端\",{\"1\":{\"1573\":1,\"1574\":1,\"1575\":1}}],[\"服务端为每个客户端请求创建一个独立的线程\",{\"1\":{\"1533\":1}}],[\"服务之间解耦\",{\"1\":{\"1326\":1}}],[\"服务调用的复杂性提高了\",{\"1\":{\"1304\":1}}],[\"服务部署更灵活\",{\"1\":{\"1304\":1}}],[\"服务模式注解\",{\"1\":{\"1023\":1,\"1131\":1}}],[\"服务模型\",{\"0\":{\"679\":1}}],[\"服务定位模式\",{\"1\":{\"906\":1}}],[\"服务引入\",{\"0\":{\"641\":1}}],[\"服务导出\",{\"0\":{\"640\":1}}],[\"服务导出与服务引入的流程图\",{\"1\":{\"639\":1}}],[\"服务器中间件\",{\"0\":{\"1984\":1}}],[\"服务器进程都维持着一个表示服务器状态的\",{\"1\":{\"599\":1}}],[\"服务器必须要扫描多行才能生成结果集中的一行\",{\"1\":{\"389\":1}}],[\"服务恢复需要的时间就越短\",{\"1\":{\"459\":1}}],[\"服务时间是指数据库处理这个查询真正花了多长时间\",{\"1\":{\"388\":1}}],[\"服务时间和排队时间\",{\"1\":{\"388\":1}}],[\"理论上\",{\"1\":{\"1474\":1}}],[\"理论上可以创建不同的db\",{\"1\":{\"463\":1}}],[\"理解每个泛型代表的含义以及每个参数的作用\",{\"1\":{\"1618\":1}}],[\"理解了三个参数具体的作用我们具体再往下看\",{\"1\":{\"1608\":1}}],[\"理解了函数式接口\",{\"1\":{\"1593\":1}}],[\"理解了change\",{\"1\":{\"343\":1}}],[\"理解条件配置spring\",{\"0\":{\"1147\":1}}],[\"理解事务传播\",{\"0\":{\"861\":1}}],[\"理解platformtransactionmanager\",{\"0\":{\"860\":1}}],[\"理解transactiondefinition\",{\"0\":{\"859\":1}}],[\"理由如下\",{\"1\":{\"410\":1,\"1342\":1}}],[\"理想情况下\",{\"1\":{\"389\":1,\"1620\":1}}],[\"较短的性的访问速度更快\",{\"1\":{\"389\":1}}],[\"糟糕\",{\"1\":{\"389\":1}}],[\"法概括地说\",{\"1\":{\"388\":1}}],[\"法来估算这个时间是否是一个合理的值\",{\"1\":{\"388\":1}}],[\"应届生一般只要掌握热题100里面的题目即可\",{\"1\":{\"1972\":1}}],[\"应当尽量避免\",{\"1\":{\"1391\":1}}],[\"应对\",{\"1\":{\"1088\":2}}],[\"应对这种情况\",{\"1\":{\"488\":1}}],[\"应该支持热插拔\",{\"1\":{\"1693\":1}}],[\"应该使服务器的类库与应用程序的类库相互独立\",{\"1\":{\"1693\":1}}],[\"应该使用这种方式来定义\",{\"1\":{\"1620\":1}}],[\"应该使用哪个表做驱动表呢\",{\"1\":{\"403\":1}}],[\"应该使用\",{\"1\":{\"388\":1}}],[\"应该确保了分割迭代器在某个时候一次只有一个线程使用\",{\"1\":{\"1620\":1}}],[\"应该尽量避免使用线程不安全的hashmap\",{\"1\":{\"1551\":1}}],[\"应该优先考虑使用truncate\",{\"1\":{\"484\":1}}],[\"应该把需要行锁的语句放在最后\",{\"1\":{\"443\":1}}],[\"应该作为驱动表\",{\"1\":{\"403\":1}}],[\"应该是两个表按照各自的条件过滤\",{\"1\":{\"403\":1}}],[\"应该选择小表做驱动表\",{\"1\":{\"403\":3}}],[\"应该选择大表做驱动表还是选择小表做驱动表\",{\"1\":{\"403\":1}}],[\"应该让小表当驱动表\",{\"1\":{\"403\":1}}],[\"应该用哪个表做驱动表\",{\"1\":{\"400\":1}}],[\"应该返回多少行\",{\"1\":{\"396\":1}}],[\"应用层协议解析\",{\"1\":{\"1687\":1}}],[\"应用类加载器\",{\"1\":{\"1663\":1}}],[\"应用分类器classifier\",{\"1\":{\"1618\":1}}],[\"应用程序开发框架\",{\"1\":{\"1982\":1}}],[\"应用程序从磁盘中读取文件内容的操作\",{\"1\":{\"1580\":1}}],[\"应用程序是不允许直接在该区域进行读写或者直接调用内核代码定义的函数\",{\"1\":{\"1579\":1}}],[\"应用程序又会不断的产生新的垃圾\",{\"1\":{\"1447\":1}}],[\"应用的性能得到提高\",{\"1\":{\"1304\":1}}],[\"应用的配置\",{\"1\":{\"1196\":1}}],[\"应用本身无法判断这个令牌是否正确\",{\"1\":{\"1203\":1}}],[\"应用其他bean的名称\",{\"1\":{\"1022\":1}}],[\"应用在启动的时候创建servletcontext对象\",{\"1\":{\"988\":1}}],[\"应用上下文停止阶段\",{\"0\":{\"1174\":1}}],[\"应用上下文启动阶段\",{\"0\":{\"1173\":1}}],[\"应用上下文\",{\"1\":{\"934\":1,\"1013\":1,\"1020\":1,\"1175\":1,\"1184\":2}}],[\"应用上下文已关闭\",{\"1\":{\"933\":2,\"934\":1}}],[\"应用上下文已启动\",{\"1\":{\"933\":2}}],[\"应用上下文准备关闭\",{\"1\":{\"933\":2}}],[\"应用场景\",{\"1\":{\"577\":1,\"578\":1,\"1518\":1}}],[\"应用案例\",{\"1\":{\"574\":1}}],[\"应用\",{\"0\":{\"601\":1},\"1\":{\"571\":1}}],[\"应用日志的过程就只能是单线程\",{\"1\":{\"485\":1}}],[\"应用中已经缓存了id为123\",{\"1\":{\"394\":1}}],[\"应用性能监控\",{\"1\":{\"301\":1}}],[\"硬核redis\",{\"1\":{\"1965\":1}}],[\"硬盘持久化\",{\"1\":{\"1475\":1}}],[\"硬盘操作\",{\"0\":{\"291\":1}}],[\"硬件内存架构没有区分线程栈和堆\",{\"1\":{\"1473\":1}}],[\"硬件层面利用lock或mfence\",{\"1\":{\"1473\":1}}],[\"硬件层面\",{\"1\":{\"1470\":1}}],[\"硬件响应等诸多因素都会影响响应时间\",{\"1\":{\"388\":1}}],[\"遗憾的是\",{\"1\":{\"388\":1,\"396\":1}}],[\"排好序之后对于名称相同的再根据分数进行排序\",{\"1\":{\"1614\":1}}],[\"排他性\",{\"1\":{\"578\":1}}],[\"排他锁\",{\"1\":{\"537\":1,\"541\":1,\"1263\":1}}],[\"排行榜应用实现\",{\"1\":{\"574\":1}}],[\"排查问题更方便\",{\"1\":{\"469\":1}}],[\"排队时间是指服务器因为等待某些资源而没有真正地执行查询的时间\",{\"1\":{\"388\":1}}],[\"排序之后将其名字查找出来\",{\"1\":{\"1611\":1}}],[\"排序等\",{\"1\":{\"1608\":1}}],[\"排序规则又可以做出如下修改\",{\"1\":{\"1605\":1}}],[\"排序函数\",{\"1\":{\"1270\":1}}],[\"排序\",{\"1\":{\"574\":1}}],[\"排序方式\",{\"1\":{\"520\":2}}],[\"排序缓存的大小\",{\"1\":{\"520\":1}}],[\"排序完后需要再次取回其它需要的字段\",{\"1\":{\"520\":1}}],[\"排序完成后\",{\"1\":{\"418\":1,\"420\":1}}],[\"排序后的id数组\",{\"1\":{\"404\":1}}],[\"排序字段若通过索引去访问将大大提高排序速度\",{\"1\":{\"358\":1}}],[\"排序是一个成本比较高的操作\",{\"1\":{\"356\":1}}],[\"排序的\",{\"1\":{\"1620\":1}}],[\"排序的过程结束后\",{\"1\":{\"421\":1}}],[\"排序的结果因为少了city和age字段的值\",{\"1\":{\"355\":1}}],[\"排序的性能会很差\",{\"1\":{\"355\":1}}],[\"排序过程中对字符串做了\",{\"1\":{\"354\":1}}],[\"排序过程中使用的临时的文件数\",{\"1\":{\"354\":1}}],[\"排序就在内存中完成\",{\"1\":{\"354\":1}}],[\"排序使用到了索引\",{\"1\":{\"330\":1}}],[\"排序没有使用索引\",{\"1\":{\"330\":1}}],[\"很浅显易懂\",{\"1\":{\"1981\":1}}],[\"很少有公司需要前后端都掌握\",{\"1\":{\"1976\":1}}],[\"很难适配高性能和便利性的xml框架\",{\"1\":{\"1036\":1}}],[\"很难保证操作和redis操作的事务的一致性\",{\"1\":{\"526\":1}}],[\"很容易采用索引统计数据而不是index\",{\"1\":{\"553\":1}}],[\"很容易出现这样的错误\",{\"1\":{\"386\":1}}],[\"很显然使用idx\",{\"1\":{\"555\":1}}],[\"很显然对驱动表的单表查询可以使用idx\",{\"1\":{\"554\":1}}],[\"很显然对驱动表的单表查询只能使用全表扫描的方式执行\",{\"1\":{\"554\":1}}],[\"很显然驱动表的扇出值越小\",{\"1\":{\"554\":1}}],[\"很显然\",{\"1\":{\"525\":1,\"555\":1,\"556\":1,\"1473\":1}}],[\"很占空间\",{\"1\":{\"454\":1}}],[\"很可能出现从库上迟迟无法响应查询请求的情况\",{\"1\":{\"472\":1}}],[\"很可能会先遇到读性能的问题\",{\"1\":{\"466\":1}}],[\"很可能会出现主备数据不一致的情况\",{\"1\":{\"454\":1}}],[\"很可能这时的数据不一致已经不可查\",{\"1\":{\"459\":1}}],[\"很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间\",{\"1\":{\"416\":1}}],[\"很可能在1秒内就被淘汰了\",{\"1\":{\"406\":1}}],[\"很可能不是必须的\",{\"1\":{\"385\":1}}],[\"很多\",{\"1\":{\"1992\":1}}],[\"很多流操作\",{\"1\":{\"1608\":1}}],[\"很多底层服务可以以rest\",{\"1\":{\"1304\":1}}],[\"很多方面其实都是ioc\",{\"1\":{\"914\":1}}],[\"很多时候一开始还没有到达\",{\"1\":{\"1563\":1}}],[\"很多时候也是能够接受的\",{\"1\":{\"1527\":1}}],[\"很多时候业务逻辑处理存在串行\",{\"1\":{\"1518\":1}}],[\"很多时候hash索引要比b+树索引更高效\",{\"1\":{\"504\":1}}],[\"很多时候小事务能够更高效\",{\"1\":{\"393\":1}}],[\"很多高性能的应用都会对关联查询进行分解\",{\"1\":{\"394\":1}}],[\"很长时间才会更新依次\",{\"1\":{\"319\":1}}],[\"离国内外i啊也会消耗应用服务器的cpu和内存资源\",{\"1\":{\"382\":1}}],[\"确定合适的处理程序对象之后\",{\"1\":{\"1657\":1}}],[\"确定合适的大类型\",{\"1\":{\"527\":1}}],[\"确定大小的\",{\"1\":{\"1620\":1}}],[\"确定哈希桶数组索引位置\",{\"0\":{\"1548\":1}}],[\"确定时io还是cpu瓶颈\",{\"1\":{\"1272\":1}}],[\"确定了线程模型\",{\"1\":{\"1226\":1}}],[\"确定具体的类型\",{\"1\":{\"527\":1}}],[\"确定选择\",{\"1\":{\"519\":1}}],[\"确定放入一个整型字段\",{\"1\":{\"418\":1}}],[\"确定放入两个字段\",{\"1\":{\"355\":1}}],[\"确定放入name\",{\"1\":{\"354\":1}}],[\"确保获取锁\",{\"1\":{\"1553\":1}}],[\"确保一致性的两种最常见的机制是窥探机制和基于目录的机制\",{\"1\":{\"1474\":1}}],[\"确保后续指令执行的原子性\",{\"1\":{\"1473\":1}}],[\"确保热点数据的实时性\",{\"1\":{\"1283\":1}}],[\"确保对业务无影响以后再删除这张表\",{\"1\":{\"487\":1}}],[\"确保seconds\",{\"1\":{\"458\":1}}],[\"确保业务一定不会出现死锁\",{\"1\":{\"444\":1}}],[\"确实很快就可以解开\",{\"1\":{\"444\":1}}],[\"确认是否使用bnl算法\",{\"1\":{\"406\":1}}],[\"确认mysql服务器层是否在分析大量超过需要的数据行\",{\"1\":{\"381\":1}}],[\"确认应用程序是否在检索大量超过需要的数据\",{\"1\":{\"381\":1}}],[\"包了\",{\"1\":{\"1980\":1}}],[\"包资源库\",{\"1\":{\"1980\":1}}],[\"包括它的源\",{\"1\":{\"1623\":1}}],[\"包括原来的就是spliterator就是空的\",{\"1\":{\"1620\":1}}],[\"包括原始值\",{\"1\":{\"1071\":1}}],[\"包括父类的属性信息\",{\"1\":{\"1484\":1}}],[\"包括private方法\",{\"1\":{\"1350\":1}}],[\"包括私有属性和私有方法\",{\"1\":{\"1340\":1}}],[\"包括java虚拟机\",{\"1\":{\"1337\":1}}],[\"包括jsp\",{\"1\":{\"983\":1,\"1235\":1}}],[\"包括占位符处理和类型转换\",{\"1\":{\"1144\":1}}],[\"包括datasource或者相关的ejb的组件\",{\"1\":{\"914\":1}}],[\"包括连接管理\",{\"1\":{\"645\":1}}],[\"包括主服务器和从服务器\",{\"1\":{\"620\":1}}],[\"包括元素成员和元素分值\",{\"1\":{\"574\":1}}],[\"包括间隙锁\",{\"1\":{\"476\":1}}],[\"包括\",{\"1\":{\"473\":1,\"1053\":1}}],[\"包括memory引擎\",{\"1\":{\"409\":1}}],[\"包括网络\",{\"1\":{\"381\":1}}],[\"包括排序\",{\"1\":{\"381\":1}}],[\"包含核心基础\",{\"1\":{\"1983\":1}}],[\"包含两个重要部件\",{\"1\":{\"1688\":1}}],[\"包含多组服务\",{\"1\":{\"1685\":1}}],[\"包含多个host\",{\"1\":{\"1683\":1}}],[\"包含一个终止操作\",{\"1\":{\"1619\":1}}],[\"包含0个或多个中间操作\",{\"1\":{\"1619\":1}}],[\"包含三个方面\",{\"1\":{\"1470\":1}}],[\"包含所有层次的事件\",{\"1\":{\"1125\":1}}],[\"包含类\",{\"1\":{\"963\":1}}],[\"包含\",{\"1\":{\"927\":1}}],[\"包含间隙行记录\",{\"1\":{\"536\":1}}],[\"包含了key和value以及next指针\",{\"1\":{\"1553\":1}}],[\"包含了一个hashentry数组\",{\"1\":{\"1553\":1}}],[\"包含了一个segment的数组\",{\"1\":{\"1553\":1}}],[\"包含了删掉的行的所有字段的值\",{\"1\":{\"454\":1}}],[\"包含了每个记录的整个字符串\",{\"1\":{\"350\":1}}],[\"包含不适合在其他列中显示但十分重要的额外信息\",{\"1\":{\"330\":1}}],[\"包含文档的各字段类型\",{\"1\":{\"309\":1}}],[\"慢\",{\"1\":{\"595\":1}}],[\"慢sql分析\",{\"1\":{\"430\":2}}],[\"慢sql的优化思路\",{\"0\":{\"163\":1,\"1272\":1}}],[\"慢查询的开启并捕获\",{\"1\":{\"430\":1}}],[\"慢查询日志支持将日志记录写入文件\",{\"1\":{\"428\":1}}],[\"慢查询日志是什么\",{\"1\":{\"428\":1}}],[\"慢查询日志\",{\"0\":{\"427\":1}}],[\"慢查询基础\",{\"0\":{\"381\":1}}],[\"题目\",{\"1\":{\"378\":1}}],[\"面对面试足够了\",{\"1\":{\"1992\":1}}],[\"面试中elasticsearch出现的概率也不高\",{\"1\":{\"1986\":1}}],[\"面试中会出现很多\",{\"1\":{\"1983\":1}}],[\"面试重点看索引部分就可以了\",{\"1\":{\"1974\":1}}],[\"面试题\",{\"0\":{\"760\":1,\"778\":1,\"829\":1,\"852\":1,\"864\":1,\"901\":1,\"913\":1,\"923\":1,\"935\":1,\"947\":1,\"968\":1,\"979\":1,\"990\":1,\"1014\":1,\"1033\":1,\"1046\":1,\"1057\":1,\"1066\":1,\"1077\":1,\"1094\":1,\"1104\":1,\"1127\":1,\"1141\":1,\"1158\":1,\"1176\":1}}],[\"面试题分析\",{\"0\":{\"378\":1}}],[\"面临网络问题\",{\"1\":{\"1304\":1}}],[\"面向块的io\",{\"1\":{\"1574\":1}}],[\"面向连接的\",{\"1\":{\"1419\":1}}],[\"面向接口的事件\",{\"0\":{\"1109\":1}}],[\"面向流失存储\",{\"1\":{\"1037\":1}}],[\"面向api\",{\"1\":{\"994\":1}}],[\"面向注解的事件\",{\"0\":{\"1110\":1}}],[\"面向注解beandefinition解析\",{\"1\":{\"995\":1}}],[\"面向注解\",{\"1\":{\"994\":1}}],[\"面向资源的情况我们在之前也有过相关的讨论\",{\"1\":{\"995\":1}}],[\"面向资源beandefinition解析\",{\"1\":{\"995\":1}}],[\"面向资源\",{\"1\":{\"994\":1,\"1037\":1}}],[\"面向切面\",{\"1\":{\"921\":1}}],[\"面向切面编程\",{\"1\":{\"892\":1,\"899\":1,\"900\":1}}],[\"面向函数式编程\",{\"1\":{\"900\":1}}],[\"面向模块编程\",{\"1\":{\"900\":1}}],[\"面向元编程\",{\"1\":{\"899\":1,\"900\":1}}],[\"面向对象的方式\",{\"1\":{\"1620\":1}}],[\"面向对象编程\",{\"1\":{\"899\":1,\"900\":1}}],[\"面向对象编程三⼤特性\",{\"0\":{\"11\":1,\"1340\":1}}],[\"面向对象\",{\"1\":{\"307\":3}}],[\"口诀\",{\"1\":{\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"375\":2,\"376\":1}}],[\"指标监控等章节\",{\"1\":{\"1983\":1}}],[\"指针\",{\"1\":{\"1561\":2}}],[\"指针到数组尽头了\",{\"1\":{\"1502\":1}}],[\"指针指向的内存值是否和\",{\"1\":{\"1479\":1}}],[\"指同一时刻\",{\"1\":{\"1470\":2}}],[\"指令作为一种硬件原语\",{\"1\":{\"1479\":1}}],[\"指令的一层简单封装\",{\"1\":{\"1479\":1}}],[\"指令和\",{\"1\":{\"1479\":2}}],[\"指令\",{\"1\":{\"1479\":4}}],[\"指令是包含在\",{\"1\":{\"1479\":1}}],[\"指令添加\",{\"1\":{\"1479\":1}}],[\"指令重排造成的线程安全问题\",{\"1\":{\"1388\":1}}],[\"指令队列\",{\"0\":{\"604\":1}}],[\"指某个函数\",{\"1\":{\"1376\":1}}],[\"指纹\",{\"1\":{\"1199\":1}}],[\"指向内核为每一个进程所维护的该进程打开文件的记录表\",{\"1\":{\"1561\":1}}],[\"指向内核中为每个进程维护进程所打开的文件的记录表\",{\"1\":{\"1423\":1}}],[\"指向了key\",{\"1\":{\"1551\":1}}],[\"指向了线程二重组后的链表\",{\"1\":{\"1551\":1}}],[\"指向的内存值交给exchange\",{\"1\":{\"1479\":1}}],[\"指向urlstreamhandler实现类的包下\",{\"1\":{\"1049\":1}}],[\"指向上一个旧版本\",{\"1\":{\"542\":1}}],[\"指向这条记录的上一个版本\",{\"1\":{\"542\":1}}],[\"指向a\",{\"1\":{\"467\":1}}],[\"指的就是并发连接\",{\"1\":{\"476\":1}}],[\"指的就是sync\",{\"1\":{\"451\":1}}],[\"指的就是把日志写入到文件系统的page\",{\"1\":{\"450\":1}}],[\"指的是\",{\"1\":{\"1619\":1}}],[\"指的是将用户应用程序的缓冲区和操作系统的内核缓冲区进行映射处理\",{\"1\":{\"1581\":1}}],[\"指的是在一个分布式系统中\",{\"1\":{\"1311\":1}}],[\"指的是使用memory引擎的表\",{\"1\":{\"409\":1}}],[\"指的是查询从索引的最左前列开始并且不跳过索引中的字段\",{\"1\":{\"370\":1}}],[\"指定元空间触发full\",{\"1\":{\"1664\":1}}],[\"指定接口的时候\",{\"1\":{\"1654\":1}}],[\"指定\",{\"1\":{\"1650\":1}}],[\"指定下次扩容的大小\",{\"1\":{\"1554\":1}}],[\"指定异常处理器\",{\"1\":{\"1510\":1}}],[\"指定容量就是有界队列\",{\"1\":{\"1503\":1}}],[\"指定队列的大小创建有界队列\",{\"1\":{\"1503\":1}}],[\"指定线程模型\",{\"1\":{\"1226\":1}}],[\"指定parent\",{\"1\":{\"1022\":1}}],[\"指定bean名称或者id\",{\"1\":{\"961\":3}}],[\"指定多少毫秒之后\",{\"1\":{\"624\":1}}],[\"指定单位的参数\",{\"1\":{\"576\":1}}],[\"指定的字段是否存在\",{\"1\":{\"573\":1}}],[\"指定成本常数使用的存储引擎名称\",{\"1\":{\"557\":1}}],[\"指定为current\",{\"1\":{\"468\":1}}],[\"指定查询字符串\",{\"1\":{\"306\":1}}],[\"指定id\",{\"1\":{\"306\":1}}],[\"自然的\",{\"1\":{\"1609\":1}}],[\"自适应自旋\",{\"1\":{\"1489\":1}}],[\"自适应自旋等技术来减少锁操作的开销\",{\"1\":{\"1483\":1}}],[\"自适应缓冲区\",{\"0\":{\"707\":1}}],[\"自减\",{\"1\":{\"1482\":1}}],[\"自减并不是原子操作\",{\"1\":{\"1482\":1}}],[\"自减操作\",{\"1\":{\"1293\":1}}],[\"自旋锁与自适应自旋\",{\"0\":{\"1820\":1}}],[\"自旋等待\",{\"1\":{\"1554\":1}}],[\"自旋的目的是为了减少线程挂起的次数\",{\"1\":{\"1485\":1}}],[\"自旋会占用cpu时间\",{\"1\":{\"1485\":1}}],[\"自旋\",{\"1\":{\"1479\":1}}],[\"自己写的java\",{\"1\":{\"1663\":1}}],[\"自己未标记完\",{\"1\":{\"1442\":1}}],[\"自己标记完了\",{\"1\":{\"1442\":1}}],[\"自己要放弃竞争锁\",{\"1\":{\"1288\":1}}],[\"自定义匹配\",{\"0\":{\"1912\":1}}],[\"自定义类加载器\",{\"1\":{\"1663\":1,\"1691\":1}}],[\"自定义collector的过程帮助我们很好的理解了关于collector的基本概念\",{\"1\":{\"1618\":1}}],[\"自定义collector\",{\"0\":{\"1617\":1}}],[\"自定义业务规则分片\",{\"1\":{\"1270\":1}}],[\"自定义的初始化回调方法\",{\"1\":{\"1234\":1}}],[\"自定义的bean\",{\"1\":{\"919\":1}}],[\"自定义spring事件\",{\"0\":{\"1119\":1}}],[\"自定义propertyeditor扩展\",{\"0\":{\"1084\":1}}],[\"自定义validator的示例\",{\"1\":{\"1064\":1}}],[\"自定义validator\",{\"0\":{\"1064\":1}}],[\"自定义namespacehandler实现\",{\"1\":{\"1030\":1}}],[\"自定义作用的相关示例\",{\"1\":{\"989\":1}}],[\"自定义实现\",{\"1\":{\"967\":1,\"1049\":1}}],[\"自定义依赖注入注解\",{\"0\":{\"967\":1},\"1\":{\"967\":1}}],[\"自定义绑定候选对象处理器\",{\"1\":{\"963\":1}}],[\"自定义注解\",{\"1\":{\"961\":1,\"967\":1}}],[\"自定义销毁方法\",{\"1\":{\"933\":3,\"1012\":1,\"1020\":1}}],[\"自定义初始化方法\",{\"1\":{\"931\":3,\"1007\":2,\"1020\":1}}],[\"自定义bean销毁的回调方法\",{\"1\":{\"1234\":1}}],[\"自定义bean作用域\",{\"0\":{\"989\":1}}],[\"自定义bean\",{\"1\":{\"918\":1,\"919\":1}}],[\"自定义\",{\"1\":{\"909\":1}}],[\"自定义编解码器\",{\"0\":{\"726\":1}}],[\"自定义redis工具类\",{\"0\":{\"584\":1}}],[\"自增\",{\"1\":{\"1482\":1}}],[\"自增锁\",{\"1\":{\"1263\":1}}],[\"自增锁直到语句执行结束才释放\",{\"1\":{\"492\":1}}],[\"自增锁还是要等语句结束后才被释放\",{\"1\":{\"492\":1}}],[\"自增锁在申请之后就马上释放\",{\"1\":{\"492\":1}}],[\"自增锁的范围是语句级别\",{\"1\":{\"492\":1}}],[\"自增锁的优化\",{\"0\":{\"492\":1},\"1\":{\"491\":1}}],[\"自增id锁并不是一个事务锁\",{\"1\":{\"492\":1}}],[\"自增值的变更结果也会有所不同\",{\"1\":{\"491\":1}}],[\"自增值的行为如下\",{\"1\":{\"491\":1}}],[\"自增值的修改\",{\"0\":{\"491\":1}}],[\"自增值保存在内存里\",{\"1\":{\"490\":1}}],[\"自增值持久化\",{\"1\":{\"490\":1}}],[\"自增值并不是保存在表结构定义里的\",{\"1\":{\"490\":1}}],[\"自增主键总结\",{\"0\":{\"499\":1}}],[\"自增主键为什么还是不能保证连续呢\",{\"1\":{\"491\":1}}],[\"自增主键的上限\",{\"0\":{\"493\":1}}],[\"自增主键的存储\",{\"0\":{\"490\":1}}],[\"自增主键的插入数据的模式\",{\"1\":{\"335\":1}}],[\"自增主键可以让主键索引尽量地保持递增顺序插入\",{\"1\":{\"489\":1}}],[\"自增主键\",{\"0\":{\"489\":1}}],[\"自增主键往往是更合理的选择\",{\"1\":{\"335\":1}}],[\"自增主键是指自增列上定义的主键\",{\"1\":{\"335\":1}}],[\"自动事务的大致实现过程\",{\"1\":{\"1630\":1}}],[\"自动销毁\",{\"1\":{\"1533\":1}}],[\"自动存盘操作\",{\"1\":{\"1531\":1}}],[\"自动调整空间大小\",{\"1\":{\"1457\":1}}],[\"自动配置的主要应用场景在xml文件当中\",{\"1\":{\"953\":1}}],[\"自动绑定的不足之处\",{\"1\":{\"952\":1}}],[\"自动绑定的模式\",{\"1\":{\"927\":1}}],[\"自动绑定\",{\"0\":{\"952\":1},\"1\":{\"951\":1}}],[\"自动模式\",{\"1\":{\"951\":1,\"953\":1,\"954\":1,\"957\":1}}],[\"自动装配\",{\"0\":{\"877\":1}}],[\"自动动态代理\",{\"0\":{\"776\":1}}],[\"自动选举\",{\"1\":{\"611\":1}}],[\"自动重新计算统计数据也不会立即发生\",{\"1\":{\"559\":1}}],[\"自动补全功能用得不多\",{\"1\":{\"482\":1}}],[\"自动or手动\",{\"1\":{\"369\":1}}],[\"$0\",{\"1\":{\"1473\":1}}],[\"$\",{\"1\":{\"978\":4,\"1022\":1,\"1031\":2,\"1032\":2,\"1044\":1,\"1049\":1,\"1146\":3,\"1156\":1,\"1157\":1,\"1210\":1,\"1289\":1,\"1592\":1,\"1648\":1}}],[\"$created\",{\"1\":{\"928\":1}}],[\"$child\",{\"1\":{\"928\":1}}],[\"$r\",{\"1\":{\"401\":1}}],[\"$r4\",{\"1\":{\"368\":2}}],[\"$l2\",{\"1\":{\"368\":1}}],[\"做1\",{\"1\":{\"1972\":1}}],[\"做hash\",{\"1\":{\"1549\":1}}],[\"做以下分类\",{\"1\":{\"483\":1}}],[\"做一个sleep可以有很大概率拿到最新的数据\",{\"1\":{\"471\":1}}],[\"做全库逻辑备份\",{\"1\":{\"437\":1}}],[\"做了1000次带索引的查询\",{\"1\":{\"407\":1}}],[\"做自动类型转换的时候\",{\"1\":{\"368\":1}}],[\"做完上面这些\",{\"1\":{\"345\":1}}],[\"做完了这些识别以后\",{\"1\":{\"320\":1}}],[\"本节我们就分析jdk已经帮我们实现的collector的例子\",{\"1\":{\"1618\":1}}],[\"本身是可变的\",{\"1\":{\"1618\":1}}],[\"本身是不存储任何元素的\",{\"1\":{\"1503\":1}}],[\"本身接受的是可变参数\",{\"1\":{\"1607\":1}}],[\"本质就是一个巨大的\",{\"1\":{\"1980\":1}}],[\"本质就是一个映射\",{\"1\":{\"1546\":1}}],[\"本质是函数式的\",{\"1\":{\"1608\":1}}],[\"本质上而言\",{\"1\":{\"1607\":1}}],[\"本质上这个其实\",{\"1\":{\"1599\":1}}],[\"本质上都是调用thread\",{\"1\":{\"1477\":1}}],[\"本质上是使用reentrantlock完成并发操作\",{\"1\":{\"1403\":1}}],[\"本条记录最后更新时间\",{\"1\":{\"558\":1}}],[\"本查询和查询四类似\",{\"1\":{\"554\":1}}],[\"本查询和查询二类似\",{\"1\":{\"554\":1}}],[\"本查询和查询一类似\",{\"1\":{\"554\":1}}],[\"本例中sql语句不满足索引合并的条件\",{\"1\":{\"550\":1}}],[\"本例中使用idx\",{\"1\":{\"549\":1}}],[\"本来申请id是一个很快的操作\",{\"1\":{\"491\":1}}],[\"本来是有索引的\",{\"1\":{\"367\":1}}],[\"本小节我们要讨论的是\",{\"1\":{\"475\":1}}],[\"本地方法栈\",{\"0\":{\"1704\":1}}],[\"本地线程分配缓冲\",{\"1\":{\"1668\":1}}],[\"本地代码缓存等\",{\"1\":{\"1438\":1}}],[\"本地调度\",{\"1\":{\"895\":1}}],[\"本地任务\",{\"1\":{\"895\":1}}],[\"本地是否包含了这个差集需要的所有binlog事务\",{\"1\":{\"468\":1}}],[\"本地记录的也是a的微店\",{\"1\":{\"467\":1}}],[\"本地resource\",{\"0\":{\"232\":1,\"1312\":1}}],[\"遍历切面中的每个方法\",{\"1\":{\"1630\":1}}],[\"遍历结束之前在结构上被修改了\",{\"1\":{\"1620\":1}}],[\"遍历的\",{\"1\":{\"1620\":1}}],[\"遍历和分割都会消耗元素\",{\"1\":{\"1620\":1}}],[\"遍历集合中的单个的字符串\",{\"1\":{\"1608\":1}}],[\"遍历执行累加器accumulator中的accept\",{\"1\":{\"1608\":1}}],[\"遍历这个集合\",{\"1\":{\"1595\":1}}],[\"遍历这个索引比主键索引来得更快\",{\"1\":{\"366\":1}}],[\"遍历该节点上的链表\",{\"1\":{\"1554\":1}}],[\"遍历过程中若发现key已经存在直接覆盖value即可\",{\"1\":{\"1549\":1}}],[\"遍历table\",{\"1\":{\"1549\":1}}],[\"遍历\",{\"1\":{\"1423\":2}}],[\"遍历时只能查看\",{\"1\":{\"1353\":1}}],[\"遍历排序号的id和字段position\",{\"1\":{\"520\":1}}],[\"遍历排序结果\",{\"1\":{\"355\":1}}],[\"遍历完成后\",{\"1\":{\"416\":1}}],[\"遍历哪个索引树得到的结果逻辑上都是一样的\",{\"1\":{\"396\":1}}],[\"方便查阅的\",{\"1\":{\"1981\":1}}],[\"方便在不同版本进行切换修改\",{\"1\":{\"1981\":1}}],[\"方便在面试复习之前刷过的题目\",{\"1\":{\"1972\":1}}],[\"方便gc\",{\"1\":{\"1503\":1}}],[\"方式是通过intconsumer的参数进行装箱操作\",{\"1\":{\"1620\":1}}],[\"方式二\",{\"1\":{\"1482\":1}}],[\"方式一\",{\"1\":{\"1482\":1}}],[\"方案\",{\"0\":{\"471\":1}}],[\"方框上面的数字表示month\",{\"1\":{\"366\":1}}],[\"方法调用\",{\"0\":{\"1805\":1}}],[\"方法表集合\",{\"0\":{\"1781\":1}}],[\"方法出口\",{\"1\":{\"1664\":1}}],[\"方法信息\",{\"1\":{\"1663\":1}}],[\"方法形参名称获取\",{\"1\":{\"1648\":1}}],[\"方法就可以不用再去执行\",{\"1\":{\"1623\":1}}],[\"方法就是printstream中的一个方法\",{\"1\":{\"1605\":1}}],[\"方法就是高阶函数\",{\"1\":{\"1598\":1}}],[\"方法进行修改\",{\"1\":{\"1619\":1}}],[\"方法要完成的事情实际上就是要将downstream在收集的时候\",{\"1\":{\"1618\":1}}],[\"方法要显式的调用\",{\"1\":{\"1346\":1}}],[\"方法本身的参数并没有直接使用t和k\",{\"1\":{\"1618\":1}}],[\"方法本身接收两个参数\",{\"1\":{\"1618\":1}}],[\"方法返回地址\",{\"0\":{\"1803\":1}}],[\"方法返回的中间结果容器类型相同\",{\"1\":{\"1617\":1}}],[\"方法返回的也是optional对象\",{\"1\":{\"1610\":1}}],[\"方法返回值和修饰值可以不同\",{\"1\":{\"1339\":1}}],[\"方法获取到结果集\",{\"1\":{\"1608\":1}}],[\"方法并不会报错\",{\"1\":{\"1607\":1}}],[\"方法也就变成了\",{\"1\":{\"1601\":1}}],[\"方法判断两个参数是不是相等\",{\"1\":{\"1599\":1}}],[\"方法而言\",{\"1\":{\"1598\":1}}],[\"方法无法脱离类或者接口单独存在\",{\"1\":{\"1595\":1}}],[\"方法接收的函数式接口就是我们上面举得第一个例子consumer\",{\"1\":{\"1594\":1}}],[\"方法外\",{\"1\":{\"1594\":1}}],[\"方法存在本质的差别\",{\"1\":{\"1593\":1}}],[\"方法与之前的foreach\",{\"1\":{\"1593\":1}}],[\"方法可以参数的传递总共有两种\",{\"1\":{\"1593\":1}}],[\"方法逻辑拷贝\",{\"1\":{\"1584\":1}}],[\"方法不同的是\",{\"1\":{\"1584\":1}}],[\"方法和类的对象\",{\"1\":{\"1558\":1}}],[\"方法做了两个工作\",{\"1\":{\"1554\":1}}],[\"方法做个验证\",{\"1\":{\"352\":1}}],[\"方法里的\",{\"1\":{\"1554\":1}}],[\"方法中使用了cas策略执行初始化操作\",{\"1\":{\"1554\":1}}],[\"方法来查询流的类型\",{\"1\":{\"1619\":1}}],[\"方法来设置foo的属性age\",{\"1\":{\"1526\":1}}],[\"方法来获取结果\",{\"1\":{\"1516\":1}}],[\"方法抛出的中断异常后\",{\"1\":{\"1524\":1}}],[\"方法重置\",{\"1\":{\"1496\":1}}],[\"方法逃逸\",{\"1\":{\"1488\":1}}],[\"方法还有一个超时参数\",{\"1\":{\"1483\":1}}],[\"方法的说明\",{\"1\":{\"1618\":1,\"1619\":1,\"1620\":8,\"1621\":1,\"1622\":3,\"1623\":4}}],[\"方法的第一个参数是一个function类型\",{\"1\":{\"1618\":1}}],[\"方法的源码是这样的\",{\"1\":{\"1610\":1}}],[\"方法的参数是空值\",{\"1\":{\"1595\":1}}],[\"方法的时候\",{\"1\":{\"1527\":1}}],[\"方法的实现如下\",{\"1\":{\"1479\":1,\"1623\":1}}],[\"方法的回调\",{\"1\":{\"1008\":1}}],[\"方法区\",{\"0\":{\"1706\":1}}],[\"方法区使用的直接内存\",{\"1\":{\"1664\":1}}],[\"方法区内存溢出的例子\",{\"1\":{\"1456\":1}}],[\"方法区的垃圾回收主要有两种\",{\"1\":{\"1443\":1}}],[\"方法在finally块中手工释放\",{\"1\":{\"1394\":1}}],[\"方法设置线程为守护线程或者用户线程\",{\"1\":{\"1375\":1}}],[\"方法引用是lambda表达式的一种语法糖\",{\"1\":{\"1603\":1}}],[\"方法引用与lambda表达式完全等价\",{\"1\":{\"1603\":1}}],[\"方法引用共分为4类\",{\"1\":{\"1602\":1}}],[\"方法引用来创建\",{\"1\":{\"1594\":1}}],[\"方法引用\",{\"0\":{\"1602\":1},\"1\":{\"1349\":1}}],[\"方法用于暴露对象的行为\",{\"1\":{\"1346\":1}}],[\"方法绑定在本地的端口上\",{\"1\":{\"1226\":1}}],[\"方法绑定本地的一个端口\",{\"1\":{\"1226\":1}}],[\"方法连接到远程的主机和端口\",{\"1\":{\"1226\":1}}],[\"方法添加一个或者多个channelhandler\",{\"1\":{\"1224\":1}}],[\"方法类型\",{\"1\":{\"1183\":1}}],[\"方法时\",{\"1\":{\"1181\":1}}],[\"方法之前可以主动填充自定义的environment对象\",{\"1\":{\"1178\":1}}],[\"方法之前和refresh\",{\"1\":{\"1178\":1}}],[\"方法之后会创建默认的environment对象\",{\"1\":{\"1178\":1}}],[\"方法之后\",{\"1\":{\"1178\":1}}],[\"方法只有在web的场景下才会进行扩展\",{\"1\":{\"1169\":1}}],[\"方法三\",{\"1\":{\"1138\":1}}],[\"方法实现中将原来流中的identity\",{\"1\":{\"1618\":1}}],[\"方法实现本身并没有特别复杂的地方\",{\"1\":{\"1593\":1}}],[\"方法实现\",{\"0\":{\"1547\":1}}],[\"方法实现需要临时存储传入对象\",{\"1\":{\"1082\":1}}],[\"方法实现将string类型转化为目标类型的对象\",{\"1\":{\"1082\":1}}],[\"方法描述符\",{\"1\":{\"1075\":1}}],[\"方法回调\",{\"1\":{\"1006\":1,\"1009\":1,\"1011\":1}}],[\"方法二\",{\"1\":{\"1005\":1,\"1006\":1,\"1011\":1,\"1113\":1,\"1114\":1,\"1115\":1,\"1138\":2,\"1548\":1}}],[\"方法一般都有返回类型\",{\"1\":{\"1346\":1}}],[\"方法一\",{\"1\":{\"1005\":1,\"1006\":1,\"1011\":1,\"1113\":1,\"1114\":1,\"1115\":1,\"1548\":1}}],[\"方法影响\",{\"1\":{\"981\":1}}],[\"方法会获得相反的结果\",{\"1\":{\"1601\":1}}],[\"方法会根据比较器comparator返回两个元素中比较小的那一个\",{\"1\":{\"1601\":1}}],[\"方法会调用preparebeanfactory\",{\"1\":{\"973\":1}}],[\"方法会继续往下执行到doresolvedependency方法\",{\"1\":{\"963\":1}}],[\"方法名必须相同\",{\"1\":{\"1339\":1}}],[\"方法名\",{\"1\":{\"1208\":1}}],[\"方法名称可以或可以不与类名称相同\",{\"1\":{\"1346\":1}}],[\"方法名称\",{\"1\":{\"963\":1}}],[\"方法名就是bean名称\",{\"1\":{\"940\":1}}],[\"方法注入的示例\",{\"1\":{\"956\":1}}],[\"方法注入\",{\"0\":{\"956\":1},\"1\":{\"958\":1,\"969\":1}}],[\"方法被回调\",{\"1\":{\"934\":1,\"1013\":1}}],[\"方法\",{\"1\":{\"931\":1,\"933\":1,\"934\":1,\"951\":1,\"964\":1,\"973\":1,\"1007\":1,\"1012\":1,\"1013\":1,\"1073\":1,\"1075\":1,\"1082\":2,\"1084\":1,\"1103\":3,\"1113\":1,\"1164\":1,\"1165\":2,\"1166\":1,\"1171\":1,\"1172\":1,\"1184\":2,\"1234\":2,\"1352\":1,\"1479\":2,\"1501\":1,\"1524\":3,\"1557\":1,\"1574\":2,\"1593\":1,\"1595\":2,\"1598\":5,\"1607\":5,\"1608\":2,\"1609\":2,\"1610\":1,\"1613\":1,\"1655\":1,\"1663\":2}}],[\"方法是有几个重载的方法\",{\"1\":{\"1608\":1}}],[\"方法是基类object中的方法\",{\"1\":{\"1594\":1}}],[\"方法是\",{\"1\":{\"528\":1}}],[\"方法有什么区别\",{\"0\":{\"79\":1,\"1408\":1}}],[\"等高级语言也都是支持管程的\",{\"1\":{\"1483\":1}}],[\"等着服务端返回响应\",{\"1\":{\"1421\":1}}],[\"等于a\",{\"1\":{\"1615\":1}}],[\"等于只要发一些指令给底层就可以了\",{\"1\":{\"1611\":1}}],[\"等于e\",{\"1\":{\"1479\":1}}],[\"等于6的时候退转为链表\",{\"1\":{\"1363\":1}}],[\"等于系统表\",{\"1\":{\"330\":1}}],[\"等值查询\",{\"1\":{\"1265\":1}}],[\"等promary\",{\"1\":{\"1256\":1}}],[\"等\",{\"1\":{\"1035\":1,\"1224\":1,\"1484\":1,\"1978\":1}}],[\"等价于<property\",{\"1\":{\"1003\":1}}],[\"等价于setx\",{\"1\":{\"572\":1}}],[\"等同于放弃了扩展性\",{\"1\":{\"470\":1}}],[\"等gtid方案\",{\"1\":{\"469\":1}}],[\"等主库位点方案\",{\"0\":{\"473\":1},\"1\":{\"469\":1}}],[\"等到着获取锁\",{\"1\":{\"1490\":1}}],[\"等到服务端给出响应后\",{\"1\":{\"1421\":1}}],[\"等到服务器重启之后\",{\"1\":{\"558\":1}}],[\"等到队列有数据了\",{\"1\":{\"605\":1}}],[\"等到卖家再刷新页面\",{\"1\":{\"471\":1}}],[\"等到主备间的同步关系建立完成\",{\"1\":{\"467\":1}}],[\"等到空间快满了\",{\"1\":{\"457\":1}}],[\"等待数据准备\",{\"1\":{\"1561\":1}}],[\"等待策略\",{\"1\":{\"1520\":1,\"1521\":1}}],[\"等待其他线程释放锁而唤醒\",{\"1\":{\"1519\":1}}],[\"等待其它线程唤醒\",{\"1\":{\"1503\":2}}],[\"等待消费者唤醒\",{\"1\":{\"1502\":1}}],[\"等待再次获得锁\",{\"1\":{\"1490\":1}}],[\"等待线程\",{\"1\":{\"1483\":1}}],[\"等待重新调度\",{\"1\":{\"1483\":1}}],[\"等待唤醒机制规范实现\",{\"1\":{\"1530\":1}}],[\"等待唤醒机制\",{\"1\":{\"1477\":1}}],[\"等待redis服务器响应\",{\"1\":{\"1291\":1}}],[\"等待连接关闭\",{\"1\":{\"1226\":1}}],[\"等待一段时间\",{\"1\":{\"1013\":1}}],[\"等待接收消息\",{\"1\":{\"598\":1}}],[\"等待总时长\",{\"1\":{\"538\":1}}],[\"等待总次数\",{\"1\":{\"538\":1}}],[\"等待平均时长\",{\"1\":{\"538\":1}}],[\"等待\",{\"1\":{\"474\":1,\"1554\":1}}],[\"等待新主库a\",{\"1\":{\"467\":1}}],[\"等待所有wroker都执行完成\",{\"1\":{\"462\":1}}],[\"等trx1要开始写盘的时候\",{\"1\":{\"451\":1}}],[\"等等\",{\"1\":{\"388\":1,\"1326\":1,\"1609\":1,\"1621\":1,\"1623\":1}}],[\"等操作\",{\"1\":{\"381\":1}}],[\"等字段\",{\"1\":{\"366\":1}}],[\"然而有些流操作可能会返回他们的接收者而并不是一个新的stream对象\",{\"1\":{\"1619\":1}}],[\"然而我想这是远远不够的\",{\"1\":{\"1613\":1}}],[\"然而即使搬了家\",{\"1\":{\"1561\":1}}],[\"然而如果在写入的过程中出现系统崩溃\",{\"1\":{\"1297\":1}}],[\"然而如果网络中断事件是发生在客户端执行exec命令之后\",{\"1\":{\"1297\":1}}],[\"然而扩展复杂\",{\"1\":{\"1036\":1}}],[\"然而性能较差\",{\"1\":{\"1036\":1}}],[\"然而\",{\"1\":{\"365\":1,\"1457\":1,\"1474\":1,\"1594\":1,\"1615\":1,\"1619\":1}}],[\"然后自己对结果集进行封装处理\",{\"1\":{\"1982\":1}}],[\"然后处理\",{\"1\":{\"1648\":1}}],[\"然后处于就绪状态\",{\"1\":{\"1383\":1}}],[\"然后合并子类的beandifition\",{\"1\":{\"1647\":1}}],[\"然后下游收集器会对流中t类型的元素生成一个d类型的结果\",{\"1\":{\"1618\":1}}],[\"然后会对于给定的key所关联的值\",{\"1\":{\"1618\":1}}],[\"然后来创建一些对象\",{\"1\":{\"1613\":1}}],[\"然后来实现对于student的排序\",{\"1\":{\"1604\":1}}],[\"然后求出流中元素的总和\",{\"1\":{\"1610\":1}}],[\"然后求和\",{\"1\":{\"1607\":1}}],[\"然后对流中的元素进行遍历\",{\"1\":{\"1608\":1}}],[\"然后对于每一行\",{\"1\":{\"401\":1}}],[\"然后调用consumer接口中的accept方法\",{\"1\":{\"1594\":1}}],[\"然后调用fsync持久化到磁盘\",{\"1\":{\"451\":1}}],[\"然后返回\",{\"1\":{\"1564\":1}}],[\"然后kernel返回结果\",{\"1\":{\"1563\":1}}],[\"然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间\",{\"1\":{\"1561\":1}}],[\"然后才有可能判断到线程的状态已经变成了kill\",{\"1\":{\"481\":1}}],[\"然后构造table\",{\"1\":{\"1554\":1}}],[\"然后是e\",{\"1\":{\"1551\":1}}],[\"然后放开线程2的断点\",{\"1\":{\"1551\":1}}],[\"然后所有的node重新rehash的过程\",{\"1\":{\"1550\":1}}],[\"然后线程会在合适的时机检查这个标志位\",{\"1\":{\"1524\":1}}],[\"然后线程会加入到条件队列\",{\"1\":{\"1490\":1}}],[\"然后唤醒因调用condition\",{\"1\":{\"1493\":1}}],[\"然后阻塞当前线程\",{\"1\":{\"1493\":1}}],[\"然后被gc线程清理掉\",{\"1\":{\"1436\":1}}],[\"然后经过一次minor\",{\"1\":{\"1436\":1}}],[\"然后传入servlet或者struts的action进行业务逻辑\",{\"1\":{\"1354\":1}}],[\"然后由消费者对消息进行处理\",{\"1\":{\"1326\":1}}],[\"然后我需要按照sex字段去查\",{\"1\":{\"1270\":1}}],[\"然后等待客户端的连接\",{\"1\":{\"1226\":1}}],[\"然后又打开浏览器的另一个tab页\",{\"1\":{\"1201\":1}}],[\"然后创建对象\",{\"1\":{\"1183\":1}}],[\"然后定义一个教室类\",{\"1\":{\"1184\":1}}],[\"然后定义相对应的配置类\",{\"1\":{\"1138\":1}}],[\"然后定期执行\",{\"1\":{\"477\":1}}],[\"然后观察输出\",{\"1\":{\"1082\":1}}],[\"然后使用分组方法collectors\",{\"1\":{\"1615\":1}}],[\"然后使用combiner方法合并部分的结果执行一个并行的汇聚操作\",{\"1\":{\"1615\":1}}],[\"然后使用combiner方法将每个分区的结果容器当中的内容进行合并\",{\"1\":{\"1615\":1}}],[\"然后使用yaml的方式装载外部化配置\",{\"1\":{\"1032\":1}}],[\"然后使用类似下面这条语句作为检测逻辑\",{\"1\":{\"479\":1}}],[\"然后设置xmlbeandefinitionreader所使用的加载类\",{\"1\":{\"1025\":1}}],[\"然后然后把结果放进去进行返回\",{\"1\":{\"963\":1}}],[\"然后开始选举新的主机\",{\"1\":{\"621\":1}}],[\"然后主机上也能看到从机的状态\",{\"1\":{\"610\":1}}],[\"然后直接使用工具类来间接操作redis\",{\"1\":{\"584\":1}}],[\"然后按索引\",{\"1\":{\"574\":1}}],[\"然后删除指定的value\",{\"1\":{\"571\":1}}],[\"然后加到另一个列表的头部\",{\"1\":{\"571\":1}}],[\"然后选区成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划\",{\"1\":{\"555\":1}}],[\"然后分析对于被驱动表的成本最低的执行方案\",{\"1\":{\"555\":2}}],[\"然后分别为驱动表和被驱动表选择成本最低的访问方法\",{\"1\":{\"555\":1}}],[\"然后分布到32个数据库实例上\",{\"1\":{\"411\":1}}],[\"然后顺序写日志文件\",{\"1\":{\"543\":1}}],[\"然后顺序申请\",{\"1\":{\"491\":1}}],[\"然后基于最初选定的值更新该行时\",{\"1\":{\"532\":1}}],[\"然后情况buffer\",{\"1\":{\"525\":1}}],[\"然后从t1表里取数据跟join\",{\"1\":{\"525\":1}}],[\"然后从0开始的情况\",{\"1\":{\"497\":1}}],[\"然后扫描被驱动表\",{\"1\":{\"525\":1}}],[\"然后遍历每行数据中字段a的值\",{\"1\":{\"524\":1}}],[\"然后取出两张表的结果合集\",{\"1\":{\"524\":1}}],[\"然后取到对应的id\",{\"1\":{\"347\":2}}],[\"然后通过哈希算法的后两步运算\",{\"1\":{\"1546\":1}}],[\"然后通过appclassloader加载到class对象并赋值给beanclass这个属性\",{\"1\":{\"998\":1}}],[\"然后通过api接口mysql\",{\"1\":{\"474\":1}}],[\"然后通过发布订阅模式通知其他的从服务器\",{\"1\":{\"620\":1}}],[\"然后通过主键回到原表查询需要的字段\",{\"1\":{\"520\":1}}],[\"然后用getset\",{\"1\":{\"1288\":1}}],[\"然后用这个平均值乘以区间最左记录和区间最右记录之间的页面数量就可以了\",{\"1\":{\"549\":1}}],[\"然后用这些索引对应的主键逐个回表\",{\"1\":{\"518\":1}}],[\"然后用过滤完剩下的索引对应的主键id再回表查整行数据\",{\"1\":{\"518\":1}}],[\"然后并将max\",{\"1\":{\"497\":1}}],[\"然后给这个变量加1\",{\"1\":{\"496\":1}}],[\"然后继续增加\",{\"1\":{\"498\":1}}],[\"然后继续循环\",{\"1\":{\"495\":1}}],[\"然后继续执行\",{\"1\":{\"414\":1}}],[\"然后不停地往上加步长\",{\"1\":{\"493\":1}}],[\"然后一次性申请\",{\"1\":{\"492\":1}}],[\"然后一起传给表t2\",{\"1\":{\"405\":1}}],[\"然后两个session\",{\"1\":{\"492\":1}}],[\"然后session\",{\"1\":{\"492\":1}}],[\"然后客户端就可以快速返回了\",{\"1\":{\"482\":1}}],[\"然后客户端程序结束执行\",{\"1\":{\"318\":1}}],[\"然后进程处理这个信号\",{\"1\":{\"481\":1}}],[\"然后进入执行器阶段\",{\"1\":{\"321\":1,\"514\":1}}],[\"然后保持这个状态\",{\"1\":{\"476\":1}}],[\"然后到主库去查\",{\"1\":{\"473\":1}}],[\"然后停止同步\",{\"1\":{\"467\":1}}],[\"然后计算平均一个页面中主键值的记录数量乘以全部叶子结点的数量就算是该表n\",{\"1\":{\"558\":1}}],[\"然后计算哈希值\",{\"1\":{\"462\":1}}],[\"然后计算大概需要多少个顺序和随机i\",{\"1\":{\"388\":1}}],[\"然后节点a和b间\",{\"1\":{\"455\":1}}],[\"然后同步到节点b的完整示意图如下\",{\"1\":{\"453\":1}}],[\"然后关掉死锁检测\",{\"1\":{\"444\":1}}],[\"然后其它线程才有可能继续执行\",{\"1\":{\"444\":1}}],[\"然后依次执行更新\",{\"1\":{\"424\":1}}],[\"然后把改行数据拷贝到undo\",{\"1\":{\"542\":1}}],[\"然后把该行数据拷贝到undo\",{\"1\":{\"542\":1}}],[\"然后把dict\",{\"1\":{\"495\":1}}],[\"然后把解析结果整个发给mysql执行\",{\"1\":{\"454\":1}}],[\"然后把下一个记录作为返回结果\",{\"1\":{\"422\":1}}],[\"然后把这12个有序文件再合并成一个有序的大文件\",{\"1\":{\"354\":1}}],[\"然后统一进行排序\",{\"1\":{\"411\":1}}],[\"然后清空read\",{\"1\":{\"404\":1}}],[\"然后根据对应的mapper接口生成一个mapper接口代理对象\",{\"1\":{\"1653\":1}}],[\"然后根据分析结果着手制定优化计划\",{\"1\":{\"538\":1}}],[\"然后根据主键查到对应的记录\",{\"1\":{\"522\":1}}],[\"然后根据从表t1中取出的每行数据中a的值\",{\"1\":{\"401\":1}}],[\"然后根据字段b来过滤\",{\"1\":{\"347\":1}}],[\"然后redis异常重启了\",{\"1\":{\"397\":1}}],[\"然后将beanfactory关闭\",{\"1\":{\"1651\":1}}],[\"然后将结果传递给所提供的sink\",{\"1\":{\"1623\":1}}],[\"然后将结果在应用程序中进行关联\",{\"1\":{\"394\":1}}],[\"然后将它转换成int值的stream对象\",{\"1\":{\"1619\":1}}],[\"然后将映射之后的值放入到map当中\",{\"1\":{\"1618\":1}}],[\"然后将该student对象添加到list中\",{\"1\":{\"1613\":1}}],[\"然后将每个元素乘以2\",{\"1\":{\"1610\":1}}],[\"然后将所有的元素作为一个整体进行打印\",{\"1\":{\"1609\":1}}],[\"然后将内核中kernel\",{\"1\":{\"1582\":1}}],[\"然后将数据拷贝到用户内存\",{\"1\":{\"1566\":1}}],[\"然后将被拒绝的任务添加到等待队列中\",{\"1\":{\"1410\":1}}],[\"然后将myapplicationlistener标注为spring\",{\"1\":{\"1114\":1}}],[\"然后将max\",{\"1\":{\"490\":1}}],[\"然后将trx\",{\"1\":{\"542\":1}}],[\"然后将statement语句直接拷贝出来执行\",{\"1\":{\"454\":1}}],[\"然后将checkpoint向后移动\",{\"1\":{\"324\":1}}],[\"然后过滤不满足条件的记录\",{\"1\":{\"390\":1}}],[\"然后每次进行比较\",{\"1\":{\"577\":1}}],[\"然后每次都返回完全相同的数据\",{\"1\":{\"386\":1}}],[\"然后每次插入新记录的时候\",{\"1\":{\"352\":1}}],[\"然后抛弃其中的大部分数据\",{\"1\":{\"383\":1}}],[\"然后获取前面n行后关闭结果集\",{\"1\":{\"383\":1}}],[\"然后这些多余的数据会被应用程序丢弃\",{\"1\":{\"382\":1}}],[\"然后原表查到city\",{\"1\":{\"355\":1}}],[\"然后让innodb\",{\"1\":{\"354\":1}}],[\"然后在mtea\",{\"1\":{\"1658\":1}}],[\"然后在segment这个类中\",{\"1\":{\"1553\":1}}],[\"然后在sort\",{\"1\":{\"520\":2}}],[\"然后在传完的瞬间主剧a的主机就掉电了\",{\"1\":{\"467\":1}}],[\"然后在z列上创建一个索引\",{\"1\":{\"417\":1}}],[\"然后在这个汇总实例上做逻辑操作\",{\"1\":{\"411\":1}}],[\"然后在服务器上进行解析\",{\"1\":{\"381\":1}}],[\"然后在返回的l4~l7中\",{\"1\":{\"350\":1}}],[\"然后在候选列表中依次判断每个索引需要扫描多少行\",{\"1\":{\"348\":1}}],[\"然后在该数据库下创建数据表\",{\"1\":{\"309\":1}}],[\"然后乘以这个索引的页面数\",{\"1\":{\"347\":1}}],[\"然后可以得到精确的结果\",{\"1\":{\"347\":1}}],[\"然后可以认为数据页内部通过二分法来定位记录\",{\"1\":{\"342\":1}}],[\"然后做如下操作\",{\"1\":{\"346\":1}}],[\"然后执行销毁方法\",{\"1\":{\"1013\":1}}],[\"然后执行上述语句即可\",{\"1\":{\"557\":1}}],[\"然后执行\",{\"1\":{\"557\":1}}],[\"然后执行下面的序列\",{\"1\":{\"481\":1}}],[\"然后执行如下语句\",{\"1\":{\"454\":1}}],[\"然后执行如下序列\",{\"1\":{\"424\":1}}],[\"然后执行如下sql语句\",{\"1\":{\"346\":1}}],[\"然后执行change\",{\"1\":{\"343\":1}}],[\"然后应用change\",{\"1\":{\"345\":1}}],[\"然后写了一处磁盘\",{\"1\":{\"345\":1}}],[\"然后判断其它条件是否满足\",{\"1\":{\"340\":1}}],[\"然后向后遍历\",{\"1\":{\"339\":1}}],[\"然后向后遍历得到所有需要的结果\",{\"1\":{\"339\":1}}],[\"然后向表中插入5条记录\",{\"1\":{\"335\":1}}],[\"然后挪动部分数据过去\",{\"1\":{\"335\":1}}],[\"然后就可以把表数据从临时库取出来\",{\"1\":{\"327\":1}}],[\"然后\",{\"1\":{\"327\":1,\"332\":1,\"346\":1,\"350\":1,\"414\":1,\"421\":1,\"487\":1,\"492\":1,\"1234\":1,\"1554\":1,\"1566\":1}}],[\"然后告知执行器执行完成了\",{\"1\":{\"326\":1}}],[\"然后再执行postprocessbeanfactory方法\",{\"1\":{\"1652\":1}}],[\"然后再执行切面的逻辑\",{\"1\":{\"1630\":1}}],[\"然后再执行请求了\",{\"1\":{\"318\":1}}],[\"然后再调用iterator中的新增加的foreachremaining方法\",{\"1\":{\"1622\":1}}],[\"然后再调用当前的function的apply\",{\"1\":{\"1598\":1}}],[\"然后再传递给tryadvance\",{\"1\":{\"1620\":1}}],[\"然后再去对应用当前的这个对象的function\",{\"1\":{\"1598\":1}}],[\"然后再去对这个结果应用当前的function\",{\"1\":{\"1598\":1}}],[\"然后再应用当前的function\",{\"1\":{\"1598\":1}}],[\"然后再创建对象\",{\"1\":{\"1436\":1}}],[\"然后再写回到socket中\",{\"1\":{\"1292\":1}}],[\"然后再将key设置成value\",{\"1\":{\"1288\":1}}],[\"然后再将确认过的临时库的数据\",{\"1\":{\"484\":1}}],[\"然后再看lettuce\",{\"1\":{\"583\":1}}],[\"然后再看使用idx\",{\"1\":{\"549\":1}}],[\"然后再加锁进行事务\",{\"1\":{\"581\":1}}],[\"然后再计算这两条记录之间有多少记录\",{\"1\":{\"553\":1}}],[\"然后再比较其他搜索条件是否成立\",{\"1\":{\"549\":1}}],[\"然后再检测其他搜索条件是否成立\",{\"1\":{\"549\":1}}],[\"然后再检测记录是否符合搜索条件\",{\"1\":{\"548\":1}}],[\"然后再根据expire\",{\"1\":{\"549\":1}}],[\"然后再用\",{\"1\":{\"485\":1}}],[\"然后再通过判断跳过那些在从库b上已经执行过的事务\",{\"1\":{\"467\":1}}],[\"然后再把生成的binlog发给节点b\",{\"1\":{\"455\":1}}],[\"然后再取前3条记录\",{\"1\":{\"421\":1}}],[\"然后再返回\",{\"1\":{\"326\":1}}],[\"然后再更新\",{\"1\":{\"324\":1}}],[\"然后磁盘也要找到对应的那条记录\",{\"1\":{\"324\":1}}],[\"尽管他们显著的功能在算法当中\",{\"1\":{\"1620\":1}}],[\"尽可能低级别事务隔离\",{\"1\":{\"539\":1}}],[\"尽可能控制事务大小\",{\"1\":{\"539\":1}}],[\"尽可能减少检索条件范围\",{\"1\":{\"539\":1}}],[\"尽可能减少join语句中的nestedloop\",{\"1\":{\"364\":1}}],[\"尽可能让所有数据检索都通过索引来完成\",{\"1\":{\"539\":1}}],[\"尽可能地只扫描需要的数据行\",{\"1\":{\"390\":1}}],[\"尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的\",{\"1\":{\"380\":1}}],[\"尽量避免直接挂起线程\",{\"1\":{\"1485\":1}}],[\"尽量将cas操作延迟\",{\"1\":{\"1480\":1}}],[\"尽量不要使用微服务的分布式事务\",{\"1\":{\"1304\":1}}],[\"尽量缩小锁的范围\",{\"1\":{\"539\":1}}],[\"尽量少用blob和text\",{\"1\":{\"530\":1}}],[\"尽量把字段定义为not\",{\"1\":{\"527\":1}}],[\"尽量用更小的数据类型\",{\"1\":{\"527\":1}}],[\"尽量减少热点冲突\",{\"1\":{\"1480\":1}}],[\"尽量减少驱动表的扇出\",{\"1\":{\"555\":1}}],[\"尽量减少扫描的数据量\",{\"1\":{\"396\":1}}],[\"尽量减少磁盘访问\",{\"1\":{\"356\":1}}],[\"尽量选择可以能够包含当前query中的where子句中更多字段的索引\",{\"1\":{\"380\":1}}],[\"尽量选择针对当前query过滤性更好的索引\",{\"1\":{\"380\":1}}],[\"尽量选择普通索引\",{\"1\":{\"344\":1}}],[\"尽量使用post请求\",{\"1\":{\"1201\":1}}],[\"尽量使用覆盖索引\",{\"1\":{\"369\":1}}],[\"尽量使用主键查询\",{\"1\":{\"335\":1}}],[\"结构型模式\",{\"0\":{\"839\":1}}],[\"结构的\",{\"1\":{\"599\":1}}],[\"结构\",{\"1\":{\"599\":1}}],[\"结点中的数据索引从左到右递增排列\",{\"1\":{\"502\":1}}],[\"结合性指的是分割计算也会得到一个等价的结果\",{\"1\":{\"1615\":1}}],[\"结合性\",{\"1\":{\"1615\":1}}],[\"结合rows统计数据\",{\"1\":{\"553\":1}}],[\"结合前面关于位点的判断\",{\"1\":{\"472\":1}}],[\"结合之前explain进行全面分析\",{\"1\":{\"428\":1}}],[\"结合分区规则来实现的\",{\"1\":{\"425\":1}}],[\"结果不应该依赖于在流管道执行过程当中可能会修改的任意状态\",{\"1\":{\"1619\":1}}],[\"结果如下图\",{\"1\":{\"1551\":1}}],[\"结果由第二个任务返回\",{\"1\":{\"1518\":1}}],[\"结果还是引用\",{\"1\":{\"1353\":1}}],[\"结果为true\",{\"1\":{\"1181\":1}}],[\"结果包含错误文案code\",{\"1\":{\"1072\":1}}],[\"结果发现没什么数据可以写\",{\"1\":{\"605\":1}}],[\"结果读了一部分就返回了\",{\"1\":{\"603\":1}}],[\"结果存放到sumscore\",{\"1\":{\"574\":1}}],[\"结果是无序的\",{\"1\":{\"572\":1}}],[\"结果是按照主键排序的\",{\"1\":{\"522\":1}}],[\"结果中包含两行数据分别是1000和999\",{\"1\":{\"414\":1}}],[\"结果集里的第一行就是\",{\"1\":{\"417\":2}}],[\"结果集\",{\"1\":{\"355\":1}}],[\"结论二\",{\"1\":{\"985\":1}}],[\"结论一\",{\"1\":{\"985\":1}}],[\"结论\",{\"0\":{\"364\":1},\"1\":{\"519\":1}}],[\"右旋\",{\"1\":{\"1360\":1}}],[\"右记录锁\",{\"1\":{\"1263\":1}}],[\"右侧\",{\"1\":{\"571\":1}}],[\"右\",{\"1\":{\"571\":1}}],[\"右边的部分\",{\"1\":{\"1595\":1}}],[\"右边向列表中push值\",{\"1\":{\"571\":1}}],[\"右边\",{\"1\":{\"571\":1}}],[\"右连接将索引创建在左表上更合适\",{\"1\":{\"362\":1}}],[\"右表\",{\"1\":{\"362\":1}}],[\"左侧\",{\"1\":{\"571\":1}}],[\"左边\",{\"1\":{\"571\":2}}],[\"左右\",{\"1\":{\"479\":1}}],[\"左连接需要在右表上添加索引\",{\"1\":{\"363\":1}}],[\"左连接将索引创建在右表上更合适\",{\"1\":{\"362\":1}}],[\"左表\",{\"1\":{\"362\":1}}],[\"书籍方面\",{\"1\":{\"1974\":1}}],[\"书籍\",{\"1\":{\"362\":1}}],[\"推断构造源码解析\",{\"0\":{\"1650\":1}}],[\"推断构造方法的核心源码如下\",{\"1\":{\"1650\":1}}],[\"推断构造方法\",{\"1\":{\"1630\":1}}],[\"推断构造方法底层原理\",{\"1\":{\"1630\":1}}],[\"推荐雷丰阳老师的\",{\"1\":{\"1983\":1}}],[\"推荐使用一整套课程进行学习\",{\"1\":{\"1982\":1}}],[\"推荐看廖雪峰的\",{\"1\":{\"1981\":1}}],[\"推荐尚硅谷的\",{\"1\":{\"1978\":1}}],[\"推荐阅读\",{\"1\":{\"1975\":1}}],[\"推荐入门的小伙伴看\",{\"1\":{\"1974\":1}}],[\"推荐大家看尚硅谷宋红康老师的\",{\"1\":{\"1969\":1}}],[\"推荐在线程绑定到固定的cpu的场景下使用\",{\"1\":{\"1520\":1}}],[\"推荐部署多个redis节点\",{\"1\":{\"1292\":1}}],[\"推荐\",{\"1\":{\"962\":1}}],[\"推论\",{\"1\":{\"361\":1}}],[\"推算出字段的类型\",{\"1\":{\"309\":1}}],[\"看了答案也不知道该怎么做\",{\"1\":{\"1972\":1}}],[\"看了这么几个例子\",{\"1\":{\"1593\":1}}],[\"看博客和源码精进学习\",{\"1\":{\"1968\":1}}],[\"看书学习\",{\"1\":{\"1968\":1}}],[\"看视频的好处就是有老师带着\",{\"1\":{\"1968\":1}}],[\"看视频系统学习\",{\"1\":{\"1968\":1}}],[\"看起来与上面的写法是完全等价的\",{\"1\":{\"1614\":1}}],[\"看起来只是增加了一步\",{\"1\":{\"1593\":1}}],[\"看上去是一个比较正常的数字\",{\"1\":{\"497\":1}}],[\"看看jdk是如何使用分割迭代器来构造流源的\",{\"1\":{\"1621\":1}}],[\"看看当前的mysql版本是否支持\",{\"1\":{\"431\":1}}],[\"看看生产的慢sql情况\",{\"1\":{\"430\":1}}],[\"看看sql的执行计划\",{\"1\":{\"361\":1}}],[\"看到这里还是比较难以理解的\",{\"1\":{\"1615\":1}}],[\"看到这里我们就明白了\",{\"1\":{\"1613\":1,\"1622\":1}}],[\"看到这条语句的command列显示的却是killed\",{\"1\":{\"480\":1}}],[\"看到属性中定义的顺序来进行确认\",{\"1\":{\"966\":1}}],[\"看到\",{\"1\":{\"446\":1}}],[\"看到mysql需要扫描多少行和实际需要使用的行数需要先去理解这个查询背后的逻辑和思想\",{\"1\":{\"390\":1}}],[\"看到一个索引的基数\",{\"1\":{\"347\":1}}],[\"案例\",{\"1\":{\"361\":1,\"370\":1,\"371\":1,\"372\":1,\"429\":1}}],[\"假如我们要对一个字符串数据按照首字母进行排序\",{\"1\":{\"1614\":1}}],[\"假如是10\",{\"1\":{\"556\":1}}],[\"假如有人中午12点删了一个库\",{\"1\":{\"485\":1}}],[\"假如一个表有10万行记录\",{\"1\":{\"359\":1}}],[\"假设容量为2的n次幂的化\",{\"1\":{\"1548\":1}}],[\"假设此刻另一个线程\",{\"1\":{\"1498\":1}}],[\"假设此时同时有另外一个顾客c要在影院b买票\",{\"1\":{\"443\":1}}],[\"假设一系列的连续操作都会对同一个对象反复加锁及解锁\",{\"1\":{\"1486\":1}}],[\"假设一个mysql实例的tps是每秒50万\",{\"1\":{\"497\":1}}],[\"假设一个日志盘的io利用率已经是100\",{\"1\":{\"478\":1}}],[\"假设一个事务更新了表t1和t2中的各一行\",{\"1\":{\"460\":1}}],[\"假设一个事务a执行到一半\",{\"1\":{\"451\":1}}],[\"假设一个值从1被顺序改成了2\",{\"1\":{\"434\":1}}],[\"假设一个业务的更新模式是写入之后马上会做查询\",{\"1\":{\"344\":1}}],[\"假设该class计数器继续增长\",{\"1\":{\"1485\":1}}],[\"假设<property\",{\"1\":{\"1003\":1}}],[\"假设使用idx\",{\"1\":{\"555\":2}}],[\"假设使用s1表作为驱动表\",{\"1\":{\"554\":1}}],[\"假设又来了事务2修改person表的同一条记录\",{\"1\":{\"542\":1}}],[\"假设account表里的数据如下\",{\"1\":{\"536\":1}}],[\"假设xid是a\",{\"1\":{\"496\":1}}],[\"假设数据库的binlog\",{\"1\":{\"492\":1}}],[\"假设数据表t中只有一列\",{\"1\":{\"433\":1}}],[\"假设事务a申请到了id=2\",{\"1\":{\"491\":1}}],[\"假设某次要插入的值是x\",{\"1\":{\"491\":1}}],[\"假设误操作命令的gtid是gtid1\",{\"1\":{\"485\":1}}],[\"假设已经开启了redo\",{\"1\":{\"479\":1}}],[\"假设trx2是一个超大事务\",{\"1\":{\"464\":1}}],[\"假设了三组事务在主库的执行情况\",{\"1\":{\"464\":1}}],[\"假设hash\",{\"1\":{\"461\":1}}],[\"假设在t这个时刻\",{\"1\":{\"467\":1}}],[\"假设在上图的基础上\",{\"1\":{\"461\":1}}],[\"假设在redo\",{\"1\":{\"327\":1}}],[\"假设主库a和备库b的主备延迟是30分钟\",{\"1\":{\"459\":1}}],[\"假设binlog的格式设置为mixed\",{\"1\":{\"454\":1}}],[\"假设时序图如下\",{\"1\":{\"447\":1}}],[\"假设执行的场景序列如下\",{\"1\":{\"446\":1}}],[\"假设执行的查询语句是select\",{\"1\":{\"342\":1}}],[\"假设in语句20000个参数的话\",{\"1\":{\"553\":1}}],[\"假设index\",{\"1\":{\"377\":1}}],[\"假设id是表t的主键\",{\"1\":{\"443\":1}}],[\"假设4个id分别是1\",{\"1\":{\"422\":1}}],[\"假设有这样一个流\",{\"1\":{\"1610\":1}}],[\"假设有以下场景\",{\"1\":{\"492\":1}}],[\"假设有两个并行执行的事务\",{\"1\":{\"491\":1}}],[\"假设有如下bean\",{\"1\":{\"1638\":1}}],[\"假设有如下场景\",{\"1\":{\"476\":1}}],[\"假设有如下数据结构\",{\"1\":{\"417\":1}}],[\"假设有1000个并发线程要同时更新同一行\",{\"1\":{\"444\":1}}],[\"假设有一个类\",{\"1\":{\"1607\":1}}],[\"假设有一个表t\",{\"1\":{\"459\":1}}],[\"假设有一个英语学习app\",{\"1\":{\"419\":1}}],[\"假设有一个站内搜索的功能\",{\"1\":{\"300\":1}}],[\"假设有一张这样的表t\",{\"1\":{\"317\":1}}],[\"假设小表的行数是n\",{\"1\":{\"403\":1}}],[\"假设驱动表的行数是n\",{\"1\":{\"401\":1}}],[\"假设驱动表trade\",{\"1\":{\"368\":1}}],[\"假设被驱动表的行数是m\",{\"1\":{\"401\":1}}],[\"假设不使用join\",{\"1\":{\"401\":1}}],[\"假设表t里面已经有了\",{\"1\":{\"491\":1}}],[\"假设表t中现在有10000条记录\",{\"1\":{\"396\":1}}],[\"假设表中确实有一个唯一的字段\",{\"1\":{\"335\":1}}],[\"假设系统里面还有另外一张表trade\",{\"1\":{\"368\":1}}],[\"假设要实现一个电影票在线交易业务\",{\"1\":{\"443\":1}}],[\"假设要查询城市是\",{\"1\":{\"353\":1}}],[\"假设要执行select\",{\"1\":{\"345\":1}}],[\"假设维护的数据库是同一个市的公民信息系统\",{\"1\":{\"352\":1}}],[\"假设\",{\"1\":{\"349\":1,\"462\":1,\"468\":1,\"485\":1}}],[\"假设这里l6\",{\"1\":{\"350\":1}}],[\"假设这张表上包含了10万行的数据\",{\"1\":{\"346\":1}}],[\"假设这个互相转换的界限都是8\",{\"1\":{\"1363\":1}}],[\"假设这个库是一天一备\",{\"1\":{\"485\":1}}],[\"假设这个市民表的定义如下\",{\"1\":{\"338\":1}}],[\"假设这个时候要查id\",{\"1\":{\"332\":1}}],[\"假设现在主库上有其他的数据表有大量的更新\",{\"1\":{\"459\":1}}],[\"假设现在已经记录了从2016年初到2018年底的所有数据\",{\"1\":{\"366\":1}}],[\"假设现在维护的是一个交易系统\",{\"1\":{\"366\":1}}],[\"假设现在维护着一个身份证信息和姓名的表\",{\"1\":{\"332\":1}}],[\"假设现在的需求是检索出表中\",{\"1\":{\"340\":1}}],[\"假设我们要实现与这样的sql语句相同的功能\",{\"1\":{\"1613\":1}}],[\"假设我们要对一个集合中的元素提取出单词并去重\",{\"1\":{\"1609\":1}}],[\"假设我们要查询的语句如下\",{\"1\":{\"351\":1}}],[\"假设我们所使用的哈希算法就是简单的用key\",{\"1\":{\"1550\":1}}],[\"假设我们采用线程池+future的方案\",{\"1\":{\"1517\":1}}],[\"假设我们设置innodb\",{\"1\":{\"476\":1}}],[\"假设我们给扫描过程中碰到的所有行都加上写锁\",{\"1\":{\"447\":1}}],[\"假设我们的表结构如下\",{\"1\":{\"419\":1}}],[\"假设我们执行如下语句\",{\"1\":{\"412\":1,\"413\":1}}],[\"假设我们执行这样一条sql语句\",{\"1\":{\"367\":1}}],[\"假设我们有一个主键列为id的表\",{\"1\":{\"335\":1}}],[\"假设我们搜索关键词\",{\"1\":{\"300\":1}}],[\"频繁地互斥同步操作也会导致不必要的性能损耗\",{\"1\":{\"1486\":1}}],[\"频繁更新的字段不适合创建索引\",{\"1\":{\"359\":1}}],[\"频繁作为查询条件的字段应该创建索引\",{\"1\":{\"358\":1}}],[\"经典垃圾收集器\",{\"0\":{\"1723\":1}}],[\"经历过完整生命周期的bean对象\",{\"1\":{\"1649\":1}}],[\"经度和纬度\",{\"1\":{\"1280\":1}}],[\"经度\",{\"1\":{\"576\":1}}],[\"经过观察可以发现\",{\"1\":{\"1550\":1}}],[\"经过研究发现\",{\"1\":{\"1485\":1}}],[\"经过full\",{\"1\":{\"1436\":1}}],[\"经过流式计算形成一些可视化的结果\",{\"1\":{\"1310\":1}}],[\"经过分析不难发现\",{\"1\":{\"447\":1}}],[\"经过t4时刻\",{\"1\":{\"447\":1}}],[\"经过t2时刻\",{\"1\":{\"447\":1}}],[\"经过t1时刻\",{\"1\":{\"447\":1}}],[\"经过了分析器\",{\"1\":{\"321\":1,\"514\":1}}],[\"经常被缩写为cow\",{\"1\":{\"1527\":1}}],[\"经常变动的信息\",{\"1\":{\"573\":1}}],[\"经常可能需要计算一个表中\",{\"1\":{\"395\":1}}],[\"经常增删改的表\",{\"1\":{\"359\":1}}],[\"前端有三大基础技术\",{\"1\":{\"1977\":1}}],[\"前\",{\"1\":{\"1657\":1}}],[\"前者牺牲了服务调用的性能\",{\"1\":{\"1306\":1}}],[\"前者称为主节点\",{\"1\":{\"606\":1}}],[\"前提是pipeline执行的指令之间没有因果相关性\",{\"1\":{\"1298\":1}}],[\"前台控件的访问权限\",{\"1\":{\"1199\":1}}],[\"前一个表指explain中id值比当前表id值小的表\",{\"1\":{\"506\":1}}],[\"前三种最为常见\",{\"1\":{\"1248\":1}}],[\"前三个session中的sleep\",{\"1\":{\"476\":1}}],[\"前三条语句的作用\",{\"1\":{\"468\":1}}],[\"前四个参数分别代表了a\",{\"1\":{\"467\":1}}],[\"前面学的越好\",{\"1\":{\"1969\":1}}],[\"前面提到过hashmap的数据结构是数组和链表的结合\",{\"1\":{\"1548\":1}}],[\"前面我们介绍过的supplier函数式接口其中一个很重要的应用就是构造方法引用\",{\"1\":{\"1606\":1}}],[\"前面我们提到过\",{\"1\":{\"1595\":1}}],[\"前面我们提到两个成本常数\",{\"1\":{\"557\":1}}],[\"前面我们了解了一些关于索引的理论知识\",{\"1\":{\"357\":1}}],[\"前面说过\",{\"1\":{\"553\":1}}],[\"前面的小节中我们介绍过mysql主备流程图\",{\"1\":{\"460\":1}}],[\"前后的begin和commit是一样的\",{\"1\":{\"454\":1}}],[\"前缀\",{\"1\":{\"1479\":1}}],[\"前缀模式\",{\"1\":{\"900\":1}}],[\"前缀sum\",{\"1\":{\"479\":1}}],[\"前缀是\",{\"1\":{\"412\":1}}],[\"前缀索引除了可能会增加扫描行数\",{\"1\":{\"351\":1}}],[\"前缀索引与覆盖索引\",{\"0\":{\"351\":1}}],[\"前缀索引很可能会损失区分度\",{\"1\":{\"350\":1}}],[\"前缀索引也可能会增加额外的记录扫描次数\",{\"1\":{\"350\":1}}],[\"前缀索引\",{\"0\":{\"350\":1}}],[\"前两个参数的作用是启用mrr\",{\"1\":{\"405\":1}}],[\"性能监控\",{\"0\":{\"1770\":1}}],[\"性能较低\",{\"1\":{\"1483\":1}}],[\"性能提升明显\",{\"1\":{\"1480\":1}}],[\"性能非常好\",{\"1\":{\"1327\":1}}],[\"性能高与业务无关\",{\"1\":{\"1288\":1}}],[\"性能也提高了\",{\"1\":{\"1194\":1}}],[\"性能也更好\",{\"1\":{\"403\":1}}],[\"性能场景\",{\"0\":{\"747\":1}}],[\"性能\",{\"0\":{\"652\":1},\"1\":{\"1509\":1}}],[\"性能很高\",{\"1\":{\"526\":1}}],[\"性能会下降10\",{\"1\":{\"479\":1}}],[\"性能相对较差\",{\"1\":{\"404\":1}}],[\"性能比强行拆成多个单表执行sql语句的性能要好\",{\"1\":{\"401\":1}}],[\"性能上会快很多\",{\"1\":{\"356\":1}}],[\"性能自然也受收到影响\",{\"1\":{\"335\":1}}],[\"让线程2进行resize\",{\"1\":{\"1551\":1}}],[\"让高峰期塞队列的速度慢点\",{\"1\":{\"1536\":1}}],[\"让出cpu给别的线程执行时间\",{\"1\":{\"1520\":1}}],[\"让更多的线程参与执行\",{\"1\":{\"1514\":1}}],[\"让它们关联同一个guardedobject\",{\"1\":{\"1530\":1}}],[\"让它们支持并发\",{\"1\":{\"1483\":1}}],[\"让它们切换主机\",{\"1\":{\"620\":1}}],[\"让变量\",{\"1\":{\"1406\":1}}],[\"让这些进程都来竞争锁的资源\",{\"1\":{\"1288\":1}}],[\"让这些从库来分担读的压力\",{\"1\":{\"457\":1}}],[\"让sharding对应的replica\",{\"1\":{\"1257\":1}}],[\"让字段名的别名和实体类的属性名一致\",{\"1\":{\"1211\":1}}],[\"让缓存失效的时间点尽量均匀\",{\"1\":{\"633\":1}}],[\"让缓存的效率更高\",{\"1\":{\"394\":1}}],[\"让redis服务器返回监控其运行状态\",{\"1\":{\"620\":1}}],[\"让优化器尽可能的更倾向于使用索引完成排序而不是filesort\",{\"1\":{\"557\":1}}],[\"让优化器选择全字段排序\",{\"1\":{\"520\":1}}],[\"让优化器选择使用双路排序算法\",{\"1\":{\"520\":1}}],[\"让他们在同一个事务里面操作\",{\"1\":{\"526\":1}}],[\"让global\",{\"1\":{\"496\":1}}],[\"让原库的批量插入数据语句\",{\"1\":{\"492\":1}}],[\"让一个库的自增id多是奇数\",{\"1\":{\"491\":1}}],[\"让主库提交得慢些\",{\"1\":{\"465\":1}}],[\"让外部系统提供统计类查询的能力\",{\"1\":{\"457\":1}}],[\"让其它事务得以继续执行\",{\"1\":{\"444\":1}}],[\"让表t1和tmp\",{\"1\":{\"407\":1}}],[\"让mysql优化器能够以更优化的方式去执行这个查询\",{\"1\":{\"390\":1}}],[\"让mysql换成另外一种算法\",{\"1\":{\"355\":1}}],[\"让我们从最简单的情形开始\",{\"1\":{\"317\":1}}],[\"另有一种是传递引用\",{\"1\":{\"1593\":1}}],[\"另起一个后台线程\",{\"1\":{\"1287\":1}}],[\"另外是由于lambda表达式中的类型判断是需要结合具体的上下文的\",{\"1\":{\"1620\":1}}],[\"另外如果中间结果容器和最终结果的结果容器类型相同\",{\"1\":{\"1617\":1}}],[\"另外如果原sql是order\",{\"1\":{\"522\":1}}],[\"另外es也有很强大的计算能力\",{\"1\":{\"1254\":1}}],[\"另外关于es的使用场景\",{\"1\":{\"1254\":1}}],[\"另外在解析静态方法和实例方法的时候\",{\"1\":{\"1183\":1}}],[\"另外一种方案就是线程本地存储模式\",{\"1\":{\"1528\":1}}],[\"另外一些相关的方法在applicationcontextawareprocessor\",{\"1\":{\"1005\":1}}],[\"另外一个行锁\",{\"1\":{\"448\":1}}],[\"另外http协议非常通用\",{\"1\":{\"637\":1}}],[\"另外整型的存储空间也比较小\",{\"1\":{\"505\":1}}],[\"另外建议使用这些命令时结合|和more使用\",{\"1\":{\"429\":1}}],[\"另外\",{\"1\":{\"354\":1,\"394\":1,\"424\":1,\"426\":1,\"464\":1,\"472\":1,\"1226\":1,\"1326\":1,\"1509\":1,\"1641\":1}}],[\"另一方面线程占用的内存也比较大\",{\"1\":{\"1533\":1}}],[\"另一方面对访问者增加了验证机制\",{\"1\":{\"1424\":1}}],[\"另一方面\",{\"1\":{\"1208\":1,\"1474\":1}}],[\"另一方式时\",{\"1\":{\"467\":1}}],[\"另一好处是\",{\"1\":{\"497\":1}}],[\"另一类情况是\",{\"1\":{\"481\":1}}],[\"另一类表级的锁是mdl\",{\"1\":{\"441\":1}}],[\"另一种是激活状态\",{\"1\":{\"1623\":1}}],[\"另一种是利用上下文切换\",{\"1\":{\"1473\":1}}],[\"另一种是使用三级缓存\",{\"1\":{\"1237\":1}}],[\"另一种是不读缓存\",{\"1\":{\"482\":1}}],[\"另一种比较典型的大事务场景\",{\"1\":{\"457\":1}}],[\"另一种方法是控制并发度\",{\"1\":{\"444\":1}}],[\"另一种策略是\",{\"1\":{\"444\":1}}],[\"另一个foreach方法是在referencepipeline当中\",{\"1\":{\"1622\":1}}],[\"另一个线程可能会进一步的分割\",{\"1\":{\"1620\":1}}],[\"另一个线程修改了我们的值\",{\"1\":{\"581\":1}}],[\"另一个用于写入操作\",{\"1\":{\"1498\":1}}],[\"另一个库的自增id都是偶数\",{\"1\":{\"491\":1}}],[\"另一个箭头代表的是备库上sql\",{\"1\":{\"460\":1}}],[\"另一个是仅检查线程的中断状态也是不够的\",{\"1\":{\"1524\":1}}],[\"另一个是无法指令唤醒的线程具体是哪一个\",{\"1\":{\"1477\":1}}],[\"另一个是共用mdl锁\",{\"1\":{\"426\":1}}],[\"另一个是整型\",{\"1\":{\"420\":1}}],[\"另一个产品目录的索引\",{\"1\":{\"303\":1}}],[\"另一块是引擎层\",{\"1\":{\"325\":1}}],[\"外\",{\"1\":{\"555\":2}}],[\"外部普通java对象\",{\"1\":{\"976\":1}}],[\"外部化属性类型转换\",{\"1\":{\"1081\":1}}],[\"外部化属性配置\",{\"1\":{\"920\":1}}],[\"外部化配置元信息\",{\"1\":{\"1017\":1}}],[\"外部化配置的示例\",{\"1\":{\"978\":1}}],[\"外部化配置作为依赖来源示例\",{\"1\":{\"978\":1}}],[\"外部化配置作为依赖来源\",{\"0\":{\"978\":1}}],[\"外部化配置以及profiles\",{\"1\":{\"945\":1}}],[\"外部化配置\",{\"0\":{\"1872\":1},\"1\":{\"907\":1,\"1035\":1}}],[\"外部检测天然有一个问题\",{\"1\":{\"478\":1}}],[\"外部排序一般使用归并排序算法\",{\"1\":{\"354\":1}}],[\"外键约束\",{\"1\":{\"465\":1}}],[\"外键关系建立索引\",{\"1\":{\"358\":1}}],[\"外层select将被标记为derived\",{\"1\":{\"330\":1}}],[\"输入类型是t\",{\"1\":{\"1618\":1}}],[\"输入你想说的话\",{\"1\":{\"1573\":1,\"1574\":1,\"1575\":1}}],[\"输入的exchange\",{\"1\":{\"1479\":1}}],[\"输入是\",{\"1\":{\"1479\":1}}],[\"输入是读写描述符列表read\",{\"1\":{\"603\":1}}],[\"输入流\",{\"1\":{\"1038\":1}}],[\"输入前缀\",{\"1\":{\"482\":1}}],[\"输出种类\",{\"1\":{\"1623\":1}}],[\"输出是\",{\"1\":{\"1479\":1}}],[\"输出是与之对应的可读可写事件\",{\"1\":{\"603\":1}}],[\"输出的eax是\",{\"1\":{\"1479\":1}}],[\"输出user定义的方法\",{\"1\":{\"1075\":1}}],[\"输出user\",{\"1\":{\"1072\":2}}],[\"输出所有的错误文案\",{\"1\":{\"1064\":1}}],[\"输出superuser\",{\"1\":{\"961\":2}}],[\"输出\",{\"1\":{\"354\":1,\"421\":1,\"961\":7}}],[\"输完命令之后\",{\"1\":{\"318\":1}}],[\"建议用date数据类型来保存日期\",{\"1\":{\"529\":1}}],[\"建议使用groupingbyconcurrent\",{\"1\":{\"1618\":1}}],[\"建议使用treemap\",{\"1\":{\"1544\":1}}],[\"建议使用tinyint代替enum\",{\"1\":{\"528\":1}}],[\"建议使用concurrenthashmap\",{\"1\":{\"1544\":1,\"1555\":1}}],[\"建议使用它的替换实现resolvabletype\",{\"1\":{\"1101\":1}}],[\"建议使用整形类型来运算和存储实数\",{\"1\":{\"528\":1}}],[\"建议指定为unsigned无符号类型\",{\"1\":{\"528\":1}}],[\"建议\",{\"1\":{\"528\":1,\"529\":1,\"530\":1,\"1270\":1}}],[\"建表sql\",{\"1\":{\"534\":1}}],[\"建表\",{\"1\":{\"437\":1}}],[\"建表语法是create\",{\"1\":{\"409\":1,\"410\":1}}],[\"建表语句如下\",{\"1\":{\"353\":1,\"366\":1}}],[\"建立连接\",{\"0\":{\"1932\":1}}],[\"建立连接的过程通常是比较复杂的\",{\"1\":{\"318\":1}}],[\"建立内存文件映射\",{\"1\":{\"1587\":1}}],[\"建立tcp连接\",{\"1\":{\"1425\":1}}],[\"建立一个session对象\",{\"1\":{\"1200\":1}}],[\"建立一个关键词与文章的对应关系表\",{\"1\":{\"300\":1}}],[\"建立主备关系\",{\"1\":{\"485\":1}}],[\"函数指针\",{\"1\":{\"1602\":1}}],[\"函数返回\",{\"1\":{\"1569\":1}}],[\"函数就可以返回\",{\"1\":{\"1565\":1}}],[\"函数式的方式\",{\"1\":{\"1620\":1}}],[\"函数式编程又指的是什么\",{\"1\":{\"1607\":1}}],[\"函数式编程必须依附这样一类特殊的对象\",{\"1\":{\"1595\":1}}],[\"函数式编程与传统的编码方式相比最明显的区别就是\",{\"1\":{\"1593\":1}}],[\"函数式编程的意义\",{\"0\":{\"1591\":1}}],[\"函数式编程的基础是不可变性\",{\"1\":{\"1527\":1}}],[\"函数式编程概览\",{\"0\":{\"1590\":1}}],[\"函数式接口扩展\",{\"0\":{\"1601\":1}}],[\"函数式接口定义\",{\"0\":{\"1594\":1}}],[\"函数式接口是函数式编程中最重要的概念\",{\"1\":{\"1593\":1}}],[\"函数式接口\",{\"1\":{\"943\":1,\"1349\":1,\"1593\":2,\"1595\":1}}],[\"函数会创建父进程的一个完整副本\",{\"1\":{\"1527\":1}}],[\"函数库在多线程的环境中被调用时\",{\"1\":{\"1376\":1}}],[\"函数接口\",{\"1\":{\"899\":1}}],[\"函数驱动\",{\"1\":{\"899\":1}}],[\"函数来获取当前主库的系统时间\",{\"1\":{\"457\":1}}],[\"函数的参数是一个函数\",{\"1\":{\"1593\":1}}],[\"函数的返回时间\",{\"1\":{\"454\":1}}],[\"函数的话\",{\"1\":{\"366\":1}}],[\"函数生成一个大于0小于1的随机小数\",{\"1\":{\"420\":1}}],[\"函数对应的值\",{\"1\":{\"366\":1}}],[\"函数操作\",{\"0\":{\"366\":1},\"1\":{\"366\":1}}],[\"函数\",{\"1\":{\"352\":1,\"368\":1,\"369\":1}}],[\"函数得到的结果可能是相同的\",{\"1\":{\"352\":1}}],[\"哈希算法基本步骤就是三步\",{\"1\":{\"1548\":1}}],[\"哈希桶数组table的长度length大小必须为2n\",{\"1\":{\"1546\":1}}],[\"哈希碰撞的概率就越小\",{\"1\":{\"1546\":1}}],[\"哈希冲突的问题\",{\"1\":{\"1475\":1}}],[\"哈希\",{\"0\":{\"573\":1},\"1\":{\"1280\":1}}],[\"哈希字段的方式也只能支持等值查询\",{\"1\":{\"352\":1}}],[\"哈希表为解决冲突\",{\"1\":{\"1546\":1}}],[\"哈希表的key就必须是\",{\"1\":{\"462\":1}}],[\"哈希表的key是\",{\"1\":{\"461\":1}}],[\"哈希表这种结构适用于只有等值查询的场景\",{\"1\":{\"332\":1}}],[\"哈希表是一种以键\",{\"1\":{\"332\":1}}],[\"哈希表\",{\"0\":{\"332\":1},\"1\":{\"331\":1,\"568\":1,\"1265\":1}}],[\"倒序方式每次写和读的时候\",{\"1\":{\"352\":1}}],[\"倒序存储方式使用4个字节的前缀长度应该是不够的\",{\"1\":{\"352\":1}}],[\"倒序存储方式在主键索引上\",{\"1\":{\"352\":1}}],[\"倒序存储的字段上创建的索引是按照倒序字符串的方式排序的\",{\"1\":{\"352\":1}}],[\"倒序存储是指如果存储身份证号码的时候把它倒过来存\",{\"1\":{\"352\":1}}],[\"倒序存储和使用哈希字段\",{\"1\":{\"352\":1}}],[\"倒排列表\",{\"1\":{\"308\":1}}],[\"倒排索引的相关配置\",{\"1\":{\"309\":1}}],[\"倒排索引项\",{\"1\":{\"308\":1}}],[\"倒排索引则是数据对应到主键\",{\"1\":{\"300\":1}}],[\"倒排索引\",{\"0\":{\"300\":1},\"1\":{\"1252\":1}}],[\"才将一系列的sink有机的串联了起来\",{\"1\":{\"1623\":1}}],[\"才将其发到从库上\",{\"1\":{\"470\":1}}],[\"才会对元数据的计算才会真正的进行执行\",{\"1\":{\"1619\":1}}],[\"才会真正的执行\",{\"1\":{\"1610\":1}}],[\"才会发挥其特性\",{\"1\":{\"1593\":1}}],[\"才会判断当前任务是否大于maxpoolsize\",{\"1\":{\"1410\":1}}],[\"才会根据泛型的具体化进行依赖查找\",{\"1\":{\"1181\":1}}],[\"才会向mysql申请事务id\",{\"1\":{\"542\":1}}],[\"才会被删除\",{\"1\":{\"434\":1}}],[\"才只保证了自增id是递增的\",{\"1\":{\"491\":1}}],[\"才有了\",{\"1\":{\"490\":1}}],[\"才有可能发现为你\",{\"1\":{\"478\":1}}],[\"才断开了session\",{\"1\":{\"481\":1}}],[\"才开始进入语句终止逻辑\",{\"1\":{\"481\":1}}],[\"才是在实际应用中使用的最多的\",{\"1\":{\"1609\":1}}],[\"才是所谓的并发查询\",{\"1\":{\"476\":1}}],[\"才是将数据持久化到磁盘的操作\",{\"1\":{\"450\":1}}],[\"才可以使用方法引用\",{\"1\":{\"1603\":1}}],[\"才可以用的上零拷贝\",{\"1\":{\"1588\":1}}],[\"才可以设置slave\",{\"1\":{\"467\":1}}],[\"才可以这么做\",{\"1\":{\"348\":1}}],[\"才不会备库同步线程停止\",{\"1\":{\"413\":1}}],[\"才能效率最高\",{\"1\":{\"1612\":1}}],[\"才能lambda表达式真正的含义\",{\"1\":{\"1593\":1}}],[\"才能让mysql拥有较高的并发能力\",{\"1\":{\"543\":1}}],[\"才能避免整个系统锁死\",{\"1\":{\"476\":1}}],[\"才能给客户端返回\",{\"1\":{\"472\":1}}],[\"才能切换\",{\"1\":{\"459\":1}}],[\"才能继续执行\",{\"1\":{\"433\":1}}],[\"才能体现出\",{\"1\":{\"404\":1}}],[\"才能够满足区分度的要求\",{\"1\":{\"352\":1}}],[\"相信我\",{\"1\":{\"1972\":1}}],[\"相等再执行传入的比较器\",{\"1\":{\"1614\":1}}],[\"相等会返回0\",{\"1\":{\"1603\":1}}],[\"相反\",{\"1\":{\"1509\":1,\"1546\":1,\"1620\":1}}],[\"相较于永久代\",{\"1\":{\"1457\":1}}],[\"相较于缓存穿透\",{\"1\":{\"629\":1}}],[\"相应的segment对象块是被锁住的\",{\"1\":{\"1553\":1}}],[\"相应的源代码\",{\"1\":{\"1166\":1,\"1167\":1,\"1168\":1,\"1170\":1,\"1171\":1,\"1172\":1,\"1173\":1,\"1174\":1,\"1175\":1}}],[\"相应的源码在abstractautowirecapablebeanfactory\",{\"1\":{\"1007\":1}}],[\"相应地\",{\"1\":{\"465\":1}}],[\"相对而言就比较复杂\",{\"1\":{\"1550\":1}}],[\"相对使用数组实现的阻塞队列\",{\"1\":{\"1509\":1}}],[\"相对线程安全类对于单独的操作可以是线程安全的\",{\"1\":{\"1391\":1}}],[\"相对线程安全\",{\"1\":{\"1391\":1}}],[\"相对便利\",{\"1\":{\"911\":1}}],[\"相对繁琐\",{\"1\":{\"911\":1}}],[\"相对于iterator\",{\"1\":{\"1620\":1}}],[\"相对于select和poll来说\",{\"1\":{\"1571\":1}}],[\"相对于只有一把锁的arrayblockingqueue性能会更好\",{\"1\":{\"1509\":1}}],[\"相对于数据文件来说\",{\"1\":{\"593\":1}}],[\"相对于用户分表来说\",{\"1\":{\"426\":1}}],[\"相关证书\",{\"1\":{\"1966\":1}}],[\"相关说明\",{\"1\":{\"1620\":2,\"1622\":1}}],[\"相关代码示例\",{\"1\":{\"1412\":1}}],[\"相关方法\",{\"1\":{\"1100\":3}}],[\"相关生命周期\",{\"1\":{\"1071\":1}}],[\"相关核心代码在propertiesbeandefinitionreader\",{\"1\":{\"1022\":1}}],[\"相关的逻辑在\",{\"1\":{\"1183\":1}}],[\"相关的源代码\",{\"1\":{\"1162\":1,\"1164\":1,\"1165\":1}}],[\"相关的源码的实现在abstractautowirecapablebeanfactory\",{\"1\":{\"1006\":1}}],[\"相关的核心源代码\",{\"1\":{\"1151\":1,\"1152\":1}}],[\"相关的代码实现\",{\"1\":{\"1055\":1}}],[\"相关的示例如下\",{\"1\":{\"1091\":1}}],[\"相关的示例代码\",{\"1\":{\"1072\":1,\"1182\":1}}],[\"相关的示例\",{\"1\":{\"997\":1,\"1029\":1,\"1043\":1,\"1044\":1,\"1072\":1,\"1084\":1,\"1099\":1,\"1100\":1,\"1112\":1,\"1113\":1,\"1120\":1,\"1148\":1,\"1149\":1,\"1157\":1,\"1387\":1}}],[\"相关的示例实际上在之前就已经提到过了\",{\"1\":{\"941\":1}}],[\"相关的演示示例\",{\"1\":{\"994\":1}}],[\"相关示例代码\",{\"1\":{\"1388\":1}}],[\"相关示例\",{\"0\":{\"683\":1},\"1\":{\"943\":1}}],[\"相关性\",{\"1\":{\"301\":1}}],[\"相当于beanfactorytransactionattributesourceadvisor中的advice\",{\"1\":{\"1655\":1}}],[\"相当于beanfactorytransactionattributesourceadvisor中的pointcut\",{\"1\":{\"1655\":1}}],[\"相当于每个mapper对应一个factorybean\",{\"1\":{\"1653\":1}}],[\"相当于\",{\"1\":{\"1554\":1}}],[\"相当于舍弃了高位\",{\"1\":{\"1548\":1}}],[\"相当于某一类型bean依赖查找代理对象\",{\"1\":{\"1181\":1}}],[\"相当于getversion\",{\"1\":{\"581\":1}}],[\"相当于乐观锁加锁\",{\"1\":{\"581\":1}}],[\"相当于又把节点b新生成的binlog拿过来执行了一次\",{\"1\":{\"455\":1}}],[\"相同的元会提供两个或多个流管道\",{\"1\":{\"1619\":1}}],[\"相同的方式\",{\"1\":{\"1601\":1}}],[\"相同的线程可以直接进入已经获取锁的同步代码块\",{\"1\":{\"1398\":1}}],[\"相同的数据页能放下的索引值就越少\",{\"1\":{\"352\":1}}],[\"相同commit\",{\"1\":{\"464\":1}}],[\"相比mmap方式\",{\"1\":{\"1585\":1}}],[\"相比mmap内存映射方式\",{\"1\":{\"1582\":1}}],[\"相比传统方法\",{\"1\":{\"1585\":1}}],[\"相比其他拷贝方式\",{\"1\":{\"1583\":1}}],[\"相比explain多了个partitions字段\",{\"1\":{\"506\":1}}],[\"相比于synchronized\",{\"1\":{\"1494\":1}}],[\"相比于sleep方法\",{\"1\":{\"472\":1}}],[\"相比于磁盘扫描\",{\"1\":{\"525\":1}}],[\"相比于一主一备的切换流程\",{\"1\":{\"466\":1}}],[\"相比于按表和按行分发\",{\"1\":{\"463\":1}}],[\"相比于按表并行分发策略\",{\"1\":{\"462\":1}}],[\"相比于优化前的join语句需要做10亿次条件判断来说\",{\"1\":{\"407\":1}}],[\"相比较而言\",{\"1\":{\"399\":1}}],[\"相比之下\",{\"1\":{\"392\":1}}],[\"相比\",{\"1\":{\"351\":1,\"422\":1}}],[\"找不到再委托上层父加载器加载\",{\"1\":{\"1692\":1}}],[\"找不到的对象就是垃圾\",{\"1\":{\"1437\":1}}],[\"找出所有的切面bean\",{\"1\":{\"1630\":1}}],[\"找出所有可能使用的索引\",{\"0\":{\"547\":1},\"1\":{\"546\":1}}],[\"找出成本最低的那一个\",{\"0\":{\"551\":1},\"1\":{\"546\":1}}],[\"找出第一个不在set\",{\"1\":{\"468\":1}}],[\"找出不小于l\",{\"1\":{\"350\":1}}],[\"找同步位点\",{\"1\":{\"467\":1}}],[\"找到的是多个\",{\"1\":{\"1648\":1}}],[\"找到的第一个是id1\",{\"1\":{\"350\":1}}],[\"找到所有bean\",{\"1\":{\"1648\":1}}],[\"找到需要注入的字段的值\",{\"1\":{\"1648\":1}}],[\"找到被桥接的方法\",{\"1\":{\"1648\":1}}],[\"找到集合中所有大于5或者是偶数的数\",{\"1\":{\"1599\":1}}],[\"找到集合中所有大于5并且是偶数的数\",{\"1\":{\"1599\":1}}],[\"找到集合中所有大于5的数\",{\"1\":{\"1599\":2}}],[\"找到集合中所有小于3的数\",{\"1\":{\"1599\":2}}],[\"找到集合中所有的奇数\",{\"1\":{\"1599\":2}}],[\"找到集合中所有的偶数\",{\"1\":{\"1599\":2}}],[\"找到该class所有正在加锁状态的偏向锁\",{\"1\":{\"1485\":1}}],[\"找到满足expire\",{\"1\":{\"549\":1}}],[\"找到第一个满足city=\",{\"1\":{\"356\":2}}],[\"找到第一个满足条件的记录id3\",{\"1\":{\"340\":1}}],[\"找到user2\",{\"1\":{\"332\":1}}],[\"找到最近的一次全量备份\",{\"1\":{\"327\":1}}],[\"找到对应的文章的主键id\",{\"1\":{\"300\":1}}],[\"依赖管理\",{\"0\":{\"1871\":1}}],[\"依赖底层操作系统的互斥原语mutex\",{\"1\":{\"1483\":1}}],[\"依赖\",{\"1\":{\"1093\":1,\"1163\":1,\"1518\":1}}],[\"依赖bean\",{\"1\":{\"1065\":1}}],[\"依赖于注解驱动\",{\"1\":{\"1007\":1}}],[\"依赖于m和d的值\",{\"1\":{\"528\":2}}],[\"依赖对象\",{\"1\":{\"974\":1}}],[\"依赖来源示例\",{\"1\":{\"973\":1}}],[\"依赖描述符\",{\"1\":{\"963\":1}}],[\"依赖容器api\",{\"1\":{\"911\":1}}],[\"依赖处理的过程\",{\"0\":{\"963\":1}}],[\"依赖处理\",{\"1\":{\"907\":1,\"911\":1}}],[\"依赖查找lifecycle\",{\"1\":{\"1173\":1,\"1174\":1,\"1175\":1}}],[\"依赖查找loadtimeweaveraware\",{\"1\":{\"1171\":1}}],[\"依赖查找environment\",{\"0\":{\"1149\":1}}],[\"依赖查找applicationeventmulticaster\",{\"0\":{\"1121\":1}}],[\"依赖查找的细节可以在abstractapplicationcontext\",{\"1\":{\"1121\":1}}],[\"依赖查找的来源仅限于spring\",{\"1\":{\"980\":1}}],[\"依赖查找的来源\",{\"0\":{\"972\":1}}],[\"依赖查找的示例\",{\"1\":{\"917\":1}}],[\"依赖查找并且创建bean\",{\"1\":{\"953\":1,\"954\":1}}],[\"依赖查找中典型异常\",{\"0\":{\"946\":1}}],[\"依赖查找类型\",{\"1\":{\"944\":1}}],[\"依赖查找简介\",{\"0\":{\"939\":1}}],[\"依赖查找和注入以及bean生命周期等\",{\"1\":{\"938\":1}}],[\"依赖查找和依赖注入的区别\",{\"0\":{\"915\":1}}],[\"依赖查找和依赖注入\",{\"0\":{\"911\":1},\"1\":{\"916\":1}}],[\"依赖查找集合对象\",{\"1\":{\"921\":2}}],[\"依赖查找是主动或手动的依赖查找方式\",{\"1\":{\"915\":1}}],[\"依赖查找\",{\"0\":{\"1182\":1},\"1\":{\"906\":1,\"907\":1,\"909\":1,\"911\":1,\"964\":1,\"974\":2,\"1115\":1,\"1123\":1,\"1125\":1}}],[\"依赖注入源码解析\",{\"0\":{\"1648\":1}}],[\"依赖注入底层实现原理\",{\"1\":{\"1630\":1}}],[\"依赖注入environment\",{\"0\":{\"1148\":1}}],[\"依赖注入注解\",{\"1\":{\"1131\":1}}],[\"依赖注入applicationeventpublisher\",{\"0\":{\"1120\":1}}],[\"依赖注入resourceloader\",{\"0\":{\"1045\":1}}],[\"依赖注入spring\",{\"0\":{\"1044\":1}}],[\"依赖注入和依赖查找的依赖来源是否相同\",{\"0\":{\"980\":1}}],[\"依赖注入的判断条件\",{\"1\":{\"1648\":1}}],[\"依赖注入的来源\",{\"0\":{\"973\":1}}],[\"依赖注入的处理主要就是由以下两个方法来完成的\",{\"1\":{\"963\":1}}],[\"依赖注入的模式和类型\",{\"0\":{\"951\":1}}],[\"依赖注入类型选择\",{\"0\":{\"958\":1}}],[\"依赖注入类型\",{\"1\":{\"951\":2}}],[\"依赖注入\",{\"0\":{\"1150\":1},\"1\":{\"903\":1,\"906\":1,\"907\":1,\"911\":1,\"919\":1,\"964\":1,\"974\":3,\"1115\":2,\"1234\":1}}],[\"依次类推\",{\"1\":{\"1615\":1}}],[\"依次将对象至少划分为新生代和老年代\",{\"1\":{\"1434\":1}}],[\"依次插入autowired\",{\"1\":{\"965\":1}}],[\"依次判断事务t和每个worker队列的冲突关系\",{\"1\":{\"461\":1}}],[\"依次是\",{\"1\":{\"459\":1}}],[\"依次把它们的rowid取出来\",{\"1\":{\"421\":1}}],[\"依次到临时表中取出word值\",{\"1\":{\"420\":1}}],[\"依次到主键id索引中查记录\",{\"1\":{\"404\":1}}],[\"依次取出里面的id的值\",{\"1\":{\"418\":1}}],[\"依次取出叶子节点上id的值\",{\"1\":{\"416\":1}}],[\"依次累加\",{\"1\":{\"417\":1}}],[\"依次选取不同长度的前缀来看这个值\",{\"1\":{\"350\":1}}],[\"依然是\",{\"1\":{\"403\":1}}],[\"依然基于表t\",{\"1\":{\"347\":1}}],[\"时就会触发线程的拒绝策略\",{\"1\":{\"1410\":1}}],[\"时\",{\"1\":{\"350\":1,\"467\":1,\"596\":1,\"1116\":1,\"1210\":2,\"1485\":1,\"1546\":1,\"1582\":1}}],[\"时间紧张的小伙伴可以不用在整合这里花费时间\",{\"1\":{\"1982\":1}}],[\"时间有限的小伙伴\",{\"1\":{\"1969\":1}}],[\"时间单位\",{\"1\":{\"1476\":1}}],[\"时间相关\",{\"1\":{\"1087\":2}}],[\"时间过了之后还是没有任何事件到来\",{\"1\":{\"603\":1}}],[\"时间戳\",{\"1\":{\"529\":1}}],[\"时间值或持续时间\",{\"1\":{\"529\":1}}],[\"时间复杂度近似是n+n\",{\"1\":{\"401\":1}}],[\"时间复杂度为o\",{\"1\":{\"333\":1}}],[\"时间\",{\"1\":{\"317\":1,\"527\":1,\"1485\":1}}],[\"zgc详解\",{\"0\":{\"1674\":1}}],[\"zero\",{\"1\":{\"1550\":1,\"1583\":1,\"1619\":1,\"1621\":1,\"1623\":1}}],[\"zookeeper视频\",{\"1\":{\"1991\":1}}],[\"zookeeper是一个高可用的分布式管理与协调框架\",{\"1\":{\"1991\":1}}],[\"zookeeper集群与watcher监听机制\",{\"0\":{\"1964\":1}}],[\"zookeeper集群leader选举\",{\"0\":{\"1963\":1}}],[\"zookeeper经典应用场景\",{\"0\":{\"1962\":1}}],[\"zookeeper特性与节点数据类型\",{\"0\":{\"1961\":1}}],[\"zookeeper\",{\"0\":{\"1960\":1,\"1991\":1},\"1\":{\"1288\":1}}],[\"zunionstore\",{\"1\":{\"574\":3}}],[\"zinterstore\",{\"1\":{\"574\":3}}],[\"zincrby\",{\"1\":{\"574\":3}}],[\"zrevrank\",{\"1\":{\"574\":4}}],[\"zrevrangebyscore\",{\"1\":{\"574\":2}}],[\"zrevrangebyscorre\",{\"1\":{\"574\":1}}],[\"zrevrangebylex\",{\"1\":{\"574\":3}}],[\"zrevrange\",{\"1\":{\"574\":4}}],[\"zremrangbyrank\",{\"1\":{\"574\":1}}],[\"zremrangebyscore\",{\"1\":{\"574\":3}}],[\"zremrangebyrank\",{\"1\":{\"574\":2}}],[\"zremrangebylex\",{\"1\":{\"574\":3}}],[\"zrem\",{\"1\":{\"574\":3}}],[\"zrangebyscore\",{\"1\":{\"574\":4}}],[\"zrangebylex\",{\"1\":{\"574\":7}}],[\"zrange\",{\"1\":{\"574\":6}}],[\"zrank\",{\"1\":{\"574\":4}}],[\"zlexcount\",{\"1\":{\"574\":4}}],[\"zcount\",{\"1\":{\"574\":4}}],[\"zcard\",{\"1\":{\"574\":3}}],[\"zadd\",{\"1\":{\"574\":3}}],[\"zzz\",{\"1\":{\"519\":1,\"553\":2}}],[\"zh\",{\"1\":{\"1981\":1}}],[\"zhaoliu\",{\"1\":{\"1603\":2,\"1604\":2,\"1605\":1,\"1609\":1,\"1615\":1}}],[\"zhangsan=90\",{\"1\":{\"1613\":1}}],[\"zhangsan=2\",{\"1\":{\"1613\":1}}],[\"zhangsan\",{\"1\":{\"1598\":1,\"1600\":1,\"1603\":2,\"1604\":2,\"1605\":1,\"1609\":1,\"1613\":2,\"1615\":1}}],[\"zhangss\",{\"1\":{\"350\":1}}],[\"zhangssxyz\",{\"1\":{\"350\":3,\"351\":2}}],[\"zhangs\",{\"1\":{\"350\":4}}],[\"zhihu\",{\"1\":{\"1551\":1}}],[\"zhuanlan\",{\"1\":{\"1551\":1}}],[\"zhuge\",{\"1\":{\"518\":1,\"520\":8,\"536\":1}}],[\"z\",{\"1\":{\"417\":4,\"577\":1,\"624\":1}}],[\"zscan\",{\"1\":{\"574\":1}}],[\"zscore\",{\"1\":{\"574\":4}}],[\"zset\",{\"0\":{\"574\":1}}],[\"zs\",{\"1\":{\"330\":1}}],[\"引导类加载器\",{\"1\":{\"1663\":1}}],[\"引导mysql使用我们期望的索引\",{\"1\":{\"348\":1}}],[\"引用\",{\"1\":{\"1623\":1}}],[\"引用扩容前的entry数组\",{\"1\":{\"1550\":1}}],[\"引用的对象\",{\"1\":{\"1438\":1}}],[\"引用个数为0的就认为是垃圾\",{\"1\":{\"1437\":1}}],[\"引用类型\",{\"1\":{\"1435\":1,\"1480\":1}}],[\"引用计数算法\",{\"0\":{\"1714\":1}}],[\"引用计数无法解决循环引用的问题\",{\"1\":{\"1437\":1}}],[\"引用计数法\",{\"1\":{\"1437\":1}}],[\"引用计数\",{\"0\":{\"722\":1}}],[\"引起的死循环问题\",{\"1\":{\"1364\":1}}],[\"引起雪崩\",{\"1\":{\"632\":1}}],[\"引入\",{\"1\":{\"1583\":1}}],[\"引入了\",{\"1\":{\"1584\":1}}],[\"引入了一个系统调用方法\",{\"1\":{\"1582\":1}}],[\"引入了红黑树\",{\"1\":{\"1546\":1}}],[\"引入ｍｑ之后\",{\"1\":{\"1326\":1}}],[\"引入mq\",{\"1\":{\"1287\":1}}],[\"引入布隆过滤器\",{\"1\":{\"1282\":1}}],[\"引擎就会按照上面绿色箭头的路线\",{\"1\":{\"366\":1}}],[\"引擎把刚刚写入的redo\",{\"1\":{\"326\":1}}],[\"引擎将这行新数据更新到内存中\",{\"1\":{\"326\":1}}],[\"引擎直接用树搜索找到这一行\",{\"1\":{\"326\":1}}],[\"既费时\",{\"1\":{\"1607\":1}}],[\"既省去了重新计算hash值得时间\",{\"1\":{\"1550\":1}}],[\"既能提升并发性\",{\"1\":{\"492\":1}}],[\"既可以从表test1里面取出name=jyc记录的id值\",{\"1\":{\"514\":1}}],[\"既可以\",{\"1\":{\"465\":1}}],[\"既可以先从表里面取出c=10的记录的id值\",{\"1\":{\"321\":1}}],[\"既然调用并行流这么方便\",{\"1\":{\"1612\":1}}],[\"既然redis有可能挂掉\",{\"1\":{\"633\":1}}],[\"既然需要启动多个服务\",{\"1\":{\"609\":1}}],[\"既然是树\",{\"1\":{\"549\":1}}],[\"既然预先不知道要申请多少个自增id\",{\"1\":{\"492\":1}}],[\"既然要更新\",{\"1\":{\"478\":1}}],[\"既然备库没有请求\",{\"1\":{\"457\":1}}],[\"既然优化器放弃了使用索引a\",{\"1\":{\"348\":1}}],[\"迁移比较麻烦\",{\"1\":{\"348\":1}}],[\"三色标记算法\",{\"0\":{\"1743\":1}}],[\"三色标记\",{\"1\":{\"1442\":1}}],[\"三次握手的目的是连接服务器指定端口\",{\"1\":{\"1425\":1}}],[\"三次握手和四次挥手\",{\"0\":{\"95\":1,\"1425\":1}}],[\"三级缓存的示意图\",{\"1\":{\"1474\":1}}],[\"三级缓存\",{\"1\":{\"1237\":1}}],[\"三者不可得兼\",{\"1\":{\"1311\":1}}],[\"三者不同方式的执行结果\",{\"1\":{\"933\":1}}],[\"三者的执行顺序\",{\"1\":{\"931\":1}}],[\"三种特殊数据类型\",{\"0\":{\"575\":1}}],[\"三种讨论的判断主备无延迟的逻辑\",{\"1\":{\"472\":1}}],[\"三个单点区间总共需要回表的记录数是58\",{\"1\":{\"549\":1}}],[\"三个并发事务\",{\"1\":{\"451\":1}}],[\"三个会话a\",{\"1\":{\"396\":1}}],[\"三表连接查询sql优化\",{\"1\":{\"363\":1}}],[\"三张表索引分析\",{\"0\":{\"363\":1}}],[\"三是这个语法并不是所有的数据库都支持\",{\"1\":{\"348\":1}}],[\"比这个例子稍微复杂一点的例子\",{\"1\":{\"1618\":1}}],[\"比这个例子稍微复杂一个例子\",{\"1\":{\"1614\":1}}],[\"比起bio我们不需要频繁的创建线程来处理客户端连接\",{\"1\":{\"1574\":1}}],[\"比起bio客户端连接操作时异步的\",{\"1\":{\"1574\":1}}],[\"比起误删数据时候进行处理\",{\"1\":{\"484\":1}}],[\"比\",{\"1\":{\"1548\":1}}],[\"比主库生产binlog的速度要慢\",{\"1\":{\"457\":1}}],[\"比直接join多了100次交互\",{\"1\":{\"401\":1}}],[\"比较出名的有以下四种\",{\"1\":{\"1985\":1}}],[\"比较器也可以进行复合\",{\"1\":{\"1614\":1}}],[\"比较完成之后还是会强转会原来的类型\",{\"1\":{\"1614\":1}}],[\"比较难\",{\"1\":{\"1576\":1}}],[\"比较常用的有\",{\"1\":{\"1520\":1}}],[\"比较常见的场景有以下几种\",{\"1\":{\"481\":1}}],[\"比较常见的是100~1000\",{\"1\":{\"451\":1}}],[\"比较常见的是将其设置为100~1000中的某个数值\",{\"1\":{\"450\":1}}],[\"比较常见的优化方法是\",{\"1\":{\"368\":1}}],[\"比较智能\",{\"1\":{\"1485\":1}}],[\"比较地址\",{\"1\":{\"1367\":1}}],[\"比较容易将热点数据区分出来\",{\"1\":{\"1270\":1}}],[\"比较好扩容\",{\"1\":{\"1270\":1}}],[\"比较好的方案是\",{\"1\":{\"386\":1}}],[\"比较适合做关键字检索\",{\"1\":{\"1252\":1}}],[\"比较典型的例子就是在springboot场景中的springbootapplication\",{\"1\":{\"1135\":1}}],[\"比较项\",{\"1\":{\"595\":1}}],[\"比较耗费时间的是步骤3\",{\"1\":{\"458\":1}}],[\"比原来小了很多\",{\"1\":{\"352\":1}}],[\"比优化器的选择快了40多倍\",{\"1\":{\"348\":1}}],[\"比如服务发现\",{\"1\":{\"1989\":1}}],[\"比如培训机构的课程\",{\"1\":{\"1968\":1}}],[\"比如abstractajpprotocol和abstracthttp11protocol\",{\"1\":{\"1687\":1}}],[\"比如arraylist\",{\"1\":{\"1608\":1}}],[\"比如http11nioprotocol和ajpnioprotocol\",{\"1\":{\"1687\":1}}],[\"比如hash码\",{\"1\":{\"1484\":1}}],[\"比如hashmap\",{\"1\":{\"408\":1}}],[\"比如hadoop这类系统\",{\"1\":{\"457\":1}}],[\"比如java\",{\"1\":{\"1683\":1}}],[\"比如javabeans是ioc的一个容器实现\",{\"1\":{\"914\":1}}],[\"比如jar类包\",{\"1\":{\"1663\":1}}],[\"比如rt\",{\"1\":{\"1663\":1}}],[\"比如redis\",{\"1\":{\"1200\":1}}],[\"比如read方法要传递进去一个参数n\",{\"1\":{\"602\":1}}],[\"比如类名\",{\"1\":{\"1646\":1}}],[\"比如短路\",{\"1\":{\"1623\":1}}],[\"比如汇聚等等\",{\"1\":{\"1623\":1}}],[\"比如过滤\",{\"1\":{\"1623\":1}}],[\"比如过滤掉非法url\",{\"1\":{\"1354\":1}}],[\"比如管理大小的信息\",{\"1\":{\"1623\":1}}],[\"比如int类型的包装类型integer\",{\"1\":{\"1620\":1}}],[\"比如int\",{\"1\":{\"1620\":1}}],[\"比如intstream\",{\"1\":{\"1619\":1}}],[\"比如统计元素个数的estimatesize方法\",{\"1\":{\"1620\":1}}],[\"比如可以帮助对元进行进一步的分割或者对于剩余的元素进行串行的遍历\",{\"1\":{\"1620\":1}}],[\"比如可以配置一组4个文件\",{\"1\":{\"324\":1}}],[\"比如ordered\",{\"1\":{\"1620\":1}}],[\"比如从files\",{\"1\":{\"1619\":1}}],[\"比如lambda表达式\",{\"1\":{\"1619\":1}}],[\"比如linkedblockingqueue\",{\"1\":{\"1509\":1}}],[\"比如刚才的widgets\",{\"1\":{\"1619\":1}}],[\"比如concurrenthashmap\",{\"1\":{\"1619\":1}}],[\"比如count\",{\"1\":{\"1619\":1}}],[\"比如collector\",{\"1\":{\"1615\":1}}],[\"比如collection\",{\"1\":{\"1089\":1,\"1619\":1}}],[\"比如文件\",{\"1\":{\"1619\":1}}],[\"比如要根据城市的名字对城市中每个人的姓进行分组\",{\"1\":{\"1618\":1}}],[\"比如要保存的是2017年某个城市的所有人口信息\",{\"1\":{\"333\":1}}],[\"比如set\",{\"1\":{\"1617\":1}}],[\"比如stream\",{\"1\":{\"1615\":1}}],[\"比如string\",{\"1\":{\"952\":1}}],[\"比如摘要\",{\"1\":{\"1616\":1}}],[\"比如你可以使用下面的方式将widget累积到treeset当中\",{\"1\":{\"1615\":1}}],[\"比如你执行下面的语句\",{\"1\":{\"514\":1}}],[\"比如无序的collector它累积元素到一个list当中\",{\"1\":{\"1615\":1}}],[\"比如计算卖方交易数量的最大值\",{\"1\":{\"1615\":1}}],[\"比如将元素累积到一个集合当中\",{\"1\":{\"1616\":1}}],[\"比如将集合中的元素添加到collection当中\",{\"1\":{\"1615\":1}}],[\"比如将n设置为3600\",{\"1\":{\"486\":1}}],[\"比如现根据名称排序\",{\"1\":{\"1614\":1}}],[\"比如filter\",{\"1\":{\"1619\":1}}],[\"比如f\",{\"1\":{\"1609\":1}}],[\"比如biconsumer\",{\"1\":{\"1601\":1}}],[\"比如bean属性\",{\"1\":{\"927\":1}}],[\"比如面向函数式编程语言javascript中\",{\"1\":{\"1593\":1}}],[\"比如发邮件\",{\"1\":{\"1516\":1}}],[\"比如数据库\",{\"1\":{\"1510\":1}}],[\"比如是否需要阻塞队列帮我们排序\",{\"1\":{\"1509\":1}}],[\"比如如果计算发生错误\",{\"1\":{\"1496\":1}}],[\"比如等待队列\",{\"1\":{\"1490\":1}}],[\"比如装在配置\",{\"1\":{\"1485\":1}}],[\"比如decr和incrby\",{\"1\":{\"1293\":1}}],[\"比如pojo\",{\"1\":{\"1236\":1}}],[\"比如用户的登录状态\",{\"1\":{\"1200\":1}}],[\"比如用来判断一个库是主库还是备库\",{\"1\":{\"438\":1}}],[\"比如web\",{\"1\":{\"1138\":1}}],[\"比如where\",{\"1\":{\"484\":1}}],[\"比如长时间的数据计算任务等\",{\"1\":{\"1129\":1}}],[\"比如注解驱动\",{\"1\":{\"1035\":1}}],[\"比如groovy或者kotlin\",{\"1\":{\"902\":1}}],[\"比如group\",{\"1\":{\"411\":1}}],[\"比如流式调用\",{\"1\":{\"637\":1}}],[\"比如热搜排行上\",{\"1\":{\"629\":1}}],[\"比如事务和基本的crud\",{\"1\":{\"583\":1}}],[\"比如事务a更新了一行\",{\"1\":{\"442\":1}}],[\"比如我们上面给出的例子中的compute\",{\"1\":{\"1598\":1}}],[\"比如我们想把order\",{\"1\":{\"559\":1}}],[\"比如我们可以这样更新关于order\",{\"1\":{\"559\":1}}],[\"比如我们要获取两个集合的笛卡尔积\",{\"1\":{\"1609\":1}}],[\"比如我们要返回一个linkedlist\",{\"1\":{\"1609\":1}}],[\"比如我们要查看order\",{\"1\":{\"553\":1}}],[\"比如我们要看一下4~7个字节的前缀索引\",{\"1\":{\"350\":1}}],[\"比如u\",{\"1\":{\"558\":1}}],[\"比如表a\",{\"1\":{\"556\":1}}],[\"比如表a和表b连接\",{\"1\":{\"556\":1}}],[\"比如对象刚刚一次自旋操作成功过\",{\"1\":{\"1485\":1}}],[\"比如对某个key只允许一个线程查询数据和写缓存\",{\"1\":{\"633\":1}}],[\"比如对如下查询\",{\"1\":{\"555\":1}}],[\"比如对于integer的ofint\",{\"1\":{\"1620\":1}}],[\"比如对于integer的intconsumer\",{\"1\":{\"1620\":1}}],[\"比如对于idx\",{\"1\":{\"558\":1}}],[\"比如对于u\",{\"1\":{\"558\":1}}],[\"比如对于一个一万行记录的表来说\",{\"1\":{\"553\":1}}],[\"比如对于联合索引u\",{\"1\":{\"553\":1}}],[\"比如有a\",{\"1\":{\"556\":1}}],[\"比如有2000个参数怎么办\",{\"1\":{\"553\":1}}],[\"比如有一个事务插入person表插入了一条新的记录\",{\"1\":{\"542\":1}}],[\"比如使用in语句就很容易产生非常多的单点区间\",{\"1\":{\"553\":1}}],[\"比如许多应用对\",{\"1\":{\"532\":1}}],[\"比如价格\",{\"1\":{\"528\":1}}],[\"比如t2表有1000行记录\",{\"1\":{\"525\":1}}],[\"比如优化器是怎么选择索引的\",{\"1\":{\"514\":1}}],[\"比如加密\",{\"1\":{\"1510\":1}}],[\"比如加\",{\"1\":{\"487\":1}}],[\"比如下面几个查询\",{\"1\":{\"554\":2}}],[\"比如下面这个查询\",{\"1\":{\"553\":1}}],[\"比如下面这个语句\",{\"1\":{\"407\":1}}],[\"比如下面三个事务\",{\"1\":{\"484\":1}}],[\"比如命名为health\",{\"1\":{\"477\":1}}],[\"比如通过set\",{\"1\":{\"468\":1}}],[\"比如一个dubbo服务要调用grpc服务\",{\"1\":{\"637\":1}}],[\"比如一个是业务逻辑库\",{\"1\":{\"463\":1}}],[\"比如一周一备的实例\",{\"1\":{\"486\":1}}],[\"比如一些金融类的业务\",{\"1\":{\"470\":1}}],[\"比如一条sql执行超过5秒钟\",{\"1\":{\"428\":1}}],[\"比如所有的更新事务都会涉及到一个表的时候\",{\"1\":{\"461\":1}}],[\"比如主库所在机器掉电\",{\"1\":{\"457\":1}}],[\"比如软件升级\",{\"1\":{\"457\":1}}],[\"比如切换过程中出现双写\",{\"1\":{\"453\":1}}],[\"比如本节中的表t\",{\"1\":{\"448\":1}}],[\"比如10个记录\",{\"1\":{\"444\":1}}],[\"比如main\",{\"1\":{\"1663\":1}}],[\"比如mysql原生的myisam引擎就不支持事务\",{\"1\":{\"432\":1}}],[\"比如memcached及其他一些nosql引擎\",{\"1\":{\"332\":1}}],[\"比如超过5秒钟的就是慢sql\",{\"1\":{\"430\":1}}],[\"比如超过了1000个\",{\"1\":{\"425\":1}}],[\"比如查询需要跨多个分区取数据\",{\"1\":{\"426\":1}}],[\"比如nio+http或者nio2+ajp\",{\"1\":{\"1687\":1}}],[\"比如nullpointexception\",{\"1\":{\"1438\":1}}],[\"比如n\",{\"1\":{\"411\":1}}],[\"比如5秒\",{\"1\":{\"458\":1}}],[\"比如5\",{\"1\":{\"350\":1}}],[\"比如上文中的这个例子\",{\"1\":{\"454\":1}}],[\"比如上面例子中的select\",{\"1\":{\"476\":1}}],[\"比如上面的这个例子\",{\"1\":{\"454\":1}}],[\"比如上面这个市民表的情况\",{\"1\":{\"339\":1}}],[\"比如上述例子中表t中\",{\"1\":{\"322\":1}}],[\"比如字符串类型的身份证号\",{\"1\":{\"335\":1}}],[\"比如某天下午两点发现中午十二点有一次误删表\",{\"1\":{\"327\":1}}],[\"比如原来是n\",{\"1\":{\"326\":1}}],[\"比如执行下面的语句\",{\"1\":{\"321\":1}}],[\"比如\",{\"1\":{\"319\":1,\"325\":1,\"343\":1,\"348\":1,\"350\":1,\"394\":1,\"411\":1,\"424\":1,\"425\":1,\"426\":1,\"454\":2,\"457\":1,\"462\":2,\"470\":1,\"479\":1,\"480\":1,\"487\":2,\"491\":1,\"493\":1,\"928\":1,\"1236\":1,\"1551\":1,\"1563\":1,\"1607\":1,\"1610\":1,\"1613\":1,\"1619\":1,\"1623\":1,\"1632\":1,\"1633\":1,\"1635\":2,\"1646\":1}}],[\"比如存储过程\",{\"1\":{\"317\":1}}],[\"比如重启\",{\"1\":{\"304\":1}}],[\"比如说head是没有previousstage的\",{\"1\":{\"1621\":1}}],[\"比如说lamda表达式\",{\"1\":{\"1619\":1}}],[\"比如说我们开发一个银行转账的程序\",{\"1\":{\"1501\":1}}],[\"比如说redis实例的主观失效和客观失效等等\",{\"1\":{\"624\":1}}],[\"比如说\",{\"1\":{\"303\":1,\"1501\":1,\"1620\":3}}],[\"设定一个日志保留的天数\",{\"1\":{\"485\":1}}],[\"设置元空间最大值\",{\"1\":{\"1664\":1}}],[\"设置堆的最大可用大小\",{\"1\":{\"1664\":1}}],[\"设置堆的初始可用大小\",{\"1\":{\"1664\":1}}],[\"设置dispatcherservlet的过滤器\",{\"1\":{\"1658\":1}}],[\"设置哪些方法不被代理\",{\"1\":{\"1654\":1}}],[\"设置classpathmapperscanner对象可以扫描到接口\",{\"1\":{\"1653\":1}}],[\"设置conn\",{\"1\":{\"1630\":1}}],[\"设置一些基础属性\",{\"1\":{\"1651\":1}}],[\"设置一个锁资源\",{\"1\":{\"1288\":1}}],[\"设置类型转化服务\",{\"1\":{\"1636\":1}}],[\"设置连接模式为非阻塞模式\",{\"1\":{\"1574\":1}}],[\"设置多消费者\",{\"1\":{\"1521\":2}}],[\"设置消费者用于处理ringbuffer的事件\",{\"1\":{\"1521\":1}}],[\"设置消息格式模式\",{\"1\":{\"1053\":1}}],[\"设置队列的工作模式\",{\"1\":{\"1510\":1}}],[\"设置jvm参数\",{\"1\":{\"1485\":1}}],[\"设置对象头\",{\"0\":{\"1669\":1},\"1\":{\"1429\":1}}],[\"设置对象属性\",{\"1\":{\"1234\":1}}],[\"设置key的有效市场\",{\"1\":{\"1288\":1}}],[\"设置隔离级别\",{\"1\":{\"1262\":1}}],[\"设置\",{\"1\":{\"1163\":2}}],[\"设置bean表达式处理器\",{\"1\":{\"1164\":1}}],[\"设置beanfactory的类加载器\",{\"1\":{\"1651\":1}}],[\"设置beanfactory\",{\"1\":{\"1163\":1}}],[\"设置bean的scope属性\",{\"1\":{\"1022\":1}}],[\"设置bean类型\",{\"1\":{\"927\":1}}],[\"设置binlog\",{\"1\":{\"413\":1,\"451\":1}}],[\"设置不同的过期时间\",{\"1\":{\"633\":1}}],[\"设置热点数据永不过期\",{\"1\":{\"630\":1,\"1283\":1}}],[\"设置哨兵sentinel\",{\"1\":{\"624\":1}}],[\"设置余额\",{\"1\":{\"581\":1}}],[\"设置已存在的field\",{\"1\":{\"573\":1}}],[\"设置spring\",{\"1\":{\"1636\":1}}],[\"设置selector\",{\"1\":{\"1574\":1}}],[\"设置sex为1\",{\"1\":{\"573\":1}}],[\"设置sign的第2位为\",{\"1\":{\"578\":1}}],[\"设置sign的第0位为\",{\"1\":{\"578\":1}}],[\"设置studentx的age为20\",{\"1\":{\"573\":1}}],[\"设置name为sakura\",{\"1\":{\"573\":1}}],[\"设置哈希表字段的值\",{\"1\":{\"573\":1}}],[\"设置成功\",{\"1\":{\"569\":1}}],[\"设置成只读\",{\"1\":{\"453\":1}}],[\"设置键值对的过期时间\",{\"1\":{\"569\":2}}],[\"设置方式就是在创建或修改表的时候通过指定stats\",{\"1\":{\"559\":1}}],[\"设置方式就是在创建或修改表的时候通过stats\",{\"1\":{\"558\":1}}],[\"设置事务隔离级别\",{\"1\":{\"532\":1}}],[\"设置了这个参数\",{\"1\":{\"482\":1}}],[\"设置主库a的ip\",{\"1\":{\"453\":1}}],[\"设置阈值\",{\"1\":{\"430\":1}}],[\"设置为\",{\"1\":{\"1554\":1}}],[\"设置为正整数n表示这个函数最多等待n秒\",{\"1\":{\"473\":1}}],[\"设置为mixed\",{\"1\":{\"454\":1}}],[\"设置为只读可以防止误操作\",{\"1\":{\"453\":1}}],[\"设置为2的时候\",{\"1\":{\"451\":1}}],[\"设置为1的时候\",{\"1\":{\"451\":1}}],[\"设置为0的时候\",{\"1\":{\"451\":1}}],[\"设置为off的时候\",{\"1\":{\"347\":1}}],[\"设置为no的时候\",{\"1\":{\"347\":1}}],[\"设计与实现在线版\",{\"1\":{\"1975\":1}}],[\"设计了一个protocolhandler的接口来封装这两种变化点\",{\"1\":{\"1687\":1}}],[\"设计了字符串常量池\",{\"1\":{\"1342\":1}}],[\"设计非常巧妙\",{\"1\":{\"1593\":1}}],[\"设计的精髓\",{\"1\":{\"1502\":2}}],[\"设计的线程都在等待别的线程释放资源时\",{\"1\":{\"444\":1}}],[\"设计注意点\",{\"1\":{\"1502\":1}}],[\"设计缺陷\",{\"1\":{\"1123\":1}}],[\"设计特点\",{\"1\":{\"1112\":1,\"1113\":1}}],[\"设计思想\",{\"1\":{\"900\":1}}],[\"设计思想和模式的实现\",{\"1\":{\"891\":1}}],[\"设计原则\",{\"0\":{\"716\":1}}],[\"设计查询的时候一个需要考虑的重要问题时\",{\"1\":{\"392\":1}}],[\"设计模式的书籍推荐\",{\"1\":{\"1992\":1}}],[\"设计模式\",{\"0\":{\"262\":1,\"740\":1,\"1186\":1},\"1\":{\"300\":1,\"899\":1,\"900\":1,\"1108\":1,\"1125\":1,\"1966\":2}}],[\"采样的页面数量是\",{\"1\":{\"558\":1}}],[\"采样统计的时候\",{\"1\":{\"347\":1}}],[\"采样统计\",{\"1\":{\"347\":1}}],[\"采用约定大约配置的方式\",{\"1\":{\"1983\":1}}],[\"采用node数组加链表\",{\"1\":{\"1554\":1}}],[\"采用netty\",{\"1\":{\"583\":1}}],[\"采用thread\",{\"1\":{\"1533\":1}}],[\"采用的就是此模式\",{\"1\":{\"1530\":1}}],[\"采用的直连\",{\"1\":{\"583\":1}}],[\"采用死循环\",{\"1\":{\"1520\":1}}],[\"采用数组而非链表\",{\"1\":{\"1519\":1}}],[\"采用加锁的方式\",{\"1\":{\"1377\":1}}],[\"采用setnx\",{\"1\":{\"630\":1}}],[\"采用\",{\"1\":{\"583\":2}}],[\"采用不缓存的方式时\",{\"1\":{\"482\":1}}],[\"采用可靠性优先策略的话\",{\"1\":{\"459\":1}}],[\"采用force\",{\"1\":{\"348\":1}}],[\"采用采样统计的原因主要是\",{\"1\":{\"347\":1}}],[\"消费建议\",{\"0\":{\"1936\":1}}],[\"消费消息\",{\"0\":{\"1899\":1}}],[\"消费过程幂等\",{\"0\":{\"1857\":1}}],[\"消费者注册\",{\"0\":{\"1889\":1}}],[\"消费者组\",{\"0\":{\"1829\":1}}],[\"消费者一天的消费能力高于生产者\",{\"1\":{\"1536\":1}}],[\"消费者一天的消费能力已经高于生产者\",{\"1\":{\"1536\":1}}],[\"消费者加机器\",{\"1\":{\"1536\":1}}],[\"消费者每天能处理的量比生产者生产的多\",{\"1\":{\"1536\":2}}],[\"消费者每天能处理的量比生产者生产的少\",{\"1\":{\"1536\":1}}],[\"消费者每天只能消费5千条\",{\"1\":{\"1536\":1}}],[\"消费者处理任务\",{\"1\":{\"1535\":1}}],[\"消费者要实现workhandler接口\",{\"1\":{\"1521\":1}}],[\"消费者线程池\",{\"1\":{\"1535\":1}}],[\"消费者线程会尽最大努力监控缓冲区的变化\",{\"1\":{\"1520\":1}}],[\"消费者线程会不断地监控缓冲区变化\",{\"1\":{\"1520\":1}}],[\"消费者线程就会立刻消费\",{\"1\":{\"1519\":1}}],[\"消费者线程阻塞\",{\"1\":{\"1503\":1}}],[\"消费者时刻关注着队列里有没有消息\",{\"1\":{\"1519\":1}}],[\"消费者\",{\"0\":{\"1856\":1},\"1\":{\"1502\":1}}],[\"消费者模式可能出现过饱的问题\",{\"1\":{\"1536\":1}}],[\"消费者模式的核心是一个任务队列\",{\"1\":{\"1535\":1}}],[\"消费者模式的时候\",{\"1\":{\"1501\":1}}],[\"消费者模式\",{\"0\":{\"1535\":1}}],[\"消费者模型\",{\"1\":{\"1519\":1}}],[\"消费者模型中使用时\",{\"1\":{\"1502\":1}}],[\"消费者直接使用线程安全的队列就可以\",{\"1\":{\"1501\":1}}],[\"消费者这一段需要保证幂等消费\",{\"1\":{\"1333\":1}}],[\"消费者消费消息不丢失\",{\"1\":{\"1328\":1}}],[\"消耗资源比较多\",{\"1\":{\"1585\":1}}],[\"消耗性能\",{\"1\":{\"592\":1}}],[\"消耗内存\",{\"1\":{\"589\":1}}],[\"消耗的cpu资源越少\",{\"1\":{\"347\":1}}],[\"消息同步传输\",{\"0\":{\"1935\":1}}],[\"消息异步传输\",{\"0\":{\"1934\":1}}],[\"消息索引服务\",{\"0\":{\"1919\":1}}],[\"消息索引流程\",{\"0\":{\"1916\":1}}],[\"消息查询\",{\"0\":{\"1917\":1}}],[\"消息接收过程\",{\"0\":{\"1888\":1}}],[\"消息过滤类型\",{\"0\":{\"1903\":1}}],[\"消息过滤过程\",{\"0\":{\"1902\":1}}],[\"消息过滤\",{\"0\":{\"1850\":1,\"1911\":1}}],[\"消息刷盘\",{\"0\":{\"1846\":1,\"1887\":1}}],[\"消息存储过程\",{\"0\":{\"1883\":1}}],[\"消息存储整体架构\",{\"0\":{\"1844\":1}}],[\"消息存储\",{\"0\":{\"1843\":1}}],[\"消息重试\",{\"0\":{\"1837\":1,\"1928\":1}}],[\"消息顺序\",{\"0\":{\"1836\":1}}],[\"消息模型\",{\"0\":{\"1827\":1}}],[\"消息会被重复消费\",{\"1\":{\"1521\":1}}],[\"消息是分散存储的\",{\"1\":{\"1328\":1}}],[\"消息传递过程中如果存在跨网络的请求\",{\"1\":{\"1328\":1}}],[\"消息积累会严重影响性能\",{\"1\":{\"1327\":1}}],[\"消息可靠性高\",{\"1\":{\"1327\":1}}],[\"消息不会重复调用\",{\"1\":{\"1326\":1}}],[\"消息的顺序分为全局有序和局部有序\",{\"1\":{\"1330\":1}}],[\"消息的具体处理器\",{\"1\":{\"1224\":1}}],[\"消息的广播\",{\"0\":{\"660\":1}}],[\"消息发送过程\",{\"0\":{\"1880\":1}}],[\"消息发送+回调\",{\"1\":{\"1328\":2}}],[\"消息发送者\",{\"1\":{\"1108\":1}}],[\"消息发布端\",{\"1\":{\"598\":1}}],[\"消息格式风格\",{\"1\":{\"1053\":1}}],[\"消息格式类型\",{\"1\":{\"1053\":1}}],[\"消息格式模式\",{\"1\":{\"1053\":1}}],[\"消息也可以看作是ioc的一种实现\",{\"1\":{\"914\":1}}],[\"消息订阅\",{\"1\":{\"601\":1}}],[\"消息排队\",{\"1\":{\"571\":1}}],[\"消息队列\",{\"0\":{\"244\":1,\"1325\":1,\"1890\":1},\"1\":{\"571\":1,\"1477\":1}}],[\"扫描事务状态\",{\"0\":{\"1943\":1}}],[\"扫描处理的核心类\",{\"1\":{\"1652\":1}}],[\"扫描得到beandefinition\",{\"1\":{\"1651\":2}}],[\"扫描的整个过程说白了\",{\"1\":{\"1652\":1}}],[\"扫描的整体过程\",{\"1\":{\"1647\":1}}],[\"扫描的时候也会把bean的名字也存下来\",{\"1\":{\"1647\":1}}],[\"扫描的时候并不会解析\",{\"1\":{\"1647\":1}}],[\"扫描的核心方法\",{\"1\":{\"1647\":1}}],[\"扫描的行数是10000\",{\"1\":{\"420\":1}}],[\"扫描的行数中的大部分都很可能是被where条件过滤掉的\",{\"1\":{\"390\":1}}],[\"扫描的行数也从小到大\",{\"1\":{\"390\":1}}],[\"扫描的行数和访问类型\",{\"0\":{\"390\":1}}],[\"扫描的行数和返回的行数应该是相同的\",{\"1\":{\"389\":1}}],[\"扫描的行数和返回的行数\",{\"0\":{\"389\":1}}],[\"扫描的行数对返回的行数的比率通常很小\",{\"1\":{\"389\":1}}],[\"扫描的行数\",{\"1\":{\"387\":1}}],[\"扫描的行数的估计值依然不准确\",{\"1\":{\"347\":1}}],[\"扫描的行数越少\",{\"1\":{\"347\":1}}],[\"扫描这些key\",{\"1\":{\"1287\":1}}],[\"扫描指定package下标注spring模式注解的类\",{\"1\":{\"1029\":1,\"1131\":1}}],[\"扫描100次t1表的索引\",{\"1\":{\"524\":1}}],[\"扫描100行\",{\"1\":{\"524\":1}}],[\"扫描完成后\",{\"1\":{\"418\":1,\"1653\":1}}],[\"扫描到的类上如果存在\",{\"1\":{\"1635\":1}}],[\"扫描到整个输入的数据结束\",{\"1\":{\"417\":1}}],[\"扫描到id=10的时候才插入m=0这一行\",{\"1\":{\"416\":1}}],[\"扫描表t1的索引a\",{\"1\":{\"416\":1,\"418\":1}}],[\"扫描表t1\",{\"1\":{\"403\":1,\"407\":1}}],[\"扫描表t2\",{\"1\":{\"403\":2,\"407\":1}}],[\"扫描额外的记录\",{\"0\":{\"387\":1}}],[\"扫描行数\",{\"1\":{\"519\":1}}],[\"扫描行数就会过多\",{\"1\":{\"403\":1}}],[\"扫描行数最少的方式找到需要的记录\",{\"1\":{\"390\":1}}],[\"扫描行数是n+λ\",{\"1\":{\"403\":1}}],[\"扫描行数是1\",{\"1\":{\"368\":1}}],[\"扫描行数是影响执行代价的因素之一\",{\"1\":{\"347\":1}}],[\"扫描行数成了影响决策的主要条件\",{\"1\":{\"348\":1}}],[\"来分别做这两件事情\",{\"1\":{\"1683\":1}}],[\"来加深对于stream的理解\",{\"1\":{\"1608\":1}}],[\"来加深对于实例方法名引用的理解\",{\"1\":{\"1605\":1}}],[\"来加速整个数据恢复过程\",{\"1\":{\"485\":1}}],[\"来完成相同的功能\",{\"1\":{\"1603\":1}}],[\"来完成对数据库中数据的操作\",{\"1\":{\"569\":1}}],[\"来返回比较小的那一个\",{\"1\":{\"1601\":1}}],[\"来返回记录\",{\"1\":{\"390\":1}}],[\"来推测出\",{\"1\":{\"1595\":1}}],[\"来声明函数式接口\",{\"1\":{\"1594\":1}}],[\"来实现\",{\"1\":{\"1650\":1}}],[\"来实现各种各样的操作\",{\"1\":{\"1593\":1}}],[\"来实现的\",{\"1\":{\"451\":1}}],[\"来进行传输的\",{\"1\":{\"1583\":1}}],[\"来进行幂等判断\",{\"1\":{\"1329\":1}}],[\"来拷贝数据\",{\"1\":{\"1583\":1}}],[\"来找到就绪的描述符\",{\"1\":{\"1569\":1}}],[\"来得到该对象的保存位\",{\"1\":{\"1548\":1}}],[\"来定位该键值对的存储位置\",{\"1\":{\"1546\":1}}],[\"来定位记录\",{\"1\":{\"339\":1}}],[\"来选择合适的阻塞队列\",{\"1\":{\"1509\":1}}],[\"来描述\",{\"1\":{\"1477\":1}}],[\"来存储元数据\",{\"1\":{\"1457\":1}}],[\"来记录新生代和老年代之间的引用关系\",{\"1\":{\"1449\":1}}],[\"来记录并统计结果\",{\"1\":{\"417\":1}}],[\"来满足业务的需求\",{\"1\":{\"1409\":1}}],[\"来达到规定的生存时间内进行计数的目的\",{\"1\":{\"1293\":1}}],[\"来达到提升备库复制并发度的目的\",{\"1\":{\"465\":1}}],[\"来指定注入哪一个\",{\"1\":{\"1242\":2}}],[\"来源于linux系统的sendfile方法逻辑\",{\"1\":{\"1576\":1}}],[\"来源于同一层兄弟节点的有序性\",{\"1\":{\"366\":1}}],[\"来源类型\",{\"1\":{\"1086\":1}}],[\"来源类型只能为java\",{\"1\":{\"1085\":1}}],[\"来源\",{\"0\":{\"1765\":1},\"1\":{\"972\":1,\"973\":1,\"974\":1,\"976\":1,\"983\":1,\"1235\":1}}],[\"来间隔\",{\"1\":{\"928\":1}}],[\"来扩充\",{\"1\":{\"928\":1}}],[\"来设置另一个短期key来锁住当前key的访问\",{\"1\":{\"630\":1}}],[\"来保证操作安全\",{\"1\":{\"1554\":1}}],[\"来保证数据的重复提交\",{\"1\":{\"1248\":1}}],[\"来保证每次只有一个slave\",{\"1\":{\"624\":1}}],[\"来保存中间结果\",{\"1\":{\"418\":1}}],[\"来保存身份证的校验码\",{\"1\":{\"352\":1}}],[\"来计算全表扫描成本\",{\"1\":{\"548\":1}}],[\"来表示当前记录已经被删除\",{\"1\":{\"542\":1}}],[\"来处理这个thd\",{\"1\":{\"481\":1}}],[\"来看具体的例子\",{\"1\":{\"1599\":1}}],[\"来看一个具体的例子\",{\"1\":{\"1601\":1}}],[\"来看一个输入参数与返回结果参数类型不一致的例子\",{\"1\":{\"1598\":1}}],[\"来看一下sql执行计划\",{\"1\":{\"361\":1}}],[\"来看这样一个例子\",{\"1\":{\"1595\":1}}],[\"来看看数据恢复的问题\",{\"1\":{\"454\":1}}],[\"来判断节点的角色\",{\"1\":{\"453\":1}}],[\"来解决\",{\"1\":{\"448\":1}}],[\"来解决这个问题\",{\"1\":{\"417\":1}}],[\"来确认产品已经发布成功了\",{\"1\":{\"471\":1}}],[\"来确认需要的数据被放在哪个分表上\",{\"1\":{\"411\":1}}],[\"来确保数据页不会被多次执行重复的redo\",{\"1\":{\"451\":1}}],[\"来确保拿到一致性视图\",{\"1\":{\"438\":1}}],[\"来查看当前的值\",{\"1\":{\"433\":1}}],[\"来查看mysqldumpslow的帮助信息\",{\"1\":{\"429\":1}}],[\"来查看以下具体的执行情况\",{\"1\":{\"346\":1}}],[\"来验证扫描行数是否是20003\",{\"1\":{\"420\":1}}],[\"来举例\",{\"1\":{\"414\":1}}],[\"来显示实例的临时文件目录\",{\"1\":{\"412\":1}}],[\"来触发bka算法\",{\"1\":{\"407\":1}}],[\"来说\",{\"1\":{\"399\":3,\"553\":1}}],[\"来提供给优化器做选择\",{\"1\":{\"348\":1}}],[\"来和session\",{\"1\":{\"346\":1}}],[\"来让优化器强制使用索引a\",{\"1\":{\"346\":1}}],[\"又将这个部分结果传递给combiner\",{\"1\":{\"1615\":1}}],[\"又马上将其修改为a\",{\"1\":{\"1479\":1}}],[\"又会退化成链表结构\",{\"1\":{\"1475\":1}}],[\"又会连接上从机恢复原状\",{\"1\":{\"611\":1}}],[\"又可称合作者\",{\"1\":{\"927\":1}}],[\"又可以获取到主机的所有数据\",{\"1\":{\"611\":1}}],[\"又可以让备库执行得快些\",{\"1\":{\"465\":1}}],[\"又可以明确地直到每个语句是否处于事务中\",{\"1\":{\"435\":1}}],[\"又不会用到collectorimpl\",{\"1\":{\"1616\":1}}],[\"又不会出现数据一致性问题\",{\"1\":{\"492\":1}}],[\"又不用额外增加太多的查询成本\",{\"1\":{\"350\":1}}],[\"又加入了\",{\"1\":{\"412\":1}}],[\"又调用idata这个存储过程\",{\"1\":{\"346\":1}}],[\"又有基于a\",{\"1\":{\"339\":1}}],[\"我最开始学习的是kafka\",{\"1\":{\"1985\":1}}],[\"我曾经看了三遍\",{\"1\":{\"1975\":1}}],[\"我先分享下自己对不同学习方式的理解\",{\"1\":{\"1968\":1}}],[\"我先把可能的数据先预先访问一遍\",{\"1\":{\"633\":1}}],[\"我再执行start\",{\"1\":{\"468\":1}}],[\"我设置的为1秒\",{\"1\":{\"428\":1}}],[\"我用下面的表\",{\"1\":{\"414\":1}}],[\"我要往page插入一行\",{\"1\":{\"345\":1}}],[\"我们已经具备实际项目的开发能力了\",{\"1\":{\"1984\":1}}],[\"我们目前只学习\",{\"1\":{\"1974\":1}}],[\"我们有必要了解一下有关分区和分组的实现\",{\"1\":{\"1618\":1}}],[\"我们有提到过bean初始化操作\",{\"1\":{\"1007\":1}}],[\"我们打印一下\",{\"1\":{\"1617\":1}}],[\"我们去掉characteristics方法中的枚举项identity\",{\"1\":{\"1617\":1}}],[\"我们提到过characteristics这个内部枚举类\",{\"1\":{\"1617\":1}}],[\"我们才能体会到函数式编程带给我们巨大好处\",{\"1\":{\"1613\":1}}],[\"我们尝试实现一个稍微复杂的需求\",{\"1\":{\"1613\":1}}],[\"我们曾经在内部迭代与外部迭代的章节中提到过\",{\"1\":{\"1613\":1}}],[\"我们更多的是使用链式的写法\",{\"1\":{\"1610\":1}}],[\"我们猜想代码可能是这样的\",{\"1\":{\"1610\":1}}],[\"我们要想写出好的代码\",{\"1\":{\"1992\":1}}],[\"我们要用到map接口中所新增加的默认方法computeifabsent\",{\"1\":{\"1618\":1}}],[\"我们要找到长度为5的字符串\",{\"1\":{\"1612\":1}}],[\"我们要找出流中大于2的元素\",{\"1\":{\"1610\":1}}],[\"我们要考虑的原则就是空间了\",{\"1\":{\"339\":1}}],[\"我们不妨来看一下优化的时候调用的sourcestagespliterator方法\",{\"1\":{\"1622\":1}}],[\"我们不妨来看一下这个方法的源码\",{\"1\":{\"1607\":1}}],[\"我们不去了解\",{\"1\":{\"550\":1}}],[\"我们补充一些关于jdk8中默认方法的相关介绍\",{\"1\":{\"1607\":1}}],[\"我们增加一个方法\",{\"1\":{\"1605\":1}}],[\"我们依然使用排序这个例子\",{\"1\":{\"1604\":1}}],[\"我们依然可以用树搜索的方式定位到第一个满足city=\",{\"1\":{\"356\":1}}],[\"我们给定两个字符串\",{\"1\":{\"1601\":1}}],[\"我们定义了一个接口\",{\"1\":{\"1595\":1}}],[\"我们定义一个测试类\",{\"1\":{\"1134\":1}}],[\"我们继续往下\",{\"1\":{\"1594\":1}}],[\"我们一直再说中间操作和终止操作\",{\"1\":{\"1611\":1}}],[\"我们一行一行来仔细阅读一下这段文档\",{\"1\":{\"1594\":1}}],[\"我们一般也会扩充notifyobservers的实现逻辑\",{\"1\":{\"1108\":1}}],[\"我们一般情况下只用配置从机就好了\",{\"1\":{\"610\":1}}],[\"我们非常有必要首来认识一下\",{\"1\":{\"1593\":1}}],[\"我们查看一下第二种方式\",{\"1\":{\"1593\":1}}],[\"我们都会给出lambda表达式的方式和方法引用的方式实现相同的功能\",{\"1\":{\"1602\":1}}],[\"我们都知道list本身继承了collection集合接口\",{\"1\":{\"1593\":1}}],[\"我们都是需要配合stream\",{\"1\":{\"1593\":1}}],[\"我们都将他投递给线程池处理\",{\"1\":{\"1573\":1}}],[\"我们首先需要理解collector泛型的含义\",{\"1\":{\"1615\":1}}],[\"我们首先需要了解我们为什么需要需要lambda表达式\",{\"1\":{\"1593\":1}}],[\"我们首先来看一下basestream类的定义\",{\"1\":{\"1619\":1}}],[\"我们首先来看一下这里面调用的counting\",{\"1\":{\"1613\":1}}],[\"我们首先来阅读一下binaryoperator这个函数式接口的文档\",{\"1\":{\"1601\":1}}],[\"我们首先创建了一个元素为5\",{\"1\":{\"1607\":1}}],[\"我们首先使用不同的方式来创建一个stream对象\",{\"1\":{\"1607\":1}}],[\"我们首先类阅读一下predicate的javadoc\",{\"1\":{\"1599\":1}}],[\"我们首先从遍历打印集合中元素这样非常常见的例子开始\",{\"1\":{\"1593\":1}}],[\"我们可能会写出如下代码\",{\"1\":{\"1598\":1}}],[\"我们可能会编写这样的代码\",{\"1\":{\"1591\":1}}],[\"我们可以简单的看一下这个方法接收的参数以及它要完成的事情\",{\"1\":{\"1613\":1}}],[\"我们可以简单的了解一下他们之前的区别\",{\"1\":{\"1593\":1}}],[\"我们可以来了解一下这个range\",{\"1\":{\"1607\":1}}],[\"我们可以来看以下具体地使用场景\",{\"1\":{\"1146\":1}}],[\"我们可以很轻松的写出如下代码\",{\"1\":{\"1606\":1}}],[\"我们可以将方法引用看作是一个\",{\"1\":{\"1602\":1}}],[\"我们可以将查询请求分为两类\",{\"1\":{\"470\":1}}],[\"我们可以给出例子\",{\"1\":{\"1599\":1}}],[\"我们可以换一种写法\",{\"1\":{\"1595\":1}}],[\"我们可以得出如下结论\",{\"1\":{\"1580\":1}}],[\"我们可以得到两个结论\",{\"1\":{\"401\":1}}],[\"我们可以注册op\",{\"1\":{\"1574\":1}}],[\"我们可以轻松地组织不同任务的运行顺序\",{\"1\":{\"1518\":1}}],[\"我们可以自定义一个lifecycle\",{\"1\":{\"1174\":1}}],[\"我们可以自己实现一个\",{\"1\":{\"1032\":1}}],[\"我们可以模拟一下整个过程\",{\"1\":{\"1082\":1}}],[\"我们可以看一些具体的例子\",{\"1\":{\"1616\":1}}],[\"我们可以看一下\",{\"1\":{\"1023\":1}}],[\"我们可以看到这里就调用了preinstantiatesingletons方法\",{\"1\":{\"1009\":1}}],[\"我们可以看到\",{\"1\":{\"416\":1}}],[\"我们可以理解为是bean属性赋值\",{\"1\":{\"1002\":1}}],[\"我们可以构造一个例子来进行测试\",{\"1\":{\"1001\":1}}],[\"我们可以打印这个bean的元信息\",{\"1\":{\"909\":1}}],[\"我们可以单独为某个表设置是否自动重新计算统计数的属性\",{\"1\":{\"559\":1}}],[\"我们可以单独设置某个表的采样页面的数量\",{\"1\":{\"558\":1}}],[\"我们可以计算order\",{\"1\":{\"553\":1}}],[\"我们可以针对索引列\",{\"1\":{\"553\":1}}],[\"我们可以从binlog备份系统中找到需要的binlog\",{\"1\":{\"485\":1}}],[\"我们可以检测出由于并发线程过多导致的数据库不可用的情况\",{\"1\":{\"477\":1}}],[\"我们可以执行如下语句序列\",{\"1\":{\"468\":1}}],[\"我们可以把slave\",{\"1\":{\"467\":1}}],[\"我们可以用seconds\",{\"1\":{\"457\":1}}],[\"我们可以对分区表做以下总结\",{\"1\":{\"425\":1}}],[\"我们可以在userholder中实现这些接口\",{\"1\":{\"1005\":1}}],[\"我们可以在url中带上index\",{\"1\":{\"307\":1}}],[\"我们可以在mysql\",{\"1\":{\"478\":1}}],[\"我们可以在group\",{\"1\":{\"418\":1}}],[\"我们可以按照这个思路\",{\"1\":{\"408\":1}}],[\"我们可以知道λ=k\",{\"1\":{\"403\":1}}],[\"我们可以通过tomcat的server\",{\"1\":{\"1683\":1}}],[\"我们可以通过collector中的of方法实现自定的收集器\",{\"1\":{\"1615\":1}}],[\"我们可以通过匿名内部类的方式来操作\",{\"1\":{\"1597\":1}}],[\"我们可以通过lambda表达式来创建runnable接口的实例\",{\"1\":{\"1594\":1}}],[\"我们可以通过multi命令开启一个事务\",{\"1\":{\"1297\":1}}],[\"我们可以通过指定stats\",{\"1\":{\"558\":1}}],[\"我们可以通过如下的语句\",{\"1\":{\"553\":1}}],[\"我们可以通过下面的语句序列验证\",{\"1\":{\"494\":1}}],[\"我们可以通过修改参数\",{\"1\":{\"355\":1}}],[\"我们可以通过统计索引上有多少个不同的值来判断需要使用多长的前缀\",{\"1\":{\"350\":1}}],[\"我们可以通过慢查询日志\",{\"1\":{\"346\":1}}],[\"我们可以新建一个更合适的索引\",{\"1\":{\"348\":1}}],[\"我们可以使用这个方法将使用tolist收集的方法来转换为一个不可变的集合\",{\"1\":{\"1618\":1}}],[\"我们可以使用slaveof\",{\"1\":{\"611\":1}}],[\"我们可以使用show\",{\"1\":{\"347\":1}}],[\"我们可以使用analyze\",{\"1\":{\"347\":1}}],[\"我们实现客户端发送消息服务端将消息回传我们的功能\",{\"1\":{\"1573\":1}}],[\"我们每次扩容都会将长度扩容为原来的2倍\",{\"1\":{\"1550\":1}}],[\"我们生产者只需要从队列里取出它们就可以了\",{\"1\":{\"1501\":1}}],[\"我们主要的关注点\",{\"1\":{\"1494\":1}}],[\"我们主要关注event\",{\"1\":{\"479\":1}}],[\"我们平常说的redis单线程快是指它的请求处理非常地块\",{\"1\":{\"1292\":1}}],[\"我们应该选择第二种方式\",{\"1\":{\"1165\":1}}],[\"我们应该如何处理呢\",{\"1\":{\"348\":1}}],[\"我们手动给他赋上了值\",{\"1\":{\"1003\":1}}],[\"我们优先考虑哨兵模式\",{\"1\":{\"619\":1}}],[\"我们这里是使用命令搭建\",{\"1\":{\"610\":1}}],[\"我们这里有两个索引\",{\"1\":{\"549\":1}}],[\"我们把这个死循环称为事件循环\",{\"1\":{\"603\":1}}],[\"我们把这条记录称之为区间最右记录\",{\"1\":{\"549\":1}}],[\"我们把这条记录称之为区间最左记录\",{\"1\":{\"549\":1}}],[\"我们存什么都不会有乱码的担忧了\",{\"1\":{\"583\":1}}],[\"我们常用的方法都可以直接通过redistemplate操作\",{\"1\":{\"583\":1}}],[\"我们启动另外一个客户端模拟插队线程\",{\"1\":{\"581\":1}}],[\"我们连接另一个客户端向newlist中push了test\",{\"1\":{\"571\":1}}],[\"我们能对它们多增删改查操作\",{\"1\":{\"559\":1}}],[\"我们也尝试着自己实现了两个相对比较简单的例子\",{\"1\":{\"1618\":1}}],[\"我们也可以转化为set\",{\"1\":{\"1609\":1}}],[\"我们也可以看到\",{\"1\":{\"1593\":1}}],[\"我们也可以手动调用analyze\",{\"1\":{\"559\":1}}],[\"我们也需要计算使用idx\",{\"1\":{\"549\":1}}],[\"我们最常见的就是btree\",{\"1\":{\"553\":1}}],[\"我们通过一个具体的例子来说明\",{\"1\":{\"1620\":1}}],[\"我们通过使用collection的stream方法创建了一个widget对象的流\",{\"1\":{\"1619\":1}}],[\"我们通过这种方式就实现了上述sql的需求\",{\"1\":{\"1613\":1}}],[\"我们通过mysql看到使用idx\",{\"1\":{\"551\":1}}],[\"我们通过慢查询日志\",{\"1\":{\"420\":1}}],[\"我们前面说过在b+树中定位到一条记录的过程是很快的\",{\"1\":{\"549\":1}}],[\"我们仍然使用如下查询语句来分析\",{\"1\":{\"547\":1}}],[\"我们默认从1开始\",{\"1\":{\"542\":1}}],[\"我们假设区间最左记录在页b中\",{\"1\":{\"549\":1}}],[\"我们假设为null\",{\"1\":{\"542\":1}}],[\"我们假设当前k索引树的状态\",{\"1\":{\"345\":1}}],[\"我们必须首先了解一下\",{\"1\":{\"541\":1}}],[\"我们并不推荐它\",{\"1\":{\"529\":1}}],[\"我们再回到一开始的例子当中\",{\"1\":{\"1621\":1}}],[\"我们再回到遍历list集合的例子中\",{\"1\":{\"1595\":1}}],[\"我们再定义一个类\",{\"1\":{\"1607\":1}}],[\"我们再举一个例子\",{\"1\":{\"1605\":1,\"1613\":1}}],[\"我们再对比优化前后sql的执行计划\",{\"1\":{\"522\":1}}],[\"我们再来看一下comparator的类定义情况\",{\"1\":{\"1603\":1}}],[\"我们再来看看如果要在这张表中插入一个新记录\",{\"1\":{\"343\":1}}],[\"我们再来看执行器和innodb引擎在执行这个update语句时的内部流程\",{\"1\":{\"326\":1}}],[\"我们观察如下事务序列\",{\"1\":{\"497\":1}}],[\"我们对mysql相关的误删数据\",{\"1\":{\"483\":1}}],[\"我们感知到的连接过程慢\",{\"1\":{\"482\":1}}],[\"我们创建一个bean加入容器\",{\"1\":{\"583\":1}}],[\"我们创建一个表t\",{\"1\":{\"489\":1}}],[\"我们创建表t\",{\"1\":{\"476\":1}}],[\"我们创建两个表t1和t2\",{\"1\":{\"400\":1}}],[\"我们执行完事务后\",{\"1\":{\"474\":1}}],[\"我们执行如下语句\",{\"1\":{\"414\":1}}],[\"我们很好理解\",{\"1\":{\"1968\":1}}],[\"我们很清楚在主备切换过程中\",{\"1\":{\"467\":1}}],[\"我们很有可能碰到前缀的区分度不够好的情况\",{\"1\":{\"352\":1}}],[\"我们判断一个事务t和worker是否冲突\",{\"1\":{\"462\":1}}],[\"我们分别从delete\",{\"1\":{\"454\":1}}],[\"我们认为fsync才占磁盘的iops\",{\"1\":{\"450\":1}}],[\"我们直到\",{\"1\":{\"447\":1}}],[\"我们直接在被驱动表上建立索引\",{\"1\":{\"407\":1}}],[\"我们初始化如下数据\",{\"1\":{\"446\":1}}],[\"我们初始化表t的时候\",{\"1\":{\"424\":1}}],[\"我们以order\",{\"1\":{\"558\":1}}],[\"我们以下面的操作序列为例\",{\"1\":{\"443\":1}}],[\"我们以一个算count\",{\"1\":{\"396\":1}}],[\"我们先来学习项目管理利器maven和git\",{\"1\":{\"1979\":1}}],[\"我们先来读一下方法说明\",{\"1\":{\"1618\":1}}],[\"我们先创建一个学生类\",{\"1\":{\"1613\":1}}],[\"我们先创建表t\",{\"1\":{\"424\":1}}],[\"我们先分析idx\",{\"1\":{\"549\":1}}],[\"我们先把问题简化以下\",{\"1\":{\"422\":1}}],[\"我们得清楚\",{\"1\":{\"417\":1}}],[\"我们得从文章开头的那个问题说起\",{\"1\":{\"327\":1}}],[\"我们使用了临时表\",{\"1\":{\"409\":1}}],[\"我们的方法就是在这里被调用了\",{\"1\":{\"1617\":1}}],[\"我们的代码就变成了\",{\"1\":{\"1591\":1}}],[\"我们的程序肯定无法满足性能需求\",{\"1\":{\"1573\":1}}],[\"我们的表t初始以后\",{\"1\":{\"448\":1}}],[\"我们的思路都是让join语句能够用上被驱动表上的索引\",{\"1\":{\"407\":1}}],[\"我们的查询\",{\"1\":{\"338\":1}}],[\"我们回到本小节一开始的两个问题\",{\"1\":{\"403\":1}}],[\"我们将会看到jdk在底层到底是如何巧妙的实现函数式编程\",{\"1\":{\"1618\":1}}],[\"我们将会讨论自己计数的方法\",{\"1\":{\"396\":1}}],[\"我们将系统而全面的分析jdk是如何实现函数式编程\",{\"1\":{\"1613\":1}}],[\"我们将备库b接收完这个binlog的时刻记为t2\",{\"1\":{\"457\":1}}],[\"我们将这个时刻记为t3\",{\"1\":{\"457\":1}}],[\"我们将这个时刻记为t1\",{\"1\":{\"457\":1}}],[\"我们将这个算法暂时称作随机算法2\",{\"1\":{\"422\":1}}],[\"我们将这个算法暂时称作随机算法1\",{\"1\":{\"422\":1}}],[\"我们将tmp\",{\"1\":{\"421\":1}}],[\"我们将sql语句修改如下\",{\"1\":{\"402\":1}}],[\"我们删除索引后\",{\"1\":{\"390\":1}}],[\"我们无法把响应时间细分到上面这些部分\",{\"1\":{\"388\":1}}],[\"我们往交易日志表tradelog和交易详情表trade\",{\"1\":{\"368\":1}}],[\"我们现在知道范围之后的索引会失效\",{\"1\":{\"361\":1}}],[\"我们试试把sql修改为select\",{\"1\":{\"361\":1}}],[\"我们发现当前临时实例需要的binlog是从master\",{\"1\":{\"485\":1}}],[\"我们发现以上两条sql的执行结果都是一样的\",{\"1\":{\"371\":1}}],[\"我们发现\",{\"1\":{\"361\":1}}],[\"我们需要先了解数据结构相关的内容\",{\"1\":{\"1970\":1}}],[\"我们需要搞清楚这里每一个泛型的含义\",{\"1\":{\"1618\":1}}],[\"我们需要提供分组的依据\",{\"1\":{\"1613\":1}}],[\"我们需要将某一个子类中的默认方法实现重写一遍\",{\"1\":{\"1607\":1}}],[\"我们需要根据任务数量来推算出合适的容量\",{\"1\":{\"1509\":1}}],[\"我们需要对之前的代码进行一定的重构\",{\"1\":{\"1005\":1}}],[\"我们需要知道如何编写配置文件然后连接redis\",{\"1\":{\"583\":1}}],[\"我们需要尽量在被驱动表的连接列上建立索引\",{\"1\":{\"555\":1}}],[\"我们需要分别分析单独使用这些索引执行查询的成本\",{\"1\":{\"549\":1}}],[\"我们需要分析一下哪些场景应该使用自增主键\",{\"1\":{\"335\":1}}],[\"我们需要的两个统计项\",{\"1\":{\"548\":1}}],[\"我们需要把这条查询语句修改成更新语句\",{\"1\":{\"477\":1}}],[\"我们需要把这三个操作放在一个事务中\",{\"1\":{\"443\":1}}],[\"我们需要找一个访问innodb的场景\",{\"1\":{\"477\":1}}],[\"我们需要update两条记录\",{\"1\":{\"443\":1}}],[\"我们需要一个临时表\",{\"1\":{\"417\":1}}],[\"我们需要每个月运行一次下面的查询\",{\"1\":{\"393\":1}}],[\"我们需要在city字段加上索引\",{\"1\":{\"354\":1}}],[\"我们经常会碰到要存储字符串的场景\",{\"1\":{\"349\":1}}],[\"我们看一下修改之后的效果\",{\"1\":{\"348\":1}}],[\"我们看到的只是输入一条语句\",{\"1\":{\"317\":1}}],[\"我们称它为伪异步io\",{\"1\":{\"1573\":1}}],[\"我们称为通用分区策略\",{\"1\":{\"425\":1}}],[\"我们称为覆盖索引\",{\"1\":{\"338\":1}}],[\"我们称之为默认方法\",{\"1\":{\"1593\":1}}],[\"我们称之为\",{\"1\":{\"347\":1,\"1133\":1}}],[\"我们在扩充hashmap的时候\",{\"1\":{\"1550\":1}}],[\"我们在使用的时候建议手动传一个队列的大小\",{\"1\":{\"1503\":1}}],[\"我们在使用事务的时候\",{\"1\":{\"443\":1}}],[\"我们在很多场景下都可以利用线程安全的队列来优雅地解决我们业务自身的线程安全问题\",{\"1\":{\"1501\":1}}],[\"我们在userholder中添加它的初始化方法\",{\"1\":{\"1007\":1}}],[\"我们在defaultlistablebeanfactory\",{\"1\":{\"963\":1}}],[\"我们在讲解配置文件的时候\",{\"1\":{\"609\":1}}],[\"我们在学习springboot自动配置的原理时\",{\"1\":{\"583\":1}}],[\"我们在给所有行加锁的时候\",{\"1\":{\"447\":1}}],[\"我们在执行语句之前\",{\"1\":{\"406\":1}}],[\"我们在示例数据库sakila中的一个查询案例\",{\"1\":{\"390\":1}}],[\"我们在这个市民表上创建一个city和name的联合索引\",{\"1\":{\"356\":1}}],[\"我们在没有使用force\",{\"1\":{\"346\":1}}],[\"我们在字段\",{\"1\":{\"346\":1}}],[\"我们在应用中应该尽量使用主键查询\",{\"1\":{\"335\":1}}],[\"我们就能愉快地上\",{\"1\":{\"1981\":1}}],[\"我们就不得不先要理清楚一些及其重要的概念和几个核心类的作用\",{\"1\":{\"1613\":1}}],[\"我们就不得不定义一个新的函数\",{\"1\":{\"1598\":1}}],[\"我们就不应该使用二叉树\",{\"1\":{\"334\":1}}],[\"我们就更能直观的体会到\",{\"1\":{\"1595\":1}}],[\"我们就会围绕这两个问题展开\",{\"1\":{\"1607\":1}}],[\"我们就会遇到编译器无法自动推断\",{\"1\":{\"1593\":1}}],[\"我们就会使用消息中间件mq处理\",{\"1\":{\"601\":1}}],[\"我们就必须要编写很多个具体的方法\",{\"1\":{\"1599\":1}}],[\"我们就必须选择类似于priorityblockingqueue之类的有序排序能力的阻塞队列\",{\"1\":{\"1509\":1}}],[\"我们就必须先切换到备库b\",{\"1\":{\"459\":1}}],[\"我们就要充分利用redis工具包中提供的redis\",{\"1\":{\"1297\":1}}],[\"我们就要把sql语句改成基于字段本身的范围查询\",{\"1\":{\"366\":1}}],[\"我们就需要分析系统中为什么会有如此多的等待\",{\"1\":{\"538\":1}}],[\"我们就需要去binlog备份系统中找到这两个文件\",{\"1\":{\"485\":1}}],[\"我们就可能会设置auto\",{\"1\":{\"491\":1}}],[\"我们就可以独立完成一个小项目\",{\"1\":{\"1992\":1}}],[\"我们就可以重用\",{\"1\":{\"1615\":1}}],[\"我们就可以\",{\"1\":{\"1609\":1}}],[\"我们就可以定义一个通用的函数\",{\"1\":{\"1599\":1}}],[\"我们就可以把123这个作为$master\",{\"1\":{\"467\":1}}],[\"我们就可以按照随机算法2的思路\",{\"1\":{\"422\":1}}],[\"我们就可以通过分表规则\",{\"1\":{\"411\":1}}],[\"我们就算慢sql\",{\"1\":{\"428\":1}}],[\"我们就分别创建普通表t\",{\"1\":{\"424\":1}}],[\"我们就从这两种索引对查询语句和更新语句的性能来进行分析\",{\"1\":{\"341\":1}}],[\"我们还要学习mq\",{\"1\":{\"1984\":1}}],[\"我们还可以这样创建stream\",{\"1\":{\"1607\":1}}],[\"我们还可以使用一种特殊的方式来创建supplier的实例\",{\"1\":{\"1600\":1}}],[\"我们还可以自定义\",{\"1\":{\"1138\":1}}],[\"我们还可以自定义注解\",{\"1\":{\"1133\":1}}],[\"我们还可以从存储空间的角度来看\",{\"1\":{\"335\":1}}],[\"我们还是应该在innodb表中主动创建自增主键\",{\"1\":{\"495\":1}}],[\"我们还是以市民表中的联合索引\",{\"1\":{\"340\":1}}],[\"我们还需要把这个参数设置为空\",{\"1\":{\"467\":1}}],[\"我们用limit\",{\"1\":{\"348\":1}}],[\"我们用\",{\"1\":{\"339\":1}}],[\"我们只要记住单例和原型两种即可\",{\"1\":{\"983\":1,\"1235\":1}}],[\"我们只要在身份证号字段上建立索引就够了\",{\"1\":{\"338\":1}}],[\"我们只给d=5这一行加了锁\",{\"1\":{\"447\":1}}],[\"我们只需要了解基本使用即可\",{\"1\":{\"1978\":1}}],[\"我们只需要\",{\"1\":{\"1609\":1}}],[\"我们只需要取r值最小的3个rowid\",{\"1\":{\"421\":1}}],[\"我们只需要输入待查找的值即key\",{\"1\":{\"332\":1}}],[\"我们知道一般情况下分割迭代器返回的是iteratorspliterator实现\",{\"1\":{\"1622\":1}}],[\"我们知道前面介绍的那几种阻塞队列\",{\"1\":{\"1509\":1}}],[\"我们知道\",{\"1\":{\"338\":1,\"1601\":1}}],[\"我们来阅读一下方法的说明\",{\"1\":{\"1620\":1}}],[\"我们来阅读一下reducing方法的说明\",{\"1\":{\"1618\":1}}],[\"我们来阅读一下collect方法的说明\",{\"1\":{\"1608\":1}}],[\"我们来举个例子\",{\"1\":{\"1610\":1}}],[\"我们来举一个具体的例子来说明\",{\"1\":{\"1608\":1}}],[\"我们来了解一些关于流的特性\",{\"1\":{\"1608\":1}}],[\"我们来新建一个测试类\",{\"1\":{\"1600\":1}}],[\"我们来具体看一个例子\",{\"1\":{\"1595\":1}}],[\"我们来实现一个自定义的spring事件\",{\"1\":{\"1119\":1}}],[\"我们来使用相关的api\",{\"1\":{\"1103\":1}}],[\"我们来看接收参数最多的这个\",{\"1\":{\"1608\":1}}],[\"我们来看具体例子\",{\"1\":{\"1599\":1}}],[\"我们来看一下iteratorspliterator中对于foreachremaining的实现\",{\"1\":{\"1622\":1}}],[\"我们来看一下这个方法的说明\",{\"1\":{\"1620\":1}}],[\"我们来看一下supplier函数式接口的文档\",{\"1\":{\"1600\":1}}],[\"我们来看一下执行效果\",{\"1\":{\"347\":1}}],[\"我们来看一个具体的例子\",{\"1\":{\"1598\":1}}],[\"我们来看下在不同的隔离级别下\",{\"1\":{\"433\":1}}],[\"我们来看看这个delete语句的binlog是怎么记录的\",{\"1\":{\"454\":1}}],[\"我们来看看这两种方式会有什么问题\",{\"1\":{\"327\":1}}],[\"我们来看看mysql是如何选择的\",{\"1\":{\"347\":1}}],[\"我们来讨论一个问题\",{\"1\":{\"338\":1}}],[\"我们探讨一下索引的执行流程\",{\"1\":{\"336\":1}}],[\"我们从一个表的一条更新语句开始\",{\"1\":{\"323\":1}}],[\"我们会讨论到引擎的选择\",{\"1\":{\"317\":1}}],[\"反之写入的过程\",{\"1\":{\"1580\":1}}],[\"反映java虚拟机内部情况的jmxbean\",{\"1\":{\"1438\":1}}],[\"反序列化\",{\"1\":{\"1352\":1}}],[\"反射\",{\"1\":{\"1969\":1}}],[\"反射的作用\",{\"0\":{\"1559\":1}}],[\"反射的定义\",{\"0\":{\"1558\":1}}],[\"反射机制允许程序在执行时获取类自身的定义信息\",{\"1\":{\"1558\":1}}],[\"反射主要指程序可以访问\",{\"1\":{\"1558\":1}}],[\"反射api\",{\"1\":{\"1352\":1}}],[\"反射实现\",{\"1\":{\"1134\":2}}],[\"反而没有那么重要了\",{\"1\":{\"1595\":1}}],[\"反而由于线程数量过多会导致性能下降\",{\"1\":{\"1510\":1}}],[\"反而会降低服务端的性能\",{\"1\":{\"482\":1}}],[\"反而忽视了备库的压力控制\",{\"1\":{\"457\":1}}],[\"反而增加了change\",{\"1\":{\"344\":1}}],[\"反过来加深我们使用的时候的理解\",{\"1\":{\"1613\":1}}],[\"反过来\",{\"1\":{\"344\":1}}],[\"反向索引则是通过value找key\",{\"1\":{\"300\":1}}],[\"页缓存与内存映射\",{\"0\":{\"1845\":1}}],[\"页是磁盘和内存之间交互的基本单位\",{\"1\":{\"545\":1}}],[\"页面在写完以后马上被访问到的概率比较小\",{\"1\":{\"344\":1}}],[\"页分裂操作还影响数据页的利用率\",{\"1\":{\"335\":1}}],[\"提交异步任务\",{\"1\":{\"1517\":1}}],[\"提交任务的源码\",{\"1\":{\"1476\":1}}],[\"提交事务结果\",{\"1\":{\"1630\":1}}],[\"提交事务\",{\"1\":{\"1328\":1,\"1655\":1}}],[\"提交日志\",{\"1\":{\"561\":1}}],[\"提供的资料\",{\"1\":{\"1993\":1}}],[\"提供的filechannel\",{\"1\":{\"1588\":1}}],[\"提供了\",{\"1\":{\"1986\":1}}],[\"提供了aio功能\",{\"1\":{\"1572\":2}}],[\"提供了新的nio类库\",{\"1\":{\"1572\":1}}],[\"提供了动态创建数组及访问数组元素的静态方法\",{\"1\":{\"1560\":1}}],[\"提供了一些创建和操作流的底层方法\",{\"1\":{\"1621\":1}}],[\"提供了一系列方便操作对象的方法\",{\"1\":{\"1538\":1}}],[\"提供了一个容器并定义了用于沿着链传播入站和出战事件流的api\",{\"1\":{\"1224\":1}}],[\"提供了exactly\",{\"1\":{\"1333\":1}}],[\"提供了restful风格的操作接口\",{\"1\":{\"1254\":1}}],[\"提供标准javabeans分析和操作\",{\"1\":{\"1074\":1}}],[\"提供条件分支流程\",{\"1\":{\"1035\":1}}],[\"提供这个方法的主要原因是之前的beanpostprocessor接口提供的回调\",{\"1\":{\"1009\":1}}],[\"提供给外部使用的接口api\",{\"1\":{\"645\":1}}],[\"提前主动加载热点数据到缓存中\",{\"1\":{\"1283\":1}}],[\"提前进行aop\",{\"1\":{\"1237\":1}}],[\"提前安排注入规则\",{\"1\":{\"951\":1}}],[\"提前结束某种顺序的成本评估\",{\"1\":{\"556\":1}}],[\"提高效率\",{\"1\":{\"1503\":1}}],[\"提高了安全性\",{\"1\":{\"1501\":1}}],[\"提高了系统的效率\",{\"1\":{\"1474\":1}}],[\"提高了数据库并发读写的性能\",{\"1\":{\"541\":1}}],[\"提高线程的可管理性\",{\"1\":{\"1407\":1}}],[\"提高响应速度\",{\"1\":{\"1407\":1}}],[\"提高系统的稳定性和可扩展性\",{\"1\":{\"1326\":1}}],[\"提高系统的安全性\",{\"1\":{\"1210\":1}}],[\"提高查询效率\",{\"1\":{\"1252\":1}}],[\"提高并发量\",{\"1\":{\"607\":1}}],[\"提高区间访问的性能\",{\"1\":{\"503\":1}}],[\"提高内存利用率\",{\"1\":{\"343\":1}}],[\"提示\",{\"1\":{\"481\":1}}],[\"提示出现了主键冲突\",{\"1\":{\"467\":1}}],[\"提升消费速度\",{\"0\":{\"1858\":1}}],[\"提升数据拷贝效率\",{\"1\":{\"1576\":1}}],[\"提升并发度\",{\"1\":{\"443\":1}}],[\"提升查询性能\",{\"1\":{\"407\":1}}],[\"提升性能\",{\"1\":{\"307\":1}}],[\"语言起源开始\",{\"1\":{\"1969\":1}}],[\"语言有一个初步的了解\",{\"1\":{\"1969\":1}}],[\"语言基础\",{\"1\":{\"1966\":2}}],[\"语义是把id=0\",{\"1\":{\"447\":1}}],[\"语义的逻辑是相同的\",{\"1\":{\"348\":1}}],[\"语句\",{\"1\":{\"1297\":1}}],[\"语句块捕获\",{\"1\":{\"1239\":1}}],[\"语句返回\",{\"1\":{\"491\":1}}],[\"语句才算真正完成\",{\"1\":{\"481\":1}}],[\"语句从开始进入终止逻辑\",{\"1\":{\"481\":1}}],[\"语句处于锁等待的时候\",{\"1\":{\"480\":1}}],[\"语句在节点a执行\",{\"1\":{\"453\":1}}],[\"语句的执行流程如下\",{\"1\":{\"407\":1}}],[\"语句的执行速度会得到明显的提升\",{\"1\":{\"343\":1}}],[\"语句执行过程中\",{\"1\":{\"492\":1}}],[\"语句执行失败也不会回退自增id\",{\"1\":{\"491\":1}}],[\"语句执行就结束了\",{\"1\":{\"343\":1}}],[\"语句执行结束\",{\"1\":{\"343\":1}}],[\"语法解析\",{\"1\":{\"557\":1}}],[\"语法\",{\"1\":{\"329\":1}}],[\"语法分析由bison生成\",{\"1\":{\"513\":1}}],[\"语法分析器会根据语法规则\",{\"1\":{\"320\":1}}],[\"语法分析\",{\"1\":{\"320\":1}}],[\"虽然通过countdownlatch等工具类也可以实现任务的编排\",{\"1\":{\"1518\":1}}],[\"虽然java中互斥和同步都可以采用synchronized关键字来完成\",{\"1\":{\"1482\":1}}],[\"虽然高效地解决了原子操作\",{\"1\":{\"1479\":1}}],[\"虽然中间有一条命令报错了\",{\"1\":{\"580\":1}}],[\"虽然表中的记录其实都存储在聚簇索引对应b+树的叶子结点中\",{\"1\":{\"548\":1}}],[\"虽然mysql重启不会导致同一个binlog里面出现两个相同的xid\",{\"1\":{\"496\":1}}],[\"虽然248\",{\"1\":{\"495\":1}}],[\"虽然自然数是没有上限的\",{\"1\":{\"493\":1}}],[\"虽然可以通过利用并行复制来加速恢复数据的过程\",{\"1\":{\"486\":1}}],[\"虽然12号线程的状态已经设置成了kill\",{\"1\":{\"481\":1}}],[\"虽然说等锁的线程不算在并发线程计数里\",{\"1\":{\"476\":1}}],[\"虽然实例x还是会继续执行实例y传过来的事务\",{\"1\":{\"468\":1}}],[\"虽然都最终可以建立从库b和新主库a\",{\"1\":{\"468\":1}}],[\"虽然随着中转日志的继续应用\",{\"1\":{\"459\":1}}],[\"虽然节点b并没有被直接访问\",{\"1\":{\"453\":1}}],[\"虽然间隙锁也是一种锁\",{\"1\":{\"448\":1}}],[\"虽然最终的结果是主备一致的\",{\"1\":{\"460\":1}}],[\"虽然最终检测的结果是没有死锁\",{\"1\":{\"444\":1}}],[\"虽然最终也能得到前3个值\",{\"1\":{\"421\":1}}],[\"虽然能够快速发现并进行处理的\",{\"1\":{\"444\":1}}],[\"虽然数据量不大\",{\"1\":{\"441\":1}}],[\"虽然查询结果相同\",{\"1\":{\"425\":1}}],[\"虽然session\",{\"1\":{\"425\":1}}],[\"虽然解决了算法1里明显的概率不均匀的问题\",{\"1\":{\"422\":1}}],[\"虽然解决了全表扫描的问题\",{\"1\":{\"361\":1}}],[\"虽然还是按行查\",{\"1\":{\"404\":1}}],[\"虽然分成两次放入join\",{\"1\":{\"403\":1}}],[\"虽然也可以得到正确的结果\",{\"1\":{\"402\":1}}],[\"虽然主键id一定不为空\",{\"1\":{\"399\":1}}],[\"虽然在t\",{\"1\":{\"366\":1}}],[\"虽然index2已经包含了所有的信息\",{\"1\":{\"351\":1}}],[\"虽然从执行时间上来看\",{\"1\":{\"347\":1}}],[\"虽然这个表的每一行的三个字段值都是一样的\",{\"1\":{\"347\":1}}],[\"虽然名字叫做change\",{\"1\":{\"343\":1}}],[\"虽然密码也可以直接跟在\",{\"1\":{\"318\":1}}],[\"唯一的区别在于\",{\"1\":{\"1644\":1}}],[\"唯一的区别就是省掉cpu参与环节的方式不同\",{\"1\":{\"1585\":1}}],[\"唯一id\",{\"1\":{\"1333\":1}}],[\"唯一键查询\",{\"0\":{\"1923\":1}}],[\"唯一键冲突\",{\"1\":{\"491\":1}}],[\"唯一键\",{\"1\":{\"462\":1}}],[\"唯一\",{\"1\":{\"358\":1}}],[\"唯一索引\",{\"1\":{\"1248\":1,\"1276\":1}}],[\"唯一索引查询\",{\"1\":{\"390\":1}}],[\"唯一索引的更新就不能使用change\",{\"1\":{\"343\":1}}],[\"唯一索引和普通索引并没有性能上的差距\",{\"1\":{\"342\":1}}],[\"唯一性索引扫描\",{\"1\":{\"330\":1}}],[\"总体会占用比较多的时间\",{\"1\":{\"1510\":1}}],[\"总体来说有以下好处\",{\"1\":{\"1265\":1}}],[\"总体来看\",{\"1\":{\"407\":1}}],[\"总线的大小及其提供的带宽也必须增加\",{\"1\":{\"1474\":1}}],[\"总来的来说\",{\"1\":{\"1005\":1}}],[\"总的来说在进行中间操作的时候\",{\"1\":{\"1623\":1}}],[\"总的来说分为两种情况\",{\"1\":{\"1618\":1}}],[\"总的来说构造方法与普通方法的区别如下\",{\"1\":{\"1346\":1}}],[\"总的来说\",{\"1\":{\"499\":1,\"963\":1,\"1008\":1,\"1328\":1,\"1353\":1,\"1594\":1,\"1611\":1}}],[\"总结来看\",{\"1\":{\"1565\":1}}],[\"总结如下表\",{\"1\":{\"1423\":1}}],[\"总结一下\",{\"1\":{\"554\":1,\"1617\":1}}],[\"总结\",{\"1\":{\"430\":1,\"1181\":1,\"1286\":1,\"1287\":1}}],[\"总扫描行数变成了20003\",{\"1\":{\"420\":1}}],[\"总扫描行数是200\",{\"1\":{\"401\":1}}],[\"总共可以分为下面几个阶段\",{\"1\":{\"1008\":1}}],[\"总共从redo\",{\"1\":{\"479\":1}}],[\"总共需要扫描c+y+1行\",{\"1\":{\"422\":1}}],[\"总共需要在内存中做判断的次数是100\",{\"1\":{\"403\":1}}],[\"总共扫描100\",{\"1\":{\"402\":1}}],[\"总共18位\",{\"1\":{\"352\":1}}],[\"总是认为不会产生并发问题\",{\"1\":{\"1399\":1}}],[\"总是假设最坏的情况\",{\"1\":{\"1399\":1}}],[\"总是要找一个\",{\"1\":{\"467\":1}}],[\"总是取到最新的数据\",{\"1\":{\"438\":1}}],[\"总是取出全部列\",{\"0\":{\"385\":1}}],[\"总是跟这个事务在启动的时候看到的数据是一致的\",{\"1\":{\"433\":1}}],[\"总是保持最大值在堆顶\",{\"1\":{\"421\":1}}],[\"总是强调需要数据库层完成尽可能多的工作\",{\"1\":{\"392\":1}}],[\"总是会使用连接器连接到这个数据库上\",{\"1\":{\"318\":1}}],[\"总而言之combiner被调用有两个条件\",{\"1\":{\"1617\":1}}],[\"总而言之\",{\"1\":{\"342\":1,\"404\":1,\"444\":1,\"454\":1,\"459\":1,\"472\":1,\"520\":1,\"542\":2,\"921\":1,\"1182\":1,\"1618\":1}}],[\"仍然可以学习这个项目\",{\"1\":{\"1987\":1}}],[\"仍然可能丢失更新\",{\"1\":{\"397\":1}}],[\"仍然会存在一个线程需要等待另外的线程完成后继续下一步操作\",{\"1\":{\"1530\":1}}],[\"仍然假设s1表是驱动表的话\",{\"1\":{\"554\":1}}],[\"仍然能够把数据恢复回来\",{\"1\":{\"327\":1}}],[\"仍可以认为这个操作成本对于现在的cpu来说可以忽略不计\",{\"1\":{\"342\":1}}],[\"后端\",{\"1\":{\"1978\":1}}],[\"后端信息维护等工作\",{\"1\":{\"469\":1}}],[\"后拦截器\",{\"1\":{\"1657\":1}}],[\"后续真正加载的时候会被替换为class对象\",{\"1\":{\"1647\":1}}],[\"后续的去重操作当然也都失败了\",{\"1\":{\"1609\":1}}],[\"后续的文章我们有专门的篇幅来介绍方法引用\",{\"1\":{\"1593\":1}}],[\"后续如果有需要\",{\"1\":{\"1509\":1}}],[\"后继节点\",{\"1\":{\"1503\":1}}],[\"后来\",{\"1\":{\"1483\":1}}],[\"后台接口访问权限\",{\"1\":{\"1199\":1}}],[\"后台线程会主动写盘\",{\"1\":{\"451\":1}}],[\"后缀模式\",{\"1\":{\"900\":1}}],[\"后者称为从节点\",{\"1\":{\"606\":1}}],[\"后边我们会重点看这个属性的\",{\"1\":{\"553\":1}}],[\"后面会越轻松\",{\"1\":{\"1969\":1}}],[\"后面的将不会再被计算\",{\"1\":{\"1599\":1}}],[\"后面的表示类的哈希值\",{\"1\":{\"1592\":1}}],[\"后面的n刚好在0到length之间\",{\"1\":{\"1548\":1}}],[\"后面的版本采用了事件回放的机制修复了这个bug\",{\"1\":{\"1122\":1}}],[\"后面的1\",{\"1\":{\"548\":2}}],[\"后面在初始化的时候\",{\"1\":{\"975\":1}}],[\"后面还有一个链表\",{\"1\":{\"332\":1}}],[\"后写入的数据会覆盖之前的数据\",{\"1\":{\"499\":1}}],[\"后一次查询看到了前一次查询没有看到的行\",{\"1\":{\"446\":1}}],[\"后访问的事务必须等待前一个事务执行完成\",{\"1\":{\"433\":1}}],[\"后执行\",{\"1\":{\"422\":1}}],[\"后\",{\"1\":{\"342\":1,\"1484\":1,\"1485\":1}}],[\"作用和beandefinitionreader类似\",{\"1\":{\"1635\":1}}],[\"作用是将输入元素累积到一个可变的结果容器当中\",{\"1\":{\"1615\":1}}],[\"作用于工作内存的变量\",{\"1\":{\"1473\":4}}],[\"作用于主内存变量\",{\"1\":{\"1473\":2}}],[\"作用于主内存的变量\",{\"1\":{\"1473\":2}}],[\"作用能提高系统的响应速度和吞吐量\",{\"1\":{\"1326\":1}}],[\"作用域简介\",{\"0\":{\"983\":1}}],[\"作用域代理schema\",{\"0\":{\"828\":1}}],[\"作用\",{\"0\":{\"607\":1,\"619\":1,\"649\":1},\"1\":{\"1224\":1,\"1432\":1,\"1454\":1}}],[\"作用如下\",{\"1\":{\"309\":1}}],[\"作者id\",{\"1\":{\"361\":1}}],[\"作为开发人员访问方法区中类定义的入口和切入点\",{\"1\":{\"1663\":1}}],[\"作为方法区这个类的各种数据的访问入口\",{\"1\":{\"1663\":1}}],[\"作为collect\",{\"1\":{\"1608\":1}}],[\"作为进程\",{\"1\":{\"1291\":1}}],[\"作为udp协议通信中的一段\",{\"1\":{\"1226\":1}}],[\"作为netty\",{\"1\":{\"1226\":1}}],[\"作为rpc框架的网络通信工具\",{\"1\":{\"1223\":1}}],[\"作为ioc容器的特性\",{\"1\":{\"909\":1}}],[\"作为主节点的备份\",{\"1\":{\"621\":1}}],[\"作为主键并不合适\",{\"1\":{\"341\":1}}],[\"作为旧记录\",{\"1\":{\"542\":2}}],[\"作为新的自增值\",{\"1\":{\"491\":1}}],[\"作为多用户共享的资源\",{\"1\":{\"436\":1}}],[\"作为结果集的一部分返回\",{\"1\":{\"403\":2}}],[\"作为结果集的一部分\",{\"1\":{\"401\":1}}],[\"作为结果集的一部分直接返回\",{\"1\":{\"356\":3}}],[\"到时就产生一个代理对象作为bean\",{\"1\":{\"1655\":1}}],[\"到时候\",{\"1\":{\"1653\":1}}],[\"到目前这个阶段\",{\"1\":{\"1615\":1}}],[\"到整个操作序列的外部\",{\"1\":{\"1486\":1}}],[\"到底什么是lambda表达式呢\",{\"1\":{\"1593\":1}}],[\"到底是先删缓存\",{\"1\":{\"1285\":1}}],[\"到底应该怎么办呢\",{\"1\":{\"396\":1}}],[\"到备库执行的时候\",{\"1\":{\"492\":1}}],[\"到终止逻辑完全完成\",{\"1\":{\"481\":1}}],[\"到主库执行查询语句\",{\"1\":{\"473\":1,\"474\":1}}],[\"到主键索引上找出相应的记录\",{\"1\":{\"518\":1}}],[\"到主键索引上找出数据行\",{\"1\":{\"340\":1}}],[\"到主键id索引取出整行\",{\"1\":{\"354\":1,\"355\":1,\"356\":1}}],[\"到主键查找到主键是id1的行\",{\"1\":{\"350\":1}}],[\"到主键上查找到主键值是id2的行\",{\"1\":{\"350\":1}}],[\"到应用完file和pos表示的binlog位置\",{\"1\":{\"473\":1}}],[\"到本地执行\",{\"1\":{\"453\":1}}],[\"到这里\",{\"1\":{\"422\":1,\"1234\":1}}],[\"到此\",{\"1\":{\"420\":1}}],[\"到哈希表中寻找匹配的数据\",{\"1\":{\"408\":1}}],[\"到被驱动表上匹配一次\",{\"1\":{\"401\":1}}],[\"到50\",{\"1\":{\"396\":1}}],[\"到服务器\",{\"1\":{\"381\":1}}],[\"到\",{\"1\":{\"354\":1,\"529\":5}}],[\"到末尾又回到开头循环写入\",{\"1\":{\"324\":1}}],[\"通俗点说\",{\"1\":{\"1985\":1}}],[\"通俗易懂\",{\"1\":{\"1971\":1}}],[\"通俗的说就是一个接口\",{\"1\":{\"1248\":1}}],[\"通信机制\",{\"0\":{\"1847\":1}}],[\"通信的\",{\"1\":{\"624\":1}}],[\"通道可以用户读\",{\"1\":{\"1574\":1}}],[\"通道是双向的\",{\"1\":{\"1574\":1}}],[\"通配路径resourceloader\",{\"1\":{\"1042\":1}}],[\"通知对象\",{\"1\":{\"1125\":1}}],[\"通知相关的客户端关于master地址已经发生改变的信息\",{\"1\":{\"624\":1}}],[\"通知脚本\",{\"1\":{\"624\":1}}],[\"通知型脚本\",{\"1\":{\"624\":1}}],[\"通用formatter\",{\"1\":{\"1092\":1}}],[\"通用conversionservice模板实现\",{\"1\":{\"1092\":1}}],[\"通用实现\",{\"1\":{\"1087\":1}}],[\"通用类型转换接口\",{\"0\":{\"1086\":1},\"1\":{\"1086\":1,\"1096\":1}}],[\"通用类型转换\",{\"1\":{\"1084\":1}}],[\"通用类型转换实现\",{\"1\":{\"1080\":1}}],[\"通用类型实现\",{\"1\":{\"1084\":1}}],[\"通用组件模式注解\",{\"1\":{\"1023\":1,\"1131\":1}}],[\"通用型beandefinition\",{\"1\":{\"1018\":1}}],[\"通用\",{\"1\":{\"431\":2}}],[\"通用分区策略\",{\"1\":{\"425\":1}}],[\"通常都是由于永久代或元空间发生了大小调整\",{\"1\":{\"1664\":1}}],[\"通常都是用在允许消息少量丢失的场景\",{\"1\":{\"1328\":1}}],[\"通常都走else的逻辑\",{\"1\":{\"1655\":1}}],[\"通常情况都是一对一的\",{\"1\":{\"1654\":1}}],[\"通常情况下我们通过rbac模型\",{\"1\":{\"1199\":1}}],[\"通常情况下我们会使用默认的namespace\",{\"1\":{\"1021\":1}}],[\"通常情况下\",{\"1\":{\"413\":1,\"467\":1,\"470\":1,\"476\":1,\"1165\":1}}],[\"通常会先先执行postprocessbeandefinitionregistry方法\",{\"1\":{\"1652\":1}}],[\"通常用来高效的处理一些集合的运算\",{\"1\":{\"1593\":1}}],[\"通常通过一个独立的acceptor线程负责监听客户端的连接\",{\"1\":{\"1573\":1}}],[\"通常适用于一个线程写\",{\"1\":{\"1384\":1}}],[\"通常文件大小不要超过1\",{\"1\":{\"1330\":1,\"1331\":1}}],[\"通常所说的springcloud是指springcloud\",{\"1\":{\"1305\":1}}],[\"通常对于分布式锁\",{\"1\":{\"1288\":1}}],[\"通常要求写操作不会太频繁\",{\"1\":{\"1286\":1}}],[\"通常是获取锁和释放锁的方法\",{\"1\":{\"1400\":1}}],[\"通常是针对mysql当中的自增字段\",{\"1\":{\"1263\":1}}],[\"通常是controller中对应的一个方法\",{\"1\":{\"1241\":1}}],[\"通常使用spring\",{\"1\":{\"1204\":1}}],[\"通常不会直接使用\",{\"1\":{\"1074\":1}}],[\"通常需要活对象的2倍大小\",{\"1\":{\"1439\":1}}],[\"通常需要使用方法递归或者嵌套解析的方式处理嵌套\",{\"1\":{\"1036\":1}}],[\"通常需要依赖容器或标准api实现\",{\"1\":{\"915\":1}}],[\"通常在spring\",{\"1\":{\"1009\":1,\"1011\":1}}],[\"通常bean的名称为类名的首字母小写\",{\"1\":{\"995\":1}}],[\"通常bean的标识符由字母组成\",{\"1\":{\"928\":1}}],[\"通常\",{\"1\":{\"928\":1,\"1375\":1}}],[\"通常非常快\",{\"1\":{\"589\":1}}],[\"通常有三种做法\",{\"1\":{\"472\":1}}],[\"通常我们会定义一个类型转换器\",{\"1\":{\"1638\":1}}],[\"通常我们比较两个对象时\",{\"1\":{\"1605\":1}}],[\"通常我们可以从以下5个角度考虑\",{\"1\":{\"1509\":1}}],[\"通常我们在主动切换的时候\",{\"1\":{\"459\":1}}],[\"通常我们说的mysql的\",{\"1\":{\"451\":1}}],[\"通常我们使用分区表的一个重要原因就是单表过大\",{\"1\":{\"424\":1}}],[\"通常我们就会根据索引的复用能力来确定索引内的字段顺序\",{\"1\":{\"339\":1}}],[\"通常可以使用select\",{\"1\":{\"395\":1}}],[\"通常来说\",{\"1\":{\"381\":1,\"457\":1,\"1330\":1}}],[\"通过利用spring的扫描后\",{\"1\":{\"1653\":1}}],[\"通过getbean\",{\"1\":{\"1650\":1}}],[\"通过georadius就可以完成\",{\"1\":{\"576\":1}}],[\"通过编程式声明bean对象\",{\"1\":{\"1632\":1}}],[\"通过编程的方式校验目标对象\",{\"1\":{\"1061\":1}}],[\"通过xml方式配置和使用注解等方式声明的bean\",{\"1\":{\"1632\":1}}],[\"通过xml的方式注入演示的示例\",{\"1\":{\"953\":1}}],[\"通过xml的方式注入\",{\"1\":{\"953\":1}}],[\"通过事务管理器\",{\"1\":{\"1630\":1}}],[\"通过支持解耦\",{\"1\":{\"1620\":1}}],[\"通过特性值sized获取到的值就是之后遍历元素个数的值\",{\"1\":{\"1620\":1}}],[\"通过reducing方法来实现\",{\"1\":{\"1618\":1}}],[\"通过redis\",{\"1\":{\"568\":1}}],[\"通过管道的方式获取值\",{\"1\":{\"1608\":1}}],[\"通过代码我们会发现\",{\"1\":{\"1574\":1}}],[\"通过代码我们可以发现bio的主要问题在于\",{\"1\":{\"1573\":1}}],[\"通过遍历文件描述符来获取已经就绪的socket\",{\"1\":{\"1570\":1}}],[\"通过打听\",{\"1\":{\"1561\":1}}],[\"通过unsafe\",{\"1\":{\"1554\":1}}],[\"通过uri搜索\",{\"1\":{\"306\":1}}],[\"通过设置断点让线程1和线程2同时debug到transfer方法的首行\",{\"1\":{\"1551\":1}}],[\"通过设置slave\",{\"1\":{\"467\":1}}],[\"通过hashcode\",{\"1\":{\"1548\":1}}],[\"通过位运算\",{\"1\":{\"1519\":1}}],[\"通过调用它的take方法或poll方法可以获取到一个已经执行完成的future\",{\"1\":{\"1517\":1}}],[\"通过调用关系\",{\"1\":{\"1000\":1}}],[\"通过任务窃取\",{\"1\":{\"1514\":1}}],[\"通过逃逸分析\",{\"1\":{\"1488\":1}}],[\"通过逃逸分析技术判别程序中所使用的锁对象是否只被一个线程所使用\",{\"1\":{\"1393\":1}}],[\"通过锁消除\",{\"1\":{\"1487\":1}}],[\"通过对比\",{\"1\":{\"1575\":1}}],[\"通过对运行上下文的扫描\",{\"1\":{\"1487\":1}}],[\"通过对多线程的串行化来访问公共资源或一段代码\",{\"1\":{\"1477\":1}}],[\"通过lambda表达式我们可以将上述代码优雅的表示为\",{\"1\":{\"1593\":1}}],[\"通过lock保证可见性\",{\"1\":{\"1471\":1}}],[\"通过lua脚本来保证原子性\",{\"1\":{\"1288\":1}}],[\"通过内存屏障保障可见性\",{\"1\":{\"1471\":1}}],[\"通过内置的双向链表来完成资源获取的线程的排队工作\",{\"1\":{\"1400\":1}}],[\"通过volatile关键字保证可见性\",{\"1\":{\"1471\":1}}],[\"通过new关键赋值的引用\",{\"1\":{\"1435\":1}}],[\"通过链表实现\",{\"1\":{\"1423\":1}}],[\"通过重新计算索引位置后\",{\"1\":{\"1550\":1}}],[\"通过重复利用已创建的线程降低线程创建和销毁造成的消耗\",{\"1\":{\"1407\":1}}],[\"通过重构查询将关联当到应用程序中将会更加高效\",{\"1\":{\"394\":1}}],[\"通过线程池来开启线程\",{\"1\":{\"1377\":1}}],[\"通过java命令执行代码的大体流程如下\",{\"1\":{\"1663\":1}}],[\"通过java注解配置元信息\",{\"1\":{\"929\":1}}],[\"通过jenkins自动化构建任务\",{\"1\":{\"1310\":1}}],[\"通过将大型的单体应用划分为比较小的服务单元\",{\"1\":{\"1304\":1}}],[\"通过定时任务或异步线程更新缓存\",{\"1\":{\"1283\":1}}],[\"通过final关键字保证可见性\",{\"1\":{\"1471\":1}}],[\"通过fileregion包装的filechannel\",{\"1\":{\"1231\":1}}],[\"通过futuretask创建一个线程\",{\"1\":{\"1377\":1}}],[\"通过factorybean\",{\"1\":{\"930\":1}}],[\"通过<resultmap>来映射字段名和实体类属性名的一一对应的关系\",{\"1\":{\"1211\":1}}],[\"通过在查询的sql语句中定义字段名的别名\",{\"1\":{\"1211\":1}}],[\"通过某种机制\",{\"1\":{\"1200\":1}}],[\"通过响应头的方式保存到客户端浏览器的cookie当中\",{\"1\":{\"1200\":1}}],[\"通过org\",{\"1\":{\"1091\":1,\"1149\":2}}],[\"通过objecterror和fielderror关联messagesource实现获取最终文案\",{\"1\":{\"1064\":1}}],[\"通过objecterror和fielderror中的code和args关联messagesource实现\",{\"1\":{\"1063\":1}}],[\"通过objectprovider进行依赖查找\",{\"1\":{\"940\":1}}],[\"通过environmentaware接口回调\",{\"1\":{\"1148\":1}}],[\"通过environment\",{\"1\":{\"1144\":1,\"1149\":1}}],[\"通过errors对象收集错误\",{\"1\":{\"1064\":1}}],[\"通过explain命令可以这条语句执行的情况\",{\"1\":{\"346\":1}}],[\"通过外部化配置\",{\"1\":{\"1035\":1}}],[\"通过资源抽象\",{\"1\":{\"1035\":1}}],[\"通过媒介\",{\"1\":{\"1035\":2}}],[\"通过指定的classpath获取resource对象\",{\"1\":{\"1022\":1}}],[\"通过源码分析\",{\"1\":{\"1000\":1}}],[\"通过观察beandefinition源代码可以发现\",{\"1\":{\"984\":1}}],[\"通过类型查找\",{\"1\":{\"963\":1}}],[\"通过注解的定义我们可以看到\",{\"1\":{\"961\":1}}],[\"通过注解类型查找\",{\"1\":{\"941\":1}}],[\"通过注解查找\",{\"1\":{\"917\":2,\"941\":1}}],[\"通过不同时机的打印\",{\"1\":{\"933\":1}}],[\"通过aopcontext\",{\"1\":{\"1654\":1}}],[\"通过applicationaware接口回调\",{\"1\":{\"1148\":1}}],[\"通过applicationeventpublisheraware回调接口\",{\"1\":{\"1120\":1}}],[\"通过applicationeventpublisher发布spring事件\",{\"1\":{\"1115\":2}}],[\"通过applicationcontext获取autowirecapablebeanfactory\",{\"1\":{\"930\":1}}],[\"通过autowirecapablebeanfactory创建userfactory对象\",{\"1\":{\"930\":1}}],[\"通过autowirecapablebeanfactory实例化\",{\"1\":{\"930\":1}}],[\"通过autowirecapablebeanfactory\",{\"1\":{\"930\":1}}],[\"通过abstactbeandefinition以及派生类\",{\"1\":{\"927\":2}}],[\"通过静态工厂方法\",{\"1\":{\"930\":1}}],[\"通过构造器\",{\"1\":{\"930\":1}}],[\"通过cglib或者jdk的动态代理来实现aop\",{\"1\":{\"1654\":1}}],[\"通过cglib技术\",{\"1\":{\"1654\":1}}],[\"通过collectorimpl来实现\",{\"1\":{\"1618\":1}}],[\"通过copy\",{\"1\":{\"1527\":1}}],[\"通过configurableapplicationcontext\",{\"1\":{\"1114\":1}}],[\"通过conversionservicefactorybean\",{\"1\":{\"1091\":1}}],[\"通过component方式\",{\"1\":{\"929\":1}}],[\"通过change\",{\"1\":{\"486\":1}}],[\"通过mutablepropertyvalues批量操作属性\",{\"1\":{\"927\":1}}],[\"通过属性设置\",{\"1\":{\"927\":1}}],[\"通过beanfactory可以获取到beannameaware\",{\"1\":{\"1005\":1}}],[\"通过beanfacotry的方式\",{\"1\":{\"1005\":1}}],[\"通过bean\",{\"1\":{\"994\":1}}],[\"通过bean名称限定\",{\"1\":{\"961\":1}}],[\"通过beandefinition和外部单体对象来注册\",{\"1\":{\"936\":1}}],[\"通过beandefinitionresgistry\",{\"1\":{\"930\":1}}],[\"通过beandefinitionbuilder\",{\"1\":{\"927\":2}}],[\"通过bean工厂方法\",{\"1\":{\"930\":1}}],[\"通过binlog输出到外部系统\",{\"1\":{\"457\":1}}],[\"通过名称byname\",{\"1\":{\"927\":1}}],[\"通过导入复用\",{\"1\":{\"918\":1}}],[\"通过依赖注入\",{\"1\":{\"906\":1}}],[\"通过加锁或者队列来控制读数据库写缓存的线程数量\",{\"1\":{\"633\":1}}],[\"通过发送命令\",{\"1\":{\"620\":1}}],[\"通过多个从节点分担负载\",{\"1\":{\"607\":1}}],[\"通过info\",{\"1\":{\"588\":1}}],[\"通过使用这些template来间接操作组件\",{\"1\":{\"583\":1}}],[\"通过分组限定\",{\"1\":{\"961\":1}}],[\"通过分数返回有序集合指定区间内的成员\",{\"1\":{\"574\":1}}],[\"通过分析两条sql的执行计划来分析性能\",{\"1\":{\"371\":1}}],[\"通过字典区间返回有序集合的成员\",{\"1\":{\"574\":1}}],[\"通过下标截取指定范围内的列表\",{\"1\":{\"571\":1}}],[\"通过索引\",{\"1\":{\"574\":1}}],[\"通过索引区间返回有序集合成指定区间内的成员\",{\"1\":{\"574\":1}}],[\"通过索引为元素设值\",{\"1\":{\"571\":1}}],[\"通过索引获取列表元素\",{\"1\":{\"571\":1}}],[\"通过ttl命令返回key的过期时间\",{\"1\":{\"569\":1}}],[\"通过进行对redis\",{\"1\":{\"569\":1}}],[\"通过data\",{\"1\":{\"548\":1}}],[\"通过statelessop创建饮水槽\",{\"1\":{\"1623\":1}}],[\"通过synchronized关键字保证线程安全\",{\"1\":{\"1555\":1}}],[\"通过sychronized关键字保证可见性\",{\"1\":{\"1471\":1}}],[\"通过signal或signalall将条件队列中的节点转移到同步队列\",{\"1\":{\"1491\":1}}],[\"通过source来判断\",{\"1\":{\"1019\":1}}],[\"通过serviceloaderfactorybean\",{\"1\":{\"930\":1}}],[\"通过set\",{\"1\":{\"454\":1}}],[\"通过sql\",{\"1\":{\"468\":1}}],[\"通过上图还是不能看出详细的信息\",{\"1\":{\"454\":1}}],[\"通过显式语句的方式来启动事务\",{\"1\":{\"435\":1}}],[\"通过回滚操作\",{\"1\":{\"434\":1}}],[\"通过优先队列排序找到最小的三个r值的行的过程\",{\"1\":{\"421\":1}}],[\"通过优化器知道了该怎么做\",{\"1\":{\"322\":1}}],[\"通过这种元创建的spliterator会返回一个concurrent的特性值\",{\"1\":{\"1620\":1}}],[\"通过这种元创建的spliterator会返回一个immutable的特性值\",{\"1\":{\"1620\":1}}],[\"通过这种方式就可以得到一个不可变的集合列表\",{\"1\":{\"1618\":1}}],[\"通过这种方式就能保证这个数据逻辑的正确性\",{\"1\":{\"343\":1}}],[\"通过这种方式可以优雅的停止线程\",{\"1\":{\"1175\":1}}],[\"通过这种方式装在的bean的名称就是\",{\"1\":{\"1026\":1}}],[\"通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式\",{\"1\":{\"1473\":1}}],[\"通过这个例子说明了lambda表达式与匿名内部类有着本质的区别\",{\"1\":{\"1592\":1}}],[\"通过这个api的拦截\",{\"1\":{\"1003\":1}}],[\"通过这个设置就可以保证一定可以使用mrr优化\",{\"1\":{\"404\":1}}],[\"通过以上的分析\",{\"1\":{\"401\":1}}],[\"通过以上两种情况的对比\",{\"1\":{\"350\":1}}],[\"通过如下两个步骤来分析总是非常有效\",{\"1\":{\"381\":1}}],[\"通过它们的执行过程能更加清楚看到这一点\",{\"1\":{\"350\":1}}],[\"通过查看表结构知道\",{\"1\":{\"330\":1}}],[\"通过执行mysql\",{\"1\":{\"318\":1}}],[\"通过\",{\"1\":{\"307\":1,\"929\":2,\"1120\":1,\"1138\":6,\"1148\":2,\"1653\":1}}],[\"通过请求体搜索的示例\",{\"1\":{\"306\":1}}],[\"通过主键定位到某条数据\",{\"1\":{\"300\":1}}],[\"通过之前建立好的索引来查询\",{\"1\":{\"299\":1}}],[\"通过一个程序扫描文本中的每一个单词\",{\"1\":{\"299\":1}}],[\"姓名\",{\"1\":{\"338\":1,\"510\":1,\"518\":1}}],[\"身份证号\",{\"1\":{\"338\":1}}],[\"身份证号是市民的唯一标识\",{\"1\":{\"338\":1}}],[\"`k1`\",{\"1\":{\"580\":1}}],[\"`georadius\",{\"1\":{\"576\":1}}],[\"`linsert\",{\"1\":{\"571\":1}}],[\"`s1`\",{\"1\":{\"555\":3}}],[\"`s2`\",{\"1\":{\"555\":3}}],[\"`staffs`\",{\"1\":{\"370\":6,\"371\":2,\"372\":2,\"373\":2,\"374\":2,\"375\":12,\"376\":3}}],[\"`step\",{\"1\":{\"368\":1}}],[\"`error`\",{\"1\":{\"580\":1}}],[\"`expire\",{\"1\":{\"553\":3,\"555\":4}}],[\"`employees`\",{\"1\":{\"510\":1,\"518\":1,\"519\":23,\"520\":2}}],[\"`emp`\",{\"1\":{\"431\":5}}],[\"`order\",{\"1\":{\"553\":10,\"555\":2}}],[\"`operator`\",{\"1\":{\"366\":1}}],[\"`optimizer\",{\"1\":{\"354\":1,\"421\":1}}],[\"`mysqladv`\",{\"1\":{\"553\":7,\"555\":6}}],[\"`mylock`\",{\"1\":{\"534\":5}}],[\"`hire\",{\"1\":{\"510\":1,\"518\":1,\"519\":2}}],[\"`health\",{\"1\":{\"478\":1}}],[\"`remark`\",{\"1\":{\"506\":1}}],[\"`film\",{\"1\":{\"506\":6}}],[\"`film`\",{\"1\":{\"506\":3}}],[\"`ftime`\",{\"1\":{\"424\":2}}],[\"`update\",{\"1\":{\"506\":2}}],[\"`d`\",{\"1\":{\"446\":1,\"489\":1,\"506\":1}}],[\"`word`\",{\"1\":{\"419\":1}}],[\"`words`\",{\"1\":{\"419\":1}}],[\"`\",{\"1\":{\"404\":1}}],[\"`position`\",{\"1\":{\"510\":2,\"518\":2,\"519\":6}}],[\"`pos`\",{\"1\":{\"370\":4,\"372\":2,\"373\":3,\"374\":1,\"375\":4}}],[\"`phone\",{\"1\":{\"363\":1}}],[\"`phone`\",{\"1\":{\"363\":2}}],[\"`balance`\",{\"1\":{\"535\":4}}],[\"`bookid`\",{\"1\":{\"362\":1}}],[\"`book`\",{\"1\":{\"362\":2}}],[\"`b`\",{\"1\":{\"346\":3,\"400\":1,\"462\":1,\"523\":1}}],[\"`views`\",{\"1\":{\"361\":6}}],[\"`c`\",{\"1\":{\"424\":1,\"446\":3,\"459\":1,\"468\":1,\"476\":1,\"489\":3}}],[\"`c5`\",{\"1\":{\"378\":10}}],[\"`c4`\",{\"1\":{\"378\":16}}],[\"`c3`\",{\"1\":{\"378\":18}}],[\"`c2`\",{\"1\":{\"378\":22}}],[\"`c1`\",{\"1\":{\"378\":22}}],[\"`card`\",{\"1\":{\"362\":2,\"363\":1}}],[\"`category\",{\"1\":{\"361\":6}}],[\"`class`\",{\"1\":{\"362\":2}}],[\"`content`\",{\"1\":{\"361\":6}}],[\"`comments`\",{\"1\":{\"361\":6}}],[\"`city`\",{\"1\":{\"353\":3}}],[\"`account`\",{\"1\":{\"535\":4}}],[\"`actor\",{\"1\":{\"506\":3}}],[\"`actor`\",{\"1\":{\"506\":3}}],[\"`add\",{\"1\":{\"375\":1}}],[\"`addr`\",{\"1\":{\"353\":1}}],[\"`author\",{\"1\":{\"361\":6}}],[\"`article`\",{\"1\":{\"361\":7}}],[\"`a`\",{\"1\":{\"346\":3,\"400\":3,\"454\":3,\"462\":3,\"523\":2}}],[\"`age`\",{\"1\":{\"338\":2,\"353\":1,\"370\":3,\"372\":2,\"373\":3,\"374\":1,\"375\":4,\"510\":2,\"518\":2,\"519\":2}}],[\"`test`\",{\"1\":{\"535\":3}}],[\"`test03`\",{\"1\":{\"378\":22}}],[\"`t1`\",{\"1\":{\"462\":1,\"523\":1}}],[\"`t2`\",{\"1\":{\"400\":1}}],[\"`t\",{\"1\":{\"366\":3,\"413\":2,\"454\":3,\"478\":1}}],[\"`trade\",{\"1\":{\"368\":2}}],[\"`tradeid`\",{\"1\":{\"366\":3,\"368\":3}}],[\"`tradelog`\",{\"1\":{\"366\":1}}],[\"`title`\",{\"1\":{\"361\":6}}],[\"`t`\",{\"1\":{\"346\":1,\"353\":1,\"424\":1,\"446\":1,\"454\":1,\"459\":1,\"468\":1,\"476\":1,\"489\":1,\"494\":1}}],[\"`tuser`\",{\"1\":{\"338\":1}}],[\"`name\",{\"1\":{\"338\":1}}],[\"`name`\",{\"1\":{\"338\":2,\"353\":1,\"370\":4,\"371\":2,\"372\":2,\"373\":3,\"374\":3,\"375\":16,\"376\":5,\"506\":5,\"510\":2,\"518\":2,\"519\":9,\"534\":5,\"535\":4}}],[\"`insert\",{\"1\":{\"553\":1}}],[\"`information\",{\"1\":{\"354\":1,\"421\":1}}],[\"`ismale`\",{\"1\":{\"338\":1}}],[\"`idx\",{\"1\":{\"506\":2,\"518\":1,\"523\":1}}],[\"`id\",{\"1\":{\"338\":3}}],[\"`id`\",{\"1\":{\"338\":2,\"346\":2,\"353\":2,\"361\":1,\"362\":1,\"366\":2,\"368\":2,\"375\":5,\"376\":2,\"378\":1,\"400\":2,\"419\":2,\"431\":5,\"446\":2,\"454\":2,\"459\":2,\"462\":2,\"468\":2,\"476\":2,\"478\":2,\"489\":2,\"494\":2,\"506\":8,\"510\":2,\"518\":2,\"519\":2,\"523\":2,\"534\":6,\"535\":2}}],[\"需同时满足下面的条件\",{\"1\":{\"1554\":1}}],[\"需求\",{\"1\":{\"338\":1}}],[\"需要自己写sql语句以及自己装配参数\",{\"1\":{\"1982\":1}}],[\"需要自己创建\",{\"1\":{\"428\":1}}],[\"需要配合具体的垃圾收集器一起使用\",{\"1\":{\"1669\":1}}],[\"需要添加\",{\"1\":{\"1630\":1}}],[\"需要被关闭\",{\"1\":{\"1619\":1}}],[\"需要有一些预备的知识\",{\"1\":{\"1619\":1}}],[\"需要选择合适的方法\",{\"1\":{\"1612\":1}}],[\"需要两者配合使用\",{\"1\":{\"1609\":1}}],[\"需要主要的是\",{\"1\":{\"1585\":1}}],[\"需要dma控制器支持\",{\"1\":{\"1585\":1}}],[\"需要\",{\"1\":{\"1583\":1}}],[\"需要轮询pollfd来获取就绪的描述符\",{\"1\":{\"1570\":1}}],[\"需要避免内存泄漏和线程安全的问题\",{\"1\":{\"1528\":1}}],[\"需要注意以下两点\",{\"1\":{\"1526\":1}}],[\"需要注意两个关键点\",{\"1\":{\"1524\":1}}],[\"需要注意的是cmpxchg有个隐含操作数eax\",{\"1\":{\"1479\":1}}],[\"需要注意的是annotatedbeandefinitionreader与beandefinition并没有任何直接的关系\",{\"1\":{\"1024\":1}}],[\"需要注意的是\",{\"1\":{\"332\":1,\"338\":1,\"366\":1,\"393\":1,\"440\":1,\"444\":2,\"457\":1,\"460\":1,\"467\":1,\"484\":1,\"497\":1,\"522\":1,\"541\":1,\"542\":1,\"1003\":1,\"1550\":1,\"1594\":1,\"1609\":1,\"1616\":1,\"1646\":1}}],[\"需要谨慎评估这三个指标\",{\"1\":{\"1510\":1}}],[\"需要一个线程等待其它线程运行到某个点\",{\"1\":{\"1482\":1}}],[\"需要一定的时间间隔进行操作\",{\"1\":{\"590\":1}}],[\"需要进行内存分配和垃圾回收等操作\",{\"1\":{\"1457\":1}}],[\"需要进行配置才可以\",{\"1\":{\"592\":1}}],[\"需要客户端和服务器总共发送3个包\",{\"1\":{\"1425\":1}}],[\"需要对文件在内存中进行四次拷贝\",{\"1\":{\"1331\":1}}],[\"需要对一些叶子节点页面进行采样\",{\"1\":{\"558\":1}}],[\"需要由消费者自行控制\",{\"1\":{\"1329\":1}}],[\"需要按照上面不同场景来单独处理\",{\"1\":{\"1328\":1}}],[\"需要b\",{\"1\":{\"1326\":1}}],[\"需要幂等性的场景\",{\"1\":{\"1248\":1}}],[\"需要编写mapper接口\",{\"1\":{\"1217\":1}}],[\"需要格外注意的是\",{\"1\":{\"1091\":1}}],[\"需要单独引入spring\",{\"1\":{\"1028\":1}}],[\"需要合并beandefinition\",{\"1\":{\"997\":1,\"1000\":1,\"1001\":1,\"1005\":1,\"1006\":1,\"1011\":1}}],[\"需要设置编码\",{\"1\":{\"978\":1}}],[\"需要设置`set\",{\"1\":{\"404\":1}}],[\"需要拼接参数的\",{\"1\":{\"645\":1}}],[\"需要手动指定依赖注入对象\",{\"1\":{\"952\":1}}],[\"需要手动将一个从节点晋升为主节点\",{\"1\":{\"621\":1}}],[\"需要手动把一台从服务器切换为主服务器\",{\"1\":{\"619\":1}}],[\"需要fork子进程\",{\"1\":{\"589\":1}}],[\"需要我们手动声明变量类型的情况\",{\"1\":{\"1593\":1}}],[\"需要我们手动来设置这个参数\",{\"1\":{\"428\":1}}],[\"需要我们去计算\",{\"1\":{\"553\":1}}],[\"需要回表的记录数\",{\"1\":{\"549\":2}}],[\"需要回表4次\",{\"1\":{\"340\":1}}],[\"需要判断是否属于在活跃事务列表m\",{\"1\":{\"542\":1}}],[\"需要跳过12点误操作的那个语句的binlog\",{\"1\":{\"485\":1}}],[\"需要生成回滚日志\",{\"1\":{\"484\":1}}],[\"需要确保binlog\",{\"1\":{\"484\":1}}],[\"需要多做一些操作\",{\"1\":{\"482\":1}}],[\"需要做的事情就是tcp握手\",{\"1\":{\"482\":1}}],[\"需要删除中间过程的临时文件\",{\"1\":{\"481\":1}}],[\"需要发出信号的原因是\",{\"1\":{\"481\":1}}],[\"需要额外说明的是\",{\"1\":{\"476\":1}}],[\"需要执行applicationcontextawareprocessor\",{\"1\":{\"1005\":1}}],[\"需要执行一条change\",{\"1\":{\"467\":1}}],[\"需要执行几次树的搜索操作\",{\"1\":{\"336\":1}}],[\"需要消耗更多的计算资源\",{\"1\":{\"462\":1}}],[\"需要满足以下这两个基本要求\",{\"1\":{\"460\":1}}],[\"需要等到终止逻辑完成\",{\"1\":{\"481\":1}}],[\"需要等到主备延迟小于5秒的时候再启动切换\",{\"1\":{\"459\":1}}],[\"需要等到t6时刻session\",{\"1\":{\"447\":1}}],[\"需要等待两次刷盘\",{\"1\":{\"451\":1}}],[\"需要特殊处理\",{\"1\":{\"444\":1}}],[\"需要修改同一行数据\",{\"1\":{\"443\":1}}],[\"需要修改my\",{\"1\":{\"428\":1}}],[\"需要根据业务情况来定\",{\"1\":{\"433\":1}}],[\"需要根据身份证号查找对应的名字\",{\"1\":{\"332\":1}}],[\"需要将jvm内存冻结的一种状态\",{\"1\":{\"1440\":1}}],[\"需要将每个事务进行隔离\",{\"1\":{\"1262\":1}}],[\"需要将事务的顺序调过来再执行\",{\"1\":{\"484\":1}}],[\"需要将mysql的参数设置为session\",{\"1\":{\"474\":1}}],[\"需要将隔离级别设置为\",{\"1\":{\"433\":1}}],[\"需要将数据页读入内存\",{\"1\":{\"343\":1}}],[\"需要访问所有的分区\",{\"1\":{\"425\":1}}],[\"需要在后端服务更新数据时同时更新缓存\",{\"1\":{\"1283\":1}}],[\"需要在业务不是很繁忙的时候再运行\",{\"1\":{\"559\":1}}],[\"需要在my\",{\"1\":{\"428\":1}}],[\"需要在主库上再写一个drop\",{\"1\":{\"413\":1}}],[\"需要在执行sql语句之前\",{\"1\":{\"405\":1}}],[\"需要参与join的实际上只有2000行数据\",{\"1\":{\"407\":1}}],[\"需要通过理论分析和查看explain结果的方式\",{\"1\":{\"406\":1}}],[\"需要隔1秒后再次被访问到\",{\"1\":{\"406\":1}}],[\"需要分k段才能完成算法流程\",{\"1\":{\"403\":1}}],[\"需要让小表做驱动表\",{\"1\":{\"401\":1}}],[\"需要把数据一行一行地从引擎里面读出来后\",{\"1\":{\"396\":1}}],[\"需要把page2从磁盘读入内存中\",{\"1\":{\"345\":1}}],[\"需要考虑一下从表中找到某一行数据的成本\",{\"1\":{\"390\":1}}],[\"需要优化sql\",{\"1\":{\"361\":1}}],[\"需要的资源很少\",{\"1\":{\"478\":1}}],[\"需要的开发工作量比较大\",{\"1\":{\"411\":1}}],[\"需要的时候从缓存中取出\",{\"1\":{\"386\":1}}],[\"需要的结果与原\",{\"1\":{\"522\":1}}],[\"需要的结果\",{\"1\":{\"366\":1}}],[\"需要的临时文件也相应地变少了\",{\"1\":{\"355\":1}}],[\"需要的分成的份数就越多\",{\"1\":{\"354\":1}}],[\"需要用到临时表\",{\"1\":{\"354\":1}}],[\"需要创建长度为12位以上的前缀索引\",{\"1\":{\"352\":1}}],[\"需要说明的是\",{\"1\":{\"343\":1,\"355\":1,\"1618\":1}}],[\"需要首先了解change\",{\"1\":{\"343\":1}}],[\"需要查找下一个记录\",{\"1\":{\"342\":1}}],[\"需要逻辑上挪动后面的数据\",{\"1\":{\"335\":1}}],[\"需要找回数据\",{\"1\":{\"327\":1}}],[\"需要先把数据或者索引加载到内存中然后再操作\",{\"1\":{\"545\":1}}],[\"需要先获取到意向排他锁\",{\"1\":{\"533\":1}}],[\"需要先获取到意向共享锁\",{\"1\":{\"533\":1}}],[\"需要先从磁盘读入内存\",{\"1\":{\"326\":1}}],[\"需要先创建数据库\",{\"1\":{\"309\":1}}],[\"覆盖默认参数\",{\"1\":{\"940\":2}}],[\"覆盖\",{\"1\":{\"572\":3}}],[\"覆盖了\",{\"1\":{\"338\":1}}],[\"覆盖索引保两边\",{\"1\":{\"375\":1}}],[\"覆盖索引尽量用\",{\"0\":{\"373\":1}}],[\"覆盖索引\",{\"0\":{\"338\":1},\"1\":{\"330\":1}}],[\"步骤6\",{\"1\":{\"1549\":1}}],[\"步骤5\",{\"1\":{\"1549\":1}}],[\"步骤4\",{\"1\":{\"1549\":1}}],[\"步骤3\",{\"1\":{\"1549\":1}}],[\"步骤3直到不满足name=\",{\"1\":{\"520\":1}}],[\"步骤2\",{\"1\":{\"1549\":1}}],[\"步骤2和4\",{\"1\":{\"337\":1}}],[\"步骤二\",{\"1\":{\"1091\":1}}],[\"步骤一\",{\"1\":{\"1091\":1}}],[\"步骤1\",{\"1\":{\"337\":1,\"1549\":1}}],[\"回复功能\",{\"1\":{\"1987\":1}}],[\"回复客户端\",{\"1\":{\"1574\":1}}],[\"回收算法\",{\"0\":{\"1749\":1}}],[\"回调函数\",{\"1\":{\"1593\":1}}],[\"回调onclose\",{\"1\":{\"1175\":1}}],[\"回顾一下sychronized的唤醒策略\",{\"1\":{\"1495\":1}}],[\"回到刚才的例子当中\",{\"1\":{\"1622\":1}}],[\"回到一开始的例子当中\",{\"1\":{\"1622\":1}}],[\"回到stream类的定义\",{\"1\":{\"1619\":1}}],[\"回到线程1\",{\"1\":{\"581\":1}}],[\"回到主键索引树搜索的过程\",{\"1\":{\"337\":1}}],[\"回滚事务\",{\"1\":{\"1328\":1}}],[\"回滚该事务内的所有操作\",{\"1\":{\"1297\":1}}],[\"回滚指针指向刚刚拷贝到undo\",{\"1\":{\"542\":1}}],[\"回滚指针指向拷贝到undo\",{\"1\":{\"542\":1}}],[\"回滚指针\",{\"1\":{\"542\":1}}],[\"回滚操作需要对事务执行期间生成的所有新数据版本做回收操作\",{\"1\":{\"481\":1}}],[\"回滚语句是rollback\",{\"1\":{\"435\":1}}],[\"回滚段被清理\",{\"1\":{\"434\":1}}],[\"回滚日志是跟字典一起放在ibdata文件里的\",{\"1\":{\"434\":1}}],[\"回滚日志只有当没有事务需要用到这些回滚日志\",{\"1\":{\"434\":1}}],[\"回帖的备注\",{\"1\":{\"361\":1}}],[\"回表操作得到的完整用户记录\",{\"1\":{\"549\":1}}],[\"回表操作得到的完成用户记录\",{\"1\":{\"549\":1}}],[\"回表过程只是简单根据数据行的位置\",{\"1\":{\"420\":1}}],[\"回表肯定是一行行搜索主键索引的\",{\"1\":{\"404\":1}}],[\"回表是指\",{\"1\":{\"404\":1}}],[\"回表了两次\",{\"1\":{\"337\":1}}],[\"回表\",{\"0\":{\"337\":1}}],[\"上游的pipline\",{\"1\":{\"1621\":1}}],[\"上下文切换次数\",{\"1\":{\"1585\":1}}],[\"上下文切换相关开销\",{\"1\":{\"431\":1}}],[\"上下文对象\",{\"1\":{\"1139\":1}}],[\"上下文资源\",{\"1\":{\"1038\":1}}],[\"上下文\",{\"1\":{\"1019\":1}}],[\"上下文的依赖查询\",{\"1\":{\"906\":1}}],[\"上锁\",{\"1\":{\"581\":1}}],[\"上边的查询语句可能用到的索引\",{\"1\":{\"547\":1}}],[\"上述代码每次调用buffer\",{\"1\":{\"1486\":1}}],[\"上述查询可能使用到idx\",{\"1\":{\"549\":1}}],[\"上述查询中涉及到几个搜索条件\",{\"1\":{\"547\":1}}],[\"上述sql的explain的结果如下\",{\"1\":{\"420\":1}}],[\"上述sql语句查询的执行流程\",{\"1\":{\"337\":1}}],[\"上一章节中\",{\"1\":{\"1609\":1}}],[\"上一条数据的历史版本指针\",{\"1\":{\"542\":1}}],[\"上一段我们说到满足最左前缀原则的时候\",{\"1\":{\"340\":1}}],[\"上限就是223\",{\"1\":{\"493\":1}}],[\"上次备份是当天0点\",{\"1\":{\"485\":1}}],[\"上\",{\"1\":{\"467\":1,\"578\":1,\"1501\":1}}],[\"上最新的file和position\",{\"1\":{\"467\":1}}],[\"上执行show\",{\"1\":{\"467\":1}}],[\"上图中每个黑色圆点就是一个node对象\",{\"1\":{\"1546\":1}}],[\"上图中备库b下的虚线框\",{\"1\":{\"472\":1}}],[\"上图中\",{\"1\":{\"460\":1,\"542\":1}}],[\"上面优化的各种问题\",{\"1\":{\"1288\":1}}],[\"上面就形成了一个比较高效的分布式锁\",{\"1\":{\"1288\":1}}],[\"上面那个查询在联合索引里匹配到名字是\",{\"1\":{\"518\":1}}],[\"上面session\",{\"1\":{\"446\":1}}],[\"上面这个group\",{\"1\":{\"417\":1}}],[\"上面查询中的tag已经被缓存了\",{\"1\":{\"394\":1}}],[\"上面的代码其实等价于\",{\"1\":{\"1617\":1}}],[\"上面的方法都是一次排序\",{\"1\":{\"1614\":1}}],[\"上面的方法也会导致两条sql的结果不一致\",{\"1\":{\"522\":1}}],[\"上面的例子当中\",{\"1\":{\"1623\":1}}],[\"上面的例子是一个串行的例子\",{\"1\":{\"1620\":1}}],[\"上面的例子创建stream的\",{\"1\":{\"1608\":1}}],[\"上面的例子看起来还是相对而言比较简陋的\",{\"1\":{\"1607\":1}}],[\"上面的例子中\",{\"1\":{\"537\":1}}],[\"上面的例子中where\",{\"1\":{\"425\":1}}],[\"上面的分析中\",{\"1\":{\"481\":1}}],[\"上面的图变成了这样\",{\"1\":{\"451\":1}}],[\"上面的group\",{\"1\":{\"417\":1}}],[\"上面的这个例子说明了好的索引多么重要\",{\"1\":{\"390\":1}}],[\"上面的sql等价于\",{\"1\":{\"368\":1}}],[\"上面的sql语句等价于\",{\"1\":{\"367\":1}}],[\"上面的排序算法\",{\"1\":{\"355\":1}}],[\"上建立了普通索引\",{\"1\":{\"346\":1}}],[\"上文中的例子\",{\"1\":{\"473\":1}}],[\"上文中提到的双m结构的主备切换流程图如下\",{\"1\":{\"456\":1}}],[\"上文中主备的结构实际上是m\",{\"1\":{\"455\":1}}],[\"上文我们提到\",{\"1\":{\"421\":1}}],[\"上文我们总结临时表的特性\",{\"1\":{\"412\":1}}],[\"上文我们说过\",{\"1\":{\"344\":1}}],[\"上文提到的一主多从的架构师客户端主动做负载均衡\",{\"1\":{\"469\":1}}],[\"上文提到的redo\",{\"1\":{\"325\":1}}],[\"上文提到过\",{\"1\":{\"327\":2}}],[\"该框架能够保证分布式环境中数据的一致性\",{\"1\":{\"1991\":1}}],[\"该阶段会把一些静态方法\",{\"1\":{\"1663\":1}}],[\"该注解代理的功能就是向spring容器中添加了两个bean\",{\"1\":{\"1655\":1}}],[\"该简单的sql所要表达的意思是\",{\"1\":{\"1611\":1}}],[\"该类所依赖及引用的类也由这个classloader载入\",{\"1\":{\"1663\":1}}],[\"该类中的所有方法都是静态的\",{\"1\":{\"1560\":1}}],[\"该类对应的java\",{\"1\":{\"1443\":1}}],[\"该判断表示已经有线程在进行扩容操作了\",{\"1\":{\"1554\":1}}],[\"该操作会更新size大小\",{\"1\":{\"1554\":1}}],[\"该节点是红黑树节点\",{\"1\":{\"1554\":1}}],[\"该链为链表\",{\"1\":{\"1549\":1}}],[\"该阻塞队列的大小为integer\",{\"1\":{\"1503\":1}}],[\"该计数器+1\",{\"1\":{\"1485\":1}}],[\"该缓存中的副本\",{\"1\":{\"1474\":1}}],[\"该缓存是以namespace为单位的\",{\"1\":{\"1218\":1}}],[\"该假说认为只会存在很少的跨代引用\",{\"1\":{\"1434\":1}}],[\"该引用变量发出的方法调用到底是哪个类中实现的方法\",{\"1\":{\"1340\":1}}],[\"该工具可以帮助我们定位到数据不一致的错误\",{\"1\":{\"1297\":1}}],[\"该api便于理解\",{\"1\":{\"1036\":1}}],[\"该变量记录着对该表进行增删改的记录条数\",{\"1\":{\"559\":1}}],[\"该成本已经超过当前最小的连接查询成本\",{\"1\":{\"556\":1}}],[\"该关键字对应的id号为1\",{\"1\":{\"553\":1,\"555\":1}}],[\"该索引列是否允许存储null值\",{\"1\":{\"553\":1}}],[\"该索引必须是唯一索引\",{\"1\":{\"335\":1}}],[\"该属性的值就是null\",{\"1\":{\"553\":1}}],[\"该表的聚簇索引的记录数为97\",{\"1\":{\"548\":1}}],[\"该表中的记录数\",{\"1\":{\"548\":1}}],[\"该值设置的越小\",{\"1\":{\"558\":1}}],[\"该值设置的越大\",{\"1\":{\"558\":1}}],[\"该值越大\",{\"1\":{\"556\":1}}],[\"该值就相当于聚簇索引占用的存储空间大小\",{\"1\":{\"548\":1}}],[\"该值就是数据文件的大小\",{\"1\":{\"548\":1}}],[\"该值是一个估计值\",{\"1\":{\"548\":1}}],[\"该值是准确的\",{\"1\":{\"548\":1}}],[\"该视图在事务结束之前都不会变化\",{\"1\":{\"542\":1}}],[\"该事务处于活跃状态\",{\"1\":{\"542\":1}}],[\"该事务还没有提交\",{\"1\":{\"542\":1}}],[\"该事务已经提交\",{\"1\":{\"542\":1}}],[\"该如何解决由这种热点行更新导致的性能的问题呢\",{\"1\":{\"444\":1}}],[\"该如何避免回表呢\",{\"1\":{\"337\":1}}],[\"该单词在文档中出现的次数\",{\"1\":{\"308\":1}}],[\"普通公司也有可能会有算法的笔试环节\",{\"1\":{\"1970\":1}}],[\"普通对象是依赖注入的后的对象\",{\"1\":{\"1630\":1}}],[\"普通集群\",{\"1\":{\"1328\":1}}],[\"普通表单提交接口\",{\"1\":{\"1248\":1}}],[\"普通令牌只是一个普通的字符串\",{\"1\":{\"1203\":1}}],[\"普通国际化文案\",{\"1\":{\"1049\":1}}],[\"普通yaml资源配置\",{\"1\":{\"1048\":1}}],[\"普通properties格式资源\",{\"1\":{\"1048\":1}}],[\"普通class作为component注册到spring\",{\"1\":{\"995\":1}}],[\"普通消息\",{\"1\":{\"574\":1}}],[\"普通二级索引该列值为1\",{\"1\":{\"553\":1}}],[\"普通的方法接收的参数tryadvance\",{\"1\":{\"1620\":1}}],[\"普通的beandefinition\",{\"1\":{\"1048\":1}}],[\"普通的get是无法获取list值的\",{\"1\":{\"571\":1}}],[\"普通的set\",{\"1\":{\"570\":1}}],[\"普通的查询语句不需要申请trx\",{\"1\":{\"497\":1}}],[\"普通的查询是快照读\",{\"1\":{\"446\":1}}],[\"普通的insert语句里面包含多个value值的情况下\",{\"1\":{\"492\":1}}],[\"普通insert语句\",{\"1\":{\"492\":1}}],[\"普通索引\",{\"1\":{\"1276\":1}}],[\"普通索引树比主键索引树小很多\",{\"1\":{\"396\":1}}],[\"普通索引和唯一索引\",{\"0\":{\"341\":1}}],[\"普通索引占用的空间也就越小\",{\"1\":{\"335\":1}}],[\"普通索引的叶子节点就越小\",{\"1\":{\"335\":1}}],[\"普通查询\",{\"1\":{\"330\":1}}],[\"显性覆盖\",{\"1\":{\"1137\":1}}],[\"显性别名\",{\"1\":{\"1136\":1}}],[\"显性的别名比较容易理解\",{\"1\":{\"1136\":1}}],[\"显式启动事务语句\",{\"1\":{\"435\":1}}],[\"显著提升查询性能\",{\"1\":{\"338\":1}}],[\"显然只要将分组的key换成分数就可以了\",{\"1\":{\"1613\":1}}],[\"显然使用maxby\",{\"1\":{\"1601\":1}}],[\"显然它是做不到的\",{\"1\":{\"1598\":1}}],[\"显然bgsave命令是针对save阻塞问题做的优化\",{\"1\":{\"587\":1}}],[\"显然跟库里面表的个数无关\",{\"1\":{\"482\":1}}],[\"显然会出现主键冲突\",{\"1\":{\"468\":1}}],[\"显然是个体力活\",{\"1\":{\"429\":1}}],[\"显然是走了全表扫描\",{\"1\":{\"346\":1}}],[\"显然把\",{\"1\":{\"348\":1}}],[\"显然这样需要扫描1000行\",{\"1\":{\"347\":1}}],[\"显然\",{\"1\":{\"335\":1,\"343\":1,\"347\":2,\"396\":1,\"401\":1,\"403\":1,\"462\":1,\"492\":2,\"551\":1,\"553\":1,\"555\":1,\"1600\":1,\"1612\":1}}],[\"显示事务的隔离级别\",{\"1\":{\"1262\":1}}],[\"显示\",{\"1\":{\"574\":3}}],[\"显示线程id\",{\"1\":{\"497\":1}}],[\"显示的是redo\",{\"1\":{\"479\":1}}],[\"显示在页面上\",{\"1\":{\"471\":1}}],[\"显示交换次数相关开销的信息\",{\"1\":{\"431\":1}}],[\"显示和source\",{\"1\":{\"431\":1}}],[\"显示页面错误相关开销信息\",{\"1\":{\"431\":1}}],[\"显示内存相关开销信息\",{\"1\":{\"431\":1}}],[\"显示发送和接收相关开销信息\",{\"1\":{\"431\":1}}],[\"显示cpu相关开销信息\",{\"1\":{\"431\":1}}],[\"显示块io相关开销\",{\"1\":{\"431\":1}}],[\"显示所有的开销信息\",{\"1\":{\"431\":1}}],[\"显示索引的哪一列被使用了\",{\"1\":{\"330\":1}}],[\"显示可能应用在这张表中的索引\",{\"1\":{\"330\":1}}],[\"系统日志规范及最佳实践\",{\"1\":{\"1965\":1}}],[\"系统类加载器\",{\"1\":{\"1691\":1}}],[\"系统类初始化等等\",{\"1\":{\"1485\":1}}],[\"系统也存在一些相对稳定的部分\",{\"1\":{\"1687\":1}}],[\"系统就会给出警告\",{\"1\":{\"1620\":1}}],[\"系统调用\",{\"1\":{\"1585\":1}}],[\"系统调用方法\",{\"1\":{\"1584\":1}}],[\"系统方法做了优化升级\",{\"1\":{\"1583\":1}}],[\"系统\",{\"0\":{\"1584\":1},\"1\":{\"1582\":1,\"1583\":1,\"1584\":2}}],[\"系统将调用\",{\"1\":{\"1546\":1}}],[\"系统高峰期生产者速度太快\",{\"1\":{\"1536\":2}}],[\"系统属性\",{\"1\":{\"1227\":1}}],[\"系统崩坏概率大\",{\"1\":{\"608\":1}}],[\"系统变量innodb\",{\"1\":{\"559\":1}}],[\"系统变量\",{\"1\":{\"556\":1}}],[\"系统启动后到现在总共等待的次数\",{\"1\":{\"538\":1}}],[\"系统保存了一个全局变量thread\",{\"1\":{\"498\":1}}],[\"系统并发能力会大幅下降\",{\"1\":{\"491\":1}}],[\"系统管理员\",{\"1\":{\"488\":1}}],[\"系统正常\",{\"1\":{\"478\":1}}],[\"系统认为只要建立主备关系\",{\"1\":{\"468\":1}}],[\"系统的复杂度提高\",{\"1\":{\"1326\":1}}],[\"系统的可用性降低\",{\"1\":{\"1326\":1}}],[\"系统的可用性更好\",{\"1\":{\"623\":1}}],[\"系统的状态是这样的\",{\"1\":{\"467\":1}}],[\"系统的不可用时间就会长达30分钟\",{\"1\":{\"458\":1}}],[\"系统已经处于完全不可用的状态\",{\"1\":{\"459\":1}}],[\"系统给binlog\",{\"1\":{\"450\":1}}],[\"系统重启的时候就会被清空\",{\"1\":{\"409\":1}}],[\"系统表空间\",{\"1\":{\"345\":1}}],[\"系统有后台线程也会定期merge\",{\"1\":{\"343\":1}}],[\"系统会获取当前id最大值作为下一条记录的id值\",{\"1\":{\"335\":1}}],[\"系统即使崩溃\",{\"1\":{\"327\":1}}],[\"整合ssm框架还是比较繁琐的\",{\"1\":{\"1982\":1}}],[\"整合mybatis底层源码解析\",{\"0\":{\"1653\":1}}],[\"整合一个组件并进行配置一定会有一个自动配置类xxxautoconfiguration\",{\"1\":{\"583\":1}}],[\"整型\",{\"1\":{\"1623\":1}}],[\"整理算法\",{\"0\":{\"1722\":1}}],[\"整理+复制算法\",{\"1\":{\"1441\":1}}],[\"整理\",{\"1\":{\"1441\":2}}],[\"整堆收集\",{\"1\":{\"1434\":1}}],[\"整数或浮点数\",{\"1\":{\"1280\":1}}],[\"整数通常是最佳的数据类型\",{\"1\":{\"528\":1}}],[\"整体流程大致如下\",{\"1\":{\"1566\":1}}],[\"整体的流程关键节点如下\",{\"1\":{\"1093\":1}}],[\"整体空间利用率降低大约50\",{\"1\":{\"335\":1}}],[\"整条语句的执行速度就可以加快\",{\"1\":{\"408\":1}}],[\"整个完整的解析过程如下\",{\"1\":{\"1652\":1}}],[\"整个语句并没有告诉底层stream要如何去做\",{\"1\":{\"1611\":1}}],[\"整个拷贝过程\",{\"1\":{\"1582\":1,\"1583\":1,\"1584\":1}}],[\"整个拷贝的过程\",{\"1\":{\"1580\":1}}],[\"整个读取的数据的过程\",{\"1\":{\"1580\":1}}],[\"整个进程会被阻塞\",{\"1\":{\"1563\":1}}],[\"整个striped64\",{\"1\":{\"1480\":1}}],[\"整个处理流程跟rocketmq的事务消息\",{\"1\":{\"1328\":1}}],[\"整个服务就会产生影响\",{\"1\":{\"1326\":1}}],[\"整个查询效率就会降低的非常明显\",{\"1\":{\"1270\":1}}],[\"整个查询的执行成本\",{\"1\":{\"555\":1}}],[\"整个查询的执行成本预计为55\",{\"1\":{\"553\":1}}],[\"整个查询语句只有1个select关键字\",{\"1\":{\"553\":1,\"555\":1}}],[\"整个系统的性能是能够提高的\",{\"1\":{\"1304\":1}}],[\"整个系统的响应非常慢\",{\"1\":{\"478\":1}}],[\"整个系统被锁死\",{\"1\":{\"476\":1}}],[\"整个系统就阻塞了\",{\"1\":{\"476\":1}}],[\"整个过程省掉了数据在内核缓冲区和用户缓冲区之间的cpu拷贝环节\",{\"1\":{\"1581\":1}}],[\"整个过程完全时自动的\",{\"1\":{\"621\":1}}],[\"整个过程都需要人工干预\",{\"1\":{\"621\":1}}],[\"整个过程对表t1和t2都做了一次全表扫描\",{\"1\":{\"525\":1}}],[\"整个过程会读取t2表的所有数据\",{\"1\":{\"524\":1}}],[\"整个过程的流程图如下\",{\"1\":{\"474\":1}}],[\"整个过程io成本\",{\"1\":{\"324\":1}}],[\"整个库到可以正常更新的状态\",{\"1\":{\"438\":1}}],[\"整个事务存在期间都用这个视图\",{\"1\":{\"433\":1}}],[\"整个排序过程中\",{\"1\":{\"421\":1}}],[\"整个算式的结果会更小\",{\"1\":{\"403\":1}}],[\"整个执行流程\",{\"1\":{\"401\":1}}],[\"整个执行流程如下\",{\"1\":{\"355\":1}}],[\"整个json都会被替换\",{\"1\":{\"306\":1}}],[\"原生的子类型的特化也提供了\",{\"1\":{\"1620\":1}}],[\"原生类型\",{\"1\":{\"959\":1,\"960\":1,\"1099\":1}}],[\"原始文件\",{\"1\":{\"1588\":1}}],[\"原始类型\",{\"1\":{\"1099\":1}}],[\"原索引+oldcap\",{\"1\":{\"1550\":1}}],[\"原索引放到bucket里\",{\"1\":{\"1550\":1}}],[\"原索引\",{\"1\":{\"1550\":3}}],[\"原子消息广播协议\",{\"1\":{\"1991\":1}}],[\"原子变量\",{\"1\":{\"1482\":1}}],[\"原子类型累加器\",{\"1\":{\"1480\":1}}],[\"原子性\",{\"0\":{\"1472\":1},\"1\":{\"1262\":1,\"1373\":1,\"1431\":1,\"1470\":1,\"1474\":1}}],[\"原型bean的销毁方法并不会被spring所调用\",{\"1\":{\"1647\":1}}],[\"原型bean\",{\"1\":{\"1182\":1}}],[\"原型作用域的bean每次在依赖查找\",{\"1\":{\"1182\":1}}],[\"原型作用域\",{\"1\":{\"983\":1,\"1235\":1}}],[\"原型模式\",{\"0\":{\"837\":1}}],[\"原理和功能都是类似的\",{\"1\":{\"1620\":1}}],[\"原理图如下所示\",{\"1\":{\"1520\":1}}],[\"原理分析\",{\"0\":{\"1514\":1}}],[\"原理\",{\"0\":{\"599\":1},\"1\":{\"1134\":1}}],[\"原来min\",{\"1\":{\"1610\":1}}],[\"原来的方式创建线程\",{\"1\":{\"1591\":1}}],[\"原来的写法\",{\"1\":{\"1591\":1}}],[\"原来的注解会失效\",{\"1\":{\"967\":1}}],[\"原来的索引idx\",{\"1\":{\"361\":1}}],[\"原来使用的\",{\"1\":{\"583\":1}}],[\"原来节点b是a的从库\",{\"1\":{\"467\":1}}],[\"原因就在于groupingbyconcurrent使用的是concurrenthashmap\",{\"1\":{\"1618\":1}}],[\"原因就在于虽然我们采用的是链式的调用\",{\"1\":{\"1612\":1}}],[\"原因就在于\",{\"1\":{\"1610\":1,\"1614\":1}}],[\"原因就在于这里我们使用map返回的类型实际上变成了string\",{\"1\":{\"1609\":1}}],[\"原因与入队同理\",{\"1\":{\"1503\":1}}],[\"原因是流本身就是无序的\",{\"1\":{\"1619\":1}}],[\"原因是显而易见的\",{\"1\":{\"1598\":1}}],[\"原因是\",{\"1\":{\"1209\":1}}],[\"原因是当前binlog设置的是statement格式\",{\"1\":{\"454\":1}}],[\"原因\",{\"1\":{\"1181\":1,\"1536\":3}}],[\"原因在于数字是值类型的\",{\"1\":{\"1618\":1}}],[\"原因在于\",{\"1\":{\"912\":1}}],[\"原因在于扫描整个索引并没有查找到没索引的行\",{\"1\":{\"522\":1}}],[\"原因有二\",{\"1\":{\"438\":1}}],[\"原因为age为新增字段\",{\"1\":{\"309\":1}}],[\"原本spring会在初始化后进行aop操作\",{\"1\":{\"1649\":1}}],[\"原本三行的代码现在仅仅需要一行就能实现\",{\"1\":{\"1593\":1}}],[\"原本语句需要执行2\",{\"1\":{\"348\":1}}],[\"原本放在一个页的数据\",{\"1\":{\"335\":1}}],[\"原则\",{\"1\":{\"335\":1}}],[\"空间分配担保\",{\"0\":{\"1763\":1}}],[\"空间局部性原理\",{\"1\":{\"1519\":1}}],[\"空间换时间\",{\"1\":{\"1475\":1}}],[\"空间开销\",{\"1\":{\"1439\":1}}],[\"空间固定会用完\",{\"1\":{\"325\":1}}],[\"空链表\",{\"1\":{\"571\":1}}],[\"空洞\",{\"1\":{\"489\":1}}],[\"空出位置\",{\"1\":{\"335\":1}}],[\"非公平\",{\"1\":{\"1490\":1,\"1502\":1}}],[\"非公平锁\",{\"1\":{\"1394\":1}}],[\"非竞态条件下\",{\"1\":{\"1480\":1}}],[\"非标准指令\",{\"1\":{\"1453\":1}}],[\"非必须对象\",{\"1\":{\"1435\":1}}],[\"非阻塞i\",{\"1\":{\"1576\":1}}],[\"非阻塞io的特点是用户进行需要不断的主动询问kernel数据好了没有\",{\"1\":{\"1564\":1}}],[\"非阻塞io有个问题\",{\"1\":{\"603\":1}}],[\"非阻塞io在套接字对象上提供了一个线程non\",{\"1\":{\"602\":1}}],[\"非阻塞io\",{\"0\":{\"602\":1,\"1564\":1},\"1\":{\"1561\":1,\"1567\":1}}],[\"非阻塞说的是调用者\",{\"1\":{\"1567\":1}}],[\"非阻塞和同步\",{\"0\":{\"1567\":1}}],[\"非阻塞式的解决方案\",{\"1\":{\"1482\":1}}],[\"非阻塞\",{\"1\":{\"1421\":2}}],[\"非阻塞同步\",{\"0\":{\"1817\":1},\"1\":{\"1392\":1}}],[\"非cpu密集型任务\",{\"1\":{\"1292\":1}}],[\"非componenet\",{\"1\":{\"995\":1}}],[\"非聚簇索引\",{\"1\":{\"1266\":1}}],[\"非聚集\",{\"1\":{\"505\":1}}],[\"非基于接口契约编程\",{\"1\":{\"1123\":1}}],[\"非主流生命周期\",{\"1\":{\"1000\":1}}],[\"非主键索引也被称为二级索引\",{\"1\":{\"335\":1}}],[\"非主键索引的叶子节点内容是主键的值\",{\"1\":{\"335\":1}}],[\"非spring容器管理对象\",{\"1\":{\"973\":1}}],[\"非延迟初始化在spring应用上下文启动完成后\",{\"1\":{\"932\":1,\"933\":1}}],[\"非命名的bean注册方法\",{\"1\":{\"929\":1}}],[\"非命名方式\",{\"1\":{\"929\":1}}],[\"非整数字型字段不可用\",{\"1\":{\"573\":1}}],[\"非永久性的统计数据\",{\"1\":{\"558\":1}}],[\"非串行隔离级别\",{\"1\":{\"535\":1}}],[\"非叶子结点不存储data\",{\"1\":{\"503\":1}}],[\"非常推荐\",{\"1\":{\"1975\":1}}],[\"非常有深度\",{\"1\":{\"1974\":1}}],[\"非常适合入门\",{\"1\":{\"1971\":1,\"1974\":1}}],[\"非常适合初学者\",{\"1\":{\"1968\":1}}],[\"非常适合处理海量io的场景\",{\"1\":{\"1228\":1}}],[\"非常差\",{\"1\":{\"1576\":1}}],[\"非常难\",{\"1\":{\"1576\":1}}],[\"非常规spring对象依赖来源\",{\"1\":{\"978\":1}}],[\"非常便于进行数据库备份\",{\"1\":{\"596\":1}}],[\"非常友好\",{\"1\":{\"468\":1}}],[\"非常耗费数据库性能\",{\"1\":{\"431\":1}}],[\"非双1\",{\"1\":{\"457\":1}}],[\"非空\",{\"1\":{\"358\":1,\"989\":1}}],[\"非唯一性索引扫描\",{\"1\":{\"330\":1}}],[\"以实现对各种资源库的控制\",{\"1\":{\"1693\":1}}],[\"以实现让java程序在各种平台下都能达到一致的并发效果\",{\"1\":{\"1473\":1}}],[\"以字节为单位\",{\"1\":{\"1664\":1}}],[\"以之前我们使用foreach\",{\"1\":{\"1594\":1}}],[\"以往遍历集合通常的做法是\",{\"1\":{\"1593\":1}}],[\"以linux系统为例\",{\"1\":{\"1585\":1}}],[\"以客户端从服务器下载文件为例\",{\"1\":{\"1580\":1}}],[\"以read为例\",{\"1\":{\"1561\":1}}],[\"以保证数据的分散性\",{\"1\":{\"1553\":1}}],[\"以确保不占用太多的cpu资源\",{\"1\":{\"1520\":1}}],[\"以确保热点数据不会过期失效\",{\"1\":{\"1283\":1}}],[\"以class为单位\",{\"1\":{\"1485\":1}}],[\"以达到内存屏障的效果\",{\"1\":{\"1479\":1}}],[\"以满足应用程序的需求\",{\"1\":{\"1457\":1}}],[\"以满足更高的性能\",{\"1\":{\"601\":1}}],[\"以稳定的系统资源应对突发的流量冲击\",{\"1\":{\"1326\":1}}],[\"以非事务方式运行\",{\"1\":{\"1238\":2}}],[\"以标签的形式编写动态sql\",{\"1\":{\"1216\":1}}],[\"以后客户端的每次请求\",{\"1\":{\"1200\":1}}],[\"以便aop操作\",{\"1\":{\"1644\":1}}],[\"以便能装入更多的元素\",{\"1\":{\"1550\":1}}],[\"以便随后的write的操作\",{\"1\":{\"1473\":1}}],[\"以便随后的load动作使用\",{\"1\":{\"1473\":1}}],[\"以便在编译时提供更严格的类型检查并支持泛型编程\",{\"1\":{\"1098\":1}}],[\"以便快速确定是否存在这个值\",{\"1\":{\"627\":1}}],[\"以便允许别的事务再申请\",{\"1\":{\"492\":1}}],[\"以日志的形式来记录每个写的操作\",{\"1\":{\"591\":1}}],[\"以mysql为例\",{\"1\":{\"567\":1}}],[\"以order\",{\"1\":{\"553\":1}}],[\"以至于当客户端进行资源文件下载的时候\",{\"1\":{\"1580\":1}}],[\"以至于页b和页c对应的目录项记录都不在一个父页面中怎么办\",{\"1\":{\"549\":1}}],[\"以至于我们花费了不小的篇幅来介绍\",{\"1\":{\"381\":1}}],[\"以此类推\",{\"1\":{\"492\":1}}],[\"以此来估算元中元素的个数\",{\"1\":{\"1620\":1}}],[\"以此来对照学习\",{\"1\":{\"1602\":1}}],[\"以此来模拟大查询\",{\"1\":{\"476\":1}}],[\"以此来跳过可能涉及的所有事务\",{\"1\":{\"467\":1}}],[\"以此来减少binlog的写盘次数\",{\"1\":{\"465\":1}}],[\"以auto\",{\"1\":{\"491\":1}}],[\"以免之后真的出现了主从数据不一致\",{\"1\":{\"467\":1}}],[\"以影院的账户为例\",{\"1\":{\"444\":1}}],[\"以\",{\"1\":{\"412\":1}}],[\"以下是关于streamsupport这个类的说明\",{\"1\":{\"1621\":1}}],[\"以下是一些原因解释为什么jdk8将永久代改为元空间\",{\"1\":{\"1457\":1}}],[\"以下是redis的内存淘汰策略\",{\"1\":{\"1300\":1}}],[\"以下观点出自于\",{\"1\":{\"910\":1}}],[\"以下参数将会在调用脚本时传给脚本\",{\"1\":{\"624\":1}}],[\"以下语句序列可以说明这一点\",{\"1\":{\"491\":1}}],[\"以下面的查询为例\",{\"1\":{\"520\":1}}],[\"以下面的查询语句为例\",{\"1\":{\"411\":1}}],[\"以下面的表t为例\",{\"1\":{\"336\":1}}],[\"以下列操作序列为例\",{\"1\":{\"410\":1}}],[\"以上是关于spliterator这个类本身的说明\",{\"1\":{\"1620\":1}}],[\"以上是jdk7的情况\",{\"1\":{\"1551\":1}}],[\"以上都是通过collectorimpl来实现的collector\",{\"1\":{\"1618\":1}}],[\"以上就是\",{\"1\":{\"1993\":1}}],[\"以上就是关于stream这个类的内容\",{\"1\":{\"1619\":1}}],[\"以上就是关于如何创建流的对象的例子\",{\"1\":{\"1607\":1}}],[\"以上就是几个最基础也是最重要的几个函数式接口\",{\"1\":{\"1600\":1}}],[\"以上对jdk8之前的定义和规范\",{\"1\":{\"1345\":1}}],[\"以上图为例\",{\"1\":{\"461\":1}}],[\"以上这条查询语句的执行流程如下\",{\"1\":{\"411\":1}}],[\"以上结论告诉我们\",{\"1\":{\"403\":1}}],[\"以上面的图为例\",{\"1\":{\"335\":1}}],[\"以innodb的一个整数字段为例\",{\"1\":{\"334\":1}}],[\"以及jvm的内部原理等\",{\"1\":{\"1992\":1}}],[\"以及具体处理request请求\",{\"1\":{\"1683\":1}}],[\"以及一些附加的信息关于终止的有状态的操作\",{\"1\":{\"1623\":1}}],[\"以及传递给finisher的参数\",{\"1\":{\"1615\":1}}],[\"以及传递给combiner方法的两个参数\",{\"1\":{\"1615\":1}}],[\"以及我们之前使用的诸多的api在底层到底是如何实现的\",{\"1\":{\"1613\":1}}],[\"以及等待指定时长的获取\",{\"1\":{\"1495\":1}}],[\"以及在必须时如何同步的访问共享变量\",{\"1\":{\"1473\":1}}],[\"以及os环境变量\",{\"1\":{\"1164\":1}}],[\"以及属性值\",{\"1\":{\"1071\":1}}],[\"以及远程资源\",{\"1\":{\"1037\":1}}],[\"以及重载方法\",{\"1\":{\"941\":1}}],[\"以及订阅这个频道的三个客户端\",{\"1\":{\"596\":1}}],[\"以及未保存到快照中的那些数据\",{\"1\":{\"592\":1}}],[\"以及成员m2\",{\"1\":{\"574\":1}}],[\"以及行记录所在的间隙里插入或修改任何数据\",{\"1\":{\"536\":1}}],[\"以及要从哪个位置开始请求binlog\",{\"1\":{\"453\":1}}],[\"以及每个值得出现次数\",{\"1\":{\"418\":1}}],[\"以及每种方法优缺点\",{\"1\":{\"396\":1}}],[\"以及增删改查语句访问的是临时表\",{\"1\":{\"410\":1}}],[\"以及拷贝字段值的操作\",{\"1\":{\"399\":1}}],[\"以及适配磁盘的访问模式\",{\"1\":{\"334\":1}}],[\"以及所有的内置函数\",{\"1\":{\"317\":1}}],[\"以及出现的次数\",{\"1\":{\"299\":1}}],[\"取中点\",{\"1\":{\"1620\":1}}],[\"取的时候也是只返回key\",{\"1\":{\"1557\":1}}],[\"取key的hashcode值\",{\"1\":{\"1548\":1}}],[\"取hashcode值\",{\"1\":{\"1548\":1}}],[\"取消所有任务\",{\"1\":{\"1517\":1}}],[\"取消事务\",{\"1\":{\"579\":1}}],[\"取模运算\",{\"1\":{\"1548\":2}}],[\"取模\",{\"1\":{\"1270\":1}}],[\"取余\",{\"1\":{\"1270\":1}}],[\"取top\",{\"1\":{\"574\":1}}],[\"取两个集合的成员score最小值作为结果的\",{\"1\":{\"574\":1}}],[\"取值范围\",{\"1\":{\"527\":1}}],[\"取最近一次全量备份\",{\"1\":{\"485\":1}}],[\"取到需要的信息\",{\"1\":{\"479\":1}}],[\"取到第二行id=999\",{\"1\":{\"414\":1}}],[\"取binlog的逻辑如下\",{\"1\":{\"468\":1}}],[\"取原主库a故障的时刻t\",{\"1\":{\"467\":1}}],[\"取决于具体的并行操作的类型\",{\"1\":{\"1615\":1}}],[\"取决于业务场景\",{\"1\":{\"473\":1}}],[\"取决于压力模型\",{\"1\":{\"463\":1}}],[\"取决于数据块的大小\",{\"1\":{\"334\":1}}],[\"取不小于x的第一个id的行\",{\"1\":{\"422\":1}}],[\"取下一个行\",{\"1\":{\"421\":1}}],[\"取下一个记录\",{\"1\":{\"356\":1}}],[\"取下一个记录主键id\",{\"1\":{\"356\":1}}],[\"取这两个子查询结果的并集\",{\"1\":{\"414\":1}}],[\"取得y=floor\",{\"1\":{\"422\":1}}],[\"取得整个表的行数\",{\"1\":{\"422\":2}}],[\"取得这个表的主键id最大值m和最小值n\",{\"1\":{\"422\":1}}],[\"取得表t1的全部1000行数据\",{\"1\":{\"408\":1}}],[\"取得id2的值\",{\"1\":{\"350\":1}}],[\"取得id=500\",{\"1\":{\"337\":1}}],[\"取得id=300\",{\"1\":{\"337\":1}}],[\"取出pointcut\",{\"1\":{\"1654\":1}}],[\"取出学生的名字\",{\"1\":{\"1613\":1}}],[\"取出takeindex位置的元素\",{\"1\":{\"1502\":1}}],[\"取出来\",{\"1\":{\"542\":1}}],[\"取出所有字段的值\",{\"1\":{\"520\":1}}],[\"取出凌晨0点之后的日志\",{\"1\":{\"485\":1}}],[\"取出前三个结果的位置信息\",{\"1\":{\"420\":1}}],[\"取出每一行数据跟join\",{\"1\":{\"407\":1}}],[\"取出表t2中满足条件的行\",{\"1\":{\"401\":1}}],[\"取出字段到表t2里去查找\",{\"1\":{\"401\":1}}],[\"取出全部列\",{\"1\":{\"385\":1}}],[\"取出其中的city\",{\"1\":{\"356\":1}}],[\"取出id2\",{\"1\":{\"350\":1}}],[\"取前1000行\",{\"1\":{\"355\":1}}],[\"取name\",{\"1\":{\"354\":1,\"355\":1,\"356\":1}}],[\"取index2上刚刚查到的位置的下一条记录\",{\"1\":{\"350\":1}}],[\"取index1索引树上刚刚查到的位置的下一条记录\",{\"1\":{\"350\":1}}],[\"取满足条件的第一行\",{\"1\":{\"322\":1}}],[\"树中的叶子节点包含了一两个元素\",{\"1\":{\"1620\":1}}],[\"树中地\",{\"1\":{\"334\":1}}],[\"树的叶子节点上的data就是数据本身\",{\"1\":{\"1266\":1}}],[\"树的子节点上的data不是数据本身\",{\"1\":{\"1266\":1}}],[\"树的第二层也有很大的概率在内存中\",{\"1\":{\"334\":1}}],[\"树叶子结点上保存的是全行数据\",{\"1\":{\"518\":1}}],[\"树可以有二叉\",{\"1\":{\"334\":1}}],[\"儿子之间的大小保证从左到右递增\",{\"1\":{\"334\":1}}],[\"示意图如下\",{\"1\":{\"472\":1}}],[\"示意图如下所示\",{\"1\":{\"333\":1}}],[\"示例表\",{\"1\":{\"523\":1}}],[\"示例如下\",{\"1\":{\"412\":1}}],[\"示例\",{\"0\":{\"598\":1},\"1\":{\"309\":1,\"570\":1}}],[\"链表长度大于8的时候转为红黑树\",{\"1\":{\"1554\":1}}],[\"链表长度大于8转换为红黑树进行处理\",{\"1\":{\"1549\":1}}],[\"链表优化重hash的代码块\",{\"1\":{\"1550\":1}}],[\"链表就转换为了红黑树\",{\"1\":{\"1546\":1}}],[\"链表的下一个node\",{\"1\":{\"1546\":1}}],[\"链表的结构改为了数组\",{\"1\":{\"1359\":1}}],[\"链表尾\",{\"1\":{\"1503\":1}}],[\"链表头\",{\"1\":{\"1503\":1}}],[\"链表转红黑树的阈值\",{\"1\":{\"1475\":1}}],[\"链表转树\",{\"1\":{\"1363\":1}}],[\"链表插入方式\",{\"1\":{\"1475\":1}}],[\"链表个数会在8左右徘徊\",{\"1\":{\"1363\":1}}],[\"链表结构已经能保证查询性能\",{\"1\":{\"1360\":1}}],[\"链表\",{\"1\":{\"1359\":1,\"1423\":1,\"1475\":1}}],[\"链表中保存了所有订阅这个频道的客户端\",{\"1\":{\"599\":1}}],[\"链路追踪等\",{\"1\":{\"1989\":1}}],[\"链路追踪\",{\"1\":{\"1310\":1}}],[\"链式\",{\"1\":{\"1107\":1}}],[\"链尾就是最早的旧记录\",{\"1\":{\"542\":1}}],[\"链地址法是解决哈希冲突比较常见的做法\",{\"1\":{\"332\":1}}],[\"链接地址是\",{\"1\":{\"1201\":1}}],[\"链接\",{\"1\":{\"312\":1,\"635\":1}}],[\"存放类的属性数据信息\",{\"1\":{\"1484\":1}}],[\"存放在进入或重新进入时被阻塞\",{\"1\":{\"1483\":1}}],[\"存在则将map中的list对象取出来\",{\"1\":{\"1613\":1}}],[\"存在守护条件\",{\"1\":{\"1531\":1}}],[\"存在用户态和内核态切换\",{\"1\":{\"1485\":1}}],[\"存在丢失数据的可能性\",{\"1\":{\"1290\":1}}],[\"存在老版本redis服务无法兼容rdb格式的问题\",{\"1\":{\"590\":1}}],[\"存在\",{\"1\":{\"569\":1,\"573\":1}}],[\"存在两个问题\",{\"1\":{\"472\":1}}],[\"存在redo\",{\"1\":{\"451\":1}}],[\"存入beandefitionmap\",{\"1\":{\"1651\":1}}],[\"存入join\",{\"1\":{\"407\":1}}],[\"存入sort\",{\"1\":{\"354\":1,\"355\":1,\"520\":1}}],[\"存储过程以及高级映射\",{\"1\":{\"1982\":1}}],[\"存储过程idata\",{\"1\":{\"400\":1}}],[\"存储系统\",{\"1\":{\"1975\":1}}],[\"存储位映射\",{\"0\":{\"1910\":1}}],[\"存储在mergedbeandefinitions这个map中\",{\"1\":{\"1647\":1}}],[\"存储方式\",{\"0\":{\"1546\":1}}],[\"存储元素\",{\"1\":{\"1503\":1}}],[\"存储锁对象\",{\"1\":{\"1483\":1}}],[\"存储粒度上执行\",{\"1\":{\"1474\":1}}],[\"存储的线程会等待队列可用\",{\"1\":{\"1395\":1}}],[\"存储地理位置信息\",{\"1\":{\"1280\":1}}],[\"存储键值对的无序散列表\",{\"1\":{\"1280\":1}}],[\"存储文件\",{\"1\":{\"1260\":1}}],[\"存储到缓存中\",{\"1\":{\"1248\":1}}],[\"存储对象\",{\"1\":{\"1153\":1}}],[\"存储\",{\"1\":{\"1019\":1,\"1026\":1,\"1473\":1}}],[\"存储效率并不高\",{\"1\":{\"627\":1}}],[\"存储空对象也需要空间\",{\"1\":{\"627\":1}}],[\"存储用户的id\",{\"1\":{\"577\":1}}],[\"存储班级成绩表\",{\"1\":{\"574\":1}}],[\"存储结果到及和张\",{\"1\":{\"572\":1}}],[\"存储结果到集合中\",{\"1\":{\"572\":1}}],[\"存储引擎层\",{\"1\":{\"557\":1}}],[\"存储于rollback\",{\"1\":{\"542\":1}}],[\"存储数据的结构\",{\"1\":{\"332\":1}}],[\"存起来的binlog里面就没有这条语句\",{\"1\":{\"327\":1}}],[\"值得一提的是\",{\"1\":{\"1990\":1}}],[\"值类型的参数无法进行传递\",{\"1\":{\"1618\":1}}],[\"值为\",{\"1\":{\"1490\":3}}],[\"值为1\",{\"1\":{\"1490\":1}}],[\"值为0\",{\"1\":{\"1490\":1}}],[\"值为a时代表升序存放\",{\"1\":{\"553\":1}}],[\"值的变化能够及时地在整个系统中传播的规程\",{\"1\":{\"1474\":1}}],[\"值的方式来计算\",{\"1\":{\"371\":1}}],[\"值由填满了缓冲区之后\",{\"1\":{\"1410\":1}}],[\"值都是固定的\",{\"1\":{\"454\":1}}],[\"值\",{\"1\":{\"332\":1,\"422\":1,\"573\":1,\"1570\":1}}],[\"值有以下三种情况\",{\"1\":{\"330\":1}}],[\"避免类的重复加载\",{\"1\":{\"1663\":1,\"1692\":1}}],[\"避免类型强转\",{\"1\":{\"1098\":1}}],[\"避免哈希冲突\",{\"1\":{\"1553\":1}}],[\"避免共享有两种方案\",{\"1\":{\"1528\":1}}],[\"避免共享的设计模式\",{\"0\":{\"1525\":1}}],[\"避免缓存穿透和击穿\",{\"1\":{\"1283\":1}}],[\"避免对后端服务的重复访问\",{\"1\":{\"1283\":1}}],[\"避免在热点数据失效时出现大量请求\",{\"1\":{\"1283\":1}}],[\"避免直接访问后端服务\",{\"1\":{\"1283\":1}}],[\"避免b+树出现分裂合并\",{\"1\":{\"1277\":1}}],[\"避免select系统调用立即返回写事件\",{\"1\":{\"605\":1}}],[\"避免了资源被消耗尽造异常外和错误\",{\"1\":{\"1619\":1}}],[\"避免了两者之间的\",{\"1\":{\"1584\":1}}],[\"避免了调整永久代大小的繁琐工作\",{\"1\":{\"1457\":1}}],[\"避免了永久代中的内存泄漏问题\",{\"1\":{\"1457\":1}}],[\"避免了传统通过循环write方式导致的内存拷贝问题\",{\"1\":{\"1231\":1}}],[\"避免了内存的拷贝\",{\"1\":{\"1231\":1}}],[\"避免了各个bytebuf之间的拷贝\",{\"1\":{\"1231\":1}}],[\"避免了加锁操作\",{\"1\":{\"541\":1}}],[\"避免了频繁加锁互斥\",{\"1\":{\"540\":1}}],[\"避免了页分裂\",{\"1\":{\"489\":1}}],[\"避免间隙锁\",{\"1\":{\"539\":1}}],[\"避免无索引行锁升级为表锁\",{\"1\":{\"539\":1}}],[\"避免使用orm框架\",{\"1\":{\"1277\":1}}],[\"避免使用整数的显示宽度\",{\"1\":{\"528\":1}}],[\"避免使用null\",{\"1\":{\"527\":1}}],[\"避免两个库生成的主键发生冲突\",{\"1\":{\"491\":1}}],[\"避免写错命令\",{\"1\":{\"487\":1}}],[\"避免让mysql再自己去翻译一次\",{\"1\":{\"378\":1}}],[\"避免访问了表的数据行\",{\"1\":{\"330\":1}}],[\"避免primary\",{\"1\":{\"304\":1}}],[\"~1\",{\"1\":{\"1620\":1}}],[\"~\",{\"1\":{\"330\":41,\"1621\":1}}],[\"说完这些\",{\"1\":{\"583\":1}}],[\"说明三个特性都不具备\",{\"1\":{\"1618\":1}}],[\"说明这个新的语法就是在调用student的无参构造来创建对象\",{\"1\":{\"1600\":1}}],[\"说明这条语句扫描了整个索引的所有值\",{\"1\":{\"366\":1}}],[\"说明存在\",{\"1\":{\"1554\":1}}],[\"说明正在扩容\",{\"1\":{\"1554\":1}}],[\"说明一天内能处理完\",{\"1\":{\"1536\":1}}],[\"说明此时处于可偏向但未偏向任何线程\",{\"1\":{\"1485\":1}}],[\"说明两者的底层实现是一样的\",{\"1\":{\"1181\":1}}],[\"说明\",{\"1\":{\"927\":1,\"952\":1,\"957\":1,\"983\":1,\"1037\":1,\"1070\":1,\"1071\":1,\"1072\":1,\"1075\":1,\"1089\":1,\"1092\":1,\"1099\":1,\"1113\":1,\"1154\":1,\"1191\":1,\"1192\":1,\"1193\":1,\"1194\":1,\"1195\":1,\"1235\":1}}],[\"说明我们是可以对其进行定制化的\",{\"1\":{\"583\":1}}],[\"说明事务执行失败\",{\"1\":{\"581\":1}}],[\"说明事务id在低水位和高水位之间\",{\"1\":{\"542\":1}}],[\"说明创建快照时\",{\"1\":{\"542\":1}}],[\"说明如下\",{\"1\":{\"454\":2}}],[\"说明第二个子句用到了索引id\",{\"1\":{\"414\":1}}],[\"说明了这是一个被服务端改写过的命令\",{\"1\":{\"413\":1}}],[\"说明a还不够合适\",{\"1\":{\"348\":1}}],[\"说明mysql会对数据使用一个外部的索引排序\",{\"1\":{\"330\":1}}],[\"说说你们公司的es集群架构\",{\"0\":{\"172\":1,\"1254\":1}}],[\"896043488029600\",{\"1\":{\"1981\":1}}],[\"8904\",{\"1\":{\"394\":1}}],[\"8之前可以通过字节码的本地变量表来获取\",{\"1\":{\"1648\":1}}],[\"8以后可以获取方法的形参名称\",{\"1\":{\"1648\":1}}],[\"8提供的一个新的类\",{\"1\":{\"1618\":1}}],[\"8开始增加了若干个默认方法\",{\"1\":{\"1614\":1}}],[\"8才开始有的\",{\"1\":{\"1597\":1}}],[\"8新增的foreach方法\",{\"1\":{\"1593\":1}}],[\"8不会倒置\",{\"1\":{\"1550\":1}}],[\"8put方法的源代码如下\",{\"1\":{\"1549\":1}}],[\"8的eden内存\",{\"1\":{\"1664\":1}}],[\"8的concurrenthashmap的示意图如下\",{\"1\":{\"1554\":1}}],[\"8的实现\",{\"0\":{\"1554\":1}}],[\"8的实现中\",{\"1\":{\"1548\":1}}],[\"8的区别\",{\"1\":{\"1545\":1}}],[\"8在计算位置的时候采用方法一返回的哈希值\",{\"1\":{\"1548\":1}}],[\"8没有这个方法\",{\"1\":{\"1548\":1}}],[\"8中接口是又具体的方法实现\",{\"1\":{\"1593\":1}}],[\"8中concurrenthashmap放弃了hashentry结构而是采用了跟hashmap结构非常相似\",{\"1\":{\"1554\":1}}],[\"8中的concurrenthashmap放弃了jdk1\",{\"1\":{\"1554\":1}}],[\"8中对扩容做了一些优化\",{\"1\":{\"1550\":1}}],[\"8中\",{\"1\":{\"1546\":1,\"1548\":1,\"1550\":1}}],[\"8增加红黑树部分\",{\"1\":{\"1546\":1}}],[\"8增加的类\",{\"1\":{\"1480\":1}}],[\"8对hashmap底层的实现进行了优化\",{\"1\":{\"1545\":1}}],[\"8对hashmap有哪些优化\",{\"0\":{\"31\":1,\"1359\":1}}],[\"8版本下\",{\"1\":{\"1453\":1}}],[\"8系列之重新认识hashmap\",{\"1\":{\"1356\":1}}],[\"8859\",{\"1\":{\"1022\":1}}],[\"88+12\",{\"1\":{\"403\":1}}],[\"8+\",{\"1\":{\"897\":1}}],[\"8+6\",{\"1\":{\"503\":1}}],[\"87\",{\"1\":{\"574\":2}}],[\"840\",{\"1\":{\"555\":2}}],[\"84\",{\"1\":{\"549\":1,\"551\":2}}],[\"8=\",{\"1\":{\"548\":1}}],[\"816f27d\",{\"1\":{\"1610\":1}}],[\"81\",{\"1\":{\"544\":1,\"549\":1,\"551\":1,\"610\":1}}],[\"838\",{\"1\":{\"529\":2}}],[\"850\",{\"1\":{\"1619\":2}}],[\"8575799808933029326l\",{\"1\":{\"1614\":1}}],[\"85\",{\"1\":{\"576\":1}}],[\"858\",{\"1\":{\"528\":3}}],[\"854\",{\"1\":{\"528\":2,\"1619\":1}}],[\"862\",{\"1\":{\"528\":3}}],[\"823\",{\"1\":{\"528\":3}}],[\"80\",{\"1\":{\"581\":1,\"610\":1,\"1613\":1,\"1615\":1,\"1616\":2}}],[\"807\",{\"1\":{\"528\":1}}],[\"8080\",{\"1\":{\"1533\":1,\"1534\":1}}],[\"808\",{\"1\":{\"528\":1}}],[\"8年后\",{\"1\":{\"497\":1}}],[\"8\",{\"1\":{\"330\":2,\"366\":3,\"368\":1,\"378\":1,\"492\":1,\"528\":4,\"529\":1,\"536\":1,\"548\":1,\"549\":1,\"551\":1,\"567\":7,\"573\":2,\"917\":1,\"918\":1,\"930\":1,\"953\":2,\"954\":2,\"961\":2,\"997\":1,\"1000\":1,\"1022\":1,\"1030\":1,\"1032\":1,\"1040\":1,\"1041\":1,\"1043\":1,\"1052\":1,\"1065\":1,\"1084\":1,\"1087\":1,\"1091\":1,\"1146\":3,\"1369\":1,\"1475\":2,\"1548\":1,\"1574\":2,\"1575\":2,\"1594\":2,\"1595\":1,\"1597\":2,\"1598\":2,\"1599\":4,\"1600\":1,\"1601\":1,\"1605\":1,\"1607\":2,\"1620\":1}}],[\"9章讲述了\",{\"1\":{\"1969\":1}}],[\"93\",{\"1\":{\"574\":2}}],[\"94\",{\"1\":{\"555\":1}}],[\"98\",{\"1\":{\"548\":2}}],[\"9s\",{\"1\":{\"544\":1,\"547\":2,\"549\":2,\"553\":2,\"554\":2}}],[\"967\",{\"1\":{\"528\":1,\"530\":2}}],[\"9开始\",{\"1\":{\"425\":1}}],[\"90分以下的分成一组\",{\"1\":{\"1613\":1}}],[\"90分以上的分成一组\",{\"1\":{\"1613\":1}}],[\"90\",{\"1\":{\"573\":1,\"574\":2,\"1603\":2,\"1604\":2,\"1605\":1,\"1613\":3,\"1615\":2,\"1616\":1}}],[\"900\",{\"1\":{\"587\":1}}],[\"90000\",{\"1\":{\"522\":5}}],[\"900376\",{\"1\":{\"420\":1}}],[\"9098的内容\",{\"1\":{\"394\":1}}],[\"9098\",{\"1\":{\"394\":1}}],[\"97\",{\"1\":{\"419\":4,\"548\":2}}],[\"999\",{\"1\":{\"1286\":1}}],[\"9999\",{\"1\":{\"529\":2}}],[\"99\",{\"1\":{\"359\":1,\"582\":1,\"583\":1}}],[\"95\",{\"1\":{\"350\":1,\"574\":1}}],[\"9\",{\"1\":{\"330\":1,\"368\":1,\"378\":1,\"528\":2,\"544\":1,\"548\":1,\"551\":1,\"569\":1,\"570\":1,\"573\":1,\"574\":1,\"624\":1,\"899\":1,\"961\":1,\"1182\":2,\"1479\":1,\"1594\":2,\"1599\":2,\"1607\":1}}],[\"||\",{\"1\":{\"542\":1,\"645\":1,\"928\":1,\"952\":1,\"963\":2,\"996\":1,\"997\":1,\"1007\":1,\"1008\":2,\"1480\":4,\"1549\":4,\"1553\":1,\"1554\":13,\"1594\":1,\"1599\":2,\"1617\":1,\"1647\":3,\"1648\":5,\"1650\":3,\"1654\":2,\"1655\":1}}],[\"|\",{\"1\":{\"330\":70,\"371\":24,\"428\":21,\"429\":1,\"431\":173,\"454\":1,\"1289\":1,\"1464\":2,\"1609\":1,\"1620\":3,\"1622\":1,\"1647\":1}}],[\"<host>\",{\"1\":{\"1683\":1}}],[\"<k\",{\"1\":{\"1618\":1}}],[\"<begin>\",{\"1\":{\"1616\":1}}],[\"<bean\",{\"1\":{\"917\":3,\"918\":1,\"929\":1,\"930\":5,\"931\":1,\"932\":1,\"933\":1,\"953\":2,\"954\":2,\"972\":1,\"973\":1,\"986\":1,\"987\":1,\"988\":1,\"989\":1,\"1003\":1,\"1005\":1,\"1012\":1,\"1032\":1,\"1065\":2,\"1084\":2,\"1091\":2,\"1146\":3}}],[\"<beans\",{\"1\":{\"917\":1,\"918\":1,\"930\":2,\"953\":2,\"954\":2,\"1021\":4,\"1030\":1,\"1032\":1,\"1065\":1,\"1084\":1,\"1091\":1,\"1146\":1}}],[\"<li>\",{\"1\":{\"1594\":4}}],[\"<<\",{\"1\":{\"1550\":2,\"1553\":1,\"1554\":1,\"1621\":1}}],[\"<e\",{\"1\":{\"1621\":2}}],[\"<engine>\",{\"1\":{\"1683\":1}}],[\"<end>\",{\"1\":{\"1616\":1}}],[\"<entry\",{\"1\":{\"989\":1}}],[\"<em>not<\",{\"1\":{\"1594\":2}}],[\"<e>\",{\"1\":{\"1099\":1}}],[\"<v>\",{\"1\":{\"1598\":12}}],[\"<value>\",{\"1\":{\"1084\":1,\"1091\":1}}],[\"<version>1<\",{\"1\":{\"965\":1}}],[\"<version>1\",{\"1\":{\"582\":1}}],[\"<version>3\",{\"1\":{\"582\":1}}],[\"<u>\",{\"1\":{\"1598\":1}}],[\"<ul>\",{\"1\":{\"1594\":2}}],[\"<users\",{\"1\":{\"1030\":1}}],[\"<util\",{\"1\":{\"918\":1,\"1091\":1}}],[\"<connector\",{\"1\":{\"1683\":1}}],[\"<context\",{\"1\":{\"1020\":7,\"1065\":1,\"1683\":1}}],[\"<constructor\",{\"1\":{\"954\":1}}],[\"<t\",{\"1\":{\"1598\":1,\"1609\":1,\"1613\":1,\"1617\":1,\"1618\":8,\"1620\":2}}],[\"<t>\",{\"1\":{\"973\":1,\"1027\":1,\"1506\":1,\"1594\":1,\"1597\":1,\"1598\":7,\"1599\":6,\"1600\":1,\"1601\":5,\"1607\":1,\"1608\":1,\"1609\":1,\"1613\":1,\"1614\":1,\"1615\":1,\"1618\":4,\"1620\":2,\"1621\":2,\"1623\":1,\"1647\":1}}],[\"<to\",{\"1\":{\"624\":2}}],[\"<i>functional\",{\"1\":{\"1594\":2}}],[\"<import\",{\"1\":{\"918\":1,\"953\":2,\"954\":2}}],[\"<ip>\",{\"1\":{\"624\":1}}],[\"<parent\",{\"1\":{\"1689\":1}}],[\"<password>\",{\"1\":{\"624\":1}}],[\"<p\",{\"1\":{\"1623\":5}}],[\"<pre>\",{\"1\":{\"1595\":1,\"1608\":3}}],[\"<prop\",{\"1\":{\"1091\":2}}],[\"<property\",{\"1\":{\"917\":4,\"918\":1,\"930\":1,\"953\":2,\"989\":1,\"1003\":2,\"1012\":2,\"1032\":1,\"1065\":1,\"1084\":3,\"1091\":5,\"1146\":7}}],[\"<p>like\",{\"1\":{\"1608\":1}}],[\"<p>any\",{\"1\":{\"1599\":4}}],[\"<p>this\",{\"1\":{\"1597\":1,\"1598\":3,\"1599\":2,\"1600\":1,\"1601\":1,\"1608\":1}}],[\"<p>there\",{\"1\":{\"1600\":1}}],[\"<p>the\",{\"1\":{\"1595\":1,\"1608\":1}}],[\"<p>however\",{\"1\":{\"1594\":3}}],[\"<p>if\",{\"1\":{\"1594\":2}}],[\"<p>note\",{\"1\":{\"1594\":2}}],[\"<p>\",{\"1\":{\"1136\":1}}],[\"<a>\",{\"1\":{\"1615\":1}}],[\"<a\",{\"1\":{\"1597\":1,\"1598\":3,\"1599\":2,\"1600\":1,\"1601\":1,\"1608\":8}}],[\"<alias\",{\"1\":{\"928\":2}}],[\"<aop\",{\"0\":{\"818\":1,\"819\":1}}],[\"<artifactid>javax\",{\"1\":{\"965\":1}}],[\"<artifactid>jedis<\",{\"1\":{\"582\":1}}],[\"<artifactid>spring\",{\"1\":{\"583\":1}}],[\"<artifactid>fastjson<\",{\"1\":{\"582\":1}}],[\"<from\",{\"1\":{\"624\":2}}],[\"<r\",{\"1\":{\"1615\":1,\"1617\":1}}],[\"<r>\",{\"1\":{\"1598\":3,\"1608\":3,\"1615\":1,\"1622\":1,\"1623\":1}}],[\"<ref\",{\"1\":{\"918\":2}}],[\"<redis\",{\"1\":{\"624\":1}}],[\"<role>是\",{\"1\":{\"624\":1}}],[\"<role>\",{\"1\":{\"624\":1}}],[\"<numslaves>\",{\"1\":{\"624\":1}}],[\"<map>\",{\"1\":{\"989\":1}}],[\"<master\",{\"1\":{\"624\":8}}],[\"<milliseconds>\",{\"1\":{\"624\":2}}],[\"<quorum>\",{\"1\":{\"624\":1}}],[\"<service>\",{\"1\":{\"1683\":1}}],[\"<server>\",{\"1\":{\"1683\":1}}],[\"<s>\",{\"1\":{\"1623\":2}}],[\"<state>\",{\"1\":{\"624\":1}}],[\"<string\",{\"1\":{\"583\":1}}],[\"<script\",{\"1\":{\"624\":2}}],[\"<sort\",{\"1\":{\"520\":2}}],[\"<groupid>javax\",{\"1\":{\"965\":1}}],[\"<groupid>org\",{\"1\":{\"583\":1}}],[\"<groupid>com\",{\"1\":{\"582\":1}}],[\"<groupid>redis\",{\"1\":{\"582\":1}}],[\"<dependency>\",{\"1\":{\"582\":2,\"583\":1,\"965\":1}}],[\"<\",{\"1\":{\"330\":1,\"393\":2,\"399\":2,\"419\":1,\"468\":4,\"519\":1,\"536\":1,\"542\":1,\"571\":1,\"582\":4,\"583\":1,\"645\":2,\"917\":5,\"918\":14,\"930\":8,\"953\":8,\"954\":5,\"965\":1,\"985\":1,\"989\":6,\"996\":1,\"1003\":2,\"1012\":2,\"1030\":2,\"1032\":3,\"1061\":1,\"1065\":3,\"1084\":6,\"1091\":10,\"1103\":3,\"1146\":9,\"1182\":2,\"1288\":1,\"1347\":1,\"1404\":4,\"1476\":1,\"1480\":1,\"1487\":1,\"1503\":1,\"1506\":1,\"1517\":2,\"1550\":4,\"1553\":1,\"1554\":4,\"1574\":1,\"1591\":1,\"1593\":1,\"1594\":2,\"1595\":1,\"1599\":2,\"1608\":3,\"1611\":1,\"1612\":1,\"1614\":1,\"1620\":4,\"1683\":4}}],[\"<=28\",{\"1\":{\"306\":1}}],[\"<=\",{\"1\":{\"306\":1,\"400\":2,\"404\":3,\"407\":1,\"408\":1,\"409\":1,\"414\":1,\"544\":1,\"547\":1,\"549\":4,\"553\":2,\"555\":8,\"1412\":1,\"1503\":1,\"1554\":2,\"1601\":1,\"1689\":1}}],[\"了\",{\"1\":{\"330\":1,\"378\":1,\"478\":1,\"1550\":1,\"1561\":1}}],[\"了解学习的重难点和掌握合适的学习方法非常重要\",{\"1\":{\"1972\":1}}],[\"了解它对于我们认识stream类有着及其关键的作用\",{\"1\":{\"1615\":1}}],[\"了解这些方法的使用以及实现细节\",{\"1\":{\"1616\":1}}],[\"了解这个查询需要哪些索引以及它的执行计划是什么\",{\"1\":{\"388\":1}}],[\"了解这两个日志的作用\",{\"1\":{\"326\":1}}],[\"了解每个组件的作用\",{\"1\":{\"317\":1}}],[\"读socket\",{\"1\":{\"1533\":1,\"1534\":1}}],[\"读线程获取读锁后\",{\"1\":{\"1498\":1}}],[\"读读可以并发\",{\"1\":{\"1498\":1}}],[\"读多写少的场景\",{\"1\":{\"1527\":1}}],[\"读多写少\",{\"1\":{\"1403\":1}}],[\"读完之后\",{\"1\":{\"1286\":1}}],[\"读完释放锁\",{\"1\":{\"1261\":1}}],[\"读数据时加共享锁\",{\"1\":{\"1261\":1}}],[\"读到了其他事务未提交的数据\",{\"1\":{\"1261\":1}}],[\"读方法和写方法都会通过返回值来告知程序实际读写了多少字节\",{\"1\":{\"602\":1}}],[\"读操作不记录\",{\"1\":{\"591\":1}}],[\"读操作只读该事务开始前的数据库的快照\",{\"1\":{\"541\":1}}],[\"读取小文件\",{\"1\":{\"1587\":1}}],[\"读取\",{\"1\":{\"1473\":1}}],[\"读取时加共享锁\",{\"1\":{\"1261\":1}}],[\"读取时还要保证其他并发事务不能修改当前记录\",{\"1\":{\"541\":1}}],[\"读取其他事务未提交的数据\",{\"1\":{\"1238\":1}}],[\"读取当前package对应的所有的\",{\"1\":{\"1043\":1}}],[\"读取message\",{\"0\":{\"670\":1}}],[\"读取一个页面花费的成本默认是1\",{\"1\":{\"557\":1}}],[\"读取的数据量\",{\"1\":{\"555\":1}}],[\"读取这些二级索引记录的cpu成本就是\",{\"1\":{\"549\":1}}],[\"读取并检测回表后聚簇索引记录的成本\",{\"1\":{\"549\":1}}],[\"读取并检测回表后聚簇索引的成本\",{\"1\":{\"549\":1}}],[\"读取并检测这些完整的用户记录是否符合其余的搜索条件的cpu成本如下\",{\"1\":{\"549\":1}}],[\"读取二级索引记录的成本\",{\"1\":{\"549\":2}}],[\"读取以及检测一条记录是否符合搜索条件的成本默认是0\",{\"1\":{\"545\":1}}],[\"读取以及检测记录是否满足对应的搜索条件\",{\"1\":{\"545\":1}}],[\"读取记录最新的版本\",{\"1\":{\"541\":1}}],[\"读取本表中和关联表表中的每行组合成的一行\",{\"1\":{\"330\":1}}],[\"读已提交\",{\"1\":{\"532\":1,\"1238\":1}}],[\"读出来就是什么\",{\"1\":{\"529\":1}}],[\"读一个处理一个\",{\"1\":{\"482\":1}}],[\"读从库之前先sleep一下\",{\"1\":{\"471\":1}}],[\"读写操作可以并发执行\",{\"1\":{\"1503\":1}}],[\"读写锁有一下三个重要的特性\",{\"1\":{\"1498\":1}}],[\"读写锁能够提供比拍他锁更好的并发性和吞吐量\",{\"1\":{\"1498\":1}}],[\"读写锁之间\",{\"1\":{\"441\":1}}],[\"读写\",{\"1\":{\"1498\":1}}],[\"读写可以瞬间完成然后程序可以继续干别的事了\",{\"1\":{\"602\":1}}],[\"读写方法不会阻塞\",{\"1\":{\"602\":1}}],[\"读写io的函数一致无法返回\",{\"1\":{\"481\":1}}],[\"读写分离的主要目标就是分摊主库的压力\",{\"1\":{\"469\":1}}],[\"读写分离\",{\"0\":{\"469\":1},\"1\":{\"646\":1}}],[\"读写分离是怎么做的\",{\"0\":{\"160\":1,\"1269\":1}}],[\"读锁是共享的\",{\"1\":{\"1498\":1}}],[\"读锁可以由多个reader线程同时持有\",{\"1\":{\"1498\":1}}],[\"读锁和写锁都支持线程重入\",{\"1\":{\"1498\":1}}],[\"读锁之间不互斥\",{\"1\":{\"441\":1}}],[\"读锁\",{\"1\":{\"433\":1,\"533\":1,\"1263\":1,\"1399\":1}}],[\"读\",{\"1\":{\"433\":1}}],[\"读提交是指\",{\"1\":{\"433\":1}}],[\"读提交\",{\"1\":{\"433\":5}}],[\"读未提交是指\",{\"1\":{\"433\":1}}],[\"读未提交\",{\"1\":{\"433\":3,\"532\":1,\"1238\":1}}],[\"读page1的时候\",{\"1\":{\"345\":1}}],[\"得到servletresponse\",{\"1\":{\"1687\":1}}],[\"得到seconds\",{\"1\":{\"457\":1}}],[\"得到一个classmetadata\",{\"1\":{\"1646\":1}}],[\"得到一个平均值\",{\"1\":{\"347\":1}}],[\"得到数组下标\",{\"1\":{\"1546\":1}}],[\"得到数组里面的不同值\",{\"1\":{\"418\":1}}],[\"得到总共需要回表的记录数之后\",{\"1\":{\"549\":1}}],[\"得到t时刻的位点\",{\"1\":{\"467\":1}}],[\"得到当前a\",{\"1\":{\"467\":1}}],[\"得到按照时间排序的前10条里面含有左连接的查询语句\",{\"1\":{\"429\":1}}],[\"得到访问次数最多的10个sql\",{\"1\":{\"429\":1}}],[\"得到返回记录集最多的10个sql\",{\"1\":{\"429\":1}}],[\"得到结果集返回给客户端\",{\"1\":{\"416\":1}}],[\"得到1000这个值\",{\"1\":{\"414\":1}}],[\"得到的记录是排过序的\",{\"1\":{\"1544\":1}}],[\"得到的记录数不相同\",{\"1\":{\"1261\":1}}],[\"得到的索引行里的age和position是无序的\",{\"1\":{\"518\":1}}],[\"得到的值保持不变\",{\"1\":{\"494\":1}}],[\"得到的就是预期结果了\",{\"1\":{\"472\":1}}],[\"得到的结果直接作为结果集的一部分\",{\"1\":{\"414\":1}}],[\"得到的\",{\"1\":{\"412\":1}}],[\"得到最新结果的过程称为merge\",{\"1\":{\"343\":1}}],[\"得到id的值为500\",{\"1\":{\"335\":1}}],[\"得到新的一行数据\",{\"1\":{\"326\":1}}],[\"得保证查询至少达到range级别\",{\"1\":{\"330\":1}}],[\"衍生\",{\"1\":{\"330\":1}}],[\"最开始要学习的是\",{\"1\":{\"1969\":1}}],[\"最开始的beanclass实际上是一个string类型\",{\"1\":{\"998\":1}}],[\"最典型的mvc就是jsp+servlet+javabean的模式\",{\"1\":{\"1657\":1}}],[\"最早零拷贝的定义\",{\"1\":{\"1576\":1}}],[\"最小都为0\",{\"1\":{\"1554\":1}}],[\"最小值\",{\"1\":{\"479\":1,\"1615\":1,\"1616\":1}}],[\"最节省cpu\",{\"1\":{\"1520\":1}}],[\"最大作用就是对文件进行版本管理\",{\"1\":{\"1981\":1}}],[\"最大值\",{\"1\":{\"1615\":1,\"1616\":1}}],[\"最大限度地减少了线程竞争任务的可能性\",{\"1\":{\"1511\":1}}],[\"最大线程数的存活时间\",{\"1\":{\"1476\":1}}],[\"最大线程数\",{\"1\":{\"1476\":1}}],[\"最大连接数\",{\"1\":{\"1423\":1}}],[\"最快\",{\"1\":{\"1439\":1}}],[\"最慢\",{\"1\":{\"1439\":1}}],[\"最为安全的解决方案\",{\"1\":{\"1424\":1}}],[\"最不经常使用策略\",{\"1\":{\"1300\":1}}],[\"最不怕的就是rm删除数据了\",{\"1\":{\"488\":1}}],[\"最近最少使用策略\",{\"1\":{\"1300\":1}}],[\"最近修改\",{\"1\":{\"542\":1}}],[\"最基本的数据类型\",{\"1\":{\"1280\":1}}],[\"最右边移除值\",{\"1\":{\"571\":1}}],[\"最终就会进入到transactioninterceptor的invoke\",{\"1\":{\"1655\":1}}],[\"最终生成的结果必须是等价的\",{\"1\":{\"1615\":1}}],[\"最终返回一个整体\",{\"1\":{\"1609\":1}}],[\"最终将他们拼接起来\",{\"1\":{\"1608\":1}}],[\"最终将数据添加到容器中是由segment对象的put方法来完成\",{\"1\":{\"1553\":1}}],[\"最终输出时赋值给exchange\",{\"1\":{\"1479\":1}}],[\"最终eax存的compare\",{\"1\":{\"1479\":1}}],[\"最终一致性指的是保证事务在最后阶段\",{\"1\":{\"1333\":1}}],[\"最终通过反射的方式将依赖注入的对象设置到属性上\",{\"1\":{\"964\":1}}],[\"最终实际上都会调用的abstractbeandefinition的setinitmethodname\",{\"1\":{\"931\":1}}],[\"最终肯定会解析不成功的\",{\"1\":{\"637\":1}}],[\"最终mysql使用了idx\",{\"1\":{\"544\":1}}],[\"最终选择的访问路径\",{\"1\":{\"519\":1}}],[\"最优访问路径\",{\"1\":{\"519\":1}}],[\"最佳实践\",{\"0\":{\"510\":1,\"672\":1,\"676\":1}}],[\"最佳左前缀法则\",{\"0\":{\"370\":1},\"1\":{\"369\":1,\"370\":1}}],[\"最花时间的就是第三步在本地构建哈希表的操作\",{\"1\":{\"482\":1}}],[\"最可能影响并发度的锁尽量完后放\",{\"1\":{\"443\":1}}],[\"最简单的方案就是避免共享\",{\"1\":{\"1528\":1}}],[\"最简单的分布式锁\",{\"1\":{\"1288\":1}}],[\"最简单的事件轮询api是select函数\",{\"1\":{\"603\":1}}],[\"最简单的衡量查询开销的三个指标如下\",{\"1\":{\"387\":1}}],[\"最简单直接的方法就是执行select\",{\"1\":{\"476\":1}}],[\"最简单有效的解决方法就是在这样的查询后面加上limit\",{\"1\":{\"383\":1}}],[\"最好做笔记\",{\"1\":{\"1972\":1}}],[\"最好还是要有意义\",{\"1\":{\"1595\":1}}],[\"最好能通过模拟对比评估\",{\"1\":{\"1510\":1}}],[\"最好的方式就是自己带一个有业务标识的id\",{\"1\":{\"1329\":1}}],[\"最好的方式是将控制器设计成无状态模式\",{\"1\":{\"1240\":1}}],[\"最好的办法是安排更合里的sharding布局并且增加节点数据\",{\"1\":{\"1257\":1}}],[\"最好就是只恢复这张表\",{\"1\":{\"485\":1}}],[\"最好使用set\",{\"1\":{\"435\":1}}],[\"最好索引怎么创建的\",{\"1\":{\"378\":1}}],[\"最好达到ref\",{\"1\":{\"330\":1}}],[\"最后再来看原理部分\",{\"1\":{\"1993\":1}}],[\"最后还会带大家做一个书城项目\",{\"1\":{\"1978\":1}}],[\"最后还要分析是否可能会使用到索引合并\",{\"1\":{\"549\":1}}],[\"最后创建一个新的beanfactory\",{\"1\":{\"1651\":1}}],[\"最后调用普通对象的方法\",{\"1\":{\"1630\":1}}],[\"最后将执行的结果\",{\"1\":{\"1623\":1}}],[\"最后将准备好的pvs对象赋值给beanwrapper\",{\"1\":{\"1003\":1}}],[\"最后进行汇聚操作\",{\"1\":{\"1623\":1}}],[\"最后进行测试\",{\"1\":{\"1138\":1}}],[\"最后流被汇总起来生成一个总的重量\",{\"1\":{\"1619\":1}}],[\"最后返回结果\",{\"1\":{\"1608\":1}}],[\"最后返回累计值\",{\"1\":{\"399\":1}}],[\"最后探究stream的实现原理\",{\"1\":{\"1607\":1}}],[\"最后这个方法就比较简单了\",{\"1\":{\"1598\":1}}],[\"最后利用dma将socket\",{\"1\":{\"1582\":1}}],[\"最后是concurrenthashmap的扩容过程\",{\"1\":{\"1554\":1}}],[\"最后是spring\",{\"1\":{\"1023\":1}}],[\"最后释放读锁的过程\",{\"1\":{\"1498\":1}}],[\"最后我们可以看一个jdk实现的一个例子\",{\"1\":{\"1608\":1}}],[\"最后我们可以通过执行exec\",{\"1\":{\"1297\":1}}],[\"最后我们来看一下对于参数的说明\",{\"1\":{\"1608\":1}}],[\"最后我们来看一下它唯一的static方法\",{\"1\":{\"1599\":1}}],[\"最后我们来查看以下\",{\"1\":{\"961\":1}}],[\"最后协调节点将数据整合返回给客户端\",{\"1\":{\"1256\":1}}],[\"最后观察输出\",{\"1\":{\"1146\":1}}],[\"最后优化器会比较这两种方式的最优访问成本\",{\"1\":{\"555\":1}}],[\"最后两个参数分别表示\",{\"1\":{\"467\":1}}],[\"最后一点是从性能的角度去考虑\",{\"1\":{\"1509\":1}}],[\"最后一次append方法结束后进行解锁\",{\"1\":{\"1486\":1}}],[\"最后一次修改该记录的事务id\",{\"1\":{\"542\":1}}],[\"最后一个元素\",{\"1\":{\"571\":1}}],[\"最后一个值弹出\",{\"1\":{\"571\":1}}],[\"最后一种方式是\",{\"1\":{\"526\":1}}],[\"最后一种方法是\",{\"1\":{\"444\":1}}],[\"最后一列sum\",{\"1\":{\"479\":1}}],[\"最后一行是一个commit\",{\"1\":{\"454\":1}}],[\"最后判断是否出现了循环等待\",{\"1\":{\"444\":1}}],[\"最后把这些消耗都加起来\",{\"1\":{\"388\":1}}],[\"最后的更新覆盖了由其他事务所做的更新\",{\"1\":{\"532\":1}}],[\"最后的第四组数据\",{\"1\":{\"479\":1}}],[\"最后的xid\",{\"1\":{\"454\":1}}],[\"最后的\",{\"1\":{\"355\":1}}],[\"最后的查询select\",{\"1\":{\"354\":1}}],[\"最后才能基于表插入数据\",{\"1\":{\"309\":1}}],[\"最根本的原因是没有能准确地判断出扫描行数\",{\"1\":{\"347\":1}}],[\"最左前缀可以用于在索引中定位记录\",{\"1\":{\"340\":1}}],[\"最左前缀\",{\"1\":{\"339\":1}}],[\"最左前缀原则\",{\"0\":{\"339\":1}}],[\"最外层查询则被标记为primary\",{\"1\":{\"330\":1}}],[\"联合索引尽量覆盖条件\",{\"1\":{\"521\":1}}],[\"联合查询\",{\"1\":{\"330\":1}}],[\"联系与区别\",{\"0\":{\"8\":1,\"1337\":1}}],[\"联系我\",{\"0\":{\"5\":1}}],[\"表达的具体含义\",{\"1\":{\"1595\":1}}],[\"表达力更强\",{\"1\":{\"1591\":1}}],[\"表达式和\",{\"1\":{\"1978\":1}}],[\"表达式\",{\"1\":{\"1073\":1}}],[\"表达式语言模块\",{\"1\":{\"903\":1}}],[\"表排他写锁\",{\"1\":{\"1263\":1}}],[\"表共享读锁\",{\"1\":{\"1263\":1}}],[\"表结构设计\",{\"0\":{\"560\":1}}],[\"表结构的定义是存放在后缀名为\",{\"1\":{\"490\":1}}],[\"表c进行连接\",{\"1\":{\"556\":1}}],[\"表b\",{\"1\":{\"556\":1}}],[\"表依赖详情\",{\"1\":{\"519\":1}}],[\"表数据文件本身就是按b+tree组织的一个索引结构文件\",{\"1\":{\"505\":1}}],[\"表定义的自增值达到上限后的逻辑是\",{\"1\":{\"494\":1}}],[\"表定义自增值id\",{\"0\":{\"494\":1}}],[\"表定义里面出现了auto\",{\"1\":{\"490\":1}}],[\"表的自增主键id达到上限后\",{\"1\":{\"499\":1}}],[\"表的自增值可以恢复为mysql重启前的值\",{\"1\":{\"490\":1}}],[\"表的方法\",{\"0\":{\"487\":1}}],[\"表的读取和加载顺序\",{\"1\":{\"330\":1}}],[\"表的读取顺序\",{\"1\":{\"329\":1}}],[\"表\",{\"0\":{\"485\":1}}],[\"表上没有主键\",{\"1\":{\"465\":1}}],[\"表上如果有外键\",{\"1\":{\"462\":1}}],[\"表必须有主键\",{\"1\":{\"462\":1}}],[\"表级别的锁\",{\"0\":{\"439\":1}}],[\"表级锁和行锁三类\",{\"1\":{\"436\":1}}],[\"表管理的实现上很粗糙\",{\"1\":{\"425\":1}}],[\"表t2的数据总量\",{\"1\":{\"525\":1}}],[\"表t1的数据总量\",{\"1\":{\"525\":1}}],[\"表t1中字段a是逆序的\",{\"1\":{\"404\":1}}],[\"表temp\",{\"1\":{\"413\":1}}],[\"表名称2\",{\"1\":{\"534\":1}}],[\"表名称\",{\"1\":{\"534\":1}}],[\"表名\",{\"1\":{\"412\":1,\"461\":1,\"558\":5,\"559\":2}}],[\"表锁的语法是lock\",{\"1\":{\"440\":1}}],[\"表锁\",{\"0\":{\"440\":1,\"534\":1},\"1\":{\"388\":1,\"1263\":1}}],[\"表面上是叫做分组\",{\"1\":{\"378\":1}}],[\"表索引列有1980个不同的值\",{\"1\":{\"359\":1}}],[\"表里面已经有了id=3的行\",{\"1\":{\"491\":1}}],[\"表里面多了一行\",{\"1\":{\"447\":1}}],[\"表里有两个字段m和c\",{\"1\":{\"416\":1}}],[\"表里有a\",{\"1\":{\"346\":1}}],[\"表里只有一个id字段\",{\"1\":{\"317\":1}}],[\"表中存放对象的信息\",{\"1\":{\"573\":1}}],[\"表中的数据也一直在变化\",{\"1\":{\"559\":1}}],[\"表中每一项的含义\",{\"1\":{\"557\":1}}],[\"表中t1中除了主键\",{\"1\":{\"462\":1}}],[\"表中有两个字段\",{\"1\":{\"420\":1}}],[\"表中有字段k\",{\"1\":{\"335\":1}}],[\"表中包含三个字段v\",{\"1\":{\"411\":1}}],[\"表中r1~r5的\",{\"1\":{\"335\":1}}],[\"表都是根据主键顺序以索引的形式存放的\",{\"1\":{\"335\":1}}],[\"表明cas失败\",{\"1\":{\"1479\":1}}],[\"表明cas成功\",{\"1\":{\"1479\":1}}],[\"表明不想让该表自动重新计算统计数据\",{\"1\":{\"559\":1}}],[\"表明我们想让该表自动重新计算统计数据\",{\"1\":{\"559\":1}}],[\"表明我们想把该表的统计数据临时的存储到内存中\",{\"1\":{\"558\":1}}],[\"表明我们想把该表的统计数据永久的存储到磁盘上\",{\"1\":{\"558\":1}}],[\"表明order\",{\"1\":{\"558\":3}}],[\"表明使用了where过滤\",{\"1\":{\"330\":1}}],[\"表明索引用来读取数据而非执行查找动作\",{\"1\":{\"330\":1}}],[\"表示要增强这个配置类\",{\"1\":{\"1652\":1}}],[\"表示要获取的对象是factorybean本身的对象\",{\"1\":{\"1647\":1}}],[\"表示默认情况下spring扫描过程中会认为类上有\",{\"1\":{\"1645\":1}}],[\"表示扫描com\",{\"1\":{\"1645\":1}}],[\"表示stringtouserpropertyeditor可以将string转化成user类型\",{\"1\":{\"1638\":1}}],[\"表示可以指定某个类加载器进行类的加载\",{\"1\":{\"1636\":1}}],[\"表示bean销毁时要执行的方法\",{\"1\":{\"1632\":1}}],[\"表示bean初始化时要执行的方法\",{\"1\":{\"1632\":1}}],[\"表示bean是否是懒加载\",{\"1\":{\"1632\":1}}],[\"表示bean的作用域\",{\"1\":{\"1632\":1}}],[\"表示bean的类型\",{\"1\":{\"1632\":1}}],[\"表示需要进行aop\",{\"1\":{\"1630\":1}}],[\"表示需要排序\",{\"1\":{\"416\":1}}],[\"表示下游的操作\",{\"1\":{\"1623\":1}}],[\"表示下一次插入数时\",{\"1\":{\"490\":1}}],[\"表示流已经消费完成\",{\"1\":{\"1621\":1}}],[\"表示串行\",{\"1\":{\"1621\":1}}],[\"表示管道反向链接的头\",{\"1\":{\"1621\":1}}],[\"表示是有顺序的\",{\"1\":{\"1621\":1}}],[\"表示取前几个元素\",{\"1\":{\"1610\":1}}],[\"表示跳过\",{\"1\":{\"1610\":1}}],[\"表示一种映射关系\",{\"1\":{\"1609\":1}}],[\"表示返回当前predicate的逻辑非\",{\"1\":{\"1599\":1}}],[\"表示多了一个线程在帮助扩容\",{\"1\":{\"1554\":1}}],[\"表示多个事务可以对同一个数据共享同一把锁\",{\"1\":{\"1263\":1}}],[\"表示多个数据操作组成一个完整的事务单元\",{\"1\":{\"1262\":1}}],[\"表示该beanfactory支持bean的后置处理器\",{\"1\":{\"1636\":1}}],[\"表示该beanfactory可以进行类型转化\",{\"1\":{\"1636\":1}}],[\"表示该beanfactory可以解析el表达式\",{\"1\":{\"1636\":1}}],[\"表示该节点是链表\",{\"1\":{\"1554\":1}}],[\"表示该索引共占用多少页面\",{\"1\":{\"558\":1}}],[\"表示扩容后key1和key2两种key确定索引位置的示例\",{\"1\":{\"1550\":1}}],[\"表示扩容前key1和key2两种key确定索引位置的示例\",{\"1\":{\"1550\":1}}],[\"表示当前场景下后续的acquireshared能够得以执行\",{\"1\":{\"1490\":1}}],[\"表示当前节点在等待condition\",{\"1\":{\"1490\":1}}],[\"表示当前节点在sync队列中\",{\"1\":{\"1490\":1}}],[\"表示当前节点的后继节点包含的线程需要运行\",{\"1\":{\"1490\":1}}],[\"表示当前的线程被取消\",{\"1\":{\"1490\":1}}],[\"表示把eax中存的值写入exchange\",{\"1\":{\"1479\":1}}],[\"表示concurrenthashmap正在执行初始化\",{\"1\":{\"1554\":1}}],[\"表示compare\",{\"1\":{\"1479\":1}}],[\"表示change\",{\"1\":{\"343\":1}}],[\"表示自己和成员变量都已经标记完毕\",{\"1\":{\"1442\":1}}],[\"表示读取这么多字节后再返回\",{\"1\":{\"602\":1}}],[\"表示60\",{\"1\":{\"587\":1}}],[\"表示300\",{\"1\":{\"587\":1}}],[\"表示900\",{\"1\":{\"587\":1}}],[\"表示单位为英尺\",{\"1\":{\"576\":1}}],[\"表示单位为英里\",{\"1\":{\"576\":1}}],[\"表示单位为千米\",{\"1\":{\"576\":1}}],[\"表示单位为米\",{\"1\":{\"576\":1}}],[\"表示参与运算的集合数\",{\"1\":{\"574\":1}}],[\"表示参与排序的只有name和id这两个字段\",{\"1\":{\"355\":1}}],[\"表示参与排序的行数是4000行\",{\"1\":{\"354\":1}}],[\"表示key过期\",{\"1\":{\"569\":1}}],[\"表示对应的索引列不重复的值有多少\",{\"1\":{\"558\":1}}],[\"表示在这个版本是由已提交的事务生成的\",{\"1\":{\"542\":1}}],[\"表示在对子查询的结果做union的时候\",{\"1\":{\"414\":1}}],[\"表示采用之前mysql5\",{\"1\":{\"492\":1}}],[\"表示断开这个线程的连接\",{\"1\":{\"480\":1}}],[\"表示终止这个线程中正在执行的语句\",{\"1\":{\"480\":1}}],[\"表示系统的io是正在工作的\",{\"1\":{\"478\":1}}],[\"表示不限制并发线程数量\",{\"1\":{\"476\":1}}],[\"表示从命令开始执行\",{\"1\":{\"473\":1}}],[\"表示收到了\",{\"1\":{\"472\":1}}],[\"表示这对主备关系使用了gtid协议\",{\"1\":{\"472\":1}}],[\"表示这个版本已经提交了的事务生成的\",{\"1\":{\"542\":1}}],[\"表示这个版本是由还未提交的事务生成的\",{\"1\":{\"542\":1}}],[\"表示这个版本是由将来启动的事务生成的\",{\"1\":{\"542\":1}}],[\"表示这个日志是自己生成的\",{\"1\":{\"455\":1}}],[\"表示这个事务是在server\",{\"1\":{\"454\":1}}],[\"表示这个语句使用了覆盖索引\",{\"1\":{\"416\":1}}],[\"表示这个线程接下来的语句都会被记录入慢查询日志中\",{\"1\":{\"346\":1}}],[\"表示a\",{\"1\":{\"468\":1}}],[\"表示延迟多少微妙后才调用fsync\",{\"1\":{\"465\":1}}],[\"表示使用mysql5\",{\"1\":{\"465\":1}}],[\"表示使用了临时表\",{\"1\":{\"416\":1}}],[\"表示会影响到这个表a=1的行\",{\"1\":{\"462\":1}}],[\"表示会影响到这个表a=2的行\",{\"1\":{\"462\":1}}],[\"表示队列中有多少个事务修改这个表\",{\"1\":{\"461\":1}}],[\"表示中间是一个事务\",{\"1\":{\"454\":1}}],[\"表示累积多少次以后才调用fsync\",{\"1\":{\"451\":1,\"465\":1}}],[\"表示每次事务提交时都将redo\",{\"1\":{\"451\":1}}],[\"表示每次事务提交时都只是把redo\",{\"1\":{\"451\":2}}],[\"表示每次提交事务都write\",{\"1\":{\"450\":1}}],[\"表示每次提交事务都会执行fsync\",{\"1\":{\"450\":1}}],[\"表示每次提交事务都只write\",{\"1\":{\"450\":1}}],[\"表示只使用了覆盖索引\",{\"1\":{\"414\":1}}],[\"表示\",{\"1\":{\"403\":1}}],[\"表示mysql将通过where条件来筛选存储引擎返回的记录\",{\"1\":{\"390\":1}}],[\"表示没有用上交易详情表trade\",{\"1\":{\"368\":1}}],[\"表示的就是a\",{\"1\":{\"467\":1}}],[\"表示的就是类似mariadb的策略\",{\"1\":{\"465\":1}}],[\"表示的就是使用了覆盖索引\",{\"1\":{\"356\":1}}],[\"表示的是中间结果容器的类型\",{\"1\":{\"1618\":1}}],[\"表示的是备库执行的最新位点\",{\"1\":{\"472\":1}}],[\"表示的是读到的主库的最新位点\",{\"1\":{\"472\":1}}],[\"表示的是需要使用临时表\",{\"1\":{\"420\":1}}],[\"表示的是只会取查询需要的字段\",{\"1\":{\"405\":1}}],[\"表示的是用上了mrr优化\",{\"1\":{\"404\":1}}],[\"表示的是使用了覆盖索引\",{\"1\":{\"366\":1}}],[\"表示的是\",{\"1\":{\"366\":1}}],[\"表示排序可以直接在内存中完成\",{\"1\":{\"354\":1}}],[\"表示就是需要排序\",{\"1\":{\"354\":1}}],[\"表示统计信息只存储在内存中\",{\"1\":{\"347\":1}}],[\"表示统计信息会持久化存储\",{\"1\":{\"347\":1}}],[\"表示索引列中不重复值的个数\",{\"1\":{\"553\":1}}],[\"表示索引被用来执行索引键值的查找\",{\"1\":{\"330\":1}}],[\"表示索引中使用的字节数\",{\"1\":{\"330\":1}}],[\"表示相应的select操作中使用了覆盖索引\",{\"1\":{\"330\":1}}],[\"表示通过索引一次就找到了\",{\"1\":{\"330\":1}}],[\"表只有一行记录\",{\"1\":{\"330\":1}}],[\"表之间的引用\",{\"1\":{\"329\":1}}],[\"+useserialgc\",{\"1\":{\"1669\":1}}],[\"+usebiasedlocking\",{\"1\":{\"1485\":1}}],[\"+=\",{\"1\":{\"1618\":2,\"1620\":2}}],[\"+顺序的方式来表示\",{\"1\":{\"1592\":1}}],[\"+i1\",{\"1\":{\"1591\":1}}],[\"+i\",{\"1\":{\"1521\":1,\"1591\":1}}],[\"+inf分别表示最小最大值\",{\"1\":{\"574\":1}}],[\"+eliminatelocks\",{\"1\":{\"1487\":1}}],[\"+4\",{\"1\":{\"1484\":2}}],[\"+printflagsfinal\",{\"1\":{\"1455\":1,\"1485\":1}}],[\"+printflagsinitial\",{\"1\":{\"1455\":1}}],[\"+printcommandlineflags\",{\"1\":{\"1453\":1}}],[\"++j\",{\"1\":{\"1550\":1}}],[\"++size\",{\"1\":{\"1549\":1}}],[\"++modcount\",{\"1\":{\"1549\":1,\"1553\":2}}],[\"++bincount\",{\"1\":{\"1549\":1,\"1554\":1}}],[\"++i\",{\"1\":{\"1517\":1,\"1620\":1}}],[\"++takeindex\",{\"1\":{\"1502\":1}}],[\"++putindex\",{\"1\":{\"1502\":1}}],[\"++\",{\"1\":{\"1404\":1}}],[\"+5\",{\"1\":{\"574\":1}}],[\"+100\",{\"1\":{\"525\":1}}],[\"+1作为这个表当前的自增值\",{\"1\":{\"490\":1}}],[\"+1\",{\"1\":{\"462\":1}}],[\"+2\",{\"1\":{\"462\":2}}],[\"+supremum\",{\"1\":{\"448\":1}}],[\"+n\",{\"1\":{\"422\":1}}],[\"+\",{\"1\":{\"329\":1,\"330\":21,\"358\":1,\"366\":1,\"371\":36,\"400\":1,\"404\":2,\"412\":2,\"413\":2,\"414\":1,\"419\":5,\"422\":1,\"428\":27,\"430\":2,\"431\":42,\"476\":2,\"480\":2,\"542\":1,\"548\":3,\"549\":14,\"553\":1,\"555\":4,\"574\":4,\"645\":2,\"917\":17,\"919\":1,\"921\":3,\"922\":2,\"928\":7,\"929\":2,\"936\":1,\"940\":1,\"941\":3,\"943\":1,\"944\":1,\"953\":3,\"961\":11,\"962\":3,\"963\":1,\"964\":1,\"967\":1,\"973\":6,\"978\":3,\"985\":19,\"989\":1,\"994\":1,\"995\":1,\"996\":19,\"997\":7,\"1000\":1,\"1001\":4,\"1003\":8,\"1005\":12,\"1006\":1,\"1007\":5,\"1009\":1,\"1011\":1,\"1012\":3,\"1022\":5,\"1029\":1,\"1040\":1,\"1041\":1,\"1043\":2,\"1045\":2,\"1054\":2,\"1055\":6,\"1061\":2,\"1065\":4,\"1092\":2,\"1108\":1,\"1112\":1,\"1113\":1,\"1121\":7,\"1163\":1,\"1166\":2,\"1167\":6,\"1168\":7,\"1175\":1,\"1181\":2,\"1184\":16,\"1200\":1,\"1208\":2,\"1209\":1,\"1263\":1,\"1288\":1,\"1333\":1,\"1347\":1,\"1359\":3,\"1369\":2,\"1404\":3,\"1410\":1,\"1412\":1,\"1424\":1,\"1475\":2,\"1479\":18,\"1480\":2,\"1487\":2,\"1498\":1,\"1503\":1,\"1506\":2,\"1550\":3,\"1553\":2,\"1554\":8,\"1573\":2,\"1574\":2,\"1575\":2,\"1598\":5,\"1606\":1,\"1609\":3,\"1610\":9,\"1613\":6,\"1615\":1,\"1617\":3,\"1620\":1,\"1622\":1,\"1647\":38,\"1648\":3,\"1650\":1,\"1651\":3,\"1655\":2,\"1658\":3}}],[\"崩溃恢复以后这个事务无效\",{\"1\":{\"327\":1}}],[\"按原问题的要求\",{\"1\":{\"1510\":1}}],[\"按分数范围获取成员等操作\",{\"1\":{\"1280\":1}}],[\"按任意键继续并且关闭spring\",{\"1\":{\"1175\":1}}],[\"按距离递增排序\",{\"1\":{\"576\":1}}],[\"按字典倒序\",{\"1\":{\"574\":1}}],[\"按字典顺序倒序\",{\"1\":{\"574\":1}}],[\"按字典顺序排序\",{\"1\":{\"574\":1}}],[\"按score递减顺序\",{\"1\":{\"574\":2}}],[\"按score递减排序\",{\"1\":{\"574\":1}}],[\"按索引显示查询结果的\",{\"1\":{\"574\":1}}],[\"按起止位置获取字符串\",{\"1\":{\"570\":1}}],[\"按指定的步长对数值进行加减\",{\"1\":{\"570\":1}}],[\"按顺序取binlog发给b去执行\",{\"1\":{\"468\":1}}],[\"按顺序遍历\",{\"1\":{\"332\":1}}],[\"按行分发这种策略会设置一个阈值\",{\"1\":{\"462\":1}}],[\"按行分发的策略有两个问题\",{\"1\":{\"462\":1}}],[\"按行分发策略的并行度会更高\",{\"1\":{\"462\":1}}],[\"按行分发策略\",{\"0\":{\"462\":1}}],[\"按行并行策略在决定线程分发的时候\",{\"1\":{\"462\":1}}],[\"按行复制和按表复制的数据结构差不多\",{\"1\":{\"462\":1}}],[\"按行复制的核心思路是\",{\"1\":{\"462\":1}}],[\"按行累加\",{\"1\":{\"399\":2}}],[\"按表分发和按行分发策略并没有被合并到官方\",{\"1\":{\"462\":1}}],[\"按表分发事务的基本思路是\",{\"1\":{\"461\":1}}],[\"按表分发策略\",{\"0\":{\"461\":1}}],[\"按主键顺序取出所有word值\",{\"1\":{\"420\":1}}],[\"按数据长度增加地方向\",{\"1\":{\"368\":1}}],[\"按name排序\",{\"1\":{\"354\":1}}],[\"按层搜索到叶子节点\",{\"1\":{\"342\":1}}],[\"按照元素输入的顺序提供给consumer\",{\"1\":{\"1623\":1}}],[\"按照这种方式我们称之为\",{\"1\":{\"1620\":1}}],[\"按照这个逻辑的话就要申请10万次\",{\"1\":{\"492\":1}}],[\"按照这个逻辑\",{\"1\":{\"455\":1,\"461\":1}}],[\"按照这个逻辑执行的话\",{\"1\":{\"417\":1}}],[\"按照如上定义\",{\"1\":{\"1567\":1}}],[\"按照经验法则\",{\"1\":{\"1434\":1}}],[\"按照userid进行了分片\",{\"1\":{\"1270\":1}}],[\"按照目标字段前缀指定进行分区\",{\"1\":{\"1270\":1}}],[\"按照枚举值分片\",{\"1\":{\"1270\":1}}],[\"按照时间分片\",{\"1\":{\"1270\":1}}],[\"按照时间分区的分区表\",{\"1\":{\"426\":1}}],[\"按照范围分片\",{\"1\":{\"1270\":1}}],[\"按照次序依次进行初始化操作\",{\"1\":{\"975\":1}}],[\"按照内建的注入规则\",{\"1\":{\"951\":1}}],[\"按照类型查找集合对象\",{\"1\":{\"917\":2,\"921\":2,\"941\":1}}],[\"按照类型查找\",{\"1\":{\"917\":3}}],[\"按照ioc的定义\",{\"1\":{\"914\":1}}],[\"按照id的值回到原表中取出所有字段的值返回给客户端\",{\"1\":{\"520\":1}}],[\"按照id\",{\"1\":{\"416\":1}}],[\"按照插入顺序排序\",{\"1\":{\"571\":1}}],[\"按照一定算法选取几个叶子结点页面\",{\"1\":{\"558\":1}}],[\"按照上述思路我们计算idx\",{\"1\":{\"549\":1}}],[\"按照上面提到的判断方法\",{\"1\":{\"472\":1}}],[\"按照日志顺序执行\",{\"1\":{\"447\":1}}],[\"按照何种方式排序\",{\"1\":{\"429\":1}}],[\"按照年份来划分\",{\"1\":{\"424\":1}}],[\"按照定义的分区的规则\",{\"1\":{\"424\":1}}],[\"按照字段f\",{\"1\":{\"411\":1}}],[\"按照字符集转换规则\",{\"1\":{\"368\":1}}],[\"按照顺序使用\",{\"1\":{\"378\":1}}],[\"按照排序结果取前1000行返回给客户端\",{\"1\":{\"354\":1}}],[\"按照途中搜索的顺序就是按照usera\",{\"1\":{\"334\":1}}],[\"按照线程安全的强度来区分\",{\"0\":{\"62\":1,\"1391\":1}}],[\"按需要恢复到线上库去\",{\"1\":{\"327\":1}}],[\"首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用\",{\"1\":{\"1666\":1}}],[\"首先将id\",{\"1\":{\"332\":1}}],[\"首先是定义在referencepipeline类当中的内部类head\",{\"1\":{\"1621\":1}}],[\"首先是tryadvance方法\",{\"1\":{\"1620\":1}}],[\"首先是通过二次哈希减小哈希冲突的可能性\",{\"1\":{\"1553\":1}}],[\"首先还是定义一个非常简单的例子\",{\"1\":{\"1620\":1}}],[\"首先stream是一个支持并行与串行聚合操作的元素的序列\",{\"1\":{\"1619\":1}}],[\"首先来查看reducing方法的定义\",{\"1\":{\"1618\":1}}],[\"首先来读一下方法的说明\",{\"1\":{\"1618\":1}}],[\"首先来看方法的说明\",{\"1\":{\"1620\":1}}],[\"首先来看这样一个例子\",{\"1\":{\"1610\":1,\"1612\":1}}],[\"首先来看一下groupingby方法的定义\",{\"1\":{\"1618\":1}}],[\"首先来看一下类的说明\",{\"1\":{\"1615\":1}}],[\"首先来看一下a\",{\"1\":{\"347\":1}}],[\"首先来看一个具体的例子\",{\"1\":{\"1609\":1}}],[\"首先来看minby\",{\"1\":{\"1601\":1}}],[\"首先来看类的说明\",{\"1\":{\"1600\":1,\"1601\":1}}],[\"首先来看第二行\",{\"1\":{\"1592\":1}}],[\"首先回到我们之前的例子当中\",{\"1\":{\"1615\":1}}],[\"首先可以看到这是一个函数式接口\",{\"1\":{\"1614\":1}}],[\"首先会通过supplier\",{\"1\":{\"1608\":1}}],[\"首先会应用当前的function\",{\"1\":{\"1598\":1}}],[\"首先会应用before这个function\",{\"1\":{\"1598\":1}}],[\"首先创建一个student类\",{\"1\":{\"1600\":1}}],[\"首先调用传入的function的apply\",{\"1\":{\"1598\":1}}],[\"首先它是从初始状态开始的\",{\"1\":{\"1623\":1}}],[\"首先它是一个默认方法\",{\"1\":{\"1595\":1}}],[\"首先它会立刻返回\",{\"1\":{\"1566\":1}}],[\"首先同样的是在collection接口中新增加了一个default\",{\"1\":{\"1593\":1}}],[\"首先需要考虑的就是功能层面\",{\"1\":{\"1509\":1}}],[\"首先比较它的内存值与某个期望值是否相同\",{\"1\":{\"1479\":1}}],[\"首先判断是单机服务还是分布式服务\",{\"1\":{\"1248\":1}}],[\"首先定义这样两个接口\",{\"1\":{\"1607\":1}}],[\"首先定义一个转换器\",{\"1\":{\"1639\":1}}],[\"首先定义一个这样的类\",{\"1\":{\"1604\":1}}],[\"首先定义一个类\",{\"1\":{\"1603\":1}}],[\"首先定义一个学生类\",{\"1\":{\"1184\":1}}],[\"首先定义一个properties文件\",{\"1\":{\"1146\":1}}],[\"首先定义一个注解\",{\"1\":{\"1138\":1}}],[\"首先定义importselector的实现类\",{\"1\":{\"1138\":1}}],[\"首先演示第一种基于配置类实现\",{\"1\":{\"1138\":1}}],[\"首先在userholder中重写finalize\",{\"1\":{\"1013\":1}}],[\"首先在实例x中创建表t\",{\"1\":{\"468\":1}}],[\"首先进行定义\",{\"1\":{\"989\":1}}],[\"首先有这样两个属性\",{\"1\":{\"975\":1}}],[\"首先注入一个autowiredannotationbeanpostprocessor\",{\"1\":{\"967\":1}}],[\"首先改造以下我们之前看到的例子\",{\"1\":{\"963\":1}}],[\"首先观察以下依赖的描述类\",{\"1\":{\"963\":1}}],[\"首先对表中的cost\",{\"1\":{\"557\":1}}],[\"首先分析一下server\",{\"1\":{\"557\":1}}],[\"首先看一下涉及s2表单表的搜索条件有s2\",{\"1\":{\"555\":1}}],[\"首先看一下涉及s1表单表的搜索条件有s1\",{\"1\":{\"555\":1}}],[\"首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行id\",{\"1\":{\"520\":1}}],[\"首先我们为接下来的部分提前定义好一个学生类作为我们分析源码的入口\",{\"1\":{\"1613\":1}}],[\"首先我们创建一个stream\",{\"1\":{\"1607\":1}}],[\"首先我们需要了解一些stream的基本概念\",{\"1\":{\"1607\":1}}],[\"首先我们需要把当前的max\",{\"1\":{\"497\":1}}],[\"首先我们来阅读以下这个方法的说明\",{\"1\":{\"1618\":1}}],[\"首先我们来分析一下我们使用过的最多的tolist方法\",{\"1\":{\"1618\":1}}],[\"首先我们来看一下reduceops的makeref方法\",{\"1\":{\"1617\":1}}],[\"首先我们来读一下它的javadoc\",{\"1\":{\"1598\":1}}],[\"首先我们来回顾一下nlj算法的执行流程\",{\"1\":{\"405\":1}}],[\"首先我们观察consumer这个接口的定义\",{\"1\":{\"1597\":1}}],[\"首先我们使用传统的匿名内部类的方式来实现myinterface中的test\",{\"1\":{\"1595\":1}}],[\"首先我们给出这个接口的使用示例\",{\"1\":{\"1000\":1}}],[\"首先我们增加一个成员变量\",{\"1\":{\"963\":1}}],[\"首先我们列表\",{\"1\":{\"571\":1}}],[\"首先要在堆中先创建一个对象\",{\"1\":{\"1436\":1}}],[\"首先要了解一条命令\",{\"1\":{\"473\":1}}],[\"首先要明确的一个概念是\",{\"1\":{\"457\":1}}],[\"首先要解决的是长事务\",{\"1\":{\"441\":1}}],[\"首先使用alter\",{\"1\":{\"424\":1}}],[\"首先计算这个列上有多少个不同的值\",{\"1\":{\"350\":1}}],[\"首先扫描索引b的最后50001个值\",{\"1\":{\"347\":1}}],[\"首先扫描索引a的前1000个值\",{\"1\":{\"347\":1}}],[\"首先先建一张表\",{\"1\":{\"346\":1}}],[\"首先\",{\"1\":{\"327\":1,\"352\":1,\"478\":1,\"481\":1,\"1234\":1,\"1479\":1,\"1605\":1,\"1968\":1}}],[\"两者是完全不同的\",{\"1\":{\"1592\":1}}],[\"两者的区别在于\",{\"1\":{\"1375\":1,\"1408\":1}}],[\"两者的区别主要在于遍历和集合本身是否分离\",{\"1\":{\"1353\":1}}],[\"两次\",{\"1\":{\"1554\":1}}],[\"两次操作合在一起写了一次磁盘\",{\"1\":{\"345\":1}}],[\"两种状态\",{\"1\":{\"1435\":1}}],[\"两种方式\",{\"1\":{\"1308\":1}}],[\"两种依赖注入的方式均可以使用\",{\"1\":{\"970\":1}}],[\"两条记录做比较操作的成本\",{\"1\":{\"557\":1}}],[\"两边的主备同步的应用线程会报错duplicate\",{\"1\":{\"459\":1}}],[\"两阶段终止模式是一种应用很广泛的并发设计模式\",{\"1\":{\"1524\":1}}],[\"两阶段终止模式\",{\"0\":{\"1524\":1},\"1\":{\"1524\":1}}],[\"两阶段锁\",{\"0\":{\"443\":1}}],[\"两阶段提交的示意图如下\",{\"1\":{\"451\":1}}],[\"两阶段提交为了让两份日志之间的逻辑一致\",{\"1\":{\"327\":1}}],[\"两阶段提交\",{\"0\":{\"327\":1},\"1\":{\"326\":1,\"327\":1}}],[\"两个相同的lambda表达式\",{\"1\":{\"1620\":1}}],[\"两个相同对象\",{\"1\":{\"1348\":1}}],[\"两个相同对象没有重写equals方法放到hashmap覆盖吗\",{\"0\":{\"39\":1,\"1367\":1}}],[\"两个配合使用\",{\"1\":{\"1607\":1}}],[\"两个任务谁执行的快\",{\"1\":{\"1518\":2}}],[\"两个任务都执行完成后\",{\"1\":{\"1518\":1}}],[\"两个任务执行完成后\",{\"1\":{\"1518\":1}}],[\"两个态之间来回切换\",{\"1\":{\"1483\":1}}],[\"两个指令的执行是jvm通过调用操作系统的互斥源于meutex来实现\",{\"1\":{\"1483\":1}}],[\"两个线程都无法继续执行\",{\"1\":{\"1389\":1}}],[\"两个不同的key可以引用相同的对象\",{\"1\":{\"1355\":1}}],[\"两个时机\",{\"1\":{\"1234\":1}}],[\"两个对象\",{\"1\":{\"973\":1}}],[\"两个表都做一次全表扫描\",{\"1\":{\"403\":1}}],[\"两表连接的成本分析\",{\"0\":{\"555\":1}}],[\"两表连接查询的sql执行计划\",{\"1\":{\"362\":1}}],[\"两表索引分析\",{\"0\":{\"362\":1}}],[\"两棵树的示例示意图如下\",{\"1\":{\"335\":1}}],[\"状态就不再发生变化\",{\"1\":{\"1526\":1}}],[\"状态变更\",{\"1\":{\"1248\":1}}],[\"状态机\",{\"1\":{\"1248\":1}}],[\"状态标识\",{\"1\":{\"1175\":1}}],[\"状态标志\",{\"1\":{\"1162\":1}}],[\"状态模式\",{\"0\":{\"851\":1}}],[\"状态统计\",{\"1\":{\"578\":1}}],[\"状态的\",{\"1\":{\"464\":1}}],[\"状态图如下\",{\"1\":{\"450\":1}}],[\"状态\",{\"1\":{\"326\":1,\"476\":1,\"1346\":1}}],[\"把题目的解题思路和解法都写一下\",{\"1\":{\"1972\":1}}],[\"把autowiremode修改为bytype\",{\"1\":{\"1653\":1}}],[\"把beanclass修改为mapperfactorybean\",{\"1\":{\"1653\":1}}],[\"把bnl算法转成bka算法\",{\"1\":{\"406\":1}}],[\"把求出流中元素的总和改为求出流中元素的最小值\",{\"1\":{\"1610\":1}}],[\"把手的意思\",{\"1\":{\"1561\":1}}],[\"把每个bucket都移动到新的buckets中\",{\"1\":{\"1550\":1}}],[\"把每一行的id值都取出来\",{\"1\":{\"399\":1}}],[\"把数据房子啊对应下标元素的链表上\",{\"1\":{\"1546\":1}}],[\"把队列塞爆了\",{\"1\":{\"1536\":2}}],[\"把前面异步任务的结果\",{\"1\":{\"1518\":1}}],[\"把持读锁\",{\"1\":{\"1498\":1}}],[\"把工作内存中的一个变量的值传送到主内存中\",{\"1\":{\"1473\":1}}],[\"把工作内存中一个变量值传递给执行引擎\",{\"1\":{\"1473\":1}}],[\"把一个变量值从主内存传输到线程的工作内存中\",{\"1\":{\"1473\":1}}],[\"把一个变量标识为一条线程独占状态\",{\"1\":{\"1473\":1}}],[\"把一个处于锁定状态的变量释放出来\",{\"1\":{\"1473\":1}}],[\"把java的字节码数据加载到jvm内存当中\",{\"1\":{\"1433\":1}}],[\"把fd\",{\"1\":{\"1423\":1}}],[\"把读到的结果写入缓存\",{\"1\":{\"1286\":1}}],[\"把缓存的失效时间分散开\",{\"1\":{\"1284\":1}}],[\"把配置好的superuser\",{\"1\":{\"1000\":1,\"1001\":1,\"1002\":1}}],[\"把符合搜索条件的记录加入到结果集\",{\"1\":{\"548\":1}}],[\"把它比作条件用来判断当前事务能够看到哪个版本的数据\",{\"1\":{\"542\":1}}],[\"把它改成delete\",{\"1\":{\"484\":1}}],[\"把被驱动表的每一行取出来跟join\",{\"1\":{\"525\":1}}],[\"把被错删的数据插入回去就可以恢复了\",{\"1\":{\"454\":1}}],[\"把驱动表的数据读入到join\",{\"1\":{\"525\":1}}],[\"把需要的字段放到sort\",{\"1\":{\"520\":1}}],[\"把需要的字段都放到sort\",{\"1\":{\"356\":1}}],[\"把排序字段position和主键id这两个字段放到sort\",{\"1\":{\"520\":1}}],[\"把当前事务的trx变量的指针地址转成整数\",{\"1\":{\"497\":1}}],[\"把自增id的锁范围扩大\",{\"1\":{\"491\":1}}],[\"把之前删掉的binlog放回备库的操作如下\",{\"1\":{\"485\":1}}],[\"把之前的统计信息清空\",{\"1\":{\"479\":1}}],[\"把12号线程状态设置为kill\",{\"1\":{\"481\":1}}],[\"把sql\",{\"1\":{\"484\":1}}],[\"把session\",{\"1\":{\"481\":1}}],[\"把sort\",{\"1\":{\"421\":1}}],[\"把中转日志\",{\"1\":{\"467\":1}}],[\"把相同热度的表均匀分到这些不同的db中\",{\"1\":{\"463\":1}}],[\"把业务请求切换到备库b\",{\"1\":{\"458\":1}}],[\"把备库b改成可读写状态\",{\"1\":{\"458\":1}}],[\"把主库a改成只读状态\",{\"1\":{\"458\":1}}],[\"把redo\",{\"1\":{\"451\":1}}],[\"把内存中的临时表复制到磁盘\",{\"1\":{\"431\":1}}],[\"把内存临时表的大小限制为最大1024字节\",{\"1\":{\"416\":1}}],[\"把max\",{\"1\":{\"421\":1}}],[\"把这些undo日志串联起来形成一个历史记录版本链\",{\"1\":{\"542\":1}}],[\"把这些日志\",{\"1\":{\"485\":1}}],[\"把这两个命令的结果用于构建一个本地的哈希表\",{\"1\":{\"482\":1}}],[\"把这个事务的gtid返回给客户端\",{\"1\":{\"474\":1}}],[\"把这个gtid加到实例x的gtid集合中\",{\"1\":{\"468\":1}}],[\"把这个gtid加入本实例的gtid集合\",{\"1\":{\"468\":1}}],[\"把这个\",{\"1\":{\"421\":1}}],[\"把这个值加上1\",{\"1\":{\"326\":1}}],[\"把这2000行数据\",{\"1\":{\"408\":1}}],[\"把表t1的所有字段取出来\",{\"1\":{\"407\":1}}],[\"把t2中的每一行取出来\",{\"1\":{\"403\":2}}],[\"把trade\",{\"1\":{\"368\":1}}],[\"把返回的结果和r构成结果集的一行\",{\"1\":{\"401\":1}}],[\"把所有需要的列都放到索引中\",{\"1\":{\"390\":1}}],[\"把结果放在临时表中\",{\"1\":{\"330\":1}}],[\"把c从0改成1\",{\"1\":{\"327\":1}}],[\"把字符串\",{\"1\":{\"320\":1}}],[\"由浅入深的学习就会轻松一些\",{\"1\":{\"1993\":1}}],[\"由这个动作抛出的异常会被传递给调用者\",{\"1\":{\"1620\":1}}],[\"由这个动作执行产生的任何的异常都会传递给调用者\",{\"1\":{\"1620\":1}}],[\"由内核程序来进行操作\",{\"1\":{\"1579\":1}}],[\"由条件队列转移到同步队列\",{\"1\":{\"1491\":1}}],[\"由类的规格说明所规定的约束在对象被多个线程访问时仍然有效\",{\"1\":{\"1391\":1}}],[\"由数组\",{\"1\":{\"1359\":1}}],[\"由eric\",{\"1\":{\"1309\":1}}],[\"由协调节点将所有的返回结果进行汇总\",{\"1\":{\"1256\":1}}],[\"由子类覆盖该方法\",{\"1\":{\"1165\":1}}],[\"由子applicationcontext发起spring事件可能会传递到其parent\",{\"1\":{\"1116\":1}}],[\"由一个或多个propertyvalue组成\",{\"1\":{\"1071\":1}}],[\"由主节点进行写操作\",{\"1\":{\"607\":1}}],[\"由read\",{\"1\":{\"542\":1}}],[\"由proxy根据请求类型和上下文决定请求的分发路由\",{\"1\":{\"469\":1}}],[\"由客户端来选择后端数据库进行查询\",{\"1\":{\"469\":1}}],[\"由参数slave\",{\"1\":{\"465\":1}}],[\"由慢查询日志来查看哪些sql超出了我们的最大忍耐时间值\",{\"1\":{\"428\":1}}],[\"由定义\",{\"1\":{\"403\":1}}],[\"由此可知\",{\"1\":{\"372\":1}}],[\"由此可见\",{\"1\":{\"362\":1,\"371\":1}}],[\"由于算法会用到数据结构的相关知识\",{\"1\":{\"1970\":1}}],[\"由于i\",{\"1\":{\"1687\":1}}],[\"由于innodb对buffer\",{\"1\":{\"406\":1}}],[\"由于调整元空间的大小需要full\",{\"1\":{\"1664\":1}}],[\"由于自动拆箱和自动装箱的原因存在\",{\"1\":{\"1620\":1}}],[\"由于中间结果类型一定是<k\",{\"1\":{\"1618\":1}}],[\"由于所有的匿名内部类又可以使用lambda表达式来进行替换\",{\"1\":{\"1597\":1}}],[\"由于所有线程处于等待状态\",{\"1\":{\"476\":1}}],[\"由于test\",{\"1\":{\"1595\":1}}],[\"由于table\",{\"1\":{\"413\":1}}],[\"由于函数式接口中只会有一个抽象方法\",{\"1\":{\"1595\":1}}],[\"由于客户端比较简单我这里使用了嵌套类部类\",{\"1\":{\"1575\":1}}],[\"由于新增的1bit是0还是1可以认为是随机的\",{\"1\":{\"1550\":1}}],[\"由于融入了红黑树\",{\"1\":{\"1550\":1}}],[\"由于length\",{\"1\":{\"1548\":1}}],[\"由于limit后面的参数不能直接跟变量\",{\"1\":{\"422\":1}}],[\"由于无锁\",{\"1\":{\"1527\":1}}],[\"由于拥有两把锁\",{\"1\":{\"1509\":1}}],[\"由于虚拟机要求对象起始地址必须是8字节的整数倍\",{\"1\":{\"1484\":1}}],[\"由于代码的执行序列不同而导致结果无法预测\",{\"1\":{\"1482\":1}}],[\"由于cpu的速度远高于主内存\",{\"1\":{\"1474\":1}}],[\"由于采用传统的jvm对象分配方式\",{\"1\":{\"1457\":1}}],[\"由于采用了可用性优先策略\",{\"1\":{\"459\":1}}],[\"由于注解无法像接口或者类一样继承\",{\"1\":{\"1134\":1}}],[\"由于注解是不能集成的\",{\"1\":{\"1023\":1}}],[\"由于newlist空了\",{\"1\":{\"571\":1}}],[\"由于n叉树在读写上的性能优点\",{\"1\":{\"334\":1}}],[\"由于没有共享\",{\"1\":{\"1528\":1}}],[\"由于没有多余的表进行连接\",{\"1\":{\"555\":1}}],[\"由于没有其它索引\",{\"1\":{\"335\":1}}],[\"由于使用idx\",{\"1\":{\"549\":1}}],[\"由于该列上只有联合索引\",{\"1\":{\"547\":1}}],[\"由于磁盘随机读写的相比顺序读写的性能是非常差的\",{\"1\":{\"543\":1}}],[\"由于低水位值会持续增加\",{\"1\":{\"497\":1}}],[\"由于此时系统的max\",{\"1\":{\"497\":1}}],[\"由于只读事务不分配trx\",{\"1\":{\"497\":1}}],[\"由于global\",{\"1\":{\"496\":1}}],[\"由于已经存在c=1的记录\",{\"1\":{\"491\":1}}],[\"由于等行锁\",{\"1\":{\"476\":1}}],[\"由于要了解后端的部署细节\",{\"1\":{\"469\":1}}],[\"由于不需要找位点了\",{\"1\":{\"468\":1}}],[\"由于不同担心线程之间的重名冲突\",{\"1\":{\"411\":1}}],[\"由于找不到精确的同步位点\",{\"1\":{\"467\":1}}],[\"由于同步了binlog\",{\"1\":{\"467\":1}}],[\"由于备库的分发策略不依赖于binlog内容\",{\"1\":{\"465\":1}}],[\"由于事务t中涉及修改表t1\",{\"1\":{\"461\":1}}],[\"由于事务没有提交\",{\"1\":{\"451\":1}}],[\"由于主备延迟的存在\",{\"1\":{\"457\":1}}],[\"由于主库a\",{\"1\":{\"468\":1}}],[\"由于主库上必须等事务执行完成才会写入binlog\",{\"1\":{\"457\":1}}],[\"由于主库直接影响业务\",{\"1\":{\"457\":1}}],[\"由于主键索引是一颗b+树\",{\"1\":{\"404\":1}}],[\"由于\",{\"1\":{\"457\":1}}],[\"由于set集合本身是无序的\",{\"1\":{\"1618\":1}}],[\"由于segment对象是一把锁\",{\"1\":{\"1553\":1}}],[\"由于segment对象本身就是一把锁\",{\"1\":{\"1553\":1}}],[\"由于session是同时执行插入数据命令的\",{\"1\":{\"492\":1}}],[\"由于session\",{\"1\":{\"441\":1,\"447\":1}}],[\"由于statement格式下\",{\"1\":{\"454\":1}}],[\"由于需要打开所有的文件\",{\"1\":{\"425\":1}}],[\"由于mysql规定了主库和备库的server\",{\"1\":{\"478\":1}}],[\"由于myisam引擎只支持表锁\",{\"1\":{\"424\":1}}],[\"由于mvcc的支持\",{\"1\":{\"438\":1}}],[\"由于merge的时候是真正进行数据更新的时刻\",{\"1\":{\"344\":1}}],[\"由于分区表的规则\",{\"1\":{\"424\":1}}],[\"由于每次操作数据库\",{\"1\":{\"479\":1}}],[\"由于每一行的id\",{\"1\":{\"417\":1}}],[\"由于每个事务都不知道其他事务的存在\",{\"1\":{\"532\":1}}],[\"由于每个分库的计算量都不饱和\",{\"1\":{\"411\":1}}],[\"由于每个非主键索引的叶子节点上都是主键的值\",{\"1\":{\"335\":1}}],[\"由于查询成本=i\",{\"1\":{\"548\":1}}],[\"由于查询操作\",{\"1\":{\"542\":1}}],[\"由于查询条件里面没有用到分区字段f\",{\"1\":{\"411\":1}}],[\"由于查询结果所需要的数据只在主键索引上有\",{\"1\":{\"337\":1}}],[\"由于临时表只能被创建它的session访问\",{\"1\":{\"410\":1}}],[\"由于表t1中的id的值是从1开始的\",{\"1\":{\"416\":1}}],[\"由于表t1被分成了两次放入join\",{\"1\":{\"403\":1}}],[\"由于表t2的字段上没有索引\",{\"1\":{\"402\":1}}],[\"由于join\",{\"1\":{\"403\":1}}],[\"由于我们设置了线程池大小和阻塞队列大小\",{\"1\":{\"1573\":1}}],[\"由于我们通过范围区间获取到二级索引记录共39条\",{\"1\":{\"549\":1}}],[\"由于我们一般会把数据库a和b的主备关系设计为双m结构\",{\"1\":{\"478\":1}}],[\"由于我们的join语句在循环读磁盘和淘汰内存页\",{\"1\":{\"406\":1}}],[\"由于我们在read\",{\"1\":{\"404\":1}}],[\"由于我们这个语句中写的是select\",{\"1\":{\"403\":1}}],[\"由于我们构造的数据都是一一对应的\",{\"1\":{\"401\":1}}],[\"由于多版本并发控制\",{\"1\":{\"396\":1}}],[\"由于这种引用转换过程具备动态性\",{\"1\":{\"1664\":1}}],[\"由于这条语句实际只用上了4个id\",{\"1\":{\"492\":1}}],[\"由于这些事务随时可能访问数据库里面的任何数据\",{\"1\":{\"434\":1}}],[\"由于这里convert函数是加在输入参数上的\",{\"1\":{\"368\":1}}],[\"由于这个数值特别大\",{\"1\":{\"1503\":1}}],[\"由于这个原因\",{\"1\":{\"1474\":1}}],[\"由于这个索引并不是唯一二级索引\",{\"1\":{\"553\":1}}],[\"由于这个事务并没有提交\",{\"1\":{\"451\":1}}],[\"由于这个优化机制的存在\",{\"1\":{\"406\":1}}],[\"由于这个查询语句并没有涉及到临时表和排序\",{\"1\":{\"347\":1}}],[\"由于这个语句的binlog丢失\",{\"1\":{\"327\":1}}],[\"由于在t1时刻\",{\"1\":{\"447\":1}}],[\"由于在t\",{\"1\":{\"366\":1}}],[\"由于校验码可能存在冲突\",{\"1\":{\"352\":1}}],[\"由于身份证号码的最后6位没有地址码这样的重复逻辑\",{\"1\":{\"352\":1}}],[\"由于身份证号字段比较大\",{\"1\":{\"341\":1}}],[\"由于email\",{\"1\":{\"350\":1}}],[\"由于是采样统计\",{\"1\":{\"347\":1}}],[\"由于引擎是按页读写的\",{\"1\":{\"342\":1}}],[\"由于索引定义了唯一性\",{\"1\":{\"342\":1}}],[\"由于覆盖索引可以减少树的搜索次数\",{\"1\":{\"338\":1}}],[\"由于redo\",{\"1\":{\"327\":2}}],[\"由于最开始的mysql并没有innodb引擎\",{\"1\":{\"325\":1}}],[\"由倒排索引项组成\",{\"1\":{\"308\":1}}],[\"擦除记录前要把记录更新到数据文件\",{\"1\":{\"324\":1}}],[\"写或者同时读写\",{\"1\":{\"1574\":1}}],[\"写socket\",{\"1\":{\"1533\":1,\"1534\":1}}],[\"写时复制模式\",{\"1\":{\"1527\":1}}],[\"写线程在获取写锁之后能够再次获取写锁\",{\"1\":{\"1498\":1}}],[\"写写互斥\",{\"1\":{\"1498\":1}}],[\"写读\",{\"1\":{\"1498\":1}}],[\"写必须被所有处理器以相同的顺序看到\",{\"1\":{\"1474\":1}}],[\"写传播\",{\"1\":{\"1474\":1}}],[\"写数据的操作只能在主节点完成\",{\"1\":{\"1269\":1}}],[\"写数据的时候是写到磁盘上的\",{\"1\":{\"409\":1}}],[\"写数据时加排他锁\",{\"1\":{\"1261\":1}}],[\"写法简单且线程安全\",{\"1\":{\"1195\":1}}],[\"写命令的发送过程是异步完成的\",{\"1\":{\"618\":1}}],[\"写不完\",{\"1\":{\"603\":1}}],[\"写也是一样\",{\"1\":{\"603\":1}}],[\"写操作也不用阻塞读操作\",{\"1\":{\"541\":1}}],[\"写冲突的无锁并发控制\",{\"1\":{\"541\":1}}],[\"写锁是独占的\",{\"1\":{\"1498\":1}}],[\"写锁能够降级成为读锁\",{\"1\":{\"1498\":1}}],[\"写锁\",{\"1\":{\"533\":1,\"1263\":1,\"1399\":1}}],[\"写锁之间是互斥的\",{\"1\":{\"441\":1}}],[\"写redo\",{\"1\":{\"484\":1}}],[\"写回主库的命令是\",{\"1\":{\"484\":1}}],[\"写binlog其实是分成两步的\",{\"1\":{\"451\":1}}],[\"写到本地文件\",{\"1\":{\"453\":1}}],[\"写到磁盘\",{\"1\":{\"451\":1}}],[\"写到第3号文件末尾后就回到0号文件开头\",{\"1\":{\"324\":1}}],[\"写入文件\",{\"0\":{\"1884\":1}}],[\"写入数据到索引库\",{\"1\":{\"1256\":1}}],[\"写入数据的原理\",{\"1\":{\"1256\":1}}],[\"写入表的row\",{\"1\":{\"495\":1}}],[\"写入\",{\"1\":{\"468\":1,\"1473\":1}}],[\"写入binlog\",{\"1\":{\"457\":1,\"472\":1}}],[\"写入了update\",{\"1\":{\"447\":1}}],[\"写入了两条语句\",{\"1\":{\"447\":2}}],[\"写入到binlog中的目的是为了主备复制\",{\"1\":{\"413\":1}}],[\"写\",{\"1\":{\"433\":1}}],[\"写屏障你了解吗\",{\"0\":{\"114\":1,\"1445\":1}}],[\"将项目部署在服务器\",{\"1\":{\"1987\":1}}],[\"将响应字节流写会给浏览器\",{\"1\":{\"1687\":1}}],[\"将tomcat\",{\"1\":{\"1687\":2}}],[\"将template\",{\"1\":{\"583\":1}}],[\"将在处理程序执行的任何结果上调用\",{\"1\":{\"1657\":1}}],[\"将代理对象暴露在threadlocal中\",{\"1\":{\"1654\":1}}],[\"将代理对象的target属性赋值为ioc容器中的普通对象\",{\"1\":{\"1630\":1}}],[\"将扫描到的beanpostprocessors实例化并排序\",{\"1\":{\"1651\":1}}],[\"将value转化为descriptor所对应的类型\",{\"1\":{\"1648\":1}}],[\"将加载到的class对象设置给beanclass属性\",{\"1\":{\"1647\":1}}],[\"将父beandefinition的属性继承\",{\"1\":{\"1647\":1}}],[\"将beandefinition注册到beandefinitionmap中\",{\"1\":{\"1647\":1}}],[\"将binlog的格式修改为binlog\",{\"1\":{\"454\":1}}],[\"将user\",{\"1\":{\"1633\":1}}],[\"将从spliterator获取到元素推送到sink当中\",{\"1\":{\"1623\":1}}],[\"将pipelinehelper所描述的管道阶段应用到所提供的spliterator同时把结果发送给提供的sink\",{\"1\":{\"1623\":1}}],[\"将propertyeditorregistry实现注册为spring\",{\"1\":{\"1084\":1}}],[\"将中间操作串联起来\",{\"1\":{\"1623\":1}}],[\"将尝试着计算他们的值使用给定的映射方法\",{\"1\":{\"1618\":1}}],[\"将要被映射的值\",{\"1\":{\"1618\":1}}],[\"将要解决的问题划分为若干规模较小的同类问题\",{\"1\":{\"1510\":1}}],[\"将接收的u类型映射为t类型\",{\"1\":{\"1618\":1}}],[\"将需要的属性和方法定义好\",{\"1\":{\"1616\":1}}],[\"将累积的结果转换为一个最终的表示\",{\"1\":{\"1615\":1}}],[\"将集合中的元素映射成后面表达式的结果的操作\",{\"1\":{\"1609\":1}}],[\"将集合中的字符串传化为大写并打印\",{\"1\":{\"1609\":1}}],[\"将流中的元素依次添加到我们新new出来的arraylist当中\",{\"1\":{\"1608\":1}}],[\"将list这个集合转化为了stream\",{\"1\":{\"1593\":1}}],[\"将文件内容通过网络传输给客户端\",{\"1\":{\"1580\":1}}],[\"将原来的nio类库进行了升级\",{\"1\":{\"1572\":2}}],[\"将用户关系的文件描述符的时间存放到内核的一个事件表中\",{\"1\":{\"1571\":1}}],[\"将终止过程分成两个阶段\",{\"1\":{\"1524\":1}}],[\"将结果交给thenacceptboth消耗\",{\"1\":{\"1518\":1}}],[\"将结果保存到集合中\",{\"1\":{\"572\":1}}],[\"将询价结果异步保存到数据库\",{\"1\":{\"1517\":1}}],[\"将大的任务分割为更小力度的小任务\",{\"1\":{\"1514\":1}}],[\"将大查询切分成小查询\",{\"1\":{\"393\":1}}],[\"将由设定的处理器处理\",{\"1\":{\"1510\":1}}],[\"将子问题的解逐层合并构成原问题的解\",{\"1\":{\"1510\":1}}],[\"将同步器所有调用都映射到sync对应的方法\",{\"1\":{\"1490\":1}}],[\"将堆分配转化为栈分配\",{\"1\":{\"1488\":1}}],[\"将会产生一个结果或者是有副作用的\",{\"1\":{\"1619\":1}}],[\"将会扩大加锁同步的范围\",{\"1\":{\"1486\":1}}],[\"将会去调用这个脚本\",{\"1\":{\"624\":1}}],[\"将线程的中断标志和设置为true\",{\"1\":{\"1477\":1}}],[\"将产生的垃圾清除\",{\"1\":{\"1447\":1}}],[\"将每个内存对象分成三种颜色\",{\"1\":{\"1442\":1}}],[\"将符号引用替换为直接引用\",{\"1\":{\"1663\":1}}],[\"将符号引用转为直接引用\",{\"1\":{\"1433\":1}}],[\"将符合条件的数据放在一个队列当中\",{\"1\":{\"1256\":1}}],[\"将触发三次握手\",{\"1\":{\"1425\":1}}],[\"将fd\",{\"1\":{\"1423\":1}}],[\"将内核划分为两个部分\",{\"1\":{\"1423\":1}}],[\"将请求处理任务提交给线程池\",{\"1\":{\"1534\":1}}],[\"将请求交由某个空闲的线程处理\",{\"1\":{\"1422\":1}}],[\"将请求转发给对应的primary\",{\"1\":{\"1256\":1}}],[\"将对象放到hashmap的时候就会调用object的equals方法\",{\"1\":{\"1367\":1}}],[\"将队列配置成持久化队列\",{\"1\":{\"1328\":1}}],[\"将自己的过期时间更新上去\",{\"1\":{\"1288\":1}}],[\"将自增值的变更记录在了redo\",{\"1\":{\"490\":1}}],[\"将锁的内容设置为过期时间\",{\"1\":{\"1288\":1}}],[\"将热点数据缓存设置为永不过期\",{\"1\":{\"1287\":1}}],[\"将热点数据缓存在内存中的一级缓存中\",{\"1\":{\"1283\":1}}],[\"将缓存修改为一个特殊值\",{\"1\":{\"1286\":1}}],[\"将视图转为http响应流返回给客户端\",{\"1\":{\"1241\":1}}],[\"将单例池中对象的引用关系调整完成\",{\"1\":{\"1237\":1}}],[\"将令牌对应的相关信息全部冗余到令牌本身\",{\"1\":{\"1203\":1}}],[\"将引导类作为配置类\",{\"1\":{\"1113\":1}}],[\"将泛型类型中的所有类型参数替换为其边界\",{\"1\":{\"1098\":1}}],[\"将其beanname缓存起来\",{\"1\":{\"1648\":1}}],[\"将其epoch字段改为新值\",{\"1\":{\"1485\":1}}],[\"将其声明为spring\",{\"1\":{\"1084\":1}}],[\"将其整体读入内存\",{\"1\":{\"342\":1}}],[\"将目标类型的对象传入propertyeditor\",{\"1\":{\"1082\":1}}],[\"将objecterror或fielderror中的code和args\",{\"1\":{\"1063\":1}}],[\"将当前平台作为mbeanserver\",{\"1\":{\"1020\":1}}],[\"将当前活跃的其他的事务记录起来\",{\"1\":{\"542\":1}}],[\"将属性替换为配置文件中的值\",{\"1\":{\"978\":1}}],[\"将我们自定义的注解类型添加到autowiredannotationbeanpostprocessor中\",{\"1\":{\"967\":1}}],[\"将他们抽取出来作为最基础的组件\",{\"1\":{\"645\":1}}],[\"将传给脚本两个参数\",{\"1\":{\"624\":1}}],[\"将传入的行的值改成\",{\"1\":{\"491\":1}}],[\"将redis执行过的所有指令记录下来\",{\"1\":{\"591\":1}}],[\"将read\",{\"1\":{\"404\":1}}],[\"将多个\",{\"1\":{\"577\":1}}],[\"将具体经纬度的坐标存入一个有序集合\",{\"1\":{\"576\":1}}],[\"将成员m2的score\",{\"1\":{\"574\":1}}],[\"将哈希表\",{\"1\":{\"573\":1}}],[\"将下标3的元素\",{\"1\":{\"571\":1}}],[\"将列表的尾部\",{\"1\":{\"571\":1}}],[\"将给定\",{\"1\":{\"570\":1}}],[\"将指定key的value数值进行+1\",{\"1\":{\"570\":1}}],[\"将\",{\"1\":{\"569\":1,\"1030\":1,\"1554\":1}}],[\"将键值对移动到指定数据库\",{\"1\":{\"569\":2}}],[\"将默认使用系统变量innodb\",{\"1\":{\"558\":1}}],[\"将controller交由spring\",{\"1\":{\"1659\":1}}],[\"将cookie设置为httponly\",{\"1\":{\"1201\":1}}],[\"将cost\",{\"1\":{\"557\":1}}],[\"将customizedpropertyeditorregistrar声明为spring\",{\"1\":{\"1084\":1}}],[\"将change\",{\"1\":{\"343\":1}}],[\"将上述中猜的过程称之为condition\",{\"1\":{\"554\":1}}],[\"将上述两个动作记入redo\",{\"1\":{\"345\":1}}],[\"将使用index\",{\"1\":{\"553\":1}}],[\"将age修改为30岁\",{\"1\":{\"542\":1}}],[\"将scope设置成singleton\",{\"1\":{\"1240\":1}}],[\"将score相加作为结果的score\",{\"1\":{\"574\":1}}],[\"将string类型转换成properties类型\",{\"1\":{\"1082\":1,\"1084\":1}}],[\"将string类型转化为目标类型的对象\",{\"1\":{\"1082\":1}}],[\"将studentx哈希表作为一个对象\",{\"1\":{\"573\":1}}],[\"将spring\",{\"1\":{\"983\":3,\"1235\":3,\"1241\":1}}],[\"将set还原到\",{\"1\":{\"572\":1}}],[\"将source集合的成员member移动到destination集合\",{\"1\":{\"572\":1}}],[\"将sql改写如下\",{\"1\":{\"522\":1}}],[\"将sync\",{\"1\":{\"450\":2,\"451\":1}}],[\"将表的自增值改成3\",{\"1\":{\"491\":1}}],[\"将表t2中满足条件的数据放在临时表tmp\",{\"1\":{\"407\":1}}],[\"将表t1的数据读入线程内存join\",{\"1\":{\"403\":1}}],[\"将变量killed赋值为thd\",{\"1\":{\"481\":1}}],[\"将并发线程的计数减1的设计\",{\"1\":{\"476\":1}}],[\"将查询请求做分类\",{\"1\":{\"470\":1}}],[\"将查询分解后\",{\"1\":{\"394\":1}}],[\"将实例a\",{\"1\":{\"468\":1}}],[\"将20个主库放在4台机器上\",{\"1\":{\"457\":1}}],[\"将m类型强转为<k\",{\"1\":{\"1618\":1}}],[\"将map中的键值对替换\",{\"1\":{\"1618\":1}}],[\"将mathscore\",{\"1\":{\"574\":1}}],[\"将master\",{\"1\":{\"454\":1}}],[\"将myinstantiationawarebeanpostprocessor作为bean注册\",{\"1\":{\"1005\":1,\"1006\":1,\"1011\":1}}],[\"将myisam分区表标记为deprecated\",{\"1\":{\"425\":1}}],[\"将myset中m3成员移动到newset集合\",{\"1\":{\"572\":1}}],[\"将mylist的最后一个值\",{\"1\":{\"571\":1}}],[\"将int常量1压入操作数栈\",{\"1\":{\"1482\":2}}],[\"将innodb的并发线程上限设置为2\",{\"1\":{\"481\":1}}],[\"将innodb\",{\"1\":{\"451\":1}}],[\"将identity\",{\"1\":{\"1618\":1}}],[\"将id\",{\"1\":{\"418\":1}}],[\"将id值放入read\",{\"1\":{\"404\":1}}],[\"将启动参数transaction\",{\"1\":{\"433\":1}}],[\"将1改成2\",{\"1\":{\"433\":1}}],[\"将分库执行的结果插入到temp\",{\"1\":{\"411\":1}}],[\"将各个分库拿到的数据\",{\"1\":{\"411\":1}}],[\"将计数保存在缓存系统中的方式\",{\"1\":{\"397\":1}}],[\"将一个大表ht\",{\"1\":{\"411\":1}}],[\"将一个大的delete语句切分成多个较小的查询可以尽可能小地影响mysql性能\",{\"1\":{\"393\":1}}],[\"将一个大查询分解为多个小查询是很有必要的\",{\"1\":{\"392\":1}}],[\"将数字转成字符串\",{\"1\":{\"376\":1}}],[\"将数据从kernel拷贝到用户进程\",{\"1\":{\"1565\":1}}],[\"将数据从内核拷贝至进程中\",{\"1\":{\"1561\":1}}],[\"将数据从磁盘读入内存涉及随机io的访问\",{\"1\":{\"343\":1}}],[\"将数据转移到新的entry数组里\",{\"1\":{\"1550\":1}}],[\"将数据库连接conn放入threadlocal\",{\"1\":{\"1655\":1}}],[\"将数据库中没有查到的结果的数据也写入到缓存\",{\"1\":{\"1282\":1}}],[\"将数据库快照保存在名字为\",{\"1\":{\"586\":1}}],[\"将数据页读入内存\",{\"1\":{\"343\":1}}],[\"将数据存储在了b+树中\",{\"1\":{\"335\":1}}],[\"将这条语句的执行时间设置为100秒\",{\"1\":{\"424\":1}}],[\"将这个例子做如下修改\",{\"1\":{\"1612\":1}}],[\"将这个对象的动态代理信息获取出来\",{\"1\":{\"1237\":1}}],[\"将这个临时实例设置成线上备库的从库\",{\"1\":{\"485\":1}}],[\"将这个时间的值设置的很小也不行\",{\"1\":{\"444\":1}}],[\"将这个命令重写后再传到备库执行\",{\"1\":{\"413\":1}}],[\"将这个操作记录到磁盘里面\",{\"1\":{\"324\":1}}],[\"将这行记录加入结果集\",{\"1\":{\"350\":2}}],[\"将语句修改为order\",{\"1\":{\"348\":1}}],[\"将更新先记录在change\",{\"1\":{\"344\":1}}],[\"将备份的binlog依次取出来\",{\"1\":{\"327\":1}}],[\"将索引中单词对应的文本位置\",{\"1\":{\"299\":1}}],[\"同步阻塞i\",{\"1\":{\"1576\":1}}],[\"同步阻塞io\",{\"1\":{\"1421\":1}}],[\"同步io\",{\"1\":{\"1567\":1}}],[\"同步io和异步io的区别\",{\"1\":{\"1567\":1}}],[\"同步等待队列\",{\"0\":{\"1491\":1},\"1\":{\"1490\":1}}],[\"同步省略或锁消除\",{\"1\":{\"1488\":1}}],[\"同步代码块是通过monitorenter和monitorexit来实现\",{\"1\":{\"1483\":1}}],[\"同步方法是通过方法中的access\",{\"1\":{\"1483\":1}}],[\"同步是由于线程执行的先后\",{\"1\":{\"1482\":1}}],[\"同步问题\",{\"1\":{\"1470\":1}}],[\"同步非阻塞io\",{\"1\":{\"1421\":1}}],[\"同步刷盘消息安全性更高\",{\"1\":{\"1328\":1}}],[\"同步刷盘\",{\"1\":{\"1328\":1}}],[\"同步同步就不会丢消息\",{\"1\":{\"1328\":1}}],[\"同步同步\",{\"1\":{\"1328\":1}}],[\"同步和异步spring事件广播\",{\"0\":{\"1123\":1}}],[\"同步\",{\"1\":{\"564\":1,\"589\":1,\"624\":1,\"1123\":3,\"1125\":1,\"1421\":2,\"1567\":1}}],[\"同步延迟\",{\"1\":{\"457\":1}}],[\"同一性指的是\",{\"1\":{\"1615\":1}}],[\"同一性\",{\"1\":{\"1615\":1}}],[\"同一位置上的新元素总会被放在链表的头部位置\",{\"1\":{\"1550\":1}}],[\"同一时刻只能有一个线程执行临界区代码\",{\"1\":{\"1482\":1}}],[\"同一个web服务器里\",{\"1\":{\"1693\":2}}],[\"同一个数据连接\",{\"1\":{\"1655\":1}}],[\"同一个namespace下的id不能重复\",{\"1\":{\"1209\":1}}],[\"同一个sentinel对同一个master两次failover之间的间隔时间\",{\"1\":{\"624\":1}}],[\"同一个只读事务查出来的trx\",{\"1\":{\"497\":1}}],[\"同一个binlog文件里\",{\"1\":{\"496\":1}}],[\"同一个语句去申请自增id\",{\"1\":{\"492\":1}}],[\"同一个事务不能被拆开\",{\"1\":{\"460\":1}}],[\"同一个事务的多个更新语句\",{\"1\":{\"460\":1}}],[\"同一行上的两个事务\",{\"1\":{\"460\":1}}],[\"同一行语句是在同一时刻执行的\",{\"1\":{\"396\":1}}],[\"同一条记录在系统中可以存在多个版本\",{\"1\":{\"434\":1}}],[\"同样\",{\"1\":{\"1992\":1}}],[\"同样还是会有脏数据的问题\",{\"1\":{\"1286\":1}}],[\"同样的方式\",{\"1\":{\"1599\":1}}],[\"同样的我们可以举一个例子\",{\"1\":{\"1598\":1}}],[\"同样的也是一个名叫foreach的方法\",{\"1\":{\"1593\":1}}],[\"同样的key会被覆盖掉\",{\"1\":{\"1475\":1}}],[\"同样的\",{\"1\":{\"1009\":1,\"1138\":1,\"1594\":1,\"1598\":1,\"1600\":1,\"1613\":1,\"1614\":1,\"1618\":1,\"1619\":1}}],[\"同样的更新语句也会按照sql语句的基本执行链路执行\",{\"1\":{\"323\":1}}],[\"同样commonannotationbeanpostprocessor也有postprocessproperties的方法\",{\"1\":{\"966\":1}}],[\"同样取出这三个字段的值\",{\"1\":{\"356\":1}}],[\"同样地\",{\"1\":{\"352\":1}}],[\"同理\",{\"1\":{\"333\":1,\"484\":1}}],[\"同时使用前缀树实现敏感词过滤\",{\"1\":{\"1987\":1}}],[\"同时使用持久化存储作为二级缓存\",{\"1\":{\"1283\":1}}],[\"同时监听8005端口发过来的shutdown命令\",{\"1\":{\"1685\":1}}],[\"同时收集器会对该值进行调整\",{\"1\":{\"1664\":1}}],[\"同时因为classpathmapperscanner中重写了iscandidatecomponent方法\",{\"1\":{\"1653\":1}}],[\"同时你也可以通知sink需要处理的数据量是多少\",{\"1\":{\"1623\":1}}],[\"同时true\",{\"1\":{\"1620\":1}}],[\"同时其中的抽象方法apply\",{\"1\":{\"1601\":1}}],[\"同时内核缓冲区和用户缓冲区也无需建立内存映射\",{\"1\":{\"1582\":1}}],[\"同时上下文从内核态转为用户态\",{\"1\":{\"1580\":1}}],[\"同时处于用户态的进程不能访问内核空间中的数据\",{\"1\":{\"1579\":1}}],[\"同时处于prepare阶段的事务\",{\"1\":{\"465\":1}}],[\"同时处于prepare状态的事务\",{\"1\":{\"465\":1}}],[\"同时我们对线程创建也缺乏管理\",{\"1\":{\"1573\":1}}],[\"同时连接的大量客户端在同一时刻可能只有很少的处于就绪状态\",{\"1\":{\"1570\":1}}],[\"同时pollfd并没有最大数量限制\",{\"1\":{\"1570\":1}}],[\"同时不会有太大的开销\",{\"1\":{\"1548\":1}}],[\"同时为了减少冲突\",{\"1\":{\"1546\":1}}],[\"同时也会创建standardenvironment对象\",{\"1\":{\"1651\":1}}],[\"同时也说明了characteristics就定义了中间结果容器和最终结果的结果容器类型的关系\",{\"1\":{\"1617\":1}}],[\"同时也是为了向后兼容的一种妥协\",{\"1\":{\"1607\":1}}],[\"同时也需要cpu响应中断\",{\"1\":{\"1580\":1}}],[\"同时也可以获取读锁\",{\"1\":{\"1498\":1}}],[\"同时也提供了配置中心\",{\"1\":{\"1311\":1}}],[\"同时也提供一些弹性\",{\"1\":{\"902\":1}}],[\"同时向condition队列尾部添加一个节点\",{\"1\":{\"1493\":1}}],[\"同时遍历jvm中所有线程的栈\",{\"1\":{\"1485\":1}}],[\"同时这也是jvm调优的重点\",{\"1\":{\"1440\":1}}],[\"同时总是会有一个高优先级的线程可以执行\",{\"1\":{\"1390\":1}}],[\"同时会阻塞当前线程\",{\"1\":{\"1491\":1}}],[\"同时会生成session\",{\"1\":{\"1200\":1}}],[\"同时会将这个变化实时通知给redis应用方\",{\"1\":{\"621\":1}}],[\"同时覆盖了\",{\"1\":{\"1137\":1}}],[\"同时有大量的请求\",{\"1\":{\"629\":1}}],[\"同时需要修改应用方的主节点地址\",{\"1\":{\"621\":1}}],[\"同时将多个\",{\"1\":{\"573\":1}}],[\"同时将这个更新操作记录到redo\",{\"1\":{\"326\":1}}],[\"同时通过redis\",{\"1\":{\"568\":1}}],[\"同时在其基础上增加了阻塞功能\",{\"1\":{\"1501\":1}}],[\"同时在该条记录的头信息\",{\"1\":{\"542\":1}}],[\"同时在这个字段上创建索引\",{\"1\":{\"352\":1}}],[\"同时还提供了timeout参数\",{\"1\":{\"603\":1}}],[\"同时还能保证各种异常情况下的数据一致性\",{\"1\":{\"543\":1}}],[\"同时还可以解决脏读\",{\"1\":{\"541\":1}}],[\"同时还可以减少mysql复制的延迟\",{\"1\":{\"393\":1}}],[\"同时还会在索引里过滤age和position这两个字段\",{\"1\":{\"518\":1}}],[\"同时设置binlog\",{\"1\":{\"492\":1}}],[\"同时执行向表t2中插入数据的操作\",{\"1\":{\"492\":1}}],[\"同时执在执行的语句超过了设置的innnodb\",{\"1\":{\"476\":1}}],[\"同时修改哈希表\",{\"1\":{\"461\":1}}],[\"同时又避免了数据不一致的风险\",{\"1\":{\"454\":1}}],[\"同时写binlog也要耗费io资源\",{\"1\":{\"454\":1}}],[\"同时写binlog\",{\"1\":{\"453\":1}}],[\"同时存在\",{\"1\":{\"330\":1}}],[\"同时\",{\"1\":{\"324\":1,\"345\":1,\"393\":1,\"404\":1,\"532\":1,\"1501\":1,\"1519\":1,\"1550\":1}}],[\"具有更高的效率\",{\"1\":{\"1548\":1}}],[\"具有以下优点\",{\"1\":{\"1304\":1}}],[\"具有高性能\",{\"1\":{\"301\":1}}],[\"具备\",{\"1\":{\"1100\":1}}],[\"具体协议的实现类扩展了协议层抽象基类\",{\"1\":{\"1687\":1}}],[\"具体考虑下面这个pipeline\",{\"1\":{\"1623\":1}}],[\"具体底层怎么做完全不用关心\",{\"1\":{\"1611\":1}}],[\"具体叫什么名字\",{\"1\":{\"1595\":1}}],[\"具体采用哪种方式\",{\"1\":{\"1585\":1}}],[\"具体区别如下\",{\"1\":{\"1421\":1}}],[\"具体有以下几种\",{\"1\":{\"1410\":1}}],[\"具体见下图\",{\"1\":{\"1328\":1}}],[\"具体含义\",{\"1\":{\"1262\":1}}],[\"具体使用场景如下\",{\"1\":{\"1326\":1}}],[\"具体使用如下\",{\"1\":{\"1226\":2}}],[\"具体使用哪一种\",{\"1\":{\"433\":1}}],[\"具体以下三种实现均可\",{\"1\":{\"1138\":1}}],[\"具体实现类特点的说明\",{\"1\":{\"1544\":1}}],[\"具体实现\",{\"1\":{\"1111\":1}}],[\"具体化\",{\"1\":{\"1100\":1}}],[\"具体操作如下\",{\"1\":{\"1064\":1}}],[\"具体原因\",{\"1\":{\"946\":1}}],[\"具体可以参考红黑树\",{\"1\":{\"1546\":1}}],[\"具体可以参考\",{\"1\":{\"601\":1,\"1546\":1}}],[\"具体查询多少次取决于对被驱动表查询的结果集中有多少条记录\",{\"1\":{\"554\":1}}],[\"具体如下图\",{\"1\":{\"542\":1,\"1328\":1,\"1663\":1}}],[\"具体如下图所示\",{\"1\":{\"461\":1}}],[\"具体情况是\",{\"1\":{\"490\":1}}],[\"具体恢复数据时\",{\"1\":{\"484\":1}}],[\"具体过程如下图\",{\"1\":{\"476\":1}}],[\"具体的实现如下\",{\"1\":{\"1623\":1}}],[\"具体的实现方式\",{\"1\":{\"1394\":1}}],[\"具体的行为在调用的时候再传入\",{\"1\":{\"1599\":1}}],[\"具体的采样页面数量\",{\"1\":{\"558\":2}}],[\"具体的操作流程如下\",{\"1\":{\"497\":1}}],[\"具体的方案就是\",{\"1\":{\"471\":1}}],[\"具体的执行结果如下\",{\"1\":{\"446\":1}}],[\"具体指运行时间超过long\",{\"1\":{\"428\":1}}],[\"具体流程下\",{\"1\":{\"413\":1}}],[\"具体来说spring中bean经过了以下几个步骤\",{\"1\":{\"1234\":1}}],[\"具体来说\",{\"1\":{\"324\":1}}],[\"归档日志\",{\"0\":{\"325\":1},\"1\":{\"323\":1,\"325\":1}}],[\"至多删除2个\",{\"1\":{\"571\":1}}],[\"至多删除3个\",{\"1\":{\"571\":1}}],[\"至多删除count个\",{\"1\":{\"571\":1}}],[\"至少要把这条记录中的内容都记下来\",{\"1\":{\"542\":1}}],[\"至少要把这条记录的主键值记下来\",{\"1\":{\"542\":1}}],[\"至少要把修改这条记录之前的旧值都记录下来\",{\"1\":{\"542\":1}}],[\"至少跑1天\",{\"1\":{\"430\":1}}],[\"至于spring\",{\"1\":{\"1990\":1}}],[\"至于底层如何充分利用计算机资源帮助我们快速迭代\",{\"1\":{\"1612\":1}}],[\"至于具体选择哪一种\",{\"1\":{\"473\":1}}],[\"至于分区表的其它问题\",{\"1\":{\"426\":1}}],[\"至此为止\",{\"1\":{\"1621\":1}}],[\"至此\",{\"1\":{\"322\":1,\"1613\":1}}],[\"至今\",{\"1\":{\"4\":1}}],[\"直至队列空出位置\",{\"1\":{\"1501\":1}}],[\"直译为\",{\"1\":{\"1483\":1}}],[\"直接去学习\",{\"1\":{\"1983\":1}}],[\"直接去运行\",{\"1\":{\"1009\":1}}],[\"直接自己从开始学算法\",{\"1\":{\"1972\":1}}],[\"直接做\",{\"1\":{\"1969\":1}}],[\"直接内存\",{\"0\":{\"1708\":1}}],[\"直接引用\",{\"1\":{\"1663\":1}}],[\"直接新建一个rootbeandefinition\",{\"1\":{\"1647\":1}}],[\"直接新建节点添加\",{\"1\":{\"1549\":1}}],[\"直接抛出异常\",{\"1\":{\"1620\":1}}],[\"直接进行实例化\",{\"1\":{\"1650\":1}}],[\"直接进行强制类型转换\",{\"1\":{\"1617\":1}}],[\"直接进入等待\",{\"1\":{\"444\":1}}],[\"直接获取响应的segment\",{\"1\":{\"1553\":1}}],[\"直接获取相应的\",{\"1\":{\"1553\":1}}],[\"直接覆盖value\",{\"1\":{\"1549\":1}}],[\"直接value\",{\"1\":{\"1549\":1}}],[\"直接决定了哈希方法的离散性能\",{\"1\":{\"1548\":1}}],[\"直接结束返回\",{\"1\":{\"1531\":1}}],[\"直接返回结果\",{\"1\":{\"1618\":1}}],[\"直接返回\",{\"1\":{\"1531\":1,\"1554\":1}}],[\"直接返回错误\",{\"1\":{\"468\":1}}],[\"直接在该位置写入或者读取数据\",{\"1\":{\"1519\":1}}],[\"直接在内存中参与计算\",{\"1\":{\"411\":1}}],[\"直接传递\",{\"1\":{\"1509\":2}}],[\"直接加到last后面\",{\"1\":{\"1503\":1}}],[\"直接走轻量级锁的逻辑\",{\"1\":{\"1485\":1}}],[\"直接累加到该变量上\",{\"1\":{\"1480\":1}}],[\"直接发消息\",{\"1\":{\"1419\":1}}],[\"直接查找\",{\"1\":{\"1149\":1}}],[\"直接依赖查找\",{\"1\":{\"1149\":1}}],[\"直接输出会显示乱码\",{\"1\":{\"978\":1}}],[\"直接用int\",{\"1\":{\"528\":1}}],[\"直接跳过1032和1062这两类错误是无损的\",{\"1\":{\"467\":1}}],[\"直接设置跳过指定的错误\",{\"1\":{\"467\":1}}],[\"直接把连接切到备库b\",{\"1\":{\"459\":1}}],[\"直接把insert语句转成delete语句\",{\"1\":{\"454\":1}}],[\"直接访问内存得到数据\",{\"1\":{\"420\":1}}],[\"直接排序优化group\",{\"0\":{\"418\":1}}],[\"直接从\",{\"1\":{\"1483\":1}}],[\"直接从缓存中获取数据\",{\"1\":{\"1283\":1}}],[\"直接从临时表中取数据返回\",{\"1\":{\"416\":1}}],[\"直接从索引中过滤不需要的记录并返回命中的结果\",{\"1\":{\"390\":1}}],[\"直接从内存返回\",{\"1\":{\"345\":1}}],[\"直接使用base累加数值\",{\"1\":{\"1480\":1}}],[\"直接使用kill命令也是有效的\",{\"1\":{\"480\":1}}],[\"直接使用磁盘临时表\",{\"1\":{\"418\":1}}],[\"直接使用\",{\"1\":{\"371\":1}}],[\"直接更新内存\",{\"1\":{\"345\":1}}],[\"直接判断并跳过\",{\"1\":{\"340\":1}}],[\"直接过滤掉不满足条件的记录\",{\"1\":{\"340\":1}}],[\"直接将这个索引设置为主键\",{\"1\":{\"335\":1}}],[\"直接将参数带过去\",{\"1\":{\"306\":1}}],[\"直到一个终止操作开始的时候\",{\"1\":{\"1621\":1}}],[\"直到有描述符就绪\",{\"1\":{\"1569\":1}}],[\"直到有线程退出\",{\"1\":{\"476\":1}}],[\"直到成功\",{\"1\":{\"1554\":1}}],[\"直到队列里有数据\",{\"1\":{\"1501\":1}}],[\"直到线程使用的数据并释放读锁之后\",{\"1\":{\"1498\":1}}],[\"直到占用资源者释放该资源\",{\"1\":{\"1477\":1}}],[\"直到消息到达时才被唤醒\",{\"1\":{\"1477\":1}}],[\"直到事务提交提交才释放\",{\"1\":{\"1261\":1}}],[\"直到事务a执行commit之后\",{\"1\":{\"443\":1}}],[\"直到事务a提交之后\",{\"1\":{\"433\":1}}],[\"直到root\",{\"1\":{\"1116\":1}}],[\"直到rdb过程完成为止\",{\"1\":{\"587\":1}}],[\"直到slave被纠正为向正确的master那里同步数据时\",{\"1\":{\"624\":1}}],[\"直到session\",{\"1\":{\"481\":1,\"497\":1}}],[\"直到缓存区中有空闲空间挪出来了\",{\"1\":{\"602\":1}}],[\"直到新的数据刀来或者连接关闭了\",{\"1\":{\"602\":1}}],[\"直到提交时才会开始执行\",{\"1\":{\"579\":1}}],[\"直到找到唯一的bean\",{\"1\":{\"1630\":1}}],[\"直到找到满足特定条件的db\",{\"1\":{\"542\":1}}],[\"直到找到第一个大于x的值\",{\"1\":{\"491\":1}}],[\"直到锁定行的session提交\",{\"1\":{\"537\":1}}],[\"直到这个库执行的事务中包含传入的gtid\",{\"1\":{\"474\":1}}],[\"直到这个值变成0为止\",{\"1\":{\"458\":1}}],[\"直到不再出现停下来的情况\",{\"1\":{\"467\":1}}],[\"直到不满足条件为止\",{\"1\":{\"339\":1}}],[\"直到和这个事务存在冲突关系的worker只剩下一个\",{\"1\":{\"461\":1}}],[\"直到步骤5完成后才能恢复\",{\"1\":{\"458\":1}}],[\"直到超时\",{\"1\":{\"444\":1}}],[\"直到第10000个\",{\"1\":{\"421\":1}}],[\"直到表t1的末尾循环结束\",{\"1\":{\"401\":1}}],[\"直到查到第1000条记录\",{\"1\":{\"356\":1}}],[\"直到查到1000条记录\",{\"1\":{\"356\":1}}],[\"直到在index2上取到的值不是\",{\"1\":{\"350\":1}}],[\"直到需要读page2的时候\",{\"1\":{\"345\":1}}],[\"直到碰到第一个不满足k=5条件的记录\",{\"1\":{\"342\":1}}],[\"直到取到这个表的最后一行\",{\"1\":{\"322\":1}}],[\"下游收集器本身返回的是<a\",{\"1\":{\"1618\":1}}],[\"下标采取递增的形式\",{\"1\":{\"1519\":1}}],[\"下次获得锁时\",{\"1\":{\"1485\":1}}],[\"下次查询再重新建立一个\",{\"1\":{\"318\":1}}],[\"下才会出现\",{\"1\":{\"446\":1}}],[\"下增加修改参数\",{\"1\":{\"428\":1}}],[\"下图为16扩充至32的过程的示意图\",{\"1\":{\"1550\":1}}],[\"下图展示了频道\",{\"1\":{\"596\":1}}],[\"下图表示了执行完这个空事务之后的show\",{\"1\":{\"468\":1}}],[\"下图表示的是基本主备切换流程\",{\"1\":{\"453\":1}}],[\"下图表示的是\",{\"1\":{\"451\":1}}],[\"下图中\",{\"1\":{\"464\":1}}],[\"下图是binlog\",{\"1\":{\"459\":1}}],[\"下图是创建的一个包含了很多分区的表t\",{\"1\":{\"425\":1}}],[\"下图所示是带change\",{\"1\":{\"345\":1}}],[\"下面通过一个例子来说明\",{\"1\":{\"1592\":1}}],[\"下面通过具体的例子来说明扩容过程\",{\"1\":{\"1550\":1}}],[\"下面举例说明\",{\"1\":{\"1548\":1}}],[\"下面的sql问题经常出现在面试当中\",{\"1\":{\"1974\":1}}],[\"下面的例子使用了java\",{\"1\":{\"1620\":1}}],[\"下面的例子就是使用jdk预先定义好的方法来执行可变的汇聚任务\",{\"1\":{\"1616\":1}}],[\"下面的示例演示了如何让使用stream和intstream进行聚合操作\",{\"1\":{\"1619\":1}}],[\"下面的方式是groupingby真正执行的方法\",{\"1\":{\"1618\":1}}],[\"下面的计算是等价的\",{\"1\":{\"1615\":1}}],[\"下面的代码中\",{\"1\":{\"1526\":2}}],[\"下面的序列中实例s是m的备库\",{\"1\":{\"413\":1}}],[\"下面开始是多集合操作\",{\"1\":{\"572\":1}}],[\"下面学习的命令\",{\"1\":{\"569\":1}}],[\"下面比较各种可执行方案以及它们对应的成本\",{\"1\":{\"551\":1}}],[\"下面两张图分别是这个例子的操作序列和执行结果图\",{\"1\":{\"425\":1}}],[\"下面我们使用supplier来创建一个对象\",{\"1\":{\"1600\":1}}],[\"下面我们用具体的例子来说明\",{\"1\":{\"1600\":1}}],[\"下面我们以内连接为例来看看如何计算出最优的连接查询方案\",{\"1\":{\"555\":1}}],[\"下面我们来看一个稍微复杂一点的例子\",{\"1\":{\"1616\":1}}],[\"下面我们来举例来说明这一点\",{\"1\":{\"459\":1}}],[\"下面我们来分析整个语句的执行过程\",{\"1\":{\"354\":1}}],[\"下面我们通过具体的例子来说明\",{\"1\":{\"1598\":1}}],[\"下面我们通过代码对bio模型进行具体分析\",{\"1\":{\"1573\":1}}],[\"下面我们通过实例来说明\",{\"1\":{\"433\":1}}],[\"下面我们通过例子来说明\",{\"1\":{\"425\":1}}],[\"下面这个查询\",{\"1\":{\"394\":1}}],[\"下面是隐性别名的例子\",{\"1\":{\"1136\":1}}],[\"下面是按照时间顺序执行两个事务的行为\",{\"1\":{\"433\":1}}],[\"下面是这个语句explain的结果\",{\"1\":{\"414\":1}}],[\"下面是这两个过程的执行流程图\",{\"1\":{\"340\":1}}],[\"下面是t\",{\"1\":{\"366\":1}}],[\"下面进行大胆的尝试\",{\"1\":{\"362\":1}}],[\"下一个待添加元素索引\",{\"1\":{\"1502\":1}}],[\"下一个待取出元素索引\",{\"1\":{\"1502\":1}}],[\"下一个值就是0\",{\"1\":{\"495\":1}}],[\"下一个事务才能再申请自增id\",{\"1\":{\"491\":1}}],[\"下一组才能开始执行\",{\"1\":{\"464\":1}}],[\"下一组事务很快就会进入commit状态\",{\"1\":{\"464\":1}}],[\"下一组事务是同时处于\",{\"1\":{\"464\":1}}],[\"下一组就是commit\",{\"1\":{\"464\":1}}],[\"下一条记录\",{\"1\":{\"356\":1}}],[\"下一张图中\",{\"1\":{\"340\":1}}],[\"下一行\",{\"1\":{\"322\":1}}],[\"开箱即用\",{\"1\":{\"1986\":1}}],[\"开头\",{\"1\":{\"1453\":2}}],[\"开头的索引之后\",{\"1\":{\"518\":1}}],[\"开头的索引\",{\"1\":{\"518\":1}}],[\"开发者必看的书\",{\"1\":{\"1992\":1}}],[\"开发的工作\",{\"1\":{\"1983\":1}}],[\"开发框架\",{\"1\":{\"1982\":1}}],[\"开发和调试非常友好\",{\"1\":{\"1292\":1}}],[\"开发人员需要熟悉xml\",{\"1\":{\"1036\":1}}],[\"开发人员可用id或者name属性来规定bean的标识符\",{\"1\":{\"928\":1}}],[\"开发人员通过这些本地api来操作数据库\",{\"1\":{\"645\":1}}],[\"开源的\",{\"1\":{\"1986\":1}}],[\"开源版功能不如云上商业版\",{\"1\":{\"1327\":1}}],[\"开源\",{\"1\":{\"908\":1}}],[\"开源项目\",{\"0\":{\"1\":1}}],[\"开销大\",{\"1\":{\"535\":1}}],[\"开销小\",{\"1\":{\"534\":1}}],[\"开始\",{\"1\":{\"1479\":1}}],[\"开始计数\",{\"1\":{\"569\":1}}],[\"开始按照备库b传过来的位置\",{\"1\":{\"453\":1}}],[\"开始执行的时候\",{\"1\":{\"322\":1}}],[\"开始执行语句\",{\"1\":{\"322\":1}}],[\"开启一个事务\",{\"1\":{\"1655\":1}}],[\"开启spring事务本质上就是增加了一个advisor\",{\"1\":{\"1655\":1}}],[\"开启show\",{\"1\":{\"431\":2}}],[\"开启了事务\",{\"1\":{\"1653\":1}}],[\"开启了慢查询日志后\",{\"1\":{\"428\":1}}],[\"开启并行流的方式除了之前我们使用过的parallelstream\",{\"1\":{\"1617\":1}}],[\"开启锁消除\",{\"1\":{\"1487\":1}}],[\"开启线程的具体方式\",{\"1\":{\"1377\":1}}],[\"开启事务\",{\"1\":{\"579\":2,\"582\":1,\"1277\":1,\"1328\":1}}],[\"开启trace\",{\"1\":{\"519\":1,\"520\":1}}],[\"开启慢查询日志\",{\"1\":{\"428\":2,\"430\":1}}],[\"决定各个表的连接顺序\",{\"1\":{\"321\":1,\"514\":1}}],[\"决定使用哪个索引\",{\"1\":{\"321\":1,\"514\":2}}],[\"列\",{\"1\":{\"1254\":1}}],[\"列举实现\",{\"1\":{\"1052\":1}}],[\"列举一些spring当中用到的设计模式\",{\"0\":{\"264\":1,\"1188\":1}}],[\"列举一些jdk中用到的设计模式\",{\"0\":{\"263\":1,\"1187\":1}}],[\"列表\",{\"0\":{\"571\":1},\"1\":{\"568\":1,\"1280\":1}}],[\"列id\",{\"1\":{\"320\":1}}],[\"识别成\",{\"1\":{\"320\":1}}],[\"识别成表名\",{\"1\":{\"320\":1}}],[\"识别出sql语句中的字符串分别是什么\",{\"1\":{\"320\":1}}],[\"代理对象在执行某个方法时\",{\"1\":{\"1655\":1}}],[\"代理对象\",{\"1\":{\"1181\":1}}],[\"代理模式\",{\"0\":{\"749\":1,\"844\":1}}],[\"代码的可读性较差\",{\"1\":{\"1654\":1}}],[\"代码还相当冗余的\",{\"1\":{\"1611\":1}}],[\"代码变的异常简洁和优雅\",{\"1\":{\"1607\":1}}],[\"代码如下\",{\"1\":{\"1573\":1}}],[\"代码复用\",{\"1\":{\"1304\":1}}],[\"代码入侵性\",{\"1\":{\"911\":1}}],[\"代码语法错误\",{\"1\":{\"580\":1}}],[\"代码线上\",{\"1\":{\"521\":1}}],[\"代码上线前\",{\"1\":{\"484\":1}}],[\"代码随想录\",{\"1\":{\"1\":1,\"1972\":1}}],[\"代表通信接口\",{\"1\":{\"1683\":1}}],[\"代表了每个红色widget的重量\",{\"1\":{\"1619\":1}}],[\"代表类的构造方法\",{\"1\":{\"1560\":1}}],[\"代表类的方法\",{\"1\":{\"1560\":1}}],[\"代表一个类\",{\"1\":{\"1560\":1}}],[\"代表它几乎没有界限\",{\"1\":{\"1503\":1}}],[\"代表实现\",{\"1\":{\"944\":1,\"1398\":1}}],[\"代表组件有哪些\",{\"0\":{\"780\":1}}],[\"代表使用默认值\",{\"1\":{\"468\":1}}],[\"代表什么\",{\"1\":{\"320\":1}}],[\"代替关联查询\",{\"1\":{\"394\":1}}],[\"除特殊情况外\",{\"1\":{\"1619\":1}}],[\"除数组之外还有一个序列号\",{\"1\":{\"1520\":1}}],[\"除非显示的使用另外一个classloader\",{\"1\":{\"1663\":1}}],[\"除非其余的异常是与第一个异常相同的异常\",{\"1\":{\"1619\":1}}],[\"除非这个流被显示的设计成可以并发修改的\",{\"1\":{\"1619\":1}}],[\"除非使用者非常了解spring事件机制\",{\"1\":{\"1129\":1}}],[\"除非内核为套接字分配的写缓冲区已经满了\",{\"1\":{\"602\":1}}],[\"除非有特殊需求\",{\"1\":{\"529\":1}}],[\"除非有什么办法能够逐个测量上面这些消耗\",{\"1\":{\"388\":1}}],[\"除非业务就是有一张静态表\",{\"1\":{\"319\":1}}],[\"除此之外\",{\"1\":{\"347\":1,\"401\":1,\"559\":1,\"914\":1,\"1594\":1,\"1969\":1,\"1974\":1}}],[\"除\",{\"1\":{\"330\":1}}],[\"除了增强某个类中的某个方法\",{\"1\":{\"1654\":1}}],[\"除了直接使用api的方式来生成代理对象\",{\"1\":{\"1654\":1}}],[\"除了直接使用jdk\",{\"1\":{\"1133\":1}}],[\"除了上述的情况外\",{\"1\":{\"1652\":1}}],[\"除了上面追加中间操作的部分\",{\"1\":{\"1622\":1}}],[\"除了singleton和prototype\",{\"1\":{\"1647\":1}}],[\"除了spliterator涵盖的是一个无限元素的对象的情况\",{\"1\":{\"1620\":1}}],[\"除了可以通过beanpostprocessor来自定义spring创建bean的过程\",{\"1\":{\"1644\":1}}],[\"除了可以添加\",{\"1\":{\"482\":1}}],[\"除了ofint之外还有其他两种oflong\",{\"1\":{\"1620\":1}}],[\"除了以上非常核心的方法\",{\"1\":{\"1620\":1}}],[\"除了以上四种标准\",{\"1\":{\"1133\":1}}],[\"除了他还有一些原生的\",{\"1\":{\"1619\":1}}],[\"除了往集合中不断累加元素之外\",{\"1\":{\"1617\":1}}],[\"除了在collectors预先定义好的静态工厂方法可以创建一个收集器之外\",{\"1\":{\"1615\":1}}],[\"除了将他们再一次传递给accumulator\",{\"1\":{\"1615\":1}}],[\"除了将流转化为list\",{\"1\":{\"1609\":1}}],[\"除了无参构造\",{\"1\":{\"1606\":1}}],[\"除了通过这种方式创建实例外\",{\"1\":{\"1600\":1}}],[\"除了一个抽象方法accept\",{\"1\":{\"1594\":1}}],[\"除了抽象方法外还可以定义default\",{\"1\":{\"1594\":1}}],[\"除了等待没有其他方式\",{\"1\":{\"1516\":1}}],[\"除了java之外\",{\"1\":{\"1483\":1}}],[\"除了查看之外\",{\"1\":{\"1353\":1}}],[\"除了框架内建的这些实现\",{\"1\":{\"1138\":1}}],[\"除了实现类名可以表达语义\",{\"1\":{\"1085\":1}}],[\"除了类型转换\",{\"1\":{\"1085\":1}}],[\"除了redis之外\",{\"1\":{\"601\":1}}],[\"除了基本的操作\",{\"1\":{\"583\":1}}],[\"除了传统的计算资源\",{\"1\":{\"533\":1}}],[\"除了bison外\",{\"1\":{\"513\":1}}],[\"除了显而易见的修改类语句外\",{\"1\":{\"497\":1}}],[\"除了误删数据的语句外\",{\"1\":{\"485\":1}}],[\"除了正常返回一个正整数m外\",{\"1\":{\"473\":1}}],[\"除了备库外\",{\"1\":{\"457\":1}}],[\"除了后台线程每秒一次的轮询操作外\",{\"1\":{\"451\":1}}],[\"除了物理上要有文件外\",{\"1\":{\"412\":1}}],[\"除了这些变化点\",{\"1\":{\"1687\":1}}],[\"除了这些常规的操作\",{\"1\":{\"1616\":1}}],[\"除了这种编码的方式\",{\"1\":{\"1123\":1}}],[\"除了这种做法\",{\"1\":{\"348\":1}}],[\"除了这两个特性看上去比较\",{\"1\":{\"409\":1}}],[\"除了会导致io压力大以外\",{\"1\":{\"406\":1}}],[\"除了访问这个数据页会触发merge外\",{\"1\":{\"343\":1}}],[\"除了考虑性能外\",{\"1\":{\"335\":1}}],[\"除了性能外\",{\"1\":{\"335\":1}}],[\"除了数据本身之外\",{\"1\":{\"331\":1}}],[\"除了all没有用到索引\",{\"1\":{\"330\":1}}],[\"除了lock和synchronized\",{\"0\":{\"87\":1,\"1416\":1}}],[\"因而具有很快的访问速度\",{\"1\":{\"1544\":1}}],[\"因a已被执行\",{\"1\":{\"1531\":1}}],[\"因为并不是所有的公司都有全文检索的需求\",{\"1\":{\"1986\":1}}],[\"因为并不是所有的行的访问代价都是相同的\",{\"1\":{\"389\":1}}],[\"因为做的项目中使用到了\",{\"1\":{\"1985\":1}}],[\"因为dogetbean方法的逻辑是\",{\"1\":{\"1661\":1}}],[\"因为handlemethod需要在spring\",{\"1\":{\"1660\":1}}],[\"因为如果遵循的话\",{\"1\":{\"1622\":1}}],[\"因为时间间隔增大了\",{\"1\":{\"1620\":1}}],[\"因为避免了在使用hasnext和next方法的竞争的出现\",{\"1\":{\"1620\":1}}],[\"因为某些保证实在执行之前才是有效的\",{\"1\":{\"1620\":1}}],[\"因为某些原因而造成故障停机\",{\"1\":{\"592\":1}}],[\"因为无需进行最后的合并操作\",{\"1\":{\"1617\":1}}],[\"因为无法保证与supplier\",{\"1\":{\"1617\":1}}],[\"因为其不接收参数\",{\"1\":{\"1606\":1}}],[\"因为行为总是被预先定义好的\",{\"1\":{\"1598\":1}}],[\"因为object类是所有类的父类\",{\"1\":{\"1594\":1}}],[\"因为编译器可以自动推断出当前遍历集合当前元素的类型\",{\"1\":{\"1593\":1}}],[\"因为resize的过程\",{\"1\":{\"1550\":1}}],[\"因为row格式在记录binlog的时候\",{\"1\":{\"459\":1}}],[\"因为rowid其实就是数组的下标\",{\"1\":{\"420\":1}}],[\"因为n变为2倍\",{\"1\":{\"1550\":1}}],[\"因为使用了while循环去等待\",{\"1\":{\"1530\":1}}],[\"因为线程的状态可能处于休眠态\",{\"1\":{\"1524\":1}}],[\"因为写屏障即内存一致性协议会导致同一时间只能一个线程操作该缓存行\",{\"1\":{\"1519\":1}}],[\"因为计算任务非常重\",{\"1\":{\"1510\":1}}],[\"因为业务可能有高峰期\",{\"1\":{\"1509\":1}}],[\"因为唤醒是需要加putlock的\",{\"1\":{\"1503\":1}}],[\"因为可能有很多线程阻塞在notfull这个条件上\",{\"1\":{\"1503\":1}}],[\"因为可能会导致一些与计算相关的问题\",{\"1\":{\"530\":1}}],[\"因为入队了一个元素\",{\"1\":{\"1502\":1}}],[\"因为阻塞队列是线程安全的\",{\"1\":{\"1501\":1}}],[\"因为消息是点对点的\",{\"1\":{\"1474\":1}}],[\"因为所有事务都是处理器看到的请求\",{\"1\":{\"1474\":1}}],[\"因为只要经过一些次数的垃圾收集\",{\"1\":{\"1434\":1}}],[\"因为只匹配一行数据\",{\"1\":{\"330\":1}}],[\"因为红黑树需要进行左旋\",{\"1\":{\"1360\":1}}],[\"因为要一天内处理完\",{\"1\":{\"1536\":1}}],[\"因为要保证主从之间的数据一致\",{\"1\":{\"1269\":1}}],[\"因为要能够从binlog里面解析出表名\",{\"1\":{\"462\":1}}],[\"因为网络超时\",{\"1\":{\"1248\":1}}],[\"因为一个异常不能压制它本身\",{\"1\":{\"1619\":1}}],[\"因为一个线程只能处理一个连接\",{\"1\":{\"1573\":1}}],[\"因为一个线程功能只能处理一个连接\",{\"1\":{\"1573\":1}}],[\"因为一个数据或事件可能需要多个channelhandler来进行处理\",{\"1\":{\"1224\":1}}],[\"因为一条语句的执行其实是分为两层的\",{\"1\":{\"557\":1}}],[\"因为会出发父应用上下文的事件\",{\"1\":{\"1116\":1}}],[\"因为io读写速度相比于cpu的速度是比较慢的\",{\"1\":{\"1510\":1}}],[\"因为instantiationawarebeanpostprocessor继承了beanpostprocessor\",{\"1\":{\"1006\":1}}],[\"因为id中间可能由空洞\",{\"1\":{\"422\":1}}],[\"因为相当于返回的bean已经被替换了\",{\"1\":{\"1003\":1}}],[\"因为创建好的prototype的bean通常而言都是马上要使用的\",{\"1\":{\"985\":1}}],[\"因为我们依赖的第三方库很可能没有正确处理中断一场\",{\"1\":{\"1524\":1}}],[\"因为我们几乎无法把这个容量装满\",{\"1\":{\"1501\":1}}],[\"因为我们这里注入autowiredannotationbeanpostprocessor采用的static\",{\"1\":{\"967\":1}}],[\"因为我们通过select系统调用同时处理多个通道描述符的读写事件\",{\"1\":{\"603\":1}}],[\"因为发一个dubbo协议的请求给一个grpc服务\",{\"1\":{\"637\":1}}],[\"因为定时生成\",{\"1\":{\"596\":1}}],[\"因为是使用子进程进行写操作\",{\"1\":{\"588\":1}}],[\"因为事务隔离实质上就是使事务在一定程度上\",{\"1\":{\"532\":1}}],[\"因为不用考虑timestamp将来的时间上限问题\",{\"1\":{\"529\":1}}],[\"因为不是有序的\",{\"1\":{\"332\":1}}],[\"因为myisam存储的引擎的表的总行数会被mysql存储在磁盘上\",{\"1\":{\"526\":1}}],[\"因为当表中某些记录被删后\",{\"1\":{\"522\":1}}],[\"因为当前正在运行的只读事务\",{\"1\":{\"497\":1}}],[\"因为根据name字段过滤完\",{\"1\":{\"518\":1}}],[\"因为同一个只读事务在执行期间\",{\"1\":{\"497\":1}}],[\"因为表自增id达到上限后\",{\"1\":{\"495\":1}}],[\"因为表t中没有c=7这个记录\",{\"1\":{\"448\":1}}],[\"因为碰到了唯一键c冲突\",{\"1\":{\"491\":1}}],[\"因为自增主键不能保证连续递增\",{\"1\":{\"489\":1}}],[\"因为外部检测都需要定时轮询\",{\"1\":{\"478\":1}}],[\"因为从库的延迟时间不可控\",{\"1\":{\"473\":1}}],[\"因为从引擎返回id会涉及到解析数据行\",{\"1\":{\"399\":1}}],[\"因为少了一层proxy转发\",{\"1\":{\"469\":1}}],[\"因为切换过程中\",{\"1\":{\"467\":1}}],[\"因为servlet可以去依赖或者反向地通过jndi的方式进行得到一些外部的一些资源\",{\"1\":{\"914\":1}}],[\"因为setter的字段本身是可以为空的\",{\"1\":{\"912\":1}}],[\"因为select系统调用的性能再描述符特别多时性能会非常差\",{\"1\":{\"603\":1}}],[\"因为session\",{\"1\":{\"441\":1}}],[\"因为statement格式的binlog也可以很容易拿到库名\",{\"1\":{\"463\":1}}],[\"因为数据是存储在表里的\",{\"1\":{\"461\":1}}],[\"因为这种整合方式目前也不在流行了\",{\"1\":{\"1982\":1}}],[\"因为这种方式需要依赖于applicationcontext的\",{\"1\":{\"1007\":1}}],[\"因为这里需要使用两个system\",{\"1\":{\"1565\":1}}],[\"因为这个线程都阻塞在了f1\",{\"1\":{\"1517\":1}}],[\"因为这类语句在申请自增id的时候\",{\"1\":{\"492\":1}}],[\"因为这段时间内\",{\"1\":{\"459\":1}}],[\"因为这三个查询都是加了for\",{\"1\":{\"446\":1}}],[\"因为在spring中是不会扫描接口的\",{\"1\":{\"1653\":1}}],[\"因为在执行过程中\",{\"1\":{\"1617\":1}}],[\"因为在beanfactory进行查找的时候\",{\"1\":{\"1091\":1}}],[\"因为在步骤2之后\",{\"1\":{\"458\":1}}],[\"因为在t3时刻\",{\"1\":{\"447\":1}}],[\"因为作为数据库系统\",{\"1\":{\"457\":1}}],[\"因为有时我们并不能在出事的时候很好的准确估计队列的大小\",{\"1\":{\"1509\":1}}],[\"因为有mvcc机制\",{\"1\":{\"526\":1}}],[\"因为有这个操作\",{\"1\":{\"481\":1}}],[\"因为有些语句的执行结果是依赖于上下文命令的\",{\"1\":{\"454\":1}}],[\"因为有些statement格式的binlog可能会导致主备不一致\",{\"1\":{\"454\":1}}],[\"因为有一个崩溃恢复逻辑是要依赖于prepare的redo\",{\"1\":{\"451\":1}}],[\"因为有了具体文本的位置\",{\"1\":{\"299\":1}}],[\"因为虽然每个客户端的并发量可能很小\",{\"1\":{\"444\":1}}],[\"因为它只需要\",{\"1\":{\"1509\":1}}],[\"因为它只需要开始于索引树的某一点\",{\"1\":{\"330\":1}}],[\"因为它的容量在创建时就确定了\",{\"1\":{\"1509\":1}}],[\"因为它速度快\",{\"1\":{\"528\":1}}],[\"因为它们都需要在读写事件就绪后自己负责进行读写\",{\"1\":{\"1568\":1}}],[\"因为它们通常有更好的性能\",{\"1\":{\"527\":1}}],[\"因为它们要更新同一个影院账户的余额\",{\"1\":{\"443\":1}}],[\"因为新的请求马上就会到\",{\"1\":{\"441\":1}}],[\"因为开启慢查询日志会或多或少带来一定的性能影响\",{\"1\":{\"428\":1}}],[\"因为\",{\"1\":{\"424\":1,\"457\":1,\"476\":1,\"491\":1,\"577\":1,\"1098\":1,\"1649\":1}}],[\"因为取max\",{\"1\":{\"422\":1}}],[\"因为将max\",{\"1\":{\"421\":1}}],[\"因为备库上并没有表tmp\",{\"1\":{\"413\":1}}],[\"因为目前的优化器会更倾向于不使用mrr\",{\"1\":{\"404\":1}}],[\"因为大多数的数据都是按照主键递增顺序插入得到的\",{\"1\":{\"404\":1}}],[\"因为之前c2这个字段已经确定了是\",{\"1\":{\"378\":1}}],[\"因为c在范围之后\",{\"1\":{\"377\":1}}],[\"因为crc32\",{\"1\":{\"352\":1}}],[\"因为b断了\",{\"1\":{\"377\":1}}],[\"因为系统并不确定前缀索引的定义是否截断了完整信息\",{\"1\":{\"351\":1}}],[\"因此还是要学习\",{\"1\":{\"1983\":1}}],[\"因此它需要加载自己的类和依赖的jar包\",{\"1\":{\"1693\":1}}],[\"因此它也被称为\",{\"1\":{\"1479\":1}}],[\"因此也就被称之为动态链接\",{\"1\":{\"1664\":1}}],[\"因此也就不需要临时表了\",{\"1\":{\"414\":1}}],[\"因此beanclass是object类型的属性\",{\"1\":{\"1647\":1}}],[\"因此有两种情况\",{\"1\":{\"1622\":1}}],[\"因此有比较严重的性能问题\",{\"1\":{\"425\":1}}],[\"因此都会自动的调用close方法\",{\"1\":{\"1619\":1}}],[\"因此流并没有被真正的调用\",{\"1\":{\"1610\":1}}],[\"因此同样满足函数式接口的定义\",{\"1\":{\"1594\":1}}],[\"因此随着监视的描述符数量的增长\",{\"1\":{\"1570\":1}}],[\"因此新的index就会发生这样的变化\",{\"1\":{\"1550\":1}}],[\"因此空间利用率更高\",{\"1\":{\"1509\":1}}],[\"因此其实这个过程是线程安全的\",{\"1\":{\"1487\":1}}],[\"因此为了消除数据在无竞争情况下锁重入\",{\"1\":{\"1485\":1}}],[\"因此为了解决幻读问题\",{\"1\":{\"448\":1}}],[\"因此变量mark是boolean类型\",{\"1\":{\"1479\":1}}],[\"因此称为四次握手\",{\"1\":{\"1425\":1}}],[\"因此需要在同步块中调用\",{\"1\":{\"1382\":1}}],[\"因此需要手动添加\",{\"1\":{\"1007\":1}}],[\"因此需要排序的总数据量就变小了\",{\"1\":{\"355\":1}}],[\"因此直接运行\",{\"1\":{\"1007\":1}}],[\"因此我们可以使用依赖注入的方式获取到唯一的对象applicationeventmulticaster的对象\",{\"1\":{\"1168\":1}}],[\"因此我们还是调整myinstantiationawarebeanpostprocessor的方法来进行观察\",{\"1\":{\"1006\":1}}],[\"因此我们将这类系统调用称为多路复用api\",{\"1\":{\"603\":1}}],[\"因此性能会更好\",{\"1\":{\"637\":1}}],[\"因此redis内部所有的涉及rdb的操作都采用bgsave的方式\",{\"1\":{\"587\":1}}],[\"因此项目中通常需要修改redistemplate的序列化方式\",{\"1\":{\"583\":1}}],[\"因此说redis所以不保证事务原子性\",{\"1\":{\"580\":1}}],[\"因此扫描的总行数为10000\",{\"1\":{\"525\":1}}],[\"因此整个过程扫描了200行\",{\"1\":{\"524\":1}}],[\"因此整个执行过程\",{\"1\":{\"401\":1}}],[\"因此达到232\",{\"1\":{\"498\":1}}],[\"因此认为这个数据可见\",{\"1\":{\"497\":1}}],[\"因此在java中\",{\"1\":{\"1595\":1}}],[\"因此在join的时候\",{\"1\":{\"402\":1}}],[\"因此在检查函数式接口的定义的时候\",{\"1\":{\"1594\":1}}],[\"因此在并发情况下都不会导致服务崩溃\",{\"1\":{\"1573\":1}}],[\"因此在建表的时候需要考察是否可能达到这个上限\",{\"1\":{\"494\":1}}],[\"因此索引更紧凑\",{\"1\":{\"489\":1}}],[\"因此会进行批量重偏向\",{\"1\":{\"1485\":1}}],[\"因此会让服务端变慢\",{\"1\":{\"482\":1}}],[\"因此会优先选择全字段排序\",{\"1\":{\"420\":1}}],[\"因此根本不会进入终止逻辑阶段\",{\"1\":{\"481\":1}}],[\"因此主库a\",{\"1\":{\"468\":1}}],[\"因此delete\",{\"1\":{\"454\":1}}],[\"因此可能会出现这样一种情况\",{\"1\":{\"454\":1}}],[\"因此可能会增加语句的响应时间\",{\"1\":{\"451\":1}}],[\"因此可以将bytebuf分为多个共享同一个存储区域的bytebuf\",{\"1\":{\"1231\":1}}],[\"因此可以正常执行\",{\"1\":{\"441\":1}}],[\"因此可以有多个线程同时对一张表增删改查\",{\"1\":{\"441\":1}}],[\"因此可以并存\",{\"1\":{\"412\":1}}],[\"因此可以直接提供查询结果\",{\"1\":{\"338\":1}}],[\"因此等trx1返回时\",{\"1\":{\"451\":1}}],[\"因此session\",{\"1\":{\"448\":1}}],[\"因此tomcat设计了一系列抽象基类来封装这些稳定的部分\",{\"1\":{\"1687\":1}}],[\"因此tomcat设计了两个核心组件连接器\",{\"1\":{\"1683\":1}}],[\"因此t5时刻q3查出来的是id=0\",{\"1\":{\"446\":1}}],[\"因此t3时刻q2查出来的是id=0和id=5这两行\",{\"1\":{\"446\":1}}],[\"因此业务设计的时候一般不会把死锁当做一个严重错误\",{\"1\":{\"444\":1}}],[\"因此只能采用使用注解描述注解的方式\",{\"1\":{\"1134\":1}}],[\"因此只能被阻塞\",{\"1\":{\"441\":1}}],[\"因此只是一个估算值\",{\"1\":{\"396\":1}}],[\"因此很多时候\",{\"1\":{\"433\":1}}],[\"因此很有可能费劲的把结果存起来\",{\"1\":{\"319\":1}}],[\"因此mysql对于被驱动表的关联字段没有索引的关联查询\",{\"1\":{\"525\":1}}],[\"因此mysql认为扫描行数是2\",{\"1\":{\"338\":1}}],[\"因此mdl锁之后的执行过程\",{\"1\":{\"425\":1}}],[\"因此所有分区共用同一个mdl锁\",{\"1\":{\"425\":1}}],[\"因此加锁范围就是图中深绿色的部分\",{\"1\":{\"424\":1}}],[\"因此选择不同行的概率不一样\",{\"1\":{\"422\":1}}],[\"因此这里不做过多介绍\",{\"1\":{\"587\":1}}],[\"因此这一步需要扫描y+1行\",{\"1\":{\"422\":1}}],[\"因此这是一个最大堆\",{\"1\":{\"421\":1}}],[\"因此这个策略会产生比较高的平均延时\",{\"1\":{\"1520\":1}}],[\"因此这个策略用的并不多\",{\"1\":{\"463\":1}}],[\"因此这个时候选择大表或者小表做驱动表\",{\"1\":{\"403\":1}}],[\"因此这个语句的执行流程如下\",{\"1\":{\"401\":1}}],[\"因此当使用磁盘临时表的时候\",{\"1\":{\"421\":1}}],[\"因此全程只使用了内存临时表\",{\"1\":{\"416\":1}}],[\"因此结果集里最后一行才是m=0\",{\"1\":{\"416\":1}}],[\"因此返回的结果集中的第一行是id=1\",{\"1\":{\"416\":1}}],[\"因此对表t1中的每一行\",{\"1\":{\"525\":1}}],[\"因此对表t2中的每一行\",{\"1\":{\"403\":1}}],[\"因此对应的number\",{\"1\":{\"421\":1}}],[\"因此对于count\",{\"1\":{\"396\":1}}],[\"因此对于写多读少的业务来说\",{\"1\":{\"344\":1}}],[\"因此总的扫描行数是1100\",{\"1\":{\"403\":1}}],[\"因此是把整个表t1放入了内存\",{\"1\":{\"403\":1}}],[\"因此应该让小表做驱动表\",{\"1\":{\"401\":1}}],[\"因此每次的搜索过程都只扫描一行\",{\"1\":{\"401\":1}}],[\"因此执行count\",{\"1\":{\"396\":1}}],[\"因此最终还是会选择索引t\",{\"1\":{\"366\":1}}],[\"因此优化器决定放弃走树搜索功能\",{\"1\":{\"366\":1}}],[\"因此不会上锁\",{\"1\":{\"1399\":1}}],[\"因此不会优先选择\",{\"1\":{\"356\":1}}],[\"因此不论这个事务多大\",{\"1\":{\"450\":1}}],[\"因此不能无线增大\",{\"1\":{\"343\":1}}],[\"因此如果有满足条件的记录\",{\"1\":{\"348\":1}}],[\"因此将会返回空集合\",{\"1\":{\"347\":1}}],[\"因此出现这种情况的概率会很低\",{\"1\":{\"342\":1}}],[\"因此\",{\"1\":{\"327\":1,\"332\":1,\"333\":1,\"335\":1,\"338\":1,\"339\":1,\"340\":1,\"343\":1,\"344\":1,\"348\":1,\"356\":1,\"368\":1,\"396\":2,\"403\":1,\"404\":1,\"406\":1,\"420\":1,\"424\":2,\"433\":1,\"435\":1,\"438\":2,\"441\":3,\"444\":1,\"446\":1,\"447\":1,\"450\":1,\"451\":1,\"453\":1,\"454\":2,\"459\":1,\"460\":1,\"462\":2,\"465\":1,\"466\":1,\"467\":2,\"468\":1,\"469\":1,\"477\":1,\"478\":1,\"479\":1,\"482\":1,\"491\":1,\"492\":2,\"496\":1,\"497\":1,\"965\":1,\"1005\":1,\"1098\":1,\"1236\":1,\"1360\":1,\"1479\":1,\"1545\":1,\"1550\":1,\"1613\":1,\"1687\":1}}],[\"因此引擎扫描行数跟rows\",{\"1\":{\"322\":1}}],[\"只需在项目的\",{\"1\":{\"1980\":1}}],[\"只需要一些配置文件\",{\"1\":{\"1982\":1}}],[\"只需要一个线程负责selector轮询\",{\"1\":{\"1574\":1}}],[\"只需要这一行代码就可以完成根据姓名对于学生的分组操作\",{\"1\":{\"1613\":1}}],[\"只需要看看原来的hash值新增的哪个bit是1还是0就好了\",{\"1\":{\"1550\":1}}],[\"只需要把转帐任务\",{\"1\":{\"1501\":1}}],[\"只需要把这个event前后的两行信息对调以下\",{\"1\":{\"454\":1}}],[\"只需要唤醒一个线程\",{\"1\":{\"1483\":1}}],[\"只需要o\",{\"1\":{\"1292\":1}}],[\"只需要在配置文件中做相关的事务规则声明就可以了\",{\"1\":{\"1238\":1}}],[\"只需要库名\",{\"1\":{\"463\":1}}],[\"只需要扫描1000次\",{\"1\":{\"356\":1}}],[\"只需要回主键索引取一次数据\",{\"1\":{\"350\":1}}],[\"只需要遍历\",{\"1\":{\"348\":1}}],[\"只需要对id4\",{\"1\":{\"340\":1}}],[\"只需要往后追加\",{\"1\":{\"332\":1}}],[\"只描述其行为\",{\"1\":{\"1611\":1}}],[\"只返回对象的supplier函数式接口的要求\",{\"1\":{\"1600\":1}}],[\"只不过这里每次只是取出来数组中唯一的元素\",{\"1\":{\"1618\":1}}],[\"只不过在某些场景下\",{\"1\":{\"1592\":1}}],[\"只不过存储的时候value默认存储了一个object的静态变量\",{\"1\":{\"1557\":1}}],[\"只不过对于驱动表s1也多了一个order\",{\"1\":{\"554\":1}}],[\"只不过对于驱动表s1多了一个order\",{\"1\":{\"554\":1}}],[\"只保留了后面的n位\",{\"1\":{\"1548\":1}}],[\"只标记出根对象直接引用的对象\",{\"1\":{\"1447\":1}}],[\"只收集老年代垃圾对象\",{\"1\":{\"1434\":1}}],[\"只收集新生代垃圾对象\",{\"1\":{\"1434\":1}}],[\"只允许一个请求访问后端服务或数据库\",{\"1\":{\"1283\":1}}],[\"只允许创建已经实现了本地分区策略的引擎\",{\"1\":{\"425\":1}}],[\"只读资源\",{\"1\":{\"1038\":1}}],[\"只读事务不分配trx\",{\"1\":{\"497\":1}}],[\"只许追加文件但不可以改写文件\",{\"1\":{\"591\":1}}],[\"只显示前n个\",{\"1\":{\"576\":1}}],[\"只支持开区间\",{\"1\":{\"574\":1}}],[\"只变动key\",{\"1\":{\"573\":1}}],[\"只存储索引\",{\"1\":{\"503\":1}}],[\"只给业务开发dml权限\",{\"1\":{\"487\":1}}],[\"只打开需要的项进行统计即可\",{\"1\":{\"479\":1}}],[\"只负责读取中转日志和分发事务\",{\"1\":{\"460\":1}}],[\"只切换备库\",{\"1\":{\"459\":1}}],[\"只会进入初始化后的阶段\",{\"1\":{\"1644\":1}}],[\"只会head\",{\"1\":{\"1621\":2}}],[\"只会根据输入元素来计算基数\",{\"1\":{\"577\":1}}],[\"只会记录id=4这个信息\",{\"1\":{\"454\":1}}],[\"只会write到文件系统的page\",{\"1\":{\"451\":1}}],[\"只会堵住在这个分区上执行的查询\",{\"1\":{\"424\":1}}],[\"只锁记录\",{\"1\":{\"442\":1}}],[\"只访问必要的分区\",{\"1\":{\"425\":1}}],[\"只访问索引的查询\",{\"1\":{\"369\":1}}],[\"只插入了两行数据\",{\"1\":{\"424\":1}}],[\"只完成一小部分\",{\"1\":{\"393\":1}}],[\"只用到a\",{\"1\":{\"377\":2}}],[\"只用了0\",{\"1\":{\"348\":1}}],[\"只对一主一备的场景是成立的\",{\"1\":{\"472\":1}}],[\"只对原表的数据读了一遍\",{\"1\":{\"355\":1}}],[\"只对本线程有效\",{\"1\":{\"354\":1,\"421\":1}}],[\"只扫描这一行就结束了\",{\"1\":{\"350\":1}}],[\"只是分割一个近似平衡的树\",{\"1\":{\"1620\":1}}],[\"只是为了说明问题\",{\"1\":{\"1620\":1}}],[\"只是根据collector接口的要求\",{\"1\":{\"1616\":1}}],[\"只是这里我们调用新的方法reversed\",{\"1\":{\"1614\":1}}],[\"只是把时间分成若干段\",{\"1\":{\"1470\":1}}],[\"只是它的请求处理整个流程是单线程处理的\",{\"1\":{\"1292\":1}}],[\"只是在细微的地方略有差别\",{\"1\":{\"966\":1}}],[\"只是针对其中某个key的缓存不可用而导致击穿\",{\"1\":{\"629\":1}}],[\"只是中心位置不是具体的经纬度\",{\"1\":{\"576\":1}}],[\"只是需要再根据主键回到原表取数据\",{\"1\":{\"520\":1}}],[\"只是显示用的\",{\"1\":{\"497\":1}}],[\"只是对于mysql的kill命令来说\",{\"1\":{\"481\":1}}],[\"只是将a的更新都同步过来\",{\"1\":{\"453\":1}}],[\"只是简单的锁等待也会释放\",{\"1\":{\"444\":1}}],[\"只是刚好在这个语句中有limit\",{\"1\":{\"348\":1}}],[\"只是按顺序把\",{\"1\":{\"340\":1}}],[\"只能够在程序运行期间调用方法的符号引用转换为直接引用\",{\"1\":{\"1664\":1}}],[\"只能返回一个结果\",{\"1\":{\"1598\":1}}],[\"只能消费者加机器\",{\"1\":{\"1536\":1}}],[\"只能选择有界队列\",{\"1\":{\"1519\":1}}],[\"只能从head取元素\",{\"1\":{\"1503\":1}}],[\"只能从id3开始一个个回表\",{\"1\":{\"340\":1}}],[\"只能保证一个共享变量原子操作\",{\"1\":{\"1479\":1}}],[\"只能有一条执行执行\",{\"1\":{\"1470\":1}}],[\"只能在流的终止操作之前进行调用\",{\"1\":{\"1619\":1}}],[\"只能在单线程环境下使用\",{\"1\":{\"1370\":1}}],[\"只能在应用到包含12点的binlog文件的时候\",{\"1\":{\"485\":1}}],[\"只能做remove操作\",{\"1\":{\"1353\":1}}],[\"只能成功一次等等\",{\"1\":{\"1248\":1}}],[\"只能由字母a\",{\"1\":{\"624\":1}}],[\"只能由主节点复制到从节点\",{\"1\":{\"606\":1}}],[\"只能通过explain语句查看到最后优化器决定使用的执行计划\",{\"1\":{\"544\":1}}],[\"只能尽量将备份跨机房\",{\"1\":{\"488\":1}}],[\"只能删除固定后缀的表\",{\"1\":{\"487\":1}}],[\"只能说明这个库的进程还在\",{\"1\":{\"476\":1}}],[\"只能取到一个大概位置\",{\"1\":{\"467\":1}}],[\"只能到所有的分区中去查找满足条件的所有行\",{\"1\":{\"411\":1}}],[\"只能自己计数\",{\"1\":{\"396\":1}}],[\"只能用于类型方面的依赖注入\",{\"1\":{\"977\":1}}],[\"只能用\",{\"1\":{\"340\":1}}],[\"只要掌握最常用的数据结构以及一些经典的算法题目即可\",{\"1\":{\"1970\":1}}],[\"只要给定的bean对象\",{\"1\":{\"1652\":1}}],[\"只要是调用代理对象的方法\",{\"1\":{\"1630\":1}}],[\"只要还有元素\",{\"1\":{\"1623\":1}}],[\"只要它的hashcode方法返回值相同\",{\"1\":{\"1548\":1}}],[\"只要r1\",{\"1\":{\"1517\":1}}],[\"只要有一个成功就返回结果\",{\"1\":{\"1517\":1}}],[\"只要有一个成功返回\",{\"1\":{\"1517\":1}}],[\"只要有对一个表的更新\",{\"1\":{\"319\":1}}],[\"只要没有writer线程\",{\"1\":{\"1498\":1}}],[\"只要没有也别大的索引\",{\"1\":{\"426\":1}}],[\"只要强引用关系还存在\",{\"1\":{\"1435\":1}}],[\"只要\",{\"1\":{\"1353\":1}}],[\"只要拿到这个对象\",{\"1\":{\"1353\":1}}],[\"只要实体类进行了序列化\",{\"1\":{\"583\":1}}],[\"只要实现按行分发\",{\"1\":{\"462\":1}}],[\"只要相隔不大于10个页面即可\",{\"1\":{\"549\":1}}],[\"只要一个mysql服务跑得足够久\",{\"1\":{\"497\":1}}],[\"只要定义了表示这个数的字节长度\",{\"1\":{\"493\":1}}],[\"只要不是恶意地把整个集群删除\",{\"1\":{\"488\":1}}],[\"只要能够达到redo\",{\"1\":{\"465\":1}}],[\"只要主库执行更新生成的所有binlog\",{\"1\":{\"456\":1}}],[\"只要where条件后面有函数操作都会导致无法使用索引快速定位的功能\",{\"1\":{\"366\":1}}],[\"只要找到满足条件的前1000条记录就可以退出了\",{\"1\":{\"356\":1}}],[\"只要city的值是杭州\",{\"1\":{\"356\":1}}],[\"只要满足最左前缀\",{\"1\":{\"339\":1}}],[\"只有aspectj才有\",{\"1\":{\"1654\":1}}],[\"只有ab\",{\"1\":{\"556\":1}}],[\"只有finisher没有被调用\",{\"1\":{\"1617\":1}}],[\"只有无序的数据源才可以使用这个属性\",{\"1\":{\"1617\":1}}],[\"只有当流的元是一个io通道的时候\",{\"1\":{\"1619\":1}}],[\"只有当终止操作开始的时候\",{\"1\":{\"1619\":1}}],[\"只有当开启并行流\",{\"1\":{\"1617\":1}}],[\"只有当特性值设置为unordered的时候\",{\"1\":{\"1615\":1}}],[\"只有当表达式中具有reduce这样的终止操作的方法的时候\",{\"1\":{\"1607\":1}}],[\"只有当某一个已经存在的方法\",{\"1\":{\"1603\":1}}],[\"只有操作系统提供sendfile这样的零拷贝系统调用方法\",{\"1\":{\"1588\":1}}],[\"只有数组对象有\",{\"1\":{\"1484\":1}}],[\"只有从未出现过并发冲突的时候\",{\"1\":{\"1480\":1}}],[\"只有native方法可以执行\",{\"1\":{\"1440\":1}}],[\"只有prototype的bean不会进行缓存\",{\"1\":{\"1182\":1}}],[\"只有两个简单的bean\",{\"1\":{\"583\":1}}],[\"只有两种选择\",{\"1\":{\"473\":1}}],[\"只有在达到了线程池最大线程数的时候才会将任务放入到阻塞队列\",{\"1\":{\"1689\":1}}],[\"只有在激活状态下才可以接收数据\",{\"1\":{\"1623\":1}}],[\"只有在流源这个阶段才有效\",{\"1\":{\"1621\":1}}],[\"只有在父进程或者子进程需要写入的时候才会复制地址空间\",{\"1\":{\"1527\":1}}],[\"只有在调用getobject的时候\",{\"1\":{\"1181\":1}}],[\"只有在字段\",{\"1\":{\"573\":1}}],[\"只有在串行化的隔离级别下\",{\"1\":{\"540\":1}}],[\"只有等到满足进入innodb的条件后\",{\"1\":{\"481\":1}}],[\"只有一个线程能执行\",{\"1\":{\"1490\":1}}],[\"只有一个事务能够获得排他锁\",{\"1\":{\"1263\":1}}],[\"只有一个worker线程在工作\",{\"1\":{\"464\":1}}],[\"只有一个索引\",{\"1\":{\"335\":1}}],[\"只有主键id还是不够的\",{\"1\":{\"462\":1}}],[\"只有最终一致性是不够的\",{\"1\":{\"456\":1}}],[\"只有sql的执行时间>10才会被记录\",{\"1\":{\"428\":1}}],[\"只有innodb和ndb这两个引擎支持了本地分区策略\",{\"1\":{\"425\":1}}],[\"只有要排序的列\",{\"1\":{\"355\":1}}],[\"只有再新建的连接才会使用新的权限设置\",{\"1\":{\"318\":1}}],[\"只检索给定范围的行\",{\"1\":{\"330\":1}}],[\"被代理的对象通常称为target\",{\"1\":{\"1654\":1}}],[\"被代理的方法通常被称为join\",{\"1\":{\"1654\":1}}],[\"被代理的方法\",{\"1\":{\"1654\":1}}],[\"被链接或者被消费\",{\"1\":{\"1622\":1}}],[\"被注解的类型满足函数式接口的定义\",{\"1\":{\"1594\":1}}],[\"被注解的是一个接口类型\",{\"1\":{\"1594\":1}}],[\"被注入的容器类\",{\"1\":{\"963\":1}}],[\"被唤醒的线程再次执行时可能条件又不满足了\",{\"1\":{\"1483\":1}}],[\"被阻塞的线程会被挂起\",{\"1\":{\"1483\":1}}],[\"被弱引用关联的对象只能生存到下一次垃圾收集发生为止\",{\"1\":{\"1435\":1}}],[\"被引用\",{\"1\":{\"1435\":1}}],[\"被描述的注解在它所修饰的类中可以被保留到何时\",{\"1\":{\"1133\":1}}],[\"被观察者\",{\"1\":{\"1125\":1}}],[\"被导入方就是内部\",{\"1\":{\"1020\":1}}],[\"被初始化\",{\"1\":{\"932\":1,\"933\":1}}],[\"被动提供\",{\"1\":{\"911\":1}}],[\"被\",{\"1\":{\"583\":1}}],[\"被放弃事务中命令并未执行\",{\"1\":{\"579\":1}}],[\"被session\",{\"1\":{\"446\":1}}],[\"被称为\",{\"1\":{\"446\":1}}],[\"被驱动表s2的扇出是16\",{\"1\":{\"555\":1}}],[\"被驱动表可能会被访问多次\",{\"1\":{\"554\":1}}],[\"被驱动表的连接列最好是该表的主键或者唯一二级索引列\",{\"1\":{\"555\":1}}],[\"被驱动表的关联字段没有索引为什么会选择bnl算法而不是用nlj呢\",{\"1\":{\"525\":1}}],[\"被驱动表的数据行数是m\",{\"1\":{\"403\":1}}],[\"被驱动表\",{\"1\":{\"524\":1}}],[\"被驱动表t2的字段上有索引\",{\"1\":{\"401\":1}}],[\"被驱动表tradelog上执行的就是类似这样的sql语句\",{\"1\":{\"368\":1}}],[\"被查看的次数\",{\"1\":{\"361\":1}}],[\"被直接缓存到内存中\",{\"1\":{\"319\":1}}],[\"被系统强行杀掉\",{\"1\":{\"318\":1}}],[\"之间\",{\"1\":{\"1265\":1}}],[\"之间的关系\",{\"1\":{\"596\":1}}],[\"之间的成员\",{\"1\":{\"574\":1}}],[\"之间的的成员\",{\"1\":{\"574\":1}}],[\"之所以设置了父子容器\",{\"1\":{\"1659\":1}}],[\"之所以需要第三个map才能解决循环依赖的根本原因是存在代理\",{\"1\":{\"1649\":1}}],[\"之所以需要这么设置\",{\"1\":{\"492\":1}}],[\"之所以会支持\",{\"1\":{\"1648\":1}}],[\"之所以会有这个差异\",{\"1\":{\"1622\":1}}],[\"之所以只缓存beanname\",{\"1\":{\"1648\":1}}],[\"之所以这么做的原因是\",{\"1\":{\"1618\":1}}],[\"之所以出现快照读的情况\",{\"1\":{\"541\":1}}],[\"之所以出现这个现象\",{\"1\":{\"478\":1}}],[\"之所以v2还是1\",{\"1\":{\"433\":1}}],[\"之所以要有计算10亿次的操作\",{\"1\":{\"408\":1}}],[\"之所以是12个文件\",{\"1\":{\"354\":1}}],[\"之前我们是对于分组中的元素个数进行统计\",{\"1\":{\"1613\":1}}],[\"之前我们举的例子要么是将集合转化为stream\",{\"1\":{\"1609\":1}}],[\"之前我们说springboot2\",{\"1\":{\"583\":1}}],[\"之前的字符\",{\"1\":{\"1026\":1}}],[\"之前的例子中\",{\"1\":{\"418\":1}}],[\"之前也是a的备库\",{\"1\":{\"468\":1}}],[\"之前优化器选择使用索引b\",{\"1\":{\"348\":1}}],[\"之前提交的记录都不会丢失\",{\"1\":{\"324\":1}}],[\"之前执行过的语句及其结果可能会以key\",{\"1\":{\"319\":1}}],[\"之前是不是执行过这条语句\",{\"1\":{\"319\":1}}],[\"之后进行aop的操作的时候\",{\"1\":{\"1649\":1}}],[\"之后所有的操作都只针对cell\",{\"1\":{\"1480\":1}}],[\"之后所有在表上新申请mdl读锁的请求也会被session\",{\"1\":{\"441\":1}}],[\"之后才开始执行\",{\"1\":{\"1473\":1}}],[\"之后才会调用存储引擎提供的接口真正的执行查询\",{\"1\":{\"546\":1}}],[\"之后重新执行\",{\"1\":{\"624\":1}}],[\"之后的版本中innodb\",{\"1\":{\"558\":1}}],[\"之后的版本默认值为200\",{\"1\":{\"553\":1}}],[\"之后的快照读获取的都是同一个read\",{\"1\":{\"542\":1}}],[\"之后的join语句\",{\"1\":{\"407\":1}}],[\"之后递增\",{\"1\":{\"542\":1}}],[\"之后回滚的时候只需要把这个主键值对应的记录删掉就好了\",{\"1\":{\"542\":1}}],[\"之后继续执行\",{\"1\":{\"491\":1}}],[\"之后继续找索引a的下个记录\",{\"1\":{\"404\":1}}],[\"之后按顺序执行binlog的时候\",{\"1\":{\"485\":1}}],[\"之后这个系统就由新主库a\",{\"1\":{\"468\":1}}],[\"之后就从这个事务开始\",{\"1\":{\"468\":1}}],[\"之后传给备库b\",{\"1\":{\"457\":1}}],[\"之后开发人员或者dba再通过重试命令重复这个过程\",{\"1\":{\"441\":1}}],[\"之后session\",{\"1\":{\"441\":1}}],[\"之后其它线程的更新\",{\"1\":{\"437\":1}}],[\"之后备份日志的时候\",{\"1\":{\"327\":1}}],[\"之后循环取\",{\"1\":{\"322\":1}}],[\"之后要查询再重连\",{\"1\":{\"318\":1}}],[\"之后\",{\"1\":{\"318\":1,\"492\":2,\"1485\":1}}],[\"或是注解即可完成对数据库的查询以及结果的映射封装\",{\"1\":{\"1982\":1}}],[\"或其他\",{\"1\":{\"1664\":1}}],[\"或其他类型\",{\"1\":{\"1089\":1}}],[\"或事务\",{\"1\":{\"1655\":1}}],[\"或别名获取某个bean对象\",{\"1\":{\"1636\":1}}],[\"或类型\",{\"1\":{\"1636\":1}}],[\"或服务端处理连接缓慢时\",{\"1\":{\"1573\":1}}],[\"或全部\",{\"1\":{\"1488\":1}}],[\"或zookeeper实现\",{\"1\":{\"1248\":1}}],[\"或objectprovider\",{\"1\":{\"1181\":4}}],[\"或通过beanfactory进行依赖查找和依赖注入\",{\"1\":{\"1016\":1}}],[\"或分号\",{\"1\":{\"928\":1}}],[\"或回滚\",{\"1\":{\"542\":1}}],[\"或未指定值\",{\"1\":{\"491\":1}}],[\"或简写为\",{\"1\":{\"482\":1}}],[\"或部分\",{\"1\":{\"395\":1}}],[\"或\",{\"1\":{\"350\":1}}],[\"或删掉误用的索引\",{\"1\":{\"348\":1}}],[\"或者刷了很多题目了\",{\"1\":{\"1972\":1}}],[\"或者判断某个方法上是否存在\",{\"1\":{\"1655\":1}}],[\"或者beandefinition\",{\"1\":{\"1650\":1}}],[\"或者只要一个构造方法的情况下\",{\"1\":{\"1650\":1}}],[\"或者执行一个终止操作\",{\"1\":{\"1621\":1}}],[\"或者spliterator是subsized的\",{\"1\":{\"1620\":1}}],[\"或者计算成本非常昂贵的时候\",{\"1\":{\"1620\":1}}],[\"或者对一个树\",{\"1\":{\"1620\":1}}],[\"或者对相同的元执行多次的遍历\",{\"1\":{\"1619\":1}}],[\"或者动作本身抛出了异常\",{\"1\":{\"1620\":1}}],[\"或者笫一次查询元素大小的时候绑定\",{\"1\":{\"1620\":1}}],[\"或者分割的不平衡或者效率非常低的方式\",{\"1\":{\"1620\":1}}],[\"或者parallel\",{\"1\":{\"1619\":1}}],[\"或者生成器函数\",{\"1\":{\"1619\":1}}],[\"或者foreach\",{\"1\":{\"1619\":1}}],[\"或者键映射为空\",{\"1\":{\"1618\":1}}],[\"或者数据源本身不要求有序\",{\"1\":{\"1615\":1}}],[\"或者数据库发生异常重启\",{\"1\":{\"410\":1}}],[\"或者返回一个函数作为返回值\",{\"1\":{\"1598\":1}}],[\"或者构造方法的引用来创建函数式接口的实例\",{\"1\":{\"1594\":1}}],[\"或者说只受限于本地内存的大小\",{\"1\":{\"1664\":1}}],[\"或者说\",{\"1\":{\"1610\":1}}],[\"或者说为什么需要函数式接口呢\",{\"1\":{\"1595\":1}}],[\"或者说表达式\",{\"1\":{\"1593\":1}}],[\"或者说对象的地址\",{\"1\":{\"1593\":1}}],[\"或者说是返回的map的key的类型\",{\"1\":{\"1618\":1}}],[\"或者说是一种语法糖\",{\"1\":{\"1592\":1}}],[\"或者说是否有存储的要求\",{\"1\":{\"1509\":1}}],[\"或者使用传统的for循环来遍历\",{\"1\":{\"1593\":1}}],[\"或者使用concurrenthashmap\",{\"1\":{\"1544\":1}}],[\"或者超时\",{\"1\":{\"1569\":1}}],[\"或者有except\",{\"1\":{\"1569\":1}}],[\"或者有其他考虑\",{\"1\":{\"385\":1}}],[\"或者默认值\",{\"1\":{\"1554\":1}}],[\"或者没必要执行这个操作\",{\"1\":{\"1531\":1}}],[\"或者cow\",{\"1\":{\"1527\":1}}],[\"或者是否正在扩容\",{\"1\":{\"1554\":1}}],[\"或者是队列空了无法移除元素时\",{\"1\":{\"1501\":1}}],[\"或者是不满足city=\",{\"1\":{\"356\":2}}],[\"或者提前设置一些参数\",{\"1\":{\"1354\":1}}],[\"或者由io操作\",{\"1\":{\"1328\":1}}],[\"或者设置一个相对较长的过期时间\",{\"1\":{\"1283\":1}}],[\"或者依赖\",{\"1\":{\"927\":1}}],[\"或者比2更高的一个返回值\",{\"1\":{\"624\":1}}],[\"或者更新已存在成员的分数\",{\"1\":{\"574\":1}}],[\"或者尾部\",{\"1\":{\"571\":1}}],[\"或者最好是跨城市保存\",{\"1\":{\"488\":1}}],[\"或者误操作的时间距离上一个全量备份的时间较长\",{\"1\":{\"486\":1}}],[\"或者where条件里面没有包含索引字段的话\",{\"1\":{\"484\":1}}],[\"或者找一个从库作为临时库\",{\"1\":{\"484\":1}}],[\"或者连带造成了更多的数据逻辑不一致\",{\"1\":{\"459\":1}}],[\"或者kill掉这个长事务\",{\"1\":{\"441\":1}}],[\"或者断开连接\",{\"1\":{\"435\":1}}],[\"或者\",{\"1\":{\"377\":2,\"624\":1,\"1435\":2,\"1615\":1}}],[\"或者其它原因不能执行这个ddl\",{\"1\":{\"368\":1}}],[\"或者采用反过来的顺序\",{\"1\":{\"327\":1}}],[\"或者在一个语句有多表关联\",{\"1\":{\"321\":1,\"514\":2}}],[\"或者程序里面判断执行过一个占用内存的大查询后\",{\"1\":{\"318\":1}}],[\"或偶数行参数\",{\"1\":{\"307\":1}}],[\"定时消息存储\",{\"0\":{\"1927\":1}}],[\"定时消息\",{\"0\":{\"1926\":1}}],[\"定时消息和重试消息\",{\"0\":{\"1925\":1}}],[\"定制jvm堆内存大小\",{\"1\":{\"1257\":1}}],[\"定制redistemplate的模板\",{\"1\":{\"583\":1}}],[\"定位到哈希桶数组的都是很关键的第一步\",{\"1\":{\"1548\":1}}],[\"定位到满足条件的记录\",{\"1\":{\"404\":1}}],[\"定位哈希桶索引位置时\",{\"1\":{\"1546\":1}}],[\"定位桶的位置是利用元素的key的哈希值对数组长度取模得到\",{\"1\":{\"1358\":1}}],[\"定位优化对象的性能瓶颈\",{\"1\":{\"1272\":1}}],[\"定位spring事件源\",{\"1\":{\"1116\":1}}],[\"定长字符串\",{\"1\":{\"530\":1}}],[\"定期删除会遍历每个database\",{\"1\":{\"1289\":1}}],[\"定期删除\",{\"1\":{\"1289\":1}}],[\"定期地清除大量数据时\",{\"1\":{\"393\":1}}],[\"定期断开长连接\",{\"1\":{\"318\":1}}],[\"定义额外逻辑\",{\"1\":{\"1654\":1}}],[\"定义threadlocal变量\",{\"1\":{\"1528\":1}}],[\"定义了一个内部cell类\",{\"1\":{\"1480\":1}}],[\"定义了netty的核心抽象\",{\"1\":{\"1224\":1}}],[\"定义atomicstampedreference\",{\"1\":{\"1479\":1}}],[\"定义一个具有\",{\"1\":{\"1134\":1}}],[\"定义一个类似的资源\",{\"1\":{\"918\":1}}],[\"定义好行为之后我们再去调用\",{\"1\":{\"1598\":1}}],[\"定义好的注解\",{\"1\":{\"1133\":1}}],[\"定义好了属性值\",{\"1\":{\"1003\":1}}],[\"定义xml文件\",{\"1\":{\"1032\":1}}],[\"定义xml结构\",{\"1\":{\"1030\":2}}],[\"定义yaml文件\",{\"1\":{\"1032\":1}}],[\"定义namespacehanlder\",{\"1\":{\"1030\":1}}],[\"定义beandefinitionparser实现\",{\"1\":{\"1030\":1}}],[\"定义bean的顺序也就是加载bean的顺序\",{\"1\":{\"963\":1}}],[\"定义\",{\"1\":{\"1022\":1,\"1435\":1}}],[\"定义完成之后使用myautowired进行注入\",{\"1\":{\"967\":1}}],[\"定义当前类作为spring\",{\"1\":{\"929\":1}}],[\"定义长度也是8个字节\",{\"1\":{\"497\":1}}],[\"定义允许为null\",{\"1\":{\"399\":1}}],[\"定义合理的长度\",{\"1\":{\"350\":1}}],[\"定义字段的数据类型\",{\"1\":{\"309\":1}}],[\"定义索引中的字段的名称\",{\"1\":{\"309\":1}}],[\"从linux内核角度探秘jdk\",{\"1\":{\"1965\":1}}],[\"从一个分割迭代器对象创建一个串行或者并行的流\",{\"1\":{\"1621\":1}}],[\"从jdk1\",{\"1\":{\"1619\":1}}],[\"从jdk8开始接口的概念有了一些变化\",{\"1\":{\"1345\":1}}],[\"从泛型的角度就可以清楚的认识到\",{\"1\":{\"1615\":1}}],[\"从下一章节开始\",{\"1\":{\"1613\":1}}],[\"从表现形式上而言\",{\"1\":{\"1611\":1}}],[\"从表t1里一次性地多拿些出来\",{\"1\":{\"405\":1}}],[\"从表t1中读入一行数据r\",{\"1\":{\"401\":1}}],[\"从本节开始\",{\"1\":{\"1620\":1}}],[\"从本质上来说\",{\"1\":{\"1610\":1}}],[\"从本地读取binlog\",{\"1\":{\"453\":1}}],[\"从写模式切换到读模式\",{\"1\":{\"1574\":1}}],[\"从缓冲区写入到通道中\",{\"1\":{\"1574\":1}}],[\"从kernel的角度\",{\"1\":{\"1566\":1}}],[\"从用户进程角度讲\",{\"1\":{\"1564\":1}}],[\"从结构实现来讲\",{\"1\":{\"1546\":1}}],[\"从结果来看\",{\"1\":{\"1003\":1}}],[\"从结果中可以看出\",{\"1\":{\"558\":1}}],[\"从某种程度上说\",{\"1\":{\"1518\":1}}],[\"从tail添加元素\",{\"1\":{\"1503\":1}}],[\"从同步队列转移到条件队列\",{\"1\":{\"1492\":1}}],[\"从偏向锁的加锁和解锁过程中可以看出\",{\"1\":{\"1485\":1}}],[\"从操作系统的视角来看\",{\"1\":{\"1477\":1}}],[\"从引用根对象向下一直找引用\",{\"1\":{\"1437\":1}}],[\"从引擎层来看\",{\"1\":{\"424\":1}}],[\"从设计的层面来说\",{\"1\":{\"1345\":1}}],[\"从设置了过期时间的键中选择使用频率最低的键进行删除\",{\"1\":{\"1300\":1}}],[\"从设置了过期时间的键中选择最近最少使用的键进行删除\",{\"1\":{\"1300\":1}}],[\"从设置了过期时间的键中随机选择要删除的键\",{\"1\":{\"1300\":1}}],[\"从所有的键中选择最近最少使用的键进行删除\",{\"1\":{\"1300\":1}}],[\"从锁的粒度来区分\",{\"1\":{\"1263\":1}}],[\"从内容到id\",{\"1\":{\"1252\":1}}],[\"从内存中读取一个块对应的成本\",{\"1\":{\"557\":1}}],[\"从内存临时表中一行一行地取出r值和位置信息\",{\"1\":{\"420\":1}}],[\"从id到内容\",{\"1\":{\"1252\":1}}],[\"从index1查到结果后直接就返回了\",{\"1\":{\"351\":1}}],[\"从index1索引树找到满足索引值是\",{\"1\":{\"350\":1}}],[\"从index2索引树找到满足索引值是\",{\"1\":{\"350\":1}}],[\"从应用层面考虑\",{\"1\":{\"1248\":1}}],[\"从1\",{\"1\":{\"1227\":1}}],[\"从1开始计数\",{\"1\":{\"553\":1}}],[\"从supplier\",{\"1\":{\"1615\":1}}],[\"从student这张表中查询出年龄>20并且地址=北京的记录\",{\"1\":{\"1611\":1}}],[\"从spring\",{\"1\":{\"1134\":1,\"1139\":1}}],[\"从show\",{\"1\":{\"481\":1}}],[\"从机手动执行命令slaveof\",{\"1\":{\"611\":1}}],[\"从机6380写入失败\",{\"1\":{\"611\":1}}],[\"从机6381写入失败\",{\"1\":{\"611\":1}}],[\"从机只能读\",{\"1\":{\"611\":1}}],[\"从机数量\",{\"1\":{\"609\":1}}],[\"从节点可以在以顶程度上帮助主节点分担读压力\",{\"1\":{\"621\":1}}],[\"从节点可以扩展主节点的读能力\",{\"1\":{\"621\":2}}],[\"从节点可以作为后备\",{\"1\":{\"621\":1}}],[\"从节点可以暂时替代主节点提供服务\",{\"1\":{\"607\":1}}],[\"从节点进行读操作\",{\"1\":{\"607\":1}}],[\"从节点以读为主\",{\"1\":{\"606\":1}}],[\"从节点a更新的事务\",{\"1\":{\"455\":1}}],[\"从不同步\",{\"1\":{\"593\":1}}],[\"从\",{\"1\":{\"592\":1,\"1969\":1}}],[\"从大到小\",{\"1\":{\"574\":1}}],[\"从newset中移除m3元素\",{\"1\":{\"572\":1}}],[\"从newlist中弹出第一个值\",{\"1\":{\"571\":1}}],[\"从mylist中弹出\",{\"1\":{\"571\":1}}],[\"从mysql的真正开始流行到现在\",{\"1\":{\"497\":1}}],[\"从mysql8\",{\"1\":{\"425\":1}}],[\"从mysql5\",{\"1\":{\"425\":2}}],[\"从尾部开始搜索\",{\"1\":{\"571\":2}}],[\"从头部开始搜索\",{\"1\":{\"571\":2}}],[\"从头开始写入\",{\"1\":{\"324\":1}}],[\"从最左边\",{\"1\":{\"571\":1}}],[\"从最好到最差依次是\",{\"1\":{\"330\":1}}],[\"从左边\",{\"1\":{\"571\":1}}],[\"从磁盘读取文件内容\",{\"1\":{\"1580\":1}}],[\"从磁盘上读取一个块对应的成本\",{\"1\":{\"557\":1}}],[\"从磁盘到内存这个加载的过程损耗的时间称之为io成本\",{\"1\":{\"545\":1}}],[\"从全表扫描和idx\",{\"1\":{\"555\":1}}],[\"从全表扫描和使用idx\",{\"1\":{\"555\":1}}],[\"从全表扫描到索引扫描\",{\"1\":{\"390\":1}}],[\"从上图可以得出如下结论\",{\"1\":{\"1583\":1,\"1584\":1}}],[\"从上图\",{\"1\":{\"1580\":1}}],[\"从上面的io拷贝机制中可以看出\",{\"1\":{\"1585\":1}}],[\"从上面的表格可以看出\",{\"1\":{\"557\":1}}],[\"从上面的计算过程也可以看出来\",{\"1\":{\"555\":1}}],[\"从上面的过程可以看出\",{\"1\":{\"542\":1}}],[\"从上一步分析我们可以得出\",{\"1\":{\"549\":1}}],[\"从链首到链尾\",{\"1\":{\"542\":1}}],[\"从系统启动到现在等待最长的一次所花时间\",{\"1\":{\"538\":1}}],[\"从系统启动到现在锁定总时间长度\",{\"1\":{\"538\":1}}],[\"从对数据库操作的类型分\",{\"1\":{\"533\":1}}],[\"从对数据操作的粒度分\",{\"1\":{\"533\":1}}],[\"从性能上分为乐观锁\",{\"1\":{\"533\":1}}],[\"从性能的角度考虑\",{\"1\":{\"484\":1}}],[\"从理论上将\",{\"1\":{\"496\":1}}],[\"从并发插入数据性能的角度考虑\",{\"1\":{\"492\":1}}],[\"从auto\",{\"1\":{\"491\":1}}],[\"从a的角度来看\",{\"1\":{\"433\":1}}],[\"从备份系统下载master\",{\"1\":{\"485\":1}}],[\"从备份的时候点开始\",{\"1\":{\"327\":1}}],[\"从日志备份里面\",{\"1\":{\"485\":1}}],[\"从返回包获取这个事务的gtid\",{\"1\":{\"474\":1}}],[\"从返回包直接获取这个事务的gtid\",{\"1\":{\"474\":1}}],[\"从库收到binlog以后\",{\"1\":{\"472\":1}}],[\"从库会认为已经没有同步延迟\",{\"1\":{\"472\":1}}],[\"从库b的同步线程就会出现duplicate\",{\"1\":{\"467\":1}}],[\"从库b要切换的时候\",{\"1\":{\"467\":1}}],[\"从库b\",{\"1\":{\"466\":2}}],[\"从binlog在主备之间状态的分析中\",{\"1\":{\"472\":1}}],[\"从自己的binlog文件里面\",{\"1\":{\"468\":1}}],[\"从单线程复制到最新版本的多线程复制\",{\"1\":{\"460\":1}}],[\"从状态1到状态2切换的详细过程如下\",{\"1\":{\"458\":1}}],[\"从顾客a账余额中扣除电影票价\",{\"1\":{\"443\":1}}],[\"从堆中去掉\",{\"1\":{\"421\":1}}],[\"从words表中\",{\"1\":{\"420\":1}}],[\"从explain入手\",{\"1\":{\"1272\":1}}],[\"从explain的结果来看\",{\"1\":{\"404\":1}}],[\"从explain的结果可以看到\",{\"1\":{\"390\":1}}],[\"从extra字段可以看到\",{\"1\":{\"418\":1}}],[\"从临时表按行取数据\",{\"1\":{\"414\":1}}],[\"从其它特征上看\",{\"1\":{\"409\":1}}],[\"从驱动表t1\",{\"1\":{\"405\":1}}],[\"从时间复杂度上来看\",{\"1\":{\"403\":1}}],[\"从每一行r取出字段a的值$r\",{\"1\":{\"401\":1}}],[\"从数据结构的角度分析\",{\"1\":{\"1353\":1}}],[\"从数据库方面考虑\",{\"1\":{\"1248\":1}}],[\"从数据行r中\",{\"1\":{\"401\":1}}],[\"从数据表中返回数据\",{\"1\":{\"390\":1}}],[\"从这一个层面来说\",{\"1\":{\"1607\":1}}],[\"从这个版本开始\",{\"1\":{\"1591\":1}}],[\"从这个角度来看\",{\"1\":{\"495\":1}}],[\"从这个备份恢复到临时库\",{\"1\":{\"327\":1}}],[\"从这点看\",{\"1\":{\"394\":1}}],[\"从好到坏依次为\",{\"1\":{\"390\":1}}],[\"从客户端\",{\"1\":{\"381\":1}}],[\"从索引name取出下一个满足name=\",{\"1\":{\"520\":1}}],[\"从索引name找到下一个满足name=\",{\"1\":{\"520\":1}}],[\"从索引name找到第一个满足name=\",{\"1\":{\"520\":2}}],[\"从索引\",{\"1\":{\"356\":4}}],[\"从索引city取下一个记录的主键id\",{\"1\":{\"354\":1,\"355\":1}}],[\"从索引city找到第一个满足city=\",{\"1\":{\"354\":1,\"355\":1}}],[\"从索引的示意图中可以看出\",{\"1\":{\"354\":1}}],[\"从查询效率上看\",{\"1\":{\"352\":1}}],[\"从查询条件来看\",{\"1\":{\"347\":1}}],[\"从占用的额外空间来看\",{\"1\":{\"352\":1}}],[\"从分析的结果来看\",{\"1\":{\"346\":1}}],[\"从而允许进行适当的资源清理\",{\"1\":{\"1657\":1}}],[\"从而可以进行排序\",{\"1\":{\"1641\":1}}],[\"从而实现收集器的映射\",{\"1\":{\"1618\":1}}],[\"从而实现真正的高可用\",{\"1\":{\"621\":1}}],[\"从而使开发人员不再需要定义样板化的配置\",{\"1\":{\"1983\":1}}],[\"从而使java具有动态语言的特性\",{\"1\":{\"1558\":1}}],[\"从而使父子进程拥有各自的地址空间\",{\"1\":{\"1527\":1}}],[\"从而提高了b的执行效率\",{\"1\":{\"1531\":1}}],[\"从而提升排序效率\",{\"1\":{\"520\":1}}],[\"从而去选择合适的blockingqueue\",{\"1\":{\"1509\":1}}],[\"从而启动后继任务的开始\",{\"1\":{\"1477\":1}}],[\"从而消除了锁的使用流程\",{\"1\":{\"1393\":1}}],[\"从而预防安全问题\",{\"1\":{\"1342\":1}}],[\"从而降低整个系统的复杂度\",{\"1\":{\"1304\":1}}],[\"从而保证了事物中的所有命令被原子的执行\",{\"1\":{\"1297\":1}}],[\"从而保证整个集群的正常工作\",{\"1\":{\"488\":1}}],[\"从而监控运行的多个redis实例\",{\"1\":{\"1291\":1}}],[\"从而控制用户访问系统的行为\",{\"1\":{\"1199\":1}}],[\"从而冻结注册\",{\"1\":{\"981\":1}}],[\"从而造成rc\",{\"1\":{\"542\":1}}],[\"从而影响性能\",{\"1\":{\"505\":1}}],[\"从而删掉过期的历史数据\",{\"1\":{\"426\":1}}],[\"从而导致了索引失效\",{\"1\":{\"367\":1}}],[\"从而导致执行速度变得很慢\",{\"1\":{\"346\":1}}],[\"从而知道mysql是如何处理sql语句的\",{\"1\":{\"329\":1}}],[\"从图中的结果可以看到\",{\"1\":{\"454\":1}}],[\"从图中可以看到\",{\"1\":{\"345\":1,\"350\":1,\"451\":1}}],[\"从图中不难看出\",{\"1\":{\"317\":1,\"335\":1}}],[\"从union表获取结果的select\",{\"1\":{\"330\":1}}],[\"从现象看就是mysql异常重启了\",{\"1\":{\"318\":1}}],[\"默认8表示一个survivor区占用1\",{\"1\":{\"1664\":1}}],[\"默认物理内存的1\",{\"1\":{\"1664\":1}}],[\"默认会有一个\",{\"1\":{\"1647\":1}}],[\"默认会添加一个annotationtypefilter给includefilters\",{\"1\":{\"1645\":1}}],[\"默认会采用系统变量innodb\",{\"1\":{\"558\":1}}],[\"默认方法\",{\"0\":{\"1607\":1}}],[\"默认超过8\",{\"1\":{\"1546\":1}}],[\"默认线程池是forkjoinpool\",{\"1\":{\"1518\":1}}],[\"默认偏向锁批量撤销阈值\",{\"1\":{\"1485\":1}}],[\"默认偏向锁批量重偏向阈值\",{\"1\":{\"1485\":1}}],[\"默认40\",{\"1\":{\"1485\":1}}],[\"默认20\",{\"1\":{\"1485\":2}}],[\"默认26379\",{\"1\":{\"624\":1}}],[\"默认就是最大年龄是15\",{\"1\":{\"1436\":1}}],[\"默认就是线程不安全的\",{\"1\":{\"1236\":1}}],[\"默认不再提供无参的构造方法\",{\"1\":{\"1346\":1}}],[\"默认有一个不带参数的构造方法\",{\"1\":{\"1346\":1}}],[\"默认策略\",{\"1\":{\"1300\":1,\"1483\":1}}],[\"默认16个\",{\"1\":{\"1289\":1}}],[\"默认1024字节\",{\"1\":{\"520\":1}}],[\"默认传播行为\",{\"1\":{\"1238\":1}}],[\"默认打开一级缓存\",{\"1\":{\"1218\":1}}],[\"默认只支持properties格式的文件\",{\"1\":{\"1155\":1}}],[\"默认实现类为simplemetadatareader\",{\"1\":{\"1646\":1}}],[\"默认实现\",{\"1\":{\"1151\":1,\"1152\":1}}],[\"默认实现的核心代码\",{\"1\":{\"928\":1}}],[\"默认模式\",{\"1\":{\"1123\":2}}],[\"默认内建时间\",{\"1\":{\"1093\":1}}],[\"默认内建实现\",{\"1\":{\"1055\":1}}],[\"默认通过iso\",{\"1\":{\"1022\":1}}],[\"默认通用beannamegenerator实现\",{\"1\":{\"928\":1}}],[\"默认直\",{\"1\":{\"1020\":1}}],[\"默认生成bean的名称的部分代码\",{\"1\":{\"995\":1}}],[\"默认spring\",{\"1\":{\"983\":1,\"1020\":3,\"1235\":1}}],[\"默认的实现是不断的调用tryadvance方法直到返回false\",{\"1\":{\"1620\":1}}],[\"默认的实现会从集合的迭代器创建一个延迟绑定的分割迭代器\",{\"1\":{\"1620\":1}}],[\"默认的实现应该要被子类所重写\",{\"1\":{\"1620\":1}}],[\"默认的实现类为defaultlistablebeanfactory\",{\"1\":{\"921\":1}}],[\"默认的负载因子0\",{\"1\":{\"1546\":1}}],[\"默认的profiles\",{\"1\":{\"1139\":1}}],[\"默认的scop就是\",{\"1\":{\"985\":2}}],[\"默认的n是8\",{\"1\":{\"347\":1}}],[\"默认的n是20\",{\"1\":{\"347\":1}}],[\"默认\",{\"1\":{\"646\":1,\"1072\":3,\"1498\":1}}],[\"默认三分钟\",{\"1\":{\"624\":1}}],[\"默认30秒\",{\"1\":{\"624\":1}}],[\"默认它们是阻塞的\",{\"1\":{\"602\":1}}],[\"默认以米作为单位\",{\"1\":{\"576\":1}}],[\"默认使用的是pollselectorprovider\",{\"1\":{\"1423\":1}}],[\"默认使用的就是innodb\",{\"1\":{\"317\":1}}],[\"默认使用db\",{\"1\":{\"567\":1}}],[\"默认页大小是16kb\",{\"1\":{\"503\":1}}],[\"默认值2代表新生代占老年代的1\",{\"1\":{\"1664\":1}}],[\"默认值为\",{\"1\":{\"1184\":1}}],[\"默认值\",{\"1\":{\"557\":2,\"952\":1,\"1072\":3}}],[\"默认值都是1\",{\"1\":{\"491\":1}}],[\"默认值是16\",{\"1\":{\"1402\":1}}],[\"默认值是16m\",{\"1\":{\"421\":1}}],[\"默认值是1\",{\"1\":{\"492\":1}}],[\"默认值是256k\",{\"1\":{\"403\":1,\"525\":1}}],[\"默认值是8小时\",{\"1\":{\"318\":1}}],[\"默认开启\",{\"1\":{\"444\":1}}],[\"默认是21m左右\",{\"1\":{\"1664\":1}}],[\"默认是20个\",{\"1\":{\"1289\":1}}],[\"默认是\",{\"1\":{\"1664\":1}}],[\"默认是物理内存的1\",{\"1\":{\"1664\":1}}],[\"默认是app\",{\"1\":{\"1647\":1}}],[\"默认是引用类型\",{\"1\":{\"1623\":1}}],[\"默认是按键值的升序排列\",{\"1\":{\"1544\":1}}],[\"默认是lru\",{\"1\":{\"645\":1}}],[\"默认是使用rdb方式持久化的\",{\"1\":{\"592\":1}}],[\"默认是不开启aof模式的\",{\"1\":{\"592\":1}}],[\"默认是以4096字节作为一个块的\",{\"1\":{\"557\":1}}],[\"默认是关闭的\",{\"1\":{\"431\":1}}],[\"默认是10秒\",{\"1\":{\"428\":1}}],[\"默认是16m\",{\"1\":{\"416\":1}}],[\"默认情况下不做任何修改\",{\"1\":{\"1003\":1}}],[\"默认情况下从机的角色不会发生变化\",{\"1\":{\"611\":1}}],[\"默认情况下long\",{\"1\":{\"428\":1}}],[\"默认情况下\",{\"1\":{\"428\":1,\"431\":1,\"586\":1,\"606\":1,\"610\":1,\"611\":1,\"1503\":1,\"1511\":1,\"1650\":1,\"1652\":1}}],[\"即先学会用这个技术\",{\"1\":{\"1993\":1}}],[\"即先遇到的先遍历\",{\"1\":{\"1623\":1}}],[\"即1\",{\"1\":{\"1664\":1}}],[\"即渲染视图后\",{\"1\":{\"1657\":1}}],[\"即按照around\",{\"1\":{\"1654\":1}}],[\"即不限制\",{\"1\":{\"1664\":1}}],[\"即不是通过链式调用\",{\"1\":{\"1621\":1}}],[\"即不同存储引擎的索引的工作方式并不一样\",{\"1\":{\"334\":1}}],[\"即只关心偶书位置上的数据\",{\"1\":{\"1620\":1}}],[\"即只有一个入口\",{\"1\":{\"1528\":1}}],[\"即只有一个线程能对cells初始化\",{\"1\":{\"1480\":1}}],[\"即执行的结果与执行的顺序是无关的\",{\"1\":{\"1619\":1}}],[\"即采用传统的方式来进行一些流的操作\",{\"1\":{\"1619\":1}}],[\"即map\",{\"1\":{\"1618\":1}}],[\"即mvcc\",{\"1\":{\"541\":1}}],[\"即流中的每一个元素的类型\",{\"1\":{\"1615\":1}}],[\"即identity\",{\"1\":{\"1615\":1}}],[\"即id在\",{\"1\":{\"536\":1}}],[\"即compare\",{\"1\":{\"1614\":1}}],[\"即对象引用\",{\"1\":{\"1600\":1}}],[\"即对象指向它的类元数据的指针\",{\"1\":{\"1484\":1}}],[\"即直接内存访问\",{\"1\":{\"1578\":1}}],[\"即网卡\",{\"1\":{\"1576\":1}}],[\"即会引起死循环\",{\"1\":{\"1551\":1}}],[\"即当键值对的实际大小size大于table的实际大小时进行扩容\",{\"1\":{\"1550\":1}}],[\"即当前事务id\",{\"1\":{\"542\":1}}],[\"即数组加链表的方式\",{\"1\":{\"1546\":1}}],[\"即任一时刻可以有多个线程同时写hashmap\",{\"1\":{\"1544\":1}}],[\"即守护\",{\"1\":{\"1530\":1}}],[\"即记过按照完成先后顺序排序\",{\"1\":{\"1517\":1}}],[\"即table\",{\"1\":{\"1549\":1}}],[\"即takeindex++\",{\"1\":{\"1502\":1}}],[\"即t2\",{\"1\":{\"457\":1}}],[\"即遵循锁降级的步骤\",{\"1\":{\"1498\":1}}],[\"即锁粗化\",{\"1\":{\"1486\":1}}],[\"即这时候线持有锁的线程已经退出了同步块\",{\"1\":{\"1485\":1}}],[\"即函数最终返回的值是原先的compare\",{\"1\":{\"1479\":1}}],[\"即一个变量如何才主内存拷贝到工作内存\",{\"1\":{\"1473\":1}}],[\"即一个线程如何和何时可以看到由其他线程修改过后的共享变量的值\",{\"1\":{\"1473\":1}}],[\"即一个引用变量到底会指向哪个类的实例对象\",{\"1\":{\"1340\":1}}],[\"即通常所说的native方法\",{\"1\":{\"1438\":1}}],[\"即便uservice类上没有\",{\"1\":{\"1645\":1}}],[\"即便它上面有\",{\"1\":{\"1645\":1}}],[\"即便不是精确的知道待遍历元素的数量\",{\"1\":{\"1620\":1}}],[\"即便我们使用的不是终止操作\",{\"1\":{\"1610\":1}}],[\"即便我们没有给他加上\",{\"1\":{\"1594\":1}}],[\"即便有5秒钟延迟\",{\"1\":{\"1527\":1}}],[\"即便有上面两条规则的限制\",{\"1\":{\"556\":1}}],[\"即便是使用volatile修饰\",{\"1\":{\"1385\":1}}],[\"即我们无需关心该序列的底层结构是什么样子的\",{\"1\":{\"1353\":1}}],[\"即子类可以对父类进行扩展\",{\"1\":{\"1340\":1}}],[\"即消息队列消息\",{\"1\":{\"1326\":1}}],[\"即applicationcontextawareprocessor\",{\"1\":{\"1015\":1}}],[\"即旧的slave\",{\"1\":{\"624\":1}}],[\"即远程字典服务\",{\"1\":{\"564\":1}}],[\"即索引列平均一个值重复多少次\",{\"1\":{\"555\":1}}],[\"即rr级别下\",{\"1\":{\"542\":1}}],[\"即readonly=true\",{\"1\":{\"458\":1}}],[\"即创建快照时\",{\"1\":{\"542\":2}}],[\"即从最近的一次修改查起\",{\"1\":{\"542\":1}}],[\"即遍历链表的db\",{\"1\":{\"542\":1}}],[\"即链接\",{\"1\":{\"542\":1}}],[\"即在读写数据的过程中会阻塞\",{\"1\":{\"1563\":1}}],[\"即在第一次append方法时进行加锁\",{\"1\":{\"1486\":1}}],[\"即在undo\",{\"1\":{\"542\":1}}],[\"即在主库上同一个线程先后执行的两个事务\",{\"1\":{\"465\":1}}],[\"即无索引行锁会升级为表锁\",{\"1\":{\"537\":1}}],[\"即小的数据集驱动大的数据集\",{\"1\":{\"525\":1}}],[\"即语句执行结束后才释放锁\",{\"1\":{\"492\":1}}],[\"即由于主从可能存在延迟\",{\"1\":{\"469\":1}}],[\"即可能是当前最新的数据\",{\"1\":{\"542\":1}}],[\"即可\",{\"1\":{\"468\":1}}],[\"即主动死锁检测\",{\"1\":{\"444\":1}}],[\"即主键查询方式\",{\"1\":{\"335\":1}}],[\"即原子性\",{\"1\":{\"432\":1}}],[\"即name和id\",{\"1\":{\"355\":1}}],[\"即name字段\",{\"1\":{\"355\":1}}],[\"即使没有学过这些技术\",{\"1\":{\"1987\":1}}],[\"即使没有出现线程竞争\",{\"1\":{\"1486\":1}}],[\"即使它们的类名相同\",{\"1\":{\"1693\":1}}],[\"即使负载因子和哈希算法设计的再合理\",{\"1\":{\"1546\":1}}],[\"即使再好的哈希算法也会出现较多碰撞\",{\"1\":{\"1546\":1}}],[\"即使较差的哈希算法也会比较分散\",{\"1\":{\"1546\":1}}],[\"即使100万qps的处理速度\",{\"1\":{\"1519\":1}}],[\"即使类已经不再使用\",{\"1\":{\"1457\":1}}],[\"即使还存在跨代引用\",{\"1\":{\"1434\":1}}],[\"即使对空值设置了过期时间\",{\"1\":{\"627\":1}}],[\"即使过了这个超时\",{\"1\":{\"624\":1}}],[\"即使只是执行一个普通的select语句\",{\"1\":{\"497\":1}}],[\"即使innodb\",{\"1\":{\"492\":1}}],[\"即使我们配置了binlog\",{\"1\":{\"485\":1}}],[\"即使是dba团队成员\",{\"1\":{\"487\":1}}],[\"即使是客户端退出了\",{\"1\":{\"481\":1}}],[\"即使是一个千兆网卡也能轻松满足每秒超过2000次的查询\",{\"1\":{\"392\":1}}],[\"即使把所有的记录都加上锁\",{\"1\":{\"447\":1}}],[\"即使长事务最终提交\",{\"1\":{\"434\":1}}],[\"即使开了多线程复制\",{\"1\":{\"413\":1}}],[\"即使redis正常工作\",{\"1\":{\"397\":1}}],[\"即使在一个通用服务器上\",{\"1\":{\"392\":1}}],[\"即使库表结构再合理\",{\"1\":{\"381\":1}}],[\"即使不改变有序性\",{\"1\":{\"366\":1}}],[\"即使name字段的定义是varchar\",{\"1\":{\"354\":1}}],[\"即使将index2的定义修改为email\",{\"1\":{\"351\":1}}],[\"即使你使用管理员账号对这个用户的权限做了修改\",{\"1\":{\"318\":1}}],[\"即整个email字符串的索引结构\",{\"1\":{\"351\":1}}],[\"即满足前缀\",{\"1\":{\"350\":1}}],[\"即email\",{\"1\":{\"350\":1,\"351\":1}}],[\"即email整个字符串的索引结构\",{\"1\":{\"350\":1}}],[\"即\",{\"1\":{\"350\":1,\"406\":1,\"447\":1,\"448\":1,\"455\":1,\"472\":1,\"481\":1,\"542\":1,\"1133\":1,\"1979\":1}}],[\"即普通索引查询方式\",{\"1\":{\"335\":1}}],[\"即key应该是\",{\"1\":{\"462\":1}}],[\"即key\",{\"1\":{\"330\":1}}],[\"即关系型数据库的表\",{\"1\":{\"309\":1}}],[\"你需要做的就是过遍数\",{\"1\":{\"1972\":1}}],[\"你就不应该再去调用accept方法\",{\"1\":{\"1623\":1}}],[\"你就会收到一个\",{\"1\":{\"318\":1}}],[\"你只需要\",{\"1\":{\"1618\":1}}],[\"你也可以按照代码随想录整理的路线刷题\",{\"1\":{\"1972\":1}}],[\"你也可以\",{\"1\":{\"1617\":1}}],[\"你还可以这么做\",{\"1\":{\"1614\":1}}],[\"你好\",{\"1\":{\"1609\":1}}],[\"你偏好构造器注入还是setter注入\",{\"0\":{\"970\":1}}],[\"你应该同时使用两种持久化功能\",{\"1\":{\"596\":1}}],[\"你可以使用collectors中的静态方法\",{\"1\":{\"1615\":1}}],[\"你可以添加一个元素到列表的头部\",{\"1\":{\"571\":1}}],[\"你可能会说\",{\"1\":{\"1612\":1}}],[\"你可能会发现\",{\"1\":{\"318\":1}}],[\"你可能很疑惑\",{\"1\":{\"1593\":1}}],[\"你存了什么\",{\"1\":{\"529\":1}}],[\"你不会在show\",{\"1\":{\"498\":1}}],[\"你要做的就是在这个节点上把数据恢复回来\",{\"1\":{\"488\":1}}],[\"你的sql语句的条件是\",{\"1\":{\"339\":1}}],[\"你了解分代理论吗\",{\"0\":{\"103\":1,\"1434\":1}}],[\"但只要按部就班\",{\"1\":{\"1993\":1}}],[\"但只能实现一个抽象类\",{\"1\":{\"1345\":1}}],[\"但因为循环依赖的存在\",{\"1\":{\"1649\":1}}],[\"但存在一些属性是不同的\",{\"1\":{\"1621\":1}}],[\"但还没有被部分遍历\",{\"1\":{\"1620\":1}}],[\"但还是持有mdl读锁的\",{\"1\":{\"481\":1}}],[\"但还是查不到trx3的\",{\"1\":{\"472\":1}}],[\"但还是没有达到\",{\"1\":{\"472\":1}}],[\"但更多的时候无法达到理想状态\",{\"1\":{\"1620\":1}}],[\"但spliterator只需要通过一个方法tryadvance\",{\"1\":{\"1620\":1}}],[\"但select\",{\"1\":{\"1568\":1}}],[\"但需要注意的是\",{\"1\":{\"1617\":1}}],[\"但需要复杂的逻辑处理\",{\"1\":{\"1518\":1}}],[\"但ide却会提示\",{\"1\":{\"1614\":1}}],[\"但innodb并没有做相关的优化\",{\"1\":{\"399\":1}}],[\"但innodb还是要回到id索引再查一下\",{\"1\":{\"351\":1}}],[\"但程序并没有停止\",{\"1\":{\"1610\":1}}],[\"但总有种纸上谈兵的感觉\",{\"1\":{\"1607\":1}}],[\"但我们使用\",{\"1\":{\"1655\":1}}],[\"但我们还是非常振奋\",{\"1\":{\"1607\":1}}],[\"但我们并没有对该接口声明functionalinterface注解\",{\"1\":{\"1594\":1}}],[\"但tostring\",{\"1\":{\"1594\":1}}],[\"但其实在调用这些方法的时候并没有先后的顺序\",{\"1\":{\"1612\":1}}],[\"但其实每次打印的stream对象都是不同的\",{\"1\":{\"1610\":1}}],[\"但其实这里的foreach\",{\"1\":{\"1593\":1}}],[\"但其过程比较复杂\",{\"1\":{\"554\":1}}],[\"但却不得不编写很多没有实际意义的代码\",{\"1\":{\"1591\":1}}],[\"但优势同样明显\",{\"1\":{\"1574\":1}}],[\"但性能可能性存在巨大瓶颈\",{\"1\":{\"1572\":1}}],[\"但作为已经废弃的类\",{\"1\":{\"1555\":1}}],[\"但从上图可以看出\",{\"1\":{\"1550\":1}}],[\"但高并发场景下性能最差\",{\"1\":{\"1520\":1}}],[\"但future没有提供这样的能力\",{\"1\":{\"1516\":1}}],[\"但locksupport可以解决这两个问题\",{\"1\":{\"1477\":1}}],[\"但使用更少的带宽\",{\"1\":{\"1474\":1}}],[\"但多个进程指令会被快速的轮换执行\",{\"1\":{\"1470\":1}}],[\"但会堆积碎片\",{\"1\":{\"1439\":1}}],[\"但非必须的对象\",{\"1\":{\"1435\":1}}],[\"但接口本身可以多继承\",{\"1\":{\"1345\":1}}],[\"但可以重载\",{\"1\":{\"1338\":1}}],[\"但当树过高时\",{\"1\":{\"1265\":1}}],[\"但内部的beanfactory是采用组合的方式进行的实现\",{\"1\":{\"921\":1}}],[\"但每个从节点只能由一个主节点\",{\"1\":{\"606\":1}}],[\"但每个客户端在和服务端建立连接的时候\",{\"1\":{\"482\":1}}],[\"但自己读取消息的速度却不够快的话\",{\"1\":{\"600\":1}}],[\"但并不推荐这种方式\",{\"1\":{\"596\":1}}],[\"但并不是在所有的场景下\",{\"1\":{\"1593\":1}}],[\"但并不是不需要了就立刻释放\",{\"1\":{\"443\":1}}],[\"但并不是所有的存储引擎都支持一致性读的隔离级别\",{\"1\":{\"438\":1}}],[\"但并不是所有的引擎都支持事务\",{\"1\":{\"432\":1}}],[\"但仍然可以承受数分钟以内的数据丢失\",{\"1\":{\"596\":1}}],[\"但分数\",{\"1\":{\"574\":1}}],[\"但它们还是有区别的\",{\"1\":{\"1482\":1}}],[\"但它们大致反映了mysql在内部执行查询时需要访问多少数据\",{\"1\":{\"387\":1}}],[\"但它并不能保证原子性\",{\"1\":{\"1385\":1}}],[\"但它以毫秒为单位设置\",{\"1\":{\"570\":1}}],[\"但付出的代价也就越大\",{\"1\":{\"532\":1}}],[\"但事务a出现了唯一键冲突\",{\"1\":{\"491\":1}}],[\"但也能避免原生rpc带来的问题\",{\"1\":{\"1306\":1}}],[\"但也没有将自增值再该回去\",{\"1\":{\"491\":1}}],[\"但也不是说增加索引就能让扫描的行数等于返回的行数\",{\"1\":{\"390\":1}}],[\"但业务设计不应该依赖于自增主键的连续性\",{\"1\":{\"489\":1}}],[\"但由于过于灵活\",{\"1\":{\"1647\":1}}],[\"但由于tostring\",{\"1\":{\"1595\":1}}],[\"但由于这个工作是自动的\",{\"1\":{\"468\":1}}],[\"但由于1000这个值已经存在于临时表了\",{\"1\":{\"414\":1}}],[\"但现在的情况比较严重\",{\"1\":{\"459\":1}}],[\"但readonly对超级\",{\"1\":{\"453\":1}}],[\"但没有丢失数据的风险\",{\"1\":{\"451\":1}}],[\"但累积n个事务才fsync\",{\"1\":{\"450\":1}}],[\"但\",{\"1\":{\"448\":1,\"497\":1}}],[\"但间隙锁不一样\",{\"1\":{\"448\":1}}],[\"但如果一个select\",{\"1\":{\"492\":1}}],[\"但如果它在真正地执行查询\",{\"1\":{\"476\":1}}],[\"但如果是查询落到其他从库上\",{\"1\":{\"472\":1}}],[\"但如果表t1执行完成的瞬间\",{\"1\":{\"460\":1}}],[\"但如果使用的是索引t\",{\"1\":{\"454\":1}}],[\"但如果只有单线程压测\",{\"1\":{\"451\":1}}],[\"但如果要变更的表是一个热点表\",{\"1\":{\"441\":1}}],[\"但如果排序数据量太大\",{\"1\":{\"354\":1}}],[\"但语句却无法执行\",{\"1\":{\"425\":1}}],[\"但在\",{\"1\":{\"1657\":2}}],[\"但在底层实现上是完全不同的\",{\"1\":{\"1612\":1}}],[\"但在起名字的时候\",{\"1\":{\"1595\":1}}],[\"但在java中\",{\"1\":{\"1593\":1}}],[\"但在微观上并不是同时执行的\",{\"1\":{\"1470\":1}}],[\"但在执行drop\",{\"1\":{\"413\":1}}],[\"但在性能上有所差别\",{\"1\":{\"341\":1}}],[\"但mysql的优化器和执行器并不支持哈希join\",{\"1\":{\"408\":1}}],[\"但即使这样\",{\"1\":{\"397\":1}}],[\"但拿到的结果却不同\",{\"1\":{\"396\":1}}],[\"但随着系统中记录数的不断增多\",{\"1\":{\"395\":1}}],[\"但无需再回表查询记录\",{\"1\":{\"390\":1}}],[\"但实际生产上使用比较多的是双m结构\",{\"1\":{\"455\":1}}],[\"但实际上\",{\"1\":{\"422\":1,\"457\":1}}],[\"但实际上并没有这么简单\",{\"1\":{\"346\":1}}],[\"但实际情况中这种\",{\"1\":{\"389\":1}}],[\"但不是一个bean的情况\",{\"1\":{\"1647\":1}}],[\"但不移除\",{\"1\":{\"1500\":2}}],[\"但不能用void声明构造方法\",{\"1\":{\"1346\":1}}],[\"但不能解决更新丢失问题\",{\"1\":{\"541\":1}}],[\"但不能忘记这样做的代价是什么\",{\"1\":{\"385\":1}}],[\"但不论是哪一种\",{\"1\":{\"492\":1}}],[\"但不保证是连续的\",{\"1\":{\"491\":1}}],[\"但不取值\",{\"1\":{\"399\":1}}],[\"但不一定被查询实际使用\",{\"1\":{\"330\":1}}],[\"但有时候也可能是访问了太多的列\",{\"1\":{\"381\":1}}],[\"但同时\",{\"1\":{\"350\":1,\"447\":1}}],[\"但这种描述方式不能满足所有的场景\",{\"1\":{\"1435\":1}}],[\"但这种方法并不完美\",{\"1\":{\"348\":1}}],[\"但这几个操作\",{\"1\":{\"482\":1}}],[\"但这两种操作都很复杂\",{\"1\":{\"468\":1}}],[\"但这并不常见\",{\"1\":{\"381\":1}}],[\"但这些还不够\",{\"1\":{\"381\":1}}],[\"但这个时候已经别无选择了\",{\"1\":{\"459\":1}}],[\"但这个时候\",{\"1\":{\"355\":1}}],[\"但这个算法有一个问题\",{\"1\":{\"355\":1}}],[\"但这样可能会导致你的密码泄露\",{\"1\":{\"318\":1}}],[\"但之后由于马上要访问这个数据页\",{\"1\":{\"344\":1}}],[\"但缺点是\",{\"1\":{\"332\":1}}],[\"但是要解决些复杂的业务场景\",{\"1\":{\"1984\":1}}],[\"但是要删除一个小表的全部数据\",{\"1\":{\"484\":1}}],[\"但是希望spring自动找该构造方法的入参值\",{\"1\":{\"1650\":1}}],[\"但是排除userservice类\",{\"1\":{\"1645\":1}}],[\"但是必须要随着trysplit方法的调用次数不断减少\",{\"1\":{\"1620\":1}}],[\"但是后面的关闭处理器依然得到了执行\",{\"1\":{\"1619\":1}}],[\"但是后面的指令依旧正常执行成功了\",{\"1\":{\"580\":1}}],[\"但是几乎所有的流实例在使用完成之后都不需要关闭\",{\"1\":{\"1619\":1}}],[\"但是jdk8对它做了一定程度的增强\",{\"1\":{\"1614\":1}}],[\"但是运行之后控制台的输出却不是我们想要的结果\",{\"1\":{\"1610\":1}}],[\"但是使用lambda表达式\",{\"1\":{\"1598\":1}}],[\"但是使用这种方式\",{\"1\":{\"985\":1}}],[\"但是总的来说还是只有一个抽象方法\",{\"1\":{\"1594\":1}}],[\"但是总共执行了101条语句\",{\"1\":{\"401\":1}}],[\"但是两者的实现有着本质的区别\",{\"1\":{\"1593\":1}}],[\"但是我们无法将函数作为参数传递给一个方法\",{\"1\":{\"1593\":1}}],[\"但是我们看到的结果是\",{\"1\":{\"424\":1}}],[\"但是很多人在使用java8的时候\",{\"1\":{\"1591\":1}}],[\"但是读取大文件\",{\"1\":{\"1587\":1}}],[\"但是数量过大后性能也会下降\",{\"1\":{\"1570\":1}}],[\"但是用户进程会被select函数阻塞\",{\"1\":{\"1565\":1}}],[\"但是文件描述符这一概念往往只适用于unix\",{\"1\":{\"1561\":1}}],[\"但是会发生数据被覆盖的情况\",{\"1\":{\"1551\":1}}],[\"但是会将连接恢复到刚刚创建完成时的状态\",{\"1\":{\"318\":1}}],[\"但是某个key对应的value值被覆盖步属于结构变化\",{\"1\":{\"1546\":1}}],[\"但是某些操作序列可能需要外部同步\",{\"1\":{\"1391\":1}}],[\"但是遍历顺序却是不确定的\",{\"1\":{\"1544\":1}}],[\"但是类bar并不是线程安全的\",{\"1\":{\"1526\":1}}],[\"但是依然可以通过setage\",{\"1\":{\"1526\":1}}],[\"但是依然建议将节点b\",{\"1\":{\"453\":1}}],[\"但是采用数组实现引发另外一个问题false\",{\"1\":{\"1519\":1}}],[\"但是调用线程和持有锁的线程是同一个\",{\"1\":{\"1498\":1}}],[\"但是append方法中的stringbuffer属于一个局部变量\",{\"1\":{\"1487\":1}}],[\"但是还是存在一些缺陷的\",{\"1\":{\"1479\":1}}],[\"但是还没有传到从库中\",{\"1\":{\"472\":1}}],[\"但是成员变量还没有完全标记完\",{\"1\":{\"1442\":1}}],[\"但是client端会认为连接失败\",{\"1\":{\"1420\":1}}],[\"但是二叉查找树在特殊情况下会变成一条线性结构\",{\"1\":{\"1361\":1}}],[\"但是新增节点的效率变慢了\",{\"1\":{\"1360\":1}}],[\"但是新插入记录这个动作\",{\"1\":{\"448\":1}}],[\"但是父类中的私有属性和方法子类是无法访问的\",{\"1\":{\"1340\":1}}],[\"但是效率会降低\",{\"1\":{\"1328\":1}}],[\"但是需要对于中间结果容器做一些处理才返回结果\",{\"1\":{\"1617\":1}}],[\"但是需要操作系统支持\",{\"1\":{\"1421\":1}}],[\"但是需要注意的是\",{\"1\":{\"1598\":1}}],[\"但是需要注意\",{\"1\":{\"1283\":1}}],[\"但是需要再回到原表去取数据\",{\"1\":{\"356\":1}}],[\"但是自增序列不会回滚\",{\"1\":{\"1263\":1}}],[\"但是只读不能修改\",{\"1\":{\"1263\":1}}],[\"但是只是在页面上显示前面10条\",{\"1\":{\"383\":1}}],[\"但是加锁的资源开销比较大\",{\"1\":{\"1263\":1}}],[\"但是可以重用一个空的\",{\"1\":{\"1620\":1}}],[\"但是可以通过正确使用同步而在并发环境中安全地使用\",{\"1\":{\"1391\":1}}],[\"但是可以通过调整查询的顺序\",{\"1\":{\"404\":1}}],[\"但是可以引用无状态的service和dao\",{\"1\":{\"1240\":1}}],[\"但是声明式事务只能针对方法级别\",{\"1\":{\"1238\":1}}],[\"但是一般不要使用二级缓存\",{\"1\":{\"1219\":1}}],[\"但是一个系统不可能无限制的备份日志\",{\"1\":{\"485\":1}}],[\"但是第二部分的回调接口无法通过beanfacotry的方式得到回调\",{\"1\":{\"1005\":1}}],[\"但是属性赋值还没进行\",{\"1\":{\"1002\":1}}],[\"但是销毁方法只有单例的bean才会调用\",{\"1\":{\"985\":1}}],[\"但是参数过多时会影响代码的整洁性\",{\"1\":{\"912\":1}}],[\"但是dubbo协议一旦涉及到跨rpc框架\",{\"1\":{\"637\":1}}],[\"但是delete全表是很慢的\",{\"1\":{\"484\":1}}],[\"但是当有其他线程尝试获取锁时\",{\"1\":{\"1485\":1}}],[\"但是当redis内存空间满的时候也会清理部分数据\",{\"1\":{\"630\":1}}],[\"但是当comments\",{\"1\":{\"361\":1}}],[\"但是其他的key依然可以使用缓存响应\",{\"1\":{\"629\":1}}],[\"但是就不按parallel\",{\"1\":{\"624\":1}}],[\"但是就被更新操作清空掉了\",{\"1\":{\"319\":1}}],[\"但是主从复制也带来了以下问题\",{\"1\":{\"621\":1}}],[\"但是本质上都是差不多的\",{\"1\":{\"603\":1}}],[\"但是required属性为true\",{\"1\":{\"1648\":1}}],[\"但是reentrantlock可以通过reentrantlock\",{\"1\":{\"1495\":1}}],[\"但是redis事务不能保证原子性\",{\"1\":{\"578\":1,\"580\":1}}],[\"但是rows显示有10354条记录\",{\"1\":{\"548\":1}}],[\"但是统计耗时特别少\",{\"1\":{\"558\":1}}],[\"但是统计耗时也就最久\",{\"1\":{\"558\":1}}],[\"但是分析多个表不同连接顺序成本花费的时间还是会很长\",{\"1\":{\"556\":1}}],[\"但是分组之前必定排序\",{\"1\":{\"378\":1}}],[\"但是消耗的时间也就越长\",{\"1\":{\"556\":1}}],[\"但是有不同的目标\",{\"1\":{\"1619\":1}}],[\"但是有的阻塞队列是有界的\",{\"1\":{\"1501\":1}}],[\"但是有的时候扇出值的计算就变得很棘手\",{\"1\":{\"554\":1}}],[\"但是有可能丢消息\",{\"1\":{\"1328\":1}}],[\"但是有丢消息的风险\",{\"1\":{\"1328\":1}}],[\"但是有时候时候\",{\"1\":{\"392\":1}}],[\"但是却实际没有用到索引\",{\"1\":{\"553\":1}}],[\"但是却需要等到下一个检测发起执行语句的时候\",{\"1\":{\"478\":1}}],[\"但是通过like操作符和以通配符开头的字符串做比较\",{\"1\":{\"547\":1}}],[\"但是通过select\",{\"1\":{\"476\":1}}],[\"但是update\",{\"1\":{\"535\":1}}],[\"但是像阿里这样的公司一般会用datetime\",{\"1\":{\"529\":1}}],[\"但是概率极小\",{\"1\":{\"499\":1}}],[\"但是概率非常小\",{\"1\":{\"352\":1}}],[\"但是trx\",{\"1\":{\"497\":1}}],[\"但是并不意味着引用这些不可变对象的对象就是线程安全的\",{\"1\":{\"1526\":1}}],[\"但是并不会保存自增值\",{\"1\":{\"490\":1}}],[\"但是并行提交多个异步任务\",{\"1\":{\"1518\":1}}],[\"但是并发查询过高会占用过多资源\",{\"1\":{\"476\":1}}],[\"但是session\",{\"1\":{\"481\":1}}],[\"但是io操作很耗时\",{\"1\":{\"1510\":1}}],[\"但是io利用率100\",{\"1\":{\"478\":1}}],[\"但是index是从索引中读的\",{\"1\":{\"330\":1}}],[\"但是查询表t的语句会被阻塞\",{\"1\":{\"476\":1}}],[\"但是也可能造成错失最优的执行计划\",{\"1\":{\"556\":1}}],[\"但是也存在两个问题\",{\"1\":{\"471\":1}}],[\"但是也有一些并不适合在被驱动表上建索引的情况\",{\"1\":{\"407\":1}}],[\"但是不能自动装配和获取beannames\",{\"1\":{\"1636\":1}}],[\"但是不能从根本上解决查询问题\",{\"1\":{\"1270\":1}}],[\"但是不删除缓存\",{\"1\":{\"1286\":1}}],[\"但是不够通用\",{\"1\":{\"637\":1}}],[\"但是不会阻塞读\",{\"1\":{\"535\":1}}],[\"但是不存在于set\",{\"1\":{\"468\":1}}],[\"但是不创建索引的话需要判断10亿次\",{\"1\":{\"407\":1}}],[\"但是相同的日志\",{\"1\":{\"467\":1}}],[\"但是设置成2\",{\"1\":{\"451\":1}}],[\"但是持久化到磁盘的速度就慢多了\",{\"1\":{\"451\":1}}],[\"但是共用同一份binlog文件\",{\"1\":{\"450\":1}}],[\"但是它们都是高性能服务器的典范\",{\"1\":{\"601\":1}}],[\"但是它的致命缺点就是\",{\"1\":{\"553\":1}}],[\"但是它可以保证每个更新请求都是更新内存中的bufferpool\",{\"1\":{\"543\":1}}],[\"但是它和之前介绍过的锁都不太一样\",{\"1\":{\"448\":1}}],[\"但是它也有额外的负担\",{\"1\":{\"444\":1}}],[\"但是汇总到数据库服务端以后\",{\"1\":{\"444\":1}}],[\"但是每秒却执行不了几个事务\",{\"1\":{\"444\":1}}],[\"但是每一行都变小了\",{\"1\":{\"355\":1}}],[\"但是检测期间要消耗大量的cpu资源\",{\"1\":{\"444\":1}}],[\"但是请求很频繁\",{\"1\":{\"441\":1}}],[\"但是语句结束后并不会马上释放\",{\"1\":{\"441\":1}}],[\"但是回滚段却有200gb\",{\"1\":{\"434\":1}}],[\"但是结果已经被a看到了\",{\"1\":{\"433\":1}}],[\"但是从上面的实验效果可以看出\",{\"1\":{\"424\":1}}],[\"但是随着单词表的变大\",{\"1\":{\"419\":1}}],[\"但是传到备库执行时如何处理的呢\",{\"1\":{\"413\":1}}],[\"但是如果我们想要一个bean完全由我们自己来创造\",{\"1\":{\"1644\":1}}],[\"但是如果你这么写的话\",{\"1\":{\"1614\":1}}],[\"但是如果使用lambda表达式\",{\"1\":{\"1599\":1}}],[\"但是如果并发数大于阻塞队列大小\",{\"1\":{\"1573\":1}}],[\"但是如果没有剩余内存\",{\"1\":{\"1503\":1}}],[\"但是如果队列里无数据\",{\"1\":{\"1501\":1}}],[\"但是如果一个线程想去写这些共享资源\",{\"1\":{\"1498\":1}}],[\"但是如果一个mysql实例跑得足够久得话\",{\"1\":{\"495\":1}}],[\"但是如果这个数字越大\",{\"1\":{\"624\":1}}],[\"但是如果这个where条件改成where\",{\"1\":{\"425\":1}}],[\"但是如果global\",{\"1\":{\"496\":1}}],[\"但是如果马上重启实例\",{\"1\":{\"490\":1}}],[\"但是如果它们被分到不同的worker\",{\"1\":{\"462\":1}}],[\"但是如果row格式的binlog\",{\"1\":{\"454\":1}}],[\"但是如果不是死锁\",{\"1\":{\"444\":1}}],[\"但是如果是在普通的分表上操作的时候并不会出现这样的问题\",{\"1\":{\"425\":1}}],[\"但是如果是增加新的字段\",{\"1\":{\"309\":1}}],[\"但是如果执行drop\",{\"1\":{\"413\":1}}],[\"但是备库同步线程是持续在运行的\",{\"1\":{\"413\":1}}],[\"但是表结构还在\",{\"1\":{\"409\":1}}],[\"但是经过where条件过滤后\",{\"1\":{\"407\":1}}],[\"但是判断等值条件的次数还是不变的\",{\"1\":{\"403\":1}}],[\"但是bnl算法的这10万次判断是内存操作\",{\"1\":{\"403\":1}}],[\"但是binlog里面已经记录了\",{\"1\":{\"327\":1}}],[\"但是这还不足以写出好的代码\",{\"1\":{\"1992\":1}}],[\"但是这么做的缺点是\",{\"1\":{\"1654\":1}}],[\"但是这样也会造成效率的降低\",{\"1\":{\"1569\":1}}],[\"但是这样的想法对于mysql来说并不适用\",{\"1\":{\"392\":1}}],[\"但是这通常没有任何好处\",{\"1\":{\"529\":1}}],[\"但是这种方式可能不准\",{\"1\":{\"526\":1}}],[\"但是这种操作本身带有一定的风险\",{\"1\":{\"444\":1}}],[\"但是这个过程并不保证各个语句计算的先后顺序和输入代码中的顺序一致\",{\"1\":{\"1405\":1}}],[\"但是这个方法并不安全\",{\"1\":{\"1379\":1}}],[\"但是这个方案仍然存在\",{\"1\":{\"486\":1}}],[\"但是这个范围是有限的\",{\"1\":{\"984\":1}}],[\"但是这个时候系统还是可以正常读取数据的\",{\"1\":{\"477\":1}}],[\"但是这个时候根据where条件\",{\"1\":{\"425\":1}}],[\"但是这个位点很难精确取到\",{\"1\":{\"467\":1}}],[\"但是这个算法会将1000行数据都排好序\",{\"1\":{\"421\":1}}],[\"但是这个sql请求需要扫描表t2多达100次\",{\"1\":{\"402\":1}}],[\"但是这里的number\",{\"1\":{\"421\":1}}],[\"但是仅返回200行结果\",{\"1\":{\"390\":1}}],[\"但是group\",{\"1\":{\"378\":1}}],[\"但是没有参数\",{\"1\":{\"1650\":1}}],[\"但是没有持久化\",{\"1\":{\"451\":1}}],[\"但是没有用到c\",{\"1\":{\"377\":2}}],[\"但是没有关系\",{\"1\":{\"332\":1}}],[\"但是范围之后的索引字段会失效\",{\"1\":{\"372\":1}}],[\"但是执行show\",{\"1\":{\"480\":1}}],[\"但是执行代价要比随机算法1的代价要高\",{\"1\":{\"422\":1}}],[\"但是执行效率有没有差距呢\",{\"1\":{\"371\":1}}],[\"但是执行的效率会有所不同\",{\"1\":{\"321\":1,\"514\":1}}],[\"但是explain结果的第二行显示\",{\"1\":{\"368\":1}}],[\"但是explain结果却显式\",{\"1\":{\"367\":1}}],[\"但是mysql比较完成成本后\",{\"1\":{\"551\":1}}],[\"但是mysql在计算全表扫描成本时直接使用聚簇索引占用的页面数作为计算io成本的依据\",{\"1\":{\"548\":1}}],[\"但是mysql重启之后会生成新的binlog文件\",{\"1\":{\"496\":1}}],[\"但是mysqlbinlog工具并不能指定只解析一个表的日志\",{\"1\":{\"485\":1}}],[\"但是mysql并没有使用这个索引\",{\"1\":{\"366\":1}}],[\"但是myisam没有crash\",{\"1\":{\"325\":1}}],[\"但是性能却差异巨大的sql语句\",{\"1\":{\"365\":1}}],[\"但是在concurrenthashmap实现里保留了segment定义\",{\"1\":{\"1554\":1}}],[\"但是在更新是会判断其它线程在这之前有没有对数据进行修改\",{\"1\":{\"1399\":1}}],[\"但是在value当中写入一个逻辑上的过期时间\",{\"1\":{\"1287\":1}}],[\"但是在另一个mapper\",{\"1\":{\"1219\":1}}],[\"但是在容器启动的时候\",{\"1\":{\"1149\":1}}],[\"但是在很多情况下\",{\"1\":{\"541\":1}}],[\"但是在使用decimal类型的时候\",{\"1\":{\"528\":1}}],[\"但是在计算机里\",{\"1\":{\"493\":1}}],[\"但是在备库上执行show\",{\"1\":{\"485\":1}}],[\"但是在这个等待进入innodb的循环过程中\",{\"1\":{\"481\":1}}],[\"但是在查询这条记录的时候\",{\"1\":{\"434\":1}}],[\"但是在order\",{\"1\":{\"361\":1}}],[\"但是在统计信息中\",{\"1\":{\"347\":1}}],[\"但是索引选取的越长\",{\"1\":{\"352\":1}}],[\"但是对于andthen\",{\"1\":{\"1598\":1}}],[\"但是对于开发中大部分的bean\",{\"1\":{\"1236\":1}}],[\"但是对于内连接来说\",{\"1\":{\"555\":1}}],[\"但是对于一些业务来说\",{\"1\":{\"459\":1}}],[\"但是对于这个查询语句来说\",{\"1\":{\"350\":1}}],[\"但是对于mysql的server层来说\",{\"1\":{\"338\":1}}],[\"但是代价太高了\",{\"1\":{\"347\":1}}],[\"但是实现原理一样的\",{\"1\":{\"1548\":1}}],[\"但是实现索引的方式却有很多中\",{\"1\":{\"331\":1}}],[\"但是实例资源需要对资源的分配做出管理\",{\"1\":{\"1530\":1}}],[\"但是实际上服务端上这条语句还在执行过程中\",{\"1\":{\"481\":1}}],[\"但是实际上大多数的数据库存储却并不使用二叉树\",{\"1\":{\"334\":1}}],[\"但是实际情况更加复杂\",{\"1\":{\"388\":1}}],[\"但是\",{\"1\":{\"333\":1,\"406\":2,\"411\":2,\"413\":1,\"416\":2,\"417\":1,\"421\":1,\"444\":1,\"450\":1,\"454\":1,\"455\":1,\"456\":1,\"461\":1,\"462\":1,\"463\":1,\"472\":1,\"476\":1,\"477\":1,\"478\":2,\"481\":2,\"482\":1,\"491\":1,\"492\":1,\"495\":1,\"497\":3,\"498\":2,\"1262\":1,\"1337\":1,\"1440\":1,\"1511\":1,\"1548\":2,\"1565\":1,\"1613\":1,\"1986\":1}}],[\"但是由于这两个接口中有同名的默认方法\",{\"1\":{\"1607\":1}}],[\"但是由于\",{\"1\":{\"468\":1}}],[\"但是由于cpu的调度策略\",{\"1\":{\"460\":1}}],[\"但是由于session\",{\"1\":{\"425\":1}}],[\"但是由于binlog没写完就crash了\",{\"1\":{\"327\":1}}],[\"但是由的时候会推算的不对\",{\"1\":{\"309\":1}}],[\"但是大多数情况下不要使用查询缓存\",{\"1\":{\"319\":1}}],[\"但是全部使用长连接后\",{\"1\":{\"318\":1}}],[\"但是信息会出现在\",{\"1\":{\"309\":1}}],[\"连接点\",{\"1\":{\"1654\":1}}],[\"连接\",{\"1\":{\"1433\":2,\"1974\":1}}],[\"连接消耗大\",{\"1\":{\"645\":1}}],[\"连接主从的密码\",{\"1\":{\"624\":1}}],[\"连接工厂\",{\"1\":{\"583\":1}}],[\"连接右\",{\"1\":{\"555\":1}}],[\"连接查询成本占大头的其实是驱动表扇出数\",{\"1\":{\"555\":1}}],[\"连接查询来说\",{\"1\":{\"555\":1}}],[\"连接查询总成本\",{\"1\":{\"555\":1}}],[\"连接查询的总成本也就越低\",{\"1\":{\"554\":1}}],[\"连接查询的成本输出\",{\"1\":{\"555\":1}}],[\"连接查询的成本计算公式\",{\"1\":{\"555\":1}}],[\"连接查询的成本\",{\"0\":{\"554\":1}}],[\"连接起来就会很快\",{\"1\":{\"482\":1}}],[\"连接就会很慢\",{\"1\":{\"482\":1}}],[\"连接维护\",{\"1\":{\"469\":1}}],[\"连接建立完成后\",{\"1\":{\"319\":1}}],[\"连接可以分为两种\",{\"1\":{\"318\":1}}],[\"连接完成之后\",{\"1\":{\"318\":1}}],[\"连接命令中的mysql是客户端工具\",{\"1\":{\"318\":1}}],[\"连接命令通常如下\",{\"1\":{\"318\":1}}],[\"连接器通过适配器adapter调用容器\",{\"1\":{\"1688\":1}}],[\"连接器用protocolhandler接口来封装通信协议个i\",{\"1\":{\"1688\":1}}],[\"连接器用protocolhandler来处理网络连接和应用层协议\",{\"1\":{\"1688\":1}}],[\"连接器需要实现的功能\",{\"1\":{\"1687\":1}}],[\"连接器对servlet容器屏蔽了不同的应用层协议及i\",{\"1\":{\"1687\":1}}],[\"连接器connector组件\",{\"0\":{\"1687\":1}}],[\"连接器负责对外交流\",{\"1\":{\"1683\":1}}],[\"连接器负责跟客户端建立连接\",{\"1\":{\"318\":1}}],[\"连接器组件\",{\"1\":{\"1683\":1}}],[\"连接器就会自动将他断开\",{\"1\":{\"318\":1}}],[\"连接器就要开始认证你的身份\",{\"1\":{\"318\":1}}],[\"连接器会到权限表里面查出你拥有的权限\",{\"1\":{\"318\":1}}],[\"连接器\",{\"0\":{\"318\":1,\"512\":1}}],[\"梳理它执行的完整的流程\",{\"1\":{\"317\":1}}],[\"接着要考虑的就是能否扩容\",{\"1\":{\"1509\":1}}],[\"接入点接口joinpoint\",{\"0\":{\"783\":1}}],[\"接口中有同名的默认方法\",{\"1\":{\"1607\":1}}],[\"接口中的抽象方法是accept\",{\"1\":{\"1597\":1}}],[\"接口中的默认方法和静态\",{\"1\":{\"1349\":1}}],[\"接口中除了static\",{\"1\":{\"1345\":1}}],[\"接口里面只能由常量\",{\"1\":{\"1345\":1}}],[\"接口方法的默认修饰符是public\",{\"1\":{\"1345\":1}}],[\"接口的方法默认都是public\",{\"1\":{\"1345\":1}}],[\"接口实现类继承sqlsessiondaosupport\",{\"1\":{\"1217\":1}}],[\"接口和方法\",{\"1\":{\"1098\":1}}],[\"接口和抽象类的区别越来越小了\",{\"1\":{\"1607\":1}}],[\"接口和抽象类的区别\",{\"0\":{\"16\":1,\"1345\":1}}],[\"接口职责\",{\"1\":{\"1061\":1,\"1062\":1}}],[\"接口\",{\"1\":{\"1038\":1,\"1122\":1,\"1146\":2,\"1969\":1}}],[\"接口回调阶段\",{\"0\":{\"1005\":1}}],[\"接口回调的示例\",{\"1\":{\"957\":1}}],[\"接口回调示例\",{\"1\":{\"957\":1}}],[\"接口回调注入\",{\"0\":{\"957\":1},\"1\":{\"969\":1}}],[\"接口回调\",{\"1\":{\"951\":1,\"1008\":1}}],[\"接口注入\",{\"1\":{\"906\":1}}],[\"接口层一接收到请求就会调用数据处理层来玩完成具体的数据处理\",{\"1\":{\"645\":1}}],[\"接收事务结束的消息\",{\"0\":{\"1942\":1}}],[\"接收事务准备消息\",{\"0\":{\"1941\":1}}],[\"接收事务消息\",{\"0\":{\"1879\":1,\"1940\":1}}],[\"接收普通消息\",{\"0\":{\"1878\":1}}],[\"接收网络连接请求\",{\"1\":{\"1687\":1}}],[\"接收的参数tointfunction<\",{\"1\":{\"1614\":1}}],[\"接收的参数类型是consumer\",{\"1\":{\"1595\":1}}],[\"接收两个参数并且返回一个结果\",{\"1\":{\"1598\":1}}],[\"接收客户端连接\",{\"1\":{\"1575\":1}}],[\"接收请求\",{\"1\":{\"1533\":1,\"1534\":1}}],[\"接收到spring事件\",{\"1\":{\"1112\":1}}],[\"接收到来自sakura频道的消息\",{\"1\":{\"598\":2}}],[\"接收消息\",{\"0\":{\"1877\":1},\"1\":{\"596\":1}}],[\"接收服务端返回结果的方式有两种\",{\"1\":{\"482\":1}}],[\"接下来把扫描得到的beandefinition进行修改\",{\"1\":{\"1653\":1}}],[\"接下来就需要重点了解管道流相关的内容\",{\"1\":{\"1621\":1}}],[\"接下来就正式开始了解有关spliterator的内容\",{\"1\":{\"1620\":1}}],[\"接下来是abstractpipeline类中的一些属性\",{\"1\":{\"1621\":1}}],[\"接下来是八个特性值\",{\"1\":{\"1620\":1}}],[\"接下来是getcomparator方法\",{\"1\":{\"1620\":1}}],[\"接下来是getexactsizeifknown方法\",{\"1\":{\"1620\":1}}],[\"接下来是hascharacteristics方法\",{\"1\":{\"1620\":1}}],[\"接下来是characteristics方法\",{\"1\":{\"1620\":1}}],[\"接下来是estimatesize方法\",{\"1\":{\"1620\":1}}],[\"接下来是trysplit方法\",{\"1\":{\"1620\":1}}],[\"接下来是foreachremaining方法\",{\"1\":{\"1620\":1}}],[\"接下来是具体处理的逻辑\",{\"1\":{\"965\":1}}],[\"接下来spliterator接口本身提供的一些方法进行说明\",{\"1\":{\"1620\":1}}],[\"接下来还提供了一个并行的例子\",{\"1\":{\"1620\":1}}],[\"接下来的章节重点分析这个类\",{\"1\":{\"1615\":1}}],[\"接下来的时间\",{\"1\":{\"1593\":1}}],[\"接下来介绍iterate方法\",{\"1\":{\"1609\":1}}],[\"接下来介绍generate和iterate这两个特殊的方法\",{\"1\":{\"1609\":1}}],[\"接下来再通过一些实际的例子\",{\"1\":{\"1608\":1}}],[\"接下来三个步骤时哈希桶数组resize成4\",{\"1\":{\"1550\":1}}],[\"接下来三组数据\",{\"1\":{\"479\":1}}],[\"接下来进行注册并且测试是否成功\",{\"1\":{\"989\":1}}],[\"接下来观察innodb\",{\"1\":{\"558\":1}}],[\"接下来执行264次查询语句\",{\"1\":{\"496\":1}}],[\"接下来执行的这个事务会直接被系统忽略\",{\"1\":{\"468\":1}}],[\"接下来四列是具体的统计项\",{\"1\":{\"479\":1}}],[\"接下来这个fsync越晚调用\",{\"1\":{\"451\":1}}],[\"接下来按照r排序\",{\"1\":{\"420\":1}}],[\"接下来按顺序取\",{\"1\":{\"356\":1}}],[\"接下来应该看看查询为了返回结果是否扫描了过多的数据\",{\"1\":{\"387\":1}}],[\"接下来\",{\"1\":{\"341\":1,\"396\":1,\"420\":1,\"454\":1,\"459\":1,\"491\":1,\"497\":1,\"1593\":1,\"1613\":1,\"1667\":1}}],[\"接下来我们来查看一下foreach方法的说明\",{\"1\":{\"1622\":1}}],[\"接下来我们来看一个kill不掉的例子\",{\"1\":{\"481\":1}}],[\"接下来我们就完整的梳理一下关于sream类本身的内容\",{\"1\":{\"1619\":1}}],[\"接下来我们就围绕collectors为我们提供的诸多的静态方法展开\",{\"1\":{\"1616\":1}}],[\"接下来我们定义一个中间结果容器需要进行类型转换的例子\",{\"1\":{\"1617\":1}}],[\"接下来我们定义一个properties文件\",{\"1\":{\"1022\":1}}],[\"接下来我们实现一个自定义的收集器\",{\"1\":{\"1617\":1}}],[\"接下来我们首先分析每一个枚举项代表的含义\",{\"1\":{\"1617\":1}}],[\"接下来我们讨论有关流的短路问题\",{\"1\":{\"1612\":1}}],[\"接下来我们再了解流的另一个特性\",{\"1\":{\"1610\":1}}],[\"接下来我们阅读一下iterate的文档\",{\"1\":{\"1609\":1}}],[\"接下来我们给出一个稍微复杂一点的示例\",{\"1\":{\"1607\":1}}],[\"接下来我们使用list集合中新增加的sort方法进行排序\",{\"1\":{\"1603\":1}}],[\"接下来我们重点分析consumer这个函数式接口\",{\"1\":{\"1595\":1}}],[\"接下来我们自定义一个注解\",{\"1\":{\"961\":1,\"967\":1}}],[\"接下来我们分析使用s2作为驱动表的情况\",{\"1\":{\"555\":1}}],[\"接下来我们分析使用s1作为驱动表的情况\",{\"1\":{\"555\":1}}],[\"接下来我们分析一下engine\",{\"1\":{\"557\":1}}],[\"接下来我们分析一下\",{\"1\":{\"457\":1}}],[\"接下来我们分别分析一下这两种情况\",{\"1\":{\"555\":1}}],[\"接下来我们分别计算这两个数据\",{\"1\":{\"549\":1}}],[\"接下来我们要在主库执行下面这两个事务\",{\"1\":{\"462\":1}}],[\"接下来我们看一下通过reducing来实现的例子\",{\"1\":{\"1618\":1}}],[\"接下来我们看一个之前使用的方法\",{\"1\":{\"1618\":1}}],[\"接下来我们看多次排序的方法\",{\"1\":{\"1614\":1}}],[\"接下来我们看看引入stream会为我们的编码带来什么样的改变\",{\"1\":{\"1607\":1}}],[\"接下来我们看看在myisam引擎中的情况\",{\"1\":{\"424\":1}}],[\"接下来我们看另外一种场景\",{\"1\":{\"368\":1}}],[\"接下来我们通过例子来说明这三点\",{\"1\":{\"491\":1}}],[\"接下来我们通过例子来说明这一点\",{\"1\":{\"468\":1}}],[\"接下来我们通过一个实例来说明这一点\",{\"1\":{\"443\":1}}],[\"接下来我们通过观察分区表加间隙锁的例子来说明对于innodb来说\",{\"1\":{\"424\":1}}],[\"接下来我们通过实例来说明它们之间的区别\",{\"1\":{\"345\":1}}],[\"接下来我们着重了解一些索引的实践部分\",{\"1\":{\"357\":1}}],[\"接下来我们说明为什么需要两阶段提交\",{\"1\":{\"327\":1}}],[\"接下来我们会从上文提到的sql语句\",{\"1\":{\"317\":1}}],[\"它利用\",{\"1\":{\"1989\":1}}],[\"它基于项目对象模型\",{\"1\":{\"1980\":1}}],[\"它负责加载servlet类\",{\"1\":{\"1693\":1}}],[\"它又定义了另外三个bean\",{\"1\":{\"1655\":1}}],[\"它存储在单例池中\",{\"1\":{\"1647\":1}}],[\"它比propertyeditor更加强大\",{\"1\":{\"1639\":1}}],[\"它比datetime更节约空间\",{\"1\":{\"529\":1}}],[\"它能解析的注解有\",{\"1\":{\"1633\":1}}],[\"它封装了一个流源和0个或者多个中间操作\",{\"1\":{\"1621\":1}}],[\"它与流的操作息息相关\",{\"1\":{\"1621\":1}}],[\"它描述了对于分割子任务的分割方法\",{\"1\":{\"1620\":1}}],[\"它对应的spliterator会忽略掉标签\",{\"1\":{\"1620\":1}}],[\"它对应的cardinality值是10225\",{\"1\":{\"553\":1}}],[\"它绝大部分的方法都是静态方法\",{\"1\":{\"1616\":1}}],[\"它要满足combiner\",{\"1\":{\"1615\":1}}],[\"它支持自定义\",{\"1\":{\"1982\":1}}],[\"它支持使用注解\",{\"1\":{\"1641\":1}}],[\"它支持串行与并行两种方式执行\",{\"1\":{\"1615\":1}}],[\"它支持字符串\",{\"1\":{\"568\":1}}],[\"它本身持有了元数据集合的引用\",{\"1\":{\"1621\":1}}],[\"它本身又调用一个重载的方法\",{\"1\":{\"1618\":1}}],[\"它本身接收一个参数叫做collector\",{\"1\":{\"1615\":1}}],[\"它本质上是一种copy\",{\"1\":{\"1527\":1}}],[\"它返回一个字典顺序的比较器\",{\"1\":{\"1614\":1}}],[\"它接受一个supplier参数\",{\"1\":{\"1609\":1}}],[\"它必须和accumulator\",{\"1\":{\"1608\":1}}],[\"它每次被调用的时候无需保证返回不同的结果\",{\"1\":{\"1600\":1}}],[\"它只会分成两组\",{\"1\":{\"1613\":1}}],[\"它只接受一个参数\",{\"1\":{\"1598\":1}}],[\"它只有一个精确的抽象方法\",{\"1\":{\"1594\":1}}],[\"它总是返回输入的变量\",{\"1\":{\"1598\":1}}],[\"它取决于调用这个怎么去处理这个异常\",{\"1\":{\"1598\":1}}],[\"它满足函数式接口的定义\",{\"1\":{\"1595\":1}}],[\"它并不算数\",{\"1\":{\"1594\":1}}],[\"它并没有实现\",{\"1\":{\"464\":1}}],[\"它允许把函数\",{\"1\":{\"1593\":1}}],[\"它还调用了finisher方法\",{\"1\":{\"1618\":1}}],[\"它还可以为我们带来代码执行效率上的提升\",{\"1\":{\"1592\":1}}],[\"它还会尝试使用一种称为轻量级锁的优化手段\",{\"1\":{\"1485\":1}}],[\"它还会和其他sentinel节点进行\",{\"1\":{\"621\":1}}],[\"它表示要对于流中每个元素都执行action操作\",{\"1\":{\"1622\":1}}],[\"它表示将流中元素的界限打破\",{\"1\":{\"1609\":1}}],[\"它表示当前对象指的是lambdatest$1\",{\"1\":{\"1592\":1}}],[\"它表示拷贝数据的次数为0\",{\"1\":{\"1576\":1}}],[\"它将数据从磁盘读取到\",{\"1\":{\"1584\":1}}],[\"它将抛出rejectedexecutionexception异常\",{\"1\":{\"1410\":1}}],[\"它提供了高速\",{\"1\":{\"1574\":1}}],[\"它发起一个read操作后\",{\"1\":{\"1564\":1}}],[\"它继承自dictionary类\",{\"1\":{\"1544\":1}}],[\"它根据键的hashcode值缓存数据\",{\"1\":{\"1544\":1}}],[\"它也会扫描成为一个bean\",{\"1\":{\"1645\":1}}],[\"它也有两个重载的方法\",{\"1\":{\"1618\":1}}],[\"它也是基于aqs来实现的\",{\"1\":{\"1496\":1}}],[\"它也要把字符串\",{\"1\":{\"320\":1}}],[\"它可能会有副作用\",{\"1\":{\"1597\":1}}],[\"它可能被外部方法所引用\",{\"1\":{\"1488\":1}}],[\"它可以快速地储存\",{\"1\":{\"1986\":1}}],[\"它可以管理项目的构建\",{\"1\":{\"1980\":1}}],[\"它可以为service内所有组件提供线程池执行任务\",{\"1\":{\"1686\":1}}],[\"它可以扫描某个包路径\",{\"1\":{\"1635\":1}}],[\"它可以将返回的spliterator交由另一个线程接管\",{\"1\":{\"1620\":1}}],[\"它可以被看成是一种对于流元的查询\",{\"1\":{\"1619\":1}}],[\"它可以通过不同的枚举值来提高并发流的执行效率\",{\"1\":{\"1615\":1}}],[\"它可以在所有的元素都处理完毕后\",{\"1\":{\"1615\":1}}],[\"它可以看成是lambda表达式的一种语法糖\",{\"1\":{\"1602\":1}}],[\"它可以直接从内核空间缓冲区中将数据读取到网卡\",{\"1\":{\"1583\":1}}],[\"它可以访问受保护的内核空间\",{\"1\":{\"1579\":1}}],[\"它可以创建和编译程序\",{\"1\":{\"1337\":1}}],[\"它可以提供更好的并发的性能\",{\"1\":{\"1618\":1}}],[\"它可以提供任何你想要的东西\",{\"1\":{\"902\":1}}],[\"它可以提高相同代码片段的复用性\",{\"1\":{\"385\":1}}],[\"它可以高频请求上用到覆盖索引\",{\"1\":{\"338\":1}}],[\"它通过h\",{\"1\":{\"1548\":1}}],[\"它通过cas操作\",{\"1\":{\"1416\":1}}],[\"它通常在缓存块的粒度上执行\",{\"1\":{\"1474\":1}}],[\"它把store操作从工作内存中一个变量的值传送到主内存的变量中\",{\"1\":{\"1473\":1}}],[\"它把一个从执行引擎接收到的值赋值给工作内存的变量\",{\"1\":{\"1473\":1}}],[\"它把read操作从主内存中得到的变量值放入工作内存的变量副本中\",{\"1\":{\"1473\":1}}],[\"它使用java语言规范定义\",{\"1\":{\"1594\":1}}],[\"它使用一个int类型的成员变量表示同步状态\",{\"1\":{\"1400\":1}}],[\"它使用起来可能在形式上略有差异\",{\"1\":{\"603\":1}}],[\"它不能用来创建新的程序\",{\"1\":{\"1337\":1}}],[\"它不止有jre\",{\"1\":{\"1337\":1}}],[\"它和springcloudalibaba都是springcloud这一系列开发模式的具体实现\",{\"1\":{\"1305\":1}}],[\"它如此优秀的性能主要取决于以下几个方面\",{\"1\":{\"1292\":1}}],[\"它会接收pipelinehelper输出类型的元素\",{\"1\":{\"1623\":1}}],[\"它会接收一个流作为输入\",{\"1\":{\"1623\":1}}],[\"它会接收一个sink作为当前操作的结果\",{\"1\":{\"1623\":1}}],[\"它会在一个地方捕获关于流管道的所有信息\",{\"1\":{\"1623\":1}}],[\"它会计算一个流福安到并且将结果发送给自身作为一个terminalsink\",{\"1\":{\"1623\":1}}],[\"它会管理流管道的构建以及计算\",{\"1\":{\"1621\":1}}],[\"它会估算父亲节点的元素的一般\",{\"1\":{\"1620\":1}}],[\"它会恰好就元素分成等量的两部分\",{\"1\":{\"1620\":1}}],[\"它会使用try\",{\"1\":{\"1619\":1}}],[\"它会考虑到顺序上的区别带来的不相等性\",{\"1\":{\"1615\":1}}],[\"它会根据定义好的排序规则\",{\"1\":{\"1603\":1}}],[\"它会经历两个阶段\",{\"1\":{\"1561\":1}}],[\"它会从队列里取出来将要执行的具体任务\",{\"1\":{\"1501\":1}}],[\"它会首先比较\",{\"1\":{\"1479\":1}}],[\"它会独立运行\",{\"1\":{\"1291\":1}}],[\"它会被自动地分配到它专属的channelpipeline\",{\"1\":{\"1224\":1}}],[\"它包含了基本的i\",{\"1\":{\"1224\":1}}],[\"它统一spring配置属性的存储\",{\"1\":{\"1144\":1}}],[\"它里面的preprocessxml和postprocessxml方法都是空实现\",{\"1\":{\"1025\":1}}],[\"它有且仅有一个实现类就是defaultlistablebeanfactory\",{\"1\":{\"996\":1}}],[\"它有三种可能取值\",{\"1\":{\"451\":1}}],[\"它都有\",{\"1\":{\"623\":1}}],[\"它认为每次回表操作都相当于访问一个页面\",{\"1\":{\"549\":1}}],[\"它就不会再被accumulator方法使用了\",{\"1\":{\"1615\":1}}],[\"它就知道数据还没有准备好\",{\"1\":{\"1564\":1}}],[\"它就会将数据从kernel中拷贝到用户内存\",{\"1\":{\"1563\":1}}],[\"它就会重置为0\",{\"1\":{\"498\":1}}],[\"它就是代表这个资源的\",{\"1\":{\"1561\":1}}],[\"它就是一个正常表\",{\"1\":{\"409\":1}}],[\"它就是找引擎拿到了两条记录\",{\"1\":{\"338\":1}}],[\"它在mysql中是用来对应事务的\",{\"1\":{\"496\":1}}],[\"它是\",{\"1\":{\"1982\":1}}],[\"它是sink的一个抽象实现\",{\"1\":{\"1623\":1}}],[\"它是定义在abstractpipeline当中的\",{\"1\":{\"1622\":1}}],[\"它是根据提供的分类器来对元素进行分组的\",{\"1\":{\"1618\":1}}],[\"它是由迭代函数f对于初始值seed的不断迭代\",{\"1\":{\"1609\":1}}],[\"它是function接口的一种特殊形式\",{\"1\":{\"1598\":1}}],[\"它是java实现整个函数式编程的手段\",{\"1\":{\"1593\":1}}],[\"它是为操作系统的内核保留的\",{\"1\":{\"1579\":1}}],[\"它是一个类\",{\"1\":{\"1636\":2}}],[\"它是一个可变的汇聚操作\",{\"1\":{\"1615\":1}}],[\"它是一个相关的\",{\"1\":{\"1608\":1}}],[\"它是一个索引值\",{\"1\":{\"1561\":1}}],[\"它是一个重量级锁\",{\"1\":{\"1483\":1}}],[\"它是性能保证的关键之一\",{\"1\":{\"1511\":1}}],[\"它是对abstractexecutorservice类的扩展\",{\"1\":{\"1510\":1}}],[\"它是操作系统中pv操作的源语在java中的实现\",{\"1\":{\"1496\":1}}],[\"它是操作系统提供给用户程序的api\",{\"1\":{\"603\":1}}],[\"它是运行已经编译的java程序所需的内容的集合\",{\"1\":{\"1337\":1}}],[\"它是针对resultset结果集执行的内存分页\",{\"1\":{\"1214\":1}}],[\"它是在从库执行的\",{\"1\":{\"473\":1}}],[\"它是加载数据行之间间隙上的\",{\"1\":{\"448\":1}}],[\"它由两部分组成\",{\"1\":{\"468\":1}}],[\"它用set\",{\"1\":{\"454\":1}}],[\"它用来记录在mysql中响应时间超过阈值的语句\",{\"1\":{\"428\":1}}],[\"它做的变更才会被其它事务看到\",{\"1\":{\"433\":1}}],[\"它做的变更就能被别的事务看到\",{\"1\":{\"433\":1}}],[\"它的构成组件都是可配置的\",{\"1\":{\"1683\":1}}],[\"它的close方法会在退出\",{\"1\":{\"1619\":1}}],[\"它的相关说明\",{\"1\":{\"1613\":1}}],[\"它的参数unaryoperator可以简单的看一下\",{\"1\":{\"1609\":1}}],[\"它的抽象方法是apply\",{\"1\":{\"1598\":1}}],[\"它的底层时调用了linux内核的mmap的api\",{\"1\":{\"1587\":1}}],[\"它的主要作用就是和channel进行交互\",{\"1\":{\"1574\":1}}],[\"它的主要目的是根据调用的请求完成一次数据库操作\",{\"1\":{\"645\":1}}],[\"它的基本原来就是select\",{\"1\":{\"1565\":1}}],[\"它的put方法\",{\"1\":{\"1553\":1}}],[\"它的操作力度更细\",{\"1\":{\"1509\":1}}],[\"它的容量固定就是integer\",{\"1\":{\"1509\":1}}],[\"它的index日志文件也是通过mmap的方式来读写的\",{\"1\":{\"1330\":1,\"1331\":1}}],[\"它的默认值是on\",{\"1\":{\"559\":1}}],[\"它的查询成本由下面两个部分构成\",{\"1\":{\"554\":1}}],[\"它的rows值是10354\",{\"1\":{\"553\":1}}],[\"它的执行流程如下\",{\"1\":{\"542\":1}}],[\"它的指针地址是不会变的\",{\"1\":{\"497\":1}}],[\"它的算法是\",{\"1\":{\"497\":1}}],[\"它的逻辑如下\",{\"1\":{\"473\":1}}],[\"它的目标是\",{\"1\":{\"464\":1}}],[\"它的计算方式如下\",{\"1\":{\"457\":1}}],[\"它的返回结果里面会显示\",{\"1\":{\"457\":1}}],[\"它的explain结果如下\",{\"1\":{\"416\":1}}],[\"它的语义是\",{\"1\":{\"414\":1}}],[\"它的意思是\",{\"1\":{\"355\":1}}],[\"它们必须都是result\",{\"1\":{\"1615\":1}}],[\"它们背后的设计思想就是copy\",{\"1\":{\"1527\":1}}],[\"它们都严格遵守了不可变类的三点要求\",{\"1\":{\"1526\":1}}],[\"它们此时并不需要cpu来计算\",{\"1\":{\"1510\":1}}],[\"它们本质上都是对相应平台的\",{\"1\":{\"1479\":1}}],[\"它们本身就可以保证索引列值的不重复\",{\"1\":{\"558\":1}}],[\"它们之间的关系是\",{\"1\":{\"1546\":1}}],[\"它们之间的关系如下图\",{\"1\":{\"1553\":1}}],[\"它们之间的关系如下\",{\"1\":{\"1422\":1}}],[\"它们之间是不冲突的\",{\"1\":{\"448\":1}}],[\"它们会选举出一个sentinel节点来完成自动故障转移的工作\",{\"1\":{\"621\":1}}],[\"它们被存储到mysql的两个表中\",{\"1\":{\"557\":1}}],[\"它们可能还没有收到最新的日志\",{\"1\":{\"472\":1}}],[\"它们可以用来制造更多的\",{\"1\":{\"465\":1}}],[\"它们在备库上可以并行执行\",{\"1\":{\"462\":1}}],[\"它们就可以并行\",{\"1\":{\"461\":1}}],[\"它们有共同的目标\",{\"1\":{\"448\":1}}],[\"它们的驱动表是固定的\",{\"1\":{\"555\":1}}],[\"它们的含义如下\",{\"1\":{\"433\":1,\"542\":1}}],[\"它们的table\",{\"1\":{\"412\":1}}],[\"它们的区别\",{\"1\":{\"352\":1}}],[\"它们的相同点是\",{\"1\":{\"352\":1}}],[\"它们的示意图如下所示\",{\"1\":{\"350\":1}}],[\"它们分别是\",{\"1\":{\"273\":1}}],[\"它所在的数据页就都在内存里了\",{\"1\":{\"342\":1}}],[\"它主要负责mysql功能层面的事情\",{\"1\":{\"325\":1}}],[\"它从mysql5\",{\"1\":{\"317\":1}}],[\"现已废弃\",{\"1\":{\"1647\":1}}],[\"现代处理器指令集架构基本上都会提供\",{\"1\":{\"1479\":1}}],[\"现代操作系统的多路复用api已经不再使用使用select系统调用\",{\"1\":{\"603\":1}}],[\"现代的网络速度比以前要快很多\",{\"1\":{\"392\":1}}],[\"现在的服务器基本都是linux系统\",{\"1\":{\"1987\":1}}],[\"现在直接使用更强大的利器spring\",{\"1\":{\"1982\":1}}],[\"现在已经是最受欢迎的企业级\",{\"1\":{\"1982\":1}}],[\"现在可以不用再学\",{\"1\":{\"1979\":1}}],[\"现在假设说要求使用流的方式求出列表的长度改怎么做呢\",{\"1\":{\"1615\":1}}],[\"现在假设我们在维护一个市民系统\",{\"1\":{\"341\":1}}],[\"现在加了一个元素后立即唤醒阻塞在notempty上的线程\",{\"1\":{\"1503\":1}}],[\"现在广泛使用的是mesa模型\",{\"1\":{\"1483\":1}}],[\"现在我们使用bifunction来实现同样的功能\",{\"1\":{\"1598\":1}}],[\"现在我们回到redisautoconfiguration\",{\"1\":{\"583\":1}}],[\"现在我们就能来验证了\",{\"1\":{\"583\":1}}],[\"现在我们将join\",{\"1\":{\"403\":1}}],[\"现在就可以根据聚簇索引占用的页面数量以及该表记录数的估计值\",{\"1\":{\"548\":1}}],[\"现在就是n+1\",{\"1\":{\"326\":1}}],[\"现在来了一个事务1对该记录的name做出了修改\",{\"1\":{\"542\":1}}],[\"现在还要再去主键索引树上判断id是否存在\",{\"1\":{\"491\":1}}],[\"现在不止是dba有自动化系统\",{\"1\":{\"488\":1}}],[\"现在这个备库上就有了临时库需要的所有binlog了\",{\"1\":{\"485\":1}}],[\"现在这个实例x是另外一个实例y的从库\",{\"1\":{\"468\":1}}],[\"现在要把数据库恢复到这个三个事务操作之前的状态\",{\"1\":{\"484\":1}}],[\"现在要查询`name`\",{\"1\":{\"371\":1}}],[\"现在worker\",{\"1\":{\"461\":2}}],[\"现在越来越多的场景要求将mysql的binlog格式设置为row\",{\"1\":{\"454\":1}}],[\"现在\",{\"1\":{\"402\":1,\"468\":1}}],[\"现在mysql预估需要扫描5073条记录来完成这个查询\",{\"1\":{\"390\":1}}],[\"现在有一个支持邮箱登录的系统\",{\"1\":{\"349\":1}}],[\"现在分到两个页中\",{\"1\":{\"335\":1}}],[\"现在常见的做法也是用全量备份加上应用binlog来实现的\",{\"1\":{\"327\":1}}],[\"现在最常用的存储引擎是innodb\",{\"1\":{\"317\":1}}],[\"现有文档会被删除\",{\"1\":{\"306\":1}}],[\"其类型转换的功能实际上委托给了内部的propertyeditor和conversionservice对象\",{\"1\":{\"1640\":1}}],[\"其地位与收集器相同\",{\"1\":{\"1621\":1}}],[\"其余接口的主要功能如下\",{\"1\":{\"1636\":1}}],[\"其余的异常就会作为被压制的异常\",{\"1\":{\"1619\":1}}],[\"其余三种主要是为了服务端模板引擎渲染\",{\"1\":{\"983\":1,\"1235\":1}}],[\"其目的\",{\"1\":{\"1607\":1}}],[\"其过程不需要cpu的参与\",{\"1\":{\"1578\":1}}],[\"其效率也会线程下降\",{\"1\":{\"1570\":1}}],[\"其效率的提升主要得益于两个方面\",{\"1\":{\"1514\":1}}],[\"其良好跨平台支持也是它的一个优点\",{\"1\":{\"1569\":1}}],[\"其初始化过程也就是对node数组的初始化过程\",{\"1\":{\"1554\":1}}],[\"其初始值为创建该对象时class中的epoch的值\",{\"1\":{\"1485\":1}}],[\"其在线程二rehash后\",{\"1\":{\"1551\":1}}],[\"其内部是用数组存储元素的\",{\"1\":{\"1502\":1}}],[\"其共享资源为临界资源\",{\"1\":{\"1482\":1}}],[\"其缺点是窥探是不可扩展的\",{\"1\":{\"1474\":1}}],[\"其对每个指令都写了一段对应的汇编代码\",{\"1\":{\"1473\":1}}],[\"其后所有待执行的语句都将不会被服务器执行\",{\"1\":{\"1297\":1}}],[\"其后的命令仍然会被继续执行\",{\"1\":{\"1297\":1}}],[\"其原理是哨兵通过发送命令\",{\"1\":{\"1291\":1}}],[\"其原因是\",{\"1\":{\"334\":1}}],[\"其存储作作用域为session\",{\"1\":{\"1218\":1}}],[\"其成本都算是0\",{\"1\":{\"545\":1}}],[\"其他组件按照一定的格式要求配置在这个顶层容器中\",{\"1\":{\"1683\":1}}],[\"其他则交由spring管理\",{\"1\":{\"1659\":1}}],[\"其他竞争失败的线程会讲数值累加到base上\",{\"1\":{\"1480\":1}}],[\"其他要使用该资源的线程必须等待\",{\"1\":{\"1477\":1}}],[\"其他副本必须反映该更改\",{\"1\":{\"1474\":1}}],[\"其他线程无法对segment的hash表做操作\",{\"1\":{\"1553\":1}}],[\"其他线程同样可以完成操作a\",{\"1\":{\"1531\":1}}],[\"其他线程能够看到修改的值\",{\"1\":{\"1471\":1}}],[\"其他线程等待\",{\"1\":{\"633\":1}}],[\"其他请求在等待该请求的执行结果时\",{\"1\":{\"1283\":1}}],[\"其他事务都不能获取该行的锁\",{\"1\":{\"1263\":1}}],[\"其他情况下均会进行缓存\",{\"1\":{\"1182\":1}}],[\"其他scope\",{\"1\":{\"1182\":1}}],[\"其他注解都可以看成是\",{\"1\":{\"1023\":1}}],[\"其他bean引用\",{\"1\":{\"927\":1}}],[\"其他\",{\"1\":{\"900\":1}}],[\"其他的都有相关的示例\",{\"1\":{\"994\":1}}],[\"其他的节点就可以手动连接到最新的主节点\",{\"1\":{\"611\":1}}],[\"其他的读请求则由从库分担\",{\"1\":{\"466\":1}}],[\"其他命令正常执行\",{\"1\":{\"580\":1}}],[\"其他命令可以正常执行\",{\"1\":{\"580\":1}}],[\"其他命令并没有被执行\",{\"1\":{\"580\":1}}],[\"其他级别都用到索引了\",{\"1\":{\"330\":1}}],[\"其它线程并不能操作这个segment对象\",{\"1\":{\"1553\":1}}],[\"其它行跟这个执行序列无关\",{\"1\":{\"447\":1}}],[\"其它方式\",{\"0\":{\"352\":1}}],[\"其次要\",{\"1\":{\"1509\":1}}],[\"其次\",{\"1\":{\"447\":1}}],[\"其实大部分语言的基础知识都是大同小异\",{\"1\":{\"1969\":1}}],[\"其实大多数情况下\",{\"1\":{\"480\":1}}],[\"其实现的原理就是不同的类加载器实例加载的类被认为是不同的类\",{\"1\":{\"1693\":1}}],[\"其实还可以这样\",{\"1\":{\"1617\":1}}],[\"其实对于分组的操作还可以进行二级分组\",{\"1\":{\"1616\":1}}],[\"其实我们也可以这样调用\",{\"1\":{\"1614\":1}}],[\"其实我们也可以直接调用list的sort方法\",{\"1\":{\"1614\":1}}],[\"其实我们还可以使用方法引用的方式\",{\"1\":{\"1603\":1}}],[\"其实中间操作都会返回一个新的stream对象\",{\"1\":{\"1610\":1}}],[\"其实最常见的\",{\"1\":{\"1607\":1}}],[\"其实最简单的办法是让共享变量只有读操作\",{\"1\":{\"1526\":1}}],[\"其实在java\",{\"1\":{\"1601\":1}}],[\"其实这里最关键的就是consumer这个参数\",{\"1\":{\"1595\":1}}],[\"其实myinterface\",{\"1\":{\"1595\":1}}],[\"其实foreach\",{\"1\":{\"1594\":1}}],[\"其实本质上看起来和我们传统的使用迭代器的方式并没有区别\",{\"1\":{\"1593\":1}}],[\"其实际过程是先比较eax的值\",{\"1\":{\"1479\":1}}],[\"其实有一个主线\",{\"1\":{\"1202\":1}}],[\"其实只有singleton和prototype这两个作用域相关的方法\",{\"1\":{\"984\":1}}],[\"其实只要确保trx1已经执行完成就可以执行select语句了\",{\"1\":{\"472\":1}}],[\"其实就是proxyfactory\",{\"1\":{\"1654\":1}}],[\"其实就是向beanfatory中添加各种各样的beandifinition\",{\"1\":{\"1652\":1}}],[\"其实就是myinterface的一个具体实现\",{\"1\":{\"1595\":1}}],[\"其实就是对\",{\"1\":{\"1583\":1}}],[\"其实就是一个用户独享的虚拟内存\",{\"1\":{\"1579\":1}}],[\"其实就是要防止消费者重复消费的问题\",{\"1\":{\"1329\":1}}],[\"其实就是搭建的集群\",{\"1\":{\"633\":1}}],[\"其实就是innodb\",{\"1\":{\"492\":1}}],[\"其实除了这两个成本参数\",{\"1\":{\"557\":1}}],[\"其实相当于3\",{\"1\":{\"556\":1}}],[\"其实相当于2\",{\"1\":{\"556\":1}}],[\"其实直接使用我们前面说过的索引统计数据就可以了\",{\"1\":{\"555\":1}}],[\"其实也就是b+树索引\",{\"1\":{\"553\":1}}],[\"其实已经过了一段时间\",{\"1\":{\"471\":1}}],[\"其实不用等到commit阶段\",{\"1\":{\"465\":1}}],[\"其实seconds\",{\"1\":{\"457\":1}}],[\"其实区别只是多了一条线\",{\"1\":{\"455\":1}}],[\"其实它就是前两种格式的混合\",{\"1\":{\"454\":1}}],[\"其实并不是连接慢\",{\"1\":{\"482\":1}}],[\"其实并不是\",{\"1\":{\"421\":1}}],[\"其实是没有意义的\",{\"1\":{\"1594\":1}}],[\"其实是没问题的\",{\"1\":{\"403\":1}}],[\"其实是无状态的\",{\"1\":{\"1236\":1}}],[\"其实是保存在了内存里\",{\"1\":{\"490\":1}}],[\"其实是让客户端变得更快\",{\"1\":{\"482\":1}}],[\"其实是锁在分区p\",{\"1\":{\"424\":1}}],[\"其实是我们根据数据特征诱导了一下优化器\",{\"1\":{\"348\":1}}],[\"其实\",{\"1\":{\"327\":1,\"334\":1,\"451\":1,\"468\":2,\"481\":2,\"488\":1,\"492\":1}}],[\"其架构模式是插件式的\",{\"1\":{\"317\":1}}],[\"其中最外层的是server\",{\"1\":{\"1683\":1}}],[\"其中最为常用的是innodb和myisam两种\",{\"1\":{\"1260\":1}}],[\"其中类加载过程有加载\",{\"1\":{\"1663\":1}}],[\"其中核心方法就是beanfactory的resolvedependency方法\",{\"1\":{\"1648\":1}}],[\"其中defaultlistablebeanfactory是最重要的实现之一\",{\"1\":{\"1636\":1}}],[\"其中每一个有状态的都会标识一个段的结尾\",{\"1\":{\"1621\":1}}],[\"其中每一项成本的含义\",{\"1\":{\"557\":1}}],[\"其中方法名叫test\",{\"1\":{\"1599\":1}}],[\"其中mappedbytebuffer的作用\",{\"1\":{\"1587\":1}}],[\"其中mget是需要我们知道它的id\",{\"1\":{\"307\":1}}],[\"其中hash1是key1对应的哈希与高位运算的结果\",{\"1\":{\"1550\":1}}],[\"其中的a表示的是中间结果的容器类型\",{\"1\":{\"1618\":1}}],[\"其中的map\",{\"1\":{\"1609\":1}}],[\"其中的biconsumer是接收两个参数\",{\"1\":{\"1608\":1}}],[\"其中的\",{\"1\":{\"1607\":1}}],[\"其中的任意一个进入读就绪状态\",{\"1\":{\"1565\":1}}],[\"其中的哈希桶数组table的size等于2\",{\"1\":{\"1550\":1}}],[\"其中的xml文件\",{\"1\":{\"1065\":1}}],[\"其中会运用到红黑树的插入\",{\"1\":{\"1546\":1}}],[\"其中node具体如下\",{\"1\":{\"1546\":1}}],[\"其中nn可以被替换为01\",{\"1\":{\"558\":1}}],[\"其中单例集合有list\",{\"1\":{\"1538\":1}}],[\"其中单例对象的最为复杂\",{\"1\":{\"1182\":1}}],[\"其中第一个阶段主要是线程t1向线程t2发送终止指令\",{\"1\":{\"1524\":1}}],[\"其中第一种我们已经见过很多次了\",{\"1\":{\"1019\":1}}],[\"其中任意线程成功获取了写锁并更新了数据\",{\"1\":{\"1498\":1}}],[\"其中要称为无用的类\",{\"1\":{\"1443\":1}}],[\"其中用户线程又称本地线程\",{\"1\":{\"1375\":1}}],[\"其中accountnum就是攻击者自己的银行账户\",{\"1\":{\"1201\":1}}],[\"其中applicationcontext相关的aware回调也是基于beanpostprocess实现\",{\"1\":{\"1015\":1}}],[\"其中使用到的工具类\",{\"1\":{\"1043\":1}}],[\"其中bean生命周期与方法映射如下\",{\"1\":{\"1017\":1}}],[\"其中userfactorybean为\",{\"1\":{\"930\":1}}],[\"其中包含了若干个sentinel节点和redis数据节点\",{\"1\":{\"621\":1}}],[\"其中39是待检测记录的条数\",{\"1\":{\"549\":1}}],[\"其中39是预计的二级索引记录数\",{\"1\":{\"549\":1}}],[\"其中39是需要读取的二级索引记录条数\",{\"1\":{\"549\":1}}],[\"其中比较重要的有innodb\",{\"1\":{\"538\":1}}],[\"其中iscandidatecomponent方法表示当前类是否是一个bean\",{\"1\":{\"1647\":1}}],[\"其中id是自增主键字段\",{\"1\":{\"489\":1}}],[\"其中io\",{\"1\":{\"453\":1}}],[\"其中步骤5到主库执行查询语句\",{\"1\":{\"473\":1}}],[\"其中可以直接看出来好处的就是\",{\"1\":{\"454\":1}}],[\"其中一种方式对将哈希值对数组长度取模运算\",{\"1\":{\"1548\":1}}],[\"其中一个要等另一个执行完才能开始执行\",{\"1\":{\"441\":1}}],[\"其中一行的值为1\",{\"1\":{\"433\":1}}],[\"其中k=λn\",{\"1\":{\"403\":1}}],[\"其中\",{\"1\":{\"381\":1,\"405\":1,\"411\":1,\"416\":1,\"420\":1,\"425\":1,\"446\":1,\"457\":1,\"467\":1,\"468\":3,\"472\":1,\"478\":1,\"479\":1,\"491\":1,\"558\":1,\"599\":1,\"1248\":1,\"1546\":1,\"1551\":1,\"1583\":1,\"1969\":1,\"1974\":2,\"1978\":1}}],[\"其中交易记录表tradelog包含交易流水号\",{\"1\":{\"366\":1}}],[\"其中前6位是地址码\",{\"1\":{\"352\":1}}],[\"其中write\",{\"1\":{\"324\":1}}],[\"其中command列显示为\",{\"1\":{\"318\":1}}],[\"其中各项含义\",{\"1\":{\"304\":1}}],[\"所需要的类型是obectfactory或objectprovider的\",{\"1\":{\"1648\":1}}],[\"所需要的类型是optional类型的\",{\"1\":{\"1648\":1}}],[\"所需的io成本就是\",{\"1\":{\"549\":1}}],[\"所返回的spliterator必须也是ordered\",{\"1\":{\"1620\":1}}],[\"所分割出来的每个块的大小是固定的\",{\"1\":{\"1620\":1}}],[\"所创建出来的spliterator还有一个额外的特性\",{\"1\":{\"1620\":1}}],[\"所生成的collector类型是map<k\",{\"1\":{\"1618\":1}}],[\"所能容纳的键值对个数就越多\",{\"1\":{\"1546\":1}}],[\"所能容纳的key\",{\"1\":{\"1546\":1}}],[\"所谓copy\",{\"1\":{\"1527\":1}}],[\"所谓不变性\",{\"1\":{\"1526\":1}}],[\"所谓三次握手\",{\"1\":{\"1425\":1}}],[\"所谓\",{\"1\":{\"1138\":1}}],[\"所谓备库延迟\",{\"1\":{\"457\":1}}],[\"所在的类\",{\"1\":{\"1102\":1}}],[\"所在session\",{\"1\":{\"447\":1}}],[\"所属模块\",{\"1\":{\"1028\":1}}],[\"所索引结构\",{\"1\":{\"351\":1}}],[\"所有select负责的socket\",{\"1\":{\"1565\":1}}],[\"所有方法均是只读的\",{\"1\":{\"1526\":1}}],[\"所有等待线程被唤醒后\",{\"1\":{\"1483\":1}}],[\"所有等待线程拥有相同的等待条件\",{\"1\":{\"1483\":1}}],[\"所有被同步锁\",{\"1\":{\"1438\":1}}],[\"所有mq产品都没有提供主动解决幂等性的机制\",{\"1\":{\"1329\":1}}],[\"所有基础服务可以在整个微服务系统中调用\",{\"1\":{\"1304\":1}}],[\"所有事务依次执行\",{\"1\":{\"1238\":1}}],[\"所有事务都会被分配到同一个worker中\",{\"1\":{\"461\":1}}],[\"所有对数据表的改变都会刷新缓存\",{\"1\":{\"1219\":1}}],[\"所有对表的增删改查都需要先申请mdl读锁\",{\"1\":{\"441\":1}}],[\"所有主从复制的优点\",{\"1\":{\"623\":1}}],[\"所有索引元素不重复\",{\"1\":{\"502\":1}}],[\"所有无主键的innodb表\",{\"1\":{\"495\":1}}],[\"所有读压力都在主库\",{\"1\":{\"470\":1}}],[\"所有lsn小于等于160的redo\",{\"1\":{\"451\":1}}],[\"所有\",{\"1\":{\"447\":2}}],[\"所有的请求都会经过dispatcherservlet\",{\"1\":{\"1657\":1}}],[\"所有的非懒加载的单例bean都创建完成之后\",{\"1\":{\"1647\":1}}],[\"所有的流管道处理器都会得到调用\",{\"1\":{\"1619\":1}}],[\"所有的关闭处理器都会得到调用而无论它之前的关闭处理器是否抛出了异常\",{\"1\":{\"1619\":1}}],[\"所有的方法一定会返回collectorimpl类型\",{\"1\":{\"1616\":1}}],[\"所有的方法在接口中不能有实现\",{\"1\":{\"1345\":1}}],[\"所有的类默认已经有了这个方法\",{\"1\":{\"1594\":1}}],[\"所有的线程栈和堆都分布在主内存中\",{\"1\":{\"1473\":1}}],[\"所有的数据都是通过\",{\"1\":{\"1583\":1}}],[\"所有的数据都存储在内存当中\",{\"1\":{\"1292\":1}}],[\"所有的数据变更操作都会被挂起\",{\"1\":{\"1263\":1}}],[\"所有的java类均继承\",{\"1\":{\"1075\":1}}],[\"所有的命令都不执行\",{\"1\":{\"580\":1}}],[\"所有的查询都会出现脏读的\",{\"1\":{\"497\":1}}],[\"所有的申请自增主键的动作都是申请后就释放锁\",{\"1\":{\"492\":1}}],[\"所有的检测逻辑都需要一个超时时间n\",{\"1\":{\"478\":1}}],[\"所有的多线程复制都符合下面的这个模型\",{\"1\":{\"460\":1}}],[\"所有的操作需要行锁的都是在事务提交的时候才会释放\",{\"1\":{\"443\":1}}],[\"所有的更新操作都要先判断这个操作是否违反唯一性约束\",{\"1\":{\"343\":1}}],[\"所有引擎都可以使用\",{\"1\":{\"325\":1}}],[\"所有跨存储引擎的功能都在这一层实现\",{\"1\":{\"317\":1}}],[\"所以xml的标签和源码一一对应\",{\"1\":{\"1683\":1}}],[\"所以spring容器中要存在sqlsessionfactory类型的bean或者sqlsessiontemplate类型的bean\",{\"1\":{\"1653\":1}}],[\"所以spring会自动调用set方法\",{\"1\":{\"1653\":1}}],[\"所以spring在启动时会调用mapperscannerregistrar类中的registerbeandefinitions方法\",{\"1\":{\"1653\":1}}],[\"所以spring中对类的元数据做了抽象\",{\"1\":{\"1646\":1}}],[\"所以defaultlistablebeanfactory的功能很强大\",{\"1\":{\"1636\":1}}],[\"所以dubbo协议成为了dubbo框架中的默认协议\",{\"1\":{\"637\":1}}],[\"所以无需定义finisher\",{\"1\":{\"1618\":1}}],[\"所以无需说明item的类型\",{\"1\":{\"1597\":1}}],[\"所以直接进入到第二种情况\",{\"1\":{\"1617\":1}}],[\"所以直接更新磁盘文件里的数据性能会很差\",{\"1\":{\"543\":1}}],[\"所以设计者直接将这个类作为一个静态的内部类\",{\"1\":{\"1616\":1}}],[\"所以编译器没有办法准确的推断出类型\",{\"1\":{\"1614\":1}}],[\"所以后面的就不再执行了\",{\"1\":{\"1612\":1}}],[\"所以程序会无限的运行下去\",{\"1\":{\"1610\":1}}],[\"所以流会被正常的调用执行\",{\"1\":{\"1610\":1}}],[\"所以创建了student的实例\",{\"1\":{\"1600\":1}}],[\"所以左边的括号是空值\",{\"1\":{\"1595\":1}}],[\"所以满足函数式接口的定义\",{\"1\":{\"1594\":1}}],[\"所以第一步先校验key\",{\"1\":{\"1554\":1}}],[\"所以第二种方法就是\",{\"1\":{\"348\":1}}],[\"所以hashentry可以构成一个链表\",{\"1\":{\"1553\":1}}],[\"所以key3\",{\"1\":{\"1550\":1}}],[\"所以为什么是函数式接口呢\",{\"1\":{\"1595\":1}}],[\"所以为每个请求创建一个新的线程并不适合高并发场景\",{\"1\":{\"1533\":1}}],[\"所以为了避免队列过大造成机器负载或者内存爆满的情况出现\",{\"1\":{\"1503\":1}}],[\"所以自然也就没有并发问题\",{\"1\":{\"1528\":1}}],[\"所以函数式编程的所有的修改操作都需要copy\",{\"1\":{\"1527\":1}}],[\"所以将读操作的性能发挥到了极致\",{\"1\":{\"1527\":1}}],[\"所以将这个参数设置成2跟设置0的性能相差并不多\",{\"1\":{\"451\":1}}],[\"所以linkedblockingqueue也被称作无界队列\",{\"1\":{\"1503\":1}}],[\"所以生产者和消费者都可以是多线程的\",{\"1\":{\"1501\":1}}],[\"所以一般我们采用的方法是设置一个标志位\",{\"1\":{\"1524\":1}}],[\"所以一旦满了就无法再往里放数据了\",{\"1\":{\"1501\":1}}],[\"所以一个表中只能有一个聚簇索引\",{\"1\":{\"1266\":1}}],[\"所以应该允许多个线程同时读取共享资源\",{\"1\":{\"1498\":1}}],[\"所以cyclicbarrier能处理更为复杂的业务场景\",{\"1\":{\"1496\":1}}],[\"所以count\",{\"1\":{\"399\":1}}],[\"所以调用condition\",{\"1\":{\"1493\":2}}],[\"所以循环校验条件\",{\"1\":{\"1483\":1}}],[\"所以跨代引用的数量不会多\",{\"1\":{\"1434\":1}}],[\"所以他们使用的端口也是不一样的\",{\"1\":{\"1424\":1}}],[\"所以每次只能有一个线程来访问map\",{\"1\":{\"1401\":1}}],[\"所以每个单点区间都需要查找一遍对应的二级索引记录数\",{\"1\":{\"549\":1}}],[\"所以都会加锁\",{\"1\":{\"1399\":1}}],[\"所以它的特性值是\",{\"1\":{\"1618\":1}}],[\"所以它的操作对象是数组和可以迭代器的结合\",{\"1\":{\"1353\":1}}],[\"所以它每次返回的一定是一个新的结果容器\",{\"1\":{\"1608\":1}}],[\"所以它只能猜这10573记录里有多少条记录满足order\",{\"1\":{\"554\":1}}],[\"所以快照持久化期间修改的数据不会保存\",{\"1\":{\"1290\":1}}],[\"所以获取到锁的进程有可能还没有执行expire指令\",{\"1\":{\"1288\":1}}],[\"所以被称为懒汉式\",{\"1\":{\"1191\":1}}],[\"所以采用元注解\",{\"1\":{\"1023\":1}}],[\"所以实例化的时候会报错\",{\"1\":{\"946\":1}}],[\"所以实例x就会直接跳过这个事务\",{\"1\":{\"468\":1}}],[\"所以jedis是无法生效的\",{\"1\":{\"583\":1}}],[\"所以事务中的命令在加入时都没有被执行\",{\"1\":{\"579\":1}}],[\"所以bitmaps是一串从左到右的二进制串\",{\"1\":{\"578\":1}}],[\"所以binlog里面对表t2的更新日志只有两种情况\",{\"1\":{\"492\":1}}],[\"所以binlog是statement格式也是可以的\",{\"1\":{\"465\":1}}],[\"所以binlog得write和fsync间的间隔时间端\",{\"1\":{\"451\":1}}],[\"所以zset命令也可以使用\",{\"1\":{\"576\":1}}],[\"所以添加\",{\"1\":{\"572\":1}}],[\"所以命令也就分为了lxxx和rlll两类\",{\"1\":{\"571\":1}}],[\"所以会影响服务的响应速度以及吞吐量\",{\"1\":{\"1424\":1}}],[\"所以会返回\",{\"1\":{\"569\":2}}],[\"所以会直接把临时表temp\",{\"1\":{\"411\":1}}],[\"所以也非常的重要\",{\"1\":{\"1614\":1}}],[\"所以也不需要再统计一遍在索引列后加上主键值的不重复值有多少\",{\"1\":{\"558\":1}}],[\"所以也许一个批量下线机器的操作\",{\"1\":{\"488\":1}}],[\"所以该值默认是0\",{\"1\":{\"557\":1}}],[\"所以关于这些操作对应的成本常数就存储在了server\",{\"1\":{\"557\":1}}],[\"所以此时使用s1作为驱动表的总成本就是\",{\"1\":{\"555\":1}}],[\"所以想要得到最优的查询方案只需要分别为驱动表和被驱动表选择成本最低的访问方法\",{\"1\":{\"555\":1}}],[\"所以总共需要回表的记录数就是\",{\"1\":{\"553\":1}}],[\"所以总的扫描行数是m+n\",{\"1\":{\"403\":1}}],[\"所以提供了一个系统变量eq\",{\"1\":{\"553\":1}}],[\"所以选择idx\",{\"1\":{\"551\":1}}],[\"所以访问这3个范围区间的二级索引付出的io成本就是\",{\"1\":{\"549\":1}}],[\"所以本例中使用idx\",{\"1\":{\"549\":1}}],[\"所以本例中使用id\",{\"1\":{\"549\":1}}],[\"所以回表操作带来的io成本就是\",{\"1\":{\"549\":1}}],[\"所以读取这39条二级索引记录需要付出的cpu成本就是\",{\"1\":{\"549\":1}}],[\"所以计算页b和页c之间有多少页面就相当于计算它们父节点\",{\"1\":{\"549\":1}}],[\"所以计算全表扫描的代价需要两个信息\",{\"1\":{\"548\":1}}],[\"所以相当于访问这个范围区间的二级索引付出的io成本就是\",{\"1\":{\"549\":1}}],[\"所以全表扫描的总成本\",{\"1\":{\"548\":1}}],[\"所以order\",{\"1\":{\"548\":1}}],[\"所以并没有什么用\",{\"1\":{\"555\":1}}],[\"所以并没有统一的索引标准\",{\"1\":{\"334\":1}}],[\"所以并不会对这个接口的抽象方法的总数有影响\",{\"1\":{\"1595\":1}}],[\"所以并不会使用索引合并\",{\"1\":{\"550\":1}}],[\"所以并不能确定一个单点区间对应的二级索引记录的条数有多少\",{\"1\":{\"553\":1}}],[\"所以并不能使用索引\",{\"1\":{\"547\":1}}],[\"所以mvcc可以为数据库解决一下问题\",{\"1\":{\"541\":1}}],[\"所以mysql简单的认为不管这个块有没有加载到内存中\",{\"1\":{\"557\":1}}],[\"所以mysql干脆提出了一些所谓的启发式规则\",{\"1\":{\"556\":1}}],[\"所以mysql最终选择索引扫描\",{\"1\":{\"519\":1}}],[\"所以mysql最终选择全表扫描\",{\"1\":{\"519\":1}}],[\"所以mysql选错索引肯定是在判断扫描行数的时候出现了问题\",{\"1\":{\"347\":1}}],[\"所以内存中的判断次数是100\",{\"1\":{\"525\":1}}],[\"所以可以强转成功\",{\"1\":{\"1618\":2}}],[\"所以可以作为comparator这个lambda表达式的方法体\",{\"1\":{\"1603\":1}}],[\"所以可以完成调用\",{\"1\":{\"1593\":1}}],[\"所以可以让排序和分页操作先查出主键\",{\"1\":{\"522\":1}}],[\"所以可能在拿到io资源的时候就可以提交成功\",{\"1\":{\"478\":1}}],[\"所以优化器放弃使用索引\",{\"1\":{\"522\":1}}],[\"所以上文中脏读的例子就是一个必现的bug\",{\"1\":{\"499\":1}}],[\"所以只需从符合二级索引范围区间的记录中猜有多少条记录符合order\",{\"1\":{\"554\":1}}],[\"所以只要我们通过根节点获得了最左边的叶子节点\",{\"1\":{\"548\":1}}],[\"所以只要当前事务在其他事务提交更新之前使用过快照读\",{\"1\":{\"542\":1}}],[\"所以只读事务优化后\",{\"1\":{\"497\":1}}],[\"所以只能采用这种方法来创建从库和新主库的主备关系\",{\"1\":{\"467\":1}}],[\"所以只能选择\",{\"1\":{\"347\":1}}],[\"所以row\",{\"1\":{\"495\":1}}],[\"所以id=5到id=7就被浪费掉了\",{\"1\":{\"492\":1}}],[\"所以id=2这一行并没有插入成功\",{\"1\":{\"491\":1}}],[\"所以innodb在设计时\",{\"1\":{\"476\":1}}],[\"所以报duplicate\",{\"1\":{\"491\":1}}],[\"所以打开这个统计功能是有性能损耗的\",{\"1\":{\"479\":1}}],[\"所以系统可能已经出问题了\",{\"1\":{\"478\":1}}],[\"所以系统认为只扫描了一行\",{\"1\":{\"350\":1}}],[\"所以查询性能更好\",{\"1\":{\"469\":1}}],[\"所以查询语句where部分要判断id\",{\"1\":{\"352\":1}}],[\"所以对部署\",{\"1\":{\"1304\":1}}],[\"所以对于两表连接查询来说\",{\"1\":{\"554\":1}}],[\"所以对之后的修改不可见\",{\"1\":{\"542\":1}}],[\"所以对ha系统的开发人员来说\",{\"1\":{\"468\":1}}],[\"所以对更新性能的提升是会很明显的\",{\"1\":{\"343\":1}}],[\"所以主备切换的复杂性也相应增加了\",{\"1\":{\"466\":1}}],[\"所以主备库选用相同规格的机器\",{\"1\":{\"457\":1}}],[\"所以按表分发\",{\"1\":{\"461\":1}}],[\"所以要使用row格式\",{\"1\":{\"454\":1}}],[\"所以要简单地对比这两个机制在提升性能上地收益的话\",{\"1\":{\"345\":1}}],[\"所以从库b\",{\"1\":{\"468\":1}}],[\"所以从结果里面可以看到各个字段的值\",{\"1\":{\"454\":1}}],[\"所以从性能和存储空间方面考量\",{\"1\":{\"335\":1}}],[\"所以速度比较快\",{\"1\":{\"450\":1}}],[\"所以q2和q3就是应该看到这两个事务的操作效果\",{\"1\":{\"446\":1}}],[\"所以v3的值也是2\",{\"1\":{\"433\":1}}],[\"所以插入失败\",{\"1\":{\"414\":1}}],[\"所以最后只会有一行不一致\",{\"1\":{\"459\":1}}],[\"所以最后得到的结果集也是按照主键id递增顺序的\",{\"1\":{\"404\":1}}],[\"所以最后这6位就提供了足够的区分度\",{\"1\":{\"352\":1}}],[\"所以我们可以自定义线程的终止标志位用于终止线程\",{\"1\":{\"1524\":1}}],[\"所以我们可以根据是否需要扩容来选择合适的队列\",{\"1\":{\"1509\":1}}],[\"所以我们可以认为\",{\"1\":{\"404\":1}}],[\"所以我们redis默认的配置就是rdb持久化\",{\"1\":{\"593\":1}}],[\"所以我们优化的重点就是下面两个部分\",{\"1\":{\"555\":1}}],[\"所以我们看到sort\",{\"1\":{\"421\":1}}],[\"所以我们称之为\",{\"1\":{\"401\":1}}],[\"所以运行多个小查询现在已经不是大问题了\",{\"1\":{\"392\":1}}],[\"所以没有产生using\",{\"1\":{\"378\":1}}],[\"所以尝试在book表和phone表上添加索引\",{\"1\":{\"363\":1}}],[\"所以如果5\",{\"1\":{\"553\":1}}],[\"所以如果等待超时\",{\"1\":{\"473\":1}}],[\"所以如果要在同一个库下创建两个同名的临时表\",{\"1\":{\"412\":1}}],[\"所以如果单行很大\",{\"1\":{\"355\":1}}],[\"所以如果长连接累积下来\",{\"1\":{\"318\":1}}],[\"所以图中的examined\",{\"1\":{\"354\":1}}],[\"所以同一个县的人的身份证号前6位一般会是相同的\",{\"1\":{\"352\":1}}],[\"所以需要先等待一会\",{\"1\":{\"1554\":1}}],[\"所以需要实现子类\",{\"1\":{\"1108\":1}}],[\"所以需要持久化\",{\"1\":{\"565\":1}}],[\"所以需要将聚簇索引对应的页面加载到内存中\",{\"1\":{\"548\":1}}],[\"所以需要在从库b刚开始接到新主库a\",{\"1\":{\"467\":1}}],[\"所以需要找一个地方把这个值定期地持久化存储起来\",{\"1\":{\"397\":1}}],[\"所以需要做类型转换\",{\"1\":{\"367\":1}}],[\"所以需要预先设定一个可以接受的损失比例\",{\"1\":{\"350\":1}}],[\"所以需要扫描50001行\",{\"1\":{\"347\":1}}],[\"所以即使扫描的行数多\",{\"1\":{\"348\":1}}],[\"所以不要使用这些特性值之外的值\",{\"1\":{\"1620\":1}}],[\"所以不存在频繁创建对象的问题\",{\"1\":{\"1528\":1}}],[\"所以不存在线程安全问题\",{\"1\":{\"1236\":1}}],[\"所以不同阻塞队列的容量是千差万别的\",{\"1\":{\"1509\":1}}],[\"所以不会对用户进程产生任何block\",{\"1\":{\"1566\":1}}],[\"所以不会覆盖\",{\"1\":{\"1367\":1}}],[\"所以不会用到索引\",{\"1\":{\"547\":1}}],[\"所以不会增加扫描行数\",{\"1\":{\"420\":1}}],[\"所以不论是在innodb\",{\"1\":{\"497\":1}}],[\"所以不需要这个额外的操作\",{\"1\":{\"410\":1}}],[\"所以不管是n是20还是8\",{\"1\":{\"347\":1}}],[\"所以不得不回表\",{\"1\":{\"337\":1}}],[\"所以当变更的数据行超过1\",{\"1\":{\"347\":1}}],[\"所以当在高并发环境下使用乐观锁机制修改文档时\",{\"1\":{\"306\":1}}],[\"所以这里调用list的add\",{\"1\":{\"1608\":1}}],[\"所以这里使用了prepare+execute的方法\",{\"1\":{\"422\":1}}],[\"所以这段代码也可以这么写\",{\"1\":{\"1607\":1}}],[\"所以这就出现了triple协议\",{\"1\":{\"637\":1}}],[\"所以这套方案很有效地解决了redis高可用的问题\",{\"1\":{\"621\":1}}],[\"所以这时cpu的每个核心工作基本都是满负荷的\",{\"1\":{\"1510\":1}}],[\"所以这时候session\",{\"1\":{\"481\":1}}],[\"所以这时候加上这条update语句也很合理\",{\"1\":{\"447\":1}}],[\"所以这时日志丢了也不会有损失\",{\"1\":{\"451\":1}}],[\"所以这两个开源分支目前都支持ddl\",{\"1\":{\"441\":1}}],[\"所以这两个表在备库的应用线程里不会冲突\",{\"1\":{\"413\":1}}],[\"所以这条update语句会锁住整个表t上的读\",{\"1\":{\"424\":1}}],[\"所以这种改写得满足以下两个条件\",{\"1\":{\"522\":1}}],[\"所以这种join尽量不要使用\",{\"1\":{\"403\":1}}],[\"所以这种方式还能避免占用内存\",{\"1\":{\"343\":1}}],[\"所以这个类的主要作用就是开启自动代理的作用\",{\"1\":{\"1655\":1}}],[\"所以这个泛型是成立的\",{\"1\":{\"1619\":1}}],[\"所以这个条件一定会为true\",{\"1\":{\"1554\":1}}],[\"所以这个值无用\",{\"1\":{\"555\":1}}],[\"所以这个查询可能使用到idx\",{\"1\":{\"555\":1}}],[\"所以这个查询可能会用到idx\",{\"1\":{\"555\":1}}],[\"所以这个查询也不用把4000行全都读一遍\",{\"1\":{\"356\":1}}],[\"所以这个统计过程页不是很耗费性能\",{\"1\":{\"549\":1}}],[\"所以这个过程的性能消耗是可以忽略不计的\",{\"1\":{\"549\":1}}],[\"所以这个过程就被改写成\",{\"1\":{\"368\":1}}],[\"所以这个时候索引下推并不会减少查询全行数据的效果\",{\"1\":{\"518\":1}}],[\"所以这个命令可能是unsafe的\",{\"1\":{\"454\":1}}],[\"所以这个写盘的动作只是write\",{\"1\":{\"451\":1}}],[\"所以这一行c的值是0\",{\"1\":{\"327\":1}}],[\"所以在学习算法之前\",{\"1\":{\"1970\":1}}],[\"所以在定义函数式接口的时候\",{\"1\":{\"1594\":1}}],[\"所以在rehash的过程中\",{\"1\":{\"1553\":1}}],[\"所以在新增数据的时候\",{\"1\":{\"1553\":1}}],[\"所以在实际工作中\",{\"1\":{\"1527\":1}}],[\"所以在多线程竞争频繁的情况下\",{\"1\":{\"1485\":1}}],[\"所以在查询操作时\",{\"1\":{\"542\":1}}],[\"所以在session\",{\"1\":{\"497\":1}}],[\"所以在备库b傻姑娘执行的检测命令\",{\"1\":{\"478\":1}}],[\"所以在出现主备切换\",{\"1\":{\"469\":1}}],[\"所以在确定位点的时候\",{\"1\":{\"467\":1}}],[\"所以在主备切换的时候\",{\"1\":{\"457\":1}}],[\"所以在t1时刻\",{\"1\":{\"424\":1}}],[\"所以在这个事务提交之前\",{\"1\":{\"434\":1}}],[\"所以在这个session结束的时候\",{\"1\":{\"410\":1}}],[\"所以在这种算法下\",{\"1\":{\"403\":1}}],[\"所以在被驱动表上查一行的时间复杂度是2\",{\"1\":{\"401\":1}}],[\"所以在不同类型的应用压力下\",{\"1\":{\"388\":1}}],[\"所以在一个数据页做merge之前\",{\"1\":{\"344\":1}}],[\"所以在计算平均性能差异的时候\",{\"1\":{\"342\":1}}],[\"所以在使用的过程中要尽量减少建立连接的动作\",{\"1\":{\"318\":1}}],[\"所以说redis单条指令保证原子性\",{\"1\":{\"580\":1}}],[\"所以说\",{\"1\":{\"342\":1,\"1561\":1}}],[\"所以使用覆盖索引是一个常用的性能优化手段\",{\"1\":{\"338\":1}}],[\"所以就需要根据实际情况确定哈希桶数组的大小\",{\"1\":{\"1546\":1}}],[\"所以就多扫描了一次t1表\",{\"1\":{\"525\":1}}],[\"所以就使用差一点儿的机器\",{\"1\":{\"457\":1}}],[\"所以就不用考虑其它索引叶子节点大小的问题了\",{\"1\":{\"335\":1}}],[\"所以就可以将具体的内容读取出来了\",{\"1\":{\"299\":1}}],[\"所以哈希索引做区间查询的速度是很慢的\",{\"1\":{\"332\":1}}],[\"所以长度就是8\",{\"1\":{\"330\":1}}],[\"所以很快\",{\"1\":{\"330\":1}}],[\"所以\",{\"1\":{\"327\":1,\"344\":1,\"347\":1,\"351\":1,\"361\":1,\"387\":1,\"388\":1,\"396\":1,\"401\":1,\"403\":1,\"410\":1,\"412\":1,\"413\":2,\"417\":1,\"422\":1,\"424\":1,\"433\":1,\"443\":1,\"444\":1,\"447\":1,\"451\":2,\"454\":3,\"455\":1,\"457\":4,\"462\":1,\"467\":1,\"468\":1,\"481\":2,\"482\":1,\"484\":2,\"491\":1,\"492\":1,\"497\":2,\"555\":1,\"577\":1,\"1503\":1,\"1510\":1,\"1516\":1,\"1550\":1,\"1565\":1,\"1592\":1,\"1597\":1,\"1600\":1,\"1606\":1,\"1607\":1}}],[\"所以恢复这一行c的值是1\",{\"1\":{\"327\":1}}],[\"涵盖mysql的大多数核心服务功能\",{\"1\":{\"317\":1}}],[\"优雅的处理集合相关的问题\",{\"1\":{\"1607\":1}}],[\"优雅的方式是让java线程自己执行完run\",{\"1\":{\"1524\":1}}],[\"优雅的停止线程\",{\"1\":{\"1477\":1}}],[\"优雅关闭相关线程组资源\",{\"1\":{\"1226\":2}}],[\"优势是速度快\",{\"1\":{\"426\":1}}],[\"优先考虑注入不是自己的那个bean\",{\"1\":{\"1648\":1}}],[\"优先级\",{\"1\":{\"1648\":1}}],[\"优先级队列采用二叉堆的数据结构\",{\"1\":{\"1506\":1}}],[\"优先级是倒数第四位的\",{\"1\":{\"966\":1}}],[\"优先队列排序地示意图如下\",{\"1\":{\"421\":1}}],[\"优先优化nestedloop的内层循环\",{\"1\":{\"364\":1}}],[\"优化了高位运算的算法\",{\"1\":{\"1548\":1}}],[\"优化了高位运算的hash算法\",{\"1\":{\"1359\":1}}],[\"优化genericconverter接口\",{\"0\":{\"1090\":1}}],[\"优化原则\",{\"1\":{\"525\":1}}],[\"优化为\",{\"1\":{\"525\":1}}],[\"优化总结\",{\"1\":{\"520\":1}}],[\"优化本篇一开始的语句\",{\"1\":{\"422\":1}}],[\"优化后的group\",{\"1\":{\"417\":1}}],[\"优化的关键是让排序时返回的字段经可能少\",{\"1\":{\"522\":1}}],[\"优化的常见做法是\",{\"1\":{\"406\":1}}],[\"优化的方式通常有两种\",{\"1\":{\"368\":1}}],[\"优化\",{\"0\":{\"395\":1,\"404\":1,\"419\":1},\"1\":{\"464\":1}}],[\"优化查询的目的就是减少和消除这些操作所花费的时间\",{\"1\":{\"381\":1}}],[\"优化order\",{\"1\":{\"356\":1}}],[\"优化器需要从符合二级索引范围内区间的记录中猜有多少条记录符合条件order\",{\"1\":{\"554\":1}}],[\"优化器需要计算二级索引的某个范围区间到底包含多少条记录\",{\"1\":{\"549\":1}}],[\"优化器阶段完成后\",{\"1\":{\"514\":1}}],[\"优化器会放弃走树搜索功能\",{\"1\":{\"367\":1,\"368\":1}}],[\"优化器会估算这两个选择的代价\",{\"1\":{\"347\":1}}],[\"优化器对比索引大小后发现\",{\"1\":{\"366\":1}}],[\"优化器可以选择遍历主键索引\",{\"1\":{\"366\":1}}],[\"优化器并不是要放弃使用这个索引\",{\"1\":{\"366\":1}}],[\"优化器还会结合是否使用临时表\",{\"1\":{\"347\":1}}],[\"优化器选择索引的目的\",{\"1\":{\"347\":1}}],[\"优化器逻辑\",{\"0\":{\"347\":1}}],[\"优化器也选择了索引a\",{\"1\":{\"346\":1}}],[\"优化器的阶段完成后\",{\"1\":{\"321\":1}}],[\"优化器是在表里面有多个索引的时候\",{\"1\":{\"321\":1,\"514\":1}}],[\"优化器\",{\"0\":{\"321\":1,\"514\":1},\"1\":{\"317\":1}}],[\"优点和缺点\",{\"0\":{\"590\":1,\"593\":1}}],[\"优点\",{\"0\":{\"623\":1},\"1\":{\"308\":1,\"589\":1,\"590\":1,\"593\":1,\"1191\":1,\"1192\":1,\"1193\":1,\"1194\":1,\"1195\":1,\"1270\":1,\"1327\":1}}],[\"返回对于遍历可能会遇到的元中的元素的数量的估算值\",{\"1\":{\"1620\":1}}],[\"返回流中元素的分割迭代器\",{\"1\":{\"1619\":1}}],[\"返回针对于流中元素的迭代器\",{\"1\":{\"1619\":1}}],[\"返回了supplier\",{\"1\":{\"1617\":1}}],[\"返回了流中student的姓名字段\",{\"1\":{\"1613\":1}}],[\"返回map对象\",{\"1\":{\"1613\":1}}],[\"返回r类型的结果\",{\"1\":{\"1609\":1}}],[\"返回值\",{\"1\":{\"1606\":1}}],[\"返回值的特性正好与构造方法的作用不谋而合\",{\"1\":{\"1606\":1}}],[\"返回值是另一个函数的情况是非常常见的\",{\"1\":{\"1593\":1}}],[\"返回值为0\",{\"1\":{\"1498\":2}}],[\"返回值为1\",{\"1\":{\"1498\":1}}],[\"返回原来的值\",{\"1\":{\"1503\":1,\"1554\":1}}],[\"返回原值\",{\"1\":{\"1503\":2}}],[\"返回头部\",{\"1\":{\"1502\":2}}],[\"返回特定值\",{\"1\":{\"1501\":1}}],[\"返回null\",{\"1\":{\"1501\":1,\"1620\":1}}],[\"返回true\",{\"1\":{\"1501\":1}}],[\"返回队首元素\",{\"1\":{\"1500\":1}}],[\"返回并删除队首元素\",{\"1\":{\"1500\":2}}],[\"返回false\",{\"1\":{\"1500\":1,\"1501\":1}}],[\"返回内存中的value值\",{\"1\":{\"1479\":1}}],[\"返回期望值e\",{\"1\":{\"1479\":1}}],[\"返回客户端响应\",{\"1\":{\"1256\":1}}],[\"返回statelessop的匿名内部类对象\",{\"1\":{\"1622\":1}}],[\"返回spliterator和它的元素特性值的集合\",{\"1\":{\"1620\":1}}],[\"返回spring应用上下文底层beanfactory\",{\"1\":{\"1163\":1}}],[\"返回score在\",{\"1\":{\"574\":1}}],[\"返回字符串里面第一个被设置为1或者0的bit位\",{\"1\":{\"578\":1}}],[\"返回输入的各个元素\",{\"1\":{\"577\":1}}],[\"返回一个额外带有关闭处理器的流\",{\"1\":{\"1619\":1}}],[\"返回一个无序的流\",{\"1\":{\"1619\":1}}],[\"返回一个等价的并行流\",{\"1\":{\"1619\":1}}],[\"返回一个等价的串行流\",{\"1\":{\"1619\":1}}],[\"返回一个boolean值类型的函数式接口\",{\"1\":{\"1599\":1}}],[\"返回一个或多个位置元素的geohash表示\",{\"1\":{\"576\":1}}],[\"返回一个结果\",{\"1\":{\"317\":1,\"1598\":2}}],[\"返回两个给定位置之间的距离\",{\"1\":{\"576\":1}}],[\"返回成员m7索引\",{\"1\":{\"574\":1}}],[\"返回集合中\",{\"1\":{\"574\":1}}],[\"返回集合中分数在\",{\"1\":{\"574\":1}}],[\"返回集合中所有的成员\",{\"1\":{\"572\":1}}],[\"返回排序结果的\",{\"1\":{\"574\":1}}],[\"返回所有成员\",{\"1\":{\"574\":1}}],[\"返回所有集合的并集\",{\"1\":{\"572\":1}}],[\"返回所有集合的交集\",{\"1\":{\"572\":1}}],[\"返回所有集合的差集\",{\"1\":{\"572\":1}}],[\"返回有序集合中指定成员的排名\",{\"1\":{\"574\":1}}],[\"返回有序集合中指定成员的索引\",{\"1\":{\"574\":1}}],[\"返回有序集中指定字典区间内的成员\",{\"1\":{\"574\":1}}],[\"返回有序集中指定分数区间内的成员\",{\"1\":{\"574\":1}}],[\"返回有序集中指定区间内的成员\",{\"1\":{\"574\":1}}],[\"返回有序集中\",{\"1\":{\"574\":1}}],[\"返回1\",{\"1\":{\"572\":1}}],[\"返回0\",{\"1\":{\"474\":1,\"572\":1,\"573\":1}}],[\"返回前面多少条记录\",{\"1\":{\"429\":1}}],[\"返回记录\",{\"1\":{\"429\":1}}],[\"返回给定\",{\"1\":{\"577\":1}}],[\"返回给客户端\",{\"1\":{\"420\":1}}],[\"返回给server层\",{\"1\":{\"399\":1}}],[\"返回的sink会接收一个元素\",{\"1\":{\"1623\":1}}],[\"返回的sink\",{\"1\":{\"1623\":1}}],[\"返回的是k类型\",{\"1\":{\"1618\":1}}],[\"返回的是一个空的集合\",{\"1\":{\"1618\":1}}],[\"返回的是一个optional对象\",{\"1\":{\"1610\":1}}],[\"返回的collector是对流中的每一个元素执行传入的整型值函数\",{\"1\":{\"1618\":1}}],[\"返回的df是不同的\",{\"1\":{\"1528\":1}}],[\"返回的成功的行数值可以作为加锁成功的依据\",{\"1\":{\"1498\":1}}],[\"返回的永远是同一个bean\",{\"1\":{\"989\":1}}],[\"返回的对象都是经过cglib代理的对象\",{\"1\":{\"987\":1}}],[\"返回的结果如图所示\",{\"1\":{\"416\":1}}],[\"返回的行数\",{\"1\":{\"387\":1}}],[\"返回结果但不抛出异常\",{\"1\":{\"1501\":1}}],[\"返回结果的\",{\"1\":{\"574\":1}}],[\"返回结果给客户端\",{\"1\":{\"520\":1}}],[\"返回结果\",{\"1\":{\"414\":1,\"1517\":1}}],[\"返回结果中key字段显式\",{\"1\":{\"347\":1}}],[\"返回结果中包含了每一条操作执行的结果\",{\"1\":{\"307\":1}}],[\"返回本表和关联表某个值匹配的所有行\",{\"1\":{\"330\":1}}],[\"湖南\",{\"1\":{\"309\":1}}],[\"就搞的懂这么难的东西\",{\"1\":{\"1972\":1}}],[\"就适当降低该值\",{\"1\":{\"1664\":1}}],[\"就实现层面来说\",{\"1\":{\"1659\":1}}],[\"就确定了哪些对象是需要生成代理对象的\",{\"1\":{\"1654\":1}}],[\"就确保了主库上执行的这个查询结果一定包含了trx1的数据\",{\"1\":{\"473\":1}}],[\"就注册到depentbeanmap中\",{\"1\":{\"1647\":1}}],[\"就正式进入的流源码的分析\",{\"1\":{\"1620\":1}}],[\"就执行mappingfunction\",{\"1\":{\"1618\":1}}],[\"就像reduce一样\",{\"1\":{\"1608\":1}}],[\"就像我们的第一个例子一样\",{\"1\":{\"348\":1}}],[\"就顺利的同时包含了较小的值和较大的值\",{\"1\":{\"1607\":1}}],[\"就变成了\",{\"1\":{\"1601\":1}}],[\"就变成单线程复制了\",{\"1\":{\"461\":1}}],[\"就通知用户进程\",{\"1\":{\"1565\":1}}],[\"就帮助其扩容\",{\"1\":{\"1554\":1}}],[\"就调用扩容方法\",{\"1\":{\"1554\":1}}],[\"就调用nanosleep函数进入sleep状态\",{\"1\":{\"481\":1}}],[\"就扩充为原来的2倍\",{\"1\":{\"1550\":1}}],[\"就进行扩容操作\",{\"1\":{\"1549\":1}}],[\"就停止处理\",{\"1\":{\"1531\":1}}],[\"就消耗那一个结果\",{\"1\":{\"1518\":1}}],[\"就入队\",{\"1\":{\"1503\":1}}],[\"就阻塞在notfull上等待被其它线程唤醒\",{\"1\":{\"1503\":1}}],[\"就使用唯一的构造方法\",{\"1\":{\"1650\":1}}],[\"就使用那一个结果\",{\"1\":{\"1518\":1}}],[\"就使用最大int值初始化其容量\",{\"1\":{\"1503\":1}}],[\"就使用set或者自己的数据类型即可\",{\"1\":{\"577\":1}}],[\"就少自旋身之不自旋\",{\"1\":{\"1485\":1}}],[\"就称之为源\",{\"1\":{\"1607\":1}}],[\"就称这段代码块为临界区\",{\"1\":{\"1482\":1}}],[\"就称为可用性优先流程\",{\"1\":{\"459\":1}}],[\"就称为回表\",{\"1\":{\"337\":1}}],[\"就给他赋一个新值\",{\"1\":{\"1479\":1}}],[\"就坐在椅子上\",{\"1\":{\"1421\":1}}],[\"就去干别的事情了\",{\"1\":{\"1421\":2}}],[\"就一直等着服务端响应\",{\"1\":{\"1421\":1}}],[\"就先把key删除\",{\"1\":{\"1289\":1}}],[\"就先删除锁\",{\"1\":{\"1288\":1}}],[\"就删除\",{\"1\":{\"1289\":1}}],[\"就挂了\",{\"1\":{\"1288\":1}}],[\"就休眠一小会\",{\"1\":{\"1286\":1}}],[\"就抛出异常\",{\"1\":{\"1238\":2}}],[\"就以非事务方式运行\",{\"1\":{\"1238\":1}}],[\"就加入到该事务\",{\"1\":{\"1238\":2}}],[\"就加入到事务中\",{\"1\":{\"1238\":1}}],[\"就创建一个新事务\",{\"1\":{\"1238\":1}}],[\"就比较麻烦\",{\"1\":{\"967\":1}}],[\"就比较麻烦了\",{\"1\":{\"637\":1}}],[\"就比较适合来做备份\",{\"1\":{\"457\":1}}],[\"就在缓存中方一个空对象用于处理后续这个请求\",{\"1\":{\"627\":1}}],[\"就在内存中change\",{\"1\":{\"345\":1}}],[\"就被链接到对应频道的链表的尾部\",{\"1\":{\"599\":1}}],[\"就意味该列的值全部是重复的\",{\"1\":{\"553\":1}}],[\"就意味着越\",{\"1\":{\"624\":1}}],[\"就意味着数据丢失\",{\"1\":{\"495\":1}}],[\"就意味着使用这两个索引都需要排序\",{\"1\":{\"348\":1}}],[\"就必然会出现\",{\"1\":{\"497\":1}}],[\"就必须走主库\",{\"1\":{\"470\":1}}],[\"就必须保证主库发给备库的日志是完整的\",{\"1\":{\"468\":1}}],[\"就必须等到备库b的seconds\",{\"1\":{\"459\":1}}],[\"就必须将当前的值依次执行图中所有的回滚操作得到\",{\"1\":{\"434\":1}}],[\"就必须对语句做改写\",{\"1\":{\"413\":1}}],[\"就必须了解优化器选择索引的策略\",{\"1\":{\"346\":1}}],[\"就必须让查询过程访问尽量少地数据块\",{\"1\":{\"334\":1}}],[\"就必须全部扫描一遍了\",{\"1\":{\"332\":1}}],[\"就大大减少了并发事务申请trx\",{\"1\":{\"497\":1}}],[\"就获得max\",{\"1\":{\"497\":1}}],[\"就应该使用spliterator\",{\"1\":{\"1620\":1}}],[\"就应该创建成8个字节bigint\",{\"1\":{\"494\":1}}],[\"就应该放弃\",{\"1\":{\"473\":1}}],[\"就跳过这个id\",{\"1\":{\"491\":1}}],[\"就方便多了\",{\"1\":{\"485\":1}}],[\"就避免了在恢复数据时还要应用其它库日志的情况\",{\"1\":{\"485\":1}}],[\"就避免了被驱动表上的字符编码转换\",{\"1\":{\"368\":1}}],[\"就无法通过flashback来恢复了\",{\"1\":{\"485\":1}}],[\"就无须设置master\",{\"1\":{\"468\":1}}],[\"就导致已经在之前误操作的基础上\",{\"1\":{\"484\":1}}],[\"就导致了系统在这个时刻之后\",{\"1\":{\"497\":1}}],[\"就导致了第二个insert语句又拿到相同的自增id值\",{\"1\":{\"494\":1}}],[\"就导致了意外的长事务\",{\"1\":{\"435\":1}}],[\"就导致了session\",{\"1\":{\"425\":1}}],[\"就把command列线程成killed\",{\"1\":{\"481\":1}}],[\"就认为系统不可用\",{\"1\":{\"478\":1}}],[\"就已经执行过这个位置了\",{\"1\":{\"473\":1}}],[\"就返回0\",{\"1\":{\"1618\":1}}],[\"就返回\",{\"1\":{\"473\":1}}],[\"就开始给客户端返回确认\",{\"1\":{\"472\":1}}],[\"就算晚几秒看到最新发布的商品\",{\"1\":{\"470\":1}}],[\"就拒绝把日志发给b\",{\"1\":{\"468\":1}}],[\"就还是按照原来的分配方式\",{\"1\":{\"468\":1}}],[\"就将descriptor对应的类型所匹配的所有bean方法\",{\"1\":{\"1648\":1}}],[\"就将元素提供给consumer\",{\"1\":{\"1623\":1}}],[\"就将他放入到map里面\",{\"1\":{\"1618\":1}}],[\"就将特性值设置为空\",{\"1\":{\"1618\":1}}],[\"就将该值+1\",{\"1\":{\"1485\":1}}],[\"就将key设置为value\",{\"1\":{\"1288\":1}}],[\"就将当前事务挂起\",{\"1\":{\"1238\":1}}],[\"就将thread\",{\"1\":{\"498\":1}}],[\"就将这行数据写入表中\",{\"1\":{\"495\":1}}],[\"就将这个current\",{\"1\":{\"468\":1}}],[\"就将x这一行的c值加1\",{\"1\":{\"416\":1}}],[\"就暂时退化为单线程模式\",{\"1\":{\"462\":1}}],[\"就有两个特征\",{\"1\":{\"495\":1}}],[\"就有两种情况\",{\"1\":{\"472\":1}}],[\"就有可能修改元的大小\",{\"1\":{\"1620\":1}}],[\"就有可能会造成消息丢失\",{\"1\":{\"1328\":1}}],[\"就有可能导致数据库崩溃\",{\"1\":{\"626\":1}}],[\"就有可能读到刚刚的事务更新之前的状态\",{\"1\":{\"469\":1}}],[\"就有可能session\",{\"1\":{\"462\":1}}],[\"就有了批量重偏向与批量撤销的机制\",{\"1\":{\"1485\":1}}],[\"就有了mixed这种binlog格式存在的场景\",{\"1\":{\"454\":1}}],[\"就有了\",{\"1\":{\"433\":1}}],[\"就相应的有不同的策略\",{\"1\":{\"457\":1}}],[\"就相对麻烦了\",{\"1\":{\"335\":1}}],[\"就能够确定在从库上执行的查询请求吗\",{\"1\":{\"472\":1}}],[\"就能恢复这个更新操作了\",{\"1\":{\"454\":1}}],[\"就能确定将这条语句到哪个分表做查询\",{\"1\":{\"411\":1}}],[\"就用row格式\",{\"1\":{\"454\":1}}],[\"就肯定会删除id=4的行\",{\"1\":{\"454\":1}}],[\"就拥有超级线程\",{\"1\":{\"453\":1}}],[\"就切成状态2\",{\"1\":{\"453\":1}}],[\"就形成了7个next\",{\"1\":{\"448\":1}}],[\"就产生了7个间隙\",{\"1\":{\"448\":1}}],[\"就破坏了session\",{\"1\":{\"447\":1}}],[\"就只有\",{\"1\":{\"481\":1}}],[\"就只能等trx2完全执行完成\",{\"1\":{\"464\":1}}],[\"就只能使用ftwrl命令了\",{\"1\":{\"438\":1}}],[\"就只需要从左到右\",{\"1\":{\"417\":1}}],[\"就只需要一次指针寻找和一次计算\",{\"1\":{\"342\":1}}],[\"就只需要回表2次\",{\"1\":{\"340\":1}}],[\"就可能导致cpu资源的浪费\",{\"1\":{\"1510\":1}}],[\"就可能导致生产事故\",{\"1\":{\"441\":1}}],[\"就可能出现一些不确定的行为\",{\"1\":{\"1620\":1}}],[\"就可能出现max\",{\"1\":{\"497\":1}}],[\"就可能出现这样的情况\",{\"1\":{\"492\":1}}],[\"就可能出现对数据的二次破坏\",{\"1\":{\"484\":1}}],[\"就可能出现行冲入\",{\"1\":{\"478\":1}}],[\"就可能出现脏读\",{\"1\":{\"433\":1}}],[\"就可能会出现错误\",{\"1\":{\"1617\":1}}],[\"就可能会出现大量的超时\",{\"1\":{\"444\":1}}],[\"就可能会导致主备延迟了\",{\"1\":{\"457\":1}}],[\"就可以把这些技术整合起来做个项目\",{\"1\":{\"1987\":1}}],[\"就可以了\",{\"1\":{\"1974\":1}}],[\"就可以开始下一阶段的学习了\",{\"1\":{\"1972\":1}}],[\"就可以开始刷算法啦\",{\"1\":{\"1970\":1}}],[\"就可以做个图书管理系统\",{\"1\":{\"1969\":1}}],[\"就可以做到既节省空间\",{\"1\":{\"350\":1}}],[\"就可以认为是配置类\",{\"1\":{\"1652\":1}}],[\"就可以通过factorybean来实现\",{\"1\":{\"1644\":1}}],[\"就可以通过max\",{\"1\":{\"479\":1}}],[\"就可以执行控制性的遍历\",{\"1\":{\"1619\":1}}],[\"就可以打印3到8的内容\",{\"1\":{\"1607\":1}}],[\"就可以支持成千上万的连接\",{\"1\":{\"1574\":1}}],[\"就可以\",{\"1\":{\"1517\":1}}],[\"就可以先从二级缓存中获取到不完整对象\",{\"1\":{\"1237\":1}}],[\"就可以获取到被代理的对象\",{\"1\":{\"1654\":1}}],[\"就可以获取到更多的回调\",{\"1\":{\"1005\":1}}],[\"就可以获得一个大概参考值来判断当前响应时间是不是一个合理的值\",{\"1\":{\"388\":1}}],[\"就可以客观认为主机故障\",{\"1\":{\"621\":1}}],[\"就可以立即返回\",{\"1\":{\"603\":1}}],[\"就可以计算接近\",{\"1\":{\"577\":1}}],[\"就可以考虑是不是由于eq\",{\"1\":{\"553\":1}}],[\"就可以考虑搭建延迟复制的备库\",{\"1\":{\"486\":1}}],[\"就可以沿着叶子节点组成的双向链表把所有记录都查看一遍\",{\"1\":{\"548\":1}}],[\"就可以保证两点\",{\"1\":{\"497\":1}}],[\"就可以看到\",{\"1\":{\"1611\":1}}],[\"就可以看到这样一段javadoc\",{\"1\":{\"1594\":1}}],[\"就可以看到如下结果\",{\"1\":{\"490\":1}}],[\"就可以看到下面这个图\",{\"1\":{\"481\":1}}],[\"就可以恢复出数据的临时实例\",{\"1\":{\"486\":1}}],[\"就可以恢复出需要的数据\",{\"1\":{\"486\":1}}],[\"就可以正常同步了\",{\"1\":{\"485\":1}}],[\"就可以正式开始执行select语句了\",{\"1\":{\"319\":1}}],[\"就可以让临时库只同步误操作的表\",{\"1\":{\"485\":1}}],[\"就可以使用方法引用来写出更加简洁的代码\",{\"1\":{\"1602\":1}}],[\"就可以使用tab键自动补全表名或者显示提示\",{\"1\":{\"482\":1}}],[\"就可以使用这个逻辑\",{\"1\":{\"473\":1}}],[\"就可以关掉这个自动不全的功能\",{\"1\":{\"482\":1}}],[\"就可以加入监控累积值了\",{\"1\":{\"479\":1}}],[\"就可以采用位点和gtid的方法来确保主备无延迟\",{\"1\":{\"472\":1}}],[\"就可以并行\",{\"1\":{\"465\":1}}],[\"就可以精确地只得到三个最小值\",{\"1\":{\"421\":1}}],[\"就可以告诉优化器\",{\"1\":{\"418\":1}}],[\"就可以拿到group\",{\"1\":{\"417\":1}}],[\"就可以得到结果\",{\"1\":{\"411\":1}}],[\"就可以直接从远程仓库同步到本地\",{\"1\":{\"1980\":1}}],[\"就可以直接对流源进行操作\",{\"1\":{\"1622\":1}}],[\"就可以直接通过alter\",{\"1\":{\"426\":1}}],[\"就可以直接转为bka算法了\",{\"1\":{\"407\":1}}],[\"就可以直接返回结果\",{\"1\":{\"319\":1}}],[\"就可以用上被驱动表上的索引\",{\"1\":{\"403\":1}}],[\"就可以用来记录新的操作\",{\"1\":{\"324\":1}}],[\"就可以大大降低对服务器的影响\",{\"1\":{\"393\":1}}],[\"就可以选择前缀长度为6\",{\"1\":{\"350\":1}}],[\"就可以少维护一个索引\",{\"1\":{\"339\":1}}],[\"就可以利用索引来加速检索\",{\"1\":{\"339\":1}}],[\"就可以存1200的3次方个值\",{\"1\":{\"334\":1}}],[\"就可以找到其对应的值即value\",{\"1\":{\"332\":1}}],[\"就表示这个锁已经被其他进程占用了\",{\"1\":{\"1288\":1}}],[\"就表示\",{\"1\":{\"1136\":1}}],[\"就表示主库没有问题\",{\"1\":{\"476\":1}}],[\"就表示所有给客户端发送过确认的事务\",{\"1\":{\"472\":1}}],[\"就表示接收到的日志已经同步完成\",{\"1\":{\"472\":1}}],[\"就表示事务已经通过锁冲突的检验了\",{\"1\":{\"465\":1}}],[\"就表示使用了优先队列排序算法\",{\"1\":{\"421\":1}}],[\"就表示现在系统里面有一个空闲连接\",{\"1\":{\"318\":1}}],[\"就插入一条记录\",{\"1\":{\"416\":1}}],[\"就依次执行子查询\",{\"1\":{\"414\":1}}],[\"就没有必要子类加载器再加载一次\",{\"1\":{\"1663\":1}}],[\"就没有了\",{\"1\":{\"414\":1}}],[\"就没必要使用change\",{\"1\":{\"343\":1}}],[\"就作为结果集的一行\",{\"1\":{\"408\":1}}],[\"就作为结果集的一部分返回\",{\"1\":{\"407\":1}}],[\"就按行累加\",{\"1\":{\"399\":1}}],[\"就怎么用\",{\"1\":{\"378\":1}}],[\"就直接返回\",{\"1\":{\"1000\":1}}],[\"就直接返回给执行器\",{\"1\":{\"326\":1}}],[\"就直接复用autowiredannotationbeanpostprocessor的实现\",{\"1\":{\"965\":1}}],[\"就直接使用满足范围条件的索引记录条数作为扇出值\",{\"1\":{\"554\":1}}],[\"就直接使用表中记录的数量作为扇出值\",{\"1\":{\"554\":1}}],[\"就直接使用统计数据来估算这些参数需要单点区间对应的记录条数了\",{\"1\":{\"553\":1}}],[\"就直接使用语句里指定的值\",{\"1\":{\"491\":1}}],[\"就直接丢弃这个日志\",{\"1\":{\"455\":1}}],[\"就直接选择这个索引\",{\"1\":{\"348\":1}}],[\"就得从io拷贝机制说起\",{\"1\":{\"1576\":1}}],[\"就得到了最终的结果\",{\"1\":{\"421\":1}}],[\"就得到了一个有序数组\",{\"1\":{\"418\":1}}],[\"就得到了这个索引的基数\",{\"1\":{\"347\":1}}],[\"就得先停下来擦掉一些记录\",{\"1\":{\"324\":1}}],[\"就是一个先进先出的数据结构\",{\"1\":{\"1985\":1}}],[\"就是一个过滤阶段\",{\"1\":{\"1623\":1}}],[\"就是一个典型的大事务的场景\",{\"1\":{\"457\":1}}],[\"就是直接进入这个方法\",{\"1\":{\"1622\":1}}],[\"就是可以传入自己本身以及父类的比较器\",{\"1\":{\"1614\":1}}],[\"就是可能出现数据不一致的情况\",{\"1\":{\"459\":1}}],[\"就是取决于是否可能会出现空指针的情况\",{\"1\":{\"1610\":1}}],[\"就是取整数部分\",{\"1\":{\"422\":1}}],[\"就是使用并发来加快运行的效率\",{\"1\":{\"1607\":1}}],[\"就是jdk8中新增的语法\",{\"1\":{\"1602\":1}}],[\"就是supplier函数式接口的一个实例\",{\"1\":{\"1600\":1}}],[\"就是select的数据列只用从索引中就能够取得\",{\"1\":{\"330\":1}}],[\"就是这两个lambda表达式的上下文\",{\"1\":{\"1595\":1}}],[\"就是这个10000行里面r值最小的三行\",{\"1\":{\"421\":1}}],[\"就是myinterface\",{\"1\":{\"1595\":1}}],[\"就是将内核缓冲区的内存和用户缓冲区的内存做了一个地址映射\",{\"1\":{\"1587\":1}}],[\"就是将服务端的session信息保存到一个第三方中\",{\"1\":{\"1200\":1}}],[\"就是指数据从一个存储区域转移到另一个存储区域\",{\"1\":{\"1576\":1}}],[\"就是指程序中写的代码\",{\"1\":{\"1405\":1}}],[\"就是变量一旦被赋值\",{\"1\":{\"1526\":1}}],[\"就是对象一旦被创建之后\",{\"1\":{\"1526\":1}}],[\"就是对系统访问者的行为进行控制\",{\"1\":{\"1199\":1}}],[\"就是对系统访问者的身份进行确认\",{\"1\":{\"1199\":1}}],[\"就是允许空闲线程从繁忙的双端队列中窃取任务\",{\"1\":{\"1511\":1}}],[\"就是允许我们将之前的授权和认证过程交给一个独立的第三方进行担保\",{\"1\":{\"1202\":1}}],[\"就是减少stw\",{\"1\":{\"1440\":1}}],[\"就是epollselectorprovider\",{\"1\":{\"1423\":1}}],[\"就是在所有进程都能访问到的一个地方\",{\"1\":{\"1288\":1}}],[\"就是当表中的数据量过大时\",{\"1\":{\"1270\":1}}],[\"就是把$\",{\"1\":{\"1210\":1}}],[\"就是三方参与者的信任程度\",{\"1\":{\"1202\":1}}],[\"就是defaultlistablebeanfactory\",{\"1\":{\"975\":1}}],[\"就是无法确定属性初始化的顺序\",{\"1\":{\"912\":1}}],[\"就是根据以往经验指定的一些规则\",{\"1\":{\"556\":1}}],[\"就是n的阶乘种连接顺序\",{\"1\":{\"556\":1}}],[\"就是先把获取索引对应的b+树的区间最左记录和区间最右记录\",{\"1\":{\"553\":1}}],[\"就是2\",{\"1\":{\"542\":1}}],[\"就是读锁会阻塞写\",{\"1\":{\"535\":1}}],[\"就是通过事务的一致性视图与这行数据的trx\",{\"1\":{\"497\":1}}],[\"就是为了效率上的考量\",{\"1\":{\"1622\":1}}],[\"就是为了更为方便的编写函数式的代码\",{\"1\":{\"1607\":1}}],[\"就是为了能够在innodb事务和server之间做关联\",{\"1\":{\"497\":1}}],[\"就是为了达到这个目的\",{\"1\":{\"492\":1}}],[\"就是为了要更新数据\",{\"1\":{\"447\":1}}],[\"就是让session\",{\"1\":{\"481\":1}}],[\"就是随机性\",{\"1\":{\"478\":1}}],[\"就是会多占一些内存\",{\"1\":{\"476\":1}}],[\"就是出现了过期读\",{\"1\":{\"472\":1}}],[\"就是大表ddl\",{\"1\":{\"457\":1}}],[\"就是同一个事务\",{\"1\":{\"457\":1}}],[\"就是我们输入的sql原文\",{\"1\":{\"454\":1}}],[\"就是图中的这两个gtid\",{\"1\":{\"468\":1}}],[\"就是图中io\",{\"1\":{\"453\":1}}],[\"就是图中红色的部分\",{\"1\":{\"451\":1}}],[\"就是要被遍历的元素的个数\",{\"1\":{\"1620\":1}}],[\"就是要尽量把数据分配均匀\",{\"1\":{\"1357\":1}}],[\"就是要能读到所有已经提交的记录的最新值\",{\"1\":{\"446\":1}}],[\"就是要把一个逻辑上的大表分散到不同的数据库实例上\",{\"1\":{\"411\":1}}],[\"就是进入了死锁状态\",{\"1\":{\"444\":1}}],[\"就是针对数据表中行记录的锁\",{\"1\":{\"442\":1}}],[\"就是数据库的多版本并发控制\",{\"1\":{\"434\":1}}],[\"就是\",{\"1\":{\"403\":1}}],[\"就是看explain的结果里面\",{\"1\":{\"403\":1}}],[\"就是如果查询要返回的字段很多的话\",{\"1\":{\"355\":1}}],[\"就是写了两处内存\",{\"1\":{\"345\":1}}],[\"就打开表继续执行\",{\"1\":{\"322\":1}}],[\"就要将sourcesupplier置为null\",{\"1\":{\"1621\":1}}],[\"就要将进程切换到内核态\",{\"1\":{\"1579\":1}}],[\"就要将一个表中的数据分散到多个数据库的多个表当中\",{\"1\":{\"1270\":1}}],[\"就要分情况来分析\",{\"1\":{\"1236\":1}}],[\"就要考虑分库分表了\",{\"1\":{\"1270\":1}}],[\"就要考虑\",{\"1\":{\"549\":1}}],[\"就要放个有意义的字段\",{\"1\":{\"478\":1}}],[\"就要放弃读写分离\",{\"1\":{\"470\":1}}],[\"就要引入半同步复制\",{\"1\":{\"472\":1}}],[\"就要同步这个事务过来执行\",{\"1\":{\"468\":1}}],[\"就要执行change\",{\"1\":{\"467\":1}}],[\"就要把这10万条记录都写到binlog中\",{\"1\":{\"454\":1}}],[\"就要暂存到磁盘\",{\"1\":{\"450\":1}}],[\"就要看看它所依赖的线程有没有被别人锁住\",{\"1\":{\"444\":1}}],[\"就要访问p\",{\"1\":{\"425\":1}}],[\"就要使用手动分表的方式\",{\"1\":{\"424\":1}}],[\"就要等session\",{\"1\":{\"424\":1}}],[\"就要多利用内存\",{\"1\":{\"356\":1}}],[\"就要先判断现在表中是否已经存在k=4的记录\",{\"1\":{\"343\":1}}],[\"就要做一次全表扫描\",{\"1\":{\"402\":1}}],[\"就要做\",{\"1\":{\"320\":1}}],[\"就要真正开始执行语句了\",{\"1\":{\"320\":1}}],[\"就会额外会执行一些其他逻辑\",{\"1\":{\"1654\":1}}],[\"就会递归在父beanfactory中查找\",{\"1\":{\"1647\":1}}],[\"就会直接返回\",{\"1\":{\"1657\":1}}],[\"就会直接抛出异常\",{\"1\":{\"1647\":1}}],[\"就会直接拿新的值覆盖旧值\",{\"1\":{\"1557\":1}}],[\"就会使用该propertyeditor来做类型转化\",{\"1\":{\"1638\":1}}],[\"就会使用第二种不缓存的方式\",{\"1\":{\"482\":1}}],[\"就会牺牲并行的优势\",{\"1\":{\"1622\":1}}],[\"就会对\",{\"1\":{\"1969\":1}}],[\"就会对的下一个元素去执行action方法\",{\"1\":{\"1620\":1}}],[\"就会对元素执行给定的action方法\",{\"1\":{\"1620\":1}}],[\"就会输出\",{\"1\":{\"1619\":1}}],[\"就会按照被添加进去的顺序得到调用\",{\"1\":{\"1619\":1}}],[\"就会两个list是相同的\",{\"1\":{\"1615\":1}}],[\"就会发现\",{\"1\":{\"1617\":1}}],[\"就会发现有问题\",{\"1\":{\"1614\":1}}],[\"就会发生丢失更新问题\",{\"1\":{\"532\":1}}],[\"就会返回jdk动态代理的对象\",{\"1\":{\"1654\":1}}],[\"就会返回并且销毁\",{\"1\":{\"1622\":1}}],[\"就会返回源阶段的分割迭代器\",{\"1\":{\"1622\":1}}],[\"就会返回long\",{\"1\":{\"1620\":1}}],[\"就会返回一个新的spliterator对象\",{\"1\":{\"1620\":1}}],[\"就会返回0\",{\"1\":{\"1613\":1}}],[\"就会返回没有权限的错误\",{\"1\":{\"322\":1}}],[\"就会在元创建的时候或者说第一次调用方法时候进行绑定\",{\"1\":{\"1620\":1}}],[\"就会在控制台打印字符5\",{\"1\":{\"1612\":1}}],[\"就会在s区来回拷贝\",{\"1\":{\"1436\":1}}],[\"就会顺利的再控制台打印出我们想要的结果了\",{\"1\":{\"1610\":1}}],[\"就会自动跳转到\",{\"1\":{\"1595\":1}}],[\"就会自动跳过误操作的语句\",{\"1\":{\"485\":1}}],[\"就会死循环在这里\",{\"1\":{\"1551\":1}}],[\"就会抛出concurrentmodificationexception的异常\",{\"1\":{\"1620\":1}}],[\"就会抛出illegalstateexception\",{\"1\":{\"1619\":1}}],[\"就会抛出stream已经被使用的异常\",{\"1\":{\"1610\":1}}],[\"就会抛出异常\",{\"1\":{\"1500\":1,\"1617\":1}}],[\"就会抛出版本冲突异常\",{\"1\":{\"306\":1}}],[\"就会将其合并称一次范围更大的加锁和解锁操作\",{\"1\":{\"1486\":1}}],[\"就会将事务t分配给worker\",{\"1\":{\"461\":1}}],[\"就会多自旋几次\",{\"1\":{\"1485\":1}}],[\"就会进入到mybatis框架的底层执行流程\",{\"1\":{\"1653\":1}}],[\"就会进入短路逻辑的判断\",{\"1\":{\"1623\":1}}],[\"就会进入s区\",{\"1\":{\"1436\":1}}],[\"就会进入等待状态\",{\"1\":{\"476\":1}}],[\"就会触发拒绝策略\",{\"1\":{\"1410\":1}}],[\"就会触发redistemplate上的条件注解使默认的redistemplate失效\",{\"1\":{\"583\":1}}],[\"就会频繁的发生树转链表\",{\"1\":{\"1363\":1}}],[\"就会立即退出并给出相应的错误提示\",{\"1\":{\"1297\":1}}],[\"就会找一个非空的unique列作为聚簇索引\",{\"1\":{\"1266\":1}}],[\"就会调用对应的方法\",{\"1\":{\"1234\":1}}],[\"就会完成转账\",{\"1\":{\"1201\":1}}],[\"就会有多个线程同时执行uniqueinstance\",{\"1\":{\"1191\":1}}],[\"就会首先使用我们注册的autowiredannotationbeanpostprocessor来进行依赖注入\",{\"1\":{\"967\":1}}],[\"就会占用部分空间\",{\"1\":{\"630\":1}}],[\"就会全部转移到数据库上\",{\"1\":{\"626\":1}}],[\"就会继续从0开始计数\",{\"1\":{\"496\":1}}],[\"就会继续后面的执行阶段\",{\"1\":{\"319\":1}}],[\"就会出现问题\",{\"1\":{\"1482\":1}}],[\"就会出现\",{\"1\":{\"1237\":1}}],[\"就会出现这个情况\",{\"1\":{\"497\":1}}],[\"就会出现插入语句报错\",{\"1\":{\"491\":1}}],[\"就会出现另外一种情况\",{\"1\":{\"406\":1}}],[\"就会产生过期读的问题\",{\"1\":{\"472\":1}}],[\"就会涉及到一主多从的架构\",{\"1\":{\"466\":1}}],[\"就会报唯一键冲突\",{\"1\":{\"462\":1}}],[\"就会报错\",{\"1\":{\"413\":1}}],[\"就会从hash\",{\"1\":{\"461\":1}}],[\"就会看到这个事务\",{\"1\":{\"460\":1}}],[\"就会看到cpu利用率很高\",{\"1\":{\"444\":1}}],[\"就会记录为statement格式\",{\"1\":{\"454\":1}}],[\"就会记录为row格式\",{\"1\":{\"454\":1}}],[\"就会丢失数据\",{\"1\":{\"451\":1}}],[\"就会带上事务a在redo\",{\"1\":{\"451\":1}}],[\"就会把插入r这一行数据的binlog又同步到从库b去执行\",{\"1\":{\"467\":1}}],[\"就会把redo\",{\"1\":{\"451\":1}}],[\"就会把这100行数据分成多段执行上图的流程\",{\"1\":{\"405\":1}}],[\"就会导致轻量级锁膨胀为重量级锁\",{\"1\":{\"1485\":1}}],[\"就会导致内存泄漏\",{\"1\":{\"1406\":1}}],[\"就会导致服务端发送结果被阻塞\",{\"1\":{\"482\":1}}],[\"就会导致备库应用日志不够快\",{\"1\":{\"460\":1}}],[\"就会导致这几个线程都进入无限等待的状态\",{\"1\":{\"444\":1}}],[\"就会导致mysql实例的buffer\",{\"1\":{\"406\":1}}],[\"就会一直占着mdl锁\",{\"1\":{\"441\":1}}],[\"就会加上mdl写锁\",{\"1\":{\"441\":1}}],[\"就会加上mdl读锁\",{\"1\":{\"441\":1}}],[\"就会优先考虑使用临时表\",{\"1\":{\"418\":1}}],[\"就会利用磁盘临时文件辅助排序\",{\"1\":{\"418\":1}}],[\"就会执行afterpropertiesset\",{\"1\":{\"1234\":1}}],[\"就会执行步骤2和3\",{\"1\":{\"404\":1}}],[\"就会执行类似这样的sql语句\",{\"1\":{\"341\":1}}],[\"就会分段放置\",{\"1\":{\"403\":1}}],[\"就会不经意间导致整个数据库的压力变大\",{\"1\":{\"365\":1}}],[\"就会停止继续检索\",{\"1\":{\"342\":1}}],[\"就会收到\",{\"1\":{\"320\":1}}],[\"就会收到一个错误提示\",{\"1\":{\"318\":1}}],[\"就需要再调用一次begin方法\",{\"1\":{\"1623\":1}}],[\"就需要对于中间操作进行一般化的处理\",{\"1\":{\"1622\":1}}],[\"就需要显示的声明类型\",{\"1\":{\"1614\":1}}],[\"就需要调用flatmap方法\",{\"1\":{\"1609\":1}}],[\"就需要做到两点\",{\"1\":{\"1333\":1}}],[\"就需要做优化\",{\"1\":{\"406\":1}}],[\"就需要额外增加attribute属性\",{\"1\":{\"1136\":1}}],[\"就需要引入依赖\",{\"1\":{\"965\":1}}],[\"就需要多个配置文件\",{\"1\":{\"609\":1}}],[\"就需要阅读redisproperties\",{\"1\":{\"583\":1}}],[\"就需要计算出驱动表的扇出值\",{\"1\":{\"554\":1}}],[\"就需要进行多少次回表操作\",{\"1\":{\"549\":1}}],[\"就需要把当前自增值修改为新的自增值\",{\"1\":{\"491\":1}}],[\"就需要恢复6天的日志\",{\"1\":{\"486\":1}}],[\"就需要使用全量备份\",{\"1\":{\"485\":1}}],[\"就需要一个按行并行复制的方案\",{\"1\":{\"462\":1}}],[\"就需要扫描100亿行\",{\"1\":{\"402\":1}}],[\"就需要外部排序\",{\"1\":{\"354\":1}}],[\"就需要重连\",{\"1\":{\"318\":1}}],[\"就需要交互对话里面输入密码\",{\"1\":{\"318\":1}}],[\"就需要了解mysql的逻辑架构\",{\"1\":{\"317\":1}}],[\"就不用再做其他的操作来保证线程安全\",{\"1\":{\"1615\":1}}],[\"就不需要移动它后面的元素\",{\"1\":{\"1502\":1}}],[\"就不需要再回表查询\",{\"1\":{\"1268\":1}}],[\"就不应该允许其他线程对该资源进行读和写操作了\",{\"1\":{\"1498\":1}}],[\"就不注册\",{\"1\":{\"967\":1}}],[\"就不再访问后端服务\",{\"1\":{\"1283\":1}}],[\"就不再继续往后分析bca这个连接顺序的成本了\",{\"1\":{\"556\":1}}],[\"就不再支持修改字段定义\",{\"1\":{\"309\":1}}],[\"就不可避免的要设置位点的这两个参数\",{\"1\":{\"467\":1}}],[\"就不止是给数据库已有的6个记录加上了行锁\",{\"1\":{\"448\":1}}],[\"就不允许创建myisam分区表了\",{\"1\":{\"425\":1}}],[\"就不允许修改了\",{\"1\":{\"1526\":1}}],[\"就不允许修改\",{\"1\":{\"309\":1}}],[\"就不得不回到id索引再去判断email字段的值\",{\"1\":{\"351\":1}}],[\"就不会被压制\",{\"1\":{\"1619\":1}}],[\"就不会被实例化\",{\"1\":{\"1191\":1}}],[\"就不会使用index\",{\"1\":{\"553\":1}}],[\"就不会再看后面的字段\",{\"1\":{\"505\":1}}],[\"就不会再处理这个日志\",{\"1\":{\"455\":1}}],[\"就不会记录到binlog里\",{\"1\":{\"413\":1}}],[\"就不会移动到lru链表头部\",{\"1\":{\"406\":1}}],[\"就不会导致线上出现主从数据库不一致的情况\",{\"1\":{\"327\":1}}],[\"就不会有这样的影响\",{\"1\":{\"309\":1}}],[\"新特性\",{\"1\":{\"1966\":1}}],[\"新建的对象也是不可偏向的\",{\"1\":{\"1485\":1}}],[\"新建一个节点\",{\"1\":{\"1503\":1}}],[\"新建一个注解\",{\"1\":{\"917\":1}}],[\"新建一个超级用户类\",{\"1\":{\"917\":1}}],[\"新建一个用户类\",{\"1\":{\"917\":1}}],[\"新创建对象的mark\",{\"1\":{\"1485\":1}}],[\"新生代大小\",{\"1\":{\"1664\":1}}],[\"新生代\",{\"1\":{\"1441\":4}}],[\"新生代收集\",{\"1\":{\"1434\":1}}],[\"新生代会变成老年代\",{\"1\":{\"1434\":1}}],[\"新类的定义可以增加新的数据或功能\",{\"1\":{\"1340\":1}}],[\"新写入操作会报错并返回错误信息\",{\"1\":{\"1300\":1}}],[\"新写入的行就会覆盖原有的行\",{\"1\":{\"495\":1}}],[\"新加的这条update语句就是把它认为加上了锁的这一行的d的值修改成了100\",{\"1\":{\"447\":1}}],[\"新插入的行\",{\"1\":{\"446\":1}}],[\"新的spliterator可能可以进一步分割\",{\"1\":{\"1620\":1}}],[\"新的时间和日期api\",{\"1\":{\"1349\":1}}],[\"新的自增值的生成算法是\",{\"1\":{\"491\":1}}],[\"新的商品\",{\"1\":{\"471\":1}}],[\"新的算法放入sort\",{\"1\":{\"355\":1}}],[\"新的文档会被索引\",{\"1\":{\"306\":1}}],[\"新增\",{\"1\":{\"1554\":1}}],[\"新增效率又比较慢\",{\"1\":{\"1360\":1}}],[\"新增内容\",{\"1\":{\"571\":1}}],[\"新增参数innodb\",{\"1\":{\"492\":1}}],[\"新增age字段导致文档插入失败\",{\"1\":{\"309\":1}}],[\"新增字段的数据无法被索引\",{\"1\":{\"309\":1}}],[\"新增加的字段\",{\"1\":{\"309\":1}}],[\"使其再次尝试获取同步状态\",{\"1\":{\"1491\":1}}],[\"使线程正常退出\",{\"1\":{\"1379\":1}}],[\"使程序功能正确完成\",{\"1\":{\"1376\":1}}],[\"使被它修饰的注解具有继承性\",{\"1\":{\"1133\":1}}],[\"使得zookeeper成为了解决分布式一致性问题的利器\",{\"1\":{\"1991\":1}}],[\"使得父容器\",{\"1\":{\"1659\":1}}],[\"使得其它处理器暂时无法通过总线访问内存\",{\"1\":{\"1473\":1}}],[\"使得多个进程快速交替的执行\",{\"1\":{\"1470\":1}}],[\"使得在宏观上具有多个进程同时执行的效果\",{\"1\":{\"1470\":1}}],[\"使得每个线程都可以独立地访问和修改自己的变量副本\",{\"1\":{\"1416\":1}}],[\"使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上的不同版本数据\",{\"1\":{\"542\":1}}],[\"使得这三个语句都处于\",{\"1\":{\"476\":1}}],[\"使得我们无需手动定义mappings\",{\"1\":{\"309\":1}}],[\"使用wkhtmltopdf生成长图和pdf\",{\"1\":{\"1987\":1}}],[\"使用wait和notify方法首先要必须要获取到当前对象的锁\",{\"1\":{\"1382\":1}}],[\"使用watch可以当做redis的乐观锁操作\",{\"1\":{\"581\":1}}],[\"使用watch\",{\"1\":{\"581\":1}}],[\"使用无参构造方法\",{\"1\":{\"1650\":1}}],[\"使用传统的iterator遍历的效率是要比流的方式效率要高的\",{\"1\":{\"1622\":1}}],[\"使用传统的方式\",{\"1\":{\"1598\":1,\"1611\":1}}],[\"使用他们来简化一些计算\",{\"1\":{\"1620\":1}}],[\"使用给定的下游收集器执行汇聚操作\",{\"1\":{\"1618\":1}}],[\"使用一个collector执行汇聚操作会生成的结果应该和下面的结果等价\",{\"1\":{\"1615\":1}}],[\"使用一段时间\",{\"1\":{\"318\":1}}],[\"使用函数式的方式\",{\"1\":{\"1607\":1}}],[\"使用函数式编程\",{\"1\":{\"1591\":1}}],[\"使用相似的方式\",{\"1\":{\"1607\":1}}],[\"使用通知性的annotation\",{\"1\":{\"1594\":1}}],[\"使用方法引用可以写出更加简洁优雅的代码\",{\"1\":{\"1593\":1}}],[\"使用lambda表达式所带来的好处其实远不止简化代码\",{\"1\":{\"1592\":1}}],[\"使用lambda表达式的新写法\",{\"1\":{\"1591\":1}}],[\"使用lambda创建了线程了\",{\"1\":{\"1591\":1}}],[\"使用匿名内部类编程\",{\"1\":{\"1591\":1}}],[\"使用比较方法\",{\"1\":{\"1538\":1}}],[\"使用集合的好处\",{\"1\":{\"1538\":1}}],[\"使用案例\",{\"1\":{\"1521\":1}}],[\"使用链表实现需要额外的\",{\"1\":{\"1509\":1}}],[\"使用独占锁reentrantlock实现线程安全\",{\"1\":{\"1502\":1}}],[\"使用生产者\",{\"1\":{\"1501\":1}}],[\"使用逃逸分析\",{\"1\":{\"1488\":1}}],[\"使用直接指针的方式\",{\"1\":{\"1430\":1}}],[\"使用句柄的方式\",{\"1\":{\"1430\":1}}],[\"使用final关键字修饰的变量等\",{\"1\":{\"1416\":1}}],[\"使用不可变的变量\",{\"1\":{\"1416\":1}}],[\"使用tocollection可以很方便的自定义返回结果容器的类型\",{\"1\":{\"1609\":1}}],[\"使用takelock加锁\",{\"1\":{\"1503\":1}}],[\"使用threadlocal\",{\"1\":{\"1416\":1}}],[\"使用try\",{\"1\":{\"1239\":1}}],[\"使用volatile\",{\"1\":{\"1416\":1}}],[\"使用线程安全的集合类\",{\"1\":{\"1416\":1}}],[\"使用线程池可以进行同一的分配\",{\"1\":{\"1407\":1}}],[\"使用线程池有什么好处\",{\"0\":{\"78\":1,\"1407\":1}}],[\"使用者需要继承aqs并重写指定的方法\",{\"1\":{\"1400\":1}}],[\"使用者可以在channelpipeline上通过addlast\",{\"1\":{\"1224\":1}}],[\"使用退出标志\",{\"1\":{\"1379\":1}}],[\"使用数组进行增加元素\",{\"1\":{\"1538\":1}}],[\"使用数组查询的效率会linkedlist大\",{\"1\":{\"1358\":1}}],[\"使用数据库默认的事务隔离级别\",{\"1\":{\"1238\":1}}],[\"使用动态代理拦截方法等\",{\"1\":{\"1354\":1}}],[\"使用迭代器遍历元素时\",{\"1\":{\"1353\":1}}],[\"使用迭代器可以遍历这个对象的内部\",{\"1\":{\"1353\":1}}],[\"使用end方法可以将它从激活状态转换成初始状态\",{\"1\":{\"1623\":1}}],[\"使用erlang语言天生就成为了一种屏障\",{\"1\":{\"1333\":1}}],[\"使用explain查看执行情况\",{\"1\":{\"354\":1}}],[\"使用explain关键字可以模拟优化器执行sql查询语句\",{\"1\":{\"329\":1}}],[\"使用事务消息机制\",{\"1\":{\"1333\":1}}],[\"使用默认的方式消费就行\",{\"1\":{\"1328\":1}}],[\"使用默认的线程数default\",{\"1\":{\"1227\":1}}],[\"使用其他自增\",{\"1\":{\"1293\":1}}],[\"使用布隆过滤器\",{\"1\":{\"1283\":1}}],[\"使用热点数据预加载\",{\"1\":{\"1283\":1}}],[\"使用二级缓存\",{\"1\":{\"1283\":1}}],[\"使用二级缓存需要实现序列化接口\",{\"1\":{\"1218\":1}}],[\"使用极小的内存空间对大量的唯一元素进行基数估算\",{\"1\":{\"1280\":1}}],[\"使用批处理语句\",{\"1\":{\"1277\":1}}],[\"使用notfull等待\",{\"1\":{\"1502\":1}}],[\"使用netty提供的compositebytebuf类\",{\"1\":{\"1231\":1}}],[\"使用nacos配置中心\",{\"0\":{\"234\":1,\"1314\":1}}],[\"使用缓存的结果可能会不正确\",{\"1\":{\"1219\":1}}],[\"使用缓存系统保存计数\",{\"0\":{\"397\":1}}],[\"使用org\",{\"1\":{\"1088\":1,\"1217\":1}}],[\"使用objectprovider延迟注入的例子\",{\"1\":{\"962\":1}}],[\"使用编码资源接口进行操作的示例\",{\"1\":{\"1040\":1}}],[\"使用proxyfactory获取代理对象\",{\"1\":{\"1654\":1}}],[\"使用properties的方式读取beandefinition的时候\",{\"1\":{\"1022\":1}}],[\"使用put锁加锁\",{\"1\":{\"1503\":1}}],[\"使用put更新文档的时候\",{\"1\":{\"306\":1}}],[\"使用新注解\",{\"1\":{\"967\":1}}],[\"使用asm技术读取当前类的名称\",{\"1\":{\"1647\":1}}],[\"使用asm技术的原因是\",{\"1\":{\"1646\":1}}],[\"使用arrayblockingqueue是个不错的选择\",{\"1\":{\"1502\":1}}],[\"使用atomic原子类\",{\"1\":{\"1416\":1}}],[\"使用applicationlistenerdemo实现applicationeventpublisheraware接口\",{\"1\":{\"1115\":1}}],[\"使用api编程\",{\"1\":{\"1032\":1}}],[\"使用api\",{\"1\":{\"962\":2}}],[\"使用alpine镜像\",{\"0\":{\"884\":1}}],[\"使用自定义注解来进行分组\",{\"1\":{\"961\":1}}],[\"使用示例\",{\"0\":{\"1948\":1},\"1\":{\"961\":3,\"1041\":1,\"1065\":1}}],[\"使用注解\",{\"1\":{\"961\":2}}],[\"使用场景\",{\"0\":{\"1081\":1},\"1\":{\"945\":2,\"974\":1,\"1020\":2,\"1021\":1,\"1022\":1,\"1089\":1,\"1118\":1,\"1124\":1,\"1517\":1}}],[\"使用简单\",{\"0\":{\"651\":1}}],[\"使用哨兵模式\",{\"1\":{\"611\":1}}],[\"使用规则\",{\"0\":{\"611\":1}}],[\"使用java标准的\",{\"1\":{\"1648\":1}}],[\"使用java来操作redis\",{\"1\":{\"582\":1}}],[\"使用jvm提供的synchronized关键字或者jdk提供的各种锁lock\",{\"1\":{\"1377\":1}}],[\"使用jedis\",{\"1\":{\"583\":1}}],[\"使用join方法变量传递\",{\"1\":{\"1411\":1}}],[\"使用join\",{\"1\":{\"405\":1}}],[\"使用join语句\",{\"1\":{\"401\":1}}],[\"使用join有什么问题\",{\"1\":{\"400\":1}}],[\"使用位存储\",{\"1\":{\"578\":1}}],[\"使用geohash位置52点整数编码\",{\"1\":{\"576\":1}}],[\"使用经纬度定位地理坐标并用一个有序集合zset保存\",{\"1\":{\"576\":1}}],[\"使用此命令遍历集合中元素\",{\"1\":{\"572\":1}}],[\"使用语句flush\",{\"1\":{\"559\":1}}],[\"使用统计数据算出来的查询成本与所需的成本可能相差非常大\",{\"1\":{\"553\":1}}],[\"使用统计数据来计算单点区间对应的索引记录条数比index\",{\"1\":{\"553\":1}}],[\"使用iterators遍历元素通常需要两者搭配使用\",{\"1\":{\"1620\":1}}],[\"使用io多路复用技术\",{\"1\":{\"1292\":1}}],[\"使用id\",{\"1\":{\"549\":1}}],[\"使用idx\",{\"1\":{\"549\":3,\"551\":5,\"555\":7}}],[\"使用interrupt方法中断线程\",{\"1\":{\"1379\":1}}],[\"使用index\",{\"1\":{\"553\":1}}],[\"使用in\",{\"1\":{\"394\":1}}],[\"使用临时文件的个数\",{\"1\":{\"520\":1}}],[\"使用临时表优化查询\",{\"0\":{\"414\":1}}],[\"使用临时表的步骤如下\",{\"1\":{\"407\":1}}],[\"使用该索引获取的记录是否按照主键排序\",{\"1\":{\"519\":1}}],[\"使用该方法开启mysql的慢查询日志只对当前数据库生效\",{\"1\":{\"428\":1}}],[\"使用整型的主键可以方便的比较大小\",{\"1\":{\"505\":1}}],[\"使用的是asm技术\",{\"1\":{\"1646\":1}}],[\"使用的是pthread\",{\"1\":{\"481\":1}}],[\"使用的putindex\",{\"1\":{\"1502\":1}}],[\"使用的算法是\",{\"1\":{\"1357\":1}}],[\"使用的示例\",{\"1\":{\"1053\":1,\"1063\":1,\"1108\":1}}],[\"使用的时候只需要继承defaultbeandefinitiondocumentreader\",{\"1\":{\"1025\":1}}],[\"使用的成本都是1\",{\"1\":{\"557\":1}}],[\"使用的就不全是默认值\",{\"1\":{\"491\":1}}],[\"使用reentrantlock+condition实现阻塞\",{\"1\":{\"1520\":1}}],[\"使用redis\",{\"1\":{\"1298\":1}}],[\"使用redistemplate需要频繁调用\",{\"1\":{\"584\":1}}],[\"使用redistemplate\",{\"1\":{\"583\":1}}],[\"使用ringbuffer来作为队列的数据结构\",{\"1\":{\"1520\":1}}],[\"使用rm命令误删整个mysql实例\",{\"1\":{\"483\":1}}],[\"使用row格式的binlog时\",{\"1\":{\"459\":1}}],[\"使用drop\",{\"1\":{\"483\":2}}],[\"使用delete语句误删数据行\",{\"1\":{\"483\":1}}],[\"使用delete语句删掉10万行数据\",{\"1\":{\"454\":1}}],[\"使用这种写法\",{\"1\":{\"1595\":1}}],[\"使用这种类型的缓存一致性\",{\"1\":{\"1474\":1}}],[\"使用这种方式是为了执行stream的close方法\",{\"1\":{\"1619\":1}}],[\"使用这种方式可以替换原来的需要人为的显示关闭各种流的操作\",{\"1\":{\"1619\":1}}],[\"使用这种方式\",{\"1\":{\"468\":1}}],[\"使用这个特点来实现数据拷贝\",{\"1\":{\"1583\":1}}],[\"使用这个临时表来辅助完成查询\",{\"1\":{\"557\":1}}],[\"使用这个算法\",{\"1\":{\"497\":1}}],[\"使用这个方法的时候就不用担心有bean初始化不完全的情况发生\",{\"1\":{\"1009\":1}}],[\"使用这个方法\",{\"1\":{\"477\":1}}],[\"使用这个策略的效果会很好\",{\"1\":{\"463\":1}}],[\"使用begin方法可以将它从初始状态转换成激活状态\",{\"1\":{\"1623\":1}}],[\"使用beanfactory和applicationcontext都可以完成依赖查找的功能\",{\"1\":{\"921\":1}}],[\"使用bio通信模型的服务端\",{\"1\":{\"1573\":1}}],[\"使用binlog来恢复数据的标准做法是\",{\"1\":{\"454\":1}}],[\"使用b索引的代价是很高的\",{\"1\":{\"348\":1}}],[\"使用如下命令解析和查看binlog中的内容\",{\"1\":{\"454\":1}}],[\"使用如下语句查询超过60s的长事务\",{\"1\":{\"434\":1}}],[\"使用前需要开启\",{\"1\":{\"431\":1}}],[\"使用前缀索引后\",{\"1\":{\"350\":1}}],[\"使用分割迭代器来构造流源的这一步我们已经完成了\",{\"1\":{\"1622\":1}}],[\"使用分区别的业务代码更简洁\",{\"1\":{\"426\":1}}],[\"使用分解关联查询的优势如下\",{\"1\":{\"394\":1}}],[\"使用sink对于接收到的所有的元素进行包装成由pipelinehelper所描述的中间操作\",{\"1\":{\"1623\":1}}],[\"使用spliterator来遍历元素的成本是更低的\",{\"1\":{\"1620\":1}}],[\"使用sql语句进行分组的查询是一个很常见的需求\",{\"1\":{\"1613\":1}}],[\"使用sql语句\",{\"1\":{\"1611\":1}}],[\"使用select\",{\"1\":{\"1565\":1}}],[\"使用servletcontext获取到的bean对象也是经过cglib代理的对象\",{\"1\":{\"988\":1}}],[\"使用service\",{\"1\":{\"906\":1}}],[\"使用stream的api很像在使用sql语句\",{\"1\":{\"1613\":1}}],[\"使用stream的就称之为内部迭代\",{\"1\":{\"1611\":1}}],[\"使用straight\",{\"1\":{\"401\":1}}],[\"使用stop方法强行终止\",{\"1\":{\"1379\":1}}],[\"使用slaveof\",{\"1\":{\"610\":1}}],[\"使用sleep\",{\"1\":{\"424\":1}}],[\"使用s2作为驱动表的总成本就是\",{\"1\":{\"555\":1}}],[\"使用s2作为被驱动表与使用s1作为被驱动表有一个区别就是\",{\"1\":{\"555\":1}}],[\"使用show\",{\"1\":{\"476\":1,\"553\":3}}],[\"使用单表查询需要\",{\"1\":{\"401\":1}}],[\"使用尽可能少的查询当然是更好的\",{\"1\":{\"392\":1}}],[\"使用到类时才会加载\",{\"1\":{\"1663\":1}}],[\"使用到a\",{\"1\":{\"377\":5}}],[\"使用到了覆盖索引\",{\"1\":{\"375\":8,\"376\":2}}],[\"使用索引的类型\",{\"1\":{\"553\":1}}],[\"使用索引的成本会除去读取并检测回表后聚簇索引记录的成本\",{\"1\":{\"551\":1}}],[\"使用索引idx\",{\"1\":{\"544\":2}}],[\"使用索引优化group\",{\"0\":{\"417\":1}}],[\"使用索引覆盖扫描\",{\"1\":{\"390\":2}}],[\"使用索引范围查询\",{\"1\":{\"375\":1}}],[\"使用索引a\",{\"1\":{\"347\":1}}],[\"使用mapper扫描器\",{\"1\":{\"1217\":1}}],[\"使用mybatis的二级缓存可能会存在如下两个问题\",{\"1\":{\"1219\":1}}],[\"使用myisam存储引擎的表来说\",{\"1\":{\"548\":1}}],[\"使用mysqlbinlog方法恢复数据还是不够快\",{\"1\":{\"485\":1}}],[\"使用mysqlbinlog解析出日志\",{\"1\":{\"454\":1}}],[\"使用mysql内置的函数\",{\"1\":{\"371\":1}}],[\"使用mq如何保证分布式事务的最终一致性\",{\"0\":{\"252\":1,\"1333\":1}}],[\"使用覆盖索引就不会全表扫描了\",{\"1\":{\"369\":1}}],[\"使用覆盖索引\",{\"1\":{\"356\":1}}],[\"使用倒序存储和使用哈希字段两种方式的异同点如下\",{\"1\":{\"352\":1}}],[\"使用哈希字段方式的查询性能相对更稳定一些\",{\"1\":{\"352\":1}}],[\"使用哈希字段指的是可以在表上创建一个整数字段\",{\"1\":{\"352\":1}}],[\"使用哈希算法不可避免的就会遇到哈希冲突\",{\"1\":{\"332\":1}}],[\"使用普通索引需要把回表的代价算进去\",{\"1\":{\"347\":1}}],[\"使用collect\",{\"1\":{\"1615\":1}}],[\"使用competionservice实现先获取的报价先保存到数据库\",{\"1\":{\"1517\":1}}],[\"使用change\",{\"1\":{\"344\":1}}],[\"使用cat命令如何统计文件中一个字符串出现的频率\",{\"0\":{\"255\":1,\"1464\":1}}],[\"使用了spliterators并行算法的实现\",{\"1\":{\"1620\":1}}],[\"使用了语句级的锁\",{\"1\":{\"492\":1}}],[\"使用了内存临时表\",{\"1\":{\"421\":1}}],[\"使用了临时表\",{\"1\":{\"414\":1}}],[\"使用了临时表保存中间结果\",{\"1\":{\"330\":1}}],[\"使用了t\",{\"1\":{\"366\":1}}],[\"使用了连接缓存\",{\"1\":{\"330\":1}}],[\"使用\",{\"1\":{\"306\":1,\"454\":1,\"1210\":1,\"1242\":4,\"1433\":1,\"1464\":1,\"1473\":1,\"1663\":1,\"1980\":1}}],[\"使用可变类当hashmap的key有什么问题\",{\"0\":{\"37\":1,\"1365\":1}}],[\"与面向切面编程\",{\"1\":{\"1982\":1}}],[\"与propertyeditor相比\",{\"1\":{\"1639\":1}}],[\"与propertyeditor类似\",{\"1\":{\"1639\":1}}],[\"与原生特定相关的类增加了用来处理结果集合添加到特定的特化的管道\",{\"1\":{\"1621\":1}}],[\"与原库的值不同\",{\"1\":{\"327\":2}}],[\"与groupingby相关联的另一个方法就是分区partitioningby\",{\"1\":{\"1618\":1}}],[\"与另一个比较器相比\",{\"1\":{\"1614\":1}}],[\"与分组相关的实际上还有一个概念叫做分区\",{\"1\":{\"1613\":1}}],[\"与map比较类似的还有一个flatmap\",{\"1\":{\"1609\":1}}],[\"与memcached一样\",{\"1\":{\"564\":1}}],[\"与传统的方式\",{\"1\":{\"1607\":1}}],[\"与静态方法引用的不同的是\",{\"1\":{\"1604\":1}}],[\"与大多数其他的函数式接口不同的是\",{\"1\":{\"1597\":1}}],[\"与普通的应用程序不同\",{\"1\":{\"1579\":1}}],[\"与h\",{\"1\":{\"1548\":1}}],[\"与hashmap不同的是\",{\"1\":{\"1544\":1}}],[\"与钱相关的业务\",{\"1\":{\"1479\":1}}],[\"与应用程序时并发执行\",{\"1\":{\"1447\":1}}],[\"与集合类似\",{\"1\":{\"1280\":1}}],[\"与之相反\",{\"1\":{\"1619\":1}}],[\"与之相关的会衍生出一系列的问题\",{\"1\":{\"1270\":1}}],[\"与之前介绍的consumer函数一样\",{\"1\":{\"1598\":1}}],[\"与之对应的就是强一致性\",{\"1\":{\"1333\":1}}],[\"与之对应的\",{\"1\":{\"309\":1}}],[\"与其他spring功能性注解的任意组合\",{\"1\":{\"1135\":1}}],[\"与\",{\"1\":{\"1065\":1,\"1479\":1,\"1647\":1}}],[\"与java\",{\"1\":{\"1062\":1}}],[\"与key数量相关\",{\"1\":{\"567\":1}}],[\"与servletrequest\",{\"1\":{\"1687\":1}}],[\"与server\",{\"1\":{\"557\":1}}],[\"与synchronized一样\",{\"1\":{\"1494\":1}}],[\"与statement格式的binlog相比\",{\"1\":{\"454\":1}}],[\"与计算idx\",{\"1\":{\"549\":1}}],[\"与系统当前其他活跃事务的id去对比\",{\"1\":{\"542\":1}}],[\"与字符集相关\",{\"1\":{\"530\":1}}],[\"与字符集无关\",{\"1\":{\"530\":1}}],[\"与时区无关\",{\"1\":{\"529\":1}}],[\"与时区相关\",{\"1\":{\"529\":1}}],[\"与redo\",{\"1\":{\"479\":1}}],[\"与处于commit状态的事务之间\",{\"1\":{\"465\":1}}],[\"与数据同步有关的时间点主要包括以下三个\",{\"1\":{\"457\":1}}],[\"与ftwrl类似\",{\"1\":{\"440\":1}}],[\"与使用delete语句删除数据相比\",{\"1\":{\"426\":1}}],[\"与临时表相类似的还有内存表\",{\"1\":{\"409\":1}}],[\"与没有适用mrr的结果集顺序刚好相反\",{\"1\":{\"404\":1}}],[\"与前面的例子中的sql语句\",{\"1\":{\"351\":1}}],[\"与实际的10000相差较大\",{\"1\":{\"347\":1}}],[\"与查询流程不一样的是\",{\"1\":{\"323\":1}}],[\"与oauth2\",{\"0\":{\"221\":1,\"1204\":1}}],[\"会有更好的连贯性\",{\"1\":{\"1982\":1}}],[\"会有一个容器将所有的操作保存下来\",{\"1\":{\"1611\":1}}],[\"会有一些基本的准则\",{\"1\":{\"1308\":1}}],[\"会首先创建线程\",{\"1\":{\"1689\":1}}],[\"会创建一个对应的class类型的对象实例放到堆中\",{\"1\":{\"1663\":1}}],[\"会找不到对应的controller\",{\"1\":{\"1660\":1}}],[\"会按照自然排序进行执行\",{\"1\":{\"1654\":1}}],[\"会按照索引列的顺序来维护b+树\",{\"1\":{\"505\":1}}],[\"会再检查methodmatcher里带参数matches的方法是否返回true\",{\"1\":{\"1654\":1}}],[\"会再计算一次使用索引的成本\",{\"1\":{\"551\":1}}],[\"会查找advisor类型的bean\",{\"1\":{\"1654\":1}}],[\"会生成代理类\",{\"1\":{\"1652\":1}}],[\"会生成cglib的代理对象\",{\"1\":{\"1650\":1}}],[\"会生成id=2\",{\"1\":{\"490\":1}}],[\"会检查beandefinition的属性是否已经被赋值过了\",{\"1\":{\"1647\":1}}],[\"会调用销毁方法\",{\"1\":{\"1647\":1}}],[\"会调用每个单例bean的aftersingletonsinstantiated方法\",{\"1\":{\"1647\":1}}],[\"会调用父类的longaccumelate去初始化cell\",{\"1\":{\"1480\":1}}],[\"会保证处理一个元素一定是happens\",{\"1\":{\"1623\":1}}],[\"会保存下游的对象\",{\"1\":{\"1623\":1}}],[\"会接收这个操作的所对应的输入元素的类型并且执行这个操作\",{\"1\":{\"1623\":1}}],[\"会重新设置sink的状态并且刷新数据集\",{\"1\":{\"1623\":1}}],[\"会输出字符串的子集\",{\"1\":{\"1623\":1}}],[\"会直接转换类型\",{\"1\":{\"1617\":1}}],[\"会直接从内存中取出\",{\"1\":{\"1343\":1}}],[\"会从流中的第一个元素开始应用所有对于流元素的操作\",{\"1\":{\"1612\":1}}],[\"会得到如下的输出\",{\"1\":{\"1610\":1}}],[\"会出现死循环\",{\"1\":{\"1551\":1}}],[\"会出现死锁\",{\"1\":{\"535\":1}}],[\"会执行一个策略\",{\"1\":{\"1520\":1}}],[\"会一直尝试唤醒后续节点\",{\"1\":{\"1496\":1}}],[\"会一直到根节点再到叶子节点查询\",{\"1\":{\"1265\":1}}],[\"会把接口扫描出来并且得到对应的beandefinition\",{\"1\":{\"1653\":1}}],[\"会把首节点唤醒\",{\"1\":{\"1491\":1}}],[\"会把主库执行的这个语句的线程id写到binlog中\",{\"1\":{\"413\":1}}],[\"会标记该class为不可偏向\",{\"1\":{\"1485\":1}}],[\"会释放对象锁\",{\"1\":{\"1477\":1}}],[\"会添加一个内存屏障\",{\"1\":{\"1473\":1}}],[\"会产生大量的空间碎片\",{\"1\":{\"1448\":1}}],[\"会产生多个进程同时拿到锁的情况\",{\"1\":{\"1288\":1}}],[\"会维护一个fd的结合fd\",{\"1\":{\"1423\":1}}],[\"会维护一个全局变量\",{\"1\":{\"556\":1}}],[\"会优化遍历并检测结构上的修改\",{\"1\":{\"1620\":1}}],[\"会优化调用顺序\",{\"1\":{\"1611\":1}}],[\"会优化放到队列缓冲区\",{\"1\":{\"1410\":1}}],[\"会优先选择全字段排序\",{\"1\":{\"356\":1}}],[\"会在父容器查找bean\",{\"1\":{\"1661\":1}}],[\"会在初始化后步骤中去寻找advisor类型的bean\",{\"1\":{\"1655\":1}}],[\"会在每一批的最后执行selectimports方法\",{\"1\":{\"1652\":1}}],[\"会在循环中不断等待数据\",{\"1\":{\"1520\":1}}],[\"会在线程池当前正在运行的thread线程池中处理被拒绝的任务\",{\"1\":{\"1410\":1}}],[\"会在表上加mdl读锁\",{\"1\":{\"481\":1}}],[\"会给string作为key的数据结构\",{\"1\":{\"1342\":1}}],[\"会丢数据\",{\"1\":{\"1327\":1}}],[\"会丢失最近n的事务的binlog日志\",{\"1\":{\"450\":1}}],[\"会要求响应快\",{\"1\":{\"1288\":1}}],[\"会带来磁盘io过高的问题\",{\"1\":{\"1265\":1}}],[\"会加间隙锁\",{\"1\":{\"1263\":1}}],[\"会加锁\",{\"1\":{\"433\":1}}],[\"会引起sql注入\",{\"1\":{\"1213\":1}}],[\"会作为map<string\",{\"1\":{\"1209\":1}}],[\"会开辟一块独立的session空间\",{\"1\":{\"1200\":1}}],[\"会实例化多个对象\",{\"1\":{\"1191\":1}}],[\"会获取到所有的\",{\"1\":{\"1183\":1}}],[\"会注册一个单例的environment对象到beanfactory中\",{\"1\":{\"1149\":1}}],[\"会通过annotationawareaspectjautoproxycreator将\",{\"1\":{\"1654\":1}}],[\"会通过接下来的方法进行替换\",{\"1\":{\"978\":1}}],[\"会通过执行select\",{\"1\":{\"457\":1}}],[\"会提前初始化方法\",{\"1\":{\"967\":1}}],[\"会进行属性合并的操作\",{\"1\":{\"964\":1}}],[\"会发现连接器需要完成3个高内聚的功能\",{\"1\":{\"1687\":1}}],[\"会发现缓存中的数据为空\",{\"1\":{\"1286\":1}}],[\"会发现事务t跟worker\",{\"1\":{\"461\":1}}],[\"会发生什么\",{\"1\":{\"1072\":2}}],[\"会发生歧义性\",{\"1\":{\"952\":1}}],[\"会对节点但做下线标识\",{\"1\":{\"621\":1}}],[\"会对读取的记录进行加锁\",{\"1\":{\"541\":1}}],[\"会占用大量的cpu资源\",{\"1\":{\"1510\":1}}],[\"会占用大量的系统资源\",{\"1\":{\"403\":1}}],[\"会占用一定的内存空间\",{\"1\":{\"590\":1}}],[\"会报错但是不影响后续命令入队\",{\"1\":{\"580\":1}}],[\"会为每个表维护一份统计数据\",{\"1\":{\"553\":1}}],[\"会分段放\",{\"1\":{\"525\":1}}],[\"会分配4个\",{\"1\":{\"492\":1}}],[\"会分配2个\",{\"1\":{\"492\":1}}],[\"会分配1个\",{\"1\":{\"492\":1}}],[\"会显示查询将访问的分区\",{\"1\":{\"506\":1}}],[\"会让整个mysql集群的所有节点都全军覆没\",{\"1\":{\"488\":1}}],[\"会让优化器无法完成索引覆盖扫描这类优化\",{\"1\":{\"385\":1}}],[\"会耗费较多的本地内存\",{\"1\":{\"482\":1}}],[\"会包含很多表\",{\"1\":{\"482\":1}}],[\"会看到command列显示为killed呢\",{\"1\":{\"481\":1}}],[\"会认为系统还是正常的\",{\"1\":{\"476\":1}}],[\"会认为有\",{\"1\":{\"459\":1}}],[\"会阻止其他语句进入引擎执行\",{\"1\":{\"476\":1}}],[\"会不断应用n\",{\"1\":{\"1609\":1}}],[\"会不断地循环执行这条更新语句\",{\"1\":{\"455\":1}}],[\"会不会很快就把128消耗完呢\",{\"1\":{\"476\":1}}],[\"会称为新的主库\",{\"1\":{\"466\":1}}],[\"会记录插入的行的所有字段的值\",{\"1\":{\"459\":1}}],[\"会多记录set\",{\"1\":{\"454\":1}}],[\"会被封装成methodinterceptor\",{\"1\":{\"1654\":1}}],[\"会被自动delete\",{\"1\":{\"569\":1}}],[\"会被选为这组的leader\",{\"1\":{\"451\":1}}],[\"会被锁住\",{\"1\":{\"433\":1}}],[\"会\",{\"1\":{\"433\":1,\"1182\":1}}],[\"会根据earlyproxyreferences这个map来判断是否需要aop操作\",{\"1\":{\"1649\":1}}],[\"会根据strictmap<string\",{\"1\":{\"1208\":1}}],[\"会根据名称和类型共同查找\",{\"1\":{\"1091\":1}}],[\"会根据这个list里面的bean的名称\",{\"1\":{\"975\":1}}],[\"会根据分区表规则\",{\"1\":{\"425\":1}}],[\"会根据文档的字段自动识别类型\",{\"1\":{\"309\":1}}],[\"会扫描表t2的每一行\",{\"1\":{\"407\":1}}],[\"会扫描多少行\",{\"1\":{\"336\":1}}],[\"会先申请可以操作的元素在数组中的问题\",{\"1\":{\"1519\":1}}],[\"会先在缓存\",{\"1\":{\"626\":1}}],[\"会先放在old区域\",{\"1\":{\"406\":1}}],[\"会先到查询缓存看看\",{\"1\":{\"319\":1}}],[\"会话c先启动一个单独的语句\",{\"1\":{\"396\":1}}],[\"会话b启动事务\",{\"1\":{\"396\":1}}],[\"会话a先启动事务并查询一次表的总行数\",{\"1\":{\"396\":1}}],[\"会使用synchronized锁把头结点锁住\",{\"1\":{\"1554\":1}}],[\"会使用到覆盖索引\",{\"1\":{\"374\":1}}],[\"会使索引失效\",{\"1\":{\"371\":1}}],[\"会将执行的方法名称设置为事务的名称\",{\"1\":{\"1655\":1}}],[\"会将返回的对象放置到earlysingletonobjects中\",{\"1\":{\"1649\":1}}],[\"会将aop需要执行的方法缓存\",{\"1\":{\"1630\":1}}],[\"会将一个stream转换为另一个stream\",{\"1\":{\"1619\":1}}],[\"会将一个任务分解为多个子任务交给多分线程并行执行\",{\"1\":{\"1530\":1}}],[\"会将中间结果容器强制转换为最终的结果类型\",{\"1\":{\"1617\":1}}],[\"会将对象熬过垃圾收集的次数\",{\"1\":{\"1434\":1}}],[\"会将sql中的\",{\"1\":{\"1210\":1}}],[\"会将propertyvalues\",{\"1\":{\"1070\":1}}],[\"会将版本链上最新的数据复制一份\",{\"1\":{\"542\":1}}],[\"会将字符串转换成数字\",{\"1\":{\"367\":1}}],[\"会将数据页做合并\",{\"1\":{\"335\":1}}],[\"会影响排序效率\",{\"1\":{\"356\":1}}],[\"会自动跳转到student的无参构造的地方\",{\"1\":{\"1600\":1}}],[\"会自动注册一个workqueue到pool\",{\"1\":{\"1513\":1}}],[\"会自动将slave切换成master\",{\"1\":{\"620\":1}}],[\"会自动删除临时表\",{\"1\":{\"410\":1,\"413\":1}}],[\"会自动触发重新做一次索引统计\",{\"1\":{\"347\":1}}],[\"会自动创建映射\",{\"1\":{\"309\":1}}],[\"会立即触发merge过程\",{\"1\":{\"344\":1}}],[\"会怎么样呢\",{\"1\":{\"340\":1}}],[\"会抛出异常\",{\"1\":{\"309\":1}}],[\"会导致客户端连接超时\",{\"1\":{\"1573\":1}}],[\"会导致hashmap中的链表中出现循环节点\",{\"1\":{\"1551\":1}}],[\"会导致\",{\"1\":{\"1483\":1}}],[\"会导致一些不确定的情况发生\",{\"1\":{\"952\":1}}],[\"会导致一些功能无法正常运行\",{\"1\":{\"309\":1}}],[\"会导致该记录的undo\",{\"1\":{\"542\":1}}],[\"会导致结果不一致\",{\"1\":{\"522\":1}}],[\"会导致上下文切换的成本会过高\",{\"1\":{\"476\":1}}],[\"会导致主备不一致的问题\",{\"1\":{\"460\":1}}],[\"会导致索引失效而转向全表扫描\",{\"1\":{\"369\":1}}],[\"会导致索引数量激增\",{\"1\":{\"339\":1}}],[\"会导致已经被索引的数据无法被搜索\",{\"1\":{\"309\":1}}],[\"会递增1\",{\"1\":{\"304\":1}}],[\"主流框架\",{\"0\":{\"1979\":1}}],[\"主流大小是64个字节\",{\"1\":{\"1519\":1}}],[\"主内存与工作内存\",{\"0\":{\"1809\":1}}],[\"主程序阻塞在accept操作上\",{\"1\":{\"1573\":1}}],[\"主节点没有应答哨兵sentinel\",{\"1\":{\"624\":1}}],[\"主节点的存储能力收到单机的限制\",{\"1\":{\"621\":1}}],[\"主节点的写能力收到单机的限制\",{\"1\":{\"621\":1}}],[\"主节点不但负责数据读写\",{\"1\":{\"618\":1}}],[\"主节点以写为主\",{\"1\":{\"606\":1}}],[\"主机故障后\",{\"1\":{\"611\":1}}],[\"主机可读可写但是多用于写\",{\"1\":{\"611\":1}}],[\"主机掉电的时候会丢数据\",{\"1\":{\"451\":1}}],[\"主机掉电时会丢binlog日志\",{\"1\":{\"451\":1}}],[\"主从消息不丢失策略\",{\"1\":{\"1328\":1}}],[\"主从可以切换\",{\"1\":{\"623\":1}}],[\"主从切换技术的方法是\",{\"1\":{\"619\":1}}],[\"主从复制时最终一致性\",{\"1\":{\"621\":1}}],[\"主从复制还是哨兵和集群能够实施的基础\",{\"1\":{\"607\":1}}],[\"主从复制实现了数据的热备份\",{\"1\":{\"607\":1}}],[\"主从复制\",{\"1\":{\"606\":1}}],[\"主从\",{\"1\":{\"564\":1}}],[\"主备同步\",{\"0\":{\"1931\":1}}],[\"主备切换不是不需要找位点了\",{\"1\":{\"468\":1}}],[\"主备切换就变成了\",{\"1\":{\"468\":1}}],[\"主备切换的可用性优先策略会导致数据不一致\",{\"1\":{\"459\":1}}],[\"主备切换可能是一个主动运维动作\",{\"1\":{\"457\":1}}],[\"主备可能发生切换\",{\"1\":{\"457\":1}}],[\"主备延迟最直接的表现是\",{\"1\":{\"457\":1}}],[\"主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差\",{\"1\":{\"457\":1}}],[\"主备延迟及其来源\",{\"0\":{\"457\":1}}],[\"主备延迟\",{\"0\":{\"456\":1}}],[\"主备的基本原理\",{\"0\":{\"453\":1}}],[\"主备一致\",{\"0\":{\"452\":1}}],[\"主动将session复制到集群中的其他实例\",{\"1\":{\"1200\":1}}],[\"主动获取\",{\"1\":{\"911\":1}}],[\"主动跳过一个事务\",{\"1\":{\"467\":1}}],[\"主动死锁检测在发生死锁的时候\",{\"1\":{\"444\":1}}],[\"主动回滚锁链条的某一个事务\",{\"1\":{\"444\":1}}],[\"主库的位点或者gtid集合更新很快\",{\"1\":{\"472\":1}}],[\"主库的binlog格式必须是row\",{\"1\":{\"462\":1}}],[\"主库只要等到一个从库的ack\",{\"1\":{\"472\":1}}],[\"主库收到这个ack以后\",{\"1\":{\"472\":1}}],[\"主库把binlog发给从库\",{\"1\":{\"472\":1}}],[\"主库执行完成\",{\"1\":{\"472\":1}}],[\"主库就发哪个位点\",{\"1\":{\"468\":1}}],[\"主库故障后的主备切换流程如下\",{\"1\":{\"466\":1}}],[\"主库负责所有的写入和一部分读\",{\"1\":{\"466\":1}}],[\"主库上执行完成了三个事务trx1\",{\"1\":{\"472\":1}}],[\"主库上可以并行执行的事务\",{\"1\":{\"464\":1}}],[\"主库上不同的线程创建同名的临时表是没有关系的\",{\"1\":{\"413\":1}}],[\"主库和备库上都是3行数据\",{\"1\":{\"459\":1}}],[\"主库提供写能力\",{\"1\":{\"457\":1}}],[\"主库所在机器按计划下线等\",{\"1\":{\"457\":1}}],[\"主库a\",{\"1\":{\"468\":1}}],[\"主库a已经执行完成了一个insert语句插入了一行数据r\",{\"1\":{\"467\":1}}],[\"主库a和备库b上出现了两行不一致的数据\",{\"1\":{\"459\":1}}],[\"主库a和备库b都处于readonly的状态\",{\"1\":{\"458\":1}}],[\"主库a执行完成一个事务\",{\"1\":{\"457\":1}}],[\"主库a校验完用户名\",{\"1\":{\"453\":1}}],[\"主库a内部有一个线程\",{\"1\":{\"453\":1}}],[\"主库接收到客户端的更新请求后\",{\"1\":{\"453\":1}}],[\"主库m上的两个session创建了同名的临时表t1\",{\"1\":{\"413\":1}}],[\"主库在线程退出的时候\",{\"1\":{\"413\":1}}],[\"主键避重\",{\"1\":{\"1270\":1}}],[\"主键自增且连续\",{\"1\":{\"522\":1}}],[\"主键自动建立主键索引\",{\"1\":{\"358\":1}}],[\"主键空缺\",{\"1\":{\"522\":1}}],[\"主键冲突\",{\"1\":{\"491\":1}}],[\"主键值和唯一索引值\",{\"1\":{\"462\":1}}],[\"主键是m\",{\"1\":{\"416\":1}}],[\"主键id\",{\"1\":{\"399\":4}}],[\"主键\",{\"1\":{\"361\":1,\"362\":2,\"363\":1}}],[\"主键长度越小\",{\"1\":{\"335\":1}}],[\"主键索引\",{\"1\":{\"519\":1,\"1276\":1}}],[\"主键索引树的叶子节点是数据\",{\"1\":{\"396\":1}}],[\"主键索引也被称为聚簇索引\",{\"1\":{\"335\":1}}],[\"主键索引的叶子节点存储的是整行数据\",{\"1\":{\"335\":1}}],[\"主键等\",{\"1\":{\"309\":1}}],[\"主要就是加载自己写的那些类\",{\"1\":{\"1663\":1}}],[\"主要思路是利用三级缓存\",{\"1\":{\"1649\":1}}],[\"主要思想\",{\"1\":{\"1475\":1}}],[\"主要用于迭代的快速失败\",{\"1\":{\"1546\":1}}],[\"主要用于维护获取锁失败时的入队的线程\",{\"1\":{\"1490\":1}}],[\"主要表现在三个方面\",{\"1\":{\"1479\":1}}],[\"主要区别\",{\"1\":{\"1424\":1}}],[\"主要考虑到模运算的速度比位运算的的快\",{\"1\":{\"1357\":1}}],[\"主要作用就是由生产者发送到ｍｑ进行排队\",{\"1\":{\"1326\":1}}],[\"主要在计数器场景使用\",{\"1\":{\"1293\":1}}],[\"主要在以下三个方面\",{\"1\":{\"352\":1}}],[\"主要分为refresh\",{\"1\":{\"1178\":1}}],[\"主要分为两种\",{\"1\":{\"995\":1}}],[\"主要\",{\"1\":{\"1129\":1}}],[\"主要来源xml资源配置beandefinition\",{\"1\":{\"1071\":1}}],[\"主要技术\",{\"1\":{\"1060\":1}}],[\"主要概念\",{\"1\":{\"1050\":1}}],[\"主要包括了di\",{\"1\":{\"924\":1}}],[\"主要有两种实现\",{\"1\":{\"928\":1}}],[\"主要有依赖查找和依赖注入两种实现\",{\"1\":{\"914\":1}}],[\"主要有create\",{\"1\":{\"307\":1}}],[\"主要原因有两个\",{\"1\":{\"485\":1}}],[\"主要是为了解决\",{\"1\":{\"1652\":1}}],[\"主要是为了取模和扩容时做优化\",{\"1\":{\"1546\":1}}],[\"主要是加载properties资源\",{\"1\":{\"1651\":1}}],[\"主要是通过commonannotationbeanpostprocessor来实现\",{\"1\":{\"1648\":1}}],[\"主要是从速度\",{\"1\":{\"1548\":1}}],[\"主要是针对于ejb\",{\"1\":{\"910\":1}}],[\"主要是因为来一个请求就直接对磁盘文件进行随机读写\",{\"1\":{\"543\":1}}],[\"主要是将要被修改的数据的最新记录中的db\",{\"1\":{\"542\":1}}],[\"主要是基于一致性和节省存储空间的考虑\",{\"1\":{\"505\":1}}],[\"主要是对更新性能的影响\",{\"1\":{\"344\":1}}],[\"主要是用于区别\",{\"1\":{\"330\":1}}],[\"主要是用来恢复数据时处理当多个文档的\",{\"1\":{\"304\":1}}],[\"长整型等\",{\"1\":{\"1623\":1}}],[\"长时间地不成功\",{\"1\":{\"1479\":1}}],[\"长期不用也会被gc\",{\"1\":{\"1435\":1}}],[\"长文本数据\",{\"1\":{\"530\":1}}],[\"长字符串我们可以采用前缀索引\",{\"1\":{\"521\":1}}],[\"长事务意味着系统里面会存在很老的事务视图\",{\"1\":{\"434\":1}}],[\"长连接是指连接成功后\",{\"1\":{\"318\":1}}],[\"长连接和短连接\",{\"1\":{\"318\":1}}],[\"长度开始时必须指定\",{\"1\":{\"1538\":1}}],[\"长度为10\",{\"1\":{\"1535\":1}}],[\"长度为8字节\",{\"1\":{\"1484\":1}}],[\"长度为6个字节的row\",{\"1\":{\"495\":1}}],[\"长度越短越好\",{\"1\":{\"330\":1}}],[\"长度\",{\"1\":{\"309\":1,\"1503\":1,\"1548\":1}}],[\"长沙\",{\"1\":{\"309\":1}}],[\"长沙麓谷\",{\"1\":{\"309\":1}}],[\"长沙麓谷兴工国际产业园\",{\"1\":{\"306\":1}}],[\"长沙麓谷企业广场\",{\"1\":{\"306\":1}}],[\"长沙橘子洲\",{\"1\":{\"306\":1}}],[\"类与对象\",{\"1\":{\"1969\":1}}],[\"类与类加载器\",{\"0\":{\"1792\":1}}],[\"类索引\",{\"0\":{\"1779\":1}}],[\"类文件结构\",{\"0\":{\"1699\":1}}],[\"类库可被tomcat和所有的web应用程序共同使用\",{\"1\":{\"1693\":1}}],[\"类被加载到方法区中后主要包含运行时常量池\",{\"1\":{\"1663\":1}}],[\"类上的注解\",{\"1\":{\"1646\":1}}],[\"类中的方法\",{\"1\":{\"1646\":1}}],[\"类中的方法才表示具体的行为\",{\"1\":{\"1607\":1}}],[\"类加载机制\",{\"0\":{\"1700\":1}}],[\"类加载检查\",{\"0\":{\"1666\":1}}],[\"类加载的引用\",{\"1\":{\"1663\":1}}],[\"类加载期间完成\",{\"1\":{\"1663\":1}}],[\"类加载\",{\"1\":{\"1647\":1}}],[\"类加载器在加载类信息放到方法区中后\",{\"1\":{\"1663\":1}}],[\"类加载器的引用\",{\"1\":{\"1663\":1}}],[\"类加载器\",{\"0\":{\"1791\":1},\"1\":{\"1636\":1}}],[\"类加载过程\",{\"0\":{\"1785\":1},\"1\":{\"1433\":1,\"1692\":1}}],[\"类的说明\",{\"1\":{\"1623\":2}}],[\"类的任意对象的实例方法引用\",{\"1\":{\"1602\":1}}],[\"类unix的操作系统中创建进行的api是fork\",{\"1\":{\"1527\":1}}],[\"类bar中持有对foo的引用foo\",{\"1\":{\"1526\":1}}],[\"类和属性都是final的\",{\"1\":{\"1526\":1}}],[\"类元数据卸载\",{\"1\":{\"1457\":1}}],[\"类元信息\",{\"1\":{\"1134\":2}}],[\"类名\",{\"1\":{\"1242\":1}}],[\"类\",{\"1\":{\"1075\":1,\"1575\":3}}],[\"类路径\",{\"1\":{\"1039\":1}}],[\"类对象\",{\"1\":{\"1027\":1}}],[\"类似这样的代码\",{\"1\":{\"1609\":1}}],[\"类似广播\",{\"1\":{\"1419\":1}}],[\"类似打电话\",{\"1\":{\"1419\":1}}],[\"类似关系型数据库中的table\",{\"1\":{\"1254\":1}}],[\"类似关系型数据库表中的一条记录\",{\"1\":{\"304\":1}}],[\"类似于hashmap中的entry\",{\"1\":{\"1553\":1}}],[\"类似于\",{\"1\":{\"1023\":2}}],[\"类似于好莱坞原则\",{\"1\":{\"914\":1}}],[\"类似于执行一条select\",{\"1\":{\"471\":1}}],[\"类似list\",{\"1\":{\"583\":1}}],[\"类似string\",{\"1\":{\"583\":1}}],[\"类似上述的\",{\"1\":{\"553\":1}}],[\"类似insert\",{\"1\":{\"492\":1}}],[\"类似下面的命令\",{\"1\":{\"454\":1}}],[\"类似的对于分区的操作也可以进行二级分区\",{\"1\":{\"1616\":1}}],[\"类似的max\",{\"1\":{\"1610\":1}}],[\"类似的方法指定字段显示宽度\",{\"1\":{\"528\":1}}],[\"类似的\",{\"1\":{\"454\":1,\"460\":1,\"1599\":1,\"1614\":1,\"1648\":1}}],[\"类似地\",{\"1\":{\"368\":1}}],[\"类型信息\",{\"1\":{\"1663\":1}}],[\"类型必须要是原生类型的包装类型\",{\"1\":{\"1620\":1}}],[\"类型可以是不相同的\",{\"1\":{\"1601\":1}}],[\"类型接口\",{\"1\":{\"1106\":1}}],[\"类型擦除确保不会为参数化类型创建新类\",{\"1\":{\"1098\":1}}],[\"类型条件接口\",{\"1\":{\"1096\":1}}],[\"类型条件判断\",{\"1\":{\"1090\":1}}],[\"类型在进行转换的时候\",{\"1\":{\"1089\":1}}],[\"类型转化注册器\",{\"1\":{\"1651\":1}}],[\"类型转化服务\",{\"1\":{\"1070\":1}}],[\"类型转化器\",{\"1\":{\"1070\":1}}],[\"类型转换器底层委派实现\",{\"1\":{\"1093\":1}}],[\"类型转换器底层抽象实现\",{\"1\":{\"1093\":1}}],[\"类型转换器底层接口\",{\"1\":{\"1093\":1}}],[\"类型转换场景\",{\"1\":{\"1089\":1}}],[\"类型转换接口\",{\"1\":{\"1086\":1,\"1096\":1}}],[\"类型转换后的值\",{\"1\":{\"1071\":1}}],[\"类型转换非常麻烦\",{\"1\":{\"645\":1}}],[\"类型转换\",{\"1\":{\"369\":1,\"892\":1}}],[\"类型为\",{\"1\":{\"1055\":1}}],[\"类型描述\",{\"1\":{\"963\":1,\"1086\":1,\"1089\":1}}],[\"类型的bean\",{\"1\":{\"946\":1}}],[\"类型安全的依赖查找示例\",{\"1\":{\"944\":1}}],[\"类型安全的依赖查找的相关示例\",{\"1\":{\"944\":1}}],[\"类型查找时\",{\"1\":{\"946\":1}}],[\"类型查找\",{\"1\":{\"940\":1}}],[\"类型之外\",{\"1\":{\"330\":1}}],[\"类型\",{\"0\":{\"1766\":1},\"1\":{\"309\":1,\"420\":1,\"528\":1,\"529\":1,\"530\":1,\"911\":1,\"975\":1,\"978\":1,\"1038\":1,\"1099\":1,\"1261\":1,\"1395\":1,\"1636\":1}}],[\"实时注入\",{\"1\":{\"918\":1,\"962\":1,\"963\":1}}],[\"实时查找\",{\"1\":{\"917\":4}}],[\"实数乘以相应的倍数后再操作\",{\"1\":{\"528\":1}}],[\"实例方法名引用\",{\"0\":{\"1605\":1}}],[\"实例方法引用\",{\"0\":{\"1604\":1}}],[\"实例方法实例化bean\",{\"1\":{\"930\":1}}],[\"实例代码如下\",{\"1\":{\"1588\":1}}],[\"实例数据\",{\"1\":{\"1484\":2}}],[\"实例化懒加载的bean\",{\"1\":{\"1651\":1}}],[\"实例化bean对象\",{\"1\":{\"1650\":1}}],[\"实例化bean的方式\",{\"0\":{\"930\":1}}],[\"实例化方法\",{\"1\":{\"1647\":1}}],[\"实例化前方法\",{\"1\":{\"1647\":1}}],[\"实例化前\",{\"1\":{\"1647\":1}}],[\"实例化前阶段\",{\"0\":{\"1000\":1}}],[\"实例化策略\",{\"1\":{\"1001\":1}}],[\"实例化阶段\",{\"0\":{\"1001\":1}}],[\"实例化\",{\"0\":{\"999\":1},\"1\":{\"1019\":1,\"1234\":2,\"1647\":2}}],[\"实例化propertiesbeandefinitionreader\",{\"1\":{\"994\":1}}],[\"实例\",{\"1\":{\"941\":1}}],[\"实例可以在多个线程中共享\",{\"1\":{\"583\":1}}],[\"实例a\",{\"1\":{\"468\":1}}],[\"实例b吧set\",{\"1\":{\"468\":1}}],[\"实例b指定主库a\",{\"1\":{\"468\":1}}],[\"实例b的gtid集合记为set\",{\"1\":{\"468\":1}}],[\"实例x作为y的从库\",{\"1\":{\"468\":1}}],[\"实现网站uv和dau统计\",{\"1\":{\"1987\":1}}],[\"实现java\",{\"1\":{\"1683\":1}}],[\"实现者必须按照servlet规范实现接口\",{\"1\":{\"1658\":1}}],[\"实现deferredimportselector接口的类\",{\"1\":{\"1652\":1}}],[\"实现disposablebean接口的destory\",{\"1\":{\"933\":1,\"1012\":1}}],[\"实现应该对于spliterator方法所返回的spliterator特性值进行文档化\",{\"1\":{\"1620\":1}}],[\"实现collector\",{\"1\":{\"1618\":1}}],[\"实现call方法\",{\"1\":{\"1377\":1}}],[\"实现callable接口\",{\"1\":{\"1377\":1}}],[\"实现是可以自由的实现\",{\"1\":{\"1615\":1}}],[\"实现代码如下\",{\"1\":{\"1587\":1}}],[\"实现了mergedbeandefinitionpostprocessor接口的beanpostprocessor的postprocessmergedbeandefinition会被放到最后再执行\",{\"1\":{\"1652\":1}}],[\"实现了map\",{\"1\":{\"1546\":1}}],[\"实现了configurablelistablebeanfactory接口和beandefinitionregistry接口\",{\"1\":{\"1636\":1}}],[\"实现了configurablebeanfactory接口\",{\"1\":{\"1636\":1}}],[\"实现了autowirecapablebeanfactory\",{\"1\":{\"1636\":1}}],[\"实现了aliasregistry接口中所定义的功能\",{\"1\":{\"1636\":1}}],[\"实现了singletonbeanregistry接口\",{\"1\":{\"1636\":1}}],[\"实现了基于事件驱动的生产者消费者模型\",{\"1\":{\"1519\":1}}],[\"实现了任务先完成可以优先获取到\",{\"1\":{\"1517\":1}}],[\"实现了隔离\",{\"1\":{\"1501\":1}}],[\"实现了union的语义\",{\"1\":{\"414\":1}}],[\"实现run方法\",{\"1\":{\"1377\":1}}],[\"实现runnable接口\",{\"1\":{\"1377\":1,\"1591\":1}}],[\"实现registercustomeditor\",{\"1\":{\"1084\":1}}],[\"实现resourceloaderaware回调\",{\"1\":{\"1045\":1}}],[\"实现高内聚低耦合的工具主要有同步的接口调用和异步的事件驱动\",{\"1\":{\"1308\":1}}],[\"实现高亮线显示\",{\"1\":{\"308\":1}}],[\"实现索引覆盖最简单的方式就是将要查询的字段\",{\"1\":{\"1268\":1}}],[\"实现消息推送系统\",{\"1\":{\"1223\":1}}],[\"实现即时通讯系统\",{\"1\":{\"1223\":1}}],[\"实现http服务器\",{\"1\":{\"1223\":1}}],[\"实现的拷贝\",{\"1\":{\"1583\":1}}],[\"实现的\",{\"1\":{\"1546\":1}}],[\"实现的无界阻塞队列\",{\"1\":{\"1501\":1}}],[\"实现的源码如下\",{\"1\":{\"1139\":1}}],[\"实现的核心代码在simpleapplicationeventmulticaster\",{\"1\":{\"1124\":1}}],[\"实现的核心源代码\",{\"1\":{\"1027\":1}}],[\"实现变化\",{\"1\":{\"1139\":1}}],[\"实现异步处理\",{\"1\":{\"1129\":1}}],[\"实现限制\",{\"1\":{\"1123\":1}}],[\"实现自定义的事件监听器\",{\"1\":{\"1119\":1}}],[\"实现通用算法\",{\"1\":{\"1098\":1}}],[\"实现接口类必须重写接口中的抽象方法\",{\"1\":{\"1345\":1}}],[\"实现接口的幂等性校验\",{\"1\":{\"1248\":1}}],[\"实现接口\",{\"1\":{\"1093\":1}}],[\"实现转换器接口\",{\"1\":{\"1091\":1}}],[\"实现步骤如下\",{\"1\":{\"1084\":1}}],[\"实现validate方法\",{\"1\":{\"1064\":1}}],[\"实现stw\",{\"0\":{\"1678\":1}}],[\"实现setastext方法\",{\"1\":{\"1082\":1,\"1084\":1}}],[\"实现supports方法\",{\"1\":{\"1064\":1}}],[\"实现scope\",{\"1\":{\"989\":1}}],[\"实现urlstreamhandlerfactory并传递到url之中\",{\"1\":{\"1049\":1}}],[\"实现urlstreamhandler\",{\"1\":{\"1049\":1}}],[\"实现urlstreamhandler并放置再sun\",{\"1\":{\"1049\":1}}],[\"实现org\",{\"1\":{\"1043\":1,\"1064\":1,\"1084\":1}}],[\"实现类threadpoolexecutor重写了execute方法\",{\"1\":{\"1408\":1}}],[\"实现类型\",{\"1\":{\"1092\":1}}],[\"实现类所在包名\",{\"1\":{\"1087\":1}}],[\"实现类无法感知目标转换类型\",{\"1\":{\"1085\":1}}],[\"实现类\",{\"1\":{\"1024\":1,\"1039\":1,\"1074\":1,\"1083\":1,\"1122\":1}}],[\"实现场景\",{\"1\":{\"1024\":1}}],[\"实现一下这个接口\",{\"1\":{\"1011\":1}}],[\"实现\",{\"0\":{\"1958\":1},\"1\":{\"986\":1,\"987\":1,\"988\":1,\"997\":1,\"1000\":1,\"1001\":1,\"1005\":1,\"1006\":1,\"1011\":1,\"1036\":1,\"1092\":1,\"1119\":1,\"1134\":1,\"1496\":1}}],[\"实现延迟依赖注入\",{\"1\":{\"962\":1}}],[\"实现方法\",{\"1\":{\"955\":1}}],[\"实现方提供依赖自动关联的方式\",{\"1\":{\"951\":1}}],[\"实现initializingbean接口的afterpropertiesset\",{\"1\":{\"931\":1,\"1007\":1}}],[\"实现便利性\",{\"1\":{\"911\":1}}],[\"实现原理就是defaultlistablebeanfactory\",{\"1\":{\"978\":1}}],[\"实现原理\",{\"0\":{\"723\":1},\"1\":{\"1289\":1}}],[\"实现与原理分析\",{\"0\":{\"663\":1}}],[\"实现哨兵模式的配置其实是很麻烦的\",{\"1\":{\"624\":1}}],[\"实现上\",{\"1\":{\"481\":1}}],[\"实现这个需求最简单的实现方式\",{\"1\":{\"419\":1}}],[\"实践中\",{\"1\":{\"411\":1}}],[\"实践中可以使用count\",{\"1\":{\"352\":1}}],[\"实际对象\",{\"1\":{\"1181\":1}}],[\"实际为configurablelistablebeanfactory\",{\"1\":{\"1016\":1}}],[\"实际使用的时候\",{\"1\":{\"1609\":1,\"1610\":1,\"1615\":1}}],[\"实际使用的索引\",{\"1\":{\"330\":1}}],[\"实际使用时\",{\"1\":{\"422\":1}}],[\"实际场景中\",{\"1\":{\"352\":1}}],[\"实际上调用处理程序之后调用\",{\"1\":{\"1657\":1}}],[\"实际上指的就是中间操作返回的新的流对象\",{\"1\":{\"1619\":1}}],[\"实际上就是除了预先定义好的收集器\",{\"1\":{\"1615\":1}}],[\"实际上这个是在并行中使用的\",{\"1\":{\"1615\":1}}],[\"实际上这两个静态方法放在任何一个类中\",{\"1\":{\"1605\":1}}],[\"实际上这两个概念是完全不同的\",{\"1\":{\"409\":1}}],[\"实际上并不是这样的\",{\"1\":{\"1611\":1}}],[\"实际上并不会起到很好的效果\",{\"1\":{\"1510\":1}}],[\"实际上在框架的底层就已经帮我们实现了\",{\"1\":{\"1612\":1}}],[\"实际上在stream出现之前的都称之为外部迭代\",{\"1\":{\"1611\":1}}],[\"实际上在collectors中有一种更为简洁的实现方案\",{\"1\":{\"1609\":1}}],[\"实际上在mysql中\",{\"1\":{\"367\":1}}],[\"实际上也可以n个的串联\",{\"1\":{\"1598\":1}}],[\"实际上也只有普通索引可以使用\",{\"1\":{\"343\":1}}],[\"实际上对于java这一门非常庞大臃肿的语言\",{\"1\":{\"1593\":1}}],[\"实际上程序运行过程中\",{\"1\":{\"1561\":1}}],[\"实际上表示cmpxchg\",{\"1\":{\"1479\":1}}],[\"实际上是一种设计上的考量\",{\"1\":{\"1616\":1}}],[\"实际上是一个索引值\",{\"1\":{\"1423\":1}}],[\"实际上是把这些统计数据存储到了两个表里\",{\"1\":{\"558\":1}}],[\"实际上hash\",{\"1\":{\"1357\":1}}],[\"实际上大部分情况下是不需要调优的\",{\"1\":{\"1257\":1}}],[\"实际上我们可以覆盖springboot中自动装配的messagesource\",{\"1\":{\"1056\":1}}],[\"实际上会返回一个代理对象\",{\"1\":{\"963\":1}}],[\"实际上每种数据结构都有自己底层的内部编码实现\",{\"1\":{\"569\":1}}],[\"实际上插入的数据就是\",{\"1\":{\"492\":1}}],[\"实际上往表t2插入了4行数据\",{\"1\":{\"492\":1}}],[\"实际上使用innodb引擎并不会出现这个问题\",{\"1\":{\"425\":1}}],[\"实际上它表示的就是每个引擎用来唯一标识数据行的信息\",{\"1\":{\"420\":1}}],[\"实际上它是可以持久化的数据\",{\"1\":{\"343\":1}}],[\"实际上可以通过设置参数binlog\",{\"1\":{\"413\":1}}],[\"实际上mysql却是先返回全部结果集再进行计算\",{\"1\":{\"383\":1}}],[\"实际上mysql服务端从排序后的sort\",{\"1\":{\"355\":1}}],[\"实际上要优化其子任务\",{\"1\":{\"381\":1}}],[\"实际上\",{\"1\":{\"366\":2,\"368\":1,\"396\":1,\"397\":1,\"418\":1,\"421\":1,\"424\":1,\"425\":1,\"426\":1,\"434\":1,\"451\":1,\"476\":2,\"482\":1,\"490\":1,\"495\":1,\"973\":1,\"993\":1,\"1139\":1,\"1561\":1,\"1570\":1,\"1576\":1,\"1580\":1,\"1592\":1,\"1593\":3,\"1595\":1,\"1600\":1,\"1605\":1,\"1607\":1,\"1613\":1,\"1623\":1}}],[\"实模式\",{\"0\":{\"290\":1}}],[\"偏向线程id\",{\"1\":{\"1484\":1}}],[\"偏向时间戳等\",{\"1\":{\"1484\":1}}],[\"偏向时间\",{\"1\":{\"1484\":1}}],[\"偏向锁撤销存在性能问题\",{\"1\":{\"1489\":1}}],[\"偏向锁重偏向一次之后不可再次重偏向\",{\"1\":{\"1485\":1}}],[\"偏向锁不仅不能提高性能\",{\"1\":{\"1485\":1}}],[\"偏向锁带来的性能开销基本可以忽略\",{\"1\":{\"1485\":1}}],[\"偏向锁模式存在偏向锁延迟机制\",{\"1\":{\"1485\":1}}],[\"偏向锁有很好的优化效果\",{\"1\":{\"1485\":1}}],[\"偏向锁是一种针对加锁操作的优化手段\",{\"1\":{\"1485\":1}}],[\"偏向锁\",{\"0\":{\"68\":1,\"1397\":1,\"1485\":1,\"1824\":1},\"1\":{\"1397\":2,\"1483\":1,\"1484\":2}}],[\"偏移量\",{\"0\":{\"1918\":1}}],[\"偏移\",{\"1\":{\"308\":1}}],[\"单元测试\",{\"1\":{\"1983\":1}}],[\"单元素的遍历迭代\",{\"1\":{\"1620\":1}}],[\"单从使用的角度而言\",{\"1\":{\"1612\":1}}],[\"单列集合\",{\"0\":{\"1539\":1}}],[\"单生产者\",{\"1\":{\"1520\":1,\"1521\":1}}],[\"单任务执行耗时以及并行数都会影响到fork\",{\"1\":{\"1510\":1}}],[\"单链表结构\",{\"1\":{\"1503\":1}}],[\"单向链表\",{\"1\":{\"1490\":1}}],[\"单核cpu自旋就是浪费\",{\"1\":{\"1485\":1}}],[\"单线程程序\",{\"1\":{\"1474\":1}}],[\"单线程的优势\",{\"1\":{\"1292\":1}}],[\"单机服务\",{\"1\":{\"1248\":1}}],[\"单机单个哨兵\",{\"0\":{\"620\":1}}],[\"单点登录系统是怎么做的\",{\"1\":{\"1205\":1}}],[\"单配置属性源\",{\"1\":{\"1153\":2}}],[\"单xml资源下的多个spring\",{\"1\":{\"1021\":1}}],[\"单体架构只要维护一个环节\",{\"1\":{\"1304\":1}}],[\"单体和分布式\",{\"1\":{\"1248\":1}}],[\"单体对象作为依赖来源\",{\"0\":{\"976\":1}}],[\"单体对象\",{\"1\":{\"974\":1}}],[\"单体bean注册示例\",{\"1\":{\"936\":1}}],[\"单例池\",{\"1\":{\"1651\":1}}],[\"单例或圆形\",{\"1\":{\"1632\":1}}],[\"单例集合和多列集合\",{\"1\":{\"1538\":1}}],[\"单例工程\",{\"1\":{\"1184\":1}}],[\"单例bean\",{\"1\":{\"1182\":1}}],[\"单例对象则没有这个限制\",{\"1\":{\"981\":1}}],[\"单例对象注册与beandefinition不同\",{\"1\":{\"981\":1}}],[\"单例对象能在ioc容器启动后注册吗\",{\"0\":{\"981\":1}}],[\"单例对象\",{\"1\":{\"972\":1,\"973\":1,\"982\":1}}],[\"单例模式下就会有线程安全问题\",{\"1\":{\"1240\":1}}],[\"单例模式的示例图\",{\"1\":{\"984\":1}}],[\"单例模式是在一定范围内是全局共享的\",{\"1\":{\"984\":1}}],[\"单例模式\",{\"0\":{\"838\":1}}],[\"单例模式有什么应用场景\",{\"0\":{\"272\":1,\"1196\":1}}],[\"单例模式有哪些实现方式\",{\"0\":{\"266\":1,\"1190\":1}}],[\"单一类型事件处理\",{\"1\":{\"1112\":1}}],[\"单一类型转换实现复杂\",{\"1\":{\"1090\":1}}],[\"单一类型查找\",{\"1\":{\"944\":1}}],[\"单一类型\",{\"1\":{\"942\":1,\"962\":2}}],[\"单一类型依赖查找接口\",{\"1\":{\"940\":1}}],[\"单一类型依赖查找\",{\"0\":{\"940\":1},\"1\":{\"939\":1}}],[\"单个spring\",{\"1\":{\"1021\":1}}],[\"单个线程下\",{\"1\":{\"989\":1}}],[\"单个bean对象\",{\"1\":{\"917\":1,\"918\":1}}],[\"单个事务如果超过设置的行的阈值\",{\"1\":{\"462\":1}}],[\"单台服务器内存容量有限\",{\"1\":{\"608\":1}}],[\"单台服务器故障率高\",{\"1\":{\"608\":1}}],[\"单台服务器难以负载大量的请求\",{\"1\":{\"608\":1}}],[\"单次查询s2\",{\"1\":{\"555\":1}}],[\"单次查询驱动表的成本\",{\"1\":{\"554\":1}}],[\"单次访问被驱动表的成本\",{\"1\":{\"555\":2}}],[\"单次访问驱动表的成本\",{\"1\":{\"555\":1}}],[\"单次io请求时间超过200毫秒属于异常\",{\"1\":{\"479\":1}}],[\"单独查询表的成本\",{\"1\":{\"553\":1}}],[\"单精度浮点数值\",{\"1\":{\"528\":1}}],[\"单位是字节\",{\"1\":{\"1669\":1}}],[\"单位是皮秒\",{\"1\":{\"479\":1}}],[\"单位时间内\",{\"1\":{\"1536\":1}}],[\"单位为微秒\",{\"1\":{\"588\":1}}],[\"单位与半径单位相同\",{\"1\":{\"576\":1}}],[\"单位字节\",{\"1\":{\"553\":1}}],[\"单位byte\",{\"1\":{\"520\":1}}],[\"单路排序会把需要查询的字段都放到sort\",{\"1\":{\"520\":1}}],[\"单路排序的详细过程\",{\"1\":{\"520\":1}}],[\"单路排序\",{\"1\":{\"520\":2}}],[\"单表查询的成本\",{\"0\":{\"546\":1}}],[\"单表或者单分区的数据一千万行\",{\"1\":{\"426\":1}}],[\"单表索引分析\",{\"0\":{\"361\":1}}],[\"单词在文档中的分析的位置\",{\"1\":{\"308\":1}}],[\"单词词典\",{\"1\":{\"308\":1}}],[\"用java实现一个jvm框架\",{\"0\":{\"1676\":1}}],[\"用以指向下一个可用的元素\",{\"1\":{\"1520\":1}}],[\"用future获取结果还好\",{\"1\":{\"1518\":1}}],[\"用flashback工具解析binlog后\",{\"1\":{\"484\":1}}],[\"用较简单的方法解决\",{\"1\":{\"1510\":1}}],[\"用while不用if是为了防止虚假唤醒\",{\"1\":{\"1502\":1}}],[\"用nextwaiter来连接\",{\"1\":{\"1492\":1}}],[\"用链表是来解决数组小表覆盖的问题\",{\"1\":{\"1475\":1}}],[\"用同样的操作查询数据\",{\"1\":{\"1261\":1}}],[\"用占位符处理\",{\"1\":{\"957\":1}}],[\"用指定的value\",{\"1\":{\"570\":1}}],[\"用版本对比来实现\",{\"1\":{\"533\":1}}],[\"用select的优势在于它可以同时处理多个connection\",{\"1\":{\"1565\":1}}],[\"用spring开发程序时\",{\"1\":{\"532\":1}}],[\"用statement格式的binlog来串行执行\",{\"1\":{\"492\":1}}],[\"用statement的话就是一个sql语句被记录到binlog中\",{\"1\":{\"454\":1}}],[\"用id关联\",{\"1\":{\"530\":1}}],[\"用incr或decr命令\",{\"1\":{\"526\":1}}],[\"用mysql的内建类型date\",{\"1\":{\"529\":1}}],[\"用mysqlbinlog解析出日志应用\",{\"1\":{\"485\":1}}],[\"用mysqlbinlog工具解析a\",{\"1\":{\"467\":1}}],[\"用mysqlbinlog工具解析出来\",{\"1\":{\"454\":1}}],[\"用途举例\",{\"1\":{\"570\":1}}],[\"用途\",{\"1\":{\"528\":1,\"529\":1,\"530\":1}}],[\"用bnl磁盘扫描次数少很多\",{\"1\":{\"525\":1}}],[\"用begin显式启动事务\",{\"1\":{\"435\":1}}],[\"用备份恢复出一个临时库\",{\"1\":{\"485\":1}}],[\"用ajax直接把客户端输入的内容作为\",{\"1\":{\"471\":1}}],[\"用的规则就不是\",{\"1\":{\"462\":1}}],[\"用的是索引a\",{\"1\":{\"454\":1}}],[\"用完再删除\",{\"1\":{\"431\":1}}],[\"用随机函数生成一个最大值和最小值之间的数x=\",{\"1\":{\"422\":1}}],[\"用到c1这一个字段\",{\"1\":{\"378\":1}}],[\"用到c1\",{\"1\":{\"378\":1}}],[\"用到索引c1\",{\"1\":{\"378\":5}}],[\"用到了c1\",{\"1\":{\"378\":3}}],[\"用到了c1一个字段\",{\"1\":{\"378\":1}}],[\"用到了索引c1\",{\"1\":{\"378\":4}}],[\"用到了覆盖索引\",{\"1\":{\"373\":1}}],[\"用到了idx\",{\"1\":{\"370\":4,\"372\":2}}],[\"用到了主键索引\",{\"1\":{\"330\":1}}],[\"用什么字段就查询什么字段\",{\"1\":{\"373\":1}}],[\"用它来连接时会索引失效\",{\"1\":{\"369\":1}}],[\"用来简化web应用程序开发的框架\",{\"1\":{\"1982\":1}}],[\"用来加载自定义路径下的类\",{\"1\":{\"1691\":1}}],[\"用来扫描mapper\",{\"1\":{\"1653\":1}}],[\"用来获取原始对象\",{\"1\":{\"1649\":1}}],[\"用来获取方法入参名称\",{\"1\":{\"1648\":1}}],[\"用来记录回到调用的地方继续执行程序的地方\",{\"1\":{\"1664\":1}}],[\"用来记录时间\",{\"1\":{\"1647\":1}}],[\"用来记录交易的操作细节\",{\"1\":{\"368\":1}}],[\"用来创建终止操作的实例\",{\"1\":{\"1623\":1}}],[\"用来完成向一个可变结果容器当中添加元素的\",{\"1\":{\"1615\":1}}],[\"用来避免自动拆箱装箱带来的性能的损耗\",{\"1\":{\"1607\":1}}],[\"用来根据objects类中的equals\",{\"1\":{\"1599\":1}}],[\"用来定位数组索引位置\",{\"1\":{\"1546\":1}}],[\"用来连接两个有依赖关系的任务\",{\"1\":{\"1518\":1}}],[\"用来决定槽数组的大小\",{\"1\":{\"1480\":1}}],[\"用来通知线程有一些事件已发生\",{\"1\":{\"1477\":1}}],[\"用来维护read\",{\"1\":{\"542\":1}}],[\"用来指定误删表所在的库\",{\"1\":{\"485\":1}}],[\"用来表示最后一次执行检测的时间\",{\"1\":{\"478\":1}}],[\"用来对应\",{\"1\":{\"468\":1}}],[\"用来对应redo\",{\"1\":{\"451\":1}}],[\"用来控制是否启动这个新策略\",{\"1\":{\"465\":1}}],[\"用来保证变更表结构操作的安全性\",{\"1\":{\"441\":1}}],[\"用来实现列数据的关联更新\",{\"1\":{\"417\":1}}],[\"用来存放数据文件\",{\"1\":{\"412\":1}}],[\"用来跟服务端建立连接\",{\"1\":{\"318\":1}}],[\"用户应用程序调用read方法\",{\"1\":{\"1580\":1}}],[\"用户进程发起read操作之后\",{\"1\":{\"1566\":1}}],[\"用户进程判断结果是一个error时\",{\"1\":{\"1564\":1}}],[\"用户进程才解除block的状态\",{\"1\":{\"1563\":1}}],[\"用户态\",{\"1\":{\"1483\":1}}],[\"用户可以指定最大的停顿时间\",{\"1\":{\"1449\":1}}],[\"用户可以通过执行不同的操作增加或者减少计数器的值\",{\"1\":{\"1293\":1}}],[\"用户创建一个对象\",{\"1\":{\"1436\":1}}],[\"用户空间的虚拟内存也会随之释放\",{\"1\":{\"1579\":1}}],[\"用户空间不能直接访问底层的硬件设备\",{\"1\":{\"1423\":1}}],[\"用户空间和内核空间\",{\"1\":{\"1423\":1}}],[\"用户线程是程序创建的线程\",{\"1\":{\"1375\":1}}],[\"用户的钱就被盗了\",{\"1\":{\"1201\":1}}],[\"用户信息仓库\",{\"1\":{\"918\":1}}],[\"用户类\",{\"1\":{\"917\":1}}],[\"用户基础\",{\"1\":{\"900\":1}}],[\"用户请求数据时\",{\"1\":{\"626\":1}}],[\"用户校验\",{\"1\":{\"482\":1}}],[\"用户名密码登录\",{\"1\":{\"1199\":1}}],[\"用户名和密码\",{\"1\":{\"467\":1}}],[\"用户名\",{\"1\":{\"453\":1}}],[\"用户名等\",{\"1\":{\"349\":1}}],[\"用户每次访问首页的时候\",{\"1\":{\"419\":1}}],[\"用户表是这么定义的\",{\"1\":{\"349\":1}}],[\"用户查询时\",{\"1\":{\"299\":1}}],[\"用二分法就可以快速得到\",{\"1\":{\"333\":1}}],[\"用于传递消息\",{\"1\":{\"1985\":1}}],[\"用于关闭整个容器\",{\"1\":{\"1685\":1}}],[\"用于缓存aop对象\",{\"1\":{\"1649\":1}}],[\"用于创建sink的一个链\",{\"1\":{\"1623\":1}}],[\"用于创建执行任务的线程\",{\"1\":{\"1520\":1}}],[\"用于在整个流管道阶段处理值\",{\"1\":{\"1623\":1}}],[\"用于描述中间的管道阶段和管道源阶段的的类\",{\"1\":{\"1621\":1}}],[\"用于呈现流的数据视图\",{\"1\":{\"1621\":1}}],[\"用于完成字符串的拼接操作\",{\"1\":{\"1618\":1}}],[\"用于判断是否有序\",{\"1\":{\"1617\":1}}],[\"用于判断中间结果容器与最终返回的类型是否相同\",{\"1\":{\"1617\":1}}],[\"用于判断某个元素是否存在于集合中\",{\"1\":{\"1283\":1}}],[\"用于将一个额外的元素合并到结果容器当中\",{\"1\":{\"1608\":1}}],[\"用于表述指向文件的引用的抽象化概念\",{\"1\":{\"1561\":1}}],[\"用于表示当前备库延迟了多少秒\",{\"1\":{\"457\":1}}],[\"用于表示事务被正确地提交了\",{\"1\":{\"454\":1}}],[\"用于保存future对象\",{\"1\":{\"1517\":1}}],[\"用于保存已经执行完成的future\",{\"1\":{\"1517\":1}}],[\"用于保存当前正在这个worker的\",{\"1\":{\"461\":1}}],[\"用于区别使用非forkjoinworkthread线程提交task\",{\"1\":{\"1513\":1}}],[\"用于区分不同表的操作\",{\"1\":{\"454\":1}}],[\"用于控制线程池的并行数\",{\"1\":{\"1510\":1}}],[\"用于屏蔽掉各种硬件和操作系统内存访问差异\",{\"1\":{\"1473\":1}}],[\"用于存储对象自身的运行时数据\",{\"1\":{\"1484\":1}}],[\"用于存储类的元数据信息\",{\"1\":{\"1457\":1}}],[\"用于存储spring配置属性源\",{\"1\":{\"1145\":1}}],[\"用于统计独立用户数量等\",{\"1\":{\"1280\":1}}],[\"用于具体的处理\",{\"1\":{\"1226\":1}}],[\"用于接收连接\",{\"1\":{\"1226\":1}}],[\"用于注册异步执行结果的监听器\",{\"1\":{\"1224\":1}}],[\"用于处理连接的生命周期中所发生的事件\",{\"1\":{\"1224\":1}}],[\"用于profiles状态维护\",{\"1\":{\"1145\":1}}],[\"用于转换spring配置属性类型\",{\"1\":{\"1145\":1}}],[\"用于属性占位符处理\",{\"1\":{\"1145\":1}}],[\"用于\",{\"1\":{\"1089\":1}}],[\"用于扩展beanfacotry\",{\"1\":{\"1016\":1}}],[\"用于spring事件\",{\"1\":{\"957\":1}}],[\"用于spring国际化\",{\"1\":{\"957\":1}}],[\"用于构造器参数\",{\"1\":{\"952\":1}}],[\"用于依赖注入\",{\"1\":{\"927\":2}}],[\"用于高速缓冲\",{\"1\":{\"565\":1}}],[\"用于配合undo日志\",{\"1\":{\"542\":1}}],[\"用于记录主库上写入的时间\",{\"1\":{\"457\":1}}],[\"用于短语搜索\",{\"1\":{\"308\":1}}],[\"用于相关性评分\",{\"1\":{\"308\":1}}],[\"用于对term本身进行索引\",{\"1\":{\"308\":1}}],[\"为特定的web应用处理所有的客户请求\",{\"1\":{\"1683\":1}}],[\"为beandefinition设置属性的初始值\",{\"1\":{\"1647\":1}}],[\"为用户所设计的大多数的静态的流的方法大多都在stream类中提的方法\",{\"1\":{\"1621\":1}}],[\"为我们方便的传递各种不同需求的行为提供了可能\",{\"1\":{\"1594\":1}}],[\"为空\",{\"1\":{\"1554\":1}}],[\"为第二步\",{\"1\":{\"1548\":1}}],[\"为第一步\",{\"1\":{\"1548\":1}}],[\"为每个class维护一个偏向锁撤销计数器\",{\"1\":{\"1485\":1}}],[\"为每个修改保存一个版本\",{\"1\":{\"541\":1}}],[\"为控制一个具有有限数量用户资源而设计\",{\"1\":{\"1477\":1}}],[\"为协调共同对一个共享资源的单独访问而设计的\",{\"1\":{\"1477\":1}}],[\"为对象字段设置零值\",{\"1\":{\"1429\":1}}],[\"为对象分配内存空间\",{\"1\":{\"1429\":1}}],[\"为分配的内存空间初始化零值\",{\"1\":{\"1429\":1}}],[\"为防止数据损坏\",{\"1\":{\"1262\":1}}],[\"为spring\",{\"1\":{\"1021\":1}}],[\"为scan\",{\"1\":{\"519\":1}}],[\"为\",{\"1\":{\"953\":1,\"954\":1,\"1479\":1}}],[\"为上层的数据层提供最基础的支撑\",{\"1\":{\"645\":1}}],[\"为指定key的offset位设置值\",{\"1\":{\"578\":1}}],[\"为哈希表\",{\"1\":{\"573\":2}}],[\"为数值加上浮点型数值\",{\"1\":{\"570\":1}}],[\"为生成统计数据而采样的页面数量\",{\"1\":{\"558\":1}}],[\"为null时代表降序存放\",{\"1\":{\"553\":1}}],[\"为m+2否则为d+2\",{\"1\":{\"528\":1}}],[\"为依据的\",{\"1\":{\"411\":1}}],[\"为例\",{\"1\":{\"340\":1,\"1594\":1}}],[\"为了使服务器不受web项目的影响\",{\"1\":{\"1693\":1}}],[\"为了使处理器内部的运算单元能尽量被充分利用\",{\"1\":{\"1405\":1}}],[\"为了节省重复创建bean的开销\",{\"1\":{\"1659\":1}}],[\"为了节省磁盘空间\",{\"1\":{\"542\":1}}],[\"为了与spring划分边界\",{\"1\":{\"1659\":1}}],[\"为了保留stream\",{\"1\":{\"1620\":1}}],[\"为了保证是在源阶段\",{\"1\":{\"1622\":1}}],[\"为了保证最终结果的正确性\",{\"1\":{\"1619\":1}}],[\"为了保证线程安全\",{\"1\":{\"1498\":1}}],[\"为了保证微服务的稳定\",{\"1\":{\"1308\":1}}],[\"为了保证效率\",{\"1\":{\"564\":1}}],[\"为了保证比较高的隔离性\",{\"1\":{\"540\":1}}],[\"为了保证交易的原子性\",{\"1\":{\"443\":1}}],[\"为了保证数据库隔离级别的一致\",{\"1\":{\"433\":1}}],[\"为了进行计算\",{\"1\":{\"1619\":1}}],[\"为了进一步提升索引的效率\",{\"1\":{\"308\":1}}],[\"为了方便子容器的切换\",{\"1\":{\"1659\":1}}],[\"为了方便观察并行流和串行流的区别\",{\"1\":{\"1617\":1}}],[\"为了方便理解这条语句的索引选择过程\",{\"1\":{\"347\":1}}],[\"为了验证关于characteristics方法的调用逻辑\",{\"1\":{\"1617\":1}}],[\"为了确保串行与并行生成等价的结果\",{\"1\":{\"1615\":1}}],[\"为了升级jdk还需要入侵式的修改客户端的代码\",{\"1\":{\"1607\":1}}],[\"为了向函数式编程迈进\",{\"1\":{\"1593\":1}}],[\"为了改进这种模型我们可以通过消息队列和线程池技术对它加以优化\",{\"1\":{\"1573\":1}}],[\"为了防止生产者速度过快\",{\"1\":{\"1519\":1}}],[\"为了防止无穷无尽的分析各种连接顺序的成本\",{\"1\":{\"556\":1}}],[\"为了解决传统线程池的缺陷\",{\"1\":{\"1510\":1}}],[\"为了解决这个缺点\",{\"1\":{\"1533\":1}}],[\"为了解决这个问题\",{\"1\":{\"324\":1}}],[\"为了解决这些问题\",{\"1\":{\"433\":1,\"1457\":1}}],[\"为了减少初始化时间\",{\"1\":{\"1485\":1}}],[\"为了实现函数式编程\",{\"1\":{\"1593\":1}}],[\"为了实现泛型\",{\"1\":{\"1098\":1}}],[\"为了实现这个功能\",{\"1\":{\"482\":1}}],[\"为了跟前面加以区别\",{\"1\":{\"1006\":1}}],[\"为了不影响mvcc的正常工作\",{\"1\":{\"542\":1}}],[\"为了查看sql多次执行的真实时间\",{\"1\":{\"526\":1}}],[\"为了加速数据恢复\",{\"1\":{\"485\":1}}],[\"为了找到解决误删数据的更高效的方法\",{\"1\":{\"483\":1}}],[\"为了能够检测innodb并发线程数过多导致的系统不可用的情况\",{\"1\":{\"477\":1}}],[\"为了能够用上索引的快速定位能力\",{\"1\":{\"366\":1}}],[\"为了便于说明\",{\"1\":{\"489\":1}}],[\"为了便于描述\",{\"1\":{\"454\":1}}],[\"为了便于量化分析\",{\"1\":{\"400\":1,\"414\":1}}],[\"为了便于量化分析和复现\",{\"1\":{\"368\":1}}],[\"为了控制redo\",{\"1\":{\"451\":1}}],[\"为了更好的说明行锁\",{\"1\":{\"443\":1}}],[\"为了得到严格随机的结果\",{\"1\":{\"422\":1}}],[\"为了最快地拿到当前堆的最大值\",{\"1\":{\"421\":1}}],[\"为了复现这个过程\",{\"1\":{\"421\":1}}],[\"为了后面描述方便\",{\"1\":{\"420\":1}}],[\"为了让主备之间的更新不产生冲突\",{\"1\":{\"478\":1}}],[\"为了让一次fsync带的组员更多\",{\"1\":{\"451\":1}}],[\"为了让一个查询尽量少地读磁盘\",{\"1\":{\"334\":1}}],[\"为了让join使用bka算法\",{\"1\":{\"407\":1}}],[\"为了避免装箱拆箱操作带来的性能消耗\",{\"1\":{\"1620\":1}}],[\"为了避免用户进程直接操作内核\",{\"1\":{\"1579\":1}}],[\"为了避免垃圾回收\",{\"1\":{\"1519\":1}}],[\"为了避免线程进入等待队列永久阻塞\",{\"1\":{\"1483\":1}}],[\"为了避免临界区的竞态条件发生\",{\"1\":{\"1482\":1}}],[\"为了避免两个事务申请到相同的自增id\",{\"1\":{\"491\":1}}],[\"为了避免数据在转换过程中由于截断导致数据错误\",{\"1\":{\"368\":1}}],[\"为了避免全表扫描\",{\"1\":{\"354\":1}}],[\"为了说明statement和row格式的区别\",{\"1\":{\"454\":1}}],[\"为了说明这个问题\",{\"1\":{\"447\":1,\"476\":1}}],[\"为了说明这一点\",{\"1\":{\"404\":1,\"413\":1,\"1610\":1}}],[\"为了说明幻读\",{\"1\":{\"446\":1}}],[\"为了说明分区表的组织形式\",{\"1\":{\"424\":1}}],[\"为了说明优化器选择的结果是否正确\",{\"1\":{\"346\":1}}],[\"为了说明普通索引和唯一索引对更新语句性能的影响\",{\"1\":{\"343\":1}}],[\"为了直观地说明这个概念\",{\"1\":{\"339\":1}}],[\"为了了解它的实现原理\",{\"1\":{\"323\":1}}],[\"为什么会只打印hello呢\",{\"1\":{\"1612\":1}}],[\"为什么会这样呢\",{\"1\":{\"454\":1}}],[\"为什么可以这样创建呢\",{\"1\":{\"1607\":1}}],[\"为什么是函数式接口\",{\"0\":{\"1595\":1}}],[\"为什么队列是满的才唤醒阻塞在notfull上的线程呢\",{\"1\":{\"1503\":1}}],[\"为什么采用\",{\"1\":{\"1265\":1}}],[\"为什么说objectfactory提供的是延迟依赖查找\",{\"0\":{\"1181\":1}}],[\"为什么说elaticsearch是一个近实时的搜索引擎\",{\"1\":{\"312\":1}}],[\"为什么spring不使用java标准资源管理\",{\"1\":{\"1036\":1}}],[\"为什么springboot的\",{\"0\":{\"187\":1,\"1246\":1}}],[\"为什么使用集群\",{\"0\":{\"608\":1}}],[\"为什么mysql不直接更新磁盘上的数据而是设计了这么复杂的一套机制来执行sql\",{\"1\":{\"543\":1}}],[\"为什么非主键索引结构的叶子结点存储的是主键值\",{\"1\":{\"505\":1}}],[\"为什么建议innodb表必须建主键\",{\"1\":{\"505\":1}}],[\"为什么这个参数要取名叫做\",{\"1\":{\"482\":1}}],[\"为什么这次能用上被驱动表的tradeied索引呢\",{\"1\":{\"368\":1}}],[\"为什么在执行kill\",{\"1\":{\"481\":1}}],[\"为什么执行group\",{\"1\":{\"417\":1}}],[\"为什么\",{\"1\":{\"361\":1}}],[\"为什么还要用redis\",{\"0\":{\"203\":1,\"1219\":1}}],[\"为什么要设计双亲委托机制\",{\"1\":{\"1663\":1,\"1692\":1}}],[\"为什么要用pipeline\",{\"0\":{\"146\":1,\"1298\":1}}],[\"为什么要将永久代改为元空间\",{\"0\":{\"126\":1,\"1457\":1}}],[\"为什么wait和notify方法要在同步块中调用\",{\"0\":{\"53\":1,\"1382\":1}}],[\"为什么阈值是8\",{\"0\":{\"34\":1,\"1362\":1}}],[\"为什么不直接使用红黑树\",{\"0\":{\"32\":1,\"1360\":1}}],[\"为什么hashmap不用linkedlist\",{\"0\":{\"30\":1,\"1358\":1}}],[\"yieldingwaitstrategy\",{\"1\":{\"1521\":1}}],[\"yieldingwaitstrategy策略\",{\"1\":{\"1520\":1}}],[\"yield\",{\"1\":{\"1520\":2,\"1554\":1}}],[\"yichang\",{\"1\":{\"576\":1}}],[\"y的propertyvalue\",{\"1\":{\"1072\":1}}],[\"yml\",{\"1\":{\"1048\":1}}],[\"yaml或\",{\"1\":{\"1048\":1}}],[\"yaml资源\",{\"1\":{\"1047\":1,\"1048\":1}}],[\"yaml等\",{\"1\":{\"1035\":1}}],[\"yaml\",{\"1\":{\"1032\":3}}],[\"yamlmap\",{\"1\":{\"1032\":1}}],[\"yamlmapfactorybean\",{\"1\":{\"1032\":2}}],[\"yamlpropertysource\",{\"1\":{\"1032\":1}}],[\"yamlpropertysourcefactory\",{\"1\":{\"1032\":2}}],[\"yamlproperties\",{\"1\":{\"1032\":2}}],[\"yamlpropertiesfactorybean\",{\"1\":{\"1032\":6}}],[\"yamlprocessor\",{\"1\":{\"1032\":1}}],[\"yyyymmddhhmmss\",{\"1\":{\"529\":1}}],[\"yyyy\",{\"1\":{\"529\":3,\"1053\":1,\"1528\":1}}],[\"yet\",{\"1\":{\"1620\":2,\"1647\":1}}],[\"year\",{\"1\":{\"424\":1,\"529\":1}}],[\"yes\",{\"1\":{\"330\":8,\"479\":2,\"592\":1,\"1081\":7}}],[\"y1\",{\"1\":{\"422\":3}}],[\"y3\",{\"1\":{\"422\":4}}],[\"y2\",{\"1\":{\"422\":4}}],[\"y\",{\"1\":{\"332\":1,\"352\":1,\"354\":1,\"355\":1,\"377\":5,\"417\":1,\"422\":5}}],[\"young\",{\"0\":{\"1751\":1},\"1\":{\"1434\":1}}],[\"young区域的数据页没有被合理地淘汰\",{\"1\":{\"406\":1}}],[\"your\",{\"1\":{\"320\":1}}],[\"you\",{\"1\":{\"320\":1,\"611\":2,\"1254\":1,\"1615\":1,\"1623\":4}}],[\"youdao\",{\"1\":{\"308\":1,\"312\":1,\"517\":2,\"531\":1,\"540\":1,\"635\":1,\"639\":1,\"1663\":1}}],[\"ynoteshare\",{\"1\":{\"308\":1,\"312\":1,\"517\":1,\"635\":1,\"639\":1}}],[\"参见\",{\"1\":{\"1249\":1,\"1277\":1}}],[\"参看文档最后\",{\"1\":{\"528\":1}}],[\"参与排序的行\",{\"1\":{\"520\":1}}],[\"参与排序的是随机值r字段和rowid段组成的行\",{\"1\":{\"421\":1}}],[\"参考\",{\"1\":{\"517\":1,\"531\":1,\"540\":1,\"561\":1,\"1561\":1}}],[\"参考链接\",{\"1\":{\"308\":1,\"545\":1,\"639\":1,\"1663\":1}}],[\"参数设置\",{\"0\":{\"1755\":1}}],[\"参数设置非常不方便\",{\"1\":{\"645\":1}}],[\"参数解析转换核心api\",{\"1\":{\"1657\":1}}],[\"参数都是非空的\",{\"1\":{\"1619\":1}}],[\"参数before指的是在应用这个函数之前所要应用的当前的函数的函数\",{\"1\":{\"1598\":1}}],[\"参数binlog\",{\"1\":{\"450\":1}}],[\"参数可以接收行为的方法们就称这个方法为高阶函数\",{\"1\":{\"1593\":1}}],[\"参数类型\",{\"1\":{\"1339\":1}}],[\"参数类似于\",{\"1\":{\"307\":1}}],[\"参数t\",{\"1\":{\"1086\":1}}],[\"参数tmp\",{\"1\":{\"416\":1}}],[\"参数名称\",{\"1\":{\"1072\":1}}],[\"参数索引\",{\"1\":{\"963\":1}}],[\"参数注入\",{\"1\":{\"906\":1}}],[\"参数file和pos指的是主库上的文件名和位置\",{\"1\":{\"473\":1}}],[\"参数处于关闭状态\",{\"1\":{\"431\":1}}],[\"参数\",{\"1\":{\"399\":1,\"482\":1,\"624\":1,\"1570\":1}}],[\"则回滚\",{\"1\":{\"1655\":2}}],[\"则提交事务\",{\"1\":{\"1655\":1}}],[\"则一级缓存生效\",{\"1\":{\"1653\":1}}],[\"则一直使用同一个连接\",{\"1\":{\"318\":1}}],[\"则表示要获取的对象是factory\",{\"1\":{\"1647\":1}}],[\"则表示返回满足条件的数据行里面\",{\"1\":{\"399\":1}}],[\"则判断对应的pointcut是否和当前bean对象的类是否匹配\",{\"1\":{\"1630\":1}}],[\"则修改链表为红黑树\",{\"1\":{\"1554\":1}}],[\"则进行链表操作或者红黑树操作\",{\"1\":{\"1554\":1}}],[\"则进行阻塞\",{\"1\":{\"1501\":1}}],[\"则基于cas策略抢占标记sizectl为\",{\"1\":{\"1554\":1}}],[\"则调用inittable方法初始化\",{\"1\":{\"1554\":1}}],[\"则使用cas无锁的方法将数据添加到容器中\",{\"1\":{\"1554\":1}}],[\"则使用\",{\"1\":{\"1554\":1}}],[\"则使用thread\",{\"1\":{\"1520\":1}}],[\"则初始化\",{\"1\":{\"1554\":1}}],[\"则初始elementdata容量为指定大小\",{\"1\":{\"1542\":1}}],[\"则初始elementdata容量为0\",{\"1\":{\"1542\":1}}],[\"则链表元素会倒置\",{\"1\":{\"1550\":1}}],[\"则直接抛出异常\",{\"1\":{\"1648\":1}}],[\"则直接无所插入\",{\"1\":{\"1554\":1}}],[\"则直接在树中插入键值对\",{\"1\":{\"1549\":1}}],[\"则直接扩容elementdata为1\",{\"1\":{\"1542\":1}}],[\"则扩容elementdata为1\",{\"1\":{\"1542\":1}}],[\"则扩容elementdata为10\",{\"1\":{\"1542\":1}}],[\"则中断处理\",{\"1\":{\"1531\":1}}],[\"则自动退出run\",{\"1\":{\"1524\":1}}],[\"则break\",{\"1\":{\"1517\":1}}],[\"则唤醒阻塞在notfull的线程\",{\"1\":{\"1503\":1}}],[\"则队列抛出oom错误\",{\"1\":{\"1503\":1}}],[\"则消费者挂起\",{\"1\":{\"1502\":1}}],[\"则阻塞在notempty条件上\",{\"1\":{\"1503\":1}}],[\"则阻塞\",{\"1\":{\"1501\":3}}],[\"则其对其他获取到读锁的线程是不可见的\",{\"1\":{\"1498\":1}}],[\"则其子类将自动具有该注解\",{\"1\":{\"1133\":1}}],[\"则线程t将会被阻塞\",{\"1\":{\"1498\":1}}],[\"则将生产者挂起\",{\"1\":{\"1502\":1}}],[\"则将cxq中的元素按原有顺序插入到entrylist\",{\"1\":{\"1483\":1}}],[\"则将其替换为\",{\"1\":{\"1098\":1}}],[\"则也调用父类的longaccumelate\",{\"1\":{\"1480\":1}}],[\"则双向交换\",{\"1\":{\"1479\":1}}],[\"则按required属性执行\",{\"1\":{\"1238\":1}}],[\"则在自己的类加载路径中查找并载入目标类\",{\"1\":{\"1692\":1}}],[\"则在嵌套事务内执行\",{\"1\":{\"1238\":1}}],[\"则在这个从库执行查询语句\",{\"1\":{\"473\":1,\"474\":1}}],[\"则无法定位到xml文件内唯一的sql语句\",{\"1\":{\"1208\":1}}],[\"则抛出异常信息如\",{\"1\":{\"1184\":1}}],[\"则同返回值为1时的行为相同\",{\"1\":{\"624\":1}}],[\"则保存\",{\"1\":{\"587\":3}}],[\"则创建新的链表\",{\"1\":{\"571\":1}}],[\"则有n\",{\"1\":{\"556\":1}}],[\"则不返回数据\",{\"1\":{\"542\":1}}],[\"则不得不利用磁盘临时文件辅助排序\",{\"1\":{\"354\":1}}],[\"则返回原始对象\",{\"1\":{\"1649\":1}}],[\"则返回代理对象\",{\"1\":{\"1649\":1}}],[\"则返回一个true\",{\"1\":{\"1599\":1}}],[\"则返回\",{\"1\":{\"1517\":1,\"1618\":1,\"1648\":1}}],[\"则返回false\",{\"1\":{\"1501\":1}}],[\"则返回null\",{\"1\":{\"1501\":1}}],[\"则返回nil\",{\"1\":{\"570\":1}}],[\"则返回nll\",{\"1\":{\"473\":1}}],[\"则返回0\",{\"1\":{\"473\":1}}],[\"则它们之间不能设定为主备关系\",{\"1\":{\"455\":1}}],[\"则必须等事务a的操作完成后才能进行更新\",{\"1\":{\"442\":1}}],[\"则数据库就会一致保持readonly状态\",{\"1\":{\"438\":1}}],[\"则事务b执行\",{\"1\":{\"433\":1}}],[\"则v1是1\",{\"1\":{\"433\":1}}],[\"则v1\",{\"1\":{\"433\":2}}],[\"则会判断新扫描的beandefinition与原来的beandefinition是否兼容\",{\"1\":{\"1647\":1}}],[\"则会严重影响hashmap的性能\",{\"1\":{\"1546\":1}}],[\"则会导致队列填满\",{\"1\":{\"1502\":1}}],[\"则会给\",{\"1\":{\"1479\":1}}],[\"则会有4\",{\"1\":{\"556\":1}}],[\"则会使用rowid来构建b+树\",{\"1\":{\"505\":1}}],[\"则会归0再重新递增\",{\"1\":{\"499\":1}}],[\"则会被记录到慢查询日志中\",{\"1\":{\"428\":1}}],[\"则会创建新文档\",{\"1\":{\"307\":1}}],[\"则可能需要重复地访问一部分数据\",{\"1\":{\"394\":1}}],[\"则可能需要一次锁住很多数据\",{\"1\":{\"393\":1}}],[\"则是在启动的过程中\",{\"1\":{\"1654\":1}}],[\"则是默认的\",{\"1\":{\"1554\":1}}],[\"则是同一个事务中的第一个快照读才会创建read\",{\"1\":{\"542\":1}}],[\"则是提交事务并自动启动下一个事务\",{\"1\":{\"435\":1}}],[\"则是将更新记录在change\",{\"1\":{\"343\":1}}],[\"则是8个字节\",{\"1\":{\"335\":1}}],[\"则是替换\",{\"1\":{\"307\":1}}],[\"则只会记录必要的信息\",{\"1\":{\"454\":1}}],[\"则只要4个字节\",{\"1\":{\"335\":1}}],[\"则只需要在r5的记录后面插入一个新记录\",{\"1\":{\"335\":1}}],[\"则只需要搜索id这颗b+树\",{\"1\":{\"335\":1}}],[\"则往往不容易保证有序插入\",{\"1\":{\"335\":1}}],[\"则需要先搜索k索引树\",{\"1\":{\"335\":1}}],[\"则该索引仅仅出现在key列表中\",{\"1\":{\"330\":1}}],[\"则该索引将被列出\",{\"1\":{\"330\":1}}],[\"则没有使用索引\",{\"1\":{\"330\":1}}],[\"则被标记为union\",{\"1\":{\"330\":1}}],[\"第八阶段\",{\"0\":{\"1992\":1}}],[\"第七阶段\",{\"0\":{\"1988\":1}}],[\"第六阶段\",{\"0\":{\"1984\":1}}],[\"第五阶段\",{\"0\":{\"1979\":1}}],[\"第四阶段\",{\"0\":{\"1976\":1}}],[\"第7\",{\"1\":{\"1969\":1}}],[\"第1次添加\",{\"1\":{\"1542\":1}}],[\"第十七章spring事件\",{\"1\":{\"1168\":1}}],[\"第十二章spring国际化\",{\"1\":{\"1167\":1}}],[\"第三个map\",{\"1\":{\"1649\":1}}],[\"第三个是流的特性值\",{\"1\":{\"1622\":1}}],[\"第三个参数是下游收集器\",{\"1\":{\"1618\":1}}],[\"第三个条件是`table`的长度不能超过最大容量\",{\"1\":{\"1554\":1}}],[\"第三方框架的整合\",{\"1\":{\"891\":1}}],[\"第三阶段\",{\"0\":{\"1973\":1},\"1\":{\"519\":1}}],[\"第三次被分配到id=4到id=7\",{\"1\":{\"492\":1}}],[\"第三次申请自增id\",{\"1\":{\"492\":1}}],[\"第三点\",{\"1\":{\"482\":1}}],[\"第三组六列\",{\"1\":{\"479\":1}}],[\"第三种实现\",{\"1\":{\"1138\":1}}],[\"第三种情况是大事务\",{\"1\":{\"457\":1}}],[\"第三种方法是\",{\"1\":{\"348\":1,\"472\":1}}],[\"第三行是真实执行的语句\",{\"1\":{\"454\":1}}],[\"第三行的extra字段\",{\"1\":{\"414\":1}}],[\"第三步\",{\"1\":{\"368\":1,\"1119\":1,\"1548\":1}}],[\"第三句\",{\"1\":{\"346\":1}}],[\"第二次发生在cpu执行的时候\",{\"1\":{\"1405\":1}}],[\"第二次被分配了id=2和id=3\",{\"1\":{\"492\":1}}],[\"第二部分的接口的回调\",{\"1\":{\"1005\":1}}],[\"第二\",{\"1\":{\"621\":2,\"1103\":1,\"1328\":1}}],[\"第二条中提到\",{\"1\":{\"611\":1}}],[\"第二条语句才进入锁等待状态\",{\"1\":{\"424\":1}}],[\"第二阶段\",{\"0\":{\"1970\":1},\"1\":{\"519\":1}}],[\"第二点\",{\"1\":{\"482\":1}}],[\"第二组六列\",{\"1\":{\"479\":1}}],[\"第二组事务才能开始执行\",{\"1\":{\"464\":1}}],[\"第二种实现\",{\"1\":{\"1138\":1}}],[\"第二种方式在之前我们已经讨论过了\",{\"1\":{\"1114\":1}}],[\"第二种方法是\",{\"1\":{\"472\":1}}],[\"第二种情况是\",{\"1\":{\"457\":1}}],[\"第二种思路的示意图如下\",{\"1\":{\"411\":1}}],[\"第二种思路是\",{\"1\":{\"411\":1}}],[\"第二个参数表示流的类型是引用类型的\",{\"1\":{\"1622\":1}}],[\"第二个参数是accumulator累加器的类型\",{\"1\":{\"1618\":1}}],[\"第二个参数是collector类型的\",{\"1\":{\"1618\":1}}],[\"第二个条件是`table`不为null\",{\"1\":{\"1554\":1}}],[\"第二个线程来独去数据\",{\"1\":{\"1286\":1}}],[\"第二个字段trx\",{\"1\":{\"497\":1}}],[\"第二个字段是varchar\",{\"1\":{\"420\":1}}],[\"第二个事务有可能比第一个事务先执行\",{\"1\":{\"460\":1}}],[\"第二个设置查询语句\",{\"1\":{\"307\":1}}],[\"第二步和第三步\",{\"1\":{\"1084\":1}}],[\"第二步\",{\"1\":{\"368\":1,\"1119\":1,\"1138\":2}}],[\"第二行是一个begin\",{\"1\":{\"454\":1}}],[\"第二行的extra字段显示的是using\",{\"1\":{\"414\":1}}],[\"第二行的key=primary\",{\"1\":{\"414\":1}}],[\"第二行key=null\",{\"1\":{\"368\":1}}],[\"第二行参数才是操作的数据\",{\"1\":{\"307\":1}}],[\"第二句\",{\"1\":{\"346\":1}}],[\"第一本docker书\",{\"1\":{\"1966\":1}}],[\"第一\",{\"1\":{\"1103\":1,\"1328\":1}}],[\"第一阶段\",{\"0\":{\"1969\":1},\"1\":{\"519\":1}}],[\"第一点\",{\"1\":{\"482\":1}}],[\"第一组五列\",{\"1\":{\"479\":1}}],[\"第一列event\",{\"1\":{\"479\":1}}],[\"第一种确保主备无延迟的方法是\",{\"1\":{\"472\":1}}],[\"第一种思路是在proxy层的进程代码中实现排序\",{\"1\":{\"411\":1}}],[\"第一种情况是\",{\"1\":{\"343\":1,\"457\":1}}],[\"第一次发生在将字节码编译成机器码的阶段\",{\"1\":{\"1405\":1}}],[\"第一次申请到了id=1\",{\"1\":{\"492\":1}}],[\"第一次申请自增id\",{\"1\":{\"492\":1}}],[\"第一次打开表的时候\",{\"1\":{\"490\":1}}],[\"第一次从磁盘读入内存的数据页\",{\"1\":{\"406\":1}}],[\"第一次调用的是\",{\"1\":{\"322\":1}}],[\"第一步中\",{\"1\":{\"474\":1}}],[\"第一步\",{\"1\":{\"368\":1,\"1084\":1,\"1119\":1,\"1138\":1}}],[\"第一行set\",{\"1\":{\"454\":1}}],[\"第一行显式优化器现在交易记录表tradelog上查到id=2的行\",{\"1\":{\"368\":1}}],[\"第一行参数为执行操作的类型及操作的对象\",{\"1\":{\"307\":1}}],[\"第一句是将查询日志的阈值设置为0\",{\"1\":{\"346\":1}}],[\"第一个参数是一个分类器\",{\"1\":{\"1618\":1}}],[\"第一个参数就是一个普通的变量\",{\"1\":{\"1593\":1}}],[\"第一个元素就已经满足了所有的操作\",{\"1\":{\"1612\":1}}],[\"第一个元素作为seed\",{\"1\":{\"1609\":1}}],[\"第一个条件是map\",{\"1\":{\"1554\":1}}],[\"第一个条件由于order\",{\"1\":{\"555\":1}}],[\"第一个线程已经将新的值写到缓存里面了\",{\"1\":{\"1286\":1}}],[\"第一个insert语句插入数据成功后\",{\"1\":{\"494\":1}}],[\"第一个误解是\",{\"1\":{\"482\":1}}],[\"第一个箭头明显粗于第二个箭头\",{\"1\":{\"460\":1}}],[\"第一个事务写完redo\",{\"1\":{\"451\":1}}],[\"第一个被锁住的线程要过50s才会超时退出\",{\"1\":{\"444\":1}}],[\"第一个扫描地c行\",{\"1\":{\"422\":1}}],[\"第一个字段是double类型\",{\"1\":{\"420\":1}}],[\"第一个字是\",{\"1\":{\"340\":1}}],[\"第一个语句创建的index1索引里面\",{\"1\":{\"350\":1}}],[\"第一个设置index和type\",{\"1\":{\"307\":1}}],[\"批量撤销\",{\"1\":{\"1489\":1}}],[\"批量重偏向和批量撤销是针对类的优化\",{\"1\":{\"1485\":1}}],[\"批量重偏向和批量撤销的总结\",{\"1\":{\"1485\":1}}],[\"批量获取多个key保存的值\",{\"1\":{\"570\":1}}],[\"批量设置键值对\",{\"1\":{\"570\":1}}],[\"批量set键值对\",{\"1\":{\"570\":1}}],[\"批量插入数据的语句\",{\"1\":{\"492\":1}}],[\"批量修改update\",{\"1\":{\"307\":1}}],[\"批量删除delete\",{\"1\":{\"307\":1}}],[\"批量对文档进行写操作是通过\",{\"1\":{\"307\":1}}],[\"批量操作可以减少网络连接所产生的开销\",{\"1\":{\"307\":1}}],[\"操作数栈\",{\"0\":{\"1801\":1},\"1\":{\"1664\":1}}],[\"操作都是类似的\",{\"1\":{\"1621\":1}}],[\"操作的时候不会将process阻塞\",{\"1\":{\"1567\":1}}],[\"操作的时候会将process阻塞\",{\"1\":{\"1567\":1}}],[\"操作上\",{\"1\":{\"1517\":1}}],[\"操作即可产生挥手操作\",{\"1\":{\"1425\":1}}],[\"操作方式\",{\"1\":{\"1423\":1}}],[\"操作list\",{\"1\":{\"583\":1}}],[\"操作字符串\",{\"1\":{\"583\":1}}],[\"操作不同的数据类型\",{\"1\":{\"583\":1}}],[\"操作不慎的话\",{\"1\":{\"441\":1}}],[\"操作过程中会增加互斥锁\",{\"1\":{\"949\":1}}],[\"操作过程\",{\"0\":{\"579\":1}}],[\"操作\",{\"1\":{\"412\":1,\"1479\":1,\"1498\":2,\"1554\":2,\"1583\":1}}],[\"操作文档\",{\"1\":{\"307\":1}}],[\"操作中单条操作失败\",{\"1\":{\"307\":1}}],[\"操作系统\",{\"1\":{\"1966\":1}}],[\"操作系统通过dma控制器从磁盘中读取数据\",{\"1\":{\"1580\":1}}],[\"操作系统会给应用程序分配一个单独的用户空间\",{\"1\":{\"1579\":1}}],[\"操作系统将虚拟内存划分为两个部分\",{\"1\":{\"1579\":1}}],[\"操作系统的核心是内核\",{\"1\":{\"1579\":1}}],[\"操作系统的发展史\",{\"0\":{\"277\":1}}],[\"操作系统层面的线程生命周期可以用\",{\"1\":{\"1477\":1}}],[\"操作系统为了保护系统安全\",{\"1\":{\"1423\":1}}],[\"操作系统环境变量\",{\"1\":{\"945\":1}}],[\"操作系统分类\",{\"0\":{\"276\":1}}],[\"对我面试帮助很大\",{\"1\":{\"1975\":1}}],[\"对类的静态变量初始化为指定的值\",{\"1\":{\"1663\":1}}],[\"对这两项技术做了一定程度的封装\",{\"1\":{\"1654\":1}}],[\"对这些语句使用不当的话\",{\"1\":{\"365\":1}}],[\"对扫描到的类进行解析\",{\"1\":{\"1635\":1}}],[\"对串行流进行优化\",{\"1\":{\"1622\":1}}],[\"对剩下的元素都执行action方法\",{\"1\":{\"1620\":1}}],[\"对原生的子类型进行装箱操作\",{\"1\":{\"1620\":1}}],[\"对照basestream的定义不难发现\",{\"1\":{\"1619\":1}}],[\"对数组中唯一的元素进行累加的操作\",{\"1\":{\"1618\":1}}],[\"对数据结构做了进一步的优化\",{\"1\":{\"1546\":1}}],[\"对数据的完整性要求不高\",{\"1\":{\"590\":1}}],[\"对流当中的元素进行可变的汇聚操作\",{\"1\":{\"1608\":1}}],[\"对流的操作会生成一个结果\",{\"1\":{\"1608\":1}}],[\"对流中的每一个元素执行打印的操作\",{\"1\":{\"1607\":1}}],[\"对sendfile的支持\",{\"0\":{\"1588\":1}}],[\"对sort\",{\"1\":{\"354\":1,\"355\":1,\"418\":1,\"520\":2}}],[\"对资源的拷贝性能提升不少\",{\"1\":{\"1582\":1}}],[\"对资源的拷贝速度性能提升不少\",{\"1\":{\"1581\":1}}],[\"对所有连接请求进行处理\",{\"1\":{\"1574\":1}}],[\"对所有可能查询的参数以hash的形式存储\",{\"1\":{\"627\":1}}],[\"对key进行处理\",{\"1\":{\"1574\":1}}],[\"对key的hashcode\",{\"1\":{\"1549\":1}}],[\"对高并发和低时延支持不好\",{\"1\":{\"1572\":1}}],[\"对\",{\"1\":{\"1554\":2,\"1583\":1}}],[\"对foo这个引用的修改在多线程中并不能保证可见性和原子性\",{\"1\":{\"1526\":1}}],[\"对齐填充\",{\"1\":{\"1484\":1}}],[\"对其填充\",{\"1\":{\"1484\":1}}],[\"对其它线程不可见\",{\"1\":{\"410\":1}}],[\"对性能有较大影响\",{\"1\":{\"1483\":1}}],[\"对单个内存位置的读\",{\"1\":{\"1474\":1}}],[\"对单个事务做如下处理\",{\"1\":{\"484\":1}}],[\"对任何缓存中的数据的更改都必须传播到对等缓冲中的其他副本\",{\"1\":{\"1474\":1}}],[\"对对象进行其它设置\",{\"1\":{\"1429\":1}}],[\"对引用数据类型\",{\"1\":{\"1344\":1}}],[\"对引用数据类型进行引用传递般的拷贝\",{\"1\":{\"1344\":1}}],[\"对基本数据类型进行值传递\",{\"1\":{\"1344\":1}}],[\"对参数进行合法性校验\",{\"1\":{\"1282\":1}}],[\"对系统内的隐私数据进行保护\",{\"1\":{\"1199\":1}}],[\"对系统影响小\",{\"1\":{\"426\":1}}],[\"对集合中的每个元素执行consumer中的accept\",{\"1\":{\"1595\":1}}],[\"对集合\",{\"1\":{\"1089\":1}}],[\"对java8特性扩展\",{\"1\":{\"943\":1}}],[\"对象的引用\",{\"0\":{\"1717\":1}}],[\"对象的回收\",{\"0\":{\"1716\":1}}],[\"对象的访问定位\",{\"0\":{\"1712\":1}}],[\"对象的内存布局\",{\"0\":{\"1711\":1}}],[\"对象的创建\",{\"0\":{\"1710\":1}}],[\"对象的所有属性都是final的\",{\"1\":{\"1526\":1}}],[\"对象序列化等\",{\"1\":{\"1666\":1}}],[\"对象克隆\",{\"1\":{\"1666\":1}}],[\"对象创建的过程\",{\"1\":{\"1665\":1}}],[\"对象就需要扩大数组的长度\",{\"1\":{\"1550\":1}}],[\"对象可能是栈分配的候选\",{\"1\":{\"1488\":1}}],[\"对象锁\",{\"1\":{\"1484\":1}}],[\"对象所属的年代\",{\"1\":{\"1484\":1}}],[\"对象在内存中存储的布局可以分为三块区域\",{\"1\":{\"1484\":1}}],[\"对象在被依赖注入和依赖查询时并未实时查找关联类型bean\",{\"1\":{\"1181\":1}}],[\"对象头的另一部分是klass类型指针\",{\"1\":{\"1484\":1}}],[\"对象头\",{\"0\":{\"1484\":1},\"1\":{\"1483\":1,\"1484\":3}}],[\"对象属性原子修改器\",{\"1\":{\"1480\":1}}],[\"对象转入老年代\",{\"1\":{\"1436\":1}}],[\"对象如果存活\",{\"1\":{\"1436\":1}}],[\"对象首先会分配在堆内存中新生代的eden区\",{\"1\":{\"1436\":1}}],[\"对象被垃圾收集器回收时收到一个系统通知\",{\"1\":{\"1435\":1}}],[\"对象不允许属性赋值\",{\"1\":{\"1002\":1}}],[\"对象不为空\",{\"1\":{\"912\":1}}],[\"对象正在被垃圾回收\",{\"1\":{\"934\":1}}],[\"对象\",{\"1\":{\"918\":1,\"1064\":2,\"1156\":1}}],[\"对象继承\",{\"1\":{\"899\":1}}],[\"对象存储缓存\",{\"1\":{\"570\":1}}],[\"对应class实例的引用\",{\"1\":{\"1663\":1}}],[\"对应class实例的引用等信息\",{\"1\":{\"1663\":1}}],[\"对应上面例子中的hashmap\",{\"1\":{\"1618\":1}}],[\"对应info统计的rdb\",{\"1\":{\"588\":1}}],[\"对应的bean\",{\"1\":{\"1636\":1}}],[\"对应的binlog\",{\"1\":{\"484\":1}}],[\"对应的进程处于用户态\",{\"1\":{\"1579\":1}}],[\"对应的进程处于内核态\",{\"1\":{\"1579\":1}}],[\"对应的有以下缺点\",{\"1\":{\"1304\":1}}],[\"对应的分片将文档数据返回给协调节点\",{\"1\":{\"1256\":1}}],[\"对应的统计项的描述\",{\"1\":{\"558\":1}}],[\"对应的统计项的值\",{\"1\":{\"558\":1}}],[\"对应的就是collect方法的三个函数式接口\",{\"1\":{\"1608\":1}}],[\"对应的就是mysql\",{\"1\":{\"482\":2}}],[\"对应的就是一个没有显式索引的innodb表排序的过程\",{\"1\":{\"421\":1}}],[\"对应的也有等待gtid的方案\",{\"1\":{\"474\":1}}],[\"对应的lsn分别是50\",{\"1\":{\"451\":1}}],[\"对应的是hard\",{\"1\":{\"451\":1}}],[\"对应的风险是\",{\"1\":{\"450\":1}}],[\"对应的执行语句的序列\",{\"1\":{\"422\":2}}],[\"对应的流程图如下\",{\"1\":{\"401\":1,\"491\":1}}],[\"对应的sql语句是\",{\"1\":{\"356\":1}}],[\"对应的主键id也就是图中的id\",{\"1\":{\"354\":1}}],[\"对应的索引k上的记录项\",{\"1\":{\"338\":1}}],[\"对字符串进行增量\",{\"1\":{\"580\":1}}],[\"对一个近似平衡的二叉树的sub\",{\"1\":{\"1620\":1}}],[\"对一个或多个保存二进制位的字符串\",{\"1\":{\"578\":1}}],[\"对一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性\",{\"1\":{\"540\":1}}],[\"对设置到哈希表\",{\"1\":{\"573\":1}}],[\"对被驱动表的访问成本尽量低\",{\"1\":{\"555\":1}}],[\"对被驱动表的全表扫描次数就越少\",{\"1\":{\"403\":1}}],[\"对驱动表进行查询后得到的记录条数称之为驱动表的扇出\",{\"1\":{\"554\":1}}],[\"对驱动表t1做了全表扫描\",{\"1\":{\"401\":1}}],[\"对结果集进行排序等这些操作损耗的时间称之为cpu成本\",{\"1\":{\"545\":1}}],[\"对该记录创建一个read\",{\"1\":{\"542\":1}}],[\"对mmap的支持\",{\"0\":{\"1587\":1}}],[\"对mvcc有帮助的实质是update\",{\"1\":{\"542\":1}}],[\"对mysql的查询缓存来说\",{\"1\":{\"394\":1}}],[\"对整个表加拍他锁之前\",{\"1\":{\"533\":1}}],[\"对整个表加共享锁之前\",{\"1\":{\"533\":1}}],[\"对decimal\",{\"1\":{\"528\":1}}],[\"对调这两行的位置即可\",{\"1\":{\"484\":1}}],[\"对客户端比较友好\",{\"1\":{\"469\":1}}],[\"对比结果可以发现依赖查找和依赖注入的来源并不一样\",{\"1\":{\"918\":1}}],[\"对比\",{\"0\":{\"595\":1}}],[\"对比各种方案\",{\"0\":{\"551\":1}}],[\"对比各种执行方案的代价\",{\"1\":{\"546\":1}}],[\"对比之后找出成本最低的方案\",{\"1\":{\"546\":1}}],[\"对比位点和对比gtid这两种方法\",{\"1\":{\"472\":1}}],[\"对比位点确保主备无延迟\",{\"1\":{\"472\":1}}],[\"对比gtid集合确保主备无延迟\",{\"1\":{\"472\":1}}],[\"对比按表分发和按行分发这两个方案\",{\"1\":{\"462\":1}}],[\"对比双m结构和m\",{\"1\":{\"455\":1}}],[\"对比statement和row的优缺点\",{\"1\":{\"454\":1}}],[\"对id=1这一行的修改\",{\"1\":{\"447\":1}}],[\"对链表里的每个临时表\",{\"1\":{\"412\":1}}],[\"对proxy端的压力比较大\",{\"1\":{\"411\":1}}],[\"对中间层的开发能力要求比较高\",{\"1\":{\"411\":1}}],[\"对表t2做了全表扫描\",{\"1\":{\"407\":1}}],[\"对表t1和t2都做了一次全表扫描\",{\"1\":{\"403\":1}}],[\"对磁盘的读比较接近顺序读\",{\"1\":{\"404\":1}}],[\"对常见的做法就是使用缓存\",{\"1\":{\"397\":1}}],[\"对最终的结果集没有并没有贡献\",{\"1\":{\"390\":1}}],[\"对索引包含的所有字段先做判断\",{\"1\":{\"518\":1}}],[\"对索引的key进行一次hash计算就可以定位出数据存储的位置\",{\"1\":{\"504\":1}}],[\"对索引字段做函数操作\",{\"1\":{\"366\":1,\"367\":1,\"368\":1}}],[\"对索引中包含的字段先做判断\",{\"1\":{\"340\":1}}],[\"对于实习和校招的小伙伴来讲\",{\"1\":{\"1988\":1}}],[\"对于实习和校招的小伙伴来讲一定要好好学这部分的内容\",{\"1\":{\"1969\":1}}],[\"对于新手或者校招的小伙伴\",{\"1\":{\"1974\":1}}],[\"对于支持jsp的web服务器\",{\"1\":{\"1693\":1}}],[\"对于8g物理内存的机器来说\",{\"1\":{\"1664\":1}}],[\"对于原型bean\",{\"1\":{\"1648\":1}}],[\"对于简单的遍历\",{\"1\":{\"1622\":1}}],[\"对于任意给定的元素\",{\"1\":{\"1622\":1}}],[\"对于任意给定的对象\",{\"1\":{\"1548\":1}}],[\"对于串行流和中间操作都是无状态的并行流\",{\"1\":{\"1621\":1}}],[\"对于可变的元来说\",{\"1\":{\"1620\":1}}],[\"对于可以读到就数据的请求\",{\"1\":{\"470\":1}}],[\"对于元的操作也是很有用的\",{\"1\":{\"1620\":1}}],[\"对于并行计算\",{\"1\":{\"1623\":1}}],[\"对于并行流管道来说\",{\"1\":{\"1622\":1}}],[\"对于并行流管道\",{\"1\":{\"1618\":1}}],[\"对于并发的collectors\",{\"1\":{\"1615\":1}}],[\"对于toset方法\",{\"1\":{\"1618\":1}}],[\"对于tolist还有一个接受的更宽广的tocollection\",{\"1\":{\"1618\":1}}],[\"对于非并发的collectors\",{\"1\":{\"1615\":1}}],[\"对于具体的实现不应该对生成的supplier\",{\"1\":{\"1615\":1}}],[\"对于无序的要求就被放松了\",{\"1\":{\"1615\":1}}],[\"对于无序的字段\",{\"1\":{\"356\":1}}],[\"对于流的串行实现会创建一个单个的结果容器\",{\"1\":{\"1615\":1}}],[\"对于流中元素进行处理的时候\",{\"1\":{\"1612\":1}}],[\"对于joining方法\",{\"1\":{\"1618\":1}}],[\"对于jdk8中的重要的api全部都介绍完成\",{\"1\":{\"1613\":1}}],[\"对于java而言\",{\"1\":{\"1593\":1}}],[\"对于该sql所做的工作如果换成咱们的stream来实现那会是个什么样子呢\",{\"1\":{\"1611\":1}}],[\"对于该class的锁\",{\"1\":{\"1485\":1}}],[\"对于以上例子我们再做一个小的扩展\",{\"1\":{\"1607\":1}}],[\"对于其中的每一种\",{\"1\":{\"1602\":1}}],[\"对于function接口中的apply\",{\"1\":{\"1598\":1}}],[\"对于前面list集合遍历的例子\",{\"1\":{\"1597\":1}}],[\"对于前面使用lambda表达式来实现集合遍历的例子还可以这样做\",{\"1\":{\"1593\":1}}],[\"对于变量前面的类型\",{\"1\":{\"1593\":1}}],[\"对于初学者而言\",{\"1\":{\"1592\":1}}],[\"对于网络io来说\",{\"1\":{\"1563\":1}}],[\"对于哈希算法而言\",{\"1\":{\"1546\":1}}],[\"对于上面注释中提到的为什么可以强转\",{\"1\":{\"1620\":1}}],[\"对于上面的例子而言\",{\"1\":{\"1611\":1}}],[\"对于上面的例子\",{\"1\":{\"1482\":1}}],[\"对于上述四种类型的类\",{\"1\":{\"1544\":1}}],[\"对于某些任务只能单线程执行\",{\"1\":{\"1510\":1}}],[\"对于mesa管程来说\",{\"1\":{\"1483\":1}}],[\"对于myisam存储引擎的表不做不带where条件的count查询性能是很高的\",{\"1\":{\"526\":1}}],[\"对于mysql\",{\"1\":{\"387\":1}}],[\"对于硬件\",{\"1\":{\"1473\":1}}],[\"对于基本数据类型进行值传递\",{\"1\":{\"1344\":1}}],[\"对于字符串拼接操作会带来极大的性能消耗\",{\"1\":{\"1342\":1}}],[\"对于对象之前的普通引用\",{\"1\":{\"1237\":1}}],[\"对于prototype作用域\",{\"1\":{\"1236\":1}}],[\"对于线程安全问题\",{\"1\":{\"1236\":1}}],[\"对于所管理的prototype类型的类进行销毁\",{\"1\":{\"985\":1}}],[\"对于生命周期的注解的处理\",{\"1\":{\"966\":1}}],[\"对于optional类型的判断\",{\"1\":{\"963\":1}}],[\"对于脚本的运行结果有以下规则\",{\"1\":{\"624\":1}}],[\"对于内存比较大的示例会造成长时间则色\",{\"1\":{\"587\":1}}],[\"对于主键和唯一二级索引则没有这个问题\",{\"1\":{\"558\":1}}],[\"对于普通的二级索引\",{\"1\":{\"558\":1}}],[\"对于普通索引来说\",{\"1\":{\"342\":2,\"343\":1}}],[\"对于n个表的连接查询\",{\"1\":{\"556\":1}}],[\"对于n表连接的话\",{\"1\":{\"556\":1}}],[\"对于四表连接\",{\"1\":{\"556\":1}}],[\"对于三表连接\",{\"1\":{\"556\":1}}],[\"对于两表连接\",{\"1\":{\"556\":1}}],[\"对于左\",{\"1\":{\"555\":1}}],[\"对于被驱动表的查询次数也就越少\",{\"1\":{\"554\":1}}],[\"对于存储字符串或者字节串的列来说\",{\"1\":{\"553\":1}}],[\"对于本例来说就是要计算\",{\"1\":{\"549\":1}}],[\"对于使用innodb存储引擎的表来说\",{\"1\":{\"548\":2}}],[\"对于使用myisam存储引擎的表来说\",{\"1\":{\"548\":1}}],[\"对于删除的情况可以认为是update的特殊情况\",{\"1\":{\"542\":1}}],[\"对于性能至关重要\",{\"1\":{\"527\":1}}],[\"对于关联sql的优化策略\",{\"1\":{\"525\":1}}],[\"对于自增且连续的主键排序的分页查询\",{\"1\":{\"522\":1}}],[\"对于单例bean\",{\"1\":{\"1648\":1}}],[\"对于单路排序和双路排序两种模式\",{\"1\":{\"520\":1}}],[\"对于单值索引\",{\"1\":{\"380\":1}}],[\"对于辅助的联合索引\",{\"1\":{\"518\":1}}],[\"对于正在执行的事务\",{\"1\":{\"497\":1}}],[\"对于批量插入数据的语句\",{\"1\":{\"492\":1}}],[\"对于一次io访问\",{\"1\":{\"1561\":1}}],[\"对于一些并发度没那么高的异步场景\",{\"1\":{\"1533\":1}}],[\"对于一些热点数据\",{\"1\":{\"1283\":1}}],[\"对于一些从oracle迁移到mysql的应用\",{\"1\":{\"433\":1}}],[\"对于一个部分累积的结果a而言\",{\"1\":{\"1615\":1}}],[\"对于一个特定的lambda表达式是什么类型的\",{\"1\":{\"1595\":1}}],[\"对于一个频繁插入删除数据的表来说\",{\"1\":{\"494\":1}}],[\"对于一个有高可用机制的mysql集群来说\",{\"1\":{\"488\":1}}],[\"对于delete语句\",{\"1\":{\"484\":1}}],[\"对于innodb存储引擎来说是一个估计值\",{\"1\":{\"548\":1}}],[\"对于innodb存储引擎来说\",{\"1\":{\"545\":1,\"548\":1,\"553\":1,\"557\":1}}],[\"对于innodb存储引擎的表mysql不会存储表的总记录行数\",{\"1\":{\"526\":1}}],[\"对于innodb引擎的表索引下推只能用于二级索引\",{\"1\":{\"518\":1}}],[\"对于innodb表来说\",{\"1\":{\"356\":1,\"420\":1}}],[\"对于insert语句\",{\"1\":{\"484\":1}}],[\"对于必须要拿到最新结果的请求\",{\"1\":{\"470\":1}}],[\"对于\",{\"1\":{\"465\":1}}],[\"对于大事务\",{\"1\":{\"462\":1}}],[\"对于相同行的更新\",{\"1\":{\"444\":1}}],[\"对于read\",{\"1\":{\"434\":1}}],[\"对于没有unordered特性的collectors来说\",{\"1\":{\"1615\":1}}],[\"对于没有锁竞争的场合\",{\"1\":{\"1485\":1}}],[\"对于没有数据的历史分区\",{\"1\":{\"426\":1}}],[\"对于没有主键的innodb表磊说\",{\"1\":{\"420\":1}}],[\"对于现在的硬件能力来说都已经是小表了\",{\"1\":{\"426\":1}}],[\"对于分区表的使用有以下需要注意的点\",{\"1\":{\"426\":1}}],[\"对于引擎来说\",{\"1\":{\"424\":1}}],[\"对于引擎层来说\",{\"1\":{\"424\":1}}],[\"对于这个例子的说明\",{\"1\":{\"1619\":1}}],[\"对于这个特定的lambda表达式\",{\"1\":{\"1595\":1}}],[\"对于这两个不同的函数式接口的实现都是\",{\"1\":{\"1595\":1}}],[\"对于这种极度不平衡的树\",{\"1\":{\"1620\":1}}],[\"对于这种任务最大线程数一般会大于cpu核心数很多倍\",{\"1\":{\"1510\":1}}],[\"对于这种业务模式来说\",{\"1\":{\"344\":1}}],[\"对于这样的任务最佳的线程数为cpu核心数的1～2倍\",{\"1\":{\"1510\":1}}],[\"对于这10000个准备排序的\",{\"1\":{\"421\":1}}],[\"对于有序的遍历而言\",{\"1\":{\"1623\":1}}],[\"对于有状态的并行流\",{\"1\":{\"1621\":1}}],[\"对于有多个列的联合索引来说\",{\"1\":{\"558\":1}}],[\"对于有主键的innodb表来说\",{\"1\":{\"420\":1}}],[\"对于有索引的表\",{\"1\":{\"322\":1}}],[\"对于sink来说\",{\"1\":{\"1623\":1}}],[\"对于sington作用域\",{\"1\":{\"1236\":1}}],[\"对于stream的操作我们只能进行一次\",{\"1\":{\"1610\":1}}],[\"对于spring\",{\"1\":{\"1002\":1}}],[\"对于server层来说\",{\"1\":{\"424\":1}}],[\"对于session\",{\"1\":{\"410\":1}}],[\"对于sql其实是一个描述性的语言\",{\"1\":{\"1611\":1}}],[\"对于sql\",{\"1\":{\"368\":1}}],[\"对于表t2来说\",{\"1\":{\"405\":1}}],[\"对于第一种\",{\"1\":{\"1593\":1}}],[\"对于第一个问题\",{\"1\":{\"403\":1}}],[\"对于第二个问题\",{\"1\":{\"403\":1}}],[\"对于每一次的调用\",{\"1\":{\"1615\":1}}],[\"对于每一个分区都会创建一个结果容器\",{\"1\":{\"1615\":1}}],[\"对于每一个word值\",{\"1\":{\"420\":1}}],[\"对于每一行r\",{\"1\":{\"401\":1}}],[\"对于每个记录都是只取前6个字节\",{\"1\":{\"350\":1}}],[\"对于返回的结果集\",{\"1\":{\"399\":1}}],[\"对于collectors静态工厂来说\",{\"1\":{\"1618\":1}}],[\"对于count\",{\"1\":{\"396\":1,\"399\":3}}],[\"对于city字段的值相同的行来说\",{\"1\":{\"356\":1}}],[\"对于找出那些\",{\"1\":{\"389\":1}}],[\"对于低效的查询\",{\"1\":{\"381\":1}}],[\"对于全字段的排序流程图会发现\",{\"1\":{\"355\":1}}],[\"对于问题二\",{\"1\":{\"347\":1}}],[\"对于查询的场景来说\",{\"1\":{\"342\":1}}],[\"对于整型字段\",{\"1\":{\"342\":1}}],[\"对于唯一索引来说\",{\"1\":{\"342\":1,\"343\":2}}],[\"对于不等于10的记录\",{\"1\":{\"340\":1}}],[\"对于更新压力大的数据库来说\",{\"1\":{\"319\":1}}],[\"对于已逻辑上过期的缓存\",{\"1\":{\"1287\":1}}],[\"对于已有字段\",{\"1\":{\"309\":1}}],[\"对于已经创建的文档\",{\"1\":{\"309\":1}}],[\"对不同的索引进行操作\",{\"1\":{\"307\":1}}],[\"对查询结果排序\",{\"1\":{\"306\":1}}],[\"对查询结果只输出某些字段\",{\"1\":{\"306\":1}}],[\"fence\",{\"1\":{\"1620\":8}}],[\"feeds\",{\"1\":{\"1619\":1}}],[\"few\",{\"1\":{\"519\":1}}],[\"f=f\",{\"1\":{\"1617\":4}}],[\"f=n\",{\"1\":{\"411\":1}}],[\"fh\",{\"1\":{\"1554\":4}}],[\"fp\",{\"1\":{\"900\":1}}],[\"fd结构来代替fd\",{\"1\":{\"1423\":1}}],[\"fd集合的大小就突破了操作系统的限制\",{\"1\":{\"1423\":1}}],[\"fd\",{\"1\":{\"603\":2,\"1423\":1,\"1569\":3,\"1570\":1}}],[\"fds里面移出来\",{\"1\":{\"605\":1}}],[\"fds\",{\"1\":{\"603\":4,\"1570\":1}}],[\"fast\",{\"1\":{\"1620\":8}}],[\"fastjson\",{\"1\":{\"582\":1}}],[\"fair\",{\"1\":{\"1502\":2}}],[\"failing\",{\"1\":{\"1616\":1,\"1620\":2}}],[\"failure就是这个函数执行失败的回调函数\",{\"1\":{\"1593\":1}}],[\"failure\",{\"1\":{\"1593\":2,\"1619\":2,\"1647\":1,\"1655\":2}}],[\"fail\",{\"1\":{\"1479\":1,\"1620\":8,\"1647\":1}}],[\"failed\",{\"1\":{\"964\":1,\"996\":1,\"1008\":1,\"1575\":5,\"1619\":2,\"1647\":5,\"1648\":2,\"1658\":1}}],[\"failover\",{\"1\":{\"624\":4}}],[\"faces\",{\"1\":{\"1110\":1}}],[\"factor\",{\"1\":{\"1475\":1,\"1550\":1}}],[\"factorybeaninstancecache\",{\"1\":{\"1647\":1}}],[\"factorybean<\",{\"1\":{\"1647\":2}}],[\"factorybean的处理逻辑\",{\"1\":{\"1647\":1}}],[\"factorybeanregistrysupport\",{\"1\":{\"1636\":1}}],[\"factorybeans\",{\"1\":{\"1170\":1}}],[\"factorybean\",{\"0\":{\"1644\":1},\"1\":{\"930\":1,\"1644\":1,\"1647\":1}}],[\"factorybean实例化bean\",{\"1\":{\"930\":1}}],[\"factorybean是创建bean的一种方式\",{\"1\":{\"925\":1}}],[\"factory\",{\"1\":{\"917\":1,\"922\":4,\"928\":1,\"930\":8,\"943\":2,\"952\":1,\"957\":1,\"961\":3,\"962\":1,\"973\":1,\"989\":3,\"997\":1,\"1032\":5,\"1039\":1,\"1146\":3,\"1150\":1,\"1152\":2,\"1164\":3,\"1182\":1,\"1510\":1,\"1615\":1,\"1618\":1,\"1632\":4,\"1647\":11,\"1648\":3}}],[\"factories中也一定能找到这个类的完全限定名\",{\"1\":{\"583\":1}}],[\"fallbackdescriptor\",{\"1\":{\"1648\":3}}],[\"fallback\",{\"1\":{\"928\":1,\"1480\":1,\"1648\":1}}],[\"falseentry\",{\"1\":{\"1618\":2}}],[\"false=\",{\"1\":{\"1613\":1}}],[\"false\",{\"1\":{\"519\":10,\"520\":2,\"542\":1,\"1002\":1,\"1020\":3,\"1023\":1,\"1043\":1,\"1072\":6,\"1139\":1,\"1162\":2,\"1166\":1,\"1170\":1,\"1171\":2,\"1174\":2,\"1175\":3,\"1184\":1,\"1288\":2,\"1387\":1,\"1432\":1,\"1476\":2,\"1502\":1,\"1531\":2,\"1549\":1,\"1553\":1,\"1554\":1,\"1574\":3,\"1599\":4,\"1607\":3,\"1609\":1,\"1618\":1,\"1620\":4,\"1621\":1,\"1622\":2,\"1647\":4,\"1650\":2,\"1663\":1,\"1689\":1}}],[\"fanout\",{\"1\":{\"554\":1}}],[\"faults\",{\"1\":{\"431\":1}}],[\"fsync到磁盘时\",{\"1\":{\"451\":1}}],[\"fsync\",{\"1\":{\"451\":1}}],[\"ftp等\",{\"1\":{\"1037\":1}}],[\"ft\",{\"1\":{\"576\":1,\"1550\":3}}],[\"ftwrl\",{\"1\":{\"437\":1}}],[\"ftime>=\",{\"1\":{\"425\":1}}],[\"ftime=\",{\"1\":{\"425\":1}}],[\"ftime的值分别是\",{\"1\":{\"424\":1}}],[\"ftime\",{\"1\":{\"424\":1}}],[\"fun\",{\"1\":{\"1456\":4}}],[\"func\",{\"1\":{\"462\":3}}],[\"functions\",{\"1\":{\"1615\":8,\"1619\":1}}],[\"function我们都知道它接收一个参数\",{\"1\":{\"1613\":1}}],[\"function这个函数式接口本身接口t类型的参数\",{\"1\":{\"1609\":1}}],[\"function这个包下面\",{\"1\":{\"1601\":1}}],[\"function2\",{\"1\":{\"1598\":4}}],[\"function1\",{\"1\":{\"1598\":4}}],[\"functiontest\",{\"1\":{\"1598\":19}}],[\"function提供了一个接收一个参数并且返回一个结果的函数\",{\"1\":{\"1598\":1}}],[\"function<partition<a>\",{\"1\":{\"1618\":1}}],[\"function<map<k\",{\"1\":{\"1618\":1}}],[\"function<r\",{\"1\":{\"1618\":1}}],[\"function<set<t>\",{\"1\":{\"1617\":2}}],[\"function<string\",{\"1\":{\"1606\":1}}],[\"function<a\",{\"1\":{\"1615\":1,\"1616\":3,\"1618\":2}}],[\"function<integer\",{\"1\":{\"1598\":7}}],[\"function<\",{\"1\":{\"1598\":6,\"1613\":1,\"1618\":7,\"1622\":1}}],[\"function<v\",{\"1\":{\"1598\":2}}],[\"function<t\",{\"1\":{\"1598\":5,\"1609\":1}}],[\"function就是其中一个\",{\"1\":{\"1598\":1}}],[\"function函数式接口\",{\"0\":{\"1598\":1}}],[\"functioninterface这个注解\",{\"1\":{\"1594\":3}}],[\"functioninterface的注解\",{\"1\":{\"1594\":1}}],[\"functionality\",{\"1\":{\"1619\":1}}],[\"functionalinterfacetest\",{\"1\":{\"1595\":17}}],[\"functionalinterface注解\",{\"1\":{\"1594\":1}}],[\"functionalinterface这个注解\",{\"1\":{\"1594\":2}}],[\"functionalinterface\",{\"1\":{\"1594\":9,\"1595\":3,\"1597\":1,\"1598\":2,\"1599\":1,\"1600\":1,\"1601\":1,\"1603\":1,\"1608\":1,\"1609\":1,\"1614\":1}}],[\"functional\",{\"1\":{\"900\":1,\"1593\":1,\"1594\":13,\"1597\":5,\"1598\":3,\"1599\":2,\"1600\":1,\"1601\":3,\"1619\":1}}],[\"function\",{\"1\":{\"431\":1,\"1593\":1,\"1597\":1,\"1598\":108,\"1599\":2,\"1602\":1,\"1606\":2,\"1608\":10,\"1609\":2,\"1613\":1,\"1615\":19,\"1617\":4,\"1618\":10,\"1619\":2,\"1620\":2}}],[\"future的实现\",{\"1\":{\"1530\":1}}],[\"future的局限性\",{\"1\":{\"1516\":1}}],[\"futures\",{\"1\":{\"1517\":5}}],[\"future<integer>\",{\"1\":{\"1517\":3}}],[\"future接口中没有关于异常处理的方法\",{\"1\":{\"1516\":1}}],[\"future接口标识异步任务\",{\"1\":{\"1396\":1}}],[\"future只提供了get\",{\"1\":{\"1516\":1}}],[\"future\",{\"0\":{\"1516\":1},\"1\":{\"1620\":1}}],[\"futuretask\",{\"1\":{\"1411\":1}}],[\"future用来获取结果\",{\"1\":{\"1396\":1}}],[\"further\",{\"1\":{\"1171\":1,\"1620\":4}}],[\"fully\",{\"1\":{\"1647\":1}}],[\"fulladdcount\",{\"1\":{\"1554\":1}}],[\"full\",{\"1\":{\"330\":2,\"997\":1,\"1053\":1,\"1434\":1,\"1647\":1}}],[\"flip\",{\"1\":{\"1533\":1,\"1534\":1,\"1574\":4,\"1575\":4}}],[\"fly\",{\"1\":{\"997\":1,\"1647\":1}}],[\"flatmap\",{\"1\":{\"1609\":3}}],[\"flags\",{\"1\":{\"1621\":1,\"1622\":1,\"1623\":5}}],[\"flags中设置acc\",{\"1\":{\"1483\":1}}],[\"flag\",{\"1\":{\"542\":2,\"922\":1,\"1387\":4,\"1647\":2,\"1651\":1}}],[\"flashback恢复数据的原理\",{\"1\":{\"484\":1}}],[\"flow\",{\"1\":{\"1623\":1,\"1655\":1}}],[\"flowler\",{\"1\":{\"1309\":1}}],[\"flowler大师提出的\",{\"1\":{\"1304\":1}}],[\"float\",{\"1\":{\"528\":1,\"645\":8,\"959\":1,\"1099\":1,\"1475\":1,\"1546\":1,\"1550\":3}}],[\"floor函数在这里的作用\",{\"1\":{\"422\":1}}],[\"floor\",{\"1\":{\"422\":5}}],[\"flux\",{\"1\":{\"1655\":1}}],[\"fluent\",{\"1\":{\"1107\":1}}],[\"flushall\",{\"1\":{\"567\":1,\"583\":1}}],[\"flushdb\",{\"1\":{\"567\":1,\"583\":1}}],[\"flush\",{\"1\":{\"437\":1,\"451\":6,\"557\":1,\"1263\":1}}],[\"flutter实战\",{\"1\":{\"1966\":1}}],[\"flutter\",{\"1\":{\"3\":1,\"1966\":1}}],[\"f\",{\"1\":{\"414\":1,\"577\":1,\"1226\":4,\"1517\":2,\"1526\":1,\"1554\":9,\"1609\":10,\"1617\":14}}],[\"fresh\",{\"1\":{\"1608\":2,\"1623\":1}}],[\"frequently\",{\"1\":{\"1300\":1}}],[\"freemark\",{\"1\":{\"1978\":1}}],[\"freemarker\",{\"1\":{\"983\":1,\"1235\":1}}],[\"free\",{\"1\":{\"1615\":2}}],[\"freenext\",{\"1\":{\"1483\":1}}],[\"freezeconfiguration\",{\"1\":{\"981\":1,\"1171\":1}}],[\"freebsd\",{\"1\":{\"603\":1}}],[\"freeing\",{\"1\":{\"431\":1}}],[\"frozenbeandefinitionnames\",{\"1\":{\"996\":1}}],[\"fromcharacteristics\",{\"1\":{\"1621\":1}}],[\"from表名的语法\",{\"1\":{\"553\":1}}],[\"from后面的是派生表查询\",{\"1\":{\"508\":1}}],[\"from\",{\"1\":{\"307\":1,\"317\":1,\"319\":1,\"321\":1,\"322\":1,\"329\":1,\"330\":5,\"335\":2,\"336\":1,\"338\":1,\"340\":1,\"341\":1,\"342\":1,\"345\":1,\"346\":4,\"347\":1,\"348\":2,\"349\":1,\"350\":2,\"351\":2,\"352\":1,\"353\":1,\"354\":4,\"361\":3,\"366\":3,\"367\":2,\"368\":7,\"370\":6,\"371\":2,\"372\":2,\"373\":2,\"374\":2,\"375\":12,\"376\":3,\"378\":15,\"384\":2,\"390\":4,\"393\":2,\"394\":4,\"395\":1,\"400\":1,\"401\":3,\"402\":1,\"403\":1,\"404\":1,\"407\":3,\"408\":2,\"409\":2,\"411\":4,\"413\":2,\"414\":1,\"416\":3,\"417\":1,\"418\":1,\"419\":1,\"420\":1,\"421\":3,\"422\":9,\"429\":1,\"431\":5,\"434\":1,\"448\":2,\"454\":1,\"476\":1,\"477\":1,\"479\":1,\"509\":6,\"514\":1,\"518\":1,\"519\":5,\"520\":4,\"522\":6,\"524\":1,\"525\":5,\"526\":4,\"537\":1,\"538\":3,\"544\":2,\"547\":1,\"549\":2,\"553\":4,\"554\":5,\"555\":2,\"557\":3,\"558\":3,\"624\":2,\"944\":1,\"964\":1,\"965\":1,\"1022\":3,\"1120\":4,\"1172\":1,\"1175\":2,\"1432\":1,\"1479\":4,\"1498\":1,\"1594\":2,\"1611\":1,\"1613\":1,\"1614\":1,\"1615\":6,\"1617\":2,\"1618\":1,\"1619\":1,\"1620\":9,\"1621\":2,\"1623\":1,\"1647\":1,\"1663\":1}}],[\"from=0\",{\"1\":{\"306\":1}}],[\"from=\",{\"1\":{\"306\":1}}],[\"framwork有哪些核心模块\",{\"0\":{\"903\":1}}],[\"frameworkservlet\",{\"1\":{\"1658\":1}}],[\"framework的核心知识点\",{\"1\":{\"1630\":1}}],[\"framework的操作\",{\"1\":{\"1082\":1}}],[\"framework的优势和不足是什么\",{\"0\":{\"904\":1}}],[\"framework中定义bean配置元信息接口\",{\"1\":{\"927\":1}}],[\"framework中使用设计模式的实现\",{\"0\":{\"855\":1}}],[\"framework是ioc\",{\"1\":{\"924\":1}}],[\"framework提供一个完整性的编程或配置的一个现代化的基于java的企业的应用\",{\"1\":{\"902\":1}}],[\"framework版本\",{\"1\":{\"897\":1}}],[\"framework\",{\"0\":{\"902\":1},\"1\":{\"896\":1,\"900\":1,\"908\":1,\"996\":1,\"1130\":5,\"1620\":2}}],[\"framework特性运用\",{\"0\":{\"865\":1}}],[\"frm的文件中\",{\"1\":{\"490\":1}}],[\"frm文件和4个\",{\"1\":{\"424\":1}}],[\"frm\",{\"1\":{\"412\":1}}],[\"fk\",{\"1\":{\"390\":5}}],[\"f2=\",{\"1\":{\"1517\":1}}],[\"f2\",{\"1\":{\"349\":1,\"1412\":2,\"1517\":1}}],[\"f1\",{\"1\":{\"349\":1,\"1412\":3,\"1517\":2}}],[\"ffffffffffff\",{\"1\":{\"468\":3}}],[\"ff\",{\"1\":{\"336\":1}}],[\"fido\",{\"1\":{\"1510\":1}}],[\"fibonacci\",{\"1\":{\"1412\":6}}],[\"finsher就得到了调用\",{\"1\":{\"1617\":1}}],[\"findaspectjannotationonmethod\",{\"1\":{\"1654\":1}}],[\"findautowiredannotation\",{\"1\":{\"964\":2,\"965\":1,\"1648\":2}}],[\"findautowirecandidates方法会返回class对象\",{\"1\":{\"1648\":1}}],[\"findautowirecandidates\",{\"1\":{\"963\":5,\"1648\":2}}],[\"findautowiringmetadata\",{\"1\":{\"964\":2,\"1648\":2}}],[\"findpropertyformethod\",{\"1\":{\"1648\":1}}],[\"findbridgedmethod\",{\"1\":{\"1648\":1}}],[\"findbootstrapclassornull\",{\"1\":{\"1432\":1,\"1663\":1}}],[\"findcandidatecomponents\",{\"1\":{\"1647\":1}}],[\"findclass\",{\"1\":{\"1432\":2,\"1663\":2}}],[\"findop\",{\"1\":{\"1624\":1}}],[\"findfirst\",{\"1\":{\"1609\":1,\"1612\":2}}],[\"find\",{\"1\":{\"1432\":1,\"1648\":1,\"1663\":1}}],[\"findloadedclass\",{\"1\":{\"1432\":1,\"1663\":1}}],[\"final语义中的内存屏障\",{\"0\":{\"1769\":1}}],[\"final变量\",{\"1\":{\"1345\":1}}],[\"final\",{\"1\":{\"952\":1,\"963\":3,\"965\":1,\"975\":1,\"989\":2,\"1001\":1,\"1003\":2,\"1005\":1,\"1061\":1,\"1163\":1,\"1172\":1,\"1175\":1,\"1194\":1,\"1227\":1,\"1368\":1,\"1412\":1,\"1475\":3,\"1480\":1,\"1502\":8,\"1503\":12,\"1520\":5,\"1526\":5,\"1528\":1,\"1533\":1,\"1534\":1,\"1546\":9,\"1548\":1,\"1549\":1,\"1550\":1,\"1553\":1,\"1554\":5,\"1557\":1,\"1605\":1,\"1609\":3,\"1614\":2,\"1615\":5,\"1616\":5,\"1617\":1,\"1618\":6,\"1620\":14,\"1621\":4,\"1622\":3,\"1623\":5,\"1647\":1,\"1648\":2,\"1651\":1,\"1655\":5}}],[\"finalized\",{\"1\":{\"1013\":1}}],[\"finalize\",{\"1\":{\"934\":1,\"1013\":2}}],[\"finally\",{\"1\":{\"582\":1,\"922\":1,\"963\":1,\"1166\":1,\"1170\":1,\"1226\":2,\"1502\":2,\"1503\":4,\"1517\":1,\"1528\":1,\"1533\":1,\"1534\":1,\"1553\":1,\"1554\":1,\"1573\":1,\"1574\":2,\"1575\":2,\"1647\":4,\"1648\":1,\"1651\":1,\"1655\":2}}],[\"finishing\",{\"1\":{\"1618\":1}}],[\"finish去掉\",{\"1\":{\"1618\":1}}],[\"finish特性去掉的原因在于\",{\"1\":{\"1618\":1}}],[\"finish特性\",{\"1\":{\"1618\":1}}],[\"finish这个枚举值\",{\"1\":{\"1617\":1}}],[\"finish这个特性\",{\"1\":{\"1617\":1}}],[\"finish表示finisher方法就是identity方法\",{\"1\":{\"1617\":1}}],[\"finish\",{\"1\":{\"1615\":1,\"1617\":5,\"1618\":7}}],[\"finisher方法就不会得到执行\",{\"1\":{\"1618\":1}}],[\"finisher\",{\"1\":{\"1615\":12,\"1616\":6,\"1617\":11,\"1618\":11}}],[\"finishconnect\",{\"1\":{\"1574\":1}}],[\"finishrefresh方法\",{\"1\":{\"1172\":1}}],[\"finishrefresh\",{\"1\":{\"922\":1,\"1172\":1,\"1647\":1,\"1651\":1}}],[\"finishbeanfactoryinitialization方法中\",{\"1\":{\"1009\":1}}],[\"finishbeanfactoryinitialization\",{\"1\":{\"922\":1,\"1009\":1,\"1171\":2,\"1647\":1,\"1651\":1}}],[\"fifo\",{\"1\":{\"645\":1}}],[\"first收集器\",{\"0\":{\"1739\":1}}],[\"first从返回包解析出gtid的值即可\",{\"1\":{\"474\":1}}],[\"first\",{\"1\":{\"429\":1,\"609\":1,\"1031\":1,\"1156\":2,\"1166\":1,\"1170\":1,\"1172\":1,\"1432\":1,\"1503\":4,\"1553\":4,\"1598\":14,\"1609\":1,\"1615\":1,\"1619\":3,\"1620\":4,\"1623\":2,\"1648\":1}}],[\"filo栈结构\",{\"1\":{\"1483\":1}}],[\"filderror\",{\"1\":{\"1063\":1}}],[\"filters\",{\"1\":{\"1658\":3}}],[\"filterpropertydescriptorsfordependencycheck\",{\"1\":{\"1647\":2}}],[\"filtertype\",{\"1\":{\"1135\":2,\"1645\":2}}],[\"filtering代表的百分比\",{\"1\":{\"555\":2}}],[\"filtering可以让成本估算更精确\",{\"1\":{\"554\":1}}],[\"filtering\",{\"1\":{\"519\":1,\"554\":1,\"1623\":4}}],[\"filter\",{\"1\":{\"485\":1,\"963\":1,\"1135\":2,\"1283\":1,\"1598\":2,\"1610\":7,\"1611\":2,\"1612\":2,\"1619\":3,\"1623\":1,\"1645\":2,\"1658\":4,\"1978\":1}}],[\"filteredpds\",{\"1\":{\"1647\":7}}],[\"filtered\",{\"1\":{\"329\":1,\"330\":5,\"361\":1,\"506\":1,\"553\":1,\"555\":2}}],[\"film2\",{\"1\":{\"506\":1}}],[\"film\",{\"1\":{\"384\":4,\"390\":17,\"506\":1,\"509\":8}}],[\"filenotfoundexception\",{\"1\":{\"1647\":1}}],[\"filename\",{\"1\":{\"429\":1}}],[\"fileoutputstream\",{\"1\":{\"1591\":1}}],[\"filechannel\",{\"1\":{\"1587\":5,\"1588\":4}}],[\"filebeat\",{\"1\":{\"1257\":1,\"1310\":1}}],[\"fileencoding\",{\"1\":{\"1146\":2}}],[\"fileurlresource\",{\"1\":{\"1040\":1}}],[\"file或java\",{\"1\":{\"1037\":1}}],[\"file和exec\",{\"1\":{\"472\":2}}],[\"file和read\",{\"1\":{\"472\":2}}],[\"file和master\",{\"1\":{\"468\":1}}],[\"file=$master\",{\"1\":{\"467\":1}}],[\"file=\",{\"1\":{\"428\":1}}],[\"file\",{\"1\":{\"428\":1,\"467\":1,\"473\":2,\"479\":9,\"591\":1,\"1039\":1,\"1040\":2,\"1060\":1,\"1423\":1,\"1570\":1,\"1619\":1}}],[\"filesystemresourceloader\",{\"1\":{\"1041\":3,\"1043\":1}}],[\"filesystemresource\",{\"1\":{\"1039\":1,\"1040\":5,\"1041\":2}}],[\"files\",{\"1\":{\"425\":1,\"520\":2,\"1619\":1}}],[\"files是0\",{\"1\":{\"421\":1}}],[\"files的值却是0\",{\"1\":{\"421\":1}}],[\"files的值就越大\",{\"1\":{\"354\":1}}],[\"files变成10了\",{\"1\":{\"355\":1}}],[\"files就是0\",{\"1\":{\"354\":1}}],[\"files表示的是\",{\"1\":{\"354\":1}}],[\"files中看到是否使用了临时文件\",{\"1\":{\"354\":1}}],[\"filesort文件排序方式\",{\"1\":{\"520\":1}}],[\"filesort表示的是需要执行排序操作\",{\"1\":{\"420\":1}}],[\"filesort说明排序没有用到c4字段\",{\"1\":{\"378\":1}}],[\"filesort了\",{\"1\":{\"356\":1}}],[\"filesort\",{\"1\":{\"330\":2,\"354\":1,\"361\":2,\"378\":4,\"416\":1,\"421\":1,\"520\":16}}],[\"filex\",{\"1\":{\"345\":1}}],[\"fielderror\",{\"1\":{\"1062\":1,\"1063\":3,\"1064\":1,\"1068\":1}}],[\"fieldname\",{\"1\":{\"963\":1}}],[\"fields\",{\"1\":{\"964\":1,\"1351\":1,\"1648\":1}}],[\"fields>\",{\"1\":{\"520\":1}}],[\"fields的意思是\",{\"1\":{\"354\":1}}],[\"field\",{\"1\":{\"330\":1,\"352\":1,\"520\":2,\"573\":9,\"961\":3,\"964\":12,\"967\":2,\"1061\":3,\"1254\":1,\"1351\":1,\"1479\":1,\"1647\":1,\"1648\":11}}],[\"field2\",{\"1\":{\"307\":1,\"573\":3}}],[\"field1\",{\"1\":{\"307\":1,\"573\":3}}],[\"fold\",{\"1\":{\"1615\":1}}],[\"folds\",{\"1\":{\"1615\":1}}],[\"follows\",{\"1\":{\"1623\":1}}],[\"following\",{\"1\":{\"1608\":2,\"1615\":2,\"1616\":1,\"1619\":1,\"1620\":1,\"1621\":1}}],[\"followed\",{\"1\":{\"1597\":2}}],[\"follower\",{\"1\":{\"606\":1}}],[\"follow\",{\"1\":{\"570\":1}}],[\"four\",{\"1\":{\"1615\":1}}],[\"found\",{\"1\":{\"928\":1,\"965\":1,\"973\":1,\"1164\":2,\"1165\":1,\"1432\":2,\"1647\":1,\"1648\":1,\"1663\":2,\"1994\":1}}],[\"foo=f\",{\"1\":{\"1526\":1}}],[\"foo线程安全\",{\"1\":{\"1526\":1}}],[\"foo具备不可变性\",{\"1\":{\"1526\":1}}],[\"foo\",{\"1\":{\"1526\":8}}],[\"foobared\",{\"1\":{\"624\":1}}],[\"fowler对ioc做出了进一步的说明\",{\"1\":{\"905\":1}}],[\"fowler提出了自己对ioc以及di的理解\",{\"1\":{\"905\":1}}],[\"forfallbackmatch\",{\"1\":{\"1648\":1}}],[\"forfalse\",{\"1\":{\"1618\":9}}],[\"forfield\",{\"1\":{\"1103\":1}}],[\"fortrue\",{\"1\":{\"1618\":9}}],[\"forgery\",{\"1\":{\"1201\":1}}],[\"forclass\",{\"1\":{\"1103\":1}}],[\"force\",{\"1\":{\"346\":1,\"1053\":2,\"1689\":1}}],[\"forname\",{\"1\":{\"965\":1,\"998\":1}}],[\"forelements\",{\"1\":{\"1648\":1}}],[\"foreachtask<>\",{\"1\":{\"1623\":1}}],[\"foreachtask\",{\"1\":{\"1623\":1}}],[\"foreachop\",{\"1\":{\"1623\":1,\"1624\":1}}],[\"foreachops\",{\"1\":{\"1622\":1}}],[\"foreachorderedtask<>\",{\"1\":{\"1623\":1}}],[\"foreachordered\",{\"1\":{\"1621\":2}}],[\"foreachremaining\",{\"1\":{\"1620\":18,\"1621\":2,\"1622\":4,\"1623\":1}}],[\"foreach实际上是调用iterable这个类中jdk1\",{\"1\":{\"1593\":1}}],[\"foreach\",{\"1\":{\"909\":1,\"943\":1,\"944\":1,\"962\":1,\"1043\":1,\"1044\":1,\"1075\":2,\"1099\":2,\"1215\":1,\"1593\":5,\"1594\":2,\"1595\":2,\"1597\":2,\"1598\":1,\"1602\":1,\"1603\":3,\"1604\":3,\"1605\":3,\"1607\":4,\"1608\":2,\"1609\":9,\"1610\":4,\"1611\":1,\"1615\":1,\"1617\":2,\"1619\":4,\"1620\":2,\"1621\":2,\"1622\":6}}],[\"foreign\",{\"1\":{\"390\":1}}],[\"forked\",{\"1\":{\"1619\":1,\"1620\":1}}],[\"forkjoin是一种基于分治算法的模型\",{\"1\":{\"1514\":1}}],[\"forkjoinworkthread是用于执行任务的线程\",{\"1\":{\"1513\":1}}],[\"forkjoinworkthread\",{\"0\":{\"1513\":1}}],[\"forkjoinworkerthreadfactory\",{\"1\":{\"1510\":1}}],[\"forkjoinpool\",{\"1\":{\"1617\":27,\"1620\":1}}],[\"forkjoinpool引入了工作窃取设计\",{\"1\":{\"1511\":1}}],[\"forkjoinpool与threadpoolexecutor有个很大的不同之处在于\",{\"1\":{\"1511\":1}}],[\"forkjoinpool多个线程\",{\"1\":{\"1510\":1}}],[\"forkjoinpool中有四个核心参数\",{\"1\":{\"1510\":1}}],[\"forkjoinpool是threadpoolexecutor线程池的一种补充\",{\"1\":{\"1510\":1}}],[\"forkjoinpool最适合计算密集型任务\",{\"1\":{\"1510\":1}}],[\"forkjoinpool允许其他线程向它提交任务\",{\"1\":{\"1510\":1}}],[\"forkjoin的基本思想是分治\",{\"1\":{\"1510\":1}}],[\"forkjoin实现原理\",{\"0\":{\"1510\":1}}],[\"fork进程的时候\",{\"1\":{\"590\":1}}],[\"fork\",{\"1\":{\"588\":1,\"1412\":1,\"1510\":1,\"1620\":1}}],[\"fork操作过程中父进程会阻塞\",{\"1\":{\"588\":1}}],[\"formatstyle\",{\"1\":{\"1053\":2}}],[\"formattingconversionservice\",{\"1\":{\"1092\":1}}],[\"formattype\",{\"1\":{\"1053\":2}}],[\"formatter等\",{\"1\":{\"959\":1}}],[\"format\",{\"1\":{\"553\":1,\"555\":1,\"1053\":7,\"1087\":2}}],[\"format=mixed时\",{\"1\":{\"459\":1}}],[\"format=\",{\"1\":{\"454\":1}}],[\"format=statement时\",{\"1\":{\"454\":1}}],[\"format=statment\",{\"1\":{\"413\":1,\"492\":1}}],[\"format=row和binlog\",{\"1\":{\"484\":1}}],[\"format=row情况又会如何呢\",{\"1\":{\"459\":1}}],[\"format=row的时候\",{\"1\":{\"454\":1}}],[\"format=row\",{\"1\":{\"413\":2,\"485\":1,\"492\":1}}],[\"for\",{\"1\":{\"318\":1,\"322\":1,\"355\":1,\"421\":3,\"429\":1,\"431\":2,\"447\":1,\"448\":2,\"467\":1,\"474\":2,\"494\":1,\"519\":6,\"520\":7,\"537\":1,\"541\":1,\"603\":2,\"645\":1,\"922\":6,\"943\":1,\"946\":2,\"963\":1,\"964\":2,\"965\":2,\"973\":1,\"985\":2,\"989\":2,\"996\":4,\"997\":2,\"1000\":1,\"1006\":1,\"1023\":1,\"1027\":2,\"1029\":1,\"1031\":1,\"1063\":1,\"1064\":1,\"1084\":1,\"1091\":1,\"1103\":1,\"1139\":1,\"1156\":1,\"1157\":1,\"1162\":1,\"1163\":1,\"1164\":4,\"1165\":1,\"1166\":6,\"1170\":3,\"1171\":6,\"1172\":1,\"1182\":2,\"1254\":1,\"1263\":1,\"1347\":1,\"1404\":4,\"1487\":1,\"1517\":3,\"1521\":1,\"1549\":2,\"1550\":1,\"1553\":1,\"1554\":2,\"1591\":2,\"1593\":2,\"1594\":1,\"1595\":5,\"1599\":7,\"1601\":4,\"1603\":1,\"1608\":11,\"1609\":1,\"1611\":2,\"1612\":1,\"1614\":2,\"1615\":15,\"1617\":1,\"1618\":3,\"1619\":5,\"1620\":45,\"1621\":13,\"1622\":6,\"1623\":21,\"1646\":1,\"1647\":27,\"1648\":4,\"1650\":1,\"1651\":2,\"1654\":2,\"1658\":1}}],[\"fox\",{\"1\":{\"309\":2,\"1521\":1}}],[\"fox老师666\",{\"1\":{\"307\":2}}],[\"fox老师\",{\"1\":{\"307\":2}}],[\">referencepipline\",{\"1\":{\"1624\":1}}],[\">abstractpipline\",{\"1\":{\"1624\":1}}],[\">associative<\",{\"1\":{\"1608\":2}}],[\">stream\",{\"1\":{\"1624\":1}}],[\">stateless<\",{\"1\":{\"1608\":2}}],[\">save\",{\"1\":{\"1517\":2}}],[\">non\",{\"1\":{\"1608\":2}}],[\">terminal\",{\"1\":{\"1608\":1}}],[\">mutable\",{\"1\":{\"1608\":1}}],[\">functional\",{\"1\":{\"1597\":1,\"1598\":3,\"1599\":2,\"1600\":1,\"1601\":1}}],[\">geocoderbys3\",{\"1\":{\"1517\":1}}],[\">geocoderbys2\",{\"1\":{\"1517\":1}}],[\">geocoderbys1\",{\"1\":{\"1517\":1}}],[\">getpricebys2\",{\"1\":{\"1517\":1}}],[\">getpricebys1\",{\"1\":{\"1517\":1}}],[\">>\",{\"1\":{\"1506\":1,\"1621\":4}}],[\">>>\",{\"1\":{\"1359\":1,\"1506\":1,\"1548\":3,\"1553\":1,\"1554\":2,\"1620\":1}}],[\">这也是spring\",{\"1\":{\"1201\":1}}],[\">jiyongchao<\",{\"1\":{\"1091\":1}}],[\">1<\",{\"1\":{\"1091\":1}}],[\">配置的话\",{\"1\":{\"1003\":1}}],[\"><\",{\"1\":{\"917\":1,\"918\":2}}],[\">=\",{\"1\":{\"366\":3,\"404\":1,\"407\":1,\"408\":1,\"409\":1,\"411\":2,\"422\":1,\"484\":1,\"542\":1,\"1506\":1,\"1549\":1,\"1550\":2,\"1554\":4,\"1601\":1,\"1607\":1,\"1613\":1,\"1616\":1}}],[\">28\",{\"1\":{\"306\":1}}],[\">\",{\"0\":{\"818\":1,\"819\":1},\"1\":{\"306\":1,\"330\":1,\"334\":3,\"361\":3,\"372\":1,\"377\":1,\"378\":2,\"393\":1,\"434\":1,\"509\":1,\"519\":9,\"522\":1,\"536\":1,\"544\":2,\"547\":2,\"549\":4,\"553\":4,\"554\":9,\"555\":8,\"567\":4,\"569\":2,\"571\":1,\"582\":2,\"645\":1,\"905\":1,\"917\":8,\"918\":14,\"928\":2,\"929\":1,\"930\":14,\"931\":1,\"932\":1,\"933\":1,\"944\":3,\"953\":12,\"954\":9,\"961\":3,\"963\":17,\"964\":6,\"965\":2,\"972\":1,\"973\":1,\"977\":1,\"985\":1,\"986\":1,\"987\":1,\"988\":1,\"989\":6,\"998\":2,\"1000\":2,\"1001\":1,\"1002\":2,\"1003\":5,\"1005\":1,\"1007\":1,\"1008\":1,\"1012\":4,\"1020\":7,\"1021\":4,\"1030\":4,\"1032\":5,\"1064\":1,\"1065\":6,\"1072\":3,\"1075\":1,\"1083\":6,\"1084\":10,\"1091\":13,\"1093\":11,\"1100\":4,\"1116\":1,\"1123\":1,\"1124\":1,\"1136\":1,\"1146\":16,\"1170\":1,\"1171\":1,\"1234\":3,\"1257\":3,\"1309\":1,\"1347\":1,\"1387\":1,\"1404\":7,\"1432\":4,\"1433\":4,\"1436\":1,\"1479\":2,\"1503\":1,\"1506\":1,\"1517\":4,\"1528\":2,\"1533\":1,\"1534\":1,\"1535\":2,\"1549\":1,\"1550\":2,\"1553\":1,\"1554\":2,\"1574\":2,\"1591\":2,\"1592\":1,\"1593\":3,\"1594\":7,\"1595\":9,\"1597\":2,\"1598\":26,\"1599\":29,\"1600\":5,\"1601\":4,\"1603\":5,\"1604\":4,\"1605\":4,\"1607\":2,\"1608\":5,\"1609\":11,\"1610\":27,\"1611\":6,\"1612\":3,\"1613\":2,\"1614\":7,\"1615\":1,\"1616\":7,\"1617\":9,\"1618\":21,\"1619\":10,\"1620\":4,\"1621\":2,\"1622\":4,\"1623\":2,\"1624\":2,\"1638\":1,\"1644\":1,\"1647\":14,\"1648\":13,\"1649\":1,\"1650\":3,\"1654\":4,\"1655\":7,\"1663\":2,\"1683\":2}}],[\"范围区间内的数量\",{\"1\":{\"549\":1}}],[\"范围区间的数量\",{\"1\":{\"549\":1}}],[\"范围区间数量\",{\"1\":{\"549\":2}}],[\"范围\",{\"1\":{\"528\":2,\"529\":1}}],[\"范围扫描\",{\"1\":{\"390\":1}}],[\"范围之后全失效\",{\"0\":{\"372\":1},\"1\":{\"372\":1,\"378\":1}}],[\"范围之后的索引会失效\",{\"1\":{\"361\":1}}],[\"范围查询\",{\"1\":{\"306\":1,\"1265\":1}}],[\"范围类型\",{\"1\":{\"304\":1}}],[\"kotlindelegate\",{\"1\":{\"1655\":2}}],[\"kotlindetector\",{\"1\":{\"1655\":1}}],[\"k表示分类器返回的结果的类型\",{\"1\":{\"1618\":1}}],[\"k表示分类的时候的key的类型\",{\"1\":{\"1618\":1}}],[\"k类型以及k类型以下的类型\",{\"1\":{\"1618\":1}}],[\"k>\",{\"1\":{\"1613\":2,\"1618\":5}}],[\"klass\",{\"1\":{\"1484\":1}}],[\"keeping\",{\"1\":{\"1615\":1}}],[\"keepalivetime\",{\"1\":{\"1476\":2}}],[\"kernel会给用户进程发送一个signal\",{\"1\":{\"1566\":1}}],[\"kernel会等待数据准备完成\",{\"1\":{\"1566\":1}}],[\"kernel会\",{\"1\":{\"1565\":1}}],[\"kernel就开始io的第一个阶段\",{\"1\":{\"1563\":1}}],[\"key是datasource\",{\"1\":{\"1655\":1}}],[\"key是beanname\",{\"1\":{\"1648\":1,\"1649\":1}}],[\"key是查询的语句\",{\"1\":{\"319\":1}}],[\"keyextractor\",{\"1\":{\"1614\":4}}],[\"keyed\",{\"1\":{\"975\":1}}],[\"key已经存在直接覆盖value\",{\"1\":{\"1549\":1}}],[\"key已经存在了\",{\"1\":{\"412\":1}}],[\"key必须实现comparable接口或者在构造treemap传入自定义的comparator\",{\"1\":{\"1544\":1}}],[\"key可以为null\",{\"1\":{\"1475\":1}}],[\"key不能重复\",{\"1\":{\"1355\":1}}],[\"key不同\",{\"1\":{\"412\":1,\"413\":1}}],[\"keyword\",{\"1\":{\"1254\":1}}],[\"keytype\",{\"1\":{\"963\":2}}],[\"key监控指定数据\",{\"1\":{\"581\":1}}],[\"key2\",{\"1\":{\"570\":3,\"571\":1,\"572\":7,\"574\":2}}],[\"key1\",{\"1\":{\"570\":3,\"571\":5,\"572\":7,\"574\":2}}],[\"key1列就可能有很多重复的记录\",{\"1\":{\"558\":1}}],[\"key的操作\",{\"1\":{\"569\":1}}],[\"key的值是由\",{\"1\":{\"412\":1}}],[\"key字段对应的值为null\",{\"1\":{\"522\":1}}],[\"key`idx\",{\"1\":{\"510\":1}}],[\"key就是bean的名称\",{\"1\":{\"996\":1}}],[\"key就是数据库名\",{\"1\":{\"463\":1}}],[\"key就是\",{\"1\":{\"413\":2}}],[\"key在\",{\"1\":{\"412\":1}}],[\"key=hash\",{\"1\":{\"462\":3}}],[\"key=\",{\"1\":{\"366\":1,\"989\":1,\"1091\":2}}],[\"key或者unique索引\",{\"1\":{\"330\":1}}],[\"keys的使用\",{\"0\":{\"1854\":1}}],[\"keyset\",{\"1\":{\"963\":5}}],[\"keys只有idx\",{\"1\":{\"547\":1}}],[\"keys\",{\"1\":{\"329\":2,\"330\":7,\"361\":1,\"390\":2,\"553\":1,\"555\":2,\"567\":3,\"569\":4,\"579\":1,\"1618\":1}}],[\"key\",{\"0\":{\"405\":1,\"569\":1},\"1\":{\"323\":1,\"329\":3,\"330\":17,\"332\":1,\"335\":2,\"336\":1,\"338\":3,\"346\":3,\"349\":1,\"353\":2,\"355\":1,\"361\":3,\"362\":2,\"363\":1,\"366\":3,\"368\":2,\"378\":1,\"390\":6,\"400\":2,\"404\":1,\"405\":2,\"407\":1,\"412\":2,\"413\":2,\"414\":1,\"419\":1,\"424\":1,\"442\":1,\"446\":2,\"448\":3,\"454\":3,\"459\":2,\"462\":2,\"467\":1,\"468\":1,\"476\":1,\"478\":2,\"489\":2,\"491\":1,\"494\":3,\"506\":5,\"510\":1,\"518\":2,\"519\":4,\"520\":2,\"523\":2,\"534\":1,\"535\":1,\"553\":4,\"555\":6,\"557\":1,\"564\":1,\"567\":1,\"569\":10,\"570\":15,\"571\":11,\"572\":8,\"573\":19,\"574\":21,\"576\":6,\"577\":3,\"578\":7,\"583\":1,\"587\":3,\"989\":2,\"1052\":1,\"1070\":1,\"1263\":1,\"1288\":4,\"1475\":1,\"1506\":3,\"1546\":2,\"1548\":4,\"1549\":16,\"1553\":9,\"1554\":14,\"1574\":26,\"1618\":10,\"1620\":1,\"1655\":1,\"1975\":1}}],[\"kafka和elasticsearch\",{\"1\":{\"1987\":1}}],[\"kafka和rocketmq都是通过零拷贝技术来优化文件读写\",{\"1\":{\"1331\":1}}],[\"kafka使用transfile方式将硬盘数据加载到网卡\",{\"1\":{\"1330\":1,\"1331\":1}}],[\"kafka\",{\"1\":{\"1327\":1,\"1328\":3,\"1333\":1,\"1985\":1}}],[\"kafka如何避免重复消费\",{\"0\":{\"253\":1,\"1334\":1}}],[\"known\",{\"1\":{\"1620\":1,\"1623\":1}}],[\"know\",{\"1\":{\"1254\":1,\"1623\":1}}],[\"kuangshen\",{\"1\":{\"582\":1,\"583\":1}}],[\"kb\",{\"1\":{\"577\":1}}],[\"km\",{\"1\":{\"576\":3}}],[\"k6\",{\"1\":{\"571\":4}}],[\"k5\",{\"1\":{\"571\":7}}],[\"kitchen\",{\"1\":{\"1623\":1}}],[\"kit\",{\"1\":{\"1337\":1}}],[\"kibana\",{\"1\":{\"1257\":1}}],[\"kind\",{\"1\":{\"571\":1}}],[\"killed\",{\"1\":{\"481\":1}}],[\"kill并不是马上停止的意思\",{\"1\":{\"481\":1}}],[\"kill\",{\"1\":{\"480\":1,\"481\":6,\"538\":1}}],[\"kill命令的执行过程\",{\"0\":{\"481\":1}}],[\"kill命令\",{\"0\":{\"480\":1}}],[\"k4\",{\"1\":{\"570\":1,\"571\":12}}],[\"k3\",{\"1\":{\"570\":2,\"571\":8,\"579\":2}}],[\"k越小越好\",{\"1\":{\"403\":1}}],[\"kk\",{\"1\":{\"377\":4}}],[\"k2所在的数据页不在内存中\",{\"1\":{\"345\":1}}],[\"k2\",{\"1\":{\"345\":2,\"570\":2,\"571\":44,\"579\":3,\"580\":4}}],[\"k1所在的数据页在内存\",{\"1\":{\"345\":1}}],[\"k1\",{\"1\":{\"345\":2,\"570\":3,\"571\":14,\"579\":5,\"580\":5}}],[\"kv场景的特点如下\",{\"1\":{\"335\":1}}],[\"kv键值对\",{\"1\":{\"306\":1}}],[\"k\",{\"1\":{\"335\":4,\"336\":4,\"338\":1,\"342\":1,\"345\":2,\"377\":1,\"411\":3,\"577\":2,\"1506\":6,\"1546\":3,\"1548\":1,\"1549\":8,\"1553\":6,\"1554\":4,\"1618\":9}}],[\"qingdao\",{\"1\":{\"1605\":1}}],[\"qinjiang\",{\"1\":{\"569\":1}}],[\"qmode=0\",{\"1\":{\"1483\":1}}],[\"qulifier对注入的bean可以进行逻辑上的分组\",{\"1\":{\"961\":1}}],[\"qualifer\",{\"1\":{\"1131\":1}}],[\"qualifer限定bean的名称的示例\",{\"1\":{\"961\":1}}],[\"qualifiers\",{\"1\":{\"1027\":3}}],[\"qualifier注解还可以作用到注解上面\",{\"1\":{\"961\":1}}],[\"qualifierusers\",{\"1\":{\"961\":6}}],[\"qualifierannotationdependencyinjectiondemo\",{\"1\":{\"961\":12}}],[\"qualifier\",{\"1\":{\"961\":15,\"985\":10,\"1023\":1,\"1027\":4,\"1242\":1,\"1648\":1}}],[\"qualifier扩展限定\",{\"1\":{\"961\":1}}],[\"qualifier限定\",{\"1\":{\"961\":1}}],[\"quorum\",{\"1\":{\"624\":1}}],[\"quit\",{\"1\":{\"598\":1}}],[\"quick呢\",{\"1\":{\"482\":1}}],[\"quick参数的意思\",{\"1\":{\"482\":1}}],[\"quick参数\",{\"1\":{\"482\":1}}],[\"quick是一个更容易引起误会的参数\",{\"1\":{\"482\":1}}],[\"quick\",{\"1\":{\"482\":1}}],[\"quey\",{\"1\":{\"480\":1}}],[\"queried\",{\"1\":{\"1619\":2,\"1621\":1}}],[\"queries\",{\"1\":{\"428\":3,\"429\":1}}],[\"query或者kill\",{\"1\":{\"481\":1}}],[\"query状态\",{\"1\":{\"481\":1}}],[\"query以后\",{\"1\":{\"480\":1}}],[\"query命令时\",{\"1\":{\"481\":1}}],[\"query命令\",{\"1\":{\"480\":1}}],[\"query\",{\"1\":{\"306\":4,\"307\":2,\"308\":1,\"346\":1,\"393\":1,\"420\":1,\"428\":20,\"429\":3,\"431\":8,\"480\":1,\"481\":8,\"496\":5,\"519\":1,\"526\":2,\"553\":2,\"555\":2,\"1619\":1,\"1620\":1}}],[\"query更新文档\",{\"1\":{\"306\":1}}],[\"queue<e>\",{\"1\":{\"1500\":1}}],[\"queue队列\",{\"0\":{\"1500\":1}}],[\"queuecapacity\",{\"1\":{\"1410\":1}}],[\"queued\",{\"1\":{\"579\":7,\"580\":7,\"581\":4}}],[\"queue\",{\"1\":{\"421\":1,\"520\":4,\"1326\":1,\"1510\":2,\"1689\":3,\"1985\":1}}],[\"queery\",{\"1\":{\"318\":1}}],[\"q4\",{\"1\":{\"413\":1}}],[\"q3读到id=1这一行的现象\",{\"1\":{\"446\":1}}],[\"q3\",{\"1\":{\"413\":1}}],[\"q2和q3\",{\"1\":{\"446\":1}}],[\"q2的rows的值是37116\",{\"1\":{\"347\":1}}],[\"q2扫描了10001行\",{\"1\":{\"346\":1}}],[\"q2是加了force\",{\"1\":{\"346\":1}}],[\"q2\",{\"1\":{\"346\":1,\"413\":1}}],[\"q1只返回id=5这一行\",{\"1\":{\"446\":1}}],[\"q1扫描了10万行\",{\"1\":{\"346\":1}}],[\"q1是session\",{\"1\":{\"346\":1}}],[\"q1\",{\"1\":{\"346\":1,\"413\":1}}],[\"qq\",{\"1\":{\"330\":1,\"573\":3}}],[\"q=age\",{\"1\":{\"306\":5}}],[\"q=\",{\"1\":{\"306\":2}}],[\"q\",{\"1\":{\"306\":1,\"482\":1,\"577\":1}}],[\"要对元素的结构上一些修改进行相应检测\",{\"1\":{\"1620\":1}}],[\"要掌握整个的流程\",{\"1\":{\"1613\":1}}],[\"要完成这样的一个sql的功能\",{\"1\":{\"1611\":1}}],[\"要完成这个交易\",{\"1\":{\"443\":1}}],[\"要实现这两个接口\",{\"1\":{\"1607\":1}}],[\"要实现上述相同的需求\",{\"1\":{\"401\":1}}],[\"要使用linkedlist\",{\"1\":{\"1618\":1}}],[\"要使用所谓的索引统计数据来进行估算\",{\"1\":{\"553\":1}}],[\"要使指向该对象的指针永远不会逃逸\",{\"1\":{\"1488\":1}}],[\"要比较的值\",{\"1\":{\"1479\":1}}],[\"要交换的值\",{\"1\":{\"1479\":1}}],[\"要统计的字符串\",{\"1\":{\"1464\":2}}],[\"要同时满足下面三个条件\",{\"1\":{\"1443\":1}}],[\"要尽量较少碰撞\",{\"1\":{\"1357\":1}}],[\"要注意布隆过滤器存在一定的误判率\",{\"1\":{\"1282\":1}}],[\"要注意如果postprocessafterinstantiation返回的是false的话\",{\"1\":{\"1003\":1}}],[\"要点总结\",{\"1\":{\"1277\":1}}],[\"要怎么排\",{\"1\":{\"1270\":1}}],[\"要怎么做\",{\"1\":{\"1270\":1}}],[\"要如何处理线程安全问题\",{\"1\":{\"1236\":1}}],[\"要如何进行优化\",{\"0\":{\"175\":1,\"1257\":1}}],[\"要素\",{\"1\":{\"975\":1,\"976\":1,\"977\":1,\"978\":1}}],[\"要进行2000次的index\",{\"1\":{\"553\":1}}],[\"要进入young区域\",{\"1\":{\"406\":1}}],[\"要出现这样得情况\",{\"1\":{\"496\":1}}],[\"要想深入了解这其中的原理\",{\"1\":{\"1576\":1}}],[\"要想恢复数据\",{\"1\":{\"485\":1}}],[\"要想更深入的了解\",{\"1\":{\"317\":1}}],[\"要理解等主库位点方案\",{\"1\":{\"473\":1}}],[\"要理解这个现象\",{\"1\":{\"346\":1}}],[\"要判断备库无延迟\",{\"1\":{\"472\":1}}],[\"要从主库的master\",{\"1\":{\"467\":1}}],[\"要保证相同的先后顺序\",{\"1\":{\"465\":1}}],[\"要等第一组事务完全执行完成后\",{\"1\":{\"464\":1}}],[\"要在表t1上执行update\",{\"1\":{\"462\":1}}],[\"要解决热点表的并行复制问题\",{\"1\":{\"462\":1}}],[\"要解决这个问题\",{\"1\":{\"455\":1,\"472\":1,\"492\":1}}],[\"要用到上文中提到的server\",{\"1\":{\"455\":1}}],[\"要更新的是记录之间的\",{\"1\":{\"448\":1}}],[\"要给d=5的语句加上锁\",{\"1\":{\"447\":1}}],[\"要把最可能造成锁冲突\",{\"1\":{\"443\":1}}],[\"要考虑先暂停ddl\",{\"1\":{\"441\":1}}],[\"要及时drop掉\",{\"1\":{\"426\":1}}],[\"要先主动跳过这些错误\",{\"1\":{\"467\":1}}],[\"要先搜索索引a\",{\"1\":{\"401\":1}}],[\"要先判断有没有对应的查询权限\",{\"1\":{\"322\":1}}],[\"要么一起回滚\",{\"1\":{\"1655\":1}}],[\"要么一起提交\",{\"1\":{\"1655\":1}}],[\"要么描述的是中间操作\",{\"1\":{\"1621\":1}}],[\"要么就是late\",{\"1\":{\"1620\":1}}],[\"要么就是在原位置再移动2次幂的位置\",{\"1\":{\"1550\":1}}],[\"要么就是先写完redo\",{\"1\":{\"327\":1}}],[\"要么是将stream转化为集合\",{\"1\":{\"1609\":1}}],[\"要么是在原位置再移动2次幂的位置\",{\"1\":{\"1359\":1}}],[\"要么是某些操作执行得太慢\",{\"1\":{\"381\":1}}],[\"要么是某些操作被额外地重复了很多次\",{\"1\":{\"381\":1}}],[\"要么完全失败\",{\"1\":{\"1262\":1}}],[\"要么完全成功\",{\"1\":{\"1262\":1}}],[\"要么同时失败\",{\"1\":{\"1262\":1}}],[\"要么先记session\",{\"1\":{\"492\":1}}],[\"要么放弃继续查询\",{\"1\":{\"480\":1}}],[\"要么全部失败\",{\"1\":{\"432\":1}}],[\"要么全部成功\",{\"1\":{\"432\":1}}],[\"要么让子任务运行得更快\",{\"1\":{\"381\":1}}],[\"要么减少子任务的执行次数\",{\"1\":{\"381\":1}}],[\"要么消除其中一些子任务\",{\"1\":{\"381\":1}}],[\"要遵守最佳左前缀法则\",{\"1\":{\"370\":1}}],[\"要转成utf8mb4\",{\"1\":{\"368\":1}}],[\"要查询所有年份中7月份的交易记录总数\",{\"1\":{\"366\":1}}],[\"要换一个算法\",{\"1\":{\"355\":1}}],[\"要分成很多个临时文件\",{\"1\":{\"355\":1}}],[\"要回主键索引取4次数据\",{\"1\":{\"350\":1}}],[\"要求出集合中每一个元素的平方并打印\",{\"1\":{\"1609\":1}}],[\"要求映射种的key是不可变对象\",{\"1\":{\"1544\":1}}],[\"要求给表名加固定的后缀\",{\"1\":{\"487\":1}}],[\"要求按照b\",{\"1\":{\"348\":1}}],[\"要求建表语句里面一定要有自增主键\",{\"1\":{\"335\":1}}],[\"要读page2的时候\",{\"1\":{\"345\":1}}],[\"要插入\",{\"1\":{\"343\":1}}],[\"要多做的那一次\",{\"1\":{\"342\":1}}],[\"要根据市民的身份证号查询他的姓名\",{\"1\":{\"338\":1}}],[\"要写出具体的字段\",{\"1\":{\"330\":1}}],[\"要说明这个问题\",{\"1\":{\"327\":1}}],[\"要带上文档的\",{\"1\":{\"306\":1}}],[\"x最新完整教程\",{\"1\":{\"1986\":1}}],[\"x传入的是1\",{\"1\":{\"1554\":1}}],[\"x86\",{\"1\":{\"1479\":3}}],[\"x80\",{\"1\":{\"578\":1}}],[\"x打印出来\",{\"1\":{\"1453\":1}}],[\"xiao\",{\"1\":{\"1031\":1}}],[\"xid只需要不在同一个binlog文件中出现重复值接口\",{\"1\":{\"499\":1}}],[\"xid是由server层维护的\",{\"1\":{\"497\":1}}],[\"xid和innodb的trx\",{\"1\":{\"497\":1}}],[\"xid一定是唯一的\",{\"1\":{\"496\":1}}],[\"xid\",{\"0\":{\"496\":1}}],[\"xss\",{\"1\":{\"1664\":1}}],[\"xss512k\",{\"1\":{\"1664\":1}}],[\"xsd=org\",{\"1\":{\"1030\":1}}],[\"xsd\",{\"1\":{\"917\":1,\"918\":1,\"930\":2,\"953\":2,\"954\":2,\"1028\":6,\"1030\":1,\"1032\":1,\"1048\":1,\"1065\":2,\"1084\":1,\"1091\":2,\"1146\":1}}],[\"xsi\",{\"1\":{\"917\":1,\"918\":1,\"930\":2,\"953\":2,\"954\":2,\"1030\":1,\"1032\":1,\"1065\":1,\"1084\":1,\"1091\":1,\"1146\":1}}],[\"xsi=\",{\"1\":{\"917\":1,\"918\":1,\"930\":2,\"953\":2,\"954\":2,\"1030\":1,\"1032\":1,\"1065\":1,\"1084\":1,\"1091\":1,\"1146\":1}}],[\"xnode\",{\"1\":{\"645\":2}}],[\"x后默认使用lettuce来替换jedis\",{\"1\":{\"583\":1}}],[\"x后\",{\"1\":{\"583\":1}}],[\"xx开头\",{\"1\":{\"1453\":1}}],[\"xx\",{\"1\":{\"582\":2,\"583\":1,\"1453\":1,\"1455\":2,\"1484\":1,\"1485\":5,\"1487\":2,\"1664\":11,\"1669\":2}}],[\"xxx\",{\"1\":{\"349\":1,\"350\":3,\"351\":2,\"582\":2,\"583\":1,\"621\":1,\"1201\":2,\"1638\":1}}],[\"xxxxxxxyyyyyyzzzzz\",{\"1\":{\"341\":1}}],[\"xa2\",{\"1\":{\"578\":1}}],[\"xor\",{\"1\":{\"578\":1}}],[\"xg\",{\"1\":{\"574\":4}}],[\"xh\",{\"1\":{\"574\":4}}],[\"xmn\",{\"1\":{\"1664\":1}}],[\"xmn1024m\",{\"1\":{\"1664\":1}}],[\"xmx\",{\"1\":{\"1664\":1}}],[\"xmx2048m\",{\"1\":{\"1664\":1}}],[\"xms\",{\"1\":{\"1664\":1}}],[\"xms2048m\",{\"1\":{\"1664\":1}}],[\"xm\",{\"1\":{\"574\":4}}],[\"xml做了刷新缓存的操作\",{\"1\":{\"1219\":1}}],[\"xml中缓存仍然有效\",{\"1\":{\"1219\":1}}],[\"xml中\",{\"1\":{\"1219\":1}}],[\"xml中有大多数针对user表的操作\",{\"1\":{\"1219\":1}}],[\"xml文件\",{\"1\":{\"1217\":1,\"1218\":1}}],[\"xml框架移植性较差\",{\"1\":{\"1036\":1}}],[\"xml基于dom\",{\"1\":{\"1036\":1}}],[\"xml处理性能较差\",{\"1\":{\"1036\":1}}],[\"xmlbasedyamlpropertysourcedemo\",{\"1\":{\"1032\":1}}],[\"xmlbeandefinitionreader可以用来解析\",{\"1\":{\"1634\":1}}],[\"xmlbeandefinitionreader\",{\"0\":{\"1634\":1},\"1\":{\"921\":2,\"953\":6,\"954\":2,\"955\":2,\"961\":6,\"962\":2,\"963\":2,\"997\":4,\"1000\":4,\"1001\":4,\"1005\":4,\"1006\":4,\"1011\":4,\"1024\":1,\"1025\":1,\"1030\":2,\"1032\":2,\"1634\":4}}],[\"xml扩展的步骤\",{\"1\":{\"1030\":1}}],[\"xml解析\",{\"1\":{\"1025\":1}}],[\"xml解析器\",{\"1\":{\"995\":1}}],[\"xml资源beandefinition解析与注册\",{\"1\":{\"1025\":1}}],[\"xml资源的方式\",{\"0\":{\"1025\":1}}],[\"xml资源\",{\"1\":{\"1024\":1,\"1047\":1,\"1048\":1}}],[\"xml资源配置\",{\"1\":{\"1048\":1}}],[\"xml资源配置方式的示例\",{\"1\":{\"954\":1}}],[\"xml资源配置的方式\",{\"1\":{\"954\":1}}],[\"xml资源配置元信息\",{\"1\":{\"951\":1,\"953\":1,\"954\":1}}],[\"xml元素与beandefinition解析\",{\"1\":{\"1030\":2}}],[\"xml元素\",{\"0\":{\"1030\":1},\"1\":{\"1020\":1,\"1021\":1}}],[\"xmldependencyconstructorinjectiondemo\",{\"1\":{\"954\":1}}],[\"xmldependencysetterinjectiondemo\",{\"1\":{\"953\":1}}],[\"xmlresourcepath\",{\"1\":{\"953\":6,\"954\":2,\"955\":2,\"961\":6,\"962\":2,\"963\":2}}],[\"xml和java\",{\"1\":{\"930\":2}}],[\"xmlschema\",{\"1\":{\"917\":1,\"918\":1,\"930\":2,\"953\":2,\"954\":2,\"1030\":1,\"1032\":1,\"1065\":1,\"1084\":1,\"1091\":1,\"1146\":1}}],[\"xmlscriptbuilder\",{\"1\":{\"645\":1}}],[\"xmlns\",{\"1\":{\"917\":1,\"918\":2,\"930\":2,\"953\":2,\"954\":2,\"1030\":2,\"1032\":1,\"1065\":2,\"1084\":1,\"1091\":2,\"1146\":1}}],[\"xmlns=\",{\"1\":{\"917\":1,\"918\":1,\"930\":2,\"953\":2,\"954\":2,\"1030\":1,\"1032\":1,\"1065\":1,\"1084\":1,\"1091\":1,\"1146\":1}}],[\"xml编列\",{\"1\":{\"893\":1}}],[\"xml标签有哪些\",{\"0\":{\"830\":1}}],[\"xml配置文件来加深对tomcat架构的理解\",{\"1\":{\"1683\":1}}],[\"xml配置文件classpath路径\",{\"1\":{\"921\":1}}],[\"xml配置资源\",{\"1\":{\"1021\":1}}],[\"xml配置资源无法打开时\",{\"1\":{\"946\":1}}],[\"xml配置\",{\"1\":{\"931\":1,\"932\":1,\"933\":1,\"994\":1}}],[\"xml配置元信息\",{\"1\":{\"929\":1,\"1020\":2}}],[\"xml配置驱动实现\",{\"0\":{\"817\":1}}],[\"xml配置after\",{\"0\":{\"774\":1}}],[\"xml配置around\",{\"0\":{\"769\":1}}],[\"xml配置before\",{\"0\":{\"771\":1}}],[\"xml配置pointcut\",{\"0\":{\"766\":1}}],[\"xmltags\",{\"1\":{\"645\":1}}],[\"xml\",{\"0\":{\"1030\":1,\"1036\":1},\"1\":{\"273\":1,\"893\":1,\"917\":2,\"918\":3,\"919\":1,\"921\":1,\"930\":7,\"953\":7,\"954\":5,\"955\":1,\"961\":3,\"962\":1,\"963\":1,\"966\":2,\"986\":1,\"987\":1,\"988\":1,\"997\":1,\"1000\":1,\"1001\":2,\"1005\":4,\"1006\":2,\"1011\":2,\"1029\":1,\"1030\":2,\"1032\":2,\"1048\":1,\"1065\":2,\"1084\":2,\"1091\":1,\"1146\":2,\"1634\":1,\"1683\":1,\"1980\":1,\"1982\":1}}],[\"x这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分\",{\"1\":{\"557\":1}}],[\"xyz\",{\"1\":{\"554\":9}}],[\"x=\",{\"1\":{\"422\":1}}],[\"x+n\",{\"1\":{\"354\":1}}],[\"x\",{\"1\":{\"332\":1,\"352\":1,\"354\":2,\"355\":1,\"411\":1,\"416\":1,\"417\":1,\"422\":1,\"555\":1,\"897\":5,\"1130\":5,\"1479\":6,\"1480\":4,\"1485\":2,\"1502\":4,\"1503\":7,\"1506\":2,\"1554\":4,\"1593\":4,\"1605\":2}}],[\"x版本的es默认使用这种方式控制版本\",{\"1\":{\"306\":1}}],[\"7开始增加了这样一个接口\",{\"1\":{\"1619\":1}}],[\"7之后新增加的类\",{\"1\":{\"1599\":1}}],[\"7之后\",{\"1\":{\"1572\":1}}],[\"7之前的版本中\",{\"1\":{\"554\":1}}],[\"7以后\",{\"1\":{\"1572\":1}}],[\"7的stream对象\",{\"1\":{\"1607\":1}}],[\"7的分段技术\",{\"1\":{\"1554\":1}}],[\"7的实现\",{\"0\":{\"1553\":1}}],[\"7的实现那样重新计算hash\",{\"1\":{\"1550\":1}}],[\"7的示例如下\",{\"1\":{\"1551\":1}}],[\"7的源码\",{\"1\":{\"1548\":1}}],[\"7的并行复制策略里\",{\"1\":{\"465\":1}}],[\"7的并行复制策略\",{\"0\":{\"463\":1,\"465\":1}}],[\"75=1\",{\"1\":{\"1551\":1}}],[\"75是对空间和时间效率的平衡选择\",{\"1\":{\"1546\":1}}],[\"75\",{\"1\":{\"1546\":1,\"1551\":1,\"1554\":1,\"1555\":1}}],[\"75f\",{\"1\":{\"1475\":1,\"1551\":1}}],[\"7和jdk1\",{\"1\":{\"1545\":1}}],[\"7分段锁来实现\",{\"1\":{\"1475\":1}}],[\"7分段锁的设计\",{\"1\":{\"1369\":1}}],[\"79\",{\"1\":{\"610\":1}}],[\"797\",{\"1\":{\"528\":3}}],[\"7k\",{\"1\":{\"555\":1}}],[\"7中的concurrenthashmap扩容只是针对segment对象中的hashentry数组进行扩容\",{\"1\":{\"1553\":1}}],[\"7中的扩容过程\",{\"1\":{\"1550\":1}}],[\"7中rehash的时候\",{\"1\":{\"1550\":1}}],[\"7中\",{\"1\":{\"554\":1}}],[\"72\",{\"1\":{\"551\":1}}],[\"7这个版本里\",{\"1\":{\"549\":1}}],[\"7这个策略\",{\"1\":{\"465\":1}}],[\"7排1\",{\"1\":{\"544\":1,\"547\":1,\"553\":2}}],[\"7byte\",{\"1\":{\"542\":1}}],[\"70<\",{\"1\":{\"582\":1}}],[\"70\",{\"1\":{\"574\":2}}],[\"709\",{\"1\":{\"528\":1}}],[\"700\",{\"1\":{\"336\":1}}],[\"744\",{\"1\":{\"528\":1}}],[\"775\",{\"1\":{\"528\":2}}],[\"777\",{\"1\":{\"528\":1,\"530\":2}}],[\"76\",{\"1\":{\"1965\":1}}],[\"76735726\",{\"1\":{\"1551\":1}}],[\"767\",{\"1\":{\"528\":1}}],[\"768\",{\"1\":{\"528\":1}}],[\"7手册\",{\"1\":{\"499\":1}}],[\"7及之前的版本\",{\"1\":{\"490\":1}}],[\"7处理备库延迟的时候\",{\"1\":{\"465\":1}}],[\"7并行复制的思想是\",{\"1\":{\"465\":1}}],[\"7版本也提供了类似的功能\",{\"1\":{\"465\":1}}],[\"7版本开始\",{\"1\":{\"412\":1}}],[\"7支持了generated\",{\"1\":{\"417\":1}}],[\"7或更新的版本\",{\"1\":{\"318\":1}}],[\"7\",{\"1\":{\"306\":1,\"336\":1,\"350\":2,\"361\":1,\"366\":5,\"368\":1,\"378\":1,\"425\":2,\"465\":1,\"474\":1,\"519\":1,\"528\":3,\"549\":1,\"551\":1,\"553\":3,\"557\":1,\"570\":1,\"573\":1,\"574\":5,\"961\":2,\"1053\":2,\"1226\":1,\"1401\":1,\"1548\":1,\"1550\":2,\"1551\":5,\"1599\":2,\"1607\":2,\"1610\":1}}],[\"=0\",{\"1\":{\"1591\":1}}],[\"=16个字节\",{\"1\":{\"1484\":1}}],[\"=10100\",{\"1\":{\"525\":1}}],[\"=a\",{\"1\":{\"1479\":2}}],[\"=起始地址+\",{\"1\":{\"1475\":1}}],[\"==present\",{\"1\":{\"1368\":1,\"1557\":1}}],[\"==null\",{\"1\":{\"1368\":1,\"1557\":1}}],[\"=======================\",{\"1\":{\"1612\":1}}],[\"====================================\",{\"1\":{\"1617\":1}}],[\"==================================\",{\"1\":{\"1603\":1,\"1604\":1}}],[\"============================\",{\"1\":{\"944\":1}}],[\"==================\",{\"1\":{\"1612\":1}}],[\"================\",{\"1\":{\"1592\":1}}],[\"=============\",{\"1\":{\"1005\":1,\"1387\":1}}],[\"==这样的话是永久的\",{\"1\":{\"610\":1}}],[\"==真实开发中应该在从机的配置文件中进行配置\",{\"1\":{\"610\":1}}],[\"==\",{\"1\":{\"542\":1,\"645\":4,\"918\":2,\"928\":2,\"930\":2,\"936\":2,\"952\":2,\"955\":1,\"957\":2,\"963\":10,\"973\":8,\"989\":1,\"997\":4,\"998\":1,\"1006\":1,\"1007\":1,\"1008\":2,\"1027\":2,\"1045\":4,\"1055\":1,\"1148\":3,\"1149\":1,\"1162\":1,\"1165\":1,\"1167\":1,\"1181\":4,\"1182\":2,\"1191\":2,\"1193\":2,\"1227\":1,\"1288\":3,\"1347\":1,\"1388\":2,\"1404\":3,\"1432\":2,\"1476\":2,\"1479\":4,\"1480\":2,\"1502\":4,\"1503\":5,\"1548\":1,\"1549\":10,\"1550\":7,\"1553\":4,\"1554\":20,\"1594\":1,\"1599\":8,\"1609\":1,\"1612\":2,\"1614\":2,\"1618\":2,\"1619\":1,\"1620\":2,\"1622\":3,\"1623\":1,\"1647\":18,\"1648\":8,\"1650\":2,\"1654\":1,\"1655\":2,\"1658\":1,\"1663\":2,\"1689\":1}}],[\"=film1\",{\"1\":{\"506\":1}}],[\"=film0\",{\"1\":{\"506\":1}}],[\"=或者<>的时候无法使用索引会导致全表扫描\",{\"1\":{\"369\":1}}],[\"=convert\",{\"1\":{\"368\":1}}],[\"=7\",{\"1\":{\"366\":1}}],[\"=\",{\"1\":{\"306\":1,\"330\":2,\"335\":3,\"336\":1,\"338\":1,\"341\":1,\"342\":1,\"346\":1,\"349\":2,\"352\":1,\"353\":1,\"354\":2,\"355\":1,\"361\":5,\"366\":4,\"367\":2,\"368\":8,\"370\":11,\"371\":4,\"372\":5,\"373\":6,\"374\":2,\"376\":4,\"377\":21,\"378\":41,\"384\":1,\"390\":3,\"393\":2,\"394\":5,\"400\":3,\"401\":1,\"402\":1,\"404\":4,\"405\":1,\"407\":3,\"409\":2,\"414\":2,\"416\":1,\"419\":3,\"422\":5,\"424\":6,\"428\":2,\"433\":1,\"435\":3,\"438\":1,\"446\":1,\"447\":4,\"448\":1,\"454\":1,\"459\":1,\"462\":3,\"468\":1,\"476\":6,\"478\":2,\"479\":2,\"481\":2,\"485\":1,\"489\":1,\"498\":1,\"504\":1,\"506\":6,\"509\":2,\"518\":2,\"520\":3,\"522\":1,\"525\":1,\"534\":2,\"535\":2,\"536\":1,\"537\":1,\"542\":1,\"544\":2,\"547\":2,\"548\":8,\"549\":11,\"551\":2,\"553\":4,\"555\":7,\"556\":2,\"558\":5,\"559\":2,\"571\":1,\"582\":6,\"583\":2,\"603\":1,\"645\":10,\"909\":3,\"917\":12,\"918\":6,\"919\":3,\"921\":10,\"922\":3,\"927\":4,\"928\":13,\"929\":4,\"930\":12,\"931\":4,\"933\":3,\"934\":1,\"936\":4,\"940\":3,\"941\":4,\"943\":6,\"944\":4,\"946\":5,\"952\":1,\"953\":17,\"954\":5,\"955\":6,\"956\":2,\"957\":3,\"961\":32,\"962\":6,\"963\":64,\"964\":12,\"965\":3,\"967\":5,\"973\":2,\"975\":2,\"977\":1,\"978\":5,\"985\":23,\"989\":17,\"994\":9,\"995\":9,\"996\":6,\"997\":22,\"998\":3,\"1000\":12,\"1001\":9,\"1002\":1,\"1003\":7,\"1005\":21,\"1006\":11,\"1007\":11,\"1008\":6,\"1009\":2,\"1011\":8,\"1012\":6,\"1019\":7,\"1021\":2,\"1022\":16,\"1023\":2,\"1025\":1,\"1027\":8,\"1029\":3,\"1030\":4,\"1031\":5,\"1032\":11,\"1040\":5,\"1041\":5,\"1043\":6,\"1044\":1,\"1045\":2,\"1053\":13,\"1055\":6,\"1056\":3,\"1061\":3,\"1063\":7,\"1064\":7,\"1065\":5,\"1072\":9,\"1075\":1,\"1082\":5,\"1084\":8,\"1091\":5,\"1099\":6,\"1100\":6,\"1103\":2,\"1108\":2,\"1112\":1,\"1113\":2,\"1116\":3,\"1119\":1,\"1120\":1,\"1121\":3,\"1123\":6,\"1124\":2,\"1134\":3,\"1135\":5,\"1136\":4,\"1137\":2,\"1138\":3,\"1139\":9,\"1146\":2,\"1148\":4,\"1149\":4,\"1156\":8,\"1157\":2,\"1162\":3,\"1163\":2,\"1166\":11,\"1167\":6,\"1168\":3,\"1170\":3,\"1171\":1,\"1174\":4,\"1175\":3,\"1181\":5,\"1182\":6,\"1184\":8,\"1191\":2,\"1192\":1,\"1193\":2,\"1194\":1,\"1226\":7,\"1227\":1,\"1288\":4,\"1347\":5,\"1351\":2,\"1357\":1,\"1365\":3,\"1368\":1,\"1387\":3,\"1388\":2,\"1404\":17,\"1412\":3,\"1432\":7,\"1475\":4,\"1476\":3,\"1479\":13,\"1480\":9,\"1482\":2,\"1483\":17,\"1484\":5,\"1485\":2,\"1486\":1,\"1487\":5,\"1498\":6,\"1502\":13,\"1503\":31,\"1506\":7,\"1517\":13,\"1521\":3,\"1528\":1,\"1531\":3,\"1533\":3,\"1534\":5,\"1535\":5,\"1548\":3,\"1549\":20,\"1550\":46,\"1551\":6,\"1553\":19,\"1554\":53,\"1557\":1,\"1573\":23,\"1574\":46,\"1575\":23,\"1587\":3,\"1588\":2,\"1591\":13,\"1592\":5,\"1593\":7,\"1594\":1,\"1595\":7,\"1597\":2,\"1598\":14,\"1599\":8,\"1600\":9,\"1601\":1,\"1602\":1,\"1603\":14,\"1604\":11,\"1605\":11,\"1606\":2,\"1607\":11,\"1608\":13,\"1609\":17,\"1610\":12,\"1611\":3,\"1612\":8,\"1613\":15,\"1614\":18,\"1615\":15,\"1616\":12,\"1617\":19,\"1618\":36,\"1619\":7,\"1620\":33,\"1621\":7,\"1622\":22,\"1623\":4,\"1632\":2,\"1633\":2,\"1634\":3,\"1635\":2,\"1638\":3,\"1639\":2,\"1640\":2,\"1644\":1,\"1645\":8,\"1646\":4,\"1647\":112,\"1648\":64,\"1649\":1,\"1650\":14,\"1651\":11,\"1652\":1,\"1654\":36,\"1655\":36,\"1658\":5,\"1663\":7}}],[\"还提供了\",{\"1\":{\"1658\":1}}],[\"还提供了国际化\",{\"1\":{\"1636\":1}}],[\"还提供了一些额外的信息\",{\"1\":{\"1623\":1}}],[\"还涉及到了另外一个及其重要的类sink\",{\"1\":{\"1622\":1}}],[\"还更差一些\",{\"1\":{\"1565\":1}}],[\"还没有的话\",{\"1\":{\"1647\":1}}],[\"还没有收到一个完整的udp包\",{\"1\":{\"1563\":1}}],[\"还没有来得及的写数据库\",{\"1\":{\"1286\":1}}],[\"还没有使用\",{\"1\":{\"319\":1}}],[\"还包括java\",{\"1\":{\"1085\":1}}],[\"还包含了数据和日志在逻辑上的一致性\",{\"1\":{\"447\":1}}],[\"还在打印集合中的元素\",{\"1\":{\"1617\":1}}],[\"还在在我们之前的例子上稍作修改\",{\"1\":{\"1003\":1}}],[\"还在这个数据基础上做了操作\",{\"1\":{\"532\":1}}],[\"还单独保存了beanname\",{\"1\":{\"975\":1}}],[\"还负责把写命令同步给从节点\",{\"1\":{\"618\":1}}],[\"还给行两边的空袭\",{\"1\":{\"448\":1}}],[\"还同时加了7个间隙锁\",{\"1\":{\"448\":1}}],[\"还要经过优化器的处理\",{\"1\":{\"514\":1}}],[\"还要主动去主库执行show\",{\"1\":{\"474\":1}}],[\"还要有地方保存表数据\",{\"1\":{\"412\":1}}],[\"还要把值取出来再判断以下\",{\"1\":{\"399\":1}}],[\"还要写到磁盘上\",{\"1\":{\"334\":1}}],[\"还不只是丢失更新的问题\",{\"1\":{\"397\":1}}],[\"还会比较有成就感\",{\"1\":{\"1993\":1}}],[\"还会导致性能下降\",{\"1\":{\"1485\":1}}],[\"还会降低系统的稳定性\",{\"1\":{\"1407\":1}}],[\"还会造成一段时间内服务不可用\",{\"1\":{\"619\":1}}],[\"还会影响并发插入的性能\",{\"1\":{\"492\":1}}],[\"还会返回一些其他结果\",{\"1\":{\"473\":1}}],[\"还会对系统有什么影响呢\",{\"1\":{\"406\":1}}],[\"还会为服务器带来额外的i\",{\"1\":{\"385\":1}}],[\"还会判断这个语句本身要扫描的行数\",{\"1\":{\"347\":1}}],[\"还需要学习设计模式\",{\"1\":{\"1992\":1}}],[\"还需要命令其他从节点去复制新的主节点\",{\"1\":{\"621\":1}}],[\"还需要做两件事儿\",{\"1\":{\"549\":1}}],[\"还需要根据成本和磁盘空间资源\",{\"1\":{\"485\":1}}],[\"还需要专门清理中间过程中生成的数据表\",{\"1\":{\"410\":1}}],[\"还需要合理的设计查询\",{\"1\":{\"381\":1}}],[\"还需要经过优化器的处理\",{\"1\":{\"321\":1}}],[\"还可能会导致覆盖索引失效\",{\"1\":{\"351\":1}}],[\"还可以很方便的协作开发\",{\"1\":{\"1981\":1}}],[\"还可以阅读\",{\"1\":{\"1969\":1}}],[\"还可以通过\",{\"1\":{\"1654\":1}}],[\"还可以通过sequential\",{\"1\":{\"1619\":1}}],[\"还可以通过注解的方式\",{\"1\":{\"1123\":1}}],[\"还可以拼接前缀和后缀\",{\"1\":{\"1616\":1}}],[\"还可以调用有参数的构造方法\",{\"1\":{\"1606\":1}}],[\"还可以统一id分配\",{\"1\":{\"1329\":1}}],[\"还可以大大减少删除时锁的持有时间\",{\"1\":{\"393\":1}}],[\"还可以更进一步\",{\"1\":{\"356\":1}}],[\"还可以将语句修改为\",{\"1\":{\"348\":1}}],[\"还可以使用逗号分隔\",{\"1\":{\"1616\":1}}],[\"还可以使用collector中的of方法\",{\"1\":{\"1615\":1}}],[\"还可以使用自旋来进行优化\",{\"1\":{\"1485\":1}}],[\"还可以使用set\",{\"1\":{\"438\":1}}],[\"还可以使用\",{\"1\":{\"306\":1,\"961\":1}}],[\"还是比较吃力的\",{\"1\":{\"1972\":1}}],[\"还是回到最开始的入口这里\",{\"1\":{\"1621\":1}}],[\"还是stream的方式更加简洁明了\",{\"1\":{\"1611\":1}}],[\"还是返回optional对象\",{\"1\":{\"1610\":1}}],[\"还是无法理解lambda表达式到底可以帮我们做哪些事情\",{\"1\":{\"1607\":1}}],[\"还是myinterface2中的默认方法mymethod\",{\"1\":{\"1607\":1}}],[\"还是只有一个抽象方法\",{\"1\":{\"1595\":1}}],[\"还是只需要\",{\"1\":{\"1509\":1}}],[\"还是代码的执行速度上来看\",{\"1\":{\"1592\":1}}],[\"还是引入零拷贝之后\",{\"1\":{\"1585\":1}}],[\"还是\",{\"1\":{\"1479\":1}}],[\"还是先写数据库\",{\"1\":{\"1285\":1}}],[\"还是运行时\",{\"0\":{\"1105\":1}}],[\"还是操作userholder类\",{\"1\":{\"1009\":1}}],[\"还是对我们的myinstantiationawarebeanpostprocessor进行添加\",{\"1\":{\"1008\":1}}],[\"还是使用传统的面向对象的编程方式\",{\"1\":{\"1591\":1}}],[\"还是使用的是同一个read\",{\"1\":{\"542\":1}}],[\"还是使用表t1执行如下sql语句\",{\"1\":{\"416\":1}}],[\"还是可以间接找到它的\",{\"1\":{\"1561\":1}}],[\"还是可以加速查询的效率\",{\"1\":{\"404\":1}}],[\"还是可能达到这个上限的\",{\"1\":{\"495\":1}}],[\"还是4294967295\",{\"1\":{\"494\":1}}],[\"还是这个语句\",{\"1\":{\"492\":1}}],[\"还是把临时库接到备库上\",{\"1\":{\"485\":1}}],[\"还是要算进并发线程的计数的\",{\"1\":{\"476\":1}}],[\"还是要把两张表放在一起\",{\"1\":{\"461\":1}}],[\"还是会修改成功\",{\"1\":{\"1479\":1}}],[\"还是会存在缓存层和存储层的数据会有一段时间窗口的不一致\",{\"1\":{\"627\":1}}],[\"还是会出现同一个binlog里面出现相同xid的场景\",{\"1\":{\"496\":1}}],[\"还是会出现过期读\",{\"1\":{\"471\":1}}],[\"还是会继续等待\",{\"1\":{\"481\":1}}],[\"还是会很大\",{\"1\":{\"444\":1}}],[\"还是3天后用来恢复这个库的备库\",{\"1\":{\"454\":1}}],[\"还是阻止不了新插入的记录\",{\"1\":{\"447\":1}}],[\"还是阻止不了id=1这一行的插入和更新呢\",{\"1\":{\"447\":1}}],[\"还是应该使用ftwrl\",{\"1\":{\"438\":1}}],[\"还是一定要进行排序的操作\",{\"1\":{\"418\":1}}],[\"还是用有索引的临时表\",{\"1\":{\"407\":1}}],[\"还是用自增字段做主键呢\",{\"1\":{\"335\":1}}],[\"还是按照name字段的值递增排序的\",{\"1\":{\"356\":1}}],[\"还是以卖家发布商品为例\",{\"1\":{\"471\":1}}],[\"还是以后用binlog克隆\",{\"1\":{\"447\":1}}],[\"还是以市民表为例\",{\"1\":{\"356\":1}}],[\"还是以我们前面举例用过的市民表为例\",{\"1\":{\"353\":1}}],[\"还是上面根据身份证号查询名字的例子\",{\"1\":{\"333\":1}}],[\"还有阿里开源dubbo\",{\"1\":{\"1990\":1}}],[\"还有后端\",{\"1\":{\"1978\":1}}],[\"还有request\",{\"1\":{\"1647\":1}}],[\"还有可能会出现如下报错\",{\"1\":{\"1617\":1}}],[\"还有很多的其他的函数式接口\",{\"1\":{\"1601\":1}}],[\"还有\",{\"1\":{\"1599\":1,\"1992\":1}}],[\"还有两个默认方法\",{\"1\":{\"1598\":1}}],[\"还有两种场景会让一个没有提交的事务的redo\",{\"1\":{\"451\":1}}],[\"还有最后一段话\",{\"1\":{\"1594\":1}}],[\"还有系统类加载器\",{\"1\":{\"1438\":1}}],[\"还有用\",{\"1\":{\"1435\":1}}],[\"还有编译器\",{\"1\":{\"1337\":1}}],[\"还有针对user单表的操作\",{\"1\":{\"1219\":1}}],[\"还有我们之前提到过的\",{\"1\":{\"1133\":1}}],[\"还有提供\",{\"1\":{\"921\":1}}],[\"还有数据库隐式定义的db\",{\"1\":{\"542\":1}}],[\"还有数据一致性的问题\",{\"1\":{\"447\":1}}],[\"还有意向锁\",{\"1\":{\"533\":1}}],[\"还有由于io压力过大\",{\"1\":{\"481\":1}}],[\"还有其他唯一索引\",{\"1\":{\"465\":1}}],[\"还有唯一索引a\",{\"1\":{\"462\":1}}],[\"还有一些连接池相关的配置\",{\"1\":{\"583\":1}}],[\"还有一种有序的遍历\",{\"1\":{\"1623\":1}}],[\"还有一种情况是\",{\"1\":{\"480\":1}}],[\"还有一种架构是\",{\"1\":{\"469\":1}}],[\"还有一种叫做mixed\",{\"1\":{\"454\":1}}],[\"还有一个终止阶段\",{\"1\":{\"1623\":1}}],[\"还有一个例子\",{\"1\":{\"1608\":1}}],[\"还有一个default默认方法andthen\",{\"1\":{\"1594\":1}}],[\"还有一个\",{\"1\":{\"454\":1}}],[\"还有一个关键的参数λ\",{\"1\":{\"403\":1}}],[\"还有一个订单数据的索引\",{\"1\":{\"303\":1}}],[\"还有什么方式可以保障线程安全\",{\"0\":{\"87\":1,\"1416\":1}}],[\"在面试之前将常考的题目解题思路和代码印在脑子里\",{\"1\":{\"1972\":1}}],[\"在面对其他任何编程语言的函数式编程时\",{\"1\":{\"1591\":1}}],[\"在容器中获取到的都是一个标准的servletrequest对象\",{\"1\":{\"1687\":1}}],[\"在容器的安全上\",{\"1\":{\"1554\":1}}],[\"在加载阶段会在内存中生成一个代表这个类的java\",{\"1\":{\"1663\":1}}],[\"在硬盘上查找并通过io读入字节码文件\",{\"1\":{\"1663\":1}}],[\"在解析的时候\",{\"1\":{\"1652\":1}}],[\"在解决了一些问题的同时\",{\"1\":{\"1270\":1}}],[\"在类加载检查通过后\",{\"1\":{\"1667\":1}}],[\"在类似数组的数据结构里存放局部变量\",{\"1\":{\"1664\":1}}],[\"在类\",{\"1\":{\"1652\":1}}],[\"在类型转换上有优势\",{\"1\":{\"912\":1}}],[\"在推断构造方法之后\",{\"1\":{\"1650\":1}}],[\"在第二次调用getbean方法的时候就会触发\",{\"1\":{\"1648\":1}}],[\"在第一次垃圾收集时就会被回收\",{\"1\":{\"1434\":1}}],[\"在第一组事务提交完成的时候\",{\"1\":{\"464\":1}}],[\"在第一张图中\",{\"1\":{\"340\":1}}],[\"在属性或set方法上使用了\",{\"1\":{\"1648\":1}}],[\"在单例池中查找单例bean\",{\"1\":{\"1647\":1}}],[\"在单体应用中\",{\"1\":{\"1304\":1}}],[\"在如下配置中\",{\"1\":{\"1645\":2}}],[\"在可用的任意的顺序\",{\"1\":{\"1623\":1}}],[\"在可重复读隔离级别下\",{\"1\":{\"446\":1}}],[\"在可重复读的隔离级别下\",{\"1\":{\"433\":1,\"537\":1,\"542\":1}}],[\"在调用完end方法\",{\"1\":{\"1623\":1}}],[\"在调用wait方法之后\",{\"1\":{\"1381\":1}}],[\"在所有的beandefinition找到符合这个类型的所有bean的名称\",{\"1\":{\"1648\":1}}],[\"在所有的数据发送完成之后\",{\"1\":{\"1623\":1}}],[\"在所有的元素都遍历之后\",{\"1\":{\"1620\":1}}],[\"在首次调用sink的accept之前必须先调用begin方法来通知数据即将到达\",{\"1\":{\"1623\":1}}],[\"在流消费之后都要置为空\",{\"1\":{\"1621\":1}}],[\"在流准备进行计算的时候是有效的\",{\"1\":{\"1621\":1}}],[\"在管道被消费之后\",{\"1\":{\"1621\":1}}],[\"在管道被消费之前\",{\"1\":{\"1621\":2}}],[\"在管程的发展史上\",{\"1\":{\"1483\":1}}],[\"在分割之前estimatesize方法所估算的元的大小的值\",{\"1\":{\"1620\":1}}],[\"在合适的时候应该被重写\",{\"1\":{\"1620\":1}}],[\"在当前的线程是以串行的方式执行\",{\"1\":{\"1620\":1}}],[\"在遍历开始之后无法分割\",{\"1\":{\"1620\":1}}],[\"在遍历的时候会自增\",{\"1\":{\"1620\":1}}],[\"在遍历已经开始之后就可能发生一些不确定的行为\",{\"1\":{\"1620\":1}}],[\"在构造之后增加不确定的行为的可能\",{\"1\":{\"1620\":1}}],[\"在正式开始介绍之前\",{\"1\":{\"1619\":1}}],[\"在正式进入stream源码分析之前\",{\"1\":{\"1614\":1}}],[\"在了解了分割迭代器的相关内容之后\",{\"1\":{\"1621\":1}}],[\"在了解了有关收集器的内容之后\",{\"1\":{\"1618\":1}}],[\"在了解mvcc多版本并发控制之前\",{\"1\":{\"541\":1}}],[\"在整个方法的返回类型中\",{\"1\":{\"1618\":1}}],[\"在整个过程中\",{\"1\":{\"350\":1}}],[\"在查看之前首先需要了解一个jdk中新增加的方法\",{\"1\":{\"1618\":1}}],[\"在查询时按照上面的规则查到对应的记录如果delete\",{\"1\":{\"542\":1}}],[\"在查询表optimizer\",{\"1\":{\"354\":1}}],[\"在完整的理解了收集器相关的概念之后\",{\"1\":{\"1616\":1}}],[\"在完成这些任务的时候\",{\"1\":{\"381\":1}}],[\"在完成经典的tcp握手后\",{\"1\":{\"318\":1}}],[\"在函数式编程中非常的常见\",{\"1\":{\"1614\":1}}],[\"在长时间的练习和记忆中\",{\"1\":{\"1613\":1}}],[\"在并行情况下使用spliterator\",{\"1\":{\"1620\":1}}],[\"在并行流中可能会多次调用\",{\"1\":{\"1608\":1}}],[\"在并发环境下同时修改\",{\"1\":{\"1519\":1}}],[\"在并发处理计算型任务时有着显著的优势\",{\"1\":{\"1514\":1}}],[\"在并发程度高的时候\",{\"1\":{\"1509\":1}}],[\"在并发读写数据库时\",{\"1\":{\"541\":1}}],[\"在并发场景下\",{\"1\":{\"451\":1}}],[\"在初步了解了sream给我们来了些什么之后\",{\"1\":{\"1608\":1}}],[\"在初始化的时候用户可能会自定义\",{\"1\":{\"1554\":1}}],[\"在初始化过程中\",{\"1\":{\"1237\":1}}],[\"在初始化后回调\",{\"1\":{\"985\":1}}],[\"在接下来的章节中\",{\"1\":{\"1607\":1}}],[\"在前面的章节我们花费了不少的章节整理了lambda表达式的相关特性\",{\"1\":{\"1607\":1}}],[\"在前面我们了解了函数式接口的概念之后\",{\"1\":{\"1595\":1}}],[\"在方法引用的最后\",{\"1\":{\"1607\":1}}],[\"在方法区中常量引用的对象\",{\"1\":{\"1438\":1}}],[\"在方法区中类静态属性引用的对象\",{\"1\":{\"1438\":1}}],[\"在此基础上\",{\"1\":{\"1600\":1}}],[\"在回答这个问题之前\",{\"1\":{\"1593\":1}}],[\"在回滚日志里面就会有类似下面的记录\",{\"1\":{\"434\":1}}],[\"在创建线程方面可以简化写法\",{\"1\":{\"1591\":1}}],[\"在创建事务的一致性视图时\",{\"1\":{\"497\":1}}],[\"在以往的java中\",{\"1\":{\"1593\":1}}],[\"在以往的使用传统面向对象的编程中\",{\"1\":{\"1591\":1}}],[\"在以上的例子中\",{\"1\":{\"413\":1}}],[\"在linux系统中\",{\"1\":{\"1579\":1}}],[\"在linux\",{\"1\":{\"1576\":1,\"1582\":1}}],[\"在linux上一般为1024\",{\"1\":{\"1569\":1}}],[\"在linux操作系统中\",{\"1\":{\"1530\":1}}],[\"在io多路复用模型中\",{\"1\":{\"1565\":1}}],[\"在initdestroyannotationbeanpostprocessor中也可以看到postprocessmergedbeandefinition这个方法\",{\"1\":{\"966\":1}}],[\"在innodb逻辑里\",{\"1\":{\"495\":1}}],[\"在innodb事务中\",{\"1\":{\"443\":1}}],[\"在innodb里\",{\"1\":{\"335\":1,\"497\":1}}],[\"在innodb中\",{\"1\":{\"335\":2,\"342\":1,\"420\":1,\"444\":1,\"476\":1}}],[\"在程序设计中\",{\"1\":{\"1561\":1}}],[\"在程序设计语言里面\",{\"1\":{\"368\":1}}],[\"在底层就是在hashmap的基础上包了一层\",{\"1\":{\"1557\":1}}],[\"在存储结构上\",{\"1\":{\"1554\":1}}],[\"在存储引擎层执行具体的数据存取操作\",{\"1\":{\"557\":1}}],[\"在扩容的时候也是这样的\",{\"1\":{\"1553\":1}}],[\"在下图中\",{\"1\":{\"1550\":1}}],[\"在下次查询需要访问这个数据页的时候\",{\"1\":{\"343\":1}}],[\"在旧数组中同一条entry链上的元素\",{\"1\":{\"1550\":1}}],[\"在向hashmap对象中不断地添加元素\",{\"1\":{\"1550\":1}}],[\"在红黑树中执行插入操作\",{\"1\":{\"1549\":1}}],[\"在数组定义好长度之后\",{\"1\":{\"1546\":1}}],[\"在数据库中都是以key\",{\"1\":{\"569\":1}}],[\"在数据库中\",{\"1\":{\"533\":1}}],[\"在数据库中保存计数\",{\"0\":{\"398\":1}}],[\"在数据库里的最终结果还是\",{\"1\":{\"447\":1}}],[\"在数据库里面的结果是\",{\"1\":{\"447\":1}}],[\"在数据库里面\",{\"1\":{\"347\":1}}],[\"在数据库正常关闭\",{\"1\":{\"343\":1}}],[\"在循环内部使用thread\",{\"1\":{\"1520\":1}}],[\"在稳定性要求特别高的系统中\",{\"1\":{\"1519\":1}}],[\"在考虑这一点的时候\",{\"1\":{\"1509\":1}}],[\"在它内部\",{\"1\":{\"1498\":2}}],[\"在读多写少的情况下\",{\"1\":{\"1498\":1}}],[\"在没有写操作的时候\",{\"1\":{\"1498\":1}}],[\"在项目启动时即可输出jvm的默认参数值\",{\"1\":{\"1485\":1}}],[\"在64位的操作系统的内存中占几8\",{\"1\":{\"1484\":1}}],[\"在获取锁时\",{\"1\":{\"1483\":1}}],[\"在操作系统领域一般翻译为\",{\"1\":{\"1483\":1}}],[\"在两种情况下会使用\",{\"1\":{\"1480\":1}}],[\"在两边插入或者改动值\",{\"1\":{\"571\":1}}],[\"在多线程使用场景中\",{\"1\":{\"1551\":1}}],[\"在多线程开发中\",{\"1\":{\"1530\":1}}],[\"在多个线程对共享资源读写操作时发生指令交错\",{\"1\":{\"1482\":1}}],[\"在多个表负载均衡的场景里应用效果很好\",{\"1\":{\"461\":1}}],[\"在多处理器环境下\",{\"1\":{\"1479\":1}}],[\"在各单个线程访问时的排他性\",{\"1\":{\"1477\":1}}],[\"在各个分库上执行select\",{\"1\":{\"411\":1}}],[\"在共享内存多处理器系统中\",{\"1\":{\"1474\":1}}],[\"在新的处理器中\",{\"1\":{\"1473\":1}}],[\"在新主库a\",{\"1\":{\"467\":1}}],[\"在变量被修改后\",{\"1\":{\"1473\":1}}],[\"在变量读取前从主内存刷新变量值这种依赖主内存作为传递没接的方法来实现可见性的\",{\"1\":{\"1471\":1}}],[\"在永久代中\",{\"1\":{\"1457\":1}}],[\"在元空间中\",{\"1\":{\"1457\":1}}],[\"在收集结束的时候\",{\"1\":{\"1448\":1}}],[\"在g1当中采用satb的方式来避免错标和漏标的情况\",{\"1\":{\"1442\":1}}],[\"在gtid模式下\",{\"1\":{\"468\":2}}],[\"在本地方法栈中jni\",{\"1\":{\"1438\":1}}],[\"在虚拟机栈\",{\"1\":{\"1438\":1}}],[\"在针对对象进行垃圾收集的时候\",{\"1\":{\"1434\":1}}],[\"在hierarchicalbeanfactory和singletonbeanregistry的基础上\",{\"1\":{\"1636\":1}}],[\"在hashmap的底层存储实现上是存储在\",{\"1\":{\"1546\":1}}],[\"在hashmap中会调用方法二来计算对象应该保存在table数组的哪个索引处\",{\"1\":{\"1548\":1}}],[\"在hashmap中\",{\"1\":{\"1358\":1,\"1546\":1}}],[\"在http的基础上增加了一系列的安全机制\",{\"1\":{\"1424\":1}}],[\"在windows下\",{\"1\":{\"1423\":1}}],[\"在dcl中\",{\"1\":{\"1388\":1}}],[\"在defaultsingletonbeanregistry\",{\"1\":{\"1182\":1}}],[\"在运行期间\",{\"1\":{\"1617\":1}}],[\"在运行判断任意一个类所具有的成员变量和方法\",{\"1\":{\"1350\":1}}],[\"在运行时判断任意一个类所具有的成员变量和方法\",{\"1\":{\"1559\":1}}],[\"在运行时判断任意一个对象所属的类型\",{\"1\":{\"1350\":1,\"1559\":1}}],[\"在运行时调用任意一个对象的方法\",{\"1\":{\"1350\":1,\"1559\":1}}],[\"在运行时构造任意一个类的对象\",{\"1\":{\"1350\":1,\"1559\":1}}],[\"在任何情况下编译器都不会提供默认的方法调用\",{\"1\":{\"1346\":1}}],[\"在任意一个socket可读\",{\"1\":{\"1292\":1}}],[\"在最终构造返回的accumulator的时候\",{\"1\":{\"1618\":1}}],[\"在最新版本的饿源码当中\",{\"1\":{\"1333\":1}}],[\"在最后的同一个时刻\",{\"1\":{\"396\":1}}],[\"在其他编程语言中\",{\"1\":{\"1593\":1}}],[\"在其他编程语言里\",{\"1\":{\"1533\":1}}],[\"在其他的日志文件当中\",{\"1\":{\"1330\":1,\"1331\":1}}],[\"在其他条件都相同的时候\",{\"1\":{\"392\":1}}],[\"在普通集群中\",{\"1\":{\"1328\":1}}],[\"在2004年\",{\"1\":{\"1309\":1}}],[\"在该语句之后执行的命令都将被视为事务之内的操作\",{\"1\":{\"1297\":1}}],[\"在内存中操作对应的数据\",{\"1\":{\"1292\":1}}],[\"在于setnx和expire两个指令无法保证原子性\",{\"1\":{\"1288\":1}}],[\"在高并发场景下会成为性能瓶颈\",{\"1\":{\"1502\":1}}],[\"在高并发场景下\",{\"1\":{\"1286\":1,\"1288\":1}}],[\"在高并发的场景下\",{\"1\":{\"1203\":1}}],[\"在原有的统一失效时间基础上\",{\"1\":{\"1284\":1}}],[\"在原有文档上更新\",{\"1\":{\"306\":1}}],[\"在系统启动或热点数据即将过期之前\",{\"1\":{\"1283\":1}}],[\"在系统架构中引入二级缓存\",{\"1\":{\"1283\":1}}],[\"在系统库\",{\"1\":{\"477\":1}}],[\"在o\",{\"1\":{\"1265\":1}}],[\"在os层面上的零拷贝技术通常指避免在用户态和内核态之间来回拷贝数据\",{\"1\":{\"1231\":1}}],[\"在修改时加排他锁\",{\"1\":{\"1261\":1}}],[\"在更新数据那一刻校验数据\",{\"1\":{\"1248\":1}}],[\"在控制台输出了\",{\"1\":{\"1610\":1}}],[\"在控制器中不要携带数据\",{\"1\":{\"1240\":1}}],[\"在控制层先进行拦截校验\",{\"1\":{\"627\":1}}],[\"在发生异常时synchronized会自动释放锁\",{\"1\":{\"1495\":1}}],[\"在发生慢查询的时候\",{\"1\":{\"381\":1}}],[\"在发现有循环依赖时\",{\"1\":{\"1237\":1}}],[\"在后续分析源码的时候就可以看到\",{\"1\":{\"1612\":1}}],[\"在后续的文章中\",{\"1\":{\"1593\":1}}],[\"在后续的每次gc中\",{\"1\":{\"1436\":1}}],[\"在后续的依赖注入过程中\",{\"1\":{\"1237\":1}}],[\"在后面源代码分析的时候\",{\"1\":{\"1611\":1}}],[\"在后面的文章中\",{\"1\":{\"317\":1}}],[\"在对象销毁前就会调用destory\",{\"1\":{\"1234\":1}}],[\"在梳理oauth2\",{\"1\":{\"1202\":1}}],[\"在请求中放入一个攻击者无法伪造的信息\",{\"1\":{\"1201\":1}}],[\"在复制的过程中\",{\"1\":{\"1200\":1}}],[\"在负载均衡中\",{\"1\":{\"1200\":1}}],[\"在找到标注了\",{\"1\":{\"1183\":1}}],[\"在每一个分区上执行这种汇聚操作\",{\"1\":{\"1615\":1}}],[\"在每个数组元素上都加上一个链表结构\",{\"1\":{\"1546\":1}}],[\"在每个事务修改完后\",{\"1\":{\"542\":1}}],[\"在每次进行依赖查找\",{\"1\":{\"1182\":1}}],[\"在注册conversionservicefactorybean的时候\",{\"1\":{\"1091\":1}}],[\"在xml中指定自定义的销毁方法\",{\"1\":{\"1012\":1}}],[\"在xml中配置信息解析的方法\",{\"1\":{\"964\":1}}],[\"在xml文件中\",{\"1\":{\"1005\":1}}],[\"在服务器关闭的时候销毁\",{\"1\":{\"988\":1}}],[\"在同一个事务中\",{\"1\":{\"1261\":1}}],[\"在同一个事务内\",{\"1\":{\"1238\":1}}],[\"在同一个cookie的情况下\",{\"1\":{\"987\":1}}],[\"在同一个数据库实例中\",{\"1\":{\"496\":1}}],[\"在源代码中可以看到相关的逻辑\",{\"1\":{\"965\":1}}],[\"在jvm初始化的时候\",{\"1\":{\"1343\":1}}],[\"在jdk中有很多的方法都可以采用方法引用的方式\",{\"1\":{\"1608\":1}}],[\"在jdk8中的提供了大量的现成的函数式接口供我们使用\",{\"1\":{\"1594\":1}}],[\"在jdk8中\",{\"1\":{\"1594\":1}}],[\"在jdk8之前\",{\"1\":{\"1457\":1}}],[\"在jdk1\",{\"1\":{\"1435\":1,\"1453\":1,\"1546\":1,\"1548\":2,\"1550\":1,\"1553\":1,\"1572\":3,\"1593\":1}}],[\"在jdk7或更早的版本中\",{\"1\":{\"1345\":1}}],[\"在jdk\",{\"1\":{\"1133\":1}}],[\"在java环境中\",{\"1\":{\"1558\":1}}],[\"在java语言中使用两阶段终止模式来优雅地终止线程\",{\"1\":{\"1524\":1}}],[\"在java6之后自旋是自适应的\",{\"1\":{\"1485\":1}}],[\"在java1\",{\"1\":{\"1483\":1}}],[\"在java中表示匿名内部类会使用类名称+\",{\"1\":{\"1592\":1}}],[\"在java中的线程是一个重量级的对象\",{\"1\":{\"1533\":1}}],[\"在java中有以下3种方法可以终止正在运行的线程\",{\"1\":{\"1379\":1}}],[\"在java中\",{\"1\":{\"1342\":1,\"1527\":1,\"1528\":1,\"1538\":1,\"1595\":1}}],[\"在java代码中添加sql通配符\",{\"1\":{\"1213\":1}}],[\"在java\",{\"1\":{\"1061\":1,\"1354\":1,\"1480\":1}}],[\"在java8之后\",{\"1\":{\"963\":1}}],[\"在join语句优化的章节中\",{\"1\":{\"409\":1}}],[\"在join\",{\"1\":{\"403\":2}}],[\"在基于xml的配置元信息中\",{\"1\":{\"928\":1}}],[\"在基于gtid的主备关系里\",{\"1\":{\"468\":1}}],[\"在即将发生大并发访问前手动触发加载缓存不同的key\",{\"1\":{\"633\":1}}],[\"在缓存失效的情况下\",{\"1\":{\"1283\":1}}],[\"在缓存失效后\",{\"1\":{\"633\":1}}],[\"在缓存过期的一刻\",{\"1\":{\"629\":1}}],[\"在访问redis之前判断数据是否存在\",{\"1\":{\"1282\":1}}],[\"在访问key之前\",{\"1\":{\"630\":1}}],[\"在访问一个表的时候会被自动加上\",{\"1\":{\"441\":1}}],[\"在默认情况下\",{\"1\":{\"626\":1}}],[\"在线程池中使用threadlocal\",{\"1\":{\"1528\":1}}],[\"在线程进入锁等待以后\",{\"1\":{\"476\":1}}],[\"在线扩容就十分麻烦\",{\"1\":{\"624\":1}}],[\"在主从复制的基础上\",{\"1\":{\"607\":1}}],[\"在主库更新后\",{\"1\":{\"471\":1}}],[\"在主库上\",{\"1\":{\"464\":1}}],[\"在主库和备库上的执行顺序相反\",{\"1\":{\"460\":1}}],[\"在主库和备库是无差别的\",{\"1\":{\"457\":1}}],[\"在主库故障的时候\",{\"1\":{\"459\":1}}],[\"在主库执行这条sql语句的时候\",{\"1\":{\"454\":1}}],[\"在从前的版本中\",{\"1\":{\"601\":1}}],[\"在从库上执行select\",{\"1\":{\"473\":1,\"474\":1}}],[\"在从库上执行查询请求\",{\"1\":{\"472\":1}}],[\"在从库b上执行change\",{\"1\":{\"467\":1}}],[\"在从库b上\",{\"1\":{\"467\":1}}],[\"在网络中传输的对象也是一样需要序列化\",{\"1\":{\"583\":1}}],[\"在网络正常的时候\",{\"1\":{\"457\":1}}],[\"在做好redis相关的配置并启动后就可以进行测试\",{\"1\":{\"582\":1}}],[\"在输入元素的数量或者体积非常非常大时\",{\"1\":{\"577\":1}}],[\"在有了前面的基础之后\",{\"1\":{\"1618\":1}}],[\"在有序集合中计算指定字典区间内成员数量\",{\"1\":{\"574\":1}}],[\"在有些系统中\",{\"1\":{\"438\":1}}],[\"在有些公司的数据库规范中\",{\"1\":{\"423\":1}}],[\"在有些场景下\",{\"1\":{\"348\":1}}],[\"在大多数场景下可以与\",{\"1\":{\"1644\":1}}],[\"在大多数情况下都是一种无状态的操作\",{\"1\":{\"1619\":1}}],[\"在大多数情况下\",{\"1\":{\"1485\":1}}],[\"在大型大体应用中\",{\"1\":{\"1304\":1}}],[\"在大部分的情况下\",{\"1\":{\"592\":1}}],[\"在大量数据环境下\",{\"1\":{\"572\":1}}],[\"在大批量插入数据的情况下\",{\"1\":{\"492\":1}}],[\"在kafka当中\",{\"1\":{\"1330\":1,\"1331\":1}}],[\"在k2元素后\",{\"1\":{\"571\":1}}],[\"在k索引树取下一个值k=6\",{\"1\":{\"337\":1}}],[\"在k索引树取下一个值k=5\",{\"1\":{\"337\":1}}],[\"在k索引树上找到k=3的记录\",{\"1\":{\"337\":1}}],[\"在表中索引多或者采样页面也别多的时候\",{\"1\":{\"559\":1}}],[\"在表t的ftime索引上\",{\"1\":{\"424\":1}}],[\"在表t的ftime索引\",{\"1\":{\"424\":1}}],[\"在表t2的字段b上创建索引会浪费资源\",{\"1\":{\"407\":1}}],[\"在表t2中插入了100万行数据\",{\"1\":{\"404\":1}}],[\"在表t1里\",{\"1\":{\"404\":1}}],[\"在表t1插入的是100行数据\",{\"1\":{\"400\":1}}],[\"在计算某些索引列中包含多少不重复值时\",{\"1\":{\"558\":1}}],[\"在计算连接顺序bca时\",{\"1\":{\"556\":1}}],[\"在和全文扫描比较成本时\",{\"1\":{\"551\":1}}],[\"在通过二级索引获取到记录之后\",{\"1\":{\"549\":1}}],[\"在事务开启之前\",{\"1\":{\"1297\":1}}],[\"在事务中的所有命令都将会被串行化的顺序执行\",{\"1\":{\"1297\":1}}],[\"在事务内进行插入操作\",{\"1\":{\"1277\":1}}],[\"在事务进行过程中\",{\"1\":{\"1261\":1}}],[\"在事务2修改该行数据时\",{\"1\":{\"542\":1}}],[\"在事务1修改该行数据时\",{\"1\":{\"542\":1}}],[\"在进行collector源码分析的时候\",{\"1\":{\"1617\":1}}],[\"在进行链表或者红黑树操作时\",{\"1\":{\"1554\":1}}],[\"在进行检索时\",{\"1\":{\"530\":1}}],[\"在进入引擎之前排队\",{\"1\":{\"444\":1}}],[\"在达到上限后的表现也不同\",{\"1\":{\"499\":1}}],[\"在17\",{\"1\":{\"497\":1}}],[\"在理论上还是可能出现一个读写事务于一个只读事务显示trx\",{\"1\":{\"497\":1}}],[\"在代码实现时row\",{\"1\":{\"495\":1}}],[\"在代码上就是通过多版本并发控制\",{\"1\":{\"396\":1}}],[\"在生产者\",{\"1\":{\"1502\":1}}],[\"在生产上\",{\"1\":{\"492\":1}}],[\"在生产环境中\",{\"1\":{\"429\":1}}],[\"在申请自增值的时候\",{\"1\":{\"491\":1}}],[\"在删除数据表之前\",{\"1\":{\"487\":1}}],[\"在备份之后的第6天发生误操作\",{\"1\":{\"486\":1}}],[\"在备库执行binlog完成\",{\"1\":{\"472\":1}}],[\"在备库执行的时候\",{\"1\":{\"465\":1}}],[\"在备库执行时也是可以并行的\",{\"1\":{\"465\":1}}],[\"在备库执行时时可以并行的\",{\"1\":{\"465\":1}}],[\"在备库执行完成的时间和主库执行完成的时间之间的差值\",{\"1\":{\"457\":1}}],[\"在备库上执行的时候\",{\"1\":{\"464\":1}}],[\"在备库b上执行start\",{\"1\":{\"453\":1}}],[\"在备库b上通过change\",{\"1\":{\"453\":1}}],[\"在备库的table\",{\"1\":{\"413\":2}}],[\"在备库的应用线程就能够知道执行每个语句的主库线程id\",{\"1\":{\"413\":1}}],[\"在用备份恢复出临时实例之后\",{\"1\":{\"485\":1}}],[\"在用户评论的地方需要查询用户头像的url\",{\"1\":{\"386\":1}}],[\"在function接口中\",{\"1\":{\"1598\":1}}],[\"在file\",{\"1\":{\"479\":1}}],[\"在from子句中包含的子查询被标记为derived\",{\"1\":{\"330\":1}}],[\"在等位点的方案中\",{\"1\":{\"474\":1}}],[\"在持续延迟的情况下\",{\"1\":{\"472\":1}}],[\"在引入gtid之后\",{\"1\":{\"468\":1}}],[\"在引擎层\",{\"1\":{\"425\":1}}],[\"在引擎内部使用覆盖索引在索引k上其实读了三条记录\",{\"1\":{\"338\":1}}],[\"在引擎内部扫描了多行\",{\"1\":{\"322\":1}}],[\"在切换任务的时候\",{\"1\":{\"467\":1}}],[\"在registerbeandefinitions方法中定义了一个classpathmapperscanner对象\",{\"1\":{\"1653\":1}}],[\"在registerbeandefinition方法中会这样保存数据\",{\"1\":{\"975\":1}}],[\"在referencepipeline当中\",{\"1\":{\"1622\":1}}],[\"在refresh\",{\"1\":{\"1178\":2}}],[\"在redis事务中如果有某一条命令执行失败\",{\"1\":{\"1297\":1}}],[\"在redistemplate上也有一个条件注解\",{\"1\":{\"583\":1}}],[\"在redis中无论什么数据类型\",{\"1\":{\"569\":1}}],[\"在redo\",{\"1\":{\"465\":1,\"479\":1}}],[\"在rc隔离级别下\",{\"1\":{\"542\":1}}],[\"在rc级别下的事务中\",{\"1\":{\"542\":1}}],[\"在rr级别下的某个事务对某条记录的第一次快照读会创建一个快照及read\",{\"1\":{\"542\":1}}],[\"在row格式下\",{\"1\":{\"454\":1}}],[\"在决定分发策略的哈希表中\",{\"1\":{\"463\":1}}],[\"在决定哪个表做驱动表的时候\",{\"1\":{\"403\":1}}],[\"在上面排序的例子中可以看到\",{\"1\":{\"1607\":1}}],[\"在上面的文档中\",{\"1\":{\"1594\":1}}],[\"在上面的这个语句序列中\",{\"1\":{\"468\":1}}],[\"在上面的例子中\",{\"1\":{\"390\":1}}],[\"在上面这个例子中\",{\"1\":{\"462\":1,\"505\":1}}],[\"在满足数据可靠性的前提下\",{\"1\":{\"459\":1}}],[\"在插入一行数据的时候\",{\"1\":{\"491\":1}}],[\"在插入一条c=4的语句后\",{\"1\":{\"459\":1}}],[\"在插入新值的时候需要做必要的维护\",{\"1\":{\"335\":1}}],[\"在双m的结构下\",{\"1\":{\"458\":1}}],[\"在真正执行的delete命令之前\",{\"1\":{\"454\":1}}],[\"在状态1中\",{\"1\":{\"453\":2}}],[\"在出现io瓶颈的场景里\",{\"1\":{\"450\":1}}],[\"在一段时间内只允许一个线程访问的资源就称为临界资源\",{\"1\":{\"1477\":1}}],[\"在一条单表查询语句真正执行之前\",{\"1\":{\"546\":1}}],[\"在一些场景下\",{\"1\":{\"491\":1}}],[\"在一主多从的场景中国呢\",{\"1\":{\"472\":1}}],[\"在一主多从的架构下\",{\"1\":{\"466\":1}}],[\"在一个网络请求中\",{\"1\":{\"1421\":1}}],[\"在一个事务过程中\",{\"1\":{\"1261\":1}}],[\"在一个页面中统计两条记录之间有几条记录的成本就很小了\",{\"1\":{\"549\":1}}],[\"在一个交易平台上\",{\"1\":{\"470\":1}}],[\"在一个市民信息表上\",{\"1\":{\"338\":1}}],[\"在一组里面一起提交的事务\",{\"1\":{\"464\":1}}],[\"在一行行扫描的过程中\",{\"1\":{\"448\":1}}],[\"在trysplit调用之前和调用当中重复地调用这个方法\",{\"1\":{\"1620\":1}}],[\"在t3时刻\",{\"1\":{\"497\":1}}],[\"在t1时刻\",{\"1\":{\"497\":2}}],[\"在t时刻写入新的binlog的位置\",{\"1\":{\"467\":1}}],[\"在t4时刻\",{\"1\":{\"446\":1}}],[\"在t2时刻\",{\"1\":{\"446\":1,\"497\":1}}],[\"在abstractapplicationcontext\",{\"1\":{\"1009\":1}}],[\"在annotationconfigutils\",{\"1\":{\"967\":1}}],[\"在a\",{\"1\":{\"467\":1}}],[\"在alter\",{\"1\":{\"441\":1}}],[\"在autocommit为1的情况下\",{\"1\":{\"435\":1}}],[\"在给小表加字段的时候\",{\"1\":{\"441\":1}}],[\"在语句执行开始时申请\",{\"1\":{\"441\":1}}],[\"在异常处理机制上有差异\",{\"1\":{\"438\":1}}],[\"在视图a\",{\"1\":{\"434\":1}}],[\"在使用传统jdbc时\",{\"1\":{\"1982\":1}}],[\"在使用这个代理对象的方法的时候才会去创建属性的实例对象\",{\"1\":{\"1649\":1}}],[\"在使用java\",{\"1\":{\"1620\":1}}],[\"在使用并行流的时候\",{\"1\":{\"1617\":1}}],[\"在使用treemao的时候\",{\"1\":{\"1544\":1}}],[\"在使用不可变性模式的时候一定要确认保持不变性的边界在哪里\",{\"1\":{\"1526\":1}}],[\"在使用不变性模式的时候\",{\"1\":{\"1526\":1}}],[\"在使用kill命令的时候\",{\"1\":{\"480\":1}}],[\"在使用binlog恢复数据的时候\",{\"1\":{\"454\":1}}],[\"在使用之前预先创建即可\",{\"1\":{\"426\":1}}],[\"在使用create\",{\"1\":{\"317\":1}}],[\"在文件开头加入两行\",{\"1\":{\"485\":1}}],[\"在文件管理\",{\"1\":{\"425\":1}}],[\"在文档写入es时\",{\"1\":{\"309\":1}}],[\"在性能上\",{\"1\":{\"424\":1}}],[\"在应用上下文中有两个autowiredannotationbeanpostprocessor来进行处理\",{\"1\":{\"967\":1}}],[\"在应用日志的时候\",{\"1\":{\"485\":1}}],[\"在应用代码里面取\",{\"1\":{\"422\":1}}],[\"在应用层做关联查询\",{\"1\":{\"394\":1}}],[\"在应用层做关联\",{\"1\":{\"394\":1}}],[\"在我们之前的所有的例子当中\",{\"1\":{\"1614\":1}}],[\"在我们创建的beanfactory无法操作这个类\",{\"1\":{\"1005\":1}}],[\"在我们构造的堆里面\",{\"1\":{\"421\":1}}],[\"在我们这个例子中\",{\"1\":{\"340\":1}}],[\"在student类中\",{\"1\":{\"1605\":1}}],[\"在stw状态下\",{\"1\":{\"1440\":1}}],[\"在start\",{\"1\":{\"485\":1}}],[\"在socket编程中\",{\"1\":{\"1425\":2}}],[\"在sort\",{\"1\":{\"420\":1}}],[\"在sql语句中拼接通配符\",{\"1\":{\"1213\":1}}],[\"在spring中\",{\"1\":{\"1654\":1}}],[\"在spring中需要去解析类的信息\",{\"1\":{\"1646\":1}}],[\"在spring的扫描逻辑中\",{\"1\":{\"1645\":1}}],[\"在spring内部使用\",{\"1\":{\"1640\":1}}],[\"在spring源码中\",{\"1\":{\"1638\":1}}],[\"在spring应用上下文启动之前\",{\"1\":{\"1156\":1}}],[\"在spring当中\",{\"1\":{\"1147\":1}}],[\"在spring\",{\"1\":{\"1056\":1}}],[\"在sunion的基础上\",{\"1\":{\"572\":1}}],[\"在sinter的基础上\",{\"1\":{\"572\":1}}],[\"在sdiff的基础上\",{\"1\":{\"572\":1}}],[\"在selector上注册通道\",{\"1\":{\"1574\":2}}],[\"在select或者where子句中包含了子查询\",{\"1\":{\"330\":1}}],[\"在server层\",{\"1\":{\"425\":1}}],[\"在session\",{\"1\":{\"424\":1,\"476\":1}}],[\"在sessoin结束的时候\",{\"1\":{\"412\":1}}],[\"在优化group\",{\"1\":{\"417\":1}}],[\"在实践中\",{\"1\":{\"1474\":1}}],[\"在实例化bean的时候\",{\"1\":{\"1000\":1}}],[\"在实例a\",{\"1\":{\"468\":1}}],[\"在实现等行锁时\",{\"1\":{\"481\":1}}],[\"在实现上\",{\"1\":{\"412\":1,\"433\":1}}],[\"在实际生产项目中会有些极端的情况\",{\"1\":{\"1536\":1}}],[\"在实际生产中\",{\"1\":{\"400\":1}}],[\"在实际使用中\",{\"1\":{\"482\":1,\"1593\":1}}],[\"在实际的应用中\",{\"1\":{\"1581\":1}}],[\"在实际的业务场景中\",{\"1\":{\"450\":1}}],[\"在实际的开发中\",{\"1\":{\"395\":1}}],[\"在磁盘上的文件不会重名\",{\"1\":{\"412\":1}}],[\"在5\",{\"1\":{\"412\":1,\"460\":1}}],[\"在汇总库上创建一个临时表temp\",{\"1\":{\"411\":1}}],[\"在put方法中\",{\"1\":{\"1553\":1}}],[\"在pentium及之前的处理器中\",{\"1\":{\"1473\":1}}],[\"在proxyfactory筛选代理对象的被代理的方法\",{\"1\":{\"1654\":1}}],[\"在proxy这一层解析完sql语句以后\",{\"1\":{\"411\":1}}],[\"在prepare阶段\",{\"1\":{\"451\":1}}],[\"在phone表上创建索引\",{\"1\":{\"363\":1}}],[\"在业务不断发展的过程中\",{\"1\":{\"466\":1}}],[\"在业务端存入到哈希这种数据结构的实现\",{\"1\":{\"408\":1}}],[\"在业务端实现\",{\"1\":{\"408\":1}}],[\"在业务开发中\",{\"1\":{\"349\":1}}],[\"在判断要不要使用join语句时\",{\"1\":{\"403\":1}}],[\"在netty中\",{\"1\":{\"1231\":1}}],[\"在n确定的情况下\",{\"1\":{\"403\":1}}],[\"在n+λ\",{\"1\":{\"403\":1}}],[\"在mod\",{\"1\":{\"1550\":1}}],[\"在mapperfactorybean中的getobject方法中\",{\"1\":{\"1653\":1}}],[\"在mapper\",{\"1\":{\"1219\":1}}],[\"在mariadb实现了并行复制之后\",{\"1\":{\"465\":1}}],[\"在m和n大小确定的情况下\",{\"1\":{\"403\":1}}],[\"在mysql的实际计算中\",{\"1\":{\"551\":1}}],[\"在mysql的information\",{\"1\":{\"441\":1}}],[\"在mysql数据类型设置方面\",{\"1\":{\"527\":1}}],[\"在mysql里面\",{\"1\":{\"491\":1}}],[\"在mysql8\",{\"1\":{\"490\":1}}],[\"在mysql和客户端之间有一个中间代理层proxy\",{\"1\":{\"469\":1}}],[\"在mysql5\",{\"1\":{\"417\":1,\"434\":1,\"441\":1,\"463\":1,\"465\":3,\"479\":1,\"490\":1,\"492\":2,\"518\":1,\"544\":2,\"558\":1}}],[\"在mysql\",{\"1\":{\"340\":1,\"549\":1,\"554\":2}}],[\"在mysql中可以设置事务的隔离级别\",{\"1\":{\"1262\":1}}],[\"在mysql中有两个kill命令\",{\"1\":{\"480\":1}}],[\"在mysql中有四种类型的行锁\",{\"1\":{\"442\":1}}],[\"在mysql中有很多看上去逻辑相同\",{\"1\":{\"365\":1}}],[\"在mysql中是支持前缀索引的\",{\"1\":{\"350\":1}}],[\"在mysql中\",{\"1\":{\"334\":1,\"347\":1,\"356\":1,\"432\":1,\"434\":1,\"527\":1}}],[\"在形式上\",{\"1\":{\"401\":1}}],[\"在保证逻辑正确的前题下\",{\"1\":{\"396\":1}}],[\"在很多场景下\",{\"1\":{\"394\":1}}],[\"在某一个线程b被阻塞或者执行其他操作时\",{\"1\":{\"1531\":1}}],[\"在某些适当的场景下才会重新收集这些统计数据\",{\"1\":{\"558\":1}}],[\"在某些从库执行查询请求会存在过期读的现象\",{\"1\":{\"472\":1}}],[\"在某些版本的mysql上\",{\"1\":{\"392\":1}}],[\"在某个数据页上做了什么修改\",{\"1\":{\"325\":1}}],[\"在返回一个小的查询结果方面很高效\",{\"1\":{\"392\":1}}],[\"在传统的实现中\",{\"1\":{\"392\":1}}],[\"在传入7的时候已经无法定位记录了\",{\"1\":{\"366\":1}}],[\"在索引中使用where条件来过滤不匹配的记录\",{\"1\":{\"390\":1}}],[\"在索引列上进行计算\",{\"1\":{\"371\":1}}],[\"在extra字段里面\",{\"1\":{\"416\":1}}],[\"在extra列中出现using\",{\"1\":{\"390\":1}}],[\"在extra列中出现了using\",{\"1\":{\"390\":1}}],[\"在explain语句中的type列反映了访问类型\",{\"1\":{\"390\":1}}],[\"在es中预先定义好映射\",{\"1\":{\"309\":1}}],[\"在评估查询开销的时候\",{\"1\":{\"390\":1}}],[\"在确定查询只返回需要的数据以后\",{\"1\":{\"387\":1}}],[\"在选择复合索引的时候\",{\"1\":{\"380\":2}}],[\"在写sql的不要使用select\",{\"1\":{\"373\":1}}],[\"在beanfactory的基础上\",{\"1\":{\"1636\":3}}],[\"在beanfactory场景下还是需要手动进行调用\",{\"1\":{\"1012\":1}}],[\"在bifunction中\",{\"1\":{\"1601\":1}}],[\"在bifunction中只有一个默认方法andthen\",{\"1\":{\"1598\":1}}],[\"在bitmap上可执行and\",{\"1\":{\"578\":1}}],[\"在binlog里面把插入数据的操作都如实记录进来\",{\"1\":{\"492\":1}}],[\"在binlog里面记录了整行的数据修改前各个字段的值\",{\"1\":{\"462\":1}}],[\"在binlog里面\",{\"1\":{\"447\":1}}],[\"在book表中有idx\",{\"1\":{\"362\":1}}],[\"在book表创建索引\",{\"1\":{\"362\":1,\"363\":1}}],[\"在b+树这种索引结构中\",{\"1\":{\"339\":1}}],[\"在排序的过程中还是按照实际长度来分配空间的\",{\"1\":{\"354\":1}}],[\"在示例表中有4000条满足city=\",{\"1\":{\"354\":1}}],[\"在开发应用的时候\",{\"1\":{\"353\":1}}],[\"在开始执行之前\",{\"1\":{\"321\":1,\"514\":1}}],[\"在concurrenthashmap中不允许key\",{\"1\":{\"1554\":1}}],[\"在controller中注入service的时候使用名称来指定注入哪一个\",{\"1\":{\"1242\":1}}],[\"在channelpipeline中\",{\"1\":{\"1224\":1}}],[\"在class表中有idx\",{\"1\":{\"362\":1}}],[\"在class表创建索引\",{\"1\":{\"362\":1}}],[\"在city字段上创建索引之后\",{\"1\":{\"354\":1}}],[\"在cpu消耗方面\",{\"1\":{\"352\":1}}],[\"在csdn中搜索elaticsearch快速入门\",{\"1\":{\"299\":1}}],[\"在不断的实践中\",{\"1\":{\"1607\":1}}],[\"在不同场景使用不同的排序模式\",{\"1\":{\"520\":1}}],[\"在不同的操作系统上使用相同的字节码文件可以得到相同的结果\",{\"1\":{\"1337\":1}}],[\"在不同的隔离级别下\",{\"1\":{\"433\":1}}],[\"在不同的mysql版本中有着不同的处理方式\",{\"1\":{\"412\":1}}],[\"在不同的mysql引擎中\",{\"1\":{\"396\":1}}],[\"在不允许过期读的要求下\",{\"1\":{\"473\":1}}],[\"在不影响数据一致性的前提下\",{\"1\":{\"343\":1}}],[\"在不损失精度的情况下\",{\"1\":{\"330\":1}}],[\"在建立联合索引的时候\",{\"1\":{\"339\":1}}],[\"在建立冗余索引来支持索引覆盖时就需要权衡考虑了\",{\"1\":{\"338\":1}}],[\"在建表语句中一般是这么定义的\",{\"1\":{\"335\":1}}],[\"在这里被第一次调用\",{\"1\":{\"1617\":1}}],[\"在这里被第二次调用\",{\"1\":{\"1617\":1}}],[\"在这里的意思是把输入的字符串转成utf8mb4字符集\",{\"1\":{\"368\":1}}],[\"在这段代码中\",{\"1\":{\"1607\":1}}],[\"在这种方式下\",{\"1\":{\"1286\":1}}],[\"在这种情况下\",{\"1\":{\"335\":1,\"1605\":1}}],[\"在这行数据中取到关联字段\",{\"1\":{\"524\":1}}],[\"在这之后\",{\"1\":{\"491\":1}}],[\"在这两个方法中都接受一个consumer<\",{\"1\":{\"1593\":1}}],[\"在这两个条件都具备的情况下\",{\"1\":{\"485\":1}}],[\"在这两个图里面\",{\"1\":{\"340\":1}}],[\"在这些可能会造成消息丢失的场景下\",{\"1\":{\"1328\":1}}],[\"在这些操作中\",{\"1\":{\"482\":1}}],[\"在这些买点的地方判断线程状态\",{\"1\":{\"481\":1}}],[\"在这棵树上\",{\"1\":{\"404\":1}}],[\"在这条语句里\",{\"1\":{\"401\":1}}],[\"在这个场景下\",{\"1\":{\"1603\":1}}],[\"在这个接口中\",{\"1\":{\"1594\":1}}],[\"在这个方法里面可以执行一些销毁的逻辑\",{\"1\":{\"985\":1}}],[\"在这个空表里面执行insert\",{\"1\":{\"490\":1}}],[\"在这个临时库上执行这些操作\",{\"1\":{\"484\":1}}],[\"在这个交易平台上\",{\"1\":{\"470\":1}}],[\"在这个不可用状态中\",{\"1\":{\"458\":1}}],[\"在这个例子当中\",{\"1\":{\"1614\":1,\"1619\":1}}],[\"在这个例子里\",{\"1\":{\"454\":1}}],[\"在这个例子中\",{\"1\":{\"337\":1,\"348\":2,\"356\":1,\"366\":1,\"394\":1,\"476\":2,\"481\":1,\"492\":1}}],[\"在这个架构中\",{\"1\":{\"411\":1}}],[\"在这个算法里\",{\"1\":{\"403\":1}}],[\"在这个join语句的执行过程中\",{\"1\":{\"401\":1}}],[\"在这个查询过程\",{\"1\":{\"401\":1}}],[\"在这个查询里面\",{\"1\":{\"338\":1}}],[\"在这个流程里\",{\"1\":{\"401\":1}}],[\"在这个语句里\",{\"1\":{\"401\":1}}],[\"在这个索引里面\",{\"1\":{\"356\":1}}],[\"在这个过程中会使用大量synchronized关键字对对象加锁\",{\"1\":{\"1485\":1}}],[\"在这个过程中\",{\"1\":{\"337\":1,\"350\":1,\"403\":1,\"443\":1}}],[\"在需要更新数据的时候就麻烦了\",{\"1\":{\"333\":1}}],[\"在之前的这个例子中\",{\"1\":{\"1594\":1}}],[\"在之前的例子中\",{\"1\":{\"320\":1,\"408\":1,\"1605\":1}}],[\"在之前\",{\"1\":{\"1007\":1}}],[\"在之后用binlog来恢复的时候就多了一个事务出来\",{\"1\":{\"327\":1}}],[\"在执行时并不一定按照写的顺序就叫做指令重排序\",{\"1\":{\"1405\":1}}],[\"在执行到它们之后的第一个修改innodb操作的语句\",{\"1\":{\"542\":1}}],[\"在执行update\",{\"1\":{\"535\":1}}],[\"在执行过程中\",{\"1\":{\"497\":1}}],[\"在执行查询请求之前\",{\"1\":{\"472\":1}}],[\"在执行主备切换时\",{\"1\":{\"467\":1}}],[\"在执行图5中第4步把binlog\",{\"1\":{\"451\":1}}],[\"在执行select\",{\"1\":{\"448\":1}}],[\"在执行流程过程中客户端发生了异常断开\",{\"1\":{\"410\":1}}],[\"在执行第三步的时候\",{\"1\":{\"368\":1}}],[\"在执行create\",{\"1\":{\"317\":1}}],[\"在执行下面这个查询语句时\",{\"1\":{\"317\":1}}],[\"在关系型数据库中\",{\"1\":{\"309\":1}}],[\"在\",{\"1\":{\"307\":1,\"428\":1,\"433\":2,\"454\":1,\"1136\":1,\"1137\":1,\"1583\":1,\"1584\":1,\"1657\":2}}],[\"格式元素\",{\"1\":{\"1053\":1}}],[\"格式化\",{\"1\":{\"1053\":1,\"1092\":1}}],[\"格式化sql\",{\"1\":{\"519\":1}}],[\"格式是\",{\"1\":{\"468\":1}}],[\"格式\",{\"1\":{\"306\":3,\"529\":1}}],[\"格式灵活\",{\"1\":{\"304\":1}}],[\"u>\",{\"1\":{\"1608\":1,\"1618\":5}}],[\"u分别是两个接收的参数的类型\",{\"1\":{\"1598\":1}}],[\"ul>\",{\"1\":{\"1594\":2}}],[\"uri\",{\"1\":{\"1037\":1}}],[\"urlclassloader继承了secureclassloader\",{\"1\":{\"1432\":1}}],[\"urlconnection\",{\"1\":{\"1037\":1}}],[\"urlresource\",{\"1\":{\"1039\":1}}],[\"url支持的协议\",{\"1\":{\"1039\":1}}],[\"urlstreamhandlefactory\",{\"1\":{\"1037\":1}}],[\"urlstreamhandler或java\",{\"1\":{\"1037\":1}}],[\"url或java\",{\"1\":{\"1037\":1}}],[\"url\",{\"1\":{\"1037\":1,\"1039\":1,\"1647\":1}}],[\"uuid\",{\"1\":{\"959\":1,\"1609\":1,\"1612\":1}}],[\"utility\",{\"1\":{\"1620\":1,\"1621\":1}}],[\"util\",{\"1\":{\"918\":2,\"945\":2,\"1026\":1,\"1028\":4,\"1042\":2,\"1043\":1,\"1052\":5,\"1053\":1,\"1060\":1,\"1091\":5,\"1099\":1,\"1108\":4,\"1109\":2,\"1111\":1,\"1112\":1,\"1123\":1,\"1124\":1,\"1125\":1,\"1146\":1,\"1370\":2,\"1479\":3,\"1480\":1,\"1498\":1,\"1539\":7,\"1540\":4,\"1597\":2,\"1598\":2,\"1601\":1,\"1610\":2,\"1617\":4,\"1619\":5,\"1620\":13}}],[\"util=\",{\"1\":{\"918\":1,\"1091\":1}}],[\"utf\",{\"1\":{\"917\":1,\"918\":1,\"930\":1,\"953\":2,\"954\":2,\"997\":1,\"1000\":1,\"1022\":1,\"1030\":1,\"1032\":1,\"1040\":1,\"1041\":1,\"1043\":1,\"1065\":1,\"1084\":1,\"1091\":1,\"1146\":3,\"1574\":2,\"1575\":2}}],[\"utf8\",{\"1\":{\"368\":2,\"506\":3,\"534\":1}}],[\"utf8mb4是utf8的超集\",{\"1\":{\"368\":1}}],[\"utf8mb4\",{\"1\":{\"366\":1,\"368\":3}}],[\"uv\",{\"1\":{\"577\":1}}],[\"uid\",{\"1\":{\"570\":1}}],[\"u\",{\"1\":{\"558\":4,\"1554\":5,\"1598\":12,\"1601\":4,\"1608\":2,\"1617\":2,\"1618\":4,\"1622\":2}}],[\"upstream表示上游元素的源\",{\"1\":{\"1622\":1}}],[\"upstream\",{\"1\":{\"1621\":2,\"1622\":5}}],[\"updating\",{\"1\":{\"1608\":2}}],[\"updated\",{\"1\":{\"1480\":1}}],[\"updateddefinitions\",{\"1\":{\"996\":4}}],[\"update的方式来解决漏标的问题\",{\"1\":{\"1442\":1}}],[\"update和delete会更新版本号\",{\"1\":{\"535\":1}}],[\"updates参数设置为on\",{\"1\":{\"484\":1}}],[\"updates=on\",{\"1\":{\"455\":1,\"484\":1}}],[\"update命令没有超时\",{\"1\":{\"478\":1}}],[\"update要把整个表所有记录锁起来\",{\"1\":{\"448\":1}}],[\"update是一致的\",{\"1\":{\"447\":1}}],[\"update加锁的语义和select\",{\"1\":{\"447\":1}}],[\"update语句的执行如下图\",{\"1\":{\"326\":1}}],[\"update不会删除原来的文档\",{\"1\":{\"306\":1}}],[\"update\",{\"1\":{\"306\":6,\"307\":3,\"323\":1,\"368\":5,\"446\":1,\"447\":9,\"448\":1,\"476\":1,\"478\":2,\"479\":1,\"484\":2,\"497\":1,\"535\":1,\"536\":1,\"537\":2,\"541\":2,\"542\":1,\"558\":1,\"1108\":1,\"1261\":1,\"1263\":1,\"1479\":4,\"1498\":4}}],[\"upon\",{\"1\":{\"1601\":2,\"1610\":1,\"1620\":2,\"1622\":1,\"1623\":1}}],[\"upload\",{\"1\":{\"1593\":1}}],[\"up\",{\"1\":{\"431\":1,\"542\":3,\"997\":1,\"1166\":1,\"1175\":1,\"1647\":2}}],[\"unpredictable\",{\"1\":{\"1619\":1}}],[\"unpark\",{\"1\":{\"1477\":1,\"1530\":1}}],[\"unmodifiablelist\",{\"1\":{\"1618\":1}}],[\"unmodifiableset\",{\"1\":{\"1617\":5,\"1618\":3}}],[\"unordered意味着收集的操作并不确保保留输入元素的顺序\",{\"1\":{\"1617\":1}}],[\"unordered\",{\"1\":{\"1615\":6,\"1617\":10,\"1618\":3,\"1619\":1,\"1623\":2}}],[\"unaryoperator<t>\",{\"1\":{\"1609\":3}}],[\"unaryoperator\",{\"1\":{\"1601\":1}}],[\"unlisted\",{\"1\":{\"1620\":1}}],[\"unlikely\",{\"1\":{\"1620\":1}}],[\"unlike\",{\"1\":{\"1597\":2}}],[\"unless\",{\"1\":{\"1594\":2,\"1595\":2,\"1618\":1,\"1619\":2,\"1620\":1}}],[\"unlocked\",{\"1\":{\"1484\":1}}],[\"unlock\",{\"1\":{\"534\":1,\"1473\":1,\"1502\":2,\"1503\":4,\"1530\":1,\"1553\":1}}],[\"unboundedqueue\",{\"1\":{\"1503\":1}}],[\"uncaughtexceptionhandler\",{\"1\":{\"1510\":1}}],[\"uncheckedioexception\",{\"1\":{\"1533\":1,\"1534\":1}}],[\"unchecked\",{\"1\":{\"1502\":1,\"1550\":1,\"1609\":1,\"1615\":1,\"1617\":1,\"1618\":3,\"1622\":2,\"1623\":1,\"1647\":1}}],[\"uncontended\",{\"1\":{\"1480\":3,\"1554\":3}}],[\"uncommited\",{\"1\":{\"1238\":2,\"1262\":1}}],[\"uncommitted\",{\"1\":{\"433\":1,\"532\":1}}],[\"unrelated\",{\"1\":{\"1620\":1}}],[\"unresolvable\",{\"1\":{\"1184\":1}}],[\"unregisterapplicationcontext\",{\"1\":{\"1175\":2}}],[\"unexpected\",{\"1\":{\"964\":1,\"1647\":1}}],[\"unsatisfieddependencyexception\",{\"1\":{\"1648\":1}}],[\"unsafewrapper\",{\"1\":{\"1479\":1}}],[\"unsafe\",{\"1\":{\"1479\":5,\"1553\":2}}],[\"unsupportedencodingexception\",{\"1\":{\"1575\":2}}],[\"unsupportedoperationexception\",{\"1\":{\"963\":1,\"1621\":2,\"1648\":1}}],[\"unsigned\",{\"1\":{\"349\":1,\"352\":1,\"361\":5,\"362\":4,\"363\":2,\"459\":2,\"493\":1,\"494\":3,\"495\":1,\"1570\":1}}],[\"until\",{\"1\":{\"928\":1,\"1595\":2,\"1619\":1,\"1620\":3,\"1621\":1}}],[\"unnamed\",{\"1\":{\"928\":1}}],[\"unwatch进行解锁\",{\"1\":{\"581\":1}}],[\"undetermined\",{\"1\":{\"1620\":1}}],[\"undermine\",{\"1\":{\"1620\":1}}],[\"under\",{\"1\":{\"1618\":1,\"1658\":1}}],[\"undefined\",{\"1\":{\"519\":1,\"1620\":1}}],[\"undo日志版本链是指一行数据被多个事务依次修改过后\",{\"1\":{\"542\":1}}],[\"undo日志版本链与read\",{\"0\":{\"542\":1}}],[\"undo\",{\"1\":{\"542\":7}}],[\"unknownhostexception\",{\"1\":{\"583\":1}}],[\"unknown\",{\"1\":{\"519\":1,\"580\":1,\"645\":1,\"1620\":1,\"1623\":1}}],[\"uninitialized\",{\"1\":{\"1170\":1}}],[\"uniqueinstance\",{\"1\":{\"1191\":5,\"1192\":2,\"1193\":4,\"1194\":2}}],[\"uniquebeanname\",{\"1\":{\"928\":2}}],[\"unique\",{\"1\":{\"462\":1,\"489\":1,\"498\":1,\"553\":1,\"928\":3,\"963\":1,\"1195\":1}}],[\"unix\",{\"1\":{\"457\":1,\"1423\":1}}],[\"unit\",{\"1\":{\"330\":1,\"576\":2,\"1476\":2,\"1501\":4}}],[\"unioned\",{\"1\":{\"1620\":1}}],[\"union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表\",{\"1\":{\"557\":1}}],[\"union还需要用到唯一索引约束\",{\"1\":{\"418\":1}}],[\"union的执行就会使用临时表来完成\",{\"1\":{\"414\":1}}],[\"union\",{\"1\":{\"330\":2,\"414\":1}}],[\"usable\",{\"1\":{\"519\":3,\"520\":2}}],[\"usages\",{\"1\":{\"1620\":1}}],[\"usage\",{\"1\":{\"429\":1,\"1620\":1}}],[\"useful\",{\"1\":{\"1616\":1,\"1620\":4}}],[\"usebiasedlocking\",{\"1\":{\"1485\":1}}],[\"usecompressedoops\",{\"1\":{\"1484\":1}}],[\"usec选项\",{\"1\":{\"588\":1}}],[\"used\",{\"1\":{\"553\":2,\"555\":4,\"1300\":2,\"1480\":2,\"1594\":2,\"1614\":1,\"1615\":4,\"1619\":1,\"1620\":4,\"1621\":3,\"1623\":3,\"1647\":1,\"1648\":1}}],[\"uses\",{\"1\":{\"519\":2,\"1620\":1}}],[\"use\",{\"1\":{\"454\":2,\"482\":1,\"519\":1,\"581\":4,\"922\":1,\"928\":1,\"997\":1,\"1055\":1,\"1164\":1,\"1167\":1,\"1473\":1,\"1608\":2,\"1614\":1,\"1615\":2,\"1619\":1,\"1620\":2,\"1623\":3,\"1647\":2,\"1650\":1}}],[\"userinterface\",{\"1\":{\"1654\":4}}],[\"userinterface接口的代理对象\",{\"1\":{\"1654\":1}}],[\"userprocessor\",{\"1\":{\"1065\":5}}],[\"uservalodator\",{\"1\":{\"1064\":2}}],[\"username\",{\"1\":{\"1061\":1,\"1156\":2,\"1157\":2,\"1598\":2}}],[\"userlogin\",{\"1\":{\"1061\":3}}],[\"userloginvalidator\",{\"1\":{\"1061\":1}}],[\"usermap\",{\"1\":{\"1029\":2,\"1031\":2}}],[\"useroptional\",{\"1\":{\"963\":1,\"967\":1}}],[\"userobjectfactory\",{\"1\":{\"944\":2,\"1181\":8}}],[\"userobjectprovider\",{\"1\":{\"943\":2,\"944\":2,\"962\":4}}],[\"user4\",{\"1\":{\"961\":1}}],[\"user3和user4\",{\"1\":{\"961\":2}}],[\"user3\",{\"1\":{\"961\":1}}],[\"usergroup\",{\"1\":{\"961\":4}}],[\"userbeandefinitionparser\",{\"1\":{\"1030\":2}}],[\"userbeandefinition\",{\"1\":{\"953\":2}}],[\"userbyfactorybean\",{\"1\":{\"930\":3}}],[\"userbyinstancemethod\",{\"1\":{\"930\":3}}],[\"user=\",{\"1\":{\"953\":1,\"1001\":1,\"1003\":1,\"1005\":1}}],[\"user=$user\",{\"1\":{\"467\":1,\"468\":1}}],[\"userholder2\",{\"1\":{\"955\":5,\"956\":4}}],[\"userholder\",{\"1\":{\"953\":28,\"954\":11,\"955\":12,\"956\":11,\"1001\":8,\"1003\":7,\"1005\":13,\"1006\":12,\"1008\":7,\"1011\":14,\"1012\":4,\"1013\":1}}],[\"user对象并不存在\",{\"1\":{\"943\":1}}],[\"user类型的所有的beans\",{\"1\":{\"929\":1}}],[\"userrespository\",{\"1\":{\"918\":11,\"919\":5}}],[\"user>\",{\"1\":{\"917\":2,\"921\":2,\"941\":2,\"963\":1,\"985\":3,\"1029\":2,\"1031\":2}}],[\"user1\",{\"1\":{\"582\":2,\"961\":4}}],[\"userservice2\",{\"1\":{\"1654\":2}}],[\"userservice\",{\"1\":{\"1635\":1,\"1638\":1,\"1644\":5,\"1645\":2,\"1646\":1,\"1654\":14}}],[\"usersnamespacehandler\",{\"1\":{\"1030\":2}}],[\"users=org\",{\"1\":{\"1030\":1}}],[\"users=\",{\"1\":{\"1030\":1}}],[\"usersobjectfactory\",{\"1\":{\"962\":3}}],[\"users\",{\"1\":{\"472\":1,\"479\":1,\"917\":4,\"918\":6,\"921\":4,\"941\":4,\"963\":1,\"985\":5,\"1022\":1,\"1029\":2,\"1030\":5,\"1031\":1,\"1621\":1}}],[\"user2\",{\"1\":{\"582\":2,\"961\":4}}],[\"user2这个路径得到\",{\"1\":{\"334\":1}}],[\"user2和user4根据身份证号算出来的值都是n\",{\"1\":{\"332\":1}}],[\"userfactorybylookup\",{\"1\":{\"936\":3}}],[\"userfactorybean\",{\"1\":{\"930\":2}}],[\"userfactoryserviceloader\",{\"1\":{\"930\":2}}],[\"userfactory\",{\"1\":{\"918\":2,\"930\":10,\"931\":12,\"933\":13,\"936\":9}}],[\"userf\",{\"1\":{\"334\":1}}],[\"userc\",{\"1\":{\"334\":1}}],[\"user\",{\"1\":{\"309\":6,\"318\":1,\"322\":1,\"356\":2,\"431\":1,\"472\":1,\"479\":1,\"917\":20,\"918\":1,\"921\":10,\"927\":2,\"929\":11,\"930\":19,\"941\":1,\"943\":5,\"944\":5,\"951\":4,\"953\":22,\"954\":4,\"955\":3,\"956\":3,\"961\":58,\"962\":4,\"963\":8,\"967\":1,\"972\":4,\"973\":4,\"978\":3,\"985\":44,\"989\":20,\"994\":11,\"996\":1,\"997\":5,\"1000\":5,\"1001\":12,\"1002\":8,\"1003\":11,\"1005\":19,\"1006\":6,\"1007\":3,\"1008\":1,\"1009\":1,\"1011\":6,\"1012\":4,\"1019\":13,\"1022\":10,\"1029\":3,\"1030\":8,\"1031\":13,\"1032\":23,\"1040\":1,\"1041\":1,\"1043\":1,\"1044\":1,\"1063\":8,\"1064\":12,\"1065\":6,\"1072\":12,\"1075\":1,\"1084\":8,\"1091\":2,\"1146\":13,\"1156\":7,\"1157\":4,\"1181\":9,\"1182\":13,\"1375\":1,\"1419\":1,\"1619\":1,\"1632\":3,\"1633\":2,\"1634\":1,\"1638\":9,\"1639\":7,\"1640\":3}}],[\"usr\",{\"1\":{\"429\":1,\"978\":1}}],[\"using\",{\"1\":{\"321\":1,\"330\":13,\"354\":1,\"356\":1,\"361\":2,\"368\":3,\"384\":2,\"390\":2,\"414\":1,\"416\":3,\"420\":1,\"429\":1,\"510\":1,\"514\":1,\"518\":1,\"519\":1,\"1055\":2,\"1121\":2,\"1167\":2,\"1168\":2,\"1171\":1,\"1550\":1,\"1554\":1,\"1615\":5,\"1616\":1,\"1618\":3,\"1619\":1,\"1620\":8,\"1647\":1}}],[\"u$user\",{\"1\":{\"318\":1,\"454\":1}}],[\"udp的特点\",{\"1\":{\"1419\":1}}],[\"udp\",{\"1\":{\"1419\":1}}],[\"ud\",{\"1\":{\"304\":1}}],[\"查表判断\",{\"0\":{\"477\":1}}],[\"查新慢查询日志的总记录条数\",{\"1\":{\"428\":1}}],[\"查出表t1的所有数据\",{\"1\":{\"401\":1}}],[\"查出来的trx\",{\"1\":{\"497\":1}}],[\"查出来有多条记录\",{\"1\":{\"330\":1}}],[\"查出来只有一条记录\",{\"1\":{\"330\":1}}],[\"查看是否有\",{\"1\":{\"1630\":1}}],[\"查看non\",{\"1\":{\"1621\":1}}],[\"查看atomic\",{\"1\":{\"1479\":1}}],[\"查看容器情况\",{\"1\":{\"1460\":1}}],[\"查看活跃的频道\",{\"1\":{\"598\":1}}],[\"查看订阅与发布系统状态\",{\"1\":{\"597\":1}}],[\"查看哈希表\",{\"1\":{\"573\":1}}],[\"查看mylist的长度\",{\"1\":{\"571\":1}}],[\"查看列表长度\",{\"1\":{\"571\":1}}],[\"查看key的过期剩余时间\",{\"1\":{\"569\":1}}],[\"查看value的数据类型\",{\"1\":{\"569\":2}}],[\"查看数据库大小\",{\"1\":{\"567\":1}}],[\"查看某个表索引的统计数据可以使用show\",{\"1\":{\"553\":1}}],[\"查看锁等待详细信息\",{\"1\":{\"538\":1}}],[\"查看锁等待\",{\"1\":{\"538\":1}}],[\"查看锁\",{\"1\":{\"538\":1}}],[\"查看事务\",{\"1\":{\"538\":1}}],[\"查看information\",{\"1\":{\"538\":1}}],[\"查看表上加过的锁\",{\"1\":{\"534\":1}}],[\"查看trace字段可知索引扫描的成本低于全表扫描\",{\"1\":{\"519\":1}}],[\"查看trace字段\",{\"1\":{\"519\":1}}],[\"查看商品是否发布成功\",{\"1\":{\"470\":1}}],[\"查看binlog中的内容\",{\"1\":{\"454\":1}}],[\"查看结果\",{\"1\":{\"431\":1}}],[\"查看system源码可以发现out实际上是printstream的一个对象\",{\"1\":{\"1605\":1}}],[\"查看studentx中所有的value\",{\"1\":{\"573\":1}}],[\"查看studentx中所有的field\",{\"1\":{\"573\":1}}],[\"查看studentx中的字段数量\",{\"1\":{\"573\":1}}],[\"查看show\",{\"1\":{\"431\":1}}],[\"查看sql执行计划\",{\"1\":{\"362\":2,\"363\":1}}],[\"查看long\",{\"1\":{\"428\":1}}],[\"查看慢查询日志是否开启\",{\"1\":{\"428\":2}}],[\"查看慢查询日志是否开以及如何开启\",{\"1\":{\"428\":1}}],[\"查看该查询扫描的行数是非常有帮助的\",{\"1\":{\"389\":1}}],[\"查看上述sql的执行计划\",{\"1\":{\"372\":1}}],[\"查看当前指定的所依赖的bean是否都已经注入完成\",{\"1\":{\"1647\":1}}],[\"查看当前命令的不稳定指令\",{\"1\":{\"1453\":1}}],[\"查看当前库的信息\",{\"1\":{\"609\":1}}],[\"查看当前数据库所有key\",{\"1\":{\"569\":1}}],[\"查看当前数据库中所有的key\",{\"1\":{\"567\":1}}],[\"查看当前数据库的事务隔离级别\",{\"1\":{\"532\":1}}],[\"查看当前的索引\",{\"1\":{\"361\":1}}],[\"查看当前索引\",{\"1\":{\"361\":1}}],[\"查看现在sql语句的执行计划\",{\"1\":{\"361\":1}}],[\"查看\",{\"1\":{\"354\":1,\"421\":1}}],[\"查看所有容器的命令\",{\"0\":{\"259\":1,\"1461\":1}}],[\"查找注入点\",{\"1\":{\"1648\":1}}],[\"查找键值对\",{\"1\":{\"1548\":1}}],[\"查找等算法\",{\"1\":{\"1546\":1}}],[\"查找条件\",{\"1\":{\"1121\":1}}],[\"查找messagesource\",{\"1\":{\"1056\":1}}],[\"查找来源\",{\"1\":{\"972\":1}}],[\"查找的复杂度都是o\",{\"1\":{\"572\":1}}],[\"查找\",{\"1\":{\"429\":1}}],[\"查找和判断下一条记录\",{\"1\":{\"342\":1}}],[\"查找到的所有的user集合对象\",{\"1\":{\"917\":1,\"921\":2,\"941\":1}}],[\"查找到的所有标注\",{\"1\":{\"917\":1,\"941\":1}}],[\"查找到位置后\",{\"1\":{\"345\":1}}],[\"查找到第一个满足条件的记录后\",{\"1\":{\"342\":1}}],[\"查找到第一个符合条件的记录是id3\",{\"1\":{\"339\":1}}],[\"查找到满足条件的第一个记录\",{\"1\":{\"342\":1}}],[\"查找一个值最多只需要访问3次从盘\",{\"1\":{\"334\":1}}],[\"查找成本都很高\",{\"1\":{\"324\":1}}],[\"查询redis命令的中文网站\",{\"1\":{\"1975\":1}}],[\"查询消息\",{\"0\":{\"1922\":1}}],[\"查询\",{\"0\":{\"1918\":1},\"1\":{\"1621\":1}}],[\"查询效率降低的问题\",{\"1\":{\"1475\":1}}],[\"查询结果按照userid来排序\",{\"1\":{\"1270\":1}}],[\"查询结果太大\",{\"1\":{\"431\":1}}],[\"查询数据的原理\",{\"1\":{\"1256\":1}}],[\"查询方式\",{\"1\":{\"1254\":1}}],[\"查询经纬度\",{\"1\":{\"576\":1}}],[\"查询m5是否是myset的成员\",{\"1\":{\"572\":1}}],[\"查询member元素是否是集合的成员\",{\"1\":{\"572\":1}}],[\"查询mysql自己维护的总行数\",{\"1\":{\"526\":1}}],[\"查询mysql页大小\",{\"1\":{\"503\":1}}],[\"查询s1表总共的成本\",{\"1\":{\"555\":1}}],[\"查询s2表大致需要扫描321条记录\",{\"1\":{\"555\":1}}],[\"查询五\",{\"1\":{\"554\":1}}],[\"查询四\",{\"1\":{\"554\":1}}],[\"查询二\",{\"1\":{\"554\":1}}],[\"查询count需要实时计算\",{\"1\":{\"526\":1}}],[\"查询category\",{\"1\":{\"361\":1}}],[\"查询不需要计算\",{\"1\":{\"526\":1}}],[\"查询不需要的记录\",{\"0\":{\"383\":1}}],[\"查询的sql如下\",{\"1\":{\"522\":1}}],[\"查询的生命周期可以按照顺序来看\",{\"1\":{\"381\":1}}],[\"查询可能使用的索引\",{\"1\":{\"519\":1}}],[\"查询成本\",{\"1\":{\"519\":1,\"553\":1}}],[\"查询到\",{\"1\":{\"459\":1}}],[\"查询时间\",{\"1\":{\"429\":1}}],[\"查询性能就会比较慢\",{\"1\":{\"426\":1}}],[\"查询性能低下最基本的原因是访问的数据太多\",{\"1\":{\"381\":1}}],[\"查询表的总行数\",{\"1\":{\"396\":2}}],[\"查询本身效率也可能会有所提升\",{\"1\":{\"394\":1}}],[\"查询解析和优化是一件代价很高的事情\",{\"1\":{\"392\":1}}],[\"查询返回超过需要的数据也不总是坏事\",{\"1\":{\"385\":1}}],[\"查询需要在不同的地方花费时间\",{\"1\":{\"381\":1}}],[\"查询优化等操作\",{\"1\":{\"557\":1}}],[\"查询优化器需要分别考虑这两情况下的最优查询成本\",{\"1\":{\"555\":1}}],[\"查询优化器在计算驱动表扇出时\",{\"1\":{\"554\":1}}],[\"查询优化器又不会真正的去执行查询\",{\"1\":{\"554\":1}}],[\"查询优化器认为读取索引的一个范围区间的io成本和读取一个页面是相同的\",{\"1\":{\"549\":1}}],[\"查询优化器认为这种访问类型可以高效地完成查询\",{\"1\":{\"390\":1}}],[\"查询优化\",{\"0\":{\"526\":1},\"1\":{\"381\":1}}],[\"查询一次s1表大致需要扫描1条记录\",{\"1\":{\"555\":1}}],[\"查询一\",{\"1\":{\"554\":1}}],[\"查询一定不用\",{\"1\":{\"373\":1}}],[\"查询一条数据需要两个对象\",{\"1\":{\"307\":1}}],[\"查询范围的字段使用到了索引\",{\"1\":{\"372\":1}}],[\"查询过程\",{\"0\":{\"342\":1}}],[\"查询条件里面只有b的语句\",{\"1\":{\"339\":1}}],[\"查询涉及到的字段上若存在索引\",{\"1\":{\"330\":1}}],[\"查询中统计或者分组字段\",{\"1\":{\"358\":1}}],[\"查询中排序的字段\",{\"1\":{\"358\":1}}],[\"查询中与其他表关联的字段\",{\"1\":{\"358\":1}}],[\"查询中如果使用了覆盖索引\",{\"1\":{\"330\":1}}],[\"查询中如果包含任何复杂的子部分\",{\"1\":{\"330\":1}}],[\"查询中不包含子查询或者union\",{\"1\":{\"330\":1}}],[\"查询缓存的命中率会非常低\",{\"1\":{\"319\":1}}],[\"查询缓存的失效非常频繁\",{\"1\":{\"319\":1}}],[\"查询缓存\",{\"0\":{\"319\":1},\"1\":{\"317\":1,\"319\":1,\"557\":1}}],[\"查询语句和search相同\",{\"1\":{\"307\":1}}],[\"查询年龄大于28前的\",{\"1\":{\"306\":1}}],[\"查询年龄小于等于28岁的\",{\"1\":{\"306\":1}}],[\"查询前10条文档\",{\"1\":{\"306\":1}}],[\"查询文档有两种方式\",{\"1\":{\"306\":1}}],[\"查询文档\",{\"1\":{\"306\":2}}],[\"全局有序\",{\"0\":{\"1862\":1}}],[\"全局锁对比\",{\"0\":{\"438\":1}}],[\"全局锁的典型使用场景是\",{\"1\":{\"437\":1}}],[\"全局锁的特点\",{\"0\":{\"437\":1}}],[\"全局锁就是对整个数据库实例加锁\",{\"1\":{\"437\":1}}],[\"全局锁\",{\"0\":{\"436\":1},\"1\":{\"1263\":1}}],[\"全盘负责是指当一个classloader装在一个类时\",{\"1\":{\"1663\":1}}],[\"全盘负责委托机制\",{\"1\":{\"1663\":1}}],[\"全程都没有通过\",{\"1\":{\"1583\":1}}],[\"全文搜索属于最常见的需求\",{\"1\":{\"1986\":1}}],[\"全文索引\",{\"1\":{\"1276\":1}}],[\"全文检索是指\",{\"1\":{\"299\":1}}],[\"全部建立到联合索引当中\",{\"1\":{\"1268\":1}}],[\"全部应用到临时库\",{\"1\":{\"485\":1}}],[\"全部同步完成\",{\"1\":{\"467\":1}}],[\"全库只读除了使用ftwrl\",{\"1\":{\"438\":1}}],[\"全值匹配\",{\"1\":{\"378\":1}}],[\"全值匹配我最爱\",{\"1\":{\"369\":1}}],[\"全字段排序和rowid排序对比\",{\"0\":{\"356\":1}}],[\"全字段排序\",{\"0\":{\"354\":1}}],[\"全表扫描tracer的输出\",{\"1\":{\"551\":1}}],[\"全表扫描的成本\",{\"1\":{\"551\":1}}],[\"全表扫描的成本低于索引扫描\",{\"1\":{\"519\":1}}],[\"全表扫描的意思就是把聚簇索引中的记录都一次和给定的搜索条件做一下比较\",{\"1\":{\"548\":1}}],[\"全表扫描情况\",{\"1\":{\"519\":1}}],[\"全表扫描\",{\"1\":{\"330\":1,\"362\":1,\"374\":1,\"375\":3,\"376\":1,\"519\":1}}],[\"全索引扫描\",{\"1\":{\"330\":1}}],[\"全量复制\",{\"0\":{\"615\":1}}],[\"全量修改原文档\",{\"1\":{\"307\":1}}],[\"全量更新\",{\"1\":{\"306\":1}}],[\"也难以形成自己的知识体系\",{\"1\":{\"1972\":1}}],[\"也满足了intconsumer的要求\",{\"1\":{\"1620\":1}}],[\"也想求出总和\",{\"1\":{\"1610\":1}}],[\"也想求出最小值\",{\"1\":{\"1610\":1}}],[\"也举出了不少的例子来展示了lambda表达式的应用\",{\"1\":{\"1607\":1}}],[\"也接收了两个不同类型的参数\",{\"1\":{\"1601\":1}}],[\"也已经不再map中了\",{\"1\":{\"1551\":1}}],[\"也避免不了拉链过长的情况\",{\"1\":{\"1546\":1}}],[\"也加入例如高位参与运算的过程\",{\"1\":{\"1546\":1}}],[\"也加上了间隙锁\",{\"1\":{\"448\":1}}],[\"也被称为多线程版本的if\",{\"1\":{\"1530\":1}}],[\"也需要30万年才能用完\",{\"1\":{\"1519\":1}}],[\"也需要将where条件修改为where\",{\"1\":{\"366\":1}}],[\"也叫重量级锁\",{\"1\":{\"1484\":1}}],[\"也叫膨胀锁\",{\"1\":{\"1484\":1}}],[\"也叫做匿名偏向状态\",{\"1\":{\"1485\":1}}],[\"也叫做监视器锁\",{\"1\":{\"1482\":1}}],[\"也叫做改进的三次握手\",{\"1\":{\"1425\":1}}],[\"也没有了访问共享资源加锁的性能损耗\",{\"1\":{\"1292\":1}}],[\"也没有办法记录实例的存在\",{\"1\":{\"985\":1}}],[\"也带来了一定的缺点\",{\"1\":{\"1270\":1}}],[\"也早于postconstruct\",{\"1\":{\"973\":1}}],[\"也能把这些题目都顺利的写出来\",{\"1\":{\"1972\":1}}],[\"也能保证考虑到高低bit都参与到hash的计算中\",{\"1\":{\"1548\":1}}],[\"也能帮助我们去实现ioc\",{\"1\":{\"914\":1}}],[\"也能够运行每秒超过10万的查询\",{\"1\":{\"392\":1}}],[\"也能够直接查到id2\",{\"1\":{\"350\":1}}],[\"也只能算作一个人\",{\"1\":{\"577\":1}}],[\"也代表不存在\",{\"1\":{\"571\":1}}],[\"也即是说优化器就直接会把10573当作s1表的扇出值\",{\"1\":{\"554\":1}}],[\"也正是这样\",{\"1\":{\"491\":1}}],[\"也正是由于这个特性\",{\"1\":{\"410\":1}}],[\"也要发回给主库a\",{\"1\":{\"478\":1}}],[\"也要确保一次性写入\",{\"1\":{\"450\":1}}],[\"也表示备库接收到的日志都已经同步完成\",{\"1\":{\"472\":1}}],[\"也跳过了\",{\"1\":{\"467\":1}}],[\"也就缩短了整个数据恢复需要的时间\",{\"1\":{\"486\":1}}],[\"也就达到了sleep的目的\",{\"1\":{\"471\":1}}],[\"也就不会再出现主键冲突的错误\",{\"1\":{\"468\":1}}],[\"也就意味着\",{\"1\":{\"460\":1}}],[\"也就是代理逻辑\",{\"1\":{\"1654\":1}}],[\"也就是变成一个负数\",{\"1\":{\"1554\":1}}],[\"也就是数组的长度\",{\"1\":{\"1550\":1}}],[\"也就是使用了单链表的头插入方式\",{\"1\":{\"1550\":1}}],[\"也就是等于h\",{\"1\":{\"1548\":1}}],[\"也就是保持了不变性\",{\"1\":{\"1526\":1}}],[\"也就是对于cpu密集型任务\",{\"1\":{\"1510\":1}}],[\"也就是对应着聚簇索引中39条完整的用户记录\",{\"1\":{\"549\":1}}],[\"也就是在condition队列中\",{\"1\":{\"1490\":1}}],[\"也就是在本地打开一片内存\",{\"1\":{\"482\":1}}],[\"也就是unpark\",{\"1\":{\"1490\":1}}],[\"也就是compare\",{\"1\":{\"1479\":1}}],[\"也就是将store\",{\"1\":{\"1473\":1}}],[\"也就是将整库的每个表都select出来存成文本\",{\"1\":{\"437\":1}}],[\"也就是常量对象\",{\"1\":{\"1342\":1}}],[\"也就是一个beanpostprocessor\",{\"1\":{\"1655\":1}}],[\"也就是一个mapper\",{\"1\":{\"1218\":1}}],[\"也就是一个表中有多少条记录\",{\"1\":{\"553\":1}}],[\"也就是允许mapper内的方法重载\",{\"1\":{\"1208\":1}}],[\"也就是用户关联角色\",{\"1\":{\"1199\":1}}],[\"也就是所谓的延迟依赖查找\",{\"1\":{\"1181\":1}}],[\"也就是所有存在于set\",{\"1\":{\"468\":1}}],[\"也就是可以将当前的客户端描述符write\",{\"1\":{\"605\":1}}],[\"也就是可能会导致主备同步停止\",{\"1\":{\"478\":1}}],[\"也就是当entrylist为空时\",{\"1\":{\"1483\":1}}],[\"也就是当run方法完成后线程终止\",{\"1\":{\"1379\":1}}],[\"也就是当数据到来时\",{\"1\":{\"603\":1}}],[\"也就是当系统里没有比这个回滚日志更早的read\",{\"1\":{\"434\":1}}],[\"也就是即使表中变动的记录数超过了10\",{\"1\":{\"559\":1}}],[\"也就是该功能默认是开启的\",{\"1\":{\"559\":1}}],[\"也就是组件\",{\"1\":{\"558\":1}}],[\"也就是统计数据默认被存储到磁盘中\",{\"1\":{\"558\":1}}],[\"也就是n\",{\"1\":{\"556\":1}}],[\"也就是s2作为驱动表\",{\"1\":{\"555\":1}}],[\"也就是s1作为驱动表\",{\"1\":{\"555\":1}}],[\"也就是session\",{\"1\":{\"497\":1}}],[\"也就是semi\",{\"1\":{\"472\":1}}],[\"也就是\",{\"1\":{\"553\":1}}],[\"也就是我们计算出来的值\",{\"1\":{\"551\":1}}],[\"也就是需要考虑最优的表连接顺序\",{\"1\":{\"555\":1}}],[\"也就是需要进行多少次页面io\",{\"1\":{\"549\":1}}],[\"也就是需要再多搭建一些备库来增加系统的读能力的时候\",{\"1\":{\"327\":1}}],[\"也就是页a\",{\"1\":{\"549\":1}}],[\"也就是possible\",{\"1\":{\"547\":1}}],[\"也就是目前已出现过的事务id的最大值+1\",{\"1\":{\"542\":1}}],[\"也就是为事务分配单向增长的时间戳\",{\"1\":{\"541\":1}}],[\"也就是总共t1表也扫描了100行\",{\"1\":{\"524\":1}}],[\"也就是总共扫描100行\",{\"1\":{\"401\":1}}],[\"也就是把表t的当前自增值改回2\",{\"1\":{\"491\":1}}],[\"也就是才实现了\",{\"1\":{\"490\":1}}],[\"也就是只需要猜39条记录中有多少符合order\",{\"1\":{\"554\":1}}],[\"也就是只重放这张表的操作\",{\"1\":{\"485\":1}}],[\"也就是只留在了文件系统的page\",{\"1\":{\"451\":1}}],[\"也就是全局事务id\",{\"1\":{\"468\":1}}],[\"也就是主库对应的文件名和日志偏移量\",{\"1\":{\"467\":1}}],[\"也就是a和a\",{\"1\":{\"466\":1}}],[\"也就是a=5这一行\",{\"1\":{\"454\":1}}],[\"也就是readonly=false\",{\"1\":{\"458\":1}}],[\"也就是t3\",{\"1\":{\"457\":1}}],[\"也就是循环复制了\",{\"1\":{\"455\":1}}],[\"也就是下图所展示的主备切换流程\",{\"1\":{\"455\":1}}],[\"也就是下面的这个过程\",{\"1\":{\"417\":1}}],[\"也就是mixed格式的binlog\",{\"1\":{\"454\":1}}],[\"也就是mvcc来实现的\",{\"1\":{\"396\":1}}],[\"也就是备库\",{\"1\":{\"453\":1}}],[\"也就是死锁\",{\"1\":{\"444\":1}}],[\"也就是超时后会再起一个新的session\",{\"1\":{\"441\":1}}],[\"也就是根据每个用户级别有一个单词表\",{\"1\":{\"419\":1}}],[\"也就是没有proxy这一层\",{\"1\":{\"411\":1}}],[\"也就是是否满足t2\",{\"1\":{\"407\":1}}],[\"也就是扫描了200行\",{\"1\":{\"401\":1}}],[\"也就是扫描了4行\",{\"1\":{\"350\":1}}],[\"也就是不需要排序了\",{\"1\":{\"356\":1}}],[\"也就是步骤7\",{\"1\":{\"355\":1}}],[\"也就是图中绿色部分\",{\"1\":{\"451\":1}}],[\"也就是图中的黄色部分\",{\"1\":{\"451\":1}}],[\"也就是图中的id\",{\"1\":{\"354\":1,\"355\":2}}],[\"也就是图中右下角的这个数据页\",{\"1\":{\"342\":1}}],[\"也就是这个页面上要更新的次数越多\",{\"1\":{\"344\":1}}],[\"也就是尽量使用长连接\",{\"1\":{\"318\":1}}],[\"也就是从连接器到执行器的部分\",{\"1\":{\"317\":1}}],[\"也就是说无论对于串行操作还是并行操作\",{\"1\":{\"1615\":1}}],[\"也就是说数据被拷贝到操作系统内核的缓冲区是需要一个过程的\",{\"1\":{\"1563\":1}}],[\"也就是说需要扩容\",{\"1\":{\"1554\":1}}],[\"也就是说不存在哈希冲突\",{\"1\":{\"1554\":1}}],[\"也就是说当put第二个元素的时候\",{\"1\":{\"1551\":1}}],[\"也就是说linkedblockingqueue是读写分离的\",{\"1\":{\"1503\":1}}],[\"也就是说只能有一个线程可以进行入队或者出队操作\",{\"1\":{\"1502\":1}}],[\"也就是说只要有一个满足条件就会调用fsync\",{\"1\":{\"451\":1}}],[\"也就是说初始化之后\",{\"1\":{\"1121\":1}}],[\"也就是说主节点自身处理完写命令后直接返回给客户端\",{\"1\":{\"618\":1}}],[\"也就是说innodb的统计数据默认是存储到内存的\",{\"1\":{\"558\":1}}],[\"也就是说in语句中的参数个数小于200的话\",{\"1\":{\"553\":1}}],[\"也就是说服务器重启之后这些统计数据还在\",{\"1\":{\"558\":1}}],[\"也就是说一条语句在server中执行的成本是和它操作的表使用的存储引擎是没有关系的\",{\"1\":{\"557\":1}}],[\"也就是说优化器需要猜在39条记录中有多少符合上述两个条件\",{\"1\":{\"554\":1}}],[\"也就是说相当于3个单点区间\",{\"1\":{\"549\":1}}],[\"也就是说二级索引范围区间有多少记录\",{\"1\":{\"549\":1}}],[\"也就是说对于任意的输入t1和t2\",{\"1\":{\"1615\":1}}],[\"也就是说对应的范围区间是\",{\"1\":{\"549\":1}}],[\"也就是说对与优化器来说\",{\"1\":{\"367\":1}}],[\"也就是说全表扫描这个过程其实有的b+树非叶子结点是不需要访问的\",{\"1\":{\"548\":1}}],[\"也就是说可以对这个注解进行一些自定义的扩展\",{\"1\":{\"961\":1}}],[\"也就是说可以这样计算该值的大小\",{\"1\":{\"548\":1}}],[\"也就是说可以用上被驱动表上的索引\",{\"1\":{\"403\":1}}],[\"也就是说重启mysql\",{\"1\":{\"497\":1}}],[\"也就是说等行锁\",{\"1\":{\"476\":1}}],[\"也就是说在状态3执行查询请求\",{\"1\":{\"472\":1}}],[\"也就是说如果之后有新的事务再执行\",{\"1\":{\"468\":1}}],[\"也就是说它们的writeset没有交集\",{\"1\":{\"465\":1}}],[\"也就是说删除的是a=4这一行\",{\"1\":{\"454\":1}}],[\"也就是说这个读写过程是阻塞的\",{\"1\":{\"1568\":1}}],[\"也就是说这个时候系统处于不可写状态\",{\"1\":{\"458\":1}}],[\"也就是说这个sql需要临时表\",{\"1\":{\"420\":1}}],[\"也就是说这时候\",{\"1\":{\"448\":1}}],[\"也就是说幻读的问题还是没有解决\",{\"1\":{\"447\":1}}],[\"也就是说2017\",{\"1\":{\"424\":1}}],[\"也就是说要在应用线程里面先后执行这个create语句两次\",{\"1\":{\"413\":1}}],[\"也就是说还是会增加扫描行数\",{\"1\":{\"352\":1}}],[\"也就是说两个不同的身份证通过crc32\",{\"1\":{\"352\":1}}],[\"也就是说前缀索引就用不上覆盖索引对查询性能的优化了\",{\"1\":{\"351\":1}}],[\"也就是说取email字段的前7个字节来构建索引的话\",{\"1\":{\"350\":1}}],[\"也就是说必须同时维护\",{\"1\":{\"339\":1}}],[\"也就是说虽然all和index都是读全表\",{\"1\":{\"330\":1}}],[\"也就是说8\",{\"1\":{\"319\":1}}],[\"也就是说\",{\"1\":{\"306\":1,\"335\":2,\"338\":2,\"342\":1,\"343\":1,\"346\":1,\"347\":2,\"350\":1,\"356\":1,\"366\":2,\"367\":1,\"403\":1,\"404\":2,\"405\":1,\"406\":1,\"412\":1,\"416\":2,\"424\":2,\"441\":1,\"443\":2,\"446\":1,\"447\":2,\"448\":1,\"451\":3,\"454\":1,\"457\":1,\"459\":2,\"461\":1,\"465\":1,\"469\":1,\"471\":1,\"472\":1,\"476\":2,\"481\":3,\"482\":2,\"484\":1,\"485\":1,\"490\":1,\"491\":1,\"492\":2,\"495\":1,\"497\":1,\"528\":1,\"548\":1,\"551\":1,\"1479\":2,\"1498\":1,\"1546\":1,\"1563\":1,\"1564\":1,\"1576\":1,\"1594\":2,\"1595\":1,\"1607\":1,\"1617\":1,\"1664\":1}}],[\"也就是要确定id才能进行更新\",{\"1\":{\"306\":1}}],[\"也减少了死锁检测的cpu消耗\",{\"1\":{\"444\":1}}],[\"也称为next\",{\"1\":{\"442\":1}}],[\"也限定了本线程接下来的操作对象\",{\"1\":{\"440\":1}}],[\"也许是调度器先于低优先级的线程而执行高优先级的线程\",{\"1\":{\"1390\":1}}],[\"也许数据只有20gb\",{\"1\":{\"434\":1}}],[\"也许你想到show\",{\"1\":{\"396\":1}}],[\"也有注入方法的方法\",{\"1\":{\"1648\":1}}],[\"也有可能将底层的流修改为并行流\",{\"1\":{\"1619\":1}}],[\"也有可能会将底层的流修改为串行流\",{\"1\":{\"1619\":1}}],[\"也有可能是t类型以上的类型\",{\"1\":{\"1614\":1}}],[\"也有可能是该行记录的undo\",{\"1\":{\"542\":1}}],[\"也有访问底层硬件设备的权限\",{\"1\":{\"1579\":1}}],[\"也有一些其他的成本常数\",{\"1\":{\"545\":1}}],[\"也有一些方案会让客户端直接连接数据\",{\"1\":{\"411\":1}}],[\"也有自动化系统\",{\"1\":{\"488\":1}}],[\"也有些访问方式可能无需扫描就能返回结果\",{\"1\":{\"390\":1}}],[\"也无法声明返回一个函数的方法\",{\"1\":{\"1593\":1}}],[\"也无法让保存s2报价的操作先执行\",{\"1\":{\"1517\":1}}],[\"也无法使用它来进行统计\",{\"1\":{\"396\":1}}],[\"也无法实现高性能\",{\"1\":{\"381\":1}}],[\"也是\",{\"1\":{\"1982\":1}}],[\"也是最有难度的知识\",{\"1\":{\"1972\":1}}],[\"也是用来遍历元当中的元素的\",{\"1\":{\"1620\":1}}],[\"也是这几个基础的函数式接口的特例\",{\"1\":{\"1601\":1}}],[\"也是函数式编程中一个及其重要的概念\",{\"1\":{\"1593\":1}}],[\"也是java8中新增的一个语法糖\",{\"1\":{\"1593\":1}}],[\"也是操作系统真正意义上的零拷贝\",{\"1\":{\"1584\":1}}],[\"也是一样的\",{\"1\":{\"1580\":1}}],[\"也是一起持久化的\",{\"1\":{\"451\":1}}],[\"也是存竞争锁失败的线程\",{\"1\":{\"1483\":1}}],[\"也是起存储的作用\",{\"1\":{\"1019\":1}}],[\"也是初始化bean的时候的顺序\",{\"1\":{\"963\":1}}],[\"也是处理的最好的自增id逻辑\",{\"1\":{\"499\":1}}],[\"也是要对应一个只读事务的\",{\"1\":{\"497\":1}}],[\"也是要先停止正在执行的语句\",{\"1\":{\"480\":1}}],[\"也是将delete\",{\"1\":{\"484\":1}}],[\"也是关于客户端常见的一个误解\",{\"1\":{\"482\":1}}],[\"也是可以省略的\",{\"1\":{\"1593\":1}}],[\"也是可以接受的\",{\"1\":{\"470\":1}}],[\"也是可能持久化到磁盘的\",{\"1\":{\"451\":1}}],[\"也是为每个worker\",{\"1\":{\"462\":1}}],[\"也是不合适的\",{\"1\":{\"1509\":1}}],[\"也是不能被接受的\",{\"1\":{\"459\":1}}],[\"也是不确定的\",{\"1\":{\"396\":1}}],[\"也是破坏了q1的加锁声明\",{\"1\":{\"447\":1}}],[\"也是找到需要更新的所有分表\",{\"1\":{\"424\":1}}],[\"也是往后推移并且循环的\",{\"1\":{\"324\":1}}],[\"也把数字存起来呢\",{\"1\":{\"396\":1}}],[\"也都是\",{\"1\":{\"368\":1}}],[\"也不能直接调用内核函数的\",{\"1\":{\"1579\":1}}],[\"也不能绑定一些简单的类型\",{\"1\":{\"952\":1}}],[\"也不能分给多个不同的worker去执行\",{\"1\":{\"460\":1}}],[\"也不是服务端慢\",{\"1\":{\"482\":1}}],[\"也不需要再额外的排序\",{\"1\":{\"417\":1}}],[\"也不需要排序了\",{\"1\":{\"417\":1}}],[\"也不需要排序\",{\"1\":{\"356\":1}}],[\"也不具备通用性\",{\"1\":{\"348\":1}}],[\"也不会扩容\",{\"1\":{\"1501\":1}}],[\"也不会执行撤销操作\",{\"1\":{\"1485\":1}}],[\"也不会等语句执行完成才释放锁\",{\"1\":{\"492\":1}}],[\"也不会触发叶子节点的分裂\",{\"1\":{\"335\":1}}],[\"也不会影响已经存在连接的权限\",{\"1\":{\"318\":1}}],[\"也判定为代价更小\",{\"1\":{\"348\":1}}],[\"也会处理\",{\"1\":{\"1648\":1}}],[\"也会增加不确定的风险\",{\"1\":{\"1620\":1}}],[\"也会在内部为每个线程分配持有的存储空间的模式\",{\"1\":{\"1528\":1}}],[\"也会利用copy\",{\"1\":{\"1527\":1}}],[\"也会适当对指令进行重排\",{\"1\":{\"1405\":1}}],[\"也会立即返回\",{\"1\":{\"603\":1}}],[\"也会等1秒\",{\"1\":{\"471\":1}}],[\"也会暂时退化为单线程模型\",{\"1\":{\"465\":1}}],[\"也会释放掉\",{\"1\":{\"444\":1}}],[\"也会将其记录到binlog中\",{\"1\":{\"413\":1}}],[\"也会执行merge操作\",{\"1\":{\"343\":1}}],[\"也会被写入到磁盘上\",{\"1\":{\"343\":1}}],[\"也可能效率会变低\",{\"1\":{\"1615\":1}}],[\"也可能返回一个新的结果容器\",{\"1\":{\"1615\":1}}],[\"也可能返回其他类型的单个值\",{\"1\":{\"1611\":1}}],[\"也可能使用到统计数据\",{\"1\":{\"554\":1}}],[\"也可能收到io资源影响耗时较久\",{\"1\":{\"481\":1}}],[\"也可能是被动操作\",{\"1\":{\"457\":1}}],[\"也可能是等待行锁\",{\"1\":{\"388\":1}}],[\"也可能被分配到从库的同一个worker中执行\",{\"1\":{\"413\":1}}],[\"也可能需要使用外部排序\",{\"1\":{\"354\":1}}],[\"也可能出现在文章内容中\",{\"1\":{\"300\":1}}],[\"也可以用来以来注入\",{\"1\":{\"1648\":1}}],[\"也可以是接口的实现类或者内部类\",{\"1\":{\"1652\":1}}],[\"也可以是一个生成器函数\",{\"1\":{\"1620\":1}}],[\"也可以是字符串索引的最左m个字符\",{\"1\":{\"339\":1}}],[\"也可以调用另一个方法\",{\"1\":{\"1607\":1}}],[\"也可以自动扩容\",{\"1\":{\"1509\":1}}],[\"也可以使用foreachremaining成块的遍历元素\",{\"1\":{\"1620\":1}}],[\"也可以使用方法引用的方式来实现\",{\"1\":{\"1614\":2}}],[\"也可以使用方法引用来替代\",{\"1\":{\"1604\":1}}],[\"也可以使用\",{\"1\":{\"1479\":1,\"1654\":1}}],[\"也可以使用父类的功能\",{\"1\":{\"1340\":1}}],[\"也可以使用show\",{\"1\":{\"526\":1}}],[\"也可以回滚数据\",{\"1\":{\"1271\":1}}],[\"也可以采用threadlocal来解决线程安全的问题\",{\"1\":{\"1236\":1}}],[\"也可以说spring容器中的bean不是线程安全的\",{\"1\":{\"1236\":1}}],[\"也可以通过\",{\"1\":{\"1147\":1}}],[\"也可以注入optional类型的字段\",{\"1\":{\"963\":1}}],[\"也可以简单的说\",{\"1\":{\"590\":1}}],[\"也可以指定排序的比较器\",{\"1\":{\"1544\":1}}],[\"也可以指定统计范围按字节\",{\"1\":{\"578\":1}}],[\"也可以指定返回值source\",{\"1\":{\"307\":1}}],[\"也可以将总数维护到redis里\",{\"1\":{\"526\":1}}],[\"也可以从表test2里面取出name=jyc的记录的id值\",{\"1\":{\"514\":1}}],[\"也可以从number\",{\"1\":{\"354\":1}}],[\"也可以跳过这个阶段\",{\"1\":{\"482\":1}}],[\"也可以在defaultlistablebeanfactory\",{\"1\":{\"1181\":1}}],[\"也可以在mysql里面做\",{\"1\":{\"444\":1}}],[\"也可以在客户端断开的时候自动释放\",{\"1\":{\"440\":1}}],[\"也可以在请求的payload中进行\",{\"1\":{\"307\":1}}],[\"也可以选择遍历索引t\",{\"1\":{\"366\":1}}],[\"也可以创建一个普通索引\",{\"1\":{\"341\":1}}],[\"也可以有多叉\",{\"1\":{\"334\":1}}],[\"也可以先从表t2里面取出d=20的记录的值\",{\"1\":{\"321\":1}}],[\"赵虎\",{\"1\":{\"306\":1}}],[\"赵六\",{\"1\":{\"306\":1}}],[\"6内核版本以上\",{\"1\":{\"1423\":1}}],[\"6内部每一次io请求的时间来判断数据库是否出现了问题会精确的多\",{\"1\":{\"479\":1}}],[\"6提供了直接执行lua脚本的方式\",{\"1\":{\"1288\":1}}],[\"666\",{\"1\":{\"1053\":1}}],[\"6+\",{\"1\":{\"897\":1}}],[\"628\",{\"1\":{\"645\":1}}],[\"62c441e80791293dccaebded\",{\"1\":{\"639\":1}}],[\"6380>\",{\"1\":{\"611\":1}}],[\"6381>\",{\"1\":{\"611\":1}}],[\"6379\",{\"1\":{\"567\":4,\"569\":2,\"582\":2,\"621\":1,\"624\":1}}],[\"6379>\",{\"1\":{\"567\":6,\"569\":17,\"570\":23,\"571\":33,\"572\":21,\"573\":19,\"574\":34,\"576\":2,\"577\":7,\"578\":9,\"579\":13,\"580\":13,\"581\":16,\"598\":4,\"609\":1,\"611\":2}}],[\"618ce3941e0853689b0818e2\",{\"1\":{\"1499\":1}}],[\"6191f070079129330ada1209\",{\"1\":{\"1494\":1}}],[\"61\",{\"1\":{\"544\":1,\"549\":5,\"551\":3,\"553\":3}}],[\"615ea79e1efad4070b2d6707\",{\"1\":{\"1657\":1}}],[\"6152cc385653bb6791db436c\",{\"1\":{\"1653\":1}}],[\"615\",{\"1\":{\"528\":1}}],[\"6s\",{\"1\":{\"544\":1,\"547\":2,\"549\":2,\"553\":2,\"554\":2}}],[\"6byte\",{\"1\":{\"542\":2}}],[\"693\",{\"1\":{\"528\":3}}],[\"65535\",{\"1\":{\"530\":1}}],[\"65\",{\"1\":{\"528\":1,\"530\":2}}],[\"6引入了索引下推优化\",{\"1\":{\"518\":1}}],[\"6以后\",{\"1\":{\"529\":1}}],[\"6以后提供的preformance\",{\"1\":{\"479\":1}}],[\"6以及之前的版本里\",{\"1\":{\"412\":1}}],[\"6的版本中\",{\"1\":{\"463\":1}}],[\"6版本中提出的\",{\"1\":{\"1571\":1}}],[\"6版本引入的\",{\"1\":{\"486\":1}}],[\"6版本引入了gtid\",{\"1\":{\"468\":1}}],[\"6版本开始\",{\"1\":{\"474\":1}}],[\"6版本的按库并行策略\",{\"1\":{\"465\":1}}],[\"6版本之前\",{\"1\":{\"460\":1}}],[\"6版本后开始引入了batched\",{\"1\":{\"405\":1}}],[\"60c8c409\",{\"1\":{\"1592\":1}}],[\"607\",{\"1\":{\"528\":1}}],[\"6074\",{\"1\":{\"519\":1}}],[\"608\",{\"1\":{\"528\":1}}],[\"60\",{\"1\":{\"434\":1,\"553\":1,\"587\":1}}],[\"600\",{\"1\":{\"335\":1,\"336\":1,\"581\":2}}],[\"6及之前的版本\",{\"1\":{\"417\":1}}],[\"64位jvm下的对象结构描述\",{\"1\":{\"1484\":1}}],[\"64位开启指针压缩或最大堆内存<32g时4字节\",{\"1\":{\"1484\":1}}],[\"64x的为例\",{\"1\":{\"1479\":1}}],[\"647\",{\"1\":{\"528\":1}}],[\"648\",{\"1\":{\"528\":1}}],[\"64\",{\"1\":{\"349\":1,\"419\":1,\"420\":1,\"555\":1,\"1479\":2,\"1506\":1,\"1664\":1}}],[\"6之后的版本中\",{\"1\":{\"544\":1}}],[\"6之后引入的索引下推优化\",{\"1\":{\"340\":1}}],[\"6之前的版本来说\",{\"1\":{\"544\":1}}],[\"6之前的版本\",{\"1\":{\"518\":1}}],[\"6之前\",{\"1\":{\"340\":1,\"558\":1}}],[\"6\",{\"1\":{\"306\":1,\"335\":1,\"336\":1,\"350\":5,\"351\":1,\"361\":1,\"368\":1,\"378\":1,\"431\":1,\"519\":2,\"549\":2,\"551\":1,\"558\":1,\"571\":4,\"572\":1,\"573\":3,\"574\":5,\"601\":1,\"1052\":1,\"1061\":1,\"1226\":1,\"1584\":1,\"1599\":2,\"1607\":4,\"1609\":1,\"1610\":6,\"1620\":1,\"1986\":1}}],[\"张图\",{\"1\":{\"1965\":1}}],[\"张\",{\"1\":{\"339\":2,\"340\":3}}],[\"张龙\",{\"1\":{\"306\":1}}],[\"张三\",{\"1\":{\"306\":4,\"339\":1,\"372\":1,\"1184\":1}}],[\"5f9512d5e401fd06fda0b2dd\",{\"1\":{\"1652\":1}}],[\"53d8d10a\",{\"1\":{\"1610\":1}}],[\"535字节\",{\"1\":{\"530\":2}}],[\"535\",{\"1\":{\"528\":1}}],[\"5倍\",{\"1\":{\"1542\":2}}],[\"5倍扩容\",{\"1\":{\"1358\":1}}],[\"5之后提供的sdk并发包也是以管程为基础的\",{\"1\":{\"1483\":1}}],[\"5之后版本做了重大的优化\",{\"1\":{\"1483\":1}}],[\"5之前\",{\"1\":{\"1483\":1}}],[\"5g\",{\"1\":{\"1330\":1,\"1331\":1}}],[\"5中提供了4个标准的用来对注解类型进行注解的注解类\",{\"1\":{\"1133\":1}}],[\"5类型接口\",{\"0\":{\"1099\":1},\"1\":{\"1099\":1}}],[\"5+\",{\"1\":{\"897\":1}}],[\"5efc2381f346fb1ae58925c1\",{\"1\":{\"645\":1}}],[\"5条记录\",{\"1\":{\"574\":1}}],[\"54s\",{\"1\":{\"571\":1}}],[\"58\",{\"1\":{\"549\":1}}],[\"58✖️1\",{\"1\":{\"549\":2}}],[\"58✖️0\",{\"1\":{\"549\":4}}],[\"55\",{\"1\":{\"549\":1,\"551\":2,\"553\":3}}],[\"551\",{\"1\":{\"528\":1}}],[\"59\",{\"1\":{\"529\":6,\"555\":5}}],[\"5秒就可以在从库上拿到正确结果\",{\"1\":{\"471\":1}}],[\"5调整到最开始执行\",{\"1\":{\"459\":1}}],[\"5版本中引入了mdl\",{\"1\":{\"441\":1}}],[\"5版本开始称为了默认的存储引擎\",{\"1\":{\"317\":1}}],[\"5及以前的版本\",{\"1\":{\"434\":1}}],[\"51\",{\"1\":{\"555\":2}}],[\"516267\",{\"1\":{\"431\":1}}],[\"51279775\",{\"1\":{\"431\":1}}],[\"520620\",{\"1\":{\"431\":1}}],[\"52105825\",{\"1\":{\"431\":1}}],[\"56\",{\"1\":{\"1605\":1}}],[\"56296725\",{\"1\":{\"431\":1}}],[\"567\",{\"1\":{\"394\":2}}],[\"507\",{\"1\":{\"528\":3}}],[\"5073\",{\"1\":{\"390\":1}}],[\"5061\",{\"1\":{\"519\":1}}],[\"5000\",{\"1\":{\"1404\":1}}],[\"50000000\",{\"1\":{\"1612\":1}}],[\"50000\",{\"1\":{\"347\":1,\"348\":1}}],[\"500\",{\"1\":{\"335\":2,\"336\":1,\"342\":1,\"576\":1,\"581\":1,\"1404\":3}}],[\"50\",{\"1\":{\"330\":2,\"535\":1,\"1603\":2,\"1604\":2,\"1605\":1}}],[\"5\",{\"0\":{\"463\":1,\"465\":1,\"1106\":1},\"1\":{\"306\":1,\"317\":1,\"335\":2,\"336\":2,\"338\":1,\"340\":2,\"342\":2,\"350\":1,\"361\":2,\"368\":1,\"371\":1,\"377\":4,\"378\":1,\"422\":1,\"430\":1,\"431\":3,\"446\":4,\"447\":33,\"448\":4,\"454\":2,\"459\":4,\"462\":3,\"492\":6,\"506\":2,\"522\":5,\"549\":1,\"553\":3,\"554\":2,\"555\":1,\"557\":1,\"567\":2,\"570\":2,\"571\":4,\"572\":2,\"573\":4,\"574\":5,\"578\":1,\"579\":1,\"897\":1,\"940\":2,\"943\":1,\"1003\":2,\"1023\":9,\"1040\":1,\"1063\":1,\"1064\":1,\"1072\":1,\"1100\":1,\"1130\":1,\"1131\":7,\"1172\":1,\"1484\":1,\"1550\":1,\"1551\":2,\"1599\":8,\"1607\":3,\"1609\":1,\"1610\":1,\"1612\":2,\"1617\":3,\"1620\":1,\"1651\":1}}],[\"4eec7777\",{\"1\":{\"1609\":1}}],[\"4次用户态和内核态的切换\",{\"1\":{\"1581\":1}}],[\"4次用户态和内核态切换\",{\"1\":{\"1580\":1}}],[\"4次上下文切换次数\",{\"1\":{\"1580\":1}}],[\"4次拷贝次数\",{\"1\":{\"1580\":1}}],[\"4内核中\",{\"1\":{\"1576\":1}}],[\"4之后\",{\"1\":{\"1572\":1}}],[\"4之前\",{\"1\":{\"1572\":1}}],[\"4之前唯一的选择\",{\"1\":{\"1421\":1}}],[\"4开始支持\",{\"1\":{\"1421\":1}}],[\"4当中的实现方式\",{\"1\":{\"1139\":1}}],[\"4和javaee5\",{\"1\":{\"897\":1}}],[\"41629346\",{\"1\":{\"1609\":1}}],[\"4151\",{\"1\":{\"576\":1}}],[\"41\",{\"1\":{\"555\":1}}],[\"47\",{\"1\":{\"551\":1}}],[\"494\",{\"1\":{\"528\":3}}],[\"466\",{\"1\":{\"528\":3}}],[\"404\",{\"1\":{\"1994\":1}}],[\"404b9385\",{\"1\":{\"1609\":1}}],[\"40\",{\"1\":{\"549\":2,\"557\":1,\"1485\":1,\"1587\":1,\"1598\":1,\"1603\":2,\"1604\":2,\"1605\":1,\"1613\":1}}],[\"402\",{\"1\":{\"528\":3}}],[\"400000253193539\",{\"1\":{\"576\":1}}],[\"40000134706497\",{\"1\":{\"576\":1}}],[\"400\",{\"1\":{\"343\":2}}],[\"446\",{\"1\":{\"528\":1}}],[\"483\",{\"1\":{\"528\":2}}],[\"450\",{\"1\":{\"535\":1,\"555\":1}}],[\"45\",{\"1\":{\"506\":1}}],[\"456\",{\"1\":{\"394\":1}}],[\"4294967295\",{\"1\":{\"494\":3,\"571\":1,\"572\":1}}],[\"42000\",{\"1\":{\"322\":1}}],[\"4直到不满足name=\",{\"1\":{\"520\":1}}],[\"4直到不满足city=\",{\"1\":{\"355\":1}}],[\"4直到city的值不满足查询条件为止\",{\"1\":{\"354\":1}}],[\"4\",{\"1\":{\"306\":1,\"307\":7,\"330\":1,\"343\":2,\"350\":1,\"361\":5,\"368\":4,\"377\":7,\"378\":1,\"422\":1,\"424\":8,\"425\":2,\"429\":1,\"430\":2,\"431\":3,\"434\":2,\"454\":2,\"459\":2,\"462\":3,\"492\":3,\"528\":6,\"529\":1,\"530\":2,\"534\":1,\"555\":1,\"567\":1,\"571\":5,\"572\":5,\"573\":3,\"574\":10,\"578\":2,\"579\":1,\"580\":1,\"624\":1,\"897\":2,\"940\":1,\"941\":1,\"963\":1,\"965\":1,\"1023\":1,\"1029\":1,\"1040\":1,\"1063\":1,\"1064\":1,\"1072\":1,\"1101\":1,\"1103\":1,\"1120\":1,\"1124\":1,\"1130\":1,\"1134\":1,\"1139\":1,\"1140\":1,\"1155\":1,\"1157\":1,\"1447\":1,\"1479\":3,\"1583\":1,\"1585\":2,\"1594\":2,\"1599\":2,\"1605\":1,\"1607\":1,\"1609\":2,\"1617\":3,\"1620\":1,\"1651\":1,\"1664\":1,\"1983\":1}}],[\"0x00004000\",{\"1\":{\"1620\":1}}],[\"0x00001000\",{\"1\":{\"1620\":1}}],[\"0x00000400\",{\"1\":{\"1620\":1}}],[\"0x00000100\",{\"1\":{\"1620\":1}}],[\"0x00000040\",{\"1\":{\"1620\":1}}],[\"0x00000004\",{\"1\":{\"1620\":1}}],[\"0x00000001\",{\"1\":{\"1620\":1}}],[\"0x00000010\",{\"1\":{\"1620\":1}}],[\"0l\",{\"1\":{\"1613\":1}}],[\"0的情况下\",{\"1\":{\"1614\":1}}],[\"0的使用场景通常称为联合登录\",{\"1\":{\"1204\":1}}],[\"0的协议认证流程\",{\"1\":{\"1202\":1}}],[\"0协议流程的过程中\",{\"1\":{\"1202\":1}}],[\"0协议有四种模式\",{\"1\":{\"1202\":1}}],[\"0是一个开放标准\",{\"1\":{\"1202\":1}}],[\"0是一个微调值\",{\"1\":{\"548\":2}}],[\"0错误处理接口\",{\"1\":{\"1124\":1}}],[\"0+通用类型转换实现\",{\"1\":{\"1081\":1,\"1095\":1}}],[\"0+\",{\"1\":{\"1080\":1,\"1110\":4}}],[\"0新特性\",{\"0\":{\"636\":1}}],[\"0终于发布了\",{\"1\":{\"601\":1}}],[\"0开始支持多层次\",{\"1\":{\"1134\":1}}],[\"0开始\",{\"1\":{\"601\":1,\"1139\":1}}],[\"0开始就彻底没有这个功能了\",{\"1\":{\"319\":1}}],[\"0<\",{\"1\":{\"582\":1}}],[\"0或1\",{\"1\":{\"578\":1}}],[\"05112878度\",{\"1\":{\"576\":1}}],[\"05112878度到85\",{\"1\":{\"576\":1}}],[\"05秒\",{\"1\":{\"348\":1}}],[\"0~3\",{\"1\":{\"574\":1}}],[\"0~1的成员\",{\"1\":{\"574\":1}}],[\"0~1部分\",{\"1\":{\"571\":1}}],[\"0~db\",{\"1\":{\"567\":1}}],[\"02\",{\"1\":{\"558\":1}}],[\"0时\",{\"1\":{\"556\":1}}],[\"0时一个页面的io成本常数\",{\"1\":{\"549\":1}}],[\"0=3\",{\"1\":{\"549\":1}}],[\"0=39\",{\"1\":{\"549\":1}}],[\"07\",{\"1\":{\"529\":1}}],[\"073\",{\"1\":{\"528\":4}}],[\"09之间大约有39条记录\",{\"1\":{\"549\":1}}],[\"09这个条件继续从id\",{\"1\":{\"549\":1}}],[\"09\",{\"1\":{\"454\":2,\"544\":1,\"547\":2,\"549\":5,\"553\":2,\"554\":4,\"555\":10}}],[\"0123passw0rd\",{\"1\":{\"624\":1}}],[\"012条记录\",{\"1\":{\"553\":1}}],[\"0126\",{\"1\":{\"553\":2}}],[\"01是微调\",{\"1\":{\"549\":1}}],[\"01\",{\"1\":{\"428\":1,\"529\":7,\"549\":4,\"553\":1}}],[\"0版本的策略\",{\"1\":{\"492\":1}}],[\"0版本的时候\",{\"1\":{\"492\":1}}],[\"0版本\",{\"1\":{\"490\":1}}],[\"0版本后\",{\"1\":{\"490\":1}}],[\"0版本开始\",{\"1\":{\"425\":1}}],[\"0版本直接将查询缓存的整块功能删掉了\",{\"1\":{\"319\":1}}],[\"036\",{\"1\":{\"528\":2}}],[\"03\",{\"1\":{\"371\":2,\"529\":1,\"544\":2,\"547\":4,\"549\":14,\"553\":4,\"554\":8,\"555\":20,\"558\":1}}],[\"08\",{\"1\":{\"371\":4,\"555\":1}}],[\"007\",{\"1\":{\"1156\":1}}],[\"001\",{\"1\":{\"994\":1,\"1484\":1}}],[\"00156100\",{\"1\":{\"431\":1}}],[\"000064\",{\"1\":{\"431\":1}}],[\"000060\",{\"1\":{\"431\":1}}],[\"000051\",{\"1\":{\"431\":1}}],[\"000053\",{\"1\":{\"431\":1}}],[\"000058\",{\"1\":{\"431\":1}}],[\"000041\",{\"1\":{\"431\":1}}],[\"000046\",{\"1\":{\"431\":2}}],[\"000032\",{\"1\":{\"431\":1}}],[\"000037\",{\"1\":{\"431\":1}}],[\"000039\",{\"1\":{\"431\":1}}],[\"000023\",{\"1\":{\"431\":1}}],[\"000019\",{\"1\":{\"431\":1}}],[\"000014\",{\"1\":{\"431\":1}}],[\"000011\",{\"1\":{\"431\":2}}],[\"000010\",{\"1\":{\"431\":1}}],[\"000007\",{\"1\":{\"485\":1}}],[\"000001文件里面从第2738字节到2973字节中间这段内容解析出来\",{\"1\":{\"454\":1}}],[\"000001\",{\"1\":{\"454\":3}}],[\"000004\",{\"1\":{\"431\":1}}],[\"000006这两个文件\",{\"1\":{\"485\":1}}],[\"000006\",{\"1\":{\"431\":2,\"485\":1}}],[\"000003\",{\"1\":{\"431\":1}}],[\"000005和master\",{\"1\":{\"485\":1}}],[\"000005开始的\",{\"1\":{\"485\":1}}],[\"000005\",{\"1\":{\"431\":2,\"485\":1}}],[\"000009\",{\"1\":{\"431\":2}}],[\"000002\",{\"1\":{\"431\":1}}],[\"0000000000000000000000000000000000000000\",{\"1\":{\"609\":1}}],[\"000000\",{\"1\":{\"428\":1,\"431\":30}}],[\"000090\",{\"1\":{\"431\":1}}],[\"000097\",{\"1\":{\"431\":1}}],[\"000347\",{\"1\":{\"420\":1}}],[\"00\",{\"1\":{\"329\":2,\"330\":10,\"361\":2,\"371\":2,\"428\":3,\"431\":4,\"529\":6,\"555\":1,\"1484\":1}}],[\"0\",{\"1\":{\"306\":3,\"307\":1,\"329\":1,\"330\":6,\"336\":1,\"361\":1,\"371\":2,\"393\":2,\"403\":1,\"417\":1,\"419\":1,\"420\":2,\"428\":5,\"431\":109,\"435\":2,\"446\":3,\"447\":11,\"448\":2,\"454\":2,\"484\":1,\"491\":1,\"510\":1,\"518\":1,\"519\":1,\"528\":9,\"530\":10,\"544\":1,\"545\":3,\"547\":2,\"548\":4,\"549\":23,\"553\":5,\"556\":1,\"557\":10,\"567\":24,\"569\":39,\"570\":49,\"571\":84,\"572\":43,\"573\":42,\"574\":82,\"576\":4,\"577\":14,\"578\":25,\"579\":26,\"580\":26,\"581\":35,\"598\":8,\"609\":7,\"611\":8,\"621\":2,\"624\":2,\"645\":1,\"917\":1,\"918\":1,\"930\":1,\"940\":1,\"941\":3,\"953\":2,\"954\":2,\"963\":1,\"985\":1,\"989\":2,\"1003\":1,\"1023\":3,\"1024\":3,\"1029\":3,\"1030\":1,\"1032\":1,\"1040\":2,\"1053\":4,\"1065\":1,\"1084\":1,\"1091\":1,\"1093\":1,\"1101\":1,\"1102\":1,\"1103\":4,\"1131\":2,\"1140\":10,\"1146\":1,\"1172\":1,\"1182\":2,\"1227\":1,\"1328\":1,\"1347\":3,\"1404\":5,\"1473\":1,\"1475\":1,\"1476\":1,\"1479\":6,\"1480\":1,\"1482\":1,\"1483\":8,\"1484\":1,\"1487\":1,\"1502\":3,\"1503\":3,\"1506\":2,\"1517\":3,\"1548\":1,\"1549\":2,\"1550\":7,\"1551\":2,\"1554\":13,\"1573\":2,\"1574\":5,\"1575\":2,\"1583\":1,\"1584\":1,\"1585\":2,\"1587\":1,\"1588\":1,\"1591\":1,\"1593\":1,\"1599\":7,\"1601\":4,\"1607\":2,\"1609\":2,\"1610\":6,\"1612\":1,\"1613\":4,\"1614\":3,\"1617\":1,\"1618\":11,\"1620\":7,\"1621\":2,\"1623\":3,\"1648\":2,\"1654\":1}}],[\"0有什么关系\",{\"0\":{\"221\":1,\"1204\":1}}],[\"王五\",{\"1\":{\"306\":1}}],[\"李四xxx\",{\"1\":{\"306\":1}}],[\"李四\",{\"1\":{\"306\":1}}],[\"wdbyte\",{\"1\":{\"1626\":1}}],[\"would\",{\"1\":{\"1615\":3,\"1620\":7,\"1622\":1}}],[\"worse\",{\"1\":{\"1615\":1}}],[\"worl\",{\"1\":{\"570\":1}}],[\"world=world\",{\"1\":{\"1617\":4}}],[\"world\",{\"0\":{\"655\":1},\"1\":{\"570\":5,\"582\":1,\"598\":3,\"977\":1,\"1053\":1,\"1108\":1,\"1115\":2,\"1119\":1,\"1123\":2,\"1365\":1,\"1440\":1,\"1593\":12,\"1594\":2,\"1595\":2,\"1597\":4,\"1602\":2,\"1607\":8,\"1608\":3,\"1609\":7,\"1610\":4,\"1612\":4,\"1614\":1,\"1617\":13,\"1619\":10,\"1620\":2}}],[\"workqueue\",{\"1\":{\"1476\":3}}],[\"worker\",{\"0\":{\"1534\":1},\"1\":{\"1617\":27}}],[\"workercountof\",{\"1\":{\"1476\":2}}],[\"workergroup\",{\"1\":{\"1226\":4}}],[\"worker执行完成后\",{\"1\":{\"461\":1}}],[\"workers决定的\",{\"1\":{\"460\":1}}],[\"work线程的个数\",{\"1\":{\"460\":1}}],[\"work\",{\"1\":{\"435\":2,\"1615\":1,\"1620\":2}}],[\"word的thread\",{\"1\":{\"1485\":1}}],[\"word的结构也变为轻量级锁的结构\",{\"1\":{\"1485\":1}}],[\"word中也有该字段\",{\"1\":{\"1485\":1}}],[\"word中的thread\",{\"1\":{\"1485\":1}}],[\"word中锁标记枚举\",{\"1\":{\"1484\":1}}],[\"words\",{\"1\":{\"419\":2,\"420\":1,\"421\":1}}],[\"word\",{\"1\":{\"306\":1,\"419\":2,\"420\":1,\"421\":1,\"1484\":2,\"1600\":2}}],[\"wb\",{\"1\":{\"1533\":2,\"1534\":2}}],[\"wc\",{\"1\":{\"1464\":2}}],[\"ws\",{\"1\":{\"966\":2}}],[\"w3\",{\"1\":{\"917\":1,\"918\":1,\"930\":2,\"953\":2,\"954\":2,\"1030\":1,\"1032\":1,\"1065\":1,\"1084\":1,\"1091\":1,\"1146\":1}}],[\"welcome=welcome\",{\"1\":{\"1617\":4}}],[\"welcome\",{\"1\":{\"1609\":4,\"1614\":1,\"1617\":17}}],[\"well\",{\"1\":{\"1608\":2,\"1620\":1}}],[\"weak\",{\"1\":{\"1435\":1}}],[\"weak等\",{\"1\":{\"645\":1}}],[\"weaving\",{\"1\":{\"1164\":1,\"1165\":1}}],[\"weaverawarename\",{\"1\":{\"1171\":2}}],[\"weaverawarenames\",{\"1\":{\"1171\":2}}],[\"weaver\",{\"1\":{\"1020\":1,\"1164\":1,\"1165\":1}}],[\"we\",{\"1\":{\"922\":1,\"963\":2,\"1170\":2,\"1615\":2,\"1619\":1,\"1620\":1,\"1623\":2,\"1647\":3,\"1648\":1,\"1651\":1,\"1689\":6}}],[\"web原理\",{\"1\":{\"1983\":1}}],[\"web教程\",{\"1\":{\"1978\":1}}],[\"web后端\",{\"0\":{\"1978\":1}}],[\"web前端\",{\"0\":{\"1977\":1}}],[\"web应用服务器\",{\"1\":{\"1683\":1}}],[\"webappinitializerclasses\",{\"1\":{\"1658\":1}}],[\"webapplicationcontext\",{\"1\":{\"986\":1,\"987\":1,\"988\":1,\"1658\":2}}],[\"web中\",{\"1\":{\"1354\":1}}],[\"web项目防止表单\",{\"1\":{\"1248\":1}}],[\"weblistener\",{\"1\":{\"1110\":1}}],[\"web扩展实现\",{\"1\":{\"1071\":1}}],[\"webexchangedatabinder\",{\"1\":{\"1070\":1}}],[\"webrequestdatabinder\",{\"1\":{\"1070\":1}}],[\"web组件\",{\"1\":{\"1070\":1}}],[\"webmvcconfigurer\",{\"1\":{\"1658\":1}}],[\"webmvc\",{\"1\":{\"1060\":1,\"1116\":1}}],[\"webdatabinder\",{\"1\":{\"1060\":1,\"1069\":1,\"1070\":1}}],[\"web参数绑定\",{\"1\":{\"1060\":1,\"1069\":1}}],[\"web站点页面渲染\",{\"1\":{\"1049\":1}}],[\"web控制器模式注解\",{\"1\":{\"1023\":1,\"1131\":1}}],[\"webservicecontext\",{\"1\":{\"966\":1}}],[\"webserviceref\",{\"1\":{\"966\":1}}],[\"websocket等\",{\"1\":{\"1683\":1}}],[\"websocket\",{\"1\":{\"894\":2}}],[\"websocket生命周期分解\",{\"0\":{\"664\":1}}],[\"webclient\",{\"1\":{\"894\":1}}],[\"webflux处理方法参数校验\",{\"1\":{\"1060\":1}}],[\"webflux\",{\"1\":{\"894\":1,\"899\":1}}],[\"web\",{\"0\":{\"1976\":1},\"1\":{\"894\":2,\"896\":2,\"1039\":1,\"1049\":1,\"1070\":4,\"1154\":2,\"1169\":5,\"1657\":4,\"1658\":2,\"1969\":1,\"1978\":2}}],[\"web技术\",{\"0\":{\"894\":1}}],[\"weight字段增加0\",{\"1\":{\"573\":1}}],[\"weight\",{\"1\":{\"573\":1,\"1619\":2}}],[\"www\",{\"1\":{\"639\":1,\"645\":1,\"917\":4,\"918\":5,\"930\":8,\"953\":8,\"954\":8,\"1028\":6,\"1030\":3,\"1032\":4,\"1049\":1,\"1065\":7,\"1084\":4,\"1091\":7,\"1146\":4,\"1201\":2,\"1494\":1,\"1499\":1,\"1626\":1,\"1652\":1,\"1653\":1,\"1657\":1,\"1969\":3,\"1974\":1,\"1975\":2,\"1978\":1,\"1980\":1,\"1981\":2,\"1982\":1,\"1983\":1,\"1985\":2,\"1986\":1,\"1987\":2,\"1989\":1,\"1990\":1,\"1991\":1,\"1992\":2}}],[\"wtw6ds0y300\",{\"1\":{\"576\":1}}],[\"wmrjwbr5250\",{\"1\":{\"576\":1}}],[\"wrap\",{\"1\":{\"1623\":1}}],[\"wrapsink\",{\"1\":{\"1623\":5}}],[\"wrapandcopyinto\",{\"1\":{\"1623\":4}}],[\"wrapping\",{\"1\":{\"1623\":1}}],[\"wrapped\",{\"1\":{\"1647\":1}}],[\"wrappedsink\",{\"1\":{\"1623\":7}}],[\"wrappedbean\",{\"1\":{\"1008\":7}}],[\"wrapper\",{\"1\":{\"1620\":2}}],[\"writableresource\",{\"1\":{\"1038\":1,\"1040\":1}}],[\"writechannel\",{\"1\":{\"1587\":3}}],[\"writecompletionhandler\",{\"1\":{\"1575\":1}}],[\"writebuffer\",{\"1\":{\"1574\":4}}],[\"writers\",{\"1\":{\"1621\":1}}],[\"writer\",{\"1\":{\"1573\":4}}],[\"writefds和exceptfds\",{\"1\":{\"1569\":1}}],[\"writefds\",{\"1\":{\"1569\":1}}],[\"write设计思想维护服务路由表\",{\"1\":{\"1527\":1}}],[\"write来解决\",{\"1\":{\"1527\":1}}],[\"write最大的应用领域还是在函数式编程领域\",{\"1\":{\"1527\":1}}],[\"write在操作系统领域中也有广泛的应用\",{\"1\":{\"1527\":1}}],[\"write这两个容器实现读操作是无锁的\",{\"1\":{\"1527\":1}}],[\"write容器\",{\"1\":{\"1527\":1}}],[\"write缺点就是消耗内存\",{\"1\":{\"1527\":1}}],[\"write方法\",{\"1\":{\"1527\":1}}],[\"write方法就会阻塞\",{\"1\":{\"602\":1}}],[\"write模式\",{\"0\":{\"1527\":1}}],[\"writemethod=public\",{\"1\":{\"909\":2}}],[\"writeset策略也是没法并行的\",{\"1\":{\"465\":1}}],[\"writeset是在主库生成后直接写入binlog里面的\",{\"1\":{\"465\":1}}],[\"writeset\",{\"1\":{\"465\":1}}],[\"writeset表示的对于事务涉及更新的每一行\",{\"1\":{\"465\":1}}],[\"write到page\",{\"1\":{\"451\":1}}],[\"write和fsync的时机\",{\"1\":{\"450\":1}}],[\"write\",{\"1\":{\"324\":2,\"429\":1,\"440\":1,\"451\":1,\"534\":2,\"588\":1,\"603\":5,\"611\":2,\"1224\":1,\"1473\":1,\"1527\":3,\"1533\":1,\"1534\":1,\"1574\":6,\"1575\":5,\"1585\":2,\"1587\":2,\"1588\":1}}],[\"wrong\",{\"1\":{\"571\":1}}],[\"wrongtype\",{\"1\":{\"571\":1}}],[\"w的参数是为了把内容都解析出来\",{\"1\":{\"454\":1}}],[\"w\",{\"1\":{\"454\":1,\"1619\":8}}],[\"wiki\",{\"1\":{\"1969\":1,\"1981\":1}}],[\"wired\",{\"1\":{\"1623\":1}}],[\"wiring很难在工具上产生一些文档或者相关提示\",{\"1\":{\"952\":1}}],[\"wiring\",{\"1\":{\"918\":1}}],[\"window\",{\"1\":{\"1620\":2}}],[\"windowsselectorprovider\",{\"1\":{\"1423\":1}}],[\"windows\",{\"1\":{\"1337\":1}}],[\"widget\",{\"1\":{\"1619\":2}}],[\"widgets是widget类型的集合\",{\"1\":{\"1619\":1}}],[\"widgets\",{\"1\":{\"1615\":1,\"1619\":4}}],[\"witnessed\",{\"1\":{\"1570\":1}}],[\"without\",{\"1\":{\"579\":1,\"910\":1,\"912\":1,\"997\":1,\"1608\":2,\"1615\":1,\"1620\":1,\"1621\":1,\"1623\":1,\"1647\":1}}],[\"withdist\",{\"1\":{\"576\":2}}],[\"withcoord\",{\"1\":{\"576\":2}}],[\"withscores\",{\"1\":{\"574\":2}}],[\"withinitial\",{\"1\":{\"1528\":1}}],[\"within\",{\"1\":{\"429\":1,\"1647\":1}}],[\"with\",{\"0\":{\"1583\":1},\"1\":{\"429\":1,\"437\":1,\"580\":2,\"928\":1,\"996\":7,\"997\":3,\"1007\":1,\"1164\":1,\"1263\":1,\"1583\":2,\"1585\":1,\"1594\":4,\"1599\":6,\"1608\":4,\"1614\":1,\"1615\":5,\"1617\":1,\"1618\":4,\"1619\":10,\"1620\":4,\"1621\":3,\"1623\":4,\"1647\":6,\"1648\":1,\"1658\":1}}],[\"wish\",{\"1\":{\"1175\":1,\"1623\":1}}],[\"will\",{\"1\":{\"997\":1,\"1594\":5,\"1597\":1,\"1599\":8,\"1608\":2,\"1609\":2,\"1617\":1,\"1618\":1,\"1619\":2,\"1620\":3,\"1621\":1,\"1623\":4,\"1647\":1,\"1655\":2}}],[\"wildcardtype\",{\"1\":{\"1099\":1}}],[\"wildcard\",{\"1\":{\"429\":1}}],[\"whose\",{\"1\":{\"1597\":2,\"1598\":3,\"1599\":2,\"1600\":1,\"1601\":2,\"1608\":2,\"1619\":1}}],[\"which\",{\"1\":{\"963\":1,\"997\":1,\"1599\":4,\"1601\":5,\"1608\":4,\"1615\":1,\"1618\":5,\"1619\":8,\"1620\":6,\"1621\":4,\"1623\":10,\"1647\":2}}],[\"while\",{\"1\":{\"393\":1,\"400\":2,\"404\":4,\"414\":2,\"419\":2,\"498\":1,\"518\":2,\"523\":4,\"928\":1,\"930\":1,\"1387\":1,\"1404\":6,\"1483\":1,\"1502\":2,\"1503\":2,\"1506\":1,\"1533\":1,\"1534\":1,\"1550\":1,\"1554\":2,\"1573\":2,\"1574\":4,\"1619\":2,\"1620\":4,\"1622\":1,\"1648\":1}}],[\"whenever\",{\"1\":{\"1620\":1}}],[\"when\",{\"1\":{\"963\":1,\"1166\":2,\"1215\":1,\"1480\":3,\"1554\":1,\"1599\":4,\"1619\":2,\"1620\":6,\"1647\":1,\"1650\":1}}],[\"whether\",{\"1\":{\"952\":2,\"997\":1,\"1175\":1,\"1594\":3,\"1620\":1,\"1623\":1}}],[\"where与order\",{\"1\":{\"521\":1}}],[\"where语句\",{\"1\":{\"377\":1}}],[\"where条件里用不到的字段不创建索引\",{\"1\":{\"359\":1}}],[\"where子句的值总是false\",{\"1\":{\"330\":1}}],[\"where\",{\"1\":{\"317\":1,\"319\":1,\"321\":1,\"322\":1,\"323\":1,\"330\":12,\"335\":2,\"336\":1,\"338\":1,\"339\":1,\"340\":1,\"341\":1,\"342\":1,\"345\":1,\"346\":4,\"347\":1,\"348\":1,\"349\":1,\"351\":2,\"352\":1,\"353\":1,\"354\":3,\"361\":4,\"366\":3,\"367\":2,\"368\":7,\"370\":6,\"371\":2,\"372\":2,\"373\":2,\"374\":2,\"375\":12,\"376\":3,\"377\":12,\"378\":15,\"384\":1,\"390\":6,\"393\":2,\"394\":4,\"400\":1,\"401\":1,\"404\":1,\"407\":2,\"408\":1,\"409\":1,\"411\":3,\"421\":1,\"422\":1,\"434\":1,\"447\":11,\"448\":1,\"454\":1,\"462\":1,\"476\":2,\"479\":2,\"509\":2,\"514\":1,\"518\":1,\"519\":4,\"520\":2,\"522\":1,\"525\":3,\"535\":1,\"536\":1,\"537\":1,\"544\":1,\"547\":1,\"549\":2,\"553\":3,\"554\":4,\"555\":2,\"558\":1,\"1215\":1,\"1498\":2,\"1601\":2,\"1611\":1,\"1615\":1,\"1618\":1,\"1619\":1,\"1621\":2,\"1623\":1}}],[\"whatever\",{\"1\":{\"1622\":2,\"1623\":3}}],[\"what\",{\"1\":{\"429\":1}}],[\"way\",{\"1\":{\"1620\":1}}],[\"ways\",{\"1\":{\"1620\":1}}],[\"wangchujiang\",{\"1\":{\"1987\":1}}],[\"wangwu=90\",{\"1\":{\"1613\":1}}],[\"wangwu=1\",{\"1\":{\"1613\":1}}],[\"wangwu\",{\"1\":{\"1598\":1,\"1603\":2,\"1604\":2,\"1605\":1,\"1609\":1,\"1613\":1,\"1615\":1}}],[\"wanted\",{\"1\":{\"1615\":1}}],[\"warm\",{\"1\":{\"1283\":1}}],[\"war\",{\"1\":{\"1037\":1}}],[\"warn\",{\"1\":{\"922\":1,\"1175\":2,\"1647\":1,\"1651\":1}}],[\"warnings\",{\"1\":{\"509\":1,\"1620\":1}}],[\"warning\",{\"1\":{\"329\":1,\"330\":5,\"361\":1,\"431\":3}}],[\"was\",{\"1\":{\"952\":1,\"963\":1,\"996\":1,\"1053\":3,\"1550\":1,\"1619\":1,\"1620\":1,\"1623\":1}}],[\"watchservice\",{\"1\":{\"1060\":1}}],[\"watch\",{\"1\":{\"581\":2,\"582\":1,\"1570\":1}}],[\"wal\",{\"1\":{\"561\":1}}],[\"wait模式\",{\"1\":{\"1530\":1}}],[\"waiters\",{\"1\":{\"1483\":1}}],[\"wait和notify\",{\"1\":{\"1477\":1}}],[\"wait和sleep方法有什么区别\",{\"0\":{\"52\":1,\"1381\":1}}],[\"waitstrategy\",{\"1\":{\"1520\":3}}],[\"waitsetlock\",{\"1\":{\"1483\":1}}],[\"waitset是第一个节点\",{\"1\":{\"1483\":1}}],[\"waitset\",{\"1\":{\"1483\":1}}],[\"waits\",{\"1\":{\"538\":4}}],[\"wait返回一个大于等于0的整数\",{\"1\":{\"473\":1}}],[\"wait\",{\"1\":{\"441\":2,\"444\":2,\"473\":2,\"474\":2,\"479\":5,\"1404\":1,\"1483\":2,\"1530\":1}}],[\"3与2\",{\"1\":{\"1983\":1}}],[\"3d494fbf\",{\"1\":{\"1613\":1}}],[\"3b07d329\",{\"1\":{\"1609\":1}}],[\"3b54deef5b7b7b7f7dd8acefa23be48879b4fcff\",{\"1\":{\"609\":1}}],[\"362872a1\",{\"1\":{\"1592\":1}}],[\"3611\",{\"1\":{\"576\":1}}],[\"3跳\",{\"1\":{\"1474\":1}}],[\"3新增语义\",{\"1\":{\"1155\":1}}],[\"349\",{\"1\":{\"1065\":1}}],[\"34930488\",{\"1\":{\"330\":1}}],[\"33\",{\"1\":{\"1002\":1}}],[\"330\",{\"1\":{\"965\":2}}],[\"330存在于classpath中\",{\"1\":{\"965\":1}}],[\"3+\",{\"1\":{\"897\":3}}],[\"3以及之前的版本的话\",{\"1\":{\"553\":1}}],[\"3以及之前的版本中\",{\"1\":{\"553\":1}}],[\"3✖️1\",{\"1\":{\"549\":1}}],[\"354\",{\"1\":{\"1092\":1}}],[\"35\",{\"1\":{\"544\":1,\"547\":2,\"549\":7,\"553\":2,\"554\":4,\"555\":15}}],[\"351\",{\"1\":{\"528\":4}}],[\"310\",{\"1\":{\"1092\":1}}],[\"31\",{\"1\":{\"529\":2,\"576\":1,\"1347\":1}}],[\"315\",{\"1\":{\"528\":3}}],[\"386\",{\"1\":{\"555\":1}}],[\"38\",{\"1\":{\"528\":3}}],[\"388\",{\"1\":{\"528\":2}}],[\"372\",{\"1\":{\"528\":2}}],[\"39✖️1\",{\"1\":{\"549\":1}}],[\"39✖️0\",{\"1\":{\"549\":2}}],[\"39\",{\"1\":{\"371\":2,\"549\":3,\"553\":1,\"582\":1}}],[\"3和5\",{\"1\":{\"337\":1}}],[\"303\",{\"1\":{\"1065\":1}}],[\"308\",{\"1\":{\"528\":3}}],[\"3000\",{\"1\":{\"1013\":1,\"1573\":3,\"1574\":2,\"1575\":2}}],[\"30000\",{\"1\":{\"624\":1}}],[\"300\",{\"1\":{\"335\":1,\"336\":1,\"587\":1}}],[\"30\",{\"1\":{\"306\":1,\"371\":2,\"571\":5,\"576\":3,\"1598\":1,\"1613\":1}}],[\"323\",{\"1\":{\"1619\":2}}],[\"32位jvm下的对象结构描述\",{\"1\":{\"1484\":1}}],[\"32位4字节\",{\"1\":{\"1484\":1}}],[\"325\",{\"1\":{\"555\":1}}],[\"321\",{\"1\":{\"555\":2}}],[\"32\",{\"1\":{\"306\":1,\"309\":2,\"338\":2,\"366\":1,\"367\":1,\"368\":3,\"528\":2}}],[\"3\",{\"1\":{\"305\":1,\"306\":1,\"307\":7,\"335\":1,\"336\":2,\"338\":1,\"356\":1,\"361\":11,\"362\":1,\"368\":5,\"377\":11,\"378\":1,\"393\":2,\"419\":1,\"420\":2,\"421\":1,\"428\":1,\"429\":1,\"430\":2,\"431\":3,\"434\":1,\"454\":2,\"459\":1,\"462\":3,\"476\":1,\"491\":1,\"492\":3,\"506\":3,\"520\":1,\"528\":4,\"529\":2,\"534\":1,\"536\":2,\"537\":1,\"549\":1,\"553\":1,\"555\":1,\"556\":1,\"567\":1,\"570\":2,\"571\":14,\"572\":6,\"573\":5,\"574\":26,\"576\":2,\"578\":2,\"579\":2,\"580\":1,\"598\":3,\"624\":1,\"897\":1,\"929\":1,\"940\":1,\"941\":3,\"963\":1,\"966\":1,\"967\":1,\"985\":1,\"989\":2,\"1023\":2,\"1024\":1,\"1025\":1,\"1029\":4,\"1063\":1,\"1064\":1,\"1072\":2,\"1080\":1,\"1081\":1,\"1082\":1,\"1084\":2,\"1095\":1,\"1101\":1,\"1110\":2,\"1116\":1,\"1120\":1,\"1130\":1,\"1131\":2,\"1144\":1,\"1146\":2,\"1226\":1,\"1263\":2,\"1404\":3,\"1447\":1,\"1479\":5,\"1484\":1,\"1490\":1,\"1501\":2,\"1517\":5,\"1535\":1,\"1550\":1,\"1551\":5,\"1554\":1,\"1594\":3,\"1598\":5,\"1599\":4,\"1605\":1,\"1607\":4,\"1609\":2,\"1610\":1,\"1617\":8,\"1620\":1,\"1647\":1,\"1651\":1,\"1664\":1}}],[\"注册过滤信息\",{\"0\":{\"1906\":1}}],[\"注册时间监听器\",{\"1\":{\"1651\":1}}],[\"注册mylifecycle成为一个spring\",{\"1\":{\"1174\":1}}],[\"注册mergedbeandefinitionpostprocessor\",{\"1\":{\"1166\":1}}],[\"注册普通beanpostprocessor\",{\"1\":{\"1166\":1}}],[\"注册ordered类型的beanpostprocessor\",{\"1\":{\"1166\":1}}],[\"注册priorityordered类型的beanpostprocessor\",{\"1\":{\"1166\":1}}],[\"注册单例对象\",{\"1\":{\"1164\":1}}],[\"注册loadtimeweaverawareprocessor对象\",{\"1\":{\"1164\":1,\"1165\":1}}],[\"注册applicationlistenerdetector对象\",{\"1\":{\"1164\":1,\"1166\":1}}],[\"注册resolvabledependency对象\",{\"1\":{\"1164\":1}}],[\"注册自定义事件监听器\",{\"1\":{\"1119\":1}}],[\"注册shutdown\",{\"1\":{\"1175\":1}}],[\"注册spring\",{\"0\":{\"1114\":1}}],[\"注册scope\",{\"1\":{\"989\":1}}],[\"注册转换器实现\",{\"1\":{\"1091\":1}}],[\"注册xml扩展\",{\"1\":{\"1030\":1}}],[\"注册一个新的beandefinition\",{\"1\":{\"996\":1}}],[\"注册阶段\",{\"0\":{\"996\":1}}],[\"注册当前类\",{\"1\":{\"995\":1}}],[\"注册\",{\"1\":{\"975\":1,\"976\":1,\"977\":1,\"1119\":1,\"1184\":1}}],[\"注册userholder的beandefinition\",{\"1\":{\"953\":1}}],[\"注册beandefinition\",{\"1\":{\"946\":2}}],[\"注册外部单例对象\",{\"1\":{\"936\":2}}],[\"注册配置类\",{\"1\":{\"929\":1}}],[\"注册中心\",{\"0\":{\"239\":1,\"1319\":1}}],[\"注入字段\",{\"1\":{\"1648\":1}}],[\"注入\",{\"0\":{\"1182\":1},\"1\":{\"1182\":2}}],[\"注入applicationcontext作为resourceloader\",{\"1\":{\"1045\":1}}],[\"注入myinstantiationawarebeanpostprocessor\",{\"1\":{\"1005\":1}}],[\"注入在postprocessproperties方法执行\",{\"1\":{\"973\":1}}],[\"注入了四个类型\",{\"1\":{\"973\":1}}],[\"注入来源\",{\"1\":{\"973\":1}}],[\"注入注解\",{\"1\":{\"966\":1}}],[\"注入选型\",{\"1\":{\"958\":1}}],[\"注入类型\",{\"1\":{\"918\":1}}],[\"注入非bean对象\",{\"1\":{\"918\":1}}],[\"注入容器内建的bean对象\",{\"1\":{\"918\":1}}],[\"注解等信息\",{\"1\":{\"1647\":1}}],[\"注解修饰的方法被类内部方法调用\",{\"1\":{\"1239\":1}}],[\"注解注入\",{\"1\":{\"1148\":1}}],[\"注解中的属性方法\",{\"1\":{\"1136\":1}}],[\"注解属性的别名实际上总共有两种\",{\"1\":{\"1136\":1}}],[\"注解元信息\",{\"1\":{\"1134\":1}}],[\"注解目标\",{\"1\":{\"1113\":1}}],[\"注解标注的beandefinition\",{\"1\":{\"1018\":1}}],[\"注解实现annotationbeannamegenerator\",{\"1\":{\"995\":1}}],[\"注解实现的核心源代码\",{\"1\":{\"928\":1}}],[\"注解的\",{\"1\":{\"995\":1}}],[\"注解beandefinition示例\",{\"1\":{\"929\":1}}],[\"注解驱动测试注解\",{\"1\":{\"1157\":1}}],[\"注解驱动的当下时代\",{\"1\":{\"1130\":1}}],[\"注解驱动的完善时代\",{\"1\":{\"1130\":1}}],[\"注解驱动的黄金时代\",{\"1\":{\"1130\":1}}],[\"注解驱动的过渡时代\",{\"1\":{\"1130\":1}}],[\"注解驱动的启蒙时代\",{\"1\":{\"1130\":1}}],[\"注解驱动的依赖注入过程\",{\"1\":{\"963\":1}}],[\"注解驱动spring应用上下文内建可查找的依赖\",{\"1\":{\"945\":1}}],[\"注解驱动\",{\"1\":{\"903\":1,\"1031\":1}}],[\"注解\",{\"1\":{\"891\":1,\"899\":1,\"900\":2,\"921\":1,\"1023\":1,\"1140\":2,\"1147\":1,\"1153\":1,\"1239\":4}}],[\"注解解析\",{\"0\":{\"870\":1}}],[\"注意是具体的beanpostprocessor实例对象\",{\"1\":{\"1651\":1}}],[\"注意此时两个线程已经成功添加数据\",{\"1\":{\"1551\":1}}],[\"注意事项\",{\"1\":{\"985\":1}}],[\"注意接下来的都是当前applicationcontext对象\",{\"1\":{\"973\":1}}],[\"注意必须为主从设置一样的验证密码\",{\"1\":{\"624\":1}}],[\"注意到有一个replication模块\",{\"1\":{\"609\":1}}],[\"注意使用时一定使用lettuce的连接池\",{\"1\":{\"583\":1}}],[\"注意20也包含在内\",{\"1\":{\"536\":1}}],[\"注意长度设置\",{\"1\":{\"528\":1}}],[\"注意这里的顺序\",{\"1\":{\"1116\":1}}],[\"注意这里必须这么写\",{\"1\":{\"994\":1}}],[\"注意这里是static方法\",{\"1\":{\"967\":1}}],[\"注意这里输出的不是所有的user对象\",{\"1\":{\"961\":2}}],[\"注意这里设置了唯一约束\",{\"1\":{\"489\":1}}],[\"注意这里并不是直接写入redo\",{\"1\":{\"326\":1}}],[\"注意on需要大写\",{\"1\":{\"428\":1}}],[\"注意\",{\"1\":{\"305\":1,\"306\":1,\"330\":1,\"451\":1,\"497\":1,\"545\":1,\"581\":1,\"944\":1,\"1485\":1,\"1519\":1,\"1528\":1,\"1551\":2,\"1599\":1,\"1633\":1}}],[\"每隔一秒扫描所有channel\",{\"1\":{\"1574\":1}}],[\"每隔一段时间\",{\"1\":{\"1289\":1}}],[\"每移动一次\",{\"1\":{\"1436\":1}}],[\"每种类型在number\",{\"1\":{\"1053\":1}}],[\"每种自增id有各自的应用场景\",{\"1\":{\"499\":1}}],[\"每台redis服务器都是主节点\",{\"1\":{\"606\":1,\"610\":1}}],[\"每秒执行一次\",{\"1\":{\"592\":1}}],[\"每秒一次后台轮询刷盘\",{\"1\":{\"451\":1}}],[\"每新建一个连接\",{\"1\":{\"498\":1}}],[\"每插入一行数据\",{\"1\":{\"495\":1}}],[\"每10毫秒判断一下是否可以进入innodb执行\",{\"1\":{\"481\":1}}],[\"每条记录在更新的时候都会同时记录一条回滚操作\",{\"1\":{\"434\":1}}],[\"每年年底时再把下一年度的12个新分区创建上即可\",{\"1\":{\"426\":1}}],[\"每当有一种新的操作\",{\"1\":{\"1598\":1}}],[\"每当有原子性自增的操作就可以使用incr命令\",{\"1\":{\"1293\":1}}],[\"每当一个连接接入时我们都需要new一个线程进行处理\",{\"1\":{\"1573\":1}}],[\"每当一个事务被锁的时候\",{\"1\":{\"444\":1}}],[\"每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作\",{\"1\":{\"1473\":1}}],[\"每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作\",{\"1\":{\"1473\":1}}],[\"每当第一次访问一个分区表的时候\",{\"1\":{\"425\":1}}],[\"每当primary\",{\"1\":{\"304\":1}}],[\"每被删除一行redis计数就减1\",{\"1\":{\"397\":1}}],[\"每一块元素都有自己的分割迭代器\",{\"1\":{\"1620\":1}}],[\"每一次该class的对象发生偏向锁撤销操作时\",{\"1\":{\"1485\":1}}],[\"每一次修改都会同步\",{\"1\":{\"593\":1}}],[\"每一种应用层协议都有自己的抽象基类\",{\"1\":{\"1687\":1}}],[\"每一种类加载器都有自己的加载目录\",{\"1\":{\"1432\":1}}],[\"每一种隔离级别都有自己的使用场景\",{\"1\":{\"433\":1}}],[\"每一位所在的位置为偏移\",{\"1\":{\"578\":1}}],[\"每一条记录对应着一个索引的一个统计项的统计数据\",{\"1\":{\"558\":1}}],[\"每一条记录对应着一个表的统计数据\",{\"1\":{\"558\":1}}],[\"每一行数据都记录了更新它的trx\",{\"1\":{\"497\":1}}],[\"每一行的a=1001\",{\"1\":{\"404\":1}}],[\"每一行记录都要判断自己是否对这个会话可见\",{\"1\":{\"396\":1}}],[\"每一份单独排序后存在这些临时文件中\",{\"1\":{\"354\":1}}],[\"每一个叶子节点都会发送个这个类的同一个terminalsink实例\",{\"1\":{\"1623\":1}}],[\"每一个单个的abstractpipeline通常称为stages\",{\"1\":{\"1621\":1}}],[\"每一个spliterator仅仅是对一个单块的计算是有用的\",{\"1\":{\"1620\":1}}],[\"每一个部分的操作都是独立的\",{\"1\":{\"1615\":1}}],[\"每一个crud操作最终都会解析为一个\",{\"1\":{\"645\":1}}],[\"每一个虚线箭头表示回表一次\",{\"1\":{\"340\":1}}],[\"每一个索引在innodb中对应一颗b+树\",{\"1\":{\"335\":1}}],[\"每次依赖注入获取bean都应该是一个新的bean\",{\"1\":{\"1648\":1}}],[\"每次依赖查找和依赖注入生成新bean对象\",{\"1\":{\"983\":1,\"1235\":1}}],[\"每次将流中的元素添加到的arraylist时都会新newarraylist\",{\"1\":{\"1608\":1}}],[\"每次被调用的结果可能是相同的\",{\"1\":{\"1600\":1}}],[\"每次修改都需要复制一个新的对象出来\",{\"1\":{\"1527\":1}}],[\"每次修改都会sync\",{\"1\":{\"592\":1}}],[\"每次操作都会上锁\",{\"1\":{\"1498\":1}}],[\"每次操作锁住一行数据\",{\"1\":{\"535\":1}}],[\"每次操作锁住整张表\",{\"1\":{\"534\":1}}],[\"每次发生批量重偏向时\",{\"1\":{\"1485\":1}}],[\"每次获取数据的时候总认为不会有其它线程对数据进行修改\",{\"1\":{\"1399\":1}}],[\"每次获取数据都认为其它线程会修改\",{\"1\":{\"1399\":1}}],[\"每次都生成一个新的对象\",{\"1\":{\"1236\":1}}],[\"每次都是匹配一个值\",{\"1\":{\"405\":1}}],[\"每次返回的都是同一个对象\",{\"1\":{\"987\":1}}],[\"每次请求都会返回一个新的对象\",{\"1\":{\"987\":1}}],[\"每次提交执行exec后都会自动释放锁\",{\"1\":{\"581\":1}}],[\"每次提交事务的时候分配给这个事务\",{\"1\":{\"468\":1}}],[\"每次遍历部分\",{\"1\":{\"572\":1}}],[\"每次读快照都会重新生成一个快照和read\",{\"1\":{\"542\":1}}],[\"每次等待所花平均时间\",{\"1\":{\"538\":1}}],[\"每次执行语句的时候将它赋值给query\",{\"1\":{\"496\":1}}],[\"每次申请一个新的trx\",{\"1\":{\"497\":1}}],[\"每次申请到的自增id个数都是上一次的两倍\",{\"1\":{\"492\":1}}],[\"每次申请id之前\",{\"1\":{\"491\":1}}],[\"每次重启后\",{\"1\":{\"490\":1}}],[\"每次用客户端连接都会卡在下面这个界面上\",{\"1\":{\"482\":1}}],[\"每次从库执行查询请求前\",{\"1\":{\"472\":1}}],[\"每次从索引a上拿到一个值\",{\"1\":{\"347\":1}}],[\"每次碰到这些错误就停下来\",{\"1\":{\"467\":1}}],[\"每次写入长度为length的redo\",{\"1\":{\"451\":1}}],[\"每次访问分区都由server层控制\",{\"1\":{\"425\":1}}],[\"每次session内操作表的时候\",{\"1\":{\"412\":1}}],[\"每次只需要将我们的所定义好的行为\",{\"1\":{\"1598\":1}}],[\"每次只能根据一个主键id查到一行数据\",{\"1\":{\"404\":1}}],[\"每次只返回一小部分查询结果\",{\"1\":{\"393\":1}}],[\"每次到t2做一次匹配\",{\"1\":{\"402\":1}}],[\"每次搜索一棵树近似复杂度是以2为底的m的对数\",{\"1\":{\"401\":1}}],[\"每次在被驱动表查一行数据\",{\"1\":{\"401\":1}}],[\"每次看到select\",{\"1\":{\"385\":1}}],[\"每次查询的时候\",{\"1\":{\"352\":1}}],[\"每次插入一条新记录\",{\"1\":{\"335\":1}}],[\"每张表有多少行被优化器查询\",{\"1\":{\"329\":1}}],[\"每个executor都是一个线程池\",{\"1\":{\"1686\":1}}],[\"每个event都有crc32的值\",{\"1\":{\"454\":1}}],[\"每个段都会被单独的执行\",{\"1\":{\"1621\":1}}],[\"每个普通的用户进程之间的用户空间是完全隔离的\",{\"1\":{\"1579\":1}}],[\"每个生产者或消费者线程\",{\"1\":{\"1519\":1}}],[\"每个处于偏向锁状态对象的mark\",{\"1\":{\"1485\":1}}],[\"每个处理器都有一个单独的缓存内存\",{\"1\":{\"1474\":1}}],[\"每个context容器负责创建和维护一个webappclassloader加载器实例\",{\"1\":{\"1693\":1}}],[\"每个class对象会有一个对应的epoch字段\",{\"1\":{\"1485\":1}}],[\"每个cell对象存有一个value值\",{\"1\":{\"1480\":1}}],[\"每个channel对应一个buffer缓冲区\",{\"1\":{\"1422\":1}}],[\"每个请求都创建一个线程\",{\"1\":{\"1533\":1}}],[\"每个请求都必须广播到系统中的所有节点\",{\"1\":{\"1474\":1}}],[\"每个请求都有机会获得io资源\",{\"1\":{\"478\":1}}],[\"每个类加载器对他加载过的类\",{\"1\":{\"1432\":1}}],[\"每个链表长度大致相同\",{\"1\":{\"1357\":1}}],[\"每个应用都可以是一个独立的项目\",{\"1\":{\"1304\":1}}],[\"每个成员关联一个分数\",{\"1\":{\"1280\":1}}],[\"每个分片进行数据查询\",{\"1\":{\"1256\":1}}],[\"每个分区对应一个\",{\"1\":{\"424\":1}}],[\"每个sharding都有一个或者多个备份\",{\"1\":{\"1254\":1}}],[\"每个service组件都包含了若干接收客户端消息的connector组件和处理请求的engine组件\",{\"1\":{\"1686\":1}}],[\"每个service的impl都可以指定名称\",{\"1\":{\"1242\":1}}],[\"每个servletrequest内部缓存\",{\"1\":{\"1182\":1}}],[\"每个sentinel节点会对数据节点和其余sentinel节点进行监控\",{\"1\":{\"621\":1}}],[\"每个httpseesion内部缓存\",{\"1\":{\"1182\":1}}],[\"每个bean拥有一个或多个标识符\",{\"1\":{\"928\":1}}],[\"每个配置文件对应修改以下信息\",{\"1\":{\"609\":1}}],[\"每个客户端套接字socket都有对应的读写文件描述符\",{\"1\":{\"603\":1}}],[\"每个\",{\"1\":{\"599\":1}}],[\"每个集合可存储40多亿个成员\",{\"1\":{\"572\":1}}],[\"每个列表超过40亿个元素\",{\"1\":{\"571\":1}}],[\"每个参数大约对应1\",{\"1\":{\"553\":1}}],[\"每个页可以放1170\",{\"1\":{\"503\":1}}],[\"每个非叶子结点可以放16kb\",{\"1\":{\"503\":1}}],[\"每个自增id都是定义了初始值\",{\"1\":{\"493\":1}}],[\"每个mysql实例都维护了一个gtid集合\",{\"1\":{\"468\":1}}],[\"每个事务trx变量的指针地址肯定不同\",{\"1\":{\"497\":1}}],[\"每个事务都会跟一个gtid一一对应\",{\"1\":{\"468\":1}}],[\"每个事务在分发的时候\",{\"1\":{\"461\":1}}],[\"每个事务的binlog里面都有一个时间字段\",{\"1\":{\"457\":1}}],[\"每个worker继续执行\",{\"1\":{\"461\":1}}],[\"每个worker线程对应一个哈希表\",{\"1\":{\"461\":1}}],[\"每个库在收到从自己的主库发过来的日志后\",{\"1\":{\"455\":1}}],[\"每个表都维护了一个变量\",{\"1\":{\"559\":1}}],[\"每个表都有一个对应的table\",{\"1\":{\"454\":1}}],[\"每个表都对应一个table\",{\"1\":{\"412\":1}}],[\"每个1秒\",{\"1\":{\"451\":1}}],[\"每个线程的栈大小\",{\"1\":{\"1664\":1}}],[\"每个线程只需要创建一个工具类的实例\",{\"1\":{\"1528\":1}}],[\"每个线程只操作自己的副本变量\",{\"1\":{\"1236\":1}}],[\"每个线程维护一个队列workqueue\",{\"1\":{\"1510\":1}}],[\"每个线程都想去利用cpu资源来执行自己的任务\",{\"1\":{\"1510\":1}}],[\"每个线程都维护了自己的临时表链表\",{\"1\":{\"412\":1}}],[\"每个线程有自己binlog\",{\"1\":{\"450\":1}}],[\"每个线程一个\",{\"1\":{\"450\":1}}],[\"每个next\",{\"1\":{\"448\":1}}],[\"每个新来的被堵住的线程\",{\"1\":{\"444\":1}}],[\"每个查询功能完全一样\",{\"1\":{\"393\":1}}],[\"每个子任务都会消耗一定的时间\",{\"1\":{\"381\":1}}],[\"每个数据页的大小默认是16kb\",{\"1\":{\"342\":1}}],[\"每个人都有一个唯一的身份证号\",{\"1\":{\"341\":1}}],[\"每个节点的左儿子小于父节点\",{\"1\":{\"334\":1}}],[\"每个文件的大小是1gb\",{\"1\":{\"324\":1}}],[\"每个文档都有一个unique\",{\"1\":{\"304\":1}}],[\"每个字段都有对应的字段类型\",{\"1\":{\"304\":1}}],[\"大家可以搜索下\",{\"1\":{\"1990\":1}}],[\"大概了解每种技术有什么作用即可\",{\"1\":{\"1976\":1}}],[\"大概要经历如下的步骤\",{\"1\":{\"1613\":1}}],[\"大话数据结构\",{\"1\":{\"1966\":1,\"1971\":1}}],[\"大话设计模式\",{\"1\":{\"1966\":1}}],[\"大对象\",{\"1\":{\"1669\":1}}],[\"大体会经过以下几个流程\",{\"1\":{\"1580\":1}}],[\"大体来说\",{\"1\":{\"317\":1}}],[\"大顶堆\",{\"1\":{\"1506\":1}}],[\"大顶堆和小顶堆\",{\"1\":{\"1506\":1}}],[\"大量生产线程被阻塞\",{\"1\":{\"1502\":1}}],[\"大量的减少了配置文件的使用\",{\"1\":{\"1983\":1}}],[\"大量的javabeans可能不经过任何修改就可以在javabean容器当中使用\",{\"1\":{\"912\":1}}],[\"大量的key设置了相同的过期时间\",{\"1\":{\"632\":1}}],[\"大量的空对象会耗费一定的空间\",{\"1\":{\"627\":1}}],[\"大于\",{\"1\":{\"1554\":1}}],[\"大于8就需要转换为红黑树\",{\"1\":{\"1554\":1}}],[\"大于8的话就把链表转换为红黑树\",{\"1\":{\"1549\":1}}],[\"大于64位处理器\",{\"1\":{\"1474\":1}}],[\"大于时就触发了拒绝策略\",{\"1\":{\"1410\":1}}],[\"大于先写入doc的\",{\"1\":{\"304\":1}}],[\"大泥团结构拆分出来的微服务就是泥团结构\",{\"1\":{\"1309\":1}}],[\"大泥团\",{\"1\":{\"1309\":1}}],[\"大型单体应用中\",{\"1\":{\"1304\":1}}],[\"大批量数据高效插入数据库表\",{\"1\":{\"1277\":1}}],[\"大\",{\"1\":{\"595\":1}}],[\"大整数值\",{\"1\":{\"528\":3}}],[\"大小的等功能\",{\"1\":{\"1621\":1}}],[\"大小为2的次幂\",{\"1\":{\"1480\":1}}],[\"大小内存的界限是6gb到8gb\",{\"1\":{\"1449\":1}}],[\"大小\",{\"1\":{\"528\":1,\"529\":1,\"530\":1}}],[\"大查询回滚\",{\"1\":{\"481\":1}}],[\"大多数流的元都是集合\",{\"1\":{\"1619\":1}}],[\"大多数的流都会接收用户指定的一种行为\",{\"1\":{\"1619\":1}}],[\"大多数的互联网应用都是读多写少\",{\"1\":{\"466\":1}}],[\"大多数人都可能会碰到误删数据的场景\",{\"1\":{\"483\":1}}],[\"大多数情况下可以直接定位它的值\",{\"1\":{\"1544\":1}}],[\"大多数情况下主备延迟在1秒内\",{\"1\":{\"471\":1}}],[\"大多数情况下\",{\"1\":{\"407\":1,\"459\":1}}],[\"大纲\",{\"1\":{\"430\":1}}],[\"大表的行数是m\",{\"1\":{\"403\":1}}],[\"大部分性能低下的查询都可以通过减少访问数据量的方式进行优化\",{\"1\":{\"381\":1}}],[\"大致有以下几种方案\",{\"1\":{\"469\":1}}],[\"大致估算出找到所需的记录需要读取的行数\",{\"1\":{\"330\":1}}],[\"大致可以分为两部分\",{\"1\":{\"325\":1}}],[\"大大减少了磁盘io的次数\",{\"1\":{\"308\":1}}],[\"大数据采集\",{\"1\":{\"1327\":1}}],[\"大数据分析\",{\"1\":{\"301\":1}}],[\"大数量分页查询该怎么优化\",{\"0\":{\"165\":1,\"1274\":1}}],[\"保护性暂停模式\",{\"1\":{\"1530\":1}}],[\"保护java的层的类不会被应用程序覆盖\",{\"1\":{\"1432\":1}}],[\"保护这个间隙\",{\"1\":{\"448\":1}}],[\"保障线程安全\",{\"1\":{\"1416\":1}}],[\"保留表结构\",{\"1\":{\"1271\":2}}],[\"保留原来的方式\",{\"1\":{\"967\":1}}],[\"保持刷题的节奏感\",{\"1\":{\"1972\":1}}],[\"保持spring\",{\"1\":{\"1000\":1,\"1001\":1,\"1002\":1}}],[\"保持不变\",{\"1\":{\"447\":1}}],[\"保证加载类的唯一性\",{\"1\":{\"1663\":1}}],[\"保证内核安全\",{\"1\":{\"1579\":1}}],[\"保证了同时只有一个线程修改链表\",{\"1\":{\"1554\":1}}],[\"保证高峰期别把队列塞满就好\",{\"1\":{\"1536\":1}}],[\"保证可见性的方式有两种\",{\"1\":{\"1473\":1}}],[\"保证可见性的方法\",{\"1\":{\"1471\":1}}],[\"保证三个线程有序交错进行的示例\",{\"1\":{\"1404\":1}}],[\"保证三个线程依次执行的示例\",{\"1\":{\"1404\":1}}],[\"保证三个线程同时执行的示例\",{\"1\":{\"1404\":1}}],[\"保证他们同时成功或者同时失败\",{\"1\":{\"1333\":1}}],[\"保证生产者发送消息不丢失策略\",{\"1\":{\"1328\":1}}],[\"保证原子操作\",{\"1\":{\"1287\":1}}],[\"保证索引生效\",{\"1\":{\"1272\":1}}],[\"保证同一个客户端的所有请求都会转发到同一个tomcat实例当中\",{\"1\":{\"1200\":1}}],[\"保证同时刻只有一个线程访问\",{\"1\":{\"630\":1}}],[\"保证读写的正确性\",{\"1\":{\"441\":1}}],[\"保证join语句中被驱动表上join条件字段已经被索引\",{\"1\":{\"364\":1}}],[\"保证后写入的doc的\",{\"1\":{\"304\":1}}],[\"保存局部变量的地方\",{\"1\":{\"1664\":1}}],[\"保存的必须为同一类型的元素\",{\"1\":{\"1538\":1}}],[\"保存所有对象的动态代理配置信息\",{\"1\":{\"1237\":1}}],[\"保存\",{\"1\":{\"354\":2,\"1636\":1}}],[\"保存在es中\",{\"1\":{\"304\":1}}],[\"数组本身也符合容器的定义\",{\"1\":{\"1618\":1}}],[\"数组的缺点\",{\"1\":{\"1538\":1}}],[\"数组的内容\",{\"1\":{\"1527\":1}}],[\"数组的底层实现\",{\"1\":{\"1475\":1}}],[\"数组对于处理器的缓存机制更加友好\",{\"1\":{\"1519\":1}}],[\"数组对象才有\",{\"1\":{\"1484\":1}}],[\"数组长度2n\",{\"1\":{\"1519\":1}}],[\"数组长度\",{\"1\":{\"1484\":2}}],[\"数组未初始化\",{\"1\":{\"1480\":1}}],[\"数组中的单元cell\",{\"1\":{\"1480\":1}}],[\"数组槽\",{\"1\":{\"1480\":1}}],[\"数组查找公式\",{\"1\":{\"1475\":1}}],[\"数组等\",{\"1\":{\"1089\":1}}],[\"数组\",{\"1\":{\"1039\":1,\"1083\":1,\"1423\":1,\"1480\":2,\"1554\":1,\"1619\":1}}],[\"数组类型\",{\"1\":{\"960\":1,\"1099\":1,\"1480\":1}}],[\"数组里最小的id为min\",{\"1\":{\"542\":1}}],[\"数量少可能问题不大\",{\"1\":{\"626\":1}}],[\"数学和加密函数等\",{\"1\":{\"317\":1}}],[\"数字0\",{\"1\":{\"624\":1}}],[\"数字1表示\",{\"1\":{\"621\":1}}],[\"数字\",{\"1\":{\"309\":1,\"527\":1}}],[\"数据访问\",{\"1\":{\"1983\":1}}],[\"数据传输\",{\"0\":{\"1933\":1}}],[\"数据和标签的个数应该相同\",{\"1\":{\"1620\":1}}],[\"数据和索引不在一起\",{\"1\":{\"1266\":1}}],[\"数据和索引是在一起\",{\"1\":{\"1266\":1}}],[\"数据实际上是存储在数组的偶数位置上\",{\"1\":{\"1620\":1}}],[\"数据透视图\",{\"1\":{\"1615\":1}}],[\"数据在内核缓冲区和用户缓冲区之间的cpu拷贝将其省略\",{\"1\":{\"1581\":1}}],[\"数据拷贝次数\",{\"1\":{\"1580\":1,\"1581\":1,\"1582\":1,\"1583\":1,\"1584\":1}}],[\"数据从通道读入缓冲区\",{\"1\":{\"1574\":1}}],[\"数据会先被拷贝到操作系统内核的缓冲区中\",{\"1\":{\"1561\":1}}],[\"数据会回滚\",{\"1\":{\"1263\":1}}],[\"数据元素数组\",{\"1\":{\"1502\":1}}],[\"数据\",{\"1\":{\"1343\":1,\"1474\":1}}],[\"数据一致性\",{\"1\":{\"1326\":1}}],[\"数据链路就会变得很复杂\",{\"1\":{\"1326\":1}}],[\"数据就会不一致\",{\"1\":{\"1287\":1}}],[\"数据有序插入\",{\"1\":{\"1277\":1}}],[\"数据分布不够均匀\",{\"1\":{\"1270\":1}}],[\"数据分片的方式有垂直分片和水平分片\",{\"1\":{\"1270\":1}}],[\"数据设计的时候\",{\"1\":{\"1248\":1}}],[\"数据仓库模式注解\",{\"1\":{\"1131\":1}}],[\"数据仓储模式注解\",{\"1\":{\"1023\":1}}],[\"数据结构推荐大家看\",{\"1\":{\"1971\":1}}],[\"数据结构和算法\",{\"1\":{\"1966\":1}}],[\"数据结构上的限制\",{\"1\":{\"1620\":1}}],[\"数据结构如下\",{\"1\":{\"1502\":1}}],[\"数据结构\",{\"0\":{\"1971\":1},\"1\":{\"1071\":1,\"1503\":1}}],[\"数据来源\",{\"1\":{\"1071\":1,\"1093\":1}}],[\"数据绑定组件\",{\"0\":{\"1070\":1}}],[\"数据绑定和校验错误收集接口\",{\"1\":{\"1062\":1}}],[\"数据绑定\",{\"1\":{\"892\":1,\"1060\":1,\"1081\":1}}],[\"数据操作过程源码剖析\",{\"0\":{\"646\":1}}],[\"数据处理层\",{\"1\":{\"645\":1}}],[\"数据加热的含义就是在正式部署之前\",{\"1\":{\"633\":1}}],[\"数据预热\",{\"1\":{\"633\":1}}],[\"数据同步\",{\"0\":{\"614\":1}}],[\"数据冗余\",{\"1\":{\"607\":1}}],[\"数据的复制是单向的\",{\"1\":{\"606\":1}}],[\"数据的可靠性一般还是要优于可用性\",{\"1\":{\"459\":1}}],[\"数据安全性\",{\"1\":{\"595\":1}}],[\"数据集中不重复的元素的个数\",{\"1\":{\"577\":1}}],[\"数据是不能互通的\",{\"1\":{\"567\":1}}],[\"数据都是缓存在内存中\",{\"1\":{\"564\":1}}],[\"数据先加行锁\",{\"1\":{\"542\":1}}],[\"数据也是一种供需要用户共享的资源\",{\"1\":{\"533\":1}}],[\"数据也一直是累计的\",{\"1\":{\"304\":1}}],[\"数据状态的变更往往是有关联的\",{\"1\":{\"484\":1}}],[\"数据丢失\",{\"1\":{\"459\":1}}],[\"数据很可能悄悄地就不一致了\",{\"1\":{\"459\":1}}],[\"数据不一致的问题更容易被发现\",{\"1\":{\"459\":1}}],[\"数据本身是没有问题的\",{\"1\":{\"447\":1}}],[\"数据定义语句\",{\"1\":{\"437\":1}}],[\"数据总行数是10000\",{\"1\":{\"421\":1}}],[\"数据量小的那个表\",{\"1\":{\"403\":1}}],[\"数据准备如下\",{\"1\":{\"518\":1}}],[\"数据准备\",{\"1\":{\"361\":1,\"362\":1,\"363\":1,\"378\":1}}],[\"数据表空间\",{\"1\":{\"345\":1}}],[\"数据读入内存是需要占用buffer\",{\"1\":{\"343\":1}}],[\"数据读取操作的操作类型\",{\"1\":{\"329\":1}}],[\"数据库特性和数据库连接池\",{\"1\":{\"1974\":1}}],[\"数据库\",{\"0\":{\"1973\":1},\"1\":{\"1288\":1}}],[\"数据库中有\",{\"1\":{\"1283\":1}}],[\"数据库中也查询不到\",{\"1\":{\"1282\":1}}],[\"数据库中的情况\",{\"1\":{\"447\":1}}],[\"数据库连接池是为了避免频繁地创建和销毁\",{\"1\":{\"1974\":1}}],[\"数据库连接池\",{\"1\":{\"1196\":1}}],[\"数据库名\",{\"1\":{\"558\":1}}],[\"数据库会先对该行加排他锁\",{\"1\":{\"542\":1}}],[\"数据库当中的每一行记录除了我们自定义的字段外\",{\"1\":{\"542\":1}}],[\"数据库需要合理地控制资源的访问规则\",{\"1\":{\"436\":1}}],[\"数据库锁的设计的初衷是处理并发问题\",{\"1\":{\"436\":1}}],[\"数据库里面它可能用到的回滚记录都必须保留\",{\"1\":{\"434\":1}}],[\"数据库里面会创建一个视图\",{\"1\":{\"433\":1}}],[\"数据库的crud操作\",{\"1\":{\"1974\":1}}],[\"数据库的事务隔离级别越严格\",{\"1\":{\"532\":1}}],[\"数据库的行为是有所不同的\",{\"1\":{\"433\":1}}],[\"数据库的慢查询日志中\",{\"1\":{\"322\":1}}],[\"数据库还维护着一个满足特定查找算法的数据结构\",{\"1\":{\"331\":1}}],[\"数据查询的类型\",{\"1\":{\"330\":1}}],[\"数据将会通过分词被切分为不同的trem\",{\"1\":{\"308\":1}}],[\"数值没有被修改\",{\"1\":{\"581\":1}}],[\"数值类型\",{\"0\":{\"528\":1}}],[\"数值\",{\"1\":{\"304\":1}}],[\"字典的键为正在被订阅的频道\",{\"1\":{\"599\":1}}],[\"字典区间的成员\",{\"1\":{\"574\":2}}],[\"字节码与数据类型\",{\"0\":{\"1784\":1}}],[\"字节码指令\",{\"0\":{\"1783\":1}}],[\"字节码有记录\",{\"1\":{\"1100\":2}}],[\"字节码提升\",{\"1\":{\"899\":1,\"900\":1}}],[\"字节流\",{\"1\":{\"1026\":1}}],[\"字节\",{\"1\":{\"528\":7,\"529\":1,\"530\":1}}],[\"字样\",{\"1\":{\"403\":1}}],[\"字符编码控制\",{\"1\":{\"1052\":1}}],[\"字符编码集\",{\"0\":{\"691\":1}}],[\"字符输入流\",{\"1\":{\"1040\":1,\"1041\":1}}],[\"字符流\",{\"1\":{\"1026\":1}}],[\"字符要加单引号\",{\"0\":{\"376\":1},\"1\":{\"376\":1}}],[\"字符串不可变的特性就是其设计基础\",{\"1\":{\"1342\":1}}],[\"字符串不加单引号索引失效\",{\"1\":{\"369\":1}}],[\"字符串短\",{\"1\":{\"530\":1}}],[\"字符串的长度相差较大用varchar\",{\"1\":{\"530\":1}}],[\"字符串和数字做比较的话\",{\"1\":{\"367\":1}}],[\"字符串添加索引\",{\"0\":{\"349\":1}}],[\"字符串\",{\"0\":{\"530\":1,\"570\":1},\"1\":{\"304\":1,\"527\":1,\"1280\":1}}],[\"字段表集合\",{\"0\":{\"1780\":1}}],[\"字段信息\",{\"1\":{\"1663\":1}}],[\"字段注入的示例\",{\"1\":{\"955\":1}}],[\"字段注入\",{\"0\":{\"955\":1},\"1\":{\"958\":1,\"969\":1}}],[\"字段名称\",{\"1\":{\"963\":1}}],[\"字段名\",{\"1\":{\"558\":1}}],[\"字段无索引\",{\"1\":{\"526\":1}}],[\"字段无法被搜索\",{\"1\":{\"308\":1}}],[\"字段有索引\",{\"1\":{\"526\":1}}],[\"字段c有唯一约束\",{\"1\":{\"491\":1}}],[\"字段b上无索引\",{\"1\":{\"400\":1}}],[\"字段rows\",{\"1\":{\"322\":1}}],[\"字段等\",{\"1\":{\"309\":1}}],[\"字段\",{\"0\":{\"330\":1},\"1\":{\"306\":1,\"309\":1,\"371\":1,\"399\":6,\"526\":1,\"951\":1,\"964\":1,\"1254\":1}}],[\"字段的类型可以指定或者通过es自动推算\",{\"1\":{\"304\":1}}],[\"二者在大部分属性的设定上都是类似的\",{\"1\":{\"1621\":1}}],[\"二者是不同的\",{\"1\":{\"1561\":1}}],[\"二者都是一起执行的\",{\"1\":{\"1470\":1}}],[\"二次哈希\",{\"1\":{\"1553\":1}}],[\"二维码登录\",{\"1\":{\"1199\":1}}],[\"二从\",{\"1\":{\"610\":1}}],[\"二是工作线程从队列中获取任务时存在竞争情况\",{\"1\":{\"1510\":1}}],[\"二是如果索引改了名字\",{\"1\":{\"348\":1}}],[\"二是语句q2为什么优化器没有选择37116行的执行计划\",{\"1\":{\"347\":1}}],[\"二叉树\",{\"1\":{\"501\":1,\"1265\":1}}],[\"二叉树是搜索效率最高的\",{\"1\":{\"334\":1}}],[\"二叉搜索树的特点是\",{\"1\":{\"334\":1}}],[\"二叉搜索树\",{\"0\":{\"334\":1}}],[\"二进制形式的极大文本数据\",{\"1\":{\"530\":1}}],[\"二进制形式的中等长度文本数据\",{\"1\":{\"530\":1}}],[\"二进制形式的长文本数据\",{\"1\":{\"530\":1}}],[\"二进制\",{\"1\":{\"304\":1,\"527\":1}}],[\"二级缓存会保存new出来的不完整对象\",{\"1\":{\"1237\":1}}],[\"二级缓存与一级缓存机制相同\",{\"1\":{\"1218\":1}}],[\"二级缓存的实现采用了装饰器设计模式\",{\"1\":{\"645\":1}}],[\"二级缓存\",{\"0\":{\"202\":1,\"1218\":1}}],[\"日常也都规定只使用只读账号\",{\"1\":{\"487\":1}}],[\"日常开发需要注意的结论\",{\"1\":{\"431\":1}}],[\"日期值\",{\"1\":{\"529\":1}}],[\"日期和时间\",{\"0\":{\"529\":1}}],[\"日期\",{\"1\":{\"304\":1,\"1087\":2}}],[\"日志体系\",{\"0\":{\"1679\":1}}],[\"日志分析\",{\"1\":{\"1327\":1}}],[\"日志分析工具mysqldumpslow\",{\"1\":{\"429\":1}}],[\"日志分析工具\",{\"0\":{\"429\":1}}],[\"日志场景\",{\"0\":{\"744\":1}}],[\"日志文件名\",{\"1\":{\"609\":1}}],[\"日志文件中的日志项\",{\"1\":{\"304\":1}}],[\"日志是写在123这个位置之后的\",{\"1\":{\"467\":1}}],[\"日志从主库传给备库所需的时间是很短的\",{\"1\":{\"457\":1}}],[\"日志的执行流程就会变成这样\",{\"1\":{\"455\":1}}],[\"日志写入到redo\",{\"1\":{\"451\":1}}],[\"日志类的系统\",{\"1\":{\"344\":1}}],[\"日志管理与分析\",{\"1\":{\"301\":1}}],[\"一周学会linux视频\",{\"1\":{\"1987\":1}}],[\"一入java深似海\",{\"1\":{\"1967\":1}}],[\"一部分是用户空间\",{\"1\":{\"1579\":1}}],[\"一部分是内核空间\",{\"1\":{\"1579\":1}}],[\"一下表的大小\",{\"1\":{\"1550\":1}}],[\"一条消息只会被一个消费者消费\",{\"1\":{\"1521\":1}}],[\"一条查询语句的执行成本是由下面这两个方面组成的\",{\"1\":{\"545\":1}}],[\"一段代码块如果存在对共享资源的多线程读写操作\",{\"1\":{\"1482\":1}}],[\"一组规则\",{\"1\":{\"1473\":1}}],[\"一组事务在commit的时候\",{\"1\":{\"464\":1}}],[\"一些涉及底层的程序编写往往会围绕着文件描述符展开\",{\"1\":{\"1561\":1}}],[\"一些常驻的异常对象\",{\"1\":{\"1438\":1}}],[\"一些归档性的数据\",{\"1\":{\"457\":1}}],[\"一共有以下四种收集方式\",{\"1\":{\"1434\":1}}],[\"一文理解kafka重复消费的原因和解决方案\",{\"1\":{\"1334\":1}}],[\"一级缓存就会失效\",{\"1\":{\"1653\":1}}],[\"一级缓存\",{\"1\":{\"1218\":1}}],[\"一方面创建线程比较耗时\",{\"1\":{\"1533\":1}}],[\"一方面保证数据传输安全\",{\"1\":{\"1424\":1}}],[\"一方面\",{\"1\":{\"1208\":1}}],[\"一处登录\",{\"1\":{\"1204\":1}}],[\"一处注册\",{\"1\":{\"1204\":1}}],[\"一直会找到所有父类中的属性的方法\",{\"1\":{\"964\":1}}],[\"一主\",{\"1\":{\"610\":1}}],[\"一主二从配置\",{\"0\":{\"610\":1}}],[\"一主多从的时候\",{\"1\":{\"472\":1}}],[\"一主多从的切换场景下\",{\"1\":{\"468\":1}}],[\"一主多从的结构在切换完成后\",{\"1\":{\"466\":1}}],[\"一主多从的设置\",{\"1\":{\"466\":1}}],[\"一主多从的方式比较常用\",{\"1\":{\"457\":1}}],[\"一主多从\",{\"0\":{\"466\":1},\"1\":{\"457\":1}}],[\"一致\",{\"1\":{\"522\":1}}],[\"一致性哈希策略\",{\"0\":{\"1895\":1}}],[\"一致性机制\",{\"1\":{\"1474\":1}}],[\"一致性可以在加载\",{\"1\":{\"1474\":1}}],[\"一致性\",{\"1\":{\"432\":1,\"1262\":1,\"1311\":1}}],[\"一次请求若在缓存和数据库中都没找到\",{\"1\":{\"627\":1}}],[\"一次性完成\",{\"1\":{\"579\":1}}],[\"一次性\",{\"1\":{\"578\":1}}],[\"一次性地使用delete语句删除太多数据\",{\"1\":{\"457\":1}}],[\"一次一行循环地从第一张表\",{\"1\":{\"524\":1}}],[\"一次组提交里面\",{\"1\":{\"451\":1}}],[\"一次是binlog\",{\"1\":{\"451\":1}}],[\"一次是redo\",{\"1\":{\"451\":1}}],[\"一次删除一万行数据一般来说时一个比较高效而且对服务器影响也最小的做法\",{\"1\":{\"393\":1}}],[\"一种理想的trysplit方法在没有进行遍历的情况下\",{\"1\":{\"1620\":1}}],[\"一种方式当然可以调整范围\",{\"1\":{\"1607\":1}}],[\"一种方案是将这个工具类作为局部变量使用\",{\"1\":{\"1528\":1}}],[\"一种方法是\",{\"1\":{\"348\":1,\"444\":1}}],[\"一种做法就是前面提到的beanpostprocess\",{\"1\":{\"985\":1}}],[\"一种做法是\",{\"1\":{\"467\":1}}],[\"一种加速方式是\",{\"1\":{\"485\":1}}],[\"一种取位点的方法是这样的\",{\"1\":{\"467\":1}}],[\"一种场景就是一场切换\",{\"1\":{\"459\":1}}],[\"一种策略是\",{\"1\":{\"444\":1}}],[\"一种是初始状态\",{\"1\":{\"1623\":1}}],[\"一种是在实现类中重写方法\",{\"1\":{\"1607\":1}}],[\"一种是传递值\",{\"1\":{\"1593\":1}}],[\"一种是内存屏障\",{\"1\":{\"1473\":1}}],[\"一种是使用\",{\"1\":{\"1237\":1}}],[\"一种是隐形覆盖\",{\"1\":{\"1137\":1}}],[\"一种是隐性的别名\",{\"1\":{\"1136\":1}}],[\"一种是显性覆盖\",{\"1\":{\"1137\":1}}],[\"一种是显性的别名\",{\"1\":{\"1136\":1}}],[\"一种是number这个属性本来是没有值的\",{\"1\":{\"1003\":1}}],[\"一种是本地缓存\",{\"1\":{\"482\":1}}],[\"一种是转到主库查询\",{\"1\":{\"473\":1}}],[\"一种是超时放弃\",{\"1\":{\"473\":1}}],[\"一种是row\",{\"1\":{\"454\":1}}],[\"一种是statement\",{\"1\":{\"454\":1}}],[\"一种是\",{\"1\":{\"451\":1}}],[\"一种是元数据锁\",{\"1\":{\"439\":1}}],[\"一种是表锁\",{\"1\":{\"439\":1}}],[\"一边直接得到结果\",{\"1\":{\"418\":1}}],[\"一边写一边后移\",{\"1\":{\"324\":1}}],[\"一行行地取到业务端\",{\"1\":{\"408\":1}}],[\"一行行地取出a的值\",{\"1\":{\"405\":1}}],[\"一行行地从记录里面读出这个字段\",{\"1\":{\"399\":1}}],[\"一行行地判断\",{\"1\":{\"399\":1}}],[\"一定要找一些题目练习一下\",{\"1\":{\"1974\":1}}],[\"一定要大于或者等于当前的和返回的新的spliterator的estimatesize方法所返回的值\",{\"1\":{\"1620\":1}}],[\"一定要指定名称为conversionservice\",{\"1\":{\"1091\":1}}],[\"一定就是myinterface\",{\"1\":{\"1595\":2}}],[\"一定不会修改同一行\",{\"1\":{\"464\":1}}],[\"一定不能写select\",{\"1\":{\"330\":1}}],[\"一定碰到过需要根据指定的字段排序来显示结果的需求\",{\"1\":{\"353\":1}}],[\"一是无法对大任务进行拆分\",{\"1\":{\"1510\":1}}],[\"一是这么写不足够优雅\",{\"1\":{\"348\":1}}],[\"一是语句q1优化器为什么没有选择索引\",{\"1\":{\"347\":1}}],[\"一般建议在jvm参数中将metaspacesize和maxmetaspacesize设置成一样的值\",{\"1\":{\"1664\":1}}],[\"一般翻译为饮水槽\",{\"1\":{\"1622\":1}}],[\"一般而言stream由3个部分组成\",{\"1\":{\"1607\":1}}],[\"一般这个时候\",{\"1\":{\"1607\":1}}],[\"一般会将这两个值设置成256m\",{\"1\":{\"1664\":1}}],[\"一般会将socket都设置为非阻塞\",{\"1\":{\"1565\":1}}],[\"一般会几种在以下两类\",{\"1\":{\"400\":1}}],[\"一般不要轻易修改\",{\"1\":{\"1546\":1}}],[\"一般不建议将这个参数设成0\",{\"1\":{\"450\":1}}],[\"一般不建议启动该参数\",{\"1\":{\"428\":1}}],[\"一般是读就绪或者写就绪\",{\"1\":{\"1568\":1}}],[\"一般是通过一个内部类sync继承aqs\",{\"1\":{\"1490\":1}}],[\"一般是出现在数据初始化以及key过期了的情况\",{\"1\":{\"1283\":1}}],[\"一般使用版本号机制或cas操作实现\",{\"1\":{\"1399\":1}}],[\"一般\",{\"1\":{\"911\":1,\"1423\":2}}],[\"一般时间很短\",{\"1\":{\"587\":1}}],[\"一般来讲\",{\"1\":{\"555\":1}}],[\"一般来说有3种\",{\"1\":{\"569\":1}}],[\"一般来说\",{\"1\":{\"330\":1,\"596\":1,\"1972\":1}}],[\"一般用于全库备份的时候\",{\"1\":{\"1263\":1}}],[\"一般用于读写分离\",{\"1\":{\"466\":1}}],[\"一般用在整表数据迁移的场景\",{\"1\":{\"534\":1}}],[\"一般应该遵循下面两步\",{\"1\":{\"527\":1}}],[\"一般都会使用bnl算法\",{\"1\":{\"525\":1}}],[\"一般都会选择第二种策略\",{\"1\":{\"444\":1}}],[\"一般在join语句中\",{\"1\":{\"524\":1}}],[\"一般在1\",{\"1\":{\"389\":1}}],[\"一般的公司建议使用timestamp\",{\"1\":{\"529\":1}}],[\"一般的主备复制结构存在的问题是\",{\"1\":{\"486\":1}}],[\"一般的做法是\",{\"1\":{\"477\":1}}],[\"一般情况下\",{\"1\":{\"411\":1,\"450\":1,\"555\":1,\"1375\":1}}],[\"一般分库分表的场景\",{\"1\":{\"411\":1}}],[\"一般mysql能够使用如下三种方式应用where条件\",{\"1\":{\"390\":1}}],[\"一般常见和重要的是等待是i\",{\"1\":{\"388\":1}}],[\"一般就是在where语句中出现了between\",{\"1\":{\"330\":1}}],[\"一般至少有两行参数\",{\"1\":{\"307\":1}}],[\"一块是server层\",{\"1\":{\"325\":1}}],[\"一旦有一个handler成功匹配\",{\"1\":{\"1657\":1}}],[\"一旦有新消息产生\",{\"1\":{\"1519\":1}}],[\"一旦有新增的文档写入\",{\"1\":{\"309\":1}}],[\"一旦一个结果被传递给了combiner或者finisher方法\",{\"1\":{\"1615\":1}}],[\"一旦某个描述符就绪\",{\"1\":{\"1568\":1}}],[\"一旦kernel中的数据准备好了\",{\"1\":{\"1564\":1}}],[\"一旦拉链过长\",{\"1\":{\"1546\":1}}],[\"一旦出现了并发冲突\",{\"1\":{\"1480\":1}}],[\"一旦出现死锁\",{\"1\":{\"444\":1}}],[\"一旦ｍｑ宕机\",{\"1\":{\"1326\":1}}],[\"一旦发现类似问题\",{\"1\":{\"1297\":1}}],[\"一旦热点数据多了起来\",{\"1\":{\"630\":1}}],[\"一旦主节点出现故障\",{\"1\":{\"621\":1}}],[\"一旦主节点出了故障不可达的情况\",{\"1\":{\"621\":1}}],[\"一旦主节点不能支撑住大并发量的读操作\",{\"1\":{\"621\":2}}],[\"一旦期间有任何事情刀来\",{\"1\":{\"603\":1}}],[\"一旦并发线程数达到这个值\",{\"1\":{\"476\":1}}],[\"一旦生成后\",{\"1\":{\"309\":1}}],[\"一旦已经有数据写入\",{\"1\":{\"309\":1}}],[\"一旦数据发生更改\",{\"1\":{\"304\":1}}],[\"一样只适用于整数型字段\",{\"1\":{\"573\":1}}],[\"一样时的冲突\",{\"1\":{\"304\":1}}],[\"一样\",{\"1\":{\"304\":1}}],[\"一篇文档包含了一系列字段\",{\"1\":{\"304\":1}}],[\"一篇pdf文档中的具体内容\",{\"1\":{\"304\":1}}],[\"一张唱片的详细信息\",{\"1\":{\"304\":1}}],[\"一本电影的具体信息\",{\"1\":{\"304\":1}}],[\"一个高并发项目到落地的心酸路\",{\"1\":{\"1965\":1}}],[\"一个engine组件处理service中的所有请求\",{\"1\":{\"1683\":1}}],[\"一个方法对应一块独立的栈帧内存区域\",{\"1\":{\"1664\":1}}],[\"一个advisor\",{\"1\":{\"1655\":1}}],[\"一个切面中\",{\"1\":{\"1654\":1}}],[\"一个名字可以对应多个别名\",{\"1\":{\"1636\":1}}],[\"一个终止操作描述了描述了流是如何处理流中元素的\",{\"1\":{\"1623\":1}}],[\"一个终止操作会拥有一个输入类型和一个流的类型\",{\"1\":{\"1623\":1}}],[\"一个具体的中间阶段通常是通过abstractpipeline构建出来的\",{\"1\":{\"1621\":1}}],[\"一个元在结构上的改变是可以通过如下的几种方式来进行管理的\",{\"1\":{\"1620\":1}}],[\"一个调用了trysplit的一个线程\",{\"1\":{\"1620\":1}}],[\"一个估算的值\",{\"1\":{\"1620\":1}}],[\"一个setsqlsessiontemplate\",{\"1\":{\"1653\":1}}],[\"一个setsqlsessionfactory\",{\"1\":{\"1653\":1}}],[\"一个selector可以注册多个channel\",{\"1\":{\"1574\":1}}],[\"一个sqlsession对象需要sqlsessionfactory来产生\",{\"1\":{\"1653\":1}}],[\"一个sink一定是处于两种状态之一的\",{\"1\":{\"1623\":1}}],[\"一个spliterator也可以对它的元素使用trysplit进行分区\",{\"1\":{\"1620\":1}}],[\"一个spliterator可以使用tryadvance单个的遍历元素\",{\"1\":{\"1620\":1}}],[\"一个流调用中间操作或者终止操作只能被操作一次\",{\"1\":{\"1619\":1}}],[\"一个流管道包含了0个或多个中间阶段\",{\"1\":{\"1623\":1}}],[\"一个流管道包含了一个元\",{\"1\":{\"1619\":1}}],[\"一个流管道\",{\"1\":{\"1619\":1}}],[\"一个i\",{\"1\":{\"1619\":1}}],[\"一个生成器法\",{\"1\":{\"1619\":1}}],[\"一个集合\",{\"1\":{\"1619\":1}}],[\"一个并发的结果容器在什么情况下使用呢\",{\"1\":{\"1615\":1}}],[\"一个多线程的汇聚操作指的是accumulator同时被多个线程调用\",{\"1\":{\"1615\":1}}],[\"一个正是我们前面举出的例子\",{\"1\":{\"1608\":1}}],[\"一个正常的请求会将合法用户的session\",{\"1\":{\"1201\":1}}],[\"一个正常访问的数据页\",{\"1\":{\"406\":1}}],[\"一个可变的汇聚操作指的是将值汇聚到可变的结果容器\",{\"1\":{\"1608\":1}}],[\"一个函数式接口\",{\"1\":{\"1594\":1}}],[\"一个进程可以监视多个描述符\",{\"1\":{\"1568\":1}}],[\"一个进程至少有一个线程\",{\"1\":{\"1374\":1}}],[\"一个典型的读操作流程大致如下\",{\"1\":{\"1563\":1}}],[\"一个典型的报错情况是这样的\",{\"1\":{\"425\":1}}],[\"一个服务提供方从上线到反馈到客户端的路由表里\",{\"1\":{\"1527\":1}}],[\"一个程序运行多个线程本身是没有问题的\",{\"1\":{\"1482\":1}}],[\"一个程序至少有一个进程\",{\"1\":{\"1374\":1}}],[\"一个cell\",{\"1\":{\"1480\":1}}],[\"一个线程处理一个任务\",{\"1\":{\"1533\":1}}],[\"一个线程的执行依赖于另一个线程的消息\",{\"1\":{\"1477\":1}}],[\"一个线程就是一个cpu可以执行的指令序列\",{\"1\":{\"1477\":1}}],[\"一个副本在请求它的每个处理器的本地缓存中\",{\"1\":{\"1474\":1}}],[\"一个副本在主内存中\",{\"1\":{\"1474\":1}}],[\"一个对象只有\",{\"1\":{\"1435\":1}}],[\"一个对象从加载到jvm\",{\"0\":{\"105\":1,\"1436\":1}}],[\"一个不存储元素的阻塞队列\",{\"1\":{\"1395\":1}}],[\"一个使用优先级队列实现的无界阻塞队列\",{\"1\":{\"1395\":1}}],[\"一个支持优先级排序的无界阻塞队列\",{\"1\":{\"1395\":1}}],[\"一个由链表结构组成的双向阻塞队列\",{\"1\":{\"1395\":1}}],[\"一个由链表结构组成的无界阻塞队列\",{\"1\":{\"1395\":1}}],[\"一个由链表结构组成的有界阻塞队列\",{\"1\":{\"1395\":1}}],[\"一个由数组结构组成的有界阻塞队列\",{\"1\":{\"1395\":1}}],[\"一个类可以实现多个接口\",{\"1\":{\"1345\":1}}],[\"一个表的数据量超过500w或者数据文件超过2g\",{\"1\":{\"1270\":1}}],[\"一个用于写入操作\",{\"1\":{\"1498\":1}}],[\"一个用于只读操作\",{\"1\":{\"1498\":2}}],[\"一个用于具体的处理\",{\"1\":{\"1226\":1}}],[\"一个用于接收连接\",{\"1\":{\"1226\":1}}],[\"一个用户多次访问\",{\"1\":{\"577\":1}}],[\"一个用户成功建立连接后\",{\"1\":{\"318\":1}}],[\"一个javaweb应用只创建一个servletcontext对象\",{\"1\":{\"988\":1}}],[\"一个beanfactory有且仅有一个实例\",{\"1\":{\"983\":1,\"1235\":1}}],[\"一个bean仅有一个标识符\",{\"1\":{\"928\":1}}],[\"一个热点新闻被同时大量访问就可能导致缓存击穿\",{\"1\":{\"629\":1}}],[\"一个存在的key\",{\"1\":{\"629\":1}}],[\"一个脚本的最大执行时间为60s\",{\"1\":{\"624\":1}}],[\"一个主节点可以有0个或者多个从节点\",{\"1\":{\"606\":1}}],[\"一个循环为一个周期\",{\"1\":{\"603\":1}}],[\"一个列表最多可以包含\",{\"1\":{\"571\":1}}],[\"一个redis实例提供了多个用来存储数据的字典\",{\"1\":{\"567\":1}}],[\"一个页就是一个块\",{\"1\":{\"557\":1}}],[\"一个值的重复次数\",{\"1\":{\"553\":1}}],[\"一个自然而然的结果就是trx\",{\"1\":{\"497\":1}}],[\"一个好处是\",{\"1\":{\"497\":1}}],[\"一个在执行线上逻辑的主库\",{\"1\":{\"484\":1}}],[\"一个语句执行过程中有多处\",{\"1\":{\"481\":1}}],[\"一个机器的cpu核数有限\",{\"1\":{\"476\":1}}],[\"一个更新事务马上发起查询\",{\"1\":{\"469\":1}}],[\"一个箭头代表了客户端写入库\",{\"1\":{\"460\":1}}],[\"一个备库接到binlog并在重放的过程中\",{\"1\":{\"455\":1}}],[\"一个没有提交的事务的redo\",{\"1\":{\"451\":1}}],[\"一个查询正在遍历一个表中的数据\",{\"1\":{\"441\":1}}],[\"一个事务的binlog在主备之间流转的状态如下\",{\"1\":{\"472\":1}}],[\"一个事务的binlog是不能被拆开的\",{\"1\":{\"450\":1}}],[\"一个事务日志同步的完整过程如下\",{\"1\":{\"453\":1}}],[\"一个事务完整提交前\",{\"1\":{\"451\":1}}],[\"一个事务执行过程中看到的数据\",{\"1\":{\"433\":1}}],[\"一个事务提交之后\",{\"1\":{\"433\":1}}],[\"一个事务还没有提交时\",{\"1\":{\"433\":1}}],[\"一个分区表就只是一个表\",{\"1\":{\"425\":1}}],[\"一个是在它的静态内部类head中\",{\"1\":{\"1622\":1}}],[\"一个是没有设置concurrent特性\",{\"1\":{\"1617\":1}}],[\"一个是并行流\",{\"1\":{\"1617\":1}}],[\"一个是间接找到对象\",{\"1\":{\"1561\":1}}],[\"一个是直接找到对象\",{\"1\":{\"1561\":1}}],[\"一个是代表\",{\"1\":{\"1561\":1}}],[\"一个是指向\",{\"1\":{\"1561\":1}}],[\"一个是仅检查终止标志位是不够的\",{\"1\":{\"1524\":1}}],[\"一个是必须配合sychronized使用\",{\"1\":{\"1477\":1}}],[\"一个是内核空间\",{\"1\":{\"1423\":1}}],[\"一个是用户空间\",{\"1\":{\"1423\":1}}],[\"一个是事件的描述\",{\"1\":{\"624\":1}}],[\"一个是事件的类型\",{\"1\":{\"624\":1}}],[\"一个是kill\",{\"1\":{\"480\":2}}],[\"一个是系统配置库\",{\"1\":{\"463\":1}}],[\"一个是第一次访问的时候需要访问所有分区\",{\"1\":{\"426\":1}}],[\"一个是由应用层代码决定使用哪个分表\",{\"1\":{\"424\":1}}],[\"一个是由server层来决定使用哪个分区\",{\"1\":{\"424\":1}}],[\"一个是double类型\",{\"1\":{\"420\":1}}],[\"一个普通表的table\",{\"1\":{\"412\":1}}],[\"一个临时表只能被创建它的session访问\",{\"1\":{\"410\":1}}],[\"一个常见的错误是常常会误以为mysql只会返回需要的数据\",{\"1\":{\"383\":1}}],[\"一个一个地判断tradeid的值是否匹配\",{\"1\":{\"368\":1}}],[\"一个数据页就可以放近千个key\",{\"1\":{\"342\":1}}],[\"一个10亿行的表上一个整数字段的索引\",{\"1\":{\"334\":1}}],[\"一个或者多个\",{\"1\":{\"330\":1,\"571\":2}}],[\"一个系统的配置表\",{\"1\":{\"319\":1}}],[\"一个索引的选择性越接近于1\",{\"1\":{\"359\":1}}],[\"一个索引上不同的值越多\",{\"1\":{\"347\":1}}],[\"一个索引由一个名字来表示同意\",{\"1\":{\"303\":1}}],[\"一个索引就是一个拥有几分相似特征的文档的集合\",{\"1\":{\"303\":1}}],[\"文案模板参数\",{\"1\":{\"1050\":1}}],[\"文案模板编码\",{\"1\":{\"1050\":1}}],[\"文件不可以完全存储消息\",{\"0\":{\"1886\":1}}],[\"文件可以完全存储消息\",{\"0\":{\"1885\":1}}],[\"文件资源等等\",{\"1\":{\"1637\":1}}],[\"文件的读写\",{\"1\":{\"1510\":1}}],[\"文件的完整性会更加好\",{\"1\":{\"593\":1}}],[\"文件描述符在形式上是一个非负整数\",{\"1\":{\"1561\":1}}],[\"文件描述符\",{\"1\":{\"1423\":1,\"1561\":1}}],[\"文件系统\",{\"1\":{\"1037\":1,\"1039\":1}}],[\"文件名\",{\"1\":{\"1464\":1}}],[\"文件名可以在配置文件中进行自定义\",{\"1\":{\"586\":1}}],[\"文件名的后缀是\",{\"1\":{\"412\":1}}],[\"文件排序信息\",{\"1\":{\"520\":1}}],[\"文件也不会变小\",{\"1\":{\"434\":1}}],[\"文件内排序\",{\"1\":{\"330\":1}}],[\"文档写入失败\",{\"1\":{\"309\":1}}],[\"文档映射mapping\",{\"0\":{\"309\":1}}],[\"文档id\",{\"1\":{\"308\":1}}],[\"文档必须已经存在\",{\"1\":{\"306\":1}}],[\"文档操作\",{\"0\":{\"306\":1}}],[\"文档的版本号\",{\"1\":{\"304\":1}}],[\"文档的原始json数据\",{\"1\":{\"304\":1}}],[\"文档的元数据信息\",{\"1\":{\"304\":1}}],[\"文档唯一id\",{\"1\":{\"304\":1}}],[\"文档所属的类型名\",{\"1\":{\"304\":1}}],[\"文档所属的索引名\",{\"1\":{\"304\":1}}],[\"文档会被序列化成json格式\",{\"1\":{\"304\":1}}],[\"文档是所有可搜索数据的最小单位\",{\"1\":{\"304\":1}}],[\"文档\",{\"0\":{\"304\":1},\"1\":{\"1254\":1}}],[\"文章\",{\"1\":{\"361\":1}}],[\"文章内容\",{\"1\":{\"300\":1}}],[\"文章标题\",{\"1\":{\"300\":1}}],[\"文章id\",{\"1\":{\"300\":2}}],[\"搜索和分析海量数据\",{\"1\":{\"1986\":1}}],[\"搜索的效率也就会越低\",{\"1\":{\"352\":1}}],[\"搜索树\",{\"1\":{\"331\":1}}],[\"搜索\",{\"1\":{\"303\":1}}],[\"搜索引擎为什么mysql查询快\",{\"0\":{\"171\":1,\"1253\":1}}],[\"索引文件结构\",{\"0\":{\"1920\":1}}],[\"索引按照score排序\",{\"1\":{\"574\":1}}],[\"索引从左往右\",{\"1\":{\"571\":1}}],[\"索引名\",{\"1\":{\"558\":1}}],[\"索引名称\",{\"1\":{\"306\":4}}],[\"索引注释信息\",{\"1\":{\"553\":1}}],[\"索引所属表的名称\",{\"1\":{\"553\":1}}],[\"索引后上\",{\"1\":{\"521\":1}}],[\"索引设计原则\",{\"0\":{\"521\":1}}],[\"索引使用成本\",{\"1\":{\"519\":1}}],[\"索引使用范围\",{\"1\":{\"519\":1}}],[\"索引扫描行数\",{\"1\":{\"519\":1}}],[\"索引实现\",{\"0\":{\"505\":1}}],[\"索引z上的数据就是类似上图中的有序数据了\",{\"1\":{\"417\":1}}],[\"索引让mysql以最高效\",{\"1\":{\"390\":1}}],[\"索引再合适\",{\"1\":{\"381\":1}}],[\"索引优化实践\",{\"0\":{\"517\":1}}],[\"索引优化\",{\"1\":{\"381\":1}}],[\"索引优化的一般性建议\",{\"1\":{\"380\":1}}],[\"索引优化几乎和order\",{\"1\":{\"378\":1}}],[\"索引相关题目\",{\"0\":{\"377\":1}}],[\"索引列注释信息\",{\"1\":{\"553\":1}}],[\"索引列如何被压缩\",{\"1\":{\"553\":1}}],[\"索引列中不重复值的数量\",{\"1\":{\"553\":1}}],[\"索引列中的值是按照何种排序方式存放的\",{\"1\":{\"553\":1}}],[\"索引列的个数\",{\"1\":{\"558\":1}}],[\"索引列的名称\",{\"1\":{\"553\":1}}],[\"索引列的值是否是唯一的\",{\"1\":{\"553\":1}}],[\"索引列在索引中的位置\",{\"1\":{\"553\":1}}],[\"索引列上不计算\",{\"0\":{\"371\":1},\"1\":{\"371\":1}}],[\"索引列和查询列一致\",{\"1\":{\"369\":1}}],[\"索引没用上\",{\"1\":{\"370\":2}}],[\"索引中范围条件右边的字段会全部失效\",{\"1\":{\"369\":1}}],[\"索引t\",{\"1\":{\"366\":1}}],[\"索引看起来非常美好\",{\"1\":{\"365\":1}}],[\"索引失效的总结\",{\"0\":{\"380\":1}}],[\"索引失效的原理分析\",{\"0\":{\"379\":1}}],[\"索引失效的场景\",{\"0\":{\"369\":1}}],[\"索引失效\",{\"0\":{\"365\":1},\"1\":{\"374\":1,\"375\":3,\"376\":1}}],[\"索引结构\",{\"1\":{\"350\":1}}],[\"索引占用的空间会更小\",{\"1\":{\"350\":1}}],[\"索引选择异常和处理\",{\"0\":{\"348\":1}}],[\"索引统计信息也不会固定不变\",{\"1\":{\"347\":1}}],[\"索引内部就判断了age是否等于10\",{\"1\":{\"340\":1}}],[\"索引下推会减少回表次数\",{\"1\":{\"518\":1}}],[\"索引下推\",{\"0\":{\"340\":1,\"518\":1}}],[\"索引项是按照索引定义里面出现的字段顺序排序的\",{\"1\":{\"339\":1}}],[\"索引字段的维护总是有代价的\",{\"1\":{\"338\":1}}],[\"索引k已经\",{\"1\":{\"338\":1}}],[\"索引的2~4\",{\"1\":{\"574\":1}}],[\"索引的名称\",{\"1\":{\"553\":1}}],[\"索引的图示\",{\"1\":{\"501\":1}}],[\"索引的最佳实践\",{\"0\":{\"360\":1}}],[\"索引的创建时机\",{\"0\":{\"357\":1}}],[\"索引的示意图\",{\"1\":{\"356\":1}}],[\"索引的长度变成了4个字节\",{\"1\":{\"352\":1}}],[\"索引的区分度就越好\",{\"1\":{\"347\":1}}],[\"索引的选择性是指索引列中不同值的数目与表中记录数的比\",{\"1\":{\"359\":1}}],[\"索引的选择\",{\"0\":{\"346\":1}}],[\"索引的执行流程\",{\"0\":{\"336\":1}}],[\"索引的出现是为了提高查询效率\",{\"1\":{\"331\":1}}],[\"索引类型分为主键索引和非主键索引\",{\"1\":{\"335\":1}}],[\"索引类似目录\",{\"1\":{\"300\":1}}],[\"索引是帮助mysql高效获取数据的排好序的数据结构\",{\"1\":{\"501\":1}}],[\"索引是如此的重要\",{\"1\":{\"381\":1}}],[\"索引是否被使用\",{\"1\":{\"377\":1}}],[\"索引是创建在book表还是创建在class表呢\",{\"1\":{\"362\":1}}],[\"索引是在存储引擎层的实现的\",{\"1\":{\"334\":1}}],[\"索引是排好序的快速查找数据结构\",{\"1\":{\"331\":1}}],[\"索引不止在内存中\",{\"1\":{\"334\":1}}],[\"索引常见模型\",{\"0\":{\"331\":1}}],[\"索引命名必须小写\",{\"1\":{\"305\":1}}],[\"索引操作\",{\"0\":{\"305\":1}}],[\"索引\",{\"0\":{\"303\":1},\"1\":{\"1252\":1,\"1254\":1}}],[\"高鹏\",{\"1\":{\"1966\":1}}],[\"高位运算\",{\"1\":{\"1548\":1}}],[\"高位运算和取模运算\",{\"1\":{\"1546\":1}}],[\"高位参与运算\",{\"1\":{\"1548\":1}}],[\"高可靠的\",{\"1\":{\"1419\":1}}],[\"高可用\",{\"1\":{\"1327\":1}}],[\"高可用基石\",{\"1\":{\"607\":1}}],[\"高性能队列disruptor\",{\"0\":{\"1519\":1}}],[\"高性能\",{\"1\":{\"1327\":1,\"1974\":1}}],[\"高性能全文检索\",{\"1\":{\"301\":1}}],[\"高吞吐\",{\"1\":{\"1327\":1}}],[\"高内聚低耦合\",{\"1\":{\"1308\":1}}],[\"高内聚\",{\"1\":{\"1308\":1}}],[\"高于\",{\"1\":{\"1056\":1}}],[\"高于水位线不可见\",{\"1\":{\"542\":1}}],[\"高级实现\",{\"1\":{\"1049\":1}}],[\"高复杂度\",{\"1\":{\"1036\":1}}],[\"高\",{\"1\":{\"595\":1,\"1423\":1,\"1554\":1,\"1576\":4}}],[\"高速缓存和消息队列代理\",{\"1\":{\"568\":1,\"1975\":1}}],[\"高效率\",{\"1\":{\"565\":1}}],[\"高并发等等问题\",{\"1\":{\"1304\":1}}],[\"高并发资源竞争\",{\"1\":{\"388\":1}}],[\"高并发下如何保证接口的幂等性\",{\"1\":{\"1415\":1}}],[\"高并发下\",{\"0\":{\"86\":1,\"1415\":1}}],[\"基础之后\",{\"1\":{\"1970\":1}}],[\"基础教程\",{\"1\":{\"1969\":1}}],[\"基础\",{\"0\":{\"1969\":1},\"1\":{\"1969\":2}}],[\"基础故障处理工具\",{\"0\":{\"1771\":1}}],[\"基础conversionservice实现\",{\"1\":{\"1092\":1}}],[\"基础类型\",{\"1\":{\"959\":1}}],[\"基础类型注入\",{\"0\":{\"959\":1}}],[\"基础api模块\",{\"1\":{\"903\":1}}],[\"基础部分\",{\"0\":{\"738\":1}}],[\"基础支撑层\",{\"1\":{\"645\":1}}],[\"基础知识\",{\"0\":{\"567\":1},\"1\":{\"963\":1}}],[\"基本没有什么理论的堆砌\",{\"1\":{\"1974\":1}}],[\"基本程序结构\",{\"1\":{\"1969\":1}}],[\"基本概念\",{\"0\":{\"1577\":1}}],[\"基本类型\",{\"1\":{\"1480\":1}}],[\"基本是一样的\",{\"1\":{\"1328\":1}}],[\"基本实现类\",{\"1\":{\"1123\":1}}],[\"基本用法\",{\"1\":{\"1053\":1}}],[\"基本思路\",{\"1\":{\"444\":1}}],[\"基本介绍\",{\"0\":{\"428\":1}}],[\"基本上就不是分区表本身的问题\",{\"1\":{\"426\":1}}],[\"基本流程如图所示\",{\"1\":{\"404\":1}}],[\"基本内联混编\",{\"0\":{\"295\":1}}],[\"基数统计\",{\"0\":{\"577\":1}}],[\"基数\",{\"1\":{\"347\":1,\"1480\":1}}],[\"基于zab算法\",{\"1\":{\"1991\":1}}],[\"基于collector实现汇聚操作的库\",{\"1\":{\"1615\":1}}],[\"基于configuration\",{\"1\":{\"1138\":1}}],[\"基于containslocalbean方法实现\",{\"1\":{\"942\":1}}],[\"基于这种情况\",{\"1\":{\"1664\":1}}],[\"基于这两个阶段\",{\"1\":{\"1561\":1}}],[\"基于这个协议\",{\"1\":{\"443\":1}}],[\"基于这个查询\",{\"1\":{\"396\":1}}],[\"基于轻量级线程实现thread\",{\"1\":{\"1533\":1}}],[\"基于disruptor开发的系统但线程能支撑每秒600万订单\",{\"1\":{\"1519\":1}}],[\"基于链表结构实现的一个双端阻塞队列\",{\"1\":{\"1501\":1}}],[\"基于链表结构实现的一个无界阻塞队列\",{\"1\":{\"1501\":1}}],[\"基于链表结构实现的一个有界阻塞队列\",{\"1\":{\"1501\":1}}],[\"基于优先级队列\",{\"1\":{\"1501\":1}}],[\"基于数组结构实现的一个有界阻塞队列\",{\"1\":{\"1501\":1}}],[\"基于monitor机制实现\",{\"1\":{\"1483\":1}}],[\"基于mq\",{\"1\":{\"1310\":1}}],[\"基于等待唤醒机制\",{\"1\":{\"1477\":1}}],[\"基于协议的窥探往往会更快\",{\"1\":{\"1474\":1}}],[\"基于tcp协议\",{\"1\":{\"1424\":1}}],[\"基于日志\",{\"1\":{\"1310\":1}}],[\"基于版本号version实现\",{\"1\":{\"1248\":1}}],[\"基于reactor线程模型\",{\"1\":{\"1228\":1}}],[\"基于resourcebundle\",{\"1\":{\"1054\":1}}],[\"基于perpetuacache的hashmap本地缓存\",{\"1\":{\"1218\":1}}],[\"基于properties资源装载外部化配置\",{\"0\":{\"1031\":1}}],[\"基于properties资源装载spring\",{\"0\":{\"1022\":1}}],[\"基于properties文件\",{\"1\":{\"920\":1}}],[\"基于org\",{\"1\":{\"1139\":1}}],[\"基于编程条件注解\",{\"1\":{\"1139\":1}}],[\"基于编码的同步和异步事件广播示例\",{\"1\":{\"1123\":1}}],[\"基于配置条件注解\",{\"1\":{\"1139\":1}}],[\"基于spring注解\",{\"1\":{\"1113\":1}}],[\"基于spring接口\",{\"1\":{\"1113\":1}}],[\"基于接口的spring事件监听器\",{\"0\":{\"1112\":1}}],[\"基于yml资源装载外部化配置\",{\"0\":{\"1032\":1}}],[\"基于extensible\",{\"0\":{\"1030\":1}}],[\"基于api扩展的示例\",{\"1\":{\"1156\":1}}],[\"基于api扩展spring配置属性源\",{\"0\":{\"1156\":1}}],[\"基于api的setter方法注入依赖\",{\"1\":{\"953\":1}}],[\"基于api的依赖注入的演示\",{\"1\":{\"953\":1}}],[\"基于autowiredannotationbeanpostprocessor实现自定义依赖注入相对比较容易\",{\"1\":{\"967\":1}}],[\"基于autowiredannotationbeanpostprocessor实现\",{\"1\":{\"967\":1}}],[\"基于注解扩展spring配置属性源\",{\"0\":{\"1155\":1}}],[\"基于注解方式的示例\",{\"1\":{\"1123\":1}}],[\"基于注解\",{\"1\":{\"961\":1,\"1123\":1}}],[\"基于注解的spring事件监听器\",{\"0\":{\"1113\":1}}],[\"基于注解的setter方法注入依赖\",{\"1\":{\"953\":1}}],[\"基于注解的字段注入依赖\",{\"1\":{\"955\":1}}],[\"基于注解的依赖注入的演示示例\",{\"1\":{\"953\":1}}],[\"基于xml资源装载spring\",{\"0\":{\"1021\":1,\"1028\":1}}],[\"基于xml资源beandefinitionreader\",{\"1\":{\"997\":1,\"1000\":1,\"1001\":1,\"1005\":1,\"1006\":1,\"1011\":1}}],[\"基于xml资源的依赖\",{\"1\":{\"953\":1,\"954\":1}}],[\"基于xml文件\",{\"1\":{\"920\":2}}],[\"基于\",{\"1\":{\"931\":1,\"957\":1,\"1138\":2,\"1989\":1}}],[\"基于java的所有socket通信都使用了同步阻塞模式\",{\"1\":{\"1572\":1}}],[\"基于javabeans\",{\"1\":{\"1095\":1}}],[\"基于javabeans接口的类型转换\",{\"0\":{\"1082\":1}}],[\"基于javabeans接口的类型转换实现\",{\"1\":{\"1080\":1,\"1081\":1}}],[\"基于java\",{\"1\":{\"920\":2,\"995\":1,\"1080\":1}}],[\"基于java注解配置spring\",{\"0\":{\"1029\":1}}],[\"基于java注解的spring\",{\"0\":{\"1023\":1}}],[\"基于java注解\",{\"1\":{\"920\":3}}],[\"基于java语言开发\",{\"1\":{\"301\":1}}],[\"基于索引统计数据的成本\",{\"0\":{\"552\":1}}],[\"基于块的嵌套循环查询\",{\"0\":{\"525\":1}}],[\"基于块的嵌套循环连接\",{\"1\":{\"523\":1}}],[\"基于慢sql查询做优化\",{\"1\":{\"521\":1}}],[\"基于位点的协议\",{\"1\":{\"468\":1}}],[\"基于位点的主备切换\",{\"0\":{\"467\":1}}],[\"基于主从复制模式\",{\"1\":{\"623\":1}}],[\"基于主备协议建立连接\",{\"1\":{\"468\":1}}],[\"基于主键索引和普通索引的查询略有差别\",{\"1\":{\"335\":1}}],[\"基于行的策略\",{\"1\":{\"462\":1}}],[\"基于上面覆盖索引的说明\",{\"1\":{\"338\":1}}],[\"基于非主键索引的查询需要多扫描一棵索引树\",{\"1\":{\"335\":1}}],[\"可视化故障处理工具\",{\"0\":{\"1772\":1}}],[\"可终止的预清理\",{\"0\":{\"1735\":1}}],[\"可包含多个context\",{\"1\":{\"1683\":1}}],[\"可包含一个engine\",{\"1\":{\"1683\":1}}],[\"可关联的一个无状态的一个函数\",{\"1\":{\"1608\":1}}],[\"可关联某一类型bean\",{\"1\":{\"1181\":1}}],[\"可维护性也比较差\",{\"1\":{\"1607\":1}}],[\"可维护性高\",{\"1\":{\"1292\":1}}],[\"可变的元提供了延迟绑定并且快速失败的spliterator\",{\"1\":{\"1620\":1}}],[\"可变的元提供了延迟绑定但是非快速失败的spliterator\",{\"1\":{\"1620\":1}}],[\"可变的元提供了非延迟绑定但是快速失败的spliterator\",{\"1\":{\"1620\":1}}],[\"可变的元提供了一种延迟绑定和快速失败的spliterator\",{\"1\":{\"1620\":1}}],[\"可变的元\",{\"1\":{\"1620\":1}}],[\"可变对象虽然是线程安全的\",{\"1\":{\"1526\":1}}],[\"可变字符序列\",{\"1\":{\"1341\":2}}],[\"可向下执行后续阶段\",{\"1\":{\"1518\":1}}],[\"可中断\",{\"1\":{\"1494\":1}}],[\"可运行状态\",{\"1\":{\"1477\":1}}],[\"可通过future的get方法将任务执行时的异常重新抛出\",{\"1\":{\"1408\":1}}],[\"可通过该列计算查询中使用的索引的长度\",{\"1\":{\"330\":1}}],[\"可写\",{\"1\":{\"1569\":1}}],[\"可写时\",{\"1\":{\"1292\":1}}],[\"可写资源接口\",{\"1\":{\"1040\":1}}],[\"可写资源\",{\"1\":{\"1038\":1}}],[\"可配置接口\",{\"1\":{\"1159\":1}}],[\"可观者对象\",{\"1\":{\"1108\":1}}],[\"可重入锁的实现\",{\"1\":{\"1494\":1}}],[\"可重入\",{\"1\":{\"1490\":1,\"1498\":1}}],[\"可重入代码\",{\"1\":{\"1392\":1}}],[\"可重复度\",{\"1\":{\"1238\":1}}],[\"可重复读是指\",{\"1\":{\"433\":1}}],[\"可重复读是它默认的隔离级别\",{\"1\":{\"396\":1}}],[\"可重复读\",{\"1\":{\"433\":4,\"532\":1}}],[\"可重载properties\",{\"1\":{\"1054\":1}}],[\"可修改实现\",{\"1\":{\"1019\":1}}],[\"可选依赖\",{\"1\":{\"1093\":1}}],[\"可选项\",{\"1\":{\"1053\":2}}],[\"可选\",{\"1\":{\"955\":1,\"956\":1}}],[\"可在name属性使用半角逗号\",{\"1\":{\"928\":1}}],[\"可考虑使用别名\",{\"1\":{\"928\":1}}],[\"可读性\",{\"1\":{\"911\":1}}],[\"可是一旦大量的请求数据\",{\"1\":{\"626\":1}}],[\"可是程序中可以正常输出\",{\"1\":{\"583\":1}}],[\"可用作数据库\",{\"1\":{\"568\":1,\"1975\":1}}],[\"可用性\",{\"1\":{\"1311\":1}}],[\"可用性判断\",{\"0\":{\"475\":1}}],[\"可用性就越高\",{\"1\":{\"459\":1}}],[\"可用性优先策略\",{\"0\":{\"459\":1}}],[\"可基于内存亦可持久化的日志型\",{\"1\":{\"564\":1}}],[\"可就不能使用index\",{\"1\":{\"553\":1}}],[\"可串行化\",{\"1\":{\"532\":1}}],[\"可见性展开的\",{\"1\":{\"1473\":1}}],[\"可见性\",{\"0\":{\"1471\":1},\"1\":{\"1373\":1,\"1431\":1,\"1470\":1,\"1474\":1}}],[\"可见性和有序性是通过哪些操作实现的\",{\"0\":{\"100\":1,\"1431\":1}}],[\"可见的情况\",{\"1\":{\"542\":1}}],[\"可见的行才能够用于计算\",{\"1\":{\"396\":1}}],[\"可见\",{\"1\":{\"462\":1,\"472\":1,\"542\":1}}],[\"可能是t类型\",{\"1\":{\"1614\":1}}],[\"可能是等i\",{\"1\":{\"388\":1}}],[\"可能不返回值\",{\"1\":{\"1611\":1}}],[\"可能初学者并不能直观的认识到\",{\"1\":{\"1595\":1}}],[\"可能延迟还更大\",{\"1\":{\"1565\":1}}],[\"可能无法应对所有的情况\",{\"1\":{\"1509\":1}}],[\"可能达到整个堆内存容量的20\",{\"1\":{\"1449\":1}}],[\"可能bean会存在初始化不完全的情况\",{\"1\":{\"1009\":1}}],[\"可能返回的是一个代理对象\",{\"1\":{\"1006\":1}}],[\"可能行为会有一些问题\",{\"1\":{\"984\":1}}],[\"可能需要修改mysql的max\",{\"1\":{\"1277\":1}}],[\"可能需要考虑重构\",{\"1\":{\"912\":1}}],[\"可能需要耗费好几秒的时间\",{\"1\":{\"458\":1}}],[\"可能存在的问题\",{\"0\":{\"887\":1}}],[\"可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描\",{\"1\":{\"557\":1}}],[\"可能更关心数据并发访问的能力\",{\"1\":{\"532\":1}}],[\"可能\",{\"1\":{\"532\":6}}],[\"可能影响到计算的准确性和完整性\",{\"1\":{\"530\":1}}],[\"可能要遍历多个索引树\",{\"1\":{\"522\":1}}],[\"可能由于发现数据问题的时间晚了一点\",{\"1\":{\"484\":1}}],[\"可能第一次轮询还不能发现\",{\"1\":{\"478\":1}}],[\"可能出现过度等待的问题\",{\"1\":{\"472\":1}}],[\"可能使用的时候会比较克制\",{\"1\":{\"457\":1}}],[\"可能导致主备延迟出现的原因\",{\"1\":{\"457\":1}}],[\"可能导致内存占用太大\",{\"1\":{\"318\":1}}],[\"可能就会反复查询这个数据\",{\"1\":{\"386\":1}}],[\"可能就是昨天晚上的一个备份\",{\"1\":{\"327\":1}}],[\"可能还会产生大量的上下文切换以及系统调用\",{\"1\":{\"381\":1}}],[\"可能会引起冲突\",{\"1\":{\"1620\":1}}],[\"可能会造成数据不一致的问题\",{\"1\":{\"1477\":1}}],[\"可能会造成连接资源浪费的情况\",{\"1\":{\"1420\":1}}],[\"可能会多次重复\",{\"1\":{\"1286\":1}}],[\"可能会多次回调\",{\"1\":{\"1248\":1}}],[\"可能会多次扫描被驱动表\",{\"1\":{\"406\":1}}],[\"可能会有一些意想不到的结果\",{\"1\":{\"985\":1}}],[\"可能会抛出nouniquebeandefinitionexception\",{\"1\":{\"952\":1}}],[\"可能会丢失一秒的数据\",{\"1\":{\"593\":1}}],[\"可能会丢失这一秒的数据\",{\"1\":{\"592\":1}}],[\"可能会延迟几秒才会进行计算\",{\"1\":{\"559\":1}}],[\"可能会影响客户端本地机器的性能\",{\"1\":{\"482\":1}}],[\"可能会出现数据不一致的问题\",{\"1\":{\"1474\":1}}],[\"可能会出现\",{\"1\":{\"480\":1}}],[\"可能会不止重复执行一个事务\",{\"1\":{\"467\":1}}],[\"可能会导致数据的不一致\",{\"1\":{\"1544\":1}}],[\"可能会导致buffer\",{\"1\":{\"406\":1}}],[\"可能会导致查询语句读数据的次数变多\",{\"1\":{\"350\":1}}],[\"可能会破坏索引值的有序性\",{\"1\":{\"366\":1}}],[\"可能在内存中完成\",{\"1\":{\"354\":1}}],[\"可能你在一些建表规范里面见到过类似的描述\",{\"1\":{\"335\":1}}],[\"可以学习微服务和分布式的内容\",{\"1\":{\"1988\":1}}],[\"可以再学习vue和react等前端技术\",{\"1\":{\"1977\":1}}],[\"可以再次调用这个方法来重置sink来进行其他的计算\",{\"1\":{\"1623\":1}}],[\"可以辅助学习\",{\"1\":{\"1969\":1}}],[\"可以包括多个service\",{\"1\":{\"1683\":1}}],[\"可以很方便的将spring\",{\"1\":{\"1659\":1}}],[\"可以很快进入输入命令的状态\",{\"1\":{\"482\":1}}],[\"可以一次性获取多个资源\",{\"1\":{\"1637\":1}}],[\"可以销毁某个bean等等功能\",{\"1\":{\"1636\":1}}],[\"可以合并beandefinition\",{\"1\":{\"1636\":1}}],[\"可以添加beanpostprocessor\",{\"1\":{\"1636\":1}}],[\"可以获取运行时环境\",{\"1\":{\"1637\":1}}],[\"可以获取所有beandefinition的beannames\",{\"1\":{\"1636\":1}}],[\"可以获取最近一个fork操作的耗时\",{\"1\":{\"588\":1}}],[\"可以根据类型或者名称进行查找\",{\"1\":{\"1647\":1}}],[\"可以根据\",{\"1\":{\"1641\":1}}],[\"可以根据某个类型获取\",{\"1\":{\"1636\":1}}],[\"可以根据某个类型获取对应的beannames\",{\"1\":{\"1636\":1}}],[\"可以根据某个bean的名字\",{\"1\":{\"1636\":1}}],[\"可以根据应用程序的需要进行动态分配和释放\",{\"1\":{\"1457\":1}}],[\"可以注册\",{\"1\":{\"1636\":1}}],[\"可以是io通道\",{\"1\":{\"1620\":1}}],[\"可以是集合\",{\"1\":{\"1620\":1}}],[\"可以是一个数组\",{\"1\":{\"1619\":1}}],[\"可以帮助客户端来判断spliterator里面是不是没有元素\",{\"1\":{\"1620\":1}}],[\"可以为我们了解stream打下良好的基础\",{\"1\":{\"1618\":1}}],[\"可以增加前缀和后缀\",{\"1\":{\"1618\":1}}],[\"可以增加负载因子loadfactor的值\",{\"1\":{\"1546\":1}}],[\"可以被省略掉\",{\"1\":{\"1617\":1}}],[\"可以被多个线程共享\",{\"1\":{\"1342\":1}}],[\"可以想象\",{\"1\":{\"1599\":1}}],[\"可以多省去一次\",{\"1\":{\"1583\":1}}],[\"可以多接几个从库\",{\"1\":{\"457\":1}}],[\"可以说\",{\"1\":{\"1593\":1}}],[\"可以说为高并发服务器的开发提供了很好的支撑\",{\"1\":{\"1574\":1}}],[\"可以说是效率做到了极致\",{\"1\":{\"1473\":1}}],[\"可以构成链表\",{\"1\":{\"1553\":1}}],[\"可以构建和遍历解析树\",{\"1\":{\"513\":1}}],[\"可以降低负载因子loadfactor的值\",{\"1\":{\"1546\":1}}],[\"可以采用开放地址法和链地址法等来解决问题\",{\"1\":{\"1546\":1}}],[\"可以采用半同步的方式\",{\"1\":{\"1269\":1}}],[\"可以按照插入的顺序使用iterator遍历\",{\"1\":{\"1544\":1}}],[\"可以按照如下流程\",{\"1\":{\"422\":1}}],[\"可以按照如下思路实现\",{\"1\":{\"422\":1}}],[\"可以动态保存任意多个对象\",{\"1\":{\"1538\":1}}],[\"可以归纳为多线程if模式\",{\"1\":{\"1531\":1}}],[\"可以尝试使用copy\",{\"1\":{\"1527\":1}}],[\"可以尝试将join\",{\"1\":{\"403\":1}}],[\"可以轻松实现后续处理的有序性\",{\"1\":{\"1517\":1}}],[\"可以更好地利用资源\",{\"1\":{\"1510\":1}}],[\"可以更容易对数据库进行拆分\",{\"1\":{\"394\":1}}],[\"可以优先考虑synchronousqueue\",{\"1\":{\"1509\":1}}],[\"可以优化为\",{\"1\":{\"522\":1}}],[\"可以继续入队\",{\"1\":{\"1503\":1}}],[\"可以继续响应其他命令\",{\"1\":{\"588\":1}}],[\"可以近似认为是无限容量\",{\"1\":{\"1501\":1}}],[\"可以重置计数器\",{\"1\":{\"1496\":1}}],[\"可以重复调用refresh方法的applicationcontext的执行逻辑是\",{\"1\":{\"1651\":1}}],[\"可以重复\",{\"1\":{\"1355\":1}}],[\"可以设置范围是\",{\"1\":{\"1607\":1}}],[\"可以设置阻塞时间\",{\"1\":{\"1501\":2}}],[\"可以设置为公平锁\",{\"1\":{\"1494\":1}}],[\"可以设置超时时间\",{\"1\":{\"1494\":1}}],[\"可以设置其过期时间为永不过期\",{\"1\":{\"1283\":1}}],[\"可以不用学的特别细致\",{\"1\":{\"1976\":1}}],[\"可以不用做这块的项目\",{\"1\":{\"1969\":1}}],[\"可以不存储在内存\",{\"1\":{\"1488\":1}}],[\"可以不需要等待线程创建就能立即执行\",{\"1\":{\"1407\":1}}],[\"可以节省毫无意义的请求锁时间\",{\"1\":{\"1487\":1}}],[\"可以手动判断线程的中断标识位\",{\"1\":{\"1477\":1}}],[\"可以分为三个小的阶段\",{\"1\":{\"1433\":1}}],[\"可以分解成下面这些查询来代替\",{\"1\":{\"394\":1}}],[\"可以进行广播发送的\",{\"1\":{\"1419\":1}}],[\"可以使得序列类型的数据结构的遍历行为与被遍历的对象分离\",{\"1\":{\"1353\":1}}],[\"可以使用flags来优化sink\",{\"1\":{\"1623\":1}}],[\"可以使用fork\",{\"1\":{\"1412\":1}}],[\"可以使用lambda表达式来替代匿名内部类完成相同的功能\",{\"1\":{\"1592\":1}}],[\"可以使用浏览器工作更为高效\",{\"1\":{\"1424\":1}}],[\"可以使用三大工具\",{\"1\":{\"1404\":1}}],[\"可以使用applicationeventpublisher\",{\"1\":{\"1118\":1}}],[\"可以使用命令\",{\"1\":{\"454\":1}}],[\"可以使用这个命令\",{\"1\":{\"437\":1}}],[\"可以使用如下示例进行观察\",{\"1\":{\"1075\":1}}],[\"可以使用如下方法创建一个列z\",{\"1\":{\"417\":1}}],[\"可以使用如下sql语句\",{\"1\":{\"368\":1}}],[\"可以使用各种引擎类型\",{\"1\":{\"409\":1}}],[\"可以使用一个redis服务来保存这个表的总行数\",{\"1\":{\"397\":1}}],[\"可以使用synchroized来解决临界区资源共享的问题\",{\"1\":{\"1482\":1}}],[\"可以使用select\",{\"1\":{\"412\":1,\"567\":1}}],[\"可以使用sql查看支持的数据存储引擎\",{\"1\":{\"1260\":1}}],[\"可以使用sql\",{\"1\":{\"319\":1}}],[\"可以使用show\",{\"1\":{\"318\":1,\"433\":1}}],[\"可以使用\",{\"1\":{\"306\":1}}],[\"可以防止通过反射机制等有意或者恶意修改\",{\"1\":{\"1342\":1}}],[\"可以防止脏读\",{\"1\":{\"1262\":1}}],[\"可以由多个消费者来处理\",{\"1\":{\"1326\":1}}],[\"可以给每个微服务组件专门的团队\",{\"1\":{\"1304\":1}}],[\"可以独立部署\",{\"1\":{\"1304\":1}}],[\"可以incr和expire\",{\"1\":{\"1293\":1}}],[\"可以对位进行设置或获取\",{\"1\":{\"1280\":1}}],[\"可以对每一个表进行一次单表查询\",{\"1\":{\"394\":1}}],[\"可以存储字符串\",{\"1\":{\"1280\":1}}],[\"可以发往任意节点\",{\"1\":{\"1256\":1}}],[\"可以发现当变量被volitle关键字修饰后\",{\"1\":{\"1473\":1}}],[\"可以发现依赖查找和依赖注入的environment都是同一个\",{\"1\":{\"1149\":1}}],[\"可以发现\",{\"1\":{\"350\":1,\"355\":1,\"368\":1,\"407\":1,\"965\":1,\"1548\":1,\"1583\":1,\"1657\":1}}],[\"可以控制数据的总量\",{\"1\":{\"1252\":1}}],[\"可以保存数据\",{\"1\":{\"1236\":1}}],[\"可以保证两个worker不会更新同一行\",{\"1\":{\"461\":1}}],[\"可以直接查找到\",{\"1\":{\"1661\":1}}],[\"可以直接注册\",{\"1\":{\"1636\":1}}],[\"可以直接调用\",{\"1\":{\"1616\":1}}],[\"可以直接将文件缓冲区的数据发送到目标channel\",{\"1\":{\"1231\":1}}],[\"可以直接把binlog中记录的delete语句转为insert\",{\"1\":{\"454\":1}}],[\"可以得出\",{\"1\":{\"1227\":1}}],[\"可以得到足够多的主键id\",{\"1\":{\"404\":1}}],[\"可以简单的回答为\",{\"1\":{\"1177\":1}}],[\"可以基于\",{\"1\":{\"1044\":1}}],[\"可以基于以下实例来分析行锁\",{\"1\":{\"535\":1}}],[\"可以让线程从休眠状态转换到runnable状态\",{\"1\":{\"1524\":1}}],[\"可以让我们在加载xml资源的前后做一些自定义的操作\",{\"1\":{\"1025\":1}}],[\"可以让mysql按照id顺序进行查询\",{\"1\":{\"394\":1}}],[\"可以结合bean实例化前阶段一起对照查看\",{\"1\":{\"1002\":1}}],[\"可以的\",{\"1\":{\"981\":1,\"993\":1}}],[\"可以参考\",{\"1\":{\"952\":1}}],[\"可以观察到bean的销毁的时机就是在应用上下文关闭的时候\",{\"1\":{\"933\":1}}],[\"可以自定义修改\",{\"1\":{\"927\":1}}],[\"可以自己命名的主节点名字\",{\"1\":{\"624\":1}}],[\"可以自己指定id或者通过es自动生成\",{\"1\":{\"304\":1}}],[\"可以从二级缓存中获取数据\",{\"1\":{\"1283\":1}}],[\"可以从构造方法中看出\",{\"1\":{\"966\":1}}],[\"可以从写时复制\",{\"1\":{\"588\":1}}],[\"可以从infomation\",{\"1\":{\"497\":1}}],[\"可以经过规则定义将其变为队列\",{\"1\":{\"571\":1}}],[\"可以改进内部编码\",{\"1\":{\"569\":1}}],[\"可以这么做\",{\"1\":{\"559\":1}}],[\"可以选择的连接顺序有两种\",{\"1\":{\"555\":1}}],[\"可以先忽略掉\",{\"1\":{\"553\":1}}],[\"可以看极客时间的专栏\",{\"1\":{\"1974\":1}}],[\"可以看\",{\"1\":{\"1974\":1,\"1992\":1}}],[\"可以看出\",{\"1\":{\"1226\":1}}],[\"可以看出来这个n\",{\"1\":{\"558\":1}}],[\"可以看见全表扫描的成本\",{\"1\":{\"544\":1}}],[\"可以看到后续的异常都被压制了\",{\"1\":{\"1619\":1}}],[\"可以看到虽然抛出了异常\",{\"1\":{\"1619\":1}}],[\"可以看到supplier\",{\"1\":{\"1617\":1}}],[\"可以看到我们实际上使用的分割迭代器是iteratorspliterator\",{\"1\":{\"1621\":1}}],[\"可以看到我们在调用filter方法之后\",{\"1\":{\"1610\":1}}],[\"可以看到我们其实只定义了一个函数\",{\"1\":{\"1598\":1}}],[\"可以看到其接收comparator作为参数\",{\"1\":{\"1603\":1}}],[\"可以看到list\",{\"1\":{\"1593\":1}}],[\"可以看到每当有新的连接接入\",{\"1\":{\"1573\":1}}],[\"可以看到put方法本身也是调用putval方法\",{\"1\":{\"1554\":1}}],[\"可以看到postprocessbeforeinstantiation方法被调用之后返回了这个对象\",{\"1\":{\"1000\":1}}],[\"可以看到在spring的应用上下文中\",{\"1\":{\"1168\":1}}],[\"可以看到在postprocessmergedbeandefinition就完成了bean的元信息的组装\",{\"1\":{\"964\":1}}],[\"可以看到占位符已经被成功的替换\",{\"1\":{\"1146\":1}}],[\"可以看到使用这种方式方便了很多\",{\"1\":{\"1065\":1}}],[\"可以看到userholder的description属性成功的变成了v3\",{\"1\":{\"1006\":1}}],[\"可以看到这两个成员变量可以认为是互斥的\",{\"1\":{\"1621\":1}}],[\"可以看到这是一个静态方法\",{\"1\":{\"1607\":1}}],[\"可以看到这是一个函数式接口\",{\"1\":{\"1603\":1}}],[\"可以看到这个方法返回的是包含最小值\",{\"1\":{\"1607\":1}}],[\"可以看到这个接口从jdk8开始就加上了\",{\"1\":{\"1594\":1}}],[\"可以看到这个接口上有一个\",{\"1\":{\"1594\":1}}],[\"可以看到这个语句的执行不再需要临时表\",{\"1\":{\"417\":1}}],[\"可以看到这里除了保存beanname和beandefinition\",{\"1\":{\"975\":1}}],[\"可以看到如果autowiredannotationbeanpostprocessor这个bean存在的话\",{\"1\":{\"967\":1}}],[\"可以看到实际上还可以进行复合注解\",{\"1\":{\"965\":1}}],[\"可以看到实例x的executed\",{\"1\":{\"468\":1}}],[\"可以看到autowiredannotationtypes实际上是一个有序的set集合\",{\"1\":{\"965\":1}}],[\"可以看到就是在这里排除掉了static的字段\",{\"1\":{\"964\":1}}],[\"可以看到还有一部分日志\",{\"1\":{\"472\":1}}],[\"可以看到trx1\",{\"1\":{\"464\":1}}],[\"可以看到λ越小越好\",{\"1\":{\"403\":1}}],[\"可以看到extra字段里面多了\",{\"1\":{\"356\":1}}],[\"可以看到\",{\"1\":{\"319\":1,\"327\":1,\"337\":1,\"339\":2,\"345\":1,\"346\":1,\"347\":3,\"356\":2,\"368\":1,\"396\":1,\"401\":2,\"403\":2,\"410\":1,\"414\":3,\"417\":2,\"424\":1,\"425\":2,\"446\":1,\"447\":1,\"450\":1,\"453\":1,\"454\":6,\"457\":1,\"458\":1,\"459\":1,\"460\":1,\"462\":1,\"464\":1,\"465\":1,\"468\":1,\"472\":1,\"480\":1,\"481\":1,\"490\":1,\"491\":2,\"492\":1,\"494\":1,\"497\":1,\"558\":1,\"921\":1,\"1157\":1,\"1183\":1,\"1591\":1,\"1594\":1,\"1595\":1,\"1597\":1,\"1609\":1,\"1610\":1,\"1611\":1,\"1615\":1}}],[\"可以做到在读操作时不用阻塞写操作\",{\"1\":{\"541\":1}}],[\"可以总结一下\",{\"1\":{\"525\":1}}],[\"可以适当增大max\",{\"1\":{\"520\":1}}],[\"可以适当将max\",{\"1\":{\"520\":1}}],[\"可以有条件的删除\",{\"1\":{\"1271\":1}}],[\"可以有效的放置sql注入\",{\"1\":{\"1210\":1}}],[\"可以有效的减少索引下推优化后\",{\"1\":{\"518\":1}}],[\"可以有一个客户数据的索引\",{\"1\":{\"303\":1}}],[\"可以放更多的索引\",{\"1\":{\"503\":1}}],[\"可以忽略不计\",{\"1\":{\"499\":1}}],[\"可以开始\",{\"1\":{\"481\":1}}],[\"可以执行\",{\"1\":{\"479\":1}}],[\"可以避免过期读\",{\"1\":{\"472\":1}}],[\"可以避免每次查询需要搜索两棵树\",{\"1\":{\"335\":1}}],[\"可以如下处理\",{\"1\":{\"457\":1}}],[\"可以提升性能\",{\"1\":{\"450\":1}}],[\"可以减少服务之间的影响\",{\"1\":{\"1326\":1}}],[\"可以减少磁盘io的次数\",{\"1\":{\"1265\":1}}],[\"可以减少线程数据了\",{\"1\":{\"583\":1}}],[\"可以减少trx\",{\"1\":{\"497\":1}}],[\"可以减少锁等待的个数\",{\"1\":{\"444\":1}}],[\"可以减少冗余记录的查询\",{\"1\":{\"394\":1}}],[\"可以考虑这种策略\",{\"1\":{\"1520\":1}}],[\"可以考虑思路2\",{\"1\":{\"492\":1}}],[\"可以考虑调整这两个参数值\",{\"1\":{\"465\":1}}],[\"可以考虑放在多条记录上\",{\"1\":{\"444\":1}}],[\"可以考虑通过将一行改成逻辑上的多行来减少锁冲突\",{\"1\":{\"444\":1}}],[\"可以查询到当前执行中的事务\",{\"1\":{\"441\":1}}],[\"可以查看以下信息\",{\"1\":{\"329\":1}}],[\"可以创建普通列和索引\",{\"1\":{\"417\":1}}],[\"可以完全存入\",{\"1\":{\"407\":1}}],[\"可以认为mvcc是行锁的一个变种\",{\"1\":{\"541\":1}}],[\"可以认为它们是对fsync的统计\",{\"1\":{\"479\":1}}],[\"可以认为它就是一个数组\",{\"1\":{\"420\":1}}],[\"可以认为就只扫描了3行\",{\"1\":{\"422\":1}}],[\"可以认为是每次中间结果容器的类型\",{\"1\":{\"1615\":1}}],[\"可以认为是http\",{\"1\":{\"1424\":1}}],[\"可以认为是生命周期中最重要的阶段\",{\"1\":{\"381\":1}}],[\"可以认为是分裂过程的逆过程\",{\"1\":{\"335\":1}}],[\"可以认为每次查询的平均扫描行数接近1\",{\"1\":{\"352\":1}}],[\"可以\",{\"1\":{\"352\":1,\"1361\":1,\"1661\":1}}],[\"可以定义字符串的一部分作为索引\",{\"1\":{\"350\":1}}],[\"可以用如下流程图来描述\",{\"1\":{\"1580\":1,\"1582\":1,\"1583\":1,\"1584\":1}}],[\"可以用collections的synchronizedmap方法使hashmap具有线程安全的能力\",{\"1\":{\"1544\":1}}],[\"可以用current\",{\"1\":{\"529\":1}}],[\"可以用来实现内存映射\",{\"1\":{\"1587\":1}}],[\"可以用来实现一个依赖状态的同步器\",{\"1\":{\"1490\":1}}],[\"可以用来重新统计索引信息\",{\"1\":{\"347\":1}}],[\"可以用java\",{\"1\":{\"1453\":2}}],[\"可以用在结果容器不要求有序的场景下\",{\"1\":{\"1617\":1}}],[\"可以用在用户画像等场景\",{\"1\":{\"1254\":1}}],[\"可以用在以下这些方面\",{\"1\":{\"624\":1}}],[\"可以用flashback工具通过闪回把数据恢复回来\",{\"1\":{\"484\":1}}],[\"可以用readonly状态\",{\"1\":{\"453\":1}}],[\"可以用unlock\",{\"1\":{\"440\":1}}],[\"可以用于生产者\",{\"1\":{\"1519\":1}}],[\"可以用于sql的调优的测量\",{\"1\":{\"431\":1}}],[\"可以用于提高读写效率的数据结构有很多中\",{\"1\":{\"331\":1}}],[\"可以通过这个集合查找到正在创建的bean\",{\"1\":{\"1649\":1}}],[\"可以通过非常简单的方式\",{\"1\":{\"1607\":1}}],[\"可以通过lambda表达式来创建\",{\"1\":{\"1594\":1}}],[\"可以通过它读取和写入数据\",{\"1\":{\"1574\":1}}],[\"可以通过修改宏定义甚至重新编译内核的方式提升这一限制\",{\"1\":{\"1569\":1}}],[\"可以通过遍历fdset\",{\"1\":{\"1569\":1}}],[\"可以通过jvm参数xx\",{\"1\":{\"1485\":1}}],[\"可以通过unsafe来cas操作它的值\",{\"1\":{\"1480\":1}}],[\"可以通过thread类直接调用\",{\"1\":{\"1386\":1}}],[\"可以通过\",{\"1\":{\"1375\":1}}],[\"可以通过参数配置\",{\"1\":{\"1328\":1}}],[\"可以通过参数innodb\",{\"1\":{\"343\":1,\"444\":1}}],[\"可以通过相关的spring相关的api进行操作\",{\"1\":{\"1160\":1}}],[\"可以通过propertysourcefactory进行扩展\",{\"1\":{\"1155\":1}}],[\"可以通过实现的priorityordered接口\",{\"1\":{\"966\":1}}],[\"可以通过脚本来通知管理员\",{\"1\":{\"624\":1}}],[\"可以通过将这个值设为\",{\"1\":{\"624\":1}}],[\"可以通过下面的sql语句查询数据的行锁的情况\",{\"1\":{\"538\":1}}],[\"可以通过开发管理系统得到支持\",{\"1\":{\"487\":1}}],[\"可以通过设定阈值\",{\"1\":{\"479\":1}}],[\"可以通过设置exposeproxy=true\",{\"1\":{\"1654\":1}}],[\"可以通过设置autowire=\",{\"1\":{\"1650\":1}}],[\"可以通过设置socket使其变为non\",{\"1\":{\"1564\":1}}],[\"可以通过设置参数来控制元数据的大小和增长策略\",{\"1\":{\"1457\":1}}],[\"可以通过设置参数innodb\",{\"1\":{\"347\":1}}],[\"可以通过设置binlog\",{\"1\":{\"451\":1}}],[\"可以通过哪些方法来提升性能呢\",{\"1\":{\"451\":1}}],[\"可以通过如下命令来查看\",{\"1\":{\"354\":1}}],[\"可以通过explain的rows列来查看\",{\"1\":{\"347\":1}}],[\"可以通过id批量获取es\",{\"1\":{\"307\":1}}],[\"可以通过id批量获取不同index和type的数据\",{\"1\":{\"307\":1}}],[\"可以快速定位到id4\",{\"1\":{\"339\":1}}],[\"可以利用converter接口\",{\"1\":{\"1089\":1}}],[\"可以利用beanpostprocess进行清扫工作\",{\"1\":{\"985\":1}}],[\"可以利用覆盖索引\",{\"1\":{\"351\":1}}],[\"可以利用索引的\",{\"1\":{\"339\":1}}],[\"可以利用reindex\",{\"1\":{\"309\":1}}],[\"可以将磁盘数据通过dma拷贝到内核态buffer后\",{\"1\":{\"1576\":1}}],[\"可以将锁消除\",{\"1\":{\"1487\":1}}],[\"可以将hash值存储起来\",{\"1\":{\"1342\":1}}],[\"可以将多次io往返的时间缩减为一次\",{\"1\":{\"1298\":1}}],[\"可以将多个bytebuf合并为一个逻辑上的bytebuf\",{\"1\":{\"1231\":1}}],[\"可以将热点数据的键存储在布隆过滤器中\",{\"1\":{\"1283\":1}}],[\"可以将bean的作用改为prototype\",{\"1\":{\"1236\":1}}],[\"可以将一个hash表作为一个对象进行存储\",{\"1\":{\"573\":1}}],[\"可以将其中的每个字典都理解成一个独立的数据库\",{\"1\":{\"567\":1}}],[\"可以将不可能用时间几乎降为0\",{\"1\":{\"458\":1}}],[\"可以将拼接sql语句的方法写在应用程序中\",{\"1\":{\"422\":1}}],[\"可以将参数query\",{\"1\":{\"319\":1}}],[\"可以将es中的一些基本概念映射到关系型数据库\",{\"1\":{\"302\":1}}],[\"可以在业务逻辑里面判断是否返回0\",{\"1\":{\"1498\":1}}],[\"可以在列表的两端进行插入和删除操作\",{\"1\":{\"1280\":1}}],[\"可以在主节点或者从节点上完成\",{\"1\":{\"1269\":1}}],[\"可以在abstractrefreshableapplicationcontext看到具体的实现\",{\"1\":{\"1163\":1}}],[\"可以在之前的例子上稍作修改\",{\"1\":{\"1001\":1}}],[\"可以在sort\",{\"1\":{\"520\":1}}],[\"可以在show\",{\"1\":{\"431\":1}}],[\"可以在索引遍历过程中\",{\"1\":{\"518\":1}}],[\"可以在索引遍历的过程中\",{\"1\":{\"340\":1}}],[\"可以在delete语句中加上where条件\",{\"1\":{\"484\":1}}],[\"可以在备库上执行show\",{\"1\":{\"457\":1}}],[\"可以在中间件中实现\",{\"1\":{\"444\":1}}],[\"可以在information\",{\"1\":{\"434\":1}}],[\"可以在每次执行一个比较大的操作后\",{\"1\":{\"318\":1}}],[\"可以在uri中指定index\",{\"1\":{\"307\":1}}],[\"可以指定这个备库持续保持跟主库有n秒的延迟\",{\"1\":{\"486\":1}}],[\"可以指定对某些字段不做索引\",{\"1\":{\"308\":1}}],[\"可以指定不同的index\",{\"1\":{\"307\":1}}],[\"可靠性\",{\"1\":{\"1576\":1}}],[\"可靠性是最好的\",{\"1\":{\"1421\":1}}],[\"可靠性比较好\",{\"1\":{\"1421\":1}}],[\"可靠性差\",{\"1\":{\"1421\":1}}],[\"可靠性优于可用性\",{\"1\":{\"495\":1}}],[\"可靠性优先策略\",{\"0\":{\"458\":1}}],[\"可靠的\",{\"1\":{\"1419\":1}}],[\"可靠\",{\"1\":{\"301\":1}}],[\"稳定\",{\"1\":{\"301\":1}}],[\"简洁\",{\"1\":{\"1607\":1}}],[\"简化之后的图\",{\"1\":{\"1683\":1}}],[\"简化\",{\"1\":{\"1479\":1}}],[\"简化模式\",{\"1\":{\"1202\":1}}],[\"简化spring事件发送\",{\"1\":{\"1118\":1}}],[\"简化java5\",{\"1\":{\"1107\":1}}],[\"简化后\",{\"1\":{\"307\":1}}],[\"简易实现\",{\"1\":{\"1049\":1}}],[\"简而言之\",{\"1\":{\"405\":1,\"535\":1,\"1595\":1,\"1614\":1}}],[\"简称mdl\",{\"1\":{\"439\":1}}],[\"简称bnl\",{\"1\":{\"402\":1}}],[\"简称nlj\",{\"1\":{\"401\":1}}],[\"简称es\",{\"1\":{\"301\":1}}],[\"简介\",{\"0\":{\"329\":1,\"666\":1,\"674\":1,\"682\":1,\"1589\":1,\"1625\":1,\"1627\":1,\"1681\":1,\"1796\":1}}],[\"简单\",{\"1\":{\"1576\":2}}],[\"简单来讲\",{\"1\":{\"1526\":1}}],[\"简单来说\",{\"1\":{\"327\":1,\"331\":1,\"432\":1,\"1234\":1,\"1405\":1,\"1410\":1,\"1553\":1,\"1611\":1}}],[\"简单的任务\",{\"1\":{\"1518\":1}}],[\"简单的select查询\",{\"1\":{\"330\":1}}],[\"简单介绍spring\",{\"0\":{\"1159\":1}}],[\"简单实现\",{\"1\":{\"1093\":1}}],[\"简单地通过判空来检查是否成功返回\",{\"1\":{\"1517\":1}}],[\"简单地说\",{\"1\":{\"914\":1,\"1990\":1}}],[\"简单地\",{\"1\":{\"394\":1}}],[\"简单查询\",{\"0\":{\"392\":1}}],[\"简单理解\",{\"1\":{\"300\":1,\"1202\":1}}],[\"正式由于supplier这个函数式接口不接收参数\",{\"1\":{\"1600\":1}}],[\"正式read\",{\"1\":{\"542\":1}}],[\"正好是十个元素\",{\"1\":{\"1617\":1}}],[\"正好可以接收bifunction这个接口的返回的结果作为参数\",{\"1\":{\"1598\":1}}],[\"正好满足bifunction的定义\",{\"1\":{\"1598\":1}}],[\"正确的订阅关系\",{\"0\":{\"1865\":1}}],[\"正确的方式应该像下面这样只取需要的列\",{\"1\":{\"384\":1}}],[\"正确同步的多线程程序\",{\"1\":{\"1474\":1}}],[\"正在销毁中\",{\"1\":{\"985\":1}}],[\"正常执行\",{\"1\":{\"581\":1}}],[\"正常情况按照最左前缀原则\",{\"1\":{\"518\":1}}],[\"正常情况下就会区别于读事务的id\",{\"1\":{\"497\":1}}],[\"正常情况下\",{\"1\":{\"456\":1}}],[\"正如它的方法名称那样描述的\",{\"1\":{\"1613\":1}}],[\"正如图redis中list是可以进行双端操作的\",{\"1\":{\"571\":1}}],[\"正如我们预测的\",{\"1\":{\"390\":1}}],[\"正是因为将执行的结果传递给了方法参数的sink\",{\"1\":{\"1623\":1}}],[\"正是这两点\",{\"1\":{\"543\":1}}],[\"正是由于多了从库b\",{\"1\":{\"466\":1}}],[\"正无穷\",{\"1\":{\"536\":1}}],[\"正文内容\",{\"1\":{\"361\":1}}],[\"正符合了我们前面提到的递增插入的场景\",{\"1\":{\"335\":1}}],[\"正向索引是通过key找value\",{\"1\":{\"300\":1}}],[\"正排索引\",{\"1\":{\"300\":1}}],[\"关注事件源主体\",{\"1\":{\"1118\":1}}],[\"关联classloader\",{\"1\":{\"1164\":1}}],[\"关联新建beanfactory到spring应用上下文\",{\"1\":{\"1163\":1}}],[\"关联方法\",{\"1\":{\"1153\":1}}],[\"关联\",{\"1\":{\"1153\":1}}],[\"关联对象\",{\"1\":{\"1139\":2}}],[\"关联的构造器\",{\"1\":{\"1102\":1}}],[\"关联的方法\",{\"1\":{\"1102\":1}}],[\"关联的bean\",{\"1\":{\"1070\":1}}],[\"关联目标bean\",{\"1\":{\"1070\":1}}],[\"关联messagesource实现\",{\"1\":{\"1063\":1}}],[\"关联字段加索引\",{\"1\":{\"525\":1}}],[\"关闭这个流\",{\"1\":{\"1619\":1}}],[\"关闭通道\",{\"1\":{\"1587\":1,\"1588\":1}}],[\"关闭socket\",{\"1\":{\"1533\":1,\"1534\":1}}],[\"关闭spring应用\",{\"1\":{\"1174\":1}}],[\"关闭spring容器\",{\"1\":{\"934\":1,\"1013\":1}}],[\"关闭锁消除\",{\"1\":{\"1487\":1}}],[\"关闭延迟开启偏向锁\",{\"1\":{\"1485\":1}}],[\"关闭\",{\"1\":{\"1184\":1}}],[\"关闭阶段\",{\"1\":{\"1177\":1}}],[\"关闭beanfactory\",{\"1\":{\"1175\":1}}],[\"关闭lifecycleprocessor\",{\"1\":{\"1175\":1}}],[\"关闭应用上下文\",{\"1\":{\"1044\":1,\"1045\":1,\"1084\":1}}],[\"关闭连接\",{\"1\":{\"582\":1}}],[\"关闭trace\",{\"1\":{\"519\":1,\"520\":1}}],[\"关掉12号线程的网络连接\",{\"1\":{\"481\":1}}],[\"关于元空间的jvm参数\",{\"1\":{\"1664\":1}}],[\"关于关闭处理器可以举一个简单的例子\",{\"1\":{\"1619\":1}}],[\"关于分组的方法还有另外的说明\",{\"1\":{\"1618\":1}}],[\"关于predicate的三个默认方法\",{\"1\":{\"1599\":1}}],[\"关于函数式接口的定义如下\",{\"1\":{\"1594\":1}}],[\"关于lambda表达式的创建会在后续的文章中详细讲解\",{\"1\":{\"1594\":1}}],[\"关于句柄的解释\",{\"1\":{\"1561\":1}}],[\"关于hashmap的容量为什么是2的幂次方\",{\"1\":{\"1546\":1}}],[\"关于主内存和工作内存之间的具体交互协议\",{\"1\":{\"1473\":1}}],[\"关于beans的元素相关的配置可以在beandefinitionparserdelegate\",{\"1\":{\"1020\":1}}],[\"关于bean生命周期的完整的演示示例\",{\"1\":{\"1011\":1}}],[\"关于bean的初始化操作\",{\"1\":{\"1008\":1}}],[\"关于georadius的参数\",{\"1\":{\"576\":1}}],[\"关于重命名rename和renamenx\",{\"1\":{\"569\":1}}],[\"关于ttl命令\",{\"1\":{\"569\":1}}],[\"关于这个过程的说明\",{\"1\":{\"485\":1}}],[\"关于幻读的两点说明\",{\"1\":{\"446\":1}}],[\"关于临时表中数据的存放方式\",{\"1\":{\"412\":1}}],[\"关于join语句使用的问题\",{\"1\":{\"400\":1}}],[\"关于我\",{\"0\":{\"0\":1}}],[\"关键的部分在于\",{\"1\":{\"1618\":1}}],[\"关键就在于需要执行的finisher方法\",{\"1\":{\"1618\":1}}],[\"关键字识别出来\",{\"1\":{\"320\":1}}],[\"关键词\",{\"1\":{\"300\":1}}],[\"这本书深入到jvm\",{\"1\":{\"1992\":1}}],[\"这本书是\",{\"1\":{\"1992\":1}}],[\"这本书是mysql领域的经典之作\",{\"1\":{\"1974\":1}}],[\"这本书实践性很强\",{\"1\":{\"1974\":1}}],[\"这本书\",{\"1\":{\"1971\":1}}],[\"这本书偏向实用\",{\"1\":{\"1969\":1}}],[\"这部分我们要学习的主流框架主要有\",{\"1\":{\"1979\":1}}],[\"这部分内容对于想要进好一点的公司的同学来说非常重要\",{\"1\":{\"1970\":1}}],[\"这部分可以先跳过\",{\"1\":{\"1969\":1}}],[\"这部分主要学习的内容有\",{\"1\":{\"1969\":1,\"1974\":1}}],[\"这部分数据的长度在32位和64位虚拟机中分别为32bit和64bit\",{\"1\":{\"1484\":1}}],[\"这可以强转的原因是如果参数是integer类型的\",{\"1\":{\"1620\":1}}],[\"这可以使用serial\",{\"1\":{\"1620\":1}}],[\"这可能是一个昂贵的操作\",{\"1\":{\"1618\":1}}],[\"这可能效率高\",{\"1\":{\"1615\":1}}],[\"这可能使得redis本身的速度变慢\",{\"1\":{\"600\":1}}],[\"这可能比随机的关联要更高效\",{\"1\":{\"394\":1}}],[\"这并不是绝对的\",{\"1\":{\"1619\":1}}],[\"这将导致\",{\"1\":{\"1617\":1}}],[\"这将返回这三表的全部数据列\",{\"1\":{\"384\":1}}],[\"这其实指的就是如果使用并行流\",{\"1\":{\"1622\":1}}],[\"这其实就是汇聚操作的整个过程\",{\"1\":{\"1615\":1}}],[\"这其中比较重要的是第二个tryadvance方法\",{\"1\":{\"1620\":1}}],[\"这其中最关键的地方在于\",{\"1\":{\"1598\":1}}],[\"这其中包含了大量为了检索数据到存储引擎的调用以及调用后的数据处理\",{\"1\":{\"381\":1}}],[\"这取决于accumulator和combiner消耗的成本和代价\",{\"1\":{\"1615\":1}}],[\"这取决于解决的实际问题\",{\"1\":{\"1612\":1}}],[\"这取决于排序所需要的内存和参数sort\",{\"1\":{\"354\":1}}],[\"这提示我们在使用流的使用后一定要注意编写的顺序和流的相关特性\",{\"1\":{\"1610\":1}}],[\"这实际上是一种比起tolist\",{\"1\":{\"1609\":1}}],[\"这实际上是jdk中的一个约定\",{\"1\":{\"1607\":1}}],[\"这几种创建stream的方式并没有什么区别\",{\"1\":{\"1607\":1}}],[\"这同一种实现\",{\"1\":{\"1595\":1}}],[\"这说明使用lambda表达式的这种方式与它所在的类是同一个作用域\",{\"1\":{\"1592\":1}}],[\"这说明在使用前缀索引的时候\",{\"1\":{\"350\":1}}],[\"这段代码会输出什么呢\",{\"1\":{\"1610\":1}}],[\"这段代码我们实际上需要的其实只有system\",{\"1\":{\"1591\":1}}],[\"这段文字的含义\",{\"1\":{\"1608\":1}}],[\"这段时间\",{\"1\":{\"464\":1}}],[\"这有助于编写出更为简洁\",{\"1\":{\"1591\":1}}],[\"这显然是不对的\",{\"1\":{\"1609\":1}}],[\"这显然是不行的\",{\"1\":{\"1598\":1}}],[\"这显然是不合适的\",{\"1\":{\"1573\":2,\"1607\":1}}],[\"这显然与\",{\"1\":{\"532\":1}}],[\"这块牌匾是不变的\",{\"1\":{\"1561\":1}}],[\"这儿是自旋\",{\"1\":{\"1554\":1}}],[\"这仅仅是为了保证序列化时的兼容性\",{\"1\":{\"1554\":1}}],[\"这项能力是它的核心能力\",{\"1\":{\"1518\":1}}],[\"这才是更重要的\",{\"1\":{\"1613\":1}}],[\"这才是重量级锁最大的开销\",{\"1\":{\"1485\":1}}],[\"这才会真正的唤醒生产者线程\",{\"1\":{\"1503\":1}}],[\"这与之前的面向对象的编程方式是完全不同的\",{\"1\":{\"1598\":1}}],[\"这与guard\",{\"1\":{\"1531\":1}}],[\"这与操作系统有关\",{\"1\":{\"1423\":1}}],[\"这与在一个关系型数据库实例\",{\"1\":{\"567\":1}}],[\"这通常是有害的\",{\"1\":{\"1391\":1}}],[\"这通常意味着访问了太多的行\",{\"1\":{\"381\":1}}],[\"这意味着中间结果容器支持使用多线程进行并发访问\",{\"1\":{\"1617\":1}}],[\"这意味着\",{\"1\":{\"1614\":1,\"1615\":1}}],[\"这意味着加锁失败\",{\"1\":{\"1498\":1}}],[\"这意味着随着系统变大\",{\"1\":{\"1474\":1}}],[\"这意味着读写数据都是在内存中完成\",{\"1\":{\"1292\":1}}],[\"这意味着如果事务执行期间mysql发生异常重启\",{\"1\":{\"451\":1}}],[\"这不是一种推荐的方式\",{\"1\":{\"619\":1}}],[\"这主要是lifecyclemetadata中包含了初始化和销毁两个阶段\",{\"1\":{\"966\":1}}],[\"这主要是因为在mysql目前的实现中\",{\"1\":{\"557\":1}}],[\"这主要是由于mysql在可重复读的隔离级别下使用了mvcc机制\",{\"1\":{\"535\":1}}],[\"这主要是出于数据的一致性的考虑\",{\"1\":{\"492\":1}}],[\"这四种查询的效率比较\",{\"1\":{\"526\":1}}],[\"这四行数据是分三次申请的自增id\",{\"1\":{\"492\":1}}],[\"这会为后面我们能完整的看到流的整个调用顺序打下良好的基础\",{\"1\":{\"1613\":1}}],[\"这会与上面的代码得到相同的结果\",{\"1\":{\"1600\":1}}],[\"这会导致user在两个命名空间下的数据不一致\",{\"1\":{\"1219\":1}}],[\"这会影响并发度\",{\"1\":{\"492\":1}}],[\"这会给mysql服务器带来额外的负担\",{\"1\":{\"382\":1}}],[\"这和数据传输可靠性有关\",{\"1\":{\"600\":1}}],[\"这和linux的kill命令类似\",{\"1\":{\"481\":1}}],[\"这和innodb的事务设计有关系\",{\"1\":{\"396\":1}}],[\"这类情况\",{\"1\":{\"481\":1}}],[\"这类请求就可以走从库\",{\"1\":{\"470\":1}}],[\"这类不会再修改的数据\",{\"1\":{\"333\":1}}],[\"这跟基于位点的主备协议不同\",{\"1\":{\"468\":1}}],[\"这跟事务的可见性规则并不矛盾\",{\"1\":{\"446\":1}}],[\"这句话的作用是\",{\"1\":{\"468\":1}}],[\"这一阶段的内容均以了解为主\",{\"1\":{\"1976\":1}}],[\"这一部分是整个函数式编程最核心的部分\",{\"1\":{\"1618\":1}}],[\"这一类参数是跟特定hotspot版本对应的\",{\"1\":{\"1453\":1}}],[\"这一类缓存的有效期要设置得短一点\",{\"1\":{\"1282\":1}}],[\"这一点在源代码中也有体现\",{\"1\":{\"1614\":1}}],[\"这一点就保证了容器在扩容的时候并不会有其他的线程进行数据添加操作\",{\"1\":{\"1554\":1}}],[\"这一点\",{\"1\":{\"966\":1,\"1005\":1,\"1611\":1,\"1612\":1}}],[\"这一点对于我们实际书写连接查询语句时十分有用\",{\"1\":{\"555\":1}}],[\"这一步就会花比较长的时间\",{\"1\":{\"482\":1}}],[\"这一行统计的是redo\",{\"1\":{\"479\":1}}],[\"这一行\",{\"1\":{\"479\":2,\"1551\":1,\"1591\":1}}],[\"这一组全部执行完成后\",{\"1\":{\"464\":1}}],[\"这一个记录的值分别是1\",{\"1\":{\"434\":1}}],[\"这么操作的前提是\",{\"1\":{\"467\":1}}],[\"这么以来\",{\"1\":{\"451\":1}}],[\"这么做实现了两个函数式接口的串联\",{\"1\":{\"1598\":1}}],[\"这么做可以在数组table的length比较小的时候\",{\"1\":{\"1548\":1}}],[\"这么做的理由是什么呢\",{\"1\":{\"1616\":1}}],[\"这么做的理由有很多\",{\"1\":{\"454\":1}}],[\"这么做的原因是\",{\"1\":{\"405\":1,\"484\":1}}],[\"这么做不如直接join\",{\"1\":{\"401\":1}}],[\"这对于需要保持一致性的业务会有影响\",{\"1\":{\"627\":1}}],[\"这对于在线服务来说\",{\"1\":{\"444\":1}}],[\"这对于高性能来说是必不可少的\",{\"1\":{\"381\":1}}],[\"这往往是dba要求业务开发人员使用innodb替代myisam的原因之一\",{\"1\":{\"438\":1}}],[\"这正是因为myisam的表锁是在引擎层实现的\",{\"1\":{\"424\":1}}],[\"这在多处理系统中的cpu尤其如此\",{\"1\":{\"1474\":1}}],[\"这在一些场景下可能会导致内存溢出\",{\"1\":{\"1457\":1}}],[\"这在一定程度上能够说明该查询找到需要的数据的效率高不高\",{\"1\":{\"389\":1}}],[\"这在mysql服务器层完成\",{\"1\":{\"390\":1}}],[\"这再次触发了本节开始时提到的原则\",{\"1\":{\"368\":1}}],[\"这条指令完成了整个\",{\"1\":{\"1479\":1}}],[\"这条update语句执行后生成的数据版本上的trx\",{\"1\":{\"497\":1}}],[\"这条记录\",{\"1\":{\"491\":1}}],[\"这条命令逻辑错误\",{\"1\":{\"580\":1}}],[\"这条命令的逻辑是\",{\"1\":{\"474\":1}}],[\"这条命令有6个参数\",{\"1\":{\"467\":1}}],[\"这条insert语句\",{\"1\":{\"425\":1}}],[\"这条查询语句在索引a上是一个范围查询\",{\"1\":{\"404\":1}}],[\"这条语句不像第一个例子的update语句一样退出呢\",{\"1\":{\"481\":1}}],[\"这条语句已经不需要继续执行了\",{\"1\":{\"481\":1}}],[\"这条语句在实例y上的gtid是\",{\"1\":{\"468\":1}}],[\"这条语句的执行就会报错\",{\"1\":{\"484\":1}}],[\"这条语句的执行流程如下\",{\"1\":{\"420\":1,\"491\":1}}],[\"这条语句的执行结果如下\",{\"1\":{\"416\":1}}],[\"这条语句的explain的结果如下\",{\"1\":{\"366\":1}}],[\"这条语句用到了union\",{\"1\":{\"414\":1}}],[\"这条语句会执行得越来越慢\",{\"1\":{\"395\":1}}],[\"这条语句触发了我们之前说到的过规则\",{\"1\":{\"367\":1}}],[\"这条语句需要走全表扫描\",{\"1\":{\"367\":1}}],[\"这条更新语句做了如下操作\",{\"1\":{\"345\":1}}],[\"这条更新语句\",{\"1\":{\"345\":1}}],[\"这体现了mysql的一个设计理念\",{\"1\":{\"356\":1}}],[\"这也验证了我们之前的说法\",{\"1\":{\"1600\":1}}],[\"这也保证了容器的安全性\",{\"1\":{\"1554\":1}}],[\"这也就意味着生产者和消费者无法并行操作\",{\"1\":{\"1502\":1}}],[\"这也就意味着\",{\"1\":{\"1501\":1}}],[\"这也就是很多文章中建议不要使用长事务的原因之一\",{\"1\":{\"434\":1}}],[\"这也就是排序模式里面\",{\"1\":{\"420\":1}}],[\"这也就是说直接执行语句的结果可能是错误的\",{\"1\":{\"454\":1}}],[\"这也就是说\",{\"1\":{\"317\":1,\"1615\":1}}],[\"这也正是\",{\"1\":{\"1479\":1}}],[\"这也从另一个角度说明了appliacitoncontext和beanfactory的区别\",{\"1\":{\"1005\":1}}],[\"这也导致出现了自增id不连续的情况\",{\"1\":{\"492\":1}}],[\"这也体现出了这个算法名字中\",{\"1\":{\"403\":1}}],[\"这也是循环依赖的一种情况\",{\"1\":{\"1647\":1}}],[\"这也是一种可变操作\",{\"1\":{\"1615\":1}}],[\"这也是使用内部迭代给我们带来的另一个好处\",{\"1\":{\"1612\":1}}],[\"这也是流的另一个重要的特性\",{\"1\":{\"1610\":1}}],[\"这也是流式编程给我们带来的好处\",{\"1\":{\"1608\":1}}],[\"这也是面向对象带来限制\",{\"1\":{\"1607\":1}}],[\"这也是新增加的comparebyscore和comparebyname的作用\",{\"1\":{\"1605\":1}}],[\"这也是在jdk8中新增加的方法\",{\"1\":{\"1603\":1}}],[\"这也是在选择是否使用前缀索引时需要考虑的一个因素\",{\"1\":{\"351\":1}}],[\"这也是锁分离带来的代价\",{\"1\":{\"1503\":1}}],[\"这也是longadder设计的精妙之处\",{\"1\":{\"1480\":1}}],[\"这也是为什么需要在步骤1先做判断\",{\"1\":{\"458\":1}}],[\"这也是myisam被innodb取代的重要原因之一\",{\"1\":{\"432\":1}}],[\"这也是两个tradeied字段的join操作\",{\"1\":{\"368\":1}}],[\"这次我们顺利的打印出了stream对象\",{\"1\":{\"1610\":1}}],[\"这次我们使用另一种写法来完成这个功能\",{\"1\":{\"1604\":1}}],[\"这次的查询操作用上了被驱动表tradelog里的索引\",{\"1\":{\"368\":1}}],[\"这次值取对了\",{\"1\":{\"350\":1}}],[\"这次优化器选择了索引b\",{\"1\":{\"347\":1}}],[\"这行记录丢弃\",{\"1\":{\"350\":1}}],[\"这三种不同的方式最终注入的是相同的对象\",{\"1\":{\"1045\":1}}],[\"这三种状态分别是\",{\"1\":{\"451\":1}}],[\"这三行的结果\",{\"1\":{\"447\":1}}],[\"这三个方法是java中管程技术的组成部分\",{\"1\":{\"1483\":1}}],[\"这三个值中取出一个最大的\",{\"1\":{\"1227\":1}}],[\"这三个字符\",{\"1\":{\"624\":1}}],[\"这三个区间\",{\"1\":{\"536\":1}}],[\"这三个指标都会记录到mysql的慢日志中\",{\"1\":{\"387\":1}}],[\"这三个索引的基数值并不同\",{\"1\":{\"347\":1}}],[\"这三条sql语句执行完成后的慢查询日志如下\",{\"1\":{\"346\":1}}],[\"这两表都位于mysql系统数据库下面\",{\"1\":{\"558\":1}}],[\"这两行数据\",{\"1\":{\"459\":1}}],[\"这两行记录分别落在p\",{\"1\":{\"424\":1}}],[\"这两种写法完全是等价的\",{\"1\":{\"1617\":1}}],[\"这两种写法的运行结果完全是等价的\",{\"1\":{\"1595\":1}}],[\"这两种累加的结果是等价的\",{\"1\":{\"1615\":1}}],[\"这两种方案\",{\"1\":{\"1528\":1}}],[\"这两种方式的效果完全等价\",{\"1\":{\"1603\":1}}],[\"这两种方式各有优劣\",{\"1\":{\"1306\":1}}],[\"这两种方式也是没有差别的\",{\"1\":{\"424\":1}}],[\"这两种机制各有优缺点\",{\"1\":{\"1474\":1}}],[\"这两种执行方法的逻辑是一样的\",{\"1\":{\"514\":1}}],[\"这两种执行方法的逻辑结果是一样的\",{\"1\":{\"321\":1}}],[\"这两种情况都会影响buffer\",{\"1\":{\"406\":1}}],[\"这两张表都有一个主键索引id和一个索引a\",{\"1\":{\"400\":1}}],[\"这两个filter是spring扫描过程中用来过滤的\",{\"1\":{\"1645\":1}}],[\"这两个缺点都会影响任务的执行效率\",{\"1\":{\"1510\":1}}],[\"这两个附加的操作是\",{\"1\":{\"1395\":1}}],[\"这两个redis命令可被视为等同于关系型数据库中的commit\",{\"1\":{\"1297\":1}}],[\"这两个成本常数是我们最常用到的\",{\"1\":{\"545\":1}}],[\"这两个方案都要求备份系统定期备份全量日志\",{\"1\":{\"485\":1}}],[\"这两个方案的共同点是\",{\"1\":{\"485\":1}}],[\"这两个参数\",{\"1\":{\"465\":1}}],[\"这两个参数用于故意拉长binlog从write到fsync的时间\",{\"1\":{\"465\":1}}],[\"这两个事务要更新的行的主键值不同\",{\"1\":{\"462\":1}}],[\"这两个条件是或的关系\",{\"1\":{\"451\":1}}],[\"这两个记录之间的间隙是会被锁住的\",{\"1\":{\"424\":1}}],[\"这两个create\",{\"1\":{\"413\":1}}],[\"这两个在email字段上创建索引的语句\",{\"1\":{\"350\":1}}],[\"这两个索引\",{\"1\":{\"339\":1}}],[\"这两类索引在查询能力上没有差别\",{\"1\":{\"344\":1}}],[\"这已经17亿了\",{\"1\":{\"334\":1}}],[\"这棵树高是4的时候\",{\"1\":{\"334\":1}}],[\"这时当前线程就可以避免阻塞\",{\"1\":{\"1485\":1}}],[\"这时锁还是会被锁死\",{\"1\":{\"1288\":1}}],[\"这时要注意为了防止redis被无用的key占满\",{\"1\":{\"1282\":1}}],[\"这时这个脚本应该通过邮件\",{\"1\":{\"624\":1}}],[\"这时因为在执行show\",{\"1\":{\"481\":1}}],[\"这时我们就可以使用kill\",{\"1\":{\"480\":1}}],[\"这时返回的结果如下\",{\"1\":{\"416\":1}}],[\"这时的内存临时表大小不够存下这100行数据\",{\"1\":{\"416\":1}}],[\"这时存储引擎层完成的\",{\"1\":{\"390\":1}}],[\"这时\",{\"1\":{\"343\":1,\"347\":2,\"356\":1,\"405\":1,\"411\":1,\"468\":3,\"472\":2,\"474\":1,\"485\":1,\"491\":1,\"492\":1,\"1201\":1}}],[\"这时也可以用上这个索引\",{\"1\":{\"339\":1}}],[\"这时只需要查id的值\",{\"1\":{\"338\":1}}],[\"这时候用户进程再调用read操作\",{\"1\":{\"1565\":1}}],[\"这时候用户的session用户信息就丢失了\",{\"1\":{\"1200\":1}}],[\"这时候就会认为是两个不同的对象\",{\"1\":{\"1367\":1}}],[\"这时候就关系到存储对象的序列化问题\",{\"1\":{\"583\":1}}],[\"这时候操作系统自己同步数据\",{\"1\":{\"592\":1}}],[\"这时候系统其实已经不正常了\",{\"1\":{\"476\":1}}],[\"这时候innodb不能响应任何请求\",{\"1\":{\"476\":1}}],[\"这时候id=1的行的a的值还是1\",{\"1\":{\"462\":1}}],[\"这时候哈希表就要记录100万个项\",{\"1\":{\"462\":1}}],[\"这时候主库a掉电了\",{\"1\":{\"459\":1}}],[\"这时候需要借助mysqlbinlog工具\",{\"1\":{\"454\":1}}],[\"这时候需要申请一个新的数据页\",{\"1\":{\"335\":1}}],[\"这时候备库会启动两个线程\",{\"1\":{\"453\":1}}],[\"这时候客户端读写访问的都是节点b\",{\"1\":{\"453\":1}}],[\"这时候trx2和trx3就可以直接返回了\",{\"1\":{\"451\":1}}],[\"这时候lsn也变成了160\",{\"1\":{\"451\":1}}],[\"这时候会对表t加上一个mdl读锁\",{\"1\":{\"441\":1}}],[\"这时候事务b虽然还没有提交\",{\"1\":{\"433\":1}}],[\"这时候c2已经不用排序了\",{\"1\":{\"378\":1}}],[\"这时候\",{\"1\":{\"346\":1,\"351\":1,\"368\":1,\"444\":1,\"451\":1,\"476\":1,\"481\":3,\"482\":1,\"967\":1,\"1201\":1}}],[\"这时候我们就需要优先考虑上一段提到的\",{\"1\":{\"335\":1}}],[\"这时候如果对身份证号长度为6的前缀索引的话\",{\"1\":{\"352\":1}}],[\"这时候如果要查询id\",{\"1\":{\"333\":1}}],[\"这时候如果你要继续\",{\"1\":{\"318\":1}}],[\"这时对应的哈希索引的示意图如下所示\",{\"1\":{\"332\":1}}],[\"这里用网络上一个台式电脑的比喻来说就是\",{\"1\":{\"1990\":1}}],[\"这里用的双路排序\",{\"1\":{\"520\":1}}],[\"这里用的单路排序\",{\"1\":{\"520\":1}}],[\"这里推荐个我做过的社区论坛项目\",{\"1\":{\"1987\":1}}],[\"这里我推荐极客时间的课程\",{\"1\":{\"1972\":1}}],[\"这里我们显然是串行流\",{\"1\":{\"1617\":1}}],[\"这里我们也是需要使用另一个collectors中的方法\",{\"1\":{\"1613\":1}}],[\"这里我们就要调用groupingby的一个重载的方式来实现\",{\"1\":{\"1613\":1}}],[\"这里我们首先对于流中的集合进行了平方的操作\",{\"1\":{\"1609\":1}}],[\"这里我们使用的静态的常量是\",{\"1\":{\"1614\":1}}],[\"这里我们使用的collectors类中的tocollection\",{\"1\":{\"1609\":1}}],[\"这里我们使用构方法引用的方式\",{\"1\":{\"1609\":1}}],[\"这里我们选择new一个arraylist作为返回的容器\",{\"1\":{\"1608\":1}}],[\"这里我们对于集合中的元素先乘以2\",{\"1\":{\"1607\":1}}],[\"这里我们对mysql使用内部临时表做如下总结\",{\"1\":{\"418\":1}}],[\"这里我们调用的是类实例的方法\",{\"1\":{\"1604\":1}}],[\"这里我们直接使用studentcomparator实例中的comparestudentbyscore来进行排序\",{\"1\":{\"1604\":1}}],[\"这里我们排序的时候直接调用的是list集合中的默认方法sort\",{\"1\":{\"1603\":1}}],[\"这里我们先不去考虑lambda表达式具体的语法\",{\"1\":{\"1593\":1}}],[\"这里我们以linux\",{\"1\":{\"1479\":1}}],[\"这里我们可以编写一个示例\",{\"1\":{\"1181\":1}}],[\"这里我们可以总结一下\",{\"1\":{\"1001\":1}}],[\"这里我们不采用注解的方式\",{\"1\":{\"1084\":1}}],[\"这里我们不对\",{\"1\":{\"967\":1}}],[\"这里我们增加一个调用的示例\",{\"1\":{\"1006\":1}}],[\"这里我们演示了两种情况\",{\"1\":{\"1003\":1}}],[\"这里我们新建一个userholder\",{\"1\":{\"953\":1}}],[\"这里我们重写了defaultuserfactory中的finalize\",{\"1\":{\"934\":1}}],[\"这里我们设置innodb\",{\"1\":{\"476\":1}}],[\"这里我们假设从上到下是按照时间顺序执行的\",{\"1\":{\"396\":1}}],[\"这里我们假设身份证号没有重复\",{\"1\":{\"333\":1}}],[\"这里我们这里讨论三种常见的数据结构\",{\"1\":{\"331\":1}}],[\"这里可以使用自定义的classloader\",{\"1\":{\"1647\":1}}],[\"这里可以通过bytype或者byname进行注入\",{\"1\":{\"953\":1}}],[\"这里对我们而言有三个阶段\",{\"1\":{\"1623\":1}}],[\"这里又调用了abstractpipeline的构造方法\",{\"1\":{\"1622\":1}}],[\"这里将集合中的迭代器找出来并且估算元素的大小\",{\"1\":{\"1622\":1}}],[\"这里调用的第一个stream方法\",{\"1\":{\"1622\":1}}],[\"这里调用的collection接口中的stream方法\",{\"1\":{\"1620\":1}}],[\"这里spliterator作为流的源\",{\"1\":{\"1621\":1}}],[\"这里引出了另外一个及其重要的类referencepipeline\",{\"1\":{\"1621\":1}}],[\"这里给出了一个例子\",{\"1\":{\"1620\":1}}],[\"这里也可以看到这个构造方法与我们之前见过的有关构造流源的构造方法的作用完全不同\",{\"1\":{\"1622\":1}}],[\"这里也是由于一定是<a\",{\"1\":{\"1618\":1}}],[\"这里也会初始化\",{\"1\":{\"1166\":1}}],[\"这里程序并不会依次的调用\",{\"1\":{\"1617\":1}}],[\"这里就会开启多个线程\",{\"1\":{\"1617\":1}}],[\"这里就要说明一个及其重要的方法collect\",{\"1\":{\"1608\":1}}],[\"这里就要提到一个同步原理\",{\"1\":{\"611\":1}}],[\"这里不能调用hashset\",{\"1\":{\"1617\":1}}],[\"这里为什么不直接使用数字\",{\"1\":{\"1618\":1}}],[\"这里为什么会是t类型以及t类型以上的类型呢\",{\"1\":{\"1614\":1}}],[\"这里为啥要唤醒一下呢\",{\"1\":{\"1503\":1}}],[\"这里面用到了collectors这个类提供的静态方法groupingby\",{\"1\":{\"1613\":1}}],[\"这里举了两个例子\",{\"1\":{\"1608\":1}}],[\"这里总共有三个步骤\",{\"1\":{\"1608\":1}}],[\"这里并不是object类\",{\"1\":{\"1599\":1}}],[\"这里并不是将值作为参数\",{\"1\":{\"1595\":1}}],[\"这里还需要简单提及一下高阶函数\",{\"1\":{\"1598\":1}}],[\"这里说\",{\"1\":{\"1594\":1,\"1599\":1}}],[\"这里涉及到相同的key进行put就会覆盖原先的value\",{\"1\":{\"1554\":1}}],[\"这里了\",{\"1\":{\"1550\":1}}],[\"这里所说的队列是系统内存的内存队列\",{\"1\":{\"1519\":1}}],[\"这里所指索引统计数据指的是这两个值\",{\"1\":{\"553\":1}}],[\"这里把head删除\",{\"1\":{\"1503\":1}}],[\"这里索性在放完元素就检测一下\",{\"1\":{\"1503\":1}}],[\"这里设计成环形链表的原因是基于效率的考量\",{\"1\":{\"1502\":1}}],[\"这里设置innodb\",{\"1\":{\"476\":1}}],[\"这里首先得明确一下线程和进程的区别\",{\"1\":{\"1377\":1}}],[\"这里首先要关注一个属性\",{\"1\":{\"965\":1}}],[\"这里map的key就是根据mapper的全类名\",{\"1\":{\"1208\":1}}],[\"这里补充一个关于shutdownhook的示例\",{\"1\":{\"1175\":1}}],[\"这里必须是静态字段\",{\"1\":{\"1116\":1}}],[\"这里会拿到缓存好的构造方法入参\",{\"1\":{\"1650\":1}}],[\"这里会处理\",{\"1\":{\"1648\":1}}],[\"这里会处理循环依赖问题\",{\"1\":{\"1647\":1}}],[\"这里会导致bean的提前初始化\",{\"1\":{\"1166\":1}}],[\"这里会触发两次\",{\"1\":{\"1116\":1}}],[\"这里会显示操作系统登录的用户名\",{\"1\":{\"978\":1}}],[\"这里第一种方式也比较容易\",{\"1\":{\"1114\":1}}],[\"这里由于observable的setchanged是protected\",{\"1\":{\"1108\":1}}],[\"这里主要演示第二种和第三种\",{\"1\":{\"1019\":1}}],[\"这里主要是通过autowiredannotationbeanpostprocessor查找构造方法\",{\"1\":{\"1650\":1}}],[\"这里主要是基于安全性的考量\",{\"1\":{\"962\":1}}],[\"这里主要是为了区分机械硬盘和固态硬盘\",{\"1\":{\"557\":1}}],[\"这里因为类型推断的原因\",{\"1\":{\"1597\":1}}],[\"这里因为我们是beanfactory的场景\",{\"1\":{\"1007\":1}}],[\"这里因为这里mysql并没有使用归并排序算法\",{\"1\":{\"421\":1}}],[\"这里列出的顺序同时也是调用时候的顺序\",{\"1\":{\"1005\":1}}],[\"这里列的这些\",{\"1\":{\"390\":1}}],[\"这里相当于可以拦截掉所有的属性赋值\",{\"1\":{\"1002\":1}}],[\"这里之所以使用limit是因为如果不加限制\",{\"1\":{\"1609\":1}}],[\"这里之所以还要维护一个beandefinitionnames是为了记住注册时候的bean的顺序\",{\"1\":{\"996\":1}}],[\"这里之所以和我们计算有点不同的原因是\",{\"1\":{\"551\":1}}],[\"这里除了properties资源配置我们没有见到过外\",{\"1\":{\"994\":1}}],[\"这里假设负载因子loadfactor=1\",{\"1\":{\"1550\":1}}],[\"这里假设使用idx\",{\"1\":{\"555\":1}}],[\"这里假设这条select查询最多在主库上等待1秒\",{\"1\":{\"473\":1}}],[\"这里暂时不做探讨\",{\"1\":{\"554\":1}}],[\"这里无用\",{\"1\":{\"553\":1}}],[\"这里自动补全的效果是\",{\"1\":{\"482\":1}}],[\"这里connection可缺省\",{\"1\":{\"480\":1}}],[\"这里value=2是因为修改前后的行id值不变\",{\"1\":{\"462\":1}}],[\"这里使用stringbuilder作为最终返回的结果容器\",{\"1\":{\"1608\":1}}],[\"这里使用beans来更加明确的说明\",{\"1\":{\"1021\":1}}],[\"这里使用的是可重复读隔离级别\",{\"1\":{\"497\":1}}],[\"这里使用箭头的粗细来表示并行度\",{\"1\":{\"460\":1}}],[\"这里使用了force\",{\"1\":{\"346\":1}}],[\"这里有两个新的方法\",{\"1\":{\"1610\":1}}],[\"这里有一个误区就是\",{\"1\":{\"984\":1}}],[\"这里有一个误区是\",{\"1\":{\"457\":1}}],[\"这里有一个问题\",{\"1\":{\"555\":1}}],[\"这里有100行\",{\"1\":{\"401\":1}}],[\"这里只能是userinterface类型的\",{\"1\":{\"1654\":1}}],[\"这里只是提供了创建结果容器的入口\",{\"1\":{\"1618\":1}}],[\"这里只是元信息不太一样\",{\"1\":{\"966\":1}}],[\"这里只需要大概了解函数式接口实例创建的方式有这么三种\",{\"1\":{\"1594\":1}}],[\"这里只介绍使用加锁来解决这些问题\",{\"1\":{\"1261\":1}}],[\"这里只介绍面向注解的beandefinition解析\",{\"1\":{\"995\":1}}],[\"这里只操作了一张表\",{\"1\":{\"454\":1}}],[\"这里只用到了cat\",{\"1\":{\"330\":1}}],[\"这里创建了一个表\",{\"1\":{\"454\":1}}],[\"这里需要注意的是\",{\"1\":{\"433\":1}}],[\"这里扫描的行数是100万\",{\"1\":{\"407\":1}}],[\"这里的wrapsink方法如下\",{\"1\":{\"1623\":1}}],[\"这里的构造方法又调用了referencepipeline的构造方法\",{\"1\":{\"1622\":1}}],[\"这里的this表示的是当前集合的引用\",{\"1\":{\"1621\":1}}],[\"这里的transaction\",{\"1\":{\"468\":1}}],[\"这里的statelessop也是定义在referencepipeline当中的一个静态内部类\",{\"1\":{\"1622\":1}}],[\"这里的spliterator方法是定义collection接口当中的一个默认方法\",{\"1\":{\"1621\":1}}],[\"这里的suppressed就是压制的异常信息\",{\"1\":{\"1619\":1}}],[\"这里的session\",{\"1\":{\"448\":1}}],[\"这里的泛型s指的就是stream<t>\",{\"1\":{\"1619\":1}}],[\"这里的泛型t代表流中元素的类型\",{\"1\":{\"1619\":1}}],[\"这里的partition是用来定义分组结果的一个静态内部类\",{\"1\":{\"1618\":1}}],[\"这里的下游指的是\",{\"1\":{\"1618\":1}}],[\"这里的属性值是identity\",{\"1\":{\"1618\":1}}],[\"这里的第四个参数指的是\",{\"1\":{\"1618\":1}}],[\"这里的第四个参数是\",{\"1\":{\"1618\":1}}],[\"这里的第二个参数就是我们上面定义过的收集器\",{\"1\":{\"1615\":1}}],[\"这里的unaryoperator表示接收参数与返回结果类型相同的情况\",{\"1\":{\"1609\":1}}],[\"这里的map描述的是一种映射\",{\"1\":{\"1607\":1}}],[\"这里的副作用指的是可能会修改传入参数的值\",{\"1\":{\"1597\":1}}],[\"这里的foreach实际上表示一种终止操作\",{\"1\":{\"1593\":1}}],[\"这里的内部结构发生变化指的是强调的是结构发生变化\",{\"1\":{\"1546\":1}}],[\"这里的内存临时表起到了暂存数据的作用\",{\"1\":{\"414\":1}}],[\"这里的必要条件之一是读写\",{\"1\":{\"1526\":1}}],[\"这里的同步\",{\"1\":{\"1421\":1}}],[\"这里的底层实现都是xmlbeandefinitionreader\",{\"1\":{\"1021\":1}}],[\"这里的name就是jiyongchao\",{\"1\":{\"1019\":1}}],[\"这里的销毁并不是这个对象被gc掉了\",{\"1\":{\"1011\":1}}],[\"这里的返回值是null\",{\"1\":{\"1003\":1}}],[\"这里的beandefinitionmap的类型是map<string\",{\"1\":{\"996\":1}}],[\"这里的3是第四步中的query\",{\"1\":{\"431\":1}}],[\"这里的扫描行数是1000\",{\"1\":{\"407\":1}}],[\"这里的\",{\"1\":{\"390\":1,\"1593\":1,\"1618\":1}}],[\"这里的测试数据有10万行\",{\"1\":{\"366\":1}}],[\"这里name\",{\"1\":{\"376\":1}}],[\"这里实际上存在两个问题\",{\"1\":{\"347\":1}}],[\"这里\",{\"1\":{\"334\":1,\"345\":1,\"396\":1,\"404\":1}}],[\"这里以一个博客文章的内容为例\",{\"1\":{\"300\":1}}],[\"这就要求spring事务管理器中的datasource和jdbc\",{\"1\":{\"1655\":1}}],[\"这就要求在在定义collector的是偶\",{\"1\":{\"1617\":1}}],[\"这就实现了收集器的复合\",{\"1\":{\"1615\":1}}],[\"这就解决了hashmap中由于put数据引起的闭环问题\",{\"1\":{\"1553\":1}}],[\"这就会造成不必要的上下文切换\",{\"1\":{\"1510\":1}}],[\"这就会造成数据一致性的问题\",{\"1\":{\"1326\":1}}],[\"这就会导致切换慢的问题\",{\"1\":{\"478\":1}}],[\"这就会导致大量占用存储空间\",{\"1\":{\"434\":1}}],[\"这就需要人工干预\",{\"1\":{\"619\":1}}],[\"这就保证了\",{\"1\":{\"496\":1}}],[\"这就代表了如果主库上有数据被误删了\",{\"1\":{\"486\":1}}],[\"这就和redo\",{\"1\":{\"451\":1}}],[\"这就涉及到binlog\",{\"1\":{\"450\":1}}],[\"这就导致接下来的查询都在事务中\",{\"1\":{\"435\":1}}],[\"这就是双亲委托机制\",{\"1\":{\"1692\":1}}],[\"这就是所谓的静态链接过程\",{\"1\":{\"1663\":1}}],[\"这就是所谓的终止操作\",{\"1\":{\"1607\":1}}],[\"这就是因为我们的中间结果类型是set类型\",{\"1\":{\"1617\":1}}],[\"这就是操作系统真正意义上的零拷贝\",{\"1\":{\"1583\":1}}],[\"这就是典型一对一答模型\",{\"1\":{\"1573\":1}}],[\"这就是为什么说java的线程比较重的原因\",{\"1\":{\"1477\":1}}],[\"这就是为什么我们可以在rc级别下的事务中可以看到别的事务提交的更新的原因\",{\"1\":{\"542\":1}}],[\"这就是锁的粗化\",{\"1\":{\"1393\":1}}],[\"这就是锁的消除\",{\"1\":{\"1393\":1}}],[\"这就是缓存被击穿\",{\"1\":{\"629\":1}}],[\"这就是我们之前所说的槽\",{\"1\":{\"1480\":1}}],[\"这就是我们预期的结果\",{\"1\":{\"480\":1}}],[\"这就是我们为什么要设置innodb\",{\"1\":{\"476\":1}}],[\"这就是等主库位点方案\",{\"1\":{\"472\":1}}],[\"这就是一种比较典型的大事务的场景\",{\"1\":{\"457\":1}}],[\"这就是最终以执行\",{\"1\":{\"456\":1}}],[\"这就是两阶段锁协议\",{\"1\":{\"443\":1}}],[\"这就是这个命令会什么会出现在binlog的原因\",{\"1\":{\"413\":1}}],[\"这就是bka算法\",{\"1\":{\"405\":1}}],[\"这就是mrr优化的设计思路\",{\"1\":{\"404\":1}}],[\"这就是使用前缀索引的优势\",{\"1\":{\"350\":1}}],[\"这就是\",{\"1\":{\"326\":1,\"1519\":1}}],[\"这就意味着集合中不能出现重复的数据\",{\"1\":{\"572\":1}}],[\"这就意味着我们可以手动更新某个表或者索引的统计数据\",{\"1\":{\"559\":1}}],[\"这就意味着mysql的查询优化器为了计算这些单点区间的索引记录条数\",{\"1\":{\"553\":1}}],[\"这就意味着\",{\"1\":{\"318\":1,\"1203\":1}}],[\"这些也是面试的必考点\",{\"1\":{\"1992\":1}}],[\"这些都可以称之为类的元数据\",{\"1\":{\"1646\":1}}],[\"这些都是对于这几个基础的函数式接口的有力的补充\",{\"1\":{\"1601\":1}}],[\"这些都是共用的东西\",{\"1\":{\"645\":1}}],[\"这些都是当前读\",{\"1\":{\"541\":1}}],[\"这些参数就会使用包装类型\",{\"1\":{\"1620\":1}}],[\"这些参数总是一个函数式接口的实例\",{\"1\":{\"1619\":1}}],[\"这些可以被spliterator的客户端使用\",{\"1\":{\"1620\":1}}],[\"这些要求确保了由stream和parallelstream方法生成的流从终止流操作开始发起的时候就反应出流的内容\",{\"1\":{\"1620\":1}}],[\"这些特性值并不要求去报告\",{\"1\":{\"1620\":1}}],[\"这些行为参数都要满足下面的这些条件特性\",{\"1\":{\"1619\":1}}],[\"这些操作会被聚合起来应用到他们的元上面\",{\"1\":{\"1619\":1}}],[\"这些对象的线程安全性都是靠不可变性来保证的\",{\"1\":{\"1526\":1}}],[\"这些子任务将由forkjoinpool内部的工作线程来并行执行\",{\"1\":{\"1510\":1}}],[\"这些java内置的使用者看不到的锁被称为内置锁\",{\"1\":{\"1482\":1}}],[\"这些指令通常是跟特定的hotspot版本对应的\",{\"1\":{\"1453\":1}}],[\"这些是所有的hotspot都支持的参数\",{\"1\":{\"1453\":1}}],[\"这些垃圾就要留到下一次gc过程中清除\",{\"1\":{\"1447\":1}}],[\"这些内建的bean的初始化都是在annotationconfigutils中完成的\",{\"1\":{\"945\":1}}],[\"这些标识符在bean所在的容器必须是唯一的\",{\"1\":{\"928\":1}}],[\"这些请求都会击穿到db\",{\"1\":{\"629\":1}}],[\"这些微调的值是直接硬编码到代码里的\",{\"1\":{\"548\":1}}],[\"这些事务的修改对于当前事务都是不可见的\",{\"1\":{\"542\":1}}],[\"这些信息是恢复不出来数据的\",{\"1\":{\"485\":1}}],[\"这些信息可以用来精确定位刚刚被插入的那一行\",{\"1\":{\"454\":1}}],[\"这些数据最终存储在多个本地缓存中\",{\"1\":{\"1474\":1}}],[\"这些数据节点的分片就会处理该查询请求\",{\"1\":{\"1256\":1}}],[\"这些数据会恢复回来\",{\"1\":{\"459\":1}}],[\"这些数据结构以某种方式指向数据\",{\"1\":{\"331\":1}}],[\"这些redo\",{\"1\":{\"451\":1}}],[\"这些不同的方式按照效率排序\",{\"1\":{\"399\":1}}],[\"这些调用需要在内存操作\",{\"1\":{\"381\":1}}],[\"这些接口都是引擎中已经定义好的\",{\"1\":{\"322\":1}}],[\"这些资源会在连接断开的时候才释放\",{\"1\":{\"318\":1}}],[\"这是项目使用到的相关技术\",{\"1\":{\"1987\":1}}],[\"这是正常现象\",{\"1\":{\"1972\":1}}],[\"这是非常昂贵的操作\",{\"1\":{\"1664\":1}}],[\"这是流管道中的一个操作\",{\"1\":{\"1623\":1}}],[\"这是流的终止操作\",{\"1\":{\"1619\":1}}],[\"这是我们了解整个流调用机制的最后一个类\",{\"1\":{\"1622\":1}}],[\"这是为什么呢\",{\"1\":{\"1610\":1}}],[\"这是为了减少锁的次数\",{\"1\":{\"1503\":1}}],[\"这是为了提升查询效率\",{\"1\":{\"1270\":1}}],[\"这是当使用bifunction运算对象与结果类型相同时候的一个特例\",{\"1\":{\"1601\":1}}],[\"这是从jdk1\",{\"1\":{\"1599\":1}}],[\"这是与非函数式编程最大的区别\",{\"1\":{\"1598\":1}}],[\"这是与hashmap有区别的地方\",{\"1\":{\"1554\":1}}],[\"这是最传统的io模型\",{\"1\":{\"1563\":1}}],[\"这是最好的联接类型\",{\"1\":{\"330\":1}}],[\"这是早期jdk采用的方式\",{\"1\":{\"1437\":1}}],[\"这是一本不错的\",{\"1\":{\"1992\":1}}],[\"这是一本图文并茂的书籍\",{\"1\":{\"1992\":1}}],[\"这是一种最简单的并发处理网络请求的方法\",{\"1\":{\"1533\":1}}],[\"这是一些基本的配置属性\",{\"1\":{\"583\":1}}],[\"这是一条语法错误命令\",{\"1\":{\"580\":1}}],[\"这是一个执行流管道的辅助类\",{\"1\":{\"1623\":1}}],[\"这是一个终止操作\",{\"1\":{\"1623\":1}}],[\"这是一个工厂\",{\"1\":{\"1623\":1}}],[\"这是一个针对原生值设定的spliterator\",{\"1\":{\"1620\":1}}],[\"这是一个通过递归解耦得到的自然的结果\",{\"1\":{\"1620\":1}}],[\"这是一个中间操作\",{\"1\":{\"1619\":3}}],[\"这是一个关闭之前可能持有一些资源\",{\"1\":{\"1619\":1}}],[\"这是一个相对比较复杂的例子\",{\"1\":{\"1618\":1}}],[\"这是一个可选的操作\",{\"1\":{\"1615\":1}}],[\"这是一个函数式接口\",{\"1\":{\"1597\":1}}],[\"这是一个时间复杂度是o\",{\"1\":{\"444\":1}}],[\"这是一个多指查询\",{\"1\":{\"404\":1}}],[\"这是一个常量\",{\"1\":{\"378\":1}}],[\"这是一个需要权衡的决定\",{\"1\":{\"356\":1}}],[\"这是一个查询语句\",{\"1\":{\"320\":1}}],[\"这是kill无效的第一类情况\",{\"1\":{\"481\":1}}],[\"这是由于在主库上\",{\"1\":{\"460\":1}}],[\"这是由于tradeid字段类型是varchar\",{\"1\":{\"367\":1}}],[\"这是\",{\"1\":{\"454\":1,\"488\":1}}],[\"这是mysql根据当前要操作的表所在的数据库自行添加的\",{\"1\":{\"454\":1}}],[\"这是mysql中两个核心概念\",{\"1\":{\"323\":1}}],[\"这是rr隔离级别用的最多的锁\",{\"1\":{\"442\":1}}],[\"这是1个表\",{\"1\":{\"424\":1}}],[\"这是4个表\",{\"1\":{\"424\":2}}],[\"这是在mysql服务器层完成的\",{\"1\":{\"390\":1}}],[\"这是属于全值匹配的情况\",{\"1\":{\"370\":1,\"372\":1}}],[\"这是因为需要将stringbuilder转为string类型\",{\"1\":{\"1618\":1}}],[\"这是因为设置了concurrent特性\",{\"1\":{\"1617\":1}}],[\"这是因为调用顺序的原因\",{\"1\":{\"1615\":1}}],[\"这是因为stream也是属于一种描述性的语句\",{\"1\":{\"1611\":1}}],[\"这是因为我们限制了只取流中的前六个元素\",{\"1\":{\"1610\":1}}],[\"这是因为我们不需要创建一个独立的io线程来处理读写操作\",{\"1\":{\"1575\":1}}],[\"这是因为前面在不断的迭代产生0\",{\"1\":{\"1610\":1}}],[\"这是因为iterate他是无限的\",{\"1\":{\"1609\":1}}],[\"这是因为这个方法调用的地方在defaultlistablebeanfactory\",{\"1\":{\"1009\":1}}],[\"这是因为这两张表的字符集不同导致的\",{\"1\":{\"368\":1}}],[\"这是因为在abstractapplicationcontext\",{\"1\":{\"1005\":1}}],[\"这是因为user\",{\"1\":{\"978\":1}}],[\"这是因为对驱动表s1结果集中的每一条记录\",{\"1\":{\"555\":1}}],[\"这是因为此时的参数设置binlog\",{\"1\":{\"454\":1}}],[\"这是因为delete带limit\",{\"1\":{\"454\":1}}],[\"这是因为mysql设计了一个唯一数组的逻辑\",{\"1\":{\"498\":1}}],[\"这是因为mysql中使用了组提交\",{\"1\":{\"451\":1}}],[\"这是因为mysql在执行过程中临时使用的内存是管理在连接对象里面的\",{\"1\":{\"318\":1}}],[\"这是因为\",{\"1\":{\"413\":1,\"482\":1,\"485\":1,\"497\":1,\"1617\":1}}],[\"这是因为即使在同一个时刻的多个查询\",{\"1\":{\"396\":1}}],[\"这是因为如果使用的是innodb引擎的话\",{\"1\":{\"354\":1}}],[\"这是const类型的特例\",{\"1\":{\"330\":1}}],[\"这个项目作为spring\",{\"1\":{\"1987\":1}}],[\"这个论坛项目不仅实现了基本的注册\",{\"1\":{\"1987\":1}}],[\"这个作为学习的可选项\",{\"1\":{\"1986\":1}}],[\"这个跟早期jdk版本的\",{\"1\":{\"1664\":1}}],[\"这个代理对象就成为spring容器中的bean\",{\"1\":{\"1653\":1}}],[\"这个终止操作是无状态的\",{\"1\":{\"1623\":1}}],[\"这个实现会接收下游的sink\",{\"1\":{\"1623\":1}}],[\"这个实例执行过的所有事务\",{\"1\":{\"468\":1}}],[\"这个实例\",{\"1\":{\"467\":1}}],[\"这个构造方法完成的就是对于已经存在的管道追加一个中间操作\",{\"1\":{\"1622\":1}}],[\"这个管道在被调用之后\",{\"1\":{\"1622\":1}}],[\"这个action可能会在任意的时间或者库所选择的任意线程中去执行\",{\"1\":{\"1622\":1}}],[\"这个阶段要么描述的是流的源\",{\"1\":{\"1621\":1}}],[\"这个枚举是定义在collector这个接口当中的\",{\"1\":{\"1615\":1}}],[\"这个类到类加载器实例的引用\",{\"1\":{\"1663\":1}}],[\"这个类是给类库的编写者提供的\",{\"1\":{\"1621\":1}}],[\"这个类型必须是java\",{\"1\":{\"1620\":1}}],[\"这个类本身并没有做任何事情\",{\"1\":{\"1616\":1}}],[\"这个类本身就定义在string类当中\",{\"1\":{\"1614\":1}}],[\"这个类没有定义在一个单独的文件当中\",{\"1\":{\"1616\":1}}],[\"这个类继承myinterface1impl\",{\"1\":{\"1607\":1}}],[\"这个结果相当于下面这段代码\",{\"1\":{\"1608\":1}}],[\"这个单词本身的含义是双向的意思\",{\"1\":{\"1598\":1}}],[\"这个复合函数首先应用before这个function\",{\"1\":{\"1598\":1}}],[\"这个概念会贯穿整个函数式编程的全过程\",{\"1\":{\"1593\":1}}],[\"这个函数表示当前的predicate与另一个predicate的短路与\",{\"1\":{\"1599\":1}}],[\"这个函数返回的是一个复合函数\",{\"1\":{\"1598\":1}}],[\"这个函数总共接收三个参数\",{\"1\":{\"1593\":1}}],[\"这个函数得到校验码填到这个新字段\",{\"1\":{\"352\":1}}],[\"这个看似简单的操作\",{\"1\":{\"1580\":1}}],[\"这个名称\",{\"1\":{\"1561\":1}}],[\"这个设计非常的巧妙\",{\"1\":{\"1550\":1}}],[\"这个key的hashcode方法得到其哈希值\",{\"1\":{\"1546\":1}}],[\"这个公式的含义是\",{\"1\":{\"1510\":1}}],[\"这个对象甚至可能被其它线程访问到\",{\"1\":{\"1488\":1}}],[\"这个根据不同操作系统和不同cpu会有不同的实现\",{\"1\":{\"1479\":1}}],[\"这个五种状态分别是\",{\"1\":{\"1477\":1}}],[\"这个开销很大\",{\"1\":{\"1473\":1}}],[\"这个messagesid可以作为消费者判断幂等的依据\",{\"1\":{\"1329\":1}}],[\"这个问题主要分为两个方面\",{\"1\":{\"1328\":1}}],[\"这个问题的结论是\",{\"1\":{\"403\":1}}],[\"这个泥团又会膨胀成为大泥团\",{\"1\":{\"1309\":1}}],[\"这个节点就成为协调节点\",{\"1\":{\"1256\":1}}],[\"这个节点就会成为coordinating\",{\"1\":{\"1256\":1}}],[\"这个请求肯定是需要登录才可以正常访问的\",{\"1\":{\"1201\":1}}],[\"这个事件使用的很少\",{\"1\":{\"1118\":1}}],[\"这个事务内的所有数据操作要么同时成功\",{\"1\":{\"1262\":1}}],[\"这个事务是可见的\",{\"1\":{\"542\":1}}],[\"这个事务也不是只读事务\",{\"1\":{\"497\":1}}],[\"这个事务的xid也是a\",{\"1\":{\"496\":1}}],[\"这个事务的哈希表就有三个项\",{\"1\":{\"462\":1}}],[\"这个事务的binlog是从8900这个位置开始的\",{\"1\":{\"454\":1}}],[\"这个事务修改的行涉及到表t1和t3\",{\"1\":{\"461\":1}}],[\"这个事务将持续存在直到主动执行commit或rollback语句\",{\"1\":{\"435\":1}}],[\"这个事务就启动了\",{\"1\":{\"435\":1}}],[\"这个渠道能够帮助我们去部署和管理一些细粒度的对象\",{\"1\":{\"910\":1}}],[\"这个解决方案的思想是\",{\"1\":{\"633\":1}}],[\"这个思想的含义是\",{\"1\":{\"633\":1}}],[\"这个脚本应该是通用的\",{\"1\":{\"624\":1}}],[\"这个脚本将会被调用\",{\"1\":{\"624\":1}}],[\"这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行\",{\"1\":{\"624\":1}}],[\"这个字典就用于保存订阅频道的信息\",{\"1\":{\"599\":1}}],[\"这个消息就会被发送给订阅它的三个客户端\",{\"1\":{\"596\":1}}],[\"这个消耗跟额外这个哈希字段也差不多抵消了\",{\"1\":{\"352\":1}}],[\"这个最后一次修改的数据就没有了\",{\"1\":{\"590\":1}}],[\"这个最左前缀可以是联合索引的最左n个字段\",{\"1\":{\"339\":1}}],[\"这个变量表示当前最小的连接查询成本\",{\"1\":{\"556\":1}}],[\"这个属性值也成功的被修改了\",{\"1\":{\"1003\":1}}],[\"这个属性本身是一个object类型的\",{\"1\":{\"998\":1}}],[\"这个属性我们暂时不了解\",{\"1\":{\"553\":1}}],[\"这个属性表示的就是那个n值\",{\"1\":{\"553\":1}}],[\"这个条件的第一条记录\",{\"1\":{\"549\":1}}],[\"这个条件访问id\",{\"1\":{\"549\":1}}],[\"这个范围区间内包含多少二级索引记录\",{\"1\":{\"549\":1}}],[\"这个选项表示表占用的存储空间字节数\",{\"1\":{\"548\":1}}],[\"这个选项表示表中的记录条数\",{\"1\":{\"548\":1}}],[\"这个选择并不是最优的\",{\"1\":{\"347\":1}}],[\"这个搜索条件的索引列由于没有和常数比较\",{\"1\":{\"547\":1}}],[\"这个搜索条件可以使用二级索引idx\",{\"1\":{\"547\":2}}],[\"这个成本最低的方案就是所谓的执行计划\",{\"1\":{\"546\":1}}],[\"这个成本比较高\",{\"1\":{\"462\":1}}],[\"这个功能可以让我们方便的查看优化器执行计划的整个过程\",{\"1\":{\"544\":1}}],[\"这个功能是mysql5\",{\"1\":{\"486\":1}}],[\"这个视图由执行查询时所有未提交事务id数组\",{\"1\":{\"542\":1}}],[\"这个视图是在每个sql语句开始执行的时候创建的\",{\"1\":{\"433\":1}}],[\"这个视图是在事务启动时创建的\",{\"1\":{\"433\":1}}],[\"这个read\",{\"1\":{\"542\":1}}],[\"这个rowid就是由系统生成的\",{\"1\":{\"420\":1}}],[\"这个rowid就是主键id\",{\"1\":{\"420\":1}}],[\"这个年限自然也就更短了\",{\"1\":{\"497\":1}}],[\"这个beanfactory的功能已经很全面了\",{\"1\":{\"1636\":1}}],[\"这个bean创建过程就完成了\",{\"1\":{\"1234\":1}}],[\"这个bug是只要mysql实例服务时间够长\",{\"1\":{\"497\":1}}],[\"这个bug仍然存在\",{\"1\":{\"497\":1}}],[\"这个binlog在从库执行或者用来恢复临时实例\",{\"1\":{\"492\":1}}],[\"这个自增值得上限是264\",{\"1\":{\"496\":1}}],[\"这个不连续的id\",{\"1\":{\"492\":1}}],[\"这个库就发生了数据不一致\",{\"1\":{\"492\":1}}],[\"这个库的线程很快就会爆满\",{\"1\":{\"441\":1}}],[\"这个锁会等执行结束以后才释放\",{\"1\":{\"492\":1}}],[\"这个恢复时间可能是要按天来计算的\",{\"1\":{\"486\":1}}],[\"这个流程的示意图如下\",{\"1\":{\"485\":1}}],[\"这个线程的状态仍然是在等待中\",{\"1\":{\"481\":1}}],[\"这个等待状态可以被唤醒\",{\"1\":{\"481\":1}}],[\"这个等待时间往往是无法接受的\",{\"1\":{\"444\":1}}],[\"这个sleep方案确实解决了类似场景下的过期读问题\",{\"1\":{\"471\":1}}],[\"这个gtid有两种生成方式\",{\"1\":{\"468\":1}}],[\"这个逻辑里面包含了一个设计思想\",{\"1\":{\"468\":1}}],[\"这个逻辑\",{\"1\":{\"467\":1}}],[\"这个哈希值是通过\",{\"1\":{\"465\":1}}],[\"这个参数的值被设置为2时\",{\"1\":{\"492\":1}}],[\"这个参数的值被设置为1时\",{\"1\":{\"492\":1}}],[\"这个参数的值被设置为0时\",{\"1\":{\"492\":1}}],[\"这个参数的可选值有以下三种\",{\"1\":{\"465\":1}}],[\"这个参数设置为50的时候\",{\"1\":{\"343\":1}}],[\"这个目标\",{\"1\":{\"464\":1}}],[\"这个策略用于低延时的场合\",{\"1\":{\"1520\":1}}],[\"这个策略仍然是一个令人感到惊艳的创新\",{\"1\":{\"464\":1}}],[\"这个策略与其他策略不同的地方在于\",{\"1\":{\"464\":1}}],[\"这个策略就没有效果了\",{\"1\":{\"463\":1}}],[\"这个策略有两个优势\",{\"1\":{\"463\":1}}],[\"这个策略是在innodb内部自己管理打开分区的行为\",{\"1\":{\"425\":1}}],[\"这个模式要求binlog的格式必须是row\",{\"1\":{\"462\":1}}],[\"这个按表分发的方案\",{\"1\":{\"461\":1}}],[\"这个切换流程的代价\",{\"1\":{\"459\":1}}],[\"这个切换流程\",{\"1\":{\"459\":1}}],[\"这个切换流程中是有不可用时间的\",{\"1\":{\"458\":1}}],[\"这个切换过程就称为可靠性优先策略\",{\"1\":{\"458\":1}}],[\"这个insert语句插入的行\",{\"1\":{\"454\":1}}],[\"这个位置包含文件名和日志偏移量\",{\"1\":{\"453\":1}}],[\"这个组里面已经有了三个事务\",{\"1\":{\"451\":1}}],[\"这个操作并不会保证它会遵循流当中元素的顺序\",{\"1\":{\"1622\":1}}],[\"这个操作的行为是不确定的\",{\"1\":{\"1622\":1}}],[\"这个操作序列复现了一个自增主键id不连续的情况\",{\"1\":{\"491\":1}}],[\"这个操作\",{\"1\":{\"448\":1}}],[\"这个操作会稍微复杂一些\",{\"1\":{\"342\":1}}],[\"这个并发控制要做在数据库服务端\",{\"1\":{\"444\":1}}],[\"这个超时时间可以通过参数innodb\",{\"1\":{\"444\":1}}],[\"这个业务需要涉及以下的操作\",{\"1\":{\"443\":1}}],[\"这个文件不存在的话\",{\"1\":{\"428\":1}}],[\"这个是针对于管道源的有过优化的实现\",{\"1\":{\"1622\":1}}],[\"这个是磁盘扫描\",{\"1\":{\"525\":1}}],[\"这个是脏读\",{\"1\":{\"497\":1}}],[\"这个是设置慢查询的时间\",{\"1\":{\"428\":1}}],[\"这个是由参数long\",{\"1\":{\"428\":1}}],[\"这个是存储慢查询的日志文件\",{\"1\":{\"428\":1}}],[\"这个是开启慢查询\",{\"1\":{\"428\":1}}],[\"这个是符合预期的\",{\"1\":{\"421\":1}}],[\"这个语法删掉分区\",{\"1\":{\"426\":1}}],[\"这个语句是执行两个表的join\",{\"1\":{\"514\":1}}],[\"这个语句第二次申请自增id\",{\"1\":{\"492\":1}}],[\"这个语句真正执行的时候\",{\"1\":{\"491\":1}}],[\"这个语句序列\",{\"1\":{\"447\":1}}],[\"这个语句涉及的数据量很大\",{\"1\":{\"418\":1}}],[\"这个语句的操作时直接删除分区文件\",{\"1\":{\"426\":1}}],[\"这个语句的逻辑是把表t1里的数据\",{\"1\":{\"416\":1}}],[\"这个语句的执行方法就确定下来了\",{\"1\":{\"514\":1}}],[\"这个语句的执行方案就确定下来了\",{\"1\":{\"321\":1}}],[\"这个语句的执行速度越来越慢\",{\"1\":{\"419\":1}}],[\"这个语句的执行没有再使用临时表\",{\"1\":{\"418\":1}}],[\"这个语句的执行流程如下\",{\"1\":{\"414\":1,\"416\":1}}],[\"这个语句的执行将会非常耗时\",{\"1\":{\"402\":1}}],[\"这个语句里trade\",{\"1\":{\"368\":1}}],[\"这个语句只要求返回id和email字段\",{\"1\":{\"351\":1}}],[\"这个语句也需要同步修改\",{\"1\":{\"348\":1}}],[\"这个语句在搜索索引树的时候\",{\"1\":{\"340\":1}}],[\"这个语句就执行完成了\",{\"1\":{\"322\":1}}],[\"这个分区表并没有实质的差别\",{\"1\":{\"424\":1}}],[\"这个例子中的\",{\"1\":{\"1602\":1}}],[\"这个例子中事务b的update语句会被阻塞\",{\"1\":{\"443\":1}}],[\"这个例子中由于临时表只有10行\",{\"1\":{\"416\":1}}],[\"这个例子里面\",{\"1\":{\"420\":1}}],[\"这个临时表使用的是memory引擎\",{\"1\":{\"420\":1}}],[\"这个临时表只有一个整型字段f\",{\"1\":{\"414\":1}}],[\"这个临时库就会少了这一次更新\",{\"1\":{\"327\":1}}],[\"这个命令需要慎重使用\",{\"1\":{\"567\":1}}],[\"这个命令就还没有在这个延迟复制的备库执行\",{\"1\":{\"486\":1}}],[\"这个命令很快也会被发给所有从库\",{\"1\":{\"486\":1}}],[\"这个命令正常返回的结果是一个正整数m\",{\"1\":{\"473\":1}}],[\"这个命令的意思是\",{\"1\":{\"454\":1}}],[\"这个命令的输出结果也有一个table\",{\"1\":{\"396\":1}}],[\"这个命令会将这个线程的自动提交关掉\",{\"1\":{\"435\":1}}],[\"这个命令\",{\"1\":{\"413\":1,\"481\":1}}],[\"这个进程的进程号是4d2\",{\"1\":{\"412\":1}}],[\"这个frm文件放在临时文件目录下\",{\"1\":{\"412\":1}}],[\"这个方案要求线上有定期的全量备份\",{\"1\":{\"485\":1}}],[\"这个方案的假设是\",{\"1\":{\"471\":1}}],[\"这个方案的做法是\",{\"1\":{\"471\":1}}],[\"这个方案的缺点也很明显\",{\"1\":{\"411\":1}}],[\"这个方案最大的问题在于\",{\"1\":{\"470\":1}}],[\"这个方案很容易被大事务拖后腿\",{\"1\":{\"464\":1}}],[\"这个方法中就产生一个mapper接口代理对象\",{\"1\":{\"1653\":1}}],[\"这个方法中会注入一些bean\",{\"1\":{\"973\":1}}],[\"这个方法就是对流中的中间操作进行串联的方法\",{\"1\":{\"1623\":1}}],[\"这个方法在abstractpipeline中有唯一的实现\",{\"1\":{\"1623\":1}}],[\"这个方法实际上在referencepipeline中是有两个实现的\",{\"1\":{\"1622\":1}}],[\"这个方法有可能会返回一个空值\",{\"1\":{\"1620\":1}}],[\"这个方法接口两个参数并且有返回值\",{\"1\":{\"1614\":1}}],[\"这个方法对于给定的输入元素进行了排序的操作\",{\"1\":{\"1613\":1}}],[\"这个方法本身是一个function的函数式接口\",{\"1\":{\"1613\":1}}],[\"这个方法返回无限的\",{\"1\":{\"1609\":1}}],[\"这个方法我们也可以用方法引用来完成\",{\"1\":{\"1608\":1}}],[\"这个方法刚好是反过来的\",{\"1\":{\"1598\":1}}],[\"这个方法其实是将两个function进行了组合\",{\"1\":{\"1598\":1}}],[\"这个方法将返回了一个新的对象stream\",{\"1\":{\"1593\":1}}],[\"这个方法非常巧妙\",{\"1\":{\"1548\":1}}],[\"这个方法会统计流中元素的个数\",{\"1\":{\"1613\":1}}],[\"这个方法会把相关的信息赋值给beandefinition\",{\"1\":{\"1027\":1}}],[\"这个方法会在set方法执行之前就执行\",{\"1\":{\"964\":1}}],[\"这个方法不会被调用\",{\"1\":{\"1003\":1}}],[\"这个方法的文档如下\",{\"1\":{\"1613\":1}}],[\"这个方法的作用就是可以修改从配置文件里面读入的值\",{\"1\":{\"1003\":1}}],[\"这个方法的问题是锁的粒度太大\",{\"1\":{\"491\":1}}],[\"这个方法的成本很高\",{\"1\":{\"491\":1}}],[\"这个方法的效率很高\",{\"1\":{\"422\":1}}],[\"这个方法是计算逻辑或的操作\",{\"1\":{\"1599\":1}}],[\"这个方法是基于\",{\"1\":{\"451\":1}}],[\"这个方法是通过查看optimizer\",{\"1\":{\"354\":1}}],[\"这个方法效率不够好\",{\"1\":{\"355\":1}}],[\"这个优化效果还是很明显的\",{\"1\":{\"407\":1}}],[\"这个判断的工作量很大\",{\"1\":{\"407\":1}}],[\"这个算法并不严格满足题目的随机要求\",{\"1\":{\"422\":1}}],[\"这个算法其实就是对nlj算法的优化\",{\"1\":{\"405\":1}}],[\"这个算法会将t1表的内容放入到join\",{\"1\":{\"403\":1}}],[\"这个值可以大于1\",{\"1\":{\"1546\":1}}],[\"这个值高达百分之九十八\",{\"1\":{\"1434\":1}}],[\"这个值的默认值是20\",{\"1\":{\"558\":1}}],[\"这个值的时间精度是秒\",{\"1\":{\"457\":1}}],[\"这个值也是一个估计值\",{\"1\":{\"558\":2}}],[\"这个值是估计值\",{\"1\":{\"558\":1}}],[\"这个值如果为0代表全部使用的sort\",{\"1\":{\"520\":1}}],[\"这个值还是逻辑上不精确的\",{\"1\":{\"397\":1}}],[\"这个值就是在执行器每次调用引擎获取数据行的时候累加的\",{\"1\":{\"322\":1}}],[\"这个指标可能还不够完美\",{\"1\":{\"389\":1}}],[\"这个步骤用上了主键索引\",{\"1\":{\"368\":1}}],[\"这个动作\",{\"1\":{\"354\":1}}],[\"这个索引的效率就越高\",{\"1\":{\"359\":1}}],[\"这个索引的区分度就非常低了\",{\"1\":{\"352\":1}}],[\"这个索引的区分度就越好\",{\"1\":{\"347\":1}}],[\"这个索引结构中每个邮箱的字段都只取6个字节\",{\"1\":{\"350\":1}}],[\"这个基数都是很容易不准的\",{\"1\":{\"347\":1}}],[\"这个基数越大\",{\"1\":{\"347\":1}}],[\"这个统计信息就是索引的\",{\"1\":{\"347\":1}}],[\"这个数字越小\",{\"1\":{\"624\":1}}],[\"这个数据页才会被读入内存\",{\"1\":{\"345\":1}}],[\"这个数组就是按照身份证号递增的顺序保存的\",{\"1\":{\"333\":1}}],[\"这个信息\",{\"1\":{\"345\":1}}],[\"这个记录要更新的目标在内存中\",{\"1\":{\"343\":1}}],[\"这个记录\",{\"1\":{\"343\":1}}],[\"这个查询用到的索引就是idx\",{\"1\":{\"553\":1}}],[\"这个查询只能在联合索引里匹配到名字是\",{\"1\":{\"518\":1}}],[\"这个查询需要读取几千行数据\",{\"1\":{\"390\":1}}],[\"这个查询将返回10行数据\",{\"1\":{\"390\":1}}],[\"这个查询过程不需要临时表\",{\"1\":{\"356\":1}}],[\"这个查询过程读了k索引树的3条记录\",{\"1\":{\"337\":1}}],[\"这个查询没有符合条件的记录\",{\"1\":{\"347\":1}}],[\"这个查询语句在索引树上的查找的过程\",{\"1\":{\"342\":1}}],[\"这个联合索引本身有序\",{\"1\":{\"356\":1}}],[\"这个联合索引的\",{\"1\":{\"339\":1}}],[\"这个联合索引来分析\",{\"1\":{\"339\":1}}],[\"这个过程被称之为零拷贝\",{\"1\":{\"1576\":1}}],[\"这个过程需要等待\",{\"1\":{\"1563\":1}}],[\"这个过程需要扫描100行\",{\"1\":{\"401\":1}}],[\"这个过程存在很大的开销\",{\"1\":{\"1519\":1}}],[\"这个过程会消耗一定的性能\",{\"1\":{\"1485\":1}}],[\"这个过程可能会很慢\",{\"1\":{\"559\":1}}],[\"这个过程可能会使用到索引\",{\"1\":{\"554\":1}}],[\"这个过程总结一下就是这样\",{\"1\":{\"546\":1}}],[\"这个过程的性能消耗也可以忽略不计的\",{\"1\":{\"549\":1}}],[\"这个过程的流程图如下\",{\"1\":{\"473\":1}}],[\"这个过程的示意图如下\",{\"1\":{\"414\":1,\"485\":1}}],[\"这个过程不需要临时文件\",{\"1\":{\"421\":1}}],[\"这个过程不需要重连和重新做权限验证\",{\"1\":{\"318\":1}}],[\"这个过程中数据是可以正常更新的\",{\"1\":{\"438\":1}}],[\"这个过程中\",{\"1\":{\"420\":1}}],[\"这个过程没有涉及到表操作\",{\"1\":{\"420\":1}}],[\"这个过程要对内存临时表做全表扫描\",{\"1\":{\"420\":1}}],[\"这个过程就跟我们写程序时的嵌套查询类似\",{\"1\":{\"401\":1}}],[\"这个过程就称为全字段排序\",{\"1\":{\"354\":1}}],[\"这个过程是很耗时的\",{\"1\":{\"1527\":1}}],[\"这个过程是同步的\",{\"1\":{\"559\":1}}],[\"这个过程是现遍历表t1\",{\"1\":{\"401\":1}}],[\"这个过程是通过遍历主键索引的方式\",{\"1\":{\"368\":1}}],[\"这个过程称为页分裂\",{\"1\":{\"335\":1}}],[\"这个过程称为回表\",{\"1\":{\"335\":1}}],[\"这个表的auto\",{\"1\":{\"494\":1}}],[\"这个表的自增值改成3\",{\"1\":{\"491\":1}}],[\"这个表的建表语句是\",{\"1\":{\"335\":1}}],[\"这个表会被从哈希表中去掉\",{\"1\":{\"461\":1}}],[\"这个表定义了一个字增逐渐id\",{\"1\":{\"459\":1}}],[\"这个表包含了一个\",{\"1\":{\"424\":1}}],[\"这个表没有建索引\",{\"1\":{\"420\":1}}],[\"这个表只有1000行\",{\"1\":{\"407\":1}}],[\"这个表每被插入一行redis计数就加1\",{\"1\":{\"397\":1}}],[\"这个表上的查询缓存都会被清空\",{\"1\":{\"319\":1}}],[\"这个n差不多是1200\",{\"1\":{\"334\":1}}],[\"这个区间的所有用户\",{\"1\":{\"332\":1}}],[\"这个也可以忽略不计\",{\"1\":{\"330\":1}}],[\"这个\",{\"1\":{\"327\":1,\"462\":1,\"482\":1}}],[\"这个日志\",{\"1\":{\"327\":1}}],[\"这个能力称为crash\",{\"1\":{\"324\":1}}],[\"这个接口是从jdk1\",{\"1\":{\"1597\":1}}],[\"这个接口中的抽象方法\",{\"1\":{\"1595\":1}}],[\"这个接口中唯一的抽象方法test\",{\"1\":{\"1595\":2}}],[\"这个接口中有两个抽象方法\",{\"1\":{\"1595\":1}}],[\"这个接口中看起来有两个抽象方法\",{\"1\":{\"1594\":1}}],[\"这个接口中只有一个抽象方法test\",{\"1\":{\"1594\":1}}],[\"这个接口\",{\"1\":{\"322\":2}}],[\"这个时间复杂度是o\",{\"1\":{\"334\":1}}],[\"这个时间是由参数wait\",{\"1\":{\"318\":1}}],[\"这个时候元就有一些风险\",{\"1\":{\"1620\":1}}],[\"这个时候如果再设置concurrent特性\",{\"1\":{\"1617\":1}}],[\"这个时候如果删除id=10的行\",{\"1\":{\"490\":1}}],[\"这个时候也要去掉identity\",{\"1\":{\"1617\":1}}],[\"这个时候我们再来分析一个这四个方法对应的泛型\",{\"1\":{\"1615\":1}}],[\"这个时候调用当前类的mymethod\",{\"1\":{\"1607\":1}}],[\"这个时候kernel就要等待足够的数据到来\",{\"1\":{\"1563\":1}}],[\"这个时候对象只会经历初始化的过程\",{\"1\":{\"987\":1}}],[\"这个时候在返回的时候就会进行判断\",{\"1\":{\"963\":1}}],[\"这个时候在备库上执行stop\",{\"1\":{\"486\":1}}],[\"这个时候这个集合元素也增加了\",{\"1\":{\"961\":1}}],[\"这个时候能不能选择出来一个老大呢\",{\"1\":{\"611\":1}}],[\"这个时候就变成了接收一个参数\",{\"1\":{\"1606\":1}}],[\"这个时候就发生了哈希碰撞\",{\"1\":{\"1546\":1}}],[\"这个时候就需要对引用的概念进行扩充\",{\"1\":{\"1435\":1}}],[\"这个时候就会导致事务执行失败\",{\"1\":{\"581\":1}}],[\"这个时候就可以考虑使用临时表\",{\"1\":{\"407\":1}}],[\"这个时候另外一个线程的事务b提交\",{\"1\":{\"451\":1}}],[\"这个时候只kill掉可能未必管用了\",{\"1\":{\"441\":1}}],[\"这个时候的$r4\",{\"1\":{\"368\":1}}],[\"这个时候不得不维护另一个索引\",{\"1\":{\"339\":1}}],[\"这个时候\",{\"1\":{\"327\":1,\"355\":1,\"411\":1,\"412\":1,\"416\":1,\"426\":1,\"438\":1,\"462\":1,\"467\":1,\"478\":1,\"1553\":1,\"1605\":1,\"1607\":2,\"1650\":1}}],[\"这个时候binlog里面就没有记录这个语句\",{\"1\":{\"327\":1}}],[\"这个时候更新就算完成了\",{\"1\":{\"324\":1}}],[\"这个时候用的就是你输入的用户名和密码\",{\"1\":{\"318\":1}}],[\"这个连接就处于空闲状态\",{\"1\":{\"318\":1}}],[\"这个连接里面的权限判断逻辑\",{\"1\":{\"318\":1}}],[\"这样比较老的技术\",{\"1\":{\"1978\":1}}],[\"这样便可以防止核心api库被随意篡改\",{\"1\":{\"1663\":1}}],[\"这样产生的bean不会经过spring的生命周期步骤\",{\"1\":{\"1644\":1}}],[\"这样调用完之后就可以重用了\",{\"1\":{\"1623\":1}}],[\"这样并行计算的时候工作量是比较平均的\",{\"1\":{\"1620\":1}}],[\"这样我们就不需要针对于原生类型的特化版本\",{\"1\":{\"1623\":1}}],[\"这样我们就在控制台打印了3到7\",{\"1\":{\"1607\":1}}],[\"这样我们就可以得到一个json格式的执行计划\",{\"1\":{\"553\":1}}],[\"这样先放一个索引上的元素会被放到entry链的尾部\",{\"1\":{\"1550\":1}}],[\"这样以后就不会扩容了\",{\"1\":{\"1550\":1}}],[\"这样能在多线程情况下避免争用\",{\"1\":{\"1402\":1}}],[\"这样数据安全性得到提高\",{\"1\":{\"1328\":1}}],[\"这样缓存中的值就会被覆盖为修改前的脏数据\",{\"1\":{\"1286\":1}}],[\"这样怎么查\",{\"1\":{\"1270\":1}}],[\"这样查询速度就可以更快\",{\"1\":{\"1268\":1}}],[\"这样资源服务器就不再需要发送求请给授权服务器去检查令牌了\",{\"1\":{\"1203\":1}}],[\"这样部分可能大量访问的数据就会加载到缓存中\",{\"1\":{\"633\":1}}],[\"这样所有连接redis实例的客户端都要提供密码\",{\"1\":{\"624\":1}}],[\"这样从节点就可以起到两个作用\",{\"1\":{\"621\":1}}],[\"这样执行以后从机会独立出来成为一个主机\",{\"1\":{\"611\":1}}],[\"这样执行的时候\",{\"1\":{\"414\":1}}],[\"这样使用起来代码效率低下\",{\"1\":{\"584\":1}}],[\"这样设置以后你能get到的值是\",{\"1\":{\"578\":1}}],[\"这样设计的原因是\",{\"1\":{\"309\":1}}],[\"这样一台挂掉之后其他的还可以继续工作\",{\"1\":{\"633\":1}}],[\"这样一旦开发出更优秀的内部编码\",{\"1\":{\"569\":1}}],[\"这样一来\",{\"1\":{\"352\":1,\"583\":1}}],[\"这样redis会在合适的场景选择合适的内部编码\",{\"1\":{\"569\":1}}],[\"这样之后回滚时再把由这些内容组成的记录插入到表中就好了\",{\"1\":{\"542\":1}}],[\"这样之后回滚时再把这条记录更新为旧值就好了\",{\"1\":{\"542\":1}}],[\"这样其他session只能读这行数据\",{\"1\":{\"537\":1}}],[\"这样排序后就会直接从内存里返回查询结果了\",{\"1\":{\"520\":1}}],[\"这样排序后就会直接从内存里面返回查询结果了\",{\"1\":{\"356\":1}}],[\"这样写到数据表中只放了最后6个字节\",{\"1\":{\"495\":1}}],[\"这样写数据成本相对较高\",{\"1\":{\"335\":1}}],[\"这样依赖\",{\"1\":{\"484\":1}}],[\"这样线程1不能提交事务\",{\"1\":{\"476\":1}}],[\"这样等gtid的方案就可以减少一次查询\",{\"1\":{\"474\":1}}],[\"这样带来的问题是\",{\"1\":{\"473\":1}}],[\"这样被加入从库的gtid集合的\",{\"1\":{\"468\":1}}],[\"这样中间碰到这两个错误时就直接跳过\",{\"1\":{\"467\":1}}],[\"这样得到的$master\",{\"1\":{\"467\":1}}],[\"这样系统的吞吐量就不够\",{\"1\":{\"464\":1}}],[\"这样需要特地异动数据\",{\"1\":{\"463\":1}}],[\"这样冲突检测就不准备\",{\"1\":{\"462\":1}}],[\"这样corrdinator会发现跟事务t冲突的worker只有worker\",{\"1\":{\"461\":1}}],[\"这样binlog传到备库去的时候\",{\"1\":{\"454\":1}}],[\"这样也可以减少iops的消耗\",{\"1\":{\"451\":1}}],[\"这样也可以将服务器上原本一次性的压力分散到一个很长的时间段中\",{\"1\":{\"393\":1}}],[\"这样看起来\",{\"1\":{\"447\":1,\"1595\":1}}],[\"这样每次冲突概率变成原来的1\",{\"1\":{\"444\":1}}],[\"这样每次要给影院账户加金额的时候\",{\"1\":{\"444\":1}}],[\"这样在未达到最大线程数的时候\",{\"1\":{\"1689\":1}}],[\"这样在并发的情况下\",{\"1\":{\"1615\":1}}],[\"这样在使用java8的好处也仅仅停留在jvm带来的性能上的提升\",{\"1\":{\"1591\":1}}],[\"这样在用户空间和内核空间的copy只需要一次\",{\"1\":{\"1571\":1}}],[\"这样在备库执行的时候\",{\"1\":{\"465\":1}}],[\"这样在切换的时候就不用再修改主备关系\",{\"1\":{\"455\":1}}],[\"这样在innodb内部就不会有大量的死锁检测工作了\",{\"1\":{\"444\":1}}],[\"这样在排序过程中一次可以排序更多行\",{\"1\":{\"356\":1}}],[\"这样当单例池中找不到依赖的属性时\",{\"1\":{\"1237\":1}}],[\"这样当出现死锁的时候\",{\"1\":{\"444\":1}}],[\"这样当我们去搜索某个关键词时\",{\"1\":{\"308\":1}}],[\"这样可以不关心修改过几次\",{\"1\":{\"1479\":1}}],[\"这样可以从根本上解决数据量过大造成的查询效率低的问题\",{\"1\":{\"1270\":1}}],[\"这样可以确保在注入时\",{\"1\":{\"912\":1}}],[\"这样可以基于一个socket连接同时发送多个dubbo请求\",{\"1\":{\"637\":1}}],[\"这样可以极大的减少需要分析的连接顺序的数量\",{\"1\":{\"556\":1}}],[\"这样可以保持节点b和a的数据是相同的\",{\"1\":{\"453\":1}}],[\"这样可以最大程度减少事务之间的锁等待\",{\"1\":{\"443\":1}}],[\"这样可能要扫描被驱动表很多次\",{\"1\":{\"403\":1}}],[\"这样会把这些类全部加载进jvm\",{\"1\":{\"1646\":1}}],[\"这样会导致整库长时间处于不可写状态\",{\"1\":{\"438\":1}}],[\"这样会影响我们分析sql语句的执行过程\",{\"1\":{\"401\":1}}],[\"这样既省去了再次执行begin语句的开销\",{\"1\":{\"435\":1}}],[\"这样返回结果里有100行数据\",{\"1\":{\"416\":1}}],[\"这样只需要100万次的哈希查找\",{\"1\":{\"408\":1}}],[\"这样对锁的要求就十分高\",{\"1\":{\"630\":1}}],[\"这样对后端维护团队的要求会更高\",{\"1\":{\"469\":1}}],[\"这样对于id=0这一行\",{\"1\":{\"447\":1}}],[\"这样对于默认的sql语句都不使用查询缓存\",{\"1\":{\"319\":1}}],[\"这样对buffer\",{\"1\":{\"406\":1}}],[\"这样通过排序以后\",{\"1\":{\"404\":1}}],[\"这样优化器只会按照我们指定的方式去join\",{\"1\":{\"401\":1}}],[\"这样的模板引擎所替代\",{\"1\":{\"1978\":1}}],[\"这样的代码我们应该已经掌握的非常的熟练了\",{\"1\":{\"1615\":1}}],[\"这样的一个参数\",{\"1\":{\"1593\":1}}],[\"这样的数字\",{\"1\":{\"558\":1}}],[\"这样的优化策略并不实用\",{\"1\":{\"522\":1}}],[\"这样的话在工作队列中等待的任务就会减少\",{\"1\":{\"1510\":1}}],[\"这样的话就得到了一个最多只需要追加1个小时\",{\"1\":{\"486\":1}}],[\"这样的话\",{\"1\":{\"470\":1,\"1502\":1}}],[\"这样的操作\",{\"1\":{\"396\":1}}],[\"这样的场景有很多\",{\"1\":{\"394\":1}}],[\"这样的重构可能会减少网络和内存的消耗\",{\"1\":{\"394\":1}}],[\"这样做有一个缺陷\",{\"1\":{\"627\":1}}],[\"这样做性能损耗很大\",{\"1\":{\"553\":1}}],[\"这样做可以减少事务视图里面活跃事务数组的大小\",{\"1\":{\"497\":1}}],[\"这样做可以保证日志传到备库去执行的时候\",{\"1\":{\"454\":1}}],[\"这样做也可以用上并行复制技术\",{\"1\":{\"485\":1}}],[\"这样做\",{\"1\":{\"453\":1,\"454\":1,\"492\":1}}],[\"这样做相当于在应用中实现了哈希关联\",{\"1\":{\"394\":1}}],[\"这样做的好处是使用者无需关心内部转换细节\",{\"1\":{\"1640\":1}}],[\"这样做的好处是元素的分布会相对来说比较均匀\",{\"1\":{\"1548\":1}}],[\"这样做的好处是增加新的user时速度会很快\",{\"1\":{\"332\":1}}],[\"这样做的原因就是concurrenthashmap是无序的\",{\"1\":{\"975\":1}}],[\"这样做的目的\",{\"1\":{\"487\":1}}],[\"这样做的目的是为了避免大对象分配内存时的复制操作而降低效率\",{\"1\":{\"1669\":1}}],[\"这样做的目的是为了保证数据的可见性\",{\"1\":{\"1498\":1}}],[\"这样做的目的是\",{\"1\":{\"487\":1}}],[\"这样做的结果就是\",{\"1\":{\"457\":1}}],[\"这样做的风险时\",{\"1\":{\"451\":1}}],[\"这样做的风险是\",{\"1\":{\"451\":1}}],[\"这样做的逻辑在于以前总是认为网络通信\",{\"1\":{\"392\":1}}],[\"这样存储引擎无需回表获取对应行就可以返回结果了\",{\"1\":{\"390\":1}}],[\"这样性能显然会更好\",{\"1\":{\"386\":1}}],[\"这样主动把l\",{\"1\":{\"368\":1}}],[\"这样整个查询语句的执行流程就变成了\",{\"1\":{\"356\":1}}],[\"这样整个查询过程的流程就变成了\",{\"1\":{\"356\":1}}],[\"这样内存里能够同时放下的行数就很少\",{\"1\":{\"355\":1}}],[\"这样随机访问io的次数不会减少\",{\"1\":{\"344\":1}}],[\"这样就有可能影响了性能上的优势\",{\"1\":{\"1620\":1}}],[\"这样就有128个线程处于等待状态\",{\"1\":{\"476\":1}}],[\"这样就保证了数据的安全性\",{\"1\":{\"1553\":1}}],[\"这样就实现了具体任务与执行任务类之间的结偶\",{\"1\":{\"1501\":1}}],[\"这样就不会出现热点数据过期的情况\",{\"1\":{\"630\":1}}],[\"这样就不需要从磁盘中读入这个数据页了\",{\"1\":{\"343\":1}}],[\"这样就达到了我们的预期\",{\"1\":{\"468\":1}}],[\"这样就增加了备库复制的并行度\",{\"1\":{\"465\":1}}],[\"这样就都是前开后闭区间了\",{\"1\":{\"448\":1}}],[\"这样就确保了无法再插入新的记录\",{\"1\":{\"448\":1}}],[\"这样就跳过了最后排序的阶段\",{\"1\":{\"416\":1}}],[\"这样就没有字符集转换问题了\",{\"1\":{\"368\":1}}],[\"这样就可以减少用户空间与内核空间之前需要拷贝的数据\",{\"1\":{\"1423\":1}}],[\"这样就可以对应上服务端的一些会话信息\",{\"1\":{\"1200\":1}}],[\"这样就可以把访问被驱动表的成本见到更低了\",{\"1\":{\"555\":1}}],[\"这样就可以使用ref访问方法来降低访问被驱动表的成本了\",{\"1\":{\"555\":1}}],[\"这样就可以保证主\",{\"1\":{\"478\":1}}],[\"这样就可以用上被驱动表的tradeid索引了\",{\"1\":{\"368\":1}}],[\"这样就可以在这些数据结构的基础上实现高级查找算法\",{\"1\":{\"331\":1}}],[\"这样如果要查询id\",{\"1\":{\"334\":1}}],[\"这样临时库就跟误删之前的线上库一样了\",{\"1\":{\"327\":1}}],[\"这样\",{\"1\":{\"307\":1,\"406\":1,\"411\":1,\"412\":1,\"413\":1,\"417\":1,\"447\":1,\"448\":1,\"464\":1,\"468\":2,\"471\":1,\"472\":1,\"479\":1,\"485\":2,\"497\":1,\"1502\":1,\"1607\":1}}],[\"这种结果用ored值来表示的\",{\"1\":{\"1620\":1}}],[\"这种结构就是倒排索引\",{\"1\":{\"308\":1}}],[\"这种修改就会在分割迭代器遍历的时候反映出来\",{\"1\":{\"1620\":1}}],[\"这种修改并不是通用的优化手段\",{\"1\":{\"348\":1}}],[\"这种执行模式的选择\",{\"1\":{\"1619\":1}}],[\"这种执行方式只是流里面的一个属性而已\",{\"1\":{\"1619\":1}}],[\"这种设置确保了可以适当的释放一些资源\",{\"1\":{\"1619\":1}}],[\"这种调用的机制被声明在资源的规范的头里面\",{\"1\":{\"1619\":1}}],[\"这种场景下\",{\"1\":{\"1604\":1}}],[\"这种场景只会存在于理论中\",{\"1\":{\"496\":1}}],[\"这种一请求一应答的通信模型简化了上层开发\",{\"1\":{\"1572\":1}}],[\"这种内存消耗已经渐渐可以接受了\",{\"1\":{\"1527\":1}}],[\"这种解决并发问题的设计模式被称为不变性模式\",{\"1\":{\"1526\":1}}],[\"这种隔离性能避免几个特别耗时的任务拖垮整个应用的风险\",{\"1\":{\"1517\":1}}],[\"这种集群模式下\",{\"1\":{\"1517\":1}}],[\"这种任务的特点是并不会特别消耗cpu资源\",{\"1\":{\"1510\":1}}],[\"这种数据结构在g1中需要占用大量的内存\",{\"1\":{\"1449\":1}}],[\"这种数据结构就是索引\",{\"1\":{\"331\":1}}],[\"这种技术通常用于通过网络传输文件时节省cpu周期和内存带宽\",{\"1\":{\"1231\":1}}],[\"这种注解是用于去声明应用中扮演\",{\"1\":{\"1134\":1}}],[\"这种模式会将所有的命令都记录下来\",{\"1\":{\"591\":1}}],[\"这种模式下一般会把数据库的连接信息放在客户端的连接层\",{\"1\":{\"469\":1}}],[\"这种工作方式使得\",{\"1\":{\"588\":1}}],[\"这种统计数据存储在内存中\",{\"1\":{\"558\":1}}],[\"这种统计数据存储在磁盘上\",{\"1\":{\"558\":1}}],[\"这种格式处理起来不太方便\",{\"1\":{\"529\":1}}],[\"这种申请自增id的策略\",{\"1\":{\"492\":1}}],[\"这种做法也存在一个问题\",{\"1\":{\"477\":1}}],[\"这种做法可行吗\",{\"1\":{\"454\":1}}],[\"这种直接跳过指定错误的方法\",{\"1\":{\"467\":1}}],[\"这种策略与按行分发的策略比较类似\",{\"1\":{\"465\":1}}],[\"这种策略的并行效果\",{\"1\":{\"463\":1}}],[\"这种\",{\"1\":{\"457\":1}}],[\"这种语句只需要访问一个分表\",{\"1\":{\"411\":1}}],[\"这种分库分表系统都有一个中间层proxy\",{\"1\":{\"411\":1}}],[\"这种表的数据都保存在内存里\",{\"1\":{\"409\":1}}],[\"这种情况可以使用stringbuffer\",{\"1\":{\"1342\":1}}],[\"这种情况只会走name字段索引\",{\"1\":{\"518\":1}}],[\"这种情况一般业务都是不可接受的\",{\"1\":{\"458\":1}}],[\"这种情况\",{\"1\":{\"457\":1,\"492\":1}}],[\"这种情况就需要mdl\",{\"1\":{\"441\":1}}],[\"这种情况更为常见\",{\"1\":{\"403\":1}}],[\"这种情况下是无法检测到被重用的\",{\"1\":{\"1619\":1}}],[\"这种情况下我们认为事务t和worker是冲突的\",{\"1\":{\"461\":1}}],[\"这种情况下\",{\"1\":{\"339\":1,\"411\":1,\"459\":1,\"485\":1,\"486\":1,\"1648\":1}}],[\"这种算法就被称为\",{\"1\":{\"402\":1}}],[\"这种方法在解决不可变对象的修改问题时经常用到\",{\"1\":{\"1527\":1}}],[\"这种方法\",{\"1\":{\"1511\":1}}],[\"这种方法并不适用\",{\"1\":{\"348\":1}}],[\"这种方式是在内存中\",{\"1\":{\"1437\":1}}],[\"这种方式是给堆内存当中的每个对象记录一个引用个数\",{\"1\":{\"1437\":1}}],[\"这种方式不太建议\",{\"1\":{\"1329\":1}}],[\"这种方式对channel是会产生阻塞的\",{\"1\":{\"1328\":1}}],[\"这种方式可以防止大量请求同时访问后端服务\",{\"1\":{\"1283\":1}}],[\"这种方式可以定义更加易读的json格式\",{\"1\":{\"306\":1}}],[\"这种方式可能会导致缓存数据与数据库的数据不一致\",{\"1\":{\"1283\":1}}],[\"这种方式有丢失数据的风险\",{\"1\":{\"1269\":1}}],[\"这种方式了类似继承\",{\"1\":{\"961\":1}}],[\"这种方式的弊端在于\",{\"1\":{\"1607\":1}}],[\"这种方式的优势是处理速度快\",{\"1\":{\"411\":1}}],[\"这种方式的缺点就在于\",{\"1\":{\"397\":1}}],[\"这种方式地效率很低\",{\"1\":{\"396\":1}}],[\"这种方式称之为静态映射\",{\"1\":{\"309\":1}}],[\"这种业务模型常见的就是账单类\",{\"1\":{\"344\":1}}],[\"这种存储方式的表称为索引组织表\",{\"1\":{\"335\":1}}],[\"这种范围扫描索引比全表扫描要好\",{\"1\":{\"330\":1}}],[\"这种机制称之为动态映射\",{\"1\":{\"309\":1}}],[\"这种我们就可以称之为倒排索引\",{\"1\":{\"300\":1}}],[\"那要不要跳过了\",{\"1\":{\"1983\":1}}],[\"那学习这部分会更快\",{\"1\":{\"1969\":1}}],[\"那必须先执行相应的类加载过程\",{\"1\":{\"1666\":1}}],[\"那使用并行就并没有带来多少的好处\",{\"1\":{\"1620\":1}}],[\"那最终的结果一定也是a类型\",{\"1\":{\"1615\":1}}],[\"那是不是所有的场景下\",{\"1\":{\"1612\":1}}],[\"那如何判断一个操作是中间操作还是终止操作呢\",{\"1\":{\"1611\":1}}],[\"那如果我们想分组的时候也统计分数的平均值\",{\"1\":{\"1613\":1}}],[\"那如果我们使用函数式的编程方式呢\",{\"1\":{\"1613\":1}}],[\"那如果既想求出最大值\",{\"1\":{\"1610\":1}}],[\"那如果要实现这个需求改怎么做呢\",{\"1\":{\"1609\":1}}],[\"那如果要包含最大值改怎么做呢\",{\"1\":{\"1607\":1}}],[\"那对于stream内部迭代的方式呢\",{\"1\":{\"1611\":1}}],[\"那对于想从jdk7升级到jdk8的人无疑是一场灾难\",{\"1\":{\"1607\":1}}],[\"那什么是外部迭代\",{\"1\":{\"1611\":1}}],[\"那stream是如何转变成我们常用的list集合呢\",{\"1\":{\"1608\":1}}],[\"那意味你需要重写所有的子类\",{\"1\":{\"1607\":1}}],[\"那意味着该列中没有重复的值\",{\"1\":{\"553\":1}}],[\"那只能限流生产者\",{\"1\":{\"1536\":1}}],[\"那说明一天之内肯定能处理完\",{\"1\":{\"1536\":1}}],[\"那还在对象头中还必须有一块数据用于记录数组长度\",{\"1\":{\"1484\":1}}],[\"那java的nio当中时使用的哪种机制呢\",{\"1\":{\"1423\":1}}],[\"那pk就是聚簇索引\",{\"1\":{\"1266\":1}}],[\"那在单例池中最终就会需要注入动态代理对象\",{\"1\":{\"1237\":1}}],[\"那我多增设几台redis\",{\"1\":{\"633\":1}}],[\"那我们就只能用单表查询\",{\"1\":{\"401\":1}}],[\"那我们将会在创建或修改文章的时候\",{\"1\":{\"300\":1}}],[\"那默认采用系统变量innodb\",{\"1\":{\"559\":1}}],[\"那就算当前已经偏向了其他线程\",{\"1\":{\"1485\":1}}],[\"那就可以抛弃这些对象\",{\"1\":{\"1435\":1}}],[\"那就可以精确统计出and\",{\"1\":{\"549\":1}}],[\"那就会去读数据库中的数据\",{\"1\":{\"1286\":1}}],[\"那就是容量的大小\",{\"1\":{\"1501\":1}}],[\"那就是线程要读数据\",{\"1\":{\"603\":1}}],[\"那就是驱动表中有多少记录\",{\"1\":{\"554\":1}}],[\"那就不会对该连接顺序继续往下分析了\",{\"1\":{\"556\":1}}],[\"那就继续递归\",{\"1\":{\"549\":1}}],[\"那就通过db\",{\"1\":{\"542\":1}}],[\"那就必须等待这个参数变为0才能执行查询请求\",{\"1\":{\"472\":1}}],[\"那些要用来计算的数字不要用varchar类型保存\",{\"1\":{\"530\":1}}],[\"那它就有上限\",{\"1\":{\"493\":1}}],[\"那为什么还会增加默认方法的机制呢\",{\"1\":{\"1607\":1}}],[\"那为什么执行show\",{\"1\":{\"481\":1}}],[\"那为什么innodb不跟myisam一样\",{\"1\":{\"396\":1}}],[\"那查询的压力都会跑到主库上\",{\"1\":{\"473\":1}}],[\"那也起不到并行的效果\",{\"1\":{\"463\":1}}],[\"那主备的数据不就不一致了吗\",{\"1\":{\"454\":1}}],[\"那怎么才能一次性地多穿些值给表t2呢\",{\"1\":{\"405\":1}}],[\"那直接更新内存会更快\",{\"1\":{\"343\":1}}],[\"那这个锁就被锁死了\",{\"1\":{\"1288\":1}}],[\"那这个tab页也是可以获得浏览器的cookie\",{\"1\":{\"1201\":1}}],[\"那这个线程什么时候会退出呢\",{\"1\":{\"481\":1}}],[\"那这个联合索引就有意义了\",{\"1\":{\"338\":1}}],[\"那这张表上的查询才适合使用查询缓存\",{\"1\":{\"319\":1}}],[\"那应该用身份证号做主键\",{\"1\":{\"335\":1}}],[\"那么看是否需要进行对构造方法进行参数的依赖注入\",{\"1\":{\"1650\":1}}],[\"那么则构造一个代理对象并返回\",{\"1\":{\"1648\":1}}],[\"那么扫描的类是非常多的\",{\"1\":{\"1646\":1}}],[\"那么扫描行树为100\",{\"1\":{\"525\":1}}],[\"那么user这个属性就会按照stringtouserpropertyeditor中定义好的规则来进行属性赋值\",{\"1\":{\"1638\":1}}],[\"那么再根据名称查找\",{\"1\":{\"1630\":1}}],[\"那么再为这个语句在表t2的字段b上创建一个索引就很浪费了\",{\"1\":{\"407\":1}}],[\"那么实现的时候\",{\"1\":{\"1623\":1}}],[\"那么源在发送数据之前就可以根据判断是否要向sink发送数据\",{\"1\":{\"1623\":1}}],[\"那么使用流的方式效率还是比传统的方式要高的\",{\"1\":{\"1622\":1}}],[\"那么使用覆盖索引来编写sql\",{\"1\":{\"375\":1}}],[\"那么返回用于排序的比较器\",{\"1\":{\"1620\":1}}],[\"那么他就会根据树的深度返回2的指数次方\",{\"1\":{\"1620\":1}}],[\"那么他将会丢失所有在短线期间发布者发布的消息\",{\"1\":{\"600\":1}}],[\"那么estimate返回的就一定是一个精确的值\",{\"1\":{\"1620\":1}}],[\"那么最终也会被包装为一个sqlsessiontemplate对象\",{\"1\":{\"1653\":1}}],[\"那么最好这种传递是发生在任何元素在使用tryadvance方法消费之前完成\",{\"1\":{\"1620\":1}}],[\"那么最新的旧数据作为链表的表头\",{\"1\":{\"542\":1}}],[\"那么遍历的时候就必须遵循遍历时候的顺序\",{\"1\":{\"1620\":1}}],[\"那么遍历此集合的算法都得做相应的调整\",{\"1\":{\"1353\":1}}],[\"那么除了ized和subsized其他的特性值并不会简化客户端的计算\",{\"1\":{\"1620\":1}}],[\"那么抛出的第一个异常就会被抛给close方法的调用者\",{\"1\":{\"1619\":1}}],[\"那么iterator\",{\"1\":{\"1619\":1}}],[\"那么innodb会默认创建一个不可见的\",{\"1\":{\"495\":1}}],[\"那么innodb会自己生成一个长度为6字节的rowid来作为主键\",{\"1\":{\"420\":1}}],[\"那么combiner就会得到调用\",{\"1\":{\"1617\":1}}],[\"那么combiner就不会被调用\",{\"1\":{\"1617\":1}}],[\"那么多个线程就会操作操作同一个中间结果容器\",{\"1\":{\"1617\":1}}],[\"那么会返回正数\",{\"1\":{\"1603\":1}}],[\"那么会根据索引a找到第一个满足条件的行\",{\"1\":{\"454\":1}}],[\"那么后面的比较器就不会再调用\",{\"1\":{\"1614\":1}}],[\"那么后面的将不再会被计算\",{\"1\":{\"1599\":1}}],[\"那么后者也不会被计算\",{\"1\":{\"1599\":1}}],[\"那么动作就会按照迭代的顺序去执行\",{\"1\":{\"1595\":1}}],[\"那么编译器就会按照函数式接口的定义来要求该接口\",{\"1\":{\"1594\":1}}],[\"那么到底什么是函数式接口呢\",{\"1\":{\"1594\":1}}],[\"那么整个进程会被block\",{\"1\":{\"1565\":1}}],[\"那么牧童的手的指向也就不同\",{\"1\":{\"1561\":1}}],[\"那么将\",{\"1\":{\"1554\":1}}],[\"那么将create\",{\"1\":{\"468\":1}}],[\"那么n\",{\"1\":{\"1550\":1}}],[\"那么table\",{\"1\":{\"1548\":1}}],[\"那么t1时刻\",{\"1\":{\"424\":1}}],[\"那么程序调用方法所计算得到的hash码值总是相同的\",{\"1\":{\"1548\":1}}],[\"那么本线程就无需再做了\",{\"1\":{\"1531\":1}}],[\"那么fork\",{\"1\":{\"1527\":1}}],[\"那么即便获取电商s2报价的耗时很短\",{\"1\":{\"1517\":1}}],[\"那么即使满足了条件\",{\"1\":{\"344\":1}}],[\"那么另外的线程边可以利用cpu去执行其他的任务\",{\"1\":{\"1510\":1}}],[\"那么生产者不需要关心具体的转账逻辑\",{\"1\":{\"1501\":1}}],[\"那么当我们使用哈希算法求得这个位置的时候\",{\"1\":{\"1548\":1}}],[\"那么当一部分线程正在等待io的时候\",{\"1\":{\"1510\":1}}],[\"那么当前线程无法感知线程t的数据更新\",{\"1\":{\"1498\":1}}],[\"那么当出现唯一键冲突和事务回滚的时候\",{\"1\":{\"491\":1}}],[\"那么认为这次自旋成功的可能性高\",{\"1\":{\"1485\":1}}],[\"那么效率会比linkedlist高\",{\"1\":{\"1475\":1}}],[\"那么它就需要提供完整的同步机制\",{\"1\":{\"1622\":1}}],[\"那么它就会报告sized的特性值\",{\"1\":{\"1620\":1}}],[\"那么它就会把这几个synchronized块合并为一个较大的同步块\",{\"1\":{\"1393\":1}}],[\"那么它就再也不会被使用了\",{\"1\":{\"1615\":1}}],[\"那么它马上就将数据拷贝到了用户内存\",{\"1\":{\"1564\":1}}],[\"那么它并不会block用户进程\",{\"1\":{\"1564\":1}}],[\"那么它由一系列子任务组成\",{\"1\":{\"381\":1}}],[\"那么jit编译器在编译这个同步代码时就不会生成synchronized关键字所标识的锁的申请与释放机器码\",{\"1\":{\"1393\":1}}],[\"那么此时也许只有部分数据被写入到磁盘\",{\"1\":{\"1297\":1}}],[\"那么首先要获取到实例方法所在的类的实例\",{\"1\":{\"1183\":1}}],[\"那么推荐使用构造器注入\",{\"1\":{\"970\":1}}],[\"那么必须保证这个脚本存在于这个路径\",{\"1\":{\"624\":1}}],[\"那么该函数就叫做高阶函数\",{\"1\":{\"1598\":1}}],[\"那么该接口就是一个函数式接口\",{\"1\":{\"1594\":1}}],[\"那么该线程也去帮扩容\",{\"1\":{\"1554\":1}}],[\"那么该事务中的所有命令都会被服务器执行\",{\"1\":{\"1297\":1}}],[\"那么该脚本稍后将会被再次执行\",{\"1\":{\"624\":1}}],[\"那么该如何优化呢\",{\"1\":{\"419\":1,\"422\":1}}],[\"那么意味着连接暂时处于空闲状态\",{\"1\":{\"605\":1}}],[\"那么久重新连接\",{\"1\":{\"611\":1}}],[\"那么久最多等待timeout时间\",{\"1\":{\"603\":1}}],[\"那么久可以加上\",{\"1\":{\"482\":1}}],[\"那么redis是如何使用单线程处理那么多的并发客户端连接的\",{\"1\":{\"601\":1}}],[\"那么redo\",{\"1\":{\"451\":1}}],[\"那么不断积压的消息会使redis输出缓冲区的体积变得越来越大\",{\"1\":{\"600\":1}}],[\"那么不符合最左前缀的部分\",{\"1\":{\"340\":1}}],[\"那么你可以只使用\",{\"1\":{\"596\":1}}],[\"那么服务器将丢失最近写入\",{\"1\":{\"592\":1}}],[\"那么服务器会重新进行一次统计数据的计算\",{\"1\":{\"559\":1}}],[\"那么一定可以使用hyperloglog\",{\"1\":{\"577\":1}}],[\"那么一种直接的想法就是需要一个时申请一个\",{\"1\":{\"492\":1}}],[\"那么优化器需要从全表扫描\",{\"1\":{\"555\":1}}],[\"那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条\",{\"1\":{\"554\":1}}],[\"那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条\",{\"1\":{\"554\":1}}],[\"那么计算group\",{\"1\":{\"417\":1}}],[\"那么扇出值就是多少\",{\"1\":{\"554\":1}}],[\"那么我们要计算区间最左记录和最右记录之间的页面数量就相当于计算页b和页c之间有多少页面\",{\"1\":{\"549\":1}}],[\"那么我们如果删除这个索引\",{\"1\":{\"361\":1}}],[\"那么之后的快照读使用的都是同一个read\",{\"1\":{\"542\":1}}],[\"那么产生的间隙就有id为\",{\"1\":{\"536\":1}}],[\"那么从理论上讲\",{\"1\":{\"497\":1}}],[\"那么mysql还会同时把query\",{\"1\":{\"496\":1}}],[\"那么mysql会自动释放这个全局锁\",{\"1\":{\"438\":1}}],[\"那么先记session\",{\"1\":{\"492\":1}}],[\"那么只需要执行set\",{\"1\":{\"485\":1}}],[\"那么备库也要进行更新检测\",{\"1\":{\"478\":1}}],[\"那么备份只能通过ftwrl方法\",{\"1\":{\"438\":1}}],[\"那么所有的更新语句和事务提交的commit语句就都会被堵住\",{\"1\":{\"477\":1}}],[\"那么1秒内master\",{\"1\":{\"473\":1}}],[\"那么上面的两个位点等值判断就会一直不成立\",{\"1\":{\"472\":1}}],[\"那么切换之后gtid集合的格式就变成了source\",{\"1\":{\"468\":1}}],[\"那么对象的部分\",{\"1\":{\"1488\":1}}],[\"那么对于spliterator的任何计算都是不受保障\",{\"1\":{\"1620\":1}}],[\"那么对于这个lambda表达式而言\",{\"1\":{\"1595\":1}}],[\"那么对于这个对象的操作可以不考虑同步\",{\"1\":{\"1488\":1}}],[\"那么对于每个唯一索引\",{\"1\":{\"465\":1}}],[\"那么对a字段建索引一般不会提高数据库的查询速度\",{\"1\":{\"359\":1}}],[\"那么时候应该使用可用性优化策略呢\",{\"1\":{\"459\":1}}],[\"那么系统几乎没有不可用时间了\",{\"1\":{\"459\":1}}],[\"那么删除的就是t\",{\"1\":{\"454\":1}}],[\"那么按照这个参数的逻辑\",{\"1\":{\"451\":1}}],[\"那么事务很有可能就会导致从库延迟10分钟\",{\"1\":{\"457\":1}}],[\"那么事务还没有提交的时候\",{\"1\":{\"451\":1}}],[\"那么事务隔离是怎么实现的呢\",{\"1\":{\"434\":1}}],[\"那么为什么我们将所有的记录都已经上了锁\",{\"1\":{\"447\":1}}],[\"那么死锁检测操作的时间复杂度就是百万量级的\",{\"1\":{\"444\":1}}],[\"那么查询线程拿到的结果就与表结构对应不上了\",{\"1\":{\"441\":1}}],[\"那么查询语句\",{\"1\":{\"353\":1}}],[\"那么手动分表和分区表有什么区别\",{\"1\":{\"424\":1}}],[\"那么sourcespliterator必须为空\",{\"1\":{\"1621\":1}}],[\"那么sourcesupplier必须是null\",{\"1\":{\"1621\":1}}],[\"那么sort\",{\"1\":{\"355\":1}}],[\"那么session\",{\"1\":{\"424\":1}}],[\"那么分区表有什么问题呢\",{\"1\":{\"423\":1}}],[\"那么取到id=4的这一行的概率是取到其它行的概率的两倍\",{\"1\":{\"422\":1}}],[\"那么内存临时表就会转成磁盘临时表\",{\"1\":{\"421\":1}}],[\"那么是不是所有的临时表都是内存表呢\",{\"1\":{\"421\":1}}],[\"那么group\",{\"1\":{\"417\":1}}],[\"那么binlog中就只能记录\",{\"1\":{\"413\":1}}],[\"那么与临时表有关的语句\",{\"1\":{\"413\":1}}],[\"那么在不超过\",{\"1\":{\"1664\":1}}],[\"那么在遍历的时候就会独立于流中输入的顺序\",{\"1\":{\"1623\":1}}],[\"那么在分割之前spliterator的estimatesize的值必须等于分割之后所剩下的estimatesize以及剩下的spliteratord的estimatesize加起来必须相等\",{\"1\":{\"1620\":1}}],[\"那么在计算为了说明h\",{\"1\":{\"1548\":1}}],[\"那么在future也没有办法做到\",{\"1\":{\"1516\":1}}],[\"那么在propertyvalues中就包含一个propertyvalues\",{\"1\":{\"1003\":1}}],[\"那么在实例b上执行start\",{\"1\":{\"468\":1}}],[\"那么在备库应用的时候\",{\"1\":{\"464\":1}}],[\"那么在备库就只有create\",{\"1\":{\"413\":1}}],[\"那么在这个算法里\",{\"1\":{\"403\":1}}],[\"那么在这种情况下\",{\"1\":{\"403\":1}}],[\"那么在连接的时候\",{\"1\":{\"368\":1}}],[\"那么显然结果是false\",{\"1\":{\"1599\":1}}],[\"那么显然可能会出现冲突\",{\"1\":{\"413\":1}}],[\"那么显然\",{\"1\":{\"401\":1,\"403\":1,\"1595\":1}}],[\"那么执行过程是先往join\",{\"1\":{\"525\":1}}],[\"那么执行的时候\",{\"1\":{\"399\":1}}],[\"那么执行器的执行流程如下\",{\"1\":{\"322\":1}}],[\"那么基于该表的查询就可以重复利用查询缓存结果了\",{\"1\":{\"394\":1}}],[\"那么第三个查询的in\",{\"1\":{\"394\":1}}],[\"那么应用就可以跳过第一个查询\",{\"1\":{\"394\":1}}],[\"那么应该关闭change\",{\"1\":{\"344\":1}}],[\"那么通常可以尝试下面的技巧进行优化\",{\"1\":{\"390\":1}}],[\"那么解决的最好办法通常就是增加一个合适的索引\",{\"1\":{\"390\":1}}],[\"那么用户多次评论的时候\",{\"1\":{\"386\":1}}],[\"那么如何保证线程安全呢\",{\"1\":{\"1377\":1}}],[\"那么如何保证消息不丢失呢\",{\"1\":{\"1328\":1}}],[\"那么如何销毁prototype的bean呢\",{\"1\":{\"985\":1}}],[\"那么如何给字符串添加合适的索引呢\",{\"1\":{\"349\":1}}],[\"那么如果一个hashmap不停的插入\",{\"1\":{\"1363\":1}}],[\"那么如果集合中保存的元素是可变类型的\",{\"1\":{\"1353\":1}}],[\"那么如果出现同一行热点更新的问题时\",{\"1\":{\"476\":1}}],[\"那么如果有一个页面经常要显示交易系统的操作记录总数\",{\"1\":{\"396\":1}}],[\"那么如果进行优化\",{\"1\":{\"362\":1}}],[\"那么索引就会包含整个字符串\",{\"1\":{\"350\":1}}],[\"那么业务代码中一定会出现类似这样的语句\",{\"1\":{\"349\":1}}],[\"那么普通索引的所有场景\",{\"1\":{\"344\":1}}],[\"那么要取下一个记录\",{\"1\":{\"342\":1}}],[\"那么这时\",{\"1\":{\"624\":1}}],[\"那么这俩也不会例外\",{\"1\":{\"583\":1}}],[\"那么这条记录一定是可以被安全清除的\",{\"1\":{\"542\":1}}],[\"那么这部分日志就丢失了\",{\"1\":{\"451\":1}}],[\"那么这两个事务冲突的部分就是语句2了\",{\"1\":{\"443\":1}}],[\"那么这两个选择逻辑上都是正确的\",{\"1\":{\"341\":1}}],[\"那么这是怎么做到的呢\",{\"1\":{\"412\":1}}],[\"那么这个方法应该当被重写\",{\"1\":{\"1620\":1}}],[\"那么这个函数就会直接将a转型为r\",{\"1\":{\"1615\":1}}],[\"那么这个接口就被称为函数式接口\",{\"1\":{\"1594\":1}}],[\"那么这个接口就是函数式接口\",{\"1\":{\"1594\":1}}],[\"那么这个db\",{\"1\":{\"542\":1}}],[\"那么这个时候表t的自增值是4\",{\"1\":{\"491\":1}}],[\"那么这个表的自增值不变\",{\"1\":{\"491\":1}}],[\"那么这个mdl读锁就没有机会释放了\",{\"1\":{\"481\":1}}],[\"那么这个请求需要拿到最新的结果\",{\"1\":{\"470\":1}}],[\"那么这个事务t的分配流程如下\",{\"1\":{\"461\":1}}],[\"那么这个索引的选择性就是1980\",{\"1\":{\"359\":1}}],[\"那么这个语句就只能全表扫描\",{\"1\":{\"350\":1}}],[\"那么这个value就会被直接返回给客户端\",{\"1\":{\"319\":1}}],[\"那么这个关键词可能出现在标题中\",{\"1\":{\"300\":1}}],[\"那么建议创建一个\",{\"1\":{\"339\":1}}],[\"那么每个二级索引的叶子节点占用约20个字节\",{\"1\":{\"335\":1}}],[\"那么访问磁盘的平均次数就更少了\",{\"1\":{\"334\":1}}],[\"那么\",{\"1\":{\"334\":1,\"337\":1,\"339\":1,\"340\":1,\"342\":1,\"343\":1,\"417\":1,\"444\":1,\"454\":1,\"455\":1,\"459\":1,\"467\":1,\"468\":1,\"470\":1,\"482\":1,\"491\":1,\"497\":1}}],[\"那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致\",{\"1\":{\"327\":1}}],[\"那么可以通过迭代出的元素修改原集合中的对象\",{\"1\":{\"1353\":1}}],[\"那么可以在使用mysqlbinlog命令时\",{\"1\":{\"485\":1}}],[\"那么可以在sql语句末尾增加order\",{\"1\":{\"416\":1}}],[\"那么可以采用可用性优先的策略\",{\"1\":{\"458\":1}}],[\"那么可以使用commit\",{\"1\":{\"435\":1}}],[\"那么可以用类似下面的方法来完成相同的工作\",{\"1\":{\"393\":1}}],[\"那么可以修改sql语句\",{\"1\":{\"368\":1}}],[\"那么可以给id\",{\"1\":{\"341\":1}}],[\"那么可以\",{\"1\":{\"327\":1}}],[\"那么就无法再保证执行给定的lambda表达式的元素的顺序了\",{\"1\":{\"1622\":1}}],[\"那么就无法使用查询缓存了\",{\"1\":{\"394\":1}}],[\"那么就意味着我们可以使用lambda表达式的方式来创建myinterface的实例\",{\"1\":{\"1595\":1}}],[\"那么就不能选择arrrayblockingqueue\",{\"1\":{\"1509\":1}}],[\"那么就一定还存在一个redisproperties类\",{\"1\":{\"583\":1}}],[\"那么就继续穷举分析每一种连接顺序的成本\",{\"1\":{\"556\":1}}],[\"那么就把这个表当前的auto\",{\"1\":{\"491\":1}}],[\"那么就有两种可能\",{\"1\":{\"468\":1}}],[\"那么就是一个事务对应一次持久化操作了\",{\"1\":{\"451\":1}}],[\"那么就可以控制死锁检测的时间复杂度\",{\"1\":{\"444\":1}}],[\"那么就可以通过倒排索引\",{\"1\":{\"300\":1}}],[\"那么就破坏了备份的一致性\",{\"1\":{\"438\":1}}],[\"那么就只能访问所有分区了\",{\"1\":{\"425\":1}}],[\"那么就会把这个类解析为一个beandefition\",{\"1\":{\"1635\":1}}],[\"那么就会被强转为intconsumer并传递给tryadvance\",{\"1\":{\"1620\":1}}],[\"那么就会报告sorted\",{\"1\":{\"1620\":1}}],[\"那么就会报告distinct\",{\"1\":{\"1620\":1}}],[\"那么就会操作不同的中间结果容器\",{\"1\":{\"1617\":1}}],[\"那么就会导致线程不能够正常终止\",{\"1\":{\"1524\":1}}],[\"那么就会使用所匹配的构造方法\",{\"1\":{\"1650\":1}}],[\"那么就会使用双路排序模式\",{\"1\":{\"520\":1}}],[\"那么就会使用单路排序模式\",{\"1\":{\"520\":1}}],[\"那么就会出现这样的情况\",{\"1\":{\"491\":1}}],[\"那么就会出现随机访问\",{\"1\":{\"404\":1}}],[\"那么就会落在p\",{\"1\":{\"425\":1}}],[\"那么就会在访问这个表的时候\",{\"1\":{\"425\":1}}],[\"那么就要确保从a类型到r类型的强制转换是可以成功的\",{\"1\":{\"1617\":1}}],[\"那么就要用f做分区键\",{\"1\":{\"411\":1}}],[\"那么就要优先考虑建立这样顺序的索引\",{\"1\":{\"339\":1}}],[\"那么就表示不能再执行新的更新操作了\",{\"1\":{\"324\":1}}],[\"那么总共就可以记录4gb的操作\",{\"1\":{\"324\":1}}],[\"是组装机\",{\"1\":{\"1990\":1}}],[\"是品牌机\",{\"1\":{\"1990\":1}}],[\"是基于\",{\"1\":{\"1981\":1}}],[\"是基于提高并发性能的考虑\",{\"1\":{\"541\":1}}],[\"是跨平台的非关系型数据库\",{\"1\":{\"1975\":1}}],[\"是针对于元的分割迭代器\",{\"1\":{\"1621\":1}}],[\"是整个流实现非常重要的一环\",{\"1\":{\"1620\":1}}],[\"是将中间的累积类型转换称为最终的结果类型\",{\"1\":{\"1615\":1}}],[\"是将当前线程插入到cxq的头部\",{\"1\":{\"1483\":1}}],[\"是collector类型的\",{\"1\":{\"1615\":1}}],[\"是jdk为我们提供的api\",{\"1\":{\"1609\":1}}],[\"是兼容的\",{\"1\":{\"1608\":1}}],[\"是采用下面的方式来创建流\",{\"1\":{\"1607\":1}}],[\"是需要上下文才能解读的\",{\"1\":{\"1595\":1}}],[\"是继承自obeject类中的方法\",{\"1\":{\"1595\":1}}],[\"是之前的select和poll的增强版本\",{\"1\":{\"1571\":1}}],[\"是你与操作系统打交道的东西\",{\"1\":{\"1561\":1}}],[\"是计算机科学中的一个术语\",{\"1\":{\"1561\":1}}],[\"是正在初始化的标识\",{\"1\":{\"1554\":1}}],[\"是1就表示索引变成了\",{\"1\":{\"1550\":1}}],[\"是没有并发问题的\",{\"1\":{\"1526\":1}}],[\"是高并发场景下一个底层细节问题\",{\"1\":{\"1519\":1}}],[\"是非常有效的\",{\"1\":{\"1591\":1}}],[\"是非常麻烦的\",{\"1\":{\"1518\":1}}],[\"是非常大的一个数\",{\"1\":{\"1501\":1}}],[\"是fifo先进先出线程等待队列\",{\"1\":{\"1491\":1}}],[\"是后来的线程先获取锁\",{\"1\":{\"1483\":1}}],[\"是后台操作\",{\"1\":{\"345\":1}}],[\"是位于cpu与主存之间的一种容量较小但速度很高的存储器\",{\"1\":{\"1474\":1}}],[\"是目前应用最广泛的开源关系数据库\",{\"1\":{\"1974\":1}}],[\"是目前现行架构下\",{\"1\":{\"1424\":1}}],[\"是目前比较常见的做法\",{\"1\":{\"457\":1}}],[\"是http的加强版\",{\"1\":{\"1424\":1}}],[\"是互联网上应用最为广泛的一种网络通信协议\",{\"1\":{\"1424\":1}}],[\"是三个参数总体协调的结果\",{\"1\":{\"1410\":1}}],[\"是还没有完成的任务给出的未来结果\",{\"1\":{\"1396\":1}}],[\"是操作系统分配资源的最小单元\",{\"1\":{\"1374\":1}}],[\"是功能齐全的java\",{\"1\":{\"1337\":1}}],[\"是运行java字节码的虚拟机\",{\"1\":{\"1337\":1}}],[\"是有缓存的\",{\"1\":{\"1343\":1}}],[\"是有可能丢失消息的\",{\"1\":{\"1328\":1}}],[\"是有一个过程的\",{\"1\":{\"481\":1}}],[\"是为了防止产生幻读\",{\"1\":{\"1263\":1}}],[\"是为了说明这两次查询看到的事务对应的线程id都是5\",{\"1\":{\"497\":1}}],[\"是innodb自动添加的一种锁\",{\"1\":{\"1263\":1}}],[\"是最常用的隔离级别\",{\"1\":{\"1262\":1}}],[\"是最主要的问题\",{\"1\":{\"478\":1}}],[\"是spring在aop基础上提供的事务实现机制\",{\"1\":{\"1238\":1}}],[\"是线程不安全的\",{\"1\":{\"1236\":1}}],[\"是字符串替换\",{\"1\":{\"1210\":1}}],[\"是预编译处理\",{\"1\":{\"1210\":1}}],[\"是注解的一种\",{\"1\":{\"1136\":1}}],[\"是会自动调用的\",{\"1\":{\"1012\":1}}],[\"是我们在xml文件中\",{\"1\":{\"1003\":1}}],[\"是按照类型来进行注入的\",{\"1\":{\"1001\":1}}],[\"是暂时的\",{\"1\":{\"610\":1}}],[\"是持久化之外的一种数据冗余的方式\",{\"1\":{\"607\":1}}],[\"是0就表示索引没有变化\",{\"1\":{\"1550\":1}}],[\"是0\",{\"1\":{\"578\":1}}],[\"是用来将一个新的数据元素添加到结果容器当中\",{\"1\":{\"1615\":1}}],[\"是用来创建新的可变的结果容器\",{\"1\":{\"1615\":1}}],[\"是用来做基数\",{\"1\":{\"577\":1}}],[\"是用户态的\",{\"1\":{\"1477\":1}}],[\"是用java开发并且是当前最流行的开源的企业级搜索引擎\",{\"1\":{\"301\":1}}],[\"是常数级别的\",{\"1\":{\"549\":1}}],[\"是每个快照读都会生成并获取最新的read\",{\"1\":{\"542\":1}}],[\"是当前读\",{\"1\":{\"535\":1}}],[\"是当内存放不下时\",{\"1\":{\"354\":1}}],[\"是快照读\",{\"1\":{\"535\":1}}],[\"是矛盾的\",{\"1\":{\"532\":1}}],[\"是另外维护的\",{\"1\":{\"497\":1}}],[\"是插入失败\",{\"1\":{\"495\":1}}],[\"是更能被接受的\",{\"1\":{\"495\":1}}],[\"是可能会被用完的\",{\"1\":{\"494\":1}}],[\"是可以同时存在的\",{\"1\":{\"984\":1}}],[\"是可以精确计算出需要多少个id的\",{\"1\":{\"492\":1}}],[\"是可以执行这两条update语句的\",{\"1\":{\"447\":1}}],[\"是4个字节\",{\"1\":{\"493\":1}}],[\"是执行不出来的\",{\"1\":{\"492\":1}}],[\"是在属性填充的时候会直接生成一个代理对象\",{\"1\":{\"1649\":1}}],[\"是在垃圾回收算法执行过程当中\",{\"1\":{\"1440\":1}}],[\"是在面向切面编程的时候\",{\"1\":{\"1354\":1}}],[\"是在维护prototype的bean的类中\",{\"1\":{\"985\":1}}],[\"是在真正执行插入数据的操作之前\",{\"1\":{\"491\":1}}],[\"是在writeset的基础上多了一个约束\",{\"1\":{\"465\":1}}],[\"是避免写错要删除的表名\",{\"1\":{\"487\":1}}],[\"是指向对象的\",{\"1\":{\"1561\":1}}],[\"是指线程之间所具有的一种制约关系\",{\"1\":{\"1477\":1}}],[\"是指程序在申请内存后\",{\"1\":{\"1451\":1}}],[\"是指程序在申请内存时\",{\"1\":{\"1451\":1}}],[\"是指建立一个tcp连接时\",{\"1\":{\"1425\":1}}],[\"是指具备相同领域的功能组件的集合\",{\"1\":{\"1138\":1}}],[\"是指支持顺序控制\",{\"1\":{\"1113\":1}}],[\"是指将一台redis服务器的数据\",{\"1\":{\"606\":1}}],[\"是指如果由于时间太久\",{\"1\":{\"485\":1}}],[\"是指binlog文件写到一定大小后会切换到写一个\",{\"1\":{\"325\":1}}],[\"是修改binlog的内容\",{\"1\":{\"484\":1}}],[\"是读操作的统计\",{\"1\":{\"479\":1}}],[\"是所有io类型的统计\",{\"1\":{\"479\":1}}],[\"是合理而且必要的\",{\"1\":{\"476\":1}}],[\"是这类方案常用的退化机制\",{\"1\":{\"473\":1}}],[\"是这个事务的唯一标识\",{\"1\":{\"468\":1}}],[\"是能确保读到最新数据\",{\"1\":{\"472\":1}}],[\"是备库所有已经执行完成的gtid集合\",{\"1\":{\"472\":1}}],[\"是主备收到的所有日志的gtid集合\",{\"1\":{\"472\":1}}],[\"是由操作系统来决定的\",{\"1\":{\"1585\":1}}],[\"是由linux操作系统提供的\",{\"1\":{\"1423\":1}}],[\"是由备库决定的\",{\"1\":{\"468\":1}}],[\"是由参数slave\",{\"1\":{\"460\":1}}],[\"是由参数sync\",{\"1\":{\"450\":1}}],[\"是由参数internal\",{\"1\":{\"421\":1}}],[\"是通过让线程等待来保护实例的安全性\",{\"1\":{\"1530\":1}}],[\"是通过将所有操作加锁互斥来实现的\",{\"1\":{\"540\":1}}],[\"是通过提交一个空事务\",{\"1\":{\"468\":1}}],[\"是通过某个关键词来搜索相关的文章\",{\"1\":{\"300\":1}}],[\"是依赖于主备延迟的\",{\"1\":{\"459\":1}}],[\"是\",{\"1\":{\"448\":1,\"572\":1,\"589\":2,\"944\":4,\"974\":3,\"1439\":2,\"1483\":1,\"1576\":5,\"1986\":1}}],[\"是lock实现的模板类\",{\"1\":{\"1400\":1}}],[\"是lock\",{\"1\":{\"442\":1}}],[\"是mysql一开始支持分区表的时候就存在的代码\",{\"1\":{\"425\":1}}],[\"是不变的\",{\"1\":{\"1236\":1}}],[\"是不安全的\",{\"1\":{\"583\":1}}],[\"是不区分非叶子结点和叶子结点的\",{\"1\":{\"548\":1}}],[\"是不可见的\",{\"1\":{\"542\":1}}],[\"是不影响数据的可见性判断的\",{\"1\":{\"497\":1}}],[\"是不会看到别的事务插入的数据的\",{\"1\":{\"446\":1}}],[\"是不需要额外内存的\",{\"1\":{\"418\":1}}],[\"是不是里面没有元素\",{\"1\":{\"1620\":1}}],[\"是不是抛出异常取决于调用者\",{\"1\":{\"1595\":1}}],[\"是不是的过来检查服务端是否给出了响应\",{\"1\":{\"1421\":1}}],[\"是不是饥饿的\",{\"1\":{\"963\":1}}],[\"是不是必须的\",{\"1\":{\"963\":1}}],[\"是不是真的需要返回全部的数据\",{\"1\":{\"385\":1}}],[\"是不是浪费空间\",{\"1\":{\"338\":1}}],[\"是一系列框架的有序集合\",{\"1\":{\"1989\":1}}],[\"是一套完整的微服务解决方案\",{\"1\":{\"1989\":1}}],[\"是一款优秀的持久层框架\",{\"1\":{\"1982\":1}}],[\"是一本小册子\",{\"1\":{\"1974\":1}}],[\"是一批一批进行解析的\",{\"1\":{\"1652\":1}}],[\"是一种跨进程的通信机制\",{\"1\":{\"1985\":1}}],[\"是一种栈结构\",{\"1\":{\"1664\":1}}],[\"是一种可以有效减少java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法\",{\"1\":{\"1488\":1}}],[\"是一种逻辑上的抽象\",{\"1\":{\"1442\":1}}],[\"是一种无连接的\",{\"1\":{\"1419\":1}}],[\"是一种面向连接的\",{\"1\":{\"1419\":1}}],[\"是一种行为的规范\",{\"1\":{\"1345\":1}}],[\"是一种模板设计\",{\"1\":{\"1345\":1}}],[\"是一种从上而下指导微服务设计的方法\",{\"1\":{\"1308\":1}}],[\"是一种服务冗余的方式\",{\"1\":{\"607\":1}}],[\"是一种消息通信模式\",{\"1\":{\"596\":1}}],[\"是一种解决读\",{\"1\":{\"541\":1}}],[\"是一次性去除满足条件行的所有字段\",{\"1\":{\"520\":1}}],[\"是一样的\",{\"1\":{\"403\":1}}],[\"是一个基于mvc架构\",{\"1\":{\"1982\":1}}],[\"是一个基于lucene框架\",{\"1\":{\"1254\":1}}],[\"是一个轻量级的\",{\"1\":{\"1982\":1}}],[\"是一个开源的分布式版本控制系统\",{\"1\":{\"1981\":1}}],[\"是一个开源的使用ansi\",{\"1\":{\"564\":1}}],[\"是一个项目管理工具\",{\"1\":{\"1980\":1}}],[\"是一个\",{\"1\":{\"1975\":1}}],[\"是一个抽象的概念\",{\"1\":{\"1423\":1}}],[\"是一个非常高效的全文检索引擎框架\",{\"1\":{\"1254\":1}}],[\"是一个string类型的field和value的映射表\",{\"1\":{\"573\":1}}],[\"是一个只读事务\",{\"1\":{\"497\":1}}],[\"是一个全局唯一的值\",{\"1\":{\"468\":1}}],[\"是一个事务在提交的时候生成的\",{\"1\":{\"468\":1}}],[\"是一个聚合函数\",{\"1\":{\"399\":1}}],[\"是一个逻辑概念\",{\"1\":{\"355\":1}}],[\"是一个常数\",{\"1\":{\"330\":1}}],[\"是一个分布式\",{\"1\":{\"301\":1}}],[\"是定义为not\",{\"1\":{\"399\":1}}],[\"是数据库系统设计的通用法则之一\",{\"1\":{\"396\":1}}],[\"是数据库里面成本最高的操作之一\",{\"1\":{\"343\":1}}],[\"是根据库中key的个数\",{\"1\":{\"567\":1}}],[\"是根据b+树索引的结构来的\",{\"1\":{\"549\":1}}],[\"是根据sql语句中的where条件\",{\"1\":{\"425\":1}}],[\"是根据tradeid的值到trade\",{\"1\":{\"368\":1}}],[\"是根据id在tradelog表里找到l2这一行\",{\"1\":{\"368\":1}}],[\"是因为依赖注入的可能也是原型bean\",{\"1\":{\"1648\":1}}],[\"是因为\",{\"1\":{\"492\":1}}],[\"是因为在这个隔离级别下\",{\"1\":{\"433\":1}}],[\"是因为在join\",{\"1\":{\"408\":1}}],[\"是因为这时候参与排序的行数虽然仍然是4000行\",{\"1\":{\"355\":1}}],[\"是因为它认为使用索引b可以避免排序\",{\"1\":{\"348\":1}}],[\"是直接继承了beanfactory\",{\"1\":{\"1636\":1}}],[\"是直接返回给客户端的\",{\"1\":{\"355\":1}}],[\"是直接在主键索引上扫描的\",{\"1\":{\"347\":1}}],[\"是从0到248\",{\"1\":{\"495\":1}}],[\"是从l2中取出tradeid字段的值\",{\"1\":{\"368\":1}}],[\"是从\",{\"1\":{\"354\":1}}],[\"是找到一个最优的执行方案\",{\"1\":{\"347\":1}}],[\"是无法使用\",{\"1\":{\"339\":1}}],[\"是否需要利用动态代理产生一个代理对象\",{\"1\":{\"1655\":1}}],[\"是否需要将一个复杂的查询分成多个简单的查询\",{\"1\":{\"392\":1}}],[\"是否可以把所有bean都交由spring\",{\"0\":{\"1661\":1}}],[\"是否可以把所有bean都通过spring容器来管理\",{\"0\":{\"1660\":1}}],[\"是否可以重复刷新的应用上下文\",{\"1\":{\"1651\":1}}],[\"是否可被\",{\"0\":{\"9\":1,\"1338\":1}}],[\"是否会直接返回值\",{\"1\":{\"1610\":1}}],[\"是否会抛出异常\",{\"1\":{\"944\":1}}],[\"是否同步\",{\"1\":{\"1576\":1}}],[\"是否阻塞\",{\"1\":{\"1576\":1}}],[\"是否要求属性对象也具备不可变性\",{\"1\":{\"1526\":1}}],[\"是否允许循环应用\",{\"1\":{\"1163\":1}}],[\"是否允许beandefinition重复定义\",{\"1\":{\"1163\":1}}],[\"是否自动增加嵌套路径\",{\"1\":{\"1072\":1}}],[\"是否忽略非法字段\",{\"1\":{\"1072\":1}}],[\"是否忽略未知字段\",{\"1\":{\"1072\":1}}],[\"是否为treenode\",{\"1\":{\"1549\":1}}],[\"是否为空或者为null\",{\"1\":{\"1549\":1}}],[\"是否为延迟初始化\",{\"1\":{\"1022\":1}}],[\"是否为抽象的beandefinition\",{\"1\":{\"1022\":1}}],[\"是否是一个bean\",{\"1\":{\"1647\":1}}],[\"是否是红黑树\",{\"1\":{\"1549\":1}}],[\"是否是原型\",{\"1\":{\"984\":1}}],[\"是否是单例\",{\"1\":{\"984\":1}}],[\"是否首要\",{\"1\":{\"963\":1}}],[\"是否安全\",{\"1\":{\"944\":1}}],[\"是否有可能使用索引合并\",{\"0\":{\"550\":1}}],[\"是否有必要将身份证号和名字建立联合索引\",{\"1\":{\"338\":1}}],[\"是否选择该索引\",{\"1\":{\"519\":1}}],[\"是否使用覆盖索引\",{\"1\":{\"519\":1}}],[\"是否支持异步\",{\"1\":{\"1658\":1}}],[\"是否支持异步执行\",{\"1\":{\"1113\":1}}],[\"是否支持泛型类型事件\",{\"1\":{\"1113\":1}}],[\"是否支持\",{\"1\":{\"431\":1}}],[\"是否排序等因素进行综合判断\",{\"1\":{\"347\":1}}],[\"是对计算密集型场景的加强\",{\"1\":{\"1510\":1}}],[\"是对小数据\",{\"1\":{\"1343\":1}}],[\"是对其他类型数据的统计\",{\"1\":{\"479\":1}}],[\"是对资源的浪费\",{\"1\":{\"464\":1}}],[\"是对\",{\"1\":{\"306\":1}}],[\"2道题目\",{\"1\":{\"1972\":1}}],[\"2次dma\",{\"1\":{\"1585\":1}}],[\"2次dma拷贝\",{\"1\":{\"1580\":1,\"1581\":1}}],[\"2次cpu拷贝\",{\"1\":{\"1580\":1}}],[\"2次cpu切换\",{\"1\":{\"1580\":1}}],[\"2以后冲突都在table\",{\"1\":{\"1550\":1}}],[\"2^31\",{\"1\":{\"1550\":1}}],[\"2^30\",{\"1\":{\"1550\":1}}],[\"2^64\",{\"1\":{\"577\":1}}],[\"2之前\",{\"1\":{\"1435\":1}}],[\"2g\",{\"1\":{\"1330\":1,\"1331\":1}}],[\"2+\",{\"1\":{\"897\":1}}],[\"2条记录\",{\"1\":{\"574\":1}}],[\"2种连接顺序\",{\"1\":{\"556\":1}}],[\"2是检测一条记录是否符合给定的搜索条件的成本常数\",{\"1\":{\"549\":1}}],[\"2是读取一条记录成本常数\",{\"1\":{\"549\":1}}],[\"2=7\",{\"1\":{\"549\":1}}],[\"2=4这些值\",{\"1\":{\"454\":1}}],[\"2指的是访问一条记录所需的cpu成本常数\",{\"1\":{\"548\":1}}],[\"2这些数字称之为成本常数\",{\"1\":{\"545\":1}}],[\"21中这个系统变量的默认值\",{\"1\":{\"553\":1}}],[\"21\",{\"1\":{\"549\":2,\"551\":2,\"555\":2,\"570\":1,\"573\":1,\"1619\":1}}],[\"2169\",{\"1\":{\"544\":1,\"548\":1,\"551\":1}}],[\"215字节\",{\"1\":{\"530\":2}}],[\"2155\",{\"1\":{\"529\":1}}],[\"215\",{\"1\":{\"528\":1}}],[\"29\",{\"1\":{\"576\":1}}],[\"295字节\",{\"1\":{\"530\":2}}],[\"295\",{\"1\":{\"528\":1}}],[\"294\",{\"1\":{\"528\":1,\"530\":2}}],[\"23设计模式和它的归类\",{\"0\":{\"853\":1}}],[\"232\",{\"1\":{\"571\":1,\"572\":1}}],[\"233\",{\"1\":{\"528\":1}}],[\"23\",{\"1\":{\"510\":2,\"518\":2,\"529\":1,\"549\":2,\"1605\":1,\"1619\":1}}],[\"23秒\",{\"1\":{\"348\":1}}],[\"2400\",{\"1\":{\"535\":1}}],[\"24\",{\"1\":{\"510\":1,\"518\":1,\"553\":1,\"556\":1}}],[\"27\",{\"1\":{\"506\":3}}],[\"2个用完以后\",{\"1\":{\"492\":1}}],[\"2语句\",{\"1\":{\"462\":1}}],[\"2中把db1\",{\"1\":{\"461\":1}}],[\"2中有一个事务会更新到表t3的数据\",{\"1\":{\"461\":1}}],[\"2里面涉及到修改表t3的事务先执行完成\",{\"1\":{\"461\":1}}],[\"2也冲突\",{\"1\":{\"461\":1}}],[\"2表示\",{\"1\":{\"461\":1}}],[\"2log2m\",{\"1\":{\"401\":1}}],[\"225\",{\"1\":{\"528\":3}}],[\"223\",{\"1\":{\"494\":1,\"528\":1}}],[\"22版本引入了一个新策略\",{\"1\":{\"492\":1}}],[\"22的版本里\",{\"1\":{\"465\":1}}],[\"22\",{\"1\":{\"306\":1,\"506\":3,\"510\":1,\"518\":2,\"544\":2,\"547\":4,\"549\":14,\"553\":4,\"554\":8,\"555\":20,\"1619\":1}}],[\"26379\",{\"1\":{\"624\":1}}],[\"262136\",{\"1\":{\"520\":1}}],[\"262056\",{\"1\":{\"520\":1}}],[\"264这个值太大了\",{\"1\":{\"496\":1}}],[\"26\",{\"1\":{\"306\":3}}],[\"28\",{\"1\":{\"306\":3,\"544\":2,\"547\":4,\"549\":14,\"553\":4,\"554\":8,\"555\":10}}],[\"256\",{\"1\":{\"975\":2}}],[\"250注解\",{\"1\":{\"945\":1}}],[\"255字节\",{\"1\":{\"530\":3}}],[\"255\",{\"1\":{\"330\":1,\"361\":2,\"506\":1,\"528\":1,\"530\":1,\"535\":1}}],[\"25\",{\"1\":{\"306\":6,\"446\":3,\"448\":2,\"570\":1,\"1598\":1}}],[\"2\",{\"1\":{\"300\":4,\"305\":1,\"306\":2,\"307\":2,\"335\":1,\"336\":1,\"361\":8,\"362\":1,\"363\":1,\"368\":6,\"371\":1,\"378\":1,\"390\":1,\"414\":1,\"422\":1,\"424\":1,\"428\":3,\"429\":6,\"430\":2,\"431\":2,\"434\":1,\"454\":2,\"459\":1,\"462\":3,\"481\":1,\"491\":7,\"492\":3,\"499\":1,\"506\":5,\"519\":1,\"520\":1,\"528\":6,\"534\":1,\"537\":1,\"542\":1,\"545\":2,\"548\":1,\"549\":7,\"553\":1,\"556\":3,\"557\":4,\"567\":2,\"569\":4,\"570\":4,\"571\":19,\"572\":9,\"573\":6,\"574\":30,\"576\":6,\"578\":2,\"579\":2,\"580\":1,\"581\":1,\"582\":2,\"583\":1,\"598\":3,\"624\":1,\"633\":1,\"897\":1,\"927\":1,\"929\":1,\"940\":1,\"941\":1,\"1003\":1,\"1023\":10,\"1040\":1,\"1053\":4,\"1060\":1,\"1063\":1,\"1064\":1,\"1072\":3,\"1082\":1,\"1084\":2,\"1093\":1,\"1100\":2,\"1101\":1,\"1102\":1,\"1110\":1,\"1113\":1,\"1116\":1,\"1120\":1,\"1130\":1,\"1131\":8,\"1139\":1,\"1140\":1,\"1226\":1,\"1227\":4,\"1234\":1,\"1238\":1,\"1240\":1,\"1263\":2,\"1351\":1,\"1404\":2,\"1412\":1,\"1423\":1,\"1447\":1,\"1479\":3,\"1480\":2,\"1484\":1,\"1490\":1,\"1501\":2,\"1506\":1,\"1535\":1,\"1551\":1,\"1554\":6,\"1573\":1,\"1576\":1,\"1582\":3,\"1583\":4,\"1584\":3,\"1585\":9,\"1594\":2,\"1595\":3,\"1598\":11,\"1599\":9,\"1605\":1,\"1607\":2,\"1609\":3,\"1610\":25,\"1614\":2,\"1617\":9,\"1618\":1,\"1619\":1,\"1620\":6,\"1647\":1,\"1651\":1,\"1664\":1}}],[\"2071\",{\"1\":{\"548\":2}}],[\"2038\",{\"1\":{\"529\":1}}],[\"205\",{\"1\":{\"576\":1}}],[\"2052\",{\"1\":{\"519\":2}}],[\"2054\",{\"1\":{\"519\":1}}],[\"2001\",{\"1\":{\"917\":1,\"918\":1,\"930\":2,\"953\":2,\"954\":2,\"1030\":1,\"1032\":1,\"1065\":1,\"1084\":1,\"1091\":1,\"1146\":1}}],[\"2005年\",{\"1\":{\"905\":1}}],[\"2004年\",{\"1\":{\"905\":1}}],[\"20003就表示这个语句执行过程中扫描了20003行\",{\"1\":{\"420\":1}}],[\"20003\",{\"1\":{\"420\":1}}],[\"2000在mysql中会发生强制类型转换\",{\"1\":{\"376\":1}}],[\"2000\",{\"1\":{\"376\":2,\"407\":2,\"408\":1,\"409\":1,\"1533\":1,\"1534\":1}}],[\"2000=0\",{\"1\":{\"359\":1}}],[\"20000249147415\",{\"1\":{\"576\":1}}],[\"20000就不会再选择索引a了\",{\"1\":{\"346\":1}}],[\"20000\",{\"1\":{\"346\":3,\"553\":1}}],[\"200\",{\"1\":{\"335\":1,\"336\":1,\"1534\":1}}],[\"20\",{\"1\":{\"330\":3,\"361\":1,\"431\":3,\"446\":3,\"448\":2,\"510\":1,\"518\":1,\"534\":1,\"536\":3,\"537\":1,\"555\":1,\"569\":2,\"570\":3,\"573\":4,\"581\":5,\"1485\":1,\"1598\":1,\"1600\":1,\"1605\":1,\"1611\":3,\"1613\":2}}],[\"20252\",{\"1\":{\"553\":1}}],[\"20220327105108038\",{\"1\":{\"479\":2}}],[\"20220325100353640\",{\"1\":{\"472\":2}}],[\"2021\",{\"1\":{\"4\":1,\"544\":2,\"547\":4,\"549\":14,\"553\":4,\"554\":8,\"555\":20}}],[\"2020\",{\"1\":{\"4\":1,\"371\":2,\"1605\":1}}],[\"2017这个分区\",{\"1\":{\"425\":1}}],[\"2017\",{\"1\":{\"366\":2,\"424\":6,\"506\":3}}],[\"2016\",{\"1\":{\"366\":2}}],[\"2018上\",{\"1\":{\"424\":1}}],[\"2018分区的supermum\",{\"1\":{\"424\":1}}],[\"2018和p\",{\"1\":{\"424\":2}}],[\"2018\",{\"1\":{\"366\":4,\"424\":7,\"425\":2,\"454\":7}}],[\"201\",{\"1\":{\"330\":2,\"528\":3}}],[\"2019和p\",{\"1\":{\"425\":1}}],[\"2019这个分区\",{\"1\":{\"425\":1}}],[\"2019这两个分区上\",{\"1\":{\"424\":1}}],[\"2019等等\",{\"1\":{\"424\":1}}],[\"2019是两个不同的表\",{\"1\":{\"424\":1}}],[\"2019\",{\"1\":{\"4\":2,\"424\":2}}],[\"2015\",{\"1\":{\"4\":1}}],[\"1friic\",{\"1\":{\"1972\":1}}],[\"1ddc4ec2\",{\"1\":{\"1613\":1}}],[\"1dcb5644392c\",{\"1\":{\"428\":1,\"429\":1}}],[\"1之后就停止了\",{\"1\":{\"1610\":1}}],[\"1之间\",{\"1\":{\"389\":1}}],[\"1次迭代函数f\",{\"1\":{\"1609\":1}}],[\"1次cpu拷贝\",{\"1\":{\"1580\":1,\"1581\":1}}],[\"1次扫描可以认为最终只扫描t1表一行完整数据\",{\"1\":{\"524\":1}}],[\"1就是一个0后面n个1\",{\"1\":{\"1548\":1}}],[\"1+平均等待时间\",{\"1\":{\"1510\":1}}],[\"1+占位符处理\",{\"1\":{\"1146\":1}}],[\"1l\",{\"1\":{\"1184\":1,\"1520\":1,\"1554\":2,\"1613\":1,\"1620\":1}}],[\"1测试配置属性源\",{\"1\":{\"1157\":1}}],[\"1前占位符处理\",{\"1\":{\"1146\":1}}],[\"1开始引入environment抽象\",{\"1\":{\"1144\":1}}],[\"1开始支持\",{\"1\":{\"1124\":1}}],[\"1|0\",{\"1\":{\"558\":2,\"559\":2}}],[\"1种连接顺序\",{\"1\":{\"556\":1}}],[\"1=6种连接顺序\",{\"1\":{\"556\":1}}],[\"1=4\",{\"1\":{\"454\":1}}],[\"1✖️\",{\"1\":{\"549\":1}}],[\"1指是加载一个页面的io成本常数\",{\"1\":{\"548\":1}}],[\"1byte\",{\"1\":{\"542\":1}}],[\"17\",{\"1\":{\"577\":1,\"1584\":1}}],[\"177\",{\"1\":{\"574\":1}}],[\"175\",{\"1\":{\"528\":3}}],[\"17开始\",{\"1\":{\"425\":1}}],[\"1后\",{\"1\":{\"498\":1}}],[\"1这个值本身已经很大了\",{\"1\":{\"495\":1}}],[\"1这个记录\",{\"1\":{\"424\":1}}],[\"1个用完以后\",{\"1\":{\"492\":1}}],[\"1版本之前\",{\"1\":{\"492\":1}}],[\"1来检测系统\",{\"1\":{\"476\":1}}],[\"1是检测不出问题的\",{\"1\":{\"476\":1}}],[\"1可以成功\",{\"1\":{\"476\":1}}],[\"1成功返回\",{\"1\":{\"476\":1}}],[\"1成功返回了\",{\"1\":{\"476\":1}}],[\"1判断\",{\"0\":{\"476\":1}}],[\"1执行\",{\"1\":{\"461\":1}}],[\"1了\",{\"1\":{\"461\":1}}],[\"1队列中有事务在修改表t1\",{\"1\":{\"461\":1}}],[\"1表示key未设置过期时间\",{\"1\":{\"569\":1}}],[\"1表示\",{\"1\":{\"461\":1}}],[\"1语句得到三行数据\",{\"1\":{\"422\":1}}],[\"1的mask范围在高位多1bit\",{\"1\":{\"1550\":1}}],[\"1的二进制前面都是0\",{\"1\":{\"1548\":1}}],[\"1的条件配置\",{\"1\":{\"1147\":1}}],[\"1的上限\",{\"1\":{\"497\":1}}],[\"1的\",{\"1\":{\"461\":1}}],[\"1的时候是可以成功的\",{\"1\":{\"424\":1}}],[\"1的时候order\",{\"1\":{\"361\":2}}],[\"1的下一个记录并不是2018\",{\"1\":{\"424\":1}}],[\"1的做法是按照顺序一个一个地读出来\",{\"1\":{\"422\":1}}],[\"1取得一行\",{\"1\":{\"422\":1}}],[\"1和10\",{\"1\":{\"389\":1}}],[\"1和order\",{\"1\":{\"348\":1}}],[\"15623667886\",{\"1\":{\"573\":4}}],[\"152\",{\"1\":{\"555\":1}}],[\"152k\",{\"1\":{\"555\":1}}],[\"1589248\",{\"1\":{\"548\":1}}],[\"150000\",{\"1\":{\"431\":3}}],[\"15\",{\"1\":{\"378\":1,\"446\":3,\"448\":2,\"506\":1,\"549\":2,\"567\":1,\"569\":1,\"570\":1,\"1619\":1}}],[\"1554018421008\",{\"1\":{\"307\":2}}],[\"1554015482530\",{\"1\":{\"307\":3}}],[\"147\",{\"1\":{\"528\":2}}],[\"14\",{\"1\":{\"378\":1,\"529\":1,\"1610\":1}}],[\"1425\",{\"1\":{\"329\":1,\"330\":1}}],[\"133314b\",{\"1\":{\"1613\":1}}],[\"134\",{\"1\":{\"528\":3}}],[\"13\",{\"1\":{\"378\":1,\"454\":1,\"553\":1,\"569\":1}}],[\"1252599548343744\",{\"1\":{\"1969\":1}}],[\"121239018\",{\"1\":{\"1649\":1}}],[\"121\",{\"1\":{\"576\":1}}],[\"12176\",{\"1\":{\"519\":1}}],[\"120\",{\"1\":{\"576\":3}}],[\"120和160\",{\"1\":{\"451\":1}}],[\"124556301\",{\"1\":{\"561\":1}}],[\"127\",{\"1\":{\"528\":1,\"567\":10,\"569\":19,\"570\":23,\"571\":33,\"572\":21,\"573\":19,\"574\":34,\"576\":2,\"577\":7,\"578\":9,\"579\":13,\"580\":13,\"581\":16,\"598\":4,\"609\":1,\"611\":4,\"621\":1,\"624\":1,\"1573\":1,\"1574\":1,\"1575\":1}}],[\"12号线程的等待逻辑是这样的\",{\"1\":{\"481\":1}}],[\"123666\",{\"1\":{\"570\":1}}],[\"123\",{\"1\":{\"394\":1,\"467\":1,\"985\":1}}],[\"12345\",{\"1\":{\"573\":3}}],[\"1234\",{\"1\":{\"394\":1}}],[\"12\",{\"1\":{\"378\":1,\"424\":1,\"454\":1,\"506\":3,\"529\":2,\"571\":1,\"577\":1,\"581\":1}}],[\"128到127之间的数字\",{\"1\":{\"1343\":1}}],[\"128到127之间的数字便被缓存到了本地内存中\",{\"1\":{\"1343\":1}}],[\"128到127\",{\"1\":{\"1343\":1}}],[\"128\",{\"1\":{\"353\":1,\"528\":1}}],[\"1才可以有效的用上索引\",{\"1\":{\"366\":1}}],[\"180000\",{\"1\":{\"624\":1}}],[\"180度到180度\",{\"1\":{\"576\":1}}],[\"188\",{\"1\":{\"574\":1}}],[\"18\",{\"1\":{\"351\":1,\"370\":3,\"371\":2,\"372\":2,\"373\":2,\"506\":3,\"528\":1,\"536\":1,\"544\":2,\"547\":4,\"549\":14,\"553\":4,\"554\":8,\"555\":20,\"1072\":2,\"1619\":2}}],[\"1都会返回b是最小的那一行\",{\"1\":{\"348\":1}}],[\"168\",{\"1\":{\"582\":1}}],[\"160\",{\"1\":{\"574\":1}}],[\"16000\",{\"1\":{\"535\":1}}],[\"16个数据库分别为\",{\"1\":{\"567\":1}}],[\"16\",{\"1\":{\"335\":1,\"336\":1,\"353\":2,\"354\":1,\"355\":1,\"528\":1,\"530\":2,\"548\":1,\"555\":1,\"567\":1,\"1359\":1,\"1548\":3,\"1554\":4}}],[\"163\",{\"1\":{\"5\":1}}],[\"1190000022279128\",{\"1\":{\"1974\":1}}],[\"111111\",{\"1\":{\"1181\":1,\"1182\":1}}],[\"1170再乘以16kb约2000多万的数据\",{\"1\":{\"503\":1}}],[\"110717\",{\"1\":{\"367\":2}}],[\"11\",{\"1\":{\"330\":4,\"338\":2,\"346\":3,\"353\":2,\"366\":2,\"368\":3,\"378\":1,\"400\":3,\"419\":1,\"424\":1,\"446\":3,\"454\":10,\"459\":2,\"462\":3,\"468\":2,\"476\":2,\"478\":1,\"489\":3,\"506\":5,\"510\":2,\"518\":2,\"523\":3,\"534\":1,\"535\":2,\"549\":2,\"551\":1,\"569\":1,\"570\":2,\"577\":2,\"1484\":1,\"1551\":1,\"1610\":1,\"1966\":1}}],[\"1142\",{\"1\":{\"322\":1}}],[\"10的新生代内存\",{\"1\":{\"1664\":1}}],[\"10的结果\",{\"1\":{\"416\":1}}],[\"101\",{\"1\":{\"1484\":1}}],[\"10123\",{\"1\":{\"519\":5}}],[\"1048576\",{\"1\":{\"609\":1}}],[\"10354值的统计数据中表的记录数\",{\"1\":{\"548\":1}}],[\"10354\",{\"1\":{\"548\":1}}],[\"1032\",{\"1\":{\"467\":1}}],[\"1032错误是删除数据时找不到行\",{\"1\":{\"467\":1}}],[\"10s\",{\"1\":{\"544\":1,\"547\":2,\"549\":2,\"553\":2,\"554\":2,\"571\":1}}],[\"1062\",{\"1\":{\"467\":1}}],[\"1062错误是插入数据时唯一键冲突\",{\"1\":{\"467\":1}}],[\"10进行分组统计\",{\"1\":{\"416\":1}}],[\"10225\",{\"1\":{\"553\":1}}],[\"1024字节\",{\"1\":{\"416\":1}}],[\"1024\",{\"1\":{\"411\":1,\"416\":1,\"548\":1,\"1521\":2,\"1533\":1,\"1534\":1,\"1574\":2,\"1575\":2,\"1587\":2}}],[\"102931490\",{\"1\":{\"330\":1}}],[\"10\",{\"1\":{\"330\":1,\"361\":5,\"362\":4,\"363\":2,\"368\":1,\"378\":7,\"390\":1,\"416\":3,\"419\":2,\"428\":1,\"429\":4,\"431\":3,\"444\":1,\"446\":3,\"448\":3,\"454\":4,\"468\":3,\"494\":1,\"506\":1,\"520\":1,\"528\":1,\"536\":2,\"570\":2,\"573\":1,\"574\":2,\"587\":2,\"961\":1,\"1404\":3,\"1484\":1,\"1517\":1,\"1535\":1,\"1599\":2,\"1603\":2,\"1604\":2,\"1605\":1,\"1609\":1,\"1610\":1,\"1617\":1}}],[\"100可以估算出将要和explain中前一个表进行连接的行数\",{\"1\":{\"506\":1}}],[\"100的值存入sort\",{\"1\":{\"418\":1}}],[\"100的结果是无序的\",{\"1\":{\"417\":1}}],[\"100万=10亿次\",{\"1\":{\"407\":1}}],[\"1001\",{\"1\":{\"404\":1}}],[\"100让优化器意识到\",{\"1\":{\"348\":1}}],[\"1000=10万次\",{\"1\":{\"403\":2}}],[\"1000=10万行\",{\"1\":{\"402\":1}}],[\"1000\",{\"1\":{\"347\":1,\"348\":1,\"353\":1,\"354\":1,\"368\":3,\"400\":1,\"404\":1,\"414\":2,\"419\":2,\"421\":1,\"529\":2,\"1288\":2,\"1573\":2,\"1574\":2}}],[\"10000=100万次\",{\"1\":{\"525\":2}}],[\"100000000\",{\"1\":{\"1487\":1}}],[\"1000000000l\",{\"1\":{\"1479\":1}}],[\"1000000\",{\"1\":{\"404\":1}}],[\"100000\",{\"1\":{\"347\":1,\"1591\":1}}],[\"10000\",{\"1\":{\"346\":4,\"366\":2,\"393\":1,\"419\":1,\"520\":4,\"587\":2}}],[\"100\",{\"1\":{\"329\":1,\"330\":4,\"335\":1,\"336\":1,\"348\":2,\"400\":1,\"404\":1,\"411\":3,\"416\":2,\"417\":1,\"418\":1,\"419\":2,\"424\":1,\"447\":8,\"476\":2,\"519\":1,\"555\":1,\"581\":2,\"1032\":1,\"1288\":1,\"1387\":1,\"1404\":3,\"1498\":2,\"1503\":1,\"1613\":1,\"1615\":1,\"1620\":1,\"1972\":1}}],[\"1996年\",{\"1\":{\"905\":1}}],[\"199999888333501\",{\"1\":{\"576\":1}}],[\"1988年\",{\"1\":{\"905\":1}}],[\"1983年\",{\"1\":{\"905\":1}}],[\"192\",{\"1\":{\"582\":1}}],[\"1970\",{\"1\":{\"529\":1}}],[\"1901\",{\"1\":{\"529\":1}}],[\"19\",{\"1\":{\"306\":1,\"529\":1}}],[\"1\",{\"1\":{\"300\":3,\"305\":1,\"306\":15,\"307\":3,\"309\":2,\"329\":4,\"330\":22,\"335\":1,\"336\":1,\"338\":1,\"347\":2,\"348\":5,\"361\":25,\"362\":1,\"363\":1,\"366\":9,\"368\":5,\"371\":5,\"378\":1,\"390\":7,\"399\":5,\"400\":2,\"403\":1,\"404\":5,\"407\":2,\"408\":1,\"409\":1,\"413\":2,\"414\":2,\"416\":1,\"417\":1,\"419\":1,\"422\":5,\"424\":9,\"425\":2,\"428\":6,\"429\":2,\"430\":2,\"431\":6,\"433\":1,\"435\":1,\"446\":2,\"447\":14,\"454\":6,\"459\":1,\"462\":4,\"468\":8,\"471\":1,\"473\":2,\"474\":2,\"476\":7,\"490\":2,\"491\":11,\"492\":4,\"493\":1,\"494\":1,\"495\":2,\"496\":1,\"497\":4,\"499\":1,\"506\":7,\"509\":2,\"519\":4,\"520\":2,\"525\":1,\"526\":2,\"528\":7,\"529\":1,\"534\":1,\"535\":1,\"542\":1,\"545\":1,\"548\":7,\"549\":5,\"553\":3,\"555\":2,\"556\":3,\"557\":4,\"567\":12,\"569\":31,\"570\":26,\"571\":62,\"572\":39,\"573\":33,\"574\":67,\"576\":8,\"577\":9,\"578\":18,\"579\":15,\"580\":14,\"581\":17,\"587\":2,\"592\":2,\"598\":11,\"609\":2,\"611\":4,\"621\":2,\"624\":5,\"633\":1,\"897\":5,\"917\":2,\"918\":1,\"921\":1,\"927\":3,\"928\":2,\"929\":3,\"930\":1,\"931\":1,\"940\":2,\"953\":2,\"954\":2,\"963\":4,\"996\":1,\"1003\":5,\"1012\":1,\"1022\":2,\"1023\":1,\"1024\":2,\"1029\":3,\"1030\":2,\"1032\":1,\"1052\":2,\"1053\":8,\"1063\":1,\"1064\":1,\"1065\":1,\"1072\":5,\"1082\":1,\"1084\":5,\"1091\":3,\"1103\":3,\"1110\":1,\"1113\":1,\"1116\":1,\"1120\":1,\"1130\":1,\"1131\":1,\"1133\":1,\"1139\":1,\"1140\":6,\"1146\":1,\"1166\":1,\"1226\":2,\"1227\":1,\"1234\":1,\"1238\":1,\"1240\":1,\"1263\":2,\"1265\":1,\"1288\":2,\"1292\":1,\"1328\":1,\"1351\":1,\"1357\":2,\"1404\":6,\"1412\":2,\"1447\":1,\"1479\":13,\"1480\":2,\"1482\":2,\"1484\":1,\"1490\":1,\"1498\":2,\"1501\":2,\"1502\":1,\"1503\":5,\"1506\":3,\"1548\":5,\"1549\":2,\"1550\":5,\"1553\":2,\"1554\":14,\"1573\":1,\"1574\":1,\"1575\":2,\"1582\":2,\"1585\":2,\"1594\":2,\"1595\":4,\"1597\":2,\"1598\":9,\"1599\":4,\"1600\":1,\"1601\":1,\"1607\":1,\"1609\":4,\"1610\":14,\"1614\":1,\"1617\":7,\"1618\":2,\"1620\":6,\"1621\":1,\"1622\":1,\"1640\":1,\"1647\":1,\"1648\":4,\"1651\":1,\"1654\":1,\"1655\":1,\"1658\":1,\"1664\":1}}],[\"例如调用类的main\",{\"1\":{\"1663\":1}}],[\"例如foreachremaining\",{\"1\":{\"1620\":1}}],[\"例如binaryoperator\",{\"1\":{\"1600\":1}}],[\"例如实现动态创建属性\",{\"1\":{\"1558\":1}}],[\"例如put新键值对\",{\"1\":{\"1546\":1}}],[\"例如程序执行如下代码\",{\"1\":{\"1546\":1}}],[\"例如引入了红黑树的数据结构和扩容优化等\",{\"1\":{\"1545\":1}}],[\"例如定时任务\",{\"1\":{\"1533\":1}}],[\"例如go语言\",{\"1\":{\"1533\":1}}],[\"例如父进程的地址空间用到了1g的内存\",{\"1\":{\"1527\":1}}],[\"例如常用的string\",{\"1\":{\"1526\":1}}],[\"例如第三方库在捕获到thread\",{\"1\":{\"1524\":1}}],[\"例如arrayblockingqueue如果容量满了\",{\"1\":{\"1501\":1}}],[\"例如antlr4\",{\"1\":{\"513\":1}}],[\"例如linkedblockingqueue的上限是integer\",{\"1\":{\"1501\":1}}],[\"例如赋值给类变量或可以在其它线程中访问的实例变量\",{\"1\":{\"1488\":1}}],[\"例如作为调用参数传递到其他方法中\",{\"1\":{\"1488\":1}}],[\"例如固定大小\",{\"1\":{\"1457\":1}}],[\"例如相册服务器\",{\"1\":{\"1421\":1}}],[\"例如聊天室\",{\"1\":{\"1421\":1}}],[\"例如concurrenthashmap\",{\"1\":{\"1416\":1}}],[\"例如string\",{\"1\":{\"1416\":1}}],[\"例如synchronized\",{\"1\":{\"1399\":1}}],[\"例如select\",{\"1\":{\"366\":1}}],[\"例如使用java\",{\"1\":{\"1620\":1}}],[\"例如使用sychronized代码块\",{\"1\":{\"1391\":1}}],[\"例如使用单独的汇总表\",{\"1\":{\"390\":1}}],[\"例如hashmap\",{\"1\":{\"1342\":1}}],[\"例如java\",{\"1\":{\"1337\":1,\"1620\":1}}],[\"例如jdbc\",{\"1\":{\"906\":1}}],[\"例如如何保证消息不丢失\",{\"1\":{\"1326\":1}}],[\"例如一个员工构成的流的工资的总数\",{\"1\":{\"1615\":1}}],[\"例如一个user表\",{\"1\":{\"1270\":1}}],[\"例如一个语句要删除100万行数据\",{\"1\":{\"462\":1}}],[\"例如按地区分片\",{\"1\":{\"1270\":1}}],[\"例如redis\",{\"1\":{\"1248\":1}}],[\"例如range查询\",{\"1\":{\"309\":1}}],[\"例如token和请求的url进行组装在一起形成令牌\",{\"1\":{\"1248\":1}}],[\"例如可以搭建在其它服务器上\",{\"1\":{\"1219\":1}}],[\"例如反射\",{\"1\":{\"891\":1}}],[\"例如秒杀场景\",{\"1\":{\"626\":1}}],[\"例如当系统运行不正常时发邮件通知相关人员\",{\"1\":{\"624\":1}}],[\"例如myisam这种不支持事务的引擎\",{\"1\":{\"438\":1}}],[\"例如下面使用聚合函数count\",{\"1\":{\"390\":1}}],[\"例如在订单中orderid\",{\"1\":{\"1329\":1}}],[\"例如在usermappper\",{\"1\":{\"1219\":1}}],[\"例如在做一个关联查询时\",{\"1\":{\"389\":1}}],[\"例如在新闻网站中取出100条记录\",{\"1\":{\"383\":1}}],[\"例如身份证号\",{\"1\":{\"352\":1}}],[\"例如邮箱\",{\"1\":{\"349\":1}}],[\"例如地理位置信息\",{\"1\":{\"309\":1}}],[\"例如字符串\",{\"1\":{\"309\":1}}],[\"例如\",{\"1\":{\"299\":1,\"304\":1,\"386\":1,\"390\":1,\"393\":1,\"394\":2,\"441\":1,\"457\":1,\"537\":1,\"1284\":1,\"1385\":1,\"1479\":1,\"1561\":1,\"1593\":1,\"1594\":1,\"1609\":1,\"1611\":1,\"1618\":3,\"1620\":2,\"1623\":1}}],[\"并赋予默认值\",{\"1\":{\"1663\":1}}],[\"并赋初始值\",{\"1\":{\"1433\":1}}],[\"并判断当前某个bean是否有匹配的advisor\",{\"1\":{\"1655\":1}}],[\"并添加到beanfactory的beanpostprocessors属性中去\",{\"1\":{\"1651\":1}}],[\"并获取类上的注解信息\",{\"1\":{\"1646\":1}}],[\"并获取了类名\",{\"1\":{\"1646\":1}}],[\"并获取旧值\",{\"1\":{\"1288\":1}}],[\"并提供了一些工具类\",{\"1\":{\"1646\":1}}],[\"并提供多种语言的api\",{\"1\":{\"564\":1}}],[\"并注册到applicationcontext中\",{\"1\":{\"1632\":1}}],[\"并放入spring容器中\",{\"1\":{\"1632\":1}}],[\"并放大的\",{\"1\":{\"1620\":1}}],[\"并生成构造方法\",{\"1\":{\"1613\":1}}],[\"并生成无参构造方法和setter及getter方法\",{\"1\":{\"1600\":1}}],[\"并流行并不一定就比串行流的效率高\",{\"1\":{\"1612\":1}}],[\"并与当前对象进行比较\",{\"1\":{\"1605\":1}}],[\"并更新sizectl的值\",{\"1\":{\"1554\":1}}],[\"并更新内存\",{\"1\":{\"324\":1}}],[\"并对null做处理\",{\"1\":{\"1549\":1}}],[\"并最终使用locksupport\",{\"1\":{\"1520\":1}}],[\"并让出cpu\",{\"1\":{\"1520\":1}}],[\"并让线程们重新执行一次\",{\"1\":{\"1496\":1}}],[\"并在此基础上进行了丰富地扩展\",{\"1\":{\"1518\":1}}],[\"并在java8中得到广泛应用\",{\"1\":{\"1510\":1}}],[\"并期望它们全部执行结束后执行特定动作\",{\"1\":{\"1516\":1}}],[\"并减少竞争\",{\"1\":{\"1514\":1}}],[\"并根据设定将这些任务拆分为粒度更细的子任务\",{\"1\":{\"1510\":1}}],[\"并唤醒第一个线程\",{\"1\":{\"1483\":1}}],[\"并清除中断标志位\",{\"1\":{\"1477\":1}}],[\"并清空binlog\",{\"1\":{\"450\":1}}],[\"并引入更灵活和可调整大小的内存区域\",{\"1\":{\"1457\":1}}],[\"并映射成jvm认可的数据结构\",{\"1\":{\"1433\":1}}],[\"并同步连接双方的序列号和确认号\",{\"1\":{\"1425\":1}}],[\"并确保这一结果和顺序执行的结果是一直的\",{\"1\":{\"1405\":1}}],[\"并使用equals方法来比较key是否相等\",{\"1\":{\"1367\":1}}],[\"并使用二分查找判断事务id是否在\",{\"1\":{\"542\":1}}],[\"并复制其内容\",{\"1\":{\"1344\":1}}],[\"并伴随着很多的问题\",{\"1\":{\"1326\":1}}],[\"并排序\",{\"1\":{\"1256\":1}}],[\"并设置得比初始值要大\",{\"1\":{\"1664\":1}}],[\"并设置beanclass为user\",{\"1\":{\"1632\":1}}],[\"并设置超时时间为\",{\"1\":{\"1248\":1}}],[\"并设置我们自定义的注解\",{\"1\":{\"967\":1}}],[\"并设置新的值\",{\"1\":{\"570\":1}}],[\"并是拥抱企业环境的java语言\",{\"1\":{\"902\":1}}],[\"并通知应用方\",{\"1\":{\"621\":1}}],[\"并将用户头像等信息存于七牛云服务器\",{\"1\":{\"1987\":1}}],[\"并将container处理的结果返回给外部\",{\"1\":{\"1687\":1}}],[\"并将任务添加到任务队列中\",{\"1\":{\"1535\":1}}],[\"并将其加入到clh同步队列\",{\"1\":{\"1491\":1}}],[\"并将其归类为方法区\",{\"1\":{\"1457\":1}}],[\"并将其定义为方法区\",{\"1\":{\"1457\":1}}],[\"并将已经写入的部分数据进行回滚\",{\"1\":{\"1297\":1}}],[\"并将结果缓存起来\",{\"1\":{\"1283\":1}}],[\"并将结果保存到\",{\"1\":{\"578\":1}}],[\"并将这些数据的文档id\",{\"1\":{\"1256\":1}}],[\"并将这些对象赋予当前对象\",{\"1\":{\"1234\":1}}],[\"并将校验失败的内容输出至errors对象\",{\"1\":{\"1061\":1}}],[\"并将对象设置到该属性\",{\"1\":{\"952\":2}}],[\"并将它抓取出来\",{\"1\":{\"430\":1}}],[\"并集\",{\"1\":{\"572\":1}}],[\"并返回一个结果\",{\"1\":{\"1598\":1,\"1600\":1}}],[\"并返回1\",{\"1\":{\"1288\":1}}],[\"并返回0\",{\"1\":{\"573\":1}}],[\"并返回增量后结果\",{\"1\":{\"573\":1}}],[\"并返回\",{\"1\":{\"570\":1,\"571\":2}}],[\"并返回结果给客户端\",{\"1\":{\"381\":1}}],[\"并发参考手册\",{\"1\":{\"1992\":1}}],[\"并发编程视频\",{\"1\":{\"1992\":1}}],[\"并发编程实战\",{\"1\":{\"1992\":1}}],[\"并发编程的艺术\",{\"1\":{\"1968\":1,\"1992\":1}}],[\"并发编程的三要素\",{\"0\":{\"44\":1,\"1373\":1}}],[\"并发框架\",{\"1\":{\"1992\":1}}],[\"并发方面\",{\"1\":{\"1992\":1}}],[\"并发消费\",{\"0\":{\"1860\":1,\"1900\":1}}],[\"并发的可达性分析\",{\"0\":{\"1762\":1}}],[\"并发的副作用就越小\",{\"1\":{\"532\":1}}],[\"并发重置\",{\"0\":{\"1738\":1}}],[\"并发清理\",{\"0\":{\"1737\":1}}],[\"并发清除\",{\"1\":{\"1447\":1}}],[\"并发流与串行流的区别并不是很大\",{\"1\":{\"1612\":1}}],[\"并发设计模式\",{\"0\":{\"1522\":1}}],[\"并发执行多任务\",{\"1\":{\"1516\":1}}],[\"并发安全的hashmap主要有两个\",{\"1\":{\"1475\":1}}],[\"并发要解决的三大问题\",{\"1\":{\"1470\":1}}],[\"并发三大特性\",{\"1\":{\"1470\":1}}],[\"并发与并行\",{\"1\":{\"1470\":1}}],[\"并发标记\",{\"0\":{\"1733\":1},\"1\":{\"1447\":1}}],[\"并发度最高\",{\"1\":{\"535\":1}}],[\"并发度最低\",{\"1\":{\"534\":1}}],[\"并发\",{\"1\":{\"532\":1,\"1441\":2,\"1470\":1}}],[\"并发事务处理带来的问题\",{\"1\":{\"532\":1}}],[\"并发线程的计数会减一\",{\"1\":{\"476\":1}}],[\"并发连接数达到几千个影响并不大\",{\"1\":{\"476\":1}}],[\"并发连接和并发查询并不是同一个概念\",{\"1\":{\"476\":1}}],[\"并反馈给客户端\",{\"1\":{\"472\":1}}],[\"并加1\",{\"1\":{\"468\":1}}],[\"并稳定执行一段时间之后\",{\"1\":{\"467\":1}}],[\"并行或者串行\",{\"1\":{\"1623\":1}}],[\"并行或并发\",{\"1\":{\"1441\":1}}],[\"并行的方式\",{\"1\":{\"1623\":1}}],[\"并行的\",{\"1\":{\"1620\":1}}],[\"并行的事务提交的时候\",{\"1\":{\"451\":1}}],[\"并行操作\",{\"1\":{\"1615\":1}}],[\"并行执行\",{\"1\":{\"1518\":1}}],[\"并行执行以下3个查询服务\",{\"1\":{\"1517\":1}}],[\"并行\",{\"1\":{\"1441\":3,\"1447\":1,\"1470\":1,\"1518\":1}}],[\"并行复制\",{\"0\":{\"460\":1}}],[\"并初始化几行数据\",{\"1\":{\"454\":1}}],[\"并执行\",{\"1\":{\"453\":1}}],[\"并没有返回相同的类型的对象\",{\"1\":{\"1615\":1}}],[\"并没有结构上的用处\",{\"1\":{\"1554\":1}}],[\"并没有更改原字符串里面value\",{\"1\":{\"1527\":1}}],[\"并没有使用零拷贝的方式\",{\"1\":{\"1330\":1,\"1331\":1}}],[\"并没有使用trade\",{\"1\":{\"368\":1}}],[\"并没有持久化\",{\"1\":{\"490\":1}}],[\"并没有去判断线程的状态\",{\"1\":{\"481\":1}}],[\"并没有数据持久化到磁盘\",{\"1\":{\"450\":1}}],[\"并没有给id=0这行加上锁\",{\"1\":{\"447\":1}}],[\"并insert一条记录\",{\"1\":{\"443\":1}}],[\"并保存future到futures\",{\"1\":{\"1517\":1}}],[\"并保存价格\",{\"1\":{\"1517\":1}}],[\"并保存最近15次的运行结果\",{\"1\":{\"431\":1}}],[\"并保存该单词在文本中的位置\",{\"1\":{\"299\":1}}],[\"并记为c\",{\"1\":{\"422\":1}}],[\"并把数据存储到内核缓冲区\",{\"1\":{\"1580\":1}}],[\"并把其值置空\",{\"1\":{\"1503\":1}}],[\"并把head下一个节点作为新的值\",{\"1\":{\"1503\":1}}],[\"并把语句改为id\",{\"1\":{\"416\":1}}],[\"并把binlog写入磁盘\",{\"1\":{\"326\":1}}],[\"并按照m的结果排序后输出\",{\"1\":{\"416\":1}}],[\"并按照id的值回到原表中取出city\",{\"1\":{\"355\":1}}],[\"并删除临时表\",{\"1\":{\"414\":1}}],[\"并存入临时表中\",{\"1\":{\"414\":1}}],[\"并利用这个线程id来构造临时表的table\",{\"1\":{\"413\":1}}],[\"并继续循环\",{\"1\":{\"404\":1}}],[\"并作为结果返回\",{\"1\":{\"404\":1}}],[\"并可以大概推算出查询运行的时间\",{\"1\":{\"387\":1}}],[\"并增加网络开销\",{\"1\":{\"382\":1}}],[\"并用最小的代价去执行语句\",{\"1\":{\"347\":1}}],[\"并分别建立索引\",{\"1\":{\"346\":1}}],[\"并非实际使用长度\",{\"1\":{\"330\":1}}],[\"并不具有实用性\",{\"1\":{\"1620\":1}}],[\"并不复制整个进程的地址空间\",{\"1\":{\"1527\":1}}],[\"并不需要等待\",{\"1\":{\"1564\":1}}],[\"并不需要考虑集合类的内部实现\",{\"1\":{\"1353\":1}}],[\"并不需要记录相应的undo\",{\"1\":{\"542\":1}}],[\"并不等待从节点复制完成\",{\"1\":{\"618\":1}}],[\"并不影响我们大方向上的分析\",{\"1\":{\"548\":1}}],[\"并不真正将过时的记录删除\",{\"1\":{\"542\":1}}],[\"并不敏感\",{\"1\":{\"532\":1}}],[\"并不能保证不可变性\",{\"1\":{\"1526\":1}}],[\"并不能保证它的索引列值是唯一的\",{\"1\":{\"558\":1}}],[\"并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中\",{\"1\":{\"557\":1}}],[\"并不能说明主库没问题\",{\"1\":{\"476\":1}}],[\"并不能精确地知道满足这个条件的记录有多少条\",{\"1\":{\"347\":1}}],[\"并不是所有的都需要实例化\",{\"1\":{\"1648\":1}}],[\"并不是所有场景中可以通过加索引来完成group\",{\"1\":{\"418\":1}}],[\"并不是对于集合中所有的元素先调用第一个filter方法\",{\"1\":{\"1611\":1}}],[\"并不是匿名内部类的语法糖或者另一种表达形式\",{\"1\":{\"1592\":1}}],[\"并不是原有的对象\",{\"1\":{\"1006\":1}}],[\"并不是非常耐久\",{\"1\":{\"592\":1}}],[\"并不是精确的\",{\"1\":{\"553\":1}}],[\"并不是这样的\",{\"1\":{\"492\":1}}],[\"并不是将这个记录本身从磁盘读出来\",{\"1\":{\"342\":1}}],[\"并不多\",{\"1\":{\"389\":1}}],[\"并不只是误操作以后需要用这个过程来恢复数据\",{\"1\":{\"327\":1}}],[\"并不会触发这个缓存\",{\"1\":{\"1648\":1}}],[\"并不会执行\",{\"1\":{\"1007\":1}}],[\"并不会修改任何用户记录\",{\"1\":{\"542\":1}}],[\"并不会导致主备延迟的值不准确\",{\"1\":{\"457\":1}}],[\"并不会导致过多的访问磁盘\",{\"1\":{\"420\":1}}],[\"并不会影响这个算法的时间复杂度\",{\"1\":{\"403\":1}}],[\"并不会影响其他操作\",{\"1\":{\"307\":1}}],[\"并不会覆盖以前的日志\",{\"1\":{\"325\":1}}],[\"并且给每个web应用创建一个类加载器实例\",{\"1\":{\"1693\":1}}],[\"并且tomcat本身也是一个java程序\",{\"1\":{\"1693\":1}}],[\"并且检查这个符号引用代表的类是否已经被加载\",{\"1\":{\"1666\":1}}],[\"并且检测是否需要扩容\",{\"1\":{\"1554\":1}}],[\"并且赋值给sqlsession属性\",{\"1\":{\"1653\":1}}],[\"并且提供获取bean的api\",{\"1\":{\"1636\":1}}],[\"并且会解析该类上的注解\",{\"1\":{\"1633\":1}}],[\"并且会调用arrays中的stream方法\",{\"1\":{\"1607\":1}}],[\"并且将结果传递给提供的sink\",{\"1\":{\"1623\":1}}],[\"并且将数据同步到对应的replica\",{\"1\":{\"1256\":1}}],[\"并且这部分内容面试也经常被问到\",{\"1\":{\"1969\":1}}],[\"并且这两种情况是互斥的\",{\"1\":{\"1622\":1}}],[\"并且这是一个终止操作\",{\"1\":{\"1622\":1}}],[\"并且这个集合不包含任何元素\",{\"1\":{\"1620\":1}}],[\"并且这个容器是通过更新结果的状态来进行合并的\",{\"1\":{\"1608\":1}}],[\"并且这个时候还没有进行类型转换\",{\"1\":{\"964\":1}}],[\"并且这个命令执行的速度较快\",{\"1\":{\"396\":1}}],[\"并且计算起来成本也不高\",{\"1\":{\"1620\":1}}],[\"并且还没有被分割或者迭代\",{\"1\":{\"1620\":1}}],[\"并且还可以通过isparallel\",{\"1\":{\"1619\":1}}],[\"并且还有其它的特性\",{\"1\":{\"1219\":1}}],[\"并且只接受一个参数\",{\"1\":{\"1618\":1}}],[\"并且只有当部分完成之后猜会进行合并的操作\",{\"1\":{\"1615\":1}}],[\"并且只有在mysql8\",{\"1\":{\"490\":1}}],[\"并且最终返回的结果也是set类型\",{\"1\":{\"1618\":1}}],[\"并且都是主线程的\",{\"1\":{\"1617\":1}}],[\"并且由于调用了reversed获取了新的比较器\",{\"1\":{\"1614\":1}}],[\"并且姓名这个字段会作为分组的key\",{\"1\":{\"1613\":1}}],[\"并且针对具体的操作\",{\"1\":{\"1611\":1}}],[\"并且流在调用的时候\",{\"1\":{\"1611\":1}}],[\"并且从易读性上而言\",{\"1\":{\"1611\":1}}],[\"并且也是一个终止操作\",{\"1\":{\"1608\":1}}],[\"并且没有设置过concurrent特性的时候才会创建和流中元素个数相同的中间结果容器\",{\"1\":{\"1617\":1}}],[\"并且没有返回值的函数式接口\",{\"1\":{\"1608\":1}}],[\"并且没有什么实质危害\",{\"1\":{\"497\":1}}],[\"并且调用foreach\",{\"1\":{\"1607\":1}}],[\"并且调用它的foreach\",{\"1\":{\"1607\":1}}],[\"并且调用了streamsupport这个类中的stream\",{\"1\":{\"1593\":1}}],[\"并且实现了操作的时候要使用的方法\",{\"1\":{\"1621\":1}}],[\"并且实现myinterface2\",{\"1\":{\"1607\":1}}],[\"并且实时备份binlog\",{\"1\":{\"485\":1}}],[\"并且接收两个相同类型的参数\",{\"1\":{\"1603\":1}}],[\"并且返回的结果要求带有排序的功能\",{\"1\":{\"1618\":1}}],[\"并且返回它们\",{\"1\":{\"1615\":1}}],[\"并且返回了一个map集合\",{\"1\":{\"1613\":1}}],[\"并且返回了不同类型的结果\",{\"1\":{\"1601\":1}}],[\"并且返回一个sink\",{\"1\":{\"1623\":1}}],[\"并且返回一个串行流\",{\"1\":{\"1620\":1}}],[\"并且返回一个结果\",{\"1\":{\"1603\":1,\"1623\":1}}],[\"并且返回一个int值\",{\"1\":{\"1603\":1}}],[\"并且返回一个泛型t类型的对象\",{\"1\":{\"1600\":1}}],[\"并且生成与运算对象相同类型的结果类型\",{\"1\":{\"1601\":1}}],[\"并且如果这个抽象方法是object类中的方法\",{\"1\":{\"1594\":1}}],[\"并且又再次收到了用户进程的system\",{\"1\":{\"1564\":1}}],[\"并且结束循环\",{\"1\":{\"1554\":1}}],[\"并且工作线程之间可以窃取彼此之间的任务\",{\"1\":{\"1510\":1}}],[\"并且根据缓存一执行协议\",{\"1\":{\"1473\":1}}],[\"并且所有缓冲的写操作写回内存\",{\"1\":{\"1473\":1}}],[\"并且所依赖的applicationcontext是需要有注解驱动能力的\",{\"1\":{\"1007\":1}}],[\"并且变化非常大\",{\"1\":{\"1453\":1}}],[\"并且功能越强大的证书费用越高\",{\"1\":{\"1424\":1}}],[\"并且https在面对ddos这样的攻击时\",{\"1\":{\"1424\":1}}],[\"并且费用一般不低\",{\"1\":{\"1424\":1}}],[\"并且连接比较长\",{\"1\":{\"1421\":1}}],[\"并且连接比较短\",{\"1\":{\"1421\":1}}],[\"并且超过了最大线程数时\",{\"1\":{\"1410\":1}}],[\"并且塞满了队列缓冲区\",{\"1\":{\"1410\":1}}],[\"并且写入慢也没有关系的场景\",{\"1\":{\"1403\":1}}],[\"并且永远也不需要额外的同步\",{\"1\":{\"1391\":1}}],[\"并且interrupted方法是static方法\",{\"1\":{\"1386\":1}}],[\"并且innodb使用了b+树索引模型\",{\"1\":{\"335\":1}}],[\"并且运维方式还都不一样\",{\"1\":{\"1304\":1}}],[\"并且该信息不存在于cookie当中\",{\"1\":{\"1201\":1}}],[\"并且对流中的每个元素都执行给定的动作\",{\"1\":{\"1623\":1}}],[\"并且对每个元素进行操作\",{\"1\":{\"1623\":1}}],[\"并且对于空的集合\",{\"1\":{\"1620\":1}}],[\"并且对于结果进行最终的转换\",{\"1\":{\"1615\":1}}],[\"并且对于流的操作也有短路的特性\",{\"1\":{\"1612\":1}}],[\"并且对于泛型的处理还存在bug\",{\"1\":{\"1118\":1}}],[\"并且对年龄进行降序排序\",{\"1\":{\"1611\":1}}],[\"并且对延时有比较严格的要求\",{\"1\":{\"1520\":1}}],[\"并且对象会经历初始化和销毁两个过程\",{\"1\":{\"987\":1}}],[\"并且为了更方便的操作\",{\"1\":{\"1108\":1}}],[\"并且使用spliterator的supplier重写stream和parallelstream方法\",{\"1\":{\"1620\":1}}],[\"并且使用哈希表的数据结构\",{\"1\":{\"1292\":1}}],[\"并且使用构造器注入的时候\",{\"1\":{\"1001\":1}}],[\"并且使用哪个索引是由mysql来确定的\",{\"1\":{\"346\":1}}],[\"并且自身不具备依赖查找的能力\",{\"1\":{\"948\":1}}],[\"并且自动重新统计数据的功能是打开的\",{\"1\":{\"559\":1}}],[\"并且支持可以运行在jvm上面的其他语言\",{\"1\":{\"902\":1}}],[\"并且每个元素会调用accumulator方法一次\",{\"1\":{\"1615\":1}}],[\"并且每个dubbo请求和响应中都有一个请求id\",{\"1\":{\"637\":1}}],[\"并且每个值的分布概率大约为50\",{\"1\":{\"359\":1}}],[\"并且保证数据尽量不丢失\",{\"1\":{\"621\":1}}],[\"并且redis事务没有隔离级别的概念\",{\"1\":{\"578\":1}}],[\"并且是线程安全的\",{\"1\":{\"1544\":1}}],[\"并且是阻塞的\",{\"1\":{\"1516\":1}}],[\"并且是在postprocessproperties之前执行的\",{\"1\":{\"964\":1}}],[\"并且是可执行的\",{\"1\":{\"624\":1}}],[\"并且是很小的\",{\"1\":{\"577\":1}}],[\"并且是采用\",{\"1\":{\"327\":1}}],[\"并且更新innodb\",{\"1\":{\"559\":1}}],[\"并且可以被并行的使用\",{\"1\":{\"1620\":1}}],[\"并且可以根据实际的需求对其进行扩展\",{\"1\":{\"1065\":1}}],[\"并且可以进行一些自定义的赋值\",{\"1\":{\"1002\":1}}],[\"并且可以通过如下语句查询\",{\"1\":{\"548\":1}}],[\"并且可以用上被驱动表的索引\",{\"1\":{\"401\":1}}],[\"并且用两个隐藏字段trx\",{\"1\":{\"542\":1}}],[\"并且用a\",{\"1\":{\"478\":1}}],[\"并且修改隐藏字段的事务id作为当前事务2的id\",{\"1\":{\"542\":1}}],[\"并且修改隐藏字段的事务id为当前事务1的id\",{\"1\":{\"542\":1}}],[\"并且dbsize\",{\"1\":{\"567\":1}}],[\"并且db\",{\"1\":{\"542\":1}}],[\"并且能使用auto\",{\"1\":{\"528\":1}}],[\"并且join\",{\"1\":{\"525\":1}}],[\"并且推荐使用整型的自增主键\",{\"1\":{\"505\":1}}],[\"并且在绑定之后\",{\"1\":{\"1620\":1}}],[\"并且在这个类中\",{\"1\":{\"1614\":1}}],[\"并且在很多情况下能够利用并行运行的代码\",{\"1\":{\"1591\":1}}],[\"并且在此基础上设计好的哈希算法来减少哈希碰撞\",{\"1\":{\"1546\":1}}],[\"并且在此基础上实现了master\",{\"1\":{\"564\":1}}],[\"并且在处理的时候\",{\"1\":{\"965\":1}}],[\"并且在postprocessproperties执行的时候会包含调用defaultlistablebeanfactory\",{\"1\":{\"964\":1}}],[\"并且在实现上\",{\"1\":{\"921\":1}}],[\"并且在spring\",{\"1\":{\"583\":1}}],[\"并且在1小时内发现了这个误操作命令\",{\"1\":{\"486\":1}}],[\"并且在超时时间n秒未达到之前就返回给了检测系统\",{\"1\":{\"478\":1}}],[\"并且在k上有索引\",{\"1\":{\"335\":1}}],[\"并且已经回复给客户端\",{\"1\":{\"472\":1}}],[\"并且已经执行完成了\",{\"1\":{\"472\":1}}],[\"并且已经将binlog传给了a\",{\"1\":{\"467\":1}}],[\"并且需要调整数据库连接信息\",{\"1\":{\"469\":1}}],[\"并且需要在临时表上排序\",{\"1\":{\"420\":1}}],[\"并且整体架构简单\",{\"1\":{\"469\":1}}],[\"并且此时在实例y上执行下面的这条插入语句\",{\"1\":{\"468\":1}}],[\"并且各个db的压力均衡\",{\"1\":{\"463\":1}}],[\"并且有返回值\",{\"1\":{\"1613\":1}}],[\"并且有以下限制\",{\"1\":{\"462\":1}}],[\"并且有三个用户并行的会话\",{\"1\":{\"396\":1}}],[\"并且设置备库breadonly=false\",{\"1\":{\"459\":1}}],[\"并且让备库可以读写\",{\"1\":{\"459\":1}}],[\"并且做对称部署\",{\"1\":{\"457\":1}}],[\"并且语句中有limit\",{\"1\":{\"454\":1}}],[\"并且记录了xid=61\",{\"1\":{\"454\":1}}],[\"并且并不是每次生成后都会持久化到磁盘中\",{\"1\":{\"451\":1}}],[\"并且把这个随机小数和word分别存入临时表的r和w字段中\",{\"1\":{\"420\":1}}],[\"并且\",{\"1\":{\"420\":1,\"446\":1,\"468\":1,\"487\":1,\"492\":1,\"527\":1,\"596\":1,\"1282\":1}}],[\"并且f是主键字段\",{\"1\":{\"414\":1}}],[\"并且查询语句如下\",{\"1\":{\"411\":1}}],[\"并且额外确保了\",{\"1\":{\"356\":1}}],[\"并且按照姓名排序返回前1000个人的姓名\",{\"1\":{\"353\":1}}],[\"并且mysql又选错了索引\",{\"1\":{\"347\":1}}],[\"并且当我们要对对应于这个索引的文档进行索引\",{\"1\":{\"303\":1}}],[\"并创建表字段\",{\"1\":{\"309\":1}}],[\"内容全面\",{\"1\":{\"1971\":1}}],[\"内容分别是\",{\"1\":{\"485\":1}}],[\"内核缓冲区和\",{\"1\":{\"1584\":1}}],[\"内核缓冲区后\",{\"1\":{\"1584\":1}}],[\"内核版本中\",{\"1\":{\"1582\":1,\"1583\":1,\"1584\":1}}],[\"内核空间总是驻留在内存中\",{\"1\":{\"1579\":1}}],[\"内核空间和用户空间\",{\"0\":{\"1579\":1}}],[\"内核模块运行在内核空间\",{\"1\":{\"1579\":1}}],[\"内核向进程返回一个文件描述符\",{\"1\":{\"1561\":1}}],[\"内核态\",{\"1\":{\"1483\":1}}],[\"内核就会向进程返回一个fd\",{\"1\":{\"1423\":1}}],[\"内置锁的并发性能已经基本与lock持平\",{\"1\":{\"1483\":1}}],[\"内置常用转化器实现\",{\"1\":{\"1092\":1}}],[\"内置复制\",{\"1\":{\"568\":1}}],[\"内省api\",{\"1\":{\"1075\":1}}],[\"内建扩展\",{\"1\":{\"1083\":1}}],[\"内建实现\",{\"1\":{\"1039\":1}}],[\"内建的propertysource\",{\"1\":{\"1154\":1}}],[\"内建的resource实现\",{\"0\":{\"1039\":1}}],[\"内建的非bean对象\",{\"1\":{\"918\":1}}],[\"内建接口\",{\"1\":{\"957\":1}}],[\"内建可查找的依赖\",{\"0\":{\"945\":1}}],[\"内建依赖\",{\"1\":{\"919\":1}}],[\"内部迭代和外部迭代\",{\"0\":{\"1611\":1}}],[\"内部有一个先进先出的阻塞队列\",{\"1\":{\"1517\":1}}],[\"内部锁\",{\"1\":{\"1502\":1}}],[\"内部使用的是迭代器\",{\"1\":{\"1353\":1}}],[\"内部api实现\",{\"1\":{\"1027\":1}}],[\"内部统计的方案主要是要利用磁盘利用率\",{\"1\":{\"479\":1}}],[\"内部统计\",{\"0\":{\"479\":1}}],[\"内部就已经自动完成了\",{\"1\":{\"468\":1}}],[\"内联编程\",{\"0\":{\"296\":1}}],[\"内存屏障\",{\"0\":{\"1764\":1}}],[\"内存屏障在linux系统x86中的实现\",{\"1\":{\"1473\":1}}],[\"内存管理\",{\"0\":{\"1697\":1}}],[\"内存映射\",{\"1\":{\"1586\":1}}],[\"内存结构\",{\"1\":{\"1509\":1}}],[\"内存动态分配\",{\"1\":{\"1457\":1}}],[\"内存泄漏\",{\"1\":{\"1451\":1}}],[\"内存溢出\",{\"1\":{\"1451\":1}}],[\"内存溢出和内存泄漏的区别\",{\"0\":{\"120\":1,\"1451\":1}}],[\"内存不够时一定会被gc\",{\"1\":{\"1435\":1}}],[\"内存是断电即失的\",{\"1\":{\"565\":1}}],[\"内存存储的数据结构服务器\",{\"1\":{\"568\":1}}],[\"内存存储\",{\"1\":{\"565\":1}}],[\"内存都不够用了\",{\"1\":{\"431\":1}}],[\"内存临时表排序的时候使用了rowid排序方法\",{\"1\":{\"421\":1}}],[\"内存临时表\",{\"0\":{\"420\":1}}],[\"内存临时表的大小是有限制的\",{\"1\":{\"416\":1}}],[\"内存可以放得下\",{\"1\":{\"416\":1}}],[\"内存里面也有一套机制区别不同的表\",{\"1\":{\"412\":1}}],[\"内存表\",{\"1\":{\"409\":1}}],[\"内存判断次数是不受选择哪个表作为驱动表影响的\",{\"1\":{\"403\":1}}],[\"内存判断是n\",{\"1\":{\"403\":1}}],[\"内存中的判断次数是m\",{\"1\":{\"403\":1}}],[\"内存中的行也比磁盘中的行的访问速度要快得多\",{\"1\":{\"389\":1}}],[\"内存和cpu的消耗\",{\"1\":{\"385\":1}}],[\"内存放不下\",{\"1\":{\"354\":1}}],[\"内存\",{\"1\":{\"345\":1,\"577\":1}}],[\"内存分页机制\",{\"0\":{\"293\":1}}],[\"内存淘汰策略是怎么样的\",{\"0\":{\"148\":1,\"1300\":1}}],[\"内存模型的原子性\",{\"0\":{\"100\":1,\"1431\":1}}],[\"d表示map返回的值的类型\",{\"1\":{\"1618\":1}}],[\"d>类型的\",{\"1\":{\"1618\":1}}],[\"d>类型\",{\"1\":{\"1618\":1}}],[\"d>>\",{\"1\":{\"1618\":5}}],[\"d>\",{\"1\":{\"1618\":9}}],[\"dma将磁盘数据复制到内核缓冲区kernel\",{\"1\":{\"1582\":1}}],[\"dma本质上是主板上一块独立的芯片\",{\"1\":{\"1578\":1}}],[\"dma\",{\"0\":{\"1578\":1,\"1583\":1},\"1\":{\"1578\":1,\"1582\":1,\"1583\":8,\"1584\":1,\"1585\":1}}],[\"dms\",{\"1\":{\"1055\":3,\"1167\":3}}],[\"df\",{\"1\":{\"1528\":1}}],[\"dspring\",{\"1\":{\"1147\":1}}],[\"dsl\",{\"0\":{\"308\":1},\"1\":{\"1254\":1}}],[\"djava\",{\"1\":{\"1049\":1}}],[\"daemon\",{\"1\":{\"1375\":1}}],[\"dangling\",{\"1\":{\"922\":1,\"1647\":1,\"1651\":1}}],[\"dao\",{\"1\":{\"893\":1,\"1236\":1}}],[\"dao支持\",{\"1\":{\"893\":1}}],[\"day\",{\"1\":{\"553\":1,\"558\":2}}],[\"dateformat\",{\"1\":{\"1528\":2}}],[\"date\",{\"1\":{\"393\":2,\"529\":1,\"645\":4,\"1053\":8,\"1092\":1,\"1599\":2,\"1605\":1}}],[\"datetime的存储格式是一个yyyymmdd\",{\"1\":{\"529\":1}}],[\"datetime来存储时间\",{\"1\":{\"529\":1}}],[\"datetime=t\",{\"1\":{\"467\":2}}],[\"datetime\",{\"1\":{\"366\":1,\"424\":1,\"506\":1,\"529\":1,\"1087\":2}}],[\"datagram\",{\"1\":{\"1419\":1}}],[\"data尽量使用固态硬盘\",{\"1\":{\"1257\":1}}],[\"datanode节点上的primary\",{\"1\":{\"1256\":1}}],[\"databinder是怎么完成属性类型转换的\",{\"0\":{\"1080\":1}}],[\"databinder与beanwrapper的联系\",{\"1\":{\"1076\":1}}],[\"databinder数据校验\",{\"0\":{\"1076\":1}}],[\"databinder特性二\",{\"1\":{\"1072\":2}}],[\"databinder特性一\",{\"1\":{\"1072\":2}}],[\"databinderdemo\",{\"1\":{\"1072\":2}}],[\"databinder绑定特殊场景分析\",{\"1\":{\"1072\":1}}],[\"databinder绑定控制参数\",{\"0\":{\"1072\":1},\"1\":{\"1072\":1}}],[\"databinder绑定方法bind\",{\"1\":{\"1070\":1}}],[\"databinder元数据\",{\"0\":{\"1071\":1},\"1\":{\"1071\":1}}],[\"databinder的核心属性\",{\"1\":{\"1070\":1}}],[\"databinder\",{\"1\":{\"1060\":1,\"1069\":1,\"1070\":1,\"1072\":13,\"1078\":1}}],[\"database\",{\"1\":{\"558\":1}}],[\"database参数\",{\"1\":{\"485\":1}}],[\"database命令删除的数据\",{\"1\":{\"485\":1}}],[\"database语句误删数据库\",{\"1\":{\"483\":1}}],[\"databases\",{\"1\":{\"482\":1,\"567\":2}}],[\"datasource\",{\"1\":{\"928\":4,\"1630\":1}}],[\"data这个参数来控制排序\",{\"1\":{\"520\":1}}],[\"data的值\",{\"1\":{\"520\":1}}],[\"data配置小点\",{\"1\":{\"520\":1}}],[\"data=16\",{\"1\":{\"421\":1}}],[\"data设置成16\",{\"1\":{\"421\":2}}],[\"data\",{\"1\":{\"355\":1,\"431\":1,\"439\":1,\"454\":1,\"460\":1,\"520\":4,\"542\":1,\"548\":2,\"553\":1,\"555\":2,\"583\":1,\"645\":3,\"892\":1,\"900\":1,\"1484\":1,\"1587\":2,\"1615\":3,\"1617\":1,\"1619\":1,\"1620\":7,\"1621\":2,\"1623\":10}}],[\"ddd要求领域是跟技术无关\",{\"1\":{\"1309\":1}}],[\"ddd只是一种方法论\",{\"1\":{\"1309\":1}}],[\"ddd是面对软件复杂之道\",{\"1\":{\"1309\":1}}],[\"ddd\",{\"1\":{\"891\":1,\"900\":1}}],[\"dddd\",{\"1\":{\"468\":3}}],[\"dd00\",{\"1\":{\"544\":3,\"547\":6,\"549\":6,\"553\":6,\"554\":6}}],[\"dd\",{\"1\":{\"529\":3,\"1053\":1,\"1528\":1}}],[\"ddl命令执行到最后阶段\",{\"1\":{\"481\":1}}],[\"d执行kill\",{\"1\":{\"481\":1}}],[\"dubbo是一个基于spring的rpc\",{\"1\":{\"1990\":1}}],[\"dubbo一个高性能优秀的服务框架\",{\"1\":{\"1990\":1}}],[\"dubbo中有一种叫做forking的集群模式\",{\"1\":{\"1517\":1}}],[\"dubbo服务调用底层原理\",{\"0\":{\"642\":1}}],[\"dubbo服务注册与引入底层原理\",{\"0\":{\"639\":1}}],[\"dubbo协议虽好\",{\"1\":{\"637\":1}}],[\"dubbo协议由于请求中没有多余的无用的字节\",{\"1\":{\"637\":1}}],[\"dubbo协议\",{\"0\":{\"637\":1}}],[\"dubbo3\",{\"0\":{\"636\":1}}],[\"dubbo底层实现原理\",{\"0\":{\"635\":1}}],[\"dubbo\",{\"0\":{\"634\":1,\"1990\":1},\"1\":{\"1990\":2}}],[\"dump\",{\"1\":{\"586\":1}}],[\"duplicate\",{\"1\":{\"478\":1,\"494\":1}}],[\"durable\",{\"1\":{\"592\":1}}],[\"durability\",{\"1\":{\"432\":1}}],[\"duration\",{\"1\":{\"431\":3,\"553\":1,\"555\":2}}],[\"during\",{\"1\":{\"318\":1,\"481\":1,\"922\":1,\"1166\":1,\"1175\":1,\"1480\":1,\"1599\":4,\"1615\":1,\"1619\":1,\"1620\":1,\"1647\":3,\"1651\":1}}],[\"d中\",{\"1\":{\"476\":1}}],[\"d只需要分别执行change\",{\"1\":{\"468\":1}}],[\"d重新指向的这个过程\",{\"1\":{\"466\":1}}],[\"d也要改接到a\",{\"1\":{\"466\":1}}],[\"d指向的是主库a\",{\"1\":{\"466\":1}}],[\"d=d\",{\"1\":{\"1617\":4}}],[\"d=5\",{\"1\":{\"447\":6}}],[\"d=5这条语句\",{\"1\":{\"447\":1}}],[\"d=5这一行的c的值\",{\"1\":{\"447\":1}}],[\"d=100\",{\"1\":{\"447\":3}}],[\"d=20\",{\"1\":{\"321\":1}}],[\"d5\",{\"1\":{\"378\":1}}],[\"d4\",{\"1\":{\"378\":1}}],[\"d3\",{\"1\":{\"378\":1}}],[\"d2\",{\"1\":{\"378\":1}}],[\"d1\",{\"1\":{\"378\":1}}],[\"d\",{\"1\":{\"368\":12,\"429\":1,\"447\":4,\"448\":1,\"528\":1,\"534\":1,\"577\":1,\"946\":1,\"989\":1,\"1022\":1,\"1617\":11,\"1618\":3}}],[\"druid\",{\"1\":{\"1974\":1}}],[\"driven\",{\"1\":{\"900\":3,\"1309\":1,\"1565\":1}}],[\"drop权限\",{\"1\":{\"487\":1}}],[\"drop语句\",{\"1\":{\"485\":1}}],[\"drop\",{\"1\":{\"361\":1,\"362\":2,\"363\":1,\"390\":2,\"400\":1,\"404\":1,\"412\":1,\"413\":5,\"426\":1,\"485\":1,\"506\":3,\"518\":1,\"523\":2,\"1271\":1}}],[\"dram\",{\"0\":{\"281\":1}}],[\"diagnostic\",{\"1\":{\"1620\":1}}],[\"didn\",{\"1\":{\"963\":1}}],[\"di\",{\"1\":{\"900\":1,\"1982\":1}}],[\"differences\",{\"1\":{\"1615\":1}}],[\"different\",{\"1\":{\"996\":1,\"1619\":1,\"1620\":1}}],[\"diff\",{\"1\":{\"558\":5}}],[\"directly\",{\"1\":{\"1619\":1}}],[\"directory\",{\"1\":{\"908\":1}}],[\"direction\",{\"1\":{\"519\":1,\"520\":2}}],[\"dir\",{\"1\":{\"624\":1,\"1040\":1,\"1041\":1,\"1043\":1,\"1044\":1}}],[\"dirty\",{\"1\":{\"433\":1,\"532\":1}}],[\"digits\",{\"1\":{\"429\":1}}],[\"disruptor<>\",{\"1\":{\"1521\":1}}],[\"disruptor<orderevent>\",{\"1\":{\"1521\":1}}],[\"disruptordemo\",{\"1\":{\"1521\":1}}],[\"disruptor实战\",{\"0\":{\"1521\":1}}],[\"disruptor\",{\"1\":{\"1520\":1,\"1521\":7}}],[\"disruptor的构造方法\",{\"1\":{\"1520\":1}}],[\"disruptor的核心概念\",{\"1\":{\"1520\":1}}],[\"disruptor会提供多种策略\",{\"1\":{\"1520\":1}}],[\"disruptor通过以下设计来解决队列速度慢的问题\",{\"1\":{\"1519\":1}}],[\"disruptor本质上是一个有界队列\",{\"1\":{\"1519\":1}}],[\"disruptor是一个高性能的队列\",{\"1\":{\"1519\":1}}],[\"disallowedfields\",{\"1\":{\"1072\":1}}],[\"disturbance\",{\"1\":{\"1053\":2}}],[\"distinct\",{\"1\":{\"350\":5,\"352\":1,\"519\":1,\"1600\":2,\"1609\":2,\"1610\":5,\"1620\":5,\"1622\":1,\"1623\":3}}],[\"disposable\",{\"1\":{\"1647\":1}}],[\"disposablebean\",{\"1\":{\"933\":3,\"985\":1,\"1234\":1}}],[\"dispatcherservlet\",{\"1\":{\"1657\":1,\"1658\":4}}],[\"dispatcherservlet将modelandview中的model交给对应的view进行视图的渲染\",{\"1\":{\"1241\":1}}],[\"dispatcherservlet根据modelandview中的viewresolver\",{\"1\":{\"1241\":1}}],[\"dispatcherservlet通过handlermapping去查找当前请求url对应的handler\",{\"1\":{\"1241\":1}}],[\"displayreturntypegenericinfo\",{\"1\":{\"1100\":4}}],[\"displayobjectproviderstreamops\",{\"1\":{\"944\":3}}],[\"displayobjectproviderifavailable\",{\"1\":{\"944\":3}}],[\"displaylistablebeanfactorygetbeanstype\",{\"1\":{\"944\":3}}],[\"displaybeanfactorygetobject\",{\"1\":{\"944\":3}}],[\"displaybeanfactorygetbean\",{\"1\":{\"944\":3}}],[\"displayserviceloader\",{\"1\":{\"930\":3}}],[\"discardpolicy\",{\"1\":{\"1410\":1,\"1476\":1}}],[\"discardoldestpolicy\",{\"1\":{\"1410\":1,\"1476\":1}}],[\"discard命令来提交\",{\"1\":{\"1297\":1}}],[\"discarded\",{\"1\":{\"580\":1}}],[\"discard\",{\"1\":{\"579\":1,\"582\":1}}],[\"discurd\",{\"1\":{\"579\":1}}],[\"disk\",{\"1\":{\"421\":1,\"431\":1,\"451\":1,\"557\":2}}],[\"divided\",{\"1\":{\"1621\":1}}],[\"divides\",{\"1\":{\"1620\":1}}],[\"dive了\",{\"1\":{\"553\":1}}],[\"dive的方式来计算查询成本\",{\"1\":{\"553\":1}}],[\"dive的方式简单\",{\"1\":{\"553\":1}}],[\"dive的方式计算各个单点区间的索引记录条数\",{\"1\":{\"553\":1}}],[\"dive的方式计算各个单点区间对应的记录数\",{\"1\":{\"553\":1}}],[\"dive的方式去计算这些单点区间对应的记录数也不是什么问题\",{\"1\":{\"553\":1}}],[\"dive操作\",{\"1\":{\"553\":1}}],[\"dive\",{\"0\":{\"553\":1},\"1\":{\"553\":5}}],[\"dives\",{\"1\":{\"519\":1}}],[\"div\",{\"1\":{\"419\":3}}],[\"dinosaur\",{\"1\":{\"384\":1}}],[\"dinosaur中出现的演员\",{\"1\":{\"384\":1}}],[\"dictionary\",{\"1\":{\"308\":1,\"564\":1}}],[\"dictionary中的范围\",{\"1\":{\"308\":1}}],[\"dynamically\",{\"1\":{\"1647\":1}}],[\"dynamic设置成strict\",{\"1\":{\"309\":1}}],[\"dynamic设置为strict\",{\"1\":{\"309\":1}}],[\"dynamic设为false\",{\"1\":{\"309\":1}}],[\"dynamic设为true时\",{\"1\":{\"309\":1}}],[\"dynamic\",{\"1\":{\"309\":4,\"645\":1,\"1658\":1}}],[\"dequeue\",{\"1\":{\"1502\":2,\"1503\":2}}],[\"deepin\",{\"1\":{\"1966\":1}}],[\"deep\",{\"1\":{\"997\":1}}],[\"demo\",{\"1\":{\"955\":3,\"961\":25,\"962\":8,\"963\":3,\"973\":1,\"978\":4,\"995\":2,\"1181\":3,\"1201\":1,\"1487\":2}}],[\"demoserviceloader\",{\"1\":{\"930\":2}}],[\"despite\",{\"1\":{\"1620\":1}}],[\"desirability\",{\"1\":{\"1620\":1}}],[\"desired\",{\"1\":{\"1619\":1}}],[\"designed\",{\"1\":{\"1615\":1,\"1619\":1,\"1620\":2}}],[\"design\",{\"1\":{\"1309\":1}}],[\"destoremethodname\",{\"1\":{\"1632\":1}}],[\"destorybean\",{\"1\":{\"1017\":2}}],[\"destory\",{\"1\":{\"933\":2,\"985\":5,\"1012\":1,\"1020\":1,\"1234\":1}}],[\"destory=\",{\"1\":{\"933\":2}}],[\"destchannel\",{\"1\":{\"1588\":3}}],[\"dest\",{\"1\":{\"1479\":10}}],[\"destructionawarebeanpostprocessor\",{\"1\":{\"1011\":2}}],[\"destruction\",{\"1\":{\"927\":1,\"1175\":1,\"1647\":1}}],[\"destroysingleton\",{\"1\":{\"1647\":1}}],[\"destroysingletons\",{\"1\":{\"1013\":1}}],[\"destroybean\",{\"1\":{\"1011\":1,\"1012\":1}}],[\"destroybeans\",{\"1\":{\"922\":1,\"1163\":1,\"1175\":1,\"1647\":1,\"1651\":2}}],[\"destroymethod\",{\"1\":{\"933\":1}}],[\"destroy\",{\"1\":{\"922\":1,\"933\":4,\"985\":1,\"1012\":2,\"1175\":1,\"1647\":1,\"1651\":1}}],[\"destkey\",{\"1\":{\"577\":1,\"578\":2}}],[\"destination\",{\"1\":{\"571\":2,\"572\":4,\"574\":2}}],[\"describes\",{\"1\":{\"1621\":1,\"1623\":2}}],[\"describe\",{\"1\":{\"1619\":1,\"1620\":1}}],[\"described\",{\"1\":{\"1619\":1,\"1623\":3}}],[\"describing\",{\"1\":{\"1619\":1}}],[\"descriptor\",{\"1\":{\"963\":45,\"1423\":1,\"1570\":1,\"1648\":47}}],[\"description=\",{\"1\":{\"1003\":1,\"1005\":1}}],[\"description\",{\"1\":{\"558\":1,\"1003\":12,\"1005\":6,\"1007\":6,\"1009\":2,\"1012\":7,\"1633\":1}}],[\"desc\",{\"1\":{\"306\":2,\"330\":1,\"361\":3,\"411\":3,\"414\":1,\"558\":1,\"1611\":1,\"1648\":5}}],[\"dep\",{\"1\":{\"1647\":6}}],[\"depensdon注解\",{\"1\":{\"1647\":1}}],[\"dependentbean\",{\"1\":{\"1647\":3}}],[\"dependentbeans\",{\"1\":{\"1647\":3}}],[\"dependencies\",{\"1\":{\"519\":2,\"927\":1,\"964\":1,\"1648\":1}}],[\"dependency以及\",{\"1\":{\"980\":1}}],[\"dependency作为依赖来源\",{\"0\":{\"977\":1}}],[\"dependencysourcedemo\",{\"1\":{\"973\":4}}],[\"dependencyobjectprovider中看到相关的原理\",{\"1\":{\"1181\":1}}],[\"dependencyobjectprovider\",{\"1\":{\"963\":1,\"1648\":1}}],[\"dependencydescriptor\",{\"1\":{\"963\":6,\"1648\":7}}],[\"dependencyinjectiondemo\",{\"1\":{\"918\":1,\"919\":1}}],[\"dependencylookupdemo\",{\"1\":{\"917\":1}}],[\"dependency>\",{\"1\":{\"582\":2,\"583\":1,\"965\":1}}],[\"dependency\",{\"1\":{\"465\":1,\"917\":3,\"918\":3,\"919\":1,\"921\":1,\"924\":2,\"930\":1,\"953\":5,\"954\":3,\"955\":1,\"961\":3,\"962\":1,\"963\":1,\"974\":1,\"982\":1,\"994\":1,\"997\":1,\"1000\":1,\"1001\":2,\"1005\":4,\"1006\":2,\"1011\":2,\"1022\":1,\"1029\":1,\"1084\":1,\"1091\":1,\"1146\":1,\"1647\":1,\"1648\":1}}],[\"depend\",{\"1\":{\"1619\":1}}],[\"depending\",{\"1\":{\"1615\":2}}],[\"dependcy\",{\"1\":{\"953\":2,\"954\":2}}],[\"dependson\",{\"1\":{\"1633\":1,\"1647\":3}}],[\"depends\",{\"1\":{\"519\":2,\"1647\":2}}],[\"departures\",{\"1\":{\"1620\":1}}],[\"department\",{\"1\":{\"1615\":1,\"1616\":2}}],[\"deprecated\",{\"1\":{\"1040\":1}}],[\"depth\",{\"1\":{\"1620\":1,\"1621\":2,\"1622\":2,\"1623\":1}}],[\"depth值相同数量的表进行穷举分析\",{\"1\":{\"556\":1}}],[\"depth系统变量\",{\"1\":{\"556\":1}}],[\"decomposition\",{\"1\":{\"1620\":2}}],[\"declaratively\",{\"1\":{\"1619\":1}}],[\"declaration\",{\"1\":{\"1594\":5}}],[\"declaringclass\",{\"1\":{\"963\":1}}],[\"declareparents动态的为被代理对象增加接口和接口中定义的方法\",{\"1\":{\"1654\":1}}],[\"declared\",{\"1\":{\"1619\":2}}],[\"declares\",{\"1\":{\"1594\":2}}],[\"declare\",{\"1\":{\"400\":1,\"404\":1,\"414\":1,\"419\":1,\"518\":1,\"523\":2}}],[\"decapitalize\",{\"1\":{\"928\":1,\"995\":1}}],[\"decrease\",{\"1\":{\"1620\":1}}],[\"decreasing\",{\"1\":{\"1620\":1}}],[\"decrement\",{\"1\":{\"1482\":3}}],[\"decrby\",{\"1\":{\"570\":2,\"581\":2}}],[\"decr\",{\"1\":{\"570\":2}}],[\"decimal最适合保存准确度要求高\",{\"1\":{\"528\":1}}],[\"decimal\",{\"1\":{\"528\":1,\"645\":2}}],[\"deterministic\",{\"1\":{\"1620\":4}}],[\"determinetransactionmanager\",{\"1\":{\"1655\":1}}],[\"determinetargettype\",{\"1\":{\"1647\":1}}],[\"determineconstructorsfrombeanpostprocessors\",{\"1\":{\"1650\":1}}],[\"determine\",{\"1\":{\"1614\":1,\"1620\":2}}],[\"determinerequiredstatus\",{\"1\":{\"964\":1,\"1648\":2}}],[\"determineautowirecandidate\",{\"1\":{\"963\":1,\"1648\":1}}],[\"determinebeannamefromannotation\",{\"1\":{\"928\":1}}],[\"detected\",{\"1\":{\"1620\":4,\"1647\":1}}],[\"detection\",{\"1\":{\"1620\":1}}],[\"detecting\",{\"1\":{\"1164\":1,\"1166\":1}}],[\"detects\",{\"1\":{\"1619\":1,\"1620\":1}}],[\"detect\",{\"1\":{\"1164\":1,\"1165\":1,\"1619\":1}}],[\"detect=on来控制\",{\"1\":{\"444\":1}}],[\"detail里id=4的行记为r4\",{\"1\":{\"368\":1}}],[\"detail里的tradeied上的索引快速定位到等值的行\",{\"1\":{\"368\":1}}],[\"detail表上的tradeid字段的字符集也改成utf8mb4\",{\"1\":{\"368\":1}}],[\"detail表成了驱动表\",{\"1\":{\"368\":1}}],[\"detail表中查找条件匹配的行\",{\"1\":{\"368\":1}}],[\"detail上的tradeid索引\",{\"1\":{\"368\":1}}],[\"detail`\",{\"1\":{\"368\":1}}],[\"detail这两个表里插入一些数据\",{\"1\":{\"368\":1}}],[\"detail\",{\"1\":{\"368\":18,\"1615\":1}}],[\"details\",{\"1\":{\"330\":1,\"561\":1,\"1620\":1,\"1621\":1,\"1649\":1}}],[\"dealing\",{\"1\":{\"1621\":1}}],[\"deallocate\",{\"1\":{\"422\":1}}],[\"deadlock\",{\"1\":{\"444\":1}}],[\"debug\",{\"1\":{\"429\":3,\"996\":1,\"1022\":1,\"1175\":1,\"1479\":7}}],[\"defining\",{\"1\":{\"1432\":1,\"1663\":1}}],[\"definitionholder\",{\"1\":{\"1027\":4,\"1647\":5}}],[\"definitions\",{\"1\":{\"1022\":3,\"1029\":2,\"1031\":1}}],[\"definition\",{\"1\":{\"928\":14,\"930\":3,\"975\":2,\"995\":2,\"996\":7,\"997\":7,\"1163\":1,\"1171\":1,\"1594\":3,\"1647\":9,\"1648\":1,\"1651\":1}}],[\"defined\",{\"1\":{\"996\":1,\"1594\":2,\"1620\":1,\"1647\":1}}],[\"def\",{\"1\":{\"412\":5,\"413\":4,\"967\":3}}],[\"defaultadvisorautoproxycreator实际上是一个beanpostprocessor\",{\"1\":{\"1654\":1}}],[\"defaultadvisorautoproxycreator\",{\"1\":{\"1654\":6}}],[\"defaultpointcutadvisor\",{\"1\":{\"1654\":8}}],[\"defaultparameternamediscoverer\",{\"1\":{\"1648\":2}}],[\"defaultpropertiesresource\",{\"1\":{\"1044\":2}}],[\"defaults\",{\"1\":{\"1550\":1}}],[\"defaultsingletonbeanregistry\",{\"1\":{\"1182\":1,\"1184\":2,\"1636\":1,\"1647\":1}}],[\"defaultthreadfactory\",{\"1\":{\"1521\":1}}],[\"defaultformattingconversionservice\",{\"1\":{\"1092\":1}}],[\"defaultconversionservice\",{\"1\":{\"1092\":2,\"1151\":1}}],[\"defaultbeandefinitiondocumentreader\",{\"1\":{\"1025\":2}}],[\"defaultbeannamegenerator\",{\"1\":{\"928\":1}}],[\"defaultresourceloader\",{\"1\":{\"1022\":1,\"1041\":1}}],[\"defaulteventlistenerfactory对象\",{\"1\":{\"945\":1}}],[\"defaultuserfactory\",{\"1\":{\"930\":2,\"931\":2,\"933\":2,\"936\":1}}],[\"defaultlistablebeanfactory的父类abstractautowirecapablebeanfactory的构造方法\",{\"1\":{\"1651\":1}}],[\"defaultlistablebeanfactory\",{\"1\":{\"921\":2,\"953\":2,\"954\":2,\"963\":1,\"994\":2,\"995\":2,\"996\":1,\"997\":2,\"1000\":2,\"1001\":2,\"1005\":2,\"1006\":2,\"1011\":2,\"1019\":2,\"1022\":2,\"1030\":2,\"1032\":2,\"1152\":1,\"1163\":4,\"1636\":1,\"1648\":3,\"1651\":3}}],[\"default\",{\"1\":{\"306\":1,\"330\":1,\"336\":2,\"338\":4,\"346\":2,\"353\":1,\"366\":4,\"368\":5,\"400\":2,\"419\":1,\"424\":2,\"429\":2,\"446\":2,\"454\":2,\"459\":1,\"462\":2,\"468\":1,\"476\":1,\"478\":1,\"489\":2,\"506\":7,\"510\":5,\"518\":5,\"523\":3,\"534\":2,\"535\":3,\"928\":1,\"961\":1,\"967\":1,\"978\":1,\"997\":1,\"1003\":2,\"1020\":12,\"1044\":1,\"1136\":4,\"1137\":3,\"1146\":2,\"1164\":1,\"1171\":1,\"1227\":3,\"1238\":1,\"1475\":1,\"1550\":4,\"1554\":1,\"1594\":8,\"1595\":2,\"1597\":1,\"1598\":6,\"1599\":6,\"1603\":1,\"1607\":2,\"1614\":1,\"1618\":1,\"1620\":14,\"1621\":2,\"1622\":1,\"1623\":5,\"1647\":1,\"1650\":1}}],[\"delivering\",{\"1\":{\"1623\":1}}],[\"delimiter\",{\"1\":{\"400\":2,\"404\":2,\"414\":2,\"419\":2,\"518\":2,\"523\":4,\"1618\":2}}],[\"del解锁\",{\"1\":{\"1288\":1}}],[\"delegate\",{\"1\":{\"1647\":1,\"1648\":1}}],[\"delegation\",{\"1\":{\"1647\":1}}],[\"delegatingmessagesource\",{\"1\":{\"1055\":3,\"1059\":1,\"1167\":2}}],[\"delete操作会加行锁\",{\"1\":{\"535\":1}}],[\"delete操作会自动给涉及的表加写锁\",{\"1\":{\"535\":1}}],[\"deleted\",{\"1\":{\"487\":1,\"542\":1}}],[\"delete命令的执行效果如下\",{\"1\":{\"454\":1}}],[\"delete和update\",{\"1\":{\"307\":1}}],[\"delete\",{\"1\":{\"306\":2,\"307\":3,\"309\":1,\"393\":2,\"454\":2,\"484\":2,\"541\":1,\"542\":2,\"1263\":1,\"1271\":1}}],[\"del\",{\"1\":{\"569\":2,\"1288\":1}}],[\"delayqueue\",{\"0\":{\"1508\":1},\"1\":{\"1395\":1,\"1501\":1}}],[\"delays\",{\"1\":{\"1175\":1}}],[\"delay=n命令\",{\"1\":{\"486\":1}}],[\"delay参数\",{\"1\":{\"465\":1}}],[\"delay设置为0的时候\",{\"1\":{\"451\":1}}],[\"delay表示延迟多少微妙后才调用fsync\",{\"1\":{\"451\":1}}],[\"delay\",{\"1\":{\"451\":4,\"465\":1}}],[\"delay和binlog\",{\"1\":{\"451\":2}}],[\"deviations\",{\"1\":{\"1620\":1}}],[\"device\",{\"1\":{\"557\":1}}],[\"development\",{\"1\":{\"900\":2,\"910\":1,\"912\":1,\"1337\":1}}],[\"developer\",{\"1\":{\"306\":4}}],[\"dev\",{\"1\":{\"372\":1,\"510\":2,\"518\":3}}],[\"derived\",{\"1\":{\"330\":1}}],[\"denied\",{\"1\":{\"318\":1,\"322\":1}}],[\"db8中并不能获取db0中的键值对\",{\"1\":{\"567\":1}}],[\"dbsize\",{\"1\":{\"567\":3}}],[\"dbsize可以查看当前数据库的大小\",{\"1\":{\"567\":1}}],[\"db1+t1+\",{\"1\":{\"462\":3}}],[\"dba\",{\"1\":{\"430\":1}}],[\"dba不让使用join\",{\"1\":{\"400\":1}}],[\"db的数据\",{\"1\":{\"307\":1}}],[\"db\",{\"1\":{\"305\":3,\"306\":26,\"307\":4,\"429\":1,\"542\":7,\"567\":2,\"569\":1}}],[\"dogetbean\",{\"1\":{\"1647\":2}}],[\"dogetbean方法是创建bean的核心方法\",{\"1\":{\"1647\":1}}],[\"doscan\",{\"1\":{\"1647\":1}}],[\"dosomething\",{\"1\":{\"1195\":1,\"1619\":4}}],[\"doing\",{\"1\":{\"1622\":1}}],[\"doinit\",{\"1\":{\"1531\":1}}],[\"doinvokelistener\",{\"1\":{\"1124\":2}}],[\"doprocessconfigurationclass\",{\"1\":{\"1155\":1}}],[\"doprivileged\",{\"1\":{\"1007\":1,\"1008\":1,\"1647\":2}}],[\"doparse\",{\"1\":{\"1030\":1}}],[\"doregisterbean\",{\"1\":{\"1027\":1}}],[\"doresolvedependency中\",{\"1\":{\"978\":1}}],[\"doresolvedependency\",{\"1\":{\"963\":2,\"1152\":1,\"1648\":2}}],[\"dom\",{\"1\":{\"1025\":1}}],[\"domain\",{\"1\":{\"900\":1,\"917\":2,\"930\":1,\"994\":1,\"1022\":1,\"1084\":1,\"1091\":1,\"1146\":1,\"1309\":1}}],[\"dowithlocalmethods\",{\"1\":{\"1648\":1}}],[\"dowithlocalfields\",{\"1\":{\"964\":1,\"1648\":1}}],[\"downstreamfinisher\",{\"1\":{\"1618\":2}}],[\"downstreamsupplier\",{\"1\":{\"1618\":2}}],[\"downstreamaccumulator\",{\"1\":{\"1618\":6}}],[\"downstream\",{\"1\":{\"1618\":34,\"1622\":1,\"1623\":13}}],[\"down\",{\"1\":{\"624\":2}}],[\"doesn\",{\"1\":{\"1620\":1}}],[\"does\",{\"1\":{\"963\":1,\"1594\":2,\"1617\":1,\"1619\":1,\"1620\":6,\"1622\":1,\"1623\":1}}],[\"dodestory\",{\"1\":{\"933\":4,\"1012\":2}}],[\"doubles\",{\"1\":{\"1623\":2}}],[\"doublestream\",{\"1\":{\"1619\":2}}],[\"doubleadder\",{\"1\":{\"1480\":1}}],[\"doubleaccumulator\",{\"1\":{\"1480\":1}}],[\"double\",{\"1\":{\"528\":1,\"645\":8,\"959\":1,\"1550\":1,\"1605\":1,\"1620\":2}}],[\"done\",{\"1\":{\"1621\":1}}],[\"don\",{\"1\":{\"429\":2}}],[\"do\",{\"1\":{\"393\":2,\"400\":1,\"404\":2,\"414\":1,\"419\":1,\"485\":1,\"498\":1,\"518\":1,\"523\":2,\"1170\":1,\"1175\":1,\"1201\":2,\"1479\":1,\"1550\":1,\"1615\":2,\"1619\":4,\"1620\":4,\"1623\":1,\"1647\":1,\"1648\":1,\"1689\":1}}],[\"docreatebean\",{\"1\":{\"1647\":2}}],[\"docker\",{\"1\":{\"1460\":1,\"1461\":1,\"1966\":2}}],[\"docker常用的命令\",{\"0\":{\"258\":1,\"1460\":1}}],[\"doclose\",{\"1\":{\"1175\":1}}],[\"doc中的例子\",{\"1\":{\"1061\":1}}],[\"documentreaderclass\",{\"1\":{\"1025\":1}}],[\"documentreader\",{\"1\":{\"1021\":2}}],[\"document\",{\"1\":{\"1021\":1,\"1254\":1,\"1620\":1}}],[\"documented注解的作用是\",{\"1\":{\"1133\":1}}],[\"documented\",{\"1\":{\"961\":3,\"967\":2,\"1133\":1,\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":3,\"1594\":1,\"1620\":3}}],[\"docs\",{\"1\":{\"307\":2,\"1627\":1}}],[\"doc\",{\"1\":{\"306\":26,\"307\":12,\"309\":2,\"1021\":2,\"1337\":1}}],[\"dokcer命令\",{\"0\":{\"257\":1,\"1459\":1}}],[\"dcl单例为什么加volatile\",{\"0\":{\"59\":1,\"1388\":1}}],[\"g=g\",{\"1\":{\"1617\":4}}],[\"guaranteed\",{\"1\":{\"1623\":1}}],[\"guarantee\",{\"1\":{\"1622\":1}}],[\"guarantees\",{\"1\":{\"1620\":2}}],[\"guard\",{\"1\":{\"1531\":1}}],[\"guarded\",{\"0\":{\"1530\":1},\"1\":{\"1530\":2}}],[\"gui交互\",{\"1\":{\"1085\":1}}],[\"guice\",{\"1\":{\"908\":1}}],[\"github\",{\"1\":{\"1981\":2,\"1986\":1}}],[\"git\",{\"0\":{\"1981\":1},\"1\":{\"1981\":8}}],[\"give\",{\"1\":{\"1647\":2}}],[\"given\",{\"1\":{\"997\":1,\"1595\":2,\"1597\":1,\"1598\":2,\"1599\":2,\"1615\":1,\"1618\":2,\"1620\":4,\"1622\":1,\"1623\":2}}],[\"gid方案\",{\"0\":{\"474\":1}}],[\"gbk\",{\"1\":{\"978\":1}}],[\"gc过程\",{\"0\":{\"1748\":1}}],[\"gc进行类型卸载\",{\"1\":{\"1664\":1}}],[\"gc初始阈值\",{\"1\":{\"1664\":1}}],[\"gc标记\",{\"1\":{\"1484\":1}}],[\"gc分代年龄\",{\"1\":{\"1484\":1}}],[\"gc各种算法优化的重点\",{\"1\":{\"1440\":1}}],[\"gc线程除外\",{\"1\":{\"1440\":1}}],[\"gc就会被标记为垃圾\",{\"1\":{\"1436\":1}}],[\"gc和bean的销毁是两个不同的概念\",{\"1\":{\"1011\":1}}],[\"gc\",{\"0\":{\"1751\":1,\"1752\":1},\"1\":{\"934\":2,\"1013\":3,\"1434\":6,\"1436\":1,\"1527\":1,\"1664\":2}}],[\"goals\",{\"1\":{\"1619\":1}}],[\"gof\",{\"0\":{\"853\":1}}],[\"gof23等\",{\"1\":{\"891\":1}}],[\"gof23\",{\"0\":{\"740\":1}}],[\"google\",{\"0\":{\"665\":1},\"1\":{\"908\":1}}],[\"gyc\",{\"1\":{\"573\":6}}],[\"gtids=own\",{\"1\":{\"474\":1}}],[\"gtid1\",{\"1\":{\"474\":1}}],[\"gtid分配给接下来要执行\",{\"1\":{\"468\":1}}],[\"gtid没有存在于实例的gtid集合中\",{\"1\":{\"468\":1}}],[\"gtid已经存在于实例的gtid集合中\",{\"1\":{\"468\":1}}],[\"gtid模式的启动需要在启动mysql实例的时候\",{\"1\":{\"468\":1}}],[\"gtid=source\",{\"1\":{\"468\":1}}],[\"gtid的全称是global\",{\"1\":{\"468\":1}}],[\"gtid\",{\"0\":{\"468\":1},\"1\":{\"454\":1,\"468\":10,\"472\":2,\"474\":4,\"485\":1}}],[\"garbage\",{\"0\":{\"1739\":1}}],[\"gained\",{\"1\":{\"1620\":1}}],[\"gather\",{\"0\":{\"1583\":1},\"1\":{\"1583\":3,\"1585\":1}}],[\"gateway有哪些功能\",{\"0\":{\"242\":1,\"1322\":1}}],[\"gap的一种特例\",{\"1\":{\"442\":1}}],[\"gap\",{\"1\":{\"442\":2,\"448\":1}}],[\"greater\",{\"1\":{\"1601\":2,\"1620\":1}}],[\"grep\",{\"1\":{\"429\":1,\"1464\":2}}],[\"grow\",{\"1\":{\"1475\":1}}],[\"grouping\",{\"1\":{\"1613\":1,\"1618\":1}}],[\"groupingby方法返回的collector不是并发的\",{\"1\":{\"1618\":1}}],[\"groupingby方法返回了完成对于给定t类型的层叠的分组操作的collector\",{\"1\":{\"1618\":1}}],[\"groupingbyconcurrent\",{\"1\":{\"1618\":3}}],[\"groupingby和partitioningby是整个collectors类中比较难以理解的两部分\",{\"1\":{\"1618\":1}}],[\"groupingby\",{\"1\":{\"1613\":6,\"1615\":3,\"1616\":5,\"1618\":7}}],[\"groupid>\",{\"1\":{\"582\":2,\"583\":1,\"965\":1}}],[\"groupedusers\",{\"1\":{\"961\":3}}],[\"group\",{\"0\":{\"415\":1,\"416\":1},\"1\":{\"358\":1,\"378\":4,\"390\":1,\"416\":3,\"417\":3,\"418\":2,\"431\":5,\"451\":9,\"464\":1,\"465\":2,\"519\":3,\"1226\":5,\"1613\":3,\"1616\":1,\"1618\":1}}],[\"grpc\",{\"0\":{\"681\":1}}],[\"grpc服务只会按照grpc的格式来解析字节流\",{\"1\":{\"637\":1}}],[\"globaladvisoradapterregistry\",{\"1\":{\"1654\":1}}],[\"globalerrors\",{\"1\":{\"1063\":1}}],[\"global\",{\"0\":{\"1753\":1},\"1\":{\"428\":4,\"438\":1,\"467\":1,\"476\":1,\"481\":1,\"496\":1,\"503\":1,\"526\":2,\"1262\":1}}],[\"geocoder\",{\"1\":{\"1517\":1}}],[\"georadius\",{\"1\":{\"576\":2}}],[\"georadiusbymember\",{\"1\":{\"576\":1}}],[\"geohash\",{\"1\":{\"576\":3}}],[\"geodist\",{\"1\":{\"576\":1}}],[\"geopos\",{\"1\":{\"576\":1}}],[\"geoadd\",{\"1\":{\"576\":1}}],[\"geospatial\",{\"0\":{\"576\":1},\"1\":{\"1280\":1}}],[\"generating\",{\"1\":{\"1619\":1}}],[\"generation\",{\"1\":{\"1457\":2}}],[\"generator\",{\"1\":{\"1619\":1,\"1620\":1}}],[\"generate\",{\"1\":{\"928\":3,\"1594\":2,\"1609\":1}}],[\"generatebeanname\",{\"1\":{\"928\":2,\"1027\":1,\"1647\":1}}],[\"generatedbeanname\",{\"1\":{\"928\":7}}],[\"generated\",{\"1\":{\"413\":3,\"417\":1,\"519\":2,\"928\":2,\"996\":1}}],[\"generally\",{\"1\":{\"1619\":1,\"1620\":1,\"1621\":1}}],[\"generalization\",{\"1\":{\"1618\":1}}],[\"general\",{\"1\":{\"959\":1}}],[\"genericwebapplicationcontext\",{\"1\":{\"1169\":1}}],[\"genericparametertype\",{\"1\":{\"1102\":1}}],[\"genericcollectiontypesolver在高版本的spring中已经移除\",{\"1\":{\"1101\":1}}],[\"genericcollectiontypesolver\",{\"1\":{\"1101\":1}}],[\"genericconversionservice实现\",{\"1\":{\"1092\":1}}],[\"genericconversionservice\",{\"1\":{\"1092\":1}}],[\"genericconverter优化接口\",{\"1\":{\"1090\":1}}],[\"genericconverter局限性\",{\"1\":{\"1090\":1}}],[\"genericconverter的介绍\",{\"1\":{\"1089\":1}}],[\"genericconverter接口\",{\"0\":{\"1089\":1}}],[\"genericconverter代替\",{\"1\":{\"1088\":1}}],[\"genericconverter\",{\"1\":{\"1086\":2,\"1089\":1,\"1090\":1,\"1091\":1,\"1096\":1}}],[\"generictyperesolver和genericcollectiontyperesolver替代者\",{\"1\":{\"1103\":1}}],[\"generictyperesolverdemo\",{\"1\":{\"1100\":4,\"1103\":1}}],[\"generictyperesolver\",{\"1\":{\"1100\":6}}],[\"genericapplicationcontext\",{\"1\":{\"1112\":2,\"1113\":2,\"1119\":2,\"1123\":2,\"1174\":2,\"1175\":2,\"1651\":1}}],[\"genericapidemo\",{\"1\":{\"1099\":1}}],[\"genericarraytype\",{\"1\":{\"1099\":1}}],[\"genericdeclaration\",{\"1\":{\"1099\":1}}],[\"genericbeandefinition\",{\"1\":{\"927\":6,\"929\":1,\"946\":2,\"953\":1,\"954\":1,\"1018\":1,\"1019\":1,\"1632\":2}}],[\"generic\",{\"1\":{\"425\":1,\"899\":1,\"1100\":2}}],[\"getwrappedclass\",{\"1\":{\"1647\":1}}],[\"getwrappedinstance\",{\"1\":{\"1647\":4}}],[\"getwritemethod\",{\"1\":{\"1075\":1}}],[\"getweight\",{\"1\":{\"1619\":3}}],[\"getoutputshape\",{\"1\":{\"1622\":1,\"1623\":1}}],[\"getoutputstream\",{\"1\":{\"1573\":2}}],[\"getopflags\",{\"1\":{\"1617\":1,\"1623\":3}}],[\"getobjectforbeaninstance\",{\"1\":{\"1647\":4}}],[\"getobjectfactory\",{\"1\":{\"918\":2}}],[\"getobject方法返回的对象\",{\"1\":{\"1647\":1}}],[\"getobject方法\",{\"1\":{\"1647\":1}}],[\"getobject方法的安全性\",{\"1\":{\"944\":1}}],[\"getobjectvolatile\",{\"1\":{\"1554\":1}}],[\"getobjecttype\",{\"1\":{\"930\":1,\"1091\":2,\"1644\":1}}],[\"getobject\",{\"1\":{\"917\":1,\"918\":1,\"930\":1,\"940\":1,\"943\":1,\"944\":2,\"946\":1,\"989\":1,\"1032\":1,\"1181\":2,\"1553\":1,\"1644\":1}}],[\"get等\",{\"1\":{\"1538\":1}}],[\"getuniqueinstance\",{\"1\":{\"1191\":1,\"1192\":1,\"1194\":1}}],[\"getusername\",{\"1\":{\"1598\":1}}],[\"getuser\",{\"1\":{\"953\":1,\"1003\":1,\"1005\":1}}],[\"getusers\",{\"1\":{\"918\":2}}],[\"getdisplayname\",{\"1\":{\"1163\":1,\"1651\":1}}],[\"getdeclaringclass\",{\"1\":{\"1654\":1}}],[\"getdeclaredconstructor\",{\"1\":{\"1351\":1}}],[\"getdeclaredfields\",{\"1\":{\"1351\":1}}],[\"getdeclaredfield\",{\"1\":{\"1103\":1}}],[\"getdependencycheck\",{\"1\":{\"1647\":1}}],[\"getdependencytype\",{\"1\":{\"963\":6,\"1648\":5}}],[\"getdependentbeans\",{\"1\":{\"1647\":1}}],[\"getdependson\",{\"1\":{\"1647\":1}}],[\"getdepartment\",{\"1\":{\"1615\":1,\"1616\":2}}],[\"getdefault\",{\"1\":{\"1063\":3,\"1064\":1}}],[\"getdescription\",{\"1\":{\"1003\":1,\"1005\":1,\"1022\":1}}],[\"getgrade\",{\"1\":{\"1616\":1}}],[\"getgeneric\",{\"1\":{\"1103\":3}}],[\"getgenericinterfaces\",{\"1\":{\"1099\":1}}],[\"getgenericinfo\",{\"1\":{\"1099\":1}}],[\"getgenericsuperclass\",{\"1\":{\"1099\":2}}],[\"getglobalerrors\",{\"1\":{\"1063\":1}}],[\"gettransactionstatus\",{\"1\":{\"1655\":1}}],[\"gettransactionattribute\",{\"1\":{\"1655\":1}}],[\"gettransactionattributesource\",{\"1\":{\"1655\":1}}],[\"gettarget\",{\"1\":{\"1655\":1}}],[\"getting\",{\"1\":{\"1166\":1}}],[\"gettempclassloader\",{\"1\":{\"1165\":1}}],[\"getter方法\",{\"1\":{\"1075\":1,\"1613\":1}}],[\"getter方法均存在\",{\"1\":{\"1075\":1}}],[\"gettype\",{\"1\":{\"1639\":2,\"1648\":3}}],[\"gettypevariablemap\",{\"1\":{\"1100\":2}}],[\"gettypedescriptor\",{\"1\":{\"963\":1,\"1648\":1}}],[\"gettypeconverter\",{\"1\":{\"963\":3,\"1648\":2}}],[\"getexactsizeifknown\",{\"1\":{\"1620\":1,\"1623\":1}}],[\"getexception\",{\"1\":{\"1007\":1}}],[\"getearlybeanreference\",{\"1\":{\"1184\":1,\"1647\":1,\"1649\":1}}],[\"geterrorhandler\",{\"1\":{\"1124\":1}}],[\"getencoding\",{\"1\":{\"1022\":2}}],[\"getenvironment\",{\"1\":{\"1005\":1,\"1023\":1,\"1031\":2,\"1139\":3,\"1148\":1,\"1149\":1,\"1156\":1,\"1162\":1,\"1164\":4,\"1171\":1}}],[\"getmostspecificmethod\",{\"1\":{\"1648\":1}}],[\"getmodifiers\",{\"1\":{\"964\":1,\"1648\":2,\"1650\":1}}],[\"getmin\",{\"1\":{\"1610\":1}}],[\"getmaximumpoolsize\",{\"1\":{\"1689\":2}}],[\"getmax\",{\"1\":{\"1610\":1}}],[\"getmapvalue\",{\"1\":{\"1101\":1}}],[\"getmethodmatcher\",{\"1\":{\"1654\":1}}],[\"getmethod\",{\"1\":{\"1100\":1}}],[\"getmethoddescriptors\",{\"1\":{\"1075\":1}}],[\"getmethodparameter\",{\"1\":{\"963\":1,\"1648\":1}}],[\"getmetadatareaderfactory\",{\"1\":{\"1647\":3}}],[\"getmetadatareader\",{\"1\":{\"1646\":1,\"1647\":1}}],[\"getmetadata\",{\"1\":{\"1027\":1,\"1647\":1}}],[\"getmergedlocalbeandefinition\",{\"1\":{\"997\":1,\"1647\":2,\"1648\":1}}],[\"getmergedbeandefinition\",{\"1\":{\"963\":1,\"997\":5,\"1017\":1,\"1647\":3,\"1648\":1}}],[\"getmessage\",{\"1\":{\"946\":1,\"1055\":1,\"1063\":1,\"1064\":1,\"1167\":1,\"1587\":1,\"1588\":1,\"1647\":1}}],[\"getvalue\",{\"1\":{\"963\":1,\"985\":1,\"1029\":1,\"1031\":1,\"1082\":3,\"1084\":3,\"1091\":1,\"1546\":1,\"1648\":2}}],[\"getkey\",{\"1\":{\"963\":1,\"985\":1,\"1029\":1,\"1031\":1,\"1084\":1,\"1091\":1,\"1546\":1,\"1648\":2}}],[\"getfactorymethodname\",{\"1\":{\"1650\":1}}],[\"getfactorybeanname\",{\"1\":{\"928\":2}}],[\"getfindclasses\",{\"1\":{\"1432\":1,\"1663\":1}}],[\"getfindclasstime\",{\"1\":{\"1432\":1,\"1663\":1}}],[\"getfielderror\",{\"1\":{\"1063\":1}}],[\"getfield\",{\"1\":{\"963\":2,\"1648\":2}}],[\"getlastname\",{\"1\":{\"1618\":2}}],[\"getlazyresolutionproxyifnecessary\",{\"1\":{\"963\":1,\"1648\":1}}],[\"getlifecycleprocessor\",{\"1\":{\"1172\":1,\"1173\":1,\"1174\":1}}],[\"getlist\",{\"1\":{\"1100\":2}}],[\"getlength\",{\"1\":{\"645\":1}}],[\"getringbuffer\",{\"1\":{\"1521\":1}}],[\"getruntime\",{\"1\":{\"1480\":1,\"1573\":1}}],[\"getrawtype\",{\"1\":{\"1099\":1}}],[\"getrange\",{\"1\":{\"570\":2}}],[\"getreturntype\",{\"1\":{\"1655\":2}}],[\"getreadmethod\",{\"1\":{\"1075\":1}}],[\"getreader\",{\"1\":{\"1040\":1,\"1041\":1,\"1043\":1}}],[\"getregistry\",{\"1\":{\"1021\":2}}],[\"getresolvedautowiremode\",{\"1\":{\"1647\":1,\"1650\":1}}],[\"getresolvabletype\",{\"1\":{\"963\":6,\"1648\":3}}],[\"getresourcepatternresolver\",{\"1\":{\"1647\":1}}],[\"getresources\",{\"1\":{\"1043\":1,\"1647\":1}}],[\"getresource\",{\"1\":{\"1022\":4,\"1032\":1,\"1037\":1,\"1041\":1}}],[\"getresourcedescription\",{\"1\":{\"996\":1,\"997\":1,\"1008\":1,\"1647\":10,\"1650\":1}}],[\"getrole\",{\"1\":{\"996\":2}}],[\"getinterceptors\",{\"1\":{\"1654\":3}}],[\"getinterceptorsanddynamicinterceptionadvice\",{\"1\":{\"1654\":2}}],[\"getinternalparentmessagesource\",{\"1\":{\"1055\":2,\"1167\":2}}],[\"getint\",{\"1\":{\"1227\":1}}],[\"getinstancesupplier\",{\"1\":{\"1650\":1}}],[\"getinstance\",{\"1\":{\"1193\":1,\"1388\":1,\"1654\":1}}],[\"getinstantiationstrategy\",{\"1\":{\"1001\":1}}],[\"getinputstream\",{\"1\":{\"1022\":1,\"1573\":2}}],[\"getinitmethodname\",{\"1\":{\"1007\":1}}],[\"getifavailable\",{\"1\":{\"943\":2,\"944\":2}}],[\"getidentityhexstring\",{\"1\":{\"928\":1}}],[\"getid\",{\"1\":{\"917\":1,\"985\":3,\"989\":3,\"1116\":1,\"1163\":1,\"1184\":1,\"1651\":1}}],[\"getpoolsize\",{\"1\":{\"1689\":3}}],[\"getpointcut\",{\"1\":{\"1654\":2}}],[\"getpersonbyusername\",{\"1\":{\"1598\":1}}],[\"getpersonbyage\",{\"1\":{\"1598\":2}}],[\"getpreferredconstructors\",{\"1\":{\"1650\":1}}],[\"getpricebys3\",{\"1\":{\"1517\":1}}],[\"getpricebys2\",{\"1\":{\"1517\":1}}],[\"getpricebys1\",{\"1\":{\"1517\":1}}],[\"getproxy\",{\"1\":{\"1654\":1}}],[\"getprobe\",{\"1\":{\"1480\":1,\"1554\":1}}],[\"getpropertiespersister\",{\"1\":{\"1022\":2}}],[\"getproperty\",{\"1\":{\"1040\":1,\"1041\":1,\"1043\":1,\"1084\":1,\"1091\":1,\"1156\":1,\"1157\":1}}],[\"getpropertysources\",{\"1\":{\"1031\":2,\"1153\":1,\"1156\":1,\"1157\":1}}],[\"getpropertyvalues\",{\"1\":{\"1647\":2}}],[\"getpropertyvalue\",{\"1\":{\"1003\":1}}],[\"getpropertydescriptors\",{\"1\":{\"909\":1,\"1075\":1}}],[\"getpassword\",{\"1\":{\"1061\":2}}],[\"getpatterncomparator\",{\"1\":{\"1043\":1}}],[\"getparametertype\",{\"1\":{\"1655\":1}}],[\"getparametercount\",{\"1\":{\"1648\":1}}],[\"getparameternamediscoverer\",{\"1\":{\"963\":1,\"1648\":1}}],[\"getparentdelegationtime\",{\"1\":{\"1432\":1,\"1663\":1}}],[\"getparentmessagesource\",{\"1\":{\"1055\":1,\"1167\":1}}],[\"getparentbeanfactory\",{\"1\":{\"997\":3,\"1647\":2,\"1648\":1}}],[\"getparentbeanfacotry\",{\"1\":{\"942\":1}}],[\"getparentname\",{\"1\":{\"928\":2,\"997\":3,\"1647\":3}}],[\"getadapter\",{\"1\":{\"1655\":1}}],[\"getadvisors\",{\"1\":{\"1654\":1}}],[\"getaddress\",{\"1\":{\"917\":1,\"1611\":2}}],[\"getannotation\",{\"1\":{\"1654\":1}}],[\"getannotationtypes\",{\"1\":{\"1646\":1}}],[\"getannotationmetadata\",{\"1\":{\"1646\":1}}],[\"getanddecrement\",{\"1\":{\"1503\":1}}],[\"getandincrement\",{\"1\":{\"1503\":1}}],[\"getapplicationeventmulticaster\",{\"1\":{\"1170\":3}}],[\"getapplicationlisteners\",{\"1\":{\"1170\":1}}],[\"getapplicationcontext\",{\"1\":{\"1116\":1}}],[\"getapplicationstartup\",{\"1\":{\"1005\":1,\"1164\":1,\"1647\":2,\"1651\":1}}],[\"getactiveprofiles\",{\"1\":{\"1147\":1}}],[\"getactualtypearguments\",{\"1\":{\"1099\":2}}],[\"getaccesscontrolcontext\",{\"1\":{\"1007\":1,\"1008\":1,\"1647\":2}}],[\"getastext\",{\"1\":{\"1084\":1}}],[\"getarguments\",{\"1\":{\"1063\":1,\"1064\":1,\"1655\":1}}],[\"getallerrors\",{\"1\":{\"1063\":1,\"1064\":1}}],[\"getallannotationattributes\",{\"1\":{\"1023\":1,\"1139\":1}}],[\"getattribute\",{\"1\":{\"1019\":1,\"1030\":1}}],[\"getautowirecandidateresolver\",{\"1\":{\"963\":2,\"1648\":3}}],[\"getautowirecapablebeanfactory\",{\"1\":{\"930\":1,\"973\":1}}],[\"getage\",{\"1\":{\"909\":2,\"1598\":1,\"1600\":1,\"1611\":2,\"1613\":1}}],[\"getbytes\",{\"1\":{\"1574\":2,\"1575\":2}}],[\"getbindingresult\",{\"1\":{\"1072\":1}}],[\"getbit\",{\"1\":{\"578\":5}}],[\"getbeanname\",{\"1\":{\"1647\":1}}],[\"getbeannamesforannotation\",{\"1\":{\"941\":1}}],[\"getbeannamesfortype\",{\"1\":{\"941\":2,\"944\":1,\"1166\":1,\"1170\":1,\"1171\":1,\"1647\":1}}],[\"getbean会首先创建所依赖的bean\",{\"1\":{\"1647\":1}}],[\"getbeanclass\",{\"1\":{\"1030\":1}}],[\"getbeanclassloader\",{\"1\":{\"1005\":1,\"1164\":2,\"1165\":1}}],[\"getbeanclassname\",{\"1\":{\"928\":2,\"995\":1,\"998\":1,\"1647\":1}}],[\"getbeanpostprocessorcount\",{\"1\":{\"1166\":1}}],[\"getbeanpostprocessorcache\",{\"1\":{\"1000\":1,\"1647\":2}}],[\"getbeanpostprocessors\",{\"1\":{\"1006\":1}}],[\"getbeanprovider\",{\"1\":{\"940\":3,\"943\":3,\"944\":3}}],[\"getbean方法的执行是线程安全的\",{\"1\":{\"949\":1}}],[\"getbean方法的安全性\",{\"1\":{\"944\":1}}],[\"getbean操作是否线程安全\",{\"0\":{\"949\":1}}],[\"getbeanobjectfactory\",{\"1\":{\"946\":1}}],[\"getbeanoftype\",{\"1\":{\"941\":1}}],[\"getbeandefinitioncount\",{\"1\":{\"995\":2,\"1021\":2}}],[\"getbeandefinition\",{\"1\":{\"927\":1,\"929\":2,\"946\":2,\"953\":1,\"954\":1,\"985\":1,\"1019\":2,\"1174\":1,\"1632\":1}}],[\"getbeanfactorypostprocessors\",{\"1\":{\"1165\":1}}],[\"getbeanfactory\",{\"1\":{\"918\":3,\"919\":1,\"936\":1,\"957\":1,\"973\":1,\"1055\":1,\"1056\":1,\"1121\":1,\"1163\":1,\"1167\":1,\"1168\":1}}],[\"getbean\",{\"1\":{\"917\":3,\"918\":1,\"919\":2,\"930\":4,\"931\":1,\"933\":1,\"936\":1,\"940\":5,\"944\":2,\"946\":3,\"953\":3,\"954\":1,\"955\":1,\"961\":3,\"962\":1,\"963\":1,\"973\":7,\"978\":1,\"985\":3,\"989\":2,\"994\":1,\"995\":1,\"997\":2,\"1000\":2,\"1001\":3,\"1005\":6,\"1006\":3,\"1011\":3,\"1019\":1,\"1022\":1,\"1030\":1,\"1032\":2,\"1055\":1,\"1056\":2,\"1065\":2,\"1084\":1,\"1121\":1,\"1123\":1,\"1134\":1,\"1138\":1,\"1139\":1,\"1146\":1,\"1148\":1,\"1149\":2,\"1156\":1,\"1166\":3,\"1167\":1,\"1168\":1,\"1171\":2,\"1181\":2,\"1182\":4,\"1184\":2,\"1632\":1,\"1633\":1,\"1634\":1,\"1635\":1,\"1647\":8}}],[\"getbeansoftype方法的安全性\",{\"1\":{\"944\":1}}],[\"getbeansoftype\",{\"1\":{\"917\":1,\"921\":2,\"929\":2,\"941\":1,\"944\":1,\"1029\":1,\"1031\":1}}],[\"getbeanswithannotation\",{\"1\":{\"917\":1,\"941\":2}}],[\"getbeaninfo\",{\"1\":{\"909\":1,\"1075\":1}}],[\"getnumber\",{\"1\":{\"1003\":1,\"1005\":1}}],[\"getnumberofbeansfound\",{\"1\":{\"946\":1}}],[\"getname\",{\"1\":{\"909\":2,\"917\":1,\"946\":1,\"973\":1,\"985\":2,\"1023\":1,\"1064\":1,\"1065\":1,\"1119\":1,\"1123\":1,\"1139\":1,\"1156\":1,\"1157\":1,\"1175\":1,\"1184\":3,\"1600\":4,\"1603\":3,\"1604\":3,\"1605\":6,\"1611\":2,\"1613\":5,\"1616\":7,\"1617\":2,\"1647\":1,\"1650\":1,\"1652\":4,\"1654\":2,\"1655\":1}}],[\"getnodename\",{\"1\":{\"645\":1}}],[\"getnodetype\",{\"1\":{\"645\":3}}],[\"getnode\",{\"1\":{\"645\":5}}],[\"getsalary\",{\"1\":{\"1615\":1,\"1616\":2}}],[\"getscore\",{\"1\":{\"1603\":4,\"1604\":4,\"1605\":3,\"1613\":5,\"1616\":10}}],[\"getscopename\",{\"1\":{\"1027\":1,\"1647\":1}}],[\"getscope\",{\"1\":{\"997\":2,\"1647\":3}}],[\"getshort\",{\"1\":{\"1601\":3}}],[\"getshortname\",{\"1\":{\"928\":1,\"995\":1}}],[\"gets\",{\"1\":{\"1600\":1,\"1622\":1}}],[\"getstreamandopflags\",{\"1\":{\"1623\":1}}],[\"getstring2\",{\"1\":{\"1606\":2}}],[\"getstringlist\",{\"1\":{\"1100\":2}}],[\"getstring\",{\"1\":{\"1100\":2,\"1606\":2}}],[\"getstringbody\",{\"1\":{\"645\":1}}],[\"getstate\",{\"1\":{\"1490\":1}}],[\"getstatic\",{\"1\":{\"1482\":2}}],[\"getstudents\",{\"1\":{\"1184\":1}}],[\"getsingleton\",{\"1\":{\"1647\":4}}],[\"getsingleton中可以看到核心的逻辑\",{\"1\":{\"1182\":1}}],[\"getsimplename\",{\"1\":{\"1100\":2,\"1116\":1,\"1121\":1,\"1168\":1}}],[\"getsystemenvironment\",{\"1\":{\"1164\":1}}],[\"getsystemproperties\",{\"1\":{\"1164\":1}}],[\"getsubmittedcount\",{\"1\":{\"1689\":1}}],[\"getsuperclass\",{\"1\":{\"1648\":1}}],[\"getsupertype\",{\"1\":{\"1103\":4}}],[\"getsum\",{\"1\":{\"1610\":1}}],[\"getsuggestedvalue\",{\"1\":{\"963\":1,\"1648\":1}}],[\"getsource\",{\"1\":{\"1019\":1,\"1119\":2}}],[\"getservletfilters\",{\"1\":{\"1658\":1}}],[\"getservletmappings\",{\"1\":{\"1658\":1}}],[\"getservletapplicationcontextinitializers\",{\"1\":{\"1658\":1}}],[\"getservletname\",{\"1\":{\"1658\":2}}],[\"getsecuritymanager\",{\"1\":{\"1007\":1,\"1008\":1,\"1647\":2}}],[\"getset等指令去获取数据时\",{\"1\":{\"1289\":1}}],[\"getset\",{\"1\":{\"570\":3,\"1288\":2}}],[\"getcause\",{\"1\":{\"1655\":1}}],[\"getcity\",{\"1\":{\"1618\":2}}],[\"getclassfilter\",{\"1\":{\"1654\":2}}],[\"getclassname\",{\"1\":{\"1646\":1}}],[\"getclassmetadata\",{\"1\":{\"1646\":1}}],[\"getclassloadinglock\",{\"1\":{\"1432\":1,\"1663\":1}}],[\"getclassloader\",{\"1\":{\"965\":1,\"1164\":1,\"1654\":1}}],[\"getclassroom\",{\"1\":{\"1184\":1}}],[\"getclass\",{\"1\":{\"963\":1,\"964\":1,\"985\":1,\"1002\":1,\"1003\":1,\"1006\":1,\"1007\":1,\"1008\":1,\"1011\":1,\"1019\":1,\"1064\":1,\"1075\":1,\"1103\":1,\"1116\":1,\"1121\":1,\"1168\":1,\"1181\":4,\"1620\":2,\"1623\":1,\"1647\":1,\"1648\":3}}],[\"getcomparator\",{\"1\":{\"1620\":1}}],[\"getcomponenttype\",{\"1\":{\"963\":2}}],[\"getcommonpoolparallelism\",{\"1\":{\"1620\":1}}],[\"getcolor\",{\"1\":{\"1619\":1}}],[\"getcollection\",{\"1\":{\"1101\":1}}],[\"getcode\",{\"1\":{\"1063\":1,\"1064\":1}}],[\"getcontinuation\",{\"1\":{\"1655\":1}}],[\"getcontent\",{\"1\":{\"1043\":4,\"1044\":2}}],[\"getcontext\",{\"1\":{\"989\":4}}],[\"getcontextclassloader\",{\"1\":{\"930\":1}}],[\"getconstructorargumentvalues\",{\"1\":{\"1650\":1}}],[\"getconversionservicee\",{\"1\":{\"1093\":1}}],[\"getconversationid\",{\"1\":{\"989\":1}}],[\"getconvertibletypes\",{\"1\":{\"1089\":1,\"1091\":1,\"1639\":1}}],[\"getconnection\",{\"1\":{\"583\":1}}],[\"getconnectionfactory\",{\"1\":{\"583\":1}}],[\"getchildnodes\",{\"1\":{\"645\":1}}],[\"get直接略过\",{\"1\":{\"570\":1}}],[\"get\",{\"1\":{\"306\":14,\"307\":4,\"309\":1,\"474\":1,\"567\":2,\"569\":1,\"570\":5,\"571\":1,\"579\":2,\"580\":3,\"581\":2,\"582\":2,\"583\":1,\"611\":1,\"645\":1,\"963\":1,\"964\":1,\"965\":1,\"989\":4,\"996\":1,\"997\":2,\"1023\":1,\"1139\":1,\"1175\":1,\"1288\":1,\"1365\":2,\"1476\":3,\"1479\":3,\"1503\":2,\"1517\":5,\"1528\":3,\"1551\":1,\"1574\":2,\"1575\":2,\"1587\":2,\"1588\":2,\"1593\":1,\"1600\":6,\"1606\":1,\"1608\":3,\"1611\":1,\"1615\":6,\"1616\":1,\"1617\":2,\"1618\":4,\"1622\":1,\"1623\":1,\"1647\":4,\"1648\":1}}],[\"gg\",{\"1\":{\"336\":1}}],[\"g\",{\"1\":{\"329\":1,\"330\":5,\"354\":1,\"361\":1,\"390\":2,\"421\":1,\"429\":2,\"538\":1,\"577\":1,\"996\":1,\"1165\":1,\"1617\":8,\"1621\":1}}],[\"g1特点\",{\"0\":{\"1754\":1}}],[\"g1简介\",{\"0\":{\"1740\":1}}],[\"g1需要记忆集\",{\"1\":{\"1449\":1}}],[\"g1的内存布局并不是固定大小以及固定数量的分代区域划分\",{\"1\":{\"1449\":1}}],[\"g1的优点\",{\"1\":{\"1449\":1}}],[\"g1\",{\"1\":{\"1441\":1}}],[\"g1有什么优缺点\",{\"0\":{\"118\":1,\"1449\":1}}],[\"g1垃圾收集器的步骤\",{\"0\":{\"118\":1,\"1449\":1}}],[\"雪花算法有什么缺点\",{\"0\":{\"241\":1,\"1321\":1}}],[\"怎样让数据库恢复到半个月内任意一秒的状态\",{\"1\":{\"327\":1}}],[\"怎样设计出高内聚\",{\"0\":{\"228\":1,\"1308\":1}}],[\"怎么做取决于调用者\",{\"1\":{\"1599\":1}}],[\"怎么从内存中和从磁盘上读取一个块的默认成本是一样的\",{\"1\":{\"557\":1}}],[\"怎么衡量使用idx\",{\"1\":{\"555\":1}}],[\"怎么拆分微服务\",{\"0\":{\"228\":1,\"1308\":1}}],[\"怎么保证消息的顺序性\",{\"1\":{\"1326\":1}}],[\"怎么保证事务一致性\",{\"0\":{\"227\":1,\"1307\":1}}],[\"怎么保证线程安全\",{\"0\":{\"48\":1,\"1377\":1}}],[\"怎么注入\",{\"0\":{\"185\":1,\"1242\":1}}],[\"怎么解决\",{\"0\":{\"129\":1,\"1281\":1}}],[\"怎么查看一个java进程的jvm参数\",{\"0\":{\"124\":1,\"1455\":1}}],[\"怎么样确定一个对象不是垃圾\",{\"0\":{\"106\":1,\"1437\":1}}],[\"都采用它\",{\"1\":{\"1986\":1}}],[\"都放到子容器中\",{\"1\":{\"1661\":1}}],[\"都应该使用lambda表达式\",{\"1\":{\"1592\":1}}],[\"都应该选择可靠性策略\",{\"1\":{\"459\":1}}],[\"都能做到游刃有余\",{\"1\":{\"1591\":1}}],[\"都能够正确地更新到test库的表t\",{\"1\":{\"454\":1}}],[\"都支持可重入\",{\"1\":{\"1494\":1}}],[\"都继承了urlclassloader\",{\"1\":{\"1432\":1}}],[\"都必须保持事务内操作的一致性\",{\"1\":{\"1262\":1}}],[\"都创建新事务进行执行\",{\"1\":{\"1238\":1}}],[\"都属于悲观锁\",{\"1\":{\"533\":1}}],[\"都将当前的dict\",{\"1\":{\"495\":1}}],[\"都将依赖于此时读到的权限\",{\"1\":{\"318\":1}}],[\"都确保了备库已经收到了这个日志\",{\"1\":{\"472\":1}}],[\"都比判断seconds\",{\"1\":{\"472\":1}}],[\"都遵循了这两条基本原则\",{\"1\":{\"460\":1}}],[\"都已经被持久化磁盘\",{\"1\":{\"451\":1}}],[\"都写完redo\",{\"1\":{\"451\":1}}],[\"都变成了\",{\"1\":{\"447\":1}}],[\"都被锁住导致表完全不可读写\",{\"1\":{\"441\":1}}],[\"都可以使用并行流来代替串行流\",{\"1\":{\"1612\":1}}],[\"都可以使用上面的伪代码逻辑进行理解\",{\"1\":{\"603\":1}}],[\"都可以延迟实现\",{\"1\":{\"1608\":1}}],[\"都可以插入值\",{\"1\":{\"571\":1}}],[\"都可以传到备库并被正确地执行\",{\"1\":{\"456\":1}}],[\"都可以得到前一个状态的值\",{\"1\":{\"434\":1}}],[\"都可以采用这个方法来处理\",{\"1\":{\"347\":1}}],[\"都是广受企业欢迎的数据库\",{\"1\":{\"1974\":1}}],[\"都是与stream相伴出现的\",{\"1\":{\"1607\":1}}],[\"都是可以调用的\",{\"1\":{\"1605\":1}}],[\"都是从jdk8开始提供的\",{\"1\":{\"1598\":1}}],[\"都是一个函数式接口\",{\"1\":{\"1598\":1}}],[\"都是基于aqs框架来实现的\",{\"1\":{\"1490\":1}}],[\"都是基于外部检测的\",{\"1\":{\"478\":1}}],[\"都是有一个缓存的\",{\"1\":{\"1432\":1}}],[\"都是abstractapplicationcontext\",{\"1\":{\"1045\":1}}],[\"都是使用autowiredannotationbeanpostprocessor来处理依赖注入的过程\",{\"1\":{\"965\":1}}],[\"都是必要的字节\",{\"1\":{\"637\":1}}],[\"都是\",{\"1\":{\"472\":1}}],[\"都是由proxy完成\",{\"1\":{\"469\":1}}],[\"都是当前读\",{\"1\":{\"446\":1}}],[\"都是在commit的时候才释放的\",{\"1\":{\"443\":1}}],[\"都是不需要扫描索引的\",{\"1\":{\"422\":1}}],[\"都是追加操作\",{\"1\":{\"335\":1}}],[\"都会调用urlclassloader的findclass方法在加载器的类路径里查找并加载该类\",{\"1\":{\"1663\":1}}],[\"都会被spring解析为对应的beandefinition对象\",{\"1\":{\"1632\":1}}],[\"都会进入这个方法\",{\"1\":{\"1622\":1}}],[\"都会回收\",{\"1\":{\"1435\":1}}],[\"都会在请求头部带上这个session\",{\"1\":{\"1200\":1}}],[\"都会去找自增量的最大值max\",{\"1\":{\"490\":1}}],[\"都会碰到\",{\"1\":{\"469\":1}}],[\"都会map到一个单独的数字\",{\"1\":{\"454\":1}}],[\"都会随机滚动显示三个单词\",{\"1\":{\"419\":1}}],[\"都会将sql语句原封不动的记录下来\",{\"1\":{\"413\":1}}],[\"都会自增1\",{\"1\":{\"304\":1}}],[\"都表示返回满足条件的结果集的总行数\",{\"1\":{\"399\":1}}],[\"都暂停一会儿再做下一次删除\",{\"1\":{\"393\":1}}],[\"都需要操作系统的支持\",{\"1\":{\"1585\":1}}],[\"都需要阻塞挂起\",{\"1\":{\"1399\":1}}],[\"都需要进行一次被驱动表s2的访问\",{\"1\":{\"555\":1}}],[\"都需要经过\",{\"1\":{\"467\":1}}],[\"都需要扫描全表的数据\",{\"1\":{\"441\":1}}],[\"都需要在二者之间寻找一个平衡点\",{\"1\":{\"433\":1}}],[\"都需要手动将年份补齐\",{\"1\":{\"366\":1}}],[\"都需要额外调用一次reverse函数\",{\"1\":{\"352\":1}}],[\"都不能在多线程环境中并发使用的代码\",{\"1\":{\"1391\":1}}],[\"都不会被对方执行\",{\"1\":{\"459\":1}}],[\"都不支持范围查询\",{\"1\":{\"352\":1}}],[\"都不设计到挪动其它记录\",{\"1\":{\"335\":1}}],[\"都同时用cr32\",{\"1\":{\"352\":1}}],[\"都要对前面的操作进行会滚\",{\"1\":{\"1262\":1}}],[\"都要判断会不会由于自己的加入导致了死锁\",{\"1\":{\"444\":1}}],[\"都要做100次判断\",{\"1\":{\"403\":1,\"525\":1}}],[\"都要回到主键索引上查出整行的数据\",{\"1\":{\"347\":1}}],[\"都要用到这个名字\",{\"1\":{\"303\":1}}],[\"都马上伴随着对这个记录的查询\",{\"1\":{\"344\":1}}],[\"都有自己的倒排索引\",{\"1\":{\"308\":1}}],[\"都解决了什么问题\",{\"0\":{\"225\":1,\"1305\":1}}],[\"都经历了什么过程\",{\"0\":{\"105\":1,\"1436\":1}}],[\"执行静态代码块\",{\"1\":{\"1663\":1}}],[\"执行被代理对象中的方法\",{\"1\":{\"1655\":1}}],[\"执行业务方法\",{\"1\":{\"1655\":1}}],[\"执行原始对象的方法\",{\"1\":{\"1654\":1}}],[\"执行原理时根据表达式的值\",{\"1\":{\"1216\":1}}],[\"执行原理是什么\",{\"0\":{\"200\":1,\"1216\":1}}],[\"执行目标方法\",{\"1\":{\"1630\":1}}],[\"执行到集合中所有的元素执行完或者抛出异常为止\",{\"1\":{\"1595\":1}}],[\"执行到这一步\",{\"1\":{\"542\":1}}],[\"执行读操作时\",{\"1\":{\"1564\":1}}],[\"执行存盘操作\",{\"1\":{\"1531\":1}}],[\"执行存储引擎使用的设备类型\",{\"1\":{\"557\":1}}],[\"执行下一步操作\",{\"1\":{\"1518\":1}}],[\"执行某一个阶段\",{\"1\":{\"1518\":1}}],[\"执行相同的操作\",{\"1\":{\"1483\":1}}],[\"执行构造方法\",{\"1\":{\"1429\":1}}],[\"执行对应的handler方法\",{\"1\":{\"1241\":1}}],[\"执行模式\",{\"1\":{\"1125\":1}}],[\"执行gc\",{\"1\":{\"934\":1,\"1013\":1}}],[\"执行lastsave命令可以获取最后一次生成rdb的时间\",{\"1\":{\"588\":1}}],[\"执行bgsave命令\",{\"1\":{\"588\":1}}],[\"执行之前\",{\"1\":{\"581\":1}}],[\"执行之后就会发现这个sql语句会比预期的慢很多\",{\"1\":{\"366\":1}}],[\"执行报错\",{\"1\":{\"580\":1}}],[\"执行事务\",{\"1\":{\"579\":1,\"581\":1,\"582\":1}}],[\"执行事务之前就会先执行这两个set命令\",{\"1\":{\"468\":1}}],[\"执行任何查询sql时会生成当前事务的一致性视图read\",{\"1\":{\"542\":1}}],[\"执行时间\",{\"1\":{\"1487\":1}}],[\"执行时间减少了一半以上\",{\"1\":{\"522\":1}}],[\"执行时间是40毫秒\",{\"1\":{\"346\":1}}],[\"执行这个userservice的test方法时\",{\"1\":{\"1654\":1}}],[\"执行这三个命令时\",{\"1\":{\"485\":1}}],[\"执行这条更新语句的成本很低\",{\"1\":{\"345\":1}}],[\"执行停止的逻辑了\",{\"1\":{\"481\":1}}],[\"执行自己的任务\",{\"1\":{\"478\":1}}],[\"执行了十次累积的操作\",{\"1\":{\"1617\":1}}],[\"执行了多少事务\",{\"1\":{\"473\":1}}],[\"执行了21毫秒\",{\"1\":{\"346\":1}}],[\"执行一百千次\",{\"1\":{\"1591\":1}}],[\"执行一次删除过期key的操作\",{\"1\":{\"1289\":1}}],[\"执行一次跳过命令\",{\"1\":{\"467\":1}}],[\"执行一个终止的操作\",{\"1\":{\"1623\":1}}],[\"执行一个事务\",{\"1\":{\"496\":1}}],[\"执行一个查询的过程中\",{\"1\":{\"480\":1}}],[\"执行一条update语句\",{\"1\":{\"478\":1}}],[\"执行一条插入语句后报错的情况\",{\"1\":{\"425\":1}}],[\"执行中\",{\"1\":{\"464\":1}}],[\"执行队列\",{\"1\":{\"461\":1}}],[\"执行内部事务的更新逻辑\",{\"1\":{\"453\":1}}],[\"执行完这个lambda表达式\",{\"1\":{\"1649\":1}}],[\"执行完图中的语句之后\",{\"1\":{\"447\":1}}],[\"执行完成后\",{\"1\":{\"319\":1}}],[\"执行后就会提交\",{\"1\":{\"446\":1}}],[\"执行代价还是小很多\",{\"1\":{\"422\":1}}],[\"执行代价都是比较高的\",{\"1\":{\"417\":1}}],[\"执行全字段排序会会减少磁盘访问\",{\"1\":{\"420\":1}}],[\"执行过程中按顺序执行\",{\"1\":{\"578\":1}}],[\"执行过程中会发现内存临时表大小达到了上限\",{\"1\":{\"416\":1}}],[\"执行过程中会发现内存临时表大小不够存下这100行数据\",{\"1\":{\"416\":1}}],[\"执行过程类似\",{\"1\":{\"526\":1}}],[\"执行过程就要扫描驱动表n行\",{\"1\":{\"401\":1}}],[\"执行第二个子查询\",{\"1\":{\"414\":1}}],[\"执行第一个子查询\",{\"1\":{\"414\":1}}],[\"执行insert语句构造temp\",{\"1\":{\"407\":1}}],[\"执行流程如下\",{\"1\":{\"421\":1}}],[\"执行流程就变成了\",{\"1\":{\"403\":1,\"418\":1,\"474\":1}}],[\"执行流程的示意图如下所示\",{\"1\":{\"354\":1}}],[\"执行耗时都是一样的\",{\"1\":{\"403\":1}}],[\"执行set\",{\"1\":{\"481\":1}}],[\"执行select\",{\"1\":{\"401\":2,\"411\":1}}],[\"执行show\",{\"1\":{\"431\":1,\"482\":2}}],[\"执行sql语句的第一步\",{\"1\":{\"318\":1}}],[\"执行得要比count\",{\"1\":{\"399\":1}}],[\"执行单个查询可以减少锁的竞争\",{\"1\":{\"394\":1}}],[\"执行\",{\"1\":{\"381\":2,\"412\":1,\"476\":1,\"1554\":1}}],[\"执行语句\",{\"1\":{\"354\":1,\"421\":1}}],[\"执行顺序如下\",{\"1\":{\"350\":2}}],[\"执行顺序由上至下\",{\"1\":{\"330\":1}}],[\"执行速度明显会快很多\",{\"1\":{\"347\":1}}],[\"执行另外一个语句\",{\"1\":{\"347\":1}}],[\"执行的核心逻辑\",{\"1\":{\"1655\":1}}],[\"执行的结果\",{\"1\":{\"1617\":1}}],[\"执行的过程中可能会调用若干的service来完成业务的处理\",{\"1\":{\"1241\":1}}],[\"执行的序列如下\",{\"1\":{\"447\":1}}],[\"执行的效率就会越低\",{\"1\":{\"433\":1}}],[\"执行的效果如下\",{\"1\":{\"348\":2,\"407\":1,\"454\":1}}],[\"执行的流程如下\",{\"1\":{\"407\":1}}],[\"执行的流程图如下\",{\"1\":{\"345\":1,\"403\":1,\"418\":1,\"458\":1}}],[\"执行的示意图如下\",{\"1\":{\"355\":1}}],[\"执行的逻辑也差不多\",{\"1\":{\"322\":1}}],[\"执行逻辑就会来到第二步\",{\"1\":{\"319\":1}}],[\"执行器不仅重用语句还会执行批量更新\",{\"1\":{\"646\":1}}],[\"执行器会重用preparestatement\",{\"1\":{\"646\":1}}],[\"执行器把binlog\",{\"1\":{\"450\":1}}],[\"执行器调用innodb引擎接口写入一行\",{\"1\":{\"491\":1}}],[\"执行器调用引擎的提交事务接口\",{\"1\":{\"326\":1}}],[\"执行器调用一次\",{\"1\":{\"322\":1}}],[\"执行器生成这个操作的binlog\",{\"1\":{\"326\":1}}],[\"执行器拿到引擎给的行数据\",{\"1\":{\"326\":1}}],[\"执行器先找引擎取id=2这一行\",{\"1\":{\"326\":1}}],[\"执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端\",{\"1\":{\"322\":1}}],[\"执行器就会根据表的引擎定义\",{\"1\":{\"322\":1}}],[\"执行器\",{\"0\":{\"322\":1,\"515\":1},\"1\":{\"317\":1}}],[\"执行结果会被存入查询缓存中\",{\"1\":{\"319\":1}}],[\"执行结果\",{\"1\":{\"309\":1}}],[\"执行插入语句后如何该数据的主键\",{\"0\":{\"196\":1,\"1212\":1}}],[\"当学完了这部分\",{\"1\":{\"1969\":1}}],[\"当父亲已经加载了该类时\",{\"1\":{\"1663\":1}}],[\"当执行该代理对象的某个方法时\",{\"1\":{\"1653\":1}}],[\"当找到多个对象的时候\",{\"1\":{\"1648\":1}}],[\"当找到k=5的时候\",{\"1\":{\"342\":1}}],[\"当命名出现重复\",{\"1\":{\"1647\":1}}],[\"当链接一个新的中间操作\",{\"1\":{\"1621\":1}}],[\"当链表长度太长\",{\"1\":{\"1546\":1}}],[\"当链表转为红黑树\",{\"0\":{\"35\":1,\"1363\":1}}],[\"当不为空的情况出现的时候\",{\"1\":{\"1620\":1}}],[\"当分割迭代器绑定到元上元素的时候\",{\"1\":{\"1620\":1}}],[\"当流的close方法被调用的时候\",{\"1\":{\"1619\":1}}],[\"当流程的执行顺序依赖于某个共享变量的场景\",{\"1\":{\"1531\":1}}],[\"当中\",{\"1\":{\"1619\":1}}],[\"当比较的结果不为0的时候直接返回\",{\"1\":{\"1614\":1}}],[\"当计算这个复合函数的时候\",{\"1\":{\"1599\":1}}],[\"当成参数传递给另一个函数\",{\"1\":{\"1593\":1}}],[\"当调用sendfile\",{\"1\":{\"1582\":1}}],[\"当启动某个应用程序时\",{\"1\":{\"1579\":1}}],[\"当任何一个socket中的数据准备好了\",{\"1\":{\"1565\":1}}],[\"当任务在运行中出错时\",{\"1\":{\"1510\":1}}],[\"当任务添加到线程池中被拒绝时\",{\"1\":{\"1410\":4}}],[\"当任务到达时\",{\"1\":{\"1407\":1}}],[\"当对于一个non\",{\"1\":{\"1564\":1}}],[\"当对一个表做增删改查操作时\",{\"1\":{\"481\":1}}],[\"当对一个表做增删改查操作的时候\",{\"1\":{\"441\":1}}],[\"当kernel一直等到数据准备好了\",{\"1\":{\"1563\":1}}],[\"当key被gc之后\",{\"1\":{\"1406\":1}}],[\"当key不存在时\",{\"1\":{\"1288\":1}}],[\"当程序打开一个现有文件或者创建一个新文件时\",{\"1\":{\"1561\":1}}],[\"当程序打开一个文件或者创建一个文件时\",{\"1\":{\"1423\":1}}],[\"当超过threshold所能容纳的数量\",{\"1\":{\"1546\":1}}],[\"当用iterator遍历treemap时\",{\"1\":{\"1544\":1}}],[\"当用户进程结束的时候\",{\"1\":{\"1579\":1}}],[\"当用户进程调用了select\",{\"1\":{\"1565\":1}}],[\"当用户进程调用了recvfrom这个系统调用\",{\"1\":{\"1563\":1}}],[\"当用户进程发出read操作时\",{\"1\":{\"1564\":1}}],[\"当用户变多之后这种方式及其浪费空间\",{\"1\":{\"577\":1}}],[\"当用户执行kill\",{\"1\":{\"481\":1}}],[\"当创建arraylist对象时\",{\"1\":{\"1542\":1}}],[\"当线程处理完请求后\",{\"1\":{\"1533\":1}}],[\"当自己的任务为空时\",{\"1\":{\"1511\":1}}],[\"当子问题划分得足够小时\",{\"1\":{\"1510\":1}}],[\"当去除takeindex对应的元素之后\",{\"1\":{\"1502\":1}}],[\"当如果生产速度远远大于消费速度\",{\"1\":{\"1502\":1}}],[\"当同步状态释放时\",{\"1\":{\"1491\":1}}],[\"当某个类中存在\",{\"1\":{\"1655\":1}}],[\"当某个类已经触发批量撤销机制后\",{\"1\":{\"1485\":1}}],[\"当某个socket有数据到达了\",{\"1\":{\"1565\":1}}],[\"当某个事物执行快照读的时候\",{\"1\":{\"542\":1}}],[\"当撤销偏向锁阈值超过40次后\",{\"1\":{\"1485\":1}}],[\"当其达到批量撤销的阈值后\",{\"1\":{\"1485\":1}}],[\"当其它线程想要访问数据时\",{\"1\":{\"1399\":1}}],[\"当达到重偏向阈值\",{\"1\":{\"1485\":1}}],[\"当达到这个状态后\",{\"1\":{\"497\":1}}],[\"当只有一个线程反复进入同步块时\",{\"1\":{\"1485\":1}}],[\"当在jvm参数中关闭指针压缩\",{\"1\":{\"1484\":1}}],[\"当在redis实例中开启了requirepass\",{\"1\":{\"624\":1}}],[\"当它收到一个asynchronous\",{\"1\":{\"1566\":1}}],[\"当它没有得到另一个线程的消息时应等待\",{\"1\":{\"1477\":1}}],[\"当它发现节点不可达时\",{\"1\":{\"621\":1}}],[\"当红黑树的元素小于6的时候\",{\"1\":{\"1475\":1}}],[\"当系统中的客户机维护公共内存资源的缓存时\",{\"1\":{\"1474\":1}}],[\"当类型相同的时候\",{\"1\":{\"1601\":1}}],[\"当类型如果设置的不对时\",{\"1\":{\"309\":1}}],[\"当类不再被引用时\",{\"1\":{\"1457\":1}}],[\"当方法执行结束后\",{\"1\":{\"1436\":1}}],[\"当提交的任务大于corepoolsize时\",{\"1\":{\"1410\":1}}],[\"当提交的线程填满核心线程数\",{\"1\":{\"1410\":1}}],[\"当队列无元素时\",{\"1\":{\"1503\":1}}],[\"当队列满了时\",{\"1\":{\"1503\":1}}],[\"当队列满了无法添加元素\",{\"1\":{\"1501\":1}}],[\"当队列满时\",{\"1\":{\"1395\":1}}],[\"当队列为空时\",{\"1\":{\"1395\":1}}],[\"当jvm启用了偏向锁模式\",{\"1\":{\"1485\":1}}],[\"当jvm中所有的线程都是守护线程的时候\",{\"1\":{\"1375\":1}}],[\"当join\",{\"1\":{\"403\":1}}],[\"当元素大于8个的时候\",{\"1\":{\"1360\":1}}],[\"当元素小于8个的时候\",{\"1\":{\"1360\":1}}],[\"当内存空间还足够时\",{\"1\":{\"1435\":1}}],[\"当内存不足以容纳新写入数据时\",{\"1\":{\"1300\":1}}],[\"当内存太小\",{\"1\":{\"356\":1}}],[\"当使用fork\",{\"1\":{\"1510\":1}}],[\"当使用append\",{\"1\":{\"1297\":1}}],[\"当使用get\",{\"1\":{\"1289\":1}}],[\"当使用默认参数连接的时候\",{\"1\":{\"482\":1}}],[\"当第一个线程删除了缓存\",{\"1\":{\"1286\":1}}],[\"当第一次被调用的时候\",{\"1\":{\"1191\":1}}],[\"当请求到来时\",{\"1\":{\"1283\":1}}],[\"当多个事务操作一个数据的时候\",{\"1\":{\"1262\":1}}],[\"当失败是\",{\"1\":{\"1262\":1}}],[\"当容器在初始化一个bean时还需要依赖一个bean\",{\"1\":{\"1234\":1}}],[\"当客户端向容器申请一个bean时\",{\"1\":{\"1234\":1}}],[\"当客户端带上令牌去访问应用的接口时\",{\"1\":{\"1203\":1}}],[\"当指定的线程数nthreads为0时\",{\"1\":{\"1227\":1}}],[\"当cpu再次使用该部分数据时可以从cache中直接调用\",{\"1\":{\"1474\":1}}],[\"当channel被创建时\",{\"1\":{\"1224\":1}}],[\"当comments\",{\"1\":{\"361\":1}}],[\"当依赖查询或依赖注入时\",{\"1\":{\"1182\":1}}],[\"当被元标注的注解中的属性无法表达语义的时候\",{\"1\":{\"1136\":1}}],[\"当refresh\",{\"1\":{\"1126\":1}}],[\"当refreshendpoint被调用时\",{\"1\":{\"1126\":1}}],[\"当服务业务逐渐复杂\",{\"1\":{\"1309\":1}}],[\"当服务端从单体应用升级为分布式之后\",{\"1\":{\"1200\":1}}],[\"当服务器tomcat第一次接收到客户端的请求时\",{\"1\":{\"1200\":1}}],[\"当服务器关闭时这些统计数据就被清除掉了\",{\"1\":{\"558\":1}}],[\"当服务实例注册后\",{\"1\":{\"1126\":1}}],[\"当服务实例注册前\",{\"1\":{\"1126\":1}}],[\"当discoveryclient客户端发送心跳时\",{\"1\":{\"1126\":1}}],[\"当dict\",{\"1\":{\"495\":1}}],[\"当environment示例配置属性发生变化时\",{\"1\":{\"1126\":1}}],[\"当propertyvalues中包含x\",{\"1\":{\"1072\":1}}],[\"当propertyvalues中包含名称的x的propertyvalue\",{\"1\":{\"1072\":2}}],[\"当outter\",{\"1\":{\"1020\":3}}],[\"当已经存在beandefinition的时候\",{\"1\":{\"996\":1}}],[\"当注入的类型时延迟查找时\",{\"1\":{\"963\":1}}],[\"当进行快照持久化的时候会开启一个子进程专门负责快照持久化\",{\"1\":{\"1290\":1}}],[\"当进行集合类型的注入时\",{\"1\":{\"963\":1}}],[\"当进行failover时\",{\"1\":{\"624\":1}}],[\"当bena实现了这个接口\",{\"1\":{\"1234\":1}}],[\"当beandefinition配置元信息非法时\",{\"1\":{\"946\":1}}],[\"当bean初始化过程中\",{\"1\":{\"946\":1}}],[\"当bean所对应的类型非具体类时\",{\"1\":{\"946\":1}}],[\"当bind方法执行时\",{\"1\":{\"1072\":3}}],[\"当binlog所在磁盘的空间占用率达到100\",{\"1\":{\"477\":1}}],[\"当binlog\",{\"1\":{\"451\":1,\"454\":2}}],[\"当binlog是row格式的时候\",{\"1\":{\"413\":1}}],[\"当查找bean不存在于ioc容器时\",{\"1\":{\"946\":1}}],[\"当查询优化器想计算整个连接查询所使用的成本时\",{\"1\":{\"554\":1}}],[\"当查询中使用到了in查询\",{\"1\":{\"553\":1}}],[\"当查询中使用同一个数据表的时候\",{\"1\":{\"394\":1}}],[\"当spliterator方法无法返回immutable\",{\"1\":{\"1620\":1}}],[\"当spring容器关闭的时候\",{\"1\":{\"1647\":1}}],[\"当springboot应用启动失败时\",{\"1\":{\"1126\":1}}],[\"当springboot应用完全可用时\",{\"1\":{\"1126\":1}}],[\"当springboot应用预备时\",{\"1\":{\"1126\":1}}],[\"当springboot应用已启动时\",{\"1\":{\"1126\":2}}],[\"当springboot\",{\"1\":{\"1126\":1}}],[\"当spring应用出现多层次spring应用上下文\",{\"1\":{\"1116\":1}}],[\"当select函数返回后\",{\"1\":{\"1569\":1}}],[\"当sentinel有任何警告级别的事件发生时\",{\"1\":{\"624\":1}}],[\"当stats\",{\"1\":{\"558\":2,\"559\":2}}],[\"当想要取消一个正在进行的failover所需要的时间\",{\"1\":{\"624\":1}}],[\"当大多数sentinel节点都认为主节点不可达时\",{\"1\":{\"621\":1}}],[\"当哨兵监测到master宕机\",{\"1\":{\"620\":1}}],[\"当从机断电宕机后\",{\"1\":{\"611\":1}}],[\"当主节点出现故障时\",{\"1\":{\"621\":1}}],[\"当主节点故障时\",{\"1\":{\"607\":1}}],[\"当主服务器宕机后\",{\"1\":{\"619\":1}}],[\"当主机恢复以后\",{\"1\":{\"611\":1}}],[\"当主机断电宕机后\",{\"1\":{\"611\":1}}],[\"当这一切都完成之后\",{\"1\":{\"1566\":1}}],[\"当这个队列满了\",{\"1\":{\"1520\":1}}],[\"当这个值达到重偏向阈值\",{\"1\":{\"1485\":1}}],[\"当这个tomcat实例出现问题之后\",{\"1\":{\"1200\":1}}],[\"当这个类有父类的时候\",{\"1\":{\"964\":1}}],[\"当这个选项打开时\",{\"1\":{\"602\":1}}],[\"当这些quorum个数sentinel哨兵认为master主节点失联\",{\"1\":{\"624\":1}}],[\"当这两个参数都设置为1的时候\",{\"1\":{\"491\":1}}],[\"当下次重启时利用之前持久化的文件即可实现数据恢复\",{\"1\":{\"584\":1}}],[\"当看到xxtemplate时可以对比resttemplat\",{\"1\":{\"583\":1}}],[\"当看到一个查询请求的响应时间的时候\",{\"1\":{\"388\":1}}],[\"当代码逻辑错误\",{\"1\":{\"580\":1}}],[\"当in语句中的参数个数大于或等于系统变量eq\",{\"1\":{\"553\":1}}],[\"当我们修改这个类的默认构造方法\",{\"1\":{\"1600\":1}}],[\"当我们对数据进行修改的时候\",{\"1\":{\"1285\":1}}],[\"当我们断开主机后\",{\"1\":{\"621\":1}}],[\"当我们调用套节字的读写方法\",{\"1\":{\"602\":1}}],[\"当我们选择把某个表以及该表索引的统计数据存放到磁盘上时\",{\"1\":{\"558\":1}}],[\"当我们想查询表中的记录时\",{\"1\":{\"545\":1}}],[\"当我们把节点b设置成节点a\",{\"1\":{\"467\":1}}],[\"当事务开启后\",{\"1\":{\"542\":1}}],[\"当事务提交后\",{\"1\":{\"542\":1}}],[\"当事务被分发给worker以后\",{\"1\":{\"460\":1}}],[\"当两个或多个事务选择同一行\",{\"1\":{\"532\":1}}],[\"当插入的字符数不足n时\",{\"1\":{\"530\":1}}],[\"当输入库名或者表名的时候\",{\"1\":{\"482\":1}}],[\"当一级缓存失效时\",{\"1\":{\"1283\":1}}],[\"当一个read操作发生时\",{\"1\":{\"1561\":1}}],[\"当一个对象在方法中被定义后\",{\"1\":{\"1488\":1}}],[\"当一个线程修改了共享变量的值\",{\"1\":{\"1471\":1}}],[\"当一个线程调用yield方法时\",{\"1\":{\"1383\":1}}],[\"当一个channelhandler处理完之后就会将数据交给下一个channelhandler\",{\"1\":{\"1224\":1}}],[\"当一个tomcat实例上保存了session信息后\",{\"1\":{\"1200\":1}}],[\"当一个master由于failover而发生改变时\",{\"1\":{\"624\":1}}],[\"当一个slave从一个错误的master那里同步数据开始计算时间\",{\"1\":{\"624\":1}}],[\"当一个哨兵主观认为主机断开\",{\"1\":{\"621\":1}}],[\"当一个事务读到一行数据的时候\",{\"1\":{\"497\":1}}],[\"当一个库中的表个数非常多的时候\",{\"1\":{\"482\":1}}],[\"当一部分行记录变成0的时候\",{\"1\":{\"444\":1}}],[\"当节点b要设置成a\",{\"1\":{\"467\":1}}],[\"当有多个构造方法和只有一个无参的构造方法都会返回null\",{\"1\":{\"1650\":1}}],[\"当有多个线程对一个原子类进行操作的时候\",{\"1\":{\"1479\":1}}],[\"当有中间操作的时候\",{\"1\":{\"1622\":1}}],[\"当有若干个线程都要使用某一共享资源时\",{\"1\":{\"1477\":1}}],[\"当有新消息通过\",{\"1\":{\"596\":1}}],[\"当有事务分配给worker的时候\",{\"1\":{\"461\":1}}],[\"当有一条记录需要更新的时候\",{\"1\":{\"324\":1}}],[\"当备库主机上的多个备库都在争抢资源的时候\",{\"1\":{\"457\":1}}],[\"当并发量很大的时候\",{\"1\":{\"444\":1}}],[\"当并发系统中不同线程出现循环资源以来\",{\"1\":{\"444\":1}}],[\"当所有事务都要更新同一行的场景时\",{\"1\":{\"444\":1}}],[\"当要对表结构做变更操作的时候\",{\"1\":{\"441\":1}}],[\"当mysql异常重启后就不会丢失数据了\",{\"1\":{\"451\":1}}],[\"当mysql本身异常重启的话\",{\"1\":{\"451\":1}}],[\"当mysqldump使用参数\",{\"1\":{\"438\":1}}],[\"当mysql认为内存足够大\",{\"1\":{\"356\":1}}],[\"当出现死锁以后\",{\"1\":{\"444\":2}}],[\"当出现并发访问的时候\",{\"1\":{\"436\":1}}],[\"当出现读写锁冲突的时候\",{\"1\":{\"433\":1}}],[\"当数据被hash后\",{\"1\":{\"1546\":1}}],[\"当数据的一个副本发生更改时\",{\"1\":{\"1474\":1}}],[\"当数据格式为timestamp和datetime时\",{\"1\":{\"529\":1}}],[\"当数据库上有多个事务同时执行的时候\",{\"1\":{\"433\":1}}],[\"当数据写入es时\",{\"1\":{\"308\":1}}],[\"当碰到第一个2的时候\",{\"1\":{\"417\":1}}],[\"当碰到第一个1的时候\",{\"1\":{\"417\":1}}],[\"当碰到优化器选择索引错误的时候\",{\"1\":{\"348\":1}}],[\"当参数设置为binlog\",{\"1\":{\"413\":1}}],[\"当能够使用in\",{\"1\":{\"394\":1}}],[\"当可以将数据分布到不同的mysql服务器上的时候\",{\"1\":{\"394\":1}}],[\"当应用能够方便地缓存单个查询结果的时候\",{\"1\":{\"394\":1}}],[\"当初次查询的时候将这个数据缓存起来\",{\"1\":{\"386\":1}}],[\"当前类是否\",{\"1\":{\"1648\":1}}],[\"当前类型\",{\"1\":{\"973\":1}}],[\"当前集合的迭代器\",{\"1\":{\"1622\":1}}],[\"当前集合的引用就是在这个时候被传递进去的\",{\"1\":{\"1621\":1}}],[\"当前传入的比较器就会发挥作用\",{\"1\":{\"1614\":1}}],[\"当前线程存在于同步队列的头结点\",{\"1\":{\"1492\":1}}],[\"当前线程如果获取同步状态失败时\",{\"1\":{\"1491\":1}}],[\"当前线程会让出cpu使用权\",{\"1\":{\"1383\":1}}],[\"当前获取锁的线程\",{\"1\":{\"1483\":1}}],[\"当前提交任务数大于\",{\"1\":{\"1410\":1}}],[\"当前全局的事务隔离级别\",{\"1\":{\"1262\":1}}],[\"当前会话的事务隔离级别\",{\"1\":{\"1262\":1}}],[\"当前servlet应用内部缓存\",{\"1\":{\"1182\":1}}],[\"当前场景\",{\"1\":{\"1007\":1}}],[\"当前的管道对象和流元的管道对象的中间操作的个数\",{\"1\":{\"1621\":1}}],[\"当前的索引\",{\"1\":{\"1620\":1}}],[\"当前的beanfactory\",{\"1\":{\"997\":1}}],[\"当前的自增值是y\",{\"1\":{\"491\":1}}],[\"当前beandefinition来自何方\",{\"1\":{\"1019\":1}}],[\"当前beanfactory查找\",{\"1\":{\"997\":1}}],[\"当前beanscopedemo\",{\"1\":{\"985\":2}}],[\"当前user对象\",{\"1\":{\"943\":1}}],[\"当前defaultuserfactory\",{\"1\":{\"934\":1}}],[\"当前未开启事务\",{\"1\":{\"579\":1}}],[\"当前key有设置过期时间\",{\"1\":{\"569\":2}}],[\"当前key没有设置过期时间\",{\"1\":{\"569\":1}}],[\"当前正在等待锁定的数量\",{\"1\":{\"538\":1}}],[\"当前正在执行\",{\"1\":{\"476\":1}}],[\"当前版本\",{\"1\":{\"535\":1}}],[\"当前读实际上是一个悲观锁的操作\",{\"1\":{\"541\":1}}],[\"当前读\",{\"1\":{\"446\":2,\"541\":1}}],[\"当前值是4\",{\"1\":{\"434\":1}}],[\"当前query中过滤性最好的字段在索引字段顺序中\",{\"1\":{\"380\":1}}],[\"当前索引是idx\",{\"1\":{\"361\":1}}],[\"当无法保证被驱动表的join条件字段被索引且内存资源充足的前提下\",{\"1\":{\"364\":1}}],[\"当需要覆盖数据时\",{\"1\":{\"1520\":1}}],[\"当需要批量提交异步任务的时候建议使用completionservice\",{\"1\":{\"1517\":1}}],[\"当需要切换的时候\",{\"1\":{\"453\":1}}],[\"当需要让整个库处于只读状态的时候\",{\"1\":{\"437\":1}}],[\"当需要更新一个数据页的时候\",{\"1\":{\"343\":1}}],[\"当需要读一条记录的时候\",{\"1\":{\"342\":1}}],[\"当需要查到所有名字是\",{\"1\":{\"339\":1}}],[\"当需要恢复到指定的某一秒时\",{\"1\":{\"327\":1}}],[\"当然可以跳过\",{\"1\":{\"1983\":1}}],[\"当然这是因为我们是没有任何的中间操作\",{\"1\":{\"1622\":1}}],[\"当然这个结果最终是在t6时刻正式提交的\",{\"1\":{\"447\":1}}],[\"当然也可以调用统计的方法一次将这些特征值都求出来\",{\"1\":{\"1616\":1}}],[\"当然也有可能会调度到刚刚让出cpu的那个线程来获取cpu执行权\",{\"1\":{\"1383\":1}}],[\"当然一开始这是不太容易能够理解的\",{\"1\":{\"1613\":1}}],[\"当然虽然这个函数的名字我们并不会直接去调用\",{\"1\":{\"1595\":1}}],[\"当然lambda表达式肯定不止只是能用来遍历集合这个简单\",{\"1\":{\"1593\":1}}],[\"当然了\",{\"1\":{\"488\":1}}],[\"当然如果这个线程有语句正在执行\",{\"1\":{\"480\":1}}],[\"当然为了唯一标识\",{\"1\":{\"465\":1}}],[\"当然\",{\"1\":{\"338\":1,\"342\":1,\"348\":1,\"352\":1,\"428\":1,\"465\":1,\"470\":1,\"473\":1,\"912\":1,\"984\":1,\"1608\":1,\"1612\":1,\"1614\":1,\"1969\":1}}],[\"当然事无绝对\",{\"1\":{\"335\":1}}],[\"当然有分裂就有合并\",{\"1\":{\"335\":1}}],[\"当相邻两个页由于删除了数据\",{\"1\":{\"335\":1}}],[\"当你需要扩容的时候\",{\"1\":{\"327\":1}}],[\"当实体类中的属性名和表中的字段名不一样怎么办\",{\"0\":{\"195\":1,\"1211\":1}}],[\"illustration\",{\"1\":{\"1620\":1}}],[\"illustrates\",{\"1\":{\"1619\":1,\"1620\":1}}],[\"illegal\",{\"1\":{\"1647\":1}}],[\"illegalargumentexception\",{\"1\":{\"1082\":1,\"1084\":1,\"1503\":1,\"1620\":1,\"1638\":1}}],[\"illegalstateexception\",{\"1\":{\"922\":1,\"1610\":1,\"1619\":1,\"1620\":2,\"1622\":4,\"1623\":1,\"1647\":4,\"1651\":1,\"1655\":2,\"1658\":1}}],[\"ignoring\",{\"1\":{\"1615\":1}}],[\"ignored\",{\"1\":{\"1647\":1}}],[\"ignoredependencyinterface\",{\"1\":{\"1164\":7,\"1651\":3}}],[\"ignores\",{\"1\":{\"1620\":1}}],[\"ignoreinvalidfields\",{\"1\":{\"1072\":1}}],[\"ignoreunknownfields\",{\"1\":{\"1072\":1}}],[\"ignoreresourcetype\",{\"1\":{\"966\":1}}],[\"ignore\",{\"1\":{\"963\":1}}],[\"i>\",{\"1\":{\"1594\":2,\"1617\":2}}],[\"i1\",{\"1\":{\"1591\":1}}],[\"i18n\",{\"1\":{\"892\":1,\"921\":1}}],[\"i<100\",{\"1\":{\"1521\":1}}],[\"i<=100\",{\"1\":{\"523\":1}}],[\"i<=10000\",{\"1\":{\"523\":1}}],[\"i<=100000\",{\"1\":{\"518\":1}}],[\"iadd\",{\"1\":{\"1482\":1}}],[\"ia\",{\"1\":{\"1479\":2,\"1654\":2}}],[\"it是spliterator中定义的迭代器\",{\"1\":{\"1622\":1}}],[\"its\",{\"1\":{\"1598\":10,\"1601\":2,\"1618\":2,\"1620\":9,\"1621\":1,\"1623\":2,\"1647\":1}}],[\"itself\",{\"1\":{\"997\":1,\"1175\":1,\"1623\":1,\"1647\":1,\"1648\":1}}],[\"itrs\",{\"1\":{\"1502\":2}}],[\"it\",{\"1\":{\"963\":1,\"997\":1,\"1166\":1,\"1597\":1,\"1598\":6,\"1615\":3,\"1617\":2,\"1618\":1,\"1619\":7,\"1620\":7,\"1621\":2,\"1622\":3,\"1623\":12,\"1647\":3,\"1655\":2,\"1689\":2}}],[\"iterable\",{\"1\":{\"1574\":3,\"1595\":2}}],[\"iterable<string>\",{\"1\":{\"943\":1}}],[\"iterative\",{\"1\":{\"1609\":1}}],[\"iteration\",{\"1\":{\"996\":1,\"1595\":4,\"1620\":1}}],[\"iterate\",{\"1\":{\"1609\":2,\"1610\":6}}],[\"iteratorspliterator是实现了spliterator接口的一个实现类\",{\"1\":{\"1621\":1}}],[\"iteratorspliterator<>\",{\"1\":{\"1621\":1}}],[\"iterators\",{\"1\":{\"1620\":1}}],[\"iterator<\",{\"1\":{\"1622\":1}}],[\"iterator<map\",{\"1\":{\"1618\":1}}],[\"iterator<t>\",{\"1\":{\"1609\":2,\"1619\":1}}],[\"iterator<selectionkey>\",{\"1\":{\"1574\":2}}],[\"iterator<userfactory>\",{\"1\":{\"930\":1}}],[\"iterator\",{\"1\":{\"645\":2,\"930\":4,\"963\":1,\"1574\":5,\"1609\":2,\"1618\":2,\"1619\":2,\"1620\":3,\"1622\":1,\"1648\":2}}],[\"item1\",{\"1\":{\"1614\":6}}],[\"item2\",{\"1\":{\"1609\":2,\"1614\":6}}],[\"item\",{\"1\":{\"519\":1,\"645\":1,\"1503\":4,\"1593\":2,\"1594\":2,\"1595\":2,\"1597\":2,\"1599\":28,\"1608\":2,\"1609\":14,\"1610\":39,\"1612\":3,\"1614\":4,\"1617\":9,\"1622\":2}}],[\"items\",{\"1\":{\"431\":1,\"519\":2,\"1502\":11}}],[\"i++的jvm字节码指令\",{\"1\":{\"1482\":1}}],[\"i++\",{\"1\":{\"645\":1,\"985\":1,\"989\":2,\"1182\":2,\"1347\":1,\"1404\":4,\"1487\":1,\"1517\":1,\"1521\":1,\"1593\":1,\"1611\":1,\"1612\":1,\"1614\":1}}],[\"ip>\",{\"1\":{\"624\":2}}],[\"ip\",{\"1\":{\"624\":3}}],[\"ipc\",{\"1\":{\"431\":1}}],[\"ix锁\",{\"1\":{\"533\":1}}],[\"i=0\",{\"1\":{\"1521\":1,\"1611\":1}}],[\"i=i+1\",{\"1\":{\"518\":1,\"523\":2}}],[\"i=1\",{\"1\":{\"518\":1,\"523\":2}}],[\"immediately\",{\"1\":{\"1620\":1}}],[\"immutable\",{\"1\":{\"1609\":1,\"1618\":1,\"1620\":11,\"1621\":1}}],[\"immutability模式即不变性模式\",{\"1\":{\"1526\":1}}],[\"immutability模式\",{\"0\":{\"1526\":1}}],[\"immutability\",{\"1\":{\"1107\":1}}],[\"imbalanced\",{\"1\":{\"1620\":1}}],[\"impose\",{\"1\":{\"1620\":1}}],[\"impossible\",{\"1\":{\"330\":2}}],[\"import注解的处理过程如下\",{\"1\":{\"1652\":1}}],[\"import注解导入具体实现\",{\"1\":{\"1138\":2}}],[\"importbeandefinitionregistrar\",{\"1\":{\"1138\":2}}],[\"importbeandefinitionregistar接口实现\",{\"1\":{\"1138\":1}}],[\"importingclassmetadata\",{\"1\":{\"1138\":2}}],[\"import具体实现\",{\"1\":{\"1138\":1}}],[\"importresource\",{\"1\":{\"1029\":2,\"1131\":1,\"1652\":1}}],[\"import方式导入\",{\"1\":{\"929\":1}}],[\"import\",{\"1\":{\"929\":2,\"1021\":1,\"1029\":2,\"1131\":1,\"1138\":6,\"1479\":4,\"1591\":8,\"1597\":1,\"1598\":1,\"1652\":1}}],[\"importselector接口实现\",{\"1\":{\"1138\":2}}],[\"importselector\",{\"1\":{\"900\":1,\"1138\":2}}],[\"implicitlyappearedsingletonexception\",{\"1\":{\"1647\":1}}],[\"implspec\",{\"1\":{\"1595\":1}}],[\"implementors\",{\"1\":{\"1620\":1}}],[\"implementing\",{\"1\":{\"1595\":2,\"1613\":1,\"1618\":1}}],[\"implementations\",{\"1\":{\"1615\":3,\"1616\":1,\"1620\":3,\"1621\":1,\"1623\":1}}],[\"implementation\",{\"1\":{\"1594\":6,\"1595\":1,\"1615\":7,\"1619\":1,\"1620\":3,\"1623\":6}}],[\"implement\",{\"1\":{\"1166\":3,\"1615\":3,\"1616\":1,\"1619\":1,\"1620\":1,\"1623\":1}}],[\"implements\",{\"1\":{\"930\":1,\"931\":1,\"933\":1,\"946\":1,\"951\":1,\"957\":1,\"963\":1,\"966\":1,\"985\":2,\"989\":1,\"1000\":1,\"1001\":1,\"1002\":1,\"1005\":1,\"1011\":1,\"1023\":1,\"1032\":1,\"1043\":1,\"1045\":1,\"1061\":1,\"1064\":1,\"1082\":1,\"1084\":2,\"1091\":1,\"1108\":1,\"1114\":1,\"1116\":1,\"1119\":1,\"1120\":1,\"1138\":2,\"1139\":2,\"1148\":1,\"1149\":1,\"1174\":1,\"1546\":1,\"1554\":1,\"1575\":3,\"1607\":4,\"1614\":1,\"1616\":1,\"1617\":3,\"1618\":1,\"1619\":1,\"1620\":1,\"1621\":1,\"1623\":3,\"1639\":1,\"1644\":1,\"1648\":1,\"1657\":1}}],[\"impl\",{\"1\":{\"645\":1}}],[\"image=full\",{\"1\":{\"484\":1}}],[\"images\",{\"1\":{\"472\":1,\"479\":1,\"1593\":1}}],[\"image\",{\"1\":{\"472\":2,\"479\":2}}],[\"image设置为minimal\",{\"1\":{\"454\":1}}],[\"image的默认配置是full\",{\"1\":{\"454\":1}}],[\"io拷贝机制对比\",{\"0\":{\"1585\":1}}],[\"io拷贝机制\",{\"0\":{\"1580\":1}}],[\"io模型对比\",{\"0\":{\"1576\":1}}],[\"io模式及select\",{\"1\":{\"1561\":1}}],[\"io多路复用就是通过一种机制\",{\"1\":{\"1568\":1}}],[\"io多路复用就是我们通常说的select\",{\"1\":{\"1565\":1}}],[\"io多路复用之select\",{\"0\":{\"1568\":1}}],[\"io多路复用均属于同步io\",{\"1\":{\"1567\":1}}],[\"io多路复用模型与阻塞io其实并没有太大的区别\",{\"1\":{\"1565\":1}}],[\"io多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符\",{\"1\":{\"1565\":1}}],[\"io多路复用\",{\"0\":{\"1565\":1},\"1\":{\"1561\":1}}],[\"io基础\",{\"0\":{\"1561\":1}}],[\"io密集型任务\",{\"1\":{\"1510\":2}}],[\"io效率\",{\"1\":{\"1423\":1}}],[\"ioutils\",{\"1\":{\"1040\":1,\"1041\":1,\"1043\":1}}],[\"ioexception\",{\"1\":{\"1022\":1,\"1032\":1,\"1043\":2,\"1082\":1,\"1084\":1,\"1163\":1,\"1175\":1,\"1574\":3,\"1591\":2,\"1646\":1,\"1647\":2,\"1651\":1}}],[\"ioc配置属性注解\",{\"1\":{\"1029\":1}}],[\"ioc配置元信息读取和解析\",{\"1\":{\"926\":1}}],[\"ioc配置元信息\",{\"0\":{\"920\":1}}],[\"ioc依赖注入\",{\"0\":{\"918\":1}}],[\"ioc依赖查找\",{\"0\":{\"917\":1}}],[\"ioc是反转控制\",{\"1\":{\"914\":1}}],[\"ioc的实现\",{\"0\":{\"908\":1}}],[\"ioc的发展简介\",{\"0\":{\"905\":1}}],[\"ioc主要的实现策略\",{\"1\":{\"906\":1}}],[\"ioc主要实现策略\",{\"0\":{\"906\":1}}],[\"ioc\",{\"1\":{\"892\":1,\"900\":1,\"917\":2,\"918\":1,\"930\":1,\"953\":2,\"954\":2,\"994\":1,\"1022\":1,\"1084\":1,\"1091\":1,\"1146\":1}}],[\"ioc容器中的bean\",{\"1\":{\"1653\":1}}],[\"ioc容器装配注解\",{\"1\":{\"1029\":1}}],[\"ioc容器相关xml配置\",{\"1\":{\"1028\":1}}],[\"ioc容器的实例化操作\",{\"1\":{\"1000\":1,\"1001\":1,\"1002\":1}}],[\"ioc容器的职责\",{\"0\":{\"907\":1}}],[\"ioc容器后\",{\"1\":{\"995\":1}}],[\"ioc容器存在多个bean实例\",{\"1\":{\"946\":1}}],[\"ioc容器启动时做了哪些准备\",{\"0\":{\"926\":1}}],[\"ioc容器生命周期\",{\"0\":{\"922\":1},\"1\":{\"926\":1}}],[\"ioc容器配置元信息\",{\"1\":{\"1035\":1}}],[\"ioc容器配置\",{\"1\":{\"920\":1}}],[\"ioc容器\",{\"0\":{\"924\":1},\"1\":{\"892\":1,\"921\":1,\"992\":1}}],[\"ioc容器自动代理标准实现\",{\"0\":{\"810\":1}}],[\"io与nio的区别\",{\"0\":{\"686\":1}}],[\"io与nio\",{\"0\":{\"685\":1}}],[\"io类型\",{\"1\":{\"589\":1}}],[\"io成本\",{\"1\":{\"545\":1,\"548\":1,\"549\":2}}],[\"io\",{\"1\":{\"431\":3,\"479\":4,\"557\":1,\"1037\":1,\"1038\":5,\"1039\":4,\"1040\":5,\"1041\":4,\"1042\":2,\"1134\":1,\"1155\":1,\"1227\":1,\"1565\":1,\"1572\":1,\"1591\":2,\"1614\":1,\"1619\":1,\"1620\":1}}],[\"i\",{\"1\":{\"400\":8,\"404\":15,\"414\":8,\"419\":9,\"429\":2,\"518\":3,\"523\":6,\"533\":1,\"577\":2,\"598\":3,\"645\":3,\"985\":2,\"989\":4,\"1022\":2,\"1163\":1,\"1166\":1,\"1182\":4,\"1347\":3,\"1404\":11,\"1480\":1,\"1482\":3,\"1487\":2,\"1517\":4,\"1521\":1,\"1549\":9,\"1550\":1,\"1551\":2,\"1554\":5,\"1591\":1,\"1593\":3,\"1603\":3,\"1607\":2,\"1610\":4,\"1611\":2,\"1612\":2,\"1614\":5,\"1617\":3,\"1619\":1,\"1620\":8,\"1622\":4,\"1634\":1,\"1647\":1,\"1651\":1,\"1969\":1}}],[\"isn\",{\"1\":{\"1650\":1}}],[\"isnonpublicaccessallowed\",{\"1\":{\"1650\":1}}],[\"isnull是一个静态方法的方法引用\",{\"1\":{\"1599\":1}}],[\"isnull\",{\"1\":{\"1594\":1,\"1599\":3}}],[\"isvavrtry\",{\"1\":{\"1655\":2}}],[\"isvalid\",{\"1\":{\"1574\":2}}],[\"isvisibilitybridgemethodpair\",{\"1\":{\"1648\":1}}],[\"isfactorybean\",{\"1\":{\"1647\":1}}],[\"islazyinit\",{\"1\":{\"1647\":1}}],[\"islocked判断\",{\"1\":{\"1495\":1}}],[\"isknown\",{\"1\":{\"1623\":1}}],[\"isub\",{\"1\":{\"1482\":1}}],[\"isruntime\",{\"1\":{\"1654\":1}}],[\"isrunning\",{\"1\":{\"1174\":1,\"1476\":2}}],[\"isreadable\",{\"1\":{\"1574\":2}}],[\"isrequired\",{\"1\":{\"963\":3,\"1648\":3}}],[\"istypematch\",{\"1\":{\"1166\":2,\"1171\":1,\"1648\":1}}],[\"istraceenabled\",{\"1\":{\"996\":1,\"1007\":1,\"1022\":1,\"1055\":2,\"1121\":2,\"1167\":2,\"1168\":2,\"1647\":2}}],[\"ispublic\",{\"1\":{\"1650\":1}}],[\"isparallel\",{\"1\":{\"1617\":1,\"1619\":2,\"1621\":2,\"1622\":1,\"1623\":1}}],[\"ispattern\",{\"1\":{\"1043\":1}}],[\"isprefiltered\",{\"1\":{\"1654\":2}}],[\"ispresent\",{\"1\":{\"964\":1,\"965\":1}}],[\"isprototypecurrentlyincreation\",{\"1\":{\"1647\":1}}],[\"isprototype\",{\"1\":{\"984\":1,\"985\":1,\"1647\":1}}],[\"iseager\",{\"1\":{\"1648\":1}}],[\"iseagerinit\",{\"1\":{\"1647\":6}}],[\"isequal\",{\"1\":{\"1594\":1,\"1599\":5}}],[\"isexternallymanagedinitmethod\",{\"1\":{\"1007\":2}}],[\"isempty\",{\"1\":{\"963\":4,\"1170\":1,\"1647\":1,\"1648\":3,\"1650\":1,\"1658\":1}}],[\"iscandidateclass\",{\"1\":{\"1648\":1}}],[\"iscandidatecomponent\",{\"1\":{\"1647\":4}}],[\"iscachebeanmetadata\",{\"1\":{\"997\":1,\"1647\":1}}],[\"isconcrete\",{\"1\":{\"1647\":1}}],[\"isconditionmatch\",{\"1\":{\"1647\":1}}],[\"isconnectable\",{\"1\":{\"1574\":1}}],[\"isconfigurationfrozen\",{\"1\":{\"996\":1}}],[\"isdependent\",{\"1\":{\"1647\":1}}],[\"isdefault\",{\"1\":{\"1594\":2}}],[\"isdebugenabled\",{\"1\":{\"996\":1,\"1022\":1,\"1175\":1}}],[\"isdynamic\",{\"1\":{\"645\":3}}],[\"issuspendingfunction\",{\"1\":{\"1655\":6}}],[\"issue\",{\"1\":{\"645\":1}}],[\"isselfreference\",{\"1\":{\"1648\":3}}],[\"isshutdown\",{\"1\":{\"1123\":1}}],[\"issynthetic\",{\"1\":{\"1008\":2,\"1647\":2}}],[\"issingletoncurrentlyincreation\",{\"1\":{\"1647\":2,\"1649\":1}}],[\"issingleton\",{\"1\":{\"984\":1,\"997\":2,\"1647\":6,\"1649\":1}}],[\"isstatic\",{\"1\":{\"964\":1,\"1648\":2}}],[\"isinstance\",{\"1\":{\"1648\":1}}],[\"isindependent\",{\"1\":{\"1647\":1}}],[\"isinterrupted\",{\"1\":{\"1477\":1}}],[\"isinterface\",{\"1\":{\"963\":1}}],[\"isinitializingbean\",{\"1\":{\"1007\":3}}],[\"isinfoenabled\",{\"1\":{\"964\":1,\"996\":1,\"1648\":3}}],[\"isinnerbean\",{\"1\":{\"928\":2}}],[\"isasyncsupported\",{\"1\":{\"1658\":1}}],[\"isassignablevalue\",{\"1\":{\"963\":1,\"1648\":1}}],[\"isassignablefrom\",{\"1\":{\"963\":1,\"1061\":1,\"1648\":1}}],[\"isabstract\",{\"1\":{\"1647\":2}}],[\"isacceptable\",{\"1\":{\"1574\":1}}],[\"isallowbeandefinitionoverriding\",{\"1\":{\"996\":1}}],[\"isarray\",{\"1\":{\"963\":1}}],[\"isautowirecandidate方法的作用是用来判断给定的bean是否可以用来依赖注入\",{\"1\":{\"1648\":1}}],[\"isautowirecandidate\",{\"1\":{\"1648\":8}}],[\"isautowire\",{\"1\":{\"952\":1}}],[\"isolated\",{\"1\":{\"1615\":1}}],[\"isolatiuon\",{\"1\":{\"1238\":1}}],[\"isolation=\",{\"1\":{\"532\":1}}],[\"isolation的值设置为read\",{\"1\":{\"433\":1}}],[\"isolation\",{\"1\":{\"432\":1,\"433\":1,\"532\":1,\"1238\":4,\"1615\":1}}],[\"isordered\",{\"1\":{\"963\":1,\"1617\":1}}],[\"iswarnenabled\",{\"1\":{\"922\":1,\"1647\":1,\"1651\":1}}],[\"is锁\",{\"1\":{\"533\":1}}],[\"is\",{\"1\":{\"369\":2,\"429\":2,\"519\":1,\"573\":1,\"580\":1,\"928\":1,\"944\":1,\"964\":1,\"997\":1,\"1013\":1,\"1022\":3,\"1053\":1,\"1063\":2,\"1162\":1,\"1166\":2,\"1175\":1,\"1184\":1,\"1432\":1,\"1479\":1,\"1480\":2,\"1594\":9,\"1595\":3,\"1597\":8,\"1598\":25,\"1599\":16,\"1600\":6,\"1601\":8,\"1608\":6,\"1613\":1,\"1614\":1,\"1615\":18,\"1617\":5,\"1618\":7,\"1619\":11,\"1620\":40,\"1621\":21,\"1622\":6,\"1623\":14,\"1647\":5,\"1648\":2,\"1650\":1,\"1655\":2,\"1658\":1,\"1663\":1}}],[\"ismale=1\",{\"1\":{\"340\":1}}],[\"ibatis\",{\"1\":{\"645\":4}}],[\"ibd文件\",{\"1\":{\"424\":2}}],[\"ibd为后缀的文件\",{\"1\":{\"412\":1}}],[\"ibdata1\",{\"1\":{\"345\":1}}],[\"ibd\",{\"1\":{\"345\":1}}],[\"ib\",{\"1\":{\"345\":1}}],[\"iconst\",{\"1\":{\"1482\":2}}],[\"icon\",{\"1\":{\"330\":1}}],[\"ifpresent\",{\"1\":{\"1609\":1,\"1610\":1,\"1612\":2,\"1616\":2}}],[\"ifavailable方法的安全性\",{\"1\":{\"944\":1}}],[\"ifavailable\",{\"1\":{\"943\":1}}],[\"if\",{\"1\":{\"306\":2,\"361\":2,\"362\":4,\"363\":2,\"429\":1,\"506\":3,\"518\":1,\"523\":2,\"542\":3,\"630\":1,\"645\":4,\"917\":2,\"921\":2,\"922\":1,\"928\":8,\"929\":1,\"941\":2,\"963\":40,\"964\":6,\"965\":1,\"967\":1,\"985\":1,\"989\":1,\"996\":11,\"997\":12,\"998\":1,\"1000\":3,\"1001\":1,\"1002\":2,\"1003\":4,\"1005\":12,\"1006\":2,\"1007\":5,\"1008\":4,\"1011\":1,\"1019\":2,\"1022\":3,\"1023\":2,\"1027\":5,\"1030\":1,\"1055\":6,\"1056\":1,\"1061\":1,\"1116\":1,\"1121\":3,\"1123\":2,\"1124\":1,\"1139\":2,\"1162\":1,\"1163\":1,\"1164\":7,\"1165\":2,\"1166\":5,\"1167\":6,\"1168\":3,\"1170\":1,\"1171\":3,\"1172\":2,\"1175\":6,\"1191\":1,\"1193\":2,\"1215\":1,\"1288\":3,\"1347\":1,\"1388\":2,\"1404\":3,\"1412\":1,\"1432\":7,\"1476\":7,\"1479\":6,\"1480\":2,\"1502\":3,\"1503\":6,\"1506\":1,\"1517\":1,\"1531\":2,\"1549\":10,\"1550\":15,\"1553\":7,\"1554\":27,\"1574\":19,\"1575\":3,\"1594\":2,\"1595\":4,\"1597\":3,\"1598\":12,\"1599\":23,\"1601\":2,\"1607\":2,\"1611\":1,\"1613\":1,\"1614\":4,\"1615\":7,\"1617\":6,\"1618\":9,\"1619\":3,\"1620\":35,\"1621\":11,\"1622\":11,\"1623\":9,\"1647\":80,\"1648\":45,\"1649\":1,\"1650\":9,\"1651\":3,\"1654\":9,\"1655\":15,\"1658\":3,\"1663\":6,\"1689\":6}}],[\"ik分词器\",{\"1\":{\"1255\":1}}],[\"ik\",{\"1\":{\"306\":1}}],[\"in表示上游流源的元素类型\",{\"1\":{\"1621\":1}}],[\"in>\",{\"1\":{\"1621\":2,\"1623\":20}}],[\"inaccurate\",{\"1\":{\"1620\":1}}],[\"inactive\",{\"1\":{\"1175\":1}}],[\"inability\",{\"1\":{\"1620\":1}}],[\"inherent\",{\"1\":{\"1620\":1}}],[\"inherits\",{\"1\":{\"1620\":1}}],[\"inherited修饰的注解\",{\"1\":{\"1133\":1}}],[\"inherited注解的作用是\",{\"1\":{\"1133\":1}}],[\"inherited\",{\"1\":{\"961\":3,\"997\":1,\"1133\":1,\"1135\":1,\"1647\":1}}],[\"inexpensive\",{\"1\":{\"1620\":1}}],[\"inexact\",{\"1\":{\"1620\":1}}],[\"inefficient\",{\"1\":{\"1620\":2}}],[\"inetsocketaddress\",{\"1\":{\"1533\":1,\"1534\":1,\"1574\":2,\"1575\":2}}],[\"inline\",{\"1\":{\"1479\":2}}],[\"injectingenvironmentdemo\",{\"1\":{\"1148\":10,\"1149\":3}}],[\"injectingapplicationeventpublisherdemo\",{\"1\":{\"1120\":2}}],[\"injectionmetadata\",{\"1\":{\"964\":2,\"967\":1,\"1648\":5}}],[\"injectionpoint\",{\"1\":{\"963\":2,\"1648\":2}}],[\"injection\",{\"1\":{\"918\":1,\"919\":1,\"924\":1,\"953\":3,\"954\":3,\"964\":1,\"1001\":1,\"1005\":2,\"1006\":1,\"1011\":1,\"1647\":1,\"1648\":1}}],[\"injectresourceloaderdemo\",{\"1\":{\"1045\":2}}],[\"injectresourcedemo\",{\"1\":{\"1044\":2}}],[\"injected\",{\"1\":{\"1647\":1}}],[\"injecteduser\",{\"1\":{\"967\":7}}],[\"injectedelement>\",{\"1\":{\"1648\":2}}],[\"injectedelement\",{\"1\":{\"967\":1}}],[\"inject<\",{\"1\":{\"965\":2}}],[\"inject注解\",{\"1\":{\"965\":1}}],[\"inject注入过程\",{\"1\":{\"965\":1}}],[\"inject和\",{\"0\":{\"965\":1},\"1\":{\"965\":1}}],[\"inject\",{\"1\":{\"955\":1,\"956\":1,\"964\":2,\"965\":5,\"967\":1,\"1023\":1,\"1648\":1}}],[\"independent\",{\"1\":{\"1623\":1}}],[\"indexfor\",{\"1\":{\"1548\":1}}],[\"index是long类型\",{\"1\":{\"1519\":1}}],[\"index都是由sharding组成的\",{\"1\":{\"1254\":1}}],[\"index语句展示出的cardinality属性\",{\"1\":{\"553\":1}}],[\"index语句展示出来的某个索引列的cardinality属性是一个估计值\",{\"1\":{\"553\":1}}],[\"indexes\",{\"1\":{\"519\":2}}],[\"index文件\",{\"1\":{\"485\":1}}],[\"index2\",{\"1\":{\"350\":1}}],[\"index1\",{\"1\":{\"350\":1}}],[\"index指定的索引在候选索引列表中\",{\"1\":{\"348\":1}}],[\"index强行选择一个索引\",{\"1\":{\"348\":1}}],[\"index方法\",{\"1\":{\"347\":1}}],[\"index的时候\",{\"1\":{\"346\":1}}],[\"index和all的区别为index类型只遍历索引树\",{\"1\":{\"330\":1}}],[\"indexname\",{\"1\":{\"307\":1}}],[\"index\",{\"0\":{\"401\":1,\"553\":1},\"1\":{\"304\":1,\"305\":1,\"306\":1,\"307\":15,\"308\":2,\"312\":1,\"330\":8,\"335\":3,\"336\":1,\"340\":1,\"346\":3,\"348\":1,\"350\":2,\"352\":1,\"356\":3,\"361\":2,\"362\":2,\"363\":2,\"366\":1,\"378\":1,\"390\":1,\"401\":1,\"404\":1,\"407\":1,\"409\":1,\"414\":2,\"416\":1,\"417\":1,\"431\":1,\"509\":1,\"517\":1,\"519\":13,\"553\":10,\"555\":2,\"558\":8,\"559\":3,\"571\":2,\"635\":1,\"639\":1,\"1254\":1,\"1479\":1,\"1553\":3}}],[\"indicating\",{\"1\":{\"1615\":1}}],[\"indicate\",{\"1\":{\"1594\":2,\"1655\":1}}],[\"indicatesmultiplebeans\",{\"1\":{\"963\":1,\"1648\":2}}],[\"indicates\",{\"1\":{\"952\":3,\"1617\":3}}],[\"individually\",{\"1\":{\"1620\":1}}],[\"individual\",{\"1\":{\"1175\":1,\"1621\":1}}],[\"invalid\",{\"1\":{\"1647\":1}}],[\"involved\",{\"1\":{\"1620\":1}}],[\"invocationcallback\",{\"1\":{\"1655\":2}}],[\"invocationhandler\",{\"1\":{\"1654\":1}}],[\"invocations\",{\"1\":{\"1615\":1,\"1620\":2}}],[\"invocation\",{\"1\":{\"1008\":1,\"1615\":1,\"1620\":2,\"1655\":7}}],[\"invoking\",{\"1\":{\"1007\":1,\"1619\":1}}],[\"invokewithintransaction\",{\"1\":{\"1655\":2}}],[\"invokesuspendingfunction\",{\"1\":{\"1655\":1}}],[\"invokesuper\",{\"1\":{\"1654\":1}}],[\"invokes\",{\"1\":{\"1620\":1}}],[\"invoked\",{\"1\":{\"1600\":2,\"1617\":49,\"1619\":4}}],[\"invokelistener\",{\"1\":{\"1124\":2}}],[\"invokecustominitmethod\",{\"1\":{\"1007\":1}}],[\"invokeinitmethods\",{\"1\":{\"1007\":1,\"1008\":1}}],[\"invokeinitmethods方法当中\",{\"1\":{\"1007\":1}}],[\"invokeawareinterfaces方法\",{\"1\":{\"1005\":1}}],[\"invokeawareinterfaces\",{\"1\":{\"1005\":2}}],[\"invokeawaremethods\",{\"1\":{\"1005\":1,\"1008\":2}}],[\"invokebeanfactorypostprocessors\",{\"1\":{\"922\":1,\"1165\":3,\"1647\":1,\"1651\":1}}],[\"invoke\",{\"1\":{\"922\":1,\"1432\":1,\"1615\":1,\"1620\":1,\"1623\":2,\"1647\":1,\"1654\":3,\"1663\":1}}],[\"inversion\",{\"1\":{\"905\":1}}],[\"infinite\",{\"1\":{\"1609\":1,\"1620\":2}}],[\"infrastructure\",{\"1\":{\"996\":1}}],[\"inf\",{\"1\":{\"574\":1,\"917\":1,\"918\":1,\"919\":1,\"921\":1,\"930\":3,\"953\":5,\"954\":3,\"955\":1,\"961\":3,\"962\":1,\"963\":1,\"978\":1,\"994\":1,\"997\":1,\"1000\":1,\"1001\":2,\"1005\":4,\"1006\":2,\"1011\":2,\"1022\":1,\"1029\":3,\"1030\":1,\"1031\":1,\"1032\":3,\"1044\":2,\"1048\":1,\"1065\":1,\"1084\":1,\"1146\":3,\"1658\":1}}],[\"informing\",{\"1\":{\"1623\":1}}],[\"inform\",{\"1\":{\"1623\":1}}],[\"informative\",{\"1\":{\"1594\":2}}],[\"information\",{\"1\":{\"434\":1,\"519\":2,\"520\":6,\"538\":3,\"544\":1,\"1615\":1,\"1623\":4}}],[\"info\",{\"1\":{\"553\":2,\"555\":3,\"609\":2,\"964\":1,\"996\":1,\"1166\":1,\"1648\":3}}],[\"info`\",{\"1\":{\"368\":1}}],[\"initapplicationexception\",{\"1\":{\"1655\":1}}],[\"initapplicationeventmulticaster方法\",{\"1\":{\"1168\":1}}],[\"initapplicationeventmulticaster中看到\",{\"1\":{\"1121\":1}}],[\"initapplicationeventmulticaster\",{\"1\":{\"922\":1,\"1121\":1,\"1168\":1,\"1647\":1,\"1651\":1}}],[\"initiation\",{\"1\":{\"1620\":1}}],[\"initiated\",{\"1\":{\"1619\":1}}],[\"initial\",{\"1\":{\"1550\":5,\"1609\":1,\"1619\":1,\"1621\":3,\"1623\":4}}],[\"initialvalue\",{\"1\":{\"989\":1}}],[\"initializingbean\",{\"1\":{\"931\":1,\"946\":1,\"1007\":3,\"1234\":1}}],[\"initialization\",{\"1\":{\"922\":1,\"927\":2,\"931\":1,\"932\":1,\"1480\":1,\"1554\":1,\"1647\":2,\"1651\":1}}],[\"initialized\",{\"1\":{\"1647\":1}}],[\"initializes\",{\"1\":{\"1554\":1}}],[\"initializebean\",{\"1\":{\"1008\":1,\"1017\":4,\"1647\":1}}],[\"initialize\",{\"1\":{\"922\":3,\"1162\":1,\"1170\":1,\"1171\":2,\"1172\":1,\"1647\":5}}],[\"inittable方法具体如下\",{\"1\":{\"1554\":1}}],[\"inittable\",{\"1\":{\"1554\":2}}],[\"inited=true\",{\"1\":{\"1531\":1}}],[\"inited\",{\"1\":{\"1531\":2}}],[\"initlifecycleprocessor\",{\"1\":{\"1172\":2}}],[\"initpropertysources\",{\"1\":{\"1162\":2}}],[\"initpostconstruct\",{\"1\":{\"1007\":2}}],[\"initparameternamediscovery\",{\"1\":{\"963\":1,\"1648\":1}}],[\"initbylookup\",{\"1\":{\"973\":1}}],[\"initdestroyannotationbeanpostprocessor\",{\"1\":{\"966\":1}}],[\"inituserholder2\",{\"1\":{\"956\":1}}],[\"inituserholder\",{\"1\":{\"956\":1}}],[\"inituserfactory\",{\"1\":{\"931\":4}}],[\"init=\",{\"1\":{\"932\":1}}],[\"initmethodname\",{\"1\":{\"931\":3,\"1007\":4,\"1632\":1}}],[\"initmethod\",{\"1\":{\"931\":1}}],[\"initmethod=\",{\"1\":{\"931\":1}}],[\"initmessagesource方法\",{\"1\":{\"1167\":1}}],[\"initmessagesource\",{\"1\":{\"922\":1,\"1055\":1,\"1167\":1,\"1647\":1,\"1651\":1}}],[\"init\",{\"1\":{\"431\":1,\"922\":1,\"931\":4,\"946\":2,\"973\":1,\"977\":1,\"985\":1,\"1007\":2,\"1008\":1,\"1009\":1,\"1012\":2,\"1020\":3,\"1022\":1,\"1030\":1,\"1044\":1,\"1045\":1,\"1120\":1,\"1171\":1,\"1234\":1,\"1531\":1,\"1647\":1}}],[\"inconsistent\",{\"1\":{\"1620\":1}}],[\"incorporate\",{\"1\":{\"1623\":1}}],[\"incorporated\",{\"1\":{\"1608\":2}}],[\"incorporating\",{\"1\":{\"1608\":2,\"1615\":1}}],[\"including\",{\"1\":{\"1620\":1,\"1623\":1}}],[\"includefilters\",{\"1\":{\"1645\":1,\"1647\":1}}],[\"includefilter表示包含过滤器\",{\"1\":{\"1645\":1}}],[\"include\",{\"1\":{\"429\":1,\"1615\":1,\"1623\":1}}],[\"increases\",{\"1\":{\"1620\":2}}],[\"increase\",{\"1\":{\"928\":1}}],[\"increment没有改变\",{\"1\":{\"494\":1}}],[\"increment是两个系统参数\",{\"1\":{\"491\":1}}],[\"increment为步长\",{\"1\":{\"491\":1}}],[\"increment值填到自增字段\",{\"1\":{\"491\":1}}],[\"increment的值\",{\"1\":{\"490\":1}}],[\"increment就会变成10\",{\"1\":{\"490\":1}}],[\"increment还是11\",{\"1\":{\"490\":1}}],[\"increment=1\",{\"1\":{\"518\":1}}],[\"increment=11\",{\"1\":{\"490\":1}}],[\"increment=4\",{\"1\":{\"510\":1}}],[\"increment=4294967295\",{\"1\":{\"494\":2}}],[\"increment=2\",{\"1\":{\"490\":1,\"491\":1}}],[\"increment\",{\"1\":{\"330\":1,\"335\":1,\"361\":1,\"362\":2,\"363\":1,\"378\":1,\"419\":1,\"459\":1,\"489\":1,\"491\":6,\"494\":2,\"506\":1,\"510\":1,\"518\":1,\"523\":1,\"528\":1,\"534\":1,\"535\":1,\"1432\":1,\"1482\":3,\"1663\":1}}],[\"incrbyfloat\",{\"1\":{\"570\":2}}],[\"incrby\",{\"1\":{\"570\":2,\"581\":3}}],[\"incr\",{\"1\":{\"570\":2,\"580\":1}}],[\"insensitive\",{\"1\":{\"1614\":2}}],[\"insert语句自动添加排他锁\",{\"1\":{\"1263\":1}}],[\"insert语句要插入10万行数据\",{\"1\":{\"492\":1}}],[\"insert语句对应的writeset就要多增加一个哈希值\",{\"1\":{\"465\":1}}],[\"insert语句的binlog会记录所有的字段信息\",{\"1\":{\"454\":1}}],[\"insert和update这三种sql语句的角度\",{\"1\":{\"454\":1}}],[\"insert\",{\"1\":{\"336\":1,\"345\":1,\"361\":5,\"368\":15,\"378\":5,\"400\":2,\"404\":2,\"407\":1,\"409\":1,\"413\":2,\"414\":1,\"419\":1,\"424\":1,\"433\":1,\"442\":1,\"446\":1,\"447\":2,\"454\":6,\"459\":4,\"462\":1,\"468\":2,\"476\":1,\"478\":1,\"484\":2,\"491\":4,\"492\":2,\"494\":2,\"498\":1,\"506\":3,\"510\":3,\"518\":7,\"523\":8,\"534\":4,\"535\":6,\"541\":1,\"542\":1,\"544\":1,\"547\":2,\"553\":3,\"555\":2,\"1261\":1}}],[\"ins\",{\"1\":{\"571\":3}}],[\"instantiationstrategy\",{\"1\":{\"1001\":1,\"1651\":2}}],[\"instantiationaware\",{\"1\":{\"1000\":1,\"1647\":2}}],[\"instantiationawarebeanpostprocessors\",{\"1\":{\"1647\":1}}],[\"instantiationawarebeanpostprocessor\",{\"1\":{\"966\":1,\"967\":1,\"1000\":3,\"1001\":1,\"1002\":2,\"1003\":2,\"1071\":1,\"1647\":5}}],[\"instantiation\",{\"1\":{\"930\":3,\"1166\":1,\"1647\":1}}],[\"instantiateusingfactorymethod\",{\"1\":{\"1650\":1}}],[\"instantiatebean\",{\"1\":{\"1001\":1,\"1093\":1,\"1650\":2}}],[\"instantiate\",{\"1\":{\"922\":1,\"1001\":1,\"1009\":1,\"1171\":1,\"1647\":3}}],[\"instancecomparator<>\",{\"1\":{\"1654\":1}}],[\"instancecandidate\",{\"1\":{\"963\":7,\"1648\":7}}],[\"instancewrapper\",{\"1\":{\"1647\":7}}],[\"instancesupplier\",{\"1\":{\"1650\":3}}],[\"instances\",{\"1\":{\"1594\":2,\"1619\":2,\"1620\":1,\"1623\":1}}],[\"instanceregisteredevent\",{\"1\":{\"1126\":1}}],[\"instancepreregisteredevent\",{\"1\":{\"1126\":1}}],[\"instanceof\",{\"1\":{\"917\":2,\"921\":2,\"928\":1,\"941\":2,\"963\":7,\"996\":1,\"997\":3,\"1003\":1,\"1005\":11,\"1007\":1,\"1055\":1,\"1065\":1,\"1123\":1,\"1166\":3,\"1167\":1,\"1549\":1,\"1550\":1,\"1554\":1,\"1620\":2,\"1647\":10,\"1648\":6,\"1654\":3,\"1655\":4}}],[\"instance\",{\"1\":{\"429\":1,\"917\":1,\"918\":1,\"930\":5,\"953\":2,\"954\":2,\"997\":1,\"1030\":1,\"1032\":1,\"1065\":1,\"1084\":1,\"1091\":1,\"1146\":1,\"1195\":1,\"1484\":1,\"1620\":4,\"1621\":1,\"1623\":3,\"1647\":11,\"1654\":1}}],[\"instruments\",{\"1\":{\"479\":1}}],[\"instead\",{\"1\":{\"429\":1,\"1619\":1,\"1620\":1,\"1647\":1}}],[\"innativeimage\",{\"1\":{\"1164\":1,\"1165\":1,\"1172\":1,\"1175\":1,\"1651\":1}}],[\"innod\",{\"1\":{\"479\":1}}],[\"innodb中\",{\"1\":{\"1266\":1}}],[\"innodb中的统计数据\",{\"0\":{\"558\":1}}],[\"innodb采用的是聚簇索引\",{\"1\":{\"1266\":1}}],[\"innodb支持\",{\"1\":{\"1263\":1}}],[\"innodb支持xa事务\",{\"1\":{\"1260\":1}}],[\"innodb支持事务的savepoints\",{\"1\":{\"1260\":1}}],[\"innodb支持事务\",{\"1\":{\"1260\":1}}],[\"innodb默认是以表为单位来收集和存储统计数据的\",{\"1\":{\"558\":1,\"559\":1}}],[\"innodb默认会选择n个数据页\",{\"1\":{\"347\":1}}],[\"innodb统计一个表中有多少行记录是这样的\",{\"1\":{\"558\":1}}],[\"innodb提供了两种存储统计数据的方式\",{\"1\":{\"558\":1}}],[\"innodb提供了innodb\",{\"1\":{\"451\":1}}],[\"innodb存储引擎都是将数据和索引都存储到磁盘上的\",{\"1\":{\"545\":1}}],[\"innodb有专门的purge线程来清理delete\",{\"1\":{\"542\":1}}],[\"innodb有一个后台线程\",{\"1\":{\"451\":1}}],[\"innodb把这些为了回滚而记录的这些东西称之为undo\",{\"1\":{\"542\":1}}],[\"innodb下的当前读和快照读\",{\"1\":{\"541\":1}}],[\"innodb索引实现\",{\"1\":{\"505\":1}}],[\"innodb才真正分配了trx\",{\"1\":{\"497\":1}}],[\"innodb并不会分配trx\",{\"1\":{\"497\":1}}],[\"innodb并不会去看age的值\",{\"1\":{\"340\":1}}],[\"innodb数据可见性的核心思想是\",{\"1\":{\"497\":1}}],[\"innodb内部维护了一个max\",{\"1\":{\"497\":1}}],[\"innodb内部使用xid\",{\"1\":{\"497\":1}}],[\"innodb自己的trx\",{\"1\":{\"497\":1}}],[\"innodb维护了一个全局的dict\",{\"1\":{\"495\":1}}],[\"innodb系统自增row\",{\"0\":{\"495\":1}}],[\"innodb放弃了这个设计\",{\"1\":{\"491\":1}}],[\"innodb发现用户没有指定自增id的值\",{\"1\":{\"491\":1}}],[\"innodb就只需要拷贝读写事务的trx\",{\"1\":{\"497\":1}}],[\"innodb就会认为线程数用满了\",{\"1\":{\"476\":1}}],[\"innodb就认为redo\",{\"1\":{\"451\":1}}],[\"innodb就可以保证即使数据库发生异常重启\",{\"1\":{\"324\":1}}],[\"innodb给每个索引加上了一个不存在得最大值supremum\",{\"1\":{\"448\":1}}],[\"innodb引入了间隙锁\",{\"1\":{\"448\":1}}],[\"innodb引擎的自增值\",{\"1\":{\"490\":1}}],[\"innodb引擎引入了本地分区策略\",{\"1\":{\"425\":1}}],[\"innodb引擎遍历整张表\",{\"1\":{\"399\":1}}],[\"innodb引擎会自动选择所有数据都不相等的列\",{\"1\":{\"505\":1}}],[\"innodb引擎会遍历整张表\",{\"1\":{\"399\":1}}],[\"innodb引擎会在适当的时候\",{\"1\":{\"324\":1}}],[\"innodb引擎在执行count\",{\"1\":{\"396\":1}}],[\"innodb引擎就会先把记录写到redo\",{\"1\":{\"324\":1}}],[\"innodb是索引组织表\",{\"1\":{\"396\":1}}],[\"innodb对这个语句也做个一定程度的优化\",{\"1\":{\"396\":1}}],[\"innodb只好把数据一行一行地读出依次判断\",{\"1\":{\"396\":1}}],[\"innodb表\",{\"1\":{\"396\":1}}],[\"innodb会创建一个隐藏的row\",{\"1\":{\"1266\":1}}],[\"innodb会对update\",{\"1\":{\"1263\":1}}],[\"innodb会自动以db\",{\"1\":{\"542\":1}}],[\"innodb会先排好name\",{\"1\":{\"505\":1}}],[\"innodb会把数据从临时表取出来\",{\"1\":{\"354\":1}}],[\"innodb会将这些更新操作缓存在change\",{\"1\":{\"343\":1}}],[\"innodb的主键索引\",{\"1\":{\"518\":1}}],[\"innodb的max\",{\"1\":{\"499\":1}}],[\"innodb的处理流程如下\",{\"1\":{\"343\":1}}],[\"innodb的处理流程\",{\"1\":{\"343\":1}}],[\"innodb的数据是按数据页为到位来读写的\",{\"1\":{\"342\":1}}],[\"innodb的redo\",{\"1\":{\"324\":1}}],[\"innodb在执行查询语句select时\",{\"1\":{\"535\":1}}],[\"innodb在设计时\",{\"1\":{\"495\":1}}],[\"innodb在接收到新请求的时候\",{\"1\":{\"476\":1}}],[\"innodb在普通索引a上查到主键id的值后\",{\"1\":{\"404\":1}}],[\"innodb在\",{\"1\":{\"340\":1}}],[\"innodb\",{\"0\":{\"497\":1},\"1\":{\"335\":1,\"336\":1,\"338\":1,\"345\":1,\"346\":1,\"349\":1,\"353\":1,\"354\":5,\"366\":1,\"368\":1,\"400\":1,\"419\":1,\"424\":6,\"433\":1,\"434\":1,\"444\":1,\"446\":1,\"454\":1,\"459\":1,\"462\":1,\"468\":1,\"476\":4,\"478\":1,\"479\":5,\"481\":1,\"489\":1,\"497\":1,\"503\":1,\"506\":3,\"537\":1,\"538\":12,\"558\":10,\"559\":2}}],[\"inner\",{\"1\":{\"384\":2,\"522\":1,\"524\":1,\"525\":1,\"554\":5,\"555\":2,\"928\":1,\"997\":1,\"1164\":1,\"1166\":1,\"1647\":1}}],[\"ing\",{\"1\":{\"375\":2}}],[\"inputshape\",{\"1\":{\"1622\":2,\"1623\":2}}],[\"inputstreamresource\",{\"1\":{\"1038\":1}}],[\"inputstreamreader\",{\"1\":{\"1022\":1,\"1573\":2}}],[\"inputstream\",{\"1\":{\"1022\":1}}],[\"inputsource\",{\"1\":{\"959\":1}}],[\"input\",{\"1\":{\"352\":1,\"1573\":2,\"1597\":4,\"1598\":16,\"1599\":6,\"1601\":2,\"1613\":2,\"1615\":8,\"1617\":1,\"1618\":5,\"1621\":1,\"1623\":6}}],[\"in等的查询\",{\"1\":{\"330\":1}}],[\"intfunction\",{\"1\":{\"1623\":1}}],[\"intpipeline\",{\"1\":{\"1621\":2}}],[\"intconsumer和consumer类型并没有直接继承的关系\",{\"1\":{\"1620\":1}}],[\"intconsumer\",{\"1\":{\"1620\":28}}],[\"intclass\",{\"1\":{\"1099\":1}}],[\"intrinsic\",{\"1\":{\"1617\":1}}],[\"introspection\",{\"1\":{\"922\":1,\"1647\":1,\"1651\":1}}],[\"introspector\",{\"1\":{\"909\":1,\"928\":1,\"995\":1,\"1075\":2}}],[\"introductionadvisor\",{\"1\":{\"1654\":3}}],[\"introductionawaremethodmatcher\",{\"1\":{\"1654\":2}}],[\"introduction\",{\"0\":{\"827\":1}}],[\"ints\",{\"1\":{\"1623\":4}}],[\"intsummarystatistics\",{\"1\":{\"1610\":5}}],[\"intsupplier等等\",{\"1\":{\"1601\":1}}],[\"intstream\",{\"1\":{\"1607\":7,\"1610\":2,\"1619\":2}}],[\"intx\",{\"1\":{\"1485\":2}}],[\"int或integer\",{\"1\":{\"528\":1}}],[\"intoset\",{\"1\":{\"1615\":1}}],[\"intorductionadvisor接口\",{\"0\":{\"795\":1}}],[\"into`test`\",{\"1\":{\"534\":4}}],[\"into\",{\"1\":{\"336\":1,\"345\":1,\"354\":2,\"361\":5,\"368\":15,\"378\":5,\"400\":2,\"404\":2,\"407\":1,\"409\":1,\"413\":4,\"414\":1,\"419\":1,\"422\":3,\"424\":1,\"433\":1,\"446\":1,\"447\":2,\"454\":6,\"459\":4,\"462\":1,\"468\":2,\"476\":1,\"478\":1,\"490\":1,\"491\":4,\"492\":1,\"494\":2,\"506\":3,\"510\":3,\"518\":4,\"523\":2,\"535\":3,\"1608\":4,\"1615\":11,\"1616\":4,\"1618\":2,\"1619\":3,\"1621\":2,\"1623\":5,\"1647\":1}}],[\"int\",{\"1\":{\"323\":2,\"330\":3,\"335\":2,\"336\":2,\"338\":2,\"346\":3,\"352\":1,\"353\":2,\"361\":5,\"362\":4,\"363\":2,\"366\":2,\"367\":1,\"368\":2,\"378\":1,\"400\":4,\"404\":4,\"407\":3,\"412\":1,\"413\":2,\"414\":4,\"417\":1,\"419\":2,\"424\":1,\"433\":1,\"446\":3,\"454\":2,\"459\":2,\"462\":3,\"468\":2,\"476\":2,\"478\":1,\"489\":3,\"493\":1,\"494\":2,\"506\":5,\"510\":2,\"518\":3,\"523\":5,\"534\":1,\"535\":2,\"567\":3,\"645\":9,\"921\":1,\"928\":1,\"930\":1,\"952\":3,\"959\":1,\"963\":2,\"985\":1,\"989\":2,\"994\":1,\"995\":3,\"997\":1,\"1000\":1,\"1001\":1,\"1005\":1,\"1006\":1,\"1011\":1,\"1021\":2,\"1022\":3,\"1053\":2,\"1061\":1,\"1099\":3,\"1166\":1,\"1182\":2,\"1227\":2,\"1347\":3,\"1404\":7,\"1412\":2,\"1475\":3,\"1476\":4,\"1479\":12,\"1480\":2,\"1482\":1,\"1485\":1,\"1487\":1,\"1490\":1,\"1502\":5,\"1503\":4,\"1506\":3,\"1510\":1,\"1517\":2,\"1520\":1,\"1521\":1,\"1526\":4,\"1546\":6,\"1548\":5,\"1549\":3,\"1550\":9,\"1553\":5,\"1554\":10,\"1569\":2,\"1570\":4,\"1573\":4,\"1574\":4,\"1575\":2,\"1591\":2,\"1593\":1,\"1598\":29,\"1600\":3,\"1603\":6,\"1604\":2,\"1605\":8,\"1607\":6,\"1610\":1,\"1611\":1,\"1612\":2,\"1613\":12,\"1614\":7,\"1616\":1,\"1617\":1,\"1618\":2,\"1619\":2,\"1620\":22,\"1621\":8,\"1622\":4,\"1623\":4,\"1634\":1,\"1647\":1,\"1654\":1}}],[\"integral\",{\"1\":{\"1623\":1}}],[\"integer>>\",{\"1\":{\"1615\":1}}],[\"integer>\",{\"1\":{\"1598\":9,\"1615\":1,\"1616\":1,\"1618\":1,\"1620\":2}}],[\"integer和double等基础类型的包装类都具备不可变性\",{\"1\":{\"1526\":1}}],[\"integer\",{\"1\":{\"567\":3,\"569\":9,\"570\":10,\"571\":10,\"572\":7,\"573\":11,\"574\":16,\"577\":5,\"578\":8,\"580\":1,\"581\":3,\"598\":3,\"645\":8,\"909\":6,\"1003\":3,\"1005\":3,\"1053\":4,\"1061\":1,\"1103\":1,\"1139\":4,\"1343\":1,\"1412\":1,\"1501\":1,\"1503\":1,\"1517\":2,\"1550\":3,\"1575\":3,\"1598\":2,\"1599\":20,\"1607\":1,\"1614\":1,\"1618\":1,\"1620\":3}}],[\"integer的缓存机制\",{\"0\":{\"14\":1,\"1343\":1}}],[\"intended\",{\"1\":{\"1594\":2,\"1621\":1}}],[\"intension\",{\"1\":{\"442\":1}}],[\"intel使用缓存锁定来保证指令执行的原子性\",{\"1\":{\"1473\":1}}],[\"intermediate\",{\"1\":{\"1615\":1,\"1618\":3,\"1619\":2,\"1621\":7,\"1622\":3,\"1623\":6}}],[\"interoperability\",{\"1\":{\"1614\":1}}],[\"interfered\",{\"1\":{\"1620\":2}}],[\"interference获取更多信息\",{\"1\":{\"1621\":1}}],[\"interference\",{\"1\":{\"1620\":11,\"1621\":2}}],[\"interfering\",{\"1\":{\"1608\":2,\"1619\":1}}],[\"interfering<\",{\"1\":{\"1608\":2}}],[\"interfacetestb\",{\"1\":{\"1595\":5}}],[\"interfacetesta\",{\"1\":{\"1595\":5}}],[\"interfaces\",{\"1\":{\"1594\":3,\"1597\":2,\"1647\":1}}],[\"interface<\",{\"1\":{\"1594\":2,\"1597\":1,\"1598\":3,\"1599\":2,\"1600\":1,\"1601\":1}}],[\"interface\",{\"1\":{\"908\":1,\"917\":1,\"961\":3,\"967\":2,\"973\":1,\"1043\":1,\"1134\":1,\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":3,\"1164\":1,\"1500\":1,\"1593\":1,\"1594\":33,\"1595\":6,\"1597\":2,\"1598\":2,\"1599\":1,\"1600\":1,\"1601\":2,\"1603\":1,\"1607\":2,\"1608\":1,\"1609\":1,\"1614\":1,\"1619\":4,\"1620\":2,\"1621\":1,\"1623\":2}}],[\"interrupt\",{\"1\":{\"1477\":1}}],[\"interrupted方法会清除中断标志\",{\"1\":{\"1386\":1}}],[\"interrupted与isinterrupted方法不同是\",{\"1\":{\"1386\":1}}],[\"interruptedexception\",{\"1\":{\"989\":1,\"1013\":1,\"1387\":1,\"1404\":12,\"1487\":1,\"1502\":2,\"1503\":2,\"1535\":2}}],[\"interrupted和isinterrupted方法的区别\",{\"0\":{\"57\":1,\"1386\":1}}],[\"interceptoranddynamicmethodmatcher\",{\"1\":{\"1654\":1}}],[\"interceptor\",{\"1\":{\"1654\":4}}],[\"interceptors\",{\"1\":{\"1654\":7}}],[\"interceptors只会有一个元素\",{\"1\":{\"1654\":1}}],[\"interceptorlist\",{\"1\":{\"1654\":6}}],[\"intercept\",{\"1\":{\"922\":1,\"1647\":1,\"1654\":1}}],[\"internalpostprocessors\",{\"1\":{\"1166\":6}}],[\"internalpersistenceannotationprocessor\",{\"1\":{\"945\":1}}],[\"internallistenerfactory\",{\"1\":{\"945\":1}}],[\"internaleventlistenerprocessor\",{\"1\":{\"945\":1}}],[\"internalcommonannotationprocessor\",{\"1\":{\"945\":1}}],[\"internalconfigurationannotationprocessor\",{\"1\":{\"945\":1}}],[\"internalautowiredannotationprocessor\",{\"1\":{\"945\":1}}],[\"internal\",{\"1\":{\"922\":1,\"1164\":1,\"1166\":1,\"1647\":1}}],[\"intersect\",{\"1\":{\"519\":2}}],[\"interval\",{\"1\":{\"393\":2}}],[\"in\",{\"0\":{\"274\":1},\"1\":{\"320\":1,\"329\":1,\"330\":6,\"345\":1,\"361\":1,\"371\":2,\"375\":8,\"394\":1,\"428\":3,\"431\":4,\"454\":1,\"504\":1,\"519\":1,\"520\":1,\"525\":1,\"537\":1,\"541\":1,\"544\":1,\"547\":2,\"549\":2,\"553\":5,\"554\":2,\"603\":2,\"645\":1,\"917\":2,\"918\":1,\"922\":5,\"930\":4,\"953\":2,\"954\":2,\"963\":2,\"973\":1,\"975\":1,\"994\":1,\"996\":1,\"997\":5,\"1003\":1,\"1005\":1,\"1012\":1,\"1022\":1,\"1030\":2,\"1040\":1,\"1041\":1,\"1043\":1,\"1053\":2,\"1061\":1,\"1065\":1,\"1084\":2,\"1091\":2,\"1134\":1,\"1138\":1,\"1146\":1,\"1162\":1,\"1164\":1,\"1165\":1,\"1171\":1,\"1172\":1,\"1174\":2,\"1175\":2,\"1184\":1,\"1263\":1,\"1432\":1,\"1550\":1,\"1553\":1,\"1554\":1,\"1573\":1,\"1574\":3,\"1575\":3,\"1595\":2,\"1597\":2,\"1608\":4,\"1609\":1,\"1610\":1,\"1613\":1,\"1615\":8,\"1617\":2,\"1618\":2,\"1619\":12,\"1620\":33,\"1621\":7,\"1622\":6,\"1623\":15,\"1647\":13,\"1648\":2,\"1651\":1,\"1655\":3,\"1663\":1}}],[\"idiom\",{\"1\":{\"1620\":1}}],[\"ideal\",{\"1\":{\"1620\":2}}],[\"ideally\",{\"1\":{\"1620\":1}}],[\"identitytostring\",{\"1\":{\"1648\":1}}],[\"identity本身的意思也就是同一性\",{\"1\":{\"1598\":1}}],[\"identity\",{\"1\":{\"928\":1,\"1598\":2,\"1609\":1,\"1615\":5,\"1617\":7,\"1618\":8}}],[\"identifiers\",{\"1\":{\"928\":1}}],[\"identifier\",{\"1\":{\"468\":1}}],[\"id改成当前线程id\",{\"1\":{\"1485\":1}}],[\"id为0\",{\"1\":{\"1485\":1}}],[\"id为1且comments大于1的情况下\",{\"1\":{\"361\":1}}],[\"id作为聚簇索引\",{\"1\":{\"1266\":1}}],[\"idb\",{\"1\":{\"1260\":1}}],[\"id保存到浏览器的cookie\",{\"1\":{\"1201\":1}}],[\"id和类型进行依赖查找\",{\"1\":{\"994\":1}}],[\"id这四个列组合起来不重复的值有多少\",{\"1\":{\"558\":1}}],[\"id这两个字段\",{\"1\":{\"355\":1}}],[\"id修改成删除操作的trx\",{\"1\":{\"542\":1}}],[\"id不在视图数组中\",{\"1\":{\"542\":1}}],[\"id不同\",{\"1\":{\"330\":1}}],[\"id在视图数组中\",{\"1\":{\"542\":1}}],[\"id落在黄色部分\",{\"1\":{\"542\":1}}],[\"id落在红色部分\",{\"1\":{\"542\":1}}],[\"id落在绿色部分\",{\"1\":{\"542\":1}}],[\"id记录trx\",{\"1\":{\"542\":1}}],[\"id所在的旧记录就是当前事务能看见的最新老版本\",{\"1\":{\"542\":1}}],[\"id再比较\",{\"1\":{\"542\":1}}],[\"id跟read\",{\"1\":{\"542\":1}}],[\"id跟row\",{\"1\":{\"497\":1}}],[\"id产生一个聚簇索引\",{\"1\":{\"542\":1}}],[\"id可以从innodb\",{\"1\":{\"538\":1}}],[\"id列\",{\"0\":{\"508\":1}}],[\"id递增值mysql每次重启都会被保存起来\",{\"1\":{\"499\":1}}],[\"id也不会清0\",{\"1\":{\"497\":1}}],[\"id也是a的server\",{\"1\":{\"455\":1}}],[\"id设置成了248\",{\"1\":{\"497\":1}}],[\"id先修成248\",{\"1\":{\"497\":1}}],[\"id达到248\",{\"1\":{\"497\":1}}],[\"id达到上限后\",{\"1\":{\"496\":1,\"499\":1}}],[\"id会持久化存储\",{\"1\":{\"497\":1}}],[\"id有什么好处呢\",{\"1\":{\"497\":1}}],[\"id值比较大\",{\"1\":{\"497\":1}}],[\"id值越大优先级越高\",{\"1\":{\"330\":1}}],[\"id就是当前自己的事务则是可见的\",{\"1\":{\"542\":1}}],[\"id就是当前自己的事务是可见的\",{\"1\":{\"542\":1}}],[\"id就是0\",{\"1\":{\"497\":1}}],[\"id就是不同的\",{\"1\":{\"497\":1}}],[\"id就是线程id\",{\"1\":{\"497\":1}}],[\"id就会是一样的\",{\"1\":{\"497\":1}}],[\"id做对比\",{\"1\":{\"497\":1}}],[\"id做主键\",{\"1\":{\"478\":1}}],[\"id加1\",{\"1\":{\"497\":1}}],[\"id时\",{\"1\":{\"497\":1}}],[\"id全局变量\",{\"1\":{\"497\":1}}],[\"id回到a\",{\"1\":{\"496\":1}}],[\"id定义的长度是8个字节\",{\"1\":{\"496\":1}}],[\"id赋值给这个事务的xid\",{\"1\":{\"496\":1}}],[\"id写入表中的值范围\",{\"1\":{\"495\":1}}],[\"id能写到数据表中的值\",{\"1\":{\"495\":1}}],[\"id留的只是6个字节的长度\",{\"1\":{\"495\":1}}],[\"id都是连续的\",{\"1\":{\"492\":1}}],[\"id分配给这个事务\",{\"1\":{\"468\":1}}],[\"id只有在事务提交的时候才会分配\",{\"1\":{\"468\":1}}],[\"id与我们通常讲的事务id有所区别\",{\"1\":{\"468\":1}}],[\"id与自己的相同\",{\"1\":{\"455\":1}}],[\"id直接写到binlog里面\",{\"1\":{\"464\":1}}],[\"id+1\",{\"1\":{\"464\":1}}],[\"id必须不同\",{\"1\":{\"455\":1,\"478\":1}}],[\"id的时候\",{\"1\":{\"498\":1}}],[\"id的逻辑是\",{\"1\":{\"498\":1}}],[\"id的逻辑类似\",{\"1\":{\"497\":1}}],[\"id的增加速度变慢了\",{\"1\":{\"497\":1}}],[\"id的锁冲突\",{\"1\":{\"497\":1}}],[\"id的申请次数\",{\"1\":{\"497\":1}}],[\"id的当前值\",{\"1\":{\"497\":1}}],[\"id的事务分到多个worker执行\",{\"1\":{\"464\":1}}],[\"id的值就是1289\",{\"1\":{\"497\":1}}],[\"id的值就变成随机的\",{\"1\":{\"404\":1}}],[\"id的值其实就是0\",{\"1\":{\"497\":1}}],[\"id的值加1\",{\"1\":{\"495\":1}}],[\"id的值作为要插入数据的row\",{\"1\":{\"495\":1}}],[\"id的值\",{\"1\":{\"404\":1,\"495\":1}}],[\"id的序号会递增\",{\"1\":{\"330\":1}}],[\"idata\",{\"1\":{\"400\":3,\"404\":3,\"414\":2,\"419\":2}}],[\"id上使用了ref访问类型来执行查询\",{\"1\":{\"390\":1}}],[\"id`\",{\"1\":{\"361\":12,\"363\":1,\"506\":7}}],[\"id2\",{\"1\":{\"345\":1}}],[\"id1\",{\"1\":{\"345\":1}}],[\"id5这两条记录回表取数据判断\",{\"1\":{\"340\":1}}],[\"idx\",{\"1\":{\"330\":4,\"361\":3,\"362\":2,\"363\":2,\"378\":1,\"390\":3,\"519\":2,\"547\":1,\"549\":3,\"551\":1,\"553\":4,\"555\":6,\"558\":3}}],[\"id主键索引\",{\"1\":{\"330\":1}}],[\"id相对于purge线程的read\",{\"1\":{\"542\":1}}],[\"id相等的时候顺序执行\",{\"1\":{\"330\":1}}],[\"id相同的情况\",{\"1\":{\"497\":1}}],[\"id相同的新的binlog\",{\"1\":{\"455\":1}}],[\"id相同不同\",{\"1\":{\"330\":1}}],[\"id相同\",{\"1\":{\"330\":1}}],[\"id是当前操作该记录的事务id\",{\"1\":{\"542\":1}}],[\"id是数据库默认为改行记录生成唯一隐式主键\",{\"1\":{\"542\":1}}],[\"id是使用中最常见的\",{\"1\":{\"499\":1}}],[\"id是1289\",{\"1\":{\"497\":1}}],[\"id是两个容易混淆的概念\",{\"1\":{\"497\":1}}],[\"id是从0开始到248\",{\"1\":{\"495\":1}}],[\"id是一个很大的数\",{\"1\":{\"497\":1}}],[\"id是一个纯内存变量\",{\"1\":{\"496\":1}}],[\"id是一个长度为8字节的无符号长整型\",{\"1\":{\"495\":1}}],[\"id是一个整数\",{\"1\":{\"468\":1}}],[\"id是一个实例第一次启动时自动生成的\",{\"1\":{\"468\":1}}],[\"id是bigint类型\",{\"1\":{\"330\":1}}],[\"id是逐渐\",{\"1\":{\"326\":1}}],[\"id是否可以重复\",{\"0\":{\"193\":1,\"1209\":1}}],[\"id字段没有索引\",{\"1\":{\"322\":1}}],[\"id=\",{\"1\":{\"917\":4,\"918\":1,\"930\":5,\"972\":1,\"973\":1,\"985\":1,\"1003\":1,\"1012\":1,\"1030\":1,\"1032\":1,\"1084\":1,\"1091\":3,\"1146\":1,\"1184\":1}}],[\"id=bbeb46c842c84cfcdbf1d1f040fe40c7\",{\"1\":{\"639\":1}}],[\"id=b36b975188fadf7bfbfd75c0d2d6b834\",{\"1\":{\"540\":1}}],[\"id=ca746f44f16b862e3189e5f24b3a8e64\",{\"1\":{\"635\":1}}],[\"id=df15aba3aa76c225090d04d0dc776dd9\",{\"1\":{\"517\":1}}],[\"id=d2e8a0ae8c9dc2a45c799b771a5899f6\",{\"1\":{\"517\":1}}],[\"id=n的行\",{\"1\":{\"495\":1}}],[\"id=n后\",{\"1\":{\"495\":1}}],[\"id=35faf7c95e69943cdbff4642fcfd5318\",{\"1\":{\"1663\":1}}],[\"id=354ae85f3519bac0581919a458278a59\",{\"1\":{\"531\":1}}],[\"id=3\",{\"1\":{\"468\":1}}],[\"id=0这一行的问题解决了\",{\"1\":{\"447\":1}}],[\"id=0这一行的最终结果也是\",{\"1\":{\"447\":1}}],[\"id=0这一行变成\",{\"1\":{\"447\":1}}],[\"id=0和id=1这两行\",{\"1\":{\"447\":1}}],[\"id=0\",{\"1\":{\"447\":4}}],[\"id=5这一行变成\",{\"1\":{\"447\":1}}],[\"id=248时\",{\"1\":{\"495\":1}}],[\"id=2\",{\"1\":{\"323\":1,\"368\":1}}],[\"id=11111\",{\"1\":{\"1146\":1}}],[\"id=12这个线程的command列显示的是killed\",{\"1\":{\"481\":1}}],[\"id=1的这个库上执行的\",{\"1\":{\"454\":1}}],[\"id=1这一行还不存在\",{\"1\":{\"447\":1}}],[\"id=1这一行\",{\"1\":{\"447\":1}}],[\"id=1\",{\"1\":{\"447\":2}}],[\"id=1和id=5的这三行\",{\"1\":{\"446\":1}}],[\"id=10\",{\"1\":{\"317\":1,\"319\":1,\"322\":1}}],[\"id=16ca3fcfcdda46a976cfd978e20df4be\",{\"1\":{\"312\":1}}],[\"id=924a9d435d78784455143b1dda4a874a\",{\"1\":{\"308\":1}}],[\"ids中\",{\"1\":{\"542\":2}}],[\"ids\",{\"1\":{\"307\":1,\"498\":1,\"542\":4}}],[\"id\",{\"0\":{\"495\":1,\"497\":1,\"498\":1,\"1918\":1},\"1\":{\"304\":1,\"306\":4,\"307\":18,\"320\":1,\"321\":1,\"323\":1,\"329\":2,\"330\":11,\"332\":2,\"335\":3,\"336\":1,\"338\":1,\"341\":1,\"342\":1,\"345\":1,\"349\":1,\"351\":2,\"352\":6,\"354\":2,\"361\":13,\"366\":2,\"368\":2,\"371\":2,\"384\":2,\"390\":10,\"394\":6,\"400\":1,\"404\":1,\"407\":1,\"412\":3,\"413\":3,\"414\":3,\"416\":3,\"417\":1,\"418\":1,\"422\":5,\"431\":3,\"447\":1,\"454\":1,\"455\":4,\"462\":1,\"464\":1,\"467\":1,\"468\":9,\"476\":2,\"478\":2,\"481\":1,\"484\":1,\"490\":2,\"494\":1,\"495\":3,\"496\":2,\"497\":9,\"498\":7,\"499\":1,\"509\":5,\"514\":1,\"519\":1,\"522\":4,\"525\":4,\"526\":1,\"535\":1,\"536\":2,\"538\":1,\"542\":22,\"549\":1,\"553\":2,\"555\":3,\"917\":7,\"927\":1,\"928\":5,\"929\":1,\"978\":4,\"985\":6,\"989\":1,\"994\":1,\"1022\":1,\"1030\":1,\"1031\":3,\"1032\":4,\"1064\":2,\"1065\":1,\"1072\":3,\"1084\":2,\"1091\":3,\"1116\":1,\"1146\":2,\"1163\":1,\"1184\":6,\"1200\":2,\"1209\":1,\"1484\":1,\"1498\":2,\"1608\":1,\"1609\":1,\"1618\":7}}],[\"idle\",{\"1\":{\"1689\":1}}],[\"idl\",{\"1\":{\"273\":1}}],[\"不作为学习的重点\",{\"1\":{\"1976\":1}}],[\"不断的过遍数\",{\"1\":{\"1972\":1}}],[\"不断地重复执行相同的查询\",{\"1\":{\"386\":1}}],[\"不行再由儿子自己加载\",{\"1\":{\"1663\":1}}],[\"不得不提前缓存aop的对象\",{\"1\":{\"1649\":1}}],[\"不相关的标签数据是存放在基数的位置上的\",{\"1\":{\"1620\":1}}],[\"不为空的\",{\"1\":{\"1620\":1}}],[\"不为null的总个数\",{\"1\":{\"399\":1}}],[\"不冲突的\",{\"1\":{\"1608\":1}}],[\"不包含最大值的intstream对象\",{\"1\":{\"1607\":1}}],[\"不妨查看一下stream这个类中的of\",{\"1\":{\"1607\":1}}],[\"不妨来读一下这段文档\",{\"1\":{\"1595\":1}}],[\"不共享的\",{\"1\":{\"1579\":1}}],[\"不存储元素的阻塞队列\",{\"1\":{\"1501\":1}}],[\"不存在则直接添加到该map中\",{\"1\":{\"1613\":1}}],[\"不存在代码级别的强依赖\",{\"1\":{\"1306\":1}}],[\"不存在的会注册一个默认的\",{\"1\":{\"967\":1}}],[\"不存在线程不安全的情况\",{\"1\":{\"583\":1}}],[\"不存在时\",{\"1\":{\"569\":1,\"573\":1}}],[\"不存在\",{\"1\":{\"569\":1,\"573\":1}}],[\"不存在也就加不上锁\",{\"1\":{\"447\":1}}],[\"不支持\",{\"1\":{\"1501\":2}}],[\"不支持范围查询\",{\"1\":{\"504\":1}}],[\"不到最后万不得已\",{\"1\":{\"1480\":1}}],[\"不稳定参数\",{\"1\":{\"1453\":1}}],[\"不区分\",{\"1\":{\"1441\":1}}],[\"不堆积碎片\",{\"1\":{\"1439\":2}}],[\"不使用arraylist的原因是\",{\"1\":{\"1358\":1}}],[\"不使用事务\",{\"1\":{\"1262\":1}}],[\"不利于微服务的拆分\",{\"1\":{\"1309\":1}}],[\"不依赖其他服务\",{\"1\":{\"1304\":1}}],[\"不空过滤器只能加数据不能删数据\",{\"1\":{\"1282\":1}}],[\"不做其作用域为sessionfactory\",{\"1\":{\"1218\":1}}],[\"不做日志的完整性判断\",{\"1\":{\"468\":1}}],[\"不具备动态更新地能力\",{\"1\":{\"1156\":1}}],[\"不阻塞\",{\"1\":{\"1501\":2}}],[\"不阻塞主线程\",{\"1\":{\"1129\":1}}],[\"不阻塞客户端命令\",{\"1\":{\"589\":1}}],[\"不变性设计\",{\"1\":{\"1107\":1}}],[\"不内置转化器和formatter实现\",{\"1\":{\"1092\":1}}],[\"不内置转化器实现\",{\"1\":{\"1092\":1}}],[\"不影响bean\",{\"1\":{\"1019\":1}}],[\"不影响更新的响应时间\",{\"1\":{\"345\":1}}],[\"不在进行实例化的操作\",{\"1\":{\"1000\":1}}],[\"不在索引列上做任何操作\",{\"1\":{\"369\":1}}],[\"不一定都是抽象方法\",{\"1\":{\"1594\":1}}],[\"不一定是pojo\",{\"1\":{\"976\":1}}],[\"不一致\",{\"1\":{\"327\":1}}],[\"不主动依赖容器api\",{\"1\":{\"911\":1}}],[\"不好设置缓存\",{\"1\":{\"645\":1}}],[\"不执行覆盖\",{\"1\":{\"1520\":1}}],[\"不执行\",{\"1\":{\"592\":1}}],[\"不但效率高并且易用\",{\"1\":{\"584\":1}}],[\"不但速度慢\",{\"1\":{\"492\":1}}],[\"不必修改\",{\"1\":{\"583\":1}}],[\"不必从数据表中读取\",{\"1\":{\"330\":2}}],[\"不管增加\",{\"1\":{\"1548\":1}}],[\"不管是\",{\"1\":{\"1479\":1}}],[\"不管是否成功\",{\"1\":{\"581\":1}}],[\"不管运行时环境如何排列\",{\"1\":{\"1391\":1}}],[\"不管中途是否成功\",{\"1\":{\"1262\":1}}],[\"不管读取记录时需不需要检测是否满足搜索条件\",{\"1\":{\"545\":1}}],[\"不设置默认\",{\"1\":{\"578\":1}}],[\"不精确\",{\"1\":{\"553\":1}}],[\"不加锁的非阻塞读\",{\"1\":{\"541\":1}}],[\"不加任何索引\",{\"1\":{\"363\":1}}],[\"不符合可见性\",{\"1\":{\"542\":1}}],[\"不符合隔离性\",{\"1\":{\"532\":2}}],[\"不符合一致性要求\",{\"1\":{\"532\":1}}],[\"不超过\",{\"1\":{\"530\":1}}],[\"不知道要预先申请多少个id\",{\"1\":{\"492\":1}}],[\"不再使用select\",{\"1\":{\"1570\":1}}],[\"不再需要像jdk1\",{\"1\":{\"1550\":1}}],[\"不再需要回表查整行记录\",{\"1\":{\"338\":1}}],[\"不再有生命周期等特性\",{\"1\":{\"1182\":1}}],[\"不再依赖于自增主键去生成\",{\"1\":{\"492\":1}}],[\"不算在并发线程里面\",{\"1\":{\"476\":1}}],[\"不限制并发线程数肯定是不行的\",{\"1\":{\"476\":1}}],[\"不要不行吗\",{\"0\":{\"1659\":1}}],[\"不要冒然在生产环境中使用\",{\"1\":{\"1510\":1}}],[\"不要采用异步方式\",{\"1\":{\"1328\":1}}],[\"不要用root用户\",{\"1\":{\"1257\":1}}],[\"不要用int\",{\"1\":{\"528\":1}}],[\"不要轻易调整simpleapplicationeventmulticaster中关联的taskexecutor对象\",{\"1\":{\"1129\":1}}],[\"不要在小基数字段上建立索引\",{\"1\":{\"521\":1}}],[\"不要直接在主库上执行这些操作\",{\"1\":{\"484\":1}}],[\"不要求binlog的格式\",{\"1\":{\"463\":1}}],[\"不要太吝惜join\",{\"1\":{\"364\":1}}],[\"不等则会把当前dest指针指向内存的值写入eax\",{\"1\":{\"1479\":1}}],[\"不等于e\",{\"1\":{\"1479\":1}}],[\"不等主备数据同步\",{\"1\":{\"459\":1}}],[\"不等有时会失效\",{\"0\":{\"374\":1}}],[\"不仅如此\",{\"1\":{\"1591\":1}}],[\"不仅耗费精力且难以维护\",{\"1\":{\"1518\":1}}],[\"不仅会消耗系统资源\",{\"1\":{\"1407\":1}}],[\"不仅会占用更大的空间\",{\"1\":{\"454\":1}}],[\"不仅完整地替换propertyplaceholderconfigurer\",{\"1\":{\"1144\":1}}],[\"不仅将给行加上了行锁\",{\"1\":{\"448\":1}}],[\"不论某个范围区间的二级索引到底占用了多少页面\",{\"1\":{\"549\":1}}],[\"不论采用哪种架构\",{\"1\":{\"469\":1}}],[\"不论这个binlog是1分钟之后被备库执行\",{\"1\":{\"454\":1}}],[\"不论当前的工作线程在哪个库里\",{\"1\":{\"454\":1}}],[\"不论是拿到备库去执行\",{\"1\":{\"447\":1}}],[\"不论是使用内存临时表还是磁盘临时表\",{\"1\":{\"417\":1}}],[\"不论是在原表上加索引\",{\"1\":{\"407\":1}}],[\"不fsync\",{\"1\":{\"450\":1}}],[\"不允许null元素\",{\"1\":{\"1503\":1}}],[\"不允许其他命令进行干扰\",{\"1\":{\"578\":1}}],[\"不允许插入值\",{\"1\":{\"448\":1}}],[\"不允许使用分区表\",{\"1\":{\"423\":1}}],[\"不止是数据库内部数据状态在此刻的一致性\",{\"1\":{\"447\":1}}],[\"不止是索引的全部定义\",{\"1\":{\"339\":1}}],[\"不是接口或抽象类\",{\"1\":{\"1647\":1}}],[\"不是内部类或static类\",{\"1\":{\"1647\":1}}],[\"不是针对性的\",{\"1\":{\"624\":1}}],[\"不是\",{\"1\":{\"572\":1}}],[\"不是自增的主键在插入的时候\",{\"1\":{\"505\":1}}],[\"不是一个特别大的数\",{\"1\":{\"494\":1}}],[\"不是真正的随机\",{\"1\":{\"422\":1}}],[\"不是null才累加\",{\"1\":{\"399\":1}}],[\"不是通过表内检索出的\",{\"1\":{\"330\":1}}],[\"不幸的是\",{\"1\":{\"390\":1}}],[\"不同类加载器实例加载的类是互相隔离的\",{\"1\":{\"1693\":1}}],[\"不同于select使用三个位图来表示三个fdset的方式\",{\"1\":{\"1570\":1}}],[\"不同于idx\",{\"1\":{\"555\":1}}],[\"不同线程执行下面代码\",{\"1\":{\"1528\":1}}],[\"不同namespace下的操作互不影响\",{\"1\":{\"1218\":1}}],[\"不同spring版本environment对于占位符处理有所差异\",{\"1\":{\"1146\":1}}],[\"不同session的临时表是可以重名的\",{\"1\":{\"410\":1}}],[\"不同数据库之间\",{\"1\":{\"567\":1}}],[\"不同事务或者相同事务的对同一记录的修改\",{\"1\":{\"542\":1}}],[\"不同事务的xid也是有可能相同的\",{\"1\":{\"496\":1}}],[\"不同时刻启动的事务会有不同的read\",{\"1\":{\"434\":1}}],[\"不同count的用法\",{\"0\":{\"399\":1}}],[\"不同案例的情况不同\",{\"1\":{\"388\":1}}],[\"不同的\",{\"1\":{\"1620\":1}}],[\"不同的是每个元素都会关联一个double类型的分数\",{\"1\":{\"574\":1}}],[\"不同的表作为驱动表最终的查询成本可能是不同的\",{\"1\":{\"555\":1}}],[\"不同的应用对读一致性和事务隔离程度的要求也是不同的\",{\"1\":{\"532\":1}}],[\"不同的并发只读事务\",{\"1\":{\"497\":1}}],[\"不同的引擎对于自增值的保存策略是不同的\",{\"1\":{\"490\":1}}],[\"不同的worker就独立执行了\",{\"1\":{\"460\":1}}],[\"不同的存储引擎共用一个server层\",{\"1\":{\"317\":1}}],[\"不同的存储引擎的表数据获取方式不同\",{\"1\":{\"317\":1}}],[\"不同的xml映射文件\",{\"0\":{\"193\":1,\"1209\":1}}],[\"不应该按下面的写法编写查询\",{\"1\":{\"384\":1}}],[\"不创建索引的情况下\",{\"1\":{\"362\":1}}],[\"不难想到\",{\"1\":{\"419\":1}}],[\"不难想象\",{\"1\":{\"402\":1}}],[\"不难发现\",{\"1\":{\"356\":1,\"459\":1,\"492\":1,\"1005\":1}}],[\"不难看出\",{\"1\":{\"345\":1,\"1000\":1,\"1591\":1,\"1607\":1}}],[\"不用父子容器也可以完成所需功能\",{\"1\":{\"1659\":1}}],[\"不用进一步做筛选了\",{\"1\":{\"1648\":1}}],[\"不用担心index溢出的问题\",{\"1\":{\"1519\":1}}],[\"不用担心请求和响应对不上\",{\"1\":{\"637\":1}}],[\"不用每次都计算\",{\"1\":{\"1342\":1}}],[\"不用再会到原表去取数据\",{\"1\":{\"356\":1}}],[\"不用扫描全部索引\",{\"1\":{\"330\":1}}],[\"不会执行\",{\"1\":{\"1663\":1}}],[\"不会再往下匹配了\",{\"1\":{\"1657\":1}}],[\"不会再有中间操作和终止操作添加到这个流实例上了\",{\"1\":{\"1621\":1}}],[\"不会再评估其它索引的执行代价了\",{\"1\":{\"348\":1}}],[\"不会被其他线程使用\",{\"1\":{\"1615\":1}}],[\"不会计入这个接口的抽象方法数量\",{\"1\":{\"1594\":1}}],[\"不会发生线程安全问题\",{\"1\":{\"1501\":1}}],[\"不会停止线程\",{\"1\":{\"1477\":1}}],[\"不会切换到内核态\",{\"1\":{\"1477\":1}}],[\"不会产生内存碎片\",{\"1\":{\"1449\":1}}],[\"不会覆盖\",{\"1\":{\"1367\":1}}],[\"不会有多个元素引用相同集合的对象\",{\"1\":{\"1355\":1}}],[\"不会有主备删除不同行的问题\",{\"1\":{\"454\":1}}],[\"不会\",{\"1\":{\"1182\":1}}],[\"不会抛出异常\",{\"1\":{\"1072\":1}}],[\"不会消耗额外的内存\",{\"1\":{\"589\":1}}],[\"不会消耗额外的存储空间\",{\"1\":{\"352\":1}}],[\"不会加锁\",{\"1\":{\"535\":1}}],[\"不会出现新的主机\",{\"1\":{\"611\":1}}],[\"不会出现死锁\",{\"1\":{\"534\":1}}],[\"不会出现需要构造100万个项这种情况\",{\"1\":{\"463\":1}}],[\"不会把执行命令记录到本地的命令历史文件\",{\"1\":{\"482\":1}}],[\"不需要硬件支持\",{\"1\":{\"1584\":1}}],[\"不需要连接\",{\"1\":{\"1419\":1}}],[\"不需要新建一个对象\",{\"1\":{\"1343\":1}}],[\"不需要保证全局有序\",{\"1\":{\"1330\":1}}],[\"不需要保证线程安全\",{\"1\":{\"1236\":1}}],[\"不需要用户干预\",{\"1\":{\"1263\":1}}],[\"不需要合并beandefinition\",{\"1\":{\"997\":1,\"1000\":1,\"1001\":1,\"1005\":1,\"1006\":1,\"1011\":1}}],[\"不需要拼接参数的\",{\"1\":{\"645\":1}}],[\"不需要人工来介入\",{\"1\":{\"621\":1}}],[\"不需要去获取写事件\",{\"1\":{\"605\":1}}],[\"不需要传信号量参数\",{\"1\":{\"481\":1}}],[\"不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker\",{\"1\":{\"465\":1}}],[\"不需要解析binlog里面的内容\",{\"1\":{\"465\":1}}],[\"不需要临时表\",{\"1\":{\"417\":1}}],[\"不需要担心数据删除问题\",{\"1\":{\"410\":1}}],[\"不需要在服务端再耗费内存存储结果\",{\"1\":{\"355\":1}}],[\"不需要回到id索引再查一次\",{\"1\":{\"351\":1}}],[\"不需要回表\",{\"1\":{\"338\":1,\"416\":1}}],[\"不需要再做排序\",{\"1\":{\"348\":1}}],[\"不需要预先定义格式\",{\"1\":{\"304\":1}}],[\"不满足条件\",{\"1\":{\"337\":1}}],[\"不可以\",{\"1\":{\"1660\":1}}],[\"不可以使用索引\",{\"1\":{\"547\":1}}],[\"不可靠的\",{\"1\":{\"1419\":1}}],[\"不可变的分割迭代器\",{\"1\":{\"1620\":1}}],[\"不可变的\",{\"1\":{\"1620\":2}}],[\"不可变的对象一定是线程安全的\",{\"1\":{\"1391\":1}}],[\"不可变的对象意味着天生就是线程安全的\",{\"1\":{\"1342\":1}}],[\"不可变对象可以保证该对象在创建后它的哈希值不会被改变\",{\"1\":{\"1544\":1}}],[\"不可变对象也需要正确发布\",{\"1\":{\"1526\":1}}],[\"不可变\",{\"1\":{\"1391\":1}}],[\"不可变字符序列\",{\"1\":{\"1341\":1}}],[\"不可回滚\",{\"1\":{\"1271\":1}}],[\"不可重复度\",{\"1\":{\"1262\":1}}],[\"不可重复读等事务隔离问题\",{\"1\":{\"541\":1}}],[\"不可重复读\",{\"0\":{\"152\":1,\"1261\":1},\"1\":{\"433\":1,\"532\":3,\"1261\":3}}],[\"不可见\",{\"1\":{\"542\":1}}],[\"不可能从该方法中逃逸出去\",{\"1\":{\"1487\":1}}],[\"不可能\",{\"1\":{\"532\":6}}],[\"不可能字段同时查到两个名字\",{\"1\":{\"330\":1}}],[\"不能同时返回sized和concurrent\",{\"1\":{\"1620\":1}}],[\"不能更改\",{\"1\":{\"1538\":1}}],[\"不能与jvm交互\",{\"1\":{\"1440\":1}}],[\"不能保证原子性\",{\"1\":{\"1387\":1}}],[\"不能保存数据\",{\"1\":{\"1236\":1}}],[\"不能保存到其他类型key噢\",{\"1\":{\"572\":1}}],[\"不能\",{\"1\":{\"1387\":1}}],[\"不能是private\",{\"1\":{\"1345\":1}}],[\"不能有其他变量\",{\"1\":{\"1345\":1}}],[\"不能有外键\",{\"1\":{\"462\":1}}],[\"不能多次创建订单\",{\"1\":{\"1248\":1}}],[\"不能颠倒\",{\"1\":{\"1116\":1}}],[\"不能用抽象类或接口\",{\"1\":{\"927\":1}}],[\"不能用来获取任何元组\",{\"1\":{\"330\":1}}],[\"不能写user\",{\"1\":{\"994\":1}}],[\"不能写\",{\"1\":{\"611\":1}}],[\"不能按位\",{\"1\":{\"578\":1}}],[\"不能像集合那样\",{\"1\":{\"577\":1}}],[\"不能无限等待\",{\"1\":{\"473\":1}}],[\"不能称为幻读\",{\"1\":{\"446\":1}}],[\"不能直接返回了\",{\"1\":{\"355\":1}}],[\"不能以下划线开头\",{\"1\":{\"305\":1}}],[\"不过就是太厚了\",{\"1\":{\"1974\":1}}],[\"不过并不会修改底层的数据源\",{\"1\":{\"1608\":1}}],[\"不过objectfactory仅关注一个或一种类型的bean依赖查找\",{\"1\":{\"948\":1}}],[\"不过官方建议采用驼峰的方式\",{\"1\":{\"928\":1}}],[\"不过从redis6\",{\"1\":{\"601\":1}}],[\"不过自动重新计算统计数据的过程是异步发生的\",{\"1\":{\"559\":1}}],[\"不过对于myisam存储引擎来说\",{\"1\":{\"557\":1}}],[\"不过因为本查询可以使用idx\",{\"1\":{\"554\":1}}],[\"不过需要注意的是\",{\"1\":{\"553\":1}}],[\"不过需要格外说明的是\",{\"1\":{\"403\":1}}],[\"不过还有一个问题\",{\"1\":{\"549\":1}}],[\"不过依然存在一些问题\",{\"1\":{\"478\":1}}],[\"不过这个概率很低\",{\"1\":{\"497\":1}}],[\"不过这个实现有以下优势\",{\"1\":{\"465\":1}}],[\"不过这种方案\",{\"1\":{\"469\":1}}],[\"不过这样需要每次执行依次\",{\"1\":{\"435\":1}}],[\"不过即使这样\",{\"1\":{\"485\":1}}],[\"不过即使如此\",{\"1\":{\"464\":1}}],[\"不过即使是使用业务分表的方式\",{\"1\":{\"425\":1}}],[\"不过现在它并不再直接更新数据\",{\"1\":{\"460\":1}}],[\"不过后来由于多线程复制方案的引入\",{\"1\":{\"453\":1}}],[\"不过将innodb\",{\"1\":{\"451\":1}}],[\"不过通常情况下第3步执行得会很快\",{\"1\":{\"451\":1}}],[\"不过如果要备份全库\",{\"1\":{\"438\":1}}],[\"不过于order\",{\"1\":{\"422\":1}}],[\"不过有时候这个值也可能非常大\",{\"1\":{\"389\":1}}],[\"不过很难做到\",{\"1\":{\"388\":1}}],[\"不过索引还是有维护代价的\",{\"1\":{\"356\":1}}],[\"不过在mysql\",{\"1\":{\"557\":1}}],[\"不过在驱动表s1选取idx\",{\"1\":{\"554\":1}}],[\"不过在这个例子中\",{\"1\":{\"348\":1}}],[\"不过在某些场景下\",{\"1\":{\"346\":1}}],[\"不过在典型的kv场景\",{\"1\":{\"335\":1}}],[\"不过在有些场景下\",{\"1\":{\"322\":1}}],[\"不过为了维持o\",{\"1\":{\"334\":1}}],[\"不过你可能会问\",{\"1\":{\"327\":1}}],[\"不过\",{\"1\":{\"317\":1,\"342\":1,\"385\":1,\"396\":1,\"408\":1,\"411\":2,\"454\":1,\"457\":1,\"460\":1,\"461\":1,\"462\":1,\"463\":1,\"464\":1,\"465\":1,\"467\":1,\"469\":1,\"472\":1,\"496\":1,\"497\":1,\"624\":1,\"1326\":1,\"1546\":1,\"1620\":1}}],[\"如需要再次扩容\",{\"1\":{\"1542\":1}}],[\"如生产者每天1万条\",{\"1\":{\"1536\":1}}],[\"如linkedblockingqueue\",{\"1\":{\"1509\":1}}],[\"如arrayblockingqueue\",{\"1\":{\"1509\":1}}],[\"如优先级队列\",{\"1\":{\"1509\":1}}],[\"如账户和金额等信息放到队列中就可以\",{\"1\":{\"1501\":1}}],[\"如立即返回是否成功的trylock\",{\"1\":{\"1495\":1}}],[\"如synchronousqueue\",{\"1\":{\"1509\":1}}],[\"如semaphore\",{\"1\":{\"1490\":1}}],[\"如spring\",{\"1\":{\"961\":1,\"1116\":1}}],[\"如reentrantlock\",{\"1\":{\"1490\":1}}],[\"如rdb\",{\"1\":{\"588\":1}}],[\"如哈希码\",{\"1\":{\"1484\":1}}],[\"如锁粗化\",{\"1\":{\"1483\":1}}],[\"如基本数据类型对应的class对象\",{\"1\":{\"1438\":1}}],[\"如公平锁\",{\"1\":{\"1394\":1}}],[\"如图所示\",{\"1\":{\"1501\":1}}],[\"如图\",{\"1\":{\"1378\":1}}],[\"如图中看到的\",{\"1\":{\"434\":1}}],[\"如电源故障导致的宕机\",{\"1\":{\"1297\":1}}],[\"如此来保证数据的唯一性\",{\"1\":{\"1248\":1}}],[\"如此循环\",{\"1\":{\"444\":1}}],[\"如bind\",{\"1\":{\"1224\":1}}],[\"如parameterizedtype\",{\"1\":{\"1107\":1}}],[\"如properties\",{\"1\":{\"1035\":1}}],[\"如contextrefreshedevent\",{\"1\":{\"1129\":1}}],[\"如collection<e>\",{\"1\":{\"1099\":1}}],[\"如cpu\",{\"1\":{\"533\":1}}],[\"如java\",{\"1\":{\"1099\":1,\"1123\":1}}],[\"如jaxb\",{\"1\":{\"1036\":1}}],[\"如jdbc\",{\"1\":{\"891\":1}}],[\"如xml\",{\"1\":{\"1035\":2}}],[\"如ioc配置元信息读取和解析\",{\"1\":{\"938\":1}}],[\"如id号\",{\"1\":{\"528\":1}}],[\"如作用域\",{\"1\":{\"927\":1}}],[\"如动态代理\",{\"1\":{\"903\":1}}],[\"如依赖查找\",{\"1\":{\"903\":1}}],[\"如资源管理\",{\"1\":{\"903\":1}}],[\"如mybatis整合hibernetes和redis\",{\"1\":{\"891\":1}}],[\"如oop\",{\"1\":{\"891\":1}}],[\"如定时任务等\",{\"1\":{\"603\":1}}],[\"如\",{\"1\":{\"426\":1,\"927\":2,\"945\":1,\"1063\":1,\"1092\":1,\"1968\":1}}],[\"如将主键置于where列表中\",{\"1\":{\"330\":1}}],[\"如下所示\",{\"1\":{\"322\":1,\"1365\":1}}],[\"如下图所示\",{\"1\":{\"308\":1,\"324\":1,\"347\":1,\"411\":1,\"417\":1,\"569\":1,\"618\":1,\"1473\":1,\"1546\":1}}],[\"如下图\",{\"1\":{\"306\":1,\"472\":1}}],[\"如日期\",{\"1\":{\"317\":1}}],[\"如要查询age在25至26岁之间的\",{\"1\":{\"306\":1}}],[\"如要查询age等于28岁的\",{\"1\":{\"306\":1}}],[\"如果跳过了不利于学习原理\",{\"1\":{\"1983\":1}}],[\"如果之前已经学习过其他语言如c\",{\"1\":{\"1969\":1}}],[\"如果之前从库b的gtid集合格式是source\",{\"1\":{\"468\":1}}],[\"如果释放了很多空间\",{\"1\":{\"1664\":1}}],[\"如果释放了大量的空间\",{\"1\":{\"1664\":1}}],[\"如果交由spring管理\",{\"1\":{\"1660\":1}}],[\"如果抛出了异常\",{\"1\":{\"1655\":1}}],[\"如果确定了当前beandefinition的构造方法\",{\"1\":{\"1650\":1}}],[\"如果确认包含全部\",{\"1\":{\"468\":1}}],[\"如果确认优化器会使用bnl算法\",{\"1\":{\"406\":1}}],[\"如果制定了构造方法的入参值\",{\"1\":{\"1650\":1}}],[\"如果传入的是普通名称\",{\"1\":{\"1647\":1}}],[\"如果传入的名称是\",{\"1\":{\"1647\":1}}],[\"如果能在mergedbeandefinitions找得到父beandifinition\",{\"1\":{\"1647\":1}}],[\"如果能够将无序数组替换为哈希表\",{\"1\":{\"408\":1}}],[\"如果能够将更新操作先记录在change\",{\"1\":{\"343\":1}}],[\"如果指定的包路径比较宽泛\",{\"1\":{\"1646\":1}}],[\"如果匹配则表示当前bean对象有匹配的pointcut\",{\"1\":{\"1630\":1}}],[\"如果找到多个\",{\"1\":{\"1630\":1}}],[\"如果遍历是无序的\",{\"1\":{\"1623\":1}}],[\"如果输入一定是不同\",{\"1\":{\"1623\":1}}],[\"如果管道的阶段是源阶段的话\",{\"1\":{\"1622\":1}}],[\"如果库访问了共享的状态\",{\"1\":{\"1622\":1}}],[\"如果库里面的表特别多\",{\"1\":{\"482\":1}}],[\"如果action是intconsumer的一个实例\",{\"1\":{\"1620\":1}}],[\"如果arraylist没有指定初始容量\",{\"1\":{\"1475\":1}}],[\"如果arraylist指定了初始容量\",{\"1\":{\"1475\":1}}],[\"如果返回了不同的特性值的集合\",{\"1\":{\"1620\":1}}],[\"如果返回值是0\",{\"1\":{\"474\":1}}],[\"如果返回值是大于等于0的正整数\",{\"1\":{\"473\":1}}],[\"如果根spliterator没有保存正确的计算结果\",{\"1\":{\"1620\":1}}],[\"如果系统变量org\",{\"1\":{\"1620\":1}}],[\"如果分割的足够小的话\",{\"1\":{\"1620\":1}}],[\"如果分割迭代器中没有任何元素\",{\"1\":{\"1620\":1}}],[\"如果两个或者多个线程操作同一个spliterator\",{\"1\":{\"1620\":1}}],[\"如果两个事务没有操作相同的行\",{\"1\":{\"465\":1}}],[\"如果两个事务更新不同的表\",{\"1\":{\"461\":1}}],[\"如果绑定之后对元进行了修改\",{\"1\":{\"1620\":1}}],[\"如果元不是有序的\",{\"1\":{\"1620\":1}}],[\"如果元在自然序列下是sorted\",{\"1\":{\"1620\":1}}],[\"如果元在绑定了spliterator之后\",{\"1\":{\"1620\":1}}],[\"如果元的元素是无限的\",{\"1\":{\"1620\":1}}],[\"如果元素存在\",{\"1\":{\"1620\":1}}],[\"如果元素为空\",{\"1\":{\"1554\":1}}],[\"如果元是sortedset集合\",{\"1\":{\"1620\":1}}],[\"如果元是set集合\",{\"1\":{\"1620\":1}}],[\"如果元是collection集合\",{\"1\":{\"1620\":1}}],[\"如果任意的关闭处理器抛出了异常\",{\"1\":{\"1619\":1}}],[\"如果任务的平均等待时间长\",{\"1\":{\"1510\":1}}],[\"如果检测到流被重用了\",{\"1\":{\"1619\":1}}],[\"如果提供的流操作并没有所需要的功能\",{\"1\":{\"1619\":1}}],[\"如果它不为空的话\",{\"1\":{\"1618\":1}}],[\"如果它的前一个比较器返回是元素的相等的情况\",{\"1\":{\"1614\":1}}],[\"如果给定一个key与值没有关联起来\",{\"1\":{\"1618\":1}}],[\"如果流中没有元素\",{\"1\":{\"1618\":1}}],[\"如果流中没有元素返回0即可\",{\"1\":{\"1610\":1}}],[\"如果编写错误了\",{\"1\":{\"1617\":1}}],[\"如果包含了identity\",{\"1\":{\"1617\":1}}],[\"如果以向创建一个根据部门对于工资的总和表格化\",{\"1\":{\"1615\":1}}],[\"如果finisher\",{\"1\":{\"1615\":1}}],[\"如果force\",{\"1\":{\"348\":1}}],[\"如果前面的比较器返回的结果不是0\",{\"1\":{\"1614\":1}}],[\"如果前面的predicate的值为false\",{\"1\":{\"1599\":1}}],[\"如果修改成如下\",{\"1\":{\"1610\":1}}],[\"如果修改了字段的数据类型\",{\"1\":{\"309\":1}}],[\"如果代码很多\",{\"1\":{\"1607\":1}}],[\"如果第一个参数大于第二个参数\",{\"1\":{\"1603\":1}}],[\"如果第二个select出现在union之后\",{\"1\":{\"330\":1}}],[\"如果所有父加载器在自己的加载路径下都找不到目标类\",{\"1\":{\"1692\":1}}],[\"如果所有的从库都延迟超过1秒了\",{\"1\":{\"473\":1}}],[\"如果所有的更新后面\",{\"1\":{\"344\":1}}],[\"如果所使用的lambda表达式恰好被实现过的话\",{\"1\":{\"1602\":1}}],[\"如果点击student\",{\"1\":{\"1600\":1}}],[\"如果与predicate相匹配\",{\"1\":{\"1599\":1}}],[\"如果当中任何一个function抛出了异常\",{\"1\":{\"1598\":1}}],[\"如果当前加载器父加载器为空则委托引导类加载器加载该类\",{\"1\":{\"1663\":1}}],[\"如果当前加载器父加载器不为空则委托父加载器加载该类\",{\"1\":{\"1663\":1}}],[\"如果当前的predicate是true的话\",{\"1\":{\"1599\":1}}],[\"如果当前的predicate抛出了异常\",{\"1\":{\"1599\":1}}],[\"如果当前\",{\"1\":{\"1554\":1}}],[\"如果当前线程获取读锁\",{\"1\":{\"1498\":1}}],[\"如果当前线程不获取读锁而是直接释放写锁\",{\"1\":{\"1498\":1}}],[\"如果当前线程自旋成功\",{\"1\":{\"1485\":1}}],[\"如果当前不存在事务\",{\"1\":{\"1238\":2}}],[\"如果当前存在事务\",{\"1\":{\"1238\":6}}],[\"如果当前没有事务\",{\"1\":{\"1238\":2}}],[\"如果当前语句是这个事务执行的第一条语句\",{\"1\":{\"496\":1}}],[\"如果算的话\",{\"1\":{\"1594\":1}}],[\"如果改用函数式风格编程\",{\"1\":{\"1591\":1}}],[\"如果立即返回设为null即可\",{\"1\":{\"1569\":1}}],[\"如果处理的连接数不是很高的话\",{\"1\":{\"1565\":1}}],[\"如果处于等待状态\",{\"1\":{\"481\":1}}],[\"如果处于锁状态的线程技术不减一\",{\"1\":{\"476\":1}}],[\"如果正在扩容\",{\"1\":{\"1554\":1}}],[\"如果链表树超过8\",{\"1\":{\"1554\":1}}],[\"如果哈希值和key都一样\",{\"1\":{\"1557\":1}}],[\"如果哈希冲突\",{\"1\":{\"1554\":1}}],[\"如果哈希桶的数组很小\",{\"1\":{\"1546\":1}}],[\"如果哈希桶的数组很大\",{\"1\":{\"1546\":1}}],[\"如果并未满足第三步\",{\"1\":{\"1554\":1}}],[\"如果并不需要对结果进行排序\",{\"1\":{\"416\":1}}],[\"如果其他线程初始化失败还可以顶替上去\",{\"1\":{\"1554\":1}}],[\"如果小于0表示concurrenthashmap正在执行初始化操作\",{\"1\":{\"1554\":1}}],[\"如果小于某个值\",{\"1\":{\"458\":1}}],[\"如果容器没有初始化\",{\"1\":{\"1554\":1}}],[\"如果守护条件不满足\",{\"1\":{\"1531\":1}}],[\"如果写操作非常少\",{\"1\":{\"1527\":1}}],[\"如果多个线程访问元\",{\"1\":{\"1620\":1}}],[\"如果多个线程同时put时\",{\"1\":{\"1551\":1}}],[\"如果多个线程同时进入了if\",{\"1\":{\"1191\":1}}],[\"如果多个变量同属于一个缓存行\",{\"1\":{\"1519\":1}}],[\"如果获取电商s1报价的耗时很长\",{\"1\":{\"1517\":1}}],[\"如果获取到锁的进程执行失败\",{\"1\":{\"1288\":1}}],[\"如果运行了10个任务\",{\"1\":{\"1516\":1}}],[\"如果运气不够好的话\",{\"1\":{\"478\":1}}],[\"如果运气好\",{\"1\":{\"327\":1}}],[\"如果希望在计算任务完成后执行特定动作\",{\"1\":{\"1516\":1}}],[\"如果希望改变字段类型\",{\"1\":{\"309\":1}}],[\"如果取之前队列长度等于容量\",{\"1\":{\"1503\":1}}],[\"如果取之前队列长度大于1\",{\"1\":{\"1503\":1}}],[\"如果现在不适合执行这个操作\",{\"1\":{\"1531\":1}}],[\"如果现在有一个高频请求\",{\"1\":{\"338\":1}}],[\"如果现队列长度小于容量\",{\"1\":{\"1503\":1}}],[\"如果没传容量\",{\"1\":{\"1503\":1}}],[\"如果没有开启事务\",{\"1\":{\"1653\":1}}],[\"如果没有找到bean\",{\"1\":{\"1648\":1}}],[\"如果没有的话\",{\"1\":{\"1622\":1}}],[\"如果没有设置这个特性\",{\"1\":{\"1617\":1}}],[\"如果没有元素\",{\"1\":{\"1613\":1}}],[\"如果没有默认方法\",{\"1\":{\"1607\":1}}],[\"如果没有被实现类所指定的话\",{\"1\":{\"1595\":1}}],[\"如果没有自定义\",{\"1\":{\"1554\":1}}],[\"如果没有数据\",{\"1\":{\"1501\":2}}],[\"如果没有获取到锁会抛出异常\",{\"1\":{\"1382\":1}}],[\"如果没有指定任何构造函数\",{\"1\":{\"1346\":1}}],[\"如果没有就返回空\",{\"1\":{\"1288\":1}}],[\"如果没有pk\",{\"1\":{\"1266\":1}}],[\"如果没有客户端的cookie\",{\"1\":{\"1200\":1}}],[\"如果没有attribute属性\",{\"1\":{\"1136\":1}}],[\"如果没有老大了\",{\"1\":{\"611\":1}}],[\"如果没有任何事件到来\",{\"1\":{\"603\":1}}],[\"如果没有读够线程就会卡在那里\",{\"1\":{\"602\":1}}],[\"如果没有所有数据都不相等的列\",{\"1\":{\"505\":1}}],[\"如果没有主键\",{\"1\":{\"505\":1}}],[\"如果没有再操作普通表\",{\"1\":{\"412\":1}}],[\"如果没有where条件\",{\"1\":{\"396\":1}}],[\"如果没有合适的索引mysql就不得不使用一种更糟糕的访问类型\",{\"1\":{\"390\":1}}],[\"如果没有同时出现using\",{\"1\":{\"330\":1}}],[\"如果没有\",{\"1\":{\"322\":1,\"1666\":1}}],[\"如果没有命中查询缓存\",{\"1\":{\"320\":1}}],[\"如果没有cookie\",{\"0\":{\"217\":1,\"1200\":1}}],[\"如果生产速度和消费速度基本匹配的情况下\",{\"1\":{\"1502\":1}}],[\"如果队列无元素\",{\"1\":{\"1503\":1}}],[\"如果队列已满\",{\"1\":{\"1501\":3}}],[\"如果队列没满\",{\"1\":{\"1501\":1}}],[\"如果队列满了\",{\"1\":{\"1500\":2,\"1503\":1}}],[\"如果队列为空\",{\"1\":{\"605\":1,\"1502\":1}}],[\"如果读锁已被多个线程获取\",{\"1\":{\"1498\":1}}],[\"如果相等\",{\"1\":{\"1479\":1}}],[\"如果相同\",{\"1\":{\"455\":1,\"1479\":1,\"1549\":1}}],[\"如果内存紧张而对时间效率要求不高\",{\"1\":{\"1546\":1}}],[\"如果内存很多而又对时间效率要求很高\",{\"1\":{\"1546\":1}}],[\"如果内存空间在垃圾收集器后仍然非常警长\",{\"1\":{\"1435\":1}}],[\"如果内存足够\",{\"1\":{\"356\":1}}],[\"如果无限制的创建\",{\"1\":{\"1407\":1}}],[\"如果情况就是这样的话\",{\"1\":{\"1393\":1}}],[\"如果显式的指定了带参的构造方法\",{\"1\":{\"1346\":1}}],[\"如果初始化\",{\"1\":{\"1343\":1}}],[\"如果ｂ系统处理成功\",{\"1\":{\"1326\":1}}],[\"如果引用的对象配置了aop\",{\"1\":{\"1237\":1}}],[\"如果曾注册\",{\"1\":{\"1175\":1}}],[\"如果已存在的话\",{\"1\":{\"1163\":1}}],[\"如果注解中存在同名的就会覆盖掉元标注注解中的属性\",{\"1\":{\"1137\":1}}],[\"如果类型参数是无边界的\",{\"1\":{\"1098\":1}}],[\"如果出现bean重复定义的情况\",{\"1\":{\"1022\":1}}],[\"如果出现相同的row\",{\"1\":{\"499\":1}}],[\"如果上面这些都无法实现\",{\"1\":{\"1620\":1}}],[\"如果上面都不满足\",{\"1\":{\"1554\":1}}],[\"如果上面第二条sql使用nlj\",{\"1\":{\"525\":1}}],[\"如果上述的方法返回的不是一个空对象\",{\"1\":{\"1000\":1}}],[\"如果依赖注入集合类型的对象\",{\"1\":{\"985\":1}}],[\"如果同时触发了rehash操作\",{\"1\":{\"1551\":1}}],[\"如果同时存在的话\",{\"1\":{\"984\":1}}],[\"如果同时出现using\",{\"1\":{\"330\":1}}],[\"如果jvm检测到有一连串的对同一个对象的加锁和解锁的操作\",{\"1\":{\"1486\":1}}],[\"如果jvm检测到有一连串零碎的操作都是对同一对象的加锁\",{\"1\":{\"1486\":1}}],[\"如果jsr\",{\"1\":{\"965\":1}}],[\"如果join\",{\"1\":{\"405\":1}}],[\"如果join语句很慢\",{\"1\":{\"403\":1}}],[\"如果应用在启动的时候发生大量full\",{\"1\":{\"1664\":1}}],[\"如果应用上下文中存在多个bean的定义\",{\"1\":{\"952\":1}}],[\"如果应用程序使用某种缓存机制\",{\"1\":{\"385\":1}}],[\"如果留空的话\",{\"1\":{\"928\":1}}],[\"如果超过\",{\"1\":{\"1549\":1}}],[\"如果超过这个时间\",{\"1\":{\"624\":1}}],[\"如果超过了这个参数规定的大小\",{\"1\":{\"450\":1}}],[\"如果脚本在执行过程中由于收到系统中断信号被终止了\",{\"1\":{\"624\":1}}],[\"如果缓冲区满了\",{\"1\":{\"603\":1}}],[\"如果\",{\"1\":{\"592\":1,\"1554\":2}}],[\"如果允许key重复\",{\"1\":{\"1208\":1}}],[\"如果允许容错\",{\"1\":{\"577\":1}}],[\"如果允许事务a把自增id回退\",{\"1\":{\"491\":1}}],[\"如果移除了所有值\",{\"1\":{\"571\":1}}],[\"如果kernel中的数据还没有准备好\",{\"1\":{\"1564\":1}}],[\"如果key存在就返回0\",{\"1\":{\"1288\":1}}],[\"如果key存在\",{\"1\":{\"571\":1}}],[\"如果key不存在\",{\"1\":{\"571\":1,\"1618\":1}}],[\"如果k=5这个记录刚好是这个数据页的最后一个记录\",{\"1\":{\"342\":1}}],[\"如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\",{\"1\":{\"571\":2}}],[\"如果该位置未存放节点\",{\"1\":{\"1554\":1}}],[\"如果该值为default\",{\"1\":{\"557\":1}}],[\"如果该列的值为null的话\",{\"1\":{\"557\":1}}],[\"如果增大这个值的话会让优化器尽量少的创建基于内存的临时表\",{\"1\":{\"557\":2}}],[\"如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表\",{\"1\":{\"557\":2}}],[\"如果增大这个值的话会提升filesort的成本\",{\"1\":{\"557\":1}}],[\"如果连接表的个数小于该值\",{\"1\":{\"556\":1}}],[\"如果对于下游收集器而言\",{\"1\":{\"1618\":1}}],[\"如果对象的哈希值发生变化\",{\"1\":{\"1544\":1}}],[\"如果对象是一个数组\",{\"1\":{\"1484\":1}}],[\"如果对象一直存活\",{\"1\":{\"1436\":1}}],[\"如果对象不重写equals方法\",{\"1\":{\"1367\":1}}],[\"如果对完整的列建立索引的话\",{\"1\":{\"553\":1}}],[\"如果对非索引字段更新\",{\"1\":{\"537\":1}}],[\"如果大于或等于200个的话\",{\"1\":{\"553\":1}}],[\"如果大部分的语句都会包含f的等值条件\",{\"1\":{\"411\":1}}],[\"如果页b和页c之间的页面实在太多\",{\"1\":{\"549\":1}}],[\"如果区间最左记录和区间最右记录相隔不太远\",{\"1\":{\"549\":1}}],[\"如果descriptor所对应的类型是数组\",{\"1\":{\"1648\":1}}],[\"如果delete语句使用的是索引a\",{\"1\":{\"454\":1}}],[\"如果db\",{\"1\":{\"542\":1}}],[\"如果某个接口只有一个抽象方法\",{\"1\":{\"1594\":1}}],[\"如果某个类使用了被\",{\"1\":{\"1133\":1}}],[\"如果某个记录的deleted\",{\"1\":{\"542\":1}}],[\"如果某个表很少改变\",{\"1\":{\"394\":1}}],[\"如果bean上面有\",{\"1\":{\"1027\":1}}],[\"如果b事务回滚\",{\"1\":{\"532\":1}}],[\"如果bnl算法来join的话\",{\"1\":{\"407\":1}}],[\"如果实现了\",{\"1\":{\"1234\":1}}],[\"如果实在要用可以考虑将blob和text字段单独存一张表\",{\"1\":{\"530\":1}}],[\"如果实例使用了gtid模式\",{\"1\":{\"485\":1}}],[\"如果实例b需要的日志已经不存在\",{\"1\":{\"468\":1}}],[\"如果实例x有从库\",{\"1\":{\"468\":1}}],[\"如果整形数据没有负数\",{\"1\":{\"528\":1}}],[\"如果值需要知道表的总行数的估计值可以用如下sql查询\",{\"1\":{\"526\":1}}],[\"如果放不下表t2的所有数据的话\",{\"1\":{\"525\":1}}],[\"如果放不下表t1的所有数据的话\",{\"1\":{\"403\":1}}],[\"如果被调用的方法在编译期无法被确定下来\",{\"1\":{\"1664\":1}}],[\"如果被流的源调用的话\",{\"1\":{\"1622\":1}}],[\"如果被标识的是主节点\",{\"1\":{\"621\":1}}],[\"如果被驱动表的关联字段没有索引\",{\"1\":{\"524\":1}}],[\"如果被kill\",{\"1\":{\"481\":1}}],[\"如果字段的总长度大于max\",{\"1\":{\"520\":1}}],[\"如果字段的总长度小于max\",{\"1\":{\"520\":1}}],[\"如果字段id被定义为auto\",{\"1\":{\"491\":1}}],[\"如果table\",{\"1\":{\"1549\":1}}],[\"如果tps更高\",{\"1\":{\"497\":1}}],[\"如果t1和t2都是10万行的表\",{\"1\":{\"402\":1}}],[\"如果再使用map类描述的话并不是特别清晰\",{\"1\":{\"1618\":1}}],[\"如果再有插入数据的行为要来申请row\",{\"1\":{\"495\":1}}],[\"如果再长一点\",{\"1\":{\"352\":1}}],[\"如果存在相同的key\",{\"1\":{\"1554\":1}}],[\"如果存在同一时间多个线程访问同一把锁的场合\",{\"1\":{\"1485\":1}}],[\"如果存在bgsave命令直接返回\",{\"1\":{\"588\":1}}],[\"如果存在值\",{\"1\":{\"570\":1}}],[\"如果存在\",{\"1\":{\"491\":1,\"1171\":1,\"1618\":1}}],[\"如果x≥y\",{\"1\":{\"491\":1}}],[\"如果x<y\",{\"1\":{\"491\":1}}],[\"如果插入数据时id字段执行了具体的值\",{\"1\":{\"491\":1}}],[\"如果插入数据时id字段指定为0\",{\"1\":{\"491\":1}}],[\"如果插入新的行id值为700\",{\"1\":{\"335\":1}}],[\"如果发生了哈希冲突的话\",{\"1\":{\"1550\":1}}],[\"如果发生变动的记录数量超过了表的大小10\",{\"1\":{\"559\":1}}],[\"如果发生重启\",{\"1\":{\"490\":1}}],[\"如果发现当前对象是string\",{\"1\":{\"1638\":1}}],[\"如果发现符合终止条件\",{\"1\":{\"1524\":1}}],[\"如果发现线程状态是thd\",{\"1\":{\"481\":1}}],[\"如果发现查询需要扫描大量的数据但只返回少数的行\",{\"1\":{\"390\":1}}],[\"如果原来的线程将spliterator交由另外一个线程处理的话\",{\"1\":{\"1620\":1}}],[\"如果原队列长度为0\",{\"1\":{\"1503\":1}}],[\"如果原实例没有使用gtid模式\",{\"1\":{\"485\":1}}],[\"如果原文档存在\",{\"1\":{\"307\":1}}],[\"如果原文档不存在\",{\"1\":{\"307\":1}}],[\"如果设置了的话\",{\"1\":{\"1664\":1}}],[\"如果设置了这个特性值\",{\"1\":{\"1618\":1}}],[\"如果设置了这个属性\",{\"1\":{\"1617\":1}}],[\"如果设置了concurrent特性\",{\"1\":{\"1617\":3}}],[\"如果设置了identity\",{\"1\":{\"1615\":1}}],[\"如果设置了sql\",{\"1\":{\"484\":1}}],[\"如果设置过多的线程数\",{\"1\":{\"1510\":1}}],[\"如果设置为\",{\"1\":{\"1184\":1}}],[\"如果设置binlog\",{\"1\":{\"459\":1}}],[\"如果忘记在delete或者update语句中写where条件\",{\"1\":{\"484\":1}}],[\"如果误删数据涉及到了多个事务的话\",{\"1\":{\"484\":1}}],[\"如果误操作不是一个\",{\"1\":{\"484\":1}}],[\"如果误执行了update语句的话\",{\"1\":{\"454\":1}}],[\"如果本地处理得慢\",{\"1\":{\"482\":1}}],[\"如果线程中断抛出异常\",{\"1\":{\"1502\":2}}],[\"如果线程直接被kill掉\",{\"1\":{\"481\":1}}],[\"如果线程不安全\",{\"0\":{\"179\":1,\"1236\":1}}],[\"如果打开redo\",{\"1\":{\"479\":1}}],[\"如果打开所有的preformance\",{\"1\":{\"479\":1}}],[\"如果刚开始执行的时候\",{\"1\":{\"473\":1}}],[\"如果刚刚在数据表中插入了一行\",{\"1\":{\"397\":1}}],[\"如果等待超过n秒\",{\"1\":{\"473\":1}}],[\"如果启用了semi\",{\"1\":{\"472\":1}}],[\"如果m>d\",{\"1\":{\"528\":1}}],[\"如果master\",{\"1\":{\"472\":1}}],[\"如果mysql排序内存有条件可以配置的比较大\",{\"1\":{\"520\":1}}],[\"如果mysql排序内存sort\",{\"1\":{\"520\":1}}],[\"如果mysql出现了性能瓶颈\",{\"1\":{\"451\":1}}],[\"如果mysql重启后会失效\",{\"1\":{\"428\":1}}],[\"如果觉得精度不够\",{\"1\":{\"472\":1}}],[\"如果延迟超过1秒\",{\"1\":{\"471\":1}}],[\"如果channel上面有新的连接读写事件的时候就会被轮询出来\",{\"1\":{\"1574\":1}}],[\"如果cell\",{\"1\":{\"1480\":2}}],[\"如果cmpxchgl执行时compare\",{\"1\":{\"1479\":2}}],[\"如果cardinality属性是1的话\",{\"1\":{\"553\":1}}],[\"如果current\",{\"1\":{\"468\":2}}],[\"如果count函数的参数不是null\",{\"1\":{\"399\":1}}],[\"如果gtid\",{\"1\":{\"468\":2}}],[\"如果单个redis实例的性能不足以支撑业务\",{\"1\":{\"1292\":1}}],[\"如果单个事务的行数超过10万行\",{\"1\":{\"462\":1}}],[\"如果单行的长度超过了这个值\",{\"1\":{\"355\":1}}],[\"如果碰到问题\",{\"1\":{\"1620\":1}}],[\"如果碰到热点表\",{\"1\":{\"461\":1}}],[\"如果碰到不适合创建索引的场景\",{\"1\":{\"418\":1}}],[\"如果跟多于一个worker冲突\",{\"1\":{\"461\":1}}],[\"如果跟所有worker都不冲突\",{\"1\":{\"461\":1}}],[\"如果跟自己的相同\",{\"1\":{\"455\":1}}],[\"如果过了很久才发现数据不一致的问题\",{\"1\":{\"459\":1}}],[\"如果将这个枚举值修改为\",{\"1\":{\"1617\":1}}],[\"如果将这个语句中的union改成union\",{\"1\":{\"414\":1}}],[\"如果将可靠性优先策略步骤的4\",{\"1\":{\"459\":1}}],[\"如果节点a同时是节点b的备库\",{\"1\":{\"455\":1}}],[\"如果操作的是多张彪\",{\"1\":{\"454\":1}}],[\"如果in语句里的参数过多\",{\"1\":{\"553\":1}}],[\"如果innodb\",{\"1\":{\"451\":1,\"559\":1}}],[\"如果id重复会导致数据互相覆盖\",{\"1\":{\"1209\":1}}],[\"如果id=2这一行所在的数据页本来就在内存中\",{\"1\":{\"326\":1}}],[\"如果id不存在\",{\"1\":{\"306\":1}}],[\"如果主机断开了连接\",{\"1\":{\"611\":1}}],[\"如果主机发生异常重启\",{\"1\":{\"450\":1}}],[\"如果主库a和备库b都用相同的更新命令\",{\"1\":{\"478\":1}}],[\"如果主库上有个表被误删了\",{\"1\":{\"486\":1}}],[\"如果主库上的表都放在同一个db里面\",{\"1\":{\"463\":1}}],[\"如果主库上执行\",{\"1\":{\"413\":1}}],[\"如果主备库及其的系统时间设置不一致\",{\"1\":{\"457\":1}}],[\"如果还想调用\",{\"1\":{\"1623\":1}}],[\"如果还有时间和精力的小伙伴\",{\"1\":{\"1988\":1}}],[\"如果还有一个或以上的非守护线程则不会退出\",{\"1\":{\"1375\":1}}],[\"如果还有其它年份的数据\",{\"1\":{\"366\":1}}],[\"如果还不等于0\",{\"1\":{\"472\":1}}],[\"如果还要减少记录的值\",{\"1\":{\"444\":1}}],[\"如果事务中需要锁多个行\",{\"1\":{\"443\":1}}],[\"如果客户端与服务器之间出现通讯故障并导致网络断开\",{\"1\":{\"1297\":1}}],[\"如果客户端发生异常\",{\"1\":{\"438\":1}}],[\"如果客户端持续有请求\",{\"1\":{\"318\":1}}],[\"如果备份过程中有更新\",{\"1\":{\"438\":1}}],[\"如果从server层看的话\",{\"1\":{\"425\":1}}],[\"如果按照这个算法\",{\"1\":{\"422\":1}}],[\"如果按照主键的递增顺序查询的话\",{\"1\":{\"404\":1}}],[\"如果只有identity\",{\"1\":{\"1618\":1}}],[\"如果只有读\",{\"1\":{\"1526\":1}}],[\"如果只需要在一颗索引树上就可以获取sql所需要的所有列\",{\"1\":{\"1268\":1}}],[\"如果只跟一个worker冲突\",{\"1\":{\"461\":1}}],[\"如果只随机选择1个word值\",{\"1\":{\"422\":1}}],[\"如果只是为了使用\",{\"1\":{\"1983\":1}}],[\"如果只是从使用的角度而言\",{\"1\":{\"1613\":1}}],[\"如果只是从这两个函数的计算复杂度来看的话\",{\"1\":{\"352\":1}}],[\"如果只是把session\",{\"1\":{\"481\":1}}],[\"如果只是查询一个index\",{\"1\":{\"307\":1}}],[\"如果redis意外宕机了\",{\"1\":{\"590\":1}}],[\"如果row的trx\",{\"1\":{\"542\":5}}],[\"如果r\",{\"1\":{\"421\":1}}],[\"如果r5所在的数据页已经满了\",{\"1\":{\"335\":1}}],[\"如果临时表大小超过了tmp\",{\"1\":{\"421\":1}}],[\"如果临时表中没有主键为x的行\",{\"1\":{\"416\":1}}],[\"如果创建的innodb表没有指定主键\",{\"1\":{\"495\":1}}],[\"如果创建的表没有主键\",{\"1\":{\"420\":1}}],[\"如果创建索引的语句不指定前缀长度\",{\"1\":{\"350\":1}}],[\"如果扫描过程中可以保证出现的数据是有序的\",{\"1\":{\"417\":1}}],[\"如果表定义了pk\",{\"1\":{\"1266\":1}}],[\"如果表中已经存在row\",{\"1\":{\"495\":1}}],[\"如果表中有主键为x的行\",{\"1\":{\"416\":1}}],[\"如果表的数据量比较大\",{\"1\":{\"417\":1}}],[\"如果直接发起主备切换\",{\"1\":{\"459\":1}}],[\"如果直接执行\",{\"1\":{\"413\":1}}],[\"如果直接使用join语句\",{\"1\":{\"401\":1}}],[\"如果关于临时表的操作都不记录\",{\"1\":{\"413\":1}}],[\"如果关联中的某个表发生了变化\",{\"1\":{\"394\":1}}],[\"如果涉及到复杂的操作\",{\"1\":{\"411\":1}}],[\"如果仅需要order\",{\"1\":{\"411\":1}}],[\"如果仅仅看查询效率\",{\"1\":{\"333\":1}}],[\"如果这时候单独恢复这几行数据\",{\"1\":{\"484\":1}}],[\"如果这时候在从库b上执行查询请求\",{\"1\":{\"472\":1}}],[\"如果这时使用select\",{\"1\":{\"476\":1}}],[\"如果这两个集合相同\",{\"1\":{\"472\":1}}],[\"如果这两条更新语句被分到不同的worker的话\",{\"1\":{\"460\":1}}],[\"如果这条语句是一个低频的sql语句\",{\"1\":{\"407\":1}}],[\"如果这个流管道已经知道了拥有短路的阶段\",{\"1\":{\"1623\":1}}],[\"如果这个spliterator的元通过comparator是sorted\",{\"1\":{\"1620\":1}}],[\"如果这个spliterator是sized\",{\"1\":{\"1620\":1}}],[\"如果这个spliterator是可以被分割的\",{\"1\":{\"1620\":1}}],[\"如果这个spliterator是ordered\",{\"1\":{\"1620\":2}}],[\"如果这个spliterator报告了spliterator\",{\"1\":{\"1620\":1}}],[\"如果这个旧值\",{\"1\":{\"1288\":1}}],[\"如果这个时候老大修复了\",{\"1\":{\"611\":1}}],[\"如果这个时候发现主库的系统时间与自己的不一致\",{\"1\":{\"457\":1}}],[\"如果这个临时库上有多个数据库\",{\"1\":{\"485\":1}}],[\"如果这个查询请求本来0\",{\"1\":{\"471\":1}}],[\"如果这个事务回滚了\",{\"1\":{\"468\":1}}],[\"如果这个binlog过了1分钟才传给备库的话\",{\"1\":{\"454\":1}}],[\"如果这个表上的查询语句频繁\",{\"1\":{\"441\":1}}],[\"如果这个表上还有另外一个索引k\",{\"1\":{\"411\":1}}],[\"如果这个表t1的数据量很大\",{\"1\":{\"416\":1}}],[\"如果这个冷表很大\",{\"1\":{\"406\":1}}],[\"如果这个被驱动表是一个大的冷数据表\",{\"1\":{\"406\":1}}],[\"如果这个\",{\"1\":{\"399\":2}}],[\"如果满足t1\",{\"1\":{\"407\":1}}],[\"如果1秒之后这个数据也不再被访问了\",{\"1\":{\"406\":1}}],[\"如果想深入学习\",{\"1\":{\"1983\":1}}],[\"如果想做出更好的交互式效果\",{\"1\":{\"1977\":1}}],[\"如果想要深入学习\",{\"1\":{\"1974\":1}}],[\"如果想要稳定地使用mrr优化的话\",{\"1\":{\"404\":1}}],[\"如果想让spring自动选择构造方法以及构造方法的入参值\",{\"1\":{\"1650\":1}}],[\"如果想将学生的名字使用字符串拼接呢\",{\"1\":{\"1616\":1}}],[\"如果想输入两个参数并返回结果\",{\"1\":{\"1598\":1}}],[\"如果想达到足以媲美\",{\"1\":{\"596\":1}}],[\"如果想提升binlog组提交的效果\",{\"1\":{\"451\":1}}],[\"如果想查询所有在电影academy\",{\"1\":{\"384\":1}}],[\"如果步骤1中\",{\"1\":{\"404\":1}}],[\"如果随着a的值递增顺序查询的话\",{\"1\":{\"404\":1}}],[\"如果每个位置上的元素数量只有一个\",{\"1\":{\"1548\":1}}],[\"如果每次删除数据后\",{\"1\":{\"393\":1}}],[\"如果每一次的更新操作都需要写进磁盘\",{\"1\":{\"324\":1}}],[\"如果把binlog\",{\"1\":{\"454\":1}}],[\"如果把innodb\",{\"1\":{\"451\":1}}],[\"如果把查询看作是一个任务\",{\"1\":{\"381\":1}}],[\"如果把整张表取出来一行行统计\",{\"1\":{\"347\":1}}],[\"如果一旦在自己的代码实现过list\",{\"1\":{\"1607\":1}}],[\"如果一开始就固定一个容量\",{\"1\":{\"1509\":1}}],[\"如果一开始就用红黑树结构\",{\"1\":{\"1360\":1}}],[\"如果一项业务跑的时间足够长\",{\"1\":{\"426\":1}}],[\"如果一个流确实需要关闭\",{\"1\":{\"1619\":1}}],[\"如果一个结果被传递给combiner或者finisher函数了\",{\"1\":{\"1615\":1}}],[\"如果一个函数接收一个函数作为参数\",{\"1\":{\"1598\":1}}],[\"如果一个接口只有一个抽象方法\",{\"1\":{\"1594\":1}}],[\"如果一个接口满足了函数式接口的定义\",{\"1\":{\"1594\":1}}],[\"如果一个接口上有\",{\"1\":{\"1594\":1}}],[\"如果一个接口上使用了\",{\"1\":{\"1594\":1}}],[\"如果一个对象在子程序中被分配\",{\"1\":{\"1488\":1}}],[\"如果一个对象被发现只能从一个线程被访问到\",{\"1\":{\"1488\":1}}],[\"如果一个客户端订阅了频道\",{\"1\":{\"600\":1}}],[\"如果一个语句申请了一个表自增锁\",{\"1\":{\"492\":1}}],[\"如果一个库的备份特别大\",{\"1\":{\"486\":1}}],[\"如果一个线程的状态是kill\",{\"1\":{\"481\":1}}],[\"如果一个表当前数据行里最大的id是10\",{\"1\":{\"490\":1}}],[\"如果一个表上除了有主键索引外\",{\"1\":{\"465\":1}}],[\"如果一个表中有2000条记录\",{\"1\":{\"359\":1}}],[\"如果一个主库上执行10分钟\",{\"1\":{\"457\":1}}],[\"如果一个分区表的分区很多\",{\"1\":{\"425\":1}}],[\"如果一定要使用\",{\"1\":{\"375\":1}}],[\"如果索引是多字段的复合索引\",{\"1\":{\"370\":1}}],[\"如果数据写操作很频繁\",{\"1\":{\"1286\":1}}],[\"如果数据库写完了之后\",{\"1\":{\"1287\":1}}],[\"如果数据库中的键过多可能会造成卡顿\",{\"1\":{\"567\":1}}],[\"如果数据库开启了gtid模式\",{\"1\":{\"474\":1}}],[\"如果数据表没有主键\",{\"1\":{\"542\":1}}],[\"如果数据量比较大\",{\"1\":{\"368\":1}}],[\"如果数据页在内存中就直接更新\",{\"1\":{\"343\":1}}],[\"如果sourcesupplier是空的\",{\"1\":{\"1621\":1}}],[\"如果sourcespliterator是非空的话\",{\"1\":{\"1621\":1}}],[\"如果sort\",{\"1\":{\"354\":1,\"418\":1}}],[\"如果spring整合mybatis之后\",{\"1\":{\"1653\":1}}],[\"如果spring设置了就用已经设置的隔离级别\",{\"1\":{\"532\":1}}],[\"如果spliterator是sized就会返回estimatesize的值\",{\"1\":{\"1620\":1}}],[\"如果spliterator是subsized\",{\"1\":{\"1620\":1}}],[\"如果spliterator是ordered\",{\"1\":{\"1620\":1}}],[\"如果spliterator没有报告immutable或者concurrent\",{\"1\":{\"1620\":1}}],[\"如果sizectl值大于等于0\",{\"1\":{\"1554\":1}}],[\"如果sentinel\",{\"1\":{\"624\":1}}],[\"如果session\",{\"1\":{\"492\":1}}],[\"如果select\",{\"1\":{\"476\":1}}],[\"如果sql语句中条件是where\",{\"1\":{\"366\":1}}],[\"如果定义的index2不是email\",{\"1\":{\"350\":1}}],[\"如果entrylist为空\",{\"1\":{\"1483\":1}}],[\"如果email这个字段上没有索引\",{\"1\":{\"350\":1}}],[\"如果explain的结果预估的rows的值跟实际情况差距比较大\",{\"1\":{\"347\":1}}],[\"如果选择索引b的话\",{\"1\":{\"348\":1}}],[\"如果使用\",{\"1\":{\"1650\":1}}],[\"如果使用spliterator不能进行分割\",{\"1\":{\"1620\":1}}],[\"如果使用原来传统的方式又该怎么做呢\",{\"1\":{\"1611\":1}}],[\"如果使用方法引用甚至能够让代码变的更加简洁\",{\"1\":{\"1593\":1}}],[\"如果使用排序的映射\",{\"1\":{\"1544\":1}}],[\"如果使用iterator来遍历集合的元素\",{\"1\":{\"1353\":1}}],[\"如果使用inndb引擎或者myisam引擎的临时表\",{\"1\":{\"409\":1}}],[\"如果使用index1\",{\"1\":{\"351\":1}}],[\"如果使用自定义实现\",{\"1\":{\"967\":1}}],[\"如果使用了truncate\",{\"1\":{\"485\":1}}],[\"如果使用delete语句误删了数据行\",{\"1\":{\"484\":1}}],[\"如果使用api开发\",{\"1\":{\"482\":1}}],[\"如果使用api\",{\"1\":{\"482\":1}}],[\"如果使用上面提到的策略\",{\"1\":{\"472\":1}}],[\"如果使用归并算法就会浪费非常多的计算量\",{\"1\":{\"421\":1}}],[\"如果使用归并排序算法的话\",{\"1\":{\"421\":1}}],[\"如果使用普通表\",{\"1\":{\"410\":1}}],[\"如果使用block\",{\"1\":{\"403\":1}}],[\"如果使用join语句\",{\"1\":{\"403\":1}}],[\"如果使用join语句的话\",{\"1\":{\"401\":1}}],[\"如果使用的是指定大小的构造器\",{\"1\":{\"1542\":1}}],[\"如果使用的是无参构造器\",{\"1\":{\"1542\":1}}],[\"如果使用的是索引执行的单表扫描\",{\"1\":{\"554\":1}}],[\"如果使用的是全表扫描的方式执行的单表查询\",{\"1\":{\"554\":1}}],[\"如果使用的是index2\",{\"1\":{\"350\":1}}],[\"如果使用的是index1\",{\"1\":{\"350\":1}}],[\"如果使用的mysql5\",{\"1\":{\"318\":1}}],[\"如果使用索引的话\",{\"1\":{\"554\":1}}],[\"如果使用索引b进行查询\",{\"1\":{\"347\":1}}],[\"如果使用索引a进行查询\",{\"1\":{\"347\":1}}],[\"如果使用索引a\",{\"1\":{\"347\":1}}],[\"如果都已经读入到内存了\",{\"1\":{\"343\":1}}],[\"如果业务代码已经保证了不会写入重复的身份证号\",{\"1\":{\"341\":1}}],[\"如果市民系统需要按照身份证号查姓名\",{\"1\":{\"341\":1}}],[\"如果既有联合查询\",{\"1\":{\"339\":1}}],[\"如果可以使用特化版本就不要使用通用版本\",{\"1\":{\"1620\":1}}],[\"如果可以使用index\",{\"1\":{\"403\":1}}],[\"如果可以帮助扩容\",{\"1\":{\"1554\":1}}],[\"如果可以\",{\"1\":{\"555\":1}}],[\"如果可以控制并发量\",{\"1\":{\"444\":1}}],[\"如果可以确保输入的数据是有序的\",{\"1\":{\"417\":1}}],[\"如果可以通过调整联合索引的顺序\",{\"1\":{\"339\":1}}],[\"如果可能的话\",{\"1\":{\"330\":1}}],[\"如果有\",{\"1\":{\"1630\":1}}],[\"如果有了一系列的中间操作\",{\"1\":{\"1622\":1}}],[\"如果有中间操作的话\",{\"1\":{\"1622\":1}}],[\"如果有长度为5的字符串\",{\"1\":{\"1612\":1}}],[\"如果有的话\",{\"1\":{\"1598\":1,\"1623\":1}}],[\"如果有的表使用了不支持事务的引擎\",{\"1\":{\"438\":1}}],[\"如果有结果不断从一个线程到另一个线程那么可以使用消息队列\",{\"1\":{\"1530\":1}}],[\"如果有这个需要\",{\"1\":{\"1509\":1}}],[\"如果有数据\",{\"1\":{\"1501\":1}}],[\"如果有足够的带宽可用\",{\"1\":{\"1474\":1}}],[\"如果有过期的\",{\"1\":{\"1289\":1}}],[\"如果有事务会滚这种情况\",{\"1\":{\"1263\":1}}],[\"如果有性能问题\",{\"1\":{\"1257\":1}}],[\"如果有唯一性\",{\"1\":{\"1248\":1}}],[\"如果有针对user的单表查询\",{\"1\":{\"1219\":1}}],[\"如果有一个bean有\",{\"1\":{\"1648\":1}}],[\"如果有一个用户\",{\"1\":{\"1201\":1}}],[\"如果有一个字段可以排序\",{\"1\":{\"505\":1}}],[\"如果有索引一般选择nlj算法\",{\"1\":{\"525\":1}}],[\"如果有并行的多个只读事务\",{\"1\":{\"497\":1}}],[\"如果有跨表的事务\",{\"1\":{\"461\":1}}],[\"如果有可能\",{\"1\":{\"454\":1,\"494\":1}}],[\"如果有多个\",{\"1\":{\"1648\":1}}],[\"如果有多个事务的binlog已经写完了\",{\"1\":{\"451\":1}}],[\"如果有多个session同时执行join优化\",{\"1\":{\"410\":1}}],[\"如果有两个线程要同时给一个表加字段\",{\"1\":{\"441\":1}}],[\"如果有两个大小不同的表做join\",{\"1\":{\"400\":1}}],[\"如果有就优先操作临时表\",{\"1\":{\"412\":1}}],[\"如果有根据身份证号查询市民信息的需求\",{\"1\":{\"338\":1}}],[\"如果有权限\",{\"1\":{\"322\":1}}],[\"如果执行成功\",{\"1\":{\"1655\":1}}],[\"如果执行下面的sql\",{\"1\":{\"536\":1}}],[\"如果执行计划extra中未出现using\",{\"1\":{\"524\":1}}],[\"如果执行期间\",{\"1\":{\"473\":1}}],[\"如果执行完一条delete语句以后\",{\"1\":{\"454\":1}}],[\"如果执行的次数过多\",{\"1\":{\"1617\":1}}],[\"如果执行的update语句\",{\"1\":{\"454\":1}}],[\"如果执行的是delete语句\",{\"1\":{\"454\":1}}],[\"如果执行的语句是select\",{\"1\":{\"338\":1}}],[\"如果执行ftwrl命令之后由于客户端发生异常断开\",{\"1\":{\"438\":1}}],[\"如果执行mmit\",{\"1\":{\"435\":1}}],[\"如果执行commit则提交事务\",{\"1\":{\"435\":1}}],[\"如果执行逻辑需要用到二维表特性\",{\"1\":{\"418\":1}}],[\"如果执行如下语句\",{\"1\":{\"416\":1}}],[\"如果执行select\",{\"1\":{\"336\":1}}],[\"如果用户在浏览器中打开另一个tab页\",{\"1\":{\"1201\":1}}],[\"如果用户名密码认证通过\",{\"1\":{\"318\":1}}],[\"如果用户名或密码不对\",{\"1\":{\"318\":1}}],[\"如果用来检测主库的话\",{\"1\":{\"478\":1}}],[\"如果用select\",{\"1\":{\"448\":1}}],[\"如果用一个大的语句一次性完成的话\",{\"1\":{\"393\":1}}],[\"如果用身份证号做主键\",{\"1\":{\"335\":1}}],[\"如果新插入的id的值为400\",{\"1\":{\"335\":1}}],[\"如果语句执行过程可以一边读数据\",{\"1\":{\"418\":1}}],[\"如果语句是select\",{\"1\":{\"335\":2}}],[\"如果语句不对\",{\"1\":{\"320\":1}}],[\"如果语句不在查询缓存中\",{\"1\":{\"319\":1}}],[\"如果我们想求出学生分数的最小值\",{\"1\":{\"1616\":1}}],[\"如果我们想实现收集器的复合改怎么做呢\",{\"1\":{\"1615\":1}}],[\"如果我们想定义四则运算的话\",{\"1\":{\"1598\":1}}],[\"如果我们使用并行流\",{\"1\":{\"1617\":1}}],[\"如果我们使用传统的编码方式来实现对于名字的分组操作\",{\"1\":{\"1613\":1}}],[\"如果我们使用有序数组来实现的话\",{\"1\":{\"333\":1}}],[\"如果我们将刚才的操作反过来\",{\"1\":{\"1610\":1}}],[\"如果我们改一下需求\",{\"1\":{\"1610\":1}}],[\"如果我们在accumulator中打印当前线程的名称\",{\"1\":{\"1617\":1}}],[\"如果我们在某个接口上声明了functionalinterface注解\",{\"1\":{\"1594\":1}}],[\"如果我们在创建表的语句并没有制定stats\",{\"1\":{\"558\":1}}],[\"如果我们在创建表时未指定stats\",{\"1\":{\"558\":1,\"559\":1}}],[\"如果我们只需要最快的那一个结果\",{\"1\":{\"1517\":1}}],[\"如果我们设置过少的线程数\",{\"1\":{\"1510\":1}}],[\"如果我们设置了双m结构\",{\"1\":{\"455\":1}}],[\"如果我们的场景需要直接传递的话\",{\"1\":{\"1509\":1}}],[\"如果我们需要动态扩容的话\",{\"1\":{\"1509\":1}}],[\"如果我们删除对应的索引再来运行这个查询\",{\"1\":{\"390\":1}}],[\"如果我们用二叉搜索树来实现上述的例子\",{\"1\":{\"334\":1}}],[\"如果为null\",{\"1\":{\"330\":1}}],[\"如果在当前的beanfactory中没有找到\",{\"1\":{\"1647\":1}}],[\"如果在操作原生子类型特化的时候\",{\"1\":{\"1620\":1}}],[\"如果在绑定元之前对元进行了修改的话\",{\"1\":{\"1620\":1}}],[\"如果在计算过程中\",{\"1\":{\"1599\":1}}],[\"如果在高并发的情况下\",{\"1\":{\"1573\":1}}],[\"如果在新表的数组索引位置相同\",{\"1\":{\"1550\":1}}],[\"如果在usermappper\",{\"1\":{\"1219\":1}}],[\"如果在订阅方断线\",{\"1\":{\"600\":1}}],[\"如果在分析某个连接顺序的成本时\",{\"1\":{\"556\":1}}],[\"如果在\",{\"1\":{\"542\":1}}],[\"如果在select语句后面加上for\",{\"1\":{\"497\":1}}],[\"如果在实际使用中\",{\"1\":{\"482\":1}}],[\"如果在连接命令中加上\",{\"1\":{\"482\":1}}],[\"如果在连接被断开之后\",{\"1\":{\"318\":1}}],[\"如果在业务更新的高峰期\",{\"1\":{\"472\":1}}],[\"如果在主库上有多个db\",{\"1\":{\"463\":1}}],[\"如果在这个执行的等待时间里面能够拿到mdl写锁最好\",{\"1\":{\"441\":1}}],[\"如果在binlog写完之后crash\",{\"1\":{\"327\":1}}],[\"如果需要进行aop\",{\"1\":{\"1649\":1}}],[\"如果需要在线程安全的场合下使用\",{\"1\":{\"1544\":1}}],[\"如果需要在并发场景中使用一个线程不安全的工具类\",{\"1\":{\"1528\":1}}],[\"如果需要满足线程安全\",{\"1\":{\"1544\":1}}],[\"如果需要扩容\",{\"1\":{\"1542\":1,\"1554\":1}}],[\"如果需要一个高性能的系统\",{\"1\":{\"1520\":1}}],[\"如果需要支持事务\",{\"1\":{\"1028\":1}}],[\"如果需要额外的\",{\"1\":{\"928\":1}}],[\"如果需要自动生成自增值\",{\"1\":{\"490\":1}}],[\"如果需要用binlog来恢复临时库的话\",{\"1\":{\"327\":1}}],[\"如果需要部分更新\",{\"1\":{\"306\":1}}],[\"如果write\",{\"1\":{\"324\":1}}],[\"如果要深入学习mysql的使用和原理\",{\"1\":{\"1974\":1}}],[\"如果要指定构造方法\",{\"1\":{\"1630\":1}}],[\"如果要正常编译运行\",{\"1\":{\"1614\":1}}],[\"如果要按照长度来进行排序\",{\"1\":{\"1614\":1}}],[\"如果要根据年龄来分组呢\",{\"1\":{\"1613\":1}}],[\"如果要改用串行流改怎么做呢\",{\"1\":{\"1612\":1}}],[\"如果要改回默认值\",{\"1\":{\"557\":1}}],[\"如果要调用系统资源\",{\"1\":{\"1579\":1}}],[\"如果要我们手动用future实现\",{\"1\":{\"1518\":1}}],[\"如果要保证线程安全\",{\"1\":{\"1236\":1}}],[\"如果要想映入新的bean的别名的话\",{\"1\":{\"928\":1}}],[\"如果要避免不安全\",{\"1\":{\"583\":1}}],[\"如果要避免切换过程中有不可用时间的这个问题\",{\"1\":{\"458\":1}}],[\"如果要修改上述参数\",{\"1\":{\"557\":1}}],[\"如果要操作多行的大事务的话\",{\"1\":{\"462\":1}}],[\"如果要在表中删除一行数据的话\",{\"1\":{\"454\":1}}],[\"如果要在id\",{\"1\":{\"341\":1}}],[\"如果要做ddl变更的表刚好有长事务在执行\",{\"1\":{\"441\":1}}],[\"如果要手工分析日志\",{\"1\":{\"429\":1}}],[\"如果要使慢查询日志永久开启\",{\"1\":{\"428\":1}}],[\"如果要使用串行流\",{\"1\":{\"1617\":1}}],[\"如果要使用传统的方式实现这些需求\",{\"1\":{\"1599\":1}}],[\"如果要使用\",{\"1\":{\"965\":1}}],[\"如果要使用bka优化算法的话\",{\"1\":{\"405\":1}}],[\"如果要使用邮箱登录\",{\"1\":{\"349\":1}}],[\"如果要使用覆盖索引\",{\"1\":{\"330\":1}}],[\"如果要优化查询\",{\"1\":{\"381\":1}}],[\"如果要排序的数据量小于sort\",{\"1\":{\"354\":1}}],[\"如果要为每一种查询都设计一个索引\",{\"1\":{\"339\":1}}],[\"如果要查询id=2的交易的所有操作步骤信息\",{\"1\":{\"368\":1}}],[\"如果要查询区间的时间复杂度也是o\",{\"1\":{\"333\":1}}],[\"如果要查的是所有名字第一个字的是\",{\"1\":{\"339\":1}}],[\"如果要查找身份证号在\",{\"1\":{\"332\":1}}],[\"如果要将id=2这一行的值加1\",{\"1\":{\"323\":1}}],[\"如果要更改mapping的字段类型\",{\"1\":{\"309\":1}}],[\"如果查询是基于分区表的话\",{\"1\":{\"506\":1}}],[\"如果查询是落在这个相应ack的从库上\",{\"1\":{\"472\":1}}],[\"如果查询结果太大\",{\"1\":{\"482\":1}}],[\"如果查询过程中生成了比较大的临时文件\",{\"1\":{\"481\":1}}],[\"如果查询选择的是从库的话\",{\"1\":{\"469\":1}}],[\"如果查询语句的where条件中没有分区key\",{\"1\":{\"425\":1}}],[\"如果查询没有办法找到合适的访问类型\",{\"1\":{\"390\":1}}],[\"如果查询写得很糟糕\",{\"1\":{\"381\":1}}],[\"如果查询命中缓存\",{\"1\":{\"319\":1}}],[\"如果查询能够直接这个缓存中找到key\",{\"1\":{\"319\":1}}],[\"如果查该index可以直接用空对象表示\",{\"1\":{\"307\":1}}],[\"如果你学的过程中\",{\"1\":{\"1972\":1}}],[\"如果你定义的是一个sqlsessionfactory类型的bean\",{\"1\":{\"1653\":1}}],[\"如果你非常关心你的数据\",{\"1\":{\"596\":1}}],[\"如果你还有一些疑问\",{\"1\":{\"514\":1}}],[\"如果你没有后续的动作\",{\"1\":{\"318\":1}}],[\"如果你连接的是生产服务器\",{\"1\":{\"318\":1}}],[\"如果不需要\",{\"1\":{\"1649\":1}}],[\"如果不需要创建\",{\"1\":{\"1648\":1}}],[\"如果不需要使用该类\",{\"1\":{\"1191\":1}}],[\"如果不满足以下情况编译器会报错\",{\"1\":{\"1594\":1}}],[\"如果不满足t1\",{\"1\":{\"407\":1}}],[\"如果不在扩容\",{\"1\":{\"1554\":1}}],[\"如果不成功\",{\"1\":{\"1520\":1}}],[\"如果不存在\",{\"1\":{\"1283\":1}}],[\"如果不存在会直接new一个\",{\"1\":{\"1121\":1}}],[\"如果不存在值\",{\"1\":{\"570\":1}}],[\"如果不允许容错\",{\"1\":{\"577\":1}}],[\"如果不设置隔离级别默认用mysql设置的隔离级别\",{\"1\":{\"532\":1}}],[\"如果不行\",{\"1\":{\"481\":1}}],[\"如果不加以限制\",{\"1\":{\"476\":1}}],[\"如果不加以小心\",{\"1\":{\"386\":1}}],[\"如果不包含\",{\"1\":{\"468\":1}}],[\"如果不同db的热点不同\",{\"1\":{\"463\":1}}],[\"如果不想每次都多\",{\"1\":{\"435\":1}}],[\"如果不是扫描出现的情况\",{\"1\":{\"1647\":1}}],[\"如果不是延迟绑定的spliterator\",{\"1\":{\"1620\":1}}],[\"如果不是调优需要的话\",{\"1\":{\"428\":1}}],[\"如果不是则跳过\",{\"1\":{\"322\":1}}],[\"如果不使用分区表的话\",{\"1\":{\"424\":1}}],[\"如果不使用\",{\"1\":{\"327\":1}}],[\"如果不用两阶段提交\",{\"1\":{\"327\":1}}],[\"如果不指定引擎类型\",{\"1\":{\"317\":1}}],[\"如果不写id就由es生成一个唯一id进行创建新文档\",{\"1\":{\"306\":1}}],[\"如果版本号不对\",{\"1\":{\"306\":1}}],[\"如果文档存在\",{\"1\":{\"306\":1}}],[\"如果填了id那就针对这个id的文档进行创建\",{\"1\":{\"306\":1}}],[\"如果是抽象的beandefinition不会创建bean\",{\"1\":{\"1647\":1}}],[\"如果是抽象类的话方法上面需要有\",{\"1\":{\"1647\":1}}],[\"如果是false\",{\"1\":{\"1621\":1}}],[\"如果是true表示并行\",{\"1\":{\"1621\":1}}],[\"如果是源阶段就是它自身\",{\"1\":{\"1621\":1}}],[\"如果是源阶段的话就是null\",{\"1\":{\"1621\":1}}],[\"如果是并行流\",{\"1\":{\"1617\":1,\"1622\":1}}],[\"如果是求出分数的总和呢\",{\"1\":{\"1616\":1}}],[\"如果是平均值呢\",{\"1\":{\"1616\":1}}],[\"如果是最大值呢\",{\"1\":{\"1616\":1}}],[\"如果是降序则\",{\"1\":{\"1614\":1}}],[\"如果是红黑树\",{\"1\":{\"1549\":1}}],[\"如果是两次握手\",{\"1\":{\"1420\":1}}],[\"如果是两个事务没有更新相同的行\",{\"1\":{\"462\":1}}],[\"如果是共享变量引起的线程安全问题\",{\"1\":{\"1416\":1}}],[\"如果是过期的锁\",{\"1\":{\"1288\":1}}],[\"如果是在高并发场景下\",{\"1\":{\"1283\":1}}],[\"如果是实例方法\",{\"1\":{\"1183\":1}}],[\"如果是中文\",{\"1\":{\"978\":1}}],[\"如果是必须依赖的话\",{\"1\":{\"970\":1}}],[\"如果是一个普通的bean就会调用java\",{\"1\":{\"928\":1}}],[\"如果是一个普通表的话\",{\"1\":{\"424\":1}}],[\"如果是简单场景的bean的名称\",{\"1\":{\"928\":1}}],[\"如果是使用全表扫描的话\",{\"1\":{\"554\":1}}],[\"如果是读已提交的隔离级别会在每次执行查询sql时都会重新生成\",{\"1\":{\"542\":1}}],[\"如果是误删表\",{\"1\":{\"485\":1}}],[\"如果是执行错了insert语句\",{\"1\":{\"454\":1}}],[\"如果是长连接\",{\"1\":{\"435\":1}}],[\"如果是长整型\",{\"1\":{\"335\":1}}],[\"如果是按月分区\",{\"1\":{\"426\":1}}],[\"如果是mysql5\",{\"1\":{\"417\":1}}],[\"如果是大表就会占用非常多的cpu资源\",{\"1\":{\"406\":1}}],[\"如果是block\",{\"1\":{\"403\":1}}],[\"如果是index\",{\"1\":{\"403\":1}}],[\"如果是事务型引擎\",{\"1\":{\"393\":1}}],[\"如果是子查询\",{\"1\":{\"330\":1}}],[\"如果是则将这行存在结果集中\",{\"1\":{\"322\":1}}],[\"如果是\",{\"0\":{\"183\":1,\"1240\":1},\"1\":{\"407\":1}}],[\"如何判断当前bean对象需不需要进行aop\",{\"1\":{\"1630\":1}}],[\"如何判断一个主库出了问题\",{\"1\":{\"475\":1}}],[\"如何将子任务进行分割\",{\"1\":{\"1620\":1}}],[\"如何使用并行框架来尽心给计算\",{\"1\":{\"1620\":1}}],[\"如何使用反射获取私有属性\",{\"0\":{\"22\":1,\"1351\":1}}],[\"如何从工作内存到主内存之间的实现细节\",{\"1\":{\"1473\":1}}],[\"如何控制propertysource的优先级\",{\"0\":{\"1160\":1}}],[\"如何避免\",{\"1\":{\"1116\":1}}],[\"如何避免b属性x不被绑定\",{\"1\":{\"1072\":1}}],[\"如何注册一个spring\",{\"0\":{\"936\":1}}],[\"如何界定ioc容器是轻量级的\",{\"0\":{\"910\":1}}],[\"如何选择合适的阻塞队列\",{\"0\":{\"1509\":1}}],[\"如何选择合适的索引\",{\"0\":{\"519\":1}}],[\"如何选择使用哪种持久化方式\",{\"0\":{\"596\":1}}],[\"如何查看一个应用的信息\",{\"0\":{\"256\":1,\"1465\":1}}],[\"如何手写一个注册中心\",{\"0\":{\"243\":1,\"1323\":1}}],[\"如何配置动态路由\",{\"0\":{\"242\":1,\"1322\":1}}],[\"如何通过服务名找到服务实例\",{\"0\":{\"239\":1,\"1319\":1}}],[\"如何实现配置自动更新messagesource\",{\"0\":{\"1060\":1}}],[\"如何实现新老注解的兼容的注入方法呢\",{\"1\":{\"967\":1}}],[\"如何实现单点登录系统\",{\"0\":{\"222\":1,\"1205\":1}}],[\"如何实现一个自定义的class作为hashmap的key\",{\"0\":{\"38\":1,\"1366\":1}}],[\"如何防止\",{\"0\":{\"218\":1,\"1201\":1}}],[\"如何设计一个不可变类\",{\"1\":{\"1366\":1}}],[\"如何设计一个权限认证框架\",{\"0\":{\"216\":1,\"1199\":1}}],[\"如何设计一个分布式锁\",{\"0\":{\"136\":1,\"1288\":1}}],[\"如何自己写一个springboot\",{\"0\":{\"190\":1,\"1249\":1}}],[\"如何处理\",{\"0\":{\"179\":1,\"1236\":1}}],[\"如何进行产品选型\",{\"0\":{\"246\":1,\"1327\":1}}],[\"如何进行中文分词\",{\"0\":{\"173\":1,\"1255\":1}}],[\"如何进行jvm调优\",{\"0\":{\"121\":1,\"1452\":1}}],[\"如何对锁性能进行优化\",{\"0\":{\"136\":1,\"1288\":1}}],[\"如何对一个字符串快速进行排序\",{\"0\":{\"83\":1,\"1412\":1}}],[\"如何回收方法区\",{\"0\":{\"112\":1,\"1443\":1}}],[\"如何访问对象\",{\"0\":{\"99\":1,\"1430\":1}}],[\"如何保证不丢失\",{\"1\":{\"1328\":1}}],[\"如何保证数据并发访问的一致性\",{\"1\":{\"533\":1}}],[\"如何保证消息的高效读写\",{\"0\":{\"250\":1,\"1331\":1}}],[\"如何保证消息不丢失\",{\"0\":{\"247\":1,\"1328\":1}}],[\"如何保证消费幂等性\",{\"0\":{\"248\":1,\"1329\":1}}],[\"如何保证线程安全\",{\"0\":{\"183\":1,\"1240\":1}}],[\"如何保证redis的高可用\",{\"0\":{\"149\":1,\"1301\":1}}],[\"如何保证redis与数据库的数据一致\",{\"0\":{\"133\":1,\"1285\":1}}],[\"如何保证接口的幂等性\",{\"0\":{\"86\":1,\"1415\":1}}],[\"如何保证三个线程有序交错进行\",{\"0\":{\"75\":1,\"1404\":1}}],[\"如何保证三个线程同时执行\",{\"0\":{\"75\":1,\"1404\":1}}],[\"如何获取子线程的执行结果\",{\"0\":{\"82\":1,\"1411\":1}}],[\"如何在并发情况下保证三个线程依次执行\",{\"0\":{\"75\":1,\"1404\":1}}],[\"如何停止一个正在运行的线程\",{\"0\":{\"50\":1,\"1379\":1}}],[\"eureka\",{\"1\":{\"1664\":1}}],[\"e=e\",{\"1\":{\"1617\":4}}],[\"e>\",{\"1\":{\"1603\":1,\"1622\":1}}],[\"efficiency\",{\"1\":{\"1620\":1}}],[\"efficient\",{\"1\":{\"1619\":1,\"1620\":2}}],[\"efficiently\",{\"1\":{\"997\":1,\"1620\":1}}],[\"effort\",{\"1\":{\"1620\":2}}],[\"effective\",{\"1\":{\"1620\":1}}],[\"effect\",{\"1\":{\"1619\":1,\"1623\":1}}],[\"effects\",{\"1\":{\"1597\":2}}],[\"ek\",{\"1\":{\"1554\":4}}],[\"e得到false\",{\"1\":{\"1479\":1}}],[\"e就是true\",{\"1\":{\"1479\":1}}],[\"epoll使用一个文件描述符管理多个描述符\",{\"1\":{\"1571\":1}}],[\"epoll更加灵活\",{\"1\":{\"1571\":1}}],[\"epoll是在linux内核2\",{\"1\":{\"1571\":1}}],[\"epoll本质上都是同步io\",{\"1\":{\"1568\":1}}],[\"epoll的优势并不是对于单个连接能处理得更快\",{\"1\":{\"1565\":1}}],[\"epoll的web\",{\"1\":{\"1565\":1}}],[\"epoll的好处在于单个process就可以同时处理多个网络连接的io\",{\"1\":{\"1565\":1}}],[\"epoll这个function会不断的轮询所负责的所有socket\",{\"1\":{\"1565\":1}}],[\"epoll详解\",{\"1\":{\"1561\":1}}],[\"epoll中不再扫描所有的fd\",{\"1\":{\"1423\":1}}],[\"epoll\",{\"0\":{\"1568\":1,\"1571\":1},\"1\":{\"1423\":2,\"1565\":1}}],[\"epoll有什么区别\",{\"0\":{\"93\":1,\"1423\":1}}],[\"etc\",{\"1\":{\"1164\":1,\"1166\":1,\"1609\":1,\"1615\":1,\"1616\":1,\"1619\":1,\"1623\":3}}],[\"easy\",{\"1\":{\"1620\":1}}],[\"each\",{\"1\":{\"1595\":3,\"1600\":2,\"1608\":2,\"1615\":3,\"1618\":2,\"1619\":1,\"1620\":2,\"1621\":3,\"1622\":1,\"1623\":7}}],[\"earlysingletonreference\",{\"1\":{\"1647\":3}}],[\"earlysingletonexposure\",{\"1\":{\"1647\":3,\"1649\":2}}],[\"earlysingletonobjects\",{\"1\":{\"1184\":1,\"1649\":1}}],[\"earlyevent\",{\"1\":{\"1170\":2}}],[\"earlyeventstoprocess\",{\"1\":{\"1170\":3}}],[\"earlyapplicationevents\",{\"1\":{\"1162\":1,\"1170\":2}}],[\"earlyapplicationlisteners\",{\"1\":{\"1162\":3,\"1175\":2}}],[\"early\",{\"1\":{\"1162\":1,\"1164\":1,\"1170\":1,\"1171\":2}}],[\"ear文件\",{\"1\":{\"1037\":1}}],[\"eanable模块\",{\"1\":{\"1138\":1}}],[\"eanable模块驱动是以\",{\"1\":{\"1138\":1}}],[\"eagerly\",{\"1\":{\"1647\":5}}],[\"eager=true\",{\"1\":{\"963\":1}}],[\"eager\",{\"1\":{\"963\":1,\"1647\":1}}],[\"either\",{\"1\":{\"952\":1,\"1597\":1,\"1598\":6,\"1599\":4,\"1615\":1,\"1619\":1,\"1620\":3,\"1621\":1}}],[\"erroneous\",{\"1\":{\"1619\":1}}],[\"errorhandler\",{\"1\":{\"1124\":5,\"1125\":1}}],[\"errormessagedemo\",{\"1\":{\"1063\":1}}],[\"errorbean\",{\"1\":{\"946\":2}}],[\"errors文案生成步骤\",{\"1\":{\"1063\":1}}],[\"errors的文案来源\",{\"0\":{\"1063\":1}}],[\"errors接口设计\",{\"0\":{\"1062\":1}}],[\"errors\",{\"1\":{\"580\":1,\"1061\":7,\"1063\":7,\"1064\":8,\"1068\":1,\"1619\":1}}],[\"errors忽略错误的方法\",{\"1\":{\"468\":1}}],[\"errors设置为\",{\"1\":{\"467\":1}}],[\"errors参数\",{\"1\":{\"467\":2}}],[\"error并停止\",{\"1\":{\"459\":1}}],[\"error\",{\"1\":{\"320\":1,\"322\":1,\"491\":1,\"571\":1,\"573\":1,\"579\":1,\"580\":4,\"611\":2,\"1063\":3,\"1064\":3,\"1163\":1,\"1594\":2,\"1651\":1,\"1655\":2}}],[\"err\",{\"1\":{\"573\":1,\"579\":1,\"580\":2,\"944\":2,\"946\":1,\"973\":1,\"1124\":2}}],[\"eg\",{\"1\":{\"565\":1}}],[\"evict\",{\"1\":{\"1549\":2}}],[\"evans提出的\",{\"1\":{\"1309\":1}}],[\"evaluating\",{\"1\":{\"1599\":4,\"1621\":1}}],[\"evaluation\",{\"1\":{\"1598\":6,\"1599\":8,\"1621\":3,\"1623\":1}}],[\"evaluatetryfailure\",{\"1\":{\"1655\":2}}],[\"evaluateparallel\",{\"1\":{\"1623\":5}}],[\"evaluated\",{\"1\":{\"1599\":8,\"1617\":1,\"1621\":1}}],[\"evaluatesequential\",{\"1\":{\"1623\":5}}],[\"evaluates\",{\"1\":{\"1599\":2,\"1623\":1}}],[\"evaluatebeandefinitionstring\",{\"1\":{\"963\":1,\"1648\":1}}],[\"evaluate\",{\"1\":{\"557\":1,\"1617\":1,\"1622\":1,\"1623\":2}}],[\"eval\",{\"1\":{\"553\":2,\"555\":3}}],[\"even\",{\"1\":{\"963\":1,\"1139\":4,\"1620\":3,\"1647\":1}}],[\"eventually\",{\"1\":{\"1620\":1,\"1647\":1}}],[\"eventproducer\",{\"1\":{\"1521\":2}}],[\"eventprofilecondition\",{\"1\":{\"1139\":2}}],[\"eventfactory\",{\"1\":{\"1520\":2}}],[\"eventfactory<t>\",{\"1\":{\"1520\":1}}],[\"eventobserver\",{\"1\":{\"1108\":2}}],[\"eventobservable\",{\"1\":{\"1108\":2}}],[\"eventobject扩展\",{\"1\":{\"1111\":1}}],[\"eventobject\",{\"1\":{\"1108\":6}}],[\"eventloopthreads\",{\"1\":{\"1227\":1}}],[\"eventloop\",{\"1\":{\"1224\":2}}],[\"eventloopgroup\",{\"0\":{\"695\":1},\"1\":{\"1226\":3}}],[\"eventloopgroup了解么\",{\"0\":{\"208\":1,\"1225\":1}}],[\"eventlistenermethodprocessor\",{\"1\":{\"1143\":1}}],[\"eventlistenermethodprocessor对象\",{\"1\":{\"945\":1}}],[\"eventlistener的工作原理\",{\"0\":{\"1130\":1,\"1143\":1}}],[\"eventlistener的spring事件监听方法\",{\"1\":{\"945\":1}}],[\"eventlistener与\",{\"1\":{\"1129\":1}}],[\"eventlistener接收到spring事件\",{\"1\":{\"1113\":2}}],[\"eventlistener2接收到spring事件\",{\"1\":{\"1113\":1}}],[\"eventlistener1接收到spring事件\",{\"1\":{\"1113\":1}}],[\"eventlistener扩展\",{\"1\":{\"1112\":1}}],[\"eventlistener\",{\"1\":{\"1108\":2,\"1113\":6,\"1123\":2}}],[\"eventlistener事件监听方法适配为applicationlistener\",{\"1\":{\"945\":1}}],[\"event改为write\",{\"1\":{\"484\":1}}],[\"event即可\",{\"1\":{\"484\":1}}],[\"event类型是write\",{\"1\":{\"484\":1}}],[\"event里的行数据\",{\"1\":{\"465\":1}}],[\"event里面\",{\"1\":{\"454\":1}}],[\"event\",{\"1\":{\"454\":2,\"479\":6,\"484\":2,\"603\":4,\"900\":1,\"922\":2,\"945\":6,\"1053\":6,\"1073\":1,\"1108\":2,\"1109\":4,\"1110\":1,\"1111\":4,\"1112\":3,\"1113\":7,\"1114\":1,\"1116\":4,\"1118\":1,\"1119\":2,\"1120\":4,\"1121\":5,\"1122\":3,\"1123\":8,\"1124\":3,\"1125\":1,\"1128\":1,\"1143\":1,\"1168\":4,\"1172\":1,\"1175\":2,\"1227\":4,\"1423\":1,\"1591\":4,\"1647\":2}}],[\"event显示了接下来要打开的表\",{\"1\":{\"454\":1}}],[\"event用于定义删除的行为\",{\"1\":{\"454\":1}}],[\"event用于说明接下来要操作的表是test库的表t\",{\"1\":{\"454\":1}}],[\"eventsetdescriptor\",{\"1\":{\"1075\":1}}],[\"events\",{\"1\":{\"454\":1,\"603\":4,\"892\":1,\"921\":1,\"1124\":1,\"1170\":1,\"1570\":3}}],[\"every\",{\"1\":{\"1623\":2}}],[\"everysec\",{\"1\":{\"592\":1}}],[\"ever\",{\"1\":{\"922\":1,\"1647\":1,\"1651\":1}}],[\"el\",{\"1\":{\"1978\":1}}],[\"el表达式解析器\",{\"1\":{\"1636\":1,\"1651\":1}}],[\"elided\",{\"1\":{\"1617\":1}}],[\"eliminatelocks\",{\"1\":{\"1487\":1}}],[\"eligible\",{\"1\":{\"1166\":1}}],[\"elk日志收集解决方案\",{\"1\":{\"1257\":1}}],[\"elementdequeued\",{\"1\":{\"1502\":1}}],[\"elementdata\",{\"1\":{\"1475\":3,\"1542\":1}}],[\"elements\",{\"1\":{\"996\":1,\"1595\":2,\"1601\":3,\"1608\":4,\"1613\":5,\"1614\":1,\"1615\":8,\"1616\":3,\"1617\":1,\"1618\":12,\"1619\":4,\"1620\":38,\"1621\":2,\"1623\":13,\"1648\":3}}],[\"elementtype\",{\"1\":{\"917\":1,\"961\":13,\"963\":3,\"967\":6,\"1134\":1,\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":3,\"1594\":1}}],[\"element\",{\"1\":{\"645\":2,\"1030\":10,\"1500\":1,\"1501\":2,\"1595\":3,\"1608\":6,\"1609\":4,\"1615\":2,\"1618\":2,\"1620\":8,\"1622\":2,\"1623\":5}}],[\"element1\",{\"1\":{\"577\":1}}],[\"elememt2\",{\"1\":{\"577\":1}}],[\"elsewhere\",{\"1\":{\"1594\":2}}],[\"else\",{\"1\":{\"542\":1,\"645\":2,\"928\":1,\"929\":1,\"963\":9,\"964\":1,\"996\":6,\"997\":4,\"1003\":1,\"1007\":1,\"1008\":1,\"1022\":1,\"1027\":2,\"1055\":1,\"1121\":1,\"1124\":1,\"1162\":1,\"1166\":2,\"1167\":1,\"1168\":1,\"1288\":1,\"1432\":1,\"1476\":2,\"1479\":1,\"1549\":3,\"1550\":8,\"1553\":3,\"1554\":6,\"1574\":4,\"1575\":1,\"1607\":2,\"1617\":1,\"1618\":3,\"1620\":6,\"1621\":2,\"1622\":3,\"1623\":2,\"1647\":17,\"1648\":8,\"1650\":1,\"1651\":1,\"1654\":5,\"1655\":3,\"1663\":1}}],[\"elastic\",{\"1\":{\"1986\":1}}],[\"elasticsearch7\",{\"1\":{\"1986\":1}}],[\"elasticsearch的底层是开源库\",{\"1\":{\"1986\":1}}],[\"elasticsearch是目前全文搜索引擎的首选\",{\"1\":{\"1986\":1}}],[\"elasticsearch这些中间件\",{\"1\":{\"1984\":1}}],[\"elasticsearch\",{\"0\":{\"169\":1,\"1251\":1,\"1986\":1}}],[\"elaticsearch形成大型报表\",{\"1\":{\"1310\":1}}],[\"elaticsearch集群架构实战及其原理\",{\"0\":{\"312\":1}}],[\"elaticsearch高阶功能\",{\"0\":{\"311\":1}}],[\"elaticsearch高级查询语法query\",{\"0\":{\"308\":1}}],[\"elaticsearch搜索技术与聚合查询\",{\"0\":{\"310\":1}}],[\"elaticsearch基本概念\",{\"0\":{\"302\":1}}],[\"elaticsearch简介\",{\"0\":{\"301\":1}}],[\"elaticsearch底层在检索时使用的就是倒排索引\",{\"1\":{\"300\":1}}],[\"elaticsearch快速入门\",{\"0\":{\"299\":1}}],[\"elaticsearch\",{\"0\":{\"298\":1},\"1\":{\"301\":1,\"1257\":1}}],[\"e+308\",{\"1\":{\"528\":3}}],[\"e+38\",{\"1\":{\"528\":3}}],[\"edition\",{\"1\":{\"1683\":1}}],[\"edit\",{\"1\":{\"1531\":1}}],[\"editors\",{\"1\":{\"1084\":1}}],[\"edp\",{\"1\":{\"900\":1}}],[\"ed\",{\"1\":{\"522\":2}}],[\"emits\",{\"1\":{\"1623\":2}}],[\"em>\",{\"1\":{\"1594\":2}}],[\"embedded\",{\"1\":{\"1171\":1}}],[\"embeddedvalueresolver\",{\"1\":{\"1005\":1,\"1146\":1}}],[\"embeddedvalueresolveraware\",{\"1\":{\"957\":1,\"1005\":3,\"1164\":1}}],[\"emptiness\",{\"1\":{\"1620\":1}}],[\"emptyspliterator\",{\"1\":{\"1620\":1}}],[\"emptyset\",{\"1\":{\"1618\":1}}],[\"empty\",{\"1\":{\"542\":1,\"569\":1,\"572\":1,\"963\":1,\"996\":1,\"1055\":1,\"1167\":1,\"1554\":1,\"1607\":2,\"1615\":1,\"1620\":2,\"1648\":1,\"1658\":1}}],[\"employed\",{\"1\":{\"1620\":1}}],[\"employee\",{\"1\":{\"1615\":2,\"1616\":5}}],[\"employees表所有字段长度总和肯定大于10字节\",{\"1\":{\"520\":1}}],[\"employees\",{\"1\":{\"510\":3,\"518\":4,\"519\":2,\"520\":2,\"522\":6,\"526\":4,\"1615\":1,\"1616\":4}}],[\"employess\",{\"1\":{\"518\":1}}],[\"emp\",{\"1\":{\"518\":3}}],[\"email=\",{\"1\":{\"351\":2}}],[\"email\",{\"1\":{\"349\":2,\"350\":7,\"351\":2,\"573\":4,\"895\":1}}],[\"e执行kill\",{\"1\":{\"481\":1}}],[\"e执行了kill\",{\"1\":{\"481\":1}}],[\"e中执行show\",{\"1\":{\"481\":1}}],[\"e\",{\"1\":{\"429\":1,\"522\":2,\"528\":6,\"577\":1,\"582\":1,\"946\":3,\"973\":1,\"989\":2,\"996\":1,\"1043\":2,\"1082\":2,\"1084\":2,\"1165\":1,\"1166\":1,\"1368\":3,\"1387\":2,\"1404\":22,\"1432\":1,\"1479\":7,\"1500\":8,\"1501\":10,\"1502\":9,\"1503\":10,\"1506\":3,\"1533\":2,\"1534\":2,\"1535\":4,\"1549\":11,\"1550\":16,\"1551\":4,\"1553\":8,\"1554\":8,\"1557\":3,\"1573\":8,\"1574\":11,\"1575\":16,\"1587\":2,\"1588\":2,\"1591\":2,\"1603\":3,\"1613\":1,\"1614\":1,\"1617\":6,\"1621\":7,\"1622\":5,\"1623\":6,\"1663\":1}}],[\"e5\",{\"1\":{\"378\":1}}],[\"e4\",{\"1\":{\"378\":1}}],[\"e3\",{\"1\":{\"378\":1}}],[\"e2\",{\"1\":{\"378\":1}}],[\"e1\",{\"1\":{\"378\":1,\"1575\":2}}],[\"enhancer\",{\"1\":{\"1654\":7}}],[\"encapsulating\",{\"1\":{\"1621\":1}}],[\"encounter\",{\"1\":{\"1617\":1,\"1620\":2,\"1622\":1,\"1623\":4}}],[\"encountered\",{\"1\":{\"922\":1,\"1620\":4,\"1647\":1,\"1651\":1}}],[\"encodedfilesystemresourceloaderdemo\",{\"1\":{\"1041\":2}}],[\"encodedfilesystemresourcedemo\",{\"1\":{\"1040\":2}}],[\"encodedresource\",{\"1\":{\"997\":4,\"1000\":4,\"1022\":13,\"1026\":1,\"1032\":1,\"1038\":1,\"1040\":5,\"1041\":4,\"1043\":4}}],[\"encoding\",{\"1\":{\"978\":1,\"1043\":2,\"1155\":1}}],[\"encoding=\",{\"1\":{\"917\":1,\"918\":1,\"930\":1,\"953\":2,\"954\":2,\"1030\":1,\"1032\":1,\"1065\":1,\"1084\":1,\"1091\":1,\"1146\":1}}],[\"enough\",{\"1\":{\"1620\":1}}],[\"ensures\",{\"1\":{\"1619\":1}}],[\"ensuresegment\",{\"1\":{\"1553\":2}}],[\"ensure\",{\"1\":{\"1615\":1,\"1620\":2}}],[\"enscore进行合并\",{\"1\":{\"574\":1}}],[\"enscore\",{\"1\":{\"574\":2}}],[\"enscore=>\",{\"1\":{\"574\":1}}],[\"enrty接口\",{\"1\":{\"1546\":1}}],[\"enqueue\",{\"1\":{\"1502\":2,\"1503\":2}}],[\"enaleasync\",{\"1\":{\"1138\":1}}],[\"enabke为前缀的注解驱动编程模型\",{\"1\":{\"1138\":1}}],[\"enabletransactionmanagement注解来开启spring事务是\",{\"1\":{\"1655\":1}}],[\"enabletranscationmanagement\",{\"1\":{\"1138\":1}}],[\"enables\",{\"1\":{\"1615\":1,\"1620\":1}}],[\"enablecircuitbreaker\",{\"1\":{\"1140\":1}}],[\"enablecaching\",{\"1\":{\"1138\":1}}],[\"enabled\",{\"1\":{\"1620\":2,\"1623\":1}}],[\"enablediscovertclient\",{\"1\":{\"1140\":1}}],[\"enabled=off\",{\"1\":{\"519\":1,\"520\":1}}],[\"enabled=on\",{\"1\":{\"354\":1,\"421\":1,\"519\":1,\"520\":1,\"544\":1}}],[\"enabled=\",{\"1\":{\"479\":1}}],[\"enable注解上面\",{\"1\":{\"1138\":1}}],[\"enable注解\",{\"1\":{\"1138\":1}}],[\"enablemoduledemo\",{\"1\":{\"1138\":2}}],[\"enablembeanexport\",{\"1\":{\"1138\":1}}],[\"enablehelloworld\",{\"1\":{\"1138\":4}}],[\"enablewebmvc\",{\"1\":{\"1138\":1}}],[\"enableasync\",{\"1\":{\"1113\":1,\"1123\":1}}],[\"enableautoconfiguration\",{\"0\":{\"873\":1},\"1\":{\"1056\":1,\"1135\":1,\"1140\":1}}],[\"enable模式\",{\"1\":{\"900\":1}}],[\"enable模块驱动\",{\"0\":{\"816\":1,\"1138\":1}}],[\"enable\",{\"1\":{\"899\":1,\"900\":1,\"1138\":2,\"1620\":1}}],[\"english\",{\"1\":{\"1053\":1}}],[\"engine>\",{\"1\":{\"1683\":1}}],[\"engines\",{\"1\":{\"1260\":1}}],[\"engine将表t改成myisam表\",{\"1\":{\"424\":1}}],[\"engine来控制的\",{\"1\":{\"421\":1}}],[\"engine=innodb\",{\"1\":{\"407\":1,\"412\":1,\"413\":1,\"494\":1,\"510\":1,\"518\":1,\"523\":1,\"535\":1,\"558\":4,\"559\":2}}],[\"engine\",{\"1\":{\"335\":1,\"336\":1,\"338\":1,\"346\":1,\"349\":1,\"353\":1,\"366\":1,\"368\":1,\"400\":1,\"409\":1,\"419\":1,\"424\":6,\"433\":1,\"446\":1,\"454\":1,\"459\":1,\"462\":1,\"468\":1,\"476\":1,\"478\":1,\"489\":1,\"506\":3,\"534\":1,\"538\":1,\"557\":3}}],[\"env\",{\"1\":{\"1031\":3,\"1139\":1,\"1147\":1,\"1151\":1,\"1153\":4,\"1154\":3,\"1155\":1,\"1159\":3,\"1479\":1}}],[\"environmentcapable\",{\"1\":{\"1637\":1}}],[\"environmentchangeevent\",{\"1\":{\"1126\":1}}],[\"environment完整的生命周期\",{\"0\":{\"1178\":1}}],[\"environment完整的生命周期是怎样的\",{\"0\":{\"1161\":1}}],[\"environmentpropertysourcechangedemo\",{\"1\":{\"1156\":6}}],[\"environment底层实现\",{\"1\":{\"1151\":1}}],[\"environment2\",{\"1\":{\"1148\":2}}],[\"environment占位符处理\",{\"0\":{\"1146\":1}}],[\"environment接口\",{\"0\":{\"1159\":1}}],[\"environment接口使用场景\",{\"0\":{\"1145\":1}}],[\"environment接口主要有以下两个作用\",{\"1\":{\"1144\":1}}],[\"environment实例已准备时\",{\"1\":{\"1126\":1}}],[\"environmentaware\",{\"1\":{\"957\":1,\"1005\":4,\"1148\":1,\"1149\":1,\"1164\":1}}],[\"environment对象本身隶属于applicationcontext\",{\"1\":{\"1149\":1}}],[\"environment对象\",{\"1\":{\"945\":1}}],[\"environment\",{\"1\":{\"919\":4,\"921\":1,\"945\":1,\"1005\":6,\"1139\":7,\"1148\":10,\"1149\":14,\"1156\":2,\"1157\":2,\"1159\":1,\"1162\":1,\"1164\":6}}],[\"environment抽象\",{\"1\":{\"899\":1,\"900\":1,\"921\":1}}],[\"enforce\",{\"1\":{\"997\":1,\"1647\":1}}],[\"enumset\",{\"1\":{\"960\":1,\"1617\":5,\"1618\":3}}],[\"enum\",{\"1\":{\"952\":1,\"959\":1,\"1195\":1,\"1484\":1,\"1594\":2,\"1615\":1}}],[\"enters\",{\"1\":{\"1618\":1}}],[\"enterprise\",{\"1\":{\"908\":1,\"1683\":1}}],[\"entries\",{\"1\":{\"1615\":1}}],[\"entryat\",{\"1\":{\"1553\":1}}],[\"entrylist中唤醒线程\",{\"1\":{\"1483\":1}}],[\"entrylist不为空\",{\"1\":{\"1483\":1}}],[\"entrylist\",{\"1\":{\"1483\":1}}],[\"entry<class<\",{\"1\":{\"1648\":1}}],[\"entry<boolean\",{\"1\":{\"1618\":5}}],[\"entry<k\",{\"1\":{\"1546\":1,\"1554\":1}}],[\"entry<object\",{\"1\":{\"1084\":1,\"1091\":1}}],[\"entry<string\",{\"1\":{\"963\":1,\"985\":1,\"1029\":1,\"1031\":1,\"1648\":1}}],[\"entry>\",{\"1\":{\"989\":1}}],[\"entryset\",{\"1\":{\"963\":1,\"985\":1,\"1029\":1,\"1031\":1,\"1084\":1,\"1091\":1,\"1618\":1,\"1648\":2}}],[\"entry\",{\"1\":{\"467\":1,\"494\":1,\"963\":3,\"985\":3,\"1029\":3,\"1031\":3,\"1084\":3,\"1091\":3,\"1479\":1,\"1550\":3,\"1623\":2,\"1648\":3}}],[\"enbaleaspectjautoproxy的原理\",{\"0\":{\"831\":1}}],[\"endpoint负责底层sokcet通信\",{\"1\":{\"1688\":1}}],[\"endpoint负责提供字节流给processor\",{\"1\":{\"1687\":1}}],[\"endpoint和processor\",{\"1\":{\"1688\":1}}],[\"endtime\",{\"1\":{\"1612\":2}}],[\"endinclusive\",{\"1\":{\"1607\":3}}],[\"endexclusive\",{\"1\":{\"1607\":3}}],[\"endswith\",{\"1\":{\"1043\":2}}],[\"end\",{\"0\":{\"1993\":1},\"1\":{\"400\":2,\"404\":3,\"414\":2,\"419\":2,\"431\":3,\"467\":1,\"518\":2,\"519\":1,\"520\":1,\"523\":4,\"570\":1,\"571\":2,\"574\":2,\"578\":2,\"922\":2,\"1166\":1,\"1487\":2,\"1620\":1,\"1621\":2,\"1623\":9,\"1647\":5,\"1651\":3}}],[\"equivalence\",{\"1\":{\"1615\":1}}],[\"equivalent\",{\"1\":{\"996\":1,\"1608\":2,\"1615\":8}}],[\"equal\",{\"1\":{\"997\":1,\"1599\":4,\"1614\":1,\"1620\":2,\"1647\":1}}],[\"equals\",{\"1\":{\"996\":1,\"997\":1,\"1000\":1,\"1001\":1,\"1002\":2,\"1003\":1,\"1006\":1,\"1007\":1,\"1008\":1,\"1011\":1,\"1019\":2,\"1064\":1,\"1091\":2,\"1546\":1,\"1549\":3,\"1553\":1,\"1554\":1,\"1594\":1,\"1598\":1,\"1599\":7,\"1611\":2,\"1615\":2,\"1639\":2,\"1647\":3,\"1648\":2,\"1654\":1,\"1655\":1}}],[\"equality\",{\"1\":{\"519\":1,\"1599\":2,\"1615\":1}}],[\"eq\",{\"1\":{\"330\":1,\"509\":1,\"519\":1,\"553\":1}}],[\"ex2\",{\"1\":{\"1655\":5}}],[\"exhaust\",{\"1\":{\"1620\":1}}],[\"exhaustion\",{\"1\":{\"1619\":1}}],[\"exiting\",{\"1\":{\"1619\":1}}],[\"exit\",{\"1\":{\"1575\":1,\"1591\":2}}],[\"existing\",{\"1\":{\"1549\":1,\"1608\":2,\"1622\":3}}],[\"existingbean\",{\"1\":{\"1006\":2}}],[\"existingdefinition\",{\"1\":{\"996\":9}}],[\"exists\",{\"1\":{\"361\":2,\"362\":4,\"363\":2,\"506\":3,\"518\":1,\"523\":2,\"525\":1,\"569\":3,\"630\":1,\"997\":1,\"1620\":1,\"1647\":1}}],[\"exc\",{\"1\":{\"1575\":5}}],[\"except\",{\"1\":{\"1620\":1}}],[\"exceptfds\",{\"1\":{\"1569\":1}}],[\"exceptions\",{\"1\":{\"1595\":2,\"1599\":4,\"1619\":1,\"1620\":2}}],[\"exception\",{\"1\":{\"582\":1,\"909\":1,\"922\":2,\"930\":1,\"931\":1,\"933\":1,\"944\":2,\"946\":2,\"1007\":1,\"1012\":1,\"1013\":2,\"1040\":1,\"1041\":1,\"1043\":1,\"1075\":1,\"1100\":2,\"1103\":1,\"1175\":2,\"1521\":1,\"1533\":1,\"1534\":1,\"1573\":4,\"1574\":6,\"1575\":7,\"1587\":1,\"1588\":1,\"1595\":2,\"1597\":2,\"1598\":6,\"1599\":4,\"1610\":1,\"1617\":2,\"1619\":14,\"1620\":1,\"1644\":1,\"1647\":5,\"1651\":2,\"1655\":4,\"1657\":4}}],[\"excludefilter表示排除过滤器\",{\"1\":{\"1645\":1}}],[\"excludefilter和includefilter\",{\"0\":{\"1645\":1}}],[\"excludefilters\",{\"1\":{\"1135\":1,\"1645\":1,\"1647\":1}}],[\"exclusive\",{\"1\":{\"1490\":1}}],[\"exchange\",{\"1\":{\"1479\":8}}],[\"exactly\",{\"1\":{\"963\":1,\"1333\":1,\"1594\":2,\"1620\":3,\"1648\":1}}],[\"examples\",{\"1\":{\"1615\":1,\"1616\":1}}],[\"example\",{\"1\":{\"624\":1,\"1103\":1,\"1608\":1,\"1615\":3,\"1618\":2,\"1619\":6,\"1620\":13,\"1623\":1,\"1647\":2}}],[\"examined\",{\"1\":{\"420\":2,\"520\":2,\"553\":1,\"555\":2}}],[\"examined并不是完全相同的\",{\"1\":{\"322\":1}}],[\"examined表示这个语句执行过程中扫描了多少行\",{\"1\":{\"322\":1}}],[\"ex\",{\"1\":{\"922\":4,\"963\":1,\"964\":5,\"965\":1,\"996\":2,\"997\":2,\"1008\":2,\"1022\":2,\"1163\":2,\"1175\":4,\"1647\":37,\"1648\":7,\"1651\":6,\"1655\":11,\"1657\":2}}],[\"execsave\",{\"1\":{\"1531\":1}}],[\"execabort\",{\"1\":{\"580\":1}}],[\"exec\",{\"1\":{\"579\":5,\"580\":2,\"581\":2,\"582\":1}}],[\"executorcompletionservice<>\",{\"1\":{\"1517\":2}}],[\"executor工具类的不同方法按照我们的需求创建了不同的线程池\",{\"1\":{\"1409\":1}}],[\"executors\",{\"1\":{\"1123\":1,\"1517\":3,\"1521\":1,\"1534\":1,\"1535\":2}}],[\"executorservice\",{\"1\":{\"1060\":1,\"1123\":2,\"1517\":3,\"1528\":1,\"1534\":1,\"1535\":2}}],[\"executor\",{\"1\":{\"1123\":2,\"1517\":10}}],[\"executor的实现类\",{\"1\":{\"646\":1}}],[\"executapplicationcontext\",{\"1\":{\"1005\":2}}],[\"executions\",{\"1\":{\"1615\":1}}],[\"execution\",{\"1\":{\"519\":4,\"520\":8,\"624\":1,\"1608\":2,\"1619\":4,\"1621\":1}}],[\"executing\",{\"1\":{\"431\":1,\"1621\":1,\"1623\":1}}],[\"execute所属顶层接口时executor\",{\"1\":{\"1408\":1}}],[\"execute会直接抛出任务运行时的异常\",{\"1\":{\"1408\":1}}],[\"execute只能提交runnable类型的任务\",{\"1\":{\"1408\":1}}],[\"execute和submit都属于线程池的方法\",{\"1\":{\"1408\":1}}],[\"executebeanfactory\",{\"1\":{\"1005\":2,\"1006\":2}}],[\"executed\",{\"1\":{\"472\":1,\"474\":2}}],[\"execute\",{\"1\":{\"422\":1,\"1476\":1,\"1517\":3,\"1528\":1,\"1534\":1,\"1619\":1,\"1623\":1,\"1655\":1}}],[\"exposedobject\",{\"1\":{\"1647\":6}}],[\"export\",{\"1\":{\"1020\":1}}],[\"expensive\",{\"1\":{\"1618\":1,\"1620\":1}}],[\"expected\",{\"1\":{\"1597\":2,\"1620\":3,\"1623\":1}}],[\"expectedvalue\",{\"1\":{\"1479\":1}}],[\"expecting\",{\"1\":{\"1171\":1}}],[\"explicitly\",{\"1\":{\"1619\":1,\"1622\":1,\"1647\":1}}],[\"explicit\",{\"1\":{\"928\":1,\"1647\":1}}],[\"explain中的列\",{\"0\":{\"507\":1}}],[\"explainpartitions\",{\"1\":{\"506\":1}}],[\"explain详解\",{\"0\":{\"506\":1}}],[\"explain的结果也显示mysql预估需要访问10行数据\",{\"1\":{\"390\":1}}],[\"explain的结果\",{\"1\":{\"368\":1,\"404\":1}}],[\"explain的结果第二行的key=null表示的就是\",{\"1\":{\"368\":1}}],[\"explain的结果如下\",{\"1\":{\"356\":2,\"401\":1,\"403\":1,\"407\":1,\"418\":1}}],[\"explain的详细过程如下\",{\"1\":{\"368\":1}}],[\"explain能干嘛\",{\"1\":{\"329\":1}}],[\"explain怎么使用\",{\"1\":{\"329\":1}}],[\"explain是什么\",{\"1\":{\"329\":1}}],[\"explain\",{\"0\":{\"329\":1,\"330\":1},\"1\":{\"329\":3,\"330\":5,\"361\":1,\"370\":6,\"372\":2,\"373\":2,\"374\":2,\"375\":12,\"376\":3,\"378\":15,\"390\":2,\"430\":2,\"509\":5,\"522\":1,\"524\":1,\"525\":1,\"526\":4,\"549\":2,\"553\":1,\"555\":1}}],[\"expressions\",{\"1\":{\"1594\":2,\"1619\":1}}],[\"expression\",{\"1\":{\"1073\":1,\"1619\":1,\"1683\":1}}],[\"expresson\",{\"1\":{\"903\":1}}],[\"express\",{\"1\":{\"892\":1}}],[\"exp让mysql查询优化器重新加载我们更改过的数据\",{\"1\":{\"559\":1}}],[\"exp2\",{\"1\":{\"554\":5,\"555\":2}}],[\"exp`\",{\"1\":{\"553\":7}}],[\"exp表关于行数的统计数据更改一下\",{\"1\":{\"559\":1}}],[\"exp表为例\",{\"1\":{\"558\":1}}],[\"exp表的统计数据\",{\"1\":{\"559\":1}}],[\"exp表的其他索引一共占用81个页面\",{\"1\":{\"558\":1}}],[\"exp表的聚簇索引占用97页面\",{\"1\":{\"558\":1}}],[\"exp表的idx\",{\"1\":{\"553\":1}}],[\"exp表中大约有10350条记录\",{\"1\":{\"558\":1}}],[\"exp表实际由10567条记录\",{\"1\":{\"548\":1}}],[\"exp的各个索引的统计数据可以这么写\",{\"1\":{\"553\":1}}],[\"exp使用默认16kb的页面大小\",{\"1\":{\"548\":1}}],[\"expiretime\",{\"1\":{\"1288\":2}}],[\"expire\",{\"1\":{\"544\":5,\"547\":8,\"549\":19,\"551\":5,\"553\":9,\"554\":9,\"555\":38,\"558\":3,\"569\":2,\"1288\":3,\"1289\":1}}],[\"exp\",{\"1\":{\"544\":1,\"547\":1,\"548\":1,\"549\":2,\"553\":5,\"554\":5,\"555\":2,\"558\":1,\"559\":1}}],[\"expanded\",{\"1\":{\"519\":1}}],[\"extclassloader\",{\"1\":{\"1432\":2,\"1691\":1}}],[\"extern\",{\"1\":{\"1479\":1}}],[\"externalconfigurationdependencysourcedemo\",{\"1\":{\"978\":4}}],[\"extension\",{\"1\":{\"1623\":1}}],[\"extensions\",{\"1\":{\"1020\":1}}],[\"extensible\",{\"0\":{\"1036\":1}}],[\"extensiblexmlauthoringdemo\",{\"1\":{\"1030\":1}}],[\"extends\",{\"1\":{\"917\":1,\"941\":2,\"963\":1,\"964\":1,\"965\":3,\"966\":1,\"967\":1,\"1025\":1,\"1027\":2,\"1030\":2,\"1082\":1,\"1084\":1,\"1100\":1,\"1108\":1,\"1119\":1,\"1412\":1,\"1500\":1,\"1598\":6,\"1601\":2,\"1607\":1,\"1609\":2,\"1613\":1,\"1617\":1,\"1618\":11,\"1619\":3,\"1620\":4,\"1621\":8,\"1622\":3,\"1623\":4,\"1638\":2,\"1648\":1}}],[\"extended\",{\"1\":{\"509\":1}}],[\"extracturitemplatevariables\",{\"1\":{\"1043\":1}}],[\"extractpathwithinpattern\",{\"1\":{\"1043\":1}}],[\"extra字段显示using\",{\"1\":{\"420\":1}}],[\"extra字段多了using\",{\"1\":{\"404\":1}}],[\"extra字段里面有没有出现\",{\"1\":{\"403\":1}}],[\"extra字段的using\",{\"1\":{\"366\":1}}],[\"extra字段中没有using\",{\"1\":{\"356\":1}}],[\"extra这个字段中的\",{\"1\":{\"354\":1}}],[\"extra\",{\"1\":{\"329\":1,\"330\":8,\"361\":1,\"390\":2}}],[\"ejb\",{\"0\":{\"1589\":1},\"1\":{\"273\":1,\"908\":1,\"910\":1,\"912\":1,\"966\":2,\"1110\":2}}],[\"ee7\",{\"1\":{\"897\":1}}],[\"ee6和7\",{\"1\":{\"897\":1}}],[\"eeee\",{\"1\":{\"468\":3}}],[\"ee\",{\"1\":{\"273\":1,\"336\":1,\"900\":1,\"908\":1,\"1683\":1}}],[\"ee简介\",{\"0\":{\"273\":1}}],[\"est\",{\"1\":{\"1622\":1}}],[\"estimate方法估算的值通常而言也是有用的\",{\"1\":{\"1620\":1}}],[\"estimates\",{\"1\":{\"1620\":1}}],[\"estimatesize\",{\"1\":{\"1620\":12}}],[\"estimate估算就可能是不精确的\",{\"1\":{\"1620\":1}}],[\"estimate\",{\"1\":{\"1620\":6}}],[\"estimated\",{\"1\":{\"1620\":3,\"1621\":1}}],[\"estimation\",{\"1\":{\"519\":2}}],[\"essence\",{\"1\":{\"1595\":1}}],[\"es生态\",{\"1\":{\"1257\":1}}],[\"es生成id\",{\"1\":{\"306\":1}}],[\"es可以用在大数量的搜索场景下\",{\"1\":{\"1254\":1}}],[\"es包含了一些核心概念\",{\"1\":{\"1254\":1}}],[\"es根据数据类型\",{\"1\":{\"309\":1}}],[\"es会自动根据文档信息\",{\"1\":{\"309\":1}}],[\"es中mapping映射可以分为动态映射和静态映射\",{\"1\":{\"309\":1}}],[\"es的参数\",{\"1\":{\"1257\":1}}],[\"es的新版本也支持sql\",{\"1\":{\"1254\":1}}],[\"es的json文档中的每个字段\",{\"1\":{\"308\":1}}],[\"es的批量查询可以用mget和msearch两种\",{\"1\":{\"307\":1}}],[\"es首先根据它的前缀或者后缀迅速缩小关键词在term\",{\"1\":{\"308\":1}}],[\"es实际的索引结构如下图所示\",{\"1\":{\"308\":1}}],[\"es在term的基础上利用term的前缀或者后缀构建了term\",{\"1\":{\"308\":1}}],[\"es将term与其对应的文档列表建立一种映射关系\",{\"1\":{\"308\":1}}],[\"es大法必修内功\",{\"1\":{\"307\":1}}],[\"es文档批量操作\",{\"0\":{\"307\":1}}],[\"es是面向文档的\",{\"1\":{\"304\":1}}],[\"es\",{\"1\":{\"301\":1,\"305\":3,\"306\":27,\"307\":4,\"1506\":4,\"1528\":2,\"1534\":3}}],[\"es有以下应用场景\",{\"1\":{\"301\":1}}],[\"es起源于lucene\",{\"1\":{\"301\":1}}],[\"es部署时\",{\"0\":{\"175\":1,\"1257\":1}}],[\"es写入数据与查询数据的原理\",{\"0\":{\"174\":1,\"1256\":1}}],[\"es了解多少\",{\"0\":{\"172\":1,\"1254\":1}}],[\"多列集合\",{\"0\":{\"1540\":1}}],[\"多列索引的结构\",{\"1\":{\"505\":1}}],[\"多生产者\",{\"1\":{\"1520\":1}}],[\"多核cpu自旋才能发挥优势\",{\"1\":{\"1485\":1}}],[\"多次发起同一个请求\",{\"1\":{\"1248\":1}}],[\"多次查询的结果不一致\",{\"1\":{\"1261\":1}}],[\"多次查询s1表总共的成本\",{\"1\":{\"555\":1}}],[\"多次查询被驱动表的成本\",{\"1\":{\"554\":1}}],[\"多处同时登录\",{\"1\":{\"1204\":1}}],[\"多处使用\",{\"1\":{\"1204\":1}}],[\"多配置属性源\",{\"1\":{\"1153\":2}}],[\"多例和单例比较的示例\",{\"1\":{\"985\":1}}],[\"多例模式的示意图\",{\"1\":{\"985\":1}}],[\"多以来\",{\"1\":{\"958\":1}}],[\"多语言的支持\",{\"0\":{\"680\":1}}],[\"多协议消息\",{\"0\":{\"671\":1}}],[\"多的slave因为replication而不可用\",{\"1\":{\"624\":1}}],[\"多的时候只能估算\",{\"1\":{\"553\":1}}],[\"多哨兵模式\",{\"0\":{\"621\":1}}],[\"多路复用\",{\"0\":{\"603\":1},\"1\":{\"603\":1}}],[\"多人在线聊天室\",{\"1\":{\"601\":1}}],[\"多个连接器\",{\"1\":{\"1683\":1}}],[\"多个线程就会操作同一个中间结果容器\",{\"1\":{\"1617\":1}}],[\"多个线程同时读写同一共享变量存在并发问题\",{\"1\":{\"1526\":1}}],[\"多个线程同时读一个资源没有任何问题\",{\"1\":{\"1498\":1}}],[\"多个线程可以同时执行\",{\"1\":{\"1490\":1}}],[\"多个线程在临界区内执行\",{\"1\":{\"1482\":1}}],[\"多个线程读共享其实也没有问题\",{\"1\":{\"1482\":1}}],[\"多个线程读的场景\",{\"1\":{\"1384\":1}}],[\"多个线程操作的话\",{\"1\":{\"583\":1}}],[\"多个对象之间存在循环的引用关系\",{\"1\":{\"1237\":1}}],[\"多个field字段\",{\"1\":{\"573\":1}}],[\"多个成员坐标\",{\"1\":{\"576\":1}}],[\"多个成员\",{\"1\":{\"572\":2,\"574\":1}}],[\"多集合操作中若只有一个参数默认和自身进行运算\",{\"1\":{\"572\":1}}],[\"多种内部编码实现可以在不同场景下发挥各自的优势\",{\"1\":{\"569\":1}}],[\"多样的数据类型\",{\"1\":{\"566\":1}}],[\"多用在排序操作上\",{\"1\":{\"557\":1}}],[\"多表连接查询的成本分析首先要考虑多表连接时可能产生多少种连接顺序\",{\"1\":{\"556\":1}}],[\"多表连接的成本分析\",{\"0\":{\"556\":1}}],[\"多表关联时返回全部列\",{\"0\":{\"384\":1}}],[\"多版本并发控制\",{\"1\":{\"541\":1}}],[\"多一次交互\",{\"1\":{\"435\":1}}],[\"多叉树就是每个节点有多个儿子\",{\"1\":{\"334\":1}}],[\"多线程分工模式\",{\"0\":{\"1532\":1}}],[\"多线程版本的if模式\",{\"0\":{\"1529\":1}}],[\"多线程竞争锁会先存到这个单向链表中\",{\"1\":{\"1483\":1}}],[\"多线程环境下可以使用java\",{\"1\":{\"1370\":1}}],[\"多线程put的时候可能导致元素丢失\",{\"1\":{\"1364\":1}}],[\"多线程扩容\",{\"1\":{\"1364\":1}}],[\"多线程\",{\"1\":{\"300\":1}}],[\"多大数据量需要进行分库分表\",{\"0\":{\"161\":1,\"1270\":1}}],[\"多态是值程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定\",{\"1\":{\"1340\":1}}],[\"多态\",{\"0\":{\"11\":1,\"1340\":1},\"1\":{\"1136\":1,\"1340\":1}}],[\"m本身是<k\",{\"1\":{\"1618\":1}}],[\"m>\",{\"1\":{\"1618\":2}}],[\"mp分别是\",{\"1\":{\"1479\":1}}],[\"mp的值存入任意的通用寄存器\",{\"1\":{\"1479\":1}}],[\"mp\",{\"1\":{\"1479\":6}}],[\"mp3播放器里的一首歌\",{\"1\":{\"304\":1}}],[\"mbean\",{\"1\":{\"1020\":3,\"1172\":1}}],[\"mbdtouse\",{\"1\":{\"1000\":1,\"1647\":9}}],[\"mbd\",{\"1\":{\"997\":16,\"1001\":1,\"1003\":1,\"1007\":7,\"1008\":8,\"1647\":72,\"1649\":2,\"1650\":18}}],[\"mtea\",{\"1\":{\"953\":3}}],[\"much\",{\"1\":{\"1623\":1}}],[\"mutable\",{\"1\":{\"1608\":5,\"1615\":8,\"1616\":1,\"1620\":5}}],[\"mutablereduction\",{\"1\":{\"1608\":1}}],[\"mutablepropertysources\",{\"1\":{\"1153\":1,\"1156\":1}}],[\"mutablepropertyvalue\",{\"1\":{\"1071\":1}}],[\"mutablepropertyvalues\",{\"1\":{\"927\":2,\"1003\":4,\"1019\":1,\"1072\":4,\"1647\":2}}],[\"mutex\",{\"1\":{\"1283\":1,\"1530\":1}}],[\"must\",{\"1\":{\"996\":2,\"1061\":1,\"1608\":4,\"1615\":9,\"1617\":1,\"1619\":3,\"1620\":10,\"1621\":2,\"1623\":6,\"1647\":1,\"1658\":3}}],[\"multithreadeventloopgroup\",{\"1\":{\"1227\":1}}],[\"multicastevent\",{\"1\":{\"1170\":1}}],[\"multicaster\",{\"1\":{\"922\":1,\"1121\":4,\"1123\":1,\"1162\":1,\"1168\":4,\"1170\":1,\"1647\":1}}],[\"multivaluemap<string\",{\"1\":{\"1023\":1,\"1139\":1}}],[\"multiple\",{\"1\":{\"963\":1,\"1608\":2,\"1615\":1,\"1617\":1,\"1619\":1,\"1620\":1,\"1648\":3}}],[\"multiplebeans\",{\"1\":{\"963\":3,\"1648\":3}}],[\"multielementdescriptor\",{\"1\":{\"963\":3,\"1648\":1}}],[\"multi\",{\"0\":{\"404\":1},\"1\":{\"404\":1,\"540\":1,\"579\":4,\"580\":2,\"581\":2,\"582\":6}}],[\"m9\",{\"1\":{\"574\":2}}],[\"m7\",{\"1\":{\"574\":3}}],[\"m6\",{\"1\":{\"572\":7}}],[\"m5\",{\"1\":{\"572\":5}}],[\"m4\",{\"1\":{\"572\":11,\"574\":4}}],[\"m3\",{\"1\":{\"572\":11,\"574\":9}}],[\"m2\",{\"1\":{\"572\":11,\"574\":10}}],[\"m1~m4\",{\"1\":{\"572\":1}}],[\"m1\",{\"1\":{\"572\":10,\"574\":8}}],[\"ms\",{\"1\":{\"1487\":1}}],[\"msetnx\",{\"1\":{\"570\":2}}],[\"mset\",{\"1\":{\"570\":2}}],[\"msearch\",{\"1\":{\"307\":3}}],[\"msearch可以通过字段查询来进行一个批量的查找\",{\"1\":{\"307\":1}}],[\"msg\",{\"1\":{\"570\":11,\"1622\":5,\"1623\":1}}],[\"mmu内存管理模型\",{\"1\":{\"1689\":1}}],[\"mmap\",{\"1\":{\"1585\":2,\"1586\":1}}],[\"mmap内存映射的拷贝\",{\"1\":{\"1581\":1}}],[\"mmap内存映射拷贝流程\",{\"0\":{\"1581\":1},\"1\":{\"1581\":1}}],[\"mmap和\",{\"1\":{\"1331\":1}}],[\"mmap适合比较小的文件\",{\"1\":{\"1330\":1,\"1331\":1}}],[\"mmap方式通过mappedbytebuffer对象进行操作\",{\"1\":{\"1330\":1,\"1331\":1}}],[\"mm\",{\"1\":{\"529\":6,\"1053\":2,\"1528\":2,\"1654\":6}}],[\"microservice\",{\"1\":{\"1664\":1}}],[\"missing\",{\"1\":{\"1647\":1}}],[\"misc\",{\"1\":{\"1432\":3,\"1663\":3}}],[\"mid\",{\"1\":{\"1620\":4}}],[\"millis\",{\"1\":{\"1612\":2}}],[\"milliseconds\",{\"1\":{\"570\":1,\"624\":2}}],[\"might\",{\"1\":{\"922\":1,\"997\":2,\"1617\":1,\"1619\":2,\"1623\":1,\"1647\":4,\"1651\":1,\"1655\":1}}],[\"mi\",{\"1\":{\"576\":1}}],[\"mixed\",{\"0\":{\"1752\":1},\"1\":{\"1434\":1}}],[\"mixedsqlnode\",{\"1\":{\"645\":2}}],[\"mixed格式可以利用statement格式的优点\",{\"1\":{\"454\":1}}],[\"mixedde的时候\",{\"1\":{\"413\":1}}],[\"minby\",{\"1\":{\"1601\":3,\"1616\":2}}],[\"mincapacity\",{\"1\":{\"1475\":2}}],[\"minor\",{\"1\":{\"1434\":1}}],[\"minimum\",{\"1\":{\"1061\":4}}],[\"min\",{\"1\":{\"422\":1,\"479\":1,\"509\":1,\"574\":9,\"1061\":1,\"1610\":2,\"1614\":3,\"1615\":1}}],[\"m的serverid\",{\"1\":{\"413\":2}}],[\"m的时候\",{\"1\":{\"347\":1}}],[\"mdl的作用是\",{\"1\":{\"441\":1}}],[\"mdl不需要显式使用\",{\"1\":{\"441\":1}}],[\"md\",{\"1\":{\"404\":1}}],[\"mrr=on\",{\"1\":{\"405\":1}}],[\"mrr的优势就用不上了\",{\"1\":{\"405\":1}}],[\"mrr能够提升性能的核心在于\",{\"1\":{\"404\":1}}],[\"mrr\",{\"1\":{\"404\":2,\"405\":1,\"519\":1}}],[\"m中\",{\"1\":{\"403\":1}}],[\"m次\",{\"1\":{\"403\":1}}],[\"m\",{\"1\":{\"403\":1,\"406\":1,\"411\":2,\"416\":6,\"418\":2,\"422\":3,\"468\":2,\"528\":1,\"542\":9,\"576\":2,\"577\":1,\"1480\":3,\"1554\":3,\"1618\":5}}],[\"mechanism\",{\"1\":{\"1623\":1}}],[\"mechanics\",{\"1\":{\"1620\":1,\"1621\":1}}],[\"means\",{\"1\":{\"1619\":1,\"1647\":1}}],[\"meanings\",{\"1\":{\"1620\":1}}],[\"meaning\",{\"1\":{\"1617\":1}}],[\"meantime\",{\"1\":{\"1165\":1}}],[\"meant\",{\"1\":{\"963\":1}}],[\"meeting\",{\"1\":{\"1594\":3}}],[\"mesa模型的wait\",{\"1\":{\"1483\":1}}],[\"message模式是完全没有问题的\",{\"1\":{\"1533\":1}}],[\"message模式就完全没有问题\",{\"1\":{\"1533\":1}}],[\"message模式作为一种最简单的分工方案\",{\"1\":{\"1533\":1}}],[\"message模式\",{\"0\":{\"1533\":1}}],[\"messagecodesresolver\",{\"1\":{\"1070\":1}}],[\"message的内建依赖\",{\"0\":{\"1055\":1}}],[\"messageformat组合messagesource实现\",{\"1\":{\"1054\":2}}],[\"messageformatpattern\",{\"1\":{\"1053\":6}}],[\"messageformatdemo\",{\"1\":{\"1053\":2}}],[\"messageformat\",{\"1\":{\"1053\":14}}],[\"message\",{\"1\":{\"597\":1,\"598\":2,\"922\":1,\"943\":2,\"1055\":4,\"1056\":3,\"1064\":2,\"1119\":2,\"1166\":1,\"1167\":4,\"1326\":1,\"1533\":1,\"1573\":5,\"1574\":9,\"1575\":11,\"1594\":2,\"1647\":2,\"1985\":1}}],[\"messagesource内建依赖\",{\"1\":{\"1167\":1}}],[\"messagesource内建bean可能来源\",{\"1\":{\"1055\":1}}],[\"messagesource开箱实现\",{\"0\":{\"1054\":1}}],[\"messagesourceaware\",{\"1\":{\"957\":1,\"1005\":3,\"1164\":1}}],[\"messagesource对象\",{\"1\":{\"945\":1}}],[\"messagesource\",{\"1\":{\"945\":1,\"973\":1,\"1050\":1,\"1055\":16,\"1056\":6,\"1058\":1,\"1063\":5,\"1064\":3,\"1164\":1,\"1167\":14,\"1637\":1}}],[\"messages\",{\"1\":{\"393\":2,\"598\":1}}],[\"meituan\",{\"1\":{\"1356\":1}}],[\"menulistener\",{\"1\":{\"1109\":1}}],[\"menuevent\",{\"1\":{\"1109\":1}}],[\"merger\",{\"1\":{\"1618\":6}}],[\"merges\",{\"1\":{\"1615\":1}}],[\"merge\",{\"1\":{\"1020\":2,\"1615\":1,\"1618\":1}}],[\"merged\",{\"1\":{\"997\":6,\"1647\":8}}],[\"mergedbeandefinitions\",{\"1\":{\"997\":3,\"1647\":3}}],[\"mergedbeandefinitiondemo\",{\"1\":{\"997\":1}}],[\"mergedbeandefinitionpostprocessor\",{\"1\":{\"967\":1,\"1166\":3,\"1647\":1,\"1648\":1}}],[\"mergedannotations\",{\"1\":{\"964\":2,\"965\":2}}],[\"mergedannotation<\",{\"1\":{\"964\":3,\"965\":2,\"1648\":2}}],[\"merging\",{\"1\":{\"997\":1,\"1618\":1,\"1647\":1}}],[\"methodidentification\",{\"1\":{\"1655\":1}}],[\"methodinterceptor\",{\"1\":{\"1654\":3}}],[\"methodmatcher\",{\"1\":{\"1654\":1}}],[\"methodbeforeadvice\",{\"1\":{\"1654\":1}}],[\"methodproxy\",{\"1\":{\"1654\":4}}],[\"methodparameter\",{\"1\":{\"1102\":1,\"1655\":1}}],[\"methodreferencedemo\",{\"1\":{\"1602\":1,\"1603\":2,\"1604\":2,\"1605\":2,\"1606\":10}}],[\"method3\",{\"1\":{\"1598\":1}}],[\"method2\",{\"1\":{\"1598\":1}}],[\"method1\",{\"1\":{\"1598\":1}}],[\"method和static\",{\"1\":{\"1594\":1}}],[\"methods\",{\"1\":{\"1594\":4,\"1615\":2,\"1619\":1,\"1620\":7,\"1621\":4,\"1623\":5,\"1648\":2}}],[\"methoddescriptor\",{\"1\":{\"1075\":2}}],[\"methodvalidationpostprocessor\",{\"1\":{\"1065\":2}}],[\"methodnamecomparator\",{\"1\":{\"1654\":2}}],[\"methodname\",{\"1\":{\"963\":1,\"1100\":4}}],[\"method=\",{\"1\":{\"930\":2,\"931\":1,\"1012\":2}}],[\"method\",{\"1\":{\"927\":2,\"930\":5,\"961\":3,\"967\":2,\"1008\":1,\"1020\":2,\"1073\":1,\"1100\":4,\"1102\":1,\"1165\":1,\"1234\":2,\"1457\":1,\"1560\":1,\"1593\":1,\"1594\":12,\"1597\":2,\"1598\":3,\"1599\":2,\"1600\":1,\"1601\":2,\"1608\":2,\"1614\":1,\"1619\":4,\"1620\":10,\"1622\":1,\"1623\":12,\"1647\":3,\"1648\":11,\"1654\":21,\"1655\":13}}],[\"metaspacesize\",{\"1\":{\"1664\":1}}],[\"metaspacesize=n和\",{\"1\":{\"1664\":1}}],[\"metaspacesize=256m\",{\"1\":{\"1664\":1}}],[\"metaspace\",{\"1\":{\"1457\":1}}],[\"metadatareader表示类的元数据读取器\",{\"1\":{\"1646\":1}}],[\"metadatareader\",{\"0\":{\"1646\":1},\"1\":{\"1646\":4,\"1647\":9}}],[\"metadatareaderfactory\",{\"1\":{\"1134\":1}}],[\"metadata\",{\"1\":{\"441\":1,\"921\":1,\"922\":1,\"964\":4,\"997\":1,\"1023\":2,\"1030\":2,\"1139\":3,\"1171\":1,\"1172\":1,\"1647\":7,\"1648\":4,\"1651\":1}}],[\"meta\",{\"1\":{\"439\":1,\"917\":1,\"918\":1,\"919\":1,\"921\":1,\"930\":3,\"953\":2,\"954\":3,\"955\":1,\"961\":3,\"962\":1,\"963\":1,\"978\":1,\"994\":1,\"997\":1,\"1000\":1,\"1001\":2,\"1005\":4,\"1006\":2,\"1011\":2,\"1022\":1,\"1029\":3,\"1030\":1,\"1031\":1,\"1032\":3,\"1044\":2,\"1048\":2,\"1065\":1,\"1084\":1,\"1132\":1,\"1133\":1,\"1146\":3}}],[\"member\",{\"1\":{\"572\":2,\"574\":4,\"576\":4,\"964\":1}}],[\"member2\",{\"1\":{\"572\":2,\"574\":2,\"576\":2}}],[\"member1\",{\"1\":{\"572\":2,\"574\":2,\"576\":2}}],[\"memory引擎不是索引组织表\",{\"1\":{\"420\":1}}],[\"memory\",{\"1\":{\"409\":1,\"431\":1,\"557\":3,\"1451\":2,\"1457\":1,\"1479\":1}}],[\"memory等多个存储引擎\",{\"1\":{\"317\":1}}],[\"medium\",{\"1\":{\"1053\":1}}],[\"mediumtext\",{\"1\":{\"530\":1}}],[\"mediumblob\",{\"1\":{\"530\":1}}],[\"mediumint\",{\"1\":{\"528\":1}}],[\"mooc的课程等\",{\"1\":{\"1968\":1}}],[\"mostly\",{\"1\":{\"1621\":1}}],[\"most\",{\"1\":{\"1333\":1,\"1597\":2,\"1619\":3,\"1621\":2}}],[\"moving\",{\"1\":{\"1166\":1}}],[\"moved\",{\"1\":{\"1554\":1}}],[\"move\",{\"1\":{\"569\":2}}],[\"mouselistener\",{\"1\":{\"1109\":1}}],[\"mouseevent\",{\"1\":{\"1109\":1}}],[\"mock\",{\"1\":{\"896\":1}}],[\"more\",{\"1\":{\"429\":1,\"1619\":3,\"1620\":2,\"1621\":3,\"1623\":3}}],[\"mono\",{\"1\":{\"1655\":1}}],[\"monitor机制\",{\"0\":{\"1483\":1}}],[\"monitor\",{\"1\":{\"621\":1,\"624\":2,\"1483\":1,\"1484\":1}}],[\"money=1000\",{\"1\":{\"1201\":2}}],[\"money上锁\",{\"1\":{\"581\":1}}],[\"money\",{\"1\":{\"581\":7,\"1092\":1}}],[\"month\",{\"1\":{\"366\":1,\"393\":2}}],[\"mongodb入门\",{\"0\":{\"315\":1}}],[\"mongodb\",{\"0\":{\"314\":1}}],[\"mod\",{\"1\":{\"1550\":1}}],[\"modcount\",{\"1\":{\"1546\":1}}],[\"modules\",{\"1\":{\"899\":1,\"900\":1}}],[\"modifications\",{\"1\":{\"1620\":2}}],[\"modification\",{\"1\":{\"1619\":1}}],[\"modifiable\",{\"1\":{\"1615\":1}}],[\"modifier\",{\"1\":{\"964\":1,\"1648\":2,\"1650\":1}}],[\"modified<=\",{\"1\":{\"454\":1}}],[\"modified<\",{\"1\":{\"366\":3}}],[\"modified字段加上了month\",{\"1\":{\"366\":1}}],[\"modified字段上已经创建了索引\",{\"1\":{\"366\":1}}],[\"modified这个索引\",{\"1\":{\"366\":1}}],[\"modified更小\",{\"1\":{\"366\":1}}],[\"modified=now\",{\"1\":{\"478\":1}}],[\"modified=\",{\"1\":{\"366\":2,\"454\":1}}],[\"modified索引的示意图\",{\"1\":{\"366\":1}}],[\"modified`\",{\"1\":{\"366\":3,\"454\":3,\"478\":1}}],[\"modified\",{\"1\":{\"366\":8,\"411\":5,\"454\":2,\"478\":2,\"1619\":1}}],[\"modifying\",{\"1\":{\"1619\":1}}],[\"modify\",{\"1\":{\"368\":1,\"996\":1,\"1619\":1,\"1647\":2}}],[\"modelandview\",{\"1\":{\"1657\":3}}],[\"modes\",{\"1\":{\"952\":1}}],[\"mode设置为1\",{\"1\":{\"492\":1}}],[\"mode设置为2\",{\"1\":{\"492\":1}}],[\"mode\",{\"1\":{\"492\":1,\"520\":2,\"541\":1,\"927\":2,\"1263\":1,\"1619\":2}}],[\"mode=on和enforce\",{\"1\":{\"468\":1}}],[\"mode里面显式的是rowid排序\",{\"1\":{\"421\":1}}],[\"mode里面的packed\",{\"1\":{\"354\":1}}],[\"mode变成了<sort\",{\"1\":{\"355\":1}}],[\"m是16\",{\"1\":{\"347\":1}}],[\"m是10\",{\"1\":{\"347\":1}}],[\"mget\",{\"1\":{\"307\":4,\"570\":2}}],[\"mask\",{\"1\":{\"1621\":1,\"1622\":1}}],[\"master是否为0更精确\",{\"1\":{\"472\":1}}],[\"master是否已经等于0\",{\"1\":{\"472\":1}}],[\"master=0之后\",{\"1\":{\"459\":1}}],[\"master的单位是秒\",{\"1\":{\"472\":1}}],[\"master的简称\",{\"1\":{\"458\":1}}],[\"master的值足够小\",{\"1\":{\"458\":1}}],[\"master的值\",{\"1\":{\"458\":1}}],[\"master计算的时候会自动扣掉这个差值\",{\"1\":{\"457\":1}}],[\"master来作为主备延迟的值\",{\"1\":{\"457\":1}}],[\"master这个参数计算的就是t3\",{\"1\":{\"457\":1}}],[\"master\",{\"1\":{\"454\":3,\"457\":2,\"458\":1,\"467\":8,\"468\":8,\"472\":7,\"473\":3,\"474\":1,\"485\":2,\"486\":2,\"606\":1,\"609\":4,\"624\":1}}],[\"master命令执行实例a\",{\"1\":{\"468\":1}}],[\"master命令\",{\"1\":{\"453\":1,\"467\":3}}],[\"made\",{\"1\":{\"1620\":2}}],[\"major\",{\"1\":{\"1434\":1}}],[\"mac\",{\"1\":{\"1337\":1}}],[\"macosx\",{\"1\":{\"603\":1}}],[\"manually\",{\"1\":{\"1647\":1}}],[\"manipulating\",{\"1\":{\"1621\":1}}],[\"manipulate\",{\"1\":{\"1619\":1}}],[\"manner\",{\"1\":{\"1620\":1}}],[\"mangledfactory\",{\"1\":{\"1618\":3}}],[\"many\",{\"1\":{\"1608\":2,\"1615\":2,\"1620\":2}}],[\"mandatory\",{\"1\":{\"1238\":1}}],[\"manages\",{\"1\":{\"1620\":1,\"1621\":1}}],[\"managed\",{\"1\":{\"1620\":1}}],[\"manage\",{\"1\":{\"1615\":1,\"1623\":1}}],[\"management\",{\"1\":{\"1020\":1,\"1619\":2}}],[\"manager\",{\"1\":{\"370\":4,\"371\":2,\"372\":1,\"373\":2,\"510\":1,\"518\":2}}],[\"makesink\",{\"1\":{\"1617\":1}}],[\"makeref方法的说明\",{\"1\":{\"1623\":1}}],[\"makeref\",{\"1\":{\"1617\":2,\"1622\":1,\"1623\":1}}],[\"make\",{\"1\":{\"1055\":1,\"1167\":1,\"1647\":2,\"1650\":1}}],[\"makeaccessible\",{\"1\":{\"964\":1}}],[\"maven中内置变量\",{\"0\":{\"886\":1}}],[\"maven\",{\"0\":{\"880\":1,\"881\":1,\"882\":1,\"1980\":1},\"1\":{\"899\":1,\"900\":1,\"1980\":3}}],[\"maintain\",{\"1\":{\"1620\":1}}],[\"maintains\",{\"1\":{\"1620\":1}}],[\"mainly\",{\"1\":{\"1480\":1}}],[\"main\",{\"1\":{\"582\":2,\"909\":1,\"917\":1,\"918\":1,\"919\":1,\"921\":2,\"927\":1,\"929\":1,\"930\":3,\"931\":1,\"933\":1,\"934\":1,\"936\":1,\"940\":1,\"943\":1,\"944\":1,\"946\":3,\"953\":3,\"954\":1,\"955\":1,\"957\":1,\"961\":3,\"962\":1,\"963\":1,\"973\":1,\"977\":1,\"978\":1,\"985\":2,\"989\":1,\"994\":1,\"995\":1,\"997\":1,\"1000\":1,\"1001\":1,\"1005\":1,\"1006\":1,\"1011\":1,\"1019\":1,\"1022\":1,\"1029\":1,\"1030\":1,\"1031\":1,\"1032\":2,\"1040\":2,\"1041\":2,\"1043\":2,\"1044\":1,\"1045\":1,\"1053\":2,\"1056\":1,\"1063\":1,\"1064\":1,\"1065\":1,\"1072\":2,\"1075\":1,\"1082\":1,\"1084\":1,\"1099\":1,\"1100\":1,\"1103\":1,\"1108\":1,\"1112\":1,\"1113\":1,\"1116\":1,\"1119\":1,\"1120\":1,\"1123\":2,\"1134\":1,\"1138\":1,\"1139\":1,\"1146\":1,\"1148\":1,\"1149\":1,\"1156\":1,\"1174\":1,\"1175\":1,\"1181\":1,\"1182\":1,\"1184\":1,\"1365\":1,\"1387\":1,\"1404\":3,\"1479\":1,\"1487\":1,\"1521\":1,\"1535\":1,\"1551\":1,\"1587\":1,\"1588\":1,\"1591\":3,\"1592\":1,\"1593\":6,\"1594\":1,\"1595\":6,\"1597\":2,\"1598\":6,\"1599\":4,\"1600\":4,\"1601\":1,\"1602\":1,\"1603\":2,\"1604\":2,\"1605\":2,\"1606\":2,\"1607\":10,\"1608\":3,\"1609\":11,\"1610\":9,\"1612\":3,\"1613\":1,\"1614\":1,\"1615\":1,\"1617\":17,\"1619\":8,\"1620\":2,\"1646\":1,\"1654\":2}}],[\"mairadb已经合并了alisql的这个功能\",{\"1\":{\"441\":1}}],[\"matter\",{\"1\":{\"1620\":1}}],[\"math\",{\"1\":{\"1227\":1,\"1614\":1}}],[\"mathscore\",{\"1\":{\"574\":2}}],[\"mathscore=>\",{\"1\":{\"574\":1}}],[\"matchop\",{\"1\":{\"1624\":1}}],[\"matching\",{\"1\":{\"1164\":1,\"1171\":1,\"1647\":1,\"1655\":2}}],[\"matchingbeans\",{\"1\":{\"963\":25,\"1648\":7}}],[\"matchstart\",{\"1\":{\"1043\":1}}],[\"matches\",{\"1\":{\"1023\":1,\"1091\":1,\"1139\":2,\"1599\":2,\"1639\":1,\"1648\":1,\"1654\":4}}],[\"match\",{\"1\":{\"306\":2,\"307\":2,\"308\":1,\"429\":1,\"572\":1,\"573\":1,\"574\":1,\"963\":1,\"1043\":1,\"1647\":2,\"1648\":1,\"1654\":4}}],[\"may\",{\"1\":{\"519\":1,\"1599\":2,\"1608\":2,\"1615\":4,\"1618\":1,\"1619\":9,\"1620\":16,\"1622\":1,\"1623\":4}}],[\"martin\",{\"1\":{\"905\":2,\"1309\":1}}],[\"marshalling\",{\"1\":{\"893\":1}}],[\"marking\",{\"0\":{\"1753\":1}}],[\"markbeanascreated\",{\"1\":{\"1647\":1}}],[\"marks\",{\"1\":{\"1621\":1}}],[\"markoop\",{\"1\":{\"1483\":1}}],[\"mark\",{\"1\":{\"1439\":2,\"1484\":3}}],[\"marked\",{\"1\":{\"1162\":1,\"1484\":1}}],[\"markers\",{\"1\":{\"519\":1,\"520\":1}}],[\"mark老师nb\",{\"1\":{\"307\":1}}],[\"mark老师\",{\"1\":{\"307\":1}}],[\"mariadb中的并行复制策略\",{\"1\":{\"464\":1}}],[\"mariadb利用了redo\",{\"1\":{\"464\":1}}],[\"mariadb的并行复制策略\",{\"0\":{\"464\":1}}],[\"maxed\",{\"1\":{\"1689\":1}}],[\"maxmetaspacesize\",{\"1\":{\"1664\":2}}],[\"maxmetaspacesize=n\",{\"1\":{\"1664\":1}}],[\"maxmetaspacesize=256m\",{\"1\":{\"1664\":1}}],[\"maximal\",{\"1\":{\"1623\":1}}],[\"maximum\",{\"1\":{\"1550\":5,\"1553\":1,\"1554\":1,\"1615\":1,\"1620\":1,\"1689\":1}}],[\"maximumpoolsize\",{\"1\":{\"1476\":2}}],[\"maxby\",{\"1\":{\"1601\":1,\"1616\":1}}],[\"maxpoolsize\",{\"1\":{\"1410\":1}}],[\"maxvalue\",{\"1\":{\"424\":1}}],[\"max\",{\"1\":{\"306\":1,\"343\":1,\"355\":1,\"421\":1,\"422\":1,\"479\":2,\"497\":1,\"520\":1,\"538\":1,\"542\":1,\"574\":8,\"1227\":1,\"1501\":2,\"1503\":2,\"1509\":1,\"1550\":3,\"1554\":1,\"1610\":1,\"1615\":1,\"1620\":2,\"1623\":1}}],[\"map方法只有唯一的实现\",{\"1\":{\"1622\":1}}],[\"maps\",{\"1\":{\"1618\":1}}],[\"mapfactory\",{\"1\":{\"1618\":2}}],[\"map是最终的结果类型\",{\"1\":{\"1618\":1}}],[\"map是用来存储键值对的\",{\"1\":{\"1355\":1}}],[\"maptoint\",{\"1\":{\"1610\":4,\"1612\":2,\"1619\":2,\"1623\":1}}],[\"maptype\",{\"1\":{\"963\":3}}],[\"map等\",{\"1\":{\"1609\":1}}],[\"mapmode\",{\"1\":{\"1587\":1}}],[\"map就需要进行resize了\",{\"1\":{\"1551\":1}}],[\"map初始化为一个长度为2的数组\",{\"1\":{\"1551\":1}}],[\"map的存取效率就会越高\",{\"1\":{\"1546\":1}}],[\"map接口的不同实现之间的关系\",{\"1\":{\"1544\":1}}],[\"map会维护与key有关联的值\",{\"1\":{\"1355\":1}}],[\"map<class<\",{\"1\":{\"1638\":1}}],[\"map<city\",{\"1\":{\"1618\":2}}],[\"map<t\",{\"1\":{\"1617\":3}}],[\"map<typevariable\",{\"1\":{\"1100\":1}}],[\"map<boolean\",{\"1\":{\"1616\":1,\"1618\":4}}],[\"map<department\",{\"1\":{\"1615\":1,\"1616\":2}}],[\"map<k\",{\"1\":{\"1613\":1,\"1618\":6}}],[\"map<integer\",{\"1\":{\"1103\":1}}],[\"map<string\",{\"1\":{\"917\":2,\"921\":2,\"941\":2,\"963\":6,\"975\":1,\"985\":2,\"989\":5,\"1029\":1,\"1031\":2,\"1043\":1,\"1617\":6,\"1648\":3}}],[\"map>\",{\"1\":{\"989\":1}}],[\"map类型\",{\"1\":{\"963\":1}}],[\"map对象很可能就定位不到映射的位置了\",{\"1\":{\"1544\":1}}],[\"map对象\",{\"1\":{\"945\":1}}],[\"map到数字226\",{\"1\":{\"454\":1}}],[\"map\",{\"0\":{\"1544\":1},\"1\":{\"454\":3,\"519\":3,\"645\":2,\"917\":1,\"941\":1,\"960\":1,\"963\":4,\"975\":1,\"985\":1,\"1029\":1,\"1031\":1,\"1043\":1,\"1044\":1,\"1084\":1,\"1089\":1,\"1091\":1,\"1099\":1,\"1368\":3,\"1540\":1,\"1546\":2,\"1551\":6,\"1554\":2,\"1557\":3,\"1587\":1,\"1607\":1,\"1609\":6,\"1610\":3,\"1613\":1,\"1616\":6,\"1617\":11,\"1618\":5,\"1622\":2,\"1648\":3}}],[\"map和delete\",{\"1\":{\"454\":1}}],[\"mappropertysource\",{\"1\":{\"1031\":1,\"1156\":2}}],[\"mapped\",{\"1\":{\"1618\":3}}],[\"mappedbytebuffer\",{\"1\":{\"1587\":1}}],[\"mappedstatement>中查找对应的mappedstatement\",{\"1\":{\"1208\":1}}],[\"mappedstatement\",{\"1\":{\"645\":1}}],[\"mapperscannerregistrar类实现了importbeandefinitionregistrar接口\",{\"1\":{\"1653\":1}}],[\"mapperscan导入了mapperscannerregistrar类\",{\"1\":{\"1653\":1}}],[\"mapperstatement>的key使用\",{\"1\":{\"1209\":1}}],[\"mapperfactorybean的autowiremode为bytype\",{\"1\":{\"1653\":1}}],[\"mapperfactorybean\",{\"1\":{\"1217\":1}}],[\"mapper\",{\"1\":{\"1217\":2,\"1618\":7,\"1622\":3}}],[\"mapper接口实现类\",{\"1\":{\"1217\":1}}],[\"mapper编写有哪几种方式\",{\"0\":{\"201\":1,\"1217\":1}}],[\"mapper内的方法为什么不能重载\",{\"0\":{\"192\":1,\"1208\":1},\"1\":{\"1208\":1}}],[\"mappingfunction\",{\"1\":{\"1618\":3}}],[\"mapping方法被用来在累积操作之前对每个输入元素都应用mapping方法\",{\"1\":{\"1618\":1}}],[\"mappings\",{\"1\":{\"309\":1}}],[\"mapping不会被更新\",{\"1\":{\"309\":1}}],[\"mapping也同时被更新\",{\"1\":{\"309\":1}}],[\"mapping\",{\"1\":{\"309\":2,\"645\":1,\"893\":1,\"1549\":1,\"1618\":6,\"1623\":4}}],[\"mapping类型自动识别\",{\"1\":{\"309\":1}}],[\"mapping类似数据库中的schema的定义\",{\"1\":{\"309\":1}}],[\"map三者的区别\",{\"0\":{\"27\":1,\"1355\":1}}],[\"mq有三大主要作用分别为解耦\",{\"1\":{\"1985\":1}}],[\"mq并不能保证exactly\",{\"1\":{\"1333\":1}}],[\"mq中要保护事务的最终一致性\",{\"1\":{\"1333\":1}}],[\"mq只需要保证局部有序\",{\"1\":{\"1330\":1}}],[\"mq消息存盘不丢失\",{\"1\":{\"1328\":1}}],[\"mq主从消息同步不丢失\",{\"1\":{\"1328\":1}}],[\"mq\",{\"0\":{\"251\":1,\"1332\":1,\"1985\":1},\"1\":{\"1308\":1,\"1328\":1,\"1985\":1}}],[\"mq如何保证消息顺序\",{\"0\":{\"249\":1,\"1330\":1}}],[\"mymethod2\",{\"1\":{\"1595\":1}}],[\"mymethod\",{\"1\":{\"1595\":1,\"1607\":9}}],[\"mymap\",{\"1\":{\"1103\":2}}],[\"mymaster\",{\"1\":{\"621\":1,\"624\":7}}],[\"mytest\",{\"1\":{\"1595\":13}}],[\"mycomparatortest\",{\"1\":{\"1614\":1}}],[\"mycomponentscan中也有scanbasepackages属性\",{\"1\":{\"1137\":1}}],[\"mycomponentscan2\",{\"1\":{\"1137\":1}}],[\"mycomponentscan\",{\"1\":{\"1136\":1,\"1137\":3}}],[\"mycomponent\",{\"1\":{\"1134\":2}}],[\"myclass2\",{\"1\":{\"1607\":5}}],[\"myclass\",{\"1\":{\"1607\":10}}],[\"mycat\",{\"1\":{\"1270\":1}}],[\"myd是数据文件\",{\"1\":{\"1260\":1}}],[\"myd和myisam文件\",{\"1\":{\"1260\":1}}],[\"mydestructionawarebeanpostprocessor\",{\"1\":{\"1011\":2}}],[\"mylifecycle\",{\"1\":{\"1174\":5}}],[\"mylistener\",{\"1\":{\"1116\":3}}],[\"mylist作为候选\",{\"1\":{\"571\":1}}],[\"mylist=>\",{\"1\":{\"571\":3}}],[\"mylist\",{\"1\":{\"567\":1,\"571\":33}}],[\"myiam和innodb都支持\",{\"1\":{\"1263\":1}}],[\"myi是索引文件\",{\"1\":{\"1260\":1}}],[\"myinterface2\",{\"1\":{\"1607\":5}}],[\"myinterface1impl\",{\"1\":{\"1607\":3}}],[\"myinterface1\",{\"1\":{\"1607\":7}}],[\"myinterface既然满足函数式接口的定义\",{\"1\":{\"1595\":1}}],[\"myinterface\",{\"1\":{\"1594\":1,\"1595\":18}}],[\"myinstantiationawarebeanpostprocessor\",{\"1\":{\"1000\":2,\"1001\":2,\"1002\":1,\"1005\":2,\"1006\":1,\"1011\":1}}],[\"myinjecteduser\",{\"1\":{\"967\":1}}],[\"myisam使用的非聚簇索引\",{\"1\":{\"1266\":1}}],[\"myisam每个表有两个文件\",{\"1\":{\"1260\":1}}],[\"myisam和innodb的区别\",{\"1\":{\"1260\":1}}],[\"myisam在执行查询语句select前会给涉及的所有表加读锁\",{\"1\":{\"535\":1}}],[\"myisam索引文件和数据文件是分离的\",{\"1\":{\"505\":1}}],[\"myisam引擎的自增值保存在数据文件中\",{\"1\":{\"490\":1}}],[\"myisam引擎把一个表的总行数存在了磁盘上\",{\"1\":{\"396\":1}}],[\"myisam分区表使用的分区策略\",{\"1\":{\"425\":1}}],[\"myisam\",{\"1\":{\"317\":1,\"425\":1,\"431\":1,\"534\":1,\"545\":1}}],[\"myarray\",{\"1\":{\"1607\":4}}],[\"myautowired\",{\"1\":{\"967\":2}}],[\"myapplicationlistener接收到spring事件\",{\"1\":{\"1114\":1}}],[\"myapplicationlistener\",{\"1\":{\"1114\":1}}],[\"myapp\",{\"1\":{\"928\":2}}],[\"mykey\",{\"1\":{\"583\":2,\"1288\":5}}],[\"myelemz\",{\"1\":{\"577\":2}}],[\"myelemy\",{\"1\":{\"577\":3}}],[\"myelemx\",{\"1\":{\"577\":4}}],[\"myzset=>\",{\"1\":{\"574\":1}}],[\"myzset\",{\"1\":{\"574\":19}}],[\"myspringeventlistener\",{\"1\":{\"1119\":2,\"1120\":1,\"1123\":2}}],[\"myspringevent\",{\"1\":{\"1119\":4,\"1120\":3,\"1123\":3}}],[\"mysuper\",{\"1\":{\"624\":1}}],[\"mysetcollector2<>\",{\"1\":{\"1617\":6}}],[\"mysetcollector2<t>\",{\"1\":{\"1617\":1}}],[\"mysetcollector<>\",{\"1\":{\"1617\":1}}],[\"mysetcollector<t>\",{\"1\":{\"1617\":1}}],[\"myset\",{\"1\":{\"567\":1,\"572\":11}}],[\"mysql必知必会\",{\"1\":{\"1974\":1}}],[\"mysql高级教程\",{\"1\":{\"1966\":1}}],[\"mysql高可用系统的可用性\",{\"1\":{\"459\":1}}],[\"mysql目前主要有以下几种索引类型\",{\"1\":{\"1276\":1}}],[\"mysql主从结构原理\",{\"1\":{\"1269\":1}}],[\"mysql主键索引和普通索引有什么区别\",{\"0\":{\"158\":1,\"1267\":1}}],[\"mysql采用b+树作为存储索引的数据结构\",{\"1\":{\"1264\":1}}],[\"mysql默认\",{\"1\":{\"1262\":1}}],[\"mysql默认的事务隔离级别是可重复读\",{\"1\":{\"532\":1}}],[\"mysql当中有五种隔离级别\",{\"1\":{\"1262\":1}}],[\"mysql还支持很多\",{\"1\":{\"557\":1}}],[\"mysql还有另一个优化\",{\"1\":{\"451\":1}}],[\"mysqladv\",{\"1\":{\"555\":1}}],[\"mysql引入了启发式规则\",{\"1\":{\"554\":1}}],[\"mysql引入了一个临时文件表空间\",{\"1\":{\"412\":1}}],[\"mysql考虑到这种情况\",{\"1\":{\"553\":1}}],[\"mysql把这种通过直接访问索引对应的b+树来计算某个范围区间对应的索引记录条数的方式称之为index\",{\"1\":{\"553\":1}}],[\"mysql评估回表操作的io成本依旧很简单粗暴\",{\"1\":{\"549\":1}}],[\"mysql根据上述算法得到索引项id\",{\"1\":{\"549\":1}}],[\"mysql计算这种查询的成本以来两个方面的数据\",{\"1\":{\"549\":1}}],[\"mysql查询优化器先分析使用唯一二级索引的成本\",{\"1\":{\"549\":1}}],[\"mysql查询成本\",{\"0\":{\"545\":1}}],[\"mysql规定读取一个页面花费的成本默认是1\",{\"1\":{\"545\":1}}],[\"mysql内核查询成本计算实战\",{\"1\":{\"545\":1}}],[\"mysql内部是严格按照事务的启动顺序来分配事务id的\",{\"1\":{\"542\":1}}],[\"mysql内部每秒能够扫描内存中上百万行的数据\",{\"1\":{\"392\":1}}],[\"mysql提出了optimizer\",{\"1\":{\"544\":1,\"556\":1}}],[\"mysql提供可以用来分析当前会话中语句执行的资源消耗情况\",{\"1\":{\"431\":1}}],[\"mysql提供了自动更新和手动更新两种更新统计数据的方式\",{\"1\":{\"559\":1}}],[\"mysql提供了一个系统变量optimizer\",{\"1\":{\"556\":1}}],[\"mysql提供了一个全局读锁的方法\",{\"1\":{\"437\":1}}],[\"mysql提供了日志分析工具mysqldumpslow\",{\"1\":{\"429\":1}}],[\"mysql提供了参数配置\",{\"1\":{\"319\":1}}],[\"mysql成本分析\",{\"0\":{\"544\":1}}],[\"mysql事务与锁\",{\"0\":{\"531\":1}}],[\"mysql能存储的最小时间粒度为秒\",{\"1\":{\"529\":1}}],[\"mysql数据类型的选择\",{\"0\":{\"527\":1}}],[\"mysql数据库服务器的参数调优\",{\"1\":{\"430\":1}}],[\"mysql数据库没有开启慢查询日志\",{\"1\":{\"428\":1}}],[\"mysql通过将主节点的binlog同步给从节点完成主从之间的数据同步\",{\"1\":{\"1269\":1}}],[\"mysql通过系统变量innodb\",{\"1\":{\"558\":1}}],[\"mysql通过max\",{\"1\":{\"520\":1}}],[\"mysql通过比较系统变量max\",{\"1\":{\"520\":1}}],[\"mysql通过分析器知道了要做什么\",{\"1\":{\"322\":1}}],[\"mysql索引结构\",{\"0\":{\"501\":1}}],[\"mysql索引结构是什么样的\",{\"0\":{\"155\":1,\"1264\":1}}],[\"mysql性能优化\",{\"0\":{\"500\":1}}],[\"mysql性能分析工具\",{\"0\":{\"328\":1}}],[\"mysql实战45讲\",{\"1\":{\"499\":1,\"1966\":1,\"1974\":1}}],[\"mysql重启时max\",{\"1\":{\"497\":1}}],[\"mysql重启可能会修改一个表的auto\",{\"1\":{\"490\":1}}],[\"mysql为我们提供了系统变量innodb\",{\"1\":{\"558\":1}}],[\"mysql为每个表维护了一系列的统计信息\",{\"1\":{\"548\":1}}],[\"mysql为什么不会把表t的自增值改回去呢\",{\"1\":{\"491\":1}}],[\"mysql为了让组提交的效果更好\",{\"1\":{\"451\":1}}],[\"mysql客户端默认采用第一种方式\",{\"1\":{\"482\":1}}],[\"mysql客户端发送请求后\",{\"1\":{\"482\":1}}],[\"mysql客户端会提供一个本地库名和表名补全的功能\",{\"1\":{\"482\":1}}],[\"mysql里有很多自增的id\",{\"1\":{\"493\":1}}],[\"mysql里处理kill命令的线程做了两件事情\",{\"1\":{\"481\":1}}],[\"mysql里面表级别的锁有两种\",{\"1\":{\"439\":1}}],[\"mysql里面的锁大致可以分为全局锁\",{\"1\":{\"436\":1}}],[\"mysql库\",{\"1\":{\"477\":1}}],[\"mysql这样设计的原因是\",{\"1\":{\"476\":1}}],[\"mysql这时会选择rowid排序\",{\"1\":{\"420\":1}}],[\"mysql5\",{\"1\":{\"465\":3,\"468\":1,\"492\":1,\"499\":1,\"518\":1,\"529\":1}}],[\"mysql只支持单线程复制\",{\"1\":{\"460\":1}}],[\"mysql要提供高可用能力\",{\"1\":{\"456\":1}}],[\"mysql要给这个innodb表创建一个frm文件保存表结构定义\",{\"1\":{\"412\":1}}],[\"mysql此时使用的statement格式\",{\"1\":{\"454\":1}}],[\"mysql自己实现的\",{\"1\":{\"513\":1}}],[\"mysql自己会判断这条sql语句是否可能引起主备不一致\",{\"1\":{\"454\":1}}],[\"mysql自带的逻辑备份工具是mysqldump\",{\"1\":{\"438\":1}}],[\"mysql自带的引擎是myisam\",{\"1\":{\"325\":1}}],[\"mysqlbinlog工具查看执行的详情\",{\"1\":{\"454\":1}}],[\"mysqlbinlog\",{\"1\":{\"454\":2,\"467\":1}}],[\"mysql认为这样写是有风险的\",{\"1\":{\"454\":1}}],[\"mysqldumpslow\",{\"1\":{\"429\":7}}],[\"mysqld\",{\"1\":{\"428\":3}}],[\"mysql需要把所有的分区都访问一遍\",{\"1\":{\"425\":1}}],[\"mysql需要先从数据表读出记录然后过滤\",{\"1\":{\"390\":1}}],[\"mysql处理limit\",{\"1\":{\"422\":1}}],[\"mysql维护数据表\",{\"1\":{\"412\":1}}],[\"mysql并没有使用simple\",{\"1\":{\"402\":1}}],[\"mysql并不会只查出需要的10条数据\",{\"1\":{\"383\":1}}],[\"mysql优化器可能会选择表t1或t2作为驱动表\",{\"1\":{\"401\":1}}],[\"mysql优化器会找到最小的那棵树来遍历\",{\"1\":{\"396\":1}}],[\"mysql响应数据给客户端就慢得多了\",{\"1\":{\"392\":1}}],[\"mysql从设计上连接和断开连接都很轻量级\",{\"1\":{\"392\":1}}],[\"mysql从整体上来看\",{\"1\":{\"325\":1}}],[\"mysql不会告诉我们生成结果实际上需要扫描多少行数据\",{\"1\":{\"390\":1}}],[\"mysql不需要执行后面的复杂操作\",{\"1\":{\"319\":1}}],[\"mysql有两种情况需要猜出扇出的值\",{\"1\":{\"554\":1}}],[\"mysql有一个批量申请自增id的策略\",{\"1\":{\"492\":1}}],[\"mysql有一个折中的方案\",{\"1\":{\"454\":1}}],[\"mysql有好几种访问方式可以查找并返回一行结果\",{\"1\":{\"390\":1}}],[\"mysql有哪几种数据存储引擎\",{\"0\":{\"151\":1,\"1260\":1}}],[\"mysql居然还是用的using\",{\"1\":{\"361\":1}}],[\"mysql才会采用rowid排序算法\",{\"1\":{\"356\":1}}],[\"mysql将需要排序的数据分成12份\",{\"1\":{\"354\":1}}],[\"mysql选错索引\",{\"1\":{\"347\":1}}],[\"mysql在执行诸如distinct查询\",{\"1\":{\"557\":1}}],[\"mysql在server层进行连接管理\",{\"1\":{\"557\":1}}],[\"mysql在计算各种链接顺序的成本之前\",{\"1\":{\"556\":1}}],[\"mysql在真实计算成本时会进行一些微调\",{\"1\":{\"548\":1}}],[\"mysql在真正开始执行语句之前\",{\"1\":{\"347\":1}}],[\"mysql在读已提交和可重复读的隔离级别下的隔离性都依靠mvcc\",{\"1\":{\"540\":1}}],[\"mysql在内部维护了一个全局变量global\",{\"1\":{\"496\":1}}],[\"mysql在第一次打开分区表的时候\",{\"1\":{\"425\":1}}],[\"mysql在记录binlog的时候\",{\"1\":{\"413\":2}}],[\"mysql在5\",{\"1\":{\"405\":1}}],[\"mysql在索引idx\",{\"1\":{\"390\":1}}],[\"mysql在使用\",{\"1\":{\"369\":1}}],[\"mysql在対查询结果排序时使用了临时表\",{\"1\":{\"330\":1}}],[\"mysql用错了索引\",{\"1\":{\"346\":1}}],[\"mysql可能会选错索引\",{\"1\":{\"346\":1}}],[\"mysql可以借助重做日志和归档日志恢复到半个月内任意一秒的状态\",{\"1\":{\"323\":1}}],[\"mysql可以分为server层和存储引擎两部分\",{\"1\":{\"317\":1}}],[\"mysql中连接查询采用的是嵌套循环连接算法\",{\"1\":{\"554\":1}}],[\"mysql中的锁的分类\",{\"0\":{\"533\":1}}],[\"mysql中的临时表\",{\"0\":{\"409\":1}}],[\"mysql中默认的日期格式是yyyy\",{\"1\":{\"529\":1}}],[\"mysql中提供了一个类似的命令\",{\"1\":{\"474\":1}}],[\"mysql中查看long\",{\"1\":{\"428\":1}}],[\"mysql中一张表可以支持多个索引\",{\"1\":{\"346\":1}}],[\"mysql中无法利用索引完成的排序操作成为\",{\"1\":{\"330\":1}}],[\"mysql就知道你要做什么了\",{\"1\":{\"514\":1}}],[\"mysql就知道你想要做什么了\",{\"1\":{\"321\":1}}],[\"mysql就确保了主备数据的一致性\",{\"1\":{\"454\":1}}],[\"mysql就会持续出现一个脏读的bug\",{\"1\":{\"497\":1}}],[\"mysql就会把source\",{\"1\":{\"468\":1}}],[\"mysql就会把内存临时表转成磁盘临时表\",{\"1\":{\"416\":1}}],[\"mysql就会使用rowid排序\",{\"1\":{\"355\":1}}],[\"mysql就认为单行太大\",{\"1\":{\"355\":1}}],[\"mysql就能将该查询转化为一个常量\",{\"1\":{\"330\":1}}],[\"mysql异常重启\",{\"1\":{\"327\":1}}],[\"mysql>\",{\"1\":{\"322\":1,\"329\":1,\"330\":6,\"361\":1,\"371\":2,\"428\":4,\"431\":4,\"454\":3}}],[\"mysql会用一些办法减少计算连接顺序的成本的方法\",{\"1\":{\"556\":1}}],[\"mysql会用read\",{\"1\":{\"542\":1}}],[\"mysql会保留修改前的数据undo回滚日志\",{\"1\":{\"542\":1}}],[\"mysql会自动返回记录插入的确切时间\",{\"1\":{\"529\":1}}],[\"mysql会block\",{\"1\":{\"524\":1}}],[\"mysql会直接使用数组来存储这些数据\",{\"1\":{\"418\":1}}],[\"mysql会在临时文件目录下创建一个相同前缀\",{\"1\":{\"412\":1}}],[\"mysql会给每个线程分配一块内存用于排序\",{\"1\":{\"354\":1}}],[\"mysql会根据词法解析的结果分析出可能可以使用的索引作为候选项\",{\"1\":{\"348\":1}}],[\"mysql会通过采样统计的方式来得到索引的基数\",{\"1\":{\"347\":1}}],[\"mysql会递归执行这些子查询\",{\"1\":{\"330\":1}}],[\"mysql会使用wal技术\",{\"1\":{\"324\":1}}],[\"mysql会使用分析器对sql语句做解析\",{\"1\":{\"320\":1}}],[\"mysql会从输入的\",{\"1\":{\"320\":1}}],[\"mysql8\",{\"1\":{\"319\":1}}],[\"mysql拿到一个查询请求后\",{\"1\":{\"319\":1}}],[\"mysql逻辑架构\",{\"0\":{\"317\":1}}],[\"mysql基础\",{\"0\":{\"316\":1}}],[\"mysql如何快速插入千万级数据\",{\"0\":{\"168\":1,\"1277\":1}}],[\"mysql如何进行分库分表\",{\"0\":{\"161\":1,\"1270\":1}}],[\"mysql集群是如何搭建的\",{\"0\":{\"160\":1,\"1269\":1}}],[\"mysql的主从集群只会讲binlog从主节点同步到从节点\",{\"1\":{\"1269\":1}}],[\"mysql的查询优化器会找出执行该语句所有可能使用的方案\",{\"1\":{\"546\":1}}],[\"mysql的查询优化器会优化sql语句的顺序\",{\"1\":{\"378\":3}}],[\"mysql的这套机制看起来虽然复杂\",{\"1\":{\"543\":1}}],[\"mysql的乐观锁\",{\"1\":{\"535\":1}}],[\"mysql的表关联常见的有两种算法\",{\"1\":{\"523\":1}}],[\"mysql的词法分析由mysqllex\",{\"1\":{\"513\":1}}],[\"mysql的tps会高于磁盘的tps\",{\"1\":{\"451\":1}}],[\"mysql的事务启动方式有以下几种\",{\"1\":{\"435\":1}}],[\"mysql的innodb默认隔离级别是\",{\"1\":{\"433\":1}}],[\"mysql的慢查询日志是mysql提供的一种日志记录\",{\"1\":{\"428\":1}}],[\"mysql的优化器除了会统计索引的基数\",{\"1\":{\"347\":1}}],[\"mysql的三种删除方式的区别\",{\"0\":{\"162\":1,\"1271\":1}}],[\"mysql的索引类型\",{\"0\":{\"167\":1,\"1276\":1}}],[\"mysql的索引覆盖和回表是什么\",{\"0\":{\"159\":1,\"1268\":1}}],[\"mysql的索引结构为什么使用b+树\",{\"0\":{\"156\":1,\"1265\":1}}],[\"mysql的锁有哪些\",{\"0\":{\"154\":1,\"1263\":1}}],[\"mysql\",{\"0\":{\"150\":1,\"463\":1,\"465\":1,\"561\":1,\"1259\":1,\"1974\":1},\"1\":{\"318\":2,\"394\":2,\"428\":2,\"429\":6,\"454\":1,\"477\":1,\"478\":3,\"481\":1,\"482\":1,\"497\":1,\"538\":2,\"553\":3,\"557\":3,\"558\":4,\"1265\":1,\"1974\":4}}],[\"my\",{\"1\":{\"428\":1,\"1123\":2,\"1591\":4}}],[\"mybean\",{\"1\":{\"951\":1}}],[\"mybtais动态sql有什么用\",{\"0\":{\"200\":1,\"1216\":1}}],[\"mybatisplus\",{\"1\":{\"1966\":1}}],[\"mybatis\",{\"1\":{\"1217\":1,\"1979\":1,\"1982\":1}}],[\"mybatis动态sql可以在xml映射文件内\",{\"1\":{\"1216\":1}}],[\"mybatis使用rowbounds对象进行分页\",{\"1\":{\"1214\":1}}],[\"mybatis在处理$\",{\"1\":{\"1210\":1}}],[\"mybatis在处理\",{\"1\":{\"1210\":1}}],[\"mybatis在xml文件中寻找对应的sql语句的时候\",{\"1\":{\"1208\":1}}],[\"mybatis提供的默认的别名注册器\",{\"1\":{\"645\":1}}],[\"mybatis源码体系\",{\"0\":{\"645\":1}}],[\"mybatis源码分析\",{\"0\":{\"644\":1}}],[\"mybatis如何开启二级缓存\",{\"0\":{\"204\":1,\"1220\":1}}],[\"mybatis有二级缓存\",{\"0\":{\"203\":1,\"1219\":1}}],[\"mybatis有哪些动态sql标签\",{\"0\":{\"199\":1,\"1215\":1}}],[\"mybatis的缓存机制\",{\"1\":{\"1220\":1}}],[\"mybatis的功能架构可以分为三层\",{\"1\":{\"645\":1}}],[\"mybatis的体系结构如下\",{\"1\":{\"645\":1}}],[\"mybatis的一级\",{\"0\":{\"202\":1,\"1218\":1}}],[\"mybatis的xml映射文件中\",{\"0\":{\"193\":1,\"1209\":1}}],[\"mybatis时如何进行分页的\",{\"0\":{\"198\":1,\"1214\":1}}],[\"mybatis接口\",{\"0\":{\"192\":1,\"1208\":1},\"1\":{\"1208\":1}}],[\"mybatis面试题\",{\"0\":{\"191\":1,\"1207\":1}}],[\"mvc替换为struts\",{\"1\":{\"1659\":1}}],[\"mvc容器进行管理\",{\"0\":{\"1661\":1}}],[\"mvc容器中查找controller\",{\"1\":{\"1660\":1}}],[\"mvc容器\",{\"1\":{\"1659\":1}}],[\"mvc的容器管理\",{\"1\":{\"1659\":1}}],[\"mvc的请求执行过程\",{\"1\":{\"1657\":1}}],[\"mvc为什么需要父子容器\",{\"0\":{\"1659\":1}}],[\"mvc启动过程\",{\"0\":{\"1658\":1}}],[\"mvc执行流程\",{\"0\":{\"1657\":1}}],[\"mvc本质上是基于servlet\",{\"1\":{\"1656\":1}}],[\"mvc源码分析\",{\"0\":{\"1656\":1}}],[\"mvc架构\",{\"1\":{\"1309\":1}}],[\"mvc处理的请求映射到dispatcherservlet的servlet上\",{\"1\":{\"1241\":1}}],[\"mvc模块\",{\"1\":{\"1138\":1}}],[\"mvc错误消息提示\",{\"1\":{\"1049\":1}}],[\"mvc测试\",{\"1\":{\"896\":1}}],[\"mvc\",{\"1\":{\"894\":1,\"896\":1,\"1657\":1,\"1979\":1,\"1982\":2}}],[\"mvcc机制的实现就是通过read\",{\"1\":{\"542\":1}}],[\"mvcc机制\",{\"0\":{\"541\":1},\"1\":{\"1965\":1}}],[\"mvcc与bufferpool缓冲机制\",{\"0\":{\"540\":1}}],[\"mvcc\",{\"1\":{\"396\":1,\"434\":1,\"541\":1,\"1261\":1}}],[\"mvc原理\",{\"0\":{\"184\":1,\"1241\":1}}],[\"mvc中的控制器是不是单例模式\",{\"0\":{\"183\":1,\"1240\":1}}],[\"pwd=h4v2\",{\"1\":{\"1972\":1}}],[\"pd\",{\"1\":{\"1648\":2}}],[\"pds\",{\"1\":{\"1003\":1}}],[\"p=29\",{\"1\":{\"1980\":1}}],[\"p=p\",{\"1\":{\"1623\":1}}],[\"p=abstractpipeline\",{\"1\":{\"1623\":1}}],[\"people\",{\"1\":{\"1616\":2,\"1618\":5}}],[\"peek\",{\"1\":{\"1500\":1,\"1501\":2}}],[\"permsize代表永久带的初始容量\",{\"1\":{\"1664\":1}}],[\"permsize参数意思不一样\",{\"1\":{\"1664\":1}}],[\"permitted\",{\"1\":{\"1621\":1}}],[\"permissions\",{\"1\":{\"431\":1}}],[\"permanent\",{\"1\":{\"1457\":2}}],[\"perform\",{\"1\":{\"1597\":1,\"1615\":4,\"1616\":1,\"1618\":1,\"1619\":2,\"1620\":1,\"1623\":3}}],[\"performing\",{\"1\":{\"1597\":2,\"1615\":2,\"1618\":1}}],[\"performed\",{\"1\":{\"1595\":3,\"1597\":1,\"1615\":1,\"1619\":2,\"1620\":3,\"1622\":1}}],[\"performs\",{\"1\":{\"1595\":2,\"1597\":3,\"1608\":2,\"1618\":1,\"1620\":2,\"1622\":1,\"1623\":1}}],[\"performance\",{\"1\":{\"354\":2,\"479\":2,\"1615\":1,\"1618\":1,\"1620\":2}}],[\"perfcounter\",{\"1\":{\"1432\":3,\"1663\":3}}],[\"percent\",{\"1\":{\"1053\":1}}],[\"persistence\",{\"1\":{\"1110\":1}}],[\"persistenceannotationprocessor对象\",{\"1\":{\"945\":1}}],[\"persistent的值作为该属性的值\",{\"1\":{\"558\":1}}],[\"persistent的值来选择\",{\"1\":{\"347\":1}}],[\"persistent属性\",{\"1\":{\"558\":1}}],[\"persistent属性来指明该表的统计数据存储方式\",{\"1\":{\"558\":1}}],[\"persistent=0时\",{\"1\":{\"558\":1}}],[\"persistent=1时\",{\"1\":{\"558\":1}}],[\"persistent\",{\"1\":{\"558\":6}}],[\"personlist\",{\"1\":{\"1598\":2}}],[\"persons2\",{\"1\":{\"1598\":2}}],[\"persons\",{\"1\":{\"1598\":6}}],[\"person3\",{\"1\":{\"1598\":2}}],[\"person2\",{\"1\":{\"1598\":2}}],[\"person1\",{\"1\":{\"1598\":2}}],[\"persontest\",{\"1\":{\"1598\":5}}],[\"person\",{\"1\":{\"909\":6,\"1598\":10,\"1616\":2,\"1618\":4}}],[\"perpetualcache\",{\"1\":{\"645\":1}}],[\"per\",{\"0\":{\"1533\":1},\"1\":{\"553\":3,\"555\":6,\"1533\":4,\"1620\":2}}],[\"ptm\",{\"1\":{\"1655\":5}}],[\"pthread\",{\"1\":{\"1483\":1,\"1530\":2}}],[\"ptr回滚指针去取出undo\",{\"1\":{\"542\":1}}],[\"ptr是一个回滚指针\",{\"1\":{\"542\":1}}],[\"ptr\",{\"1\":{\"542\":1}}],[\"ptr等字段\",{\"1\":{\"542\":1}}],[\"pp\",{\"1\":{\"1166\":12}}],[\"ppname\",{\"1\":{\"1166\":10}}],[\"pplybeanpostprocessorsbeforeinitialization\",{\"1\":{\"1006\":1}}],[\"pkgs启动参数\",{\"1\":{\"1049\":1}}],[\"pbd\",{\"1\":{\"997\":4,\"1647\":4}}],[\"pvstouse\",{\"1\":{\"1647\":5}}],[\"pvs\",{\"1\":{\"964\":5,\"1003\":8,\"1647\":11,\"1648\":4}}],[\"platform\",{\"1\":{\"1683\":1}}],[\"platformtransactionmanager\",{\"1\":{\"1655\":1}}],[\"placed\",{\"1\":{\"1550\":1}}],[\"place\",{\"1\":{\"1480\":1,\"1623\":1}}],[\"placeholders\",{\"1\":{\"1146\":1}}],[\"placeholder\",{\"1\":{\"1020\":1,\"1162\":1}}],[\"plain\",{\"1\":{\"928\":1,\"973\":1,\"1164\":1}}],[\"planet\",{\"1\":{\"1053\":9}}],[\"plan\",{\"1\":{\"519\":8}}],[\"plans\",{\"1\":{\"519\":2}}],[\"plugin\",{\"0\":{\"880\":1,\"881\":1,\"882\":1}}],[\"ps\",{\"1\":{\"1156\":3,\"1157\":3,\"1460\":1,\"1461\":1}}],[\"psubscribe\",{\"1\":{\"597\":1}}],[\"psetex\",{\"1\":{\"570\":1}}],[\"pfmerge\",{\"1\":{\"577\":3}}],[\"pfcount\",{\"1\":{\"577\":5}}],[\"pfadd\",{\"1\":{\"577\":4}}],[\"pfx04表示的是insert\",{\"1\":{\"558\":1}}],[\"pfx03表示的是insert\",{\"1\":{\"558\":1}}],[\"pfx02表示insert\",{\"1\":{\"558\":1}}],[\"pfx01表示的是统计insert\",{\"1\":{\"558\":1}}],[\"pfxnn\",{\"1\":{\"558\":1}}],[\"pct\",{\"1\":{\"519\":1}}],[\"pipelinehelper描述了一个流管道最开始的阶段\",{\"1\":{\"1623\":1}}],[\"pipelinehelper\",{\"1\":{\"1623\":10}}],[\"pipelinehelper<t>\",{\"1\":{\"1623\":2}}],[\"pipelinehelper<e\",{\"1\":{\"1623\":3}}],[\"pipeline起作用\",{\"1\":{\"1621\":2}}],[\"pipeline源码分析\",{\"0\":{\"1621\":1}}],[\"pipelines\",{\"1\":{\"1618\":1,\"1619\":2,\"1621\":1,\"1622\":1,\"1623\":1}}],[\"pipeline\",{\"1\":{\"1617\":2,\"1619\":5,\"1621\":18,\"1622\":4,\"1623\":14}}],[\"pipeline有什么好处\",{\"0\":{\"146\":1,\"1298\":1}}],[\"picking\",{\"1\":{\"1166\":1}}],[\"pick\",{\"1\":{\"997\":1,\"1647\":1}}],[\"picocontainer\",{\"1\":{\"908\":1}}],[\"pid文件名\",{\"1\":{\"609\":1}}],[\"pid并不是让进程直接停止\",{\"1\":{\"481\":1}}],[\"ping\",{\"1\":{\"582\":1}}],[\"pivot\",{\"1\":{\"571\":1,\"1615\":1}}],[\"png\",{\"1\":{\"472\":1,\"479\":1}}],[\"p$pwd\",{\"1\":{\"454\":1}}],[\"p$port\",{\"1\":{\"318\":1}}],[\"p13000\",{\"1\":{\"454\":1}}],[\"pan\",{\"1\":{\"1972\":1}}],[\"padding\",{\"1\":{\"1484\":1}}],[\"pair\",{\"1\":{\"1479\":2}}],[\"payloadapplicationevent\",{\"1\":{\"1118\":1}}],[\"payload事件\",{\"0\":{\"1118\":1},\"1\":{\"1118\":1}}],[\"pack\",{\"1\":{\"1591\":2}}],[\"packet配置项\",{\"1\":{\"1277\":1}}],[\"packed\",{\"1\":{\"520\":1,\"553\":1}}],[\"packagesearchpath\",{\"1\":{\"1647\":2}}],[\"packages\",{\"1\":{\"1137\":1}}],[\"packages覆盖了scanbasepackages\",{\"1\":{\"1137\":1}}],[\"package\",{\"1\":{\"1087\":1,\"1479\":1,\"1591\":1,\"1597\":2,\"1598\":4,\"1599\":2,\"1600\":1,\"1601\":1,\"1605\":1,\"1608\":8,\"1620\":2,\"1647\":1}}],[\"package=\",{\"1\":{\"1065\":1}}],[\"pae\",{\"1\":{\"1007\":2}}],[\"passes\",{\"1\":{\"1623\":1}}],[\"passed\",{\"1\":{\"1615\":6,\"1619\":1,\"1620\":2,\"1623\":2}}],[\"passingfailing\",{\"1\":{\"1616\":1}}],[\"passing\",{\"1\":{\"1616\":1,\"1623\":1}}],[\"password\",{\"1\":{\"1061\":7}}],[\"password=$password\",{\"1\":{\"467\":1,\"468\":1}}],[\"pass\",{\"1\":{\"624\":2,\"1615\":1,\"1616\":1,\"1621\":1,\"1648\":3,\"1655\":1}}],[\"paging\",{\"1\":{\"561\":1}}],[\"pages的值作为该属性的值\",{\"1\":{\"558\":1}}],[\"pages属性的话\",{\"1\":{\"558\":1}}],[\"pages属性来指明该表的统计数据存储方式\",{\"1\":{\"558\":1}}],[\"pages\",{\"1\":{\"558\":3,\"1683\":1}}],[\"pages来控制使用永久性的统计数据时\",{\"1\":{\"558\":1}}],[\"page\",{\"1\":{\"431\":1,\"503\":1}}],[\"page2没有在内存中\",{\"1\":{\"345\":1}}],[\"page1在内存中\",{\"1\":{\"345\":1}}],[\"pathmatcher\",{\"1\":{\"1042\":1,\"1043\":2}}],[\"pathmatchingresourcepatternresolver\",{\"1\":{\"1042\":1,\"1043\":3}}],[\"pathresource\",{\"1\":{\"1040\":1}}],[\"path>\",{\"1\":{\"624\":2}}],[\"paths\",{\"1\":{\"519\":4,\"1587\":2,\"1588\":2}}],[\"path\",{\"1\":{\"519\":2,\"1043\":8,\"1073\":1,\"1074\":1,\"1257\":1,\"1619\":1}}],[\"pattern2\",{\"1\":{\"1043\":1}}],[\"pattern1\",{\"1\":{\"1043\":1}}],[\"pattern\",{\"1\":{\"429\":1,\"572\":1,\"573\":1,\"574\":1,\"597\":4,\"906\":1,\"1043\":4,\"1053\":1,\"1484\":1}}],[\"pareach<>\",{\"1\":{\"1620\":1}}],[\"pareach<t>\",{\"1\":{\"1620\":2}}],[\"pareach\",{\"1\":{\"1620\":3}}],[\"parentbeanfactory\",{\"1\":{\"1647\":7}}],[\"parentbeanname\",{\"1\":{\"997\":6,\"1647\":6}}],[\"parentcontent\",{\"1\":{\"1116\":7}}],[\"parentcid\",{\"1\":{\"330\":4}}],[\"parent==null\",{\"1\":{\"1689\":1}}],[\"parent=\",{\"1\":{\"917\":1}}],[\"parent\",{\"1\":{\"330\":2,\"928\":1,\"997\":8,\"1022\":1,\"1055\":5,\"1116\":2,\"1167\":5,\"1432\":3,\"1506\":3,\"1620\":3,\"1647\":10,\"1648\":6,\"1663\":3,\"1689\":5}}],[\"par\",{\"1\":{\"1618\":3}}],[\"parknanos\",{\"1\":{\"1479\":1,\"1520\":1}}],[\"parnew收集器\",{\"0\":{\"1725\":1}}],[\"parnew\",{\"1\":{\"1441\":1}}],[\"parsing\",{\"1\":{\"1163\":1,\"1651\":1}}],[\"parsercontext\",{\"1\":{\"1030\":2}}],[\"parsedynamictags\",{\"1\":{\"645\":1}}],[\"parse\",{\"1\":{\"429\":1,\"1022\":1}}],[\"parameters\",{\"1\":{\"1619\":4,\"1648\":1}}],[\"parametername是java8之后才存在\",{\"1\":{\"1102\":1}}],[\"parametername\",{\"1\":{\"1102\":1}}],[\"parametertype\",{\"1\":{\"1102\":1}}],[\"parametertypes\",{\"1\":{\"963\":1}}],[\"parameterized\",{\"1\":{\"1099\":1}}],[\"parameterizedtype返回\",{\"1\":{\"1100\":1}}],[\"parameterizedtype\",{\"1\":{\"1099\":9,\"1100\":1}}],[\"parameterindex\",{\"1\":{\"963\":1,\"1102\":1}}],[\"parameter\",{\"1\":{\"961\":3,\"1623\":1}}],[\"param\",{\"1\":{\"917\":5,\"921\":2,\"929\":2,\"941\":2,\"1487\":2,\"1595\":1,\"1597\":3,\"1598\":24,\"1599\":12,\"1600\":1,\"1601\":5,\"1608\":4}}],[\"parallelstream两个方法的延迟特性\",{\"1\":{\"1620\":1}}],[\"parallelstream\",{\"1\":{\"1612\":1,\"1617\":1,\"1619\":2,\"1620\":3,\"1622\":1}}],[\"parallelized\",{\"1\":{\"1608\":2}}],[\"parallelism\",{\"1\":{\"1510\":1,\"1620\":1,\"1622\":1,\"1623\":1}}],[\"parallel\",{\"0\":{\"1726\":1,\"1728\":1},\"1\":{\"460\":1,\"465\":1,\"624\":2,\"1441\":2,\"1608\":2,\"1615\":5,\"1617\":4,\"1618\":2,\"1619\":6,\"1620\":11,\"1621\":18,\"1622\":1,\"1623\":2}}],[\"partially\",{\"1\":{\"1615\":2,\"1620\":2}}],[\"partial\",{\"1\":{\"1615\":2}}],[\"participate\",{\"1\":{\"1172\":1}}],[\"particular\",{\"1\":{\"963\":1}}],[\"partition<t>\",{\"1\":{\"1618\":1}}],[\"partition<>\",{\"1\":{\"1618\":3}}],[\"partitioned\",{\"1\":{\"1615\":1,\"1620\":1}}],[\"partitioningby\",{\"1\":{\"1613\":1,\"1616\":4,\"1618\":3}}],[\"partitioning\",{\"1\":{\"425\":2,\"1620\":1}}],[\"partition\",{\"1\":{\"424\":5,\"426\":1,\"1311\":1,\"1613\":1,\"1615\":5,\"1616\":1,\"1618\":1,\"1620\":1}}],[\"partitions\",{\"1\":{\"329\":1,\"330\":5,\"361\":1,\"1615\":2}}],[\"part\",{\"1\":{\"553\":1,\"1647\":1}}],[\"parts\",{\"1\":{\"519\":2,\"553\":1,\"555\":2}}],[\"purposes\",{\"1\":{\"946\":1}}],[\"purposers\",{\"1\":{\"946\":1}}],[\"purge线程会清除掉没有用的节点\",{\"1\":{\"542\":1}}],[\"purge线程自己也维护了一个read\",{\"1\":{\"542\":1}}],[\"punsubscribe\",{\"1\":{\"597\":1}}],[\"pubsub\",{\"1\":{\"597\":1,\"598\":1,\"599\":1}}],[\"publisher<\",{\"1\":{\"1655\":2}}],[\"publisher\",{\"1\":{\"1328\":1}}],[\"published\",{\"1\":{\"1162\":1}}],[\"publishevent方法\",{\"1\":{\"1118\":1}}],[\"publishevent\",{\"1\":{\"1115\":2,\"1118\":1,\"1119\":1,\"1120\":4,\"1123\":2,\"1172\":1,\"1173\":1,\"1174\":1,\"1175\":1}}],[\"publish\",{\"1\":{\"596\":1,\"597\":1,\"598\":2,\"922\":1,\"1170\":1,\"1172\":1,\"1175\":1,\"1647\":1}}],[\"public\",{\"1\":{\"582\":4,\"583\":2,\"645\":1,\"909\":7,\"917\":13,\"918\":9,\"919\":2,\"921\":5,\"922\":1,\"927\":2,\"928\":3,\"929\":5,\"930\":9,\"931\":8,\"933\":7,\"934\":2,\"936\":2,\"940\":3,\"943\":4,\"944\":3,\"946\":11,\"952\":3,\"953\":14,\"954\":4,\"955\":3,\"956\":3,\"957\":4,\"961\":15,\"962\":2,\"963\":5,\"964\":2,\"965\":1,\"966\":2,\"967\":4,\"973\":4,\"977\":3,\"978\":2,\"985\":20,\"989\":11,\"994\":2,\"995\":2,\"996\":1,\"997\":3,\"998\":1,\"1000\":3,\"1001\":6,\"1002\":2,\"1003\":9,\"1005\":16,\"1006\":5,\"1007\":3,\"1008\":1,\"1009\":1,\"1011\":4,\"1012\":3,\"1019\":3,\"1021\":1,\"1022\":3,\"1023\":1,\"1029\":2,\"1030\":5,\"1031\":3,\"1032\":7,\"1040\":2,\"1041\":2,\"1043\":10,\"1044\":3,\"1045\":4,\"1053\":4,\"1056\":3,\"1061\":3,\"1063\":2,\"1064\":4,\"1065\":6,\"1072\":4,\"1075\":2,\"1082\":4,\"1084\":7,\"1091\":4,\"1099\":2,\"1100\":5,\"1103\":3,\"1108\":5,\"1112\":3,\"1113\":7,\"1114\":1,\"1115\":1,\"1116\":3,\"1119\":8,\"1120\":5,\"1123\":7,\"1134\":4,\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":11,\"1139\":7,\"1146\":2,\"1148\":4,\"1149\":3,\"1156\":2,\"1157\":2,\"1166\":1,\"1173\":1,\"1174\":7,\"1175\":3,\"1181\":3,\"1182\":3,\"1184\":18,\"1191\":2,\"1192\":2,\"1193\":2,\"1194\":2,\"1195\":2,\"1288\":1,\"1347\":1,\"1365\":2,\"1368\":2,\"1387\":2,\"1388\":2,\"1404\":6,\"1476\":2,\"1479\":2,\"1480\":1,\"1482\":6,\"1485\":2,\"1486\":1,\"1487\":3,\"1500\":1,\"1501\":1,\"1502\":4,\"1503\":4,\"1520\":1,\"1521\":2,\"1535\":3,\"1546\":6,\"1549\":1,\"1551\":4,\"1553\":1,\"1554\":1,\"1557\":3,\"1573\":2,\"1575\":14,\"1587\":1,\"1588\":1,\"1591\":8,\"1592\":3,\"1593\":12,\"1594\":11,\"1595\":16,\"1597\":6,\"1598\":29,\"1599\":16,\"1600\":15,\"1601\":6,\"1602\":2,\"1603\":11,\"1604\":7,\"1605\":15,\"1606\":6,\"1607\":30,\"1608\":8,\"1609\":27,\"1610\":16,\"1612\":6,\"1613\":19,\"1614\":6,\"1615\":2,\"1616\":5,\"1617\":24,\"1618\":18,\"1619\":9,\"1620\":22,\"1621\":4,\"1622\":5,\"1623\":7,\"1638\":5,\"1639\":5,\"1644\":3,\"1645\":2,\"1646\":2,\"1647\":3,\"1648\":7,\"1650\":2,\"1651\":4,\"1654\":12,\"1657\":4,\"1689\":1}}],[\"pub\",{\"1\":{\"596\":2}}],[\"pushes\",{\"1\":{\"1623\":1}}],[\"push\",{\"1\":{\"571\":1}}],[\"pushdown\",{\"1\":{\"340\":1}}],[\"put顺序依次为5\",{\"1\":{\"1550\":1}}],[\"puttreeval\",{\"1\":{\"1549\":1,\"1554\":1}}],[\"putval\",{\"1\":{\"1549\":2,\"1554\":4}}],[\"put方法的整体执行过程如下图\",{\"1\":{\"1549\":1}}],[\"put方法\",{\"0\":{\"1549\":1}}],[\"putlock\",{\"1\":{\"1503\":10}}],[\"put锁会会阻塞在notfull上\",{\"1\":{\"1503\":1}}],[\"put锁\",{\"1\":{\"1503\":1}}],[\"putindex指针到数组尽头了\",{\"1\":{\"1502\":1}}],[\"putindex\",{\"1\":{\"1502\":3}}],[\"put的流程图\",{\"1\":{\"1475\":1}}],[\"put非null元素后get出来的却是null\",{\"1\":{\"1364\":1}}],[\"put需要对一个具体的资源进行操作\",{\"1\":{\"306\":1}}],[\"put\",{\"1\":{\"305\":3,\"306\":9,\"309\":4,\"582\":2,\"975\":1,\"989\":1,\"996\":3,\"997\":1,\"1031\":1,\"1072\":10,\"1156\":2,\"1365\":1,\"1368\":1,\"1501\":3,\"1502\":1,\"1503\":1,\"1535\":1,\"1546\":1,\"1549\":1,\"1551\":3,\"1553\":3,\"1554\":1,\"1557\":1,\"1574\":2,\"1575\":2,\"1617\":1,\"1618\":1,\"1638\":1,\"1647\":2,\"1648\":1}}],[\"pms\",{\"1\":{\"329\":2,\"330\":10}}],[\"p后面写在命令行中\",{\"1\":{\"318\":1}}],[\"p\",{\"1\":{\"318\":1,\"424\":5,\"542\":3,\"577\":1,\"1479\":2,\"1549\":10,\"1551\":1,\"1554\":4,\"1599\":2,\"1617\":2,\"1622\":4,\"1623\":3}}],[\"pr\",{\"1\":{\"1655\":3}}],[\"practical\",{\"1\":{\"1620\":1}}],[\"prune\",{\"1\":{\"556\":1}}],[\"pretenuresizethreshold=1000000\",{\"1\":{\"1669\":1}}],[\"prehandle\",{\"1\":{\"1657\":2}}],[\"pre>\",{\"1\":{\"1595\":1,\"1608\":3}}],[\"predefined\",{\"1\":{\"1615\":1,\"1616\":1}}],[\"predestory\",{\"1\":{\"933\":1,\"966\":1,\"1012\":1,\"1023\":1}}],[\"predestory标注方法\",{\"1\":{\"933\":1,\"1012\":1}}],[\"predestroy\",{\"1\":{\"933\":3,\"966\":1,\"985\":1,\"1012\":4}}],[\"predicate2\",{\"1\":{\"1599\":6}}],[\"predicate中除了抽象方法test\",{\"1\":{\"1599\":1}}],[\"predicate在集合与stream中有大量的应用\",{\"1\":{\"1599\":1}}],[\"predicatetest3\",{\"1\":{\"1599\":5}}],[\"predicatetest2\",{\"1\":{\"1599\":19}}],[\"predicatetest\",{\"1\":{\"1599\":1}}],[\"predicate代表了一个接收一个参数\",{\"1\":{\"1599\":1}}],[\"predicate这个单词本身是谓词\",{\"1\":{\"1599\":1}}],[\"predicate也是一个重要的函数式接口\",{\"1\":{\"1599\":1}}],[\"predicate\",{\"1\":{\"1599\":87,\"1618\":4,\"1619\":2}}],[\"predicate函数式接口\",{\"0\":{\"1599\":1}}],[\"predicate<date>\",{\"1\":{\"1599\":1}}],[\"predicate<integer>\",{\"1\":{\"1599\":8}}],[\"predicate<string>\",{\"1\":{\"1599\":1}}],[\"predicate<\",{\"1\":{\"1594\":2,\"1599\":4,\"1618\":2}}],[\"predicate<t>\",{\"1\":{\"1594\":5,\"1599\":9}}],[\"pred\",{\"1\":{\"1554\":2}}],[\"pre\",{\"1\":{\"1162\":2,\"1175\":1,\"1283\":1}}],[\"preinstantiatesingtons\",{\"1\":{\"1017\":1}}],[\"preinstantiatesingletons将已注册的beandefinition初始化成spring\",{\"1\":{\"1009\":1}}],[\"preinstantiatesingletons\",{\"1\":{\"1009\":3,\"1011\":1,\"1171\":1,\"1647\":1}}],[\"precedence\",{\"1\":{\"966\":1,\"967\":1}}],[\"preserve\",{\"1\":{\"1619\":1,\"1620\":1}}],[\"preservation\",{\"1\":{\"1618\":1}}],[\"preserving\",{\"1\":{\"1617\":1}}],[\"presenting\",{\"1\":{\"1621\":1}}],[\"presented\",{\"1\":{\"1618\":1}}],[\"present\",{\"1\":{\"1368\":2,\"1557\":2,\"1594\":3,\"1613\":1,\"1618\":1}}],[\"presumed\",{\"1\":{\"1615\":1}}],[\"pressed\",{\"1\":{\"1591\":3}}],[\"press\",{\"1\":{\"598\":1}}],[\"presistent的值默认是on\",{\"1\":{\"558\":1}}],[\"presistent的值默认是off\",{\"1\":{\"558\":1}}],[\"presistent来控制到底采用哪种方式去存储统计数据\",{\"1\":{\"558\":1}}],[\"previously\",{\"1\":{\"1647\":1}}],[\"previousstage\",{\"1\":{\"1621\":2,\"1622\":9,\"1623\":2}}],[\"previousinjectionpoint\",{\"1\":{\"963\":2,\"1648\":2}}],[\"previous\",{\"1\":{\"580\":1,\"997\":4,\"1483\":1,\"1615\":1,\"1621\":1,\"1647\":4}}],[\"preferred\",{\"1\":{\"1650\":1}}],[\"preferable\",{\"1\":{\"1620\":1}}],[\"preferencechangelistener\",{\"1\":{\"1109\":1}}],[\"preferencechangeevent\",{\"1\":{\"1109\":1}}],[\"preference\",{\"1\":{\"1109\":1,\"1620\":1}}],[\"prefs\",{\"1\":{\"1109\":2}}],[\"prefix\",{\"1\":{\"519\":2,\"553\":1,\"555\":2,\"928\":2,\"1022\":2,\"1618\":2,\"1620\":1,\"1647\":2}}],[\"preformance\",{\"1\":{\"479\":1}}],[\"prepassivate\",{\"1\":{\"1110\":1}}],[\"prepaer阶段\",{\"1\":{\"465\":1}}],[\"preparation\",{\"1\":{\"519\":2,\"1621\":1}}],[\"preparing\",{\"1\":{\"431\":1}}],[\"preparetransactioninfo\",{\"1\":{\"1655\":1}}],[\"preparemethodoverrides\",{\"1\":{\"1647\":1}}],[\"preparebeanfactory中\",{\"1\":{\"1005\":1}}],[\"preparebeanfactory\",{\"1\":{\"922\":1,\"1164\":2,\"1647\":1,\"1651\":1}}],[\"preparerefresh方法\",{\"1\":{\"1162\":1}}],[\"preparerefresh\",{\"1\":{\"922\":1,\"1162\":1,\"1647\":1,\"1651\":1}}],[\"prepare阶段\",{\"1\":{\"451\":1}}],[\"prepare\",{\"1\":{\"422\":2,\"922\":2,\"1164\":1,\"1165\":1,\"1647\":3}}],[\"prepare和commit\",{\"1\":{\"326\":1}}],[\"prioritizedparameternamediscoverer\",{\"1\":{\"1648\":1}}],[\"priority注解\",{\"1\":{\"1648\":1}}],[\"priorityblockingqueue即使在指定了初始容量之后\",{\"1\":{\"1509\":1}}],[\"priorityblockingqueue\",{\"0\":{\"1506\":1},\"1\":{\"1395\":1,\"1501\":2}}],[\"priorityorderedpostprocessors\",{\"1\":{\"1166\":4}}],[\"priorityordered\",{\"1\":{\"1166\":3,\"1648\":1}}],[\"priority\",{\"1\":{\"421\":1,\"520\":4,\"1648\":1}}],[\"prior\",{\"1\":{\"1620\":2}}],[\"privilegedaction<boolean>\",{\"1\":{\"1647\":1}}],[\"privilegedaction<object>\",{\"1\":{\"1008\":1,\"1647\":1}}],[\"privilegedactionexception\",{\"1\":{\"1007\":1}}],[\"privilegedexceptionaction<object>\",{\"1\":{\"1007\":1}}],[\"private\",{\"1\":{\"583\":1,\"917\":8,\"918\":3,\"921\":2,\"930\":1,\"940\":1,\"941\":2,\"943\":3,\"944\":5,\"952\":1,\"953\":1,\"955\":2,\"956\":2,\"957\":2,\"961\":11,\"962\":3,\"963\":16,\"964\":1,\"965\":2,\"967\":2,\"973\":5,\"975\":2,\"977\":1,\"978\":4,\"985\":19,\"989\":4,\"998\":1,\"1001\":1,\"1003\":3,\"1005\":9,\"1025\":1,\"1027\":1,\"1030\":1,\"1044\":4,\"1045\":2,\"1061\":1,\"1063\":1,\"1065\":1,\"1100\":1,\"1103\":1,\"1113\":1,\"1116\":1,\"1120\":2,\"1148\":3,\"1149\":1,\"1156\":1,\"1157\":2,\"1174\":1,\"1181\":2,\"1184\":5,\"1191\":2,\"1192\":2,\"1193\":2,\"1194\":3,\"1227\":1,\"1368\":2,\"1387\":2,\"1388\":2,\"1404\":5,\"1456\":2,\"1475\":1,\"1482\":2,\"1502\":4,\"1503\":11,\"1506\":1,\"1535\":1,\"1542\":1,\"1551\":1,\"1554\":2,\"1557\":1,\"1573\":1,\"1574\":3,\"1575\":2,\"1600\":2,\"1603\":3,\"1605\":3,\"1613\":5,\"1614\":2,\"1616\":5,\"1617\":1,\"1618\":1,\"1620\":4,\"1621\":6,\"1638\":1,\"1647\":1,\"1648\":2}}],[\"primarily\",{\"1\":{\"1171\":1,\"1619\":1}}],[\"primary注解\",{\"1\":{\"1648\":2}}],[\"primary等等\",{\"1\":{\"1027\":1}}],[\"primary=true\",{\"1\":{\"963\":1}}],[\"primary=\",{\"1\":{\"917\":1}}],[\"primary索引\",{\"1\":{\"558\":1}}],[\"primary选举等\",{\"1\":{\"304\":1}}],[\"primary\",{\"1\":{\"304\":3,\"306\":3,\"323\":1,\"330\":4,\"335\":2,\"336\":1,\"338\":1,\"346\":1,\"349\":1,\"353\":1,\"361\":1,\"362\":2,\"363\":1,\"366\":1,\"368\":1,\"378\":1,\"400\":1,\"404\":1,\"407\":1,\"412\":1,\"413\":1,\"414\":1,\"419\":1,\"446\":1,\"454\":1,\"459\":1,\"462\":2,\"467\":1,\"468\":1,\"476\":1,\"478\":1,\"489\":1,\"494\":3,\"506\":3,\"510\":1,\"518\":1,\"519\":1,\"523\":1,\"534\":1,\"535\":1,\"943\":1,\"961\":3,\"1027\":1,\"1056\":1,\"1620\":1,\"1633\":1,\"1648\":1}}],[\"primitive\",{\"1\":{\"959\":1,\"1619\":1,\"1620\":14,\"1621\":1,\"1623\":1}}],[\"printstream\",{\"1\":{\"1605\":1}}],[\"printstacktrace\",{\"1\":{\"944\":1,\"989\":1,\"1013\":1,\"1082\":1,\"1084\":1,\"1387\":1,\"1404\":11,\"1535\":2,\"1573\":4,\"1574\":3,\"1575\":4}}],[\"printwriter\",{\"1\":{\"1573\":4}}],[\"print\",{\"1\":{\"1485\":1,\"1605\":1}}],[\"printable\",{\"1\":{\"1113\":2}}],[\"printf\",{\"1\":{\"946\":1,\"985\":1,\"989\":1,\"1022\":1,\"1029\":1,\"1031\":1,\"1100\":2,\"1113\":1,\"1116\":1,\"1119\":1,\"1123\":1,\"1156\":1,\"1157\":1,\"1175\":1}}],[\"printbeansexception\",{\"1\":{\"944\":6}}],[\"println\",{\"1\":{\"582\":3,\"583\":1,\"909\":1,\"917\":5,\"918\":4,\"919\":2,\"921\":3,\"929\":2,\"930\":7,\"931\":3,\"933\":7,\"934\":2,\"936\":1,\"940\":1,\"941\":2,\"943\":4,\"944\":3,\"953\":3,\"954\":1,\"955\":3,\"957\":2,\"961\":11,\"962\":4,\"963\":1,\"973\":5,\"977\":1,\"978\":3,\"985\":12,\"989\":1,\"994\":2,\"995\":2,\"997\":3,\"1000\":3,\"1001\":4,\"1005\":8,\"1006\":4,\"1007\":3,\"1009\":1,\"1011\":5,\"1012\":3,\"1013\":1,\"1019\":1,\"1022\":1,\"1030\":1,\"1031\":1,\"1032\":2,\"1040\":1,\"1041\":1,\"1043\":1,\"1044\":3,\"1045\":2,\"1053\":5,\"1056\":1,\"1063\":1,\"1064\":2,\"1065\":2,\"1072\":3,\"1075\":2,\"1082\":1,\"1084\":1,\"1099\":3,\"1100\":1,\"1103\":2,\"1108\":1,\"1112\":1,\"1113\":6,\"1114\":1,\"1134\":1,\"1138\":1,\"1139\":1,\"1146\":1,\"1148\":4,\"1149\":2,\"1156\":1,\"1157\":1,\"1174\":2,\"1175\":1,\"1181\":5,\"1182\":2,\"1184\":2,\"1365\":2,\"1387\":1,\"1404\":8,\"1485\":2,\"1487\":1,\"1551\":2,\"1573\":5,\"1574\":3,\"1575\":3,\"1587\":1,\"1588\":1,\"1591\":6,\"1592\":3,\"1593\":7,\"1594\":1,\"1595\":13,\"1597\":2,\"1598\":12,\"1599\":7,\"1600\":5,\"1601\":2,\"1602\":1,\"1603\":4,\"1604\":4,\"1605\":5,\"1606\":2,\"1607\":9,\"1608\":2,\"1609\":10,\"1610\":17,\"1611\":2,\"1612\":6,\"1614\":1,\"1615\":2,\"1616\":8,\"1617\":18,\"1619\":11,\"1620\":3,\"1622\":3,\"1632\":1,\"1633\":1,\"1634\":1,\"1635\":1,\"1638\":1,\"1640\":1,\"1646\":2,\"1654\":4}}],[\"principle\",{\"1\":{\"905\":1}}],[\"pri\",{\"1\":{\"330\":1}}],[\"prompt\",{\"1\":{\"1619\":1}}],[\"promotion\",{\"1\":{\"1614\":1}}],[\"promise\",{\"0\":{\"699\":1}}],[\"proxies\",{\"1\":{\"1166\":1}}],[\"proxytransactionmanagementconfiguration是一个配置类\",{\"1\":{\"1655\":1}}],[\"proxytransactionmanagementconfiguration\",{\"1\":{\"1655\":2}}],[\"proxytest\",{\"1\":{\"1654\":1}}],[\"proxybeanmethods\",{\"1\":{\"1652\":1}}],[\"proxy\",{\"1\":{\"1647\":1,\"1654\":6}}],[\"proxyfactorybean\",{\"0\":{\"807\":1}}],[\"proxyfactory\",{\"0\":{\"806\":1},\"1\":{\"1654\":7}}],[\"proxycreatorsupport\",{\"0\":{\"804\":1}}],[\"proxy也需要有高可用架构\",{\"1\":{\"469\":1}}],[\"programmercarl\",{\"1\":{\"1972\":1}}],[\"programming\",{\"1\":{\"900\":1}}],[\"programing\",{\"1\":{\"900\":2}}],[\"protocolhandler内部又分为endpoint和processor模块\",{\"1\":{\"1688\":1}}],[\"protocolhandler组件\",{\"0\":{\"1688\":1}}],[\"protocol\",{\"1\":{\"1049\":3,\"1419\":2,\"1620\":1}}],[\"prototypeinstance\",{\"1\":{\"1647\":3}}],[\"prototype的bean在被容器创建之后就会与容器脱钩\",{\"1\":{\"1182\":1}}],[\"prototype不会被缓存\",{\"1\":{\"1182\":1}}],[\"prototypeuser是每次依赖查找都会生成新的bean对象\",{\"1\":{\"985\":1}}],[\"prototypeuser3\",{\"1\":{\"985\":1}}],[\"prototypeuser2\",{\"1\":{\"985\":5}}],[\"prototypeuser1\",{\"1\":{\"985\":5}}],[\"prototypeuser\",{\"1\":{\"985\":16}}],[\"prototype作用域\",{\"0\":{\"985\":1}}],[\"prototype\",{\"1\":{\"983\":1,\"985\":4,\"991\":1,\"1182\":2,\"1235\":1,\"1647\":1}}],[\"prototype等\",{\"1\":{\"927\":1}}],[\"proto文件\",{\"0\":{\"667\":1}}],[\"protobuf\",{\"0\":{\"665\":1}}],[\"protected和default这些修饰符\",{\"1\":{\"1345\":1}}],[\"protected\",{\"1\":{\"645\":1,\"928\":1,\"934\":1,\"964\":1,\"995\":1,\"997\":1,\"1000\":1,\"1007\":1,\"1008\":1,\"1009\":1,\"1013\":1,\"1030\":2,\"1055\":1,\"1121\":1,\"1124\":1,\"1162\":1,\"1163\":1,\"1164\":1,\"1165\":1,\"1167\":1,\"1168\":1,\"1170\":1,\"1171\":1,\"1172\":1,\"1175\":1,\"1227\":1,\"1432\":1,\"1623\":1,\"1647\":9,\"1648\":2,\"1650\":1,\"1651\":1,\"1655\":1,\"1658\":1,\"1663\":1}}],[\"producing\",{\"1\":{\"1601\":2,\"1609\":1}}],[\"producer消息发送重试\",{\"0\":{\"1929\":1}}],[\"producerthreads\",{\"1\":{\"1535\":2}}],[\"producertype\",{\"1\":{\"1520\":2,\"1521\":1}}],[\"produce\",{\"1\":{\"1615\":5,\"1618\":1,\"1619\":2,\"1620\":1,\"1623\":1}}],[\"produces\",{\"1\":{\"1598\":3,\"1608\":2,\"1618\":3,\"1619\":1,\"1623\":2}}],[\"produced\",{\"1\":{\"553\":1,\"555\":2,\"1609\":1,\"1618\":1,\"1620\":1,\"1621\":1}}],[\"producttype\",{\"1\":{\"1520\":1}}],[\"product\",{\"1\":{\"330\":2}}],[\"providing\",{\"1\":{\"1622\":1}}],[\"provide\",{\"1\":{\"1615\":2,\"1619\":1,\"1620\":2,\"1623\":1}}],[\"provided\",{\"1\":{\"1609\":1,\"1619\":1,\"1620\":1,\"1623\":9}}],[\"provider\",{\"1\":{\"1065\":1}}],[\"provides\",{\"1\":{\"519\":1,\"1615\":1,\"1620\":4}}],[\"province\",{\"1\":{\"309\":1}}],[\"proper\",{\"1\":{\"1647\":1}}],[\"properly\",{\"1\":{\"1615\":1}}],[\"propertyresolver\",{\"1\":{\"1159\":1}}],[\"propertyresourcebundle\",{\"1\":{\"1052\":1}}],[\"propertyplaceholderconfigurerdemo\",{\"1\":{\"1146\":1}}],[\"propertyplaceholderconfigurer\",{\"1\":{\"1146\":2}}],[\"propertypath\",{\"1\":{\"1084\":1}}],[\"propertychangelistener\",{\"1\":{\"1109\":1}}],[\"propertychangeevent\",{\"1\":{\"1109\":1}}],[\"propertyeditor仅仅支持string类型转换成其他的类型\",{\"1\":{\"1639\":1}}],[\"propertyeditormap\",{\"1\":{\"1638\":3}}],[\"propertyeditor>>\",{\"1\":{\"1638\":1}}],[\"propertyeditor是jdk中提供的类型转化工具类\",{\"1\":{\"1638\":1}}],[\"propertyeditor接口实现\",{\"1\":{\"1095\":1}}],[\"propertyeditor接口职责太多\",{\"1\":{\"1085\":1}}],[\"propertyeditor实现\",{\"1\":{\"1093\":1}}],[\"propertyeditor实现缺少类型安全\",{\"1\":{\"1085\":1}}],[\"propertyeditor实现类型局限\",{\"1\":{\"1085\":1}}],[\"propertyeditor的局限性\",{\"0\":{\"1085\":1}}],[\"propertyeditorregistrysupport\",{\"1\":{\"1093\":2}}],[\"propertyeditorregistry注册自定义propertyeditor实现\",{\"1\":{\"1084\":1}}],[\"propertyeditorregistry\",{\"1\":{\"1084\":2}}],[\"propertyeditorregistrar\",{\"1\":{\"1084\":2}}],[\"propertyeditors\",{\"1\":{\"1083\":7}}],[\"propertyeditorsupport类\",{\"1\":{\"1084\":1}}],[\"propertyeditorsupport\",{\"1\":{\"1082\":1,\"1084\":1,\"1638\":1}}],[\"propertyeditordemo\",{\"1\":{\"1082\":1}}],[\"propertyeditor扩展\",{\"1\":{\"1080\":1}}],[\"propertyeditor\",{\"0\":{\"1638\":1},\"1\":{\"1073\":2,\"1082\":7,\"1084\":5,\"1093\":1,\"1152\":1}}],[\"propertyvalue包含属性名称\",{\"1\":{\"1071\":1}}],[\"propertyvalue\",{\"1\":{\"1003\":1,\"1019\":1}}],[\"propertyvalue是不可变的\",{\"1\":{\"1003\":1}}],[\"propertyvalues存在一个嵌套属性\",{\"1\":{\"1072\":2}}],[\"propertyvalues存在user中不存在的属性值\",{\"1\":{\"1072\":2}}],[\"propertyvalues就是从配置文件里面读入的值\",{\"1\":{\"1003\":1}}],[\"propertyvalues\",{\"1\":{\"927\":4,\"964\":3,\"1003\":16,\"1017\":1,\"1019\":1,\"1070\":1,\"1071\":1,\"1072\":4,\"1093\":2,\"1647\":2,\"1648\":2}}],[\"propertysource的配置实际上有两种类型\",{\"1\":{\"1156\":1}}],[\"propertysource实现原理\",{\"1\":{\"1155\":1}}],[\"propertysource类型\",{\"1\":{\"1154\":1}}],[\"propertysource工作原理\",{\"0\":{\"1144\":1}}],[\"propertysource<\",{\"1\":{\"1032\":1}}],[\"propertysourcefactory\",{\"1\":{\"1032\":1,\"1155\":1}}],[\"propertysource默认是没有yaml格式的实现的\",{\"1\":{\"1032\":1}}],[\"propertysourcedemo\",{\"1\":{\"1031\":1}}],[\"propertysource集合注解\",{\"1\":{\"1029\":1}}],[\"propertysource\",{\"1\":{\"978\":1,\"1017\":1,\"1029\":4,\"1031\":6,\"1032\":1,\"1144\":1,\"1145\":1,\"1153\":2,\"1156\":6,\"1157\":3}}],[\"propertysourcespropertyresolver\",{\"1\":{\"1151\":1}}],[\"propertysourcesplaceholderconfigurer\",{\"1\":{\"1146\":2,\"1171\":1}}],[\"propertysources\",{\"1\":{\"899\":1,\"1029\":2,\"1031\":2,\"1153\":2,\"1156\":3,\"1162\":1}}],[\"property\",{\"1\":{\"927\":1,\"1020\":2,\"1031\":1,\"1032\":1,\"1064\":1,\"1073\":2,\"1084\":1,\"1156\":2,\"1162\":1,\"1619\":1,\"1620\":1,\"1647\":4}}],[\"property>\",{\"1\":{\"917\":1,\"918\":1,\"989\":1,\"1084\":1,\"1091\":1}}],[\"propertytype=class\",{\"1\":{\"909\":2}}],[\"propertydescriptor并不要求setter\",{\"1\":{\"1075\":1}}],[\"propertydescriptor\",{\"1\":{\"909\":2,\"1003\":1,\"1075\":6,\"1647\":1,\"1648\":1}}],[\"properties配置属性源\",{\"1\":{\"1154\":1}}],[\"properties>\",{\"1\":{\"1091\":1}}],[\"propertiestostringconverter\",{\"1\":{\"1091\":2}}],[\"properties类型要转成string\",{\"1\":{\"1091\":1}}],[\"properties类型\",{\"1\":{\"1084\":1,\"1091\":1}}],[\"propertiesresources\",{\"1\":{\"1044\":2}}],[\"properties等\",{\"1\":{\"1035\":1}}],[\"propertiespropertysource\",{\"1\":{\"1032\":1,\"1154\":1}}],[\"propertiessource\",{\"1\":{\"1031\":3}}],[\"properties资源实现\",{\"1\":{\"1052\":1}}],[\"properties资源\",{\"1\":{\"1047\":1,\"1048\":1}}],[\"properties资源beandefinition解析与注册\",{\"1\":{\"1026\":1}}],[\"properties资源的方式\",{\"0\":{\"1026\":1}}],[\"properties资源配置\",{\"1\":{\"994\":1}}],[\"properties属性名\",{\"1\":{\"1022\":1}}],[\"propertiesbeandefinitionreaderdemo\",{\"1\":{\"1022\":1}}],[\"propertiesbeandefinitionreader\",{\"1\":{\"994\":4,\"1022\":3,\"1024\":1,\"1026\":1}}],[\"properties对象\",{\"1\":{\"945\":1}}],[\"properties\",{\"1\":{\"309\":1,\"927\":2,\"952\":3,\"959\":1,\"960\":1,\"978\":1,\"994\":1,\"1022\":5,\"1024\":1,\"1026\":1,\"1029\":2,\"1031\":1,\"1032\":1,\"1035\":1,\"1044\":2,\"1048\":1,\"1063\":2,\"1074\":1,\"1082\":5,\"1084\":9,\"1091\":7,\"1146\":2,\"1156\":1,\"1157\":2,\"1162\":1,\"1164\":3,\"1615\":1,\"1620\":1,\"1647\":1}}],[\"propotype\",{\"1\":{\"1240\":1}}],[\"prop>\",{\"1\":{\"1091\":2}}],[\"props\",{\"1\":{\"1022\":4}}],[\"propagatecompletion\",{\"1\":{\"1620\":1}}],[\"propagate\",{\"1\":{\"922\":1,\"1172\":1,\"1490\":1,\"1647\":1,\"1651\":1}}],[\"propagation\",{\"1\":{\"519\":2,\"1238\":7}}],[\"profiling=on\",{\"1\":{\"431\":1}}],[\"profiling\",{\"1\":{\"431\":3}}],[\"profile在spring\",{\"1\":{\"1139\":1}}],[\"profiledemo\",{\"1\":{\"1139\":2}}],[\"profile基于\",{\"1\":{\"1139\":1}}],[\"profilecondition\",{\"1\":{\"1023\":1,\"1139\":2}}],[\"profile注解的示例\",{\"1\":{\"1139\":1}}],[\"profile注解的\",{\"1\":{\"1023\":1}}],[\"profile查询列表\",{\"1\":{\"431\":1}}],[\"profile查询参数备注\",{\"1\":{\"431\":1}}],[\"profile查询sql在mysql数据库中的执行细节和生命周期情况\",{\"1\":{\"430\":1}}],[\"profile中看到一条sql中完整的生命周期\",{\"1\":{\"431\":1}}],[\"profiles信息\",{\"1\":{\"1144\":1}}],[\"profiles配置值\",{\"1\":{\"1020\":1}}],[\"profiles\",{\"0\":{\"1147\":1},\"1\":{\"431\":2,\"1023\":1,\"1139\":1,\"1147\":2}}],[\"profile功能\",{\"1\":{\"431\":2}}],[\"profile功能是否开启\",{\"1\":{\"431\":1}}],[\"profile是什么\",{\"1\":{\"431\":1}}],[\"profile\",{\"0\":{\"431\":1},\"1\":{\"430\":1,\"431\":3,\"1017\":2,\"1020\":1,\"1023\":2,\"1035\":1,\"1139\":4,\"1147\":1}}],[\"proceedwithinvocation\",{\"1\":{\"1655\":2}}],[\"processes\",{\"1\":{\"1623\":1}}],[\"processed\",{\"1\":{\"1166\":1,\"1595\":2,\"1615\":2,\"1620\":1}}],[\"processedevents\",{\"1\":{\"1116\":2}}],[\"processpropertysource\",{\"1\":{\"1155\":1}}],[\"processuser\",{\"1\":{\"1065\":2}}],[\"processcommondefinitionannotations\",{\"1\":{\"1027\":2,\"1647\":1}}],[\"processor负责应用层协议解析\",{\"1\":{\"1688\":1}}],[\"processor负责提供tomcat\",{\"1\":{\"1687\":1}}],[\"processor和adapter\",{\"1\":{\"1687\":1}}],[\"processor\",{\"1\":{\"967\":3,\"1006\":2,\"1164\":1,\"1166\":2,\"1172\":2}}],[\"processors\",{\"1\":{\"922\":2,\"1170\":1,\"1647\":3}}],[\"processon\",{\"1\":{\"639\":1,\"645\":1,\"1494\":1,\"1499\":1,\"1652\":1,\"1653\":1,\"1657\":1}}],[\"process\",{\"1\":{\"900\":1,\"922\":1,\"1620\":1,\"1647\":2,\"1651\":1}}],[\"processing\",{\"1\":{\"519\":4,\"922\":1,\"1620\":2,\"1623\":2,\"1647\":2}}],[\"processlist里看到两个相同的thread\",{\"1\":{\"498\":1}}],[\"processlist结果上看也是command\",{\"1\":{\"481\":1}}],[\"processlist的时候\",{\"1\":{\"481\":2}}],[\"processlist的结果里看到的几千个连接\",{\"1\":{\"476\":1}}],[\"processlist\",{\"1\":{\"481\":1}}],[\"processlist命令\",{\"1\":{\"480\":1}}],[\"processlist命令中看到它\",{\"1\":{\"318\":1}}],[\"procedure\",{\"1\":{\"400\":2,\"404\":2,\"414\":1,\"419\":1,\"518\":2,\"523\":4}}],[\"phase\",{\"1\":{\"996\":1,\"1647\":1}}],[\"phantom\",{\"1\":{\"433\":1,\"532\":1,\"1435\":1}}],[\"phone\",{\"1\":{\"363\":2}}],[\"phrase\",{\"1\":{\"308\":1}}],[\"php\",{\"1\":{\"306\":1}}],[\"pom\",{\"1\":{\"1980\":2}}],[\"population\",{\"1\":{\"1647\":1}}],[\"populatedefaults中看到\",{\"1\":{\"1020\":1}}],[\"populatebean\",{\"1\":{\"1017\":3,\"1647\":2}}],[\"populate\",{\"1\":{\"1002\":1}}],[\"poor\",{\"1\":{\"1620\":1}}],[\"pool连接池\",{\"1\":{\"583\":1}}],[\"pool在这段时间内\",{\"1\":{\"406\":1}}],[\"pool\",{\"1\":{\"345\":1,\"1123\":2}}],[\"pool里的内存\",{\"1\":{\"343\":1}}],[\"pool的热数据被淘汰\",{\"1\":{\"406\":1}}],[\"pool的正常运作\",{\"1\":{\"406\":1}}],[\"pool的命中率影响就不大\",{\"1\":{\"406\":1}}],[\"pool的lru算法做了优化\",{\"1\":{\"406\":1}}],[\"pool的50\",{\"1\":{\"343\":1}}],[\"pool的\",{\"1\":{\"343\":1}}],[\"policy\",{\"1\":{\"1620\":2}}],[\"poll返回后\",{\"1\":{\"1570\":1}}],[\"poll使用一个pollfd的指针实现\",{\"1\":{\"1570\":1}}],[\"pollfd结构包含了要监视的event和发生的event\",{\"1\":{\"1570\":1}}],[\"pollfd\",{\"1\":{\"1570\":2}}],[\"poll和epoll都是io多路复用的机制\",{\"1\":{\"1568\":1}}],[\"poll机制\",{\"1\":{\"1423\":1}}],[\"poll\",{\"0\":{\"93\":1,\"1423\":1,\"1568\":1,\"1570\":1},\"1\":{\"1423\":3,\"1500\":1,\"1501\":5,\"1561\":1,\"1565\":2,\"1568\":1,\"1570\":1,\"1623\":1}}],[\"power\",{\"1\":{\"1480\":1,\"1620\":1}}],[\"pojo\",{\"1\":{\"946\":2}}],[\"points\",{\"1\":{\"1623\":1}}],[\"point\",{\"1\":{\"1171\":1,\"1620\":2,\"1621\":1,\"1623\":1,\"1647\":2,\"1650\":1,\"1654\":1}}],[\"pointcutadvisor\",{\"1\":{\"1654\":6}}],[\"pointcutadvisor接口\",{\"0\":{\"794\":1}}],[\"pointcut\",{\"0\":{\"787\":1,\"820\":1},\"1\":{\"1654\":3}}],[\"pointcut便利实现\",{\"0\":{\"786\":1}}],[\"pointcut组合实现\",{\"0\":{\"785\":1}}],[\"pointcut指令与表达式\",{\"0\":{\"765\":1}}],[\"pointer\",{\"1\":{\"542\":1,\"1484\":1,\"1602\":1}}],[\"portion\",{\"1\":{\"1621\":1}}],[\"port是用来和旧的master和新的master\",{\"1\":{\"624\":1}}],[\"port>\",{\"1\":{\"624\":3}}],[\"port\",{\"1\":{\"624\":3,\"1226\":2,\"1573\":6,\"1574\":4,\"1575\":4}}],[\"port就可以为从机配置主机了\",{\"1\":{\"610\":1}}],[\"port=6379\",{\"1\":{\"583\":1}}],[\"port=$port\",{\"1\":{\"467\":1,\"468\":1}}],[\"pong\",{\"1\":{\"582\":1}}],[\"potential\",{\"1\":{\"519\":2,\"1620\":1,\"1621\":1,\"1647\":1}}],[\"possibly\",{\"1\":{\"963\":1,\"1620\":1}}],[\"possible\",{\"1\":{\"329\":2,\"330\":7,\"361\":1,\"390\":2,\"553\":1,\"555\":2,\"1619\":1,\"1620\":1}}],[\"pos这两组值完全相同\",{\"1\":{\"472\":1}}],[\"pos这两个参数了\",{\"1\":{\"468\":1}}],[\"pos这个位置的日志继续同步\",{\"1\":{\"467\":1}}],[\"pos的值并不精确\",{\"1\":{\"467\":1}}],[\"pos的值\",{\"1\":{\"467\":1}}],[\"pos后面的值\",{\"1\":{\"467\":1}}],[\"pos=$master\",{\"1\":{\"467\":1}}],[\"pos\",{\"1\":{\"371\":2,\"467\":1,\"472\":3,\"473\":4}}],[\"pos字段索引失效\",{\"1\":{\"370\":1,\"372\":1}}],[\"pos字段\",{\"1\":{\"370\":1,\"372\":1}}],[\"pos索引中的name\",{\"1\":{\"370\":2,\"372\":2}}],[\"pos索引中的name字段\",{\"1\":{\"370\":2}}],[\"pos追上了checkpoint\",{\"1\":{\"324\":1}}],[\"pos和checkpoint之间还空着的部分\",{\"1\":{\"324\":1}}],[\"pos是当前记录的位置\",{\"1\":{\"324\":1}}],[\"position`\",{\"1\":{\"510\":1,\"518\":1}}],[\"position从误操作之后的日志继续执行\",{\"1\":{\"485\":1}}],[\"position参数执行到误操作之前的日志\",{\"1\":{\"485\":1}}],[\"position=1就表示这个主备关系使用的是gtid协议\",{\"1\":{\"468\":1}}],[\"position=1\",{\"1\":{\"468\":1,\"472\":1}}],[\"position=2973\",{\"1\":{\"454\":1}}],[\"position=2738\",{\"1\":{\"454\":1}}],[\"position=8900\",{\"1\":{\"454\":1}}],[\"position\",{\"1\":{\"308\":1,\"473\":1,\"510\":3,\"518\":6,\"519\":5,\"520\":4,\"1609\":3}}],[\"posthandle\",{\"1\":{\"1657\":2}}],[\"post请求可以带请求体\",{\"1\":{\"1201\":1}}],[\"postpersist\",{\"1\":{\"1110\":1}}],[\"postprocessed\",{\"1\":{\"1647\":2}}],[\"postprocessinglock\",{\"1\":{\"1647\":1}}],[\"postprocessornames\",{\"1\":{\"1166\":3}}],[\"postprocessorregistrationdelegate\",{\"1\":{\"1165\":1}}],[\"postprocesspropertyvalues\",{\"1\":{\"1003\":2,\"1647\":1}}],[\"postprocessproperties\",{\"1\":{\"964\":1,\"1003\":3,\"1071\":1,\"1647\":2,\"1648\":1}}],[\"postprocessafterinstantiation\",{\"1\":{\"1002\":2,\"1647\":2}}],[\"postprocessafterinitialization\",{\"1\":{\"985\":1,\"1008\":2,\"1019\":1}}],[\"postprocessbeandefinition\",{\"1\":{\"1647\":1}}],[\"postprocessbeanfactory\",{\"1\":{\"922\":1,\"1165\":1,\"1647\":1,\"1651\":1}}],[\"postprocessbeforedestruction\",{\"1\":{\"1011\":2}}],[\"postprocessbeforeinitialization\",{\"1\":{\"1006\":3}}],[\"postprocessbeforeinstantiation\",{\"1\":{\"1000\":3,\"1001\":1,\"1002\":1,\"1647\":1}}],[\"postprocessmergedbeandefinition\",{\"1\":{\"964\":1,\"1647\":1,\"1648\":1}}],[\"postconstruct等\",{\"1\":{\"945\":1}}],[\"postconstruct\",{\"1\":{\"931\":3,\"966\":2,\"973\":2,\"977\":1,\"985\":1,\"1007\":1,\"1023\":1,\"1044\":1,\"1045\":1,\"1110\":1,\"1120\":1}}],[\"postconstruct注解\",{\"1\":{\"931\":1}}],[\"postconstruct标注方法需要注解驱动\",{\"1\":{\"1007\":1}}],[\"postconstruct标注方法\",{\"1\":{\"931\":1,\"1007\":1}}],[\"postgresql\",{\"1\":{\"596\":1}}],[\"posting\",{\"1\":{\"308\":2}}],[\"post时可以针对整个资源集合进行操作的\",{\"1\":{\"306\":1}}],[\"post和put都能起到创建\",{\"1\":{\"306\":1}}],[\"post\",{\"1\":{\"306\":5,\"307\":5,\"394\":9,\"922\":2,\"1164\":1,\"1166\":1,\"1170\":1,\"1647\":4,\"1651\":1}}],[\"python\",{\"1\":{\"306\":1}}],[\"谈一下redis事务的了解\",{\"0\":{\"145\":1,\"1297\":1}}],[\"谈谈你对微服务的理解\",{\"0\":{\"224\":1,\"1304\":1}}],[\"谈谈你对aqs的理解\",{\"0\":{\"71\":1,\"1400\":1}}],[\"谈谈你了解的jvm参数\",{\"0\":{\"124\":1,\"1455\":1}}],[\"子容器中找不到\",{\"1\":{\"1661\":1}}],[\"子部分固定大小的\",{\"1\":{\"1620\":1}}],[\"子进程的时候\",{\"1\":{\"1527\":1}}],[\"子进程的时候要复制父进程整个进程的地址空间\",{\"1\":{\"1527\":1}}],[\"子进程会拥有父进程的内存数据\",{\"1\":{\"1290\":1}}],[\"子进程会全部复制父进程的数据吗\",{\"0\":{\"138\":1,\"1290\":1}}],[\"子类中有的属性设置会父类的属性\",{\"1\":{\"1647\":1}}],[\"子类也可以重写父类的方法\",{\"1\":{\"1340\":1}}],[\"子类可以拥有自己的属性和方法\",{\"1\":{\"1340\":1}}],[\"子类拥有父类所有的属性和方法\",{\"1\":{\"1340\":1}}],[\"子注解提供了新的属性方法引用\",{\"1\":{\"1136\":1}}],[\"子\",{\"1\":{\"1036\":1}}],[\"子查询等的复杂查询\",{\"1\":{\"330\":1}}],[\"子线程中如何获取父线程的\",{\"0\":{\"85\":1,\"1414\":1}}],[\"先找父亲加载\",{\"1\":{\"1663\":1}}],[\"先执行bean的销毁方法\",{\"1\":{\"1651\":1}}],[\"先执行完的先进入阻塞队列\",{\"1\":{\"1517\":1}}],[\"先合并父的beandefinition\",{\"1\":{\"1647\":1}}],[\"先使用cglib生成代理类\",{\"1\":{\"1630\":1}}],[\"先根据类型进行依赖查找\",{\"1\":{\"1630\":1}}],[\"先根据expire\",{\"1\":{\"549\":1}}],[\"先从直观的角度来感受函数式编程带来的好处\",{\"1\":{\"1593\":1}}],[\"先是执行newtable\",{\"1\":{\"1551\":1}}],[\"先是通过b+树从树根开始\",{\"1\":{\"342\":1}}],[\"先进行自旋等待\",{\"1\":{\"1520\":1}}],[\"先后出现过三种不同的管程模型\",{\"1\":{\"1483\":1}}],[\"先返回key对应的值\",{\"1\":{\"1288\":1}}],[\"先get\",{\"1\":{\"1288\":1}}],[\"先删除缓存\",{\"1\":{\"1286\":1}}],[\"先删缓存\",{\"0\":{\"134\":1,\"1286\":1}}],[\"先操作缓存\",{\"1\":{\"1286\":1}}],[\"先通过布隆过滤器判断该键是否存在于缓存中\",{\"1\":{\"1283\":1}}],[\"先通过执行change\",{\"1\":{\"485\":1}}],[\"先有蛋还是先有鸡\",{\"1\":{\"1237\":1}}],[\"先不创建实例\",{\"1\":{\"1191\":1}}],[\"先到先服务\",{\"1\":{\"604\":1}}],[\"先看jedis\",{\"1\":{\"583\":1}}],[\"先算哪个都可以\",{\"1\":{\"549\":1}}],[\"先用\",{\"1\":{\"485\":1}}],[\"先判断表里面是否已经存在这个id\",{\"1\":{\"491\":1}}],[\"先判断从库是否同步完成的方法\",{\"1\":{\"472\":1}}],[\"先判断seconds\",{\"1\":{\"472\":1}}],[\"先判断server\",{\"1\":{\"455\":1}}],[\"先记录一行set\",{\"1\":{\"468\":1}}],[\"先把这个gtid加到临时实例的gtid集合\",{\"1\":{\"485\":1}}],[\"先把结果存起来\",{\"1\":{\"482\":1}}],[\"先把binlog从binlog\",{\"1\":{\"451\":1}}],[\"先把日志写到binlog\",{\"1\":{\"450\":1}}],[\"先放弃\",{\"1\":{\"441\":1}}],[\"先取前三行\",{\"1\":{\"421\":1}}],[\"先遍历链表\",{\"1\":{\"412\":1}}],[\"先设置\",{\"1\":{\"405\":1}}],[\"先插入两条数据\",{\"1\":{\"345\":1}}],[\"先写binlog后写redo\",{\"1\":{\"327\":1}}],[\"先写redo\",{\"1\":{\"327\":1}}],[\"先写日志\",{\"1\":{\"324\":1}}],[\"先写数据库\",{\"0\":{\"135\":1,\"1287\":1},\"1\":{\"1287\":1}}],[\"rules\",{\"1\":{\"1619\":1,\"1655\":2}}],[\"runoob\",{\"1\":{\"1969\":1}}],[\"runaftereither\",{\"1\":{\"1518\":1}}],[\"runafterbotheither\",{\"1\":{\"1518\":1}}],[\"running\",{\"1\":{\"1174\":4}}],[\"runnable接口现在变成了函数式接口\",{\"1\":{\"1594\":1}}],[\"runnable状态转换到终止状态\",{\"1\":{\"1524\":1}}],[\"runnable\",{\"1\":{\"944\":3,\"989\":1,\"1476\":1,\"1477\":1,\"1518\":1,\"1591\":1,\"1592\":3,\"1594\":1,\"1619\":1,\"1689\":1}}],[\"runwith\",{\"1\":{\"1157\":1}}],[\"run\",{\"1\":{\"944\":1,\"1056\":1,\"1551\":2,\"1573\":1,\"1591\":1,\"1592\":1,\"1594\":1,\"1619\":3}}],[\"runtimeexception异常\",{\"1\":{\"1239\":1}}],[\"runtimeexception\",{\"1\":{\"1043\":1,\"1574\":2,\"1575\":5,\"1655\":3}}],[\"runtime\",{\"1\":{\"917\":1,\"961\":3,\"967\":2,\"1134\":1,\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":3,\"1480\":1,\"1573\":1,\"1594\":1}}],[\"r类型表示汇聚操作的结果类型\",{\"1\":{\"1615\":1}}],[\"r是返回的结果的类型\",{\"1\":{\"1598\":1}}],[\"r>分别表示输入参数的类型和返回结果的类型\",{\"1\":{\"1598\":1}}],[\"r>\",{\"1\":{\"1598\":4,\"1601\":1,\"1608\":2,\"1615\":2,\"1616\":5,\"1617\":1,\"1618\":4,\"1622\":3,\"1623\":2}}],[\"rset\",{\"0\":{\"1745\":1}}],[\"rs\",{\"1\":{\"1554\":5}}],[\"rsp\",{\"1\":{\"1473\":1}}],[\"rb\",{\"1\":{\"1533\":3,\"1534\":3}}],[\"r2\",{\"1\":{\"1517\":1,\"1592\":2,\"1609\":2,\"1615\":2,\"1618\":4}}],[\"r2=geocoderbys2\",{\"1\":{\"1517\":1}}],[\"r3有一个返回\",{\"1\":{\"1517\":1}}],[\"r3=geocoderbys3\",{\"1\":{\"1517\":1}}],[\"r3~r5\",{\"1\":{\"338\":1}}],[\"r1\",{\"1\":{\"1592\":2,\"1609\":3,\"1615\":2,\"1618\":6}}],[\"r1|r2|r3\",{\"1\":{\"1517\":1}}],[\"r1=geocoderbys1\",{\"1\":{\"1517\":1}}],[\"r1~r100\",{\"1\":{\"405\":1}}],[\"rr>\",{\"1\":{\"1618\":3}}],[\"rr隔离级别下\",{\"1\":{\"1263\":1}}],[\"rr级别下快照读的结果不同\",{\"1\":{\"542\":1}}],[\"rr级别下的innodb快照读有什么不同\",{\"1\":{\"542\":1}}],[\"r映射\",{\"1\":{\"893\":1}}],[\"risk\",{\"1\":{\"1620\":1}}],[\"risks\",{\"1\":{\"1620\":1}}],[\"right\",{\"1\":{\"571\":1,\"1608\":2,\"1615\":2,\"1618\":7}}],[\"ringbuffer<orderevent>\",{\"1\":{\"1521\":1}}],[\"ringbuffersize\",{\"1\":{\"1520\":2}}],[\"ringbuffer就是一个可自定义大小的环形数组\",{\"1\":{\"1520\":1}}],[\"ringbuffer\",{\"0\":{\"1520\":1},\"1\":{\"1521\":2}}],[\"ringo\",{\"1\":{\"370\":4,\"371\":5,\"372\":1,\"373\":2,\"374\":2,\"376\":1}}],[\"rin\",{\"1\":{\"375\":1}}],[\"rpchook\",{\"0\":{\"1949\":1}}],[\"rpoplpush\",{\"1\":{\"571\":3}}],[\"rpop\",{\"1\":{\"571\":4}}],[\"rpushx\",{\"1\":{\"571\":2}}],[\"rpush\",{\"1\":{\"571\":4}}],[\"rc\",{\"1\":{\"542\":1}}],[\"rather\",{\"1\":{\"1608\":2,\"1615\":1,\"1619\":1,\"1620\":2}}],[\"race\",{\"1\":{\"1554\":1,\"1620\":1}}],[\"races\",{\"1\":{\"1480\":1}}],[\"rabbit\",{\"1\":{\"1328\":1}}],[\"rabbitmq教程\",{\"1\":{\"1985\":1}}],[\"rabbitmq消息消费失败后的处理方案\",{\"1\":{\"1332\":1}}],[\"rabbitmq\",{\"1\":{\"1327\":1,\"1328\":3,\"1333\":1,\"1966\":1}}],[\"raisenomatchingbeanfound\",{\"1\":{\"963\":2,\"1648\":2}}],[\"rawtypes\",{\"1\":{\"1550\":1,\"1623\":1}}],[\"rawclass\",{\"1\":{\"1099\":1}}],[\"raw\",{\"1\":{\"645\":1,\"1099\":1,\"1647\":1}}],[\"raft维基百科\",{\"1\":{\"633\":1}}],[\"radius\",{\"1\":{\"576\":2}}],[\"ram\",{\"1\":{\"533\":1}}],[\"randomuuid\",{\"1\":{\"1609\":1,\"1612\":1}}],[\"random\",{\"1\":{\"1300\":2}}],[\"rand\",{\"0\":{\"419\":1},\"1\":{\"419\":1,\"420\":1,\"421\":2,\"422\":9,\"567\":3}}],[\"rangeclosed\",{\"1\":{\"1607\":2}}],[\"rangeintspliterator\",{\"1\":{\"1607\":2}}],[\"ranges\",{\"1\":{\"519\":3}}],[\"range\",{\"0\":{\"404\":1},\"1\":{\"330\":2,\"404\":1,\"424\":1,\"509\":1,\"519\":12,\"553\":5,\"555\":1,\"580\":1,\"1607\":2}}],[\"rm删除数据\",{\"0\":{\"488\":1}}],[\"rmi\",{\"0\":{\"1681\":1},\"1\":{\"273\":1}}],[\"r这一行已经存在\",{\"1\":{\"467\":2}}],[\"r\",{\"1\":{\"421\":6,\"429\":5,\"467\":1,\"893\":1,\"1479\":6,\"1517\":5,\"1598\":6,\"1601\":1,\"1608\":4,\"1615\":6,\"1617\":3,\"1618\":3,\"1623\":3}}],[\"r字段存放的随机值是8个字段\",{\"1\":{\"421\":1}}],[\"rnd\",{\"1\":{\"404\":6}}],[\"rocket\",{\"1\":{\"1333\":1}}],[\"rocketmq通信类结构\",{\"0\":{\"1848\":1}}],[\"rocketmq从实践到原理\",{\"0\":{\"1825\":1}}],[\"rocketmq当中使用mmap方式对它的文件进行读写\",{\"1\":{\"1330\":1,\"1331\":1}}],[\"rocketmq\",{\"1\":{\"1327\":1,\"1328\":3,\"1329\":1,\"1966\":1}}],[\"roctmq\",{\"1\":{\"1328\":1}}],[\"role\",{\"1\":{\"609\":1,\"996\":3,\"1633\":1}}],[\"roll\",{\"1\":{\"542\":4}}],[\"rollbackon\",{\"1\":{\"1655\":1}}],[\"rollback语句\",{\"1\":{\"1297\":1}}],[\"rollback\",{\"1\":{\"491\":1,\"1655\":5}}],[\"roworder\",{\"1\":{\"519\":3}}],[\"row格式的binlog会把删掉的行的整行信息保存起来\",{\"1\":{\"454\":1}}],[\"row格式的binlog里没有了sql语句的原文\",{\"1\":{\"454\":1}}],[\"row格式的缺点是\",{\"1\":{\"454\":1}}],[\"rowid\",{\"1\":{\"421\":6,\"519\":1}}],[\"rowid是6个字节\",{\"1\":{\"421\":1}}],[\"rowid名字的来历\",{\"1\":{\"420\":1}}],[\"rowid>\",{\"1\":{\"355\":1,\"520\":1}}],[\"rowid排序会要求回表\",{\"1\":{\"356\":1}}],[\"rowid排序多访问了一次表t的主键索引\",{\"1\":{\"355\":1}}],[\"rowid排序\",{\"0\":{\"355\":1}}],[\"rows值越不精确\",{\"1\":{\"558\":1}}],[\"rows值越精确\",{\"1\":{\"558\":1}}],[\"rows值精确与否取决于统计时采样的页面数量\",{\"1\":{\"558\":1}}],[\"rows值\",{\"1\":{\"558\":1}}],[\"rows的值是10350\",{\"1\":{\"558\":1}}],[\"rows的话\",{\"1\":{\"484\":1}}],[\"rows是通过采样估算的来的\",{\"1\":{\"396\":1}}],[\"rows用于显示这个表当前有多少行\",{\"1\":{\"396\":1}}],[\"rows=1表示只扫描一行\",{\"1\":{\"368\":1}}],[\"rows=100335\",{\"1\":{\"366\":1}}],[\"rows=4000\",{\"1\":{\"354\":1}}],[\"rows\",{\"1\":{\"329\":2,\"330\":8,\"354\":6,\"361\":1,\"390\":2,\"393\":3,\"420\":3,\"428\":2,\"429\":2,\"431\":3,\"454\":2,\"484\":4,\"519\":7,\"520\":4,\"548\":1,\"553\":3,\"555\":4}}],[\"row\",{\"1\":{\"329\":2,\"330\":10,\"361\":2,\"371\":2,\"390\":2,\"428\":2,\"431\":1,\"454\":3,\"484\":1,\"495\":5,\"499\":1,\"519\":1,\"538\":9,\"542\":4,\"557\":3,\"1254\":1}}],[\"rootbeandefinition\",{\"1\":{\"964\":1,\"967\":2,\"997\":7,\"1007\":1,\"1008\":1,\"1018\":1,\"1174\":1,\"1632\":1,\"1647\":15,\"1648\":2,\"1650\":1}}],[\"root\",{\"0\":{\"107\":1,\"1438\":1},\"1\":{\"429\":1,\"570\":1,\"997\":1,\"1620\":1}}],[\"rdb快照是一次全量备份\",{\"1\":{\"1290\":1}}],[\"rdb文件名\",{\"1\":{\"609\":1}}],[\"rdb文件使用特定二进制格式保存\",{\"1\":{\"590\":1}}],[\"rdb和aop选择\",{\"0\":{\"594\":1}}],[\"rdb完全够用\",{\"1\":{\"592\":1}}],[\"rdb不适合实时持久化\",{\"1\":{\"590\":1}}],[\"rdb的自动触发只需要在配置文件redis\",{\"1\":{\"587\":1}}],[\"rdb的手动触发分别对应save和bgsave命令\",{\"1\":{\"587\":1}}],[\"rdb的二进制文件中\",{\"1\":{\"586\":1}}],[\"rdb持久化过程由子进程负责\",{\"1\":{\"587\":1}}],[\"rdb持久化是把当前进程数据生成快照保存到硬盘的过程\",{\"1\":{\"586\":1}}],[\"rdb持久化\",{\"0\":{\"585\":1}}],[\"rdb\",{\"0\":{\"595\":1},\"1\":{\"565\":1,\"592\":1,\"595\":1,\"596\":3}}],[\"rdb操作\",{\"0\":{\"138\":1,\"1290\":1}}],[\"rdms\",{\"1\":{\"301\":1}}],[\"revents\",{\"1\":{\"1570\":1}}],[\"reverseorder\",{\"1\":{\"1614\":2}}],[\"reversed\",{\"1\":{\"1614\":5}}],[\"reverse函数额外消耗的cpu的资源会更小一些\",{\"1\":{\"352\":1}}],[\"reverse\",{\"1\":{\"352\":1,\"429\":1,\"484\":3}}],[\"rehash\",{\"1\":{\"1553\":1}}],[\"reentrantreadwritelock不支持锁升级\",{\"1\":{\"1498\":1}}],[\"reentrantreadwritelock是可重入的读写锁实现类\",{\"1\":{\"1498\":1}}],[\"reentrantreadwritelock\",{\"0\":{\"1498\":1}}],[\"reentrantlock+condition\",{\"1\":{\"1530\":1}}],[\"reentrantlock获取锁的形式有多种\",{\"1\":{\"1495\":1}}],[\"reentrantlock是可以是公平也可以是非公平的\",{\"1\":{\"1495\":1}}],[\"reentrantlock是jdk层次的锁实现\",{\"1\":{\"1495\":1}}],[\"reentrantlock是一种互斥锁\",{\"1\":{\"1494\":1}}],[\"reentrantlock加锁解锁的逻辑\",{\"1\":{\"1494\":1}}],[\"reentrantlock具备如下特点\",{\"1\":{\"1494\":1}}],[\"reentrantlock详解\",{\"0\":{\"1494\":1}}],[\"reentrantlock\",{\"1\":{\"1398\":1,\"1502\":4,\"1503\":8}}],[\"rejectedexecutionhandler\",{\"1\":{\"1476\":1}}],[\"reject\",{\"1\":{\"1063\":1,\"1476\":2}}],[\"reject生成\",{\"1\":{\"1063\":1}}],[\"reject生成objecterror\",{\"1\":{\"1063\":1}}],[\"reject方法\",{\"1\":{\"1062\":1}}],[\"rejectvalue方法\",{\"1\":{\"1062\":1}}],[\"rejectvalue\",{\"1\":{\"1061\":1,\"1063\":1}}],[\"rejectifemptyorwhitespace\",{\"1\":{\"1061\":2,\"1064\":2}}],[\"relationship\",{\"1\":{\"1647\":1}}],[\"relative\",{\"1\":{\"1615\":1,\"1623\":1}}],[\"related\",{\"1\":{\"1615\":1}}],[\"relaxed\",{\"1\":{\"1615\":1}}],[\"relayed\",{\"1\":{\"1595\":2,\"1597\":1,\"1598\":6,\"1599\":4,\"1620\":2}}],[\"relay\",{\"1\":{\"453\":1,\"457\":1,\"460\":1,\"467\":1,\"472\":2}}],[\"release\",{\"1\":{\"1404\":3,\"1619\":1}}],[\"reloadableresourcebundlemessagesource\",{\"1\":{\"1054\":1,\"1056\":1,\"1059\":1}}],[\"re\",{\"1\":{\"964\":1,\"997\":1,\"1166\":2,\"1623\":1,\"1647\":3,\"1650\":1}}],[\"region\",{\"0\":{\"1742\":1}}],[\"registration\",{\"1\":{\"975\":1,\"996\":1,\"1658\":6}}],[\"registry\",{\"1\":{\"928\":6,\"929\":4,\"967\":2,\"1027\":3,\"1084\":2,\"1138\":2,\"1647\":3,\"1654\":4}}],[\"registerdispatcherservlet\",{\"1\":{\"1658\":1}}],[\"registerdisposablebeanifnecessary\",{\"1\":{\"1647\":1}}],[\"registerdependentbeans\",{\"1\":{\"1648\":1}}],[\"registerdependentbean\",{\"1\":{\"1647\":1}}],[\"registerdefaulteditors\",{\"1\":{\"1093\":1}}],[\"registerdestructioncallback\",{\"1\":{\"989\":1}}],[\"registering\",{\"1\":{\"1171\":1}}],[\"registercustomeditors\",{\"1\":{\"1084\":1}}],[\"registercustomeditor\",{\"1\":{\"1084\":3,\"1640\":1}}],[\"registerservletfilter\",{\"1\":{\"1658\":1}}],[\"registershutdownhook\",{\"1\":{\"1175\":1}}],[\"registerscope\",{\"1\":{\"989\":2}}],[\"registersinleton\",{\"1\":{\"976\":1}}],[\"registersingleton\",{\"1\":{\"936\":1,\"1055\":1,\"1121\":1,\"1164\":4,\"1167\":1,\"1168\":1}}],[\"registerresolvabledependency\",{\"1\":{\"973\":4,\"977\":2,\"1164\":4}}],[\"registerpostprocessor\",{\"1\":{\"967\":1}}],[\"registerapplicationcontext\",{\"1\":{\"1172\":1}}],[\"registerannotationconfigprocessors中\",{\"1\":{\"967\":1}}],[\"registeralias\",{\"1\":{\"645\":50}}],[\"registeruserbeandefinition\",{\"1\":{\"929\":1}}],[\"registerwithgeneratedname\",{\"1\":{\"929\":2,\"1138\":1}}],[\"registerbean\",{\"1\":{\"995\":1}}],[\"registerbeandefinitionparser\",{\"1\":{\"1030\":1}}],[\"registerbeandefinitions\",{\"1\":{\"1021\":3,\"1022\":1,\"1138\":1}}],[\"registerbeandefinition的逻辑如下\",{\"1\":{\"996\":1}}],[\"registerbeandefinition\",{\"1\":{\"929\":2,\"930\":1,\"946\":2,\"953\":1,\"975\":1,\"996\":1,\"1019\":1,\"1027\":1,\"1174\":1,\"1632\":1,\"1647\":1}}],[\"registerbeanpostprocessors\",{\"1\":{\"922\":1,\"1166\":6,\"1647\":1,\"1651\":1}}],[\"registerlisteners方法\",{\"1\":{\"1170\":1}}],[\"registerlisteners\",{\"1\":{\"922\":1,\"1170\":1,\"1647\":1,\"1651\":1}}],[\"registered\",{\"1\":{\"922\":1,\"973\":2,\"1055\":1,\"1164\":2,\"1165\":1,\"1167\":1,\"1171\":1,\"1647\":3,\"1658\":1}}],[\"register\",{\"1\":{\"921\":1,\"922\":2,\"929\":2,\"931\":1,\"933\":1,\"934\":1,\"940\":1,\"943\":1,\"944\":1,\"946\":1,\"953\":1,\"955\":1,\"957\":1,\"961\":3,\"962\":1,\"963\":1,\"973\":1,\"977\":1,\"978\":1,\"985\":2,\"989\":1,\"1029\":1,\"1031\":1,\"1032\":1,\"1044\":1,\"1045\":1,\"1113\":1,\"1116\":2,\"1120\":1,\"1123\":1,\"1134\":1,\"1138\":1,\"1139\":1,\"1148\":1,\"1149\":1,\"1156\":1,\"1164\":2,\"1166\":6,\"1170\":1,\"1171\":1,\"1181\":1,\"1182\":1,\"1184\":1,\"1574\":5,\"1633\":1,\"1647\":3,\"1658\":1}}],[\"regardless\",{\"1\":{\"1594\":3}}],[\"regsiterbeandefinition\",{\"1\":{\"1017\":1}}],[\"regular\",{\"1\":{\"963\":1,\"1166\":1,\"1170\":1}}],[\"requiring\",{\"1\":{\"1608\":2}}],[\"require\",{\"1\":{\"1619\":3}}],[\"requirement\",{\"1\":{\"1600\":2}}],[\"requirements\",{\"1\":{\"1594\":2,\"1620\":1}}],[\"requirenonnull\",{\"1\":{\"1594\":5,\"1595\":1,\"1597\":1,\"1598\":6,\"1599\":4,\"1601\":2,\"1609\":1,\"1614\":2,\"1617\":1,\"1618\":2,\"1621\":2,\"1622\":2,\"1623\":5}}],[\"requires\",{\"1\":{\"1238\":1}}],[\"requiredtype\",{\"1\":{\"1084\":2,\"1647\":7,\"1648\":9}}],[\"requiredfields\",{\"1\":{\"1072\":1}}],[\"required=true\",{\"1\":{\"963\":1}}],[\"required\",{\"1\":{\"963\":1,\"964\":2,\"967\":1,\"1061\":2,\"1063\":2,\"1064\":2,\"1162\":1,\"1238\":1,\"1594\":2,\"1615\":1,\"1618\":1,\"1620\":1,\"1622\":1,\"1648\":6}}],[\"request对象给adapter\",{\"1\":{\"1687\":1}}],[\"request对象转成标准的servlet\",{\"1\":{\"1687\":1}}],[\"request对象\",{\"1\":{\"1687\":1}}],[\"requestmapping的完成流程\",{\"1\":{\"1657\":1}}],[\"requested\",{\"1\":{\"1570\":1,\"1623\":1}}],[\"requestscope\",{\"1\":{\"986\":1}}],[\"requestscope或\",{\"1\":{\"986\":1}}],[\"request作用域的对象\",{\"1\":{\"987\":1}}],[\"request作用域\",{\"0\":{\"986\":1}}],[\"request\",{\"1\":{\"983\":1,\"986\":2,\"991\":1,\"1182\":1,\"1201\":1,\"1235\":1,\"1240\":1,\"1657\":6,\"1687\":2}}],[\"requestingbeanname\",{\"1\":{\"963\":6,\"1648\":6}}],[\"reached\",{\"1\":{\"1689\":1}}],[\"reactor线程设计\",{\"0\":{\"1849\":1}}],[\"reactor采用多路复用将事件分发给相应的handler处理\",{\"1\":{\"1228\":1}}],[\"reactor模式\",{\"0\":{\"703\":1,\"705\":1}}],[\"reactiveadapter\",{\"1\":{\"1655\":1}}],[\"reactiveadapterregistry\",{\"1\":{\"1655\":2}}],[\"reactivetype\",{\"1\":{\"1655\":2}}],[\"reactivetransactionsupport\",{\"1\":{\"1655\":2}}],[\"reactivetransactionmanager\",{\"1\":{\"1655\":2}}],[\"reactivetransactionmanager用的比较少\",{\"1\":{\"1655\":1}}],[\"reactivewebserverapplicationcontext\",{\"1\":{\"1169\":1}}],[\"reactive\",{\"1\":{\"899\":1,\"900\":1,\"1169\":1,\"1655\":2}}],[\"reactive技术栈\",{\"1\":{\"894\":1}}],[\"reason\",{\"1\":{\"1620\":1}}],[\"readchannel\",{\"1\":{\"1587\":3}}],[\"readcompletionhandler\",{\"1\":{\"1575\":4}}],[\"readbuffer\",{\"1\":{\"1575\":3}}],[\"readbytes\",{\"1\":{\"1574\":5}}],[\"readline\",{\"1\":{\"1573\":2}}],[\"readfds\",{\"1\":{\"1569\":1}}],[\"read之后\",{\"1\":{\"1566\":1}}],[\"reader\",{\"1\":{\"921\":2,\"1030\":2,\"1032\":2,\"1040\":3,\"1041\":3,\"1043\":3,\"1573\":4,\"1647\":2,\"1651\":2}}],[\"readmethod=public\",{\"1\":{\"909\":2}}],[\"read方法才会返回\",{\"1\":{\"602\":1}}],[\"reading\",{\"1\":{\"598\":1}}],[\"readview生成时刻系统尚未分配下一个事务id\",{\"1\":{\"542\":1}}],[\"read统计的是\",{\"1\":{\"479\":1}}],[\"readonly的值会被用来做其它逻辑\",{\"1\":{\"438\":1}}],[\"readonly\",{\"1\":{\"438\":1,\"453\":1,\"611\":2}}],[\"read优化的主要目的是尽量使用顺序读盘\",{\"1\":{\"404\":1}}],[\"read的值加1\",{\"1\":{\"354\":1}}],[\"read\",{\"0\":{\"404\":1},\"1\":{\"354\":5,\"404\":2,\"433\":6,\"437\":1,\"440\":1,\"532\":6,\"534\":2,\"542\":3,\"553\":3,\"555\":5,\"557\":2,\"603\":4,\"611\":2,\"1175\":1,\"1224\":1,\"1238\":3,\"1262\":3,\"1263\":1,\"1473\":1,\"1479\":3,\"1533\":1,\"1534\":1,\"1574\":5,\"1575\":2,\"1585\":1,\"1587\":2,\"1588\":1,\"1647\":1}}],[\"reused\",{\"1\":{\"1619\":1}}],[\"reuse\",{\"1\":{\"646\":1,\"1615\":1,\"1619\":1}}],[\"renamenx\",{\"1\":{\"569\":1}}],[\"rename\",{\"1\":{\"569\":1}}],[\"rethrow\",{\"1\":{\"1655\":1}}],[\"retval\",{\"1\":{\"1655\":13}}],[\"reteniton注解的作用是\",{\"1\":{\"1133\":1}}],[\"retentionpolicy\",{\"1\":{\"917\":1,\"961\":3,\"967\":2,\"1134\":1,\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":3,\"1594\":1}}],[\"retention\",{\"1\":{\"917\":1,\"961\":3,\"967\":2,\"1133\":1,\"1134\":1,\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":3,\"1594\":1}}],[\"returnvalue\",{\"1\":{\"1654\":1}}],[\"returns\",{\"1\":{\"1597\":3,\"1598\":12,\"1599\":8,\"1601\":8,\"1609\":1,\"1613\":2,\"1614\":1,\"1615\":1,\"1618\":3,\"1620\":11,\"1622\":1}}],[\"returned\",{\"1\":{\"1570\":1,\"1600\":2,\"1615\":2,\"1618\":1,\"1619\":1,\"1620\":6}}],[\"returntypeargument\",{\"1\":{\"1100\":2}}],[\"returntype\",{\"1\":{\"1100\":2}}],[\"returning\",{\"0\":{\"824\":1},\"1\":{\"1613\":1,\"1620\":1,\"1647\":2}}],[\"return\",{\"1\":{\"542\":4,\"583\":1,\"645\":1,\"909\":2,\"917\":5,\"918\":3,\"921\":1,\"928\":6,\"929\":1,\"930\":2,\"931\":1,\"933\":1,\"940\":1,\"943\":2,\"946\":3,\"952\":4,\"953\":5,\"954\":3,\"955\":1,\"956\":1,\"961\":6,\"963\":24,\"964\":4,\"965\":2,\"967\":2,\"973\":2,\"985\":11,\"989\":8,\"995\":1,\"997\":3,\"998\":2,\"1000\":5,\"1001\":3,\"1002\":4,\"1003\":8,\"1005\":4,\"1006\":4,\"1007\":1,\"1008\":4,\"1019\":1,\"1021\":1,\"1022\":1,\"1023\":3,\"1027\":1,\"1030\":1,\"1031\":1,\"1032\":2,\"1043\":9,\"1056\":2,\"1061\":1,\"1063\":1,\"1064\":1,\"1065\":2,\"1084\":1,\"1091\":3,\"1100\":3,\"1119\":2,\"1123\":1,\"1136\":1,\"1137\":2,\"1138\":2,\"1139\":6,\"1174\":1,\"1181\":1,\"1182\":1,\"1184\":9,\"1191\":1,\"1192\":1,\"1193\":1,\"1194\":1,\"1288\":4,\"1347\":1,\"1368\":2,\"1388\":1,\"1404\":3,\"1412\":2,\"1432\":1,\"1475\":1,\"1476\":1,\"1479\":2,\"1485\":1,\"1502\":2,\"1503\":2,\"1517\":1,\"1528\":1,\"1531\":2,\"1548\":2,\"1549\":3,\"1550\":3,\"1553\":2,\"1554\":6,\"1557\":3,\"1594\":6,\"1597\":2,\"1598\":32,\"1599\":20,\"1600\":3,\"1601\":5,\"1603\":4,\"1604\":2,\"1605\":6,\"1606\":2,\"1607\":6,\"1608\":7,\"1609\":6,\"1610\":2,\"1612\":1,\"1613\":8,\"1614\":5,\"1615\":5,\"1616\":5,\"1617\":22,\"1618\":29,\"1619\":1,\"1620\":21,\"1621\":4,\"1622\":5,\"1623\":12,\"1638\":1,\"1639\":4,\"1644\":2,\"1647\":23,\"1648\":25,\"1650\":7,\"1654\":8,\"1655\":9,\"1657\":1,\"1658\":3,\"1663\":1,\"1689\":5}}],[\"retrieved\",{\"1\":{\"472\":1}}],[\"received\",{\"1\":{\"1647\":1}}],[\"receive\",{\"1\":{\"1623\":3}}],[\"receiver\",{\"1\":{\"1619\":1}}],[\"recently\",{\"1\":{\"1300\":1}}],[\"recvfrom\",{\"1\":{\"1565\":1}}],[\"recvfrom分别调用一次\",{\"1\":{\"1565\":1}}],[\"recursive\",{\"1\":{\"1620\":1}}],[\"recursivetask<integer>\",{\"1\":{\"1412\":1}}],[\"recursions\",{\"1\":{\"1483\":1}}],[\"recheck\",{\"1\":{\"1476\":3,\"1553\":1}}],[\"recalc系统变量的值为off的话\",{\"1\":{\"559\":1}}],[\"recalc的值作为该属性的值\",{\"1\":{\"559\":1}}],[\"recalc属性\",{\"1\":{\"559\":1}}],[\"recalc属性来指明该表的统计数据存储方式\",{\"1\":{\"559\":1}}],[\"recalc=0时\",{\"1\":{\"559\":1}}],[\"recalc=1时\",{\"1\":{\"559\":1}}],[\"recalc\",{\"1\":{\"559\":2}}],[\"recale决定着服务器是否自动重新计算统计数据\",{\"1\":{\"559\":1}}],[\"recommended\",{\"1\":{\"1621\":1}}],[\"reconfig\",{\"1\":{\"624\":3}}],[\"reconsidering\",{\"1\":{\"519\":2}}],[\"recorded\",{\"1\":{\"1554\":1}}],[\"record\",{\"1\":{\"542\":1,\"1432\":1,\"1663\":1}}],[\"rec\",{\"1\":{\"442\":1}}],[\"repeated\",{\"1\":{\"1620\":2}}],[\"repeatedly\",{\"1\":{\"1620\":1}}],[\"repeatableread\",{\"1\":{\"532\":1}}],[\"repeatable\",{\"1\":{\"433\":2,\"532\":1,\"1029\":1,\"1133\":1,\"1238\":1,\"1262\":1}}],[\"report\",{\"1\":{\"1620\":4,\"1621\":1}}],[\"reporting\",{\"1\":{\"1620\":1}}],[\"reports\",{\"1\":{\"1620\":7}}],[\"reported\",{\"1\":{\"1620\":5}}],[\"repository\",{\"1\":{\"918\":1,\"1023\":1,\"1131\":1}}],[\"represent\",{\"1\":{\"1623\":1}}],[\"represented\",{\"1\":{\"1620\":1}}],[\"representing\",{\"1\":{\"1619\":1}}],[\"representation\",{\"1\":{\"1615\":1}}],[\"represents\",{\"1\":{\"952\":1,\"1597\":2,\"1598\":3,\"1599\":14,\"1600\":2,\"1601\":2,\"1621\":1}}],[\"replaced\",{\"1\":{\"1620\":1}}],[\"replaceall\",{\"1\":{\"1618\":1}}],[\"replacing\",{\"1\":{\"996\":3,\"1608\":2}}],[\"replayingdecoder\",{\"0\":{\"727\":1}}],[\"repl\",{\"1\":{\"609\":6}}],[\"replid2\",{\"1\":{\"609\":1}}],[\"replid\",{\"1\":{\"609\":1}}],[\"replica\",{\"1\":{\"611\":2,\"1256\":1}}],[\"replicate\",{\"1\":{\"485\":1}}],[\"replication\",{\"1\":{\"472\":1,\"485\":1,\"609\":3}}],[\"replicas\",{\"1\":{\"305\":2}}],[\"remain\",{\"1\":{\"1620\":1}}],[\"remaining\",{\"1\":{\"922\":1,\"1009\":1,\"1171\":1,\"1574\":2,\"1575\":2,\"1620\":4,\"1647\":1}}],[\"remark\",{\"1\":{\"306\":8}}],[\"remoting\",{\"1\":{\"895\":1}}],[\"remote\",{\"1\":{\"564\":1}}],[\"removesingletonifcreatedfortypecheckonly\",{\"1\":{\"1647\":1}}],[\"removed\",{\"1\":{\"1620\":1}}],[\"removepropertyvalue\",{\"1\":{\"1003\":1}}],[\"removemanualsingletonname\",{\"1\":{\"996\":2}}],[\"remove\",{\"1\":{\"989\":2,\"1368\":2,\"1476\":1,\"1500\":1,\"1501\":2,\"1528\":1,\"1538\":1,\"1557\":2,\"1618\":1,\"1647\":3}}],[\"removal\",{\"1\":{\"519\":1,\"964\":1}}],[\"removing\",{\"1\":{\"431\":1}}],[\"referred\",{\"1\":{\"1619\":1,\"1621\":1}}],[\"referencepipeline<e\",{\"1\":{\"1621\":1,\"1622\":1}}],[\"referencepipeline\",{\"1\":{\"1621\":2,\"1622\":1}}],[\"referencepipeline$2\",{\"1\":{\"1610\":1}}],[\"references\",{\"1\":{\"1594\":4,\"1608\":2,\"1619\":2,\"1647\":2,\"1648\":1}}],[\"reference值为1\",{\"1\":{\"1479\":1}}],[\"reference\",{\"1\":{\"1184\":1,\"1435\":4,\"1599\":2,\"1617\":1,\"1622\":1,\"1623\":2,\"1647\":5}}],[\"reflected\",{\"1\":{\"1620\":2}}],[\"reflect\",{\"1\":{\"1099\":7,\"1560\":4,\"1594\":2,\"1620\":1}}],[\"reflectionutils\",{\"1\":{\"964\":2,\"1648\":2}}],[\"ref=\",{\"1\":{\"953\":2,\"954\":1,\"1065\":1,\"1091\":1}}],[\"refreshbeanfactory\",{\"1\":{\"1163\":2,\"1651\":1}}],[\"refreshscopedrefreshedevent\",{\"1\":{\"1126\":1}}],[\"refreshevent\",{\"1\":{\"1126\":1}}],[\"refreshing\",{\"1\":{\"922\":1,\"1647\":1}}],[\"refresh\",{\"1\":{\"921\":1,\"922\":4,\"929\":1,\"931\":1,\"933\":1,\"934\":1,\"936\":1,\"940\":1,\"943\":1,\"944\":1,\"946\":3,\"953\":2,\"955\":1,\"957\":1,\"961\":3,\"962\":1,\"963\":1,\"973\":2,\"977\":1,\"978\":1,\"985\":2,\"989\":1,\"1005\":1,\"1029\":1,\"1031\":1,\"1032\":1,\"1044\":1,\"1045\":1,\"1112\":1,\"1113\":1,\"1116\":2,\"1119\":1,\"1120\":1,\"1123\":2,\"1134\":1,\"1138\":1,\"1139\":1,\"1148\":1,\"1149\":1,\"1156\":1,\"1162\":2,\"1172\":1,\"1174\":1,\"1175\":2,\"1177\":1,\"1181\":1,\"1182\":1,\"1184\":1,\"1635\":1,\"1647\":4,\"1651\":3}}],[\"ref>\",{\"1\":{\"918\":2}}],[\"ref>ref>range>index>all\",{\"1\":{\"330\":1}}],[\"ref的访问方式要比range成本更低\",{\"1\":{\"555\":1}}],[\"refine\",{\"1\":{\"519\":2}}],[\"ref\",{\"1\":{\"329\":2,\"330\":11,\"361\":1,\"390\":3,\"509\":1,\"519\":2,\"555\":2,\"1022\":1}}],[\"red\",{\"1\":{\"1619\":3}}],[\"reducing方法也是借助collectorimpl来实现的collector的\",{\"1\":{\"1618\":1}}],[\"reducingsink>\",{\"1\":{\"1617\":2}}],[\"reducingsink\",{\"1\":{\"1617\":4}}],[\"reducing\",{\"1\":{\"1613\":1,\"1618\":2,\"1623\":1}}],[\"reductions\",{\"1\":{\"1615\":1}}],[\"reduction\",{\"1\":{\"1608\":4,\"1615\":19,\"1616\":2,\"1618\":3,\"1623\":3}}],[\"reduction<\",{\"1\":{\"1608\":1}}],[\"reduceop\",{\"1\":{\"1624\":1}}],[\"reduceop<t\",{\"1\":{\"1617\":1}}],[\"reduceops\",{\"1\":{\"1617\":1}}],[\"reduced\",{\"1\":{\"1608\":2}}],[\"reduce\",{\"1\":{\"1607\":1,\"1608\":2,\"1621\":1}}],[\"redo日志\",{\"0\":{\"561\":1}}],[\"redo\",{\"0\":{\"451\":1},\"1\":{\"323\":1,\"325\":4,\"327\":2,\"345\":2,\"451\":2,\"496\":1}}],[\"redisbook\",{\"1\":{\"1975\":1}}],[\"redis作为当下主流的缓存技术\",{\"1\":{\"1975\":1}}],[\"redis设计与实现\",{\"1\":{\"1968\":1,\"1975\":1}}],[\"redis设置key的过期时间\",{\"1\":{\"1289\":1}}],[\"redis在微博的9年优化历程\",{\"1\":{\"1965\":1}}],[\"redis在内存不足时\",{\"0\":{\"148\":1,\"1300\":1}}],[\"redis延迟队列\",{\"1\":{\"1299\":1}}],[\"redis延迟队列怎么实现的\",{\"0\":{\"147\":1,\"1299\":1}}],[\"redis服务器会在重新启动时执行一系列必要的一致性检测\",{\"1\":{\"1297\":1}}],[\"redis服务器通过响应队列来将指令的返回结果回复给客户端\",{\"1\":{\"605\":1}}],[\"redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘\",{\"1\":{\"1297\":1}}],[\"redis会将每个客户端套接字都关联一个指令队列\",{\"1\":{\"604\":1}}],[\"redis不会再为其它客户端的请求提供任何服务\",{\"1\":{\"1297\":1}}],[\"redis不好在线扩容\",{\"1\":{\"624\":1}}],[\"redis去读取客户端请求\",{\"1\":{\"1292\":1}}],[\"redis可以在单线程中监听多个socket的请求\",{\"1\":{\"1292\":1}}],[\"redis采用io多路复用计数和非阻塞io\",{\"1\":{\"1292\":1}}],[\"redis每秒可以承受10w+的qps\",{\"1\":{\"1292\":1}}],[\"redis提供了哨兵的命令\",{\"1\":{\"1291\":1}}],[\"redis2\",{\"1\":{\"1288\":1}}],[\"redis实现分布式锁\",{\"1\":{\"1288\":1}}],[\"redis开发与运维\",{\"1\":{\"633\":1,\"1966\":1}}],[\"redis高可用\",{\"1\":{\"633\":1}}],[\"redis当中使用了raft算法实现领导者选举\",{\"1\":{\"624\":1}}],[\"redis同样会为每个客户端套接字关联一个响应队列\",{\"1\":{\"605\":1}}],[\"redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作\",{\"1\":{\"591\":1}}],[\"redis启动之初会读取该文件重新构建数据\",{\"1\":{\"591\":1}}],[\"redis版本演进过程中有多个格式的rdb版本\",{\"1\":{\"590\":1}}],[\"redis加载rdb恢复数据远远快于aof的方式\",{\"1\":{\"590\":1}}],[\"redis父进程判断当前是否存在正在执行的子进程\",{\"1\":{\"588\":1}}],[\"redis还可以将继续响应客户端请求\",{\"1\":{\"588\":1}}],[\"redis进程执行fork操作创建子进程\",{\"1\":{\"587\":1}}],[\"redis持久化文件加载的流程\",{\"1\":{\"584\":1}}],[\"redis支持以下几种数据类型\",{\"1\":{\"1280\":1}}],[\"redis支持rdb和aof两种持久化机制\",{\"1\":{\"584\":1}}],[\"redis支持哪些数据类型\",{\"0\":{\"128\":1,\"1280\":1}}],[\"redisutils工具类很全\",{\"1\":{\"584\":1}}],[\"redission\",{\"1\":{\"1288\":1}}],[\"redisson\",{\"1\":{\"1248\":1}}],[\"redisson实现分布式锁的原理\",{\"0\":{\"143\":1,\"1295\":1}}],[\"redisserver\",{\"1\":{\"599\":1}}],[\"redisserializer\",{\"1\":{\"583\":4}}],[\"redisconfig\",{\"1\":{\"583\":1}}],[\"redisconnectionfactory\",{\"1\":{\"583\":3}}],[\"redisconnection\",{\"1\":{\"583\":1,\"1288\":1}}],[\"redis02springbootapplicationtests\",{\"1\":{\"583\":1}}],[\"redistemplate<string\",{\"1\":{\"583\":2}}],[\"redistemplate\",{\"1\":{\"583\":9}}],[\"redis也不例外\",{\"1\":{\"583\":1}}],[\"redis<\",{\"1\":{\"583\":1}}],[\"redis正是通过分数来为集合中的成员进行从小到大的排序\",{\"1\":{\"574\":1}}],[\"redis中事务的实现特征\",{\"1\":{\"1297\":1}}],[\"redis中集合是通过哈希表实现的\",{\"1\":{\"572\":1}}],[\"redis中保存的值也加了1\",{\"1\":{\"397\":1}}],[\"redis列表是简单的字符串列表\",{\"1\":{\"571\":1}}],[\"redis这样设计有两个好处\",{\"1\":{\"569\":1}}],[\"redis命令大全\",{\"1\":{\"569\":1}}],[\"redis是将两种方式结合来使用的\",{\"1\":{\"1289\":1}}],[\"redis是个单线程的程序\",{\"1\":{\"601\":1}}],[\"redis是一个开源\",{\"1\":{\"568\":1}}],[\"redis是一个字典结构的存储服务器\",{\"1\":{\"567\":1}}],[\"redis是什么\",{\"0\":{\"564\":1}}],[\"redis能该干什么\",{\"0\":{\"565\":1}}],[\"redis入门到精通课程\",{\"1\":{\"1975\":1}}],[\"redis入门\",{\"0\":{\"562\":1},\"1\":{\"1966\":1}}],[\"redis为什么能通过lua脚本保证并发的线程安全\",{\"0\":{\"144\":1,\"1296\":1}}],[\"redis如何实现消息队列\",{\"0\":{\"142\":1,\"1294\":1}}],[\"redis自增命令使用\",{\"0\":{\"141\":1,\"1293\":1}}],[\"redis使用单线程为什么速度这么快\",{\"0\":{\"140\":1,\"1292\":1}}],[\"redis的大部分操作并不是cpu密集型任务\",{\"1\":{\"1292\":1}}],[\"redis的主从复制模式可以将主节点的数据改变同步给从节点\",{\"1\":{\"621\":1}}],[\"redis的单条命令是保证原子性的\",{\"1\":{\"578\":1}}],[\"redis的事务就是指一组命令的集合\",{\"1\":{\"578\":1}}],[\"redis的set是string类型的无序集合\",{\"1\":{\"572\":1}}],[\"redis的key\",{\"1\":{\"569\":1}}],[\"redis的数据不能永久地留在内存中\",{\"1\":{\"397\":1}}],[\"redis的哨兵模式能自动完成故障发现和故障转移\",{\"1\":{\"621\":1}}],[\"redis的哨兵模式\",{\"0\":{\"139\":1,\"1291\":1}}],[\"redis的过期删除策略\",{\"0\":{\"137\":1,\"1289\":1}}],[\"redis\",{\"0\":{\"127\":1,\"569\":1,\"1279\":1,\"1975\":1},\"1\":{\"564\":1,\"573\":1,\"574\":3,\"577\":1,\"583\":2,\"586\":1,\"588\":1,\"592\":2,\"596\":1,\"599\":2,\"621\":2,\"624\":2,\"626\":1,\"1248\":1,\"1288\":1,\"1292\":1,\"1975\":3}}],[\"respecting\",{\"1\":{\"1623\":1}}],[\"respect\",{\"1\":{\"1622\":1}}],[\"responsible\",{\"1\":{\"1483\":1,\"1622\":1}}],[\"response转成网络字节流\",{\"1\":{\"1687\":1}}],[\"responsebyte\",{\"1\":{\"1574\":3}}],[\"response提前过滤一些信息\",{\"1\":{\"1354\":1}}],[\"response\",{\"1\":{\"582\":2,\"1201\":1,\"1657\":6,\"1687\":1}}],[\"respository\",{\"1\":{\"899\":1}}],[\"res\",{\"1\":{\"1614\":3}}],[\"resizers\",{\"1\":{\"1554\":1}}],[\"resizestamp\",{\"1\":{\"1554\":1}}],[\"resize\",{\"1\":{\"1549\":2,\"1550\":2,\"1554\":2}}],[\"resizing\",{\"1\":{\"1480\":1}}],[\"resository\",{\"1\":{\"1142\":1}}],[\"resolution\",{\"1\":{\"963\":1,\"1171\":1,\"1647\":1}}],[\"resolving\",{\"1\":{\"1647\":1}}],[\"resolveautowiringvalue\",{\"1\":{\"1648\":1}}],[\"resolvebasepackage\",{\"1\":{\"1647\":1}}],[\"resolvebeforeinstantiation\",{\"1\":{\"1000\":1,\"1017\":1,\"1647\":2}}],[\"resolvebeanclass\",{\"1\":{\"998\":1,\"1647\":1,\"1650\":1}}],[\"resolveplaceholders\",{\"1\":{\"1171\":1}}],[\"resolvetypearguments\",{\"1\":{\"1100\":1}}],[\"resolvetypeargument\",{\"1\":{\"1100\":1}}],[\"resolvetype\",{\"1\":{\"1100\":1}}],[\"resolvescopemetadata\",{\"1\":{\"1027\":1,\"1647\":1}}],[\"resolveshortcut\",{\"1\":{\"963\":1,\"1648\":1}}],[\"resolveclass\",{\"1\":{\"1432\":1,\"1663\":1}}],[\"resolvecontextualobject\",{\"1\":{\"989\":1}}],[\"resolvecandidate\",{\"1\":{\"963\":2,\"1648\":1}}],[\"resolvefieldvalue\",{\"1\":{\"964\":2,\"1648\":1}}],[\"resolvenotunique\",{\"1\":{\"963\":1,\"1648\":1}}],[\"resolveembeddedvalue\",{\"1\":{\"963\":1,\"978\":1,\"1648\":1}}],[\"resolvegeneric\",{\"1\":{\"963\":3,\"1103\":2}}],[\"resolve\",{\"1\":{\"963\":2,\"964\":1,\"997\":2,\"1103\":4,\"1432\":2,\"1479\":1,\"1614\":1,\"1647\":2,\"1663\":2}}],[\"resolvedautowiremode\",{\"1\":{\"1647\":5}}],[\"resolvedarraytype\",{\"1\":{\"963\":3}}],[\"resolvedtargettype\",{\"1\":{\"1647\":1}}],[\"resolvedconstructororfactorymethod\",{\"1\":{\"1650\":1}}],[\"resolvedclass\",{\"1\":{\"998\":3,\"1647\":3}}],[\"resolvedcachedargument\",{\"1\":{\"964\":1}}],[\"resolved\",{\"1\":{\"997\":1,\"1647\":4,\"1650\":4}}],[\"resolvedependency方法的过程\",{\"1\":{\"964\":1}}],[\"resolvedependency处打个断点进行观察\",{\"1\":{\"963\":1}}],[\"resolvedependency\",{\"1\":{\"963\":2,\"1648\":2}}],[\"resolvemultiplebeans\",{\"1\":{\"963\":2,\"1648\":1}}],[\"resolvereturntypeargument\",{\"1\":{\"1100\":3}}],[\"resolvereturntype\",{\"1\":{\"1100\":3}}],[\"resolver\",{\"1\":{\"900\":1,\"1146\":1,\"1171\":1,\"1648\":5}}],[\"resolvabledependencies\",{\"1\":{\"1648\":1}}],[\"resolvabledependencysourcedemo\",{\"1\":{\"977\":2}}],[\"resolvabledependency作为依赖来源\",{\"1\":{\"977\":1}}],[\"resolvabletype无法处理非具体化的parameterizedtype\",{\"1\":{\"1103\":1}}],[\"resolvabletype无法处理泛型擦写\",{\"1\":{\"1103\":1}}],[\"resolvabletype也有两个局限性\",{\"1\":{\"1103\":1}}],[\"resolvabletypedemo\",{\"1\":{\"1103\":1}}],[\"resolvabletype\",{\"0\":{\"1103\":1},\"1\":{\"940\":1,\"941\":1,\"963\":7,\"1101\":1,\"1103\":10,\"1125\":1}}],[\"resolvable\",{\"0\":{\"977\":1},\"1\":{\"899\":1,\"973\":1,\"974\":1,\"982\":1,\"1162\":1,\"1164\":1}}],[\"resource注解可以在不修改源码的情况下完成迁移\",{\"1\":{\"1648\":1}}],[\"resource注解是因为\",{\"1\":{\"1648\":1}}],[\"resource是java规范支持的注解\",{\"1\":{\"1648\":1}}],[\"resource和\",{\"1\":{\"1648\":1}}],[\"resourcepattern\",{\"1\":{\"1647\":1}}],[\"resourcepatternresolver\",{\"1\":{\"1042\":1,\"1043\":3,\"1134\":1,\"1637\":1,\"1647\":1}}],[\"resourceeditorregistrar\",{\"1\":{\"1164\":2}}],[\"resourcebundlemessagesource\",{\"1\":{\"1054\":1,\"1059\":1,\"1063\":1}}],[\"resourcebundlecontrolprovider\",{\"1\":{\"1052\":1}}],[\"resourcebundle核心特性\",{\"1\":{\"1052\":1}}],[\"resourcebundle\",{\"1\":{\"1052\":2}}],[\"resourceutils\",{\"1\":{\"1043\":2,\"1044\":2}}],[\"resource加载器\",{\"1\":{\"1041\":1}}],[\"resource接口扩展\",{\"0\":{\"1040\":1}}],[\"resource接口\",{\"0\":{\"1038\":1}}],[\"resourceloader\",{\"1\":{\"957\":1,\"973\":6,\"1022\":3,\"1041\":3,\"1045\":5,\"1164\":2}}],[\"resourceloaderaware\",{\"1\":{\"957\":1,\"1005\":3,\"1045\":1,\"1164\":1}}],[\"resource\",{\"0\":{\"1044\":1},\"1\":{\"955\":3,\"956\":2,\"959\":1,\"966\":1,\"978\":5,\"997\":3,\"1000\":3,\"1021\":3,\"1022\":3,\"1023\":1,\"1026\":1,\"1032\":2,\"1038\":1,\"1040\":2,\"1041\":3,\"1043\":9,\"1044\":4,\"1172\":1,\"1242\":2,\"1619\":4,\"1647\":6}}],[\"resource=\",{\"1\":{\"918\":1,\"953\":2,\"954\":2}}],[\"resources声明成一个资源\",{\"1\":{\"1619\":1}}],[\"resources代码块的时候自动得到调用\",{\"1\":{\"1619\":1}}],[\"resources\",{\"1\":{\"892\":1,\"921\":1,\"922\":1,\"1032\":1,\"1043\":2,\"1619\":3,\"1647\":3,\"1651\":1}}],[\"results\",{\"1\":{\"1600\":3,\"1613\":1,\"1615\":5,\"1620\":1,\"1621\":1,\"1623\":4}}],[\"resultset\",{\"1\":{\"645\":2}}],[\"resulting\",{\"1\":{\"519\":6,\"1618\":1}}],[\"result需要申请本地内存来缓存查询结果\",{\"1\":{\"482\":1}}],[\"result方法\",{\"1\":{\"482\":2}}],[\"result这个提示\",{\"1\":{\"418\":1}}],[\"result\",{\"1\":{\"330\":1,\"418\":1,\"431\":1,\"582\":4,\"963\":18,\"997\":1,\"1000\":3,\"1006\":5,\"1053\":10,\"1072\":2,\"1575\":7,\"1597\":2,\"1598\":18,\"1600\":4,\"1601\":5,\"1608\":20,\"1609\":1,\"1610\":6,\"1613\":1,\"1615\":32,\"1617\":3,\"1618\":5,\"1619\":3,\"1620\":3,\"1621\":1,\"1623\":4,\"1647\":2,\"1648\":17,\"1654\":5,\"1655\":7}}],[\"resets\",{\"1\":{\"1623\":1}}],[\"resetbeandefinition\",{\"1\":{\"996\":1}}],[\"resetcommoncaches\",{\"1\":{\"922\":1,\"1647\":1,\"1651\":1}}],[\"reset\",{\"1\":{\"318\":1,\"922\":2,\"1162\":1,\"1175\":1,\"1623\":1,\"1647\":2,\"1651\":2}}],[\"restrictions\",{\"1\":{\"1619\":1}}],[\"rest\",{\"1\":{\"1166\":1,\"1986\":1}}],[\"rest风格的请求uri\",{\"1\":{\"306\":1}}],[\"restful风格的搜索和数据分析引擎\",{\"1\":{\"301\":1}}],[\"再做个系统性的项目把技术融合起来\",{\"1\":{\"1993\":1}}],[\"再深入学习个技术点就可以了\",{\"1\":{\"1988\":1}}],[\"再也不用满世界搜索下载\",{\"1\":{\"1980\":1}}],[\"再以串行的方式去执行\",{\"1\":{\"1620\":1}}],[\"再以这个接口为例\",{\"1\":{\"1594\":1}}],[\"再调用其他方法\",{\"1\":{\"1611\":1}}],[\"再调用第二个filter方法\",{\"1\":{\"1611\":1}}],[\"再调用引擎接口写入这行新数据\",{\"1\":{\"326\":1}}],[\"再取出流中的前两个元素\",{\"1\":{\"1610\":1}}],[\"再举这样一个例子来加深对于flatmap理解的场景\",{\"1\":{\"1609\":1}}],[\"再举一个例子\",{\"1\":{\"1607\":1}}],[\"再回到集合遍历的例子当中\",{\"1\":{\"1605\":1}}],[\"再回到主键索引上取值再判断\",{\"1\":{\"347\":1}}],[\"再来看一个例子\",{\"1\":{\"1610\":1}}],[\"再来看一个map和flatmap例子\",{\"1\":{\"1609\":1}}],[\"再来看一些具体的例子\",{\"1\":{\"1599\":1}}],[\"再来处理业务逻辑\",{\"1\":{\"1421\":1}}],[\"再jdk中有这样一个函数式接口bifunction\",{\"1\":{\"1598\":1}}],[\"再比如使用stringbuilder将字符串拼接起来\",{\"1\":{\"1615\":1}}],[\"再比如\",{\"1\":{\"1594\":2,\"1609\":1}}],[\"再比如我们经常会用到的创建线程的例子\",{\"1\":{\"1591\":1}}],[\"再比较position\",{\"1\":{\"505\":1}}],[\"再比较age\",{\"1\":{\"505\":1}}],[\"再对map做索引位置为3的get操作\",{\"1\":{\"1551\":1}}],[\"再对比age和position这两个字段的值是否符合\",{\"1\":{\"518\":1}}],[\"再对比字段值\",{\"1\":{\"340\":1}}],[\"再获取读锁最后释放写锁的次序\",{\"1\":{\"1498\":1}}],[\"再将偏向锁撤销为无锁状态或升级为轻量级锁\",{\"1\":{\"1485\":1}}],[\"再将描述符放进去\",{\"1\":{\"605\":1}}],[\"再重新上锁\",{\"1\":{\"1288\":1}}],[\"再set\",{\"1\":{\"1288\":1}}],[\"再创建实例\",{\"1\":{\"1191\":1}}],[\"再创建新的文档\",{\"1\":{\"306\":1}}],[\"再在数据库中进行查找\",{\"1\":{\"626\":1}}],[\"再分析使用普通索引的成本\",{\"1\":{\"549\":1}}],[\"再放入t2表剩余200行记录\",{\"1\":{\"525\":1}}],[\"再放回备库中\",{\"1\":{\"485\":1}}],[\"再申请时它的值就不会改变\",{\"1\":{\"499\":1}}],[\"再申请下一个id时\",{\"1\":{\"494\":1}}],[\"再启动一个事务\",{\"1\":{\"496\":1}}],[\"再插入数据时报主键冲突错误\",{\"1\":{\"495\":1}}],[\"再插入新的数据行是\",{\"1\":{\"491\":1}}],[\"再试图执行插入语句\",{\"1\":{\"494\":1}}],[\"再接入整个集群\",{\"1\":{\"488\":1}}],[\"再通过dma拷贝到nic\",{\"1\":{\"1576\":1}}],[\"再通过之前介绍的方法\",{\"1\":{\"486\":1}}],[\"再通过下面的这条语句\",{\"1\":{\"479\":1}}],[\"再进入终止逻辑阶段\",{\"1\":{\"481\":1}}],[\"再次运行\",{\"1\":{\"1617\":1}}],[\"再次删除缓存\",{\"1\":{\"1286\":1}}],[\"再次启动后作为主机是无法获取之前主机的数据的\",{\"1\":{\"611\":1}}],[\"再次从t1表里取数据跟join\",{\"1\":{\"525\":1}}],[\"再次出现这个异常\",{\"1\":{\"479\":1}}],[\"再次执行sql的执行计划\",{\"1\":{\"363\":1}}],[\"再传给备库\",{\"1\":{\"457\":1}}],[\"再传回给节点a\",{\"1\":{\"455\":1}}],[\"再把binlog\",{\"1\":{\"450\":1}}],[\"再观察执行效果\",{\"1\":{\"447\":1}}],[\"再请求的话\",{\"1\":{\"441\":1}}],[\"再加上248\",{\"1\":{\"497\":1}}],[\"再加上应用binlog的方式\",{\"1\":{\"485\":1}}],[\"再加上崩溃恢复这个逻辑\",{\"1\":{\"451\":1}}],[\"再加上binlog来恢复的\",{\"1\":{\"451\":1}}],[\"再加上\",{\"1\":{\"422\":1}}],[\"再用limit\",{\"1\":{\"422\":1}}],[\"再用其乘以在具体硬件下一次i\",{\"1\":{\"388\":1}}],[\"再判断其它条件\",{\"1\":{\"407\":1}}],[\"再判断test1里面name的值是否等于jyc\",{\"1\":{\"514\":1}}],[\"再判断test2里面的name的值是否等于jyc\",{\"1\":{\"514\":1}}],[\"再判断t1里面c的值是否等于10\",{\"1\":{\"321\":1}}],[\"再判断t2里面d的值是否等于20\",{\"1\":{\"321\":1}}],[\"再去通过自己的各种方式来完成本次转账\",{\"1\":{\"1501\":1}}],[\"再去查一次redis\",{\"1\":{\"1286\":1}}],[\"再去数据库里面执行\",{\"1\":{\"454\":1}}],[\"再去主键索引查数据\",{\"1\":{\"404\":1}}],[\"再去order\",{\"1\":{\"378\":1}}],[\"再根据名称进行过滤\",{\"1\":{\"1648\":1}}],[\"再根据字段m做排序\",{\"1\":{\"416\":1}}],[\"再根据一个个主键id的值到主键索引上去查整行数据的过程\",{\"1\":{\"404\":1}}],[\"再根据id值关联到test1\",{\"1\":{\"514\":1}}],[\"再根据id值关联到t1\",{\"1\":{\"321\":1}}],[\"再根据id值关联到表test2\",{\"1\":{\"514\":1}}],[\"再根据id值关联到表t2\",{\"1\":{\"321\":1}}],[\"再执行后面的操作\",{\"1\":{\"1289\":1}}],[\"再执行insert\",{\"1\":{\"492\":1}}],[\"再执行show\",{\"1\":{\"490\":1}}],[\"再执行三个limit\",{\"1\":{\"422\":1}}],[\"再执行\",{\"1\":{\"403\":1}}],[\"再搜索主键索引\",{\"1\":{\"401\":1}}],[\"再例如\",{\"1\":{\"394\":1}}],[\"再到被驱动表t2去做join\",{\"1\":{\"405\":1}}],[\"再到id索引上取整行然后判断\",{\"1\":{\"350\":1}}],[\"再到id索引树查到id=300对应的r3\",{\"1\":{\"337\":1}}],[\"再到id索引树搜索一次\",{\"1\":{\"335\":1}}],[\"再到主键索引上去查出每一行\",{\"1\":{\"347\":1}}],[\"再到gc清除\",{\"0\":{\"105\":1,\"1436\":1}}],[\"再写磁盘\",{\"1\":{\"324\":1}}],[\"再写数据库\",{\"0\":{\"134\":1,\"1286\":1},\"1\":{\"1286\":1}}],[\"再删缓存\",{\"0\":{\"135\":1,\"1287\":1},\"1\":{\"1287\":1}}],[\"再转红黑树\",{\"0\":{\"32\":1,\"1360\":1}}],[\"创建servlet容器\",{\"1\":{\"1658\":1}}],[\"创建数据库连接conn\",{\"1\":{\"1655\":1}}],[\"创建数组\",{\"1\":{\"1554\":1}}],[\"创建代理对象的核心方法\",{\"1\":{\"1654\":1}}],[\"创建读取器\",{\"1\":{\"1651\":1}}],[\"创建bean的方法\",{\"1\":{\"1647\":1}}],[\"创建bean\",{\"1\":{\"1647\":1}}],[\"创建beanfactory的实例对象\",{\"1\":{\"1651\":1}}],[\"创建beanfactory实例对象\",{\"1\":{\"1651\":1}}],[\"创建beanfactory\",{\"1\":{\"1163\":1}}],[\"创建beanfactory容器\",{\"1\":{\"921\":2}}],[\"创建实现factorybean的实例对象\",{\"1\":{\"1647\":1}}],[\"创建非懒加载的单例bean\",{\"1\":{\"1647\":1}}],[\"创建流元的过程是由streamsupport这个类来完成的\",{\"1\":{\"1621\":1}}],[\"创建出来的分割迭代器具有\",{\"1\":{\"1620\":1}}],[\"创建出来的分割迭代器继承了集合迭代器的快速失败\",{\"1\":{\"1620\":1}}],[\"创建的就是并行流\",{\"1\":{\"1619\":1}}],[\"创建的就是串行流\",{\"1\":{\"1619\":1}}],[\"创建线程时需要用到的runnable接口\",{\"1\":{\"1594\":1}}],[\"创建线程池\",{\"1\":{\"1517\":3}}],[\"创建100000个花费的总毫秒值\",{\"1\":{\"1591\":1}}],[\"创建成本很高\",{\"1\":{\"1533\":1}}],[\"创建生产者\",{\"1\":{\"1521\":1}}],[\"创建ringbuffer容器\",{\"1\":{\"1521\":1}}],[\"创建dispatcherservlet\",{\"1\":{\"1658\":1}}],[\"创建disruptor\",{\"1\":{\"1521\":1}}],[\"创建databinder\",{\"1\":{\"1072\":2}}],[\"创建事件\",{\"1\":{\"1520\":1}}],[\"创建completionservice\",{\"1\":{\"1517\":2}}],[\"创建current\",{\"1\":{\"1116\":1}}],[\"创建类或接口的静态变量\",{\"1\":{\"1433\":1}}],[\"创建服务端启动引导\",{\"1\":{\"1226\":1}}],[\"创建客户端启动引导\",{\"1\":{\"1226\":1}}],[\"创建对象\",{\"1\":{\"1181\":1,\"1433\":1}}],[\"创建对象有哪些方式\",{\"0\":{\"23\":1,\"1352\":1}}],[\"创建parent\",{\"1\":{\"1116\":1}}],[\"创建propertyvalues\",{\"1\":{\"1072\":2}}],[\"创建空白对象\",{\"1\":{\"1072\":2}}],[\"创建errors对象\",{\"1\":{\"1064\":1}}],[\"创建validator\",{\"1\":{\"1064\":1}}],[\"创建user对象\",{\"1\":{\"1063\":1}}],[\"创建型模式\",{\"0\":{\"833\":1}}],[\"创建基于内存的临时表写入或者读取一条记录的成本\",{\"1\":{\"557\":1}}],[\"创建基于磁盘的临时表的成本\",{\"1\":{\"557\":1}}],[\"创建快照时\",{\"1\":{\"542\":1}}],[\"创建临时表和对这个临时表进行写入和读取的操作代价还是很高的\",{\"1\":{\"557\":1}}],[\"创建临时表\",{\"1\":{\"431\":1}}],[\"创建临时表的语句会自动在备库执行\",{\"1\":{\"413\":1}}],[\"创建内存临时表\",{\"1\":{\"416\":1}}],[\"创建一个数据库连接\",{\"1\":{\"1630\":1}}],[\"创建一个针对于这个集合的元素分割迭代器\",{\"1\":{\"1620\":1}}],[\"创建一个新的对象\",{\"1\":{\"1344\":1}}],[\"创建一个外部userfactory对象\",{\"1\":{\"936\":1}}],[\"创建一个临时表\",{\"1\":{\"420\":1}}],[\"创建一个内存临时表\",{\"1\":{\"414\":1}}],[\"创建一个对象的过程\",{\"0\":{\"98\":1,\"1429\":1}}],[\"创建第二表的过程中就会发现table\",{\"1\":{\"412\":1}}],[\"创建复合索引\",{\"1\":{\"378\":1}}],[\"创建表t1和t2\",{\"1\":{\"404\":1}}],[\"创建表\",{\"1\":{\"378\":1}}],[\"创建idx\",{\"1\":{\"361\":1}}],[\"创建符合索引idx\",{\"1\":{\"361\":1}}],[\"创建好索引之后\",{\"1\":{\"336\":1}}],[\"创建\",{\"1\":{\"306\":1}}],[\"创建新的文档\",{\"1\":{\"306\":1}}],[\"创建文档\",{\"1\":{\"306\":2,\"309\":1}}],[\"创建索引idx\",{\"1\":{\"361\":1,\"362\":2}}],[\"创建索引时可以设置分片数和副本数\",{\"1\":{\"305\":1}}],[\"创建索引\",{\"1\":{\"305\":1,\"361\":1,\"362\":2}}],[\"创建索引格式\",{\"1\":{\"305\":1}}],[\"h5dpvd6sy8uw\",{\"1\":{\"1972\":1}}],[\"href=\",{\"1\":{\"1597\":1,\"1598\":3,\"1599\":2,\"1600\":1,\"1601\":1,\"1608\":8}}],[\"hpp\",{\"1\":{\"1479\":1}}],[\"h^\",{\"1\":{\"1359\":1}}],[\"hyperloglog底层使用string\",{\"1\":{\"577\":1}}],[\"hyperloglog就能帮助我们利用最小的空间完成\",{\"1\":{\"577\":1}}],[\"hyperloglog\",{\"0\":{\"577\":1},\"1\":{\"577\":8,\"1280\":1}}],[\"hyperloglogs等数据类型\",{\"1\":{\"568\":1}}],[\"hscan\",{\"1\":{\"573\":1}}],[\"hsetnx\",{\"1\":{\"573\":5}}],[\"hset\",{\"1\":{\"573\":5}}],[\"hdel\",{\"1\":{\"573\":3}}],[\"hvals\",{\"1\":{\"573\":3}}],[\"hlen\",{\"1\":{\"573\":3}}],[\"hkeys\",{\"1\":{\"573\":4}}],[\"hms\",{\"1\":{\"1055\":3,\"1167\":3}}],[\"hmset\",{\"1\":{\"573\":3}}],[\"hmget\",{\"1\":{\"573\":3}}],[\"hgetall\",{\"1\":{\"573\":3}}],[\"hget\",{\"1\":{\"573\":3}}],[\"hotswap\",{\"1\":{\"1693\":1}}],[\"hotspot的算法实现细节\",{\"0\":{\"1757\":1}}],[\"hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上\",{\"1\":{\"1488\":1}}],[\"hotspot虚拟机对象\",{\"0\":{\"1709\":1}}],[\"hotspot虚拟机在启动后有4s的延迟才会对每个新建的对象开启偏向锁模式\",{\"1\":{\"1485\":1}}],[\"hotspot虚拟机的对象头包括\",{\"1\":{\"1484\":1}}],[\"hotspot虚拟机中\",{\"1\":{\"1484\":1}}],[\"hotspot\",{\"1\":{\"1479\":2}}],[\"how\",{\"1\":{\"1620\":1,\"1623\":2}}],[\"however\",{\"1\":{\"1615\":1,\"1619\":2,\"1620\":3}}],[\"hoare模型和mesa模型\",{\"1\":{\"1483\":1}}],[\"hook线程\",{\"1\":{\"1175\":1}}],[\"hold\",{\"1\":{\"1619\":1}}],[\"holder\",{\"1\":{\"1003\":2,\"1006\":1,\"1007\":3,\"1008\":1,\"1009\":1,\"1011\":1,\"1012\":4}}],[\"holding\",{\"1\":{\"571\":1}}],[\"hollywood\",{\"1\":{\"905\":1}}],[\"host>\",{\"1\":{\"1683\":1}}],[\"host\",{\"1\":{\"610\":1,\"1226\":1,\"1573\":2,\"1574\":2,\"1575\":2}}],[\"host=39\",{\"1\":{\"583\":1}}],[\"host=$host\",{\"1\":{\"467\":1,\"468\":1}}],[\"hostname\",{\"1\":{\"429\":2}}],[\"hh\",{\"1\":{\"529\":3,\"1053\":1,\"1528\":1}}],[\"hibernate\",{\"1\":{\"1979\":2}}],[\"hikaricp\",{\"1\":{\"1974\":1}}],[\"highly\",{\"1\":{\"1620\":2}}],[\"hi\",{\"1\":{\"1609\":1}}],[\"hitail\",{\"1\":{\"1550\":6}}],[\"hihead\",{\"1\":{\"1550\":3}}],[\"hidden\",{\"1\":{\"1201\":1,\"1615\":1}}],[\"hierarchicalbeanfactory\",{\"1\":{\"1636\":1}}],[\"hierarchicalspringeventpropagatedemo\",{\"1\":{\"1116\":1}}],[\"hierarchicalmessagesource\",{\"1\":{\"1051\":1,\"1055\":3,\"1058\":1,\"1167\":3}}],[\"hierachicalbeanfactory\",{\"1\":{\"942\":1,\"1637\":1}}],[\"histlen\",{\"1\":{\"609\":1}}],[\"hincrbyfloat\",{\"1\":{\"573\":3}}],[\"hincrby\",{\"1\":{\"573\":4}}],[\"hints\",{\"1\":{\"1615\":1}}],[\"hint\",{\"1\":{\"418\":1}}],[\"hire\",{\"1\":{\"510\":3,\"518\":3}}],[\"h127\",{\"1\":{\"454\":1}}],[\"here\",{\"1\":{\"997\":1,\"1170\":1,\"1619\":1,\"1620\":3,\"1623\":1,\"1647\":1,\"1689\":1}}],[\"hexists\",{\"1\":{\"573\":4}}],[\"held\",{\"1\":{\"1620\":2}}],[\"hello=hello\",{\"1\":{\"1617\":4}}],[\"hellohello\",{\"1\":{\"1601\":2}}],[\"helloworldimportbeandefinitionregistrar\",{\"1\":{\"1138\":2}}],[\"helloworldimportselector\",{\"1\":{\"1138\":3}}],[\"helloworldconfiguration\",{\"1\":{\"1138\":6}}],[\"helloworld\",{\"1\":{\"940\":3,\"943\":2,\"1138\":3,\"1608\":3,\"1609\":3}}],[\"hello\",{\"1\":{\"547\":1,\"570\":6,\"582\":1,\"598\":6,\"977\":1,\"1053\":1,\"1108\":1,\"1115\":2,\"1119\":1,\"1123\":2,\"1365\":2,\"1593\":12,\"1594\":2,\"1595\":2,\"1597\":4,\"1599\":1,\"1600\":2,\"1601\":2,\"1602\":2,\"1606\":1,\"1607\":8,\"1608\":3,\"1609\":14,\"1610\":4,\"1612\":5,\"1614\":1,\"1617\":20,\"1619\":10,\"1620\":2}}],[\"helper\",{\"1\":{\"1621\":1,\"1623\":11}}],[\"helping\",{\"1\":{\"1620\":1}}],[\"helptransfer\",{\"1\":{\"1554\":1}}],[\"help打印出来\",{\"1\":{\"1453\":1}}],[\"help\",{\"1\":{\"429\":3}}],[\"headfirst设计模式\",{\"1\":{\"1992\":1}}],[\"head类本身有两个泛型\",{\"1\":{\"1621\":1}}],[\"head<e\",{\"1\":{\"1621\":1}}],[\"head<>\",{\"1\":{\"1621\":1}}],[\"head是referencepipeline的一个静态内部类\",{\"1\":{\"1621\":1}}],[\"head节点本身是不存储任何元素的\",{\"1\":{\"1503\":1}}],[\"head\",{\"1\":{\"1503\":4,\"1621\":5,\"1623\":1,\"1624\":1}}],[\"header\",{\"1\":{\"542\":1,\"1483\":1,\"1484\":1,\"1619\":1}}],[\"heartbeatevent\",{\"1\":{\"1126\":1}}],[\"health\",{\"1\":{\"477\":1,\"478\":4}}],[\"heap\",{\"1\":{\"431\":1}}],[\"h\",{\"1\":{\"429\":1,\"577\":1,\"599\":1,\"1347\":6,\"1359\":1,\"1503\":4,\"1548\":11}}],[\"hao134838\",{\"1\":{\"1649\":1}}],[\"half\",{\"1\":{\"1620\":2}}],[\"having\",{\"1\":{\"1620\":1}}],[\"have\",{\"1\":{\"320\":1,\"963\":1,\"997\":1,\"1170\":1,\"1594\":4,\"1595\":2,\"1615\":3,\"1619\":2,\"1620\":4,\"1623\":2,\"1647\":2,\"1648\":1,\"1689\":2}}],[\"happens\",{\"1\":{\"1615\":1,\"1623\":1}}],[\"happers\",{\"1\":{\"1373\":1}}],[\"hassuspendingflowreturntype\",{\"1\":{\"1655\":3}}],[\"hasmatchingintroductions\",{\"1\":{\"1654\":1}}],[\"hasintroductions\",{\"1\":{\"1654\":4}}],[\"hasinstawarebpps\",{\"1\":{\"1647\":2}}],[\"hasinstantiationawarebeanpostprocessors\",{\"1\":{\"1647\":3}}],[\"hasconstructorargumentvalues\",{\"1\":{\"1650\":1}}],[\"hascharacteristics\",{\"1\":{\"1620\":1}}],[\"hasqualifier\",{\"1\":{\"1648\":1}}],[\"haspropertyvalues\",{\"1\":{\"1647\":2}}],[\"hasdependentbean\",{\"1\":{\"1647\":1}}],[\"hasannotatedmethods\",{\"1\":{\"1647\":1}}],[\"hasremaining\",{\"1\":{\"1575\":1}}],[\"has\",{\"1\":{\"1432\":1,\"1594\":2,\"1610\":1,\"1615\":1,\"1617\":1,\"1619\":1,\"1620\":7,\"1622\":1,\"1623\":4,\"1647\":2}}],[\"hasembeddedvalueresolver\",{\"1\":{\"1171\":1}}],[\"hasbeanclass\",{\"1\":{\"1647\":1}}],[\"hasbeancreationstarted\",{\"1\":{\"996\":1}}],[\"hasbeanfactory\",{\"1\":{\"1163\":1,\"1651\":1}}],[\"haslength\",{\"1\":{\"997\":1,\"1007\":1,\"1647\":2,\"1658\":1}}],[\"hasnext\",{\"1\":{\"930\":1,\"1574\":2,\"1609\":1,\"1620\":1,\"1622\":1}}],[\"hastext\",{\"1\":{\"928\":2,\"929\":1,\"996\":1,\"1030\":1}}],[\"hashentry<k\",{\"1\":{\"1553\":5}}],[\"hashentry中\",{\"1\":{\"1553\":1}}],[\"hashtable的默认构造函数\",{\"1\":{\"1555\":1}}],[\"hashtable底层基于数组与链表实现\",{\"1\":{\"1555\":1}}],[\"hashtable源码分析\",{\"0\":{\"1555\":1}}],[\"hashtable是历史遗留类\",{\"1\":{\"1544\":1}}],[\"hashtable是基于方法级别的synchronized的来实现的\",{\"1\":{\"1475\":1}}],[\"hashtable\",{\"1\":{\"1540\":1,\"1544\":1}}],[\"hashtable和concurrenthashmap\",{\"1\":{\"1475\":1}}],[\"hashtable等带来性能提升\",{\"1\":{\"1342\":1}}],[\"hashset<>\",{\"1\":{\"1617\":1}}],[\"hashset是调用hashmap的put\",{\"1\":{\"1557\":1}}],[\"hashset实现了set接口\",{\"1\":{\"1557\":1}}],[\"hashset实现原理\",{\"0\":{\"40\":1,\"1368\":1}}],[\"hashset源码分析\",{\"0\":{\"1557\":1}}],[\"hashset\",{\"1\":{\"1539\":1,\"1617\":3,\"1618\":1}}],[\"hashset删除元素的方法\",{\"1\":{\"1368\":1}}],[\"hashset添加元素的方法\",{\"1\":{\"1368\":1}}],[\"hashcode发生了改变\",{\"1\":{\"1365\":1}}],[\"hashcode可能发生改变\",{\"1\":{\"1365\":1}}],[\"hashcode碰撞次数与泊松分布有关\",{\"1\":{\"1362\":1}}],[\"hashcode\",{\"1\":{\"928\":1,\"1347\":1,\"1484\":1,\"1546\":1,\"1548\":3,\"1549\":1,\"1553\":1,\"1554\":1}}],[\"hashcode和equals的作用\",{\"0\":{\"19\":1,\"1348\":1}}],[\"hash的value\",{\"1\":{\"583\":1}}],[\"hash的key\",{\"1\":{\"583\":1}}],[\"hash更适合于对象的存储\",{\"1\":{\"573\":1}}],[\"hash变更的数据user\",{\"1\":{\"573\":1}}],[\"hash特别适合用于存储对象\",{\"1\":{\"573\":1}}],[\"hash冲突问题\",{\"1\":{\"504\":1}}],[\"hash表\",{\"1\":{\"501\":1}}],[\"hash\",{\"0\":{\"408\":1,\"504\":1,\"573\":1},\"1\":{\"461\":2,\"573\":2,\"1280\":1,\"1347\":2,\"1357\":2,\"1546\":2,\"1548\":1,\"1549\":11,\"1550\":2,\"1553\":10,\"1554\":11}}],[\"hashmapinfiniteloop\",{\"1\":{\"1551\":1}}],[\"hashmap线程不安全的主要原因是在多线程的使用场景下可能会造成死循环\",{\"1\":{\"1551\":1}}],[\"hashmap定位数组索引位置的方法\",{\"1\":{\"1548\":1}}],[\"hashmap采用这种设计\",{\"1\":{\"1546\":1}}],[\"hashmap就需要重新resize\",{\"1\":{\"1546\":1}}],[\"hashmap就是采用了链地址法\",{\"1\":{\"1546\":1}}],[\"hashmap就是使用哈希表来存储的\",{\"1\":{\"1546\":1}}],[\"hashmap中实际存在的键值对数量\",{\"1\":{\"1546\":1}}],[\"hashmap中有几个非常重要的属性\",{\"1\":{\"1546\":1}}],[\"hashmap内部结构发生变化的次数\",{\"1\":{\"1546\":1}}],[\"hashmap是可以允许为空的\",{\"1\":{\"1554\":1}}],[\"hashmap是数组+链表+红黑树\",{\"1\":{\"1546\":1}}],[\"hashmap是java程序员使用频率最高的用于映射\",{\"1\":{\"1545\":1}}],[\"hashmap原理分析\",{\"0\":{\"1545\":1}}],[\"hashmap非线程安全\",{\"1\":{\"1544\":1}}],[\"hashmap最多只允许一条记录的键位null\",{\"1\":{\"1544\":1}}],[\"hashmap插入元素的方式\",{\"1\":{\"1475\":1}}],[\"hashmap的table属性引用新的entry数组\",{\"1\":{\"1550\":1}}],[\"hashmap的底层存储结构\",{\"1\":{\"1475\":1}}],[\"hashmap的特点\",{\"1\":{\"1475\":1}}],[\"hashmap的value是object类型\",{\"1\":{\"1368\":1}}],[\"hashmap底层原理\",{\"0\":{\"1475\":1}}],[\"hashmap使用对象的hashcode方法确定对象在哈希表中的存储位置\",{\"1\":{\"1367\":1}}],[\"hashmapdemo\",{\"1\":{\"1365\":1}}],[\"hashmap为了存取高效\",{\"1\":{\"1357\":1}}],[\"hashmap为什么扩容为2倍\",{\"0\":{\"29\":1,\"1357\":1}}],[\"hashmap<e\",{\"1\":{\"1368\":1}}],[\"hashmap<list<string>\",{\"1\":{\"1365\":1}}],[\"hashmap<integer\",{\"1\":{\"1103\":1,\"1551\":2}}],[\"hashmap<string\",{\"1\":{\"1072\":2,\"1156\":1}}],[\"hashmap<>\",{\"1\":{\"989\":1,\"1031\":1,\"1072\":2,\"1156\":1,\"1365\":1,\"1617\":1,\"1638\":1}}],[\"hashmap\",{\"1\":{\"645\":2,\"1475\":2,\"1540\":1,\"1544\":1,\"1618\":1}}],[\"hashmap在并发编程环境下有什么问题\",{\"0\":{\"36\":1,\"1364\":1}}],[\"hashmap不使用红黑树\",{\"0\":{\"33\":1,\"1361\":1}}],[\"hashmap实现原理\",{\"0\":{\"28\":1,\"1356\":1}}],[\"handoff\",{\"1\":{\"1620\":1}}],[\"hands\",{\"1\":{\"1620\":1}}],[\"hand\",{\"1\":{\"1620\":1}}],[\"handling\",{\"1\":{\"1175\":1,\"1650\":1}}],[\"handles\",{\"1\":{\"1619\":1}}],[\"handle的本意是把柄\",{\"1\":{\"1561\":1}}],[\"handleeventswithworkerpool\",{\"1\":{\"1521\":1}}],[\"handleeventswith\",{\"1\":{\"1521\":2}}],[\"handleerror\",{\"1\":{\"1124\":1}}],[\"handlenode\",{\"1\":{\"645\":1}}],[\"handlertypes执行的接口的实现类\",{\"1\":{\"1658\":1}}],[\"handlertypes\",{\"1\":{\"1658\":1}}],[\"handleradapter\",{\"1\":{\"1657\":2}}],[\"handleradapter的典型实现\",{\"1\":{\"1657\":1}}],[\"handlermapping\",{\"1\":{\"1657\":1}}],[\"handlermapping的典型实现\",{\"1\":{\"1657\":1}}],[\"handlerinterceptor\",{\"1\":{\"1657\":4}}],[\"handlerkey代码如下\",{\"1\":{\"1574\":1}}],[\"handlerkey\",{\"1\":{\"1574\":2}}],[\"handler包下\",{\"1\":{\"1049\":1}}],[\"handler实现类映射文件\",{\"1\":{\"1048\":1}}],[\"handlers\",{\"1\":{\"1036\":1,\"1048\":1}}],[\"handler\",{\"1\":{\"645\":3,\"900\":1,\"1049\":1,\"1476\":2,\"1510\":1,\"1593\":1,\"1657\":8}}],[\"handle\",{\"1\":{\"603\":3,\"1574\":3}}],[\"hanlp中文分词器\",{\"1\":{\"1255\":1}}],[\"hangzhou\",{\"1\":{\"576\":1,\"994\":1,\"1022\":1}}],[\"hanmei\",{\"1\":{\"535\":1}}],[\"hanmeimei\",{\"1\":{\"510\":1,\"518\":1}}],[\"ha系统就会开始工作\",{\"1\":{\"488\":1}}],[\"ha系统要切换b作为主库\",{\"1\":{\"459\":1}}],[\"h$ip\",{\"1\":{\"318\":1}}],[\"ht放到32个分库中的某一个上\",{\"1\":{\"411\":1}}],[\"ht表中\",{\"1\":{\"411\":1}}],[\"ht\",{\"1\":{\"411\":5}}],[\"html\",{\"1\":{\"308\":1,\"312\":1,\"517\":1,\"635\":1,\"639\":1,\"1597\":1,\"1598\":3,\"1599\":2,\"1600\":1,\"1601\":1,\"1608\":8,\"1627\":1,\"1969\":1,\"1975\":1,\"1977\":1}}],[\"http服务器+serverlet容器\",{\"1\":{\"1683\":1}}],[\"httpmessageconverter\",{\"1\":{\"1657\":1}}],[\"httprequesthandleradapter\",{\"1\":{\"1657\":1}}],[\"http默认端口是80\",{\"1\":{\"1424\":1}}],[\"http是免费的\",{\"1\":{\"1424\":1}}],[\"http的连接时简单无状态的\",{\"1\":{\"1424\":1}}],[\"httponly\",{\"1\":{\"1201\":1}}],[\"http2可以支持同时发在一个socket上送多个请求\",{\"1\":{\"643\":1}}],[\"http2原理解析\",{\"0\":{\"643\":1}}],[\"http\",{\"1\":{\"531\":1,\"540\":1,\"917\":4,\"918\":5,\"930\":8,\"953\":8,\"954\":8,\"1028\":6,\"1030\":7,\"1032\":4,\"1037\":1,\"1065\":6,\"1084\":4,\"1091\":7,\"1146\":4,\"1424\":1,\"1657\":1,\"1663\":1,\"1687\":1,\"1975\":1}}],[\"httpservletresponse\",{\"1\":{\"1657\":3}}],[\"httpservletrequest\",{\"1\":{\"1657\":3}}],[\"https也并不是完全安全的\",{\"1\":{\"1424\":1}}],[\"https的握手协议比较费时\",{\"1\":{\"1424\":1}}],[\"https的缺点\",{\"1\":{\"1424\":1}}],[\"https的数据传输时经过证书加密的\",{\"1\":{\"1424\":1}}],[\"https\",{\"1\":{\"308\":1,\"312\":1,\"330\":1,\"517\":2,\"561\":1,\"635\":1,\"639\":2,\"645\":1,\"1065\":1,\"1424\":1,\"1494\":1,\"1499\":1,\"1551\":1,\"1626\":1,\"1627\":1,\"1649\":1,\"1652\":1,\"1653\":1,\"1657\":1,\"1969\":3,\"1972\":3,\"1974\":2,\"1975\":2,\"1978\":1,\"1980\":1,\"1981\":3,\"1982\":1,\"1983\":1,\"1985\":2,\"1986\":1,\"1987\":3,\"1989\":1,\"1990\":1,\"1991\":1,\"1992\":2}}],[\"http和https的区别\",{\"0\":{\"94\":1,\"1424\":1}}],[\"分派\",{\"0\":{\"1807\":1}}],[\"分代收集理论\",{\"0\":{\"1719\":1}}],[\"分代收集理论基于以下三种假说和经验法则\",{\"1\":{\"1434\":1}}],[\"分开一半的范围\",{\"1\":{\"1620\":1}}],[\"分割\",{\"1\":{\"1621\":1}}],[\"分割迭代器无疑是函数式编程中一个相当核心的概念\",{\"1\":{\"1621\":1}}],[\"分割迭代器并不被要求是线程安全的\",{\"1\":{\"1620\":1}}],[\"分割之前和分割之后有可能特性值会不同\",{\"1\":{\"1620\":1}}],[\"分割左侧的\",{\"1\":{\"1620\":1}}],[\"分割以及遍历的行为是不确定的\",{\"1\":{\"1620\":1}}],[\"分解\",{\"1\":{\"1510\":1,\"1620\":1}}],[\"分解关联查询\",{\"0\":{\"394\":1}}],[\"分离对象或标量替换\",{\"1\":{\"1488\":1}}],[\"分配内存\",{\"0\":{\"1667\":1}}],[\"分配一个1024字节的缓冲区\",{\"1\":{\"1574\":1}}],[\"分配一个哈希表\",{\"1\":{\"462\":1}}],[\"分配资源的最小单位是进程\",{\"1\":{\"1477\":1}}],[\"分工问题\",{\"1\":{\"1470\":1}}],[\"分片信息都返回给协调节点\",{\"1\":{\"1256\":1}}],[\"分片sharding和副本replicas\",{\"1\":{\"1254\":1}}],[\"分层构建镜像\",{\"0\":{\"885\":1}}],[\"分布式mq的三种语义\",{\"1\":{\"1333\":1}}],[\"分布式事务指的是业务相关的多个操作\",{\"1\":{\"1333\":1}}],[\"分布式事务\",{\"1\":{\"1304\":1}}],[\"分布式事务如何处理\",{\"0\":{\"227\":1,\"1307\":1}}],[\"分布式服务\",{\"1\":{\"1248\":1}}],[\"分布式锁的本质\",{\"1\":{\"1288\":1}}],[\"分布式锁\",{\"1\":{\"630\":1,\"1248\":1}}],[\"分担服务器的负载\",{\"1\":{\"607\":1}}],[\"分数从高到低排序\",{\"1\":{\"574\":1}}],[\"分数从高到底\",{\"1\":{\"574\":1}}],[\"分组和分区还可以互相嵌套\",{\"1\":{\"1616\":1}}],[\"分组\",{\"1\":{\"1613\":1}}],[\"分组查询\",{\"1\":{\"557\":1}}],[\"分组等\",{\"1\":{\"381\":1}}],[\"分为有界和无界两种\",{\"1\":{\"1501\":1}}],[\"分为读锁和写锁\",{\"1\":{\"533\":1}}],[\"分为表锁和行锁\",{\"1\":{\"533\":1}}],[\"分为哪几类\",{\"0\":{\"62\":1,\"1391\":1}}],[\"分区有序\",{\"0\":{\"1863\":1}}],[\"分区一定是固定的两组结果\",{\"1\":{\"1618\":1}}],[\"分区\",{\"1\":{\"1613\":1}}],[\"分区可以认为是特殊的分组\",{\"1\":{\"1613\":1}}],[\"分区与分组\",{\"0\":{\"1613\":1}}],[\"分区容错性\",{\"1\":{\"1311\":1}}],[\"分区也不要提前预留太多\",{\"1\":{\"426\":1}}],[\"分区并不是越细越好\",{\"1\":{\"426\":1}}],[\"分区策略\",{\"0\":{\"425\":1}}],[\"分区表在使用的时候\",{\"1\":{\"426\":1}}],[\"分区表在做ddl的时候\",{\"1\":{\"425\":1}}],[\"分区表可以很方便的清理历史数据\",{\"1\":{\"426\":1}}],[\"分区表的一个显而易见的优势是对业务透明\",{\"1\":{\"426\":1}}],[\"分区表的应用场景\",{\"0\":{\"426\":1}}],[\"分区表最重要的问题在于\",{\"1\":{\"424\":1}}],[\"分区表和手工分表\",{\"1\":{\"424\":1}}],[\"分区表简介\",{\"0\":{\"424\":1}}],[\"分区表\",{\"0\":{\"423\":1}}],[\"分区key的选择是以\",{\"1\":{\"411\":1}}],[\"分成的段数也就越少\",{\"1\":{\"403\":1}}],[\"分块去join\",{\"1\":{\"403\":1}}],[\"分而治之\",{\"1\":{\"393\":1}}],[\"分析连接器的功能列表\",{\"1\":{\"1687\":1}}],[\"分析hashmap需要注意区别jdk1\",{\"1\":{\"1545\":1}}],[\"分析一下\",{\"1\":{\"1288\":1}}],[\"分析各个索引使用成本\",{\"1\":{\"519\":1}}],[\"分析步骤\",{\"1\":{\"431\":1}}],[\"分析\",{\"1\":{\"430\":1}}],[\"分析慢sql的步骤\",{\"0\":{\"430\":1}}],[\"分析sql\",{\"1\":{\"429\":1}}],[\"分析查询时\",{\"1\":{\"389\":1}}],[\"分析器\",{\"0\":{\"320\":1},\"1\":{\"317\":1}}],[\"分类器方法会将元素映射成某个k类型\",{\"1\":{\"1618\":1}}],[\"分类\",{\"1\":{\"362\":2,\"363\":1,\"1391\":1}}],[\"分类id\",{\"1\":{\"361\":1}}],[\"分词器等\",{\"1\":{\"309\":1}}],[\"分页\",{\"1\":{\"574\":1,\"646\":1}}],[\"分页查询优化\",{\"0\":{\"522\":1}}],[\"分页查询\",{\"1\":{\"306\":1}}],[\"分页插件的原理是什么\",{\"0\":{\"198\":1,\"1214\":1}}],[\"分库分表也并不是完美的\",{\"1\":{\"1270\":1}}],[\"分库分表最常用的组件\",{\"1\":{\"1270\":1}}],[\"分库分表系统的跨库查询就是一个典型的使用场景\",{\"1\":{\"411\":1}}],[\"分库分表后\",{\"0\":{\"161\":1,\"1270\":1}}],[\"分库分表的方式和分片策略由哪些\",{\"0\":{\"161\":1,\"1270\":1}}],[\"分别记为\",{\"1\":{\"1479\":1}}],[\"分别对应postprocessbeforeinitialization以及postprocessafterinitialization方法\",{\"1\":{\"1015\":1}}],[\"分别用于操作redis和redis中的string数据类型\",{\"1\":{\"583\":1}}],[\"分别用来表示自增的初始值和步长\",{\"1\":{\"491\":1}}],[\"分别表示relay\",{\"1\":{\"472\":1}}],[\"分别是endpoint\",{\"1\":{\"1687\":1}}],[\"分别是readfds\",{\"1\":{\"1569\":1}}],[\"分别是hasen模型\",{\"1\":{\"1483\":1}}],[\"分别是\",{\"1\":{\"448\":1}}],[\"分别是q1\",{\"1\":{\"446\":1}}],[\"分别存入sort\",{\"1\":{\"420\":1}}],[\"分别的特点是什么\",{\"0\":{\"104\":1,\"1435\":1}}],[\"分别有什么作用\",{\"0\":{\"92\":1,\"207\":1,\"1224\":1,\"1422\":1}}],[\"n1\",{\"1\":{\"1614\":3}}],[\"nfds\",{\"1\":{\"1570\":1}}],[\"nt\",{\"1\":{\"1554\":5}}],[\"nthreads\",{\"1\":{\"1227\":3}}],[\"n为table的长度\",{\"1\":{\"1550\":1}}],[\"n位table的长度\",{\"1\":{\"1548\":1}}],[\"ncpu\",{\"1\":{\"1480\":1}}],[\"n∗字节数\",{\"1\":{\"1475\":1}}],[\"n表示第n+1个构造器参数\",{\"1\":{\"1022\":1}}],[\"n测试\",{\"1\":{\"574\":1}}],[\"nihao\",{\"1\":{\"1614\":1}}],[\"nil\",{\"1\":{\"567\":1,\"569\":1,\"570\":1,\"579\":1,\"580\":1,\"581\":1}}],[\"nio文件读写本质\",{\"1\":{\"1965\":1}}],[\"nio有一个mappedbytebuffer的类\",{\"1\":{\"1587\":1}}],[\"nio虽然编码复杂\",{\"1\":{\"1574\":1}}],[\"nio比bio复杂很多\",{\"1\":{\"1574\":1}}],[\"nio中的一些概念\",{\"1\":{\"1574\":1}}],[\"nio弥补了同步阻塞io的不足\",{\"1\":{\"1574\":1}}],[\"nio的几个核心组件有\",{\"1\":{\"1422\":1}}],[\"nio的几个核心组件是什么\",{\"0\":{\"92\":1,\"1422\":1}}],[\"nio模型\",{\"1\":{\"1421\":1}}],[\"nioeventloopgroup\",{\"1\":{\"1226\":3}}],[\"nioeventloopgroup默认的构造函数会起多少线程\",{\"0\":{\"210\":1,\"1227\":1}}],[\"nio\",{\"0\":{\"1574\":1,\"1587\":1,\"1588\":1},\"1\":{\"1060\":2,\"1421\":1,\"1576\":1,\"1588\":2}}],[\"nio网络编程\",{\"0\":{\"690\":1}}],[\"n切换到db\",{\"1\":{\"567\":1}}],[\"n代表字符数\",{\"1\":{\"530\":1}}],[\"n>1\",{\"1\":{\"450\":1}}],[\"n这个语法\",{\"1\":{\"441\":1}}],[\"n+1\",{\"1\":{\"422\":1}}],[\"n分别是两张表的行数\",{\"1\":{\"406\":1}}],[\"n次对比\",{\"1\":{\"406\":1}}],[\"nlj算法比bnl算法性能更高\",{\"1\":{\"525\":1}}],[\"nlj算法执行的逻辑是\",{\"1\":{\"405\":1}}],[\"nlj和bnl都还有优化的空间\",{\"1\":{\"404\":1}}],[\"n小一些\",{\"1\":{\"403\":1}}],[\"n对扫描行数影响更大\",{\"1\":{\"401\":1}}],[\"nearly\",{\"1\":{\"1619\":1}}],[\"negation\",{\"1\":{\"1599\":4}}],[\"negate本身是否定的意思\",{\"1\":{\"1599\":1}}],[\"negate\",{\"1\":{\"1594\":1,\"1599\":3}}],[\"never\",{\"1\":{\"1238\":1,\"1615\":2}}],[\"nestinglevel\",{\"1\":{\"963\":1}}],[\"nested\",{\"0\":{\"401\":1,\"402\":1,\"403\":1},\"1\":{\"401\":1,\"402\":3,\"403\":7,\"523\":2,\"524\":1,\"555\":1,\"1073\":1,\"1074\":1,\"1238\":1,\"1542\":1}}],[\"necessary\",{\"1\":{\"928\":1,\"1175\":1}}],[\"neither\",{\"1\":{\"928\":1}}],[\"needed\",{\"1\":{\"1619\":1}}],[\"needing\",{\"1\":{\"1615\":1}}],[\"needsdepcheck\",{\"1\":{\"1647\":2}}],[\"needs\",{\"1\":{\"997\":1,\"1647\":1}}],[\"need\",{\"1\":{\"922\":1,\"1170\":1,\"1619\":1,\"1623\":1,\"1647\":1,\"1651\":1,\"1689\":1}}],[\"new关键词\",{\"1\":{\"1666\":1}}],[\"new关键字\",{\"1\":{\"1352\":1}}],[\"new指令对应到语言层面上讲是\",{\"1\":{\"1666\":1}}],[\"newratio\",{\"1\":{\"1664\":1}}],[\"new对象等等\",{\"1\":{\"1663\":1}}],[\"newproxyinstance\",{\"1\":{\"1654\":1}}],[\"newpvs\",{\"1\":{\"1647\":4}}],[\"new也可以写成arraylist<t>\",{\"1\":{\"1618\":1}}],[\"new中的new的话\",{\"1\":{\"1600\":1}}],[\"newtab\",{\"1\":{\"1550\":7}}],[\"newtable\",{\"1\":{\"1550\":4,\"1551\":1}}],[\"newthr\",{\"1\":{\"1550\":6}}],[\"newtime1\",{\"1\":{\"1591\":2}}],[\"newtime\",{\"1\":{\"1288\":1,\"1591\":2}}],[\"newnode\",{\"1\":{\"1549\":2}}],[\"newfixedthreadpool\",{\"1\":{\"1517\":3,\"1534\":1,\"1535\":2}}],[\"newcap\",{\"1\":{\"1506\":1,\"1550\":8}}],[\"newcapacity\",{\"1\":{\"1475\":1,\"1550\":3}}],[\"newcondition\",{\"1\":{\"1502\":2,\"1503\":2}}],[\"newlinkedhashmap\",{\"1\":{\"1648\":1}}],[\"newline\",{\"1\":{\"1485\":1,\"1605\":1}}],[\"newlist\",{\"1\":{\"571\":9}}],[\"newvalue\",{\"1\":{\"1479\":1,\"1546\":1,\"1618\":4}}],[\"newinstance\",{\"1\":{\"1351\":1,\"1352\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"1123\":2}}],[\"newset\",{\"1\":{\"572\":4}}],[\"newxnode\",{\"1\":{\"645\":1}}],[\"newkey\",{\"1\":{\"569\":2}}],[\"newkey仅当\",{\"1\":{\"569\":1}}],[\"newkey修改\",{\"1\":{\"569\":1}}],[\"new\",{\"1\":{\"498\":2,\"519\":1,\"582\":3,\"583\":1,\"645\":5,\"917\":1,\"918\":1,\"919\":1,\"921\":4,\"927\":2,\"928\":1,\"929\":2,\"930\":4,\"931\":2,\"933\":2,\"934\":1,\"936\":2,\"940\":1,\"943\":1,\"944\":1,\"946\":5,\"953\":7,\"954\":3,\"955\":3,\"956\":1,\"957\":1,\"961\":12,\"962\":2,\"963\":8,\"964\":2,\"965\":1,\"967\":4,\"973\":1,\"975\":2,\"977\":1,\"978\":1,\"985\":6,\"989\":6,\"994\":2,\"995\":2,\"996\":3,\"997\":8,\"1000\":6,\"1001\":4,\"1002\":1,\"1003\":1,\"1005\":5,\"1006\":3,\"1007\":1,\"1008\":1,\"1011\":5,\"1019\":2,\"1022\":7,\"1027\":3,\"1029\":1,\"1030\":3,\"1031\":4,\"1032\":6,\"1040\":3,\"1041\":2,\"1043\":5,\"1044\":1,\"1045\":1,\"1053\":12,\"1055\":1,\"1056\":1,\"1061\":1,\"1063\":3,\"1064\":3,\"1065\":2,\"1072\":9,\"1082\":3,\"1084\":5,\"1091\":2,\"1108\":3,\"1112\":2,\"1113\":3,\"1115\":1,\"1116\":3,\"1119\":3,\"1120\":5,\"1121\":1,\"1123\":9,\"1134\":1,\"1138\":3,\"1139\":1,\"1146\":1,\"1148\":1,\"1149\":1,\"1156\":3,\"1157\":1,\"1162\":2,\"1163\":1,\"1164\":6,\"1165\":2,\"1166\":8,\"1167\":1,\"1168\":1,\"1172\":1,\"1173\":1,\"1174\":2,\"1175\":3,\"1181\":2,\"1182\":2,\"1184\":3,\"1191\":2,\"1192\":1,\"1193\":2,\"1194\":1,\"1226\":5,\"1234\":1,\"1238\":1,\"1239\":1,\"1365\":3,\"1368\":1,\"1387\":1,\"1388\":2,\"1404\":12,\"1412\":2,\"1476\":1,\"1479\":5,\"1484\":1,\"1486\":1,\"1487\":2,\"1502\":1,\"1503\":9,\"1517\":3,\"1521\":9,\"1528\":1,\"1533\":3,\"1534\":2,\"1535\":2,\"1550\":2,\"1551\":3,\"1553\":2,\"1554\":4,\"1557\":1,\"1573\":15,\"1574\":9,\"1575\":18,\"1591\":8,\"1592\":4,\"1595\":4,\"1597\":1,\"1598\":9,\"1599\":5,\"1600\":6,\"1601\":1,\"1603\":8,\"1604\":10,\"1605\":4,\"1606\":4,\"1607\":8,\"1608\":12,\"1609\":5,\"1611\":1,\"1612\":1,\"1613\":4,\"1614\":1,\"1615\":10,\"1616\":1,\"1617\":13,\"1618\":30,\"1619\":4,\"1620\":9,\"1621\":6,\"1622\":8,\"1623\":4,\"1632\":1,\"1633\":2,\"1634\":2,\"1635\":2,\"1638\":3,\"1639\":4,\"1640\":2,\"1644\":1,\"1646\":1,\"1647\":31,\"1648\":16,\"1650\":1,\"1651\":6,\"1654\":20,\"1655\":6,\"1658\":1,\"1689\":1}}],[\"nex=automatic\",{\"1\":{\"468\":1}}],[\"nextstage\",{\"1\":{\"1622\":1}}],[\"nextline\",{\"1\":{\"1573\":1}}],[\"nexttable\",{\"1\":{\"1554\":1}}],[\"next已经指向了key\",{\"1\":{\"1551\":1}}],[\"next导致了next指向了key\",{\"1\":{\"1551\":1}}],[\"next\",{\"1\":{\"930\":1,\"963\":1,\"1082\":1,\"1084\":1,\"1166\":1,\"1263\":1,\"1503\":4,\"1546\":2,\"1549\":2,\"1550\":10,\"1551\":4,\"1553\":1,\"1554\":3,\"1574\":3,\"1575\":1,\"1603\":1,\"1609\":1,\"1620\":2,\"1621\":1,\"1622\":1,\"1623\":1,\"1648\":2}}],[\"next命令\",{\"1\":{\"468\":1}}],[\"next是一个指定的gtid的值\",{\"1\":{\"468\":1}}],[\"next的值\",{\"1\":{\"468\":1}}],[\"next=gtid1\",{\"1\":{\"485\":1}}],[\"next=automatic\",{\"1\":{\"468\":2}}],[\"next=\",{\"1\":{\"454\":1,\"468\":3}}],[\"netflix架构图\",{\"1\":{\"1305\":1}}],[\"netflix\",{\"1\":{\"1305\":1}}],[\"net\",{\"1\":{\"330\":1,\"561\":1,\"1037\":6,\"1049\":1,\"1649\":1}}],[\"nettyruntime\",{\"1\":{\"1227\":1}}],[\"netty\",{\"1\":{\"1227\":1}}],[\"netty中的处理器\",{\"0\":{\"725\":1}}],[\"netty中的设计原则\",{\"0\":{\"715\":1}}],[\"netty中的reactor线程模型\",{\"0\":{\"706\":1}}],[\"netty中的future对象\",{\"0\":{\"696\":1}}],[\"netty与websocket\",{\"0\":{\"662\":1}}],[\"netty对socket的实现\",{\"0\":{\"658\":1}}],[\"netty整体执行流程分析\",{\"0\":{\"657\":1}}],[\"netty模块分析\",{\"0\":{\"656\":1}}],[\"netty的hello\",{\"0\":{\"655\":1}}],[\"netty的零拷贝了解么\",{\"0\":{\"214\":1,\"1231\":1}}],[\"netty架构实现\",{\"0\":{\"654\":1}}],[\"netty特点\",{\"0\":{\"648\":1}}],[\"netty长连接\",{\"0\":{\"213\":1,\"1230\":1}}],[\"netty服务端和客户端的启动过程了解么\",{\"0\":{\"212\":1,\"1229\":1}}],[\"netty线程模型了解么\",{\"0\":{\"211\":1,\"1228\":1}}],[\"netty核心组件有哪些\",{\"0\":{\"207\":1,\"1224\":1}}],[\"netty有哪些应用场景\",{\"0\":{\"206\":1,\"1223\":1}}],[\"netty面试题\",{\"0\":{\"205\":1,\"1222\":1}}],[\"n\",{\"1\":{\"334\":1,\"377\":1,\"403\":4,\"422\":3,\"429\":4,\"441\":1,\"444\":1,\"468\":2,\"481\":1,\"530\":2,\"556\":2,\"558\":2,\"567\":1,\"570\":2,\"573\":3,\"574\":2,\"576\":1,\"589\":2,\"946\":1,\"985\":1,\"989\":1,\"1022\":2,\"1029\":1,\"1031\":1,\"1100\":2,\"1113\":1,\"1116\":1,\"1119\":1,\"1123\":1,\"1156\":1,\"1157\":1,\"1175\":1,\"1412\":8,\"1475\":1,\"1549\":4,\"1554\":11,\"1569\":1,\"1609\":3,\"1620\":1}}],[\"n叉\",{\"1\":{\"334\":1}}],[\"n叉树\",{\"1\":{\"334\":1}}],[\"n的值并不是递增的\",{\"1\":{\"332\":1}}],[\"n2\",{\"1\":{\"1614\":3}}],[\"n2的话\",{\"1\":{\"334\":1}}],[\"n2对应的名字\",{\"1\":{\"333\":1}}],[\"n2对应的名字是什么\",{\"1\":{\"332\":1}}],[\"n2通过哈希函数算出n\",{\"1\":{\"332\":1}}],[\"numeric\",{\"1\":{\"1614\":1}}],[\"numkeys\",{\"1\":{\"574\":3}}],[\"num\",{\"1\":{\"429\":2}}],[\"number=\",{\"1\":{\"1003\":1,\"1005\":1}}],[\"number=1\",{\"1\":{\"1003\":1}}],[\"numbers\",{\"1\":{\"429\":2}}],[\"number\",{\"1\":{\"305\":3,\"354\":2,\"355\":1,\"451\":1,\"479\":1,\"520\":2,\"959\":1,\"1003\":10,\"1005\":6,\"1012\":1,\"1053\":3,\"1139\":5,\"1480\":1,\"1613\":1,\"1620\":5,\"1621\":1}}],[\"nullpointerexception\",{\"1\":{\"1476\":1,\"1503\":1,\"1553\":1,\"1554\":1,\"1595\":1,\"1597\":1,\"1598\":6,\"1599\":4,\"1601\":2,\"1619\":10,\"1622\":1}}],[\"nullsafeequals\",{\"1\":{\"1000\":1,\"1001\":1,\"1002\":2,\"1003\":1,\"1006\":1,\"1008\":1,\"1011\":1,\"1019\":1}}],[\"nullbean\",{\"1\":{\"963\":2,\"1007\":1,\"1647\":1,\"1648\":1}}],[\"nullable\",{\"1\":{\"931\":1,\"963\":18,\"964\":3,\"965\":1,\"997\":1,\"998\":2,\"1007\":1,\"1008\":1,\"1022\":1,\"1027\":4,\"1647\":6,\"1648\":10,\"1650\":1,\"1654\":1,\"1655\":2}}],[\"null值表示未被压缩\",{\"1\":{\"553\":1}}],[\"null的话\",{\"1\":{\"399\":1}}],[\"null也无法使用索引\",{\"1\":{\"369\":1}}],[\"null\",{\"1\":{\"329\":6,\"330\":26,\"335\":1,\"336\":2,\"338\":5,\"346\":3,\"353\":5,\"361\":12,\"362\":4,\"363\":2,\"366\":4,\"368\":5,\"369\":1,\"378\":1,\"390\":4,\"400\":3,\"416\":3,\"419\":2,\"424\":2,\"446\":3,\"454\":3,\"459\":2,\"462\":3,\"468\":2,\"476\":2,\"478\":2,\"489\":3,\"490\":1,\"491\":5,\"492\":1,\"494\":3,\"506\":9,\"510\":5,\"518\":5,\"519\":1,\"523\":3,\"527\":1,\"534\":2,\"535\":3,\"553\":1,\"645\":1,\"928\":4,\"930\":1,\"963\":32,\"964\":4,\"965\":1,\"973\":1,\"989\":1,\"995\":1,\"996\":4,\"997\":8,\"998\":2,\"1000\":4,\"1001\":1,\"1002\":1,\"1003\":3,\"1005\":1,\"1006\":2,\"1007\":4,\"1008\":7,\"1019\":1,\"1020\":4,\"1022\":1,\"1023\":1,\"1027\":3,\"1043\":4,\"1055\":2,\"1061\":1,\"1063\":3,\"1100\":3,\"1124\":1,\"1139\":1,\"1162\":1,\"1165\":1,\"1167\":2,\"1170\":1,\"1171\":1,\"1175\":2,\"1191\":2,\"1193\":2,\"1288\":1,\"1351\":2,\"1388\":2,\"1432\":4,\"1476\":2,\"1480\":5,\"1483\":9,\"1502\":2,\"1503\":3,\"1517\":1,\"1548\":1,\"1549\":11,\"1550\":16,\"1553\":6,\"1554\":21,\"1573\":3,\"1574\":14,\"1575\":4,\"1594\":1,\"1595\":1,\"1597\":1,\"1598\":6,\"1599\":9,\"1601\":2,\"1605\":1,\"1618\":5,\"1619\":1,\"1620\":7,\"1621\":10,\"1622\":6,\"1623\":1,\"1647\":42,\"1648\":21,\"1650\":10,\"1654\":5,\"1655\":17,\"1658\":4,\"1663\":4}}],[\"narrows\",{\"1\":{\"1620\":1}}],[\"natural\",{\"1\":{\"1620\":2}}],[\"nativedetector\",{\"1\":{\"1164\":1,\"1165\":1,\"1172\":1,\"1175\":1,\"1651\":1}}],[\"native\",{\"1\":{\"425\":1,\"1457\":1}}],[\"nanoseconds\",{\"1\":{\"1612\":1}}],[\"nanotime\",{\"1\":{\"985\":2,\"989\":1,\"1432\":2,\"1612\":2,\"1663\":2}}],[\"navigableset\",{\"1\":{\"960\":1}}],[\"naming\",{\"1\":{\"908\":1,\"939\":2}}],[\"namematchmethodpointcut\",{\"1\":{\"1654\":2}}],[\"nametolookup\",{\"1\":{\"1647\":5}}],[\"namedthreadlocal\",{\"1\":{\"989\":1}}],[\"namedthreadlocal<map<string\",{\"1\":{\"989\":1}}],[\"nameduser\",{\"1\":{\"961\":9}}],[\"name是一个系统属性\",{\"1\":{\"978\":1}}],[\"name>\",{\"1\":{\"624\":8}}],[\"name字段在studentx中是否存在\",{\"1\":{\"573\":1}}],[\"name字段是比age字段大的\",{\"1\":{\"339\":1}}],[\"name具体的含义\",{\"1\":{\"558\":1}}],[\"name为jerry\",{\"1\":{\"542\":1}}],[\"name`\",{\"1\":{\"506\":1}}],[\"name表示统计的类型\",{\"1\":{\"479\":1}}],[\"name表里有很多行数据\",{\"1\":{\"479\":1}}],[\"name表里统计了每次io请求的时间\",{\"1\":{\"479\":1}}],[\"name文件的master\",{\"1\":{\"467\":1}}],[\"namesbycity\",{\"1\":{\"1618\":1}}],[\"namespace\",{\"1\":{\"1209\":1}}],[\"namespacehandlersupport\",{\"1\":{\"1030\":1}}],[\"names\",{\"1\":{\"429\":1,\"975\":1,\"1616\":2,\"1618\":2}}],[\"name和age这三个字段的值\",{\"1\":{\"356\":1}}],[\"name和age这三个字段的结果\",{\"1\":{\"355\":1}}],[\"name的值就一定是有序的\",{\"1\":{\"356\":1}}],[\"name=inlined\",{\"1\":{\"1157\":1}}],[\"name=吉永超\",{\"1\":{\"1157\":1}}],[\"name=jjjj\",{\"1\":{\"1146\":1}}],[\"name=jyc\",{\"1\":{\"514\":2}}],[\"name=name\",{\"1\":{\"909\":1}}],[\"name=age\",{\"1\":{\"909\":1}}],[\"name=\",{\"1\":{\"330\":2,\"479\":1,\"917\":5,\"918\":1,\"928\":2,\"930\":1,\"953\":2,\"954\":1,\"985\":1,\"989\":1,\"1003\":4,\"1012\":2,\"1030\":1,\"1032\":1,\"1065\":2,\"1084\":3,\"1091\":5,\"1146\":7,\"1156\":1,\"1157\":1,\"1184\":3,\"1242\":1,\"1526\":2,\"1613\":1}}],[\"name\",{\"1\":{\"306\":10,\"309\":3,\"330\":10,\"335\":1,\"339\":3,\"340\":4,\"341\":1,\"351\":1,\"353\":2,\"354\":4,\"355\":2,\"356\":7,\"370\":4,\"371\":2,\"372\":2,\"421\":2,\"428\":3,\"429\":2,\"431\":1,\"441\":2,\"467\":3,\"468\":2,\"479\":6,\"485\":1,\"510\":4,\"518\":7,\"519\":6,\"520\":2,\"522\":4,\"526\":1,\"536\":1,\"553\":3,\"555\":2,\"557\":1,\"558\":5,\"567\":3,\"569\":5,\"570\":3,\"573\":11,\"582\":1,\"611\":4,\"624\":1,\"909\":5,\"917\":7,\"927\":3,\"928\":7,\"929\":2,\"939\":1,\"952\":5,\"963\":2,\"967\":4,\"975\":1,\"978\":6,\"985\":8,\"989\":9,\"994\":1,\"995\":1,\"996\":1,\"997\":4,\"1005\":2,\"1007\":1,\"1019\":4,\"1022\":1,\"1027\":3,\"1029\":1,\"1030\":1,\"1031\":5,\"1032\":7,\"1055\":4,\"1056\":3,\"1063\":4,\"1064\":3,\"1065\":6,\"1072\":8,\"1082\":1,\"1084\":2,\"1091\":3,\"1121\":4,\"1123\":1,\"1139\":2,\"1146\":2,\"1149\":2,\"1156\":7,\"1157\":3,\"1164\":9,\"1165\":1,\"1167\":4,\"1168\":4,\"1171\":3,\"1184\":12,\"1432\":6,\"1600\":8,\"1603\":5,\"1605\":8,\"1611\":1,\"1613\":19,\"1647\":17,\"1655\":1,\"1658\":2,\"1663\":6}}],[\"na\",{\"1\":{\"375\":1}}],[\"nacos配置动态更新原理\",{\"1\":{\"1313\":1}}],[\"nacos配置中心\",{\"0\":{\"232\":1,\"1312\":1}}],[\"nacos同时支持ap和cp模式\",{\"1\":{\"1311\":1}}],[\"nacos同一个namespace中的不同的group注册的服务可以相互访问吗\",{\"0\":{\"236\":1,\"1316\":1}}],[\"nacos本身支持负载均衡\",{\"1\":{\"1311\":1}}],[\"nacos提供了服务的注册与发现\",{\"1\":{\"1311\":1}}],[\"nacos服务注册的流程是怎么样的\",{\"0\":{\"237\":1,\"1317\":1}}],[\"nacos中命名空间和分组的概念及区别\",{\"0\":{\"235\":1,\"1315\":1}}],[\"nacos的配置动态更新原理\",{\"0\":{\"233\":1,\"1313\":1}}],[\"nacos和eureka的区别\",{\"0\":{\"231\":1,\"1311\":1}}],[\"noop\",{\"1\":{\"1654\":1}}],[\"noid\",{\"1\":{\"1618\":8}}],[\"noeviction\",{\"1\":{\"1300\":1}}],[\"nouniquebeandefinitionexceptiondemo\",{\"1\":{\"946\":2}}],[\"nouniquebeandefinitionexception示例\",{\"1\":{\"946\":2}}],[\"nouniquebeandefinitionexception\",{\"1\":{\"946\":2}}],[\"nosuchbeandefinitionexception\",{\"1\":{\"946\":1,\"964\":1,\"973\":1,\"997\":2,\"1647\":3,\"1648\":1}}],[\"nor\",{\"1\":{\"928\":2}}],[\"normal`\",{\"1\":{\"413\":2}}],[\"normal的时候\",{\"1\":{\"413\":1}}],[\"normal和insert\",{\"1\":{\"413\":1}}],[\"normal\",{\"1\":{\"413\":6,\"1655\":1}}],[\"nodes\",{\"1\":{\"1620\":2}}],[\"node节点设计如下\",{\"1\":{\"1554\":1}}],[\"node是hashmap的一个内部类\",{\"1\":{\"1546\":1}}],[\"node<\",{\"1\":{\"1554\":1}}],[\"node<k\",{\"1\":{\"1546\":4,\"1549\":3,\"1550\":8,\"1554\":14}}],[\"node<e>\",{\"1\":{\"1503\":10}}],[\"nodehandlermap\",{\"1\":{\"645\":1}}],[\"nodehandler\",{\"1\":{\"645\":1}}],[\"nodename\",{\"1\":{\"645\":3}}],[\"nodelist\",{\"1\":{\"645\":1}}],[\"node\",{\"1\":{\"571\":1,\"601\":1,\"645\":10,\"1256\":1,\"1369\":1,\"1491\":1,\"1503\":5,\"1546\":2,\"1550\":1,\"1553\":6,\"1554\":1}}],[\"no来说\",{\"1\":{\"558\":1}}],[\"no访问s1的成本\",{\"1\":{\"555\":1}}],[\"no进行对s1的访问\",{\"1\":{\"555\":1}}],[\"no=常数中的常数值我们是不知道\",{\"1\":{\"555\":1}}],[\"no=21\",{\"1\":{\"306\":1}}],[\"no可以进行ref方式访问\",{\"1\":{\"555\":1}}],[\"no`\",{\"1\":{\"553\":1,\"555\":1}}],[\"no列平均每个值的重复次数就是10354\",{\"1\":{\"553\":1}}],[\"no索引为例\",{\"1\":{\"553\":1}}],[\"no的tracer的输出\",{\"1\":{\"551\":1}}],[\"no的成本就是\",{\"1\":{\"551\":1}}],[\"no的成本\",{\"1\":{\"549\":1,\"551\":1}}],[\"no的成本为72\",{\"1\":{\"544\":1}}],[\"no执行查询的总成本就是\",{\"1\":{\"549\":1}}],[\"no执行查询的成本呢\",{\"1\":{\"555\":1}}],[\"no执行查询的成本就如下所示\",{\"1\":{\"549\":1}}],[\"no执行查询的成本\",{\"1\":{\"549\":1}}],[\"no执行查询时有3个单点区间\",{\"1\":{\"549\":1}}],[\"no时需要访问的范围区间数量以及需要回表的记录数\",{\"1\":{\"549\":1}}],[\"no对应的搜索条件是\",{\"1\":{\"549\":1}}],[\"nondeterministic\",{\"1\":{\"1622\":1}}],[\"nonnull\",{\"1\":{\"1620\":4}}],[\"noninterference\",{\"1\":{\"1608\":2}}],[\"nonvolatile\",{\"1\":{\"1553\":1}}],[\"none\",{\"1\":{\"1262\":1,\"1609\":2,\"1620\":1,\"1647\":1}}],[\"nonorderedpostprocessors\",{\"1\":{\"1166\":3}}],[\"nonorderedpostprocessornames\",{\"1\":{\"1166\":4}}],[\"nonrepeatable\",{\"1\":{\"532\":1}}],[\"non\",{\"1\":{\"433\":1,\"553\":1,\"922\":1,\"963\":1,\"997\":1,\"1009\":1,\"1171\":1,\"1432\":1,\"1480\":1,\"1542\":1,\"1608\":2,\"1615\":2,\"1619\":2,\"1620\":11,\"1621\":5,\"1647\":2,\"1650\":1,\"1655\":2,\"1663\":1}}],[\"nowtime\",{\"1\":{\"1288\":2}}],[\"nowait\",{\"1\":{\"441\":2}}],[\"now\",{\"1\":{\"368\":3,\"393\":2,\"434\":1,\"454\":1,\"478\":1,\"510\":3,\"518\":3,\"996\":1,\"997\":1,\"1166\":1,\"1170\":1,\"1647\":1}}],[\"notfull条件\",{\"1\":{\"1503\":1}}],[\"notfull条件队列转同步队列\",{\"1\":{\"1502\":1,\"1503\":2}}],[\"notfull\",{\"1\":{\"1502\":4,\"1503\":4}}],[\"notnull\",{\"1\":{\"996\":1,\"1065\":1,\"1658\":2}}],[\"notify和notifyall分别何时使用\",{\"1\":{\"1483\":1}}],[\"notify和notifyall有什么区别\",{\"0\":{\"51\":1,\"1380\":1}}],[\"notifyall\",{\"1\":{\"1483\":1,\"1530\":1}}],[\"notify主要两个缺陷\",{\"1\":{\"1477\":1}}],[\"notify会随机唤醒一个阻塞的线程\",{\"1\":{\"1380\":1}}],[\"notifyobservers\",{\"1\":{\"1108\":3}}],[\"notify\",{\"1\":{\"624\":1,\"1483\":1,\"1530\":1}}],[\"notification\",{\"1\":{\"624\":2}}],[\"not以及其它位操作\",{\"1\":{\"578\":1}}],[\"not\",{\"1\":{\"335\":2,\"336\":2,\"338\":1,\"346\":1,\"353\":4,\"361\":8,\"362\":6,\"363\":3,\"366\":1,\"368\":1,\"369\":1,\"378\":1,\"400\":1,\"419\":1,\"424\":1,\"442\":1,\"446\":1,\"454\":2,\"459\":1,\"462\":1,\"468\":1,\"476\":1,\"478\":2,\"489\":1,\"494\":1,\"506\":5,\"510\":5,\"518\":5,\"519\":2,\"520\":2,\"523\":1,\"534\":1,\"535\":1,\"573\":1,\"580\":1,\"630\":1,\"922\":1,\"963\":1,\"964\":1,\"965\":1,\"973\":1,\"996\":2,\"997\":3,\"1022\":1,\"1063\":3,\"1164\":1,\"1166\":1,\"1170\":1,\"1171\":1,\"1238\":1,\"1239\":1,\"1432\":2,\"1594\":7,\"1597\":1,\"1599\":8,\"1615\":4,\"1617\":3,\"1618\":3,\"1619\":6,\"1620\":15,\"1621\":1,\"1622\":3,\"1623\":3,\"1647\":7,\"1648\":3,\"1650\":1,\"1651\":1,\"1655\":1,\"1658\":3,\"1663\":2,\"1994\":1}}],[\"notempty条件\",{\"1\":{\"1503\":1}}],[\"notempty条件队列转同步队列\",{\"1\":{\"1502\":1,\"1503\":2}}],[\"notempty\",{\"1\":{\"1502\":4,\"1503\":4,\"1647\":1}}],[\"note没有用到索引\",{\"1\":{\"555\":1}}],[\"note`\",{\"1\":{\"553\":1,\"555\":1}}],[\"note即使有索引\",{\"1\":{\"547\":1}}],[\"noteshare\",{\"1\":{\"531\":1,\"540\":1,\"1663\":1}}],[\"note\",{\"1\":{\"308\":1,\"312\":1,\"517\":2,\"531\":1,\"540\":1,\"544\":1,\"547\":2,\"553\":2,\"554\":9,\"555\":6,\"635\":1,\"639\":1,\"1663\":1}}],[\"no\",{\"1\":{\"304\":4,\"306\":2,\"330\":1,\"451\":4,\"465\":1,\"478\":1,\"520\":2,\"544\":1,\"547\":4,\"549\":3,\"553\":6,\"554\":2,\"555\":9,\"558\":1,\"592\":1,\"611\":2,\"928\":1,\"952\":4,\"995\":1,\"1055\":2,\"1081\":1,\"1121\":1,\"1167\":2,\"1168\":1,\"1171\":1,\"1480\":1,\"1554\":1,\"1597\":2,\"1600\":2,\"1613\":1,\"1614\":1,\"1617\":1,\"1618\":1,\"1619\":1,\"1620\":4,\"1621\":1,\"1647\":3,\"1648\":3,\"1650\":2}}],[\"nginx如何保证高可用\",{\"0\":{\"261\":1,\"1468\":1}}],[\"nginx\",{\"0\":{\"260\":1,\"1467\":1}}],[\"而需要的类型是user\",{\"1\":{\"1638\":1}}],[\"而无论这个阶段接收的类型\",{\"1\":{\"1623\":1}}],[\"而无需线程b再执行\",{\"1\":{\"1531\":1}}],[\"而无需重复获取锁\",{\"1\":{\"1398\":1}}],[\"而无需再创建idb文件\",{\"1\":{\"412\":1}}],[\"而数组是引用类型的\",{\"1\":{\"1618\":1}}],[\"而数据表是会持续更新的\",{\"1\":{\"347\":1}}],[\"而尽量不要进行其他的操作\",{\"1\":{\"1617\":1}}],[\"而最终的结果类型是map类型\",{\"1\":{\"1617\":1}}],[\"而作为collector的工厂\",{\"1\":{\"1616\":1}}],[\"而作为银行这个类来讲\",{\"1\":{\"1501\":1}}],[\"而终止操作则不会返回stream类型\",{\"1\":{\"1611\":1}}],[\"而流关注的则是对数据的计算\",{\"1\":{\"1611\":1}}],[\"而具体如何让db完成这个行为是没有暴露出来的\",{\"1\":{\"1611\":1}}],[\"而去重也并没有等待到新的值\",{\"1\":{\"1610\":1}}],[\"而foreach是终止操作\",{\"1\":{\"1610\":1}}],[\"而求和则不会\",{\"1\":{\"1610\":1}}],[\"而jdk在很多的接口中都增加了默认方法\",{\"1\":{\"1607\":1}}],[\"而jdk会在集合进行流操作的时候\",{\"1\":{\"1593\":1}}],[\"而接口更多的时候还是表示一种模板或者契约\",{\"1\":{\"1607\":1}}],[\"而接口是对行为的抽象\",{\"1\":{\"1345\":1}}],[\"而println\",{\"1\":{\"1605\":1}}],[\"而put方法中有这样的逻辑\",{\"1\":{\"1557\":1}}],[\"而方法引用则需要满足一些条件才能使用\",{\"1\":{\"1603\":1}}],[\"而事实上java8的新特性可以极大提升我们的开发效率\",{\"1\":{\"1591\":1}}],[\"而事务id从0开始计数\",{\"1\":{\"497\":1}}],[\"而事务b在等待事务a释放id=1的行锁\",{\"1\":{\"444\":1}}],[\"而实际io读写\",{\"1\":{\"1580\":1}}],[\"而用户程序运行在用户空间\",{\"1\":{\"1579\":1}}],[\"而用于同步更新的线程\",{\"1\":{\"453\":1}}],[\"而异步io则无需自己负责进行读写\",{\"1\":{\"1568\":1}}],[\"而另一方面\",{\"1\":{\"1566\":1}}],[\"而另外一部分数据却已经丢失\",{\"1\":{\"1297\":1}}],[\"而另外的128个线程又处于锁等待状态\",{\"1\":{\"476\":1}}],[\"而阻塞io值调用了一次system\",{\"1\":{\"1565\":1}}],[\"而同时\",{\"1\":{\"1565\":1}}],[\"而指针实质上是某个变量或者对象所在内存位置的首地址\",{\"1\":{\"1561\":1}}],[\"而下一次循环的next\",{\"1\":{\"1551\":1}}],[\"而next指向了key\",{\"1\":{\"1551\":1}}],[\"而notifyall会唤醒所有线程\",{\"1\":{\"1380\":1}}],[\"而limit\",{\"1\":{\"1610\":1}}],[\"而linux中fork\",{\"1\":{\"1527\":1}}],[\"而linux下\",{\"1\":{\"1423\":1}}],[\"而length\",{\"1\":{\"1548\":1}}],[\"而hashset就是利用这个特性来保证唯一性的\",{\"1\":{\"1557\":1}}],[\"而hashentry存放的就是我们的键值对\",{\"1\":{\"1553\":1}}],[\"而hashentry也是concurrenthashmap的内部类\",{\"1\":{\"1553\":1}}],[\"而hashmap对象内部地数组无法装在更多地元素时\",{\"1\":{\"1550\":1}}],[\"而hashmap的长度length总是为2n\",{\"1\":{\"1548\":1}}],[\"而https默认是443端口\",{\"1\":{\"1424\":1}}],[\"而https需要申请证书\",{\"1\":{\"1424\":1}}],[\"而消费者线程从任务队列中获取任务并执行\",{\"1\":{\"1535\":1}}],[\"而保护性暂停模式可以帮助我们解决上述的等待问题\",{\"1\":{\"1530\":1}}],[\"而多个线程之间相互协作时\",{\"1\":{\"1530\":1}}],[\"而线程本地存储方案\",{\"1\":{\"1528\":1}}],[\"而线程2也在等待线程1互斥持有的资源\",{\"1\":{\"1389\":1}}],[\"而利用java线程中断机制的interrupt\",{\"1\":{\"1524\":1}}],[\"而过多的线程的也会消耗内存等其他资源\",{\"1\":{\"1510\":1}}],[\"而取元素时只有取之前队列是满的才会唤醒notfull\",{\"1\":{\"1503\":1}}],[\"而负责放任务的线程是无法直接访问到我们银行具体实现转账操作的对象的\",{\"1\":{\"1501\":1}}],[\"而释放锁时\",{\"1\":{\"1483\":1}}],[\"而元空间中的元数据分配是基于本地内存的\",{\"1\":{\"1457\":1}}],[\"而元空间中的类元数据可以进行卸载\",{\"1\":{\"1457\":1}}],[\"而大内存应用上g1更有优化\",{\"1\":{\"1449\":1}}],[\"而证书通常是收费的\",{\"1\":{\"1424\":1}}],[\"而单链表不需要\",{\"1\":{\"1360\":1}}],[\"而抽象类中则不一定\",{\"1\":{\"1345\":1}}],[\"而transfer通过filechannel来进行操作\",{\"1\":{\"1330\":1,\"1331\":1}}],[\"而exchange\",{\"1\":{\"1479\":1}}],[\"而eureka只满足ap模式\",{\"1\":{\"1311\":1}}],[\"而eureka只提供了服务注册与发现\",{\"1\":{\"1311\":1}}],[\"而eureka不支持\",{\"1\":{\"1311\":1}}],[\"而es中不需要预先定义mapping映射\",{\"1\":{\"309\":1}}],[\"而到了微服务是很多个环境\",{\"1\":{\"1304\":1}}],[\"而采用微服务之后\",{\"1\":{\"1304\":2}}],[\"而微服务可以根据业务特点\",{\"1\":{\"1304\":1}}],[\"而读数据的操作\",{\"1\":{\"1269\":1}}],[\"而非对象本身\",{\"1\":{\"1353\":1}}],[\"而非聚簇索引可以有多个\",{\"1\":{\"1266\":1}}],[\"而非物理分页\",{\"1\":{\"1214\":1}}],[\"而bifunction要求接收两个参数\",{\"1\":{\"1598\":1}}],[\"而b+树可以稳定在o\",{\"1\":{\"1265\":1}}],[\"而beanpostprocess直接与beanfactory关联\",{\"1\":{\"1016\":1}}],[\"而infrastructureadvisorautoproxycreator继承了abstractadvisorautoproxycreator\",{\"1\":{\"1655\":1}}],[\"而innodb每个表只有一个文件\",{\"1\":{\"1260\":1}}],[\"而isinterrupted方法则不会\",{\"1\":{\"1386\":1}}],[\"而id的值已经在k索引树上了\",{\"1\":{\"338\":1}}],[\"而生成动态代理是要在对象初始化完成之后才开始的\",{\"1\":{\"1237\":1}}],[\"而角色访问不同的资源\",{\"1\":{\"1199\":1}}],[\"而选择重新发明轮子\",{\"1\":{\"1036\":1}}],[\"而xmlbeandefinitionreader和propertiesbeandefinitionreader都继承了abstractbeandefinitionreader\",{\"1\":{\"1024\":1}}],[\"而我们通过方法引用的方式\",{\"1\":{\"1613\":1}}],[\"而我们又设置了过多的线程\",{\"1\":{\"1510\":1}}],[\"而我们前面提到过\",{\"1\":{\"1005\":1}}],[\"而我们的目的只是计数\",{\"1\":{\"577\":1}}],[\"而dubbo采用rpc通信\",{\"1\":{\"1306\":1}}],[\"而description这个属性\",{\"1\":{\"1003\":1}}],[\"而db\",{\"1\":{\"542\":1}}],[\"而accumulator将流中待处理的元素添加到结果容器之后\",{\"1\":{\"1615\":1}}],[\"而atomic变量可以让这种操作具有原子性\",{\"1\":{\"1385\":1}}],[\"而applicationcontextawareprocessor又是一个非public的类\",{\"1\":{\"1005\":1}}],[\"而applicationcontext则可以\",{\"1\":{\"1005\":1}}],[\"而applicationcontext添加了更多企业级的特性\",{\"1\":{\"921\":1}}],[\"而arraylist是有序的\",{\"1\":{\"975\":1}}],[\"而延迟初始化是在依赖查找和依赖注入的时候才会进行初始化\",{\"1\":{\"932\":1}}],[\"而依赖注入的来源还包括了resolvable\",{\"1\":{\"980\":1}}],[\"而依赖注入则是手动或自动依赖绑定的方式\",{\"1\":{\"915\":1}}],[\"而依赖于存储引擎的一些操作对应的成本常数就存储在了engine\",{\"1\":{\"557\":1}}],[\"而改用epoll\",{\"1\":{\"603\":1}}],[\"而write方法一般来说不会阻塞\",{\"1\":{\"602\":1}}],[\"而worker\",{\"1\":{\"461\":1}}],[\"而字典的值则是一个链表\",{\"1\":{\"599\":1}}],[\"而父进程依然可以接收来自客户端的请求\",{\"1\":{\"588\":1}}],[\"而stream<t>又正好继承了basestream\",{\"1\":{\"1619\":1}}],[\"而submit既能提交runnable类型的任务也能提交callable类型任务\",{\"1\":{\"1408\":1}}],[\"而synchronized是通过jvm来获取的\",{\"1\":{\"1394\":1}}],[\"而sleep方法则不会释放掉锁\",{\"1\":{\"1381\":1}}],[\"而save命令已经废弃\",{\"1\":{\"587\":1}}],[\"而serverbootstrap需要配置两个事件循环组\",{\"1\":{\"1226\":1}}],[\"而server层也有自己的日志\",{\"1\":{\"325\":1}}],[\"而session作用域\",{\"1\":{\"987\":1}}],[\"而session\",{\"1\":{\"441\":1,\"448\":1}}],[\"而value使用默认值填充\",{\"1\":{\"573\":1}}],[\"而对外的数据结构和命令没有影响\",{\"1\":{\"569\":1}}],[\"而对于并行实现将会对输入进行分区\",{\"1\":{\"1615\":1}}],[\"而对于thencomparing方法而言\",{\"1\":{\"1614\":1}}],[\"而对于n>0\",{\"1\":{\"1609\":1}}],[\"而对于delayqueue而言\",{\"1\":{\"1509\":1}}],[\"而对于只读事务\",{\"1\":{\"497\":1}}],[\"而对于临时内存表的排序来说\",{\"1\":{\"420\":1}}],[\"而对于临时表\",{\"1\":{\"412\":1}}],[\"而对于确定要使用查询缓存的语句\",{\"1\":{\"319\":1}}],[\"而它们父节点中记录的每一条目录项记录都对应一个数据页\",{\"1\":{\"549\":1}}],[\"而早于read\",{\"1\":{\"542\":1}}],[\"而有的里面没有任何容量\",{\"1\":{\"1509\":1}}],[\"而有可能是之前的历史版本\",{\"1\":{\"541\":1}}],[\"而有业务逻辑的字段做主键\",{\"1\":{\"335\":1}}],[\"而写锁组会把读和写都阻塞\",{\"1\":{\"535\":1}}],[\"而双路排序只会把主键和需要排序的字段放到sort\",{\"1\":{\"520\":1}}],[\"而一般情况下\",{\"1\":{\"495\":1}}],[\"而一个索引上不同的值的个数\",{\"1\":{\"347\":1}}],[\"而为了解决这个主键冲突\",{\"1\":{\"491\":1}}],[\"而又未经确认的话\",{\"1\":{\"484\":1}}],[\"而能够使用这个方案的前题是\",{\"1\":{\"484\":1}}],[\"而当线程b恢复执行或者执行操作a时\",{\"1\":{\"1531\":1}}],[\"而当前的自增id的值是2\",{\"1\":{\"491\":1}}],[\"而当前读的规则\",{\"1\":{\"446\":1}}],[\"而当session\",{\"1\":{\"481\":1}}],[\"而update语句\",{\"1\":{\"478\":1}}],[\"而备库还没收到日志的状态\",{\"1\":{\"472\":1}}],[\"而按照mariadb的并行复制策略\",{\"1\":{\"464\":1}}],[\"而mybatis则帮我们简化了以上功能\",{\"1\":{\"1982\":1}}],[\"而mysql5\",{\"1\":{\"474\":1}}],[\"而mysql启动的时候\",{\"1\":{\"425\":1}}],[\"而map是中间操作\",{\"1\":{\"1610\":1}}],[\"而map就称之为中间操作\",{\"1\":{\"1607\":1}}],[\"而mariadb的并行复制策略利用这个特性\",{\"1\":{\"464\":1}}],[\"而modcount主要记录hashmap内部结构发生变化的次数\",{\"1\":{\"1546\":1}}],[\"而mq\",{\"1\":{\"1326\":1}}],[\"而mvcc实现了快照读和写冲突不加锁\",{\"1\":{\"541\":1}}],[\"而不再是传统的值\",{\"1\":{\"1598\":1}}],[\"而不能绕过接口直接访问对方的数据\",{\"1\":{\"1308\":1}}],[\"而不需要遍历整个链表\",{\"1\":{\"1548\":1}}],[\"而不需要存储过程\",{\"1\":{\"1509\":1}}],[\"而不需要去关心银行这个类如何实现具体的转账业务\",{\"1\":{\"1501\":1}}],[\"而不需要自己去考虑更多的线程安全问题\",{\"1\":{\"1501\":1}}],[\"而不需要将用户名和密码提供给第三方应用分享他们数据的所有内容\",{\"1\":{\"1202\":1}}],[\"而不需要在它上面增加一些额外的操作\",{\"1\":{\"985\":1}}],[\"而不会操作里面的值\",{\"1\":{\"1617\":1}}],[\"而不会反过来同步问题\",{\"1\":{\"1269\":1}}],[\"而不会对bean进行销毁\",{\"1\":{\"987\":1}}],[\"而不会储存输入元素本身\",{\"1\":{\"577\":1}}],[\"而不给truncate\",{\"1\":{\"487\":1}}],[\"而不设置备只读也是不行的\",{\"1\":{\"459\":1}}],[\"而不是对每个元素一次检测\",{\"1\":{\"1620\":1}}],[\"而不是在spliterator创建的时候绑定的\",{\"1\":{\"1620\":1}}],[\"而不是在配置文件中配置的信息\",{\"1\":{\"978\":1}}],[\"而不是保持独立\",{\"1\":{\"1615\":1}}],[\"而不是通过替换结果进行合并的\",{\"1\":{\"1608\":1}}],[\"而不是一个普通的int\",{\"1\":{\"1610\":1}}],[\"而不是一个注解类型\",{\"1\":{\"1594\":1}}],[\"而不是一个哈希表\",{\"1\":{\"408\":1}}],[\"而不是kafka这样的分布式队列\",{\"1\":{\"1519\":1}}],[\"而不是堆分配\",{\"1\":{\"1488\":1}}],[\"而不是用户态的线程\",{\"1\":{\"1477\":1}}],[\"而不是广播的\",{\"1\":{\"1474\":1}}],[\"而不是锁具体的记录\",{\"1\":{\"1263\":1}}],[\"而不是原对象\",{\"1\":{\"1237\":1}}],[\"而不是直接去查找\",{\"1\":{\"1181\":1}}],[\"而不是页这个词\",{\"1\":{\"557\":1}}],[\"而不是使用字符串\",{\"1\":{\"529\":1}}],[\"而不是使用mysql的嵌套循环关联\",{\"1\":{\"394\":1}}],[\"而不是真正地去数据库查询\",{\"1\":{\"471\":1}}],[\"而不是按照表内的索引顺序进行读取\",{\"1\":{\"330\":1}}],[\"而不是两次\",{\"0\":{\"90\":1,\"1420\":1}}],[\"而使用lambda表达式就可以实现传递行为这种高阶函数\",{\"1\":{\"1593\":1}}],[\"而使用线程安全的concurrenthashmap\",{\"1\":{\"1551\":1}}],[\"而使用哪种方式取决于session变量gtid\",{\"1\":{\"468\":1}}],[\"而使用mixed或者statement格式的binlog时\",{\"1\":{\"459\":1}}],[\"而使用force\",{\"1\":{\"348\":1}}],[\"而没有compose\",{\"1\":{\"1598\":1}}],[\"而没有写操作\",{\"1\":{\"1526\":1}}],[\"而没有写\",{\"1\":{\"1526\":1}}],[\"而没有散布到其他线程当中\",{\"1\":{\"1393\":1}}],[\"而没有先做判断直接切换的话\",{\"1\":{\"458\":1}}],[\"而没有调用fsync\",{\"1\":{\"451\":1}}],[\"而从库\",{\"1\":{\"457\":1}}],[\"而从5\",{\"1\":{\"412\":1}}],[\"而把备库集中在一台机器上\",{\"1\":{\"457\":1}}],[\"而节点a是b的备库\",{\"1\":{\"453\":1}}],[\"而节点b是a的备库\",{\"1\":{\"453\":1}}],[\"而referencepipeline又实现了stream接口\",{\"1\":{\"1623\":1}}],[\"而referencepipeline的构造方法又调用了它的父类abstractpipeline的构造方法\",{\"1\":{\"1621\":1}}],[\"而referencepipeline则是存在previousstage的\",{\"1\":{\"1621\":1}}],[\"而reentrantlock对于已经在等待的线程是先来的线程先获得锁\",{\"1\":{\"1495\":1}}],[\"而reentrantlock需要开发者在finally块中显示释放锁\",{\"1\":{\"1495\":1}}],[\"而reentrantlock\",{\"1\":{\"1495\":1}}],[\"而reducing方法本身又是通过collectorimpl来实现的\",{\"1\":{\"1618\":1}}],[\"而reduce描述的一种聚合\",{\"1\":{\"1607\":1}}],[\"而redis的瓶颈在于内存和网络带宽\",{\"1\":{\"1292\":1}}],[\"而redis很好的解决了这个问题\",{\"1\":{\"1219\":1}}],[\"而redo\",{\"1\":{\"451\":1}}],[\"而rows字段显式需要扫描的行数是50198\",{\"1\":{\"347\":1}}],[\"而要了解组提交首先要了解日志逻辑序列号\",{\"1\":{\"451\":1}}],[\"而要写入2017\",{\"1\":{\"424\":1}}],[\"而根据binlog的执行结果是\",{\"1\":{\"447\":1}}],[\"而会等到整个事务提交后再释放\",{\"1\":{\"441\":1}}],[\"而执行期间另一个线程对这个表结构在做变更\",{\"1\":{\"441\":1}}],[\"而将整个库设置为readonly之后\",{\"1\":{\"438\":1}}],[\"而锁就是用来实现这些访问规则的重要数据结构\",{\"1\":{\"436\":1}}],[\"而\",{\"1\":{\"433\":1,\"476\":1,\"912\":1,\"1648\":1}}],[\"而第一个lamda表达式所打印的就是当前类lambdatest的地址\",{\"1\":{\"1592\":1}}],[\"而第二阶段则是线程t2响应终止指令\",{\"1\":{\"1524\":1}}],[\"而第二条update语句的事务id就是0了\",{\"1\":{\"497\":1}}],[\"而第二个语句创建的index2索引里面\",{\"1\":{\"350\":1}}],[\"而第三步的select也可以用索引快速定位\",{\"1\":{\"422\":1}}],[\"而优化器的作用就是决定选择使用哪一个方案\",{\"1\":{\"514\":1}}],[\"而优化器的作用就是决定选择使用哪一种方案\",{\"1\":{\"321\":1}}],[\"而优先队列算法\",{\"1\":{\"421\":1}}],[\"而临时表由于会自动回收\",{\"1\":{\"410\":1}}],[\"而临时表\",{\"1\":{\"409\":1}}],[\"而考虑到扫描行数\",{\"1\":{\"403\":1}}],[\"而被驱动表是走树搜索\",{\"1\":{\"401\":1}}],[\"而characteristics执行了两次\",{\"1\":{\"1617\":1}}],[\"而change\",{\"1\":{\"344\":1,\"345\":1}}],[\"而cyclicbarrier的计数器可以使用reset\",{\"1\":{\"1496\":1}}],[\"而collectingandthen方法的目的就在于转换最终的结果类型\",{\"1\":{\"1618\":1}}],[\"而collection接口又继承了iterable这个类\",{\"1\":{\"1593\":1}}],[\"而collectors本身实际上是一个工厂\",{\"1\":{\"1615\":1}}],[\"而concurrenthashmap使用分段锁来保证在多线程下的性能\",{\"1\":{\"1401\":1}}],[\"而countdownlatch则是通过aqs的\",{\"1\":{\"1496\":1}}],[\"而count\",{\"1\":{\"399\":1}}],[\"而catch语句块没有throw\",{\"1\":{\"1239\":1}}],[\"而刚刚加1的这个计数操作却丢失了\",{\"1\":{\"397\":1}}],[\"而普通索引树的叶子节点是主键值\",{\"1\":{\"396\":1}}],[\"而拆分后\",{\"1\":{\"394\":1}}],[\"而只是一个中间操作\",{\"1\":{\"1610\":1}}],[\"而只是删掉了其中某一个节点的数据的话\",{\"1\":{\"488\":1}}],[\"而只会告诉我们生成结果时一共扫描了多少行数据\",{\"1\":{\"390\":1}}],[\"而只能根据统计信息来估算记录数\",{\"1\":{\"347\":1}}],[\"而输入的参数却是整型\",{\"1\":{\"367\":1}}],[\"而倒序存储方式毕竟还是用的前缀索引的方式\",{\"1\":{\"352\":1}}],[\"而哈希字段的方式需要额外调用一次crc32\",{\"1\":{\"352\":1}}],[\"而哈希字段方法需要增加一个字段\",{\"1\":{\"352\":1}}],[\"而在sqlsessiontemplate类中就存在一个getmapper方法\",{\"1\":{\"1653\":1}}],[\"而在我们的程序中\",{\"1\":{\"1617\":1}}],[\"而在别的地方\",{\"1\":{\"1616\":1}}],[\"而在其他语言中\",{\"1\":{\"1593\":1}}],[\"而在其它情况下change\",{\"1\":{\"344\":1}}],[\"而在用户进程这边\",{\"1\":{\"1563\":1}}],[\"而在以往\",{\"1\":{\"1518\":1}}],[\"而在applicationcontext中\",{\"1\":{\"1012\":1}}],[\"而在rr隔离级别下\",{\"1\":{\"542\":1}}],[\"而在显示值里面加上248\",{\"1\":{\"497\":1}}],[\"而在数据层解决读性能问题\",{\"1\":{\"466\":1}}],[\"而在数据库中做关联查询\",{\"1\":{\"394\":1}}],[\"而在备库执行这条sql语句的时候\",{\"1\":{\"454\":1}}],[\"而在innodb引擎中会返回4001\",{\"1\":{\"354\":1}}],[\"而在mysql\",{\"1\":{\"340\":1}}],[\"而这两个方法执行的前提是根据方法参数类型能找到对应的bean\",{\"1\":{\"1653\":1}}],[\"而这些文件描述符\",{\"1\":{\"1565\":1}}],[\"而这些行为的抽象就是基于abstractqueuedsynchronizer实现的\",{\"1\":{\"1490\":1}}],[\"而这明显不合\",{\"1\":{\"476\":1}}],[\"而这里transaction\",{\"1\":{\"468\":1}}],[\"而这个唯一的结果容器就是最终的结果容器\",{\"1\":{\"1617\":1}}],[\"而这个无参构造刚好满足不接受参数\",{\"1\":{\"1600\":1}}],[\"而这个方法需要显示的调用才会执行\",{\"1\":{\"1009\":1}}],[\"而这个很大的数\",{\"1\":{\"497\":1}}],[\"而这个位置就是我们所说的同步位点\",{\"1\":{\"467\":1}}],[\"而这个一致性\",{\"1\":{\"447\":1}}],[\"而这个时候\",{\"1\":{\"442\":1}}],[\"而这个更新往往是在系统比较空闲的时候做\",{\"1\":{\"324\":1}}],[\"而这必须要将数据页读入内存才能判断\",{\"1\":{\"343\":1}}],[\"而如果没有设置\",{\"1\":{\"1617\":1}}],[\"而如果传入的是父类型的比较器\",{\"1\":{\"1614\":1}}],[\"而如果平均工作时间长\",{\"1\":{\"1510\":1}}],[\"而如果我们设置更多的线程数\",{\"1\":{\"1510\":1}}],[\"而如果使用for循环进行遍历\",{\"1\":{\"1353\":1}}],[\"而如果使用appliactioncontext来进行操作\",{\"1\":{\"1005\":1}}],[\"而如果使用index2\",{\"1\":{\"351\":1}}],[\"而如果业务开发人员有ddl需求话\",{\"1\":{\"487\":1}}],[\"而如果是update\",{\"1\":{\"484\":1}}],[\"而如果加上\",{\"1\":{\"482\":1}}],[\"而如果db1这个库里表很少的话\",{\"1\":{\"482\":1}}],[\"而如果这时候刚好这两个事务更新的是同一行\",{\"1\":{\"460\":1}}],[\"而如果这个数据页还没有在内存中的话\",{\"1\":{\"343\":1}}],[\"而如果执行的语句去掉limit\",{\"1\":{\"454\":1}}],[\"而如果计算month\",{\"1\":{\"366\":1}}],[\"而如果选择扫描10万行\",{\"1\":{\"347\":1}}],[\"而如果用整型做主键\",{\"1\":{\"335\":1}}],[\"而且课程最后还会手把手教大家将项目部署在云服务器\",{\"1\":{\"1987\":1}}],[\"而且性能也可以得到保证\",{\"1\":{\"1574\":1}}],[\"而且map中还丢失了元素\",{\"1\":{\"1551\":1}}],[\"而且mysql查询优化器计算索引合并成本的算法也比较麻烦\",{\"1\":{\"550\":1}}],[\"而且一旦指定\",{\"1\":{\"1538\":1}}],[\"而且一个实例上db数也不会很多\",{\"1\":{\"463\":1}}],[\"而且能够限制线程的最大数量\",{\"1\":{\"1534\":1}}],[\"而且路由表对数据的一致性要求并不高\",{\"1\":{\"1527\":1}}],[\"而且存在死锁的隐患\",{\"1\":{\"1519\":1}}],[\"而且最好是非阻塞任务\",{\"1\":{\"1510\":1}}],[\"而且总是由同一线程多次获得\",{\"1\":{\"1485\":1}}],[\"而且每个段的执行结果会作为下一个段的输入\",{\"1\":{\"1621\":1}}],[\"而且每个条件变量都对应有一个等待队列\",{\"1\":{\"1483\":1}}],[\"而且每次等待时长也不小的时候\",{\"1\":{\"538\":1}}],[\"而且g1中维护记忆集的成本较高\",{\"1\":{\"1449\":1}}],[\"而且这种方式是支持多层次的\",{\"1\":{\"1136\":1}}],[\"而且此种方案会占用空间\",{\"1\":{\"630\":1}}],[\"而且是多种实现\",{\"1\":{\"569\":1}}],[\"而且key已经过期\",{\"1\":{\"569\":1}}],[\"而且不符合最左前缀原则\",{\"1\":{\"547\":1}}],[\"而且用于计算的数据\",{\"1\":{\"528\":1}}],[\"而且需要确保binlog在被从本地删除之前已经做了备份\",{\"1\":{\"485\":1}}],[\"而且容易出错\",{\"1\":{\"468\":1}}],[\"而且瓶颈在io上\",{\"1\":{\"451\":1}}],[\"而且也看到了\",{\"1\":{\"446\":1}}],[\"而且客户端有重试机制\",{\"1\":{\"441\":1}}],[\"而且并不会自动提交\",{\"1\":{\"435\":1}}],[\"而且计算过程还用上了临时表主键id的唯一性约束\",{\"1\":{\"414\":1}}],[\"而且还会学习整合ssm框架\",{\"1\":{\"1982\":1}}],[\"而且还支持更丰富的配置属性源\",{\"1\":{\"1144\":1}}],[\"而且还有很多额外的功能\",{\"1\":{\"637\":1}}],[\"而且还要保证索引不失效\",{\"1\":{\"375\":1}}],[\"而且还是顺序写的\",{\"1\":{\"345\":1}}],[\"而且由于\",{\"1\":{\"356\":1}}],[\"而且其实都不准确\",{\"1\":{\"347\":1}}],[\"而且\",{\"1\":{\"343\":1,\"404\":1,\"459\":1,\"469\":1,\"476\":1,\"478\":1,\"497\":1}}],[\"而且通过业务代码保证不会写入两个重复的身份证号\",{\"1\":{\"341\":1}}],[\"而且年龄是10岁所有男孩\",{\"1\":{\"340\":1}}],[\"而再建立一个\",{\"1\":{\"338\":1}}],[\"而哪些场景下不应该\",{\"1\":{\"335\":1}}],[\"而更糟的情况是\",{\"1\":{\"335\":1}}],[\"而底层的实现也可能不同\",{\"1\":{\"334\":1}}],[\"而结束于另一点\",{\"1\":{\"330\":1}}],[\"而两阶段提交就是让这两个状态保持逻辑上的一致\",{\"1\":{\"327\":1}}],[\"而存储引擎层负责数据的存储和提取\",{\"1\":{\"317\":1}}],[\"而是刷个10来道题目之后\",{\"1\":{\"1972\":1}}],[\"而是向spring容器中添加了一个advisor\",{\"1\":{\"1649\":1}}],[\"而是拿出一个元素执行所有的中间操作\",{\"1\":{\"1621\":1}}],[\"而是通过声明式的方式来描述他们元以及操作\",{\"1\":{\"1619\":1}}],[\"而是通过一个selector处理多个客户端连接\",{\"1\":{\"1574\":1}}],[\"而是new了一个int类型的数组\",{\"1\":{\"1618\":1}}],[\"而是定义在collectors当中\",{\"1\":{\"1616\":1}}],[\"而是这样的\",{\"1\":{\"1610\":1}}],[\"而是objects\",{\"1\":{\"1599\":1}}],[\"而是枚举或者类\",{\"1\":{\"1594\":1}}],[\"而是省掉了cpu拷贝环节\",{\"1\":{\"1576\":1}}],[\"而是在不停的运行\",{\"1\":{\"1610\":1}}],[\"而是在于能处理更多的连接\",{\"1\":{\"1565\":1}}],[\"而是在程序运行期间才确定\",{\"1\":{\"1340\":1}}],[\"而是马上就得到了一个结果\",{\"1\":{\"1564\":1}}],[\"而是立刻返回一个error\",{\"1\":{\"1564\":1}}],[\"而是让父子进程共享同一个地址空间\",{\"1\":{\"1527\":1}}],[\"而是创建了一个新字符串\",{\"1\":{\"1527\":1}}],[\"而是阻塞等待\",{\"1\":{\"1520\":1}}],[\"而是存储在cpu寄存器中\",{\"1\":{\"1488\":1}}],[\"而是直接返回\",{\"1\":{\"1574\":1}}],[\"而是直接移动takeindex的指针\",{\"1\":{\"1502\":1}}],[\"而是直接通过cas操作将其mark\",{\"1\":{\"1485\":1}}],[\"而是直接使用了排序算法\",{\"1\":{\"418\":1}}],[\"而是只将用户关心的fd的事件存放到内核的一个事件表当中\",{\"1\":{\"1423\":1}}],[\"而是数据存放的地址\",{\"1\":{\"1266\":1}}],[\"而是数据量的问题或者说时使用方式的问题了\",{\"1\":{\"426\":1}}],[\"而是会调用最后指定的方式\",{\"1\":{\"1617\":1}}],[\"而是会现在缓存的字段singletonobjects中进行获取\",{\"1\":{\"1182\":1}}],[\"而是会查询出全部的结果集\",{\"1\":{\"383\":1}}],[\"而是采用了cas机制\",{\"1\":{\"1554\":1}}],[\"而是采用了优先队列排序算法\",{\"1\":{\"421\":1}}],[\"而是采用xml的方式进行配置\",{\"1\":{\"1084\":1}}],[\"而是能读多少读多少\",{\"1\":{\"602\":1}}],[\"而是将行为作为参数进行传递\",{\"1\":{\"1595\":1}}],[\"而是将这些常用的公共api抽取出来封装成为一个工具类\",{\"1\":{\"584\":1}}],[\"而是将redo\",{\"1\":{\"326\":1}}],[\"而是删除的flag变了\",{\"1\":{\"542\":1}}],[\"而是每次申请完就马上释放\",{\"1\":{\"492\":1}}],[\"而是多个\",{\"1\":{\"484\":1}}],[\"而是客户端慢\",{\"1\":{\"482\":1}}],[\"而是给进程发一个信号\",{\"1\":{\"481\":1}}],[\"而是告诉线程\",{\"1\":{\"481\":1}}],[\"而是找位点的这个工作\",{\"1\":{\"468\":1}}],[\"而是\",{\"1\":{\"462\":1}}],[\"而是替换成了两个event\",{\"1\":{\"454\":1}}],[\"而是要等到事务结束时才释放\",{\"1\":{\"443\":1}}],[\"而是要使用\",{\"1\":{\"334\":1}}],[\"而是p\",{\"1\":{\"424\":1}}],[\"而是使用t类型以及t以上的类型\",{\"1\":{\"1618\":1}}],[\"而是使用结合中已有的成员作为中心点\",{\"1\":{\"576\":1}}],[\"而是使用索引统计数据\",{\"1\":{\"553\":1}}],[\"而是使用了另一个叫做\",{\"1\":{\"402\":1}}],[\"而是使用二叉查找树可以吗\",{\"0\":{\"33\":1,\"1361\":1}}],[\"而是email\",{\"1\":{\"350\":1}}],[\"而是不适用于唯一索引\",{\"1\":{\"344\":1}}],[\"而是以页为单位\",{\"1\":{\"342\":1}}],[\"而是实现真正的数据更新\",{\"1\":{\"306\":1}}],[\"而是选择扫描行数是100000的执行计划\",{\"1\":{\"347\":1}}],[\"而是选择先用链表\",{\"0\":{\"32\":1,\"1360\":1}}],[\"而是选用数组\",{\"0\":{\"30\":1,\"1358\":1}}],[\"tm\",{\"1\":{\"1655\":4}}],[\"tmeplate中的datasource是同一个\",{\"1\":{\"1655\":1}}],[\"tmpdir命令\",{\"1\":{\"412\":1}}],[\"tmp\",{\"1\":{\"354\":4,\"355\":1,\"416\":1,\"421\":5,\"431\":4,\"509\":1,\"519\":1,\"520\":2,\"624\":1}}],[\"tf\",{\"1\":{\"1647\":4}}],[\"tutorial\",{\"1\":{\"1627\":1,\"1969\":1,\"1975\":1}}],[\"turned\",{\"1\":{\"1647\":1}}],[\"turn\",{\"1\":{\"1620\":1,\"1623\":1}}],[\"tuser\",{\"1\":{\"340\":1}}],[\"t表示由当前的spliterator所返回的元素的类型\",{\"1\":{\"1620\":1}}],[\"t表示流中元素的类型\",{\"1\":{\"1618\":2}}],[\"t表并插入数据的过程中\",{\"1\":{\"407\":1}}],[\"t类型表示流中元素的类型\",{\"1\":{\"1618\":1}}],[\"t类型表示进行汇聚操作的输入元素的类型\",{\"1\":{\"1615\":1}}],[\"t实际上表示的就是流中的每个元素的类型\",{\"1\":{\"1613\":1}}],[\"two\",{\"1\":{\"1598\":2,\"1599\":4,\"1601\":7,\"1608\":2,\"1614\":1,\"1615\":4,\"1619\":1,\"1620\":3,\"1623\":1}}],[\"tlab\",{\"1\":{\"1668\":1}}],[\"tl\",{\"1\":{\"1528\":4}}],[\"tl=threadlocal\",{\"1\":{\"1528\":1}}],[\"t0\",{\"1\":{\"1432\":2,\"1663\":2}}],[\"t3操作\",{\"1\":{\"1498\":1}}],[\"t3\",{\"1\":{\"1404\":2}}],[\"t3这一项去掉\",{\"1\":{\"461\":1}}],[\"t>>\",{\"1\":{\"1617\":2,\"1618\":3}}],[\"t>由于没有明确的上下文\",{\"1\":{\"1614\":1}}],[\"t>\",{\"1\":{\"1086\":1,\"1506\":2,\"1593\":1,\"1594\":5,\"1595\":1,\"1597\":1,\"1598\":4,\"1599\":4,\"1601\":4,\"1608\":2,\"1609\":1,\"1614\":2,\"1615\":1,\"1616\":4,\"1617\":6,\"1618\":11,\"1620\":5,\"1621\":1,\"1622\":2,\"1623\":1}}],[\"tdd\",{\"1\":{\"891\":1,\"900\":1}}],[\"ttl\",{\"1\":{\"569\":4,\"1300\":1}}],[\"txinfo\",{\"1\":{\"1655\":7}}],[\"txsupport\",{\"1\":{\"1655\":2}}],[\"txselect\",{\"1\":{\"1328\":1}}],[\"txattr\",{\"1\":{\"1655\":12}}],[\"txt\",{\"1\":{\"1587\":2,\"1588\":2}}],[\"txrollback\",{\"1\":{\"1328\":1}}],[\"txcommit\",{\"1\":{\"1328\":1}}],[\"tx\",{\"1\":{\"532\":2,\"1028\":5}}],[\"typically\",{\"1\":{\"1620\":1}}],[\"typical\",{\"1\":{\"1620\":1}}],[\"typora\",{\"1\":{\"472\":1,\"479\":1}}],[\"typecheckonly\",{\"1\":{\"1647\":3}}],[\"typeconvert\",{\"1\":{\"1093\":1}}],[\"typeconverter本身使用了委托的设计模式\",{\"1\":{\"1640\":1}}],[\"typeconverter整合了propertyeditor和conversionservice的功能\",{\"1\":{\"1640\":1}}],[\"typeconverterdelegate\",{\"1\":{\"1093\":3,\"1152\":1}}],[\"typeconvertersupport\",{\"1\":{\"1093\":2}}],[\"typeconverter\",{\"0\":{\"1640\":1},\"1\":{\"963\":18,\"1070\":1,\"1093\":2,\"1152\":1,\"1640\":3,\"1648\":12}}],[\"typefilter\",{\"1\":{\"1647\":2}}],[\"typeexcludefilter\",{\"1\":{\"1135\":1}}],[\"type类型的派生类或接口\",{\"0\":{\"1106\":1}}],[\"type>\",{\"1\":{\"1100\":1}}],[\"types\",{\"1\":{\"1099\":1}}],[\"typesafetydependencylookupdemp\",{\"1\":{\"944\":2}}],[\"typevariablemap\",{\"1\":{\"1100\":2}}],[\"typevariables\",{\"1\":{\"1099\":2}}],[\"typevariable\",{\"1\":{\"1099\":2,\"1100\":2}}],[\"type前置判断\",{\"1\":{\"1088\":1,\"1090\":1}}],[\"type和target\",{\"1\":{\"1088\":2,\"1090\":1}}],[\"type和id\",{\"1\":{\"307\":1}}],[\"typedescriptor是如何处理泛型\",{\"0\":{\"1097\":1}}],[\"typedescriptor\",{\"1\":{\"963\":3,\"1086\":3,\"1089\":3,\"1091\":4,\"1639\":4}}],[\"typeresolver\",{\"1\":{\"899\":1}}],[\"typealiasregistry\",{\"1\":{\"645\":1}}],[\"type=\",{\"1\":{\"1201\":1,\"1242\":1}}],[\"type=0\",{\"1\":{\"526\":1}}],[\"type=note\",{\"1\":{\"308\":1,\"312\":1,\"517\":2,\"635\":1,\"639\":1}}],[\"type列\",{\"0\":{\"509\":1}}],[\"type来控制并行复制策略\",{\"1\":{\"465\":1}}],[\"type设置成demand\",{\"1\":{\"319\":1}}],[\"typename\",{\"1\":{\"307\":1}}],[\"type\",{\"1\":{\"306\":1,\"307\":10,\"309\":2,\"329\":3,\"330\":15,\"361\":2,\"390\":4,\"519\":1,\"542\":1,\"553\":2,\"555\":2,\"557\":1,\"569\":2,\"577\":1,\"578\":1,\"892\":1,\"899\":1,\"917\":1,\"952\":5,\"961\":4,\"963\":22,\"964\":2,\"965\":2,\"973\":1,\"1088\":1,\"1099\":4,\"1100\":1,\"1101\":2,\"1103\":1,\"1107\":1,\"1134\":8,\"1135\":3,\"1136\":1,\"1137\":1,\"1138\":3,\"1164\":2,\"1171\":1,\"1594\":17,\"1597\":1,\"1598\":15,\"1599\":4,\"1600\":1,\"1601\":9,\"1608\":1,\"1613\":2,\"1615\":5,\"1618\":6,\"1620\":9,\"1621\":2,\"1623\":7,\"1645\":4,\"1647\":4,\"1648\":11,\"1655\":1}}],[\"t6时刻\",{\"1\":{\"447\":1}}],[\"t4时刻显示的trx\",{\"1\":{\"497\":1}}],[\"t4时刻\",{\"1\":{\"447\":1,\"497\":1}}],[\"tbl\",{\"1\":{\"441\":2,\"485\":1}}],[\"t不存在\",{\"1\":{\"413\":1}}],[\"t这两个语句的binlog日志\",{\"1\":{\"413\":1}}],[\"t做join操作\",{\"1\":{\"407\":1}}],[\"t的字段b加上索引\",{\"1\":{\"407\":1}}],[\"t中\",{\"1\":{\"407\":1}}],[\"treat\",{\"1\":{\"1594\":3}}],[\"treebin<k\",{\"1\":{\"1554\":1}}],[\"treebin\",{\"1\":{\"1554\":1}}],[\"treenode<k\",{\"1\":{\"1549\":1,\"1550\":1}}],[\"treenode\",{\"1\":{\"1549\":1,\"1550\":1}}],[\"treemap实现sortedmap接口\",{\"1\":{\"1544\":1}}],[\"treemap\",{\"1\":{\"1540\":1,\"1544\":1,\"1618\":1}}],[\"treeset<widget>>\",{\"1\":{\"1615\":1}}],[\"treeset<string>\",{\"1\":{\"1609\":1}}],[\"treeset\",{\"1\":{\"1539\":1,\"1609\":1,\"1615\":3,\"1616\":2}}],[\"treeifybin\",{\"1\":{\"1549\":1,\"1554\":1}}],[\"treeify\",{\"1\":{\"1475\":2,\"1549\":1,\"1554\":1}}],[\"tree\",{\"0\":{\"502\":1},\"1\":{\"501\":1,\"1620\":3}}],[\"triggered\",{\"1\":{\"1647\":1}}],[\"triggering\",{\"1\":{\"1623\":1}}],[\"trip\",{\"1\":{\"1620\":2,\"1623\":1}}],[\"tripwire被设置成true的话\",{\"1\":{\"1620\":1}}],[\"tripwire\",{\"1\":{\"1620\":5,\"1623\":2}}],[\"triple协议\",{\"0\":{\"638\":1}}],[\"triple协议是基于http2\",{\"1\":{\"637\":1}}],[\"trim\",{\"1\":{\"1061\":1}}],[\"trivial\",{\"1\":{\"519\":1}}],[\"trysplit\",{\"1\":{\"1620\":12}}],[\"tryadvance\",{\"1\":{\"1620\":21}}],[\"trylock\",{\"1\":{\"1288\":1,\"1553\":1}}],[\"try\",{\"1\":{\"582\":1,\"922\":1,\"944\":1,\"946\":1,\"963\":2,\"964\":2,\"965\":1,\"973\":1,\"989\":1,\"996\":1,\"997\":1,\"1007\":1,\"1008\":1,\"1013\":1,\"1022\":2,\"1040\":1,\"1041\":1,\"1043\":2,\"1082\":1,\"1084\":1,\"1124\":1,\"1163\":1,\"1175\":2,\"1226\":2,\"1387\":1,\"1404\":11,\"1432\":1,\"1502\":2,\"1503\":4,\"1517\":1,\"1528\":1,\"1533\":2,\"1534\":2,\"1535\":2,\"1553\":1,\"1554\":1,\"1573\":4,\"1574\":6,\"1575\":9,\"1587\":1,\"1588\":1,\"1619\":7,\"1647\":16,\"1648\":4,\"1651\":2,\"1655\":3,\"1663\":1}}],[\"truncate\",{\"1\":{\"479\":1,\"1271\":1}}],[\"trueentry\",{\"1\":{\"1618\":2}}],[\"true=\",{\"1\":{\"1613\":1}}],[\"true\",{\"1\":{\"309\":2,\"438\":1,\"519\":6,\"542\":2,\"645\":2,\"917\":1,\"932\":2,\"961\":3,\"967\":1,\"1002\":1,\"1023\":2,\"1027\":2,\"1072\":5,\"1139\":2,\"1162\":2,\"1166\":1,\"1170\":1,\"1174\":1,\"1175\":2,\"1184\":2,\"1288\":2,\"1351\":1,\"1387\":2,\"1404\":6,\"1476\":1,\"1480\":1,\"1517\":1,\"1531\":1,\"1533\":1,\"1534\":1,\"1549\":1,\"1554\":1,\"1573\":4,\"1574\":2,\"1591\":2,\"1599\":4,\"1607\":1,\"1609\":1,\"1617\":2,\"1618\":1,\"1620\":4,\"1621\":1,\"1622\":3,\"1623\":1,\"1647\":1,\"1648\":3,\"1650\":1,\"1652\":1}}],[\"trx还是在innodb\",{\"1\":{\"497\":1}}],[\"trx表里查看到\",{\"1\":{\"538\":1}}],[\"trx表里查出来的两个字段\",{\"1\":{\"497\":1}}],[\"trx表中看到事务的trx\",{\"1\":{\"497\":1}}],[\"trx表中\",{\"1\":{\"441\":1}}],[\"trx5和trx6是在执行的\",{\"1\":{\"464\":1}}],[\"trx4\",{\"1\":{\"464\":1}}],[\"trx3在主库执行完成\",{\"1\":{\"472\":1}}],[\"trx3\",{\"1\":{\"451\":1}}],[\"trx2和trx3\",{\"1\":{\"472\":1}}],[\"trx2和trx3提交的时候\",{\"1\":{\"464\":1}}],[\"trx2\",{\"1\":{\"451\":1}}],[\"trx1事务更新完成后\",{\"1\":{\"473\":1,\"474\":2}}],[\"trx1和trx2已经传到从库\",{\"1\":{\"472\":1}}],[\"trx1和trx3执行完成后\",{\"1\":{\"464\":1}}],[\"trx1去写盘的时候\",{\"1\":{\"451\":1}}],[\"trx1是第一个到达得\",{\"1\":{\"451\":1}}],[\"trx1\",{\"1\":{\"451\":1}}],[\"trx\",{\"0\":{\"497\":1},\"1\":{\"434\":2,\"451\":6,\"497\":9,\"499\":1,\"538\":3,\"542\":13}}],[\"trx这个表中\",{\"1\":{\"434\":1}}],[\"traversed\",{\"1\":{\"1620\":4,\"1621\":1}}],[\"traverse\",{\"1\":{\"1620\":3}}],[\"traversing\",{\"1\":{\"1620\":2}}],[\"traversals\",{\"1\":{\"1619\":1,\"1623\":1}}],[\"traversal\",{\"1\":{\"1619\":1,\"1620\":18,\"1623\":3}}],[\"tranferto实现文件传输\",{\"1\":{\"1231\":1}}],[\"transitions\",{\"1\":{\"1623\":2}}],[\"transient表示该属性不会被序列化\",{\"1\":{\"1542\":1}}],[\"transient\",{\"1\":{\"963\":2,\"985\":1,\"1368\":1,\"1475\":1,\"1480\":2,\"1503\":2,\"1542\":1,\"1546\":1}}],[\"transferto并不保证一定能使用零拷贝\",{\"1\":{\"1588\":1}}],[\"transferto\",{\"1\":{\"1588\":1}}],[\"transferto方法\",{\"1\":{\"1588\":1}}],[\"transferindex\",{\"1\":{\"1554\":1}}],[\"transfer\",{\"1\":{\"1419\":1,\"1550\":1,\"1554\":2}}],[\"transfile\",{\"1\":{\"1331\":1}}],[\"transfile没有文件大小限制\",{\"1\":{\"1330\":1,\"1331\":1}}],[\"transfor\",{\"1\":{\"1201\":2}}],[\"transform这个特性\",{\"1\":{\"1615\":1}}],[\"transform\",{\"1\":{\"1615\":4,\"1619\":2}}],[\"transforming\",{\"1\":{\"1615\":1}}],[\"transformed\",{\"1\":{\"1620\":1}}],[\"transformedbeanname\",{\"1\":{\"997\":2,\"1647\":2,\"1648\":1}}],[\"transformers\",{\"1\":{\"1171\":1}}],[\"transformation\",{\"1\":{\"519\":3,\"1615\":1,\"1618\":2}}],[\"transction\",{\"1\":{\"1262\":1}}],[\"transactioncallback\",{\"1\":{\"1655\":1}}],[\"transactioninfo\",{\"1\":{\"1655\":2}}],[\"transactioninterceptor就是代理逻辑\",{\"1\":{\"1655\":1}}],[\"transactioninterceptor\",{\"1\":{\"1655\":2}}],[\"transactionmanager\",{\"1\":{\"1655\":1}}],[\"transactionattribute\",{\"1\":{\"1655\":1}}],[\"transactionattributesource\",{\"1\":{\"1655\":1}}],[\"transactionaspectsupport\",{\"1\":{\"1655\":19}}],[\"transactional\",{\"1\":{\"1655\":1}}],[\"transactional注解时\",{\"1\":{\"1655\":1}}],[\"transactional注解的属性值\",{\"1\":{\"1655\":1}}],[\"transactional注解的\",{\"1\":{\"1655\":1}}],[\"transactional注解并不会注入一个新的beanpostprocessor\",{\"1\":{\"1649\":1}}],[\"transactional注解并不会影响循环依赖\",{\"1\":{\"1649\":1}}],[\"transactional注解\",{\"1\":{\"1630\":1,\"1655\":1}}],[\"transactional中propagation属性值设置错误即propagation\",{\"1\":{\"1239\":1}}],[\"transactional所在类中\",{\"1\":{\"1239\":1}}],[\"transactional所在类非spring容器管理的bean\",{\"1\":{\"1239\":1}}],[\"transactional配置的方法并非public权限修饰\",{\"1\":{\"1239\":1}}],[\"transactionsystemexception\",{\"1\":{\"1655\":1}}],[\"transactionstatus\",{\"1\":{\"1655\":1}}],[\"transactionsupportcache\",{\"1\":{\"1655\":1}}],[\"transactions\",{\"1\":{\"893\":1}}],[\"transaction只适用于所有的表使用事务引擎的数据库\",{\"1\":{\"438\":1}}],[\"transaction的时候\",{\"1\":{\"438\":1}}],[\"transaction\",{\"1\":{\"433\":1,\"435\":1,\"465\":1,\"468\":5,\"542\":1,\"580\":1,\"582\":1,\"891\":1,\"1262\":3,\"1297\":1,\"1615\":1,\"1655\":3}}],[\"track\",{\"1\":{\"474\":2}}],[\"tracking\",{\"1\":{\"465\":1}}],[\"trace排序部分结果\",{\"1\":{\"520\":2}}],[\"trace结果中\",{\"1\":{\"421\":1}}],[\"trace的功能\",{\"1\":{\"544\":1}}],[\"trace的结果如下\",{\"1\":{\"355\":1}}],[\"trace的结果来确认的\",{\"1\":{\"354\":1}}],[\"trace的时候\",{\"1\":{\"354\":1}}],[\"trace`\",{\"1\":{\"354\":1,\"421\":1}}],[\"trace=\",{\"1\":{\"354\":1,\"421\":1,\"519\":2,\"520\":2}}],[\"trace\",{\"1\":{\"354\":2,\"421\":2,\"519\":2,\"520\":2,\"544\":2,\"965\":1,\"996\":1,\"1007\":1,\"1022\":1,\"1055\":2,\"1121\":2,\"1167\":2,\"1168\":2,\"1647\":3}}],[\"traideid\",{\"1\":{\"368\":3}}],[\"tradid\",{\"1\":{\"367\":1}}],[\"tradeied\",{\"1\":{\"368\":2}}],[\"tradeid转成utf8\",{\"1\":{\"368\":1}}],[\"tradeid=l\",{\"1\":{\"368\":2}}],[\"tradeid\",{\"1\":{\"366\":1,\"367\":1,\"368\":10}}],[\"trade\",{\"1\":{\"368\":17}}],[\"tradelog\",{\"1\":{\"366\":3,\"367\":2,\"368\":10}}],[\"t命令\",{\"1\":{\"347\":1}}],[\"t2表\",{\"1\":{\"461\":1}}],[\"t2时刻这个数字是每次查询的时候由系统临时计算出来的\",{\"1\":{\"497\":1}}],[\"t2时刻显示的trx\",{\"1\":{\"497\":1}}],[\"t2时刻\",{\"1\":{\"447\":1}}],[\"t2是被驱动表\",{\"1\":{\"401\":1}}],[\"t2\",{\"1\":{\"321\":2,\"400\":3,\"401\":1,\"402\":2,\"403\":1,\"404\":2,\"407\":7,\"408\":1,\"409\":1,\"492\":1,\"523\":5,\"524\":2,\"525\":2,\"1404\":2,\"1498\":1,\"1592\":2,\"1615\":3}}],[\"t1表\",{\"1\":{\"461\":1}}],[\"t1的值是非常小的\",{\"1\":{\"457\":1}}],[\"t1语句都会被传到备库s上\",{\"1\":{\"413\":1}}],[\"t1是驱动表\",{\"1\":{\"401\":1}}],[\"t1\",{\"1\":{\"321\":2,\"400\":2,\"401\":3,\"402\":2,\"403\":2,\"404\":4,\"407\":4,\"408\":1,\"409\":3,\"414\":4,\"416\":3,\"417\":2,\"418\":1,\"457\":2,\"462\":2,\"523\":5,\"524\":2,\"525\":2,\"1404\":2,\"1432\":3,\"1498\":1,\"1592\":2,\"1615\":3,\"1663\":3}}],[\"tas\",{\"1\":{\"1655\":3}}],[\"tasks\",{\"1\":{\"1616\":1,\"1620\":1}}],[\"taskname\",{\"1\":{\"1535\":4}}],[\"task\",{\"1\":{\"1535\":5,\"1600\":1,\"1620\":1}}],[\"taskqueue\",{\"1\":{\"1535\":3}}],[\"taskexecutor\",{\"1\":{\"1123\":9}}],[\"tabulate\",{\"1\":{\"1615\":1}}],[\"tabat\",{\"1\":{\"1554\":2}}],[\"tab\",{\"1\":{\"1549\":8,\"1553\":5,\"1554\":24}}],[\"table本质上就是一个node数组\",{\"1\":{\"1554\":1}}],[\"table位空则创建\",{\"1\":{\"1549\":1}}],[\"table的初始长度length默认值是16\",{\"1\":{\"1546\":1}}],[\"table和drop\",{\"1\":{\"485\":1}}],[\"table和insert语句的binlog同步过去执行的话\",{\"1\":{\"468\":1}}],[\"table或者drop\",{\"1\":{\"484\":1}}],[\"table或者truncate\",{\"1\":{\"483\":1}}],[\"table语句会立即重新计算统计数据\",{\"1\":{\"559\":1}}],[\"table语句来重新计算统计数据\",{\"1\":{\"559\":1}}],[\"table语句误删数据表\",{\"1\":{\"483\":1}}],[\"table语句里面设定等待时间\",{\"1\":{\"441\":1}}],[\"table语句中使用engine=memory来指定存储引擎的类型来创建表\",{\"1\":{\"317\":1}}],[\"tables语法除了会限制别的线程的读写外\",{\"1\":{\"440\":1}}],[\"tables主动释放锁\",{\"1\":{\"440\":1}}],[\"tables\",{\"1\":{\"431\":2,\"437\":1,\"440\":1,\"482\":1,\"519\":2,\"534\":2,\"557\":1,\"558\":1,\"1263\":1}}],[\"tables命令不显示临时表\",{\"1\":{\"410\":1}}],[\"table命令\",{\"1\":{\"484\":1}}],[\"table命令记录binlog的时候\",{\"1\":{\"413\":1}}],[\"table命令的时候\",{\"1\":{\"413\":1}}],[\"table是可以一次删除多个表的\",{\"1\":{\"413\":1}}],[\"table传给备库执行\",{\"1\":{\"413\":1}}],[\"table\",{\"1\":{\"322\":1,\"323\":1,\"329\":1,\"330\":6,\"335\":1,\"336\":1,\"338\":1,\"346\":1,\"347\":1,\"349\":1,\"350\":2,\"352\":1,\"353\":1,\"356\":2,\"361\":3,\"362\":4,\"363\":2,\"366\":1,\"368\":2,\"378\":1,\"390\":4,\"396\":2,\"400\":2,\"404\":2,\"407\":1,\"409\":3,\"410\":1,\"412\":3,\"413\":8,\"414\":1,\"416\":2,\"417\":1,\"419\":1,\"421\":4,\"424\":2,\"426\":1,\"431\":4,\"433\":1,\"441\":2,\"446\":1,\"454\":4,\"459\":1,\"461\":4,\"462\":1,\"468\":1,\"476\":1,\"478\":1,\"479\":1,\"485\":1,\"489\":1,\"490\":1,\"494\":3,\"506\":6,\"510\":1,\"518\":1,\"519\":11,\"520\":2,\"523\":2,\"526\":1,\"534\":2,\"535\":1,\"548\":1,\"553\":4,\"555\":4,\"558\":8,\"559\":8,\"1480\":3,\"1498\":2,\"1546\":1,\"1548\":3,\"1549\":1,\"1550\":4,\"1553\":1,\"1554\":7,\"1615\":1}}],[\"table建表的时候\",{\"1\":{\"317\":1}}],[\"takes\",{\"1\":{\"1623\":3}}],[\"takelock\",{\"1\":{\"1503\":10}}],[\"take锁会阻塞在notempty条件上\",{\"1\":{\"1503\":1}}],[\"take锁\",{\"1\":{\"1503\":1}}],[\"takeindex\",{\"1\":{\"1502\":5}}],[\"take\",{\"1\":{\"1501\":3,\"1502\":1,\"1503\":1,\"1517\":2,\"1535\":1,\"1608\":1,\"1615\":1}}],[\"taks\",{\"1\":{\"895\":1}}],[\"target2\",{\"1\":{\"1654\":2}}],[\"target是被代理的对象爱过你\",{\"1\":{\"1654\":1}}],[\"targetbatchsize\",{\"1\":{\"1620\":8}}],[\"targetbeanname\",{\"1\":{\"917\":1}}],[\"targetref\",{\"1\":{\"1594\":3,\"1599\":8}}],[\"target注解的作用是描述注解的使用范围\",{\"1\":{\"1133\":1}}],[\"targettype\",{\"1\":{\"1086\":1,\"1089\":1,\"1091\":3,\"1639\":3,\"1647\":3}}],[\"targetclass\",{\"1\":{\"964\":1,\"1648\":7,\"1654\":4,\"1655\":4}}],[\"target\",{\"1\":{\"917\":1,\"961\":3,\"964\":1,\"967\":2,\"1061\":2,\"1064\":2,\"1070\":2,\"1133\":1,\"1134\":1,\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":3,\"1594\":1,\"1647\":1,\"1654\":7}}],[\"targetsource接口\",{\"0\":{\"803\":1}}],[\"tag中的数据不需要\",{\"1\":{\"1620\":1}}],[\"taggedarrayspliterator\",{\"1\":{\"1620\":1}}],[\"taggedarrayspliterator<t>\",{\"1\":{\"1620\":1}}],[\"taggedarrayspliterator<>\",{\"1\":{\"1620\":2}}],[\"taggedarray\",{\"1\":{\"1620\":1}}],[\"taggedarray<t>\",{\"1\":{\"1620\":2}}],[\"tag\",{\"1\":{\"394\":12,\"1620\":1,\"1647\":5}}],[\"tags的使用\",{\"0\":{\"1853\":1}}],[\"tags\",{\"1\":{\"307\":3,\"1620\":4}}],[\"tangs\",{\"1\":{\"330\":2}}],[\"t\",{\"1\":{\"317\":1,\"319\":1,\"320\":2,\"322\":2,\"323\":2,\"335\":3,\"336\":3,\"338\":1,\"342\":1,\"345\":3,\"346\":3,\"347\":1,\"348\":1,\"352\":2,\"353\":1,\"354\":1,\"356\":2,\"366\":10,\"395\":1,\"407\":4,\"409\":5,\"411\":6,\"412\":1,\"413\":12,\"421\":1,\"422\":8,\"424\":4,\"426\":1,\"429\":10,\"433\":2,\"446\":1,\"447\":13,\"448\":1,\"454\":8,\"459\":4,\"468\":2,\"476\":4,\"478\":3,\"491\":4,\"494\":4,\"542\":1,\"611\":2,\"928\":1,\"963\":1,\"973\":1,\"1086\":1,\"1103\":7,\"1506\":2,\"1594\":25,\"1595\":6,\"1597\":7,\"1598\":23,\"1599\":20,\"1600\":1,\"1601\":8,\"1603\":2,\"1607\":2,\"1608\":4,\"1609\":10,\"1613\":3,\"1614\":2,\"1615\":4,\"1617\":4,\"1618\":29,\"1620\":15,\"1647\":3,\"1648\":1,\"1650\":1,\"1689\":1}}],[\"tendency\",{\"1\":{\"1623\":1}}],[\"tell\",{\"1\":{\"922\":1,\"1164\":1,\"1647\":1}}],[\"tel字段\",{\"1\":{\"573\":1}}],[\"tel字段的value\",{\"1\":{\"573\":1}}],[\"tel为15623667886\",{\"1\":{\"573\":1}}],[\"tel\",{\"1\":{\"573\":5}}],[\"tehello\",{\"1\":{\"570\":1}}],[\"tests\",{\"1\":{\"1599\":4}}],[\"testset\",{\"1\":{\"574\":11}}],[\"testset=>\",{\"1\":{\"574\":2}}],[\"testusername\",{\"1\":{\"1157\":1}}],[\"testpropertysource来源的优先级相当的高\",{\"1\":{\"1157\":1}}],[\"testpropertysourcedemo\",{\"1\":{\"1157\":3}}],[\"testpropertysource\",{\"1\":{\"1157\":2}}],[\"testping\",{\"1\":{\"582\":1}}],[\"testclass\",{\"1\":{\"1134\":3}}],[\"testclient\",{\"1\":{\"896\":1}}],[\"testcontext\",{\"1\":{\"896\":1}}],[\"testcontext框架\",{\"1\":{\"896\":1}}],[\"testtx\",{\"1\":{\"582\":1}}],[\"test2\",{\"1\":{\"514\":2}}],[\"test1\",{\"1\":{\"514\":2}}],[\"test\",{\"1\":{\"454\":2,\"537\":1,\"570\":2,\"571\":1,\"583\":1,\"896\":1,\"900\":1,\"1157\":2,\"1535\":1,\"1591\":1,\"1594\":7,\"1595\":8,\"1599\":22,\"1606\":1,\"1609\":1,\"1618\":1,\"1620\":5,\"1638\":1,\"1646\":1,\"1654\":5}}],[\"test03\",{\"1\":{\"378\":1}}],[\"templateinterpreter\",{\"1\":{\"1473\":1}}],[\"template\",{\"1\":{\"583\":8}}],[\"temptable\",{\"1\":{\"557\":4}}],[\"tempary\",{\"1\":{\"412\":1,\"413\":2}}],[\"temp\",{\"1\":{\"407\":3,\"409\":5,\"411\":1,\"412\":1,\"413\":5}}],[\"temporary\",{\"1\":{\"330\":1,\"407\":1,\"409\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":1,\"416\":1,\"420\":1,\"1164\":1,\"1171\":1,\"1647\":1}}],[\"textbuilder\",{\"1\":{\"1084\":3,\"1091\":3}}],[\"textsqlnode\",{\"1\":{\"645\":5}}],[\"text系列存储非二进制字符串\",{\"1\":{\"530\":1}}],[\"text\",{\"1\":{\"309\":1,\"429\":1,\"530\":1,\"645\":1,\"1053\":3,\"1082\":4,\"1084\":2,\"1254\":1,\"1638\":2}}],[\"terminalsink是sink最终的形态\",{\"1\":{\"1623\":1}}],[\"terminalsink\",{\"1\":{\"1623\":2}}],[\"terminalop<e\",{\"1\":{\"1623\":2}}],[\"terminalop<t\",{\"1\":{\"1617\":1,\"1623\":1}}],[\"terminalop\",{\"1\":{\"1623\":15,\"1624\":1}}],[\"terminal\",{\"1\":{\"1608\":1,\"1619\":3,\"1620\":1,\"1621\":4,\"1622\":1,\"1623\":4}}],[\"term=6\",{\"1\":{\"306\":1}}],[\"term\",{\"1\":{\"304\":3,\"306\":2,\"308\":1}}],[\"tianjin\",{\"1\":{\"1605\":1}}],[\"tid\",{\"1\":{\"1483\":1}}],[\"ticket\",{\"1\":{\"1404\":6}}],[\"tirm\",{\"1\":{\"1215\":1}}],[\"timout\",{\"1\":{\"571\":1}}],[\"times\",{\"1\":{\"1608\":2}}],[\"timestamp是utc时间戳\",{\"1\":{\"529\":1}}],[\"timestamp作为默认\",{\"1\":{\"529\":1}}],[\"timestamp命令\",{\"1\":{\"454\":1}}],[\"timestamp命令约定了接下来now\",{\"1\":{\"454\":1}}],[\"timestamp=1546103491\",{\"1\":{\"454\":1}}],[\"timestamp=1541402277\",{\"1\":{\"420\":1}}],[\"timestamp\",{\"1\":{\"454\":2,\"457\":1,\"478\":2,\"510\":2,\"518\":2,\"529\":1}}],[\"timeval\",{\"1\":{\"1569\":1}}],[\"timeunit\",{\"1\":{\"1476\":1,\"1501\":2,\"1573\":1,\"1612\":1}}],[\"time和choice类型选其一\",{\"1\":{\"1053\":1}}],[\"timezone\",{\"1\":{\"959\":1}}],[\"time选项\",{\"1\":{\"588\":1}}],[\"time这三个列组合起来不重复的值有多少\",{\"1\":{\"558\":1}}],[\"time这单单一列不重复的值有多少\",{\"1\":{\"558\":1}}],[\"time这几个方案里选出一个成本最低的方案\",{\"1\":{\"555\":1}}],[\"time这两个方案中选出成本最低的那个\",{\"1\":{\"555\":2}}],[\"time这两个索引\",{\"1\":{\"549\":1}}],[\"time可以使用range方式的访问\",{\"1\":{\"555\":1}}],[\"time访问s2的成本\",{\"1\":{\"555\":2}}],[\"time访问s1的成本\",{\"1\":{\"555\":1}}],[\"time两种\",{\"1\":{\"555\":1}}],[\"time索引占了6条记录\",{\"1\":{\"558\":1}}],[\"time索引\",{\"1\":{\"554\":1,\"555\":2}}],[\"time索引执行查询后\",{\"1\":{\"554\":1}}],[\"time索引执行查询\",{\"1\":{\"554\":1}}],[\"time成本将会是\",{\"1\":{\"551\":1}}],[\"time来执行查询\",{\"1\":{\"551\":1}}],[\"time时有3个单点区间\",{\"1\":{\"549\":1}}],[\"time执行查询的成本更低些\",{\"1\":{\"555\":2}}],[\"time执行查询的成本如下所示\",{\"1\":{\"549\":1}}],[\"time执行查询的总成本就是\",{\"1\":{\"549\":1}}],[\"time二级索引执行查询时\",{\"1\":{\"549\":1}}],[\"time在区间expire\",{\"1\":{\"549\":1}}],[\"time对应的位置分别是1\",{\"1\":{\"553\":1}}],[\"time对应的b+树索引中找出最后一条满足这个条件的记录\",{\"1\":{\"549\":1}}],[\"time对应的b+树索引\",{\"1\":{\"549\":1}}],[\"time对应的搜索条件是\",{\"1\":{\"549\":1}}],[\"time搜索会使用二级索引+回表方式的查询\",{\"1\":{\"549\":1}}],[\"time<=\",{\"1\":{\"547\":1,\"549\":1,\"554\":3,\"555\":2}}],[\"time>\",{\"1\":{\"547\":2,\"549\":1,\"554\":3,\"555\":2}}],[\"time作为这个sql查询过程中索引\",{\"1\":{\"544\":1}}],[\"timewait函数\",{\"1\":{\"481\":1}}],[\"timer\",{\"1\":{\"479\":1}}],[\"timer的值来判断数据库是否出问题了\",{\"1\":{\"479\":1}}],[\"timed=\",{\"1\":{\"479\":1}}],[\"timediff\",{\"1\":{\"434\":1}}],[\"timeout指定等待时间\",{\"1\":{\"1569\":1}}],[\"timeout可选\",{\"1\":{\"473\":1}}],[\"timeout\",{\"1\":{\"473\":1,\"571\":1,\"603\":1,\"624\":3,\"1501\":2,\"1569\":1,\"1570\":1}}],[\"timeout的默认值是50s\",{\"1\":{\"444\":1}}],[\"timeout来设置\",{\"1\":{\"444\":1}}],[\"timeout控制的\",{\"1\":{\"318\":1}}],[\"time的范围区间是确定的\",{\"1\":{\"555\":1}}],[\"time的范围区间只有一个\",{\"1\":{\"549\":1}}],[\"time的tracer的输出\",{\"1\":{\"551\":1}}],[\"time的情况类似\",{\"1\":{\"549\":1}}],[\"time的成本更小\",{\"1\":{\"555\":1}}],[\"time的成本最低\",{\"1\":{\"551\":1}}],[\"time的成本\",{\"1\":{\"549\":1,\"551\":1}}],[\"time的成本为47\",{\"1\":{\"544\":1}}],[\"time的时间\",{\"1\":{\"428\":2}}],[\"time的值为10秒\",{\"1\":{\"428\":1}}],[\"time的默认值为10\",{\"1\":{\"428\":1}}],[\"time控制的\",{\"1\":{\"428\":1}}],[\"time值的sql\",{\"1\":{\"428\":1}}],[\"time`\",{\"1\":{\"375\":1,\"506\":2,\"510\":1,\"518\":1,\"519\":2,\"553\":4,\"555\":4}}],[\"time=1685977459844\",{\"1\":{\"639\":1}}],[\"time=1685805324275\",{\"1\":{\"635\":1}}],[\"time=1684856471454\",{\"1\":{\"312\":1}}],[\"time=1684249060388\",{\"1\":{\"308\":1}}],[\"time=1678024153495\",{\"1\":{\"517\":1}}],[\"time=1\",{\"1\":{\"428\":1}}],[\"time=0\",{\"1\":{\"346\":1}}],[\"time\",{\"1\":{\"307\":5,\"371\":2,\"420\":2,\"428\":4,\"429\":6,\"434\":1,\"510\":3,\"518\":3,\"529\":2,\"538\":5,\"544\":4,\"547\":7,\"549\":8,\"553\":10,\"555\":20,\"558\":4,\"996\":1,\"997\":1,\"1020\":1,\"1053\":3,\"1092\":1,\"1164\":1,\"1165\":1,\"1501\":2,\"1600\":2,\"1608\":2,\"1620\":3,\"1622\":1,\"1623\":1,\"1647\":1}}],[\"tinytext\",{\"1\":{\"530\":1}}],[\"tinyblob\",{\"1\":{\"530\":1}}],[\"tinyint\",{\"1\":{\"330\":1,\"338\":1,\"528\":1}}],[\"title\",{\"1\":{\"307\":4,\"384\":1}}],[\"tomcat热加载和热部署\",{\"0\":{\"1695\":1}}],[\"tomcat提供了四组目录供用户存放第三方类库\",{\"1\":{\"1693\":1}}],[\"tomcat提供了webapplicationinitializer的接口\",{\"1\":{\"1658\":1}}],[\"tomcat主要用类加载器解决以下4个问题\",{\"1\":{\"1693\":1}}],[\"tomcat拥有不同的自定义类加载器\",{\"1\":{\"1693\":1}}],[\"tomcat中自定义了一个类加载器webappclassloader\",{\"1\":{\"1693\":1}}],[\"tomcat作为servlet容器\",{\"1\":{\"1693\":1}}],[\"tomcat类加载机制\",{\"0\":{\"1690\":1}}],[\"tomcat对jdk线程池的扩展taskqueue\",{\"1\":{\"1689\":1}}],[\"tomcat线程模型\",{\"0\":{\"1689\":1}}],[\"tomcat与外部世界的连接器\",{\"1\":{\"1687\":1}}],[\"tomcat核心组件\",{\"0\":{\"1684\":1}}],[\"tomcat要实现2个核心功能\",{\"1\":{\"1683\":1}}],[\"tomcat的类加载机制\",{\"0\":{\"1693\":1}}],[\"tomcat的设计者将网络通信和应用层协议解析放在一起考虑\",{\"1\":{\"1687\":1}}],[\"tomcat的设计者分别设计了3个组件来实现这3个功能\",{\"1\":{\"1687\":1}}],[\"tomcat的架构图如下\",{\"1\":{\"1683\":1}}],[\"tomcat的核心\",{\"1\":{\"1683\":1}}],[\"tomcat启动期间会通过解析server\",{\"1\":{\"1683\":1}}],[\"tomcat采用了组件化的设计\",{\"1\":{\"1683\":1}}],[\"tomcat是java\",{\"1\":{\"1683\":1}}],[\"tomcat整体架构\",{\"0\":{\"1683\":1}}],[\"tomcat\",{\"0\":{\"1682\":1},\"1\":{\"1687\":1}}],[\"tomcat自定义类加载器\",{\"1\":{\"1663\":1}}],[\"tomcat除了会帮我们实例化我们所实现的webapplicationinitializer的类以外\",{\"1\":{\"1658\":1}}],[\"tomillis\",{\"1\":{\"1612\":1}}],[\"toc\",{\"1\":{\"1627\":1}}],[\"tocollection\",{\"1\":{\"1609\":4,\"1616\":1,\"1618\":2}}],[\"toset\",{\"1\":{\"1618\":3}}],[\"tostring\",{\"1\":{\"917\":3,\"953\":1,\"985\":1,\"994\":1,\"997\":2,\"1000\":2,\"1001\":4,\"1003\":1,\"1005\":7,\"1006\":3,\"1011\":4,\"1040\":1,\"1041\":1,\"1043\":1,\"1065\":1,\"1084\":1,\"1091\":1,\"1099\":1,\"1119\":2,\"1184\":2,\"1546\":1,\"1594\":1,\"1595\":4,\"1608\":2,\"1609\":2,\"1612\":1,\"1613\":1,\"1616\":1,\"1618\":2,\"1647\":2}}],[\"together\",{\"1\":{\"1615\":1,\"1621\":1}}],[\"tointfunction<\",{\"1\":{\"1614\":1,\"1618\":1}}],[\"touppercase\",{\"1\":{\"1609\":1,\"1610\":3,\"1614\":2}}],[\"toarray\",{\"1\":{\"1603\":1,\"1608\":2}}],[\"tolowercase\",{\"1\":{\"1614\":5}}],[\"tolist本身方法返回的是一个arraylist对象\",{\"1\":{\"1618\":1}}],[\"tolist\",{\"1\":{\"1598\":2,\"1608\":2,\"1609\":5,\"1613\":1,\"1615\":1,\"1616\":1,\"1618\":5}}],[\"tolerance\",{\"1\":{\"1311\":1}}],[\"toward\",{\"1\":{\"1594\":2}}],[\"token机制\",{\"1\":{\"1248\":1}}],[\"todo\",{\"1\":{\"989\":1,\"1019\":1}}],[\"tojsonstring\",{\"1\":{\"582\":1}}],[\"tool\",{\"1\":{\"1028\":3}}],[\"too\",{\"1\":{\"519\":1,\"1620\":1}}],[\"totalbydept\",{\"1\":{\"1616\":1}}],[\"total\",{\"1\":{\"429\":1,\"1616\":1,\"1619\":1}}],[\"top\",{\"1\":{\"429\":1,\"928\":1,\"1972\":1}}],[\"to\",{\"1\":{\"306\":4,\"318\":1,\"322\":1,\"429\":4,\"431\":2,\"434\":1,\"467\":1,\"468\":1,\"481\":1,\"486\":1,\"487\":1,\"519\":3,\"598\":1,\"624\":2,\"922\":3,\"963\":1,\"997\":4,\"1055\":2,\"1162\":3,\"1164\":1,\"1166\":1,\"1167\":2,\"1170\":3,\"1171\":1,\"1172\":1,\"1175\":3,\"1432\":1,\"1479\":3,\"1480\":1,\"1542\":1,\"1554\":1,\"1570\":1,\"1594\":6,\"1595\":3,\"1597\":5,\"1598\":36,\"1599\":14,\"1601\":5,\"1608\":4,\"1609\":2,\"1613\":1,\"1614\":1,\"1615\":36,\"1616\":3,\"1617\":4,\"1618\":14,\"1619\":13,\"1620\":56,\"1621\":7,\"1622\":2,\"1623\":31,\"1647\":22,\"1648\":2,\"1651\":2,\"1655\":4,\"1658\":1,\"1663\":1,\"1689\":3}}],[\"thymeleaf\",{\"1\":{\"1978\":1}}],[\"those\",{\"1\":{\"1619\":1,\"1620\":1,\"1623\":2}}],[\"three\",{\"1\":{\"1623\":1}}],[\"threshold=2\",{\"1\":{\"1551\":1}}],[\"threshold=length∗loadfactor\",{\"1\":{\"1546\":1}}],[\"threshold是hashmap所能容纳的最大数量的node\",{\"1\":{\"1546\":1}}],[\"threshold\",{\"1\":{\"1475\":2,\"1546\":1,\"1549\":2,\"1550\":8,\"1553\":1,\"1554\":1,\"1616\":1}}],[\"threadlambda\",{\"1\":{\"1591\":2}}],[\"threadlocalrandom\",{\"1\":{\"1554\":1}}],[\"threadlocal增加变量\",{\"1\":{\"1528\":1}}],[\"threadlocal<dateformat>\",{\"1\":{\"1528\":1}}],[\"threadlocal类实现了该模式\",{\"1\":{\"1528\":1}}],[\"threadlocal可以为每一个线程拷贝变量的副本\",{\"1\":{\"1406\":1}}],[\"threadlocal为每一个线程保存一个副本变量\",{\"1\":{\"1236\":1}}],[\"threadlocal\",{\"1\":{\"989\":2,\"1528\":1}}],[\"threadlocalscopedemo\",{\"1\":{\"989\":2}}],[\"threadlocalscope\",{\"1\":{\"989\":4}}],[\"threadlocal的作用\",{\"0\":{\"77\":1,\"1406\":1}}],[\"threading+blocking的web\",{\"1\":{\"1565\":1}}],[\"thread模式\",{\"0\":{\"1534\":1},\"1\":{\"1534\":1}}],[\"threadfatory\",{\"1\":{\"1520\":1}}],[\"threadfactory\",{\"1\":{\"1227\":3,\"1476\":3,\"1520\":2}}],[\"thread2通过cas修改value值为1\",{\"1\":{\"1479\":1}}],[\"thread2通过cas修改value值为2\",{\"1\":{\"1479\":1}}],[\"thread2\",{\"1\":{\"1479\":5,\"1551\":1}}],[\"thread1的e指向了key\",{\"1\":{\"1551\":1}}],[\"thread1通过cas修改value值为3\",{\"1\":{\"1479\":1}}],[\"thread1\",{\"1\":{\"1479\":4,\"1551\":1}}],[\"threadname\",{\"1\":{\"1477\":1}}],[\"threadsafedemo\",{\"1\":{\"1404\":4}}],[\"threads\",{\"1\":{\"1227\":4,\"1615\":1,\"1617\":1,\"1620\":1,\"1689\":3}}],[\"threadpooltaskscheduler\",{\"1\":{\"1124\":1}}],[\"threadpoolexecutor的拒绝策略\",{\"1\":{\"1476\":1}}],[\"threadpoolexecutor\",{\"1\":{\"1123\":1,\"1476\":1,\"1573\":2}}],[\"thread更新数据\",{\"1\":{\"460\":1}}],[\"thread执行中转日志\",{\"1\":{\"460\":1}}],[\"thread演化成为了多个线程\",{\"1\":{\"453\":1}}],[\"thread读取中转日志\",{\"1\":{\"453\":1}}],[\"thread负责与主库建立连接\",{\"1\":{\"453\":1}}],[\"thread和sql\",{\"1\":{\"453\":1}}],[\"thread\",{\"0\":{\"498\":1,\"1528\":1,\"1533\":1},\"1\":{\"412\":1,\"453\":1,\"460\":1,\"476\":8,\"481\":2,\"497\":1,\"498\":4,\"499\":1,\"538\":2,\"930\":1,\"989\":13,\"1013\":1,\"1113\":1,\"1119\":1,\"1123\":3,\"1175\":1,\"1375\":1,\"1387\":2,\"1404\":17,\"1477\":4,\"1479\":2,\"1533\":4,\"1534\":1,\"1551\":2,\"1554\":1,\"1573\":1,\"1575\":2,\"1591\":6,\"1592\":4,\"1610\":1,\"1615\":1,\"1617\":4,\"1619\":3,\"1620\":9,\"1622\":1,\"1623\":2,\"1668\":1,\"1689\":1}}],[\"thread类中的yield方法有什么作用\",{\"0\":{\"54\":1,\"1383\":1}}],[\"through\",{\"1\":{\"1165\":1,\"1623\":1}}],[\"thrown\",{\"1\":{\"1175\":2,\"1432\":1,\"1595\":2,\"1599\":4,\"1620\":2,\"1663\":1}}],[\"throwableholderexception\",{\"1\":{\"1655\":2}}],[\"throwableholder\",{\"1\":{\"1655\":11}}],[\"throwable\",{\"1\":{\"934\":1,\"946\":2,\"964\":2,\"1007\":1,\"1008\":1,\"1013\":1,\"1124\":1,\"1175\":2,\"1575\":5,\"1647\":5,\"1648\":1,\"1654\":4,\"1655\":13}}],[\"throwing\",{\"0\":{\"825\":1},\"1\":{\"1620\":1}}],[\"throw\",{\"1\":{\"645\":1,\"922\":1,\"928\":1,\"946\":2,\"963\":1,\"964\":2,\"996\":2,\"997\":2,\"1007\":1,\"1008\":1,\"1022\":1,\"1043\":1,\"1163\":1,\"1476\":1,\"1503\":2,\"1533\":1,\"1534\":1,\"1553\":1,\"1554\":1,\"1574\":2,\"1575\":5,\"1619\":4,\"1620\":3,\"1621\":2,\"1622\":5,\"1623\":1,\"1647\":23,\"1648\":4,\"1650\":1,\"1651\":2,\"1655\":9,\"1658\":1}}],[\"throws\",{\"1\":{\"583\":1,\"909\":1,\"922\":1,\"928\":1,\"930\":1,\"931\":1,\"933\":1,\"934\":1,\"946\":2,\"957\":2,\"963\":2,\"964\":1,\"985\":1,\"996\":1,\"997\":2,\"998\":1,\"1000\":1,\"1001\":1,\"1002\":2,\"1003\":3,\"1005\":1,\"1006\":2,\"1007\":2,\"1008\":1,\"1011\":1,\"1012\":1,\"1013\":1,\"1019\":1,\"1021\":1,\"1022\":1,\"1032\":1,\"1040\":1,\"1041\":1,\"1043\":2,\"1075\":1,\"1082\":1,\"1084\":1,\"1100\":2,\"1103\":1,\"1148\":1,\"1163\":1,\"1175\":1,\"1404\":1,\"1432\":1,\"1487\":1,\"1502\":2,\"1503\":2,\"1521\":1,\"1574\":3,\"1591\":1,\"1595\":3,\"1597\":3,\"1598\":12,\"1599\":8,\"1601\":2,\"1619\":3,\"1620\":3,\"1638\":1,\"1644\":1,\"1646\":1,\"1647\":7,\"1648\":3,\"1651\":2,\"1654\":4,\"1655\":1,\"1657\":3,\"1663\":1}}],[\"thrift文件\",{\"0\":{\"675\":1}}],[\"thrift\",{\"0\":{\"673\":1}}],[\"that\",{\"1\":{\"429\":1,\"922\":1,\"952\":3,\"1162\":1,\"1166\":4,\"1170\":1,\"1594\":6,\"1597\":4,\"1598\":19,\"1599\":20,\"1600\":2,\"1608\":2,\"1613\":1,\"1615\":24,\"1616\":1,\"1617\":5,\"1618\":1,\"1619\":6,\"1620\":25,\"1621\":3,\"1623\":12,\"1647\":4}}],[\"than\",{\"1\":{\"424\":4,\"1608\":2,\"1615\":2,\"1619\":1,\"1620\":4,\"1689\":1}}],[\"things\",{\"1\":{\"1616\":1}}],[\"thinking\",{\"0\":{\"274\":1},\"1\":{\"917\":2,\"918\":1,\"930\":4,\"953\":2,\"954\":2,\"994\":1,\"1003\":1,\"1005\":1,\"1012\":1,\"1022\":1,\"1030\":2,\"1040\":1,\"1041\":1,\"1043\":1,\"1065\":1,\"1084\":2,\"1091\":2,\"1134\":1,\"1138\":1,\"1146\":1,\"1174\":2}}],[\"this表示referencepipeline\",{\"1\":{\"1622\":1}}],[\"this\",{\"1\":{\"429\":2,\"909\":2,\"917\":3,\"918\":3,\"922\":7,\"931\":1,\"952\":5,\"953\":2,\"956\":2,\"963\":3,\"964\":4,\"965\":4,\"973\":3,\"975\":2,\"985\":7,\"996\":10,\"997\":6,\"998\":1,\"1001\":2,\"1003\":3,\"1005\":16,\"1007\":3,\"1009\":1,\"1012\":3,\"1027\":6,\"1045\":1,\"1053\":1,\"1055\":8,\"1065\":1,\"1121\":5,\"1148\":2,\"1149\":1,\"1162\":10,\"1163\":1,\"1164\":6,\"1167\":8,\"1168\":5,\"1170\":2,\"1171\":2,\"1172\":3,\"1173\":1,\"1174\":1,\"1175\":13,\"1184\":5,\"1193\":2,\"1388\":2,\"1412\":1,\"1432\":1,\"1485\":1,\"1501\":1,\"1502\":5,\"1503\":8,\"1526\":1,\"1531\":3,\"1535\":1,\"1549\":1,\"1550\":1,\"1554\":4,\"1573\":1,\"1575\":3,\"1592\":2,\"1594\":3,\"1595\":2,\"1597\":6,\"1598\":21,\"1599\":26,\"1600\":4,\"1601\":3,\"1603\":4,\"1605\":7,\"1608\":9,\"1613\":10,\"1614\":1,\"1615\":3,\"1616\":6,\"1617\":2,\"1618\":4,\"1619\":6,\"1620\":41,\"1621\":15,\"1622\":14,\"1623\":19,\"1638\":1,\"1647\":39,\"1648\":12,\"1649\":1,\"1650\":1,\"1651\":12,\"1654\":1,\"1655\":3,\"1663\":1}}],[\"these\",{\"1\":{\"1619\":2,\"1620\":4}}],[\"thelist2\",{\"1\":{\"1608\":2}}],[\"thelist1\",{\"1\":{\"1608\":2}}],[\"thelist\",{\"1\":{\"1608\":2,\"1609\":2}}],[\"thenacceptboth\",{\"1\":{\"1518\":1}}],[\"thenapply\",{\"1\":{\"1518\":1}}],[\"thencomparing\",{\"1\":{\"1614\":6,\"1654\":1}}],[\"thencompose\",{\"1\":{\"1518\":1}}],[\"thencombine\",{\"1\":{\"1518\":1}}],[\"then\",{\"1\":{\"1432\":1,\"1598\":12,\"1599\":4,\"1615\":2,\"1617\":1,\"1618\":1,\"1619\":2,\"1620\":5,\"1621\":4,\"1663\":1}}],[\"they\",{\"1\":{\"1175\":1,\"1594\":2,\"1615\":2,\"1619\":1,\"1623\":4}}],[\"their\",{\"1\":{\"1171\":1,\"1619\":5,\"1620\":3}}],[\"there\",{\"1\":{\"1053\":3,\"1184\":1,\"1480\":1,\"1600\":1,\"1608\":2,\"1619\":1,\"1647\":1,\"1658\":1}}],[\"them\",{\"1\":{\"922\":1,\"1170\":1,\"1608\":1,\"1615\":3,\"1616\":1,\"1647\":1}}],[\"the\",{\"1\":{\"429\":3,\"571\":1,\"922\":5,\"928\":1,\"997\":8,\"1003\":2,\"1006\":1,\"1007\":3,\"1008\":1,\"1009\":1,\"1011\":1,\"1012\":4,\"1053\":2,\"1061\":1,\"1120\":4,\"1162\":3,\"1164\":3,\"1165\":1,\"1166\":5,\"1171\":1,\"1172\":1,\"1175\":2,\"1432\":5,\"1440\":1,\"1554\":1,\"1594\":24,\"1595\":16,\"1597\":11,\"1598\":89,\"1599\":48,\"1600\":3,\"1601\":37,\"1608\":18,\"1609\":7,\"1613\":3,\"1614\":1,\"1615\":76,\"1616\":2,\"1617\":11,\"1618\":23,\"1619\":28,\"1620\":123,\"1621\":44,\"1622\":11,\"1623\":94,\"1647\":28,\"1648\":4,\"1650\":1,\"1655\":2,\"1658\":1,\"1663\":4,\"1689\":3}}],[\"tcp的连接的拆除需要发送四个包\",{\"1\":{\"1425\":1}}],[\"tcp的特点\",{\"1\":{\"1419\":1}}],[\"tcp建立连接三次握手\",{\"1\":{\"1420\":1}}],[\"tcp\",{\"1\":{\"1419\":1}}],[\"tcp协议通信中的客户端\",{\"1\":{\"1226\":1}}],[\"tcp粘包与拆包\",{\"0\":{\"730\":1}}],[\"tcp为什么是三次握手\",{\"0\":{\"90\":1,\"1420\":1}}],[\"tcp和udp有什么区别\",{\"0\":{\"89\":1,\"1419\":1}}],[\"的文章都是来自这本书\",{\"1\":{\"1992\":1}}],[\"的书籍推荐\",{\"1\":{\"1992\":1}}],[\"的开发便利性简化了分布式系统的开发\",{\"1\":{\"1989\":1}}],[\"的开销而引入偏向锁\",{\"1\":{\"1485\":1}}],[\"的封装\",{\"1\":{\"1986\":1}}],[\"的底层问题\",{\"1\":{\"1983\":1}}],[\"的代码库托管站\",{\"1\":{\"1981\":1}}],[\"的gui开发使用并不多\",{\"1\":{\"1969\":1}}],[\"的gui编程\",{\"1\":{\"1969\":1}}],[\"的gtid的集合记为set\",{\"1\":{\"468\":1}}],[\"的危与机\",{\"1\":{\"1965\":1}}],[\"的部分技术规范\",{\"1\":{\"1683\":1}}],[\"的情况下\",{\"1\":{\"1664\":1}}],[\"的作用\",{\"1\":{\"1664\":1}}],[\"的任意一个方法上面添加了\",{\"1\":{\"1652\":1}}],[\"的映射关系\",{\"1\":{\"1636\":1}}],[\"的属性\",{\"1\":{\"1620\":1}}],[\"的分割迭代器\",{\"1\":{\"1620\":1}}],[\"的流\",{\"1\":{\"1619\":1}}],[\"的对象\",{\"1\":{\"1619\":1}}],[\"的频率非常的高\",{\"1\":{\"1615\":1}}],[\"的说明\",{\"1\":{\"1601\":1}}],[\"的参数\",{\"1\":{\"1595\":1,\"1608\":1}}],[\"的使用\",{\"1\":{\"1593\":1}}],[\"的使用方式如下\",{\"1\":{\"307\":2}}],[\"的方式获取数组对应index上的元素\",{\"1\":{\"1554\":1}}],[\"的方式来代替关联查询的时候\",{\"1\":{\"394\":1}}],[\"的引用赋给了e\",{\"1\":{\"1550\":1}}],[\"的首个元素是否和key一样\",{\"1\":{\"1549\":1}}],[\"的高位异或低16位实现的\",{\"1\":{\"1548\":1}}],[\"的个数\",{\"1\":{\"1546\":1}}],[\"的意思\",{\"1\":{\"1531\":1}}],[\"的工厂类\",{\"1\":{\"1520\":1}}],[\"的奇数位\",{\"1\":{\"1513\":1}}],[\"的线程\",{\"1\":{\"1483\":1}}],[\"的线程时不算在128里面的\",{\"1\":{\"476\":1}}],[\"的jvm字节码指令\",{\"1\":{\"1482\":1}}],[\"的一个实例\",{\"1\":{\"1595\":1}}],[\"的一部分\",{\"1\":{\"1457\":1,\"1982\":1}}],[\"的一种具体的实现\",{\"1\":{\"924\":1}}],[\"的消息投递\",{\"1\":{\"1333\":1}}],[\"的时间复杂度\",{\"1\":{\"1292\":1}}],[\"的时候一些汇总信息\",{\"1\":{\"1615\":1}}],[\"的时候会释放锁\",{\"1\":{\"1490\":1}}],[\"的时候会直接返回这个数\",{\"1\":{\"396\":1}}],[\"的时候都会根据beandefinition重新构建bean\",{\"1\":{\"1182\":1}}],[\"的时候都需要用怀疑的眼光审视\",{\"1\":{\"385\":1}}],[\"的时候不是直接创建对象\",{\"1\":{\"1182\":1}}],[\"的时候\",{\"1\":{\"321\":1,\"348\":1,\"396\":1,\"433\":1,\"448\":1,\"450\":1,\"514\":2}}],[\"的搜索引擎产品\",{\"1\":{\"1254\":1}}],[\"的搜索条件\",{\"1\":{\"554\":2}}],[\"的bean会被缓存嘛\",{\"0\":{\"1182\":1}}],[\"的注解\",{\"1\":{\"1134\":1}}],[\"的定义\",{\"1\":{\"1019\":1}}],[\"的后置处理器\",{\"1\":{\"1016\":1}}],[\"的判断\",{\"1\":{\"1002\":1}}],[\"的holder类\",{\"1\":{\"953\":1}}],[\"的价值所在\",{\"1\":{\"1479\":1}}],[\"的价值\",{\"1\":{\"928\":1}}],[\"的数据安全性\",{\"1\":{\"596\":1}}],[\"的数据结构\",{\"0\":{\"85\":1,\"1414\":1}}],[\"的基数估算值\",{\"1\":{\"577\":1}}],[\"的基础上\",{\"1\":{\"412\":1}}],[\"的成员\",{\"1\":{\"574\":1}}],[\"的成本比扫描全表的成本更高\",{\"1\":{\"522\":1}}],[\"的生存时间\",{\"1\":{\"570\":1}}],[\"的旧值\",{\"1\":{\"570\":1}}],[\"的名称\",{\"1\":{\"569\":1}}],[\"的整个区间就可以叫做临键锁\",{\"1\":{\"537\":1}}],[\"的争用以外\",{\"1\":{\"533\":1}}],[\"的优点是\",{\"1\":{\"577\":1}}],[\"的优化常见优化方法有四种\",{\"1\":{\"526\":1}}],[\"的优势\",{\"1\":{\"404\":1}}],[\"的主键id\",{\"1\":{\"520\":1}}],[\"的主备关系\",{\"1\":{\"468\":1}}],[\"的能力\",{\"1\":{\"490\":1}}],[\"的结论\",{\"1\":{\"478\":1}}],[\"的语句\",{\"1\":{\"476\":1}}],[\"的语义\",{\"1\":{\"414\":1}}],[\"的确认\",{\"1\":{\"472\":1}}],[\"的程度\",{\"1\":{\"472\":1}}],[\"的自己生成的binlog中的gtid集合格式是\",{\"1\":{\"468\":1}}],[\"的file文件的123位置\",{\"1\":{\"467\":1}}],[\"的file\",{\"1\":{\"467\":1}}],[\"的\",{\"1\":{\"467\":1,\"1554\":1,\"1983\":1}}],[\"的位点是不同的\",{\"1\":{\"467\":1}}],[\"的从库的语法如下\",{\"1\":{\"468\":1}}],[\"的从库的时候\",{\"1\":{\"467\":1}}],[\"的从库\",{\"1\":{\"467\":1}}],[\"的ip\",{\"1\":{\"467\":1}}],[\"的场景\",{\"1\":{\"465\":1}}],[\"的过程\",{\"1\":{\"1013\":1,\"1116\":1}}],[\"的过程如果使用的是单线程的话\",{\"1\":{\"460\":1}}],[\"的过程中\",{\"1\":{\"343\":1}}],[\"的模式\",{\"1\":{\"457\":1}}],[\"的速度\",{\"1\":{\"457\":1}}],[\"的机制\",{\"1\":{\"451\":1}}],[\"的行\",{\"1\":{\"447\":2}}],[\"的行数\",{\"1\":{\"395\":1}}],[\"的概念\",{\"1\":{\"433\":1,\"1980\":1}}],[\"的问题\",{\"1\":{\"433\":1,\"469\":2,\"486\":1,\"1237\":1}}],[\"的特性\",{\"1\":{\"432\":1,\"1620\":1}}],[\"的执行过程\",{\"1\":{\"422\":1}}],[\"的由来\",{\"1\":{\"403\":1}}],[\"的算法\",{\"1\":{\"402\":1}}],[\"的表的总行数\",{\"1\":{\"396\":1}}],[\"的例子来说明\",{\"1\":{\"396\":1}}],[\"的原因\",{\"1\":{\"396\":1}}],[\"的实现\",{\"0\":{\"396\":1},\"1\":{\"1595\":1,\"1991\":1}}],[\"的查询\",{\"1\":{\"389\":1,\"390\":1}}],[\"的查询复杂度\",{\"1\":{\"334\":1}}],[\"的设置\",{\"1\":{\"364\":1}}],[\"的总次数\",{\"1\":{\"364\":1}}],[\"的遍历过程中\",{\"1\":{\"356\":1}}],[\"的当前值\",{\"1\":{\"354\":1}}],[\"的初始值\",{\"1\":{\"354\":1}}],[\"的大小和需要查询的字段的总大小来判断使用哪种排序模式\",{\"1\":{\"520\":1}}],[\"的大小\",{\"1\":{\"354\":1}}],[\"的所有字段和值\",{\"1\":{\"573\":1}}],[\"的所有数据\",{\"1\":{\"405\":1}}],[\"的所有人的名字\",{\"1\":{\"353\":1}}],[\"的所有市民了\",{\"1\":{\"352\":1}}],[\"的前缀索引\",{\"1\":{\"351\":1}}],[\"的值相等\",{\"1\":{\"1479\":1}}],[\"的值为cpu核心数\",{\"1\":{\"1227\":1}}],[\"的值变化\",{\"1\":{\"587\":3}}],[\"的值设为\",{\"1\":{\"570\":1,\"573\":1}}],[\"的值\",{\"1\":{\"350\":1}}],[\"的值分别为\",{\"1\":{\"335\":1}}],[\"的记录下面有两种方式来查询\",{\"1\":{\"371\":1}}],[\"的记录只有一个\",{\"1\":{\"350\":1}}],[\"的记录\",{\"1\":{\"350\":1,\"354\":1,\"356\":1}}],[\"的记录一条条取出来回表\",{\"1\":{\"340\":1}}],[\"的条件了\",{\"1\":{\"350\":1}}],[\"的这三种格式间的区别\",{\"1\":{\"454\":1}}],[\"的这些记录\",{\"1\":{\"354\":1}}],[\"的这条记录\",{\"1\":{\"350\":1}}],[\"的这一行\",{\"1\":{\"318\":1}}],[\"的话\",{\"1\":{\"343\":1,\"351\":2,\"366\":1}}],[\"的操作接口\",{\"1\":{\"1986\":1}}],[\"的操作\",{\"1\":{\"342\":1,\"444\":1}}],[\"的单字段索引\",{\"1\":{\"339\":1}}],[\"的人\",{\"1\":{\"339\":1}}],[\"的人时\",{\"1\":{\"339\":1}}],[\"的联合索引和一个\",{\"1\":{\"339\":1}}],[\"的联合索引\",{\"1\":{\"338\":1}}],[\"的形式\",{\"1\":{\"327\":1,\"1554\":1}}],[\"的错误提醒\",{\"1\":{\"320\":1}}],[\"的错误\",{\"1\":{\"318\":1}}],[\"的api来实现的\",{\"1\":{\"307\":1}}],[\"的区别是什么\",{\"0\":{\"12\":1,\"194\":1,\"1210\":1,\"1341\":1}}],[\"中文手册\",{\"1\":{\"1981\":1}}],[\"中配置相关依赖后\",{\"1\":{\"1980\":1}}],[\"中需要接收的参数的类型\",{\"1\":{\"1595\":1}}],[\"中等\",{\"1\":{\"1439\":1}}],[\"中等长度文本数据\",{\"1\":{\"530\":1}}],[\"中引用的对象\",{\"1\":{\"1438\":1}}],[\"中找到对应的视图\",{\"1\":{\"1241\":1}}],[\"中是单例对象\",{\"1\":{\"992\":1}}],[\"中值得学习的地方\",{\"0\":{\"891\":1}}],[\"中查找\",{\"1\":{\"626\":1}}],[\"中可以创建多个数据库类似\",{\"1\":{\"567\":1}}],[\"中有多少条记录\",{\"1\":{\"554\":1}}],[\"中有几种引用类型\",{\"0\":{\"104\":1,\"1435\":1}}],[\"中对应的目录项记录之间隔着几条记录\",{\"1\":{\"549\":1}}],[\"中读取行\",{\"1\":{\"524\":1}}],[\"中间件\",{\"1\":{\"1966\":1}}],[\"中间操作\",{\"1\":{\"1623\":2}}],[\"中间操纵都会返回一个stream对象\",{\"1\":{\"1611\":1}}],[\"中间结果容器的个数也是类似的\",{\"1\":{\"1617\":1}}],[\"中间有差值7可以防止链表和树之间频繁的转换\",{\"1\":{\"1363\":1}}],[\"中间演化经历多个版本\",{\"1\":{\"460\":1}}],[\"中间兄弟不能断\",{\"1\":{\"370\":1}}],[\"中转日志还没有应用完成\",{\"1\":{\"459\":1}}],[\"中就可以少几个id\",{\"1\":{\"394\":1}}],[\"中\",{\"1\":{\"307\":1,\"309\":1,\"345\":1,\"573\":2,\"574\":2,\"577\":1,\"1480\":1,\"1576\":1}}],[\"中消费时\",{\"0\":{\"251\":1,\"1332\":1}}],[\"中的filechannel\",{\"1\":{\"1588\":1}}],[\"中的\",{\"1\":{\"1479\":2}}],[\"中的元注允许是spring模式注解\",{\"1\":{\"1135\":1}}],[\"中的元素进行转换\",{\"1\":{\"1089\":1}}],[\"中的e\",{\"1\":{\"1099\":1}}],[\"中的属性上\",{\"1\":{\"1070\":1}}],[\"中的一个\",{\"1\":{\"624\":1}}],[\"中的所有成员\",{\"1\":{\"574\":1}}],[\"中的sex\",{\"1\":{\"573\":1}}],[\"中的指定字段的浮点数值加上增量\",{\"1\":{\"573\":1}}],[\"中的指定字段的整数值加上增量n\",{\"1\":{\"573\":1}}],[\"中的字段\",{\"1\":{\"573\":1}}],[\"中的n代表最大字符数\",{\"1\":{\"530\":1}}],[\"中的安全点和安全区各代表什么\",{\"0\":{\"113\":1,\"1444\":1}}],[\"中的值\",{\"0\":{\"85\":1,\"1414\":1}}],[\"中国矿业大学\",{\"1\":{\"4\":1}}],[\"bv1pj411n7xz\",{\"1\":{\"1992\":1}}],[\"bv16j411h7rd\",{\"1\":{\"1992\":1}}],[\"bv1m741137qy\",{\"1\":{\"1991\":1}}],[\"bv1gb411t7ha\",{\"1\":{\"1990\":1}}],[\"bv18e411x7et\",{\"1\":{\"1989\":1}}],[\"bv1sv411r7vd\",{\"1\":{\"1987\":1}}],[\"bv1az4y1u7n3\",{\"1\":{\"1987\":1}}],[\"bv1a4411b7v9\",{\"1\":{\"1985\":1}}],[\"bv17a4y1x7zq\",{\"1\":{\"1986\":1}}],[\"bv14a411q7pf\",{\"1\":{\"1985\":1}}],[\"bv19k4y1l7mt\",{\"1\":{\"1983\":1}}],[\"bv1tv411b7dp\",{\"1\":{\"1982\":1}}],[\"bv1fe411p7b3\",{\"1\":{\"1981\":1}}],[\"bv1dp4y1q7hf\",{\"1\":{\"1980\":1}}],[\"bv1y7411k7zz\",{\"1\":{\"1978\":1}}],[\"bv1cj411m7gc\",{\"1\":{\"1975\":1}}],[\"bv12b411k7zu\",{\"1\":{\"1974\":1}}],[\"bv1kb411w75n\",{\"1\":{\"1969\":1}}],[\"broker权限验证\",{\"0\":{\"1953\":1}}],[\"broker消费队列\",{\"0\":{\"1896\":1}}],[\"bridgemethodresolver\",{\"1\":{\"1648\":2}}],[\"bridgedmethod\",{\"1\":{\"1648\":4}}],[\"break\",{\"1\":{\"1506\":1,\"1517\":1,\"1549\":2,\"1553\":2,\"1554\":6,\"1648\":1}}],[\"brpoplpush\",{\"1\":{\"571\":1}}],[\"brpop\",{\"1\":{\"571\":2}}],[\"b树的查询效率不稳定\",{\"1\":{\"1265\":1}}],[\"b树的范围查询\",{\"1\":{\"1265\":1}}],[\"bcl\",{\"1\":{\"1005\":3}}],[\"bca\",{\"1\":{\"556\":1}}],[\"bw\",{\"1\":{\"1003\":1,\"1647\":10}}],[\"bp\",{\"1\":{\"1000\":2,\"1647\":5}}],[\"bdname\",{\"1\":{\"1648\":3}}],[\"bd\",{\"1\":{\"963\":2,\"997\":9,\"1019\":3,\"1647\":13,\"1648\":2}}],[\"bgsave和save对比\",{\"0\":{\"589\":1}}],[\"bgsave是异步进行\",{\"1\":{\"588\":1}}],[\"bgsave\",{\"0\":{\"588\":1},\"1\":{\"589\":1}}],[\"bgsave命令返回\",{\"1\":{\"588\":1}}],[\"bgsave命令\",{\"1\":{\"587\":1}}],[\"blpop\",{\"1\":{\"571\":6}}],[\"bloking\",{\"1\":{\"1572\":1}}],[\"bloom\",{\"1\":{\"1283\":1}}],[\"blobinfo\",{\"1\":{\"1593\":1}}],[\"blob和text都不能有默认值\",{\"1\":{\"530\":1}}],[\"blob系列存储二进制字符串\",{\"1\":{\"530\":1}}],[\"blob\",{\"1\":{\"530\":1}}],[\"blocked\",{\"1\":{\"1483\":1}}],[\"blockingwaitstrategy策略\",{\"1\":{\"1520\":1}}],[\"blockingqueue<integer>\",{\"1\":{\"1503\":2}}],[\"blockingqueue<runnable>\",{\"1\":{\"1476\":1}}],[\"blockingqueue是线程安全的\",{\"1\":{\"1501\":1}}],[\"blockingqueue和jdk集合包中的queue接口兼容\",{\"1\":{\"1501\":1}}],[\"blockingqueue\",{\"0\":{\"1501\":1}}],[\"blockingqueue实现原理\",{\"0\":{\"1499\":1}}],[\"blocking\",{\"1\":{\"602\":1,\"1564\":2}}],[\"block\",{\"0\":{\"403\":1},\"1\":{\"402\":1,\"403\":2,\"431\":5,\"523\":1,\"553\":1,\"555\":1,\"557\":2,\"1619\":1}}],[\"blog\",{\"1\":{\"330\":1,\"561\":1,\"1649\":1}}],[\"bsd许可\",{\"1\":{\"568\":1}}],[\"b=b\",{\"1\":{\"1617\":4}}],[\"b=\",{\"1\":{\"525\":1}}],[\"b=temp\",{\"1\":{\"407\":1}}],[\"btree\",{\"1\":{\"510\":1,\"518\":1}}],[\"b大约1170个元素\",{\"1\":{\"503\":1}}],[\"b+tree\",{\"0\":{\"503\":1}}],[\"b+树作为索引\",{\"1\":{\"1265\":1}}],[\"b+树解决了范围查询的带来的问题\",{\"1\":{\"1265\":1}}],[\"b+树的层级并不会很高\",{\"1\":{\"549\":1}}],[\"b+树可能会出现分裂和平衡的现象\",{\"1\":{\"505\":1}}],[\"b+树提供的这个快速定位能力\",{\"1\":{\"366\":1}}],[\"b+树为了维护索引的有序性\",{\"1\":{\"335\":1}}],[\"b+树\",{\"0\":{\"335\":1}}],[\"b执行第一条update语句的事务id就是248\",{\"1\":{\"497\":1}}],[\"b查到的这个trx\",{\"1\":{\"497\":1}}],[\"b中从innodb\",{\"1\":{\"497\":1}}],[\"b这个语句执行出来\",{\"1\":{\"492\":1}}],[\"b这两个索引的结构图\",{\"1\":{\"347\":1}}],[\"b继续执行\",{\"1\":{\"492\":1}}],[\"b先插入了两个记录\",{\"1\":{\"492\":1}}],[\"b是申请了自增值以后马上就释放自增锁\",{\"1\":{\"492\":1}}],[\"b创建了一个相同结构的表t2\",{\"1\":{\"492\":1}}],[\"b创建的两个临时表t1\",{\"1\":{\"412\":1}}],[\"b创建的临时表\",{\"1\":{\"412\":1}}],[\"b退出等待\",{\"1\":{\"481\":1}}],[\"b处于锁等待状态\",{\"1\":{\"481\":1}}],[\"b时\",{\"1\":{\"481\":1}}],[\"b虽然处于blocked状态\",{\"1\":{\"481\":1}}],[\"b几乎同时就提示了语句被中断\",{\"1\":{\"480\":1}}],[\"b发给主库a\",{\"1\":{\"468\":1}}],[\"b也是再这个间隙加的间隙锁\",{\"1\":{\"448\":1}}],[\"b并不会被阻塞\",{\"1\":{\"448\":1}}],[\"b才能继续执行\",{\"1\":{\"447\":1}}],[\"b在执行第一个update语句的时候就被锁住了\",{\"1\":{\"447\":1}}],[\"b在t2时刻\",{\"1\":{\"447\":1}}],[\"b事务提交\",{\"1\":{\"447\":1}}],[\"b和session\",{\"1\":{\"446\":1}}],[\"b把id=0这一行的d值改成了5\",{\"1\":{\"446\":1}}],[\"b把数据都删除后\",{\"1\":{\"346\":1}}],[\"b需要的也是mdl读锁\",{\"1\":{\"441\":1}}],[\"b只需要操作p\",{\"1\":{\"425\":1}}],[\"b要写入一行ftime是2018\",{\"1\":{\"424\":1}}],[\"b的insert语句\",{\"1\":{\"492\":1}}],[\"b的\",{\"1\":{\"492\":1}}],[\"b的连接\",{\"1\":{\"481\":1}}],[\"b的线程状态设置thd\",{\"1\":{\"481\":1}}],[\"b的线程id是5\",{\"1\":{\"412\":1}}],[\"b的执行线程发一个信号\",{\"1\":{\"481\":1}}],[\"b的运行状态改成thd\",{\"1\":{\"481\":1}}],[\"b的server\",{\"1\":{\"478\":1}}],[\"b的事务\",{\"1\":{\"468\":1}}],[\"b的gtid的集合\",{\"1\":{\"468\":1}}],[\"b的差集\",{\"1\":{\"468\":1}}],[\"b的语句先执行\",{\"1\":{\"462\":1}}],[\"b的第二条语句update\",{\"1\":{\"447\":1}}],[\"b的第一条查询语句是可以正常执行的\",{\"1\":{\"424\":1}}],[\"b的第一个insert语句是可以执行成功\",{\"1\":{\"424\":1}}],[\"b的修改结果\",{\"1\":{\"446\":1}}],[\"b的alter语句被堵住\",{\"1\":{\"425\":1}}],[\"b的两条插入语句应该都要进入锁等待状态\",{\"1\":{\"424\":1}}],[\"b的thread\",{\"1\":{\"413\":1}}],[\"b的临时表t1\",{\"1\":{\"413\":1}}],[\"b的查询语句select\",{\"1\":{\"346\":1}}],[\"b就是不可见的\",{\"1\":{\"410\":1}}],[\"b<=2000\",{\"1\":{\"407\":1}}],[\"b>=1\",{\"1\":{\"407\":1}}],[\"b∈\",{\"1\":{\"407\":1}}],[\"bnl的内存计算也会快得多\",{\"1\":{\"525\":1}}],[\"bnl的执行流程如下\",{\"1\":{\"403\":1}}],[\"bnl转bka\",{\"0\":{\"407\":1}}],[\"bnl算法对系统的影响主要包括三个方面\",{\"1\":{\"406\":1}}],[\"bnl算法的性能问题\",{\"0\":{\"406\":1}}],[\"bnl可能会对被驱动表做多次扫描\",{\"1\":{\"406\":1}}],[\"bka算法的优化要依赖于mrr\",{\"1\":{\"405\":1}}],[\"bka算法并没有默认开启\",{\"1\":{\"405\":1}}],[\"bka\",{\"1\":{\"405\":1}}],[\"baidu\",{\"1\":{\"1972\":1}}],[\"basis\",{\"1\":{\"1620\":2}}],[\"basepackage\",{\"1\":{\"1647\":4}}],[\"basepackages\",{\"1\":{\"1134\":1,\"1136\":5,\"1137\":1,\"1647\":3}}],[\"basestream\",{\"1\":{\"1624\":1}}],[\"basestream<e\",{\"1\":{\"1623\":2}}],[\"basestream<t\",{\"1\":{\"1619\":3}}],[\"basestream定义了所有流\",{\"1\":{\"1619\":1}}],[\"basecount\",{\"1\":{\"1554\":2}}],[\"base基数才会使用到\",{\"1\":{\"1480\":1}}],[\"base变量\",{\"1\":{\"1480\":1}}],[\"base\",{\"1\":{\"1065\":1,\"1480\":3,\"1621\":1,\"1647\":1}}],[\"based\",{\"1\":{\"1615\":1,\"1620\":2,\"1647\":2}}],[\"based实现\",{\"0\":{\"818\":1,\"819\":1,\"820\":1,\"821\":1,\"822\":1,\"823\":1,\"824\":1,\"825\":1,\"826\":1,\"827\":1,\"828\":1}}],[\"based=off\",{\"1\":{\"404\":1,\"405\":1}}],[\"balking\",{\"1\":{\"1531\":1}}],[\"balking是\",{\"1\":{\"1531\":1}}],[\"balking模式和guard\",{\"1\":{\"1531\":1}}],[\"balking模式一种多个线程执行同一操作a时可以考虑的模式\",{\"1\":{\"1531\":1}}],[\"balking模式常用于一个线程发现另一个线程已经做了某一件相同的事\",{\"1\":{\"1531\":1}}],[\"balking模式\",{\"0\":{\"1531\":1}}],[\"balanced\",{\"1\":{\"1620\":3}}],[\"balance\",{\"1\":{\"535\":2,\"1620\":1}}],[\"bar线程不安全\",{\"1\":{\"1526\":1}}],[\"bar\",{\"1\":{\"1526\":2}}],[\"bar的属性foo虽然是final的\",{\"1\":{\"1526\":1}}],[\"barrier等\",{\"1\":{\"1490\":1}}],[\"batch\",{\"1\":{\"646\":1}}],[\"batched\",{\"0\":{\"405\":1},\"1\":{\"405\":1}}],[\"backlink\",{\"1\":{\"1621\":1}}],[\"backlog\",{\"1\":{\"609\":4}}],[\"backed\",{\"1\":{\"1619\":1}}],[\"background\",{\"1\":{\"588\":1}}],[\"back\",{\"1\":{\"574\":6,\"1623\":1}}],[\"bac\",{\"1\":{\"556\":1}}],[\"ba两种连接顺序\",{\"1\":{\"556\":1}}],[\"become\",{\"1\":{\"1623\":2}}],[\"because\",{\"1\":{\"580\":1,\"1614\":1}}],[\"begun\",{\"1\":{\"1620\":1}}],[\"begins\",{\"1\":{\"1621\":1}}],[\"beginning\",{\"1\":{\"580\":1}}],[\"begin或start\",{\"1\":{\"435\":1}}],[\"begin\",{\"1\":{\"400\":1,\"404\":1,\"414\":1,\"419\":1,\"435\":1,\"468\":1,\"485\":1,\"491\":1,\"518\":1,\"523\":2,\"542\":1,\"1297\":1,\"1617\":1,\"1623\":9}}],[\"beyond\",{\"1\":{\"1620\":1}}],[\"bearing\",{\"1\":{\"1619\":1}}],[\"bean注解方法返回的单例对象的问题\",{\"1\":{\"1652\":1}}],[\"bean注册\",{\"1\":{\"1114\":1}}],[\"beanbostprocess\",{\"1\":{\"1651\":1}}],[\"bean对应的beandefinition\",{\"1\":{\"1650\":1}}],[\"bean对象\",{\"1\":{\"974\":1,\"1030\":1,\"1032\":1}}],[\"beanutils\",{\"1\":{\"1648\":1}}],[\"bean替换使用\",{\"1\":{\"1644\":1}}],[\"bean工厂\",{\"1\":{\"1636\":1}}],[\"bean工厂实例化bean\",{\"1\":{\"930\":1}}],[\"beanid\",{\"1\":{\"1242\":1}}],[\"beaninitilzationlifecycledemo\",{\"1\":{\"1006\":1}}],[\"beaninitializationdemo\",{\"1\":{\"931\":2,\"934\":1}}],[\"beaninstance\",{\"1\":{\"1001\":1,\"1647\":8}}],[\"beaninstantiationlifecycledemo\",{\"1\":{\"1000\":1,\"1001\":1,\"1005\":1}}],[\"beaninstantiationexceptiondemo\",{\"1\":{\"946\":1}}],[\"beaninstantiationexception示例\",{\"1\":{\"946\":2}}],[\"beaninstantiationexception\",{\"1\":{\"946\":1}}],[\"beaninstantiationdemo\",{\"1\":{\"930\":1}}],[\"beaninfo\",{\"1\":{\"909\":3,\"1073\":1,\"1075\":5}}],[\"beaninfodemo\",{\"1\":{\"909\":1}}],[\"bean就可以正常使用了\",{\"1\":{\"1234\":1}}],[\"bean创建的前置处理\",{\"1\":{\"1234\":1}}],[\"bean装配管理\",{\"1\":{\"1144\":1}}],[\"bean刷新后\",{\"1\":{\"1126\":1}}],[\"bean类型\",{\"1\":{\"1121\":1}}],[\"bean类全称限定名\",{\"1\":{\"1022\":1}}],[\"bean即可\",{\"1\":{\"1114\":1}}],[\"beanwrapper是spring底层javabeans基础设施的中心化接口\",{\"1\":{\"1079\":1}}],[\"beanwrapper与javabeans之间的关系是\",{\"0\":{\"1079\":1}}],[\"beanwrapperimpl\",{\"1\":{\"1074\":1,\"1093\":1}}],[\"beanwrapper使用场景\",{\"0\":{\"1074\":1}}],[\"beanwrapper\",{\"1\":{\"1073\":1,\"1081\":1,\"1093\":1,\"1647\":2,\"1650\":1}}],[\"bean方法和实例\",{\"1\":{\"1183\":1}}],[\"bean方法\",{\"1\":{\"1183\":2}}],[\"bean方法参数校验\",{\"1\":{\"1065\":1}}],[\"bean方式定义\",{\"1\":{\"929\":1}}],[\"beanvalidation\",{\"1\":{\"1065\":4,\"1068\":1}}],[\"bean错误描述\",{\"1\":{\"1062\":1,\"1068\":1}}],[\"bean和其属性有强关联性\",{\"1\":{\"1062\":1}}],[\"bean和prototype\",{\"1\":{\"985\":1}}],[\"bean构建\",{\"1\":{\"1056\":1}}],[\"bean构造器参数\",{\"1\":{\"927\":1}}],[\"bean范围解析\",{\"1\":{\"1027\":1}}],[\"bean声明周期回调注解\",{\"1\":{\"1023\":1}}],[\"bean条件装配注解\",{\"1\":{\"1023\":1}}],[\"bean依赖注入\",{\"1\":{\"1023\":1,\"1131\":1}}],[\"bean依赖注入注解\",{\"1\":{\"1023\":1}}],[\"beanmetadataelement\",{\"1\":{\"1019\":1}}],[\"beanmetadataconfigurationdemo\",{\"1\":{\"994\":1}}],[\"bean元信息元素\",{\"1\":{\"1019\":1}}],[\"bean配置元信息底层实现\",{\"0\":{\"1024\":1}}],[\"bean配置元信息\",{\"0\":{\"1018\":1,\"1021\":1,\"1022\":1,\"1023\":1},\"1\":{\"1017\":1,\"1021\":1,\"1035\":1}}],[\"beanfacrtory\",{\"1\":{\"1016\":1}}],[\"beanfactroypostprocessor必须有spring\",{\"1\":{\"1016\":1}}],[\"beanfactroypostprocessor是spring\",{\"1\":{\"1016\":1}}],[\"beanfactorytransactionattributesourceadvisor\",{\"1\":{\"1655\":1}}],[\"beanfactory会负责创建bean\",{\"1\":{\"1636\":1}}],[\"beanfactory表示bean工厂\",{\"1\":{\"1636\":1}}],[\"beanfactorypostprocessor只可以拿到beandifinition\",{\"1\":{\"1652\":1}}],[\"beanfactorypostprocessor\",{\"0\":{\"1643\":1},\"1\":{\"1171\":1}}],[\"beanfactorypostprocess与beanpostprocess的区别\",{\"0\":{\"1016\":1}}],[\"beanfactory初始化非延迟单例beans\",{\"1\":{\"1171\":1}}],[\"beanfactory初始化完成阶段\",{\"0\":{\"1171\":1}}],[\"beanfactory冻结配置\",{\"1\":{\"1171\":1}}],[\"beanfactory临时classloader置为null\",{\"1\":{\"1171\":1}}],[\"beanfactory关联conversionservice\",{\"1\":{\"1171\":1}}],[\"beanfactory注册beanpostprocess\",{\"0\":{\"1166\":1}}],[\"beanfactory注册了applicationcontextawareprocessor这个接口\",{\"1\":{\"1005\":1}}],[\"beanfactory后置处理阶段\",{\"0\":{\"1165\":1}}],[\"beanfactory准备阶段\",{\"0\":{\"1164\":1}}],[\"beanfactory创建阶段\",{\"0\":{\"1163\":1}}],[\"beanfactory的类图如下\",{\"1\":{\"1636\":1}}],[\"beanfactory的默认实现为defaultlistablebeanfactory\",{\"1\":{\"1017\":1}}],[\"beanfactory的ioc容器的使用\",{\"1\":{\"921\":1}}],[\"beanfactory无法与其直接交互\",{\"1\":{\"1016\":1}}],[\"beanfactoryaware这三个接口的回调\",{\"1\":{\"1005\":1}}],[\"beanfactoryaware\",{\"1\":{\"951\":1,\"957\":2,\"966\":1,\"1005\":4,\"1234\":1,\"1647\":1,\"1648\":1,\"1651\":1}}],[\"beanfactoryasioccontainerdemo\",{\"1\":{\"921\":1}}],[\"beanfactory则提供了单一类型\",{\"1\":{\"948\":1}}],[\"beanfactoryutils\",{\"1\":{\"942\":2,\"1648\":2}}],[\"beanfactory是如何处理循环依赖的\",{\"0\":{\"1184\":1}}],[\"beanfactory是怎样处理bean生命周期\",{\"0\":{\"1017\":1}}],[\"beanfactory是ioc底层容器\",{\"1\":{\"925\":1}}],[\"beanfactory是一个具有基本功能的框架\",{\"1\":{\"921\":1}}],[\"beanfactory和factorybean\",{\"0\":{\"925\":1}}],[\"beanfactory和applicationcontext谁才是spring\",{\"1\":{\"921\":1}}],[\"beanfactory和applicationcontext\",{\"0\":{\"921\":1}}],[\"beanfactory作为ioc容器示例\",{\"1\":{\"921\":1}}],[\"beanfactory\",{\"0\":{\"949\":1,\"1636\":1},\"1\":{\"917\":29,\"918\":13,\"919\":4,\"921\":13,\"922\":6,\"930\":10,\"936\":3,\"940\":1,\"941\":10,\"944\":6,\"946\":3,\"949\":1,\"953\":3,\"954\":3,\"957\":8,\"973\":16,\"977\":2,\"985\":3,\"989\":2,\"992\":1,\"994\":3,\"995\":5,\"997\":5,\"1000\":5,\"1001\":6,\"1005\":13,\"1006\":6,\"1007\":2,\"1009\":3,\"1011\":10,\"1012\":1,\"1013\":1,\"1019\":5,\"1022\":3,\"1030\":3,\"1032\":3,\"1055\":4,\"1056\":3,\"1121\":5,\"1163\":7,\"1164\":35,\"1165\":8,\"1166\":19,\"1167\":4,\"1168\":5,\"1171\":11,\"1175\":1,\"1636\":1,\"1647\":8,\"1648\":7,\"1651\":13}}],[\"bean垃圾收集\",{\"0\":{\"1013\":1}}],[\"bean垃圾回收\",{\"1\":{\"934\":1,\"1013\":1}}],[\"beanlifecycledemo\",{\"1\":{\"1011\":1}}],[\"bean属性类型实现\",{\"1\":{\"1084\":1}}],[\"bean属性类型转换\",{\"1\":{\"1081\":1,\"1084\":1}}],[\"bean属性错误描述\",{\"1\":{\"1062\":1,\"1068\":1}}],[\"bean属性上下文存储\",{\"1\":{\"1019\":1}}],[\"bean属性元信息\",{\"0\":{\"1019\":1},\"1\":{\"1017\":1,\"1019\":1}}],[\"bean属性赋值阶段\",{\"1\":{\"1017\":1}}],[\"bean属性赋值前阶段\",{\"1\":{\"1017\":1}}],[\"bean属性赋值前回调\",{\"1\":{\"1003\":1}}],[\"bean属性值信息的类\",{\"1\":{\"1003\":1}}],[\"bean属性设置\",{\"1\":{\"927\":1}}],[\"bean覆盖\",{\"1\":{\"1000\":1,\"1001\":1,\"1002\":1}}],[\"bean覆盖的finalize\",{\"1\":{\"934\":1,\"1013\":1}}],[\"bean没有本质区别\",{\"1\":{\"993\":1}}],[\"bean与\",{\"1\":{\"993\":1}}],[\"bean是否被其他方案他替代\",{\"0\":{\"993\":1}}],[\"bean是否在一个应用中是唯一的\",{\"0\":{\"992\":1}}],[\"bean仅在当前spring\",{\"1\":{\"992\":1}}],[\"bean有别于其他地方的依赖注入\",{\"1\":{\"985\":1}}],[\"bean均会存在一个\",{\"1\":{\"985\":1}}],[\"bean无论依赖查找还是依赖注入均为新生成的对象\",{\"1\":{\"985\":1}}],[\"bean无论依赖查找还是依赖注入均为同一个对象\",{\"1\":{\"985\":1}}],[\"bean存储在servletcontext中\",{\"1\":{\"983\":1,\"1235\":1}}],[\"bean存储在servletrequest上下文中\",{\"1\":{\"983\":1,\"1235\":1}}],[\"bean存储在httpsession中\",{\"1\":{\"983\":1,\"1235\":1}}],[\"bean作用域\",{\"1\":{\"983\":1,\"1235\":1}}],[\"bean生命周期顺序按照注册顺序\",{\"1\":{\"975\":1}}],[\"beantype\",{\"1\":{\"964\":2,\"973\":3,\"1647\":5,\"1648\":2}}],[\"beannumbers\",{\"1\":{\"994\":2,\"997\":2,\"1000\":2,\"1001\":2,\"1005\":2,\"1006\":2,\"1011\":2}}],[\"beannotofrequiredtypeexception\",{\"1\":{\"963\":1,\"1648\":1}}],[\"beannameviewresolver\",{\"1\":{\"1657\":1}}],[\"beannameurlhandlermapping\",{\"1\":{\"1657\":1}}],[\"beannames\",{\"1\":{\"1647\":3}}],[\"beannamesfortypeincludingancestors\",{\"1\":{\"942\":1,\"1648\":1}}],[\"beanname=\",{\"1\":{\"1005\":1}}],[\"beannameaware\",{\"1\":{\"957\":1,\"985\":1,\"1005\":4,\"1234\":1,\"1651\":1}}],[\"beanname\",{\"1\":{\"928\":6,\"929\":4,\"963\":11,\"964\":10,\"975\":2,\"985\":8,\"988\":1,\"996\":17,\"997\":10,\"1000\":5,\"1001\":3,\"1002\":4,\"1003\":5,\"1005\":5,\"1006\":4,\"1007\":3,\"1008\":9,\"1011\":2,\"1019\":3,\"1027\":2,\"1647\":95,\"1648\":29,\"1649\":3,\"1650\":11}}],[\"beannamegenerator\",{\"1\":{\"928\":1,\"1027\":1,\"1647\":1}}],[\"bean3\",{\"1\":{\"946\":2}}],[\"bean2\",{\"1\":{\"946\":2}}],[\"bean1\",{\"1\":{\"946\":2}}],[\"bean初始化完成阶段\",{\"1\":{\"1017\":1}}],[\"bean初始化后阶段\",{\"1\":{\"1017\":1}}],[\"bean初始化阶段\",{\"1\":{\"1017\":1}}],[\"bean初始化前阶段\",{\"1\":{\"1017\":1}}],[\"bean初始化前和初始化后的生命周期回调\",{\"1\":{\"1015\":1}}],[\"bean初始化方法执行异常时\",{\"1\":{\"946\":1}}],[\"bean初始化回调方法名称\",{\"1\":{\"927\":1}}],[\"bean处理器\",{\"1\":{\"945\":1}}],[\"bean名称依赖查找\",{\"1\":{\"1149\":1}}],[\"bean名称生成来自于beannamegenerator\",{\"1\":{\"995\":1}}],[\"bean名称生成器\",{\"1\":{\"928\":1}}],[\"bean名称\",{\"1\":{\"945\":2,\"985\":1,\"1121\":1}}],[\"beanoftypeincludingancestors\",{\"1\":{\"942\":1}}],[\"beanoftype\",{\"1\":{\"942\":1}}],[\"beanporcess的后处理的方法\",{\"1\":{\"1234\":1}}],[\"beanpostprocess提供了spring\",{\"1\":{\"1015\":1}}],[\"beanpostprocess使用场景有哪些\",{\"0\":{\"1015\":1}}],[\"beanpostprocess\",{\"1\":{\"922\":2,\"1234\":1,\"1647\":2,\"1651\":2}}],[\"beanpostprocessors\",{\"1\":{\"1166\":6,\"1647\":1}}],[\"beanpostprocessorchecker\",{\"1\":{\"1166\":2}}],[\"beanpostprocessor\",{\"0\":{\"1642\":1},\"1\":{\"899\":1,\"967\":9,\"985\":1,\"1006\":2,\"1008\":1,\"1019\":1,\"1166\":8,\"1647\":1}}],[\"beanprocessortargetcount\",{\"1\":{\"1166\":2}}],[\"beanpropertybindingresult关联beanwrapper\",{\"1\":{\"1076\":1}}],[\"beanpropertybindingresult\",{\"1\":{\"1063\":3,\"1064\":1}}],[\"beanprovider\",{\"1\":{\"940\":2,\"943\":5}}],[\"beanpublic\",{\"1\":{\"972\":1,\"973\":1}}],[\"bean延迟依赖查找接口\",{\"1\":{\"943\":1}}],[\"bean延迟查找\",{\"1\":{\"940\":1}}],[\"bean延迟初始化\",{\"1\":{\"932\":1}}],[\"bean延迟初始化模式\",{\"1\":{\"927\":1}}],[\"bean实例\",{\"1\":{\"945\":1}}],[\"bean实例化阶段\",{\"1\":{\"1017\":1}}],[\"bean实例化前阶段\",{\"1\":{\"1017\":1}}],[\"bean实例化后阶段\",{\"0\":{\"1002\":1},\"1\":{\"1002\":1,\"1017\":1}}],[\"bean实例化示例\",{\"1\":{\"930\":1}}],[\"bean实例化\",{\"1\":{\"930\":1}}],[\"bean实时查找\",{\"1\":{\"940\":1}}],[\"beangarbagecollectiondemo\",{\"1\":{\"934\":1}}],[\"beandescriptor\",{\"1\":{\"1075\":1}}],[\"beandestorydemo\",{\"1\":{\"933\":2}}],[\"beandefition中存在很多属性用来描述一个bean的特点\",{\"1\":{\"1632\":1}}],[\"beandefinition表示bean的元信息定义\",{\"1\":{\"1632\":1}}],[\"beandefinition对象保存\",{\"1\":{\"1234\":1}}],[\"beandefinition到bean实例创建\",{\"1\":{\"1069\":1}}],[\"beandefinitionholder\",{\"1\":{\"1027\":2,\"1647\":2}}],[\"beandefinition处理\",{\"1\":{\"1027\":1}}],[\"beandefinition解析\",{\"1\":{\"1026\":1,\"1027\":1}}],[\"beandefinition解析与注册的方式\",{\"1\":{\"1024\":1}}],[\"beandefinition名称\",{\"1\":{\"1022\":1}}],[\"beandefinitiondocumentreader>\",{\"1\":{\"1025\":1}}],[\"beandefinitiondocumentreader有且仅有一个实现\",{\"1\":{\"1025\":1}}],[\"beandefinitiondocumentreader\",{\"1\":{\"1021\":1,\"1025\":1}}],[\"beandefinition主要包括了\",{\"1\":{\"1018\":1}}],[\"beandefinition合并\",{\"1\":{\"997\":1}}],[\"beandefinition合并阶段\",{\"0\":{\"997\":1},\"1\":{\"1017\":1}}],[\"beandefinitionoverrideexception\",{\"1\":{\"996\":1}}],[\"beandefinitionvalidationexception\",{\"1\":{\"996\":1,\"1647\":2}}],[\"beandefinitioncustomizer\",{\"1\":{\"1027\":2}}],[\"beandefinitioncount\",{\"1\":{\"995\":2}}],[\"beandefinitioncountafter\",{\"1\":{\"995\":2}}],[\"beandefinitioncountbefore\",{\"1\":{\"995\":2}}],[\"beandefinitioncreationdemo\",{\"1\":{\"927\":1}}],[\"beandefinitionparserdelegate\",{\"1\":{\"1025\":1}}],[\"beandefinitionparser\",{\"1\":{\"995\":1}}],[\"beandefinition的autowirecandidate属性\",{\"1\":{\"1648\":1}}],[\"beandefinition的典型实现\",{\"1\":{\"1632\":1}}],[\"beandefinition的配置方式\",{\"1\":{\"994\":1}}],[\"beandefinition的构建方式\",{\"1\":{\"927\":1}}],[\"beandefinition会被configurablelistablebeanfactory\",{\"1\":{\"981\":1}}],[\"beandefinition以及单例对象\",{\"1\":{\"980\":1}}],[\"beandefinitionnames\",{\"1\":{\"975\":2,\"996\":4,\"1647\":1}}],[\"beandefinitionmap\",{\"1\":{\"975\":2,\"996\":5}}],[\"beandefinition>\",{\"1\":{\"975\":1,\"996\":1}}],[\"beandefinition作为依赖来源\",{\"0\":{\"975\":1}}],[\"beandefinition是关于bean定义的元信息的接口\",{\"1\":{\"937\":1}}],[\"beandefinitionresource\",{\"1\":{\"1039\":1}}],[\"beandefinitionreader\",{\"1\":{\"953\":6,\"954\":2,\"955\":2,\"961\":6,\"962\":2,\"963\":2,\"995\":3,\"1022\":2}}],[\"beandefinitionreaderutils\",{\"1\":{\"929\":2,\"1027\":1,\"1138\":1}}],[\"beandefinitionregistrypostprocessor可以向beanfactory中注册beandefinition\",{\"1\":{\"1652\":1}}],[\"beandefinitionregistrypostprocessor与beanfactorypostprocessor的区别在于\",{\"1\":{\"1652\":1}}],[\"beandefinitionregistry有且仅有一个实现\",{\"1\":{\"975\":1}}],[\"beandefinitionregistry\",{\"1\":{\"928\":3,\"929\":3,\"975\":1,\"996\":1,\"1025\":1,\"1026\":1,\"1027\":1,\"1138\":1,\"1636\":1}}],[\"beandefinition注册\",{\"1\":{\"1025\":1,\"1026\":1,\"1027\":1}}],[\"beandefinition注册阶段\",{\"1\":{\"1017\":1}}],[\"beandefinition注册的核心接口\",{\"1\":{\"996\":1}}],[\"beandefinition注册的不同方式\",{\"1\":{\"929\":1}}],[\"beandefinition注册到ioc容器\",{\"0\":{\"929\":1}}],[\"beandefinition并非bean的终态\",{\"1\":{\"927\":1}}],[\"beandefinitionbuilder\",{\"1\":{\"927\":6,\"929\":6,\"946\":8,\"953\":5,\"954\":5,\"972\":1,\"973\":1,\"1019\":5,\"1030\":2,\"1174\":1,\"1632\":1}}],[\"beandefinition构建示例\",{\"1\":{\"927\":1}}],[\"beandefinition元信息\",{\"1\":{\"927\":1}}],[\"beandefinition时spring\",{\"1\":{\"927\":1}}],[\"beandefinitionstoreexception\",{\"1\":{\"928\":2,\"946\":1,\"996\":2,\"997\":2,\"1021\":1,\"1022\":2,\"1647\":5}}],[\"beandefinitions\",{\"1\":{\"921\":2,\"1647\":3}}],[\"beandefinition\",{\"0\":{\"927\":1,\"937\":1,\"1632\":1},\"1\":{\"899\":1,\"927\":1,\"928\":3,\"929\":1,\"930\":1,\"953\":3,\"954\":2,\"963\":1,\"964\":2,\"972\":1,\"973\":1,\"974\":1,\"975\":2,\"982\":1,\"985\":3,\"995\":1,\"996\":17,\"997\":4,\"1017\":1,\"1019\":6,\"1021\":2,\"1022\":1,\"1025\":1,\"1071\":1,\"1093\":1,\"1138\":2,\"1632\":3,\"1647\":6,\"1648\":3}}],[\"beandefs\",{\"1\":{\"967\":1}}],[\"bean销毁的逻辑\",{\"1\":{\"1647\":1}}],[\"bean销毁阶段\",{\"1\":{\"1017\":1}}],[\"bean销毁前阶段\",{\"1\":{\"1017\":1}}],[\"bean销毁并不意味这bean垃圾回收了\",{\"1\":{\"1011\":1}}],[\"bean销毁\",{\"1\":{\"933\":1,\"1012\":1}}],[\"bean销毁回调方法名称\",{\"1\":{\"927\":1}}],[\"bean别名\",{\"1\":{\"928\":1}}],[\"beancreation\",{\"1\":{\"1647\":5}}],[\"beancreationexceptiondemo\",{\"1\":{\"946\":1}}],[\"beancreationexception示例\",{\"1\":{\"946\":2}}],[\"beancreationexception\",{\"1\":{\"946\":1,\"964\":2,\"1008\":1,\"1647\":14,\"1648\":2,\"1650\":1}}],[\"beancurrentlyincreationexception\",{\"1\":{\"1647\":2}}],[\"beancachingdemo\",{\"1\":{\"1182\":7}}],[\"beanconfigurationmetadatademo\",{\"1\":{\"1019\":3}}],[\"beancontext\",{\"1\":{\"906\":1,\"939\":6}}],[\"beanclass\",{\"1\":{\"998\":2,\"1000\":4,\"1001\":2,\"1002\":2,\"1027\":2,\"1650\":5}}],[\"beanclassloaderaware\",{\"1\":{\"957\":1,\"1005\":5,\"1234\":1,\"1651\":1}}],[\"beanclassname\",{\"1\":{\"928\":3,\"995\":3}}],[\"bean命名\",{\"0\":{\"928\":1}}],[\"bean自动绑定模式\",{\"1\":{\"927\":1}}],[\"bean的方式代理对象\",{\"1\":{\"1654\":1}}],[\"bean的方法解析出相应的beandefinition\",{\"1\":{\"1183\":1}}],[\"bean的方法\",{\"1\":{\"1183\":1}}],[\"bean的会覆盖掉\",{\"1\":{\"1652\":1}}],[\"bean的也是配置类\",{\"1\":{\"1652\":1}}],[\"bean的生命周期\",{\"0\":{\"1647\":1}}],[\"bean的生命周期底层原理\",{\"1\":{\"1630\":1}}],[\"bean的处理流程是怎样的\",{\"0\":{\"1183\":1}}],[\"bean的属性\",{\"1\":{\"1074\":1}}],[\"bean的校验\",{\"0\":{\"1069\":1}}],[\"bean的配置元信息\",{\"1\":{\"1018\":1}}],[\"bean的实例化主要有两种类型\",{\"1\":{\"1001\":1}}],[\"bean的完整生命周期\",{\"1\":{\"985\":1}}],[\"bean的初始化\",{\"1\":{\"931\":1}}],[\"bean的factorybean的实现\",{\"1\":{\"930\":1}}],[\"bean的名称\",{\"1\":{\"1648\":1}}],[\"bean的名称为scopedtarget\",{\"1\":{\"988\":1}}],[\"bean的名称尽管没有限制\",{\"1\":{\"928\":1}}],[\"bean的名称或者id\",{\"1\":{\"927\":1}}],[\"bean的id或name属性并非必须制定\",{\"1\":{\"928\":1}}],[\"bean的作用域示例\",{\"1\":{\"985\":1}}],[\"bean的作用域\",{\"1\":{\"927\":1}}],[\"bean的类名\",{\"1\":{\"927\":1}}],[\"bean全类名\",{\"1\":{\"927\":1}}],[\"bean行为配置元素\",{\"1\":{\"927\":1}}],[\"bean定义\",{\"1\":{\"1021\":2,\"1039\":1}}],[\"bean定义加载的数量\",{\"1\":{\"921\":1}}],[\"bean定义配置\",{\"1\":{\"920\":1}}],[\"bean=\",{\"1\":{\"918\":2,\"930\":1}}],[\"bean>\",{\"1\":{\"917\":3,\"918\":1,\"930\":1,\"953\":2,\"954\":1,\"989\":1,\"1003\":1,\"1012\":1,\"1032\":1,\"1065\":1,\"1084\":1,\"1091\":2,\"1146\":3}}],[\"bean相关\",{\"1\":{\"903\":1}}],[\"beans事件和java\",{\"1\":{\"1085\":1}}],[\"beans核心实现\",{\"1\":{\"1073\":1}}],[\"beans替换实现\",{\"0\":{\"1073\":1}}],[\"beans配置\",{\"1\":{\"1021\":1}}],[\"beans作为jmx\",{\"1\":{\"1020\":1}}],[\"beans指的是在xml文件中通过import导入资源的方法注册bean\",{\"1\":{\"1020\":1}}],[\"beans元素属性\",{\"1\":{\"1020\":1}}],[\"beans元素相关\",{\"1\":{\"1020\":1}}],[\"beanscopedemo\",{\"1\":{\"985\":19}}],[\"beans的api\",{\"1\":{\"928\":1}}],[\"beansexception子类型\",{\"1\":{\"946\":1}}],[\"beansexception\",{\"1\":{\"922\":2,\"944\":1,\"957\":2,\"963\":2,\"985\":1,\"997\":1,\"1000\":1,\"1001\":1,\"1002\":2,\"1003\":3,\"1005\":1,\"1006\":2,\"1008\":1,\"1011\":1,\"1019\":1,\"1148\":1,\"1163\":1,\"1647\":6,\"1648\":3,\"1651\":3}}],[\"beans>\",{\"1\":{\"917\":1,\"918\":1,\"930\":2,\"953\":2,\"954\":2,\"1030\":1,\"1032\":1,\"1065\":1,\"1084\":1,\"1091\":1,\"1146\":1}}],[\"beans呢\",{\"1\":{\"909\":1}}],[\"beans或其他资源\",{\"1\":{\"907\":2}}],[\"beans\",{\"1\":{\"903\":1,\"908\":2,\"909\":7,\"917\":5,\"918\":4,\"922\":5,\"930\":9,\"939\":3,\"943\":2,\"952\":1,\"953\":8,\"954\":8,\"957\":1,\"961\":3,\"962\":1,\"963\":2,\"989\":3,\"1020\":7,\"1021\":1,\"1028\":6,\"1030\":2,\"1032\":8,\"1039\":1,\"1065\":4,\"1073\":4,\"1074\":1,\"1075\":6,\"1080\":1,\"1083\":7,\"1084\":8,\"1085\":3,\"1091\":4,\"1093\":12,\"1109\":2,\"1146\":7,\"1150\":1,\"1152\":5,\"1164\":2,\"1166\":5,\"1170\":2,\"1171\":1,\"1172\":1,\"1173\":2,\"1174\":2,\"1175\":5,\"1182\":1,\"1632\":4,\"1647\":10,\"1648\":2,\"1651\":2}}],[\"bean\",{\"0\":{\"934\":1,\"936\":1,\"998\":1,\"1056\":1,\"1065\":1},\"1\":{\"583\":1,\"891\":1,\"921\":1,\"922\":5,\"928\":10,\"929\":3,\"930\":7,\"931\":2,\"933\":2,\"940\":1,\"943\":2,\"946\":4,\"952\":2,\"953\":1,\"954\":1,\"955\":2,\"956\":2,\"961\":10,\"963\":2,\"964\":8,\"967\":5,\"973\":1,\"975\":3,\"985\":11,\"989\":1,\"995\":1,\"996\":9,\"997\":12,\"1000\":3,\"1001\":1,\"1002\":3,\"1003\":5,\"1005\":26,\"1006\":4,\"1007\":7,\"1008\":7,\"1009\":1,\"1011\":4,\"1012\":1,\"1017\":1,\"1019\":3,\"1021\":1,\"1022\":3,\"1029\":1,\"1030\":2,\"1031\":2,\"1032\":1,\"1040\":1,\"1041\":1,\"1043\":1,\"1049\":1,\"1055\":6,\"1056\":6,\"1064\":2,\"1065\":2,\"1068\":1,\"1075\":5,\"1084\":3,\"1091\":1,\"1093\":1,\"1121\":5,\"1123\":2,\"1134\":2,\"1138\":3,\"1139\":2,\"1149\":2,\"1163\":1,\"1164\":12,\"1165\":2,\"1166\":2,\"1167\":5,\"1168\":5,\"1171\":7,\"1174\":1,\"1181\":1,\"1182\":2,\"1184\":2,\"1638\":1,\"1639\":1,\"1647\":60,\"1648\":7,\"1649\":1,\"1650\":3,\"1651\":2,\"1654\":2}}],[\"below\",{\"1\":{\"1615\":1}}],[\"better\",{\"1\":{\"1615\":2,\"1618\":1}}],[\"between\",{\"1\":{\"330\":1,\"336\":1,\"338\":1,\"346\":4,\"347\":2,\"348\":2,\"1166\":1,\"1620\":2,\"1621\":1,\"1647\":1}}],[\"beijing\",{\"1\":{\"1605\":1,\"1611\":3}}],[\"being\",{\"1\":{\"997\":1,\"1617\":1,\"1619\":2,\"1620\":1,\"1647\":1}}],[\"behaviour\",{\"1\":{\"1620\":1}}],[\"behavioral\",{\"1\":{\"1619\":1}}],[\"behavior\",{\"1\":{\"1619\":3,\"1620\":5,\"1622\":1}}],[\"behaves\",{\"1\":{\"1595\":1}}],[\"behind\",{\"1\":{\"457\":5,\"458\":4,\"459\":1,\"472\":3}}],[\"been\",{\"1\":{\"1432\":1,\"1595\":2,\"1610\":1,\"1615\":1,\"1619\":1,\"1620\":4,\"1622\":1,\"1623\":1,\"1647\":3}}],[\"benefit\",{\"1\":{\"1620\":1,\"1622\":1}}],[\"benchmark进行压测的时候可以发现影响redis的qps峰值的一个重要因素是pipeline批次指令的数目\",{\"1\":{\"1298\":1}}],[\"bena实例化前阶段\",{\"1\":{\"1000\":1}}],[\"bena实例\",{\"1\":{\"945\":1}}],[\"bena垃圾回收的示例\",{\"1\":{\"934\":1}}],[\"beforeinstantiationresolved\",{\"1\":{\"1647\":2}}],[\"beforeprototypecreation\",{\"1\":{\"1647\":2}}],[\"before规则可以解决有序性的问题\",{\"1\":{\"1373\":1}}],[\"before\",{\"0\":{\"789\":1,\"790\":1,\"822\":1},\"1\":{\"571\":2,\"963\":1,\"997\":1,\"1171\":1,\"1598\":18,\"1618\":2,\"1620\":4,\"1621\":2,\"1623\":5,\"1630\":1,\"1647\":3,\"1654\":6}}],[\"best\",{\"1\":{\"519\":2,\"1620\":3}}],[\"be\",{\"1\":{\"429\":1,\"487\":1,\"519\":1,\"963\":1,\"996\":2,\"997\":4,\"1055\":1,\"1061\":1,\"1162\":1,\"1167\":1,\"1594\":4,\"1595\":1,\"1597\":1,\"1599\":10,\"1600\":2,\"1608\":6,\"1609\":2,\"1615\":12,\"1617\":5,\"1618\":3,\"1619\":13,\"1620\":30,\"1621\":6,\"1622\":1,\"1623\":6,\"1647\":9,\"1648\":1}}],[\"b5\",{\"1\":{\"378\":1}}],[\"b4\",{\"1\":{\"378\":1}}],[\"b3\",{\"1\":{\"378\":1}}],[\"b22\",{\"1\":{\"378\":1}}],[\"b1bc7ed\",{\"1\":{\"1613\":1}}],[\"b1\",{\"1\":{\"378\":1}}],[\"b本身是索引\",{\"1\":{\"348\":1}}],[\"b原来的查询语句执行情况对比\",{\"1\":{\"346\":1}}],[\"b原来的查询\",{\"1\":{\"346\":1}}],[\"b两个字段\",{\"1\":{\"346\":1}}],[\"b各自的查询呢\",{\"1\":{\"339\":1}}],[\"bbb\",{\"1\":{\"1486\":1,\"1487\":1,\"1619\":7}}],[\"bb\",{\"1\":{\"336\":1}}],[\"built\",{\"1\":{\"1621\":1}}],[\"buildautowiringmetadata\",{\"1\":{\"1648\":1}}],[\"build\",{\"1\":{\"1619\":2}}],[\"builder模式\",{\"1\":{\"1107\":1}}],[\"builder\",{\"1\":{\"1030\":6}}],[\"builderexception\",{\"1\":{\"645\":1}}],[\"builddefaultbeanname\",{\"1\":{\"928\":2,\"995\":1}}],[\"busyspinwaitstrategy策略\",{\"1\":{\"1520\":1}}],[\"button\",{\"1\":{\"1591\":5}}],[\"but\",{\"1\":{\"1480\":1,\"1615\":1,\"1619\":1,\"1620\":2,\"1647\":1,\"1648\":1}}],[\"bundies\",{\"1\":{\"899\":1}}],[\"buffer通过网卡传输给客户端\",{\"1\":{\"1582\":1}}],[\"buffer直接拷贝到socket\",{\"1\":{\"1582\":1}}],[\"buffer用于和nio通道进行交互\",{\"1\":{\"1574\":1}}],[\"buffer用的是buffer\",{\"1\":{\"343\":1}}],[\"bufferedreader\",{\"1\":{\"1573\":4}}],[\"buffer对成本的影响\",{\"1\":{\"555\":1}}],[\"bufferpool缓存机制\",{\"0\":{\"543\":1}}],[\"buffer一次只能放800行数据\",{\"1\":{\"525\":1}}],[\"buffer则表示使用的join算法是nlj\",{\"1\":{\"524\":1}}],[\"buffer配置的比较小并且没有条件继续增加了\",{\"1\":{\"520\":1}}],[\"buffer内存排序\",{\"1\":{\"520\":1}}],[\"buffer以后\",{\"1\":{\"451\":1}}],[\"buffer里放800行记录\",{\"1\":{\"525\":1}}],[\"buffer里的数据是无序的\",{\"1\":{\"525\":1}}],[\"buffer里的日志全部持久化到磁盘\",{\"1\":{\"451\":1}}],[\"buffer里面维护的是一个无序数组\",{\"1\":{\"408\":1}}],[\"buffer里面要放的字段数太多\",{\"1\":{\"355\":1}}],[\"buffer里面的操作日志\",{\"1\":{\"345\":1}}],[\"buffer持久化到磁盘\",{\"1\":{\"451\":1}}],[\"buffer占用的空间即将达到innodb\",{\"1\":{\"451\":1}}],[\"buffer是很快的\",{\"1\":{\"451\":1}}],[\"buffer是有序数组\",{\"1\":{\"418\":1}}],[\"buffer是无序数组\",{\"1\":{\"418\":1}}],[\"buffer是以无序数组的方式组织的\",{\"1\":{\"403\":1}}],[\"buffer放不下\",{\"1\":{\"405\":1}}],[\"buffer放满了\",{\"1\":{\"404\":1}}],[\"buffer优化的nlj算法就是bka算法\",{\"1\":{\"405\":1}}],[\"buffer参数控制的\",{\"1\":{\"404\":1}}],[\"buffer复用\",{\"1\":{\"403\":1}}],[\"buffer满了\",{\"1\":{\"403\":1}}],[\"buffer和channel都是可读可写的\",{\"1\":{\"1422\":1}}],[\"buffer和临时表中执行的\",{\"1\":{\"355\":1}}],[\"buffer和redo\",{\"0\":{\"345\":1},\"1\":{\"345\":1}}],[\"buffer主要节省的则是随机读磁盘的io消耗\",{\"1\":{\"345\":1}}],[\"buffer区域\",{\"1\":{\"345\":1}}],[\"buffer都能提升更新性能\",{\"1\":{\"344\":1}}],[\"buffer都可以起到加速的作用吗\",{\"1\":{\"344\":1}}],[\"buffer反而起到了副作用\",{\"1\":{\"344\":1}}],[\"buffer只限于用在普通索引的场景下\",{\"1\":{\"344\":1}}],[\"buffer详解\",{\"0\":{\"344\":1}}],[\"buffer因为减少了随机磁盘访问\",{\"1\":{\"343\":1}}],[\"buffer的操作会导致其他cache中的副本失效\",{\"1\":{\"1473\":1}}],[\"buffer的内存不够用\",{\"1\":{\"418\":1}}],[\"buffer的字段m做排序\",{\"1\":{\"418\":1}}],[\"buffer的字段\",{\"1\":{\"355\":1}}],[\"buffer的更新状态图\",{\"1\":{\"345\":1}}],[\"buffer的维护代价\",{\"1\":{\"344\":1}}],[\"buffer的使用效果最好\",{\"1\":{\"344\":1}}],[\"buffer的记录变更越多\",{\"1\":{\"344\":1}}],[\"buffer的主要目的就是将记录的变更动作缓存下来\",{\"1\":{\"344\":1}}],[\"buffer的机制\",{\"1\":{\"343\":1}}],[\"buffer的大小是由read\",{\"1\":{\"404\":1}}],[\"buffer的大小是由参数join\",{\"1\":{\"403\":1,\"525\":1}}],[\"buffer的大小最多只能占用buffer\",{\"1\":{\"343\":1}}],[\"buffer的大小\",{\"1\":{\"343\":1}}],[\"buffer了\",{\"1\":{\"343\":1}}],[\"buffer呢\",{\"1\":{\"343\":1}}],[\"buffer在内存中有拷贝\",{\"1\":{\"343\":1}}],[\"buffer中数据对比\",{\"1\":{\"525\":1}}],[\"buffer中一次排序更多的行\",{\"1\":{\"520\":1}}],[\"buffer中进行排序\",{\"1\":{\"520\":3}}],[\"buffer中根据r的值进行排序\",{\"1\":{\"420\":1}}],[\"buffer中有两个字段\",{\"1\":{\"420\":1}}],[\"buffer中放入的数据是r1~r100\",{\"1\":{\"405\":1}}],[\"buffer中按照id做了排序\",{\"1\":{\"404\":1}}],[\"buffer中依次取出id\",{\"1\":{\"355\":1}}],[\"buffer中的内容写入内存\",{\"1\":{\"1473\":1}}],[\"buffer中的字段position和主键id按照字段position进行排序\",{\"1\":{\"520\":1}}],[\"buffer中的\",{\"1\":{\"451\":1}}],[\"buffer中的日志一起持久化到磁盘\",{\"1\":{\"451\":1}}],[\"buffer中的日志\",{\"1\":{\"451\":1}}],[\"buffer中的部分日志有没有可能被持久化到磁盘呢\",{\"1\":{\"451\":1}}],[\"buffer中的两个字段里\",{\"1\":{\"420\":1}}],[\"buffer中的id进行递增排序\",{\"1\":{\"404\":1}}],[\"buffer中的数据对比得到部分结果\",{\"1\":{\"525\":1}}],[\"buffer中的数据按照字段position排序\",{\"1\":{\"520\":1}}],[\"buffer中的数据按照字段name进行排序\",{\"1\":{\"355\":1}}],[\"buffer中的数据按照字段name做快速排序\",{\"1\":{\"354\":1}}],[\"buffer中的数据进行对比\",{\"1\":{\"407\":1}}],[\"buffer中的数据做对比\",{\"1\":{\"403\":2,\"525\":1}}],[\"buffer中的操作应用到原数据页\",{\"1\":{\"343\":1}}],[\"buffer中与这个页有关的操作\",{\"1\":{\"343\":1}}],[\"buffer中\",{\"1\":{\"343\":1,\"354\":1,\"356\":1,\"403\":5,\"404\":1,\"407\":1,\"418\":1,\"451\":3,\"520\":4,\"525\":1}}],[\"buffer\",{\"0\":{\"687\":1},\"1\":{\"330\":1,\"343\":6,\"344\":2,\"345\":1,\"354\":8,\"355\":2,\"364\":1,\"403\":8,\"404\":1,\"405\":1,\"407\":1,\"418\":1,\"420\":1,\"421\":3,\"451\":2,\"520\":2,\"525\":1,\"1422\":1,\"1486\":2,\"1574\":1,\"1575\":4,\"1576\":2,\"1582\":2,\"1668\":1}}],[\"bulk\",{\"1\":{\"307\":7,\"1620\":3}}],[\"bilibili\",{\"1\":{\"1969\":1,\"1974\":1,\"1975\":1,\"1978\":1,\"1980\":1,\"1981\":1,\"1982\":1,\"1983\":1,\"1985\":2,\"1986\":1,\"1987\":2,\"1989\":1,\"1990\":1,\"1991\":1,\"1992\":2}}],[\"biconsumer\",{\"1\":{\"1615\":1}}],[\"biconsumer<partition<a>\",{\"1\":{\"1618\":1}}],[\"biconsumer<map<k\",{\"1\":{\"1618\":1}}],[\"biconsumer<i\",{\"1\":{\"1617\":1}}],[\"biconsumer<set<t>\",{\"1\":{\"1617\":4}}],[\"biconsumer<a\",{\"1\":{\"1615\":1,\"1616\":4,\"1617\":1,\"1618\":3}}],[\"biconsumer<t\",{\"1\":{\"1608\":1}}],[\"biconsumer<r\",{\"1\":{\"1608\":4}}],[\"bifunction\",{\"1\":{\"1598\":6,\"1601\":4}}],[\"bifunction<integer\",{\"1\":{\"1598\":3}}],[\"bifunction<t\",{\"1\":{\"1598\":3,\"1601\":3}}],[\"bifunctiontest\",{\"1\":{\"1598\":14}}],[\"bifunction这个函数式接口的定义\",{\"1\":{\"1598\":1}}],[\"bi实际上是bidirectional的缩写\",{\"1\":{\"1598\":1}}],[\"biasedlockingdecaytime=25000ms范围内没有达到40次\",{\"1\":{\"1485\":1}}],[\"biasedlockingbulkrevokethreshold来手动设置阈值\",{\"1\":{\"1485\":1}}],[\"biasedlockingbulkrevokethreshold\",{\"1\":{\"1485\":1}}],[\"biasedlockingbulkrebiasthreshold和xx\",{\"1\":{\"1485\":1}}],[\"biasedlockingbulkrebiasthreshold\",{\"1\":{\"1485\":1}}],[\"biasedlockingstartupdelay=0\",{\"1\":{\"1485\":1}}],[\"biased\",{\"1\":{\"1484\":1}}],[\"bioexampleserverhandle\",{\"1\":{\"1573\":3}}],[\"bio\",{\"0\":{\"1573\":1},\"1\":{\"1576\":1}}],[\"bio模式\",{\"1\":{\"1421\":1}}],[\"bios\",{\"0\":{\"283\":1}}],[\"bitpos\",{\"1\":{\"578\":1}}],[\"bitop\",{\"1\":{\"578\":1}}],[\"bitcount\",{\"1\":{\"578\":3}}],[\"bitmap\",{\"1\":{\"1280\":1}}],[\"bitmap是一串连续的2进制数字\",{\"1\":{\"578\":1}}],[\"bitmaps\",{\"0\":{\"578\":1}}],[\"bit为true\",{\"1\":{\"542\":1}}],[\"bit为true的记录\",{\"1\":{\"542\":1}}],[\"bitenum\",{\"1\":{\"528\":1}}],[\"bits\",{\"1\":{\"519\":2}}],[\"bit\",{\"1\":{\"519\":1,\"542\":2,\"578\":1,\"1620\":1}}],[\"bincount\",{\"1\":{\"1549\":2,\"1554\":9}}],[\"binds\",{\"1\":{\"1620\":4}}],[\"bind方法生成beanpropertybindingresult\",{\"1\":{\"1076\":1}}],[\"bind\",{\"1\":{\"1070\":4,\"1072\":2,\"1215\":1,\"1226\":1,\"1533\":1,\"1534\":1,\"1574\":1,\"1575\":1}}],[\"binding这样一些特性\",{\"1\":{\"1621\":1}}],[\"bindingresult\",{\"1\":{\"1070\":1,\"1072\":1}}],[\"binding\",{\"1\":{\"892\":1,\"1620\":17,\"1621\":1}}],[\"binaryoperator是因为合并的是两个部分的结果容器的类型\",{\"1\":{\"1615\":1}}],[\"binaryoperator<partition<a>>\",{\"1\":{\"1618\":1}}],[\"binaryoperator<map<k\",{\"1\":{\"1618\":1}}],[\"binaryoperator<u>\",{\"1\":{\"1618\":1}}],[\"binaryoperator<i>\",{\"1\":{\"1617\":1}}],[\"binaryoperator<set<t>>\",{\"1\":{\"1617\":2}}],[\"binaryoperator<a>\",{\"1\":{\"1615\":1,\"1616\":4,\"1618\":1}}],[\"binaryoperator<t>\",{\"1\":{\"1601\":4}}],[\"binaryoperatortest\",{\"1\":{\"1601\":6}}],[\"binaryoperator中还有两个静态方法\",{\"1\":{\"1601\":1}}],[\"binaryoperator表示针对于两个相同运算对象的操作\",{\"1\":{\"1601\":1}}],[\"binaryoperator\",{\"1\":{\"1601\":6,\"1608\":2,\"1615\":1,\"1618\":2}}],[\"binary\",{\"1\":{\"542\":1,\"1620\":1}}],[\"bin\",{\"0\":{\"450\":1,\"454\":1,\"516\":1},\"1\":{\"429\":1,\"454\":1,\"479\":1,\"1554\":1}}],[\"binlogs显示的最小的binlog文件是master\",{\"1\":{\"485\":1}}],[\"binlog被从库发送给备库\",{\"1\":{\"472\":1}}],[\"binlog在记录event的时候\",{\"1\":{\"454\":1}}],[\"binlog里面就只有一个truncate\",{\"1\":{\"485\":1}}],[\"binlog里面记的都是a的server\",{\"1\":{\"455\":1}}],[\"binlog里面记录了数据行修改前和修改后的值\",{\"1\":{\"484\":1}}],[\"binlog里面记录了真实删除的行的主键id\",{\"1\":{\"454\":1}}],[\"binlog里面记录的就是sql语句的原文\",{\"1\":{\"454\":1}}],[\"binlog里面会记录修改前整行的数据和修改后的整行数据\",{\"1\":{\"454\":1}}],[\"binlog中的内容如下\",{\"1\":{\"454\":1}}],[\"binlog\",{\"1\":{\"451\":3,\"454\":4,\"465\":2,\"479\":1}}],[\"binlog也可以组提交了\",{\"1\":{\"451\":1}}],[\"binlog和innodb\",{\"1\":{\"451\":1}}],[\"binlog设置为大于1的值\",{\"1\":{\"451\":1}}],[\"binlog设置为n\",{\"1\":{\"450\":1}}],[\"binlog设置成一个比较大的值\",{\"1\":{\"450\":1}}],[\"binlog=n\",{\"1\":{\"450\":1}}],[\"binlog=1的时候\",{\"1\":{\"450\":1}}],[\"binlog=0的时候\",{\"1\":{\"450\":1}}],[\"binlog控制的\",{\"1\":{\"450\":1}}],[\"binlog的组提交中\",{\"1\":{\"465\":1}}],[\"binlog的组提交的效果通常不如redo\",{\"1\":{\"451\":1}}],[\"binlog的吸入逻辑比较简单\",{\"1\":{\"450\":1}}],[\"binlog的内容如下\",{\"1\":{\"447\":1}}],[\"binlog才会记录临时表的操作\",{\"1\":{\"413\":1}}],[\"binlog还没有写完的时候\",{\"1\":{\"327\":1}}],[\"binlog会记录所有的逻辑操作\",{\"1\":{\"327\":1}}],[\"binlog是可以追加写入的\",{\"1\":{\"325\":1}}],[\"binlog是逻辑日志\",{\"1\":{\"325\":1}}],[\"binlog是mysql的server层实现的\",{\"1\":{\"325\":1}}],[\"binlog日志只能用于归档\",{\"1\":{\"325\":1}}],[\"bigdecimal\",{\"1\":{\"645\":6}}],[\"big\",{\"1\":{\"418\":2}}],[\"biginteger都是不可变的\",{\"1\":{\"1391\":1}}],[\"biginteger\",{\"1\":{\"645\":4}}],[\"bigint\",{\"1\":{\"330\":2,\"335\":1,\"349\":1,\"495\":1,\"528\":1}}],[\"boxed\",{\"1\":{\"1620\":1}}],[\"boxing\",{\"1\":{\"1620\":5}}],[\"box\",{\"1\":{\"1620\":1}}],[\"boxsupplier\",{\"1\":{\"1618\":1}}],[\"box<i>\",{\"1\":{\"1617\":1}}],[\"both\",{\"1\":{\"1615\":1}}],[\"body\",{\"1\":{\"1594\":1}}],[\"body中\",{\"1\":{\"306\":1}}],[\"boundedqueue\",{\"1\":{\"1503\":1}}],[\"bound\",{\"1\":{\"1480\":1}}],[\"bossgroup\",{\"1\":{\"1226\":4}}],[\"boot框架\",{\"1\":{\"1989\":1}}],[\"boot实战练手很不错\",{\"1\":{\"1987\":1}}],[\"boot呢\",{\"1\":{\"1983\":1}}],[\"boot就可以了\",{\"1\":{\"1982\":1}}],[\"bootstrapclassloader\",{\"1\":{\"1432\":1,\"1691\":1}}],[\"bootstrap只需要配置一个事件循环组\",{\"1\":{\"1226\":1}}],[\"bootstrap也可以通过bind\",{\"1\":{\"1226\":1}}],[\"bootstrap通常使用connet\",{\"1\":{\"1226\":1}}],[\"bootstrap\",{\"1\":{\"1226\":3}}],[\"bootstrap是客户端的启动引导类\",{\"1\":{\"1226\":1}}],[\"bootstrap和serverbootstrap了解么\",{\"0\":{\"209\":1,\"1226\":1}}],[\"boot激活自动装配\",{\"1\":{\"1140\":1}}],[\"boot应用引导注解\",{\"1\":{\"1140\":1}}],[\"boot配置类\",{\"1\":{\"1140\":1}}],[\"boot或spring\",{\"1\":{\"1116\":1}}],[\"boot场景中\",{\"1\":{\"1056\":1}}],[\"boot基于bean\",{\"1\":{\"1056\":1}}],[\"boot通过外部化配置简化了messagesource\",{\"1\":{\"1056\":1}}],[\"boot\",{\"0\":{\"880\":1,\"1983\":1},\"1\":{\"583\":1,\"900\":1,\"1169\":2,\"1983\":5,\"1989\":1}}],[\"boot<\",{\"1\":{\"583\":1}}],[\"boolean\",{\"1\":{\"645\":8,\"928\":1,\"930\":1,\"952\":1,\"959\":2,\"963\":2,\"964\":1,\"967\":1,\"984\":2,\"1002\":1,\"1007\":1,\"1023\":1,\"1043\":3,\"1061\":1,\"1064\":1,\"1091\":1,\"1139\":2,\"1174\":2,\"1288\":1,\"1368\":2,\"1387\":2,\"1432\":1,\"1480\":1,\"1500\":2,\"1502\":1,\"1510\":1,\"1531\":2,\"1546\":1,\"1549\":2,\"1553\":1,\"1554\":2,\"1557\":3,\"1594\":1,\"1599\":4,\"1609\":1,\"1617\":1,\"1619\":1,\"1620\":7,\"1621\":8,\"1622\":1,\"1623\":2,\"1639\":1,\"1647\":8,\"1648\":4,\"1649\":1,\"1650\":2,\"1654\":2,\"1655\":2,\"1657\":1,\"1663\":1,\"1689\":1}}],[\"bool\",{\"1\":{\"542\":1}}],[\"book\",{\"1\":{\"362\":4,\"363\":2,\"1981\":1}}],[\"book表\",{\"1\":{\"362\":1}}],[\"book和class两张表都是没有使用索引\",{\"1\":{\"362\":1}}],[\"bydept\",{\"1\":{\"1616\":1}}],[\"byname\",{\"1\":{\"952\":1,\"953\":1}}],[\"bytype\",{\"1\":{\"918\":1,\"952\":1,\"953\":2}}],[\"bytearraypropertyeditor\",{\"1\":{\"1083\":1}}],[\"bytearrayresource\",{\"1\":{\"1039\":1}}],[\"byte数组\",{\"1\":{\"1083\":1}}],[\"bytebuffer>\",{\"1\":{\"1575\":3}}],[\"bytebuffer\",{\"1\":{\"1533\":4,\"1534\":4,\"1574\":22,\"1575\":31}}],[\"bytebuf支持slice操作\",{\"1\":{\"1231\":1}}],[\"bytebuf数据结构\",{\"0\":{\"720\":1}}],[\"bytebuf使用示例\",{\"0\":{\"719\":1}}],[\"bytebuf实现原理\",{\"0\":{\"718\":1}}],[\"byte\",{\"1\":{\"609\":1,\"645\":8,\"959\":1,\"1254\":1,\"1574\":6,\"1575\":6}}],[\"bytes1\",{\"1\":{\"1575\":3}}],[\"bytes\",{\"1\":{\"479\":1,\"1574\":9,\"1575\":9}}],[\"by非主键的字段\",{\"1\":{\"522\":1}}],[\"by冲突时优先where\",{\"1\":{\"521\":1}}],[\"by还需要用到另外一个字段来存累积计数\",{\"1\":{\"418\":1}}],[\"by还比较简单\",{\"1\":{\"411\":1}}],[\"by的逻辑\",{\"1\":{\"418\":1}}],[\"by的结果\",{\"1\":{\"417\":1}}],[\"by的时候\",{\"1\":{\"417\":1}}],[\"by的语义逻辑是统计不同的值出现的个数\",{\"1\":{\"417\":1}}],[\"by问题之前\",{\"1\":{\"417\":1}}],[\"by逻辑都需要构造一个带唯一索引的表\",{\"1\":{\"417\":1}}],[\"by语句中加入sql\",{\"1\":{\"418\":1}}],[\"by语句都要先放到内存临时表\",{\"1\":{\"418\":1}}],[\"by语句就可以改成\",{\"1\":{\"417\":1}}],[\"by语句就可以不再需要临时表\",{\"1\":{\"417\":1}}],[\"by语句需要临时表\",{\"1\":{\"417\":1}}],[\"by语句执行起来就会很慢\",{\"1\":{\"417\":1}}],[\"by语句\",{\"0\":{\"417\":1,\"418\":1}}],[\"by语句的explain结果\",{\"1\":{\"417\":1}}],[\"by语句的优化\",{\"0\":{\"415\":1}}],[\"by语句的一种方式就是让原来无序的数据变的\",{\"1\":{\"356\":1}}],[\"by执行流程\",{\"0\":{\"416\":1}}],[\"by会有临时表的产生\",{\"1\":{\"378\":1}}],[\"by一致\",{\"1\":{\"378\":1}}],[\"by基本上都需要进行排序\",{\"1\":{\"378\":1}}],[\"by排序views字段索引就可以用上\",{\"1\":{\"361\":1}}],[\"by排序views字段索引就用不上\",{\"1\":{\"361\":1}}],[\"by排序的时候没有用到索引\",{\"1\":{\"361\":1}}],[\"by也和索引有关\",{\"1\":{\"358\":1}}],[\"by与索引\",{\"0\":{\"353\":1}}],[\"by和分组查询group\",{\"1\":{\"330\":1}}],[\"by\",{\"0\":{\"419\":1},\"1\":{\"306\":2,\"330\":3,\"348\":6,\"353\":1,\"354\":1,\"361\":3,\"378\":12,\"390\":1,\"411\":4,\"413\":3,\"414\":1,\"416\":6,\"417\":1,\"418\":1,\"419\":1,\"420\":1,\"421\":3,\"422\":2,\"424\":1,\"429\":1,\"431\":7,\"479\":4,\"519\":6,\"520\":2,\"522\":4,\"930\":6,\"952\":10,\"975\":1,\"1165\":1,\"1166\":1,\"1594\":2,\"1595\":4,\"1597\":2,\"1600\":1,\"1608\":4,\"1609\":1,\"1611\":1,\"1613\":4,\"1615\":4,\"1616\":3,\"1618\":4,\"1619\":4,\"1620\":17,\"1621\":2,\"1622\":1,\"1623\":4,\"1647\":8,\"1655\":2}}],[\"b\",{\"0\":{\"75\":1,\"502\":1,\"1404\":1},\"1\":{\"322\":1,\"339\":3,\"347\":2,\"348\":7,\"354\":4,\"377\":15,\"396\":1,\"402\":1,\"403\":1,\"404\":1,\"407\":11,\"408\":2,\"409\":5,\"414\":1,\"434\":1,\"468\":1,\"484\":2,\"501\":1,\"506\":1,\"523\":2,\"525\":4,\"534\":1,\"556\":1,\"577\":2,\"1072\":2,\"1226\":6,\"1404\":2,\"1480\":3,\"1550\":1,\"1551\":1,\"1554\":3,\"1587\":1,\"1588\":1,\"1598\":8,\"1601\":12,\"1614\":2,\"1617\":14,\"1618\":4}}],[\"有很多生产经常遇到的问题\",{\"1\":{\"1974\":1}}],[\"有很多用户都只使用\",{\"1\":{\"596\":1}}],[\"有以下四个注解之一\",{\"1\":{\"1652\":1}}],[\"有以下考虑\",{\"1\":{\"453\":1}}],[\"有状态的中间操作\",{\"1\":{\"1624\":1}}],[\"有状态表示实例有属性对象\",{\"1\":{\"1236\":1}}],[\"有助于我们强化对于collector的理解\",{\"1\":{\"1618\":1}}],[\"有必要了解关于comparator比较器的内容\",{\"1\":{\"1614\":1}}],[\"有三个泛型\",{\"1\":{\"1598\":1}}],[\"有3个default默认方法\",{\"1\":{\"1594\":1}}],[\"有且仅有一个抽象方法\",{\"1\":{\"1594\":1}}],[\"有数据可读\",{\"1\":{\"1569\":1}}],[\"有界队列通常采用数组实现\",{\"1\":{\"1519\":1}}],[\"有返回值\",{\"1\":{\"1518\":2}}],[\"有自旋优化\",{\"1\":{\"1489\":1}}],[\"有批量重偏向\",{\"1\":{\"1489\":1}}],[\"有的默认是容量无限的\",{\"1\":{\"1509\":1}}],[\"有的是容量固定的\",{\"1\":{\"1509\":1}}],[\"有的对象可能不需要作为一个连续的内存结构存在也可以被访问到\",{\"1\":{\"1488\":1}}],[\"有的时候计算扇出值是很容易的\",{\"1\":{\"554\":1}}],[\"有着天然的原子性\",{\"1\":{\"1479\":1}}],[\"有几个常用的不稳定指令\",{\"1\":{\"1453\":1}}],[\"有bio\",{\"1\":{\"1421\":1}}],[\"有关系型数据库开发经验的人可以将其理解为\",{\"1\":{\"1297\":1}}],[\"有关依赖查找安全性对比如下\",{\"1\":{\"944\":1}}],[\"有多个advice会按照顺序进行执行\",{\"1\":{\"1654\":1}}],[\"有多种手段可以达到目的\",{\"1\":{\"1482\":1}}],[\"有多种方式可以依赖注入resourceloader\",{\"1\":{\"1045\":1}}],[\"有多条指令在多个处理器上同时执行\",{\"1\":{\"1470\":1}}],[\"有多少种依赖注入的方式\",{\"0\":{\"969\":1}}],[\"有\",{\"1\":{\"974\":1,\"1650\":1,\"1654\":1}}],[\"有可能筛选出来的是某个bean的类型\",{\"1\":{\"1648\":1}}],[\"有可能是beanclass\",{\"1\":{\"1648\":1}}],[\"有可能是内部类或其他虽然有\",{\"1\":{\"1647\":1}}],[\"有可能返回流本身\",{\"1\":{\"1619\":2}}],[\"有可能会返回流本身\",{\"1\":{\"1619\":1}}],[\"有可能会出现\",{\"1\":{\"489\":1}}],[\"有可能被放到了新数组的不同位置上\",{\"1\":{\"1550\":1}}],[\"有可能需要动态扩容\",{\"1\":{\"1509\":1}}],[\"有可能丢失消息\",{\"1\":{\"1419\":1}}],[\"有可能时非public字段\",{\"1\":{\"964\":1}}],[\"有了非阻塞io意味着线程在读写io时可以不必再阻塞了\",{\"1\":{\"602\":1}}],[\"有了redo\",{\"1\":{\"324\":1}}],[\"有效的纬度从\",{\"1\":{\"576\":1}}],[\"有效的经度从\",{\"1\":{\"576\":1}}],[\"有效经纬度\",{\"1\":{\"576\":1}}],[\"有效性是所有数据库必须解决的一个问题\",{\"1\":{\"533\":1}}],[\"有零星几个单点区间的话\",{\"1\":{\"553\":1}}],[\"有时两个key会定位到相同的问题\",{\"1\":{\"1546\":1}}],[\"有时人们把unix的时间戳保存为整数值\",{\"1\":{\"529\":1}}],[\"有时候需要进行io中断\",{\"1\":{\"1580\":1}}],[\"有时候l也表示list例如llen\",{\"1\":{\"571\":1}}],[\"有时候我们只想对这些串的前n个字符或字节建立索引\",{\"1\":{\"553\":1}}],[\"有时候使用索引执行查询时会有许多单点区间\",{\"1\":{\"553\":1}}],[\"有时候会碰到所有的查询都不能是过期读的需求\",{\"1\":{\"470\":1}}],[\"有时候一些运营类的查询语句会被放到备库上去查\",{\"1\":{\"453\":1}}],[\"有时候对于一个大查询我们需要\",{\"1\":{\"393\":1}}],[\"有时候还能避免某些列被修改带来的问题\",{\"1\":{\"385\":1}}],[\"有符号\",{\"1\":{\"528\":1}}],[\"有无符号\",{\"1\":{\"527\":1}}],[\"有索引的情况下\",{\"1\":{\"525\":1}}],[\"有没有可能选择错等等\",{\"1\":{\"514\":1}}],[\"有没有了解通过ddd领域驱动设计\",{\"0\":{\"229\":1,\"1309\":1}}],[\"有新增了一个基于writeset的并行复制\",{\"1\":{\"465\":1}}],[\"有这样两个参数\",{\"1\":{\"465\":1}}],[\"有4个事务涉及到db1\",{\"1\":{\"461\":1}}],[\"有两个\",{\"1\":{\"1664\":1}}],[\"有两个set方法\",{\"1\":{\"1653\":1}}],[\"有两个比较常见的误解\",{\"1\":{\"482\":1}}],[\"有两个绕不开的问题\",{\"1\":{\"426\":1}}],[\"有两种定位垃圾的方式\",{\"1\":{\"1437\":1}}],[\"有两种方式\",{\"1\":{\"1331\":1}}],[\"有两种方式可以产生新的主机\",{\"1\":{\"611\":1}}],[\"有两种方法\",{\"1\":{\"491\":1}}],[\"有两种思路\",{\"1\":{\"492\":1}}],[\"有两种比较常见的错误\",{\"1\":{\"467\":1}}],[\"有两种比较常用的思路\",{\"1\":{\"411\":1}}],[\"有两种常用的方法\",{\"1\":{\"467\":1}}],[\"有两种策略\",{\"1\":{\"444\":1}}],[\"有两种存储索引统计的方式\",{\"1\":{\"347\":1}}],[\"有两种情况\",{\"1\":{\"309\":1}}],[\"有不同的实现方式\",{\"1\":{\"396\":1}}],[\"有一些特性值会额外限制方法的行为\",{\"1\":{\"1620\":1}}],[\"有一些差别\",{\"1\":{\"1183\":1}}],[\"有一些访问方式可能需要扫描很多行才能返回一行结果\",{\"1\":{\"390\":1}}],[\"有一段文本name\",{\"1\":{\"1082\":1}}],[\"有一个static方法\",{\"1\":{\"1594\":1}}],[\"有一个结果需要从一个线程传递到另一个线程\",{\"1\":{\"1530\":1}}],[\"有一个编程范式\",{\"1\":{\"1483\":1}}],[\"有一个特别的逻辑\",{\"1\":{\"481\":1}}],[\"有一个相同的commit\",{\"1\":{\"464\":1}}],[\"有一个事务涉及到db2\",{\"1\":{\"461\":1}}],[\"有一个字段a只有true和false两种值\",{\"1\":{\"359\":1}}],[\"有些地方也称这种io方式为event\",{\"1\":{\"1565\":1}}],[\"有些线上的库\",{\"1\":{\"482\":1}}],[\"有些部署条件下\",{\"1\":{\"457\":1}}],[\"有些客户端框架会默认连接成功后先执行set\",{\"1\":{\"435\":1}}],[\"有些查询会请求超过实际需要的数据\",{\"1\":{\"382\":1}}],[\"有些使用mysql占用内存涨的特别快\",{\"1\":{\"318\":1}}],[\"有序消费\",{\"0\":{\"1901\":1}}],[\"有序性\",{\"0\":{\"1473\":1},\"1\":{\"1373\":1,\"1431\":1,\"1470\":1,\"1473\":1,\"1474\":1}}],[\"有序的执行\",{\"1\":{\"1623\":1}}],[\"有序的\",{\"1\":{\"1620\":1}}],[\"有序的一个stream\",{\"1\":{\"1609\":1}}],[\"有序的对象\",{\"1\":{\"1355\":1}}],[\"有序的字符串列表\",{\"1\":{\"1280\":1}}],[\"有序集成员按分数值递减\",{\"1\":{\"574\":1}}],[\"有序集合中对指定成员的分数加上增量\",{\"1\":{\"574\":1}}],[\"有序集合的成员是唯一的\",{\"1\":{\"574\":1}}],[\"有序集合\",{\"0\":{\"574\":1},\"1\":{\"568\":1,\"1280\":1}}],[\"有序\",{\"1\":{\"356\":1}}],[\"有序数组索引只适用于静态存储引擎\",{\"1\":{\"333\":1}}],[\"有序数组就是最好的数据结构了\",{\"1\":{\"333\":1}}],[\"有序数组在等值查询和范围查询场景中的性能就都非常优秀\",{\"1\":{\"333\":1}}],[\"有序数组\",{\"0\":{\"333\":1},\"1\":{\"331\":1}}],[\"有哪些块还停留在磁盘上\",{\"1\":{\"557\":1}}],[\"有哪些具体的使用场景\",{\"0\":{\"245\":1,\"1326\":1}}],[\"有哪些实现\",{\"0\":{\"69\":1,\"1398\":1}}],[\"有哪几种认证方式\",{\"0\":{\"219\":1,\"1202\":1}}],[\"有什么好处\",{\"0\":{\"170\":1,\"1252\":1}}],[\"有什么缺点\",{\"0\":{\"117\":1,\"1448\":1}}],[\"有什么作用\",{\"0\":{\"101\":1,\"1432\":1}}],[\"有什么区别\",{\"0\":{\"91\":1,\"1421\":1},\"1\":{\"1990\":1}}],[\"有abc\",{\"1\":{\"556\":1}}],[\"有a\",{\"0\":{\"75\":1,\"1404\":1}}],[\"ajp\",{\"1\":{\"1687\":1}}],[\"aid\",{\"1\":{\"1620\":1}}],[\"aioclienthandler\",{\"1\":{\"1575\":3}}],[\"aio要比bio简单\",{\"1\":{\"1575\":1}}],[\"aio\",{\"0\":{\"1575\":1},\"1\":{\"1576\":1}}],[\"aio模型\",{\"1\":{\"1421\":1}}],[\"aio异步非阻塞io模型\",{\"1\":{\"1421\":1}}],[\"a表示下游收集器的中间结果容器类型\",{\"1\":{\"1618\":1}}],[\"a类型表示汇聚操作的可变的累积类型\",{\"1\":{\"1615\":1}}],[\"a>类型的\",{\"1\":{\"1618\":1}}],[\"a>类型\",{\"1\":{\"1618\":2}}],[\"a>>mapmerger\",{\"1\":{\"1618\":1}}],[\"a>>\",{\"1\":{\"1618\":3}}],[\"a>\",{\"1\":{\"1597\":1,\"1598\":3,\"1599\":2,\"1600\":1,\"1601\":1,\"1608\":8,\"1615\":1,\"1617\":1,\"1618\":5}}],[\"a>=4\",{\"1\":{\"454\":1}}],[\"a<100000\",{\"1\":{\"1591\":1}}],[\"a<sup>\",{\"1\":{\"468\":4}}],[\"a++\",{\"1\":{\"1591\":2}}],[\"aqs中条件队列是使用单向列表保存的\",{\"1\":{\"1492\":1}}],[\"aqs中的await和signal\",{\"1\":{\"1477\":1}}],[\"aqs则会将当前线程已经等待状态信息构造成一个节点\",{\"1\":{\"1491\":1}}],[\"aqs依赖clh同步队列来完成同步状态的管理\",{\"1\":{\"1491\":1}}],[\"aqs当中的同步等待队列也称clh队列\",{\"1\":{\"1491\":1}}],[\"aqs定义了5个队列中节点的状态\",{\"1\":{\"1490\":1}}],[\"aqs定义两种资源共享方式\",{\"1\":{\"1490\":1}}],[\"aqs内部维护属性volatile\",{\"1\":{\"1490\":1}}],[\"aqs具备的特性\",{\"1\":{\"1490\":1}}],[\"aqs是一个抽象同步框架\",{\"1\":{\"1490\":1}}],[\"aqs的核心\",{\"1\":{\"1490\":1}}],[\"aqs与reentrantlock实现原理\",{\"0\":{\"1490\":1}}],[\"aqs使用模板方法的设计模式\",{\"1\":{\"1400\":1}}],[\"aqs如何实现可重入锁\",{\"0\":{\"71\":1,\"1400\":1}}],[\"awaitsingleornull\",{\"1\":{\"1655\":1}}],[\"await方法而阻塞的线程\",{\"1\":{\"1493\":2}}],[\"await方法的时候必须持有锁\",{\"1\":{\"1493\":1}}],[\"await方法会释放当前持有的锁\",{\"1\":{\"1493\":1}}],[\"await\",{\"1\":{\"1404\":1,\"1502\":2,\"1503\":2,\"1530\":1}}],[\"awareresourceloader\",{\"1\":{\"1045\":5}}],[\"aware接口回调阶段\",{\"1\":{\"1017\":1}}],[\"aware接口\",{\"1\":{\"1005\":1,\"1234\":1}}],[\"awareinterfacedependencyinjectiondemo\",{\"1\":{\"957\":4}}],[\"aware系列接口回调\",{\"1\":{\"957\":1}}],[\"aware\",{\"1\":{\"899\":1,\"900\":1,\"957\":1,\"1005\":1,\"1055\":1,\"1167\":1}}],[\"awt\",{\"1\":{\"1109\":3,\"1591\":4}}],[\"advantages\",{\"1\":{\"1620\":1}}],[\"advised\",{\"1\":{\"1654\":2}}],[\"advisedsupportlistener\",{\"0\":{\"805\":1}}],[\"advisedsupport\",{\"0\":{\"801\":1}}],[\"advisors\",{\"1\":{\"1654\":4}}],[\"advisoradapterregistry\",{\"1\":{\"1654\":1}}],[\"advisoradapter接口\",{\"0\":{\"796\":1}}],[\"advisor\",{\"0\":{\"826\":1},\"1\":{\"1654\":10}}],[\"advisorchainfactory接口\",{\"0\":{\"802\":1}}],[\"advisor接口\",{\"0\":{\"793\":1}}],[\"advicemethodcomparator\",{\"1\":{\"1654\":1}}],[\"advicekindcomparator\",{\"1\":{\"1654\":2}}],[\"advice的底层是通过methodinterceptor来实现的\",{\"1\":{\"1654\":1}}],[\"advice标准实现\",{\"0\":{\"789\":1,\"791\":1}}],[\"advice\",{\"0\":{\"769\":1,\"771\":1,\"772\":1,\"774\":1,\"775\":1,\"790\":1,\"792\":1,\"821\":1,\"822\":1,\"823\":1,\"824\":1,\"825\":1,\"830\":1}}],[\"advice类型\",{\"0\":{\"755\":1}}],[\"adhere\",{\"1\":{\"1615\":1}}],[\"adapter负责提供servletrequest对象给容器\",{\"1\":{\"1687\":1}}],[\"adapter\",{\"1\":{\"1655\":3}}],[\"adapted\",{\"1\":{\"1620\":1}}],[\"adaptbeaninstance\",{\"1\":{\"1647\":1}}],[\"adapt\",{\"1\":{\"1618\":1}}],[\"adapts\",{\"1\":{\"1618\":2}}],[\"adaptdependencycomparator\",{\"1\":{\"963\":2}}],[\"adaptordercomparator\",{\"1\":{\"963\":1}}],[\"addmapping\",{\"1\":{\"1658\":1}}],[\"addmethodname\",{\"1\":{\"1654\":1}}],[\"addmessage\",{\"1\":{\"1063\":2}}],[\"addservlet\",{\"1\":{\"1658\":1}}],[\"addsingletonfactory\",{\"1\":{\"1647\":1,\"1649\":1}}],[\"addcandidateentry\",{\"1\":{\"1648\":3}}],[\"addcount方法的源码如下\",{\"1\":{\"1554\":1}}],[\"addcount\",{\"1\":{\"1554\":3}}],[\"addconstructorargreference\",{\"1\":{\"954\":1}}],[\"adddiscoverer\",{\"1\":{\"1648\":2}}],[\"addtopendingcount\",{\"1\":{\"1620\":1}}],[\"addtime\",{\"1\":{\"1432\":1,\"1663\":1}}],[\"addition\",{\"1\":{\"1615\":1,\"1619\":1,\"1620\":2}}],[\"additionally\",{\"1\":{\"1620\":2,\"1623\":1}}],[\"additional\",{\"1\":{\"354\":1,\"520\":1,\"1608\":4,\"1615\":1,\"1618\":1,\"1620\":1,\"1623\":1}}],[\"adding\",{\"1\":{\"1554\":1}}],[\"add方法的逻辑如下图\",{\"1\":{\"1480\":1}}],[\"add方法会抛出非法一场\",{\"1\":{\"1476\":1}}],[\"addworker\",{\"1\":{\"1476\":3}}],[\"addl\",{\"1\":{\"1473\":1}}],[\"added\",{\"1\":{\"1620\":1}}],[\"addelapsedtimefrom\",{\"1\":{\"1432\":1,\"1663\":1}}],[\"addembeddedvalueresolver\",{\"1\":{\"1171\":1}}],[\"addadvice\",{\"1\":{\"1654\":1}}],[\"addactionlistener\",{\"1\":{\"1591\":2}}],[\"addactiveprofile\",{\"1\":{\"1147\":1}}],[\"addapplicationlistenerbean\",{\"1\":{\"1170\":1}}],[\"addapplicationlistener\",{\"1\":{\"1112\":1,\"1113\":1,\"1119\":1,\"1120\":1,\"1123\":3,\"1170\":1,\"1175\":1}}],[\"addall\",{\"1\":{\"963\":4,\"996\":1,\"1162\":1,\"1175\":1,\"1608\":5,\"1609\":1,\"1615\":1,\"1617\":3,\"1618\":3,\"1648\":1,\"1654\":3}}],[\"addobserver\",{\"1\":{\"1108\":1}}],[\"addfirst\",{\"1\":{\"1031\":1,\"1156\":1}}],[\"addqualifier\",{\"1\":{\"1027\":1}}],[\"addbeanpostprocessor\",{\"1\":{\"985\":1,\"1000\":1,\"1001\":1,\"1005\":2,\"1006\":1,\"1007\":1,\"1011\":3,\"1019\":1,\"1164\":3,\"1165\":1,\"1166\":2}}],[\"addbeanfactorypostprocessor\",{\"1\":{\"977\":1,\"985\":1,\"989\":1}}],[\"addpropertyeditorregistrar\",{\"1\":{\"1164\":1}}],[\"addpropertyreference\",{\"1\":{\"953\":1}}],[\"addpropertyvalue\",{\"1\":{\"927\":4,\"929\":2,\"1003\":2,\"1019\":1,\"1030\":1}}],[\"addr\",{\"1\":{\"573\":1,\"1479\":5,\"1517\":4}}],[\"address=\",{\"1\":{\"917\":1}}],[\"address\",{\"1\":{\"306\":9,\"309\":3,\"917\":7,\"1611\":1}}],[\"add\",{\"1\":{\"350\":2,\"352\":2,\"356\":2,\"368\":3,\"371\":2,\"409\":1,\"417\":2,\"441\":2,\"574\":7,\"645\":2,\"963\":1,\"964\":1,\"965\":3,\"967\":1,\"975\":1,\"996\":2,\"1116\":1,\"1166\":8,\"1365\":2,\"1368\":1,\"1404\":1,\"1480\":1,\"1500\":1,\"1501\":2,\"1517\":3,\"1538\":1,\"1557\":1,\"1591\":2,\"1598\":1,\"1608\":5,\"1609\":1,\"1611\":1,\"1612\":1,\"1615\":1,\"1617\":5,\"1618\":4,\"1621\":1,\"1647\":5,\"1648\":3,\"1652\":4,\"1654\":1,\"1689\":2}}],[\"ao\",{\"1\":{\"964\":2,\"965\":2}}],[\"aop参照了aspectj的实现\",{\"1\":{\"1654\":1}}],[\"aop还有一种aspectj的实现\",{\"1\":{\"1654\":1}}],[\"aop源码解析\",{\"0\":{\"1654\":1}}],[\"aop大致的实现原理\",{\"1\":{\"1630\":1}}],[\"aop底层原理\",{\"1\":{\"1630\":1}}],[\"aop等\",{\"1\":{\"1035\":1}}],[\"aop字节码提升\",{\"1\":{\"903\":1}}],[\"aop处理\",{\"1\":{\"903\":1}}],[\"aop抽象\",{\"1\":{\"900\":1,\"916\":1}}],[\"aop与ioc功能整合的设计模式\",{\"0\":{\"867\":1}}],[\"aop在spring\",{\"0\":{\"865\":1}}],[\"aoputils\",{\"0\":{\"815\":1}}],[\"aopcontext\",{\"0\":{\"813\":1}}],[\"aopinfrastructurebean接口\",{\"0\":{\"812\":1}}],[\"aopproxyutils\",{\"0\":{\"814\":1}}],[\"aopproxy实现\",{\"0\":{\"799\":1,\"800\":1}}],[\"aopproxyfactory\",{\"0\":{\"798\":1}}],[\"aopproxy接口\",{\"0\":{\"797\":1}}],[\"aop三种实现方式是如何进行设计的\",{\"0\":{\"781\":1}}],[\"aop支持哪些类型的advice\",{\"0\":{\"779\":1}}],[\"aop存在哪些差别\",{\"0\":{\"761\":1}}],[\"aop和aspectj\",{\"0\":{\"761\":1}}],[\"aop代理实现\",{\"0\":{\"756\":1}}],[\"aop编程模型有哪些\",{\"0\":{\"780\":1}}],[\"aop编程模型\",{\"0\":{\"754\":1}}],[\"aop设计核心\",{\"0\":{\"753\":1}}],[\"aop设计模式\",{\"0\":{\"748\":1}}],[\"aop常见使用场景\",{\"0\":{\"743\":1}}],[\"aop\",{\"0\":{\"736\":1,\"752\":1,\"755\":1,\"830\":1},\"1\":{\"892\":1,\"903\":1,\"921\":1,\"1028\":4,\"1965\":1,\"1966\":1,\"1982\":1}}],[\"aof工具\",{\"1\":{\"1297\":1}}],[\"aof运行效率也要比rdb慢\",{\"1\":{\"593\":1}}],[\"aof远远大于rdb\",{\"1\":{\"593\":1}}],[\"aof默认是不开启的\",{\"1\":{\"592\":1}}],[\"aof表示append\",{\"1\":{\"591\":1}}],[\"aof子进程\",{\"1\":{\"588\":1}}],[\"aof\",{\"0\":{\"595\":1},\"1\":{\"565\":1,\"592\":2,\"595\":1,\"596\":2}}],[\"amount\",{\"1\":{\"1620\":1}}],[\"among\",{\"1\":{\"1620\":1}}],[\"am\",{\"1\":{\"598\":3}}],[\"amaze\",{\"1\":{\"574\":6}}],[\"affect\",{\"1\":{\"1620\":2}}],[\"affected\",{\"1\":{\"393\":3,\"428\":1,\"431\":1}}],[\"aftercompletion\",{\"1\":{\"1657\":2}}],[\"afterthrowing的顺序进行执行\",{\"1\":{\"1654\":1}}],[\"afterthrowing\",{\"1\":{\"1654\":1}}],[\"afterreturning\",{\"1\":{\"1654\":3}}],[\"afterreturningadvice\",{\"1\":{\"1654\":1}}],[\"afterprototypecreation\",{\"1\":{\"1647\":2}}],[\"afterpropertiesset方法\",{\"1\":{\"1007\":1}}],[\"afterpropertiesset\",{\"1\":{\"583\":1,\"931\":3,\"946\":2,\"1007\":7}}],[\"after等注解\",{\"1\":{\"1630\":1}}],[\"after这个function类型的参数\",{\"1\":{\"1598\":1}}],[\"afternodeinsertion\",{\"1\":{\"1549\":1}}],[\"afternodeaccess\",{\"1\":{\"1549\":1}}],[\"aftersingletonsinstantiated\",{\"1\":{\"1009\":3,\"1647\":2}}],[\"after\",{\"0\":{\"791\":1,\"792\":1,\"823\":1,\"824\":1,\"825\":1},\"1\":{\"571\":3,\"624\":2,\"1594\":6,\"1597\":9,\"1598\":36,\"1615\":2,\"1619\":1,\"1620\":9,\"1621\":4,\"1622\":1,\"1623\":4,\"1654\":5}}],[\"a读取的数据无效\",{\"1\":{\"532\":1}}],[\"a=a\",{\"1\":{\"1617\":4}}],[\"a=\",{\"1\":{\"524\":1}}],[\"a=t2\",{\"1\":{\"401\":1,\"403\":1}}],[\"a`\",{\"1\":{\"523\":1}}],[\"a执行select语句的时候\",{\"1\":{\"497\":1}}],[\"a启动的事务ta的低水位就是248\",{\"1\":{\"497\":1}}],[\"a还没有涉及到更新\",{\"1\":{\"497\":1}}],[\"a还只是给id=5这一行加了行锁\",{\"1\":{\"447\":1}}],[\"a所在的线程\",{\"1\":{\"497\":1}}],[\"a来申请自增id得到id=3\",{\"1\":{\"492\":1}}],[\"a往表t1中插入了4行数据\",{\"1\":{\"492\":1}}],[\"averagingint\",{\"1\":{\"1616\":1}}],[\"averagingdouble\",{\"1\":{\"1613\":1}}],[\"average\",{\"1\":{\"429\":3,\"1615\":1}}],[\"availability\",{\"1\":{\"1311\":1}}],[\"availableprocessors\",{\"1\":{\"1227\":1,\"1480\":1,\"1573\":1}}],[\"available\",{\"1\":{\"965\":1,\"1162\":1,\"1623\":3,\"1648\":1}}],[\"avalon\",{\"1\":{\"908\":1}}],[\"avoiding\",{\"1\":{\"1619\":1}}],[\"avoid\",{\"1\":{\"922\":1,\"1175\":1,\"1620\":2,\"1647\":1,\"1651\":1}}],[\"avg\",{\"1\":{\"479\":1,\"538\":2}}],[\"apache\",{\"0\":{\"673\":1},\"1\":{\"645\":4,\"908\":1}}],[\"appconfig\",{\"1\":{\"1632\":1,\"1633\":1,\"1634\":1,\"1645\":2}}],[\"appclassloader\",{\"1\":{\"1432\":1,\"1691\":1}}],[\"appropriate\",{\"1\":{\"1621\":1}}],[\"approximately\",{\"1\":{\"1620\":3}}],[\"approximate\",{\"1\":{\"1620\":1}}],[\"applied\",{\"1\":{\"1598\":6,\"1615\":1,\"1617\":1,\"1618\":2}}],[\"applies\",{\"1\":{\"1598\":26,\"1623\":1}}],[\"appliactioncontext场景使用\",{\"1\":{\"1009\":1,\"1011\":1}}],[\"applicable\",{\"1\":{\"519\":1,\"520\":2,\"1647\":2}}],[\"applicationfailedevent\",{\"1\":{\"1126\":1}}],[\"applicationreadyevent\",{\"1\":{\"1126\":1}}],[\"applicationpreparedevent\",{\"1\":{\"1126\":1}}],[\"applicationenvironmentpreparedevent\",{\"1\":{\"1126\":1}}],[\"applicationevents\",{\"1\":{\"1162\":1}}],[\"applicationevent\",{\"0\":{\"1111\":1},\"1\":{\"1112\":3,\"1113\":1,\"1114\":1,\"1115\":1,\"1119\":2,\"1124\":1,\"1125\":1,\"1128\":1,\"1170\":1}}],[\"applicationeventmulticaster这个对象一定会存在\",{\"1\":{\"1168\":1}}],[\"applicationeventmulticaster底层实现\",{\"1\":{\"1168\":1}}],[\"applicationeventmulticaster不会为空\",{\"1\":{\"1121\":1}}],[\"applicationeventmulticaster对象\",{\"1\":{\"945\":1}}],[\"applicationeventmulticaster\",{\"1\":{\"945\":1,\"973\":1,\"1121\":9,\"1122\":1,\"1123\":9,\"1128\":1,\"1168\":7}}],[\"applicationeventpublisher以及applicationcontext\",{\"1\":{\"1164\":1}}],[\"applicationeventpublisher底层实现\",{\"0\":{\"1122\":1}}],[\"applicationeventpublisheraware与beanpostprocessor不能同时使用\",{\"1\":{\"1122\":1}}],[\"applicationeventpublisheraware\",{\"1\":{\"957\":1,\"1005\":3,\"1120\":1,\"1164\":1}}],[\"applicationeventpublisher\",{\"1\":{\"899\":1,\"973\":5,\"1115\":4,\"1118\":1,\"1120\":10,\"1128\":1,\"1164\":1,\"1637\":1}}],[\"applicationlistene接收到spring事件\",{\"1\":{\"1113\":1}}],[\"applicationlistenerdetector\",{\"1\":{\"1164\":1,\"1166\":1}}],[\"applicationlistenerdemo\",{\"1\":{\"1112\":1,\"1113\":2}}],[\"applicationlisteners\",{\"1\":{\"1162\":4,\"1164\":1,\"1166\":1,\"1175\":2}}],[\"applicationlistener<\",{\"1\":{\"1124\":1,\"1170\":1}}],[\"applicationlistener<contextclosedevent>\",{\"1\":{\"1123\":1,\"1175\":1}}],[\"applicationlistener<myspringevent>\",{\"1\":{\"1119\":1}}],[\"applicationlistener<applicationcontextevent>\",{\"1\":{\"1116\":1}}],[\"applicationlistener<applicationevent>\",{\"1\":{\"1112\":1,\"1113\":1}}],[\"applicationlistener作为spring\",{\"1\":{\"1114\":1}}],[\"applicationlistener\",{\"0\":{\"1114\":1},\"1\":{\"1112\":1,\"1114\":1,\"1119\":2,\"1125\":1,\"1128\":1,\"1170\":1,\"1175\":1}}],[\"application以及websocket\",{\"1\":{\"991\":1}}],[\"applicationstartedevent\",{\"1\":{\"1126\":1}}],[\"applicationstartingevent\",{\"1\":{\"1126\":1}}],[\"applicationstartupaware\",{\"1\":{\"1005\":2,\"1164\":1}}],[\"applicationstartup\",{\"1\":{\"922\":2,\"1647\":3,\"1651\":2}}],[\"applicationscope\",{\"1\":{\"988\":1}}],[\"applicationscope或\",{\"1\":{\"988\":1}}],[\"application作用域的bean可以在servletcontext中直接获取到\",{\"1\":{\"988\":1}}],[\"application作用域\",{\"0\":{\"988\":1},\"1\":{\"1647\":1}}],[\"applicationconetxt对象\",{\"1\":{\"957\":1}}],[\"applicationcontext的典型实现\",{\"1\":{\"1637\":1}}],[\"applicationcontext提供了如下功能\",{\"1\":{\"1637\":1}}],[\"applicationcontext除了beanfactory提供的基础功能外\",{\"1\":{\"1636\":1}}],[\"applicationcontext除了ioc容器角色\",{\"1\":{\"921\":1}}],[\"applicationcontext继承了beanfactory\",{\"1\":{\"1636\":1}}],[\"applicationcontextexception\",{\"1\":{\"1163\":1,\"1651\":1}}],[\"applicationcontextevent派生事件\",{\"1\":{\"1117\":1}}],[\"applicationcontextevent\",{\"1\":{\"1111\":1,\"1116\":1}}],[\"applicationcontext作为事件源\",{\"1\":{\"1111\":1}}],[\"applicationcontext执行\",{\"1\":{\"1016\":1}}],[\"applicationcontextawareprocessor\",{\"1\":{\"1005\":1,\"1164\":2}}],[\"applicationcontextaware\",{\"1\":{\"957\":2,\"1005\":3,\"1148\":1,\"1164\":1,\"1234\":1}}],[\"applicationcontext\",{\"0\":{\"1637\":1},\"1\":{\"921\":4,\"929\":6,\"930\":3,\"931\":5,\"933\":5,\"934\":4,\"936\":4,\"940\":7,\"943\":13,\"944\":15,\"946\":13,\"953\":12,\"955\":6,\"957\":7,\"961\":18,\"962\":6,\"963\":6,\"973\":17,\"977\":5,\"978\":5,\"985\":16,\"989\":9,\"1005\":13,\"1044\":4,\"1045\":7,\"1056\":3,\"1065\":4,\"1084\":3,\"1116\":3,\"1120\":7,\"1148\":7,\"1164\":1,\"1166\":2}}],[\"applicationcontext虽然继承了beanfactory接口\",{\"1\":{\"921\":1}}],[\"applicationcontext是beanfactory的超集\",{\"1\":{\"921\":1}}],[\"applicationa作为ioc容器示例\",{\"1\":{\"921\":1}}],[\"application的ioc容器使用\",{\"1\":{\"921\":1}}],[\"application\",{\"0\":{\"993\":1},\"1\":{\"472\":1,\"479\":1,\"983\":1,\"988\":2,\"993\":1,\"996\":1,\"1121\":4,\"1123\":1,\"1162\":1,\"1164\":2,\"1168\":4,\"1170\":1,\"1175\":1,\"1182\":1,\"1235\":1,\"1609\":1,\"1655\":2}}],[\"applymergedbeandefinitionpostprocessors\",{\"1\":{\"1647\":1}}],[\"applyasint\",{\"1\":{\"1614\":2,\"1618\":1}}],[\"applying\",{\"1\":{\"1609\":1,\"1618\":1}}],[\"applytoeither\",{\"1\":{\"1518\":1}}],[\"apply\",{\"1\":{\"1170\":1,\"1598\":30,\"1601\":6,\"1606\":1,\"1609\":1,\"1615\":10,\"1617\":2,\"1618\":11,\"1620\":1,\"1622\":1,\"1647\":1,\"1655\":1}}],[\"applypattern\",{\"1\":{\"1053\":2}}],[\"applypropertyvalues\",{\"1\":{\"1003\":1,\"1647\":1}}],[\"applyscopedproxymode\",{\"1\":{\"1027\":1,\"1647\":1}}],[\"applybeanpostprocessorsafterinitialization\",{\"1\":{\"1008\":1,\"1647\":1}}],[\"applybeanpostprocessorsbeforeinitialization\",{\"1\":{\"1006\":1,\"1008\":1}}],[\"applybeanpostprocessorsbeforeinstantiation\",{\"1\":{\"1000\":1,\"1647\":1}}],[\"apple\",{\"1\":{\"574\":14}}],[\"appending\",{\"1\":{\"1622\":3}}],[\"append方法都需要加锁和解锁\",{\"1\":{\"1486\":1}}],[\"appendfsync\",{\"1\":{\"592\":3}}],[\"appendfilename\",{\"1\":{\"592\":1}}],[\"appendonly\",{\"1\":{\"592\":2}}],[\"append\",{\"1\":{\"570\":2,\"1084\":4,\"1091\":4,\"1486\":4,\"1487\":4,\"1608\":4,\"1618\":2}}],[\"api构建的原始web框架\",{\"1\":{\"1656\":1}}],[\"apinote\",{\"1\":{\"1608\":1}}],[\"api的方式对外提供统一的服务\",{\"1\":{\"1304\":1}}],[\"api的封装与简化\",{\"1\":{\"891\":1}}],[\"api添加\",{\"1\":{\"1125\":1}}],[\"api注册\",{\"1\":{\"1114\":1}}],[\"api设计\",{\"1\":{\"1107\":1}}],[\"api开发\",{\"1\":{\"1107\":1}}],[\"api整合\",{\"1\":{\"1037\":1}}],[\"api整体设计\",{\"0\":{\"782\":1}}],[\"api编程\",{\"1\":{\"1031\":1}}],[\"api内部实现\",{\"1\":{\"1026\":1}}],[\"apidependencysetterinjectiondemo\",{\"1\":{\"953\":1}}],[\"api配置元信息的方式的核心部分\",{\"1\":{\"954\":1}}],[\"api配置元信息\",{\"1\":{\"929\":2,\"951\":1,\"953\":1,\"954\":1}}],[\"api依赖性\",{\"1\":{\"911\":1}}],[\"api抽象设计\",{\"1\":{\"900\":1}}],[\"api实现\",{\"1\":{\"972\":1,\"973\":1}}],[\"api实现after\",{\"0\":{\"775\":1}}],[\"api实现before\",{\"0\":{\"772\":1}}],[\"api实现pointcut\",{\"0\":{\"767\":1}}],[\"api接口层\",{\"1\":{\"645\":1}}],[\"api就是用来解决这个问题的\",{\"1\":{\"603\":1}}],[\"api和我们的指令是一样的\",{\"1\":{\"583\":1}}],[\"api\",{\"1\":{\"309\":1,\"920\":2,\"930\":5,\"931\":1,\"933\":1,\"965\":1,\"986\":1,\"987\":1,\"988\":1,\"989\":1,\"1025\":1,\"1036\":2,\"1075\":1,\"1091\":1,\"1099\":1,\"1147\":1,\"1153\":1,\"1349\":1,\"1620\":1,\"1974\":1,\"1986\":1}}],[\"api提供了两种查询条件查询搜索方式\",{\"1\":{\"306\":1}}],[\"a与set\",{\"1\":{\"468\":1}}],[\"a判断这个server\",{\"1\":{\"455\":1}}],[\"a加的是间隙锁\",{\"1\":{\"448\":1}}],[\"a加的表锁\",{\"1\":{\"424\":1}}],[\"a提交以后\",{\"1\":{\"447\":1}}],[\"a把所有的行都加上了写锁\",{\"1\":{\"447\":1}}],[\"a事务提交\",{\"1\":{\"447\":1}}],[\"a声明说\",{\"1\":{\"447\":1}}],[\"a在t3时刻执行insert语句的时候\",{\"1\":{\"497\":1}}],[\"a在t1时刻再加上一个更新语句\",{\"1\":{\"447\":1}}],[\"a在myisam引擎中返回的结果是4000\",{\"1\":{\"354\":1}}],[\"a之后的select语句用\",{\"1\":{\"446\":1}}],[\"a里q1语句要锁住所有d=5的行的加锁声明\",{\"1\":{\"447\":1}}],[\"a里执行了三次查询\",{\"1\":{\"446\":1}}],[\"a里面\",{\"1\":{\"424\":1}}],[\"a先启动\",{\"1\":{\"441\":1}}],[\"a要得到1\",{\"1\":{\"434\":1}}],[\"atomicstampedrerence\",{\"1\":{\"1480\":1}}],[\"atomicstampedreferencetest\",{\"1\":{\"1479\":1}}],[\"atomicstampedreference\",{\"1\":{\"1479\":10}}],[\"atomicreferencefieldupdater\",{\"1\":{\"1480\":1}}],[\"atomicreferencearray\",{\"1\":{\"1480\":1}}],[\"atomicreference\",{\"1\":{\"1480\":1}}],[\"atomicboolean\",{\"1\":{\"1480\":1}}],[\"atomiclongfieldupdater\",{\"1\":{\"1480\":1}}],[\"atomiclongarray\",{\"1\":{\"1480\":1}}],[\"atomiclong\",{\"1\":{\"1480\":1}}],[\"atomic包里提供了一组原子操作类\",{\"1\":{\"1480\":1}}],[\"atomic源码解析\",{\"0\":{\"1480\":1}}],[\"atomicmarkablereference\",{\"1\":{\"1479\":2,\"1480\":1}}],[\"atomic\",{\"1\":{\"1479\":10}}],[\"atomic开头的原子类\",{\"1\":{\"1373\":1}}],[\"atomicintegerarray\",{\"1\":{\"1480\":1}}],[\"atomicinteger\",{\"1\":{\"1480\":1,\"1503\":4}}],[\"atomicintegerfieldupdater\",{\"0\":{\"724\":1},\"1\":{\"1480\":1}}],[\"atomicity\",{\"1\":{\"432\":1}}],[\"attain\",{\"1\":{\"1620\":1}}],[\"attachment\",{\"1\":{\"1575\":12}}],[\"attached\",{\"1\":{\"519\":5,\"553\":1,\"555\":1}}],[\"attaching\",{\"1\":{\"519\":2}}],[\"attribute\",{\"1\":{\"1132\":1,\"1136\":2,\"1137\":1,\"1171\":1,\"1655\":1}}],[\"attributevalue\",{\"1\":{\"1030\":3}}],[\"attributename\",{\"1\":{\"1030\":3}}],[\"attributeaccessor\",{\"1\":{\"1019\":1}}],[\"attrs\",{\"1\":{\"1023\":3,\"1139\":3}}],[\"attempts\",{\"1\":{\"1618\":1}}],[\"attempt\",{\"1\":{\"922\":1,\"1175\":1,\"1647\":1,\"1651\":1}}],[\"at\",{\"1\":{\"429\":4,\"451\":6,\"952\":1,\"1053\":3,\"1061\":1,\"1171\":1,\"1333\":2,\"1609\":2,\"1619\":11,\"1620\":4,\"1621\":1,\"1622\":1,\"1647\":3,\"1650\":1}}],[\"a持有整个表t的mdl锁\",{\"1\":{\"425\":1}}],[\"a的\",{\"1\":{\"492\":1}}],[\"a的参数以外\",{\"1\":{\"482\":1}}],[\"a的参数\",{\"1\":{\"482\":2}}],[\"a的位点和a\",{\"1\":{\"467\":1}}],[\"a的mdl读锁还没有释放\",{\"1\":{\"441\":1}}],[\"a的间隙锁\",{\"1\":{\"424\":1}}],[\"a的select语句其实只操作了分区p\",{\"1\":{\"424\":1}}],[\"a的select语句对索引ftime上这两个记录之间的间隙加了锁\",{\"1\":{\"424\":1}}],[\"a的thread\",{\"1\":{\"413\":1}}],[\"a的临时表t1\",{\"1\":{\"413\":1}}],[\"a的线程id是4\",{\"1\":{\"412\":1}}],[\"a和session\",{\"1\":{\"412\":1}}],[\"a和\",{\"1\":{\"412\":1}}],[\"a内有同名的临时表和普通表的时候\",{\"1\":{\"410\":1}}],[\"a创建的临时表t\",{\"1\":{\"410\":1}}],[\"a5\",{\"1\":{\"378\":5}}],[\"a4\",{\"1\":{\"378\":9}}],[\"a3\",{\"1\":{\"378\":6,\"1615\":3}}],[\"a2\",{\"1\":{\"378\":13,\"1615\":6}}],[\"a1\",{\"1\":{\"378\":16,\"1615\":7}}],[\"above\",{\"1\":{\"1619\":2}}],[\"about\",{\"1\":{\"1615\":1,\"1620\":1,\"1623\":3}}],[\"abortpolicy\",{\"1\":{\"1410\":1,\"1476\":1}}],[\"aba问题比较重要\",{\"1\":{\"1479\":1}}],[\"aba问题示例\",{\"1\":{\"1479\":1}}],[\"aba问题\",{\"1\":{\"1479\":1}}],[\"aba\",{\"1\":{\"1479\":1}}],[\"abastractapplicationcontext内建可查找的依赖\",{\"1\":{\"945\":1}}],[\"ab发布又称蓝绿发布\",{\"1\":{\"1310\":1}}],[\"ab发布\",{\"1\":{\"1310\":1}}],[\"ab发布要怎么做\",{\"0\":{\"230\":1,\"1310\":1}}],[\"able\",{\"1\":{\"1055\":1,\"1167\":1,\"1647\":1}}],[\"abd\",{\"1\":{\"1027\":12}}],[\"abc\",{\"1\":{\"574\":6,\"1526\":2}}],[\"abc索引失效会变成全表扫描\",{\"1\":{\"369\":1}}],[\"abstractflag是beandefinition的内部属性\",{\"1\":{\"1647\":1}}],[\"abstract<p\",{\"1\":{\"1623\":3}}],[\"abstractpipeline<e\",{\"1\":{\"1623\":1}}],[\"abstractpipeline<\",{\"1\":{\"1622\":3}}],[\"abstractpipeline包含了大多数计算管道的机制\",{\"1\":{\"1621\":1}}],[\"abstractpipeline代表了流管道初始的阶段\",{\"1\":{\"1621\":1}}],[\"abstractpipeline是对于管道类抽象出来的一个父类\",{\"1\":{\"1621\":1}}],[\"abstractpipeline的说明如下\",{\"1\":{\"1621\":1}}],[\"abstractpipeline\",{\"1\":{\"1619\":4,\"1621\":7,\"1622\":1,\"1623\":2}}],[\"abstractset<map\",{\"1\":{\"1618\":1}}],[\"abstractsinglebeandefinitionparser\",{\"1\":{\"1030\":1}}],[\"abstractrefreshablewebapplicationcontext\",{\"1\":{\"1169\":1}}],[\"abstractmap<boolean\",{\"1\":{\"1618\":1}}],[\"abstractmap<integer\",{\"1\":{\"1103\":1}}],[\"abstractmessagesource\",{\"1\":{\"1060\":1}}],[\"abstractlist\",{\"1\":{\"1099\":1,\"1103\":2}}],[\"abstractbeanfactory\",{\"1\":{\"1093\":1,\"1636\":1,\"1647\":2}}],[\"abstractbeandefinition\",{\"1\":{\"927\":1,\"929\":1,\"931\":1,\"933\":1,\"996\":2,\"1019\":1,\"1632\":1,\"1647\":3}}],[\"abstractnestablepropertyaccessor实现\",{\"1\":{\"1093\":1}}],[\"abstractaspectjadvisorfactory\",{\"1\":{\"1654\":1}}],[\"abstractapplicationeventmulticaster\",{\"1\":{\"1122\":1}}],[\"abstractapplicationcontext的实现决定了messagesource内建实现\",{\"1\":{\"1056\":1}}],[\"abstractapplicationcontext\",{\"1\":{\"973\":1,\"1041\":1,\"1045\":1,\"1056\":3,\"1093\":1,\"1123\":1,\"1162\":1,\"1163\":1,\"1164\":1,\"1165\":2,\"1166\":2,\"1167\":1,\"1168\":1,\"1169\":1,\"1170\":1,\"1171\":1,\"1172\":1,\"1173\":1,\"1174\":1,\"1175\":1}}],[\"abstractautowirecapablebeanfactory\",{\"1\":{\"1005\":1,\"1093\":1,\"1184\":2,\"1636\":1,\"1651\":1}}],[\"abstractautoproxycreator\",{\"0\":{\"809\":1}}],[\"abstraction\",{\"1\":{\"921\":1}}],[\"abstract类\",{\"1\":{\"899\":1}}],[\"abstract\",{\"1\":{\"429\":2,\"1022\":1,\"1594\":9,\"1621\":2,\"1622\":1,\"1623\":4}}],[\"aggregate\",{\"1\":{\"574\":1,\"1619\":3}}],[\"against\",{\"1\":{\"571\":1,\"611\":2}}],[\"again\",{\"1\":{\"368\":2,\"1615\":3,\"1623\":1}}],[\"ageofperson\",{\"1\":{\"1598\":1}}],[\"age=a\",{\"1\":{\"1526\":1}}],[\"age=0\",{\"1\":{\"1526\":2}}],[\"age=10\",{\"1\":{\"340\":1}}],[\"age为24岁\",{\"1\":{\"542\":1}}],[\"age字段\",{\"1\":{\"370\":1,\"372\":1}}],[\"age三个字段返回给客户端\",{\"1\":{\"355\":1}}],[\"age三个字段的值\",{\"1\":{\"354\":1,\"356\":1}}],[\"age这三个字段的定义总长度是36\",{\"1\":{\"355\":1}}],[\"age这三个字段\",{\"1\":{\"354\":1}}],[\"age`\",{\"1\":{\"338\":1}}],[\"age\",{\"1\":{\"306\":12,\"309\":2,\"339\":3,\"340\":2,\"353\":1,\"354\":1,\"356\":4,\"370\":5,\"371\":2,\"372\":3,\"421\":1,\"510\":4,\"518\":7,\"519\":3,\"569\":13,\"570\":6,\"573\":8,\"909\":5,\"927\":1,\"1072\":2,\"1598\":3,\"1600\":5,\"1611\":2,\"1613\":8}}],[\"auth\",{\"1\":{\"624\":2}}],[\"authoring的缺点\",{\"0\":{\"1036\":1}}],[\"authoring扩展spring\",{\"0\":{\"1030\":1}}],[\"author\",{\"1\":{\"361\":3,\"1605\":1}}],[\"autoproxyregistrar主要的作用是向spring容器中注册了一个infrastructureadvisorautoproxycreator的bean\",{\"1\":{\"1655\":1}}],[\"autoproxyregistrar\",{\"1\":{\"1655\":1}}],[\"autocloseabletest\",{\"1\":{\"1619\":5}}],[\"autocloseable\",{\"1\":{\"1619\":5}}],[\"autoconfigurationexcludefilter\",{\"1\":{\"1135\":1}}],[\"autoconfiguration\",{\"1\":{\"1056\":1}}],[\"autocommit=flase\",{\"1\":{\"1655\":1}}],[\"autocommit=false\",{\"1\":{\"1630\":1}}],[\"autocommit\",{\"1\":{\"435\":3,\"1328\":1}}],[\"autosave\",{\"1\":{\"1531\":1}}],[\"autogrownestedpaths\",{\"1\":{\"1072\":1}}],[\"autowried注解来实现\",{\"1\":{\"1630\":1}}],[\"autowring\",{\"1\":{\"951\":1}}],[\"autowird注入\",{\"0\":{\"964\":1}}],[\"autowird\",{\"1\":{\"955\":1,\"956\":1}}],[\"autowiringvalue\",{\"1\":{\"1648\":6}}],[\"autowiringtype\",{\"1\":{\"1648\":2}}],[\"autowiring无法把控注入的时候的精确性\",{\"1\":{\"952\":1}}],[\"autowiring\",{\"1\":{\"927\":1,\"952\":6,\"965\":1,\"973\":1,\"1164\":1}}],[\"autowireconstructor\",{\"1\":{\"1650\":3}}],[\"autowirecandidatequalifier\",{\"1\":{\"1027\":1}}],[\"autowirecandidateresolver\",{\"1\":{\"963\":1,\"1648\":1}}],[\"autowirecapablebeanfactory\",{\"1\":{\"930\":1,\"952\":3,\"1636\":2}}],[\"autowirenecessary\",{\"1\":{\"1650\":3}}],[\"autowireutils\",{\"1\":{\"1648\":1}}],[\"autowirebytype\",{\"1\":{\"1647\":1}}],[\"autowirebyname\",{\"1\":{\"1647\":1}}],[\"autowire\",{\"1\":{\"952\":6,\"1020\":3,\"1647\":6,\"1650\":1}}],[\"autowire=\",{\"1\":{\"918\":1,\"953\":1,\"954\":1,\"1003\":1,\"1012\":1}}],[\"autowired是spring的注解\",{\"1\":{\"1648\":1}}],[\"autowiredmethodelement\",{\"1\":{\"1648\":2}}],[\"autowiredresourceloader\",{\"1\":{\"1045\":4}}],[\"autowired依赖查找\",{\"1\":{\"1023\":1,\"1131\":1}}],[\"autowired做任何的扩展\",{\"1\":{\"967\":1}}],[\"autowired联系\",{\"0\":{\"965\":1}}],[\"autowiredfieldelement\",{\"1\":{\"964\":1,\"1648\":1}}],[\"autowiredannotationbeanpostprocessor\",{\"1\":{\"965\":2,\"967\":7,\"1150\":1,\"1152\":1,\"1648\":3}}],[\"autowiredannotationbeanpostprocessor对象\",{\"1\":{\"945\":1}}],[\"autowiredannotationtypes\",{\"1\":{\"964\":1,\"965\":5,\"967\":2,\"1648\":1}}],[\"autowired注入applicationcontext\",{\"1\":{\"1148\":1}}],[\"autowired注入environment\",{\"1\":{\"1148\":1}}],[\"autowired注入resourceloader\",{\"1\":{\"1045\":1}}],[\"autowired注入总体过程\",{\"1\":{\"964\":1}}],[\"autowired注解制定了某个构造方法\",{\"1\":{\"1650\":1}}],[\"autowired注解的区别在于\",{\"1\":{\"1648\":1}}],[\"autowired注解的实现类\",{\"1\":{\"1648\":1}}],[\"autowired注解的字段\",{\"1\":{\"964\":1}}],[\"autowired注解在处理的上完全一样的\",{\"1\":{\"965\":1}}],[\"autowiredbeanname\",{\"1\":{\"963\":8,\"1648\":12}}],[\"autowiredbeannames\",{\"1\":{\"963\":15,\"1648\":11}}],[\"autowired字段关联\",{\"1\":{\"955\":1}}],[\"autowired会忽略掉静态字段\",{\"1\":{\"955\":1}}],[\"autowiredpublic\",{\"1\":{\"951\":1}}],[\"autowireduser\",{\"1\":{\"951\":1}}],[\"autowired以及\",{\"1\":{\"945\":1}}],[\"autowired\",{\"1\":{\"583\":1,\"955\":1,\"956\":1,\"961\":11,\"962\":3,\"963\":4,\"964\":2,\"965\":1,\"967\":6,\"973\":4,\"977\":1,\"985\":12,\"1023\":3,\"1045\":2,\"1120\":5,\"1131\":1,\"1148\":1,\"1157\":1,\"1181\":2,\"1184\":2,\"1648\":4}}],[\"automatically\",{\"1\":{\"1619\":1}}],[\"automatic\",{\"1\":{\"899\":1,\"900\":1}}],[\"autoinc\",{\"1\":{\"492\":3}}],[\"auto\",{\"1\":{\"330\":1,\"335\":1,\"361\":1,\"362\":2,\"363\":1,\"378\":1,\"419\":1,\"459\":1,\"468\":2,\"472\":1,\"489\":1,\"490\":2,\"491\":1,\"494\":4,\"506\":1,\"510\":2,\"518\":2,\"523\":1,\"534\":1,\"535\":1,\"559\":9,\"918\":1}}],[\"along\",{\"1\":{\"1648\":1}}],[\"algorithms\",{\"1\":{\"1620\":3}}],[\"also\",{\"1\":{\"1480\":1,\"1594\":2,\"1615\":1,\"1617\":1,\"1620\":3,\"1621\":1,\"1623\":2,\"1647\":1}}],[\"already\",{\"1\":{\"922\":1,\"1055\":1,\"1167\":1,\"1432\":1,\"1610\":1,\"1618\":1,\"1622\":2,\"1623\":1,\"1647\":3,\"1651\":1}}],[\"alibaba框架开发教程\",{\"1\":{\"1989\":1}}],[\"alibaba<\",{\"1\":{\"582\":1}}],[\"aliasregistry\",{\"1\":{\"1636\":1}}],[\"aliasfor中的注解的属性\",{\"1\":{\"1136\":1}}],[\"aliasfor\",{\"1\":{\"1136\":6,\"1137\":2}}],[\"aliases\",{\"1\":{\"1132\":1}}],[\"alias=\",{\"1\":{\"928\":2}}],[\"alias\",{\"1\":{\"348\":1,\"928\":2,\"1021\":1}}],[\"al\",{\"1\":{\"429\":2}}],[\"always\",{\"1\":{\"417\":1,\"592\":1,\"1598\":4,\"1618\":1,\"1619\":1,\"1620\":1}}],[\"alternatives\",{\"1\":{\"519\":4}}],[\"alter\",{\"1\":{\"350\":2,\"352\":1,\"356\":2,\"368\":1,\"390\":2,\"409\":1,\"417\":1,\"441\":2,\"558\":2,\"559\":1}}],[\"allocation\",{\"1\":{\"1668\":1}}],[\"allocate\",{\"1\":{\"1574\":4,\"1575\":4}}],[\"allocatedirect\",{\"1\":{\"1533\":1,\"1534\":1}}],[\"allowcaching\",{\"1\":{\"1647\":2}}],[\"allowcircularreferences\",{\"1\":{\"1647\":1,\"1649\":1}}],[\"alloweagerinit\",{\"1\":{\"1647\":1}}],[\"allowed\",{\"1\":{\"1277\":1,\"1650\":1}}],[\"allowedfields\",{\"1\":{\"1072\":1}}],[\"allowrawinjectiondespitewrapping\",{\"1\":{\"1647\":1}}],[\"allowing\",{\"1\":{\"1620\":1}}],[\"allow\",{\"1\":{\"1162\":1,\"1171\":2,\"1615\":1,\"1647\":3}}],[\"allows\",{\"1\":{\"922\":1,\"1618\":1,\"1647\":1}}],[\"allkeys\",{\"1\":{\"1300\":2}}],[\"allerrors\",{\"1\":{\"1063\":2}}],[\"allusers\",{\"1\":{\"961\":6}}],[\"all的话\",{\"1\":{\"414\":1}}],[\"all全表扫描\",{\"1\":{\"370\":2}}],[\"all是从磁盘中读取的\",{\"1\":{\"330\":1}}],[\"all\",{\"1\":{\"307\":2,\"329\":1,\"330\":1,\"361\":1,\"390\":2,\"429\":2,\"431\":1,\"922\":1,\"952\":1,\"1009\":1,\"1162\":1,\"1166\":3,\"1170\":1,\"1171\":2,\"1175\":2,\"1328\":1,\"1595\":2,\"1601\":2,\"1615\":1,\"1619\":3,\"1620\":3,\"1621\":2,\"1623\":3,\"1647\":2}}],[\"a排序\",{\"1\":{\"348\":1}}],[\"a开启一个事务\",{\"1\":{\"346\":1}}],[\"a\",{\"1\":{\"339\":2,\"346\":8,\"347\":2,\"348\":5,\"354\":3,\"377\":12,\"401\":4,\"402\":1,\"404\":4,\"407\":1,\"414\":2,\"429\":1,\"462\":3,\"466\":1,\"468\":4,\"484\":2,\"506\":1,\"519\":9,\"523\":2,\"524\":1,\"525\":3,\"534\":1,\"537\":1,\"571\":1,\"577\":1,\"611\":2,\"928\":1,\"963\":2,\"973\":2,\"996\":2,\"997\":4,\"1053\":3,\"1072\":2,\"1123\":1,\"1164\":4,\"1165\":1,\"1166\":2,\"1170\":1,\"1171\":2,\"1404\":2,\"1461\":1,\"1475\":1,\"1479\":2,\"1480\":2,\"1526\":1,\"1550\":1,\"1551\":1,\"1554\":4,\"1587\":1,\"1588\":1,\"1591\":3,\"1594\":17,\"1597\":6,\"1598\":48,\"1599\":28,\"1600\":7,\"1601\":25,\"1603\":3,\"1608\":22,\"1609\":2,\"1613\":5,\"1614\":3,\"1615\":56,\"1616\":4,\"1617\":16,\"1618\":51,\"1619\":32,\"1620\":80,\"1621\":12,\"1622\":3,\"1623\":44,\"1647\":15,\"1648\":2,\"1655\":7,\"1689\":1,\"1974\":1}}],[\"aaa\",{\"1\":{\"1486\":1,\"1487\":1,\"1619\":7}}],[\"aaaaaaac\",{\"1\":{\"368\":5}}],[\"aaaaaaab\",{\"1\":{\"368\":5}}],[\"aaaaaaaa\",{\"1\":{\"368\":4,\"468\":3}}],[\"aa3\",{\"1\":{\"553\":2}}],[\"aa2\",{\"1\":{\"553\":2}}],[\"aa1\",{\"1\":{\"553\":2}}],[\"aa\",{\"1\":{\"336\":1}}],[\"ahead\",{\"1\":{\"324\":1}}],[\"another\",{\"1\":{\"1599\":4,\"1614\":1,\"1618\":1,\"1619\":1,\"1620\":3,\"1623\":1,\"1658\":1}}],[\"anonymoustest\",{\"1\":{\"1591\":2}}],[\"anonymous\",{\"1\":{\"454\":1}}],[\"answer\",{\"1\":{\"1573\":3,\"1574\":1,\"1575\":1}}],[\"anything\",{\"1\":{\"1615\":1,\"1648\":1}}],[\"any\",{\"1\":{\"1162\":1,\"1171\":1,\"1594\":5,\"1615\":6,\"1619\":1,\"1620\":5,\"1622\":1,\"1623\":3,\"1647\":2,\"1689\":1}}],[\"anymore\",{\"1\":{\"922\":1,\"996\":1,\"1647\":1,\"1651\":1}}],[\"antpathmatcher\",{\"1\":{\"1042\":1}}],[\"ant模式匹配实现\",{\"1\":{\"1042\":1}}],[\"antlr从语法生成一个解析器\",{\"1\":{\"513\":1}}],[\"ann\",{\"1\":{\"964\":3,\"1648\":6,\"1654\":3}}],[\"annotated\",{\"1\":{\"1594\":4,\"1647\":1,\"1651\":1}}],[\"annotatedasynceventhandlerdemo\",{\"1\":{\"1123\":2}}],[\"annotatedyamlpropertysourcedemo\",{\"1\":{\"1032\":2}}],[\"annotatedspringioccontainerconfigurationdemo\",{\"1\":{\"1029\":2,\"1031\":1}}],[\"annotatedgenericbeandefinition\",{\"1\":{\"1027\":2,\"1138\":2,\"1632\":1}}],[\"annotatedtypemetadata\",{\"1\":{\"1023\":1,\"1139\":2}}],[\"annotatedbeandefinition中的annotationmetadata有两种具体的实现\",{\"1\":{\"1018\":1}}],[\"annotatedbeandefinitionparsingdemo\",{\"1\":{\"995\":6}}],[\"annotatedbeandefinitionreader可以直接把某个类转换为beandefition\",{\"1\":{\"1633\":1}}],[\"annotatedbeandefinitionreader的实现\",{\"1\":{\"995\":1}}],[\"annotatedbeandefinitionreader\",{\"0\":{\"1633\":1},\"1\":{\"929\":1,\"995\":3,\"1024\":1,\"1027\":1,\"1633\":4,\"1647\":1,\"1651\":1}}],[\"annotatedbeandefinition\",{\"1\":{\"928\":2,\"1018\":1,\"1647\":3}}],[\"annotationtransactionattributesource就是用来判断某个类上是否存在\",{\"1\":{\"1655\":1}}],[\"annotationtransactionattributesource\",{\"1\":{\"1655\":1}}],[\"annotationtype\",{\"1\":{\"1646\":2}}],[\"annotationutils\",{\"1\":{\"1648\":1}}],[\"annotationawareordercomparator\",{\"1\":{\"1641\":1}}],[\"annotationapplicationasioccontainerdemo\",{\"1\":{\"921\":2}}],[\"annotationmetadatareadingvisitor\",{\"1\":{\"1134\":1}}],[\"annotationmetadata\",{\"0\":{\"1646\":1},\"1\":{\"1134\":1,\"1138\":2,\"1646\":3,\"1647\":1}}],[\"annotationconfigutils\",{\"1\":{\"1027\":3,\"1647\":2}}],[\"annotationconfigapplicationcontext\",{\"1\":{\"921\":2,\"929\":2,\"931\":2,\"933\":2,\"934\":2,\"936\":2,\"940\":3,\"943\":5,\"944\":5,\"946\":6,\"953\":4,\"955\":2,\"957\":2,\"961\":6,\"962\":2,\"963\":2,\"973\":2,\"977\":2,\"978\":2,\"985\":6,\"989\":3,\"1029\":2,\"1031\":2,\"1032\":2,\"1044\":2,\"1045\":2,\"1113\":2,\"1116\":4,\"1120\":2,\"1123\":2,\"1134\":2,\"1138\":2,\"1139\":2,\"1148\":2,\"1149\":2,\"1156\":2,\"1181\":2,\"1182\":2,\"1184\":2,\"1632\":2,\"1633\":2,\"1634\":2,\"1635\":2,\"1637\":1,\"1647\":1,\"1651\":1}}],[\"annotationdependencyinjectionresolutiondemo\",{\"1\":{\"963\":4}}],[\"annotationdependencyfiledinjectiondemo\",{\"1\":{\"955\":4}}],[\"annotationdependencysetterinjectiondemo\",{\"1\":{\"953\":2}}],[\"annotation\",{\"1\":{\"952\":1,\"961\":5,\"964\":4,\"965\":4,\"966\":3,\"967\":3,\"1020\":1,\"1031\":2,\"1110\":1,\"1123\":1,\"1133\":1,\"1134\":3,\"1135\":1,\"1136\":2,\"1137\":1,\"1138\":1,\"1139\":10,\"1147\":1,\"1150\":1,\"1152\":1,\"1153\":2,\"1155\":3,\"1171\":1,\"1594\":9,\"1632\":2,\"1637\":1,\"1648\":5,\"1652\":2,\"1655\":1,\"1658\":1}}],[\"annotation>>\",{\"1\":{\"965\":1,\"967\":1}}],[\"annotation>\",{\"1\":{\"941\":2,\"964\":1,\"965\":2,\"1027\":2,\"1654\":1}}],[\"annotationbeandefinitiondemo\",{\"1\":{\"929\":3}}],[\"annotationbeannamegenerator\",{\"1\":{\"928\":1}}],[\"annotations\",{\"1\":{\"921\":1,\"964\":2,\"965\":2,\"1132\":3,\"1135\":1}}],[\"anded\",{\"1\":{\"1599\":2}}],[\"andthen\",{\"1\":{\"1594\":2,\"1597\":1,\"1598\":9,\"1618\":1}}],[\"and\",{\"1\":{\"321\":1,\"330\":2,\"336\":1,\"338\":1,\"340\":2,\"346\":4,\"347\":3,\"348\":3,\"361\":3,\"366\":3,\"368\":3,\"370\":5,\"372\":4,\"373\":4,\"377\":14,\"378\":28,\"404\":1,\"407\":2,\"408\":1,\"409\":1,\"429\":2,\"435\":2,\"454\":1,\"514\":1,\"518\":2,\"536\":1,\"544\":5,\"547\":6,\"549\":4,\"553\":9,\"554\":6,\"555\":12,\"908\":1,\"922\":1,\"965\":1,\"973\":1,\"1132\":1,\"1164\":2,\"1165\":1,\"1166\":1,\"1480\":1,\"1498\":1,\"1594\":3,\"1597\":2,\"1598\":23,\"1599\":15,\"1601\":3,\"1608\":5,\"1611\":1,\"1613\":1,\"1615\":18,\"1616\":2,\"1617\":1,\"1618\":4,\"1619\":19,\"1620\":46,\"1621\":11,\"1622\":2,\"1623\":30,\"1647\":3,\"1650\":1}}],[\"an\",{\"1\":{\"320\":1,\"573\":1,\"580\":1,\"952\":1,\"963\":2,\"996\":1,\"1165\":1,\"1166\":1,\"1175\":1,\"1184\":1,\"1594\":18,\"1595\":4,\"1597\":4,\"1598\":6,\"1599\":4,\"1601\":2,\"1608\":9,\"1609\":2,\"1615\":11,\"1617\":2,\"1618\":3,\"1619\":10,\"1620\":22,\"1621\":6,\"1622\":6,\"1623\":9}}],[\"analyze\",{\"1\":{\"559\":2}}],[\"analyzer\",{\"1\":{\"306\":1,\"309\":1}}],[\"analyzing\",{\"1\":{\"519\":4}}],[\"analysis\",{\"1\":{\"306\":1,\"519\":2}}],[\"acl权限管理器\",{\"0\":{\"1955\":1}}],[\"acl权限控制\",{\"0\":{\"1947\":1}}],[\"aclclientrpchook\",{\"0\":{\"1950\":1}}],[\"across\",{\"1\":{\"1620\":3}}],[\"achieve\",{\"1\":{\"1615\":1}}],[\"acquire\",{\"1\":{\"1404\":5}}],[\"acks\",{\"1\":{\"1328\":1}}],[\"acid\",{\"1\":{\"1262\":1}}],[\"acb\",{\"1\":{\"556\":1}}],[\"accurate\",{\"1\":{\"1620\":2}}],[\"accuracy\",{\"1\":{\"1620\":1}}],[\"accumulation\",{\"1\":{\"1615\":4,\"1618\":1}}],[\"accumulatingsink<t\",{\"1\":{\"1617\":1}}],[\"accumulating\",{\"1\":{\"1615\":1,\"1616\":1}}],[\"accumulated\",{\"1\":{\"1615\":5}}],[\"accumulates\",{\"1\":{\"1615\":2}}],[\"accumulate\",{\"1\":{\"1608\":1,\"1615\":2,\"1616\":2}}],[\"accumulator方法只能进行累积的操作\",{\"1\":{\"1617\":1}}],[\"accumulator是我们要把流中的元素添加到要返回的结果容器当中\",{\"1\":{\"1608\":1}}],[\"accumulator\",{\"1\":{\"1608\":9,\"1615\":21,\"1616\":8,\"1617\":13,\"1618\":10}}],[\"accmulator\",{\"1\":{\"1617\":52}}],[\"according\",{\"1\":{\"1599\":4,\"1601\":5,\"1613\":1,\"1616\":1,\"1618\":1}}],[\"accountnum表示目标账户\",{\"1\":{\"1201\":1}}],[\"accountnum=100\",{\"1\":{\"1201\":2}}],[\"account\",{\"1\":{\"535\":1,\"536\":1}}],[\"accepting\",{\"1\":{\"1613\":1,\"1618\":2,\"1623\":1}}],[\"accepts\",{\"1\":{\"1597\":2,\"1598\":3,\"1615\":1,\"1623\":7}}],[\"acceptsprofiles\",{\"1\":{\"1023\":1,\"1139\":2,\"1147\":1}}],[\"acceptcompletionhandler\",{\"1\":{\"1575\":3}}],[\"accepteither\",{\"1\":{\"1518\":1}}],[\"accept\",{\"1\":{\"1055\":1,\"1167\":1,\"1533\":1,\"1534\":1,\"1573\":2,\"1574\":2,\"1575\":2,\"1594\":7,\"1595\":2,\"1597\":6,\"1608\":3,\"1615\":5,\"1617\":3,\"1618\":4,\"1619\":1,\"1620\":9,\"1622\":3,\"1623\":9,\"1654\":1}}],[\"accesses\",{\"1\":{\"1622\":1}}],[\"accessing\",{\"1\":{\"1620\":1}}],[\"accessibleobject\",{\"1\":{\"964\":1,\"965\":1}}],[\"accesscontroller\",{\"1\":{\"1007\":1,\"1008\":1,\"1647\":2}}],[\"access=on\",{\"1\":{\"405\":1}}],[\"access\",{\"0\":{\"405\":1},\"1\":{\"318\":1,\"519\":7,\"553\":1,\"555\":2,\"1542\":1,\"1619\":2,\"1623\":1,\"1650\":1}}],[\"acess\",{\"1\":{\"405\":1}}],[\"academy\",{\"1\":{\"384\":1}}],[\"actualclass\",{\"1\":{\"1654\":6}}],[\"actualdependentbeans\",{\"1\":{\"1647\":4}}],[\"actually\",{\"1\":{\"1619\":1,\"1647\":2,\"1650\":1}}],[\"actual\",{\"1\":{\"952\":2,\"1175\":1,\"1620\":1}}],[\"action会被适配成intconsumer实例\",{\"1\":{\"1620\":1}}],[\"action会以遇到元素的顺序去执行\",{\"1\":{\"1620\":1}}],[\"actions\",{\"1\":{\"1595\":2,\"1620\":1}}],[\"action\",{\"1\":{\"1593\":1,\"1594\":3,\"1595\":13,\"1620\":39,\"1621\":6,\"1622\":14,\"1623\":5}}],[\"actionperformed\",{\"1\":{\"1591\":1}}],[\"actionlistener\",{\"1\":{\"1591\":3}}],[\"actionevent\",{\"1\":{\"1591\":3}}],[\"actionname表示操作类型\",{\"1\":{\"307\":1}}],[\"actionname\",{\"1\":{\"307\":1}}],[\"active来修改当前的激活环境\",{\"1\":{\"1147\":1}}],[\"active\",{\"1\":{\"609\":1,\"922\":1,\"1162\":3,\"1172\":1,\"1175\":3,\"1623\":3,\"1647\":1,\"1651\":1}}],[\"actory\",{\"1\":{\"1623\":1}}],[\"actor`\",{\"1\":{\"506\":3}}],[\"actor\",{\"1\":{\"384\":5,\"390\":11,\"506\":1,\"509\":3}}],[\"asplatformtransactionmanager\",{\"1\":{\"1655\":1}}],[\"aspect注解扫描到spring容器中\",{\"1\":{\"1654\":1}}],[\"aspect\",{\"0\":{\"819\":1}}],[\"aspect后置动作\",{\"0\":{\"773\":1}}],[\"aspectjannotation<\",{\"1\":{\"1654\":1}}],[\"aspectjawareadvisorautoproxycreator\",{\"0\":{\"811\":1}}],[\"aspectj是在编译期间就增强了对应的方法\",{\"1\":{\"1654\":1}}],[\"aspectjproxyfactory\",{\"0\":{\"808\":1}}],[\"aspectj实现\",{\"0\":{\"787\":1,\"790\":1,\"792\":1}}],[\"aspectj的前置动作\",{\"0\":{\"770\":1}}],[\"aspectj拦截动作\",{\"0\":{\"768\":1}}],[\"aspectj\",{\"0\":{\"765\":1,\"816\":1,\"817\":1},\"1\":{\"899\":1}}],[\"aspectj注解驱动\",{\"0\":{\"762\":1}}],[\"aspectj代理模块\",{\"1\":{\"1138\":1}}],[\"aspectj代理\",{\"0\":{\"759\":1,\"763\":1}}],[\"asflow\",{\"1\":{\"1655\":1}}],[\"asynchronousserversocketchannel>\",{\"1\":{\"1575\":1}}],[\"asynchronousserversocketchannel\",{\"1\":{\"1575\":4}}],[\"asynchronousserversocketchannel由jdk底层线程池负责回调驱动读写操作\",{\"1\":{\"1575\":1}}],[\"asynchronoussocketchannel>\",{\"1\":{\"1575\":1}}],[\"asynchronoussocketchannel\",{\"1\":{\"1575\":8}}],[\"asyncmode\",{\"1\":{\"1510\":2}}],[\"async配合\",{\"1\":{\"1129\":1}}],[\"asynceventhandlerdemo\",{\"1\":{\"1123\":1}}],[\"async\",{\"1\":{\"1113\":1,\"1123\":2,\"1138\":1}}],[\"aslist\",{\"1\":{\"967\":1,\"1593\":6,\"1594\":1,\"1595\":1,\"1597\":2,\"1598\":1,\"1599\":2,\"1602\":1,\"1603\":2,\"1604\":1,\"1605\":2,\"1607\":2,\"1608\":3,\"1609\":9,\"1610\":2,\"1612\":2,\"1613\":1,\"1614\":1,\"1615\":1,\"1617\":2,\"1618\":1,\"1619\":1,\"1620\":1,\"1654\":3}}],[\"assumably\",{\"1\":{\"1647\":1}}],[\"assume\",{\"1\":{\"1620\":1}}],[\"associated\",{\"1\":{\"1618\":2,\"1620\":1,\"1623\":1}}],[\"associative\",{\"1\":{\"1608\":2}}],[\"associativity\",{\"1\":{\"1608\":2,\"1615\":2}}],[\"assignable\",{\"1\":{\"1645\":2}}],[\"assign\",{\"1\":{\"1473\":1,\"1620\":1}}],[\"assistant\",{\"1\":{\"306\":3}}],[\"assert\",{\"1\":{\"928\":1,\"995\":1,\"996\":2,\"1622\":1,\"1623\":1,\"1647\":1,\"1648\":1,\"1658\":3}}],[\"asm实现\",{\"1\":{\"1134\":2}}],[\"asmap\",{\"1\":{\"963\":1,\"1103\":1}}],[\"asm\",{\"1\":{\"899\":1,\"1172\":1,\"1479\":1}}],[\"as\",{\"1\":{\"350\":5,\"367\":1,\"414\":1,\"416\":6,\"417\":2,\"418\":2,\"519\":5,\"554\":10,\"922\":1,\"973\":2,\"1055\":1,\"1103\":1,\"1162\":1,\"1164\":3,\"1166\":1,\"1167\":1,\"1171\":1,\"1172\":1,\"1480\":1,\"1554\":5,\"1594\":5,\"1595\":1,\"1601\":2,\"1608\":4,\"1615\":5,\"1616\":1,\"1617\":1,\"1619\":11,\"1620\":18,\"1621\":2,\"1622\":1,\"1623\":10,\"1647\":3,\"1648\":1}}],[\"ascollection\",{\"1\":{\"963\":1,\"1103\":2}}],[\"asc\",{\"1\":{\"306\":1,\"520\":2}}],[\"arbitrarily\",{\"1\":{\"1620\":1}}],[\"arbitrary\",{\"1\":{\"1620\":4}}],[\"arity\",{\"1\":{\"1598\":1}}],[\"arrayblockingqueue<runnable>\",{\"1\":{\"1573\":1}}],[\"arrayblockingqueue<task>\",{\"1\":{\"1535\":2}}],[\"arrayblockingqueue是典型的有界阻塞队列\",{\"1\":{\"1502\":1}}],[\"arrayblockingqueue\",{\"0\":{\"1502\":1},\"1\":{\"1395\":1,\"1501\":1,\"1502\":2}}],[\"arrays\",{\"1\":{\"963\":1,\"967\":1,\"1475\":1,\"1593\":6,\"1594\":1,\"1595\":1,\"1597\":2,\"1598\":1,\"1599\":2,\"1602\":1,\"1603\":3,\"1604\":1,\"1605\":2,\"1607\":4,\"1608\":1,\"1609\":10,\"1610\":2,\"1612\":2,\"1613\":1,\"1614\":1,\"1615\":1,\"1617\":2,\"1618\":1,\"1619\":2,\"1620\":1,\"1654\":3}}],[\"array\",{\"1\":{\"960\":1,\"1560\":1,\"1607\":3,\"1619\":1,\"1620\":9}}],[\"arraylist中维护了一个object类型的数组elementdata\",{\"1\":{\"1542\":1}}],[\"arraylist源码分析\",{\"0\":{\"1542\":1}}],[\"arraylist并不是线程安全的\",{\"1\":{\"1370\":1}}],[\"arraylist底层使用一个支持自动扩容的数组来保存所有元素\",{\"1\":{\"1370\":1}}],[\"arraylist的扩容机制\",{\"1\":{\"1475\":1}}],[\"arraylist的扩容机制是1\",{\"1\":{\"1358\":1}}],[\"arraylist的实现原理\",{\"0\":{\"42\":1,\"1370\":1}}],[\"arraylist<string>\",{\"1\":{\"1100\":1,\"1608\":1,\"1609\":1}}],[\"arraylist<object>\",{\"1\":{\"1100\":1}}],[\"arraylist<object>是list泛型参数类型的具体化\",{\"1\":{\"1100\":1}}],[\"arraylist<>\",{\"1\":{\"645\":1,\"975\":1,\"996\":1,\"1166\":6,\"1365\":1,\"1517\":1,\"1611\":1,\"1612\":1,\"1647\":1,\"1648\":2,\"1654\":1}}],[\"arraylist\",{\"1\":{\"645\":2,\"1099\":1,\"1103\":2,\"1539\":1,\"1608\":13,\"1609\":1,\"1618\":2,\"1620\":1}}],[\"arm\",{\"1\":{\"891\":1}}],[\"around等注解的方法\",{\"1\":{\"1654\":1}}],[\"around\",{\"0\":{\"821\":1},\"1\":{\"1654\":1}}],[\"arg\",{\"1\":{\"954\":1,\"1108\":2,\"1650\":1}}],[\"argumenttypes\",{\"1\":{\"1100\":2}}],[\"argumentindex\",{\"1\":{\"1053\":1}}],[\"arguments\",{\"1\":{\"927\":1,\"1598\":2,\"1599\":6,\"1601\":2,\"1608\":2,\"1615\":1}}],[\"argument\",{\"1\":{\"597\":2,\"964\":1,\"1597\":4,\"1598\":12,\"1599\":8,\"1601\":2,\"1615\":3,\"1620\":1}}],[\"args\",{\"1\":{\"580\":1,\"582\":2,\"909\":1,\"917\":1,\"918\":1,\"919\":1,\"921\":2,\"927\":1,\"929\":1,\"930\":3,\"931\":1,\"933\":1,\"934\":1,\"936\":1,\"940\":1,\"943\":1,\"944\":1,\"946\":3,\"953\":3,\"954\":1,\"955\":1,\"957\":1,\"961\":3,\"962\":1,\"963\":1,\"973\":1,\"977\":1,\"978\":1,\"985\":2,\"989\":1,\"994\":1,\"995\":1,\"997\":1,\"1000\":1,\"1001\":1,\"1005\":1,\"1006\":1,\"1011\":1,\"1019\":1,\"1022\":1,\"1029\":1,\"1030\":1,\"1031\":1,\"1032\":2,\"1040\":1,\"1041\":1,\"1043\":1,\"1044\":1,\"1045\":1,\"1050\":1,\"1053\":2,\"1056\":2,\"1063\":1,\"1064\":1,\"1065\":1,\"1072\":2,\"1075\":1,\"1082\":1,\"1084\":1,\"1099\":1,\"1100\":1,\"1103\":1,\"1108\":1,\"1112\":1,\"1113\":1,\"1116\":1,\"1119\":1,\"1120\":1,\"1123\":2,\"1134\":1,\"1138\":1,\"1139\":1,\"1146\":1,\"1148\":1,\"1149\":1,\"1156\":1,\"1174\":1,\"1175\":1,\"1181\":1,\"1182\":1,\"1184\":1,\"1227\":2,\"1365\":1,\"1387\":1,\"1404\":3,\"1479\":1,\"1487\":1,\"1521\":1,\"1535\":1,\"1551\":1,\"1587\":1,\"1588\":1,\"1591\":3,\"1592\":1,\"1593\":6,\"1594\":1,\"1595\":6,\"1597\":2,\"1598\":6,\"1599\":4,\"1600\":3,\"1601\":1,\"1602\":1,\"1603\":2,\"1604\":2,\"1605\":2,\"1606\":2,\"1607\":10,\"1608\":3,\"1609\":11,\"1610\":8,\"1612\":3,\"1613\":1,\"1614\":1,\"1615\":1,\"1617\":2,\"1619\":2,\"1620\":2,\"1646\":1,\"1647\":15,\"1650\":5,\"1654\":6}}],[\"artifact\",{\"1\":{\"1037\":1}}],[\"artifacts\",{\"1\":{\"899\":1,\"900\":1}}],[\"artifactid>\",{\"1\":{\"582\":2,\"583\":1,\"965\":1}}],[\"article\",{\"1\":{\"307\":11,\"330\":1,\"361\":14,\"561\":1,\"1649\":1}}],[\"ar\",{\"1\":{\"429\":2}}],[\"area\",{\"1\":{\"1457\":1}}],[\"are\",{\"1\":{\"429\":1,\"1162\":1,\"1594\":4,\"1595\":4,\"1599\":8,\"1601\":2,\"1608\":6,\"1613\":1,\"1615\":5,\"1616\":1,\"1618\":3,\"1619\":11,\"1620\":17,\"1621\":4,\"1623\":6,\"1647\":1,\"1689\":1}}],[\"architect\",{\"1\":{\"306\":2}}],[\"锁住链表或者红黑树的头结点\",{\"1\":{\"1554\":1}}],[\"锁住的是两个值之间的空隙\",{\"1\":{\"536\":1}}],[\"锁分离\",{\"1\":{\"1503\":1}}],[\"锁降级中的读锁获取是否必要呢\",{\"1\":{\"1498\":1}}],[\"锁降级\",{\"1\":{\"1498\":1}}],[\"锁粗化\",{\"0\":{\"1486\":1,\"1822\":1},\"1\":{\"1486\":1}}],[\"锁升级过程\",{\"1\":{\"1485\":1}}],[\"锁不仅不存在多线程竞争\",{\"1\":{\"1485\":1}}],[\"锁状态标志\",{\"1\":{\"1484\":2}}],[\"锁消除是java虚拟机在jit编译期间\",{\"1\":{\"1487\":1}}],[\"锁消除即删除不必要的加锁操作\",{\"1\":{\"1487\":1}}],[\"锁消除\",{\"0\":{\"1487\":1,\"1821\":1},\"1\":{\"1483\":1,\"1487\":1}}],[\"锁一定的范围\",{\"1\":{\"1263\":1}}],[\"锁一条具体的数据\",{\"1\":{\"1263\":1}}],[\"锁一条记录及其间隙\",{\"1\":{\"442\":1}}],[\"锁表或锁行\",{\"1\":{\"1248\":1}}],[\"锁优化\",{\"0\":{\"1819\":1}}],[\"锁优化技术主要有锁消除与锁粗化两种\",{\"1\":{\"1393\":1}}],[\"锁优化技术你了解什么\",{\"0\":{\"64\":1,\"1393\":1}}],[\"锁优化建议\",{\"0\":{\"539\":1}}],[\"锁主要是加在索引上\",{\"1\":{\"537\":1}}],[\"锁定\",{\"1\":{\"1473\":1}}],[\"锁定某一行还可以用lock\",{\"1\":{\"537\":1}}],[\"锁定粒度最小\",{\"1\":{\"535\":1}}],[\"锁定粒度大\",{\"1\":{\"534\":1}}],[\"锁定时间\",{\"1\":{\"429\":1}}],[\"锁冲突也是影响数据库并发访问性能的一个重要因素\",{\"1\":{\"533\":1}}],[\"锁是计算机协调多个进程或线程并发访问某一资源的机制\",{\"1\":{\"533\":1}}],[\"锁的粗化和锁的消除\",{\"1\":{\"1489\":1}}],[\"锁的重入次数\",{\"1\":{\"1483\":1}}],[\"锁的粒度更小了\",{\"1\":{\"1475\":1}}],[\"锁的具体类型\",{\"1\":{\"1394\":1}}],[\"锁的释放方式\",{\"1\":{\"1394\":1}}],[\"锁的获取方式\",{\"1\":{\"1394\":1}}],[\"锁的就是两个值之间的空隙\",{\"1\":{\"448\":1}}],[\"锁的设计是为了保证数据的一致性\",{\"1\":{\"447\":1}}],[\"锁两个记录之间的gap\",{\"1\":{\"442\":1}}],[\"锁等待\",{\"1\":{\"381\":1}}],[\"锁机制是如何升级的\",{\"0\":{\"68\":1,\"1397\":1}}],[\"重要概念\",{\"0\":{\"1741\":1}}],[\"重要消息\",{\"1\":{\"574\":1}}],[\"重新设置范围\",{\"1\":{\"1620\":1}}],[\"重新运行起来\",{\"1\":{\"1563\":1}}],[\"重新计时\",{\"1\":{\"1485\":1}}],[\"重新标记\",{\"0\":{\"1736\":1},\"1\":{\"1447\":1}}],[\"重新写入缓存需要一定的时间\",{\"1\":{\"1283\":1}}],[\"重操作\",{\"1\":{\"1421\":1}}],[\"重量级锁竞争的时候\",{\"1\":{\"1485\":1}}],[\"重量级锁阻塞挂起的方法\",{\"1\":{\"1483\":1}}],[\"重量级锁及锁机制具体如下图\",{\"1\":{\"1397\":1}}],[\"重量级锁对应不同锁状态\",{\"1\":{\"1397\":1}}],[\"重量级锁有什么区别\",{\"0\":{\"68\":1,\"1397\":1}}],[\"重写的spliterator中的tryadvance方法\",{\"1\":{\"1620\":1}}],[\"重写的ofprimitive中的tryadvance方法\",{\"1\":{\"1620\":1}}],[\"重写的类需要文档化spliterator的绑定策略\",{\"1\":{\"1620\":1}}],[\"重写run方法\",{\"1\":{\"1377\":1,\"1591\":1}}],[\"重写hashcode和equals\",{\"1\":{\"1366\":1}}],[\"重写这个方法\",{\"1\":{\"1108\":1}}],[\"重写这个复杂的查询\",{\"1\":{\"390\":1}}],[\"重载发生在同一个类中\",{\"1\":{\"1339\":1}}],[\"重载\",{\"1\":{\"1062\":2}}],[\"重载和重写的区别\",{\"0\":{\"10\":1,\"1339\":1}}],[\"重置为fasle\",{\"1\":{\"1477\":1}}],[\"重置format\",{\"1\":{\"1053\":1}}],[\"重置locale\",{\"1\":{\"1053\":1}}],[\"重置messageformatpattern\",{\"1\":{\"1053\":1}}],[\"重置java\",{\"1\":{\"1053\":2}}],[\"重置消息格式模板\",{\"1\":{\"1053\":1}}],[\"重置pathmatcher\",{\"1\":{\"1043\":1}}],[\"重启也不会重置为0\",{\"1\":{\"497\":1}}],[\"重启之后就会清零\",{\"1\":{\"496\":1}}],[\"重启的时候依靠redo\",{\"1\":{\"490\":1}}],[\"重启后这个表的auto\",{\"1\":{\"490\":1}}],[\"重启后需要从存储redis数据的地方把这个值读回来\",{\"1\":{\"397\":1}}],[\"重启备库\",{\"1\":{\"485\":1}}],[\"重命名临时表\",{\"0\":{\"412\":1}}],[\"重构查询\",{\"0\":{\"391\":1}}],[\"重复调用trysplit最终得到的结果一定是空\",{\"1\":{\"1620\":1}}],[\"重复支付同一笔订单只能扣一次钱\",{\"1\":{\"1248\":1}}],[\"重复次数目前默认为10\",{\"1\":{\"624\":1}}],[\"重复设置field进行覆盖\",{\"1\":{\"573\":1}}],[\"重复设置同一个field会覆盖\",{\"1\":{\"573\":1}}],[\"重复3\",{\"1\":{\"520\":1}}],[\"重复第二步\",{\"1\":{\"421\":1}}],[\"重复执行步骤1到3\",{\"1\":{\"401\":1}}],[\"重复执行步骤2\",{\"1\":{\"356\":1}}],[\"重复查询相同的数据\",{\"0\":{\"386\":1}}],[\"重复步骤2\",{\"1\":{\"356\":1,\"520\":1}}],[\"重复步骤3\",{\"1\":{\"354\":1,\"355\":1}}],[\"重复上一步\",{\"1\":{\"350\":1}}],[\"重复相同的判断逻辑\",{\"1\":{\"322\":1}}],[\"重放到中午误删表之前的那个时刻\",{\"1\":{\"327\":1}}],[\"重做日志\",{\"0\":{\"324\":1},\"1\":{\"323\":1}}],[\"重建索引\",{\"1\":{\"309\":1}}],[\"ljava\",{\"1\":{\"1609\":4}}],[\"l选项只统计行数\",{\"1\":{\"1464\":1}}],[\"l命令用于统计行数\",{\"1\":{\"1464\":1}}],[\"lfu\",{\"1\":{\"1300\":2}}],[\"ltrim\",{\"1\":{\"571\":3}}],[\"lpop\",{\"1\":{\"571\":4}}],[\"lpushx失败\",{\"1\":{\"571\":1}}],[\"lpushx\",{\"1\":{\"571\":5}}],[\"lpush\",{\"1\":{\"571\":8}}],[\"llen\",{\"1\":{\"571\":3}}],[\"lru\",{\"1\":{\"645\":1,\"1300\":3}}],[\"lru收回\",{\"1\":{\"568\":1}}],[\"lrem\",{\"1\":{\"571\":4}}],[\"lrange\",{\"1\":{\"571\":14}}],[\"lua脚本\",{\"1\":{\"568\":1}}],[\"lucene\",{\"1\":{\"1986\":2}}],[\"lucene实现的倒排索引\",{\"1\":{\"309\":1}}],[\"lucy\",{\"1\":{\"510\":1,\"518\":1,\"535\":1}}],[\"large\",{\"1\":{\"1620\":1}}],[\"larger\",{\"1\":{\"1620\":1}}],[\"largest\",{\"1\":{\"429\":1}}],[\"layer\",{\"1\":{\"1424\":1}}],[\"laziness\",{\"1\":{\"1620\":1}}],[\"lazt\",{\"1\":{\"1020\":1}}],[\"lazyinit\",{\"1\":{\"1632\":1}}],[\"lazy或者\",{\"1\":{\"1027\":1}}],[\"lazyuser\",{\"1\":{\"963\":1}}],[\"lazy注解的作用\",{\"1\":{\"1649\":1}}],[\"lazy注解\",{\"1\":{\"963\":1,\"1237\":2,\"1648\":1}}],[\"lazyannotationdependencyinjectiondemo\",{\"1\":{\"962\":4}}],[\"lazy\",{\"1\":{\"922\":1,\"927\":1,\"932\":3,\"963\":1,\"1009\":1,\"1020\":1,\"1022\":1,\"1027\":1,\"1171\":1,\"1181\":1,\"1554\":1,\"1619\":1,\"1633\":1,\"1647\":1}}],[\"late\",{\"1\":{\"1620\":12,\"1621\":1}}],[\"later\",{\"1\":{\"997\":1,\"1647\":1}}],[\"latch\",{\"1\":{\"1490\":1}}],[\"latitude\",{\"1\":{\"576\":2}}],[\"latin1\",{\"1\":{\"424\":1}}],[\"lang\",{\"1\":{\"909\":6,\"930\":1,\"1027\":1,\"1037\":1,\"1075\":1,\"1085\":1,\"1099\":13,\"1375\":1,\"1443\":1,\"1477\":1,\"1544\":1,\"1560\":5,\"1594\":6,\"1609\":4,\"1610\":1,\"1617\":1,\"1619\":4,\"1663\":2}}],[\"language\",{\"1\":{\"892\":1,\"1594\":2,\"1683\":1}}],[\"lambda$main$1\",{\"1\":{\"1619\":1}}],[\"lambda$main$0\",{\"1\":{\"1619\":2}}],[\"lambdatest$1\",{\"1\":{\"1592\":1}}],[\"lambdatest\",{\"1\":{\"1592\":7,\"1593\":6,\"1594\":1,\"1595\":1,\"1597\":2}}],[\"lambda创建100000个花费的总毫秒值\",{\"1\":{\"1591\":1}}],[\"lambda表达式在大多数的场景下\",{\"1\":{\"1607\":1}}],[\"lambda表达式在简化代码上\",{\"1\":{\"1591\":1}}],[\"lambda表达式其实是一种更为通用的形式\",{\"1\":{\"1603\":1}}],[\"lambda表达式需要依赖于函数式接口这样一种特殊的形式\",{\"1\":{\"1595\":1}}],[\"lambda表达式是对象\",{\"1\":{\"1593\":1}}],[\"lambda表达式的类型是函数\",{\"1\":{\"1593\":1}}],[\"lambda表达式往往与stream相互配合\",{\"1\":{\"1593\":1}}],[\"lambda表达式和stream\",{\"0\":{\"1593\":1}}],[\"lambda表达式和匿名内部类\",{\"0\":{\"1592\":1}}],[\"lambda表达式就是一种全新的语法\",{\"1\":{\"1592\":1}}],[\"lambda表达式看起来特别像是java中匿名内部类的一种特殊写法\",{\"1\":{\"1592\":1}}],[\"lambda表达式\",{\"1\":{\"1349\":1}}],[\"lambda\",{\"1\":{\"900\":1,\"1591\":2,\"1594\":2,\"1605\":1,\"1619\":2}}],[\"lambda语法\",{\"1\":{\"891\":1}}],[\"lastnamesbycity\",{\"1\":{\"1618\":1}}],[\"last指向入队元素\",{\"1\":{\"1503\":1}}],[\"last\",{\"1\":{\"429\":1,\"558\":1,\"588\":1,\"922\":1,\"1503\":4,\"1618\":1,\"1623\":1,\"1647\":1}}],[\"l7都满足\",{\"1\":{\"350\":1}}],[\"l7\",{\"1\":{\"350\":1}}],[\"l6\",{\"1\":{\"350\":1}}],[\"l5\",{\"1\":{\"350\":1}}],[\"l4\",{\"1\":{\"350\":1}}],[\"l\",{\"1\":{\"350\":1,\"368\":9,\"429\":3,\"1464\":1}}],[\"lset\",{\"1\":{\"571\":3}}],[\"lsn也会写到innodb的数据页中\",{\"1\":{\"451\":1}}],[\"lsn的值就会加上length\",{\"1\":{\"451\":1}}],[\"lsn是单调递增的\",{\"1\":{\"451\":1}}],[\"lsn\",{\"1\":{\"451\":1}}],[\"ls\",{\"1\":{\"330\":1}}],[\"leetcode热题100\",{\"1\":{\"1972\":1}}],[\"leetcode\",{\"0\":{\"1970\":1},\"1\":{\"1966\":1,\"1972\":1}}],[\"lexicographic\",{\"1\":{\"1614\":1}}],[\"let\",{\"1\":{\"997\":1,\"1170\":1,\"1175\":1,\"1647\":1}}],[\"lettuce\",{\"1\":{\"583\":2}}],[\"lead\",{\"1\":{\"1655\":2}}],[\"leader\",{\"1\":{\"606\":1,\"624\":1}}],[\"leaf\",{\"1\":{\"1620\":1,\"1623\":1}}],[\"leak\",{\"1\":{\"1451\":1}}],[\"leave\",{\"1\":{\"1170\":1}}],[\"least\",{\"1\":{\"429\":1,\"1061\":1,\"1300\":2,\"1333\":1,\"1647\":1}}],[\"lesser\",{\"1\":{\"1601\":3}}],[\"less\",{\"1\":{\"424\":4,\"1689\":1}}],[\"left\",{\"1\":{\"350\":4,\"371\":1,\"429\":1,\"509\":1,\"571\":1,\"1608\":3,\"1615\":3,\"1618\":9}}],[\"levels\",{\"1\":{\"1036\":1}}],[\"level来控制到底是不是用这些启发式规则\",{\"1\":{\"556\":1}}],[\"level\",{\"1\":{\"330\":3,\"928\":1,\"1025\":1,\"1172\":1,\"1262\":3,\"1621\":1}}],[\"len中\",{\"1\":{\"378\":2}}],[\"length取余\",{\"1\":{\"1548\":1}}],[\"length的二进制就是一个1后面n个0\",{\"1\":{\"1548\":1}}],[\"length这两种运算结果式等价的\",{\"1\":{\"1548\":1}}],[\"lengthfieldbasedframedecoder\",{\"0\":{\"728\":1}}],[\"length可以聚簇索引的页面数量\",{\"1\":{\"548\":1}}],[\"length\",{\"1\":{\"355\":1,\"421\":3,\"520\":7,\"548\":2,\"553\":1,\"555\":2,\"1061\":7,\"1166\":1,\"1347\":2,\"1357\":3,\"1480\":1,\"1485\":1,\"1502\":3,\"1548\":5,\"1549\":2,\"1550\":2,\"1553\":2,\"1554\":5,\"1574\":2,\"1575\":2,\"1599\":1,\"1601\":2,\"1607\":1,\"1608\":2,\"1612\":8,\"1614\":17,\"1620\":3,\"1623\":1,\"1647\":1,\"1648\":1,\"1654\":1}}],[\"len计算规则\",{\"1\":{\"330\":1}}],[\"len是根据表定义计算而得\",{\"1\":{\"330\":1}}],[\"len显示的值为索引字段的最大可能长度\",{\"1\":{\"330\":1}}],[\"len\",{\"1\":{\"329\":1,\"330\":7,\"361\":1,\"390\":2}}],[\"lotail\",{\"1\":{\"1550\":6}}],[\"lohead\",{\"1\":{\"1550\":3}}],[\"lombok\",{\"1\":{\"1479\":1}}],[\"loadfactor=0\",{\"1\":{\"1551\":1}}],[\"loadfactor\",{\"1\":{\"1546\":1,\"1550\":2}}],[\"loadclass\",{\"1\":{\"1432\":2,\"1663\":2}}],[\"loader\",{\"1\":{\"1164\":1,\"1432\":2,\"1663\":2}}],[\"loaded\",{\"1\":{\"1022\":1,\"1432\":1}}],[\"loading\",{\"1\":{\"1022\":1}}],[\"loadtimeweaveraware\",{\"1\":{\"1171\":2}}],[\"loadtimeweaverawareprocessor\",{\"1\":{\"1164\":1,\"1165\":1}}],[\"loadtimeweaver\",{\"1\":{\"1020\":1,\"1164\":1,\"1165\":1}}],[\"loadbalanced注解的实现\",{\"1\":{\"961\":1}}],[\"loadbalanced\",{\"1\":{\"961\":2}}],[\"loadbeandefinitionsforbeanmethod方法中\",{\"1\":{\"1183\":1}}],[\"loadbeandefinitions\",{\"1\":{\"921\":1,\"953\":3,\"954\":1,\"955\":1,\"961\":3,\"962\":1,\"963\":1,\"994\":1,\"997\":1,\"1000\":1,\"1001\":1,\"1005\":1,\"1006\":1,\"1011\":1,\"1022\":3,\"1030\":1,\"1032\":1,\"1163\":2,\"1634\":1,\"1651\":1}}],[\"load\",{\"1\":{\"930\":1,\"1020\":1,\"1022\":2,\"1082\":1,\"1084\":1,\"1164\":1,\"1165\":1,\"1473\":1,\"1475\":1,\"1550\":1,\"1554\":1}}],[\"look\",{\"1\":{\"963\":1}}],[\"lookup注解的时候\",{\"1\":{\"1650\":1}}],[\"lookup注解的方法\",{\"1\":{\"1647\":1}}],[\"lookup注解有关\",{\"1\":{\"1647\":1}}],[\"lookupenvironmentdemo\",{\"1\":{\"1149\":4}}],[\"lookupifavailable\",{\"1\":{\"943\":2}}],[\"lookupinlazy\",{\"1\":{\"917\":2}}],[\"lookupinrealtime\",{\"1\":{\"917\":2}}],[\"lookupbystreamops\",{\"1\":{\"943\":2}}],[\"lookupbyobejctprovider\",{\"1\":{\"940\":2,\"943\":2}}],[\"lookupbyannotationtype\",{\"1\":{\"917\":2,\"941\":1}}],[\"lookupbytype\",{\"1\":{\"917\":2}}],[\"lookupcollectiontype\",{\"1\":{\"917\":2,\"921\":4,\"941\":1}}],[\"lookup\",{\"1\":{\"917\":1,\"918\":1,\"921\":1,\"924\":1,\"939\":1,\"953\":4,\"954\":2,\"955\":1,\"961\":3,\"962\":1,\"963\":1,\"997\":1,\"1000\":1,\"1001\":1,\"1005\":2,\"1006\":1,\"1011\":1,\"1029\":1,\"1647\":1}}],[\"loop\",{\"0\":{\"401\":1,\"402\":1,\"403\":1},\"1\":{\"401\":1,\"402\":3,\"403\":7,\"523\":2,\"524\":1,\"555\":1,\"1227\":4}}],[\"lo\",{\"1\":{\"570\":1,\"1620\":4}}],[\"lowest\",{\"1\":{\"966\":1,\"967\":1}}],[\"lowestscore\",{\"1\":{\"574\":2}}],[\"low\",{\"1\":{\"542\":3,\"1621\":1}}],[\"longs\",{\"1\":{\"1623\":2}}],[\"longstream\",{\"1\":{\"1619\":2}}],[\"longeststringlengthstartingwitha\",{\"1\":{\"1623\":1}}],[\"longpipeline\",{\"1\":{\"1621\":1}}],[\"longpredicate\",{\"1\":{\"1601\":1}}],[\"long>\",{\"1\":{\"1613\":1}}],[\"longaccumulate的流程图如下\",{\"1\":{\"1480\":1}}],[\"longaccumulate\",{\"1\":{\"1480\":1}}],[\"longaccumulator\",{\"1\":{\"1480\":1}}],[\"longadder内部有一个base变量\",{\"1\":{\"1480\":1}}],[\"longadder和doubleadder在高并发的情况下\",{\"1\":{\"1480\":1}}],[\"longadder\",{\"1\":{\"1480\":2}}],[\"longitude\",{\"1\":{\"576\":1}}],[\"longitud\",{\"1\":{\"576\":1}}],[\"longtext\",{\"1\":{\"530\":1}}],[\"longblob\",{\"1\":{\"530\":1}}],[\"long\",{\"1\":{\"346\":1,\"428\":5,\"645\":8,\"959\":1,\"1053\":4,\"1099\":1,\"1184\":3,\"1288\":4,\"1432\":2,\"1476\":1,\"1479\":1,\"1480\":3,\"1487\":2,\"1501\":2,\"1526\":1,\"1554\":4,\"1591\":6,\"1612\":3,\"1613\":1,\"1614\":1,\"1617\":1,\"1620\":10,\"1622\":1,\"1623\":2,\"1663\":2}}],[\"logic\",{\"1\":{\"1615\":1}}],[\"logically\",{\"1\":{\"1599\":4}}],[\"logical\",{\"1\":{\"1599\":12}}],[\"login\",{\"1\":{\"1061\":3}}],[\"log4j在内的很多知名项目都应用了disruptor以获取高性能\",{\"1\":{\"1519\":1}}],[\"logger\",{\"1\":{\"922\":2,\"964\":2,\"965\":1,\"996\":6,\"1007\":2,\"1022\":4,\"1055\":4,\"1121\":4,\"1167\":4,\"1168\":4,\"1175\":4,\"1647\":7,\"1648\":6,\"1651\":2,\"1655\":2}}],[\"logging\",{\"1\":{\"324\":1,\"561\":1}}],[\"log成为一条记录版本先行表\",{\"1\":{\"542\":1}}],[\"log了\",{\"1\":{\"542\":1}}],[\"log实际上就是存在rollback\",{\"1\":{\"542\":1}}],[\"log主要分为3种\",{\"1\":{\"542\":1}}],[\"log主要节省的是随机写磁盘的io消耗\",{\"1\":{\"345\":1}}],[\"log归档\",{\"0\":{\"516\":1}}],[\"log恢复重启之前的值\",{\"1\":{\"490\":1}}],[\"log中的db\",{\"1\":{\"542\":1}}],[\"log中有当前行的拷贝副本\",{\"1\":{\"542\":1}}],[\"log中\",{\"1\":{\"490\":1,\"542\":2}}],[\"log和bin\",{\"1\":{\"484\":1}}],[\"log和binlog有一个共同的字段叫做xid\",{\"1\":{\"496\":1}}],[\"log和binlog有以下区别\",{\"1\":{\"325\":1}}],[\"log和binlog这两个统计信息\",{\"1\":{\"479\":1}}],[\"log和binlog中的事务\",{\"1\":{\"472\":1}}],[\"log和binlog都可以用于表示事务的提交状态\",{\"1\":{\"327\":1}}],[\"log和binlog时两个独立的逻辑\",{\"1\":{\"327\":1}}],[\"log对应的是event\",{\"1\":{\"479\":1}}],[\"log里\",{\"1\":{\"479\":1}}],[\"log里读了多少字节\",{\"1\":{\"479\":1}}],[\"log里面的某个版本的数据\",{\"1\":{\"542\":1}}],[\"log里面\",{\"1\":{\"324\":1,\"326\":1}}],[\"log操作的时间统计\",{\"1\":{\"479\":1}}],[\"log组提交\",{\"1\":{\"464\":1}}],[\"log其实有三种格式\",{\"1\":{\"454\":1}}],[\"log做fsync的时间拖到了步骤1之后\",{\"1\":{\"451\":1}}],[\"log在commit的时候就不需要fsync了\",{\"1\":{\"451\":1}}],[\"log在prepaer阶段就要持久化一次\",{\"1\":{\"451\":1}}],[\"log到buffer中\",{\"1\":{\"451\":1}}],[\"log也会被后台线程一起持久化到磁盘\",{\"1\":{\"451\":1}}],[\"log也就是直接写在redo\",{\"1\":{\"451\":1}}],[\"log写到文件系统的page\",{\"1\":{\"451\":1}}],[\"log写入到磁盘中\",{\"1\":{\"451\":1}}],[\"log写入到page\",{\"1\":{\"451\":1}}],[\"log写完之后\",{\"1\":{\"327\":1}}],[\"log写完\",{\"1\":{\"327\":1}}],[\"log直接持久化到磁盘\",{\"1\":{\"451\":1}}],[\"log留在redo\",{\"1\":{\"451\":1}}],[\"log的链首就是最新的旧记录\",{\"1\":{\"542\":1}}],[\"log的最前面\",{\"1\":{\"542\":1}}],[\"log的副本记录\",{\"1\":{\"542\":2}}],[\"log的时间监控\",{\"1\":{\"479\":1}}],[\"log的各个字段完全相同\",{\"1\":{\"479\":1}}],[\"log的\",{\"1\":{\"478\":1}}],[\"log的两阶段提交中\",{\"1\":{\"465\":1}}],[\"log的三种格式\",{\"0\":{\"454\":1}}],[\"log的三种状态有关\",{\"1\":{\"451\":1}}],[\"log的效果那么好\",{\"1\":{\"451\":1}}],[\"log的一个个写入点\",{\"1\":{\"451\":1}}],[\"log的写入时间\",{\"1\":{\"479\":1}}],[\"log的写入策略\",{\"1\":{\"451\":1}}],[\"log的写入机制\",{\"0\":{\"450\":1,\"451\":1}}],[\"log的写入拆成了两个步骤\",{\"1\":{\"326\":1}}],[\"log会先写入到redo\",{\"1\":{\"451\":1}}],[\"logstash\",{\"1\":{\"1257\":1,\"1310\":1}}],[\"logstash与filebeat详解以及efk整合\",{\"0\":{\"313\":1}}],[\"logs\",{\"1\":{\"429\":1,\"1166\":1}}],[\"log=on\",{\"1\":{\"428\":1}}],[\"log2m\",{\"1\":{\"401\":1}}],[\"logn\",{\"1\":{\"333\":2,\"334\":3,\"1265\":2}}],[\"log还没写\",{\"1\":{\"327\":1}}],[\"log后写binlog\",{\"1\":{\"327\":1}}],[\"log再写binlog\",{\"1\":{\"327\":1}}],[\"log改成提交\",{\"1\":{\"326\":1}}],[\"log处于prepare状态\",{\"1\":{\"326\":1}}],[\"log是两个比较容易混淆的概念\",{\"1\":{\"345\":1}}],[\"log是循环写的\",{\"1\":{\"325\":1}}],[\"log是物理日志\",{\"1\":{\"325\":1}}],[\"log是innodb引擎所特有的\",{\"1\":{\"325\":1}}],[\"log是innodb引擎特有的日志\",{\"1\":{\"325\":1}}],[\"log是固定大小的\",{\"1\":{\"324\":1}}],[\"log\",{\"0\":{\"345\":1},\"1\":{\"323\":1,\"324\":1,\"325\":1,\"326\":1,\"327\":1,\"345\":3,\"346\":1,\"420\":1,\"428\":9,\"429\":6,\"451\":27,\"453\":1,\"455\":1,\"457\":1,\"460\":1,\"465\":1,\"467\":10,\"468\":2,\"472\":8,\"479\":2,\"484\":1,\"542\":6,\"1479\":7}}],[\"localvariabletableparameternamediscoverer\",{\"1\":{\"1648\":1}}],[\"localvalidatorfactorybean\",{\"1\":{\"1065\":3,\"1068\":1}}],[\"locally\",{\"1\":{\"997\":1}}],[\"local\",{\"1\":{\"989\":2,\"1162\":1,\"1175\":1,\"1668\":1}}],[\"locale\",{\"1\":{\"959\":1,\"1050\":1,\"1053\":2,\"1063\":3,\"1064\":1}}],[\"localhost\",{\"1\":{\"322\":1}}],[\"locationpattern\",{\"1\":{\"1043\":2}}],[\"locations\",{\"1\":{\"1001\":2,\"1005\":4,\"1006\":2,\"1011\":2,\"1620\":2}}],[\"location\",{\"1\":{\"921\":2,\"994\":2,\"997\":2,\"1000\":2,\"1022\":2,\"1146\":2}}],[\"locator\",{\"1\":{\"906\":1}}],[\"lock模式\",{\"1\":{\"1530\":1}}],[\"lockinterruptibly\",{\"1\":{\"1502\":2,\"1503\":2}}],[\"lockinterruptibly方法是可以被中断的\",{\"1\":{\"1495\":1}}],[\"lockeliminationtest\",{\"1\":{\"1487\":3}}],[\"locked\",{\"1\":{\"431\":1,\"1480\":1,\"1484\":1}}],[\"lock前缀指令会等待它之前所有的指令完成\",{\"1\":{\"1473\":1}}],[\"lock前缀指令具有类似内存屏障的功能\",{\"1\":{\"1473\":1}}],[\"lock前缀指令的作用\",{\"1\":{\"1473\":1}}],[\"lock提供了多种\",{\"1\":{\"1394\":1}}],[\"lock务必通过unlock\",{\"1\":{\"1394\":1}}],[\"lock是通过java代码的方式来实现\",{\"1\":{\"1394\":1}}],[\"lock是通过程序代码的方式由开发者手工获取\",{\"1\":{\"1394\":1}}],[\"lock是前后闭区间\",{\"1\":{\"448\":1}}],[\"lock可以解决可见性的问题\",{\"1\":{\"1373\":1}}],[\"lock可以解决原子性的问题\",{\"1\":{\"1373\":1}}],[\"locktime\",{\"1\":{\"1288\":1}}],[\"locksupport\",{\"1\":{\"1477\":1,\"1479\":2}}],[\"locks\",{\"1\":{\"538\":1,\"1479\":1,\"1498\":1}}],[\"locks表里\",{\"1\":{\"497\":1}}],[\"lock\",{\"1\":{\"420\":1,\"429\":3,\"431\":1,\"437\":1,\"439\":1,\"440\":1,\"441\":1,\"442\":5,\"444\":2,\"448\":3,\"492\":3,\"534\":1,\"537\":1,\"538\":10,\"541\":1,\"997\":1,\"1263\":2,\"1283\":1,\"1473\":2,\"1479\":3,\"1482\":4,\"1484\":1,\"1502\":12,\"1503\":2,\"1530\":1,\"1554\":1,\"1647\":1}}],[\"lock与synchronized有什么区别\",{\"0\":{\"65\":1,\"1394\":1}}],[\"lost\",{\"1\":{\"318\":1,\"481\":1,\"1554\":1}}],[\"liaoxuefeng\",{\"1\":{\"1969\":1,\"1981\":1}}],[\"lisi=90\",{\"1\":{\"1613\":1}}],[\"lisi=1\",{\"1\":{\"1613\":1}}],[\"lisi\",{\"1\":{\"1598\":1,\"1603\":2,\"1604\":2,\"1605\":1,\"1609\":1,\"1613\":1,\"1615\":1}}],[\"list等类型\",{\"1\":{\"1648\":1}}],[\"lists\",{\"1\":{\"1615\":1}}],[\"list1\",{\"1\":{\"1609\":2}}],[\"list2\",{\"1\":{\"1609\":4}}],[\"list这样一个顶层的集合增加了排序的方法\",{\"1\":{\"1607\":1}}],[\"listiterator\",{\"1\":{\"1603\":1}}],[\"listiterator<e>\",{\"1\":{\"1603\":1}}],[\"list用来存储一组不唯一\",{\"1\":{\"1355\":1}}],[\"listresourcebundle\",{\"1\":{\"1052\":1}}],[\"list<object>\",{\"1\":{\"1654\":3}}],[\"list<objecterror>\",{\"1\":{\"1063\":2}}],[\"list<injectionmetadata\",{\"1\":{\"1648\":2}}],[\"list<integer>\",{\"1\":{\"1599\":7,\"1607\":1,\"1609\":1}}],[\"list<t>就表示根据分类依据k分类之后的列表集合\",{\"1\":{\"1618\":1}}],[\"list<t>>>\",{\"1\":{\"1613\":1,\"1618\":2}}],[\"list<t>>\",{\"1\":{\"1608\":1,\"1618\":1}}],[\"list<employee>>\",{\"1\":{\"1616\":1}}],[\"list<person>>\",{\"1\":{\"1598\":1}}],[\"list<person>\",{\"1\":{\"1598\":7}}],[\"list<future<integer>>\",{\"1\":{\"1517\":1}}],[\"list<beanpostprocessor>\",{\"1\":{\"1166\":4}}],[\"list<student>>\",{\"1\":{\"1616\":1}}],[\"list<student>\",{\"1\":{\"1603\":2,\"1604\":1,\"1605\":1,\"1613\":1,\"1615\":2}}],[\"list<string>>\",{\"1\":{\"1103\":3}}],[\"list<string>\",{\"1\":{\"975\":1,\"996\":1,\"1103\":1,\"1166\":2,\"1365\":1,\"1593\":6,\"1594\":1,\"1595\":1,\"1597\":2,\"1602\":1,\"1605\":1,\"1607\":1,\"1608\":4,\"1609\":5,\"1610\":2,\"1612\":3,\"1614\":1,\"1616\":1,\"1617\":2,\"1618\":1,\"1619\":1,\"1620\":1,\"1647\":1}}],[\"list<sqlnode>\",{\"1\":{\"645\":1}}],[\"list<\",{\"1\":{\"963\":2}}],[\"listenerbeanname\",{\"1\":{\"1170\":2}}],[\"listenerbeannames\",{\"1\":{\"1170\":2}}],[\"listeners\",{\"1\":{\"1162\":1,\"1170\":1,\"1175\":1}}],[\"listenerfor\",{\"1\":{\"1110\":1}}],[\"listener\",{\"1\":{\"922\":1,\"1124\":3,\"1170\":2,\"1647\":1,\"1978\":1}}],[\"list>\",{\"1\":{\"918\":2}}],[\"listablebeanfactory\",{\"1\":{\"917\":10,\"921\":10,\"941\":11,\"944\":2,\"1636\":1,\"1637\":1}}],[\"list实际上是一个链表\",{\"1\":{\"571\":1}}],[\"list不存在\",{\"1\":{\"571\":1}}],[\"list中是允许value重复的\",{\"1\":{\"571\":1}}],[\"list列表中事务id最小的id\",{\"1\":{\"542\":1}}],[\"list未提交事务id列表\",{\"1\":{\"542\":1}}],[\"list\",{\"0\":{\"27\":1,\"571\":1,\"1355\":1,\"1475\":1,\"1541\":1},\"1\":{\"308\":1,\"352\":1,\"569\":1,\"571\":2,\"572\":1,\"645\":2,\"960\":1,\"963\":1,\"975\":1,\"1100\":2,\"1103\":2,\"1280\":1,\"1365\":6,\"1539\":1,\"1593\":13,\"1594\":2,\"1595\":2,\"1597\":4,\"1599\":23,\"1602\":2,\"1607\":4,\"1608\":4,\"1609\":9,\"1610\":5,\"1611\":5,\"1612\":9,\"1614\":15,\"1615\":1,\"1616\":2,\"1617\":4,\"1618\":3,\"1619\":4,\"1620\":2,\"1622\":3}}],[\"lifo\",{\"1\":{\"1510\":1}}],[\"lifecycledemo\",{\"1\":{\"1174\":1}}],[\"lifecycle\",{\"1\":{\"945\":1,\"1003\":1,\"1005\":1,\"1012\":1,\"1172\":2,\"1174\":3,\"1175\":1,\"1647\":1}}],[\"lifecycleprocessor对象\",{\"1\":{\"945\":1}}],[\"lifecycleprocessor\",{\"1\":{\"945\":1,\"1175\":3}}],[\"live\",{\"1\":{\"1175\":1}}],[\"livebeansview\",{\"1\":{\"1172\":2,\"1175\":2}}],[\"lines返回对象\",{\"1\":{\"1619\":1}}],[\"lines\",{\"1\":{\"1619\":1}}],[\"line\",{\"1\":{\"1084\":1,\"1091\":1}}],[\"linkplain\",{\"1\":{\"1594\":2}}],[\"linked\",{\"1\":{\"1622\":3,\"1623\":1}}],[\"linkedorconsumed\",{\"1\":{\"1622\":4,\"1623\":2}}],[\"linkedhashmap保存了记录的插入顺序\",{\"1\":{\"1544\":1}}],[\"linkedhashmap\",{\"1\":{\"1544\":1}}],[\"linkedhashset<>\",{\"1\":{\"965\":1,\"967\":1,\"1116\":1,\"1162\":2,\"1647\":3,\"1648\":1}}],[\"linkedlist<string>\",{\"1\":{\"1609\":1}}],[\"linkedlist源码分析\",{\"0\":{\"1543\":1}}],[\"linkedlist\",{\"1\":{\"1539\":1,\"1609\":1,\"1618\":1}}],[\"linkedlist是双向链表\",{\"1\":{\"1475\":1}}],[\"linkedblockingdeque的总结\",{\"1\":{\"1504\":1}}],[\"linkedblockingdeque\",{\"0\":{\"1504\":1},\"1\":{\"1395\":1,\"1501\":1}}],[\"linkedblockingqueue的总结\",{\"1\":{\"1503\":1}}],[\"linkedblockingqueue<>\",{\"1\":{\"1503\":2}}],[\"linkedblockingqueue使用\",{\"1\":{\"1503\":1}}],[\"linkedblockingqueue采用两把锁的锁分离技术实现入队出队互不阻塞\",{\"1\":{\"1503\":1}}],[\"linkedblockingqueue内存由单链表实现\",{\"1\":{\"1503\":1}}],[\"linkedblockingqueue是一个基于链表实现的阻塞队列\",{\"1\":{\"1503\":1}}],[\"linkedblockingqueue\",{\"0\":{\"1503\":1},\"1\":{\"1395\":1,\"1501\":2,\"1503\":2}}],[\"linkedtransferqueue\",{\"0\":{\"1507\":1},\"1\":{\"1395\":1,\"1501\":1}}],[\"link\",{\"1\":{\"639\":1,\"645\":1,\"953\":3,\"954\":2,\"957\":1,\"961\":3,\"962\":1,\"1479\":1,\"1494\":1,\"1499\":1,\"1597\":2,\"1598\":4,\"1599\":6,\"1600\":1,\"1601\":4,\"1608\":1,\"1652\":1,\"1653\":1,\"1657\":1}}],[\"linux内核之旅\",{\"1\":{\"1966\":1}}],[\"linux提供的零拷贝技术\",{\"1\":{\"1586\":1}}],[\"linux系统sendfile拷贝流程\",{\"0\":{\"1582\":1}}],[\"linux下的异步io其实用的很少\",{\"1\":{\"1566\":1}}],[\"linux下\",{\"1\":{\"1564\":1}}],[\"linux网络编程io模型\",{\"0\":{\"1562\":1}}],[\"linux操作系统有以下四种io模型的方案\",{\"1\":{\"1561\":1}}],[\"linux这样的操作系统\",{\"1\":{\"1561\":1}}],[\"linux服务器上一些优化策略\",{\"1\":{\"1257\":1}}],[\"linux\",{\"0\":{\"1584\":1},\"1\":{\"603\":1,\"1337\":1,\"1423\":1,\"1479\":1,\"1561\":1,\"1582\":1,\"1583\":2,\"1584\":3,\"1966\":1,\"1987\":1}}],[\"linux命令在线查询\",{\"1\":{\"1987\":1}}],[\"linux命令\",{\"0\":{\"254\":1,\"1463\":1}}],[\"linsert\",{\"1\":{\"571\":2}}],[\"lindex\",{\"1\":{\"571\":4}}],[\"lilei\",{\"1\":{\"510\":1,\"518\":4,\"535\":1}}],[\"libraries\",{\"1\":{\"1615\":1}}],[\"library\",{\"1\":{\"472\":1,\"479\":1,\"1615\":1,\"1621\":1,\"1622\":1}}],[\"lib\",{\"1\":{\"428\":2,\"429\":4}}],[\"limit的值太小导致的\",{\"1\":{\"553\":1}}],[\"limit的值的话\",{\"1\":{\"553\":1}}],[\"limit的默认值为10\",{\"1\":{\"553\":1}}],[\"limit参数使用的默认值是1024\",{\"1\":{\"425\":1}}],[\"limit\",{\"1\":{\"347\":1,\"348\":6,\"353\":1,\"354\":1,\"361\":3,\"393\":1,\"411\":3,\"414\":1,\"416\":1,\"419\":1,\"420\":1,\"421\":2,\"422\":5,\"431\":3,\"454\":1,\"520\":2,\"522\":5,\"542\":6,\"553\":1,\"574\":2,\"1609\":1,\"1610\":10}}],[\"limit语句会扫描全表吗\",{\"0\":{\"164\":1,\"1273\":1}}],[\"liked\",{\"1\":{\"1972\":1}}],[\"likelihood\",{\"1\":{\"1620\":1}}],[\"like百分加右边\",{\"0\":{\"375\":1},\"1\":{\"375\":1}}],[\"like以通配符开头\",{\"1\":{\"369\":1}}],[\"like\",{\"1\":{\"339\":1,\"340\":1,\"375\":13,\"377\":4,\"400\":1,\"404\":1,\"409\":1,\"413\":1,\"428\":6,\"431\":2,\"433\":1,\"479\":1,\"503\":1,\"518\":1,\"523\":1,\"532\":1,\"538\":1,\"544\":1,\"547\":2,\"548\":1,\"553\":3,\"557\":1,\"558\":2,\"1262\":1,\"1608\":1,\"1619\":1,\"1620\":1,\"1647\":1}}],[\"v表示当前map的值的类型\",{\"1\":{\"1618\":1}}],[\"v>\",{\"1\":{\"1546\":5,\"1549\":4,\"1550\":9,\"1553\":7,\"1554\":16,\"1598\":8,\"1618\":1}}],[\"v9\",{\"1\":{\"1011\":1}}],[\"v8\",{\"1\":{\"1009\":1}}],[\"v7\",{\"1\":{\"1008\":1}}],[\"v6\",{\"1\":{\"1007\":1}}],[\"v5\",{\"1\":{\"1007\":1}}],[\"vector\",{\"1\":{\"1539\":1}}],[\"velocity\",{\"1\":{\"983\":1,\"1235\":1}}],[\"very\",{\"1\":{\"1620\":1,\"1648\":1}}],[\"verbose\",{\"1\":{\"429\":3}}],[\"version此时为101\",{\"1\":{\"1498\":1}}],[\"version=\",{\"1\":{\"917\":1,\"918\":1,\"930\":1,\"953\":2,\"954\":2,\"1030\":1,\"1032\":1,\"1065\":1,\"1084\":1,\"1091\":1,\"1146\":1}}],[\"version>\",{\"1\":{\"582\":2,\"965\":1}}],[\"version的优化\",{\"1\":{\"306\":1}}],[\"version\",{\"1\":{\"304\":3,\"540\":1,\"1498\":5,\"1647\":2}}],[\"void>\",{\"1\":{\"1623\":1}}],[\"void\",{\"1\":{\"582\":2,\"583\":1,\"909\":5,\"917\":9,\"918\":4,\"919\":1,\"921\":4,\"922\":1,\"927\":1,\"929\":2,\"930\":5,\"931\":5,\"933\":4,\"934\":2,\"936\":1,\"940\":2,\"941\":2,\"943\":4,\"944\":7,\"946\":5,\"951\":1,\"953\":4,\"954\":1,\"955\":1,\"956\":2,\"957\":3,\"961\":3,\"962\":1,\"963\":1,\"964\":2,\"973\":3,\"977\":2,\"978\":1,\"985\":10,\"989\":3,\"994\":1,\"995\":1,\"996\":1,\"997\":1,\"1000\":1,\"1001\":1,\"1003\":2,\"1005\":11,\"1006\":2,\"1007\":4,\"1009\":2,\"1011\":2,\"1012\":3,\"1013\":1,\"1019\":1,\"1022\":1,\"1027\":1,\"1029\":1,\"1030\":4,\"1031\":1,\"1032\":2,\"1040\":1,\"1041\":1,\"1043\":1,\"1044\":2,\"1045\":3,\"1053\":2,\"1055\":1,\"1056\":1,\"1061\":1,\"1063\":1,\"1064\":2,\"1065\":3,\"1072\":2,\"1075\":1,\"1082\":2,\"1084\":3,\"1099\":1,\"1100\":2,\"1103\":2,\"1108\":4,\"1112\":2,\"1113\":7,\"1114\":1,\"1115\":1,\"1116\":2,\"1119\":2,\"1120\":4,\"1121\":1,\"1123\":4,\"1124\":1,\"1134\":1,\"1138\":2,\"1139\":1,\"1146\":1,\"1148\":3,\"1149\":2,\"1156\":1,\"1157\":1,\"1162\":1,\"1163\":1,\"1164\":1,\"1165\":1,\"1166\":1,\"1167\":1,\"1168\":1,\"1170\":1,\"1171\":1,\"1172\":1,\"1173\":1,\"1174\":4,\"1175\":3,\"1181\":1,\"1182\":1,\"1184\":6,\"1195\":1,\"1365\":1,\"1387\":1,\"1404\":4,\"1456\":2,\"1476\":1,\"1479\":1,\"1480\":1,\"1482\":6,\"1485\":1,\"1486\":1,\"1487\":2,\"1502\":2,\"1503\":4,\"1506\":1,\"1521\":1,\"1526\":2,\"1531\":4,\"1535\":1,\"1550\":1,\"1551\":3,\"1554\":1,\"1573\":1,\"1574\":3,\"1575\":12,\"1587\":1,\"1588\":1,\"1591\":5,\"1592\":2,\"1593\":6,\"1594\":6,\"1595\":17,\"1597\":4,\"1598\":6,\"1599\":9,\"1600\":5,\"1601\":1,\"1602\":1,\"1603\":5,\"1604\":2,\"1605\":5,\"1606\":2,\"1607\":15,\"1608\":4,\"1609\":11,\"1610\":8,\"1612\":3,\"1613\":6,\"1614\":1,\"1615\":1,\"1617\":5,\"1619\":6,\"1620\":10,\"1621\":2,\"1622\":5,\"1623\":7,\"1638\":2,\"1646\":1,\"1647\":3,\"1648\":1,\"1651\":2,\"1654\":4,\"1657\":2,\"1658\":1}}],[\"volatile型变量\",{\"0\":{\"1810\":1}}],[\"volatile语义中的内存屏障\",{\"0\":{\"1768\":1}}],[\"volatile的内存语义总结\",{\"1\":{\"1474\":1}}],[\"volatile关键字的c++实现源码\",{\"1\":{\"1473\":1}}],[\"volatile关键字只能保证线程可见性\",{\"1\":{\"1387\":1}}],[\"volatile和synchronized\",{\"1\":{\"1431\":1}}],[\"volatile和synchronized有什么区别\",{\"0\":{\"55\":1,\"1384\":1}}],[\"volatile可以共享保障变量的可见性\",{\"1\":{\"1416\":1}}],[\"volatile防止指令重排\",{\"1\":{\"1388\":1}}],[\"volatiledemo\",{\"1\":{\"1387\":1}}],[\"volatile变量可以确保写操作发生在后续的读操作之前\",{\"1\":{\"1385\":1}}],[\"volatile变量和atomic变量什么不同\",{\"0\":{\"56\":1,\"1385\":1}}],[\"volatile只是保持变量的线程可见性\",{\"1\":{\"1384\":1}}],[\"volatile\",{\"1\":{\"963\":2,\"975\":1,\"998\":1,\"1193\":1,\"1300\":4,\"1373\":1,\"1387\":1,\"1388\":1,\"1404\":1,\"1431\":1,\"1477\":1,\"1479\":2,\"1480\":2,\"1554\":2}}],[\"volatile能不能保证线程安全\",{\"0\":{\"58\":1,\"1387\":1}}],[\"v4\",{\"1\":{\"570\":1,\"1007\":1}}],[\"video\",{\"1\":{\"1969\":1,\"1974\":1,\"1975\":1,\"1978\":1,\"1980\":1,\"1981\":1,\"1982\":1,\"1983\":1,\"1985\":2,\"1986\":1,\"1987\":2,\"1989\":1,\"1990\":1,\"1991\":1,\"1992\":2}}],[\"via\",{\"1\":{\"1480\":2,\"1597\":2,\"1619\":1,\"1620\":3}}],[\"visible\",{\"1\":{\"542\":1}}],[\"viewresoler的典型实现\",{\"1\":{\"1657\":1}}],[\"viewed\",{\"1\":{\"1619\":1}}],[\"view创建的事务所做的修改均是可见\",{\"1\":{\"542\":1}}],[\"view会记录此时所有其他活动事务的快照\",{\"1\":{\"542\":1}}],[\"view时\",{\"1\":{\"542\":1}}],[\"view生成时机的不同\",{\"1\":{\"542\":1}}],[\"view生成时刻系统正活跃的事务id\",{\"1\":{\"542\":1}}],[\"view机制与undo版本链对比机制\",{\"1\":{\"542\":1}}],[\"view机制详解\",{\"0\":{\"542\":1}}],[\"view做比对从而得到最终的快照结果\",{\"1\":{\"542\":1}}],[\"view有三个全局属性\",{\"1\":{\"542\":1}}],[\"view的属性做了某些比较\",{\"1\":{\"542\":1}}],[\"view的时候\",{\"1\":{\"434\":1}}],[\"view维护\",{\"1\":{\"542\":1}}],[\"view遵循一个可见性算法\",{\"1\":{\"542\":1}}],[\"view读视图\",{\"1\":{\"542\":1}}],[\"view来做可见性的判断\",{\"1\":{\"542\":1}}],[\"view可见\",{\"1\":{\"542\":1}}],[\"view相当于系统中最老活跃事务的read\",{\"1\":{\"542\":1}}],[\"view\",{\"1\":{\"434\":2,\"542\":10,\"639\":1,\"645\":1,\"1494\":1,\"1499\":1,\"1652\":1,\"1653\":1,\"1657\":2}}],[\"views\",{\"1\":{\"361\":5,\"1621\":1}}],[\"views最多的article\",{\"1\":{\"361\":1}}],[\"v12\",{\"1\":{\"1012\":1}}],[\"v11\",{\"1\":{\"1012\":1}}],[\"v10\",{\"1\":{\"1012\":1}}],[\"v1\",{\"1\":{\"433\":1,\"570\":3,\"571\":2,\"579\":3,\"580\":2}}],[\"v3\",{\"1\":{\"570\":2,\"579\":1,\"1006\":1}}],[\"v3是2\",{\"1\":{\"433\":1}}],[\"v3的值是2\",{\"1\":{\"433\":1}}],[\"v3的值都是2\",{\"1\":{\"433\":1}}],[\"v3的返回值分别是什么\",{\"1\":{\"433\":1}}],[\"v2的值是1\",{\"1\":{\"433\":1}}],[\"v2的值是2\",{\"1\":{\"433\":1}}],[\"v2是1\",{\"1\":{\"433\":1}}],[\"v2\",{\"1\":{\"433\":2,\"570\":2,\"571\":1,\"579\":2,\"580\":3,\"1003\":1,\"1981\":1}}],[\"v\",{\"1\":{\"411\":4,\"429\":1,\"577\":1,\"1480\":3,\"1546\":5,\"1549\":5,\"1553\":5,\"1554\":9,\"1598\":8,\"1618\":8}}],[\"vavr\",{\"1\":{\"1655\":2}}],[\"vavrdelegate\",{\"1\":{\"1655\":4}}],[\"vavrpresent\",{\"1\":{\"1655\":2}}],[\"val两个字段都不是null才继续往下走\",{\"1\":{\"1554\":1}}],[\"val字段为空\",{\"1\":{\"1554\":1}}],[\"val\",{\"1\":{\"1347\":2,\"1554\":5}}],[\"valid\",{\"1\":{\"1065\":1,\"1617\":1,\"1620\":1,\"1621\":4,\"1623\":1}}],[\"validator实例集合\",{\"1\":{\"1070\":1}}],[\"validators\",{\"1\":{\"1070\":1}}],[\"validator适配\",{\"1\":{\"1065\":1}}],[\"validatordemo\",{\"1\":{\"1064\":1}}],[\"validator接口\",{\"1\":{\"1064\":1}}],[\"validator接口设计\",{\"0\":{\"1061\":1}}],[\"validator工具类\",{\"1\":{\"1061\":1}}],[\"validator\",{\"1\":{\"1060\":1,\"1061\":1,\"1064\":5,\"1065\":7,\"1067\":1,\"1068\":1}}],[\"validaterequiredproperties\",{\"1\":{\"1162\":1}}],[\"validated\",{\"1\":{\"1065\":2}}],[\"validate\",{\"1\":{\"996\":1,\"1061\":2,\"1064\":2,\"1162\":1}}],[\"validation适配\",{\"1\":{\"1068\":1}}],[\"validationutils\",{\"1\":{\"1061\":3,\"1064\":2}}],[\"validation校验非常普遍\",{\"1\":{\"1056\":1}}],[\"validation校验国际化文案\",{\"1\":{\"1049\":1}}],[\"validation\",{\"0\":{\"1065\":1},\"1\":{\"891\":1,\"892\":1,\"996\":1,\"1061\":2,\"1062\":2,\"1063\":1,\"1064\":1,\"1065\":8,\"1067\":1,\"1068\":5,\"1070\":1,\"1078\":1,\"1647\":1}}],[\"value有可能是bean对象\",{\"1\":{\"1648\":1}}],[\"valued\",{\"1\":{\"1599\":2,\"1615\":1,\"1618\":1}}],[\"value的值\",{\"1\":{\"1554\":1}}],[\"value的字符集是utf8\",{\"1\":{\"368\":1}}],[\"value和\",{\"1\":{\"1479\":1}}],[\"value和dest指针指向内存值相等则会使得dest指针指向内存值变成exchange\",{\"1\":{\"1479\":1}}],[\"value变量作为返回值\",{\"1\":{\"1479\":1}}],[\"value变量\",{\"1\":{\"1479\":1}}],[\"value变量中\",{\"1\":{\"1479\":1}}],[\"value赋值给了exchange\",{\"1\":{\"1479\":1}}],[\"value存入eax寄存器\",{\"1\":{\"1479\":1}}],[\"value存储\",{\"1\":{\"1475\":1}}],[\"value还存在\",{\"1\":{\"1406\":1}}],[\"value底层实现\",{\"1\":{\"1152\":1}}],[\"value中的运用\",{\"0\":{\"1152\":1}}],[\"value>\",{\"1\":{\"1084\":1,\"1091\":1}}],[\"value内容映射到关联bean\",{\"1\":{\"1070\":1}}],[\"value设计\",{\"1\":{\"1052\":1}}],[\"value实现\",{\"1\":{\"1044\":1}}],[\"value就是对应的beandefinition\",{\"1\":{\"996\":1}}],[\"valueof\",{\"1\":{\"985\":2,\"989\":2,\"1061\":1,\"1647\":1}}],[\"value外部化配置\",{\"1\":{\"982\":1}}],[\"value所标注的外部化配置\",{\"1\":{\"980\":1}}],[\"valuetype\",{\"1\":{\"963\":3}}],[\"value注解的方法\",{\"1\":{\"1648\":1}}],[\"value注解的实现类\",{\"1\":{\"1150\":1}}],[\"value注解\",{\"1\":{\"945\":1,\"1648\":1}}],[\"value`\",{\"1\":{\"571\":1}}],[\"value除了是字符串还可以是数字\",{\"1\":{\"570\":1}}],[\"value形式保存\",{\"1\":{\"569\":1}}],[\"value数据库\",{\"1\":{\"564\":1}}],[\"value字段值更新为null\",{\"1\":{\"557\":1}}],[\"value字段值进行update操作\",{\"1\":{\"557\":1}}],[\"value表示成本常数对应的值\",{\"1\":{\"557\":1}}],[\"value=\",{\"1\":{\"917\":4,\"930\":1,\"1003\":4,\"1012\":2,\"1032\":1,\"1084\":2,\"1091\":3,\"1146\":7,\"1201\":1}}],[\"value=1\",{\"1\":{\"462\":2}}],[\"value=2\",{\"1\":{\"462\":1}}],[\"value是conn连接\",{\"1\":{\"1655\":1}}],[\"value是一段lamda表达式\",{\"1\":{\"1649\":1}}],[\"value是一个数字\",{\"1\":{\"461\":1}}],[\"value是查询的结果\",{\"1\":{\"319\":1}}],[\"values\",{\"1\":{\"336\":1,\"345\":1,\"361\":5,\"368\":14,\"378\":5,\"400\":1,\"404\":2,\"413\":1,\"414\":1,\"419\":1,\"424\":5,\"433\":1,\"446\":1,\"447\":2,\"454\":6,\"459\":3,\"462\":1,\"468\":2,\"476\":1,\"478\":1,\"490\":1,\"491\":4,\"492\":1,\"494\":2,\"506\":3,\"510\":3,\"518\":4,\"523\":2,\"534\":4,\"535\":3,\"963\":2,\"997\":1,\"1171\":1,\"1601\":2,\"1607\":2,\"1608\":2,\"1618\":2,\"1619\":1,\"1620\":13,\"1623\":2,\"1647\":3}}],[\"value\",{\"0\":{\"1150\":1},\"1\":{\"332\":1,\"354\":2,\"368\":3,\"428\":3,\"431\":1,\"542\":1,\"558\":1,\"570\":9,\"571\":4,\"573\":6,\"578\":1,\"580\":1,\"583\":1,\"952\":7,\"961\":1,\"963\":8,\"964\":6,\"965\":2,\"977\":2,\"978\":6,\"1023\":3,\"1029\":1,\"1031\":2,\"1032\":3,\"1044\":4,\"1136\":5,\"1139\":3,\"1156\":1,\"1157\":1,\"1171\":1,\"1288\":2,\"1347\":3,\"1479\":37,\"1480\":2,\"1484\":4,\"1501\":2,\"1503\":2,\"1509\":1,\"1546\":2,\"1549\":9,\"1550\":3,\"1553\":9,\"1554\":10,\"1598\":22,\"1608\":4,\"1615\":1,\"1618\":2,\"1620\":6,\"1621\":2,\"1623\":1,\"1638\":1,\"1640\":2,\"1645\":2,\"1648\":12,\"1655\":1,\"1975\":1}}],[\"value对极限\",{\"1\":{\"1546\":1}}],[\"value对的形式\",{\"1\":{\"319\":1}}],[\"value对应的配置项如何动态更新\",{\"0\":{\"234\":1,\"1314\":1}}],[\"value2\",{\"1\":{\"307\":1,\"570\":2,\"571\":1,\"573\":1,\"1598\":10}}],[\"value1\",{\"1\":{\"307\":1,\"570\":2,\"571\":1,\"573\":1,\"1598\":10}}],[\"variants\",{\"1\":{\"1623\":1}}],[\"variables\",{\"1\":{\"428\":4,\"431\":2,\"433\":1,\"532\":1,\"553\":1,\"558\":1,\"1262\":1}}],[\"variable\",{\"1\":{\"354\":4,\"428\":3,\"431\":1,\"1099\":1}}],[\"various\",{\"1\":{\"1616\":2,\"1621\":1}}],[\"var\",{\"1\":{\"428\":2,\"429\":4,\"624\":2}}],[\"varchar\",{\"1\":{\"335\":1,\"336\":1,\"338\":2,\"349\":1,\"353\":3,\"361\":2,\"366\":1,\"368\":3,\"419\":1,\"506\":3,\"510\":2,\"518\":2,\"530\":2,\"534\":1,\"535\":1}}],[\"vstart\",{\"0\":{\"284\":1,\"287\":1}}],[\"vue\",{\"1\":{\"3\":1}}],[\"什么时候触发拒绝策略\",{\"1\":{\"1410\":1}}],[\"什么时候退化为链表\",{\"0\":{\"35\":1,\"1363\":1}}],[\"什么样的sql才会被记录到慢查询日志里面呢\",{\"1\":{\"428\":1}}],[\"什么情况下会使用到change\",{\"1\":{\"343\":1}}],[\"什么情况下堆内存会溢出\",{\"0\":{\"125\":1,\"1456\":1}}],[\"什么情况方法区会内存溢出\",{\"0\":{\"125\":1,\"1456\":1}}],[\"什么是可变的汇聚操作呢\",{\"1\":{\"1615\":1}}],[\"什么是可重入锁\",{\"0\":{\"69\":1,\"1398\":1}}],[\"什么是内部迭代呢\",{\"1\":{\"1611\":1}}],[\"什么是函数式接口\",{\"1\":{\"1593\":1}}],[\"什么是ddd\",{\"1\":{\"1309\":1}}],[\"什么是分库分表\",{\"1\":{\"1270\":1}}],[\"什么是bean的名称\",{\"1\":{\"928\":1}}],[\"什么是ioc\",{\"0\":{\"914\":1}}],[\"什么是java\",{\"1\":{\"909\":1}}],[\"什么是jwt令牌\",{\"0\":{\"220\":1,\"1203\":1}}],[\"什么是aof\",{\"0\":{\"592\":1}}],[\"什么是rdb\",{\"0\":{\"586\":1}}],[\"什么是mysql\",{\"1\":{\"541\":1}}],[\"什么是操作系统\",{\"0\":{\"275\":1}}],[\"什么是spring\",{\"0\":{\"902\":1,\"924\":1,\"937\":1}}],[\"什么是sso\",{\"0\":{\"221\":1,\"1204\":1}}],[\"什么是stw\",{\"0\":{\"109\":1,\"1440\":1}}],[\"什么是oauth2\",{\"0\":{\"219\":1,\"1202\":1}}],[\"什么是csrf攻击\",{\"0\":{\"218\":1,\"1201\":1}}],[\"什么是callable和future\",{\"0\":{\"67\":1,\"1396\":1}}],[\"什么是认证和授权\",{\"0\":{\"216\":1,\"1199\":1}}],[\"什么是倒排索引\",{\"0\":{\"170\":1,\"1252\":1}}],[\"什么是间隙锁\",{\"0\":{\"154\":1,\"1263\":1}}],[\"什么是脏读\",{\"0\":{\"152\":1,\"1261\":1}}],[\"什么是缓存穿透\",{\"0\":{\"129\":1,\"1281\":1}}],[\"什么是三色标记算法\",{\"0\":{\"111\":1,\"1442\":1}}],[\"什么是gc\",{\"0\":{\"107\":1,\"1438\":1}}],[\"什么是双亲委派机制\",{\"0\":{\"101\":1,\"1432\":1}}],[\"什么是executors框架\",{\"0\":{\"80\":1,\"1409\":1}}],[\"什么是指令重排序\",{\"0\":{\"76\":1,\"1405\":1}}],[\"什么是乐观锁\",{\"0\":{\"70\":1,\"1399\":1}}],[\"什么是悲观锁\",{\"0\":{\"70\":1,\"1399\":1}}],[\"什么是阻塞队列\",{\"0\":{\"66\":1,\"1395\":1}}],[\"什么是线程安全\",{\"0\":{\"47\":1,\"1376\":1}}],[\"sbd\",{\"1\":{\"1647\":4}}],[\"sbase\",{\"1\":{\"1553\":1}}],[\"s>\",{\"1\":{\"1623\":1}}],[\"s>>\",{\"1\":{\"1619\":1,\"1623\":1}}],[\"s指的是实现了basestream类型的流对象\",{\"1\":{\"1619\":1}}],[\"sg\",{\"1\":{\"1583\":1}}],[\"s3\",{\"1\":{\"1404\":3}}],[\"sdk\",{\"1\":{\"1337\":1}}],[\"sdiffstore\",{\"1\":{\"572\":1}}],[\"sdiff\",{\"1\":{\"572\":5}}],[\"snapshot\",{\"1\":{\"596\":1}}],[\"srcchannel\",{\"1\":{\"1588\":4}}],[\"src\",{\"1\":{\"1040\":1,\"1041\":1,\"1043\":1}}],[\"sring更加适合字符串存储\",{\"1\":{\"573\":1}}],[\"srem\",{\"1\":{\"572\":3}}],[\"srandmember\",{\"1\":{\"572\":4}}],[\"spa\",{\"1\":{\"1972\":1}}],[\"sparc\",{\"1\":{\"1479\":1}}],[\"splice\",{\"0\":{\"1584\":1},\"1\":{\"1584\":4,\"1585\":2}}],[\"splitr是原生的spliterator分割迭代器的类型\",{\"1\":{\"1620\":1}}],[\"splitr>\",{\"1\":{\"1620\":1}}],[\"splitr>>\",{\"1\":{\"1620\":1}}],[\"splitr\",{\"1\":{\"1620\":2}}],[\"splitting\",{\"1\":{\"1615\":1,\"1620\":8}}],[\"spliterator在流管道开启之后仅仅是完成遍历\",{\"1\":{\"1621\":1}}],[\"spliterator中还有两个接口ofprimitive和ofint\",{\"1\":{\"1620\":1}}],[\"spliterator的api设计为串行和高效的并行方式来进行元素的遍历\",{\"1\":{\"1620\":1}}],[\"spliterator还会报告它的结构\",{\"1\":{\"1620\":1}}],[\"spliterator是一个对于元中的元素进行遍历和分区的对象\",{\"1\":{\"1620\":1}}],[\"spliterator和spliterators的关系就好像collector和collectors的关系一样\",{\"1\":{\"1620\":1}}],[\"spliteratorcharacteristics\",{\"1\":{\"1620\":1}}],[\"spliterator<s>\",{\"1\":{\"1623\":2}}],[\"spliterator<p\",{\"1\":{\"1623\":6}}],[\"spliterator<e\",{\"1\":{\"1622\":4}}],[\"spliterator<e>\",{\"1\":{\"1620\":1,\"1621\":1}}],[\"spliterator<\",{\"1\":{\"1621\":6}}],[\"spliterator<t>\",{\"1\":{\"1619\":1,\"1620\":9,\"1621\":2}}],[\"spliterator被称之为分割迭代器\",{\"1\":{\"1620\":1}}],[\"spliterator源码分析\",{\"0\":{\"1620\":1}}],[\"spliterator\",{\"1\":{\"1609\":2,\"1619\":2,\"1620\":109,\"1621\":12,\"1622\":1,\"1623\":23}}],[\"spliteratorunknownsize\",{\"1\":{\"1609\":1}}],[\"spliterators中静态方法spliterator返回了一个spliterator实现\",{\"1\":{\"1621\":1}}],[\"spliterators就像iterators一样\",{\"1\":{\"1620\":1}}],[\"spliterators通过estimatesize方法来估算剩余元素的个数\",{\"1\":{\"1620\":1}}],[\"spliterators针对于spliterator提供了若干的静态方法\",{\"1\":{\"1620\":1}}],[\"spliterators的特性值要么是immutable或者concurrent\",{\"1\":{\"1620\":1}}],[\"spliterators\",{\"1\":{\"1609\":1,\"1620\":9,\"1621\":1}}],[\"split\",{\"1\":{\"1550\":1,\"1609\":2,\"1620\":8,\"1621\":1}}],[\"spread\",{\"1\":{\"1554\":1}}],[\"springmvc\",{\"1\":{\"1982\":1}}],[\"spring和spring\",{\"0\":{\"1659\":1}}],[\"springproxytest\",{\"1\":{\"1654\":1}}],[\"spring整合mybatis之后sql执行流程\",{\"1\":{\"1653\":1}}],[\"spring整合其他的框架本质上就是让其他的框架所产生的对象成为spring\",{\"1\":{\"1653\":1}}],[\"spring就会基于beandefinition去创建bean了\",{\"1\":{\"1653\":1}}],[\"spring启动的过程其实就是需要做一些准备工作\",{\"1\":{\"1651\":1}}],[\"spring启动的时候需要去扫描\",{\"1\":{\"1646\":1}}],[\"spring启动过程\",{\"0\":{\"1651\":1}}],[\"spring使用构造方法的原则如下\",{\"1\":{\"1650\":1}}],[\"spring使得你的应用开发变的更容易\",{\"1\":{\"902\":1}}],[\"spring考虑到如果开发者要迁移到其他支持依赖注入的框架\",{\"1\":{\"1648\":1}}],[\"spring自带的依赖注入\",{\"1\":{\"1647\":1}}],[\"spring源码分析\",{\"0\":{\"1629\":1}}],[\"spring当中支持编程式事务管理和声明式事务管理两种方式\",{\"1\":{\"1238\":1}}],[\"spring检测对象如果实现了这个接口\",{\"1\":{\"1234\":1}}],[\"spring会优先使用无参的构造方法\",{\"1\":{\"1650\":1}}],[\"spring会在找到注入点之后\",{\"1\":{\"1648\":1}}],[\"spring会检测对象是否实现了\",{\"1\":{\"1234\":1}}],[\"spring会忽略后面定义的bean的相关信息\",{\"1\":{\"1022\":1}}],[\"spring通过beandefinition找到对象依赖的其他对象\",{\"1\":{\"1234\":1}}],[\"spring通配路径资源扩展\",{\"0\":{\"1043\":1}}],[\"spring通配路径资源加载器\",{\"0\":{\"1042\":1}}],[\"springrunner\",{\"1\":{\"1157\":1}}],[\"spring条件注解\",{\"0\":{\"1139\":1}}],[\"spring元注解\",{\"0\":{\"1133\":1}}],[\"spring组合注解\",{\"1\":{\"1132\":1,\"1135\":1}}],[\"spring核心编程思想\",{\"1\":{\"1966\":1}}],[\"spring核心概念\",{\"0\":{\"1631\":1}}],[\"spring核心原理概览\",{\"0\":{\"1630\":1}}],[\"spring核心价值\",{\"0\":{\"1180\":1}}],[\"spring核心注解场景分类\",{\"0\":{\"1131\":1}}],[\"spring核心特性\",{\"0\":{\"892\":1,\"1179\":1}}],[\"spring异步事件\",{\"1\":{\"1129\":1}}],[\"spring同步事件\",{\"1\":{\"1129\":1}}],[\"spring同步和异步事件处理的使用场景\",{\"0\":{\"1129\":1}}],[\"spring还会处理applicationevent的子孙类\",{\"1\":{\"1125\":1}}],[\"spring本地调度\",{\"1\":{\"1124\":1}}],[\"spring本地调度中的应用\",{\"0\":{\"863\":1}}],[\"spring层次性上下文事件传播\",{\"0\":{\"1116\":1}}],[\"spring层次性国际化接口\",{\"1\":{\"1051\":1}}],[\"spring应用上下文生命周期有哪些阶段\",{\"0\":{\"1177\":1}}],[\"spring应用上下文关闭阶段\",{\"0\":{\"1175\":1}}],[\"spring应用上下文关闭事件\",{\"1\":{\"1117\":1}}],[\"spring应用上下文刷新完成阶段\",{\"0\":{\"1172\":1}}],[\"spring应用上下文刷新\",{\"0\":{\"1169\":1}}],[\"spring应用上下文启动准备阶段\",{\"0\":{\"1162\":1}}],[\"spring应用上下文启动后装配propertysource\",{\"1\":{\"1156\":1}}],[\"spring应用上下文启动前装配propertysource\",{\"1\":{\"1156\":1}}],[\"spring应用上下文启动事件\",{\"1\":{\"1117\":1}}],[\"spring应用上下文停止事件\",{\"1\":{\"1117\":1}}],[\"spring应用上下文就绪事件\",{\"1\":{\"1117\":1}}],[\"spring应用上下文\",{\"1\":{\"1111\":1,\"1116\":3}}],[\"spring应用上下文applicationevent扩展\",{\"1\":{\"1111\":1}}],[\"spring应用上下文存在\",{\"1\":{\"946\":1}}],[\"spring标准事件\",{\"0\":{\"1111\":1}}],[\"spring方法参数封装\",{\"0\":{\"1102\":1}}],[\"spring泛型类型辅助类\",{\"0\":{\"1100\":1}}],[\"spring3\",{\"0\":{\"1086\":1},\"1\":{\"1124\":1,\"1147\":1}}],[\"springcustomizedpropertyeditordemo\",{\"1\":{\"1084\":1}}],[\"springcloud使用基于http的rest方式\",{\"1\":{\"1306\":1}}],[\"springcloudalibaba架构图\",{\"1\":{\"1305\":1}}],[\"springcloudapplication\",{\"1\":{\"1140\":1}}],[\"springcloud是提供了构建微服务系统所需要的一组通用开发模式以及一系列快速实现这些开发模式的工具\",{\"1\":{\"1305\":1}}],[\"springcloud注解\",{\"1\":{\"1140\":1}}],[\"springcloud事件\",{\"1\":{\"1126\":1}}],[\"springcloud\",{\"0\":{\"888\":1},\"1\":{\"1305\":1,\"1989\":1}}],[\"springcloud和dubbo的区别\",{\"0\":{\"226\":1,\"1306\":1}}],[\"springcloud和springcloudalibaba有哪些组件\",{\"0\":{\"225\":1,\"1305\":1}}],[\"spring框架将通过propertyeditor\",{\"1\":{\"1082\":1}}],[\"spring框架将文本内容传递到propertyeditor实现的setastext\",{\"1\":{\"1082\":1}}],[\"spring框架中的bean经历过四个阶段\",{\"1\":{\"1234\":1}}],[\"spring框架中的bean是线程安全的吗\",{\"0\":{\"179\":1,\"1236\":1}}],[\"spring框架中bean的创建过程是怎样的\",{\"0\":{\"177\":1,\"1234\":1}}],[\"spring替代实现\",{\"1\":{\"1073\":1}}],[\"spring底层javabeans基础设施的中心化接口\",{\"1\":{\"1074\":1}}],[\"spring底层java\",{\"0\":{\"1073\":1}}],[\"spring数据绑定api是什么\",{\"0\":{\"1078\":1}}],[\"spring数据绑定\",{\"1\":{\"1069\":1}}],[\"spring数据绑定的使用场景\",{\"1\":{\"1069\":1}}],[\"spring数据存储\",{\"0\":{\"893\":1}}],[\"spring有哪些校验核心组件\",{\"0\":{\"1068\":1}}],[\"spring有哪些messagesource的内建实现\",{\"0\":{\"1059\":1}}],[\"spring校验接口是哪个\",{\"0\":{\"1067\":1}}],[\"spring校验使用场景\",{\"1\":{\"1060\":1}}],[\"springbeanvalidationdemo\",{\"1\":{\"1065\":1}}],[\"springboot2\",{\"1\":{\"1983\":1}}],[\"springboot与springcloud\",{\"1\":{\"1966\":1}}],[\"springboot程序的jvm参数设置格式\",{\"1\":{\"1664\":1}}],[\"springboot的\",{\"1\":{\"1246\":1}}],[\"springboot注解\",{\"1\":{\"1140\":1}}],[\"springboot和springcloud注解\",{\"0\":{\"1140\":1}}],[\"springbootconfiguration\",{\"1\":{\"1135\":1,\"1140\":1}}],[\"springboot事件\",{\"0\":{\"1126\":1},\"1\":{\"1126\":1}}],[\"springboot为什么要新建messagesource\",{\"0\":{\"1056\":1}}],[\"springbootapplication\",{\"0\":{\"869\":1},\"1\":{\"1135\":1,\"1140\":1}}],[\"springboottest\",{\"1\":{\"583\":1}}],[\"springboot\",{\"0\":{\"868\":1},\"1\":{\"583\":1,\"900\":1,\"1248\":1}}],[\"springboot整合\",{\"0\":{\"583\":1}}],[\"springboot如何防止表单重复提交\",{\"0\":{\"189\":1,\"1248\":1}}],[\"springboot自动装配过程及实现原理\",{\"0\":{\"188\":1,\"1247\":1}}],[\"springboot面试题\",{\"0\":{\"186\":1,\"1245\":1}}],[\"spring内建事件\",{\"0\":{\"1117\":1}}],[\"spring内建类型转换器\",{\"0\":{\"1087\":1}}],[\"spring内建propertyeditor扩展\",{\"0\":{\"1083\":1}}],[\"spring内建的依赖注入\",{\"1\":{\"1647\":1}}],[\"spring内建的配置属性源\",{\"0\":{\"1154\":1}}],[\"spring内建的xml\",{\"0\":{\"1034\":1}}],[\"spring内建的bean的作用域有几种\",{\"0\":{\"991\":1}}],[\"spring内部校验接口\",{\"1\":{\"1061\":1}}],[\"springapplication\",{\"1\":{\"1056\":1}}],[\"spring国际化接口有哪些\",{\"0\":{\"1058\":1}}],[\"spring国际化接口\",{\"0\":{\"1050\":1}}],[\"spring国际化使用场景\",{\"1\":{\"1049\":1}}],[\"spring配置属性源propertysource\",{\"0\":{\"1153\":1}}],[\"spring配置资源中有哪些常见类型\",{\"0\":{\"1047\":1}}],[\"spring配置元信息有哪些\",{\"0\":{\"1035\":1}}],[\"spring资源加载器\",{\"0\":{\"1041\":1}}],[\"spring要自立门户\",{\"1\":{\"1036\":1}}],[\"spring注解属性覆盖\",{\"0\":{\"1137\":1}}],[\"spring注解属性别名\",{\"0\":{\"1136\":1}}],[\"spring注解属性别名和覆盖\",{\"1\":{\"1132\":1}}],[\"spring注解编程模型\",{\"0\":{\"1132\":1}}],[\"spring注解驱动的编程发展的大概历程\",{\"1\":{\"1130\":1}}],[\"spring注解\",{\"1\":{\"1023\":4,\"1029\":2,\"1113\":1,\"1131\":3}}],[\"spring模式注解有哪些\",{\"0\":{\"1142\":1}}],[\"spring模式注解\",{\"0\":{\"1134\":1},\"1\":{\"1023\":1,\"1131\":1,\"1132\":1}}],[\"spring模块化设计\",{\"0\":{\"898\":1}}],[\"spring1\",{\"1\":{\"1003\":1}}],[\"spring依赖注入的来源有哪些\",{\"0\":{\"971\":1,\"982\":1}}],[\"spring依赖注入和依赖查找的来源\",{\"0\":{\"919\":1}}],[\"spring类型转换在\",{\"0\":{\"1152\":1}}],[\"spring类型转换在environment中的运用\",{\"0\":{\"1151\":1}}],[\"spring类型转换器接口有哪些\",{\"0\":{\"1096\":1}}],[\"spring类型转换实现有哪些\",{\"0\":{\"1095\":1}}],[\"spring类型转换的实现方案\",{\"1\":{\"1080\":1}}],[\"spring类型\",{\"1\":{\"959\":1,\"960\":1}}],[\"spring的条件注解主要有两种\",{\"1\":{\"1139\":1}}],[\"spring的依赖查找和依赖注入在来源上有什么区别\",{\"0\":{\"950\":1}}],[\"spring的核心特点是在应用级别上的基础设施建设\",{\"1\":{\"902\":1}}],[\"spring的核心价值\",{\"0\":{\"900\":1}}],[\"springframwork\",{\"1\":{\"943\":1}}],[\"springframework\",{\"0\":{\"889\":1},\"1\":{\"583\":1,\"917\":4,\"918\":4,\"930\":7,\"943\":1,\"945\":6,\"952\":1,\"953\":6,\"954\":6,\"957\":1,\"961\":3,\"962\":1,\"989\":3,\"1028\":6,\"1030\":2,\"1031\":5,\"1032\":7,\"1038\":5,\"1039\":6,\"1040\":5,\"1041\":5,\"1042\":4,\"1043\":1,\"1050\":1,\"1051\":1,\"1054\":2,\"1058\":1,\"1059\":4,\"1060\":1,\"1061\":2,\"1062\":2,\"1063\":1,\"1064\":1,\"1065\":10,\"1067\":1,\"1068\":5,\"1070\":5,\"1073\":1,\"1074\":1,\"1078\":1,\"1083\":7,\"1084\":6,\"1086\":4,\"1087\":3,\"1088\":2,\"1089\":3,\"1090\":2,\"1091\":11,\"1092\":1,\"1093\":12,\"1096\":4,\"1100\":1,\"1101\":2,\"1102\":1,\"1103\":1,\"1111\":4,\"1112\":2,\"1113\":1,\"1118\":1,\"1119\":3,\"1121\":1,\"1122\":3,\"1123\":3,\"1124\":3,\"1125\":5,\"1128\":4,\"1134\":10,\"1139\":11,\"1143\":1,\"1144\":1,\"1146\":9,\"1147\":2,\"1149\":2,\"1150\":1,\"1151\":3,\"1152\":5,\"1153\":6,\"1154\":6,\"1155\":5,\"1159\":3,\"1162\":1,\"1169\":5,\"1182\":1,\"1632\":5,\"1637\":2,\"1648\":2,\"1652\":2,\"1655\":1,\"1657\":5,\"1658\":2}}],[\"spring容器\",{\"1\":{\"1659\":1}}],[\"spring容器生命周期处理\",{\"1\":{\"1651\":1}}],[\"spring容器本身没有提供bean的线程安全策略\",{\"1\":{\"1236\":1}}],[\"spring容器配置元信息\",{\"0\":{\"1020\":1}}],[\"spring容器没有办法管理prototype\",{\"1\":{\"985\":1}}],[\"spring容器管理和游离对象\",{\"0\":{\"974\":1}}],[\"spring容器是怎样管理注册bean\",{\"0\":{\"938\":1}}],[\"spring容器返回的对象和非延迟的对象存在怎样的差异\",{\"1\":{\"932\":1}}],[\"spring作为ioc容器有什么优势\",{\"0\":{\"916\":1}}],[\"spring官方推荐使用构造器注入\",{\"1\":{\"912\":1}}],[\"spring用户\",{\"1\":{\"900\":1}}],[\"spring编程模型\",{\"0\":{\"899\":1}}],[\"spring版本特性\",{\"0\":{\"897\":1}}],[\"spring测试\",{\"0\":{\"896\":1}}],[\"spring技术整合\",{\"0\":{\"895\":1}}],[\"spring表达式\",{\"1\":{\"892\":1}}],[\"spring事件监听器注册\",{\"0\":{\"1170\":1}}],[\"spring事件监听器\",{\"1\":{\"1128\":1}}],[\"spring事件核心接口\",{\"0\":{\"1128\":1}}],[\"spring事件异常处理\",{\"0\":{\"1124\":1}}],[\"spring事件广播器\",{\"1\":{\"945\":1,\"1128\":1}}],[\"spring事件发布器\",{\"0\":{\"1115\":1},\"1\":{\"1128\":1}}],[\"spring事件发布\",{\"1\":{\"926\":1}}],[\"spring事件\",{\"0\":{\"1125\":1},\"1\":{\"892\":1,\"1124\":1,\"1128\":1}}],[\"spring事务管理器\",{\"1\":{\"1655\":1}}],[\"spring事务源码解析\",{\"0\":{\"1655\":1}}],[\"spring事务底层原理\",{\"1\":{\"1630\":1}}],[\"spring事务传播的原理\",{\"0\":{\"866\":1}}],[\"spring事务中的应用\",{\"0\":{\"857\":1}}],[\"spring事务失效的场景有哪些\",{\"0\":{\"182\":1,\"1239\":1}}],[\"spring特性总览\",{\"0\":{\"890\":1}}],[\"spring中还提供了ordercomparator的子类\",{\"1\":{\"1641\":1}}],[\"spring中保证线程安全的方法\",{\"1\":{\"1240\":1}}],[\"spring中事务的隔离级别\",{\"1\":{\"1238\":1}}],[\"spring中对事务定义了不同的传播级别\",{\"1\":{\"1238\":1}}],[\"spring中实例化方式\",{\"1\":{\"1001\":1}}],[\"spring中的service有多个实现类\",{\"0\":{\"185\":1,\"1242\":1}}],[\"spring中bean的作用域\",{\"0\":{\"178\":1,\"1235\":1}}],[\"spring\",{\"0\":{\"183\":1,\"184\":1,\"736\":1,\"741\":1,\"752\":1,\"754\":1,\"755\":1,\"756\":1,\"761\":1,\"779\":1,\"780\":1,\"781\":1,\"830\":1,\"832\":1,\"856\":1,\"862\":1,\"865\":1,\"867\":1,\"880\":1,\"891\":1,\"894\":1,\"903\":1,\"904\":1,\"917\":1,\"918\":1,\"920\":1,\"922\":1,\"926\":1,\"928\":1,\"975\":1,\"1018\":1,\"1019\":1,\"1024\":1,\"1070\":1,\"1135\":1,\"1138\":1,\"1157\":1,\"1173\":1,\"1174\":1,\"1240\":1,\"1241\":1,\"1243\":1,\"1654\":1,\"1656\":1,\"1657\":1,\"1658\":1,\"1798\":1,\"1983\":1,\"1989\":1},\"1\":{\"583\":2,\"892\":1,\"894\":2,\"896\":2,\"897\":1,\"899\":2,\"900\":7,\"902\":1,\"903\":9,\"908\":1,\"917\":3,\"918\":2,\"922\":3,\"924\":1,\"930\":6,\"934\":2,\"940\":4,\"941\":4,\"943\":1,\"953\":4,\"954\":4,\"955\":1,\"972\":1,\"973\":1,\"974\":2,\"982\":1,\"994\":1,\"1003\":2,\"1005\":2,\"1012\":1,\"1013\":1,\"1017\":5,\"1020\":4,\"1021\":1,\"1022\":2,\"1023\":2,\"1024\":1,\"1025\":1,\"1026\":1,\"1027\":1,\"1028\":13,\"1029\":2,\"1030\":3,\"1032\":1,\"1035\":1,\"1036\":4,\"1040\":1,\"1041\":1,\"1043\":1,\"1048\":5,\"1056\":2,\"1060\":5,\"1065\":3,\"1069\":2,\"1080\":1,\"1081\":1,\"1084\":3,\"1091\":5,\"1093\":1,\"1095\":1,\"1116\":1,\"1118\":1,\"1123\":2,\"1124\":1,\"1130\":5,\"1134\":1,\"1138\":1,\"1140\":6,\"1146\":4,\"1157\":2,\"1174\":2,\"1184\":2,\"1217\":1,\"1630\":2,\"1634\":1,\"1647\":6,\"1651\":5,\"1654\":3,\"1656\":1,\"1657\":1,\"1659\":1,\"1965\":1,\"1966\":2,\"1979\":3,\"1982\":5,\"1983\":7,\"1989\":4,\"1990\":1}}],[\"spring如何处理事务\",{\"0\":{\"181\":1,\"1238\":1}}],[\"spring是如何处理循环依赖问题的\",{\"0\":{\"180\":1,\"1237\":1}}],[\"spring面试题\",{\"0\":{\"176\":1,\"1233\":1}}],[\"specified\",{\"1\":{\"952\":1,\"1170\":1,\"1595\":5,\"1601\":3,\"1615\":1,\"1618\":3,\"1619\":2,\"1620\":1,\"1647\":1}}],[\"specifies\",{\"1\":{\"928\":1}}],[\"specification\",{\"1\":{\"1594\":2,\"1619\":1}}],[\"specific\",{\"0\":{\"1528\":1},\"1\":{\"922\":1,\"1615\":1,\"1621\":4,\"1647\":1}}],[\"specialized\",{\"1\":{\"1620\":2,\"1623\":1}}],[\"specialize\",{\"1\":{\"1620\":2}}],[\"specializations\",{\"1\":{\"1619\":1,\"1620\":3,\"1621\":1}}],[\"specialization\",{\"1\":{\"1598\":1,\"1601\":2,\"1620\":2,\"1623\":1}}],[\"specialbeaninstantiationdemo\",{\"1\":{\"930\":1}}],[\"special\",{\"1\":{\"922\":1,\"930\":2,\"1619\":1,\"1647\":1,\"1650\":1}}],[\"spi机制\",{\"0\":{\"1795\":1},\"1\":{\"1658\":1}}],[\"spin\",{\"1\":{\"1530\":1,\"1554\":1}}],[\"spinclock\",{\"1\":{\"1483\":1}}],[\"spinfreq\",{\"1\":{\"1483\":1}}],[\"spinlock\",{\"1\":{\"1480\":1}}],[\"spi扩展\",{\"1\":{\"916\":1,\"1052\":1}}],[\"spi\",{\"0\":{\"1797\":1,\"1798\":1},\"1\":{\"908\":1,\"1052\":1}}],[\"spotify\",{\"0\":{\"881\":1}}],[\"spop\",{\"1\":{\"572\":3}}],[\"smartinstantiationawarebeanpostprocessor\",{\"1\":{\"1648\":1}}],[\"smartinitialize\",{\"1\":{\"1647\":2}}],[\"smartinitializingsingleton\",{\"1\":{\"1009\":2,\"1011\":1,\"1647\":3}}],[\"smartsingleton\",{\"1\":{\"1647\":3}}],[\"smart\",{\"1\":{\"1647\":1}}],[\"smartfactorybean<\",{\"1\":{\"1647\":2}}],[\"smartfactorybean\",{\"1\":{\"1647\":2}}],[\"small\",{\"1\":{\"1620\":1}}],[\"smaller\",{\"1\":{\"1620\":1}}],[\"smallint\",{\"1\":{\"528\":1}}],[\"sms等方式去通知系统管理员关于系统不正常运行的信息\",{\"1\":{\"624\":1}}],[\"smove\",{\"1\":{\"572\":3}}],[\"smembers\",{\"1\":{\"572\":6}}],[\"s2表是驱动表\",{\"1\":{\"555\":1}}],[\"s2的扇出\",{\"1\":{\"555\":1}}],[\"s2连接s1\",{\"1\":{\"555\":1}}],[\"s2作为被驱动表\",{\"1\":{\"555\":1}}],[\"s2\",{\"1\":{\"554\":5,\"555\":14,\"1404\":4,\"1614\":3}}],[\"s1表是被驱动表\",{\"1\":{\"555\":1}}],[\"s1的扇出\",{\"1\":{\"555\":1}}],[\"s1作为被驱动表\",{\"1\":{\"555\":1}}],[\"s1连接s2\",{\"1\":{\"555\":1}}],[\"s1\",{\"1\":{\"554\":15,\"555\":14,\"1404\":4,\"1614\":3}}],[\"ssh\",{\"1\":{\"1979\":1}}],[\"sshift\",{\"1\":{\"1553\":1}}],[\"ssm\",{\"1\":{\"1979\":2,\"1983\":3}}],[\"ssm框架视频\",{\"1\":{\"1982\":1}}],[\"ssm框架\",{\"0\":{\"1982\":1},\"1\":{\"1966\":1}}],[\"ssc\",{\"1\":{\"1533\":2,\"1534\":3}}],[\"ssc=\",{\"1\":{\"1533\":1}}],[\"sscan\",{\"1\":{\"572\":1}}],[\"ssl\",{\"1\":{\"1424\":1}}],[\"sso的实现关键是将seesion信息几种存储\",{\"1\":{\"1204\":1}}],[\"sso\",{\"1\":{\"1204\":1}}],[\"ss的整数\",{\"1\":{\"529\":1}}],[\"ss\",{\"1\":{\"529\":2,\"1053\":1,\"1528\":1}}],[\"skip\",{\"1\":{\"467\":4,\"468\":2,\"965\":1,\"1610\":5,\"1647\":1}}],[\"s结构\",{\"1\":{\"455\":1}}],[\"s结果\",{\"1\":{\"455\":1}}],[\"swarm\",{\"1\":{\"1966\":1}}],[\"swaps\",{\"1\":{\"431\":1}}],[\"sweep\",{\"1\":{\"1439\":1}}],[\"swing\",{\"1\":{\"1109\":3,\"1591\":2}}],[\"switches\",{\"1\":{\"431\":1}}],[\"switch\",{\"1\":{\"405\":1,\"1162\":1,\"1175\":1}}],[\"switch=\",{\"1\":{\"404\":1}}],[\"sliceops$1\",{\"1\":{\"1610\":1}}],[\"slf4j\",{\"1\":{\"1479\":3}}],[\"slaves依然会被正确配置为指向master\",{\"1\":{\"624\":1}}],[\"slaves\",{\"1\":{\"609\":1}}],[\"slave之前\",{\"1\":{\"485\":1}}],[\"slave\",{\"1\":{\"455\":1,\"457\":1,\"467\":2,\"468\":2,\"486\":1,\"564\":1,\"606\":1}}],[\"slave命令之前还有一行set\",{\"1\":{\"468\":1}}],[\"slave命令让同步线程执行起来的时候\",{\"1\":{\"468\":1}}],[\"slave命令\",{\"1\":{\"453\":1,\"468\":1}}],[\"slow\",{\"1\":{\"428\":13,\"429\":6}}],[\"sleepingwaitstrategy策略\",{\"1\":{\"1520\":1}}],[\"sleep方法会清除中断标识\",{\"1\":{\"1477\":1}}],[\"sleep方案\",{\"1\":{\"469\":1}}],[\"sleep\",{\"0\":{\"471\":1},\"1\":{\"318\":1,\"471\":1,\"476\":1,\"1013\":1,\"1387\":1,\"1404\":7,\"1524\":1,\"1533\":1,\"1534\":1}}],[\"satb算法\",{\"0\":{\"1744\":1}}],[\"satisfy\",{\"1\":{\"1615\":1}}],[\"satisfies\",{\"1\":{\"1594\":2}}],[\"said\",{\"1\":{\"1647\":1}}],[\"sacrifice\",{\"1\":{\"1622\":1}}],[\"salaries\",{\"1\":{\"1615\":3,\"1616\":2}}],[\"says\",{\"1\":{\"1615\":2}}],[\"same\",{\"1\":{\"997\":1,\"1601\":6,\"1615\":3,\"1617\":1,\"1619\":2,\"1620\":2,\"1623\":1,\"1647\":1,\"1648\":1,\"1650\":1,\"1658\":1}}],[\"sampe\",{\"1\":{\"558\":1}}],[\"sample\",{\"1\":{\"558\":8}}],[\"saving\",{\"1\":{\"588\":1}}],[\"save\",{\"1\":{\"587\":3,\"588\":1,\"589\":1,\"1517\":1}}],[\"save命令\",{\"1\":{\"587\":1}}],[\"sadd\",{\"1\":{\"572\":3}}],[\"sakura\",{\"1\":{\"567\":1,\"570\":1,\"573\":1,\"598\":10,\"611\":4}}],[\"sakila\",{\"1\":{\"384\":6,\"390\":6}}],[\"sa\",{\"1\":{\"488\":1}}],[\"safedateformat\",{\"1\":{\"1528\":2}}],[\"safe的能力\",{\"1\":{\"325\":1}}],[\"safe\",{\"1\":{\"324\":1,\"484\":2,\"1620\":1}}],[\"survivorratio\",{\"1\":{\"1664\":1}}],[\"sure\",{\"1\":{\"1647\":2,\"1650\":1}}],[\"suited\",{\"1\":{\"1608\":2}}],[\"suspension模式在守护条件不满足的时候会一直等待至可以运行\",{\"1\":{\"1531\":1}}],[\"suspension模式不同\",{\"1\":{\"1531\":1}}],[\"suspension模式一样\",{\"1\":{\"1531\":1}}],[\"suspension模式也常被称为guarded\",{\"1\":{\"1530\":1}}],[\"suspension模式允许多个线程对实例资源进行访问\",{\"1\":{\"1530\":1}}],[\"suspension模式\",{\"0\":{\"1530\":1}}],[\"suser\",{\"1\":{\"349\":2,\"350\":4,\"351\":2}}],[\"succeed\",{\"1\":{\"1617\":1}}],[\"successfully\",{\"1\":{\"1622\":1}}],[\"successful\",{\"1\":{\"1620\":1}}],[\"success就是这个函数执行成功的回调函数\",{\"1\":{\"1593\":1}}],[\"success\",{\"1\":{\"1498\":2,\"1593\":2}}],[\"succ\",{\"1\":{\"1483\":1}}],[\"such\",{\"1\":{\"1171\":1,\"1172\":1,\"1608\":2,\"1615\":4,\"1616\":1,\"1617\":1,\"1619\":8,\"1620\":10,\"1623\":6}}],[\"sun\",{\"1\":{\"1432\":3,\"1663\":3}}],[\"sunionstore\",{\"1\":{\"572\":1}}],[\"sunion\",{\"1\":{\"572\":4}}],[\"suffix\",{\"1\":{\"928\":2,\"1618\":2}}],[\"summed\",{\"1\":{\"1619\":1}}],[\"summingint方法的说明\",{\"1\":{\"1618\":1}}],[\"summingint的实现\",{\"1\":{\"1618\":1}}],[\"summingint\",{\"1\":{\"1615\":1,\"1616\":3,\"1618\":1}}],[\"summingsalariesbydept\",{\"1\":{\"1615\":1}}],[\"summingsalaries\",{\"1\":{\"1615\":2}}],[\"summarizingint\",{\"1\":{\"1616\":1}}],[\"summarizing\",{\"1\":{\"1616\":1}}],[\"summarize\",{\"1\":{\"429\":1}}],[\"summaries\",{\"1\":{\"1615\":1}}],[\"summarystatistics\",{\"1\":{\"1610\":1}}],[\"summary\",{\"1\":{\"479\":4,\"519\":4,\"520\":4,\"1597\":1,\"1598\":3,\"1599\":2,\"1600\":1,\"1601\":1,\"1608\":8,\"1615\":1}}],[\"sumcount\",{\"1\":{\"1554\":2}}],[\"sumscore\",{\"1\":{\"574\":2}}],[\"sum\",{\"1\":{\"558\":1,\"1607\":1,\"1610\":3,\"1613\":1,\"1615\":4,\"1616\":2,\"1618\":1,\"1619\":2,\"1620\":1}}],[\"suppressed\",{\"1\":{\"1619\":1}}],[\"suppresswarnings\",{\"1\":{\"1502\":1,\"1550\":1,\"1609\":1,\"1618\":3,\"1620\":2,\"1622\":2,\"1623\":2,\"1647\":1}}],[\"supplied\",{\"1\":{\"1600\":1,\"1601\":2,\"1618\":1}}],[\"supplier的元\",{\"1\":{\"1621\":1}}],[\"supplier提供的结果容器就会传递给accumulator\",{\"1\":{\"1615\":1}}],[\"supplier会创建一个新的结果容器\",{\"1\":{\"1608\":1}}],[\"supplier就是我们要返回的结果\",{\"1\":{\"1608\":1}}],[\"supplier2\",{\"1\":{\"1600\":2}}],[\"supplier更多的适用于工厂创建对象\",{\"1\":{\"1600\":1}}],[\"supplier<\",{\"1\":{\"1621\":4,\"1650\":1}}],[\"supplier<partition<a>>\",{\"1\":{\"1618\":1}}],[\"supplier<map<k\",{\"1\":{\"1618\":2}}],[\"supplier<m>\",{\"1\":{\"1618\":1}}],[\"supplier<i>\",{\"1\":{\"1617\":1}}],[\"supplier<set<t>>\",{\"1\":{\"1617\":2,\"1618\":1}}],[\"supplier<student>\",{\"1\":{\"1600\":3}}],[\"supplier<string>\",{\"1\":{\"1600\":1,\"1606\":1}}],[\"supplier<a>\",{\"1\":{\"1615\":1,\"1616\":4,\"1618\":1}}],[\"supplier<c>\",{\"1\":{\"1609\":1,\"1618\":1}}],[\"supplier<list<t>>\",{\"1\":{\"1608\":1,\"1618\":2}}],[\"supplier<r>\",{\"1\":{\"1608\":2}}],[\"supplier<t>\",{\"1\":{\"1027\":1,\"1600\":1}}],[\"supplierjyc\",{\"1\":{\"1600\":4}}],[\"supplier不接受参数\",{\"1\":{\"1600\":1}}],[\"supplier表示提供结果的供应者\",{\"1\":{\"1600\":1}}],[\"supplier函数式接口\",{\"0\":{\"1600\":1}}],[\"supplier\",{\"1\":{\"943\":1,\"1027\":2,\"1600\":9,\"1606\":2,\"1608\":6,\"1615\":15,\"1616\":8,\"1617\":14,\"1618\":9,\"1620\":1,\"1621\":2}}],[\"supporting\",{\"1\":{\"1619\":1,\"1620\":1}}],[\"supports\",{\"1\":{\"1061\":2,\"1064\":2,\"1238\":2}}],[\"supported\",{\"1\":{\"964\":1,\"965\":1,\"1239\":1,\"1623\":1,\"1648\":2,\"1655\":1}}],[\"support\",{\"1\":{\"472\":1,\"479\":1,\"893\":1,\"963\":1,\"996\":1,\"1038\":1,\"1039\":2,\"1040\":1,\"1041\":1,\"1042\":2,\"1054\":2,\"1059\":4,\"1060\":1,\"1070\":2,\"1087\":1,\"1091\":1,\"1134\":1,\"1146\":2,\"1151\":1,\"1152\":1,\"1154\":2,\"1155\":1,\"1162\":1,\"1169\":3,\"1182\":1,\"1617\":1,\"1620\":1,\"1632\":3,\"1637\":1,\"1647\":1}}],[\"sup>\",{\"1\":{\"468\":4}}],[\"superficial\",{\"1\":{\"1619\":1}}],[\"super的user集合对象\",{\"1\":{\"917\":1,\"941\":1}}],[\"superuser\",{\"1\":{\"917\":4,\"918\":1,\"953\":1,\"954\":2,\"961\":5,\"963\":1,\"997\":5,\"1000\":8,\"1001\":8,\"1002\":3,\"1005\":10,\"1006\":5,\"1011\":5}}],[\"super\",{\"1\":{\"453\":1,\"917\":4,\"941\":1,\"1013\":1,\"1108\":2,\"1119\":3,\"1227\":1,\"1506\":2,\"1593\":1,\"1594\":5,\"1595\":1,\"1597\":1,\"1598\":6,\"1599\":4,\"1601\":2,\"1603\":1,\"1607\":1,\"1608\":2,\"1613\":1,\"1614\":3,\"1615\":1,\"1617\":4,\"1618\":18,\"1620\":8,\"1621\":7,\"1622\":8,\"1623\":3,\"1651\":1,\"1657\":3,\"1689\":4}}],[\"subtasks\",{\"1\":{\"1620\":2}}],[\"subtype\",{\"1\":{\"1620\":3}}],[\"subtract\",{\"1\":{\"429\":1,\"1598\":1}}],[\"subresults\",{\"1\":{\"1615\":1}}],[\"subresult\",{\"1\":{\"1615\":1}}],[\"submit\",{\"1\":{\"1517\":8,\"1535\":2,\"1573\":1}}],[\"submit所属顶层接口是executorservice\",{\"1\":{\"1408\":1}}],[\"submit会吃掉异常\",{\"1\":{\"1408\":1}}],[\"subclasses\",{\"1\":{\"922\":2,\"1175\":1,\"1620\":1,\"1647\":2}}],[\"subclass\",{\"1\":{\"922\":1,\"1647\":1}}],[\"subcommand\",{\"1\":{\"597\":1}}],[\"subsequent\",{\"1\":{\"1623\":1}}],[\"subset\",{\"1\":{\"1623\":1}}],[\"subsized\",{\"1\":{\"1620\":10}}],[\"substring\",{\"1\":{\"1610\":6}}],[\"substitute\",{\"1\":{\"519\":2}}],[\"subsystemb\",{\"1\":{\"928\":1}}],[\"subsystema\",{\"1\":{\"928\":1}}],[\"subscribe\",{\"1\":{\"597\":2,\"598\":2}}],[\"sub=f6e1eb8e778044ec9bb87ba05dce5e4b\",{\"1\":{\"1663\":1}}],[\"sub=5a7459fe4b464ec896f9dd9a4eb64942\",{\"1\":{\"540\":1}}],[\"sub=9a8237e2b9b248b9a2f5fc5aed6cbcf1\",{\"1\":{\"531\":1}}],[\"sub\",{\"1\":{\"393\":2,\"553\":1,\"596\":2,\"1620\":4}}],[\"subquery\",{\"1\":{\"330\":1}}],[\"s\",{\"1\":{\"336\":1,\"429\":6,\"577\":1,\"922\":1,\"946\":2,\"985\":2,\"989\":1,\"997\":2,\"1029\":2,\"1031\":2,\"1086\":1,\"1100\":6,\"1113\":2,\"1116\":2,\"1119\":2,\"1123\":2,\"1156\":2,\"1157\":2,\"1164\":1,\"1175\":2,\"1553\":4,\"1554\":5,\"1594\":2,\"1597\":2,\"1616\":2,\"1619\":5,\"1620\":9,\"1622\":4,\"1623\":10,\"1647\":4,\"1651\":1,\"1655\":1,\"1972\":1}}],[\"shift\",{\"1\":{\"1554\":2}}],[\"shiro有什么区别\",{\"0\":{\"1243\":1}}],[\"should\",{\"1\":{\"1615\":3,\"1617\":1,\"1619\":2,\"1620\":13,\"1621\":1,\"1623\":1,\"1648\":1}}],[\"shouldignorespel\",{\"1\":{\"1164\":1}}],[\"shouldskip\",{\"1\":{\"1027\":1}}],[\"shortcutdependencydescriptor\",{\"1\":{\"1648\":1}}],[\"shortcut\",{\"1\":{\"963\":3,\"1648\":3,\"1650\":1}}],[\"shortclassname\",{\"1\":{\"928\":2,\"995\":2}}],[\"short\",{\"1\":{\"645\":8,\"959\":1,\"1053\":1,\"1570\":2,\"1599\":8,\"1623\":4}}],[\"show\",{\"0\":{\"431\":1},\"1\":{\"330\":1,\"346\":1,\"410\":2,\"420\":1,\"428\":6,\"429\":1,\"430\":2,\"431\":9,\"454\":1,\"494\":1,\"503\":1,\"509\":1,\"532\":1,\"534\":1,\"538\":2,\"548\":1,\"553\":2,\"557\":1,\"558\":2,\"1260\":1,\"1262\":1}}],[\"sh\",{\"1\":{\"624\":2}}],[\"shape\",{\"1\":{\"1621\":3,\"1623\":4}}],[\"shanghai\",{\"1\":{\"576\":2,\"1030\":1}}],[\"shadow\",{\"1\":{\"561\":1}}],[\"sharing\",{\"1\":{\"1519\":1}}],[\"sharedinstance\",{\"1\":{\"1647\":5}}],[\"shared\",{\"1\":{\"1620\":1,\"1622\":1,\"1647\":1}}],[\"share\",{\"1\":{\"517\":1,\"537\":1,\"541\":1,\"1263\":1,\"1490\":1}}],[\"shardingsphere分库分表的执行流程\",{\"1\":{\"1270\":1}}],[\"shardingsphere\",{\"1\":{\"1270\":1}}],[\"sharding尽量在同一个机房\",{\"1\":{\"1257\":1}}],[\"sharding都保存好文档了之后\",{\"1\":{\"1256\":1}}],[\"sharding\",{\"1\":{\"1256\":2}}],[\"sharding处理请求\",{\"1\":{\"1256\":1}}],[\"sharding所在的datanode\",{\"1\":{\"1256\":1}}],[\"shards\",{\"1\":{\"305\":1}}],[\"shard发生重新分配时\",{\"1\":{\"304\":1}}],[\"shard上的写入被覆盖\",{\"1\":{\"304\":1}}],[\"shard级别严格递增\",{\"1\":{\"304\":1}}],[\"shutdowngracefully\",{\"1\":{\"1226\":3}}],[\"shutdownhookthreaddemo\",{\"1\":{\"1175\":1}}],[\"shutdown\",{\"1\":{\"343\":1,\"1123\":1,\"1175\":1,\"1521\":1,\"1534\":1,\"1573\":1}}],[\"sychronized+wait\",{\"1\":{\"1530\":1}}],[\"sychronized关键字和wait\",{\"1\":{\"1483\":1}}],[\"sys\",{\"1\":{\"495\":4}}],[\"systempropertyutil\",{\"1\":{\"1227\":1}}],[\"systemproperties\",{\"1\":{\"945\":1}}],[\"systemenvironmentpropertysource\",{\"1\":{\"1154\":1}}],[\"systemenvironment\",{\"1\":{\"945\":1}}],[\"system>const\",{\"1\":{\"509\":1}}],[\"system>const>eq\",{\"1\":{\"330\":1}}],[\"system\",{\"1\":{\"330\":2,\"431\":2,\"582\":3,\"583\":1,\"909\":1,\"917\":5,\"918\":4,\"919\":2,\"921\":3,\"929\":2,\"930\":7,\"931\":3,\"933\":7,\"934\":3,\"936\":1,\"940\":1,\"941\":2,\"943\":4,\"944\":3,\"946\":1,\"953\":3,\"954\":1,\"955\":3,\"957\":2,\"961\":11,\"962\":4,\"963\":1,\"973\":5,\"977\":1,\"978\":3,\"985\":15,\"989\":3,\"994\":2,\"995\":2,\"997\":3,\"1000\":3,\"1001\":4,\"1005\":8,\"1006\":4,\"1007\":4,\"1008\":1,\"1009\":1,\"1011\":5,\"1012\":3,\"1013\":3,\"1019\":1,\"1022\":2,\"1029\":1,\"1030\":1,\"1031\":2,\"1032\":2,\"1040\":2,\"1041\":2,\"1043\":2,\"1044\":3,\"1045\":2,\"1053\":5,\"1056\":1,\"1063\":1,\"1064\":2,\"1065\":2,\"1072\":3,\"1075\":2,\"1082\":1,\"1084\":2,\"1091\":1,\"1099\":3,\"1100\":3,\"1103\":2,\"1108\":1,\"1112\":1,\"1113\":1,\"1116\":1,\"1119\":1,\"1123\":1,\"1134\":1,\"1138\":1,\"1139\":1,\"1146\":1,\"1148\":4,\"1149\":2,\"1156\":3,\"1157\":2,\"1162\":1,\"1164\":5,\"1174\":2,\"1175\":3,\"1181\":5,\"1182\":2,\"1184\":2,\"1288\":1,\"1365\":2,\"1387\":1,\"1404\":9,\"1432\":2,\"1485\":1,\"1487\":3,\"1551\":2,\"1573\":4,\"1574\":4,\"1575\":5,\"1587\":1,\"1588\":1,\"1591\":9,\"1592\":3,\"1593\":7,\"1594\":1,\"1595\":13,\"1597\":2,\"1598\":12,\"1599\":7,\"1600\":5,\"1601\":2,\"1602\":1,\"1603\":4,\"1604\":4,\"1605\":4,\"1606\":2,\"1607\":9,\"1608\":2,\"1609\":10,\"1610\":17,\"1611\":2,\"1612\":8,\"1614\":1,\"1615\":2,\"1616\":8,\"1617\":18,\"1619\":11,\"1620\":4,\"1622\":3,\"1632\":1,\"1633\":1,\"1634\":1,\"1635\":1,\"1638\":1,\"1640\":1,\"1646\":2,\"1647\":2,\"1654\":4,\"1663\":2}}],[\"synchronization\",{\"1\":{\"1608\":2,\"1615\":1,\"1622\":1}}],[\"synchronized来保证并发安全性\",{\"1\":{\"1554\":1}}],[\"synchronized来实现的\",{\"1\":{\"1475\":1}}],[\"synchronized在特定的情况下对于已经在等待的线程是后来的线程先获得锁\",{\"1\":{\"1495\":1}}],[\"synchronized在jdk1\",{\"1\":{\"1483\":1}}],[\"synchronized的锁状态是无法在代码中直接判断的\",{\"1\":{\"1495\":1}}],[\"synchronized的优化\",{\"0\":{\"1489\":1}}],[\"synchronized和reentrantlock\",{\"0\":{\"1495\":1}}],[\"synchronized标志来实现\",{\"1\":{\"1483\":1}}],[\"synchronized是不可以被中断的\",{\"1\":{\"1495\":1}}],[\"synchronized是非公平锁\",{\"1\":{\"1495\":1}}],[\"synchronized是jvm层次的锁实现\",{\"1\":{\"1495\":1}}],[\"synchronized是jvm内置锁\",{\"1\":{\"1483\":1}}],[\"synchronized是通过jvm来释放\",{\"1\":{\"1394\":1}}],[\"synchronized是通过jvm底层来实现\",{\"1\":{\"1394\":1}}],[\"synchronized加锁方式\",{\"1\":{\"1482\":1}}],[\"synchronized同步块是java提供的一种原子性内置锁\",{\"1\":{\"1482\":1}}],[\"synchronized基础\",{\"0\":{\"1482\":1}}],[\"synchronized实现原理\",{\"0\":{\"1481\":1}}],[\"synchronized关键字\",{\"1\":{\"1438\":1}}],[\"synchronized关键是用来加锁\",{\"1\":{\"1384\":1}}],[\"synchronizedmap依次锁住整张表来保证线程安全\",{\"1\":{\"1401\":1}}],[\"synchronizedmap和concurrenthashmap有什么区别\",{\"0\":{\"72\":1,\"1401\":1}}],[\"synchronized与lock都提供了可重入锁\",{\"1\":{\"1394\":1}}],[\"synchronizedlist或java\",{\"1\":{\"1370\":1}}],[\"synchronized\",{\"1\":{\"922\":1,\"996\":1,\"997\":1,\"1108\":1,\"1193\":1,\"1369\":1,\"1373\":2,\"1388\":1,\"1398\":1,\"1431\":1,\"1432\":1,\"1482\":5,\"1485\":2,\"1531\":3,\"1554\":2,\"1605\":1,\"1647\":3,\"1648\":1,\"1650\":1,\"1651\":1,\"1663\":1}}],[\"synchronousqueue性能往往优于其他实现\",{\"1\":{\"1509\":1}}],[\"synchronousqueue非常适合传递性场景做交换工作\",{\"1\":{\"1505\":1}}],[\"synchronousqueue\",{\"0\":{\"1505\":1},\"1\":{\"1395\":1,\"1501\":1}}],[\"syncs所配置的规则来了\",{\"1\":{\"624\":1}}],[\"syncs\",{\"1\":{\"624\":2}}],[\"sync配合判断主备无延迟的方案\",{\"1\":{\"472\":1}}],[\"sync+位点判断的方案\",{\"1\":{\"472\":1}}],[\"sync的设计如下\",{\"1\":{\"472\":1}}],[\"sync方案\",{\"1\":{\"469\":1}}],[\"sync\",{\"1\":{\"450\":3,\"451\":8,\"465\":2,\"472\":2,\"592\":2,\"1226\":4}}],[\"syntax\",{\"1\":{\"306\":1,\"320\":1}}],[\"similarly\",{\"1\":{\"1623\":1}}],[\"similar\",{\"1\":{\"1620\":1}}],[\"similarities\",{\"1\":{\"1619\":1}}],[\"simplify\",{\"1\":{\"1542\":1,\"1620\":2}}],[\"simply\",{\"1\":{\"965\":1,\"1650\":1,\"1689\":1}}],[\"simpleurlhandlermapping\",{\"1\":{\"1657\":1}}],[\"simpleinstantiationstrategy\",{\"1\":{\"1651\":1}}],[\"simpleimmutableentry<>\",{\"1\":{\"1618\":2}}],[\"simplemetadatareader去解析类时\",{\"1\":{\"1646\":1}}],[\"simplemetadatareaderfactory\",{\"1\":{\"1646\":4}}],[\"simplealiasregistry\",{\"1\":{\"1636\":1}}],[\"simpleapplicationeventmulticaster\",{\"1\":{\"1121\":1,\"1122\":1,\"1123\":6,\"1124\":1,\"1125\":1,\"1168\":1}}],[\"simpleannotationmetadata是基于asm实现的\",{\"1\":{\"1018\":1}}],[\"simpletypeconverter\",{\"1\":{\"1093\":1,\"1640\":2}}],[\"simpledateformat\",{\"1\":{\"1053\":1,\"1528\":1}}],[\"simple\",{\"0\":{\"402\":1},\"1\":{\"329\":1,\"330\":6,\"361\":1,\"390\":2,\"402\":1,\"403\":1,\"519\":1,\"646\":1,\"1620\":1}}],[\"side\",{\"1\":{\"1597\":2,\"1619\":1,\"1623\":1}}],[\"siftupcomparable\",{\"1\":{\"1506\":1}}],[\"site\",{\"1\":{\"1201\":1}}],[\"silently\",{\"1\":{\"963\":1}}],[\"signature\",{\"1\":{\"1647\":1}}],[\"signatures\",{\"1\":{\"1608\":2}}],[\"signalnotfull\",{\"1\":{\"1503\":2}}],[\"signalnotempty\",{\"1\":{\"1503\":2}}],[\"signal方法的时候必须持有锁\",{\"1\":{\"1493\":1}}],[\"signal方法会将condition队列的首节点移动到阻塞队列尾部\",{\"1\":{\"1493\":1}}],[\"signal\",{\"1\":{\"1490\":1,\"1502\":2,\"1503\":4,\"1623\":1}}],[\"signifies\",{\"1\":{\"1550\":1}}],[\"sign\",{\"1\":{\"578\":9,\"1204\":1}}],[\"signed\",{\"1\":{\"367\":1}}],[\"sinks\",{\"1\":{\"1623\":1}}],[\"sink中的方法说明\",{\"1\":{\"1623\":1}}],[\"sink会将值映射成整型值向下游发送\",{\"1\":{\"1623\":1}}],[\"sink对于accept有一个入口点\",{\"1\":{\"1623\":1}}],[\"sink实例是用来表示管道的每一个阶段\",{\"1\":{\"1623\":1}}],[\"sink本身可以通过cancellationrequested方法来发出不要再接收数据的信号\",{\"1\":{\"1623\":1}}],[\"sink是consumer接口的一个扩展\",{\"1\":{\"1623\":1}}],[\"sink源码分析\",{\"0\":{\"1623\":1}}],[\"sink<\",{\"1\":{\"1623\":2}}],[\"sink<t>\",{\"1\":{\"1623\":2}}],[\"sink<r>\",{\"1\":{\"1622\":1}}],[\"sink<p\",{\"1\":{\"1622\":1,\"1623\":7}}],[\"sink<e\",{\"1\":{\"1621\":2,\"1623\":4}}],[\"sink\",{\"1\":{\"1621\":1,\"1622\":3,\"1623\":48}}],[\"singalall\",{\"1\":{\"1530\":1}}],[\"singal\",{\"1\":{\"1530\":2}}],[\"sington\",{\"1\":{\"991\":1}}],[\"singledemo\",{\"1\":{\"1193\":1,\"1388\":13}}],[\"singletoncurrentlyincreation\",{\"1\":{\"1649\":1}}],[\"singletonobjects\",{\"1\":{\"1649\":1}}],[\"singletonobjects属性\",{\"1\":{\"1182\":1}}],[\"singletoninstance\",{\"1\":{\"1647\":3}}],[\"singletonholder\",{\"1\":{\"1194\":2}}],[\"singletonfactories的主要逻辑\",{\"1\":{\"1649\":1}}],[\"singletonfactories\",{\"1\":{\"1184\":1,\"1649\":1}}],[\"singletonbean会被缓存\",{\"1\":{\"1182\":1}}],[\"singletonbeanregistry\",{\"1\":{\"976\":1,\"1636\":1}}],[\"singletonbeanregistrationdemo\",{\"1\":{\"936\":1}}],[\"singletonuser是共享的bean对象\",{\"1\":{\"985\":1}}],[\"singletonuser1\",{\"1\":{\"985\":4}}],[\"singletonuser\",{\"1\":{\"985\":14}}],[\"singleton和prototype并没有互斥的关系\",{\"1\":{\"984\":1}}],[\"singleton作用域\",{\"0\":{\"984\":1}}],[\"singleton\",{\"0\":{\"992\":1},\"1\":{\"922\":1,\"927\":1,\"983\":1,\"985\":4,\"992\":1,\"993\":1,\"997\":5,\"1091\":1,\"1182\":1,\"1191\":6,\"1192\":5,\"1193\":8,\"1194\":5,\"1195\":1,\"1235\":1,\"1639\":2,\"1647\":11,\"1651\":1}}],[\"singletons\",{\"1\":{\"922\":2,\"1009\":1,\"1171\":1,\"1175\":1,\"1647\":4,\"1651\":1}}],[\"single\",{\"1\":{\"438\":2,\"1204\":1,\"1521\":1,\"1597\":2,\"1608\":1,\"1615\":1,\"1620\":3,\"1621\":1}}],[\"since\",{\"1\":{\"922\":1,\"997\":1,\"1040\":2,\"1052\":2,\"1172\":1,\"1594\":5,\"1595\":1,\"1597\":2,\"1598\":2,\"1599\":2,\"1600\":1,\"1601\":1,\"1619\":1,\"1620\":3,\"1647\":2,\"1651\":1}}],[\"sinterstore\",{\"1\":{\"572\":1}}],[\"sinter\",{\"1\":{\"572\":4}}],[\"sismember\",{\"1\":{\"572\":5}}],[\"sized特性值\",{\"1\":{\"1620\":1}}],[\"sized\",{\"1\":{\"1620\":16}}],[\"sizectl\",{\"1\":{\"1554\":9}}],[\"size这个字段的含义就是hashmap中实际存在的键值对数量\",{\"1\":{\"1546\":1}}],[\"size这个配置限制了内存临时表的大小\",{\"1\":{\"421\":1}}],[\"size和key个数相关\",{\"1\":{\"567\":1}}],[\"size列就表明了采样的页面数量是多少\",{\"1\":{\"558\":1}}],[\"sizes的值是81\",{\"1\":{\"558\":1}}],[\"size的值是97\",{\"1\":{\"558\":1}}],[\"size来设定的\",{\"1\":{\"525\":1}}],[\"size来动态设置\",{\"1\":{\"343\":1}}],[\"size一半的时候\",{\"1\":{\"451\":1}}],[\"size用于控制单个线程内binlog\",{\"1\":{\"450\":1}}],[\"size定义的32768字节\",{\"1\":{\"421\":1}}],[\"size设置成32768\",{\"1\":{\"421\":1}}],[\"size设置成1024\",{\"1\":{\"421\":1}}],[\"size设定的\",{\"1\":{\"403\":1}}],[\"size就是控制这个内存大小的\",{\"1\":{\"416\":1}}],[\"size就是mysql为排序开辟的内存\",{\"1\":{\"354\":1}}],[\"size默认值是256k\",{\"1\":{\"407\":1}}],[\"size不够大的时候\",{\"1\":{\"403\":1}}],[\"size足够大的时候\",{\"1\":{\"403\":1}}],[\"size改大\",{\"1\":{\"403\":1}}],[\"size改小\",{\"1\":{\"403\":1}}],[\"size越大的时候\",{\"1\":{\"403\":1}}],[\"size越小\",{\"1\":{\"354\":1}}],[\"size超过了需要排序的数据量的大小\",{\"1\":{\"354\":1}}],[\"size\",{\"1\":{\"307\":1,\"354\":2,\"416\":1,\"421\":1,\"503\":1,\"520\":2,\"542\":1,\"558\":2,\"609\":1,\"963\":2,\"996\":1,\"1166\":2,\"1404\":2,\"1480\":2,\"1546\":1,\"1554\":4,\"1588\":1,\"1593\":1,\"1611\":1,\"1612\":1,\"1617\":1,\"1618\":2,\"1620\":6,\"1621\":1,\"1622\":1,\"1623\":5,\"1648\":2}}],[\"size=0\",{\"1\":{\"526\":1}}],[\"size=32768\",{\"1\":{\"421\":1}}],[\"size=1024\",{\"1\":{\"421\":1}}],[\"size=1\",{\"1\":{\"306\":1}}],[\"size=\",{\"1\":{\"306\":1}}],[\"sql经典练习题\",{\"1\":{\"1974\":1}}],[\"sql匹配\",{\"0\":{\"1905\":1}}],[\"sql优化的思路\",{\"1\":{\"1272\":1}}],[\"sql优化阶段\",{\"1\":{\"519\":1}}],[\"sqlsession对象是mybatis中的\",{\"1\":{\"1653\":1}}],[\"sqlsession是一种门面设计模式\",{\"1\":{\"646\":1}}],[\"sqlsessiontemplate\",{\"1\":{\"583\":1}}],[\"sqlsource\",{\"1\":{\"645\":2}}],[\"sql对应的对象\",{\"1\":{\"645\":1}}],[\"sql解析\",{\"1\":{\"645\":1}}],[\"sql准备阶段\",{\"1\":{\"519\":1}}],[\"sql标准的事务隔离级别包括\",{\"1\":{\"433\":1}}],[\"sql执行和执行结果映射处理等\",{\"1\":{\"645\":1}}],[\"sql执行阶段\",{\"1\":{\"519\":1,\"520\":1}}],[\"sql执行底层原理\",{\"0\":{\"511\":1}}],[\"sql执行计划\",{\"1\":{\"361\":1}}],[\"sql执行流程\",{\"0\":{\"323\":1}}],[\"sql语句耦合在代码中\",{\"1\":{\"645\":1}}],[\"sql语句的分析分为词法分析与语法分析\",{\"1\":{\"513\":1}}],[\"sql语句可能如下\",{\"1\":{\"366\":1}}],[\"sql语句\",{\"1\":{\"361\":1,\"1262\":1}}],[\"sql语句是这么写的\",{\"1\":{\"340\":1}}],[\"sql语句执行流程是怎样的\",{\"0\":{\"161\":1,\"1270\":1}}],[\"sql的执行计划\",{\"1\":{\"329\":1,\"362\":1}}],[\"sql如下\",{\"1\":{\"323\":1}}],[\"sql\",{\"1\":{\"319\":1,\"320\":1,\"329\":1,\"412\":1,\"418\":1,\"422\":3,\"453\":2,\"467\":1,\"479\":1,\"522\":1,\"645\":1,\"1982\":1}}],[\"soon\",{\"1\":{\"1623\":1}}],[\"so\",{\"1\":{\"1620\":2,\"1622\":1,\"1623\":1}}],[\"something\",{\"1\":{\"1479\":1}}],[\"some\",{\"1\":{\"1175\":1,\"1618\":1,\"1619\":2,\"1620\":2,\"1623\":1}}],[\"socket句柄\",{\"1\":{\"1619\":1}}],[\"socketpool\",{\"1\":{\"1573\":4}}],[\"socketchannel\",{\"1\":{\"1533\":1,\"1534\":1,\"1574\":15,\"1575\":7}}],[\"socket\",{\"1\":{\"1424\":1,\"1564\":1,\"1573\":21,\"1574\":1,\"1576\":1,\"1584\":1,\"1619\":1}}],[\"socket使用示例\",{\"0\":{\"659\":1}}],[\"sockjs\",{\"1\":{\"894\":1}}],[\"soft\",{\"1\":{\"645\":1,\"1435\":1}}],[\"sortpostprocessors\",{\"1\":{\"1166\":3}}],[\"sorted\",{\"1\":{\"963\":1,\"1280\":1,\"1611\":1,\"1612\":2,\"1618\":1,\"1620\":8,\"1622\":1}}],[\"sortedset\",{\"1\":{\"960\":1,\"1620\":1}}],[\"sorting\",{\"1\":{\"431\":1}}],[\"sort\",{\"1\":{\"330\":1,\"354\":4,\"355\":2,\"418\":1,\"420\":1,\"421\":4,\"429\":2,\"431\":1,\"519\":1,\"520\":11,\"963\":2,\"1603\":5,\"1604\":3,\"1605\":3,\"1611\":1,\"1614\":13}}],[\"sort=age\",{\"1\":{\"306\":1}}],[\"sort=字段\",{\"1\":{\"306\":1}}],[\"sourceanystateful\",{\"1\":{\"1622\":1}}],[\"sourceoropflags\",{\"1\":{\"1621\":3,\"1622\":1}}],[\"sourceflags\",{\"1\":{\"1621\":8}}],[\"sourcetype\",{\"1\":{\"1086\":1,\"1089\":1,\"1091\":3,\"1639\":3}}],[\"sourcespliterator\",{\"1\":{\"1621\":2,\"1622\":3,\"1623\":2}}],[\"sourcestage\",{\"1\":{\"1621\":2,\"1622\":10}}],[\"sourcestagespliterator\",{\"1\":{\"1621\":2,\"1622\":2}}],[\"sourcesupplier\",{\"1\":{\"1621\":3,\"1622\":3}}],[\"sources\",{\"1\":{\"1056\":1,\"1162\":1,\"1620\":1}}],[\"sourcekey\",{\"1\":{\"577\":2}}],[\"source=name\",{\"1\":{\"306\":1}}],[\"source=字段\",{\"1\":{\"306\":1}}],[\"source\",{\"1\":{\"304\":1,\"306\":2,\"309\":1,\"431\":1,\"468\":3,\"571\":2,\"572\":1,\"922\":1,\"944\":3,\"967\":1,\"1031\":1,\"1032\":1,\"1055\":4,\"1056\":3,\"1072\":14,\"1086\":1,\"1089\":1,\"1091\":2,\"1156\":6,\"1163\":1,\"1167\":4,\"1617\":2,\"1619\":11,\"1620\":30,\"1621\":19,\"1622\":3,\"1623\":4,\"1639\":2,\"1647\":1,\"1651\":1}}],[\"scm\",{\"1\":{\"1981\":1}}],[\"sc\",{\"1\":{\"1533\":4,\"1534\":4,\"1554\":19}}],[\"scop\",{\"1\":{\"989\":3}}],[\"scopenotactiveexception\",{\"1\":{\"1647\":1}}],[\"scopename\",{\"1\":{\"1647\":5}}],[\"scopedinstance\",{\"1\":{\"1647\":2}}],[\"scopedbeansbylookup\",{\"1\":{\"985\":2,\"989\":2}}],[\"scopedbeansbyinjection\",{\"1\":{\"985\":2}}],[\"scopemetadata\",{\"1\":{\"1027\":4,\"1647\":4}}],[\"scopemetadataresolver\",{\"1\":{\"1027\":2,\"1647\":1}}],[\"scopes\",{\"1\":{\"989\":1,\"1647\":1}}],[\"scope=\",{\"1\":{\"986\":1,\"987\":1,\"988\":1}}],[\"scope\",{\"1\":{\"927\":1,\"985\":4,\"986\":2,\"987\":2,\"988\":1,\"989\":4,\"997\":2,\"1022\":1,\"1126\":1,\"1182\":1,\"1621\":1,\"1632\":1,\"1633\":1,\"1647\":9}}],[\"score均为0\",{\"1\":{\"574\":2}}],[\"score=\",{\"1\":{\"1613\":1}}],[\"score=2\",{\"1\":{\"574\":1}}],[\"score=1\",{\"1\":{\"574\":1}}],[\"score2\",{\"1\":{\"574\":1}}],[\"score相同索引值按字典顺序顺序增加\",{\"1\":{\"574\":1}}],[\"score相同\",{\"1\":{\"574\":1}}],[\"score\",{\"1\":{\"574\":3,\"1603\":7,\"1605\":10,\"1613\":17}}],[\"scheduling\",{\"1\":{\"895\":1,\"1123\":1,\"1124\":3}}],[\"schemas\",{\"1\":{\"1048\":1}}],[\"schemas以及spring\",{\"1\":{\"1036\":1}}],[\"schema资源映射文件\",{\"1\":{\"1048\":1}}],[\"schema资源\",{\"1\":{\"1048\":1}}],[\"schema资源url\",{\"1\":{\"1028\":1}}],[\"schema常见有哪些\",{\"0\":{\"1034\":1}}],[\"schema映射\",{\"1\":{\"1030\":2}}],[\"schema文件\",{\"1\":{\"1030\":1}}],[\"schemalocation=\",{\"1\":{\"917\":1,\"918\":1,\"930\":2,\"953\":2,\"954\":2,\"1030\":1,\"1032\":1,\"1065\":1,\"1084\":1,\"1091\":1,\"1146\":1}}],[\"schemaless\",{\"1\":{\"301\":1}}],[\"schema系统库锁相关数据表\",{\"1\":{\"538\":1}}],[\"schema项\",{\"1\":{\"479\":1}}],[\"schema都需要额外地统计这些信息\",{\"1\":{\"479\":1}}],[\"schema库\",{\"1\":{\"479\":1}}],[\"schema库的innodb\",{\"1\":{\"434\":1,\"441\":1}}],[\"schema`\",{\"1\":{\"354\":1,\"421\":1}}],[\"schema\",{\"0\":{\"818\":1,\"819\":1,\"820\":1,\"821\":1,\"822\":1,\"823\":1,\"824\":1,\"825\":1,\"826\":1,\"827\":1},\"1\":{\"354\":2,\"434\":1,\"479\":2,\"497\":1,\"519\":2,\"520\":2,\"538\":3,\"544\":1,\"917\":3,\"918\":4,\"930\":6,\"953\":6,\"954\":6,\"1028\":6,\"1030\":6,\"1032\":3,\"1036\":1,\"1065\":6,\"1084\":3,\"1091\":6,\"1146\":3,\"1254\":1}}],[\"scatter\",{\"0\":{\"1583\":1},\"1\":{\"1583\":3,\"1585\":1}}],[\"scavenge收集器\",{\"0\":{\"1726\":1}}],[\"scavenge\",{\"1\":{\"1441\":1}}],[\"scalar\",{\"1\":{\"959\":1}}],[\"scard\",{\"1\":{\"572\":3}}],[\"scancandidatecomponents\",{\"1\":{\"1647\":1}}],[\"scannedgenericbeandefinition\",{\"1\":{\"1632\":1,\"1647\":2}}],[\"scanner\",{\"1\":{\"1573\":2,\"1574\":2,\"1575\":2,\"1635\":2,\"1647\":1,\"1651\":1}}],[\"scanning\",{\"1\":{\"1172\":1,\"1647\":1}}],[\"scanandlockforput\",{\"1\":{\"1553\":1}}],[\"scanandlockforput会去查找是否有key相同node\",{\"1\":{\"1553\":1}}],[\"scanbasepackages\",{\"1\":{\"1136\":3,\"1137\":4}}],[\"scans\",{\"1\":{\"519\":1}}],[\"scan\",{\"1\":{\"330\":2,\"519\":6,\"553\":1,\"555\":2,\"1020\":1,\"1065\":1,\"1635\":1}}],[\"scripting\",{\"1\":{\"645\":1}}],[\"scripts\",{\"1\":{\"624\":1}}],[\"script\",{\"1\":{\"306\":1,\"429\":1,\"624\":4,\"1977\":1}}],[\"studyplan\",{\"1\":{\"1972\":1}}],[\"studentlist\",{\"1\":{\"1615\":2}}],[\"studentcomparator\",{\"1\":{\"1604\":10}}],[\"student类中的静态方法comparestudentbyscore恰好是接收两个参数\",{\"1\":{\"1603\":1}}],[\"studentparam2\",{\"1\":{\"1603\":4,\"1604\":2}}],[\"studentparam1\",{\"1\":{\"1603\":4,\"1604\":2}}],[\"student4\",{\"1\":{\"1603\":4,\"1604\":3,\"1605\":2,\"1613\":2,\"1615\":2}}],[\"student3\",{\"1\":{\"1603\":4,\"1604\":3,\"1605\":2,\"1613\":2,\"1615\":2}}],[\"student2\",{\"1\":{\"1603\":8,\"1604\":7,\"1605\":6,\"1613\":2,\"1615\":2}}],[\"student1\",{\"1\":{\"1603\":8,\"1604\":7,\"1605\":6,\"1613\":2,\"1615\":2}}],[\"studenttest\",{\"1\":{\"1600\":2}}],[\"students=\",{\"1\":{\"1184\":1}}],[\"students\",{\"1\":{\"1184\":6,\"1603\":8,\"1604\":7,\"1605\":3,\"1611\":3,\"1613\":6,\"1615\":3,\"1616\":14}}],[\"student\",{\"1\":{\"1184\":12,\"1600\":8,\"1603\":30,\"1604\":26,\"1605\":23,\"1611\":15,\"1613\":25,\"1615\":8,\"1616\":18}}],[\"studentx的age字段数值+1\",{\"1\":{\"573\":1}}],[\"studentx\",{\"1\":{\"573\":19}}],[\"stl源码剖析\",{\"1\":{\"1966\":1}}],[\"styles\",{\"1\":{\"1647\":1}}],[\"stw对并发执行阶段的对象进行重新标记\",{\"1\":{\"1447\":1}}],[\"stw\",{\"1\":{\"1440\":1,\"1447\":1}}],[\"stereotype\",{\"1\":{\"1132\":1,\"1135\":1}}],[\"step\",{\"1\":{\"922\":1,\"1647\":1}}],[\"steps\",{\"1\":{\"519\":12,\"520\":4}}],[\"step`\",{\"1\":{\"368\":1}}],[\"still\",{\"1\":{\"996\":1,\"997\":1,\"1432\":1,\"1620\":1,\"1647\":1,\"1663\":1}}],[\"std\",{\"1\":{\"542\":1}}],[\"storm\",{\"1\":{\"1519\":1}}],[\"stored\",{\"1\":{\"1647\":1}}],[\"store\",{\"1\":{\"482\":2,\"1162\":1,\"1473\":1}}],[\"storage模式\",{\"0\":{\"1528\":1}}],[\"storage\",{\"1\":{\"421\":1}}],[\"stopping\",{\"1\":{\"1623\":1}}],[\"stop方法\",{\"1\":{\"1174\":1,\"1477\":1}}],[\"stopclass排除\",{\"1\":{\"1075\":1}}],[\"stop\",{\"1\":{\"454\":1,\"467\":1,\"485\":1,\"574\":1,\"1171\":1,\"1174\":4,\"1175\":1,\"1177\":1,\"1440\":1}}],[\"stmts\",{\"1\":{\"429\":1}}],[\"stmt\",{\"1\":{\"422\":3}}],[\"struts2\",{\"1\":{\"1979\":2}}],[\"structures\",{\"1\":{\"1621\":1}}],[\"structure\",{\"1\":{\"1620\":2}}],[\"structurally\",{\"1\":{\"1620\":2}}],[\"structural\",{\"1\":{\"1620\":6}}],[\"struct\",{\"1\":{\"1569\":1,\"1570\":2}}],[\"str\",{\"1\":{\"1606\":2,\"1609\":1}}],[\"str2\",{\"1\":{\"1487\":3}}],[\"str1\",{\"1\":{\"1487\":3}}],[\"strongly\",{\"1\":{\"1621\":1}}],[\"strong\",{\"1\":{\"1435\":1}}],[\"strval\",{\"1\":{\"963\":2,\"978\":1,\"1171\":2,\"1648\":2}}],[\"stream调用流程\",{\"0\":{\"1624\":1}}],[\"stream应该用于减少潜在的干扰\",{\"1\":{\"1621\":1}}],[\"stream方法的参数也是定义在collection集合中的默认方法\",{\"1\":{\"1620\":1}}],[\"stream方法的安全性\",{\"1\":{\"944\":1}}],[\"stream方法会调用的将集合作为流的元\",{\"1\":{\"1620\":1}}],[\"stream会被组合成一个stream\",{\"1\":{\"1619\":1}}],[\"stream本身又继承了basestream类\",{\"1\":{\"1619\":1}}],[\"stream本身是一个对象引用流\",{\"1\":{\"1619\":1}}],[\"stream本身其实也提供了针对与特定数据类型的具化的stream对象\",{\"1\":{\"1607\":1}}],[\"stream源码分析\",{\"0\":{\"1619\":1}}],[\"streamopflag\",{\"1\":{\"1617\":1,\"1621\":5,\"1622\":4,\"1623\":3}}],[\"streamops\",{\"1\":{\"1608\":1}}],[\"stream的源码复杂而多变\",{\"1\":{\"1613\":1}}],[\"stream也对分组提供了强有力的支持\",{\"1\":{\"1613\":1}}],[\"stream也可以分为并行流和串行流\",{\"1\":{\"1607\":1}}],[\"stream和sql非常的类似\",{\"1\":{\"1611\":1}}],[\"stream和sql语句其实非常的相似\",{\"1\":{\"1611\":1}}],[\"stream只能使用一次\",{\"1\":{\"1610\":1}}],[\"stream实际上和文件系统中的io流有很多类似的性质\",{\"1\":{\"1610\":1}}],[\"stream实例剖析\",{\"0\":{\"1609\":1}}],[\"stream陷阱剖析\",{\"0\":{\"1610\":1}}],[\"stream类源码解析\",{\"0\":{\"1608\":1}}],[\"streams$1\",{\"1\":{\"1619\":3}}],[\"streamshape\",{\"1\":{\"1617\":1,\"1622\":2,\"1623\":2}}],[\"streams\",{\"1\":{\"1607\":2,\"1609\":2,\"1619\":12,\"1620\":2,\"1621\":5}}],[\"streamsupport中的stream方法\",{\"1\":{\"1621\":1}}],[\"streamsupport\",{\"1\":{\"1607\":2,\"1609\":1,\"1620\":2,\"1621\":1}}],[\"stream3\",{\"1\":{\"1607\":1,\"1610\":2}}],[\"stream<r>\",{\"1\":{\"1622\":1}}],[\"stream<e>\",{\"1\":{\"1620\":2,\"1621\":1}}],[\"stream<integer>\",{\"1\":{\"1610\":6}}],[\"stream<list<integer>>\",{\"1\":{\"1609\":1}}],[\"stream<string>\",{\"1\":{\"1608\":3,\"1609\":3,\"1619\":3}}],[\"stream<t>>\",{\"1\":{\"1619\":1}}],[\"stream<t>\",{\"1\":{\"1607\":2,\"1609\":1,\"1619\":1,\"1621\":1}}],[\"stream<object>\",{\"1\":{\"963\":1}}],[\"stream1\",{\"1\":{\"1607\":2}}],[\"streamtest9\",{\"1\":{\"1612\":1}}],[\"streamtest8\",{\"1\":{\"1610\":1}}],[\"streamtest7\",{\"1\":{\"1610\":2}}],[\"streamtest6\",{\"1\":{\"1609\":2,\"1610\":5}}],[\"streamtest1\",{\"1\":{\"1615\":1}}],[\"streamtest13\",{\"1\":{\"1613\":1}}],[\"streamtest10\",{\"1\":{\"1612\":2}}],[\"streamtest12\",{\"1\":{\"1609\":1}}],[\"streamtest11\",{\"1\":{\"1609\":2}}],[\"streamtest5\",{\"1\":{\"1609\":3}}],[\"streamtest4\",{\"1\":{\"1608\":3,\"1609\":3}}],[\"streamtest3\",{\"1\":{\"1607\":1,\"1620\":1}}],[\"streamtest2\",{\"1\":{\"1607\":3,\"1619\":13}}],[\"streamtest\",{\"1\":{\"1607\":3}}],[\"stream2\",{\"1\":{\"1592\":2,\"1607\":1,\"1610\":3,\"1619\":6}}],[\"streamdependencydescriptor\",{\"1\":{\"963\":2}}],[\"stream扩展\",{\"1\":{\"943\":1}}],[\"stream\",{\"1\":{\"909\":1,\"943\":2,\"944\":2,\"963\":5,\"1043\":1,\"1044\":1,\"1075\":2,\"1099\":2,\"1349\":1,\"1593\":1,\"1598\":2,\"1607\":16,\"1608\":16,\"1609\":27,\"1610\":24,\"1611\":1,\"1612\":3,\"1613\":9,\"1615\":4,\"1616\":19,\"1617\":6,\"1618\":5,\"1619\":49,\"1620\":15,\"1621\":18,\"1622\":11,\"1623\":21}}],[\"strlen\",{\"1\":{\"570\":2}}],[\"straight\",{\"1\":{\"401\":1,\"402\":1,\"403\":1}}],[\"striped64\",{\"1\":{\"1480\":1}}],[\"strictmap如果出现重复的key会直接抛出异常\",{\"1\":{\"1208\":1}}],[\"strict\",{\"1\":{\"309\":1,\"1620\":1}}],[\"stringtouserconverter\",{\"1\":{\"1639\":2}}],[\"stringtouserpropertyeditor\",{\"1\":{\"1638\":2,\"1640\":1}}],[\"stringtopropertiespropertyeditor\",{\"1\":{\"1082\":2,\"1084\":2}}],[\"stringjoiner是jdk1\",{\"1\":{\"1618\":1}}],[\"stringjoiner\",{\"1\":{\"1618\":4}}],[\"stringarray\",{\"1\":{\"1608\":2}}],[\"string常量池需要\",{\"1\":{\"1342\":1}}],[\"string被设计成一个不可变的类\",{\"1\":{\"1342\":1}}],[\"stringvalueresolver\",{\"1\":{\"1146\":1}}],[\"stringlist\",{\"1\":{\"1100\":3,\"1103\":2}}],[\"stringlist也是list泛型类型的具体化\",{\"1\":{\"1100\":1}}],[\"stringreader\",{\"1\":{\"1082\":1,\"1084\":1}}],[\"stringredistemplate\",{\"1\":{\"583\":1}}],[\"string>\",{\"1\":{\"1043\":1,\"1551\":2,\"1606\":1,\"1617\":6,\"1618\":3}}],[\"stringiterable\",{\"1\":{\"943\":2}}],[\"stringutils\",{\"1\":{\"928\":2,\"929\":1,\"997\":1,\"1007\":1,\"1030\":1,\"1647\":3}}],[\"string序列化方式\",{\"1\":{\"583\":1}}],[\"string类型\",{\"1\":{\"1085\":1}}],[\"string类似的使用场景\",{\"1\":{\"570\":1}}],[\"string类为什么是不可变的\",{\"0\":{\"13\":1,\"1342\":1}}],[\"stringstream\",{\"1\":{\"1608\":4}}],[\"strings\",{\"1\":{\"429\":1,\"1593\":1,\"1608\":3,\"1615\":1,\"1616\":1,\"1623\":4}}],[\"string中hashcode的实现\",{\"0\":{\"18\":1,\"1347\":1}}],[\"stringbuilder来替代string\",{\"1\":{\"1342\":1}}],[\"stringbuilder\",{\"0\":{\"12\":1,\"1341\":1},\"1\":{\"1084\":2,\"1091\":2,\"1341\":1,\"1608\":6,\"1615\":1,\"1618\":4}}],[\"stringbuffer的append是个同步方法\",{\"1\":{\"1487\":1}}],[\"stringbuffer内部同步\",{\"1\":{\"1485\":1}}],[\"stringbuffer\",{\"0\":{\"12\":1,\"1341\":1},\"1\":{\"1341\":1,\"1486\":2,\"1487\":4}}],[\"string\",{\"0\":{\"12\":1,\"570\":1,\"1341\":1},\"1\":{\"306\":1,\"352\":1,\"429\":1,\"569\":1,\"577\":1,\"578\":1,\"582\":4,\"583\":2,\"645\":4,\"909\":7,\"917\":12,\"918\":1,\"919\":1,\"921\":3,\"927\":1,\"928\":11,\"929\":3,\"930\":4,\"931\":3,\"933\":2,\"934\":1,\"936\":1,\"940\":6,\"943\":8,\"944\":2,\"946\":8,\"953\":7,\"954\":2,\"955\":2,\"957\":1,\"959\":1,\"961\":7,\"962\":2,\"963\":12,\"964\":3,\"973\":1,\"977\":3,\"978\":6,\"985\":15,\"989\":9,\"994\":2,\"995\":4,\"996\":1,\"997\":6,\"998\":1,\"1000\":4,\"1001\":4,\"1002\":2,\"1003\":7,\"1005\":10,\"1006\":4,\"1007\":2,\"1008\":2,\"1011\":3,\"1019\":4,\"1022\":3,\"1023\":1,\"1027\":2,\"1029\":1,\"1030\":3,\"1031\":3,\"1032\":5,\"1040\":2,\"1041\":2,\"1043\":20,\"1044\":2,\"1045\":1,\"1053\":7,\"1056\":1,\"1063\":1,\"1064\":3,\"1065\":5,\"1072\":2,\"1075\":1,\"1082\":5,\"1083\":6,\"1084\":4,\"1091\":2,\"1099\":4,\"1100\":4,\"1103\":2,\"1108\":1,\"1112\":1,\"1113\":1,\"1116\":1,\"1119\":4,\"1120\":1,\"1123\":2,\"1134\":1,\"1136\":4,\"1137\":3,\"1138\":6,\"1139\":2,\"1146\":1,\"1147\":4,\"1148\":1,\"1149\":1,\"1156\":2,\"1157\":1,\"1166\":4,\"1170\":2,\"1171\":2,\"1174\":1,\"1175\":1,\"1181\":1,\"1182\":1,\"1184\":9,\"1280\":1,\"1341\":1,\"1365\":1,\"1387\":1,\"1391\":1,\"1404\":3,\"1432\":1,\"1479\":1,\"1482\":1,\"1485\":1,\"1487\":3,\"1521\":1,\"1526\":1,\"1535\":3,\"1546\":1,\"1551\":1,\"1573\":4,\"1574\":6,\"1575\":7,\"1587\":1,\"1588\":1,\"1591\":3,\"1592\":1,\"1593\":10,\"1594\":2,\"1595\":10,\"1597\":3,\"1598\":7,\"1599\":4,\"1600\":7,\"1601\":4,\"1602\":1,\"1603\":5,\"1604\":2,\"1605\":7,\"1606\":7,\"1607\":12,\"1608\":10,\"1609\":17,\"1610\":10,\"1612\":4,\"1613\":10,\"1614\":16,\"1615\":1,\"1616\":1,\"1617\":2,\"1619\":2,\"1620\":2,\"1623\":1,\"1638\":1,\"1639\":3,\"1646\":2,\"1647\":22,\"1648\":17,\"1650\":1,\"1654\":2,\"1655\":1,\"1658\":1,\"1663\":2}}],[\"stack\",{\"1\":{\"1986\":1}}],[\"stages\",{\"1\":{\"1621\":1,\"1623\":5}}],[\"stage\",{\"1\":{\"1617\":1,\"1621\":6,\"1622\":4,\"1623\":12}}],[\"stampedlock\",{\"1\":{\"1498\":1}}],[\"stamp\",{\"1\":{\"1479\":15,\"1554\":2}}],[\"stampholder\",{\"1\":{\"1479\":8}}],[\"stamp为1\",{\"1\":{\"1479\":1}}],[\"stale\",{\"1\":{\"997\":1,\"1647\":1}}],[\"stable\",{\"1\":{\"996\":1}}],[\"star是所有io的总次数\",{\"1\":{\"479\":1}}],[\"startswith\",{\"1\":{\"1623\":1}}],[\"starts\",{\"1\":{\"1623\":1}}],[\"starttime\",{\"1\":{\"1612\":2}}],[\"startinclusive\",{\"1\":{\"1607\":6}}],[\"starting\",{\"1\":{\"431\":1}}],[\"start方法\",{\"1\":{\"1173\":1,\"1477\":1}}],[\"start和end只能按字节\",{\"1\":{\"578\":1}}],[\"start\",{\"1\":{\"454\":2,\"467\":2,\"468\":2,\"485\":1,\"542\":1,\"570\":1,\"571\":2,\"574\":3,\"578\":2,\"922\":2,\"989\":1,\"1112\":1,\"1113\":1,\"1173\":2,\"1174\":2,\"1177\":1,\"1387\":1,\"1404\":7,\"1479\":2,\"1487\":2,\"1521\":1,\"1533\":1,\"1551\":2,\"1573\":1,\"1591\":2,\"1592\":2,\"1647\":5,\"1651\":3}}],[\"started\",{\"1\":{\"434\":1,\"588\":1}}],[\"starter\",{\"0\":{\"190\":1,\"1249\":1},\"1\":{\"583\":1,\"1249\":1}}],[\"startupdate\",{\"1\":{\"1162\":2}}],[\"startupstep\",{\"1\":{\"922\":2,\"1647\":5,\"1651\":3}}],[\"startupshutdownmonitor\",{\"1\":{\"922\":1,\"1647\":1,\"1651\":1}}],[\"startup\",{\"1\":{\"429\":1,\"996\":2,\"1164\":2}}],[\"standardreflectionparameternamediscoverer\",{\"1\":{\"1648\":1}}],[\"standardopenoption\",{\"1\":{\"1587\":3,\"1588\":3}}],[\"standardbeanexpressionresolver\",{\"1\":{\"1164\":1}}],[\"standardannotationmetadata\",{\"1\":{\"1134\":2}}],[\"standardannotationmetadata是基于java注解实现的\",{\"1\":{\"1018\":1}}],[\"standard\",{\"1\":{\"429\":1,\"1087\":1,\"1647\":1}}],[\"staffs\",{\"1\":{\"370\":4,\"372\":2}}],[\"states\",{\"1\":{\"1623\":1}}],[\"statefulop\",{\"1\":{\"1624\":1}}],[\"stateful\",{\"1\":{\"1621\":4,\"1623\":1}}],[\"statelessop继承了referencepipeline\",{\"1\":{\"1623\":1}}],[\"statelessop\",{\"1\":{\"1622\":1,\"1624\":1}}],[\"statelessop<e\",{\"1\":{\"1622\":1}}],[\"statelessop<p\",{\"1\":{\"1622\":1}}],[\"stateless\",{\"1\":{\"1608\":2,\"1619\":1,\"1622\":1,\"1623\":1}}],[\"statelessness\",{\"1\":{\"1608\":2}}],[\"state属性三种访问方式\",{\"1\":{\"1490\":1}}],[\"state表示资源的可用状态\",{\"1\":{\"1490\":1}}],[\"state\",{\"1\":{\"928\":1,\"995\":1,\"1162\":1,\"1175\":2,\"1490\":1,\"1608\":2,\"1615\":1,\"1617\":5,\"1619\":1,\"1622\":1,\"1623\":7,\"1647\":2,\"1648\":1,\"1655\":1}}],[\"statement\",{\"1\":{\"645\":1,\"1619\":1}}],[\"static<t\",{\"1\":{\"1618\":1}}],[\"static<t>\",{\"1\":{\"1607\":1,\"1609\":1}}],[\"statically\",{\"1\":{\"1170\":1}}],[\"staticwebapplicationcontext\",{\"1\":{\"1169\":1}}],[\"staticmessagesource\",{\"1\":{\"1059\":1,\"1063\":6}}],[\"statictextsqlnode\",{\"1\":{\"645\":1}}],[\"static\",{\"1\":{\"582\":2,\"909\":1,\"917\":6,\"918\":1,\"919\":1,\"921\":4,\"927\":1,\"928\":2,\"929\":3,\"930\":7,\"931\":1,\"933\":1,\"934\":1,\"936\":1,\"940\":2,\"941\":2,\"943\":4,\"944\":7,\"946\":4,\"953\":4,\"954\":2,\"955\":2,\"957\":3,\"961\":3,\"962\":1,\"963\":1,\"964\":1,\"967\":2,\"973\":1,\"977\":1,\"978\":1,\"985\":11,\"989\":4,\"994\":1,\"995\":1,\"997\":1,\"1000\":2,\"1001\":2,\"1002\":1,\"1005\":3,\"1006\":2,\"1011\":1,\"1019\":1,\"1022\":1,\"1029\":1,\"1030\":1,\"1031\":1,\"1032\":2,\"1040\":1,\"1041\":1,\"1043\":4,\"1044\":1,\"1045\":1,\"1053\":2,\"1056\":1,\"1061\":1,\"1063\":2,\"1064\":2,\"1065\":3,\"1072\":2,\"1075\":1,\"1082\":1,\"1084\":1,\"1099\":1,\"1100\":6,\"1103\":1,\"1108\":3,\"1112\":1,\"1113\":2,\"1114\":1,\"1116\":3,\"1119\":1,\"1120\":1,\"1123\":2,\"1134\":1,\"1138\":1,\"1139\":1,\"1146\":1,\"1148\":1,\"1149\":1,\"1156\":1,\"1166\":1,\"1174\":1,\"1175\":1,\"1181\":1,\"1182\":2,\"1184\":3,\"1191\":2,\"1192\":2,\"1194\":3,\"1227\":1,\"1365\":1,\"1368\":1,\"1387\":3,\"1404\":7,\"1456\":2,\"1475\":3,\"1479\":1,\"1480\":1,\"1482\":8,\"1487\":1,\"1503\":1,\"1506\":1,\"1521\":1,\"1528\":3,\"1535\":2,\"1546\":1,\"1548\":2,\"1551\":2,\"1554\":1,\"1557\":1,\"1587\":1,\"1588\":1,\"1591\":3,\"1592\":1,\"1593\":6,\"1594\":2,\"1595\":6,\"1597\":2,\"1598\":8,\"1599\":7,\"1600\":3,\"1601\":3,\"1602\":1,\"1603\":4,\"1604\":2,\"1605\":5,\"1606\":2,\"1607\":13,\"1608\":4,\"1609\":13,\"1610\":8,\"1612\":3,\"1613\":3,\"1614\":5,\"1615\":2,\"1616\":1,\"1617\":3,\"1618\":18,\"1619\":2,\"1620\":13,\"1621\":4,\"1622\":1,\"1623\":2,\"1646\":1,\"1648\":2,\"1652\":1,\"1654\":3}}],[\"statistics\",{\"1\":{\"431\":1}}],[\"statu和idx\",{\"1\":{\"558\":1}}],[\"status这两个列组合起来不重复的值有多少\",{\"1\":{\"558\":1}}],[\"status来说\",{\"1\":{\"558\":1}}],[\"status来优化查询\",{\"1\":{\"526\":1}}],[\"status`\",{\"1\":{\"553\":1}}],[\"status展示出的rows的值\",{\"1\":{\"553\":1}}],[\"status得到当前主库执行到的file和position\",{\"1\":{\"473\":1}}],[\"status的结果\",{\"1\":{\"468\":1}}],[\"status的部分结果如下\",{\"1\":{\"424\":1}}],[\"status命令\",{\"1\":{\"396\":1,\"457\":1,\"467\":1}}],[\"status\",{\"1\":{\"330\":1,\"354\":2,\"428\":2,\"431\":1,\"474\":1,\"503\":1,\"538\":2,\"544\":1,\"547\":2,\"548\":1,\"553\":4,\"555\":2,\"558\":2,\"997\":1,\"1647\":1,\"1655\":6}}],[\"stat\",{\"1\":{\"558\":4}}],[\"stats命令查看latest\",{\"1\":{\"588\":1}}],[\"stats表就相当于一个普通的表一样\",{\"1\":{\"559\":1}}],[\"stats表\",{\"1\":{\"559\":2}}],[\"stats表里的统计数据也在变化\",{\"1\":{\"559\":1}}],[\"stats表的每条记录代表着一个索引的一个统计项\",{\"1\":{\"558\":1}}],[\"stats表的数据\",{\"1\":{\"558\":1}}],[\"stats和innodb\",{\"1\":{\"559\":3}}],[\"stats存储了关于索引的统计就数据\",{\"1\":{\"558\":1}}],[\"stats存储了关于表的统计数据\",{\"1\":{\"558\":1}}],[\"stats\",{\"1\":{\"347\":1,\"558\":15,\"559\":5,\"1432\":1,\"1663\":1}}],[\"self\",{\"1\":{\"1621\":1,\"1648\":1}}],[\"seller\",{\"1\":{\"1615\":1}}],[\"selelct语句直到状态4都不能执行\",{\"1\":{\"472\":1}}],[\"selectedkeys\",{\"1\":{\"1574\":2}}],[\"selectionkeys\",{\"1\":{\"1574\":4}}],[\"selectionkey\",{\"1\":{\"1574\":9}}],[\"selectimports\",{\"1\":{\"1138\":1}}],[\"select和poll都需要在返回后\",{\"1\":{\"1570\":1}}],[\"select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制\",{\"1\":{\"1569\":1}}],[\"select的数据列只用从索引中就能够取得\",{\"1\":{\"330\":1}}],[\"select目前几乎在所有的平台上支持\",{\"1\":{\"1569\":1}}],[\"select函数监视的文件描述符分为3类\",{\"1\":{\"1569\":1}}],[\"select就会返回\",{\"1\":{\"1565\":1}}],[\"select机制\",{\"1\":{\"1423\":1}}],[\"selector会不断的轮询注册在它上面的channel\",{\"1\":{\"1574\":1}}],[\"selector会根据channel上发生的读写时间\",{\"1\":{\"1422\":1}}],[\"selector对应一个或者多个线程\",{\"1\":{\"1422\":1}}],[\"selector\",{\"0\":{\"689\":1},\"1\":{\"1422\":1,\"1574\":28}}],[\"select操作不会更新版本号\",{\"1\":{\"535\":1}}],[\"select后面的是子查询\",{\"1\":{\"508\":1}}],[\"select这种批量插入数据的场景时\",{\"1\":{\"492\":1}}],[\"select这样的批量插入数据的语句\",{\"1\":{\"492\":1}}],[\"select语句在默认设置下\",{\"1\":{\"492\":1}}],[\"select\",{\"0\":{\"93\":1,\"476\":1,\"1423\":1,\"1569\":1},\"1\":{\"317\":1,\"319\":1,\"320\":1,\"321\":1,\"322\":2,\"329\":3,\"330\":12,\"340\":1,\"341\":1,\"346\":3,\"347\":1,\"348\":2,\"349\":1,\"350\":2,\"351\":2,\"352\":1,\"353\":1,\"354\":5,\"361\":3,\"366\":2,\"367\":2,\"368\":7,\"370\":6,\"371\":2,\"372\":2,\"373\":2,\"374\":2,\"375\":12,\"376\":3,\"378\":15,\"384\":2,\"390\":6,\"394\":4,\"400\":1,\"401\":1,\"402\":1,\"403\":1,\"404\":1,\"407\":3,\"408\":2,\"409\":2,\"411\":2,\"413\":2,\"414\":2,\"416\":3,\"417\":1,\"418\":1,\"419\":1,\"420\":1,\"421\":3,\"422\":8,\"431\":5,\"434\":1,\"473\":1,\"474\":1,\"476\":2,\"477\":1,\"479\":1,\"492\":1,\"509\":6,\"514\":1,\"518\":1,\"519\":9,\"520\":6,\"522\":6,\"524\":1,\"525\":5,\"526\":4,\"537\":1,\"538\":3,\"541\":2,\"542\":1,\"544\":2,\"547\":1,\"549\":2,\"553\":4,\"554\":5,\"555\":3,\"557\":2,\"558\":2,\"567\":3,\"569\":1,\"603\":1,\"1263\":2,\"1423\":1,\"1498\":1,\"1565\":4,\"1568\":1,\"1569\":1,\"1574\":2,\"1611\":1,\"1613\":1}}],[\"semaphore与reentantlock的逻辑实现区别在于semaphore是共享锁\",{\"1\":{\"1496\":1}}],[\"semaphore与countdownlatch\",{\"0\":{\"1496\":1}}],[\"semaphore可以用于做流量控制\",{\"1\":{\"1496\":1}}],[\"semaphore\",{\"1\":{\"1404\":7,\"1496\":1}}],[\"semi\",{\"1\":{\"472\":3}}],[\"separately\",{\"1\":{\"1621\":1}}],[\"separated\",{\"1\":{\"1616\":1}}],[\"separate\",{\"1\":{\"1166\":1,\"1620\":1}}],[\"separator\",{\"1\":{\"928\":2,\"1084\":1,\"1091\":1}}],[\"seed\",{\"1\":{\"1609\":9}}],[\"see\",{\"1\":{\"1162\":1,\"1598\":5,\"1601\":2,\"1620\":2,\"1621\":1,\"1623\":2}}],[\"seesion\",{\"1\":{\"346\":1}}],[\"seesion还能进行身份验证吗\",{\"0\":{\"217\":1,\"1200\":1}}],[\"se\",{\"1\":{\"900\":1,\"908\":1}}],[\"segmentfault\",{\"1\":{\"1974\":1}}],[\"segment对象的put方法源代码如下\",{\"1\":{\"1553\":1}}],[\"segments\",{\"1\":{\"1553\":1,\"1621\":1}}],[\"segmentshift\",{\"1\":{\"1553\":1}}],[\"segment\",{\"1\":{\"1553\":1,\"1621\":3,\"1623\":1}}],[\"segmentmask\",{\"1\":{\"1553\":1}}],[\"segment<k\",{\"1\":{\"1553\":2}}],[\"segment的数组结构为hashentry的数组\",{\"1\":{\"1553\":1}}],[\"segment是concurrenthashmap的内部类\",{\"1\":{\"1553\":1}}],[\"segment中旧记录链\",{\"1\":{\"542\":1}}],[\"segment里\",{\"1\":{\"542\":1}}],[\"series\",{\"1\":{\"1615\":1}}],[\"serial收集器\",{\"0\":{\"1724\":1}}],[\"serially\",{\"1\":{\"1615\":1}}],[\"serialversionuid\",{\"1\":{\"1614\":2}}],[\"serial\",{\"0\":{\"1727\":1},\"1\":{\"1441\":2,\"1620\":1,\"1623\":1}}],[\"serializable\",{\"1\":{\"433\":1,\"532\":1,\"963\":1,\"966\":1,\"1238\":1,\"1262\":1,\"1614\":3}}],[\"sercuity\",{\"0\":{\"1243\":1}}],[\"sermonlizhi\",{\"1\":{\"561\":1}}],[\"service组件还包含了若干executor组件\",{\"1\":{\"1686\":1}}],[\"service组件\",{\"0\":{\"1686\":1}}],[\"service>\",{\"1\":{\"1683\":1}}],[\"services目录下放置一个名称为javax\",{\"1\":{\"1658\":1}}],[\"servicetype\",{\"1\":{\"930\":1}}],[\"serviceloader<userfactory>\",{\"1\":{\"930\":2}}],[\"serviceloaderfactorybean\",{\"1\":{\"930\":1}}],[\"serviceloader\",{\"1\":{\"908\":1,\"930\":10}}],[\"service\",{\"1\":{\"899\":1,\"1023\":1,\"1131\":1,\"1142\":1,\"1171\":4,\"1236\":1,\"1242\":1,\"1646\":1,\"1685\":1}}],[\"server检查事务状态\",{\"0\":{\"1945\":1}}],[\"server定时扫描\",{\"0\":{\"1944\":1}}],[\"server组件指的就是整个tomcat服务器\",{\"1\":{\"1685\":1}}],[\"server组件\",{\"0\":{\"1685\":1}}],[\"server>\",{\"1\":{\"1683\":1}}],[\"serversocket\",{\"1\":{\"1573\":8}}],[\"serversocketchannel\",{\"1\":{\"1533\":2,\"1534\":2,\"1574\":6}}],[\"server性能更好\",{\"1\":{\"1565\":1}}],[\"server不一定比使用mutli\",{\"1\":{\"1565\":1}}],[\"server端会建立通道一直等待连接\",{\"1\":{\"1420\":1}}],[\"server是多线程的\",{\"1\":{\"1292\":1}}],[\"serverbootstrap通常使用bind\",{\"1\":{\"1226\":1}}],[\"serverbootstrap是客户端的启动引导类\",{\"1\":{\"1226\":1}}],[\"serverbootstrap\",{\"0\":{\"700\":1},\"1\":{\"1226\":3}}],[\"server层\",{\"1\":{\"557\":1}}],[\"server层对于返回的每一行\",{\"1\":{\"399\":1}}],[\"server层拿到id后\",{\"1\":{\"399\":1}}],[\"server层包括连接器\",{\"1\":{\"317\":1}}],[\"server\",{\"1\":{\"318\":1,\"412\":1,\"413\":3,\"429\":3,\"454\":1,\"478\":1,\"481\":1,\"557\":1,\"564\":1,\"1020\":1,\"1664\":1}}],[\"servletresponse的转化\",{\"1\":{\"1687\":1}}],[\"servletregistration\",{\"1\":{\"1658\":1}}],[\"servletrequestparameterpropertyvalues\",{\"1\":{\"1071\":1}}],[\"servletrequestdatabinder\",{\"1\":{\"1070\":1}}],[\"servletappcontext\",{\"1\":{\"1658\":3}}],[\"servletname\",{\"1\":{\"1658\":4}}],[\"servlet接口名\",{\"1\":{\"1658\":1}}],[\"servletwebserverapplicationcontext\",{\"1\":{\"1169\":1}}],[\"servlet配置属性源\",{\"1\":{\"1154\":1}}],[\"servletconfigpropertysource\",{\"1\":{\"1154\":1}}],[\"servletconfigpropertyvalue\",{\"1\":{\"1071\":1}}],[\"servletcontext配置属性源\",{\"1\":{\"1154\":1}}],[\"servletcontextpropertysource\",{\"1\":{\"1154\":1}}],[\"servletcontextresource\",{\"1\":{\"1039\":1}}],[\"servletcontext\",{\"1\":{\"1039\":1,\"1658\":4}}],[\"servlet的容器也是ioc的实现\",{\"1\":{\"914\":1}}],[\"servlet技术栈\",{\"1\":{\"894\":1}}],[\"servlet\",{\"1\":{\"273\":1,\"891\":1,\"908\":1,\"1110\":2,\"1169\":1,\"1657\":4,\"1658\":3,\"1683\":1,\"1978\":1}}],[\"send\",{\"1\":{\"1623\":2}}],[\"sends\",{\"1\":{\"1623\":3}}],[\"sendfile拷贝流程省掉了2次用户态和内核态的切换\",{\"1\":{\"1582\":1}}],[\"sendfile\",{\"0\":{\"1583\":1},\"1\":{\"1582\":2,\"1583\":3,\"1584\":1,\"1585\":4,\"1586\":1}}],[\"sendfile系统调用方法\",{\"1\":{\"1576\":1}}],[\"sending\",{\"1\":{\"431\":1,\"1623\":2}}],[\"sentinel\",{\"1\":{\"621\":3,\"624\":16}}],[\"sentinel是一个分布式架构\",{\"1\":{\"621\":1}}],[\"sentinel提供高可用\",{\"1\":{\"568\":1}}],[\"sent\",{\"1\":{\"420\":1,\"429\":2,\"1623\":3}}],[\"session共享\",{\"1\":{\"1200\":1}}],[\"session复制\",{\"1\":{\"1200\":1}}],[\"session黏贴\",{\"1\":{\"1200\":1}}],[\"session要如何扩展\",{\"1\":{\"1200\":1}}],[\"session是无法进行身份验证的\",{\"1\":{\"1200\":1}}],[\"sessionscope\",{\"1\":{\"987\":1}}],[\"sessionscope或\",{\"1\":{\"987\":1}}],[\"session作用域\",{\"0\":{\"987\":1}}],[\"session\",{\"1\":{\"346\":2,\"354\":2,\"410\":1,\"412\":5,\"413\":4,\"424\":6,\"441\":1,\"446\":4,\"447\":9,\"454\":1,\"465\":1,\"468\":2,\"474\":1,\"480\":2,\"481\":4,\"492\":5,\"497\":5,\"519\":2,\"520\":2,\"645\":1,\"983\":1,\"987\":2,\"991\":1,\"1182\":1,\"1235\":1,\"1262\":1,\"1647\":1,\"1978\":1}}],[\"secureclassloader又继承了classloader\",{\"1\":{\"1432\":1}}],[\"secure\",{\"1\":{\"1424\":1}}],[\"security实现\",{\"1\":{\"1204\":1}}],[\"security框架中采用的防范方式\",{\"1\":{\"1201\":1}}],[\"security安全控制\",{\"1\":{\"998\":1}}],[\"security\",{\"1\":{\"900\":1}}],[\"secret\",{\"1\":{\"624\":1}}],[\"second\",{\"1\":{\"498\":1,\"569\":1,\"609\":1,\"1598\":2,\"1619\":1}}],[\"seconds\",{\"1\":{\"457\":1,\"472\":1,\"570\":1,\"1573\":1}}],[\"secondary\",{\"1\":{\"335\":1}}],[\"sec\",{\"1\":{\"329\":1,\"330\":6,\"361\":1,\"371\":2,\"428\":4,\"431\":4,\"434\":1}}],[\"section\",{\"0\":{\"284\":1,\"286\":1},\"1\":{\"645\":1}}],[\"search\",{\"1\":{\"306\":14,\"542\":1,\"556\":2,\"1254\":1}}],[\"sex\",{\"1\":{\"306\":9,\"573\":4}}],[\"sequentially\",{\"1\":{\"1615\":1,\"1619\":1,\"1620\":4}}],[\"sequential\",{\"1\":{\"1609\":1,\"1615\":2,\"1617\":5,\"1619\":5,\"1620\":2,\"1621\":4,\"1623\":1}}],[\"sequence\",{\"1\":{\"451\":1,\"1520\":1,\"1597\":2,\"1619\":1}}],[\"seq\",{\"1\":{\"304\":4,\"306\":3,\"553\":1}}],[\"set2\",{\"1\":{\"1617\":4}}],[\"set1\",{\"1\":{\"1617\":6}}],[\"setvisible\",{\"1\":{\"1591\":2}}],[\"setvalue\",{\"1\":{\"1082\":1,\"1084\":1,\"1546\":1,\"1638\":1}}],[\"setvalueserializer\",{\"1\":{\"583\":1}}],[\"setfoo\",{\"1\":{\"1526\":1}}],[\"setformat\",{\"1\":{\"1053\":1}}],[\"set结构进行了优化\",{\"1\":{\"1423\":1}}],[\"set从用户空间复制到内核空间\",{\"1\":{\"1423\":1}}],[\"setdaemon\",{\"1\":{\"1375\":1}}],[\"setdefaultcloseoperation\",{\"1\":{\"1591\":2}}],[\"setdefaultprofiles\",{\"1\":{\"1139\":1}}],[\"setdescription\",{\"1\":{\"1003\":1,\"1005\":1,\"1006\":1,\"1008\":1,\"1011\":1}}],[\"setdestroyannotationtype\",{\"1\":{\"966\":1}}],[\"setdestorymethodname\",{\"1\":{\"933\":1}}],[\"set用来存储不允许重复的集合\",{\"1\":{\"1355\":1}}],[\"setheader\",{\"1\":{\"1201\":1}}],[\"sethashvalueserializer\",{\"1\":{\"583\":1}}],[\"sethashkeyserializer\",{\"1\":{\"583\":1}}],[\"setloadonstartup\",{\"1\":{\"1658\":1}}],[\"setlocale\",{\"1\":{\"1053\":1}}],[\"setlazyinit\",{\"1\":{\"1027\":1}}],[\"setpointcut\",{\"1\":{\"1654\":1}}],[\"setparent\",{\"1\":{\"1116\":1}}],[\"setparentmessagesource\",{\"1\":{\"1055\":2,\"1167\":2}}],[\"setpathmatcher\",{\"1\":{\"1043\":2}}],[\"setpropertyvalue\",{\"1\":{\"1030\":4}}],[\"setpropertyvalues\",{\"1\":{\"927\":1,\"1093\":1}}],[\"setprimary\",{\"1\":{\"1027\":1}}],[\"setmessagesource\",{\"1\":{\"1005\":1}}],[\"setrequiredproperties\",{\"1\":{\"1162\":1}}],[\"setrequiredfields\",{\"1\":{\"1072\":1}}],[\"setresources\",{\"1\":{\"1032\":1}}],[\"setresourceloader\",{\"1\":{\"1005\":1,\"1045\":1}}],[\"setrange\",{\"1\":{\"570\":2}}],[\"setentryat\",{\"1\":{\"1553\":1}}],[\"setenvironment\",{\"1\":{\"1005\":2,\"1148\":1,\"1149\":1}}],[\"setembeddedvalueresolver\",{\"1\":{\"1005\":1}}],[\"setex\",{\"1\":{\"570\":3,\"1289\":1}}],[\"setsuperclass\",{\"1\":{\"1654\":1}}],[\"setscore\",{\"1\":{\"1603\":1,\"1605\":1,\"1613\":2}}],[\"setscope\",{\"1\":{\"997\":2,\"1027\":1,\"1647\":3}}],[\"setstate\",{\"1\":{\"1490\":1}}],[\"setstudents\",{\"1\":{\"1184\":1}}],[\"setserializationid\",{\"1\":{\"1163\":1,\"1651\":1}}],[\"setsource\",{\"1\":{\"967\":1,\"1019\":1,\"1647\":1}}],[\"setorder\",{\"1\":{\"966\":1}}],[\"setobjectfactory\",{\"1\":{\"918\":1}}],[\"set<beandefinition>\",{\"1\":{\"1647\":3}}],[\"set<beandefinitionholder>\",{\"1\":{\"1647\":2}}],[\"set<map\",{\"1\":{\"1618\":1}}],[\"set<t>>\",{\"1\":{\"1617\":2,\"1618\":1}}],[\"set<t>\",{\"1\":{\"1617\":2}}],[\"set<selectionkey>\",{\"1\":{\"1574\":2}}],[\"set<string>>\",{\"1\":{\"1618\":2}}],[\"set<string>\",{\"1\":{\"963\":3,\"1616\":1,\"1617\":2,\"1647\":1,\"1648\":3}}],[\"set<applicationevent>\",{\"1\":{\"1116\":1,\"1170\":1}}],[\"set<collector\",{\"1\":{\"1618\":4}}],[\"set<convertiblepair>\",{\"1\":{\"1089\":1,\"1091\":1,\"1639\":1}}],[\"set<characteristics>\",{\"1\":{\"1616\":4,\"1617\":3}}],[\"set<class<\",{\"1\":{\"965\":1,\"967\":1}}],[\"setcallbackfilter\",{\"1\":{\"1654\":1}}],[\"setcallbacks\",{\"1\":{\"1654\":1}}],[\"setcustomeditors\",{\"1\":{\"1638\":1}}],[\"setcurrentinjectionpoint\",{\"1\":{\"963\":2,\"1648\":2}}],[\"setclassroom\",{\"1\":{\"1184\":1}}],[\"setchanged\",{\"1\":{\"1108\":3}}],[\"setcontextinitializers\",{\"1\":{\"1658\":1}}],[\"setcontainingclass\",{\"1\":{\"1648\":1}}],[\"setconverters\",{\"1\":{\"1639\":1}}],[\"setconversionservice\",{\"1\":{\"1093\":1,\"1171\":1}}],[\"setconfiglocations\",{\"1\":{\"1005\":1}}],[\"setconnectionfactory\",{\"1\":{\"583\":1}}],[\"setignoreinvalidfields\",{\"1\":{\"1072\":1}}],[\"setignoreunknownfields\",{\"1\":{\"1072\":1}}],[\"setinterfaces\",{\"1\":{\"1654\":1}}],[\"setinstancesupplier\",{\"1\":{\"1027\":1}}],[\"setinitannotationtype\",{\"1\":{\"966\":1}}],[\"setinitmethodname\",{\"1\":{\"931\":2}}],[\"setid\",{\"1\":{\"917\":1,\"921\":1,\"929\":1,\"961\":6,\"985\":4,\"989\":1,\"1002\":1,\"1031\":1,\"1032\":1,\"1116\":2,\"1181\":1,\"1182\":1,\"1184\":2}}],[\"setbeanexpressionresolver\",{\"1\":{\"1164\":1}}],[\"setbeanname\",{\"1\":{\"985\":1,\"1005\":2}}],[\"setbeanclassloader\",{\"1\":{\"1005\":2,\"1164\":1}}],[\"setbeanclass\",{\"1\":{\"927\":1,\"1632\":1,\"1647\":1}}],[\"setbeanfactory\",{\"1\":{\"918\":1,\"957\":1,\"1005\":2}}],[\"setbit\",{\"1\":{\"578\":6}}],[\"setuser\",{\"1\":{\"953\":2}}],[\"setusers\",{\"1\":{\"918\":1}}],[\"setup\",{\"1\":{\"479\":1,\"519\":2}}],[\"setadvice\",{\"1\":{\"1654\":1}}],[\"setaddress\",{\"1\":{\"917\":1}}],[\"setaccessible\",{\"1\":{\"1351\":1}}],[\"setactiveprofiles\",{\"1\":{\"1139\":1,\"1147\":1}}],[\"setallowcircularreferences\",{\"1\":{\"1184\":2}}],[\"setasyncsupported\",{\"1\":{\"1658\":1}}],[\"setasvalue\",{\"1\":{\"1082\":2}}],[\"setastext\",{\"1\":{\"1082\":3,\"1084\":1,\"1638\":1}}],[\"setautogrownestedpaths\",{\"1\":{\"1072\":1}}],[\"setautowiredannotationtypes\",{\"1\":{\"967\":1}}],[\"setautowiredannotationtype\",{\"1\":{\"967\":2}}],[\"setattribute\",{\"1\":{\"1019\":1}}],[\"setapplicationstartup\",{\"1\":{\"1005\":1}}],[\"setapplicationeventpublisher\",{\"1\":{\"1005\":1,\"1115\":1,\"1120\":1}}],[\"setapplicationcontext\",{\"1\":{\"957\":1,\"1005\":1,\"1120\":1,\"1148\":1}}],[\"setage\",{\"1\":{\"909\":2,\"1526\":1,\"1600\":1,\"1613\":1}}],[\"setnext\",{\"1\":{\"1553\":1}}],[\"setnumber\",{\"1\":{\"1003\":1,\"1005\":1}}],[\"setname\",{\"1\":{\"909\":2,\"917\":1,\"921\":1,\"929\":1,\"985\":2,\"1002\":1,\"1019\":1,\"1031\":1,\"1032\":1,\"1065\":1,\"1181\":1,\"1182\":1,\"1184\":4,\"1600\":1,\"1603\":1,\"1605\":1,\"1613\":2,\"1638\":1,\"1639\":1}}],[\"setnx失败后\",{\"1\":{\"1288\":1}}],[\"setnx获取锁失败时\",{\"1\":{\"1288\":1}}],[\"setnx和expire并不是原子性的\",{\"1\":{\"1288\":1}}],[\"setnx\",{\"1\":{\"570\":3,\"1288\":3}}],[\"settarget\",{\"1\":{\"1654\":1}}],[\"settaskexecutor\",{\"1\":{\"1123\":2}}],[\"settempclassloader\",{\"1\":{\"1164\":1,\"1165\":1,\"1171\":1}}],[\"setter\",{\"1\":{\"953\":1,\"1613\":1}}],[\"setter方法注入\",{\"1\":{\"958\":1}}],[\"setter方法注入依赖\",{\"1\":{\"953\":1}}],[\"setter方法\",{\"1\":{\"951\":1,\"1075\":1}}],[\"setter方法方式来进行存储信息\",{\"1\":{\"937\":1}}],[\"setter注入用于可选依赖\",{\"1\":{\"970\":1}}],[\"setter注入实现方法\",{\"1\":{\"953\":1}}],[\"setter注入也有缺点\",{\"1\":{\"912\":1}}],[\"setter注入应该主要仅用于我们的可选性的注入\",{\"1\":{\"912\":1}}],[\"setter注入\",{\"0\":{\"953\":1},\"1\":{\"906\":1,\"969\":1}}],[\"settings\",{\"1\":{\"305\":2,\"306\":1}}],[\"setkeyserializer\",{\"1\":{\"583\":1}}],[\"set排序\",{\"1\":{\"574\":1}}],[\"set就是一种简化的hash\",{\"1\":{\"573\":1}}],[\"setz的并集\",{\"1\":{\"572\":1}}],[\"setz\",{\"1\":{\"572\":4}}],[\"setz=>\",{\"1\":{\"572\":1}}],[\"sety的交集\",{\"1\":{\"572\":1}}],[\"sety\",{\"1\":{\"572\":13}}],[\"sety=>\",{\"1\":{\"572\":1}}],[\"setx的交集\",{\"1\":{\"572\":1}}],[\"setx\",{\"1\":{\"572\":12}}],[\"setx=>\",{\"1\":{\"572\":1}}],[\"set值为k6\",{\"1\":{\"571\":1}}],[\"set里面\",{\"1\":{\"468\":1}}],[\"set\",{\"0\":{\"27\":1,\"572\":1,\"1355\":1,\"1475\":1,\"1556\":1},\"1\":{\"323\":1,\"329\":1,\"330\":6,\"346\":1,\"354\":1,\"355\":1,\"361\":1,\"368\":1,\"371\":2,\"400\":2,\"404\":4,\"405\":1,\"414\":2,\"416\":1,\"419\":2,\"420\":1,\"421\":4,\"422\":6,\"428\":5,\"431\":4,\"435\":1,\"447\":11,\"462\":1,\"467\":1,\"468\":2,\"472\":2,\"474\":4,\"476\":3,\"478\":1,\"479\":1,\"518\":2,\"519\":2,\"520\":3,\"523\":4,\"526\":2,\"528\":1,\"532\":1,\"535\":1,\"536\":1,\"544\":1,\"567\":1,\"569\":5,\"570\":3,\"572\":1,\"579\":5,\"580\":4,\"581\":2,\"582\":2,\"583\":1,\"611\":3,\"630\":1,\"928\":1,\"960\":1,\"964\":1,\"995\":1,\"997\":1,\"1055\":1,\"1162\":2,\"1164\":1,\"1167\":1,\"1175\":1,\"1201\":1,\"1215\":1,\"1262\":3,\"1280\":2,\"1423\":2,\"1498\":1,\"1528\":1,\"1538\":2,\"1539\":1,\"1569\":3,\"1603\":1,\"1609\":2,\"1615\":2,\"1616\":1,\"1617\":26,\"1618\":2,\"1620\":7,\"1621\":2,\"1623\":3,\"1647\":2,\"1655\":2}}],[\"深度大于0说明有中间操作\",{\"1\":{\"1623\":1}}],[\"深度加1\",{\"1\":{\"1622\":1}}],[\"深拷贝\",{\"1\":{\"1344\":1}}],[\"深拷贝和浅拷贝的区别\",{\"0\":{\"15\":1,\"1344\":1}}],[\"深入理解\",{\"1\":{\"1992\":1}}],[\"深入理解git\",{\"1\":{\"1966\":1}}],[\"深入理解java8\",{\"1\":{\"1966\":1}}],[\"深入理解java线程\",{\"0\":{\"1477\":1}}],[\"深入理解jvm\",{\"0\":{\"1696\":1},\"1\":{\"1966\":1}}],[\"深入理解netty\",{\"0\":{\"647\":1},\"1\":{\"1966\":1}}],[\"深入浅出分布式事务的实现原理\",{\"1\":{\"1307\":1}}],[\"深入浅出spring事务的实现原理\",{\"1\":{\"1238\":1}}],[\"深圳\",{\"1\":{\"4\":1,\"917\":1}}],[\"封装是把一个对象的属性私有化\",{\"1\":{\"1340\":1}}],[\"封装到request\",{\"1\":{\"306\":1}}],[\"封装\",{\"0\":{\"11\":1,\"1340\":1},\"1\":{\"1340\":1}}],[\"o和多线程\",{\"1\":{\"1969\":1}}],[\"o和锁等待\",{\"1\":{\"388\":1}}],[\"o模型的差异\",{\"1\":{\"1688\":1}}],[\"o模型和应用层协议可以自由组合\",{\"1\":{\"1687\":1}}],[\"o模型\",{\"1\":{\"1687\":1}}],[\"our\",{\"1\":{\"1655\":2}}],[\"out表示这个阶段生成的元素类型\",{\"1\":{\"1621\":1}}],[\"out>>\",{\"1\":{\"1623\":2}}],[\"out>\",{\"1\":{\"1617\":1,\"1621\":6,\"1622\":9,\"1623\":7}}],[\"outter\",{\"1\":{\"1020\":1}}],[\"outer\",{\"1\":{\"997\":2,\"1647\":2}}],[\"out\",{\"1\":{\"431\":1,\"580\":1,\"582\":3,\"583\":1,\"909\":1,\"917\":5,\"918\":4,\"919\":2,\"921\":3,\"929\":2,\"930\":7,\"931\":3,\"933\":7,\"934\":2,\"936\":1,\"940\":1,\"941\":2,\"943\":4,\"944\":1,\"953\":3,\"954\":1,\"955\":3,\"957\":2,\"961\":11,\"962\":4,\"963\":1,\"973\":4,\"977\":1,\"978\":3,\"985\":13,\"989\":2,\"994\":2,\"995\":2,\"997\":3,\"1000\":3,\"1001\":4,\"1005\":8,\"1006\":4,\"1007\":3,\"1009\":1,\"1011\":5,\"1012\":3,\"1013\":1,\"1019\":1,\"1022\":2,\"1029\":1,\"1030\":1,\"1031\":2,\"1032\":2,\"1040\":1,\"1041\":1,\"1043\":1,\"1044\":3,\"1045\":2,\"1053\":5,\"1056\":1,\"1063\":1,\"1064\":2,\"1065\":2,\"1072\":3,\"1075\":2,\"1082\":1,\"1084\":1,\"1099\":3,\"1100\":3,\"1103\":2,\"1108\":1,\"1112\":1,\"1113\":1,\"1116\":1,\"1119\":1,\"1123\":1,\"1134\":1,\"1138\":1,\"1139\":1,\"1146\":1,\"1148\":4,\"1149\":2,\"1156\":2,\"1157\":2,\"1174\":2,\"1175\":2,\"1181\":5,\"1182\":2,\"1184\":2,\"1365\":2,\"1387\":1,\"1404\":8,\"1451\":1,\"1485\":1,\"1487\":1,\"1551\":2,\"1573\":3,\"1574\":3,\"1575\":3,\"1587\":1,\"1588\":1,\"1591\":6,\"1592\":3,\"1593\":7,\"1594\":1,\"1595\":13,\"1597\":2,\"1598\":12,\"1599\":7,\"1600\":5,\"1601\":2,\"1602\":1,\"1603\":4,\"1604\":4,\"1605\":5,\"1606\":2,\"1607\":9,\"1608\":2,\"1609\":10,\"1610\":17,\"1611\":2,\"1612\":6,\"1614\":1,\"1615\":2,\"1616\":8,\"1617\":19,\"1619\":12,\"1620\":3,\"1622\":7,\"1623\":6,\"1632\":1,\"1633\":1,\"1634\":1,\"1635\":1,\"1638\":1,\"1640\":1,\"1646\":2,\"1654\":4,\"1689\":1}}],[\"output\",{\"1\":{\"429\":1,\"1598\":6,\"1623\":3}}],[\"o表示的就是代理对象\",{\"1\":{\"1654\":1}}],[\"omnivorous\",{\"1\":{\"1623\":1}}],[\"o通道等等\",{\"1\":{\"1619\":1}}],[\"occurred\",{\"1\":{\"1620\":1}}],[\"occurs\",{\"1\":{\"1620\":1}}],[\"occur\",{\"1\":{\"1615\":1,\"1619\":1,\"1620\":3}}],[\"o2\",{\"1\":{\"1603\":1,\"1614\":1}}],[\"o1\",{\"1\":{\"1603\":1,\"1614\":1}}],[\"o选项只输出匹配的部分\",{\"1\":{\"1464\":1}}],[\"oauth2\",{\"1\":{\"1202\":3,\"1204\":1}}],[\"odd\",{\"1\":{\"1139\":4,\"1620\":1}}],[\"overloads\",{\"1\":{\"1620\":2}}],[\"overly\",{\"1\":{\"1620\":1}}],[\"overhead\",{\"1\":{\"1620\":1}}],[\"over\",{\"1\":{\"1620\":2,\"1647\":1}}],[\"overflow\",{\"1\":{\"1614\":1,\"1986\":1}}],[\"overridden\",{\"1\":{\"997\":1,\"1620\":3,\"1655\":2}}],[\"overriding\",{\"1\":{\"996\":4,\"1594\":2,\"1620\":1}}],[\"overrides\",{\"1\":{\"1132\":1,\"1647\":2}}],[\"overridefrom\",{\"1\":{\"997\":1,\"1647\":1}}],[\"override\",{\"0\":{\"9\":1,\"1338\":1},\"1\":{\"917\":2,\"928\":1,\"930\":2,\"931\":1,\"933\":1,\"934\":1,\"946\":1,\"953\":1,\"957\":2,\"963\":1,\"964\":3,\"985\":4,\"989\":6,\"997\":1,\"1000\":1,\"1001\":2,\"1002\":2,\"1003\":2,\"1005\":5,\"1006\":2,\"1007\":1,\"1008\":1,\"1009\":1,\"1011\":1,\"1012\":1,\"1013\":1,\"1019\":1,\"1020\":1,\"1023\":1,\"1030\":3,\"1032\":1,\"1043\":7,\"1045\":1,\"1064\":2,\"1065\":1,\"1082\":1,\"1084\":3,\"1091\":3,\"1108\":3,\"1112\":1,\"1113\":1,\"1114\":1,\"1115\":1,\"1116\":1,\"1119\":3,\"1120\":1,\"1123\":1,\"1138\":2,\"1139\":2,\"1148\":2,\"1149\":1,\"1163\":1,\"1174\":3,\"1175\":1,\"1184\":2,\"1573\":1,\"1575\":10,\"1591\":2,\"1592\":1,\"1595\":5,\"1597\":1,\"1607\":3,\"1609\":2,\"1613\":1,\"1616\":5,\"1617\":17,\"1618\":3,\"1619\":2,\"1620\":7,\"1621\":4,\"1622\":6,\"1623\":8,\"1638\":1,\"1639\":3,\"1644\":2,\"1647\":2,\"1648\":2,\"1651\":1,\"1654\":6,\"1657\":3,\"1689\":1}}],[\"overview\",{\"1\":{\"917\":2,\"918\":1,\"930\":1,\"994\":1,\"1022\":1,\"1084\":1,\"1091\":1,\"1146\":1}}],[\"oop局限性\",{\"0\":{\"742\":1}}],[\"oop\",{\"0\":{\"739\":1},\"1\":{\"900\":1,\"1479\":2}}],[\"oom\",{\"1\":{\"318\":1}}],[\"obtainfromsupplier\",{\"1\":{\"1650\":1}}],[\"obtainfreshbeanfactory方法\",{\"1\":{\"1163\":1}}],[\"obtainfreshbeanfactory\",{\"1\":{\"922\":1,\"1647\":1,\"1651\":1}}],[\"obtained\",{\"1\":{\"1623\":1}}],[\"obvious\",{\"1\":{\"1620\":1}}],[\"obj\",{\"1\":{\"1479\":2,\"1528\":1,\"1599\":2}}],[\"objecyprovider\",{\"1\":{\"943\":1}}],[\"object类中方法并不会对函数式接口的方法的数量变化\",{\"1\":{\"1594\":1}}],[\"objectmonitor\",{\"1\":{\"1483\":1}}],[\"objectvalue\",{\"1\":{\"1365\":2}}],[\"objectarrayclass\",{\"1\":{\"1099\":1}}],[\"object方法\",{\"1\":{\"1075\":1}}],[\"objectname\",{\"1\":{\"1070\":1}}],[\"objecterror\",{\"1\":{\"1062\":1,\"1063\":2,\"1064\":2,\"1068\":1}}],[\"objectp\",{\"1\":{\"1053\":1}}],[\"objectprovider延迟注入\",{\"1\":{\"962\":1}}],[\"objectprovider\",{\"1\":{\"944\":5,\"962\":1,\"963\":1,\"1181\":8,\"1648\":1}}],[\"objectprovider<set<user>>\",{\"1\":{\"962\":1}}],[\"objectprovider<string>\",{\"1\":{\"940\":1,\"943\":2}}],[\"objectprovider<user>\",{\"1\":{\"943\":1,\"944\":2,\"962\":1,\"1181\":2}}],[\"objectutils\",{\"1\":{\"928\":1,\"1000\":1,\"1001\":1,\"1002\":2,\"1003\":1,\"1006\":1,\"1008\":1,\"1011\":1,\"1019\":1,\"1648\":1,\"1650\":1,\"1658\":1}}],[\"objectfactory和objectprovider\",{\"1\":{\"1181\":1}}],[\"objectfactorylazylookupdemo\",{\"1\":{\"1181\":4}}],[\"objectfactory延迟注入\",{\"1\":{\"962\":1}}],[\"objectfactory与beanfactory均提供依赖查找的能力\",{\"1\":{\"948\":1}}],[\"objectfactory与beanfactory的区别\",{\"0\":{\"948\":1}}],[\"objectfactory<\",{\"1\":{\"989\":1}}],[\"objectfactory<applicationcontext>\",{\"1\":{\"918\":4}}],[\"objectfactory<user>\",{\"1\":{\"917\":2,\"944\":1,\"1181\":2}}],[\"objectfactorycreatingfactorybean\",{\"1\":{\"917\":1}}],[\"objectfactory\",{\"1\":{\"917\":4,\"918\":5,\"943\":1,\"944\":2,\"963\":1,\"989\":2,\"1181\":4,\"1648\":1}}],[\"objects\",{\"1\":{\"896\":1,\"975\":1,\"1594\":6,\"1595\":1,\"1597\":2,\"1598\":9,\"1599\":11,\"1601\":2,\"1609\":1,\"1614\":2,\"1617\":1,\"1618\":2,\"1619\":1,\"1621\":3,\"1622\":2,\"1623\":6,\"1654\":3}}],[\"object>>\",{\"1\":{\"989\":1}}],[\"object>\",{\"1\":{\"583\":3,\"963\":6,\"989\":5,\"1023\":1,\"1031\":1,\"1072\":2,\"1084\":1,\"1091\":1,\"1139\":1,\"1156\":1,\"1365\":1,\"1368\":1,\"1648\":5}}],[\"object\",{\"1\":{\"309\":1,\"645\":4,\"900\":1,\"909\":1,\"930\":1,\"940\":2,\"959\":1,\"963\":13,\"964\":3,\"985\":2,\"989\":9,\"998\":1,\"1000\":4,\"1001\":1,\"1002\":2,\"1003\":3,\"1005\":2,\"1006\":6,\"1007\":1,\"1008\":5,\"1011\":1,\"1019\":2,\"1023\":1,\"1053\":4,\"1061\":3,\"1064\":1,\"1075\":1,\"1082\":2,\"1086\":1,\"1089\":1,\"1091\":2,\"1098\":1,\"1099\":2,\"1108\":2,\"1113\":1,\"1118\":1,\"1119\":1,\"1139\":1,\"1227\":1,\"1365\":2,\"1368\":3,\"1475\":2,\"1483\":1,\"1484\":1,\"1502\":3,\"1506\":2,\"1542\":1,\"1546\":1,\"1548\":1,\"1557\":4,\"1594\":8,\"1597\":2,\"1598\":4,\"1599\":22,\"1601\":4,\"1603\":2,\"1608\":2,\"1615\":1,\"1616\":1,\"1618\":1,\"1619\":5,\"1620\":6,\"1621\":1,\"1623\":1,\"1639\":2,\"1644\":1,\"1647\":18,\"1648\":15,\"1650\":1,\"1654\":15,\"1655\":5,\"1657\":3,\"1689\":1}}],[\"observable\",{\"1\":{\"1108\":7}}],[\"observerdemo\",{\"1\":{\"1108\":1}}],[\"observer\",{\"1\":{\"624\":1,\"1108\":2}}],[\"obejctproviderdemo\",{\"1\":{\"940\":2,\"943\":2}}],[\"old收集器\",{\"0\":{\"1727\":1,\"1728\":1}}],[\"old1\",{\"1\":{\"1591\":2}}],[\"oldthr\",{\"1\":{\"1550\":4}}],[\"oldtab\",{\"1\":{\"1550\":7}}],[\"oldtable\",{\"1\":{\"1550\":2}}],[\"oldcap放到bucket里\",{\"1\":{\"1550\":1}}],[\"oldcapacity\",{\"1\":{\"1550\":2}}],[\"oldcap\",{\"1\":{\"1506\":4,\"1550\":10}}],[\"oldvalue\",{\"1\":{\"1549\":3,\"1553\":4}}],[\"oldval\",{\"1\":{\"1288\":4,\"1554\":5}}],[\"old\",{\"1\":{\"570\":1,\"1434\":1,\"1441\":2,\"1591\":2}}],[\"otherwise\",{\"1\":{\"1215\":1,\"1595\":2,\"1599\":2,\"1617\":1,\"1619\":2,\"1620\":3,\"1621\":2}}],[\"other\",{\"1\":{\"558\":1,\"922\":1,\"1594\":6,\"1597\":2,\"1599\":32,\"1614\":4,\"1615\":2,\"1617\":2,\"1620\":2,\"1647\":3}}],[\"others这两个分区\",{\"1\":{\"425\":1}}],[\"others\",{\"1\":{\"424\":1,\"603\":1}}],[\"o成本\",{\"1\":{\"557\":1}}],[\"o成本+cpu成本\",{\"1\":{\"548\":1}}],[\"o等\",{\"1\":{\"533\":1}}],[\"ok\",{\"1\":{\"428\":1,\"431\":1,\"567\":4,\"569\":4,\"570\":4,\"571\":2,\"573\":1,\"577\":1,\"579\":6,\"580\":4,\"581\":6,\"611\":1}}],[\"o的消耗时间\",{\"1\":{\"388\":1}}],[\"o操作的处理\",{\"1\":{\"1224\":1}}],[\"o操作\",{\"1\":{\"1224\":1}}],[\"o操作完成\",{\"1\":{\"388\":1}}],[\"o操作上消耗时间\",{\"1\":{\"381\":1}}],[\"o\",{\"1\":{\"385\":1,\"388\":1,\"589\":2,\"893\":2,\"1108\":1,\"1163\":1,\"1368\":2,\"1464\":2,\"1546\":1,\"1557\":4,\"1576\":4,\"1619\":1,\"1647\":1,\"1651\":1,\"1654\":1,\"1689\":5}}],[\"oracle\",{\"1\":{\"1627\":1,\"1974\":1}}],[\"oracle数据库的默认隔离级别是\",{\"1\":{\"433\":1}}],[\"ored\",{\"1\":{\"1599\":2,\"1620\":1}}],[\"origin\",{\"1\":{\"1620\":13}}],[\"originating\",{\"1\":{\"1615\":1}}],[\"originalbeanname\",{\"1\":{\"1647\":1}}],[\"original\",{\"1\":{\"519\":3,\"997\":1,\"1620\":1,\"1647\":1}}],[\"oriented\",{\"1\":{\"900\":1}}],[\"org\",{\"1\":{\"645\":4,\"917\":7,\"918\":6,\"930\":13,\"943\":2,\"945\":6,\"952\":1,\"953\":10,\"954\":10,\"957\":1,\"961\":3,\"962\":1,\"972\":1,\"973\":1,\"989\":3,\"994\":1,\"1003\":1,\"1005\":1,\"1012\":1,\"1022\":1,\"1028\":6,\"1030\":7,\"1031\":5,\"1032\":8,\"1038\":5,\"1039\":6,\"1040\":6,\"1041\":6,\"1042\":4,\"1043\":1,\"1050\":1,\"1051\":1,\"1054\":2,\"1058\":1,\"1059\":4,\"1060\":1,\"1061\":2,\"1062\":2,\"1063\":1,\"1065\":12,\"1067\":1,\"1068\":5,\"1070\":5,\"1073\":1,\"1074\":1,\"1078\":1,\"1083\":7,\"1084\":7,\"1086\":4,\"1087\":3,\"1089\":3,\"1090\":2,\"1091\":13,\"1092\":1,\"1093\":12,\"1096\":4,\"1100\":1,\"1101\":2,\"1102\":1,\"1103\":1,\"1111\":4,\"1112\":2,\"1113\":1,\"1118\":1,\"1119\":3,\"1121\":1,\"1122\":3,\"1123\":3,\"1124\":3,\"1125\":5,\"1128\":4,\"1134\":11,\"1138\":1,\"1139\":10,\"1143\":1,\"1146\":11,\"1147\":2,\"1150\":1,\"1151\":3,\"1152\":5,\"1153\":6,\"1154\":6,\"1155\":5,\"1159\":3,\"1162\":1,\"1169\":5,\"1174\":2,\"1182\":1,\"1620\":1,\"1632\":5,\"1637\":2,\"1648\":2,\"1652\":2,\"1655\":1,\"1657\":5,\"1658\":2}}],[\"ordinary\",{\"1\":{\"442\":1}}],[\"order来指定order的值\",{\"1\":{\"1641\":1}}],[\"order注解或实现ordered接口来执行值进行比较\",{\"1\":{\"1641\":1}}],[\"order注解控制\",{\"1\":{\"1113\":1}}],[\"ordercomparator是spring所提供的一种比较器\",{\"1\":{\"1641\":1}}],[\"ordercomparator\",{\"0\":{\"1641\":1}}],[\"ordereventproducer\",{\"1\":{\"1521\":2}}],[\"ordereventhandler\",{\"1\":{\"1521\":5}}],[\"orderevent\",{\"1\":{\"1521\":1}}],[\"orderedpostprocessors\",{\"1\":{\"1166\":4}}],[\"orderedpostprocessornames\",{\"1\":{\"1166\":4}}],[\"ordered\",{\"1\":{\"519\":1,\"966\":1,\"967\":1,\"1166\":3,\"1609\":2,\"1617\":1,\"1620\":8,\"1623\":5}}],[\"orderthread\",{\"1\":{\"1404\":1}}],[\"orderthread2\",{\"1\":{\"1404\":1}}],[\"ordering\",{\"1\":{\"519\":2,\"1620\":1}}],[\"order表示根据同时进入prepare和commit来判断是否可以并行的策略\",{\"1\":{\"465\":1}}],[\"order\",{\"0\":{\"353\":1,\"419\":1},\"1\":{\"330\":2,\"347\":1,\"348\":4,\"353\":1,\"354\":1,\"361\":3,\"378\":8,\"411\":3,\"414\":1,\"416\":2,\"419\":1,\"420\":1,\"421\":3,\"429\":2,\"431\":2,\"519\":9,\"520\":2,\"522\":4,\"544\":5,\"547\":10,\"548\":2,\"549\":12,\"551\":3,\"553\":17,\"554\":14,\"555\":26,\"558\":6,\"559\":2,\"967\":1,\"975\":1,\"997\":2,\"1113\":2,\"1432\":1,\"1595\":4,\"1611\":1,\"1614\":4,\"1615\":2,\"1617\":2,\"1618\":1,\"1620\":8,\"1622\":1,\"1623\":5,\"1647\":2,\"1663\":1}}],[\"or\",{\"0\":{\"392\":1},\"1\":{\"366\":2,\"430\":1,\"519\":1,\"569\":1,\"572\":1,\"578\":1,\"580\":1,\"952\":1,\"996\":1,\"1065\":1,\"1093\":1,\"1480\":1,\"1594\":10,\"1595\":2,\"1599\":8,\"1600\":2,\"1610\":1,\"1615\":12,\"1618\":1,\"1619\":14,\"1620\":27,\"1621\":10,\"1622\":2,\"1623\":8,\"1647\":1,\"1658\":1}}],[\"opportunity\",{\"1\":{\"1647\":1}}],[\"opflags\",{\"1\":{\"1622\":7}}],[\"opforxxx然后才能进行对应的操作\",{\"1\":{\"584\":1}}],[\"opwrapsink是map等方法中实现的\",{\"1\":{\"1623\":1}}],[\"opwrapsink\",{\"1\":{\"1621\":1,\"1622\":1,\"1623\":2}}],[\"opisstateful\",{\"1\":{\"1621\":1,\"1622\":2}}],[\"op\",{\"1\":{\"1574\":5,\"1618\":6,\"1622\":1}}],[\"opsforhah\",{\"1\":{\"583\":1}}],[\"opsforlist\",{\"1\":{\"583\":1}}],[\"opsforvalue\",{\"1\":{\"583\":3}}],[\"ops\",{\"1\":{\"431\":2,\"1621\":2}}],[\"optionally\",{\"1\":{\"1615\":2,\"1623\":1}}],[\"optionalint\",{\"1\":{\"1610\":2}}],[\"optional\",{\"1\":{\"963\":2,\"1349\":1,\"1615\":1,\"1616\":1,\"1648\":1}}],[\"optional<user>\",{\"1\":{\"963\":1,\"967\":1}}],[\"optional等\",{\"1\":{\"959\":1}}],[\"options\",{\"1\":{\"429\":1}}],[\"optimize\",{\"1\":{\"1615\":1,\"1620\":1,\"1623\":1}}],[\"optimizer\",{\"1\":{\"354\":3,\"404\":1,\"405\":1,\"421\":4,\"519\":6,\"520\":4,\"544\":2,\"557\":1}}],[\"optimization\",{\"1\":{\"519\":2,\"520\":4,\"1621\":1}}],[\"optimization这个部分的chosen=true\",{\"1\":{\"421\":1}}],[\"optimizing\",{\"1\":{\"431\":1}}],[\"opts\",{\"1\":{\"429\":1}}],[\"opevaluateparallel\",{\"1\":{\"1623\":1}}],[\"operands\",{\"1\":{\"1601\":9}}],[\"operating\",{\"1\":{\"1620\":1}}],[\"operation<\",{\"1\":{\"1608\":1}}],[\"operations\",{\"1\":{\"1608\":2,\"1615\":2,\"1616\":1,\"1619\":8,\"1620\":3,\"1621\":7,\"1623\":5}}],[\"operation\",{\"1\":{\"571\":1,\"1597\":14,\"1601\":2,\"1608\":3,\"1613\":1,\"1615\":7,\"1617\":1,\"1618\":3,\"1619\":4,\"1620\":1,\"1621\":7,\"1622\":6,\"1623\":12}}],[\"operates\",{\"1\":{\"1618\":2}}],[\"operated\",{\"1\":{\"1610\":1,\"1619\":1,\"1622\":1}}],[\"operate\",{\"1\":{\"1597\":2,\"1620\":1}}],[\"operator\",{\"1\":{\"366\":1,\"368\":3,\"1601\":1}}],[\"operration\",{\"1\":{\"578\":1}}],[\"openjdk\",{\"1\":{\"1620\":2}}],[\"opening\",{\"1\":{\"431\":1}}],[\"open\",{\"1\":{\"425\":1,\"534\":1,\"1533\":1,\"1534\":1,\"1574\":4,\"1575\":2,\"1587\":2,\"1588\":2}}],[\"onto\",{\"1\":{\"1622\":2}}],[\"ondata\",{\"1\":{\"1521\":1}}],[\"onclose\",{\"1\":{\"1175\":2,\"1619\":7}}],[\"once的demo\",{\"1\":{\"1333\":1}}],[\"once的实现机制\",{\"1\":{\"1333\":1}}],[\"once\",{\"1\":{\"1162\":1,\"1333\":4,\"1615\":2,\"1619\":1}}],[\"onapplicationevent1\",{\"1\":{\"1113\":1}}],[\"onapplicationevent\",{\"1\":{\"1112\":2,\"1113\":4,\"1114\":1,\"1116\":1,\"1119\":1,\"1123\":1,\"1175\":1}}],[\"onrefresh方法\",{\"1\":{\"1169\":1}}],[\"onrefresh\",{\"1\":{\"922\":1,\"1169\":6,\"1172\":2,\"1647\":1,\"1651\":1}}],[\"ongl表达式\",{\"1\":{\"646\":1}}],[\"onevent\",{\"1\":{\"1123\":1}}],[\"one让自己变成主机\",{\"1\":{\"611\":1}}],[\"one\",{\"1\":{\"611\":1,\"963\":1,\"1594\":4,\"1598\":2,\"1599\":2,\"1608\":2,\"1615\":3,\"1618\":3,\"1619\":1,\"1620\":4,\"1623\":2,\"1647\":1,\"1648\":1}}],[\"onlyifabsent\",{\"1\":{\"1549\":2,\"1553\":2,\"1554\":3}}],[\"only模式时\",{\"1\":{\"1297\":1}}],[\"only\",{\"1\":{\"429\":1,\"519\":1,\"591\":1,\"611\":2,\"1055\":1,\"1167\":1,\"1587\":1,\"1615\":2,\"1617\":2,\"1619\":5,\"1620\":4,\"1621\":4,\"1623\":1,\"1648\":1,\"1655\":2}}],[\"on\",{\"0\":{\"1527\":1},\"1\":{\"361\":2,\"362\":2,\"363\":2,\"378\":1,\"394\":2,\"401\":1,\"402\":1,\"403\":1,\"407\":2,\"409\":1,\"431\":1,\"478\":1,\"509\":1,\"519\":2,\"522\":1,\"524\":1,\"525\":1,\"555\":2,\"588\":1,\"964\":1,\"997\":2,\"1007\":1,\"1053\":6,\"1175\":1,\"1204\":1,\"1480\":1,\"1527\":11,\"1591\":2,\"1594\":3,\"1597\":1,\"1599\":2,\"1608\":2,\"1613\":1,\"1615\":6,\"1618\":3,\"1619\":5,\"1620\":8,\"1621\":1,\"1623\":4,\"1647\":6,\"1648\":3,\"1689\":1}}],[\"ofref<>\",{\"1\":{\"1623\":1}}],[\"ofdouble\",{\"1\":{\"1620\":1}}],[\"ofprimitive<integer\",{\"1\":{\"1620\":1}}],[\"ofprimitive<t\",{\"1\":{\"1620\":2}}],[\"ofint>\",{\"1\":{\"1620\":1}}],[\"ofint\",{\"1\":{\"1620\":11}}],[\"often\",{\"1\":{\"1615\":1,\"1619\":1,\"1620\":2,\"1621\":1,\"1647\":1}}],[\"offers\",{\"1\":{\"1623\":1}}],[\"offer\",{\"1\":{\"1476\":1,\"1500\":1,\"1501\":5,\"1618\":1,\"1619\":1,\"1689\":6}}],[\"offer方法则会返回false\",{\"1\":{\"1476\":1}}],[\"offer方法和add方法的区别在于\",{\"1\":{\"1476\":1}}],[\"off\",{\"1\":{\"428\":1,\"431\":1,\"1620\":3,\"1647\":1}}],[\"offset和auto\",{\"1\":{\"491\":1}}],[\"offset开始的值\",{\"1\":{\"570\":1}}],[\"offset开始\",{\"1\":{\"491\":1}}],[\"offset\",{\"1\":{\"308\":1,\"570\":1,\"578\":3,\"609\":3,\"1479\":3}}],[\"of\",{\"1\":{\"305\":3,\"354\":4,\"355\":1,\"421\":2,\"429\":3,\"467\":1,\"468\":4,\"479\":1,\"520\":2,\"558\":1,\"571\":1,\"580\":2,\"905\":1,\"909\":1,\"922\":1,\"963\":2,\"964\":2,\"975\":2,\"996\":1,\"997\":2,\"1008\":1,\"1023\":1,\"1043\":1,\"1044\":1,\"1055\":1,\"1075\":2,\"1099\":2,\"1139\":1,\"1162\":1,\"1166\":1,\"1167\":1,\"1175\":1,\"1451\":1,\"1480\":3,\"1594\":16,\"1595\":4,\"1597\":2,\"1598\":39,\"1599\":26,\"1600\":3,\"1601\":19,\"1607\":6,\"1608\":10,\"1609\":6,\"1613\":3,\"1614\":1,\"1615\":26,\"1616\":5,\"1617\":6,\"1618\":14,\"1619\":15,\"1620\":74,\"1621\":17,\"1622\":4,\"1623\":27,\"1647\":16,\"1648\":2,\"1655\":2,\"1689\":1}}],[\"osgi\",{\"1\":{\"899\":1}}],[\"os\",{\"0\":{\"274\":1},\"1\":{\"1337\":1,\"1479\":1,\"1584\":1}}],[\"owneristhread\",{\"1\":{\"1483\":1}}],[\"owner\",{\"1\":{\"1\":1,\"1483\":2}}],[\"和容器\",{\"1\":{\"1683\":1}}],[\"和一个结果类型\",{\"1\":{\"1623\":1}}],[\"和cancellationrequested方法都会链接起来\",{\"1\":{\"1623\":1}}],[\"和condition来实现一组线程的阻塞唤醒的\",{\"1\":{\"1496\":1}}],[\"和count\",{\"1\":{\"399\":1,\"526\":1}}],[\"和spliterator\",{\"1\":{\"1619\":1,\"1620\":1}}],[\"和select函数一样\",{\"1\":{\"1570\":1}}],[\"和select机制差不多的\",{\"1\":{\"1423\":1}}],[\"和setdefaultprofiles\",{\"1\":{\"1147\":1}}],[\"和产生的结果r1和r2\",{\"1\":{\"1615\":1}}],[\"和transfer\",{\"1\":{\"1554\":1}}],[\"和associativity\",{\"1\":{\"1615\":1}}],[\"和allof用于支持多个completablefuture并行执行\",{\"1\":{\"1518\":1}}],[\"和acceptsprofiles\",{\"1\":{\"1147\":1}}],[\"和公平的锁获取方式\",{\"1\":{\"1498\":1}}],[\"和对象无关\",{\"1\":{\"1485\":1}}],[\"和对其填充\",{\"1\":{\"1484\":1}}],[\"和dubbo\",{\"1\":{\"1990\":1}}],[\"和dest地址所存的值是否相等\",{\"1\":{\"1479\":1}}],[\"和dl\",{\"1\":{\"924\":1}}],[\"和用户线程\",{\"1\":{\"1375\":1}}],[\"和jdb\",{\"1\":{\"1337\":1}}],[\"和工具\",{\"1\":{\"1337\":1}}],[\"和关系型数据库中的事务相比\",{\"1\":{\"1297\":1}}],[\"和getdefaultprofiles\",{\"1\":{\"1147\":1}}],[\"和kqueue\",{\"1\":{\"603\":1}}],[\"和rpoplpush功能相同\",{\"1\":{\"571\":1}}],[\"和roll\",{\"1\":{\"542\":1}}],[\"和order\",{\"1\":{\"554\":1}}],[\"和连接查询相关的数据量\",{\"1\":{\"553\":1}}],[\"和已创建的最大事务id\",{\"1\":{\"542\":1}}],[\"和for\",{\"1\":{\"537\":1}}],[\"和悲观锁\",{\"1\":{\"533\":1}}],[\"和从库b的gtid集合是一样的\",{\"1\":{\"468\":1}}],[\"和b\",{\"1\":{\"467\":1}}],[\"和binlog\",{\"1\":{\"323\":1}}],[\"和修改后各个字段的值\",{\"1\":{\"462\":1}}],[\"和主库a的\",{\"1\":{\"459\":1}}],[\"和主键id\",{\"1\":{\"355\":1}}],[\"和更新类事务的提交语句都会被阻塞\",{\"1\":{\"437\":1}}],[\"和串行化\",{\"1\":{\"433\":1}}],[\"和min\",{\"1\":{\"422\":1}}],[\"和普通令牌有什么区别\",{\"0\":{\"220\":1,\"1203\":1}}],[\"和exsits优化\",{\"1\":{\"525\":1}}],[\"和execute\",{\"0\":{\"79\":1,\"1408\":1}}],[\"和eventloop什么关系\",{\"0\":{\"208\":1,\"1225\":1}}],[\"和$\",{\"0\":{\"194\":1,\"1210\":1}}],[\"和\",{\"0\":{\"8\":1,\"12\":1,\"595\":1,\"1243\":1,\"1337\":1,\"1341\":1},\"1\":{\"304\":1,\"306\":2,\"330\":2,\"378\":1,\"424\":2,\"447\":1,\"465\":1,\"485\":1,\"532\":1,\"570\":1,\"574\":1,\"578\":1,\"596\":1,\"1256\":1,\"1479\":1,\"1483\":1,\"1565\":1,\"1584\":1,\"1595\":1,\"1974\":2,\"1979\":2}}],[\"jfr\",{\"1\":{\"1647\":1}}],[\"jframe\",{\"1\":{\"1591\":18}}],[\"j++\",{\"1\":{\"1620\":2}}],[\"jls\",{\"1\":{\"1594\":3}}],[\"jlong\",{\"1\":{\"1479\":1}}],[\"jbutton\",{\"1\":{\"1591\":10}}],[\"jboolean\",{\"1\":{\"1479\":1}}],[\"juc下的队列大部分采用reentrantlock锁的方式保证线程安全\",{\"1\":{\"1519\":1}}],[\"juc包中的大多数同步器实现都是围绕着共同的基础行为\",{\"1\":{\"1490\":1}}],[\"just\",{\"1\":{\"429\":1,\"1554\":1,\"1623\":1,\"1689\":1}}],[\"jobject\",{\"1\":{\"1479\":2}}],[\"joined\",{\"1\":{\"1616\":1}}],[\"joining还有一个重载的方法\",{\"1\":{\"1618\":1}}],[\"joining方法与之前的方法不同的是\",{\"1\":{\"1618\":1}}],[\"joining\",{\"1\":{\"1609\":1,\"1616\":4,\"1618\":2}}],[\"join实现\",{\"1\":{\"1530\":1}}],[\"join的性能\",{\"1\":{\"1510\":1}}],[\"join框架时\",{\"1\":{\"1510\":1}}],[\"join框架的核心是forkjoinpool类\",{\"1\":{\"1510\":1}}],[\"join框架\",{\"1\":{\"1510\":1}}],[\"join框架来完成\",{\"1\":{\"1412\":1}}],[\"joinpointidentification\",{\"1\":{\"1655\":3}}],[\"joinpoint执行动作接口\",{\"0\":{\"788\":1}}],[\"joinpoint条件接口\",{\"0\":{\"784\":1}}],[\"join关联查询优化\",{\"0\":{\"523\":1}}],[\"join比较过程中\",{\"1\":{\"407\":1}}],[\"join和block\",{\"1\":{\"403\":1}}],[\"join算法是相同的\",{\"1\":{\"403\":1}}],[\"join算法\",{\"1\":{\"402\":1,\"403\":4,\"524\":1}}],[\"join过程用上了这个索引\",{\"1\":{\"401\":1}}],[\"join可以让mysql使用固定的连接方式执行查询\",{\"1\":{\"401\":1}}],[\"join语句的优化\",{\"0\":{\"400\":1},\"1\":{\"364\":1}}],[\"join\",{\"0\":{\"401\":1,\"402\":1,\"403\":1,\"408\":1},\"1\":{\"301\":1,\"321\":2,\"330\":1,\"384\":2,\"394\":2,\"401\":2,\"402\":3,\"403\":2,\"405\":1,\"407\":3,\"409\":1,\"418\":1,\"429\":1,\"509\":1,\"514\":3,\"519\":6,\"520\":4,\"522\":1,\"523\":2,\"524\":2,\"525\":3,\"553\":2,\"554\":5,\"555\":6,\"989\":1,\"1412\":1,\"1477\":1,\"1575\":2}}],[\"jnihandles\",{\"1\":{\"1479\":1}}],[\"jnienv\",{\"1\":{\"1479\":1}}],[\"jndi配置属性源\",{\"1\":{\"1154\":1}}],[\"jndipropertysource\",{\"1\":{\"1154\":1}}],[\"jndi\",{\"0\":{\"1627\":1},\"1\":{\"273\":1,\"908\":1,\"939\":1,\"1154\":1,\"1627\":1}}],[\"jconsole\",{\"0\":{\"1774\":1},\"1\":{\"1454\":1}}],[\"jca\",{\"1\":{\"895\":1}}],[\"jvisualvm\",{\"0\":{\"1773\":1},\"1\":{\"1454\":1}}],[\"jvm教程\",{\"1\":{\"1992\":1}}],[\"jvm类加载器\",{\"0\":{\"1691\":1}}],[\"jvm类加载机制\",{\"0\":{\"1663\":1}}],[\"jvm如何调用java方法\",{\"0\":{\"1677\":1}}],[\"jvm常量池\",{\"0\":{\"1673\":1}}],[\"jvm调优工具\",{\"0\":{\"1672\":1}}],[\"jvm调优主要是通过定制jvm运行参数来提高java应用程序的运行速度\",{\"1\":{\"1452\":1}}],[\"jvm对象创建与内存分配机制深度剖析\",{\"0\":{\"1665\":1}}],[\"jvm对synchronized做了如下优化\",{\"1\":{\"1489\":1}}],[\"jvm整体架构及内存模型\",{\"1\":{\"1664\":1}}],[\"jvm内存模型\",{\"0\":{\"1664\":1}}],[\"jvm会默认当前类产生了严重的问题\",{\"1\":{\"1485\":1}}],[\"jvm会认为不该偏向\",{\"1\":{\"1485\":1}}],[\"jvm就认为该class的使用场景存在多线程竞争\",{\"1\":{\"1485\":1}}],[\"jvm就认为该class的偏向锁有问题\",{\"1\":{\"1485\":1}}],[\"jvm就需要等到安全点时\",{\"1\":{\"1485\":1}}],[\"jvm就可以退出\",{\"1\":{\"1375\":1}}],[\"jvm默认延时加载偏向锁\",{\"1\":{\"1485\":1}}],[\"jvm启动时会进行一系列的复杂活动\",{\"1\":{\"1485\":1}}],[\"jvm利用storeload\",{\"1\":{\"1473\":1}}],[\"jvm层面\",{\"1\":{\"1470\":1}}],[\"jvm参数设置\",{\"1\":{\"1664\":1}}],[\"jvm参数大致可以分为三类\",{\"1\":{\"1453\":1}}],[\"jvm参数有哪些\",{\"0\":{\"122\":1,\"1453\":1}}],[\"jvmti中注册的回调\",{\"1\":{\"1438\":1}}],[\"jvm要实例化一个对象\",{\"1\":{\"1436\":1}}],[\"jvm首先需要到方法区去找对象的类型信息\",{\"1\":{\"1436\":1}}],[\"jvm为了提升性能和减少内存开销\",{\"1\":{\"1342\":1}}],[\"jvm针对于不同的操作系统有不同的实现\",{\"1\":{\"1337\":1}}],[\"jvm有哪些垃圾回收器\",{\"0\":{\"110\":1,\"1441\":1}}],[\"jvm有哪些垃圾回收算法\",{\"0\":{\"108\":1,\"1439\":1}}],[\"jvm\",{\"0\":{\"8\":1,\"113\":1,\"1337\":1,\"1444\":1,\"1662\":1},\"1\":{\"1337\":1,\"1992\":2}}],[\"jps\",{\"1\":{\"1454\":1}}],[\"jpa\",{\"1\":{\"891\":1,\"1110\":1}}],[\"jwt令牌的本质就是一个加密的字符串\",{\"1\":{\"1203\":1}}],[\"jjjj\",{\"1\":{\"1072\":3}}],[\"jjjjjj\",{\"1\":{\"1002\":1}}],[\"jycinterceptor\",{\"1\":{\"1657\":1}}],[\"jyc这个包下面所有的类\",{\"1\":{\"1645\":1}}],[\"jycfactorybean\",{\"1\":{\"1644\":1}}],[\"jyc\",{\"1\":{\"917\":2,\"918\":1,\"927\":2,\"929\":1,\"930\":4,\"953\":2,\"954\":2,\"994\":1,\"1003\":1,\"1005\":1,\"1012\":1,\"1022\":1,\"1030\":2,\"1040\":1,\"1041\":1,\"1043\":1,\"1065\":1,\"1084\":2,\"1091\":2,\"1134\":1,\"1138\":1,\"1146\":1,\"1156\":1,\"1174\":2,\"1635\":1,\"1645\":2,\"1646\":1}}],[\"jycoder\",{\"1\":{\"5\":1,\"1019\":1,\"1030\":4,\"1546\":2}}],[\"j2ee1\",{\"1\":{\"897\":1}}],[\"j2ee\",{\"1\":{\"897\":2,\"910\":1,\"912\":1}}],[\"jmm的内存可见性保证\",{\"1\":{\"1474\":1}}],[\"jmm是围绕原子性\",{\"1\":{\"1473\":1}}],[\"jmm描述的是一种抽象的概念\",{\"1\":{\"1473\":1}}],[\"jmm规范了java虚拟机与计算机内存是如何协同工作的\",{\"1\":{\"1473\":1}}],[\"jmm即java多线程通信模型\",{\"1\":{\"1470\":1}}],[\"jmm实现原理\",{\"0\":{\"1470\":1}}],[\"jmap\",{\"1\":{\"1454\":1}}],[\"jmx撤销托管\",{\"1\":{\"1175\":1}}],[\"jmx\",{\"0\":{\"1626\":1},\"1\":{\"891\":1,\"895\":1,\"1138\":1,\"1626\":1}}],[\"jms\",{\"0\":{\"1625\":1},\"1\":{\"273\":1,\"895\":1}}],[\"jint\",{\"1\":{\"1479\":11}}],[\"jinfo\",{\"1\":{\"1454\":1}}],[\"jit编译器在执行动态编译时\",{\"1\":{\"1393\":1}}],[\"ji\",{\"1\":{\"1031\":1}}],[\"jib\",{\"0\":{\"882\":1}}],[\"jiyongchao\",{\"1\":{\"472\":1,\"479\":1,\"929\":1,\"1019\":2,\"1022\":1,\"1030\":1,\"1605\":1}}],[\"jedis是redis官方推荐使用的java连接redis的客户端\",{\"1\":{\"582\":1}}],[\"jedis\",{\"0\":{\"582\":1},\"1\":{\"582\":12,\"583\":2}}],[\"j\",{\"1\":{\"577\":2,\"1550\":7,\"1553\":3,\"1620\":1}}],[\"jstl\",{\"1\":{\"1978\":1}}],[\"jstack\",{\"1\":{\"1454\":1}}],[\"jstat\",{\"1\":{\"1454\":1}}],[\"jsf\",{\"1\":{\"1110\":1}}],[\"jsr\",{\"1\":{\"965\":2,\"1065\":2,\"1092\":2}}],[\"jsr330factory\",{\"1\":{\"963\":1,\"1648\":1}}],[\"jsr规范的适配与实现\",{\"1\":{\"891\":1}}],[\"js与nginx也是单线程\",{\"1\":{\"601\":1}}],[\"jsonobject\",{\"1\":{\"582\":6}}],[\"json\",{\"1\":{\"553\":1,\"555\":1,\"583\":2}}],[\"json=on\",{\"1\":{\"519\":1,\"520\":1}}],[\"json文档\",{\"1\":{\"304\":1}}],[\"json对象由字段组成\",{\"1\":{\"304\":1}}],[\"jsp\",{\"1\":{\"273\":1,\"1978\":2}}],[\"jta\",{\"1\":{\"273\":1}}],[\"jts\",{\"1\":{\"273\":1}}],[\"jdbc频繁的创建和关闭数据库连接\",{\"1\":{\"645\":1}}],[\"jdbc的缺点\",{\"1\":{\"645\":1}}],[\"jdbc\",{\"1\":{\"273\":1,\"893\":1,\"1974\":2}}],[\"jdk的体系结构\",{\"1\":{\"1664\":1}}],[\"jdk的设计者匠心独具\",{\"1\":{\"1593\":1}}],[\"jdk会根据这个枚举项类判断他们之间的关系\",{\"1\":{\"1617\":1}}],[\"jdk从1\",{\"1\":{\"1614\":1}}],[\"jdk还为我们提供了一些其他的函数式接口\",{\"1\":{\"1600\":1}}],[\"jdk中举出的拼接字符串的例子\",{\"1\":{\"1609\":1}}],[\"jdk中\",{\"1\":{\"1530\":1}}],[\"jdk中很多类都具备不变性\",{\"1\":{\"1526\":1}}],[\"jdk中提供的大多数的同步器如lock\",{\"1\":{\"1490\":1}}],[\"jdk乐观锁的实现\",{\"1\":{\"1498\":1}}],[\"jdk6默认开启\",{\"1\":{\"1485\":1}}],[\"jdk默认开启指针压缩后位4字节\",{\"1\":{\"1484\":1}}],[\"jdk7之前\",{\"1\":{\"1475\":1}}],[\"jdk7开始支持的\",{\"1\":{\"1421\":1}}],[\"jdk9接口中增加了私有方法和私有静态方法\",{\"1\":{\"1345\":1}}],[\"jdkdynamicaopproxy\",{\"1\":{\"899\":1}}],[\"jdk动态代理\",{\"0\":{\"757\":1},\"1\":{\"1654\":1}}],[\"jdk8使我们看到了java这门古老的语言的全新面貌\",{\"1\":{\"1607\":1}}],[\"jdk8或者说java8是目前企业开发中最常用的jdk版本\",{\"1\":{\"1591\":1}}],[\"jdk8虽然不会出现死循环的情况\",{\"1\":{\"1551\":1}}],[\"jdk8默认开启\",{\"1\":{\"1487\":1}}],[\"jdk8以后\",{\"1\":{\"1475\":1}}],[\"jdk8将永久代\",{\"1\":{\"1457\":1}}],[\"jdk8接口中增加了默认方法和静态方法\",{\"1\":{\"1345\":1}}],[\"jdk8\",{\"0\":{\"126\":1,\"1457\":1},\"1\":{\"1475\":1}}],[\"jdk8有哪些新特性\",{\"0\":{\"20\":1,\"1349\":1}}],[\"jdk1\",{\"0\":{\"31\":1,\"1359\":1,\"1553\":1,\"1554\":1},\"1\":{\"1369\":2,\"1401\":1,\"1421\":2,\"1480\":1,\"1545\":1,\"1546\":1,\"1548\":5,\"1549\":1,\"1550\":4,\"1551\":1,\"1554\":2,\"1572\":1,\"1648\":1}}],[\"jdk\",{\"0\":{\"8\":1,\"104\":1,\"799\":1,\"1337\":1,\"1435\":1,\"1797\":1},\"1\":{\"1337\":1,\"1373\":1,\"1608\":2,\"1614\":1,\"1620\":1}}],[\"jams\",{\"1\":{\"1621\":1}}],[\"jackson\",{\"1\":{\"583\":1}}],[\"jar等\",{\"1\":{\"1663\":1}}],[\"jar\",{\"1\":{\"1037\":1,\"1663\":1,\"1664\":2,\"1980\":2}}],[\"jar包中同级目录的配置文件加载优先级\",{\"0\":{\"232\":1,\"1312\":1}}],[\"jar可以直接运行\",{\"0\":{\"187\":1,\"1246\":1},\"1\":{\"1246\":1}}],[\"java学习路线\",{\"0\":{\"1967\":1}}],[\"java高级编程\",{\"1\":{\"1966\":1}}],[\"java面向对象编程\",{\"1\":{\"1966\":1}}],[\"java面试题精选\",{\"0\":{\"6\":1}}],[\"java编程开发入门\",{\"1\":{\"1966\":1}}],[\"java编译器提供一个默认的构造函数\",{\"1\":{\"1346\":1}}],[\"java与线程\",{\"0\":{\"1811\":1}}],[\"java监控简介\",{\"0\":{\"1680\":1}}],[\"javaserver\",{\"1\":{\"1683\":1}}],[\"javase\",{\"1\":{\"1627\":1}}],[\"javascript是一门非常典型的函数式语言\",{\"1\":{\"1593\":1}}],[\"java是纯面向对象的语言\",{\"1\":{\"1595\":1}}],[\"java引入了一个全新的概念\",{\"1\":{\"1593\":1}}],[\"java并不是全部支持\",{\"1\":{\"1586\":1}}],[\"java并发包里提供了线程池等工具类\",{\"1\":{\"1533\":1}}],[\"java并发包提供了读写锁reentrantreadwritelock\",{\"1\":{\"1498\":1}}],[\"java并发编程的艺术\",{\"1\":{\"1966\":1}}],[\"java并发编程之美\",{\"1\":{\"1966\":1}}],[\"java并发编程\",{\"0\":{\"1469\":1}}],[\"java并发\",{\"0\":{\"43\":1,\"1372\":1}}],[\"java开始支持非阻塞io\",{\"1\":{\"1572\":1}}],[\"java反射机制的主要用于实现以下功能\",{\"1\":{\"1559\":1}}],[\"java反射有哪些作用\",{\"0\":{\"21\":1,\"1350\":1}}],[\"java7中引入了fork\",{\"1\":{\"1510\":1}}],[\"java7之后不能控制是否开启自旋功能\",{\"1\":{\"1485\":1}}],[\"java1\",{\"1\":{\"1483\":1}}],[\"java中有以下几种类加载器\",{\"1\":{\"1663\":1}}],[\"java中使用会存在性能缺陷\",{\"1\":{\"1533\":1}}],[\"java中monitor的工作流程\",{\"1\":{\"1483\":1}}],[\"java中对静态变量的自增\",{\"1\":{\"1482\":1}}],[\"java中创建线程的方式\",{\"1\":{\"1477\":1}}],[\"java中\",{\"1\":{\"1473\":1}}],[\"java中的零拷贝\",{\"0\":{\"1586\":1}}],[\"java中的io模型\",{\"0\":{\"1572\":1}}],[\"java中的string在实现replace\",{\"1\":{\"1527\":1}}],[\"java中的clh队列是原clh队列的一个变种\",{\"1\":{\"1491\":1}}],[\"java中的cas操作\",{\"1\":{\"1479\":1}}],[\"java中的每个对象都可以把它当作一个同步锁来使用\",{\"1\":{\"1482\":1}}],[\"java中的appclassloader\",{\"1\":{\"1432\":1}}],[\"java中的指令重排序有两次\",{\"1\":{\"1405\":1}}],[\"java中的线程分为两种\",{\"1\":{\"1375\":1}}],[\"java内存屏障\",{\"0\":{\"1767\":1}}],[\"java内存模型\",{\"0\":{\"1808\":1}}],[\"java内存模型定义了以下八种操作来完成\",{\"1\":{\"1473\":1}}],[\"java内存模型和计算机硬件内存架构是一个交叉关系\",{\"1\":{\"1473\":1}}],[\"java内存模型与硬件内存架构之间存在差异\",{\"1\":{\"1473\":1}}],[\"java内存模型是通过在变量修改后将新值同步回主内存\",{\"1\":{\"1471\":1}}],[\"java内存映射工具\",{\"1\":{\"1454\":1}}],[\"java层面线程共有六种状态\",{\"1\":{\"1477\":1}}],[\"java层面\",{\"1\":{\"1470\":1}}],[\"java配置信息工具\",{\"1\":{\"1454\":1}}],[\"java堆栈跟踪工具\",{\"1\":{\"1454\":1}}],[\"java堆中不存在该类的任何实例对象\",{\"1\":{\"1443\":1}}],[\"java堆分为新生代和老年代\",{\"1\":{\"1434\":1}}],[\"java所有的线程都是停止执行的\",{\"1\":{\"1440\":1}}],[\"java线程调度\",{\"0\":{\"1813\":1}}],[\"java线程进入终止状态的前提是线程进入runnable状态\",{\"1\":{\"1524\":1}}],[\"java线程间通信主要有两种\",{\"1\":{\"1477\":1}}],[\"java线程池实现原理及其在美团业务中的实践\",{\"1\":{\"1413\":1}}],[\"java线程锁机制是怎样的\",{\"0\":{\"68\":1,\"1397\":1}}],[\"java的函数式编程并不是完美无暇的\",{\"1\":{\"1607\":1}}],[\"java的编程向着函数式风格迈进\",{\"1\":{\"1591\":1}}],[\"java的线程是内核级别的线程\",{\"1\":{\"1477\":1}}],[\"java的类加载器\",{\"1\":{\"1432\":1}}],[\"java的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程\",{\"1\":{\"1397\":1}}],[\"java的锁就是在对象的markword中记录一个锁状态\",{\"1\":{\"1397\":1}}],[\"java的反射机制主要用于实现以下功能\",{\"1\":{\"1350\":1}}],[\"java方法\",{\"1\":{\"1346\":1}}],[\"java构造函数\",{\"1\":{\"1346\":1}}],[\"java命令和其他的一些基础构件\",{\"1\":{\"1337\":1}}],[\"javac\",{\"1\":{\"1337\":1}}],[\"java程序从源代码到运行一般经历下面3个步骤\",{\"1\":{\"1337\":1}}],[\"java语言中可以直接使用线程池来实现worker\",{\"1\":{\"1534\":1}}],[\"java语言提供的唯一并发语言就是管程\",{\"1\":{\"1483\":1}}],[\"java语言\",{\"0\":{\"1336\":1}}],[\"java语言特性\",{\"1\":{\"891\":1}}],[\"java当中对零拷贝进行了封装\",{\"1\":{\"1330\":1,\"1331\":1}}],[\"java当中也有开源的词法结构分析工具\",{\"1\":{\"513\":1}}],[\"javadoc\",{\"1\":{\"1133\":1}}],[\"java技术规范\",{\"1\":{\"1109\":1}}],[\"java事件\",{\"0\":{\"1108\":1}}],[\"java泛型擦写是发生在编译时\",{\"0\":{\"1105\":1}}],[\"java泛型反射api\",{\"1\":{\"1099\":1}}],[\"java泛型基础\",{\"0\":{\"1098\":1}}],[\"java类加载器是有亲子层级结构的\",{\"1\":{\"1663\":1}}],[\"java类加载的全过程是怎么样的\",{\"0\":{\"102\":1,\"1433\":1}}],[\"java类库中大多数基本数值类如integer\",{\"1\":{\"1391\":1}}],[\"java类库\",{\"1\":{\"1337\":1}}],[\"java类api\",{\"1\":{\"1099\":1}}],[\"java文本格式化还有一些高级特性\",{\"1\":{\"1053\":1}}],[\"java文本格式化\",{\"0\":{\"1053\":1}}],[\"java文件\",{\"1\":{\"1043\":1}}],[\"java国际化标准实现\",{\"0\":{\"1052\":1}}],[\"javafilepathmatcher\",{\"1\":{\"1043\":2}}],[\"java标准事件监听器java\",{\"1\":{\"1112\":1}}],[\"java标准事件\",{\"1\":{\"1111\":1}}],[\"java标准资源定位\",{\"1\":{\"1037\":1}}],[\"java标准资源管理扩展的步骤\",{\"0\":{\"1049\":1}}],[\"java标准资源管理\",{\"0\":{\"1037\":1}}],[\"java标准资源管理强大\",{\"1\":{\"1036\":1}}],[\"java标准版\",{\"1\":{\"897\":1}}],[\"java8为我们了提供了很多的函数式接口\",{\"1\":{\"1598\":1}}],[\"java8可谓java语言历史上变化最大的一个版本\",{\"1\":{\"1591\":1}}],[\"java8\",{\"1\":{\"1029\":1}}],[\"java注册beandefintiion解析与注册\",{\"1\":{\"1027\":1}}],[\"java注解的方式\",{\"0\":{\"1027\":1}}],[\"java注解方式的核心部分\",{\"1\":{\"954\":1}}],[\"java注解\",{\"1\":{\"931\":1,\"932\":1,\"933\":1,\"986\":1,\"987\":1,\"988\":1,\"1023\":1,\"1024\":1}}],[\"java注解和java\",{\"1\":{\"930\":3}}],[\"java注解配置元信息\",{\"1\":{\"929\":1,\"951\":1,\"953\":1,\"954\":1}}],[\"java通用注解原理\",{\"0\":{\"966\":1}}],[\"java系统属性\",{\"1\":{\"945\":1}}],[\"javabeansdemo\",{\"1\":{\"1075\":1}}],[\"javabeans操作属性\",{\"0\":{\"1075\":1}}],[\"javabeans\",{\"1\":{\"939\":1,\"1075\":1,\"1109\":1}}],[\"javabean属性通常是一个自文档的说明\",{\"1\":{\"912\":1}}],[\"javabean属性能够获取更好的ide支持\",{\"1\":{\"912\":1}}],[\"javaxinjectproviderclass\",{\"1\":{\"963\":1,\"1648\":1}}],[\"javax\",{\"1\":{\"939\":2,\"965\":2,\"966\":6,\"1109\":2,\"1110\":4,\"1591\":2}}],[\"java9\",{\"1\":{\"900\":1}}],[\"java企业版\",{\"1\":{\"897\":1}}],[\"java邮件客户端\",{\"1\":{\"895\":1}}],[\"java管理扩展\",{\"1\":{\"895\":1}}],[\"java连接架构\",{\"1\":{\"895\":1}}],[\"java消息服务\",{\"1\":{\"895\":1}}],[\"java设计模式\",{\"1\":{\"300\":1}}],[\"java设计模式是每一个java程序员都应该掌握的进阶知识\",{\"1\":{\"300\":1}}],[\"java多线程与设计模式结合\",{\"1\":{\"300\":1}}],[\"java多线程设计模式\",{\"1\":{\"300\":1}}],[\"javamail和jaf\",{\"1\":{\"273\":1}}],[\"java虚拟机规范中定义了java内存模型\",{\"1\":{\"1473\":1}}],[\"java虚拟机中的永久代\",{\"1\":{\"1457\":1}}],[\"java虚拟机内部的引用\",{\"1\":{\"1438\":1}}],[\"java虚拟机\",{\"0\":{\"96\":1,\"1427\":1},\"1\":{\"1337\":1}}],[\"java有哪几种io模型\",{\"0\":{\"91\":1,\"1421\":1}}],[\"java网络通信\",{\"0\":{\"88\":1,\"1418\":1}}],[\"java如何开启线程\",{\"0\":{\"48\":1,\"1377\":1}}],[\"java集合元素实质是对象的引用\",{\"1\":{\"1353\":1}}],[\"java集合\",{\"0\":{\"26\":1}}],[\"java基础\",{\"0\":{\"7\":1}}],[\"java\",{\"0\":{\"92\":1,\"98\":1,\"100\":1,\"273\":1,\"738\":1,\"748\":1,\"1099\":1,\"1422\":1,\"1429\":1,\"1431\":1,\"1587\":1,\"1588\":1,\"1679\":1,\"1969\":1,\"1976\":1},\"1\":{\"3\":1,\"273\":2,\"300\":1,\"306\":6,\"307\":3,\"574\":13,\"584\":1,\"891\":1,\"897\":2,\"899\":1,\"900\":2,\"907\":2,\"908\":6,\"909\":9,\"929\":2,\"930\":1,\"931\":1,\"933\":1,\"939\":3,\"945\":2,\"998\":1,\"1020\":1,\"1025\":1,\"1026\":1,\"1027\":1,\"1037\":5,\"1040\":2,\"1041\":2,\"1043\":5,\"1052\":5,\"1053\":1,\"1060\":4,\"1062\":2,\"1068\":2,\"1073\":4,\"1075\":12,\"1084\":2,\"1085\":3,\"1087\":1,\"1093\":1,\"1099\":14,\"1108\":4,\"1109\":9,\"1110\":2,\"1111\":1,\"1138\":1,\"1152\":1,\"1156\":1,\"1164\":1,\"1337\":1,\"1356\":1,\"1375\":1,\"1422\":1,\"1453\":1,\"1455\":2,\"1477\":1,\"1479\":4,\"1488\":1,\"1498\":1,\"1539\":7,\"1540\":4,\"1560\":5,\"1587\":1,\"1588\":2,\"1591\":6,\"1594\":8,\"1597\":2,\"1598\":2,\"1610\":3,\"1614\":1,\"1617\":5,\"1619\":20,\"1620\":8,\"1626\":1,\"1664\":1,\"1683\":3,\"1965\":1,\"1966\":1,\"1968\":1,\"1969\":16,\"1970\":2,\"1977\":1,\"1978\":5,\"1982\":3,\"1983\":1,\"1992\":7,\"1993\":2}}],[\"jre是java运行时环境\",{\"1\":{\"1337\":1}}],[\"jredis\",{\"1\":{\"1248\":1}}],[\"jre\",{\"0\":{\"8\":1,\"1337\":1}}],[\"杭州\",{\"1\":{\"4\":1,\"353\":2,\"354\":4,\"355\":2,\"356\":5,\"421\":1}}],[\"北京\",{\"1\":{\"4\":1}}],[\"⭐⭐\",{\"1\":{\"3\":1}}],[\"⭐⭐⭐\",{\"1\":{\"3\":2}}],[\"⭐⭐⭐⭐⭐\",{\"1\":{\"3\":1}}],[\"cn\",{\"1\":{\"1972\":1,\"1975\":1}}],[\"cnf修改配置文件\",{\"1\":{\"428\":1}}],[\"cnf\",{\"1\":{\"428\":1}}],[\"cnf文件\",{\"1\":{\"428\":1}}],[\"certain\",{\"1\":{\"1620\":1}}],[\"cellvalue\",{\"1\":{\"1554\":1}}],[\"cells\",{\"1\":{\"1480\":4}}],[\"cell\",{\"1\":{\"1480\":4}}],[\"c>\",{\"1\":{\"1609\":1,\"1618\":1}}],[\"czxy\",{\"1\":{\"1591\":1}}],[\"cyclicbarrier是通过reentranlock的\",{\"1\":{\"1496\":1}}],[\"cyclicbarrier与countdownlatch的区别\",{\"1\":{\"1496\":1}}],[\"cylicbarrier实现原理\",{\"0\":{\"1497\":1}}],[\"cylicbarrier\",{\"1\":{\"1404\":1}}],[\"cxq\",{\"1\":{\"1483\":1}}],[\"cmpose\",{\"1\":{\"1598\":1}}],[\"cmpxchg这个函数最终返回值是exchange\",{\"1\":{\"1479\":1}}],[\"cmpxchgl的详细执行过程\",{\"1\":{\"1479\":1}}],[\"cmpxchgl\",{\"1\":{\"1479\":4}}],[\"cmpxchg的实现\",{\"1\":{\"1479\":1}}],[\"cmpxchg方法中\",{\"1\":{\"1479\":1}}],[\"cmpxchg\",{\"1\":{\"1479\":7}}],[\"cms详细步骤\",{\"0\":{\"1731\":1}}],[\"cms简介\",{\"0\":{\"1730\":1}}],[\"cms收集器\",{\"0\":{\"1729\":1}}],[\"cms收集器对cpu资源非常敏感\",{\"1\":{\"1448\":1}}],[\"cms在小内存应用上的表现要优于g1\",{\"1\":{\"1449\":1}}],[\"cms处理器无法处理浮动垃圾\",{\"1\":{\"1448\":1}}],[\"cms通过增量标记increment\",{\"1\":{\"1442\":1}}],[\"cms的核心算法就是三色标记\",{\"1\":{\"1442\":1}}],[\"cms\",{\"0\":{\"116\":1,\"117\":1,\"1447\":1,\"1448\":1},\"1\":{\"1441\":1}}],[\"cpp\",{\"1\":{\"1479\":1}}],[\"cpu层面讲解了\",{\"1\":{\"1992\":1}}],[\"cpu拷贝次数\",{\"1\":{\"1585\":2}}],[\"cpu切换次数\",{\"1\":{\"1580\":1,\"1581\":1}}],[\"cpu把内核缓冲区的数据\",{\"1\":{\"1580\":1}}],[\"cpu上下文从用户态转为内核态\",{\"1\":{\"1580\":1}}],[\"cpunum\",{\"1\":{\"1573\":3}}],[\"cpu成功达到100\",{\"1\":{\"1551\":1}}],[\"cpu成本\",{\"1\":{\"545\":1,\"548\":1,\"549\":2}}],[\"cpu缓存是以缓存行为最小数据单位\",{\"1\":{\"1519\":1}}],[\"cpu缓存即高速缓冲存储器\",{\"1\":{\"1474\":1}}],[\"cpu密集型任务也叫计算密集型任务\",{\"1\":{\"1510\":1}}],[\"cpu密集型任务\",{\"1\":{\"1510\":1}}],[\"cpu核数大于消费者线程数量\",{\"1\":{\"1520\":1}}],[\"cpu核数\",{\"1\":{\"1480\":1}}],[\"cpu核心数\",{\"1\":{\"1227\":1}}],[\"cpu核心线程数\",{\"1\":{\"1227\":1}}],[\"cpus\",{\"1\":{\"1480\":1}}],[\"cpu直接从内存中存取数据需要等待一定时间周期\",{\"1\":{\"1474\":1}}],[\"cpu不需要先将数据从某处内存复制到另一个特定区域\",{\"1\":{\"1231\":1}}],[\"cpu操作和内存不足时导致的i\",{\"1\":{\"381\":1}}],[\"cpu计算\",{\"1\":{\"381\":1}}],[\"cpu的工作原理\",{\"0\":{\"289\":1}}],[\"cpu的实模式\",{\"0\":{\"288\":1}}],[\"cpu\",{\"0\":{\"279\":1},\"1\":{\"431\":5,\"1479\":1,\"1582\":2,\"1583\":4,\"1584\":3}}],[\"css和\",{\"1\":{\"1977\":1}}],[\"cset\",{\"0\":{\"1746\":1}}],[\"cs\",{\"1\":{\"1480\":5,\"1517\":10}}],[\"csrf\",{\"1\":{\"1201\":1}}],[\"csdn\",{\"1\":{\"330\":1,\"561\":1,\"1649\":1}}],[\"cglib和jdk的动态代理示例\",{\"1\":{\"1654\":1}}],[\"cglibsubclassinginstantiationstrategy\",{\"1\":{\"1651\":1}}],[\"cglib提升与aop类代理的关系\",{\"0\":{\"832\":1}}],[\"cglib\",{\"0\":{\"800\":1},\"1\":{\"899\":1}}],[\"cglib动态代理\",{\"0\":{\"758\":1},\"1\":{\"1654\":1}}],[\"cdata\",{\"1\":{\"645\":1}}],[\"ctors\",{\"1\":{\"1650\":6}}],[\"ctl\",{\"1\":{\"1476\":3}}],[\"ctrl\",{\"1\":{\"598\":1}}],[\"ctx\",{\"1\":{\"306\":1}}],[\"c语言编写\",{\"1\":{\"564\":1}}],[\"c三个表进行连接\",{\"1\":{\"556\":1}}],[\"c三个线程\",{\"0\":{\"75\":1,\"1404\":1}}],[\"cba这6种连接顺序\",{\"1\":{\"556\":1}}],[\"c是唯一索引\",{\"1\":{\"489\":1}}],[\"c的查询语句继续执行\",{\"1\":{\"481\":1}}],[\"c收到了断开连接的提示\",{\"1\":{\"481\":1}}],[\"c命令没有效果\",{\"1\":{\"481\":1}}],[\"c执行的时候被阻塞了\",{\"1\":{\"481\":1}}],[\"c执行kill\",{\"1\":{\"480\":1}}],[\"c事务提交\",{\"1\":{\"447\":1}}],[\"c也是相同的道理\",{\"1\":{\"447\":1}}],[\"c两条语句\",{\"1\":{\"446\":1}}],[\"c又插入一行\",{\"1\":{\"446\":1}}],[\"c阻塞\",{\"1\":{\"441\":1}}],[\"c需要mdl写锁\",{\"1\":{\"441\":1}}],[\"c会被blocked\",{\"1\":{\"441\":1}}],[\"c会同时查询表t的总行数\",{\"1\":{\"396\":1}}],[\"c里面\",{\"1\":{\"434\":1}}],[\"c5\",{\"1\":{\"378\":1}}],[\"c4字段排序产生了using\",{\"1\":{\"378\":1}}],[\"c4字段失效\",{\"1\":{\"378\":2}}],[\"c4失效\",{\"1\":{\"378\":3}}],[\"c4全字段\",{\"1\":{\"378\":4}}],[\"c4\",{\"1\":{\"378\":1}}],[\"c3p0\",{\"1\":{\"1974\":1}}],[\"c3用于排序\",{\"1\":{\"378\":4}}],[\"c3和c2两个字段索引失效\",{\"1\":{\"378\":1}}],[\"c3三个字段\",{\"1\":{\"378\":7}}],[\"c3字段用于排序了但是没有统计到key\",{\"1\":{\"378\":2}}],[\"c3字段\",{\"1\":{\"378\":1}}],[\"c3\",{\"1\":{\"378\":9}}],[\"c2和c3排序失效产生了using\",{\"1\":{\"378\":1}}],[\"c2和c3用于排序\",{\"1\":{\"378\":1}}],[\"c2用于查找\",{\"1\":{\"378\":3}}],[\"c2两个字段\",{\"1\":{\"378\":1}}],[\"c2\",{\"1\":{\"378\":21,\"1614\":14}}],[\"c122\",{\"1\":{\"1184\":1}}],[\"c1234\",{\"1\":{\"378\":1}}],[\"c1用于查找\",{\"1\":{\"378\":3}}],[\"c1和c2两个字段用于查找\",{\"1\":{\"378\":3}}],[\"c1\",{\"1\":{\"378\":4,\"1614\":14}}],[\"c都用到\",{\"1\":{\"377\":2}}],[\"clh队列是一种基于双向链表数据结构的队列\",{\"1\":{\"1491\":1}}],[\"clz\",{\"1\":{\"1351\":1}}],[\"cleanuptransactioninfo\",{\"1\":{\"1655\":2}}],[\"cleanupafterbeancreationfailure\",{\"1\":{\"1647\":1}}],[\"clean\",{\"1\":{\"1175\":1}}],[\"cleaning\",{\"1\":{\"431\":1}}],[\"clearresourcecaches\",{\"1\":{\"1172\":2}}],[\"clear\",{\"1\":{\"1162\":1,\"1172\":1,\"1175\":1}}],[\"clearchanged\",{\"1\":{\"1108\":1}}],[\"clearbytypecache\",{\"1\":{\"996\":1}}],[\"clients\",{\"1\":{\"1620\":3}}],[\"clients<\",{\"1\":{\"582\":1}}],[\"client\",{\"1\":{\"624\":2}}],[\"client1\",{\"1\":{\"596\":1}}],[\"client5\",{\"1\":{\"596\":1}}],[\"client2\",{\"1\":{\"596\":1}}],[\"cluster提供自动分区\",{\"1\":{\"568\":1}}],[\"clustered\",{\"1\":{\"335\":1,\"558\":1}}],[\"clazz\",{\"1\":{\"1061\":2,\"1064\":2,\"1351\":1,\"1648\":6}}],[\"clause\",{\"1\":{\"519\":7}}],[\"class类文件的结构\",{\"0\":{\"1775\":1}}],[\"class类不会被加载\",{\"1\":{\"1663\":1}}],[\"class文件结构\",{\"0\":{\"1670\":1}}],[\"class对象\",{\"1\":{\"1663\":1}}],[\"class对象不在任何地方被引用\",{\"1\":{\"1443\":1}}],[\"classobjectentry\",{\"1\":{\"1648\":3}}],[\"class解析为beandefinition\",{\"1\":{\"1633\":1}}],[\"classcastexception\",{\"1\":{\"1617\":1}}],[\"classcastexception类型的异常\",{\"1\":{\"1544\":1}}],[\"classification\",{\"1\":{\"1613\":1,\"1618\":2}}],[\"classifier\",{\"1\":{\"1613\":2,\"1618\":8}}],[\"classroom\",{\"1\":{\"1184\":21}}],[\"classreading\",{\"1\":{\"1134\":3}}],[\"classrelativeresourceloader\",{\"1\":{\"1041\":1}}],[\"class的类之后\",{\"1\":{\"1183\":1}}],[\"class的classloader\",{\"1\":{\"957\":1}}],[\"class中的\",{\"1\":{\"1183\":1}}],[\"classmetadatareadingvisitor\",{\"1\":{\"1134\":1}}],[\"classmetadata\",{\"0\":{\"1646\":1},\"1\":{\"1134\":1,\"1646\":3}}],[\"classeditor\",{\"1\":{\"1083\":1}}],[\"classes\",{\"1\":{\"952\":1,\"1056\":1,\"1135\":2,\"1157\":1,\"1608\":2,\"1620\":1,\"1621\":3,\"1645\":2}}],[\"class属性来自于object\",{\"1\":{\"1075\":1}}],[\"classname\",{\"1\":{\"998\":3}}],[\"classnotfoundexception\",{\"1\":{\"965\":1,\"998\":1,\"1432\":3,\"1663\":3}}],[\"classloader的loadclass方法\",{\"1\":{\"1663\":1}}],[\"classloader\",{\"1\":{\"998\":3,\"1005\":7,\"1037\":1,\"1164\":1,\"1171\":1,\"1647\":1}}],[\"classloader类加载\",{\"1\":{\"998\":1}}],[\"class加载阶段\",{\"0\":{\"998\":1}}],[\"class<t>\",{\"1\":{\"973\":1,\"1027\":1,\"1647\":1}}],[\"class<\",{\"1\":{\"930\":1,\"941\":2,\"963\":10,\"964\":2,\"965\":2,\"998\":2,\"1000\":2,\"1001\":1,\"1002\":1,\"1025\":1,\"1027\":2,\"1030\":1,\"1064\":1,\"1084\":2,\"1100\":4,\"1432\":2,\"1638\":1,\"1644\":1,\"1647\":3,\"1648\":6,\"1650\":1,\"1654\":2,\"1655\":2,\"1663\":2}}],[\"classutils\",{\"1\":{\"928\":1,\"963\":1,\"965\":1,\"995\":1,\"998\":1,\"1648\":2}}],[\"classpathscanningcandidatecomponentprovider\",{\"1\":{\"1134\":1}}],[\"classpathbeandefinitionscanner是扫描器\",{\"1\":{\"1635\":1}}],[\"classpathbeandefinitionscanner\",{\"0\":{\"1635\":1},\"1\":{\"1134\":1,\"1635\":2,\"1647\":1,\"1651\":1}}],[\"classpathresource\",{\"1\":{\"997\":1,\"1000\":1,\"1039\":1}}],[\"classpath\",{\"1\":{\"921\":1,\"930\":3,\"953\":5,\"954\":3,\"955\":1,\"961\":3,\"962\":1,\"963\":1,\"994\":1,\"1022\":1,\"1029\":3,\"1030\":1,\"1031\":1,\"1032\":3,\"1039\":1,\"1044\":3,\"1065\":1,\"1084\":1,\"1146\":3,\"1647\":2}}],[\"classpathxmlapplicationcontext\",{\"1\":{\"917\":1,\"918\":1,\"919\":1,\"930\":3,\"1005\":2,\"1065\":1,\"1084\":1,\"1146\":2,\"1637\":1}}],[\"class=\",{\"1\":{\"917\":3,\"918\":1,\"930\":4,\"953\":2,\"954\":2,\"972\":1,\"973\":1,\"986\":1,\"987\":1,\"988\":1,\"989\":1,\"1003\":1,\"1005\":1,\"1012\":1,\"1032\":1,\"1065\":2,\"1084\":2,\"1091\":2,\"1146\":3}}],[\"class\",{\"0\":{\"832\":1},\"1\":{\"362\":4,\"582\":2,\"583\":2,\"645\":50,\"909\":4,\"917\":6,\"918\":3,\"919\":3,\"921\":5,\"927\":4,\"928\":3,\"929\":9,\"930\":10,\"931\":4,\"933\":4,\"934\":2,\"936\":2,\"940\":7,\"941\":4,\"943\":5,\"944\":7,\"946\":10,\"951\":1,\"953\":9,\"954\":3,\"955\":3,\"957\":2,\"961\":9,\"962\":3,\"963\":12,\"965\":3,\"966\":3,\"967\":6,\"973\":11,\"977\":3,\"978\":3,\"985\":8,\"989\":5,\"994\":4,\"995\":5,\"997\":3,\"1000\":5,\"1001\":7,\"1002\":3,\"1003\":2,\"1005\":8,\"1006\":5,\"1007\":1,\"1008\":1,\"1011\":6,\"1019\":6,\"1022\":4,\"1023\":2,\"1025\":1,\"1027\":3,\"1029\":5,\"1030\":5,\"1031\":3,\"1032\":7,\"1040\":1,\"1041\":1,\"1043\":2,\"1044\":2,\"1045\":2,\"1053\":2,\"1055\":1,\"1056\":3,\"1061\":4,\"1063\":1,\"1064\":3,\"1065\":5,\"1072\":2,\"1075\":3,\"1082\":2,\"1083\":1,\"1084\":5,\"1091\":5,\"1099\":13,\"1100\":10,\"1103\":2,\"1108\":3,\"1112\":1,\"1113\":2,\"1114\":1,\"1116\":4,\"1119\":3,\"1120\":2,\"1121\":1,\"1123\":4,\"1134\":4,\"1135\":2,\"1136\":2,\"1137\":1,\"1138\":14,\"1139\":7,\"1146\":2,\"1148\":3,\"1149\":4,\"1156\":3,\"1157\":3,\"1164\":12,\"1166\":6,\"1167\":1,\"1168\":1,\"1170\":1,\"1171\":3,\"1174\":3,\"1175\":1,\"1181\":4,\"1182\":6,\"1184\":7,\"1191\":1,\"1192\":1,\"1193\":2,\"1194\":2,\"1242\":1,\"1365\":1,\"1387\":1,\"1388\":2,\"1404\":3,\"1412\":1,\"1432\":5,\"1479\":1,\"1487\":1,\"1503\":1,\"1521\":1,\"1526\":4,\"1528\":1,\"1535\":2,\"1542\":1,\"1546\":1,\"1551\":1,\"1554\":1,\"1560\":1,\"1575\":3,\"1591\":3,\"1592\":1,\"1593\":6,\"1594\":4,\"1595\":8,\"1597\":2,\"1598\":8,\"1599\":4,\"1600\":4,\"1601\":1,\"1602\":1,\"1603\":3,\"1604\":3,\"1605\":3,\"1606\":2,\"1607\":11,\"1608\":3,\"1609\":11,\"1610\":8,\"1612\":3,\"1613\":3,\"1614\":2,\"1615\":2,\"1616\":1,\"1617\":3,\"1618\":1,\"1619\":2,\"1620\":8,\"1621\":5,\"1622\":1,\"1623\":4,\"1632\":4,\"1633\":2,\"1634\":1,\"1638\":4,\"1639\":5,\"1640\":2,\"1644\":2,\"1645\":4,\"1646\":1,\"1647\":6,\"1648\":7,\"1650\":2,\"1651\":3,\"1652\":4,\"1654\":12,\"1655\":3,\"1657\":1,\"1663\":4}}],[\"class表\",{\"1\":{\"362\":1}}],[\"clone\",{\"1\":{\"1352\":1,\"1647\":1}}],[\"clonebeandefinition\",{\"1\":{\"997\":1,\"1647\":1}}],[\"cloud与docker微服务架构实战\",{\"1\":{\"1966\":1}}],[\"cloud激活熔断注解\",{\"1\":{\"1140\":1}}],[\"cloud激活服务发现客户端注解\",{\"1\":{\"1140\":1}}],[\"cloud应用引导注解\",{\"1\":{\"1140\":1}}],[\"cloud场景下\",{\"1\":{\"1116\":1}}],[\"cloud\",{\"0\":{\"1989\":1},\"1\":{\"900\":2,\"961\":1,\"1989\":2,\"1990\":2}}],[\"cloumn机制\",{\"1\":{\"417\":1}}],[\"closehandler\",{\"1\":{\"1619\":1}}],[\"closefuture\",{\"1\":{\"1226\":2}}],[\"close方法会自动的得到调用\",{\"1\":{\"1619\":1}}],[\"close方法\",{\"1\":{\"1175\":1}}],[\"closebeanfactory\",{\"1\":{\"1163\":1,\"1175\":1,\"1651\":1}}],[\"closed\",{\"1\":{\"1162\":2,\"1175\":2,\"1610\":1,\"1619\":2,\"1622\":2}}],[\"close\",{\"1\":{\"582\":1,\"929\":1,\"931\":1,\"933\":1,\"934\":1,\"936\":1,\"940\":1,\"943\":1,\"944\":1,\"946\":3,\"953\":2,\"955\":1,\"957\":1,\"961\":3,\"962\":1,\"963\":1,\"973\":1,\"977\":1,\"978\":1,\"985\":2,\"989\":1,\"1005\":1,\"1029\":1,\"1031\":1,\"1032\":1,\"1044\":1,\"1045\":1,\"1065\":1,\"1084\":1,\"1112\":1,\"1113\":1,\"1116\":2,\"1119\":1,\"1120\":1,\"1123\":2,\"1134\":1,\"1138\":1,\"1139\":1,\"1146\":1,\"1148\":1,\"1149\":1,\"1156\":1,\"1174\":1,\"1175\":4,\"1177\":1,\"1181\":1,\"1182\":1,\"1184\":1,\"1533\":2,\"1534\":2,\"1574\":7,\"1575\":5,\"1587\":2,\"1588\":2,\"1591\":2,\"1619\":9}}],[\"closing\",{\"1\":{\"431\":1,\"1175\":1,\"1619\":2}}],[\"clock\",{\"1\":{\"465\":1}}],[\"cv\",{\"1\":{\"361\":3}}],[\"cv索引呢\",{\"1\":{\"361\":1}}],[\"criteria\",{\"1\":{\"1616\":1}}],[\"cross\",{\"1\":{\"1201\":1}}],[\"creation\",{\"1\":{\"922\":1,\"1184\":1,\"1615\":1,\"1647\":4,\"1689\":1}}],[\"creating\",{\"1\":{\"431\":3,\"1480\":1,\"1621\":1,\"1623\":2,\"1647\":1,\"1650\":1}}],[\"creator\",{\"1\":{\"542\":1}}],[\"createtransactionifnecessary\",{\"1\":{\"1655\":1}}],[\"createannotatedbeandefreader\",{\"1\":{\"1647\":2,\"1651\":2}}],[\"createservletapplicationcontext\",{\"1\":{\"1658\":2}}],[\"creates\",{\"1\":{\"1608\":2,\"1615\":1,\"1619\":2,\"1620\":2,\"1621\":1}}],[\"createmessagesource\",{\"1\":{\"1063\":2,\"1064\":1}}],[\"createpropertysource\",{\"1\":{\"1032\":1}}],[\"createreadercontext\",{\"1\":{\"1021\":1}}],[\"createoptionaldependency\",{\"1\":{\"963\":1,\"1648\":1}}],[\"createuserbeandefinition\",{\"1\":{\"953\":2,\"954\":1}}],[\"createuser\",{\"1\":{\"930\":4,\"943\":1,\"985\":8,\"989\":2}}],[\"createbeanfactory\",{\"1\":{\"1163\":2,\"1651\":1}}],[\"createbeandefinitiondocumentreader\",{\"1\":{\"1021\":1}}],[\"createbeaninstance\",{\"1\":{\"1017\":1,\"1647\":1,\"1650\":1}}],[\"createbean\",{\"1\":{\"930\":2,\"1647\":4}}],[\"create语句\",{\"1\":{\"410\":1}}],[\"createdispatcherservlet\",{\"1\":{\"1658\":2}}],[\"createdependencyprovider\",{\"1\":{\"963\":1,\"1648\":1}}],[\"created\",{\"1\":{\"393\":2,\"922\":1,\"1166\":1,\"1594\":2,\"1618\":1,\"1619\":1,\"1620\":5,\"1647\":1,\"1651\":1}}],[\"create\",{\"1\":{\"307\":8,\"323\":1,\"335\":1,\"336\":1,\"338\":1,\"346\":1,\"349\":1,\"353\":1,\"361\":3,\"362\":4,\"363\":3,\"366\":1,\"368\":1,\"378\":2,\"400\":3,\"404\":3,\"407\":1,\"409\":1,\"412\":1,\"413\":2,\"414\":2,\"419\":2,\"424\":1,\"433\":1,\"446\":1,\"454\":1,\"459\":1,\"462\":1,\"468\":1,\"476\":1,\"478\":1,\"489\":1,\"490\":1,\"494\":3,\"506\":3,\"510\":1,\"518\":2,\"523\":4,\"534\":1,\"535\":1,\"557\":2,\"558\":2,\"559\":1,\"1587\":1,\"1588\":1,\"1615\":4,\"1619\":1,\"1620\":1,\"1647\":3,\"1651\":1,\"1654\":1}}],[\"crc\",{\"1\":{\"352\":2}}],[\"customeditorconfigurer\",{\"1\":{\"1638\":7}}],[\"customizablethreadfactory\",{\"1\":{\"1123\":2}}],[\"customizebeanfactory\",{\"1\":{\"1163\":3,\"1651\":1}}],[\"customizedspringeventdemo\",{\"1\":{\"1119\":1}}],[\"customizedpropertyeditorregistrar\",{\"1\":{\"1084\":2}}],[\"customizedmessagesourcebeandemo\",{\"1\":{\"1056\":2}}],[\"customizedresourcepatternresolver\",{\"1\":{\"1043\":1}}],[\"customize\",{\"1\":{\"1027\":1}}],[\"customizeregistration\",{\"1\":{\"1658\":1}}],[\"customizer\",{\"1\":{\"1027\":2}}],[\"customizers\",{\"1\":{\"1027\":3}}],[\"customscopeconfigurer\",{\"1\":{\"989\":1}}],[\"custom\",{\"1\":{\"963\":1,\"1135\":2}}],[\"cuser\",{\"1\":{\"341\":1}}],[\"currelements\",{\"1\":{\"964\":1,\"1648\":4}}],[\"currencyeditor\",{\"1\":{\"1083\":1}}],[\"currency\",{\"1\":{\"959\":1,\"1053\":1,\"1083\":1,\"1092\":1}}],[\"currentval\",{\"1\":{\"1288\":2}}],[\"currently\",{\"1\":{\"1184\":1}}],[\"currenttimemillis\",{\"1\":{\"1162\":1,\"1288\":1,\"1404\":1,\"1487\":2,\"1591\":4}}],[\"currentthread\",{\"1\":{\"930\":1,\"989\":2,\"1113\":1,\"1119\":1,\"1123\":1,\"1175\":1,\"1575\":2,\"1617\":2}}],[\"currentcontent\",{\"1\":{\"1116\":5}}],[\"currentproxy\",{\"1\":{\"1654\":1}}],[\"currentprojectrootpath\",{\"1\":{\"1044\":2}}],[\"currentpackagepath\",{\"1\":{\"1043\":2}}],[\"currentjavafile\",{\"1\":{\"1040\":2}}],[\"currentjavafilepath\",{\"1\":{\"1040\":2,\"1041\":2}}],[\"current\",{\"1\":{\"454\":1,\"468\":1,\"478\":1,\"510\":1,\"518\":1,\"538\":1,\"1006\":3,\"1116\":2,\"1620\":1}}],[\"currenthashmap的实现原理\",{\"0\":{\"41\":1,\"1369\":1}}],[\"cursor\",{\"1\":{\"573\":1,\"574\":1}}],[\"ccc\",{\"1\":{\"1486\":1}}],[\"cccc\",{\"1\":{\"468\":3}}],[\"ccv最后一个字段views会失效\",{\"1\":{\"361\":1}}],[\"ccv之后\",{\"1\":{\"361\":1}}],[\"ccv\",{\"1\":{\"361\":2}}],[\"cc\",{\"1\":{\"336\":1,\"1479\":1}}],[\"cities\",{\"1\":{\"1605\":5}}],[\"city2\",{\"1\":{\"1605\":2}}],[\"city1\",{\"1\":{\"1605\":2}}],[\"city这个索引的示意图如下\",{\"1\":{\"354\":1}}],[\"city=hangzhou\",{\"1\":{\"1146\":1}}],[\"city=\",{\"1\":{\"353\":1,\"354\":2,\"421\":1,\"1030\":1}}],[\"city\",{\"1\":{\"309\":1,\"353\":1,\"354\":3,\"355\":1,\"356\":10,\"421\":1,\"576\":2,\"994\":1,\"1022\":1,\"1030\":1,\"1072\":1,\"1146\":2,\"1605\":4,\"1618\":2}}],[\"circuit\",{\"1\":{\"1623\":2}}],[\"circuiting\",{\"1\":{\"1599\":8,\"1623\":2}}],[\"circular\",{\"1\":{\"1184\":1,\"1647\":7}}],[\"circularreferencesdemo\",{\"1\":{\"1184\":2}}],[\"cid\",{\"1\":{\"330\":2}}],[\"ch\",{\"1\":{\"1608\":1,\"1609\":1,\"1618\":15}}],[\"choice\",{\"1\":{\"1619\":2}}],[\"chongqing\",{\"1\":{\"1605\":1}}],[\"chooses\",{\"1\":{\"1622\":1}}],[\"choose\",{\"1\":{\"1215\":1}}],[\"chosen\",{\"1\":{\"519\":4}}],[\"childbeandefinition\",{\"1\":{\"1632\":1}}],[\"child\",{\"1\":{\"645\":7,\"997\":2,\"1647\":2}}],[\"children\",{\"1\":{\"645\":3}}],[\"china\",{\"1\":{\"576\":2}}],[\"checks\",{\"1\":{\"1689\":1}}],[\"checksum=crc32\",{\"1\":{\"454\":1}}],[\"checkdependencies\",{\"1\":{\"1647\":1}}],[\"checkmergedbeandefinition\",{\"1\":{\"1647\":1}}],[\"checkcandidate\",{\"1\":{\"1647\":1}}],[\"checkconfigmembers\",{\"1\":{\"964\":1,\"1648\":1}}],[\"checked\",{\"1\":{\"1623\":1}}],[\"check就是bincount\",{\"1\":{\"1554\":1}}],[\"checknotnull\",{\"1\":{\"1502\":1}}],[\"check`\",{\"1\":{\"478\":1}}],[\"check表上存入多行数据\",{\"1\":{\"478\":1}}],[\"check这个表需要再加一行\",{\"1\":{\"478\":1}}],[\"check\",{\"1\":{\"477\":2,\"478\":2,\"922\":1,\"997\":2,\"1175\":1,\"1297\":1,\"1432\":1,\"1554\":4,\"1620\":1,\"1647\":6,\"1655\":1,\"1658\":1}}],[\"checking\",{\"1\":{\"431\":1,\"1620\":1}}],[\"checkpoint是当前要擦除的位置\",{\"1\":{\"324\":1}}],[\"chatset\",{\"1\":{\"1663\":1}}],[\"chance\",{\"1\":{\"1647\":1}}],[\"channel的读写操作都是异步的\",{\"1\":{\"1574\":1}}],[\"channel的四大组件\",{\"0\":{\"709\":1}}],[\"channel是一个通道\",{\"1\":{\"1574\":1}}],[\"channel会注册到selector\",{\"1\":{\"1422\":1}}],[\"channel类似于流\",{\"1\":{\"1422\":1}}],[\"channelpipeline为channelhandler的链\",{\"1\":{\"1224\":1}}],[\"channelpipeline\",{\"1\":{\"1224\":1}}],[\"channelhandler\",{\"1\":{\"1224\":1}}],[\"channelhandler与channelhandlercontext\",{\"0\":{\"712\":1}}],[\"channel接口是netty对网络操作的抽象类\",{\"1\":{\"1224\":1}}],[\"channel注册流程\",{\"0\":{\"714\":1}}],[\"channel选择器\",{\"0\":{\"713\":1}}],[\"channeloption与attributekey\",{\"0\":{\"711\":1}}],[\"channel与channelpipeline\",{\"0\":{\"710\":1}}],[\"channel实现原理\",{\"0\":{\"708\":1}}],[\"channelfuture\",{\"0\":{\"697\":1},\"1\":{\"1224\":1,\"1226\":2}}],[\"channels\",{\"1\":{\"598\":1,\"599\":1}}],[\"channel\",{\"0\":{\"688\":1},\"1\":{\"597\":5,\"1224\":1,\"1226\":2,\"1328\":3,\"1422\":1,\"1574\":31,\"1575\":19,\"1619\":2,\"1620\":1}}],[\"channel1\",{\"1\":{\"596\":2}}],[\"changemap\",{\"1\":{\"1365\":4}}],[\"changes\",{\"1\":{\"542\":1,\"997\":1,\"1171\":1,\"1647\":1}}],[\"changed=false\",{\"1\":{\"1531\":1}}],[\"changed\",{\"1\":{\"519\":1,\"1531\":3}}],[\"change\",{\"0\":{\"344\":1,\"345\":1},\"1\":{\"343\":5,\"344\":3,\"345\":1,\"467\":1,\"468\":1,\"1531\":2,\"1619\":1}}],[\"chains\",{\"1\":{\"1623\":1}}],[\"chainedreference\",{\"1\":{\"1623\":1}}],[\"chainedreference<t\",{\"1\":{\"1623\":1}}],[\"chainedreference<p\",{\"1\":{\"1622\":1}}],[\"chaining\",{\"1\":{\"1621\":1}}],[\"chain\",{\"1\":{\"435\":1,\"1166\":1,\"1621\":1,\"1623\":1,\"1654\":1}}],[\"chain语法\",{\"1\":{\"435\":1}}],[\"charat\",{\"1\":{\"1601\":2,\"1614\":2}}],[\"chararraypropertyeditor\",{\"1\":{\"1083\":1}}],[\"characteristics会作为一个位操作来标识的\",{\"1\":{\"1620\":1}}],[\"characteristics>\",{\"1\":{\"1618\":4}}],[\"characteristics是collector的一个属性\",{\"1\":{\"1615\":1}}],[\"characteristics\",{\"1\":{\"1615\":8,\"1616\":8,\"1617\":38,\"1618\":21,\"1619\":1,\"1620\":16,\"1621\":2}}],[\"characteristic\",{\"1\":{\"1615\":2,\"1620\":7,\"1621\":1}}],[\"charactereditor\",{\"1\":{\"1083\":1}}],[\"characters\",{\"1\":{\"1061\":1}}],[\"character\",{\"1\":{\"368\":1,\"959\":1,\"1614\":4}}],[\"charsequence是一个接口\",{\"1\":{\"946\":1}}],[\"charsequence\",{\"1\":{\"946\":1,\"1618\":3}}],[\"charseteditor\",{\"1\":{\"1083\":1}}],[\"charset=utf8\",{\"1\":{\"510\":1,\"518\":1,\"523\":1,\"535\":1}}],[\"charset\",{\"1\":{\"366\":1,\"368\":1,\"424\":1,\"506\":3,\"534\":1,\"959\":1,\"1083\":1,\"1619\":1}}],[\"char和varchar适用于包括人名\",{\"1\":{\"530\":1}}],[\"char\",{\"1\":{\"330\":3,\"378\":5,\"419\":4,\"530\":2,\"959\":1,\"1083\":2,\"1347\":1,\"1614\":2}}],[\"camel\",{\"1\":{\"1519\":1}}],[\"capturing\",{\"1\":{\"1623\":1}}],[\"capacity\",{\"1\":{\"1502\":3,\"1503\":8,\"1550\":9,\"1553\":1,\"1554\":2}}],[\"cap原则又称为cap定理\",{\"1\":{\"1311\":1}}],[\"cascaded\",{\"1\":{\"1618\":1}}],[\"cas+park\",{\"1\":{\"1530\":1}}],[\"cas操作\",{\"1\":{\"1485\":1}}],[\"casbase\",{\"1\":{\"1480\":1}}],[\"casx\",{\"1\":{\"1479\":1}}],[\"cas失败\",{\"1\":{\"1479\":1}}],[\"cas成功\",{\"1\":{\"1479\":1}}],[\"cas逻辑\",{\"1\":{\"1479\":1}}],[\"cas的过程如下\",{\"1\":{\"1479\":1}}],[\"cas的伪代码如下\",{\"1\":{\"1479\":1}}],[\"cas通常指的是这样一种原子操作\",{\"1\":{\"1479\":1}}],[\"cas源码解析\",{\"0\":{\"1479\":1}}],[\"cas与atomic实现原理\",{\"0\":{\"1478\":1}}],[\"cas\",{\"1\":{\"1369\":1,\"1475\":1,\"1479\":9,\"1480\":3,\"1482\":1,\"1554\":2,\"1668\":1}}],[\"cases\",{\"1\":{\"1619\":2,\"1621\":1}}],[\"caseinsensitivecomparator\",{\"1\":{\"1614\":2}}],[\"case\",{\"1\":{\"963\":2,\"997\":1,\"1601\":2,\"1614\":2,\"1617\":1,\"1647\":2,\"1648\":1,\"1655\":2}}],[\"castresult\",{\"1\":{\"1618\":2}}],[\"castingidentity\",{\"1\":{\"1616\":1}}],[\"castabat\",{\"1\":{\"1554\":1}}],[\"cast\",{\"1\":{\"367\":1,\"1099\":1,\"1615\":1,\"1617\":2,\"1620\":1}}],[\"calculation\",{\"1\":{\"1620\":1,\"1623\":1}}],[\"calendar\",{\"1\":{\"959\":1}}],[\"calling\",{\"1\":{\"1620\":3,\"1623\":4}}],[\"called\",{\"1\":{\"1608\":2,\"1615\":1,\"1617\":1,\"1619\":1,\"1620\":1,\"1622\":1,\"1623\":2}}],[\"callerrunspolicy\",{\"1\":{\"1410\":1,\"1476\":1}}],[\"caller\",{\"1\":{\"922\":1,\"1595\":2,\"1597\":1,\"1598\":6,\"1599\":4,\"1615\":1,\"1620\":2,\"1647\":1,\"1651\":1}}],[\"callable\",{\"1\":{\"1477\":1}}],[\"callable用于产生结果\",{\"1\":{\"1396\":1}}],[\"calls\",{\"1\":{\"1055\":1,\"1167\":1,\"1620\":3}}],[\"callbackpreferringplatformtransactionmanager\",{\"1\":{\"1655\":3}}],[\"callbackfilter\",{\"1\":{\"1654\":1}}],[\"callbacks\",{\"1\":{\"1164\":1}}],[\"callback\",{\"1\":{\"989\":1,\"1654\":1,\"1655\":3}}],[\"call\",{\"1\":{\"400\":1,\"404\":1,\"414\":1,\"419\":1,\"518\":1,\"523\":2,\"1564\":1,\"1565\":2,\"1623\":6}}],[\"caching\",{\"1\":{\"895\":1,\"1138\":1,\"1171\":1,\"1647\":1}}],[\"cachedfieldvalue\",{\"1\":{\"964\":1,\"1648\":5}}],[\"cached\",{\"1\":{\"964\":2,\"1175\":1,\"1647\":2,\"1648\":2}}],[\"caches\",{\"1\":{\"922\":1,\"1172\":1,\"1647\":1,\"1651\":1}}],[\"cache的速度也是很快的\",{\"1\":{\"451\":1}}],[\"cache的保存问题\",{\"1\":{\"450\":1}}],[\"cache中保存着cpu刚刚用过或循环使用的一部分数据\",{\"1\":{\"1474\":1}}],[\"cache中写到磁盘上的binlog文件\",{\"1\":{\"451\":1}}],[\"cache中就够了\",{\"1\":{\"451\":1}}],[\"cache也差不多\",{\"1\":{\"451\":1}}],[\"cache里面\",{\"1\":{\"451\":1}}],[\"cache里的完整事务写入到binlog中\",{\"1\":{\"450\":1}}],[\"cache所占内存的大小\",{\"1\":{\"450\":1}}],[\"cache分配了一片内存\",{\"1\":{\"450\":1}}],[\"cache写入到binlog文件中\",{\"1\":{\"450\":1}}],[\"cache显式指定\",{\"1\":{\"319\":1}}],[\"cache\",{\"1\":{\"319\":2,\"450\":5,\"451\":3,\"526\":2,\"645\":1,\"997\":1,\"1283\":1,\"1647\":4}}],[\"cab\",{\"1\":{\"556\":1}}],[\"cause\",{\"1\":{\"519\":4,\"520\":2}}],[\"candidateindicators\",{\"1\":{\"1652\":4}}],[\"candidatenames存的就是找到的和所给类型匹配的所有的bean\",{\"1\":{\"1648\":1}}],[\"candidatenames\",{\"1\":{\"1648\":5}}],[\"candidate\",{\"1\":{\"1647\":11,\"1648\":13}}],[\"candidates\",{\"1\":{\"1020\":1,\"1647\":5}}],[\"cannot\",{\"1\":{\"996\":1,\"997\":2,\"1614\":1,\"1617\":1,\"1618\":1,\"1620\":3,\"1647\":4,\"1655\":1}}],[\"cancel\",{\"1\":{\"1517\":1,\"1574\":3}}],[\"cancellation\",{\"1\":{\"1623\":1}}],[\"cancellationrequested\",{\"1\":{\"1623\":5}}],[\"cancelled\",{\"1\":{\"1490\":1}}],[\"cancelling\",{\"1\":{\"922\":1,\"1647\":1,\"1651\":1}}],[\"cancelrefresh\",{\"1\":{\"922\":1,\"1647\":1,\"1651\":1}}],[\"can\",{\"1\":{\"429\":1,\"611\":2,\"928\":1,\"1594\":2,\"1608\":2,\"1615\":4,\"1617\":2,\"1618\":1,\"1619\":3,\"1620\":6,\"1623\":4,\"1647\":1,\"1648\":1,\"1689\":1}}],[\"card索引的情况下\",{\"1\":{\"362\":2}}],[\"card的值是否精确相同\",{\"1\":{\"352\":1}}],[\"cardinality直译过来就是基数的意思\",{\"1\":{\"553\":1}}],[\"cardinality属性\",{\"1\":{\"553\":1}}],[\"cardinality\",{\"1\":{\"347\":1,\"553\":2}}],[\"card字段创建唯一索引\",{\"1\":{\"341\":1}}],[\"card字段上创建索引\",{\"1\":{\"341\":1}}],[\"card`\",{\"1\":{\"338\":3}}],[\"card\",{\"1\":{\"332\":5,\"333\":1,\"334\":1,\"341\":1,\"352\":4,\"362\":6,\"363\":4}}],[\"cat命令用于将文件内容输出到标准输出\",{\"1\":{\"1464\":1}}],[\"catch\",{\"1\":{\"582\":1,\"922\":1,\"944\":1,\"946\":1,\"963\":1,\"964\":3,\"965\":1,\"973\":1,\"989\":1,\"996\":1,\"997\":1,\"1007\":1,\"1008\":1,\"1013\":1,\"1022\":1,\"1043\":1,\"1082\":1,\"1084\":1,\"1124\":1,\"1163\":1,\"1175\":2,\"1239\":1,\"1387\":1,\"1404\":11,\"1432\":1,\"1533\":1,\"1534\":1,\"1535\":2,\"1573\":4,\"1574\":6,\"1575\":9,\"1587\":1,\"1588\":1,\"1647\":16,\"1648\":4,\"1651\":2,\"1655\":5,\"1663\":1}}],[\"catlevel\",{\"1\":{\"330\":4}}],[\"cat\",{\"1\":{\"330\":8,\"1464\":1}}],[\"category\",{\"1\":{\"329\":2,\"330\":10,\"361\":5}}],[\"c=c\",{\"1\":{\"1617\":4}}],[\"c=c+1\",{\"1\":{\"323\":1}}],[\"c=3这个数据版本的trx\",{\"1\":{\"497\":1}}],[\"c=5\",{\"1\":{\"447\":4}}],[\"c=10\",{\"1\":{\"321\":1}}],[\"c\",{\"1\":{\"323\":1,\"377\":10,\"413\":1,\"416\":3,\"417\":1,\"418\":1,\"422\":7,\"429\":3,\"433\":2,\"447\":1,\"459\":4,\"466\":3,\"468\":1,\"476\":4,\"484\":2,\"506\":1,\"534\":1,\"577\":2,\"598\":1,\"1404\":2,\"1432\":8,\"1476\":4,\"1480\":4,\"1483\":2,\"1503\":8,\"1551\":2,\"1553\":3,\"1603\":2,\"1609\":1,\"1617\":7,\"1618\":1,\"1621\":2,\"1663\":8,\"1966\":1}}],[\"cover\",{\"1\":{\"1620\":1}}],[\"covering\",{\"1\":{\"1620\":1}}],[\"covered\",{\"1\":{\"1620\":2}}],[\"covers\",{\"1\":{\"1620\":3}}],[\"code\",{\"1\":{\"1050\":1,\"1594\":7,\"1595\":3,\"1597\":8,\"1598\":18,\"1599\":22,\"1601\":8,\"1608\":7}}],[\"could\",{\"1\":{\"997\":1,\"1022\":1,\"1615\":2,\"1618\":1,\"1620\":2,\"1623\":1,\"1647\":1}}],[\"countedcompleter<void>\",{\"1\":{\"1620\":1}}],[\"countedcompleter\",{\"1\":{\"1620\":2}}],[\"countercells\",{\"1\":{\"1554\":1}}],[\"countercell\",{\"1\":{\"1554\":2}}],[\"counter++\",{\"1\":{\"498\":1,\"928\":1,\"1482\":3}}],[\"counter定义的大小是4个字节\",{\"1\":{\"498\":1}}],[\"counter赋值给这个新连接的线程变量\",{\"1\":{\"498\":1}}],[\"counter\",{\"1\":{\"498\":1,\"567\":1,\"928\":4,\"1482\":4}}],[\"counter跳过事务和通过slave\",{\"1\":{\"468\":1}}],[\"counter=1\",{\"1\":{\"467\":1}}],[\"counts\",{\"1\":{\"1613\":1}}],[\"counting\",{\"1\":{\"1613\":2,\"1615\":1,\"1616\":1}}],[\"count++\",{\"1\":{\"1502\":1}}],[\"count++的操作也不是原子性的\",{\"1\":{\"1385\":1}}],[\"countdown\",{\"1\":{\"1404\":1}}],[\"countdownlatch的计数器只能使用一次\",{\"1\":{\"1496\":1}}],[\"countdownlatch\",{\"1\":{\"1404\":6,\"1490\":1}}],[\"countbefore\",{\"1\":{\"1021\":2}}],[\"count缺省值为1\",{\"1\":{\"572\":2}}],[\"count也无效了\",{\"1\":{\"451\":1}}],[\"count参数\",{\"1\":{\"451\":2,\"465\":1}}],[\"count来实现\",{\"1\":{\"451\":1}}],[\"count\",{\"0\":{\"395\":1,\"396\":1,\"526\":1},\"1\":{\"330\":1,\"350\":5,\"366\":2,\"390\":1,\"395\":1,\"396\":1,\"399\":7,\"416\":3,\"417\":1,\"418\":1,\"422\":2,\"429\":1,\"479\":1,\"526\":6,\"571\":4,\"572\":4,\"573\":2,\"574\":2,\"576\":1,\"1022\":3,\"1404\":2,\"1483\":1,\"1485\":1,\"1498\":3,\"1502\":4,\"1503\":9,\"1553\":2,\"1594\":4,\"1612\":2,\"1613\":1,\"1615\":1,\"1619\":1,\"1620\":2}}],[\"corinv\",{\"1\":{\"1655\":6}}],[\"coroutinesutils\",{\"1\":{\"1655\":1}}],[\"coroutinesinvocationcallback\",{\"1\":{\"1655\":3}}],[\"coroutines\",{\"1\":{\"1655\":2}}],[\"corresponds\",{\"1\":{\"1620\":1}}],[\"corresponding\",{\"1\":{\"922\":1,\"1620\":3,\"1623\":1,\"1647\":1}}],[\"correct\",{\"1\":{\"997\":1,\"1619\":1,\"1623\":3,\"1647\":1}}],[\"corrdinator再去取下一批\",{\"1\":{\"464\":1}}],[\"corrdinator直接执行这个事务\",{\"1\":{\"462\":1}}],[\"corrdinator暂时先hold住这个事务\",{\"1\":{\"462\":1}}],[\"corrdinator在解析这个语句的binlog的时候\",{\"1\":{\"462\":1}}],[\"corrdinator线程就会把这个事务分配给这个存在冲突关系的worker\",{\"1\":{\"461\":1}}],[\"corrdinator线程就会把这个事务分配给最闲的worker\",{\"1\":{\"461\":1}}],[\"corrdinator线程就会进入等待状态\",{\"1\":{\"461\":1}}],[\"corrdinator线程就进入等待\",{\"1\":{\"461\":1}}],[\"corrdinator继续读下一个中转日志\",{\"1\":{\"461\":1}}],[\"corrdinator从中转日志中读入下一个新事务t\",{\"1\":{\"461\":1}}],[\"corepoolsize\",{\"1\":{\"1476\":3}}],[\"core\",{\"1\":{\"903\":1,\"922\":1,\"1031\":3,\"1038\":5,\"1039\":4,\"1040\":5,\"1041\":4,\"1042\":2,\"1086\":4,\"1087\":1,\"1088\":2,\"1089\":3,\"1090\":2,\"1091\":4,\"1092\":1,\"1093\":1,\"1096\":4,\"1100\":1,\"1101\":2,\"1102\":1,\"1103\":1,\"1125\":1,\"1134\":8,\"1139\":1,\"1147\":1,\"1151\":3,\"1152\":1,\"1153\":4,\"1154\":3,\"1155\":2,\"1159\":3,\"1621\":1,\"1647\":1,\"1651\":1}}],[\"collectingandthen\",{\"1\":{\"1616\":1,\"1618\":2}}],[\"collectiontocommadelimitedstring\",{\"1\":{\"1647\":1}}],[\"collectionfactory\",{\"1\":{\"1609\":2,\"1618\":2}}],[\"collection提供了新的stream\",{\"1\":{\"1608\":1}}],[\"collection<\",{\"1\":{\"1621\":1}}],[\"collection<widget>\",{\"1\":{\"1619\":1}}],[\"collection<t>\",{\"1\":{\"1609\":1,\"1618\":1}}],[\"collection<t>>\",{\"1\":{\"1609\":1,\"1618\":1}}],[\"collection<e>\",{\"1\":{\"1500\":1}}],[\"collection<student>\",{\"1\":{\"1184\":3}}],[\"collection<user>\",{\"1\":{\"918\":3,\"961\":5}}],[\"collectionutils\",{\"1\":{\"1170\":1,\"1648\":1}}],[\"collections\",{\"1\":{\"1091\":1,\"1370\":1,\"1605\":2,\"1611\":1,\"1614\":12,\"1616\":1,\"1617\":5,\"1618\":5,\"1619\":3,\"1620\":2,\"1639\":2}}],[\"collection\",{\"1\":{\"645\":2,\"960\":2,\"963\":4,\"996\":1,\"1162\":1,\"1615\":2,\"1617\":1,\"1619\":5,\"1620\":8,\"1621\":1,\"1622\":2,\"1648\":1}}],[\"collect本身的定义是这样的\",{\"1\":{\"1615\":1}}],[\"collector所使用的map是由supplied工厂函数提供的\",{\"1\":{\"1618\":1}}],[\"collectorimpl\",{\"1\":{\"1616\":2}}],[\"collectorimpl<charsequence\",{\"1\":{\"1618\":1}}],[\"collectorimpl<t\",{\"1\":{\"1616\":1}}],[\"collectorimpl<>\",{\"1\":{\"1608\":1,\"1609\":1,\"1618\":12}}],[\"collector接口有且仅有唯一的实现类collectorimpl\",{\"1\":{\"1616\":1}}],[\"collector实践\",{\"0\":{\"1616\":1}}],[\"collector必须满足两个条件\",{\"1\":{\"1615\":1}}],[\"collector是由以下四个方法构成\",{\"1\":{\"1615\":1}}],[\"collector<charsequence\",{\"1\":{\"1618\":2}}],[\"collector<employee\",{\"1\":{\"1615\":2}}],[\"collector<widget\",{\"1\":{\"1615\":1}}],[\"collector<\",{\"1\":{\"1615\":1,\"1617\":2,\"1618\":5}}],[\"collector<t\",{\"1\":{\"1608\":1,\"1609\":1,\"1613\":2,\"1616\":1,\"1617\":2,\"1618\":14}}],[\"collector无疑是整个stream源码中及其重要的一个类\",{\"1\":{\"1615\":1}}],[\"collector源码分析\",{\"0\":{\"1615\":1}}],[\"collector\",{\"1\":{\"1613\":2,\"1615\":25,\"1616\":1,\"1617\":19,\"1618\":21}}],[\"collectors作为生产collector的静态工厂类\",{\"1\":{\"1618\":1}}],[\"collectors源码分析\",{\"0\":{\"1618\":1}}],[\"collectors实现了collector接口并提供了很多很有用的汇聚操作\",{\"1\":{\"1616\":1}}],[\"collectors类被用来生产一些常见的方法\",{\"1\":{\"1616\":1}}],[\"collectors很多方法可以接收collector作为参数返回一个新的collector\",{\"1\":{\"1615\":1}}],[\"collectors还有一个描述特征的的集合\",{\"1\":{\"1615\":1}}],[\"collectors是collector的实现类\",{\"1\":{\"1615\":1}}],[\"collectors提供了很多对于常见的可变的汇聚操作的实现\",{\"1\":{\"1615\":1}}],[\"collectors\",{\"1\":{\"1598\":2,\"1608\":1,\"1609\":9,\"1613\":7,\"1615\":15,\"1616\":26,\"1618\":3}}],[\"collect无需其他操作就可以很好的支持并行流\",{\"1\":{\"1608\":1}}],[\"collect方法接收三个参数\",{\"1\":{\"1608\":1}}],[\"collect\",{\"1\":{\"1598\":2,\"1608\":14,\"1609\":9,\"1613\":5,\"1615\":5,\"1616\":19,\"1617\":8,\"1618\":4}}],[\"collaborators\",{\"1\":{\"927\":1}}],[\"collation\",{\"1\":{\"553\":1}}],[\"columns\",{\"1\":{\"519\":2,\"553\":1,\"555\":2}}],[\"column\",{\"1\":{\"417\":1,\"441\":2,\"553\":1}}],[\"cooperatively\",{\"1\":{\"1623\":1}}],[\"cookiename=cookievalue\",{\"1\":{\"1201\":1}}],[\"cookie\",{\"1\":{\"1200\":1,\"1201\":1,\"1978\":1}}],[\"cookie和session有什么区别\",{\"0\":{\"217\":1,\"1200\":1}}],[\"coordinator在分发的时候\",{\"1\":{\"460\":1}}],[\"coordinator就是原来的sql\",{\"1\":{\"460\":1}}],[\"copyintowithcancel\",{\"1\":{\"1623\":1}}],[\"copyinto\",{\"1\":{\"1623\":4}}],[\"copying\",{\"1\":{\"431\":1,\"1439\":1}}],[\"copy都是少不了的\",{\"1\":{\"1585\":1}}],[\"copyonwritearraylis就是一个不可变的元\",{\"1\":{\"1620\":1}}],[\"copyonwritearraylist和copyonwritearrayset这两个copy\",{\"1\":{\"1527\":1}}],[\"copyonwritearraylist\",{\"1\":{\"1416\":1,\"1620\":1}}],[\"copyonwritearraylist来代替\",{\"1\":{\"1370\":1}}],[\"copyonwritearraylist可以用于什么应用场景\",{\"0\":{\"74\":1,\"1403\":1}}],[\"copyof\",{\"1\":{\"1475\":1,\"1618\":1}}],[\"copyrelevantmergedbeandefinitioncaches\",{\"1\":{\"997\":1,\"1647\":1}}],[\"copy\",{\"0\":{\"1527\":1},\"1\":{\"588\":1,\"997\":2,\"1527\":3,\"1583\":1}}],[\"cost多出了两列\",{\"1\":{\"557\":1}}],[\"costs\",{\"1\":{\"557\":1}}],[\"cost表相比\",{\"1\":{\"557\":1}}],[\"cost表\",{\"1\":{\"557\":2}}],[\"cost表中\",{\"1\":{\"557\":2}}],[\"cost\",{\"1\":{\"404\":1,\"405\":1,\"519\":7,\"553\":8,\"555\":12,\"557\":12,\"1615\":1}}],[\"convenience\",{\"1\":{\"1620\":1}}],[\"conversionservice可以自定义转换类型\",{\"1\":{\"1639\":1}}],[\"conversionservice是spring中提供的类型转化服务\",{\"1\":{\"1639\":1}}],[\"conversionservice实现\",{\"1\":{\"1093\":1}}],[\"conversionservice作为依赖\",{\"0\":{\"1093\":1}}],[\"conversionservice说明\",{\"1\":{\"1092\":1}}],[\"conversionservicefactorybean\",{\"1\":{\"1091\":1,\"1639\":6}}],[\"conversionservice\",{\"0\":{\"1639\":1},\"1\":{\"1070\":1,\"1091\":2,\"1093\":4,\"1151\":1,\"1152\":1,\"1171\":2,\"1639\":1}}],[\"conversion\",{\"1\":{\"892\":1,\"1084\":1,\"1091\":1,\"1171\":4}}],[\"convertvalueifnecessary\",{\"1\":{\"1151\":1}}],[\"convertlfnecessary重载方法\",{\"1\":{\"1093\":1}}],[\"convertifnecessnary\",{\"1\":{\"1093\":1}}],[\"convertifnecessary\",{\"1\":{\"963\":5,\"1640\":1,\"1648\":3}}],[\"convertiblepair\",{\"1\":{\"1086\":1,\"1089\":1,\"1091\":1,\"1639\":1}}],[\"convertingcomparator<>\",{\"1\":{\"1654\":2}}],[\"converting\",{\"1\":{\"431\":1}}],[\"converter<method\",{\"1\":{\"1654\":1}}],[\"converter<s\",{\"1\":{\"1086\":1}}],[\"converters\",{\"1\":{\"1091\":1}}],[\"converterfatory\",{\"1\":{\"1091\":1}}],[\"converter接口的局限性\",{\"0\":{\"1088\":1}}],[\"converter\",{\"1\":{\"963\":8,\"1086\":3,\"1088\":2,\"1089\":2,\"1090\":2,\"1091\":4,\"1096\":5,\"1648\":4,\"1657\":1}}],[\"convert\",{\"1\":{\"368\":3,\"1086\":6,\"1087\":1,\"1088\":2,\"1089\":4,\"1090\":2,\"1091\":5,\"1092\":1,\"1093\":1,\"1096\":4,\"1151\":2,\"1152\":1,\"1598\":1,\"1616\":1,\"1639\":1}}],[\"connet事件等待结果而不用像bio那样被同步阻塞\",{\"1\":{\"1574\":1}}],[\"connector\",{\"1\":{\"1683\":1}}],[\"connect\",{\"1\":{\"1224\":1,\"1226\":1,\"1574\":2,\"1575\":1}}],[\"connected\",{\"1\":{\"609\":1}}],[\"connection命令时\",{\"1\":{\"481\":1}}],[\"connection命令\",{\"1\":{\"481\":1}}],[\"connection命令是有效的\",{\"1\":{\"480\":1}}],[\"connection来重新初始化连接资源\",{\"1\":{\"318\":1}}],[\"connection\",{\"1\":{\"318\":1,\"480\":1,\"481\":4,\"583\":3}}],[\"conn\",{\"1\":{\"1288\":6,\"1655\":1}}],[\"conform\",{\"1\":{\"1619\":1,\"1620\":1}}],[\"confinement这种模式来实现\",{\"1\":{\"1620\":1}}],[\"confinement\",{\"1\":{\"1620\":1}}],[\"confined\",{\"1\":{\"1615\":1}}],[\"confirms\",{\"1\":{\"1328\":1}}],[\"config类型的所有的beans\",{\"1\":{\"929\":1}}],[\"configureblocking\",{\"1\":{\"1574\":3}}],[\"configure\",{\"1\":{\"1056\":1,\"1164\":1}}],[\"configured\",{\"1\":{\"997\":1,\"1647\":1}}],[\"configuror\",{\"1\":{\"900\":1}}],[\"configurablepropertyresolver\",{\"1\":{\"1162\":1}}],[\"configurableenvironment\",{\"1\":{\"1139\":1,\"1147\":1,\"1153\":1,\"1156\":1,\"1157\":1,\"1159\":1}}],[\"configurableapplicationcontext\",{\"1\":{\"1056\":1,\"1065\":1,\"1084\":1,\"1149\":3,\"1175\":1,\"1177\":4}}],[\"configurablebeanfactory临时classloader\",{\"1\":{\"998\":1}}],[\"configurablebeanfactory\",{\"1\":{\"985\":2,\"989\":1,\"997\":5,\"1093\":1,\"1636\":2,\"1647\":3}}],[\"configurablelistablebeanfactory\",{\"1\":{\"922\":1,\"936\":1,\"977\":1,\"1009\":1,\"1055\":1,\"1056\":1,\"1121\":1,\"1164\":2,\"1165\":3,\"1166\":2,\"1167\":1,\"1168\":1,\"1171\":2,\"1636\":1,\"1647\":1,\"1648\":2,\"1651\":1}}],[\"configurable模式\",{\"1\":{\"900\":1}}],[\"configurationphase\",{\"1\":{\"1139\":1}}],[\"configurationclassbeandefinitionreader\",{\"1\":{\"1183\":1}}],[\"configurationclassparser\",{\"1\":{\"1139\":1,\"1155\":2,\"1652\":1}}],[\"configurationclasspostprocessor\",{\"1\":{\"1139\":1,\"1165\":1,\"1652\":1}}],[\"configurationclasspostprocessor对象\",{\"1\":{\"945\":1}}],[\"configurationcondition\",{\"1\":{\"1139\":1}}],[\"configuration是非必须的注解\",{\"1\":{\"940\":1,\"943\":1}}],[\"configuration\",{\"0\":{\"832\":1,\"871\":1},\"1\":{\"583\":1,\"645\":1,\"921\":1,\"929\":1,\"931\":1,\"978\":1,\"1023\":1,\"1131\":1,\"1138\":1,\"1142\":1,\"1183\":2,\"1184\":1,\"1652\":1}}],[\"config\",{\"0\":{\"818\":1},\"1\":{\"567\":1,\"917\":1,\"929\":3,\"989\":3,\"1020\":1,\"1022\":1,\"1029\":2,\"1031\":1,\"1032\":4,\"1146\":3,\"1654\":5,\"1658\":1}}],[\"conf配置文件中配置了这个脚本路径\",{\"1\":{\"624\":1}}],[\"conf\",{\"1\":{\"621\":1,\"624\":2}}],[\"conf中第8条\",{\"1\":{\"609\":1}}],[\"conf中开启相关配置即可\",{\"1\":{\"587\":1}}],[\"conduct\",{\"1\":{\"1623\":1}}],[\"condtional实现原理大致如下\",{\"1\":{\"1139\":1}}],[\"cond\",{\"1\":{\"481\":1,\"1483\":1,\"1530\":1}}],[\"conditionfilter4\",{\"1\":{\"1599\":2}}],[\"conditionfilter3\",{\"1\":{\"1599\":2}}],[\"conditionfilter2\",{\"1\":{\"1599\":2}}],[\"conditionfilter\",{\"1\":{\"1599\":10}}],[\"condition接口\",{\"0\":{\"1493\":1}}],[\"condition接口实现\",{\"1\":{\"1139\":1}}],[\"condition具体实现\",{\"1\":{\"1139\":1}}],[\"conditionevaluator\",{\"1\":{\"1027\":2,\"1139\":1}}],[\"conditioncontext\",{\"1\":{\"1023\":1,\"1139\":3}}],[\"conditional注解的使用也可能会用到profile属性\",{\"1\":{\"1139\":1}}],[\"conditional实现\",{\"1\":{\"1139\":1}}],[\"conditionalconverter\",{\"1\":{\"1090\":1,\"1096\":1}}],[\"conditionalconverter实现\",{\"1\":{\"1088\":1}}],[\"conditionalgenericconverter\",{\"1\":{\"1090\":1,\"1091\":1,\"1096\":1,\"1639\":1}}],[\"conditional\",{\"1\":{\"1023\":2,\"1139\":2,\"1633\":1}}],[\"conditionalonclass注解中有两个类是默认不存在的\",{\"1\":{\"583\":1}}],[\"conditions\",{\"1\":{\"519\":8}}],[\"condition\",{\"1\":{\"340\":1,\"519\":10,\"553\":2,\"554\":1,\"555\":5,\"1023\":1,\"1139\":2,\"1490\":1,\"1502\":2,\"1503\":2,\"1647\":1}}],[\"cons是原生的consumer特化的类型\",{\"1\":{\"1620\":1}}],[\"cons>\",{\"1\":{\"1620\":1}}],[\"consequence\",{\"1\":{\"1620\":1,\"1647\":1}}],[\"consumes\",{\"1\":{\"1623\":3}}],[\"consumed\",{\"1\":{\"1619\":1,\"1620\":1,\"1621\":6,\"1622\":4}}],[\"consumer消息接收重试\",{\"0\":{\"1930\":1}}],[\"consumertest\",{\"1\":{\"1620\":8}}],[\"consumerthreads\",{\"1\":{\"1535\":2}}],[\"consumer原生类型的特化\",{\"1\":{\"1620\":1}}],[\"consumer代表了一种接收单个输入并且不返回结果的操作\",{\"1\":{\"1597\":1}}],[\"consumer这个单词本身的意思是消费者\",{\"1\":{\"1597\":1}}],[\"consumer函数式接口\",{\"0\":{\"1597\":1}}],[\"consumer<integer>\",{\"1\":{\"1620\":3}}],[\"consumer<string>\",{\"1\":{\"1597\":1}}],[\"consumer<\",{\"1\":{\"1594\":3,\"1595\":1,\"1597\":1,\"1620\":6,\"1621\":2,\"1622\":4,\"1623\":1}}],[\"consumer<t>\",{\"1\":{\"1594\":4,\"1597\":2,\"1620\":3}}],[\"consumer\",{\"1\":{\"943\":1,\"1597\":4,\"1619\":2,\"1620\":13,\"1623\":4}}],[\"cons\",{\"1\":{\"1351\":3,\"1620\":4}}],[\"consists\",{\"1\":{\"1619\":1,\"1623\":1}}],[\"consisting\",{\"1\":{\"1609\":1}}],[\"consistency=on\",{\"1\":{\"468\":1}}],[\"consistency\",{\"1\":{\"432\":1,\"1311\":1}}],[\"considerations\",{\"1\":{\"1620\":1}}],[\"considers\",{\"1\":{\"1614\":1}}],[\"considered\",{\"1\":{\"519\":4,\"1621\":1}}],[\"consider\",{\"1\":{\"429\":1,\"1615\":1,\"1623\":1,\"1647\":1,\"1648\":2}}],[\"constrain\",{\"1\":{\"1620\":1}}],[\"constraint\",{\"1\":{\"1615\":2}}],[\"constraints\",{\"1\":{\"1615\":2,\"1620\":1}}],[\"constructs\",{\"1\":{\"1623\":1}}],[\"constructions\",{\"1\":{\"1620\":1}}],[\"construction\",{\"1\":{\"1619\":1,\"1620\":2,\"1621\":1,\"1650\":1}}],[\"construct\",{\"1\":{\"1615\":1,\"1622\":1}}],[\"constructors\",{\"1\":{\"1650\":1}}],[\"constructor<\",{\"1\":{\"1650\":1}}],[\"constructorargumentsresolved\",{\"1\":{\"1650\":1}}],[\"constructorargumentlock\",{\"1\":{\"1650\":1}}],[\"constructorresolver\",{\"1\":{\"963\":2,\"1648\":2}}],[\"constructor\",{\"0\":{\"9\":1,\"1338\":1},\"1\":{\"927\":1,\"952\":1,\"954\":3,\"967\":2,\"1001\":1,\"1003\":1,\"1005\":2,\"1006\":1,\"1011\":1,\"1012\":1,\"1351\":1,\"1352\":1,\"1560\":1,\"1594\":2,\"1622\":2,\"1650\":3}}],[\"constuctor\",{\"1\":{\"1102\":1}}],[\"constant\",{\"1\":{\"519\":1,\"952\":3}}],[\"const用于比较primary\",{\"1\":{\"330\":1}}],[\"const\",{\"1\":{\"330\":4,\"390\":1,\"542\":1}}],[\"concreteness\",{\"1\":{\"1623\":1}}],[\"concrete\",{\"1\":{\"1621\":2}}],[\"concerning\",{\"1\":{\"1620\":1}}],[\"concerned\",{\"1\":{\"1619\":2}}],[\"conceptually\",{\"1\":{\"1594\":2}}],[\"concurrent或者late\",{\"1\":{\"1621\":1}}],[\"concurrentmap<k\",{\"1\":{\"1618\":1}}],[\"concurrentmodificationexception\",{\"1\":{\"1617\":2,\"1620\":3}}],[\"concurrent并不是unordered\",{\"1\":{\"1617\":1}}],[\"concurrent表示当前的收集器是并发的\",{\"1\":{\"1617\":1}}],[\"concurrently\",{\"1\":{\"1615\":3,\"1617\":2,\"1620\":2}}],[\"concurrenttaskscheduler\",{\"1\":{\"1124\":1}}],[\"concurrent\",{\"0\":{\"1753\":1},\"1\":{\"1060\":1,\"1123\":1,\"1124\":2,\"1370\":1,\"1479\":4,\"1480\":1,\"1498\":1,\"1615\":7,\"1617\":5,\"1618\":1,\"1619\":1,\"1620\":18,\"1621\":1}}],[\"concurrenthashmap键的集合就是一个并发的元\",{\"1\":{\"1620\":1}}],[\"concurrenthashmap扩容采用的是多线程的方式\",{\"1\":{\"1554\":1}}],[\"concurrenthashmap新增的核心方法有两个\",{\"1\":{\"1554\":1}}],[\"concurrenthashmap\",{\"1\":{\"1553\":5,\"1554\":12,\"1618\":1,\"1619\":1,\"1620\":1}}],[\"concurrenthashmap数据结构为一个segment数组\",{\"1\":{\"1553\":1}}],[\"concurrenthashmap的成员变量中\",{\"1\":{\"1553\":1}}],[\"concurrenthashmap的并发度是什么\",{\"0\":{\"73\":1,\"1402\":1}}],[\"concurrenthashmap源码分析\",{\"0\":{\"1552\":1}}],[\"concurrenthashmap只是在链表的头结点加锁\",{\"1\":{\"1475\":1}}],[\"concurrenthashmap在jdk1\",{\"1\":{\"1475\":1}}],[\"concurrenthashmap是基于node\",{\"1\":{\"1475\":1}}],[\"concurrenthashmap<>\",{\"1\":{\"975\":1}}],[\"concurrency的值\",{\"1\":{\"476\":1}}],[\"concurrency=128\",{\"1\":{\"476\":1}}],[\"concurrency=3表示innodb只允许3个线程并发执行\",{\"1\":{\"476\":1}}],[\"concurrency参数的原因\",{\"1\":{\"476\":1}}],[\"concurrency参数的目的是\",{\"1\":{\"476\":1}}],[\"concurrency可以设置为64～128之间的值\",{\"1\":{\"476\":1}}],[\"concurrency这个参数的默认值是0\",{\"1\":{\"476\":1}}],[\"concurrency\",{\"1\":{\"476\":1,\"481\":1,\"540\":1,\"1060\":1}}],[\"concatenate\",{\"1\":{\"1616\":1}}],[\"concatenates\",{\"1\":{\"1608\":1}}],[\"concatenating\",{\"1\":{\"1615\":1}}],[\"concat\",{\"1\":{\"419\":1,\"422\":1,\"518\":1,\"1608\":2}}],[\"contain\",{\"1\":{\"1620\":2}}],[\"contained\",{\"1\":{\"997\":1,\"1615\":1,\"1647\":1}}],[\"containers\",{\"1\":{\"1615\":1,\"1621\":1}}],[\"container的依赖注入的框架\",{\"1\":{\"914\":1}}],[\"container\",{\"1\":{\"892\":1,\"1608\":4,\"1615\":15,\"1617\":9,\"1618\":2,\"1683\":1}}],[\"containing\",{\"1\":{\"1619\":1}}],[\"containingbd\",{\"1\":{\"997\":6,\"1647\":6}}],[\"containingclass\",{\"1\":{\"963\":1,\"1100\":5,\"1102\":1}}],[\"containskey\",{\"1\":{\"1557\":1}}],[\"containslocalbean\",{\"1\":{\"1055\":1,\"1121\":1,\"1164\":4,\"1167\":1,\"1168\":1}}],[\"contains\",{\"1\":{\"1003\":1,\"1557\":1,\"1617\":4,\"1618\":3,\"1620\":1,\"1621\":1}}],[\"containssingleton\",{\"1\":{\"996\":1,\"1648\":1}}],[\"containsbean\",{\"1\":{\"963\":1,\"1056\":1,\"1164\":1,\"1165\":1,\"1171\":1,\"1648\":2}}],[\"containsbeandefinition\",{\"1\":{\"928\":1,\"967\":1,\"997\":1,\"1647\":1,\"1648\":1}}],[\"contrast\",{\"1\":{\"1619\":1}}],[\"controlled\",{\"1\":{\"1619\":1}}],[\"controller\",{\"1\":{\"1023\":1,\"1131\":1,\"1142\":1,\"1236\":1}}],[\"control\",{\"1\":{\"540\":1,\"905\":1,\"1052\":2,\"1419\":1,\"1620\":2,\"1623\":1}}],[\"contributor\",{\"1\":{\"1\":1}}],[\"contextloader\",{\"1\":{\"1658\":1}}],[\"contextloads\",{\"1\":{\"583\":1}}],[\"contexttypematchclassloader\",{\"1\":{\"1164\":1,\"1165\":1}}],[\"contextconfiguration\",{\"1\":{\"1157\":1}}],[\"contextclosedevent\",{\"1\":{\"1111\":1,\"1113\":1,\"1117\":1,\"1123\":1,\"1175\":5}}],[\"contextstoppedevent\",{\"1\":{\"1111\":1,\"1117\":1,\"1174\":2}}],[\"contextstartedevent\",{\"1\":{\"1111\":1,\"1113\":1,\"1117\":1,\"1173\":2}}],[\"contextastext\",{\"1\":{\"1091\":1}}],[\"context=\",{\"1\":{\"1065\":1}}],[\"contextresource\",{\"1\":{\"1038\":1}}],[\"contextrefreshedevent\",{\"1\":{\"1111\":1,\"1113\":2,\"1117\":1,\"1172\":2}}],[\"contextrefresh\",{\"1\":{\"922\":2,\"1647\":2,\"1651\":2}}],[\"context\",{\"1\":{\"431\":1,\"903\":1,\"917\":1,\"918\":2,\"919\":1,\"921\":1,\"922\":10,\"930\":3,\"939\":1,\"945\":6,\"953\":4,\"954\":2,\"955\":1,\"957\":6,\"961\":3,\"962\":1,\"963\":1,\"989\":7,\"997\":1,\"1000\":1,\"1001\":1,\"1005\":2,\"1006\":1,\"1011\":1,\"1023\":2,\"1028\":4,\"1029\":6,\"1030\":1,\"1031\":9,\"1032\":6,\"1039\":1,\"1041\":1,\"1050\":1,\"1051\":1,\"1054\":2,\"1055\":1,\"1058\":1,\"1059\":4,\"1060\":1,\"1065\":5,\"1084\":3,\"1091\":4,\"1111\":4,\"1112\":7,\"1113\":8,\"1116\":2,\"1118\":1,\"1119\":8,\"1120\":5,\"1121\":1,\"1122\":3,\"1123\":14,\"1125\":3,\"1128\":4,\"1134\":7,\"1138\":5,\"1139\":20,\"1143\":1,\"1146\":5,\"1147\":1,\"1148\":7,\"1149\":8,\"1153\":2,\"1154\":2,\"1155\":3,\"1156\":6,\"1162\":2,\"1164\":2,\"1167\":1,\"1169\":5,\"1171\":1,\"1172\":2,\"1174\":6,\"1175\":8,\"1181\":6,\"1182\":8,\"1184\":7,\"1632\":4,\"1633\":3,\"1634\":3,\"1635\":4,\"1637\":2,\"1647\":12,\"1651\":4,\"1652\":2,\"1658\":1}}],[\"contention\",{\"1\":{\"1480\":1}}],[\"contents\",{\"1\":{\"645\":5,\"1615\":1,\"1620\":1}}],[\"content\",{\"1\":{\"307\":3,\"1029\":1,\"1031\":1}}],[\"coming\",{\"1\":{\"1623\":2}}],[\"combining\",{\"1\":{\"1608\":2,\"1615\":3}}],[\"combineopflags\",{\"1\":{\"1621\":1,\"1622\":1}}],[\"combinedflags\",{\"1\":{\"1621\":1,\"1622\":2,\"1623\":1}}],[\"combined\",{\"1\":{\"1615\":1}}],[\"combiner方法会将一个map的key合并到另一个当中\",{\"1\":{\"1618\":1}}],[\"combiner三个对象\",{\"1\":{\"1617\":1}}],[\"combiner分别执行了一次\",{\"1\":{\"1617\":1}}],[\"combiner中返回的结果都一定是线程封闭的\",{\"1\":{\"1615\":1}}],[\"combiner或者finisher方法\",{\"1\":{\"1615\":1}}],[\"combiner做任何的事情\",{\"1\":{\"1615\":1}}],[\"combiner上一次调用的结果\",{\"1\":{\"1615\":1}}],[\"combiner函数可以将状态从一个折叠成为另一个\",{\"1\":{\"1615\":1}}],[\"combiner函数接收两个部分的结果并且合并它们\",{\"1\":{\"1615\":1}}],[\"combiner用于合并两个值\",{\"1\":{\"1608\":1}}],[\"combiner是将上一次返回的结果\",{\"1\":{\"1608\":1}}],[\"combiner\",{\"1\":{\"1608\":4,\"1615\":16,\"1616\":8,\"1617\":12,\"1618\":5}}],[\"combine\",{\"1\":{\"1043\":1,\"1615\":1,\"1617\":1}}],[\"comxchgq\",{\"1\":{\"1479\":1}}],[\"compiler\",{\"1\":{\"1594\":3}}],[\"compilers\",{\"1\":{\"1594\":2}}],[\"completetransactionafterthrowing\",{\"1\":{\"1655\":1}}],[\"complete\",{\"1\":{\"1615\":1,\"1620\":1}}],[\"completed\",{\"1\":{\"1575\":5}}],[\"completionhandler<void\",{\"1\":{\"1575\":1}}],[\"completionhandler<integer\",{\"1\":{\"1575\":3}}],[\"completionhandler<asynchronoussocketchannel\",{\"1\":{\"1575\":1}}],[\"completionstage接口\",{\"1\":{\"1518\":1}}],[\"completionservice支持自己创建线程池\",{\"1\":{\"1517\":1}}],[\"completionservice能够让异步任务的执行结果有序化\",{\"1\":{\"1517\":1}}],[\"completionservice将线程池和阻塞队列blockingqueue的功能融合在了一起\",{\"1\":{\"1517\":1}}],[\"completionservice的应用场景总结\",{\"1\":{\"1517\":1}}],[\"completionservice<integer>\",{\"1\":{\"1517\":2}}],[\"completionservice内部通过阻塞队列+futuretask\",{\"1\":{\"1517\":1}}],[\"completionservice\",{\"0\":{\"1517\":1}}],[\"completablefuture类自己也提供了anyof\",{\"1\":{\"1518\":1}}],[\"completablefuture实现了对任务的编排能力\",{\"1\":{\"1518\":1}}],[\"completablefuture实现了future接口\",{\"1\":{\"1518\":1}}],[\"completablefuture实现原理\",{\"0\":{\"1515\":1}}],[\"completablefuture是future接口的扩展和增强\",{\"1\":{\"1518\":1}}],[\"completablefuture\",{\"0\":{\"1518\":1}}],[\"computing\",{\"1\":{\"1615\":2}}],[\"computeifabsent\",{\"1\":{\"1618\":2,\"1655\":1}}],[\"computes\",{\"1\":{\"1615\":1,\"1623\":1}}],[\"compute2\",{\"1\":{\"1598\":2}}],[\"compute的function参数传递的是一种行为\",{\"1\":{\"1598\":1}}],[\"compute\",{\"1\":{\"1412\":2,\"1598\":15,\"1616\":2,\"1618\":2,\"1620\":3}}],[\"computational\",{\"1\":{\"1619\":1}}],[\"computation\",{\"1\":{\"519\":2,\"1615\":2,\"1619\":2,\"1620\":7}}],[\"compenent\",{\"1\":{\"1142\":1}}],[\"compose与docker\",{\"1\":{\"1966\":1}}],[\"compose\",{\"1\":{\"1598\":6}}],[\"composed\",{\"1\":{\"1132\":1,\"1135\":1,\"1597\":3,\"1598\":24,\"1599\":12,\"1615\":1,\"1619\":1}}],[\"compositepropertysource\",{\"1\":{\"1155\":1}}],[\"componenetscan\",{\"1\":{\"1029\":1}}],[\"componenet\",{\"1\":{\"1020\":1}}],[\"component注解的包含过滤器\",{\"1\":{\"1647\":1}}],[\"component注解的就是bean\",{\"1\":{\"1645\":1}}],[\"component注解也不会注册为bean\",{\"1\":{\"1645\":1}}],[\"component注解\",{\"1\":{\"1635\":1,\"1645\":1,\"1647\":1}}],[\"component派生\",{\"1\":{\"1134\":1}}],[\"component是一种通用的组件注解\",{\"1\":{\"1134\":1}}],[\"component的beandefinition\",{\"1\":{\"1652\":1}}],[\"component的\",{\"1\":{\"1023\":1}}],[\"component以及自定义注解扫描\",{\"1\":{\"1020\":1}}],[\"componenttype\",{\"1\":{\"963\":4}}],[\"component\",{\"1\":{\"899\":1,\"929\":2,\"1023\":1,\"1065\":2,\"1084\":1,\"1131\":1,\"1134\":3,\"1638\":1,\"1644\":1,\"1647\":1,\"1652\":1}}],[\"componentscan中\",{\"1\":{\"1136\":1}}],[\"componentscandemo\",{\"1\":{\"1134\":2}}],[\"componentscan\",{\"0\":{\"872\":1},\"1\":{\"1131\":1,\"1134\":1,\"1135\":1,\"1136\":5,\"1645\":4,\"1652\":1}}],[\"compatible\",{\"1\":{\"1608\":2}}],[\"compact\",{\"1\":{\"1439\":1}}],[\"company\",{\"1\":{\"1072\":7}}],[\"comparingint\",{\"1\":{\"1614\":11,\"1616\":3}}],[\"comparing\",{\"1\":{\"1601\":2,\"1614\":1}}],[\"comparable<\",{\"1\":{\"1506\":2}}],[\"comparable<string>\",{\"1\":{\"1100\":1}}],[\"comparable\",{\"1\":{\"1100\":1}}],[\"comparator并不是jdk8新增加的内容\",{\"1\":{\"1614\":1}}],[\"comparator源码分析及实践\",{\"0\":{\"1614\":1}}],[\"comparator<method>\",{\"1\":{\"1654\":2}}],[\"comparator<t>\",{\"1\":{\"1603\":1,\"1614\":5}}],[\"comparator<\",{\"1\":{\"1601\":2,\"1603\":1,\"1614\":1,\"1620\":1}}],[\"comparator<string>\",{\"1\":{\"1043\":1,\"1601\":1,\"1614\":2}}],[\"comparator<object>\",{\"1\":{\"963\":2}}],[\"comparator\",{\"1\":{\"963\":6,\"1601\":19,\"1603\":1,\"1611\":1,\"1614\":16,\"1616\":3,\"1620\":2}}],[\"comparebyname\",{\"1\":{\"1605\":2}}],[\"comparebyscore\",{\"1\":{\"1605\":1}}],[\"comparestudentbyname\",{\"1\":{\"1603\":1,\"1604\":2,\"1605\":1}}],[\"comparestudentbyscore与comparestudentbyname方法实际上是我们有意为之的\",{\"1\":{\"1605\":1}}],[\"comparestudentbyscore\",{\"1\":{\"1603\":4,\"1604\":3,\"1605\":1}}],[\"comparetoignorecase\",{\"1\":{\"1603\":1,\"1604\":1,\"1605\":4,\"1614\":1}}],[\"compareto\",{\"1\":{\"1506\":1}}],[\"compareandswaplong\",{\"1\":{\"1554\":2}}],[\"compareandswapint的返回值\",{\"1\":{\"1479\":1}}],[\"compareandswapint\",{\"1\":{\"1479\":3,\"1554\":3}}],[\"compareandsetstate\",{\"1\":{\"1490\":1}}],[\"compareandset\",{\"1\":{\"1175\":1,\"1479\":3}}],[\"compare\",{\"1\":{\"557\":1,\"1479\":5,\"1599\":2,\"1601\":2,\"1603\":1,\"1614\":6}}],[\"communicated\",{\"1\":{\"1647\":1}}],[\"commences\",{\"1\":{\"1621\":1}}],[\"commenced\",{\"1\":{\"1620\":3}}],[\"comment=\",{\"1\":{\"510\":1,\"518\":1}}],[\"comments\",{\"1\":{\"361\":4}}],[\"comment\",{\"1\":{\"361\":8,\"362\":6,\"363\":3,\"454\":1,\"510\":4,\"518\":4,\"553\":2}}],[\"commas\",{\"1\":{\"1616\":1}}],[\"commandlinepropertysource\",{\"1\":{\"1154\":1}}],[\"command\",{\"1\":{\"322\":1,\"580\":1,\"1476\":8,\"1987\":1}}],[\"common目录中\",{\"1\":{\"1693\":1}}],[\"commonpool\",{\"1\":{\"1518\":1,\"1617\":27}}],[\"commonannotationbeanpostprocessor会在autowiredannotationbeanpostprocessor之前进行处理\",{\"1\":{\"966\":1}}],[\"commonannotationbeanpostprocessor实现了initdestroyannotationbeanpostprocessor接口\",{\"1\":{\"966\":1}}],[\"commonannotationbeanpostprocessor和autowiredannotationbeanpostprocessor大概的实现逻辑是如出一辙的\",{\"1\":{\"966\":1}}],[\"commonannotationbeanpostprocessor\",{\"1\":{\"966\":3,\"1007\":1,\"1011\":1}}],[\"commonannotationbeanpostprocessor对象\",{\"1\":{\"945\":1}}],[\"common\",{\"1\":{\"922\":1,\"1110\":1,\"1615\":1,\"1616\":1,\"1647\":1,\"1651\":1}}],[\"committransactionafterreturning\",{\"1\":{\"1655\":1}}],[\"committed\",{\"1\":{\"433\":2,\"532\":1}}],[\"commited\",{\"1\":{\"1238\":1,\"1262\":1}}],[\"commit都设置成1\",{\"1\":{\"451\":1}}],[\"commit设置成0\",{\"1\":{\"451\":1}}],[\"commit设置成1\",{\"1\":{\"451\":1}}],[\"commit设置为2\",{\"1\":{\"451\":1}}],[\"commit设置的是1\",{\"1\":{\"451\":1}}],[\"commit参数\",{\"1\":{\"451\":1}}],[\"commit\",{\"1\":{\"326\":1,\"368\":3,\"451\":9,\"464\":2,\"465\":3,\"468\":1,\"485\":1,\"561\":1,\"1617\":1,\"1655\":3}}],[\"com\",{\"1\":{\"5\":1,\"308\":1,\"312\":1,\"350\":3,\"351\":2,\"517\":2,\"531\":1,\"540\":1,\"573\":3,\"635\":1,\"639\":2,\"645\":1,\"1201\":2,\"1356\":1,\"1479\":1,\"1494\":1,\"1499\":1,\"1551\":1,\"1591\":1,\"1626\":1,\"1627\":1,\"1635\":1,\"1645\":2,\"1646\":1,\"1652\":1,\"1653\":1,\"1657\":1,\"1663\":1,\"1969\":3,\"1972\":2,\"1974\":2,\"1975\":3,\"1978\":1,\"1980\":1,\"1981\":3,\"1982\":1,\"1983\":1,\"1985\":2,\"1986\":1,\"1987\":3,\"1989\":1,\"1990\":1,\"1991\":1,\"1992\":2}}],[\"c++内存管理\",{\"1\":{\"1966\":1}}],[\"c++面向对象编程\",{\"1\":{\"1966\":1}}],[\"c++\",{\"1\":{\"3\":1,\"1483\":1,\"1966\":2,\"1969\":1}}],[\"掘金\",{\"1\":{\"2\":1}}],[\"社区论坛项目\",{\"1\":{\"1987\":1}}],[\"社区\",{\"0\":{\"2\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
