const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:n})=>n),bt=et(V(JSON.parse("{\"/\":{\"documentCount\":1873,\"nextId\":1873,\"documentIds\":{\"0\":\"1\",\"1\":\"1#pages\",\"2\":\"1#content\",\"3\":\"1#configuration\",\"4\":\"1#layouts-and-customization\",\"5\":\"2\",\"6\":\"2#开源项目\",\"7\":\"2#社区\",\"8\":\"2#技能点\",\"9\":\"2#个人经历\",\"10\":\"2#联系我\",\"11\":\"3\",\"12\":\"3#java基础\",\"13\":\"3#jvm、jdk-和-jre-联系与区别\",\"14\":\"3#构造器-constructor-是否可被-override\",\"15\":\"3#重载和重写的区别\",\"16\":\"3#面向对象编程三大特性-封装-继承-多态\",\"17\":\"3#string-stringbuffer-和-stringbuilder-的区别是什么\",\"18\":\"3#string类为什么是不可变的\",\"19\":\"3#integer的缓存机制\",\"20\":\"3#深拷贝和浅拷贝的区别\",\"21\":\"3#接口和抽象类的区别\",\"22\":\"3#构造方法有哪些特性\",\"23\":\"3#string中hashcode的实现\",\"24\":\"3#hashcode和equals的作用\",\"25\":\"3#jdk8有哪些新特性\",\"26\":\"3#java反射有哪些作用\",\"27\":\"3#如何使用反射获取私有属性\",\"28\":\"3#创建对象有哪些方式\",\"29\":\"3#迭代器和for循环遍历的区别\",\"30\":\"3#过滤器和拦截器的区别\",\"31\":\"3#java集合\",\"32\":\"3#list、set、map三者的区别\",\"33\":\"3#hashmap实现原理\",\"34\":\"3#hashmap为什么扩容为2倍\",\"35\":\"3#为什么hashmap不用linkedlist-而是选用数组\",\"36\":\"3#jdk1-8对hashmap有哪些优化\",\"37\":\"3#为什么不直接使用红黑树-而是选择先用链表-再转红黑树\",\"38\":\"3#hashmap不使用红黑树-而是使用二叉查找树可以吗\",\"39\":\"3#为什么阈值是8\",\"40\":\"3#当链表转为红黑树-什么时候退化为链表\",\"41\":\"3#hashmap在并发编程环境下有什么问题\",\"42\":\"3#使用可变类当hashmap的key有什么问题\",\"43\":\"3#如何实现一个自定义的class作为hashmap的key\",\"44\":\"3#两个相同对象没有重写equals方法放到hashmap覆盖吗\",\"45\":\"3#hashset实现原理\",\"46\":\"3#currenthashmap的实现原理\",\"47\":\"3#arraylist的实现原理\",\"48\":\"3#java并发\",\"49\":\"3#并发编程的三要素\",\"50\":\"3#线程和进程的区别\",\"51\":\"3#守护线程和用户线程的区别\",\"52\":\"3#什么是线程安全\",\"53\":\"3#java如何开启线程-怎么保证线程安全\",\"54\":\"3#线程有哪些状态\",\"55\":\"3#如何停止一个正在运行的线程\",\"56\":\"3#notify和notifyall有什么区别\",\"57\":\"3#wait和sleep方法有什么区别\",\"58\":\"3#为什么wait和notify方法要在同步块中调用\",\"59\":\"3#thread类中的yield方法有什么作用\",\"60\":\"3#volatile和synchronized有什么区别\",\"61\":\"3#volatile变量和atomic变量什么不同\",\"62\":\"3#interrupted和isinterrupted方法的区别\",\"63\":\"3#volatile能不能保证线程安全\",\"64\":\"3#dcl单例为什么加volatile\",\"65\":\"3#死锁与活锁的区别\",\"66\":\"3#死锁与饥饿的区别\",\"67\":\"3#按照线程安全的强度来区分-分为哪几类\",\"68\":\"3#线程安全的实现方法有哪些\",\"69\":\"3#锁优化技术你了解什么\",\"70\":\"3#lock与synchronized有什么区别\",\"71\":\"3#什么是阻塞队列-阻塞队列的实现原理是什么\",\"72\":\"3#什么是callable和future\",\"73\":\"3#java线程锁机制是怎样的-偏向锁、轻量级锁、重量级锁有什么区别-锁机制是如何升级的\",\"74\":\"3#什么是可重入锁-有哪些实现\",\"75\":\"3#什么是悲观锁-什么是乐观锁\",\"76\":\"3#谈谈你对aqs的理解-aqs如何实现可重入锁\",\"77\":\"3#synchronizedmap和concurrenthashmap有什么区别\",\"78\":\"3#concurrenthashmap的并发度是什么\",\"79\":\"3#copyonwritearraylist可以用于什么应用场景\",\"80\":\"3#有a、b、c三个线程-如何保证三个线程同时执行-如何在并发情况下保证三个线程依次执行-如何保证三个线程有序交错进行\",\"81\":\"3#什么是指令重排序\",\"82\":\"3#threadlocal的作用-导致内存泄漏的原因是什么\",\"83\":\"3#使用线程池有什么好处\",\"84\":\"3#线程池中submit-和execute-方法有什么区别\",\"85\":\"3#什么是executors框架\",\"86\":\"3#线程池的拒绝策略\",\"87\":\"3#如何获取子线程的执行结果\",\"88\":\"3#如何对一个字符串快速进行排序\",\"89\":\"3#线程池的参数如何设置\",\"90\":\"3#子线程中如何获取父线程的-threadlocal-中的值、threadlocal-的数据结构\",\"91\":\"3#高并发下-如何保证接口的幂等性\",\"92\":\"3#除了lock和synchronized-还有什么方式可以保障线程安全\",\"93\":\"3#java网络通信\",\"94\":\"3#tcp和udp有什么区别\",\"95\":\"3#tcp为什么是三次握手-而不是两次\",\"96\":\"3#java有哪几种io模型-有什么区别\",\"97\":\"3#java-nio的几个核心组件是什么-分别有什么作用\",\"98\":\"3#select、poll、epoll有什么区别\",\"99\":\"3#http和https的区别\",\"100\":\"3#三次握手和四次挥手\",\"101\":\"3#java虚拟机\",\"102\":\"3#运行时数据区中包含哪些区域-哪些线程共享-哪些线程独享\",\"103\":\"3#java-创建一个对象的过程\",\"104\":\"3#如何访问对象\",\"105\":\"3#java-内存模型的原子性、可见性和有序性是通过哪些操作实现的\",\"106\":\"3#什么是双亲委派机制-有什么作用\",\"107\":\"3#java类加载的全过程是怎么样的\",\"108\":\"3#你了解分代理论吗\",\"109\":\"3#jdk-中有几种引用类型-分别的特点是什么\",\"110\":\"3#一个对象从加载到jvm-再到gc清除-都经历了什么过程\",\"111\":\"3#怎么样确定一个对象不是垃圾\",\"112\":\"3#什么是gc-root\",\"113\":\"3#jvm有哪些垃圾回收算法\",\"114\":\"3#什么是stw\",\"115\":\"3#jvm有哪些垃圾回收器\",\"116\":\"3#什么是三色标记算法\",\"117\":\"3#如何回收方法区\",\"118\":\"3#jvm-中的安全点和安全区各代表什么\",\"119\":\"3#写屏障你了解吗\",\"120\":\"3#解决并发扫描时对象消失问题的两种方案\",\"121\":\"3#cms-垃圾收集器的步骤\",\"122\":\"3#cms-有什么缺点\",\"123\":\"3#g1垃圾收集器的步骤-g1有什么优缺点\",\"124\":\"3#讲一下内存分配策略\",\"125\":\"3#内存溢出和内存泄漏的区别\",\"126\":\"3#如何进行jvm调优\",\"127\":\"3#jvm参数有哪些\",\"128\":\"3#虚拟机基础故障处理工具有哪些\",\"129\":\"3#怎么查看一个java进程的jvm参数-谈谈你了解的jvm参数\",\"130\":\"3#什么情况下堆内存会溢出-什么情况方法区会内存溢出\",\"131\":\"3#jdk8-为什么要将永久代改为元空间\",\"132\":\"3#redis\",\"133\":\"3#redis支持哪些数据类型\",\"134\":\"3#什么是缓存穿透-缓存击穿-缓存雪崩-怎么解决\",\"135\":\"3#缓存穿透\",\"136\":\"3#缓存击穿\",\"137\":\"3#缓存雪崩\",\"138\":\"3#如何保证redis与数据库的数据一致\",\"139\":\"3#先删缓存-再写数据库\",\"140\":\"3#先写数据库-再删缓存\",\"141\":\"3#如何设计一个分布式锁-如何对锁性能进行优化\",\"142\":\"3#redis的过期删除策略\",\"143\":\"3#rdb操作-子进程会全部复制父进程的数据吗\",\"144\":\"3#redis的哨兵模式\",\"145\":\"3#redis使用单线程为什么速度这么快\",\"146\":\"3#redis自增命令使用\",\"147\":\"3#redis如何实现消息队列\",\"148\":\"3#redisson实现分布式锁的原理\",\"149\":\"3#redis为什么能通过lua脚本保证并发的线程安全\",\"150\":\"3#谈一下redis事务的了解\",\"151\":\"3#pipeline有什么好处-为什么要用pipeline\",\"152\":\"3#redis延迟队列怎么实现的\",\"153\":\"3#redis在内存不足时-内存淘汰策略是怎么样的\",\"154\":\"3#如何保证redis的高可用\",\"155\":\"3#mysql\",\"156\":\"3#mysql有哪几种数据存储引擎\",\"157\":\"3#什么是脏读、不可重复读、幻读\",\"158\":\"3#事务的基本特性和隔离级别\",\"159\":\"3#mysql的锁有哪些-什么是间隙锁\",\"160\":\"3#mysql索引结构是什么样的\",\"161\":\"3#mysql的索引结构为什么使用b-树\",\"162\":\"3#聚簇索引和非聚簇索引有什么区别\",\"163\":\"3#mysql主键索引和普通索引有什么区别\",\"164\":\"3#mysql的索引覆盖和回表是什么\",\"165\":\"3#mysql集群是如何搭建的-读写分离是怎么做的\",\"166\":\"3#mysql如何进行分库分表-多大数据量需要进行分库分表-分库分表的方式和分片策略由哪些-分库分表后-sql语句执行流程是怎样的\",\"167\":\"3#mysql的三种删除方式的区别\",\"168\":\"3#慢sql的优化思路\",\"169\":\"3#limit语句会扫描全表吗\",\"170\":\"3#大数量分页查询该怎么优化\",\"171\":\"3#平时项目里面表结构是如何进行设计的\",\"172\":\"3#mysql的索引类型\",\"173\":\"3#mysql如何快速插入千万级数据\",\"174\":\"3#elasticsearch\",\"175\":\"3#什么是倒排索引-有什么好处\",\"176\":\"3#搜索引擎为什么mysql查询快\",\"177\":\"3#es了解多少-说说你们公司的es集群架构。\",\"178\":\"3#如何进行中文分词\",\"179\":\"3#es写入数据与查询数据的原理。\",\"180\":\"3#es部署时-要如何进行优化\",\"181\":\"3#spring面试题\",\"182\":\"3#spring框架中bean的创建过程是怎样的\",\"183\":\"3#spring中bean的作用域\",\"184\":\"3#spring框架中的bean是线程安全的吗-如果线程不安全-如何处理\",\"185\":\"3#spring是如何处理循环依赖问题的\",\"186\":\"3#spring如何处理事务\",\"187\":\"3#spring事务失效的场景有哪些\",\"188\":\"3#spring-mvc中的控制器是不是单例模式-如果是-如何保证线程安全\",\"189\":\"3#spring-mvc原理\",\"190\":\"3#spring中的service有多个实现类-怎么注入\",\"191\":\"3#springboot面试题\",\"192\":\"3#为什么springboot的-jar可以直接运行\",\"193\":\"3#springboot自动装配过程及实现原理\",\"194\":\"3#springboot如何防止表单重复提交\",\"195\":\"3#如何自己写一个springboot-starter\",\"196\":\"3#mybatis面试题\",\"197\":\"3#mybatis接口-mapper内的方法为什么不能重载\",\"198\":\"3#mybatis的xml映射文件中-不同的xml映射文件-id是否可以重复\",\"199\":\"3#和-的区别是什么\",\"200\":\"3#当实体类中的属性名和表中的字段名不一样怎么办\",\"201\":\"3#执行插入语句后如何该数据的主键\",\"202\":\"3#模糊查询like语句该怎么写\",\"203\":\"3#mybatis时如何进行分页的-分页插件的原理是什么\",\"204\":\"3#mybatis有哪些动态sql标签\",\"205\":\"3#mybtais动态sql有什么用-执行原理是什么\",\"206\":\"3#mapper编写有哪几种方式\",\"207\":\"3#mybatis的一级、二级缓存\",\"208\":\"3#mybatis有二级缓存-为什么还要用redis\",\"209\":\"3#mybatis如何开启二级缓存\",\"210\":\"3#netty面试题\",\"211\":\"3#netty有哪些应用场景\",\"212\":\"3#netty核心组件有哪些-分别有什么作用\",\"213\":\"3#eventloopgroup了解么-和eventloop什么关系\",\"214\":\"3#bootstrap和serverbootstrap了解么\",\"215\":\"3#nioeventloopgroup默认的构造函数会起多少线程\",\"216\":\"3#netty线程模型了解么\",\"217\":\"3#netty服务端和客户端的启动过程了解么\",\"218\":\"3#netty长连接、心跳机制了解么\",\"219\":\"3#netty的零拷贝了解么\",\"220\":\"3#spring-sercuity\",\"221\":\"3#spring-sercuity-和-shiro有什么区别\",\"222\":\"3#网络安全\",\"223\":\"3#什么是认证和授权-如何设计一个权限认证框架\",\"224\":\"3#cookie和session有什么区别-如果没有cookie、seesion还能进行身份验证吗\",\"225\":\"3#什么是csrf攻击-如何防止\",\"226\":\"3#什么是oauth2-有哪几种认证方式\",\"227\":\"3#什么是jwt令牌-和普通令牌有什么区别\",\"228\":\"3#什么是sso-与oauth2-0有什么关系\",\"229\":\"3#如何实现单点登录系统\",\"230\":\"3#微服务\",\"231\":\"3#谈谈你对微服务的理解-微服务有哪些优缺点\",\"232\":\"3#springcloud和springcloudalibaba有哪些组件-都解决了什么问题\",\"233\":\"3#springcloud和dubbo的区别\",\"234\":\"3#分布式事务如何处理-怎么保证事务一致性\",\"235\":\"3#怎么拆分微服务-怎样设计出高内聚、低耦合的微服务\",\"236\":\"3#有没有了解通过ddd领域驱动设计\",\"237\":\"3#微服务的链路追踪、持续集成、ab发布要怎么做\",\"238\":\"3#nacos和eureka的区别\",\"239\":\"3#nacos配置中心-本地resource-jar包中同级目录的配置文件加载优先级\",\"240\":\"3#nacos的配置动态更新原理\",\"241\":\"3#使用nacos配置中心-value对应的配置项如何动态更新\",\"242\":\"3#nacos中命名空间和分组的概念及区别\",\"243\":\"3#nacos同一个namespace中的不同的group注册的服务可以相互访问吗\",\"244\":\"3#nacos服务注册的流程是怎么样的\",\"245\":\"3#微服务下服务a调用服务b的流程\",\"246\":\"3#注册中心-如何通过服务名找到服务实例\",\"247\":\"3#熔断和限流有什么区别\",\"248\":\"3#雪花算法有什么缺点\",\"249\":\"3#gateway有哪些功能-如何配置动态路由\",\"250\":\"3#如何手写一个注册中心\",\"251\":\"3#消息队列\",\"252\":\"3#mq有什么用-有哪些具体的使用场景\",\"253\":\"3#如何进行产品选型\",\"254\":\"3#如何保证消息不丢失\",\"255\":\"3#如何保证消费幂等性\",\"256\":\"3#mq如何保证消息顺序\",\"257\":\"3#如何保证消息的高效读写\",\"258\":\"3#mq-中消费时-业务逻辑出现异常怎么办\",\"259\":\"3#使用mq如何保证分布式事务的最终一致性\",\"260\":\"3#kafka如何避免重复消费\",\"261\":\"3#linux命令\",\"262\":\"3#使用cat命令如何统计文件中一个字符串出现的频率\",\"263\":\"3#如何查看一个应用的信息\",\"264\":\"3#dokcer命令\",\"265\":\"3#docker常用的命令\",\"266\":\"3#查看所有容器的命令\",\"267\":\"3#nginx\",\"268\":\"3#nginx如何保证高可用\",\"269\":\"3#设计模式\",\"270\":\"3#列举一些jdk中用到的设计模式\",\"271\":\"3#列举一些spring当中用到的设计模式\",\"272\":\"3#项目中有用过设计模式吗\",\"273\":\"3#单例模式有哪些实现方式\",\"274\":\"3#懒汉式\",\"275\":\"3#饿汉式\",\"276\":\"3#双重检查锁\",\"277\":\"3#静态内部类\",\"278\":\"3#枚举类\",\"279\":\"3#单例模式有什么应用场景\",\"280\":\"4\",\"281\":\"5\",\"282\":\"6\",\"283\":\"6#递归\",\"284\":\"6#定义\",\"285\":\"6#代码模板\",\"286\":\"6#分治\",\"287\":\"6#定义-1\",\"288\":\"6#代码模板-1\",\"289\":\"6#回溯\",\"290\":\"6#定义-2\",\"291\":\"6#代码模板-2\",\"292\":\"6#贪心算法\",\"293\":\"6#定义-3\",\"294\":\"6#深度优先搜索\",\"295\":\"6#定义-4\",\"296\":\"6#代码模板-3\",\"297\":\"6#广度优先搜索\",\"298\":\"6#定义-5\",\"299\":\"6#代码模板-4\",\"300\":\"6#字典树\",\"301\":\"6#定义-6\",\"302\":\"6#代码模板-5\",\"303\":\"6#二分查找\",\"304\":\"6#定义-7\",\"305\":\"6#代码模板-6\",\"306\":\"6#布隆过滤器\",\"307\":\"6#定义-8\",\"308\":\"6#代码模板-7\",\"309\":\"6#lru-cache\",\"310\":\"6#定义-9\",\"311\":\"6#代码模板-8\",\"312\":\"6#位运算\",\"313\":\"6#定义-10\",\"314\":\"6#性质\",\"315\":\"6#实战技巧\",\"316\":\"6#排序算法\",\"317\":\"6#冒泡排序\",\"318\":\"6#选择排序\",\"319\":\"6#插入排序\",\"320\":\"6#希尔排序\",\"321\":\"6#堆排序\",\"322\":\"6#归并排序\",\"323\":\"6#快速排序\",\"324\":\"6#动态规划\",\"325\":\"6#定义-11\",\"326\":\"6#代码模板-9\",\"327\":\"6#股票问题\",\"328\":\"7\",\"329\":\"7#数组\",\"330\":\"7#链表\",\"331\":\"7#跳表\",\"332\":\"7#哈希表\",\"333\":\"7#栈\",\"334\":\"7#队列\",\"335\":\"7#双端队列\",\"336\":\"7#树\",\"337\":\"7#总体介绍\",\"338\":\"7#代码模板\",\"339\":\"7#二叉树\",\"340\":\"7#二叉搜索树\",\"341\":\"7#平衡二叉树\",\"342\":\"7#红黑树\",\"343\":\"7#定义和性质\",\"344\":\"7#红黑树的查找\",\"345\":\"7#红黑树的插入\",\"346\":\"7#多路查找树\",\"347\":\"7#_2-3树\",\"348\":\"7#_2-3-4树\",\"349\":\"7#b树\",\"350\":\"7#b-树\",\"351\":\"7#堆\",\"352\":\"7#优先队列\",\"353\":\"7#总体介绍-1\",\"354\":\"7#方法剖析\",\"355\":\"7#图\",\"356\":\"7#拓扑排序\",\"357\":\"8\",\"358\":\"8#数组\",\"359\":\"8#_1-两数之和\",\"360\":\"8#_704-二分查找\",\"361\":\"8#_27-移除元素\",\"362\":\"8#_977-有序数组的平方\",\"363\":\"8#_209-长度最小的子数组\",\"364\":\"8#_59-螺旋矩阵ii\",\"365\":\"8#_283-移动零\",\"366\":\"8#_15-三数之和\",\"367\":\"8#_84-柱状图中最大的矩形\",\"368\":\"8#_11-盛最多水的容器\",\"369\":\"8#数组题目总结\",\"370\":\"8#链表\",\"371\":\"8#_203-移除链表元素\",\"372\":\"8#_206-反转链表\",\"373\":\"8#_141-环形链表\",\"374\":\"8#_24-两两交换链表中的节点\",\"375\":\"8#_19-删除链表的倒数第n个节点\",\"376\":\"8#_160-链表相交\",\"377\":\"8#_142-环形链表ii\",\"378\":\"8#链表总结\",\"379\":\"8#哈希表\",\"380\":\"8#_49-字母异位词分组\",\"381\":\"8#_136-只出现一次的数字\",\"382\":\"8#字符串\",\"383\":\"8#_344-反转字符串\",\"384\":\"8#_541-反转字符串ii\",\"385\":\"8#_151-翻转字符串里的单词\",\"386\":\"8#_20-有效的括号\",\"387\":\"8#_242-有效的字母异位词\",\"388\":\"8#剑指-offer-67-把字符串转换成整数\",\"389\":\"8#_459-重复的子字符串\",\"390\":\"8#字符串总结\",\"391\":\"8#栈与队列\",\"392\":\"8#_155-最小栈\",\"393\":\"8#_239-滑动窗口最大值\",\"394\":\"8#树\",\"395\":\"8#_94-二叉树的中序遍历\",\"396\":\"8#_104-二叉树的最大深度\",\"397\":\"8#_98-验证二叉搜索树\",\"398\":\"8#_236-二叉树的最近公共祖先\",\"399\":\"8#_78-子集\",\"400\":\"8#_17-电话号码的字母组合\",\"401\":\"8#_102-二叉树的层序遍历\",\"402\":\"8#_107-二叉树的层次遍历-ii\",\"403\":\"8#_199-二叉树的右视图\",\"404\":\"8#_515-在每个树行中找最大值\",\"405\":\"8#_226-翻转二叉树\",\"406\":\"8#_101-对称二叉树\",\"407\":\"8#_222-完全二叉树的节点个数\",\"408\":\"8#_110-平衡二叉树\",\"409\":\"8#_257-二叉树的所有路径\",\"410\":\"8#_404-左叶子之和\",\"411\":\"8#_513-找树左下角的值\",\"412\":\"8#_112-路径总和\",\"413\":\"8#树总结\",\"414\":\"8#回溯算法\",\"415\":\"8#_22-括号生成\",\"416\":\"8#_212-单词搜索-ii\",\"417\":\"8#_51-n-皇后\",\"418\":\"8#贪心算法\",\"419\":\"8#_121-买卖股票的最佳时机\",\"420\":\"8#_322-零钱兑换\",\"421\":\"8#_55-跳跃游戏\",\"422\":\"8#_455-分发饼干\",\"423\":\"8#动态规划\",\"424\":\"8#_70-爬楼梯\",\"425\":\"8#_62-不同路径\",\"426\":\"8#_120-三角形最小路径和\",\"427\":\"8#_1143-最长公共子序列\",\"428\":\"8#_5-最长回文子串\",\"429\":\"8#_509-斐波那契数\",\"430\":\"8#_53-最大子序和\",\"431\":\"8#_198-打家劫舍\",\"432\":\"8#_213-打家劫舍-ii\",\"433\":\"8#_409-最长回文串\",\"434\":\"8#图论\",\"435\":\"8#_200-岛屿数量\",\"436\":\"8#数学\",\"437\":\"8#_136-只出现一次的数字-1\",\"438\":\"8#_50-pow-x-n\",\"439\":\"8#_69-x-的平方根\",\"440\":\"8#_367-有效的完全平方数\",\"441\":\"8#_414-第三大的数\",\"442\":\"8#矩阵\",\"443\":\"8#_74-搜索二维矩阵\",\"444\":\"9\",\"445\":\"9#elaticsearch快速入门\",\"446\":\"9#elaticsearch高级查询语法query-dsl\",\"447\":\"9#elaticsearch搜索技术与聚合查询\",\"448\":\"9#elaticsearch高阶功能\",\"449\":\"9#elaticsearch集群架构实战及其原理\",\"450\":\"9#logstash与filebeat详解以及efk整合\",\"451\":\"10\",\"452\":\"10#mongodb入门\",\"453\":\"11\",\"454\":\"11#mysql逻辑架构\",\"455\":\"11#连接器\",\"456\":\"11#查询缓存\",\"457\":\"11#分析器\",\"458\":\"11#优化器\",\"459\":\"11#执行器\",\"460\":\"11#sql执行流程\",\"461\":\"11#重做日志\",\"462\":\"11#归档日志\",\"463\":\"11#更新语句执行流程\",\"464\":\"11#两阶段提交\",\"465\":\"11#mysql性能分析工具\",\"466\":\"11#explain-简介\",\"467\":\"11#explain-字段\",\"468\":\"11#索引常见模型\",\"469\":\"11#哈希表\",\"470\":\"11#有序数组\",\"471\":\"11#二叉搜索树\",\"472\":\"11#b-树\",\"473\":\"11#索引的执行流程\",\"474\":\"11#回表\",\"475\":\"11#覆盖索引\",\"476\":\"11#最左前缀原则\",\"477\":\"11#索引下推\",\"478\":\"11#普通索引和唯一索引\",\"479\":\"11#查询过程\",\"480\":\"11#更新过程\",\"481\":\"11#change-buffer详解\",\"482\":\"11#change-buffer和redo-log\",\"483\":\"11#索引的选择\",\"484\":\"11#优化器逻辑\",\"485\":\"11#索引选择异常和处理\",\"486\":\"11#字符串添加索引\",\"487\":\"11#前缀索引\",\"488\":\"11#前缀索引与覆盖索引\",\"489\":\"11#其它方式\",\"490\":\"11#order-by与索引\",\"491\":\"11#全字段排序\",\"492\":\"11#rowid排序\",\"493\":\"11#全字段排序和rowid排序对比\",\"494\":\"11#索引的创建时机\",\"495\":\"11#哪些情况需要建索引\",\"496\":\"11#那些情况不要建索引\",\"497\":\"11#索引的最佳实践\",\"498\":\"11#单表索引分析\",\"499\":\"11#两表索引分析\",\"500\":\"11#三张表索引分析\",\"501\":\"11#结论\",\"502\":\"11#索引失效\",\"503\":\"11#函数操作\",\"504\":\"11#隐式类型转换\",\"505\":\"11#隐式字符编码转换\",\"506\":\"11#索引失效的场景\",\"507\":\"11#最佳左前缀法则\",\"508\":\"11#索引列上不计算\",\"509\":\"11#范围之后全失效\",\"510\":\"11#覆盖索引尽量用\",\"511\":\"11#不等有时会失效\",\"512\":\"11#like百分加右边\",\"513\":\"11#字符要加单引号\",\"514\":\"11#索引相关题目\",\"515\":\"11#面试题分析\",\"516\":\"11#索引失效的原理分析\",\"517\":\"11#索引失效的总结\",\"518\":\"11#慢查询基础\",\"519\":\"11#请求多余的数据\",\"520\":\"11#查询不需要的记录\",\"521\":\"11#多表关联时返回全部列\",\"522\":\"11#总是取出全部列\",\"523\":\"11#重复查询相同的数据\",\"524\":\"11#扫描额外的记录\",\"525\":\"11#响应时间\",\"526\":\"11#扫描的行数和返回的行数\",\"527\":\"11#扫描的行数和访问类型\",\"528\":\"11#重构查询\",\"529\":\"11#复杂查询-or-简单查询\",\"530\":\"11#切分查询\",\"531\":\"11#分解关联查询\",\"532\":\"11#count-优化\",\"533\":\"11#count-的实现\",\"534\":\"11#使用缓存系统保存计数\",\"535\":\"11#在数据库中保存计数\",\"536\":\"11#不同count的用法\",\"537\":\"11#join语句的优化\",\"538\":\"11#index-nested-loop-join\",\"539\":\"11#simple-nested-loop-join\",\"540\":\"11#block-nested-loop-join\",\"541\":\"11#multi-range-read-优化\",\"542\":\"11#batched-key-access\",\"543\":\"11#bnl算法的性能问题\",\"544\":\"11#bnl转bka\",\"545\":\"11#hash-join\",\"546\":\"11#mysql中的临时表\",\"547\":\"11#临时表的特性\",\"548\":\"11#临时表的应用\",\"549\":\"11#重命名临时表\",\"550\":\"11#临时表和主备复制\",\"551\":\"11#使用临时表优化查询\",\"552\":\"11#group-by语句的优化\",\"553\":\"11#group-by执行流程\",\"554\":\"11#使用索引优化group-by语句\",\"555\":\"11#直接排序优化group-by语句\",\"556\":\"11#order-by-rand-优化\",\"557\":\"11#内存临时表\",\"558\":\"11#磁盘临时表\",\"559\":\"11#随机排序法\",\"560\":\"11#分区表\",\"561\":\"11#分区表简介\",\"562\":\"11#分区策略\",\"563\":\"11#分区表的应用场景\",\"564\":\"11#慢查询日志\",\"565\":\"11#基本介绍\",\"566\":\"11#日志分析工具\",\"567\":\"11#分析慢sql的步骤\",\"568\":\"11#show-profile\",\"569\":\"11#事务隔离\",\"570\":\"11#隔离性和隔离级别\",\"571\":\"11#事务隔离的实现\",\"572\":\"11#事务的启动方式\",\"573\":\"11#全局锁\",\"574\":\"11#全局锁的特点\",\"575\":\"11#全局锁对比\",\"576\":\"11#表级别的锁\",\"577\":\"11#表锁\",\"578\":\"11#元数据锁\",\"579\":\"11#行锁\",\"580\":\"11#两阶段锁\",\"581\":\"11#死锁和死锁检测\",\"582\":\"11#间隙锁\",\"583\":\"11#幻读\",\"584\":\"11#幻读的问题\",\"585\":\"11#间隙锁-1\",\"586\":\"11#防止数据丢失\",\"587\":\"11#bin-log的写入机制\",\"588\":\"11#redo-log的写入机制\",\"589\":\"11#主备一致\",\"590\":\"11#主备的基本原理\",\"591\":\"11#bin-log的三种格式\",\"592\":\"11#循环复制问题\",\"593\":\"11#主备延迟\",\"594\":\"11#主备延迟及其来源\",\"595\":\"11#可靠性优先策略\",\"596\":\"11#可用性优先策略\",\"597\":\"11#并行复制\",\"598\":\"11#按表分发策略\",\"599\":\"11#按行分发策略\",\"600\":\"11#mysql-5-7的并行复制策略\",\"601\":\"11#mariadb的并行复制策略\",\"602\":\"11#mysql-5-7的并行复制策略-1\",\"603\":\"11#一主多从\",\"604\":\"11#基于位点的主备切换\",\"605\":\"11#gtid\",\"606\":\"11#读写分离\",\"607\":\"11#强制走主库方案\",\"608\":\"11#sleep-方案\",\"609\":\"11#判断主备无延迟方案\",\"610\":\"11#等主库位点方案\",\"611\":\"11#gid方案\",\"612\":\"11#可用性判断\",\"613\":\"11#select-1判断\",\"614\":\"11#查表判断\",\"615\":\"11#更新判断\",\"616\":\"11#内部统计\",\"617\":\"11#kill命令\",\"618\":\"11#kill命令的执行过程\",\"619\":\"11#客户端缓存\",\"620\":\"11#误删数据\",\"621\":\"11#误删行\",\"622\":\"11#误删库-表\",\"623\":\"11#延迟复制备库\",\"624\":\"11#预防误删库-表的方法\",\"625\":\"11#rm删除数据\",\"626\":\"11#自增主键\",\"627\":\"11#自增主键的存储\",\"628\":\"11#自增值的修改\",\"629\":\"11#自增锁的优化\",\"630\":\"11#自增主键的上限\",\"631\":\"11#表定义自增值id\",\"632\":\"11#innodb系统自增row-id\",\"633\":\"11#xid\",\"634\":\"11#innodb-trx-id\",\"635\":\"11#thread-id\",\"636\":\"11#自增主键总结\",\"637\":\"12\",\"638\":\"12#mysql索引结构\",\"639\":\"12#b-tree\",\"640\":\"12#b-tree-1\",\"641\":\"12#hash\",\"642\":\"12#索引实现\",\"643\":\"12#explain详解\",\"644\":\"12#explain中的列\",\"645\":\"12#id列\",\"646\":\"12#type列\",\"647\":\"12#最佳实践\",\"648\":\"12#sql执行底层原理\",\"649\":\"12#连接器\",\"650\":\"12#词法分析器\",\"651\":\"12#优化器\",\"652\":\"12#执行器\",\"653\":\"12#bin-log归档\",\"654\":\"12#索引优化实践\",\"655\":\"12#索引下推\",\"656\":\"12#如何选择合适的索引\",\"657\":\"12#常见sql优化\",\"658\":\"12#索引设计原则\",\"659\":\"12#分页查询优化\",\"660\":\"12#join关联查询优化\",\"661\":\"12#嵌套循环连接算法\",\"662\":\"12#基于块的嵌套循环查询\",\"663\":\"12#count-查询优化\",\"664\":\"12#mysql数据类型的选择\",\"665\":\"12#数值类型\",\"666\":\"12#日期和时间\",\"667\":\"12#字符串\",\"668\":\"12#mysql事务与锁\",\"669\":\"12#事务及其属性\",\"670\":\"12#mysql中的锁的分类\",\"671\":\"12#表锁\",\"672\":\"12#行锁\",\"673\":\"12#间隙锁\",\"674\":\"12#临键锁\",\"675\":\"12#行锁分析\",\"676\":\"12#锁优化建议\",\"677\":\"12#mvcc与bufferpool缓冲机制\",\"678\":\"12#mvcc机制\",\"679\":\"12#undo日志版本链与read-view机制详解\",\"680\":\"12#bufferpool缓存机制\",\"681\":\"12#mysql成本分析\",\"682\":\"12#mysql查询成本\",\"683\":\"12#单表查询的成本\",\"684\":\"12#根据搜索条件-找出所有可能使用的索引\",\"685\":\"12#计算全表扫描的代价\",\"686\":\"12#计算使用不同索引执行查询的代价\",\"687\":\"12#是否有可能使用索引合并\",\"688\":\"12#对比各种方案-找出成本最低的那一个\",\"689\":\"12#基于索引统计数据的成本\",\"690\":\"12#index-dive\",\"691\":\"12#连接查询的成本\",\"692\":\"12#两表连接的成本分析\",\"693\":\"12#多表连接的成本分析\",\"694\":\"12#调节成本常数\",\"695\":\"12#innodb中的统计数据\",\"696\":\"12#更新统计数据\",\"697\":\"12#表结构设计\",\"698\":\"12#mysql-redo日志\",\"699\":\"13\",\"700\":\"13#概述\",\"701\":\"13#redis是什么\",\"702\":\"13#redis能该干什么\",\"703\":\"13#核心特性\",\"704\":\"13#基础知识\",\"705\":\"13#五大数据类型\",\"706\":\"13#redis-key\",\"707\":\"13#string-字符串\",\"708\":\"13#list-列表\",\"709\":\"13#set-集合\",\"710\":\"13#hash-哈希\",\"711\":\"13#zset-有序集合\",\"712\":\"13#三种特殊数据类型\",\"713\":\"13#geospatial-地理位置\",\"714\":\"13#hyperloglog-基数统计\",\"715\":\"13#bitmaps-位图\",\"716\":\"13#操作过程\",\"717\":\"13#事务错误\",\"718\":\"13#监控\",\"719\":\"13#jedis\",\"720\":\"13#springboot整合\",\"721\":\"13#自定义redis工具类\",\"722\":\"13#rdb持久化\",\"723\":\"13#什么是rdb\",\"724\":\"13#工作原理\",\"725\":\"13#bgsave\",\"726\":\"13#bgsave和save对比\",\"727\":\"13#优点和缺点\",\"728\":\"13#持久化aof\",\"729\":\"13#什么是aof\",\"730\":\"13#优点和缺点-1\",\"731\":\"13#rdb和aop选择\",\"732\":\"13#rdb-和-aof-对比\",\"733\":\"13#如何选择使用哪种持久化方式\",\"734\":\"13#命令\",\"735\":\"13#示例\",\"736\":\"13#原理\",\"737\":\"13#缺点\",\"738\":\"13#应用\",\"739\":\"13#非阻塞io\",\"740\":\"13#多路复用\",\"741\":\"13#指令队列\",\"742\":\"13#响应队列\",\"743\":\"13#概念\",\"744\":\"13#作用\",\"745\":\"13#为什么使用集群\",\"746\":\"13#环境配置\",\"747\":\"13#一主二从配置\",\"748\":\"13#使用规则\",\"749\":\"13#复制原理\",\"750\":\"13#复制过程\",\"751\":\"13#数据同步\",\"752\":\"13#全量复制\",\"753\":\"13#部分复制\",\"754\":\"13#心跳\",\"755\":\"13#异步复制\",\"756\":\"13#作用-1\",\"757\":\"13#单机单个哨兵\",\"758\":\"13#多哨兵模式\",\"759\":\"13#哨兵模式优缺点\",\"760\":\"13#优点\",\"761\":\"13#缺点-1\",\"762\":\"13#缓存穿透\",\"763\":\"13#概念-1\",\"764\":\"13#解决方案\",\"765\":\"13#缓存击穿\",\"766\":\"13#概念-2\",\"767\":\"13#解决方案-1\",\"768\":\"13#缓存雪崩\",\"769\":\"13#概念-3\",\"770\":\"13#解决方案-2\",\"771\":\"14\",\"772\":\"14#什么是操作系统\",\"773\":\"14#操作系统分类\",\"774\":\"14#操作系统的发展史\",\"775\":\"14#计算机组成原理\",\"776\":\"14#cpu\",\"777\":\"14#地址总线\",\"778\":\"14#dram\",\"779\":\"14#计算机的启动过程\",\"780\":\"14#bios\",\"781\":\"14#地址、section、vstart\",\"782\":\"14#地址\",\"783\":\"14#section\",\"784\":\"14#vstart\",\"785\":\"14#cpu的实模式\",\"786\":\"14#cpu的工作原理\",\"787\":\"14#实模式\",\"788\":\"14#硬盘操作\",\"789\":\"14#获取物理内存容量\",\"790\":\"14#内存分页机制\",\"791\":\"14#混合编程\",\"792\":\"14#基本内联混编\",\"793\":\"14#内联编程\",\"794\":\"14#扩展内联混编\",\"795\":\"15\",\"796\":\"15#dubbo底层实现原理\",\"797\":\"15#dubbo3-0新特性\",\"798\":\"15#dubbo协议\",\"799\":\"15#triple协议\",\"800\":\"15#dubbo服务注册与引入底层原理\",\"801\":\"15#服务导出\",\"802\":\"15#服务引入\",\"803\":\"15#dubbo服务调用底层原理\",\"804\":\"15#http2原理解析\",\"805\":\"16\",\"806\":\"16#mybatis源码体系\",\"807\":\"16#数据操作过程源码剖析\",\"808\":\"17\",\"809\":\"17#netty特点\",\"810\":\"17#作用\",\"811\":\"17#良好的设计\",\"812\":\"17#使用简单\",\"813\":\"17#性能\",\"814\":\"17#安全\",\"815\":\"17#netty架构实现\",\"816\":\"17#netty的hello-world\",\"817\":\"17#netty模块分析\",\"818\":\"17#netty整体执行流程分析\",\"819\":\"17#netty对socket的实现\",\"820\":\"17#socket使用示例\",\"821\":\"17#消息的广播\",\"822\":\"17#心跳机制\",\"823\":\"17#netty与websocket\",\"824\":\"17#实现与原理分析\",\"825\":\"17#websocket生命周期分解\",\"826\":\"17#google-protobuf\",\"827\":\"17#简介\",\"828\":\"17#proto文件\",\"829\":\"17#解析和序列化\",\"830\":\"17#编写message\",\"831\":\"17#读取message\",\"832\":\"17#多协议消息\",\"833\":\"17#最佳实践\",\"834\":\"17#apache-thrift\",\"835\":\"17#简介-1\",\"836\":\"17#thrift文件\",\"837\":\"17#最佳实践-1\",\"838\":\"17#传输格式\",\"839\":\"17#传输方式\",\"840\":\"17#服务模型\",\"841\":\"17#多语言的支持\",\"842\":\"17#grpc\",\"843\":\"17#简介-2\",\"844\":\"17#相关示例\",\"845\":\"17#流式调用\",\"846\":\"17#io与nio\",\"847\":\"17#io与nio的区别\",\"848\":\"17#buffer\",\"849\":\"17#channel\",\"850\":\"17#selector\",\"851\":\"17#nio网络编程\",\"852\":\"17#字符编码集\",\"853\":\"17#零拷贝\",\"854\":\"17#传统的io流程\",\"855\":\"17#零拷贝实现原理\",\"856\":\"17#eventloopgroup\",\"857\":\"17#netty中的future对象\",\"858\":\"17#channelfuture\",\"859\":\"17#异步读写架构\",\"860\":\"17#promise\",\"861\":\"17#serverbootstrap\",\"862\":\"17#核心方法\",\"863\":\"17#初始化和注册方法\",\"864\":\"17#reactor模式\",\"865\":\"17#传统的模型\",\"866\":\"17#reactor模式-1\",\"867\":\"17#netty中的reactor线程模型\",\"868\":\"17#自适应缓冲区\",\"869\":\"17#channel实现原理\",\"870\":\"17#channel的四大组件\",\"871\":\"17#channel与channelpipeline\",\"872\":\"17#channeloption与attributekey\",\"873\":\"17#channelhandler与channelhandlercontext\",\"874\":\"17#channel选择器\",\"875\":\"17#channel注册流程\",\"876\":\"17#netty中的设计原则\",\"877\":\"17#设计原则\",\"878\":\"17#业务线程池\",\"879\":\"17#bytebuf实现原理\",\"880\":\"17#bytebuf使用示例\",\"881\":\"17#bytebuf数据结构\",\"882\":\"17#复合缓冲区\",\"883\":\"17#引用计数\",\"884\":\"17#实现原理\",\"885\":\"17#atomicintegerfieldupdater\",\"886\":\"17#netty中的处理器\",\"887\":\"17#自定义编解码器\",\"888\":\"17#replayingdecoder\",\"889\":\"17#lengthfieldbasedframedecoder\",\"890\":\"17#常见编解码器总结\",\"891\":\"17#tcp粘包与拆包\",\"892\":\"17#粘包与拆包\",\"893\":\"17#解决方案\",\"894\":\"17#观察者模式\",\"895\":\"17#适配器模式\",\"896\":\"17#模板方法模式\",\"897\":\"18\",\"898\":\"18#知识储备\",\"899\":\"18#java-基础部分\",\"900\":\"18#oop-部分\",\"901\":\"18#gof23-设计模式\",\"902\":\"18#spring-核心基础\",\"903\":\"18#oop局限性\",\"904\":\"18#aop常见使用场景\",\"905\":\"18#日志场景\",\"906\":\"18#统计场景\",\"907\":\"18#安防场景\",\"908\":\"18#性能场景\",\"909\":\"18#java-aop设计模式\",\"910\":\"18#代理模式\",\"911\":\"18#判断模式\",\"912\":\"18#拦截模式\",\"913\":\"18#spring-aop-功能概述\",\"914\":\"18#aop设计核心\",\"915\":\"18#spring-aop编程模型\",\"916\":\"18#spring-aop-advice类型\",\"917\":\"18#spring-aop代理实现\",\"918\":\"18#jdk动态代理\",\"919\":\"18#cglib动态代理\",\"920\":\"18#aspectj代理\",\"921\":\"18#面试题\",\"922\":\"18#spring-aop和aspectj-aop存在哪些差别\",\"923\":\"18#aspectj注解驱动\",\"924\":\"18#编程方式创建-aspectj代理\",\"925\":\"18#标准工厂api\",\"926\":\"18#aspectj-pointcut指令与表达式\",\"927\":\"18#xml配置pointcut\",\"928\":\"18#api实现pointcut\",\"929\":\"18#aspectj拦截动作\",\"930\":\"18#xml配置around-advice\",\"931\":\"18#aspectj的前置动作\",\"932\":\"18#xml配置before-advice\",\"933\":\"18#api实现before-advice\",\"934\":\"18#aspect后置动作\",\"935\":\"18#xml配置after-advice\",\"936\":\"18#api实现after-advice\",\"937\":\"18#自动动态代理\",\"938\":\"18#替换targetsource\",\"939\":\"18#面试题-1\",\"940\":\"18#spring-aop支持哪些类型的advice\",\"941\":\"18#spring-aop编程模型有哪些-代表组件有哪些\",\"942\":\"18#spring-aop三种实现方式是如何进行设计的\",\"943\":\"18#api整体设计\",\"944\":\"18#接入点接口joinpoint\",\"945\":\"18#joinpoint条件接口\",\"946\":\"18#pointcut组合实现\",\"947\":\"18#pointcut便利实现\",\"948\":\"18#pointcut-aspectj实现\",\"949\":\"18#joinpoint执行动作接口\",\"950\":\"18#before-advice标准实现\",\"951\":\"18#before-advice-aspectj实现\",\"952\":\"18#after-advice标准实现\",\"953\":\"18#after-advice-aspectj实现\",\"954\":\"18#advisor接口\",\"955\":\"18#pointcutadvisor接口\",\"956\":\"18#intorductionadvisor接口\",\"957\":\"18#advisoradapter接口\",\"958\":\"18#aopproxy接口\",\"959\":\"18#aopproxyfactory\",\"960\":\"18#jdk-aopproxy实现\",\"961\":\"18#cglib-aopproxy实现\",\"962\":\"18#advisedsupport\",\"963\":\"18#advisorchainfactory接口\",\"964\":\"18#targetsource接口\",\"965\":\"18#proxycreatorsupport\",\"966\":\"18#advisedsupportlistener\",\"967\":\"18#proxyfactory\",\"968\":\"18#proxyfactorybean\",\"969\":\"18#aspectjproxyfactory\",\"970\":\"18#abstractautoproxycreator\",\"971\":\"18#ioc容器自动代理标准实现\",\"972\":\"18#aspectjawareadvisorautoproxycreator\",\"973\":\"18#aopinfrastructurebean接口\",\"974\":\"18#aopcontext\",\"975\":\"18#aopproxyutils\",\"976\":\"18#aoputils\",\"977\":\"18#aspectj-enable模块驱动\",\"978\":\"18#aspectj-xml配置驱动实现\",\"979\":\"18#aop-config-schema-based实现\",\"980\":\"18#aop-aspect-schema-based实现\",\"981\":\"18#pointcut-schema-based实现\",\"982\":\"18#around-advice-schema-based实现\",\"983\":\"18#before-advice-schema-based实现\",\"984\":\"18#after-advice-schema-based实现\",\"985\":\"18#after-returning-advice-schema-based实现\",\"986\":\"18#after-throwing-advice-schema-based实现\",\"987\":\"18#advisor-schema-based实现\",\"988\":\"18#introduction-schema-based实现\",\"989\":\"18#作用域代理schema-based实现\",\"990\":\"18#面试题-2\",\"991\":\"18#spring-aop-advice-xml标签有哪些\",\"992\":\"18#请解释spring-enbaleaspectjautoproxy的原理\",\"993\":\"18#spring-configuration-class-cglib提升与aop类代理的关系\",\"994\":\"18#创建型模式\",\"995\":\"18#抽象工厂模式\",\"996\":\"18#构建器模式\",\"997\":\"18#工厂方法模式\",\"998\":\"18#原型模式\",\"999\":\"18#单例模式\",\"1000\":\"18#结构型模式\",\"1001\":\"18#适配器模式\",\"1002\":\"18#组合模式\",\"1003\":\"18#装饰器模式\",\"1004\":\"18#享元模式\",\"1005\":\"18#代理模式-1\",\"1006\":\"18#行为型模式\",\"1007\":\"18#模板方法模式\",\"1008\":\"18#责任链模式\",\"1009\":\"18#观察者模式\",\"1010\":\"18#策略模式\",\"1011\":\"18#命令模式\",\"1012\":\"18#状态模式\",\"1013\":\"18#面试题-3\",\"1014\":\"18#gof-23设计模式和它的归类\",\"1015\":\"18#举例装饰器模式和代理模式的区别\",\"1016\":\"18#请举例说明spring-framework中使用设计模式的实现\",\"1017\":\"18#spring-事件中的应用\",\"1018\":\"18#spring事务中的应用\",\"1019\":\"18#核心api\",\"1020\":\"18#理解transactiondefinition\",\"1021\":\"18#理解platformtransactionmanager\",\"1022\":\"18#理解事务传播\",\"1023\":\"18#spring-缓存中的应用\",\"1024\":\"18#spring本地调度中的应用\",\"1025\":\"18#面试题-4\",\"1026\":\"18#spring-aop在spring-framework特性运用\",\"1027\":\"18#spring事务传播的原理\",\"1028\":\"18#spring-aop与ioc功能整合的设计模式\",\"1029\":\"19\",\"1030\":\"19#springbootapplication\",\"1031\":\"19#注解解析\",\"1032\":\"19#configuration\",\"1033\":\"19#componentscan\",\"1034\":\"19#enableautoconfiguration\",\"1035\":\"19#启动执行流程\",\"1036\":\"19#流程概览\",\"1037\":\"19#启动详情\",\"1038\":\"19#自动装配\",\"1039\":\"19#打包过程\",\"1040\":\"19#构建工具\",\"1041\":\"19#spring-boot-maven-plugin\",\"1042\":\"19#spotify-maven-plugin\",\"1043\":\"19#jib-maven-plugin\",\"1044\":\"19#修改之前\",\"1045\":\"19#使用alpine镜像\",\"1046\":\"19#分层构建镜像\",\"1047\":\"19#maven中内置变量\",\"1048\":\"19#可能存在的问题\",\"1049\":\"20\",\"1050\":\"21\",\"1051\":\"21#spring特性总览\",\"1052\":\"21#spring-中值得学习的地方\",\"1053\":\"21#spring核心特性\",\"1054\":\"21#spring数据存储\",\"1055\":\"21#spring-web技术\",\"1056\":\"21#spring技术整合\",\"1057\":\"21#spring测试\",\"1058\":\"21#spring版本特性\",\"1059\":\"21#spring模块化设计\",\"1060\":\"21#spring编程模型\",\"1061\":\"21#spring的核心价值\",\"1062\":\"21#面试题\",\"1063\":\"21#什么是spring-framework\",\"1064\":\"21#spring-framwork有哪些核心模块\",\"1065\":\"21#spring-framework的优势和不足是什么\",\"1066\":\"21#ioc的发展简介\",\"1067\":\"21#ioc主要实现策略\",\"1068\":\"21#ioc容器的职责\",\"1069\":\"21#ioc的实现\",\"1070\":\"21#传统ioc容器的实现\",\"1071\":\"21#如何界定ioc容器是轻量级的\",\"1072\":\"21#依赖查找和依赖注入\",\"1073\":\"21#构造器注入和setter注入\",\"1074\":\"21#面试题-1\",\"1075\":\"21#什么是ioc\",\"1076\":\"21#依赖查找和依赖注入的区别\",\"1077\":\"21#spring作为ioc容器有什么优势\",\"1078\":\"21#spring-ioc依赖查找\",\"1079\":\"21#spring-ioc依赖注入\",\"1080\":\"21#spring依赖注入和依赖查找的来源\",\"1081\":\"21#spring-ioc配置元信息\",\"1082\":\"21#beanfactory和applicationcontext\",\"1083\":\"21#spring-ioc容器生命周期\",\"1084\":\"21#面试题-2\",\"1085\":\"21#什么是spring-ioc容器\",\"1086\":\"21#beanfactory和factorybean\",\"1087\":\"21#spring-ioc容器启动时做了哪些准备\",\"1088\":\"21#beandefinition\",\"1089\":\"21#spring-bean命名\",\"1090\":\"21#beandefinition注册到ioc容器\",\"1091\":\"21#实例化bean的方式\",\"1092\":\"21#初始化bean的方式\",\"1093\":\"21#延迟初始化bean\",\"1094\":\"21#销毁bean\",\"1095\":\"21#垃圾回收spring-bean\",\"1096\":\"21#面试题-3\",\"1097\":\"21#如何注册一个spring-bean\",\"1098\":\"21#什么是spring-beandefinition\",\"1099\":\"21#spring容器是怎样管理注册bean\",\"1100\":\"21#依赖查找简介\",\"1101\":\"21#单一类型依赖查找\",\"1102\":\"21#集合类型依赖查找\",\"1103\":\"21#层次性依赖查找\",\"1104\":\"21#延迟依赖查找\",\"1105\":\"21#安全依赖查找\",\"1106\":\"21#内建可查找的依赖\",\"1107\":\"21#依赖查找中典型异常\",\"1108\":\"21#面试题-4\",\"1109\":\"21#objectfactory与beanfactory的区别\",\"1110\":\"21#beanfactory-getbean操作是否线程安全\",\"1111\":\"21#spring的依赖查找和依赖注入在来源上有什么区别\",\"1112\":\"21#依赖注入的模式和类型\",\"1113\":\"21#自动绑定\",\"1114\":\"21#setter注入\",\"1115\":\"21#构造器注入\",\"1116\":\"21#字段注入\",\"1117\":\"21#方法注入\",\"1118\":\"21#接口回调注入\",\"1119\":\"21#依赖注入类型选择\",\"1120\":\"21#基础类型注入\",\"1121\":\"21#集合类型注入\",\"1122\":\"21#限定注入\",\"1123\":\"21#延迟依赖注入\",\"1124\":\"21#依赖处理的过程\",\"1125\":\"21#autowird注入\",\"1126\":\"21#inject和-autowired联系\",\"1127\":\"21#java通用注解原理\",\"1128\":\"21#自定义依赖注入注解\",\"1129\":\"21#面试题-5\",\"1130\":\"21#有多少种依赖注入的方式\",\"1131\":\"21#你偏好构造器注入还是setter注入\",\"1132\":\"21#spring依赖注入的来源有哪些\",\"1133\":\"21#依赖查找的来源\",\"1134\":\"21#依赖注入的来源\",\"1135\":\"21#spring容器管理和游离对象\",\"1136\":\"21#spring-beandefinition作为依赖来源\",\"1137\":\"21#单体对象作为依赖来源\",\"1138\":\"21#resolvable-dependency作为依赖来源\",\"1139\":\"21#外部化配置作为依赖来源\",\"1140\":\"21#面试题-6\",\"1141\":\"21#依赖注入和依赖查找的依赖来源是否相同\",\"1142\":\"21#单例对象能在ioc容器启动后注册吗\",\"1143\":\"21#spring依赖注入的来源有哪些-1\",\"1144\":\"21#作用域简介\",\"1145\":\"21#singleton作用域\",\"1146\":\"21#prototype作用域\",\"1147\":\"21#request作用域\",\"1148\":\"21#session作用域\",\"1149\":\"21#application作用域\",\"1150\":\"21#自定义bean作用域\",\"1151\":\"21#面试题-7\",\"1152\":\"21#spring内建的bean的作用域有几种\",\"1153\":\"21#singleton-bean是否在一个应用中是唯一的\",\"1154\":\"21#application-bean是否被其他方案他替代\",\"1155\":\"21#元信息配置阶段\",\"1156\":\"21#元信息解析阶段\",\"1157\":\"21#注册阶段\",\"1158\":\"21#beandefinition合并阶段\",\"1159\":\"21#bean-class加载阶段\",\"1160\":\"21#实例化\",\"1161\":\"21#实例化前阶段\",\"1162\":\"21#实例化阶段\",\"1163\":\"21#bean实例化后阶段\",\"1164\":\"21#属性赋值前阶段\",\"1165\":\"21#初始化\",\"1166\":\"21#接口回调阶段\",\"1167\":\"21#初始化前阶段\",\"1168\":\"21#初始化阶段\",\"1169\":\"21#初始化后阶段\",\"1170\":\"21#初始化完成阶段\",\"1171\":\"21#销毁阶段\",\"1172\":\"21#销毁前阶段\",\"1173\":\"21#销毁阶段-1\",\"1174\":\"21#bean垃圾收集\",\"1175\":\"21#面试题-8\",\"1176\":\"21#beanpostprocess使用场景有哪些\",\"1177\":\"21#beanfactorypostprocess与beanpostprocess的区别\",\"1178\":\"21#beanfactory是怎样处理bean生命周期\",\"1179\":\"21#spring-bean配置元信息\",\"1180\":\"21#spring-bean属性元信息\",\"1181\":\"21#spring容器配置元信息\",\"1182\":\"21#基于xml资源装载spring-bean配置元信息\",\"1183\":\"21#基于properties资源装载spring-bean配置元信息\",\"1184\":\"21#基于java注解的spring-bean配置元信息\",\"1185\":\"21#spring-bean配置元信息底层实现\",\"1186\":\"21#xml资源的方式\",\"1187\":\"21#properties资源的方式\",\"1188\":\"21#java注解的方式\",\"1189\":\"21#基于xml资源装载spring-容器配置元信息\",\"1190\":\"21#基于java注解配置spring-容器配置元信息\",\"1191\":\"21#基于extensible-xml-authoring扩展spring-xml元素\",\"1192\":\"21#基于properties资源装载外部化配置\",\"1193\":\"21#基于yml资源装载外部化配置\",\"1194\":\"21#面试题-9\",\"1195\":\"21#spring内建的xml-schema常见有哪些\",\"1196\":\"21#spring配置元信息有哪些\",\"1197\":\"21#extensible-xml-authoring的缺点\",\"1198\":\"21#java标准资源管理\",\"1199\":\"21#resource接口\",\"1200\":\"21#内建的resource实现\",\"1201\":\"21#resource接口扩展\",\"1202\":\"21#spring资源加载器\",\"1203\":\"21#spring通配路径资源加载器\",\"1204\":\"21#spring通配路径资源扩展\",\"1205\":\"21#依赖注入spring-resource\",\"1206\":\"21#依赖注入resourceloader\",\"1207\":\"21#面试题-10\",\"1208\":\"21#spring配置资源中有哪些常见类型\",\"1209\":\"21#请举例不同类型的spring配置资源\",\"1210\":\"21#java标准资源管理扩展的步骤\",\"1211\":\"21#spring国际化接口\",\"1212\":\"21#层次性的messagesource\",\"1213\":\"21#java国际化标准实现\",\"1214\":\"21#java文本格式化\",\"1215\":\"21#messagesource开箱实现\",\"1216\":\"21#message的内建依赖\",\"1217\":\"21#springboot为什么要新建messagesource-bean\",\"1218\":\"21#面试题-11\",\"1219\":\"21#spring国际化接口有哪些\",\"1220\":\"21#spring有哪些messagesource的内建实现\",\"1221\":\"21#如何实现配置自动更新messagesource\",\"1222\":\"21#validator接口设计\",\"1223\":\"21#errors接口设计\",\"1224\":\"21#errors的文案来源\",\"1225\":\"21#自定义validator\",\"1226\":\"21#bean-validation\",\"1227\":\"21#面试题-12\",\"1228\":\"21#spring校验接口是哪个\",\"1229\":\"21#spring有哪些校验核心组件\",\"1230\":\"21#请通过示例演示spring-bean的校验\",\"1231\":\"21#spring-数据绑定组件\",\"1232\":\"21#databinder元数据\",\"1233\":\"21#databinder绑定控制参数\",\"1234\":\"21#spring底层java-beans替换实现\",\"1235\":\"21#beanwrapper使用场景\",\"1236\":\"21#javabeans操作属性\",\"1237\":\"21#databinder数据校验\",\"1238\":\"21#面试题-13\",\"1239\":\"21#spring数据绑定api是什么\",\"1240\":\"21#beanwrapper与javabeans之间的关系是\",\"1241\":\"21#databinder是怎么完成属性类型转换的\",\"1242\":\"21#使用场景\",\"1243\":\"21#基于javabeans接口的类型转换\",\"1244\":\"21#spring内建propertyeditor扩展\",\"1245\":\"21#自定义propertyeditor扩展\",\"1246\":\"21#propertyeditor的局限性\",\"1247\":\"21#spring3-通用类型转换接口\",\"1248\":\"21#spring内建类型转换器\",\"1249\":\"21#converter接口的局限性\",\"1250\":\"21#genericconverter接口\",\"1251\":\"21#优化genericconverter接口\",\"1252\":\"21#扩展spring类型转换器\",\"1253\":\"21#统一类型转换服务\",\"1254\":\"21#conversionservice作为依赖\",\"1255\":\"21#面试题-14\",\"1256\":\"21#spring类型转换实现有哪些\",\"1257\":\"21#spring类型转换器接口有哪些\",\"1258\":\"21#typedescriptor是如何处理泛型\",\"1259\":\"21#java泛型基础\",\"1260\":\"21#java-5类型接口\",\"1261\":\"21#spring泛型类型辅助类\",\"1262\":\"21#泛型集合类型辅助类\",\"1263\":\"21#spring方法参数封装\",\"1264\":\"21#resolvabletype\",\"1265\":\"21#面试题-15\",\"1266\":\"21#java泛型擦写是发生在编译时-还是运行时\",\"1267\":\"21#请介绍java-5-type类型的派生类或接口\",\"1268\":\"21#请说明resolvabletype的设计优势\",\"1269\":\"21#java事件-监听器编程模型\",\"1270\":\"21#面向接口的事件-监听器设计模式\",\"1271\":\"21#面向注解的事件-监听器设计模式\",\"1272\":\"21#spring标准事件-applicationevent\",\"1273\":\"21#基于接口的spring事件监听器\",\"1274\":\"21#基于注解的spring事件监听器\",\"1275\":\"21#注册spring-applicationlistener\",\"1276\":\"21#spring事件发布器\",\"1277\":\"21#spring层次性上下文事件传播\",\"1278\":\"21#spring内建事件\",\"1279\":\"21#payload事件\",\"1280\":\"21#自定义spring事件\",\"1281\":\"21#依赖注入applicationeventpublisher\",\"1282\":\"21#依赖查找applicationeventmulticaster\",\"1283\":\"21#applicationeventpublisher底层实现\",\"1284\":\"21#同步和异步spring事件广播\",\"1285\":\"21#spring事件异常处理\",\"1286\":\"21#spring事件-监听实现原理\",\"1287\":\"21#springboot事件\",\"1288\":\"21#面试题-16\",\"1289\":\"21#spring事件核心接口-组件\",\"1290\":\"21#spring同步和异步事件处理的使用场景\",\"1291\":\"21#eventlistener的工作原理\",\"1292\":\"21#spring核心注解场景分类\",\"1293\":\"21#spring注解编程模型\",\"1294\":\"21#spring元注解\",\"1295\":\"21#spring模式注解\",\"1296\":\"21#spring-组合注解\",\"1297\":\"21#spring注解属性别名\",\"1298\":\"21#spring注解属性覆盖\",\"1299\":\"21#spring-enable模块驱动\",\"1300\":\"21#spring条件注解\",\"1301\":\"21#springboot和springcloud注解\",\"1302\":\"21#面试题-17\",\"1303\":\"21#spring模式注解有哪些\",\"1304\":\"21#eventlistener的工作原理-1\",\"1305\":\"21#propertysource工作原理\",\"1306\":\"21#environment接口使用场景\",\"1307\":\"21#environment占位符处理\",\"1308\":\"21#理解条件配置spring-profiles\",\"1309\":\"21#依赖注入environment\",\"1310\":\"21#依赖查找environment\",\"1311\":\"21#依赖注入-value\",\"1312\":\"21#spring类型转换在environment中的运用\",\"1313\":\"21#spring类型转换在-value中的运用\",\"1314\":\"21#spring配置属性源propertysource\",\"1315\":\"21#spring内建的配置属性源\",\"1316\":\"21#基于注解扩展spring配置属性源\",\"1317\":\"21#基于api扩展spring配置属性源\",\"1318\":\"21#spring-测试配置属性源\",\"1319\":\"21#面试题-18\",\"1320\":\"21#简单介绍spring-environment接口\",\"1321\":\"21#如何控制propertysource的优先级\",\"1322\":\"21#environment完整的生命周期是怎样的\",\"1323\":\"21#spring应用上下文启动准备阶段\",\"1324\":\"21#beanfactory创建阶段\",\"1325\":\"21#beanfactory准备阶段\",\"1326\":\"21#beanfactory后置处理阶段\",\"1327\":\"21#beanfactory注册beanpostprocess\",\"1328\":\"21#初始化内建messagesource\",\"1329\":\"21#初始化内建spring事件广播器\",\"1330\":\"21#spring应用上下文刷新\",\"1331\":\"21#spring事件监听器注册\",\"1332\":\"21#beanfactory初始化完成阶段\",\"1333\":\"21#spring应用上下文刷新完成阶段\",\"1334\":\"21#spring-应用上下文启动阶段\",\"1335\":\"21#spring-应用上下文停止阶段\",\"1336\":\"21#spring应用上下文关闭阶段\",\"1337\":\"21#面试题-19\",\"1338\":\"21#spring应用上下文生命周期有哪些阶段\",\"1339\":\"21#environment完整的生命周期\",\"1340\":\"21#spring核心特性-1\",\"1341\":\"21#spring核心价值\",\"1342\":\"21#为什么说objectfactory提供的是延迟依赖查找\",\"1343\":\"21#依赖查找-注入-的bean会被缓存嘛\",\"1344\":\"21#bean的处理流程是怎样的\",\"1345\":\"21#beanfactory是如何处理循环依赖的\",\"1346\":\"37\",\"1347\":\"37#jmm实现原理\",\"1348\":\"37#可见性\",\"1349\":\"37#原子性\",\"1350\":\"37#有序性\",\"1351\":\"37#缓存一致性\",\"1352\":\"37#list、set、hashmap底层原理\",\"1353\":\"37#线程池底层原理\",\"1354\":\"37#深入理解java线程\",\"1355\":\"37#cas与atomic实现原理\",\"1356\":\"37#cas源码解析\",\"1357\":\"37#atomic源码解析\",\"1358\":\"37#synchronized实现原理\",\"1359\":\"37#synchronized基础\",\"1360\":\"37#monitor机制\",\"1361\":\"37#对象头\",\"1362\":\"37#偏向锁\",\"1363\":\"37#锁粗化\",\"1364\":\"37#锁消除\",\"1365\":\"37#逃逸分析\",\"1366\":\"37#synchronized的优化\",\"1367\":\"37#aqs与reentrantlock实现原理\",\"1368\":\"37#同步等待队列\",\"1369\":\"37#条件等待队列\",\"1370\":\"37#condition接口\",\"1371\":\"37#reentrantlock详解\",\"1372\":\"37#synchronized和reentrantlock\",\"1373\":\"37#semaphore与countdownlatch\",\"1374\":\"37#cylicbarrier实现原理\",\"1375\":\"37#reentrantreadwritelock\",\"1376\":\"37#blockingqueue实现原理\",\"1377\":\"37#queue队列\",\"1378\":\"37#blockingqueue\",\"1379\":\"37#arrayblockingqueue\",\"1380\":\"37#linkedblockingqueue\",\"1381\":\"37#linkedblockingdeque\",\"1382\":\"37#synchronousqueue\",\"1383\":\"37#priorityblockingqueue\",\"1384\":\"37#linkedtransferqueue\",\"1385\":\"37#delayqueue\",\"1386\":\"37#如何选择合适的阻塞队列\",\"1387\":\"37#forkjoin实现原理\",\"1388\":\"37#工作窃取\",\"1389\":\"37#工作队列\",\"1390\":\"37#forkjoinworkthread\",\"1391\":\"37#原理分析\",\"1392\":\"37#completablefuture实现原理\",\"1393\":\"37#future\",\"1394\":\"37#completionservice\",\"1395\":\"37#completablefuture\",\"1396\":\"37#高性能队列disruptor\",\"1397\":\"37#ringbuffer\",\"1398\":\"37#disruptor实战\",\"1399\":\"37#并发设计模式\",\"1400\":\"37#终止线程模式\",\"1401\":\"37#两阶段终止模式\",\"1402\":\"37#避免共享的设计模式\",\"1403\":\"37#immutability模式\",\"1404\":\"37#copy-on-write模式\",\"1405\":\"37#thread-specific-storage模式\",\"1406\":\"37#多线程版本的if模式\",\"1407\":\"37#guarded-suspension模式\",\"1408\":\"37#balking模式\",\"1409\":\"37#多线程分工模式\",\"1410\":\"37#thread-per-message模式\",\"1411\":\"37#worker-thread模式\",\"1412\":\"37#生产者-消费者模式\",\"1413\":\"37#过饱问题解决方案\",\"1414\":\"38\",\"1415\":\"38#集合的优点\",\"1416\":\"38#单列集合\",\"1417\":\"38#多列集合\",\"1418\":\"38#list\",\"1419\":\"38#arraylist源码分析\",\"1420\":\"38#linkedlist源码分析\",\"1421\":\"38#map\",\"1422\":\"38#hashmap原理分析\",\"1423\":\"38#存储方式\",\"1424\":\"38#方法实现\",\"1425\":\"38#确定哈希桶数组索引位置\",\"1426\":\"38#put方法\",\"1427\":\"38#扩容机制\",\"1428\":\"38#线程安全性\",\"1429\":\"38#concurrenthashmap源码分析\",\"1430\":\"38#jdk1-7的实现\",\"1431\":\"38#jdk1-8的实现\",\"1432\":\"38#hashtable源码分析\",\"1433\":\"38#set\",\"1434\":\"38#hashset源码分析\",\"1435\":\"38#反射的定义\",\"1436\":\"38#反射的作用\",\"1437\":\"38#核心api\",\"1438\":\"38#io基础\",\"1439\":\"38#linux网络编程io模型\",\"1440\":\"38#阻塞io模型\",\"1441\":\"38#非阻塞io\",\"1442\":\"38#io多路复用\",\"1443\":\"38#异步io\",\"1444\":\"38#阻塞、非阻塞和同步、异步\",\"1445\":\"38#io多路复用之select、poll、epoll\",\"1446\":\"38#select\",\"1447\":\"38#poll\",\"1448\":\"38#epoll\",\"1449\":\"38#java中的io模型\",\"1450\":\"38#bio\",\"1451\":\"38#nio\",\"1452\":\"38#aio\",\"1453\":\"38#io模型对比\",\"1454\":\"38#基本概念\",\"1455\":\"38#dma\",\"1456\":\"38#内核空间和用户空间\",\"1457\":\"38#io拷贝机制\",\"1458\":\"38#mmap内存映射拷贝流程\",\"1459\":\"38#linux系统sendfile拷贝流程\",\"1460\":\"38#sendfile-with-dma-scatter-gather-拷贝流程\",\"1461\":\"38#linux-系统-splice-零拷贝流程\",\"1462\":\"38#io拷贝机制对比\",\"1463\":\"38#java中的零拷贝\",\"1464\":\"38#java-nio-对mmap的支持\",\"1465\":\"38#java-nio-对sendfile的支持\",\"1466\":\"39\",\"1467\":\"40\",\"1468\":\"40#函数式编程的意义\",\"1469\":\"40#lambda表达式和匿名内部类\",\"1470\":\"40#lambda表达式和stream\",\"1471\":\"40#函数式接口定义\",\"1472\":\"40#为什么是函数式接口\",\"1473\":\"40#常见的函数式接口\",\"1474\":\"40#consumer函数式接口\",\"1475\":\"40#function函数式接口\",\"1476\":\"40#predicate函数式接口\",\"1477\":\"40#supplier函数式接口\",\"1478\":\"40#函数式接口扩展\",\"1479\":\"40#方法引用\",\"1480\":\"40#静态方法引用\",\"1481\":\"40#实例方法引用\",\"1482\":\"40#实例方法名引用\",\"1483\":\"40#构造方法引用\",\"1484\":\"40#默认方法\",\"1485\":\"40#stream类源码解析\",\"1486\":\"40#stream实例剖析\",\"1487\":\"40#stream陷阱剖析\",\"1488\":\"40#内部迭代和外部迭代\",\"1489\":\"40#流的短路与并发流\",\"1490\":\"40#分区与分组\",\"1491\":\"40#comparator源码分析及实践\",\"1492\":\"40#collector源码分析\",\"1493\":\"40#collector实践\",\"1494\":\"40#自定义collector\",\"1495\":\"40#collectors源码分析\",\"1496\":\"40#stream源码分析\",\"1497\":\"40#spliterator源码分析\",\"1498\":\"40#pipeline源码分析\",\"1499\":\"40#流调用机制与原理\",\"1500\":\"40#sink源码分析\",\"1501\":\"40#stream调用流程\",\"1502\":\"41\",\"1503\":\"42\",\"1504\":\"43\",\"1505\":\"44\",\"1506\":\"44#spring源码分析\",\"1507\":\"44#spring核心原理概览\",\"1508\":\"44#spring核心概念\",\"1509\":\"44#beandefinition\",\"1510\":\"44#annotatedbeandefinitionreader\",\"1511\":\"44#xmlbeandefinitionreader\",\"1512\":\"44#classpathbeandefinitionscanner\",\"1513\":\"44#beanfactory\",\"1514\":\"44#applicationcontext\",\"1515\":\"44#propertyeditor\",\"1516\":\"44#conversionservice\",\"1517\":\"44#typeconverter\",\"1518\":\"44#ordercomparator\",\"1519\":\"44#beanpostprocessor\",\"1520\":\"44#beanfactorypostprocessor\",\"1521\":\"44#factorybean\",\"1522\":\"44#excludefilter和includefilter\",\"1523\":\"44#metadatareader、classmetadata、annotationmetadata\",\"1524\":\"44#bean的生命周期\",\"1525\":\"44#依赖注入源码解析\",\"1526\":\"44#循环依赖解析\",\"1527\":\"44#推断构造源码解析\",\"1528\":\"44#spring启动过程\",\"1529\":\"44#配置类解析与扫描过程源码解析\",\"1530\":\"44#整合mybatis底层源码解析\",\"1531\":\"44#spring-aop源码解析\",\"1532\":\"44#spring事务源码解析\",\"1533\":\"44#spring-mvc源码分析\",\"1534\":\"44#spring-mvc执行流程\",\"1535\":\"44#spring-mvc启动过程\",\"1536\":\"44#spring和spring-mvc为什么需要父子容器-不要不行吗\",\"1537\":\"44#是否可以把所有bean都通过spring容器来管理\",\"1538\":\"44#是否可以把所有bean都交由spring-mvc容器进行管理\",\"1539\":\"44#jvm\",\"1540\":\"44#jvm类加载机制\",\"1541\":\"44#jvm内存模型\",\"1542\":\"44#jvm对象创建与内存分配机制深度剖析\",\"1543\":\"44#类加载检查\",\"1544\":\"44#分配内存\",\"1545\":\"44#划分内存的方法\",\"1546\":\"44#设置对象头\",\"1547\":\"44#class文件结构\",\"1548\":\"44#垃圾收集器\",\"1549\":\"44#jvm调优工具\",\"1550\":\"44#jvm常量池\",\"1551\":\"44#zgc详解\",\"1552\":\"44#云原生时代的java虚拟机\",\"1553\":\"44#用java实现一个jvm框架\",\"1554\":\"44#jvm如何调用java方法\",\"1555\":\"44#实现stw\",\"1556\":\"45\",\"1557\":\"46\",\"1558\":\"47\",\"1559\":\"48\",\"1560\":\"48#tomcat\",\"1561\":\"48#tomcat整体架构\",\"1562\":\"48#tomcat核心组件\",\"1563\":\"48#server组件\",\"1564\":\"48#service组件\",\"1565\":\"48#连接器connector组件\",\"1566\":\"48#protocolhandler组件\",\"1567\":\"48#tomcat线程模型\",\"1568\":\"48#tomcat类加载机制\",\"1569\":\"48#jvm类加载器\",\"1570\":\"48#双亲委托机制\",\"1571\":\"48#tomcat的类加载机制\",\"1572\":\"48#线程上下文类加载器\",\"1573\":\"48#tomcat热加载和热部署\",\"1574\":\"49\",\"1575\":\"49#内存管理\",\"1576\":\"49#垃圾回收\",\"1577\":\"49#类文件结构\",\"1578\":\"49#类加载机制\",\"1579\":\"49#运行时数据区域\",\"1580\":\"49#程序计数器\",\"1581\":\"49#虚拟机栈\",\"1582\":\"49#本地方法栈\",\"1583\":\"49#堆\",\"1584\":\"49#方法区\",\"1585\":\"49#运行时常量池\",\"1586\":\"49#直接内存\",\"1587\":\"49#hotspot虚拟机对象\",\"1588\":\"49#对象的创建\",\"1589\":\"49#对象的内存布局\",\"1590\":\"49#对象的访问定位\",\"1591\":\"49#判断对象已死\",\"1592\":\"49#引用计数算法\",\"1593\":\"49#根搜索算法\",\"1594\":\"49#对象的回收\",\"1595\":\"49#对象的引用\",\"1596\":\"49#垃圾回收算法\",\"1597\":\"49#分代收集理论\",\"1598\":\"49#标记-清除算法\",\"1599\":\"49#标记-复制算法\",\"1600\":\"49#标记-整理算法\",\"1601\":\"49#经典垃圾收集器\",\"1602\":\"49#serial收集器\",\"1603\":\"49#parnew收集器\",\"1604\":\"49#parallel-scavenge收集器\",\"1605\":\"49#serial-old收集器\",\"1606\":\"49#parallel-old收集器\",\"1607\":\"49#cms收集器\",\"1608\":\"49#cms简介\",\"1609\":\"49#cms详细步骤\",\"1610\":\"49#初始标记\",\"1611\":\"49#并发标记\",\"1612\":\"49#预清理阶段\",\"1613\":\"49#可终止的预清理\",\"1614\":\"49#重新标记\",\"1615\":\"49#并发清理\",\"1616\":\"49#并发重置\",\"1617\":\"49#garbage-first收集器\",\"1618\":\"49#g1简介\",\"1619\":\"49#重要概念\",\"1620\":\"49#region\",\"1621\":\"49#三色标记算法\",\"1622\":\"49#satb算法\",\"1623\":\"49#rset\",\"1624\":\"49#cset\",\"1625\":\"49#停顿预测模型\",\"1626\":\"49#gc过程\",\"1627\":\"49#回收算法\",\"1628\":\"49#收集过程\",\"1629\":\"49#young-gc\",\"1630\":\"49#mixed-gc\",\"1631\":\"49#global-concurrent-marking\",\"1632\":\"49#g1特点\",\"1633\":\"49#参数设置\",\"1634\":\"49#垃圾收集器参数总结\",\"1635\":\"49#hotspot的算法实现细节\",\"1636\":\"49#根节点枚举\",\"1637\":\"49#安全点\",\"1638\":\"49#安全区域\",\"1639\":\"49#记忆集与卡表\",\"1640\":\"49#并发的可达性分析\",\"1641\":\"49#空间分配担保\",\"1642\":\"49#内存屏障\",\"1643\":\"49#来源\",\"1644\":\"49#类型\",\"1645\":\"49#java内存屏障\",\"1646\":\"49#volatile语义中的内存屏障\",\"1647\":\"49#final语义中的内存屏障\",\"1648\":\"49#性能监控、故障处理工具\",\"1649\":\"49#基础故障处理工具\",\"1650\":\"49#可视化故障处理工具\",\"1651\":\"49#jvisualvm\",\"1652\":\"49#jconsole\",\"1653\":\"49#class类文件的结构\",\"1654\":\"49#魔数与class文件的版本\",\"1655\":\"49#常量池\",\"1656\":\"49#访问标志\",\"1657\":\"49#类索引、父类索引与接口索引集合\",\"1658\":\"49#字段表集合\",\"1659\":\"49#方法表集合\",\"1660\":\"49#属性表集合\",\"1661\":\"49#字节码指令\",\"1662\":\"49#字节码与数据类型\",\"1663\":\"49#类加载过程\",\"1664\":\"49#加载\",\"1665\":\"49#验证\",\"1666\":\"49#准备\",\"1667\":\"49#解析\",\"1668\":\"49#初始化\",\"1669\":\"49#类加载器\",\"1670\":\"49#类与类加载器\",\"1671\":\"49#双亲委派模型\",\"1672\":\"49#破坏双亲委派模型\",\"1673\":\"49#spi机制\",\"1674\":\"49#简介\",\"1675\":\"49#jdk-spi\",\"1676\":\"49#spring-spi\",\"1677\":\"49#运行时栈帧结构\",\"1678\":\"49#局部变量表\",\"1679\":\"49#操作数栈\",\"1680\":\"49#动态连接\",\"1681\":\"49#方法返回地址\",\"1682\":\"49#附加信息\",\"1683\":\"49#方法调用\",\"1684\":\"49#解析-1\",\"1685\":\"49#分派\",\"1686\":\"49#java内存模型\",\"1687\":\"49#主内存与工作内存\",\"1688\":\"49#volatile型变量\",\"1689\":\"49#java与线程\",\"1690\":\"49#线程的实现\",\"1691\":\"49#java线程调度\",\"1692\":\"49#线程状态\",\"1693\":\"49#线程安全\",\"1694\":\"49#互斥同步\",\"1695\":\"49#非阻塞同步\",\"1696\":\"49#无同步方案\",\"1697\":\"49#锁优化\",\"1698\":\"49#自旋锁与自适应自旋\",\"1699\":\"49#锁消除\",\"1700\":\"49#锁粗化\",\"1701\":\"49#轻量级锁\",\"1702\":\"49#偏向锁\",\"1703\":\"50\",\"1704\":\"50#概念\",\"1705\":\"50#消息模型\",\"1706\":\"50#生产者组\",\"1707\":\"50#消费者组\",\"1708\":\"50#集群消费\",\"1709\":\"50#广播消息\",\"1710\":\"50#标签\",\"1711\":\"50#队列\",\"1712\":\"50#协议\",\"1713\":\"50#特性\",\"1714\":\"50#消息顺序\",\"1715\":\"50#消息重试\",\"1716\":\"50#延迟队列\",\"1717\":\"50#死信队列\",\"1718\":\"50#技术架构\",\"1719\":\"50#集群工作流程\",\"1720\":\"50#架构设计\",\"1721\":\"50#消息存储\",\"1722\":\"50#消息存储整体架构\",\"1723\":\"50#页缓存与内存映射\",\"1724\":\"50#消息刷盘\",\"1725\":\"50#通信机制\",\"1726\":\"50#rocketmq通信类结构\",\"1727\":\"50#reactor线程设计\",\"1728\":\"50#消息过滤\",\"1729\":\"50#负载均衡\",\"1730\":\"50#生产者\",\"1731\":\"50#tags的使用\",\"1732\":\"50#keys的使用\",\"1733\":\"50#选择oneway形式发送\",\"1734\":\"50#消费者\",\"1735\":\"50#消费过程幂等\",\"1736\":\"50#提升消费速度\",\"1737\":\"50#顺序消费\",\"1738\":\"50#并发消费\",\"1739\":\"50#顺序消费-1\",\"1740\":\"50#全局有序\",\"1741\":\"50#分区有序\",\"1742\":\"50#订阅关系的一致性\",\"1743\":\"50#正确的订阅关系\",\"1744\":\"50#错误的订阅关系\",\"1745\":\"50#订阅了不同的topic\",\"1746\":\"50#订阅了不同tag\",\"1747\":\"50#订阅不同数量的topic\",\"1748\":\"50#配置管理\",\"1749\":\"50#依赖管理\",\"1750\":\"50#外部化配置\",\"1751\":\"50#配置类\",\"1752\":\"50#发送消息\",\"1753\":\"50#发送普通消息\",\"1754\":\"50#发送事务消息\",\"1755\":\"50#接收消息\",\"1756\":\"50#接收普通消息\",\"1757\":\"50#接收事务消息\",\"1758\":\"50#消息发送过程\",\"1759\":\"50#选择发送的路由\",\"1760\":\"50#向broker发送消息\",\"1761\":\"50#消息存储过程\",\"1762\":\"50#写入文件\",\"1763\":\"50#文件可以完全存储消息\",\"1764\":\"50#文件不可以完全存储消息\",\"1765\":\"50#消息刷盘-1\",\"1766\":\"50#消息接收过程\",\"1767\":\"50#消费者注册\",\"1768\":\"50#消息队列\",\"1769\":\"50#广播模式\",\"1770\":\"50#集群模式\",\"1771\":\"50#平均分配策略\",\"1772\":\"50#平均分配轮询策略\",\"1773\":\"50#一致性哈希策略\",\"1774\":\"50#broker消费队列\",\"1775\":\"50#集群模式-1\",\"1776\":\"50#广播模式-1\",\"1777\":\"50#消费消息\",\"1778\":\"50#并发消费-1\",\"1779\":\"50#有序消费\",\"1780\":\"50#消息过滤过程\",\"1781\":\"50#消息过滤类型\",\"1782\":\"50#标签匹配\",\"1783\":\"50#sql匹配\",\"1784\":\"50#注册过滤信息\",\"1785\":\"50#生成bloomfilterdata\",\"1786\":\"50#编译sql语句\",\"1787\":\"50#计算位映射\",\"1788\":\"50#存储位映射\",\"1789\":\"50#消息过滤-1\",\"1790\":\"50#自定义匹配\",\"1791\":\"50#过滤服务器\",\"1792\":\"50#过滤类\",\"1793\":\"50#过滤消息\",\"1794\":\"50#消息索引流程\",\"1795\":\"50#消息查询\",\"1796\":\"50#id-偏移量-查询\",\"1797\":\"50#消息索引服务\",\"1798\":\"50#索引文件结构\",\"1799\":\"50#添加消息\",\"1800\":\"50#查询消息\",\"1801\":\"50#唯一键查询\",\"1802\":\"50#键查询消息\",\"1803\":\"50#定时消息和重试消息\",\"1804\":\"50#定时消息\",\"1805\":\"50#定时消息存储\",\"1806\":\"50#消息重试-1\",\"1807\":\"50#producer消息发送重试\",\"1808\":\"50#consumer消息接收重试\",\"1809\":\"50#主备同步\",\"1810\":\"50#建立连接\",\"1811\":\"50#数据传输\",\"1812\":\"50#消息异步传输\",\"1813\":\"50#消息同步传输\",\"1814\":\"50#消费建议\",\"1815\":\"50#异常处理\",\"1816\":\"50#事务消息\",\"1817\":\"50#发送事务消息-1\",\"1818\":\"50#接收事务消息-1\",\"1819\":\"50#接收事务准备消息\",\"1820\":\"50#接收事务结束的消息\",\"1821\":\"50#扫描事务状态\",\"1822\":\"50#server定时扫描\",\"1823\":\"50#server检查事务状态\",\"1824\":\"50#客户端检查事务状态\",\"1825\":\"50#acl权限控制\",\"1826\":\"50#使用示例\",\"1827\":\"50#rpchook\",\"1828\":\"50#aclclientrpchook\",\"1829\":\"50#生成签名\",\"1830\":\"50#添加扩展字段\",\"1831\":\"50#broker权限验证\",\"1832\":\"50#校验权限\",\"1833\":\"50#acl权限管理器\",\"1834\":\"50#逻辑队列\",\"1835\":\"50#架构实现\",\"1836\":\"50#实现\",\"1837\":\"50#监听者模式\",\"1838\":\"51\",\"1839\":\"51#zookeeper特性与节点数据类型\",\"1840\":\"51#zookeeper经典应用场景\",\"1841\":\"51#zookeeper集群leader选举\",\"1842\":\"51#zookeeper集群与watcher监听机制\",\"1843\":\"52\",\"1844\":\"53\",\"1845\":\"54\",\"1846\":\"54#学习路线概览\",\"1847\":\"54#第一阶段-java-基础\",\"1848\":\"54#第二阶段-leetcode\",\"1849\":\"54#数据结构\",\"1850\":\"54#算法\",\"1851\":\"54#第三阶段-数据库\",\"1852\":\"54#mysql\",\"1853\":\"54#redis\",\"1854\":\"54#第四阶段-java-web\",\"1855\":\"54#web前端\",\"1856\":\"54#web后端\",\"1857\":\"54#第五阶段-主流框架\",\"1858\":\"54#maven\",\"1859\":\"54#git\",\"1860\":\"54#ssm框架\",\"1861\":\"54#spring-boot\",\"1862\":\"54#第六阶段-服务器中间件\",\"1863\":\"54#mq\",\"1864\":\"54#elasticsearch\",\"1865\":\"54#项目实践\",\"1866\":\"54#第七阶段-微服务和分布式\",\"1867\":\"54#spring-cloud\",\"1868\":\"54#dubbo\",\"1869\":\"54#zookeeper\",\"1870\":\"54#第八阶段-进阶优化\",\"1871\":\"54#end\",\"1872\":\"55\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2,10],\"1\":[1,24],\"2\":[1,28],\"3\":[1,29],\"4\":[3,28],\"5\":[1],\"6\":[1,5],\"7\":[1,1],\"8\":[1,9],\"9\":[1,9],\"10\":[1,3],\"11\":[1],\"12\":[1],\"13\":[6],\"14\":[5],\"15\":[2],\"16\":[4],\"17\":[6],\"18\":[2],\"19\":[2],\"20\":[2],\"21\":[1],\"22\":[2],\"23\":[2],\"24\":[2],\"25\":[2],\"26\":[2],\"27\":[2],\"28\":[2],\"29\":[2],\"30\":[2],\"31\":[1],\"32\":[4],\"33\":[2],\"34\":[2],\"35\":[3],\"36\":[3],\"37\":[4],\"38\":[3],\"39\":[2],\"40\":[3],\"41\":[2],\"42\":[2],\"43\":[2],\"44\":[2],\"45\":[2],\"46\":[2],\"47\":[2],\"48\":[1],\"49\":[2],\"50\":[2],\"51\":[2],\"52\":[2],\"53\":[3],\"54\":[2],\"55\":[2],\"56\":[2],\"57\":[2],\"58\":[2],\"59\":[2],\"60\":[2],\"61\":[2],\"62\":[2],\"63\":[2],\"64\":[2],\"65\":[2],\"66\":[2],\"67\":[3],\"68\":[2],\"69\":[2],\"70\":[2],\"71\":[3],\"72\":[2],\"73\":[6],\"74\":[3],\"75\":[3],\"76\":[3],\"77\":[2],\"78\":[2],\"79\":[2],\"80\":[7],\"81\":[2],\"82\":[3],\"83\":[2],\"84\":[4],\"85\":[2],\"86\":[2],\"87\":[2],\"88\":[2],\"89\":[2],\"90\":[4],\"91\":[3],\"92\":[3],\"93\":[1],\"94\":[2],\"95\":[3],\"96\":[3],\"97\":[4],\"98\":[4],\"99\":[2],\"100\":[2],\"101\":[1],\"102\":[4],\"103\":[3],\"104\":[2],\"105\":[4],\"106\":[3],\"107\":[2],\"108\":[2],\"109\":[4],\"110\":[4],\"111\":[2],\"112\":[3],\"113\":[2],\"114\":[2],\"115\":[2],\"116\":[2],\"117\":[2],\"118\":[3],\"119\":[2],\"120\":[2],\"121\":[3],\"122\":[3],\"123\":[3],\"124\":[2],\"125\":[2],\"126\":[2],\"127\":[2],\"128\":[2],\"129\":[2],\"130\":[3],\"131\":[3],\"132\":[1],\"133\":[2],\"134\":[5],\"135\":[1],\"136\":[1],\"137\":[1],\"138\":[2],\"139\":[2],\"140\":[2],\"141\":[3],\"142\":[2],\"143\":[3],\"144\":[2],\"145\":[2],\"146\":[2],\"147\":[2],\"148\":[2],\"149\":[2],\"150\":[2],\"151\":[3],\"152\":[2],\"153\":[3],\"154\":[2],\"155\":[1],\"156\":[2],\"157\":[4],\"158\":[1],\"159\":[3],\"160\":[2],\"161\":[2],\"162\":[2],\"163\":[2],\"164\":[2],\"165\":[3],\"166\":[6],\"167\":[2],\"168\":[2],\"169\":[2],\"170\":[2],\"171\":[2],\"172\":[2],\"173\":[2],\"174\":[1],\"175\":[3],\"176\":[2],\"177\":[3],\"178\":[2],\"179\":[2],\"180\":[3],\"181\":[1],\"182\":[2],\"183\":[2],\"184\":[4],\"185\":[2],\"186\":[2],\"187\":[2],\"188\":[5],\"189\":[3],\"190\":[3],\"191\":[1],\"192\":[3],\"193\":[2],\"194\":[2],\"195\":[3],\"196\":[1],\"197\":[3],\"198\":[4],\"199\":[3],\"200\":[2],\"201\":[2],\"202\":[2],\"203\":[3],\"204\":[2],\"205\":[3],\"206\":[2],\"207\":[3],\"208\":[3],\"209\":[2],\"210\":[1],\"211\":[2],\"212\":[3],\"213\":[3],\"214\":[2],\"215\":[2],\"216\":[2],\"217\":[2],\"218\":[3],\"219\":[2],\"220\":[2],\"221\":[5],\"222\":[1],\"223\":[3],\"224\":[4],\"225\":[3],\"226\":[3],\"227\":[3],\"228\":[4],\"229\":[2],\"230\":[1],\"231\":[3],\"232\":[3],\"233\":[2],\"234\":[3],\"235\":[4],\"236\":[2],\"237\":[4],\"238\":[2],\"239\":[4],\"240\":[2],\"241\":[3],\"242\":[2],\"243\":[2],\"244\":[2],\"245\":[2],\"246\":[3],\"247\":[2],\"248\":[2],\"249\":[3],\"250\":[2],\"251\":[1],\"252\":[3],\"253\":[2],\"254\":[2],\"255\":[2],\"256\":[2],\"257\":[2],\"258\":[4],\"259\":[2],\"260\":[2],\"261\":[1],\"262\":[2],\"263\":[2],\"264\":[1],\"265\":[2],\"266\":[2],\"267\":[1],\"268\":[2],\"269\":[1],\"270\":[2],\"271\":[2],\"272\":[2],\"273\":[2],\"274\":[1],\"275\":[1],\"276\":[1],\"277\":[1],\"278\":[1],\"279\":[2],\"280\":[2,17],\"281\":[3],\"282\":[1,14],\"283\":[1],\"284\":[1,2],\"285\":[1,23],\"286\":[1],\"287\":[1,3],\"288\":[1,27],\"289\":[1],\"290\":[1,15],\"291\":[1],\"292\":[1],\"293\":[1,30],\"294\":[1],\"295\":[1,6],\"296\":[1,22],\"297\":[1],\"298\":[1],\"299\":[1],\"300\":[1],\"301\":[1,22],\"302\":[1,129],\"303\":[1],\"304\":[1,23],\"305\":[1,22],\"306\":[1],\"307\":[1,55],\"308\":[1],\"309\":[2],\"310\":[1,21],\"311\":[1,33],\"312\":[1],\"313\":[1,22],\"314\":[1,23],\"315\":[1,18],\"316\":[1,27],\"317\":[1,40],\"318\":[1,47],\"319\":[1,50],\"320\":[1,7],\"321\":[1,10],\"322\":[1,5],\"323\":[1,5],\"324\":[1],\"325\":[1,18],\"326\":[1,17],\"327\":[1,3],\"328\":[1,14],\"329\":[1,60],\"330\":[1,14],\"331\":[1,2],\"332\":[1,51],\"333\":[1,11],\"334\":[1,10],\"335\":[1,5],\"336\":[1],\"337\":[1,22],\"338\":[1,11],\"339\":[1,23],\"340\":[1,20],\"341\":[1,13],\"342\":[1,2],\"343\":[1,51],\"344\":[1,18],\"345\":[1,35],\"346\":[1,5],\"347\":[2,26],\"348\":[3,17],\"349\":[1,10],\"350\":[1,14],\"351\":[1,11],\"352\":[1],\"353\":[1,22],\"354\":[1,30],\"355\":[1],\"356\":[1,28],\"357\":[1],\"358\":[1],\"359\":[1,25],\"360\":[2,31],\"361\":[2,23],\"362\":[2,37],\"363\":[2,40],\"364\":[2,33],\"365\":[1,21],\"366\":[1,56],\"367\":[1,37],\"368\":[1,38],\"369\":[1,4],\"370\":[1],\"371\":[2,25],\"372\":[1,13],\"373\":[1,25],\"374\":[2,1],\"375\":[2,35],\"376\":[2,19],\"377\":[2,25],\"378\":[1,2],\"379\":[1],\"380\":[1,38],\"381\":[1,48],\"382\":[1],\"383\":[2,26],\"384\":[2,44],\"385\":[2,70],\"386\":[1,56],\"387\":[1,38],\"388\":[1,37],\"389\":[2,19],\"390\":[1],\"391\":[1],\"392\":[1,31],\"393\":[1,44],\"394\":[1],\"395\":[1,56],\"396\":[1,36],\"397\":[1,54],\"398\":[1,57],\"399\":[1,34],\"400\":[1,60],\"401\":[1,38],\"402\":[3,39],\"403\":[2,47],\"404\":[2,40],\"405\":[2,18],\"406\":[2,24],\"407\":[2,18],\"408\":[2,28],\"409\":[2,48],\"410\":[2,34],\"411\":[2,47],\"412\":[2,20],\"413\":[1,2],\"414\":[1],\"415\":[1,40],\"416\":[1],\"417\":[1,45],\"418\":[1],\"419\":[1,22],\"420\":[1,3],\"421\":[1,27],\"422\":[1,26],\"423\":[1],\"424\":[1,28],\"425\":[1,27],\"426\":[1,42],\"427\":[1,52],\"428\":[1,90],\"429\":[1,44],\"430\":[1,36],\"431\":[1,50],\"432\":[1,18],\"433\":[1],\"434\":[1],\"435\":[1,68],\"436\":[1],\"437\":[1,12],\"438\":[1,36],\"439\":[1,25],\"440\":[1,25],\"441\":[1,26],\"442\":[1],\"443\":[1,38],\"444\":[1],\"445\":[1],\"446\":[2,11],\"447\":[1],\"448\":[1],\"449\":[1,13],\"450\":[1],\"451\":[1],\"452\":[1],\"453\":[1],\"454\":[1,58],\"455\":[1,103],\"456\":[1,57],\"457\":[1,35],\"458\":[1,34],\"459\":[1,64],\"460\":[1,28],\"461\":[1,52],\"462\":[1,35],\"463\":[1,40],\"464\":[1,85],\"465\":[1],\"466\":[2,50],\"467\":[2,262],\"468\":[1,15],\"469\":[1,42],\"470\":[1,25],\"471\":[1,57],\"472\":[1,149],\"473\":[1,52],\"474\":[1,25],\"475\":[1,81],\"476\":[1,59],\"477\":[1,61],\"478\":[1,27],\"479\":[1,55],\"480\":[1,91],\"481\":[2,44],\"482\":[3,83],\"483\":[1,92],\"484\":[1,143],\"485\":[1,93],\"486\":[1,31],\"487\":[1,120],\"488\":[1,40],\"489\":[1,95],\"490\":[2,44],\"491\":[1,159],\"492\":[1,95],\"493\":[1,98],\"494\":[1,3],\"495\":[1,13],\"496\":[1,17],\"497\":[1],\"498\":[1,135],\"499\":[1,59],\"500\":[1,40],\"501\":[1,12],\"502\":[1,8],\"503\":[1,116],\"504\":[1,32],\"505\":[1,157],\"506\":[1,26],\"507\":[1,35],\"508\":[1,49],\"509\":[1,33],\"510\":[1,20],\"511\":[1,14],\"512\":[1,28],\"513\":[1,19],\"514\":[1,26],\"515\":[1,129],\"516\":[1],\"517\":[1,9],\"518\":[1,61],\"519\":[1,6],\"520\":[1,12],\"521\":[1,20],\"522\":[1,18],\"523\":[1,13],\"524\":[1,14],\"525\":[1,38],\"526\":[1,23],\"527\":[1,118],\"528\":[1],\"529\":[3,24],\"530\":[1,51],\"531\":[1,73],\"532\":[2,11],\"533\":[2,90],\"534\":[1,21],\"535\":[1],\"536\":[1,53],\"537\":[1,60],\"538\":[4,105],\"539\":[4,36],\"540\":[4,169],\"541\":[4,130],\"542\":[3,56],\"543\":[1,53],\"544\":[1,99],\"545\":[2,32],\"546\":[1,46],\"547\":[1,36],\"548\":[1,92],\"549\":[1,93],\"550\":[1,116],\"551\":[1,95],\"552\":[2],\"553\":[2,94],\"554\":[2,86],\"555\":[2,75],\"556\":[4,66],\"557\":[1,107],\"558\":[1,139],\"559\":[1,105],\"560\":[1,4],\"561\":[1,143],\"562\":[1,95],\"563\":[1,45],\"564\":[1],\"565\":[1,103],\"566\":[1,143],\"567\":[1,28],\"568\":[2,185],\"569\":[1,20],\"570\":[1,127],\"571\":[1,65],\"572\":[1,41],\"573\":[1,9],\"574\":[1,21],\"575\":[1,42],\"576\":[1,8],\"577\":[1,13],\"578\":[1,95],\"579\":[1,27],\"580\":[1,44],\"581\":[1,109],\"582\":[1],\"583\":[1,80],\"584\":[1,129],\"585\":[1,80],\"586\":[1],\"587\":[2,64],\"588\":[2,241],\"589\":[1],\"590\":[1,77],\"591\":[2,293],\"592\":[1,53],\"593\":[1,10],\"594\":[1,139],\"595\":[1,41],\"596\":[1,126],\"597\":[1,68],\"598\":[1,84],\"599\":[1,128],\"600\":[3,32],\"601\":[1,63],\"602\":[3,110],\"603\":[1,28],\"604\":[1,164],\"605\":[1,258],\"606\":[1,51],\"607\":[1,30],\"608\":[2,33],\"609\":[1,159],\"610\":[1,65],\"611\":[1,50],\"612\":[1,3],\"613\":[2,146],\"614\":[1,25],\"615\":[1,110],\"616\":[1,127],\"617\":[1,38],\"618\":[1,172],\"619\":[1,103],\"620\":[1,13],\"621\":[1,90],\"622\":[2,135],\"623\":[1,37],\"624\":[2,30],\"625\":[1,22],\"626\":[1,32],\"627\":[1,63],\"628\":[1,146],\"629\":[1,163],\"630\":[1,15],\"631\":[1,55],\"632\":[2,65],\"633\":[1,44],\"634\":[3,181],\"635\":[2,30],\"636\":[1,27],\"637\":[1],\"638\":[1,9],\"639\":[2,4],\"640\":[1,22],\"641\":[1,7],\"642\":[1,29],\"643\":[1,67],\"644\":[1],\"645\":[1,3],\"646\":[1,24],\"647\":[1,57],\"648\":[1],\"649\":[1],\"650\":[1,11],\"651\":[1,37],\"652\":[1],\"653\":[2],\"654\":[1,13],\"655\":[1,117],\"656\":[1,199],\"657\":[1,152],\"658\":[1,8],\"659\":[1,52],\"660\":[1,59],\"661\":[1,35],\"662\":[1,74],\"663\":[2,44],\"664\":[1,22],\"665\":[1,119],\"666\":[1,76],\"667\":[1,68],\"668\":[1,8],\"669\":[1,66],\"670\":[1,33],\"671\":[1,56],\"672\":[1,68],\"673\":[1,32],\"674\":[1,32],\"675\":[1,53],\"676\":[1,10],\"677\":[1,20],\"678\":[1,23],\"679\":[2,73],\"680\":[1,13],\"681\":[1,57],\"682\":[1,26],\"683\":[1,12],\"684\":[2,50],\"685\":[1,81],\"686\":[1,199],\"687\":[1,5],\"688\":[2,42],\"689\":[1],\"690\":[2,272],\"691\":[1,109],\"692\":[1,226],\"693\":[1,79],\"694\":[1,116],\"695\":[1,185],\"696\":[1,72],\"697\":[1],\"698\":[2,19],\"699\":[1],\"700\":[1],\"701\":[2,21],\"702\":[2,15],\"703\":[1,4],\"704\":[1,66],\"705\":[1,21],\"706\":[2,92],\"707\":[3,119],\"708\":[3,187],\"709\":[3,122],\"710\":[3,137],\"711\":[3,206],\"712\":[1],\"713\":[3,92],\"714\":[3,90],\"715\":[3,73],\"716\":[1,42],\"717\":[1,64],\"718\":[1,61],\"719\":[1,80],\"720\":[1,163],\"721\":[1,15],\"722\":[1],\"723\":[1,9],\"724\":[1,34],\"725\":[1,44],\"726\":[1,20],\"727\":[1,16],\"728\":[1,13],\"729\":[1,38],\"730\":[1,13],\"731\":[1],\"732\":[4,15],\"733\":[2,43],\"734\":[1,18],\"735\":[1,35],\"736\":[1,20],\"737\":[1,9],\"738\":[1,24],\"739\":[1,24],\"740\":[1,61],\"741\":[1,4],\"742\":[1,13],\"743\":[1,18],\"744\":[1,19],\"745\":[1,5],\"746\":[1,41],\"747\":[1,18],\"748\":[1,59],\"749\":[1],\"750\":[1],\"751\":[1],\"752\":[1],\"753\":[1],\"754\":[1],\"755\":[1,7],\"756\":[1,10],\"757\":[1,10],\"758\":[1,60],\"759\":[1],\"760\":[1,10],\"761\":[1,170],\"762\":[1],\"763\":[1,16],\"764\":[1,18],\"765\":[1],\"766\":[1,14],\"767\":[1,19],\"768\":[1],\"769\":[1,6],\"770\":[1,23],\"771\":[3],\"772\":[1],\"773\":[1],\"774\":[1],\"775\":[1],\"776\":[1],\"777\":[1],\"778\":[1],\"779\":[1],\"780\":[1],\"781\":[3],\"782\":[1],\"783\":[1],\"784\":[1],\"785\":[1],\"786\":[1],\"787\":[1],\"788\":[1],\"789\":[1],\"790\":[1],\"791\":[1],\"792\":[1],\"793\":[1],\"794\":[1],\"795\":[1],\"796\":[1,11],\"797\":[2],\"798\":[1,23],\"799\":[1],\"800\":[1,17],\"801\":[1],\"802\":[1],\"803\":[1],\"804\":[1,3],\"805\":[1],\"806\":[1,173],\"807\":[1,16],\"808\":[1],\"809\":[1],\"810\":[1],\"811\":[1],\"812\":[1],\"813\":[1],\"814\":[1],\"815\":[1],\"816\":[2],\"817\":[1],\"818\":[1],\"819\":[1],\"820\":[1],\"821\":[1],\"822\":[1],\"823\":[1],\"824\":[1],\"825\":[1],\"826\":[2],\"827\":[1],\"828\":[1],\"829\":[1],\"830\":[1],\"831\":[1],\"832\":[1],\"833\":[1],\"834\":[2],\"835\":[1],\"836\":[1],\"837\":[1],\"838\":[1],\"839\":[1],\"840\":[1],\"841\":[1],\"842\":[1],\"843\":[1],\"844\":[1],\"845\":[1],\"846\":[1],\"847\":[1],\"848\":[1],\"849\":[1],\"850\":[1],\"851\":[1],\"852\":[1],\"853\":[1],\"854\":[1],\"855\":[1],\"856\":[1],\"857\":[1],\"858\":[1],\"859\":[1],\"860\":[1],\"861\":[1],\"862\":[1],\"863\":[1],\"864\":[1],\"865\":[1],\"866\":[1],\"867\":[1],\"868\":[1],\"869\":[1],\"870\":[1],\"871\":[1],\"872\":[1],\"873\":[1],\"874\":[1],\"875\":[1],\"876\":[1],\"877\":[1],\"878\":[1],\"879\":[1],\"880\":[1],\"881\":[1],\"882\":[1],\"883\":[1],\"884\":[1],\"885\":[1],\"886\":[1],\"887\":[1],\"888\":[1],\"889\":[1],\"890\":[1],\"891\":[1],\"892\":[1],\"893\":[1],\"894\":[1],\"895\":[1],\"896\":[1],\"897\":[2],\"898\":[1],\"899\":[2],\"900\":[2],\"901\":[2],\"902\":[2],\"903\":[1],\"904\":[1],\"905\":[1],\"906\":[1],\"907\":[1],\"908\":[1],\"909\":[2],\"910\":[1],\"911\":[1],\"912\":[1],\"913\":[3],\"914\":[1],\"915\":[2],\"916\":[3],\"917\":[2],\"918\":[1],\"919\":[1],\"920\":[1],\"921\":[1],\"922\":[4],\"923\":[2],\"924\":[2],\"925\":[1],\"926\":[3],\"927\":[1],\"928\":[1],\"929\":[2],\"930\":[2],\"931\":[2],\"932\":[2],\"933\":[2],\"934\":[2],\"935\":[2],\"936\":[2],\"937\":[1],\"938\":[1],\"939\":[1],\"940\":[3],\"941\":[4],\"942\":[3],\"943\":[1],\"944\":[1],\"945\":[1],\"946\":[1],\"947\":[1],\"948\":[2],\"949\":[1],\"950\":[2],\"951\":[3],\"952\":[2],\"953\":[3],\"954\":[1],\"955\":[1],\"956\":[1],\"957\":[1],\"958\":[1],\"959\":[1],\"960\":[2],\"961\":[2],\"962\":[1],\"963\":[1],\"964\":[1],\"965\":[1],\"966\":[1],\"967\":[1],\"968\":[1],\"969\":[1],\"970\":[1],\"971\":[1],\"972\":[1],\"973\":[1],\"974\":[1],\"975\":[1],\"976\":[1],\"977\":[2],\"978\":[2],\"979\":[5],\"980\":[5],\"981\":[3],\"982\":[4],\"983\":[4],\"984\":[4],\"985\":[5],\"986\":[5],\"987\":[3],\"988\":[3],\"989\":[2],\"990\":[1],\"991\":[5],\"992\":[3],\"993\":[5],\"994\":[1],\"995\":[1],\"996\":[1],\"997\":[1],\"998\":[1],\"999\":[1],\"1000\":[1],\"1001\":[1],\"1002\":[1],\"1003\":[1],\"1004\":[1],\"1005\":[1],\"1006\":[1],\"1007\":[1],\"1008\":[1],\"1009\":[1],\"1010\":[1],\"1011\":[1],\"1012\":[1],\"1013\":[1],\"1014\":[3],\"1015\":[2],\"1016\":[3],\"1017\":[2],\"1018\":[1],\"1019\":[1],\"1020\":[1],\"1021\":[1],\"1022\":[1],\"1023\":[2],\"1024\":[1],\"1025\":[1],\"1026\":[4],\"1027\":[2],\"1028\":[3],\"1029\":[1],\"1030\":[2],\"1031\":[1],\"1032\":[2],\"1033\":[2],\"1034\":[2],\"1035\":[1],\"1036\":[1],\"1037\":[1],\"1038\":[1],\"1039\":[1],\"1040\":[1],\"1041\":[4],\"1042\":[3],\"1043\":[3],\"1044\":[1],\"1045\":[1],\"1046\":[1],\"1047\":[1],\"1048\":[1],\"1049\":[1],\"1050\":[1],\"1051\":[1],\"1052\":[2],\"1053\":[1],\"1054\":[1],\"1055\":[2],\"1056\":[1],\"1057\":[1],\"1058\":[1],\"1059\":[1],\"1060\":[1],\"1061\":[1],\"1062\":[1],\"1063\":[3],\"1064\":[3],\"1065\":[3],\"1066\":[1],\"1067\":[1],\"1068\":[1],\"1069\":[1],\"1070\":[1],\"1071\":[2],\"1072\":[1],\"1073\":[1],\"1074\":[1],\"1075\":[2],\"1076\":[2],\"1077\":[2],\"1078\":[2],\"1079\":[2],\"1080\":[1],\"1081\":[2],\"1082\":[1],\"1083\":[2],\"1084\":[1],\"1085\":[2],\"1086\":[1],\"1087\":[3],\"1088\":[1],\"1089\":[2],\"1090\":[1],\"1091\":[1],\"1092\":[1],\"1093\":[1],\"1094\":[1],\"1095\":[2],\"1096\":[1],\"1097\":[3],\"1098\":[3],\"1099\":[1],\"1100\":[1],\"1101\":[1],\"1102\":[1],\"1103\":[1],\"1104\":[1],\"1105\":[1],\"1106\":[1],\"1107\":[1],\"1108\":[1],\"1109\":[1],\"1110\":[3],\"1111\":[2],\"1112\":[1],\"1113\":[1],\"1114\":[1],\"1115\":[1],\"1116\":[1],\"1117\":[1],\"1118\":[1],\"1119\":[1],\"1120\":[1],\"1121\":[1],\"1122\":[1],\"1123\":[1],\"1124\":[1],\"1125\":[2],\"1126\":[3],\"1127\":[1],\"1128\":[1],\"1129\":[1],\"1130\":[1],\"1131\":[2],\"1132\":[2],\"1133\":[1],\"1134\":[1],\"1135\":[1],\"1136\":[2],\"1137\":[1],\"1138\":[2],\"1139\":[1],\"1140\":[1],\"1141\":[2],\"1142\":[2],\"1143\":[2],\"1144\":[1],\"1145\":[1],\"1146\":[1],\"1147\":[1],\"1148\":[1],\"1149\":[1],\"1150\":[1],\"1151\":[1],\"1152\":[2],\"1153\":[3],\"1154\":[3],\"1155\":[1],\"1156\":[1],\"1157\":[1],\"1158\":[1],\"1159\":[2],\"1160\":[1],\"1161\":[1],\"1162\":[1],\"1163\":[1],\"1164\":[1],\"1165\":[1],\"1166\":[1],\"1167\":[1],\"1168\":[1],\"1169\":[1],\"1170\":[1],\"1171\":[1],\"1172\":[1],\"1173\":[1],\"1174\":[1],\"1175\":[1],\"1176\":[2],\"1177\":[1],\"1178\":[2],\"1179\":[2],\"1180\":[2],\"1181\":[1],\"1182\":[2],\"1183\":[2],\"1184\":[2],\"1185\":[2],\"1186\":[1],\"1187\":[1],\"1188\":[1],\"1189\":[2],\"1190\":[2],\"1191\":[4],\"1192\":[1],\"1193\":[1],\"1194\":[1],\"1195\":[3],\"1196\":[2],\"1197\":[4],\"1198\":[1],\"1199\":[1],\"1200\":[1],\"1201\":[1],\"1202\":[1],\"1203\":[1],\"1204\":[1],\"1205\":[2],\"1206\":[1],\"1207\":[1],\"1208\":[2],\"1209\":[1],\"1210\":[1],\"1211\":[1],\"1212\":[1],\"1213\":[1],\"1214\":[1],\"1215\":[1],\"1216\":[1],\"1217\":[3],\"1218\":[1],\"1219\":[2],\"1220\":[2],\"1221\":[2],\"1222\":[1],\"1223\":[1],\"1224\":[1],\"1225\":[1],\"1226\":[2],\"1227\":[1],\"1228\":[2],\"1229\":[2],\"1230\":[3],\"1231\":[2],\"1232\":[1],\"1233\":[1],\"1234\":[2],\"1235\":[1],\"1236\":[1],\"1237\":[1],\"1238\":[1],\"1239\":[2],\"1240\":[2],\"1241\":[2],\"1242\":[1],\"1243\":[1],\"1244\":[1],\"1245\":[1],\"1246\":[1],\"1247\":[2],\"1248\":[1],\"1249\":[1],\"1250\":[1],\"1251\":[1],\"1252\":[1],\"1253\":[1],\"1254\":[1],\"1255\":[1],\"1256\":[2],\"1257\":[2],\"1258\":[2],\"1259\":[1],\"1260\":[2],\"1261\":[1],\"1262\":[1],\"1263\":[1],\"1264\":[1],\"1265\":[1],\"1266\":[3],\"1267\":[4],\"1268\":[1],\"1269\":[2],\"1270\":[2],\"1271\":[2],\"1272\":[2],\"1273\":[1],\"1274\":[1],\"1275\":[2],\"1276\":[1],\"1277\":[1],\"1278\":[1],\"1279\":[1],\"1280\":[1],\"1281\":[1],\"1282\":[1],\"1283\":[1],\"1284\":[1],\"1285\":[1],\"1286\":[2],\"1287\":[1],\"1288\":[1],\"1289\":[3],\"1290\":[2],\"1291\":[2],\"1292\":[1],\"1293\":[1],\"1294\":[1],\"1295\":[1],\"1296\":[2],\"1297\":[1],\"1298\":[1],\"1299\":[2],\"1300\":[1],\"1301\":[1],\"1302\":[1],\"1303\":[2],\"1304\":[2],\"1305\":[2],\"1306\":[1],\"1307\":[1],\"1308\":[2],\"1309\":[1],\"1310\":[1],\"1311\":[2],\"1312\":[1],\"1313\":[2],\"1314\":[1],\"1315\":[1],\"1316\":[1],\"1317\":[1],\"1318\":[2],\"1319\":[1],\"1320\":[3],\"1321\":[2],\"1322\":[2],\"1323\":[1],\"1324\":[1],\"1325\":[1],\"1326\":[1],\"1327\":[1],\"1328\":[1],\"1329\":[1],\"1330\":[1],\"1331\":[1],\"1332\":[1],\"1333\":[1],\"1334\":[2],\"1335\":[2],\"1336\":[1],\"1337\":[1],\"1338\":[2],\"1339\":[2],\"1340\":[1],\"1341\":[1],\"1342\":[2],\"1343\":[4],\"1344\":[2],\"1345\":[2],\"1346\":[1],\"1347\":[1,28],\"1348\":[1,10],\"1349\":[1],\"1350\":[1,97],\"1351\":[1,72],\"1352\":[3,80],\"1353\":[1,63],\"1354\":[1,90],\"1355\":[1],\"1356\":[1,264],\"1357\":[1,157],\"1358\":[1],\"1359\":[1,65],\"1360\":[1,129],\"1361\":[1,94],\"1362\":[1,159],\"1363\":[1,26],\"1364\":[1,57],\"1365\":[1,30],\"1366\":[1,9],\"1367\":[1,69],\"1368\":[1,18],\"1369\":[1,7],\"1370\":[1,12],\"1371\":[1,22],\"1372\":[1,20],\"1373\":[1,23],\"1374\":[1],\"1375\":[1,108],\"1376\":[1,8],\"1377\":[1,26],\"1378\":[1,118],\"1379\":[1,123],\"1380\":[1,182],\"1381\":[1,2],\"1382\":[1,4],\"1383\":[1,43],\"1384\":[1],\"1385\":[1],\"1386\":[1,66],\"1387\":[1,111],\"1388\":[1,13],\"1389\":[1],\"1390\":[1,7],\"1391\":[1,10],\"1392\":[1],\"1393\":[1,17],\"1394\":[1,116],\"1395\":[1,65],\"1396\":[1,64],\"1397\":[1,75],\"1398\":[1,55],\"1399\":[1],\"1400\":[1],\"1401\":[1,28],\"1402\":[1],\"1403\":[1,67],\"1404\":[3,62],\"1405\":[3,59],\"1406\":[1],\"1407\":[2,47],\"1408\":[1,57],\"1409\":[1],\"1410\":[3,69],\"1411\":[2,55],\"1412\":[2,48],\"1413\":[1,34],\"1414\":[1],\"1415\":[1,23],\"1416\":[1,11],\"1417\":[1,7],\"1418\":[1],\"1419\":[1,26],\"1420\":[1],\"1421\":[1,46],\"1422\":[1,11],\"1423\":[1,148],\"1424\":[1],\"1425\":[1,100],\"1426\":[1,113],\"1427\":[1,180],\"1428\":[1,99],\"1429\":[1],\"1430\":[2,123],\"1431\":[2,330],\"1432\":[1,10],\"1433\":[1],\"1434\":[1,33],\"1435\":[1,10],\"1436\":[1,6],\"1437\":[1,13],\"1438\":[1,64],\"1439\":[1],\"1440\":[1,23],\"1441\":[1,26],\"1442\":[1,53],\"1443\":[1,17],\"1444\":[3,16],\"1445\":[3,15],\"1446\":[1,33],\"1447\":[1,38],\"1448\":[1,10],\"1449\":[1,18],\"1450\":[1,98],\"1451\":[1,151],\"1452\":[1,111],\"1453\":[1,55],\"1454\":[1],\"1455\":[1,6],\"1456\":[1,30],\"1457\":[1,43],\"1458\":[1,14],\"1459\":[1,31],\"1460\":[6,49],\"1461\":[4,37],\"1462\":[1,44],\"1463\":[1,6],\"1464\":[3,53],\"1465\":[3,47],\"1466\":[2],\"1467\":[1],\"1468\":[1,120],\"1469\":[1,58],\"1470\":[1,164],\"1471\":[1,276],\"1472\":[2,193],\"1473\":[1],\"1474\":[1,139],\"1475\":[1,272],\"1476\":[1,225],\"1477\":[1,125],\"1478\":[1,150],\"1479\":[1,38],\"1480\":[1,105],\"1481\":[1,57],\"1482\":[1,103],\"1483\":[1,38],\"1484\":[1,226],\"1485\":[1,282],\"1486\":[1,244],\"1487\":[1,165],\"1488\":[1,103],\"1489\":[1,97],\"1490\":[1,217],\"1491\":[1,194],\"1492\":[1,564],\"1493\":[1,189],\"1494\":[1,366],\"1495\":[1,529],\"1496\":[1,575],\"1497\":[1,1100],\"1498\":[1,395],\"1499\":[1,287],\"1500\":[1,587],\"1501\":[1,17],\"1502\":[2],\"1503\":[1,7],\"1504\":[2,10],\"1505\":[1],\"1506\":[1],\"1507\":[1,47],\"1508\":[1],\"1509\":[1,51],\"1510\":[1,29],\"1511\":[1,20],\"1512\":[1,24],\"1513\":[1,79],\"1514\":[1,25],\"1515\":[1,52],\"1516\":[1,42],\"1517\":[1,20],\"1518\":[1,10],\"1519\":[1],\"1520\":[1],\"1521\":[1,29],\"1522\":[1,34],\"1523\":[3,58],\"1524\":[1,781],\"1525\":[1,406],\"1526\":[1,61],\"1527\":[1,134],\"1528\":[1,181],\"1529\":[1,59],\"1530\":[1,57],\"1531\":[2,234],\"1532\":[1,238],\"1533\":[2,4],\"1534\":[2,75],\"1535\":[2,100],\"1536\":[4,17],\"1537\":[2,6],\"1538\":[3,7],\"1539\":[1],\"1540\":[1,157],\"1541\":[1,102],\"1542\":[1,2],\"1543\":[1,11],\"1544\":[1,2],\"1545\":[1,10],\"1546\":[1,8],\"1547\":[1],\"1548\":[1],\"1549\":[1],\"1550\":[1],\"1551\":[1],\"1552\":[1],\"1553\":[1],\"1554\":[1],\"1555\":[1],\"1556\":[2],\"1557\":[1],\"1558\":[2],\"1559\":[1],\"1560\":[1],\"1561\":[1,67],\"1562\":[1],\"1563\":[1,7],\"1564\":[1,5],\"1565\":[1,56],\"1566\":[1,10],\"1567\":[1,57],\"1568\":[1],\"1569\":[1,8],\"1570\":[1,9],\"1571\":[1,27],\"1572\":[1],\"1573\":[1],\"1574\":[1],\"1575\":[1],\"1576\":[1],\"1577\":[1],\"1578\":[1],\"1579\":[1],\"1580\":[1],\"1581\":[1],\"1582\":[1],\"1583\":[1],\"1584\":[1],\"1585\":[1],\"1586\":[1],\"1587\":[1],\"1588\":[1],\"1589\":[1],\"1590\":[1],\"1591\":[1],\"1592\":[1],\"1593\":[1],\"1594\":[1],\"1595\":[1],\"1596\":[1],\"1597\":[1],\"1598\":[2],\"1599\":[2],\"1600\":[2],\"1601\":[1],\"1602\":[1],\"1603\":[1],\"1604\":[2],\"1605\":[2],\"1606\":[2],\"1607\":[1],\"1608\":[1],\"1609\":[1],\"1610\":[1],\"1611\":[1],\"1612\":[1],\"1613\":[1],\"1614\":[1],\"1615\":[1],\"1616\":[1],\"1617\":[2],\"1618\":[1],\"1619\":[1],\"1620\":[1],\"1621\":[1],\"1622\":[1],\"1623\":[1],\"1624\":[1],\"1625\":[1],\"1626\":[1],\"1627\":[1],\"1628\":[1],\"1629\":[2],\"1630\":[2],\"1631\":[3],\"1632\":[1],\"1633\":[1],\"1634\":[1],\"1635\":[1],\"1636\":[1],\"1637\":[1],\"1638\":[1],\"1639\":[1],\"1640\":[1],\"1641\":[1],\"1642\":[1],\"1643\":[1],\"1644\":[1],\"1645\":[1],\"1646\":[1],\"1647\":[1],\"1648\":[2],\"1649\":[1],\"1650\":[1],\"1651\":[1],\"1652\":[1],\"1653\":[1],\"1654\":[1],\"1655\":[1],\"1656\":[1],\"1657\":[2],\"1658\":[1],\"1659\":[1],\"1660\":[1],\"1661\":[1],\"1662\":[1],\"1663\":[1],\"1664\":[1],\"1665\":[1],\"1666\":[1],\"1667\":[1],\"1668\":[1],\"1669\":[1],\"1670\":[1],\"1671\":[1],\"1672\":[1],\"1673\":[1],\"1674\":[1],\"1675\":[2],\"1676\":[2],\"1677\":[1],\"1678\":[1],\"1679\":[1],\"1680\":[1],\"1681\":[1],\"1682\":[1],\"1683\":[1],\"1684\":[1],\"1685\":[1],\"1686\":[1],\"1687\":[1],\"1688\":[1],\"1689\":[1],\"1690\":[1],\"1691\":[1],\"1692\":[1],\"1693\":[1],\"1694\":[1],\"1695\":[1],\"1696\":[1],\"1697\":[1],\"1698\":[1],\"1699\":[1],\"1700\":[1],\"1701\":[1],\"1702\":[1],\"1703\":[1],\"1704\":[1],\"1705\":[1],\"1706\":[1],\"1707\":[1],\"1708\":[1],\"1709\":[1],\"1710\":[1],\"1711\":[1],\"1712\":[1],\"1713\":[1],\"1714\":[1],\"1715\":[1],\"1716\":[1],\"1717\":[1],\"1718\":[1],\"1719\":[1],\"1720\":[1],\"1721\":[1],\"1722\":[1],\"1723\":[1],\"1724\":[1],\"1725\":[1],\"1726\":[1],\"1727\":[1],\"1728\":[1],\"1729\":[1],\"1730\":[1],\"1731\":[1],\"1732\":[1],\"1733\":[1],\"1734\":[1],\"1735\":[1],\"1736\":[1],\"1737\":[1],\"1738\":[1],\"1739\":[1],\"1740\":[1],\"1741\":[1],\"1742\":[1],\"1743\":[1],\"1744\":[1],\"1745\":[1],\"1746\":[1],\"1747\":[1],\"1748\":[1],\"1749\":[1],\"1750\":[1],\"1751\":[1],\"1752\":[1],\"1753\":[1],\"1754\":[1],\"1755\":[1],\"1756\":[1],\"1757\":[1],\"1758\":[1],\"1759\":[1],\"1760\":[1],\"1761\":[1],\"1762\":[1],\"1763\":[1],\"1764\":[1],\"1765\":[1],\"1766\":[1],\"1767\":[1],\"1768\":[1],\"1769\":[1],\"1770\":[1],\"1771\":[1],\"1772\":[1],\"1773\":[1],\"1774\":[1],\"1775\":[1],\"1776\":[1],\"1777\":[1],\"1778\":[1],\"1779\":[1],\"1780\":[1],\"1781\":[1],\"1782\":[1],\"1783\":[1],\"1784\":[1],\"1785\":[1],\"1786\":[1],\"1787\":[1],\"1788\":[1],\"1789\":[1],\"1790\":[1],\"1791\":[1],\"1792\":[1],\"1793\":[1],\"1794\":[1],\"1795\":[1],\"1796\":[3],\"1797\":[1],\"1798\":[1],\"1799\":[1],\"1800\":[1],\"1801\":[1],\"1802\":[1],\"1803\":[1],\"1804\":[1],\"1805\":[1],\"1806\":[1],\"1807\":[1],\"1808\":[1],\"1809\":[1],\"1810\":[1],\"1811\":[1],\"1812\":[1],\"1813\":[1],\"1814\":[1],\"1815\":[1],\"1816\":[1],\"1817\":[1],\"1818\":[1],\"1819\":[1],\"1820\":[1],\"1821\":[1],\"1822\":[1],\"1823\":[1],\"1824\":[1],\"1825\":[1],\"1826\":[1],\"1827\":[1],\"1828\":[1],\"1829\":[1],\"1830\":[1],\"1831\":[1],\"1832\":[1],\"1833\":[1],\"1834\":[1],\"1835\":[1],\"1836\":[1],\"1837\":[1],\"1838\":[1],\"1839\":[1],\"1840\":[1],\"1841\":[1],\"1842\":[1],\"1843\":[1,14],\"1844\":[1,64],\"1845\":[1,2],\"1846\":[1,19],\"1847\":[3,73],\"1848\":[2,14],\"1849\":[1,7],\"1850\":[1,56],\"1851\":[2],\"1852\":[1,60],\"1853\":[1,33],\"1854\":[3,6],\"1855\":[1,10],\"1856\":[1,37],\"1857\":[2,20],\"1858\":[1,28],\"1859\":[1,35],\"1860\":[1,51],\"1861\":[2,42],\"1862\":[2,6],\"1863\":[1,29],\"1864\":[1,34],\"1865\":[1,42],\"1866\":[2,6],\"1867\":[2,22],\"1868\":[1,26],\"1869\":[1,13],\"1870\":[2,45],\"1871\":[1,16],\"1872\":[1,3]},\"averageFieldLength\":[1.4287239722370537,43.217274044535685],\"storedFields\":{\"0\":{\"h\":\"Get Started\",\"t\":[\"This is a normal page, which contains VuePress basics.\"]},\"1\":{\"h\":\"Pages\",\"t\":[\"You can add markdown files in your vuepress directory, every markdown file will be converted to a page in your site.\",\"See routing for more details.\"]},\"2\":{\"h\":\"Content\",\"t\":[\"Every markdown file will be rendered to HTML, then converted to a Vue SFC.\",\"VuePress support basic markdown syntax and some extensions, you can also use Vue features in it.\"]},\"3\":{\"h\":\"Configuration\",\"t\":[\"VuePress use a .vuepress/config.js(or .ts) file as site configuration, you can use it to config your site.\",\"For client side configuration, you can create .vuepress/client.js(or .ts).\",\"Meanwhile, you can also add configuration per page with frontmatter.\"]},\"4\":{\"h\":\"Layouts and customization\",\"t\":[\"Here are common configuration controlling layout of @vuepress/theme-default:\",\"navbar\",\"sidebar\",\"Check default theme docs for full reference.\",\"You can add extra style with .vuepress/styles/index.scss file.\"]},\"5\":{\"h\":\"关于我\"},\"6\":{\"h\":\"开源项目\",\"t\":[\"软考通（Owner）\",\"代码随想录（Contributor）\"]},\"7\":{\"h\":\"社区\",\"t\":[\"掘金\"]},\"8\":{\"h\":\"技能点\",\"t\":[\"Java（⭐⭐⭐⭐⭐）\",\"Flutter（⭐⭐⭐）\",\"Vue（⭐⭐⭐）\",\"C++（⭐⭐）\",\"Python（⭐⭐）\"]},\"9\":{\"h\":\"个人经历\",\"t\":[\"2015-2019 中国矿业大学（北京）\",\"2019-2020 杭州\",\"2021-至今 深圳\"]},\"10\":{\"h\":\"联系我\",\"t\":[\"jycoder@163.com\"]},\"11\":{\"h\":\"Java面试题精选\"},\"12\":{\"h\":\"Java基础\"},\"13\":{\"h\":\"JVM、JDK 和 JRE 联系与区别？\"},\"14\":{\"h\":\"构造器 Constructor 是否可被 override?\"},\"15\":{\"h\":\"重载和重写的区别？\"},\"16\":{\"h\":\"面向对象编程三⼤特性: 封装 继承 多态\"},\"17\":{\"h\":\"String StringBuffer 和 StringBuilder 的区别是什么?\"},\"18\":{\"h\":\"String类为什么是不可变的?\"},\"19\":{\"h\":\"Integer的缓存机制？\"},\"20\":{\"h\":\"深拷贝和浅拷贝的区别？\"},\"21\":{\"h\":\"接口和抽象类的区别\"},\"22\":{\"h\":\"构造方法有哪些特性？\"},\"23\":{\"h\":\"String中hashCode的实现？\"},\"24\":{\"h\":\"hashCode和equals的作用？\"},\"25\":{\"h\":\"JDK8有哪些新特性？\"},\"26\":{\"h\":\"Java反射有哪些作用？\"},\"27\":{\"h\":\"如何使用反射获取私有属性？\"},\"28\":{\"h\":\"创建对象有哪些方式？\"},\"29\":{\"h\":\"迭代器和for循环遍历的区别？\"},\"30\":{\"h\":\"过滤器和拦截器的区别？\"},\"31\":{\"h\":\"Java集合\"},\"32\":{\"h\":\"List、Set、Map三者的区别？\"},\"33\":{\"h\":\"HashMap实现原理？\"},\"34\":{\"h\":\"HashMap为什么扩容为2倍？\"},\"35\":{\"h\":\"为什么HashMap不用LinkedList，而是选用数组？\"},\"36\":{\"h\":\"JDK1.8对HashMap有哪些优化？\"},\"37\":{\"h\":\"为什么不直接使用红黑树，而是选择先用链表，再转红黑树？\"},\"38\":{\"h\":\"HashMap不使用红黑树，而是使用二叉查找树可以吗？\"},\"39\":{\"h\":\"为什么阈值是8？\"},\"40\":{\"h\":\"当链表转为红黑树，什么时候退化为链表？\"},\"41\":{\"h\":\"HashMap在并发编程环境下有什么问题？\"},\"42\":{\"h\":\"使用可变类当HashMap的key有什么问题？\"},\"43\":{\"h\":\"如何实现一个自定义的Class作为HashMap的key？\"},\"44\":{\"h\":\"两个相同对象没有重写equals方法放到HashMap覆盖吗?\"},\"45\":{\"h\":\"HashSet实现原理？\"},\"46\":{\"h\":\"CurrentHashMap的实现原理？\"},\"47\":{\"h\":\"ArrayList的实现原理？\"},\"48\":{\"h\":\"Java并发\"},\"49\":{\"h\":\"并发编程的三要素？\"},\"50\":{\"h\":\"线程和进程的区别？\"},\"51\":{\"h\":\"守护线程和用户线程的区别？\"},\"52\":{\"h\":\"什么是线程安全？\"},\"53\":{\"h\":\"Java如何开启线程？怎么保证线程安全？\"},\"54\":{\"h\":\"线程有哪些状态？\"},\"55\":{\"h\":\"如何停止一个正在运行的线程？\"},\"56\":{\"h\":\"notify和notifyAll有什么区别？\"},\"57\":{\"h\":\"wait和sleep方法有什么区别？\"},\"58\":{\"h\":\"为什么wait和notify方法要在同步块中调用？\"},\"59\":{\"h\":\"Thread类中的yield方法有什么作用？\"},\"60\":{\"h\":\"volatile和synchronized有什么区别？\"},\"61\":{\"h\":\"volatile变量和atomic变量什么不同？\"},\"62\":{\"h\":\"interrupted和isInterrupted方法的区别？\"},\"63\":{\"h\":\"volatile能不能保证线程安全？\"},\"64\":{\"h\":\"DCL单例为什么加volatile？\"},\"65\":{\"h\":\"死锁与活锁的区别？\"},\"66\":{\"h\":\"死锁与饥饿的区别？\"},\"67\":{\"h\":\"按照线程安全的强度来区分，分为哪几类？\"},\"68\":{\"h\":\"线程安全的实现方法有哪些？\"},\"69\":{\"h\":\"锁优化技术你了解什么？\"},\"70\":{\"h\":\"Lock与synchronized有什么区别？\"},\"71\":{\"h\":\"什么是阻塞队列？阻塞队列的实现原理是什么？\"},\"72\":{\"h\":\"什么是Callable和Future？\"},\"73\":{\"h\":\"Java线程锁机制是怎样的？偏向锁、轻量级锁、重量级锁有什么区别？锁机制是如何升级的？\"},\"74\":{\"h\":\"什么是可重入锁？有哪些实现？\"},\"75\":{\"h\":\"什么是悲观锁？什么是乐观锁？\"},\"76\":{\"h\":\"谈谈你对AQS的理解，AQS如何实现可重入锁？\"},\"77\":{\"h\":\"SynchronizedMap和ConcurrentHashMap有什么区别？\"},\"78\":{\"h\":\"ConcurrentHashMap的并发度是什么？\"},\"79\":{\"h\":\"CopyOnWriteArrayList可以用于什么应用场景？\"},\"80\":{\"h\":\"有A、B、C三个线程，如何保证三个线程同时执行？如何在并发情况下保证三个线程依次执行？如何保证三个线程有序交错进行？\"},\"81\":{\"h\":\"什么是指令重排序？\"},\"82\":{\"h\":\"ThreadLocal的作用？导致内存泄漏的原因是什么？\"},\"83\":{\"h\":\"使用线程池有什么好处？\"},\"84\":{\"h\":\"线程池中submit()和execute()方法有什么区别？\"},\"85\":{\"h\":\"什么是Executors框架？\"},\"86\":{\"h\":\"线程池的拒绝策略？\"},\"87\":{\"h\":\"如何获取子线程的执行结果？\"},\"88\":{\"h\":\"如何对一个字符串快速进行排序？\"},\"89\":{\"h\":\"线程池的参数如何设置？\"},\"90\":{\"h\":\"子线程中如何获取父线程的 中的值、 的数据结构？\"},\"91\":{\"h\":\"高并发下，如何保证接口的幂等性？\"},\"92\":{\"h\":\"除了Lock和synchronized，还有什么方式可以保障线程安全？\"},\"93\":{\"h\":\"Java网络通信\"},\"94\":{\"h\":\"TCP和UDP有什么区别？\"},\"95\":{\"h\":\"TCP为什么是三次握手，而不是两次？\"},\"96\":{\"h\":\"Java有哪几种IO模型？有什么区别？\"},\"97\":{\"h\":\"Java NIO的几个核心组件是什么？分别有什么作用？\"},\"98\":{\"h\":\"select、poll、epoll有什么区别？\"},\"99\":{\"h\":\"HTTP和HTTPS的区别？\"},\"100\":{\"h\":\"三次握手和四次挥手？\"},\"101\":{\"h\":\"Java虚拟机\"},\"102\":{\"h\":\"运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？\"},\"103\":{\"h\":\"Java 创建一个对象的过程？\"},\"104\":{\"h\":\"如何访问对象？\"},\"105\":{\"h\":\"Java 内存模型的原子性、可见性和有序性是通过哪些操作实现的？\"},\"106\":{\"h\":\"什么是双亲委派机制？有什么作用？\"},\"107\":{\"h\":\"Java类加载的全过程是怎么样的？\"},\"108\":{\"h\":\"你了解分代理论吗？\"},\"109\":{\"h\":\"JDK 中有几种引用类型？分别的特点是什么？\"},\"110\":{\"h\":\"一个对象从加载到JVM，再到GC清除，都经历了什么过程？\"},\"111\":{\"h\":\"怎么样确定一个对象不是垃圾？\"},\"112\":{\"h\":\"什么是GC Root？\"},\"113\":{\"h\":\"JVM有哪些垃圾回收算法？\"},\"114\":{\"h\":\"什么是STW？\"},\"115\":{\"h\":\"JVM有哪些垃圾回收器？\"},\"116\":{\"h\":\"什么是三色标记算法？\"},\"117\":{\"h\":\"如何回收方法区？\"},\"118\":{\"h\":\"JVM 中的安全点和安全区各代表什么？\"},\"119\":{\"h\":\"写屏障你了解吗？\"},\"120\":{\"h\":\"解决并发扫描时对象消失问题的两种方案？\"},\"121\":{\"h\":\"CMS 垃圾收集器的步骤？\"},\"122\":{\"h\":\"CMS 有什么缺点？\"},\"123\":{\"h\":\"G1垃圾收集器的步骤，G1有什么优缺点？\"},\"124\":{\"h\":\"讲一下内存分配策略？\"},\"125\":{\"h\":\"内存溢出和内存泄漏的区别？\"},\"126\":{\"h\":\"如何进行JVM调优？\"},\"127\":{\"h\":\"JVM参数有哪些？\"},\"128\":{\"h\":\"虚拟机基础故障处理工具有哪些？\"},\"129\":{\"h\":\"怎么查看一个Java进程的JVM参数，谈谈你了解的JVM参数\"},\"130\":{\"h\":\"什么情况下堆内存会溢出，什么情况方法区会内存溢出？\"},\"131\":{\"h\":\"JDK8 为什么要将永久代改为元空间？\"},\"132\":{\"h\":\"Redis\"},\"133\":{\"h\":\"Redis支持哪些数据类型？\"},\"134\":{\"h\":\"什么是缓存穿透？缓存击穿？缓存雪崩？怎么解决？\"},\"135\":{\"h\":\"缓存穿透\"},\"136\":{\"h\":\"缓存击穿\"},\"137\":{\"h\":\"缓存雪崩\"},\"138\":{\"h\":\"如何保证Redis与数据库的数据一致？\"},\"139\":{\"h\":\"先删缓存，再写数据库\"},\"140\":{\"h\":\"先写数据库，再删缓存\"},\"141\":{\"h\":\"如何设计一个分布式锁？如何对锁性能进行优化？\"},\"142\":{\"h\":\"Redis的过期删除策略？\"},\"143\":{\"h\":\"RDB操作，子进程会全部复制父进程的数据吗？\"},\"144\":{\"h\":\"Redis的哨兵模式？\"},\"145\":{\"h\":\"Redis使用单线程为什么速度这么快？\"},\"146\":{\"h\":\"Redis自增命令使用？\"},\"147\":{\"h\":\"Redis如何实现消息队列？\"},\"148\":{\"h\":\"Redisson实现分布式锁的原理？\"},\"149\":{\"h\":\"Redis为什么能通过Lua脚本保证并发的线程安全？\"},\"150\":{\"h\":\"谈一下Redis事务的了解？\"},\"151\":{\"h\":\"Pipeline有什么好处，为什么要用pipeline？\"},\"152\":{\"h\":\"Redis延迟队列怎么实现的？\"},\"153\":{\"h\":\"Redis在内存不足时，内存淘汰策略是怎么样的？\"},\"154\":{\"h\":\"如何保证Redis的高可用？\"},\"155\":{\"h\":\"MySQL\"},\"156\":{\"h\":\"MySQL有哪几种数据存储引擎?\"},\"157\":{\"h\":\"什么是脏读、不可重复读、幻读？\"},\"158\":{\"h\":\"事务的基本特性和隔离级别\"},\"159\":{\"h\":\"MySQL的锁有哪些？什么是间隙锁？\"},\"160\":{\"h\":\"MySQL索引结构是什么样的？\"},\"161\":{\"h\":\"Mysql的索引结构为什么使用B+树？\"},\"162\":{\"h\":\"聚簇索引和非聚簇索引有什么区别？\"},\"163\":{\"h\":\"MySQL主键索引和普通索引有什么区别？\"},\"164\":{\"h\":\"MySQL的索引覆盖和回表是什么？\"},\"165\":{\"h\":\"MySQL集群是如何搭建的？读写分离是怎么做的？\"},\"166\":{\"h\":\"MySQL如何进行分库分表？多大数据量需要进行分库分表？分库分表的方式和分片策略由哪些？分库分表后，SQL语句执行流程是怎样的？\"},\"167\":{\"h\":\"Mysql的三种删除方式的区别？\"},\"168\":{\"h\":\"慢SQL的优化思路？\"},\"169\":{\"h\":\"limit语句会扫描全表吗？\"},\"170\":{\"h\":\"大数量分页查询该怎么优化？\"},\"171\":{\"h\":\"平时项目里面表结构是如何进行设计的？\"},\"172\":{\"h\":\"MySQL的索引类型？\"},\"173\":{\"h\":\"MySQL如何快速插入千万级数据？\"},\"174\":{\"h\":\"Elasticsearch\"},\"175\":{\"h\":\"什么是倒排索引？有什么好处？\"},\"176\":{\"h\":\"搜索引擎为什么MySQL查询快？\"},\"177\":{\"h\":\"ES了解多少？说说你们公司的ES集群架构。\"},\"178\":{\"h\":\"如何进行中文分词？\"},\"179\":{\"h\":\"ES写入数据与查询数据的原理。\"},\"180\":{\"h\":\"ES部署时，要如何进行优化？\"},\"181\":{\"h\":\"Spring面试题\"},\"182\":{\"h\":\"Spring框架中Bean的创建过程是怎样的？\"},\"183\":{\"h\":\"Spring中Bean的作用域？\"},\"184\":{\"h\":\"Spring框架中的Bean是线程安全的吗？如果线程不安全，如何处理？\"},\"185\":{\"h\":\"Spring是如何处理循环依赖问题的？\"},\"186\":{\"h\":\"Spring如何处理事务?\"},\"187\":{\"h\":\"Spring事务失效的场景有哪些？\"},\"188\":{\"h\":\"Spring MVC中的控制器是不是单例模式？如果是，如何保证线程安全？\"},\"189\":{\"h\":\"Spring MVC原理？\"},\"190\":{\"h\":\"Spring中的Service有多个实现类，怎么注入？\"},\"191\":{\"h\":\"SpringBoot面试题\"},\"192\":{\"h\":\"为什么SpringBoot的 jar可以直接运行？\"},\"193\":{\"h\":\"SpringBoot自动装配过程及实现原理？\"},\"194\":{\"h\":\"SpringBoot如何防止表单重复提交？\"},\"195\":{\"h\":\"如何自己写一个SpringBoot Starter？\"},\"196\":{\"h\":\"MyBatis面试题\"},\"197\":{\"h\":\"Mybatis接口 Mapper内的方法为什么不能重载？\"},\"198\":{\"h\":\"Mybatis的XML映射文件中，不同的XML映射文件，id是否可以重复？\"},\"199\":{\"h\":\"#{}和${}的区别是什么？\"},\"200\":{\"h\":\"当实体类中的属性名和表中的字段名不一样怎么办？\"},\"201\":{\"h\":\"执行插入语句后如何该数据的主键？\"},\"202\":{\"h\":\"模糊查询like语句该怎么写？\"},\"203\":{\"h\":\"Mybatis时如何进行分页的？分页插件的原理是什么?\"},\"204\":{\"h\":\"Mybatis有哪些动态sql标签？\"},\"205\":{\"h\":\"Mybtais动态sql有什么用？执行原理是什么？\"},\"206\":{\"h\":\"Mapper编写有哪几种方式？\"},\"207\":{\"h\":\"Mybatis的一级、二级缓存？\"},\"208\":{\"h\":\"Mybatis有二级缓存，为什么还要用Redis？\"},\"209\":{\"h\":\"Mybatis如何开启二级缓存？\"},\"210\":{\"h\":\"Netty面试题\"},\"211\":{\"h\":\"Netty有哪些应用场景？\"},\"212\":{\"h\":\"Netty核心组件有哪些？分别有什么作用？\"},\"213\":{\"h\":\"EventLoopGroup了解么?和EventLoop什么关系?\"},\"214\":{\"h\":\"Bootstrap和ServerBootstrap了解么？\"},\"215\":{\"h\":\"NioEventLoopGroup默认的构造函数会起多少线程？\"},\"216\":{\"h\":\"Netty线程模型了解么？\"},\"217\":{\"h\":\"Netty服务端和客户端的启动过程了解么？\"},\"218\":{\"h\":\"Netty长连接、心跳机制了解么？\"},\"219\":{\"h\":\"Netty的零拷贝了解么？\"},\"220\":{\"h\":\"Spring Sercuity\"},\"221\":{\"h\":\"Spring Sercuity 和 Shiro有什么区别？\"},\"222\":{\"h\":\"网络安全\"},\"223\":{\"h\":\"什么是认证和授权？如何设计一个权限认证框架？\"},\"224\":{\"h\":\"Cookie和Session有什么区别？如果没有Cookie、Seesion还能进行身份验证吗？\"},\"225\":{\"h\":\"什么是CSRF攻击？如何防止？\"},\"226\":{\"h\":\"什么是OAuth2？有哪几种认证方式？\"},\"227\":{\"h\":\"什么是JWT令牌？和普通令牌有什么区别？\"},\"228\":{\"h\":\"什么是SSO？与OAuth2.0有什么关系？\"},\"229\":{\"h\":\"如何实现单点登录系统？\"},\"230\":{\"h\":\"微服务\"},\"231\":{\"h\":\"谈谈你对微服务的理解，微服务有哪些优缺点？\"},\"232\":{\"h\":\"SpringCloud和SpringCloudAlibaba有哪些组件？都解决了什么问题？\"},\"233\":{\"h\":\"SpringCloud和Dubbo的区别？\"},\"234\":{\"h\":\"分布式事务如何处理？怎么保证事务一致性？\"},\"235\":{\"h\":\"怎么拆分微服务？怎样设计出高内聚、低耦合的微服务？\"},\"236\":{\"h\":\"有没有了解通过DDD领域驱动设计？\"},\"237\":{\"h\":\"微服务的链路追踪、持续集成、AB发布要怎么做？\"},\"238\":{\"h\":\"Nacos和Eureka的区别？\"},\"239\":{\"h\":\"Nacos配置中心，本地Resource，jar包中同级目录的配置文件加载优先级？\"},\"240\":{\"h\":\"Nacos的配置动态更新原理？\"},\"241\":{\"h\":\"使用Nacos配置中心，@Value对应的配置项如何动态更新？\"},\"242\":{\"h\":\"Nacos中命名空间和分组的概念及区别？\"},\"243\":{\"h\":\"Nacos同一个namespace中的不同的group注册的服务可以相互访问吗？\"},\"244\":{\"h\":\"Nacos服务注册的流程是怎么样的？\"},\"245\":{\"h\":\"微服务下服务a调用服务b的流程？\"},\"246\":{\"h\":\"注册中心，如何通过服务名找到服务实例？\"},\"247\":{\"h\":\"熔断和限流有什么区别？\"},\"248\":{\"h\":\"雪花算法有什么缺点？\"},\"249\":{\"h\":\"Gateway有哪些功能？如何配置动态路由？\"},\"250\":{\"h\":\"如何手写一个注册中心？\"},\"251\":{\"h\":\"消息队列\"},\"252\":{\"h\":\"ＭＱ有什么用？有哪些具体的使用场景？\"},\"253\":{\"h\":\"如何进行产品选型？\"},\"254\":{\"h\":\"如何保证消息不丢失？\"},\"255\":{\"h\":\"如何保证消费幂等性?\"},\"256\":{\"h\":\"MQ如何保证消息顺序?\"},\"257\":{\"h\":\"如何保证消息的高效读写?\"},\"258\":{\"h\":\"MQ 中消费时，业务逻辑出现异常怎么办？\"},\"259\":{\"h\":\"使用MQ如何保证分布式事务的最终一致性？\"},\"260\":{\"h\":\"Kafka如何避免重复消费？\"},\"261\":{\"h\":\"Linux命令\"},\"262\":{\"h\":\"使用cat命令如何统计文件中一个字符串出现的频率？\"},\"263\":{\"h\":\"如何查看一个应用的信息？\"},\"264\":{\"h\":\"Dokcer命令\"},\"265\":{\"h\":\"Docker常用的命令？\"},\"266\":{\"h\":\"查看所有容器的命令？\"},\"267\":{\"h\":\"Nginx\"},\"268\":{\"h\":\"Nginx如何保证高可用？\"},\"269\":{\"h\":\"设计模式\"},\"270\":{\"h\":\"列举一些JDK中用到的设计模式？\"},\"271\":{\"h\":\"列举一些Spring当中用到的设计模式？\"},\"272\":{\"h\":\"项目中有用过设计模式吗？\"},\"273\":{\"h\":\"单例模式有哪些实现方式？\"},\"274\":{\"h\":\"懒汉式\"},\"275\":{\"h\":\"饿汉式\"},\"276\":{\"h\":\"双重检查锁\"},\"277\":{\"h\":\"静态内部类\"},\"278\":{\"h\":\"枚举类\"},\"279\":{\"h\":\"单例模式有什么应用场景？\"},\"280\":{\"h\":\"Java EE简介\",\"t\":[\"Java EE 号称有十三种核心技术。它们分别是：JDBC、JNDI、EJB、RMI、Servlet、JSP、XML、JMS、Java IDL、JTS、JTA、JavaMail和JAF。\"]},\"281\":{\"h\":\"leetcode in Java\"},\"282\":{\"h\":\"常用算法\",\"t\":[\"算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。\",\"算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。\",\"算法设计的要求：正确性、可读性、健壮性、时间效率高和低存储。\"]},\"283\":{\"h\":\"递归\"},\"284\":{\"h\":\"定义\",\"t\":[\"递归从某种意义上来说和循环是等价的。\"]},\"285\":{\"h\":\"代码模板\",\"t\":[\" public void recursion(int level, param1, param2,...) { // 递归的终止条件 if (level > MAX_LEVEL) { process_result; return; } // 处理当前层逻辑 process(level, data...); // 下探到下一层 recursion(level + 1, newParam); // 如果有必要的话清理当前层不需要的全局变量或者其他东西 } \"]},\"286\":{\"h\":\"分治\"},\"287\":{\"h\":\"定义\",\"t\":[\"分治指的是将一个大问题分解为若干个小问题，分治从某种意义上和递归也是等价的。\"]},\"288\":{\"h\":\"代码模板\",\"t\":[\"public void divideConquer(problem, param1, param2,...) { // 递归的终止条件 if (problem != None) { return result; } // 准备数据 data = prepareData(problem); // 分割子问题 subProblem = splitProblem(problem, data); // 处理子问题 subResult1 = divideConquer(subProblem[0], param1, param2,...); subResult2 = divideConquer(subProblem[0], param1, param2,...); subResult3 = divideConquer(subProblem[0], param1, param2,...); ... // 合并结果 processResult(subResult1, subResult2, subResult3,...); // 清理当前状态集 } \"]},\"289\":{\"h\":\"回溯\"},\"290\":{\"h\":\"定义\",\"t\":[\"回溯法采用试错的思想，它尝试分步的去解决一个问题。在分布解决问题的过程中，当它通过尝试发现现有的分布答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能分布解答再次尝试寻找问题的答案。\",\"回溯法通常用最简的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：\",\"找到一个可能存在的正确的答案；\",\"在尝试了所有可能的分布方法后宣告该问题没有答案。\",\"在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。回溯法的典型应用：八皇后问题和数独。\"]},\"291\":{\"h\":\"代码模板\"},\"292\":{\"h\":\"贪心算法\"},\"293\":{\"h\":\"定义\",\"t\":[\"贪心算法是一种在每一步选择中都采取在当前状态下最好或最有（即最有利的选择），从而希望导致结果是全局最好或最优的算法。\",\"贪心算法与动态规划的不同在于它对于每个子问题的解决方案都做出选择，不能回退，动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。\",\"贪心算法：当下做局部最优判断\",\"回溯：能够回退\",\"动态规划：最优判断 + 回退\",\"贪心法可以解决一些最优化问题，如：求图中的最小生成树、哈夫曼编码等。然而对于工程和生活中的问题，贪心法一般不能得到我们所求的答案。\",\"一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个的最好办法。由于贪心法的高效性以及其所求得得答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确得问题。\",\"贪心算法可以从前往后，也可以从后往前，也可以从局部切入进行贪心。\"]},\"294\":{\"h\":\"深度优先搜索\"},\"295\":{\"h\":\"定义\",\"t\":[\"对于树这种数据结构而言，深度优先具体指的就是，前、中、后序遍历。\"]},\"296\":{\"h\":\"代码模板\",\"t\":[\"二叉树递归模板：\",\"public void dfs(TreeNode root) { if (root == null) { return; } Stack<TreeNode> stack = new Stack<TreeNode>(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); TreeNode left = node.left; if (left != null) { stack.push(left); } TreeNode right = node.right; if (right != null) { stack.push(right); } } } \"]},\"297\":{\"h\":\"广度优先搜索\"},\"298\":{\"h\":\"定义\"},\"299\":{\"h\":\"代码模板\"},\"300\":{\"h\":\"字典树\"},\"301\":{\"h\":\"定义\",\"t\":[\"字典树，即Trie树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不限于字符串），所以经常被搜索引擎系统用于文本词频统计。\",\"它的优点是：最大限度地减少无谓地字符串比较，查询效率比哈希表高。\",\"注意：字典树不是二叉树，可以有多个子节点。\",\"基本性质：\",\"1、结点本身不存完整单词；\",\"2、从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串；\",\"3、每个结点的所有子节点路径代表的字符都不相同\"]},\"302\":{\"h\":\"代码模板\",\"t\":[\"package structure; import util.LogUtil; import java.util.LinkedList; /** * 字典树实现 */ public class TrieTree { private TrieNode root = new TrieNode(); class TrieNode { TrieNode preNode = null; boolean isEnd = false; // 是否是红点，也就是是否是word的解为 int deep = 0; // 做hash使用，防止一个单词里面有多个char的时候hash是一样的，可能导致删除出错 char content = 0; // 当前结点到parent节点存储的字母 LinkedList<TrieNode> child = new LinkedList<>(); // 子节点，当前节点后续节点 TrieNode() { } TrieNode(char content) { this.content = content; } @Override public String toString() { return \\\"\\\\n\\\" + \\\"{\\\" + \\\"End=\\\" + isEnd + \\\", d=\\\" + deep + \\\", c=\\\" + content + \\\", c=\\\" + child + '}'; } @Override public int hashCode() { return content + deep; } @Override public boolean equals(Object obj) { return obj instanceof TrieNode && (((TrieNode) obj).content == content); } void setPreNode(TrieNode node) { preNode = node; } TrieNode getPreNode() { return preNode; } /** * child中删掉某个Node * * @param node 需要删掉的node */ void removeChild(TrieNode node) { for (TrieNode aChild : child) { if (aChild.content == node.content) { child.remove(aChild); break; } } } /** * child中是否有此Node * * @param character 保存的char * @return 存在返回不存在返回Null */ TrieNode getNode(Character character) { for (TrieNode aChild : child) { if (aChild.content == character) { return aChild; } } return null; } } /** * 添加一个word * apple * * @param word 需要添加的词 */ public void addWord(String word) { int deep = 0; TrieNode currNode = root; while (deep < word.length()) { /* * 判断当前node的child，如果为空直接添加，不为空，查找是否含有，不含有则添加并设为currNode，含有则找到并设置为currNode */ char c = word.charAt(deep); if (currNode.child.contains(new TrieNode(c))) { currNode = currNode.getNode(c); } else { TrieNode node = new TrieNode(c); node.setPreNode(currNode); node.deep = deep + 1; currNode.child.add(node); currNode = node; } if (deep == word.length() - 1) { currNode.isEnd = true; } deep++; } } /** * word在map中是否存在 * * @param word 需要查找的word * @return 是否存在 */ public boolean hasWord(String word) { int deep = 0; TrieNode currNode = root; while (deep < word.length()) { char c = word.charAt(deep); if (currNode.child.contains(new TrieNode(c))) { currNode = currNode.getNode(c); } else { return false; } if (deep == word.length() - 1) { return currNode.isEnd; } deep++; } return false; } /** * 移除word，几种情况： * 1、word在list中不存在，直接返回失败 * 2、word最后一个char 没有child，则删掉此节点并朝 root 查找没有child && isEnd=false 的节点都删掉 * 3、word最后一个char 有child，则把isEnd置为false * * @param word 需要移除的word * @return 是否移除成功 */ public boolean removeWord(String word) { if (word == null || word.trim().equals(\\\"\\\")) { return false; } if (hasWord(word)) { return false; } int deep = 0; TrieNode currNode = root; while (deep < word.length()) { char c = word.charAt(deep); if (currNode.child.contains(new TrieNode(c))) { currNode = currNode.getNode(c); } else { return false; } if (deep == word.length() - 1) { if (currNode.child.size() > 0) { //3、word最后一个char 有child，则把isEnd置为false currNode.isEnd = false; return true; } else { //2、word最后一个char 没有child，则删掉此节点并朝 root 查找没有child && isEnd=false 的节点都删掉 TrieNode parent = currNode.getPreNode(); while (parent != null) { if (parent.child.size() == 0 && !parent.isEnd) { parent.removeChild(currNode); currNode = parent; } else { return true; } } } } deep++; } return false; } /** * 前序遍历所有节点 */ public void traverseTree() { visitNode(root, \\\"\\\"); } private void visitNode(TrieNode node, String result) { LogUtil.Companion.d(\\\"node.content->\\\" + node.content); String re = result + node.content; for (TrieNode n : node.child) { visitNode(n, re); LogUtil.Companion.d(\\\"result->\\\" + re); } } } \"]},\"303\":{\"h\":\"二分查找\"},\"304\":{\"h\":\"定义\",\"t\":[\"二分查找又称折半查找，二分查找的核心思想是，在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功，若给定值小于中间记录的关键字，则在中间记录的左搬去继续查找；若给定值大于中间记录的关键字，则在中间记录的右搬去继续查找，不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。\",\"要使用二分查找的前题是：\",\"目标函数单调（单调递增或者单调递减）\",\"能够通过索引访问（即顺序存储）\",\"存在上下界\",\"二分查找的时间复杂度为O（logn）\"]},\"305\":{\"h\":\"代码模板\",\"t\":[\" public int binarySearch(int nums[], int target) { int left = 0; int right = nums.length - 1; while (left <= right) { int mid = (left + right) / 2; if (target < nums[mid]) { right = mid - 1; } else if (target > nums[mid]) { left = mid + 1; }else { return mid; } } return -1; } \"]},\"306\":{\"h\":\"布隆过滤器\"},\"307\":{\"h\":\"定义\",\"t\":[\"布隆过滤器由一个很长的二进制向量和一系列随机映射函数构成，可以用于检索一个元素是否在一个集合中。\",\"布隆过滤器本质上是由长度为m的位向量或位列表（仅包含0或1位值的列表）组成，最初初始值均为0，如下图所示。\",\"使用多个哈希函数产生多个哈希值：\",\"如上图所示，当输入\\\"semlinker\\\"时，预设的3个哈希函数将输出2、4、6，假设另一个输入\\\"kakuqo\\\"，哈希函数输出3、4和7。4这个位置已经被\\\"semlinker\\\"标记了，在布隆过滤器中是可以共用这个标记位的，此时，当前位向量的标记状态为：\",\"此时，假设我们要判断\\\"fullstack\\\"是否在集合中，对其使用散列函数，获取哈希函数输出的 3 个索引值分别是 2、3 和 7：\",\"可以看到，虽然\\\"fullstack\\\"不在集合中，但是计算出的索引值均为1，说明它在集合中，这就产生了误报，产生的原因是由于哈希碰撞导致的巧合而将不同的元素存储在相同的比特位上。相应的，布隆过滤器有一个可预测的误判率。\",\"布隆过滤器的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误别率和删除困难。\",\"总而言之，当布隆过滤器把元素都插入结束之后，对于测试元素（新元素）。当它验证是否存在的时候，如果验证位是1，那么有可能在，如果是0，那么一定不存在。\"]},\"308\":{\"h\":\"代码模板\"},\"309\":{\"h\":\"LRU Cache\"},\"310\":{\"h\":\"定义\",\"t\":[\"LRU Cache缓存\",\"记忆\",\"钱包 - 储物柜\",\"代码模块\",\"两个要素：大小、替换策略\",\"Hash Table + Double LinkedList\",\"O(1)查询\",\"O(1)修改、更新\",\"LRU（最近至少使用）\"]},\"311\":{\"h\":\"代码模板\",\"t\":[\"class LRUCache extends LinkedHashMap<Integer, Integer>{ private int capacity; public LRUCache(int capacity) { super(capacity, 0.75F, true); this.capacity = capacity; } public int get(int key) { return super.getOrDefault(key, -1); } public void put(int key, int value) { super.put(key, value); } @Override protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) { return size() > capacity; } } \"]},\"312\":{\"h\":\"位运算\"},\"313\":{\"h\":\"定义\",\"t\":[\"含义\",\"运算符\",\"示例\",\"左移\",\"<<\",\"0011 -> 0110\",\"右移\",\">>\",\"0110 -> 0011\",\"按位或\",\"|\",\"0011 | 1011 -> 1011\",\"按位与\",\"&\",\"0011 & 1011 -> 0011\",\"按位取反\",\"~\",\"~0011 -> 1100\",\"按位异或（相同为零不同为一）\",\"^\",\"0011 ^ 1011 -> 1000\"]},\"314\":{\"h\":\"性质\",\"t\":[\"x^0 = x\",\"x^1s = ~x // 注意1s = ~0\",\"x^(~x) = 1s\",\"x^x = 0\",\"c = a^b => a^c = b, b^c = a // 交换两个数\",\"a^b^c = (a^b)^c = a^(b^c)\"]},\"315\":{\"h\":\"实战技巧\",\"t\":[\"判断奇偶：\",\"x%2 == 1 -> (x&1) == 1\",\"x%2 == 0 -> (x&1) == 0\",\"x >> 1 -> x/2\",\"即x = x/2; -> x = x>>1; mid = (left + right)/2; -> mid = (left + right) >> 1;\",\"x = x&(x-1) 清零最低位的1\",\"x&-x => 得到最低位的1\",\"x&-x => 0\"]},\"316\":{\"h\":\"排序算法\",\"t\":[\"不同排序算法之间的对比如下：\",\"相关的原理介绍和代码实现可以参考：十大经典排序算法\",\"它们之间的对比如下：\",\"排序算法\",\"适用场景\",\"冒泡排序\",\"元素基本有序\",\"选择排序\",\"插入排序\",\"希尔排序\",\"堆排序\",\"归并排序\",\"时间复杂度与数组长度无关，但需要额外的空间\",\"快速排序\",\"大多数情况下，快速排序是最佳的选择。\",\"java.util.Arrays#sort()对于值类型，使用的是三向切分的快速排序；对于引用类型，使用的是归并排序。\"]},\"317\":{\"h\":\"冒泡排序\",\"t\":[\"算法步骤：\",\"比较相邻的元素，如果第一个比第二个大，就交换它们\",\"对每一对相邻的元素作同样的动作，从开始第一对到最后\",\"针对所有的元素重复以上的步骤，除了最后一个，直到没有任何一对数字需要比较。\",\"public class BubbleSortTemplate { public static void sort(Comparable[] a) { for (int i = 0; i < a.length; i++) { for (int j = 1; j < a.length - 1; j++) { if (less(a[i], a[j])) { exch(a, i, j); } } } } // 比较元素大小 public static boolean less(Comparable v, Comparable w) { return v.compareTo(w) < 0; } // 交换元素位置 public static void exch(Comparable[] a, int i, int j) { Comparable temp = a[i]; a[i] = a[j]; a[j] = temp; } } \"]},\"318\":{\"h\":\"选择排序\",\"t\":[\"算法步骤：\",\"找到数组中最小的那个元素\",\"将它和数组的第一个元素交换位置（如果是第一个元素就是和它自己交换位置）\",\"在剩下的元素中找到最小的元素，将它与数组的第二个元素交换\",\"如此往复，直到将整个数组排序\",\"之所以叫做选择排序，是因为在不断地选择剩余元素中最小的元素。\",\"public class SelectionTemplate { public static void sort(Comparable[] a) { for (int i = 0; i < a.length; i++) { int min = 0; // 注意 for (int j = i + 1; j < a.length; j++) { // i + 1 从下一个元素开始朝朝 if (less(a[j], a[i])) { min = j; } }; exch(a, i, min); } } // 比较元素大小 public static boolean less(Comparable v, Comparable w) { return v.compareTo(w) < 0; } // 交换元素位置 public static void exch(Comparable[] a, int i, int j) { Comparable<?> temp = a[i]; a[i] = a[j]; a[j] = temp; } } \"]},\"319\":{\"h\":\"插入排序\",\"t\":[\"算法步骤：从到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置（如果待插入的元素与有序序列中的每个元素相等，则将待插入元素插入到相等元素的后面）。\",\"public class InsertionTemplate { // 解法1 public static void sort(Comparable[] a) { for (int i = 1; i < a.length; i++) { // 注意下标为0时只有一个元素，默认有序，所以从1开始 Comparable min = a[i]; int j = i - 1; // 从已经排序的序列最右边的开始比较，找到比其小的数 while (j > 0 && min.compareTo(a[j - 1]) < 0) { a[j] = a[j - 1]; j--; } // 存在比其小的数，插入 if (j != i) { a[j] = min; } } } // 解法2 public static void sort2(Comparable[] a) { for (int i = 1; i < a.length; i++) { Comparable min = a[i]; for (int j = i; j > 0; j--) { if (less(a[j], a[j - 1])) { exch(a, j - 1, j); } else { a[j] = min; break; } } } } // 解法3 public static void sort3(Comparable[] a) { for (int i = 1; i < a.length; i++) { int j; for (j = i; j > 0 && less(a[j], a[j - 1]); j--) { exch(a, j, j - 1); } a[j] = a[i]; } } public static boolean less(Comparable v, Comparable w) { return v.compareTo(w) < 0; } public static void exch(Comparable[] a, int i, int j) { Comparable temp = a[i]; a[i] = a[j]; a[i] = temp; } } \"]},\"320\":{\"h\":\"希尔排序\",\"t\":[\"算法步骤：先将整个待排序的记录序列分割成为若干子序列分别进行插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。\",\" \"]},\"321\":{\"h\":\"堆排序\",\"t\":[\"堆排序是指利用堆这种数据结构所设计的一种排序算法。堆排序可以说是一种利用堆的概念来排序的选择排序，分为两种方法：\",\"大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列\",\"小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列\",\" \"]},\"322\":{\"h\":\"归并排序\",\"t\":[\"算法步骤：\",\"将数组拆分成两半，分别进行排序\",\"将结果归并起来\",\" \"]},\"323\":{\"h\":\"快速排序\",\"t\":[\"算法步骤：\",\"将一个数组分成两个子数组分别进行排序\",\"当两个子数组有序时，整个数组即有序\",\" \"]},\"324\":{\"h\":\"动态规划\"},\"325\":{\"h\":\"定义\",\"t\":[\"动态规划（Dynamic Programming）也可以认为是动态递归。\",\"关键点：\",\"最优子结构：opt[n] = best_of(opt[n -1], opt[n - 2], ...)\",\"存储中间状态：opt[i]\",\"递推公式（状态转移方程或者DP方程）\"]},\"326\":{\"h\":\"代码模板\",\"t\":[\"# 初始化 base case dp[0][0][...] = base # 进行状态转移 for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 求最值(选择1，选择2...) \"]},\"327\":{\"h\":\"股票问题\",\"t\":[\"一个方法团灭 6 道股票问题\"]},\"328\":{\"h\":\"数据结构\",\"t\":[\"数据结构，是相互之间存在一种或多种特定关系的数据元素的集合。按照视点的不同，我们把数据结构分为逻辑结构和物理结构。其中，逻辑结构又可以分为集合结构、线性结构、树形结构、图形结构等，物理结构可以分为顺序存储结构和链式存储结构。\",\"数据结构优化的核心思路，一是升维 二是用空间换时间。\"]},\"329\":{\"h\":\"数组\",\"t\":[\"数组的查询的时间复杂度O(1)，插入/删除元素的时间复杂度O(n)。\",\"初始化数组的方式：\",\"静态初始化：\",\"int[] nums = new int[]{1, 2, 3, 4, 5, 9}; \",\"简单的静态初始化：\",\"int[] nums = {1, 2, 3, 4, 5, 9}; \",\"动态初始化：\",\"int[] nums = new int[4]; \",\"遍历数组的方式：\",\"传统的for循环方式：\",\"public class Main { public static void main(String[] args) { int[] ns = {1, 4, 9, 16, 25}; for (int i = 0; i < ns.length; i++) { System.out.println(ns[i]); } } } \",\"使用foreach循环：\",\"public class Main { public static void main(String[] args) { int[] ns = {1, 4, 9, 16, 25}; for (int n : ns) { System.out.println(n); } } } \",\"使用Java标准库中的Arrays.toString()：\",\"import java.util.Arrays; public class Main { public static void main(String[] args) { int[] ns = {1, 1, 2, 3, 5, 8}; System.out.println(Arrays.toString(ns)); } } \",\"二维数组的定义及遍历。\",\"public class Main { public static void main(String[] args) { int[][] array = new int[3][4]; //创建一个3行4列的数组，并且里面值都为默认值 for (int i = 0; i < array.length; i++) { // 第一个循环，循环每一行 for (int j = 0; j < array[i].length; j++) { //第二个循环，循环每行的每一列 System.out.print(array[i][j]); } System.out.println(); } } } \"]},\"330\":{\"h\":\"链表\",\"t\":[\"链表的查询时间时间复杂度O(n)，插入/删除元素的时间复杂度O(1)\",\"提高链表线性表查找的效率？\",\"添加第一级索引\",\"添加第二级索引\",\"添加多级索引，总数为log2n个索引\",\"时间复杂度为O(log2n)，空间复杂度为O(n)\"]},\"331\":{\"h\":\"跳表\",\"t\":[\"跳表的问题：索引的维护比较困难\"]},\"332\":{\"h\":\"哈希表\",\"t\":[\"哈希表（Hash table），也叫散列表，是根据关键码值直接访问元素的数据结构，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，即通过某个函数f，使得：\",\"存储位置 = f（关键字） \",\"这样我们可以通过查找关键字而不需要比较就可以获取需要的记录的存储位置，这个映射函数f叫做散列函数或者哈希函数，存放记录的数组叫做哈希表（或散列表），关键字所对应的记录位置称为散列地址。\",\"散列技术即是一种存储方法，也是一种查找方法。散列技术的记录之间不存在什么逻辑关系，它只与关键字有关系，因此最适合求接的问题是查找与给定值相等的记录。\",\"当两个关键字key1 ≠ key2，但是却有f(key1) = f(key2)，这种现象我们称为冲突，并把key1和key2称为这个散列函数的同义词。\",\"构造哈希函数的方法主要有：\",\"直接定址法：f(key) = a*key + b(a、b均为常数)\",\"数字分析法\",\"平法取中法\",\"折叠法\",\"除留余数法 ：f(key) = key mod p (p <= m)\",\"随机数法\",\"处理散列冲突的方法：\",\"开放地址法\",\"再散列函数法\",\"链地址法\",\"公共区溢出法\"]},\"333\":{\"h\":\"栈\",\"t\":[\"stack：先入后出；添加，删除皆为O(1)，有时候也称为FILO\",\"如果问题具有最近相关性，就可以使用栈来解决。\",\"如果要用栈来实现队列，可以用两个栈。\"]},\"334\":{\"h\":\"队列\",\"t\":[\"queue：先入先出；添加、删除皆为O(1)，有时候也成为FIFO\",\"如果问题具有公平性，就可以使用队列来解决。\",\"如果要用队列来实现栈，可以用两个队列\"]},\"335\":{\"h\":\"双端队列\",\"t\":[\"双端队列（Dequeue） Double-End Queue\"]},\"336\":{\"h\":\"树\"},\"337\":{\"h\":\"总体介绍\",\"t\":[\"现实生活中，除了前面的一对一的线性结构，还有很多一对多的数据结构——“树”。\",\"树的表示方法有：\",\"双亲表示法\",\"孩子表示法\",\"孩子兄弟表示法\",\"对于计算机来说，它只有循环、判断、递归等方式，也就是说，它只能处理线性序列，树的遍历实际上就是将树中的结点编程某种意义上的线性序列，方便计算机处理。\",\"在实际工程中，经常采用递归来解决树相关的问题的原因是：\",\"节点的定义\",\"可重复性（自相似性）\"]},\"338\":{\"h\":\"代码模板\",\"t\":[\"public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int val) { this.val = val; this.left = null; this.right = null; } } \"]},\"339\":{\"h\":\"二叉树\",\"t\":[\"二叉树的遍历方法有以下几种：\",\"前序（Pre-order）：根-左-右\",\"中序（In-order）：左-根-右\",\"后序（Post-order）：左-右-根\",\"层次遍历\",\"二叉树遍历遍历的性质：\",\"已知前序遍历序列和中序遍历序列，可以唯一确定一颗二叉树\",\"已知中序遍历序列和后序遍历序列，可以唯一确定一颗二叉树\",\"已知前序和后序遍历，无法确定唯一一颗二叉树。\",\"如果二叉树退化成了链表（即元素都在左子树上或者都在右子树上），那么时间复杂度会变成O（n）\"]},\"340\":{\"h\":\"二叉搜索树\",\"t\":[\"二叉搜索树，也称二叉搜索树、有序二叉树（Ordered Binary Tree）、二叉排序树（Sorted Binary Tree），是一棵空树或者具有下列性质的二叉树：\",\"左子树上的所有结点的值均小于它的根节点的值\",\"右子树上所有结点的值均大于它的根结点的值\",\"依次类推：左、右子树也分别为二叉查找树（这就是重复性）\",\"二叉搜索树的性质：\",\"中序遍历是递增序列\",\"二叉搜索树的插入和查询时间复杂度都是O(logn)。\"]},\"341\":{\"h\":\"平衡二叉树\",\"t\":[\"平衡二叉树是一种二叉排序树，每一个结点的左子树和右子树的高度差至多等于1，平衡二叉树有时候也称为AVL树。\",\"平衡二叉树的性质：\",\"我们将二叉树的左子树深度减去右子树深度的值称为平衡因子（BF），那么平衡二叉树的所有结点的平衡因子只可能是-1，0，1。\",\"平衡二叉树的查找、插入和删除的时间复杂度均为O（logn）\"]},\"342\":{\"h\":\"红黑树\",\"t\":[\"主要参考：30张图带你彻底理解红黑树\"]},\"343\":{\"h\":\"定义和性质\",\"t\":[\"红黑树是二叉查找树，具体来说，是一种含有红黑结点并能自平衡的二叉查找树，它必须满足下面的性质：\",\"性质1：每个结点要么是黑色，要么是红色\",\"性质2：根节点是黑色\",\"性质3：每个叶子结点（NIL）是黑色\",\"性质4：每个红色结点的两个子节点一定都是黑色\",\"性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑节点\",\"从性质5又可以推出：\",\"性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点\",\"一颗简单的红黑树如下图所示：\",\"红黑树并不是一个完美平衡二叉查找树，从图1可以看到，根节点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到每个叶子结点的路径都包含数量相同的黑结点（性质5）。所以我们叫红黑树这种平衡为黑色完美平衡。\",\"在红黑树中最主要的有三种操作：左旋、右旋和变色。\",\"左旋：以某个结点作为支点（旋转结点），其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变\",\"右旋：以某个结点作为支点（旋转结点），其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变\",\"变色：结点的颜色由红变黑或由黑变红\",\"左旋的示意图：\",\"右旋的示意图：\",\"如果我们暂时忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。\",\"左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪了\",\"右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪了\"]},\"344\":{\"h\":\"红黑树的查找\",\"t\":[\"整体的示意图如下：\",\"因为红黑树也是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：\",\"从根节点开始查找，把根节点设置为当前结点\",\"若当前结点为空，返回null\",\"若当前结点不为空，用当前结点的key跟查找key作比较\",\"若当前结点等于查找key，那么该key就是查找目标，返回当前结点\",\"若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2\",\"若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2\"]},\"345\":{\"h\":\"红黑树的插入\",\"t\":[\"整体的示意图如下：\",\"插入操作包括两部分工作：一个是查找插入的位置，而是插入后自平衡。查找插入的父结点很简单，跟查找操作的区别不大：\",\"从根结点开始查找\",\"若根结点为空，那么插入结点作为根节点，结束\",\"若根结点不为空，那么把根结点作为当前结点\",\"若当前结点为null，返回当前结点的父结点，结束\",\"若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束\",\"若当前结点key大于查找key，那么当前结点的左子结点设置为当前结点，重复步骤4\",\"若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4\",\"当插入的位置确定之后就是要确定插入结点的颜色，插入的结点都是红色，原因在于，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。\",\"所有可能的插入的情景：\"]},\"346\":{\"h\":\"多路查找树\",\"t\":[\"多路查找树的每一个结点的孩子树可以多于两个，且每一个结点处可以存储多个元素，由于它是查找树，所有元素之间存在某种特定的排序关系。\"]},\"347\":{\"h\":\"2-3树\",\"t\":[\"2-3树是这样一颗多路查找树：其中每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点）。\",\"一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个2结点要么没有孩子，要么就有两个，不能只有一个孩子\",\"一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素\",\"并且2-3树种所有的叶子都在同一层次上。\"]},\"348\":{\"h\":\"2-3-4树\",\"t\":[\"2-3-4树实对2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含于最小元素的元素，第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最低元素的元素；右子树包含大于最大元素的元素。\"]},\"349\":{\"h\":\"B树\",\"t\":[\"B树是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶。因此，2-3树是3阶的B树，2-3-4树是4阶B树。\"]},\"350\":{\"h\":\"B+树\",\"t\":[\"B+树是应文件系统所需而出的一种B树的变形树，注意严格意义上讲，它其实已经不是之前所定义的树了。在B树中，每一个元素在该树只出现一次，有可能在叶子结点上，也可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当做它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向叶子结点的指针。\"]},\"351\":{\"h\":\"堆\",\"t\":[\"堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆，如下图所示：\",\"这里由定义可知，根节点一定是堆中所有结点最大（小）者。\"]},\"352\":{\"h\":\"优先队列\"},\"353\":{\"h\":\"总体介绍\",\"t\":[\"优先队列(Priority Queue)的作用是能保证每次取出的元素都是队列中权值最小的（Java的优先队列每次取得是最小元素）。元素的大小默认是通过元素本身的自然顺序，也可以通过构造时传入比较器。\",\"Java中的PriorityQueue实现了Queue接口，不允许放入null元素，其通过堆实现，具体是通过完全二叉树实现的小顶堆，这也意味着可以通过数组来作为PriorityQueue的底层实现。\",\"优先队列的插入操作时间复杂度是：O(1)，取出操作：O(logN) ，底层具体实现的数据结构较为多样和复杂：heap、bst、treap...。\"]},\"354\":{\"h\":\"方法剖析\",\"t\":[\"add(E e)和offer(E e)的语义相同，都是向队列中插入元素，二者的区别在于插入失败情况的处理，前者插入失败是抛出异常，后者则返回false。\",\"element()和peek()语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者的区别在于获取失败的情况的处理，前者会抛出异常，后者会返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个，如果用数组来存储堆，根据下标关系，0下标处的那个元素即是堆顶元素，因此，直接返回数组0下标处的那个元素即可。\",\"romve()和poll()方法的语义也完全相同，都是获取并删除队首元素，二者的区别在于删除失败的情况的处理，前者会抛出异常，后者会返回null。\"]},\"355\":{\"h\":\"图\"},\"356\":{\"h\":\"拓扑排序\",\"t\":[\"并查集（Disjoint-set）\",\"适用的场景：\",\"组团、配对问题\",\"Group or not？\",\"并查集的操作\",\"1、makeSet（s）：建立一个新的并查集，其中包含s个单元素集合。\",\"2、unionSet（x，y）：把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并。\",\"3、find（x）：找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将他们各自的代表比较一下就可以了。\"]},\"357\":{\"h\":\"算法刷题\"},\"358\":{\"h\":\"数组\"},\"359\":{\"h\":\"\",\"t\":[\"梦开始的地方：\",\" public int[] twoSum(int[] nums, int target) { Map<Integer,Integer> map = new HashMap<>(); for(int i = 0; i < nums.length; i++) { if(map.containsKey(target - nums[i])) { return new int[]{i,map.get(target-nums[i])}; } map.put(nums[i],i); } return new int[2]; } \"]},\"360\":{\"h\":\"704. 二分查找\",\"t\":[\"力扣题目链接\",\"模板代码：\",\"class Solution { public int search(int[] nums, int target) { int l = 0, r = nums.length - 1; while (l <= r) { int mid = (l + r) / 2; // 为了避免 l + r 超过int的最大值，更安全的写法是：int mid = (r - l) / 2 + l; if (nums[mid] == target) { return mid; } else if (nums[mid] > target) { r--; } else if (nums[mid] < target) { l++; } } return -1; } } \"]},\"361\":{\"h\":\"27. 移除元素\",\"t\":[\"力扣题目链接\",\"使用for循环的双指针：\",\"class Solution { public int removeElement(int[] nums, int val) { int slow = 0; for (int fast = 0; fast < nums.length; fast++) { if (nums[fast] != val) { nums[slow] = nums[fast]; slow++; } } return slow; } } \",\"使用while循环的双指针：\",\"class Solution { public int removeElement(int[] nums, int val) { int slow = 0, fast = 0; while (fast < nums.length) { if (nums[fast] != val) { nums[slow] = nums[fast]; slow++; } fast++; } return slow; } } \"]},\"362\":{\"h\":\"977.有序数组的平方\",\"t\":[\"力扣题目链接\",\"最直观的做法，对于数组中的每个元素平方后排序：\",\"class Solution { public int[] sortedSquares(int[] nums) { for (int i = 0; i < nums.length; i++) { nums[i] = nums[i] * nums[i]; } Arrays.sort(nums); return nums; } } \",\"也可以使用双指针来降低时间复杂度：\",\"class Solution { public int[] sortedSquares(int[] nums) { int left = 0; int right = nums.length - 1; int[] ans = new int[nums.length]; int index = right; while (left <= right) { // 当前元素等于绝对值大的那个元素的平方和 if (Math.abs(nums[right]) > Math.abs(nums[left])) { ans[index] = nums[right] * nums[right]; right--; } else { ans[index] = nums[left] * nums[left]; left++; } index--; // 处理下一个元素 } return ans; } } \"]},\"363\":{\"h\":\"209.长度最小的子数组\",\"t\":[\"力扣题目链接\",\"滑动窗口：\",\"class Solution { public int minSubArrayLen(int target, int[] nums) { if (nums == null || nums.length == 0) { return 0; } int ans = Integer.MAX_VALUE; int sum = 0, left = 0; for (int right = 0; right < nums.length; right++) { sum += nums[right]; while (sum >= target) { // 根据题意大于等于即可 ans = Math.min(ans, right - left + 1); // 更新结果 sum -= nums[left]; // 滑动窗口 left++; } } return ans == Integer.MAX_VALUE ? 0 : ans; // 如果等于 Integer.MAX_VALUE 说明没有满足的元素 } } \"]},\"364\":{\"h\":\"59.螺旋矩阵II\",\"t\":[\"力扣题目链接\",\"class Solution { public int[][] generateMatrix(int n) { int l = 0, r = n - 1, t = 0, b = n - 1; int[][] result = new int[n][n]; int num = 1, tar = n * n; while (num <= tar) { // 从左到右 for (int i = l; i <= r; i++) { result[t][i] = num++; } t++; // 从上到下 for (int i = t; i <= b; i++) { result[i][r] = num++; } r--; // 从右到左 for (int i = r; i >= l; i--) { result[b][i] = num++; } b--; // 从下到上 for (int i = b; i >= t; i--) { result[i][l] = num++; } l++; } return result; } } \"]},\"365\":{\"h\":\"\",\"t\":[\"public void moveZeroes(int[] nums) { if (nums == null || nums.length == 0) { return; } // 将非零数移动到index处 int index = 0; for (int i = 0; i < nums.length; i++) { if (nums[i] != 0) { nums[index] = nums[i]; index++; } } for (int i = index; i < nums.length; i++) { nums[i] = 0; } } \"]},\"366\":{\"h\":\"\",\"t\":[\"穷举法：\",\" public List<List<Integer>> threeSum(int[] nums) { List<List<Integer>> res = new LinkedList<>(); int target = 0; for (int i = 0; i < nums.length - 2; i++) { for (int j = i + 1; j < nums.length - 1; j++) { for (int k = j + 1; k < nums.length; k++) { if ((nums[i] + nums[j] + nums[k]) == target) { List<Integer> integers = Arrays.asList(nums[i],nums[j],nums[k]); res.add(integers); } } } } return res; } \",\"双指针法：\",\" public List<List<Integer>> threeSum(int[] nums) { List<List<Integer>> res = new LinkedList<>(); if (nums == null || nums.length < 3) { return res; } // 排序 Arrays.sort(nums); // O(n^2) for (int i = 0; i <= nums.length - 1; i++) { // 经过排序之后的数组第一个数大于0，后面的数都比它大，一定不成立 if (nums[i] > 0) { break; } // 去掉重复情况 if (i > 0 && nums[i] == nums[i - 1]) { continue; } int left = i + 1, right = nums.length - 1; while (left < right) { if (nums[left] + nums[right] + nums[i] == 0) { res.add(new ArrayList<>(Arrays.asList(nums[i], nums[left], nums[right]))); left++; right--; // 去掉重复情况，一直移动到没有相同项 while (left < right && nums[left] == nums[left - 1]) { left++; } while (left < right && nums[right] == nums[right + 1]) { right--; } } else if (nums[left] + nums[right] + nums[i] < 0) { left++; } else { // nums[left] + nums[right] + nums[i] > 0 right--; } } } return res; } \"]},\"367\":{\"h\":\"\",\"t\":[\"使用暴力法求解：\",\"对于每一个位置，我们需要：\",\"向左遍历，找到大于等于当前柱形高度最左元素的下标\",\"向右遍历，找到大于等于当前柱形高度最右元素的下标\",\"然后得到一个矩形的面积，求出他们的最大值。\",\" public int largestRectangleArea(int[] heights) { if (heights.length == 0) { return 0; } int res = 0; for (int i = 0; i < heights.length; i++) { // 向左遍历，找到大于等于当前柱形高度最左元素的下标 int left = i; while (left > 0 && heights[left - 1] >= heights[i]) { left--; } // 向右遍历，找到大于等于当前柱形高度最右元素的下标，注意这里的边界条件 int right = i; while (right < heights.length - 1 && heights[right + 1] >= heights[i]) { right++; } int width = right - left + 1; res = Math.max(res, width * heights[i]); } return res; } \"]},\"368\":{\"h\":\"\",\"t\":[\"传统的遍历方式，时间复杂度为O(n^2)。\",\" public int maxArea(int[] height) { if (height == null || height.length <= 2) { return 0; } int max = 0; for (int i = 0; i < height.length - 1; i++) { for (int j = i + 1; j < height.length; j++) { int hg = Math.min(height[i], height[j]); int area = Math.abs(j - i) * hg; max = Math.max(max,area); } } return max; } \",\"也可以采用双边收敛的方式：\",\"private int maxArea(int[] height) { int i = 0, j = height.length - 1, max = 0; while (i < j) { int h = Math.min(height[i],height[j]); int res = h * (j - i); max = Math.max(res,max); if (height[i] < height[j]) { i++; }else { j--; } } return max; } \"]},\"369\":{\"h\":\"数组题目总结\",\"t\":[\"双指针、排序、哈希表是解决数组问题的常见手段。\"]},\"370\":{\"h\":\"链表\"},\"371\":{\"h\":\"203.移除链表元素\",\"t\":[\"力扣题目链接\",\"使用虚拟的头节点：\",\"class Solution { public ListNode removeElements(ListNode head, int val) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; ListNode curr = head; while (curr != null) { if (curr.val == val) { // 相等就移除节点 pre.next = curr.next; } else { pre = curr; } curr = curr.next; } return dummy.next; } } \"]},\"372\":{\"h\":\"\",\"t\":[\"双指针的解法：\",\" public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode curr = head; while (curr != null) { ListNode next = curr.next; curr.next = prev; prev = curr; curr = next; } return prev; } \"]},\"373\":{\"h\":\"\",\"t\":[\"使用哈希表来实现：\",\" public boolean hasCycle(ListNode head) { Set<ListNode> listNodes = new LinkedHashSet<ListNode>; while (head != null) { if (!listNodes.add(head.next)) { return true; } head = head.next; } return false; } \",\"快慢指针法：\",\"public boolean hasCycle(ListNode head) { if (head == null || head.next == null) { return false; } ListNode slow = head; ListNode fast = head.next; while (slow != fast) { if (fast == null || fast.next == null) { return false; } slow = slow.next; fast = fast.next.next; } return true; } \"]},\"374\":{\"h\":\"24. 两两交换链表中的节点\",\"t\":[\"力扣题目链接\"]},\"375\":{\"h\":\"19.删除链表的倒数第N个节点\",\"t\":[\"力扣题目链接\",\"class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode slow = dummy; ListNode fast = dummy; for (int i = 0; i <= n; i++) { // 让快慢指针相距n个节点, 需要走n + 1步，所以是小于等于n fast = fast.next; } while (fast != null) { // 让慢指针异动到倒数第n个节点的地方 slow = slow.next; fast = fast.next; } // 此时 fast指向null，slow 刚好在第 n - 1 的位置上 slow.next = slow.next.next; return dummy.next; } } \"]},\"376\":{\"h\":\"160.链表相交\",\"t\":[\"力扣题目链接\",\"public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode a = headA; ListNode b = headB; while (a != b) { a = a == null ? headB : a.next; b = b == null ? headA : b.next; } return b; } } \"]},\"377\":{\"h\":\"142.环形链表II\",\"t\":[\"力扣题目链接\",\"public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { // 证明有环 ListNode index1 = fast; ListNode index2 = head; // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口 while (index1 != index2) { index1 = index1.next; index2 = index2.next; } return index1; } } return null; } } \"]},\"378\":{\"h\":\"链表总结\",\"t\":[\"创建虚拟的头节点和快慢指针是链表常见的解题思路。\"]},\"379\":{\"h\":\"哈希表\"},\"380\":{\"h\":\"\",\"t\":[\"使用哈希表，将排序之后的字符串作为key，并且排序之后相同的字符串添加到列表中，最后从Map中获取值并返回。\",\"public List<List<String>> groupAnagrams(String[] strs) { HashMap<String, List<String>> map = new HashMap<>(); for (int i = 0; i < strs.length; i++) { char[] chars = strs[i].toCharArray(); Arrays.sort(chars); String key = String.valueOf(chars); if (!map.containsKey(key)) { map.put(key, new ArrayList<>()); } map.get(key).add(strs[i]); } return new ArrayList<>(map.values()); } \"]},\"381\":{\"h\":\"\",\"t\":[\"使用Map统计 每个数字出现的次数，然后遍历map，找出出现次数为1次的数字：\",\"class Solution { public int singleNumber(int[] nums) { Map<Integer, Integer> map = new HashMap<>(); for (int num : nums) { int count = map.getOrDefault(num, 0); map.put(num, ++count); } for (Map.Entry<Integer, Integer> entry : map.entrySet()) { if (entry.getValue() == 1) { return entry.getKey(); } } throw new IllegalArgumentException(\\\"not found\\\"); } } \",\"更简单的做法是用set：\",\"class Solution { public int singleNumber(int[] nums) { Set<Integer> set = new HashSet<>(); for (int num : nums) { if (!set.contains(num)) { set.add(num); } else { set.remove(num); } } return set.iterator().next(); } } \"]},\"382\":{\"h\":\"字符串\"},\"383\":{\"h\":\"344.反转字符串\",\"t\":[\"力扣题目链接\",\"双指针：\",\"class Solution { public void reverseString(char[] s) { if (s == null || s.length == 0) { return; } int left = 0, right = s.length - 1; while (left < right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } } \"]},\"384\":{\"h\":\"541. 反转字符串II\",\"t\":[\"力扣题目链接\",\"题目的意思是：反转字符串中k个字符，下面k个不反转，如此反复，最后剩下的不够k个字符时全部反转。\",\"class Solution { public String reverseStr(String s, int k) { int n = s.length(); char[] ch = s.toCharArray(); for (int i = 0; i < n - 1; i += 2 * k) { // 剩下的字符够k个，则反转前k个字符 if (i + k <= n) { reverse(ch, i, i + k - 1); } else { reverse(ch, i, n - 1); } } return new String(ch); } private void reverse(char[] ch, int start, int end) { while (start < end) { char temp = ch[start]; ch[start] = ch[end]; ch[end] = temp; start++; end--; } } } \"]},\"385\":{\"h\":\"151.翻转字符串里的单词\",\"t\":[\"力扣题目链接\",\"调用库函数的方式：\",\"class Solution { public String reverseWords(String s) { if (s == null) { return null; } String[] splitArray = s.trim().split(\\\" \\\"); StringBuilder ans = new StringBuilder(); for (int i = splitArray.length - 1; i >= 0; i--) { if (!\\\"\\\".equals(splitArray[i])) { ans.append(\\\" \\\"); ans.append(splitArray[i].trim()); } } return ans.toString().trim(); } } \",\"完全手写的方式：\",\"public class Solution { public String reverseWords(String s) { if (s == null) return null; char[] a = s.toCharArray(); int n = a.length; // step 1. reverse the whole string reverse(a, 0, n - 1); // step 2. reverse each word reverseWords(a, n); // step 3. clean up spaces return cleanSpaces(a, n); } void reverseWords(char[] a, int n) { int i = 0, j = 0; while (i < n) { while (i < j || i < n && a[i] == ' ') i++; // skip spaces while (j < i || j < n && a[j] != ' ') j++; // skip non spaces reverse(a, i, j - 1); // reverse the word } } // trim leading, trailing and multiple spaces String cleanSpaces(char[] a, int n) { int i = 0, j = 0; while (j < n) { while (j < n && a[j] == ' ') j++; // skip spaces while (j < n && a[j] != ' ') a[i++] = a[j++]; // keep non spaces while (j < n && a[j] == ' ') j++; // skip spaces if (j < n) a[i++] = ' '; // keep only one space } return new String(a).substring(0, i); } // reverse a[] from a[i] to a[j] private void reverse(char[] a, int i, int j) { while (i < j) { char t = a[i]; a[i++] = a[j]; a[j--] = t; } } } \"]},\"386\":{\"h\":\"\",\"t\":[\"可以使用暴力破解法，即遍历字符串，找到最近的匹配括号开始，如果匹配就替换为空字符串，一直循环下去，如果括号是匹配的，那么最终的结果应该是个空字符串。\",\"这里使用的栈来解决。\",\"public boolean isValid(String s) { int n = s.length(); // 如果个数是奇数个直接返回 if(n % 2 == 1) { return false; } Map<Character, Character> characterMap = new HashMap<>(); characterMap.put('}', '{'); characterMap.put(']', '['); characterMap.put(')', '('); Deque<Character> stack = new LinkedList<>(); for (int i = 0; i < s.length(); i++) { char bracket = s.charAt(i); // 栈中有左括号 if (characterMap.containsKey(bracket)) { // 如果栈中元素为空或者与Map中括号不匹配 if (stack.isEmpty() || stack.peek() != characterMap.get(bracket)) { return false; } stack.pop(); } else { stack.push(bracket); } } return stack.isEmpty(); } \",\"除了这种，还有一种相对比较简单的写法：\",\" public boolean isValid(String s) { Deque<Character> stack = new LinkedList<>(); for (char c : s.toCharArray()) { if (c == '[') { stack.push(']'); } else if (c == '{') { stack.push('}'); } else if (c == '(') { stack.push(')'); } else if (stack.isEmpty() || c != stack.pop()) { return false; } } return stack.isEmpty(); } \"]},\"387\":{\"h\":\"\",\"t\":[\"使用排序：\",\" public boolean isAnagram(String s, String t) { char[] sChars = s.toCharArray(); char[] tChars = t.toCharArray(); // 注意这里不能简写为 Arrays.sort(s.toCharArray())，因为Arrays.sort采用的就地排序。 Arrays.sort(sChars); Arrays.sort(tChars); return Arrays.equals(sChars, tChars); } \",\"使用哈希表：\",\" public boolean isAnagram(String s, String t) { HashMap<Character, Integer> hashTable = new HashMap<>(); for (char c : s.toCharArray()) { hashTable.put(c, hashTable.getOrDefault(c, 0) + 1); } for (char c : t.toCharArray()) { hashTable.put(c, hashTable.getOrDefault(c, 0) - 1); if (hashTable.get(c) < 0) { return false; } } return true; } \"]},\"388\":{\"h\":\"\",\"t\":[\"public int myAtoi(String str) { int index = 0, sign = 1, total = 0; // 空字符串 if (str.length() == 0) { return 0; } // 移除空格 while (str.charAt(index) == ' ') { index++; } // 处理正负号 if (str.charAt(index) == '+' || str.charAt(index) == '-') { sign = str.charAt(index) == '+' ? 1 : -1; index++; } // 转为数字 while (index < str.length()) { int digit = str.charAt(index) - '0'; if (digit < 0 || digit > 9) { break; } // 越界处理 if (Integer.MAX_VALUE / 10 < total || (Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)) { return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; } else { total = 10 * total + digit; index++; } } return total * sign; } \"]},\"389\":{\"h\":\"459.重复的子字符串\",\"t\":[\"力扣题目链接\",\"移动匹配法：\",\"class Solution { public boolean repeatedSubstringPattern(String s) { int idx = (s + s).indexOf(s, 1); return idx < s.length(); } } \"]},\"390\":{\"h\":\"字符串总结\"},\"391\":{\"h\":\"栈与队列\"},\"392\":{\"h\":\"\",\"t\":[\"class MinStack { // 存储最小值的栈 Deque<Integer> minStack; // 普通的栈 Deque<Integer> stack; /** * initialize your data structure here. */ public MinStack() { minStack = new LinkedList<>(); stack = new LinkedList<>(); minStack.push(Integer.MAX_VALUE); } public void push(int val) { stack.push(val); minStack.push(Math.min(val, minStack.pop())); } public void pop() { stack.pop(); } public int top() { return stack.peek(); } public int getMin() { return minStack.pop(); } } \"]},\"393\":{\"h\":\"\",\"t\":[\"所有滑动窗口的问题都可以使用队列来解决。\",\"使用最大堆（优先队列）：\",\" public int[] maxSlidingWindow(int[] nums, int k) { int n = nums.length; // 传入比较器，当两者的值相同时，比较下标的位置，下标大的在前面。 PriorityQueue<int[]> queue = new PriorityQueue<>((p1, p2) -> p1[0] != p2[0] ? p2[0] - p1[0] : p2[1] - p1[1]); // 初始化k前面的元素到堆中 for (int i = 0; i < k; i++) { queue.offer(new int[]{nums[i], i}); } // 答案总共有n-k+1个 int[] ans = new int[n - k + 1]; // 将第一次的答案添加到结果当中 ans[0] = queue.peek()[0]; for (int i = k; i < n; i++) { // 将新元素加入优先队列 queue.offer(new int[]{nums[i], i}); // 循环判断当前队首是否在窗口中，窗口的左边界为i-k while (queue.peek()[1] <= i - k) { queue.poll(); } ans[i - k + 1] = queue.peek()[0]; } return ans; } \"]},\"394\":{\"h\":\"树\"},\"395\":{\"h\":\"\",\"t\":[\"使用传统的递归方式：\",\" public List<Integer> inorderTraversal(TreeNode root) { List<Integer> list = new ArrayList<>(); this.inorder(root, list); return list; } public void inorder(TreeNode root, List<Integer> res) { if (root == null) { return; } if (root.left != null) { inorder(root.left, res); } res.add(root.val); if (root.right != null) { inorder(root.right, res); } } \",\"迭代实现：\",\" public List<Integer> inorderTraversal(TreeNode root) { List<Integer> res = new ArrayList<>(); Stack<TreeNode> stack = new Stack<>(); while (stack.size() > 0 || root != null) { // 不断往左子树方向走，每走一次就将当前节点保存到栈中 // 这是模拟递归的调用 if (root != null) { stack.add(root); root = root.left; // 当前节点为空，说明左边走到头了，从栈中弹出节点并保存 // 然后转向右边节点，继续上面整个过程 } else { TreeNode tmp = stack.pop(); res.add(tmp.val); root = tmp.right; } } return res; } \",\"莫里斯遍历：\",\"public List<Integer> inorderTraversal3(TreeNode root) { if (root == null) { return new ArrayList<>(); } TreeNode cur = root; // 记录当前节点位置 List<Integer> res = new ArrayList<>(); while (cur != null) { if (cur.left == null) { // 左节点为空，移到右子节点 res.add(cur.val); cur = cur.right; } else { TreeNode prev = cur.left; while (prev.right != null && prev.right != cur) { // 遍历到左子树的最右侧节点 prev = prev.right; } if (prev.right == null) { // 建立返回父节点连接 prev.right = cur; cur = cur.left; } else { // 左子树建立了连接，说明遍历完了，可以拆除连接 res.add(cur.val); // 中序遍历录入当前节点 prev.right = null; cur = cur.right; } } } return res; } \"]},\"396\":{\"h\":\"\",\"t\":[\"递归解法：\",\" public int maxDepth(TreeNode root) { if (root == null) { return 0; } return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } \",\"广度优先遍历解法：\",\"public int maxDepthByBFS(TreeNode root) { if (root == null) { return 0; } int depth = 0; Queue<TreeNode> treeNodeQueue = new LinkedList<>(); treeNodeQueue.offer(root); while (!treeNodeQueue.isEmpty()) { int size = treeNodeQueue.size(); while (size > 0) { // 移除上一层的结点 TreeNode node = treeNodeQueue.poll(); if (node.left != null) { treeNodeQueue.add(node.left); } if (node.right != null) { treeNodeQueue.add(node.right); } size--; } depth++; } return depth; } \"]},\"397\":{\"h\":\"\",\"t\":[\"二叉搜索树有两个重要性质，第一，左子树上所有结点的值都要小于根节点的值，右子树所有结点的值都要大于根节点的值；第二，中序遍历后的结果是一个递增的数列。\",\"使用递归：\",\" public boolean validate(TreeNode node, long min, long max) { // 终止条件 if (node == null) { return true; } if (node.val <= min || node.val >= max) { return false; } // 相当于给子树上所有的节点都添加了min和max的边界 // 约束root的左子树的值不超过root的值，右子树的值不小于root的值 return validate(node.left, min, node.val) && validate(node.right, node.val, max); } \",\"利用中序遍历的性质：\",\" public boolean isValidBST(TreeNode root) { Deque<TreeNode> stack = new LinkedList<>(); // 存储上一个节点的值 double inorder = -Double.MAX_VALUE; while (root != null || !stack.isEmpty()) { while (root != null) { stack.push(root); root = root.left; } TreeNode node = stack.pop(); // 当前节点的值与上一个节点的值进行比较 if (node.val <= inorder) { return false; } inorder = node.val; root = node.right; } return true; } \",\"除此之外，也可以先进行中序遍历，然后判断返回的列表是否为升序。\"]},\"398\":{\"h\":\"\",\"t\":[\"树的祖先的定义：若节点P在节点root的左（右）子树中，或P=root，则称root是p的祖先。\",\"最近公共祖先的定义：设节点root为节点p，q的某公共祖先，若其左子节点root.left和右子节点root.right都不是p,q的公共祖先，则称root是\\\"最近的公共祖先\\\"。\",\"根据以上定义，若root是p,q的最近公共祖先，则只可能为以下情况之一：\",\"p 和q 在root的子树中，且分列root的异侧即分别在左、右子树中）\",\"p = root，且q在root的左或右子树中\",\"q = root，且p在root的左或右子树中\",\"class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null) return null; // 如果p,q为根节点，则公共祖先为根节点 if (root.val == p.val || root.val == q.val) return root; // 如果p,q在左子树，则公共祖先在左子树查找 if (find(root.left, p) && find(root.left, q)) { return lowestCommonAncestor(root.left, p, q); } // 如果p,q在右子树，则公共祖先在右子树查找 if (find(root.right, p) && find(root.right, q)) { return lowestCommonAncestor(root.right, p, q); } // 如果p,q分属两侧，则公共祖先为根节点 return root; } private boolean find(TreeNode root, TreeNode c) { if (root == null) return false; if (root.val == c.val) { return true; } return find(root.left, c) || find(root.right, c); } } \"]},\"399\":{\"h\":\"\",\"t\":[\"以求解[1,2,3]的子集为例，画出的树形图如下所示：\",\"使用回溯算法：\",\" public List<List<Integer>> subsets(int[] nums) { List<List<Integer>> res = new LinkedList<>(); dfs(nums, res, 0, new ArrayList<>()); return res; } public void dfs(int[] nums, List<List<Integer>> res, int n, ArrayList<Integer> temp) { res.add(new ArrayList<>(temp)); for (int i = n; i < nums.length; i++) { temp.add(nums[i]); dfs(nums, res, i + 1, temp); temp.remove(temp.size() - 1); } } \"]},\"400\":{\"h\":\"\",\"t\":[\"题目的状态树：\",\"使用回溯法：\",\" public List<String> letterCombinations(String digits) { List<String> res = new ArrayList<>(); if (digits.length() == 0) { return res; } Map<String, String> map = new HashMap<>(); map.put(\\\"2\\\", \\\"abc\\\"); map.put(\\\"3\\\", \\\"def\\\"); map.put(\\\"4\\\", \\\"ghi\\\"); map.put(\\\"5\\\", \\\"jkl\\\"); map.put(\\\"6\\\", \\\"mno\\\"); map.put(\\\"7\\\", \\\"pqrs\\\"); map.put(\\\"8\\\", \\\"tuv\\\"); map.put(\\\"9\\\", \\\"wxyz\\\"); dfs(digits, 0, map, res, new StringBuilder()); return res; } public void dfs(String digits, int index, Map<String, String> map, List<String> res, StringBuilder str) { if (index == digits.length()) { res.add(str.toString()); return; } // 获取当前数字对应的字符值 String val = map.get(digits.substring(index, index + 1)); for (char c : val.toCharArray()) { str.append(c); dfs(digits, index + 1, map, res, str); // 删除刚才添加到末尾的元素，选择当前数字对应字符串的下一个值进行遍历 str.deleteCharAt(str.length() - 1); } } \"]},\"401\":{\"h\":\"\",\"t\":[\"模板代码：\",\"class Solution { public List<List<Integer>> levelOrder(TreeNode root) { List<List<Integer>> ans = new ArrayList<>(); if (root == null) { return ans; } Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); List<Integer> list = new ArrayList<>(); for (int i = 0; i < size; i++) { TreeNode node = queue.poll(); list.add(node.val); TreeNode left = node.left; if (left != null) { queue.offer(left); } TreeNode right = node.right; if (right != null) { queue.offer(right); } } ans.add(list); } return ans; } } \"]},\"402\":{\"h\":\"107.二叉树的层次遍历 II\",\"t\":[\"力扣题目链接\",\"在二叉树的层次遍历上稍做改动：\",\"class Solution { public List<List<Integer>> levelOrderBottom(TreeNode root) { List<List<Integer>> ans = new ArrayList<>(); if (root == null) { return ans; } Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { List<Integer> list = new ArrayList<>(); int size = queue.size(); for (int i = 0; i < size; i++) { TreeNode node = queue.poll(); list.add(node.val); TreeNode left = node.left; if (left != null) { queue.offer(left); } TreeNode right = node.right; if (right != null) { queue.offer(right); } } ans.add(0, list); } return ans; } } \"]},\"403\":{\"h\":\"199.二叉树的右视图\",\"t\":[\"力扣题目链接\",\"同样的，在二叉树的层次遍历上稍做改动：\",\"class Solution { public List<Integer> rightSideView(TreeNode root) { List<Integer> ans = new ArrayList<>(); if (root == null) { return ans; } Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i < size; i++) { TreeNode node = queue.poll(); if (i == size - 1) { ans.add(node.val); } TreeNode left = node.left; if (left != null) { queue.offer(left); } TreeNode right = node.right; if (right != null) { queue.offer(right); } } } return ans; } } \",\"递归解法：\",\"class Solution { public List<Integer> rightSideView(TreeNode root) { List<Integer> res = new ArrayList<>(); recursion(root, res, 0); return res; } private void recursion(TreeNode curr, List<Integer> res, int currDepth) { if (curr == null) { return; } if (currDepth == res.size()) { res.add(curr.val); } recursion(curr.right, res, currDepth + 1); recursion(curr.left, res, currDepth + 1); } } \"]},\"404\":{\"h\":\"515.在每个树行中找最大值\",\"t\":[\"力扣题目链接\",\"class Solution { public List<Integer> largestValues(TreeNode root) { List<Integer> ans = new ArrayList<>(); if (root == null) { return ans; } Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); Integer max = Integer.MIN_VALUE; while (size > 0) { // 和for循环一样，没有区别 TreeNode node = queue.poll(); max = Math.max(max, node.val); TreeNode left = node.left; if (left != null) { queue.offer(left); } TreeNode right = node.right; if (right != null) { queue.offer(right); } size--; } ans.add(max); } return ans; } } \"]},\"405\":{\"h\":\"226.翻转二叉树\",\"t\":[\"递归即可：\",\"class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) { return null; } TreeNode temp = root.left; root.left = root.right; root.right = temp; // 注意这里不需要判断 root.left 是否为空 invertTree(root.left); invertTree(root.right); return root; } } \"]},\"406\":{\"h\":\"101. 对称二叉树\",\"t\":[\"class Solution { public boolean isSymmetric(TreeNode root) { if (root == null) { return false; } return recusion(root.left, root.right); } private boolean recusion(TreeNode left, TreeNode right) { if (left == null && right != null) { return false; } if (left != null && right == null) { return false; } if (left == null && right == null) { return true; } if (left.val != right.val) { return false; } boolean leftSsSymmetric = recusion(left.left, right.right); boolean rightSsSymmetric = recusion(left.right, right.left); return leftSsSymmetric && rightSsSymmetric; } } \",\"简洁一点的写法：\",\"class Solution { public boolean isSymmetric(TreeNode root) { if (root == null) return false; return recursion(root.left, root.right); } private boolean recursion(TreeNode left, TreeNode right) { if (left != null && right == null) return false; if (left == null && right != null) return false; if (left == null && right == null) return true; if (left.val != right.val) return false; return recursion(left.left, right.right) && recursion(left.right, right.left); } } \"]},\"407\":{\"h\":\"222.完全二叉树的节点个数\",\"t\":[\"力扣题目链接\",\"class Solution { public int countNodes(TreeNode root) { if (root == null) { return 0; } return countNodes(root.left) + countNodes(root.right) + 1; } } \"]},\"408\":{\"h\":\"110.平衡二叉树\",\"t\":[\"力扣题目链接\",\"class Solution { public boolean isBalanced(TreeNode root) { return height(root) != -1; } private int height(TreeNode root) { if (root == null) { return 0; } int left = height(root.left); if (left == -1) { return -1; } int right = height(root.right); if (right == -1) { return -1; } if (Math.abs(right - left) > 1) { // 左右子树的高度差1，说明已经不是平衡树了 return -1; } return Math.max(left, right) + 1; } } \"]},\"409\":{\"h\":\"257. 二叉树的所有路径\",\"t\":[\"力扣题目链接\",\"递归：\",\"class Solution { public List<String> binaryTreePaths(TreeNode root) { List<String> ans = new ArrayList<>(); dfs(ans, \\\"\\\", root); return ans; } private void dfs(List<String> ans, String path, TreeNode root) { if (root == null) { return; } if (root.left == null && root.right == null) { path += root.val; ans.add(path); return; } path += root.val + \\\"->\\\"; dfs(ans, path, root.left); dfs(ans, path, root.right); } } \",\"执行结果：\",\"使用StringBuilder效率会有所提升：\",\"class Solution { public List<String> binaryTreePaths(TreeNode root) { List<String> ans = new ArrayList<>(); dfs(ans, \\\"\\\", root); return ans; } private void dfs(List<String> ans, String path, TreeNode root) { if (root == null) { return; } if (root.left == null && root.right == null) { String s = new StringBuilder(path).append(root.val).toString(); ans.add(s); return; } String s = new StringBuilder(path).append(root.val).append(\\\"->\\\").toString(); dfs(ans, s, root.left); dfs(ans, s, root.right); } } \",\"执行结果：\",\"前序遍历的回溯算法：\",\"class Solution { public List<String> binaryTreePaths(TreeNode root) { List<String> ans = new ArrayList<>(); List<Integer> paths = new ArrayList<>(); dfs(ans, paths, root); return ans; } private void dfs(List<String> ans, List<Integer> paths, TreeNode root) { paths.add(root.val); if (root.left == null && root.right == null) { StringBuilder sb = new StringBuilder(); for (Integer path : paths) { sb.append(path).append(\\\"->\\\"); } sb.delete(sb.length() - 2, sb.length()); ans.add(sb.toString()); return; } if (root.left != null) { dfs(ans, paths, root.left); paths.remove(paths.size() - 1); } if (root.right != null) { dfs(ans, paths, root.right); paths.remove(paths.size() - 1); } } } \"]},\"410\":{\"h\":\"404.左叶子之和\",\"t\":[\"力扣题目链接\",\"递归法：\",\"class Solution { public int sumOfLeftLeaves(TreeNode root) { if (root == null) { return 0; } return dfs(root); } private int dfs(TreeNode root) { if (root == null) { return 0; } int left = dfs(root.left); int right = dfs(root.right); int val = 0; if (root.left != null && root.left.left == null && root.left.right == null) { // 说明是左侧节点 val = root.left.val; } return left + right + val; } } \",\"迭代法：\",\"class Solution { public int sumOfLeftLeaves(TreeNode root) { if (root == null) { return 0; } int ans = 0; Stack<TreeNode> stack = new Stack<TreeNode>(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (node.left != null && node.left.left == null && node.left.right == null) { ans += node.left.val; } TreeNode left = node.left; if (left != null) { stack.push(left); } TreeNode right = node.right; if (right != null) { stack.push(right); } } return ans; } } \"]},\"411\":{\"h\":\"513.找树左下角的值\",\"t\":[\"力扣题目链接\",\"递归解法：\",\"class Solution { private int maxDepth = Integer.MIN_VALUE; private int ans = 0; public int findBottomLeftValue(TreeNode root) { if (root == null) { return ans; } dfs(root, 0); return ans; } private void dfs(TreeNode root, int depth) { if (root == null) { return; } if (root.left == null && root.right == null) { // 是叶子节点 if (depth > maxDepth) { ans = root.val; maxDepth = depth; } } dfs(root.left, depth + 1); dfs(root.right, depth + 1); } } \",\"层序遍历：\",\"class Solution { public int findBottomLeftValue(TreeNode root) { if (root == null) { return 0; } int ans = 0; Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i < size; i++) { TreeNode node = queue.poll(); if (i == 0) { ans = node.val; } TreeNode left = node.left; if (left != null) { queue.offer(left); } TreeNode right = node.right; if (right != null) { queue.offer(right); } } } return ans; } } \"]},\"412\":{\"h\":\"112. 路径总和\",\"t\":[\"力扣题目链接\",\"class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) { return false; } if (root.left == null && root.right == null) { return root.val == targetSum; } return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val); } } \"]},\"413\":{\"h\":\"树总结\",\"t\":[\"递归是解决树的最重要的方法。\"]},\"414\":{\"h\":\"回溯算法\"},\"415\":{\"h\":\"\",\"t\":[\"括号生成的状态树：\",\" public List<String> generateParenthesis(int n) { List<String> res = new LinkedList<>(); if (n <= 0) { return res; } dfs(\\\"\\\", res, n, 0, 0); return res; } public void dfs(String paths, List<String> res, int n, int left, int right) { // 剪枝,去掉( > n 或 ) > n 或 ) > (的情况，由于传递性，) > n可以去掉 if (left > n || right > left) { return; } // 因为括号都是成对出现的，因此需要遍历的树的深度为n*2 if (paths.length() == n * 2) { res.add(paths); // 每次遍历后，需要将上一次的结果清理，从根结点继续遍历 paths = \\\"\\\"; return; } dfs(paths + '(', res, n, left + 1, right); dfs(paths + ')', res, n, left, right + 1); } \"]},\"416\":{\"h\":\"\"},\"417\":{\"h\":\"\",\"t\":[\" public List<List<String>> solveNQueens(int n) { List<List<String>> solutions = new ArrayList<List<String>>(); int[] queens = new int[n]; Arrays.fill(queens, -1); Set<Integer> columns = new HashSet<Integer>(); Set<Integer> diagonals1 = new HashSet<Integer>(); Set<Integer> diagonals2 = new HashSet<Integer>(); backtrack(solutions, queens, n, 0, columns, diagonals1, diagonals2); return solutions; } public void backtrack(List<List<String>> solutions, int[] queens, int n, int row, Set<Integer> columns, Set<Integer> diagonals1, Set<Integer> diagonals2) { if (row == n) { List<String> board = generateBoard(queens, n); solutions.add(board); } else { for (int i = 0; i < n; i++) { if (columns.contains(i)) { continue; } int diagonal1 = row - i; if (diagonals1.contains(diagonal1)) { continue; } int diagonal2 = row + i; if (diagonals2.contains(diagonal2)) { continue; } queens[row] = i; columns.add(i); diagonals1.add(diagonal1); diagonals2.add(diagonal2); backtrack(solutions, queens, n, row + 1, columns, diagonals1, diagonals2); queens[row] = -1; columns.remove(i); diagonals1.remove(diagonal1); diagonals2.remove(diagonal2); } } } public List<String> generateBoard(int[] queens, int n) { List<String> board = new ArrayList<String>(); for (int i = 0; i < n; i++) { char[] row = new char[n]; Arrays.fill(row, '.'); row[queens[i]] = 'Q'; board.add(new String(row)); } return board; } \"]},\"418\":{\"h\":\"贪心算法\"},\"419\":{\"h\":\"\",\"t\":[\"使用贪心算法：\",\" public int maxProfit(int[] prices) { int profit = 0; int min = prices[0]; for (int i = 0; i < prices.length; i++) { if (prices[i] < min) { min = prices[i]; } else { profit = Math.max(prices[i] - min, profit); } } return profit; } \",\"需要注意的是，本题中股票值买卖一次。\"]},\"420\":{\"h\":\"\",\"t\":[\"使用贪心算法：\",\"public \"]},\"421\":{\"h\":\"\",\"t\":[\"使用贪心算法：\",\"此时0这个位置的下标是4，但是之前最大的可达步数是3，因为无法再进行跳跃。\",\" public boolean canJump(int[] nums) { // 最大能跳跃到的地方 int maxJump = 0; for (int i = 0; i < nums.length; i++) { if (i > maxJump) { return false; } maxJump = Math.max(i + nums[i], maxJump); } return true; } \"]},\"422\":{\"h\":\"\",\"t\":[\"使用贪心算法：\",\" public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); // 孩子数组的下标 int i = 0; // 饼干数组的下标 int j = 0; while (i < g.length && j < s.length) { // 满足条件就下一个孩子 if (g[i] <= s[i]) { i++; } // 不满足下一个饼干 j++; } // 下标i正好是满足条件的孩子的个数 return i; } \"]},\"423\":{\"h\":\"动态规划\"},\"424\":{\"h\":\"\",\"t\":[\"直接使用递归求接斐波那契数列：\",\" public int climbStairs(int n) { if (n == 1) { return 1; } if (n == 2) { return 2; } return climbStairs(n - 1) + climbStairs(n - 2); } \",\"使用循环求解：\",\" public int climbStairs(int n) { if (n <= 2) { return n; } int f1 = 1, f2 = 2, f3 = 3; for (int i = 3; i < n + 1; i++) { f3 = f1 + f2; // 优化 f1 = f2; f2 = f3; } return f3; } \",\"也可以直接dp求解：\",\" public int climbStairs(int n) { if(n <= 2) { return n; } int[] dp = new int[n]; dp[0] = 1; dp[1] = 2; for(int i = 2; i < n; i++) { dp[i] = dp[i-1] + dp[i - 2]; } return dp[n -1]; } \"]},\"425\":{\"h\":\"\",\"t\":[\"递推公式：\",\"f(m,n)=f(m−1,n)+f(m,n−1)\",\"直接求解即可：\",\" public int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; // 最后一行和最后一列都只有一种走法 for (int i = 0; i < m; i++) { dp[i][0] = 1; } for (int j = 0; j < n; j++) { dp[0][j] = 1; } for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; } \"]},\"426\":{\"h\":\"\",\"t\":[\"注意，本题要求每一步只能移动到下一行相邻的结点上，由此，递归方程为：\",\"f(i,j)=min{f(i−1,j),f(i−1,j−1)}+c(i)(j)\",\"其中c(i)(j)表示位置(i,j)对应的元素值。\",\" public int minimumTotal(List<List<Integer>> triangle) { int n = triangle.size(); // 结果一定是下三角矩阵 int[][] dp = new int[n][n]; dp[0][0] = triangle.get(0).get(0); for (int i = 1; i < n; i++) { // 第一列的结果等于上一行的元素加上当前行的元素 dp[i][0] = dp[i - 1][0] + triangle.get(i).get(0); for (int j = 1; j < i; j++) { // 除了第一列元素和最后一列元素都满足状态转移方程 dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle.get(i).get(j); } // 对角线上的元素等于上一个对角线元素加上当前元素 dp[i][i] = dp[i - 1][i - 1] + triangle.get(i).get(i); } // 最后一行就是所有的结果，找出最小值即可 int min = dp[n - 1][0]; for (int i = 1; i < n; i++) { min = Math.min(min, dp[n - 1][i]); } return min; } \"]},\"427\":{\"h\":\"\",\"t\":[\"假设字符串text1​和text2​的长度分别为m和n，创建m+1行n+1列的二维数组dp，其中dp[i][j]表示text1​[0:i]和text2​[0:j]的最长公共序列的长度，状态转移方程如下：\",\"dp[i][j]={dp[i−1][j−1]+1,max(dp[i−1][j],dp[i][j−1]),​text1​[i−1]=text2​[j−1]text1​[i−1]=text2​[j−1]​\",\"示意图：\",\"直接求解即可：\",\" public int longestCommonSubsequence(String text1, String text2) { int m = text1.length(); int n = text2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i < m + 1; i++) { char c1 = text1.charAt(i - 1); for (int j = 1; j < n + 1; j++) { char c2 = text2.charAt(j - 1); // text_1[i - 1] = text_2[j -1] if (c1 == c2) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { // text_1[i - 1] ≠ text_2[j -1] dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; } \"]},\"428\":{\"h\":\"\",\"t\":[\"我们使用p(i,j)表示字符串s的第i到j个字母组成的串（下文表示成s[i:j]）是否为回文串：\",\"p(i,j)={true,false,​如果字串Si​...Sj​是回文串其它情况​\",\"这里的其它情况包含两种可能性：\",\"s[i,j]本身不是一个回文串\",\"i>j，此时s[i,j]本身不合法\",\"那么对应的状态转移方程：\",\"p(i,j)=p(i+1,j−1)∧(Si​==Sj​)\",\"以上都是子串长度2的前提之上的，对于长度为1的字串，明显就是回文串，对于长度为2的字串，只要它的两个字母相同，就是一个回文串，因此，可以确定动态规划的边界条件：\",\"{p(i,i)=true,p(i,i+1)=(Si​==Si+1​),​如果字串Si​...Sj​是回文串其它情况​\",\"相应的示例代码：\",\" public String longestPalindrome(String s) { int len = s.length(); if (len < 2) { return s; } int maxLen = 1; int begin = 0; // dp[i][j] 表示 s[i..j] 是否是回文串 boolean[][] dp = new boolean[len][len]; // 初始化：所有长度为 1 的子串都是回文串 for (int i = 0; i < len; i++) { dp[i][i] = true; } char[] charArray = s.toCharArray(); // 递推开始 // 先枚举子串长度 for (int L = 2; L <= len; L++) { // 枚举左边界，左边界的上限设置可以宽松一些 for (int i = 0; i < len; i++) { // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得 int j = L + i - 1; // 如果右边界越界，就可以退出当前循环 if (j >= len) { break; } if (charArray[i] != charArray[j]) { dp[i][j] = false; } else { if (j - i < 3) { dp[i][j] = true; } else { dp[i][j] = dp[i + 1][j - 1]; } } // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置 if (dp[i][j] && j - i + 1 > maxLen) { maxLen = j - i + 1; begin = i; } } } return s.substring(begin, begin + maxLen); } \"]},\"429\":{\"h\":\"\",\"t\":[\"直接暴力递归的时间复杂度是O(2n)，因为需要优化，优化的思路大致分为两种，一种是记忆化搜索，一种是动态规划，使用记忆化搜索相当于剪枝，记忆化搜索的递归树：\",\"代码：\",\"class Solution { public int fib(int n) { if (n < 2) { return n; } int[] dp = new int[n + 1]; dp[0] = 0; dp[1] = 1; for (int i = 2; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; } } \",\"所谓的状态转移方程或者说递推公式为：dp[i] = dp[i - 1] + dp[i - 2]。\",\" public int fib(int n) { int[] dp = {0, 1}; for (int i = 2; i < n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; } \",\"还可以进一步优化，实际上每次只需要存储最近的两个结果即可，按照这个思路，可以将空间复杂度优化到O(1)。\",\" public int fib(int n) { if (n <= 1) return n; // 初始的时候，分别对应f(o) = 0和f(1) = 1 int prev = 0, curr = 1; for (int i = 2; i <= n; i++) { int sum = prev + curr; // 原来的值变成前一个元素 prev = curr; // 新的值变成当前值 curr = sum; } return curr; } \"]},\"430\":{\"h\":\"\",\"t\":[\"不难写出，这个问题的状态转移方程：\",\"f(i)=max{f(i−1)+nums[i],num[i]}\",\"使用数组来保存 f(i) 的值，遍历求出所有的 f(i) 即可：\",\" public int maxSubArray(int[] nums) { int[] dp = new int[nums.length]; dp[0] = nums[0]; int res = nums[0]; for (int i = 1; i < nums.length; i++) { dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); res = Math.max(dp[i], res); } return res; } \",\"实际上我们无需记录所有的中间状态，只需要记录前一个值即可：\",\" public int maxSubArray(int[] nums) { int pre = 0, maxAns = nums[0]; for (int x : nums) { pre = Math.max(pre + x, x); maxAns = Math.max(maxAns, pre); } return maxAns; } \"]},\"431\":{\"h\":\"\",\"t\":[\"假设一共有n个房子，每个房子的金额分别是H0​,H1​,...Hn−1​，子问题f(k)表示从前k个房子（即H0​，H1​,...,Hk−1​）中能偷盗的最大金额。那么偷k个房子有两种偷法：\",\"状态转移方程为：\",\"f(k)=max{f(k−1),Hk−1​+f(k−2)}\",\"使用一维数组的方式：\",\" public int rob(int[] nums) { if (nums == null || nums.length == 0) return 0; int n = nums.length; // 第0位用来存储0的情况，从第1位开始存储nums[1] int[] dp = new int[n + 1]; dp[0] = 0; dp[1] = nums[0]; // 注意这里从2开始，到n+1 for (int i = 2; i < n + 1; i++) { dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2]); } return dp[n]; } \",\"还可以多开一维数组来存每次偷或者不偷的状态：\",\" public int rob(int[] nums) { if (nums == null || nums.length == 0) return 0; int n = nums.length; int[][] dp = new int[n][2]; // 0表示不选当前元素，1表示选择当前元素 dp[0][0] = 0; dp[0][1] = nums[0]; for (int i = 1; i < n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]); dp[i][1] = dp[i - 1][0] + nums[i]; } return Math.max(dp[n - 1][0], dp[n - 1][1]); } \"]},\"432\":{\"h\":\"\",\"t\":[\"状态转移方程：\",\"dp[i]=max(dp[i−2]+nums[i],dp[i−1])\",\"边界条件为：\",\"{dp[start]=nums[start]dp[start+1]=max(nums[start],nums[start+1])​只有一间房屋，则偷窃该房屋只有两件房屋，偷窃其中金额较高的房屋​\",\"相应的实现：\",\"class{ } \"]},\"433\":{\"h\":\"\"},\"434\":{\"h\":\"图论\"},\"435\":{\"h\":\"\",\"t\":[\"岛屿问题是一类典型的网格问题。通常而言，网格中的格子的相邻的格子节点分别是上下左右四个。\",\"在这类问题中，深度优先遍历的终止条件：\",\"这样我们就得到了网格DFS遍历的框架代码：\",\"void dfs(int[][] grid, int r, int c) { // 判断 base case // 如果坐标 (r, c) 超出了网格范围，直接返回 if (!inArea(grid, r, c)) { return; } // 访问上、下、左、右四个相邻结点 dfs(grid, r - 1, c); dfs(grid, r + 1, c); dfs(grid, r, c - 1); dfs(grid, r, c + 1); } // 判断坐标 (r, c) 是否在网格中 boolean inArea(int[][] grid, int r, int c) { return 0 <= r && r < grid.length && 0 <= c && c < grid[0].length; } \",\"与二叉树的深度遍历不同的是，网格的遍历可能会遍历重复的节点：\",\"为了避免这样重复的遍历，我们可以将已经遍历过的格子进行标记，也就是说，每个格子可能取三个值：\",\"0 表示海洋格子\",\"1 表示陆地格子（未遍历过）\",\"2 表示陆地格子（已遍历过）\",\"因此我们可以将代码模板修改为：\",\"void dfs(int[][] grid, int r, int c) { // 判断 base case if (!inArea(grid, r, c)) { return; } // 如果这个格子不是岛屿，直接返回 if (grid[r][c] != 1) { return; } grid[r][c] = 2; // 将格子标记为「已遍历过」 // 访问上、下、左、右四个相邻结点 dfs(grid, r - 1, c); dfs(grid, r + 1, c); dfs(grid, r, c - 1); dfs(grid, r, c + 1); } // 判断坐标 (r, c) 是否在网格中 boolean inArea(int[][] grid, int r, int c) { return 0 <= r && r < grid.length && 0 <= c && c < grid[0].length; } \",\"利用这个代码模板求接这个问题实际上就是求深度遍历的次数：\",\" public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } // 实际上就是求深度遍历的次数 int dfsNumber = 0; for (int r = 0; r < grid.length; r++) { for (int c = 0; c < grid[0].length; c++) { if (grid[r][c] == '1') { dfs(grid, r, c); dfsNumber++; } } } return dfsNumber; } public void dfs(char[][] grid, int r, int c) { // 注意这里的次序不能交换，必须先判断在网格中，再判断元素是否等于'1' if (!inArea(grid, r, c) || grid[r][c] != '1') { return; } // 已经遍历过了就设置为0 grid[r][c] = '0'; dfs(grid, r - 1, c); dfs(grid, r + 1, c); dfs(grid, r, c - 1); dfs(grid, r, c + 1); } // 判断格子是否在网格中 boolean inArea(char[][] grid, int r, int c) { return 0 <= r && r < grid.length && 0 <= c && c < grid[0].length; } \"]},\"436\":{\"h\":\"数学\"},\"437\":{\"h\":\"\",\"t\":[\" public int singleNumber(int[] nums) { int single = 0; for (int num : nums) { single ^= num; } return single; } \"]},\"438\":{\"h\":\"\",\"t\":[\"使用暴力解法：\",\" public double myPow(double x, int n) { long N = n; if (N < 0) { N = -n; x = 1 / x; } double ans = 1; while (N > 0) { ans = ans * x; N--; } return x; } \",\"通过观察不难发现，对于f(n) = xn（x为常数）都有f(n) = f(n/2)* f(n/2)，因此可以通过分治的方式来处理：\",\"public double myPow2(double x, int n) { if (n == 0 || x==1) { return 1; } long N = n; if (N < 0) { N = -N; x = 1 / x; } return myPow2Helper(x, N); } private double myPow2Helper(double x, long N) { if (N == 1) { return x; } // 如果指数是奇数，则需要补乘一个x if (N % 2 != 0) { return myPow2Helper(x, N / 2) * myPow2Helper(x, N / 2) * x; } else { return myPow2Helper(x, N / 2) * myPow2Helper(x, N / 2); } } \"]},\"439\":{\"h\":\"\",\"t\":[\"使用二分查找：\",\" public int mySqrt(int x) { int left = 0; int right = x; while (left < right) { int mid = left + (right - left + 1) / 2; // 注意：这里为了避免乘法溢出，改用除法 if (mid > x / mid) { right = mid - 1; } else { left = mid + 1; } } return left; } \",\"另外，解决此类问题也可以使用平方根法。\"]},\"440\":{\"h\":\"\",\"t\":[\" public boolean isPerfectSquare(int num) { int left = 0; int right = num; while (left <= right) { // 这么写的原因是极端情况下left + right相加的结果溢出 int mid = left + (right - left) / 2; if (mid * mid == num) { return true; } else if (mid * mid > num) { right = mid - 1; } else { left = mid + 1; } } return false; } \"]},\"441\":{\"h\":\"\",\"t\":[\" public static int thirdMax(int[] nums) { Set<Integer> set = new HashSet<>(); for (int n : nums) { set.add(n); if (set.size() > 3) { set.remove(Collections.min(set)); } } // 第三大的正好是集合当中最小的元素 if (set.size() == 3) { return Collections.min(set); } // 说明数组的元素不超过3个 return Collections.max(set); } \"]},\"442\":{\"h\":\"矩阵\"},\"443\":{\"h\":\"\",\"t\":[\"将矩阵每一行拼接在上一行的末尾，则会得到一个升序数组，我们可以在该数组上二分找到目标元素，可以二分升序数组的下标，将其映射到原矩阵的行和列上：\",\" public boolean searchMatrix(int[][] matrix, int target) { int r = matrix.length; int c = matrix[0].length; int left = 0; // 总共有这么多个元素 int right = r * c - 1; while (left < right) { int mid = left + (right - left) / 2; // 最主要的就是元素映射到原矩阵的行和列上 // mid/c刚好是行数,mid%c刚好是列数,注意矩阵的下标从0开始算起 int element = matrix[mid / c][mid % c]; if (element == target) { return true; } else if (element < target) { left = mid + 1; } else if (element > target) { right = mid - 1; } } return false; } \"]},\"444\":{\"h\":\"ElaticSearch\"},\"445\":{\"h\":\"ElaticSearch快速入门\"},\"446\":{\"h\":\"ElaticSearch高级查询语法Query DSL\",\"t\":[\"参考链接：https://note.youdao.com/ynoteshare/index.html?id=924a9d435d78784455143b1dda4a874a&type=note&_time=1684249060388\"]},\"447\":{\"h\":\"ElaticSearch搜索技术与聚合查询\"},\"448\":{\"h\":\"ElaticSearch高阶功能\"},\"449\":{\"h\":\"ElaticSearch集群架构实战及其原理\",\"t\":[\"链接：https://note.youdao.com/ynoteshare/index.html?id=16ca3fcfcdda46a976cfd978e20df4be&type=note&_time=1684856471454\",\"为什么说ElaticSearch是一个近实时的搜索引擎？\"]},\"450\":{\"h\":\"Logstash与FileBeat详解以及EFK整合\"},\"451\":{\"h\":\"MongoDb\"},\"452\":{\"h\":\"MongoDb入门\"},\"453\":{\"h\":\"MySQL基础\"},\"454\":{\"h\":\"MySQL逻辑架构\",\"t\":[\"让我们从最简单的情形开始，假设有一张这样的表T，表里只有一个ID字段，在执行下面这个查询语句时：\",\"select * from T where ID=10; \",\"我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程，要想更深入的了解，就需要了解MySQL的逻辑架构：\",\"大体来说，MySQL可以分为Server层和存储引擎两部分。\",\"Server层包括连接器、查询缓存、分析器、优化器、执行器，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。\",\"而存储引擎层负责数据的存储和提取，其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎，现在最常用的存储引擎是InnoDB，它从MySQL5.5.5版本开始称为了默认的存储引擎。\",\"这也就是说，在执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不过，在使用create table语句中使用engine=memory来指定存储引擎的类型来创建表，不同的存储引擎的表数据获取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。\",\"从图中不难看出，不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分。接下来我们会从上文提到的SQL语句，梳理它执行的完整的流程，了解每个组件的作用。\"]},\"455\":{\"h\":\"连接器\",\"t\":[\"执行SQL语句的第一步，总是会使用连接器连接到这个数据库上。连接器负责跟客户端建立连接、获取权限、维持和管理连接，连接命令通常如下：\",\"mysql -h$ip -P$port -u$user -p \",\"输完命令之后，就需要交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致你的密码泄露。如果你连接的是生产服务器，强烈建议你不要这么做。\",\"连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。\",\"如果用户名或密码不对，你就会收到一个“Access denied for user”的错误，然后客户端程序结束执行\",\"如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限，之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限\",\"这就意味着，一个用户成功建立连接后，即使你使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。\",\"连接完成之后，如果你没有后续的动作，这个连接就处于空闲状态，可以使用show processlist命令中看到它，其中Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。\",\"客户端如果太长时间没有动静，连接器就会自动将他断开，这个时间是由参数wait_timeout控制的，默认值是8小时。\",\"如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提示：Lost connection to MySQL Server during queery。这时候如果你要继续，就需要重连，然后再执行请求了。\",\"连接可以分为两种：长连接和短连接。长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。\",\"建立连接的过程通常是比较复杂的，所以在使用的过程中要尽量减少建立连接的动作，也就是尽量使用长连接。但是全部使用长连接后，你可能会发现，有些使用MySQL占用内存涨的特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。\",\"解决这个问题通常有两种方案：\",\"定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连\",\"如果使用的MySQL5.7或更新的版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完成时的状态\"]},\"456\":{\"h\":\"查询缓存\",\"t\":[\"连接建立完成后，就可以正式开始执行select语句了，执行逻辑就会来到第二步：查询缓存。\",\"MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句，之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存到内存中。key是查询的语句，value是查询的结果，如果查询能够直接这个缓存中找到key，那么这个value就会被直接返回给客户端。\",\"如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中，可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，效率就会很高。\",\"但是大多数情况下不要使用查询缓存，查询缓存的失效非常频繁，只要有对一个表的更新，这个表上的查询缓存都会被清空。因此很有可能费劲的把结果存起来，还没有使用，但是就被更新操作清空掉了，对于更新压力大的数据库来说，查询缓存的命中率会非常低，除非业务就是有一张静态表，很长时间才会更新依次，比如，一个系统的配置表，那这张表上的查询才适合使用查询缓存。\",\"MySQL提供了参数配置，可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存，而对于确定要使用查询缓存的语句，可以使用SQL_CACHE显式指定：\",\" select SQL_CACHE * from T where ID=10 ； \",\"MySQL8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始就彻底没有这个功能了。\"]},\"457\":{\"h\":\"分析器\",\"t\":[\"如果没有命中查询缓存，就要真正开始执行语句了。MySQL会使用分析器对SQL语句做解析，识别出SQL语句中的字符串分别是什么，代表什么。在之前的例子中，MySQL会从输入的“select”关键字识别出来，这是一个查询语句，它也要把字符串“T”识别成表名“T”，把字符串“ID”识别成“列ID”，做完了这些识别以后，就要做“语法分析”，根据词法分析的结果，语法分析器会根据语法规则，判断输入的SQL语句是否满足MySQL语法。\",\"如果语句不对，就会收到“You have an error in your SQL syntax”的错误提醒。\"]},\"458\":{\"h\":\"优化器\",\"t\":[\"经过了分析器，MySQL就知道你想要做什么了，在开始执行之前，还需要经过优化器的处理。\",\"优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序，比如执行下面的语句：\",\"select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; \",\"既可以先从表里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20\",\"也可以先从表t2里面取出d=20的记录的值，再根据ID值关联到t1，再判断t1里面c的值是否等于10\",\"这两种执行方法的逻辑结果是一样的，但是执行的效率会有所不同，而优化器的作用就是决定选择使用哪一种方案。优化器的阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。\"]},\"459\":{\"h\":\"执行器\",\"t\":[\"MySQL通过分析器知道了要做什么。通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。开始执行的时候，要先判断有没有对应的查询权限，如果没有，就会返回没有权限的错误，如下所示：\",\"mysql> select * from T where ID=10; ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T' \",\"如果有权限，就打开表继续执行，打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口，比如上述例子中表T中，ID字段没有索引，那么执行器的执行流程如下：\",\"调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中\",\"调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行\",\"执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端\",\"至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。\",\"数据库的慢查询日志中，字段rows_examined表示这个语句执行过程中扫描了多少行，这个值就是在执行器每次调用引擎获取数据行的时候累加的。不过在有些场景下，执行器调用一次，在引擎内部扫描了多行，因此引擎扫描行数跟rows_examined并不是完全相同的。\"]},\"460\":{\"h\":\"SQL执行流程\",\"t\":[\"MySQL可以借助重做日志和归档日志恢复到半个月内任意一秒的状态。为了了解它的实现原理，我们从一个表的一条更新语句开始：\",\"create table T(ID int primary key, c int); \",\"如果要将ID=2这一行的值加1，SQL如下：\",\"update T set c=c+1 where ID=2; \",\"同样的更新语句也会按照SQL语句的基本执行链路执行：\",\"与查询流程不一样的是，更新流程还设计两个重要的的日志模块：redo log（重做日志）和binlog（归档日志），这是MySQL中两个核心概念。\"]},\"461\":{\"h\":\"重做日志\",\"t\":[\"如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL会使用WAL技术（Write-Ahead Logging），先写日志，再写磁盘。\",\"具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录到磁盘里面，而这个更新往往是在系统比较空闲的时候做。InnoDB的redo log是固定大小的，比如可以配置一组4个文件，每个文件的大小是1GB，那么总共就可以记录4GB的操作。从头开始写入，到末尾又回到开头循环写入，如下图所示：\",\"其中write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头，checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。write pos和checkpoint之间还空着的部分，就可以用来记录新的操作，如果write pos追上了checkpoint，那么就表示不能再执行新的更新操作了，就得先停下来擦掉一些记录，然后将checkpoint向后移动。\",\"有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。\"]},\"462\":{\"h\":\"归档日志\",\"t\":[\"MySQL从整体上来看，大致可以分为两部分，一块是Server层，它主要负责MySQL功能层面的事情，另一块是引擎层，负责存储相关的具体事宜。上文提到的redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为bin log（归档日志）。由于最开始的MySQL并没有InnoDB引擎，MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。\",\"redo log和binlog有以下区别：\",\"redo log是InnoDB引擎所特有的，binlog是MySQL的Server层实现的，所有引擎都可以使用\",\"redo log是物理日志，记录的是“在某个数据页上做了什么修改”，binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1”\",\"redo log是循环写的，空间固定会用完，binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到写一个，并不会覆盖以前的日志\"]},\"463\":{\"h\":\"更新语句执行流程\",\"t\":[\"了解这两个日志的作用，我们再来看执行器和InnoDB引擎在执行这个update语句时的内部流程。\",\"执行器先找引擎取ID=2这一行，ID是逐渐，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回\",\"执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据\",\"引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态，然后告知执行器执行完成了，随时可以提交事务\",\"执行器生成这个操作的binlog，并把binlog写入磁盘\",\"执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成\",\"update语句的执行如下图：\",\"注意这里并不是直接写入redo log，而是将redo log的写入拆成了两个步骤：prepare和commit，这就是“两阶段提交”。\"]},\"464\":{\"h\":\"两阶段提交\",\"t\":[\"两阶段提交为了让两份日志之间的逻辑一致，要说明这个问题，我们得从文章开头的那个问题说起：怎样让数据库恢复到半个月内任意一秒的状态？\",\"上文提到过，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式，当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那么可以：\",\"首先，找到最近的一次全量备份，如果运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库\",\"然后，从备份的时候点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻\",\"这样临时库就跟误删之前的线上库一样了，然后就可以把表数据从临时库取出来，按需要恢复到线上库去。\",\"接下来我们说明为什么需要两阶段提交，由于redo log和binlog时两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序，我们来看看这两种方式会有什么问题：\",\"先写redo log后写binlog。假设在redo log写完，binlog还没有写完的时候，MySQL异常重启，上文提到过，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复这一行c的值是1，但是由于binlog没写完就crash了，这个时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句，这个时候，如果需要用binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同\",\"先写binlog后写redo log，如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志，所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行的c的值就是1，与原库的值不同\",\"可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致，不过你可能会问，碰到需要用日志恢复数据的场景是不是很少，其实，并不只是误操作以后需要用这个过程来恢复数据，当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就不会导致线上出现主从数据库不一致的情况。\",\"简单来说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。\"]},\"465\":{\"h\":\"MySQL性能分析工具\"},\"466\":{\"h\":\"explain 简介\",\"t\":[\"EXPLAIN是什么？\",\"EXPLAIN：SQL的执行计划，使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句的。\",\"EXPLAIN怎么使用？\",\"语法：explain + SQL。\",\"mysql> explain select * from pms_category \\\\G; *************************** 1. row *************************** id: 1 select_type: SIMPLE table: pms_category partitions: NULL type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 1425 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec) \",\"EXPLAIN能干嘛？\",\"可以查看以下信息：\",\"id：表的读取顺序。\",\"select_type：数据读取操作的操作类型。\",\"possible_keys：哪些索引可以使用。\",\"key：哪些索引被实际使用。\",\"ref：表之间的引用。\",\"rows：每张表有多少行被优化器查询。\"]},\"467\":{\"h\":\"explain 字段\",\"t\":[\"id\",\"id：表的读取和加载顺序。\",\"值有以下三种情况：\",\"id相同，执行顺序由上至下。\",\"id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。\",\"id相同不同，同时存在。永远是id大的优先级最高，id相等的时候顺序执行。\",\"select_type\",\"select_type：数据查询的类型，主要是用于区别，普通查询、联合查询、子查询等的复杂查询。\",\"SIMPLE：简单的SELECT查询，查询中不包含子查询或者UNION 。\",\"PRIMARY：查询中如果包含任何复杂的子部分，最外层查询则被标记为PRIMARY。\",\"SUBQUERY：在SELECT或者WHERE子句中包含了子查询。\",\"DERIVED：在FROM子句中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询，把结果放在临时表中。\",\"UNION：如果第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为DERIVED。\",\"UNION RESULT：从UNION表获取结果的SELECT。\",\"type\",\"type：访问类型排列。\",\"从最好到最差依次是：system>const>eq_ref>ref>range>index>ALL。除了ALL没有用到索引，其他级别都用到索引了。\",\"一般来说，得保证查询至少达到range级别，最好达到ref。\",\"system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计。\",\"const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转化为一个常量。\",\"eq_ref：唯一性索引扫描，读取本表中和关联表表中的每行组合成的一行，查出来只有一条记录。除 了 system 和 const 类型之外, 这是最好的联接类型。\",\"ref：非唯一性索引扫描，返回本表和关联表某个值匹配的所有行，查出来有多条记录。\",\"range：只检索给定范围的行，一般就是在WHERE语句中出现了BETWEEN、< >、in等的查询。这种范围扫描索引比全表扫描要好，因为它只需要开始于索引树的某一点，而结束于另一点，不用扫描全部索引。\",\"index：Full Index Scan，全索引扫描，index和ALL的区别为index类型只遍历索引树。也就是说虽然ALL和index都是读全表，但是index是从索引中读的，ALL是从磁盘中读取的。\",\"ALL：Full Table Scan，没有用到索引，全表扫描。\",\"possible_keys 和 key\",\"possible_keys：显示可能应用在这张表中的索引，一个或者多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。\",\"key：实际使用的索引。如果为NULL，则没有使用索引。查询中如果使用了覆盖索引，则该索引仅仅出现在key列表中。\",\"key_len\",\"key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。在不损失精度的情况下，长度越短越好。\",\"key_len计算规则：https://blog.csdn.net/qq_34930488/article/details/102931490\",\"mysql> desc pms_category; +---------------+------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +---------------+------------+------+-----+---------+----------------+ | cat_id | bigint(20) | NO | PRI | NULL | auto_increment | | name | char(50) | YES | | NULL | | | parent_cid | bigint(20) | YES | | NULL | | | cat_level | int(11) | YES | | NULL | | | show_status | tinyint(4) | YES | | NULL | | | sort | int(11) | YES | | NULL | | | icon | char(255) | YES | | NULL | | | product_unit | char(50) | YES | | NULL | | | product_count | int(11) | YES | | NULL | | +---------------+------------+------+-----+---------+----------------+ 9 rows in set (0.00 sec) mysql> explain select cat_id from pms_category where cat_id between 10 and 20 \\\\G; *************************** 1. row *************************** id: 1 select_type: SIMPLE table: pms_category partitions: NULL type: range possible_keys: PRIMARY key: PRIMARY # 用到了主键索引，通过查看表结构知道，cat_id是bigint类型，占用8个字节 key_len: 8 # 这里只用到了cat_id主键索引，所以长度就是8！ ref: NULL rows: 11 filtered: 100.00 Extra: Using where; Using index 1 row in set, 1 warning (0.00 sec) \",\"ref\",\"ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。\",\"rows\",\"rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录需要读取的行数。\",\"Extra\",\"Extra：包含不适合在其他列中显示但十分重要的额外信息。\",\"Using filesort：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作成为\\\"文件内排序\\\"。\",\"# 排序没有使用索引 mysql> explain select name from pms_category where name='Tangs' order by cat_level \\\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: pms_category partitions: NULL type: ref possible_keys: idx_name_parentCid_catLevel key: idx_name_parentCid_catLevel key_len: 201 ref: const rows: 1 filtered: 100.00 Extra: Using where; Using index; Using filesort 1 row in set, 1 warning (0.00 sec) #~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ # 排序使用到了索引 mysql> explain select name from pms_category where name='Tangs' order by parent_cid,cat_level\\\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: pms_category partitions: NULL type: ref possible_keys: idx_name_parentCid_catLevel key: idx_name_parentCid_catLevel key_len: 201 ref: const rows: 1 filtered: 100.00 Extra: Using where; Using index 1 row in set, 1 warning (0.00 sec) \",\"Using temporary：使用了临时表保存中间结果，MySQL在対查询结果排序时使用了临时表。常见于排序order by和分组查询group by。临时表対系统性能损耗很大。\",\"Using index：表示相应的SELECT操作中使用了覆盖索引，避免访问了表的数据行，效率不错！如果同时出现Using where，表示索引被用来执行索引键值的查找；如果没有同时出现Using where，表明索引用来读取数据而非执行查找动作。\",\"# 覆盖索引 # 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。 # 注意：如果要使用覆盖索引，一定不能写SELECT *，要写出具体的字段。 mysql> explain select cat_id from pms_category \\\\G; *************************** 1. row *************************** id: 1 select_type: SIMPLE table: pms_category partitions: NULL type: index possible_keys: NULL key: PRIMARY key_len: 8 ref: NULL rows: 1425 filtered: 100.00 Extra: Using index # select的数据列只用从索引中就能够取得，不必从数据表中读取 1 row in set, 1 warning (0.00 sec) \",\"Using where：表明使用了WHERE过滤。\",\"Using join buffer：使用了连接缓存。\",\"impossible where：WHERE子句的值总是false，不能用来获取任何元组。\",\"mysql> explain select name from pms_category where name = 'zs' and name = 'ls'\\\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: NULL partitions: NULL type: NULL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: NULL filtered: NULL Extra: Impossible WHERE # 不可能字段同时查到两个名字 1 row in set, 1 warning (0.00 sec) \"]},\"468\":{\"h\":\"索引常见模型\",\"t\":[\"除了数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。简单来说，索引是排好序的快速查找数据结构。\",\"索引的出现是为了提高查询效率，但是实现索引的方式却有很多中，可以用于提高读写效率的数据结构有很多中，这里我们这里讨论三种常见的数据结构：哈希表、有序数组、搜索树。\"]},\"469\":{\"h\":\"哈希表\",\"t\":[\"哈希表是一种以键-值（key-value）存储数据的结构，我们只需要输入待查找的值即key，就可以找到其对应的值即value。使用哈希算法不可避免的就会遇到哈希冲突，链地址法是解决哈希冲突比较常见的做法。\",\"假设现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：\",\"图中，User2和User4根据身份证号算出来的值都是N，但是没有关系，后面还有一个链表。假设这个时候要查ID_card_n2对应的名字是什么，首先将ID_card_n2通过哈希函数算出N，然后，按顺序遍历，找到User2。\",\"需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加，但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的，如果要查找身份证号在[ID_card_X,ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。因此，哈希表这种结构适用于只有等值查询的场景，比如Memcached及其他一些NoSQL引擎。\"]},\"470\":{\"h\":\"有序数组\",\"t\":[\"有序数组在等值查询和范围查询场景中的性能就都非常优秀。还是上面根据身份证号查询名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：\",\"这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果要查询ID_card_n2对应的名字，用二分法就可以快速得到，时间复杂度为O（logN）。同理，如果要查询区间的时间复杂度也是O（logN）。\",\"如果仅仅看查询效率，有序数组就是最好的数据结构了，但是，在需要更新数据的时候就麻烦了。往中间插入一条记录就必须得往后挪动所有的记录，成本非常高。因此，有序数组索引只适用于静态存储引擎，比如要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。\"]},\"471\":{\"h\":\"二叉搜索树\",\"t\":[\"如果我们用二叉搜索树来实现上述的例子：\",\"二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果要查询ID_card_n2的话，按照途中搜索的顺序就是按照UserA -> UserC -> UserF -> User2这个路径得到，这个时间复杂度是O（logN）。\",\"不过为了维持O（logN）的查询复杂度，更新的时间复杂度也是O（logN）。\",\"树可以有二叉，也可以有多叉，多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止在内存中，还要写到磁盘上。\",\"为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少地数据块。那么，我们就不应该使用二叉树，而是要使用“N叉树”，这里，“N叉”树中地“N”取决于数据块的大小。以InnoDB的一个整数字段为例。这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次从盘。其实，树的第二层也有很大的概率在内存中，那么访问磁盘的平均次数就更少了。\",\"由于N叉树在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。在MySQL中，索引是在存储引擎层的实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而底层的实现也可能不同。\"]},\"472\":{\"h\":\"B+树\",\"t\":[\"在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表，并且InnoDB使用了B+树索引模型，将数据存储在了B+树中，每一个索引在InnoDB中对应一颗B+树。\",\"假设我们有一个主键列为ID的表，表中有字段k，并且在k上有索引，这个表的建表语句是：\",\"CREATE TABLE T ( id int PRIMARY KEY, k int NOT NULL, name varchar(16), INDEX(k) ) ENGINE = InnoDB; \",\"然后向表中插入5条记录，表中R1~R5的（ID，K）的值分别为（100，1）、（200，2）、（300，3）、（500，5）、（600，6），两棵树的示例示意图如下：\",\"从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。主键索引的叶子节点存储的是整行数据，在InnoDB中，主键索引也被称为聚簇索引（clustered index）。非主键索引的叶子节点内容是主键的值，在InnoDB里，非主键索引也被称为二级索引（secondary index）。\",\"基于主键索引和普通索引的查询略有差别：\",\"如果语句是select * from T where ID = 500，即主键查询方式，则只需要搜索ID这颗B+树\",\"如果语句是select * from T where k = 5，即普通索引查询方式，则需要先搜索K索引树，得到ID的值为500，再到ID索引树搜索一次，这个过程称为回表\",\"也就是说，基于非主键索引的查询需要多扫描一棵索引树，因此，我们在应用中应该尽量使用主键查询。\",\"B+树为了维护索引的有序性，在插入新值的时候需要做必要的维护。以上面的图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID的值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然也受收到影响。\",\"除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。\",\"当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并，合并的过程，可以认为是分裂过程的逆过程。\",\"可能你在一些建表规范里面见到过类似的描述，要求建表语句里面一定要有自增主键。当然事无绝对，我们需要分析一下哪些场景应该使用自增主键，而哪些场景下不应该。\",\"自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的：NOT PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值作为下一条记录的ID值，也就是说，自增主键的插入数据的模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不设计到挪动其它记录，也不会触发叶子节点的分裂。而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。\",\"除了考虑性能外，我们还可以从存储空间的角度来看。假设表中确实有一个唯一的字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？\",\"由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以从性能和存储空间方面考量，自增主键往往是更合理的选择。\",\"不过在典型的KV场景，由于没有其它索引，所以就不用考虑其它索引叶子节点大小的问题了，KV场景的特点如下：\",\"只有一个索引\",\"该索引必须是唯一索引\",\"这时候我们就需要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。\"]},\"473\":{\"h\":\"索引的执行流程\",\"t\":[\"创建好索引之后，我们探讨一下索引的执行流程，以下面的表T为例，如果执行select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？\",\"CREATE TABLE T ( ID int PRIMARY KEY, k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT '', INDEX k(k) ) ENGINE = InnoDB; insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg'); \",\"此时表中的索引结构如下图所示：\"]},\"474\":{\"h\":\"回表\",\"t\":[\"此时，上述SQL语句查询的执行流程：\",\"在k索引树上找到k=3的记录，取得ID=300\",\"再到ID索引树查到ID=300对应的R3\",\"在k索引树取下一个值k=5，取得ID=500\",\"在k索引树取下一个值k=6，不满足条件，循环结束\",\"在这个过程中，回到主键索引树搜索的过程，就称为回表，可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）.\",\"在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，该如何避免回表呢？\"]},\"475\":{\"h\":\"覆盖索引\",\"t\":[\"如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询 需求，我们称为覆盖索引。\",\"由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。\",\"需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三条记录，R3~R5（对应的索引k上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2。\",\"基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？假设这个市民表的定义如下：\",\"CREATE TABLE `tuser` ( `id` int(11) NOT NULL, `id_card` varchar(32) DEFAULT NULL, `name` varchar(32) DEFAULT NULL, `age` int(11) DEFAULT NULL, `ismale` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`), KEY `id_card` (`id_card`), KEY `name_age` (`name`, `age`) ) ENGINE = InnoDB \",\"我们知道，身份证号是市民的唯一标识，也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？\",\"如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，那这个联合索引就有意义了。它可以高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。\",\"当然，索引字段的维护总是有代价的，因此，在建立冗余索引来支持索引覆盖时就需要权衡考虑了。\"]},\"476\":{\"h\":\"最左前缀原则\",\"t\":[\"如果要为每一种查询都设计一个索引，会导致索引数量激增，在B+树这种索引结构中，可以利用索引的“最左前缀”来定位记录，为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。\",\"可以看到，索引项是按照索引定义里面出现的字段顺序排序的。当需要查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。\",\"如果要查的是所有名字第一个字的是“张”的人，你的SQL语句的条件是“where name like 张%”。这时也可以用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。\",\"可以看到，不止是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。因此，在建立联合索引的时候，通常我们就会根据索引的复用能力来确定索引内的字段顺序，如果可以通过调整联合索引的顺序，就可以少维护一个索引，那么就要优先考虑建立这样顺序的索引。\",\"那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用（a，b）这个联合索引的，这个时候不得不维护另一个索引，也就是说必须同时维护（a，b）、（b）这两个索引。这种情况下，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name字段是比age字段大的，那么建议创建一个（name，age）的联合索引和一个（age）的单字段索引。\"]},\"477\":{\"h\":\"索引下推\",\"t\":[\"上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录，那么不符合最左前缀的部分，会怎么样呢？\",\"我们还是以市民表中的联合索引（name，age）为例。假设现在的需求是检索出表中“名字第一个字是张，而且年龄是10岁所有男孩”，那么，SQL语句是这么写的：\",\"select * from tuser where name like '张%' and age=10 and ismale=1; \",\"这个语句在搜索索引树的时候，只能用“张”，找到第一个满足条件的记录ID3，然后判断其它条件是否满足。在MySQL 5.6之前，只能从ID3开始一个个回表，到主键索引上找出数据行，再对比字段值，而在MySQL 5.6之后引入的索引下推优化（index condition pushdown），可以在索引遍历的过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，下面是这两个过程的执行流程图：\",\"在这两个图里面，每一个虚线箭头表示回表一次，在第一张图中，InnoDB并不会去看age的值，只是按顺序把“name”第一个字是“张”的记录一条条取出来回表，因此，需要回表4次。下一张图中，InnoDB在（name，age）索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在我们这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。\"]},\"478\":{\"h\":\"普通索引和唯一索引\",\"t\":[\"现在假设我们在维护一个市民系统，每个人都有一个唯一的身份证号，而且通过业务代码保证不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语句：\",\"select name from CUser where id_card = 'xxxxxxxyyyyyyzzzzz'; \",\"如果要在id_card字段上创建索引，由于身份证号字段比较大，作为主键并不合适，那么可以给id_card字段创建唯一索引，也可以创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的，但在性能上有所差别。\",\"接下来，我们就从这两种索引对查询语句和更新语句的性能来进行分析。\"]},\"479\":{\"h\":\"查询过程\",\"t\":[\"假设执行的查询语句是select id from T where k = 5，这个查询语句在索引树上的查找的过程，先是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。\",\"对于普通索引来说，查找到满足条件的第一个记录（5，500）后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录\",\"对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索\",\"InnoDB的数据是按数据页为到位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。由于引擎是按页读写的，所以说，当找到k=5的时候，它所在的数据页就都在内存里了，那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。\",\"当然，如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些，不过，对于整型字段，一个数据页就可以放近千个key，因此出现这种情况的概率会很低，所以在计算平均性能差异的时候，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。\",\"总而言之，对于查询的场景来说，唯一索引和普通索引并没有性能上的差距。\"]},\"480\":{\"h\":\"更新过程\",\"t\":[\"为了说明普通索引和唯一索引对更新语句性能的影响，需要首先了解change buffer。\",\"当需要更新一个数据页的时候，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。\",\"需要说明的是，虽然名字叫做change buffer，实际上它是可以持久化的数据，也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程也会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。\",\"显然，如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能避免占用内存，提高内存利用率。\",\"那么，什么情况下会使用到change buffer呢？\",\"对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入（4，400）这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。\",\"因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。\",\"change buffer用的是buffer pool里的内存，因此不能无线增大。change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。\",\"理解了change buffer的机制，我们再来看看如果要在这张表中插入一个新记录（4，400）的话，InnoDB的处理流程。\",\"第一种情况是，这个记录要更新的目标在内存中，这时，InnoDB的处理流程如下：\",\"对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束\",\"对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了\",\"将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。\"]},\"481\":{\"h\":\"change buffer详解\",\"t\":[\"上文我们说过，change buffer只限于用在普通索引的场景下，而是不适用于唯一索引，那么普通索引的所有场景，使用change buffer都可以起到加速的作用吗？\",\"由于merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer的记录变更越多（也就是这个页面上要更新的次数越多），收益就越大。因此对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。\",\"此时我们再来分析普通索引和唯一索引选择的问题。这两类索引在查询能力上没有差别，主要是对更新性能的影响，因此，尽量选择普通索引。如果所有的更新后面，都马上伴随着对这个记录的查询，那么应该关闭change buffer，而在其它情况下change buffer都能提升更新性能。\"]},\"482\":{\"h\":\"change buffer和redo log\",\"t\":[\"change buffer和redo log是两个比较容易混淆的概念，接下来我们通过实例来说明它们之间的区别，先插入两条数据：\",\"INSERT INTO t (id, k) VALUES (id1, k1), (id2, k2); \",\"这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存（InnoDB buffer pool）中，k2所在的数据页不在内存中。下图所示是带change buffer的更新状态图：\",\"这条更新语句，共涉及了四个部分：内存、redo log（ib_log_fileX）、数据表空间（t.ibd）、系统表空间（ibdata1）。\",\"这条更新语句做了如下操作：\",\"Page1在内存中，直接更新内存\",\"Page2没有在内存中，就在内存中change buffer区域，记录下“我要往Page插入一行”这个信息\",\"将上述两个动作记入redo log（图中3和4）\",\"做完上面这些，事务就可以完成了，不难看出，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的，同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。\",\"完成上述操作之后，假设要执行select * from t where k in(k1, k2)，执行的流程图如下：\",\"从图中可以看到：\",\"读Page1的时候，直接从内存返回\",\"要读Page2的时候，需要把Page2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果\",\"可以看到，直到需要读Page2的时候，这个数据页才会被读入内存，所以要简单地对比这两个机制在提升性能上地收益的话，redo log主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。\"]},\"483\":{\"h\":\"索引的选择\",\"t\":[\"MySQL中一张表可以支持多个索引，并且使用哪个索引是由MySQL来确定的，不过在某些场景下，MySQL可能会选错索引，从而导致执行速度变得很慢。\",\"首先先建一张表，表里有a、b两个字段，并分别建立索引：\",\"CREATE TABLE `t` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `b` (`b`) ) ENGINE = InnoDB ； \",\"然后执行如下SQL语句：\",\"select * from t where a between 10000 and 20000; \",\"通过explain命令可以这条语句执行的情况：\",\"我们在字段‘a’上建立了普通索引，从分析的结果来看，优化器也选择了索引a，但实际上并没有这么简单，假设这张表上包含了10万行的数据，然后做如下操作：\",\"session A开启一个事务，然后，seesion B把数据都删除后，又调用idata这个存储过程，插入了10万行数据。这时候，session B的查询语句select * from where a between 10000 and 20000就不会再选择索引a了。我们可以通过慢查询日志（show log）来查看以下具体的执行情况。为了说明优化器选择的结果是否正确，这里使用了force index(a)来让优化器强制使用索引a。\",\"set long_query_time=0; select * from t where a between 10000 and 20000; /*Q1*/ select * from t force index(a) where a between 10000 and 20000;/*Q2*/ \",\"第一句是将查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日志中\",\"第二句，Q1是session B原来的查询\",\"第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比\",\"这三条SQL语句执行完成后的慢查询日志如下：\",\"可以看到，Q1扫描了10万行，显然是走了全表扫描，执行时间是40毫秒。Q2扫描了10001行，执行了21毫秒。也就是说，我们在没有使用force index的时候，MySQL用错了索引，导致了更长的执行时间，要理解这个现象，就必须了解优化器选择索引的策略。\"]},\"484\":{\"h\":\"优化器逻辑\",\"t\":[\"优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越小，消耗的CPU资源越少。除此之外，优化器还会结合是否使用临时表、是否排序等因素进行综合判断，由于这个查询语句并没有涉及到临时表和排序，所以MySQL选错索引肯定是在判断扫描行数的时候出现了问题。\",\"MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数，这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好，而一个索引上不同的值的个数，我们称之为“基数（cardinality）”。也就是说，这个基数越大，索引的区分度就越好。\",\"我们可以使用show index方法，看到一个索引的基数，如下图所示：\",\"可以看到，虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不同，而且其实都不准确。\",\"MySQL会通过采样统计的方式来得到索引的基数，采用采样统计的原因主要是，如果把整张表取出来一行行统计，然后可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。\",\"采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。而数据表是会持续更新的，索引统计信息也不会固定不变，所以当变更的数据行超过1/M的时候，会自动触发重新做一次索引统计。\",\"在MySQL中，有两种存储索引统计的方式，可以通过设置参数innodb_stats_persistent的值来选择：\",\"设置为no的时候，表示统计信息会持久化存储，这时，默认的N是20，M是10\",\"设置为off的时候，表示统计信息只存储在内存中，这时，默认的N是8，M是16\",\"由于是采样统计，所以不管是N是20还是8，这个基数都是很容易不准的。\",\"MySQL的优化器除了会统计索引的基数，还会判断这个语句本身要扫描的行数，可以通过explain的rows列来查看：\",\"可以看到，Q2的rows的值是37116，与实际的10000相差较大，这里实际上存在两个问题，一是语句Q1优化器为什么没有选择索引‘a’，二是语句Q2为什么优化器没有选择37116行的执行计划，而是选择扫描行数是100000的执行计划，\",\"对于问题二，如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行的数据，而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价，优化器会估算这两个选择的代价，虽然从执行时间上来看，这个选择并不是最优的。\",\"使用普通索引需要把回表的代价算进去，所以，MySQL选错索引，最根本的原因是没有能准确地判断出扫描行数，我们可以使用analyze table t命令，可以用来重新统计索引信息，我们来看一下执行效果。\",\"如果explain的结果预估的rows的值跟实际情况差距比较大，都可以采用这个方法来处理。\",\"依然基于表t，执行另外一个语句：\",\"select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order b limit 1; \",\"从查询条件来看，这个查询没有符合条件的记录，因此将会返回空集合。为了方便理解这条语句的索引选择过程，首先来看一下a、b这两个索引的结构图：\",\"如果使用索引a进行查询，首先扫描索引a的前1000个值，然后取到对应的id，再到主键索引上去查出每一行，然后根据字段b来过滤，显然这样需要扫描1000行。如果使用索引b进行查询，首先扫描索引b的最后50001个值，然后取到对应的id，再回到主键索引上取值再判断，所以需要扫描50001行。显然，使用索引a，执行速度明显会快很多，我们来看看MySQL是如何选择的：\",\"可以看到，返回结果中key字段显式，这次优化器选择了索引b，而rows字段显式需要扫描的行数是50198。也就是说，扫描的行数的估计值依然不准确，并且MySQL又选错了索引。\"]},\"485\":{\"h\":\"索引选择异常和处理\",\"t\":[\"当碰到优化器选择索引错误的时候，我们应该如何处理呢？\",\"一种方法是，就像我们的第一个例子一样，采用force index强行选择一个索引。MySQL会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不会再评估其它索引的执行代价了，执行的效果如下：\",\"原本语句需要执行2.23秒，而使用force index（a）的时候，只用了0.05秒，比优化器的选择快了40多倍。但这种方法并不完美，一是这么写不足够优雅，二是如果索引改了名字，这个语句也需要同步修改，三是这个语法并不是所有的数据库都支持，迁移比较麻烦。\",\"既然优化器放弃了使用索引a，说明a还不够合适，所以第二种方法就是，修改语句，引导MySQL使用我们期望的索引。比如，在这个例子中，显然把“order by b limit 1”改成“order by b，a limit 1”，语义的逻辑是相同的，我们看一下修改之后的效果：\",\"之前优化器选择使用索引b，是因为它认为使用索引b可以避免排序（b本身是索引，已经是有序的了，如果选择索引b的话，不需要再做排序，只需要遍历），所以即使扫描的行数多，也判定为代价更小。将语句修改为order by b，a，要求按照b，a排序，就意味着使用这两个索引都需要排序。因此，扫描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描1000行的索引a。\",\"当然，这种修改并不是通用的优化手段，只是刚好在这个语句中有limit 1，因此如果有满足条件的记录，order by b limit 1和order by b，a limit 1都会返回b是最小的那一行，逻辑上一致，才可以这么做，除了这种做法，还可以将语句修改为：\",\"select * from (select * from t where (a between 1 and 1000) and (b between 50000 and 100) order by b limit 100) alias limit 1; \",\"执行的效果如下：\",\"在这个例子中，我们用limit 100让优化器意识到，使用b索引的代价是很高的，其实是我们根据数据特征诱导了一下优化器，也不具备通用性。\",\"第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。不过在这个例子中，这种方法并不适用。\"]},\"486\":{\"h\":\"字符串添加索引\",\"t\":[\"在业务开发中，我们经常会碰到要存储字符串的场景，例如邮箱、用户名等，那么如何给字符串添加合适的索引呢？\",\"假设，现在有一个支持邮箱登录的系统，用户表是这么定义的：\",\"CREATE TABLE SUser ( ID bigint UNSIGNED PRIMARY KEY, email varchar(64), ... ) ENGINE = innodb; \",\"如果要使用邮箱登录，那么业务代码中一定会出现类似这样的语句：\",\"select f1, f2 from SUser where email = 'xxx'; \"]},\"487\":{\"h\":\"前缀索引\",\"t\":[\"如果email这个字段上没有索引，那么这个语句就只能全表扫描。在MySQL中是支持前缀索引的，也就是说，可以定义字符串的一部分作为索引，如果创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。\",\"比如，这两个在email字段上创建索引的语句：\",\"alter table SUser add index index1(email); 或 alter table SUser add index index2(email(6)); \",\"第一个语句创建的index1索引里面，包含了每个记录的整个字符串，而第二个语句创建的index2索引里面，对于每个记录都是只取前6个字节，它们的示意图如下所示：\",\"从图中可以看到，由于email(6)这个索引结构中每个邮箱的字段都只取6个字节（即：zhangs），索引占用的空间会更小，这就是使用前缀索引的优势，但同时，前缀索引也可能会增加额外的记录扫描次数，通过它们的执行过程能更加清楚看到这一点。\",\"如果使用的是index1（即email整个字符串的索引结构），执行顺序如下：\",\"从index1索引树找到满足索引值是'zhangssxyz@xxx.com'的这条记录，取得ID2的值\",\"到主键上查找到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集\",\"取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email='zhangssxyz@xxx.com'的条件了，循环结束\",\"在整个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。\",\"如果使用的是index2（即email（6）索引结构），执行顺序如下：\",\"从index2索引树找到满足索引值是'zhangs'的记录，找到的第一个是ID1\",\"到主键查找到主键是ID1的行，判断出email的值不是'zhangssxyz@xxx.com'，这行记录丢弃\",\"取index2上刚刚查到的位置的下一条记录，发现仍然是'zhangs'，取出ID2，再到ID索引上取整行然后判断，这次值取对了，将这行记录加入结果集\",\"重复上一步，直到在index2上取到的值不是'zhangs'时，循环结束\",\"在这个过程中，要回主键索引取4次数据，也就是扫描了4行。\",\"通过以上两种情况的对比，可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多，但是对于这个查询语句来说，如果定义的index2不是email(6)而是email(7)，也就是说取email字段的前7个字节来构建索引的话，即满足前缀'zhangss'的记录只有一个，也能够直接查到ID2，只扫描这一行就结束了。\",\"这说明在使用前缀索引的时候，定义合理的长度，就可以做到既节省空间，又不用额外增加太多的查询成本。\",\"我们可以通过统计索引上有多少个不同的值来判断需要使用多长的前缀，首先计算这个列上有多少个不同的值：\",\"select count(distinct email) as L from SUser; \",\"然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引：\",\"select count(distinct left(email,4) ） as L4, count(distinct left(email,5) ） as L5, count(distinct left(email,6) ） as L6, count(distinct left(email,7) ） as L7, from SUser; \",\"前缀索引很可能会损失区分度，所以需要预先设定一个可以接受的损失比例，比如5%，然后在返回的L4~L7中，找出不小于L*95%的值，假设这里L6、L7都满足，就可以选择前缀长度为6。\"]},\"488\":{\"h\":\"前缀索引与覆盖索引\",\"t\":[\"前缀索引除了可能会增加扫描行数，影响到性能外，还可能会导致覆盖索引失效。\",\"假设我们要查询的语句如下：\",\"select id,email from SUser where email='zhangssxyz@xxx.com'; \",\"与前面的例子中的SQL语句：\",\"select id,name,email from SUser where email='zhangssxyz@xxx.com'; \",\"相比，这个语句只要求返回id和email字段，所以，如果使用index1（即整个email字符串的索引结构）的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再查一次。而如果使用index2（即email（6）所索引结构）的话，就不得不回到ID索引再去判断email字段的值。\",\"即使将index2的定义修改为email（18）的前缀索引，这时候，虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。也就是说前缀索引就用不上覆盖索引对查询性能的优化了，这也是在选择是否使用前缀索引时需要考虑的一个因素。\"]},\"489\":{\"h\":\"其它方式\",\"t\":[\"实际场景中，我们很有可能碰到前缀的区分度不够好的情况，例如身份证号，总共18位，其中前6位是地址码，所以同一个县的人的身份证号前6位一般会是相同的。假设维护的数据库是同一个市的公民信息系统，这时候如果对身份证号长度为6的前缀索引的话，这个索引的区分度就非常低了，需要创建长度为12位以上的前缀索引，才能够满足区分度的要求，但是索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。解决这个问题通常来说有两种方式：倒序存储和使用哈希字段。\",\"倒序存储是指如果存储身份证号码的时候把它倒过来存，每次查询的时候，可以：\",\"select field_list from t where id_card = reverse('input_id_card_string'); \",\"由于身份证号码的最后6位没有地址码这样的重复逻辑，所以最后这6位就提供了足够的区分度，实践中可以使用count(distinct)方法做个验证。\",\"使用哈希字段指的是可以在表上创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引：\",\"alter table t add id_card_crc int unsigned, add index(id_card_crc); \",\"然后每次插入新记录的时候，都同时用cr32（）这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证通过crc32（）函数得到的结果可能是相同的，所以查询语句where部分要判断id_card的值是否精确相同。这样一来，索引的长度变成了4个字节，比原来小了很多。\",\"使用倒序存储和使用哈希字段两种方式的异同点如下：\",\"首先，它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X,ID_Y]的所有市民了。同样地，哈希字段的方式也只能支持等值查询。\",\"它们的区别，主要在以下三个方面：\",\"从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而哈希字段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个哈希字段也差不多抵消了\",\"在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而哈希字段的方式需要额外调用一次crc32()函数，如果只是从这两个函数的计算复杂度来看的话，reverse函数额外消耗的CPU的资源会更小一些\",\"从查询效率上看，使用哈希字段方式的查询性能相对更稳定一些，因为crc32（）算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数\"]},\"490\":{\"h\":\"order by与索引\",\"t\":[\"在开发应用的时候，一定碰到过需要根据指定的字段排序来显示结果的需求，还是以我们前面举例用过的市民表为例，假设要查询城市是“杭州”的所有人的名字，并且按照姓名排序返回前1000个人的姓名、年龄。\",\"建表语句如下：\",\"CREATE TABLE `t` ( `id` int(11) NOT NULL, `city` varchar(16) NOT NULL, `name` varchar(16) NOT NULL, `age` int(11) NOT NULL, `addr` varchar(128) DEFAULT NULL, PRIMARY KEY (`id`), KEY `city` (`city`) ) ENGINE = InnoDB; \",\"那么查询语句：\",\"select city,name,age from t where city=' 杭州 ' order by name limit 1000; \"]},\"491\":{\"h\":\"全字段排序\",\"t\":[\"为了避免全表扫描，我们需要在city字段加上索引，city这个索引的示意图如下：\",\"在city字段上创建索引之后，使用explain查看执行情况：\",\"Extra这个字段中的“Using filesort”表示就是需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。\",\"从索引的示意图中可以看出， city='杭州'条件的行，是从 ID_X 到 ID_(X+N) 的这些记录。下面我们来分析整个语句的执行过程：\",\"初始化sort_buffer，确定放入name、city、age这三个字段\",\"从索引city找到第一个满足city='杭州'条件的主键id，也就是图中的ID_X\",\"到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中\",\"从索引city取下一个记录的主键id\",\"重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y\",\"对sort_buffer中的数据按照字段name做快速排序\",\"按照排序结果取前1000行返回给客户端\",\"这个过程就称为全字段排序，执行流程的示意图如下所示：\",\"图中“按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需要的内存和参数sort_buffer_size。sort_buffer_size就是MySQL为排序开辟的内存（sort_buffer）的大小，如果要排序的数据量小于sort_buffer_size，排序就在内存中完成，但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。可以通过如下命令来查看\",\"/* 打开 optimizer_trace ，只对本线程有效 */ SET optimizer_trace='enabled=on'; /* @a 保存 Innodb_rows_read 的初始值 */ select VARIABLE_VALUE into @a from performance_schema.session_status where variable_name = 'Innodb_rows_read'; /* 执行语句 */ select city, name,age from t where city=' 杭州 ' order by name limit 1000; /* 查看 OPTIMIZER_TRACE 输出 */ SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\\\\G /* @b 保存 Innodb_rows_read 的当前值 */ select VARIABLE_VALUE into @b from performance_schema.session_status where variable_name = 'Innodb_rows_read'; /* 计算 Innodb_rows_read 差值 */ select @b-@a; \",\"这个方法是通过查看OPTIMIZER_TRACE的结果来确认的，也可以从number_of_tmp_files中看到是否使用了临时文件。\",\"图中number_of_tmp_files表示的是，排序过程中使用的临时的文件数，之所以是12个文件，是当内存放不下时，就需要外部排序，外部排序一般使用归并排序算法，MySQL将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中，然后把这12个有序文件再合并成一个有序的大文件。如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序可以直接在内存中完成，否则就需要放在临时文件中排序。sort_buffer_size越小，需要的分成的份数就越多，number_of_tmp_files的值就越大。\",\"另外，在示例表中有4000条满足city='杭州'的记录，所以图中的examined_rows=4000，表示参与排序的行数是4000行。\",\"sort_mode里面的packed_additional_fields的意思是，排序过程中对字符串做了“紧凑处理”，即使name字段的定义是varchar(16)，在排序的过程中还是按照实际长度来分配空间的。\",\"最后的查询select @b - @a在MyISAM引擎中返回的结果是4000，而在InnoDB引擎中会返回4001，这是因为如果使用的是InnoDB引擎的话，在查询表optimizer_trace的时候，需要用到临时表，InnoDB会把数据从临时表取出来，然后让innodb_rows_read的值加1。\"]},\"492\":{\"h\":\"rowid排序\",\"t\":[\"上面的排序算法，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时表中执行的，但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数就很少，要分成很多个临时文件，排序的性能会很差，所以如果单行很大，这个方法效率不够好。\",\"我们可以通过修改参数，让MySQL换成另外一种算法：\",\"SET max_length_for_sort_data = 16; \",\"它的意思是，如果单行的长度超过了这个值，MySQL就认为单行太大，要换一个算法。city、name、age这三个字段的定义总长度是36，超过了16，这个时候，MySQL就会使用rowid排序。\",\"新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id，但这个时候，排序的结果因为少了city和age字段的值，不能直接返回了，整个执行流程如下：\",\"初始化sort_buffer，确定放入两个字段，即name和id\",\"从索引city找到第一个满足city=“杭州”条件的主键id，也就是图中的ID_X\",\"到主键id索引取出整行，取name、id这两个字段，存入sort_buffer\",\"从索引city取下一个记录的主键id\",\"重复步骤3、4直到不满足city=“杭州”条件为止，也就是图中的ID_Y\",\"对sort_buffer中的数据按照字段name进行排序\",\"遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name、age三个字段返回给客户端\",\"执行的示意图如下：\",\"对于全字段的排序流程图会发现，rowid排序多访问了一次表t的主键索引，也就是步骤7。需要说明的是，最后的“结果集”是一个逻辑概念，实际上MySQL服务端从排序后的sort_buffer中依次取出id，然后原表查到city、name和age这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的，此时的OPTIMIZER_TRACE的结果如下：\",\"可以发现：\",\"sort_mode变成了<sort_key,rowid>,表示参与排序的只有name和id这两个字段\",\"number_of_tmp_files变成10了，是因为这时候参与排序的行数虽然仍然是4000行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了\"]},\"493\":{\"h\":\"全字段排序和rowid排序对比\",\"t\":[\"当MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再会到原表去取数据；当内存太小，会影响排序效率，MySQL才会采用rowid排序算法，这样在排序过程中一次可以排序更多行，但是需要再回到原表去取数据。这体现了MySQL的一个设计理念：如果内存足够，就要多利用内存，尽量减少磁盘访问，对于InnoDB表来说，rowid排序会要求回表，因此不会优先选择。\",\"不难发现，在MySQL中，对于无序的字段，排序是一个成本比较高的操作，因此，优化order by语句的一种方式就是让原来无序的数据变的“有序”。还是以市民表为例，我们在这个市民表上创建一个city和name的联合索引，对应的SQL语句是：\",\"alter table t add index city_user(city, name); \",\"索引的示意图：\",\"在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city=\\\"杭州\\\"的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是有序的。这样整个查询过程的流程就变成了：\",\"从索引（city，name）找到第一个满足city=\\\"杭州\\\"条件的主键id\",\"到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回\",\"从索引（city，name）取下一个记录主键id\",\"重复步骤2、3，直到查到1000条记录，或者是不满足city=\\\"杭州\\\"条件时循环结束\",\"可以看到，这个查询过程不需要临时表，也不需要排序，explain的结果如下：\",\"可以看到，Extra字段中没有Using filesort了，也就是不需要排序了，而且由于（city，name）这个联合索引本身有序，所以这个查询也不用把4000行全都读一遍，只要找到满足条件的前1000条记录就可以退出了，也就是说，在这个例子中，只需要扫描1000次。\",\"还可以更进一步，使用覆盖索引：\",\"alter table t add index city_user_age(city, name, age); \",\"这时，对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询也就不再需要排序了，这样整个查询语句的执行流程就变成了：\",\"从索引（city，name，age）找到第一个满足city=\\\"杭州\\\"条件的记录，取出其中的city、name和age这三个字段的值，作为结果集的一部分直接返回\",\"从索引（city，name，age）取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回\",\"重复执行步骤2，直到查到第1000条记录，或者是不满足city=\\\"杭州\\\"条件时循环结束\",\"explain的结果如下：\",\"可以看到Extra字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多，不过索引还是有维护代价的，这是一个需要权衡的决定。\"]},\"494\":{\"h\":\"索引的创建时机\",\"t\":[\"前面我们了解了一些关于索引的理论知识，接下来我们着重了解一些索引的实践部分。\"]},\"495\":{\"h\":\"哪些情况需要建索引\",\"t\":[\"主键自动建立主键索引（唯一 + 非空）。\",\"频繁作为查询条件的字段应该创建索引。\",\"查询中与其他表关联的字段，外键关系建立索引。\",\"查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。\",\"查询中统计或者分组字段（group by也和索引有关）。\"]},\"496\":{\"h\":\"那些情况不要建索引\",\"t\":[\"记录太少的表。\",\"经常增删改的表。\",\"频繁更新的字段不适合创建索引。\",\"Where条件里用不到的字段不创建索引。\",\"假如一个表有10万行记录，有一个字段A只有true和false两种值，并且每个值的分布概率大约为50%，那么对A字段建索引一般不会提高数据库的查询速度。索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。\"]},\"497\":{\"h\":\"索引的最佳实践\"},\"498\":{\"h\":\"单表索引分析\",\"t\":[\"数据准备\",\"DROP TABLE IF EXISTS `article`; CREATE TABLE IF NOT EXISTS `article`( `id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '主键', `author_id` INT(10) UNSIGNED NOT NULL COMMENT '作者id', `category_id` INT(10) UNSIGNED NOT NULL COMMENT '分类id', `views` INT(10) UNSIGNED NOT NULL COMMENT '被查看的次数', `comments` INT(10) UNSIGNED NOT NULL COMMENT '回帖的备注', `title` VARCHAR(255) NOT NULL COMMENT '标题', `content` VARCHAR(255) NOT NULL COMMENT '正文内容' ) COMMENT '文章'; INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(1,1,1,1,'1','1'); INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(2,2,2,2,'2','2'); INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(3,3,3,3,'3','3'); INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(1,1,3,3,'3','3'); INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(1,1,4,4,'4','4'); \",\"案例：查询category_id为1且comments大于1的情况下，views最多的article_id。\",\"1、编写SQL语句并查看SQL执行计划。\",\"# 1、sql语句 SELECT id,author_id FROM article WHERE category_id = 1 AND comments > 1 ORDER BY views DESC LIMIT 1; # 2、sql执行计划 mysql> EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments > 1 ORDER BY views DESC LIMIT 1\\\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: article partitions: NULL type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 5 filtered: 20.00 Extra: Using where; Using filesort # 产生了文件内排序，需要优化SQL 1 row in set, 1 warning (0.00 sec) \",\"2、创建索引idx_article_ccv。\",\"CREATE INDEX idx_article_ccv ON article(category_id,comments,views); \",\"3、查看当前索引。\",\"4、查看现在SQL语句的执行计划。\",\"我们发现，创建符合索引idx_article_ccv之后，虽然解决了全表扫描的问题，但是在order by排序的时候没有用到索引，MySQL居然还是用的Using filesort，为什么？\",\"5、我们试试把SQL修改为SELECT id,author_id FROM article WHERE category_id = 1 AND comments = 1 ORDER BY views DESC LIMIT 1;看看SQL的执行计划。\",\"推论：当comments > 1的时候order by排序views字段索引就用不上，但是当comments = 1的时候order by排序views字段索引就可以用上！！！所以，范围之后的索引会失效。\",\"6、我们现在知道范围之后的索引会失效，原来的索引idx_article_ccv最后一个字段views会失效，那么我们如果删除这个索引，创建idx_article_cv索引呢？？？？\",\"/* 创建索引 idx_article_cv */ CREATE INDEX idx_article_cv ON article(category_id,views); \",\"查看当前的索引\",\"7、当前索引是idx_article_cv，来看一下SQL执行计划。\"]},\"499\":{\"h\":\"两表索引分析\",\"t\":[\"数据准备\",\"DROP TABLE IF EXISTS `class`; DROP TABLE IF EXISTS `book`; CREATE TABLE IF NOT EXISTS `class`( `id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '主键', `card` INT(10) UNSIGNED NOT NULL COMMENT '分类' ) COMMENT '商品类别'; CREATE TABLE IF NOT EXISTS `book`( `bookid` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '主键', `card` INT(10) UNSIGNED NOT NULL COMMENT '分类' ) COMMENT '书籍'; \",\"两表连接查询的SQL执行计划\",\"1、不创建索引的情况下，SQL的执行计划。\",\"book和class两张表都是没有使用索引，全表扫描，那么如果进行优化，索引是创建在book表还是创建在class表呢？下面进行大胆的尝试！\",\"2、左表(book表)创建索引。\",\"创建索引idx_book_card\",\"/* 在book表创建索引 */ CREATE INDEX idx_book_card ON book(card); \",\"在book表中有idx_book_card索引的情况下，查看SQL执行计划\",\"3、删除book表的索引，右表(class表)创建索引。\",\"创建索引idx_class_card\",\"/* 在class表创建索引 */ CREATE INDEX idx_class_card ON class(card); \",\"在class表中有idx_class_card索引的情况下，查看SQL执行计划\",\"由此可见，左连接将索引创建在右表上更合适，右连接将索引创建在左表上更合适。\"]},\"500\":{\"h\":\"三张表索引分析\",\"t\":[\"数据准备\",\"DROP TABLE IF EXISTS `phone`; CREATE TABLE IF NOT EXISTS `phone`( `phone_id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '主键', `card` INT(10) UNSIGNED NOT NULL COMMENT '分类' ) COMMENT '手机'; \",\"三表连接查询SQL优化\",\"1、不加任何索引，查看SQL执行计划。\",\"2、根据两表查询优化的经验，左连接需要在右表上添加索引，所以尝试在book表和phone表上添加索引。\",\"/* 在book表创建索引 */ CREATE INDEX idx_book_card ON book(card); /* 在phone表上创建索引 */ CREATE INDEX idx_phone_card ON phone(card); \",\"再次执行SQL的执行计划\"]},\"501\":{\"h\":\"结论\",\"t\":[\"JOIN语句的优化：\",\"尽可能减少JOIN语句中的NestedLoop（嵌套循环）的总次数：永远都是小的结果集驱动大的结果集。\",\"优先优化NestedLoop的内层循环。\",\"保证JOIN语句中被驱动表上JOIN条件字段已经被索引。\",\"当无法保证被驱动表的JOIN条件字段被索引且内存资源充足的前提下，不要太吝惜Join Buffer 的设置。\"]},\"502\":{\"h\":\"索引失效\",\"t\":[\"索引看起来非常美好，能够十分有效的加快我们的查询效率，然而，在MySQL中有很多看上去逻辑相同，但是性能却差异巨大的SQL语句，对这些语句使用不当的话，就会不经意间导致整个数据库的压力变大，\"]},\"503\":{\"h\":\"函数操作\",\"t\":[\"假设现在维护的是一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员id（operator）、交易时间（t_modified）等字段，建表语句如下：\",\"CREATE TABLE `tradelog` ( `id` int(11) NOT NULL, `tradeid` varchar(32) DEFAULT NULL, `operator` int(11) DEFAULT NULL, `t_modified` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `tradeid` (`tradeid`), KEY `t_modified` (`t_modified`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; \",\"假设现在已经记录了从2016年初到2018年底的所有数据，要查询所有年份中7月份的交易记录总数，SQL语句可能如下：\",\"select count(*) from tradelog where month(t_modified)=7; \",\"执行之后就会发现这个SQL语句会比预期的慢很多，虽然在t_modified字段上已经创建了索引，但是MySQL并没有使用这个索引。下面是t_modified索引的示意图，方框上面的数字表示month()函数对应的值：\",\"如果SQL语句中条件是where t_modified='2018-7-1'的话，引擎就会按照上面绿色箭头的路线，快速定位到t_modified='2018-7-1'需要的结果，而如果计算month()函数的话，在传入7的时候已经无法定位记录了。实际上，B+树提供的这个快速定位能力，来源于同一层兄弟节点的有序性，也就是说，对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器决定放弃走树搜索功能。\",\"需要注意的是，优化器并不是要放弃使用这个索引，在这个例子中，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引t_modified，优化器对比索引大小后发现，索引t_modified更小，遍历这个索引比主键索引来得更快，因此最终还是会选择索引t_modified。\",\"这条语句的explain的结果如下：\",\"key=\\\"t_modified\\\"表示的是，使用了t_modified这个索引，这里的测试数据有10万行，rows=100335，说明这条语句扫描了整个索引的所有值，Extra字段的Using index，表示的是使用了覆盖索引，也就是说，由于在t_modified字段加上了month()函数操作，导致了全索引扫描。为了能够用上索引的快速定位能力，我们就要把SQL语句改成基于字段本身的范围查询：\",\"select count(*) from tradelog where (t_modified >= '2016-7-1' and t_modified<'2016-8-1') or (t_modified >= '2017-7-1' and t_modified<'2017-8-1') or (t_modified >= '2018-7-1' and t_modified<'2018-8-1'); \",\"如果还有其它年份的数据，都需要手动将年份补齐。实际上，只要where条件后面有函数操作都会导致无法使用索引快速定位的功能，即使不改变有序性，例如select * from tradelog where id + 1 = 10000,也需要将where条件修改为where id = 10000 - 1才可以有效的用上索引。\"]},\"504\":{\"h\":\"隐式类型转换\",\"t\":[\"假设我们执行这样一条SQL语句：\",\"select * from tradelog where tradeid = 110717; \",\"交易编号tradeid这个字段上，本来是有索引的，但是explain结果却显式，这条语句需要走全表扫描，这是由于tradeid字段类型是varchar（32），而输入的参数却是整型，所以需要做类型转换，从而导致了索引失效。实际上在MySQL中，字符串和数字做比较的话，会将字符串转换成数字，也就是说对与优化器来说，上面的SQL语句等价于：\",\"select * from tradelog where CAST(tradid AS signed int) = 110717; \",\"也就是说，这条语句触发了我们之前说到的过规则：对索引字段做函数操作，优化器会放弃走树搜索功能。\"]},\"505\":{\"h\":\"隐式字符编码转换\",\"t\":[\"假设系统里面还有另外一张表trade_detail，用来记录交易的操作细节。为了便于量化分析和复现，我们往交易日志表tradelog和交易详情表trade_detail这两个表里插入一些数据：\",\"CREATE TABLE `trade_detail` ( `id` int(11) NOT NULL, `tradeid` varchar(32) DEFAULT NULL, `trade_step` int(11) DEFAULT NULL, `step_info` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`), KEY `tradeid` (`tradeid`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8; insert into tradelog insert into tradelog values(1, 'aaaaaaaa', 1000, now()); insert into tradelog values(2, 'aaaaaaab', 1000, now()); insert into tradelog values(3, 'aaaaaaac', 1000, now()); insert into trade_detail values(1, 'aaaaaaaa', 1, 'add'); insert into trade_detail values(2, 'aaaaaaaa', 2, 'update'); insert into trade_detail values(3, 'aaaaaaaa', 3, 'commit'); insert into trade_detail values(4, 'aaaaaaab', 1, 'add'); insert into trade_detail values(5, 'aaaaaaab', 2, 'update'); insert into trade_detail values(6, 'aaaaaaab', 3, 'update again'); insert into trade_detail values(7, 'aaaaaaab', 4, 'commit'); insert into trade_detail values(8, 'aaaaaaac', 1, 'add'); insert into trade_detail values(9, 'aaaaaaac', 2, 'update'); insert into trade_detail values(10, 'aaaaaaac', 3, 'update again'); insert into trade_detail values(11, 'aaaaaaac', 4, 'commit'); \",\"这时候，如果要查询id=2的交易的所有操作步骤信息，可以使用如下SQL语句：\",\"select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2; \",\"可以看到：\",\"第一行显式优化器现在交易记录表tradelog上查到id=2的行，这个步骤用上了主键索引，rows=1表示只扫描一行\",\"第二行key=NULL，表示没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫描\",\"explain的详细过程如下：\",\"图中：\",\"第一步，是根据id在tradelog表里找到L2这一行\",\"第二步，是从L2中取出tradeid字段的值\",\"第三步，是根据tradeid的值到trade_detail表中查找条件匹配的行。explain的结果第二行的key=NULL表示的就是，这个过程是通过遍历主键索引的方式，一个一个地判断tradeid的值是否匹配\",\"可以发现，在执行第三步的时候，并没有使用trade_detail里的tradeied上的索引快速定位到等值的行。实际上，这是因为这两张表的字符集不同导致的，上面的SQL等价于：\",\"select * from trade_detail where CONVERT(traideid USING utf8mb4) = $L2.tradeid.value; \",\"CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集，这再次触发了本节开始时提到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。\",\"utf8mb4是utf8的超集，类似地，在程序设计语言里面，做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加地方向”进行转换的。\",\"接下来我们看另外一种场景：\",\"select l.operator from tradelog l , trade_detail d where d.tradeid=l.tradeid and d.id = 4; \",\"explain的结果：\",\"这个语句里trade_detail表成了驱动表，但是explain结果的第二行显示，这次的查询操作用上了被驱动表tradelog里的索引（tradeied），扫描行数是1，这也是两个tradeied字段的join操作，为什么这次能用上被驱动表的tradeied索引呢？假设驱动表trade_detail里id=4的行记为R4，那么在连接的时候。被驱动表tradelog上执行的就是类似这样的SQL语句：\",\"select operator from tradelog where traideid = $R4.tradeid.value; \",\"这个时候的$R4.tradeied.value的字符集是utf8，按照字符集转换规则，要转成utf8mb4，所以这个过程就被改写成：\",\"select operator from tradelog where traideid =CONVERT($R4.tradeid.value USING utf8mb4); \",\"由于这里CONVERT函数是加在输入参数上的，这样就可以用上被驱动表的tradeid索引了。\",\"因此，对于SQL：\",\"select d.* from tradelog l, trade_detail d where d.tradeid = l.tradeid and l.id = 2; \",\"优化的方式通常有两种：\",\"比较常见的优化方法是，把trade_detail表上的tradeid字段的字符集也改成utf8mb4，这样就没有字符集转换问题了\",\"alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null; \",\"如果数据量比较大，或者其它原因不能执行这个DDL，那么可以修改SQL语句：\",\"select d.* from tradelog l, trade_detail d where d.tradeid = CONVERT(l.tradeid USING utf8); \",\"这样主动把l.tradeid转成utf8，就避免了被驱动表上的字符编码转换。\"]},\"506\":{\"h\":\"索引失效的场景\",\"t\":[\"全值匹配我最爱。\",\"最佳左前缀法则。\",\"不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描。\",\"索引中范围条件右边的字段会全部失效。\",\"尽量使用覆盖索引（只访问索引的查询，索引列和查询列一致），减少SELECT *。\",\"MySQL在使用!=或者<>的时候无法使用索引会导致全表扫描。\",\"is null、is not null也无法使用索引。\",\"like以通配符开头%abc索引失效会变成全表扫描（使用覆盖索引就不会全表扫描了）。\",\"字符串不加单引号索引失效。\",\"少用or，用它来连接时会索引失效。\"]},\"507\":{\"h\":\"最佳左前缀法则\",\"t\":[\"案例\",\"/* 用到了idx_staffs_name_age_pos索引中的name字段 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` = 'Ringo'; /* 用到了idx_staffs_name_age_pos索引中的name, age字段 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` = 'Ringo' AND `age` = 18; /* 用到了idx_staffs_name_age_pos索引中的name，age，pos字段 这是属于全值匹配的情况！！！*/ EXPLAIN SELECT * FROM `staffs` WHERE `name` = 'Ringo' AND `age` = 18 AND `pos` = 'manager'; /* 索引没用上，ALL全表扫描 */ EXPLAIN SELECT * FROM `staffs` WHERE `age` = 18 AND `pos` = 'manager'; /* 索引没用上，ALL全表扫描 */ EXPLAIN SELECT * FROM `staffs` WHERE `pos` = 'manager'; /* 用到了idx_staffs_name_age_pos索引中的name字段，pos字段索引失效 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` = 'Ringo' AND `pos` = 'manager'; \",\"概念\",\"最佳左前缀法则：如果索引是多字段的复合索引，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的字段。\",\"口诀：带头大哥不能死，中间兄弟不能断。\"]},\"508\":{\"h\":\"索引列上不计算\",\"t\":[\"案例\",\"# 现在要查询`name` = 'Ringo'的记录下面有两种方式来查询！ # 1、直接使用 字段 = 值的方式来计算 mysql> SELECT * FROM `staffs` WHERE `name` = 'Ringo'; +----+-------+-----+---------+---------------------+ | id | name | age | pos | add_time | +----+-------+-----+---------+---------------------+ | 1 | Ringo | 18 | manager | 2020-08-03 08:30:39 | +----+-------+-----+---------+---------------------+ 1 row in set (0.00 sec) # 2、使用MySQL内置的函数 mysql> SELECT * FROM `staffs` WHERE LEFT(`name`, 5) = 'Ringo'; +----+-------+-----+---------+---------------------+ | id | name | age | pos | add_time | +----+-------+-----+---------+---------------------+ | 1 | Ringo | 18 | manager | 2020-08-03 08:30:39 | +----+-------+-----+---------+---------------------+ 1 row in set (0.00 sec) \",\"我们发现以上两条SQL的执行结果都是一样的，但是执行效率有没有差距呢？？？\",\"通过分析两条SQL的执行计划来分析性能。\",\"由此可见，在索引列上进行计算，会使索引失效。\",\"口诀：索引列上不计算。\"]},\"509\":{\"h\":\"范围之后全失效\",\"t\":[\"案例\",\"/* 用到了idx_staffs_name_age_pos索引中的name，age，pos字段 这是属于全值匹配的情况！！！*/ EXPLAIN SELECT * FROM `staffs` WHERE `name` = 'Ringo' AND `age` = 18 AND `pos` = 'manager'; /* 用到了idx_staffs_name_age_pos索引中的name，age字段，pos字段索引失效 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` = '张三' AND `age` > 18 AND `pos` = 'dev'; \",\"查看上述SQL的执行计划\",\"由此可知，查询范围的字段使用到了索引，但是范围之后的索引字段会失效。\",\"口诀：范围之后全失效。\"]},\"510\":{\"h\":\"覆盖索引尽量用\",\"t\":[\"在写SQL的不要使用SELECT *，用什么字段就查询什么字段。\",\"/* 没有用到覆盖索引 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` = 'Ringo' AND `age` = 18 AND `pos` = 'manager'; /* 用到了覆盖索引 */ EXPLAIN SELECT `name`, `age`, `pos` FROM `staffs` WHERE `name` = 'Ringo' AND `age` = 18 AND `pos` = 'manager'; \",\"口诀：查询一定不用*。\"]},\"511\":{\"h\":\"不等有时会失效\",\"t\":[\"/* 会使用到覆盖索引 */ EXPLAIN SELECT `name`, `age`, `pos` FROM `staffs` WHERE `name` != 'Ringo'; /* 索引失效 全表扫描 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` != 'Ringo'; \"]},\"512\":{\"h\":\"like百分加右边\",\"t\":[\"/* 索引失效 全表扫描 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` LIKE '%ing%'; /* 索引失效 全表扫描 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` LIKE '%ing'; /* 使用索引范围查询 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` LIKE 'Rin%'; \",\"口诀：like百分加右边。\",\"如果一定要使用%like，而且还要保证索引不失效，那么使用覆盖索引来编写SQL。\",\"/* 使用到了覆盖索引 */ EXPLAIN SELECT `id` FROM `staffs` WHERE `name` LIKE '%in%'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `name` FROM `staffs` WHERE `name` LIKE '%in%'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `age` FROM `staffs` WHERE `name` LIKE '%in%'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `pos` FROM `staffs` WHERE `name` LIKE '%in%'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `id`, `name` FROM `staffs` WHERE `name` LIKE '%in%'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `id`, `age` FROM `staffs` WHERE `name` LIKE '%in%'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `id`,`name`, `age`, `pos` FROM `staffs` WHERE `name` LIKE '%in'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `id`, `name` FROM `staffs` WHERE `pos` LIKE '%na'; /* 索引失效 全表扫描 */ EXPLAIN SELECT `name`, `age`, `pos`, `add_time` FROM `staffs` WHERE `name` LIKE '%in'; \",\"口诀：覆盖索引保两边。\"]},\"513\":{\"h\":\"字符要加单引号\",\"t\":[\"/* 使用到了覆盖索引 */ EXPLAIN SELECT `id`, `name` FROM `staffs` WHERE `name` = 'Ringo'; /* 使用到了覆盖索引 */ EXPLAIN SELECT `id`, `name` FROM `staffs` WHERE `name` = 2000; /* 索引失效 全表扫描 */ EXPLAIN SELECT * FROM `staffs` WHERE `name` = 2000; \",\"这里name = 2000在MySQL中会发生强制类型转换，将数字转成字符串。\",\"口诀：字符要加单引号。\"]},\"514\":{\"h\":\"索引相关题目\",\"t\":[\"假设index(a,b,c)\",\"Where语句\",\"索引是否被使用\",\"where a = 3\",\"Y，使用到a\",\"where a = 3 and b = 5\",\"Y，使用到a，b\",\"where a = 3 and b = 5\",\"Y，使用到a，b，c\",\"where b = 3 或者 where b = 3 and c = 4 或者 where c = 4\",\"N，没有用到a字段\",\"where a = 3 and c = 5\",\"使用到a，但是没有用到c，因为b断了\",\"where a = 3 and b > 4 and c = 5\",\"使用到a，b，但是没有用到c，因为c在范围之后\",\"where a = 3 and b like 'kk%' and c = 4\",\"Y，a，b，c都用到\",\"where a = 3 and b like '%kk' and c = 4\",\"只用到a\",\"where a = 3 and b like '%kk%' and c = 4\",\"只用到a\",\"where a = 3 and b like 'k%kk%' and c = 4\",\"Y，a，b，c都用到\"]},\"515\":{\"h\":\"面试题分析\",\"t\":[\"数据准备\",\"/* 创建表 */ CREATE TABLE `test03`( `id` INT PRIMARY KEY NOT NULL AUTO_INCREMENT, `c1` CHAR(10), `c2` CHAR(10), `c3` CHAR(10), `c4` CHAR(10), `c5` CHAR(10) ); /* 插入数据 */ INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES('a1','a2','a3','a4','a5'); INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES('b1','b22','b3','b4','b5'); INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES('c1','c2','c3','c4','c5'); INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES('d1','d2','d3','d4','d5'); INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES('e1','e2','e3','e4','e5'); /* 创建复合索引 */ CREATE INDEX idx_test03_c1234 ON `test03`(`c1`,`c2`,`c3`,`c4`); \",\"题目\",\"/* 最好索引怎么创建的，就怎么用，按照顺序使用，避免让MySQL再自己去翻译一次 */ /* 1.全值匹配 用到索引c1 c2 c3 c4全字段 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' AND `c3` = 'a3' AND `c4` = 'a4'; /* 2.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' AND `c4` = 'a4' AND `c3` = 'a3'; /* 3.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/ EXPLAIN SELECT * FROM `test03` WHERE `c4` = 'a4' AND `c3` = 'a3' AND `c2` = 'a2' AND `c1` = 'a1'; /* 4.用到索引c1 c2 c3字段，c4字段失效，范围之后全失效 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' AND `c3` > 'a3' AND `c4` = 'a4'; /* 5.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' AND `c4` > 'a4' AND `c3` = 'a3'; /* 6.用到了索引c1 c2 c3三个字段, c1和c2两个字段用于查找, c3字段用于排序了但是没有统计到key_len中，c4字段失效 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' AND `c4` = 'a4' ORDER BY `c3`; /* 7.用到了索引c1 c2 c3三个字段，c1和c2两个字段用于查找, c3字段用于排序了但是没有统计到key_len中*/ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' ORDER BY `c3`; /* 8.用到了索引c1 c2两个字段，c4失效，c1和c2两个字段用于查找，c4字段排序产生了Using filesort说明排序没有用到c4字段 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' ORDER BY `c4`; /* 9.用到了索引c1 c2 c3三个字段，c1用于查找，c2和c3用于排序 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c5` = 'a5' ORDER BY `c2`, `c3`; /* 10.用到了c1一个字段，c1用于查找，c3和c2两个字段索引失效，产生了Using filesort */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c5` = 'a5' ORDER BY `c3`, `c2`; /* 11.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' ORDER BY c2, c3; /* 12.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' AND `c5` = 'a5' ORDER BY c2, c3; /* 13.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 没有产生Using filesort 因为之前c2这个字段已经确定了是'a2'了，这是一个常量，再去ORDER BY c3,c2 这时候c2已经不用排序了！ 所以没有产生Using filesort 和(10)进行对比学习！ */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c2` = 'a2' AND `c5` = 'a5' ORDER BY c3, c2; /* GROUP BY 表面上是叫做分组，但是分组之前必定排序。 */ /* 14.用到c1 c2 c3三个字段，c1用于查找，c2 c3用于排序，c4失效 */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c4` = 'a4' GROUP BY `c2`,`c3`; /* 15.用到c1这一个字段，c4失效，c2和c3排序失效产生了Using filesort */ EXPLAIN SELECT * FROM `test03` WHERE `c1` = 'a1' AND `c4` = 'a4' GROUP BY `c3`,`c2`; \",\"GROUP BY基本上都需要进行排序，索引优化几乎和ORDER BY一致，但是GROUP BY会有临时表的产生。\"]},\"516\":{\"h\":\"索引失效的原理分析\"},\"517\":{\"h\":\"索引失效的总结\",\"t\":[\"索引优化的一般性建议：\",\"对于单值索引，尽量选择针对当前query过滤性更好的索引。\",\"在选择复合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。\",\"在选择复合索引的时候，尽量选择可以能够包含当前query中的where子句中更多字段的索引。\",\"尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。\"]},\"518\":{\"h\":\"慢查询基础\",\"t\":[\"索引是如此的重要，以至于我们花费了不小的篇幅来介绍，这对于高性能来说是必不可少的。但这些还不够，还需要合理的设计查询，如果查询写得很糟糕，即使库表结构再合理、索引再合适，也无法实现高性能。查询优化、索引优化、库表结构优化需要多管齐下才能写出高效的SQL。\",\"如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行得更快。\",\"通常来说，查询的生命周期可以按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中“执行”可以认为是生命周期中最重要的阶段，这其中包含了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。\",\"在完成这些任务的时候，查询需要在不同的地方花费时间，包括网络，CPU计算，生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间。根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。\",\"在发生慢查询的时候，要么是某些操作被额外地重复了很多次，要么是某些操作执行得太慢。优化查询的目的就是减少和消除这些操作所花费的时间。\",\"查询性能低下最基本的原因是访问的数据太多，某些查询可能不可避免地需要筛选大量数据，但这并不常见。大部分性能低下的查询都可以通过减少访问数据量的方式进行优化，对于低效的查询，通过如下两个步骤来分析总是非常有效：\",\"确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列\",\"确认MySQL服务器层是否在分析大量超过需要的数据行\"]},\"519\":{\"h\":\"请求多余的数据\",\"t\":[\"有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃，这会给MySQL服务器带来额外的负担，并增加网络开销，离国内外i啊也会消耗应用服务器的CPU和内存资源。\"]},\"520\":{\"h\":\"查询不需要的记录\",\"t\":[\"一个常见的错误是常常会误以为MySQL只会返回需要的数据，实际上MySQL却是先返回全部结果集再进行计算。典型的场景是先使用select语句查询大量的结果，然后获取前面N行后关闭结果集（例如在新闻网站中取出100条记录，但是只是在页面上显示前面10条）。MySQL并不会只查出需要的10条数据，而是会查询出全部的结果集，客户端的应用程序会接收全部的结果集数据，然后抛弃其中的大部分数据。最简单有效的解决方法就是在这样的查询后面加上LIMIT。\"]},\"521\":{\"h\":\"多表关联时返回全部列\",\"t\":[\"如果想查询所有在电影Academy Dinosaur中出现的演员，不应该按下面的写法编写查询：\",\"SELECT * FROM sakila.actor INNER JOIN sakila.film_actor USING(actor_id) INNER JOIN sakila.film USING(film_id) WHERE sakila.film.title = 'Academy Dinosaur'; \",\"这将返回这三表的全部数据列，正确的方式应该像下面这样只取需要的列：\",\"SELECT sakila.actor.* FROM sakila.actor...; \"]},\"522\":{\"h\":\"总是取出全部列\",\"t\":[\"每次看到select *的时候都需要用怀疑的眼光审视，是不是真的需要返回全部的数据？很可能不是必须的。取出全部列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的I/O、内存和CPU的消耗，有时候还能避免某些列被修改带来的问题。\",\"不过，查询返回超过需要的数据也不总是坏事，它可以提高相同代码片段的复用性，如果应用程序使用某种缓存机制，或者有其他考虑，获取超过需要的数据也可能有其好处，但不能忘记这样做的代价是什么。\"]},\"523\":{\"h\":\"重复查询相同的数据\",\"t\":[\"如果不加以小心，很容易出现这样的错误——不断地重复执行相同的查询，然后每次都返回完全相同的数据。例如，在用户评论的地方需要查询用户头像的URL，那么用户多次评论的时候，可能就会反复查询这个数据。比较好的方案是，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样性能显然会更好。\"]},\"524\":{\"h\":\"扫描额外的记录\",\"t\":[\"在确定查询只返回需要的数据以后，接下来应该看看查询为了返回结果是否扫描了过多的数据。对于MySQL，最简单的衡量查询开销的三个指标如下：\",\"响应时间\",\"扫描的行数\",\"返回的行数\",\"没有哪个指标能够完美地衡量查询的开销，但它们大致反映了MySQL在内部执行查询时需要访问多少数据，并可以大概推算出查询运行的时间。这三个指标都会记录到MySQL的慢日志中，所以，检查慢日志记录是找出扫描行数过多的查询的好办法。\"]},\"525\":{\"h\":\"响应时间\",\"t\":[\"响应时间是两个部分之和：服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正地执行查询的时间——可能是等I/O操作完成，也可能是等待行锁，等等。遗憾的是，我们无法把响应时间细分到上面这些部分，除非有什么办法能够逐个测量上面这些消耗，不过很难做到。一般常见和重要的是等待是I/O和锁等待，但是实际情况更加复杂。\",\"所以在不同类型的应用压力下，响应时间并没有什么一致的规律或者公示。诸如存储引擎的锁（表锁、行锁）、高并发资源竞争、硬件响应等诸多因素都会影响响应时间。所以，响应时间既可能是一个问题的结果也可能是一个问题的原因，不同案例的情况不同。\",\"当看到一个查询请求的响应时间的时候，应该使用“快速上限估计”法来估算这个时间是否是一个合理的值。“快速上限估计”法概括地说，了解这个查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机I/O，再用其乘以在具体硬件下一次I/O的消耗时间，最后把这些消耗都加起来，就可以获得一个大概参考值来判断当前响应时间是不是一个合理的值。\"]},\"526\":{\"h\":\"扫描的行数和返回的行数\",\"t\":[\"分析查询时，查看该查询扫描的行数是非常有帮助的。这在一定程度上能够说明该查询找到需要的数据的效率高不高。\",\"对于找出那些“糟糕”的查询，这个指标可能还不够完美，因为并不是所有的行的访问代价都是相同的。较短的性的访问速度更快，内存中的行也比磁盘中的行的访问速度要快得多。\",\"理想情况下，扫描的行数和返回的行数应该是相同的。但实际情况中这种“美事”并不多。例如在做一个关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在1:1和10:1之间，不过有时候这个值也可能非常大。\"]},\"527\":{\"h\":\"扫描的行数和访问类型\",\"t\":[\"在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySQL有好几种访问方式可以查找并返回一行结果。有一些访问方式可能需要扫描很多行才能返回一行结果，也有些访问方式可能无需扫描就能返回结果。\",\"在explain语句中的type列反映了访问类型。访问类型有很多中，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。这里列的这些，速度从慢到快，扫描的行数也从小到大。如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引。索引让MySQL以最高效、扫描行数最少的方式找到需要的记录。\",\"例如，我们在示例数据库Sakila中的一个查询案例：\",\"SELECT * FROM sakila.film_actor WHERE film_id = 1; \",\"这个查询将返回10行数据，从explain的结果可以看到，MySQL在索引idx_fk_film_id上使用了ref访问类型来执行查询：\",\"EXPLAIN SELECT * FROM sakila.film actor WHERE film id = 1\\\\G **************************** 1. roW *************************** id: 1 select_type: SIMPLE table: film_actor type: ref possible_keys: idx_fk_film_id key: idx_fk_film_id key_len: 2 ref: const rows: 10 Extra: \",\"explain的结果也显示MySQL预估需要访问10行数据。换言之，查询优化器认为这种访问类型可以高效地完成查询。如果没有合适的索引MySQL就不得不使用一种更糟糕的访问类型。如果我们删除对应的索引再来运行这个查询：\",\" ALTER TABLE sakila.film_actor DROP FOREIGN KEY fk_film_actor_film; ALTER TABLE sakila.film_actor DROP KEY idx_fk_film_id; EXPLAIN SELECT * FROM sakila.film_actor WHERE film_id = 1\\\\G *************************** 1. row ********************* id: 1 select_type: SIMPLE table: film_actor type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 5073 Extra: Using where \",\"正如我们预测的，访问类型变成了一个全表扫描（ALL），现在MySQL预估需要扫描5073条记录来完成这个查询。这里的“Using Where”表示MySQL将通过WHERE条件来筛选存储引擎返回的记录。\",\"一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：\",\"在索引中使用WHERE条件来过滤不匹配的记录。这时存储引擎层完成的\",\"使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无需再回表查询记录\",\"从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤\",\"上面的这个例子说明了好的索引多么重要。好的索引可以让查询使用合适的访问类型，尽可能地只扫描需要的数据行。但也不是说增加索引就能让扫描的行数等于返回的行数。例如下面使用聚合函数COUNT（）的查询：\",\"SELECT actor_id, COUNT (*) FROM sakila.film_actor GROUP BY actor_id; \",\"这个查询需要读取几千行数据，但是仅返回200行结果。没有什么索引能够让这样的查询减少需要扫描的行数。\",\"不幸的是，MySQL不会告诉我们生成结果实际上需要扫描多少行数据，而只会告诉我们生成结果时一共扫描了多少行数据。扫描的行数中的大部分都很可能是被WHERE条件过滤掉的，对最终的结果集没有并没有贡献。在上面的例子中，我们删除索引后，看到MySQL需要扫描多少行和实际需要使用的行数需要先去理解这个查询背后的逻辑和思想。\",\"如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧进行优化：\",\"使用索引覆盖扫描，把所有需要的列都放到索引中，这样存储引擎无需回表获取对应行就可以返回结果了\",\"改变库表结构，例如使用单独的汇总表\",\"重写这个复杂的查询，让MySQL优化器能够以更优化的方式去执行这个查询\"]},\"528\":{\"h\":\"重构查询\"},\"529\":{\"h\":\"复杂查询 or 简单查询\",\"t\":[\"设计查询的时候一个需要考虑的重要问题时，是否需要将一个复杂的查询分成多个简单的查询。在传统的实现中，总是强调需要数据库层完成尽可能多的工作，这样做的逻辑在于以前总是认为网络通信、查询解析和优化是一件代价很高的事情。\",\"但是这样的想法对于MySQL来说并不适用，MySQL从设计上连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效。现代的网络速度比以前要快很多，无论是带宽还是延迟。在某些版本的MySQL上，即使在一个通用服务器上，也能够运行每秒超过10万的查询，即使是一个千兆网卡也能轻松满足每秒超过2000次的查询，所以运行多个小查询现在已经不是大问题了。\",\"MySQL内部每秒能够扫描内存中上百万行的数据，相比之下，MySQL响应数据给客户端就慢得多了。在其他条件都相同的时候，使用尽可能少的查询当然是更好的。但是有时候时候，将一个大查询分解为多个小查询是很有必要的。\"]},\"530\":{\"h\":\"切分查询\",\"t\":[\"有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。\",\"删除旧的数据就是一个很好的例子。定期地清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。将一个大的DELETE语句切分成多个较小的查询可以尽可能小地影响MySQL性能，同时还可以减少MySQL复制的延迟。例如，我们需要每个月运行一次下面的查询：\",\"DELETE FROM messages WHERE created < DATE_SUB(NOW(), INTERVAL 3 MONTH); \",\"那么可以用类似下面的方法来完成相同的工作：\",\"rows affected = 0 do { rows_affected = do_query( \\\"DELETE FROM messages WHERE created < DATE_SUB(NOW(),INTERVAL 3 MONTH). LIMIT 10000\\\" ) } while rows_affected > 0 \",\"一次删除一万行数据一般来说时一个比较高效而且对服务器影响也最小的做法（如果是事务型引擎，很多时候小事务能够更高效）。同时，需要注意的是，如果每次删除数据后，都暂停一会儿再做下一次删除，这样也可以将服务器上原本一次性的压力分散到一个很长的时间段中，就可以大大降低对服务器的影响，还可以大大减少删除时锁的持有时间。\"]},\"531\":{\"h\":\"分解关联查询\",\"t\":[\"很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，例如，下面这个查询：\",\"SELECT * FROM tag JOIN tag_post ON tag_post.tag_id = tag.id JOIN post ON tag_post.post_id = post.id WHERE tag.tag = 'mysql'; \",\"可以分解成下面这些查询来代替：\",\"SELECT * FROM tag WHERE tag = 'mysql'; SELECT * FROM tag_post WHERE tag_id = 1234; SELECT * FROM post WHERE post.id in (123,456,567,9098,8904); \",\"使用分解关联查询的优势如下：\",\"让缓存的效率更高。许多应用程序可以方便地缓存单表查询对应的结果对象。例如，上面查询中的tag已经被缓存了，那么应用就可以跳过第一个查询。再例如，应用中已经缓存了ID为123、567、9098的内容，那么第三个查询的IN（）中就可以少几个ID。另外，对MySQL的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了\",\"将查询分解后，执行单个查询可以减少锁的竞争\",\"在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展\",\"查询本身效率也可能会有所提升。在这个例子中，使用IN（）代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联要更高效\",\"可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构可能会减少网络和内存的消耗\",\"更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。某些场景哈希关联的效率要高很多\",\"在很多场景下，通过重构查询将关联当到应用程序中将会更加高效，这样的场景有很多，比如：当应用能够方便地缓存单个查询结果的时候，当可以将数据分布到不同的MySQL服务器上的时候，当能够使用IN（）的方式来代替关联查询的时候，当查询中使用同一个数据表的时候。\"]},\"532\":{\"h\":\"count（*）优化\",\"t\":[\"在实际的开发中，经常可能需要计算一个表中（或部分）的行数，通常可以使用select count(*) from t，但随着系统中记录数的不断增多，这条语句会执行得越来越慢。\"]},\"533\":{\"h\":\"count(*)的实现\",\"t\":[\"实际上，在不同的MySQL引擎中，count(*)有不同的实现方式：\",\"MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数（如果没有where条件），效率很高\",\"InnoDB引擎在执行count（*）的时候，需要把数据一行一行地从引擎里面读出来后，累积计数，显然，这种方式地效率很低\",\"那为什么InnoDB不跟MyISAM一样，也把数字存起来呢？这是因为即使在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的，这里，我们以一个算count（*）的例子来说明，假设表t中现在有10000条记录，并且有三个用户并行的会话：\",\"会话A先启动事务并查询一次表的总行数\",\"会话B启动事务，插入一行后记录后，查询表的总行数\",\"会话c先启动一个单独的语句，插入一行记录后，查询表的总行数\",\"这里我们假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。\",\"可以看到，在最后的同一个时刻，三个会话A、B、C会同时查询表t的总行数，但拿到的结果却不同，这和InnoDB的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是MVCC来实现的，每一行记录都要判断自己是否对这个会话可见，因此对于count（*）请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。\",\"不过，InnoDB对这个语句也做个一定程度的优化，InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于count(*)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的，因此，MySQL优化器会找到最小的那棵树来遍历，在保证逻辑正确的前题下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。\",\"也许你想到show table status命令，这个命令的输出结果也有一个TABLE_ROWS用于显示这个表当前有多少行，并且这个命令执行的速度较快，遗憾的是，TABLE_ROWS是通过采样估算的来的，因此只是一个估算值，官方文档显示误差可能达到40%到50%，因此，也无法使用它来进行统计。\",\"那么如果有一个页面经常要显示交易系统的操作记录总数，到底应该怎么办呢？答案是，只能自己计数，接下来，我们将会讨论自己计数的方法，以及每种方法优缺点。\"]},\"534\":{\"h\":\"使用缓存系统保存计数\",\"t\":[\"对常见的做法就是使用缓存，可以使用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。这种方式的缺点就在于，缓存系统可能会丢失更新。Redis的数据不能永久地留在内存中，所以需要找一个地方把这个值定期地持久化存储起来，但即使这样，仍然可能丢失更新，如果刚刚在数据表中插入了一行，Redis中保存的值也加了1，然后Redis异常重启了，重启后需要从存储Redis数据的地方把这个值读回来，而刚刚加1的这个计数操作却丢失了。\",\"实际上，将计数保存在缓存系统中的方式，还不只是丢失更新的问题，即使Redis正常工作，这个值还是逻辑上不精确的。\"]},\"535\":{\"h\":\"在数据库中保存计数\"},\"536\":{\"h\":\"不同count的用法\",\"t\":[\"count（）是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加，最后返回累计值，所以count（*）、count（主键id）和count（1）都表示返回满足条件的结果集的总行数，而count（字段）,则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。\",\"对于count（主键id）来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层，server层拿到id后，判断是不可能为空的，就按行累加；对于count（1）来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。相比较而言，count（1）执行得要比count（主键id）快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。\",\"虽然主键id一定不为空，但InnoDB并没有做相关的优化。\",\"对于count（字段）来说：\",\"如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加\",\"如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断以下，不是null才累加\",\"这些不同的方式按照效率排序：count（字段）< count（主键id） < count（1） ≈ count（*）。\"]},\"537\":{\"h\":\"join语句的优化\",\"t\":[\"在实际生产中，关于join语句使用的问题，一般会几种在以下两类：\",\"DBA不让使用join，使用join有什么问题？\",\"如果有两个大小不同的表做join，应该用哪个表做驱动表？\",\"为了便于量化分析，我们创建两个表t1和t2：\",\"CREATE TABLE `t2` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`) ) ENGINE = InnoDB; drop procedure idata; delimiter;; create procedure idata() begin declare i int; set i = 1; while(i <= 1000) do insert into t2 values (i, i, i); set i = i + 1; end while; end;; delimiter; call idata(); create table t1 like t2; insert into t1 (select * from t2 where id <= 100); \",\"这两张表都有一个主键索引id和一个索引a，字段b上无索引。存储过程idata()往表t2里面插入了1000行数据，在表t1插入的是100行数据。\"]},\"538\":{\"h\":\"Index Nested-Loop Join\",\"t\":[\"select * from t1 straight_join t2 on (t1.a=t2.a); \",\"如果直接使用join语句，MySQL优化器可能会选择表t1或t2作为驱动表，这样会影响我们分析SQL语句的执行过程，使用straight_join可以让MySQL使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去join，在这个语句里，t1是驱动表，t2是被驱动表，explain的结果如下：\",\"可以看到，在这条语句里，被驱动表t2的字段上有索引，join过程用上了这个索引，因此这个语句的执行流程如下：\",\"从表t1中读入一行数据R\",\"从数据行R中，取出字段到表t2里去查找\",\"取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分\",\"重复执行步骤1到3，直到表t1的末尾循环结束\",\"这个过程是现遍历表t1，然后根据从表t1中取出的每行数据中a的值，去表t2查找满足条件的记录，在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“Index Nested-Loop Join”，简称NLJ。对应的流程图如下：\",\"在这个流程里：\",\"对驱动表t1做了全表扫描，这个过程需要扫描100行\",\"对于每一行R，根据a字段去表t2查找，走的是树搜索过程，由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也就是总共扫描100行\",\"所以，整个执行流程，总扫描行数是200\",\"假设不使用join，那我们就只能用单表查询，要实现上述相同的需求，使用单表查询需要：\",\"执行select * from t1，查出表t1的所有数据，这里有100行\",\"循环遍历这100行数据 \",\"从每一行R取出字段a的值$R.a\",\"执行select * from where a = $R.a\",\"把返回的结果和R构成结果集的一行\",\"可以看到，在这个查询过程，也就是扫描了200行，但是总共执行了101条语句，比直接join多了100次交互，除此之外，客户端还要自己拼接SQL语句和结果，那么显然，这么做不如直接join。\",\"在这个join语句的执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索，假设被驱动表的行数是M，每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引，每次搜索一棵树近似复杂度是以2为底的M的对数，记为log2M，所以在被驱动表上查一行的时间复杂度是2*log2M。假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次，因此整个执行过程，时间复杂度近似是N+N*2log2M，显然，N对扫描行数影响更大，因此应该让小表做驱动表。\",\"通过以上的分析，我们可以得到两个结论：\",\"使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好\",\"如果使用join语句的话，需要让小表做驱动表\"]},\"539\":{\"h\":\"Simple Nested-Loop Join\",\"t\":[\"现在，我们将SQL语句修改如下：\",\"select * from t1 straight_join t2 on (t1.a = t2.b); \",\"由于表t2的字段上没有索引，因此在join的时候，每次到t2做一次匹配，就要做一次全表扫描，这种算法就被称为“Simple Nested-Loop Join”。虽然也可以得到正确的结果，但是这个SQL请求需要扫描表t2多达100次，总共扫描100*1000=10万行。如果t1和t2都是10万行的表，就需要扫描100亿行，不难想象，这个语句的执行将会非常耗时。MySQL并没有使用Simple Nested-Loop Join算法，而是使用了另一个叫做“Block Nested-Loop Join”的算法，简称BNL。\"]},\"540\":{\"h\":\"Block Nested-Loop Join\",\"t\":[\"BNL的执行流程如下：\",\"将表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整个表t1放入了内存\",\"扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回\",\"流程图如下：\",\"explain的结果如下：\",\"可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做判断的次数是100*1000=10万次。\",\"从时间复杂度上来看，Simple Nested-Loop Join和Block Nested-Loop Join算法是相同的，但是BNL算法的这10万次判断是内存操作，速度会快上很多，性能也更好。\",\"那么在这种情况下，应该使用哪个表做驱动表呢？假设小表的行数是N，大表的行数是M，那么在这个算法里：\",\"两个表都做一次全表扫描，所以总的扫描行数是M+N\",\"内存中的判断次数是M*N\",\"可以看到，调换M和N的位置，并不会影响这个算法的时间复杂度，因此这个时候选择大表或者小表做驱动表，执行耗时都是一样的。\",\"这个算法会将t1表的内容放入到join_buffer中，join_buffer的大小是由参数join_buffer_size设定的，默认值是256k。如果放不下表t1的所有数据的话，就会分段放置。现在我们将join_buffer_size改小，再执行：\",\"select * from t1 straight_join t2 on (t1.a=t2.b); \",\"此时，执行流程就变成了：\",\"扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步\",\"扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回\",\"清空join_buffer\",\"继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第二步\",\"执行的流程图如下：\",\"图中的步骤4和5表示清空join_buffer复用，这也体现出了这个算法名字中“Block”的由来，表示“分块去join”。由于表t1被分成了两次放入join_buffer中，导致表t2会被扫描两次，虽然分成两次放入join_buffer，但是判断等值条件的次数还是不变的，依然是（88+12）*1000=10万次。\",\"在这个算法里，驱动表的数据行数是N，需要分k段才能完成算法流程，其中K=λN（λ∈（0,1）），被驱动表的数据行数是M：\",\"扫描行数是N+λ*N*M\",\"内存判断是N*M次\",\"显然，内存判断次数是不受选择哪个表作为驱动表影响的，而考虑到扫描行数，在M和N大小确定的情况下，N小一些，整个算式的结果会更小，所以在这种算法下，应该让小表当驱动表。\",\"在N+λ*N*M中，还有一个关键的参数λ，可以看到λ越小越好，由定义，我们可以知道λ=K/N，那么显然，在N确定的情况下，K越小越好，也就是说，当join_buffer_size越大的时候，分成的段数也就越少，对被驱动表的全表扫描次数就越少。\",\"以上结论告诉我们，如果join语句很慢，可以尝试将join_buffer_size改大。\",\"我们回到本小节一开始的两个问题：\",\"能不能使用join语句？\",\"如果使用join语句，应该选择大表做驱动表还是选择小表做驱动表？\",\"对于第一个问题：\",\"如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，就可以用上被驱动表上的索引，其实是没问题的\",\"如果使用Block Nested-Loop Join算法，扫描行数就会过多，尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源，所以这种join尽量不要使用\",\"因此，在判断要不要使用join语句时，就是看explain的结果里面，extra字段里面有没有出现“Block Nested Loop”字样。\",\"对于第二个问题：\",\"如果是Index Nested-Loop Join算法，应该选择小表做驱动表\",\"如果是Block Nested-Loop Join算法： \",\"在join_buffer_size足够大的时候，是一样的\",\"在join_buffer_size不够大的时候（这种情况更为常见），应该选择小表做驱动表\",\"所以，这个问题的结论是，应该选择小表做驱动表。不过需要格外说明的是，在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。\"]},\"541\":{\"h\":\"Multi-Range Read 优化\",\"t\":[\"NLJ和BNL都还有优化的空间，为了说明这一点，创建表t1和t2：\",\"create table t1( id int primary key, a int, b int, index(a) ); create table t2 like t1; drop procedure idata; delimiter;; create procedure idata() begin declare i int; set i = 1; while(i <= 1000) do insert into t1 values (i, 1001 - i, i); set i = i + 1; end while; set i = 1; while(i <= 1000000) do insert into t2 values (i, i, i); set i = i + 1; end while; end;; delimiter; call idata(); \",\"在表t1里，插入了1000行数据，每一行的a=1001-id的值。也就是说，表t1中字段a是逆序的，同时，在表t2中插入了100万行数据。\",\"Multi-Range Read优化的主要目的是尽量使用顺序读盘。回表是指，InnoDB在普通索引a上查到主键id的值后，再根据一个个主键id的值到主键索引上去查整行数据的过程。\",\"select * from t1 where a >= 1 and a <= 100; \",\"由于主键索引是一颗B+树，在这棵树上，每次只能根据一个主键id查到一行数据。因此，回表肯定是一行行搜索主键索引的，基本流程如图所示：\",\"如果随着a的值递增顺序查询的话，id的值就变成随机的，那么就会出现随机访问，性能相对较差。虽然还是按行查，但是可以通过调整查询的顺序，还是可以加速查询的效率，因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。这就是MRR优化的设计思路，此时语句的执行流程就变成了这样：\",\"根据索引a，定位到满足条件的记录，将id值放入read_rnd_buffer中\",\"将read_rnd_buffer中的id进行递增排序\",\"排序后的id数组，依次到主键id索引中查记录，并作为结果返回\",\"这里，read_rnd_buffer的大小是由read_rnd_buffer参数控制的。如果步骤1中，read_rnd_buffer放满了，就会执行步骤2和3，然后清空read_rnd_buffer，之后继续找索引a的下个记录，并继续循环。\",\"如果想要稳定地使用MRR优化的话，需要设置`set optimizer_switch=\\\"mrr_cost_based=off\\\"`，因为目前的优化器会更倾向于不使用MRR，通过这个设置就可以保证一定可以使用MRR优化。\",\"explain的结果：\",\"从explain的结果来看，Extra字段多了Using MRR，表示的是用上了MRR优化，而且，由于我们在read_md_buffer中按照id做了排序，所以最后得到的结果集也是按照主键id递增顺序的，与没有适用MRR的结果集顺序刚好相反。\",\"总而言之，MRR能够提升性能的核心在于，这条查询语句在索引a上是一个范围查询（也就是说，这是一个多指查询），可以得到足够多的主键id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。\"]},\"542\":{\"h\":\"Batched Key Access\",\"t\":[\"MySQL在5.6版本后开始引入了Batched Key Acess（BKA）算法，这个算法其实就是对NLJ算法的优化。首先我们来回顾一下NLJ算法的执行流程：\",\"NLJ算法执行的逻辑是：从驱动表t1，一行行地取出a的值，再到被驱动表t2去做join。也就是说，对于表t2来说，每次都是匹配一个值，这时，MRR的优势就用不上了。那怎么才能一次性地多穿些值给表t2呢？从表t1里一次性地多拿些出来，放入到join_buffer，然后一起传给表t2，这就是BKA算法，简而言之，使用join_buffer优化的NLJ算法就是BKA算法，算法的流程图如下：\",\"图中，join_buffer中放入的数据是R1~R100，表示的是只会取查询需要的字段，如果join_buffer放不下 R1~R100 的所有数据，就会把这100行数据分成多段执行上图的流程。BKA算法并没有默认开启，如果要使用BKA优化算法的话，需要在执行SQL语句之前，先设置：\",\"set optimizer_switch = 'mrr=on,mrr_cost_based=off,batched_key_access=on'; \",\"其中，前两个参数的作用是启用MRR，这么做的原因是，BKA算法的优化要依赖于MRR。\"]},\"543\":{\"h\":\"BNL算法的性能问题\",\"t\":[\"BNL可能会对被驱动表做多次扫描，如果这个被驱动表是一个大的冷数据表，除了会导致IO压力大以外，还会对系统有什么影响呢？\",\"由于InnoDB对Buffer Pool的LRU算法做了优化，即：第一次从磁盘读入内存的数据页，会先放在old区域。如果1秒之后这个数据也不再被访问了，就不会移动到LRU链表头部，这样对Buffer Pool的命中率影响就不大。但是，如果这个冷表很大，就会出现另外一种情况：业务正常访问的数据页，没有机会进入young区域。\",\"由于这个优化机制的存在，一个正常访问的数据页，要进入young区域，需要隔1秒后再次被访问到。但是，由于我们的join语句在循环读磁盘和淘汰内存页，进入old区域的数据页，很可能在1秒内就被淘汰了。这样，就会导致MySQL实例的Buffer Pool在这段时间内，young区域的数据页没有被合理地淘汰，也就是说，这两种情况都会影响Buffer Pool的正常运作。\",\"BNL算法对系统的影响主要包括三个方面：\",\"可能会多次扫描被驱动表，占用磁盘IO资源\",\"判断join条件需要执行M*N次对比（M、N分别是两张表的行数），如果是大表就会占用非常多的CPU资源\",\"可能会导致Buffer Pool的热数据被淘汰，影响内存命中率\",\"因此，我们在执行语句之前，需要通过理论分析和查看explain结果的方式，确认是否使用BNL算法。如果确认优化器会使用BNL算法，就需要做优化。优化的常见做法是，给被驱动表的join字段加上索引，把BNL算法转成BKA算法。\"]},\"544\":{\"h\":\"BNL转BKA\",\"t\":[\"大多数情况下，我们直接在被驱动表上建立索引，就可以直接转为BKA算法了，但是也有一些并不适合在被驱动表上建索引的情况，比如下面这个语句：\",\"select * from t1 join t2 on (t1.b = t2.b) where t2.b >= 1 and t2.b <= 2000; \",\"此时，如果BNL算法来join的话，语句的执行流程如下：\",\"把表t1的所有字段取出来，存入join_buffer中，这个表只有1000行，join_buffer_size默认值是256k，可以完全存入\",\"扫描表t2，取出每一行数据跟join_buffer中的数据进行对比： \",\"如果不满足t1.b = t2.b\",\"如果满足t1.b = t2.b，再判断其它条件，也就是是否满足t2.b∈[1,2000]，如果是，就作为结果集的一部分返回，否则跳过\",\"explain的结果如下：\",\"可以发现，判断join是否满足的时候，会扫描表t2的每一行，判断条件的次数是1000*100万=10亿次，这个判断的工作量很大。但是经过where条件过滤后，需要参与join的实际上只有2000行数据。如果这条语句是一个低频的SQL语句，那么再为这个语句在表t2的字段b上创建一个索引就很浪费了。\",\"在表t2的字段b上创建索引会浪费资源，但是不创建索引的话需要判断10亿次，这个时候就可以考虑使用临时表，使用临时表的步骤如下：\",\"将表t2中满足条件的数据放在临时表tmp_t中\",\"为了让join使用BKA算法，给临时表tmp_t的字段b加上索引\",\"让表t1和tmp_t做join操作\",\"create temporary table temp_t(id int primary key, a int, b int, index(b))engine=innodb; insert into temp_t select * from t2 where b>=1 and b<=2000; select * from t1 join temp_t on (t1.b=temp_t.b); \",\"执行的流程如下：\",\"执行insert语句构造temp_t表并插入数据的过程中，对表t2做了全表扫描，这里扫描的行数是100万\",\"之后的join语句，扫描表t1，这里的扫描行数是1000，join比较过程中，做了1000次带索引的查询，相比于优化前的join语句需要做10亿次条件判断来说，这个优化效果还是很明显的\",\"执行的效果如下：\",\"总体来看，不论是在原表上加索引，还是用有索引的临时表，我们的思路都是让join语句能够用上被驱动表上的索引，来触发BKA算法，提升查询性能。\"]},\"545\":{\"h\":\"hash join\",\"t\":[\"在之前的例子中，之所以要有计算10亿次的操作，是因为在join_buffer里面维护的是一个无序数组，而不是一个哈希表，如果能够将无序数组替换为哈希表，这样只需要100万次的哈希查找，整条语句的执行速度就可以加快，但MySQL的优化器和执行器并不支持哈希join。不过，我们可以按照这个思路，在业务端实现：\",\"select * from t1;，取得表t1的全部1000行数据，在业务端存入到哈希这种数据结构的实现，比如HashMap\",\"select * from t2 where b >= 1 and b <= 2000;，获取表t2中满足条件的2000行数据\",\"把这2000行数据，一行行地取到业务端，到哈希表中寻找匹配的数据，满足匹配的条件的这行数据，就作为结果集的一行\"]},\"546\":{\"h\":\"MySQL中的临时表\",\"t\":[\"在join语句优化的章节中，我们使用了临时表：\",\"create temporary table temp_t like t1; alter table temp_t add index(b); insert into temp_t select * from t2 where b >= 1 and b <= 2000; select * from t1 join temp_t on (t1.b = temp_t.b); \",\"与临时表相类似的还有内存表，实际上这两个概念是完全不同的。\",\"内存表，指的是使用Memory引擎的表，建表语法是create table ...engine = memory。这种表的数据都保存在内存里，系统重启的时候就会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”，从其它特征上看，它就是一个正常表\",\"而临时表，可以使用各种引擎类型（包括Memory引擎），如果使用InnDB引擎或者MyISAM引擎的临时表，写数据的时候是写到磁盘上的\"]},\"547\":{\"h\":\"临时表的特性\",\"t\":[\"以下列操作序列为例：\",\"可以看到，临时表有以下几个特点：\",\"建表语法是create temporary table..\",\"一个临时表只能被创建它的session访问，对其它线程不可见，所以，图中session A创建的临时表t，对于session B就是不可见的\",\"临时表可以与普通表同名\",\"session A内有同名的临时表和普通表的时候，show create语句，以及增删改查语句访问的是临时表\",\"show tables命令不显示临时表\",\"由于临时表只能被创建它的session访问，所以在这个session结束的时候，会自动删除临时表，也正是由于这个特性，临时表特别适合join优化的场景，理由如下：\",\"不同session的临时表是可以重名的，如果有多个session同时执行join优化，无需担心表名重复导致建表失败的问题\",\"不需要担心数据删除问题。如果使用普通表，在执行流程过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作\"]},\"548\":{\"h\":\"临时表的应用\",\"t\":[\"由于不同担心线程之间的重名冲突，临时表经常会被用在复杂查询优化过程中，其中，分库分表系统的跨库查询就是一个典型的使用场景。\",\"一般分库分表的场景，就是要把一个逻辑上的大表分散到不同的数据库实例上。比如，将一个大表ht，按照字段f，拆分成1024个分表，然后分布到32个数据库实例上，如下图所示：\",\"一般情况下，这种分库分表系统都有一个中间层proxy，不过，也有一些方案会让客户端直接连接数据，也就是没有proxy这一层。在这个架构中，分区key的选择是以“减少跨库和跨表查询”为依据的。如果大部分的语句都会包含f的等值条件，那么就要用f做分区键。这样，在proxy这一层解析完SQL语句以后，就能确定将这条语句到哪个分表做查询。\",\"以下面的查询语句为例：\",\"select v from ht where f=N; \",\"这时，我们就可以通过分表规则（比如N%1024）来确认需要的数据被放在哪个分表上，这种语句只需要访问一个分表。但是，如果这个表上还有另外一个索引k，并且查询语句如下：\",\"select v from ht where k >= M order by t_modified desc limit 100; \",\"这个时候，由于查询条件里面没有用到分区字段f，只能到所有的分区中去查找满足条件的所有行，然后统一进行排序，这种情况下，有两种比较常用的思路。\",\"第一种思路是在proxy层的进程代码中实现排序。这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算，不过，这个方案的缺点也很明显：\",\"需要的开发工作量比较大。如果仅需要order by还比较简单，但是，如果涉及到复杂的操作，比如group by，甚至join这样的操作，对中间层的开发能力要求比较高\",\"对proxy端的压力比较大，尤其是很容易出现内存不够用和CPU瓶颈的问题\",\"第二种思路是，将各个分库拿到的数据，汇总到一个MySQL实例的一个表中，然后在这个汇总实例上做逻辑操作，以上这条查询语句的执行流程如下：\",\"在汇总库上创建一个临时表temp_ht，表中包含三个字段v、t、t_modified\",\"在各个分库上执行select v,k,t_modified from ht_x where k >= M order by t_modified desc limit 100;\",\"将分库执行的结果插入到temp_ht表中\",\"执行select v from temp_ht order by t_modified desc limit 100;就可以得到结果\",\"第二种思路的示意图如下：\",\"实践中，由于每个分库的计算量都不饱和，所以会直接把临时表temp_ht放到32个分库中的某一个上。\"]},\"549\":{\"h\":\"重命名临时表\",\"t\":[\"上文我们总结临时表的特性，发现不同线程可以创建同名的临时表，那么这是怎么做到的呢？\",\"假设我们执行如下语句：\",\"create temporary table temp_t(id int primary key)engine=innodb; \",\"这个时候，MySQL要给这个InnoDB表创建一个frm文件保存表结构定义，还要有地方保存表数据，这个frm文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程id}_{线程id}_序列号”，可以使用select @@tmpdir命令，来显示实例的临时文件目录。\",\"关于临时表中数据的存放方式，在不同的MySQL版本中有着不同的处理方式：\",\"在5.6以及之前的版本里，MySQL会在临时文件目录下创建一个相同前缀、以.ibd为后缀的文件，用来存放数据文件\",\"而从5.7版本开始，MySQL引入了一个临时文件表空间，专门用来存放临时文件的数据，而无需再创建idb文件\",\"示例如下：\",\"这个进程的进程号是4d2，session A的线程id是4，session B的线程id是5，所以，session A和 session B创建的临时表，在磁盘上的文件不会重名。\",\"MySQL维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个table_def_key。\",\"一个普通表的table_def_key的值是由“库名+表名”得到的，所以如果要在同一个库下创建两个同名的临时表，创建第二表的过程中就会发现table_def_key已经存在了\",\"而对于临时表，table_def_key在“库名+表名”的基础上，又加入了“server_id + thread_id”，也就是说，session A和session B创建的两个临时表t1，它们的table_def_key不同，磁盘文件名也不同，因此可以并存。\",\"在实现上，每个线程都维护了自己的临时表链表。这样，每次session内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表，在sessoin结束的时候，对链表里的每个临时表，执行“DROP TEMPARY TABLE + 表名”操作。\"]},\"550\":{\"h\":\"临时表和主备复制\",\"t\":[\"临时表只能在线程内自己访问，但在执行DROP TEMPARY TABLE命令的时候，也会将其记录到binlog中，写入到binlog中的目的是为了主备复制。为了说明这一点，假设我们执行如下语句：\",\"create table t_normal(id int primary key, c int)engine=innodb;/*Q1*/ create temporary table temp_t like t_normal;/*Q2*/ insert into temp_t values(1,1);/*Q3*/ insert into t_normal select * from temp_t;/*Q4*/ \",\"如果关于临时表的操作都不记录，那么在备库就只有create table t_normal和insert into t_normal select * from temp_t这两个语句的binlog日志，备库在执行到insert into t_normal的时候，就会报错“表temp_t不存在”。\",\"实际上可以通过设置参数binlog_format=row,那么与临时表有关的语句，就不会记录到binlog里。当参数设置为binlog_format=statment/mixedde的时候，binlog才会记录临时表的操作。\",\"当binlog是row格式的时候，创建临时表的语句会自动在备库执行，主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，需要在主库上再写一个DROP TEMPARY TABLE传给备库执行，这就是这个命令会什么会出现在binlog的原因。\",\"通常情况下，MySQL在记录binlog的时候，都会将SQL语句原封不动的记录下来，但是如果执行drop table_normal，此时binlog会被记录成：\",\"DROP TABLE `t_normal` /* generated by server */ \",\"这是因为，drop table是可以一次删除多个表的。在以上的例子中，设置binlog_format=row，如果主库上执行“drop table t_normal, temp_t”这个命令，那么binlog中就只能记录：\",\"DROP TABLE `t_normal` /* generated by server */ \",\"因为备库上并没有表tmp_t，将这个命令重写后再传到备库执行，才不会备库同步线程停止。所以，drop table命令记录binlog的时候，就必须对语句做改写， “/* generated by server */” 说明了这是一个被服务端改写过的命令。\",\"主库上不同的线程创建同名的临时表是没有关系的，但是传到备库执行时如何处理的呢？下面的序列中实例S是M的备库：\",\"主库M上的两个session创建了同名的临时表t1，这两个create temporary table t1语句都会被传到备库S上，但是，备库的应用日志线程是共用的，也就是说要在应用线程里面先后执行这个create语句两次。（即使开了多线程复制，也可能被分配到从库的同一个worker中执行），如果直接执行，那么显然可能会出现冲突。MySQL在记录binlog的时候，会把主库执行的这个语句的线程id写到binlog中，这样，在备库的应用线程就能够知道执行每个语句的主库线程id，并利用这个线程id来构造临时表的table_def_key，具体流程下：\",\"session A的临时表t1，在备库的table_def_key就是：库名+t1+“M的serverid” + “session A的thread_id”\",\"session B的临时表t1，在备库的table_def_key就是：库名+t1+“M的serverid” + “session B的thread_id”\",\"由于table_def_key不同，所以这两个表在备库的应用线程里不会冲突。\"]},\"551\":{\"h\":\"使用临时表优化查询\",\"t\":[\"union的执行就会使用临时表来完成，为了便于量化分析，我用下面的表 t1 来举例。\",\"create table t1( id int primary key, a int, b int, index(a) ); delimiter;; create procedure idata() begin declare i int; set i = 1; while(i <= 1000) do insert into t1 values (i, i, i); set i = i + 1; end while; end;; delimiter; call idata(); \",\"然后，我们执行如下语句：\",\"(select 1000 as f) union (select id from t1 order by id desc limit 2); \",\"这条语句用到了union，它的语义是，取这两个子查询结果的并集，下面是这个语句explain的结果：\",\"可以看到：\",\"第二行的key=PRIMARY，说明第二个子句用到了索引id\",\"第三行的Extra字段，表示在对子查询的结果做UNION的时候，使用了临时表（Using temporary）。\",\"这个语句的执行流程如下：\",\"创建一个内存临时表，这个临时表只有一个整型字段f，并且f是主键字段\",\"执行第一个子查询，得到1000这个值，并存入临时表中\",\"执行第二个子查询： \",\"拿到第一行id=1000，试图插入临时表中，但由于1000这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行\",\"取到第二行id=999，插入临时表成功\",\"从临时表按行取数据，返回结果，并删除临时表，结果中包含两行数据分别是1000和999\",\"这个过程的示意图如下：\",\"可以看到，这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键id的唯一性约束，实现了union的语义。如果将这个语句中的union改成union all的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端，因此也就不需要临时表了。\",\"可以看到，第二行的Extra字段显示的是Using index，表示只使用了覆盖索引，没有用临时表了。\"]},\"552\":{\"h\":\"group by语句的优化\"},\"553\":{\"h\":\"group by执行流程\",\"t\":[\"还是使用表t1执行如下SQL语句：\",\"select id % 10 as m, count(*) as c from t1 group by m; \",\"这个语句的逻辑是把表t1里的数据，按照id%10进行分组统计，并按照m的结果排序后输出，它的explain结果如下：\",\"在Extra字段里面，我们可以看到：\",\"Using index，表示这个语句使用了覆盖索引，选择了索引a，不需要回表\",\"Using temporary，表示使用了临时表\",\"Using filesort，表示需要排序\",\"这个语句的执行流程如下：\",\"创建内存临时表，表里有两个字段m和c，主键是m\",\"扫描表t1的索引a，依次取出叶子节点上id的值，计算id%10的结果，记为x \",\"如果临时表中没有主键为x的行，就插入一条记录（x，1）\",\"如果表中有主键为x的行，就将x这一行的c值加1\",\"遍历完成后，再根据字段m做排序，得到结果集返回给客户端\",\"流程图如下：\",\"其中，虚线框内表示临时表的排序过程：\",\"这条语句的执行结果如下：\",\"如果并不需要对结果进行排序，那么可以在SQL语句末尾增加order by null：\",\"select id % 10 as m, count(*) as c from t1 group by m order by null; \",\"这样就跳过了最后排序的阶段，直接从临时表中取数据返回，返回的结果如图所示：\",\"由于表t1中的id的值是从1开始的，因此返回的结果集中的第一行是id=1，扫描到id=10的时候才插入m=0这一行，因此结果集里最后一行才是m=0。\",\"这个例子中由于临时表只有10行，内存可以放得下，因此全程只使用了内存临时表。但是，内存临时表的大小是有限制的，参数tmp_table_size就是控制这个内存大小的，默认是16M。此时，如果执行如下语句：\",\"set tmp_table_size = 1024; select id % 100 as m, count(*) as c from t1 group by m order by null limit 10; \",\"把内存临时表的大小限制为最大1024字节，并把语句改为id%100，这样返回结果里有100行数据。但是，这时的内存临时表大小不够存下这100行数据，也就是说，执行过程中会发现内存临时表大小不够存下这100行数据，也就是说，执行过程中会发现内存临时表大小达到了上限（1024字节）。这个时候，MySQL就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是InnoDB，这时返回的结果如下：\",\"如果这个表t1的数据量很大，很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间。\"]},\"554\":{\"h\":\"使用索引优化group by语句\",\"t\":[\"可以看到，不论是使用内存临时表还是磁盘临时表，group by逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的，如果表的数据量比较大，上面这个group by语句执行起来就会很慢。\",\"在优化group by问题之前，我们得清楚，为什么执行group by语句需要临时表，group by的语义逻辑是统计不同的值出现的个数，但是，由于每一行的id%100的结果是无序的，所以，我们需要一个临时表，来记录并统计结果。那么，如果扫描过程中可以保证出现的数据是有序的，那么group by语句就可以不再需要临时表，假设有如下数据结构：\",\"可以看到，如果可以确保输入的数据是有序的，那么计算group by的时候，就只需要从左到右，顺序扫描，依次累加，也就是下面的这个过程：\",\"当碰到第一个1的时候，已经知道累积了X个0，结果集里的第一行就是（0，x）\",\"当碰到第一个2的时候，已经知道类及了Y个1，结果集里的第一行就是（1，Y）\",\"按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到group by的结果，不需要临时表，也不需要再额外的排序。在MySQL5.7支持了generated cloumn机制，用来实现列数据的关联更新，可以使用如下方法创建一个列z，然后在z列上创建一个索引（如果是MySQL5.6及之前的版本，可以创建普通列和索引，来解决这个问题）。\",\"alter table t1 add column z int generated always as(id % 100), add index(z); \",\"这样，索引z上的数据就是类似上图中的有序数据了，此时，上面的group by语句就可以改成：\",\"select z, count(*) as c from t1 group by z; \",\"优化后的group by语句的explain结果，如下图所示：\",\"可以看到这个语句的执行不再需要临时表，也不需要排序了。\"]},\"555\":{\"h\":\"直接排序优化group by语句\",\"t\":[\"实际上，并不是所有场景中可以通过加索引来完成group by的逻辑，如果碰到不适合创建索引的场景，还是一定要进行排序的操作。无论数据量大或小的group by语句都要先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表，我们可以在group by语句中加入SQL_BIG_RESULT这个提示（hint），就可以告诉优化器 ，这个语句涉及的数据量很大，直接使用磁盘临时表，MySQL会直接使用数组来存储这些数据，此时\",\"select SQL_BIG_RESULT id % 100 as m, count(*) as c from t1 group by m; \",\"执行流程就变成了：\",\"初始化sort_buffer，确定放入一个整型字段，记为m\",\"扫描表t1的索引a，依次取出里面的id的值，将id%100的值存入sort_buffer中\",\"扫描完成后，对sort_buffer的字段m做排序（如果sort_buffer的内存不够用，就会利用磁盘临时文件辅助排序）\",\"排序完成后，就得到了一个有序数组\",\"根据有序数组，得到数组里面的不同值，以及每个值得出现次数，执行的流程图如下：\",\"explain的结果如下：\",\"从Extra字段可以看到，这个语句的执行没有再使用临时表，而是直接使用了排序算法。\",\"这里我们对MySQL使用内部临时表做如下总结：\",\"如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果\",\"join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构\",\"如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表（之前的例子中，union还需要用到唯一索引约束，group by还需要用到另外一个字段来存累积计数）\"]},\"556\":{\"h\":\"order by rand() 优化\",\"t\":[\"假设有一个英语学习APP，用户每次访问首页的时候，都会随机滚动显示三个单词，也就是根据每个用户级别有一个单词表，假设我们的表结构如下：\",\"CREATE TABLE `words` ( `id` int(11) NOT NULL AUTO_INCREMENT, `word` varchar(64) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = InnoDB; delimiter;; create procedure idata() begin declare i int; set i = 0; while i < 10000 do insert into words(word) values ( concat( char( 97 +(i div 1000) ), char( 97 +(i % 1000 div 100) ), char( 97 +(i % 100 div 10) ), char( 97 +(i % 10) ) ) ); set i = i + 1; end while; end;; delimiter; call idata(); \",\"实现这个需求最简单的实现方式，不难想到：\",\"select word from words order by rand() limit 3; \",\"但是随着单词表的变大，这个语句的执行速度越来越慢，那么该如何优化呢？\"]},\"557\":{\"h\":\"内存临时表\",\"t\":[\"上述SQL的explain的结果如下：\",\"Extra字段显示Using temporary，表示的是需要使用临时表，Using filesort表示的是需要执行排序操作，也就是说这个SQL需要临时表，并且需要在临时表上排序。\",\"对于InnoDB表来说，执行全字段排序会会减少磁盘访问，因此会优先选择全字段排序，而对于临时内存表的排序来说，回表过程只是简单根据数据行的位置，直接访问内存得到数据，并不会导致过多的访问磁盘，因此，MySQL这时会选择rowid排序。\",\"这条语句的执行流程如下：\",\"创建一个临时表，这个临时表使用的是memory引擎，表中有两个字段，第一个字段是double类型，为了后面描述方便，记为字段R，第二个字段是varchar（64）类型，记为字段W，并且，这个表没有建索引\",\"从words表中，按主键顺序取出所有word值，对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并且把这个随机小数和word分别存入临时表的R和W字段中，到此，扫描的行数是10000\",\"接下来按照R排序\",\"初始化sort_buffer，sort_buffer中有两个字段，一个是double类型，另一个是整型\",\"从内存临时表中一行一行地取出R值和位置信息，分别存入sort_buffer中的两个字段里，这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，变成了20000\",\"在sort_buffer中根据R的值进行排序（这个过程没有涉及到表操作，所以不会增加扫描行数）\",\"排序完成后，取出前三个结果的位置信息，依次到临时表中取出word值，返回给客户端，这个过程中，访问了表的三行数据，总扫描行数变成了20003\",\"接下来，我们通过慢查询日志（show log）来验证扫描行数是否是20003：\",\"# Query_time: 0.900376 Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003 SET timestamp=1541402277; select word from words order by rand() limit 3; \",\"其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行。完整的排序的执行流程图如下：\",\"图中的pos指的是位置信息。在InnoDB中，如果创建的表没有主键，获取把一个表的主键删掉了，那么InnoDB会自己生成一个长度为6字节的rowid来作为主键，这也就是排序模式里面，rowid名字的来历，实际上它表示的就是每个引擎用来唯一标识数据行的信息。\",\"对于有主键的InnoDB表来说，这个rowid就是主键ID\",\"对于没有主键的InnoDB表磊说，这个rowid就是由系统生成的\",\"Memory引擎不是索引组织表，这个例子里面，可以认为它就是一个数组，因为rowid其实就是数组的下标\"]},\"558\":{\"h\":\"磁盘临时表\",\"t\":[\"上文我们提到，order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法，那么是不是所有的临时表都是内存表呢？其实并不是，tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。\",\"磁盘临时表使用的引擎默认是InnoDB，是由参数internal_tmp_disk_storage_engine来控制的，因此当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表排序的过程。\",\"为了复现这个过程，我们将tmp_table_size设置成1024，把sort_buffer_size设置成32768，把max_length_for_sort_data设置成16。\",\"set tmp_table_size=1024; set sort_buffer_size=32768; set max_length_for_sort_data=16; /* 打开 optimizer_trace ，只对本线程有效 */ SET optimizer_trace='enabled=on'; /* 执行语句 */ select word from words order by rand() limit 3; /* 查看 OPTIMIZER_TRACE 输出 */ SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\\\\G \",\"因为将max_length_for_sort_data设置成16，小于word字段的长度定义，所以我们看到sort_mode里面显式的是rowid排序，这个是符合预期的，参与排序的是随机值R字段和rowid段组成的行。\",\"R字段存放的随机值是8个字段，rowid是6个字节，数据总行数是10000，加起来是14000字节，超过了sort_buffer_size定义的32768字节，但是这里的number_of_tmp_files的值却是0，这里因为这里MySQL并没有使用归并排序算法，而是采用了优先队列排序算法。实际上，我们只需要取R值最小的3个rowid，但是，如果使用归并排序算法的话，虽然最终也能得到前3个值，但是这个算法会将1000行数据都排好序，然后再取前3条记录，如果使用归并算法就会浪费非常多的计算量。而优先队列算法，就可以精确地只得到三个最小值，执行流程如下：\",\"对于这10000个准备排序的（R，rowid），先取前三行，构造成一个堆\",\"取下一个行（R'，rowid'），跟当前堆里面最大地R比较，如果R'小于R，把这个（R，rowid）从堆中去掉，换成（R'，rowid'）\",\"重复第二步，直到第10000个（R'，rowid'）完成比较\",\"优先队列排序地示意图如下：\",\"图中模拟了6个（R，rowid）行，通过优先队列排序找到最小的三个R值的行的过程。整个排序过程中，为了最快地拿到当前堆的最大值，总是保持最大值在堆顶，因此这是一个最大堆。\",\"OPTIMIZER_TRACE结果中，filesort_priority_queue_optimization这个部分的chosen=true，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的number_of_tmp_files是0。\",\"select city,name,age from t where city=' 杭州 ' order by name limit 1000; \",\"排序的过程结束后，在我们构造的堆里面，就是这个10000行里面R值最小的三行。然后，依次把它们的rowid取出来，去临时表里面拿到word字段，就得到了最终的结果。\"]},\"559\":{\"h\":\"随机排序法\",\"t\":[\"清楚了order by rand（）的执行过程，那么该如何优化呢？\",\"我们先把问题简化以下，如果只随机选择1个word值，可以按照如下思路实现：\",\"取得这个表的主键id最大值M和最小值N\",\"用随机函数生成一个最大值和最小值之间的数X=（M-N）*rand（）+N\",\"取不小于X的第一个ID的行\",\"我们将这个算法暂时称作随机算法1，对应的执行语句的序列：\",\"select max(id),min(id) into @M,@N from t; set @X= floor((@M-@N+1)*rand() + @N); select * from t where id >= @X limit 1; \",\"这个方法的效率很高，因为取max（id）和min（id）都是不需要扫描索引的，而第三步的select也可以用索引快速定位，可以认为就只扫描了3行。但实际上，这个算法并不严格满足题目的随机要求，因为ID中间可能由空洞，因此选择不同行的概率不一样，不是真正的随机。假设4个id分别是1、2、4、5，如果按照这个算法，那么取到id=4的这一行的概率是取到其它行的概率的两倍。\",\"所以，为了得到严格随机的结果，可以按照如下流程：\",\"取得整个表的行数，并记为C\",\"取得Y=floor(C*rand())，floor函数在这里的作用，就是取整数部分\",\"再用limit Y,1取得一行\",\"我们将这个算法暂时称作随机算法2，对应的执行语句的序列：\",\"select count(*) into @C from t; set @Y = floor(@C * rand()); set @sql = concat(\\\"select * from t limit \\\", @Y, \\\",1\\\"); prepare stmt from @sql; execute stmt; DEALLOCATE prepare stmt; \",\"由于limit后面的参数不能直接跟变量，所以这里使用了prepare+execute的方法，实际使用时，可以将拼接SQL语句的方法写在应用程序中。\",\"MySQL处理limit Y,1的做法是按照顺序一个一个地读出来，丢掉前Y个，然后把下一个记录作为返回结果，因此这一步需要扫描Y+1行，再加上，第一个扫描地C行，总共需要扫描C+Y+1行，虽然解决了算法1里明显的概率不均匀的问题，但是执行代价要比随机算法1的代价要高，不过于order by rand（）相比，执行代价还是小很多。\",\"到这里，我们就可以按照随机算法2的思路，优化本篇一开始的语句：\",\"取得整个表的行数，记为C\",\"根据相同的随机方法得到Y1、Y2、Y3\",\"再执行三个limit Y,1语句得到三行数据\",\"完整的执行序列如下：\",\"select count(*) into @C from t; set @Y1 = floor(@C * rand()); set @Y2 = floor(@C * rand()); set @Y3 = floor(@C * rand()); select * from t limit @Y1 ， 1 ； // 在应用代码里面取 Y1 、 Y2 、 Y3 值，拼出 SQL 后执行 select * from t limit @Y2 ， 1 ； select * from t limit @Y3 ， 1 ； \"]},\"560\":{\"h\":\"分区表\",\"t\":[\"在有些公司的数据库规范中，不允许使用分区表，那么分区表有什么问题呢？\"]},\"561\":{\"h\":\"分区表简介\",\"t\":[\"为了说明分区表的组织形式，我们先创建表t：\",\"CREATE TABLE `t` ( `ftime` datetime NOT NULL, `c` int(11) DEFAULT NULL, KEY (`ftime`) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 PARTITION BY RANGE ( YEAR(ftime) ) ( PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB, PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB, PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB, PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB ); insert into t values('2017-4-1',1),('2018-4-1',1); \",\"此时表中有两行记录，按照定义的分区的规则，这两行记录分别落在p_2018和p_2019这两个分区上，可以看到，这个表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件，也就是说：\",\"对于引擎层来说，这是4个表\",\"对于Server层来说，这是1个表\",\"接下来我们通过观察分区表加间隙锁的例子来说明对于InnoDB来说，这是4个表：\",\"我们初始化表t的时候，只插入了两行数据，ftime的值分别是，'2017-4-1'和'2018-4-1'，session A的select语句对索引ftime上这两个记录之间的间隙加了锁。如果是一个普通表的话，那么T1时刻，在表t的ftime索引，间隙和加锁状态应该如下图：\",\"也就是说，'2017-4-1'和'2018-4-1'这两个记录之间的间隙是会被锁住的，那么session B的两条插入语句应该都要进入锁等待状态。但是从上面的实验效果可以看出，session B的第一个insert语句是可以执行成功，因为，对于引擎来说，p_2018和p_2019是两个不同的表，也就是说2017-4-1的下一个记录并不是2018-4-1，而是p_2018分区的supermum，所以在T1时刻，在表t的ftime索引上，间隙和加锁的状态其实是这样的：\",\"由于分区表的规则，session A的select语句其实只操作了分区p_2018，因此加锁范围就是图中深绿色的部分，所以，session B要写入一行ftime是2018-2-1的时候是可以成功的，而要写入2017-12-1这个记录，就要等session A的间隙锁。\",\"此时show engine innodb status的部分结果如下：\",\"接下来我们看看在MyISAM引擎中的情况，首先使用alter table t engine将表t改成MyISAM表，然后执行如下序列：\",\"在session A里面，使用sleep(100)将这条语句的执行时间设置为100秒，由于MyISAM引擎只支持表锁，所以这条update语句会锁住整个表t上的读，但是我们看到的结果是，session B的第一条查询语句是可以正常执行的，第二条语句才进入锁等待状态，这正是因为MyISAM的表锁是在引擎层实现的，session A加的表锁，其实是锁在分区p_2018上。因此，只会堵住在这个分区上执行的查询，落到其它分区的查询时不受影响的。\",\"此时看起来使用分区表并没有什么不妥，通常我们使用分区表的一个重要原因就是单表过大，如果不使用分区表的话，就要使用手动分表的方式，那么手动分表和分区表有什么区别？比如，按照年份来划分，我们就分别创建普通表t_2017、t_2018、t_2019等等。手工分表的逻辑，也是找到需要更新的所有分表，然后依次执行更新，在性能上，这个分区表并没有实质的差别。另外，分区表和手工分表，一个是由server层来决定使用哪个分区，一个是由应用层代码决定使用哪个分表，因此，从引擎层来看，这两种方式也是没有差别的。\",\"实际上，问题的关键在于server层，分区表最重要的问题在于：打开表的行为。\"]},\"562\":{\"h\":\"分区策略\",\"t\":[\"每当第一次访问一个分区表的时候，MySQL需要把所有的分区都访问一遍。一个典型的报错情况是这样的：如果一个分区表的分区很多，比如超过了1000个，而MySQL启动的时候，open_files_limit参数使用的默认值是1024，那么就会在访问这个表的时候，由于需要打开所有的文件，导致打开表文件的个数超过了上限而报错。\",\"下图是创建的一个包含了很多分区的表t_myisam，执行一条插入语句后报错的情况。：\",\"可以看到，这条insert语句，明显只需要访问一个分区，但语句却无法执行。实际上使用InnoDB引擎并不会出现这个问题，MyISAM分区表使用的分区策略，我们称为通用分区策略（generic partitioning），每次访问分区都由server层控制，通用分区策略，是MySQL一开始支持分区表的时候就存在的代码，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题。\",\"从MySQL5.7.9开始，InnoDB引擎引入了本地分区策略（native partitioning），这个策略是在InnoDB内部自己管理打开分区的行为。从MySQL5.7.17开始，将MyISAM分区表标记为Deprecated，从MySQL8.0版本开始，就不允许创建MyISAM分区表了，只允许创建已经实现了本地分区策略的引擎。目前来看，只有InnoDB和NDB这两个引擎支持了本地分区策略。\",\"如果从server层看的话，一个分区表就只是一个表。下面我们通过例子来说明，下面两张图分别是这个例子的操作序列和执行结果图。\",\"可以看到，虽然session B只需要操作p_2017这个分区，但是由于session A持有整个表t的MDL锁，就导致了session B的alter语句被堵住，实际上，分区表在做DDL的时候，影响会更大，但是如果是在普通的分表上操作的时候并不会出现这样的问题。\",\"我们可以对分区表做以下总结：\",\"MySQL在第一次打开分区表的时候，需要访问所有的分区\",\"在server层，认为这是同一张表，因此所有分区共用同一个MDL锁\",\"在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必要的分区\",\"其中“必要的分区”是根据SQL语句中的where条件，结合分区规则来实现的。比如，上面的例子中where ftime='2018-4-1'，根据分区规则year函数算出来的值是2018，那么就会落在p_2019这个分区，但是如果这个where条件改成where ftime>='2018-4-1'，虽然查询结果相同，但是这个时候根据where条件，就要访问p_2019和P_others这两个分区。如果查询语句的where条件中没有分区key，那么就只能访问所有分区了，不过即使是使用业务分表的方式，没有分区的key也需要访问所有的分区表。\"]},\"563\":{\"h\":\"分区表的应用场景\",\"t\":[\"分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区别的业务代码更简洁，另外，分区表可以很方便的清理历史数据。如\",\"如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求，这个时候，按照时间分区的分区表，就可以直接通过alter table t drop partition...这个语法删掉分区，从而删掉过期的历史数据，这个语句的操作时直接删除分区文件，效果跟drop普通表类似，与使用delete语句删除数据相比，优势是速度快、对系统影响小。\",\"分区表在使用的时候，有两个绕不开的问题：一个是第一次访问的时候需要访问所有分区，另一个是共用MDL锁，对于分区表的使用有以下需要注意的点：\",\"分区并不是越细越好，实际上，单表或者单分区的数据一千万行，只要没有也别大的索引，对于现在的硬件能力来说都已经是小表了\",\"分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时再把下一年度的12个新分区创建上即可，对于没有数据的历史分区，要及时drop掉\",\"至于分区表的其它问题，比如查询需要跨多个分区取数据，查询性能就会比较慢，基本上就不是分区表本身的问题，而是数据量的问题或者说时使用方式的问题了。\"]},\"564\":{\"h\":\"慢查询日志\"},\"565\":{\"h\":\"基本介绍\",\"t\":[\"慢查询日志是什么？\",\"MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。\",\"long_query_time的默认值为10，意思是运行10秒以上的语句。\",\"由慢查询日志来查看哪些SQL超出了我们的最大忍耐时间值，比如一条SQL执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒钟的SQL，结合之前explain进行全面分析。\",\"特别说明\",\"**默认情况下，MySQL数据库没有开启慢查询日志，**需要我们手动来设置这个参数。\",\"当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。\",\"查看慢查询日志是否开以及如何开启\",\"查看慢查询日志是否开启：SHOW VARIABLES LIKE '%slow_query_log%';。\",\"开启慢查询日志：SET GLOBAL slow_query_log = 1;。使用该方法开启MySQL的慢查询日志只对当前数据库生效，如果MySQL重启后会失效。\",\"# 1、查看慢查询日志是否开启 mysql> SHOW VARIABLES LIKE '%slow_query_log%'; +---------------------+--------------------------------------+ | Variable_name | Value | +---------------------+--------------------------------------+ | slow_query_log | OFF | | slow_query_log_file | /var/lib/mysql/1dcb5644392c-slow.log | +---------------------+--------------------------------------+ 2 rows in set (0.01 sec) # 2、开启慢查询日志 mysql> SET GLOBAL slow_query_log = 1; Query OK, 0 rows affected (0.00 sec) \",\"如果要使慢查询日志永久开启，需要修改my.cnf文件，在[mysqld]下增加修改参数。\",\"# my.cnf [mysqld] # 1.这个是开启慢查询。注意ON需要大写 slow_query_log=ON # 2.这个是存储慢查询的日志文件。这个文件不存在的话，需要自己创建 slow_query_log_file=/var/lib/mysql/slow.log \",\"开启了慢查询日志后，什么样的SQL才会被记录到慢查询日志里面呢？\",\"这个是由参数long_query_time控制的，默认情况下long_query_time的值为10秒。\",\"MySQL中查看long_query_time的时间：SHOW VARIABLES LIKE 'long_query_time%';。\",\"# 查看long_query_time 默认是10秒 # 只有SQL的执行时间>10才会被记录 mysql> SHOW VARIABLES LIKE 'long_query_time%'; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | long_query_time | 10.000000 | +-----------------+-----------+ 1 row in set (0.00 sec) \",\"修改long_query_time的时间，需要在my.cnf修改配置文件\",\"[mysqld] # 这个是设置慢查询的时间，我设置的为1秒 long_query_time=1 \",\"查新慢查询日志的总记录条数：SHOW GLOBAL STATUS LIKE '%Slow_queries%';。\",\"mysql> SHOW GLOBAL STATUS LIKE '%Slow_queries%'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | Slow_queries | 3 | +---------------+-------+ 1 row in set (0.00 sec) \"]},\"566\":{\"h\":\"日志分析工具\",\"t\":[\"日志分析工具mysqldumpslow：在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。\",\"# 1、mysqldumpslow --help 来查看mysqldumpslow的帮助信息 root@1dcb5644392c:/usr/bin# mysqldumpslow --help Usage: mysqldumpslow [ OPTS... ] [ LOGS... ] Parse and summarize the MySQL slow query log. Options are --verbose verbose --debug debug --help write this text to standard output -v verbose -d debug -s ORDER what to sort by (al, at, ar, c, l, r, t), 'at' is default # 按照何种方式排序 al: average lock time # 平均锁定时间 ar: average rows sent # 平均返回记录数 at: average query time # 平均查询时间 c: count # 访问次数 l: lock time # 锁定时间 r: rows sent # 返回记录 t: query time # 查询时间 -r reverse the sort order (largest last instead of first) -t NUM just show the top n queries # 返回前面多少条记录 -a don't abstract all numbers to N and strings to 'S' -n NUM abstract numbers with at least n digits within names -g PATTERN grep: only consider stmts that include this string -h HOSTNAME hostname of db server for *-slow.log filename (can be wildcard), default is '*', i.e. match all -i NAME name of server instance (if using mysql.server startup script) -l don't subtract lock time from total time # 2、 案例 # 2.1、得到返回记录集最多的10个SQL mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log # 2.2、得到访问次数最多的10个SQL mysqldumpslow -s c -t 10 /var/lib/mysql/slow.log # 2.3、得到按照时间排序的前10条里面含有左连接的查询语句 mysqldumpslow -s t -t 10 -g \\\"left join\\\" /var/lib/mysql/slow.log # 2.4、另外建议使用这些命令时结合|和more使用，否则出现爆屏的情况 mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log | more \"]},\"567\":{\"h\":\"分析慢SQL的步骤\",\"t\":[\"分析：\",\"1、观察，至少跑1天，看看生产的慢SQL情况。\",\"2、开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来。\",\"3、explain + 慢SQL分析。\",\"4、show Profile。\",\"5、运维经理 OR DBA，进行MySQL数据库服务器的参数调优。\",\"总结（大纲）：\",\"1、慢查询的开启并捕获。\",\"2、explain + 慢SQL分析。\",\"3、show Profile查询SQL在MySQL数据库中的执行细节和生命周期情况。\",\"4、MySQL数据库服务器的参数调优。\"]},\"568\":{\"h\":\"Show Profile\",\"t\":[\"Show Profile是什么？\",\"Show Profile：MySQL提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量。默认情况下，参数处于关闭状态，并保存最近15次的运行结果。\",\"分析步骤\",\"1、是否支持，看看当前的MySQL版本是否支持。\",\"# 查看Show Profile功能是否开启 mysql> SHOW VARIABLES LIKE 'profiling'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | profiling | OFF | +---------------+-------+ 1 row in set (0.00 sec) \",\"2、开启Show Profile功能，默认是关闭的，使用前需要开启。\",\"# 开启Show Profile功能 mysql> SET profiling=ON; Query OK, 0 rows affected, 1 warning (0.00 sec) \",\"3、运行SQL\",\"SELECT * FROM `emp` GROUP BY `id`%10 LIMIT 150000; SELECT * FROM `emp` GROUP BY `id`%20 ORDER BY 5; \",\"4、查看结果，执行SHOW PROFILES;\",\"Duration：持续时间。\",\"mysql> SHOW PROFILES; +----------+------------+---------------------------------------------------+ | Query_ID | Duration | Query | +----------+------------+---------------------------------------------------+ | 1 | 0.00156100 | SHOW VARIABLES LIKE 'profiling' | | 2 | 0.56296725 | SELECT * FROM `emp` GROUP BY `id`%10 LIMIT 150000 | | 3 | 0.52105825 | SELECT * FROM `emp` GROUP BY `id`%10 LIMIT 150000 | | 4 | 0.51279775 | SELECT * FROM `emp` GROUP BY `id`%20 ORDER BY 5 | +----------+------------+---------------------------------------------------+ 4 rows in set, 1 warning (0.00 sec) \",\"5、诊断SQL，SHOW PROFILE cpu,block io FOR QUERY Query_ID;\",\"# 这里的3是第四步中的Query_ID。 # 可以在SHOW PROFILE中看到一条SQL中完整的生命周期。 mysql> SHOW PROFILE cpu,block io FOR QUERY 3; +----------------------+----------+----------+------------+--------------+---------------+ | Status | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out | +----------------------+----------+----------+------------+--------------+---------------+ | starting | 0.000097 | 0.000090 | 0.000002 | 0 | 0 | | checking permissions | 0.000010 | 0.000009 | 0.000000 | 0 | 0 | | Opening tables | 0.000039 | 0.000058 | 0.000000 | 0 | 0 | | init | 0.000046 | 0.000046 | 0.000000 | 0 | 0 | | System lock | 0.000011 | 0.000000 | 0.000000 | 0 | 0 | | optimizing | 0.000005 | 0.000000 | 0.000000 | 0 | 0 | | statistics | 0.000023 | 0.000037 | 0.000000 | 0 | 0 | | preparing | 0.000014 | 0.000000 | 0.000000 | 0 | 0 | | Creating tmp table | 0.000041 | 0.000053 | 0.000000 | 0 | 0 | | Sorting result | 0.000005 | 0.000000 | 0.000000 | 0 | 0 | | executing | 0.000003 | 0.000000 | 0.000000 | 0 | 0 | | Sending data | 0.520620 | 0.516267 | 0.000000 | 0 | 0 | | Creating sort index | 0.000060 | 0.000051 | 0.000000 | 0 | 0 | | end | 0.000006 | 0.000000 | 0.000000 | 0 | 0 | | query end | 0.000011 | 0.000000 | 0.000000 | 0 | 0 | | removing tmp table | 0.000006 | 0.000000 | 0.000000 | 0 | 0 | | query end | 0.000004 | 0.000000 | 0.000000 | 0 | 0 | | closing tables | 0.000009 | 0.000000 | 0.000000 | 0 | 0 | | freeing items | 0.000032 | 0.000064 | 0.000000 | 0 | 0 | | cleaning up | 0.000019 | 0.000000 | 0.000000 | 0 | 0 | +----------------------+----------+----------+------------+--------------+---------------+ 20 rows in set, 1 warning (0.00 sec) \",\"Show Profile查询参数备注：\",\"ALL：显示所有的开销信息。\",\"BLOCK IO：显示块IO相关开销（通用）。\",\"CONTEXT SWITCHES：上下文切换相关开销。\",\"CPU：显示CPU相关开销信息（通用）。\",\"IPC：显示发送和接收相关开销信息。\",\"MEMORY：显示内存相关开销信息。\",\"PAGE FAULTS：显示页面错误相关开销信息。\",\"SOURCE：显示和Source_function。\",\"SWAPS：显示交换次数相关开销的信息。\",\"6、Show Profile查询列表，日常开发需要注意的结论：\",\"converting HEAP to MyISAM：查询结果太大，内存都不够用了，往磁盘上搬了。\",\"Creating tmp table：创建临时表（拷贝数据到临时表，用完再删除），非常耗费数据库性能。\",\"Copying to tmp table on disk：把内存中的临时表复制到磁盘，危险！！！\",\"locked：死锁。\"]},\"569\":{\"h\":\"事务隔离\",\"t\":[\"简单来说，事务就是要保证一组操作，要么全部成功，要么全部失败，事务具有ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）的特性。在MySQL中，事务支持是在引擎层实现的，但并不是所有的引擎都支持事务，比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。\"]},\"570\":{\"h\":\"隔离性和隔离级别\",\"t\":[\"当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。隔离级别越高，执行的效率就会越低，因此很多时候，都需要在二者之间寻找一个平衡点。\",\"SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable），它们的含义如下：\",\"读未提交是指，一个事务还没有提交时，它做的变更就能被别的事务看到\",\"读提交是指，一个事务提交之后，它做的变更才会被其它事务看到\",\"可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动的时候看到的数据是一致的。在可重复读的隔离级别下，未提交变更对其它事务也是不可见的\",\"串行化是指对同一行记录，“写”会加锁，“读”会“读锁”。当出现读写锁冲突的时候，后访问的事务必须等待前一个事务执行完成，才能继续执行\",\"下面我们通过实例来说明，假设数据表T中只有一列，其中一行的值为1：\",\"create table T(c int) engine = InnoDB; insert into T(c) values (1); \",\"下面是按照时间顺序执行两个事务的行为：\",\"我们来看下在不同的隔离级别下，事务A会查询到的V1、V2、V3的返回值分别是什么：\",\"若隔离级别是“读未提交”，则V1、V2、V3的值都是2。这时候事务B虽然还没有提交，但是结果已经被A看到了\",\"若隔离级别是“读提交”，则V1是1，V2的值是2，事务B的更新在提交后才能被A看到，所以V3的值也是2\",\"若隔离级别是“可重复读”，则V1、V2是1，V3是2，之所以V2还是1，是因为在这个隔离级别下，事务在执行期间看到的数据前后必须是一致的\",\"若隔离级别是“串行化”，则事务B执行“将1改成2”的时候，会被锁住，直到事务A提交之后，事务B才可以继续执行。所以，从A的角度来看，V1、V2的值是1，V3的值是2\",\"在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的，这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。\",\"在不同的隔离级别下，数据库的行为是有所不同的。Oracle数据库的默认隔离级别是“读提交”，MySQL的InnoDB默认隔离级别是“可重复读”。因此，对于一些从Oracle迁移到MySQL的应用，为了保证数据库隔离级别的一致，需要将隔离级别设置为“读提交”，将启动参数transaction-isolation的值设置为READ-COMMITTED，可以使用show variables like 'transaction_isolation';来查看当前的值。\",\"每一种隔离级别都有自己的使用场景，具体使用哪一种，需要根据业务情况来定。\"]},\"571\":{\"h\":\"事务隔离的实现\",\"t\":[\"那么事务隔离是怎么实现的呢？实际上，在MySQL中，每条记录在更新的时候都会同时记录一条回滚操作，记录上最新的值，通过回滚操作，都可以得到前一个状态的值。假设一个值从1被顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录：\",\"当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A要得到1，就必须将当前的值依次执行图中所有的回滚操作得到。\",\"回滚日志只有当没有事务需要用到这些回滚日志，也就是当系统里没有比这个回滚日志更早的read-view的时候，才会被删除，这也就是很多文章中建议不要使用长事务的原因之一。长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以在这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。在MySQL5.5及以前的版本，回滚日志是跟字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小，也许数据只有20GB，但是回滚段却有200GB。\",\"可以在information_schema库的innodb_trx这个表中，使用如下语句查询超过60s的长事务：\",\"select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started)) > 60; \"]},\"572\":{\"h\":\"事务的启动方式\",\"t\":[\"MySQL的事务启动方式有以下几种：\",\"显式启动事务语句：begin或start transaction;。配套的提交语句是commit，回滚语句是rollback\",\"set autocommit = 0;，这个命令会将这个线程的自动提交关掉，意味着如果只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务将持续存在直到主动执行commit或rollback语句，或者断开连接\",\"有些客户端框架会默认连接成功后先执行set autocommit = 0;，这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。因此，最好使用set autocommit = 1，通过显式语句的方式来启动事务，不过这样需要每次执行依次“begin”，如果不想每次都多“多一次交互”，那么可以使用commit work and chain语法。在autocommit为1的情况下，用begin显式启动事务，如果执行commit则提交事务，如果执行mmit work and chain，则是提交事务并自动启动下一个事务，这样既省去了再次执行begin语句的开销，又可以明确地直到每个语句是否处于事务中。\"]},\"573\":{\"h\":\"全局锁\",\"t\":[\"数据库锁的设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则，而锁就是用来实现这些访问规则的重要数据结构。根据加锁的范围，MySQL里面的锁大致可以分为全局锁、表级锁和行锁三类。\"]},\"574\":{\"h\":\"全局锁的特点\",\"t\":[\"顾名思义，全局锁就是对整个数据库实例加锁，MySQL提供了一个全局读锁的方法：Flush tables with read lock(FTWRL)。当需要让整个库处于只读状态的时候，可以使用这个命令，之后其它线程的更新（增删改）、数据定义语句（建表、修改表结构）和更新类事务的提交语句都会被阻塞。\",\"全局锁的典型使用场景是，做全库逻辑备份，也就是将整库的每个表都select出来存成文本。\"]},\"575\":{\"h\":\"全局锁对比\",\"t\":[\"MySQL自带的逻辑备份工具是mysqldump，当mysqldump使用参数-single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图，由于MVCC的支持，这个过程中数据是可以正常更新的。但并不是所有的存储引擎都支持一致性读的隔离级别，例如MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是取到最新的数据，那么就破坏了备份的一致性，这个时候，就只能使用FTWRL命令了，因此-single-transaction只适用于所有的表使用事务引擎的数据库，如果有的表使用了不支持事务的引擎，那么备份只能通过FTWRL方法，这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一。\",\"全库只读除了使用FTWRL，还可以使用set global readonly = true，不过如果要备份全库，还是应该使用FTWRL，原因有二：\",\"在有些系统中，readonly的值会被用来做其它逻辑，比如用来判断一个库是主库还是备库，因此，修改global变量的方式影响面更大\",\"在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一致保持readonly状态，这样会导致整库长时间处于不可写状态，风险较高\"]},\"576\":{\"h\":\"表级别的锁\",\"t\":[\"MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，简称MDL）。\"]},\"577\":{\"h\":\"表锁\",\"t\":[\"表锁的语法是lock tables ... read/write。与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意的是，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。\"]},\"578\":{\"h\":\"元数据锁\",\"t\":[\"另一类表级的锁是MDL（metadata lock）。MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。例如，一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构在做变更，删了一列，那么查询线程拿到的结果就与表结构对应不上了，这种情况就需要MDL。在MySQL5.5版本中引入了MDL，当对一个表做增删改查操作的时候，就会加上MDL读锁；当要对表结构做变更操作的时候，就会加上MDL写锁。\",\"读锁之间不互斥，因此可以有多个线程同时对一张表增删改查\",\"读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行\",\"给一个表加字段或者修改字段、添加索引，都需要扫描全表的数据，因此，操作不慎的话，就可能导致生产事故：\",\"session A先启动，这时候会对表t加上一个MDL读锁，由于session B需要的也是MDL读锁，因此可以正常执行。之后session C会被blocked，因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。之后所有在表上新申请MDL读锁的请求也会被session C阻塞，也就是说，所有对表的增删改查都需要先申请MDL读锁，都被锁住导致表完全不可读写。如果这个表上的查询语句频繁，而且客户端有重试机制，也就是超时后会再起一个新的session 再请求的话，这个库的线程很快就会爆满。\",\"事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。在给小表加字段的时候，首先要解决的是长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema库的innodb_trx表中，可以查询到当前执行中的事务，如果要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。但如果要变更的表是一个热点表，虽然数据量不大，但是请求很频繁，这个时候只kill掉可能未必管用了，因为新的请求马上就会到。\",\"因此，给小表添加字段比较合理的方案是，在alter table语句里面设定等待时间，如果在这个执行的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃，之后开发人员或者DBA再通过重试命令重复这个过程。MairaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAIT n这个语法。\",\"ALTER TABLE tbl_name NOWAIT add column ... ALTER TABLE tbl_name WAIT N add column ... \"]},\"579\":{\"h\":\"行锁\",\"t\":[\"行锁顾名思义，就是针对数据表中行记录的锁，比如事务A更新了一行，而这个时候，事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。在MySQL中有四种类型的行锁：\",\"LOCK_ORDINARY：也称为Next-Key Lock，锁一条记录及其间隙，这是RR隔离级别用的最多的锁\",\"LOCK_GAP：间隙锁，锁两个记录之间的GAP，防止记录插入\",\"LOCK_REC_NOT_GAP：只锁记录\",\"LOCK_INSERT_INTENSION：插入意向GAP锁，插入记录时使用，是LOCK_GAP的一种特例\"]},\"580\":{\"h\":\"两阶段锁\",\"t\":[\"为了更好的说明行锁，我们以下面的操作序列为例，假设id是表t的主键：\",\"这个例子中事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行，在这个过程中，事务A持有两个记录的行锁，都是在commit的时候才释放的，也就是说，在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放，这就是两阶段锁协议。基于这个协议，我们在使用事务的时候，如果事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁尽量完后放，接下来我们通过一个实例来说明这一点。\",\"假设要实现一个电影票在线交易业务，顾客A要在影院B购买电影票，这个业务需要涉及以下的操作：\",\"从顾客A账余额中扣除电影票价\",\"给影院B的账户余额增加这张电影票价\",\"记录一条交易日志\",\"也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录，为了保证交易的原子性，我们需要把这三个操作放在一个事务中。假设此时同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了，因为它们要更新同一个影院账户的余额，需要修改同一行数据。根据两阶段锁协议，无论怎样安排语句顺序，所有的操作需要行锁的都是在事务提交的时候才会释放，所以，应该把需要行锁的语句放在最后，这样可以最大程度减少事务之间的锁等待，提升并发度。\"]},\"581\":{\"h\":\"死锁和死锁检测\",\"t\":[\"当并发系统中不同线程出现循环资源以来，设计的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。\",\"这时候，事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：\",\"一种策略是，直接进入等待，直到超时，这个超时时间可以通过参数innodb_lock_wait_timeout来设置\",\"另一种策略是。发起死锁检测，发现死锁后，主动回滚锁链条的某一个事务，让其它事务得以继续执行，可以通过参数innodb_deadlock_detect=on来控制，默认开启\",\"在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其它线程才有可能继续执行。这对于在线服务来说，这个等待时间往往是无法接受的。但是，将这个时间的值设置的很小也不行，这样当出现死锁的时候，确实很快就可以解开，但是如果不是死锁，只是简单的锁等待也会释放，也会释放掉。所以，一般都会选择第二种策略，即主动死锁检测。\",\"主动死锁检测在发生死锁的时候，虽然能够快速发现并进行处理的，但是它也有额外的负担，每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。\",\"当所有事务都要更新同一行的场景时，每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O（n）的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作的时间复杂度就是百万量级的，虽然最终检测的结果是没有死锁，但是检测期间要消耗大量的CPU资源，因此，当并发量很大的时候，就会看到CPU利用率很高，但是每秒却执行不了几个事务。\",\"总而言之，死锁检测要耗费大量的CPU资源。那么，该如何解决由这种热点行更新导致的性能的问题呢？\",\"一种方法是，确保业务一定不会出现死锁，然后关掉死锁检测，但是这种操作本身带有一定的风险，因此业务设计的时候一般不会把死锁当做一个严重错误，一旦出现死锁，就可能会出现大量的超时\",\"另一种方法是控制并发度，根据上面的分析，死锁检测的时间复杂度与并发量正相关，如果可以控制并发量，那么就可以控制死锁检测的时间复杂度。需要注意的是，这个并发控制要做在数据库服务端，因为虽然每个客户端的并发量可能很小，但是汇总到数据库服务端以后，还是会很大。可以在中间件中实现，也可以在MySQL里面做（基本思路：对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作了）。\",\"最后一种方法是，可以考虑通过将一行改成逻辑上的多行来减少锁冲突。以影院的账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加，这样每次冲突概率变成原来的1/10，可以减少锁等待的个数，也减少了死锁检测的CPU消耗，需要注意的是，当一部分行记录变成0的时候，如果还要减少记录的值，需要特殊处理\"]},\"582\":{\"h\":\"间隙锁\"},\"583\":{\"h\":\"幻读\",\"t\":[\"为了说明幻读，我们初始化如下数据：\",\"CREATE TABLE `t` ( `id` INT (11) NOT NULL, `c` INT (11) DEFAULT NULL, `d` INT (11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`) ) ENGINE = INNODB; INSERT INTO t VALUES (0, 0, 0), (5, 5, 5), (10, 10, 10), (15, 15, 15), (20, 20, 20), (25, 25, 25); \",\"假设执行的场景序列如下：\",\"可以看到，session A里执行了三次查询，分别是Q1、Q2和Q3，具体的执行结果如下：\",\"Q1只返回id=5这一行\",\"在T2时刻，session B把id=0这一行的d值改成了5，因此T3时刻Q2查出来的是id=0和id=5这两行\",\"在T4时刻，session C又插入一行（1,1,5），因此T5时刻Q3查出来的是id=0、id=1和id=5的这三行\",\"其中，Q3读到id=1这一行的现象，被称为“幻读”。也就是说，幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行，关于幻读的两点说明：\",\"在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现\",\"上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读，幻读专指“新插入的行”\",\"因为这三个查询都是加了for update，都是当前读。而当前读的规则，就是要能读到所有已经提交的记录的最新值，并且，session B和session C两条语句，执行后就会提交，所以Q2和Q3就是应该看到这两个事务的操作效果，而且也看到了，这跟事务的可见性规则并不矛盾。\"]},\"584\":{\"h\":\"幻读的问题\",\"t\":[\"幻读会带来一些问题，假设时序图如下：\",\"session B的第二条语句update t set c = 5 where id = 0，语义是把id=0、d=5这一行的c的值，改成了5。由于在T1时刻，session A还只是给id=5这一行加了行锁，并没有给id=0这行加上锁。因此，session B在T2时刻，是可以执行这两条update语句的，这样，就破坏了session A里Q1语句要锁住所有d=5的行的加锁声明。session C也是相同的道理，对id=1这一行的修改，也是破坏了Q1的加锁声明。\",\"其次，还有数据一致性的问题，我们直到，锁的设计是为了保证数据的一致性，而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。为了说明这个问题，给session A在T1时刻再加上一个更新语句，即：update t set d = 100 where d = 5;，此时的序列图如下：\",\"update加锁的语义和select ... for update是一致的，所以这时候加上这条update语句也很合理。session A声明说“要给d=5的语句加上锁”，就是为了要更新数据，新加的这条update语句就是把它认为加上了锁的这一行的d的值修改成了100。\",\"执行完图中的语句之后，数据库中的情况：\",\"经过T1时刻，id=5这一行变成（5，5，100），当然这个结果最终是在T6时刻正式提交的\",\"经过T2时刻，id=0这一行变成（0，5，5）\",\"经过T4时刻，表里面多了一行（1，5，5）\",\"其它行跟这个执行序列无关，保持不变\",\"这样看起来，数据本身是没有问题的，binlog的内容如下：\",\"T2时刻，session B事务提交，写入了两条语句\",\"T4时刻，session C事务提交，写入了两条语句\",\"T6时刻，session A事务提交，写入了update t set d=100 where d=5这条语句\",\"汇总后如下：\",\"update t set d=5 where id=0; /*(0,0,5)*/ update t set c=5 where id=0; /*(0,5,5)*/ insert into t values(1,1,5); /*(1,1,5)*/ update t set c=5 where id=1; /*(1,5,5)*/ update t set d=100 where d=5;/* 所有 d=5 的行， d 改成 100*/ \",\"这个语句序列，不论是拿到备库去执行，还是以后用binlog克隆，这三行的结果，都变成了（0，5，100）、（1，5，100）和（5，5，100）。也就是说，id=0和id=1这两行，发生了数据不一致，经过分析不难发现，我们只给d=5这一行加了锁，假设我们给扫描过程中碰到的所有行都加上写锁，再观察执行效果：\",\"由于session A把所有的行都加上了写锁，所在session B在执行第一个update语句的时候就被锁住了，需要等到T6时刻session A提交以后，session B才能继续执行，这样对于id=0这一行，在数据库里的最终结果还是（0，5，5）。在binlog里面，执行的序列如下：\",\"insert into t values(1,1,5); /*(1,1,5)*/ update t set c=5 where id=1; /*(1,5,5)*/ update t set d=100 where d=5;/* 所有 d=5 的行， d 改成 100*/ update t set d=5 where id=0; /*(0,0,5)*/ update t set c=5 where id=0; /*(0,5,5)*/ \",\"可以看到，按照日志顺序执行，id=0这一行的最终结果也是（0，5，5）。所以，id=0这一行的问题解决了，但同时，id=1这一行，在数据库里面的结果是（1，5，5），而根据binlog的执行结果是（1，5，100），也就是说幻读的问题还是没有解决，那么为什么我们将所有的记录都已经上了锁，还是阻止不了id=1这一行的插入和更新呢？因为在T3时刻，我们在给所有行加锁的时候，id=1这一行还不存在，不存在也就加不上锁，也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录。\"]},\"585\":{\"h\":\"间隙锁\",\"t\":[\"产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此为了解决幻读问题，InnoDB引入了间隙锁（Gap Lock）来解决。顾名思义，间隙锁，锁的就是两个值之间的空隙，比如本节中的表t，初始化插入6个记录，就产生了7个间隙。\",\"这样。在执行select * from t where d = 5 for update;的时候，就不止是给数据库已有的6个记录加上了行锁，还同时加了7个间隙锁，这样就确保了无法再插入新的记录，也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空袭，也加上了间隙锁。\",\"虽然间隙锁也是一种锁，但是它和之前介绍过的锁都不太一样，它是加载数据行之间间隙上的，行锁的之间的冲突关系是“另外一个行锁”，但间隙锁不一样，跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作，间隙锁之间不存在冲突关系。\",\"这里的session B并不会被阻塞，因为表t中没有c=7这个记录，因此session A加的是间隙锁（5，10），而session B也是再这个间隙加的间隙锁，它们有共同的目标，即：保护这个间隙，不允许插入值，但，它们之间是不冲突的。\",\"间隙锁和行锁合称next-key lock，每个next-key lock是前后闭区间。也就是说，我们的表t初始以后，如果用select * from for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是(-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20,25]、(25,+supremum]。InnoDB给每个索引加上了一个不存在得最大值supremum，这样就都是前开后闭区间了。\"]},\"586\":{\"h\":\"防止数据丢失\"},\"587\":{\"h\":\"bin log的写入机制\",\"t\":[\"binlog的吸入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写入到binlog文件中。一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到binlog cache的保存问题，系统给binlog cache分配了一片内存，每个线程一个，参数binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。状态图如下：\",\"可以看到，每个线程有自己binlog cache，但是共用同一份binlog文件。\",\"图中的write，指的就是把日志写入到文件系统的page cache，并没有数据持久化到磁盘，所以速度比较快\",\"图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的IOPS\",\"write和fsync的时机，是由参数sync_binlog控制的：\",\"sync_binlog=0的时候，表示每次提交事务都只write，不fsync\",\"sync_binlog=1的时候，表示每次提交事务都会执行fsync\",\"sync_binlog=N（N>1）的时候，表示每次提交事务都write，但累积N个事务才fsync\",\"因此，在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N的事务的binlog日志。\"]},\"588\":{\"h\":\"redo log的写入机制\",\"t\":[\"事务在执行过程中，生成的redo log会先写入到redo log buffer中，并且并不是每次生成后都会持久化到磁盘中。这意味着如果事务执行期间MySQL发生异常重启，那么这部分日志就丢失了，由于事务没有提交，所以这时日志丢了也不会有损失，那么事务还没有提交的时候，redo log buffer中的部分日志有没有可能被持久化到磁盘呢？这就和redo log的三种状态有关：\",\"这三种状态分别是：\",\"存在redo log buffer中，物理上是在MySQL进程内存中，就是图中红色的部分\",\"写到磁盘（write），但是没有持久化（fsync），物理上是在文件系统的page cache里面，也就是图中的黄色部分\",\"持久化到磁盘，对应的是hard disk，也就是图中绿色部分\",\"日志写入到redo log buffer是很快的，write到page cache也差不多，但是持久化到磁盘的速度就慢多了。为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种可能取值：\",\"设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中\",\"设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘\",\"设置为2的时候，表示每次事务提交时都只是把redo log写入到page cache\",\"InnoDB有一个后台线程，每个1秒，就会把redo log buffer中的日志，调用write写入到文件系统的page cache，然后调用fsync持久化到磁盘。\",\"事务执行中间过程中的redo log也就是直接写在redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的redo log，也是可能持久化到磁盘的。\",\"实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中：\",\"一种是，redo log buffer占用的空间即将达到innodb_log_buffer_size一半的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘的动作只是write，而没有调用fsync，也就是只留在了文件系统的page cache\",\"并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。假设一个事务A执行到一半，已经写了一些redo log到buffer中，这个时候另外一个线程的事务B提交，如果innodb_flush_log_at_trx_commit设置的是1，那么按照这个参数的逻辑，事务B要把redo log buffer里的日志全部持久化到磁盘。这时候，就会带上事务A在redo log buffer中的日志一起持久化到磁盘。\",\"如果把innodb_flush_log_at_trx_commit设置成1，那么redo log在prepaer阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于prepare的redo log，再加上binlog来恢复的。每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到文件系统的page cache中就够了。\",\"通常我们说的MySQL的“双1”配置，指的就是sync_binlog和innodb_flush_log_at_trx_commit都设置成1，也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare阶段），一次是binlog。\",\"MySQL的TPS会高于磁盘的TPS，这是因为MySQL中使用了组提交（group commit）的机制，而要了解组提交首先要了解日志逻辑序列号（log sequence number，LSN）。LSN是单调递增的，用来对应redo log的一个个写入点，每次写入长度为length的redo log，LSN的值就会加上length，LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。\",\"下图表示的是，三个并发事务（trx1，trx2，trx3）在prepare阶段，都写完redo log buffer，持久化到磁盘的过程，对应的LSN分别是50、120和160。\",\"从图中可以看到：\",\"trx1是第一个到达得，会被选为这组的leader\",\"等trx1要开始写盘的时候，这个组里面已经有了三个事务，这时候LSN也变成了160\",\"trx1去写盘的时候，带的就是LSN=160，因此等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化磁盘\",\"这时候trx2和trx3就可以直接返回了\",\"所以，一次组提交里面，组员越多，节约磁盘IOPS效果越好，但如果只有单线程压测，那么就是一个事务对应一次持久化操作了。在并发场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能越多，节约IOPS的效果就越好，为了让一次fsync带的组员更多，MySQL还有另一个优化：拖时间。两阶段提交的示意图如下：\",\"其实，写binlog其实是分成两步的：\",\"先把binlog从binlog cache中写到磁盘上的binlog文件\",\"调用fsync持久化\",\"MySQL为了让组提交的效果更好，把redo log做fsync的时间拖到了步骤1之后。也就是说，上面的图变成了这样：\",\"这么以来，binlog也可以组提交了。在执行图5中第4步把binlog fsync到磁盘时，如果有多个事务的binlog已经写完了，也是一起持久化的，这样也可以减少IOPS的消耗。\",\"不过通常情况下第3步执行得会很快，所以binlog得write和fsync间的间隔时间端，导致能集合到一起持久化的binlog比较少，因此，binlog的组提交的效果通常不如redo log的效果那么好，如果想提升binlog组提交的效果，可以通过设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count来实现。\",\"binlog_group_commit_sync_delay表示延迟多少微妙后才调用fsync\",\"binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync\",\"这两个条件是或的关系，也就是说只要有一个满足条件就会调用fsync，所以，当binlog_group_commit_sync_delay设置为0的时候，binlog_group_commit_sync_no_delay_count也无效了。\",\"综上所述，如果MySQL出现了性能瓶颈，而且瓶颈在IO上，可以通过哪些方法来提升性能呢？\",\"设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险\",\"将sync_binlog设置为大于1的值（比较常见的是100~1000）。这样做的风险是，主机掉电时会丢binlog日志\",\"将innodb_flush_log_at_trx_commit设置为2，这样做的风险时，主机掉电的时候会丢数据\",\"不过将innodb_flush_log_at_trx_commit设置成0，当MySQL本身异常重启的话，就会丢失数据。而redo log写到文件系统的page cache的速度也是很快的，所以将这个参数设置成2跟设置0的性能相差并不多，但是设置成2，当MySQL异常重启后就不会丢失数据了。\"]},\"589\":{\"h\":\"主备一致\"},\"590\":{\"h\":\"主备的基本原理\",\"t\":[\"下图表示的是基本主备切换流程：\",\"在状态1中，客户端的读写都直接访问节点A，而节点B是A的备库，只是将A的更新都同步过来，到本地执行，这样可以保持节点B和A的数据是相同的。当需要切换的时候，就切成状态2，这时候客户端读写访问的都是节点B，而节点A是B的备库。\",\"在状态1中，虽然节点B并没有被直接访问，但是依然建议将节点B（也就是备库）设置成只读（readonly）模式，这样做，有以下考虑：\",\"有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作\",\"防止切换逻辑有bug，比如切换过程中出现双写，造成主备不一致\",\"可以用readonly状态，来判断节点的角色\",\"备库虽然设置了readonly，但readonly对超级（super）权限用户是无效的，而用于同步更新的线程，就拥有超级线程，因此，备库可以和主库保持同步更新。\",\"语句在节点A执行，然后同步到节点B的完整示意图如下：\",\"可以看到：主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。备库B和主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连接，一个事务日志同步的完整过程如下：\",\"在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量\",\"在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中io_thread和sql_thread。其中io_thread负责与主库建立连接\",\"主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B\",\"备库B拿到binlog后，写到本地文件，称为中转日志（relay log）\",\"sql_thread读取中转日志，解析出日志里的命令，并执行\",\"不过后来由于多线程复制方案的引入，sql_thread演化成为了多个线程。\"]},\"591\":{\"h\":\"bin log的三种格式\",\"t\":[\"bin log其实有三种格式：一种是statement，一种是row，还有一种叫做mixed，其实它就是前两种格式的混合。为了便于描述 binlog 的这三种格式间的区别，这里创建了一个表，并初始化几行数据：\",\"CREATE TABLE `t` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `t_modified`(`t_modified`) ) ENGINE = InnoDB; insert into t values(1,1,'2018-11-13'); insert into t values(2,2,'2018-11-12'); insert into t values(3,3,'2018-11-11'); insert into t values(4,4,'2018-11-10'); insert into t values(5,5,'2018-11-09'); \",\"如果要在表中删除一行数据的话，我们来看看这个delete语句的binlog是怎么记录的：\",\"mysql> delete from t /*comment*/ where a>=4 and t_modified<='2018-11-10' limit 1; \",\"当binlog_format=statement时，binlog里面记录的就是SQL语句的原文，可以使用命令：\",\"mysql> show binlog events in 'master.000001'; \",\"查看binlog中的内容：\",\"说明如下：\",\"第一行SET @@SESSION.GTID_NEXT='ANONYMOUS'\",\"第二行是一个BEGIN，跟第四行的commit对应，表示中间是一个事务\",\"第三行是真实执行的语句。可以看到，在真正执行的delete命令之前，还有一个“use test”命令，这是MySQL根据当前要操作的表所在的数据库自行添加的，这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确地更新到test库的表t。在“use test”命令之后的delete语句，就是我们输入的SQL原文，可以看到，binlog“忠实”地记录了SQL命令，甚至连注释也一并记录了\",\"最后一行是一个COMMIT，并且记录了xid=61\",\"为了说明statement和row格式的区别，delete命令的执行效果如下：\",\"可以看到，运行这条delete命令产生了一个warning，原因是当前binlog设置的是statement格式，并且语句中有limit，所以这个命令可能是unsafe的。为什么会这样呢？这是因为delete带limit，很可能会出现主备数据不一致的情况，比如上面的这个例子：\",\"如果delete语句使用的是索引a，那么会根据索引a找到第一个满足条件的行，也就是说删除的是a=4这一行\",\"但如果使用的是索引t_modified，那么删除的就是t_modified='2018-11-09'也就是a=5这一行\",\"由于statement格式下，记录到binlog里的是语句原文，因此可能会出现这样一种情况：在主库执行这条SQL语句的时候，用的是索引a，而在备库执行这条SQL语句的时候，却使用了索引t_modified。因此，MySQL认为这样写是有风险的。\",\"将binlog的格式修改为binlog_format='row',此时，binlog中的内容如下：\",\" 可以看到，与statement格式的binlog相比，前后的BEGIN和COMMIT是一样的。但是，row格式的binlog里没有了SQL语句的原文，而是替换成了两个event：Table_map和Delete_rows:\",\"Table_map event用于说明接下来要操作的表是test库的表t\",\"Delete_rows event用于定义删除的行为\",\"通过上图还是不能看出详细的信息，这时候需要借助mysqlbinlog工具，使用如下命令解析和查看binlog中的内容：\",\"mysqlbinlog -w data/master.000001 --start-position=8900; /** 根据上图，这个事务的binlog是从8900这个位置开始的。 */ \",\"说明如下：\",\"server id 1，表示这个事务是在server_id=1的这个库上执行的\",\"每个event都有CRC32的值，这是因为此时的参数设置binlog_checksum=CRC32\",\"Table_map event显示了接下来要打开的表，map到数字226。这里只操作了一张表，如果操作的是多张彪，每个表都有一个对应的Table_map event，都会map到一个单独的数字，用于区分不同表的操作\",\"-w的参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1=4，@2=4这些值）\",\"binlog_row_image的默认配置是FULL，因此Delete_event里面，包含了删掉的行的所有字段的值。如果把binlog_row_image设置为MINIMAL，则只会记录必要的信息，在这个例子里，只会记录id=4这个信息\",\"最后的Xid event，用于表示事务被正确地提交了\",\"可以看到，当binlog_format=row的时候，binlog里面记录了真实删除的行的主键id，这样binlog传到备库去的时候，就肯定会删除id=4的行，不会有主备删除不同行的问题。\",\"对比statement和row的优缺点，就有了mixed这种binlog格式存在的场景：\",\"因为有些statement格式的binlog可能会导致主备不一致，所以要使用row格式\",\"row格式的缺点是，很占空间。比如，使用delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但是如果row格式的binlog，就要把这10万条记录都写到binlog中，这样做，不仅会占用更大的空间，同时写binlog也要耗费IO资源，影响执行速度\",\"MySQL有一个折中的方案，也就是mixed格式的binlog。MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式\",\"总而言之，mixed格式可以利用statement格式的优点，同时又避免了数据不一致的风险。比如上文中的这个例子，设置为mixed，就会记录为row格式，而如果执行的语句去掉limit 1，就会记录为statement格式。\",\"不过，现在越来越多的场景要求将MySQL的binlog格式设置为row，这么做的理由有很多，其中可以直接看出来好处的就是：恢复数据。接下来，我们分别从delete、insert和update这三种SQL语句的角度，来看看数据恢复的问题：\",\"如果执行的是delete语句，row格式的binlog会把删掉的行的整行信息保存起来。所以，如果执行完一条delete语句以后，发现删错数据了，可以直接把binlog中记录的delete语句转为insert，把被错删的数据插入回去就可以恢复了，\",\"类似的，如果是执行错了insert语句，在row格式下，insert语句的binlog会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行。这是，直接把insert语句转成delete语句，删掉这被误插入的一行数据就可以了。\",\"如果执行的update语句，binlog里面会记录修改前整行的数据和修改后的整行数据。所以，如果误执行了update语句的话，只需要把这个event前后的两行信息对调以下，再去数据库里面执行，就能恢复这个更新操作了。\",\"在使用binlog恢复数据的时候，使用mysqlbinlog解析出日志，然后将statement语句直接拷贝出来执行，这种做法可行吗？假设binlog的格式设置为mixed，然后执行如下语句：\",\"mysql> insert into t values(10,10, now()); \",\"执行的效果如下：\",\"可以看到，MySQL此时使用的statement格式，那么，如果这个binlog过了1分钟才传给备库的话，那主备的数据不就不一致了吗？使用 mysqlbinlog工具查看执行的详情：\",\"从图中的结果可以看到，binlog在记录event的时候，会多记录SET TIMESTAMP=1546103491，它用SET TIMESTAMP命令约定了接下来now()函数的返回时间。因此，不论这个binlog是1分钟之后被备库执行，还是3天后用来恢复这个库的备库，这个insert语句插入的行，值都是固定的。也就是说，通过SET TIMESTAMP命令，MySQL就确保了主备数据的一致性。\",\"这也就是说直接执行语句的结果可能是错误的，因为有些语句的执行结果是依赖于上下文命令的，所以，使用binlog来恢复数据的标准做法是，用mysqlbinlog工具解析出来，然后把解析结果整个发给MySQL执行，类似下面的命令：\",\"mysqlbinlog master.000001 --start-position=2738 --stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd; \",\"这个命令的意思是，将master.000001文件里面从第2738字节到2973字节中间这段内容解析出来，放到MySQL去执行。\"]},\"592\":{\"h\":\"循环复制问题\",\"t\":[\"上文中主备的结构实际上是M-S结果，但实际生产上使用比较多的是双M结构，也就是下图所展示的主备切换流程：\",\"对比双M结构和M-S结构，其实区别只是多了一条线，即：节点A和B之间总是互为主备关系，这样在切换的时候就不用再修改主备关系。但是，双M结构有一个显著的问题需要解决：\",\"业务逻辑在节点A上更新了一条语句，然后再把生成的binlog发给节点B，节点B执行完这条更新语句后也会生成binlog（log_slave_updates=on），那么，如果节点A同时是节点B的备库，相当于又把节点B新生成的binlog拿过来执行了一次，然后节点A和B间，会不断地循环执行这条更新语句，也就是循环复制了，要解决这个问题，要用到上文中提到的server id：\",\"规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系\",\"一个备库接到binlog并在重放的过程中，生成与binlog的server id相同的新的binlog\",\"每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志\",\"按照这个逻辑，如果我们设置了双M结构，日志的执行流程就会变成这样：\",\"从节点A更新的事务，binlog里面记的都是A的server id\",\"传到节点B执行一次后，节点B生成的binlog的server id也是A的server id\",\"再传回给节点A，A判断这个server id与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了\"]},\"593\":{\"h\":\"主备延迟\",\"t\":[\"正常情况下，只要主库执行更新生成的所有binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终以执行，但是，MySQL要提供高可用能力，只有最终一致性是不够的，上文中提到的双M结构的主备切换流程图如下：\"]},\"594\":{\"h\":\"主备延迟及其来源\",\"t\":[\"主备切换可能是一个主动运维动作，比如软件升级、主库所在机器按计划下线等，也可能是被动操作，比如主库所在机器掉电。\",\"首先要明确的一个概念是“同步延迟”，与数据同步有关的时间点主要包括以下三个：\",\"主库A执行完成一个事务，写入binlog，我们将这个时刻记为T1\",\"之后传给备库B，我们将备库B接收完这个binlog的时刻记为T2\",\"备库B执行完成这个事务，我们将这个时刻记为T3\",\"所谓备库延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。可以在备库上执行show slave status命令，它的返回结果里面会显示：seconds_behind_master，用于表示当前备库延迟了多少秒。它的计算方式如下：\",\"每个事务的binlog里面都有一个时间字段，用于记录主库上写入的时间\",\"备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到seconds_behind_master\",\"可以看到，其实seconds_behind_master这个参数计算的就是T3-T1.所以，我们可以用seconds_behind_master来作为主备延迟的值，这个值的时间精度是秒。需要注意的是，如果主备库及其的系统时间设置不一致，并不会导致主备延迟的值不准确。因为，备库连接到主库的时候，会通过执行SELECT UNIX_TIMESTAMP()函数来获取当前主库的系统时间，如果这个时候发现主库的系统时间与自己的不一致，备库在执行seconds_behind_master计算的时候会自动扣掉这个差值。\",\"在网络正常的时候，日志从主库传给备库所需的时间是很短的，即T2-T1的值是非常小的。也就是说，网络正常的情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。所以，主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产binlog的速度要慢。\",\"接下来我们分析一下，可能导致主备延迟出现的原因。\",\"第一种情况是，有些部署条件下，备库所在的机器的性能要比主库所在的机器性能差。这里有一个误区是，既然备库没有请求，所以就使用差一点儿的机器，例如，将20个主库放在4台机器上，而把备库集中在一台机器上。但实际上，更新请求对IOPS的压力，在主库和备库是无差别的，这种“非双1”的模式，更新过程中也会触发大量的读操作，所以，当备库主机上的多个备库都在争抢资源的时候，就可能会导致主备延迟了。不过，由于，主备可能发生切换，备库随时可能变成主库，所以主备库选用相同规格的机器，并且做对称部署，是目前比较常见的做法。\",\"第二种情况是，备库的压力大。通常来说，主库提供写能力，备库提供读能力。由于主库直接影响业务，可能使用的时候会比较克制，反而忽视了备库的压力控制。这样做的结果就是，备库上的查询耗费了大量的CPU资源，影响了同步速度，造成了主备延迟。这种情况，可以如下处理：\",\"一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力\",\"通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力\",\"其中，一主多从的方式比较常用，因为作为数据库系统，必须保证要有定期全量备份的能力，而从库，就比较适合来做备份。\",\"第三种情况是大事务。由于主库上必须等事务执行完成才会写入binlog，再传给备库。所以，如果一个主库上执行10分钟，那么事务很有可能就会导致从库延迟10分钟。一次性地使用delete语句删除太多数据，就是一个典型的大事务的场景，比如，一些归档性的数据，平时没有注意删除历史数据，等到空间快满了，业务开发人员要一次性地删掉大量历史数据，这就是一种比较典型的大事务的场景。另一种比较典型的大事务场景，就是大表DDL。\",\"由于主备延迟的存在，所以在主备切换的时候，就相应的有不同的策略。\"]},\"595\":{\"h\":\"可靠性优先策略\",\"t\":[\"在双M的结构下，从状态1到状态2切换的详细过程如下：\",\"判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步\",\"把主库A改成只读状态，即readonly=true\",\"判断备库B的seconds_behind_master的值，直到这个值变成0为止\",\"把备库B改成可读写状态，也就是readonly=false\",\"把业务请求切换到备库B\",\"这个切换过程就称为可靠性优先策略，执行的流程图如下：\",\"图中SBM是seconds_behind_master的简称\",\"可以看到，这个切换流程中是有不可用时间的。因为在步骤2之后，主库A和备库B都处于readonly的状态，也就是说这个时候系统处于不可写状态，直到步骤5完成后才能恢复。在这个不可用状态中，比较耗费时间的是步骤3，可能需要耗费好几秒的时间。这也是为什么需要在步骤1先做判断，确保seconds_behind_master的值足够小。试想如果一开始主备延迟就长达30分钟，而没有先做判断直接切换的话，系统的不可用时间就会长达30分钟，这种情况一般业务都是不可接受的。\",\"如果要避免切换过程中有不可用时间的这个问题，那么可以采用可用性优先的策略，可以将不可能用时间几乎降为0。\"]},\"596\":{\"h\":\"可用性优先策略\",\"t\":[\"如果将可靠性优先策略步骤的4、5调整到最开始执行，也就是说，不等主备数据同步，直接把连接切到备库B，并且让备库可以读写，那么系统几乎没有不可用时间了，这个切换流程，就称为可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。下面我们来举例来说明这一点，假设有一个表t：\",\"CREATE TABLE `t` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `c` int(11) unsigned DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = InnoDB; insert into t(c) insert into t(c) values(1),(2),(3); \",\"这个表定义了一个字增逐渐id，初始化数据后，主库和备库上都是3行数据。接下来，业务人员要继续在表t上执行两条插入语句的命令，依次是：\",\"insert into t(c) values(4); insert into t(c) values(5); \",\"假设现在主库上有其他的数据表有大量的更新，导致主备延迟达到5秒，在插入一条c=4的语句后，发起了主备切换。下图是binlog_format=mixed时，切换的流程和结果：\",\"可以看到，由于采用了可用性优先策略，主库A和备库B上出现了两行不一致的数据。那么，如果设置binlog_format=row情况又会如何呢？\",\"因为row格式在记录binlog的时候，会记录插入的行的所有字段的值，所以最后只会有一行不一致。而且，两边的主备同步的应用线程会报错duplicate key error并停止。也就是说，这种情况下，备库B的（5，4）和主库A的（5，5）这两行数据，都不会被对方执行。详细过程如下：\",\"不难发现：\",\"使用row格式的binlog时，数据不一致的问题更容易被发现，而使用mixed或者statement格式的binlog时，数据很可能悄悄地就不一致了。如果过了很久才发现数据不一致的问题，很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致\",\"主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，都应该选择可靠性策略，数据的可靠性一般还是要优于可用性\",\"那么时候应该使用可用性优化策略呢？一种场景就是一场切换。假设主库A和备库B的主备延迟是30分钟，这时候主库A掉电了，HA系统要切换B作为主库，通常我们在主动切换的时候，需要等到主备延迟小于5秒的时候再启动切换，但这个时候已经别无选择了。\",\"采用可靠性优先策略的话，就必须等到备库B的seconds_behind_master=0之后，才能切换，但现在的情况比较严重，系统已经处于完全不可用的状态。我们就必须先切换到备库B，并且设置备库Breadonly=false。只切换备库，而不设置备只读也是不行的，因为这段时间内，中转日志还没有应用完成，如果直接发起主备切换，客户端查询看不到之前执行完成的事务，会认为有“数据丢失”。虽然随着中转日志的继续应用，这些数据会恢复回来，但是对于一些业务来说，查询到“暂时丢失数据的状态”也是不能被接受的。\",\"总而言之，在满足数据可靠性的前提下，MySQL高可用系统的可用性，是依赖于主备延迟的，延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。\"]},\"597\":{\"h\":\"并行复制\",\"t\":[\"前面的小节中我们介绍过MySQL主备流程图：\",\"图中两个黑色的箭头，一个箭头代表了客户端写入库，另一个箭头代表的是备库上sql_thread执行中转日志（relay log）。这里使用箭头的粗细来表示并行度，可以看到，第一个箭头明显粗于第二个箭头，这是由于在主库上，各种锁都会影响并发度。\",\"图中备库上sql_thread更新数据（DATA）的过程如果使用的是单线程的话，就会导致备库应用日志不够快，造成主备延迟，在5.6版本之前，MySQL只支持单线程复制，从单线程复制到最新版本的多线程复制，中间演化经历多个版本，不过，所有的多线程复制都符合下面的这个模型：\",\"上图中，coordinator就是原来的sql_thread，不过现在它并不再直接更新数据，只负责读取中转日志和分发事务，真正更新日志的，变成了worker线程，work线程的个数，是由参数slave_parallel_workers决定的。\",\"需要注意的是，事务并不能简单的按照轮询的方式分发给各个worker。当事务被分发给worker以后，不同的worker就独立执行了，但是由于CPU的调度策略，第二个事务有可能比第一个事务先执行，而如果这时候刚好这两个事务更新的是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不一致的问题。类似的，同一个事务的多个更新语句，也不能分给多个不同的worker去执行，假设一个事务更新了表t1和t2中的各一行，如果这两条更新语句被分到不同的worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的隔离性。\",\"因此，coordinator在分发的时候，需要满足以下这两个基本要求：\",\"更新同一行的事务，必须被分发到同一个worker中\",\"同一个事务不能被拆开，必须放到同一个worker中\",\"各个版本的多线程复制，都遵循了这两条基本原则。\"]},\"598\":{\"h\":\"按表分发策略\",\"t\":[\"按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行，因为数据是存储在表里的，所以按表分发，可以保证两个worker不会更新同一行。不过，如果有跨表的事务，还是要把两张表放在一起，具体如下图所示：\",\"每个worker线程对应一个哈希表，用于保存当前正在这个worker的“执行队列”里的事务所涉及到的表。哈希表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表，当有事务分配给worker的时候，事务里面涉及到的表会被加到对应的哈希表中。worker执行完成后，这个表会被从哈希表中去掉。以上图为例，hash_table_1表示，现在worker_1的“待执行事务队列”里，有4个事务涉及到db1.t1表，有一个事务涉及到db2.t2表，hash_table_2表示，现在worker_2中有一个事务会更新到表t3的数据。\",\"假设在上图的基础上，corrdinator从中转日志中读入下一个新事务T，这个事务修改的行涉及到表t1和t3，那么这个事务T的分配流程如下：\",\"由于事务T中涉及修改表t1，而worker_1队列中有事务在修改表t1，事务T和队列中的某个事务要修改同一个表的数据，这种情况下我们认为事务T和worker是冲突的\",\"按照这个逻辑，依次判断事务T和每个worker队列的冲突关系，会发现事务T跟worker_2也冲突\",\"事务T跟多余一个worker冲突，corrdinator线程就进入等待\",\"每个worker继续执行，同时修改哈希表，假设hash_table_2里面涉及到修改表t3的事务先执行完成，就会从hash_table_2中把db1.t3这一项去掉\",\"这样corrdinator会发现跟事务T冲突的worker只有worker_1了，此时，就会将事务T分配给worker_1执行\",\"corrdinator继续读下一个中转日志，继续分配事务\",\"也就是说，每个事务在分发的时候，跟所有worker的冲突关系包含以下三种情况：\",\"如果跟所有worker都不冲突，corrdinator线程就会把这个事务分配给最闲的worker\",\"如果跟多于一个worker冲突，corrdinator线程就会进入等待状态，直到和这个事务存在冲突关系的worker只剩下一个\",\"如果只跟一个worker冲突，corrdinator线程就会把这个事务分配给这个存在冲突关系的worker\",\"这个按表分发的方案，在多个表负载均衡的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到一个表的时候，所有事务都会被分配到同一个worker中，就变成单线程复制了。\"]},\"599\":{\"h\":\"按行分发策略\",\"t\":[\"要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果是两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求binlog的格式必须是row。\",\"这个时候，我们判断一个事务T和worker是否冲突，用的规则就不是“修改同一个表”，而是“修改同一行”。\",\"按行复制和按表复制的数据结构差不多，也是为每个worker，分配一个哈希表，只要实现按行分发，此时，哈希表的key就必须是“库名+表名+唯一键的值”。但是，这个“唯一键”只有主键id还是不够的，表中t1中除了主键，还有唯一索引a：\",\"CREATE TABLE `t1` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `a` (`a`) ) ENGINE = InnoDB; insert into t1 values(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5); \",\"假设，接下来我们要在主库执行下面这两个事务：\",\"可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的worker，就有可能session B的语句先执行，这时候id=1的行的a的值还是1，就会报唯一键冲突。因此，基于行的策略，事务哈希表还需要考虑唯一键，即key应该是“库名+表名+索引a的名字+a的值”，比如，在上面这个例子中，要在表t1上执行update t1 set a = 1 where id = 2语句，在binlog里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。因此，corrdinator在解析这个语句的binlog的时候，这个事务的哈希表就有三个项：\",\"key=hash_func(db1+t1+'PRIMARY'+2), value=2，这里value=2是因为修改前后的行id值不变，出现了两次\",\"key=hash_func(db1+t1+'a'+2), value=1，表示会影响到这个表a=2的行\",\"key=hash_func(db1+t1+'a'+1), value=1，表示会影响到这个表a=1的行\",\"可见，相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源，并且有以下限制：\",\"主库的binlog格式必须是row，因为要能够从binlog里面解析出表名、主键值和唯一索引值\",\"表必须有主键\",\"不能有外键，表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准备\",\"对比按表分发和按行分发这两个方案，按行分发策略的并行度会更高，不过，如果要操作多行的大事务的话，按行分发的策略有两个问题：\",\"耗费内存，例如一个语句要删除100万行数据，这时候哈希表就要记录100万个项\",\"耗费CPU，解析binlog，然后计算哈希值，对于大事务，这个成本比较高\",\"所以，按行分发这种策略会设置一个阈值，单个事务如果超过设置的行的阈值（比如，如果单个事务的行数超过10万行），就暂时退化为单线程模式，退化的逻辑大概如下：\",\"corrdinator暂时先hold住这个事务\",\"等待所有wroker都执行完成，变成空队列\",\"corrdinator直接执行这个事务\",\"恢复并行模式\",\"按表分发和按行分发策略并没有被合并到官方。\"]},\"600\":{\"h\":\"MySQL 5.7的并行复制策略\",\"t\":[\"在MySQL5.6的版本中，支持了按库并行的复制策略，在决定分发策略的哈希表中，key就是数据库名。这种策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好。\",\"相比于按表和按行分发，这个策略有两个优势：\",\"构造哈希值的时候很快，只需要库名，而且一个实例上DB数也不会很多，不会出现需要构造100万个项这种情况\",\"不要求binlog的格式，因为statement格式的binlog也可以很容易拿到库名\",\"但是，如果主库上的表都放在同一个DB里面，这个策略就没有效果了。如果不同DB的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。理论上可以创建不同的DB，把相同热度的表均匀分到这些不同的DB中，强行使用这个策略，不过，这样需要特地异动数据，因此这个策略用的并不多。\"]},\"601\":{\"h\":\"MariaDB的并行复制策略\",\"t\":[\"MariaDB利用了redo log组提交（group commit）优化，而MariaDB的并行复制策略利用这个特性：\",\"能够在同一个组里提交的事务，一定不会修改同一行\",\"主库上可以并行执行的事务，备库上也一定是可以并行执行的\",\"MariaDB中的并行复制策略：\",\"在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1\",\"commit_id直接写到binlog里面\",\"传到备库应用的时候，相同commit_id的事务分到多个worker执行\",\"这一组全部执行完成后，corrdinator再去取下一批\",\"这个策略与其他策略不同的地方在于，它的目标是“模拟主库的并行模式”，不过，它并没有实现“真正模拟主库并发度”这个目标。在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。\",\"下图中，假设了三组事务在主库的执行情况，可以看到trx1、trx2和trx3提交的时候，trx4、trx5和trx6是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进入commit状态。\",\"而按照MariaDB的并行复制策略，备库上的执行效果如下：\",\"可以看到，在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，这样系统的吞吐量就不够。另外，这个方案很容易被大事务拖后腿。假设trx2是一个超大事务，那么在备库应用的时候，trx1和trx3执行完成后，就只能等trx2完全执行完成，下一组才能开始执行，这段时间，只有一个worker线程在工作，是对资源的浪费，不过即使如此，这个策略仍然是一个令人感到惊艳的创新。\"]},\"602\":{\"h\":\"MySQL 5.7的并行复制策略\",\"t\":[\"在MariaDB实现了并行复制之后，MySQL5.7版本也提供了类似的功能，由参数slave-parallel-type来控制并行复制策略：\",\"配置为DATABASE，表示使用MySQL5.6版本的按库并行策略\",\"配置为LOGICAL_CLOCK，表示的就是类似MariaDB的策略。不过，MySQL5.7这个策略，针对并行度做了优化\",\"在redo log的两阶段提交中，其实不用等到commit阶段，只要能够达到redo log prepaer阶段，就表示事务已经通过锁冲突的检验了。因此，MySQL5.7并行复制的思想是：\",\"同时处于prepare状态的事务，在备库执行时时可以并行的\",\"处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的\",\"binlog的组提交中，有这样两个参数：\",\"binlog_group_commit_sync_delay参数，表示延迟多少微妙后才调用fsync\",\"binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync\",\"这两个参数用于故意拉长binlog从write到fsync的时间，以此来减少binlog的写盘次数，在MySQL5.7的并行复制策略里，它们可以用来制造更多的“同时处于prepare阶段的事务”，这样就增加了备库复制的并行度。也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些，在MySQL5.7处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。\",\"在MySQL5.7.22的版本里，有新增了一个基于WRITESET的并行复制，相应地，增加了一个参数binlog-transaction-dependency-tracking，用来控制是否启动这个新策略，这个参数的可选值有以下三种：\",\"COMMIT_ORDER表示根据同时进入prepare和commit来判断是否可以并行的策略\",\"WRITESET表示的对于事务涉及更新的每一行，计算出这一行的哈希值，组成集合writeset，如果两个事务没有操作相同的行，也就是说它们的writeset没有交集，就可以并行\",\"WRITESET_SESSION，是在writeset的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序\",\"当然为了唯一标识，这个哈希值是通过“库名+表名+索引名+值”计算出来的，如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert语句对应的writeset就要多增加一个哈希值。\",\"可以看到，这种策略与按行分发的策略比较类似，不过这个实现有以下优势：\",\"writeset是在主库生成后直接写入binlog里面的，这样在备库执行的时候，不需要解析binlog里面的内容（event里的行数据），节省了很多计算量\",\"不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker，更省内存\",\"由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的\",\"当然，对于“表上没有主键”和“外键约束”的场景，writeset策略也是没法并行的，也会暂时退化为单线程模型。\"]},\"603\":{\"h\":\"一主多从\",\"t\":[\"大多数的互联网应用都是读多写少，因此，在业务不断发展的过程中，很可能会先遇到读性能的问题，而在数据层解决读性能问题，就会涉及到一主多从的架构。\",\"图中，虚线箭头表示的是主备关系，也就是A和A'互为主备，从库B、C、D指向的是主库A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。\",\"在一主多从的架构下，主库故障后的主备切换流程如下：\",\"相比于一主一备的切换流程，一主多从的结构在切换完成后，A'会称为新的主库，从库B、C、D也要改接到A'，正是由于多了从库B、C、D重新指向的这个过程，所以主备切换的复杂性也相应增加了。\"]},\"604\":{\"h\":\"基于位点的主备切换\",\"t\":[\"当我们把节点B设置成节点A'的从库的时候，需要执行一条change master命令：\",\"CHANGE MASTER TO MASTER_HOST=$host_name MASTER_PORT=$port MASTER_USER=$user_name MASTER_PASSWORD=$password MASTER_LOG_FILE=$master_log_name MASTER_LOG_POS=$master_log_pos \",\"这条命令有6个参数，其中：\",\"前四个参数分别代表了A'的IP、端口、用户名和密码\",\"最后两个参数分别表示，要从主库的master_log_name文件的master_log_pos这个位置的日志继续同步，而这个位置就是我们所说的同步位点，也就是主库对应的文件名和日志偏移量。\",\"当节点B要设置成A'的从库，就要执行change master命令，就不可避免的要设置位点的这两个参数。原来节点B是A的从库，本地记录的也是A的微店，但是相同的日志，A的位点和A'的位点是不同的。因此，从库B要切换的时候，都需要经过”找同步位点“这个逻辑，但是这个位点很难精确取到，只能取到一个大概位置。\",\"考虑到切换过程中不能丢失数据，所以在确定位点的时候，总是要找一个”稍微往前“的，然后再通过判断跳过那些在从库B上已经执行过的事务，一种取位点的方法是这样的：\",\"等待新主库A'把中转日志（relay log）全部同步完成\",\"在A'上执行show master status命令，得到当前A'上最新的File和Position\",\"取原主库A故障的时刻T\",\"用mysqlbinlog工具解析A'的File，得到T时刻的位点\",\"mysqlbinlog File --stop-datetime=T --start-datetime=T \",\"图中，end_log_pos后面的值“123”，表示的就是A'这个实例，在T时刻写入新的binlog的位置，那么，我们就可以把123这个作为$master_log_pos的值。\",\"不过，这样得到的$master_log_pos的值并不精确。假设在T这个时刻，主库A已经执行完成了一个insert语句插入了一行数据R，并且已经将binlog传给了A'和B，然后在传完的瞬间主剧A的主机就掉电了。此时，系统的状态是这样的：\",\"在从库B上，由于同步了binlog，R这一行已经存在\",\"在新主库A'上，R这一行已经存在，日志是写在123这个位置之后的\",\"此时，在从库B上执行change_master命令，指向A'的File文件的123位置，就会把插入R这一行数据的binlog又同步到从库B去执行\",\"这个时候，从库B的同步线程就会出现Duplicate entry 'id_of_R' for key 'PRIMARY'错误，提示出现了主键冲突，然后停止同步。\",\"所以，通常情况下，在切换任务的时候，要先主动跳过这些错误，有两种常用的方法，一种做法是，主动跳过一个事务，跳过命令的写法是：\",\"set global sql_slave_skip_counter=1; start slave; \",\"因为切换过程中，可能会不止重复执行一个事务，所以需要在从库B刚开始接到新主库A'时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。\",\"另一方式时，通过设置slave_skip_errors参数，直接设置跳过指定的错误，在执行主备切换时，有两种比较常见的错误：\",\"1062错误是插入数据时唯一键冲突\",\"1032错误是删除数据时找不到行\",\"因此，我们可以把slave_skip_errors设置为“1032，1062”，这样中间碰到这两个错误时就直接跳过。\",\"需要注意的是，这种直接跳过指定错误的方法，针对的是主备切换时，由于找不到精确的同步位点，所以只能采用这种方法来创建从库和新主库的主备关系。这么操作的前提是，我们很清楚在主备切换过程中，直接跳过1032和1062这两类错误是无损的，才可以设置slave_skip_errors参数，等到主备间的同步关系建立完成，并稳定执行一段时间之后，我们还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。\"]},\"605\":{\"h\":\"GTID\",\"t\":[\"通过sql_slave_skip_counter跳过事务和通过slave_skip_errors忽略错误的方法，虽然都最终可以建立从库B和新主库A'的主备关系，但这两种操作都很复杂，而且容易出错。所以，MySQL5.6版本引入了GTID，彻底解决了这个问题。\",\"GTID的全称是Global Transaction Identifier，也就是全局事务ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：\",\"GTID=source_id:transaction_id \",\"其中：\",\"ƒsource_id是一个实例第一次启动时自动生成的，是一个全局唯一的值\",\"transaction_id是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1\",\"这里的transaction_id与我们通常讲的事务id有所区别，事务id是在事务执行过程中分配的，如果这个事务回滚了，事务id也会递增，而这里transaction_id只有在事务提交的时候才会分配。\",\"GTID模式的启动需要在启动MySQL实例的时候，添加参数gtid_mode=on和enforce_gtid_consistency=on。在GTID模式下，每个事务都会跟一个GTID一一对应。这个GTID有两种生成方式，而使用哪种方式取决于session变量gtid_next的值：\",\"如果gtid_nex=automatic，代表使用默认值，这时，MySQL就会把source_id:transaction_id分配给这个事务 \",\"记录binlog的时候，先记录一行SET@SESSION.GTID_NEXT='source_id:transaction_id'\",\"把这个GTID加入本实例的GTID集合\",\"如果gtid_next是一个指定的GTID的值，比如通过set gtid_next='current_gtid'指定为current_gtid，那么就有两种可能： \",\"如果current_gtid已经存在于实例的GTID集合中，接下来执行的这个事务会直接被系统忽略\",\"如果current_gtid没有存在于实例的GTID集合中，就将这个current_gtid分配给接下来要执行\",\"这样，每个MySQL实例都维护了一个GTID集合，用来对应“这个实例执行过的所有事务”，接下来我们通过例子来说明这一点。\",\"首先在实例X中创建表t：\",\"CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = InnoDB; insert into t values(1,1); \",\"可以看到，事务的BEGIN之前有一条SET SESSION.GTID_NEXT命令。这时，如果实例X有从库，那么将CREATE TABLE和insert语句的binlog同步过去执行的话，执行事务之前就会先执行这两个SET命令，这样被加入从库的GTID集合的，就是图中的这两个GTID。假设，现在这个实例X是另外一个实例Y的从库，并且此时在实例Y上执行下面的这条插入语句：\",\"insert into t values(1,1); \",\"并且，这条语句在实例Y上的GTID是“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。那么，实例X作为Y的从库，就要同步这个事务过来执行，显然会出现主键冲突，导致实例X的同步线程停止，这时，我们可以执行如下语句序列：\",\"set gtid_next='aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10'; begin; commit; set gtid_next=automatic; start slave; \",\"其中，前三条语句的作用，是通过提交一个空事务，把这个GTID加到实例X的GTID集合中。下图表示了执行完这个空事务之后的show master status的结果：\",\"可以看到实例X的Executed_Gtid_set里面，已经加入了这个GTID，这样，我再执行start slave命令让同步线程执行起来的时候，虽然实例X还是会继续执行实例Y传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”已经存在于实例X的GTID集合中了，所以实例X就会直接跳过这个事务，也就不会再出现主键冲突的错误。\",\"在上面的这个语句序列中，start slave命令之前还有一行set gtid_next=automatic。这句话的作用是“恢复GTID的默认分配行为”，也就是说如果之后有新的事务再执行，就还是按照原来的分配方式，继续分配transaction_id=3。\",\"在GTID模式下，备库B要设置为新主库A'的从库的语法如下：\",\"CHANGE MASTER TO MASTER_HOST=$host_name MASTER_PORT=$port MASTER_USER=$user_name MASTER_PASSWORD=$password master_auto_position=1 \",\"其中，master_auto_position=1就表示这个主备关系使用的是GTID协议，使用这种方式，就无须设置MASTER_LOG_FILE和MASTER_LOG_POS这两个参数了。\",\"现在，将实例A'的GTID的集合记为set_a，实例B的GTID集合记为set_b，那么在实例B上执行start slave命令，取binlog的逻辑如下：\",\"实例B指定主库A'，基于主备协议建立连接\",\"实例B吧set b发给主库A'\",\"实例A'算出set_a与set_b的差集，也就是所有存在于set_a，但是不存在于set_b的GTID的集合，判断A'本地是否包含了这个差集需要的所有binlog事务 \",\"如果不包含，表示A'已经把实例B需要的binlog给删掉了，直接返回错误\",\"如果确认包含全部，A'从自己的binlog文件里面，找出第一个不在set_b的事务，发给B\",\"之后就从这个事务开始，往后读文件，按顺序取binlog发给B去执行\",\"其实，这个逻辑里面包含了一个设计思想：在基于GTID的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的，因此，如果实例B需要的日志已经不存在，A'就拒绝把日志发给B。这跟基于位点的主备协议不同，基于位点的协议，是由备库决定的，备库指定哪个点位，主库就发哪个位点，不做日志的完整性判断。\",\"在引入GTID之后，一主多从的切换场景下，主备切换就变成了：由于不需要找位点了，所以从库B、C、D只需要分别执行change master命令执行实例A'即可。其实，严谨地说，主备切换不是不需要找位点了，而是找位点的这个工作，在实例A'内部就已经自动完成了，但由于这个工作是自动的，所以对HA系统的开发人员来说，非常友好。之后这个系统就由新主库A'写入，主库A'的自己生成的binlog中的GTID集合格式是：source_id_of_A<sup>'</sup>:1-M。如果之前从库B的GTID集合格式是source_id_of_A<sup>'</sup>:1-N，那么切换之后GTID集合的格式就变成了source_id_of_A<sup>'</sup>:1-N，source_id_of_A<sup>'</sup>:1-M。由于主库A'之前也是A的备库，因此主库A'和从库B的GTID集合是一样的。这样就达到了我们的预期。\"]},\"606\":{\"h\":\"读写分离\",\"t\":[\"读写分离的主要目标就是分摊主库的压力，上文提到的一主多从的架构师客户端主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由客户端来选择后端数据库进行查询。还有一种架构是，在MySQL和客户端之间有一个中间代理层proxy，客户端只连接proxy，由proxy根据请求类型和上下文决定请求的分发路由。\",\"客户端直连和带proxy的读写分离架构的优劣势：\",\"客户端直连方案，因为少了一层proxy转发，所以查询性能更好，并且整体架构简单，排查问题更方便。不过这种方案，由于要了解后端的部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。\",\"带proxy的结构，对客户端比较友好。客户端无需关心后端的细节，连接维护、后端信息维护等工作，都是由proxy完成。不过，这样对后端维护团队的要求会更高，而且，proxy也需要有高可用架构，因此，带proxy架构的整体就相对比较复杂\",\"不论采用哪种架构，都会碰到“过期读”的问题，即由于主从可能存在延迟，客户端执行完 一个更新事务马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。\",\"处理这种”过期读“的问题，大致有以下几种方案：\",\"强制走主库方案\",\"sleep方案\",\"判断主备无延迟方案\",\"配合semi-sync方案\",\"等主库位点方案\",\"等GTID方案\"]},\"607\":{\"h\":\"强制走主库方案\",\"t\":[\"强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为两类：\",\"对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品后，马上要返回主页面，查看商品是否发布成功，那么这个请求需要拿到最新的结果，就必须走主库\",\"对于可以读到就数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的，那么，这类请求就可以走从库\",\"当然，这个方案最大的问题在于，有时候会碰到所有的查询都不能是过期读的需求，比如一些金融类的业务。这样的话，就要放弃读写分离，所有读压力都在主库，等同于放弃了扩展性。\"]},\"608\":{\"h\":\"sleep 方案\",\"t\":[\"这个方案的做法是，在主库更新后，读从库之前先sleep一下。具体的方案就是，类似于执行一条select sleep(1)命令。这个方案的假设是，大多数情况下主备延迟在1秒内，做一个sleep可以有很大概率拿到最新的数据。\",\"还是以卖家发布商品为例，商品发布后，用Ajax直接把客户端输入的内容作为“新的商品”显示在页面上，而不是真正地去数据库查询，这样，买家就可以通过这个现实，来确认产品已经发布成功了。等到卖家再刷新页面，去查看商品的时候，其实已经过了一段时间，也就达到了sleep的目的，进而也就解决了过期读的问题。\",\"也就是说，这个sleep方案确实解决了类似场景下的过期读问题，但是也存在两个问题：\",\"如果这个查询请求本来0.5秒就可以在从库上拿到正确结果，也会等1秒\",\"如果延迟超过1秒，还是会出现过期读\"]},\"609\":{\"h\":\"判断主备无延迟方案\",\"t\":[\"要判断备库无延迟，通常有三种做法。\",\"第一种确保主备无延迟的方法是，每次从库执行查询请求前，先判断seconds_behind_master是否已经等于0，如果还不等于0，那就必须等待这个参数变为0才能执行查询请求。seconds_behind_master的单位是秒，如果觉得精度不够，就可以采用位点和GTID的方法来确保主备无延迟。\",\"第二种方法是，对比位点确保主备无延迟：\",\"Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点\",\"Relay_Master_Log_File和Exec_Master_Log_Pos，表示的是备库执行的最新位点\",\"如果Master_Log_File和Read_Master_Log_Pos，Relay_Master_Log_File和Exec_Master_Log_Pos这两组值完全相同，就表示接收到的日志已经同步完成。\",\"第三种方法是，对比GTID集合确保主备无延迟：\",\"Auto_Position=1，表示这对主备关系使用了GTID协议\",\"Retrieved_Gtid_Set，是主备收到的所有日志的GTID集合\",\"Executed_Gtid_Set，是备库所有已经执行完成的GTID集合\",\"如果这两个集合相同，也表示备库接收到的日志都已经同步完成。\",\"可见，对比位点和对比GTID这两种方法，都比判断seconds_behind_master是否为0更精确。在执行查询请求之前，先判断从库是否同步完成的方法，相比于sleep方法，准确度确实提升了不少，但还是没有达到“精确”的程度。一个事务的binlog在主备之间流转的状态如下：\",\"主库执行完成，写入binlog，并反馈给客户端\",\"binlog被从库发送给备库，备库收到\",\"在备库执行binlog完成\",\"三种讨论的判断主备无延迟的逻辑，都是“备库收到的日志都执行完成了”。但是，从binlog在主备之间状态的分析中，可以看到还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态，如下图：\",\"![image-20220325100353640](/Users/jiyongchao/Library/Application Support/typora-user-images/image-20220325100353640.png)\",\"这时，主库上执行完成了三个事务trx1、trx2和trx3，其中：\",\"trx1和trx2已经传到从库，并且已经执行完成了\",\"trx3在主库执行完成，并且已经回复给客户端，但是还没有传到从库中\",\"如果这时候在从库B上执行查询请求，按照上面提到的判断方法，从库会认为已经没有同步延迟，但还是查不到trx3的。严格地说，就是出现了过期读。\",\"要解决这个问题，就要引入半同步复制，也就是semi-sync replication，semi-sync的设计如下：\",\"事务提交的时候，主库把binlog发给从库\",\"从库收到binlog以后，发回给主库一个ack，表示收到了\",\"主库收到这个ack以后，才能给客户端返回“事务完成”的确认\",\"也就是说，如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。这样，结合前面关于位点的判断，就能够确定在从库上执行的查询请求吗，可以避免过期读。\",\"不过，semi-sync+位点判断的方案，只对一主一备的场景是成立的。在一主多从的场景中国呢，主库只要等到一个从库的ack，就开始给客户端返回确认，这时，在从库上执行查询请求，就有两种情况：\",\"如果查询是落在这个相应ack的从库上，是能确保读到最新数据\",\"但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题\",\"另外，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者GTID集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况，示意图如下：\",\"上图中备库B下的虚线框，分别表示relay log和binlog中的事务，可以看到，备库从状态1到状态4都和主库A存在延迟，如果使用上面提到的策略，必须要等到无延迟才能查询的方案，selelct语句直到状态4都不能执行。\",\"总而言之，semi-sync配合判断主备无延迟的方案，存在两个问题：\",\"一主多从的时候，在某些从库执行查询请求会存在过期读的现象\",\"在持续延迟的情况下，可能出现过度等待的问题\",\"仔细观察可以发现，客户端是在发完trx1更新后发起的select语句，其实只要确保trx1已经执行完成就可以执行select语句了，也就是说在状态3执行查询请求，得到的就是预期结果了，这就是等主库位点方案。\"]},\"610\":{\"h\":\"等主库位点方案\",\"t\":[\"要理解等主库位点方案，首先要了解一条命令：\",\"select master_pos_wait(file, pos[,timeout]); \",\"它的逻辑如下：\",\"它是在从库执行的\",\"参数file和pos指的是主库上的文件名和位置\",\"timeout可选，设置为正整数N表示这个函数最多等待N秒\",\"这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。当然，除了正常返回一个正整数M外，还会返回一些其他结果，包括：\",\"如果执行期间，备库同步线程发生异常，则返回NLL\",\"如果等待超过N秒，就返回-1\",\"如果刚开始执行的时候，就已经执行过这个位置了，则返回0\",\"上文中的例子，就可以使用这个逻辑：\",\"trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position\",\"选定一个从库执行查询语句\",\"在从库上执行select master_pos_wait(File,Position,1);\",\"如果返回值是大于等于0的正整数，则在这个从库执行查询语句\",\"否则，到主库执行查询语句\",\"这个过程的流程图如下：\",\"这里假设这条select查询最多在主库上等待1秒，那么1秒内master_pos_wait返回一个大于等于0的整数，就确保了主库上执行的这个查询结果一定包含了trx1的数据。\",\"其中步骤5到主库执行查询语句，是这类方案常用的退化机制，因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。这样带来的问题是，如果所有的从库都延迟超过1秒了，那查询的压力都会跑到主库上。在不允许过期读的要求下，只有两种选择，一种是超时放弃，一种是转到主库查询，至于具体选择哪一种，取决于业务场景。\"]},\"611\":{\"h\":\"GID方案\",\"t\":[\"如果数据库开启了GTID模式，对应的也有等待GTID的方案，MySQL中提供了一个类似的命令：\",\"select wait_for_executed_gtid_set(gtid_set,1); \",\"这条命令的逻辑是：\",\"等待，直到这个库执行的事务中包含传入的gtid_set，返回0\",\"超时返回1\",\"在等位点的方案中，我们执行完事务后，还要主动去主库执行show master status。而MySQL5.7.6版本开始，允许在执行更新类事务，把这个事务的GTID返回给客户端，这样等GTID的方案就可以减少一次查询，这时，执行流程就变成了：\",\"trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1\",\"选定一个从库执行查询语句\",\"在从库上执行select wait_for_executed_gtid_set(gtid1,1)\",\"如果返回值是0，则在这个从库执行查询语句\",\"否则，到主库执行查询语句\",\"整个过程的流程图如下：\",\"第一步中，trx1事务更新完成后，从返回包获取这个事务的GTID，需要将MySQL的参数设置为session_track_gtids=OWN_GTID，然后通过API接口mysql_session_track_get_first从返回包解析出GTID的值即可。\"]},\"612\":{\"h\":\"可用性判断\",\"t\":[\"本小节我们要讨论的是，如何判断一个主库出了问题。\"]},\"613\":{\"h\":\"select 1判断\",\"t\":[\"最简单直接的方法就是执行select 1，如果select 1成功返回了，就表示主库没有问题。实际上，select 1成功返回，只能说明这个库的进程还在，并不能说明主库没问题，为了说明这个问题，我们创建表t：\",\"set global innodb_thread_concurrency = 3; CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = InnoDB; insert into t values(1,1) \",\"这里我们设置innodb_thread_concurrency参数的目的是，控制InnoDB的并发线程上限。也就是说，一旦并发线程数达到这个值，InnoDB在接收到新请求的时候，就会进入等待状态，直到有线程退出。\",\"这里设置innodb_thread_concurrency=3表示InnoDB只允许3个线程并发执行。在这个例子中，前三个session中的sleep（100），使得这三个语句都处于“执行”状态，以此来模拟大查询。在session D中，select 1可以成功，但是查询表t的语句会被阻塞，也就是说，如果这时使用select 1是检测不出问题的。\",\"在InnoDB中，innodb_thread_concurrency这个参数的默认值是0，表示不限制并发线程数量。但是，不限制并发线程数肯定是不行的，因为，一个机器的CPU核数有限，如果不加以限制，线程数过高，会导致上下文切换的成本会过高。通常情况下，innodb_thread_concurrency可以设置为64～128之间的值。\",\"需要额外说明的是，并发连接和并发查询并不是同一个概念，使用show processlist的结果里看到的几千个连接，指的就是并发连接，而“当前正在执行”的语句，才是所谓的并发查询。并发连接数达到几千个影响并不大，就是会多占一些内存，但是并发查询过高会占用过多资源，这就是我们为什么要设置innodb_thread_concurrency参数的原因。\",\"假设我们设置innodb_thread_concurrency=128，那么如果出现同一行热点更新的问题时，会不会很快就把128消耗完呢？实际上，在线程进入锁等待以后，并发线程的计数会减一，也就是说等行锁（包括间隙锁）的线程时不算在128里面的。MySQL这样设计的原因是，进入锁等待的线程已经不吃CPU了，更重要的是，必须这么设计，才能避免整个系统锁死，假设有如下场景：\",\"线程1执行begin; update t set c = c + 1 where id = 1;，启动了事务trx1，然后保持这个状态。这时候，线程处于空闲状态，不算在并发线程里面\",\"线程2到线程129都执行update t set c = c + 1 where id = 1;，由于等行锁，进入等待状态，这样就有128个线程处于等待状态\",\"如果处于锁状态的线程技术不减一，InnoDB就会认为线程数用满了，会阻止其他语句进入引擎执行，这样线程1不能提交事务。而另外的128个线程又处于锁等待状态，整个系统就阻塞了\",\"具体过程如下图：\",\"这时候InnoDB不能响应任何请求，整个系统被锁死。而且，由于所有线程处于等待状态，此时占用的CPU却是0，而这明显不合。所以InnoDB在设计时，遇到进程进入锁等待的情况时，将并发线程的计数减1的设计，是合理而且必要的。\",\"虽然说等锁的线程不算在并发线程计数里，但如果它在真正地执行查询，比如上面例子中的select sleep(100) from t，还是要算进并发线程的计数的。\",\"在这个例子中，同时执在执行的语句超过了设置的innnodb_thread_concurrency的值，这时候系统其实已经不正常了，但是通过select 1来检测系统，会认为系统还是正常的。\"]},\"614\":{\"h\":\"查表判断\",\"t\":[\"为了能够检测InnoDB并发线程数过多导致的系统不可用的情况，我们需要找一个访问InnoDB的场景。一般的做法是，在系统库（mysql库）里创建一个表，比如命名为health_check，里面只放一行数据，然后定期执行：\",\"select * from mysql.health_check; \",\"使用这个方法，我们可以检测出由于并发线程过多导致的数据库不可用的情况。但是，这种做法也存在一个问题，更新事务要写入binlog，当binlog所在磁盘的空间占用率达到100%，那么所有的更新语句和事务提交的commit语句就都会被堵住，但是这个时候系统还是可以正常读取数据的，因此，我们需要把这条查询语句修改成更新语句。\"]},\"615\":{\"h\":\"更新判断\",\"t\":[\"既然要更新，就要放个有意义的字段，常见的做法是放一个timestamp字段，用来表示最后一次执行检测的时间：\",\"update mysql.health_check set t_modified=now(); \",\"节点可用性的检测都应该包含主库和备库。如果用来检测主库的话，那么备库也要进行更新检测。但是，备库的检测也是要写bin log的，由于我们一般会把数据库A和B的主备关系设计为双M结构，所以在备库B傻姑娘执行的检测命令，也要发回给主库A。\",\"但是，如果主库A和备库B都用相同的更新命令，就可能出现行冲入，也就是可能会导致主备同步停止，因此，mysql.health_check这个表需要再加一行。为了让主备之间的更新不产生冲突，我们可以在mysql.health_check表上存入多行数据，并且用A、B的server_id做主键。\",\"CREATE TABLE `health_check` ( `id` int(11) NOT NULL, `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE = InnoDB; /* 检测命令 */ insert into mysql.health_check(id, t_modified) values (@@server_id, now()) on duplicate key update t_modified = no \",\"由于MySQL规定了主库和备库的server_id必须不同（否则创建主备关系的时候就会报错），这样就可以保证主、备库各自的检测命令不会发生冲突。\",\"更新判断是一个相对比较常用的方案，不过依然存在一些问题，其中，“判定慢”是最主要的问题。\",\"首先，所有的检测逻辑都需要一个超时时间N，执行一条update语句，超过N秒后还不返回，就认为系统不可用。假设一个日志盘的IO利用率已经是100%了，这个时候，整个系统的响应非常慢，已经需要做主备切换了。但是IO利用率100%表示系统的IO是正在工作的，每个请求都有机会获得IO资源，执行自己的任务。而update语句，需要的资源很少，所以可能在拿到IO资源的时候就可以提交成功，并且在超时时间N秒未达到之前就返回给了检测系统。检测系统发现，update命令没有超时，于是得到了“系统正常”的结论。\",\"之所以出现这个现象，根本原因是上文中提到的所有方法，都是基于外部检测的。外部检测天然有一个问题，就是随机性。因为外部检测都需要定时轮询，所以系统可能已经出问题了，但是却需要等到下一个检测发起执行语句的时候，才有可能发现为你。而且，如果运气不够好的话，可能第一次轮询还不能发现，这就会导致切换慢的问题。\"]},\"616\":{\"h\":\"内部统计\",\"t\":[\"内部统计的方案主要是要利用磁盘利用率，在MySQL5.6以后提供的preformance_schema库，在file_summary_by_event_name表里统计了每次IO请求的时间，根据MySQL5.6内部每一次IO请求的时间来判断数据库是否出现了问题会精确的多。\",\"file_summary_by_event_name表里有很多行数据，我们主要关注event_name='wait/io/file/innodb/innodb_log_file'这一行：\",\"![image-20220327105108038](/Users/jiyongchao/Library/Application Support/typora-user-images/image-20220327105108038.png)\",\"图中，这一行统计的是redo log的写入时间，第一列EVENT_NAME表示统计的类型。接下来三组数据，显示的是redo log操作的时间统计。第一组五列，是所有IO类型的统计。其中，COUNT_STAR是所有IO的总次数，接下来四列是具体的统计项，单位是皮秒，前缀SUM、MIN、AVG、MAX，顾名思义指的就是总和、最小值、平均值和最大值。第二组六列，是读操作的统计，最后一列SUM_NUMBER_OF_BYTES_READ统计的是，总共从redo log里读了多少字节。第三组六列，统计的是写操作。最后的第四组数据，是对其他类型数据的统计。在redo log里，可以认为它们是对fsync的统计。\",\"bin log对应的是event_name = \\\"wait/io/file/sql/binlog\\\"这一行，各个字段的统计逻辑，与redo log的各个字段完全相同。\",\"由于每次操作数据库，preformance_schema都需要额外地统计这些信息，所以打开这个统计功能是有性能损耗的。如果打开所有的preformance_schema项，性能会下降10%左右，因此，只打开需要的项进行统计即可。\",\"如果打开redo log的时间监控，可以执行：\",\"update setup_instruments set ENABLED='YES', Timed='YES' where name like '%wait/io/file/innodb/innod \",\"假设已经开启了redo log和binlog这两个统计信息，就可以通过MAX_TIMER的值来判断数据库是否出问题了。比如，可以通过设定阈值，单次IO请求时间超过200毫秒属于异常，然后使用类似下面这条语句作为检测逻辑：\",\"select event_name,MAX_TIMER_WAIT FROM performance_schema.file_summary_by_event_name where EVENT_NAME = 'wait/io/file/innodb/innodb_log_file'; \",\"发现异常后，取到需要的信息，再通过下面的这条语句：\",\"truncate table performance_schema.file_summary_by_event_name; \",\"把之前的统计信息清空，这样，再次出现这个异常，就可以加入监控累积值了。\"]},\"617\":{\"h\":\"Kill命令\",\"t\":[\"在MySQL中有两个kill命令：一个是kill quey + 线程id，表示终止这个线程中正在执行的语句：一个是kill connection + 线程id，这里connection可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句。在使用kill命令的时候，可能会出现，无法断开这个连接，但是执行show processlist命令，看到这条语句的Command列显示的却是Killed。\",\"其实大多数情况下，kill query/connection命令是有效的，比如，执行一个查询的过程中，发现执行时间太久，要么放弃继续查询，这时我们就可以使用kill query命令，终止这条查询语句。还有一种情况是，语句处于锁等待的时候，直接使用kill命令也是有效的：\",\"可以看到，session C执行kill query以后，session B几乎同时就提示了语句被中断，这就是我们预期的结果。\"]},\"618\":{\"h\":\"kill命令的执行过程\",\"t\":[\"当对一个表做增删改查操作时，会在表上加MDL读锁，所以，session B虽然处于blocked状态，但还是持有MDL读锁的，如果线程直接被kill掉，那么这个MDL读锁就没有机会释放了。也就是说，kill并不是马上停止的意思，而是告诉线程，这条语句已经不需要继续执行了，可以开始“执行停止的逻辑了”。\",\"其实，这和Linux的kill命令类似。kill -N pid并不是让进程直接停止，而是给进程发一个信号，然后进程处理这个信号，进入终止逻辑。只是对于MySQL的kill命令来说，不需要传信号量参数，就只有“停止”这个命令。\",\"实现上，当用户执行kill query thread_id_B时，MySQL里处理kill命令的线程做了两件事情：\",\"把session B的运行状态改成THD::KILL_QUERY（将变量killed赋值为THD::KILL_QUERY）\",\"给session B的执行线程发一个信号\",\"需要发出信号的原因是，session B处于锁等待状态，如果只是把session B的线程状态设置THD::KILL_QUERY，线程B并不知道这个状态变化，还是会继续等待，发一个信号的目的，就是让session B退出等待，来处理这个THD::KILL_QUERY状态。\",\"上面的分析中，隐含了下面的三层意思：\",\"一个语句执行过程中有多处“埋点”，在这些买点的地方判断线程状态，如果发现线程状态是THD::KILL_QUERY，才开始进入语句终止逻辑\",\"如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处\",\"语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的\",\"接下来我们来看一个kill不掉的例子。首先，执行set global innodb_thread_concurrency = 2，将InnoDB的并发线程上限设置为2，然后执行下面的序列：\",\"可以看到：\",\"session C执行的时候被阻塞了\",\"但是session D执行kill query C命令没有效果\",\"直到session E执行了kill connection命令，才断开了session B的连接，提示“Lost connection to MySQL server during query”\",\"但是，此时如果在session E中执行show processlist，就可以看到下面这个图：\",\"这时候，id=12这个线程的Command列显示的是Killed。也就是说，客户端虽然断开了连接，但是实际上服务端上这条语句还在执行过程中。\",\"为什么在执行kill query命令时，这条语句不像第一个例子的update语句一样退出呢？在实现等行锁时，使用的是pthread_cond_timewait函数，这个等待状态可以被唤醒。但是，在这个例子中，12号线程的等待逻辑是这样的：每10毫秒判断一下是否可以进入InnoDB执行，如果不行，就调用nanosleep函数进入sleep状态。也就是说，虽然12号线程的状态已经设置成了KILL_QUERY，但是在这个等待进入InnoDB的循环过程中，并没有去判断线程的状态，因此根本不会进入终止逻辑阶段。而当session E执行kill connection命令时：\",\"把12号线程状态设置为KILL_CONNECTION\",\"关掉12号线程的网络连接，因为有这个操作，所以这时候session C收到了断开连接的提示\",\"那为什么执行show processlist的时候，会看到Command列显示为killed呢？其实，这时因为在执行show processlist的时候，有一个特别的逻辑：如果一个线程的状态是KILL_CONNECTION，就把Command列线程成Killed，所以，即使是客户端退出了，这个线程的状态仍然是在等待中，那这个线程什么时候会退出呢？\",\"只有等到满足进入InnoDB的条件后，session C的查询语句继续执行，然后才有可能判断到线程的状态已经变成了KILL_QUERY或者KILL_CONNECTION，再进入终止逻辑阶段。\",\"这是kill无效的第一类情况，即：线程没有执行到判断线程状态的逻辑，跟这种情况相同的，还有由于IO压力过大，读写IO的函数一致无法返回，导致不能及时判断线程的状态。另一类情况是，终止逻辑耗时较长，这时候，从show processlist结果上看也是Command = Killed，需要等到终止逻辑完成，语句才算真正完成，这类情况，比较常见的场景有以下几种：\",\"超大事务执行期间被kill，这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长\",\"大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待IO资源，导致耗时较长\",\"DDL命令执行到最后阶段，如果被kill，需要删除中间过程的临时文件，也可能收到IO资源影响耗时较久。\"]},\"619\":{\"h\":\"客户端缓存\",\"t\":[\"在实际使用中，有两个比较常见的误解。\",\"第一个误解是：如果库里面的表特别多，连接就会很慢。有些线上的库，会包含很多表，这时候，每次用客户端连接都会卡在下面这个界面上：\",\"而如果db1这个库里表很少的话，连接起来就会很快，可以很快进入输入命令的状态。但每个客户端在和服务端建立连接的时候，需要做的事情就是TCP握手、用户校验、获取权限。但这几个操作，显然跟库里面表的个数无关。\",\"实际上，当使用默认参数连接的时候，MySQL客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端在连接成功后，需要多做一些操作：\",\"执行show databases;\",\"切到db1库，执行show tables;\",\"把这两个命令的结果用于构建一个本地的哈希表\",\"在这些操作中，最花时间的就是第三步在本地构建哈希表的操作。所以，当一个库中的表个数非常多的时候，这一步就会花比较长的时间。也就是说，我们感知到的连接过程慢，其实并不是连接慢，也不是服务端慢，而是客户端慢。如果在连接命令中加上-A的参数，就可以关掉这个自动不全的功能，然后客户端就可以快速返回了。这里自动补全的效果是，当输入库名或者表名的时候，输入前缀，就可以使用Tab键自动补全表名或者显示提示。如果在实际使用中，自动补全功能用得不多，那么久可以加上-A的参数。\",\"除了可以添加-A的参数以外，加-quick（或简写为-q）参数，也可以跳过这个阶段。但是，这个-quick是一个更容易引起误会的参数，也是关于客户端常见的一个误解。\",\"MySQL客户端发送请求后，接收服务端返回结果的方式有两种：\",\"一种是本地缓存，也就是在本地打开一片内存，先把结果存起来。如果使用API，对应的就是mysql_store_result方法\",\"另一种是不读缓存，读一个处理一个。如果使用API开发，对应的就是mysql_use_result方法\",\"MySQL客户端默认采用第一种方式，而如果加上-quick参数，就会使用第二种不缓存的方式。采用不缓存的方式时，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。也就是说，设置了这个参数，反而会降低服务端的性能。\",\"那么，为什么这个参数要取名叫做-quick呢？这是因为：\",\"第一点，跳过了表名自动补全的功能\",\"第二点，mysql_store_result需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能\",\"第三点，不会把执行命令记录到本地的命令历史文件\",\"因此，-quick参数的意思，其实是让客户端变得更快。\"]},\"620\":{\"h\":\"误删数据\",\"t\":[\"俗话说“常在河边走，哪有不湿鞋”，大多数人都可能会碰到误删数据的场景，为了找到解决误删数据的更高效的方法，我们对MySQL相关的误删数据，做以下分类：\",\"使用delete语句误删数据行\",\"使用drop table或者truncate table语句误删数据表\",\"使用drop database语句误删数据库\",\"使用rm命令误删整个MySQL实例\"]},\"621\":{\"h\":\"误删行\",\"t\":[\"如果使用delete语句误删了数据行，可以用Flashback工具通过闪回把数据恢复回来，Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放，而能够使用这个方案的前题是，需要确保binlog_format=row和binlog_row_image=FULL。\",\"具体恢复数据时，对单个事务做如下处理：\",\"对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event即可\",\"同理，对于delete语句，也是将Delete_rows event改为Write_rows event\",\"而如果是Update_rows的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的位置即可\",\"如果误操作不是一个，而是多个，比如下面三个事务：\",\"(A)delete ... (B)insert ... (C)update... \",\"现在要把数据库恢复到这个三个事务操作之前的状态，用Flashback工具解析binlog后，写回主库的命令是：\",\"(reverse C)update ... (reverse B)delete ... (reverse A)insert... \",\"也就是说，如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。需要注意的是，不要直接在主库上执行这些操作，恢复数据比较安全的做法是，恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。这么做的原因是，一个在执行线上逻辑的主库，数据状态的变更往往是有关联的，可能由于发现数据问题的时间晚了一点，就导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其它数据，所以，如果这时候单独恢复这几行数据，而又未经确认的话，就可能出现对数据的二次破坏。\",\"比起误删数据时候进行处理，更重要的是做到事前预防：\",\"把sql_safe_updates参数设置为on，这样依赖，如果忘记在delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错\",\"代码上线前，必须经过SQL审计\",\"如果设置了sql_safe_updates=on，但是要删除一个小表的全部数据，可以在delete语句中加上where条件，比如where id >= 0。但是delete全表是很慢的，需要生成回滚日志，写redo log和bin log，所以，从性能的角度考虑，应该优先考虑使用truncate table或者drop table命令。\"]},\"622\":{\"h\":\"误删库/表\",\"t\":[\"如果使用了truncate/drop table和drop database命令删除的数据，就无法通过Flashback来恢复了，这是因为，即使我们配置了binlog_format=row，执行这三个命令时，记录的binlog还是statement格式。binlog里面就只有一个truncate/drop语句，这些信息是恢复不出来数据的。\",\"这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份binlog，在这两个条件都具备的情况下，假如有人中午12点删了一个库，恢复数据的流程如下：\",\"取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点\",\"用备份恢复出一个临时库\",\"从日志备份里面，取出凌晨0点之后的日志\",\"把这些日志，除了误删数据的语句外，全部应用到临时库\",\"这个流程的示意图如下：\",\"关于这个过程的说明：\",\"为了加速数据恢复，如果这个临时库上有多个数据库，那么可以在使用mysqlbinlog命令时，加上一个-database参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其它库日志的情况\",\"在应用日志的时候，需要跳过12点误操作的那个语句的binlog： \",\"如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用-stop-position参数执行到误操作之前的日志，然后再用-start-position从误操作之后的日志继续执行\",\"如果实例使用了GTID模式，就方便多了。假设误操作命令的GTID是gtid1，那么只需要执行set gtid_next=gtid1;begin;commit;，先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，就会自动跳过误操作的语句\",\"不过即使这样，使用mysqlbinlog方法恢复数据还是不够快，主要原因有两个：\",\"如果是误删表，最好就是只恢复这张表，也就是只重放这张表的操作，但是mysqlbinlog工具并不能指定只解析一个表的日志\",\"用mysqlbinlog解析出日志应用，应用日志的过程就只能是单线程。\",\"一种加速方式是，在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，这样：\",\"在start slave之前，先通过执行change replication filter replicate_do_table = (tbl_name) 命令，就可以让临时库只同步误操作的表\",\"这样做也可以用上并行复制技术，来加速整个数据恢复过程\",\"这个过程的示意图如下：\",\"图中binlog备份系统到线上备库有一条虚线，是指如果由于时间太久，备库上已经删除了临时实例需要的binlog的话，我们可以从binlog备份系统中找到需要的binlog，再放回备库中。假设，我们发现当前临时实例需要的binlog是从master.000005开始的，但是在备库上执行show binlogs显示的最小的binlog文件是master.000007，意味着少了两个binlog文件。这时，我们就需要去binlog备份系统中找到这两个文件，把之前删掉的binlog放回备库的操作如下：\",\"从备份系统下载master.000005和master.000006这两个文件，放到备库的日志目录下\",\"打开日志目录下的master.index文件，在文件开头加入两行，内容分别是“./master.000005”和“.、master.000006”\",\"重启备库，目的是要让备库重新识别这两个日志文件\",\"现在这个备库上就有了临时库需要的所有binlog了，建立主备关系，就可以正常同步了\",\"无论是把mysqlbinlog工具解析出的binlog文件应用到临时库，还是把临时库接到备库上，这两个方案的共同点是：误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用binlog的方式。也就是说，这两个方案都要求备份系统定期备份全量日志，而且需要确保binlog在被从本地删除之前已经做了备份，但是一个系统不可能无限制的备份日志，还需要根据成本和磁盘空间资源，设定一个日志保留的天数。\"]},\"623\":{\"h\":\"延迟复制备库\",\"t\":[\"虽然可以通过利用并行复制来加速恢复数据的过程，但是这个方案仍然存在“恢复时间不可控”的问题。如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的实例，在备份之后的第6天发生误操作，就需要恢复6天的日志，这个恢复时间可能是要按天来计算的。\",\"这种情况下，就可以考虑搭建延迟复制的备库，这个功能是MySQL5.6版本引入的。一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。\",\"延迟复制的备库是一种特殊的备库，通过CHANGE MASTER TO MASTER_DELAY=N命令，可以指定这个备库持续保持跟主库有N秒的延迟。比如将N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行，这个时候在备库上执行stop slave，再通过之前介绍的方法，跳过误操作的命令，就可以恢复出需要的数据，这样的话就得到了一个最多只需要追加1个小时，就可以恢复出数据的临时实例，也就缩短了整个数据恢复需要的时间。\"]},\"624\":{\"h\":\"预防误删库/表的方法\",\"t\":[\"账号分离。这样做的目的是，避免写错命令，比如： \",\"只给业务开发DML权限，而不给truncate/drop权限，而如果业务开发人员有DDL需求话，可以通过开发管理系统得到支持\",\"即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号\",\"制定操作规范。这样做的目的，是避免写错要删除的表名，比如： \",\"在删除数据表之前，必须先对表做改名操作，然后，观察一段时间，确保对业务无影响以后再删除这张表\",\"改表名的时候，要求给表名加固定的后缀（比如加_to_be_deleted），删除表的动作必须通过管理系统执行。并且，管理系统删除表的时候，只能删除固定后缀的表\"]},\"625\":{\"h\":\"rm删除数据\",\"t\":[\"其实，对于一个有高可用机制的MySQL集群来说，最不怕的就是rm删除数据了，只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作，这是，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。\",\"当然了，现在不止是DBA有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批量下线机器的操作，会让整个MySQL集群的所有节点都全军覆没，应对这种情况，只能尽量将备份跨机房，或者最好是跨城市保存。\"]},\"626\":{\"h\":\"自增主键\",\"t\":[\"自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑，但业务设计不应该依赖于自增主键的连续性，因为自增主键不能保证连续递增，有可能会出现“空洞”。为了便于说明，我们创建一个表t，其中id是自增主键字段，c是唯一索引：\",\"CREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), -- 注意这里设置了唯一约束 UNIQUE KEY `c` (`c`) ) ENGINE = InnoDB; \"]},\"627\":{\"h\":\"自增主键的存储\",\"t\":[\"在这个空表里面执行insert into values(null,1,1);插入一行数据，再执行show create table;命令，就可以看到如下结果：\",\"可以看到，表定义里面出现了AUTO_INCREMENT=2，表示下一次插入数时，如果需要自动生成自增值，会生成id=2。实际上，自增值并不是保存在表结构定义里的，表结构的定义是存放在后缀名为.frm的文件中，但是并不会保存自增值。\",\"不同的引擎对于自增值的保存策略是不同的：\",\"MyISAM引擎的自增值保存在数据文件中\",\"InnoDB引擎的自增值，其实是保存在了内存里，并且只有在MySQL8.0版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的值”，具体情况是： \",\"在MySQL5.7及之前的版本，自增值保存在内存里，并没有持久化，每次重启后，第一次打开表的时候，都会去找自增量的最大值max(id)，然后将max(id)+1作为这个表当前的自增值。举例来说，如果一个表当前数据行里最大的id是10，AUTO_INCREMENT=11,这个时候如果删除id=10的行，AUTO_INCREMENT还是11，但是如果马上重启实例，重启后这个表的AUTO_INCREMENT就会变成10，也就是说，MySQL重启可能会修改一个表的AUTO_INCREMENT的值\",\"在MySQL8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值\"]},\"628\":{\"h\":\"自增值的修改\",\"t\":[\"在MySQL里面，如果字段id被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：\",\"如果插入数据时id字段指定为0、null、或未指定值，那么就把这个表当前的AUTO_INCREMENT值填到自增字段\",\"如果插入数据时id字段执行了具体的值，就直接使用语句里指定的值\",\"根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同，假设某次要插入的值是X，当前的自增值是Y：\",\"如果X<Y，那么这个表的自增值不变\",\"如果X≥Y，就需要把当前自增值修改为新的自增值\",\"新的自增值的生成算法是：从auto_increment_offset开始，以auto_increment_increment为步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。其中，auto_increment_offset和auto_increment_increment是两个系统参数，分别用来表示自增的初始值和步长，默认值都是1。\",\"在一些场景下，使用的就不全是默认值。比如，双M的主备结构里要求双写的时候，我们就可能会设置auto_increment_increment=2，让一个库的自增id多是奇数，另一个库的自增id都是偶数，避免两个库生成的主键发生冲突。\",\"那么，当这两个参数都设置为1的时候，自增主键为什么还是不能保证连续呢？常见的导致自增主键的原因有：\",\"唯一键冲突\",\"事务回滚\",\"自增锁的优化\",\"接下来我们通过例子来说明这三点，假设表t里面已经有了（1，1，1）这条记录，此时执行如下插入命令：\",\"insert into t values(null, 1, 1); \",\"这条语句的执行流程如下：\",\"执行器调用InnoDB引擎接口写入一行，传入的这一行的值是（0，1，1）\",\"InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2\",\"将传入的行的值改成（2，1，1）\",\"将表的自增值改成3\",\"继续执行插入数据的操作，由于已经存在c=1的记录（字段c有唯一约束），所以报Duplicate key error，语句返回\",\"对应的流程图如下：\",\"可以看到，这个表的自增值改成3，是在真正执行插入数据的操作之前，这个语句真正执行的时候，因为碰到了唯一键c冲突，所以id=2这一行并没有插入成功，但也没有将自增值再该回去，所以，在这之后，再插入新的数据行是，拿到的自增id就是3，也就是说，出现了自增主键不连续的情况。\",\"完整的演示过程如下：\",\"可以看到，这个操作序列复现了一个自增主键id不连续的情况（没有id=2的行）。\",\"事务回滚也会发生类似的情况，以下语句序列可以说明这一点：\",\"insert into t values(null,1,1); begin; insert into t values(null,2,2); rollback; insert into t values(null,2,2); // 插入的行是 (3,2,2) \",\"那么当出现唯一键冲突和事务回滚的时候，MySQL为什么不会把表t的自增值改回去呢？答案是为了性能，假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请：\",\"假设事务A申请到了id=2，事务B申请到id=3，那么这个时候表t的自增值是4，之后继续执行\",\"事务B正确提交了，但事务A出现了唯一键冲突\",\"如果允许事务A把自增id回退，也就是把表t的当前自增值改回2，那么就会出现这样的情况：表里面已经有了id=3的行，而当前的自增id的值是2\",\"接下来，继续执行的其它事务就会申请到id=3，这时，就会出现插入语句报错“主键冲突”\",\"而为了解决这个主键冲突，有两种方法：\",\"每次申请id之前，先判断表里面是否已经存在这个id，如果存在，就跳过这个id。但是，这个方法的成本很高，因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断id是否存在\",\"把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id，这个方法的问题是锁的粒度太大，系统并发能力会大幅下降\",\"因此，InnoDB放弃了这个设计，语句执行失败也不会回退自增id，也正是这样，才只保证了自增id是递增的，但不保证是连续的。\"]},\"629\":{\"h\":\"自增锁的优化\",\"t\":[\"可以看到，自增id锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。其实，在MySQL5.1版本之前，并不是这样的，在MySQL5.0版本的时候，自增锁的范围是语句级别，也就是说，如果一个语句申请了一个表自增锁，这个锁会等执行结束以后才释放，显然，这会影响并发度。MySQL5.1.22版本引入了一个新策略，新增参数innodb_autoinc_lock_mode，默认值是1，并且：\",\"这个参数的值被设置为0时，表示采用之前MySQL5.0版本的策略，即语句执行结束后才释放锁\",\"这个参数的值被设置为1时： \",\"普通insert语句，自增锁在申请之后就马上释放\",\"类似insert...select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放\",\"这个参数的值被设置为2时，所有的申请自增主键的动作都是申请后就释放锁\",\"不难发现，insert...select语句在默认设置下，使用了语句级的锁，这主要是出于数据的一致性的考虑，假设有以下场景：\",\"在这个例子中，session A往表t1中插入了4行数据，然后session B创建了一个相同结构的表t2，然后两个session 同时执行向表t2中插入数据的操作，如果session B是申请了自增值以后马上就释放自增锁，就可能出现这样的情况：\",\"session B先插入了两个记录（1，1，1）、（2，2，2）\",\"然后，session A来申请自增id得到id=3，插入了（3，5，5）\",\"之后，session B继续执行，插入两条记录（4，3，3）、（5，4，4）\",\"假设数据库的binlog_format=statment，由于session是同时执行插入数据命令的，所以binlog里面对表t2的更新日志只有两种情况：要么先记session A的，那么先记session B的，但不论是哪一种，这个binlog在从库执行或者用来恢复临时实例，备库和临时实例里面，session B这个语句执行出来，生成的结果里面，id都是连续的，这时，这个库就发生了数据不一致。\",\"产生这个问题的原因是session B的insert语句，生成的id不连续，这个不连续的id，用statement格式的binlog来串行执行，是执行不出来的，要解决这个问题，有两种思路：\",\"让原库的批量插入数据语句，固定生成连续的id的值，所以，自增锁直到语句执行结束才释放，就是为了达到这个目的\",\"在binlog里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成，这种情况，其实就是innodb_autoinc_lock_mode设置为2，同时设置binlog_format=row\",\"因此，在生产上，尤其是有insert...select这种批量插入数据的场景时，从并发插入数据性能的角度考虑，可以考虑思路2，这样做，既能提升并发性，又不会出现数据一致性问题。\",\"普通的insert语句里面包含多个value值的情况下，即使innodb_autoinc_lock_mode设置为1，也不会等语句执行完成才释放锁，因为这类语句在申请自增id的时候，是可以精确计算出需要多少个id的，然后一次性申请，申请完成后锁就可以释放了。也就是说，批量插入数据的语句，之所以需要这么设置，是因为“不知道要预先申请多少个id”，既然预先不知道要申请多少个自增id，那么一种直接的想法就是需要一个时申请一个，但如果一个select...insert语句要插入10万行数据，按照这个逻辑的话就要申请10万次，显然，这种申请自增id的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。因此，对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：\",\"语句执行过程中，第一次申请自增id，会分配1个\",\"1个用完以后，这个语句第二次申请自增id，会分配2个\",\"2个用完以后，还是这个语句，第三次申请自增id，会分配4个\",\"以此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍\",\"insert...select，实际上往表t2插入了4行数据，但是，这四行数据是分三次申请的自增id，第一次申请到了id=1，第二次被分配了id=2和id=3，第三次被分配到id=4到id=7，由于这条语句实际只用上了4个id，所以id=5到id=7就被浪费掉了，之后，再执行insert into t2 values(null,5,)，实际上插入的数据就是（8，5，5）,这也导致出现了自增id不连续的情况。\"]},\"630\":{\"h\":\"自增主键的上限\",\"t\":[\"MySQL里有很多自增的id，每个自增id都是定义了初始值，然后不停地往上加步长，虽然自然数是没有上限的，但是在计算机里，只要定义了表示这个数的字节长度，那它就有上限。比如，无符号整型（unsigned int）是4个字节，上限就是223-1。\"]},\"631\":{\"h\":\"表定义自增值id\",\"t\":[\"表定义的自增值达到上限后的逻辑是：再申请下一个id时，得到的值保持不变，我们可以通过下面的语句序列验证：\",\"create table t(id int unsigned auto_increment primary key) auto_increment=4294967295; insert into t values(null); // 成功插入一行 4294967295 show create table t; /* CREATE TABLE `t` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4294967295; */ insert into t values(null); //Duplicate entry '4294967295' for key 'PRIMARY' \",\"可以看到，第一个insert语句插入数据成功后，这个表的AUTO_INCREMENT没有改变（还是4294967295），就导致了第二个insert语句又拿到相同的自增id值，再试图执行插入语句，报主键冲突错误。223-1（4294967295）不是一个特别大的数，对于一个频繁插入删除数据的表来说，是可能会被用完的，因此在建表的时候需要考察是否可能达到这个上限，如果有可能，就应该创建成8个字节bigint unsigned。\"]},\"632\":{\"h\":\"InnoDB系统自增row_id\",\"t\":[\"如果创建的InnoDB表没有指定主键，那么InnoDB会默认创建一个不可见的，长度为6个字节的row_id，InnoDB维护了一个全局的dict_sys.row_id的值，所有无主键的InnoDB表，每插入一行数据，都将当前的dict_sys.row_id的值作为要插入数据的row_id，然后把dict_sys.row_id的值加1。实际上，在代码实现时row_id是一个长度为8字节的无符号长整型（bigint unsigned），但是，InnoDB在设计时，给row_id留的只是6个字节的长度，这样写到数据表中只放了最后6个字节，所以row_id能写到数据表中的值，就有两个特征：\",\"row_id写入表中的值范围，是从0到248-1\",\"当dict_sys.row_id=248时，如果再有插入数据的行为要来申请row_id，拿到以后再取最后6个字节的话就是0\",\"也就是说，写入表的row_id是从0开始到248-1，达到上限后，下一个值就是0，然后继续循环，虽然248-1这个值本身已经很大了，但是如果一个MySQL实例跑得足够久得话，还是可能达到这个上限的，在InnoDB逻辑里，申请row_id=N后，就将这行数据写入表中，如果表中已经存在row_id=N的行，新写入的行就会覆盖原有的行。\",\"从这个角度来看，我们还是应该在InnoDB表中主动创建自增主键，因为表自增id达到上限后，再插入数据时报主键冲突错误，是更能被接受的，毕竟覆盖数据，就意味着数据丢失，影响的是数据可靠性，报主键冲突，是插入失败，影响的是可用性，而一般情况下，可靠性优于可用性。\"]},\"633\":{\"h\":\"Xid\",\"t\":[\"redo log和binlog有一个共同的字段叫做Xid，它在MySQL中是用来对应事务的。MySQL在内部维护了一个全局变量global_query_id，每次执行语句的时候将它赋值给Query_id，然后给这个变量加1。如果当前语句是这个事务执行的第一条语句，那么MySQL还会同时把query_id赋值给这个事务的Xid。global_query_id是一个纯内存变量，重启之后就会清零，因此，在同一个数据库实例中，不同事务的Xid也是有可能相同的。但是MySQL重启之后会生成新的binlog文件，这就保证了，同一个binlog文件里，Xid一定是唯一的。\",\"虽然MySQL重启不会导致同一个binlog里面出现两个相同的Xid，但是如果global_query_id达到上限后，就会继续从0开始计数，从理论上将，还是会出现同一个binlog里面出现相同Xid的场景。由于global_query_id定义的长度是8个字节，这个自增值得上限是264-1，要出现这样得情况，必须出现如下场景：\",\"执行一个事务，假设Xid是A\",\"接下来执行264次查询语句，让global_query_id回到A\",\"再启动一个事务，这个事务的Xid也是A\",\"不过，264这个值太大了，这种场景只会存在于理论中。\"]},\"634\":{\"h\":\"Innodb trx_id\",\"t\":[\"Xid和InnoDB的trx_id是两个容易混淆的概念。Xid是由server层维护的，InnoDB内部使用Xid，就是为了能够在InnoDB事务和server之间做关联。但是，InnoDB自己的trx_id，是另外维护的。InnoDB内部维护了一个max_trx_id全局变量，每次申请一个新的trx_id时，就获得max_trx_id的当前值，然后并将max_trx_id加1.\",\"InnoDB数据可见性的核心思想是：每一行数据都记录了更新它的trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的trx_id做对比。对于正在执行的事务，可以从infomation_schema.innodb_trx表中看到事务的trx_id。\",\"接下来，我们观察如下事务序列：\",\"session B中从innodb_trx表里查出来的两个字段，第二个字段trx_mysql_thread_id就是线程id。显示线程id，是为了说明这两次查询看到的事务对应的线程id都是5，也就是session A所在的线程。可以看到，T2时刻显示的trx_id是一个很大的数；T4时刻显示的trx_id是1289，看上去是一个比较正常的数字，这是因为，在T1时刻，session A还没有涉及到更新，是一个只读事务，而对于只读事务，InnoDB并不会分配trx_id，也就是说：\",\"在T1时刻，trx_id的值其实就是0，而这个很大的数，只是显示用的\",\"直到session A在T3时刻执行insert语句的时候，InnoDB才真正分配了trx_id。所以，T4时刻，session B查到的这个trx_id的值就是1289\",\"需要注意的是，除了显而易见的修改类语句外，如果在select语句后面加上for update，这个事务也不是只读事务。\",\"T2时刻这个数字是每次查询的时候由系统临时计算出来的。它的算法是：把当前事务的trx变量的指针地址转成整数，再加上248，使用这个算法，就可以保证两点：\",\"因为同一个只读事务在执行期间，它的指针地址是不会变的，所以不论是在innodb_trx还是在innodb_locks表里，同一个只读事务查出来的trx_id就会是一样的\",\"如果有并行的多个只读事务，每个事务trx变量的指针地址肯定不同。这样，不同的并发只读事务，查出来的trx_id就是不同的\",\"而在显示值里面加上248，目的是为了保证只读事务显示的trx_id值比较大，正常情况下就会区别于读事务的id。但是trx_id跟row_id的逻辑类似，定义长度也是8个字节。因此，在理论上还是可能出现一个读写事务于一个只读事务显示trx_id相同的情况，不过这个概率很低，并且没有什么实质危害。\",\"那么，只读事务不分配trx_id有什么好处呢？\",\"一个好处是，这样做可以减少事务视图里面活跃事务数组的大小。因为当前正在运行的只读事务，是不影响数据的可见性判断的。所以，在创建事务的一致性视图时，InnoDB就只需要拷贝读写事务的trx_id\",\"另一好处是，可以减少trx_id的申请次数。在InnoDB里，即使只是执行一个普通的select语句，在执行过程中，也是要对应一个只读事务的。所以只读事务优化后，普通的查询语句不需要申请trx_id，就大大减少了并发事务申请trx_id的锁冲突\",\"由于只读事务不分配trx_id，一个自然而然的结果就是trx_id的增加速度变慢了。但是，max_trx_id会持久化存储，重启也不会重置为0，那么从理论上讲，只要一个MySQL服务跑得足够久，就可能出现max_trx_id达到248-1的上限，然后从0开始的情况。当达到这个状态后，MySQL就会持续出现一个脏读的bug。\",\"首先我们需要把当前的max_trx_id先修成248-1。注意：这里使用的是可重复读隔离级别，具体的操作流程如下：\",\"由于此时系统的max_trx_id设置成了248-1，所以在session A启动的事务TA的低水位就是248-1，在T2时刻，session B执行第一条update语句的事务id就是248-1，而第二条update语句的事务id就是0了，这条update语句执行后生成的数据版本上的trx_id就是0，在T3时刻，session A执行select语句的时候，判断可见性发现，c=3这个数据版本的trx_id，小于事务TA的低水位，因此认为这个数据可见，但，这个是脏读，由于低水位值会持续增加，而事务id从0开始计数，就导致了系统在这个时刻之后，所有的查询都会出现脏读的。而且，MySQL重启时max_trx_id也不会清0，也就是说重启MySQL，这个bug仍然存在。\",\"假设一个MySQL实例的TPS是每秒50万，持续这个压力的话，在17.8年后，就会出现这个情况。如果TPS更高，这个年限自然也就更短了。但是，从MySQL的真正开始流行到现在，恐怕都还没有实例跑到过这个上限。不过，这个bug是只要MySQL实例服务时间够长，就必然会出现。\"]},\"635\":{\"h\":\"thread_id\",\"t\":[\"thread_id的逻辑是，系统保存了一个全局变量thread_id_counter，每新建一个连接，就将thread_id_counter赋值给这个新连接的线程变量。thread_id_counter定义的大小是4个字节，因此达到232-1后，它就会重置为0，然后继续增加。但是，但是，你不会在show processlist里看到两个相同的thread_id，这是因为MySQL设计了一个唯一数组的逻辑，给新线程分配thread_id的时候，逻辑代码如下：\",\"do { new_id = thread_id_counter++; } while (!thread_ids.insert_unique(new_id).second); \"]},\"636\":{\"h\":\"自增主键总结\",\"t\":[\"总的来说，每种自增id有各自的应用场景，在达到上限后的表现也不同：\",\"表的自增主键id达到上限后，再申请时它的值就不会改变，进而导致继续插入数据时报主键冲突的错误\",\"row_id达到上限后，则会归0再重新递增，如果出现相同的row_id，后写入的数据会覆盖之前的数据\",\"Xid只需要不在同一个binlog文件中出现重复值接口，但是概率极小，可以忽略不计\",\"InnoDB的max_trx_id递增值MySQL每次重启都会被保存起来，所以上文中脏读的例子就是一个必现的bug\",\"thread_id是使用中最常见的，也是处理的最好的自增id逻辑\",\"[1] MySQL实战45讲\",\"[2] MySQL5.7手册\"]},\"637\":{\"h\":\"MySQL性能优化\"},\"638\":{\"h\":\"MySQL索引结构\",\"t\":[\"索引是帮助MySQL高效获取数据的排好序的数据结构。\",\"常见索引的数据结构：\",\"二叉树\",\"红黑树\",\"Hash表\",\"B-Tree\",\"索引的图示：\"]},\"639\":{\"h\":\"B-Tree\",\"t\":[\"叶子结点具有相同的深度，叶子结点的指针为空\",\"所有索引元素不重复\",\"结点中的数据索引从左到右递增排列\"]},\"640\":{\"h\":\"B+Tree\",\"t\":[\"非叶子结点不存储data，只存储索引（冗余），可以放更多的索引\",\"叶子结点包含所有索引字段\",\"叶子结点用指针连接，提高区间访问的性能\",\"查询MySQL页大小：\",\"show global status like 'innodb_page_size'; \",\"默认页大小是16KB，每个非叶子结点可以放16KB/（8+6）B大约1170个元素，每个页可以放1170*1170再乘以16KB约2000多万的数据。\"]},\"641\":{\"h\":\"Hash\",\"t\":[\"对索引的key进行一次hash计算就可以定位出数据存储的位置。\",\"很多时候Hash索引要比B+树索引更高效\",\"仅能满足“=”，“IN”，不支持范围查询\",\"hash冲突问题\"]},\"642\":{\"h\":\"索引实现\",\"t\":[\"InnoDB索引实现（聚集）\",\"表数据文件本身就是按B+Tree组织的一个索引结构文件\",\"聚集索引-叶子结点包含了完整的数据记录\",\"为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？\",\"如果没有主键，InnoDB引擎会自动选择所有数据都不相等的列，如果没有所有数据都不相等的列，则会使用rowId来构建B+树。使用整型的主键可以方便的比较大小，另外整型的存储空间也比较小。不是自增的主键在插入的时候，B+树可能会出现分裂和平衡的现象，从而影响性能。\",\"为什么非主键索引结构的叶子结点存储的是主键值？\",\"主要是基于一致性和节省存储空间的考虑。\",\"MyISAM索引文件和数据文件是分离的（非聚集）：\",\"多列索引的结构：\",\"会按照索引列的顺序来维护B+树，在上面这个例子中，InnoDB会先排好name，再比较age，再比较position，如果有一个字段可以排序，就不会再看后面的字段。\"]},\"643\":{\"h\":\"EXPLAIN详解\",\"t\":[\"DROP TABLE IF EXISTS `actor`; CREATE TABLE `actor` ( `id` INT ( 11 ) NOT NULL, `name` VARCHAR ( 45 ) DEFAULT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = INNODB DEFAULT CHARSET = utf8; INSERT INTO `actor` ( `d`, `name`, `update_time` ) VALUES (1, 'a', '2017‐12‐22 15:27:18' ),(2, 'b', '2017‐12‐22 5:27:18' ), (3, 'c', '2017‐12‐22 5:27:18' ); DROP TABLE IF EXISTS `film`; CREATE TABLE `film` ( `id` INT ( 11 ) NOT NULL AUTO_INCREMENT, `name` VARCHAR ( 10 ) DEFAULT NULL, PRIMARY KEY ( `id` ), KEY `idx_name` ( `name` ) ) ENGINE = INNODB DEFAULT CHARSET = utf8; INSERT INTO `film` ( `id`, `name` ) VALUES ( 3, '=film0' ),(1,'=film1' ),( 2, 'film2' ); DROP TABLE IF EXISTS `film_actor`; CREATE TABLE `film_actor` ( `id` INT ( 11 ) NOT NULL, `film_id` INT ( 11 ) NOT NULL, `actor_id` INT ( 11 ) NOT NULL, `remark` VARCHAR ( 255 ) DEFAULT NULL, PRIMARY KEY ( `id` ), KEY `idx_film_actor_id` ( `film_id`, `actor_id` ) ) ENGINE = INNODB DEFAULT CHARSET = utf8; INSERT INTO `film_actor` ( `id`, `film_id`, `actor_id` ) VALUES( 1, 1, 1 ),(2, 1, 2 ),(3,2,1 ); \",\"Filtered/100可以估算出将要和explain中前一个表进行连接的行数（前一个表指explain中id值比当前表id值小的表）。\",\"explainpartitions：相比explain多了个partitions字段，如果查询是基于分区表的话，会显示查询将访问的分区。\"]},\"644\":{\"h\":\"EXPLAIN中的列\"},\"645\":{\"h\":\"id列\",\"t\":[\"select后面的是子查询，from后面的是派生表查询。\"]},\"646\":{\"h\":\"type列\",\"t\":[\"system>const\",\"EXPLAIN SELECT min( id ) FROM film; \",\"EXPLAIN EXTENDED SELECT * FROM( SELECT * FROM film WHERE id = 1 ) tmp; \",\"show warnings; \",\"eq_ref\",\"EXPLAIN SELECT * FROM film_actor LEFT JOIN film ON film_actor.film_id = film.id; \",\"range\",\"EXPLAIN SELECT * FROM actor WHERE id > 1; \",\"index\",\"EXPLAIN SELECT * FROM film; \"]},\"647\":{\"h\":\"最佳实践\",\"t\":[\"CREATE TABLE `employees` (`id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(24) NOT NULL DEFAULT '' COMMENT '姓名', `age` int(11) NOT NULL DEFAULT '0' COMMENT '年龄', `position` varchar(20) NOT NULL DEFAULT '' COMMENT '职位', `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '入职时间', PRIMARY KEY(`id`), KEY`idx_name_age_position` (`name`,`age`,`position`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='员工记录表'; INSERT INTO employees(name,age,position,hire_time) VALUES('LiLei',22,'manager',NOW()); INSERT INTO employees(name,age,position,hire_time) VALUES('HanMeimei', 23,'dev',NOW()); INSERT INTO employees(name,age,position,hire_time) VALUES('Lucy',23,'dev',NOW()); \"]},\"648\":{\"h\":\"SQL执行底层原理\"},\"649\":{\"h\":\"连接器\"},\"650\":{\"h\":\"词法分析器\",\"t\":[\"SQL语句的分析分为词法分析与语法分析，mysql的词法分析由MySQLLex（MySQL自己实现的）完成，语法分析由Bison生成。除了Bison外，Java当中也有开源的词法结构分析工具，例如Antlr4，ANTLR从语法生成一个解析器，可以构建和遍历解析树。\"]},\"651\":{\"h\":\"优化器\",\"t\":[\"经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要经过优化器的处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面的语句，这个语句是执行两个表的join：\",\"select * from test1 join test2 using(ID) where test1.name=jyc and test2.name=jyc; \",\"既可以从表test1里面取出name=jyc记录的ID值，再根据ID值关联到表test2，再判断test2里面的name的值是否等于jyc；也可以从表test2里面取出name=jyc的记录的ID值，再根据ID值关联到test1，再判断test1里面name的值是否等于jyc。\",\"这两种执行方法的逻辑是一样的，但是执行的效率会有所不同，而优化器的作用就是决定选择使用哪一个方案，优化器阶段完成后，这个语句的执行方法就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等。\"]},\"652\":{\"h\":\"执行器\"},\"653\":{\"h\":\"bin-log归档\"},\"654\":{\"h\":\"索引优化实践\",\"t\":[\"参考：\",\"https://note.youdao.com/ynoteshare/index.html?id=d2e8a0ae8c9dc2a45c799b771a5899f6&type=note&time=1678024153495\",\"https://note.youdao.com/share/?id=df15aba3aa76c225090d04d0dc776dd9&type=note\"]},\"655\":{\"h\":\"索引下推\",\"t\":[\"数据准备如下。\",\"CREATE TABLE `employees` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(24) NOT NULL DEFAULT '' COMMENT '姓名', `age` int(11) NOT NULL DEFAULT '0' COMMENT '年龄', `position` varchar(20) NOT NULL DEFAULT '' COMMENT '职位', `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '入职时间', PRIMARY KEY (`id`), KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='员工记录表'; INSERT INTO employees(name,age,position,hire_time) VALUES('LiLei',22,'manager',NOW()); INSERT INTO employees(name,age,position,hire_time) VALUES('HanMeimei', 23,'dev',NOW()); INSERT INTO employees(name,age,position,hire_time) VALUES('Lucy',23,'dev',NOW()); drop procedure if exists insert_emp; delimiter ;; create procedure insert_emp() begin declare i int; set i=1; while(i<=100000)do insert into employees(name,age,position) values(CONCAT('zhuge',i),i,'dev'); set i=i+1; end while; end;; delimiter ; call insert_emp(); \",\"对于辅助的联合索引（name，age、position），正常情况按照最左前缀原则，select * from employess where name like 'LiLei%' and age = 22 and position = 'manager' ，这种情况只会走name字段索引，因为根据name字段过滤完，得到的索引行里的age和position是无序的，无法很好的利用索引。\",\"在MySQL5.6之前的版本，这个查询只能在联合索引里匹配到名字是'LiLei%'开头的索引，然后用这些索引对应的主键逐个回表，到主键索引上找出相应的记录，再对比age和position这两个字段的值是否符合。\",\"MySQL5.6引入了索引下推优化，可以在索引遍历过程中，对索引包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，可以有效的减少索引下推优化后，上面那个查询在联合索引里匹配到名字是'LiLei%'开头的索引之后，同时还会在索引里过滤age和position这两个字段，然后用过滤完剩下的索引对应的主键id再回表查整行数据。\",\"索引下推会减少回表次数，对于InnoDB引擎的表索引下推只能用于二级索引，InnoDB的主键索引（聚簇索引）树叶子结点上保存的是全行数据，所以这个时候索引下推并不会减少查询全行数据的效果。\"]},\"656\":{\"h\":\"如何选择合适的索引\",\"t\":[\"set session optimizer_trace=\\\"enabled=on\\\",end_markers_in_json=on; --开启trace select * from employees where name > 'a' order by position; SELECT * FROM information_schema.OPTIMIZER_TRACE; \",\"查看trace字段：\",\"{ \\\"steps\\\": [ { \\\"join_preparation\\\": { --第一阶段：SQL准备阶段，格式化sql \\\"select#\\\": 1, \\\"steps\\\": [ { \\\"expanded_query\\\": \\\"/* select#1 */ select `employees`.`id` AS `id`,`employees`.`name` AS `name`,`employees`.`age` AS `age`,`employees`.`position` AS `position`,`employees`.`hire_time` AS `hire_time` from `employees` where (`employees`.`name` > 'a') order by `employees`.`position`\\\" } ] /* steps */ } /* join_preparation */ }, { \\\"join_optimization\\\": { --第二阶段：SQL优化阶段 \\\"select#\\\": 1, \\\"steps\\\": [ { \\\"condition_processing\\\": { --条件处理 \\\"condition\\\": \\\"WHERE\\\", \\\"original_condition\\\": \\\"(`employees`.`name` > 'a')\\\", \\\"steps\\\": [ { \\\"transformation\\\": \\\"equality_propagation\\\", \\\"resulting_condition\\\": \\\"(`employees`.`name` > 'a')\\\" }, { \\\"transformation\\\": \\\"constant_propagation\\\", \\\"resulting_condition\\\": \\\"(`employees`.`name` > 'a')\\\" }, { \\\"transformation\\\": \\\"trivial_condition_removal\\\", \\\"resulting_condition\\\": \\\"(`employees`.`name` > 'a')\\\" } ] /* steps */ } /* condition_processing */ }, { \\\"substitute_generated_columns\\\": { } /* substitute_generated_columns */ }, { \\\"table_dependencies\\\": [ --表依赖详情 { \\\"table\\\": \\\"`employees`\\\", \\\"row_may_be_null\\\": false, \\\"map_bit\\\": 0, \\\"depends_on_map_bits\\\": [ ] /* depends_on_map_bits */ } ] /* table_dependencies */ }, { \\\"ref_optimizer_key_uses\\\": [ ] /* ref_optimizer_key_uses */ }, { \\\"rows_estimation\\\": [ --预估表的访问成本 { \\\"table\\\": \\\"`employees`\\\", \\\"range_analysis\\\": { \\\"table_scan\\\": { --全表扫描情况 \\\"rows\\\": 10123, --扫描行数 \\\"cost\\\": 2054.7 --查询成本 } /* table_scan */, \\\"potential_range_indexes\\\": [ --查询可能使用的索引 { \\\"index\\\": \\\"PRIMARY\\\", --主键索引 \\\"usable\\\": false, \\\"cause\\\": \\\"not_applicable\\\" }, { \\\"index\\\": \\\"idx_name_age_position\\\", --辅助索引 \\\"usable\\\": true, \\\"key_parts\\\": [ \\\"name\\\", \\\"age\\\", \\\"position\\\", \\\"id\\\" ] /* key_parts */ } ] /* potential_range_indexes */, \\\"setup_range_conditions\\\": [ ] /* setup_range_conditions */, \\\"group_index_range\\\": { \\\"chosen\\\": false, \\\"cause\\\": \\\"not_group_by_or_distinct\\\" } /* group_index_range */, \\\"analyzing_range_alternatives\\\": { --分析各个索引使用成本 \\\"range_scan_alternatives\\\": [ { \\\"index\\\": \\\"idx_name_age_position\\\", \\\"ranges\\\": [ \\\"a < name\\\" --索引使用范围 ] /* ranges */, \\\"index_dives_for_eq_ranges\\\": true, \\\"rowid_ordered\\\": false, --使用该索引获取的记录是否按照主键排序 \\\"using_mrr\\\": false, \\\"index_only\\\": false, --是否使用覆盖索引 \\\"rows\\\": 5061, --索引扫描行数 \\\"cost\\\": 6074.2, --索引使用成本 \\\"chosen\\\": false, --是否选择该索引 \\\"cause\\\": \\\"cost\\\" } ] /* range_scan_alternatives */, \\\"analyzing_roworder_intersect\\\": { \\\"usable\\\": false, \\\"cause\\\": \\\"too_few_roworder_scans\\\" } /* analyzing_roworder_intersect */ } /* analyzing_range_alternatives */ } /* range_analysis */ } ] /* rows_estimation */ }, { \\\"considered_execution_plans\\\": [ { \\\"plan_prefix\\\": [ ] /* plan_prefix */, \\\"table\\\": \\\"`employees`\\\", \\\"best_access_path\\\": { --最优访问路径 \\\"considered_access_paths\\\": [ --最终选择的访问路径 { \\\"rows_to_scan\\\": 10123, \\\"access_type\\\": \\\"scan\\\", --访问类型：为scan，全表扫描 \\\"resulting_rows\\\": 10123, \\\"cost\\\": 2052.6, \\\"chosen\\\": true, --确定选择 \\\"use_tmp_table\\\": true } ] /* considered_access_paths */ } /* best_access_path */, \\\"condition_filtering_pct\\\": 100, \\\"rows_for_plan\\\": 10123, \\\"cost_for_plan\\\": 2052.6, \\\"sort_cost\\\": 10123, \\\"new_cost_for_plan\\\": 12176, \\\"chosen\\\": true } ] /* considered_execution_plans */ }, { \\\"attaching_conditions_to_tables\\\": { \\\"original_condition\\\": \\\"(`employees`.`name` > 'a')\\\", \\\"attached_conditions_computation\\\": [ ] /* attached_conditions_computation */, \\\"attached_conditions_summary\\\": [ { \\\"table\\\": \\\"`employees`\\\", \\\"attached\\\": \\\"(`employees`.`name` > 'a')\\\" } ] /* attached_conditions_summary */ } /* attaching_conditions_to_tables */ }, { \\\"clause_processing\\\": { \\\"clause\\\": \\\"ORDER BY\\\", \\\"original_clause\\\": \\\"`employees`.`position`\\\", \\\"items\\\": [ { \\\"item\\\": \\\"`employees`.`position`\\\" } ] /* items */, \\\"resulting_clause_is_simple\\\": true, \\\"resulting_clause\\\": \\\"`employees`.`position`\\\" } /* clause_processing */ }, { \\\"reconsidering_access_paths_for_index_ordering\\\": { \\\"clause\\\": \\\"ORDER BY\\\", \\\"steps\\\": [ ] /* steps */, \\\"index_order_summary\\\": { \\\"table\\\": \\\"`employees`\\\", \\\"index_provides_order\\\": false, \\\"order_direction\\\": \\\"undefined\\\", \\\"index\\\": \\\"unknown\\\", \\\"plan_changed\\\": false } /* index_order_summary */ } /* reconsidering_access_paths_for_index_ordering */ }, { \\\"refine_plan\\\": [ { \\\"table\\\": \\\"`employees`\\\" } ] /* refine_plan */ } ] /* steps */ } /* join_optimization */ }, { \\\"join_execution\\\": { --第三阶段：SQL执行阶段 \\\"select#\\\": 1, \\\"steps\\\": [ ] /* steps */ } /* join_execution */ } ] /* steps */ } \",\"结论：全表扫描的成本低于索引扫描，所以mysql最终选择全表扫描\",\"select * from employees where name > 'zzz' order by position; SELECT * FROM information_schema.OPTIMIZER_TRACE; \",\"查看trace字段可知索引扫描的成本低于全表扫描，所以mysql最终选择索引扫描。\",\"set session optimizer_trace=\\\"enabled=off\\\"; --关闭trace \"]},\"657\":{\"h\":\"常见SQL优化\",\"t\":[\"优化总结：\",\"filesort文件排序方式：\",\"单路排序\",\"是一次性去除满足条件行的所有字段，然后在sort buffer中进行排序；\",\"双路排序\",\"首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行ID，然后在sort buffer中进行排序，排序完后需要再次取回其它需要的字段\",\"MySQL通过比较系统变量max_length_for_sort_data（默认1024字节）的大小和需要查询的字段的总大小来判断使用哪种排序模式。\",\"如果字段的总长度小于max_length_for_sort_data，那么就会使用单路排序模式\",\"如果字段的总长度大于max_length_for_sort_data，那么就会使用双路排序模式\",\"以下面的查询为例：\",\"set session optimizer_trace=\\\"enabled=on\\\",end_markers_in_json=on; --开启trace select * from employees where name = 'zhuge' order by position; select * from information_schema.OPTIMIZER_TRACE; \",\"trace排序部分结果：\",\"\\\"join_execution\\\": { --Sql执行阶段 \\\"select#\\\": 1, \\\"steps\\\": [ { \\\"filesort_information\\\": [ { \\\"direction\\\": \\\"asc\\\", \\\"table\\\": \\\"`employees`\\\", \\\"field\\\": \\\"position\\\" } ] /* filesort_information */, \\\"filesort_priority_queue_optimization\\\": { \\\"usable\\\": false, \\\"cause\\\": \\\"not applicable (no LIMIT)\\\" } /* filesort_priority_queue_optimization */, \\\"filesort_execution\\\": [ ] /* filesort_execution */, \\\"filesort_summary\\\": { --文件排序信息 \\\"rows\\\": 10000, --预计扫描行数 \\\"examined_rows\\\": 10000, --参与排序的行 \\\"number_of_tmp_files\\\": 3, --使用临时文件的个数，这个值如果为0代表全部使用的sort_buffer内存排序，否则使用的磁盘文件排序 \\\"sort_buffer_size\\\": 262056, --排序缓存的大小，单位Byte \\\"sort_mode\\\": \\\"<sort_key, packed_additional_fields>\\\" --排序方式，这里用的单路排序 } /* filesort_summary */ } ] /* steps */ } /* join_execution */ \",\"set max_length_for_sort_data = 10; --employees表所有字段长度总和肯定大于10字节 select * from employees where name = 'zhuge' order by position; select * from information_schema.OPTIMIZER_TRACE; \",\"trace排序部分结果：\",\" \\\"join_execution\\\": { \\\"select#\\\": 1, \\\"steps\\\": [ { \\\"filesort_information\\\": [ { \\\"direction\\\": \\\"asc\\\", \\\"table\\\": \\\"`employees`\\\", \\\"field\\\": \\\"position\\\" } ] /* filesort_information */, \\\"filesort_priority_queue_optimization\\\": { \\\"usable\\\": false, \\\"cause\\\": \\\"not applicable (no LIMIT)\\\" } /* filesort_priority_queue_optimization */, \\\"filesort_execution\\\": [ ] /* filesort_execution */, \\\"filesort_summary\\\": { \\\"rows\\\": 10000, \\\"examined_rows\\\": 10000, \\\"number_of_tmp_files\\\": 2, \\\"sort_buffer_size\\\": 262136, \\\"sort_mode\\\": \\\"<sort_key, rowid>\\\" --排序方式，这里用的双路排序 } /* filesort_summary */ } ] /* steps */ } /* join_execution */ \",\" set session optimizer_trace=\\\"enabled=off\\\"; --关闭trace \",\"单路排序的详细过程：\",\"从索引name找到第一个满足name='zhuge'条件的主键id\",\"根据主键id取出整行，取出所有字段的值，存入sort buffer中\",\"从索引name找到下一个满足name='zhuge'条件的主键id\",\"重复步骤2，步骤3直到不满足name='zhuge'\",\"对sort_buffer中的数据按照字段position排序\",\"返回结果给客户端\",\"双路排序的详细过程：\",\"从索引name找到第一个满足name='zhuge'的主键id\",\"根据主键id取出整行，把排序字段position和主键id这两个字段放到sort buffer中\",\"从索引name取出下一个满足name='zhuge'记录的主键id\",\"重复3、4直到不满足name='zhuge'\",\"对sort_buffer中的字段position和主键id按照字段position进行排序\",\"遍历排序号的id和字段position，按照id的值回到原表中取出所有字段的值返回给客户端\",\"对于单路排序和双路排序两种模式，单路排序会把需要查询的字段都放到sort buffer中，而双路排序只会把主键和需要排序的字段放到sort buffer中进行排序，然后通过主键回到原表查询需要的字段。\",\"如果MySQL排序内存sort buffer配置的比较小并且没有条件继续增加了，可以适当将max_length_for_sort_data配置小点，让优化器选择使用双路排序算法，可以在sort buffer中一次排序更多的行，只是需要再根据主键回到原表取数据。如果MySQL排序内存有条件可以配置的比较大，可以适当增大max_length_for_sort_data的值，让优化器选择全字段排序（单路排序），把需要的字段放到sort buffer中，这样排序后就会直接从内存里返回查询结果了。总而言之，MySQL通过max_length_for_sort_data这个参数来控制排序，在不同场景使用不同的排序模式，从而提升排序效率。\"]},\"658\":{\"h\":\"索引设计原则\",\"t\":[\"代码线上，索引后上\",\"联合索引尽量覆盖条件\",\"不要在小基数字段上建立索引\",\"长字符串我们可以采用前缀索引\",\"where与order by冲突时优先where\",\"基于慢sql查询做优化\"]},\"659\":{\"h\":\"分页查询优化\",\"t\":[\"对于自增且连续的主键排序的分页查询：\",\"select * from employees ORDER BY name limit 90000,5; \",\"可以优化为：\",\"select * from employees where id > 90000 limit 5; \",\"需要注意的是，这样的优化策略并不实用，因为当表中某些记录被删后，主键空缺，会导致结果不一致。另外如果原SQL是order by非主键的字段，上面的方法也会导致两条SQL的结果不一致，所以这种改写得满足以下两个条件：\",\"主键自增且连续\",\"结果是按照主键排序的\",\"根据非主键字段排序的分页查询，查询的SQL如下：\",\"select * from employees ORDER BY name limit 90000,5; \",\"EXPLAIN select * from employees ORDER BY name limit 90000,5; \",\"发现并没有使用name字段的索引（key字段对应的值为null），原因在于扫描整个索引并没有查找到没索引的行（可能要遍历多个索引树）的成本比扫描全表的成本更高，所以优化器放弃使用索引。优化的关键是让排序时返回的字段经可能少，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录，将SQL改写如下：\",\"select * from employees e inner join (select id from employees order by name limit 90000,5) ed on e.id = ed.id; \",\"需要的结果与原 SQL 一致，执行时间减少了一半以上，我们再对比优化前后sql的执行计划：\"]},\"660\":{\"h\":\"Join关联查询优化\",\"t\":[\"-- 示例表： CREATE TABLE `t1` ( `id` int(11) NOT NULL AUTO_INCREMENT, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_a` (`a`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; create table t2 like t1; -- 插入一些示例数据 -- 往t1表插入1万行记录 drop procedure if exists insert_t1; delimiter ;; create procedure insert_t1() begin declare i int; set i=1; while(i<=10000)do insert into t1(a,b) values(i,i); set i=i+1; end while; end;; delimiter ; call insert_t1(); -- 往t2表插入100行记录 drop procedure if exists insert_t2; delimiter ;; create procedure insert_t2() begin declare i int; set i=1; while(i<=100)do insert into t2(a,b) values(i,i); set i=i+1; end while; end;; delimiter ; call insert_t2(); \",\"MySQL的表关联常见的有两种算法：\",\"Nested-Loop Join（嵌套循环连接）算法\",\"Block Nested-Loop Join（基于块的嵌套循环连接）算法\"]},\"661\":{\"h\":\"嵌套循环连接算法\",\"t\":[\"一次一行循环地从第一张表（成为驱动表）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（被驱动表）里取出满足条件的行，然后取出两张表的结果合集。\",\"EXPLAIN select * from t1 inner join t2 on t1.a= t2.a; \",\"一般在join语句中，如果执行计划Extra中未出现Using join buffer则表示使用的join算法是NLJ。\",\"整个过程会读取t2表的所有数据（扫描100行），然后遍历每行数据中字段a的值，根据t2表中的值索引扫描t1表中的对应行（扫描100次t1表的索引，1次扫描可以认为最终只扫描t1表一行完整数据，也就是总共t1表也扫描了100行）。因此整个过程扫描了200行。\",\"如果被驱动表的关联字段没有索引，mysql会Block Nested-Loop Join算法。\"]},\"662\":{\"h\":\"基于块的嵌套循环查询\",\"t\":[\"把驱动表的数据读入到join_buffer中，然后扫描被驱动表，把被驱动表的每一行取出来跟join_buffer中的数据做对比。\",\"EXPLAIN select * from t1 inner join t2 on t1.b= t2.b; \",\"整个过程对表t1和t2都做了一次全表扫描，因此扫描的总行数为10000（表t1的数据总量）+100（表t2的数据总量）=10100。并且join_buffer里的数据是无序的，因此对表t1中的每一行，都要做100次判断，所以内存中的判断次数是100*10000=100万次。\",\"join_buffer的大小是由参数join_buffer_size来设定的，默认值是256k。如果放不下表t2的所有数据的话，会分段放。比如t2表有1000行记录，join_buffer一次只能放800行数据，那么执行过程是先往join_buffer里放800行记录，然后从t1表里取数据跟join_buffer中的数据对比得到部分结果，然后情况buffer，再放入t2表剩余200行记录，再次从t1表里取数据跟join_buffer中数据对比，所以就多扫描了一次t1表。\",\"被驱动表的关联字段没有索引为什么会选择BNL算法而不是用NLJ呢？\",\"如果上面第二条SQL使用NLJ，那么扫描行树为100*10000=100万次，这个是磁盘扫描。\",\"很显然，用BNL磁盘扫描次数少很多，相比于磁盘扫描，BNL的内存计算也会快得多，因此MySQL对于被驱动表的关联字段没有索引的关联查询，一般都会使用BNL算法，如果有索引一般选择NLJ算法，有索引的情况下，NLJ算法比BNL算法性能更高。\",\"可以总结一下，对于关联sql的优化策略：\",\"关联字段加索引\",\"小表驱动大表·和exsits优化\",\"select * from A where id in (select id from B) \",\"优化为：\",\"select * from A where exists (select 1 from B where B.id = A.id) \",\"优化原则：小表驱动大表，即小的数据集驱动大的数据集。\"]},\"663\":{\"h\":\"count(*)查询优化\",\"t\":[\"-- 临时关闭mysql查询缓存，为了查看sql多次执行的真实时间 set global query_cache_size=0; set global query_cache_type=0; EXPLAIN select count(1) from employees; EXPLAIN select count(id) from employees; EXPLAIN select count(name) from employees; EXPLAIN select count(*) from employees; \",\"这四种查询的效率比较：\",\"字段有索引\",\"字段无索引\",\"count(1)和count(字段)执行过程类似，\",\"count(*)的优化常见优化方法有四种。\",\"查询MySQL自己维护的总行数，对于myisam存储引擎的表不做不带where条件的count查询性能是很高的，因为myisam存储的引擎的表的总行数会被mysql存储在磁盘上，查询不需要计算：\",\"对于innodb存储引擎的表mysql不会存储表的总记录行数（因为有MVCC机制），查询count需要实时计算。\",\"也可以使用show table status来优化查询，如果值需要知道表的总行数的估计值可以用如下sql查询，性能很高：\",\"也可以将总数维护到Redis里，插入或删除数据行的时候同时维护Redis里面的表总行数key的计数值（用incr或decr命令），但是这种方式可能不准，很难保证操作和Redis操作的事务的一致性。\",\"最后一种方式是，插入或删除表数据行的时候同时维护计数表，让他们在同一个事务里面操作。\"]},\"664\":{\"h\":\"MySQL数据类型的选择\",\"t\":[\"在MySQL中，选择正确的数据类型，对于性能至关重要。一般应该遵循下面两步：\",\"确定合适的大类型：数字、字符串、时间、二进制；\",\"确定具体的类型：有无符号、取值范围、变长定长等。\",\"在MySQL数据类型设置方面，尽量用更小的数据类型，因为它们通常有更好的性能，花费更少的硬件资源。并且，尽量把字段定义为NOT NULL，避免使用NULL。\"]},\"665\":{\"h\":\"数值类型\",\"t\":[\"类型\",\"大小\",\"范围（有符号）\",\"范围（无符号）\",\"用途\",\"TINYINT\",\"1 字节\",\"(-128, 127)\",\"(0, 255)\",\"小整数值\",\"SMALLINT\",\"2 字节\",\"(-32 768, 32 767)\",\"(0, 65 535)\",\"大整数值\",\"MEDIUMINT\",\"3 字节\",\"(-8 388 608, 8 388 607)\",\"(0, 16 777 215)\",\"大整数值\",\"INT或INTEGER\",\"4 字节\",\"(-2 147 483 648, 2 147 483 647)\",\"(0, 4 294 967 295)\",\"大整数值\",\"BIGINT\",\"8 字节\",\"(-9 233 372 036 854 775 808, 9 223 372 036 854 775 807)\",\"(0, 18 446 744 073 709 551 615)\",\"极大整数值\",\"FLOAT\",\"4 字节\",\"(-3.402 823 466 E+38, 1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)\",\"0, (1.175 494 351 E-38, 3.402 823 466 E+38)\",\"单精度浮点数值\",\"DOUBLE\",\"8 字节\",\"(1.797 693 134 862 315 7 E+308, 2.225 073 858 507 201 4 E-308), 0, (2.225 073 858 507 201 4 E-308, 1.797 693 134 862 315 7 E+308)\",\"0, (2.225 073 858 507 201 4 E-308, 1.797 693 134 862 315 7 E+308)\",\"双精度浮点数值\",\"DECIMAL\",\"对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2\",\"依赖于M和D的值\",\"依赖于M和D的值\",\"小数值\",\"建议：\",\"如果整形数据没有负数，如ID号，建议指定为UNSIGNED无符号类型，容量可以扩大一倍。\",\"建议使用TINYINT代替ENUM、BITENUM、SET。\",\"避免使用整数的显示宽度(参看文档最后)，也就是说，不要用INT(10)类似的方法指定字段显示宽度，直接用INT。\",\"DECIMAL最适合保存准确度要求高，而且用于计算的数据，比如价格。但是在使用DECIMAL类型的时候，注意长度设置。\",\"建议使用整形类型来运算和存储实数，方法是，实数乘以相应的倍数后再操作。\",\"整数通常是最佳的数据类型，因为它速度快，并且能使用AUTO_INCREMENT。\"]},\"666\":{\"h\":\"日期和时间\",\"t\":[\"类型\",\"大小(字节)\",\"范围\",\"格式\",\"用途\",\"DATE\",\"3\",\"1000-01-01 到 9999-12-31\",\"YYYY-MM-DD\",\"日期值\",\"TIME\",\"3\",\"'-838:59:59' 到 '838:59:59'\",\"HH:MM:SS\",\"时间值或持续时间\",\"YEAR\",\"1\",\"1901 到 2155\",\"YYYY\",\"年份值\",\"DATETIME\",\"8\",\"1000-01-01 00:00:00 到 9999-12-31 23:59:59\",\"YYYY-MM-DD HH:MM:SS\",\"混合日期和时间值\",\"TIMESTAMP\",\"4\",\"1970-01-01 00:00:00 到 2038-01-19 03:14:07\",\"YYYYMMDDhhmmss\",\"混合日期和时间值，时间戳\",\"建议：\",\"MySQL能存储的最小时间粒度为秒。\",\"建议用DATE数据类型来保存日期。MySQL中默认的日期格式是yyyy-mm-dd。\",\"用MySQL的内建类型DATE、TIME、DATETIME来存储时间，而不是使用字符串。\",\"当数据格式为TIMESTAMP和DATETIME时，可以用CURRENT_TIMESTAMP作为默认（MySQL5.6以后），MySQL会自动返回记录插入的确切时间。\",\"TIMESTAMP是UTC时间戳，与时区相关。\",\"DATETIME的存储格式是一个YYYYMMDD HH:MM:SS的整数，与时区无关，你存了什么，读出来就是什么。\",\"除非有特殊需求，一般的公司建议使用TIMESTAMP，它比DATETIME更节约空间，但是像阿里这样的公司一般会用DATETIME，因为不用考虑TIMESTAMP将来的时间上限问题。\",\"有时人们把Unix的时间戳保存为整数值，但是这通常没有任何好处，这种格式处理起来不太方便，我们并不推荐它。\"]},\"667\":{\"h\":\"字符串\",\"t\":[\"类型\",\"大小\",\"用途\",\"CHAR\",\"0-255字节\",\"定长字符串，char(n)当插入的字符数不足n时(n代表字符数)，插入空格进行补充保存。在进行检索时，尾部的空格会被去掉。\",\"VARCHAR\",\"0-65535 字节\",\"变长字符串，varchar(n)中的n代表最大字符数，插入的字符数不足n时不会补充空格\",\"TINYBLOB\",\"0-255字节\",\"不超过 255 个字符的二进制字符串\",\"TINYTEXT\",\"0-255字节\",\"短文本字符串\",\"BLOB\",\"0-65 535字节\",\"二进制形式的长文本数据\",\"TEXT\",\"0-65 535字节\",\"长文本数据\",\"MEDIUMBLOB\",\"0-16 777 215字节\",\"二进制形式的中等长度文本数据\",\"MEDIUMTEXT\",\"0-16 777 215字节\",\"中等长度文本数据\",\"LONGBLOB\",\"0-4 294 967 295字节\",\"二进制形式的极大文本数据\",\"LONGTEXT\",\"0-4 294 967 295字节\",\"极大文本数据\",\"建议：\",\"字符串的长度相差较大用VARCHAR；字符串短，且所有值都接近一个长度用CHAR。\",\"CHAR和VARCHAR适用于包括人名、邮政编码、电话号码和不超过255个字符长度的任意字母数字组合。那些要用来计算的数字不要用VARCHAR类型保存，因为可能会导致一些与计算相关的问题。换句话说，可能影响到计算的准确性和完整性。\",\"尽量少用BLOB和TEXT，如果实在要用可以考虑将BLOB和TEXT字段单独存一张表，用id关联。\",\"BLOB系列存储二进制字符串，与字符集无关。TEXT系列存储非二进制字符串，与字符集相关。\",\"BLOB和TEXT都不能有默认值。\"]},\"668\":{\"h\":\"MySQL事务与锁\",\"t\":[\"参考：http://note.youdao.com/noteshare?id=354ae85f3519bac0581919a458278a59&sub=9A8237E2B9B248B9A2F5FC5AED6CBCF1\"]},\"669\":{\"h\":\"事务及其属性\",\"t\":[\"并发事务处理带来的问题：\",\"更新丢失或脏写\",\"当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事务所做的更新。\",\"脏读\",\"事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。\",\"不可重复读\",\"事务A内部相同查询语句在不同时刻读出的结果不一致，不符合隔离性。\",\"幻读\",\"事务A读取到了事务B提交的新增数据，不符合隔离性。\",\"事务的隔离级别：\",\"隔离级别\",\"脏读(Dirty Read)\",\"不可重复读(NonRepeatable Read)\",\"幻读(Phantom Read)\",\"读未提交(Read uncommitted)\",\"可能\",\"可能\",\"可能\",\"读已提交(Read committed)\",\"不可能\",\"可能\",\"可能\",\"可重复读(Repeatableread)\",\"不可能\",\"不可能\",\"可能\",\"可串行化(Serializable)\",\"不可能\",\"不可能\",\"不可能\",\"数据库的事务隔离级别越严格，并发的副作用就越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。\",\"查看当前数据库的事务隔离级别：\",\"show variables like 'tx_isolation'; \",\"设置事务隔离级别：\",\"set tx_isolation='REPEATABLE-READ'; \",\"MySQL默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用MySQL设置的隔离级别，如果Spring设置了就用已经设置的隔离级别。\"]},\"670\":{\"h\":\"MySQL中的锁的分类\",\"t\":[\"锁是计算机协调多个进程或线程并发访问某一资源的机制。\",\"在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。\",\"从性能上分为乐观锁（用版本对比来实现）和悲观锁；\",\"从对数据操作的粒度分，分为表锁和行锁；\",\"从对数据库操作的类型分，分为读锁和写锁（都属于悲观锁），还有意向锁；\",\"读锁：\",\"写锁：\",\"意向锁：\",\"意向锁主要分为：\",\"意向共享锁，IS锁，对整个表加共享锁之前，需要先获取到意向共享锁\",\"意向拍他锁，IX锁，对整个表加拍他锁之前，需要先获取到意向排他锁\"]},\"671\":{\"h\":\"表锁\",\"t\":[\"每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；一般用在整表数据迁移的场景。\",\"--建表SQL CREATE TABLE `mylock` ( `id` INT (11) NOT NULL AUTO_INCREMENT, `NAME` VARCHAR (20) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = MyISAM DEFAULT CHARSET = utf8; --插入数据 INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES ('1', 'a'); INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES ('2', 'b'); INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES ('3', 'c'); INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES ('4', 'd'); \",\"手动增加表锁：\",\"lock table 表名称 read(write),表名称2 read(write); \",\"查看表上加过的锁：\",\"show open tables; \",\"删除表锁：\",\"unlock tables; \"]},\"672\":{\"h\":\"行锁\",\"t\":[\"每次操作锁住一行数据，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度最高。\",\"MyISAM在执行查询语句SELECT前会给涉及的所有表加读锁，在执行update、insert、delete操作会自动给涉及的表加写锁。\",\"InnoDB在执行查询语句SELECT时（非串行隔离级别），不会加锁，但是update、insert、delete操作会加行锁。简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁组会把读和写都阻塞。\",\"可以基于以下实例来分析行锁。\",\"CREATE TABLE `account` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `balance` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO `test`.`account` (`name`, `balance`) VALUES ('lilei', '450'); INSERT INTO `test`.`account` (`name`, `balance`) VALUES ('hanmei', '16000'); INSERT INTO `test`.`account` (`name`, `balance`) VALUES ('lucy', '2400'); \",\"MySQL的乐观锁：\",\"update account set balance = balance - 50 where id = 1 \",\"这主要是由于MySQL在可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本号，是当前读（当前版本）。\"]},\"673\":{\"h\":\"间隙锁\",\"t\":[\"间隙锁，锁住的是两个值之间的空隙，间隙锁在某些情况下可以解决幻读的问题。假设account表里的数据如下：\",\"如果执行下面的SQL：\",\"update account set name = 'zhuge' where id > 8 and id < 18; \",\"那么产生的间隙就有id为(3,10)，(10,20)，(20,正无穷)这三个区间。此时其他Session没法在这个范围锁包含的所有行记录（包含间隙行记录）以及行记录所在的间隙里插入或修改任何数据，即id在(3,20]区间都无法修改数据，注意20也包含在内。\",\"间隙锁只有在可重复读的隔离级别下才会生效的。\"]},\"674\":{\"h\":\"临键锁\",\"t\":[\"临键锁是行锁与间隙锁的组合，上面的例子中(3,20]的整个区间就可以叫做临键锁。\",\"在可重复读的隔离级别下，锁主要是加在索引上，如果对非索引字段更新，行锁可能会变表锁，即无索引行锁会升级为表锁。\",\"锁定某一行还可以用lock in share（共享锁）和for update（排他锁），例如：\",\"select * from test_innodb_lock where a = 2 for update; \",\"这样其他session只能读这行数据，修改则会被阻塞，直到锁定行的session提交。\"]},\"675\":{\"h\":\"行锁分析\",\"t\":[\"可以通过下面的SQL语句查询数据的行锁的情况：\",\"show status like 'innodb_row_lock%'; \",\"各个变量的含义：\",\"Innodb_row_lock_current_waits: 当前正在等待锁定的数量\",\"Innodb_row_lock_time: 从系统启动到现在锁定总时间长度\",\"Innodb_row_lock_time_avg: 每次等待所花平均时间\",\"Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花时间\",\"Innodb_row_lock_waits: 系统启动后到现在总共等待的次数\",\"其中比较重要的有Innodb_row_lock_time_avg（等待平均时长）、Innodb_row_lock_waits（等待总次数）、Innodb_row_lock_time（等待总时长）。尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。\",\"查看INFORMATION_SCHEMA系统库锁相关数据表：\",\"-- 查看事务 select * from INFORMATION_SCHEMA.INNODB_TRX; -- 查看锁 select * from INFORMATION_SCHEMA.INNODB_LOCKS; -- 查看锁等待 select * from INFORMATION_SCHEMA.INNODB_LOCK_WAITS; -- 释放锁，trx_mysql_thread_id可以从INNODB_TRX表里查看到 kill trx_mysql_thread_id -- 查看锁等待详细信息 show engine innodb status\\\\G; \"]},\"676\":{\"h\":\"锁优化建议\",\"t\":[\"尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁\",\"合理设计索引，尽量缩小锁的范围\",\"尽可能减少检索条件范围，避免间隙锁\",\"尽可能控制事务大小，减少锁定资源量和实践长度，涉及事务加锁的sql尽量放在事务的最后执行\",\"尽可能低级别事务隔离\"]},\"677\":{\"h\":\"MVCC与BufferPool缓冲机制\",\"t\":[\"参考：http://note.youdao.com/noteshare?id=b36b975188fadf7bfbfd75c0d2d6b834&sub=5A7459FE4B464EC896F9DD9A4EB64942\",\"MySQL在读已提交和可重复读的隔离级别下的隔离性都依靠MVCC（Multi-Version Concurrency Control）机制来实现，对一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性，避免了频繁加锁互斥。只有在串行化的隔离级别下，为了保证比较高的隔离性，是通过将所有操作加锁互斥来实现的。\"]},\"678\":{\"h\":\"MVCC机制\",\"t\":[\"在了解MVCC多版本并发控制之前，我们必须首先了解一下，什么是MySQL InnoDB下的当前读和快照读。\",\"当前读：读取记录最新的版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行枷锁，select lock in share mode(共享锁),select for update,update,insert,delete（排他锁），这些都是当前读。\",\"快照读：不加锁的非阻塞读。\"]},\"679\":{\"h\":\"undo日志版本链与read view机制详解\",\"t\":[\"undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，MySQL会保留修改前的数据undo回滚日志，并且用两个隐藏字段trx_id（事务ID）和roll_pointer（上一条数据的历史版本指针）把这些undo日志串联起来形成一个历史记录版本链，具体如下图。\",\"在可重复读的隔离级别下，当事务开启后，执行任何查询sql时会生成当前事务的一致性视图read-view，该视图在事务结束之前都不会变化（如果是读已提交的隔离级别会在每次执行查询sql时都会重新生成），这个视图由执行查询时所有未提交事务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。\",\"版本链的比对规则如下：\",\"如果row的trx_id落在绿色部分（trx），表示在这个版本是由已提交的事务生成的，这个事务是可见的\",\"如果row的trx_id落在红色部分，表示这个版本是由将来启动的事务生成的，是不可见的（若row的trx_id就是当前自己的事务是可见的）\",\"如果row的trx_id落在黄色部分，此时包含两种情况： \",\"如果row的trx_id在视图数组中，表示这个版本是由还未提交的事务生成的，不可见（若row的trx_id就是当前自己的事务则是可见的）\",\"如果row的trx_id不在视图数组中，表示这个版本已经提交了的事务生成的，事务是可见的\",\"对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的trx_id，同时在该条记录的头信息（record header）里的（deleted_flag）标记位写上true，来表示当前记录已经被删除，在查询时按照上面的规则查到对应的记录如果delete_flag 标记位为true，意味着记录已被删除，则不返回数据。\",\"begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个修改InnoDB操作的语句，事务才真正启动，才会向mysql申请事务id，mysql内部是严格按照事务的启动顺序来分配事务id的。\",\"总而言之，MVCC机制的实现就是通过read-view机制与undo版本链对比机制，使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上的不同版本数据。\"]},\"680\":{\"h\":\"BufferPool缓存机制\",\"t\":[\"为什么MySQL不直接更新磁盘上的数据而是设计了这么复杂的一套机制来执行SQL？\",\"主要是因为来一个请求就直接对磁盘文件进行随机读写，由于磁盘随机读写的相比顺序读写的性能是非常差的，所以直接更新磁盘文件里的数据性能会很差。MySQL的这套机制看起来虽然复杂，但是它可以保证每个更新请求都是更新内存中的BufferPool，然后顺序写日志文件，同时还能保证各种异常情况下的数据一致性。更新内存的数据的性能是很高的，顺序写磁盘上的日志文件的性能也是很高的，正是这两点，才能让MySQL拥有较高的并发能力。\"]},\"681\":{\"h\":\"MySQL成本分析\",\"t\":[\"在MySQL5.6之前的版本来说，只能通过EXPLAIN语句查看到最后优化器决定使用的执行计划，却无法知道它为什么做这个决策。在MySQL5.6之后的版本中，MySQL提出了optimizer trace的功能，这个功能可以让我们方便的查看优化器执行计划的整个过程。\",\"SET optimizer_trace = \\\"enabled=on\\\"; SELECT * FROM order_exp WHERE order_no IN ('DD00_6S', 'DD00_9S', 'DD00_10S') AND expire_time > '2021-03-22 18:28:28' AND expire_time <= '2021-03-22 18:35:09' AND insert_time > expire_time AND order_note LIKE '%7排1%' AND order_status = 0; SELECT * FROM information_schema.OPTIMIZER_TRACE; \",\"可以看见全表扫描的成本：2169.9：\",\"使用索引idx_order_no的成本为72.61:\",\"使用索引idx_expire_time的成本为47.81：\",\"最终MySQL使用了idx_expire_time作为这个SQL查询过程中索引：\"]},\"682\":{\"h\":\"MySQL查询成本\",\"t\":[\"参考链接：Mysql内核查询成本计算实战。\",\"一条查询语句的执行成本是由下面这两个方面组成的：\",\"IO成本：MyISAM、InnoDB存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。从磁盘到内存这个加载的过程损耗的时间称之为IO成本\",\"CPU成本：读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为CPU成本。对于InnoDB存储引擎来说，页是磁盘和内存之间交互的基本单位，MySQL规定读取一个页面花费的成本默认是1.0，读取以及检测一条记录是否符合搜索条件的成本默认是0.2。1.0、0.2这些数字称之为成本常数，这两个成本常数是我们最常用到的，也有一些其他的成本常数。\",\"注意，不管读取记录时需不需要检测是否满足搜索条件，其成本都算是0.2。\"]},\"683\":{\"h\":\"单表查询的成本\",\"t\":[\"在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的执行计划，之后才会调用存储引擎提供的接口真正的执行查询，这个过程总结一下就是这样：\",\"根据搜索条件，找出所有可能使用的索引\",\"计算全表扫描的代价\",\"计算使用不同索引执行查询的代价\",\"对比各种执行方案的代价，找出成本最低的那一个\"]},\"684\":{\"h\":\"根据搜索条件，找出所有可能使用的索引\",\"t\":[\"我们仍然使用如下查询语句来分析：\",\"SELECT * FROM order_exp WHERE order_no IN ('DD00_6S', 'DD00_9S', 'DD00_10S') AND expire_time > '2021-03-22 18:28:28' AND expire_time <= '2021-03-22 18:35:09' AND insert_time > expire_time AND order_note LIKE '%7排1%' AND order_status = 0; \",\"上述查询中涉及到几个搜索条件：\",\"order_no IN ('DD00_6S', 'DD00_9S', 'DD00_10S') ，这个搜索条件可以使用二级索引idx_order_no\",\"expire_time> '2021-03-22 18:28:28' AND expire_time<= '2021-03-22 18:35:09'，这个搜索条件可以使用二级索引idx_expire_time\",\"insert_time> expire_time，这个搜索条件的索引列由于没有和常数比较，所以并不能使用索引\",\"order_note LIKE '%hello%'，order_note即使有索引，但是通过LIKE操作符和以通配符开头的字符串做比较，不可以使用索引\",\"order_status = 0，由于该列上只有联合索引，而且不符合最左前缀原则，所以不会用到索引\",\"综上所述，上边的查询语句可能用到的索引，也就是possible keys只有idx_order_no，idx_expire_time。\"]},\"685\":{\"h\":\"计算全表扫描的代价\",\"t\":[\"对于InnoDB存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都一次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。由于查询成本=I/O成本+CPU成本，所以计算全表扫描的代价需要两个信息：聚簇索引占用的页面数、该表中的记录数。\",\"MySQL为每个表维护了一系列的统计信息，并且可以通过如下语句查询：\",\"SHOW TABLE STATUS LIKE 'order_exp'; \",\"我们需要的两个统计项：\",\"Rows：这个选项表示表中的记录条数。对于使用MyISAM存储引擎的表来说，该值是准确的，对于使用InnoDB存储引擎的表来说，该值是一个估计值。所以order_exp表实际由10567条记录，但是Rows显示有10354条记录\",\"Data_length：这个选项表示表占用的存储空间字节数。使用MyISAM存储引擎的表来说，该值就是数据文件的大小，对于使用InnoDB存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小，也就是说可以这样计算该值的大小：Data_length = 聚簇索引的页面数量✖️每个页面的大小，order_exp使用默认16KB的页面大小，通过Data_length可以聚簇索引的页面数量 = 1589248 ➗ 16 ➗ 1024 = 97，也就是说，该表的聚簇索引的记录数为97\",\"现在就可以根据聚簇索引占用的页面数量以及该表记录数的估计值，来计算全表扫描成本：\",\"IO成本 = 97 ✖️ 1.0 + 1.1 = 98.1（1.1指是加载一个页面的IO成本常数，后面的1.0是一个微调值）\",\"CPU成本 = 10354 ✖️ 0.2 + 1.0 = 2071.8（10354值的统计数据中表的记录数，对于InnoDB存储引擎来说是一个估计值，0.2指的是访问一条记录所需的CPU成本常数，后面的1.0是一个微调值）\",\"MySQL在真实计算成本时会进行一些微调，这些微调的值是直接硬编码到代码里的，没有注释而且这些微调的值十分的小，并不影响我们大方向上的分析。\",\"所以全表扫描的总成本 = 98.1 + 2071.8= 2169.9。\",\"虽然表中的记录其实都存储在聚簇索引对应B+树的叶子结点中，所以只要我们通过根节点获得了最左边的叶子节点。就可以沿着叶子节点组成的双向链表把所有记录都查看一遍。也就是说全表扫描这个过程其实有的B+树非叶子结点是不需要访问的。但是MySQL在计算全表扫描成本时直接使用聚簇索引占用的页面数作为计算IO成本的依据，是不区分非叶子结点和叶子结点的。\"]},\"686\":{\"h\":\"计算使用不同索引执行查询的代价\",\"t\":[\"从上一步分析我们可以得出，上述查询可能使用到idx_order_no，idx_expire_time这两个索引，我们需要分别分析单独使用这些索引执行查询的成本，最后还要分析是否可能会使用到索引合并。MySQL查询优化器先分析使用唯一二级索引的成本，再分析使用普通索引的成本，我们这里有两个索引，先算哪个都可以。我们先分析idx_expire_time的成本，然后再看使用idx_order_no的成本。\",\"idx_expire_time对应的搜索条件是：AND expire_time > '2021-03-22 18:28:28' AND expire_time <= '2021-03-22 18:35:09'，也就是说对应的范围区间是('2021-03-22 18:28:28' , '2021-03-22 18:35:09' )。使用idx_expire_time搜索会使用二级索引+回表方式的查询，MySQL计算这种查询的成本以来两个方面的数据：\",\"范围区间数量\",\"需要回表的记录数\",\"接下来我们分别计算这两个数据。\",\"不论某个范围区间的二级索引到底占用了多少页面，查询优化器认为读取索引的一个范围区间的IO成本和读取一个页面是相同的。本例中使用idx_expire_time的范围区间只有一个，所以相当于访问这个范围区间的二级索引付出的IO成本就是：1✖️ 1.0 = 1.0。\",\"优化器需要计算二级索引的某个范围区间到底包含多少条记录，对于本例来说就是要计算('2021-03-22 18:28:28' , '2021-03-22 18:35:09' )这个范围区间内包含多少二级索引记录，计算过程如下：\",\"先根据expire_time > '2021-03-22 18:28:28'这个条件访问id_expire_time对应的B+树索引，找到满足expire_time > '2021-03-22 18:28:28'这个条件的第一条记录，我们把这条记录称之为区间最左记录。我们前面说过在B+树中定位到一条记录的过程是很快的，是常数级别的，所以这个过程的性能消耗是可以忽略不计的\",\"然后再根据expire_time <= '2021-03-22 18:35:09这个条件继续从id_expire_time对应的B+树索引中找出最后一条满足这个条件的记录，我们把这条记录称之为区间最右记录，这个过程的性能消耗也可以忽略不计的\",\"如果区间最左记录和区间最右记录相隔不太远（在MySQL 5.7这个版本里，只要相隔不大于10个页面即可），那就可以精确统计出AND expire_time > '2021-03-22 18:28:28' AND expire_time <= '2021-03-22 18:35:09'条件的二级索引记录条数。否则只沿着区间最左记录向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以区间最左记录和区间最右记录之间的页面数量就可以了\",\"估计区间最左记录和区间最右记录之间有多少个页面，是根据B+树索引的结构来的。我们假设区间最左记录在页b中，区间最右记录在页c中，那么我们要计算区间最左记录和最右记录之间的页面数量就相当于计算页b和页c之间有多少页面，而它们父节点中记录的每一条目录项记录都对应一个数据页，所以计算页b和页c之间有多少页面就相当于计算它们父节点（也就是页a）中对应的目录项记录之间隔着几条记录。在一个页面中统计两条记录之间有几条记录的成本就很小了。\",\"不过还有一个问题，如果页b和页c之间的页面实在太多，以至于页b和页c对应的目录项记录都不在一个父页面中怎么办？既然是树，那就继续递归，B+树的层级并不会很高，所以这个统计过程页不是很耗费性能。\",\"MySQL根据上述算法得到索引项id_expire_time在区间expire_time <= '2021-03-22 18:35:09之间大约有39条记录。\",\"explain SELECT * FROM order_exp WHERE expire_time> '2021-03-22 18:28:28' AND expire_time<= '2021-03-22 18:35:09'; \",\"所以读取这39条二级索引记录需要付出的CPU成本就是：39✖️0.2 + 0.01 = 7.81。其中39是需要读取的二级索引记录条数，0.2是读取一条记录成本常数，0.01是微调。\",\"在通过二级索引获取到记录之后，还需要做两件事儿：\",\"根据这些记录中的主键值到聚簇索引中做回表操作。MySQL评估回表操作的IO成本依旧很简单粗暴，它认为每次回表操作都相当于访问一个页面，也就是说二级索引范围区间有多少记录，就需要进行多少次回表操作，也就是需要进行多少次页面IO。id_expire_time二级索引执行查询时，预计有39条二级索引记录需要进行回表操作，所以回表操作带来的IO成本就是：39✖️1.0=39.0，其中39是预计的二级索引记录数，1.0时一个页面的IO成本常数\",\"回表操作得到的完成用户记录，然后再检测其他搜索条件是否成立。由于我们通过范围区间获取到二级索引记录共39条，也就是对应着聚簇索引中39条完整的用户记录，读取并检测这些完整的用户记录是否符合其余的搜索条件的CPU成本如下：39✖️0.2=7.8。其中39是待检测记录的条数，0.2是检测一条记录是否符合给定的搜索条件的成本常数\",\"所以本例中使用id_expire_time执行查询的成本如下所示：\",\"IO成本：1.0 + 39 ✖️1.0 = 40.0 （范围区间的数量 + 预估的二级索引记录条数）\",\"CPU成本：39 ✖️ 0.2 + 0.01 + 39 ✖️ 0.2 = 15.61（读取二级索引记录的成本 + 读取并检测回表后聚簇索引的成本）\",\"综上所属，使用id_expire_time执行查询的总成本就是：40.0 + 15.6 = 55.61。\",\"按照上述思路我们计算idx_order_no执行查询的成本。\",\"idx_order_no对应的搜索条件是：order_no IN('DD00_6S', 'DD00_9S', 'DD00_10S')，也就是说相当于3个单点区间。与计算idx_expire_time的情况类似，我们也需要计算使用idx_order_no时需要访问的范围区间数量以及需要回表的记录数，计算过程与上面类似。\",\"范围区间数量：使用idx_order_no执行查询时有3个单点区间，所以访问这3个范围区间的二级索引付出的IO成本就是：3✖️1.0=3.0。\",\"需要回表的记录数：由于使用idx_expire_time时有3个单点区间，所以每个单点区间都需要查找一遍对应的二级索引记录数，三个单点区间总共需要回表的记录数是58。\",\"explain SELECT * FROM order_exp WHERE order_no IN ('DD00_6S', 'DD00_9S', 'DD00_10S'); \",\"读取这些二级索引记录的CPU成本就是：58✖️0.2 + 0.01 = 11.61。得到总共需要回表的记录数之后，就要考虑：根据这些记录里的主键值到聚簇索引中做回表操作，所需的IO成本就是：58✖️1.0 = 58.0。回表操作得到的完整用户记录，然后再比较其他搜索条件是否成立，此步骤对应的CPU成本就是：58✖️0.2 = 11.6。\",\"所以本例中使用idx_order_no执行查询的成本就如下所示：\",\"IO成本：3.0 + 58✖️1.0 = 61.0（范围区间内的数量 + 预估的二级索引记录数）\",\"CPU成本：58✖️0.2 + 58✖️0.2 + 0.01 = 23.21（读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）\",\"综上所属，使用idx_order_no执行查询的总成本就是：61.0 + 23.1 = 84.21。\"]},\"687\":{\"h\":\"是否有可能使用索引合并\",\"t\":[\"本例中SQL语句不满足索引合并的条件，所以并不会使用索引合并。而且MySQL查询优化器计算索引合并成本的算法也比较麻烦，我们不去了解。\"]},\"688\":{\"h\":\"对比各种方案，找出成本最低的那一个\",\"t\":[\"下面比较各种可执行方案以及它们对应的成本：\",\"全表扫描的成本：2169.9\",\"使用idx_expire_time的成本：55.61\",\"使用idx_order_no的成本：84.21\",\"显然，使用idx_expire_time的成本最低，所以选择idx_expire_time来执行查询。\",\"全表扫描Tracer的输出：\",\"使用idx_order_no的Tracer的输出：\",\"使用idx_expire_time的Tracer的输出：\",\"这里之所以和我们计算有点不同的原因是，在MySQL的实际计算中，在和全文扫描比较成本时，使用索引的成本会除去读取并检测回表后聚簇索引记录的成本，也就是说，我们通过MySQL看到使用idx_expire_time成本将会是：55.61 - 7.8 = 47.81，idx_order_no的成本就是：84.21 - 11.6 = 72.61。但是MySQL比较完成成本后，会再计算一次使用索引的成本，此时就会加上前面去除的成本，也就是我们计算出来的值。\"]},\"689\":{\"h\":\"基于索引统计数据的成本\"},\"690\":{\"h\":\"index dive\",\"t\":[\"有时候使用索引执行查询时会有许多单点区间，比如使用IN语句就很容易产生非常多的单点区间，比如下面这个查询：\",\"SELECT * FROM order_exp WHERE order_no IN ('aa1', 'aa2', 'aa3', ... , 'zzz'); \",\"显然，这个查询用到的索引就是idx_order_no，由于这个索引并不是唯一二级索引，所以并不能确定一个单点区间对应的二级索引记录的条数有多少，需要我们去计算。就是先把获取索引对应的B+树的区间最左记录和区间最右记录，然后再计算这两条记录之间有多少记录（记录条数少的时候可以做到精确计算，多的时候只能估算）。MySQL把这种通过直接访问索引对应的B+树来计算某个范围区间对应的索引记录条数的方式称之为index dive。\",\"有零星几个单点区间的话，使用index dive的方式去计算这些单点区间对应的记录数也不是什么问题，如果IN语句里的参数过多，比如有2000个参数怎么办？\",\"这就意味着MySQL的查询优化器为了计算这些单点区间的索引记录条数，要进行2000次的index dive操作，这样做性能损耗很大，搞不好计算这些单点区间对应的索引记录条数的成本比直接全表扫描的成本都大了。MySQL考虑到这种情况，所以提供了一个系统变量eq_range_index_dive_limit，MySQL 5.7.21中这个系统变量的默认值：\",\"show variables like '%dive%'; \",\"也就是说IN语句中的参数个数小于200的话，将使用index dive的方式计算各个单点区间对应的记录数，如果大于或等于200个的话，可就不能使用index dive了，要使用所谓的索引统计数据来进行估算。类似上述的，MySQL 会为每个表维护一份统计数据，查看某个表索引的统计数据可以使用SHOW INDEX FROM表名的语法，比如我们要查看order_exp的各个索引的统计数据可以这么写：\",\"show index from order_exp; \",\"详细含义：\",\"属性\",\"描述\",\"Table\",\"索引所属表的名称。\",\"Non_unique\",\"索引列的值是否是唯一的，聚簇索引和唯一二级索引的该列值为0，普通二级索引该列值为1。\",\"Key_name\",\"索引的名称。\",\"Seq_in_index\",\"索引列在索引中的位置，从1开始计数。比如对于联合索引u_idx_day_status，来说，insert_time, order_status, expire_time对应的位置分别是1、2、3。\",\"Column_name\",\"索引列的名称。\",\"Collation\",\"索引列中的值是按照何种排序方式存放的，值为A时代表升序存放，为NULL时代表降序存放。\",\"Cardinality\",\"索引列中不重复值的数量。后边我们会重点看这个属性的。\",\"Sub_part\",\"对于存储字符串或者字节串的列来说，有时候我们只想对这些串的前n个字符或字节建立索引，这个属性表示的就是那个n值。如果对完整的列建立索引的话，该属性的值就是NULL。\",\"Packed\",\"索引列如何被压缩，NULL值表示未被压缩。这个属性我们暂时不了解，可以先忽略掉。\",\"Null\",\"该索引列是否允许存储NULL值。\",\"Index_type\",\"使用索引的类型，我们最常见的就是BTREE，其实也就是B+树索引。\",\"Comment\",\"索引列注释信息。\",\"Index_comment\",\"索引注释信息。\",\"Cardinality属性，Cardinality直译过来就是基数的意思，表示索引列中不重复值的个数，比如对于一个一万行记录的表来说，某个索引列的Cardinality属性是10000，那意味着该列中没有重复的值，如果Cardinality属性是1的话，就意味该列的值全部是重复的。不过需要注意的是，对于InnoDB存储引擎来说，使用SHOW INDEX语句展示出来的某个索引列的Cardinality属性是一个估计值，并不是精确的。\",\"前面说过，当IN语句中的参数个数大于或等于系统变量eq_range_index_limit的值的话，就不会使用index dive的方式计算各个单点区间的索引记录条数，而是使用索引统计数据，这里所指索引统计数据指的是这两个值：\",\"使用SHOW TABLE STATUS展示出的Rows的值，也就是一个表中有多少条记录\",\"使用SHOW INDEX语句展示出的Cardinality属性\",\"结合Rows统计数据，我们可以针对索引列，计算出平均一个值重复多少次。一个值的重复次数 ≈ Rows ÷ Cardinality。\",\"以order_exp表的idx_order_no索引为例，它的Rows值是10354，它对应的Cardinality值是10225，我们可以计算order_no列平均每个值的重复次数就是10354 ÷ 10225 ≈ 1.0126（条）。此时再看上述查询语句：SELECT * FROM order_exp WHERE order_no IN ('aa1', 'aa2', 'aa3', ... , 'zzz');，假设IN语句20000个参数的话，就直接使用统计数据来估算这些参数需要单点区间对应的记录条数了，每个参数大约对应1.012条记录，所以总共需要回表的记录数就是：20000 ✖️ 1.0126 = 20252。\",\"使用统计数据来计算单点区间对应的索引记录条数比index dive的方式简单，但是它的致命缺点就是：不精确。使用统计数据算出来的查询成本与所需的成本可能相差非常大。\",\"MySQL 5.7.3以及之前的版本中，eq_range_index_dive_limit的默认值为10，之后的版本默认值为200。所以如果5.7.3以及之前的版本的话，很容易采用索引统计数据而不是index dive的方式来计算查询成本。当查询中使用到了IN查询，但是却实际没有用到索引，就可以考虑是不是由于eq_range_index_dive_limit的值太小导致的。\",\"我们可以通过如下的语句，查询成本：\",\"EXPLAIN format = json SELECT * FROM order_exp WHERE order_no IN ('DD00_6S', 'DD00_9S', 'DD00_10S') AND expire_time > '2021-03-22 18:28:28' AND expire_time <= '2021-03-22 18:35:09' AND insert_time > expire_time AND order_note LIKE '%7排1%' AND order_status = 0 \",\"这样我们就可以得到一个json格式的执行计划，里面包含计划花费的成本：\",\" { \\\"query_block\\\": { \\\"select_id\\\": 1, # 整个查询语句只有1个SELECT关键字，该关键字对应的id号为1 \\\"cost_info\\\": { \\\"query_cost\\\": \\\"55.61\\\" # 整个查询的执行成本预计为55.61 }, \\\"table\\\": { \\\"table_name\\\": \\\"order_exp\\\", \\\"access_type\\\": \\\"range\\\", \\\"possible_keys\\\": [ \\\"idx_order_no\\\", \\\"idx_expire_time\\\" ], \\\"key\\\": \\\"idx_expire_time\\\", \\\"used_key_parts\\\": [ \\\"expire_time\\\" ], \\\"key_length\\\": \\\"5\\\", \\\"rows_examined_per_scan\\\": 39, \\\"rows_produced_per_join\\\": 0, \\\"filtered\\\": \\\"0.13\\\", \\\"index_condition\\\": \\\"((`mysqladv`.`order_exp`.`expire_time` > '2021-03-22 18:28:28') and (`mysqladv`.`order_exp`.`expire_time` <= '2021-03-22 18:35:09'))\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"55.60\\\", \\\"eval_cost\\\": \\\"0.01\\\", \\\"prefix_cost\\\": \\\"55.61\\\", #单独查询表的成本，也就是：read_cost + eval_cost \\\"data_read_per_join\\\": \\\"24\\\" #和连接查询相关的数据量，单位字节，这里无用 }, \\\"used_columns\\\": [ \\\"id\\\", \\\"order_no\\\", \\\"order_note\\\", \\\"insert_time\\\", \\\"expire_duration\\\", \\\"expire_time\\\", \\\"order_status\\\" ], \\\"attached_condition\\\": \\\"((`mysqladv`.`order_exp`.`order_status` = 0) and (`mysqladv`.`order_exp`.`order_no` in ('DD00_6S','DD00_9S','DD00_10S')) and (`mysqladv`.`order_exp`.`insert_time` > `mysqladv`.`order_exp`.`expire_time`) and (`mysqladv`.`order_exp`.`order_note` like '%7排1%'))\\\" } } } \"]},\"691\":{\"h\":\"连接查询的成本\",\"t\":[\"MySQL中连接查询采用的是嵌套循环连接算法，驱动表会被访问一次，被驱动表可能会被访问多次，所以对于两表连接查询来说，它的查询成本由下面两个部分构成：\",\"单次查询驱动表的成本\",\"多次查询被驱动表的成本（具体查询多少次取决于对被驱动表查询的结果集中有多少条记录）\",\"对驱动表进行查询后得到的记录条数称之为驱动表的扇出（fanout）。很显然驱动表的扇出值越小，对于被驱动表的查询次数也就越少，连接查询的总成本也就越低。当查询优化器想计算整个连接查询所使用的成本时，就需要计算出驱动表的扇出值，有的时候计算扇出值是很容易的，比如下面几个查询。\",\"查询一：\",\"SELECT * FROM order_exp AS s1 INNER JOIN order_exp2 AS s2; \",\"假设使用s1表作为驱动表，很显然对驱动表的单表查询只能使用全表扫描的方式执行，驱动表的扇出值也很明确，那就是驱动表中有多少记录，扇出值就是多少。统计数据中s1表的记录行数是10573，也即是说优化器就直接会把10573当作s1表的扇出值。\",\"查询二：\",\"SELECT * FROM order_exp AS s1 INNER JOIN order_exp2 AS s2 WHERE s1.expire_time> '2021-03-22 18:28:28' AND s1.expire_time<= '2021-03-22 18:35:09'; \",\"仍然假设s1表是驱动表的话，很显然对驱动表的单表查询可以使用idx_expire_time索引执行查询。此时范围区间('2021-03-22 18:28:28', '2021-03-22 18:35:09')中有多少条记录，那么扇出值就是多少。但是有的时候扇出值的计算就变得很棘手，比如下面几个查询：\",\"SELECT * FROM order_exp AS s1 INNER JOIN order_exp2 AS s2 WHERE s1.order_note > 'xyz'; \",\"本查询和查询一类似，只不过对于驱动表s1多了一个order_note > 'xyz'的搜索条件。查询优化器又不会真正的去执行查询，所以它只能猜这10573记录里有多少条记录满足order_note > 'xyz'条件。\",\"查询四：\",\"SELECT * FROM order_exp AS s1 INNER JOIN order_exp2 AS s2 WHERE s1.expire_time> '2021-03-22 18:28:28' AND s1.expire_time<= '2021-03-22 18:35:09' AND s1.order_note > 'xyz'; \",\"本查询和查询二类似，只不过对于驱动表s1也多了一个order_note > 'xyz'的搜索条件。不过因为本查询可以使用idx_expire_time索引，所以只需从符合二级索引范围区间的记录中猜有多少条记录符合order_note > 'xyz'条件，也就是只需要猜39条记录中有多少符合order_note > 'xyz'条件。\",\"查询五：\",\"SELECT * FROM order_exp AS s1 INNER JOIN order_exp2 AS s2 WHERE s1.expire_time> '2021-03-22 18:28:28' AND s1.expire_time<= '2021-03-22 18:35:09' AND s1.order_no IN ('DD00_6S', 'DD00_9S', 'DD00_10S') AND s1.order_note > 'xyz'; \",\"本查询和查询四类似，不过在驱动表s1选取idx_expire_time索引执行查询后，优化器需要从符合二级索引范围内区间的记录中猜有多少条记录符合条件order_no IN ('DD00_6S', 'DD00_9S', 'DD00_10S') 和order_note > 'xyz'。也就是说优化器需要猜在39条记录中有多少符合上述两个条件。\",\"总结一下，MySQL有两种情况需要猜出扇出的值：\",\"如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条\",\"如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条\",\"在MySQL 5.7之前的版本中，查询优化器在计算驱动表扇出时，如果是使用全表扫描的话，就直接使用表中记录的数量作为扇出值，如果使用索引的话，就直接使用满足范围条件的索引记录条数作为扇出值。\",\"在MySQL 5.7中，MySQL引入了启发式规则，将上述中猜的过程称之为condition filtering。这个过程可能会使用到索引，也可能使用到统计数据。condition filtering可以让成本估算更精确，但其过程比较复杂，这里暂时不做探讨。\"]},\"692\":{\"h\":\"两表连接的成本分析\",\"t\":[\"连接查询的成本计算公式：连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本。\",\"对于左（外）连接右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要分别为驱动表和被驱动表选择成本最低的访问方法。\",\"但是对于内连接来说，驱动表和被驱动表的位置是可以互换的，不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序，然后分别为驱动表和被驱动表选择成本最低的访问方法。\",\"显然，计算内连接查询成本的方式更麻烦一些，下面我们以内连接为例来看看如何计算出最优的连接查询方案，比如对如下查询：\",\"SELECT * FROM order_exp s1 INNER JOIN order_exp2 s2 ON s1.order_no = s2.order_note WHERE s1.expire_time > '2021-03-22 18:28:28' AND s1.expire_time <= '2021-03-22 18:35:09' AND s2.expire_time > '2021-03-22 18:35:09' AND s2.expire_time <= '2021-03-22 18:35:59'; \",\"可以选择的连接顺序有两种：\",\"s1连接s2，也就是s1作为驱动表，s2作为被驱动表\",\"s2连接s1，也就是s2作为驱动表，s1作为被驱动表\",\"查询优化器需要分别考虑这两情况下的最优查询成本，然后选区成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。接下来我们分别分析一下这两种情况。\",\"接下来我们分析使用s1作为驱动表的情况。\",\"首先看一下涉及s1表单表的搜索条件有s1.expire_time > '2021-03-22 18:28:28' AND s1.expire_time <= '2021-03-22 18:35:09'，所以这个查询可能会用到idx_expire_time索引，从全表扫描和使用idx_expire_time这两个方案中选出成本最低的那个，很显然使用idx_expire_time执行查询的成本更低些。然后分析对于被驱动表的成本最低的执行方案，此时涉及到被驱动表s2的搜索条件就是：\",\"s2.order_note = 常数（这是因为对驱动表s1结果集中的每一条记录，都需要进行一次被驱动表s2的访问，此时那些设计两表的条件相当于只涉及被驱动表s2了。）\",\"s2.expire_time > '2021-03-22 18:35:09' AND s2.expire_time <= '2021-03-22 18:35:59'\",\"很显然，第一个条件由于order_note没有用到索引，所以并没有什么用，此时访问s2表时可用的方案也是全表扫描和使用idx_expire_time两种，假设使用idx_expire_time的成本更小。所以此时使用s1作为驱动表的总成本就是（暂时不考虑使用join buffer对成本的影响）：\",\"使用idx_expire_time访问s1的成本 + s1的扇出 × 使用idx_expire_time访问s2的成本。\",\"接下来我们分析使用s2作为驱动表的情况。\",\"首先看一下涉及s2表单表的搜索条件有s2.expire_time> '2021-03-22 18:35:09' AND s2.expire_time<= '2021-03-22 18:35:59'，所以这个查询可能使用到idx_expire_time索引，从全表扫描和idx_expire_time这两个方案中选出成本最低的那个，假设使用idx_expire_time执行查询的成本更低些。然后分析对于被驱动表的成本最低的执行方案，此时涉及到被驱动表s1的搜索条件就是：\",\"s1.order_no = 常数\",\"s1.expire_time> '2021-03-22 18:28:28' AND s1.expire_time<= '2021-03-22 18:35:09'\",\"使用s2作为被驱动表与使用s1作为被驱动表有一个区别就是，idx_order_no可以进行ref方式访问，使用idx_expire_time可以使用range方式的访问。那么优化器需要从全表扫描、使用idx_order_no、使用idx_expire_time这几个方案里选出一个成本最低的方案。\",\"这里有一个问题，不同于idx_expire_time的范围区间是确定的，s1.order_no=常数中的常数值我们是不知道，怎么衡量使用idx_order_no执行查询的成本呢？其实直接使用我们前面说过的索引统计数据就可以了（即索引列平均一个值重复多少次）。一般情况下，ref的访问方式要比range成本更低，这里假设使用idx_order_no进行对s1的访问。\",\"所以，使用s2作为驱动表的总成本就是：使用idx_expire_time访问s2的成本 + s2的扇出 × 使用idx_order_no访问s1的成本。\",\"最后优化器会比较这两种方式的最优访问成本，选取其中成本更低的连接顺序去真正的执行查询。从上面的计算过程也可以看出来，一般来讲，连接查询成本占大头的其实是驱动表扇出数 × 单次访问被驱动表的成本，所以我们优化的重点就是下面两个部分\",\"尽量减少驱动表的扇出\",\"对被驱动表的访问成本尽量低\",\"这一点对于我们实际书写连接查询语句时十分有用，我们需要尽量在被驱动表的连接列上建立索引，这样就可以使用ref访问方法来降低访问被驱动表的成本了。如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样就可以把访问被驱动表的成本见到更低了。\",\"连接查询的成本输出：\",\"EXPLAIN format = json SELECT * FROM order_exp s1 INNER JOIN order_exp2 s2 ON s1.order_no = s2.order_note WHERE s1.expire_time > '2021-03-22 18:28:28' AND s1.expire_time <= '2021-03-22 18:35:09' AND s2.expire_time > '2021-03-22 18:35:09' AND s2.expire_time <= '2021-03-22 18:35:59' \",\"成本数据：\",\"{ \\\"query_block\\\": { \\\"select_id\\\": 1,# 整个查询语句只有1个SELECT关键字，该关键字对应的id号为1 \\\"cost_info\\\": { \\\"query_cost\\\": \\\"840.51\\\" # 整个查询的执行成本 }, \\\"nested_loop\\\": [ # 几个表之间采用嵌套循环连接算法执行 { \\\"table\\\": { \\\"table_name\\\": \\\"s2\\\", # s2表是驱动表 \\\"access_type\\\": \\\"range\\\", # 访问方法为range \\\"possible_keys\\\": [ \\\"idx_expire_time\\\" ], \\\"key\\\": \\\"idx_expire_time\\\", \\\"used_key_parts\\\": [ \\\"expire_time\\\" ], \\\"key_length\\\": \\\"5\\\", \\\"rows_examined_per_scan\\\": 321, # 查询s2表大致需要扫描321条记录 \\\"rows_produced_per_join\\\": 321, # 驱动表s2的扇出是321 \\\"filtered\\\": \\\"100.00\\\", # condition filtering代表的百分比 \\\"index_condition\\\": \\\"((`mysqladv`.`s2`.`expire_time` > '2021-03-22 18:35:09') and (`mysqladv`.`s2`.`expire_time` <= '2021-03-22 18:35:59'))\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"386.21\\\", \\\"eval_cost\\\": \\\"64.20\\\", \\\"prefix_cost\\\": \\\"450.41\\\", # 查询s1表总共的成本，read_cost + eval_cost \\\"data_read_per_join\\\": \\\"152K\\\" # 读取的数据量 }, \\\"used_columns\\\": [ \\\"id\\\", \\\"order_no\\\", \\\"order_note\\\", \\\"insert_time\\\", \\\"expire_duration\\\", \\\"expire_time\\\", \\\"order_status\\\" ] } }, { \\\"table\\\": { \\\"table_name\\\": \\\"s1\\\", # s1表是被驱动表 \\\"access_type\\\": \\\"ref\\\", \\\"possible_keys\\\": [ \\\"idx_order_no\\\", \\\"idx_expire_time\\\" ], \\\"key\\\": \\\"idx_order_no\\\", \\\"used_key_parts\\\": [ \\\"order_no\\\" ], \\\"key_length\\\": \\\"152\\\", \\\"ref\\\": [ \\\"mysqladv.s2.order_note\\\" ], \\\"rows_examined_per_scan\\\": 1, # 查询一次s1表大致需要扫描1条记录 \\\"rows_produced_per_join\\\": 16, # 被驱动表s2的扇出是16（由于没有多余的表进行连接，所以这个值无用） \\\"filtered\\\": \\\"4.94\\\", # condition filtering代表的百分比 \\\"index_condition\\\": \\\"(`mysqladv`.`s1`.`order_no` = `mysqladv`.`s2`.`order_note`)\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"325.08\\\", \\\"eval_cost\\\": \\\"3.21\\\", \\\"prefix_cost\\\": \\\"840.51\\\", # 单次查询s2、多次查询s1表总共的成本 \\\"data_read_per_join\\\": \\\"7K\\\" }, \\\"used_columns\\\": [ \\\"id\\\", \\\"order_no\\\", \\\"order_note\\\", \\\"insert_time\\\", \\\"expire_duration\\\", \\\"expire_time\\\", \\\"order_status\\\" ], \\\"attached_condition\\\": \\\"((`mysqladv`.`s1`.`expire_time` > '2021-03-22 18:28:28') and (`mysqladv`.`s1`.`expire_time` <= '2021-03-22 18:35:09'))\\\" } } ] } } \"]},\"693\":{\"h\":\"多表连接的成本分析\",\"t\":[\"多表连接查询的成本分析首先要考虑多表连接时可能产生多少种连接顺序：\",\"对于两表连接，比如表A和表B连接，只有AB、BA两种连接顺序。其实相当于2 × 1 = 2种连接顺序\",\"对于三表连接，比如表A、表B、表C进行连接，有ABC、ACB、BAC、BCA、CAB、CBA这6种连接顺序。其实相当于3 × 2 × 1=6种连接顺序\",\"对于四表连接，则会有4 × 3 × 2 × 1 = 24 种连接顺序\",\"对于n表连接的话，则有n × (n - 1) × (n - 2) × ... × 1种连接顺序，就是n的阶乘种连接顺序，也就是n!\",\"对于n个表的连接查询，MySQL会用一些办法减少计算连接顺序的成本的方法：\",\"提前结束某种顺序的成本评估：MySQL在计算各种链接顺序的成本之前，会维护一个全局变量，这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，那就不会对该连接顺序继续往下分析了。比如有A、B、C三个表进行连接，已经得到连接顺序ABC时当前的最小连接成本，假如是10.0，在计算连接顺序BCA时，发现B和C的连接成本就已经大于10.0时，就不再继续往后分析BCA这个连接顺序的成本了\",\"系统变量\",\"为了防止无穷无尽的分析各种连接顺序的成本，MySQL提出了optimizer_search_depth系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对optimizer_search_depth值相同数量的表进行穷举分析。很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长。\",\"根据某些规则压根儿就不考虑某些连接顺序\",\"即便有上面两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以MySQL干脆提出了一些所谓的启发式规则（就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序不参与分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。MySQL提供了一个系统变量optimizer_prune_level来控制到底是不是用这些启发式规则。\"]},\"694\":{\"h\":\"调节成本常数\",\"t\":[\"前面我们提到两个成本常数：读取一个页面花费的成本默认是1.0，检测一条记录是否符合搜索条件的成本默认是0.2。其实除了这两个成本参数，MySQL还支持很多，它们被存储到MySQL的两个表中：\",\"SHOW TABLES FROM mysql LIKE '%cost%'; \",\"因为一条语句的执行其实是分为两层的：server层、存储引擎层。\",\"MySQL在server层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。也就是说一条语句在server中执行的成本是和它操作的表使用的存储引擎是没有关系的。所以关于这些操作对应的成本常数就存储在了server_cost表中，而依赖于存储引擎的一些操作对应的成本常数就存储在了engine_cost表中。\",\"首先分析一下server_cost表。\",\"SELECT * FROM mysql.server_cost; \",\"cost_value表示成本常数对应的值。如果该列的值为NULL的话，意味着对应的成本常数会采用默认值。\",\"其中每一项成本的含义：\",\"名称\",\"默认值\",\"含义\",\"disk_temptable_create_cost\",\"40.0\",\"创建基于磁盘的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表\",\"disk_temptable_row_cost\",\"1.0\",\"向基于磁盘的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表\",\"key_compare_cost\",\"0.1\",\"两条记录做比较操作的成本，多用在排序操作上，如果增大这个值的话会提升filesort的成本，让优化器尽可能的更倾向于使用索引完成排序而不是filesort\",\"memory_temptable_create_cost\",\"2.0\",\"创建基于内存的临时表写入或者读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表\",\"memory_temptable_row_cost\",\"0.2\",\"向基于内存的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表\",\"row_evaluate_cost\",\"0.2\",\"检测一条记录是否符合搜索条件的成本，增大这个值可以让优化器倾向于使用索引而不是直接全表扫描\",\"MySQL在执行诸如DISTINCT查询、分组查询、Union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，使用这个临时表来辅助完成查询。从上面的表格可以看出，创建临时表和对这个临时表进行写入和读取的操作代价还是很高的。\",\"如果要修改上述参数，首先对表中的cost_value字段值进行update操作，然后执行：\",\"FLUSH OPTIMIZER_COSTS; \",\"如果要改回默认值，将cost_value字段值更新为NULL，然后执行上述语句即可。\",\"接下来我们分析一下engine_cost表。\",\"SELECT * FROM mysql.engine_cost; \",\"与server_cost表相比，engine_cost多出了两列：\",\"engine_name：指定成本常数使用的存储引擎名称。如果该值为default，意味着对应的成本常数使用于所有的存储引擎\",\"device_type：执行存储引擎使用的设备类型，这里主要是为了区分机械硬盘和固态硬盘，不过在MySQL 5.7.X这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分，所以该值默认是0。\",\"表中每一项的含义：\",\"名称\",\"默认值\",\"含义\",\"io_block_read_cost\",\"1.0\",\"从磁盘上读取一个块对应的成本。请注意我使用的是块，而不是页这个词。对于InnoDB存储引擎来说，一个页就是一个块，不过对于MyISAM存储引擎来说，默认是以4096字节作为一个块的。增大这个值会加重I/O成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。\",\"memory_block_read_cost\",\"1.0\",\"从内存中读取一个块对应的成本\",\"怎么从内存中和从磁盘上读取一个块的默认成本是一样的？这主要是因为在MySQL目前的实现中，并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中，有哪些块还停留在磁盘上，所以MySQL简单的认为不管这个块有没有加载到内存中，使用的成本都是1.0。\"]},\"695\":{\"h\":\"InnoDB中的统计数据\",\"t\":[\"InnoDB提供了两种存储统计数据的方式：\",\"永久性的统计数据，这种统计数据存储在磁盘上，也就是说服务器重启之后这些统计数据还在\",\"非永久性的统计数据，这种统计数据存储在内存中，当服务器关闭时这些统计数据就被清除掉了，等到服务器重启之后，在某些适当的场景下才会重新收集这些统计数据\",\"MySQL为我们提供了系统变量innodb_stats_presistent来控制到底采用哪种方式去存储统计数据。在MySQL5.6.6之前，innodb_stats_presistent的值默认是OFF，也就是说InnoDB的统计数据默认是存储到内存的，之后的版本中innodb_stats_presistent的值默认是ON，也就是统计数据默认被存储到磁盘中。\",\"SHOW VARIABLES LIKE 'innodb_stats_persistent'; \",\"我们可以通过指定STATS_PERSISTENT属性来指明该表的统计数据存储方式：\",\"CREATE TABLE 表名 (...) Engine=InnoDB, STATS_PERSISTENT = (1|0); ALTER TABLE 表名 Engine=InnoDB, STATS_PERSISTENT = (1|0); \",\"当STATS_PERSISTENT=1时，表明我们想把该表的统计数据永久的存储到磁盘上，当STATS_PERSISTENT=0时，表明我们想把该表的统计数据临时的存储到内存中。如果我们在创建表时未指定STATS_PERSISTENT属性，默认会采用系统变量innodb_stats_persistent的值作为该属性的值。\",\"当我们选择把某个表以及该表索引的统计数据存放到磁盘上时，实际上是把这些统计数据存储到了两个表里：\",\"SHOW TABLES FROM mysql LIKE 'innodb%'; \",\"可以看到，这两表都位于mysql系统数据库下面，其中：\",\"innodb_table_stats存储了关于表的统计数据，每一条记录对应着一个表的统计数据\",\"Innodb_index_stats存储了关于索引的统计就数据，每一条记录对应着一个索引的一个统计项的统计数据\",\"SELECT * FROM mysql.innodb_table_stats; \",\"几个重要统计信息项的值如下：\",\"n_rows的值是10350，表明order_exp表中大约有10350条记录，这个值是估计值\",\"clustered_index_size的值是97，表明order_exp表的聚簇索引占用97页面，这个值也是一个估计值\",\"sum_of_other_index_sizes的值是81，表明order_exp表的其他索引一共占用81个页面，这个值也是一个估计值\",\"InnoDB统计一个表中有多少行记录是这样的：按照一定算法选取几个叶子结点页面，计算每个页面中主键值记录数量，然后计算平均一个页面中主键值的记录数量乘以全部叶子结点的数量就算是该表n_rows值。\",\"可以看出来这个n_rows值精确与否取决于统计时采样的页面数量，MySQL通过系统变量innodb_stats_persistent_sample_pages来控制使用永久性的统计数据时，计算统计数据时采样的页面数量。该值设置的越大，统计出的n_rows值越精确，但是统计耗时也就最久，该值设置的越小，统计出的n_rows值越不精确，但是统计耗时特别少，这个值的默认值是20。\",\"InnoDB默认是以表为单位来收集和存储统计数据的，我们可以单独设置某个表的采样页面的数量，设置方式就是在创建或修改表的时候通过STATS_SAMPLE_PAGES属性来指明该表的统计数据存储方式：\",\"CREATE TABLE 表名 (...) Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量; ALTER TABLE 表名 Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量; \",\"如果我们在创建表的语句并没有制定STATS_SAMPLE_PAGES属性的话，将默认使用系统变量innodb_stats_persistent_sample_pages的值作为该属性的值。\",\"接下来观察Innodb_index_stats表的数据：\",\"desc mysql.innodb_index_stats; \",\"各个字段的含义：\",\"字段名\",\"描述\",\"database_name\",\"数据库名\",\"table_name\",\"表名\",\"index_name\",\"索引名\",\"last_update\",\"本条记录最后更新时间\",\"stat_name\",\"统计项名称\",\"stat_value\",\"对应的统计项的值\",\"sample_size\",\"为生成统计数据而采样的页面数量\",\"stat_description\",\"对应的统计项的描述\",\"innodb_index_stats表的每条记录代表着一个索引的一个统计项。我们以order_exp表为例：\",\"SELECT * FROM mysql.innodb_index_stats WHERE table_name = 'order_exp'; \",\"从结果中可以看出，PRIMARY索引（也就是组件）占了3条记录，idx_expire_time索引占了6条记录。\",\"stat_name具体的含义：\",\"size：表示该索引共占用多少页面\",\"n_diff_pfxNN：表示对应的索引列不重复的值有多少，其中NN可以被替换为01、02、03...这样的数字，比如对于u_idx_day_status来说，u_diff_pfx01表示的是统计insert_time这单单一列不重复的值有多少，u_diff_pfx02表示insert_time、order_status这两个列组合起来不重复的值有多少，u_diff_pfx03表示的是insert_time、order_status、expire_time这三个列组合起来不重复的值有多少，u_diff_pfx04表示的是insert_time、order_status、expire_time、id这四个列组合起来不重复的值有多少。\",\"对于普通的二级索引，并不能保证它的索引列值是唯一的，比如对于idx_order_no来说，key1列就可能有很多重复的记录。此时只有在索引列上加上主键值才可以区分两条索引列值都是一样的二级索引记录。对于主键和唯一二级索引则没有这个问题，它们本身就可以保证索引列值的不重复，所以也不需要再统计一遍在索引列后加上主键值的不重复值有多少，比如u_idx_day_statu和idx_order_no。\",\"在计算某些索引列中包含多少不重复值时，需要对一些叶子节点页面进行采样，sample_size列就表明了采样的页面数量是多少。对于有多个列的联合索引来说，采样的页面数量是：innodb_stats_persistent_sampe_pages × 索引列的个数。\"]},\"696\":{\"h\":\"更新统计数据\",\"t\":[\"随着我们不断的对表进行增删改操作，表中的数据也一直在变化，innodb_table_stats和innodb_index_stats表里的统计数据也在变化，MySQL提供了自动更新和手动更新两种更新统计数据的方式。\",\"系统变量innodb_stats_auto_recale决定着服务器是否自动重新计算统计数据，它的默认值是ON，也就是该功能默认是开启的。\",\"每个表都维护了一个变量，该变量记录着对该表进行增删改的记录条数，如果发生变动的记录数量超过了表的大小10%，并且自动重新统计数据的功能是打开的，那么服务器会重新进行一次统计数据的计算，并且更新innodb_table_stats和innodb_index_stats表，不过自动重新计算统计数据的过程是异步发生的，也就是即使表中变动的记录数超过了10%，自动重新计算统计数据也不会立即发生，可能会延迟几秒才会进行计算。\",\"InnoDB默认是以表为单位来收集和存储统计数据的，我们可以单独为某个表设置是否自动重新计算统计数的属性，设置方式就是在创建或修改表的时候通过指定STATS_AUTO_RECALC属性来指明该表的统计数据存储方式：\",\"CREATE TABLE 表名 (...) Engine=InnoDB, STATS_AUTO_RECALC = (1|0); ALTER TABLE 表名 Engine=InnoDB, STATS_AUTO_RECALC = (1|0); \",\"当STATS_AUTO_RECALC=1时，表明我们想让该表自动重新计算统计数据，当STATS_AUTO_RECALC=0时，表明不想让该表自动重新计算统计数据，如果我们在创建表时未指定STATS_AUTO_RECALC属性，那默认采用系统变量innodb_stats_auto_recalc的值作为该属性的值。\",\"如果innodb_stats_auto_recalc系统变量的值为OFF的话，我们也可以手动调用ANALYZE TABLE语句来重新计算统计数据，比如我们可以这样更新关于order_exp表的统计数据：\",\"ANALYZE TABLE order_exp; \",\"ANALYZE TABLE语句会立即重新计算统计数据，这个过程是同步的，在表中索引多或者采样页面也别多的时候，这个过程可能会很慢，需要在业务不是很繁忙的时候再运行。\",\"除此之外，innodb_table_stats和innodb_index_stats表就相当于一个普通的表一样，我们能对它们多增删改查操作，这就意味着我们可以手动更新某个表或者索引的统计数据。比如我们想把order_exp表关于行数的统计数据更改一下，可以这么做：\",\"更新innodb_table_stats表\",\"使用语句FLUSH TABLE order_exp让MySQL查询优化器重新加载我们更改过的数据\"]},\"697\":{\"h\":\"表结构设计\"},\"698\":{\"h\":\"MySQL redo日志\",\"t\":[\"参考：https://blog.csdn.net/sermonlizhi/article/details/124556301\",\"事务的实现方式：\",\"WAL(预写式日志)\",\"Commit Logging(提交日志)\",\"Shadow Paging(影子分页)\"]},\"699\":{\"h\":\"Redis入门\"},\"700\":{\"h\":\"概述\"},\"701\":{\"h\":\"Redis是什么？\",\"t\":[\"Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\",\"与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。\"]},\"702\":{\"h\":\"Redis能该干什么？\",\"t\":[\"内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）\",\"高效率、用于高速缓冲\",\"发布订阅系统\",\"地图信息分析\",\"计时器、计数器(eg：浏览量)\"]},\"703\":{\"h\":\"核心特性\",\"t\":[\"多样的数据类型\",\"持久化\",\"集群\",\"事务\"]},\"704\":{\"h\":\"基础知识\",\"t\":[\"Redis是一个字典结构的存储服务器，一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将这数据存储在哪个字典中，这与在一个关系型数据库实例（以MySQL为例）中可以创建多个数据库类似，可以将其中的每个字典都理解成一个独立的数据库。\",\"16个数据库分别为：DB 0~DB 15，默认使用DB 0 ，可以使用select n切换到DB n，dbsize可以查看当前数据库的大小，与key数量相关。\",\"127.0.0.1:6379> config get databases # 命令行查看数据库数量databases 1) \\\"databases\\\" 2) \\\"16\\\" 127.0.0.1:6379> select 8 # 切换数据库 DB 8 OK 127.0.0.1:6379[8]> dbsize # 查看数据库大小 (integer) 0 # 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。 127.0.0.1:6379> set name sakura OK 127.0.0.1:6379> SELECT 8 OK 127.0.0.1:6379[8]> get name # db8中并不能获取db0中的键值对。 (nil) 127.0.0.1:6379[8]> DBSIZE (integer) 0 127.0.0.1:6379[8]> SELECT 0 OK 127.0.0.1:6379> keys * 1) \\\"counter:__rand_int__\\\" 2) \\\"mylist\\\" 3) \\\"name\\\" 4) \\\"key:__rand_int__\\\" 5) \\\"myset:__rand_int__\\\" 127.0.0.1:6379> DBSIZE # size和key个数相关 (integer) 5 \",\"keys * ：查看当前数据库中所有的key。\",\"flushdb：清空当前数据库中的键值对。\",\"flushall：清空所有数据库的键值对。\",\"keys *这个命令需要慎重使用，如果数据库中的键过多可能会造成卡顿，生产环境中应该使用dbsize\"]},\"705\":{\"h\":\"五大数据类型\",\"t\":[\"Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。\"]},\"706\":{\"h\":\"Redis-key\",\"t\":[\"在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。\",\"下面学习的命令：\",\"exists key：判断键是否存在\",\"del key：删除键值对\",\"move key db：将键值对移动到指定数据库\",\"expire key second：设置键值对的过期时间\",\"type key：查看value的数据类型\",\"127.0.0.1:6379> keys * # 查看当前数据库所有key (empty list or set) 127.0.0.1:6379> set name qinjiang # set key OK 127.0.0.1:6379> set age 20 OK 127.0.0.1:6379> keys * 1) \\\"age\\\" 2) \\\"name\\\" 127.0.0.1:6379> move age 1 # 将键值对移动到指定数据库 (integer) 1 127.0.0.1:6379> EXISTS age # 判断键是否存在 (integer) 0 # 不存在 127.0.0.1:6379> EXISTS name (integer) 1 # 存在 127.0.0.1:6379> SELECT 1 OK 127.0.0.1:6379[1]> keys * 1) \\\"age\\\" 127.0.0.1:6379[1]> del age # 删除键值对 (integer) 1 # 删除个数 127.0.0.1:6379> set age 20 OK 127.0.0.1:6379> EXPIRE age 15 # 设置键值对的过期时间 (integer) 1 # 设置成功 开始计数 127.0.0.1:6379> ttl age # 查看key的过期剩余时间 (integer) 13 127.0.0.1:6379> ttl age (integer) 11 127.0.0.1:6379> ttl age (integer) 9 127.0.0.1:6379> ttl age (integer) -2 # -2 表示key过期，-1表示key未设置过期时间 127.0.0.1:6379> get age # 过期的key 会被自动delete (nil) 127.0.0.1:6379> keys * 1) \\\"name\\\" 127.0.0.1:6379> type name # 查看value的数据类型 string \",\"关于TTL命令\",\"Redis的key，通过TTL命令返回key的过期时间，一般来说有3种：\",\"当前key没有设置过期时间，所以会返回-1.\",\"当前key有设置过期时间，而且key已经过期，所以会返回-2.\",\"当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.\",\"关于重命名RENAME和RENAMENX\",\"RENAME key newkey修改 key 的名称\",\"RENAMENX key newkey仅当 newkey 不存在时，将 key 改名为 newkey 。\",\"更多命令学习：Redis命令大全\",\"实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样Redis会在合适的场景选择合适的内部编码，如下图所示：\",\"Redis这样设计有两个好处：\",\"可以改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令\",\"多种内部编码实现可以在不同场景下发挥各自的优势\"]},\"707\":{\"h\":\"String(字符串)\",\"t\":[\"普通的set、get直接略过。\",\"命令\",\"描述\",\"示例\",\"APPEND key value\",\"向指定的key的value后追加字符串\",\"127.0.0.1:6379> set msg hello OK 127.0.0.1:6379> append msg \\\" world\\\" (integer) 11 127.0.0.1:6379> get msg “hello world”\",\"DECR/INCR key\",\"将指定key的value数值进行+1/-1(仅对于数字)\",\"127.0.0.1:6379> set age 20 OK 127.0.0.1:6379> incr age (integer) 21 127.0.0.1:6379> decr age (integer) 20\",\"INCRBY/DECRBY key n\",\"按指定的步长对数值进行加减\",\"127.0.0.1:6379> INCRBY age 5 (integer) 25 127.0.0.1:6379> DECRBY age 10 (integer) 15\",\"INCRBYFLOAT key n\",\"为数值加上浮点型数值\",\"127.0.0.1:6379> INCRBYFLOAT age 5.2 “20.2”\",\"STRLEN key\",\"获取key保存值的字符串长度\",\"127.0.0.1:6379> get msg “hello world” 127.0.0.1:6379> STRLEN msg (integer) 11\",\"GETRANGE key start end\",\"按起止位置获取字符串（闭区间，起止位置都取）\",\"127.0.0.1:6379> get msg “hello world” 127.0.0.1:6379> GETRANGE msg 3 9 “lo worl”\",\"SETRANGE key offset value\",\"用指定的value 替换key中 offset开始的值\",\"127.0.0.1:6379> SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379> get msg “tehello”\",\"GETSET key value\",\"将给定 key 的值设为 value ，并返回 key 的旧值(old value)。\",\"127.0.0.1:6379> GETSET msg test “hello world”\",\"SETNX key value\",\"仅当key不存在时进行set\",\"127.0.0.1:6379> SETNX msg test (integer) 0 127.0.0.1:6379> SETNX name sakura (integer) 1\",\"SETEX key seconds value\",\"set 键值对并设置过期时间\",\"127.0.0.1:6379> setex name 10 root OK 127.0.0.1:6379> get name (nil)\",\"MSET key1 value1 [key2 value2..]\",\"批量set键值对\",\"127.0.0.1:6379> MSET k1 v1 k2 v2 k3 v3 OK\",\"MSETNX key1 value1 [key2 value2..]\",\"批量设置键值对，仅当参数中所有的key都不存在时执行\",\"127.0.0.1:6379> MSETNX k1 v1 k4 v4 (integer) 0\",\"MGET key1 [key2..]\",\"批量获取多个key保存的值\",\"127.0.0.1:6379> MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”\",\"PSETEX key milliseconds value\",\"和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，\",\"getset key value\",\"如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值\",\"String类似的使用场景：value除了是字符串还可以是数字，用途举例：\",\"计数器\",\"统计多单位的数量：uid:123666：follow 0\",\"粉丝数\",\"对象存储缓存\"]},\"708\":{\"h\":\"List(列表)\",\"t\":[\"Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边），一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。\",\"首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等\",\"正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN\",\"命令\",\"描述\",\"LPUSH/RPUSH key value1[value2..]\",\"从左边/右边向列表中PUSH值(一个或者多个)。\",\"LRANGE key start end\",\"获取list 起止元素（索引从左往右 递增）\",\"LPUSHX/RPUSHX key value\",\"向已存在的列名中push值（一个或者多个）\",\"`LINSERT key BEFORE\",\"AFTER pivot value`\",\"LLEN key\",\"查看列表长度\",\"LINDEX key index\",\"通过索引获取列表元素\",\"LSET key index value\",\"通过索引为元素设值\",\"LPOP/RPOP key\",\"从最左边/最右边移除值 并返回\",\"RPOPLPUSH source destination\",\"将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部\",\"LTRIM key start end\",\"通过下标截取指定范围内的列表\",\"LREM key count value\",\"List中是允许value重复的 count > 0：从头部开始搜索 然后删除指定的value 至多删除count个 count < 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。\",\"BLPOP/BRPOP key1[key2] timout\",\"移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\",\"BRPOPLPUSH source destination timeout\",\"和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\",\"---------------------------LPUSH---RPUSH---LRANGE-------------------------------- 127.0.0.1:6379> LPUSH mylist k1 # LPUSH mylist=>{1} (integer) 1 127.0.0.1:6379> LPUSH mylist k2 # LPUSH mylist=>{2,1} (integer) 2 127.0.0.1:6379> RPUSH mylist k3 # RPUSH mylist=>{2,1,3} (integer) 3 127.0.0.1:6379> get mylist # 普通的get是无法获取list值的 (error) WRONGTYPE Operation against a key holding the wrong kind of value 127.0.0.1:6379> LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素 1) \\\"k2\\\" 2) \\\"k1\\\" 3) \\\"k3\\\" 127.0.0.1:6379> LRANGE mylist 0 2 1) \\\"k2\\\" 2) \\\"k1\\\" 3) \\\"k3\\\" 127.0.0.1:6379> LRANGE mylist 0 1 1) \\\"k2\\\" 2) \\\"k1\\\" 127.0.0.1:6379> LRANGE mylist 0 -1 # 获取全部元素 1) \\\"k2\\\" 2) \\\"k1\\\" 3) \\\"k3\\\" ---------------------------LPUSHX---RPUSHX----------------------------------- 127.0.0.1:6379> LPUSHX list v1 # list不存在 LPUSHX失败 (integer) 0 127.0.0.1:6379> LPUSHX list v1 v2 (integer) 0 127.0.0.1:6379> LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5 (integer) 5 127.0.0.1:6379> LRANGE mylist 0 -1 1) \\\"k5\\\" 2) \\\"k4\\\" 3) \\\"k2\\\" 4) \\\"k1\\\" 5) \\\"k3\\\" ---------------------------LINSERT--LLEN--LINDEX--LSET---------------------------- 127.0.0.1:6379> LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1 (integer) 6 127.0.0.1:6379> LRANGE mylist 0 -1 1) \\\"k5\\\" 2) \\\"k4\\\" 3) \\\"k2\\\" 4) \\\"ins_key1\\\" 5) \\\"k1\\\" 6) \\\"k3\\\" 127.0.0.1:6379> LLEN mylist # 查看mylist的长度 (integer) 6 127.0.0.1:6379> LINDEX mylist 3 # 获取下标为3的元素 \\\"ins_key1\\\" 127.0.0.1:6379> LINDEX mylist 0 \\\"k5\\\" 127.0.0.1:6379> LSET mylist 3 k6 # 将下标3的元素 set值为k6 OK 127.0.0.1:6379> LRANGE mylist 0 -1 1) \\\"k5\\\" 2) \\\"k4\\\" 3) \\\"k2\\\" 4) \\\"k6\\\" 5) \\\"k1\\\" 6) \\\"k3\\\" ---------------------------LPOP--RPOP-------------------------- 127.0.0.1:6379> LPOP mylist # 左侧(头部)弹出 \\\"k5\\\" 127.0.0.1:6379> RPOP mylist # 右侧(尾部)弹出 \\\"k3\\\" ---------------------------RPOPLPUSH-------------------------- 127.0.0.1:6379> LRANGE mylist 0 -1 1) \\\"k4\\\" 2) \\\"k2\\\" 3) \\\"k6\\\" 4) \\\"k1\\\" 127.0.0.1:6379> RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部 \\\"k1\\\" 127.0.0.1:6379> LRANGE newlist 0 -1 1) \\\"k1\\\" 127.0.0.1:6379> LRANGE mylist 0 -1 1) \\\"k4\\\" 2) \\\"k2\\\" 3) \\\"k6\\\" ---------------------------LTRIM-------------------------- 127.0.0.1:6379> LTRIM mylist 0 1 # 截取mylist中的 0~1部分 OK 127.0.0.1:6379> LRANGE mylist 0 -1 1) \\\"k4\\\" 2) \\\"k2\\\" # 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2 ---------------------------LREM-------------------------- 127.0.0.1:6379> LREM mylist 3 k2 # 从头部开始搜索 至多删除3个 k2 (integer) 3 # 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2 127.0.0.1:6379> LREM mylist -2 k2 #从尾部开始搜索 至多删除2个 k2 (integer) 2 # 删除后：mylist: k2,k2,k2,k4,k2,k2 ---------------------------BLPOP--BRPOP-------------------------- mylist: k2,k2,k2,k4,k2,k2 newlist: k1 127.0.0.1:6379> BLPOP newlist mylist 30 # 从newlist中弹出第一个值，mylist作为候选 1) \\\"newlist\\\" # 弹出 2) \\\"k1\\\" 127.0.0.1:6379> BLPOP newlist mylist 30 1) \\\"mylist\\\" # 由于newlist空了 从mylist中弹出 2) \\\"k2\\\" 127.0.0.1:6379> BLPOP newlist 30 (30.10s) # 超时了 127.0.0.1:6379> BLPOP newlist 30 # 我们连接另一个客户端向newlist中push了test, 阻塞被解决。 1) \\\"newlist\\\" 2) \\\"test\\\" (12.54s) \",\"小结：\",\"list实际上是一个链表，before Node after , left, right 都可以插入值\",\"如果key不存在，则创建新的链表\",\"如果key存在，新增内容\",\"如果移除了所有值，空链表，也代表不存在\",\"在两边插入或者改动值，效率最高！修改中间元素，效率相对较低\",\"应用：\",\"消息排队\",\"消息队列（Lpush Rpop）\",\"栈（Lpush Lpop）\"]},\"709\":{\"h\":\"Set(集合)\",\"t\":[\"Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)，集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\",\"命令\",\"描述\",\"SADD key member1[member2..]\",\"向集合中无序增加一个/多个成员\",\"SCARD key\",\"获取集合的成员数\",\"SMEMBERS key\",\"返回集合中所有的成员\",\"SISMEMBER key member\",\"查询member元素是否是集合的成员,结果是无序的\",\"SRANDMEMBER key [count]\",\"随机返回集合中count个成员，count缺省值为1\",\"SPOP key [count]\",\"随机移除并返回集合中count个成员，count缺省值为1\",\"SMOVE source destination member\",\"将source集合的成员member移动到destination集合\",\"SREM key member1[member2..]\",\"移除集合中一个/多个成员\",\"SDIFF key1[key2..]\",\"返回所有集合的差集 key1- key2 - …\",\"SDIFFSTORE destination key1[key2..]\",\"在SDIFF的基础上，将结果保存到集合中(覆盖)。不能保存到其他类型key噢！\",\"SINTER key1 [key2..]\",\"返回所有集合的交集\",\"SINTERSTORE destination key1[key2..]\",\"在SINTER的基础上，存储结果到集合中。覆盖\",\"SUNION key1 [key2..]\",\"返回所有集合的并集\",\"SUNIONSTORE destination key1 [key2..]\",\"在SUNION的基础上，存储结果到及和张。覆盖\",\"SSCAN KEY [MATCH pattern] [COUNT count]\",\"在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分\",\"---------------SADD--SCARD--SMEMBERS--SISMEMBER-------------------- 127.0.0.1:6379> SADD myset m1 m2 m3 m4 # 向myset中增加成员 m1~m4 (integer) 4 127.0.0.1:6379> SCARD myset # 获取集合的成员数目 (integer) 4 127.0.0.1:6379> smembers myset # 获取集合中所有成员 1) \\\"m4\\\" 2) \\\"m3\\\" 3) \\\"m2\\\" 4) \\\"m1\\\" 127.0.0.1:6379> SISMEMBER myset m5 # 查询m5是否是myset的成员 (integer) 0 # 不是，返回0 127.0.0.1:6379> SISMEMBER myset m2 (integer) 1 # 是，返回1 127.0.0.1:6379> SISMEMBER myset m3 (integer) 1 ---------------------SRANDMEMBER--SPOP---------------------------------- 127.0.0.1:6379> SRANDMEMBER myset 3 # 随机返回3个成员 1) \\\"m2\\\" 2) \\\"m3\\\" 3) \\\"m4\\\" 127.0.0.1:6379> SRANDMEMBER myset # 随机返回1个成员 \\\"m3\\\" 127.0.0.1:6379> SPOP myset 2 # 随机移除并返回2个成员 1) \\\"m1\\\" 2) \\\"m4\\\" # 将set还原到{m1,m2,m3,m4} ---------------------SMOVE--SREM---------------------------------------- 127.0.0.1:6379> SMOVE myset newset m3 # 将myset中m3成员移动到newset集合 (integer) 1 127.0.0.1:6379> SMEMBERS myset 1) \\\"m4\\\" 2) \\\"m2\\\" 3) \\\"m1\\\" 127.0.0.1:6379> SMEMBERS newset 1) \\\"m3\\\" 127.0.0.1:6379> SREM newset m3 # 从newset中移除m3元素 (integer) 1 127.0.0.1:6379> SMEMBERS newset (empty list or set) # 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算 # setx=>{m1,m2,m4,m6}, sety=>{m2,m5,m6}, setz=>{m1,m3,m6} -----------------------------SDIFF------------------------------------ 127.0.0.1:6379> SDIFF setx sety setz # 等价于setx-sety-setz 1) \\\"m4\\\" 127.0.0.1:6379> SDIFF setx sety # setx - sety 1) \\\"m4\\\" 2) \\\"m1\\\" 127.0.0.1:6379> SDIFF sety setx # sety - setx 1) \\\"m5\\\" -------------------------SINTER--------------------------------------- # 共同关注（交集） 127.0.0.1:6379> SINTER setx sety setz # 求 setx、sety、setx的交集 1) \\\"m6\\\" 127.0.0.1:6379> SINTER setx sety # 求setx sety的交集 1) \\\"m2\\\" 2) \\\"m6\\\" -------------------------SUNION--------------------------------------- 127.0.0.1:6379> SUNION setx sety setz # setx sety setz的并集 1) \\\"m4\\\" 2) \\\"m6\\\" 3) \\\"m3\\\" 4) \\\"m2\\\" 5) \\\"m1\\\" 6) \\\"m5\\\" 127.0.0.1:6379> SUNION setx sety # setx sety 并集 1) \\\"m4\\\" 2) \\\"m6\\\" 3) \\\"m2\\\" 4) \\\"m1\\\" 5) \\\"m5\\\" \"]},\"710\":{\"h\":\"Hash（哈希）\",\"t\":[\"Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象，Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。\",\"命令\",\"描述\",\"HSET key field value\",\"将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0\",\"HMSET key field1 value1 [field2 value2..]\",\"同时将多个 field-value (域-值)对设置到哈希表 key 中。\",\"HSETNX key field value\",\"只有在字段 field 不存在时，设置哈希表字段的值。\",\"HEXISTS key field\",\"查看哈希表 key 中，指定的字段是否存在。\",\"HGET key field value\",\"获取存储在哈希表中指定字段的值\",\"HMGET key field1 [field2..]\",\"获取所有给定字段的值\",\"HGETALL key\",\"获取在哈希表key 的所有字段和值\",\"HKEYS key\",\"获取哈希表key中所有的字段\",\"HLEN key\",\"获取哈希表中字段的数量\",\"HVALS key\",\"获取哈希表中所有值\",\"HDEL key field1 [field2..]\",\"删除哈希表key中一个/多个field字段\",\"HINCRBY key field n\",\"为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段\",\"HINCRBYFLOAT key field n\",\"为哈希表 key 中的指定字段的浮点数值加上增量 n。\",\"HSCAN key cursor [MATCH pattern] [COUNT count]\",\"迭代哈希表中的键值对。\",\"------------------------HSET--HMSET--HSETNX---------------- 127.0.0.1:6379> HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura (integer) 1 127.0.0.1:6379> HSET studentx name gyc # 重复设置field进行覆盖，并返回0 (integer) 0 127.0.0.1:6379> HSET studentx age 20 # 设置studentx的age为20 (integer) 1 127.0.0.1:6379> HMSET studentx sex 1 tel 15623667886 # 设置sex为1，tel为15623667886 OK 127.0.0.1:6379> HSETNX studentx name gyc # HSETNX 设置已存在的field (integer) 0 # 失败 127.0.0.1:6379> HSETNX studentx email 12345@qq.com (integer) 1 # 成功 ----------------------HEXISTS-------------------------------- 127.0.0.1:6379> HEXISTS studentx name # name字段在studentx中是否存在 (integer) 1 # 存在 127.0.0.1:6379> HEXISTS studentx addr (integer) 0 # 不存在 -------------------HGET--HMGET--HGETALL----------- 127.0.0.1:6379> HGET studentx name # 获取studentx中name字段的value \\\"gyc\\\" 127.0.0.1:6379> HMGET studentx name age tel # 获取studentx中name、age、tel字段的value 1) \\\"gyc\\\" 2) \\\"20\\\" 3) \\\"15623667886\\\" 127.0.0.1:6379> HGETALL studentx # 获取studentx中所有的field及其value 1) \\\"name\\\" 2) \\\"gyc\\\" 3) \\\"age\\\" 4) \\\"20\\\" 5) \\\"sex\\\" 6) \\\"1\\\" 7) \\\"tel\\\" 8) \\\"15623667886\\\" 9) \\\"email\\\" 10) \\\"12345@qq.com\\\" --------------------HKEYS--HLEN--HVALS-------------- 127.0.0.1:6379> HKEYS studentx # 查看studentx中所有的field 1) \\\"name\\\" 2) \\\"age\\\" 3) \\\"sex\\\" 4) \\\"tel\\\" 5) \\\"email\\\" 127.0.0.1:6379> HLEN studentx # 查看studentx中的字段数量 (integer) 5 127.0.0.1:6379> HVALS studentx # 查看studentx中所有的value 1) \\\"gyc\\\" 2) \\\"20\\\" 3) \\\"1\\\" 4) \\\"15623667886\\\" 5) \\\"12345@qq.com\\\" -------------------------HDEL-------------------------- 127.0.0.1:6379> HDEL studentx sex tel # 删除studentx 中的sex、tel字段 (integer) 2 127.0.0.1:6379> HKEYS studentx 1) \\\"name\\\" 2) \\\"age\\\" 3) \\\"email\\\" -------------HINCRBY--HINCRBYFLOAT------------------------ 127.0.0.1:6379> HINCRBY studentx age 1 # studentx的age字段数值+1 (integer) 21 127.0.0.1:6379> HINCRBY studentx name 1 # 非整数字型字段不可用 (error) ERR hash value is not an integer 127.0.0.1:6379> HINCRBYFLOAT studentx weight 0.6 # weight字段增加0.6 \\\"90.8\\\" \",\"Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！Hash更适合于对象的存储，Sring更加适合字符串存储！\"]},\"711\":{\"h\":\"Zset（有序集合）\",\"t\":[\"不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。score相同：按字典顺序排序，有序集合的成员是唯一的，但分数(score)却可以重复。\",\"命令\",\"描述\",\"ZADD key score member1 [score2 member2]\",\"向有序集合添加一个或多个成员，或者更新已存在成员的分数\",\"ZCARD key\",\"获取有序集合的成员数\",\"ZCOUNT key min max\",\"计算在有序集合中指定区间score的成员数\",\"ZINCRBY key n member\",\"有序集合中对指定成员的分数加上增量 n\",\"ZSCORE key member\",\"返回有序集中，成员的分数值\",\"ZRANK key member\",\"返回有序集合中指定成员的索引\",\"ZRANGE key start end\",\"通过索引区间返回有序集合成指定区间内的成员\",\"ZRANGEBYLEX key min max\",\"通过字典区间返回有序集合的成员\",\"ZRANGEBYSCORE key min max\",\"通过分数返回有序集合指定区间内的成员-inf 和 +inf分别表示最小最大值，只支持开区间()\",\"ZLEXCOUNT key min max\",\"在有序集合中计算指定字典区间内成员数量\",\"ZREM key member1 [member2..]\",\"移除有序集合中一个/多个成员\",\"ZREMRANGEBYLEX key min max\",\"移除有序集合中给定的字典区间的所有成员\",\"ZREMRANGEBYRANK key start stop\",\"移除有序集合中给定的排名区间的所有成员\",\"ZREMRANGEBYSCORE key min max\",\"移除有序集合中给定的分数区间的所有成员\",\"ZREVRANGE key start end\",\"返回有序集中指定区间内的成员，通过索引，分数从高到底\",\"ZREVRANGEBYSCORRE key max min\",\"返回有序集中指定分数区间内的成员，分数从高到低排序\",\"ZREVRANGEBYLEX key max min\",\"返回有序集中指定字典区间内的成员，按字典顺序倒序\",\"ZREVRANK key member\",\"返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序\",\"ZINTERSTORE destination numkeys key1 [key2 ..]\",\"计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score\",\"ZUNIONSTORE destination numkeys key1 [key2..]\",\"计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中\",\"ZSCAN key cursor [MATCH pattern\\\\] [COUNT count]\",\"迭代有序集合中的元素（包括元素成员和元素分值）\",\"-------------------ZADD--ZCARD--ZCOUNT-------------- 127.0.0.1:6379> ZADD myzset 1 m1 2 m2 3 m3 # 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2.. (integer) 2 127.0.0.1:6379> ZCARD myzset # 获取有序集合的成员数 (integer) 2 127.0.0.1:6379> ZCOUNT myzset 0 1 # 获取score在 [0,1]区间的成员数量 (integer) 1 127.0.0.1:6379> ZCOUNT myzset 0 2 (integer) 2 ----------------ZINCRBY--ZSCORE-------------------------- 127.0.0.1:6379> ZINCRBY myzset 5 m2 # 将成员m2的score +5 \\\"7\\\" 127.0.0.1:6379> ZSCORE myzset m1 # 获取成员m1的score \\\"1\\\" 127.0.0.1:6379> ZSCORE myzset m2 \\\"7\\\" --------------ZRANK--ZRANGE----------------------------------- 127.0.0.1:6379> ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加 (integer) 0 127.0.0.1:6379> ZRANK myzset m2 (integer) 2 127.0.0.1:6379> ZRANGE myzset 0 1 # 获取索引在 0~1的成员 1) \\\"m1\\\" 2) \\\"m3\\\" 127.0.0.1:6379> ZRANGE myzset 0 -1 # 获取全部成员 1) \\\"m1\\\" 2) \\\"m3\\\" 3) \\\"m2\\\" #testset=>{abc,add,amaze,apple,back,java,redis} score均为0 ------------------ZRANGEBYLEX--------------------------------- 127.0.0.1:6379> ZRANGEBYLEX testset - + # 返回所有成员 1) \\\"abc\\\" 2) \\\"add\\\" 3) \\\"amaze\\\" 4) \\\"apple\\\" 5) \\\"back\\\" 6) \\\"java\\\" 7) \\\"redis\\\" 127.0.0.1:6379> ZRANGEBYLEX testset - + LIMIT 0 3 # 分页 按索引显示查询结果的 0,1,2条记录 1) \\\"abc\\\" 2) \\\"add\\\" 3) \\\"amaze\\\" 127.0.0.1:6379> ZRANGEBYLEX testset - + LIMIT 3 3 # 显示 3,4,5条记录 1) \\\"apple\\\" 2) \\\"back\\\" 3) \\\"java\\\" 127.0.0.1:6379> ZRANGEBYLEX testset (- [apple # 显示 (-,apple] 区间内的成员 1) \\\"abc\\\" 2) \\\"add\\\" 3) \\\"amaze\\\" 4) \\\"apple\\\" 127.0.0.1:6379> ZRANGEBYLEX testset [apple [java # 显示 [apple,java]字典区间的成员 1) \\\"apple\\\" 2) \\\"back\\\" 3) \\\"java\\\" -----------------------ZRANGEBYSCORE--------------------- 127.0.0.1:6379> ZRANGEBYSCORE myzset 1 10 # 返回score在 [1,10]之间的的成员 1) \\\"m1\\\" 2) \\\"m3\\\" 3) \\\"m2\\\" 127.0.0.1:6379> ZRANGEBYSCORE myzset 1 5 1) \\\"m1\\\" 2) \\\"m3\\\" --------------------ZLEXCOUNT----------------------------- 127.0.0.1:6379> ZLEXCOUNT testset - + (integer) 7 127.0.0.1:6379> ZLEXCOUNT testset [apple [java (integer) 3 ------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE-------------------------------- 127.0.0.1:6379> ZREM testset abc # 移除成员abc (integer) 1 127.0.0.1:6379> ZREMRANGEBYLEX testset [apple [java # 移除字典区间[apple,java]中的所有成员 (integer) 3 127.0.0.1:6379> ZREMRANGEBYRANK testset 0 1 # 移除排名0~1的所有成员 (integer) 2 127.0.0.1:6379> ZREMRANGEBYSCORE myzset 0 3 # 移除score在 [0,3]的成员 (integer) 2 # testset=> {abc,add,apple,amaze,back,java,redis} score均为0 # myzset=> {(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)} ----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX----------- 127.0.0.1:6379> ZREVRANGE myzset 0 3 # 按score递减排序，然后按索引，返回结果的 0~3 1) \\\"m9\\\" 2) \\\"m7\\\" 3) \\\"m4\\\" 4) \\\"m3\\\" 127.0.0.1:6379> ZREVRANGE myzset 2 4 # 返回排序结果的 索引的2~4 1) \\\"m4\\\" 2) \\\"m3\\\" 3) \\\"m2\\\" 127.0.0.1:6379> ZREVRANGEBYSCORE myzset 6 2 # 按score递减顺序 返回集合中分数在[2,6]之间的成员 1) \\\"m4\\\" 2) \\\"m3\\\" 3) \\\"m2\\\" 127.0.0.1:6379> ZREVRANGEBYLEX testset [java (add # 按字典倒序 返回集合中(add,java]字典区间的成员 1) \\\"java\\\" 2) \\\"back\\\" 3) \\\"apple\\\" 4) \\\"amaze\\\" -------------------------ZREVRANK------------------------------ 127.0.0.1:6379> ZREVRANK myzset m7 # 按score递减顺序，返回成员m7索引 (integer) 1 127.0.0.1:6379> ZREVRANK myzset m2 (integer) 4 # mathscore=>{(xm,90),(xh,95),(xg,87)} 小明、小红、小刚的数学成绩 # enscore=>{(xm,70),(xh,93),(xg,90)} 小明、小红、小刚的英语成绩 -------------------ZINTERSTORE--ZUNIONSTORE----------------------------------- 127.0.0.1:6379> ZINTERSTORE sumscore 2 mathscore enscore # 将mathscore enscore进行合并 结果存放到sumscore (integer) 3 127.0.0.1:6379> ZRANGE sumscore 0 -1 withscores # 合并后的score是之前集合中所有score的和 1) \\\"xm\\\" 2) \\\"160\\\" 3) \\\"xg\\\" 4) \\\"177\\\" 5) \\\"xh\\\" 6) \\\"188\\\" 127.0.0.1:6379> ZUNIONSTORE lowestscore 2 mathscore enscore AGGREGATE MIN # 取两个集合的成员score最小值作为结果的 (integer) 3 127.0.0.1:6379> ZRANGE lowestscore 0 -1 withscores 1) \\\"xm\\\" 2) \\\"70\\\" 3) \\\"xg\\\" 4) \\\"87\\\" 5) \\\"xh\\\" 6) \\\"93\\\" \",\"应用案例：\",\"set排序 存储班级成绩表 工资表排序！\",\"普通消息，1.重要消息 2.带权重进行判断\",\"排行榜应用实现，取Top N测试\"]},\"712\":{\"h\":\"三种特殊数据类型\"},\"713\":{\"h\":\"Geospatial(地理位置)\",\"t\":[\"使用经纬度定位地理坐标并用一个有序集合zset保存，所以zset命令也可以使用。\",\"命令\",\"描述\",\"geoadd key longitud(经度) latitude(纬度) member [..]\",\"将具体经纬度的坐标存入一个有序集合\",\"geopos key member [member..]\",\"获取集合中的一个/多个成员坐标\",\"geodist key member1 member2 [unit]\",\"返回两个给定位置之间的距离。默认以米作为单位。\",\"`georadius key longitude latitude radius m\",\"km\",\"GEORADIUSBYMEMBER key member radius...\",\"功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。\",\"geohash key member1 [member2..]\",\"返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。\",\"有效经纬度\",\"有效的经度从-180度到180度。\",\"有效的纬度从-85.05112878度到85.05112878度。\",\"指定单位的参数 unit 必须是以下单位的其中一个：\",\"m 表示单位为米。\",\"km 表示单位为千米。\",\"mi 表示单位为英里。\",\"ft 表示单位为英尺。\",\"关于GEORADIUS的参数\",\"通过georadius就可以完成 附近的人功能\",\"withcoord:带上坐标\",\"withdist:带上距离，单位与半径单位相同\",\"COUNT n : 只显示前n个(按距离递增排序)\",\"----------------georadius--------------------- 127.0.0.1:6379> GEORADIUS china:city 120 30 500 km withcoord withdist # 查询经纬度(120,30)坐标500km半径内的成员 1) 1) \\\"hangzhou\\\" 2) \\\"29.4151\\\" 3) 1) \\\"120.20000249147415\\\" 2) \\\"30.199999888333501\\\" 2) 1) \\\"shanghai\\\" 2) \\\"205.3611\\\" 3) 1) \\\"121.40000134706497\\\" 2) \\\"31.400000253193539\\\" ------------geohash--------------------------- 127.0.0.1:6379> geohash china:city yichang shanghai # 获取成员经纬坐标的geohash表示 1) \\\"wmrjwbr5250\\\" 2) \\\"wtw6ds0y300\\\" \"]},\"714\":{\"h\":\"Hyperloglog(基数统计)\",\"t\":[\"Redis HyperLogLog 是用来做基数（数据集中不重复的元素的个数）统计的数据结构，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。\",\"花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。\",\"因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。\",\"应用场景：网页的访问量（UV），一个用户多次访问，也只能算作一个人。\",\"传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是计数，Hyperloglog就能帮助我们利用最小的空间完成。\",\"命令\",\"描述\",\"PFADD key element1 [elememt2..]\",\"添加指定元素到 HyperLogLog 中\",\"PFCOUNT key [key]\",\"返回给定 HyperLogLog 的基数估算值。\",\"PFMERGE destkey sourcekey [sourcekey..]\",\"将多个 HyperLogLog 合并为一个 HyperLogLog\",\"----------PFADD--PFCOUNT--------------------- 127.0.0.1:6379> PFADD myelemx a b c d e f g h i j k # 添加元素 (integer) 1 127.0.0.1:6379> type myelemx # hyperloglog底层使用String string 127.0.0.1:6379> PFCOUNT myelemx # 估算myelemx的基数 (integer) 11 127.0.0.1:6379> PFADD myelemy i j k z m c b v p q s (integer) 1 127.0.0.1:6379> PFCOUNT myelemy (integer) 11 ----------------PFMERGE----------------------- 127.0.0.1:6379> PFMERGE myelemz myelemx myelemy # 合并myelemx和myelemy 成为myelemz OK 127.0.0.1:6379> PFCOUNT myelemz # 估算基数 (integer) 17 \",\"如果允许容错，那么一定可以使用Hyperloglog !\",\"如果不允许容错，就使用set或者自己的数据类型即可 ！\"]},\"715\":{\"h\":\"BitMaps(位图)\",\"t\":[\"使用位存储，信息状态只有 0 和 1，Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。\",\"应用场景：签到统计、状态统计\",\"命令\",\"描述\",\"setbit key offset value\",\"为指定key的offset位设置值\",\"getbit key offset\",\"获取offset位的值\",\"bitcount key [start end]\",\"统计字符串被设置为1的bit数，也可以指定统计范围按字节\",\"bitop operration destkey key[key..]\",\"对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。\",\"BITPOS key bit [start] [end]\",\"返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位\",\"------------setbit--getbit-------------- 127.0.0.1:6379> setbit sign 0 1 # 设置sign的第0位为 1 (integer) 0 127.0.0.1:6379> setbit sign 2 1 # 设置sign的第2位为 1 不设置默认 是0 (integer) 0 127.0.0.1:6379> setbit sign 3 1 (integer) 0 127.0.0.1:6379> setbit sign 5 1 (integer) 0 127.0.0.1:6379> type sign string 127.0.0.1:6379> getbit sign 2 # 获取第2位的数值 (integer) 1 127.0.0.1:6379> getbit sign 3 (integer) 1 127.0.0.1:6379> getbit sign 4 # 未设置默认是0 (integer) 0 -----------bitcount---------------------------- 127.0.0.1:6379> BITCOUNT sign # 统计sign中为1的位数 (integer) 4 \",\"这样设置以后你能get到的值是：\\\\xA2\\\\x80，所以bitmaps是一串从左到右的二进制串\",\"Redis的事务就是指一组命令的集合，Redis的单条命令是保证原子性的，但是redis事务不能保证原子性，并且Redis事务没有隔离级别的概念。\",\"事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。\",\"一次性\",\"顺序性\",\"排他性\"]},\"716\":{\"h\":\"操作过程\",\"t\":[\"开启事务（multi）\",\"命令入队\",\"执行事务（exec）\",\"所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。\",\"127.0.0.1:6379> multi # 开启事务 OK 127.0.0.1:6379> set k1 v1 # 命令入队 QUEUED 127.0.0.1:6379> set k2 v2 # .. QUEUED 127.0.0.1:6379> get k1 QUEUED 127.0.0.1:6379> set k3 v3 QUEUED 127.0.0.1:6379> keys * QUEUED 127.0.0.1:6379> exec # 事务执行 1) OK 2) OK 3) \\\"v1\\\" 4) OK 5) 1) \\\"k3\\\" 2) \\\"k2\\\" 3) \\\"k1\\\" \",\"取消事务(discurd)\",\"127.0.0.1:6379> multi OK 127.0.0.1:6379> set k1 v1 QUEUED 127.0.0.1:6379> set k2 v2 QUEUED 127.0.0.1:6379> DISCARD # 放弃事务 OK 127.0.0.1:6379> EXEC (error) ERR EXEC without MULTI # 当前未开启事务 127.0.0.1:6379> get k1 # 被放弃事务中命令并未执行 (nil) \"]},\"717\":{\"h\":\"事务错误\",\"t\":[\"代码语法错误（编译时异常）所有的命令都不执行：\",\"127.0.0.1:6379> multi OK 127.0.0.1:6379> set k1 v1 QUEUED 127.0.0.1:6379> set k2 v2 QUEUED 127.0.0.1:6379> error k1 # 这是一条语法错误命令 (error) ERR unknown command `error`, with args beginning with: `k1`, # 会报错但是不影响后续命令入队 127.0.0.1:6379> get k2 QUEUED 127.0.0.1:6379> EXEC (error) EXECABORT Transaction discarded because of previous errors. # 执行报错 127.0.0.1:6379> get k1 (nil) # 其他命令并没有被执行 \",\"当代码逻辑错误 (运行时异常) ，其他命令可以正常执行，因此说Redis所以不保证事务原子性：\",\"127.0.0.1:6379> multi OK 127.0.0.1:6379> set k1 v1 QUEUED 127.0.0.1:6379> set k2 v2 QUEUED 127.0.0.1:6379> INCR k1 # 这条命令逻辑错误（对字符串进行增量） QUEUED 127.0.0.1:6379> get k2 QUEUED 127.0.0.1:6379> exec 1) OK 2) OK 3) (error) ERR value is not an integer or out of range # 运行时报错 4) \\\"v2\\\" # 其他命令正常执行 # 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。 # 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。 \"]},\"718\":{\"h\":\"监控\",\"t\":[\"使用watch key监控指定数据，相当于乐观锁加锁。\",\"正常执行：\",\"127.0.0.1:6379> set money 100 # 设置余额:100 OK 127.0.0.1:6379> set use 0 # 支出使用:0 OK 127.0.0.1:6379> watch money # 监视money (上锁) OK 127.0.0.1:6379> multi OK 127.0.0.1:6379> DECRBY money 20 QUEUED 127.0.0.1:6379> INCRBY use 20 QUEUED 127.0.0.1:6379> exec # 监视值没有被中途修改，事务正常执行 1) (integer) 80 2) (integer) 20 \",\"测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion）：\",\"我们启动另外一个客户端模拟插队线程。\",\"线程1：\",\"127.0.0.1:6379> watch money # money上锁 OK 127.0.0.1:6379> multi OK 127.0.0.1:6379> DECRBY money 20 QUEUED 127.0.0.1:6379> INCRBY use 20 QUEUED 127.0.0.1:6379> # 此时事务并没有执行 \",\"模拟线程插队，线程2：\",\"127.0.0.1:6379> INCRBY money 500 # 修改了线程一中监视的money (integer) 600 12 \",\"回到线程1，执行事务：\",\"127.0.0.1:6379> EXEC # 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败 (nil) # 没有结果，说明事务执行失败 127.0.0.1:6379> get money # 线程2 修改生效 \\\"600\\\" 127.0.0.1:6379> get use # 线程1事务执行失败，数值没有被修改 \\\"0\\\" \",\"解锁获取最新值，然后再加锁进行事务。unwatch进行解锁。注意：每次提交执行exec后都会自动释放锁，不管是否成功\"]},\"719\":{\"h\":\"Jedis\",\"t\":[\"使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。\",\"导入相关依赖：\",\"<!--导入jredis的包--> <dependency> <groupId>redis.clients</groupId> <artifactId>jedis</artifactId> <version>3.2.0</version> </dependency> <!--fastjson--> <dependency> <groupId>com.alibaba</groupId> <artifactId>fastjson</artifactId> <version>1.2.70</version> </dependency> \",\"在做好Redis相关的配置并启动后就可以进行测试：\",\"public class TestPing { public static void main(String[] args) { Jedis jedis = new Jedis(\\\"192.168.xx.xxx\\\", 6379); String response = jedis.ping(); System.out.println(response); // PONG } } \",\"测试事务：\",\"public class TestTX { public static void main(String[] args) { Jedis jedis = new Jedis(\\\"39.99.xxx.xx\\\", 6379); JSONObject jsonObject = new JSONObject(); jsonObject.put(\\\"hello\\\", \\\"world\\\"); jsonObject.put(\\\"name\\\", \\\"kuangshen\\\"); // 开启事务 Transaction multi = jedis.multi(); String result = jsonObject.toJSONString(); // jedis.watch(result) try { multi.set(\\\"user1\\\", result); multi.set(\\\"user2\\\", result); // 执行事务 multi.exec(); }catch (Exception e){ // 放弃事务 multi.discard(); } finally { // 关闭连接 System.out.println(jedis.get(\\\"user1\\\")); System.out.println(jedis.get(\\\"user2\\\")); jedis.close(); } } } \"]},\"720\":{\"h\":\"SpringBoot整合\",\"t\":[\"导入依赖\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> </dependency> \",\"springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。\",\"jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式\",\"lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式\",\"我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。\",\"那么就一定还存在一个RedisProperties类\",\"之前我们说SpringBoot2.x后默认使用Lettuce来替换Jedis，现在我们就能来验证了。\",\"先看Jedis:\",\"@ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的\",\"然后再看Lettuce：\",\"完美生效。\",\"现在我们回到RedisAutoConfiguration\",\"只有两个简单的Bean\",\"RedisTemplate\",\"StringRedisTemplate\",\"当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。\",\"在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的\",\"说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties\",\"这是一些基本的配置属性。\",\"还有一些连接池相关的配置。注意使用时一定使用Lettuce的连接池。\",\"编写配置文件\",\"# 配置redis spring.redis.host=39.99.xxx.xx spring.redis.port=6379 \",\"使用RedisTemplate\",\"@SpringBootTest class Redis02SpringbootApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test void contextLoads() { // redisTemplate 操作不同的数据类型，api和我们的指令是一样的 // opsForValue 操作字符串 类似String // opsForList 操作List 类似List // opsForHah // 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD // 获取连接对象 //RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); //connection.flushDb(); //connection.flushAll(); redisTemplate.opsForValue().set(\\\"mykey\\\",\\\"kuangshen\\\"); System.out.println(redisTemplate.opsForValue().get(\\\"mykey\\\")); } } \",\"测试结果\",\"此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出：\",\"这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。因此项目中通常需要修改RedisTemplate的序列化方式。\",\"定制RedisTemplate的模板：\",\"我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。\",\"@Configuration public class RedisConfig { @Bean public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { // 将template 泛型设置为 <String, Object> RedisTemplate<String, Object> template = new RedisTemplate(); // 连接工厂，不必修改 template.setConnectionFactory(redisConnectionFactory); /* * 序列化设置 */ // key、hash的key 采用 String序列化方式 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // value、hash的value 采用 Jackson 序列化方式 template.setValueSerializer(RedisSerializer.json()); template.setHashValueSerializer(RedisSerializer.json()); template.afterPropertiesSet(); return template; } } \",\"这样一来，只要实体类进行了序列化，我们存什么都不会有乱码的担忧了。\"]},\"721\":{\"h\":\"自定义Redis工具类\",\"t\":[\"使用RedisTemplate需要频繁调用.opForxxx然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。\",\"工具类参考博客：java redisUtils工具类很全\",\"Redis支持RDB和AOF两种持久化机制，持久化功能有效避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件即可实现数据恢复。\",\"Redis持久化文件加载的流程：\"]},\"722\":{\"h\":\"RDB持久化\"},\"723\":{\"h\":\"什么是RDB\",\"t\":[\"RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程可以分为手动触发和自动触发。默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。\"]},\"724\":{\"h\":\"工作原理\",\"t\":[\"RDB的手动触发分别对应save和bgsave命令：\",\"save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的示例会造成长时间则色，线上环境不建议使用。\",\"bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。\",\"显然bgsave命令是针对save阻塞问题做的优化。因此Redis内部所有的涉及RDB的操作都采用bgsave的方式，而save命令已经废弃，因此这里不做过多介绍。\",\"RDB的自动触发只需要在配置文件redis.conf中开启相关配置即可：\",\"save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存 save 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存 save 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存 \"]},\"725\":{\"h\":\"bgsave\",\"t\":[\"bgsave是异步进行，进行持久化的时候，Redis还可以将继续响应客户端请求 ；\",\"详细具体步骤如下：\",\"执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB/AOF子进程，如果存在bgsave命令直接返回\",\"父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位为微秒\",\"父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令\",\"父进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成RDB的时间，对应info统计的rdb_last_save_time选项\",\"进程发送信号给父进程表示完成，父进程更新统计信息\",\"这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求)。\"]},\"726\":{\"h\":\"bgsave和save对比\",\"t\":[\"命令\",\"save\",\"bgsave\",\"IO类型\",\"同步\",\"异步\",\"阻塞\",\"是\",\"是（阻塞发生在fock()，通常非常快）\",\"复杂度\",\"O(n)\",\"O(n)\",\"优点\",\"不会消耗额外的内存\",\"不阻塞客户端命令\",\"缺点\",\"阻塞客户端命令\",\"需要fork子进程，消耗内存\"]},\"727\":{\"h\":\"优点和缺点\",\"t\":[\"优点：\",\"适合大规模的数据恢复\",\"对数据的完整性要求不高\",\"Redis加载RDB恢复数据远远快于AOF的方式\",\"缺点：\",\"需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了\",\"fork进程的时候，会占用一定的内存空间\",\"RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容RDB格式的问题\",\"也可以简单的说，RDB不适合实时持久化。\"]},\"728\":{\"h\":\"持久化AOF\",\"t\":[\"AOF表示Append Only File，这种模式会将所有的命令都记录下来，恢复的时候就把这个文件全部再执行一遍。\",\"以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。\"]},\"729\":{\"h\":\"什么是AOF\",\"t\":[\"快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。\",\"AOF默认是不开启的，需要进行配置才可以：\",\"appendonly yes # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用 appendfilename \\\"appendonly.aof\\\" # appendfsync always # 每次修改都会sync 消耗性能 appendfsync everysec # 每秒执行一次 sync 可能会丢失这一秒的数据 # appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快 \"]},\"730\":{\"h\":\"优点和缺点\",\"t\":[\"优点\",\"每一次修改都会同步，文件的完整性会更加好\",\"没秒同步一次，可能会丢失一秒的数据\",\"从不同步，效率最高\",\"缺点\",\"相对于数据文件来说，AOF远远大于RDB，修复速度比RDB慢\",\"AOF运行效率也要比RDB慢，所以我们Redis默认的配置就是RDB持久化\"]},\"731\":{\"h\":\"RDB和AOP选择\"},\"732\":{\"h\":\"RDB 和 AOF 对比\",\"t\":[\"比较项\",\"RDB\",\"AOF\",\"启动优先级\",\"低\",\"高\",\"体积\",\"小\",\"大\",\"恢复速度\",\"快\",\"慢\",\"数据安全性\",\"丢数据\",\"根据策略决定\"]},\"733\":{\"h\":\"如何选择使用哪种持久化方式？\",\"t\":[\"一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。\",\"Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。\",\"下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：\",\"当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：\"]},\"734\":{\"h\":\"命令\",\"t\":[\"命令\",\"描述\",\"PSUBSCRIBE pattern [pattern..]\",\"订阅一个或多个符合给定模式的频道。\",\"PUNSUBSCRIBE pattern [pattern..]\",\"退订一个或多个符合给定模式的频道。\",\"PUBSUB subcommand [argument[argument]]\",\"查看订阅与发布系统状态。\",\"PUBLISH channel message\",\"向指定频道发布消息\",\"SUBSCRIBE channel [channel..]\",\"订阅给定的一个或多个频道。\",\"SUBSCRIBE channel [channel..]\",\"退订一个或多个频道\"]},\"735\":{\"h\":\"示例\",\"t\":[\"------------订阅端---------------------- 127.0.0.1:6379> SUBSCRIBE sakura # 订阅sakura频道 Reading messages... (press Ctrl-C to quit) # 等待接收消息 1) \\\"subscribe\\\" # 订阅成功的消息 2) \\\"sakura\\\" 3) (integer) 1 1) \\\"message\\\" # 接收到来自sakura频道的消息 \\\"hello world\\\" 2) \\\"sakura\\\" 3) \\\"hello world\\\" 1) \\\"message\\\" # 接收到来自sakura频道的消息 \\\"hello i am sakura\\\" 2) \\\"sakura\\\" 3) \\\"hello i am sakura\\\" --------------消息发布端------------------- 127.0.0.1:6379> PUBLISH sakura \\\"hello world\\\" # 发布消息到sakura频道 (integer) 1 127.0.0.1:6379> PUBLISH sakura \\\"hello i am sakura\\\" # 发布消息 (integer) 1 -----------------查看活跃的频道------------ 127.0.0.1:6379> PUBSUB channels 1) \\\"sakura\\\" \"]},\"736\":{\"h\":\"原理\",\"t\":[\"每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。\",\"客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。\"]},\"737\":{\"h\":\"缺点\",\"t\":[\"如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。\",\"这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。\"]},\"738\":{\"h\":\"应用\",\"t\":[\"消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）\",\"多人在线聊天室。\",\"稍微复杂的场景，我们就会使用消息中间件MQ处理。\",\"在从前的版本中，Redis是个单线程的程序，除了Redis之外，Node.js与Nginx也是单线程，但是它们都是高性能服务器的典范，不过从Redis6.0开始，增加了多线程的支持，以满足更高的性能，具体可以参考：支持多线程的Redis 6.0终于发布了，那么Redis是如何使用单线程处理那么多的并发客户端连接的？答案就是多路复用。\"]},\"739\":{\"h\":\"非阻塞IO\",\"t\":[\"当我们调用套节字的读写方法，默认它们是阻塞的，比如read方法要传递进去一个参数n，表示读取这么多字节后再返回，如果没有读够线程就会卡在那里，直到新的数据刀来或者连接关闭了，read方法才会返回，线程才能继续处理。而write方法一般来说不会阻塞，除非内核为套接字分配的写缓冲区已经满了，write方法就会阻塞，直到缓存区中有空闲空间挪出来了。\",\"非阻塞IO在套接字对象上提供了一个线程Non_Blocking，当这个选项打开时，读写方法不会阻塞，而是能读多少读多少，能写多少写多少。能读多少取决于内核为套接字分配的读缓冲区内部的数据字节数，能写多少取决于内核为套接字分配的写缓冲区的空闲空间字节数。读方法和写方法都会通过返回值来告知程序实际读写了多少字节。\",\"有了非阻塞IO意味着线程在读写IO时可以不必再阻塞了，读写可以瞬间完成然后程序可以继续干别的事了。\"]},\"740\":{\"h\":\"多路复用\",\"t\":[\"非阻塞IO有个问题，那就是线程要读数据，结果读了一部分就返回了，线程如何知道何时才应该继续。也就是当数据到来时，线程如何得到通知。写也是一样，如果缓冲区满了，写不完，剩下的数据何时才应该续写，线程也应该得到通知。\",\"多路复用（事件轮询）API就是用来解决这个问题的，最简单的事件轮询API是select函数，它是操作系统提供给用户程序的API。输入是读写描述符列表read_fds & write_fds，输出是与之对应的可读可写事件。同时还提供了timeout参数，如果没有任何事件到来，那么久最多等待timeout时间，线程处于阻塞状态。一旦期间有任何事情刀来，就可以立即返回。时间过了之后还是没有任何事件到来，也会立即返回。拿到事件后，线程就可以继续挨个处理相应的事件。处理完了继续过来轮询。于是线程就进入了一个死循环，我们把这个死循环称为事件循环，一个循环为一个周期。\",\"每个客户端套接字socket都有对应的读写文件描述符。\",\"read_events,write_events = select(read_fds,write_fds,timeout) for event in read_events: handle_read(event.fd) for event in write_events: handle_write(event.fd) # 处理其它事情，如定时任务等 handle_others() \",\"因为我们通过select系统调用同时处理多个通道描述符的读写事件，因此我们将这类系统调用称为多路复用API。现代操作系统的多路复用API已经不再使用使用select系统调用，而改用epoll(linux)和kqueue(freebsd & macosx)，因为select系统调用的性能再描述符特别多时性能会非常差。它使用起来可能在形式上略有差异，但是本质上都是差不多的，都可以使用上面的伪代码逻辑进行理解。\"]},\"741\":{\"h\":\"指令队列\",\"t\":[\"Redis会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务。\"]},\"742\":{\"h\":\"响应队列\",\"t\":[\"Redis同样会为每个客户端套接字关联一个响应队列。Redis服务器通过响应队列来将指令的返回结果回复给客户端。如果队列为空，那么意味着连接暂时处于空闲状态，不需要去获取写事件，也就是可以将当前的客户端描述符write_fds里面移出来。等到队列有数据了，再将描述符放进去。避免select系统调用立即返回写事件，结果发现没什么数据可以写。出现这种情况的线程会飙高CPU。\"]},\"743\":{\"h\":\"概念\",\"t\":[\"主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。\",\"默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。\"]},\"744\":{\"h\":\"作用\",\"t\":[\"数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。\",\"故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式\",\"负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。\",\"高可用基石：主从复制还是哨兵和集群能够实施的基础。\"]},\"745\":{\"h\":\"为什么使用集群\",\"t\":[\"单台服务器难以负载大量的请求\",\"单台服务器故障率高，系统崩坏概率大\",\"单台服务器内存容量有限。\"]},\"746\":{\"h\":\"环境配置\",\"t\":[\"我们在讲解配置文件的时候，注意到有一个replication模块 (见Redis.conf中第8条)\",\"查看当前库的信息：info replication\",\"127.0.0.1:6379> info replication # Replication role:master # 角色 connected_slaves:0 # 从机数量 master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 \",\"既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：\",\"端口号\",\"pid文件名\",\"日志文件名\",\"rdb文件名\",\"启动单机多服务集群：\"]},\"747\":{\"h\":\"一主二从配置\",\"t\":[\"默认情况下，每台Redis服务器都是主节点；我们一般情况下只用配置从机就好了！\",\"认老大！一主（79）二从（80，81）\",\"使用SLAVEOF host port就可以为从机配置主机了。\",\"然后主机上也能看到从机的状态：\",\"我们这里是使用命令搭建，是暂时的，==真实开发中应该在从机的配置文件中进行配置，==这样的话是永久的。\"]},\"748\":{\"h\":\"使用规则\",\"t\":[\"从机只能读，不能写，主机可读可写但是多用于写。\",\" 127.0.0.1:6381> set name sakura # 从机6381写入失败 (error) READONLY You can't write against a read only replica. 127.0.0.1:6380> set name sakura # 从机6380写入失败 (error) READONLY You can't write against a read only replica. 127.0.0.1:6379> set name sakura OK 127.0.0.1:6379> get name \\\"sakura\\\" \",\"当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。\",\"当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。\",\"第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：\",\"从机手动执行命令slaveof no one,这样执行以后从机会独立出来成为一个主机\",\"使用哨兵模式（自动选举）\",\"如果没有老大了，这个时候能不能选择出来一个老大呢？手动！\",\"如果主机断开了连接，我们可以使用SLAVEOF no one让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！\"]},\"749\":{\"h\":\"复制原理\"},\"750\":{\"h\":\"复制过程\"},\"751\":{\"h\":\"数据同步\"},\"752\":{\"h\":\"全量复制\"},\"753\":{\"h\":\"部分复制\"},\"754\":{\"h\":\"心跳\"},\"755\":{\"h\":\"异步复制\",\"t\":[\"主节点不但负责数据读写，还负责把写命令同步给从节点。写命令的发送过程是异步完成的，也就是说主节点自身处理完写命令后直接返回给客户端，并不等待从节点复制完成，如下图所示：\"]},\"756\":{\"h\":\"作用\",\"t\":[\"主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。\"]},\"757\":{\"h\":\"单机单个哨兵\",\"t\":[\"哨兵的作用：\",\"通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。\",\"当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。\"]},\"758\":{\"h\":\"多哨兵模式\",\"t\":[\"Redis的主从复制模式可以将主节点的数据改变同步给从节点，这样从节点就可以起到两个作用：\",\"作为主节点的备份，一旦主节点出了故障不可达的情况，从节点可以作为后备“顶上来”，并且保证数据尽量不丢失（主从复制时最终一致性）。第二，从节点可以扩展主节点的读能力，一旦主节点不能支撑住大并发量的读操作\",\"第二，从节点可以扩展主节点的读能力，一旦主节点不能支撑住大并发量的读操作，从节点可以在以顶程度上帮助主节点分担读压力\",\"但是主从复制也带来了以下问题：\",\"一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要人工干预\",\"主节点的写能力收到单机的限制\",\"主节点的存储能力收到单机的限制\",\"当主节点出现故障时，Redis的哨兵模式能自动完成故障发现和故障转移，并通知应用方，从而实现真正的高可用。Redis Sentinel是一个分布式架构，其中包含了若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当它发现节点不可达时，会对节点但做下线标识。如果被标识的是主节点，它还会和其他Sentinel节点进行“协商”，当大多数Sentinel节点都认为主节点不可达时，它们会选举出一个Sentinel节点来完成自动故障转移的工作，同时会将这个变化实时通知给Redis应用方。整个过程完全时自动的，不需要人工来介入，所以这套方案很有效地解决了Redis高可用的问题。\",\"哨兵模式与主从复制的区别：\",\"哨兵的核心配置\",\"sentinel monitor mymaster 127.0.0.1 6379 1 \",\"数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。\",\"测试\",\"redis-sentinel xxx/sentinel.conf \",\"成功启动哨兵模式\",\"此时哨兵监视着我们的主机6379，当我们断开主机后：\"]},\"759\":{\"h\":\"哨兵模式优缺点\"},\"760\":{\"h\":\"优点\",\"t\":[\"哨兵集群，基于主从复制模式，所有主从复制的优点，它都有\",\"主从可以切换，故障可以转移，系统的可用性更好\",\"哨兵模式是主从模式的升级，手动到自动，更加健壮\"]},\"761\":{\"h\":\"缺点\",\"t\":[\"Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦\",\"实现哨兵模式的配置其实是很麻烦的，里面有很多配置项\",\"完整的哨兵模式配置文件 sentinel.conf\",\"# Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379 port 26379 # 哨兵sentinel的工作目录 dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符\\\".-_\\\"组成。 # quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了 # sentinel monitor <master-name> <ip> <redis-port> <quorum> sentinel monitor mymaster 127.0.0.1 6379 1 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码 # 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 # sentinel auth-pass <master-name> <password> sentinel auth-pass mymaster MySUPER--secret-0123passw0rd # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒 # sentinel down-after-milliseconds <master-name> <milliseconds> sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步， 这个数字越小，完成failover所需的时间就越长， 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。 # sentinel parallel-syncs <master-name> <numslaves> sentinel parallel-syncs mymaster 1 # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。 #2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。 #3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout <master-name> <milliseconds> sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。 #对于脚本的运行结果有以下规则： #若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10 #若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。 #如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 #一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本， #这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数， #一个是事件的类型， #一个是事件的描述。 #如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。 #通知脚本 # sentinel notification-script <master-name> <script-path> sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本 # 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。 # 以下参数将会在调用脚本时传给脚本: # <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port> # 目前<state>总是“failover”, # <role>是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的 # 这个脚本应该是通用的，能被多次调用，不是针对性的。 # sentinel client-reconfig-script <master-name> <script-path> sentinel client-reconfig-script mymaster /var/redis/reconfig.sh \",\"Redis当中使用了Raft算法实现领导者选举。\"]},\"762\":{\"h\":\"缓存穿透\"},\"763\":{\"h\":\"概念\",\"t\":[\"在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。\"]},\"764\":{\"h\":\"解决方案\",\"t\":[\"布隆过滤器：对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。\",\"缓存空对象:一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。\",\"这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间\",\"即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。\"]},\"765\":{\"h\":\"缓存击穿\"},\"766\":{\"h\":\"概念\",\"t\":[\"相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。\",\"比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。\"]},\"767\":{\"h\":\"解决方案\",\"t\":[\"设置热点数据永不过期\",\"这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。\",\"加互斥锁(分布式锁)\",\"在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。\"]},\"768\":{\"h\":\"缓存雪崩\"},\"769\":{\"h\":\"概念\",\"t\":[\"大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。\"]},\"770\":{\"h\":\"解决方案\",\"t\":[\"redis高可用\",\"这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群\",\"限流降级\",\"这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。\",\"数据预热\",\"数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。\",\"[1] Redis开发与运维\",\"[2] Raft维基百科\"]},\"771\":{\"h\":\"thinking in os\"},\"772\":{\"h\":\"什么是操作系统\"},\"773\":{\"h\":\"操作系统分类\"},\"774\":{\"h\":\"操作系统的发展史\"},\"775\":{\"h\":\"计算机组成原理\"},\"776\":{\"h\":\"CPU\"},\"777\":{\"h\":\"地址总线\"},\"778\":{\"h\":\"DRAM\"},\"779\":{\"h\":\"计算机的启动过程\"},\"780\":{\"h\":\"BIOS\"},\"781\":{\"h\":\"地址、section、vstart\"},\"782\":{\"h\":\"地址\"},\"783\":{\"h\":\"section\"},\"784\":{\"h\":\"vstart\"},\"785\":{\"h\":\"CPU的实模式\"},\"786\":{\"h\":\"CPU的工作原理\"},\"787\":{\"h\":\"实模式\"},\"788\":{\"h\":\"硬盘操作\"},\"789\":{\"h\":\"获取物理内存容量\"},\"790\":{\"h\":\"内存分页机制\"},\"791\":{\"h\":\"混合编程\"},\"792\":{\"h\":\"基本内联混编\"},\"793\":{\"h\":\"内联编程\"},\"794\":{\"h\":\"扩展内联混编\"},\"795\":{\"h\":\"Dubbo\"},\"796\":{\"h\":\"Dubbo底层实现原理\",\"t\":[\"链接：https://note.youdao.com/ynoteshare/index.html?id=ca746f44f16b862e3189e5f24b3a8e64&type=note&_time=1685805324275\"]},\"797\":{\"h\":\"Dubbo3.0新特性\"},\"798\":{\"h\":\"dubbo协议\",\"t\":[\"dubbo协议由于请求中没有多余的无用的字节，都是必要的字节，因此性能会更好，并且每个Dubbo请求和响应中都有一个请求ID，这样可以基于一个Socket连接同时发送多个Dubbo请求，不用担心请求和响应对不上，所以dubbo协议成为了Dubbo框架中的默认协议。\",\"但是dubbo协议一旦涉及到跨RPC框架，比如一个Dubbo服务要调用gRPC服务，就比较麻烦了。因为发一个dubbo协议的请求给一个gRPC服务，gRPC服务只会按照gRPC的格式来解析字节流，最终肯定会解析不成功的。\",\"dubbo协议虽好，但是不够通用，所以这就出现了Triple协议，Triple协议是基于HTTP2，没有性能问题，另外HTTP协议非常通用，兼容起来也比较简单，而且还有很多额外的功能，比如流式调用。\"]},\"799\":{\"h\":\"Triple协议\"},\"800\":{\"h\":\"Dubbo服务注册与引入底层原理\",\"t\":[\"参考链接：https://note.youdao.com/ynoteshare/index.html?id=bbeb46c842c84cfcdbf1d1f040fe40c7&type=note&_time=1685977459844\",\"服务导出与服务引入的流程图：https://www.processon.com/view/link/62c441e80791293dccaebded\"]},\"801\":{\"h\":\"服务导出\"},\"802\":{\"h\":\"服务引入\"},\"803\":{\"h\":\"Dubbo服务调用底层原理\"},\"804\":{\"h\":\"Http2原理解析\",\"t\":[\"Http2可以支持同时发在一个socket上送多个请求。\",\"帧长度\",\"帧类型\"]},\"805\":{\"h\":\"Mybatis源码分析\"},\"806\":{\"h\":\"Mybatis源码体系\",\"t\":[\"JDBC的缺点：\",\"sql语句耦合在代码中，维护性差\",\"JDBC频繁的创建和关闭数据库连接，连接消耗大\",\"不好设置缓存\",\"参数设置非常不方便\",\"处理查询结果集，类型转换非常麻烦\",\"Mybatis的体系结构如下：\",\"Mybatis的功能架构可以分为三层：\",\"API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操作数据库，接口层一接收到请求就会调用数据处理层来玩完成具体的数据处理\",\"数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等，它的主要目的是根据调用的请求完成一次数据库操作\",\"基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件，为上层的数据层提供最基础的支撑\",\"解析过程：https://www.processon.com/view/link/5efc2381f346fb1ae58925c1\",\"解析到的所有对象的数据会存储到：org.apache.ibatis.session.Configuration。\",\"Mybatis提供的默认的别名注册器：\",\" public TypeAliasRegistry() { registerAlias(\\\"string\\\", String.class); registerAlias(\\\"byte\\\", Byte.class); registerAlias(\\\"long\\\", Long.class); registerAlias(\\\"short\\\", Short.class); registerAlias(\\\"int\\\", Integer.class); registerAlias(\\\"integer\\\", Integer.class); registerAlias(\\\"double\\\", Double.class); registerAlias(\\\"float\\\", Float.class); registerAlias(\\\"boolean\\\", Boolean.class); registerAlias(\\\"byte[]\\\", Byte[].class); registerAlias(\\\"long[]\\\", Long[].class); registerAlias(\\\"short[]\\\", Short[].class); registerAlias(\\\"int[]\\\", Integer[].class); registerAlias(\\\"integer[]\\\", Integer[].class); registerAlias(\\\"double[]\\\", Double[].class); registerAlias(\\\"float[]\\\", Float[].class); registerAlias(\\\"boolean[]\\\", Boolean[].class); registerAlias(\\\"_byte\\\", byte.class); registerAlias(\\\"_long\\\", long.class); registerAlias(\\\"_short\\\", short.class); registerAlias(\\\"_int\\\", int.class); registerAlias(\\\"_integer\\\", int.class); registerAlias(\\\"_double\\\", double.class); registerAlias(\\\"_float\\\", float.class); registerAlias(\\\"_boolean\\\", boolean.class); registerAlias(\\\"_byte[]\\\", byte[].class); registerAlias(\\\"_long[]\\\", long[].class); registerAlias(\\\"_short[]\\\", short[].class); registerAlias(\\\"_int[]\\\", int[].class); registerAlias(\\\"_integer[]\\\", int[].class); registerAlias(\\\"_double[]\\\", double[].class); registerAlias(\\\"_float[]\\\", float[].class); registerAlias(\\\"_boolean[]\\\", boolean[].class); registerAlias(\\\"date\\\", Date.class); registerAlias(\\\"decimal\\\", BigDecimal.class); registerAlias(\\\"bigdecimal\\\", BigDecimal.class); registerAlias(\\\"biginteger\\\", BigInteger.class); registerAlias(\\\"object\\\", Object.class); registerAlias(\\\"date[]\\\", Date[].class); registerAlias(\\\"decimal[]\\\", BigDecimal[].class); registerAlias(\\\"bigdecimal[]\\\", BigDecimal[].class); registerAlias(\\\"biginteger[]\\\", BigInteger[].class); registerAlias(\\\"object[]\\\", Object[].class); registerAlias(\\\"map\\\", Map.class); registerAlias(\\\"hashmap\\\", HashMap.class); registerAlias(\\\"list\\\", List.class); registerAlias(\\\"arraylist\\\", ArrayList.class); registerAlias(\\\"collection\\\", Collection.class); registerAlias(\\\"iterator\\\", Iterator.class); registerAlias(\\\"ResultSet\\\", ResultSet.class); } \",\"二级缓存的实现采用了装饰器设计模式：org.apache.ibatis.cache.impl.PerpetualCache。过期策略可以设置：LRU、FIFO、SOFT、WEAK等，默认是LRU。\",\"每一个CRUD操作最终都会解析为一个：org.apache.ibatis.mapping.MappedStatement。\",\"sql对应的对象：\",\"Dynamic sqlSource（需要拼接参数的）\",\"Raw sqlSource（不需要拼接参数的）\",\"动态标签会被解析为：\",\"解析SQL NODE：org.apache.ibatis.scripting.xmltags.XMLScriptBuilder\",\" protected MixedSqlNode parseDynamicTags(XNode node) { List<SqlNode> contents = new ArrayList<>(); NodeList children = node.getNode().getChildNodes(); for (int i = 0; i < children.getLength(); i++) { XNode child = node.newXNode(children.item(i)); if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) { String data = child.getStringBody(\\\"\\\"); TextSqlNode textSqlNode = new TextSqlNode(data); if (textSqlNode.isDynamic()) { contents.add(textSqlNode); isDynamic = true; } else { contents.add(new StaticTextSqlNode(data)); } } else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) { // issue #628 String nodeName = child.getNode().getNodeName(); NodeHandler handler = nodeHandlerMap.get(nodeName); if (handler == null) { throw new BuilderException(\\\"Unknown element <\\\" + nodeName + \\\"> in SQL statement.\\\"); } handler.handleNode(child, contents); isDynamic = true; } } return new MixedSqlNode(contents); } \"]},\"807\":{\"h\":\"数据操作过程源码剖析\",\"t\":[\"SqlSession是一种门面设计模式。\",\"Executor的实现类：\",\"SIMPLE（默认）\",\"REUSE：执行器会重用PrepareStatement\",\"BATCH：执行器不仅重用语句还会执行批量更新\",\"拦截器的作用：\",\"分页\",\"读写分离\",\"修改SQL，拿到SQL语句\",\"动态标签解析：ongl表达式。\"]},\"808\":{\"h\":\"深入理解Netty\"},\"809\":{\"h\":\"Netty特点\"},\"810\":{\"h\":\"作用\"},\"811\":{\"h\":\"良好的设计\"},\"812\":{\"h\":\"使用简单\"},\"813\":{\"h\":\"性能\"},\"814\":{\"h\":\"安全\"},\"815\":{\"h\":\"Netty架构实现\"},\"816\":{\"h\":\"Netty的Hello world\"},\"817\":{\"h\":\"Netty模块分析\"},\"818\":{\"h\":\"Netty整体执行流程分析\"},\"819\":{\"h\":\"Netty对Socket的实现\"},\"820\":{\"h\":\"Socket使用示例\"},\"821\":{\"h\":\"消息的广播\"},\"822\":{\"h\":\"心跳机制\"},\"823\":{\"h\":\"Netty与WebSocket\"},\"824\":{\"h\":\"实现与原理分析\"},\"825\":{\"h\":\"WebSocket生命周期分解\"},\"826\":{\"h\":\"Google Protobuf\"},\"827\":{\"h\":\"简介\"},\"828\":{\"h\":\"proto文件\"},\"829\":{\"h\":\"解析和序列化\"},\"830\":{\"h\":\"编写message\"},\"831\":{\"h\":\"读取message\"},\"832\":{\"h\":\"多协议消息\"},\"833\":{\"h\":\"最佳实践\"},\"834\":{\"h\":\"Apache Thrift\"},\"835\":{\"h\":\"简介\"},\"836\":{\"h\":\"thrift文件\"},\"837\":{\"h\":\"最佳实践\"},\"838\":{\"h\":\"传输格式\"},\"839\":{\"h\":\"传输方式\"},\"840\":{\"h\":\"服务模型\"},\"841\":{\"h\":\"多语言的支持\"},\"842\":{\"h\":\"GRPC\"},\"843\":{\"h\":\"简介\"},\"844\":{\"h\":\"相关示例\"},\"845\":{\"h\":\"流式调用\"},\"846\":{\"h\":\"IO与NIO\"},\"847\":{\"h\":\"IO与NIO的区别\"},\"848\":{\"h\":\"Buffer\"},\"849\":{\"h\":\"Channel\"},\"850\":{\"h\":\"Selector\"},\"851\":{\"h\":\"NIO网络编程\"},\"852\":{\"h\":\"字符编码集\"},\"853\":{\"h\":\"零拷贝\"},\"854\":{\"h\":\"传统的IO流程\"},\"855\":{\"h\":\"零拷贝实现原理\"},\"856\":{\"h\":\"EventLoopGroup\"},\"857\":{\"h\":\"Netty中的Future对象\"},\"858\":{\"h\":\"ChannelFuture\"},\"859\":{\"h\":\"异步读写架构\"},\"860\":{\"h\":\"Promise\"},\"861\":{\"h\":\"ServerBootStrap\"},\"862\":{\"h\":\"核心方法\"},\"863\":{\"h\":\"初始化和注册方法\"},\"864\":{\"h\":\"Reactor模式\"},\"865\":{\"h\":\"传统的模型\"},\"866\":{\"h\":\"Reactor模式\"},\"867\":{\"h\":\"Netty中的Reactor线程模型\"},\"868\":{\"h\":\"自适应缓冲区\"},\"869\":{\"h\":\"Channel实现原理\"},\"870\":{\"h\":\"Channel的四大组件\"},\"871\":{\"h\":\"Channel与ChannelPipeline\"},\"872\":{\"h\":\"ChannelOption与AttributeKey\"},\"873\":{\"h\":\"ChannelHandler与ChannelHandlerContext\"},\"874\":{\"h\":\"Channel选择器\"},\"875\":{\"h\":\"Channel注册流程\"},\"876\":{\"h\":\"Netty中的设计原则\"},\"877\":{\"h\":\"设计原则\"},\"878\":{\"h\":\"业务线程池\"},\"879\":{\"h\":\"ByteBuf实现原理\"},\"880\":{\"h\":\"ByteBuf使用示例\"},\"881\":{\"h\":\"ByteBuf数据结构\"},\"882\":{\"h\":\"复合缓冲区\"},\"883\":{\"h\":\"引用计数\"},\"884\":{\"h\":\"实现原理\"},\"885\":{\"h\":\"AtomicIntegerFieldUpdater\"},\"886\":{\"h\":\"Netty中的处理器\"},\"887\":{\"h\":\"自定义编解码器\"},\"888\":{\"h\":\"ReplayingDecoder\"},\"889\":{\"h\":\"LengthFieldBasedFrameDecoder\"},\"890\":{\"h\":\"常见编解码器总结\"},\"891\":{\"h\":\"TCP粘包与拆包\"},\"892\":{\"h\":\"粘包与拆包\"},\"893\":{\"h\":\"解决方案\"},\"894\":{\"h\":\"观察者模式\"},\"895\":{\"h\":\"适配器模式\"},\"896\":{\"h\":\"模板方法模式\"},\"897\":{\"h\":\"Spring AOP\"},\"898\":{\"h\":\"知识储备\"},\"899\":{\"h\":\"Java 基础部分\"},\"900\":{\"h\":\"OOP 部分\"},\"901\":{\"h\":\"GOF23 设计模式\"},\"902\":{\"h\":\"Spring 核心基础\"},\"903\":{\"h\":\"OOP局限性\"},\"904\":{\"h\":\"AOP常见使用场景\"},\"905\":{\"h\":\"日志场景\"},\"906\":{\"h\":\"统计场景\"},\"907\":{\"h\":\"安防场景\"},\"908\":{\"h\":\"性能场景\"},\"909\":{\"h\":\"Java AOP设计模式\"},\"910\":{\"h\":\"代理模式\"},\"911\":{\"h\":\"判断模式\"},\"912\":{\"h\":\"拦截模式\"},\"913\":{\"h\":\"Spring AOP 功能概述\"},\"914\":{\"h\":\"AOP设计核心\"},\"915\":{\"h\":\"Spring AOP编程模型\"},\"916\":{\"h\":\"Spring AOP Advice类型\"},\"917\":{\"h\":\"Spring AOP代理实现\"},\"918\":{\"h\":\"JDK动态代理\"},\"919\":{\"h\":\"CGLIB动态代理\"},\"920\":{\"h\":\"AspectJ代理\"},\"921\":{\"h\":\"面试题\"},\"922\":{\"h\":\"Spring AOP和AspectJ AOP存在哪些差别？\"},\"923\":{\"h\":\"@AspectJ注解驱动\"},\"924\":{\"h\":\"编程方式创建@AspectJ代理\"},\"925\":{\"h\":\"标准工厂API\"},\"926\":{\"h\":\"@AspectJ Pointcut指令与表达式\"},\"927\":{\"h\":\"XML配置Pointcut\"},\"928\":{\"h\":\"API实现Pointcut\"},\"929\":{\"h\":\"@AspectJ拦截动作\"},\"930\":{\"h\":\"XML配置Around Advice\"},\"931\":{\"h\":\"@AspectJ的前置动作\"},\"932\":{\"h\":\"XML配置Before Advice\"},\"933\":{\"h\":\"API实现Before Advice\"},\"934\":{\"h\":\"@Aspect后置动作\"},\"935\":{\"h\":\"XML配置After Advice\"},\"936\":{\"h\":\"API实现After Advice\"},\"937\":{\"h\":\"自动动态代理\"},\"938\":{\"h\":\"替换TargetSource\"},\"939\":{\"h\":\"面试题\"},\"940\":{\"h\":\"Spring AOP支持哪些类型的Advice？\"},\"941\":{\"h\":\"Spring AOP编程模型有哪些，代表组件有哪些？\"},\"942\":{\"h\":\"Spring AOP三种实现方式是如何进行设计的？\"},\"943\":{\"h\":\"API整体设计\"},\"944\":{\"h\":\"接入点接口Joinpoint\"},\"945\":{\"h\":\"Joinpoint条件接口\"},\"946\":{\"h\":\"Pointcut组合实现\"},\"947\":{\"h\":\"Pointcut便利实现\"},\"948\":{\"h\":\"Pointcut AspectJ实现\"},\"949\":{\"h\":\"Joinpoint执行动作接口\"},\"950\":{\"h\":\"Before Advice标准实现\"},\"951\":{\"h\":\"Before Advice AspectJ实现\"},\"952\":{\"h\":\"After Advice标准实现\"},\"953\":{\"h\":\"After Advice AspectJ实现\"},\"954\":{\"h\":\"Advisor接口\"},\"955\":{\"h\":\"PointcutAdvisor接口\"},\"956\":{\"h\":\"IntorductionAdvisor接口\"},\"957\":{\"h\":\"AdvisorAdapter接口\"},\"958\":{\"h\":\"AopProxy接口\"},\"959\":{\"h\":\"AopProxyFactory\"},\"960\":{\"h\":\"JDK AopProxy实现\"},\"961\":{\"h\":\"CGLIB AopProxy实现\"},\"962\":{\"h\":\"AdvisedSupport\"},\"963\":{\"h\":\"AdvisorChainFactory接口\"},\"964\":{\"h\":\"TargetSource接口\"},\"965\":{\"h\":\"ProxyCreatorSupport\"},\"966\":{\"h\":\"AdvisedSupportListener\"},\"967\":{\"h\":\"ProxyFactory\"},\"968\":{\"h\":\"ProxyFactoryBean\"},\"969\":{\"h\":\"AspectJProxyFactory\"},\"970\":{\"h\":\"AbstractAutoProxyCreator\"},\"971\":{\"h\":\"IoC容器自动代理标准实现\"},\"972\":{\"h\":\"AspectJAwareAdvisorAutoProxyCreator\"},\"973\":{\"h\":\"AopInfrastructureBean接口\"},\"974\":{\"h\":\"AopContext\"},\"975\":{\"h\":\"AopProxyUtils\"},\"976\":{\"h\":\"AopUtils\"},\"977\":{\"h\":\"AspectJ Enable模块驱动\"},\"978\":{\"h\":\"AspectJ XML配置驱动实现\"},\"979\":{\"h\":\"<aop:config /> Schema-based实现\"},\"980\":{\"h\":\"<aop:aspect /> Schema-based实现\"},\"981\":{\"h\":\"Pointcut Schema-based实现\"},\"982\":{\"h\":\"Around Advice Schema-based实现\"},\"983\":{\"h\":\"Before Advice Schema-based实现\"},\"984\":{\"h\":\"After Advice Schema-based实现\"},\"985\":{\"h\":\"After Returning Advice Schema-based实现\"},\"986\":{\"h\":\"After Throwing Advice Schema-based实现\"},\"987\":{\"h\":\"Advisor Schema-based实现\"},\"988\":{\"h\":\"Introduction Schema-based实现\"},\"989\":{\"h\":\"作用域代理Schema-based实现\"},\"990\":{\"h\":\"面试题\"},\"991\":{\"h\":\"Spring AOP Advice XML标签有哪些？\"},\"992\":{\"h\":\"请解释Spring @EnbaleAspectJAutoProxy的原理？\"},\"993\":{\"h\":\"Spring Configuration Class CGLIB提升与AOP类代理的关系？\"},\"994\":{\"h\":\"创建型模式\"},\"995\":{\"h\":\"抽象工厂模式\"},\"996\":{\"h\":\"构建器模式\"},\"997\":{\"h\":\"工厂方法模式\"},\"998\":{\"h\":\"原型模式\"},\"999\":{\"h\":\"单例模式\"},\"1000\":{\"h\":\"结构型模式\"},\"1001\":{\"h\":\"适配器模式\"},\"1002\":{\"h\":\"组合模式\"},\"1003\":{\"h\":\"装饰器模式\"},\"1004\":{\"h\":\"享元模式\"},\"1005\":{\"h\":\"代理模式\"},\"1006\":{\"h\":\"行为型模式\"},\"1007\":{\"h\":\"模板方法模式\"},\"1008\":{\"h\":\"责任链模式\"},\"1009\":{\"h\":\"观察者模式\"},\"1010\":{\"h\":\"策略模式\"},\"1011\":{\"h\":\"命令模式\"},\"1012\":{\"h\":\"状态模式\"},\"1013\":{\"h\":\"面试题\"},\"1014\":{\"h\":\"GOF 23设计模式和它的归类？\"},\"1015\":{\"h\":\"举例装饰器模式和代理模式的区别？\"},\"1016\":{\"h\":\"请举例说明Spring Framework中使用设计模式的实现？\"},\"1017\":{\"h\":\"Spring 事件中的应用\"},\"1018\":{\"h\":\"Spring事务中的应用\"},\"1019\":{\"h\":\"核心API\"},\"1020\":{\"h\":\"理解TransactionDefinition\"},\"1021\":{\"h\":\"理解PlatformTransactionManager\"},\"1022\":{\"h\":\"理解事务传播\"},\"1023\":{\"h\":\"Spring 缓存中的应用\"},\"1024\":{\"h\":\"Spring本地调度中的应用\"},\"1025\":{\"h\":\"面试题\"},\"1026\":{\"h\":\"Spring AOP在Spring Framework特性运用？\"},\"1027\":{\"h\":\"Spring事务传播的原理？\"},\"1028\":{\"h\":\"Spring AOP与IoC功能整合的设计模式？\"},\"1029\":{\"h\":\"SpringBoot\"},\"1030\":{\"h\":\"@SpringBootApplication\"},\"1031\":{\"h\":\"注解解析\"},\"1032\":{\"h\":\"@Configuration\"},\"1033\":{\"h\":\"@ComponentScan\"},\"1034\":{\"h\":\"@EnableAutoConfiguration\"},\"1035\":{\"h\":\"启动执行流程\"},\"1036\":{\"h\":\"流程概览\"},\"1037\":{\"h\":\"启动详情\"},\"1038\":{\"h\":\"自动装配\"},\"1039\":{\"h\":\"打包过程\"},\"1040\":{\"h\":\"构建工具\"},\"1041\":{\"h\":\"spring-boot-maven-plugin\"},\"1042\":{\"h\":\"Spotify Maven Plugin\"},\"1043\":{\"h\":\"Jib Maven Plugin\"},\"1044\":{\"h\":\"修改之前\"},\"1045\":{\"h\":\"使用Alpine镜像\"},\"1046\":{\"h\":\"分层构建镜像\"},\"1047\":{\"h\":\"Maven中内置变量\"},\"1048\":{\"h\":\"可能存在的问题\"},\"1049\":{\"h\":\"SpringCloud\"},\"1050\":{\"h\":\"SpringFramework\"},\"1051\":{\"h\":\"Spring特性总览\"},\"1052\":{\"h\":\"Spring 中值得学习的地方\"},\"1053\":{\"h\":\"Spring核心特性\"},\"1054\":{\"h\":\"Spring数据存储\"},\"1055\":{\"h\":\"Spring Web技术\"},\"1056\":{\"h\":\"Spring技术整合\"},\"1057\":{\"h\":\"Spring测试\"},\"1058\":{\"h\":\"Spring版本特性\"},\"1059\":{\"h\":\"Spring模块化设计\"},\"1060\":{\"h\":\"Spring编程模型\"},\"1061\":{\"h\":\"Spring的核心价值\"},\"1062\":{\"h\":\"面试题\"},\"1063\":{\"h\":\"什么是Spring Framework？\"},\"1064\":{\"h\":\"Spring Framwork有哪些核心模块？\"},\"1065\":{\"h\":\"Spring Framework的优势和不足是什么？\"},\"1066\":{\"h\":\"IoC的发展简介\"},\"1067\":{\"h\":\"IoC主要实现策略\"},\"1068\":{\"h\":\"IoC容器的职责\"},\"1069\":{\"h\":\"IoC的实现\"},\"1070\":{\"h\":\"传统IoC容器的实现\"},\"1071\":{\"h\":\"如何界定IoC容器是轻量级的？\"},\"1072\":{\"h\":\"依赖查找和依赖注入\"},\"1073\":{\"h\":\"构造器注入和Setter注入\"},\"1074\":{\"h\":\"面试题\"},\"1075\":{\"h\":\"什么是IoC？\"},\"1076\":{\"h\":\"依赖查找和依赖注入的区别？\"},\"1077\":{\"h\":\"Spring作为IoC容器有什么优势？\"},\"1078\":{\"h\":\"Spring IoC依赖查找\"},\"1079\":{\"h\":\"Spring IoC依赖注入\"},\"1080\":{\"h\":\"Spring依赖注入和依赖查找的来源\"},\"1081\":{\"h\":\"Spring IoC配置元信息\"},\"1082\":{\"h\":\"BeanFactory和ApplicationContext\"},\"1083\":{\"h\":\"Spring IoC容器生命周期\"},\"1084\":{\"h\":\"面试题\"},\"1085\":{\"h\":\"什么是Spring IoC容器\"},\"1086\":{\"h\":\"BeanFactory和FactoryBean\"},\"1087\":{\"h\":\"Spring IoC容器启动时做了哪些准备？\"},\"1088\":{\"h\":\"BeanDefinition\"},\"1089\":{\"h\":\"Spring Bean命名\"},\"1090\":{\"h\":\"BeanDefinition注册到IoC容器\"},\"1091\":{\"h\":\"实例化Bean的方式\"},\"1092\":{\"h\":\"初始化Bean的方式\"},\"1093\":{\"h\":\"延迟初始化Bean\"},\"1094\":{\"h\":\"销毁Bean\"},\"1095\":{\"h\":\"垃圾回收Spring Bean\"},\"1096\":{\"h\":\"面试题\"},\"1097\":{\"h\":\"如何注册一个Spring Bean？\"},\"1098\":{\"h\":\"什么是Spring BeanDefinition？\"},\"1099\":{\"h\":\"Spring容器是怎样管理注册Bean\"},\"1100\":{\"h\":\"依赖查找简介\"},\"1101\":{\"h\":\"单一类型依赖查找\"},\"1102\":{\"h\":\"集合类型依赖查找\"},\"1103\":{\"h\":\"层次性依赖查找\"},\"1104\":{\"h\":\"延迟依赖查找\"},\"1105\":{\"h\":\"安全依赖查找\"},\"1106\":{\"h\":\"内建可查找的依赖\"},\"1107\":{\"h\":\"依赖查找中典型异常\"},\"1108\":{\"h\":\"面试题\"},\"1109\":{\"h\":\"ObjectFactory与BeanFactory的区别\"},\"1110\":{\"h\":\"BeanFactory.getBean操作是否线程安全？\"},\"1111\":{\"h\":\"Spring的依赖查找和依赖注入在来源上有什么区别？\"},\"1112\":{\"h\":\"依赖注入的模式和类型\"},\"1113\":{\"h\":\"自动绑定\"},\"1114\":{\"h\":\"Setter注入\"},\"1115\":{\"h\":\"构造器注入\"},\"1116\":{\"h\":\"字段注入\"},\"1117\":{\"h\":\"方法注入\"},\"1118\":{\"h\":\"接口回调注入\"},\"1119\":{\"h\":\"依赖注入类型选择\"},\"1120\":{\"h\":\"基础类型注入\"},\"1121\":{\"h\":\"集合类型注入\"},\"1122\":{\"h\":\"限定注入\"},\"1123\":{\"h\":\"延迟依赖注入\"},\"1124\":{\"h\":\"依赖处理的过程\"},\"1125\":{\"h\":\"@Autowird注入\"},\"1126\":{\"h\":\"@Inject和@Autowired联系\"},\"1127\":{\"h\":\"Java通用注解原理\"},\"1128\":{\"h\":\"自定义依赖注入注解\"},\"1129\":{\"h\":\"面试题\"},\"1130\":{\"h\":\"有多少种依赖注入的方式\"},\"1131\":{\"h\":\"你偏好构造器注入还是Setter注入?\"},\"1132\":{\"h\":\"Spring依赖注入的来源有哪些？\"},\"1133\":{\"h\":\"依赖查找的来源\"},\"1134\":{\"h\":\"依赖注入的来源\"},\"1135\":{\"h\":\"Spring容器管理和游离对象\"},\"1136\":{\"h\":\"Spring BeanDefinition作为依赖来源\"},\"1137\":{\"h\":\"单体对象作为依赖来源\"},\"1138\":{\"h\":\"Resolvable Dependency作为依赖来源\"},\"1139\":{\"h\":\"外部化配置作为依赖来源\"},\"1140\":{\"h\":\"面试题\"},\"1141\":{\"h\":\"依赖注入和依赖查找的依赖来源是否相同？\"},\"1142\":{\"h\":\"单例对象能在IoC容器启动后注册吗？\"},\"1143\":{\"h\":\"Spring依赖注入的来源有哪些？\"},\"1144\":{\"h\":\"作用域简介\"},\"1145\":{\"h\":\"singleton作用域\"},\"1146\":{\"h\":\"prototype作用域\"},\"1147\":{\"h\":\"request作用域\"},\"1148\":{\"h\":\"session作用域\"},\"1149\":{\"h\":\"application作用域\"},\"1150\":{\"h\":\"自定义Bean作用域\"},\"1151\":{\"h\":\"面试题\"},\"1152\":{\"h\":\"Spring内建的Bean的作用域有几种？\"},\"1153\":{\"h\":\"singleton Bean是否在一个应用中是唯一的？\"},\"1154\":{\"h\":\"\\\"application\\\" Bean是否被其他方案他替代？\"},\"1155\":{\"h\":\"元信息配置阶段\"},\"1156\":{\"h\":\"元信息解析阶段\"},\"1157\":{\"h\":\"注册阶段\"},\"1158\":{\"h\":\"BeanDefinition合并阶段\"},\"1159\":{\"h\":\"Bean Class加载阶段\"},\"1160\":{\"h\":\"实例化\"},\"1161\":{\"h\":\"实例化前阶段\"},\"1162\":{\"h\":\"实例化阶段\"},\"1163\":{\"h\":\"Bean实例化后阶段\"},\"1164\":{\"h\":\"属性赋值前阶段\"},\"1165\":{\"h\":\"初始化\"},\"1166\":{\"h\":\"接口回调阶段\"},\"1167\":{\"h\":\"初始化前阶段\"},\"1168\":{\"h\":\"初始化阶段\"},\"1169\":{\"h\":\"初始化后阶段\"},\"1170\":{\"h\":\"初始化完成阶段\"},\"1171\":{\"h\":\"销毁阶段\"},\"1172\":{\"h\":\"销毁前阶段\"},\"1173\":{\"h\":\"销毁阶段\"},\"1174\":{\"h\":\"Bean垃圾收集\"},\"1175\":{\"h\":\"面试题\"},\"1176\":{\"h\":\"BeanPostProcess使用场景有哪些？\"},\"1177\":{\"h\":\"BeanFactoryPostProcess与BeanPostProcess的区别\"},\"1178\":{\"h\":\"BeanFactory是怎样处理Bean生命周期？\"},\"1179\":{\"h\":\"Spring Bean配置元信息\"},\"1180\":{\"h\":\"Spring Bean属性元信息\"},\"1181\":{\"h\":\"Spring容器配置元信息\"},\"1182\":{\"h\":\"基于XML资源装载Spring Bean配置元信息\"},\"1183\":{\"h\":\"基于Properties资源装载Spring Bean配置元信息\"},\"1184\":{\"h\":\"基于Java注解的Spring Bean配置元信息\"},\"1185\":{\"h\":\"Spring Bean配置元信息底层实现\"},\"1186\":{\"h\":\"XML资源的方式\"},\"1187\":{\"h\":\"Properties资源的方式\"},\"1188\":{\"h\":\"Java注解的方式\"},\"1189\":{\"h\":\"基于XML资源装载Spring 容器配置元信息\"},\"1190\":{\"h\":\"基于Java注解配置Spring 容器配置元信息\"},\"1191\":{\"h\":\"基于Extensible XML authoring扩展Spring XML元素\"},\"1192\":{\"h\":\"基于Properties资源装载外部化配置\"},\"1193\":{\"h\":\"基于yml资源装载外部化配置\"},\"1194\":{\"h\":\"面试题\"},\"1195\":{\"h\":\"Spring内建的XML Schema常见有哪些？\"},\"1196\":{\"h\":\"Spring配置元信息有哪些？\"},\"1197\":{\"h\":\"Extensible XML authoring的缺点？\"},\"1198\":{\"h\":\"Java标准资源管理\"},\"1199\":{\"h\":\"Resource接口\"},\"1200\":{\"h\":\"内建的Resource实现\"},\"1201\":{\"h\":\"Resource接口扩展\"},\"1202\":{\"h\":\"Spring资源加载器\"},\"1203\":{\"h\":\"Spring通配路径资源加载器\"},\"1204\":{\"h\":\"Spring通配路径资源扩展\"},\"1205\":{\"h\":\"依赖注入Spring Resource\"},\"1206\":{\"h\":\"依赖注入ResourceLoader\"},\"1207\":{\"h\":\"面试题\"},\"1208\":{\"h\":\"Spring配置资源中有哪些常见类型？\"},\"1209\":{\"h\":\"请举例不同类型的Spring配置资源\"},\"1210\":{\"h\":\"Java标准资源管理扩展的步骤\"},\"1211\":{\"h\":\"Spring国际化接口\"},\"1212\":{\"h\":\"层次性的MessageSource\"},\"1213\":{\"h\":\"Java国际化标准实现\"},\"1214\":{\"h\":\"Java文本格式化\"},\"1215\":{\"h\":\"MessageSource开箱实现\"},\"1216\":{\"h\":\"Message的内建依赖\"},\"1217\":{\"h\":\"SpringBoot为什么要新建MessageSource Bean?\"},\"1218\":{\"h\":\"面试题\"},\"1219\":{\"h\":\"Spring国际化接口有哪些？\"},\"1220\":{\"h\":\"Spring有哪些MessageSource的内建实现？\"},\"1221\":{\"h\":\"如何实现配置自动更新MessageSource？\"},\"1222\":{\"h\":\"Validator接口设计\"},\"1223\":{\"h\":\"Errors接口设计\"},\"1224\":{\"h\":\"Errors的文案来源\"},\"1225\":{\"h\":\"自定义Validator\"},\"1226\":{\"h\":\"Bean Validation\"},\"1227\":{\"h\":\"面试题\"},\"1228\":{\"h\":\"Spring校验接口是哪个？\"},\"1229\":{\"h\":\"Spring有哪些校验核心组件？\"},\"1230\":{\"h\":\"请通过示例演示Spring Bean的校验？\"},\"1231\":{\"h\":\"Spring 数据绑定组件\"},\"1232\":{\"h\":\"DataBinder元数据\"},\"1233\":{\"h\":\"DataBinder绑定控制参数\"},\"1234\":{\"h\":\"Spring底层Java Beans替换实现\"},\"1235\":{\"h\":\"BeanWrapper使用场景\"},\"1236\":{\"h\":\"JavaBeans操作属性\"},\"1237\":{\"h\":\"DataBinder数据校验\"},\"1238\":{\"h\":\"面试题\"},\"1239\":{\"h\":\"Spring数据绑定API是什么？\"},\"1240\":{\"h\":\"BeanWrapper与JavaBeans之间的关系是？\"},\"1241\":{\"h\":\"DataBinder是怎么完成属性类型转换的？\"},\"1242\":{\"h\":\"使用场景\"},\"1243\":{\"h\":\"基于JavaBeans接口的类型转换\"},\"1244\":{\"h\":\"Spring内建PropertyEditor扩展\"},\"1245\":{\"h\":\"自定义PropertyEditor扩展\"},\"1246\":{\"h\":\"PropertyEditor的局限性\"},\"1247\":{\"h\":\"Spring3 通用类型转换接口\"},\"1248\":{\"h\":\"Spring内建类型转换器\"},\"1249\":{\"h\":\"Converter接口的局限性\"},\"1250\":{\"h\":\"GenericConverter接口\"},\"1251\":{\"h\":\"优化GenericConverter接口\"},\"1252\":{\"h\":\"扩展Spring类型转换器\"},\"1253\":{\"h\":\"统一类型转换服务\"},\"1254\":{\"h\":\"ConversionService作为依赖\"},\"1255\":{\"h\":\"面试题\"},\"1256\":{\"h\":\"Spring类型转换实现有哪些？\"},\"1257\":{\"h\":\"Spring类型转换器接口有哪些？\"},\"1258\":{\"h\":\"TypeDescriptor是如何处理泛型？\"},\"1259\":{\"h\":\"Java泛型基础\"},\"1260\":{\"h\":\"Java 5类型接口\"},\"1261\":{\"h\":\"Spring泛型类型辅助类\"},\"1262\":{\"h\":\"泛型集合类型辅助类\"},\"1263\":{\"h\":\"Spring方法参数封装\"},\"1264\":{\"h\":\"ResolvableType\"},\"1265\":{\"h\":\"面试题\"},\"1266\":{\"h\":\"Java泛型擦写是发生在编译时，还是运行时？\"},\"1267\":{\"h\":\"请介绍Java 5 Type类型的派生类或接口?\"},\"1268\":{\"h\":\"请说明ResolvableType的设计优势\"},\"1269\":{\"h\":\"Java事件/监听器编程模型\"},\"1270\":{\"h\":\"面向接口的事件/监听器设计模式\"},\"1271\":{\"h\":\"面向注解的事件/监听器设计模式\"},\"1272\":{\"h\":\"Spring标准事件 ApplicationEvent\"},\"1273\":{\"h\":\"基于接口的Spring事件监听器\"},\"1274\":{\"h\":\"基于注解的Spring事件监听器\"},\"1275\":{\"h\":\"注册Spring ApplicationListener\"},\"1276\":{\"h\":\"Spring事件发布器\"},\"1277\":{\"h\":\"Spring层次性上下文事件传播\"},\"1278\":{\"h\":\"Spring内建事件\"},\"1279\":{\"h\":\"Payload事件\"},\"1280\":{\"h\":\"自定义Spring事件\"},\"1281\":{\"h\":\"依赖注入ApplicationEventPublisher\"},\"1282\":{\"h\":\"依赖查找ApplicationEventMulticaster\"},\"1283\":{\"h\":\"ApplicationEventPublisher底层实现\"},\"1284\":{\"h\":\"同步和异步Spring事件广播\"},\"1285\":{\"h\":\"Spring事件异常处理\"},\"1286\":{\"h\":\"Spring事件/监听实现原理\"},\"1287\":{\"h\":\"SpringBoot事件\"},\"1288\":{\"h\":\"面试题\"},\"1289\":{\"h\":\"Spring事件核心接口/组件？\"},\"1290\":{\"h\":\"Spring同步和异步事件处理的使用场景？\"},\"1291\":{\"h\":\"@EventListener的工作原理\"},\"1292\":{\"h\":\"Spring核心注解场景分类\"},\"1293\":{\"h\":\"Spring注解编程模型\"},\"1294\":{\"h\":\"Spring元注解\"},\"1295\":{\"h\":\"Spring模式注解\"},\"1296\":{\"h\":\"Spring 组合注解\"},\"1297\":{\"h\":\"Spring注解属性别名\"},\"1298\":{\"h\":\"Spring注解属性覆盖\"},\"1299\":{\"h\":\"Spring @Enable模块驱动\"},\"1300\":{\"h\":\"Spring条件注解\"},\"1301\":{\"h\":\"SpringBoot和SpringCloud注解\"},\"1302\":{\"h\":\"面试题\"},\"1303\":{\"h\":\"Spring模式注解有哪些？\"},\"1304\":{\"h\":\"@EventListener的工作原理？\"},\"1305\":{\"h\":\"@PropertySource工作原理\"},\"1306\":{\"h\":\"Environment接口使用场景\"},\"1307\":{\"h\":\"Environment占位符处理\"},\"1308\":{\"h\":\"理解条件配置Spring Profiles\"},\"1309\":{\"h\":\"依赖注入Environment\"},\"1310\":{\"h\":\"依赖查找Environment\"},\"1311\":{\"h\":\"依赖注入@Value\"},\"1312\":{\"h\":\"Spring类型转换在Environment中的运用\"},\"1313\":{\"h\":\"Spring类型转换在@Value中的运用\"},\"1314\":{\"h\":\"Spring配置属性源PropertySource\"},\"1315\":{\"h\":\"Spring内建的配置属性源\"},\"1316\":{\"h\":\"基于注解扩展Spring配置属性源\"},\"1317\":{\"h\":\"基于API扩展Spring配置属性源\"},\"1318\":{\"h\":\"Spring 测试配置属性源\"},\"1319\":{\"h\":\"面试题\"},\"1320\":{\"h\":\"简单介绍Spring Environment接口？\"},\"1321\":{\"h\":\"如何控制PropertySource的优先级？\"},\"1322\":{\"h\":\"Environment完整的生命周期是怎样的？\"},\"1323\":{\"h\":\"Spring应用上下文启动准备阶段\"},\"1324\":{\"h\":\"BeanFactory创建阶段\"},\"1325\":{\"h\":\"BeanFactory准备阶段\"},\"1326\":{\"h\":\"BeanFactory后置处理阶段\"},\"1327\":{\"h\":\"BeanFactory注册BeanPostProcess\"},\"1328\":{\"h\":\"初始化内建MessageSource\"},\"1329\":{\"h\":\"初始化内建Spring事件广播器\"},\"1330\":{\"h\":\"Spring应用上下文刷新\"},\"1331\":{\"h\":\"Spring事件监听器注册\"},\"1332\":{\"h\":\"BeanFactory初始化完成阶段\"},\"1333\":{\"h\":\"Spring应用上下文刷新完成阶段\"},\"1334\":{\"h\":\"Spring 应用上下文启动阶段\"},\"1335\":{\"h\":\"Spring 应用上下文停止阶段\"},\"1336\":{\"h\":\"Spring应用上下文关闭阶段\"},\"1337\":{\"h\":\"面试题\"},\"1338\":{\"h\":\"Spring应用上下文生命周期有哪些阶段？\"},\"1339\":{\"h\":\"Environment完整的生命周期？\"},\"1340\":{\"h\":\"Spring核心特性\"},\"1341\":{\"h\":\"Spring核心价值\"},\"1342\":{\"h\":\"为什么说ObjectFactory提供的是延迟依赖查找？\"},\"1343\":{\"h\":\"依赖查找（注入）的Bean会被缓存嘛？\"},\"1344\":{\"h\":\"@Bean的处理流程是怎样的？\"},\"1345\":{\"h\":\"BeanFactory是如何处理循环依赖的？\"},\"1346\":{\"h\":\"Java并发编程\"},\"1347\":{\"h\":\"JMM实现原理\",\"t\":[\"JMM即Java多线程通信模型-共享内存模型，包含三个方面：\",\"Java层面\",\"Jvm层面\",\"硬件层面\",\"并发与并行：\",\"并行：指同一时刻，有多条指令在多个处理器上同时执行。无论从微观还是宏观来看，二者都是一起执行的\",\"并发：指同一时刻，只能有一条执行执行，但多个进程指令会被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使得多个进程快速交替的执行\",\"并发三大特性：可见性、有序性、原子性；并发要解决的三大问题：同步问题、互斥问题、分工问题。\"]},\"1348\":{\"h\":\"可见性\",\"t\":[\"当一个线程修改了共享变量的值，其他线程能够看到修改的值。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递没接的方法来实现可见性的。\",\"保证可见性的方法：\",\"通过volatile关键字保证可见性\",\"通过内存屏障保障可见性\",\"通过sychronized关键字保证可见性\",\"通过Lock保证可见性\",\"通过final关键字保证可见性\"]},\"1349\":{\"h\":\"原子性\"},\"1350\":{\"h\":\"有序性\",\"t\":[\"Java虚拟机规范中定义了Java内存模型，用于屏蔽掉各种硬件和操作系统内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的，即一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。JMM描述的是一种抽象的概念，一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性、有序性、可见性展开的。\",\"Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示，Java内存模型和计算机硬件内存架构是一个交叉关系：\",\"关于主内存和工作内存之间的具体交互协议，即一个变量如何才主内存拷贝到工作内存、如何从工作内存到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成；\",\"lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态\",\"unlock（解锁）作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\",\"read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用\",\"load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中\",\"use（使用）：作用于工作内存的变量，把工作内存中一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作\",\"assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作\",\"store（存储）；作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作\",\"write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中\",\"volatile关键字的C++实现源码：\",\"可以发现当变量被volitle关键字修饰后，在变量被修改后，会添加一个内存屏障。\",\"内存屏障在Linux系统x86中的实现：\",\"汇编层面volatile的实现：\",\"lock;addl $0,0(%%rsp) \",\"模板解释器(templateInterpreter)，其对每个指令都写了一段对应的汇编代码，启动时将每个指令与对应汇编代码入口绑定，可以说是效率做到了极致。\",\"lock前缀指令的作用：\",\"确保后续指令执行的原子性。在Pentium及之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其它处理器暂时无法通过总线访问内存，很显然，这个开销很大。在新的处理器中，Intel使用缓存锁定来保证指令执行的原子性，缓存锁定将大大降低lock前缀指令的执行开销\",\"lock前缀指令具有类似内存屏障的功能，禁止该指令与前面和后面的读写指令重排序\",\"lock前缀指令会等待它之前所有的指令完成、并且所有缓冲的写操作写回内存（也就是将store buffer中的内容写入内存）之后才开始执行，并且根据缓存一执行协议，刷新store buffer的操作会导致其他cache中的副本失效。\",\"Java中，保证可见性的方式有两种，一种是内存屏障（JVM利用storeLoad，硬件层面利用lock或mfence），另一种是利用上下文切换。\"]},\"1351\":{\"h\":\"缓存一致性\",\"t\":[\"CPU缓存即高速缓冲存储器，是位于CPU与主存之间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据需要等待一定时间周期，Cache中保存着CPU刚刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可以从Cache中直接调用，减少CPU等待时间，提高了系统的效率。\",\"三级缓存的示意图：\",\"计算机体系结构中，缓存一致性是共享资源数据的一致性，这些数据最终存储在多个本地缓存中。当系统中的客户机维护公共内存资源的缓存时，可能会出现数据不一致的问题，这在多处理系统中的CPU尤其如此。\",\"在共享内存多处理器系统中，每个处理器都有一个单独的缓存内存，共享数据可能有多个副本：一个副本在主内存中，一个副本在请求它的每个处理器的本地缓存中。当数据的一个副本发生更改时，其他副本必须反映该更改。缓存一致性是确保共享操作数（数据）值的变化能够及时地在整个系统中传播的规程。\",\"缓存一致性的要求：\",\"写传播\",\"对任何缓存中的数据的更改都必须传播到对等缓冲中的其他副本（该缓存中的副本）\",\"事务串行化\",\"对单个内存位置的读/写必须被所有处理器以相同的顺序看到。理论上，一致性可以在加载/存储粒度上执行。然而，在实践中，它通常在缓存块的粒度上执行\",\"一致性机制\",\"确保一致性的两种最常见的机制是窥探机制和基于目录的机制，这两种机制各有优缺点。如果有足够的带宽可用，基于协议的窥探往往会更快，因为所有事务都是处理器看到的请求/响应。其缺点是窥探是不可扩展的。每个请求都必须广播到系统中的所有节点，这意味着随着系统变大，（逻辑或物理）总线的大小及其提供的带宽也必须增加。另一方面，目录往往有更长的延迟（3跳 请求/转发/响应），但使用更少的带宽，因为消息是点对点的，而不是广播的。由于这个原因，许多较大的系统（大于64位处理器）使用这种类型的缓存一致性\",\"JMM的内存可见性保证：\",\"单线程程序\",\"正确同步的多线程程序\",\"未同步/未正确同步的多线程程序\",\"volatile的内存语义总结：\",\"可见性：\",\"原子性：\",\"有序性：\"]},\"1352\":{\"h\":\"List、Set、HashMap底层原理\",\"t\":[\"数组查找公式：a[n]=起始地址+（n∗字节数）。\",\"数组的底层实现：\",\"transient Object[] elementData; \",\"ArrayList的扩容机制：\",\"private Object[] grow(int minCapacity) { return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); } \",\"主要思想：空间换时间。\",\"集合类实现序列化接口的目的：\",\"网络传输\",\"硬盘持久化\",\" LinkedList是双向链表。\",\"添加元素效率的对比：如果ArrayList指定了初始容量，那么效率会比LinkedList高，如果ArrayList没有指定初始容量，添加效率会比LinkedList低。\",\"HashMap的特点：key、value存储，key可以为null，同样的key会被覆盖掉。\",\"HashMap的底层存储结构：底层采用数据、链表、红黑树来实现。\",\"用链表是来解决数组小表覆盖的问题（哈希冲突的问题），红黑树是为了解决当哈希冲突比较多的时候，查询效率降低的问题。\",\"HashMap插入元素的方式，JDK7之前：头插法，JDK8以后：尾插法。\",\"头插法和尾插法的对比：HashMap 链表插入方式。\",\"链表转红黑树的阈值：\",\"static final int TREEIFY_THRESHOLD = 8; \",\"当红黑树的元素小于6的时候，又会退化成链表结构：\",\"static final int TREEIFY_THRESHOLD = 8; \",\"扩容因子：\",\"static final float DEFAULT_LOAD_FACTOR = 0.75f; \",\"JDK8 HashMap put的流程图：\",\"并发安全的HashMap主要有两个，HashTable和ConcurrentHashMap，HashTable是基于方法级别的synchronized的来实现的。ConcurrentHashMap是基于Node + CAS + Synchronized来实现的。\",\"ConcurrentHashMap在JDK1.7分段锁来实现。ConcurrentHashMap只是在链表的头结点加锁，锁的粒度更小了。\"]},\"1353\":{\"h\":\"线程池底层原理\",\"t\":[\"线程池执行过程示意图：\",\"线程池底层原理：\",\" public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { } \",\"线程池参数解析：\",\"corePoolSize：核心线程数\",\"maximumPoolSize：最大线程数\",\"keepAliveTime：最大线程数的存活时间\",\"unit：时间单位\",\"workQueue：阻塞队列\",\"threadFactory：线程工厂\",\"handler：拒绝策略\",\"提交任务的源码：\",\"public void execute(Runnable command) { if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) < corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } // offer方法和add方法的区别在于，add方法会抛出非法一场，offer方法则会返回false if (isRunning(c) && workQueue.offer(command)) { int recheck = ctl.get(); // 双重检测 if (! isRunning(recheck) && remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); } else if (!addWorker(command, false)) // 拒绝方法 reject(command); } \",\"ThreadPoolExecutor的拒绝策略：\",\"AbortPolicy\",\"CallerRunsPolicy\",\"DiscardOldestPolicy\",\"DiscardPolicy\"]},\"1354\":{\"h\":\"深入理解Java线程\",\"t\":[\"一个线程就是一个CPU可以执行的指令序列。\",\"从操作系统的视角来看，分配资源的最小单位是进程，线程是CPU调度的最小单位。\",\"进程间通信方式：\",\"管道及有名管道\",\"信号\",\"消息队列\",\"共享内存\",\"信号量\",\"套接字\",\"线程同步：是指线程之间所具有的一种制约关系，一个线程的执行依赖于另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。\",\"线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排他性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其他要使用该资源的线程必须等待，直到占用资源者释放该资源，线程互斥可以看成是一种特殊的线程同步。\",\"四种线程同步互斥的控制方法：\",\"临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问（在一段时间内只允许一个线程访问的资源就称为临界资源）\",\"互斥量：为协调共同对一个共享资源的单独访问而设计的\",\"信号量：为控制一个具有有限数量用户资源而设计\",\"事件：用来通知线程有一些事件已发生，从而启动后继任务的开始\",\"操作系统层面的线程生命周期可以用“五态模型”来描述，这个五种状态分别是：初始状态、可运行状态、运行状态、休眠状态和终止状态。\",\"Java层面线程共有六种状态：\",\"Java中创建线程的方式：\",\"Thread\",\"Runnable\",\"Callable\",\"本质上都是调用Thread#start方法，线程真正创建线程的过程如下：\",\"Java的线程是内核级别的线程，而不是用户态的线程，这就是为什么说Java的线程比较重的原因。\",\"协程是轻量级的线程，是用户态的，不会切换到内核态。\",\"优雅的停止线程：\",\"stop方法，过于暴力，会释放对象锁，可能会造成数据不一致的问题。\",\"interrupt，将线程的中断标志和设置为true，不会停止线程\",\"java.lang.Thread#isInterrupted()，判断当前线程的中断标志位是否位true，并清除中断标志位，重置为fasle\",\"可以手动判断线程的中断标识位，停止线程。\",\"Thread#sleep方法会清除中断标识。\",\"Java线程间通信主要有两种：\",\"volatile\",\"等待唤醒机制 \",\"wait和notify\",\"AQS中的await和signal\",\"管道输入输出流\",\"Thread#join（基于等待唤醒机制）\",\"notify主要两个缺陷：一个是必须配合sychronized使用，另一个是无法指令唤醒的线程具体是哪一个，但LockSupport可以解决这两个问题：\",\"LockSupport.unpark(threadName); \"]},\"1355\":{\"h\":\"CAS与Atomic实现原理\"},\"1356\":{\"h\":\"CAS源码解析\",\"t\":[\"CAS通常指的是这样一种原子操作，针对一个变量，首先比较它的内存值与某个期望值是否相同，如果相同，就给他赋一个新值。\",\"CAS的伪代码如下：\",\"if (value == expectedValue) { value = newValue; } \",\"CAS的过程如下：\",\"Java中的CAS操作：\",\"Hotspot 虚拟机对compareAndSwapInt 方法的实现如下：\",\"#unsafe.cpp UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) UnsafeWrapper(\\\"Unsafe_CompareAndSwapInt\\\"); oop p = JNIHandles::resolve(obj); // 根据偏移量，计算value的地址 jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); // Atomic::cmpxchg(x, addr, e) cas逻辑 x:要交换的值 e:要比较的值 //cas成功，返回期望值e，等于e,此方法返回true //cas失败，返回内存中的value值，不等于e，此方法返回false return (jint)(Atomic::cmpxchg(x, addr, e)) == e; \",\"核心逻辑在Atomic::cmpxchg方法中，这个根据不同操作系统和不同CPU会有不同的实现。这里我们以linux_64x的为例，查看Atomic::cmpxchg的实现：\",\"#atomic_linux_x86.inline.hpp inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) { //判断当前执行环境是否为多处理器环境 int mp = os::is_MP(); //LOCK_IF_MP(%4) 在多处理器环境下，为 cmpxchgl 指令添加 lock 前缀，以达到内存屏障的效果 //cmpxchgl 指令是包含在 x86 架构及 IA-64 架构中的一个原子条件指令， //它会首先比较 dest 指针指向的内存值是否和 compare_value 的值相等， //如果相等，则双向交换 dest 与 exchange_value，否则就单方面地将 dest 指向的内存值交给exchange_value。 //这条指令完成了整个 CAS 操作，因此它也被称为 CAS 指令。 __asm__ volatile (LOCK_IF_MP(%4) \\\"cmpxchgl %1,(%3)\\\" : \\\"=a\\\" (exchange_value) : \\\"r\\\" (exchange_value), \\\"a\\\" (compare_value), \\\"r\\\" (dest), \\\"r\\\" (mp) : \\\"cc\\\", \\\"memory\\\"); return exchange_value; \",\"cmpxchgl的详细执行过程：\",\"首先，输入是\\\"r\\\" (exchange_value), “a” (compare_value), “r” (dest), “r” (mp)，表示compare_value存入eax寄存器，而exchange_value、dest、mp的值存入任意的通用寄存器。嵌入式汇编规定把输出和输入寄存器按统一顺序编号，顺序是从输出寄存器序列从左到右从上到下以“%0”开始，分别记为%0、%1···%9。也就是说，输出的eax是%0，输入的exchange_value、compare_value、dest、mp分别是%1、%2、%3、%4。\",\"因此，cmpxchg %1,(%3)实际上表示cmpxchg exchange_value,(dest)\",\"需要注意的是cmpxchg有个隐含操作数eax，其实际过程是先比较eax的值(也就是compare_value)和dest地址所存的值是否相等，\",\"输出是\\\"=a\\\" (exchange_value)，表示把eax中存的值写入exchange_value变量中。\",\"Atomic::cmpxchg这个函数最终返回值是exchange_value，也就是说，如果cmpxchgl执行时compare_value和dest指针指向内存值相等则会使得dest指针指向内存值变成exchange_value，最终eax存的compare_value赋值给了exchange_value变量，即函数最终返回的值是原先的compare_value。此时Unsafe_CompareAndSwapInt的返回值(jint)(Atomic::cmpxchg(x, addr, e)) == e就是true，表明CAS成功。如果cmpxchgl执行时compare_value和(dest)不等则会把当前dest指针指向内存的值写入eax，最终输出时赋值给exchange_value变量作为返回值，导致(jint)(Atomic::cmpxchg(x, addr, e)) == e得到false，表明CAS失败。\",\"现代处理器指令集架构基本上都会提供 CAS 指令，例如 x86 和 IA-64 架构中的 cmpxchgl 指令和 comxchgq 指令，sparc 架构中的 cas 指令和 casx 指令。\",\"不管是 Hotspot 中的 Atomic::cmpxchg 方法，还是 Java 中的 compareAndSwapInt 方法，它们本质上都是对相应平台的 CAS 指令的一层简单封装。CAS 指令作为一种硬件原语，有着天然的原子性，这也正是 CAS 的价值所在。\",\"CAS 虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方面：\",\"自旋 CAS 长时间地不成功，则会给 CPU 带来非常大的开销\",\"只能保证一个共享变量原子操作\",\"ABA 问题\",\"ABA问题：当有多个线程对一个原子类进行操作的时候，某个线程在短时间内将原子类的值A修改为B，又马上将其修改为A，此时其他线程不感知，还是会修改成功。\",\"ABA问题示例：\",\"package com.concurrent; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.atomic.AtomicMarkableReference; import java.util.concurrent.atomic.AtomicStampedReference; import java.util.concurrent.locks.LockSupport; /** * 与钱相关的业务 ABA问题比较重要 * 也可以使用{@link AtomicMarkableReference} 简化，这样可以不关心修改过几次，仅仅关心是否修改过。因此变量mark是boolean类型，仅记录值是否有过修改。 */ @Slf4j public class AtomicStampedReferenceTest { public static void main(String[] args) { // 定义AtomicStampedReference Pair.reference值为1, Pair.stamp为1 AtomicStampedReference atomicStampedReference = new AtomicStampedReference(1, 1); new Thread(() -> { int[] stampHolder = new int[1]; int value = (int) atomicStampedReference.get(stampHolder); int stamp = stampHolder[0]; log.debug(\\\"Thread1 read value: \\\" + value + \\\", stamp: \\\" + stamp); // 阻塞1s LockSupport.parkNanos(1000000000L); // Thread1通过CAS修改value值为3 if (atomicStampedReference.compareAndSet(value, 3, stamp, stamp + 1)) { log.debug(\\\"Thread1 update from \\\" + value + \\\" to 3\\\"); } else { log.debug(\\\"Thread1 update fail!\\\"); } }, \\\"Thread1\\\").start(); new Thread(() -> { int[] stampHolder = new int[1]; int value = (int) atomicStampedReference.get(stampHolder); int stamp = stampHolder[0]; log.debug(\\\"Thread2 read value: \\\" + value + \\\", stamp: \\\" + stamp); // Thread2通过CAS修改value值为2 if (atomicStampedReference.compareAndSet(value, 2, stamp, stamp + 1)) { log.debug(\\\"Thread2 update from \\\" + value + \\\" to 2\\\"); // do something value = (int) atomicStampedReference.get(stampHolder); stamp = stampHolder[0]; log.debug(\\\"Thread2 read value: \\\" + value + \\\", stamp: \\\" + stamp); // Thread2通过CAS修改value值为1 if (atomicStampedReference.compareAndSet(value, 1, stamp, stamp + 1)) { log.debug(\\\"Thread2 update from \\\" + value + \\\" to 1\\\"); } } }, \\\"Thread2\\\").start(); } } \"]},\"1357\":{\"h\":\"Atomic源码解析\",\"t\":[\"在java.util.concurrent.atomic包里提供了一组原子操作类：\",\"基本类型：AtomicInteger、AtomicLong、AtomicBoolean；\",\"引用类型：AtomicReference、AtomicStampedRerence、AtomicMarkableReference；\",\"数组类型：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray\",\"对象属性原子修改器：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater\",\"原子类型累加器（jdk1.8增加的类）：DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder、Striped64\",\"LongAdder和DoubleAdder在高并发的情况下，性能提升明显：\",\"LongAdder内部有一个base变量，一个cell[]数组：\",\"base变量：非竞态条件下，直接累加到该变量上\",\"Cell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中\",\"/** Number of CPUS, to place bound on table size */ // CPU核数，用来决定槽数组的大小 static final int NCPU = Runtime.getRuntime().availableProcessors(); /** * Table of cells. When non-null, size is a power of 2. */ // 数组槽，大小为2的次幂 transient volatile Cell[] cells; /** * Base value, used mainly when there is no contention, but also as * a fallback during table initialization races. Updated via CAS. */ /** * 基数，在两种情况下会使用： * 1. 没有遇到并发竞争时，直接使用base累加数值 * 2. 初始化cells数组时，必须要保证cells数组只能被初始化一次（即只有一个线程能对cells初始化）， * 其他竞争失败的线程会讲数值累加到base上 */ transient volatile long base; /** * Spinlock (locked via CAS) used when resizing and/or creating Cells. */ \",\"定义了一个内部Cell类，这就是我们之前所说的槽，每个Cell对象存有一个value值，可以通过Unsafe来CAS操作它的值：\",\"添加方法的源代码：\",\" public void add(long x) { Cell[] cs; long b, v; int m; Cell c; if ((cs = cells) != null || !casBase(b = base, b + x)) { boolean uncontended = true; if (cs == null || (m = cs.length - 1) < 0 || (c = cs[getProbe() & m]) == null || !(uncontended = c.cas(v = c.value, v + x))) longAccumulate(x, null, uncontended); } } \",\"LongAdder#add方法的逻辑如下图：\",\"只有从未出现过并发冲突的时候，base基数才会使用到，一旦出现了并发冲突，之后所有的操作都只针对Cell[]数组中的单元Cell。\",\"如果Cell[]数组未初始化，会调用父类的longAccumelate去初始化Cell[]，如果Cell[]已经初始化但是冲突发生在Cell单元内，则也调用父类的longAccumelate，此时可能就需要对Cell[]扩容了。\",\"这也是LongAdder设计的精妙之处：尽量减少热点冲突，不到最后万不得已，尽量将CAS操作延迟。\",\"整个Striped64#longAccumulate的流程图如下：\"]},\"1358\":{\"h\":\"synchronized实现原理\"},\"1359\":{\"h\":\"synchronized基础\",\"t\":[\"Java中对静态变量的自增、自减并不是原子操作。\",\"i++的JVM字节码指令：\",\"getstatic i // 获取静态变量i的值 iconst_1 // 将int常量1压入操作数栈 iadd // 自增 \",\"i--的JVM字节码指令：\",\"getstatic i // 获取静态变量i的值 iconst_1 // 将int常量1压入操作数栈 isub // 自减 \",\"一个程序运行多个线程本身是没有问题的，问题出在多个线程访问共享资源：\",\"多个线程读共享其实也没有问题\",\"在多个线程对共享资源读写操作时发生指令交错，就会出现问题\",\"一段代码块如果存在对共享资源的多线程读写操作，就称这段代码块为临界区，其共享资源为临界资源。\",\"//临界资源 private static int counter = 0; public static void increment() { //临界区 counter++; } public static void decrement() {//临界区 counter--; } \",\"多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件，为了避免临界区的竞态条件发生，有多种手段可以达到目的：\",\"阻塞式的解决方案：synchronized、Lock\",\"非阻塞式的解决方案：原子变量（CAS）\",\"虽然Java中互斥和同步都可以采用synchronized关键字来完成，但它们还是有区别的：互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码，同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点。\",\"synchronized同步块是Java提供的一种原子性内置锁，Java中的每个对象都可以把它当作一个同步锁来使用，这些Java内置的使用者看不到的锁被称为内置锁，也叫做监视器锁。\",\"synchronized加锁方式：\",\"对于上面的例子，可以使用synchroized来解决临界区资源共享的问题：\",\"/********************* * 方式一 *******************/ public static synchronized void increment() { counter++; } public static synchronized void decrement() { counter--; } /********************* * 方式二 *******************/ private static String lock = \\\"\\\"; public static void increment() { synchronized (lock){ counter++; } } public static void decrement() { synchronized (lock) { counter--; } } \"]},\"1360\":{\"h\":\"Monitor机制\",\"t\":[\"synchronized是JVM内置锁，基于Monitor机制实现，依赖底层操作系统的互斥原语Mutex（互斥量），它是一个重量级锁，性能较低。后来，synchronized在JDK1.5之后版本做了重大的优化，如锁粗化、锁消除、轻量级锁、偏向锁、自适应自旋等技术来减少锁操作的开销，内置锁的并发性能已经基本与Lock持平。\",\"同步方法是通过方法中的access_flags中设置ACC_SYNCHRONIZED标志来实现；同步代码块是通过monitorenter和monitorexit来实现。两个指令的执行是JVM通过调用操作系统的互斥源于meutex来实现。被阻塞的线程会被挂起、等待重新调度，会导致“用户态”和“内核态”两个态之间来回切换，对性能有较大影响。\",\"Monitor，直译为“监视器”，在操作系统领域一般翻译为“管程“。管程是指管理共享变量以及对共享变量操作的过程，让它们支持并发。在Java1.5之前，Java语言提供的唯一并发语言就是管程，Java1.5之后提供的SDK并发包也是以管程为基础的。除了Java之外，C/C++、C#等高级语言也都是支持管程的。sychronized关键字和wait()、notify()、notifyAll()这三个方法是Java中管程技术的组成部分。\",\"在管程的发展史上，先后出现过三种不同的管程模型，分别是Hasen模型、Hoare模型和MESA模型。现在广泛使用的是MESA模型。\",\"管程中引入了条件变量的概念，而且每个条件变量都对应有一个等待队列。条件变量个等待队列的作用是解决线程之间的同步问题。\",\"对于MESA管程来说，有一个编程范式：\",\"while(条件不满足) { wait(); } \",\"唤醒时间和获取到锁继续执行的时间是不一致的，被唤醒的线程再次执行时可能条件又不满足了，所以循环校验条件。MESA模型的wait()方法还有一个超时参数，为了避免线程进入等待队列永久阻塞。\",\"notify和notifyAll分别何时使用：\",\"所有等待线程拥有相同的等待条件\",\"所有等待线程被唤醒后，执行相同的操作\",\"只需要唤醒一个线程\",\"ObjectMonitor() { _header = NULL; //对象头 markOop _count = 0; _waiters = 0, _recursions = 0; // 锁的重入次数 _object = NULL; //存储锁对象 _owner = NULL; // 标识拥有该monitor的线程（当前获取锁的线程） _WaitSet = NULL; // 等待线程（调用wait）组成的双向循环链表，_WaitSet是第一个节点 _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; //多线程竞争锁会先存到这个单向链表中 （FILO栈结构） FreeNext = NULL ; _EntryList = NULL ; //存放在进入或重新进入时被阻塞(blocked)的线程 (也是存竞争锁失败的线程) _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; _previous_owner_tid = 0; } \",\"Java中Monitor的工作流程：\",\"在获取锁时，是将当前线程插入到cxq的头部，而释放锁时，默认策略（QMode=0）是：如果EntryList为空，则将cxq中的元素按原有顺序插入到EntryList，并唤醒第一个线程，也就是当EntryList为空时，是后来的线程先获取锁。_EntryList不为空，直接从_EntryList中唤醒线程。\",\"重量级锁阻塞挂起的方法：pthread_cond_wait。\"]},\"1361\":{\"h\":\"对象头\",\"t\":[\"Hotspot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对其填充（Padding）。\",\"对象头：比如hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象才有）等\",\"实例数据：存放类的属性数据信息，包括父类的属性信息\",\"对其填充：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐\",\"HotSpot虚拟机的对象头包括：\",\"Mark Word\",\"用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位虚拟机中分别为32bit和64bit，官方称它为“Mark Word”\",\"Klass Pointer\",\"对象头的另一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。32位4字节，64位开启指针压缩或最大堆内存<32g时4字节，否则8字节。JDK默认开启指针压缩后位4字节，当在JVM参数中关闭指针压缩（-XX:-UseCompressedOops）后，长度为8字节\",\"数组长度（只有数组对象有）\",\"如果对象是一个数组，那还在对象头中还必须有一块数据用于记录数组长度。占据4字节\",\"new Object()在64位的操作系统的内存中占几8（对象头）+4（元数据指针）+4（对齐填充）=16个字节。\",\"32位JVM下的对象结构描述：\",\"64位JVM下的对象结构描述：\",\"Mark Word中锁标记枚举：\",\"enum { locked_value = 0, //00 轻量级锁 unlocked_value = 1, //001 无锁 monitor_value = 2, //10 监视器锁，也叫膨胀锁，也叫重量级锁 marked_value = 3, //11 GC标记 biased_lock_pattern = 5 //101 偏向锁 } \",\"含义如下：\"]},\"1362\":{\"h\":\"偏向锁\",\"t\":[\"偏向锁是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了消除数据在无竞争情况下锁重入（CAS操作）的开销而引入偏向锁。对于没有锁竞争的场合，偏向锁有很好的优化效果。\",\"/***StringBuffer内部同步***/ public synchronized int length() { return count; } //System.out.println 无意识的使用锁 public void println(String x) { synchronized (this) { print(x); newLine(); } } \",\"当JVM启用了偏向锁模式（jdk6默认开启），新创建对象的Mark Word中的Thread ID为0，说明此时处于可偏向但未偏向任何线程，也叫做匿名偏向状态。\",\"偏向锁模式存在偏向锁延迟机制：HotSpot虚拟机在启动后有4s的延迟才会对每个新建的对象开启偏向锁模式。JVM启动时会进行一系列的复杂活动，比如装在配置，系统类初始化等等。在这个过程中会使用大量synchronized关键字对对象加锁，且这些锁大多数都不是偏向锁。为了减少初始化时间，JVM默认延时加载偏向锁。\",\"/关闭延迟开启偏向锁 -XX:BiasedLockingStartupDelay=0 //禁止偏向锁 -XX:-UseBiasedLocking //启用偏向锁 -XX:+UseBiasedLocking \",\"倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段，此时Mark Word的结构也变为轻量级锁的结构。轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间多个线程访问同一把锁的场合，就会导致轻量级锁膨胀为重量级锁。\",\"锁升级过程：\",\"从偏向锁的加锁和解锁过程中可以看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获取锁时，JVM就需要等到安全点时，再将偏向锁撤销为无锁状态或升级为轻量级锁，这个过程会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。\",\"以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向锁撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。\",\"每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正在加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发生当前对象的epoch值和class的epoch不想等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id改成当前线程Id。\",\"当达到重偏向阈值（默认20）后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。\",\"设置JVM参数-XX:+PrintFlagsFinal，在项目启动时即可输出JVM的默认参数值\",\"intx BiasedLockingBulkRebiasThreshold = 20 // 默认偏向锁批量重偏向阈值 intx BiasedLockingBulkRevokeThreshold = 40 //默认偏向锁批量撤销阈值 \",\"可以通过JVM参数XX:BiasedLockingBulkRebiasThreshold和XX:BiasedLockingBulkRevokeThreshold来手动设置阈值。\",\"当撤销偏向锁阈值超过40次后，JVM会认为不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的。\",\"注意；时间-XX:BiasedLockingDecayTime=25000ms范围内没有达到40次，撤销次数清0，重新计时。\",\"批量重偏向和批量撤销的总结：\",\"批量重偏向和批量撤销是针对类的优化，和对象无关\",\"偏向锁重偏向一次之后不可再次重偏向\",\"当某个类已经触发批量撤销机制后，JVM会默认当前类产生了严重的问题，剥夺了该类的新实例对象使用偏向锁的权利\",\"重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候线持有锁的线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。\",\"自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势\",\"在Java6之后自旋是自适应的，比如对象刚刚一次自旋操作成功过，那么认为这次自旋成功的可能性高，就会多自旋几次；繁殖，就少自旋身之不自旋，比较智能\",\"Java7之后不能控制是否开启自旋功能\",\"自旋的目的是为了减少线程挂起的次数，尽量避免直接挂起线程（挂起操作涉及系统调用，存在用户态和内核态切换，这才是重量级锁最大的开销）。\"]},\"1363\":{\"h\":\"锁粗化\",\"t\":[\"假设一系列的连续操作都会对同一个对象反复加锁及解锁，甚至加锁的操作是出现在循环体中的，即使没有出现线程竞争，频繁地互斥同步操作也会导致不必要的性能损耗。如果JVM检测到有一连串零碎的操作都是对同一对象的加锁，将会扩大加锁同步的范围（即锁粗化）到整个操作序列的外部。\",\"StringBuffer buffer = new StringBuffer(); /** * 锁粗化 */ public void append(){ buffer.append(\\\"aaa\\\").append(\\\" bbb\\\").append(\\\" ccc\\\"); } \",\"上述代码每次调用buffer.append方法都需要加锁和解锁，如果JVM检测到有一连串的对同一个对象的加锁和解锁的操作，就会将其合并称一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。\"]},\"1364\":{\"h\":\"锁消除\",\"t\":[\"锁消除即删除不必要的加锁操作。锁消除是Java虚拟机在JIT编译期间，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间。\",\"public class LockEliminationTest { /** * 锁消除 * -XX:+EliminateLocks 开启锁消除(jdk8默认开启） * -XX:-EliminateLocks 关闭锁消除 * @param str1 * @param str2 */ public void append(String str1, String str2) { StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(str1).append(str2); } public static void main(String[] args) throws InterruptedException { LockEliminationTest demo = new LockEliminationTest(); long start = System.currentTimeMillis(); for (int i = 0; i < 100000000; i++) { demo.append(\\\"aaa\\\", \\\"bbb\\\"); } long end = System.currentTimeMillis(); System.out.println(\\\"执行时间：\\\" + (end - start) + \\\" ms\\\"); } } \",\"StringBuffer的append是个同步方法，但是append方法中的StringBuffer属于一个局部变量，不可能从该方法中逃逸出去，因此其实这个过程是线程安全的，可以将锁消除。\"]},\"1365\":{\"h\":\"逃逸分析\",\"t\":[\"逃逸分析，是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java HotSpot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域。\",\"逃逸分析分为方法逃逸和线程逃逸：\",\"方法逃逸：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中\",\"线程逃逸：这个对象甚至可能被其它线程访问到，例如赋值给类变量或可以在其它线程中访问的实例变量\",\"使用逃逸分析，编译器可以对代码做如下优化：\",\"同步省略或锁消除。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步\",\"将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配\",\"分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中\"]},\"1366\":{\"h\":\"synchronized的优化\",\"t\":[\"JVM对synchronized做了如下优化：\",\"针对偏向锁（偏向锁撤销存在性能问题），有批量重偏向，批量撤销\",\"针对重量级锁，有自旋优化，自适应自旋\",\"锁的粗化和锁的消除\"]},\"1367\":{\"h\":\"AQS与ReentrantLock实现原理\",\"t\":[\"AQS的核心：\",\"同步等待队列（单向链表）：主要用于维护获取锁失败时的入队的线程\",\"条件等待队列（双向链表）：调用await()的时候会释放锁，然后线程会加入到条件队列，调用signal唤醒的时候会把条件队列中的线程节点移动到同步队列中，等待再次获得锁\",\"JUC包中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列，条件队列，独占获取，共享获取等，而这些行为的抽象就是基于AbstractQueuedSynchronizer实现的，AQS是一个抽象同步框架，可以用来实现一个依赖状态的同步器。\",\"JDK中提供的大多数的同步器如Lock，Latch，Barrier等，都是基于AQS框架来实现的\",\"一般是通过一个内部类Sync继承AQS\",\"将同步器所有调用都映射到Sync对应的方法\",\"AQS具备的特性：\",\"阻塞等待队列\",\"共享/独占\",\"公平/非公平\",\"可重入\",\"允许中断\",\"AQS内部维护属性volatile int state：\",\"state表示资源的可用状态\",\"state属性三种访问方式：\",\"getState()\",\"setState()\",\"compareAndSetState()\",\"AQS定义两种资源共享方式：\",\"Exclusive-独占，只有一个线程能执行，如ReentrantLock\",\"Share-共享，多个线程可以同时执行，如Semaphore/CountDownLatch\",\"AQS定义了5个队列中节点的状态：\",\"值为0，初始化状态，表示当前节点在sync队列中，等到着获取锁。\",\"CANCELLED，值为1，表示当前的线程被取消\",\"SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark\",\"CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中\",\"PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行\"]},\"1368\":{\"h\":\"同步等待队列\",\"t\":[\"AQS当中的同步等待队列也称CLH队列，CLH队列是一种基于双向链表数据结构的队列，是FIFO先进先出线程等待队列，Java中的CLH队列是原CLH队列的一个变种，线程由原自旋机制改为阻塞机制。\",\"AQS依赖CLH同步队列来完成同步状态的管理：\",\"当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程\",\"当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态\",\"通过signal或signalAll将条件队列中的节点转移到同步队列（由条件队列转移到同步队列）\"]},\"1369\":{\"h\":\"条件等待队列\",\"t\":[\"AQS中条件队列是使用单向列表保存的，用nextWaiter来连接：\",\"调用await方法阻塞线程\",\"当前线程存在于同步队列的头结点，调用await方法进行阻塞（从同步队列转移到条件队列）\"]},\"1370\":{\"h\":\"Condition接口\",\"t\":[\"调用Condition#await方法会释放当前持有的锁，然后阻塞当前线程，同时向Condition队列尾部添加一个节点，所以调用Condition#await方法的时候必须持有锁\",\"调用Condition#signal方法会将Condition队列的首节点移动到阻塞队列尾部，然后唤醒因调用Condition#await方法而阻塞的线程（唤醒之后这个线程就可以去竞争锁了），所以调用Condition#signal方法的时候必须持有锁，持有锁的线程唤醒被因调用Condition#await方法而阻塞的线程\"]},\"1371\":{\"h\":\"ReentrantLock详解\",\"t\":[\"ReentrantLock是一种互斥锁，相比于synchronized，ReentrantLock具备如下特点：\",\"可中断\",\"可以设置超时时间\",\"可以设置为公平锁\",\"支持多个条件变量\",\"与synchronized一样，都支持可重入\",\"我们主要的关注点：\",\"ReentrantLock加锁解锁的逻辑\",\"公平和非公平，可重入锁的实现\",\"线程竞争锁失败入队阻塞逻辑和获取锁的线程释放锁唤醒阻塞线程竞争锁的逻辑实现\",\"完成的流程图：https://www.processon.com/view/link/6191f070079129330ada1209\"]},\"1372\":{\"h\":\"synchronized和ReentrantLock\",\"t\":[\"synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现；\",\"synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过ReentrantLock#isLocked判断；\",\"synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；\",\"synchronized是不可以被中断的，而ReentrantLock#lockInterruptibly方法是可以被中断的；\",\"在发生异常时synchronized会自动释放锁，而ReentrantLock需要开发者在finally块中显示释放锁；\",\"ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock(),以及等待指定时长的获取，更加灵活；\",\"synchronized在特定的情况下对于已经在等待的线程是后来的线程先获得锁（回顾一下sychronized的唤醒策略），而ReentrantLock对于已经在等待的线程是先来的线程先获得锁；\"]},\"1373\":{\"h\":\"Semaphore与CountDownLatch\",\"t\":[\"Semaphore，俗称信号量，它是操作系统中PV操作的源语在Java中的实现，它也是基于AQS来实现的。\",\"Semaphore可以用于做流量控制，特别是公共资源有限的应用场景。\",\"Semaphore与ReentantLock的逻辑实现区别在于Semaphore是共享锁。\",\"共享锁的模式，会一直尝试唤醒后续节点。\",\"CyclicBarrier与CountDownLatch的区别：\",\"CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次\",\"CyclicBarrier是通过ReentranLock的“独占锁”和Condition来实现一组线程的阻塞唤醒的，而CountDownLatch则是通过AQS的“共享锁”实现\"]},\"1374\":{\"h\":\"CylicBarrier实现原理\"},\"1375\":{\"h\":\"ReentrantReadWriteLock\",\"t\":[\"在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源（读读可以并发）；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写操作了（读写，写读，写写互斥）。在读多写少的情况下，读写锁能够提供比拍他锁更好的并发性和吞吐量。\",\"针对这种场景，Java并发包提供了读写锁ReentrantReadWriteLock，在它内部，维护了一对相关的锁，一个用于只读操作；一个用于写入操作，成为写锁。\",\"线程进入读锁的前提条件：\",\"没有其他线程的写锁\",\"没有写请求或者有写请求，但是调用线程和持有锁的线程是同一个\",\"线程进入写锁的前提条件：\",\"没有其他线程的读锁\",\"没有其他线程的写锁\",\"读写锁有一下三个重要的特性：\",\"公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平\",\"可重入：读锁和写锁都支持线程重入。读线程获取读锁后，能够再次获取读锁。写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁\",\"锁降级：遵循获取写锁、再获取读锁最后释放写锁的次序，写锁能够降级成为读锁\",\"ReentrantReadWriteLock是可重入的读写锁实现类。在它内部，维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有Writer线程，读锁可以由多个Reader线程同时持有。也就是说，写锁是独占的，读锁是共享的。\",\"锁降级中的读锁获取是否必要呢？必要，这样做的目的是为了保证数据的可见性。如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记为线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到线程使用的数据并释放读锁之后，线程T才能获取写锁进行数据更新。\",\"ReentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的也是保证数据的可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其对其他获取到读锁的线程是不可见的。\",\"悲观锁：考虑最坏的场景，为了保证线程安全，每次操作都会上锁；\",\"乐观锁的例子：\",\"select count, version from table where id = ? version = 100; update table set count = count - 1, version = version + 1 where id = ? and version = 100; \",\"此时假设有三个线程同时执行这条更新语句：\",\"# T1 操作 update success 返回值为1，version此时为101 # T2 操作 update success 返回值为0，这意味着加锁失败，返回的成功的行数值可以作为加锁成功的依据，可以在业务逻辑里面判断是否返回0 # T3操作 update 成功 返回值为0 \",\"乐观锁又被称为无锁算法。\",\"JDK乐观锁的实现：java.util.concurrent.locks.StampedLock。\"]},\"1376\":{\"h\":\"BlockingQueue实现原理\",\"t\":[\"阻塞队列的总结：https://www.processon.com/view/link/618ce3941e0853689b0818e2\"]},\"1377\":{\"h\":\"Queue队列\",\"t\":[\"public interface Queue<E> extends Collection<E> { //添加一个元素，添加成功返回true, 如果队列满了，就会抛出异常 boolean add(E e); //添加一个元素，添加成功返回true, 如果队列满了，返回false boolean offer(E e); //返回并删除队首元素，队列为空则抛出异常 E remove(); //返回并删除队首元素，队列为空则返回null E poll(); //返回队首元素，但不移除，队列为空则抛出异常 E element(); //获取队首元素，但不移除，队列为空则返回null E peek(); } \"]},\"1378\":{\"h\":\"BlockingQueue\",\"t\":[\"BlockingQueue和JDK集合包中的Queue接口兼容，同时在其基础上增加了阻塞功能。\",\"入队：\",\"（1）offer(E e)：如果队列没满，返回true，如果队列已满，返回false（不阻塞）\",\"（2）offer(E e, long timeout, TimeUnit unit)：可以设置阻塞时间，如果队列已满，则进行阻塞。超过阻塞时间，则返回false\",\"（3）put(E e)：队列没满的时候是正常的插入，如果队列已满，则阻塞，直至队列空出位置\",\"出队：\",\"（1）poll()：如果有数据，出队，如果没有数据，返回null （不阻塞）\",\"（2）poll(long timeout, TimeUnit unit)：可以设置阻塞时间，如果没有数据，则阻塞，超过阻塞时间，则返回null\",\"（3）take()：队列里有数据会正常取出数据并删除；但是如果队列里无数据，则阻塞，直到队列里有数据\",\"当队列满了无法添加元素，或者是队列空了无法移除元素时：\",\"抛出异常：add、remove、element\",\"返回结果但不抛出异常：offer、poll、peek\",\"阻塞：put、take\",\"方法\",\"抛出异常\",\"返回特定值\",\"阻塞\",\"阻塞特定时间\",\"入队\",\"add(e)\",\"offer(e)\",\"put(e)\",\"offer(e, time, unit)\",\"出队\",\"remove()\",\"poll()\",\"take()\",\"poll(time, unit)\",\"获取队首元素\",\"element()\",\"peek()\",\"不支持\",\"不支持\",\"阻塞队列出了阻塞外还有一个非常重要的属性，那就是容量的大小，分为有界和无界两种。无界队列意味着里面可以容纳非常多的元素，例如LinkedBlockingQueue的上限是Integer.MAX_VALUE，是非常大的一个数，可以近似认为是无限容量，因为我们几乎无法把这个容量装满。但是有的阻塞队列是有界的，例如ArrayBlockingQueue如果容量满了，也不会扩容，所以一旦满了就无法再往里放数据了。\",\"public LinkedBlockingQueue() { this(Integer.MAX_VALUE); } \",\"BlockingQueue是线程安全的，我们在很多场景下都可以利用线程安全的队列来优雅地解决我们业务自身的线程安全问题。比如说，使用生产者/消费者模式的时候，我们生产者只需要从队列里取出它们就可以了，如图所示；\",\"因为阻塞队列是线程安全的，所以生产者和消费者都可以是多线程的，不会发生线程安全问题。生产者/消费者直接使用线程安全的队列就可以，而不需要自己去考虑更多的线程安全问题。这也就意味着，考虑锁等线程安全问题的重任从开发者转移到了“队列”上，降低了我们开发的难度和工作量。\",\"同时，队列它还能起到一个隔离的作用。比如说我们开发一个银行转账的程序，那么生产者不需要关心具体的转账逻辑，只需要把转帐任务，如账户和金额等信息放到队列中就可以，而不需要去关心银行这个类如何实现具体的转账业务。而作为银行这个类来讲，它会从队列里取出来将要执行的具体任务，再去通过自己的各种方式来完成本次转账。这样就实现了具体任务与执行任务类之间的结偶，任务被放在了阻塞队列中，而负责放任务的线程是无法直接访问到我们银行具体实现转账操作的对象的，实现了隔离，提高了安全性。\",\"常见的阻塞队列：\",\"队列\",\"描述\",\"ArrayBlockingQueue\",\"基于数组结构实现的一个有界阻塞队列\",\"LinkedBlockingQueue\",\"基于链表结构实现的一个有界阻塞队列\",\"PriorityBlockingQueue\",\"支持按优先级排序的无界阻塞队列\",\"DelayQueue\",\"基于优先级队列（PriorityBlockingQueue）实现的无界阻塞队列\",\"SynchronousQueue\",\"不存储元素的阻塞队列\",\"LinkedTransferQueue\",\"基于链表结构实现的一个无界阻塞队列\",\"LinkedBlockingDeque\",\"基于链表结构实现的一个双端阻塞队列\"]},\"1379\":{\"h\":\"ArrayBlockingQueue\",\"t\":[\"ArrayBlockingQueue是典型的有界阻塞队列，其内部是用数组存储元素的，初始化时需要指定容量大小，利用ReentrantLock实现线程安全。\",\"在生产者-消费者模型中使用时，如果生产速度和消费速度基本匹配的情况下，使用ArrayBlockingQueue是个不错的选择；当如果生产速度远远大于消费速度，则会导致队列填满，大量生产线程被阻塞。\",\"使用独占锁ReentrantLock实现线程安全，入队和出队操作使用同一个锁对象，也就是说只能有一个线程可以进行入队或者出队操作；这也就意味着生产者和消费者无法并行操作，在高并发场景下会成为性能瓶颈。\",\"数据结构如下：\",\"//数据元素数组 final Object[] items; //下一个待取出元素索引 int takeIndex; //下一个待添加元素索引 int putIndex; //元素个数 int count; //内部锁 final ReentrantLock lock; //消费者 private final Condition notEmpty; //生产者 private final Condition notFull; public ArrayBlockingQueue(int capacity) { this(capacity, false); } public ArrayBlockingQueue(int capacity, boolean fair) { ... lock = new ReentrantLock(fair); //公平，非公平 notEmpty = lock.newCondition(); notFull = lock.newCondition(); } \",\"入队put方法：\",\"public void put(E e) throws InterruptedException { //检查是否为空 checkNotNull(e); final ReentrantLock lock = this.lock; //加锁，如果线程中断抛出异常 lock.lockInterruptibly(); try { //阻塞队列已满，则将生产者挂起，等待消费者唤醒 //设计注意点： 用while不用if是为了防止虚假唤醒 while (count == items.length) notFull.await(); //队列满了，使用notFull等待（生产者阻塞） // 入队 enqueue(e); } finally { lock.unlock(); // 唤醒消费者线程 } } private void enqueue(E x) { final Object[] items = this.items; //入队 使用的putIndex items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; //设计的精髓： 环形数组，putIndex指针到数组尽头了，返回头部 count++; //notEmpty条件队列转同步队列，准备唤醒消费者线程，因为入队了一个元素，肯定不为空了 notEmpty.signal(); } \",\"出队操作：\",\"public E take() throws InterruptedException { final ReentrantLock lock = this.lock; //加锁，如果线程中断抛出异常 lock.lockInterruptibly(); try { //如果队列为空，则消费者挂起 while (count == 0) notEmpty.await(); //出队 return dequeue(); } finally { lock.unlock();// 唤醒生产者线程 } } private E dequeue() { final Object[] items = this.items; @SuppressWarnings(\\\"unchecked\\\") E x = (E) items[takeIndex]; //取出takeIndex位置的元素 items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; //设计的精髓： 环形数组，takeIndex 指针到数组尽头了，返回头部 count--; if (itrs != null) itrs.elementDequeued(); //notFull条件队列转同步队列，准备唤醒生产者线程，此时队列有空位 notFull.signal(); return x; } \",\"这里设计成环形链表的原因是基于效率的考量，这样，当去除takeIndex对应的元素之后，就不需要移动它后面的元素，而是直接移动takeIndex的指针，即takeIndex++，这样的话，删除元素的时间复杂度也变为了O(1)。\"]},\"1380\":{\"h\":\"LinkedBlockingQueue\",\"t\":[\"LinkedBlockingQueue是一个基于链表实现的阻塞队列，默认情况下，该阻塞队列的大小为Integer.MAX_VALUE，由于这个数值特别大，所以LinkedBlockingQueue也被称作无界队列，代表它几乎没有界限，队列可以随着元素的添加而动态增长，但是如果没有剩余内存，则队列抛出OOM错误。所以为了避免队列过大造成机器负载或者内存爆满的情况出现，我们在使用的时候建议手动传一个队列的大小。\",\"LinkedBlockingQueue内存由单链表实现，只能从head取元素，从tail添加元素。LinkedBlockingQueue采用两把锁的锁分离技术实现入队出队互不阻塞，添加元素和获取元素都有独立的锁，也就是说LinkedBlockingQueue是读写分离的，读写操作可以并发执行。\",\"LinkedBlockingQueue使用：\",\"//指定队列的大小创建有界队列 BlockingQueue<Integer> boundedQueue = new LinkedBlockingQueue<>(100); //无界队列 BlockingQueue<Integer> unboundedQueue = new LinkedBlockingQueue<>(); \",\"数据结构：\",\"// 容量,指定容量就是有界队列 private final int capacity; // 元素数量 private final AtomicInteger count = new AtomicInteger(); // 链表头 本身是不存储任何元素的，初始化时item指向null transient Node<E> head; // 链表尾 private transient Node<E> last; // take锁 锁分离，提高效率 private final ReentrantLock takeLock = new ReentrantLock(); // notEmpty条件 // 当队列无元素时，take锁会阻塞在notEmpty条件上，等待其它线程唤醒 private final Condition notEmpty = takeLock.newCondition(); // put锁 private final ReentrantLock putLock = new ReentrantLock(); // notFull条件 // 当队列满了时，put锁会会阻塞在notFull上，等待其它线程唤醒 private final Condition notFull = putLock.newCondition(); //典型的单链表结构 static class Node<E> { E item; //存储元素 Node<E> next; //后继节点 单链表结构 Node(E x) { item = x; } } \",\"构造器：\",\"public LinkedBlockingQueue() { // 如果没传容量，就使用最大int值初始化其容量 this(Integer.MAX_VALUE); } public LinkedBlockingQueue(int capacity) { if (capacity <= 0) throw new IllegalArgumentException(); this.capacity = capacity; // 初始化head和last指针为空值节点 last = head = new Node<E>(null); } \",\"入队put方法：\",\"public void put(E e) throws InterruptedException { // 不允许null元素 if (e == null) throw new NullPointerException(); int c = -1; // 新建一个节点 Node<E> node = new Node<E>(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; // 使用put锁加锁 putLock.lockInterruptibly(); try { // 如果队列满了，就阻塞在notFull上等待被其它线程唤醒（阻塞生产者线程） while (count.get() == capacity) { notFull.await(); } // 队列不满，就入队 enqueue(node); c = count.getAndIncrement();// 队列长度加1，返回原值 // 如果现队列长度小于容量，notFull条件队列转同步队列，准备唤醒一个阻塞在notFull条件上的线程(可以继续入队) // 这里为啥要唤醒一下呢？ // 因为可能有很多线程阻塞在notFull这个条件上,而取元素时只有取之前队列是满的才会唤醒notFull,此处不用等到取元素时才唤醒 if (c + 1 < capacity) notFull.signal(); } finally { putLock.unlock(); // 真正唤醒生产者线程 } // 如果原队列长度为0，现在加了一个元素后立即唤醒阻塞在notEmpty上的线程 if (c == 0) signalNotEmpty(); } private void enqueue(Node<E> node) { // 直接加到last后面,last指向入队元素 last = last.next = node; } private void signalNotEmpty() { final ReentrantLock takeLock = this.takeLock; takeLock.lock();// 加take锁 try { notEmpty.signal();// notEmpty条件队列转同步队列，准备唤醒阻塞在notEmpty上的线程 } finally { takeLock.unlock(); // 真正唤醒消费者线程 } \",\"出队方法：\",\"public E take() throws InterruptedException { E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; // 使用takeLock加锁 takeLock.lockInterruptibly(); try { // 如果队列无元素，则阻塞在notEmpty条件上（消费者线程阻塞） while (count.get() == 0) { notEmpty.await(); } // 否则，出队 x = dequeue(); c = count.getAndDecrement();//长度-1，返回原值 if (c > 1)// 如果取之前队列长度大于1，notEmpty条件队列转同步队列，准备唤醒阻塞在notEmpty上的线程，原因与入队同理 notEmpty.signal(); } finally { takeLock.unlock(); // 真正唤醒消费者线程 } // 为什么队列是满的才唤醒阻塞在notFull上的线程呢？ // 因为唤醒是需要加putLock的，这是为了减少锁的次数,所以，这里索性在放完元素就检测一下，未满就唤醒其它notFull上的线程, // 这也是锁分离带来的代价 // 如果取之前队列长度等于容量（已满），则唤醒阻塞在notFull的线程 if (c == capacity) signalNotFull(); return x; } private E dequeue() { // head节点本身是不存储任何元素的 // 这里把head删除，并把head下一个节点作为新的值 // 并把其值置空，返回原来的值 Node<E> h = head; Node<E> first = h.next; h.next = h; // 方便GC head = first; E x = first.item; first.item = null; return x; } private void signalNotFull() { final ReentrantLock putLock = this.putLock; putLock.lock(); try { notFull.signal();// notFull条件队列转同步队列，准备唤醒阻塞在notFull上的线程 } finally { putLock.unlock(); // 解锁，这才会真正的唤醒生产者线程 } \",\"LinkedBlockingQueue的总结：\"]},\"1381\":{\"h\":\"LinkedBlockingDeque\",\"t\":[\"LinkedBlockingDeque的总结：\"]},\"1382\":{\"h\":\"SynchronousQueue\",\"t\":[\"SynchronousQueue非常适合传递性场景做交换工作，生产者的线程和消费者的线程同步传递某些信息、事件或者任务。\"]},\"1383\":{\"h\":\"PriorityBlockingQueue\",\"t\":[\"优先级队列采用二叉堆的数据结构。\",\"大顶堆和小顶堆：\",\"大顶堆：父结点的键值总是大于或等于任何一个子结点的键值\",\"小顶堆：父结点的键值总是小于或等于任何一个子结点的键值\",\"扩容的算法：\",\"int newCap = oldCap + ((oldCap < 64) ? (oldCap + 2) : (oldCap >> 1)); \",\"构造小顶堆的方法：\",\" private static <T> void siftUpComparable(int k, T x, Object[] es) { Comparable<? super T> key = (Comparable<? super T>) x; while (k > 0) { int parent = (k - 1) >>> 1; Object e = es[parent]; if (key.compareTo((T) e) >= 0) break; es[k] = e; k = parent; } es[k] = key; } \"]},\"1384\":{\"h\":\"LinkedTransferQueue\"},\"1385\":{\"h\":\"DelayQueue\"},\"1386\":{\"h\":\"如何选择合适的阻塞队列\",\"t\":[\"通常我们可以从以下5个角度考虑，来选择合适的阻塞队列：\",\"功能：首先需要考虑的就是功能层面，比如是否需要阻塞队列帮我们排序，如优先级队列、延迟执行等。如果有这个需要，我们就必须选择类似于PriorityBlockingQueue之类的有序排序能力的阻塞队列\",\"容量：其次要 考虑的是容量，或者说是否有存储的要求，还是只需要“直接传递”。在考虑这一点的时候，我们知道前面介绍的那几种阻塞队列，有的是容量固定的，如ArrayBlockingQueue；有的默认是容量无限的，如LinkedBlockingQueue；而有的里面没有任何容量，如SynchronousQueue；而对于DelayQueue而言，它的容量固定就是Integer.MAX_VALUE。所以不同阻塞队列的容量是千差万别的，我们需要根据任务数量来推算出合适的容量，从而去选择合适的BlockingQueue\",\"能否扩容：接着要考虑的就是能否扩容，因为有时我们并不能在出事的时候很好的准确估计队列的大小，因为业务可能有高峰期、低谷期。如果一开始就固定一个容量，可能无法应对所有的情况，也是不合适的，有可能需要动态扩容。如果我们需要动态扩容的话，那么就不能选择ArrrayBlockingQueue，因为它的容量在创建时就确定了，无法扩容。相反，PriorityBlockingQueue即使在指定了初始容量之后，后续如果有需要，也可以自动扩容。所以我们可以根据是否需要扩容来选择合适的队列\",\"内存结构：相对使用数组实现的阻塞队列，使用链表实现需要额外的“节点”，因此空间利用率更高\",\"性能：最后一点是从性能的角度去考虑，比如LinkedBlockingQueue，由于拥有两把锁，它的操作力度更细，在并发程度高的时候，相对于只有一把锁的ArrayBlockingQueue性能会更好。另外，SynchronousQueue性能往往优于其他实现，因为它只需要“直接传递”，而不需要存储过程。如果我们的场景需要直接传递的话，可以优先考虑SynchronousQueue\"]},\"1387\":{\"h\":\"ForkJoin实现原理\",\"t\":[\"任务类型：\",\"CPU密集型任务\",\"IO密集型任务\",\"CPU密集型任务也叫计算密集型任务，比如加密、解密、压缩、计算等一系列需要大量耗费CPU资源的任务。对于这样的任务最佳的线程数为CPU核心数的1～2倍，如果设置过多的线程数，实际上并不会起到很好的效果。此时假设我们设置的线程数量是CPU核心数的2倍以上，因为计算任务非常重，会占用大量的CPU资源，所以这时CPU的每个核心工作基本都是满负荷的，而我们又设置了过多的线程，每个线程都想去利用CPU资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。\",\"IO密集型任务，比如数据库、文件的读写，网络通信等任务，这种任务的特点是并不会特别消耗CPU资源，但是IO操作很耗时，总体会占用比较多的时间。对于这种任务最大线程数一般会大于CPU核心数很多倍，因为IO读写速度相比于CPU的速度是比较慢的，如果我们设置过少的线程数，就可能导致CPU资源的浪费。而如果我们设置更多的线程数，那么当一部分线程正在等待IO的时候，它们此时并不需要CPU来计算，那么另外的线程边可以利用CPU去执行其他的任务，互不影响，这样的话在工作队列中等待的任务就会减少，可以更好地利用资源。\",\"线程数计算方法：线程数=CPU核心线程数∗（1+平均等待时间/平均工作时间）。\",\"这个公式的含义是，如果任务的平均等待时间长，线程数就随之增加，而如果平均工作时间长，也就是对于CPU密集型任务，线程数就随之减少。\",\"太少的线程数会使得程序整体性能降低，而过多的线程的也会消耗内存等其他资源。\",\"ForkJoin的基本思想是分治：\",\"分解：将要解决的问题划分为若干规模较小的同类问题\",\"求解：当子问题划分得足够小时，用较简单的方法解决\",\"合并：按原问题的要求，将子问题的解逐层合并构成原问题的解\",\"传统线程池ThreadPoolExecutor有两个明显的缺点：一是无法对大任务进行拆分，对于某些任务只能单线程执行；二是工作线程从队列中获取任务时存在竞争情况。这两个缺点都会影响任务的执行效率。为了解决传统线程池的缺陷，Java7中引入了Fork/Join框架，并在Java8中得到广泛应用。Fork/Join框架的核心是ForkJoinPool类，它是对AbstractExecutorService类的扩展。ForkJoinPool允许其他线程向它提交任务，并根据设定将这些任务拆分为粒度更细的子任务，这些子任务将由ForkJoinPool内部的工作线程来并行执行，并且工作线程之间可以窃取彼此之间的任务。\",\"ForkJoinPool最适合计算密集型任务，而且最好是非阻塞任务。ForkJoinPool是ThreadPoolExecutor线程池的一种补充，是对计算密集型场景的加强。\",\"根据经验和实验，任务总数，单任务执行耗时以及并行数都会影响到Fork/Join的性能。所以，当使用Fork/Join框架时，需要谨慎评估这三个指标，最好能通过模拟对比评估，不要冒然在生产环境中使用。\",\"ForkJoinPool中有四个核心参数，用于控制线程池的并行数、工作线程的创建、异常处理和模式指定。各种参数解释如下：\",\"int parallelism：\",\"ForkJoinWorkerThreadFactory factory：\",\"UncaughtExceptionHandler handler：指定异常处理器，当任务在运行中出错时，将由设定的处理器处理\",\"boolean asyncMode：设置队列的工作模式：asyncMode？FIDO_QUEUE:LIFO_QUEUE。\",\"ForkJoinPool多个线程，每个线程维护一个队列workQueue。\"]},\"1388\":{\"h\":\"工作窃取\",\"t\":[\"ForkJoinPool与ThreadPoolExecutor有个很大的不同之处在于，ForkJoinPool引入了工作窃取设计，它是性能保证的关键之一。工作窃取，就是允许空闲线程从繁忙的双端队列中窃取任务。默认情况下，工作线程从它自己的双端队列的头部获取任务。但是，当自己的任务为空时，线程会从其他繁忙线程双端队列的尾部中获取任务。这种方法，最大限度地减少了线程竞争任务的可能性。\"]},\"1389\":{\"h\":\"工作队列\"},\"1390\":{\"h\":\"ForkJoinWorkThread\",\"t\":[\"ForkJoinWorkThread是用于执行任务的线程，用于区别使用非ForkJoinWorkThread线程提交task，启动一个该Thread，会自动注册一个WorkQueue到Pool，拥有Thread的WorkQueue只能出现在WorkQueues[]的奇数位。\"]},\"1391\":{\"h\":\"原理分析\",\"t\":[\"ForkJoin是一种基于分治算法的模型，在并发处理计算型任务时有着显著的优势。其效率的提升主要得益于两个方面：\",\"任务切分：将大的任务分割为更小力度的小任务，让更多的线程参与执行\",\"任务窃取：通过任务窃取，充分地利用空闲线程，并减少竞争\"]},\"1392\":{\"h\":\"CompletableFuture实现原理\"},\"1393\":{\"h\":\"Future\",\"t\":[\"Future的局限性：\",\"并发执行多任务：Future只提供了get()方法来获取结果，并且是阻塞的。所以，除了等待没有其他方式\",\"无法对多个任务进行链式调用：如果希望在计算任务完成后执行特定动作，比如发邮件，但Future没有提供这样的能力\",\"无法组合多个任务：如果运行了10个任务，并期望它们全部执行结束后执行特定动作，那么在Future也没有办法做到\",\"没有异常处理：Future接口中没有关于异常处理的方法\"]},\"1394\":{\"h\":\"CompletionService\",\"t\":[\"CompletionService内部通过阻塞队列+FutureTask，实现了任务先完成可以优先获取到，即记过按照完成先后顺序排序，内部有一个先进先出的阻塞队列，用于保存已经执行完成的Future，通过调用它的take方法或poll方法可以获取到一个已经执行完成的Future，进而通过调用Future接口实现类的get方法获取最终的结果。\",\"使用场景：向不同的电商平台询价，并保存价格。\",\"假设我们采用线程池+Future的方案，异步执行询价然后再保存：\",\"// 创建线程池 ExecutorService executor = Executors.newFixedThreadPool(3); // 异步向电商S1询价 Future<Integer> f1 = executor.submit(()->getPriceByS1()); // 异步向电商S2询价 Future<Integer> f2= executor.submit(()->getPriceByS2()); // 获取电商S1报价并异步保存 executor.execute(()->save(f1.get())); // 获取电商S2报价并异步保存 executor.execute(()->save(f2.get()); \",\"如果获取电商s1报价的耗时很长，那么即便获取电商s2报价的耗时很短，也无法让保存s2报价的操作先执行，因为这个线程都阻塞在了f1.get()操作上。\",\"使用CompetionService实现先获取的报价先保存到数据库：\",\"//创建线程池 ExecutorService executor = Executors.newFixedThreadPool(10); //创建CompletionService CompletionService<Integer> cs = new ExecutorCompletionService<>(executor); //异步向电商S1询价 cs.submit(() -> getPriceByS1()); //异步向电商S2询价 cs.submit(() -> getPriceByS2()); //异步向电商S3询价 cs.submit(() -> getPriceByS3()); //将询价结果异步保存到数据库 for (int i = 0; i < 3; i++) { Integer r = cs.take().get(); executor.execute(() -> save(r)); } \",\"如果我们只需要最快的那一个结果，就可以：\",\"// 创建线程池 ExecutorService executor = Executors.newFixedThreadPool(3); // 创建CompletionService CompletionService<Integer> cs = new ExecutorCompletionService<>(executor); // 用于保存Future对象 List<Future<Integer>> futures = new ArrayList<>(3); //提交异步任务，并保存future到futures futures.add(cs.submit(()->geocoderByS1())); futures.add(cs.submit(()->geocoderByS2())); futures.add(cs.submit(()->geocoderByS3())); // 获取最快返回的任务执行结果 Integer r = 0; try { // 只要有一个成功返回，则break for (int i = 0; i < 3; ++i) { r = cs.take().get(); //简单地通过判空来检查是否成功返回 if (r != null) { break; } } } finally { //取消所有任务 for(Future<Integer> f : futures) f.cancel(true); } // 返回结果 \",\"Dubbo中有一种叫做Forking的集群模式，这种集群模式下，支持并行地调用度多个服务实例，只要有一个成功就返回结果。\",\"geocoder(addr) { //并行执行以下3个查询服务， r1=geocoderByS1(addr); r2=geocoderByS2(addr); r3=geocoderByS3(addr); //只要r1,r2,r3有一个返回 //则返回 return r1|r2|r3; } \",\"CompletionService的应用场景总结：\",\"当需要批量提交异步任务的时候建议使用CompletionService，CompletionService将线程池和阻塞队列BlockingQueue的功能融合在了一起，能够让批量异步任务的管理更简单\",\"CompletionService能够让异步任务的执行结果有序化。先执行完的先进入阻塞队列，利用这个特性，可以轻松实现后续处理的有序性\",\"线程池隔离：CompletionService支持自己创建线程池，这种隔离性能避免几个特别耗时的任务拖垮整个应用的风险。\"]},\"1395\":{\"h\":\"CompletableFuture\",\"t\":[\"简单的任务，用Future获取结果还好，但是并行提交多个异步任务，往往并不是独立的，很多时候业务逻辑处理存在串行[依赖]、并行、聚合的关系。如果要我们手动用Future实现，是非常麻烦的。\",\"CompletableFuture是Future接口的扩展和增强。CompletableFuture实现了Future接口，并在此基础上进行了丰富地扩展，完美地弥补了Future上述的种种问题，更为重要的是，CompletableFuture实现了对任务的编排能力。借助这项能力，我们可以轻松地组织不同任务的运行顺序、规则以及方式。从某种程度上说，这项能力是它的核心能力。而在以往，虽然通过CountDownLatch等工具类也可以实现任务的编排，但需要复杂的逻辑处理，不仅耗费精力且难以维护。\",\"CompletionStage接口：执行某一个阶段，可向下执行后续阶段。异步执行，默认线程池是ForkJoinPool.commonPool()。\",\"应用场景：\",\"描述依赖关系\",\"thenApply()：把前面异步任务的结果，交给后面的Function\",\"thenCompose()：用来连接两个有依赖关系的任务，结果由第二个任务返回\",\"描述and聚合关系\",\"thenCombine：任务合并，有返回值\",\"thenAcceptBoth：两个任务执行完成后，将结果交给thenAcceptBoth消耗，无返回值\",\"runAfterBothEither：两个任务都执行完成后，执行下一步操作（Runnable）\",\"描述or聚合关系\",\"applyToEither：两个任务谁执行的快，就使用那一个结果，有返回值\",\"acceptEither：两个任务谁执行的快，就消耗那一个结果，无返回值\",\"runAfterEither：任意一个任务执行完成，进行下一步操作\",\"并行执行\",\"CompletableFuture类自己也提供了anyOf()和allOf用于支持多个CompletableFuture并行执行\",\"常用方法总结：\"]},\"1396\":{\"h\":\"高性能队列Disruptor\",\"t\":[\"Disruptor是一个高性能的队列，研发的初衷是为了解决内存队列的延迟问题，基于Disruptor开发的系统但线程能支撑每秒600万订单。目前Apache Storm、Camel、Log4j在内的很多知名项目都应用了Disruptor以获取高性能。注意，这里所说的队列是系统内存的内存队列，而不是Kafka这样的分布式队列。\",\"Disruptor本质上是一个有界队列，可以用于生产者-消费者模型。\",\"JUC下的队列大部分采用ReentrantLock锁的方式保证线程安全。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列。加锁的方式通常会严重影响性能，线程会因为竞争不到锁而被挂起，等待其他线程释放锁而唤醒，这个过程存在很大的开销，而且存在死锁的隐患。有界队列通常采用数组实现，但是采用数组实现引发另外一个问题false sharing（伪共享）。\",\"CPU缓存是以缓存行为最小数据单位，缓存行是2的整数幂个连续字节，主流大小是64个字节。如果多个变量同属于一个缓存行，在并发环境下同时修改，因为写屏障即内存一致性协议会导致同一时间只能一个线程操作该缓存行，进而因为竞争导致性能下降，这就是“伪共享”。“伪共享”是高并发场景下一个底层细节问题。\",\"Disruptor通过以下设计来解决队列速度慢的问题：\",\"环形数组结构\",\"为了避免垃圾回收，采用数组而非链表。同时，数组对于处理器的缓存机制更加友好（空间局部性原理）\",\"元素位置定位\",\"数组长度2n，通过位运算，加速定位的速度，下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完\",\"无锁设计\",\"每个生产者或消费者线程，会先申请可以操作的元素在数组中的问题，申请到之后，直接在该位置写入或者读取数据\",\"利用缓存行填充解决伪共享的问题\",\"实现了基于事件驱动的生产者消费者模型（观察者模式）\",\"消费者时刻关注着队列里有没有消息，一旦有新消息产生，消费者线程就会立刻消费。\"]},\"1397\":{\"h\":\"RingBuffer\",\"t\":[\"使用RingBuffer来作为队列的数据结构，RingBuffer就是一个可自定义大小的环形数组。除数组之外还有一个序列号（sequence），用以指向下一个可用的元素，供生产者与消费者使用，原理图如下所示：\",\"当需要覆盖数据时，会执行一个策略，Disruptor会提供多种策略，比较常用的有：\",\"BlockingWaitStrategy策略，常见且默认的等待测了，当这个队列满了，不执行覆盖，而是阻塞等待。使用ReentrantLock+Condition实现阻塞，最节省CPU，但高并发场景下性能最差。适合CPU资源紧缺，吞吐量和延迟并不重要的场景\",\"SleepingWaitStrategy策略，会在循环中不断等待数据。先进行自旋等待，如果不成功，则使用Thread.yield()并让出CPU，并最终使用LockSupport.parkNanos(1L)进行线程休眠，以确保不占用太多的CPU资源。因此这个策略会产生比较高的平均延时。典型的应用场景就是异步日志\",\"YieldingWaitStrategy策略，这个策略用于低延时的场合。消费者线程会不断地监控缓冲区变化，在循环内部使用Thread.yield()让出CPU给别的线程执行时间。如果需要一个高性能的系统，并且对延时有比较严格的要求，可以考虑这种策略。\",\"BusySpinWaitStrategy策略，采用死循环，消费者线程会尽最大努力监控缓冲区的变化。适用于对延时要求非常苛刻的场景，CPU核数大于消费者线程数量。推荐在线程绑定到固定的CPU的场景下使用\",\"Disruptor的核心概念：\",\"Disruptor的构造方法：\",\"public Disruptor( final EventFactory<T> eventFactory, final int ringBufferSize, final ThreadFactory threadFactory, final ProducerType producerType, final WaitStrategy WaitStrategy } \",\"EventFactory：创建事件（任务）的工厂类\",\"ringBufferSize：容器的长度\",\"ThreadFatory：用于创建执行任务的线程\",\"ProductType：生产者类型：单生产者、多生产者\",\"WaitStrategy：等待策略\"]},\"1398\":{\"h\":\"Disruptor实战\",\"t\":[\"使用案例：\",\"public class DisruptorDemo { public static void main(String[] args) throws Exception { //创建disruptor Disruptor<OrderEvent> disruptor = new Disruptor<>( OrderEvent::new, 1024 * 1024, Executors.defaultThreadFactory(), ProducerType.SINGLE, //单生产者 new YieldingWaitStrategy() //等待策略 ); //设置消费者用于处理RingBuffer的事件 disruptor.handleEventsWith(new OrderEventHandler()); //设置多消费者,消息会被重复消费 //disruptor.handleEventsWith(new OrderEventHandler(),new OrderEventHandler()); //设置多消费者,消费者要实现WorkHandler接口，一条消息只会被一个消费者消费 //disruptor.handleEventsWithWorkerPool(new OrderEventHandler(), new OrderEventHandler()); //启动disruptor disruptor.start(); //创建ringbuffer容器 RingBuffer<OrderEvent> ringBuffer = disruptor.getRingBuffer(); //创建生产者 OrderEventProducer eventProducer = new OrderEventProducer(ringBuffer); // 发送消息 for(int i=0;i<100;i++){ eventProducer.onData(i,\\\"Fox\\\"+i); } disruptor.shutdown(); } } \"]},\"1399\":{\"h\":\"并发设计模式\"},\"1400\":{\"h\":\"终止线程模式\"},\"1401\":{\"h\":\"两阶段终止模式\",\"t\":[\"两阶段终止模式，将终止过程分成两个阶段，其中第一个阶段主要是线程T1向线程T2发送终止指令，而第二阶段则是线程T2响应终止指令。\",\"Java线程进入终止状态的前提是线程进入RUNNABLE状态，而利用java线程中断机制的interrupt()方法，可以让线程从休眠状态转换到RUNNABLE状态。RUNNABLE状态转换到终止状态，优雅的方式是让Java线程自己执行完run()方法，所以一般我们采用的方法是设置一个标志位，然后线程会在合适的时机检查这个标志位，如果发现符合终止条件，则自动退出run()方法。\",\"两阶段终止模式是一种应用很广泛的并发设计模式，在Java语言中使用两阶段终止模式来优雅地终止线程，需要注意两个关键点：一个是仅检查终止标志位是不够的，因为线程的状态可能处于休眠态；另一个是仅检查线程的中断状态也是不够的，因为我们依赖的第三方库很可能没有正确处理中断一场，例如第三方库在捕获到Thread.sleep()方法抛出的中断异常后，没有重新设置线程的中断状态，那么就会导致线程不能够正常终止。所以我们可以自定义线程的终止标志位用于终止线程。\"]},\"1402\":{\"h\":\"避免共享的设计模式\"},\"1403\":{\"h\":\"Immutability模式\",\"t\":[\"Immutability模式即不变性模式，“多个线程同时读写同一共享变量存在并发问题”，这里的必要条件之一是读写，如果只有读，而没有写，是没有并发问题的。解决并发问题，其实最简单的办法是让共享变量只有读操作，而没有写操作，这种解决并发问题的设计模式被称为不变性模式。所谓不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化。换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。\",\"JDK中很多类都具备不变性，例如常用的String、Long、Integer和Double等基础类型的包装类都具备不可变性，这些对象的线程安全性都是靠不可变性来保证的。它们都严格遵守了不可变类的三点要求：类和属性都是final的，所有方法均是只读的。\",\"在使用不变性模式的时候，需要注意以下两点：\",\"对象的所有属性都是final的，并不能保证不可变性\",\"不可变对象也需要正确发布\",\"在使用不可变性模式的时候一定要确认保持不变性的边界在哪里，是否要求属性对象也具备不可变性。\",\"下面的代码中，Bar的属性foo虽然是final的，但是依然可以通过setAge()方法来设置foo的属性age。\",\"class Foo { int age=0; int name=\\\"abc\\\"; } final class Bar { final Foo foo; void setAge(int a){ foo.age=a; } \",\"可变对象虽然是线程安全的，但是并不意味着引用这些不可变对象的对象就是线程安全的。下面的代码中，Foo具备不可变性，线程安全，但是类Bar并不是线程安全的，类Bar中持有对Foo的引用foo，对foo这个引用的修改在多线程中并不能保证可见性和原子性。\",\"//Foo线程安全 final class Foo { final int age=0; final String name=\\\"abc\\\"; } //Bar线程不安全 class Bar { Foo foo; void setFoo(Foo f){ this.foo=f; } } \"]},\"1404\":{\"h\":\"Copy-on-Write模式\",\"t\":[\"写时复制模式。Java中的String在实现replace()方法的时候，并没有更改原字符串里面value[]数组的内容，而是创建了一个新字符串，这种方法在解决不可变对象的修改问题时经常用到。它本质上是一种Copy-on-Write方法。所谓Copy-on-Write，经常被缩写为COW，或者CoW。\",\"Copy-on-Write缺点就是消耗内存，每次修改都需要复制一个新的对象出来，好在随着自动垃圾回收（GC）算法的成熟以及硬件的发展，这种内存消耗已经渐渐可以接受了。所以在实际工作中，如果写操作非常少（读多写少的场景），可以尝试使用Copy-on-Write。\",\"在Java中，CopyOnWriteArrayList和CopyOnWriteArraySet这两个Copy-on-Write容器，它们背后的设计思想就是Copy-on-Write，通过Copy-on-Write这两个容器实现读操作是无锁的，由于无锁，所以将读操作的性能发挥到了极致。\",\"Copy-on-Write在操作系统领域中也有广泛的应用。类Unix的操作系统中创建进行的API是fork()，传统的fork()函数会创建父进程的一个完整副本，例如父进程的地址空间用到了1G的内存，那么fork()子进程的时候要复制父进程整个进程的地址空间（占有1G内存）给子进程，这个过程是很耗时的。而Linux中fork()子进程的时候，并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间；只有在父进程或者子进程需要写入的时候才会复制地址空间，从而使父子进程拥有各自的地址空间。\",\"Copy-on-Write最大的应用领域还是在函数式编程领域。函数式编程的基础是不可变性，所以函数式编程的所有的修改操作都需要Copy-on-Write来解决。\",\"像一些RPC框架还有服务注册中心，也会利用Copy-on-Write设计思想维护服务路由表。路由表是典型的读多写少，而且路由表对数据的一致性要求并不高，一个服务提供方从上线到反馈到客户端的路由表里，即便有5秒钟延迟，很多时候也是能够接受的。\"]},\"1405\":{\"h\":\"Thread-Specific Storage模式\",\"t\":[\"线程本地存储模式，即只有一个入口，也会在内部为每个线程分配持有的存储空间的模式。在Java中，ThreadLocal类实现了该模式。\",\"线程本地存储模式本质上就是一种避免共享的方法，由于没有共享，所以自然也就没有并发问题。如果需要在并发场景中使用一个线程不安全的工具类，最简单的方案就是避免共享。避免共享有两种方案，一种方案是将这个工具类作为局部变量使用，另外一种方案就是线程本地存储模式。这两种方案，局部变量方案的缺点是在高并发场景下会频繁创建对象，而线程本地存储方案，每个线程只需要创建一个工具类的实例，所以不存在频繁创建对象的问题。\",\"static class SafeDateFormat { //定义ThreadLocal变量 static final ThreadLocal<DateFormat> tl=ThreadLocal.withInitial( ()-> new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\")); static DateFormat get(){ return tl.get(); } } //不同线程执行下面代码，返回的df是不同的 DateFormat df = SafeDateFormat.get()； // 注意：在线程池中使用ThreadLocal 需要避免内存泄漏和线程安全的问题 ExecutorService es; ThreadLocal tl; es.execute(()->{ //ThreadLocal增加变量 tl.set(obj); try { // 省略业务逻辑代码 } finally { //手动清理ThreadLocal tl.remove(); } }); \"]},\"1406\":{\"h\":\"多线程版本的if模式\"},\"1407\":{\"h\":\"Guarded Suspension模式\",\"t\":[\"保护性暂停模式，是通过让线程等待来保护实例的安全性，即守护-挂起模式。在多线程开发中，常常为了提高应用程序的并发性，会将一个任务分解为多个子任务交给多分线程并行执行，而多个线程之间相互协作时，仍然会存在一个线程需要等待另外的线程完成后继续下一步操作。而保护性暂停模式可以帮助我们解决上述的等待问题。\",\"Guarded Suspension模式允许多个线程对实例资源进行访问，但是实例资源需要对资源的分配做出管理。\",\"Guarded Suspension模式也常被称为Guarded Wait模式、Spin Lock模式（因为使用了while循环去等待），也被称为多线程版本的if。\",\"有一个结果需要从一个线程传递到另一个线程，让它们关联同一个GuardedObject\",\"如果有结果不断从一个线程到另一个线程那么可以使用消息队列\",\"JDK中，join实现，Future的实现，采用的就是此模式\",\"等待唤醒机制规范实现，此模式依赖于Java线程的阻塞唤醒机制 \",\"sychronized+wait/notify/notifyAll\",\"ReentrantLock+Condition（await/singal/singalAll）\",\"cas+park/unpark\",\"阻塞唤醒机制机制底层原理：在linux操作系统中，pthread_mutex_lock/unlock，pthread_cond_wait/singal。\",\"解决线程之间的协作不可避免会用到阻塞唤醒机制。\"]},\"1408\":{\"h\":\"Balking模式\",\"t\":[\"Balking是“退缩不前”的意思。如果现在不适合执行这个操作，或者没必要执行这个操作，就停止处理，直接返回。当流程的执行顺序依赖于某个共享变量的场景，可以归纳为多线程if模式。Balking模式常用于一个线程发现另一个线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回。\",\"Balking模式一种多个线程执行同一操作A时可以考虑的模式；在某一个线程B被阻塞或者执行其他操作时，其他线程同样可以完成操作A，而当线程B恢复执行或者执行操作A时，因A已被执行，而无需线程B再执行，从而提高了B的执行效率。\",\"Balking模式和Guard Suspension模式一样，存在守护条件，如果守护条件不满足，则中断处理；这与Guard Suspension模式不同，Guard Suspension模式在守护条件不满足的时候会一直等待至可以运行，\",\"boolean changed=false; // 自动存盘操作 void autoSave(){ synchronized(this){ if (!changed) { return; } changed = false; } // 执行存盘操作 // 省略且实现 this.execSave(); } // 编辑操作 void edit(){ // 省略编辑逻辑 ...... change(); } // 改变状态 void change(){ synchronized(this){ changed = true; } } Balking 模式有一个非常典型的应用场景就是单次初始化。 boolean inited = false; synchronized void init(){ if(inited){ return; } //省略doInit的实现 doInit(); inited=true; } \"]},\"1409\":{\"h\":\"多线程分工模式\"},\"1410\":{\"h\":\"Thread-Per-Message模式\",\"t\":[\"一个线程处理一个任务，Thread-Per-Message 模式的一个最经典的应用场景是网络编程里服务端的实现，服务端为每个客户端请求创建一个独立的线程，当线程处理完请求后，自动销毁，这是一种最简单的并发处理网络请求的方法。\",\"final ServerSocketChannel ssc= ServerSocketChannel.open().bind(new InetSocketAddress(8080)); //处理请求 try { while (true) { // 接收请求 SocketChannel sc = ssc.accept(); // 每个请求都创建一个线程 new Thread(()->{ try { // 读Socket ByteBuffer rb = ByteBuffer.allocateDirect(1024); sc.read(rb); //模拟处理请求 Thread.sleep(2000); // 写Socket ByteBuffer wb = (ByteBuffer)rb.flip(); sc.write(wb); // 关闭Socket sc.close(); }catch(Exception e){ throw new UncheckedIOException(e); } }).start(); } } finally { ssc.close(); } \",\"Thread-Per-Message模式作为一种最简单的分工方案，Java中使用会存在性能缺陷。在Java中的线程是一个重量级的对象，创建成本很高，一方面创建线程比较耗时，另一方面线程占用的内存也比较大。所以为每个请求创建一个新的线程并不适合高并发场景。为了解决这个缺点，Java并发包里提供了线程池等工具类。\",\"在其他编程语言里，例如Go语言，基于轻量级线程实现Thread-Per-Message模式就完全没有问题。\",\"对于一些并发度没那么高的异步场景，例如定时任务，采用Thread-Per-Message模式是完全没有问题的。\"]},\"1411\":{\"h\":\"Worker Thread模式\",\"t\":[\"线程工厂模式，能避免线程频繁创建、销毁的问题，而且能够限制线程的最大数量。Java语言中可以直接使用线程池来实现Worker Thread模式。\",\"ExecutorService es = Executors.newFixedThreadPool(200); final ServerSocketChannel ssc = ServerSocketChannel.open().bind(new InetSocketAddress(8080)); //处理请求 try { while (true) { // 接收请求 SocketChannel sc = ssc.accept(); // 将请求处理任务提交给线程池 es.execute(()->{ try { // 读Socket ByteBuffer rb = ByteBuffer.allocateDirect(1024); sc.read(rb); //模拟处理请求 Thread.sleep(2000); // 写Socket ByteBuffer wb = (ByteBuffer)rb.flip(); sc.write(wb); // 关闭Socket sc.close(); }catch(Exception e){ throw new UncheckedIOException(e); } }); } } finally { ssc.close(); es.shutdown(); } \"]},\"1412\":{\"h\":\"生产者-消费者模式\",\"t\":[\"生产者-消费者模式的核心是一个任务队列，生产者线程生产任务，并将任务添加到任务队列中，而消费者线程从任务队列中获取任务并执行。\",\"public class Test { public static void main(String[] args) { // 生产者线程池 ExecutorService producerThreads = Executors.newFixedThreadPool(3); // 消费者线程池 ExecutorService consumerThreads = Executors.newFixedThreadPool(2); // 任务队列，长度为10 ArrayBlockingQueue<Task> taskQueue = new ArrayBlockingQueue<Task>(10); // 生产者提交任务 producerThreads.submit(() -> { try { taskQueue.put(new Task(\\\"任务\\\")); } catch (InterruptedException e) { e.printStackTrace(); } }); // 消费者处理任务 consumerThreads.submit(() -> { try { Task task = taskQueue.take(); } catch (InterruptedException e) { e.printStackTrace(); } }); } static class Task { // 任务名称 private String taskName; public Task(String taskName) { this.taskName = taskName; } } } \"]},\"1413\":{\"h\":\"过饱问题解决方案\",\"t\":[\"在实际生产项目中会有些极端的情况，导致生产者/消费者模式可能出现过饱的问题。单位时间内，生产者生产的速度大于消费者消费的速度，导致任务不断堆积到阻塞队列中，队列堆满只是时间问题。\",\"场景一：消费者每天能处理的量比生产者生产的少；如生产者每天1万条，消费者每天只能消费5千条。\",\"解决办法：消费者加机器\",\"原因：生产者没法限流，因为要一天内处理完，只能消费者加机器\",\"场景二：消费者每天能处理的量比生产者生产的多。系统高峰期生产者速度太快，把队列塞爆了\",\"解决办法：适当的加大队列\",\"原因：消费者一天的消费能力已经高于生产者，那说明一天之内肯定能处理完，保证高峰期别把队列塞满就好\",\"场景三：消费者每天能处理的量比生产者生产的多。条件有限或其他原因，队列没法设置特别大。系统高峰期生产者速度太快，把队列塞爆了\",\"解决办法：生产者限流\",\"原因：消费者一天的消费能力高于生产者，说明一天内能处理完，队列又太小，那只能限流生产者，让高峰期塞队列的速度慢点\"]},\"1414\":{\"h\":\"集合\"},\"1415\":{\"h\":\"集合的优点\",\"t\":[\"数组的缺点：\",\"长度开始时必须指定，而且一旦指定，不能更改\",\"保存的必须为同一类型的元素\",\"使用数组进行增加元素、删除元素、插入元素等相对复杂\",\"使用集合的好处：\",\"可以动态保存任意多个对象，使用比较方法\",\"提供了一系列方便操作对象的方法：add、remove、set、get等\",\"在Java中，集合主要分为两大类：单例集合和多列集合，其中单例集合有List、Set，双列集合有Map。\"]},\"1416\":{\"h\":\"单列集合\",\"t\":[\"核心API - java.util.List\",\"java.util.ArrayList\",\"java.util.Vector（线程安全）\",\"java.util.LinkedList\",\"核心API - java.util.Set\",\"java.util.HashSet\",\"java.util.TreeSet\"]},\"1417\":{\"h\":\"多列集合\",\"t\":[\"核心API - java.util.Map\",\"java.util.Hashtable\",\"java.util.HashMap\",\"java.util.TreeMap\"]},\"1418\":{\"h\":\"List\"},\"1419\":{\"h\":\"ArrayList源码分析\",\"t\":[\"核心特点：\",\"ArrayList中维护了一个Object类型的数组elementData：\",\"transient Object[] elementData; // non-private to simplify nested class access \",\"当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5倍\",\"如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍\",\"transient表示该属性不会被序列化。\"]},\"1420\":{\"h\":\"LinkedList源码分析\"},\"1421\":{\"h\":\"Map\",\"t\":[\"Map接口的不同实现之间的关系：\",\"具体实现类特点的说明：\",\"HashMap：它根据键的hashCode值缓存数据，大多数情况下可以直接定位它的值，因而具有很快的访问速度，但是遍历顺序却是不确定的。HashMap最多只允许一条记录的键位null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致，如果需要满足线程安全，可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap\",\"Hashtable：Hashtable是历史遗留类，官方建议使用HashMap替代它，与HashMap不同的是，它继承自Dictionary类，并且是线程安全的，如果需要在线程安全的场合下使用，建议使用ConcurrentHashMap\",\"LinkedHashMap：LinkedHashMap保存了记录的插入顺序，可以按照插入的顺序使用Iterator遍历\",\"TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排列，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap，在使用TreeMao的时候，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常\",\"对于上述四种类型的类，要求映射种的key是不可变对象。不可变对象可以保证该对象在创建后它的哈希值不会被改变，如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。\"]},\"1422\":{\"h\":\"HashMap原理分析\",\"t\":[\"HashMap是Java程序员使用频率最高的用于映射（键值对）处理的数据类型。JDK1.8对HashMap底层的实现进行了优化，例如引入了红黑树的数据结构和扩容优化等，因此，分析HashMap需要注意区别JDK1.7和JDK1.8的区别。\"]},\"1423\":{\"h\":\"存储方式\",\"t\":[\"从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加红黑树部分）实现的，如下图所示：\",\"在HashMap的底层存储实现上是存储在：\",\" transient Node<K,V>[] table; \",\"其中Node具体如下：\",\"static class Node<K,V> implements Map.Entry<K,V> { final int hash; //用来定位数组索引位置 final K key; V value; Node<K,V> next; //链表的下一个node Node(int hash, K key, V value, Node<K,V> next) { ... } public final K getKey(){ ... } public final V getValue() { ... } public final String toString() { ... } public final int hashCode() { ... } public final V setValue(V newValue) { ... } public final boolean equals(Object o) { ... } } \",\"Node是HashMap的一个内部类，实现了Map.Enrty接口，本质就是一个映射（键值对）。上图中每个黑色圆点就是一个Node对象。\",\"HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，HashMap就是采用了链地址法，即数组加链表的方式，在每个数组元素上都加上一个链表结构，当数据被Hash后，得到数组下标，把数据房子啊对应下标元素的链表上，例如程序执行如下代码：\",\"map.put(\\\"jycoder\\\",\\\"吉永超\\\"); \",\"系统将调用“jycoder”这个key的hashCode方法得到其哈希值，然后通过哈希算法的后两步运算（高位运算和取模运算）来定位该键值对的存储位置，有时两个key会定位到相同的问题，这个时候就发生了哈希碰撞。对于哈希算法而言，计算的结果越分散，哈希碰撞的概率就越小，Map的存取效率就会越高。\",\"如果哈希桶的数组很大，即使较差的哈希算法也会比较分散，如果哈希桶的数组很小，即使再好的哈希算法也会出现较多碰撞，所以就需要根据实际情况确定哈希桶数组的大小，并且在此基础上设计好的哈希算法来减少哈希碰撞。\",\"HashMap中有几个非常重要的属性：\",\"int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子 int modCount; // HashMap内部结构发生变化的次数 int size; // HashMap中实际存在的键值对数量 \",\"其中，Node[] table的初始长度length默认值是16，负载因子loadFactor默认值是0.75，threshold是HashMap所能容纳的最大数量的Node（键值对）的个数。它们之间的关系是：threshold=length∗loadFactor，也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数就越多。\",\"当超过threshold所能容纳的数量，HashMap就需要重新resize（扩容），扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的平衡选择，一般不要轻易修改，如果内存很多而又对时间效率要求很高，可以降低负载因子loadFactor的值；相反，如果内存紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。\",\"size这个字段的含义就是HashMap中实际存在的键值对数量，而modCount主要记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。这里的内部结构发生变化指的是强调的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖步属于结构变化。\",\"在HashMap中，哈希桶数组table的长度length大小必须为2n，HashMap采用这种设计，主要是为了取模和扩容时做优化，同时为了减少冲突，具体可以参考：关于hashMap的容量为什么是2的幂次方。定位哈希桶索引位置时，也加入例如高位参与运算的过程。\",\"不过，即使负载因子和哈希算法设计的再合理，也避免不了拉链过长的情况，一旦拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8中，对数据结构做了进一步的优化，引入了红黑树，当链表长度太长（默认超过8）时，链表就转换为了红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会运用到红黑树的插入、删除、查找等算法。具体可以参考红黑树。\"]},\"1424\":{\"h\":\"方法实现\"},\"1425\":{\"h\":\"确定哈希桶数组索引位置\",\"t\":[\"不管增加、删除、查找键值对，定位到哈希桶数组的都是很关键的第一步，前面提到过HashMap的数据结构是数组和链表的结合， 如果每个位置上的元素数量只有一个，那么当我们使用哈希算法求得这个位置的时候，马上就可以获取对应位置的元素，而不需要遍历整个链表。HashMap定位数组索引位置的方法，直接决定了哈希方法的离散性能，源码的实现如下：\",\"// 方法一 static final int hash(Object key) { //jdk1.8 & jdk1.7 int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h >>> 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } // 方法二 static int indexFor(int h, int length) { //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 return h & (length - 1); //第三步 取模运算，JDK1.8在计算位置的时候采用方法一返回的哈希值 & 长度-1 } \",\"可以发现，在JDK1.8中，哈希算法基本步骤就是三步：取key的hashCode值、高位运算、取模运算。\",\"对于任意给定的对象，只要它的hashCode方法返回值相同，那么程序调用方法所计算得到的Hash码值总是相同的。其中一种方式对将哈希值对数组长度取模运算，这样做的好处是元素的分布会相对来说比较均匀，但是，模运算的消耗还是比较大的。在HashMap中会调用方法二来计算对象应该保存在table数组的哪个索引处。\",\"这个方法非常巧妙，它通过h&(table.length-1)来得到该对象的保存位，而HashMap的长度length总是为2n，此时，h&(table.length-1)与h%length这两种运算结果式等价的，但是&比%具有更高的效率。\",\"假设容量为2的n次幂的化，那么table.length的二进制就是一个1后面n个0，而length - 1就是一个0后面n个1，那么在计算为了说明h & (table.length - 1)，由于length - 1的二进制前面都是0，相当于舍弃了高位，只保留了后面的n位，后面的n刚好在0到length之间，也就是等于h % length取余。\",\"在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高位异或低16位实现的：(h = k.hashcode())^(h >>> 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。\",\"下面举例说明，n位table的长度：\"]},\"1426\":{\"h\":\"put方法\",\"t\":[\"put方法的整体执行过程如下图：\",\"JDK1.8put方法的源代码如下：\",\" public V put(K key, V value) { // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node<K,V>[] tab; Node<K,V> p; int n, i; // 步骤1：table位空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 步骤2：计算index，并对null做处理 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node<K,V> e; K k; // 步骤3：节点key存在，直接value if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; // 步骤4：判断该链表为红黑树 else if (p instanceof TreeNode) e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); // 步骤5：该链为链表 else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 链表长度大于8转换为红黑树进行处理 if (binCount >= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; } // key已经存在直接覆盖value if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 步骤6：超过最大容量就扩容 if (++size > threshold) resize(); afterNodeInsertion(evict); return null; } \",\"详细说明如下：\",\"判断键值对数组table[i]是否为空或者为null，否则执行resize()进行扩容\",\"根据键值key计算hash值得到插入元素数组的索引i，如果table[i] == null，直接新建节点添加，转向步骤6，否则转向步骤3\",\"判断table[i]的首个元素是否和key一样，如果相同（hashCode && equals）直接覆盖value，否则转向步骤4\",\"判断table[i]是否为treeNode，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向步骤5\",\"遍历table[i]，判断链表的长度是否大于8，大于8的话就把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作，遍历过程中若发现key已经存在直接覆盖value即可\",\"插入成功后，判断实际存在的键值对数量size是否超过了最大容量，如果超过，就进行扩容操作\"]},\"1427\":{\"h\":\"扩容机制\",\"t\":[\"扩容就是重新计算容量。在向HashMap对象中不断地添加元素，而HashMap对象内部地数组无法装在更多地元素时，对象就需要扩大数组的长度，以便能装入更多的元素。\",\"JDK1.7中的扩容过程：\",\" void resize(int newCapacity) { //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; } Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 } \",\"newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上的新元素总会被放在链表的头部位置，这样先放一个索引上的元素会被放到Entry链的尾部（如果发生了哈希冲突的话），在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。\",\"下面通过具体的例子来说明扩容过程。假设我们所使用的哈希算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size等于2，所以key3、5、7，put顺序依次为5、7、3/在mod 2以后冲突都在table[1]这里了。这里假设负载因子loadFactor=1，即当键值对的实际大小size大于table的实际大小时进行扩容。接下来三个步骤时哈希桶数组resize成4，然后所有的Node重新rehash的过程。\",\"在JDK1.8中，由于融入了红黑树，相对而言就比较复杂：\",\" final Node<K,V>[] resize() { Node<K,V>[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { // 超过最大值就不再扩充 if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) newThr = oldThr << 1; // double threshold } else if (oldThr > 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 计算新的resize上限 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\\\"rawtypes\\\",\\\"unchecked\\\"}) Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; table = newTab; if (oldTab != null) { // 把每个bucket都移动到新的buckets中 for (int j = 0; j < oldCap; ++j) { Node<K,V> e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash & (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode<K,V>)e).split(this, newTab, j, oldCap); else { // 链表优化重hash的代码块 Node<K,V> loHead = null, loTail = null; Node<K,V> hiHead = null, hiTail = null; Node<K,V> next; do { next = e.next; // 原索引 if ((e.hash & oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } // 原索引 + oldCap else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } // 原索引 + oldCap放到bucket里 if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } \",\"JDK1.8中对扩容做了一些优化，经过观察可以发现，我们每次扩容都会将长度扩容为原来的2倍，所以，元素的位置要么是在原来的位置，要么就是在原位置再移动2次幂的位置。在下图中，n为table的长度，图（a）表示扩容前key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算的结果。\",\"元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit（红色），因此新的index就会发生这样的变化：\",\"因此，我们在扩充HashMap的时候，不再需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的哪个bit是1还是0就好了，是0就表示索引没有变化，是1就表示索引变成了“原索引+oldCap”，下图为16扩充至32的过程的示意图：\",\"这个设计非常的巧妙，既省去了重新计算hash值得时间，同时，由于新增的1bit是0还是1可以认为是随机的，因为resize的过程，均匀的把之前的冲突节点分散到新的bucket了。需要注意的是，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但从上图可以看出，JDK1.8不会倒置。\"]},\"1428\":{\"h\":\"线程安全性\",\"t\":[\"在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。HashMap线程不安全的主要原因是在多线程的使用场景下可能会造成死循环，如果多个线程同时put时，如果同时触发了rehash操作，会导致HashMap中的链表中出现循环节点，进而使得后面get的时候，会出现死循环。\",\"JDK1.7的示例如下：\",\"public class HashMapInfiniteLoop { private static HashMap<Integer,String> map = new HashMap<Integer,String>(2，0.75f); public static void main(String[] args) { map.put(5， \\\"C\\\"); new Thread(\\\"Thread1\\\") { public void run() { map.put(7, \\\"B\\\"); System.out.println(map); }; }.start(); new Thread(\\\"Thread2\\\") { public void run() { map.put(3, \\\"A); System.out.println(map); }; }.start(); } } \",\"其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个元素的时候，map就需要进行resize了。\",\"通过设置断点让线程1和线程2同时debug到transfer方法的首行，注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的Entry next = e.next，这一行，然后放开线程2的断点，让线程2进行resize，结果如下图：\",\"注意，Thread1的e指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。\",\"线程一被调度回来执行，先是执行newTable[i] = e，然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。\",\"e.next = newTable[i]导致key(3)指向了key(7)。注意：此时的key(7).next已经指向了key(3)，环形链表就这样出现了。\",\"此时，再对map做索引位置为3的get操作，就会死循环在这里，CPU成功达到100%，比如，调用map.get(11)，即会引起死循环，而且map中还丢失了元素，(5,“c”)也已经不再map中了。\",\"以上是JDK7的情况，JDK8虽然不会出现死循环的情况，但是会发生数据被覆盖的情况。\",\"https://zhuanlan.zhihu.com/p/76735726\"]},\"1429\":{\"h\":\"ConcurrentHashMap源码分析\"},\"1430\":{\"h\":\"JDK1.7的实现\",\"t\":[\"ConcurrentHashMap的成员变量中，包含了一个Segment的数组，Segment是ConcurrentHashMap的内部类，然后在Segment这个类中，包含了一个HashEntry数组，而HashEntry也是ConcurrentHashMap的内部类。HashEntry中，包含了key和value以及next指针（类似于HashMap中的Entry），所以HashEntry可以构成一个链表。\",\"简单来说，ConcurrentHashMap数据结构为一个Segment数组，Segment的数组结构为HashEntry的数组，而HashEntry存放的就是我们的键值对，可以构成链表，它们之间的关系如下图：\",\"它的put方法：\",\" public V put(K key, V value) { Segment<K,V> s; if (value == null) throw new NullPointerException(); // 二次哈希，以保证数据的分散性，避免哈希冲突 int hash = hash(key.hashCode()); int j = (hash >>> segmentShift) & segmentMask; // Unsafe 调用方式，直接获取相应的 Segment if ((s = (Segment<K,V>)UNSAFE.getObject // nonvolatile; recheck (segments, (j << SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false); } \",\"在put方法中，首先是通过二次哈希减小哈希冲突的可能性，根据hash值以Unsafe调用方式，直接获取响应的Segment，最终将数据添加到容器中是由segment对象的put方法来完成。Segment对象的put方法源代码如下：\",\"final V put(K key, int hash, V value, boolean onlyIfAbsent) { // 无论如何，确保获取锁 scanAndLockForPut会去查找是否有key相同Node ConcurrentHashMap.HashEntry<K,V> node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try { ConcurrentHashMap.HashEntry<K,V>[] tab = table; int index = (tab.length - 1) & hash; ConcurrentHashMap.HashEntry<K,V> first = entryAt(tab, index); for (ConcurrentHashMap.HashEntry<K,V> e = first;;) { // 更新已存在的key if (e != null) { K k; if ((k = e.key) == key || (e.hash == hash && key.equals(k))) { oldValue = e.value; if (!onlyIfAbsent) { e.value = value; ++modCount; } break; } e = e.next; } else { if (node != null) node.setNext(first); else node = new ConcurrentHashMap.HashEntry<K,V>(hash, key, value, first); int c = count + 1; // 判断是否需要扩容 if (c > threshold && tab.length < MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; } } } finally { unlock(); } return oldValue; } \",\"由于Segment对象本身就是一把锁，所以在新增数据的时候，相应的Segment对象块是被锁住的，其它线程并不能操作这个Segment对象，这样就保证了数据的安全性，在扩容的时候也是这样的，在JDK1.7中的ConcurrentHashMap扩容只是针对Segment对象中的HashEntry数组进行扩容，这个时候，由于Segment对象是一把锁，所以在rehash的过程中，其他线程无法对Segment的hash表做操作，这就解决了HashMap中由于put数据引起的闭环问题。\"]},\"1431\":{\"h\":\"JDK1.8的实现\",\"t\":[\"在容器的安全上，1.8中的ConcurrentHashMap放弃了JDK1.7的分段技术，而是采用了CAS机制 + synchronized来保证并发安全性，但是在ConcurrentHashMap实现里保留了Segment定义，这仅仅是为了保证序列化时的兼容性，并没有结构上的用处。\",\"在存储结构上，JDK1.8中ConcurrentHashMap放弃了HashEntry结构而是采用了跟HashMap结构非常相似，采用Node数组加链表（链表长度大于8的时候转为红黑树）的形式，Node节点设计如下：\",\"static class Node<K,V> implements Map.Entry<K,V> { final int hash; final K key; volatile V val; volatile Node<K,V> next; ...省略... } \",\"JDK1.8的ConcurrentHashMap的示意图如下：\",\"ConcurrentHashMap新增的核心方法有两个：putVal（新增）和transfer（扩容）。\",\"public V put(K key, V value) { return putVal(key, value, false); } \",\"可以看到put方法本身也是调用putVal方法：\",\" final V putVal(K key, V value, boolean onlyIfAbsent) { // 如果 key 为空，直接返回 if (key == null || value == null) throw new NullPointerException(); // 两次 hash ，减少碰撞次数 int hash = spread(key.hashCode()); // 记录链表节点得个数 int binCount = 0; // 无条件得循环遍历整个 node 数组，直到成功 for (ConcurrentHashMap.Node<K,V>[] tab = table;;) { ConcurrentHashMap.Node<K,V> f; int n, i, fh; // lazy-load 懒加载的方式，如果当前 tab 容器为空，则初始化 tab 容器 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 通过Unsafe.getObjectVolatile()的方式获取数组对应index上的元素，如果元素为空，则直接无所插入 else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { //// 利用CAS去进行无锁线程安全操作 if (casTabAt(tab, i, null, new ConcurrentHashMap.Node<K,V>(hash, key, value, null))) break; // no lock when adding to empty bin } // 如果 fh == -1 ，说明正在扩容，那么该线程也去帮扩容 else if ((fh = f.hash) == MOVED) // 协作扩容操作 tab = helpTransfer(tab, f); else { // 如果上面都不满足，说明存在 hash 冲突，则使用 synchronized 加锁。锁住链表或者红黑树的头结点，来保证操作安全 V oldVal = null; synchronized (f) { if (tabAt(tab, i) == f) { if (fh >= 0) {// 表示该节点是链表 binCount = 1; // 遍历该节点上的链表 for (ConcurrentHashMap.Node<K,V> e = f;; ++binCount) { K ek; //这里涉及到相同的key进行put就会覆盖原先的value if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } ConcurrentHashMap.Node<K,V> pred = e; if ((e = e.next) == null) {//插入链表尾部 pred.next = new ConcurrentHashMap.Node<K,V>(hash, key, value, null); break; } } } else if (f instanceof ConcurrentHashMap.TreeBin) {// 该节点是红黑树节点 ConcurrentHashMap.Node<K,V> p; binCount = 2; if ((p = ((ConcurrentHashMap.TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } // 插入完之后，判断链表长度是否大于8，大于8就需要转换为红黑树 if (binCount != 0) { if (binCount >= TREEIFY_THRESHOLD) treeifyBin(tab, i); // 如果存在相同的key ，返回原来的值 if (oldVal != null) return oldVal; break; } } } //统计 size，并且检测是否需要扩容 addCount(1L, binCount); return null; } \",\"详细说明：\",\"在ConcurrentHashMap中不允许key val字段为空，所以第一步先校验key value的值。key、val两个字段都不是null才继续往下走，否则直接抛出了NullPointerException异常，这是与HashMap有区别的地方，HashMap是可以允许为空的\",\"判断容器是否初始化，如果容器没有初始化，则调用initTable方法初始化\",\"initTable方法具体如下：\",\" /** * Initializes table, using the size recorded in sizeCtl. */ private final Node<K,V>[] initTable() { Node<K,V>[] tab; int sc; while ((tab = table) == null || tab.length == 0) { // 负数表示正在初始化或扩容，等待 if ((sc = sizeCtl) < 0) // 自旋等待 Thread.yield(); // lost initialization race; just spin // 执行 CAS 操作，期望将 sizeCtl 设置为 -1，-1 是正在初始化的标识 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { // CAS 抢到了锁 try { // 对 table 进行初始化，初始化长度为指定值，或者默认值 16 if ((tab = table) == null || tab.length == 0) { // sc 在初始化的时候用户可能会自定义，如果没有自定义，则是默认的 int n = (sc > 0) ? sc : DEFAULT_CAPACITY; // 创建数组 Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n]; table = tab = nt; // 指定下次扩容的大小，相当于 0.75 × n sc = n - (n >>> 2); } } finally { sizeCtl = sc; } break; } } return tab; } \",\"Table本质上就是一个Node数组，其初始化过程也就是对Node数组的初始化过程，方法中使用了CAS策略执行初始化操作。初始化流程为：\",\"判断sizeCtl值是否小于0，如果小于0表示ConcurrentHashMap正在执行初始化操作，所以需要先等待一会，如果其他线程初始化失败还可以顶替上去\",\"如果sizeCtl值大于等于0，则基于CAS策略抢占标记sizeCtl为-1，表示ConcurrentHashMap正在执行初始化，然后构造table，并更新sizeCtl的值\",\"初始化号table之后继续添加元素：\",\"根据双哈希之后的hash值找到数组对应的小标位置，如果该位置未存放节点，也就是说不存在哈希冲突，则使用CAS无锁的方法将数据添加到容器中，并且结束循环\",\"如果并未满足第三步，加入到扩容大军中（ConcurrentHashMap扩容采用的是多线程的方式），扩容时并未跳出死循环，这一点就保证了容器在扩容的时候并不会有其他的线程进行数据添加操作，这也保证了容器的安全性\",\"如果哈希冲突，则进行链表操作或者红黑树操作（如果链表树超过8，则修改链表为红黑树），在进行链表或者红黑树操作时，会使用synchronized锁把头结点锁住，保证了同时只有一个线程修改链表，防止出现链表成环\",\"进行addCount（1L，binCount）操作，该操作会更新size大小，判断是否需要扩容\",\"addCount方法的源码如下：\",\" // X传入的是1，check 传入的是 putVal 方法里的 binCount，没有hash冲突的话为0，冲突就会大于1 private final void addCount(long x, int check) { ConcurrentHashMap.CounterCell[] as; long b, s; // 统计ConcurrentHashMap里面节点个数 if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) { ConcurrentHashMap.CounterCell a; long v; int m; boolean uncontended = true; if (as == null || (m = as.length - 1) < 0 || (a = as[ThreadLocalRandom.getProbe() & m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) { fullAddCount(x, uncontended); return; } if (check <= 1) return; s = sumCount(); } // check就是binCount，binCount 最小都为0，所以这个条件一定会为true if (check >= 0) { ConcurrentHashMap.Node<K,V>[] tab, nt; int n, sc; // 这儿是自旋，需同时满足下面的条件 // 1. 第一个条件是map.size 大于 sizeCtl，也就是说需要扩容 // 2. 第二个条件是`table`不为null // 3. 第三个条件是`table`的长度不能超过最大容量 while (s >= (long)(sc = sizeCtl) && (tab = table) != null && (n = tab.length) < MAXIMUM_CAPACITY) { int rs = resizeStamp(n); // 该判断表示已经有线程在进行扩容操作了 if (sc < 0) { if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex <= 0) break; // 如果可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); } // 如果不在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2 else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs << RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); } } \",\"addCount 方法做了两个工作：\",\"对 map 的 size 加一\",\"检查是否需要扩容，或者是否正在扩容。如果需要扩容，就调用扩容方法，如果正在扩容，就帮助其扩容。\",\"最后是ConcurrentHashMap的扩容过程：\"]},\"1432\":{\"h\":\"HashTable源码分析\",\"t\":[\"HashTable底层基于数组与链表实现，通过synchronized关键字保证线程安全，但作为已经废弃的类，建议使用ConcurrentHashMap。\",\"HashTable的默认构造函数，容量为11，加载因子为0.75，扩容大小2倍+1。\"]},\"1433\":{\"h\":\"Set\"},\"1434\":{\"h\":\"HashSet源码分析\",\"t\":[\"HashSet实现了Set接口，在底层就是在HashMap的基础上包了一层，只不过存储的时候value默认存储了一个Object的静态变量，取的时候也是只返回key：\",\" private static final Object PRESENT = new Object(); \",\"核心方法的实现：\",\"public boolean add(E e) { return map.put(e, PRESENT)==null; } public boolean remove(Object o) { return map.remove(o)==PRESENT; } public boolean contains(Object o) { return map.containsKey(o); } \",\"HashSet是调用HashMap的put()方法，而put方法中有这样的逻辑，如果哈希值和key都一样，就会直接拿新的值覆盖旧值，而HashSet就是利用这个特性来保证唯一性的。\"]},\"1435\":{\"h\":\"反射的定义\",\"t\":[\"反射主要指程序可以访问、检测和修改其本身状态或行为的一种能力，在Java环境中，反射机制允许程序在执行时获取类自身的定义信息，例如实现动态创建属性、方法和类的对象、变更属性的内容和执行特定的方法的功能，从而使Java具有动态语言的特性，增强了程序的灵活性可移植性。\"]},\"1436\":{\"h\":\"反射的作用\",\"t\":[\"Java反射机制的主要用于实现以下功能：\",\"在运行时判断任意一个对象所属的类型\",\"在运行时构造任意一个类的对象\",\"在运行时判断任意一个类所具有的成员变量和方法\",\"在运行时调用任意一个对象的方法，哪怕可以调用private方法\"]},\"1437\":{\"h\":\"核心API\",\"t\":[\"核心包 - java.lang.reflect\",\"java.lang.Class：代表一个类\",\"java.lang.reflect.Method：代表类的方法\",\"java.lang.reflect.Constructor：代表类的构造方法\",\"java.lang.reflect.Array：提供了动态创建数组及访问数组元素的静态方法。该类中的所有方法都是静态的\"]},\"1438\":{\"h\":\"IO基础\",\"t\":[\"参考：Linux IO模式及select poll epoll详解。\",\"文件描述符：是计算机科学中的一个术语，用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。\",\"关于句柄的解释；牧童的手为指针，杏花村的牌子为句柄，杏花村酒店为对象的实例。句柄是资源在创建过程中由Windows赋予的，它就是代表这个资源的。而指针实质上是某个变量或者对象所在内存位置的首地址，是指向对象的。一个是指向，一个是代表，二者是不同的。一个是直接找到对象（指针），一个是间接找到对象（句柄）。例如，杏花村可以搬家（实际上程序运行过程中，资源在内存中的地址是变化的），那么牧童的手的指向也就不同（指针）了，然而即使搬了家，“杏花村”这块牌匾是不变的，通过打听“杏花村”这个名称，还是可以间接找到它的（地址）。HANDLE的本意是把柄，把手的意思，是你与操作系统打交道的东西。\",\"对于一次IO访问（以read为例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：\",\"等待数据准备\",\"将数据从内核拷贝至进程中\",\"基于这两个阶段，Linux操作系统有以下四种IO模型的方案：\",\"阻塞IO\",\"非阻塞IO\",\"IO多路复用\",\"异步IO\"]},\"1439\":{\"h\":\"Linux网络编程IO模型\"},\"1440\":{\"h\":\"阻塞IO模型\",\"t\":[\"这是最传统的IO模型，即在读写数据的过程中会阻塞，一个典型的读操作流程大致如下：\",\"当用户进程调用了recvfrom这个系统调用，kernel就开始IO的第一个阶段：准备数据（对于网络IO来说，很多时候一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区是需要一个过程的。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。\",\"也就是说，阻塞IO的特点就是在IO执行的两个阶段都被block了。\"]},\"1441\":{\"h\":\"非阻塞IO\",\"t\":[\"linux下，可以通过设置socket使其变为non-blocking。当对于一个non-blocking socket 执行读操作时，流程大致如下：\",\"当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。\",\"也就是说，非阻塞IO的特点是用户进行需要不断的主动询问kernel数据好了没有。\"]},\"1442\":{\"h\":\"IO多路复用\",\"t\":[\"IO多路复用就是我们通常说的select、poll、epoll，有些地方也称这种IO方式为event driven IO。\",\"select/epoll的好处在于单个process就可以同时处理多个网络连接的IO。它的基本原来就是select、poll、epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。\",\"当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。\",\"总结来看，IO多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。\",\"IO多路复用模型与阻塞IO其实并没有太大的区别，事实上，还更差一些。因为这里需要使用两个system call(select 和 recvfrom分别调用一次)，而阻塞IO值调用了一次system call(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。\",\"所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用mutli-threading+blocking的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。\",\"在IO多路复用模型中，一般会将socket都设置为非阻塞，但是用户进程会被select函数阻塞。\"]},\"1443\":{\"h\":\"异步IO\",\"t\":[\"Linux下的异步IO其实用的很少，整体流程大致如下：\",\"用户进程发起read操作之后，立刻就可以开始去做其它的事，而另一方面，从kernel的角度，当它收到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。\"]},\"1444\":{\"h\":\"阻塞、非阻塞和同步、异步\",\"t\":[\"阻塞、非阻塞说的是调用者。同步、异步说的是被调用者。\",\"同步IO和异步IO的区别：\",\"同步IO：真实IO 操作的时候会将process阻塞\",\"异步IO：真实IO 操作的时候不会将process阻塞\",\"按照如上定义，阻塞IO、非阻塞IO、IO多路复用均属于同步IO。\",\"五种线程模型对比：\"]},\"1445\":{\"h\":\"IO多路复用之select、poll、epoll\",\"t\":[\"select、poll和epoll都是IO多路复用的机制。IO多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select、poll、epoll本质上都是同步IO，因为它们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步IO则无需自己负责进行读写，异步IO的实现会负责把数据从内核拷贝到用户空间。\"]},\"1446\":{\"h\":\"select\",\"t\":[\"int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); \",\"select函数监视的文件描述符分为3类，分别是readfds、writefds和exceptfds。调用select函数会阻塞，直到有描述符就绪（有数据可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。\",\"select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。\"]},\"1447\":{\"h\":\"poll\",\"t\":[\"int poll (struct pollfd *fds, unsigned int nfds, int timeout); \",\"不同于select使用三个位图来表示三个fdset的方式，poll使用一个pollfd的指针实现。\",\"struct pollfd { int fd; /* file descriptor */ short events; /* requested events to watch */ short revents; /* returned events witnessed */ }; \",\"pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时pollfd并没有最大数量限制（但是数量过大后性能也会下降）。和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。\",\"select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。实际上，同时连接的大量客户端在同一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线程下降。\"]},\"1448\":{\"h\":\"epoll\",\"t\":[\"epoll是在Linux内核2.6版本中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的时间存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需要一次。\"]},\"1449\":{\"h\":\"Java中的IO模型\",\"t\":[\"在JDK1.4之前，基于Java的所有socket通信都使用了同步阻塞模式（bloking IO），这种一请求一应答的通信模型简化了上层开发，但性能可能性存在巨大瓶颈，对高并发和低时延支持不好。\",\"在JDK1.4之后，提供了新的NIO类库，Java开始支持非阻塞IO。在JDK1.7以后，将原来的NIO类库进行了升级，提供了AIO功能，支持基于文件的异步IO操作和针对套接字的异步IO操作等功能。\",\"JDK1.7之后，将原来的NIO类库进行了升级，提供了AIO功能，支持基于文件的异步IO操作和针对套接字的异步IO操作等功能。\"]},\"1450\":{\"h\":\"BIO\",\"t\":[\"使用BIO通信模型的服务端，通常通过一个独立的Acceptor线程负责监听客户端的连接，监听到客户端连接请求后为每一个客户端创建一个新的线程链路进行处理，处理完成通过输出流回应客户端，线程消耗，这就是典型一对一答模型，下面我们通过代码对BIO模型进行具体分析，我们实现客户端发送消息服务端将消息回传我们的功能。\",\"服务端：\",\" int port = 3000; try(ServerSocket serverSocket = new ServerSocket(port)) { Socket socket = null; while (true) { //主程序阻塞在accept操作上 socket = serverSocket.accept(); new Thread(new BioExampleServerHandle(socket)).start(); } } catch (Exception e) { e.printStackTrace(); } \",\" private Socket socket; public BioExampleServerHandle(Socket socket) { this.socket = socket; } @Override public void run() { try(BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter writer = new PrintWriter(socket.getOutputStream(), true)) { String message = reader.readLine(); System.out.println(\\\"收到客户端消息：\\\" + message); writer.println(\\\"answer: \\\" + message); } catch (Exception e) { e.printStackTrace(); } } \",\"客户端：\",\" String host = \\\"127.0.0.1\\\"; int port = 3000; try(Socket socket = new Socket(host, port); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter writer = new PrintWriter(socket.getOutputStream(), true)) { Scanner input = new Scanner(System.in); System.out.println(\\\"输入你想说的话：\\\"); String message = input.nextLine(); writer.println(message); String answer = reader.readLine(); System.out.println(answer); } catch (Exception e) { e.printStackTrace(); } \",\"通过代码我们可以发现BIO的主要问题在于，每当一个连接接入时我们都需要new一个线程进行处理，这显然是不合适的，因为一个线程功能只能处理一个连接，这显然是不合适的，因为一个线程只能处理一个连接，如果在高并发的情况下，我们的程序肯定无法满足性能需求，同时我们对线程创建也缺乏管理。为了改进这种模型我们可以通过消息队列和线程池技术对它加以优化，我们称它为伪异步IO，代码如下：\",\" int port = 3000; ThreadPoolExecutor socketPool = null; try(ServerSocket serverSocket = new ServerSocket(port)) { Socket socket = null; int cpuNum = Runtime.getRuntime().availableProcessors(); socketPool = new ThreadPoolExecutor(cpuNum, cpuNum * 2, 1000, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1000)); while (true) { socket = serverSocket.accept(); socketPool.submit(new BioExampleServerHandle(socket)); } } catch (Exception e) { e.printStackTrace(); } finally { socketPool.shutdown(); } \",\"可以看到每当有新的连接接入，我们都将他投递给线程池处理，由于我们设置了线程池大小和阻塞队列大小，因此在并发情况下都不会导致服务崩溃，但是如果并发数大于阻塞队列大小，或服务端处理连接缓慢时，阻塞队列无法继续处理，会导致客户端连接超时，影响用户体验。\"]},\"1451\":{\"h\":\"NIO\",\"t\":[\"NIO弥补了同步阻塞IO的不足，它提供了高速、面向块的IO，NIO中的一些概念：\",\"Buffer：Buffer用于和NIO通道进行交互。数据从通道读入缓冲区，从缓冲区写入到通道中，它的主要作用就是和channel进行交互\",\"Channel：Channel是一个通道，可以通过它读取和写入数据，通道是双向的，通道可以用户读、写或者同时读写\",\"Selector：Selector会不断的轮询注册在它上面的Channel，如果Channel上面有新的连接读写事件的时候就会被轮询出来，一个Selector可以注册多个Channel，只需要一个线程负责Selector轮询，就可以支持成千上万的连接，可以说为高并发服务器的开发提供了很好的支撑\",\"服务端：\",\" int port = 3000; ServerSocketChannel socketChannel = null; Selector selector = null; try { selector = Selector.open(); socketChannel = ServerSocketChannel.open(); //设置连接模式为非阻塞模式 socketChannel.configureBlocking(false); socketChannel.socket().bind(new InetSocketAddress(port)); //在selector上注册通道，监听连接事件 socketChannel.register(selector, SelectionKey.OP_ACCEPT); while (true) { //设置selector 每隔一秒扫描所有channel selector.select(1000); Set<SelectionKey> selectionKeys = selector.selectedKeys(); Iterator<SelectionKey> iterable = selectionKeys.iterator(); SelectionKey key = null; while (iterable.hasNext()) { key = iterable.next(); //对key进行处理 try { handlerKey(key, selector); } catch (Exception e) { if (null != key) { key.cancel(); if (null != key.channel()) { key.channel().close(); } } } } } } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != selector) { selector.close(); } if (null != socketChannel) { socketChannel.close(); } } catch (Exception e) { throw new RuntimeException(e); } } \",\"handlerKey代码如下：\",\" private void handlerKey(SelectionKey key, Selector selector) throws IOException { if (key.isValid()) { //判断是否是连接请求，对所有连接请求进行处理 if (key.isAcceptable()) { ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel(); SocketChannel channel = serverSocketChannel.accept(); channel.configureBlocking(false); //在selector上注册通道，监听读事件 channel.register(selector, SelectionKey.OP_READ); } else if (key.isReadable()) { SocketChannel channel = (SocketChannel) key.channel(); //分配一个1024字节的缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int readBytes = channel.read(byteBuffer); if (readBytes > 0) { //从写模式切换到读模式 byteBuffer.flip(); byte[] bytes = new byte[byteBuffer.remaining()]; byteBuffer.get(bytes); String message = new String(bytes, \\\"UTF-8\\\"); System.out.println(\\\"收到客户端消息: \\\" + message); //回复客户端 message = \\\"answer: \\\" + message; byte[] responseByte = message.getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(responseByte.length); writeBuffer.put(responseByte); writeBuffer.flip(); channel.write(writeBuffer); } } } } \",\"客户端代码：\",\" int port = 3000; String host = \\\"127.0.0.1\\\"; SocketChannel channel = null; Selector selector = null; try { selector = Selector.open(); channel = SocketChannel.open(); channel.configureBlocking(false); if (channel.connect(new InetSocketAddress(host, port))) { channel.register(selector, SelectionKey.OP_READ); write(channel); } else { channel.register(selector, SelectionKey.OP_CONNECT); } while (true) { selector.select(1000); Set<SelectionKey> selectionKeys = selector.selectedKeys(); Iterator<SelectionKey> iterator = selectionKeys.iterator(); SelectionKey key = null; while (iterator.hasNext()) { try { key = iterator.next(); handle(key, selector); } catch (Exception e) { e.printStackTrace(); if (null != key.channel()) { key.channel().close(); } if (null != key) { key.cancel(); } } } } } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != channel) { channel.close(); } if (null != selector) { selector.close(); } } catch (Exception e) { throw new RuntimeException(e); } } \",\"write 方法：\",\" private void write(SocketChannel channel) throws IOException { Scanner in = new Scanner(System.in); System.out.println(\\\"输入你想说的话：\\\"); String message = in.next(); byte[] bytes = message.getBytes(); ByteBuffer byteBuffer = ByteBuffer.allocate(bytes.length); byteBuffer.put(bytes); byteBuffer.flip(); channel.write(byteBuffer); } \",\"handle 方法：\",\" private void handle(SelectionKey key, Selector selector) throws IOException { if (key.isValid()) { SocketChannel channel = (SocketChannel) key.channel(); if (key.isConnectable()) { if (channel.finishConnect()) { channel.register(selector, SelectionKey.OP_READ); write(channel); } } else if (key.isReadable()) { ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int readBytes = channel.read(byteBuffer); if (readBytes > 0) { byteBuffer.flip(); byte[] bytes = new byte[byteBuffer.remaining()]; byteBuffer.get(bytes); String message = new String(bytes, \\\"UTF-8\\\"); System.out.println(message); } else if (readBytes < 0) { key.cancel(); channel.close(); } } } } \",\"通过代码我们会发现，NIO比BIO复杂很多。NIO虽然编码复杂，但优势同样明显，比起BIO客户端连接操作时异步的，我们可以注册OP_CONNET事件等待结果而不用像BIO那样被同步阻塞，Channel的读写操作都是异步的，没有等待数据它不会等待，而是直接返回。比起BIO我们不需要频繁的创建线程来处理客户端连接，而是通过一个Selector处理多个客户端连接，而且性能也可以得到保证，适合做高性能服务器开发。\"]},\"1452\":{\"h\":\"AIO\",\"t\":[\"通过对比，AIO要比BIO简单，这是因为我们不需要创建一个独立的IO线程来处理读写操作，AsynchronousSocketchannel、AsynchronousServerSocketChannel由JDK底层线程池负责回调驱动读写操作。\",\"服务端：\",\" int port = 3000; AsynchronousServerSocketChannel socketChannel = null; try { socketChannel = AsynchronousServerSocketChannel.open(); socketChannel.bind(new InetSocketAddress(port)); //接收客户端连接，传入AcceptCompletionHandler作为回调来接收连接消息 socketChannel.accept(socketChannel, new AcceptCompletionHandler()); Thread.currentThread().join(); } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != socketChannel) { socketChannel.close(); } } catch (Exception e1) { throw new RuntimeException(e1); } } \",\"AcceptCompletionHandler 类：\",\"public class AcceptCompletionHandler implements CompletionHandler<AsynchronousSocketChannel, AsynchronousServerSocketChannel> { @Override public void completed(AsynchronousSocketChannel result, AsynchronousServerSocketChannel attachment) { //继续接受其他客户端的连接请求，形成一个循环 attachment.accept(attachment, this); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //调用read操作进行异步读取操作，传入ReadCompletionHandler作为回调 result.read(byteBuffer, byteBuffer, new ReadCompletionHandler(result)); } @Override public void failed(Throwable exc, AsynchronousServerSocketChannel attachment) { //异常失败处理在这里 } } \",\"ReadCompletionHandler 类\",\"public class ReadCompletionHandler implements CompletionHandler<Integer, ByteBuffer> { private AsynchronousSocketChannel channel; public ReadCompletionHandler(AsynchronousSocketChannel channel) { this.channel = channel; } @Override public void completed(Integer result, ByteBuffer byteBuffer) { try { byteBuffer.flip(); byte[] bytes = new byte[byteBuffer.remaining()]; byteBuffer.get(bytes); String message = new String(bytes, \\\"UTF-8\\\"); System.out.println(\\\"收到客户端消息：: \\\" + message); write(message); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } @Override public void failed(Throwable exc, ByteBuffer attachment) { try { channel.close(); } catch (Exception e) { throw new RuntimeException(e); } } private void write(String message) { message = \\\"answer: \\\" + message; byte[] bytes = message.getBytes(); ByteBuffer byteBuffer = ByteBuffer.allocate(bytes.length); byteBuffer.put(bytes); byteBuffer.flip(); channel.write(byteBuffer, byteBuffer, new WriteCompletionHandler(channel)); } } \",\"客户端：\",\" int port = 3000; String host = \\\"127.0.0.1\\\"; AsynchronousSocketChannel channel = null; try { channel = AsynchronousSocketChannel.open(); channel.connect(new InetSocketAddress(host, port), channel, new AioClientHandler()); Thread.currentThread().join(); } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != channel) { channel.close(); } } catch (Exception e) { throw new RuntimeException(e); } } \",\"AioClientHandler 类(由于客户端比较简单我这里使用了嵌套类部类)：\",\"public class AioClientHandler implements CompletionHandler<Void, AsynchronousSocketChannel> { @Override public void completed(Void result, AsynchronousSocketChannel channel) { Scanner in = new Scanner(System.in); System.out.println(\\\"输入你想说的话：\\\"); String message = in.next(); byte[] bytes = message.getBytes(); ByteBuffer byteBuffer = ByteBuffer.allocate(bytes.length); byteBuffer.put(bytes); byteBuffer.flip(); channel.write(byteBuffer, byteBuffer, new CompletionHandler<Integer, ByteBuffer>() { @Override public void completed(Integer result, ByteBuffer buffer) { //判断是否写完如果没有继续写 if (buffer.hasRemaining()) { channel.write(buffer, buffer, this); } else { ByteBuffer readBuffer = ByteBuffer.allocate(1024); channel.read(readBuffer, readBuffer, new CompletionHandler<Integer, ByteBuffer>() { @Override public void completed(Integer result, ByteBuffer attachment) { try { attachment.flip(); byte[] bytes1 = new byte[attachment.remaining()]; attachment.get(bytes1); String message = new String(bytes1, \\\"UTF-8\\\"); System.out.println(message); System.exit(1); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } @Override public void failed(Throwable exc, ByteBuffer attachment) { try { channel.close(); } catch (Exception e) { throw new RuntimeException(e); } } }); } } @Override public void failed(Throwable exc, ByteBuffer attachment) { try { channel.close(); } catch (Exception e) { throw new RuntimeException(e); } } }); } @Override public void failed(Throwable exc, AsynchronousSocketChannel attachment) { } \"]},\"1453\":{\"h\":\"IO模型对比\",\"t\":[\"同步阻塞I/O(BIO)\",\"伪异步I/O\",\"非阻塞I/O(NIO)\",\"异步I/O(AIO)\",\"是否阻塞\",\"是\",\"是\",\"否\",\"否\",\"是否同步\",\"是\",\"是\",\"是\",\"否(异步)\",\"程序员友好程度\",\"简单\",\"简单\",\"非常难\",\"比较难\",\"可靠性\",\"非常差\",\"差\",\"高\",\"高\",\"吞吐量\",\"低\",\"中\",\"高\",\"高\",\"零拷贝从字面上来看包含两个意思：\",\"拷贝：就是指数据从一个存储区域转移到另一个存储区域\",\"零：它表示拷贝数据的次数为0\",\"合起来理解，零拷贝就是不需要将数据从一个存储区域复制到另一个存储区域。实际上，最早零拷贝的定义，来源于Linux系统的sendfile方法逻辑。\",\"在Linux 2.4内核中，sendfile系统调用方法，可以将磁盘数据通过DMA拷贝到内核态Buffer后，再通过DMA拷贝到NIC Buffer（socket buffer 即网卡），无需CPU拷贝，这个过程被称之为零拷贝。也就是说，站在操作系统的角度，零拷贝并不是不需要拷贝数据，而是省掉了CPU拷贝环节，减少了不必要的拷贝次数，提升数据拷贝效率。要想深入了解这其中的原理，就得从IO拷贝机制说起。\"]},\"1454\":{\"h\":\"基本概念\"},\"1455\":{\"h\":\"DMA\",\"t\":[\"DMA，即直接内存访问。DMA本质上是主板上一块独立的芯片，允许外设设备和内存存储器之间直接进行IO数据传输，其过程不需要CPU的参与。\"]},\"1456\":{\"h\":\"内核空间和用户空间\",\"t\":[\"操作系统的核心是内核，与普通的应用程序不同，它可以访问受保护的内核空间，也有访问底层硬件设备的权限。\",\"为了避免用户进程直接操作内核，保证内核安全，操作系统将虚拟内存划分为两个部分，一部分是内核空间，一部分是用户空间。在Linux系统中，内核模块运行在内核空间，对应的进程处于内核态；而用户程序运行在用户空间，对应的进程处于用户态。\",\"内核空间总是驻留在内存中，它是为操作系统的内核保留的。应用程序是不允许直接在该区域进行读写或者直接调用内核代码定义的函数。\",\"当启动某个应用程序时，操作系统会给应用程序分配一个单独的用户空间，其实就是一个用户独享的虚拟内存，每个普通的用户进程之间的用户空间是完全隔离的、不共享的，当用户进程结束的时候，用户空间的虚拟内存也会随之释放。\",\"同时处于用户态的进程不能访问内核空间中的数据，也不能直接调用内核函数的，如果要调用系统资源，就要将进程切换到内核态，由内核程序来进行操作。\"]},\"1457\":{\"h\":\"IO拷贝机制\",\"t\":[\"以客户端从服务器下载文件为例，服务端需要做两件事：\",\"从磁盘读取文件内容\",\"将文件内容通过网络传输给客户端\",\"实际上，这个看似简单的操作，里面的流程却没有那么简单，应用程序从磁盘中读取文件内容的操作，大体会经过以下几个流程：\",\"用户应用程序调用read方法，向操作系统发起IO请求，CPU上下文从用户态转为内核态，完成第一次CPU切换\",\"操作系统通过DMA控制器从磁盘中读取数据，并把数据存储到内核缓冲区\",\"CPU把内核缓冲区的数据，拷贝到用户缓冲区，同时上下文从内核态转为用户态，完成第二次CPU切换\",\"整个读取的数据的过程，完成了1次DMA拷贝，1次CPU拷贝，2次CPU切换，反之写入的过程，也是一样的。整个拷贝的过程，可以用如下流程图来描述：\",\"从上图，我们可以得出如下结论，4次拷贝次数，4次上下文切换次数。\",\"数据拷贝次数：2次DMA拷贝，2次CPU拷贝\",\"CPU切换次数：4次用户态和内核态切换\",\"而实际IO读写，有时候需要进行IO中断，同时也需要CPU响应中断，拷贝次数和切换次数比预期的还要多，以至于当客户端进行资源文件下载的时候，传输速度总是不尽人意。\"]},\"1458\":{\"h\":\"mmap内存映射拷贝流程\",\"t\":[\"mmap内存映射的拷贝，指的是将用户应用程序的缓冲区和操作系统的内核缓冲区进行映射处理，数据在内核缓冲区和用户缓冲区之间的CPU拷贝将其省略，进而加快资源拷贝效率。\",\"mmap内存映射拷贝流程：\",\"数据拷贝次数：2次DMA拷贝，1次CPU拷贝\",\"CPU切换次数：4次用户态和内核态的切换\",\"整个过程省掉了数据在内核缓冲区和用户缓冲区之间的CPU拷贝环节，在实际的应用中，对资源的拷贝速度性能提升不少。\"]},\"1459\":{\"h\":\"Linux系统sendfile拷贝流程\",\"t\":[\"在Linux 2.1 内核版本中，引入了一个系统调用方法：sendfile。\",\"当调用sendfile()时，DMA将磁盘数据复制到内核缓冲区kernel buffer；然后将内核中kernel buffer直接拷贝到socket buffer，最后利用DMA将socket buffer通过网卡传输给客户端。整个拷贝过程，可以用如下流程图来描述：\",\"Linux 系统 sendfile 拷贝流程：\",\"数据拷贝次数：2 次 DMA 拷贝，1 次 CPU 拷贝\",\"CPU 切换次数：2 次用户态和内核态的切换\",\"相比mmap内存映射方式，sendfile拷贝流程省掉了2次用户态和内核态的切换，同时内核缓冲区和用户缓冲区也无需建立内存映射，对资源的拷贝性能提升不少。\"]},\"1460\":{\"h\":\"sendfile With DMA scatter/gather 拷贝流程\",\"t\":[\"在 Linux 2.4 内核版本中，对 sendfile 系统方法做了优化升级，引入 SG-DMA 技术，需要 DMA 控制器支持。\",\"其实就是对 DMA 拷贝加入了 scatter/gather 操作，它可以直接从内核空间缓冲区中将数据读取到网卡。使用这个特点来实现数据拷贝，可以多省去一次 CPU 拷贝。\",\"整个拷贝过程，可以用如下流程图来描述：\",\"Linux 系统 sendfile With DMA scatter/gather 拷贝流程，从上图可以得出如下结论：\",\"数据拷贝次数：2 次 DMA 拷贝，0 次 CPU 拷贝\",\"CPU 切换次数：2 次用户态和内核态的切换\",\"可以发现，sendfile With DMA scatter/gather 实现的拷贝，其中 2 次数据拷贝都是 DMA 拷贝，全程都没有通过 CPU 来拷贝数据，所有的数据都是通过 DMA 来进行传输的，这就是操作系统真正意义上的零拷贝（Zero-copy) 技术，相比其他拷贝方式，传输效率最佳。\"]},\"1461\":{\"h\":\"Linux 系统 splice 零拷贝流程\",\"t\":[\"在 Linux 2.6.17 内核版本中，引入了 splice 系统调用方法，和 sendfile 方法不同的是，splice 不需要硬件支持。\",\"它将数据从磁盘读取到 OS 内核缓冲区后，内核缓冲区和 socket 缓冲区之间建立管道来传输数据，避免了两者之间的 CPU 拷贝操作。\",\"整个拷贝过程，可以用如下流程图来描述：\",\"Linux 系统 splice 拷贝流程，从上图可以得出如下结论：\",\"数据拷贝次数：2 次 DMA 拷贝，0 次 CPU 拷贝\",\"CPU 切换次数：2 次用户态和内核态的切换\",\"Linux 系统 splice 方法逻辑拷贝，也是操作系统真正意义上的零拷贝。\"]},\"1462\":{\"h\":\"IO拷贝机制对比\",\"t\":[\"从上面的IO拷贝机制中可以看出，无论是传统的IO方式，还是引入零拷贝之后，2次DMA copy都是少不了的，唯一的区别就是省掉CPU参与环节的方式不同。\",\"以Linux系统为例，拷贝机制对比的结果如下：\",\"拷贝机制\",\"系统调用\",\"CPU拷贝次数\",\"CPU拷贝次数\",\"上下文切换次数\",\"特点\",\"传统拷贝方式\",\"read/write\",\"2\",\"2\",\"4\",\"消耗资源比较多，拷贝数据效率慢\",\"mmap\",\"mmap/write\",\"1\",\"2\",\"4\",\"相比传统方法，少了用户缓冲区与内核缓冲区的数据拷贝，效率更高\",\"sendfile\",\"sendfile\",\"1\",\"2\",\"2\",\"相比mmap方式，少了内存文件映射步骤，效率更高\",\"sendfile With DMA scatter/gather\",\"sendfile\",\"0\",\"2\",\"2\",\"需要DMA控制器支持，没有CPU拷贝数据环节，真正的零拷贝\",\"splice\",\"splice\",\"0\",\"2\",\"2\",\"没有CPU拷贝数据环节，真正的零拷贝，编程逻辑复杂\",\"需要主要的是，零拷贝所有的方式，都需要操作系统的支持，具体采用哪种方式，是由操作系统来决定的。\"]},\"1463\":{\"h\":\"Java中的零拷贝\",\"t\":[\"Linux提供的零拷贝技术，Java并不是全部支持，目前只支持一下两种；\",\"mmap（内存映射）\",\"sendfile\"]},\"1464\":{\"h\":\"Java NIO 对mmap的支持\",\"t\":[\"Java NIO有一个MappedByteBuffer的类，可以用来实现内存映射，它的底层时调用了Linux内核的mmap的API。\",\"实现代码如下：\",\"public static void main(String[] args) { try { FileChannel readChannel = FileChannel.open(Paths.get(\\\"a.txt\\\"), StandardOpenOption.READ); // 建立内存文件映射 MappedByteBuffer data = readChannel.map(FileChannel.MapMode.READ_ONLY, 0, 1024 * 1024 * 40); FileChannel writeChannel = FileChannel.open(Paths.get(\\\"b.txt\\\"), StandardOpenOption.WRITE, StandardOpenOption.CREATE); // 拷贝数据 writeChannel.write(data); // 关闭通道 readChannel.close(); writeChannel.close(); }catch (Exception e){ System.out.println(e.getMessage()); } } \",\"其中MappedByteBuffer的作用，就是将内核缓冲区的内存和用户缓冲区的内存做了一个地址映射，读取小文件，效率并不高，但是读取大文件，效率很高。\"]},\"1465\":{\"h\":\"Java NIO 对sendfile的支持\",\"t\":[\"Java NIO 中的FileChannel.transferTo方法，底层调用的就是Linux内核的sendfile系统调用方法。实例代码如下：\",\"public static void main(String[] args) { try { // 原始文件 FileChannel srcChannel = FileChannel.open(Paths.get(\\\"a.txt\\\"), StandardOpenOption.READ); // 目标文件 FileChannel destChannel = FileChannel.open(Paths.get(\\\"b.txt\\\"), StandardOpenOption.WRITE, StandardOpenOption.CREATE); // 拷贝数据 srcChannel.transferTo(0, srcChannel.size(), destChannel); // 关闭通道 srcChannel.close(); destChannel.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } \",\"Java NIO 提供的FileChannel.transferTo并不保证一定能使用零拷贝。只有操作系统提供sendfile这样的零拷贝系统调用方法，才可以用的上零拷贝。\"]},\"1466\":{\"h\":\"EJB 简介\"},\"1467\":{\"h\":\"函数式编程概览\"},\"1468\":{\"h\":\"函数式编程的意义\",\"t\":[\"JDK8或者说Java8是目前企业开发中最常用的JDK版本，Java8可谓Java语言历史上变化最大的一个版本，从这个版本开始，Java的编程向着函数式风格迈进，这有助于编写出更为简洁、表达力更强，并且在很多情况下能够利用并行运行的代码。但是很多人在使用Java8的时候，还是使用传统的面向对象的编程方式，这样在使用Java8的好处也仅仅停留在JVM带来的性能上的提升，而事实上Java8的新特性可以极大提升我们的开发效率。不仅如此，几乎所有的高级编程语言都支持了函数式编程的特性，掌握其中一门的设计理念与思想，在面对其他任何编程语言的函数式编程时，都能做到游刃有余。\",\"在以往的使用传统面向对象的编程中，我们可能会编写这样的代码：\",\"import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class anonymousTest { public static void main(String[] args) { JFrame jFrame = new JFrame(\\\"My JFrame\\\"); JButton jButton = new JButton(\\\"My Button\\\"); // 使用匿名内部类编程 jButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.out.println(\\\"Button Pressed\\\"); } }); jFrame.add(jButton); jFrame.pack(); jFrame.setVisible(true); jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } \",\"这段代码我们实际上需要的其实只有System.out.println(\\\"Button Pressed\\\")这一行，但却不得不编写很多没有实际意义的代码，如果改用函数式风格编程，我们的代码就变成了：\",\"import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class anonymousTest { public static void main(String[] args) { JFrame jFrame = new JFrame(\\\"My JFrame\\\"); JButton jButton = new JButton(\\\"My Button\\\"); // 使用函数式编程 jButton.addActionListener(e -> System.out.println(\\\"Button Pressed\\\")); jFrame.add(jButton); jFrame.pack(); jFrame.setVisible(true); jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } \",\"可以看到，瞬间代码的易读性提高了很多。再比如我们经常会用到的创建线程的例子：\",\"package com.czxy.test; import java.io.FileOutputStream; import java.io.IOException; /** * Lambda 在创建线程方面可以简化写法 */ public class Lambda { //原来的写法 public static void main(String[] args) throws IOException { //获取执行前的毫秒值 long old = System.currentTimeMillis(); //执行一百千次 for (int a = 0; a < 100000; a++) { //原来的方式创建线程 实现Runnable接口 重写run方法 Thread thread = new Thread(new Runnable() { @Override public void run() { } }); thread.start(); } //获取执行后的毫秒值 long newTime = System.currentTimeMillis(); //获得消耗的时间 long i = newTime - old; System.out.println(\\\"创建100000个花费的总毫秒值\\\"+i); /* 使用Lambda表达式的新写法 */ //获取执行前的毫秒值 long old1 = System.currentTimeMillis(); for (int a =0; a<100000; a++){ Thread threadLambda = new Thread(()-> System.out.println(\\\"使用Lambda创建了线程了\\\")); threadLambda.start(); } //获取执行后的毫秒值 long newTime1 = System.currentTimeMillis(); //获得消耗的时间 long i1 = newTime1 - old1; System.out.println(\\\"Lambda创建100000个花费的总毫秒值\\\"+i1); } } \",\"不难看出，Lambda表达式在简化代码上，是非常有效的。\"]},\"1469\":{\"h\":\"Lambda表达式和匿名内部类\",\"t\":[\"Lambda表达式看起来特别像是Java中匿名内部类的一种特殊写法，对于初学者而言，暂时不妨可以认为Lambda表达式就是匿名内部类的一种新的写法，或者说是一种语法糖。下面通过一个例子来说明，Lambda表达式就是一种全新的语法：\",\"public class LambdaTest { Runnable r1 = () -> System.out.println(this); Runnable r2 = new Runnable() { @Override public void run() { System.out.println(this); } }; public static void main(String[] args) { LambdaTest lambdaTest = new LambdaTest(); Thread t1 = new Thread(lambdaTest.r1); t1.start(); System.out.println(\\\"================\\\"); Thread t2 = new Thread(lambdaTest.r2); t2.start(); } } \",\"控制台输出：\",\"Stream2.LambdaTest@362872a1 Stream2.LambdaTest$1@60c8c409 \",\"首先来看第二行，它表示当前对象指的是LambdaTest$1，在Java中表示匿名内部类会使用类名称+\\\"$\\\"+顺序的方式来表示，\\\"@\\\"后面的表示类的哈希值，而第一个Lamda表达式所打印的就是当前类LambdaTest的地址，这说明使用Lambda表达式的这种方式与它所在的类是同一个作用域。\",\"通过这个例子说明了Lambda表达式与匿名内部类有着本质的区别，两者是完全不同的，并不是匿名内部类的语法糖或者另一种表达形式，只不过在某些场景下，可以使用Lambda表达式来替代匿名内部类完成相同的功能。\",\"实际上，使用Lambda表达式所带来的好处其实远不止简化代码，它还可以为我们带来代码执行效率上的提升，所以，无论是出于开发效率，还是代码的执行速度上来看，都应该使用Lambda表达式。\"]},\"1470\":{\"h\":\"Lambda表达式和Stream\",\"t\":[\"在实际使用中，Lambda表达式往往与Stream相互配合，才会发挥其特性，通常用来高效的处理一些集合的运算。\",\"我们首先从遍历打印集合中元素这样非常常见的例子开始，以往遍历集合通常的做法是：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); for (String string : list) { System.out.println(string); } } } \",\"或者使用传统的for循环来遍历：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); for (int i = 0; i < list.size(); i++) { System.out.println(list.get(i)); } } } \",\"通过Lambda表达式我们可以将上述代码优雅的表示为：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\",\\\"world\\\",\\\"hello world\\\");\\\\ list.forEach((String x) -> System.out.println(x)); } } \",\"实际上，对于变量前面的类型，也是可以省略的。\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); list.forEach(x-> System.out.println(x)); } } \",\"因为编译器可以自动推断出当前遍历集合当前元素的类型，但并不是在所有的场景下，编译器都可以自动推断类型，在后续的文章中，我们就会遇到编译器无法自动推断，需要我们手动声明变量类型的情况。\",\"这里我们先不去考虑Lambda表达式具体的语法，先从直观的角度来感受函数式编程带来的好处，原本三行的代码现在仅仅需要一行就能实现，如果使用方法引用甚至能够让代码变的更加简洁：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); strings.forEach(System.out::println); } } \",\"这里的\",\":: \",\"也是java8中新增的一个语法糖。后续的文章我们有专门的篇幅来介绍方法引用，使用方法引用可以写出更加简洁优雅的代码。\",\"看了这么几个例子，你可能很疑惑，到底什么是Lambda表达式呢？在回答这个问题之前，我们首先需要了解我们为什么需要需要Lambda表达式。\",\"在以往的Java中，方法可以参数的传递总共有两种，一种是传递值，另有一种是传递引用，或者说对象的地址，但是我们无法将函数作为参数传递给一个方法，也无法声明返回一个函数的方法，而在其他语言中，比如面向函数式编程语言JavaScript中，函数的参数是一个函数，返回值是另一个函数的情况是非常常见的（回调函数），例如：\",\"images_upload_handler: function(blobInfo, success, failure) { success(...) failure(...) } \",\"这个函数总共接收三个参数，第一个参数就是一个普通的变量，success就是这个函数执行成功的回调函数，failure就是这个函数执行失败的回调函数。可以说，JavaScript是一门非常典型的函数式语言。而使用Lambda表达式就可以实现传递行为这种高阶函数（参数可以接收行为的方法们就称这个方法为高阶函数）的使用。\",\"当然Lambda表达式肯定不止只是能用来遍历集合这个简单，实际上，更多的情况下，我们都是需要配合Stream（流）来实现各种各样的操作。对于前面使用Lambda表达式来实现集合遍历的例子还可以这样做：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\",\\\"world\\\",\\\"hello world\\\"); list.forEach(item-> System.out.println(item)); list.stream().forEach(System.out::println); } } \",\"看起来只是增加了一步，将list这个集合转化为了Stream，但是两者的实现有着本质的区别。我们可以简单的了解一下他们之前的区别。 对于第一种： 可以看到list.forEach实际上是调用Iterable这个类中jdk1.8新增的forEach方法，我们都知道List本身继承了Collection集合接口，而Collection接口又继承了Iterable这个类，所以可以完成调用，方法实现本身并没有特别复杂的地方，其实本质上看起来和我们传统的使用迭代器的方式并没有区别，接下来，我们查看一下第二种方式： 首先同样的是在Collection接口中新增加了一个default method（我们称之为默认方法），在jdk1.8中接口是又具体的方法实现，实际上对于java这一门非常庞大臃肿的语言，为了向函数式编程迈进，jdk的设计者匠心独具，设计非常巧妙。这个方法将返回了一个新的对象Stream，并且调用了StreamSupport这个类中的stream（）方法： 追踪下去，我们也可以看到，同样的也是一个名叫forEach的方法，但其实这里的forEach()方法与之前的forEach（）方法存在本质的差别，这里的forEach实际上表示一种终止操作，而jdk会在集合进行流操作的时候，调用终止操作。\",\"在这两个方法中都接受一个Consumer<? super T> action 这样的一个参数，实际上，对于java而言，为了实现函数式编程，java引入了一个全新的概念：函数式接口，它是java实现整个函数式编程的手段，也是函数式编程中一个及其重要的概念，这个概念会贯穿整个函数式编程的全过程，理解了函数式接口，才能Lambda表达式真正的含义，接下来的时间，我们非常有必要首来认识一下，什么是函数式接口。\",\"函数式接口是函数式编程中最重要的概念，函数式编程与传统的编码方式相比最明显的区别就是，它允许把函数（或者说表达式）当成参数传递给另一个函数，在其他编程语言中，Lambda表达式的类型是函数，但在Java中，Lambda表达式是对象，他们必须依附于一类特别的对象--函数式接口（functional interface）。\"]},\"1471\":{\"h\":\"函数式接口定义\",\"t\":[\"在之前的这个例子中：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\",\\\"world\\\",\\\"hello world\\\"); list.forEach(item-> System.out.println(item)); } } \",\"点击箭头就会进入到一个接口当中：\",\"@FunctionalInterface public interface Consumer<T> { void accept(T t); default Consumer<T> andThen(Consumer<? super T> after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } } \",\"可以看到这个接口上有一个@FunctionInterface的注解，点击这个注解进入，就可以看到这样一段JavaDoc:\",\"/** * An informative annotation type used to indicate that an interface * type declaration is intended to be a <i>functional interface</i> as * defined by the Java Language Specification. * * Conceptually, a functional interface has exactly one abstract * method. Since {@linkplain java.lang.reflect.Method#isDefault() * default methods} have an implementation, they are not abstract. If * an interface declares an abstract method overriding one of the * public methods of {@code java.lang.Object}, that also does * <em>not</em> count toward the interface's abstract method count * since any implementation of the interface will have an * implementation from {@code java.lang.Object} or elsewhere. * * <p>Note that instances of functional interfaces can be created with * lambda expressions, method references, or constructor references. * * <p>If a type is annotated with this annotation type, compilers are * required to generate an error message unless: * * <ul> * <li> The type is an interface type and not an annotation type, enum, or class. * <li> The annotated type satisfies the requirements of a functional interface. * </ul> * * <p>However, the compiler will treat any interface meeting the * definition of a functional interface as a functional interface * regardless of whether or not a {@code FunctionalInterface} * annotation is present on the interface declaration. * * @jls 4.3.2. The Class Object * @jls 9.8 Functional Interfaces * @jls 9.4.3 Interface Method Body * @since 1.8 */ @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface FunctionalInterface {} \",\"我们一行一行来仔细阅读一下这段文档：\",\" An informative annotation type used to indicate that an interface type declaration is intended to be a <i>functional interface</i> as defined by the Java Language Specification. \",\"这里说，@FunctionInterface这个注解，它使用Java语言规范定义，使用通知性的annotation,来声明函数式接口，换言之，如果一个接口上使用了@FunctionInterface这个注解，那么这个接口就是函数式接口。\",\"那么到底什么是函数式接口呢？继续往下看：\",\" Conceptually, a functional interface has exactly one abstract method. Since {@linkplain java.lang.reflect.Method#isDefault() default methods} have an implementation, they are not abstract. If an interface declares an abstract method overriding one of the public methods of {@code java.lang.Object}, that also does <em>not</em> count toward the interface's abstract method count since any implementation of the interface will have an implementation from {@code java.lang.Object} or elsewhere. \",\"一个函数式接口，它只有一个精确的抽象方法，也就是说，有且仅有一个抽象方法，那么这个接口就被称为函数式接口（在jdk8中，除了抽象方法外还可以定义default method和static method，不一定都是抽象方法），并且如果这个抽象方法是Object类中的方法，不会计入这个接口的抽象方法数量。需要注意的是，可以通过Lambda表达式来创建，方法引用来创建，或者构造方法的引用来创建函数式接口的实例。\",\"关于Lambda表达式的创建会在后续的文章中详细讲解，这里只需要大概了解函数式接口实例创建的方式有这么三种。我们继续往下：\",\" <p>Note that instances of functional interfaces can be created with lambda expressions, method references, or constructor references. <p>If a type is annotated with this annotation type, compilers are required to generate an error message unless: <ul> <li> The type is an interface type and not an annotation type, enum, or class. <li> The annotated type satisfies the requirements of a functional interface. </ul> <p>However, the compiler will treat any interface meeting the definition of a functional interface as a functional interface regardless of whether or not a {@code FunctionalInterface} annotation is present on the interface declaration. \",\"如果一个接口上有@FunctionInterface这个注解，如果不满足以下情况编译器会报错：\",\"被注解的是一个接口类型，而不是一个注解类型，而是枚举或者类；\",\"被注解的类型满足函数式接口的定义；\",\"例如，创建线程时需要用到的Runnable接口：\",\"@FunctionalInterface public interface Runnable { public abstract void run(); } \",\"可以看到这个接口从JDK8开始就加上了@FunctionalInterface这个注解，换句话说，Runnable接口现在变成了函数式接口，我们可以通过Lambda表达式来创建Runnable接口的实例。\",\"在上面的文档中，还有最后一段话：\",\" <p>However, the compiler will treat any interface meeting the definition of a functional interface as a functional interface regardless of whether or not a {@code FunctionalInterface} annotation is present on the interface declaration \",\"然而，编译器其实会自动为满足函数式接口定义的接口添加@FunctionalInterface注解，也就是说，如果一个接口满足了函数式接口的定义，即便我们没有给他加上@FunctionalInterface这个注解，编译器会自动将它看成是函数式接口。\",\"总的来说，关于函数式接口的定义如下：\",\"1.如果一个接口只有一个抽象方法，那么该接口就是一个函数式接口 2.如果我们在某个接口上声明了FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口 3.如果某个接口只有一个抽象方法，但我们并没有对该接口声明FunctionalInterface注解，编译器依旧会将该接口看作是函数式接口。\",\"再以这个接口为例：\",\"@FunctionalInterface public interface Consumer<T> { void accept(T t); default Consumer<T> andThen(Consumer<? super T> after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } } \",\"可以看到，在这个接口中，除了一个抽象方法accept()方法外，还有一个default默认方法andThen()，但是总的来说还是只有一个抽象方法，所以满足函数式接口的定义。\",\"再比如：\",\"@FunctionalInterface public interface Predicate<T> { boolean test(T t); default Predicate<T> and(Predicate<? super T> other) { Objects.requireNonNull(other); return (t) -> test(t) && other.test(t); } default Predicate<T> negate() { return (t) -> !test(t); } default Predicate<T> or(Predicate<? super T> other) { Objects.requireNonNull(other); return (t) -> test(t) || other.test(t); } static <T> Predicate<T> isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -> targetRef.equals(object); } } \",\"同样的，这个接口中只有一个抽象方法test()，除此之外，有3个default默认方法，有一个static方法，因此同样满足函数式接口的定义。\",\"再比如：\",\"@FunctionalInterface public interface MyInterface { void test(); String toString(); } \",\"这个接口中看起来有两个抽象方法，但toString()方法是基类Object中的方法，因此在检查函数式接口的定义的时候，它并不算数，因为Object类是所有类的父类，所有的类默认已经有了这个方法，如果算的话，其实是没有意义的，所以在定义函数式接口的时候，Object类中方法并不会对函数式接口的方法的数量变化。\",\"在JDK8中的提供了大量的现成的函数式接口供我们使用，以之前我们使用forEach()为例：\",\" default void forEach(Consumer<? super T> action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } \",\"其实forEach()方法接收的函数式接口就是我们上面举得第一个例子Consumer，然后调用Consumer接口中的accept方法，诸多的函数式接口，为我们方便的传递各种不同需求的行为提供了可能。\"]},\"1472\":{\"h\":\"为什么是函数式接口？\",\"t\":[\"在前面我们了解了函数式接口的概念之后，我们来具体看一个例子：\",\"@FunctionalInterface interface MyInterface { void test(); @Override String toString(); } public class FunctionalInterfaceTest { public static void main(String[] args) { } } \",\"我们定义了一个接口，MyInterface，这个接口中有两个抽象方法，但由于toString()是继承自Obeject类中的方法，所以并不会对这个接口的抽象方法的总数有影响，还是只有一个抽象方法，那么显然，它满足函数式接口的定义。\",\"首先我们使用传统的匿名内部类的方式来实现MyInterface中的test()方法：\",\"@FunctionalInterface interface MyInterface { void test(); @Override String toString(); } public class FunctionalInterfaceTest { public void MyTest(MyInterface myInterface) { System.out.println(1); myInterface.test(); System.out.println(2); } public static void main(String[] args) { FunctionalInterfaceTest functionalInterfaceTest = new FunctionalInterfaceTest(); functionalInterfaceTest.MyTest(new MyInterface() { @Override public void test() { System.out.println(\\\"myTest\\\"); } }); } } \",\"MyInterface既然满足函数式接口的定义，那么就意味着我们可以使用Lambda表达式的方式来创建MyInterface的实例：\",\"@FunctionalInterface interface MyInterface { void test(); @Override String toString(); } public class FunctionalInterfaceTest { public void MyTest(MyInterface myInterface) { System.out.println(1); myInterface.test(); System.out.println(2); } public static void main(String[] args) { FunctionalInterfaceTest functionalInterfaceTest = new FunctionalInterfaceTest(); functionalInterfaceTest.MyTest(() -> System.out.println(\\\"myTest\\\")); } } \",\"这两种写法的运行结果完全是等价的，编译器会自动根据上下文，来推测出 functionalInterfaceTest.MyTest()中需要接收的参数的类型，也就是说，() -> System.out.println(\\\"myTest\\\")就是MyInterface 的一个实例，由于函数式接口中只会有一个抽象方法，那么对于这个Lambda表达式而言，箭头左边的部分，一定就是MyInterface 这个接口中唯一的抽象方法test()的参数，右边的部分，一定就是MyInterface 这个接口中唯一的抽象方法test()的实现，由于test()方法的参数是空值，所以左边的括号是空值。\",\"这样看起来，其实MyInterface 这个接口中的抽象方法，具体叫什么名字，反而没有那么重要了，当然虽然这个函数的名字我们并不会直接去调用，但在起名字的时候，最好还是要有意义。\",\"可能初学者并不能直观的认识到() -> System.out.println(\\\"myTest\\\")表达的具体含义，我们可以换一种写法：\",\"interface MyInterface { void test(); @Override String toString(); } public class FunctionalInterfaceTest { public void MyTest(MyInterface myInterface) { System.out.println(1); myInterface.test(); System.out.println(2); } public static void main(String[] args) { FunctionalInterfaceTest functionalInterfaceTest = new FunctionalInterfaceTest(); MyInterface myInterface = () -> System.out.println(\\\"myTest\\\") functionalInterfaceTest.MyTest(myInterface); } } \",\"程序运行的效果是完全等价的，使用这种写法，我们就更能直观的体会到，() -> System.out.println(\\\"myTest\\\")其实就是MyInterface的一个具体实现。\",\"前面我们提到过，在Java中，Lambda表达式需要依赖于函数式接口这样一种特殊的形式，所以为什么是函数式接口呢？或者说为什么需要函数式接口呢？简而言之，Java是纯面向对象的语言，方法无法脱离类或者接口单独存在，因此在Java中，函数式编程必须依附这样一类特殊的对象：函数式接口。\",\"实际上，对于一个特定的Lambda表达式是什么类型的，是需要上下文才能解读的，来看这样一个例子：\",\"public class Essence { public static void main(String[] args) { InterfaceTestA interfaceTestA = () -> {}; InterfaceTestB interfaceTestB = () -> {}; } } interface InterfaceTestA { void myMethod(); } interface InterfaceTestB { void myMethod2(); } \",\"可以看到，对于这两个不同的函数式接口的实现都是() -> {}这同一种实现，对于这个特定的Lambda表达式，必须要联系他的上下文才能知道：\",\" InterfaceTestA interfaceTestA \",\"和\",\" InterfaceTestB interfaceTestB \",\"就是这两个Lambda表达式的上下文。\",\"我们再回到遍历List集合的例子中：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\",\\\"world\\\",\\\"hello world\\\"); list.forEach(item-> System.out.println(item)); } } \",\"点击forEach方法，就会自动跳转到：\",\" /** * Performs the given action for each element of the {@code Iterable} * until all elements have been processed or the action throws an * exception. Unless otherwise specified by the implementing class, * actions are performed in the order of iteration (if an iteration order * is specified). Exceptions thrown by the action are relayed to the * caller. * * @implSpec * <p>The default implementation behaves as if: * <pre>{@code * for (T t : this) * action.accept(t); * }</pre> * * @param action The action to be performed for each element * @throws NullPointerException if the specified action is null * @since 1.8 */ default void forEach(Consumer<? super T> action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } \",\"首先它是一个默认方法，接收的参数类型是Consumer，遍历这个集合，对集合中的每个元素执行Consumer中的accept()方法。\",\"不妨来读一下这段文档：\",\" Performs the given action for each element of the {@code Iterable} until all elements have been processed or the action throws an exception. Unless otherwise specified by the implementing class, actions are performed in the order of iteration (if an iteration order is specified). Exceptions thrown by the action are relayed to the caller \",\"针对于Iterable每一个元素去执行给定的动作，换句话说，这里并不是将值作为参数，而是将行为作为参数进行传递，执行到集合中所有的元素执行完或者抛出异常为止，如果没有被实现类所指定的话，那么动作就会按照迭代的顺序去执行，是不是抛出异常取决于调用者。\",\"其实这里最关键的就是Consumer这个参数，接下来我们重点分析Consumer这个函数式接口。\"]},\"1473\":{\"h\":\"常见的函数式接口\"},\"1474\":{\"h\":\"Consumer函数式接口\",\"t\":[\"首先我们观察Consumer这个接口的定义：\",\"package java.util.function; import java.util.Objects; /** * Represents an operation that accepts a single input argument and returns no * result. Unlike most other functional interfaces, {@code Consumer} is expected * to operate via side-effects. * * <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> * whose functional method is {@link #accept(Object)}. * * @param <T> the type of the input to the operation * * @since 1.8 */ @FunctionalInterface public interface Consumer<T> { /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); /** * Returns a composed {@code Consumer} that performs, in sequence, this * operation followed by the {@code after} operation. If performing either * operation throws an exception, it is relayed to the caller of the * composed operation. If performing this operation throws an exception, * the {@code after} operation will not be performed. * * @param after the operation to perform after this operation * @return a composed {@code Consumer} that performs in sequence this * operation followed by the {@code after} operation * @throws NullPointerException if {@code after} is null */ default Consumer<T> andThen(Consumer<? super T> after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } } \",\"可以看到：\",\"@since 1.8 \",\"这个接口是从JDK1.8才开始有的，consumer这个单词本身的意思是消费者\",\" Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, {@code Consumer} is expected to operate via side-effects. \",\"Consumer代表了一种接收单个输入并且不返回结果的操作，与大多数其他的函数式接口不同的是，它可能会有副作用。\",\"这里的副作用指的是可能会修改传入参数的值。\",\"This is a functional interface whose functional method is {@link #accept(Object)}. \",\"这是一个函数式接口，接口中的抽象方法是accept()。 对于前面List集合遍历的例子， 我们可以通过匿名内部类的方式来操作：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\",\\\"world\\\",\\\"hello world\\\"); list.forEach(new Consumer<String>() { @Override public void accept(String s) { System.out.println(s); } }); } } \",\"由于所有的匿名内部类又可以使用Lambda表达式来进行替换，所以：\",\"public class LambdaTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\",\\\"world\\\",\\\"hello world\\\"); list.forEach(item-> System.out.println(item)); } } \",\"这里因为类型推断的原因，编译器会自动推断Item的数据类型，所以无需说明item的类型。\"]},\"1475\":{\"h\":\"Function函数式接口\",\"t\":[\"java8为我们了提供了很多的函数式接口，Function就是其中一个，首先我们来读一下它的javaDoc：\",\"package java.util.function; import java.util.Objects; /** * Represents a function that accepts one argument and produces a result. * * <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> * whose functional method is {@link #apply(Object)}. * * @param <T> the type of the input to the function * @param <R> the type of the result of the function * * @since 1.8 */ @FunctionalInterface public interface Function<T, R> { /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); /** * Returns a composed function that first applies the {@code before} * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param <V> the type of input to the {@code before} function, and to the * composed function * @param before the function to apply before this function is applied * @return a composed function that first applies the {@code before} * function and then applies this function * @throws NullPointerException if before is null * * @see #andThen(Function) */ default <V> Function<V, R> compose(Function<? super V, ? extends T> before) { Objects.requireNonNull(before); return (V v) -> apply(before.apply(v)); } /** * Returns a composed function that first applies this function to * its input, and then applies the {@code after} function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param <V> the type of output of the {@code after} function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the {@code after} function * @throws NullPointerException if after is null * * @see #compose(Function) */ default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) { Objects.requireNonNull(after); return (T t) -> after.apply(apply(t)); } /** * Returns a function that always returns its input argument. * * @param <T> the type of the input and output objects to the function * @return a function that always returns its input argument */ static <T> Function<T, T> identity() { return t -> t; } } \",\"同样的，与之前介绍的Consumer函数一样，都是一个函数式接口，都是从JDK8开始提供的。\",\" Represents a function that accepts one argument and produces a result. <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> whose functional method is {@link #apply(Object)}. @param <T> the type of the input to the function @param <R> the type of the result of the function \",\"Function提供了一个接收一个参数并且返回一个结果的函数，它的抽象方法是apply()，<T,R>分别表示输入参数的类型和返回结果的类型。\",\"我们来看一个具体的例子：\",\"public class FunctionTest { public static void main(String[] args) { FunctionTest functionTest = new FunctionTest(); System.out.println(functionTest.compute(1, value -> 2 * value)); } public int compute(int a, Function<Integer, Integer> function) { int result = function.apply(a); return result; } } \",\"这其中最关键的地方在于，compute的function参数传递的是一种行为，而不再是传统的值。\",\"public class FunctionTest { public static void main(String[] args) { FunctionTest functionTest = new FunctionTest(); System.out.println(functionTest.compute(1, value -> 2 * value)); System.out.println(functionTest.compute(2, value -> value * value)); System.out.println(functionTest.compute(3, value -> 3 + value)); } public int compute(int a, Function<Integer, Integer> function) { int result = function.apply(a); return result; } } \",\"可以看到我们其实只定义了一个函数，每次只需要将我们的所定义好的行为，传入即可，这是与非函数式编程最大的区别。\",\"来看一个输入参数与返回结果参数类型不一致的例子：\",\"public class FunctionTest { public int method1(int a) { return 2 * a; } public int method2(int a) { return a * a; } public int method3(int a) { return 3 + a; } } \",\"每当有一种新的操作，我们就不得不定义一个新的函数，因为行为总是被预先定义好的，定义好行为之后我们再去调用。但是使用Lambda表达式，行为是调用的时候才动态的调用执行，这与之前的面向对象的编程方式是完全不同的。\",\"这里还需要简单提及一下高阶函数，如果一个函数接收一个函数作为参数，或者返回一个函数作为返回值，那么该函数就叫做高阶函数。\",\"比如我们上面给出的例子中的compute()方法，convert()方法就是高阶函数。\",\"在Function接口中，还有两个默认方法：\",\" /** * Returns a composed function that first applies the {@code before} * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param <V> the type of input to the {@code before} function, and to the * composed function * @param before the function to apply before this function is applied * @return a composed function that first applies the {@code before} * function and then applies this function * @throws NullPointerException if before is null * * @see #andThen(Function) */ default <V> Function<V, R> compose(Function<? super V, ? extends T> before) { Objects.requireNonNull(before); return (V v) -> apply(before.apply(v)); } \",\"compose()这个函数返回的是一个复合函数，这个复合函数首先应用before这个Function，然后再去对这个结果应用当前的Function，如果当中任何一个Function抛出了异常，它取决于调用这个怎么去处理这个异常。\",\"参数before指的是在应用这个函数之前所要应用的当前的函数的函数，首先会应用before这个Function，然后再应用当前的Function。\",\"cmpose()这个方法其实是将两个Function进行了组合，首先调用传入的Function的apply()方法，然后再调用当前的Function的apply()方法。这么做实现了两个函数式接口的串联，实际上也可以n个的串联。\",\" /** * Returns a composed function that first applies this function to * its input, and then applies the {@code after} function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param <V> the type of output of the {@code after} function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the {@code after} function * @throws NullPointerException if after is null * * @see #compose(Function) */ default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) { Objects.requireNonNull(after); return (T t) -> after.apply(apply(t)); } \",\"andThen()这个方法刚好是反过来的，首先会应用当前的Function，然后再去对应用当前的这个对象的Function。\",\"最后这个方法就比较简单了：\",\" /** * Returns a function that always returns its input argument. * * @param <T> the type of the input and output objects to the function * @return a function that always returns its input argument */ static <T> Function<T, T> identity() { return t -> t; } \",\"它总是返回输入的变量。identity本身的意思也就是同一性，下面我们通过具体的例子来说明：\",\"public class FunctionTest { public static void main(String[] args) { FunctionTest functionTest = new FunctionTest(); System.out.println(functionTest.compute(2, value -> value * 3, value -> value * value)); System.out.println(functionTest.compute2(2, value -> value * 3, value -> value * value)); } public int compute(int a, Function<Integer, Integer> function1, Function<Integer, Integer> function2) { return function1.compose(function2).apply(a); } public int compute2(int a, Function<Integer, Integer> function1, Function<Integer, Integer> function2) { return function1.andThen(function2).apply(a); } } \",\"对于Function接口中的apply()方法而言，它只接受一个参数，并返回一个结果，如果想输入两个参数并返回结果，显然它是做不到的，再JDK中有这样一个函数式接口BiFunction：\",\"@FunctionalInterface public interface BiFunction<T, U, R> { /** * Applies this function to the given arguments. * * @param t the first function argument * @param u the second function argument * @return the function result */ R apply(T t, U u); /** * Returns a composed function that first applies this function to * its input, and then applies the {@code after} function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param <V> the type of output of the {@code after} function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the {@code after} function * @throws NullPointerException if after is null */ default <V> BiFunction<T, U, V> andThen(Function<? super R, ? extends V> after) { Objects.requireNonNull(after); return (T t, U u) -> after.apply(apply(t, u)); } } \",\"Bi实际上是Bidirectional的缩写，这个单词本身的含义是双向的意思。BiFunction这个函数式接口的定义：\",\" /** * Represents a function that accepts two arguments and produces a result. * This is the two-arity specialization of {@link Function}. * * <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> * whose functional method is {@link #apply(Object, Object)}. * * @param <T> the type of the first argument to the function * @param <U> the type of the second argument to the function * @param <R> the type of the result of the function * * @see Function * @since 1.8 */ \",\"接收两个参数并且返回一个结果，它是Function接口的一种特殊形式，有三个泛型，T，U分别是两个接收的参数的类型，R是返回的结果的类型。\",\"如果我们想定义四则运算的话，使用传统的方式，我们可能会写出如下代码：\",\"public class BiFunctionTest { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } ... } \",\"观察不难发现，四则运算正好就是输入两个参数，返回一个结果，正好满足BiFunction的定义，现在我们使用BiFunction来实现同样的功能：\",\"public class BiFunctionTest { public static void main(String[] args) { BiFunctionTest biFunctionTest = new BiFunctionTest(); System.out.println(biFunctionTest.compute(1, 2, (value1, value2) -> value1 + value2)); System.out.println(biFunctionTest.compute(1, 2, (value1, value2) -> value1 - value2)); System.out.println(biFunctionTest.compute(1, 2, (value1, value2) -> value1 * value2)); System.out.println(biFunctionTest.compute(1, 2, (value1, value2) -> value1 / value2)); } public int compute(int a, int b, BiFunction<Integer, Integer, Integer> biFunction) { return biFunction.apply(a, b); } } \",\"但是需要注意的是，在Bifunction中只有一个默认方法andThen()，而没有compose()方法:\",\" /** * Returns a composed function that first applies this function to * its input, and then applies the {@code after} function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param <V> the type of output of the {@code after} function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the {@code after} function * @throws NullPointerException if after is null */ default <V> BiFunction<T, U, V> andThen(Function<? super R, ? extends V> after) { Objects.requireNonNull(after); return (T t, U u) -> after.apply(apply(t, u)); } \",\"原因是显而易见的，如果有的话，只能返回一个结果，而Bifunction要求接收两个参数，返回一个结果，这显然是不行的，但是对于andThen()方法，after这个Function类型的参数，正好可以接收BiFunction这个接口的返回的结果作为参数。\",\"同样的我们可以举一个例子：\",\"public class BiFunctionTest { public static void main(String[] args) { BiFunctionTest biFunctionTest = new BiFunctionTest(); System.out.println(biFunctionTest.compute(1, 2, (value1, value2) -> value1 + value2, value -> value * value)); } public int compute(int a, int b, BiFunction<Integer, Integer, Integer> biFunction, Function<Integer, Integer> function) { return biFunction.andThen(function).apply(a, b); } } \",\"public class PersonTest { public static void main(String[] args) { Person person1 = new Person(\\\"zhangsan\\\", 20); Person person2 = new Person(\\\"lisi\\\", 30); Person person3 = new Person(\\\"wangwu\\\", 40); List<Person> persons = Arrays.asList(person1, person2, person3); PersonTest personTest = new PersonTest(); List<Person> persons2 = personTest.getPersonByAge(25, persons); persons2.forEach(System.out::println); } public List<Person> getPersonByUsername(String username, List<Person> persons) { return persons.stream().filter(person -> person.getUsername().equals(username)).collect(Collectors.toList()); } public List<Person> getPersonByAge(int age, List<Person> persons) { BiFunction<Integer, List<Person>, List<Person>> biFunction = (ageOfPerson, personList) -> { return personList.stream().filter(person -> person.getAge() > age).collect(Collectors.toList()); }; return biFunction.apply(age, persons); } } \"]},\"1476\":{\"h\":\"Predicate函数式接口\",\"t\":[\"同样的方式，我们首先类阅读一下Predicate的JavaDoc：\",\"/** * Represents a predicate (boolean-valued function) of one argument. * * <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> * whose functional method is {@link #test(Object)}. * * @param <T> the type of the input to the predicate * * @since 1.8 */ @FunctionalInterface public interface Predicate<T> { /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return {@code true} if the input argument matches the predicate, * otherwise {@code false} */ boolean test(T t); /** * Returns a composed predicate that represents a short-circuiting logical * AND of this predicate and another. When evaluating the composed * predicate, if this predicate is {@code false}, then the {@code other} * predicate is not evaluated. * * <p>Any exceptions thrown during evaluation of either predicate are relayed * to the caller; if evaluation of this predicate throws an exception, the * {@code other} predicate will not be evaluated. * * @param other a predicate that will be logically-ANDed with this * predicate * @return a composed predicate that represents the short-circuiting logical * AND of this predicate and the {@code other} predicate * @throws NullPointerException if other is null */ default Predicate<T> and(Predicate<? super T> other) { Objects.requireNonNull(other); return (t) -> test(t) && other.test(t); } /** * Returns a predicate that represents the logical negation of this * predicate. * * @return a predicate that represents the logical negation of this * predicate */ default Predicate<T> negate() { return (t) -> !test(t); } /** * Returns a composed predicate that represents a short-circuiting logical * OR of this predicate and another. When evaluating the composed * predicate, if this predicate is {@code true}, then the {@code other} * predicate is not evaluated. * * <p>Any exceptions thrown during evaluation of either predicate are relayed * to the caller; if evaluation of this predicate throws an exception, the * {@code other} predicate will not be evaluated. * * @param other a predicate that will be logically-ORed with this * predicate * @return a composed predicate that represents the short-circuiting logical * OR of this predicate and the {@code other} predicate * @throws NullPointerException if other is null */ default Predicate<T> or(Predicate<? super T> other) { Objects.requireNonNull(other); return (t) -> test(t) || other.test(t); } /** * Returns a predicate that tests if two arguments are equal according * to {@link Objects#equals(Object, Object)}. * * @param <T> the type of arguments to the predicate * @param targetRef the object reference with which to compare for equality, * which may be {@code null} * @return a predicate that tests if two arguments are equal according * to {@link Objects#equals(Object, Object)} */ static <T> Predicate<T> isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -> targetRef.equals(object); } } \",\"Predicate也是一个重要的函数式接口\",\"/** * Represents a predicate (boolean-valued function) of one argument. * * <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> * whose functional method is {@link #test(Object)}. * * @param <T> the type of the input to the predicate * * @since 1.8 */ \",\"predicate这个单词本身是谓词， 阐明， 断言的意思，这里说，Predicate代表了一个接收一个参数，返回一个boolean值类型的函数式接口，其中方法名叫test()。\",\" /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return {@code true} if the input argument matches the predicate, * otherwise {@code false} */ \",\"针对于给定的T类型的参数t来计算，如果与predicate相匹配，则返回一个true,否则返回false。\",\"针对于Predicate可以定义，我们可以给出例子：\",\"public class PredicateTest { public static void main(String[] args) { Predicate<String> predicate = p -> p.length() > 5; System.out.println(predicate.test(\\\"hello\\\")); } } \",\"Predicate在集合与stream中有大量的应用，再来看一些具体的例子：\",\"public class PredicateTest2 { public static void main(String[] args) { List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); PredicateTest2 predicateTest2 = new PredicateTest2(); // 找到集合中所有的偶数 predicateTest2.conditionFilter(list, item -> item % 2 == 0); // 找到集合中所有的奇数 predicateTest2.conditionFilter(list, item -> item % 2 != 0); // 找到集合中所有大于5的数 predicateTest2.conditionFilter(list, item -> item > 5); // 找到集合中所有小于3的数 predicateTest2.conditionFilter(list, item -> item < 3); } public void conditionFilter(List<Integer> list, Predicate<Integer> predicate) { for (Integer integer : list) { if (predicate.test(integer)) { System.out.println(integer); } } } } \",\"可以想象，如果要使用传统的方式实现这些需求，我们就必须要编写很多个具体的方法，但是如果使用Lambda表达式，我们就可以定义一个通用的函数，具体的行为在调用的时候再传入。\",\"Predicate中除了抽象方法test()，还有：\",\" /** * Returns a composed predicate that represents a short-circuiting logical * AND of this predicate and another. When evaluating the composed * predicate, if this predicate is {@code false}, then the {@code other} * predicate is not evaluated. * * <p>Any exceptions thrown during evaluation of either predicate are relayed * to the caller; if evaluation of this predicate throws an exception, the * {@code other} predicate will not be evaluated. * * @param other a predicate that will be logically-ANDed with this * predicate * @return a composed predicate that represents the short-circuiting logical * AND of this predicate and the {@code other} predicate * @throws NullPointerException if other is null */ default Predicate<T> and(Predicate<? super T> other) { Objects.requireNonNull(other); return (t) -> test(t) && other.test(t); } \",\"这个函数表示当前的Predicate与另一个Predicate的短路与，当计算这个复合函数的时候，如果前面的Predicate的值为false,那么后面的将不再会被计算，如果在计算过程中，任何一个Predicate会抛出异常的话，怎么做取决于调用者，如果当前的Predicate抛出了异常，那么后者也不会被计算。\",\" /** * Returns a predicate that represents the logical negation of this * predicate. * * @return a predicate that represents the logical negation of this * predicate */ default Predicate<T> negate() { return (t) -> !test(t); } \",\"negate本身是否定的意思，表示返回当前Predicate的逻辑非。\",\" /** * Returns a composed predicate that represents a short-circuiting logical * OR of this predicate and another. When evaluating the composed * predicate, if this predicate is {@code true}, then the {@code other} * predicate is not evaluated. * * <p>Any exceptions thrown during evaluation of either predicate are relayed * to the caller; if evaluation of this predicate throws an exception, the * {@code other} predicate will not be evaluated. * * @param other a predicate that will be logically-ORed with this * predicate * @return a composed predicate that represents the short-circuiting logical * OR of this predicate and the {@code other} predicate * @throws NullPointerException if other is null */ default Predicate<T> or(Predicate<? super T> other) { Objects.requireNonNull(other); return (t) -> test(t) || other.test(t); } \",\"类似的，这个方法是计算逻辑或的操作，如果当前的Predicate是true的话，后面的将不会再被计算，关于Predicate的三个默认方法，我们来看具体例子：\",\"public class PredicateTest2 { public static void main(String[] args) { List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); PredicateTest2 predicateTest2 = new PredicateTest2(); // 找到集合中所有的偶数 predicateTest2.conditionFilter(list, item -> item % 2 == 0); // 找到集合中所有的奇数 predicateTest2.conditionFilter(list, item -> item % 2 != 0); // 找到集合中所有大于5的数 predicateTest2.conditionFilter(list, item -> item > 5); // 找到集合中所有小于3的数 predicateTest2.conditionFilter(list, item -> item < 3); // 找到集合中所有大于5并且是偶数的数 predicateTest2.conditionFilter2(list, item -> item > 5, item -> item % 2 == 0); // 找到集合中所有大于5或者是偶数的数 predicateTest2.conditionFilter3(list, item -> item > 5, item -> item % 2 == 0); predicateTest2.conditionFilter4(list, item -> item > 5, item -> item % 2 == 0); } public void conditionFilter(List<Integer> list, Predicate<Integer> predicate) { for (Integer integer : list) { if (predicate.test(integer)) { System.out.println(integer); } } } public void conditionFilter2(List<Integer> list, Predicate<Integer> predicate, Predicate<Integer> predicate2) { for (Integer integer : list) { if (predicate.and(predicate2).test(integer)) { System.out.println(integer); } } } public void conditionFilter3(List<Integer> list, Predicate<Integer> predicate, Predicate<Integer> predicate2) { for (Integer integer : list) { if (predicate.or(predicate2).test(integer)) { System.out.println(integer); } } } public void conditionFilter4(List<Integer> list, Predicate<Integer> predicate, Predicate<Integer> predicate2) { for (Integer integer : list) { if (predicate.or(predicate2).negate().test(integer)) { System.out.println(integer); } } } } \",\"最后我们来看一下它唯一的static方法：\",\" /** * Returns a predicate that tests if two arguments are equal according * to {@link Objects#equals(Object, Object)}. * * @param <T> the type of arguments to the predicate * @param targetRef the object reference with which to compare for equality, * which may be {@code null} * @return a predicate that tests if two arguments are equal according * to {@link Objects#equals(Object, Object)} */ static <T> Predicate<T> isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -> targetRef.equals(object); } \",\"用来根据Objects类中的equals()方法判断两个参数是不是相等，注意，这里并不是Object类，而是Objects，这是从JDK1.7之后新增加的类。 Objects::isNull是一个静态方法的方法引用，\",\" public static boolean isNull(Object obj) { return obj == null; } \",\"来看具体的例子：\",\"public class PredicateTest3 { public static void main(String[] args) { PredicateTest3 predicateTest3 = new PredicateTest3(); System.out.println(predicateTest3.isEqual(\\\"test\\\").test(new Date())); } public Predicate<Date> isEqual(Object object) { return Predicate.isEqual(object); } } \",\"本质上这个其实\\\"test\\\".equals(new Date())，那么显然结果是false。\"]},\"1477\":{\"h\":\"Supplier函数式接口\",\"t\":[\"同样的，我们来看一下Supplier函数式接口的文档：\",\"/** * Represents a supplier of results. * * <p>There is no requirement that a new or distinct result be returned each * time the supplier is invoked. * * <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> * whose functional method is {@link #get()}. * * @param <T> the type of results supplied by this supplier * * @since 1.8 */ @FunctionalInterface public interface Supplier<T> { /** * Gets a result. * * @return a result */ T get(); } \",\"首先来看类的说明：\",\"Represents a supplier of results. There is no requirement that a new or distinct result be returned each time the supplier is invoked. \",\"Supplier表示提供结果的供应者，它每次被调用的时候无需保证返回不同的结果，换言之，每次被调用的结果可能是相同的。\",\"Supplier不接受参数，并返回一个结果。\",\"我们来新建一个测试类：\",\"public class SupplierJyc { public static void main(String[] args) { Supplier<String> supplierJyc = () -> \\\"hello word\\\"; System.out.println(supplierJyc.get()); } } \",\"显然，控制台会打印出以下结果：\",\"> Task :SupplierJyc.main() hello word \",\"实际上，Supplier更多的适用于工厂创建对象，下面我们用具体的例子来说明，首先创建一个Student类，并生成无参构造方法和setter及getter方法：\",\"public class Student { private String name = \\\"zhangsan\\\"; private int age = 20; public Student() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } \",\"下面我们使用Supplier来创建一个对象：\",\"public class StudentTest { public static void main(String[] args) { Supplier<Student> supplier = () -> new Student(); System.out.println(supplier.get().getName()); } } \",\"正式由于Supplier这个函数式接口不接收参数，并且返回一个泛型T类型的对象，所以() -> new Student()就是Supplier函数式接口的一个实例。除了通过这种方式创建实例外，我们还可以使用一种特殊的方式来创建Supplier的实例，即对象引用：\",\"public class StudentTest { public static void main(String[] args) { Supplier<Student> supplier = () -> new Student(); System.out.println(supplier.get().getName()); System.out.println(\\\"--------------\\\"); Supplier<Student> supplier2 = Student::new; System.out.println(supplier2.get().getName()); } } \",\"这会与上面的代码得到相同的结果，如果点击Student::new中的new的话，会自动跳转到Student的无参构造的地方：\",\" public Student() { } \",\"说明这个新的语法就是在调用Student的无参构造来创建对象，而这个无参构造刚好满足不接受参数，只返回对象的Supplier函数式接口的要求，所以创建了Student的实例。\",\"当我们修改这个类的默认构造方法，去掉没有参数的构造方法：\",\" public Student(String name) { this.name = name; } \",\"编译器就会提示我们不能解析构造方法,这也验证了我们之前的说法。\",\"以上就是几个最基础也是最重要的几个函数式接口，在此基础上，JDK还为我们提供了一些其他的函数式接口，例如BinaryOperator，他们可以看成是前面几个函数式接口的扩展。\"]},\"1478\":{\"h\":\"函数式接口扩展\",\"t\":[\"相同的方式，我们首先来阅读一下BinaryOperator这个函数式接口的文档：\",\"/** * Represents an operation upon two operands of the same type, producing a result * of the same type as the operands. This is a specialization of * {@link BiFunction} for the case where the operands and the result are all of * the same type. * * <p>This is a <a href=\\\"package-summary.html\\\">functional interface</a> * whose functional method is {@link #apply(Object, Object)}. * * @param <T> the type of the operands and result of the operator * * @see BiFunction * @see UnaryOperator * @since 1.8 */ @FunctionalInterface public interface BinaryOperator<T> extends BiFunction<T,T,T> { /** * Returns a {@link BinaryOperator} which returns the lesser of two elements * according to the specified {@code Comparator}. * * @param <T> the type of the input arguments of the comparator * @param comparator a {@code Comparator} for comparing the two values * @return a {@code BinaryOperator} which returns the lesser of its operands, * according to the supplied {@code Comparator} * @throws NullPointerException if the argument is null */ public static <T> BinaryOperator<T> minBy(Comparator<? super T> comparator) { Objects.requireNonNull(comparator); return (a, b) -> comparator.compare(a, b) <= 0 ? a : b; } /** * Returns a {@link BinaryOperator} which returns the greater of two elements * according to the specified {@code Comparator}. * * @param <T> the type of the input arguments of the comparator * @param comparator a {@code Comparator} for comparing the two values * @return a {@code BinaryOperator} which returns the greater of its operands, * according to the supplied {@code Comparator} * @throws NullPointerException if the argument is null */ public static <T> BinaryOperator<T> maxBy(Comparator<? super T> comparator) { Objects.requireNonNull(comparator); return (a, b) -> comparator.compare(a, b) >= 0 ? a : b; } } \",\"首先来看类的说明：\",\"Represents an operation upon two operands of the same type, producing a result of the same type as the operands. This is a specialization of BiFunction for the case where the operands and the result are all of the same type. This is a functional interface whose functional method is apply(Object, Object). \",\"BinaryOperator表示针对于两个相同运算对象的操作，并且生成与运算对象相同类型的结果类型，这是当使用BiFunction运算对象与结果类型相同时候的一个特例，我们知道，在BiFunction中，类型可以是不相同的：\",\"BiFunction<T, U, R> \",\"同时其中的抽象方法apply()，也接收了两个不同类型的参数，并且返回了不同类型的结果：\",\"R apply(T t, U u); \",\"当类型相同的时候，就变成了：\",\" BinaryOperator<T> extends BiFunction<T,T,T> \",\"apply()方法也就变成了：\",\"T apply(T t, T u); \",\"BinaryOperator中还有两个静态方法，首先来看minBy()的说明：\",\"Returns a BinaryOperator which returns the lesser of two elements according to the specified Comparator. \",\"minBy()方法会根据比较器Comparator返回两个元素中比较小的那一个，来看一个具体的例子，我们给定两个字符串，来返回比较小的那一个：\",\"public class BinaryOperatorTest { public static void main(String[] args) { BinaryOperatorTest binaryOperatorTest = new BinaryOperatorTest(); System.out.println(binaryOperatorTest.getShort(\\\"hellohello\\\", \\\"hello\\\", (a, b) -> a.length() - b.length())); System.out.println(binaryOperatorTest.getShort(\\\"hellohello\\\", \\\"hello\\\", (a, b) -> a.charAt(0) - b.charAt(0))); } public String getShort(String a, String b, Comparator<String> comparator) { return BinaryOperator.minBy(comparator).apply(a, b); } } \",\"显然使用maxBy()方法会获得相反的结果。\",\"其实在java.util.function这个包下面，还有很多的其他的函数式接口，比如BiConsumer，BiFunction，LongPredicate，IntSupplier等等，这些都是对于这几个基础的函数式接口的有力的补充，也是这几个基础的函数式接口的特例。\"]},\"1479\":{\"h\":\"方法引用\",\"t\":[\"public class MethodReferenceDemo { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); list.forEach(System.out::println); } } \",\"这个例子中的::就是JDK8中新增的语法，叫做方法引用，它可以看成是Lambda表达式的一种语法糖，如果所使用的Lambda表达式恰好被实现过的话，就可以使用方法引用来写出更加简洁的代码，我们可以将方法引用看作是一个【函数指针（function pointer）】。\",\"方法引用共分为4类：静态方法引用、构造方法引用、类的任意对象的实例方法引用、特定对象的实例方法引用，对于其中的每一种，我们都会给出Lambda表达式的方式和方法引用的方式实现相同的功能，以此来对照学习。\"]},\"1480\":{\"h\":\"静态方法引用\",\"t\":[\"首先定义一个类：\",\"public class Student { private String name; private int score; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getScore() { return score; } public void setScore(int score) { this.score = score; } public static int compareStudentByScore(Student student1, Student student2) { return student1.score - student2.score; } private static int compareStudentByName(Student student1, Student student2) { return student1.getName().compareToIgnoreCase(student2.getName()); } } \",\"接下来我们使用List集合中新增加的sort方法进行排序：\",\"public class MethodReferenceDemo { public static void main(String[] args) { Student student1 = new Student(\\\"zhangsan\\\", 10); Student student2 = new Student(\\\"lisi\\\", 90); Student student3 = new Student(\\\"wangwu\\\", 50); Student student4 = new Student(\\\"zhaoliu\\\", 40); List<Student> students = Arrays.asList(student1, student2, student3, student4); students.sort((studentParam1, studentParam2) -> Student.compareStudentByScore(studentParam1, studentParam2)); students.forEach(student -> System.out.println(student.getScore())); } } \",\"这里我们排序的时候直接调用的是List集合中的默认方法sort（），这也是在JDK8中新增加的方法：\",\" default void sort(Comparator<? super E> c) { Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator<E> i = this.listIterator(); for (Object e : a) { i.next(); i.set((E) e); } } \",\"可以看到其接收Comparator作为参数，我们再来看一下Comparator的类定义情况：\",\"@FunctionalInterface public interface Comparator<T> { int compare(T o1, T o2); } \",\"可以看到这是一个函数式接口，并且接收两个相同类型的参数，并且返回一个Int值，它会根据定义好的排序规则，如果第一个参数大于第二个参数，那么会返回正数，相等会返回0，小于会返回负数，针对于以上的例子，Student类中的静态方法compareStudentByScore恰好是接收两个参数，并且返回一个结果，所以可以作为Comparator这个Lambda表达式的方法体，其实我们还可以使用方法引用的方式，来完成相同的功能：\",\"public class MethodReferenceDemo { public static void main(String[] args) { Student student1 = new Student(\\\"zhangsan\\\", 10); Student student2 = new Student(\\\"lisi\\\", 90); Student student3 = new Student(\\\"wangwu\\\", 50); Student student4 = new Student(\\\"zhaoliu\\\", 40); List<Student> students = Arrays.asList(student1, student2, student3, student4); // students.sort((studentParam1, studentParam2) -> Student.compareStudentByScore(studentParam1, studentParam2)); // students.forEach(student -> System.out.println(student.getScore())); System.out.println(\\\"==================================\\\"); students.sort(Student::compareStudentByScore); students.forEach(student -> System.out.println(student.getScore())); } } \",\"这两种方式的效果完全等价，换言之，在这个场景下，方法引用与Lambda表达式完全等价，方法引用是Lambda表达式的一种语法糖，只有当某一个已经存在的方法，恰好满足了Lambda表达式的要求，才可以使用方法引用，Lambda表达式其实是一种更为通用的形式，而方法引用则需要满足一些条件才能使用。\"]},\"1481\":{\"h\":\"实例方法引用\",\"t\":[\"我们依然使用排序这个例子，这次我们使用另一种写法来完成这个功能，首先定义一个这样的类：\",\"public class StudentComparator { public int compareStudentByScore(Student student1, Student student2) { return student1.getScore() - student2.getScore(); } public int compareStudentByName(Student student1, Student student2) { return student1.getName().compareToIgnoreCase(student2.getName()); } } \",\"然后来实现对于Student的排序：\",\"public class MethodReferenceDemo { public static void main(String[] args) { Student student1 = new Student(\\\"zhangsan\\\", 10); Student student2 = new Student(\\\"lisi\\\", 90); Student student3 = new Student(\\\"wangwu\\\", 50); Student student4 = new Student(\\\"zhaoliu\\\", 40); StudentComparator studentComparator = new StudentComparator(); students.sort((studentParam1, studentParam2) -> studentComparator. compareStudentByScore(studentParam1, studentParam2)); students.forEach(student -> System.out.println(student.getScore())); } } \",\"这里我们直接使用StudentComparator实例中的compareStudentByScore来进行排序，事实上，这种场景下，也可以使用方法引用来替代：\",\"public class MethodReferenceDemo { public static void main(String[] args) { Student student1 = new Student(\\\"zhangsan\\\", 10); Student student2 = new Student(\\\"lisi\\\", 90); Student student3 = new Student(\\\"wangwu\\\", 50); Student student4 = new Student(\\\"zhaoliu\\\", 40); List<Student> students = Arrays.asList(student1, student2, student3, student4); StudentComparator studentComparator = new StudentComparator(); students.sort(studentComparator::compareStudentByScore); students.forEach(student -> System.out.println(student.getScore())); System.out.println(\\\"==================================\\\"); students.sort(studentComparator::compareStudentByName); students.forEach(student -> System.out.println(student.getName())); } } \",\"与静态方法引用的不同的是，这里我们调用的是类实例的方法。\"]},\"1482\":{\"h\":\"实例方法名引用\",\"t\":[\"首先，在Student类中，我们增加一个方法：\",\"package lambda; /** * 2 * @Author: jiyongchao * 3 * @Date: 2020/8/20 23:56 * 4 */ public class Student { private String name; private int score; public Student(String name, int score) { this.name = name; this.score = score; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getScore() { return score; } public void setScore(int score) { this.score = score; } public static int compareStudentByScore(Student student1, Student student2) { return student1.score - student2.score; } private static int compareStudentByName(Student student1, Student student2) { return student1.getName().compareToIgnoreCase(student2.getName()); } public int compareByScore(Student student) { return this.getScore() - student.getScore(); } public int compareByName(Student student) { return this.getName().compareToIgnoreCase(student.getName()); } } \",\"在之前的例子中，compareStudentByScore与compareStudentByName方法实际上是我们有意为之的，实际上这两个静态方法放在任何一个类中，都是可以调用的，通常我们比较两个对象时，更多的情况是，传入一个对象，并与当前对象进行比较，这也是新增加的compareByScore和compareByName的作用，在这种情况下，排序规则又可以做出如下修改：\",\"public class MethodReferenceDemo { public static void main(String[] args) { Student student1 = new Student(\\\"zhangsan\\\", 10); Student student2 = new Student(\\\"lisi\\\", 90); Student student3 = new Student(\\\"wangwu\\\", 50); Student student4 = new Student(\\\"zhaoliu\\\", 40); List<Student> students = Arrays.asList(student1, student2, student3, student4); students.sort(Student::compareByName); students.forEach(student -> System.out.println(student.getName())); } } \",\"我们再举一个例子，来加深对于实例方法名引用的理解：\",\"public class MethodReferenceDemo { public static void main(String[] args) { List<String> cities = Arrays.asList(\\\"qingdao\\\", \\\"chongqing\\\", \\\"tianjin\\\", \\\"beijing\\\"); Collections.sort(cities, (city1, city2) -> city1.compareToIgnoreCase(city2)); cities.forEach(city -> System.out.println(city)); Collections.sort(cities, String::compareToIgnoreCase); cities.forEach(city -> System.out.println(city)); } } \",\"这个时候，再回到集合遍历的例子当中：\",\"System.out::println() \",\"实际上，查看System源码可以发现out实际上是PrintStream的一个对象：\",\" public final static PrintStream out = null; \",\"而println()方法就是PrintStream中的一个方法：\",\" public void println(double x) { synchronized (this) { print(x); newLine(); } } \"]},\"1483\":{\"h\":\"构造方法引用\",\"t\":[\"前面我们介绍过的Supplier函数式接口其中一个很重要的应用就是构造方法引用，因为其不接收参数，返回值的特性正好与构造方法的作用不谋而合，所以，我们可以很轻松的写出如下代码：\",\"public class MethodReferenceDemo { public String getString(Supplier<String> supplier) { return supplier.get() + \\\"test\\\"; } public static void main(String[] args) { MethodReferenceDemo methodReferenceDemo = new MethodReferenceDemo(); System.out.println(methodReferenceDemo.getString(String::new)); } } \",\"除了无参构造，还可以调用有参数的构造方法，这个时候就变成了接收一个参数，返回值：\",\"public class MethodReferenceDemo { public String getString2(String str, Function<String, String> function) { return function.apply(str); } public static void main(String[] args) { MethodReferenceDemo methodReferenceDemo = new MethodReferenceDemo(); System.out.println(methodReferenceDemo.getString2(\\\"hello\\\", String::new)); } } \"]},\"1484\":{\"h\":\"默认方法\",\"t\":[\"在方法引用的最后，我们补充一些关于JDK8中默认方法的相关介绍，首先定义这样两个接口，接口中有同名的默认方法：\",\"public interface MyInterface1 { default void myMethod() { System.out.println(\\\"MyInterface1\\\"); } } \",\"public interface MyInterface2 { default void myMethod() { System.out.println(\\\"MyInterface2\\\"); } } \",\"这个时候，假设有一个类，要实现这两个接口，但是由于这两个接口中有同名的默认方法，所以，编译器无法自动推断出要继承哪一个接口中的默认方法，一般这个时候，处理方式有两种，一种是在实现类中重写方法：\",\"public class MyClass implements MyInterface1, MyInterface2 { @Override public void myMethod() { System.out.println(\\\"MyInterface1\\\"); } public static void main(String[] args) { MyClass myClass = new MyClass(); myClass.myMethod(); } } \",\"这种方式的弊端在于，我们需要将某一个子类中的默认方法实现重写一遍，如果代码很多，既费时，可维护性也比较差，好在JDK为我们提供了另一种方式来完成：\",\"public class MyClass implements MyInterface1, MyInterface2 { @Override public void myMethod() { MyInterface1.super.myMethod(); } public static void main(String[] args) { MyClass myClass = new MyClass(); myClass.myMethod(); } } \",\"对于以上例子我们再做一个小的扩展，增加一个MyInterface1的实现类：\",\"public class MyInterface1Impl implements MyInterface1 { @Override public void myMethod() { System.out.println(\\\"MyInterface1Impl\\\"); } } \",\"这个时候，我们再定义一个类，这个类继承MyInterface1Impl，并且实现MyInterface2：\",\"public class MyClass2 extends MyInterface1Impl implements MyInterface2 { public static void main(String[] args) { MyClass2 myClass2 = new MyClass2(); myClass2.myMethod(); } } \",\"这个时候调用当前类的myMethod()方法并不会报错，也就是说，编译器自动推断出了我们要想调用MyInterface1Impl中的myMethod()方法，还是MyInterface2中的默认方法myMethod()，这实际上是JDK中的一个约定，编译器会认为继承的优先级大于实现，类中的方法才表示具体的行为，而接口更多的时候还是表示一种模板或者契约。\",\"增加默认方法的特性是Java对于支持函数式编程一个非常重要的改变，在上面排序的例子中可以看到，List这样一个顶层的集合增加了排序的方法，试想，如果没有默认方法，那对于想从JDK7升级到JDK8的人无疑是一场灾难，如果一旦在自己的代码实现过List，那意味你需要重写所有的子类，而JDK在很多的接口中都增加了默认方法，为了升级JDK还需要入侵式的修改客户端的代码，这显然是不合适的，那为什么还会增加默认方法的机制呢？其目的，就是为了更为方便的编写函数式的代码，同时也是为了向后兼容的一种妥协，从这一个层面来说，Java的函数式编程并不是完美无暇的，更像是一个裹足前行的人，这也是面向对象带来限制，但我们还是非常振奋，JDK8使我们看到了Java这门古老的语言的全新面貌。\",\"增加默认方法也可以看到，接口和抽象类的区别越来越小了。\",\"在前面的章节我们花费了不少的章节整理了Lambda表达式的相关特性，也举出了不少的例子来展示了Lambda表达式的应用，但总有种纸上谈兵的感觉，还是无法理解Lambda表达式到底可以帮我们做哪些事情？函数式编程又指的是什么？在接下来的章节中，我们就会围绕这两个问题展开。\",\"实际上，Lambda表达式在大多数的场景下，都是与Stream相伴出现的，两个配合使用，更加高效、简洁、优雅的处理集合相关的问题。\",\"首先我们需要了解一些Stream的基本概念，学会新的API使用，在不断的实践中，最后探究Stream的实现原理。一般而言Stream由3个部分组成：\",\"源\",\"零个或多个中间操作\",\"终止操作\",\"流操作的分类又有两种：\",\"惰性求值\",\"及早求值\",\"Stream也可以分为并行流和串行流，可以通过非常简单的方式，就是使用并发来加快运行的效率。\",\"我们首先使用不同的方式来创建一个Stream对象：\",\"public class StreamTest { public static void main(String[] args) { Stream stream1 = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); } } \",\"为什么可以这样创建呢？不妨查看一下Stream这个类中的of()方法：\",\" public static<T> Stream<T> of(T... values) { return Arrays.stream(values); } \",\"可以看到这是一个静态方法，本身接受的是可变参数，并且会调用Arrays中的stream方法：\",\" public static <T> Stream<T> stream(T[] array) { return stream(array, 0, array.length); } \",\"其中的\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"就称之为源，源的意思就是要操作的数据对象，使用相似的方式，我们还可以这样创建Stream：\",\"public class StreamTest { public static void main(String[] args) { Stream stream1 = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); String[] myArray = new String[]{\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"}; Stream stream2 = Stream.of(myArray); Stream stream3 = Arrays.stream(myArray); } } \",\"本质上而言，这几种创建Stream的方式并没有什么区别，其实最常见的，是采用下面的方式来创建流：\",\"public class StreamTest { public static void main(String[] args) { List<String> list = Arrays.asList(myArray); Stream stream = list.stream(); } } \",\"以上就是关于如何创建流的对象的例子，接下来我们看看引入Stream会为我们的编码带来什么样的改变，首先我们创建一个Stream，并且调用它的forEach（）方法：\",\"public class StreamTest2 { public static void main(String[] args) { Stream.of(new int[]{5, 6, 7}).forEach(System.out::println); } } \",\"在这段代码中，我们首先创建了一个元素为5，6，7的Stream对象，并且调用forEach()方法，对流中的每一个元素执行打印的操作。\",\"Stream本身其实也提供了针对与特定数据类型的具化的Stream对象，用来避免自动拆箱装箱带来的性能的损耗，所以这段代码也可以这么写：\",\"public class StreamTest2 { public static void main(String[] args) { IntStream.of(new int[]{5, 6, 7,}).forEach(System.out::println); } } \",\"再举一个例子：\",\"public class StreamTest2 { public static void main(String[] args) { IntStream.range(3, 8).forEach(System.out::println); } } \",\"这样我们就在控制台打印了3到7，我们可以来了解一下这个range()方法：\",\" public static IntStream range(int startInclusive, int endExclusive) { if (startInclusive >= endExclusive) { return empty(); } else { return StreamSupport.intStream( new Streams.RangeIntSpliterator(startInclusive, endExclusive, false), false); } } \",\"可以看到这个方法返回的是包含最小值，不包含最大值的IntStream对象，那如果要包含最大值改怎么做呢？一种方式当然可以调整范围，比如，可以设置范围是（3，9）就可以打印3到8的内容，也可以调用另一个方法：\",\"IntStream.rangeClosed(3, 8).forEach(System.out::println); \",\"我们不妨来看一下这个方法的源码：\",\" public static IntStream rangeClosed(int startInclusive, int endInclusive) { if (startInclusive > endInclusive) { return empty(); } else { return StreamSupport.intStream( new Streams.RangeIntSpliterator(startInclusive, endInclusive, true), false); } } \",\"这样，就顺利的同时包含了较小的值和较大的值。\",\"上面的例子看起来还是相对而言比较简陋的，接下来我们给出一个稍微复杂一点的示例：\",\"public class StreamTest3 { public static void main(String[] args) { List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6); System.out.println(list.stream().map(i -> 2 * i).reduce(0, Integer::sum)); } } \",\"这里我们对于集合中的元素先乘以2，然后求和，这里的map描述的是一种映射，而reduce描述的一种聚合，只有当表达式中具有reduce这样的终止操作的方法的时候，流才会被真正的执行，这就是所谓的终止操作，而map就称之为中间操作。不难看出，与传统的方式，使用函数式的方式，代码变的异常简洁和优雅。\"]},\"1485\":{\"h\":\"Stream类源码解析\",\"t\":[\"在初步了解了Sream给我们来了些什么之后，我们来了解一些关于流的特性：\",\"Collection提供了新的Stream()方法\",\"流不存储值，通过管道的方式获取值\",\"本质是函数式的，对流的操作会生成一个结果，不过并不会修改底层的数据源，集合可以作为流的底层数据源\",\"延迟查找，很多流操作（过滤、映射、排序等）都可以延迟实现\",\"接下来再通过一些实际的例子，来加深对于Stream的理解：\",\"public class StreamTest4 { public static void main(String[] args) { Stream<String> stream = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"helloworld\\\"); String[] stringArray = stream.toArray(length -> new String[length]); String[] strings = stream.toArray(String[]::new); Arrays.asList(stringArray).forEach(System.out::println); } } \",\"上面的例子创建Stream的，那Stream是如何转变成我们常用的List集合呢？这里就要说明一个及其重要的方法collect()：\",\"public class StreamTest4 { public static void main(String[] args) { Stream<String> stream = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"helloworld\\\"); List<String> list = stream.collect(Collectors.toList()); list.forEach(System.out::println); } } \",\"collect()方法是有几个重载的方法，我们来看接收参数最多的这个：\",\" /** * Performs a <a href=\\\"package-summary.html#MutableReduction\\\">mutable * reduction</a> operation on the elements of this stream. A mutable * reduction is one in which the reduced value is a mutable result container, * such as an {@code ArrayList}, and elements are incorporated by updating * the state of the result rather than by replacing the result. This * produces a result equivalent to: * <pre>{@code * R result = supplier.get(); * for (T element : this stream) * accumulator.accept(result, element); * return result; * }</pre> * * <p>Like {@link #reduce(Object, BinaryOperator)}, {@code collect} operations * can be parallelized without requiring additional synchronization. * * <p>This is a <a href=\\\"package-summary.html#StreamOps\\\">terminal * operation</a>. * * @apiNote There are many existing classes in the JDK whose signatures are * well-suited for use with method references as arguments to {@code collect()}. * For example, the following will accumulate strings into an {@code ArrayList}: * <pre>{@code * List<String> asList = stringStream.collect(ArrayList::new, ArrayList::add, * ArrayList::addAll); * }</pre> * * <p>The following will take a stream of strings and concatenates them into a * single string: * <pre>{@code * String concat = stringStream.collect(StringBuilder::new, StringBuilder::append, * StringBuilder::append) * .toString(); * }</pre> * * @param <R> type of the result * @param supplier a function that creates a new result container. For a * parallel execution, this function may be called * multiple times and must return a fresh value each time. * @param accumulator an <a href=\\\"package-summary.html#Associativity\\\">associative</a>, * <a href=\\\"package-summary.html#NonInterference\\\">non-interfering</a>, * <a href=\\\"package-summary.html#Statelessness\\\">stateless</a> * function for incorporating an additional element into a result * @param combiner an <a href=\\\"package-summary.html#Associativity\\\">associative</a>, * <a href=\\\"package-summary.html#NonInterference\\\">non-interfering</a>, * <a href=\\\"package-summary.html#Statelessness\\\">stateless</a> * function for combining two values, which must be * compatible with the accumulator function * @return the result of the reduction */ <R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner); \",\"collect方法接收三个参数，其中的BiConsumer是接收两个参数，并且没有返回值的函数式接口：\",\"@FunctionalInterface public interface BiConsumer<T, U> void accept(T t, U u); } \",\"我们来阅读一下collect方法的说明：\",\"Performs a mutable reduction operation on the elements of this stream. A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList, and elements are incorporated by updating the state of the result rather than by replacing the result. This produces a result equivalent to: \",\"对流当中的元素进行可变的汇聚操作，一个可变的汇聚操作指的是将值汇聚到可变的结果容器，比如ArrayList，并且这个容器是通过更新结果的状态来进行合并的，而不是通过替换结果进行合并的，这个结果相当于下面这段代码：\",\" R result = supplier.get(); for (T element : this stream) accumulator.accept(result, element); return result; \",\"首先会通过supplier.get()方法获取到结果集，然后对流中的元素进行遍历，遍历执行累加器accumulator中的accept，最后返回结果，这里总共有三个步骤，对应的就是collect方法的三个函数式接口：\",\" <R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner); \",\"我们来举一个具体的例子来说明，这段文字的含义：\",\"public class StreamTest4 { public static void main(String[] args) { Stream<String> stream = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"helloworld\\\"); List<String> list = stream.collect(() -> new ArrayList<String>(), (theList, item) -> theList.add(item),(theList1, theList2) -> theList1.addAll(theList2)); } } \",\"supplier就是我们要返回的结果，这里我们选择new一个ArrayList作为返回的容器，accumulator是我们要把流中的元素添加到要返回的结果容器当中，所以这里调用List的add()方法，将流中的元素依次添加到我们新new出来的ArrayList当中，每次将流中的元素添加到的ArrayList时都会新newArrayList，combiner是将上一次返回的结果，添加到的最终的结果theList1当中，当然，这个方法我们也可以用方法引用来完成：\",\" stream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll); \",\"理解了三个参数具体的作用我们具体再往下看：\",\"Like reduce(Object, BinaryOperator), collect operations can be parallelized without requiring additional synchronization.This is a terminal operation. \",\"就像reduce一样，collect无需其他操作就可以很好的支持并行流，并且也是一个终止操作，这也是流式编程给我们带来的好处。\",\"There are many existing classes in the JDK whose signatures are well-suited for use with method references as arguments to collect(). \",\"在JDK中有很多的方法都可以采用方法引用的方式，作为collect()的参数，这里举了两个例子，一个正是我们前面举出的例子：\",\" List<String> asList = stringStream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll); \",\"还有一个例子：\",\" String concat = stringStream.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString(); \",\"这里使用StringBuilder作为最终返回的结果容器，遍历集合中的单个的字符串，最终将他们拼接起来。\",\"最后我们来看一下对于参数的说明：\",\"supplier – a function that creates a new result container. For a parallel execution, this function may be called multiple times and must return a fresh value each time.\",\"accumulator – an associative, non-interfering, stateless function for incorporating an additional element into a result\",\"combiner – an associative, non-interfering, stateless function for combining two values, which must be compatible with the accumulator function\",\"supplier会创建一个新的结果容器，在并行流中可能会多次调用，所以它每次返回的一定是一个新的结果容器，accumulator，它是一个相关的，不冲突的，可关联的一个无状态的一个函数，用于将一个额外的元素合并到结果容器当中，combiner用于合并两个值，它必须和accumulator 是兼容的。\",\"最后我们可以看一个JDK实现的一个例子：\",\" public static <T> Collector<T, ?, List<T>> toList() { return new CollectorImpl<>((Supplier<List<T>>) ArrayList::new, List::add, (left, right) -> { left.addAll(right); return left; }, CH_ID); } \"]},\"1486\":{\"h\":\"Stream实例剖析\",\"t\":[\"首先来看一个具体的例子：\",\"public class StreamTest4 { public static void main(String[] args) { Stream<String> stream = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"helloworld\\\"); ArrayList<String> list = stream.collect(Collectors.toCollection(ArrayList::new)); list.forEach(System.out::println); } } \",\"这里我们使用的Collectors类中的toCollection()方法：\",\"public static <T, C extends Collection<T>> Collector<T, ?, C> toCollection(Supplier<C> collectionFactory) { return new CollectorImpl<>(collectionFactory, Collection<T>::add, (r1, r2) -> { r1.addAll(r2); return r1; }, CH_ID); } \",\"可以看到，它接受一个Supplier参数，这里我们使用构方法引用的方式，这实际上是一种比起toList()更为通用的写法，使用toCollection可以很方便的自定义返回结果容器的类型，比如我们要返回一个LinkedList，我们只需要：\",\"LinkedList<String> list = stream.collect(Collectors.toCollection(LinkedList::new)); \",\"除了将流转化为List，我们也可以转化为Set、Map等，例如：\",\"public class StreamTest4 { public static void main(String[] args) { TreeSet<String> set = stream.collect(Collectors.toCollection(TreeSet::new)); set.forEach(System.out::println); } } \",\"上一章节中，JDK中举出的拼接字符串的例子，实际上在Collectors中有一种更为简洁的实现方案：\",\"public class StreamTest4 { public static void main(String[] args) { Stream<String> stream = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"helloworld\\\"); String str = stream.collect(Collectors.joining()).toString(); } } \",\"之前我们举的例子要么是将集合转化为Stream，要么是将Stream转化为集合，实际使用的时候，需要两者配合使用，举一个这样的例子，将集合中的字符串传化为大写并打印：\",\"public class StreamTest5 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"helloworld\\\", \\\"test\\\"); list.stream().map(String::toUpperCase).collect(Collectors.toList()). forEach(System.out::println); } } \",\"类似这样的代码，才是在实际应用中使用的最多的，其中的map()是JDK为我们提供的API，表示一种映射关系，将集合中的元素映射成后面表达式的结果的操作，再比如，要求出集合中每一个元素的平方并打印：\",\"public class StreamTest5 { public static void main(String[] args) { List<Integer> list2 = Arrays.asList(1, 2, 3, 4); list2.stream().map(item -> item * item).collect(Collectors.toList()). forEach(System.out::println); } } \",\"与map比较类似的还有一个flatmap()方法，它表示将流中元素的界限打破，最终返回一个整体，举个例子：\",\"public class StreamTest5 { public static void main(String[] args) { Stream<List<Integer>> stream = Stream.of(Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6)); stream.flatMap(theList -> theList.stream().map(item -> item * item)).forEach(System.out::println); } } \",\"这里我们首先对于流中的集合进行了平方的操作，然后将所有的元素作为一个整体进行打印。\",\"再来看一个map和flatMap例子，假设我们要对一个集合中的元素提取出单词并去重：\",\"public class StreamTest11 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello welcome\\\", \\\"world hello\\\", \\\"hello world hello\\\", \\\"hello welcome\\\"); list.stream().map(item -> item.split(\\\" \\\")).distinct().collect(Collectors.toList()).forEach(System.out::println); } } \",\"运行的结果：\",\"[Ljava.lang.String;@4eec7777 [Ljava.lang.String;@3b07d329 [Ljava.lang.String;@41629346 [Ljava.lang.String;@404b9385 \",\"这显然是不对的，原因就在于这里我们使用map返回的类型实际上变成了String[]，自然的，后续的去重操作当然也都失败了，那如果要实现这个需求改怎么做呢？就需要调用flatMap方法：\",\"public class StreamTest11 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello welcome\\\", \\\"world hello\\\", \\\"hello world hello\\\", \\\"hello welcome\\\"); list.stream().map(item -> item.split(\\\" \\\")).flatMap(Arrays::stream).distinct(). collect(Collectors.toList()).forEach(System.out::println); } } \",\"再举这样一个例子来加深对于flatMap理解的场景，比如我们要获取两个集合的笛卡尔积，我们就可以：\",\"public class StreamTest12 { public static void main(String[] args) { List<String> list1 = Arrays.asList(\\\"Hi\\\", \\\"Hello\\\", \\\"你好\\\"); List<String> list2 = Arrays.asList(\\\"zhangsan\\\", \\\"lisi\\\", \\\"wangwu\\\", \\\"zhaoliu\\\"); list1.stream().flatMap(item -> list2.stream().map(item2 -> item + \\\" \\\" + item2)). collect(Collectors.toList()).forEach(System.out::println); } } \",\"接下来介绍generate和iterate这两个特殊的方法：\",\"public class StreamTest6 { public static void main(String[] args) { Stream<String> stream = Stream.generate(UUID.randomUUID()::toString); stream.findFirst().ifPresent(System.out::println); } } \",\"接下来介绍iterate方法：\",\"public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) { Objects.requireNonNull(f); final Iterator<T> iterator = new Iterator<T>() { @SuppressWarnings(\\\"unchecked\\\") T t = (T) Streams.NONE; @Override public boolean hasNext() { return true; } @Override public T next() { return t = (t == Streams.NONE) ? seed : f.apply(t); } }; return StreamSupport.stream(Spliterators.spliteratorUnknownSize( iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE), false); } \",\"它的参数UnaryOperator可以简单的看一下：\",\"@FunctionalInterface public interface UnaryOperator<T> extends Function<T, T> { static <T> UnaryOperator<T> identity() { return t -> t; } } \",\"Function这个函数式接口本身接口T类型的参数，返回R类型的结果，这里的UnaryOperator表示接收参数与返回结果类型相同的情况，接下来我们阅读一下iterate的文档：\",\"Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc. The first element (position 0) in the Stream will be the provided seed. For n > 0, the element at position n, will be the result of applying the function f to the element at position n - 1. \",\"这个方法返回无限的、串行的、有序的一个Stream，它是由迭代函数f对于初始值seed的不断迭代，第一个元素作为seed（种子）,而对于n>0，会不断应用n-1次迭代函数f，比如f(seed)、f(f(seed))等等。\",\"举个例子：\",\"public class StreamTest6 { public static void main(String[] args) { Stream.iterate(1, item -> item + 2).limit(10).forEach(System.out::println); } } \",\"需要注意的是，这里之所以使用limit是因为如果不加限制，程序将一直运行下去，这是因为iterate他是无限的。\"]},\"1487\":{\"h\":\"Stream陷阱剖析\",\"t\":[\"首先来看这样一个例子，假设有这样一个流，流中的元素为1，3，5，6，7，11，我们要找出流中大于2的元素，然后将每个元素乘以2，忽略掉流中的前两个元素之后，再取出流中的前两个元素，然后求出流中元素的总和：\",\"public class StreamTest6 { public static void main(String[] args) { Stream<Integer> stream = Stream.iterate(1, item -> item + 2).limit(6); int sum = stream.filter(item -> item > 2).mapToInt(item -> item * 2).skip(2).limit(2).sum(); System.out.println(sum); } } \",\"这里有两个新的方法，skip()表示跳过，而limit()表示取前几个元素。\",\"如果我们改一下需求，把求出流中元素的总和改为求出流中元素的最小值，我们猜想代码可能是这样的：\",\"stream.filter(item -> item > 2).mapToInt(item -> item * 2).skip(2).limit(2).min(); \",\"但是运行之后控制台的输出却不是我们想要的结果，而是这样的：\",\"OptionalInt[14] \",\"原来min()方法的源码是这样的：\",\"OptionalInt min(); \",\"返回的是一个Optional对象，而不是一个普通的Int，类似的max()方法返回的也是Optional对象，原因就在于，求最大值和最小值有可能为空，而求和则不会，如果流中没有元素返回0即可，从本质上来说，是否会直接返回值，还是返回Optional对象，就是取决于是否可能会出现空指针的情况。\",\"public class StreamTest6 { public static void main(String[] args) { Stream<Integer> stream = Stream.iterate(1, item -> item + 2).limit(10); stream.filter(item -> item > 2).mapToInt(item -> item * 2).skip(2).limit(2).max().ifPresent(System.out::println); } } \",\"那如果既想求出最大值，也想求出最小值，也想求出总和，改怎么办呢？\",\"public class StreamTest6 { public static void main(String[] args) { IntSummaryStatistics intSummaryStatistics = stream.filter(item -> item > 2).mapToInt(item -> item * 2).skip(2).limit(2).summaryStatistics(); System.out.println(intSummaryStatistics.getMax()); System.out.println(intSummaryStatistics.getMin()); System.out.println(intSummaryStatistics.getSum()); } } \",\"答案就是调用summaryStatistics()方法。\",\"Stream实际上和文件系统中的IO流有很多类似的性质，比如，Stream只能使用一次：\",\"public class StreamTest6 { public static void main(String[] args) { Stream<Integer> stream = Stream.iterate(1, item -> item + 2).limit(6); System.out.println(stream); System.out.println(stream.filter(item -> item > 2)); System.out.println(stream.distinct()); } } \",\"运行程序，会得到如下的输出：\",\"java.util.stream.SliceOps$1@816f27d java.util.stream.ReferencePipeline$2@53d8d10a Exception in thread \\\"main\\\" java.lang.IllegalStateException: stream has already been operated upon or closed \",\"可以看到我们在调用filter方法之后，就会抛出Stream已经被使用的异常，即便我们使用的不是终止操作，而只是一个中间操作，或者说，对于Stream的操作我们只能进行一次，其实中间操作都会返回一个新的Stream对象，为了说明这一点，我们来举个例子：\",\"public class StreamTest6 { public static void main(String[] args) { Stream<Integer> stream = Stream.iterate(1, item -> item + 2).limit(6); System.out.println(stream); Stream<Integer> stream2 = stream.filter(item -> item > 2); System.out.println(stream2); Stream<Integer> stream3 = stream2.distinct(); System.out.println(stream3); } } \",\"这次我们顺利的打印出了Stream对象，但其实每次打印的Stream对象都是不同的，实际使用的时候，我们更多的是使用链式的写法：\",\"stream.filter(item -> item > 2).distinct(); \",\"接下来我们再了解流的另一个特性：\",\"public class StreamTest7 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); list.stream().map((item->{ String result = item.substring(0, 1).toUpperCase() + item.substring(1); System.out.println(result); return result; })); } } \",\"这段代码会输出什么呢？答案是什么都不会，如果修改成如下：\",\"public class StreamTest7 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); list.stream().map(item -> item.substring(0, 1).toUpperCase() + item.substring(1)).forEach(System.out::println); list.stream().map((item -> { String result = item.substring(0, 1).toUpperCase() + item.substring(1); System.out.println(result); return result; })).forEach(System.out::println); } } \",\"就会顺利的再控制台打印出我们想要的结果了。\",\"这也是流的另一个重要的特性——流是惰性的，流只有在遇到终止操作的时候，才会真正的执行，而map是中间操作，因此流并没有被真正的调用，而forEach是终止操作，所以流会被正常的调用执行。\",\"再来看一个例子：\",\"public class StreamTest8 { public static void main(String[] args) { IntStream.iterate(0, i -> (i + 1) % 2).distinct().limit(6).forEach(System.out::println); } } \",\"在控制台输出了：\",\"0 1 \",\"但程序并没有停止，而是在不停的运行，这是为什么呢？这是因为前面在不断的迭代产生0，1，而去重也并没有等待到新的值，所以程序会无限的运行下去，如果我们将刚才的操作反过来：\",\"IntStream.iterate(0, i -> (i + 1) % 2).limit(6).distinct().forEach(System.out::println); \",\"可以看到，控制台在输出了0，1之后就停止了，这是因为我们限制了只取流中的前六个元素，这提示我们在使用流的使用后一定要注意编写的顺序和流的相关特性。\"]},\"1488\":{\"h\":\"内部迭代和外部迭代\",\"t\":[\"Stream和SQL语句其实非常的相似，例如，要完成这样的一个SQL的功能，使用SQL语句：\",\"select name from student where age > 20 and address = ‘beijing’ order by age desc; \",\"该简单的sql所要表达的意思是：从student这张表中查询出年龄>20并且地址=北京的记录，并且对年龄进行降序排序，排序之后将其名字查找出来。对于sql其实是一个描述性的语言，只描述其行为，而具体如何让db完成这个行为是没有暴露出来的，对于该sql所做的工作如果换成咱们的stream来实现那会是个什么样子呢，伪代码可能是这样的：\",\" students.stream().filter(student -> student.getAge() > 20).filter(student -> student.getAddress().equals(“beijing”)) .sorted(…).forEach(student -> System.out.println(student.getName())); \",\"从表现形式上而言，Stream和SQL非常的类似，这是因为Stream也是属于一种描述性的语句， 整个语句并没有告诉底层Stream要如何去做，等于只要发一些指令给底层就可以了，具体底层怎么做完全不用关心。\",\"如果使用原来传统的方式又该怎么做呢？\",\" List list = new ArrayList<>(); for(int i=0; i < students.size();i++){ Student student = students.get(i); if(student.getAge() > 20 && student.getAddress().equals(“beijing”)){ list.add(student); } } Collections.sort(list. Comparator()…); for(Student student : list){ System.out.println(student.getName()); } \",\"可以看到，使用传统的方式，代码还相当冗余的，并且从易读性上而言，还是Stream的方式更加简洁明了，那什么是外部迭代，什么是内部迭代呢？实际上在Stream出现之前的都称之为外部迭代，使用Stream的就称之为内部迭代。\",\"针对一个集合：\",\"对于上面的例子而言：\",\"集合与我们编写的处理逻辑之间是有清晰的划分的：\",\"那对于Stream内部迭代的方式呢？\",\"总的来说，集合关注的是数据与数据存储本身；而流关注的则是对数据的计算。流与迭代器类似的一点是：流是无法重复使用或消费的，并且流在调用的时候，并不是对于集合中所有的元素先调用第一个filter方法，再调用第二个filter方法，再调用其他方法，实际上并不是这样的，流会将执行的调用链的时候，会有一个容器将所有的操作保存下来，并且针对具体的操作，会优化调用顺序，这一点，在后面源代码分析的时候，就可以看到。\",\"我们一直再说中间操作和终止操作，那如何判断一个操作是中间操作还是终止操作呢？简单来说，中间操纵都会返回一个Stream对象，而终止操作则不会返回Stream类型，可能不返回值，也可能返回其他类型的单个值。\"]},\"1489\":{\"h\":\"流的短路与并发流\",\"t\":[\"单从使用的角度而言，并发流与串行流的区别并不是很大，但在底层实现上是完全不同的。\",\"public class StreamTest9 { public static void main(String[] args) { List<String> list = new ArrayList<>(50000000); for (int i = 0; i < list.size(); i++) { list.add(UUID.randomUUID().toString()); } System.out.println(\\\"==================\\\"); long startTime = System.nanoTime(); list.stream().sorted().count(); long endTime = System.nanoTime(); long millis = TimeUnit.NANOSECONDS.toMillis(endTime - startTime); System.out.println(\\\"=======================\\\"); System.out.println(millis); } } \",\"如果要改用串行流改怎么做呢？仅仅需要将我们调用的方法修改为：\",\" list.parallelStream().sorted().count(); \",\"这也是使用内部迭代给我们带来的另一个好处，至于底层如何充分利用计算机资源帮助我们快速迭代，实际上在框架的底层就已经帮我们实现了，复杂性永远都是存在的，区别在于框架帮助我们实现了多少。当然，你可能会说，既然调用并行流这么方便，那是不是所有的场景下，都可以使用并行流来代替串行流？答案是否定的，并流行并不一定就比串行流的效率高，这取决于解决的实际问题，需要选择合适的方法，才能效率最高，这一点，在后续分析源码的时候就可以看到。\",\"接下来我们讨论有关流的短路问题，首先来看这样一个例子：\",\"public class StreamTest10 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); list.stream().mapToInt(String::length).filter(length -> length == 5).findFirst().ifPresent(System.out::println); } } \",\"显然，如果有长度为5的字符串，就会在控制台打印字符5，将这个例子做如下修改：\",\"public class StreamTest10 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); list.stream().mapToInt(item -> { int length = item.length(); System.out.println(item); return length; }).filter(length -> length == 5).findFirst().ifPresent(System.out::println); } } \",\"控制台会打印什么呢？答案是会在控制台打印出：\",\"hello \",\"为什么会只打印hello呢？原因就在于虽然我们采用的是链式的调用，但其实在调用这些方法的时候并没有先后的顺序，对于流中元素进行处理的时候，会从流中的第一个元素开始应用所有对于流元素的操作，并且对于流的操作也有短路的特性，我们要找到长度为5的字符串，第一个元素就已经满足了所有的操作，所以后面的就不再执行了。\"]},\"1490\":{\"h\":\"分区与分组\",\"t\":[\"我们曾经在内部迭代与外部迭代的章节中提到过，使用Stream的API很像在使用SQL语句，使用SQL语句进行分组的查询是一个很常见的需求，实际上，Stream也对分组提供了强有力的支持。\",\"同样的，我们先创建一个学生类，并生成构造方法、setter、getter方法：\",\"public class Student { private String name; private int score; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getScore() { return score; } public void setScore(int score) { this.score = score; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Student(String name, int score, int age) { this.name = name; this.score = score; this.age = age; } } \",\"然后来创建一些对象：\",\"public class StreamTest13 { public static void main(String[] args) { Student student1 = new Student(\\\"zhangsan\\\", 100, 20); Student student2 = new Student(\\\"lisi\\\", 90, 20); Student student3 = new Student(\\\"wangwu\\\", 90, 30); Student student4 = new Student(\\\"zhangsan\\\", 80, 40); List<Student> students = Arrays.asList(student1, student2, student3, student4); } } \",\"如果我们使用传统的编码方式来实现对于名字的分组操作，大概要经历如下的步骤：\",\"循环列表\",\"取出学生的名字\",\"检查Map中是否存在该名字，不存在则直接添加到该Map中，存在则将Map中的List对象取出来，然后将该Student对象添加到List中\",\"返回Map对象\",\"那如果我们使用函数式的编程方式呢？\",\"students.stream().collect(Collectors.groupingBy(Student::getName)); \",\"只需要这一行代码就可以完成根据姓名对于学生的分组操作，这里面用到了Collectors这个类提供的静态方法groupingBy()，我们可以简单的看一下这个方法接收的参数以及它要完成的事情：\",\" public static <T, K> Collector<T, ?, Map<K, List<T>>> groupingBy(Function<? super T, ? extends K> classifier) { return groupingBy(classifier, toList()); } \",\"这个方法本身是一个Function的函数式接口，Function我们都知道它接收一个参数，并且有返回值，正如它的方法名称那样描述的，我们需要提供分组的依据，这个方法的文档如下：\",\"Returns a Collector implementing a \\\"group by\\\" operation on input elements of type T, grouping elements according to a classification function, and returning the results in a Map. \",\"这个方法对于给定的输入元素进行了排序的操作，并且返回了一个Map集合，看到这里我们就明白了，T实际上表示的就是流中的每个元素的类型，而我们通过方法引用的方式，返回了流中Student的姓名字段，流就会自动的为我们根据姓名来进行分类了,并且姓名这个字段会作为分组的key。\",\"如果要根据年龄来分组呢，显然只要将分组的key换成分数就可以了：\",\"students.stream().collect(Collectors.groupingBy(Student::getScore)); \",\"接下来，我们尝试实现一个稍微复杂的需求，假设我们要实现与这样的SQL语句相同的功能：\",\"select name,count(*) from student group by name; \",\"这里我们就要调用groupingBy的一个重载的方式来实现：\",\" students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.counting())); \",\"我们首先来看一下这里面调用的counting()方法：\",\" public static <T> Collector<T, ?, Long> counting() { return reducing(0L, e -> 1L, Long::sum); } \",\"它的相关说明：\",\"Returns a Collector accepting elements of type T that counts the number of input elements. If no elements are present, the result is 0. \",\"这个方法会统计流中元素的个数，如果没有元素，就会返回0。\",\"我们通过这种方式就实现了上述SQL的需求，运行程序就会在控制台打印：\",\"{lisi=1, zhangsan=2, wangwu=1} \",\"我们再举一个例子，之前我们是对于分组中的元素个数进行统计，那如果我们想分组的时候也统计分数的平均值，这里我们也是需要使用另一个Collectors中的方法：\",\"students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.averagingDouble(Student::getScore))); \",\"运行效果如下：\",\"{lisi=90.0, zhangsan=90.0, wangwu=90.0} \",\"与分组相关的实际上还有一个概念叫做分区，分区可以认为是特殊的分组，它只会分成两组，调用的Api分别是：\",\"分组：group by\",\"分区：partition by\",\"比如，90分以上的分成一组，90分以下的分成一组：\",\"students.stream().collect(Collectors.partitioningBy(student -> student.getScore() >= 90)); \",\"运行的结果：\",\"{false=[stream.Student@3d494fbf], true=[stream.Student@1ddc4ec2, stream.Student@133314b, stream.Student@b1bc7ed]} \",\"至此，对于JDK8中的重要的API全部都介绍完成，学会使用是第一步也是非常重要的一步，在长时间的练习和记忆中，我们才能体会到函数式编程带给我们巨大好处，如果只是从使用的角度而言，掌握本章及之前的内容对于一般的开发者，完全是够用的，然而我想这是远远不够的，学习JDK中优秀的源码，反过来加深我们使用的时候的理解，达到相互促进的作用，这才是更重要的，因此，从下一章节开始，我们将系统而全面的分析JDK是如何实现函数式编程，以及我们之前使用的诸多的API在底层到底是如何实现的。\",\"Stream的源码复杂而多变，要掌握整个的流程，我们就不得不先要理清楚一些及其重要的概念和几个核心类的作用，当然一开始这是不太容易能够理解的，但是，这会为后面我们能完整的看到流的整个调用顺序打下良好的基础。\",\"首先我们为接下来的部分提前定义好一个学生类作为我们分析源码的入口：\",\"public class Student { private String name; private int score; public String getName() { return name; } public Student(String name, int score) { this.name = name; this.score = score; } @Override public String toString() { return \\\"Student{\\\" + \\\"name='\\\" + name + '\\\\'' + \\\", score=\\\" + score + '}'; } public void setName(String name) { this.name = name; } public int getScore() { return score; } public void setScore(int score) { this.score = score; } } \"]},\"1491\":{\"h\":\"Comparator源码分析及实践\",\"t\":[\"Comparator并不是JDK8新增加的内容，但是JDK8对它做了一定程度的增强，在函数式编程中非常的常见，所以也非常的重要，在正式进入Stream源码分析之前，有必要了解关于Comparator比较器的内容。\",\"@FunctionalInterface public interface Comparator<T> { int compare(T o1, T o2); } \",\"首先可以看到这是一个函数式接口，拥有唯一的抽象方法compare，这个方法接口两个参数并且有返回值，并且在这个类中，JDK从1.8开始增加了若干个默认方法。\",\"假如我们要对一个字符串数据按照首字母进行排序：\",\"public class MyComparatorTest { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"nihao\\\", \\\"hello\\\", \\\"world\\\", \\\"welcome\\\"); Collections.sort(list); System.out.println(list); } } \",\"如果要按照长度来进行排序：\",\"Collections.sort(list, (item1, item2) -> item1.length() - item2.length()); \",\"也可以使用方法引用的方式来实现：\",\"Collections.sort(list, Comparator.comparingInt(String::length)); \",\"如果是降序则：\",\"Collections.sort(list, (item1, item2) -> item2.length() - item1.length()); \",\"同样的，也可以使用方法引用的方式来实现，只是这里我们调用新的方法reversed：\",\"Collections.sort(list, Comparator.comparingInt(String::length).reversed()); \",\"但是如果你这么写的话，就会发现有问题：\",\"Collections.sort(list, Comparator.comparingInt(item -> item.length()).reversed()); \",\"看起来与上面的写法是完全等价的，但IDE却会提示：\",\"cannot resolve method 'length()' \",\"原因就在于，编译器会认为此时的item是一个Object类型的对象，如果要正常编译运行，就需要显示的声明类型：\",\"Collections.sort(list, Comparator.comparingInt((String item) -> item.length()).reversed()); \",\"在我们之前的所有的例子当中，编译器都可以自动的推断出元素的类型，在这个例子当中，接收的参数ToIntFunction<? super T>由于没有明确的上下文（可能是T类型，也有可能是T类型以上的类型），并且由于调用了reversed获取了新的比较器，所以编译器没有办法准确的推断出类型：\",\" public static <T> Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor) { Objects.requireNonNull(keyExtractor); return (Comparator<T> & Serializable) (c1, c2) -> Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2)); } \",\"这里为什么会是T类型以及T类型以上的类型呢？简而言之，就是可以传入自己本身以及父类的比较器，而如果传入的是父类型的比较器，比较完成之后还是会强转会原来的类型。\",\"其实我们也可以直接调用list的sort方法：\",\"list.sort(Comparator.comparingInt(String::length).reversed()); \",\"上面的方法都是一次排序，接下来我们看多次排序的方法，比如现根据名称排序，排好序之后对于名称相同的再根据分数进行排序：\",\"Collections.sort(list, Comparator.comparingInt(String::length).thenComparing((item1, item2) -> item1.compareToIgnoreCase(item2))); \",\"其实我们也可以这样调用：\",\"Collections.sort(list,Comparator.comparingInt(String::length).thenComparing(String.CASE_INSENSITIVE_ORDER)); \",\"这里我们使用的静态的常量是：\",\" public static final Comparator<String> CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator(); \",\"这个类本身就定义在String类当中：\",\" private static class CaseInsensitiveComparator implements Comparator<String>, java.io.Serializable { // use serialVersionUID from JDK 1.2.2 for interoperability private static final long serialVersionUID = 8575799808933029326L; public int compare(String s1, String s2) { int n1 = s1.length(); int n2 = s2.length(); int min = Math.min(n1, n2); for (int i = 0; i < min; i++) { char c1 = s1.charAt(i); char c2 = s2.charAt(i); if (c1 != c2) { c1 = Character.toUpperCase(c1); c2 = Character.toUpperCase(c2); if (c1 != c2) { c1 = Character.toLowerCase(c1); c2 = Character.toLowerCase(c2); if (c1 != c2) { // No overflow because of numeric promotion return c1 - c2; } } } } return n1 - n2; } \",\"而对于thenComparing方法而言：\",\"Returns a lexicographic-order comparator with another comparator. If this Comparator considers two elements equal, i.e. compare(a, b) == 0, other is used to determine the order. \",\"与另一个比较器相比，它返回一个字典顺序的比较器，如果它的前一个比较器返回是元素的相等的情况，即compare(a, b) == 0的情况下，当前传入的比较器就会发挥作用，进行二次排序，这意味着，如果前面的比较器返回的结果不是0，那么后面的比较器就不会再调用，这一点在源代码中也有体现：\",\" default Comparator<T> thenComparing(Comparator<? super T> other) { Objects.requireNonNull(other); return (Comparator<T> & Serializable) (c1, c2) -> { int res = compare(c1, c2); // 当比较的结果不为0的时候直接返回，相等再执行传入的比较器。 return (res != 0) ? res : other.compare(c1, c2); }; } \",\"当然，你还可以这么做：\",\"Collections.sort(list,Comparator.comparingInt(String::length).thenComparing(Comparator.comparing(String::toLowerCase))); \",\"类似的，比较器也可以进行复合：\",\"Collections.sort(list, Comparator.comparingInt(String::length).thenComparing(String::toLowerCase, Comparator.reverseOrder())); \",\"比这个例子稍微复杂一个例子：\",\"Collections.sort(list,Comparator.comparingInt(String::length).reversed().thenComparing(String::toLowerCase, Comparator.reverseOrder())); \"]},\"1492\":{\"h\":\"Collector源码分析\",\"t\":[\"Collector无疑是整个Stream源码中及其重要的一个类，了解它对于我们认识Stream类有着及其关键的作用，首先回到我们之前的例子当中：\",\"public class StreamTest1 { public static void main(String[] args) { Student student1 = new Student(\\\"zhangsan\\\", 80); Student student2 = new Student(\\\"lisi\\\", 90); Student student3 = new Student(\\\"wangwu\\\", 100); Student student4 = new Student(\\\"zhaoliu\\\", 90); List<Student> students = Arrays.asList(student1, student2, student3, student4); List<Student> studentList = students.stream().collect(Collectors.toList()); studentList.forEach(System.out::println); } } \",\"毫无疑问，到目前这个阶段，这样的代码我们应该已经掌握的非常的熟练了，现在假设说要求使用流的方式求出列表的长度改怎么做呢？你可以使用Collectors中的静态方法：\",\" System.out.println(\\\"count: \\\" + students.stream().collect(Collectors.counting())); \",\"可以看到，实际使用的时候，使用collect（收集器）的频率非常的高，collect本身的定义是这样的：\",\"<R, A> R collect(Collector<? super T, A, R> collector); \",\"它本身接收一个参数叫做collector，是Collector类型的，接下来的章节重点分析这个类。\",\"A mutable reduction operation that accumulates input elements into a mutable result container, optionally transforming the accumulated result into a final representation after all input elements have been processed. Reduction operations can be performed either sequentially or in parallel. Examples of mutable reduction operations include: accumulating elements into a Collection; concatenating strings using a StringBuilder; computing summary information about elements such as sum, min, max, or average; computing \\\"pivot table\\\" summaries such as \\\"maximum valued transaction by seller\\\", etc. The class Collectors provides implementations of many common mutable reductions. \",\"它是一个可变的汇聚操作，作用是将输入元素累积到一个可变的结果容器当中。它可以在所有的元素都处理完毕后，将累积的结果转换为一个最终的表示（这是一个可选的操作），它支持串行与并行两种方式执行。什么是可变的汇聚操作呢？比如将集合中的元素添加到Collection当中，再比如使用StringBuilder将字符串拼接起来，计算关于元素的求和、最小值、最大值、平均值，这也是一种可变操作，计算“数据透视图”的时候一些汇总信息，比如计算卖方交易数量的最大值，Collectors提供了很多对于常见的可变的汇聚操作的实现（Collectors是Collector的实现类，而Collectors本身实际上是一个工厂）。\",\"A Collector is specified by four functions that work together to accumulate entries into a mutable result container, and optionally perform a final transform on the result. They are: \",\"Collector是由以下四个方法构成，用来完成向一个可变结果容器当中添加元素的，并且对于结果进行最终的转换：\",\"creation of a new result container (supplier())\",\"incorporating a new data element into a result container (accumulator())\",\"combining two result containers into one (combiner())\",\"performing an optional final transform on the container (finisher())\",\"A function that creates and returns a new mutable result container. \",\"supplier()是用来创建新的可变的结果容器。\",\"A function that folds a value into a mutable result container. \",\"accumulator()是用来将一个新的数据元素添加到结果容器当中。\",\"A function that accepts two partial results and merges them. The combiner function may fold state from one argument into the other and return that, or may return a new result container. \",\"combiner函数接收两个部分的结果并且合并它们，combiner函数可以将状态从一个折叠成为另一个，并且返回它们，也可能返回一个新的结果容器，实际上这个是在并行中使用的。\",\"Perform the final transformation from the intermediate accumulation type A to the final result type R. If the characteristic IDENTITY_TRANSFORM is set, this function may be presumed to be an identity transform with an unchecked cast from A to R. \",\"是将中间的累积类型转换称为最终的结果类型，如果设置了IDENTITY_TRANSFORM这个特性，那么这个函数就会直接将A转型为R。\",\"Collectors also have a set of characteristics, such as Collector.Characteristics.CONCURRENT, that provide hints that can be used by a reduction implementation to provide better performance. \",\"Collectors还有一个描述特征的的集合，比如Collector.Characteristics.CONCURRENT，它可以通过不同的枚举值来提高并发流的执行效率。\",\" enum Characteristics { CONCURRENT， UNORDERED, IDENTITY_FINISH } \",\"这个枚举是定义在Collector这个接口当中的，首先来看一下类的说明：\",\"Characteristics indicating properties of a Collector, which can be used to optimize reduction implementations. \",\"Characteristics是Collector的一个属性，能够优化汇聚操作。\",\"A sequential implementation of a reduction using a collector would create a single result container using the supplier function, and invoke the accumulator function once for each input element. A parallel implementation would partition the input, create a result container for each partition, accumulate the contents of each partition into a subresult for that partition, and then use the combiner function to merge the subresults into a combined result. \",\"对于流的串行实现会创建一个单个的结果容器，并且每个元素会调用accumulator方法一次，而对于并行实现将会对输入进行分区，对于每一个分区都会创建一个结果容器，然后使用combiner方法将每个分区的结果容器当中的内容进行合并。\",\"To ensure that sequential and parallel executions produce equivalent results, the collector functions must satisfy an identity and an associativity constraints. \",\"为了确保串行与并行生成等价的结果，collector必须满足两个条件，即identity（同一性）和associativity（结合性）。\",\"The identity constraint says that for any partially accumulated result, combining it with an empty result container must produce an equivalent result. That is, for a partially accumulated result a that is the result of any series of accumulator and combiner invocations, a must be equivalent to combiner.apply(a, supplier.get()). \",\"同一性指的是，部分累积的结果与一个空的结果容器运算之后还是它本身，这也就是说，对于一个部分累积的结果a而言，它要满足combiner.apply(a, supplier.get())等于a。\",\"The associativity constraint says that splitting the computation must produce an equivalent result. That is, for any input elements t1 and t2, the results r1 and r2 in the computation below must be equivalent: \",\"结合性指的是分割计算也会得到一个等价的结果，也就是说对于任意的输入t1和t2，和产生的结果r1和r2，下面的计算是等价的。\",\" // 串行操作 A a1 = supplier.get(); accumulator.accept(a1, t1); accumulator.accept(a1, t2); R r1 = finisher.apply(a1); // 并行操作 A a2 = supplier.get(); accumulator.accept(a2, t1); A a3 = supplier.get(); accumulator.accept(a3, t2); R r2 = finisher.apply(combiner.apply(a2, a3)); \",\"也就是说无论对于串行操作还是并行操作，最终生成的结果必须是等价的。\",\"For collectors that do not have the UNORDERED characteristic, two accumulated results a1 and a2 are equivalent if finisher.apply(a1).equals(finisher.apply(a2)). For unordered collectors, equivalence is relaxed to allow for non-equality related to differences in order. (For example, an unordered collector that accumulated elements to a List would consider two lists equivalent if they contained the same elements, ignoring order.) \",\"对于没有UNORDERED特性的collectors来说，如果finisher.apply(a1).equals(finisher.apply(a2))，这两种累加的结果是等价的，对于无序的要求就被放松了，它会考虑到顺序上的区别带来的不相等性，比如无序的collector它累积元素到一个List当中，就会两个List是相同的，他们包含了相同的元素，忽略了顺序。\",\"Libraries that implement reduction based on Collector, such as Stream.collect(Collector), must adhere to the following constraints: \",\"基于Collector实现汇聚操作的库，比如Stream.collect(Collector)，必须要遵守下面的约定。\",\"The first argument passed to the accumulator function, both arguments passed to the combiner function, and the argument passed to the finisher function must be the result of a previous invocation of the result supplier, accumulator, or combiner functions. \",\"传递给accumulator方法的第一个参数，以及传递给combiner方法的两个参数，以及传递给finisher的参数，它们必须都是result supplier, accumulator, combiner上一次调用的结果。\",\"看到这里还是比较难以理解的，我们首先需要理解Collector泛型的含义：\",\"<T> – the type of input elements to the reduction operation <A> – the mutable accumulation type of the reduction operation (often hidden as an implementation detail) <R> – the result type of the reduction operation \",\"T类型表示进行汇聚操作的输入元素的类型，即流中的每一个元素的类型，A类型表示汇聚操作的可变的累积类型，可以认为是每次中间结果容器的类型，R类型表示汇聚操作的结果类型，这个时候我们再来分析一个这四个方法对应的泛型：\",\"Supplier<A> supplier(); BiConsumer<A, T> accumulator(); BinaryOperator<A> combiner(); Function<A, R> finisher(); \",\"BinaryOperator是因为合并的是两个部分的结果容器的类型，那最终的结果一定也是A类型，从泛型的角度就可以清楚的认识到，对于每一次的调用，supplier提供的结果容器就会传递给accumulator，而accumulator将流中待处理的元素添加到结果容器之后，又将这个部分结果传递给combiner，依次类推。\",\"The implementation should not do anything with the result of any of the result supplier, accumulator, or combiner functions other than to pass them again to the accumulator, combiner, or finisher functions, or return them to the caller of the reduction operation. \",\"对于具体的实现不应该对生成的supplier、accumulator、combiner做任何的事情，除了将他们再一次传递给accumulator、combiner或者finisher方法，否则将他们返回给汇聚操作的调用者。\",\"If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again. \",\"如果一个结果被传递给combiner或者finisher函数了，并没有返回相同的类型的对象，那么它就再也不会被使用了。\",\"Once a result is passed to the combiner or finisher function, it is never passed to the accumulator function again. \",\"一旦一个结果被传递给了combiner或者finisher方法，它就不会再被accumulator方法使用了（这是因为调用顺序的原因）。\",\"For non-concurrent collectors, any result returned from the result supplier, accumulator, or combiner functions must be serially thread-confined. This enables collection to occur in parallel without the Collector needing to implement any additional synchronization. The reduction implementation must manage that the input is properly partitioned, that partitions are processed in isolation, and combining happens only after accumulation is complete. \",\"对于非并发的collectors，从supplier, accumulator, 或者 combiner中返回的结果都一定是线程封闭的，不会被其他线程使用，这样在并发的情况下，就不用再做其他的操作来保证线程安全，每一个部分的操作都是独立的，并且只有当部分完成之后猜会进行合并的操作。\",\"For concurrent collectors, an implementation is free to (but not required to) implement reduction concurrently. A concurrent reduction is one where the accumulator function is called concurrently from multiple threads, using the same concurrently-modifiable result container, rather than keeping the result isolated during accumulation. A concurrent reduction should only be applied if the collector has the Collector.Characteristics.UNORDERED characteristics or if the originating data is unordered. \",\"对于并发的collectors，实现是可以自由的实现，一个多线程的汇聚操作指的是accumulator同时被多个线程调用，他们可以使用相同的可以并发修改的结果容器，而不是保持独立，一个并发的结果容器在什么情况下使用呢？只有当特性值设置为UNORDERED的时候，或者数据源本身不要求有序。\",\"In addition to the predefined implementations in Collectors, the static factory methods of(Supplier, BiConsumer, BinaryOperator, Characteristics...) can be used to construct collectors. For example, you could create a collector that accumulates widgets into a TreeSet with: \",\"除了在Collectors预先定义好的静态工厂方法可以创建一个收集器之外，还可以使用Collector中的of方法，比如你可以使用下面的方式将widget累积到TreeSet当中：\",\"Collector<Widget, ?, TreeSet<Widget>> intoSet = Collector.of(TreeSet::new, TreeSet::add, (left, right) -> { left.addAll(right); return left; }); \",\"实际上就是除了预先定义好的收集器，我们可以通过Collector中的of方法实现自定的收集器。\",\"Performing a reduction operation with a Collector should produce a result equivalent to: \",\"使用一个Collector执行汇聚操作会生成的结果应该和下面的结果等价:\",\"R container = collector.supplier().get(); for (T t : data) collector.accumulator().accept(container, t); return collector.finisher().apply(container); \",\"这其实就是汇聚操作的整个过程。\",\"However, the library is free to partition the input, perform the reduction on the partitions, and then use the combiner function to combine the partial results to achieve a parallel reduction. (Depending on the specific reduction operation, this may perform better or worse, depending on the relative cost of the accumulator and combiner functions.) \",\"然而，库可以自由的对输入元素分组与分区，在每一个分区上执行这种汇聚操作，然后使用combiner方法合并部分的结果执行一个并行的汇聚操作（取决于具体的并行操作的类型，这可能效率高，也可能效率会变低，这取决于accumulator和combiner消耗的成本和代价）。\",\"Collectors are designed to be composed; many of the methods in Collectors are functions that take a collector and produce a new collector. For example, given the following collector that computes the sum of the salaries of a stream of employees: \",\"收集器是被设计成可以组合的，这意味着，Collectors很多方法可以接收collector作为参数返回一个新的collector，例如一个员工构成的流的工资的总数：\",\" Collector<Employee, ?, Integer> summingSalaries = Collectors.summingInt(Employee::getSalary)) \",\"如果我们想实现收集器的复合改怎么做呢？\",\"If we wanted to create a collector to tabulate the sum of salaries by department, we could reuse the \\\"sum of salaries\\\" logic using Collectors.groupingBy(Function, Collector): \",\"如果以向创建一个根据部门对于工资的总和表格化，我们就可以重用“工资总和”逻辑，然后使用分组方法Collectors.groupingBy(Function, Collector):\",\" Collector<Employee, ?, Map<Department, Integer>> summingSalariesByDept = Collectors.groupingBy(Employee::getDepartment, summingSalaries); \",\"这里的第二个参数就是我们上面定义过的收集器，这就实现了收集器的复合。\"]},\"1493\":{\"h\":\"Collector实践\",\"t\":[\"Collector接口有且仅有唯一的实现类CollectorImpl：\",\" static class CollectorImpl<T, A, R> implements Collector<T, A, R> { private final Supplier<A> supplier; private final BiConsumer<A, T> accumulator; private final BinaryOperator<A> combiner; private final Function<A, R> finisher; private final Set<Characteristics> characteristics; CollectorImpl(Supplier<A> supplier, BiConsumer<A, T> accumulator, BinaryOperator<A> combiner, Function<A,R> finisher, Set<Characteristics> characteristics) { this.supplier = supplier; this.accumulator = accumulator; this.combiner = combiner; this.finisher = finisher; this.characteristics = characteristics; } CollectorImpl(Supplier<A> supplier, BiConsumer<A, T> accumulator, BinaryOperator<A> combiner, Set<Characteristics> characteristics) { this(supplier, accumulator, combiner, castingIdentity(), characteristics); } @Override public BiConsumer<A, T> accumulator() { return accumulator; } @Override public Supplier<A> supplier() { return supplier; } @Override public BinaryOperator<A> combiner() { return combiner; } @Override public Function<A, R> finisher() { return finisher; } @Override public Set<Characteristics> characteristics() { return characteristics; } } \",\"需要注意的是，这个类没有定义在一个单独的文件当中，而是定义在Collectors当中，这个类本身并没有做任何事情，只是根据Collector接口的要求，将需要的属性和方法定义好。这么做的理由是什么呢？实际上是一种设计上的考量，Collectors类被用来生产一些常见的方法，它绝大部分的方法都是静态方法，可以直接调用，而作为Collector的工厂，所有的方法一定会返回CollectorImpl类型，而在别的地方，又不会用到CollectorImpl，所以设计者直接将这个类作为一个静态的内部类。\",\"接下来我们就围绕Collectors为我们提供的诸多的静态方法展开，了解这些方法的使用以及实现细节。\",\"Implementations of Collector that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc. \",\"Collectors实现了Collector接口并提供了很多很有用的汇聚操作，比如将元素累积到一个集合当中，比如摘要（最大值、最小值、平均值等等）。\",\"The following are examples of using the predefined collectors to perform common mutable reduction tasks: \",\"下面的例子就是使用JDK预先定义好的方法来执行可变的汇聚任务：\",\" // Accumulate names into a List List<String> list = people.stream().map(Person::getName).collect(Collectors.toList()); // Accumulate names into a TreeSet Set<String> set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new)); // Convert elements to strings and concatenate them, separated by commas String joined = things.stream() .map(Object::toString) .collect(Collectors.joining(\\\", \\\")); // Compute sum of salaries of employee int total = employees.stream() .collect(Collectors.summingInt(Employee::getSalary))); // Group employees by department Map<Department, List<Employee>> byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment)); // Compute sum of salaries by department Map<Department, Integer> totalByDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary))); // Partition students into passing and failing Map<Boolean, List<Student>> passingFailing = students.stream() .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD)); \",\"在完整的理解了收集器相关的概念之后，我们可以看一些具体的例子，针对于之前的学生的集合，如果我们想求出学生分数的最小值：\",\"students.stream().collect(Collectors.minBy(Comparator.comparingInt(Student::getScore))).ifPresent(System.out::println); \",\"如果是最大值呢？\",\"students.stream().collect(Collectors.maxBy(Comparator.comparingInt(Student::getScore))).ifPresent(System.out::println); \",\"如果是平均值呢？\",\"System.out.println( students.stream().collect(Collectors.averagingInt(Student::getScore))); \",\"如果是求出分数的总和呢？\",\"System.out.println(students.stream().collect(Collectors.summingInt(Student::getScore))); \",\"当然也可以调用统计的方法一次将这些特征值都求出来：\",\"System.out.println(students.stream().collect(Collectors.summarizingInt(Student::getScore))); \",\"如果想将学生的名字使用字符串拼接呢？\",\"System.out.println(students.stream().map(Student::getName).collect(Collectors.joining())); \",\"还可以使用逗号分隔：\",\"System.out.println(students.stream().map(Student::getName).collect(Collectors.joining(\\\",\\\"))); \",\"还可以拼接前缀和后缀：\",\"System.out.println(students.stream().map(Student::getName).collect(Collectors.joining(\\\",\\\",\\\"<begin>\\\",\\\"<end>\\\"))); \",\"除了这些常规的操作，其实对于分组的操作还可以进行二级分组：\",\"students.stream().collect(Collectors.groupingBy(Student::getScore,Collectors.groupingBy(Student::getName))); \",\"类似的对于分区的操作也可以进行二级分区：\",\"students.stream().collect(Collectors.partitioningBy(student -> student.getScore() > 90, Collectors. partitioningBy(student -> student.getScore() > 80))); \",\"分组和分区还可以互相嵌套：\",\"students.stream().collect(Collectors.partitioningBy(student -> student.getScore() > 80, Collectors.counting())); \",\"下面我们来看一个稍微复杂一点的例子：\",\"students.stream().collect(Collectors.groupingBy(Student::getName,Collectors.collectingAndThen(Collectors.minBy(Comparator.comparingInt(Student::getScore)), Optional::get))); \"]},\"1494\":{\"h\":\"自定义Collector\",\"t\":[\"在进行Collector源码分析的时候，我们提到过Characteristics这个内部枚举类，接下来我们首先分析每一个枚举项代表的含义：\",\"1、CONCURRENT\",\"Indicates that this collector is concurrent, meaning that the result container can support the accumulator function being called concurrently with the same result container from multiple threads. If a CONCURRENT collector is not also UNORDERED, then it should only be evaluated concurrently if applied to an unordered data source. \",\"CONCURRENT表示当前的收集器是并发的，这意味着中间结果容器支持使用多线程进行并发访问，CONCURRENT并不是UNORDERED，只有无序的数据源才可以使用这个属性。\",\"2、UNORDERED\",\"Indicates that the collection operation does not commit to preserving the encounter order of input elements. (This might be true if the result container has no intrinsic order, such as a Set.) \",\"UNORDERED意味着收集的操作并不确保保留输入元素的顺序（可以用在结果容器不要求有序的场景下，比如Set）\",\"3、IDENTITY_FINISH\",\"Indicates that the finisher function is the identity function and can be elided. If set, it must be the case that an unchecked cast from A to R will succeed. \",\"IDENTITY_FINISH表示finisher方法就是identity方法，可以被省略掉，如果设置了这个属性，那么就要确保从A类型到R类型的强制转换是可以成功的。\",\"接下来我们实现一个自定义的收集器：\",\"public class MySetCollector<T> implements Collector<T, Set<T>, Set<T>> { @Override public Supplier<Set<T>> supplier() { System.out.println(\\\"supplier invoked!\\\"); return HashSet::new; } @Override public BiConsumer<Set<T>, T> accumulator() { System.out.println(\\\"accmulator invoked!\\\"); // 这里不能调用HashSet::add，因为无法保证与supplier()方法返回的中间结果容器类型相同 return Set::add; } @Override public BinaryOperator<Set<T>> combiner() { System.out.println(\\\"combiner invoked!\\\"); return (set1, set2) -> { set1.addAll(set2); return set1; }; } @Override public Function<Set<T>, Set<T>> finisher() { System.out.println(\\\"finisher invoked!\\\"); return Function.identity(); } @Override public Set<Characteristics> characteristics() { System.out.println(\\\"characteristics invoked!\\\"); return Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH, Characteristics.UNORDERED)); } public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"welcome\\\"); Set<String> set = list.stream().collect(new MySetCollector<>()); System.out.println(set); } } \",\"程序运行的结果如下：\",\"supplier invoked! accmulator invoked! combiner invoked! characteristics invoked! characteristics invoked! [world, hello, welcome] \",\"可以看到supplier、accumulator、combiner分别执行了一次，而characteristics执行了两次，只有finisher没有被调用。\",\" public final <R, A> R collect(Collector<? super P_OUT, A, R> collector) { A container; // 如果是并行流 if (isParallel() && (collector.characteristics().contains(Collector.Characteristics.CONCURRENT)) && (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) { container = collector.supplier().get(); BiConsumer<A, ? super P_OUT> accumulator = collector.accumulator(); forEach(u -> accumulator.accept(container, u)); } else { container = evaluate(ReduceOps.makeRef(collector)); } // characteristics()在这里被第二次调用，用于判断中间结果容器与最终返回的类型是否相同,如果包含了IDENTITY_FINISH这个特性，直接进行强制类型转换，会将中间结果容器强制转换为最终的结果类型。 return collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH) ? (R) container : collector.finisher().apply(container); } \",\"这里我们显然是串行流，所以直接进入到第二种情况，首先我们来看一下ReduceOps的makeRef方法：\",\" public static <T, I> TerminalOp<T, I> makeRef(Collector<? super T, I, ?> collector) { // 我们的方法就是在这里被调用了，返回了supplier、accumulator、combiner三个对象。 Supplier<I> supplier = Objects.requireNonNull(collector).supplier(); BiConsumer<I, ? super T> accumulator = collector.accumulator(); BinaryOperator<I> combiner = collector.combiner(); class ReducingSink extends Box<I> implements AccumulatingSink<T, I, ReducingSink> { @Override public void begin(long size) { state = supplier.get(); } @Override public void accept(T t) { accumulator.accept(state, t); } @Override public void combine(ReducingSink other) { state = combiner.apply(state, other.state); } } return new ReduceOp<T, I, ReducingSink>(StreamShape.REFERENCE) { @Override public ReducingSink makeSink() { return new ReducingSink(); } // Characteristics()在这里被第一次调用，用于判断是否有序 @Override public int getOpFlags() { return collector.characteristics().contains(Collector.Characteristics.UNORDERED) ? StreamOpFlag.NOT_ORDERED : 0; } }; } \",\"为了验证关于Characteristics方法的调用逻辑，我们去掉characteristics方法中的枚举项IDENTITY_FINISH：\",\" @Override public Set<Characteristics> characteristics() { System.out.println(\\\"characteristics invoked!\\\"); return Collections.unmodifiableSet(EnumSet.of( Characteristics.UNORDERED)); } \",\"观察结果，finsher就得到了调用：\",\"supplier invoked! accmulator invoked! combiner invoked! characteristics invoked! characteristics invoked! finisher invoked! [world, hello, welcome] \",\"接下来我们定义一个中间结果容器需要进行类型转换的例子：\",\"public class MySetCollector2<T> implements Collector<T, Set<T>, Map<T, T>> { @Override public Supplier<Set<T>> supplier() { System.out.println(\\\"supplier invoked!\\\"); return HashSet::new; } @Override public BiConsumer<Set<T>, T> accumulator() { System.out.println(\\\"accmulator invoked!\\\"); return (set, item) -> set.add(item); } @Override public BinaryOperator<Set<T>> combiner() { System.out.println(\\\"combiner invoked!\\\"); return (set1, set2) -> { set1.addAll(set2); return set1; }; } @Override public Function<Set<T>, Map<T, T>> finisher() { System.out.println(\\\"finisher invoked!\\\"); return set -> { Map<T, T> map = new HashMap<>(10); set.forEach(item -> map.put(item, item)); return map; }; } @Override public Set<Characteristics> characteristics() { System.out.println(\\\"characteristics invoked!\\\"); return Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED)); } public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"welcome\\\", \\\"hello\\\", \\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\", \\\"e\\\", \\\"f\\\", \\\"g\\\"); Set<String> set = new HashSet<>(); set.addAll(list); System.out.println(\\\"set: \\\" + set); Map<String, String> map = set.stream().collect(new MySetCollector2<>()); System.out.println(map); } } \",\"执行的结果：\",\"supplier invoked! accmulator invoked! combiner invoked! characteristics invoked! characteristics invoked! finisher invoked! {a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome} \",\"如果将这个枚举值修改为：\",\"return Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED,Characteristics.IDENTITY_FINISH)); \",\"就会抛出异常：\",\"Exception in thread \\\"main\\\" java.lang.ClassCastException: java.util.HashSet cannot be cast to java.util.Map \",\"这就是因为我们的中间结果类型是Set类型，而最终的结果类型是Map类型，同时也说明了characteristics就定义了中间结果容器和最终结果的结果容器类型的关系，在运行期间，JDK会根据这个枚举项类判断他们之间的关系，如果编写错误了，就可能会出现错误。\",\"另外如果中间结果容器和最终结果的结果容器类型相同，但是需要对于中间结果容器做一些处理才返回结果，这个时候也要去掉IDENTITY_FINISH这个枚举值，因为在执行过程中，会直接转换类型，而不会操作里面的值。\",\"如果我们在accumulator中打印当前线程的名称：\",\" @Override public BiConsumer<Set<T>, T> accumulator() { System.out.println(\\\"accmulator invoked!\\\"); return (set, item) -> { set.add(item); System.out.println(\\\"accmulator: \\\" + Thread.currentThread().getName()); }; } \",\"控制台就会打印十次：\",\"accmulator: main accmulator: main accmulator: main accmulator: main accmulator: main accmulator: main accmulator: main accmulator: main accmulator: main accmulator: main \",\"去掉集合中重复的元素\\\"hello\\\",正好是十个元素，执行了十次累积的操作，并且都是主线程的，如果我们使用并行流：\",\"Map<String, String> map = set.parallelStream().collect(new MySetCollector2<>()); \",\"运行的结果就变成了：\",\"set: [a, b, world, c, d, e, f, g, hello, welcome] characteristics invoked! supplier invoked! accmulator invoked! combiner invoked! characteristics invoked! accmulator: main accmulator: ForkJoinPool.commonPool-worker-5 accmulator: ForkJoinPool.commonPool-worker-4 accmulator: ForkJoinPool.commonPool-worker-3 accmulator: ForkJoinPool.commonPool-worker-1 accmulator: ForkJoinPool.commonPool-worker-1 accmulator: ForkJoinPool.commonPool-worker-3 accmulator: ForkJoinPool.commonPool-worker-3 accmulator: ForkJoinPool.commonPool-worker-5 accmulator: ForkJoinPool.commonPool-worker-2 characteristics invoked! finisher invoked! {a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome} \",\"为了方便观察并行流和串行流的区别，我们打印一下，进行累积操作的集合中的元素，再次运行，就会发现：\",\"set: [a, b, world, c, d, e, f, g, hello, welcome] characteristics invoked! supplier invoked! accmulator invoked! combiner invoked! characteristics invoked! [hello] [b] accmulator: ForkJoinPool.commonPool-worker-2 accmulator: main [f] accmulator: ForkJoinPool.commonPool-worker-3 [d] accmulator: ForkJoinPool.commonPool-worker-1 [d, e] accmulator: ForkJoinPool.commonPool-worker-1 [welcome] accmulator: ForkJoinPool.commonPool-worker-4 [f, g] accmulator: ForkJoinPool.commonPool-worker-3 [b, world] accmulator: ForkJoinPool.commonPool-worker-2 [b, world, c] accmulator: ForkJoinPool.commonPool-worker-2 [a] accmulator: ForkJoinPool.commonPool-worker-5 characteristics invoked! finisher invoked! {a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome} \",\"这里就会开启多个线程，这个时候如果再设置CONCURRENT特性：\",\"return Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED, Characteristics.CONCURRENT)); \",\"控制台输出：\",\"set: [a, b, world, c, d, e, f, g, hello, welcome] characteristics invoked! supplier invoked! ==================================== accmulator invoked! [hello] accmulator: main [hello, welcome] accmulator: ForkJoinPool.commonPool-worker-2 [f, hello, welcome] [b, f, hello, welcome] accmulator: ForkJoinPool.commonPool-worker-2 accmulator: ForkJoinPool.commonPool-worker-3 [a, b, f, hello, welcome] accmulator: ForkJoinPool.commonPool-worker-4 [a, b, world, d, f, g, hello, welcome] accmulator: ForkJoinPool.commonPool-worker-3 [a, b, world, d, f, hello, welcome] accmulator: ForkJoinPool.commonPool-worker-2 [a, b, d, f, hello, welcome] accmulator: ForkJoinPool.commonPool-worker-1 [a, b, world, c, d, e, f, g, hello, welcome] accmulator: ForkJoinPool.commonPool-worker-1 [a, b, world, c, d, f, g, hello, welcome] accmulator: ForkJoinPool.commonPool-worker-2 characteristics invoked! finisher invoked! {a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome} \",\"如果执行的次数过多，还有可能会出现如下报错：\",\"Exception in thread \\\"main\\\" java.util.ConcurrentModificationException: java.util.ConcurrentModificationException \",\"这是因为设置了CONCURRENT特性，多个线程就会操作同一个中间结果容器，而在我们的程序中，除了往集合中不断累加元素之外，还在打印集合中的元素：\",\" public BiConsumer<Set<T>, T> accumulator() { System.out.println(\\\"accmulator invoked!\\\"); return (set, item) -> { set.add(item); System.out.println(\\\"accmulator: \\\" + Thread.currentThread().getName()); }; } \",\"这将导致，偶发的情况下就会出现并发修改的异常，这就要求在在定义Collector的是偶，如果设置了CONCURRENT特性，accumulator方法只能进行累积的操作，而尽量不要进行其他的操作。\",\"总结一下，在使用并行流的时候，如果设置了CONCURRENT特性，那么多个线程就会操作操作同一个中间结果容器，而这个唯一的结果容器就是最终的结果容器，如果没有设置这个特性，那么就会操作不同的中间结果容器，换言之，如果设置了CONCURRENT特性，那么combiner就不会被调用，因为无需进行最后的合并操作，而如果没有设置，那么combiner就会得到调用。\",\"总而言之combiner被调用有两个条件，一个是并行流，一个是没有设置CONCURRENT特性，中间结果容器的个数也是类似的，只有当开启并行流，并且没有设置过CONCURRENT特性的时候才会创建和流中元素个数相同的中间结果容器。\",\"开启并行流的方式除了之前我们使用过的parallelStream，其实还可以这样：\",\"Map<String, String> map = set.stream().parallel().collect(new MySetCollector2<>()); \",\"如果要使用串行流，你也可以：\",\"Map<String, String> map = set.stream().sequential().collect(new MySetCollector2<>()); \",\"甚至可以：\",\"Map<String, String> map = set.stream().sequential().parallel().sequential().collect(new MySetCollector2<>()); \",\"但需要注意的是，这里程序并不会依次的调用，而是会调用最后指定的方式，也就是说，上面的代码其实等价于：\",\"Map<String, String> map = set.stream().sequential().collect(new MySetCollector2<>()); \",\"这两种写法完全是等价的，这是因为，选择并行流还是串行流，仅仅是由一个布尔值来控制的：\",\" /** * True if pipeline is parallel, otherwise the pipeline is sequential; only * valid for the source stage. */ private boolean parallel; \"]},\"1495\":{\"h\":\"Collectors源码分析\",\"t\":[\"自定义Collector的过程帮助我们很好的理解了关于Collector的基本概念，我们也尝试着自己实现了两个相对比较简单的例子，Collectors作为生产Collector的静态工厂类，里面有大量的关于Collector的实现，本节我们就分析JDK已经帮我们实现的Collector的例子，学习这些例子，有助于我们强化对于Collector的理解。\",\"对于Collectors静态工厂来说，实现Collector，总的来说分为两种情况：\",\"通过CollectorImpl来实现\",\"通过reducing方法来实现，而reducing方法本身又是通过CollectorImpl来实现的。\",\"首先我们来分析一下我们使用过的最多的toList方法：\",\" public static <T> Collector<T, ?, List<T>> toList() { return new CollectorImpl<>((Supplier<List<T>>) ArrayList::new, List::add, (left, right) -> { left.addAll(right); return left; }, CH_ID); } \",\"这里的(Supplier<List<T>>) ArrayList::new也可以写成ArrayList<T>::new，这里的第四个参数是：\",\" static final Set<Collector.Characteristics> CH_ID = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH)); \",\"这里的属性值是IDENTITY_FINISH，意味着中间结果容器的类型和最终返回的结果类型相同，所以无需定义finisher。对于toList还有一个接受的更宽广的toCollection：\",\" public static <T, C extends Collection<T>> Collector<T, ?, C> toCollection(Supplier<C> collectionFactory) { return new CollectorImpl<>(collectionFactory, Collection<T>::add, (r1, r2) -> { r1.addAll(r2); return r1; }, CH_ID); } \",\"这里只是提供了创建结果容器的入口，例如，要使用LinkedList，你只需要：\",\"list.stream().collect(Collectors.toCollection(LinkedList::new)); \",\"对于toSet方法：\",\" public static <T> Collector<T, ?, Set<T>> toSet() { return new CollectorImpl<>((Supplier<Set<T>>) HashSet::new, Set::add, (left, right) -> { left.addAll(right); return left; }, CH_UNORDERED_ID); } \",\"由于Set集合本身是无序的，并且最终返回的结果也是Set类型，所以它的特性值是：\",\" static final Set<Collector.Characteristics> CH_UNORDERED_ID = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.UNORDERED, Collector.Characteristics.IDENTITY_FINISH)); \",\"对于joining方法：\",\" public static Collector<CharSequence, ?, String> joining() { return new CollectorImpl<CharSequence, StringBuilder, String>( StringBuilder::new, StringBuilder::append, (r1, r2) -> { r1.append(r2); return r1; }, StringBuilder::toString, CH_NOID); } \",\"joining方法与之前的方法不同的是，它还调用了finisher方法，这是因为需要将StringBuilder转为String类型。这里的第四个参数指的是：\",\"static final Set<Collector.Characteristics> CH_NOID = Collections.emptySet(); \",\"返回的是一个空的集合，说明三个特性都不具备。\",\"joining还有一个重载的方法，可以增加前缀和后缀：\",\" public static Collector<CharSequence, ?, String> joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) { return new CollectorImpl<>( () -> new StringJoiner(delimiter, prefix, suffix), StringJoiner::add, StringJoiner::merge, StringJoiner::toString, CH_NOID); } \",\"StringJoiner是JDK1.8提供的一个新的类，用于完成字符串的拼接操作。\",\" public static <T, U, A, R> Collector<T, ?, R> mapping(Function<? super T, ? extends U> mapper, Collector<? super U, A, R> downstream) { BiConsumer<A, ? super U> downstreamAccumulator = downstream.accumulator(); return new CollectorImpl<>(downstream.supplier(), (r, t) -> downstreamAccumulator.accept(r, mapper.apply(t)), downstream.combiner(), downstream.finisher(), downstream.characteristics()); } \",\"这是一个相对比较复杂的例子，我们先来读一下方法说明：\",\"Adapts a Collector accepting elements of type U to one accepting elements of type T by applying a mapping function to each input element before accumulation. \",\"mapping方法被用来在累积操作之前对每个输入元素都应用mapping方法，将接收的U类型映射为T类型，从而实现收集器的映射。\",\"方法本身接收两个参数：\",\"mapper – a function to be applied to the input elements downstream – a collector which will accept mapped values \",\"这里的下游指的是，将要被映射的值，给出了一个具体的案例：\",\" Map<City, Set<String>> lastNamesByCity = people.stream().collect(groupingBy(Person::getCity, mapping(Person::getLastName, toSet()))); \",\"比这个例子稍微复杂一点的例子：\",\" public static<T,A,R,RR> Collector<T,A,RR> collectingAndThen(Collector<T,A,R> downstream, Function<R,RR> finisher) { Set<Collector.Characteristics> characteristics = downstream.characteristics(); if (characteristics.contains(Collector.Characteristics.IDENTITY_FINISH)) { if (characteristics.size() == 1) // 如果只有IDENTITY_FINISH特性，就将特性值设置为空 characteristics = Collectors.CH_NOID; else { // 将IDENTITY_FINISH去掉 characteristics = EnumSet.copyOf(characteristics); characteristics.remove(Collector.Characteristics.IDENTITY_FINISH); characteristics = Collections.unmodifiableSet(characteristics); } } return new CollectorImpl<>(downstream.supplier(), downstream.accumulator(), downstream.combiner(), downstream.finisher().andThen(finisher), characteristics); } \",\"首先来读一下方法的说明：\",\"Adapts a Collector to perform an additional finishing transformation. For example, one could adapt the toList() collector to always produce an immutable list with: \",\"适配一个Collector来执行finisher方法的转换，例如，我们可以使用这个方法将使用toList收集的方法来转换为一个不可变的集合，例如：\",\" List<String> people = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList)); \",\"toList本身方法返回的是一个ArrayList对象，本身是可变的，通过这种方式就可以得到一个不可变的集合列表，方法实现中将原来流中的IDENTITY_FINISH特性去掉的原因在于，如果设置了这个特性值，finisher方法就不会得到执行，而collectingAndThen方法的目的就在于转换最终的结果类型，关键就在于需要执行的finisher方法。\",\"接下来我们看一个之前使用的方法，summingInt的实现：\",\" public static <T> Collector<T, ?, Integer> summingInt(ToIntFunction<? super T> mapper) { return new CollectorImpl<>( () -> new int[1], (a, t) -> { a[0] += mapper.applyAsInt(t); }, (a, b) -> { a[0] += b[0]; return a; }, a -> a[0], CH_NOID); } \",\"summingInt方法的说明：\",\"Returns a Collector that produces the sum of a integer-valued function applied to the input elements. If no elements are present, the result is 0. \",\"返回的Collector是对流中的每一个元素执行传入的整型值函数，如果流中没有元素，就返回0。\",\"需要说明的是，这里为什么不直接使用数字，而是new了一个int类型的数组，原因在于数字是值类型的，而数组是引用类型的，值类型的参数无法进行传递，数组本身也符合容器的定义，只不过这里每次只是取出来数组中唯一的元素，对数组中唯一的元素进行累加的操作。\",\"以上都是通过CollectorImpl来实现的Collector，接下来我们看一下通过reducing来实现的例子，首先来查看reducing方法的定义：\",\" public static <T, U> Collector<T, ?, U> reducing(U identity, Function<? super T, ? extends U> mapper, BinaryOperator<U> op) { return new CollectorImpl<>( boxSupplier(identity), (a, t) -> { a[0] = op.apply(a[0], mapper.apply(t)); }, (a, b) -> { a[0] = op.apply(a[0], b[0]); return a; }, a -> a[0], CH_NOID); } \",\"reducing方法也是借助CollectorImpl来实现的Collector的，我们来阅读一下reducing方法的说明：\",\"Returns a Collector which performs a reduction of its input elements under a specified mapping function and BinaryOperator. This is a generalization of reducing(Object, BinaryOperator) which allows a transformation of the elements before reduction. \",\"groupingBy和partitioningBy是整个Collectors类中比较难以理解的两部分，关键的部分在于，理解每个泛型代表的含义以及每个参数的作用，在有了前面的基础之后，我们有必要了解一下有关分区和分组的实现。首先来看一下groupingBy方法的定义：\",\" public static <T, K> Collector<T, ?, Map<K, List<T>>> groupingBy(Function<? super T, ? extends K> classifier) { return groupingBy(classifier, toList()); } \",\"T类型表示流中元素的类型，？表示的是中间结果容器的类型，Map是最终的结果类型，K表示分类的时候的key的类型，List<T>就表示根据分类依据K分类之后的列表集合，方法本身的参数并没有直接使用T和K，而是使用T类型以及T以上的类型，K类型以及K类型以下的类型，并且只接受一个参数，调用了另一个重载的groupingBy方法：\",\" public static <T, K, A, D> Collector<T, ?, Map<K, D>> groupingBy(Function<? super T, ? extends K> classifier, Collector<? super T, A, D> downstream) { return groupingBy(classifier, HashMap::new, downstream); } \",\"方法的第一个参数是一个Function类型，第二个参数是Collector类型的，同样的，我们需要搞清楚这里每一个泛型的含义，T表示流中元素的类型，K表示分类器返回的结果的类型，或者说是返回的Map的key的类型，D表示Map返回的值的类型，方法要完成的事情实际上就是要将downstream在收集的时候，应用分类器classifier。它本身又调用一个重载的方法，在查看之前首先需要了解一个JDK中新增加的方法，在最终构造返回的accumulator的时候，我们要用到Map接口中所新增加的默认方法computeIfAbsent：\",\"default V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) { Objects.requireNonNull(mappingFunction); // V表示当前map的值的类型 V v; if ((v = get(key)) == null) { V newValue; if ((newValue = mappingFunction.apply(key)) != null) { put(key, newValue); return newValue; } } return v; } \",\"方法的说明：\",\"If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null. \",\"如果给定一个key与值没有关联起来（或者键映射为空），直接返回结果，如果它不为空的话，将尝试着计算他们的值使用给定的映射方法，就将他放入到map里面。总而言之，如果key不存在，则返回，如果存在，就执行mappingFunction，然后将映射之后的值放入到map当中。\",\"下面的方式是groupingBy真正执行的方法：\",\"public static <T, K, D, A, M extends Map<K, D>> Collector<T, ?, M> groupingBy(Function<? super T, ? extends K> classifier, Supplier<M> mapFactory, Collector<? super T, A, D> downstream) { // A表示下游收集器的中间结果容器类型 Supplier<A> downstreamSupplier = downstream.supplier(); // T表示流中元素的类型 BiConsumer<A, ? super T> downstreamAccumulator = downstream.accumulator(); // 构造最终所返回的累加器对象 BiConsumer<Map<K, A>, T> accumulator = (m, t) -> { K key = Objects.requireNonNull(classifier.apply(t), \\\"element cannot be mapped to a null key\\\"); A container = m.computeIfAbsent(key, k -> downstreamSupplier.get()); downstreamAccumulator.accept(container, t); }; // 完成两个Map的合并操作 BinaryOperator<Map<K, A>> merger = Collectors.<K, A, Map<K, A>>mapMerger(downstream.combiner()); // 将M类型强转为<K,A>类型，M本身是<K,D>类型，由于中间结果类型一定是<K,A>类型，所以可以强转成功。 @SuppressWarnings(\\\"unchecked\\\") Supplier<Map<K, A>> mangledFactory = (Supplier<Map<K, A>>) mapFactory; if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) { return new CollectorImpl<>(mangledFactory, accumulator, merger, CH_ID); } else { // 下游收集器本身返回的是<A,D>类型的，这里也是由于一定是<A,A>类型的，所以可以强转成功。 @SuppressWarnings(\\\"unchecked\\\") Function<A, A> downstreamFinisher = (Function<A, A>) downstream.finisher(); // 将Map中的键值对替换 Function<Map<K, A>, M> finisher = intermediate -> { intermediate.replaceAll((k, v) -> downstreamFinisher.apply(v)); @SuppressWarnings(\\\"unchecked\\\") M castResult = (M) intermediate; return castResult; }; return new CollectorImpl<>(mangledFactory, accumulator, merger, finisher, CH_NOID); } } \",\"第一个参数是一个分类器，输入类型是T，返回的是K类型，第二个参数是accumulator累加器的类型，对应上面例子中的HashMap::new，第三个参数是下游收集器，其中的A表示的是中间结果的容器类型，在整个方法的返回类型中，泛型M的定义是M extends Map<K, D>。首先我们来阅读以下这个方法的说明：\",\"Returns a Collector implementing a cascaded \\\"group by\\\" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector. The Map produced by the Collector is created with the supplied factory function. \",\"groupingBy方法返回了完成对于给定T类型的层叠的分组操作的Collector，它是根据提供的分类器来对元素进行分组的，然后会对于给定的key所关联的值（即Map）使用给定的下游收集器执行汇聚操作，Collector所使用的Map是由supplied工厂函数提供的。\",\"The classification function maps elements to some key type K. The downstream collector operates on elements of type T and produces a result of type D. The resulting collector produces a Map<K, D>. \",\"分类器方法会将元素映射成某个k类型，然后下游收集器会对流中T类型的元素生成一个D类型的结果，所生成的collector类型是Map<K,D>。\",\"For example, to compute the set of last names of people in each city, where the city names are sorted: \",\"比如要根据城市的名字对城市中每个人的姓进行分组，并且返回的结果要求带有排序的功能：\",\" Map<City, Set<String>> namesByCity = people.stream().collect(groupingBy(Person::getCity, TreeMap::new, mapping(Person::getLastName, toSet()))); \",\"关于分组的方法还有另外的说明：\",\"The returned Collector is not concurrent. For parallel stream pipelines, the combiner function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using groupingByConcurrent(Function, Supplier, Collector) may offer better parallel performance. \",\"groupingBy方法返回的Collector不是并发的，对于并行流管道，combiner方法会将一个map的key合并到另一个当中，这可能是一个昂贵的操作，如果对于下游收集器而言，元素的顺序不是很重要的话，建议使用groupingByConcurrent，它可以提供更好的并发的性能：\",\" public static <T, K, A, D> Collector<T, ?, ConcurrentMap<K, D>> groupingByConcurrent(Function<? super T, ? extends K> classifier, Collector<? super T, A, D> downstream) { return groupingByConcurrent(classifier, ConcurrentHashMap::new, downstream); } \",\"原因就在于groupingByConcurrent使用的是ConcurrentHashMap。\",\"与groupingBy相关联的另一个方法就是分区partitioningBy：\",\" public static <T> Collector<T, ?, Map<Boolean, List<T>>> partitioningBy(Predicate<? super T> predicate) { return partitioningBy(predicate, toList()); } \",\"它也有两个重载的方法：\",\" public static <T, D, A> Collector<T, ?, Map<Boolean, D>> partitioningBy(Predicate<? super T> predicate, Collector<? super T, A, D> downstream) { BiConsumer<A, ? super T> downstreamAccumulator = downstream.accumulator(); BiConsumer<Partition<A>, T> accumulator = (result, t) -> downstreamAccumulator.accept(predicate.test(t) ? result.forTrue : result.forFalse, t); BinaryOperator<A> op = downstream.combiner(); BinaryOperator<Partition<A>> merger = (left, right) -> new Partition<>(op.apply(left.forTrue, right.forTrue), op.apply(left.forFalse, right.forFalse)); Supplier<Partition<A>> supplier = () -> new Partition<>(downstream.supplier().get(), downstream.supplier().get()); if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) { return new CollectorImpl<>(supplier, accumulator, merger, CH_ID); } else { Function<Partition<A>, Map<Boolean, D>> finisher = par -> new Partition<>(downstream.finisher().apply(par.forTrue), downstream.finisher().apply(par.forFalse)); return new CollectorImpl<>(supplier, accumulator, merger, finisher, CH_NOID); } } \",\"这里的Partition是用来定义分组结果的一个静态内部类：\",\" private static final class Partition<T> extends AbstractMap<Boolean, T> implements Map<Boolean, T> { final T forTrue; final T forFalse; Partition(T forTrue, T forFalse) { this.forTrue = forTrue; this.forFalse = forFalse; } @Override public Set<Map.Entry<Boolean, T>> entrySet() { return new AbstractSet<Map.Entry<Boolean, T>>() { @Override public Iterator<Map.Entry<Boolean, T>> iterator() { Map.Entry<Boolean, T> falseEntry = new SimpleImmutableEntry<>(false, forFalse); Map.Entry<Boolean, T> trueEntry = new SimpleImmutableEntry<>(true, forTrue); return Arrays.asList(falseEntry, trueEntry).iterator(); } @Override public int size() { return 2; } }; } } \",\"之所以这么做的原因是，分区一定是固定的两组结果，如果再使用Map类描述的话并不是特别清晰。\",\"收集器是我们认识整个Stream的第一步，在了解了有关收集器的内容之后，可以为我们了解Stream打下良好的基础，这一部分是整个函数式编程最核心的部分，我们将会看到JDK在底层到底是如何巧妙的实现函数式编程。\"]},\"1496\":{\"h\":\"Stream源码分析\",\"t\":[\"在正式开始介绍之前，需要有一些预备的知识，从JDK1.7开始增加了这样一个接口：\",\"public interface AutoCloseable { void close() throws Exception; } \",\"方法的说明：\",\"An object that may hold resources (such as file or socket handles) until it is closed. The close() method of an AutoCloseable object is called automatically when exiting a try-with-resources block for which the object has been declared in the resource specification header. This construction ensures prompt release, avoiding resource exhaustion exceptions and errors that may otherwise occur. \",\"这是一个关闭之前可能持有一些资源（比如文件、socket句柄）的对象，它的close方法会在退出 try-with-resources代码块的时候自动得到调用，这种调用的机制被声明在资源的规范的头里面，这种设置确保了可以适当的释放一些资源，避免了资源被消耗尽造异常外和错误。\",\"举个例子：\",\"public class AutoCloseableTest implements AutoCloseable { @Override public void close() throws Exception { System.out.println(\\\"close invoked!\\\"); } public void doSomething() { System.out.println(\\\"doSomething invoked!\\\"); } public static void main(String[] args) throws Exception { try (AutoCloseableTest autoCloseableTest = new AutoCloseableTest()) { autoCloseableTest.doSomething(); } } } \",\"使用这种方式可以替换原来的需要人为的显示关闭各种流的操作，close方法会自动的得到调用：\",\"doSomething invoked! close invoked! \",\"接下来我们就完整的梳理一下关于Sream类本身的内容：\",\"A sequence of elements supporting sequential and parallel aggregate operations. The following example illustrates an aggregate operation using Stream and IntStream: \",\"首先Stream是一个支持并行与串行聚合操作的元素的序列，下面的示例演示了如何让使用Stream和IntStream进行聚合操作：\",\"int sum = widgets.stream() .filter(w -> w.getColor() == RED) .mapToInt(w -> w.getWeight()) .sum(); \",\"对于这个例子的说明：\",\"In this example, widgets is a Collection<Widget>. We create a stream of Widget objects via Collection.stream(), filter it to produce a stream containing only the red widgets, and then transform it into a stream of int values representing the weight of each red widget. Then this stream is summed to produce a total weight. \",\"在这个例子当中，widgets是Widget类型的集合，我们通过使用Collection的stream方法创建了一个Widget对象的流，生成了一个新的只包含红色的Widget的流，然后将它转换成int值的Stream对象，代表了每个红色Widget的重量，最后流被汇总起来生成一个总的重量。\",\"In addition to Stream, which is a stream of object references, there are primitive specializations for IntStream, LongStream, and DoubleStream, all of which are referred to as \\\"streams\\\" and conform to the characteristics and restrictions described here. \",\"Stream本身是一个对象引用流，除了他还有一些原生的、特化的版本。比如IntStream、LongStream、DoubleStream，他们都被称之为Stream，满足Stream的特性，遵循Stream的相关约束。\",\"To perform a computation, stream operations are composed into a stream pipeline. A stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more intermediate operations (which transform a stream into another stream, such as filter(Predicate)), and a terminal operation (which produces a result or side-effect, such as count() or forEach(Consumer)). Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed. \",\"为了进行计算，Stream会被组合成一个Stream pipeline（流管道）当中，一个流管道包含了一个元（可以是一个数组，一个集合，一个生成器法，一个I/O通道等等），包含0个或多个中间操作（会将一个Stream转换为另一个Stream，比如filter(Predicate)），包含一个终止操作（将会产生一个结果或者是有副作用的，比如count() 或者forEach(Consumer)），流是延迟的，只有当终止操作开始的时候，才会对元数据的计算才会真正的进行执行，元的数据只有在需要的时候才会被消费。\",\"Collections and streams, while bearing some superficial similarities, have different goals. Collections are primarily concerned with the efficient management of, and access to, their elements. By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. However, if the provided stream operations do not offer the desired functionality, the iterator() and spliterator() operations can be used to perform a controlled traversal. \",\"集合与流，他们有一些相似性，但是有不同的目标，集合主要考虑的是高效的访问和管理他们的元素，与之相反，流并不会直接提供直接的去操作元素的方式，而是通过声明式的方式来描述他们元以及操作，这些操作会被聚合起来应用到他们的元上面，流关注的是元的计算。然而，如果提供的流操作并没有所需要的功能，那么iterator()和spliterator() 就可以执行控制性的遍历（即采用传统的方式来进行一些流的操作）。\",\"A stream pipeline, like the \\\"widgets\\\" example above, can be viewed as a query on the stream source. Unless the source was explicitly designed for concurrent modification (such as a ConcurrentHashMap), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried. \",\"一个流管道，比如刚才的widgets，它可以被看成是一种对于流元的查询，除非这个流被显示的设计成可以并发修改的（比如ConcurrentHashMap），否则一些错误的型为就可能会产生并发修改的异常。\",\"Most stream operations accept parameters that describe user-specified behavior, such as the lambda expression w -> w.getWeight() passed to mapToInt in the example above. To preserve correct behavior, these behavioral parameters: \",\"大多数的流都会接收用户指定的一种行为，比如Lambda表达式 w -> w.getWeight()，为了保证最终结果的正确性，这些行为参数都要满足下面的这些条件特性：\",\"must be non-interfering (they do not modify the stream source); and in most cases must be stateless (their result should not depend on any state that might change during execution of the stream pipeline). \",\"他们必须是冲突非干扰的，\",\"在大多数情况下都是一种无状态的操作（结果不应该依赖于在流管道执行过程当中可能会修改的任意状态）,即执行的结果与执行的顺序是无关的\",\"Such parameters are always instances of a functional interface such as Function, and are often lambda expressions or method references. Unless otherwise specified these parameters must be non-null. \",\"这些参数总是一个函数式接口的实例。比如说Lamda表达式，除特殊情况外，参数都是非空的。\",\"stream should be operated on (invoking an intermediate or terminal stream operation) only once. This rules out, for example, \\\"forked\\\" streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream. A stream implementation may throw IllegalStateException if it detects that the stream is being reused. However, since some stream operations may return their receiver rather than a new stream object, it may not be possible to detect reuse in all cases. \",\"一个流调用中间操作或者终止操作只能被操作一次，这并不是绝对的，比如”派生“的流，相同的元会提供两个或多个流管道，或者对相同的元执行多次的遍历，如果检测到流被重用了，就会抛出IllegalStateException，然而有些流操作可能会返回他们的接收者而并不是一个新的Stream对象，这种情况下是无法检测到被重用的。\",\"Streams have a close() method and implement AutoCloseable, but nearly all stream instances do not actually need to be closed after use. Generally, only streams whose source is an IO channel (such as those returned by Files.lines(Path, Charset)) will require closing. Most streams are backed by collections, arrays, or generating functions, which require no special resource management. (If a stream does require closing, it can be declared as a resource in a try-with-resources statement.) \",\"流都实现了AutoCloseable接口，因此都会自动的调用close方法，但是几乎所有的流实例在使用完成之后都不需要关闭，只有当流的元是一个IO通道的时候（比如从Files.lines返回对象）需要被关闭，大多数流的元都是集合、数组、或者生成器函数，他们并不需要特殊的资源管理（如果一个流确实需要关闭，它会使用try-with-resources声明成一个资源）。\",\"Stream pipelines may execute either sequentially or in parallel. This execution mode is a property of the stream. Streams are created with an initial choice of sequential or parallel execution. (For example, Collection.stream() creates a sequential stream, and Collection.parallelStream() creates a parallel one.) This choice of execution mode may be modified by the sequential() or parallel() methods, and may be queried with the isParallel() method. \",\"流管道可以通过并行或者是串行的方式来去执行，这种执行方式只是流里面的一个属性而已，流初始被创建的时候就会选择串行还是并行的（比如Collection.stream() 创建的就是串行流，Collection.parallelStream()创建的就是并行流），这种执行模式的选择，还可以通过sequential()或者parallel() 方法进行修改，并且还可以通过isParallel() 方法来查询流的类型。\",\"以上就是关于Stream这个类的内容，Stream本身又继承了BaseStream类，BaseStream定义了所有流、流的操作、流管道以及并行流的行为和种类，我们首先来看一下BaseStream类的定义：\",\"public interface BaseStream<T, S extends BaseStream<T, S>> extends AutoCloseable { // 返回针对于流中元素的迭代器 Iterator<T> iterator(); // 这是流的终止操作，返回流中元素的分割迭代器 Spliterator<T> spliterator(); // 判断流是否是并行流，只能在流的终止操作之前进行调用 boolean isParallel(); // 返回一个等价的串行流，有可能会返回流本身，也有可能会将底层的流修改为串行流，这是一个中间操作 S sequential(); // 返回一个等价的并行流，有可能返回流本身，也有可能将底层的流修改为并行流，这是一个中间操作 S parallel(); // 返回一个无序的流，有可能返回流本身，原因是流本身就是无序的，这是一个中间操作 S unordered(); // 返回一个额外带有关闭处理器的流，当流的close方法被调用的时候，就会按照被添加进去的顺序得到调用，所有的关闭处理器都会得到调用而无论它之前的关闭处理器是否抛出了异常，如果任意的关闭处理器抛出了异常，那么抛出的第一个异常就会被抛给close方法的调用者，其余的异常就会作为被压制的异常（除非其余的异常是与第一个异常相同的异常，因为一个异常不能压制它本身），同样的，他也有可能返回自己 S onClose(Runnable closeHandler); // 关闭这个流，所有的流管道处理器都会得到调用 @Override void close(); } \",\"这里的泛型T代表流中元素的类型，S指的是实现了BaseStream类型的流对象，实际上指的就是中间操作返回的新的流对象，回到Stream类的定义：\",\"public interface Stream<T> extends BaseStream<T, Stream<T>> \",\"对照BaseStream的定义不难发现，这里的泛型S指的就是Stream<T>,而Stream<T>又正好继承了BaseStream，所以这个泛型是成立的。\",\"关于关闭处理器可以举一个简单的例子：\",\"public class StreamTest2 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); // 使用这种方式是为了执行Stream的close方法 try (Stream<String> stream = list.stream()) { stream.onClose(() -> { System.out.println(\\\"aaa\\\"); }).onClose(() -> { System.out.println(\\\"bbb\\\"); }).forEach(System.out::println); } } } \",\"控制台输出：\",\"hello world hello world aaa bbb \",\"修改一下程序，观察有异常发生的情况：\",\" try (Stream<String> stream = list.stream()) { stream.onClose(() -> { System.out.println(\\\"aaa\\\"); throw new NullPointerException(\\\"first exception\\\"); }).onClose(() -> { System.out.println(\\\"bbb\\\"); }).forEach(System.out::println); } \",\"就会输出：\",\"Exception in thread \\\"main\\\" hello world hello world aaa bbb java.lang.NullPointerException: first exception at Stream2.StreamTest2.lambda$main$0(StreamTest2.java:18) at java.util.stream.Streams$1.run(Streams.java:850) at java.util.stream.AbstractPipeline.close(AbstractPipeline.java:323) at Stream2.StreamTest2.main(StreamTest2.java:22) FAILURE: Build failed with an exception. \",\"可以看到虽然抛出了异常，但是后面的关闭处理器依然得到了执行。\",\"hello Exception in thread \\\"main\\\" world hello world aaa bbb java.lang.NullPointerException: first exception at Stream2.StreamTest2.lambda$main$0(StreamTest2.java:18) at java.util.stream.Streams$1.run(Streams.java:850) at java.util.stream.AbstractPipeline.close(AbstractPipeline.java:323) at Stream2.StreamTest2.main(StreamTest2.java:23) Suppressed: java.lang.NullPointerException: second exception at Stream2.StreamTest2.lambda$main$1(StreamTest2.java:21) at java.util.stream.Streams$1.run(Streams.java:854) ... 2 more \",\"这里的Suppressed就是压制的异常信息，可以看到后续的异常都被压制了,针对于文档中提到相同的异常，就不会被压制，指的是：\",\" NullPointerException nullPointerException = new NullPointerException(\\\"exception\\\"); try (Stream<String> stream = list.stream()) { stream.onClose(() -> { System.out.println(\\\"aaa\\\"); throw nullPointerException; }).onClose(() -> { System.out.println(\\\"bbb\\\"); throw nullPointerException; }).forEach(System.out::println); } \",\"控制台输出：\",\"hello Exception in thread \\\"main\\\" world hello world aaa bbb java.lang.NullPointerException: exception at Stream2.StreamTest2.main(StreamTest2.java:15) FAILURE: Build failed with an exception. \"]},\"1497\":{\"h\":\"Spliterator源码分析\",\"t\":[\"Spliterator被称之为分割迭代器，是整个流实现非常重要的一环，从本节开始，就正式进入的流源码的分析。\",\"首先还是定义一个非常简单的例子：\",\"public class StreamTest3 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"hello world\\\"); list.stream().forEach(System.out::println); } } \",\"这里调用的Collection接口中的stream方法：\",\"default Stream<E> stream() { return StreamSupport.stream(spliterator(), false); } \",\"我们来阅读一下方法的说明：\",\"Returns a sequential Stream with this collection as its source. This method should be overridden when the spliterator() method cannot return a spliterator that is IMMUTABLE, CONCURRENT, or late-binding. (See spliterator() for details.) \",\"stream方法会调用的将集合作为流的元，并且返回一个串行流，当spliterator方法无法返回IMMUTABLE（不可变的）、CONCURRENT（并行的）、late-binding（延迟绑定的）的分割迭代器，那么这个方法应该当被重写。\",\"stream方法的参数也是定义在Collection集合中的默认方法：\",\" default Spliterator<E> spliterator() { return Spliterators.spliterator(this, 0); } \",\"我们来看一下这个方法的说明：\",\"Creates a Spliterator over the elements in this collection. Implementations should document characteristic values reported by the spliterator. Such characteristic values are not required to be reported if the spliterator reports Spliterator.SIZED and this collection contains no elements. The default implementation should be overridden by subclasses that can return a more efficient spliterator. In order to preserve expected laziness behavior for the stream() and parallelStream()} methods, spliterators should either have the characteristic of IMMUTABLE or CONCURRENT, or be late-binding. If none of these is practical, the overriding class should describe the spliterator's documented policy of binding and structural interference, and should override the stream() and parallelStream() methods to create streams using a Supplier of the spliterator, as in: \",\"创建一个针对于这个集合的元素分割迭代器，实现应该对于spliterator方法所返回的Spliterator特性值进行文档化（记录下来），这些特性值并不要求去报告，如果这个Spliterator报告了Spliterator.SIZED，并且这个集合不包含任何元素，默认的实现应该要被子类所重写，目的是为了返回一个效率更高的分割迭代器，为了保留stream、parallelStream两个方法的延迟特性，spliterators的特性值要么是IMMUTABLE或者CONCURRENT，要么就是late-binding，如果上面这些都无法实现，重写的类需要文档化spliterator的绑定策略，并且使用spliterator的Supplier重写stream和parallelStream方法，例如：\",\" Stream<E> s = StreamSupport.stream(() -> spliterator(), spliteratorCharacteristics) \",\"应该使用这种方式来定义。\",\"These requirements ensure that streams produced by the stream() and parallelStream() methods will reflect the contents of the collection as of initiation of the terminal stream operation. \",\"这些要求确保了由stream和parallelStream方法生成的流从终止流操作开始发起的时候就反应出流的内容。\",\"The default implementation creates a late-binding spliterator from the collections's Iterator. The spliterator inherits the fail-fast properties of the collection's iterator. The created Spliterator reports Spliterator.SIZED. \",\"默认的实现会从集合的迭代器创建一个延迟绑定的分割迭代器，创建出来的分割迭代器继承了集合迭代器的快速失败（如果碰到问题，程序不再往下执行，直接抛出异常）的属性，创建出来的分割迭代器具有 Spliterator.SIZED（固定大小）的特性。\",\"The created Spliterator additionally reports Spliterator.SUBSIZED. \",\"所创建出来的Spliterator还有一个额外的特性：Spliterator.SUBSIZED（所分割出来的每个块的大小是固定的）。\",\"If a spliterator covers no elements then the reporting of additional characteristic values, beyond that of SIZED and SUBSIZED, does not aid clients to control, specialize or simplify computation. However, this does enable shared use of an immutable and empty spliterator instance (see Spliterators.emptySpliterator()) for empty collections, and enables clients to determine if such a spliterator covers no elements. \",\"如果分割迭代器中没有任何元素，那么除了IZED和SUBSIZED其他的特性值并不会简化客户端的计算，但是可以重用一个空的、不可变的分割迭代器，是不是里面没有元素，并且对于空的集合，可以帮助客户端来判断spliterator里面是不是没有元素。\",\"Spliterator和Spliterators的关系就好像Collector和Collectors的关系一样，Spliterators针对于Spliterator提供了若干的静态方法，接下来就正式开始了解有关Spliterator的内容。\",\"An object for traversing and partitioning elements of a source. The source of elements covered by a Spliterator could be, for example, an array, a Collection, an IO channel, or a generator function. \",\"Spliterator是一个对于元中的元素进行遍历和分区的对象，Spliterator 元中的元素可以是数组，可以是集合，可以是IO通道，也可以是一个生成器函数。\",\"A Spliterator may traverse elements individually (tryAdvance()) or sequentially in bulk (forEachRemaining()). \",\"一个Spliterator可以使用tryAdvance单个的遍历元素，也可以使用forEachRemaining成块的遍历元素。\",\"A Spliterator may also partition off some of its elements (using trySplit) as another Spliterator, to be used in possibly-parallel operations. Operations using a Spliterator that cannot split, or does so in a highly imbalanced or inefficient manner, are unlikely to benefit from parallelism. Traversal and splitting exhaust elements; each Spliterator is useful for only a single bulk computation. \",\"一个Spliterator也可以对它的元素使用trySplit进行分区，形成另外的Spliterator，并且可以被并行的使用。如果使用Spliterator不能进行分割，或者分割的不平衡或者效率非常低的方式，那使用并行就并没有带来多少的好处。遍历和分割都会消耗元素，每一个Spliterator仅仅是对一个单块的计算是有用的（每一块元素都有自己的分割迭代器）。\",\"A Spliterator also reports a set of characteristics() of its structure, source, and elements from among ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, and SUBSIZED. These may be employed by Spliterator clients to control, specialize or simplify computation. For example, a Spliterator for a Collection would report SIZED, a Spliterator for a Set would report DISTINCT, and a Spliterator for a SortedSet would also report SORTED. Characteristics are reported as a simple unioned bit set. Some characteristics additionally constrain method behavior; for example if ORDERED, traversal methods must conform to their documented ordering. New characteristics may be defined in the future, so implementors should not assign meanings to unlisted values. \",\"Spliterator还会报告它的结构、元、元素的特性值ORDERED（有序的）、DISTINCT（不同的）、SORTED（排序的）、SIZED（确定大小的）、NONNULL（不为空的）、IMMUTABLE（不可变的）、CONCURRENT（并放大的）、SUBSIZED（子部分固定大小的），这些可以被Spliterator的客户端使用，使用他们来简化一些计算，比如说，如果元是Collection集合，那么它就会报告SIZED的特性值，如果元是Set集合，那么就会报告DISTINCT，如果元是SortedSet集合，那么就会报告SORTED，Characteristics会作为一个位操作来标识的，有一些特性值会额外限制方法的行为，比如ORDERED，那么遍历的时候就必须遵循遍历时候的顺序，未来可能会定义一些新的characteristics，所以不要使用这些特性值之外的值，可能会引起冲突。\",\"A Spliterator that does not report IMMUTABLE or CONCURRENT is expected to have a documented policy concerning: when the spliterator binds to the element source; and detection of structural interference of the element source detected after binding. A late-binding Spliterator binds to the source of elements at the point of first traversal, first split, or first query for estimated size, rather than at the time the Spliterator is created. A Spliterator that is not late-binding binds to the source of elements at the point of construction or first invocation of any method. Modifications made to the source prior to binding are reflected when the Spliterator is traversed. After binding a Spliterator should, on a best-effort basis, throw ConcurrentModificationException if structural interference is detected. Spliterators that do this are called fail-fast. The bulk traversal method (forEachRemaining()) of a Spliterator may optimize traversal and check for structural interference after all elements have been traversed, rather than checking per-element and failing immediately. \",\"当分割迭代器绑定到元上元素的时候，如果Spliterator没有报告IMMUTABLE或者CONCURRENT，期望可以文档化。并且在绑定之后，要对元素的结构上一些修改进行相应检测，延迟绑定的Spliterator会在元素第一次分割、遍历的，或者笫一次查询元素大小的时候绑定。而不是在Spliterator创建的时候绑定的，如果不是延迟绑定的Spliterator，就会在元创建的时候或者说第一次调用方法时候进行绑定。如果在绑定元之前对元进行了修改的话，这种修改就会在分割迭代器遍历的时候反映出来，如果绑定之后对元进行了修改，就会抛出ConcurrentModificationException的异常，按照这种方式我们称之为\\\"快速失败\\\"，块的遍历方法（例如forEachRemaining）会优化遍历并检测结构上的修改，在所有的元素都遍历之后，而不是对每个元素一次检测。\",\"Spliterators can provide an estimate of the number of remaining elements via the estimateSize method. Ideally, as reflected in characteristic SIZED, this value corresponds exactly to the number of elements that would be encountered in a successful traversal. However, even when not exactly known, an estimated value may still be useful to operations being performed on the source, such as helping to determine whether it is preferable to split further or traverse the remaining elements sequentially. \",\"Spliterators通过estimateSize方法来估算剩余元素的个数，理想情况下，通过特性值SIZED获取到的值就是之后遍历元素个数的值，不过，即便不是精确的知道待遍历元素的数量，一个估算的值，对于元的操作也是很有用的，比如可以帮助对元进行进一步的分割或者对于剩余的元素进行串行的遍历。\",\"Despite their obvious utility in parallel algorithms, spliterators are not expected to be thread-safe; instead, implementations of parallel algorithms using spliterators should ensure that the spliterator is only used by one thread at a time. This is generally easy to attain via serial thread-confinement, which often is a natural consequence of typical parallel algorithms that work by recursive decomposition. A thread calling trySplit() may hand over the returned Spliterator to another thread, which in turn may traverse or further split that Spliterator. The behaviour of splitting and traversal is undefined if two or more threads operate concurrently on the same spliterator. If the original thread hands a spliterator off to another thread for processing, it is best if that handoff occurs before any elements are consumed with tryAdvance(), as certain guarantees (such as the accuracy of estimateSize() for SIZED spliterators) are only valid before traversal has begun. \",\"尽管他们显著的功能在算法当中，分割迭代器并不被要求是线程安全的，相反，使用了spliterators并行算法的实现，应该确保了分割迭代器在某个时候一次只有一个线程使用，这可以使用serial thread-confinement这种模式来实现。这是一个通过递归解耦得到的自然的结果。一个调用了trySplit的一个线程，它可以将返回的Spliterator交由另一个线程接管，另一个线程可能会进一步的分割，分割以及遍历的行为是不确定的，如果两个或者多个线程操作同一个Spliterator，如果原来的线程将Spliterator交由另外一个线程处理的话，那么最好这种传递是发生在任何元素在使用tryAdvance方法消费之前完成，因为某些保证实在执行之前才是有效的（比如统计元素个数的estimateSize方法，SIZED特性值）。\",\"Primitive subtype specializations of Spliterator are provided for int, long, and double values. The subtype default implementations of tryAdvance(Consumer) and forEachRemaining(Consumer) box primitive values to instances of their corresponding wrapper class. Such boxing may undermine any performance advantages gained by using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, Spliterator.OfInt.tryAdvance(IntConsumer) and Spliterator.OfInt.forEachRemaining(IntConsumer) should be used in preference to Spliterator.OfInt.tryAdvance(Consumer) and Spliterator.OfInt.forEachRemaining(Consumer). Traversal of primitive values using boxing-based methods tryAdvance() and forEachRemaining() does not affect the order in which the values, transformed to boxed values, are encountered. \",\"原生的子类型的特化也提供了。比如int、long、double，普通的方法接收的参数tryAdvance(Consumer) and forEachRemaining(Consumer)，这些参数就会使用包装类型，这样就有可能影响了性能上的优势，为了避免装箱拆箱操作带来的性能消耗，就应该使用Spliterator.OfInt.tryAdvance(IntConsumer) 和Spliterator.OfInt.forEachRemaining(IntConsumer) ，如果可以使用特化版本就不要使用通用版本。无论使用哪种方式，元素的顺序与之前的保持一致。\",\"Spliterators, like Iterators, are for traversing the elements of a source. The Spliterator API was designed to support efficient parallel traversal in addition to sequential traversal, by supporting decomposition as well as single-element iteration. In addition, the protocol for accessing elements via a Spliterator is designed to impose smaller per-element overhead than Iterator, and to avoid the inherent race involved in having separate methods for hasNext() and next(). \",\"Spliterators就像Iterators一样，也是用来遍历元当中的元素的，Spliterator的API设计为串行和高效的并行方式来进行元素的遍历，通过支持解耦、分解、单元素的遍历迭代，此外，相对于Iterator，使用Spliterator来遍历元素的成本是更低的，因为避免了在使用hasNext和next方法的竞争的出现（使用Iterators遍历元素通常需要两者搭配使用，但Spliterator只需要通过一个方法tryAdvance）。\",\"For mutable sources, arbitrary and non-deterministic behavior may occur if the source is structurally interfered with (elements added, replaced, or removed) between the time that the Spliterator binds to its data source and the end of traversal. For example, such interference will produce arbitrary, non-deterministic results when using the java.util.stream framework. \",\"对于可变的元来说，如果元在绑定了Spliterator之后，遍历结束之前在结构上被修改了（元素的添加、替换、移除）就可能出现一些不确定的行为，比如说，在使用java.util.stream 框架的这种修改可能出现这些不确定的结果。\",\"Structural interference of a source can be managed in the following ways (in approximate order of decreasing desirability): \",\"一个元在结构上的改变是可以通过如下的几种方式来进行管理的：\",\"The source cannot be structurally interfered with. For example, an instance of java.util.concurrent.CopyOnWriteArrayList is an immutable source. A Spliterator created from the source reports a characteristic of IMMUTABLE. \",\"1、元的结构是不能被修改的，例如，java.util.concurrent.CopyOnWriteArrayLis就是一个不可变的元，通过这种元创建的Spliterator会返回一个IMMUTABLE的特性值。\",\"The source manages concurrent modifications. For example, a key set of a java.util.concurrent.ConcurrentHashMap is a concurrent source. A Spliterator created from the source reports a characteristic of CONCURRENT. \",\"2、元本身管理并发修改，例如java.util.concurrent.ConcurrentHashMap键的集合就是一个并发的元，通过这种元创建的Spliterator会返回一个CONCURRENT的特性值。\",\"The mutable source provides a late-binding and fail-fast Spliterator. Late binding narrows the window during which interference can affect the calculation; fail-fast detects, on a best-effort basis, that structural interference has occurred after traversal has commenced and throws ConcurrentModificationException. For example, ArrayList, and many other non-concurrent Collection classes in the JDK, provide a late-binding, fail-fast spliterator. \",\"3、可变的元提供了一种延迟绑定和快速失败的Spliterator，延迟绑定会限制修改影响计算的时间间隔，可变的元\",\"The mutable source provides a non-late-binding but fail-fast Spliterator. The source increases the likelihood of throwing ConcurrentModificationException since the window of potential interference is larger. \",\"4、可变的元提供了非延迟绑定但是快速失败的Spliterator，发生ConcurrentModificationException可能性就会增加，因为时间间隔增大了。\",\"The mutable source provides a late-binding and non-fail-fast Spliterator. The source risks arbitrary, non-deterministic behavior after traversal has commenced since interference is not detected. \",\"5、可变的元提供了延迟绑定但是非快速失败的Spliterator，这个时候元就有一些风险，在遍历已经开始之后就可能发生一些不确定的行为。\",\"The mutable source provides a non-late-binding and non-fail-fast Spliterator. The source increases the risk of arbitrary, non-deterministic behavior since non-detected interference may occur after construction. \",\"6、可变的元提供了延迟绑定并且快速失败的Spliterator，也会增加不确定的风险，在构造之后增加不确定的行为的可能。\",\"Example. Here is a class (not a very useful one, except for illustration) that maintains an array in which the actual data are held in even locations, and unrelated tag data are held in odd locations. Its Spliterator ignores the tags. \",\"这里给出了一个例子（并不具有实用性，只是为了说明问题），数据实际上是存储在数组的偶数位置上，不相关的标签数据是存放在基数的位置上的，它对应的Spliterator会忽略掉标签，即只关心偶书位置上的数据：\",\" class TaggedArray<T> { // 构造之后就是一个不可变的数组 private final Object[] elements; TaggedArray(T[] data, Object[] tags) { int size = data.length; // 数据和标签的个数应该相同 if (tags.length != size) throw new IllegalArgumentException(); this.elements = new Object[2 * size]; for (int i = 0, j = 0; i < size; ++i) { elements[j++] = data[i]; elements[j++] = tags[i]; } } public Spliterator<T> spliterator() { return new TaggedArraySpliterator<>(elements, 0, elements.length); } static class TaggedArraySpliterator<T> implements Spliterator<T> { private final Object[] array; // 当前的索引，在遍历的时候会自增 private int origin; // 超过最大索引值加1 private final int fence; TaggedArraySpliterator(Object[] array, int origin, int fence) { this.array = array; this.origin = origin; this.fence = fence; } public void forEachRemaining(Consumer<? super T> action) { for (; origin < fence; origin += 2) action.accept((T) array[origin]); } public boolean tryAdvance(Consumer<? super T> action) { if (origin < fence) { action.accept((T) array[origin]); // tag中的数据不需要 origin += 2; return true; } else return false; } public Spliterator<T> trySplit() { // 分开一半的范围 int lo = origin; // 取中点 int mid = ((lo + fence) >>> 1) & ~1; // 分割左侧的 if (lo < mid) { // 重新设置范围 origin = mid; return new TaggedArraySpliterator<>(array, lo, mid); } else // 太小了，无法分割 return null; } public long estimateSize() { return (long)((fence - origin) / 2); } public int characteristics() { return ORDERED | SIZED | IMMUTABLE | SUBSIZED; } } } \",\"上面的例子是一个串行的例子，接下来还提供了一个并行的例子。\",\"As an example how a parallel computation framework, such as the java.util.stream package, would use Spliterator in a parallel computation, here is one way to implement an associated parallel forEach, that illustrates the primary usage idiom of splitting off subtasks until the estimated amount of work is small enough to perform sequentially. Here we assume that the order of processing across subtasks doesn't matter; different (forked) tasks may further split and process elements concurrently in undetermined order. This example uses a java.util.concurrent.CountedCompleter; similar usages apply to other parallel task constructions. \",\"如何使用并行框架来尽心给计算，例如使用java.util.stream package，在并行情况下使用Spliterator，它描述了对于分割子任务的分割方法，如何将子任务进行分割，如果分割的足够小的话，再以串行的方式去执行，下面的例子使用了java.util.concurrent.CountedCompleter：\",\"static <T> void parEach(TaggedArray<T> a, Consumer<T> action) { Spliterator<T> s = a.spliterator(); long targetBatchSize = s.estimateSize() / (ForkJoinPool.getCommonPoolParallelism() * 8); new ParEach(null, s, action, targetBatchSize).invoke(); } static class ParEach<T> extends CountedCompleter<Void> { final Spliterator<T> spliterator; final Consumer<T> action; final long targetBatchSize; ParEach(ParEach<T> parent, Spliterator<T> spliterator, Consumer<T> action, long targetBatchSize) { super(parent); this.spliterator = spliterator; this.action = action; this.targetBatchSize = targetBatchSize; } public void compute() { Spliterator<T> sub; while (spliterator.estimateSize() > targetBatchSize && (sub = spliterator.trySplit()) != null) { addToPendingCount(1); new ParEach<>(this, sub, action, targetBatchSize).fork(); } spliterator.forEachRemaining(action); propagateCompletion(); } } \",\"If the boolean system property org.openjdk.java.util.stream.tripwire is set to true then diagnostic warnings are reported if boxing of primitive values occur when operating on primitive subtype specializations. \",\"如果系统变量org.openjdk.java.util.stream.tripwire被设置成true的话，如果在操作原生子类型特化的时候，对原生的子类型进行装箱操作，系统就会给出警告。\",\"以上是关于Spliterator这个类本身的说明，接下来Spliterator接口本身提供的一些方法进行说明：\",\"首先是tryAdvance方法：\",\"boolean tryAdvance(Consumer<? super T> action); \",\"方法的说明：\",\"If a remaining element exists, performs the given action on it, returning true; else returns false. If this Spliterator is ORDERED the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller. \",\"如果元素存在，就会对元素执行给定的action方法，同时true，否则返回false，如果这个Spliterator是ORDERED，就会对的下一个元素去执行action方法，由这个动作执行产生的任何的异常都会传递给调用者。\",\"接下来是forEachRemaining方法：\",\" default void forEachRemaining(Consumer<? super T> action) { do { } while (tryAdvance(action)); } \",\"方法的说明：\",\"Performs the given action for each remaining element, sequentially in the current thread, until all elements have been processed or the action throws an exception. If this Spliterator is ORDERED, actions are performed in encounter order. Exceptions thrown by the action are relayed to the caller.The default implementation repeatedly invokes tryAdvance until it returns false. It should be overridden whenever possible. \",\"对剩下的元素都执行action方法，在当前的线程是以串行的方式执行，知道所有的元素都已经被处理了，或者动作本身抛出了异常，如果Spliterator是ORDERED，action会以遇到元素的顺序去执行，由这个动作抛出的异常会被传递给调用者。默认的实现是不断的调用tryAdvance方法直到返回false，在合适的时候应该被重写。\",\"接下来是trySplit方法：\",\" Spliterator<T> trySplit(); \",\"方法的说明：\",\"If this spliterator can be partitioned, returns a Spliterator covering elements, that will, upon return from this method, not be covered by this Spliterator. If this Spliterator is ORDERED, the returned Spliterator must cover a strict prefix of the elements. Unless this Spliterator covers an infinite number of elements, repeated calls to trySplit() must eventually return null. Upon non-null return: \",\"如果这个Spliterator是可以被分割的，就会返回一个新的Spliterator对象，新的Spliterator可能可以进一步分割，剩余的元素是由当前的Spliterator继续涵盖的。\",\"如果这个Spliterator是ORDERED，所返回的Spliterator必须也是ORDERED，除了Spliterator涵盖的是一个无限元素的对象的情况，重复调用trySplit最终得到的结果一定是空，当不为空的情况出现的时候：\",\"the value reported for estimateSize() before splitting, must, after splitting, be greater than or equal to estimateSize() for this and the returned Spliterator; and \",\"1、在分割之前estimateSize方法所估算的元的大小的值，必须在分割之后，一定要大于或者等于当前的和返回的新的Spliterator的estimateSize方法所返回的值。\",\"if this Spliterator is SUBSIZED, then estimateSize() for this spliterator before splitting must be equal to the sum of estimateSize() for this and the returned Spliterator after splitting. \",\"2、如果Spliterator是SUBSIZED，那么在分割之前Spliterator的estimateSize的值必须等于分割之后所剩下的estimateSize以及剩下的Spliteratord的estimateSize加起来必须相等。\",\"This method may return null for any reason, including emptiness, inability to split after traversal has commenced, data structure constraints, and efficiency considerations. \",\"这个方法有可能会返回一个空值，包括原来的就是Spliterator就是空的，在遍历开始之后无法分割，数据结构上的限制，效率上的考量等等。\",\"n ideal trySplit method efficiently (without traversal) divides its elements exactly in half, allowing balanced parallel computation. Many departures from this ideal remain highly effective; for example, only approximately splitting an approximately balanced tree, or for a tree in which leaf nodes may contain either one or two elements, failing to further split these nodes. However, large deviations in balance and/or overly inefficient trySplit mechanics typically result in poor parallel performance. \",\"一种理想的trySplit方法在没有进行遍历的情况下，它会恰好就元素分成等量的两部分，这样并行计算的时候工作量是比较平均的。但更多的时候无法达到理想状态，比如说，只是分割一个近似平衡的树，或者对一个树，树中的叶子节点包含了一两个元素，没法再对这些节点进行进一步的分割，对于这种极度不平衡的树，没有效率的trySplit会是的并发执行的效率急剧下降。\",\"接下来是estimateSize方法：\",\"long estimateSize(); \",\"方法的说明：\",\"Returns an estimate of the number of elements that would be encountered by a forEachRemaining traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute. \",\"返回对于遍历可能会遇到的元中的元素的数量的估算值，如果元的元素是无限的、未知的、或者计算成本非常昂贵的时候，就会返回Long.MAX_VALUE。\",\"If this Spliterator is SIZED and has not yet been partially traversed or split, or this Spliterator is SUBSIZED and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of trySplit. \",\"如果这个Spliterator是SIZED，并且还没有被分割或者迭代，或者Spliterator是SUBSIZED的，但还没有被部分遍历，那么estimate返回的就一定是一个精确的值，就是要被遍历的元素的个数，否则，estimate估算就可能是不精确的，但是必须要随着trySplit方法的调用次数不断减少。\",\"Even an inexact estimate is often useful and inexpensive to compute. For example, a sub-spliterator of an approximately balanced binary tree may return a value that estimates the number of elements to be half of that of its parent; if the root Spliterator does not maintain an accurate count, it could estimate size to be the power of two corresponding to its maximum depth. \",\"estimate方法估算的值通常而言也是有用的，并且计算起来成本也不高，对一个近似平衡的二叉树的sub-spliterator，它会估算父亲节点的元素的一般，如果根Spliterator没有保存正确的计算结果，那么他就会根据树的深度返回2的指数次方，以此来估算元中元素的个数。\",\"接下来是getExactSizeIfKnown方法：\",\" default long getExactSizeIfKnown() { return (characteristics() & SIZED) == 0 ? -1L : estimateSize(); } \",\"方法的说明：\",\"Convenience method that returns estimateSize() if this Spliterator is SIZED, else -1. \",\"如果Spliterator是SIZED就会返回estimateSize的值，否则返回-1。\",\"接下来是characteristics方法：\",\"int characteristics(); \",\"方法的说明：\",\"Returns a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result. \",\"返回Spliterator和它的元素特性值的集合，这种结果用ORed值来表示的，共有八个，在trySplit调用之前和调用当中重复地调用这个方法，永远都会返回相同的结果。\",\"If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator. \",\"如果返回了不同的特性值的集合（分割之前和分割之后有可能特性值会不同），那么对于Spliterator的任何计算都是不受保障。\",\"接下来是hasCharacteristics方法：\",\" default boolean hasCharacteristics(int characteristics) { return (characteristics() & characteristics) == characteristics; } \",\"方法的说明：\",\"Returns true if this Spliterator's characteristics contain all of the given characteristics. \",\"判断当前的Spliterator是否包含传入的characteristics特性值。\",\"接下来是getComparator方法：\",\" default Comparator<? super T> getComparator() { throw new IllegalStateException(); } \",\"方法的说明：\",\"If this Spliterator's source is SORTED by a Comparator, returns that Comparator. If the source is SORTED in natural order, returns null. Otherwise, if the source is not SORTED, throws IllegalStateException. \",\"如果这个Spliterator的元通过Comparator是SORTED，那么返回用于排序的比较器，如果元在自然序列下是SORTED，返回null，如果元不是有序的，抛出IllegalStateException异常。\",\"接下来是八个特性值：\",\" public static final int ORDERED = 0x00000010; public static final int DISTINCT = 0x00000001; public static final int SORTED = 0x00000004; public static final int SIZED = 0x00000040; public static final int NONNULL = 0x00000100; public static final int IMMUTABLE = 0x00000400; // 不能同时返回SIZED和CONCURRENT，如果多个线程访问元，就有可能修改元的大小 public static final int CONCURRENT = 0x00001000; public static final int SUBSIZED = 0x00004000; \",\"除了以上非常核心的方法，Spliterator中还有两个接口OfPrimitive和OfInt。\",\"public interface OfPrimitive<T, T_CONS, T_SPLITR extends Spliterator.OfPrimitive<T, T_CONS, T_SPLITR>> extends Spliterator<T> { @Override T_SPLITR trySplit(); @SuppressWarnings(\\\"overloads\\\") boolean tryAdvance(T_CONS action); @SuppressWarnings(\\\"overloads\\\") default void forEachRemaining(T_CONS action) { do { } while (tryAdvance(action)); } } \",\"相关说明：\",\"A Spliterator specialized for primitive values. <T> – the type of elements returned by this Spliterator. The type must be a wrapper type for a primitive type, such as Integer for the primitive int type. <T_CONS> – the type of primitive consumer. The type must be a primitive specialization of Consumer for T, such as IntConsumer for Integer. <T_SPLITR> – the type of primitive Spliterator. The type must be a primitive specialization of Spliterator for T, such as Spliterator.OfInt for Integer. \",\"这是一个针对原生值设定的Spliterator，T表示由当前的Spliterator所返回的元素的类型，类型必须要是原生类型的包装类型，比如int类型的包装类型Integer。T_CONS是原生的consumer特化的类型，这个类型必须是java.util.function.Consumer原生类型的特化，比如对于Integer的IntConsumer，T_SPLITR是原生的Spliterator分割迭代器的类型，必须是对于T类型的原生类型的特化，比如对于Integer的OfInt。\",\" public interface OfInt extends OfPrimitive<Integer, IntConsumer, OfInt> { @Override OfInt trySplit(); // 重写的OfPrimitive中的tryAdvance方法 @Override boolean tryAdvance(IntConsumer action); @Override default void forEachRemaining(IntConsumer action) { do { } while (tryAdvance(action)); } // 重写的Spliterator中的tryAdvance方法 @Override default boolean tryAdvance(Consumer<? super Integer> action) { if (action instanceof IntConsumer) { // IntConsumer和Consumer类型并没有直接继承的关系，这可以强转的原因是如果参数是Integer类型的，由于自动拆箱和自动装箱的原因存在，传递的action如果是Lambda表达式就既满足了Consumer的要求，也满足了IntConsumer的要求，另外是由于Lambda表达式中的类型判断是需要结合具体的上下文的。 return tryAdvance((IntConsumer) action); } else { if (Tripwire.ENABLED) Tripwire.trip(getClass(), \\\"{0} calling Spliterator.OfInt.tryAdvance((IntConsumer) action::accept)\\\"); return tryAdvance((IntConsumer) action::accept); } } @Override default void forEachRemaining(Consumer<? super Integer> action) { if (action instanceof IntConsumer) { forEachRemaining((IntConsumer) action); } else { if (Tripwire.ENABLED) Tripwire.trip(getClass(), \\\"{0} calling Spliterator.OfInt.forEachRemaining((IntConsumer) action::accept)\\\"); forEachRemaining((IntConsumer) action::accept); } } } \",\"相关说明：\",\"A Spliterator specialized for int values. \",\"针对于int值的分割迭代器。\",\"这其中比较重要的是第二个tryAdvance方法，首先来看方法的说明\",\"If the action is an instance of IntConsumer then it is cast to IntConsumer and passed to tryAdvance(IntConsumer); otherwise the action is adapted to an instance of IntConsumer, by boxing the argument of IntConsumer, and then passed to tryAdvance(IntConsumer). \",\"如果action是IntConsumer的一个实例，那么就会被强转为IntConsumer并传递给tryAdvance(IntConsumer)，否则，action会被适配成IntConsumer实例，方式是通过IntConsumer的参数进行装箱操作，然后再传递给tryAdvance(IntConsumer)。\",\"对于上面注释中提到的为什么可以强转，我们通过一个具体的例子来说明：\",\"public class ConsumerTest { public void test(Consumer<Integer> consumer) { consumer.accept(100); } public static void main(String[] args) { ConsumerTest consumerTest = new ConsumerTest(); // 两个相同的Lambda表达式 Consumer<Integer> consumer = i -> System.out.println(i); IntConsumer intConsumer = i -> System.out.println(i); // 面向对象的方式 consumerTest.test(consumer); // 编译通过但执行报错 consumerTest.test((Consumer<Integer>) intConsumer); // 传递行为，函数式的方式 consumerTest.test(consumer::accept); consumerTest.test(intConsumer::accept); } } \",\"除了OfInt之外还有其他两种OfLong、OfDouble，原理和功能都是类似的。\"]},\"1498\":{\"h\":\"Pipeline源码分析\",\"t\":[\"分割迭代器无疑是函数式编程中一个相当核心的概念，其地位与收集器相同，在了解了分割迭代器的相关内容之后，我们再回到一开始的例子当中，看看JDK是如何使用分割迭代器来构造流源的，还是回到最开始的入口这里：\",\"default Stream<E> stream() { return StreamSupport.stream(spliterator(), false); } \",\"这里的spliterator方法是定义Collection接口当中的一个默认方法：\",\" default Spliterator<E> spliterator() { // 这里的this表示的是当前集合的引用，当前集合的引用就是在这个时候被传递进去的 return Spliterators.spliterator(this, 0); } \",\"Spliterators中静态方法spliterator返回了一个Spliterator实现：\",\" public static <T> Spliterator<T> spliterator(Collection<? extends T> c, int characteristics) { return new IteratorSpliterator<>(Objects.requireNonNull(c), characteristics); } \",\"可以看到我们实际上使用的分割迭代器是IteratorSpliterator，IteratorSpliterator是实现了Spliterator接口的一个实现类，它本身持有了元数据集合的引用。\",\"创建流元的过程是由StreamSupport这个类来完成的，以下是关于StreamSupport这个类的说明：\",\"Low-level utility methods for creating and manipulating streams. This class is mostly for library writers presenting stream views of data structures; most static stream methods intended for end users are in the various Stream classes. \",\"提供了一些创建和操作流的底层方法。这个类是给类库的编写者提供的，用于呈现流的数据视图，为用户所设计的大多数的静态的流的方法大多都在stream类中提的方法。\",\"StreamSupport中的stream方法：\",\" public static <T> Stream<T> stream(Spliterator<T> spliterator, boolean parallel) { Objects.requireNonNull(spliterator); return new ReferencePipeline.Head<>(spliterator, StreamOpFlag.fromCharacteristics(spliterator), parallel); } \",\"方法的说明：\",\"Creates a new sequential or parallel Stream from a Spliterator. The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences. It is strongly recommended the spliterator report a characteristic of IMMUTABLE or CONCURRENT, or be late-binding. Otherwise, stream(Supplier, int, boolean) should be used to reduce the scope of potential interference with the source. See Non-Interference for more details. \",\"从一个分割迭代器对象创建一个串行或者并行的流，spliterator在流管道开启之后仅仅是完成遍历、分割、查询、大小的等功能，强烈建议spliterator返回IMMUTABLE、CONCURRENT或者late-binding这样一些特性，否则，stream应该用于减少潜在的干扰，查看Non-Interference获取更多信息。\",\"这里引出了另外一个及其重要的类ReferencePipeline，用于描述中间的管道阶段和管道源阶段的的类，它与流的操作息息相关，Head是ReferencePipeline的一个静态内部类，描述的是管道的源阶段，二者在大部分属性的设定上都是类似的，但存在一些属性是不同的，比如说Head是没有previousStage的，而ReferencePipeline则是存在previousStage的，等等。接下来就需要重点了解管道流相关的内容。\",\"首先是定义在ReferencePipeline类当中的内部类Head：\",\" static class Head<E_IN, E_OUT> extends ReferencePipeline<E_IN, E_OUT> { Head(Supplier<? extends Spliterator<?>> source, int sourceFlags, boolean parallel) { super(source, sourceFlags, parallel); } // 这里Spliterator作为流的源 Head(Spliterator<?> source, int sourceFlags, boolean parallel) { super(source, sourceFlags, parallel); } @Override final boolean opIsStateful() { throw new UnsupportedOperationException(); } @Override final Sink<E_IN> opWrapSink(int flags, Sink<E_OUT> sink) { throw new UnsupportedOperationException(); } @Override public void forEach(Consumer<? super E_OUT> action) { if (!isParallel()) { sourceStageSpliterator().forEachRemaining(action); } else { super.forEach(action); } } @Override public void forEachOrdered(Consumer<? super E_OUT> action) { if (!isParallel()) { sourceStageSpliterator().forEachRemaining(action); } else { super.forEachOrdered(action); } } } \",\"Head类本身有两个泛型：\",\"<E_IN> – type of elements in the upstream source <E_OUT> – type of elements in produced by this stage \",\"E_IN表示上游流源的元素类型，E_OUT表示这个阶段生成的元素类型。\",\"真正在创建的时候又是调用了ReferencePipeline的构造方法：\",\" ReferencePipeline(Supplier<? extends Spliterator<?>> source, int sourceFlags, boolean parallel) { super(source, sourceFlags, parallel); } \",\"而ReferencePipeline的构造方法又调用了它的父类AbstractPipeline的构造方法：\",\" AbstractPipeline(Supplier<? extends Spliterator<?>> source, int sourceFlags, boolean parallel) { this.previousStage = null; this.sourceSupplier = source; this.sourceStage = this; this.sourceOrOpFlags = sourceFlags & StreamOpFlag.STREAM_MASK; // The following is an optimization of: // StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE); this.combinedFlags = (~(sourceOrOpFlags << 1)) & StreamOpFlag.INITIAL_OPS_VALUE; this.depth = 0; this.parallel = parallel; } \",\"AbstractPipeline的说明如下：\",\"Abstract base class for \\\"pipeline\\\" classes, which are the core implementations of the Stream interface and its primitive specializations. Manages construction and evaluation of stream pipelines. \",\"AbstractPipeline是对于管道类抽象出来的一个父类，管道类指的是流接口以及其原生特化的核心的实现，它会管理流管道的构建以及计算。\",\"An AbstractPipeline represents an initial portion of a stream pipeline, encapsulating a stream source and zero or more intermediate operations. The individual AbstractPipeline objects are often referred to as stages, where each stage describes either the stream source or an intermediate operation. \",\"AbstractPipeline代表了流管道初始的阶段，它封装了一个流源和0个或者多个中间操作，每一个单个的AbstractPipeline通常称为stages（阶段），这个阶段要么描述的是流的源，要么描述的是中间操作。\",\"A concrete intermediate stage is generally built from an AbstractPipeline, a shape-specific pipeline class which extends it (e.g., IntPipeline) which is also abstract, and an operation-specific concrete class which extends that. AbstractPipeline contains most of the mechanics of evaluating the pipeline, and implements methods that will be used by the operation; the shape-specific classes add helper methods for dealing with collection of results into the appropriate shape-specific containers. \",\"一个具体的中间阶段通常是通过AbstractPipeline构建出来的，特化的管道类（IntPipeline、LongPipeline）操作都是类似的，AbstractPipeline包含了大多数计算管道的机制，并且实现了操作的时候要使用的方法，与原生特定相关的类增加了用来处理结果集合添加到特定的特化的管道。\",\"After chaining a new intermediate operation, or executing a terminal operation, the stream is considered to be consumed, and no more intermediate or terminal operations are permitted on this stream instance. \",\"当链接一个新的中间操作，或者执行一个终止操作，流就会被认为被消费掉了，不会再有中间操作和终止操作添加到这个流实例上了。\",\"For sequential streams, and parallel streams without stateful intermediate operations, parallel streams, pipeline evaluation is done in a single pass that \\\"jams\\\" all the operations together. For parallel streams with stateful operations, execution is divided into segments, where each stateful operations marks the end of a segment, and each segment is evaluated separately and the result used as the input to the next segment. In all cases, the source data is not consumed until a terminal operation begins. \",\"对于串行流和中间操作都是无状态的并行流，管道的计算是在单个的过程中完成的（即不是通过链式调用，而是拿出一个元素执行所有的中间操作），对于有状态的并行流，管道的计算就会分成不同的段来执行，其中每一个有状态的都会标识一个段的结尾，每个段都会被单独的执行，而且每个段的执行结果会作为下一个段的输入（表示是有顺序的），直到一个终止操作开始的时候，源数据才会被消费。\",\"接下来是AbstractPipeline类中的一些属性：\",\" private final AbstractPipeline previousStage; \",\"属性的说明：\",\"The \\\"upstream\\\" pipeline, or null if this is the source stage. \",\"上游的pipline，如果是源阶段的话就是null。\",\" private final AbstractPipeline sourceStage; \",\"属性的说明：\",\"Backlink to the head of the pipeline chain (self if this is the source stage). \",\"表示管道反向链接的头（如果是源阶段就是它自身）。\",\" private int depth; \",\"属性的说明：\",\"The number of intermediate operations between this pipeline object and the stream source if sequential, or the previous stateful if parallel. Valid at the point of pipeline preparation for evaluation. \",\"当前的管道对象和流元的管道对象的中间操作的个数，在流准备进行计算的时候是有效的。\",\" private boolean parallel; \",\"属性的说明：\",\"True if pipeline is parallel, otherwise the pipeline is sequential; only valid for the source stage. \",\"如果是true表示并行，如果是false，表示串行，只有在流源这个阶段才有效。\",\" private Spliterator<?> sourceSpliterator; \",\"属性的说明：\",\"The source spliterator. Only valid for the head pipeline. Before the pipeline is consumed if non-null then sourceSupplier must be null. After the pipeline is consumed if non-null then is set to null. \",\"是针对于元的分割迭代器，只会head pipeline起作用，在管道被消费之前，如果sourceSpliterator是非空的话，那么sourceSupplier必须是null，管道被消费之后sourceSpliterator就要设置为空。\",\" private Supplier<? extends Spliterator<?>> sourceSupplier; \",\"属性的说明：\",\"The source supplier. Only valid for the head pipeline. Before the pipeline is consumed if non-null then sourceSpliterator must be null. After the pipeline is consumed if non-null then is set to null. \",\"supplier的元，只会head pipeline起作用，在管道被消费之前，如果sourceSupplier是空的，那么sourceSpliterator必须为空，在管道被消费之后，就要将sourceSupplier置为null。\",\"可以看到这两个成员变量可以认为是互斥的，必须要保证其中一个不为空，在流消费之后都要置为空，表示流已经消费完成，至此为止，流源的对象也已经构造完成。\"]},\"1499\":{\"h\":\"流调用机制与原理\",\"t\":[\"回到一开始的例子当中：\",\"list.stream().forEach(System.out::println); \",\"这里调用的第一个stream方法，使用分割迭代器来构造流源的这一步我们已经完成了，接下来我们来查看一下forEach方法的说明：\",\"Performs an action for each element of this stream. This is a terminal operation. \",\"它表示要对于流中每个元素都执行action操作，并且这是一个终止操作。\",\"The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does not guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library chooses. If the action accesses shared state, it is responsible for providing the required synchronization. \",\"这个操作的行为是不确定的，对于并行流管道来说，这个操作并不会保证它会遵循流当中元素的顺序，因为如果遵循的话，就会牺牲并行的优势，对于任意给定的元素，这个action可能会在任意的时间或者库所选择的任意线程中去执行，如果库访问了共享的状态，那么它就需要提供完整的同步机制。\",\"list.parallelStream().forEach(System.out::println); \",\"这其实指的就是如果使用并行流，那么就无法再保证执行给定的Lambda表达式的元素的顺序了，这个方法实际上在ReferencePipeline中是有两个实现的，一个是在它的静态内部类Head中：\",\" @Override public void forEach(Consumer<? super E_OUT> action) { // 对串行流进行优化 if (!isParallel()) { sourceStageSpliterator().forEachRemaining(action); } else { // 如果是并行流，调用ReferencePipeline中的forEach方法 super.forEach(action); } } \",\"这个是针对于管道源的有过优化的实现，换句话说，如果被流的源调用的话，就是直接进入这个方法，另一个forEach方法是在ReferencePipeline当中：\",\" @Override public void forEach(Consumer<? super P_OUT> action) { evaluate(ForEachOps.makeRef(action, false)); } \",\"当有中间操作的时候，都会进入这个方法，之所以会有这个差异，就是为了效率上的考量，如果有中间操作的话，就需要对于中间操作进行一般化的处理，如果没有的话，就可以直接对流源进行操作。\",\"我们不妨来看一下优化的时候调用的sourceStageSpliterator方法，它是定义在AbstractPipeline当中的\",\" final Spliterator<E_OUT> sourceStageSpliterator() { if (this != sourceStage) throw new IllegalStateException(); // 被链接或者被消费，为了保证是在源阶段 if (linkedOrConsumed) // MSG_STREAM_LINKED = \\\"stream has already been operated upon or closed\\\"; throw new IllegalStateException(MSG_STREAM_LINKED); linkedOrConsumed = true; // 流源可能通过两种方式来构建，因此有两种情况，并且这两种情况是互斥的 if (sourceStage.sourceSpliterator != null) { @SuppressWarnings(\\\"unchecked\\\") Spliterator<E_OUT> s = sourceStage.sourceSpliterator; sourceStage.sourceSpliterator = null; return s; } else if (sourceStage.sourceSupplier != null) { @SuppressWarnings(\\\"unchecked\\\") Spliterator<E_OUT> s = (Spliterator<E_OUT>) sourceStage.sourceSupplier.get(); sourceStage.sourceSupplier = null; return s; } else { // MSG_CONSUMED = \\\"source already consumed or closed\\\"; throw new IllegalStateException(MSG_CONSUMED); } } \",\"方法的说明：\",\"Gets the source stage spliterator if this pipeline stage is the source stage. The pipeline is consumed after this method is called and returns successfully. \",\"如果管道的阶段是源阶段的话，就会返回源阶段的分割迭代器，这个管道在被调用之后，就会返回并且销毁。\",\"我们知道一般情况下分割迭代器返回的是IteratorSpliterator实现，我们来看一下IteratorSpliterator中对于forEachRemaining的实现：\",\" @Override public void forEachRemaining(Consumer<? super T> action) { if (action == null) throw new NullPointerException(); Iterator<? extends T> i; // it是Spliterator中定义的迭代器 if ((i = it) == null) { // 当前集合的迭代器 i = it = collection.iterator(); est = (long)collection.size(); } i.forEachRemaining(action); } \",\"这里将集合中的迭代器找出来并且估算元素的大小，然后再调用Iterator中的新增加的forEachRemaining方法：\",\" default void forEachRemaining(Consumer<? super E> action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); } \",\"看到这里我们就明白了，对于简单的遍历，使用传统的Iterator遍历的效率是要比流的方式效率要高的，当然这是因为我们是没有任何的中间操作，如果有了一系列的中间操作，那么使用流的方式效率还是比传统的方式要高的。\",\"list.stream().map(item -> item).forEach(System.out::println); \",\"在ReferencePipeline当中，map方法只有唯一的实现：\",\" public final <R> Stream<R> map(Function<? super P_OUT, ? extends R> mapper) { Objects.requireNonNull(mapper); // 返回StatelessOp的匿名内部类对象，this表示ReferencePipeline，第二个参数表示流的类型是引用类型的，第三个是流的特性值 return new StatelessOp<P_OUT, R>(this, StreamShape.REFERENCE, StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) { @Override Sink<P_OUT> opWrapSink(int flags, Sink<R> sink) { return new Sink.ChainedReference<P_OUT, R>(sink) { // 真正执行传入Lambda表达式的地方 @Override public void accept(P_OUT u) { downstream.accept(mapper.apply(u)); } }; } }; } \",\"这里的StatelessOp也是定义在ReferencePipeline当中的一个静态内部类：\",\" abstract static class StatelessOp<E_IN, E_OUT> extends ReferencePipeline<E_IN, E_OUT> { StatelessOp(AbstractPipeline<?, E_IN, ?> upstream, StreamShape inputShape, int opFlags) { super(upstream, opFlags); assert upstream.getOutputShape() == inputShape; } @Override final boolean opIsStateful() { return false; } } \",\"相关说明：\",\"Construct a new Stream by appending a stateless intermediate operation to an existing stream. \",\"构造一个针对无状态的中间的阶段的流，这里的构造方法又调用了ReferencePipeline的构造方法：\",\" ReferencePipeline(AbstractPipeline<?, P_IN, ?> upstream, int opFlags) { super(upstream, opFlags); } \",\"方法的说明：\",\"Constructor for appending an intermediate operation onto an existing pipeline. \",\"这个构造方法完成的就是对于已经存在的管道追加一个中间操作，upstream表示上游元素的源。\",\"这里又调用了AbstractPipeline的构造方法：\",\"AbstractPipeline(AbstractPipeline<?, E_IN, ?> previousStage, int opFlags) { if (previousStage.linkedOrConsumed) throw new IllegalStateException(MSG_STREAM_LINKED); // 标识为已经消费 previousStage.linkedOrConsumed = true; previousStage.nextStage = this; this.previousStage = previousStage; this.sourceOrOpFlags = opFlags & StreamOpFlag.OP_MASK; this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags); this.sourceStage = previousStage.sourceStage; if (opIsStateful()) sourceStage.sourceAnyStateful = true; // 深度加1 this.depth = previousStage.depth + 1; } \",\"方法的说明：\",\"Constructor for appending an intermediate operation stage onto an existing pipeline. \",\"向一个已有的管道用于追加一个中间操作。\",\"这里也可以看到这个构造方法与我们之前见过的有关构造流源的构造方法的作用完全不同，回到刚才的例子当中，除了上面追加中间操作的部分，还涉及到了另外一个及其重要的类Sink，一般翻译为饮水槽，这是我们了解整个流调用机制的最后一个类。\"]},\"1500\":{\"h\":\"Sink源码分析\",\"t\":[\"An extension of Consumer used to conduct values through the stages of a stream pipeline, with additional methods to manage size information, control flow, etc. Before calling the accept() method on a Sink for the first time, you must first call the begin() method to inform it that data is coming (optionally informing the sink how much data is coming), and after all data has been sent, you must call the end() method. After calling end(), you should not call accept() without again calling begin(). Sink also offers a mechanism by which the sink can cooperatively signal that it does not wish to receive any more data (the cancellationRequested() method), which a source can poll before sending more data to the Sink. \",\"Sink是Consumer接口的一个扩展，用于在整个流管道阶段处理值，还提供了一些额外的信息，比如管理大小的信息，控制流程，等等。在首次调用Sink的accept之前必须先调用begin方法来通知数据即将到达，同时你也可以通知Sink需要处理的数据量是多少，在所有的数据发送完成之后，必须调用end方法，在调用完end方法，你就不应该再去调用accept方法，如果还想调用，就需要再调用一次begin方法，Sink本身可以通过cancellationRequested方法来发出不要再接收数据的信号，那么源在发送数据之前就可以根据判断是否要向Sink发送数据。\",\"A sink may be in one of two states: an initial state and an active state. It starts out in the initial state; the begin() method transitions it to the active state, and the end() method transitions it back into the initial state, where it can be re-used. Data-accepting methods (such as accept() are only valid in the active state. \",\"一个Sink一定是处于两种状态之一的，一种是初始状态，另一种是激活状态，首先它是从初始状态开始的，使用begin方法可以将它从初始状态转换成激活状态，使用end方法可以将它从激活状态转换成初始状态，这样调用完之后就可以重用了，对于Sink来说，只有在激活状态下才可以接收数据。\",\"A stream pipeline consists of a source, zero or more intermediate stages (such as filtering or mapping), and a terminal stage, such as reduction or for-each. For concreteness, consider the pipeline: \",\"一个流管道包含了0个或多个中间阶段（比如过滤、映射），还有一个终止阶段，比如汇聚等等，具体考虑下面这个pipeline：\",\"int longestStringLengthStartingWithA = strings.stream() .filter(s -> s.startsWith(\\\"A\\\")) .mapToInt(String::length) .max(); \",\"继续往下：\",\"Here, we have three stages, filtering, mapping, and reducing. The filtering stage consumes strings and emits a subset of those strings; the mapping stage consumes strings and emits ints; the reduction stage consumes those ints and computes the maximal value. \",\"这里对我们而言有三个阶段，过滤，映射，汇聚，过滤阶段会消耗字符串集合，会输出字符串的子集，映射阶段会消耗字符串集合，映射成整型值，汇聚阶段会消耗这个整型值并求出最大值。\",\"A Sink instance is used to represent each stage of this pipeline, whether the stage accepts objects, ints, longs, or doubles. Sink has entry points for accept(Object), accept(int), etc, so that we do not need a specialized interface for each primitive specialization. (It might be called a \\\"kitchen sink\\\" for this omnivorous tendency.) The entry point to the pipeline is the Sink for the filtering stage, which sends some elements \\\"downstream\\\" -- into the Sink for the mapping stage, which in turn sends integral values downstream into the Sink for the reduction stage. The Sink implementations associated with a given stage is expected to know the data type for the next stage, and call the correct accept method on its downstream Sink. Similarly, each stage must implement the correct accept method corresponding to the data type it accepts. \",\"Sink实例是用来表示管道的每一个阶段，而无论这个阶段接收的类型，比如 ints, longs, or doubles，Sink对于accept有一个入口点，这样我们就不需要针对于原生类型的特化版本，上面的例子当中，就是一个过滤阶段，Sink会将值映射成整型值向下游发送，最后进行汇聚操作。\",\"Sink中的方法说明：\",\" default void begin(long size) {} \",\"方法的说明：\",\"Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling end(), you may call this method to reset the sink for another calculation. \",\"会重新设置Sink的状态并且刷新数据集，向Sink发送任何数据之前一定要调用这个方法，调用完end方法之后，可以再次调用这个方法来重置Sink来进行其他的计算。\",\" static abstract class ChainedReference<T, E_OUT> implements Sink<T> { // 表示下游的操作 protected final Sink<? super E_OUT> downstream; // 会保存下游的对象 public ChainedReference(Sink<? super E_OUT> downstream) { this.downstream = Objects.requireNonNull(downstream); } @Override public void begin(long size) { downstream.begin(size); } @Override public void end() { downstream.end(); } @Override public boolean cancellationRequested() { return downstream.cancellationRequested(); } } \",\"类的说明：\",\"Abstract Sink implementation for creating chains of sinks. The begin, end, and cancellationRequested methods are wired to chain to the downstream Sink. This implementation takes a downstream Sink of unknown input shape and produces a Sink<T>. The implementation of the accept() method must call the correct accept() method on the downstream Sink. \",\"它是Sink的一个抽象实现，用于创建Sink的一个链，begin, end, 和cancellationRequested方法都会链接起来，这个实现会接收下游的Sink。\",\" abstract Sink<E_IN> opWrapSink(int flags, Sink<E_OUT> sink); \",\"Accepts a Sink which will receive the results of this operation, and return a Sink which accepts elements of the input type of this operation and which performs the operation, passing the results to the provided Sink. \",\"它会接收一个Sink作为当前操作的结果(E_OUT)，并且返回一个Sink，返回的Sink（E_IN）会接收这个操作的所对应的输入元素的类型并且执行这个操作，然后将结果传递给所提供的Sink。\",\"a sink which accepts elements, perform the operation upon each element, and passes the results (if any) to the provided Sink. \",\"返回的Sink会接收一个元素，并且对每个元素进行操作，最后将执行的结果（如果有的话）传递给提供的Sink。\",\"正是因为将执行的结果传递给了方法参数的Sink，才将一系列的Sink有机的串联了起来。\",\"The implementation may use the flags parameter to optimize the sink wrapping. For example, if the input is already DISTINCT, the implementation for the Stream#distinct() method could just return the sink it was passed. \",\"可以使用flags来优化sink，例如，如果输入一定是不同，那么实现的时候，stream.distinct()方法就可以不用再去执行。\",\"总的来说在进行中间操作的时候，StatelessOp继承了ReferencePipeline，而ReferencePipeline又实现了Stream接口，通过StatelessOp创建饮水槽，将中间操作串联起来。\",\"public static <T> TerminalOp<T, Void> makeRef(Consumer<? super T> action, boolean ordered) { Objects.requireNonNull(action); return new ForEachOp.OfRef<>(action, ordered);} \",\"actory for creating instances of TerminalOp that perform an action for every element of a stream. Supported variants include unordered traversal (elements are provided to the Consumer as soon as they are available), and ordered traversal (elements are provided to the Consumer in encounter order.) \",\"这是一个工厂，用来创建终止操作的实例，终止操作会对流中的每个元素执行action，支持的变化包括无序的遍历（只要还有元素，就将元素提供给Consumer）还有一种有序的遍历（按照元素输入的顺序提供给Consumer）\",\"Elements are provided to the Consumer on whatever thread and whatever order they become available. For ordered traversals, it is guaranteed that processing an element happens-before processing subsequent elements in the encounter order. \",\"在可用的任意的顺序，任意线程都会将元素提供给Consumer ，对于有序的遍历而言，会保证处理一个元素一定是happens-before（某一件事情一定是发生在另外一件事情之前）处理后续的元素之前，即先遇到的先遍历。\",\"makeRef方法的说明：\",\"Constructs a TerminalOp that perform an action for every element of a stream. \",\"构造了一个终止操作，并且对流中的每个元素都执行给定的动作。\",\"interface TerminalOp<E_IN, R> { // 默认是引用类型 default StreamShape inputShape() { return StreamShape.REFERENCE; } default int getOpFlags() { return 0; } // 并行的方式 default <P_IN> R evaluateParallel(PipelineHelper<E_IN> helper, Spliterator<P_IN> spliterator) { if (Tripwire.ENABLED) Tripwire.trip(getClass(), \\\"{0} triggering TerminalOp.evaluateParallel serial default\\\"); return evaluateSequential(helper, spliterator); } // 串行的方式 <P_IN> R evaluateSequential(PipelineHelper<E_IN> helper, Spliterator<P_IN> spliterator); } \",\"类的说明：\",\"An operation in a stream pipeline that takes a stream as input and produces a result or side-effect. A TerminalOp has an input type and stream shape, and a result type. A TerminalOp also has a set of operation flags that describes how the operation processes elements of the stream (such as short-circuiting or respecting encounter order; see StreamOpFlag). \",\"这是流管道中的一个操作，它会接收一个流作为输入，生成一个结果或者拥有副作用（修改传入参数的引用），一个终止操作会拥有一个输入类型和一个流的类型（引用、整型、长整型等）和一个结果类型，一个终止操作描述了描述了流是如何处理流中元素的（比如短路、有序的执行）。\",\"A TerminalOp must provide a sequential and parallel implementation of the operation relative to a given stream source and set of intermediate operations. \",\"终止操作对于给定的流源和中间操作一定要提供并行和串行的实现。\",\"实际上，终止操作的数量并不是特别多。\",\"A TerminalOp that evaluates a stream pipeline and sends the output to itself as a TerminalSink. Elements will be sent in whatever thread they become available. If the traversal is unordered, they will be sent independent of the stream's encounter order. \",\"这是一个终止操作，它会计算一个流福安到并且将结果发送给自身作为一个TerminalSink，元素如果可用的话会发送给任意一个线程，如果遍历是无序的，那么在遍历的时候就会独立于流中输入的顺序。\",\"This terminal operation is stateless. For parallel evaluation, each leaf instance of a ForEachTask will send elements to the same TerminalSink reference that is an instance of this class. \",\"这个终止操作是无状态的，对于并行计算，每一个叶子节点都会发送个这个类的同一个TerminalSink实例。\",\"Evaluate the pipeline with a terminal operation to produce a result. \",\"执行一个终止的操作，并且返回一个结果。\",\" final <R> R evaluate(TerminalOp<E_OUT, R> terminalOp) { assert getOutputShape() == terminalOp.inputShape(); if (linkedOrConsumed) throw new IllegalStateException(MSG_STREAM_LINKED); linkedOrConsumed = true; return isParallel() ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags())) : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags())); } \",\"串行的实现：\",\" @Override public <S> Void evaluateSequential(PipelineHelper<T> helper, Spliterator<S> spliterator) { return helper.wrapAndCopyInto(this, spliterator).get(); } \",\"Helper class for executing stream pipelines, capturing all of the information about a stream pipeline (output shape, intermediate operations, stream flags, parallelism, etc) in one place. \",\"这是一个执行流管道的辅助类，它会在一个地方捕获关于流管道的所有信息（输出种类，中间操作，特性值，并行或者串行）。\",\"A PipelineHelper describes the initial segment of a stream pipeline, including its source, intermediate operations, and may additionally incorporate information about the terminal (or stateful) operation which follows the last intermediate operation described by this PipelineHelper. The PipelineHelper is passed to the TerminalOp. evaluateParallel(PipelineHelper, Spliterator), TerminalOp.evaluateSequential(PipelineHelper, Spliterator), and AbstractPipeline.opEvaluateParallel(PipelineHelper, Spliterator, IntFunction), methods, which can use the PipelineHelper to access information about the pipeline such as head shape, stream flags, and size, and use the helper methods such as wrapAndCopyInto(Sink, Spliterator), copyInto(Sink, Spliterator), and wrapSink(Sink) to execute pipeline operations. \",\"PipelineHelper描述了一个流管道最开始的阶段，包括它的源，中间操作，以及一些附加的信息关于终止的有状态的操作。\",\"abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT, S>> extends PipelineHelper<E_OUT> implements BaseStream<E_OUT, S> \",\" @Override public <S> Void evaluateParallel(PipelineHelper<T> helper, Spliterator<S> spliterator) { if (ordered) new ForEachOrderedTask<>(helper, spliterator, this).invoke(); else new ForEachTask<>(helper, spliterator, helper.wrapSink(this)).invoke(); return null; } \",\" abstract<P_IN, S extends Sink<P_OUT>> S wrapAndCopyInto(S sink, Spliterator<P_IN> spliterator); \",\"方法的说明：\",\"Applies the pipeline stages described by this PipelineHelper to the provided Spliterator and send the results to the provided Sink. \",\"将PipelineHelper所描述的管道阶段应用到所提供的Spliterator同时把结果发送给提供的Sink。\",\"这个方法在AbstractPipeline中有唯一的实现：\",\" @Override final <P_IN, S extends Sink<E_OUT>> S wrapAndCopyInto(S sink, Spliterator<P_IN> spliterator) { copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator); return sink; } \",\"这里的wrapSink方法如下：\",\" abstract<P_IN> Sink<P_IN> wrapSink(Sink<P_OUT> sink); \",\"方法的说明：\",\"Takes a Sink that accepts elements of the output type of the PipelineHelper, and wrap it with a Sink that accepts elements of the input type and implements all the intermediate operations described by this PipelineHelper, delivering the result into the provided Sink. \",\"它会接收PipelineHelper输出类型的元素，使用Sink对于接收到的所有的元素进行包装成由PipelineHelper所描述的中间操作，并且将结果传递给提供的Sink。\",\"这个方法就是对流中的中间操作进行串联的方法，具体的实现如下：\",\" @Override @SuppressWarnings(\\\"unchecked\\\") final <P_IN> Sink<P_IN> wrapSink(Sink<E_OUT> sink) { Objects.requireNonNull(sink); // 深度大于0说明有中间操作。 for ( @SuppressWarnings(\\\"rawtypes\\\") AbstractPipeline p=AbstractPipeline.this; p.depth > 0; p=p.previousStage) { // opWrapSink是map等方法中实现的 sink = p.opWrapSink(p.previousStage.combinedFlags, sink); } return (Sink<P_IN>) sink; } \",\" abstract<P_IN> void copyInto(Sink<P_IN> wrappedSink, Spliterator<P_IN> spliterator); \",\"方法的说明：\",\"Pushes elements obtained from the Spliterator into the provided Sink. If the stream pipeline is known to have short-circuiting stages in it (see StreamOpFlag.SHORT_CIRCUIT), the Sink.cancellationRequested() is checked after each element, stopping if cancellation is requested. \",\"将从Spliterator获取到元素推送到Sink当中，如果这个流管道已经知道了拥有短路的阶段，就会进入短路逻辑的判断，方法的实现如下：\",\" @Override final <P_IN> void copyInto(Sink<P_IN> wrappedSink, Spliterator<P_IN> spliterator) { Objects.requireNonNull(wrappedSink); if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) { wrappedSink.begin(spliterator.getExactSizeIfKnown()); spliterator.forEachRemaining(wrappedSink); wrappedSink.end(); } else { copyIntoWithCancel(wrappedSink, spliterator); } } \",\"TerminalSink是Sink最终的形态。\"]},\"1501\":{\"h\":\"Stream调用流程\",\"t\":[\"BaseStream->Stream->AbstractPipline->ReferencePipline->(Head（流源）、StatelessOp（无状态的中间操作）、StatefulOp（有状态的中间操作））\",\"Terminalop->(FindOp、ForeachOp、MatchOp、ReduceOp)\"]},\"1502\":{\"h\":\"JMS 简介\"},\"1503\":{\"h\":\"JMX\",\"t\":[\"https://www.wdbyte.com/java/jmx/\"]},\"1504\":{\"h\":\"JNDI 简介\",\"t\":[\"官方文档：https://docs.oracle.com/javase/jndi/tutorial/TOC.html\"]},\"1505\":{\"h\":\"框架源码分析\"},\"1506\":{\"h\":\"Spring源码分析\"},\"1507\":{\"h\":\"Spring核心原理概览\",\"t\":[\"Spring Framework的核心知识点：\",\"Bean的生命周期底层原理\",\"依赖注入底层实现原理\",\"初始化底层原理\",\"推断构造方法底层原理\",\"AOP底层原理\",\"Spring事务底层原理\",\"推断构造方法：先根据类型进行依赖查找，如果找到多个，那么再根据名称查找，直到找到唯一的Bean，如果要指定构造方法，需要添加@Autowried注解来实现。\",\"AOP大致的实现原理：先使用cglib生成代理类，将代理对象的target属性赋值为IOC容器中的普通对象（普通对象是依赖注入的后的对象），然后再执行切面的逻辑，最后调用普通对象的方法。\",\"如何判断当前Bean对象需不需要进行AOP：\",\"找出所有的切面Bean\",\"遍历切面中的每个方法，查看是否有@Before、@After等注解\",\"如果有，则判断对应的Pointcut是否和当前Bean对象的类是否匹配\",\"如果匹配则表示当前Bean对象有匹配的Pointcut，表示需要进行AOP，会将AOP需要执行的方法缓存\",\"Spring 自动事务的大致实现过程：\",\"判读方法是否含有@Transactional注解\",\"通过事务管理器（dataSource）创建一个数据库连接\",\"设置conn.autocommit=false\",\"执行目标方法，提交事务结果\",\"解决事务失效的核心思路：只要是调用代理对象的方法，事务就可以生效。\"]},\"1508\":{\"h\":\"Spring核心概念\"},\"1509\":{\"h\":\"BeanDefinition\",\"t\":[\"BeanDefinition表示Bean的元信息定义，BeanDefition中存在很多属性用来描述一个Bean的特点。比如：\",\"class，表示Bean的类型\",\"scope，表示Bean的作用域（单例或圆形）\",\"lazyInit：表示Bean是否是懒加载\",\"initMethodName：表示Bean初始化时要执行的方法\",\"destoreMethodName：表示Bean销毁时要执行的方法\",\"......\",\"通过XML方式配置和使用注解等方式声明的Bean，都会被Spring解析为对应的BeanDefinition对象，并放入Spring容器中。\",\"通过编程式声明Bean对象：\",\"AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); // 生成一个BeanDefinition对象，并设置beanClass为User.class，并注册到ApplicationContext中 AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition(); beanDefinition.setBeanClass(User.class); context.registerBeanDefinition(\\\"user\\\", beanDefinition); System.out.println(context.getBean(\\\"user\\\")); \",\"BeanDefinition的典型实现：\",\"org.springframework.beans.factory.support.GenericBeanDefinition\",\"org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition\",\"org.springframework.context.annotation.ScannedGenericBeanDefinition\",\"org.springframework.beans.factory.support.RootBeanDefinition\",\"org.springframework.beans.factory.support.ChildBeanDefinition\"]},\"1510\":{\"h\":\"AnnotatedBeanDefinitionReader\",\"t\":[\"AnnotatedBeanDefinitionReader可以直接把某个类转换为BeanDefition，并且会解析该类上的注解，比如：\",\"AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); AnnotatedBeanDefinitionReader annotatedBeanDefinitionReader = new AnnotatedBeanDefinitionReader(context); // 将User.class解析为BeanDefinition annotatedBeanDefinitionReader.register(User.class); System.out.println(context.getBean(\\\"user\\\")); \",\"注意，它能解析的注解有：@Conditional、@Scope、@Lazy、@Primary、@DependsOn、@Role、@Description\"]},\"1511\":{\"h\":\"XmlBeanDefinitionReader\",\"t\":[\"XmlBeanDefinitionReader可以用来解析\",\"AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(context); int i = xmlBeanDefinitionReader.loadBeanDefinitions(\\\"spring.xml\\\"); System.out.println(context.getBean(\\\"user\\\")); \"]},\"1512\":{\"h\":\"ClassPathBeanDefinitionScanner\",\"t\":[\"ClassPathBeanDefinitionScanner是扫描器，作用和BeanDefinitionReader类似，它可以扫描某个包路径，对扫描到的类进行解析，比如，扫描到的类上如果存在@Component注解，那么就会把这个类解析为一个BeanDefition，比如：\",\"AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.refresh(); ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(context); scanner.scan(\\\"com.jyc\\\"); System.out.println(context.getBean(\\\"userService\\\")); \"]},\"1513\":{\"h\":\"BeanFactory\",\"t\":[\"BeanFactory表示Bean工厂，BeanFactory会负责创建Bean，并且提供获取Bean的API。\",\"ApplicationContext继承了BeanFactory，ApplicationContext除了BeanFactory提供的基础功能外，还提供了国际化、事件发布、获取环境变量等功能。\",\"BeanFactory的类图如下：\",\"其中DefaultListableBeanFactory是最重要的实现之一。其余接口的主要功能如下：\",\"AliasRegistry：支持别名功能，一个名字可以对应多个别名\",\"BeanDefinitionRegistry：可以注册、保存、移除、获取某个BeanDefinition\",\"BeanFactory：Bean工厂，可以根据某个bean的名字、或类型、或别名获取某个Bean对象\",\"SingletonBeanRegistry：可以直接注册、获取某个单例Bean\",\"SimpleAliasRegistry：它是一个类，实现了AliasRegistry接口中所定义的功能，支持别名功能\",\"ListableBeanFactory：在BeanFactory的基础上，增加了其他功能，可以获取所有BeanDefinition的beanNames，可以根据某个类型获取对应的beanNames，可以根据某个类型获取{类型：对应的Bean}的映射关系\",\"HierarchicalBeanFactory：在BeanFactory的基础上，添加了获取父BeanFactory的功能\",\"DefaultSingletonBeanRegistry：它是一个类，实现了SingletonBeanRegistry接口，拥有了直接注册、获取某个单例Bean的功能\",\"ConfigurableBeanFactory：在HierarchicalBeanFactory和SingletonBeanRegistry的基础上，添加了设置父BeanFactory、类加载器（表示可以指定某个类加载器进行类的加载）、设置Spring EL表达式解析器（表示该BeanFactory可以解析EL表达式）、设置类型转化服务（表示该BeanFactory可以进行类型转化）、可以添加BeanPostProcessor（表示该BeanFactory支持Bean的后置处理器），可以合并BeanDefinition，可以销毁某个Bean等等功能\",\"FactoryBeanRegistrySupport：支持了FactoryBean的功能\",\"AutowireCapableBeanFactory：是直接继承了BeanFactory，在BeanFactory的基础上，支持在创建Bean的过程中能对Bean进行自动装配\",\"AbstractBeanFactory：实现了ConfigurableBeanFactory接口，继承了FactoryBeanRegistrySupport，这个BeanFactory的功能已经很全面了，但是不能自动装配和获取beanNames\",\"ConfigurableListableBeanFactory：继承了ListableBeanFactory、AutowireCapableBeanFactory、ConfigurableBeanFactory\",\"AbstractAutowireCapableBeanFactory：继承了AbstractBeanFactory，实现了AutowireCapableBeanFactory，拥有了自动装配的功能\",\"DefaultListableBeanFactory：继承了AbstractAutowireCapableBeanFactory，实现了ConfigurableListableBeanFactory接口和BeanDefinitionRegistry接口，所以DefaultListableBeanFactory的功能很强大\"]},\"1514\":{\"h\":\"ApplicationContext\",\"t\":[\"ApplicationContext提供了如下功能：\",\"HierachicalBeanFactory：拥有获取父BeanFactory的功能\",\"ListableBeanFactory：拥有获取beanNames的功能\",\"ResourcePatternResolver：资源加载器，可以一次性获取多个资源（文件资源等等）\",\"EnvironmentCapable：可以获取运行时环境（没有设置运行时环境的功能）\",\"ApplicationEventPublisher：拥有广播事件的功能（没有添加事件监听器的功能）\",\"MessageSource：拥有国际化功能\",\"ApplicationContext的典型实现：\",\"org.springframework.context.annotation.AnnotationConfigApplicationContext\",\"org.springframework.context.support.ClassPathXmlApplicationContext\"]},\"1515\":{\"h\":\"PropertyEditor\",\"t\":[\"PropertyEditor是JDK中提供的类型转化工具类。\",\"通常我们会定义一个类型转换器：\",\"// 继承PropertyEditorSupport public class StringToUserPropertyEditor extends PropertyEditorSupport { @Override public void setAsText(String text) throws IllegalArgumentException { User user = new User(); user.setName(text); this.setValue(user); } } \",\"向Spring中注册PropertyEditor：\",\"@Bean public CustomEditorConfigurer customEditorConfigurer() { CustomEditorConfigurer customEditorConfigurer = new CustomEditorConfigurer(); Map<Class<?>, Class<? extends PropertyEditor>> propertyEditorMap = new HashMap<>(); // 表示StringToUserPropertyEditor可以将String转化成User类型，在Spring源码中，如果发现当前对象是String，而需要的类型是User，就会使用该PropertyEditor来做类型转化 propertyEditorMap.put(User.class, StringToUserPropertyEditor.class); customEditorConfigurer.setCustomEditors(propertyEditorMap); return customEditorConfigurer; } \",\"假设有如下Bean：\",\"@Component public class UserService { @Value(\\\"xxx\\\") private User user; public void test() { System.out.println(user); } } \",\"那么user这个属性就会按照StringToUserPropertyEditor中定义好的规则来进行属性赋值。\"]},\"1516\":{\"h\":\"ConversionService\",\"t\":[\"ConversionService是Spring中提供的类型转化服务，它比PropertyEditor更加强大。与PropertyEditor类似，首先定义一个转换器。\",\" public class StringToUserConverter implements ConditionalGenericConverter { @Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return sourceType.getType().equals(String.class) && targetType.getType().equals(User.class); } @Override public Set<ConvertiblePair> getConvertibleTypes() { return Collections.singleton(new ConvertiblePair(String.class, User.class)); } @Override public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { User user = new User(); user.setName((String)source); return user; } } \",\"与PropertyEditor相比，conversionService可以自定义转换类型，PropertyEditor仅仅支持String类型转换成其他的类型。\",\"向Spring中注册conversionService：\",\"@Bean public ConversionServiceFactoryBean conversionService() { ConversionServiceFactoryBean conversionServiceFactoryBean = new ConversionServiceFactoryBean(); conversionServiceFactoryBean.setConverters(Collections.singleton(new StringToUserConverter())); return conversionServiceFactoryBean; } \"]},\"1517\":{\"h\":\"TypeConverter\",\"t\":[\"TypeConverter整合了PropertyEditor和conversionService的功能，在Spring内部使用：\",\"SimpleTypeConverter typeConverter = new SimpleTypeConverter(); typeConverter.registerCustomEditor(User.class, new StringToUserPropertyEditor()); User value = typeConverter.convertIfNecessary(\\\"1\\\", User.class); System.out.println(value); \",\"typeConverter本身使用了委托的设计模式，其类型转换的功能实际上委托给了内部的propertyEditor和conversionService对象，这样做的好处是使用者无需关心内部转换细节。\"]},\"1518\":{\"h\":\"OrderComparator\",\"t\":[\"OrderComparator是Spring所提供的一种比较器，可以根据@Order注解或实现Ordered接口来执行值进行比较，从而可以进行排序。\",\"另外，Spring中还提供了OrderComparator的子类：AnnotationAwareOrderComparator，它支持使用注解@Order来指定order的值。\"]},\"1519\":{\"h\":\"BeanPostProcessor\"},\"1520\":{\"h\":\"BeanFactoryPostProcessor\"},\"1521\":{\"h\":\"FactoryBean\",\"t\":[\"除了可以通过BeanPostProcessor来自定义Spring创建Bean的过程，但是如果我们想要一个Bean完全由我们自己来创造，就可以通过FactoryBean来实现：\",\"@Component public class JycFactoryBean implements FactoryBean { @Override public Object getObject() throws Exception { UserService userService = new UserService(); return userService; } @Override public Class<?> getObjectType() { return UserService.class; } } \",\"在大多数场景下可以与@Bean替换使用，唯一的区别在于，这样产生的Bean不会经过Spring的生命周期步骤，只会进入初始化后的阶段，以便AOP操作。\"]},\"1522\":{\"h\":\"ExcludeFilter和IncludeFilter\",\"t\":[\"这两个Filter是Spring扫描过程中用来过滤的。ExcludeFilter表示排除过滤器，IncludeFilter表示包含过滤器。\",\"在如下配置中，表示扫描com.jyc这个包下面所有的类，但是排除UserService类，即便它上面有@Component注解也不会注册为Bean。\",\"@ComponentScan(value = \\\"com.jyc\\\", excludeFilters = {@ComponentScan.Filter( type = FilterType.ASSIGNABLE_TYPE, classes = UserService.class)}.) public class AppConfig { } \",\"在如下配置中，即便Uservice类上没有@Component注解，它也会扫描成为一个Bean。\",\"@ComponentScan(value = \\\"com.jyc\\\", includeFilters = {@ComponentScan.Filter( type = FilterType.ASSIGNABLE_TYPE, classes = UserService.class)}) public class AppConfig { } \",\"在Spring的扫描逻辑中，默认会添加一个AnnotationTypeFilter给includeFilters，表示默认情况下Spring扫描过程中会认为类上有@Component注解的就是Bean。\"]},\"1523\":{\"h\":\"MetadataReader、ClassMetadata、AnnotationMetadata\",\"t\":[\"在Spring中需要去解析类的信息，比如类名，类中的方法、类上的注解，这些都可以称之为类的元数据，所以Spring中对类的元数据做了抽象，并提供了一些工具类。\",\"MetadataReader表示类的元数据读取器，默认实现类为SimpleMetadataReader。比如：\",\"public class Test { public static void main(String[] args) throws IOException { SimpleMetadataReaderFactory simpleMetadataReaderFactory = new SimpleMetadataReaderFactory(); // 构造一个MetadataReader MetadataReader metadataReader = simpleMetadataReaderFactory.getMetadataReader(\\\"com.jyc.service.UserService\\\"); // 得到一个ClassMetadata，并获取了类名 ClassMetadata classMetadata = metadataReader.getClassMetadata(); System.out.println(classMetadata.getClassName()); // 获取一个AnnotationMetadata，并获取类上的注解信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); for (String annotationType : annotationMetadata.getAnnotationTypes()) { System.out.println(annotationType); } } } \",\"需要注意的是，SimpleMetadataReader去解析类时，使用的是ASM技术。使用ASM技术的原因是，Spring启动的时候需要去扫描，如果指定的包路径比较宽泛，那么扫描的类是非常多的，这样会把这些类全部加载进JVM。\"]},\"1524\":{\"h\":\"Bean的生命周期\",\"t\":[\"生命周期的整体流程：\",\"过程描述如下：\",\"InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation\",\"实例化\",\"MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition\",\"InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation\",\"属性赋值（Spring自带的依赖注入）\",\"InstantiationAwareBeanPostProcessor#postProcessProperties\",\"初始化前\",\"初始化\",\"初始化后\",\" public AnnotationConfigApplicationContext() { // JFR 特性，用来记录时间 StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start(\\\"spring.context.annotated-bean-reader.create\\\"); // 构造一个reader和scanner this.reader = new AnnotatedBeanDefinitionReader(this); createAnnotatedBeanDefReader.end(); this.scanner = new ClassPathBeanDefinitionScanner(this); } \",\" public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { StartupStep contextRefresh = this.applicationStartup.start(\\\"spring.context.refresh\\\"); // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); StartupStep beanPostProcess = this.applicationStartup.start(\\\"spring.context.beans.post-process\\\"); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); beanPostProcess.end(); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\\\"Exception encountered during context initialization - \\\" + \\\"cancelling refresh attempt: \\\" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); contextRefresh.end(); } } } \",\"扫描的整体过程：\",\" protected Set<BeanDefinitionHolder> doScan(String... basePackages) { Assert.notEmpty(basePackages, \\\"At least one base package must be specified\\\"); Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>(); for (String basePackage : basePackages) { Set<BeanDefinition> candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) { ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } // 为BeanDefinition设置属性的初始值，当命名出现重复，如果不是扫描出现的情况，就会直接抛出异常，否则，则会判断新扫描的BeanDefinition与原来的BeanDefinition是否兼容 if (candidate instanceof AnnotatedBeanDefinition) { AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); } // 检查Spring容器中是否已经含有这个名字的Bean if (checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // 将BeanDefinition注册到beanDefinitionMap中 registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } \",\"扫描的核心方法：\",\" private Set<BeanDefinition> scanCandidateComponents(String basePackage) { Set<BeanDefinition> candidates = new LinkedHashSet<>(); try { String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; // 获取给定包路径下面的Class文件的Resource对象 Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); for (Resource resource : resources) { try { // 元数据读取器，使用ASM技术读取当前类的名称、注解等信息 MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); // 是否是一个Bean if (isCandidateComponent(metadataReader)) { // 扫描的时候并不会解析，此时只会将Bean的名称设置给beanClass属性，后续真正加载的时候会被替换为Class对象，因此beanClass是Object类型的属性 ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setSource(resource); // 有可能是内部类或其他虽然有@Component注解，但不是一个Bean的情况 if (isCandidateComponent(sbd)) { candidates.add(sbd); } } } catch (FileNotFoundException ignored) { } catch (Throwable ex) { throw new BeanDefinitionStoreException( \\\"Failed to read candidate component class: \\\" + resource, ex); } } } catch (IOException ex) { throw new BeanDefinitionStoreException(\\\"I/O failure during classpath scanning\\\", ex); } return candidates; } \",\"其中isCandidateComponent方法表示当前类是否是一个Bean：\",\" protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException { // 处理排除过滤器和包含过滤器，默认会有一个@Component注解的包含过滤器 for (TypeFilter tf : this.excludeFilters) { if (tf.match(metadataReader, getMetadataReaderFactory())) { return false; } } for (TypeFilter tf : this.includeFilters) { if (tf.match(metadataReader, getMetadataReaderFactory())) { // 条件匹配，条件注解@Condition return isConditionMatch(metadataReader); } } return false; } \",\"判断BeanDefinition是否是一个Bean：\",\" protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) { AnnotationMetadata metadata = beanDefinition.getMetadata(); // 1.不是内部类或static类 // 2.不是接口或抽象类 // 3.如果是抽象类的话方法上面需要有@Lookup注解的方法 return (metadata.isIndependent() && (metadata.isConcrete() || (metadata.isAbstract() && metadata.hasAnnotatedMethods(Lookup.class.getName())))); } \",\"创建非懒加载的单例Bean：\",\" @Override public void preInstantiateSingletons() throws BeansException { // 扫描的时候也会把Bean的名字也存下来 List<String> beanNames = new ArrayList<>(this.beanDefinitionNames); for (String beanName : beanNames) { // 合并BeanDefition，将父BeanDefinition的属性继承，合并会生成一个新的BeanDefition，存储在mergedBeanDefinitions这个Map中 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 如果是抽象的BeanDefinition不会创建Bean，abstractFlag是BeanDefinition的内部属性，抽象的BeanDifition表示BeanDifition之间有父子关系 if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) { // FactoryBean的处理逻辑，如果在当前的beanFactory中没有找到，就会递归在父beanFactory中查找 if (isFactoryBean(beanName)) { // 创建实现FactoryBean的实例对象 Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); if (bean instanceof FactoryBean) { FactoryBean<?> factory = (FactoryBean<?>) bean; boolean isEagerInit; if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) { isEagerInit = AccessController.doPrivileged( (PrivilegedAction<Boolean>) ((SmartFactoryBean<?>) factory)::isEagerInit, getAccessControlContext()); } else { isEagerInit = (factory instanceof SmartFactoryBean && ((SmartFactoryBean<?>) factory).isEagerInit()); } if (isEagerInit) { // 调用getBean方法才会调用FactoryBean#getObject方法 getBean(beanName); } } } else { // 创建Bean getBean(beanName); } } } // 在单例池中查找单例Bean，这里会处理循环依赖问题 for (String beanName : beanNames) { Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) { StartupStep smartInitialize = this.getApplicationStartup().start(\\\"spring.beans.smart-initialize\\\") .tag(\\\"beanName\\\", beanName); SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction<Object>) () -> { smartSingleton.afterSingletonsInstantiated(); return null; }, getAccessControlContext()); } else { // 所有的非懒加载的单例Bean都创建完成之后，会调用每个单例Bean的afterSingletonsInstantiated方法 smartSingleton.afterSingletonsInstantiated(); } smartInitialize.end(); } } } \",\"合并BeanDifinition的方法：\",\" protected RootBeanDefinition getMergedBeanDefinition( String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd) throws BeanDefinitionStoreException { synchronized (this.mergedBeanDefinitions) { RootBeanDefinition mbd = null; RootBeanDefinition previous = null; // Check with full lock now in order to enforce the same merged instance. if (containingBd == null) { mbd = this.mergedBeanDefinitions.get(beanName); } if (mbd == null || mbd.stale) { previous = mbd; if (bd.getParentName() == null) { // 如果能在mergedBeanDefinitions找得到父BeanDifinition，直接新建一个RootBeanDefinition if (bd instanceof RootBeanDefinition) { mbd = ((RootBeanDefinition) bd).cloneBeanDefinition(); } else { mbd = new RootBeanDefinition(bd); } } else { // Child bean definition: needs to be merged with parent. BeanDefinition pbd; try { String parentBeanName = transformedBeanName(bd.getParentName()); // 递归查找合并 if (!beanName.equals(parentBeanName)) { pbd = getMergedBeanDefinition(parentBeanName); } else { BeanFactory parent = getParentBeanFactory(); if (parent instanceof ConfigurableBeanFactory) { pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName); } else { throw new NoSuchBeanDefinitionException(parentBeanName, \\\"Parent name '\\\" + parentBeanName + \\\"' is equal to bean name '\\\" + beanName + \\\"': cannot be resolved without a ConfigurableBeanFactory parent\\\"); } } } catch (NoSuchBeanDefinitionException ex) { throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName, \\\"Could not resolve parent bean definition '\\\" + bd.getParentName() + \\\"'\\\", ex); } // 先合并父的BeanDefinition，然后合并子类的BeanDifition mbd = new RootBeanDefinition(pbd); // 属性覆盖，子类中有的属性设置会父类的属性 mbd.overrideFrom(bd); } // Set default singleton scope, if not configured before. if (!StringUtils.hasLength(mbd.getScope())) { mbd.setScope(SCOPE_SINGLETON); } // A bean contained in a non-singleton bean cannot be a singleton itself. // Let's correct this on the fly here, since this might be the result of // parent-child merging for the outer bean, in which case the original inner bean // definition will not have inherited the merged outer bean's singleton status. if (containingBd != null && !containingBd.isSingleton() && mbd.isSingleton()) { mbd.setScope(containingBd.getScope()); } // Cache the merged bean definition for the time being // (it might still get re-merged later on in order to pick up metadata changes) if (containingBd == null && isCacheBeanMetadata()) { this.mergedBeanDefinitions.put(beanName, mbd); } } if (previous != null) { copyRelevantMergedBeanDefinitionCaches(previous, mbd); } return mbd; } } \",\"doGetBean方法是创建Bean的核心方法：\",\" @SuppressWarnings(\\\"unchecked\\\") protected <T> T doGetBean( String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException { // 如果传入的名称是“&***”，表示要获取的对象是FactoryBean本身的对象，它存储在单例池中，如果传入的是普通名称，则表示要获取的对象是Factory#getObject方法返回的对象 String beanName = transformedBeanName(name); Object beanInstance; // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null && args == null) { if (logger.isTraceEnabled()) { if (isSingletonCurrentlyInCreation(beanName)) { logger.trace(\\\"Returning eagerly cached instance of singleton bean '\\\" + beanName + \\\"' that is not fully initialized yet - a consequence of a circular reference\\\"); } else { logger.trace(\\\"Returning cached instance of singleton bean '\\\" + beanName + \\\"'\\\"); } } beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null); } else { // Fail if we're already creating this bean instance: // We're assumably within a circular reference. if (isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null && !containsBeanDefinition(beanName)) { // Not found -> check parent. String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) { return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); } else if (args != null) { // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); } else if (requiredType != null) { // No args -> delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); } else { return (T) parentBeanFactory.getBean(nameToLookup); } } if (!typeCheckOnly) { markBeanAsCreated(beanName); } StartupStep beanCreation = this.applicationStartup.start(\\\"spring.beans.instantiate\\\") .tag(\\\"beanName\\\", name); try { if (requiredType != null) { beanCreation.tag(\\\"beanType\\\", requiredType::toString); } // 拿到合并后的Beanfinition RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 处理@Depensdon注解，查看当前指定的所依赖的Bean是否都已经注入完成 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) { for (String dep : dependsOn) { if (isDependent(beanName, dep)) { // 这也是循环依赖的一种情况 throw new BeanCreationException(mbd.getResourceDescription(), beanName, \\\"Circular depends-on relationship between '\\\" + beanName + \\\"' and '\\\" + dep + \\\"'\\\"); } // 还没有的话，就注册到depentBeanMap中 registerDependentBean(dep, beanName); try { // getBean会首先创建所依赖的Bean getBean(dep); } catch (NoSuchBeanDefinitionException ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \\\"'\\\" + beanName + \\\"' depends on missing bean '\\\" + dep + \\\"'\\\", ex); } } } // Create bean instance. if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -> { try { return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } else if (mbd.isPrototype()) { // It's a prototype -> create a new instance. Object prototypeInstance = null; try { beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } else { // 除了singleton和prototype，还有request、session、application作用域 String scopeName = mbd.getScope(); if (!StringUtils.hasLength(scopeName)) { throw new IllegalStateException(\\\"No scope name defined for bean '\\\" + beanName + \\\"'\\\"); } Scope scope = this.scopes.get(scopeName); if (scope == null) { throw new IllegalStateException(\\\"No Scope registered for scope name '\\\" + scopeName + \\\"'\\\"); } try { Object scopedInstance = scope.get(beanName, () -> { beforePrototypeCreation(beanName); try { return createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } }); beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException ex) { throw new ScopeNotActiveException(beanName, scopeName, ex); } } } catch (BeansException ex) { beanCreation.tag(\\\"exception\\\", ex.getClass().toString()); beanCreation.tag(\\\"message\\\", String.valueOf(ex.getMessage())); cleanupAfterBeanCreationFailure(beanName); throw ex; } finally { beanCreation.end(); } } // 检查通过name查找到的Bean是否是requiredType类型的Bean return adaptBeanInstance(name, beanInstance, requiredType); } } \",\"创建Bean的方法：\",\" @Override protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { RootBeanDefinition mbdToUse = mbd; // Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition. // 类加载，这里可以使用自定义的ClassLoader，默认是APP ClassLoader Class<?> resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) { mbdToUse = new RootBeanDefinition(mbd); // 将加载到的Class对象设置给beanClass属性 mbdToUse.setBeanClass(resolvedClass); } // Prepare method overrides. try { // 与@Lookup注解有关 mbdToUse.prepareMethodOverrides(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, \\\"Validation of method overrides failed\\\", ex); } try { // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. // 实例化前 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) { return bean; } } catch (Throwable ex) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \\\"BeanPostProcessor before instantiation of bean failed\\\", ex); } try { // 实例化 Object beanInstance = doCreateBean(beanName, mbdToUse, args); return beanInstance; } catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) { // A previously detected exception with proper bean creation context already, // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry. throw ex; } catch (Throwable ex) { throw new BeanCreationException( mbdToUse.getResourceDescription(), beanName, \\\"Unexpected exception during bean creation\\\", ex); } } \",\"实例化前方法：\",\" // 支持BeanPostPropcessor protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) { Object bean = null; if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) { // Make sure bean class is actually resolved at this point. if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) { Class<?> targetType = determineTargetType(beanName, mbd); if (targetType != null) { bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); if (bean != null) { bean = applyBeanPostProcessorsAfterInitialization(bean, beanName); } } } mbd.beforeInstantiationResolved = (bean != null); } return bean; } \",\"实例化方法：\",\" protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { instanceWrapper = createBeanInstance(beanName, mbd, args); } Object bean = instanceWrapper.getWrappedInstance(); Class<?> beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { try { applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \\\"Post-processing of merged bean definition failed\\\", ex); } mbd.postProcessed = true; } } // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isTraceEnabled()) { logger.trace(\\\"Eagerly caching bean '\\\" + beanName + \\\"' to allow for resolving potential circular references\\\"); } addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); } // Initialize the bean instance. Object exposedObject = bean; try { // 填充属性 populateBean(beanName, mbd, instanceWrapper); // 初始化 exposedObject = initializeBean(beanName, exposedObject, mbd); } catch (Throwable ex) { if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \\\"Initialization of bean failed\\\", ex); } } if (earlySingletonExposure) { Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { if (exposedObject == bean) { exposedObject = earlySingletonReference; } else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length); for (String dependentBean : dependentBeans) { if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, \\\"Bean with name '\\\" + beanName + \\\"' has been injected into other beans [\\\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \\\"] in its raw version as part of a circular reference, but has eventually been \\\" + \\\"wrapped. This means that said other beans do not use the final version of the \\\" + \\\"bean. This is often the result of over-eager type matching - consider using \\\" + \\\"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.\\\"); } } } } // Register bean as disposable. try { // Bean销毁的逻辑，当Spring容器关闭的时候，会调用销毁方法 registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \\\"Invalid destruction signature\\\", ex); } return exposedObject; } \",\"属性绑定：\",\" protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) { if (bw == null) { if (mbd.hasPropertyValues()) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \\\"Cannot apply property values to null instance\\\"); } else { // Skip property population phase for null instance. return; } } // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the // state of the bean before properties are set. This can be used, for example, // to support styles of field injection. if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) { for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { if (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { return; } } } PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null); int resolvedAutowireMode = mbd.getResolvedAutowireMode(); // Spring内建的依赖注入，可以根据类型或者名称进行查找，但由于过于灵活，现已废弃 if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) { MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // Add property values based on autowire by name if applicable. if (resolvedAutowireMode == AUTOWIRE_BY_NAME) { autowireByName(beanName, mbd, bw, newPvs); } // Add property values based on autowire by type if applicable. if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) { autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE); PropertyDescriptor[] filteredPds = null; if (hasInstAwareBpps) { if (pvs == null) { pvs = mbd.getPropertyValues(); } for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { // 处理属性回调，会检查BeanDefinition的属性是否已经被赋值过了 PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { if (filteredPds == null) { filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { return; } } pvs = pvsToUse; } } if (needsDepCheck) { if (filteredPds == null) { filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } checkDependencies(beanName, mbd, filteredPds, pvs); } if (pvs != null) { applyPropertyValues(beanName, mbd, bw, pvs); } } \",\"销毁方法只是针对于单例的Bean而言，原型Bean的销毁方法并不会被Spring所调用。\"]},\"1525\":{\"h\":\"依赖注入源码解析\",\"t\":[\"@Autowired注解的实现类：org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor：\",\"public class AutowiredAnnotationBeanPostProcessor implements SmartInstantiationAwareBeanPostProcessor, MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware { @Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) { // 查找注入点： InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); } @Override public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) { // 给字段赋值 InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs); try { // 处理@Value注解的方法 metadata.inject(bean, beanName, pvs); } catch (BeanCreationException ex) { throw ex; } catch (Throwable ex) { throw new BeanCreationException(beanName, \\\"Injection of autowired dependencies failed\\\", ex); } return pvs; } } \",\"静态属性和静态方法会跳过，无法依赖注入。\",\" private InjectionMetadata buildAutowiringMetadata(Class<?> clazz) { // 当前类是否 if (!AnnotationUtils.isCandidateClass(clazz, this.autowiredAnnotationTypes)) { return InjectionMetadata.EMPTY; } List<InjectionMetadata.InjectedElement> elements = new ArrayList<>(); Class<?> targetClass = clazz; do { final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>(); ReflectionUtils.doWithLocalFields(targetClass, field -> { MergedAnnotation<?> ann = findAutowiredAnnotation(field); if (ann != null) { // 静态属性跳过 if (Modifier.isStatic(field.getModifiers())) { if (logger.isInfoEnabled()) { logger.info(\\\"Autowired annotation is not supported on static fields: \\\" + field); } return; } boolean required = determineRequiredStatus(ann); currElements.add(new AutowiredFieldElement(field, required)); } }); ReflectionUtils.doWithLocalMethods(targetClass, method -> { // 处理桥接方法，找到被桥接的方法，然后处理 Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) { return; } MergedAnnotation<?> ann = findAutowiredAnnotation(bridgedMethod); if (ann != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) { // 静态方法跳过 if (Modifier.isStatic(method.getModifiers())) { if (logger.isInfoEnabled()) { logger.info(\\\"Autowired annotation is not supported on static methods: \\\" + method); } return; } if (method.getParameterCount() == 0) { if (logger.isInfoEnabled()) { logger.info(\\\"Autowired annotation should only be used on methods with parameters: \\\" + method); } } boolean required = determineRequiredStatus(ann); PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz); currElements.add(new AutowiredMethodElement(method, required, pd)); } }); elements.addAll(0, currElements); targetClass = targetClass.getSuperclass(); } while (targetClass != null && targetClass != Object.class); return InjectionMetadata.forElements(elements, clazz); } \",\"注入字段：\",\" @Nullable private Object resolveFieldValue(Field field, Object bean, @Nullable String beanName) { DependencyDescriptor desc = new DependencyDescriptor(field, this.required); desc.setContainingClass(bean.getClass()); Set<String> autowiredBeanNames = new LinkedHashSet<>(1); Assert.state(beanFactory != null, \\\"No BeanFactory available\\\"); TypeConverter typeConverter = beanFactory.getTypeConverter(); Object value; try { // 找到需要注入的字段的值 value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter); } catch (BeansException ex) { throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex); } synchronized (this) { if (!this.cached) { Object cachedFieldValue = null; if (value != null || this.required) { cachedFieldValue = desc; registerDependentBeans(beanName, autowiredBeanNames); if (autowiredBeanNames.size() == 1) { String autowiredBeanName = autowiredBeanNames.iterator().next(); if (beanFactory.containsBean(autowiredBeanName) && beanFactory.isTypeMatch(autowiredBeanName, field.getType())) { cachedFieldValue = new ShortcutDependencyDescriptor( desc, autowiredBeanName, field.getType()); } } } this.cachedFieldValue = cachedFieldValue; this.cached = true; } } return value; } } \",\"类似的，也有注入方法的方法：org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredMethodElement。\",\"其中核心方法就是beanFactory的resolveDependency方法：\",\" public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName, @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException { // 用来获取方法入参名称 descriptor.initParameterNameDiscovery(getParameterNameDiscoverer()); // 所需要的类型是Optional类型的 if (Optional.class == descriptor.getDependencyType()) { return createOptionalDependency(descriptor, requestingBeanName); } // 所需要的类型是ObectFactory或ObjectProvider的 else if (ObjectFactory.class == descriptor.getDependencyType() || ObjectProvider.class == descriptor.getDependencyType()) { return new DependencyObjectProvider(descriptor, requestingBeanName); } else if (javaxInjectProviderClass == descriptor.getDependencyType()) { return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName); } else { // 在属性或set方法上使用了@Lazy注解，那么则构造一个代理对象并返回，真正使用该代理对象时才进行类型筛选Bean Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary( descriptor, requestingBeanName); if (result == null) { result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter); } return result; } } \",\"方法形参名称获取：\",\"public class DefaultParameterNameDiscoverer extends PrioritizedParameterNameDiscoverer { public DefaultParameterNameDiscoverer() { // JDK1.8以后可以获取方法的形参名称，1.8之前可以通过字节码的本地变量表来获取 addDiscoverer(new StandardReflectionParameterNameDiscoverer()); addDiscoverer(new LocalVariableTableParameterNameDiscoverer()); } } \",\"核心方法doResolveDependency的源代码：\",\" @Nullable public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName, @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException { InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor); try { Object shortcut = descriptor.resolveShortcut(this); if (shortcut != null) { return shortcut; } Class<?> type = descriptor.getDependencyType(); // 处理@Value注解 Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor); if (value != null) { if (value instanceof String) { // 占位符的填充（${}） String strVal = resolveEmbeddedValue((String) value); BeanDefinition bd = (beanName != null && containsBean(beanName) ? getMergedBeanDefinition(beanName) : null); // 解析Spring表达式（#{}，也可以用来以来注入） value = evaluateBeanDefinitionString(strVal, bd); } // 将value转化为descriptor所对应的类型 TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter()); try { return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor()); } catch (UnsupportedOperationException ex) { return (descriptor.getField() != null ? converter.convertIfNecessary(value, type, descriptor.getField()) : converter.convertIfNecessary(value, type, descriptor.getMethodParameter())); } } // 如果descriptor所对应的类型是数组、Map、List等类型，就将descriptor对应的类型所匹配的所有Bean方法，不用进一步做筛选了 Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter); if (multipleBeans != null) { return multipleBeans; } // 找到所有Bean，key是beanName，value有可能是bean对象，有可能是beanClass Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor); if (matchingBeans.isEmpty()) { // 如果没有找到Bean，但是required属性为true，则直接抛出异常 if (isRequired(descriptor)) { raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor); } return null; } String autowiredBeanName; Object instanceCandidate; // 找到的是多个，再根据名称进行过滤 if (matchingBeans.size() > 1) { // 这里会处理@Primary注解，如果有一个bean有@Primary注解，则返回，也会处理@Priority注解，优先级 autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor); if (autowiredBeanName == null) { if (isRequired(descriptor) || !indicatesMultipleBeans(type)) { return descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans); } else { return null; } } instanceCandidate = matchingBeans.get(autowiredBeanName); } else { // We have exactly one match. Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next(); autowiredBeanName = entry.getKey(); instanceCandidate = entry.getValue(); } if (autowiredBeanNames != null) { autowiredBeanNames.add(autowiredBeanName); } // 有可能筛选出来的是某个bean的类型，此处就进行实例化，调用getBean if (instanceCandidate instanceof Class) { instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this); } Object result = instanceCandidate; if (result instanceof NullBean) { if (isRequired(descriptor)) { raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor); } result = null; } if (!ClassUtils.isAssignableValue(type, result)) { throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass()); } return result; } finally { ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint); } } \",\"当找到多个对象的时候，并不是所有的都需要实例化，如果不需要创建，findAutowireCandidates方法会返回Class对象。\",\" protected Map<String, Object> findAutowireCandidates( @Nullable String beanName, Class<?> requiredType, DependencyDescriptor descriptor) { // 在所有的beanDefinition找到符合这个类型的所有bean的名称 String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this, requiredType, true, descriptor.isEager()); Map<String, Object> result = CollectionUtils.newLinkedHashMap(candidateNames.length); for (Map.Entry<Class<?>, Object> classObjectEntry : this.resolvableDependencies.entrySet()) { Class<?> autowiringType = classObjectEntry.getKey(); if (autowiringType.isAssignableFrom(requiredType)) { Object autowiringValue = classObjectEntry.getValue(); autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType); if (requiredType.isInstance(autowiringValue)) { result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue); break; } } } // candidateNames存的就是找到的和所给类型匹配的所有的bean for (String candidate : candidateNames) { // 如果有多个，优先考虑注入不是自己的那个bean if (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, descriptor)) { addCandidateEntry(result, candidate, descriptor, requiredType); } } if (result.isEmpty()) { boolean multiple = indicatesMultipleBeans(requiredType); // Consider fallback matches if the first pass failed to find anything... DependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch(); for (String candidate : candidateNames) { if (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, fallbackDescriptor) && (!multiple || getAutowireCandidateResolver().hasQualifier(descriptor))) { addCandidateEntry(result, candidate, descriptor, requiredType); } } if (result.isEmpty() && !multiple) { // Consider self references as a final pass... // but in the case of a dependency collection, not the very same bean itself. for (String candidate : candidateNames) { if (isSelfReference(beanName, candidate) && (!(descriptor instanceof MultiElementDescriptor) || !beanName.equals(candidate)) && isAutowireCandidate(candidate, fallbackDescriptor)) { addCandidateEntry(result, candidate, descriptor, requiredType); } } } } return result; } \",\"isAutowireCandidate方法的作用是用来判断给定的bean是否可以用来依赖注入：\",\" protected boolean isAutowireCandidate( String beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver) throws NoSuchBeanDefinitionException { String bdName = BeanFactoryUtils.transformedBeanName(beanName); // 根据BeanDefinition的autowireCandidate属性来判断是否可以用来依赖注入 if (containsBeanDefinition(bdName)) { return isAutowireCandidate(beanName, getMergedLocalBeanDefinition(bdName), descriptor, resolver); } else if (containsSingleton(beanName)) { return isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor, resolver); } BeanFactory parent = getParentBeanFactory(); if (parent instanceof DefaultListableBeanFactory) { // No bean definition found in this factory -> delegate to parent. return ((DefaultListableBeanFactory) parent).isAutowireCandidate(beanName, descriptor, resolver); } else if (parent instanceof ConfigurableListableBeanFactory) { // If no DefaultListableBeanFactory, can't pass the resolver along. return ((ConfigurableListableBeanFactory) parent).isAutowireCandidate(beanName, descriptor); } else { return true; } } \",\"依赖注入的判断条件：\",\"BeanDefinition的autowireCandidate属性\",\"泛型条件判断\",\"@Qualifier\",\"@Primary\",\"@Priority\",\"bean的名称\",\"Spring会在找到注入点之后，将其beanName缓存起来。对于单例bean，并不会触发这个缓存，对于原型bean，在第二次调用getBean方法的时候就会触发。之所以只缓存beanName，是因为依赖注入的可能也是原型bean，这种情况下，每次依赖注入获取bean都应该是一个新的bean。\",\"@Resource和@Autowired注解的区别在于，@Resource是Java规范支持的注解，主要是通过CommonAnnotationBeanPostProcessor来实现，而@Autowired是Spring的注解。之所以会支持@Resource注解是因为，Spring考虑到如果开发者要迁移到其他支持依赖注入的框架，使用Java标准的@Resource注解可以在不修改源码的情况下完成迁移。\"]},\"1526\":{\"h\":\"循环依赖解析\",\"t\":[\"解决循环依赖，主要思路是利用三级缓存：\",\"singletonObjects（经历过完整生命周期的Bean对象）\",\"earlySingletonObjects（用于缓存AOP对象，里面存的是部分属性为空的对象，）\",\"singletonFactories（key是beanName，value是一段lamda表达式，用来获取原始对象）\",\"额外辅助：singletonCurrentlyIncreation，可以通过这个集合查找到正在创建的bean。\",\"之所以需要第三个Map才能解决循环依赖的根本原因是存在代理。原本Spring会在初始化后进行AOP操作，但因为循环依赖的存在，不得不提前缓存AOP的对象。\",\"详细解析：https://blog.csdn.net/hao134838/article/details/121239018\",\"第三个Map，singletonFactories的主要逻辑：\",\" boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { // 判断是否需要进行AOP，如果需要进行AOP，则返回代理对象，如果不需要，则返回原始对象，执行完这个lambda表达式，会将返回的对象放置到earlySingletonObjects中。 // 之后进行AOP的操作的时候，会根据earlyProxyReferences这个Map来判断是否需要AOP操作。 addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); } \",\"打破循环最关键的点是singletonFactories。\",\"@Lazy注解的作用，是在属性填充的时候会直接生成一个代理对象，在使用这个代理对象的方法的时候才会去创建属性的实例对象。\",\"@Transactional注解并不会影响循环依赖，因为@Transactional注解并不会注入一个新的BeanPostProcessor，而是向Spring容器中添加了一个advisor。\"]},\"1527\":{\"h\":\"推断构造源码解析\",\"t\":[\"Spring使用构造方法的原则如下：\",\"默认情况下，使用无参构造方法，或者只要一个构造方法的情况下，就使用唯一的构造方法\",\"如果制定了构造方法的入参值，通过getBean()或者BeanDefinition.getConstructorArgumentValues()指定，那么就会使用所匹配的构造方法\",\"如果想让Spring自动选择构造方法以及构造方法的入参值，可以通过设置autowire=\\\"constructor\\\"来实现\",\"如果使用@Autowired注解制定了某个构造方法，但是希望Spring自动找该构造方法的入参值\",\"推断构造方法的核心源码如下：\",\" protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) { // Make sure bean class is actually resolved at this point. Class<?> beanClass = resolveBeanClass(mbd, beanName); if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \\\"Bean class isn't public, and non-public access not allowed: \\\" + beanClass.getName()); } Supplier<?> instanceSupplier = mbd.getInstanceSupplier(); if (instanceSupplier != null) { return obtainFromSupplier(instanceSupplier, beanName); } // 处理@Bean对应的BeanDefinition if (mbd.getFactoryMethodName() != null) { return instantiateUsingFactoryMethod(beanName, mbd, args); } // Shortcut when re-creating the same bean... boolean resolved = false; boolean autowireNecessary = false; if (args == null) { synchronized (mbd.constructorArgumentLock) { // 缓存BeanDefition的属性，缓存好的构造方法和参数值 if (mbd.resolvedConstructorOrFactoryMethod != null) { resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; } } } if (resolved) { // 如果确定了当前BeanDefinition的构造方法，那么看是否需要进行对构造方法进行参数的依赖注入（构造方法注入） if (autowireNecessary) { // 这里会拿到缓存好的构造方法入参，实例化bean对象 return autowireConstructor(beanName, mbd, null, null); } else { // 构造方法已经找到了，但是没有参数，直接进行实例化 return instantiateBean(beanName, mbd); } } // 这里主要是通过AutowiredAnnotationBeanPostProcessor查找构造方法，当有多个构造方法和只有一个无参的构造方法都会返回null，这个时候，Spring会优先使用无参的构造方法。 Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) { return autowireConstructor(beanName, mbd, ctors, args); } // Preferred constructors for default construction? ctors = mbd.getPreferredConstructors(); if (ctors != null) { return autowireConstructor(beanName, mbd, ctors, null); } // No special handling: simply use no-arg constructor. return instantiateBean(beanName, mbd); } \",\"有@Lookup注解的时候，在推断构造方法之后，会生成cglib的代理对象。\"]},\"1528\":{\"h\":\"Spring启动过程\",\"t\":[\"Spring启动的过程其实就是需要做一些准备工作，好方便后续的相关操作。\",\"创建BeanFactory实例对象，DefaultListableBeanFactory\",\"解析配置类\",\"扫描得到BeanDefinition，存入beanDefitionMap\",\"beanBostprocess\",\"单例池\",\"创建BeanFactory的实例对象：\",\"public GenericApplicationContext() { this.beanFactory = new DefaultListableBeanFactory(); } \",\"于此同时，DefaultListableBeanFactory的父类AbstractAutowireCapableBeanFactory的构造方法：\",\" public AbstractAutowireCapableBeanFactory() { super(); ignoreDependencyInterface(BeanNameAware.class); ignoreDependencyInterface(BeanFactoryAware.class); ignoreDependencyInterface(BeanClassLoaderAware.class); if (NativeDetector.inNativeImage()) { this.instantiationStrategy = new SimpleInstantiationStrategy(); } else { // 初始化cglib策略 this.instantiationStrategy = new CglibSubclassingInstantiationStrategy(); } } \",\"public AnnotationConfigApplicationContext() { StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start(\\\"spring.context.annotated-bean-reader.create\\\"); // 创建读取器，同时也会创建StandardEnvironment对象 this.reader = new AnnotatedBeanDefinitionReader(this); createAnnotatedBeanDefReader.end(); this.scanner = new ClassPathBeanDefinitionScanner(this); } \",\"可以重复调用refresh方法的ApplicationContext的执行逻辑是，先执行bean的销毁方法，然后将beanFactory关闭，最后创建一个新的beanFactory。\",\"protected final void refreshBeanFactory() throws BeansException { if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); loadBeanDefinitions(beanFactory); this.beanFactory = beanFactory; } catch (IOException ex) { throw new ApplicationContextException(\\\"I/O error parsing bean definition source for \\\" + getDisplayName(), ex); } } \",\"启动过程的完整代码：\",\" @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { StartupStep contextRefresh = this.applicationStartup.start(\\\"spring.context.refresh\\\"); // 准备一些资源，设置一些基础属性，主要是加载Properties资源 prepareRefresh(); // 是否可以重复刷新的应用上下文 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 往BeanFactory工厂中添加如下对象： // 1.设置BeanFactory的类加载器，Spring EL表达式解析器，类型转化注册器 // 2.添三个BeanPostProcessor，注意是具体的BeanPostProcessor实例对象 // 3.记录ignoreDependencyInterface // 4.记录ResolvableDependency // 5. 添加三个单例Bean prepareBeanFactory(beanFactory); try { // 模版方法，供子类调用 postProcessBeanFactory(beanFactory); StartupStep beanPostProcess = this.applicationStartup.start(\\\"spring.context.beans.post-process\\\"); // 扫描得到BeanDefinition，放到Bean工厂当中 invokeBeanFactoryPostProcessors(beanFactory); // 将扫描到的BeanPostProcessors实例化并排序，并添加到BeanFactory的BeanPostProcessors属性中去 registerBeanPostProcessors(beanFactory); beanPostProcess.end(); // 初始化国际化相关的内容 initMessageSource(); // 初始化事件广播器 initApplicationEventMulticaster(); // 模版方法，给子类扩展 onRefresh(); // 注册时间监听器 registerListeners(); // 实例化懒加载的Bean finishBeanFactoryInitialization(beanFactory); // Spring容器生命周期处理 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\\\"Exception encountered during context initialization - \\\" + \\\"cancelling refresh attempt: \\\" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); contextRefresh.end(); } } } \",\"处理Spring容器的生命周期：\"]},\"1529\":{\"h\":\"配置类解析与扫描过程源码解析\",\"t\":[\"BeanDefinitionRegistryPostProcessor与BeanFactoryPostProcessor的区别在于，BeanDefinitionRegistryPostProcessor可以向BeanFactory中注册BeanDefinition，BeanFactoryPostProcessor只可以拿到BeanDifinition。通常会先先执行postProcessBeanDefinitionRegistry方法，然后再执行postProcessBeanFactory方法。\",\"扫描的整个过程说白了，其实就是向BeanFatory中添加各种各样的BeanDifinition。\",\"配置类加载的主要的类：org.springframework.context.annotation.ConfigurationClassPostProcessor\",\"实现了MergedBeanDefinitionPostProcessor接口的BeanPostProcessor的postProcessMergedBeanDefinition会被放到最后再执行。\",\"完整的解析配置类流程图：https://www.processon.com/view/link/5f9512d5e401fd06fda0b2dd\",\"只要给定的Bean对象，有以下四个注解之一，就可以认为是配置类。\",\"static { candidateIndicators.add(Component.class.getName()); candidateIndicators.add(ComponentScan.class.getName()); candidateIndicators.add(Import.class.getName()); candidateIndicators.add(ImportResource.class.getName()); } \",\"除了上述的情况外，在类（也可以是接口的实现类或者内部类）的任意一个方法上面添加了@Bean的也是配置类。\",\"扫描处理的核心类：\",\"org.springframework.context.annotation.ConfigurationClassParser\",\"@Import注解的处理过程如下：\",\"整个完整的解析过程如下：\",\"在解析的时候，是一批一批进行解析的，实现DeferredImportSelector接口的类，会在每一批的最后执行selectImports方法。\",\"默认情况下，@Bean的会覆盖掉@Component的BeanDefinition。\",\"@Configuration(proxyBeanMethods = true)表示要增强这个配置类，会生成代理类，主要是为了解决@Bean注解方法返回的单例对象的问题。\"]},\"1530\":{\"h\":\"整合Mybatis底层源码解析\",\"t\":[\"Spring整合其他的框架本质上就是让其他的框架所产生的对象成为Spring IOC容器中的Bean。\",\"通过@MapperScan导入了MapperScannerRegistrar类\",\"MapperScannerRegistrar类实现了ImportBeanDefinitionRegistrar接口，所以Spring在启动时会调用MapperScannerRegistrar类中的registerBeanDefinitions方法\",\"在registerBeanDefinitions方法中定义了一个ClassPathMapperScanner对象，用来扫描mapper\",\"设置ClassPathMapperScanner对象可以扫描到接口，因为在Spring中是不会扫描接口的\",\"同时因为ClassPathMapperScanner中重写了isCandidateComponent方法，导致isCandidateComponent只会认为接口是备选者Component\",\"通过利用Spring的扫描后，会把接口扫描出来并且得到对应的BeanDefinition\",\"接下来把扫描得到的BeanDefinition进行修改，把BeanClass修改为MapperFactoryBean，把AutowireMode修改为byType\",\"扫描完成后，Spring就会基于BeanDefinition去创建Bean了，相当于每个Mapper对应一个FactoryBean\",\"在MapperFactoryBean中的getObject方法中，调用了getSqlSession()去得到一个sqlSession对象，然后根据对应的Mapper接口生成一个Mapper接口代理对象，这个代理对象就成为Spring容器中的Bean\",\"sqlSession对象是Mybatis中的，一个sqlSession对象需要SqlSessionFactory来产生\",\"MapperFactoryBean的AutowireMode为byType，所以Spring会自动调用set方法，有两个set方法，一个setSqlSessionFactory，一个setSqlSessionTemplate，而这两个方法执行的前提是根据方法参数类型能找到对应的bean，所以Spring容器中要存在SqlSessionFactory类型的bean或者SqlSessionTemplate类型的bean。\",\"如果你定义的是一个SqlSessionFactory类型的bean，那么最终也会被包装为一个SqlSessionTemplate对象，并且赋值给sqlSession属性\",\"而在SqlSessionTemplate类中就存在一个getMapper方法，这个方法中就产生一个Mapper接口代理对象\",\"到时候，当执行该代理对象的某个方法时，就会进入到Mybatis框架的底层执行流程，详细的请看下图\",\"Spring整合Mybatis之后SQL执行流程：https://www.processon.com/view/link/6152cc385653bb6791db436c\",\"如果Spring整合Mybatis之后，开启了事务，则一级缓存生效，如果没有开启事务，一级缓存就会失效。\"]},\"1531\":{\"h\":\"Spring AOP源码解析\",\"t\":[\"CGLIB和JDK的动态代理示例：\",\"public class ProxyTest { public static void main(String[] args) { /*********************** * CGLIB动态代理 ***********************/ UserService target = new UserService(); // 通过cglib技术 Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(UserService.class); // 定义额外逻辑，也就是代理逻辑 enhancer.setCallbacks(new Callback[]{new MethodInterceptor() { // o表示的就是代理对象，target是被代理的对象爱过你 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(\\\"before...\\\"); // 被代理的方法，目标对象 Object result = methodProxy.invoke(target, objects); // 执行原始对象的方法 // Object result = methodProxy.invokeSuper(target, objects); System.out.println(\\\"after...\\\"); return result; } }, NoOp.INSTANCE}); // 设置哪些方法不被代理 enhancer.setCallbackFilter(new CallbackFilter() { @Override public int accept(Method method) { if (method.getName().equals(\\\"test\\\")) { return 0; } else { return 1; } } }); // 动态代理所创建出来的UserService对象 UserService userService = (UserService) enhancer.create(); // 执行这个userService的test方法时，就会额外会执行一些其他逻辑 userService.test(); /*********************** * JDK动态代理 ***********************/ UserService target2 = new UserService(); // UserInterface接口的代理对象 Object proxy = Proxy.newProxyInstance(UserService.class.getClassLoader(), new Class[]{UserInterface.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\\\"before...\\\"); Object result = method.invoke(target2, args); System.out.println(\\\"after...\\\"); return result; } }); // 这里只能是UserInterface类型的，产生的代理对象一定是传入的接口的类型 UserInterface userService2 = (UserInterface) proxy; userService2.test(); } } \",\"在Spring中，对这两项技术做了一定程度的封装，使用ProxyFactory获取代理对象。\",\"public class SpringProxyTest { public static void main(String[] args) { UserService target = new UserService(); ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.setTarget(target); // 指定接口的时候，就会返回JDK动态代理的对象 // proxyFactory.setInterfaces(UserInterface.class); // 会被封装成MethodInterceptor，有多个Advice会按照顺序进行执行 proxyFactory.addAdvice(new MethodBeforeAdvice() { @Override public void before(Method method, Object[] args, Object target) throws Throwable { } }); UserService proxy = (UserService) proxyFactory.getProxy(); proxy.test(); } } \",\"除了直接使用API的方式来生成代理对象，也可以使用@Bean的方式代理对象：\",\" @Bean public DefaultPointcutAdvisor defaultPointcutAdvisor(){ NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut(); pointcut.addMethodName(\\\"test\\\"); DefaultPointcutAdvisor defaultPointcutAdvisor = new DefaultPointcutAdvisor(); defaultPointcutAdvisor.setPointcut(pointcut); defaultPointcutAdvisor.setAdvice(new AfterReturningAdvice() { @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { } }); return defaultPointcutAdvisor; } @Bean public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() { DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator(); return defaultAdvisorAutoProxyCreator; } \",\"DefaultAdvisorAutoProxyCreator实际上是一个BeanPostProcessor，会查找Advisor类型的Bean，就确定了哪些对象是需要生成代理对象的。\",\"AOP还有一种AspectJ的实现，Spring AOP参照了AspectJ的实现，复用了AspectJ中的几个核心注解，AspectJ是在编译期间就增强了对应的方法，Spring 则是在启动的过程中，通过CGLIB或者JDK的动态代理来实现AOP。Spring 会通过AnnotationAwareAspectJAutoProxyCreator将@Aspect注解扫描到Spring容器中。\",\"被代理的对象通常称为target，被代理的方法通常被称为Join point（连接点）。\",\"除了增强某个类中的某个方法，还可以通过@DeclareParents动态的为被代理对象增加接口和接口中定义的方法。但是这么做的缺点是，代码的可读性较差。\",\"创建代理对象的核心方法：\",\"可以通过设置exposeProxy=true，将代理对象暴露在ThreadLocal中，通过AopContext.currentProxy()就可以获取到被代理的对象。\",\"在ProxyFactory筛选代理对象的被代理的方法：\",\" List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); \",\"Advice的底层是通过MethodInterceptor来实现的。\",\"@Override public List<Object> getInterceptorsAndDynamicInterceptionAdvice( Advised config, Method method, @Nullable Class<?> targetClass) { AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); // config 其实就是ProxyFactory Advisor[] advisors = config.getAdvisors(); List<Object> interceptorList = new ArrayList<>(advisors.length); Class<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass()); Boolean hasIntroductions = null; for (Advisor advisor : advisors) { if (advisor instanceof PointcutAdvisor) { // 取出Pointcut，根据ClassFilter和MethodMatcher来进行过滤 PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor; if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) { MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher(); boolean match; if (mm instanceof IntroductionAwareMethodMatcher) { if (hasIntroductions == null) { hasIntroductions = hasMatchingIntroductions(advisors, actualClass); } match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions); } else { match = mm.matches(method, actualClass); } if (match) { // 适配成MethodInterceptor，通常情况都是一对一的，interceptors只会有一个元素 MethodInterceptor[] interceptors = registry.getInterceptors(advisor); // 运行时会封装成为InterceptorAndDynamicMethodMatcher // 真正执行的时候，会再检查MethodMatcher里带参数matches的方法是否返回true if (mm.isRuntime()) { for (MethodInterceptor interceptor : interceptors) { interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm)); } } else { interceptorList.addAll(Arrays.asList(interceptors)); } } } } else if (advisor instanceof IntroductionAdvisor) { IntroductionAdvisor ia = (IntroductionAdvisor) advisor; if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) { Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } else { Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } return interceptorList; } \",\"一个切面中 ，有@Before，@After（只有AspectJ才有），@Around等注解的方法，他们的执行顺序是由一个比较器来决定的：\",\"static { Comparator<Method> adviceKindComparator = new ConvertingComparator<>( new InstanceComparator<>( Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class), (Converter<Method, Annotation>) method -> { AspectJAnnotation<?> ann = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method); return (ann != null ? ann.getAnnotation() : null); }); Comparator<Method> methodNameComparator = new ConvertingComparator<>(Method::getName); adviceMethodComparator = adviceKindComparator.thenComparing(methodNameComparator); } \",\"即按照Around、Before、After、AfterReturning、AfterThrowing的顺序进行执行。出现重复的注解修饰的方法，会按照自然排序进行执行。\"]},\"1532\":{\"h\":\"Spring事务源码解析\",\"t\":[\"开启Spring事务本质上就是增加了一个Advisor，但我们使用@EnableTransactionManagement注解来开启Spring事务是，该注解代理的功能就是向Spring容器中添加了两个Bean：\",\"AutoProxyRegistrar\",\"ProxyTransactionManagementConfiguration\",\"AutoProxyRegistrar主要的作用是向Spring容器中注册了一个InfrastructureAdvisorAutoProxyCreator的Bean。\",\"而InfrastructureAdvisorAutoProxyCreator继承了AbstractAdvisorAutoProxyCreator，所以这个类的主要作用就是开启自动代理的作用，也就是一个BeanPostProcessor，会在初始化后步骤中去寻找Advisor类型的Bean，并判断当前某个Bean是否有匹配的Advisor，是否需要利用动态代理产生一个代理对象。\",\"ProxyTransactionManagementConfiguration是一个配置类，它又定义了另外三个bean：\",\"BeanFactoryTransactionAttributeSourceAdvisor：一个Advisor\",\"AnnotationTransactionAttributeSource：相当于BeanFactoryTransactionAttributeSourceAdvisor中的Pointcut\",\"TransactionInterceptor：相当于BeanFactoryTransactionAttributeSourceAdvisor中的Advice\",\"AnnotationTransactionAttributeSource就是用来判断某个类上是否存在@Transactional注解，或者判断某个方法上是否存在@Transactional注解的。\",\"TransactionInterceptor就是代理逻辑，当某个类中存在@Transactional注解时，到时就产生一个代理对象作为Bean，代理对象在执行某个方法时，最终就会进入到TransactionInterceptor的invoke()方法。\",\"核心API：org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration#transactionInterceptor\",\"事务的执行过程：\",\"Spring事务管理器，创建数据库连接conn\",\"conn.autocommit=flase\",\"将数据库连接conn放入ThreadLocal（key是DataSource，value是conn连接，这就要求Spring事务管理器中的DataSource和JDBC Tmeplate中的DataSource是同一个，否则，事务可能就会失效）\",\"执行业务方法\",\"如果执行成功，则提交事务\",\"如果抛出了异常，则回滚\",\"隔离级别会依赖于数据库，传播行为是Spring事务管理中的难点。\",\"同一个数据连接（或事务），要么一起提交，要么一起回滚。\",\"执行的核心逻辑：\",\" @Nullable protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass, final TransactionAspectSupport.InvocationCallback invocation) throws Throwable { // If the transaction attribute is null, the method is non-transactional. TransactionAttributeSource tas = getTransactionAttributeSource(); // 获取@Transactional注解的属性值 final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null); // 获取Spring 容器中的事务管理器 final TransactionManager tm = determineTransactionManager(txAttr); // ReactiveTransactionManager用的比较少，通常都走else的逻辑 if (this.reactiveAdapterRegistry != null && tm instanceof ReactiveTransactionManager) { boolean isSuspendingFunction = KotlinDetector.isSuspendingFunction(method); boolean hasSuspendingFlowReturnType = isSuspendingFunction && COROUTINES_FLOW_CLASS_NAME.equals(new MethodParameter(method, -1).getParameterType().getName()); if (isSuspendingFunction && !(invocation instanceof TransactionAspectSupport.CoroutinesInvocationCallback)) { throw new IllegalStateException(\\\"Coroutines invocation not supported: \\\" + method); } TransactionAspectSupport.CoroutinesInvocationCallback corInv = (isSuspendingFunction ? (TransactionAspectSupport.CoroutinesInvocationCallback) invocation : null); TransactionAspectSupport.ReactiveTransactionSupport txSupport = this.transactionSupportCache.computeIfAbsent(method, key -> { Class<?> reactiveType = (isSuspendingFunction ? (hasSuspendingFlowReturnType ? Flux.class : Mono.class) : method.getReturnType()); ReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(reactiveType); if (adapter == null) { throw new IllegalStateException(\\\"Cannot apply reactive transaction to non-reactive return type: \\\" + method.getReturnType()); } return new TransactionAspectSupport.ReactiveTransactionSupport(adapter); }); TransactionAspectSupport.InvocationCallback callback = invocation; if (corInv != null) { callback = () -> CoroutinesUtils.invokeSuspendingFunction(method, corInv.getTarget(), corInv.getArguments()); } Object result = txSupport.invokeWithinTransaction(method, targetClass, callback, txAttr, (ReactiveTransactionManager) tm); if (corInv != null) { Publisher<?> pr = (Publisher<?>) result; return (hasSuspendingFlowReturnType ? TransactionAspectSupport.KotlinDelegate.asFlow(pr) : TransactionAspectSupport.KotlinDelegate.awaitSingleOrNull(pr, corInv.getContinuation())); } return result; } PlatformTransactionManager ptm = asPlatformTransactionManager(tm); // 会将执行的方法名称设置为事务的名称 final String joinpointIdentification = methodIdentification(method, targetClass, txAttr); if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) { // 开启一个事务 TransactionAspectSupport.TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification); Object retVal; try { // 执行被代理对象中的方法 retVal = invocation.proceedWithInvocation(); } catch (Throwable ex) { // 抛出异常，则回滚 completeTransactionAfterThrowing(txInfo, ex); throw ex; } finally { cleanupTransactionInfo(txInfo); } if (retVal != null && vavrPresent && TransactionAspectSupport.VavrDelegate.isVavrTry(retVal)) { // Set rollback-only in case of Vavr failure matching our rollback rules... TransactionStatus status = txInfo.getTransactionStatus(); if (status != null && txAttr != null) { retVal = TransactionAspectSupport.VavrDelegate.evaluateTryFailure(retVal, txAttr, status); } } // 提交事务 commitTransactionAfterReturning(txInfo); return retVal; } else { Object result; final TransactionAspectSupport.ThrowableHolder throwableHolder = new TransactionAspectSupport.ThrowableHolder(); // It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in. try { result = ((CallbackPreferringPlatformTransactionManager) ptm).execute(txAttr, status -> { TransactionAspectSupport.TransactionInfo txInfo = prepareTransactionInfo(ptm, txAttr, joinpointIdentification, status); try { Object retVal = invocation.proceedWithInvocation(); if (retVal != null && vavrPresent && TransactionAspectSupport.VavrDelegate.isVavrTry(retVal)) { // Set rollback-only in case of Vavr failure matching our rollback rules... retVal = TransactionAspectSupport.VavrDelegate.evaluateTryFailure(retVal, txAttr, status); } return retVal; } catch (Throwable ex) { if (txAttr.rollbackOn(ex)) { // A RuntimeException: will lead to a rollback. if (ex instanceof RuntimeException) { throw (RuntimeException) ex; } else { throw new TransactionAspectSupport.ThrowableHolderException(ex); } } else { // A normal return value: will lead to a commit. throwableHolder.throwable = ex; return null; } } finally { cleanupTransactionInfo(txInfo); } }); } catch (TransactionAspectSupport.ThrowableHolderException ex) { throw ex.getCause(); } catch (TransactionSystemException ex2) { if (throwableHolder.throwable != null) { logger.error(\\\"Application exception overridden by commit exception\\\", throwableHolder.throwable); ex2.initApplicationException(throwableHolder.throwable); } throw ex2; } catch (Throwable ex2) { if (throwableHolder.throwable != null) { logger.error(\\\"Application exception overridden by commit exception\\\", throwableHolder.throwable); } throw ex2; } // Check result state: It might indicate a Throwable to rethrow. if (throwableHolder.throwable != null) { throw throwableHolder.throwable; } return result; } } \"]},\"1533\":{\"h\":\"Spring MVC源码分析\",\"t\":[\"Spring MVC本质上是基于Servlet API构建的原始Web框架。\"]},\"1534\":{\"h\":\"Spring MVC执行流程\",\"t\":[\"最典型的MVC就是JSP+Servlet+javabean的模式。\",\"所有的请求都会经过DispatcherServlet。\",\"Spring MVC的请求执行过程：\",\"HandlerMapping的典型实现：\",\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\",\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\",\"HandlerAdapter的典型实现：\",\"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter\",\"ViewResoler的典型实现：\",\"org.springframework.web.servlet.view.BeanNameViewResolver\",\"处理请求的方法：\",\"可以发现，一旦有一个Handler成功匹配，就会直接返回，不会再往下匹配了。\",\"@RequestMapping的完成流程：https://www.processon.com/view/link/615ea79e1efad4070b2d6707\",\"参数解析转换核心API：\",\"org.springframework.http.converter.HttpMessageConverter\",\"扩展点：前、后拦截器：\",\"public class JycInterceptor implements HandlerInterceptor { /** * 在 HandlerMapping 确定合适的处理程序对象之后，但在 HandlerAdapter 调用处理程序之前调用 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return HandlerInterceptor.super.preHandle(request, response, handler); } /** * 拦截处理程序的执行。在 HandlerAdapter 实际上调用处理程序之后调用，但在 DispatcherServlet 呈现视图之前调用 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); } /** * 请求处理完成后的回调，即渲染视图后。将在处理程序执行的任何结果上调用，从而允许进行适当的资源清理。 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { HandlerInterceptor.super.afterCompletion(request, response, handler, ex); } } \"]},\"1535\":{\"h\":\"Spring MVC启动过程\",\"t\":[\"容器之间的关系：\",\"SPI机制：服务提供者接口，Tomcat提供了WebApplicationInitializer的接口，实现者必须按照Servlet规范实现接口，然后在MTEA-INF/services目录下放置一个名称为javax.servlet接口名，里面的内容是实现者实现的类的完整的类限定名。\",\"Tomcat除了会帮我们实例化我们所实现的WebApplicationInitializer的类以外，还提供了@HandlerTypes，他会将@HandlerTypes执行的接口的实现类，传递到onStartup方法的第一个参数上面（webAppInitializerClasses）去。\",\" protected void registerDispatcherServlet(ServletContext servletContext) { String servletName = getServletName(); Assert.hasLength(servletName, \\\"getServletName() must not return null or empty\\\"); // 创建Servlet容器 WebApplicationContext servletAppContext = createServletApplicationContext(); Assert.notNull(servletAppContext, \\\"createServletApplicationContext() must not return null\\\"); // 创建DispatcherServlet FrameworkServlet dispatcherServlet = createDispatcherServlet(servletAppContext); Assert.notNull(dispatcherServlet, \\\"createDispatcherServlet(WebApplicationContext) must not return null\\\"); dispatcherServlet.setContextInitializers(getServletApplicationContextInitializers()); ServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet); if (registration == null) { throw new IllegalStateException(\\\"Failed to register servlet with name '\\\" + servletName + \\\"'. \\\" + \\\"Check if there is another servlet registered under the same name.\\\"); } // 启动时加载 registration.setLoadOnStartup(1); // 映射 registration.addMapping(getServletMappings()); // 是否支持异步 registration.setAsyncSupported(isAsyncSupported()); // 设置DispatcherServlet的过滤器 Filter[] filters = getServletFilters(); if (!ObjectUtils.isEmpty(filters)) { for (Filter filter : filters) { registerServletFilter(servletContext, filter); } } // 模版方法 customizeRegistration(registration); } \",\"启动核心API：\",\"org.springframework.web.context.ContextLoader\",\"添加配置类：\",\"org.springframework.web.servlet.config.annotation.WebMvcConfigurer\"]},\"1536\":{\"h\":\"Spring和Spring MVC为什么需要父子容器？不要不行吗？\",\"t\":[\"就实现层面来说，不用父子容器也可以完成所需功能。之所以设置了父子容器：\",\"为了与Spring划分边界，将Controller交由Spring mvc的容器管理，其他则交由Spring管理\",\"规范整体框架，使得父容器（Spring容器）无法访问子容器（Spring MVC容器）\",\"为了方便子容器的切换，可以很方便的将Spring MVC替换为struts\",\"为了节省重复创建Bean的开销\"]},\"1537\":{\"h\":\"是否可以把所有Bean都通过Spring容器来管理？\",\"t\":[\"不可以，因为HandleMethod需要在Spring MVC容器中查找Controller，如果交由Spring管理，会找不到对应的Controller。\"]},\"1538\":{\"h\":\"是否可以把所有Bean都交由Spring MVC容器进行管理？\",\"t\":[\"可以，因为doGetBean方法的逻辑是，子容器中找不到，会在父容器查找Bean，都放到子容器中，可以直接查找到。\"]},\"1539\":{\"h\":\"JVM\"},\"1540\":{\"h\":\"JVM类加载机制\",\"t\":[\"参考链接：http://note.youdao.com/noteshare?id=35faf7c95e69943cdbff4642fcfd5318&sub=F6E1EB8E778044EC9BB87BA05DCE5E4B\",\"通过Java命令执行代码的大体流程如下：\",\"其中类加载过程有加载、验证、准备、解析、初始化、使用、卸载：\",\"加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\",\"验证：校验字节码文件的正确性\",\"准备：给类的静态变量分配内存，并赋予默认值\",\"解析：将符号引用替换为直接引用，该阶段会把一些静态方法（符号引用，比如main()方法）替换为指向数据所存内存的指针或句柄等（直接引用），这就是所谓的静态链接过程（类加载期间完成），动态链接是在程序运行期间完成的将符号引用替换为直接引用\",\"初始化：对类的静态变量初始化为指定的值，执行静态代码块\",\"类被加载到方法区中后主要包含运行时常量池、类型信息、字段信息、方法信息、类加载的引用、对应Class实例的引用等信息。\",\"类加载器的引用：这个类到类加载器实例的引用。\",\"对应Class实例的引用：类加载器在加载类信息放到方法区中后，会创建一个对应的Class类型的对象实例放到堆中，作为开发人员访问方法区中类定义的入口和切入点。\",\"Java中有以下几种类加载器：\",\"引导类加载器：负载加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、chatset.jar等\",\"扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext目录下的类库，比如JAR类包\",\"应用类加载器：负责加载ClassPath路径下的类包，主要就是加载自己写的那些类\",\"自定义类加载器：负载加载用户自定义路径下的类包\",\"Java类加载器是有亲子层级结构的，具体如下图。\",\"为什么要设计双亲委托机制？\",\"沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改\",\"避免类的重复加载：当父亲已经加载了该类时，就没有必要子类加载器再加载一次，保证加载类的唯一性\",\"双亲委派机制简单来说就是，先找父亲加载，不行再由儿子自己加载。\",\"//ClassLoader的loadClass方法，里面实现了双亲委派机制 protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 检查当前类加载器是否已经加载了该类 Class<?> c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { //如果当前加载器父加载器不为空则委托父加载器加载该类 c = parent.loadClass(name, false); } else { //如果当前加载器父加载器为空则委托引导类加载器加载该类 c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); //都会调用URLClassLoader的findClass方法在加载器的类路径里查找并加载该类 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { //不会执行 resolveClass(c); } return c; } } \",\"全盘负责委托机制：全盘负责是指当一个ClassLoader装在一个类时，除非显示的使用另外一个ClassLoader，该类所依赖及引用的类也由这个ClassLoader载入。\",\"Tomcat自定义类加载器：\"]},\"1541\":{\"h\":\"JVM内存模型\",\"t\":[\"JDK的体系结构：\",\"JVM整体架构及内存模型：\",\"栈（线程）的作用：保存局部变量的地方。\",\"栈帧：一个方法对应一块独立的栈帧内存区域。\",\"局部变量表：在类似数组的数据结构里存放局部变量\",\"操作数栈：程序运行过程中，进行加法（或其他）运算的一块临时内存，是一种栈结构\",\"动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期间调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接\",\"方法出口： 用来记录回到调用的地方继续执行程序的地方\",\"方法区使用的直接内存。\",\"JVM参数设置：\",\"SpringBoot程序的JVM参数设置格式：\",\"java -Xms2048M -Xmx2048M -Xmn1024M -Xss512K -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -jar microservice-eureka-server.jar \",\"各个参数对应的含义：\",\"-Xss：每个线程的栈大小\",\"-Xms：设置堆的初始可用大小，默认是物理内存的1/64\",\"-Xmx：设置堆的最大可用大小，默认物理内存的1/4\",\"-Xmn：新生代大小\",\"-XX：NewRatio：默认值2代表新生代占老年代的1/2，占整个堆内存的1/3\",\"-XX：SurvivorRatio：默认8表示一个Survivor区占用1/8的Eden内存，即1/10的新生代内存\",\"关于元空间的JVM参数。有两个：-XX：MetaspaceSize=N和-XX：MAXMetaspaceSize=N。\",\"-XX：MAXMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存的大小。\",\"-XX：MetaspaceSize：指定元空间触发Full GC初始阈值（元空间无固定初始大小），以字节为单位，默认是21M左右，达到该值就会触发full gc进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很多空间，那么在不超过-XX：MAXMetaspaceSize（如果设置了的话）的情况下，适当提高该值。这个跟早期JDK版本的-XX:PermSize参数意思不一样，-XX:PermSize代表永久带的初始容量。\",\"由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MAXMetaspaceSize设置成一样的值，并设置得比初始值要大，对于8G物理内存的机器来说，一般会将这两个值设置成256M。\"]},\"1542\":{\"h\":\"JVM对象创建与内存分配机制深度剖析\",\"t\":[\"对象创建的过程：\"]},\"1543\":{\"h\":\"类加载检查\",\"t\":[\"虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\",\"new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。\"]},\"1544\":{\"h\":\"分配内存\",\"t\":[\"在类加载检查通过后，接下来\"]},\"1545\":{\"h\":\"划分内存的方法\",\"t\":[\"解决并发问题的方法：\",\"CAS：虚拟机采用CAS分配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。\",\"本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）：\"]},\"1546\":{\"h\":\"设置对象头\",\"t\":[\"大对象：-XX:PretenureSizeThreshold=1000000（单位是字节）。需要配合具体的垃圾收集器一起使用：-XX:+UseSerialGC。\",\"这样做的目的是为了避免大对象分配内存时的复制操作而降低效率。\"]},\"1547\":{\"h\":\"Class文件结构\"},\"1548\":{\"h\":\"垃圾收集器\"},\"1549\":{\"h\":\"JVM调优工具\"},\"1550\":{\"h\":\"JVM常量池\"},\"1551\":{\"h\":\"ZGC详解\"},\"1552\":{\"h\":\"云原生时代的Java虚拟机\"},\"1553\":{\"h\":\"用Java实现一个JVM框架\"},\"1554\":{\"h\":\"JVM如何调用Java方法\"},\"1555\":{\"h\":\"实现STW\"},\"1556\":{\"h\":\"Java 日志体系\"},\"1557\":{\"h\":\"Java监控简介\"},\"1558\":{\"h\":\"RMI 简介\"},\"1559\":{\"h\":\"\"},\"1560\":{\"h\":\"Tomcat\"},\"1561\":{\"h\":\"Tomcat整体架构\",\"t\":[\"Tomcat是Java Web应用服务器，实现Java EE（Java Platform Enterprise Edition）的部分技术规范，比如Java Servlet、JavaServer Pages、Java Expression Language、Java WebSocket等。\",\"Tomcat的核心：Http服务器+Serverlet容器\",\"我们可以通过Tomcat的server.xml配置文件来加深对Tomcat架构的理解。Tomcat采用了组件化的设计，它的构成组件都是可配置的，其中最外层的是Server，其他组件按照一定的格式要求配置在这个顶层容器中。\",\"<Server> //顶层组件，可以包括多个Service <Service> //顶层组件，可包含一个Engine，多个连接器 <Connector/>//连接器组件，代表通信接口 <Engine>//容器组件，一个Engine组件处理Service中的所有请求，包含多个Host <Host> //容器组件，处理特定的Host下客户请求，可包含多个Context <Context/> //容器组件，为特定的Web应用处理所有的客户请求 </Host> </Engine> </Service> </Server> \",\"Tomcat启动期间会通过解析server.xml，利用反射创建相应的组件，所以xml的标签和源码一一对应。\",\"Tomcat的架构图如下：\",\"简化之后的图：\",\"Tomcat要实现2个核心功能：\",\"处理Socket连接，负责网络字节流与Request和Response对象的转化\",\"加载和管理Servlet，以及具体处理Request请求\",\"因此Tomcat设计了两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情。连接器负责对外交流，容器负责内部处理。\"]},\"1562\":{\"h\":\"Tomcat核心组件\"},\"1563\":{\"h\":\"Server组件\",\"t\":[\"Server组件指的就是整个Tomcat服务器，包含多组服务（Service），负责管理和启动各个Service，同时监听8005端口发过来的shutdown命令，用于关闭整个容器。\"]},\"1564\":{\"h\":\"Service组件\",\"t\":[\"每个Service组件都包含了若干接收客户端消息的Connector组件和处理请求的Engine组件。Service组件还包含了若干Executor组件，每个Executor都是一个线程池，它可以为Service内所有组件提供线程池执行任务。\"]},\"1565\":{\"h\":\"连接器Connector组件\",\"t\":[\"Tomcat与外部世界的连接器，监听固定端口接收外部请求，传递给Container，并将Container处理的结果返回给外部。连接器对Servlet容器屏蔽了不同的应用层协议及I/O模型，无论是HTTP还是AJP，在容器中获取到的都是一个标准的ServletRequest对象。连接器需要实现的功能：\",\"监听网络端口\",\"接收网络连接请求\",\"获取请求网络字节流\",\"根据具体应用协议（HTTP/AJP）解析字节流，生成统一的Tomcat Request对象\",\"将Tomcat Request对象转成标准的Servlet Request\",\"调用Servlet容器，得到ServletResponse\",\"将Tomcat Response转成网络字节流\",\"将响应字节流写会给浏览器\",\"分析连接器的功能列表，会发现连接器需要完成3个高内聚的功能：\",\"网络通信\",\"应用层协议解析\",\"Tomcat Request/Response 与ServletRequest/ServletResponse的转化\",\"因此，Tomcat的设计者分别设计了3个组件来实现这3个功能，分别是EndPoint、Processor和Adapter：\",\"EndPoint负责提供字节流给Processor\",\"Processor负责提供Tomcat Request对象给Adapter\",\"Adapter负责提供ServletRequest对象给容器\",\"由于I/O模型和应用层协议可以自由组合，比如NIO+HTTP或者NIO2+AJP。Tomcat的设计者将网络通信和应用层协议解析放在一起考虑，设计了一个ProtocolHandler的接口来封装这两种变化点。各种协议和通信模型的组合有相应的具体实现类。比如Http11NioProtocol和AjpNioProtocol。\",\"除了这些变化点，系统也存在一些相对稳定的部分，因此Tomcat设计了一系列抽象基类来封装这些稳定的部分，抽象基类AbstractProtocol实现了ProtocolHandler接口。每一种应用层协议都有自己的抽象基类，比如AbstractAjpProtocol和AbstractHttp11Protocol，具体协议的实现类扩展了协议层抽象基类。\"]},\"1566\":{\"h\":\"ProtocolHandler组件\",\"t\":[\"连接器用ProtocolHandler来处理网络连接和应用层协议，包含两个重要部件：EndPoint和Processor。\",\"连接器用ProtocolHandler接口来封装通信协议个I/O模型的差异，ProtocolHandler内部又分为EndPoint和Processor模块，EndPoint负责底层Sokcet通信，Processor负责应用层协议解析。连接器通过适配器Adapter调用容器。\"]},\"1567\":{\"h\":\"Tomcat线程模型\",\"t\":[\"MMU内存管理模型。\",\"Tomcat对JDK线程池的扩展TaskQueue#offer：\",\"@Override public boolean offer(Runnable o) { //we can't do any checks if (parent==null) { return super.offer(o); } //we are maxed out on threads, simply queue the object if (parent.getPoolSize() == parent.getMaximumPoolSize()) { return super.offer(o); } //we have idle threads, just add it to the queue if (parent.getSubmittedCount()<=(parent.getPoolSize())) { return super.offer(o); } //if we have less threads than maximum force creation of a new thread if (parent.getPoolSize()<parent.getMaximumPoolSize()) { return false; } //if we reached here, we need to add it to the queue return super.offer(o); } \",\"这样在未达到最大线程数的时候，会首先创建线程，只有在达到了线程池最大线程数的时候才会将任务放入到阻塞队列。\"]},\"1568\":{\"h\":\"Tomcat类加载机制\"},\"1569\":{\"h\":\"JVM类加载器\",\"t\":[\"BootStrapClassLoader（启动类加载器），\",\"ExtClassLoader（扩展类加载器），\",\"AppClassLoader（系统类加载器）\",\"自定义类加载器，用来加载自定义路径下的类\"]},\"1570\":{\"h\":\"双亲委托机制\",\"t\":[\"加载某个类会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类。这就是双亲委托机制。\",\"类加载过程\",\"为什么要设计双亲委托机制？\",\"沙箱安全机制\",\"避免类的重复加载\"]},\"1571\":{\"h\":\"Tomcat的类加载机制\",\"t\":[\"Tomcat作为Servlet容器，它负责加载Servlet类，此外它还负责加载Servlet所依赖的Jar包。并且Tomcat本身也是一个Java程序，因此它需要加载自己的类和依赖的jar包。\",\"Tomcat中自定义了一个类加载器WebAppClassLoader，并且给每个Web应用创建一个类加载器实例，每个Context容器负责创建和维护一个WebAppClassLoader加载器实例。其实现的原理就是不同的类加载器实例加载的类被认为是不同的类，即使它们的类名相同（不同类加载器实例加载的类是互相隔离的）。\",\"Tomcat拥有不同的自定义类加载器，以实现对各种资源库的控制。Tomcat主要用类加载器解决以下4个问题：\",\"同一个Web服务器里，各个Web项目各自使用的Java类库要相互隔离\",\"同一个Web服务器里，各个Web项目之间可以提供共享的Java类库\",\"为了使服务器不受Web项目的影响，应该使服务器的类库与应用程序的类库相互独立\",\"对于支持JSP的Web服务器，应该支持热插拔（HotSwap）功能\",\"Tomcat提供了四组目录供用户存放第三方类库：\",\"放置在/common目录中：类库可被Tomcat和所有的Web应用程序共同使用\"]},\"1572\":{\"h\":\"线程上下文类加载器\"},\"1573\":{\"h\":\"Tomcat热加载和热部署\"},\"1574\":{\"h\":\"深入理解JVM\"},\"1575\":{\"h\":\"内存管理\"},\"1576\":{\"h\":\"垃圾回收\"},\"1577\":{\"h\":\"类文件结构\"},\"1578\":{\"h\":\"类加载机制\"},\"1579\":{\"h\":\"运行时数据区域\"},\"1580\":{\"h\":\"程序计数器\"},\"1581\":{\"h\":\"虚拟机栈\"},\"1582\":{\"h\":\"本地方法栈\"},\"1583\":{\"h\":\"堆\"},\"1584\":{\"h\":\"方法区\"},\"1585\":{\"h\":\"运行时常量池\"},\"1586\":{\"h\":\"直接内存\"},\"1587\":{\"h\":\"HotSpot虚拟机对象\"},\"1588\":{\"h\":\"对象的创建\"},\"1589\":{\"h\":\"对象的内存布局\"},\"1590\":{\"h\":\"对象的访问定位\"},\"1591\":{\"h\":\"判断对象已死\"},\"1592\":{\"h\":\"引用计数算法\"},\"1593\":{\"h\":\"根搜索算法\"},\"1594\":{\"h\":\"对象的回收\"},\"1595\":{\"h\":\"对象的引用\"},\"1596\":{\"h\":\"垃圾回收算法\"},\"1597\":{\"h\":\"分代收集理论\"},\"1598\":{\"h\":\"标记-清除算法\"},\"1599\":{\"h\":\"标记-复制算法\"},\"1600\":{\"h\":\"标记-整理算法\"},\"1601\":{\"h\":\"经典垃圾收集器\"},\"1602\":{\"h\":\"Serial收集器\"},\"1603\":{\"h\":\"ParNew收集器\"},\"1604\":{\"h\":\"Parallel Scavenge收集器\"},\"1605\":{\"h\":\"Serial Old收集器\"},\"1606\":{\"h\":\"Parallel Old收集器\"},\"1607\":{\"h\":\"CMS收集器\"},\"1608\":{\"h\":\"CMS简介\"},\"1609\":{\"h\":\"CMS详细步骤\"},\"1610\":{\"h\":\"初始标记\"},\"1611\":{\"h\":\"并发标记\"},\"1612\":{\"h\":\"预清理阶段\"},\"1613\":{\"h\":\"可终止的预清理\"},\"1614\":{\"h\":\"重新标记\"},\"1615\":{\"h\":\"并发清理\"},\"1616\":{\"h\":\"并发重置\"},\"1617\":{\"h\":\"Garbage First收集器\"},\"1618\":{\"h\":\"G1简介\"},\"1619\":{\"h\":\"重要概念\"},\"1620\":{\"h\":\"Region\"},\"1621\":{\"h\":\"三色标记算法\"},\"1622\":{\"h\":\"SATB算法\"},\"1623\":{\"h\":\"RSet\"},\"1624\":{\"h\":\"CSet\"},\"1625\":{\"h\":\"停顿预测模型\"},\"1626\":{\"h\":\"GC过程\"},\"1627\":{\"h\":\"回收算法\"},\"1628\":{\"h\":\"收集过程\"},\"1629\":{\"h\":\"Young GC\"},\"1630\":{\"h\":\"Mixed GC\"},\"1631\":{\"h\":\"global concurrent marking\"},\"1632\":{\"h\":\"G1特点\"},\"1633\":{\"h\":\"参数设置\"},\"1634\":{\"h\":\"垃圾收集器参数总结\"},\"1635\":{\"h\":\"HotSpot的算法实现细节\"},\"1636\":{\"h\":\"根节点枚举\"},\"1637\":{\"h\":\"安全点\"},\"1638\":{\"h\":\"安全区域\"},\"1639\":{\"h\":\"记忆集与卡表\"},\"1640\":{\"h\":\"并发的可达性分析\"},\"1641\":{\"h\":\"空间分配担保\"},\"1642\":{\"h\":\"内存屏障\"},\"1643\":{\"h\":\"来源\"},\"1644\":{\"h\":\"类型\"},\"1645\":{\"h\":\"Java内存屏障\"},\"1646\":{\"h\":\"volatile语义中的内存屏障\"},\"1647\":{\"h\":\"final语义中的内存屏障\"},\"1648\":{\"h\":\"性能监控、故障处理工具\"},\"1649\":{\"h\":\"基础故障处理工具\"},\"1650\":{\"h\":\"可视化故障处理工具\"},\"1651\":{\"h\":\"jvisualvm\"},\"1652\":{\"h\":\"jconsole\"},\"1653\":{\"h\":\"Class类文件的结构\"},\"1654\":{\"h\":\"魔数与Class文件的版本\"},\"1655\":{\"h\":\"常量池\"},\"1656\":{\"h\":\"访问标志\"},\"1657\":{\"h\":\"类索引、父类索引与接口索引集合\"},\"1658\":{\"h\":\"字段表集合\"},\"1659\":{\"h\":\"方法表集合\"},\"1660\":{\"h\":\"属性表集合\"},\"1661\":{\"h\":\"字节码指令\"},\"1662\":{\"h\":\"字节码与数据类型\"},\"1663\":{\"h\":\"类加载过程\"},\"1664\":{\"h\":\"加载\"},\"1665\":{\"h\":\"验证\"},\"1666\":{\"h\":\"准备\"},\"1667\":{\"h\":\"解析\"},\"1668\":{\"h\":\"初始化\"},\"1669\":{\"h\":\"类加载器\"},\"1670\":{\"h\":\"类与类加载器\"},\"1671\":{\"h\":\"双亲委派模型\"},\"1672\":{\"h\":\"破坏双亲委派模型\"},\"1673\":{\"h\":\"SPI机制\"},\"1674\":{\"h\":\"简介\"},\"1675\":{\"h\":\"JDK SPI\"},\"1676\":{\"h\":\"Spring SPI\"},\"1677\":{\"h\":\"运行时栈帧结构\"},\"1678\":{\"h\":\"局部变量表\"},\"1679\":{\"h\":\"操作数栈\"},\"1680\":{\"h\":\"动态连接\"},\"1681\":{\"h\":\"方法返回地址\"},\"1682\":{\"h\":\"附加信息\"},\"1683\":{\"h\":\"方法调用\"},\"1684\":{\"h\":\"解析\"},\"1685\":{\"h\":\"分派\"},\"1686\":{\"h\":\"Java内存模型\"},\"1687\":{\"h\":\"主内存与工作内存\"},\"1688\":{\"h\":\"volatile型变量\"},\"1689\":{\"h\":\"Java与线程\"},\"1690\":{\"h\":\"线程的实现\"},\"1691\":{\"h\":\"Java线程调度\"},\"1692\":{\"h\":\"线程状态\"},\"1693\":{\"h\":\"线程安全\"},\"1694\":{\"h\":\"互斥同步\"},\"1695\":{\"h\":\"非阻塞同步\"},\"1696\":{\"h\":\"无同步方案\"},\"1697\":{\"h\":\"锁优化\"},\"1698\":{\"h\":\"自旋锁与自适应自旋\"},\"1699\":{\"h\":\"锁消除\"},\"1700\":{\"h\":\"锁粗化\"},\"1701\":{\"h\":\"轻量级锁\"},\"1702\":{\"h\":\"偏向锁\"},\"1703\":{\"h\":\"RocketMQ从实践到原理\"},\"1704\":{\"h\":\"概念\"},\"1705\":{\"h\":\"消息模型\"},\"1706\":{\"h\":\"生产者组\"},\"1707\":{\"h\":\"消费者组\"},\"1708\":{\"h\":\"集群消费\"},\"1709\":{\"h\":\"广播消息\"},\"1710\":{\"h\":\"标签\"},\"1711\":{\"h\":\"队列\"},\"1712\":{\"h\":\"协议\"},\"1713\":{\"h\":\"特性\"},\"1714\":{\"h\":\"消息顺序\"},\"1715\":{\"h\":\"消息重试\"},\"1716\":{\"h\":\"延迟队列\"},\"1717\":{\"h\":\"死信队列\"},\"1718\":{\"h\":\"技术架构\"},\"1719\":{\"h\":\"集群工作流程\"},\"1720\":{\"h\":\"架构设计\"},\"1721\":{\"h\":\"消息存储\"},\"1722\":{\"h\":\"消息存储整体架构\"},\"1723\":{\"h\":\"页缓存与内存映射\"},\"1724\":{\"h\":\"消息刷盘\"},\"1725\":{\"h\":\"通信机制\"},\"1726\":{\"h\":\"RocketMQ通信类结构\"},\"1727\":{\"h\":\"Reactor线程设计\"},\"1728\":{\"h\":\"消息过滤\"},\"1729\":{\"h\":\"负载均衡\"},\"1730\":{\"h\":\"生产者\"},\"1731\":{\"h\":\"Tags的使用\"},\"1732\":{\"h\":\"Keys的使用\"},\"1733\":{\"h\":\"选择oneway形式发送\"},\"1734\":{\"h\":\"消费者\"},\"1735\":{\"h\":\"消费过程幂等\"},\"1736\":{\"h\":\"提升消费速度\"},\"1737\":{\"h\":\"顺序消费\"},\"1738\":{\"h\":\"并发消费\"},\"1739\":{\"h\":\"顺序消费\"},\"1740\":{\"h\":\"全局有序\"},\"1741\":{\"h\":\"分区有序\"},\"1742\":{\"h\":\"订阅关系的一致性\"},\"1743\":{\"h\":\"正确的订阅关系\"},\"1744\":{\"h\":\"错误的订阅关系\"},\"1745\":{\"h\":\"订阅了不同的Topic\"},\"1746\":{\"h\":\"订阅了不同Tag\"},\"1747\":{\"h\":\"订阅不同数量的Topic\"},\"1748\":{\"h\":\"配置管理\"},\"1749\":{\"h\":\"依赖管理\"},\"1750\":{\"h\":\"外部化配置\"},\"1751\":{\"h\":\"配置类\"},\"1752\":{\"h\":\"发送消息\"},\"1753\":{\"h\":\"发送普通消息\"},\"1754\":{\"h\":\"发送事务消息\"},\"1755\":{\"h\":\"接收消息\"},\"1756\":{\"h\":\"接收普通消息\"},\"1757\":{\"h\":\"接收事务消息\"},\"1758\":{\"h\":\"消息发送过程\"},\"1759\":{\"h\":\"选择发送的路由\"},\"1760\":{\"h\":\"向Broker发送消息\"},\"1761\":{\"h\":\"消息存储过程\"},\"1762\":{\"h\":\"写入文件\"},\"1763\":{\"h\":\"文件可以完全存储消息\"},\"1764\":{\"h\":\"文件不可以完全存储消息\"},\"1765\":{\"h\":\"消息刷盘\"},\"1766\":{\"h\":\"消息接收过程\"},\"1767\":{\"h\":\"消费者注册\"},\"1768\":{\"h\":\"消息队列\"},\"1769\":{\"h\":\"广播模式\"},\"1770\":{\"h\":\"集群模式\"},\"1771\":{\"h\":\"平均分配策略\"},\"1772\":{\"h\":\"平均分配轮询策略\"},\"1773\":{\"h\":\"一致性哈希策略\"},\"1774\":{\"h\":\"Broker消费队列\"},\"1775\":{\"h\":\"集群模式\"},\"1776\":{\"h\":\"广播模式\"},\"1777\":{\"h\":\"消费消息\"},\"1778\":{\"h\":\"并发消费\"},\"1779\":{\"h\":\"有序消费\"},\"1780\":{\"h\":\"消息过滤过程\"},\"1781\":{\"h\":\"消息过滤类型\"},\"1782\":{\"h\":\"标签匹配\"},\"1783\":{\"h\":\"SQL匹配\"},\"1784\":{\"h\":\"注册过滤信息\"},\"1785\":{\"h\":\"生成BloomFilterData\"},\"1786\":{\"h\":\"编译SQL语句\"},\"1787\":{\"h\":\"计算位映射\"},\"1788\":{\"h\":\"存储位映射\"},\"1789\":{\"h\":\"消息过滤\"},\"1790\":{\"h\":\"自定义匹配\"},\"1791\":{\"h\":\"过滤服务器\"},\"1792\":{\"h\":\"过滤类\"},\"1793\":{\"h\":\"过滤消息\"},\"1794\":{\"h\":\"消息索引流程\"},\"1795\":{\"h\":\"消息查询\"},\"1796\":{\"h\":\"ID (偏移量) 查询\"},\"1797\":{\"h\":\"消息索引服务\"},\"1798\":{\"h\":\"索引文件结构\"},\"1799\":{\"h\":\"添加消息\"},\"1800\":{\"h\":\"查询消息\"},\"1801\":{\"h\":\"唯一键查询\"},\"1802\":{\"h\":\"键查询消息\"},\"1803\":{\"h\":\"定时消息和重试消息\"},\"1804\":{\"h\":\"定时消息\"},\"1805\":{\"h\":\"定时消息存储\"},\"1806\":{\"h\":\"消息重试\"},\"1807\":{\"h\":\"Producer消息发送重试\"},\"1808\":{\"h\":\"Consumer消息接收重试\"},\"1809\":{\"h\":\"主备同步\"},\"1810\":{\"h\":\"建立连接\"},\"1811\":{\"h\":\"数据传输\"},\"1812\":{\"h\":\"消息异步传输\"},\"1813\":{\"h\":\"消息同步传输\"},\"1814\":{\"h\":\"消费建议\"},\"1815\":{\"h\":\"异常处理\"},\"1816\":{\"h\":\"事务消息\"},\"1817\":{\"h\":\"发送事务消息\"},\"1818\":{\"h\":\"接收事务消息\"},\"1819\":{\"h\":\"接收事务准备消息\"},\"1820\":{\"h\":\"接收事务结束的消息\"},\"1821\":{\"h\":\"扫描事务状态\"},\"1822\":{\"h\":\"Server定时扫描\"},\"1823\":{\"h\":\"Server检查事务状态\"},\"1824\":{\"h\":\"客户端检查事务状态\"},\"1825\":{\"h\":\"ACL权限控制\"},\"1826\":{\"h\":\"使用示例\"},\"1827\":{\"h\":\"RPCHook\"},\"1828\":{\"h\":\"AclClientRPCHook\"},\"1829\":{\"h\":\"生成签名\"},\"1830\":{\"h\":\"添加扩展字段\"},\"1831\":{\"h\":\"Broker权限验证\"},\"1832\":{\"h\":\"校验权限\"},\"1833\":{\"h\":\"ACL权限管理器\"},\"1834\":{\"h\":\"逻辑队列\"},\"1835\":{\"h\":\"架构实现\"},\"1836\":{\"h\":\"实现\"},\"1837\":{\"h\":\"监听者模式\"},\"1838\":{\"h\":\"Zookeeper\"},\"1839\":{\"h\":\"Zookeeper特性与节点数据类型\"},\"1840\":{\"h\":\"Zookeeper经典应用场景\"},\"1841\":{\"h\":\"Zookeeper集群Leader选举\"},\"1842\":{\"h\":\"Zookeeper集群与Watcher监听机制\"},\"1843\":{\"h\":\"\",\"t\":[\"云原生时代，Java 的危与机\",\"从Linux内核角度探秘JDK NIO文件读写本质\",\"MVCC机制\",\"76 张图，剖析 Spring AOP 源码\",\"系统日志规范及最佳实践\",\"一个高并发项目到落地的心酸路\"]},\"1844\":{\"h\":\"\",\"t\":[\"Java\",\"语言基础\",\" Java编程开发入门\",\"Java面向对象编程\",\"Java高级编程\",\"深入理解Java8\",\"常用框架\",\"SSM框架\",\"MyBatisPlus\",\"跟我学SpringBoot\",\"SpringBoot与SpringCloud\",\"Spring核心编程思想\",\"Spring AOP\",\"深入理解Netty\",\"核心原理\",\"精通Java并发\",\"Java并发编程之美\",\"Java并发编程的艺术\",\"深入理解JVM\",\"中间件\",\"MySQL高级教程\",\"MySQL实战45讲\",\"Redis入门\",\"Redis开发与运维\",\"RabbitMQ\",\"RocketMq\",\"C/C++\",\"语言基础 \",\"C++面向对象编程\",\"C++ 11 新特性\",\"核心原理 \",\"C++内存管理\",\"STL源码剖析\",\"跨平台\",\"flutter \",\"flutter实战\",\"部署运维\",\"linux\",\"鸟哥的私房菜\",\"deepin\",\"Linux内核之旅\",\"docker\",\"第一本docker书\",\"Spring Cloud与Docker微服务架构实战\",\"docker compose与docker swarm\",\"必备技能\",\"计算机基础\",\"计算机组成原理\",\"操作系统\",\"编译原理\",\"常用工具\",\"深入理解git\",\"设计模式\",\"高鹏-设计模式\",\"大话设计模式\",\"数据结构和算法\",\"大话数据结构\",\"算法训练营\",\"leetCode\",\"牛客网\",\"相关证书\",\"软件设计师\"]},\"1845\":{\"h\":\"Java学习路线\",\"t\":[\"一入Java深似海。\"]},\"1846\":{\"h\":\"学习路线概览\",\"t\":[\"首先，我先分享下自己对不同学习方式的理解，小伙伴们可以根据自己情况选择。\",\"看视频系统学习，比如培训机构的课程、MOOC的课程等。看视频的好处就是有老师带着，易于理解和掌握，非常适合初学者。\",\"看书学习，如《Redis设计与实现》、《 Java 并发编程的艺术》，便于了解技术脉络和深入学习知识点。\",\"看博客和源码精进学习。博客的好处是有些知识点会以很通俗的方式讲解出来，我们很好理解。\"]},\"1847\":{\"h\":\"第一阶段：Java 基础\",\"t\":[\"最开始要学习的是 Java 基础，学习了这部分，就会对 Java 语言有一个初步的了解。其实大部分语言的基础知识都是大同小异，如果之前已经学习过其他语言如C、C++，那学习这部分会更快。\",\"这部分主要学习的内容有：基本程序结构，类与对象，接口，泛型，反射，集合，异常， Java 网络编程， Java I/O和多线程。对于实习和校招的小伙伴来讲一定要好好学这部分的内容，前面学的越好，后面会越轻松，并且这部分内容面试也经常被问到。\",\"学 Java 基础，推荐大家看尚硅谷宋红康老师的 Java 教程，宋老师的课程更适合零基础学员，从 Java 语言起源开始，循序渐进，知识点剖析细致。\",\"宋老师的 Java 基础教程：https://www.bilibili.com/video/BV1Kb411W75N\",\"除此之外，还可以阅读《 Java 核心技术 卷I》，这本书偏向实用，广度和深度都恰到好处。其中，第7-9章讲述了 Java 的GUI编程， Java 的GUI开发使用并不多，这部分可以先跳过。\",\"网上也有一些不错的文档教程网站，可以辅助学习：\",\"廖雪峰 Java 教程：https://www.liaoxuefeng.com/wiki/1252599548343744\",\"菜鸟教程 Java ：https://www.runoob.com/Java/Java-tutorial.html\",\"当学完了这部分，就可以做个图书管理系统、学生管理系统这样的小项目了。\",\"当然，时间有限的小伙伴，可以不用做这块的项目，直接做 Java Web 项目就好了。\"]},\"1848\":{\"h\":\"第二阶段：LeetCode\",\"t\":[\"学完 Java 基础之后，就可以开始刷算法啦！这部分内容对于想要进好一点的公司的同学来说非常重要，普通公司也有可能会有算法的笔试环节。\",\"好在对于 Java 程序员来说，算法的要求并不算特别高，只要掌握最常用的数据结构以及一些经典的算法题目即可。\",\"由于算法会用到数据结构的相关知识，所以在学习算法之前，我们需要先了解数据结构相关的内容。\"]},\"1849\":{\"h\":\"数据结构\",\"t\":[\"数据结构推荐大家看《大话数据结构》这本书，通俗易懂，内容全面，非常适合入门。\"]},\"1850\":{\"h\":\"算法\",\"t\":[\"直接自己从开始学算法，还是比较吃力的，也难以形成自己的知识体系，了解学习的重难点和掌握合适的学习方法非常重要，这里我推荐极客时间的课程，算法训练营：\",\"算法训练营：https://pan.baidu.com/s/1FRIIC-H5DPVd6Sy8uW-SpA?pwd=h4v2\",\"你也可以按照代码随想录整理的路线刷题：\",\"代码随想录：https://programmercarl.com/\",\"一般来说，应届生一般只要掌握热题100里面的题目即可：\",\"leetcode热题100：https://leetcode.cn/studyplan/top-100-liked/\",\"算法部分并不是要完全学完所有的题目才开始学下一个阶段，而是刷个10来道题目之后，就可以开始下一阶段的学习了。剩下的题目可以在每天开始学其他内容之前，做1-2道题目，保持刷题的节奏感。\",\"算法是学习任何一门编程语言都绕不开的知识，也是最有难度的知识。如果你学的过程中，感到无从下手，看了答案也不知道该怎么做，或者刷了很多题目了，碰到某些题目还是没有任何思路，相信我，这是正常现象，没有人可以一开始，就搞的懂这么难的东西。\",\"你需要做的就是过遍数，不断的过遍数，在面试之前将常考的题目解题思路和代码印在脑子里，形成肌肉记忆，达到基本不怎么用思考，也能把这些题目都顺利的写出来。\",\"刷题过程中，最好做笔记，把题目的解题思路和解法都写一下，方便在面试复习之前刷过的题目。\"]},\"1851\":{\"h\":\"第三阶段：数据库\"},\"1852\":{\"h\":\"MySQL\",\"t\":[\"MySQL 和 Oracle 都是广受企业欢迎的数据库，其中 MySQL 是目前应用最广泛的开源关系数据库，对于新手或者校招的小伙伴，我们目前只学习 MySQL 就可以了。\",\"这部分主要学习的内容有：数据库的CRUD操作、JDBC API、数据库特性和数据库连接池。\",\"其中，数据库连接池是为了避免频繁地创建和销毁 JDBC 连接，常见连接池包括 C3P0，Druid 和 HikariCP，目前使用最广泛的是Druid。\",\"尚硅谷的MySQL入门视频：https://www.bilibili.com/video/BV12b411K7Zu\",\"学完基本知识之后，一定要找一些题目练习一下，巩固成果，下面的SQL问题经常出现在面试当中。\",\"SQL经典练习题（老师、学生、成绩）：https://segmentfault.com/a/1190000022279128\",\"书籍方面，推荐入门的小伙伴看《MySQL必知必会》，是一本小册子，这本书实践性很强，基本没有什么理论的堆砌，非常适合入门。\",\"如果想要深入学习，可以看《高性能 MySQL》，这本书是MySQL领域的经典之作，不过就是太厚了，面试重点看索引部分就可以了。\",\"除此之外，如果要深入学习MySQL的使用和原理，可以看极客时间的专栏《MySQL实战45讲》，阿里资深技术专家讲解的课程，有很多生产经常遇到的问题，非常有深度。\"]},\"1853\":{\"h\":\"Redis\",\"t\":[\"Redis 是一个 key-value 存储系统，是跨平台的非关系型数据库，可用作数据库，高速缓存和消息队列代理。\",\"Redis作为当下主流的缓存技术，已经成为互联网企业的不二首选。\",\"Redis入门到精通课程：https://www.bilibili.com/video/BV1CJ411m7Gc\",\"想深入学习的小伙伴，推荐阅读《Redis设计与实现》，知识点非常丰富，讲了很多底层的原理，我曾经看了三遍，对我面试帮助很大，非常推荐！\",\"Redis 设计与实现在线版：http://redisbook.com/\",\"查询Redis命令的中文网站：https://www.redis.com.cn/tutorial.html\"]},\"1854\":{\"h\":\"第四阶段：Java Web\",\"t\":[\"这一阶段的内容均以了解为主，不作为学习的重点，很少有公司需要前后端都掌握，大概了解每种技术有什么作用即可，可以不用学的特别细致。\"]},\"1855\":{\"h\":\"web前端\",\"t\":[\"前端有三大基础技术 Html、CSS和 Java Script，初学的话，学习这些就可以了。如果想做出更好的交互式效果，可以再学习Vue和React等前端技术。\"]},\"1856\":{\"h\":\"web后端\",\"t\":[\"后端 Java 技术包括 Servlet、Filter、Listener、Session、Cookie、JSP、EL 表达式和 JSTL 等。\",\"其中，像 JSP 这样比较老的技术，目前在各大互联网公司基本不再使用，已经被 Freemark、Thymeleaf 这样的模板引擎所替代，我们只需要了解基本使用即可。\",\"入门 Java Web，推荐尚硅谷的 Java Web 教程，教程不仅包括前端三大技术，还有后端 Java 技术，最后还会带大家做一个书城项目。\",\"Java Web教程：https://www.bilibili.com/video/BV1Y7411K7zz\"]},\"1857\":{\"h\":\"第五阶段：主流框架\",\"t\":[\"这部分我们要学习的主流框架主要有 Spring、Spring MVC 和 MyBatis，俗称 SSM 框架。\",\"曾经的 SSH 框架，即 Struts2、Spring、Hibernate 框架，已经逐渐被 SSM 替代，现在可以不用再学 Struts2 和 Hibernate 框架了。\",\"学习这些框架之前，我们先来学习项目管理利器Maven和Git。\"]},\"1858\":{\"h\":\"Maven\",\"t\":[\"Maven 是一个项目管理工具，它基于项目对象模型(POM)的概念，它可以管理项目的构建、报告和文档。\",\"Maven 本质就是一个巨大的 jar 包资源库，使用 Maven 构建项目，只需在项目的 pom.xml 中配置相关依赖后，就可以直接从远程仓库同步到本地，再也不用满世界搜索下载 jar 包了，省了很多查找和下载的烦恼。\",\"动力结点的Maven实战入门视频：https://www.bilibili.com/video/BV1dp4y1Q7Hf?p=29\"]},\"1859\":{\"h\":\"Git\",\"t\":[\"Git 是一个开源的分布式版本控制系统，最大作用就是对文件进行版本管理，方便在不同版本进行切换修改，还可以很方便的协作开发。\",\"GitHub 是基于 Git 的代码库托管站，学会了 Git ，我们就能愉快地上 Github 交友了。\",\"狂神说的 Git 视频： https://www.bilibili.com/video/BV1FE411P7B3\",\"喜欢文字版的小伙伴，推荐看廖雪峰的 Git 教程，很浅显易懂\",\"廖雪峰的 Git 教程：https://www.liaoxuefeng.com/wiki/896043488029600\",\"方便查阅的 Git 中文手册：https://git-scm.com/book/zh/v2\"]},\"1860\":{\"h\":\"SSM框架\",\"t\":[\"Spring 是一个轻量级的 Java 开发框架，现在已经是最受欢迎的企业级 Java 应用程序开发框架，也是 Java 能在服务端具有统治地位的重要原因之一。\",\"Spring 框架的核心特性是依赖注入(DI)与面向切面编程(AOP)，Spring 框架的组成结构图如下所示：\",\"Spring MVC 是一个基于MVC架构，用来简化web应用程序开发的框架，它是 Spring 的一部分，SpringMVC 已经成为目前最主流的 MVC 框架之一。\",\"MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。\",\"在使用传统JDBC时，往往需要写很多JDBC代码，需要自己写SQL语句以及自己装配参数，然后自己对结果集进行封装处理。\",\"而Mybatis则帮我们简化了以上功能，只需要一些配置文件（xml）或是注解即可完成对数据库的查询以及结果的映射封装。\",\"学习SSM框架，推荐使用一整套课程进行学习，会有更好的连贯性，而且还会学习整合SSM框架。\",\"SSM框架视频：https://www.bilibili.com/video/BV1Tv411b7Dp\",\"整合SSM框架还是比较繁琐的，时间紧张的小伙伴可以不用在整合这里花费时间，因为这种整合方式目前也不在流行了，现在直接使用更强大的利器Spring Boot就可以了。\"]},\"1861\":{\"h\":\"Spring Boot\",\"t\":[\"Spring Boot 采用约定大约配置的方式，大量的减少了配置文件的使用，从而使开发人员不再需要定义样板化的配置。\",\"学习 Spring Boot，推荐雷丰阳老师的 Spring Boot 课程，课程基于 SpringBoot2.3与2.4 版本，包含核心基础、Web原理、单元测试、数据访问、指标监控等章节。\",\"那要不要跳过了 SSM 直接去学习 Spring Boot呢？\",\"如果只是为了使用 Spring Boot，当然可以跳过，毕竟 SSM 配置太繁琐了。\",\"如果想深入学习，尤其是找 Java 开发的工作，面试中会出现很多 Spring 的底层问题，因此还是要学习 SSM 的，如果跳过了不利于学习原理。\",\"雷老师的 Spring Boot 课程：https://www.bilibili.com/video/BV19K4y1L7MT\"]},\"1862\":{\"h\":\"第六阶段：服务器中间件\",\"t\":[\"学完上面的内容，我们已经具备实际项目的开发能力了，但是要解决些复杂的业务场景，我们还要学习MQ、Elasticsearch这些中间件。\"]},\"1863\":{\"h\":\"MQ\",\"t\":[\"MQ（Message Queue）是一种跨进程的通信机制，用于传递消息。通俗点说，就是一个先进先出的数据结构。MQ有三大主要作用分别为解耦、异步、削峰/限流。\",\"目前业界有很多MQ产品，比较出名的有以下四种：\",\"我最开始学习的是Kafka，因为做的项目中使用到了，小伙伴们根据喜好或者项目需要，选择一款MQ学习就可以了。\",\"Kafka 教程：https://www.bilibili.com/video/BV1a4411B7V9\",\"RabbitMQ教程：https://www.bilibili.com/video/BV14A411q7pF\",\"目前企业里用的比较多的是RocketMQ和Kafka。\"]},\"1864\":{\"h\":\"Elasticsearch\",\"t\":[\"全文搜索属于最常见的需求，开源的 Elasticsearch是目前全文搜索引擎的首选，这个作为学习的可选项，因为并不是所有的公司都有全文检索的需求，面试中Elasticsearch出现的概率也不高。\",\"它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。\",\"Elasticsearch的底层是开源库 Lucene。但是，必须自己写代码去调用Lucene的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。\",\"ElasticSearch7.6.x最新完整教程：https://www.bilibili.com/video/BV17a4y1x7zq\"]},\"1865\":{\"h\":\"项目实践\",\"t\":[\"学完了这些，就可以把这些技术整合起来做个项目，这里推荐个我做过的社区论坛项目。\",\"这个论坛项目不仅实现了基本的注册，登录，发帖，评论，点赞，回复功能，同时使用前缀树实现敏感词过滤，使用wkhtmltopdf生成长图和pdf，实现网站UV和DAU统计，并将用户头像等信息存于七牛云服务器。\",\"这是项目使用到的相关技术：\",\"这个项目作为Spring Boot实战练手很不错，老师讲解的很清晰，课程的深度和广度都有，而且课程最后还会手把手教大家将项目部署在云服务器。\",\"课程中也会简要讲解Redis、Kafka和Elasticsearch，即使没有学过这些技术，仍然可以学习这个项目。\",\"社区论坛项目：https://www.bilibili.com/video/BV1AZ4y1u7n3\",\"补充一点，现在的服务器基本都是Linux系统，将项目部署在服务器，学习些基本的Linux命令是必不可少的。\",\"韩顺平 一周学会Linux视频：https://www.bilibili.com/video/BV1Sv411r7vd\",\"Linux命令在线查询：https://wangchujiang.com/linux-command/\"]},\"1866\":{\"h\":\"第七阶段：微服务和分布式\",\"t\":[\"对于实习和校招的小伙伴来讲，学好前五阶段的技术知识，再深入学习个技术点就可以了，如果还有时间和精力的小伙伴，可以学习微服务和分布式的内容。\"]},\"1867\":{\"h\":\"Spring Cloud\",\"t\":[\"Spring Cloud 是一套完整的微服务解决方案，基于 Spring Boot框架。\",\"准确的说，Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性简化了分布式系统的开发，比如服务发现、服务网关、服务路由、链路追踪等。\",\"SpringCloud alibaba框架开发教程：https://www.bilibili.com/video/BV18E411x7eT\"]},\"1868\":{\"h\":\"Dubbo\",\"t\":[\"值得一提的是，还有阿里开源Dubbo，Dubbo一个高性能优秀的服务框架。简单地说，Dubbo是一个基于Spring的RPC（远程过程调用）框架，能够实现服务的远程调用、服务的治理。\",\"至于Spring Cloud 和Dubbo 有什么区别，大家可以搜索下。这里用网络上一个台式电脑的比喻来说就是：Dubbo 是品牌机，Spring Cloud 是组装机。\",\"Dubbo 视频：https://www.bilibili.com/video/BV1Gb411T7Ha\"]},\"1869\":{\"h\":\"ZooKeeper\",\"t\":[\"ZooKeeper是一个高可用的分布式管理与协调框架，基于ZAB算法（原子消息广播协议）的实现。该框架能够保证分布式环境中数据的一致性，使得ZooKeeper成为了解决分布式一致性问题的利器。\",\"zookeeper视频：https://www.bilibili.com/video/BV1M741137qY\"]},\"1870\":{\"h\":\"第八阶段：进阶优化\",\"t\":[\"学会前面这些，我们就可以独立完成一个小项目，独立完成项目组分配给你的开发任务。\",\"但是这还不足以写出好的代码，我们要想写出好的代码，还需要学习设计模式，学习多线程，以及JVM的内部原理等。同样，这些也是面试的必考点。\",\"设计模式的书籍推荐《HeadFirst设计模式》，这是一本图文并茂的书籍，适合入门。\",\"JVM 的书籍推荐《深入理解 Java 虚拟机》，这本书是 Java 开发者必看的书，很多 JVM 的文章都是来自这本书。\",\"Java 并发方面，可以看《 Java 并发编程的艺术》，这本书深入到JVM、CPU层面讲解了 Java 并发框架、线程池的原理等，面对面试足够了；还有《并发编程实战》，这是一本不错的 Java 并发参考手册。\",\"部分视频课程如下：\",\"Java 并发编程视频：https://www.bilibili.com/video/BV16J411h7Rd\",\"JVM教程：https://www.bilibili.com/video/BV1PJ411n7xZ\"]},\"1871\":{\"h\":\"End\",\"t\":[\"以上就是 Java 路线的全部内容了，刚入门的小伙伴可能都看头晕了，觉得好多知识点要学。\",\"Java 技术栈知识的确是多，但只要按部就班、由浅入深的学习就会轻松一些，还会比较有成就感，即先学会用这个技术，再做个系统性的项目把技术融合起来，最后再来看原理部分。\",\"特别感谢：零基础Java学习路线 提供的资料。\"]},\"1872\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"觉得好多知识点要学\",{\"1\":{\"1871\":1}}],[\"刚入门的小伙伴可能都看头晕了\",{\"1\":{\"1871\":1}}],[\"刚好在第\",{\"1\":{\"375\":1}}],[\"独立完成项目组分配给你的开发任务\",{\"1\":{\"1870\":1}}],[\"独占锁\",{\"1\":{\"1373\":1}}],[\"独占\",{\"1\":{\"1367\":2}}],[\"独占获取\",{\"1\":{\"1367\":1}}],[\"远程过程调用\",{\"1\":{\"1868\":1}}],[\"韩顺平\",{\"1\":{\"1865\":1}}],[\"补充一点\",{\"1\":{\"1865\":1}}],[\"点赞\",{\"1\":{\"1865\":1}}],[\"点击foreach方法\",{\"1\":{\"1472\":1}}],[\"点击这个注解进入\",{\"1\":{\"1471\":1}}],[\"点击箭头就会进入到一个接口当中\",{\"1\":{\"1471\":1}}],[\"评论\",{\"1\":{\"1865\":1}}],[\"登录\",{\"1\":{\"1865\":1}}],[\"削峰\",{\"1\":{\"1863\":1}}],[\"雷老师的\",{\"1\":{\"1861\":1}}],[\"毕竟\",{\"1\":{\"1861\":1}}],[\"毕竟覆盖数据\",{\"1\":{\"632\":1}}],[\"课程中也会简要讲解redis\",{\"1\":{\"1865\":1}}],[\"课程的深度和广度都有\",{\"1\":{\"1865\":1}}],[\"课程基于\",{\"1\":{\"1861\":1}}],[\"课程\",{\"1\":{\"1861\":2}}],[\"喜欢文字版的小伙伴\",{\"1\":{\"1859\":1}}],[\"视频\",{\"1\":{\"1859\":1,\"1868\":1}}],[\"视图等\",{\"1\":{\"454\":1}}],[\"狂神说的\",{\"1\":{\"1859\":1}}],[\"动力结点的maven实战入门视频\",{\"1\":{\"1858\":1}}],[\"动态连接\",{\"0\":{\"1680\":1}}],[\"动态链接\",{\"1\":{\"1541\":1}}],[\"动态链接是在程序运行期间完成的将符号引用替换为直接引用\",{\"1\":{\"1540\":1}}],[\"动态代理所创建出来的userservice对象\",{\"1\":{\"1531\":1}}],[\"动态标签解析\",{\"1\":{\"807\":1}}],[\"动态标签会被解析为\",{\"1\":{\"806\":1}}],[\"动态初始化\",{\"1\":{\"329\":1}}],[\"动态规划\",{\"0\":{\"324\":1,\"423\":1},\"1\":{\"293\":1,\"325\":1}}],[\"动态规划则会保存以前的运算结果\",{\"1\":{\"293\":1}}],[\"省了很多查找和下载的烦恼\",{\"1\":{\"1858\":1}}],[\"省略\",{\"1\":{\"1431\":1}}],[\"省略doinit的实现\",{\"1\":{\"1408\":1}}],[\"省略编辑逻辑\",{\"1\":{\"1408\":1}}],[\"省略且实现\",{\"1\":{\"1408\":1}}],[\"省略业务逻辑代码\",{\"1\":{\"1405\":1}}],[\"报告和文档\",{\"1\":{\"1858\":1}}],[\"报主键冲突\",{\"1\":{\"632\":1}}],[\"报主键冲突错误\",{\"1\":{\"631\":1}}],[\"替代\",{\"1\":{\"1857\":1}}],[\"替换为指向数据所存内存的指针或句柄等\",{\"1\":{\"1540\":1}}],[\"替换targetsource\",{\"0\":{\"938\":1}}],[\"替换\",{\"1\":{\"720\":1,\"1497\":1}}],[\"替换key中\",{\"1\":{\"707\":1}}],[\"替换策略\",{\"1\":{\"310\":1}}],[\"曾经的\",{\"1\":{\"1857\":1}}],[\"像\",{\"1\":{\"1856\":1}}],[\"像一些rpc框架还有服务注册中心\",{\"1\":{\"1404\":1}}],[\"初学的话\",{\"1\":{\"1855\":1}}],[\"初始标记\",{\"0\":{\"1610\":1}}],[\"初始状态\",{\"1\":{\"1354\":1}}],[\"初始\",{\"1\":{\"708\":1}}],[\"初始值是1\",{\"1\":{\"605\":1}}],[\"初始的时候\",{\"1\":{\"429\":1}}],[\"初始化事件广播器\",{\"1\":{\"1528\":1}}],[\"初始化国际化相关的内容\",{\"1\":{\"1528\":1}}],[\"初始化cglib策略\",{\"1\":{\"1528\":1}}],[\"初始化cells数组时\",{\"1\":{\"1357\":1}}],[\"初始化后\",{\"1\":{\"1524\":1}}],[\"初始化后阶段\",{\"0\":{\"1169\":1}}],[\"初始化前\",{\"1\":{\"1524\":1}}],[\"初始化前阶段\",{\"0\":{\"1167\":1}}],[\"初始化底层原理\",{\"1\":{\"1507\":1}}],[\"初始化号table之后继续添加元素\",{\"1\":{\"1431\":1}}],[\"初始化流程为\",{\"1\":{\"1431\":1}}],[\"初始化长度为指定值\",{\"1\":{\"1431\":1}}],[\"初始化一个新的entry数组\",{\"1\":{\"1427\":1}}],[\"初始化head和last指针为空值节点\",{\"1\":{\"1380\":1}}],[\"初始化时item指向null\",{\"1\":{\"1380\":1}}],[\"初始化时需要指定容量大小\",{\"1\":{\"1379\":1}}],[\"初始化状态\",{\"1\":{\"1367\":1}}],[\"初始化内建spring事件广播器\",{\"0\":{\"1329\":1}}],[\"初始化内建messagesource\",{\"0\":{\"1328\":1}}],[\"初始化完成阶段\",{\"0\":{\"1170\":1}}],[\"初始化阶段\",{\"0\":{\"1168\":1}}],[\"初始化bean的方式\",{\"0\":{\"1092\":1}}],[\"初始化和注册方法\",{\"0\":{\"863\":1}}],[\"初始化数据后\",{\"1\":{\"596\":1}}],[\"初始化数组的方式\",{\"1\":{\"329\":1}}],[\"初始化插入6个记录\",{\"1\":{\"585\":1}}],[\"初始化sort\",{\"1\":{\"491\":1,\"492\":1,\"555\":1,\"557\":1}}],[\"初始化k前面的元素到堆中\",{\"1\":{\"393\":1}}],[\"初始化\",{\"0\":{\"1165\":1,\"1668\":1},\"1\":{\"326\":1,\"428\":1,\"1524\":2,\"1540\":2}}],[\"讲了很多底层的原理\",{\"1\":{\"1853\":1}}],[\"讲一下内存分配策略\",{\"0\":{\"124\":1}}],[\"想深入学习的小伙伴\",{\"1\":{\"1853\":1}}],[\"阿里资深技术专家讲解的课程\",{\"1\":{\"1852\":1}}],[\"老师讲解的很清晰\",{\"1\":{\"1865\":1}}],[\"老师\",{\"1\":{\"1852\":1}}],[\"巩固成果\",{\"1\":{\"1852\":1}}],[\"尚硅谷的mysql入门视频\",{\"1\":{\"1852\":1}}],[\"刷题过程中\",{\"1\":{\"1850\":1}}],[\"刷新store\",{\"1\":{\"1350\":1}}],[\"碰到某些题目还是没有任何思路\",{\"1\":{\"1850\":1}}],[\"碰到需要用日志恢复数据的场景是不是很少\",{\"1\":{\"464\":1}}],[\"感到无从下手\",{\"1\":{\"1850\":1}}],[\"项目实践\",{\"0\":{\"1865\":1}}],[\"项目就好了\",{\"1\":{\"1847\":1}}],[\"项目中有用过设计模式吗\",{\"0\":{\"272\":1}}],[\"菜鸟教程\",{\"1\":{\"1847\":1}}],[\"廖雪峰的\",{\"1\":{\"1859\":1}}],[\"廖雪峰\",{\"1\":{\"1847\":1}}],[\"卷i\",{\"1\":{\"1847\":1}}],[\"宋老师的\",{\"1\":{\"1847\":1}}],[\"宋老师的课程更适合零基础学员\",{\"1\":{\"1847\":1}}],[\"循序渐进\",{\"1\":{\"1847\":1}}],[\"循环依赖解析\",{\"0\":{\"1526\":1}}],[\"循环列表\",{\"1\":{\"1490\":1}}],[\"循环复制问题\",{\"0\":{\"592\":1}}],[\"循环遍历这100行数据\",{\"1\":{\"538\":1}}],[\"循环结束\",{\"1\":{\"474\":1,\"487\":2}}],[\"循环判断当前队首是否在窗口中\",{\"1\":{\"393\":1}}],[\"循环每行的每一列\",{\"1\":{\"329\":1}}],[\"循环每一行\",{\"1\":{\"329\":1}}],[\"教程不仅包括前端三大技术\",{\"1\":{\"1856\":1}}],[\"教程\",{\"1\":{\"1847\":2,\"1856\":1,\"1859\":2,\"1863\":1}}],[\"博客的好处是有些知识点会以很通俗的方式讲解出来\",{\"1\":{\"1846\":1}}],[\"便于了解技术脉络和深入学习知识点\",{\"1\":{\"1846\":1}}],[\"易于理解和掌握\",{\"1\":{\"1846\":1}}],[\"软件设计师\",{\"1\":{\"1844\":1}}],[\"软考通\",{\"1\":{\"6\":1}}],[\"牛客网\",{\"1\":{\"1844\":1}}],[\"鸟哥的私房菜\",{\"1\":{\"1844\":1}}],[\"部署运维\",{\"1\":{\"1844\":1}}],[\"部分视频课程如下\",{\"1\":{\"1870\":1}}],[\"部分累积的结果与一个空的结果容器运算之后还是它本身\",{\"1\":{\"1492\":1}}],[\"部分线程栈和堆可能有时候会出现在cpu缓存中和cpu内部的寄存器中\",{\"1\":{\"1350\":1}}],[\"部分\",{\"0\":{\"900\":1}}],[\"部分复制\",{\"0\":{\"753\":1}}],[\"跨平台\",{\"1\":{\"1844\":1}}],[\"精通java并发\",{\"1\":{\"1844\":1}}],[\"精确\",{\"1\":{\"609\":1}}],[\"剖析\",{\"1\":{\"1843\":1}}],[\"云原生时代\",{\"1\":{\"1843\":1}}],[\"云原生时代的java虚拟机\",{\"0\":{\"1552\":1}}],[\"键查询消息\",{\"0\":{\"1802\":1}}],[\"键值对\",{\"1\":{\"1422\":1,\"1423\":2}}],[\"键值对并设置过期时间\",{\"1\":{\"707\":1}}],[\"偏移量\",{\"0\":{\"1796\":1}}],[\"偏向线程id\",{\"1\":{\"1361\":1}}],[\"偏向时间戳等\",{\"1\":{\"1361\":1}}],[\"偏向时间\",{\"1\":{\"1361\":1}}],[\"偏向锁撤销存在性能问题\",{\"1\":{\"1366\":1}}],[\"偏向锁重偏向一次之后不可再次重偏向\",{\"1\":{\"1362\":1}}],[\"偏向锁不仅不能提高性能\",{\"1\":{\"1362\":1}}],[\"偏向锁带来的性能开销基本可以忽略\",{\"1\":{\"1362\":1}}],[\"偏向锁模式存在偏向锁延迟机制\",{\"1\":{\"1362\":1}}],[\"偏向锁有很好的优化效果\",{\"1\":{\"1362\":1}}],[\"偏向锁是一种针对加锁操作的优化手段\",{\"1\":{\"1362\":1}}],[\"偏向锁\",{\"0\":{\"73\":1,\"1362\":1,\"1702\":1},\"1\":{\"1360\":1,\"1361\":2}}],[\"广度和深度都恰到好处\",{\"1\":{\"1847\":1}}],[\"广度优先遍历解法\",{\"1\":{\"396\":1}}],[\"广度优先搜索\",{\"0\":{\"297\":1}}],[\"广播模式\",{\"0\":{\"1769\":1,\"1776\":1}}],[\"广播消息\",{\"0\":{\"1709\":1}}],[\"附加信息\",{\"0\":{\"1682\":1}}],[\"附近的人功能\",{\"1\":{\"713\":1}}],[\"破坏双亲委派模型\",{\"0\":{\"1672\":1}}],[\"破坏了事务逻辑的隔离性\",{\"1\":{\"597\":1}}],[\"魔数与class文件的版本\",{\"0\":{\"1654\":1}}],[\"停顿预测模型\",{\"0\":{\"1625\":1}}],[\"停止线程\",{\"1\":{\"1354\":1}}],[\"停止\",{\"1\":{\"618\":1}}],[\"顶层组件\",{\"1\":{\"1561\":2}}],[\"顶上来\",{\"1\":{\"758\":1}}],[\"划分内存的方法\",{\"0\":{\"1545\":1}}],[\"局部变量表\",{\"0\":{\"1678\":1},\"1\":{\"1541\":1}}],[\"局部变量方案的缺点是在高并发场景下会频繁创建对象\",{\"1\":{\"1405\":1}}],[\"沙箱安全机制\",{\"1\":{\"1540\":1,\"1570\":1}}],[\"符号引用\",{\"1\":{\"1540\":1}}],[\"校验权限\",{\"0\":{\"1832\":1}}],[\"校验字节码文件的正确性\",{\"1\":{\"1540\":1}}],[\"校验不通过直接打回\",{\"1\":{\"764\":1}}],[\"卸载\",{\"1\":{\"1540\":1}}],[\"验证\",{\"0\":{\"1665\":1},\"1\":{\"1540\":2}}],[\"呈现视图之前调用\",{\"1\":{\"1534\":1}}],[\"供子类调用\",{\"1\":{\"1528\":1}}],[\"供生产者与消费者使用\",{\"1\":{\"1397\":1}}],[\"添三个beanpostprocessor\",{\"1\":{\"1528\":1}}],[\"添加扩展字段\",{\"0\":{\"1830\":1}}],[\"添加消息\",{\"0\":{\"1799\":1}}],[\"添加配置类\",{\"1\":{\"1535\":1}}],[\"添加三个单例bean\",{\"1\":{\"1528\":1}}],[\"添加了设置父beanfactory\",{\"1\":{\"1513\":1}}],[\"添加了获取父beanfactory的功能\",{\"1\":{\"1513\":1}}],[\"添加到的最终的结果thelist1当中\",{\"1\":{\"1485\":1}}],[\"添加成功返回true\",{\"1\":{\"1377\":2}}],[\"添加一个元素\",{\"1\":{\"1377\":2}}],[\"添加一个word\",{\"1\":{\"302\":1}}],[\"添加方法的源代码\",{\"1\":{\"1357\":1}}],[\"添加效率会比linkedlist低\",{\"1\":{\"1352\":1}}],[\"添加元素和获取元素都有独立的锁\",{\"1\":{\"1380\":1}}],[\"添加元素效率的对比\",{\"1\":{\"1352\":1}}],[\"添加元素\",{\"1\":{\"714\":1}}],[\"添加指定元素到\",{\"1\":{\"714\":1}}],[\"添加参数gtid\",{\"1\":{\"605\":1}}],[\"添加索引\",{\"1\":{\"578\":1}}],[\"添加\",{\"1\":{\"333\":1,\"334\":1}}],[\"添加多级索引\",{\"1\":{\"330\":1}}],[\"添加第二级索引\",{\"1\":{\"330\":1}}],[\"添加第一级索引\",{\"1\":{\"330\":1}}],[\"于此同时\",{\"1\":{\"1528\":1}}],[\"于是它可以再次发送read操作\",{\"1\":{\"1441\":1}}],[\"于是整个类的所有对象都会变为不可偏向的\",{\"1\":{\"1362\":1}}],[\"于是\",{\"1\":{\"1362\":1,\"1423\":1}}],[\"于是线程就进入了一个死循环\",{\"1\":{\"740\":1}}],[\"于是得到了\",{\"1\":{\"615\":1}}],[\"于是此时优化器选了只需要扫描1000行的索引a\",{\"1\":{\"485\":1}}],[\"于是就进入了执行器阶段\",{\"1\":{\"459\":1}}],[\"额外辅助\",{\"1\":{\"1526\":1}}],[\"额外的故意等待\",{\"1\":{\"588\":1}}],[\"填充属性\",{\"1\":{\"1524\":1}}],[\"填充数据不是必须存在的\",{\"1\":{\"1361\":1}}],[\"抽象基类abstractprotocol实现了protocolhandler接口\",{\"1\":{\"1565\":1}}],[\"抽象的beandifition表示beandifition之间有父子关系\",{\"1\":{\"1524\":1}}],[\"抽象工厂模式\",{\"0\":{\"995\":1}}],[\"资源加载器\",{\"1\":{\"1514\":1}}],[\"资源在内存中的地址是变化的\",{\"1\":{\"1438\":1}}],[\"框架之一\",{\"1\":{\"1860\":1}}],[\"框架的组成结构图如下所示\",{\"1\":{\"1860\":1}}],[\"框架的核心特性是依赖注入\",{\"1\":{\"1860\":1}}],[\"框架的这种修改可能出现这些不确定的结果\",{\"1\":{\"1497\":1}}],[\"框架了\",{\"1\":{\"1857\":1}}],[\"框架\",{\"1\":{\"1857\":3,\"1868\":1}}],[\"框架源码分析\",{\"0\":{\"1505\":1}}],[\"阶段\",{\"1\":{\"1498\":1}}],[\"抛出illegalstateexception异常\",{\"1\":{\"1497\":1}}],[\"抛出异常\",{\"1\":{\"1378\":2,\"1532\":1}}],[\"剩余的元素是由当前的spliterator继续涵盖的\",{\"1\":{\"1497\":1}}],[\"剩下的题目可以在每天开始学其他内容之前\",{\"1\":{\"1850\":1}}],[\"剩下的数据何时才应该续写\",{\"1\":{\"740\":1}}],[\"剩下的操作都是在sort\",{\"1\":{\"492\":1}}],[\"剩下的字符够k个\",{\"1\":{\"384\":1}}],[\"知识点非常丰富\",{\"1\":{\"1853\":1}}],[\"知识点剖析细致\",{\"1\":{\"1847\":1}}],[\"知识储备\",{\"0\":{\"898\":1}}],[\"知道所有的元素都已经被处理了\",{\"1\":{\"1497\":1}}],[\"太小了\",{\"1\":{\"1497\":1}}],[\"太少的线程数会使得程序整体性能降低\",{\"1\":{\"1387\":1}}],[\"块的遍历方法\",{\"1\":{\"1497\":1}}],[\"期望可以文档化\",{\"1\":{\"1497\":1}}],[\"期望将\",{\"1\":{\"1431\":1}}],[\"形成肌肉记忆\",{\"1\":{\"1850\":1}}],[\"形成另外的spliterator\",{\"1\":{\"1497\":1}}],[\"形成一个循环\",{\"1\":{\"1452\":1}}],[\"固定大小\",{\"1\":{\"1497\":1}}],[\"固定生成连续的id的值\",{\"1\":{\"629\":1}}],[\"他会将\",{\"1\":{\"1535\":1}}],[\"他也有可能返回自己\",{\"1\":{\"1496\":1}}],[\"他们的执行顺序是由一个比较器来决定的\",{\"1\":{\"1531\":1}}],[\"他们并不需要特殊的资源管理\",{\"1\":{\"1496\":1}}],[\"他们必须是冲突非干扰的\",{\"1\":{\"1496\":1}}],[\"他们必须依附于一类特别的对象\",{\"1\":{\"1470\":1}}],[\"他们有一些相似性\",{\"1\":{\"1496\":1}}],[\"他们都被称之为stream\",{\"1\":{\"1496\":1}}],[\"他们可以使用相同的可以并发修改的结果容器\",{\"1\":{\"1492\":1}}],[\"他们可以看成是前面几个函数式接口的扩展\",{\"1\":{\"1477\":1}}],[\"他们包含了相同的元素\",{\"1\":{\"1492\":1}}],[\"派生\",{\"1\":{\"1496\":1}}],[\"遵循stream的相关约束\",{\"1\":{\"1496\":1}}],[\"遵循获取写锁\",{\"1\":{\"1375\":1}}],[\"偶发的情况下就会出现并发修改的异常\",{\"1\":{\"1494\":1}}],[\"忽略了顺序\",{\"1\":{\"1492\":1}}],[\"忽略掉流中的前两个元素之后\",{\"1\":{\"1487\":1}}],[\"毫无疑问\",{\"1\":{\"1492\":1}}],[\"拥有国际化功能\",{\"1\":{\"1514\":1}}],[\"拥有广播事件的功能\",{\"1\":{\"1514\":1}}],[\"拥有获取beannames的功能\",{\"1\":{\"1514\":1}}],[\"拥有获取父beanfactory的功能\",{\"1\":{\"1514\":1}}],[\"拥有了自动装配的功能\",{\"1\":{\"1513\":1}}],[\"拥有了直接注册\",{\"1\":{\"1513\":1}}],[\"拥有唯一的抽象方法compare\",{\"1\":{\"1491\":1}}],[\"拥有thread的workqueue只能出现在workqueues\",{\"1\":{\"1390\":1}}],[\"达到基本不怎么用思考\",{\"1\":{\"1850\":1}}],[\"达到该值就会触发full\",{\"1\":{\"1541\":1}}],[\"达到相互促进的作用\",{\"1\":{\"1490\":1}}],[\"达到上限后\",{\"1\":{\"632\":1}}],[\"学好前五阶段的技术知识\",{\"1\":{\"1866\":1}}],[\"学生\",{\"1\":{\"1852\":1}}],[\"学生管理系统这样的小项目了\",{\"1\":{\"1847\":1}}],[\"学完了这些\",{\"1\":{\"1865\":1}}],[\"学完上面的内容\",{\"1\":{\"1862\":1}}],[\"学完基本知识之后\",{\"1\":{\"1852\":1}}],[\"学完\",{\"1\":{\"1848\":1}}],[\"学\",{\"1\":{\"1847\":1}}],[\"学习多线程\",{\"1\":{\"1870\":1}}],[\"学习些基本的linux命令是必不可少的\",{\"1\":{\"1865\":1}}],[\"学习\",{\"1\":{\"1861\":1}}],[\"学习ssm框架\",{\"1\":{\"1860\":1}}],[\"学习这些框架之前\",{\"1\":{\"1857\":1}}],[\"学习这些就可以了\",{\"1\":{\"1855\":1}}],[\"学习这些例子\",{\"1\":{\"1495\":1}}],[\"学习了这部分\",{\"1\":{\"1847\":1}}],[\"学习路线概览\",{\"0\":{\"1846\":1}}],[\"学习jdk中优秀的源码\",{\"1\":{\"1490\":1}}],[\"学会前面这些\",{\"1\":{\"1870\":1}}],[\"学会了\",{\"1\":{\"1859\":1}}],[\"学会使用是第一步也是非常重要的一步\",{\"1\":{\"1490\":1}}],[\"学会新的api使用\",{\"1\":{\"1484\":1}}],[\"掌握本章及之前的内容对于一般的开发者\",{\"1\":{\"1490\":1}}],[\"掌握其中一门的设计理念与思想\",{\"1\":{\"1468\":1}}],[\"种子\",{\"1\":{\"1486\":1}}],[\"种连接顺序\",{\"1\":{\"693\":1}}],[\"串行操作\",{\"1\":{\"1492\":1}}],[\"串行的实现\",{\"1\":{\"1500\":1}}],[\"串行的方式\",{\"1\":{\"1500\":1}}],[\"串行的\",{\"1\":{\"1486\":1}}],[\"串行化\",{\"1\":{\"570\":2,\"669\":1}}],[\"串行化是指对同一行记录\",{\"1\":{\"570\":1}}],[\"举个例子\",{\"1\":{\"1486\":2,\"1496\":1}}],[\"举一个这样的例子\",{\"1\":{\"1486\":1}}],[\"举例装饰器模式和代理模式的区别\",{\"0\":{\"1015\":1}}],[\"举例来说\",{\"1\":{\"627\":1}}],[\"映射成整型值\",{\"1\":{\"1500\":1}}],[\"映射阶段会消耗字符串集合\",{\"1\":{\"1500\":1}}],[\"映射\",{\"1\":{\"1485\":1,\"1500\":2,\"1535\":1}}],[\"及早求值\",{\"1\":{\"1484\":1}}],[\"惰性求值\",{\"1\":{\"1484\":1}}],[\"源码\",{\"1\":{\"1843\":1}}],[\"源码的实现如下\",{\"1\":{\"1425\":1}}],[\"源数据才会被消费\",{\"1\":{\"1498\":1}}],[\"源的意思就是要操作的数据对象\",{\"1\":{\"1484\":1}}],[\"源\",{\"1\":{\"1484\":1}}],[\"恰好满足了lambda表达式的要求\",{\"1\":{\"1480\":1}}],[\"叫做方法引用\",{\"1\":{\"1479\":1}}],[\"断言的意思\",{\"1\":{\"1476\":1}}],[\"断开连接\",{\"1\":{\"455\":1}}],[\"阐明\",{\"1\":{\"1476\":1}}],[\"四则运算正好就是输入两个参数\",{\"1\":{\"1475\":1}}],[\"四种线程同步互斥的控制方法\",{\"1\":{\"1354\":1}}],[\"程序员来说\",{\"1\":{\"1848\":1}}],[\"程序员友好程度\",{\"1\":{\"1453\":1}}],[\"程序计数器\",{\"0\":{\"1580\":1}}],[\"程序运行过程中\",{\"1\":{\"1541\":1}}],[\"程序运行的结果如下\",{\"1\":{\"1494\":1}}],[\"程序运行的效果是完全等价的\",{\"1\":{\"1472\":1}}],[\"程序不再往下执行\",{\"1\":{\"1497\":1}}],[\"程序将一直运行下去\",{\"1\":{\"1486\":1}}],[\"箭头左边的部分\",{\"1\":{\"1472\":1}}],[\"诸多的函数式接口\",{\"1\":{\"1471\":1}}],[\"诸如存储引擎的锁\",{\"1\":{\"525\":1}}],[\"追踪下去\",{\"1\":{\"1470\":1}}],[\"追加写\",{\"1\":{\"462\":1,\"464\":1}}],[\"获得消耗的时间\",{\"1\":{\"1468\":2}}],[\"获取请求网络字节流\",{\"1\":{\"1565\":1}}],[\"获取\",{\"1\":{\"1532\":1}}],[\"获取给定包路径下面的class文件的resource对象\",{\"1\":{\"1524\":1}}],[\"获取一个annotationmetadata\",{\"1\":{\"1523\":1}}],[\"获取某个单例bean的功能\",{\"1\":{\"1513\":1}}],[\"获取某个单例bean\",{\"1\":{\"1513\":1}}],[\"获取某个beandefinition\",{\"1\":{\"1513\":1}}],[\"获取环境变量等功能\",{\"1\":{\"1513\":1}}],[\"获取执行后的毫秒值\",{\"1\":{\"1468\":2}}],[\"获取执行前的毫秒值\",{\"1\":{\"1468\":2}}],[\"获取最快返回的任务执行结果\",{\"1\":{\"1394\":1}}],[\"获取电商s2报价并异步保存\",{\"1\":{\"1394\":1}}],[\"获取电商s1报价并异步保存\",{\"1\":{\"1394\":1}}],[\"获取队首元素\",{\"1\":{\"1377\":1,\"1378\":1}}],[\"获取写锁\",{\"1\":{\"1375\":1}}],[\"获取了写锁并修改了数据\",{\"1\":{\"1375\":1}}],[\"获取静态变量i的值\",{\"1\":{\"1359\":2}}],[\"获取物理内存容量\",{\"0\":{\"789\":1}}],[\"获取连接对象\",{\"1\":{\"720\":1}}],[\"获取第2位的数值\",{\"1\":{\"715\":1}}],[\"获取offset位的值\",{\"1\":{\"715\":1}}],[\"获取成员经纬坐标的geohash表示\",{\"1\":{\"713\":1}}],[\"获取成员m1的索引\",{\"1\":{\"711\":1}}],[\"获取成员m1的score\",{\"1\":{\"711\":1}}],[\"获取全部成员\",{\"1\":{\"711\":1}}],[\"获取全部元素\",{\"1\":{\"708\":1}}],[\"获取索引在\",{\"1\":{\"711\":1}}],[\"获取spring\",{\"1\":{\"1532\":1}}],[\"获取score在\",{\"1\":{\"711\":1}}],[\"获取studentx中所有的field及其value\",{\"1\":{\"710\":1}}],[\"获取studentx中name\",{\"1\":{\"710\":1}}],[\"获取studentx中name字段的value\",{\"1\":{\"710\":1}}],[\"获取有序集合的成员数\",{\"1\":{\"711\":2}}],[\"获取哈希表中所有值\",{\"1\":{\"710\":1}}],[\"获取哈希表中字段的数量\",{\"1\":{\"710\":1}}],[\"获取哈希表key中所有的字段\",{\"1\":{\"710\":1}}],[\"获取哈希函数输出的\",{\"1\":{\"307\":1}}],[\"获取在哈希表key\",{\"1\":{\"710\":1}}],[\"获取所有给定字段的值\",{\"1\":{\"710\":1}}],[\"获取存储在哈希表中指定字段的值\",{\"1\":{\"710\":1}}],[\"获取集合中的一个\",{\"1\":{\"713\":1}}],[\"获取集合中所有成员\",{\"1\":{\"709\":1}}],[\"获取集合的成员数目\",{\"1\":{\"709\":1}}],[\"获取集合的成员数\",{\"1\":{\"709\":1}}],[\"获取下标为3的元素\",{\"1\":{\"708\":1}}],[\"获取起止位置范围内的元素\",{\"1\":{\"708\":1}}],[\"获取list\",{\"1\":{\"708\":1}}],[\"获取原来的值\",{\"1\":{\"707\":1}}],[\"获取key保存值的字符串长度\",{\"1\":{\"707\":1}}],[\"获取表t当前的自增值2\",{\"1\":{\"628\":1}}],[\"获取表t2中满足条件的2000行数据\",{\"1\":{\"545\":1}}],[\"获取把一个表的主键删掉了\",{\"1\":{\"557\":1}}],[\"获取超过需要的数据也可能有其好处\",{\"1\":{\"522\":1}}],[\"获取权限\",{\"1\":{\"455\":1,\"619\":1}}],[\"获取当前数字对应的字符值\",{\"1\":{\"400\":1}}],[\"瞬间代码的易读性提高了很多\",{\"1\":{\"1468\":1}}],[\"少了内存文件映射步骤\",{\"1\":{\"1462\":1}}],[\"少了用户缓冲区与内核缓冲区的数据拷贝\",{\"1\":{\"1462\":1}}],[\"少用or\",{\"1\":{\"506\":1}}],[\"特性\",{\"0\":{\"1713\":1},\"1\":{\"1524\":1}}],[\"特性值\",{\"1\":{\"1500\":1}}],[\"特化的管道类\",{\"1\":{\"1498\":1}}],[\"特化的版本\",{\"1\":{\"1496\":1}}],[\"特定对象的实例方法引用\",{\"1\":{\"1479\":1}}],[\"特点\",{\"1\":{\"1462\":1}}],[\"特别感谢\",{\"1\":{\"1871\":1}}],[\"特别是公共资源有限的应用场景\",{\"1\":{\"1373\":1}}],[\"特别说明\",{\"1\":{\"565\":1}}],[\"缓冲区之间建立管道来传输数据\",{\"1\":{\"1461\":1}}],[\"缓存好的构造方法和参数值\",{\"1\":{\"1527\":1}}],[\"缓存beandefition的属性\",{\"1\":{\"1527\":1}}],[\"缓存行是2的整数幂个连续字节\",{\"1\":{\"1396\":1}}],[\"缓存一致性的要求\",{\"1\":{\"1351\":1}}],[\"缓存一致性是确保共享操作数\",{\"1\":{\"1351\":1}}],[\"缓存一致性是共享资源数据的一致性\",{\"1\":{\"1351\":1}}],[\"缓存一致性\",{\"0\":{\"1351\":1}}],[\"缓存锁定将大大降低lock前缀指令的执行开销\",{\"1\":{\"1350\":1}}],[\"缓存中的应用\",{\"0\":{\"1023\":1}}],[\"缓存空对象\",{\"1\":{\"764\":1}}],[\"缓存都没有命中的话\",{\"1\":{\"763\":1}}],[\"缓存系统可能会丢失更新\",{\"1\":{\"534\":1}}],[\"缓存穿透\",{\"0\":{\"135\":1,\"762\":1}}],[\"缓存雪崩\",{\"0\":{\"134\":1,\"137\":1,\"768\":1}}],[\"缓存击穿的目的性更强\",{\"1\":{\"766\":1}}],[\"缓存击穿\",{\"0\":{\"134\":1,\"136\":1,\"765\":1}}],[\"控制流程\",{\"1\":{\"1500\":1}}],[\"控制台就会打印十次\",{\"1\":{\"1494\":1}}],[\"控制台会打印什么呢\",{\"1\":{\"1489\":1}}],[\"控制台会打印出以下结果\",{\"1\":{\"1477\":1}}],[\"控制台在输出了0\",{\"1\":{\"1487\":1}}],[\"控制台输出\",{\"1\":{\"1469\":1,\"1494\":1,\"1496\":2}}],[\"控制器支持\",{\"1\":{\"1460\":1}}],[\"控制innodb的并发线程上限\",{\"1\":{\"613\":1}}],[\"技术栈知识的确是多\",{\"1\":{\"1871\":1}}],[\"技术包括\",{\"1\":{\"1856\":1}}],[\"技术架构\",{\"0\":{\"1718\":1}}],[\"技术\",{\"1\":{\"1460\":2,\"1856\":1}}],[\"技能点\",{\"0\":{\"8\":1}}],[\"次数据拷贝都是\",{\"1\":{\"1460\":1}}],[\"次用户态和内核态的切换\",{\"1\":{\"1459\":1,\"1460\":1,\"1461\":1}}],[\"次\",{\"1\":{\"1459\":2,\"1460\":2,\"1461\":2}}],[\"站在操作系统的角度\",{\"1\":{\"1453\":1}}],[\"零基础java学习路线\",{\"1\":{\"1871\":1}}],[\"零个或多个中间操作\",{\"1\":{\"1484\":1}}],[\"零\",{\"1\":{\"1453\":1}}],[\"零拷贝所有的方式\",{\"1\":{\"1462\":1}}],[\"零拷贝流程\",{\"0\":{\"1461\":1}}],[\"零拷贝并不是不需要拷贝数据\",{\"1\":{\"1453\":1}}],[\"零拷贝就是不需要将数据从一个存储区域复制到另一个存储区域\",{\"1\":{\"1453\":1}}],[\"零拷贝从字面上来看包含两个意思\",{\"1\":{\"1453\":1}}],[\"零拷贝实现原理\",{\"0\":{\"855\":1}}],[\"零拷贝\",{\"0\":{\"853\":1}}],[\"拷贝数据\",{\"1\":{\"1464\":1,\"1465\":1}}],[\"拷贝数据效率慢\",{\"1\":{\"1462\":1}}],[\"拷贝数据到临时表\",{\"1\":{\"568\":1}}],[\"拷贝机制\",{\"1\":{\"1462\":1}}],[\"拷贝机制对比的结果如下\",{\"1\":{\"1462\":1}}],[\"拷贝操作\",{\"1\":{\"1461\":1}}],[\"拷贝加入了\",{\"1\":{\"1460\":1}}],[\"拷贝流程\",{\"0\":{\"1460\":1},\"1\":{\"1459\":1,\"1460\":1,\"1461\":1}}],[\"拷贝次数和切换次数比预期的还要多\",{\"1\":{\"1457\":1}}],[\"拷贝到用户缓冲区\",{\"1\":{\"1457\":1}}],[\"拷贝\",{\"1\":{\"1453\":1,\"1459\":2,\"1460\":4,\"1461\":2}}],[\"差\",{\"1\":{\"1453\":1}}],[\"差值\",{\"1\":{\"491\":1}}],[\"伪代码可能是这样的\",{\"1\":{\"1488\":1}}],[\"伪异步i\",{\"1\":{\"1453\":1}}],[\"伪共享\",{\"1\":{\"1396\":3}}],[\"收集过程\",{\"0\":{\"1628\":1}}],[\"收集器是我们认识整个stream的第一步\",{\"1\":{\"1495\":1}}],[\"收集器是被设计成可以组合的\",{\"1\":{\"1492\":1}}],[\"收集器\",{\"1\":{\"1492\":1}}],[\"收到客户端消息\",{\"1\":{\"1450\":1,\"1451\":1,\"1452\":1}}],[\"收益就越大\",{\"1\":{\"481\":1}}],[\"真实io\",{\"1\":{\"1444\":2}}],[\"真正执行的时候\",{\"1\":{\"1531\":1}}],[\"真正执行传入lambda表达式的地方\",{\"1\":{\"1499\":1}}],[\"真正使用该代理对象时才进行类型筛选bean\",{\"1\":{\"1525\":1}}],[\"真正在创建的时候又是调用了referencepipeline的构造方法\",{\"1\":{\"1498\":1}}],[\"真正的零拷贝\",{\"1\":{\"1462\":2}}],[\"真正唤醒消费者线程\",{\"1\":{\"1380\":2}}],[\"真正唤醒生产者线程\",{\"1\":{\"1380\":1}}],[\"真正模拟主库并发度\",{\"1\":{\"601\":1}}],[\"真正更新日志的\",{\"1\":{\"597\":1}}],[\"告诉它read操作完成了\",{\"1\":{\"1443\":1}}],[\"立刻就可以开始去做其它的事\",{\"1\":{\"1443\":1}}],[\"句柄\",{\"1\":{\"1438\":1}}],[\"句柄是资源在创建过程中由windows赋予的\",{\"1\":{\"1438\":1}}],[\"杏花村\",{\"1\":{\"1438\":2}}],[\"杏花村可以搬家\",{\"1\":{\"1438\":1}}],[\"杏花村酒店为对象的实例\",{\"1\":{\"1438\":1}}],[\"杏花村的牌子为句柄\",{\"1\":{\"1438\":1}}],[\"牧童的手为指针\",{\"1\":{\"1438\":1}}],[\"抢到了锁\",{\"1\":{\"1431\":1}}],[\"冲突就会大于1\",{\"1\":{\"1431\":1}}],[\"冲突\",{\"1\":{\"1431\":1}}],[\"懒加载的方式\",{\"1\":{\"1431\":1}}],[\"懒汉式\",{\"0\":{\"274\":1}}],[\"旧链表迁移新链表的时候\",{\"1\":{\"1427\":1}}],[\"均匀的把之前的冲突节点分散到新的bucket了\",{\"1\":{\"1427\":1}}],[\"质量来考虑的\",{\"1\":{\"1425\":1}}],[\"功效\",{\"1\":{\"1425\":1}}],[\"功能\",{\"1\":{\"1386\":1,\"1571\":1}}],[\"功能概述\",{\"0\":{\"913\":1}}],[\"功能与georadius相同\",{\"1\":{\"713\":1}}],[\"具有更高的效率\",{\"1\":{\"1425\":1}}],[\"具体协议的实现类扩展了协议层抽象基类\",{\"1\":{\"1565\":1}}],[\"具体考虑下面这个pipeline\",{\"1\":{\"1500\":1}}],[\"具体底层怎么做完全不用关心\",{\"1\":{\"1488\":1}}],[\"具体叫什么名字\",{\"1\":{\"1472\":1}}],[\"具体采用哪种方式\",{\"1\":{\"1462\":1}}],[\"具体实现类特点的说明\",{\"1\":{\"1421\":1}}],[\"具体可以参考红黑树\",{\"1\":{\"1423\":1}}],[\"具体可以参考\",{\"1\":{\"738\":1,\"1423\":1}}],[\"具体查询多少次取决于对被驱动表查询的结果集中有多少条记录\",{\"1\":{\"691\":1}}],[\"具体如下图\",{\"1\":{\"679\":1,\"1540\":1}}],[\"具体如下图所示\",{\"1\":{\"598\":1}}],[\"具体情况是\",{\"1\":{\"627\":1}}],[\"具体恢复数据时\",{\"1\":{\"621\":1}}],[\"具体过程如下图\",{\"1\":{\"613\":1}}],[\"具体的实现如下\",{\"1\":{\"1500\":1}}],[\"具体的行为在调用的时候再传入\",{\"1\":{\"1476\":1}}],[\"具体的采样页面数量\",{\"1\":{\"695\":2}}],[\"具体的操作流程如下\",{\"1\":{\"634\":1}}],[\"具体的方案就是\",{\"1\":{\"608\":1}}],[\"具体的执行结果如下\",{\"1\":{\"583\":1}}],[\"具体使用哪一种\",{\"1\":{\"570\":1}}],[\"具体指运行时间超过long\",{\"1\":{\"565\":1}}],[\"具体流程下\",{\"1\":{\"550\":1}}],[\"具体是通过完全二叉树实现的小顶堆\",{\"1\":{\"353\":1}}],[\"具体来说\",{\"1\":{\"343\":1,\"461\":1}}],[\"吉永超\",{\"1\":{\"1423\":1}}],[\"场景三\",{\"1\":{\"1413\":1}}],[\"场景二\",{\"1\":{\"1413\":1}}],[\"场景一\",{\"1\":{\"1413\":1}}],[\"挂起模式\",{\"1\":{\"1407\":1}}],[\"挂起操作涉及系统调用\",{\"1\":{\"1362\":1}}],[\"路线的全部内容了\",{\"1\":{\"1871\":1}}],[\"路由表是典型的读多写少\",{\"1\":{\"1404\":1}}],[\"路径总和\",{\"0\":{\"412\":1}}],[\"路径上经过的字符连接起来\",{\"1\":{\"301\":1}}],[\"好方便后续的相关操作\",{\"1\":{\"1528\":1}}],[\"好在对于\",{\"1\":{\"1848\":1}}],[\"好在jdk为我们提供了另一种方式来完成\",{\"1\":{\"1484\":1}}],[\"好在随着自动垃圾回收\",{\"1\":{\"1404\":1}}],[\"好的索引可以让查询使用合适的访问类型\",{\"1\":{\"527\":1}}],[\"推荐雷丰阳老师的\",{\"1\":{\"1861\":1}}],[\"推荐使用一整套课程进行学习\",{\"1\":{\"1860\":1}}],[\"推荐看廖雪峰的\",{\"1\":{\"1859\":1}}],[\"推荐尚硅谷的\",{\"1\":{\"1856\":1}}],[\"推荐阅读\",{\"1\":{\"1853\":1}}],[\"推荐入门的小伙伴看\",{\"1\":{\"1852\":1}}],[\"推荐大家看尚硅谷宋红康老师的\",{\"1\":{\"1847\":1}}],[\"推荐在线程绑定到固定的cpu的场景下使用\",{\"1\":{\"1397\":1}}],[\"推断构造源码解析\",{\"0\":{\"1527\":1}}],[\"推断构造方法的核心源码如下\",{\"1\":{\"1527\":1}}],[\"推断构造方法\",{\"1\":{\"1507\":1}}],[\"推断构造方法底层原理\",{\"1\":{\"1507\":1}}],[\"推论\",{\"1\":{\"498\":1}}],[\"吞吐量\",{\"1\":{\"1453\":1}}],[\"吞吐量和延迟并不重要的场景\",{\"1\":{\"1397\":1}}],[\"吞吐量还是非公平优于公平\",{\"1\":{\"1375\":1}}],[\"研发的初衷是为了解决内存队列的延迟问题\",{\"1\":{\"1396\":1}}],[\"规范整体框架\",{\"1\":{\"1536\":1}}],[\"规则以及方式\",{\"1\":{\"1395\":1}}],[\"规定两个库的server\",{\"1\":{\"592\":1}}],[\"借助这项能力\",{\"1\":{\"1395\":1}}],[\"充分地利用空闲线程\",{\"1\":{\"1391\":1}}],[\"异常\",{\"1\":{\"1847\":1}}],[\"异常处理\",{\"0\":{\"1815\":1}}],[\"异常处理和模式指定\",{\"1\":{\"1387\":1}}],[\"异常失败处理在这里\",{\"1\":{\"1452\":1}}],[\"异步i\",{\"1\":{\"1453\":1}}],[\"异步io的实现会负责把数据从内核拷贝到用户空间\",{\"1\":{\"1445\":1}}],[\"异步io\",{\"0\":{\"1443\":1},\"1\":{\"1438\":1,\"1444\":1}}],[\"异步说的是被调用者\",{\"1\":{\"1444\":1}}],[\"异步执行\",{\"1\":{\"1395\":1}}],[\"异步执行询价然后再保存\",{\"1\":{\"1394\":1}}],[\"异步向电商s3询价\",{\"1\":{\"1394\":1}}],[\"异步向电商s2询价\",{\"1\":{\"1394\":2}}],[\"异步向电商s1询价\",{\"1\":{\"1394\":2}}],[\"异步读写架构\",{\"0\":{\"859\":1}}],[\"异步复制\",{\"0\":{\"755\":1}}],[\"异步\",{\"0\":{\"1444\":1},\"1\":{\"726\":1,\"1453\":1,\"1863\":1}}],[\"压缩\",{\"1\":{\"1387\":1}}],[\"压力骤增\",{\"1\":{\"766\":1,\"769\":1}}],[\"肯定不为空了\",{\"1\":{\"1379\":1}}],[\"肯定要加锁\",{\"1\":{\"628\":1}}],[\"降低了我们开发的难度和工作量\",{\"1\":{\"1378\":1}}],[\"出队方法\",{\"1\":{\"1380\":1}}],[\"出队操作\",{\"1\":{\"1379\":1}}],[\"出队\",{\"1\":{\"1378\":3,\"1379\":1,\"1380\":1}}],[\"出现重复的注解修饰的方法\",{\"1\":{\"1531\":1}}],[\"出现这种情况的线程会飙高cpu\",{\"1\":{\"742\":1}}],[\"出现了自增主键不连续的情况\",{\"1\":{\"628\":1}}],[\"出现了两次\",{\"1\":{\"599\":1}}],[\"出现在分支结点中的元素会被当做它们在该分支结点位置的中序后继者\",{\"1\":{\"350\":1}}],[\"入门\",{\"1\":{\"1856\":1}}],[\"入队put方法\",{\"1\":{\"1379\":1,\"1380\":1}}],[\"入队和出队操作使用同一个锁对象\",{\"1\":{\"1379\":1}}],[\"入队\",{\"1\":{\"1378\":2,\"1379\":2}}],[\"入职时间\",{\"1\":{\"647\":1,\"655\":1}}],[\"乐观锁又被称为无锁算法\",{\"1\":{\"1375\":1}}],[\"乐观锁的例子\",{\"1\":{\"1375\":1}}],[\"考虑的是容量\",{\"1\":{\"1386\":1}}],[\"考虑锁等线程安全问题的重任从开发者转移到了\",{\"1\":{\"1378\":1}}],[\"考虑最坏的场景\",{\"1\":{\"1375\":1}}],[\"考虑到切换过程中不能丢失数据\",{\"1\":{\"604\":1}}],[\"考虑到丢失日志量的可控性\",{\"1\":{\"587\":1}}],[\"考虑到树根的数据块总是在内存中的\",{\"1\":{\"471\":1}}],[\"悲观锁\",{\"1\":{\"1375\":1}}],[\"俗称\",{\"1\":{\"1857\":1}}],[\"俗称信号量\",{\"1\":{\"1373\":1}}],[\"俗话说\",{\"1\":{\"620\":1}}],[\"唤醒生产者线程\",{\"1\":{\"1379\":1}}],[\"唤醒消费者线程\",{\"1\":{\"1379\":1}}],[\"唤醒之后这个线程就可以去竞争锁了\",{\"1\":{\"1370\":1}}],[\"唤醒时间和获取到锁继续执行的时间是不一致的\",{\"1\":{\"1360\":1}}],[\"允许外设设备和内存存储器之间直接进行io数据传输\",{\"1\":{\"1455\":1}}],[\"允许多条记录的值为null\",{\"1\":{\"1421\":1}}],[\"允许中断\",{\"1\":{\"1367\":1}}],[\"允许在执行更新类事务\",{\"1\":{\"611\":1}}],[\"逃逸分析分为方法逃逸和线程逃逸\",{\"1\":{\"1365\":1}}],[\"逃逸分析的基本行为就是分析对象动态作用域\",{\"1\":{\"1365\":1}}],[\"逃逸分析\",{\"0\":{\"1365\":1},\"1\":{\"1365\":1}}],[\"繁殖\",{\"1\":{\"1362\":1}}],[\"剥夺了该类的新实例对象使用偏向锁的权利\",{\"1\":{\"1362\":1}}],[\"撤销次数清0\",{\"1\":{\"1362\":1}}],[\"倘若偏向锁失败\",{\"1\":{\"1362\":1}}],[\"启用偏向锁\",{\"1\":{\"1362\":1}}],[\"启动类加载器\",{\"1\":{\"1569\":1}}],[\"启动核心api\",{\"1\":{\"1535\":1}}],[\"启动时加载\",{\"1\":{\"1535\":1}}],[\"启动时将每个指令与对应汇编代码入口绑定\",{\"1\":{\"1350\":1}}],[\"启动过程的完整代码\",{\"1\":{\"1528\":1}}],[\"启动disruptor\",{\"1\":{\"1398\":1}}],[\"启动一个该thread\",{\"1\":{\"1390\":1}}],[\"启动详情\",{\"0\":{\"1037\":1}}],[\"启动执行流程\",{\"0\":{\"1035\":1}}],[\"启动单机多服务集群\",{\"1\":{\"746\":1}}],[\"启动优先级\",{\"1\":{\"732\":1}}],[\"启动了事务trx1\",{\"1\":{\"613\":1}}],[\"禁止偏向锁\",{\"1\":{\"1362\":1}}],[\"禁止该指令与前面和后面的读写指令重排序\",{\"1\":{\"1350\":1}}],[\"官方文档\",{\"1\":{\"1504\":1}}],[\"官方文档显示误差可能达到40\",{\"1\":{\"533\":1}}],[\"官方建议使用hashmap替代它\",{\"1\":{\"1421\":1}}],[\"官方称它为\",{\"1\":{\"1361\":1}}],[\"称之为发生了竞态条件\",{\"1\":{\"1359\":1}}],[\"称为中转日志\",{\"1\":{\"590\":1}}],[\"称为死锁\",{\"1\":{\"581\":1}}],[\"称为sort\",{\"1\":{\"491\":1}}],[\"称为bin\",{\"1\":{\"462\":1}}],[\"称为小顶堆\",{\"1\":{\"351\":1}}],[\"称为大顶堆\",{\"1\":{\"351\":1}}],[\"竞态条件下\",{\"1\":{\"1357\":1}}],[\"问题出在多个线程访问共享资源\",{\"1\":{\"1359\":1}}],[\"问题\",{\"1\":{\"1356\":1}}],[\"问题的关键在于server层\",{\"1\":{\"561\":1}}],[\"嵌入式汇编规定把输出和输入寄存器按统一顺序编号\",{\"1\":{\"1356\":1}}],[\"嵌套循环连接算法\",{\"0\":{\"661\":1}}],[\"嵌套循环连接\",{\"1\":{\"660\":1}}],[\"嵌套循环\",{\"1\":{\"501\":1}}],[\"架构实现\",{\"0\":{\"1835\":1}}],[\"架构设计\",{\"0\":{\"1720\":1}}],[\"架构中的\",{\"1\":{\"1356\":2}}],[\"架构中的一个原子条件指令\",{\"1\":{\"1356\":1}}],[\"架构及\",{\"1\":{\"1356\":1}}],[\"协议\",{\"0\":{\"1712\":1}}],[\"协作扩容操作\",{\"1\":{\"1431\":1}}],[\"协程是轻量级的线程\",{\"1\":{\"1354\":1}}],[\"协商\",{\"1\":{\"758\":1}}],[\"休眠状态和终止状态\",{\"1\":{\"1354\":1}}],[\"五种线程模型对比\",{\"1\":{\"1444\":1}}],[\"五态模型\",{\"1\":{\"1354\":1}}],[\"五大数据类型\",{\"0\":{\"705\":1}}],[\"任意线程都会将元素提供给consumer\",{\"1\":{\"1500\":1}}],[\"任意一个任务执行完成\",{\"1\":{\"1395\":1}}],[\"任意一结点到每个叶子结点的路径都包含数量相同的黑节点\",{\"1\":{\"343\":1}}],[\"任何一个predicate会抛出异常的话\",{\"1\":{\"1476\":1}}],[\"任何时刻最多只允许一个线程去使用\",{\"1\":{\"1354\":1}}],[\"任务名称\",{\"1\":{\"1412\":1}}],[\"任务队列\",{\"1\":{\"1412\":1}}],[\"任务\",{\"1\":{\"1397\":1,\"1412\":1}}],[\"任务合并\",{\"1\":{\"1395\":1}}],[\"任务窃取\",{\"1\":{\"1391\":1}}],[\"任务切分\",{\"1\":{\"1391\":1}}],[\"任务总数\",{\"1\":{\"1387\":1}}],[\"任务类型\",{\"1\":{\"1387\":1}}],[\"任务被放在了阻塞队列中\",{\"1\":{\"1378\":1}}],[\"套接字描述符\",{\"1\":{\"1442\":1}}],[\"套接字\",{\"1\":{\"1354\":1}}],[\"信号量\",{\"1\":{\"1354\":2}}],[\"信号\",{\"1\":{\"1354\":1}}],[\"信息并不再阻塞父进程\",{\"1\":{\"725\":1}}],[\"信息状态只有\",{\"1\":{\"715\":1}}],[\"管程中引入了条件变量的概念\",{\"1\":{\"1360\":1}}],[\"管程是指管理共享变量以及对共享变量操作的过程\",{\"1\":{\"1360\":1}}],[\"管程\",{\"1\":{\"1360\":1}}],[\"管道被消费之后sourcespliterator就要设置为空\",{\"1\":{\"1498\":1}}],[\"管道的计算就会分成不同的段来执行\",{\"1\":{\"1498\":1}}],[\"管道的计算是在单个的过程中完成的\",{\"1\":{\"1498\":1}}],[\"管道类指的是流接口以及其原生特化的核心的实现\",{\"1\":{\"1498\":1}}],[\"管道输入输出流\",{\"1\":{\"1354\":1}}],[\"管道及有名管道\",{\"1\":{\"1354\":1}}],[\"管理系统删除表的时候\",{\"1\":{\"624\":1}}],[\"拒绝方法\",{\"1\":{\"1353\":1}}],[\"拒绝策略\",{\"1\":{\"1353\":1}}],[\"扩容大小2倍+1\",{\"1\":{\"1432\":1}}],[\"扩容时并未跳出死循环\",{\"1\":{\"1431\":1}}],[\"扩容前的数组大小如果已经达到最大\",{\"1\":{\"1427\":1}}],[\"扩容就是重新计算容量\",{\"1\":{\"1427\":1}}],[\"扩容机制\",{\"0\":{\"1427\":1}}],[\"扩容后的hashmap容量是之前容量的两倍\",{\"1\":{\"1423\":1}}],[\"扩容\",{\"1\":{\"1423\":1,\"1431\":1}}],[\"扩容的算法\",{\"1\":{\"1383\":1}}],[\"扩容了\",{\"1\":{\"1357\":1}}],[\"扩容因子\",{\"1\":{\"1352\":1}}],[\"扩展类加载器\",{\"1\":{\"1540\":1,\"1569\":1}}],[\"扩展点\",{\"1\":{\"1534\":1}}],[\"扩展spring类型转换器\",{\"0\":{\"1252\":1}}],[\"扩展内联混编\",{\"0\":{\"794\":1}}],[\"尾插法\",{\"1\":{\"1352\":1}}],[\"尾部\",{\"1\":{\"708\":1}}],[\"尾部的空格会被去掉\",{\"1\":{\"667\":1}}],[\"头插法和尾插法的对比\",{\"1\":{\"1352\":1}}],[\"头插法\",{\"1\":{\"1352\":1}}],[\"头部\",{\"1\":{\"708\":1}}],[\"底层调用的就是linux内核的sendfile系统调用方法\",{\"1\":{\"1465\":1}}],[\"底层采用数据\",{\"1\":{\"1352\":1}}],[\"底层具体实现的数据结构较为多样和复杂\",{\"1\":{\"353\":1}}],[\"许多较大的系统\",{\"1\":{\"1351\":1}}],[\"许多应用程序可以方便地缓存单表查询对应的结果对象\",{\"1\":{\"531\":1}}],[\"汇聚阶段会消耗这个整型值并求出最大值\",{\"1\":{\"1500\":1}}],[\"汇聚\",{\"1\":{\"1500\":1}}],[\"汇编层面volatile的实现\",{\"1\":{\"1350\":1}}],[\"汇总后如下\",{\"1\":{\"584\":1}}],[\"汇总到一个mysql实例的一个表中\",{\"1\":{\"548\":1}}],[\"赋值\",{\"1\":{\"1350\":1}}],[\"载入\",{\"1\":{\"1350\":1}}],[\"释放了锁\",{\"1\":{\"1362\":1}}],[\"释放后的变量才可以被其他线程锁定\",{\"1\":{\"1350\":1}}],[\"释放锁\",{\"1\":{\"675\":1}}],[\"泛型\",{\"1\":{\"1847\":1}}],[\"泛型条件判断\",{\"1\":{\"1525\":1}}],[\"泛型m的定义是m\",{\"1\":{\"1495\":1}}],[\"泛型集合类型辅助类\",{\"0\":{\"1262\":1}}],[\"泛型设置为\",{\"1\":{\"720\":1}}],[\"统一类型转换服务\",{\"0\":{\"1253\":1}}],[\"统计concurrenthashmap里面节点个数\",{\"1\":{\"1431\":1}}],[\"统计\",{\"1\":{\"1431\":1}}],[\"统计场景\",{\"0\":{\"906\":1}}],[\"统计sign中为1的位数\",{\"1\":{\"715\":1}}],[\"统计字符串被设置为1的bit数\",{\"1\":{\"715\":1}}],[\"统计的数据结构\",{\"1\":{\"714\":1}}],[\"统计的是写操作\",{\"1\":{\"616\":1}}],[\"统计多单位的数量\",{\"1\":{\"707\":1}}],[\"统计项名称\",{\"1\":{\"695\":1}}],[\"统计出的n\",{\"1\":{\"695\":2}}],[\"统计数据中s1表的记录行数是10573\",{\"1\":{\"691\":1}}],[\"统计这些页面上的不同值\",{\"1\":{\"484\":1}}],[\"容器负责内部处理\",{\"1\":{\"1561\":1}}],[\"容器组件\",{\"1\":{\"1561\":3}}],[\"容器之间的关系\",{\"1\":{\"1535\":1}}],[\"容器中的事务管理器\",{\"1\":{\"1532\":1}}],[\"容器\",{\"1\":{\"1431\":1}}],[\"容器为空\",{\"1\":{\"1431\":1}}],[\"容器的长度\",{\"1\":{\"1397\":1}}],[\"容器配置元信息\",{\"0\":{\"1189\":1,\"1190\":1}}],[\"容量为11\",{\"1\":{\"1432\":1}}],[\"容量\",{\"1\":{\"1380\":1,\"1386\":1}}],[\"容量可以扩大一倍\",{\"1\":{\"665\":1}}],[\"销毁方法只是针对于单例的bean而言\",{\"1\":{\"1524\":1}}],[\"销毁的问题\",{\"1\":{\"1411\":1}}],[\"销毁前阶段\",{\"0\":{\"1172\":1}}],[\"销毁阶段\",{\"0\":{\"1171\":1,\"1173\":1}}],[\"销毁bean\",{\"0\":{\"1094\":1}}],[\"限流\",{\"1\":{\"1863\":1}}],[\"限流降级\",{\"1\":{\"770\":1}}],[\"限定注入\",{\"0\":{\"1122\":1}}],[\"垃圾回收算法\",{\"0\":{\"1596\":1}}],[\"垃圾回收\",{\"0\":{\"1576\":1}}],[\"垃圾回收spring\",{\"0\":{\"1095\":1}}],[\"垃圾收集器参数总结\",{\"0\":{\"1634\":1}}],[\"垃圾收集器\",{\"0\":{\"1548\":1}}],[\"垃圾收集器的步骤\",{\"0\":{\"121\":1}}],[\"打破循环最关键的点是singletonfactories\",{\"1\":{\"1526\":1}}],[\"打包过程\",{\"0\":{\"1039\":1}}],[\"打开日志目录下的master\",{\"1\":{\"622\":1}}],[\"打开表的行为\",{\"1\":{\"561\":1}}],[\"打开表的时候\",{\"1\":{\"459\":1}}],[\"打开\",{\"1\":{\"491\":1,\"558\":1}}],[\"策略模式\",{\"0\":{\"1010\":1}}],[\"责任链模式\",{\"0\":{\"1008\":1}}],[\"享元模式\",{\"0\":{\"1004\":1}}],[\"装饰器模式\",{\"0\":{\"1003\":1}}],[\"构建项目\",{\"1\":{\"1858\":1}}],[\"构建工具\",{\"0\":{\"1040\":1}}],[\"构建器模式\",{\"0\":{\"996\":1}}],[\"构造一个reader和scanner\",{\"1\":{\"1524\":1}}],[\"构造一个metadatareader\",{\"1\":{\"1523\":1}}],[\"构造一个针对无状态的中间的阶段的流\",{\"1\":{\"1499\":1}}],[\"构造了一个终止操作\",{\"1\":{\"1500\":1}}],[\"构造之后就是一个不可变的数组\",{\"1\":{\"1497\":1}}],[\"构造最终所返回的累加器对象\",{\"1\":{\"1495\":1}}],[\"构造方法已经找到了\",{\"1\":{\"1527\":1}}],[\"构造方法注入\",{\"1\":{\"1527\":1}}],[\"构造方法引用\",{\"0\":{\"1483\":1},\"1\":{\"1479\":1}}],[\"构造方法有哪些特性\",{\"0\":{\"22\":1}}],[\"构造小顶堆的方法\",{\"1\":{\"1383\":1}}],[\"构造哈希值的时候很快\",{\"1\":{\"600\":1}}],[\"构造哈希函数的方法主要有\",{\"1\":{\"332\":1}}],[\"构造成一个堆\",{\"1\":{\"558\":1}}],[\"构造器注入\",{\"0\":{\"1115\":1}}],[\"构造器注入和setter注入\",{\"0\":{\"1073\":1}}],[\"构造器\",{\"0\":{\"14\":1},\"1\":{\"1380\":1}}],[\"拦截处理程序的执行\",{\"1\":{\"1534\":1}}],[\"拦截模式\",{\"0\":{\"912\":1}}],[\"拦截器的作用\",{\"1\":{\"807\":1}}],[\"安防场景\",{\"0\":{\"907\":1}}],[\"安全区域\",{\"0\":{\"1638\":1}}],[\"安全点\",{\"0\":{\"1637\":1}}],[\"安全依赖查找\",{\"0\":{\"1105\":1}}],[\"安全\",{\"0\":{\"814\":1}}],[\"粘包与拆包\",{\"0\":{\"892\":1}}],[\"核心技术\",{\"1\":{\"1847\":1}}],[\"核心原理\",{\"1\":{\"1844\":2}}],[\"核心包\",{\"1\":{\"1437\":1}}],[\"核心特点\",{\"1\":{\"1419\":1}}],[\"核心特性\",{\"0\":{\"703\":1}}],[\"核心逻辑在atomic\",{\"1\":{\"1356\":1}}],[\"核心线程数\",{\"1\":{\"1353\":1}}],[\"核心api\",{\"0\":{\"1019\":1,\"1437\":1},\"1\":{\"1416\":2,\"1417\":1,\"1532\":1}}],[\"核心基础\",{\"0\":{\"902\":1}}],[\"核心方法doresolvedependency的源代码\",{\"1\":{\"1525\":1}}],[\"核心方法的实现\",{\"1\":{\"1434\":1}}],[\"核心方法\",{\"0\":{\"862\":1}}],[\"流源\",{\"1\":{\"1501\":1}}],[\"流源可能通过两种方式来构建\",{\"1\":{\"1499\":1}}],[\"流源的对象也已经构造完成\",{\"1\":{\"1498\":1}}],[\"流调用机制与原理\",{\"0\":{\"1499\":1}}],[\"流就会被认为被消费掉了\",{\"1\":{\"1498\":1}}],[\"流就会自动的为我们根据姓名来进行分类了\",{\"1\":{\"1490\":1}}],[\"流的操作\",{\"1\":{\"1496\":1}}],[\"流的短路与并发流\",{\"0\":{\"1489\":1}}],[\"流初始被创建的时候就会选择串行还是并行的\",{\"1\":{\"1496\":1}}],[\"流都实现了autocloseable接口\",{\"1\":{\"1496\":1}}],[\"流关注的是元的计算\",{\"1\":{\"1496\":1}}],[\"流并不会直接提供直接的去操作元素的方式\",{\"1\":{\"1496\":1}}],[\"流管道以及并行流的行为和种类\",{\"1\":{\"1496\":1}}],[\"流管道可以通过并行或者是串行的方式来去执行\",{\"1\":{\"1496\":1}}],[\"流管道\",{\"1\":{\"1496\":1}}],[\"流会将执行的调用链的时候\",{\"1\":{\"1488\":1}}],[\"流是延迟的\",{\"1\":{\"1496\":1}}],[\"流是无法重复使用或消费的\",{\"1\":{\"1488\":1}}],[\"流是惰性的\",{\"1\":{\"1487\":1}}],[\"流与迭代器类似的一点是\",{\"1\":{\"1488\":1}}],[\"流只有在遇到终止操作的时候\",{\"1\":{\"1487\":1}}],[\"流中的元素为1\",{\"1\":{\"1487\":1}}],[\"流不存储值\",{\"1\":{\"1485\":1}}],[\"流才会被真正的执行\",{\"1\":{\"1484\":1}}],[\"流操作的分类又有两种\",{\"1\":{\"1484\":1}}],[\"流\",{\"1\":{\"1470\":1}}],[\"流程大致如下\",{\"1\":{\"1441\":1}}],[\"流程概览\",{\"0\":{\"1036\":1}}],[\"流程图如下\",{\"1\":{\"540\":1,\"553\":1}}],[\"流式调用\",{\"0\":{\"845\":1}}],[\"良好的设计\",{\"0\":{\"811\":1}}],[\"维基百科\",{\"1\":{\"1864\":1}}],[\"维护了一对相关的锁\",{\"1\":{\"1375\":2}}],[\"维护性差\",{\"1\":{\"806\":1}}],[\"维持和管理连接\",{\"1\":{\"455\":1}}],[\"帧类型\",{\"1\":{\"804\":1}}],[\"帧长度\",{\"1\":{\"804\":1}}],[\"兼容起来也比较简单\",{\"1\":{\"798\":1}}],[\"混合编程\",{\"0\":{\"791\":1}}],[\"混合日期和时间值\",{\"1\":{\"666\":2}}],[\"硬盘持久化\",{\"1\":{\"1352\":1}}],[\"硬盘操作\",{\"0\":{\"788\":1}}],[\"硬件内存架构没有区分线程栈和堆\",{\"1\":{\"1350\":1}}],[\"硬件层面利用lock或mfence\",{\"1\":{\"1350\":1}}],[\"硬件层面\",{\"1\":{\"1347\":1}}],[\"硬件响应等诸多因素都会影响响应时间\",{\"1\":{\"525\":1}}],[\"减轻了存储系统的压力\",{\"1\":{\"764\":1}}],[\"减少了不必要的拷贝次数\",{\"1\":{\"1453\":1}}],[\"减少碰撞次数\",{\"1\":{\"1431\":1}}],[\"减少cpu等待时间\",{\"1\":{\"1351\":1}}],[\"减少锁定资源量和实践长度\",{\"1\":{\"676\":1}}],[\"减少binlog的写盘次数\",{\"1\":{\"588\":1}}],[\"减少跨库和跨表查询\",{\"1\":{\"548\":1}}],[\"减少select\",{\"1\":{\"506\":1}}],[\"减少读磁盘\",{\"1\":{\"480\":1}}],[\"减少回表次数\",{\"1\":{\"477\":1}}],[\"减少语句的执行时间\",{\"1\":{\"475\":1}}],[\"脚本将会被一个sigkill信号终止\",{\"1\":{\"761\":1}}],[\"脚本将不会重复执行\",{\"1\":{\"761\":1}}],[\"授权密码\",{\"1\":{\"761\":1}}],[\"客观上认为主节点失联了\",{\"1\":{\"761\":1}}],[\"客户端检查事务状态\",{\"0\":{\"1824\":1}}],[\"客户端代码\",{\"1\":{\"1451\":1}}],[\"客户端\",{\"1\":{\"1450\":1,\"1452\":1}}],[\"客户端重新配置主节点参数脚本\",{\"1\":{\"761\":1}}],[\"客户端订阅\",{\"1\":{\"736\":1}}],[\"客户端可以指定将这数据存储在哪个字典中\",{\"1\":{\"704\":1}}],[\"客户端在连接成功后\",{\"1\":{\"619\":1}}],[\"客户端缓存\",{\"0\":{\"619\":1}}],[\"客户端虽然断开了连接\",{\"1\":{\"618\":1}}],[\"客户端是在发完trx1更新后发起的select语句\",{\"1\":{\"609\":1}}],[\"客户端执行完\",{\"1\":{\"606\":1}}],[\"客户端无需关心后端的细节\",{\"1\":{\"606\":1}}],[\"客户端都会感知到\",{\"1\":{\"606\":1}}],[\"客户端直连方案\",{\"1\":{\"606\":1}}],[\"客户端直连和带proxy的读写分离架构的优劣势\",{\"1\":{\"606\":1}}],[\"客户端只连接proxy\",{\"1\":{\"606\":1}}],[\"客户端查询看不到之前执行完成的事务\",{\"1\":{\"596\":1}}],[\"客户端的指令通过队列来排队进行顺序处理\",{\"1\":{\"741\":1}}],[\"客户端的读写都直接访问节点a\",{\"1\":{\"590\":1}}],[\"客户端的应用程序会接收全部的结果集数据\",{\"1\":{\"520\":1}}],[\"客户端还要自己拼接sql语句和结果\",{\"1\":{\"538\":1}}],[\"客户端再次发送请求的话\",{\"1\":{\"455\":1}}],[\"客户端如果太长时间没有动静\",{\"1\":{\"455\":1}}],[\"哨兵主观上认为主节点下线\",{\"1\":{\"761\":1}}],[\"哨兵sentinel监控的redis主节点的\",{\"1\":{\"761\":1}}],[\"哨兵sentinel的工作目录\",{\"1\":{\"761\":1}}],[\"哨兵sentinel实例运行的端口\",{\"1\":{\"761\":1}}],[\"哨兵集群\",{\"1\":{\"760\":1}}],[\"哨兵模式是主从模式的升级\",{\"1\":{\"760\":1}}],[\"哨兵模式优缺点\",{\"0\":{\"759\":1}}],[\"哨兵模式与主从复制的区别\",{\"1\":{\"758\":1}}],[\"哨兵的核心配置\",{\"1\":{\"758\":1}}],[\"哨兵的作用\",{\"1\":{\"757\":1}}],[\"费事费力\",{\"1\":{\"756\":1}}],[\"心跳机制\",{\"0\":{\"822\":1}}],[\"心跳机制了解么\",{\"0\":{\"218\":1}}],[\"心跳\",{\"0\":{\"754\":1}}],[\"认老大\",{\"1\":{\"747\":1}}],[\"认为这是不同的表\",{\"1\":{\"562\":1}}],[\"认为这是同一张表\",{\"1\":{\"562\":1}}],[\"角色\",{\"1\":{\"746\":1}}],[\"见redis\",{\"1\":{\"746\":1}}],[\"环形链表就这样出现了\",{\"1\":{\"1428\":1}}],[\"环形链表ii\",{\"0\":{\"377\":1}}],[\"环形数组结构\",{\"1\":{\"1396\":1}}],[\"环形数组\",{\"1\":{\"1379\":2}}],[\"环境配置\",{\"0\":{\"746\":1}}],[\"负数表示正在初始化或扩容\",{\"1\":{\"1431\":1}}],[\"负载加载用户自定义路径下的类包\",{\"1\":{\"1540\":1}}],[\"负载加载支撑jvm运行的位于jre的lib目录下的核心类库\",{\"1\":{\"1540\":1}}],[\"负载因子越大\",{\"1\":{\"1423\":1}}],[\"负载因子loadfactor默认值是0\",{\"1\":{\"1423\":1}}],[\"负载因子\",{\"1\":{\"1423\":1}}],[\"负载均衡\",{\"0\":{\"1729\":1},\"1\":{\"744\":1}}],[\"负责管理和启动各个service\",{\"1\":{\"1563\":1}}],[\"负责网络字节流与request和response对象的转化\",{\"1\":{\"1561\":1}}],[\"负责加载classpath路径下的类包\",{\"1\":{\"1540\":1}}],[\"负责加载支撑jvm运行的位于jre的lib目录下的ext目录下的类库\",{\"1\":{\"1540\":1}}],[\"负责最基础的功能支撑\",{\"1\":{\"806\":1}}],[\"负责具体的sql查找\",{\"1\":{\"806\":1}}],[\"负责存储相关的具体事宜\",{\"1\":{\"462\":1}}],[\"复用了aspectj中的几个核心注解\",{\"1\":{\"1531\":1}}],[\"复合缓冲区\",{\"0\":{\"882\":1}}],[\"复制算法\",{\"0\":{\"1599\":1}}],[\"复制过程\",{\"0\":{\"750\":1}}],[\"复制原理\",{\"0\":{\"749\":1}}],[\"复制到其他的redis服务器\",{\"1\":{\"743\":1}}],[\"复杂性永远都是存在的\",{\"1\":{\"1489\":1}}],[\"复杂度\",{\"1\":{\"726\":1}}],[\"复杂查询\",{\"0\":{\"529\":1}}],[\"响应\",{\"1\":{\"1351\":2}}],[\"响应队列\",{\"0\":{\"742\":1}}],[\"响应时间既可能是一个问题的结果也可能是一个问题的原因\",{\"1\":{\"525\":1}}],[\"响应时间并没有什么一致的规律或者公示\",{\"1\":{\"525\":1}}],[\"响应时间是两个部分之和\",{\"1\":{\"525\":1}}],[\"响应时间\",{\"0\":{\"525\":1},\"1\":{\"524\":1}}],[\"事实上\",{\"1\":{\"1442\":1,\"1481\":1}}],[\"事件发布\",{\"1\":{\"1513\":1}}],[\"事件或者任务\",{\"1\":{\"1382\":1}}],[\"事件\",{\"1\":{\"1354\":1}}],[\"事件中的应用\",{\"0\":{\"1017\":1}}],[\"事件轮询\",{\"1\":{\"740\":1}}],[\"事务消息\",{\"0\":{\"1816\":1}}],[\"事务可能就会失效\",{\"1\":{\"1532\":1}}],[\"事务串行化\",{\"1\":{\"1351\":1}}],[\"事务管理\",{\"1\":{\"806\":1}}],[\"事务正常执行\",{\"1\":{\"718\":1}}],[\"事务错误\",{\"0\":{\"717\":1}}],[\"事务中每条命令都会被序列化\",{\"1\":{\"715\":1}}],[\"事务中的mdl锁\",{\"1\":{\"578\":1}}],[\"事务以及不同级别磁盘持久化功能\",{\"1\":{\"705\":1}}],[\"事务\",{\"1\":{\"703\":1}}],[\"事务才真正启动\",{\"1\":{\"679\":1}}],[\"事务是可见的\",{\"1\":{\"679\":1}}],[\"事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read\",{\"1\":{\"679\":1}}],[\"事务里面涉及到的表会被加到对应的哈希表中\",{\"1\":{\"598\":1}}],[\"事务及其属性\",{\"0\":{\"669\":1}}],[\"事务回滚也会发生类似的情况\",{\"1\":{\"628\":1}}],[\"事务回滚\",{\"1\":{\"628\":1}}],[\"事务完成\",{\"1\":{\"609\":1}}],[\"事务id\",{\"1\":{\"679\":1}}],[\"事务id也会递增\",{\"1\":{\"605\":1}}],[\"事务id是在事务执行过程中分配的\",{\"1\":{\"605\":1}}],[\"事务哈希表还需要考虑唯一键\",{\"1\":{\"599\":1}}],[\"事务t跟多余一个worker冲突\",{\"1\":{\"598\":1}}],[\"事务t和队列中的某个事务要修改同一个表的数据\",{\"1\":{\"598\":1}}],[\"事务并不能简单的按照轮询的方式分发给各个worker\",{\"1\":{\"597\":1}}],[\"事务执行\",{\"1\":{\"716\":1}}],[\"事务执行中间过程中的redo\",{\"1\":{\"588\":1}}],[\"事务执行过程中\",{\"1\":{\"587\":1}}],[\"事务在执行过程中\",{\"1\":{\"588\":1}}],[\"事务在执行期间看到的数据前后必须是一致的\",{\"1\":{\"570\":1}}],[\"事务提交的时候\",{\"1\":{\"587\":2,\"609\":1}}],[\"事务a读取到了事务b提交的新增数据\",{\"1\":{\"669\":1}}],[\"事务a读取到了事务b已经修改但尚未提交的数据\",{\"1\":{\"669\":1}}],[\"事务a内部相同查询语句在不同时刻读出的结果不一致\",{\"1\":{\"669\":1}}],[\"事务a和事务b在互相等待对方的资源释放\",{\"1\":{\"581\":1}}],[\"事务a在等待事务b释放id=2的行锁\",{\"1\":{\"581\":1}}],[\"事务a持有两个记录的行锁\",{\"1\":{\"580\":1}}],[\"事务a会查询到的v1\",{\"1\":{\"570\":1}}],[\"事务不提交\",{\"1\":{\"578\":1}}],[\"事务的执行过程\",{\"1\":{\"1532\":1}}],[\"事务的实现方式\",{\"1\":{\"698\":1}}],[\"事务的隔离级别\",{\"1\":{\"669\":1}}],[\"事务的begin之前有一条set\",{\"1\":{\"605\":1}}],[\"事务的启动方式\",{\"0\":{\"572\":1}}],[\"事务的基本特性和隔离级别\",{\"0\":{\"158\":1}}],[\"事务b正确提交了\",{\"1\":{\"628\":1}}],[\"事务b申请到id=3\",{\"1\":{\"628\":1}}],[\"事务b要把redo\",{\"1\":{\"588\":1}}],[\"事务b才能继续执行\",{\"1\":{\"580\":1}}],[\"事务b才可以继续执行\",{\"1\":{\"570\":1}}],[\"事务b也要更新同一行\",{\"1\":{\"579\":1}}],[\"事务b的更新在提交后才能被a看到\",{\"1\":{\"570\":1}}],[\"事务支持是在引擎层实现的\",{\"1\":{\"569\":1}}],[\"事务具有acid\",{\"1\":{\"569\":1}}],[\"事务就可以生效\",{\"1\":{\"1507\":1}}],[\"事务就可以完成了\",{\"1\":{\"482\":1}}],[\"事务就是要保证一组操作\",{\"1\":{\"569\":1}}],[\"事务隔离的实现\",{\"0\":{\"571\":1}}],[\"事务隔离\",{\"0\":{\"569\":1}}],[\"稍微复杂的场景\",{\"1\":{\"738\":1}}],[\"稍微往前\",{\"1\":{\"604\":1}}],[\"起始更多是使用消息队列来进行实现\",{\"1\":{\"738\":1}}],[\"起止元素\",{\"1\":{\"708\":1}}],[\"起止位置都取\",{\"1\":{\"707\":1}}],[\"微博关注等等\",{\"1\":{\"738\":1}}],[\"微服务和分布式\",{\"0\":{\"1866\":1}}],[\"微服务下服务a调用服务b的流程\",{\"0\":{\"245\":1}}],[\"微服务的链路追踪\",{\"0\":{\"237\":1}}],[\"微服务有哪些优缺点\",{\"0\":{\"231\":1}}],[\"微服务\",{\"0\":{\"230\":1}}],[\"公平选择性\",{\"1\":{\"1375\":1}}],[\"公平和非公平\",{\"1\":{\"1371\":1}}],[\"公平锁\",{\"1\":{\"1368\":1}}],[\"公平\",{\"1\":{\"1367\":1,\"1379\":1}}],[\"公众号订阅\",{\"1\":{\"738\":1}}],[\"公共区溢出法\",{\"1\":{\"332\":1}}],[\"退缩不前\",{\"1\":{\"1408\":1}}],[\"退订则就是将客户端节点从链表中移除\",{\"1\":{\"736\":1}}],[\"退订一个或多个频道\",{\"1\":{\"734\":1}}],[\"退订一个或多个符合给定模式的频道\",{\"1\":{\"734\":1}}],[\"退化的逻辑大概如下\",{\"1\":{\"599\":1}}],[\"订阅不同数量的topic\",{\"0\":{\"1747\":1}}],[\"订阅了不同tag\",{\"0\":{\"1746\":1}}],[\"订阅了不同的topic\",{\"0\":{\"1745\":1}}],[\"订阅关系的一致性\",{\"0\":{\"1742\":1}}],[\"订阅成功的消息\",{\"1\":{\"735\":1}}],[\"订阅sakura频道\",{\"1\":{\"735\":1}}],[\"订阅端\",{\"1\":{\"735\":1}}],[\"订阅给定的一个或多个频道\",{\"1\":{\"734\":1}}],[\"订阅一个或多个符合给定模式的频道\",{\"1\":{\"734\":1}}],[\"订阅者\",{\"1\":{\"733\":1}}],[\"丢数据\",{\"1\":{\"732\":1}}],[\"丢掉前y个\",{\"1\":{\"559\":1}}],[\"体积\",{\"1\":{\"732\":1}}],[\"低谷期\",{\"1\":{\"1386\":1}}],[\"低\",{\"1\":{\"732\":1,\"1431\":1,\"1453\":1}}],[\"低耦合的微服务\",{\"0\":{\"235\":1}}],[\"修复速度比rdb慢\",{\"1\":{\"730\":1}}],[\"修改传入参数的引用\",{\"1\":{\"1500\":1}}],[\"修改一下程序\",{\"1\":{\"1496\":1}}],[\"修改阈值\",{\"1\":{\"1427\":1}}],[\"修改阈值为int的最大值\",{\"1\":{\"1427\":1}}],[\"修改之前\",{\"0\":{\"1044\":1}}],[\"修改sql\",{\"1\":{\"807\":1}}],[\"修改配置文件\",{\"1\":{\"757\":1}}],[\"修改生效\",{\"1\":{\"718\":1}}],[\"修改了线程一中监视的money\",{\"1\":{\"718\":1}}],[\"修改中间元素\",{\"1\":{\"708\":1}}],[\"修改则会被阻塞\",{\"1\":{\"674\":1}}],[\"修改同一行\",{\"1\":{\"599\":1}}],[\"修改同一个表\",{\"1\":{\"599\":1}}],[\"修改global变量的方式影响面更大\",{\"1\":{\"575\":1}}],[\"修改表结构\",{\"1\":{\"574\":1}}],[\"修改long\",{\"1\":{\"565\":1}}],[\"修改语句\",{\"1\":{\"485\":1}}],[\"修改完成后\",{\"1\":{\"455\":1}}],[\"修改\",{\"1\":{\"310\":1}}],[\"没法再对这些节点进行进一步的分割\",{\"1\":{\"1497\":1}}],[\"没超过最大值\",{\"1\":{\"1427\":1}}],[\"没秒同步一次\",{\"1\":{\"730\":1}}],[\"没有人可以一开始\",{\"1\":{\"1850\":1}}],[\"没有添加事件监听器的功能\",{\"1\":{\"1514\":1}}],[\"没有设置运行时环境的功能\",{\"1\":{\"1514\":1}}],[\"没有效率的trysplit会是的并发执行的效率急剧下降\",{\"1\":{\"1497\":1}}],[\"没有cpu拷贝数据环节\",{\"1\":{\"1462\":2}}],[\"没有child\",{\"1\":{\"302\":2}}],[\"没有等待数据它不会等待\",{\"1\":{\"1451\":1}}],[\"没有描述符限制\",{\"1\":{\"1448\":1}}],[\"没有hash冲突的话为0\",{\"1\":{\"1431\":1}}],[\"没有修改操作\",{\"1\":{\"1403\":1}}],[\"没有写操作\",{\"1\":{\"1403\":1}}],[\"没有写请求或者有写请求\",{\"1\":{\"1375\":1}}],[\"没有重新设置线程的中断状态\",{\"1\":{\"1401\":1}}],[\"没有异常处理\",{\"1\":{\"1393\":1}}],[\"没有其他线程的读锁\",{\"1\":{\"1375\":1}}],[\"没有其他线程的写锁\",{\"1\":{\"1375\":2}}],[\"没有遇到并发竞争时\",{\"1\":{\"1357\":1}}],[\"没有性能问题\",{\"1\":{\"798\":1}}],[\"没有结果\",{\"1\":{\"718\":1}}],[\"没有注释而且这些微调的值十分的小\",{\"1\":{\"685\":1}}],[\"没有id=2的行\",{\"1\":{\"628\":1}}],[\"没有视图概念\",{\"1\":{\"570\":1}}],[\"没有分区的key也需要访问所有的分区表\",{\"1\":{\"562\":1}}],[\"没有用临时表了\",{\"1\":{\"551\":1}}],[\"没有用到a字段\",{\"1\":{\"514\":1}}],[\"没有用到覆盖索引\",{\"1\":{\"510\":1}}],[\"没有用到索引\",{\"1\":{\"467\":1}}],[\"没有机会进入young区域\",{\"1\":{\"543\":1}}],[\"没有什么索引能够让这样的查询减少需要扫描的行数\",{\"1\":{\"527\":1}}],[\"没有哪个指标能够完美地衡量查询的开销\",{\"1\":{\"524\":1}}],[\"没有产生using\",{\"1\":{\"515\":1}}],[\"没有额外的代价\",{\"1\":{\"484\":1}}],[\"没有区别\",{\"1\":{\"404\":1}}],[\"版本\",{\"1\":{\"1861\":1}}],[\"版本开始\",{\"1\":{\"729\":1}}],[\"版本链的比对规则如下\",{\"1\":{\"679\":1}}],[\"适当提高该值\",{\"1\":{\"1541\":1}}],[\"适当的加大队列\",{\"1\":{\"1413\":1}}],[\"适配成methodinterceptor\",{\"1\":{\"1531\":1}}],[\"适配一个collector来执行finisher方法的转换\",{\"1\":{\"1495\":1}}],[\"适配器模式\",{\"0\":{\"895\":1,\"1001\":1}}],[\"适合入门\",{\"1\":{\"1870\":1}}],[\"适合做高性能服务器开发\",{\"1\":{\"1451\":1}}],[\"适合cpu资源紧缺\",{\"1\":{\"1397\":1}}],[\"适合控制数据访问\",{\"1\":{\"1354\":1}}],[\"适合大规模的数据恢复\",{\"1\":{\"727\":1}}],[\"适用于对延时要求非常苛刻的场景\",{\"1\":{\"1397\":1}}],[\"适用的场景\",{\"1\":{\"356\":1}}],[\"适用场景\",{\"1\":{\"316\":1}}],[\"缺点\",{\"0\":{\"737\":1,\"761\":1},\"1\":{\"726\":1,\"727\":1,\"730\":1}}],[\"缺点是有一定的误别率和删除困难\",{\"1\":{\"307\":1}}],[\"机制中获益\",{\"1\":{\"725\":1}}],[\"机制来实现\",{\"1\":{\"677\":1}}],[\"秒内如果至少有\",{\"1\":{\"724\":3}}],[\"触发rdb持久化过程可以分为手动触发和自动触发\",{\"1\":{\"723\":1}}],[\"触发器\",{\"1\":{\"454\":1}}],[\"工资总和\",{\"1\":{\"1492\":1}}],[\"工资表排序\",{\"1\":{\"711\":1}}],[\"工厂方法模式\",{\"0\":{\"997\":1}}],[\"工作队列\",{\"0\":{\"1389\":1}}],[\"工作线程从它自己的双端队列的头部获取任务\",{\"1\":{\"1388\":1}}],[\"工作线程的创建\",{\"1\":{\"1387\":1}}],[\"工作窃取\",{\"0\":{\"1388\":1},\"1\":{\"1388\":1}}],[\"工作原理\",{\"0\":{\"724\":1}}],[\"工作中一般不会这样使用\",{\"1\":{\"721\":1}}],[\"工具类参考博客\",{\"1\":{\"721\":1}}],[\"序列化方式\",{\"1\":{\"720\":1}}],[\"序列化设置\",{\"1\":{\"720\":1}}],[\"序列号\",{\"1\":{\"549\":1}}],[\"否\",{\"1\":{\"1453\":3}}],[\"否者就全是乱码\",{\"1\":{\"720\":1}}],[\"否则返回\",{\"1\":{\"1497\":1}}],[\"否则返回false\",{\"1\":{\"1476\":1,\"1497\":1}}],[\"否则一些错误的型为就可能会产生并发修改的异常\",{\"1\":{\"1496\":1}}],[\"否则将他们返回给汇聚操作的调用者\",{\"1\":{\"1492\":1}}],[\"否则直接抛出了nullpointerexception异常\",{\"1\":{\"1431\":1}}],[\"否则进行链表的插入操作\",{\"1\":{\"1426\":1}}],[\"否则转向步骤5\",{\"1\":{\"1426\":1}}],[\"否则转向步骤4\",{\"1\":{\"1426\":1}}],[\"否则转向步骤3\",{\"1\":{\"1426\":1}}],[\"否则执行resize\",{\"1\":{\"1426\":1}}],[\"否则会在运行时抛出java\",{\"1\":{\"1421\":1}}],[\"否则8字节\",{\"1\":{\"1361\":1}}],[\"否则sentinel无法正常启动成功\",{\"1\":{\"761\":1}}],[\"否则只对optimizer\",{\"1\":{\"693\":1}}],[\"否则只沿着区间最左记录向右读10个页面\",{\"1\":{\"686\":1}}],[\"否则使用的磁盘文件排序\",{\"1\":{\"657\":1}}],[\"否则根本不会执行到\",{\"1\":{\"618\":1}}],[\"否则创建主备关系的时候就会报错\",{\"1\":{\"615\":1}}],[\"否则持续重试这一步\",{\"1\":{\"595\":1}}],[\"否则就单方面地将\",{\"1\":{\"1356\":1}}],[\"否则就用statement格式\",{\"1\":{\"591\":1}}],[\"否则就需要额外的内存\",{\"1\":{\"555\":1}}],[\"否则就需要放在临时文件中排序\",{\"1\":{\"491\":1}}],[\"否则出现爆屏的情况\",{\"1\":{\"566\":1}}],[\"否则跳过\",{\"1\":{\"544\":1}}],[\"否则不加\",{\"1\":{\"536\":1}}],[\"否则\",{\"1\":{\"463\":1,\"610\":1,\"611\":1,\"1380\":1,\"1497\":2,\"1498\":1,\"1524\":1,\"1532\":1}}],[\"惊奇发现全是乱码\",{\"1\":{\"720\":1}}],[\"测试配置属性源\",{\"0\":{\"1318\":1}}],[\"测试\",{\"1\":{\"758\":1}}],[\"测试结果\",{\"1\":{\"720\":1}}],[\"测试事务\",{\"1\":{\"719\":1}}],[\"测试多线程修改值\",{\"1\":{\"718\":1}}],[\"监听者模式\",{\"0\":{\"1837\":1}}],[\"监听网络端口\",{\"1\":{\"1565\":1}}],[\"监听固定端口接收外部请求\",{\"1\":{\"1565\":1}}],[\"监听读事件\",{\"1\":{\"1451\":1}}],[\"监听连接事件\",{\"1\":{\"1451\":1}}],[\"监听到客户端连接请求后为每一个客户端创建一个新的线程链路进行处理\",{\"1\":{\"1450\":1}}],[\"监听实现原理\",{\"0\":{\"1286\":1}}],[\"监听器设计模式\",{\"0\":{\"1270\":1,\"1271\":1}}],[\"监听器编程模型\",{\"0\":{\"1269\":1}}],[\"监视\",{\"1\":{\"1442\":1}}],[\"监视器锁\",{\"1\":{\"1361\":1}}],[\"监视器\",{\"1\":{\"1360\":1}}],[\"监视值没有被中途修改\",{\"1\":{\"718\":1}}],[\"监视money\",{\"1\":{\"718\":1}}],[\"监控\",{\"0\":{\"718\":1}}],[\"支出使用\",{\"1\":{\"718\":1}}],[\"支持beanpostpropcessor\",{\"1\":{\"1524\":1}}],[\"支持在创建bean的过程中能对bean进行自动装配\",{\"1\":{\"1513\":1}}],[\"支持了factorybean的功能\",{\"1\":{\"1513\":1}}],[\"支持了按库并行的复制策略\",{\"1\":{\"600\":1}}],[\"支持别名功能\",{\"1\":{\"1513\":2}}],[\"支持的变化包括无序的遍历\",{\"1\":{\"1500\":1}}],[\"支持的功能也不同\",{\"1\":{\"454\":1}}],[\"支持基于文件的异步io操作和针对套接字的异步io操作等功能\",{\"1\":{\"1449\":2}}],[\"支持并行地调用度多个服务实例\",{\"1\":{\"1394\":1}}],[\"支持按优先级排序的无界阻塞队列\",{\"1\":{\"1378\":1}}],[\"支持非公平\",{\"1\":{\"1375\":1}}],[\"支持多个条件变量\",{\"1\":{\"1371\":1}}],[\"支持多线程的redis\",{\"1\":{\"738\":1}}],[\"支持网络\",{\"1\":{\"701\":1}}],[\"支持innodb\",{\"1\":{\"454\":1}}],[\"编程逻辑复杂\",{\"1\":{\"1462\":1}}],[\"编程方式创建\",{\"0\":{\"924\":1}}],[\"编辑操作\",{\"1\":{\"1408\":1}}],[\"编译原理\",{\"1\":{\"1844\":1}}],[\"编译sql语句\",{\"0\":{\"1786\":1}}],[\"编译通过但执行报错\",{\"1\":{\"1497\":1}}],[\"编译器都可以自动的推断出元素的类型\",{\"1\":{\"1491\":1}}],[\"编译器都可以自动推断类型\",{\"1\":{\"1470\":1}}],[\"编译器会认为此时的item是一个object类型的对象\",{\"1\":{\"1491\":1}}],[\"编译器会认为继承的优先级大于实现\",{\"1\":{\"1484\":1}}],[\"编译器会自动推断item的数据类型\",{\"1\":{\"1474\":1}}],[\"编译器会自动根据上下文\",{\"1\":{\"1472\":1}}],[\"编译器会自动将它看成是函数式接口\",{\"1\":{\"1471\":1}}],[\"编译器自动推断出了我们要想调用myinterface1impl中的mymethod\",{\"1\":{\"1484\":1}}],[\"编译器无法自动推断出要继承哪一个接口中的默认方法\",{\"1\":{\"1484\":1}}],[\"编译器就会提示我们不能解析构造方法\",{\"1\":{\"1477\":1}}],[\"编译器依旧会将该接口看作是函数式接口\",{\"1\":{\"1471\":1}}],[\"编译器其实会自动为满足函数式接口定义的接口添加\",{\"1\":{\"1471\":1}}],[\"编译器可以对代码做如下优化\",{\"1\":{\"1365\":1}}],[\"编译时异常\",{\"1\":{\"717\":1}}],[\"编写message\",{\"0\":{\"830\":1}}],[\"编写配置文件\",{\"1\":{\"720\":1}}],[\"编写sql语句并查看sql执行计划\",{\"1\":{\"498\":1}}],[\"签到统计\",{\"1\":{\"715\":1}}],[\"估算基数\",{\"1\":{\"714\":1}}],[\"估算myelemx的基数\",{\"1\":{\"714\":1}}],[\"估计区间最左记录和区间最右记录之间有多少个页面\",{\"1\":{\"686\":1}}],[\"花费\",{\"1\":{\"714\":1}}],[\"花费更少的硬件资源\",{\"1\":{\"664\":1}}],[\"坐标500km半径内的成员\",{\"1\":{\"713\":1}}],[\"纬度\",{\"1\":{\"713\":1}}],[\"失败\",{\"1\":{\"710\":1}}],[\"域\",{\"1\":{\"710\":1}}],[\"截取mylist中的\",{\"1\":{\"708\":1}}],[\"弹出\",{\"1\":{\"708\":4}}],[\"粉丝数\",{\"1\":{\"707\":1}}],[\"批量撤销\",{\"1\":{\"1366\":1}}],[\"批量重偏向和批量撤销是针对类的优化\",{\"1\":{\"1362\":1}}],[\"批量重偏向和批量撤销的总结\",{\"1\":{\"1362\":1}}],[\"批量获取多个key保存的值\",{\"1\":{\"707\":1}}],[\"批量设置键值对\",{\"1\":{\"707\":1}}],[\"批量set键值对\",{\"1\":{\"707\":1}}],[\"批量插入数据的语句\",{\"1\":{\"629\":1}}],[\"闭区间\",{\"1\":{\"707\":1}}],[\"故障处理工具\",{\"0\":{\"1648\":1}}],[\"故障转移的超时时间\",{\"1\":{\"761\":1}}],[\"故障可以转移\",{\"1\":{\"760\":1}}],[\"故障恢复\",{\"1\":{\"744\":1}}],[\"故会返回key的正常剩余时间\",{\"1\":{\"706\":1}}],[\"故意\",{\"1\":{\"602\":1}}],[\"集合主要考虑的是高效的访问和管理他们的元素\",{\"1\":{\"1496\":1}}],[\"集合主要分为两大类\",{\"1\":{\"1415\":1}}],[\"集合与流\",{\"1\":{\"1496\":1}}],[\"集合与我们编写的处理逻辑之间是有清晰的划分的\",{\"1\":{\"1488\":1}}],[\"集合关注的是数据与数据存储本身\",{\"1\":{\"1488\":1}}],[\"集合可以作为流的底层数据源\",{\"1\":{\"1485\":1}}],[\"集合的优点\",{\"0\":{\"1415\":1}}],[\"集合类实现序列化接口的目的\",{\"1\":{\"1352\":1}}],[\"集合类型注入\",{\"0\":{\"1121\":1}}],[\"集合类型依赖查找\",{\"0\":{\"1102\":1}}],[\"集合中最大的成员数为\",{\"1\":{\"709\":1}}],[\"集合成员是唯一的\",{\"1\":{\"709\":1}}],[\"集合\",{\"0\":{\"709\":1,\"1414\":1},\"1\":{\"705\":1,\"1847\":1}}],[\"集群模式\",{\"0\":{\"1770\":1,\"1775\":1}}],[\"集群工作流程\",{\"0\":{\"1719\":1}}],[\"集群消费\",{\"0\":{\"1708\":1}}],[\"集群容量一旦达到上限\",{\"1\":{\"761\":1}}],[\"集群中只是失去了写操作\",{\"1\":{\"748\":1}}],[\"集群\",{\"1\":{\"703\":1}}],[\"生命周期的整体流程\",{\"1\":{\"1524\":1}}],[\"生产者组\",{\"0\":{\"1706\":1}}],[\"生产者限流\",{\"1\":{\"1413\":1}}],[\"生产者没法限流\",{\"1\":{\"1413\":1}}],[\"生产者生产的速度大于消费者消费的速度\",{\"1\":{\"1413\":1}}],[\"生产者提交任务\",{\"1\":{\"1412\":1}}],[\"生产者线程池\",{\"1\":{\"1412\":1}}],[\"生产者线程生产任务\",{\"1\":{\"1412\":1}}],[\"生产者类型\",{\"1\":{\"1397\":1}}],[\"生产者的线程和消费者的线程同步传递某些信息\",{\"1\":{\"1382\":1}}],[\"生产者阻塞\",{\"1\":{\"1379\":1}}],[\"生产者\",{\"0\":{\"1412\":1,\"1730\":1},\"1\":{\"1378\":1,\"1379\":1,\"1412\":1}}],[\"生产环境中应该使用dbsize\",{\"1\":{\"704\":1}}],[\"生成签名\",{\"0\":{\"1829\":1}}],[\"生成bloomfilterdata\",{\"0\":{\"1785\":1}}],[\"生成统一的tomcat\",{\"1\":{\"1565\":1}}],[\"生成统计信息和执行计划\",{\"1\":{\"518\":1}}],[\"生成一个beandefinition对象\",{\"1\":{\"1509\":1}}],[\"生成一个结果或者拥有副作用\",{\"1\":{\"1500\":1}}],[\"生成一个正确的版本并返回结果\",{\"1\":{\"482\":1}}],[\"生成了一个新的只包含红色的widget的流\",{\"1\":{\"1496\":1}}],[\"生成的id不连续\",{\"1\":{\"629\":1}}],[\"生成的结果里面\",{\"1\":{\"629\":1}}],[\"生成的redo\",{\"1\":{\"588\":1}}],[\"生成与binlog的server\",{\"1\":{\"592\":1}}],[\"生成执行计划\",{\"1\":{\"518\":1}}],[\"浏览量\",{\"1\":{\"702\":1}}],[\"计数器\",{\"1\":{\"702\":1,\"707\":1}}],[\"计时器\",{\"1\":{\"702\":1}}],[\"计算位映射\",{\"0\":{\"1787\":1}}],[\"计算关于元素的求和\",{\"1\":{\"1492\":1}}],[\"计算新的resize上限\",{\"1\":{\"1427\":1}}],[\"计算index\",{\"1\":{\"1426\":1}}],[\"计算id\",{\"1\":{\"553\":1}}],[\"计算的结果越分散\",{\"1\":{\"1423\":1}}],[\"计算等一系列需要大量耗费cpu资源的任务\",{\"1\":{\"1387\":1}}],[\"计算value的地址\",{\"1\":{\"1356\":1}}],[\"计算机基础\",{\"1\":{\"1844\":1}}],[\"计算机体系结构中\",{\"1\":{\"1351\":1}}],[\"计算机的启动过程\",{\"0\":{\"779\":1}}],[\"计算机组成原理\",{\"0\":{\"775\":1},\"1\":{\"1844\":1}}],[\"计算基数所需的空间总是固定的\",{\"1\":{\"714\":1}}],[\"计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合\",{\"1\":{\"711\":2}}],[\"计算在有序集合中指定区间score的成员数\",{\"1\":{\"711\":1}}],[\"计算统计数据时采样的页面数量\",{\"1\":{\"695\":1}}],[\"计算每个页面中主键值记录数量\",{\"1\":{\"695\":1}}],[\"计算内连接查询成本的方式更麻烦一些\",{\"1\":{\"692\":1}}],[\"计算过程与上面类似\",{\"1\":{\"686\":1}}],[\"计算过程如下\",{\"1\":{\"686\":1}}],[\"计算平均每个页面中包含多少记录\",{\"1\":{\"686\":1}}],[\"计算使用不同索引执行查询的代价\",{\"0\":{\"686\":1},\"1\":{\"683\":1}}],[\"计算全表扫描的代价\",{\"0\":{\"685\":1},\"1\":{\"683\":1}}],[\"计算出平均一个值重复多少次\",{\"1\":{\"690\":1}}],[\"计算出来的\",{\"1\":{\"602\":1}}],[\"计算出这一行的哈希值\",{\"1\":{\"602\":1}}],[\"计算它与当前系统时间的差值\",{\"1\":{\"594\":1}}],[\"计算参与join的各个字段的总数据量\",{\"1\":{\"540\":1}}],[\"计算\",{\"1\":{\"491\":1,\"506\":1,\"1492\":1}}],[\"地址\",{\"0\":{\"781\":1,\"782\":1},\"1\":{\"1438\":1}}],[\"地址总线\",{\"0\":{\"777\":1}}],[\"地理位置\",{\"0\":{\"713\":1}}],[\"地图信息分析\",{\"1\":{\"702\":1}}],[\"地记录了sql命令\",{\"1\":{\"591\":1}}],[\"高性能\",{\"1\":{\"1852\":1}}],[\"高性能队列disruptor\",{\"0\":{\"1396\":1}}],[\"高鹏\",{\"1\":{\"1844\":1}}],[\"高位运算\",{\"1\":{\"1425\":1}}],[\"高位运算和取模运算\",{\"1\":{\"1423\":1}}],[\"高位参与运算\",{\"1\":{\"1425\":1}}],[\"高可用基石\",{\"1\":{\"744\":1}}],[\"高\",{\"1\":{\"732\":1,\"1431\":1,\"1453\":4}}],[\"高速缓存和消息队列代理\",{\"1\":{\"705\":1,\"1853\":1}}],[\"高效率\",{\"1\":{\"702\":1}}],[\"高并发资源竞争\",{\"1\":{\"525\":1}}],[\"高并发下\",{\"0\":{\"91\":1}}],[\"概述\",{\"0\":{\"700\":1}}],[\"概念\",{\"0\":{\"743\":1,\"763\":1,\"766\":1,\"769\":1,\"1704\":1},\"1\":{\"507\":1}}],[\"永久性的统计数据\",{\"1\":{\"695\":1}}],[\"永远都会返回相同的结果\",{\"1\":{\"1497\":1}}],[\"永远都是小的结果集驱动大的结果集\",{\"1\":{\"501\":1}}],[\"永远是id大的优先级最高\",{\"1\":{\"467\":1}}],[\"请说明resolvabletype的设计优势\",{\"0\":{\"1268\":1}}],[\"请介绍java\",{\"0\":{\"1267\":1}}],[\"请通过示例演示spring\",{\"0\":{\"1230\":1}}],[\"请举例不同类型的spring配置资源\",{\"0\":{\"1209\":1}}],[\"请举例说明spring\",{\"0\":{\"1016\":1}}],[\"请解释spring\",{\"0\":{\"992\":1}}],[\"请注意我使用的是块\",{\"1\":{\"694\":1}}],[\"请求处理完成后的回调\",{\"1\":{\"1534\":1}}],[\"请求\",{\"1\":{\"1351\":1}}],[\"请求来说\",{\"1\":{\"533\":1}}],[\"请求多余的数据\",{\"0\":{\"519\":1}}],[\"名称\",{\"1\":{\"694\":2}}],[\"名字第一个字是张\",{\"1\":{\"477\":1}}],[\"凡是不满足这些规则的连接顺序不参与分析\",{\"1\":{\"693\":1}}],[\"几乎所有的高级编程语言都支持了函数式编程的特性\",{\"1\":{\"1468\":1}}],[\"几个重要统计信息项的值如下\",{\"1\":{\"695\":1}}],[\"几个表之间采用嵌套循环连接算法执行\",{\"1\":{\"692\":1}}],[\"几种情况\",{\"1\":{\"302\":1}}],[\"×\",{\"1\":{\"692\":3,\"693\":10,\"695\":1,\"1431\":1}}],[\"暂时不妨可以认为lambda表达式就是匿名内部类的一种新的写法\",{\"1\":{\"1469\":1}}],[\"暂时不考虑使用join\",{\"1\":{\"692\":1}}],[\"暂时丢失数据的状态\",{\"1\":{\"596\":1}}],[\"扇出值就是多少\",{\"1\":{\"691\":1}}],[\"条\",{\"1\":{\"690\":1}}],[\"条件注解\",{\"1\":{\"1524\":1}}],[\"条件匹配\",{\"1\":{\"1524\":1}}],[\"条件有限或其他原因\",{\"1\":{\"1413\":1}}],[\"条件队列\",{\"1\":{\"1367\":1}}],[\"条件等待队列\",{\"0\":{\"1369\":1},\"1\":{\"1367\":1}}],[\"条件不满足\",{\"1\":{\"1360\":1}}],[\"条件变量个等待队列的作用是解决线程之间的同步问题\",{\"1\":{\"1360\":1}}],[\"条件\",{\"1\":{\"691\":3}}],[\"条件处理\",{\"1\":{\"656\":1}}],[\"条件时循环结束\",{\"1\":{\"493\":2}}],[\"条件为止\",{\"1\":{\"492\":1}}],[\"条件的二级索引记录条数\",{\"1\":{\"686\":1}}],[\"条件的记录\",{\"1\":{\"493\":1}}],[\"条件的主键id\",{\"1\":{\"491\":1,\"492\":1,\"493\":1,\"657\":2}}],[\"条件的行\",{\"1\":{\"491\":1}}],[\"÷\",{\"1\":{\"690\":2}}],[\"某一件事情一定是发生在另外一件事情之前\",{\"1\":{\"1500\":1}}],[\"某个线程在短时间内将原子类的值a修改为b\",{\"1\":{\"1356\":1}}],[\"某个索引列的cardinality属性是10000\",{\"1\":{\"690\":1}}],[\"某些场景哈希关联的效率要高很多\",{\"1\":{\"531\":1}}],[\"某些查询可能不可避免地需要筛选大量数据\",{\"1\":{\"518\":1}}],[\"描述的是管道的源阶段\",{\"1\":{\"1498\":1}}],[\"描述or聚合关系\",{\"1\":{\"1395\":1}}],[\"描述and聚合关系\",{\"1\":{\"1395\":1}}],[\"描述依赖关系\",{\"1\":{\"1395\":1}}],[\"描述\",{\"1\":{\"690\":1,\"695\":1,\"707\":1,\"708\":1,\"709\":1,\"710\":1,\"711\":1,\"713\":1,\"714\":1,\"715\":1,\"734\":1,\"1378\":1}}],[\"属性表集合\",{\"0\":{\"1660\":1}}],[\"属性绑定\",{\"1\":{\"1524\":1}}],[\"属性覆盖\",{\"1\":{\"1524\":1}}],[\"属性赋值\",{\"1\":{\"1524\":1}}],[\"属性赋值前阶段\",{\"0\":{\"1164\":1}}],[\"属性的说明\",{\"1\":{\"1498\":6}}],[\"属性是一个字典\",{\"1\":{\"736\":1}}],[\"属性\",{\"1\":{\"690\":1}}],[\"详细的请看下图\",{\"1\":{\"1530\":1}}],[\"详细解析\",{\"1\":{\"1526\":1}}],[\"详细说明\",{\"1\":{\"1431\":1}}],[\"详细说明如下\",{\"1\":{\"1426\":1}}],[\"详细具体步骤如下\",{\"1\":{\"725\":1}}],[\"详细含义\",{\"1\":{\"690\":1}}],[\"详细过程如下\",{\"1\":{\"596\":1}}],[\"搞不好计算这些单点区间对应的索引记录条数的成本比直接全表扫描的成本都大了\",{\"1\":{\"690\":1}}],[\"此处就进行实例化\",{\"1\":{\"1525\":1}}],[\"此处不用等到取元素时才唤醒\",{\"1\":{\"1380\":1}}],[\"此外它还负责加载servlet所依赖的jar包\",{\"1\":{\"1571\":1}}],[\"此外\",{\"1\":{\"1497\":1}}],[\"此模式依赖于java线程的阻塞唤醒机制\",{\"1\":{\"1407\":1}}],[\"此方法返回false\",{\"1\":{\"1356\":1}}],[\"此方法返回true\",{\"1\":{\"1356\":1}}],[\"此步骤对应的cpu成本就是\",{\"1\":{\"686\":1}}],[\"此时只会将bean的名称设置给beanclass属性\",{\"1\":{\"1524\":1}}],[\"此时只有在索引列上加上主键值才可以区分两条索引列值都是一样的二级索引记录\",{\"1\":{\"695\":1}}],[\"此时线程数的增多并没有让性能提升\",{\"1\":{\"1387\":1}}],[\"此时假设我们设置的线程数量是cpu核心数的2倍以上\",{\"1\":{\"1387\":1}}],[\"此时假设有三个线程同时执行这条更新语句\",{\"1\":{\"1375\":1}}],[\"此时队列有空位\",{\"1\":{\"1379\":1}}],[\"此时mark\",{\"1\":{\"1362\":1}}],[\"此时可能就需要对cell\",{\"1\":{\"1357\":1}}],[\"此时其他线程不感知\",{\"1\":{\"1356\":1}}],[\"此时其他session没法在这个范围锁包含的所有行记录\",{\"1\":{\"673\":1}}],[\"此时unsafe\",{\"1\":{\"1356\":1}}],[\"此时哨兵监视着我们的主机6379\",{\"1\":{\"758\":1}}],[\"此时我们回到redis查看数据时候\",{\"1\":{\"720\":1}}],[\"此时我们再来分析普通索引和唯一索引选择的问题\",{\"1\":{\"481\":1}}],[\"此时事务并没有执行\",{\"1\":{\"718\":1}}],[\"此时涉及到被驱动表s1的搜索条件就是\",{\"1\":{\"692\":1}}],[\"此时涉及到被驱动表s2的搜索条件就是\",{\"1\":{\"692\":1}}],[\"此时访问s2表时可用的方案也是全表扫描和使用idx\",{\"1\":{\"692\":1}}],[\"此时那些设计两表的条件相当于只涉及被驱动表s2了\",{\"1\":{\"692\":1}}],[\"此时范围区间\",{\"1\":{\"691\":1}}],[\"此时再看上述查询语句\",{\"1\":{\"690\":1}}],[\"此时就会加上前面去除的成本\",{\"1\":{\"688\":1}}],[\"此时包含两种情况\",{\"1\":{\"679\":1}}],[\"此时执行如下插入命令\",{\"1\":{\"628\":1}}],[\"此时如果在session\",{\"1\":{\"618\":1}}],[\"此时占用的cpu却是0\",{\"1\":{\"613\":1}}],[\"此时看起来使用分区表并没有什么不妥\",{\"1\":{\"561\":1}}],[\"此时表中有两行记录\",{\"1\":{\"561\":1}}],[\"此时表中的索引结构如下图所示\",{\"1\":{\"473\":1}}],[\"此时扫描行数增加10000\",{\"1\":{\"557\":1}}],[\"此时binlog会被记录成\",{\"1\":{\"550\":1}}],[\"此时语句的执行流程就变成了这样\",{\"1\":{\"541\":1}}],[\"此时的key\",{\"1\":{\"1428\":1}}],[\"此时的序列图如下\",{\"1\":{\"584\":1}}],[\"此时的查询也就不再需要排序了\",{\"1\":{\"493\":1}}],[\"此时的optimizer\",{\"1\":{\"492\":1}}],[\"此时change\",{\"1\":{\"481\":1}}],[\"此时redo\",{\"1\":{\"463\":1}}],[\"此时记录回文长度和起始位置\",{\"1\":{\"428\":1}}],[\"此时show\",{\"1\":{\"561\":1}}],[\"此时s\",{\"1\":{\"428\":1}}],[\"此时0这个位置的下标是4\",{\"1\":{\"421\":1}}],[\"此时\",{\"1\":{\"307\":2,\"375\":1,\"474\":1,\"540\":1,\"544\":1,\"553\":1,\"554\":1,\"555\":1,\"591\":1,\"598\":1,\"599\":1,\"604\":2,\"669\":1,\"761\":1,\"1425\":1,\"1428\":1}}],[\"综上所属\",{\"1\":{\"686\":2}}],[\"综上所述\",{\"1\":{\"588\":1,\"684\":1}}],[\"✖️1\",{\"1\":{\"686\":1}}],[\"✖️\",{\"1\":{\"685\":2,\"686\":2,\"690\":1}}],[\"➗\",{\"1\":{\"685\":2}}],[\"涉及事务加锁的sql尽量放在事务的最后执行\",{\"1\":{\"676\":1}}],[\"合起来理解\",{\"1\":{\"1453\":1}}],[\"合理设计索引\",{\"1\":{\"676\":1}}],[\"合并beandifinition的方法\",{\"1\":{\"1524\":1}}],[\"合并beandefition\",{\"1\":{\"1524\":1}}],[\"合并会生成一个新的beandefition\",{\"1\":{\"1524\":1}}],[\"合并\",{\"1\":{\"1387\":1}}],[\"合并myelemx和myelemy\",{\"1\":{\"714\":1}}],[\"合并为一个\",{\"1\":{\"714\":1}}],[\"合并后的score是之前集合中所有score的和\",{\"1\":{\"711\":1}}],[\"合并的过程\",{\"1\":{\"472\":1}}],[\"合并结果\",{\"1\":{\"288\":1}}],[\"共有八个\",{\"1\":{\"1497\":1}}],[\"共享\",{\"1\":{\"1367\":2}}],[\"共享获取等\",{\"1\":{\"1367\":1}}],[\"共享内存\",{\"1\":{\"1354\":1}}],[\"共享内存模型\",{\"1\":{\"1347\":1}}],[\"共享数据可能有多个副本\",{\"1\":{\"1351\":1}}],[\"共享锁的模式\",{\"1\":{\"1373\":1}}],[\"共享锁\",{\"1\":{\"674\":1,\"678\":1,\"1373\":1}}],[\"共同关注\",{\"1\":{\"709\":1}}],[\"共涉及了四个部分\",{\"1\":{\"482\":1}}],[\"临界资源\",{\"1\":{\"1359\":1}}],[\"临界区\",{\"1\":{\"1354\":1,\"1359\":2}}],[\"临键锁是行锁与间隙锁的组合\",{\"1\":{\"674\":1}}],[\"临键锁\",{\"0\":{\"674\":1}}],[\"临时关闭mysql查询缓存\",{\"1\":{\"663\":1}}],[\"临时表是二维表结构\",{\"1\":{\"555\":1}}],[\"临时表只能在线程内自己访问\",{\"1\":{\"550\":1}}],[\"临时表和主备复制\",{\"0\":{\"550\":1}}],[\"临时表经常会被用在复杂查询优化过程中\",{\"1\":{\"548\":1}}],[\"临时表的应用\",{\"0\":{\"548\":1}}],[\"临时表的特性\",{\"0\":{\"547\":1}}],[\"临时表特别适合join优化的场景\",{\"1\":{\"547\":1}}],[\"临时表可以与普通表同名\",{\"1\":{\"547\":1}}],[\"临时表有以下几个特点\",{\"1\":{\"547\":1}}],[\"临时表対系统性能损耗很大\",{\"1\":{\"467\":1}}],[\"区别在于框架帮助我们实现了多少\",{\"1\":{\"1489\":1}}],[\"区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件\",{\"1\":{\"701\":1}}],[\"区间内的成员\",{\"1\":{\"711\":1}}],[\"区间的成员数量\",{\"1\":{\"711\":1}}],[\"区间最右记录在页c中\",{\"1\":{\"686\":1}}],[\"区间都无法修改数据\",{\"1\":{\"673\":1}}],[\"区分度\",{\"1\":{\"484\":1}}],[\"历史版本\",{\"1\":{\"672\":1}}],[\"脏读\",{\"1\":{\"669\":2}}],[\"电话号码和不超过255个字符长度的任意字母数字组合\",{\"1\":{\"667\":1}}],[\"邮政编码\",{\"1\":{\"667\":1}}],[\"极大文本数据\",{\"1\":{\"667\":1}}],[\"极大整数值\",{\"1\":{\"665\":1}}],[\"短文本字符串\",{\"1\":{\"667\":1}}],[\"短连接则是指每次执行完很少的几次查询就断开连接\",{\"1\":{\"455\":1}}],[\"年份值\",{\"1\":{\"666\":1}}],[\"年龄\",{\"1\":{\"490\":1,\"647\":1,\"655\":1}}],[\"辅助索引\",{\"1\":{\"656\":1}}],[\"格式\",{\"1\":{\"666\":1}}],[\"格式化sql\",{\"1\":{\"656\":1}}],[\"格式是\",{\"1\":{\"605\":1}}],[\"词法分析器\",{\"0\":{\"650\":1}}],[\"员工记录表\",{\"1\":{\"647\":1,\"655\":1}}],[\"职位\",{\"1\":{\"647\":1,\"655\":1}}],[\"聚合的关系\",{\"1\":{\"1395\":1}}],[\"聚簇索引和唯一二级索引的该列值为0\",{\"1\":{\"690\":1}}],[\"聚簇索引和非聚簇索引有什么区别\",{\"0\":{\"162\":1}}],[\"聚簇索引的页面数量✖️每个页面的大小\",{\"1\":{\"685\":1}}],[\"聚簇索引占用的页面数\",{\"1\":{\"685\":1}}],[\"聚簇索引\",{\"1\":{\"655\":1}}],[\"聚集索引\",{\"1\":{\"642\":1}}],[\"聚集\",{\"1\":{\"642\":1}}],[\"仅仅是由一个布尔值来控制的\",{\"1\":{\"1494\":1}}],[\"仅仅是为了字节对齐\",{\"1\":{\"1361\":1}}],[\"仅仅需要将我们调用的方法修改为\",{\"1\":{\"1489\":1}}],[\"仅仅关心是否修改过\",{\"1\":{\"1356\":1}}],[\"仅记录值是否有过修改\",{\"1\":{\"1356\":1}}],[\"仅当参数中所有的key都不存在时执行\",{\"1\":{\"707\":1}}],[\"仅当key不存在时进行set\",{\"1\":{\"707\":1}}],[\"仅对于数字\",{\"1\":{\"707\":1}}],[\"仅能满足\",{\"1\":{\"641\":1}}],[\"仅包含0或1位值的列表\",{\"1\":{\"307\":1}}],[\"冗余\",{\"1\":{\"640\":1}}],[\"恐怕都还没有实例跑到过这个上限\",{\"1\":{\"634\":1}}],[\"申请到之后\",{\"1\":{\"1396\":1}}],[\"申请row\",{\"1\":{\"632\":1}}],[\"申请完成后锁就可以释放了\",{\"1\":{\"629\":1}}],[\"制定操作规范\",{\"1\":{\"624\":1}}],[\"账号分离\",{\"1\":{\"624\":1}}],[\"预清理阶段\",{\"0\":{\"1612\":1}}],[\"预写式日志\",{\"1\":{\"698\":1}}],[\"预估的二级索引记录数\",{\"1\":{\"686\":1}}],[\"预估的二级索引记录条数\",{\"1\":{\"686\":1}}],[\"预估表的访问成本\",{\"1\":{\"656\":1}}],[\"预计有39条二级索引记录需要进行回表操作\",{\"1\":{\"686\":1}}],[\"预计扫描行数\",{\"1\":{\"657\":1}}],[\"预防误删库\",{\"0\":{\"624\":1}}],[\"预设的3个哈希函数将输出2\",{\"1\":{\"307\":1}}],[\"延迟队列\",{\"0\":{\"1716\":1}}],[\"延迟绑定会限制修改影响计算的时间间隔\",{\"1\":{\"1497\":1}}],[\"延迟绑定的spliterator会在元素第一次分割\",{\"1\":{\"1497\":1}}],[\"延迟绑定的\",{\"1\":{\"1497\":1}}],[\"延迟查找\",{\"1\":{\"1485\":1}}],[\"延迟执行等\",{\"1\":{\"1386\":1}}],[\"延迟依赖注入\",{\"0\":{\"1123\":1}}],[\"延迟依赖查找\",{\"0\":{\"1104\":1}}],[\"延迟初始化bean\",{\"0\":{\"1093\":1}}],[\"延迟复制的备库是一种特殊的备库\",{\"1\":{\"623\":1}}],[\"延迟复制备库\",{\"0\":{\"623\":1}}],[\"延迟的时间越小\",{\"1\":{\"596\":1}}],[\"误删库或者表后\",{\"1\":{\"622\":1}}],[\"误删库\",{\"0\":{\"622\":1}}],[\"误删行\",{\"0\":{\"621\":1}}],[\"误删数据\",{\"0\":{\"620\":1}}],[\"哪怕可以调用private方法\",{\"1\":{\"1436\":1}}],[\"哪有不湿鞋\",{\"1\":{\"620\":1}}],[\"哪些情况需要建索引\",{\"0\":{\"495\":1}}],[\"哪些列或常量被用于查找索引列上的值\",{\"1\":{\"467\":1}}],[\"哪些索引被实际使用\",{\"1\":{\"466\":1}}],[\"哪些索引可以使用\",{\"1\":{\"466\":1}}],[\"哪些线程独享\",{\"0\":{\"102\":1}}],[\"哪些线程共享\",{\"0\":{\"102\":1}}],[\"加载某个类会先委托父加载器寻找目标类\",{\"1\":{\"1570\":1}}],[\"加载和管理servlet\",{\"1\":{\"1561\":1}}],[\"加载\",{\"0\":{\"1664\":1},\"1\":{\"1540\":1}}],[\"加载因子为0\",{\"1\":{\"1432\":1}}],[\"加一\",{\"1\":{\"1431\":1}}],[\"加入到扩容大军中\",{\"1\":{\"1431\":1}}],[\"加入到newlist的头部\",{\"1\":{\"708\":1}}],[\"加速定位的速度\",{\"1\":{\"1396\":1}}],[\"加take锁\",{\"1\":{\"1380\":1}}],[\"加互斥锁\",{\"1\":{\"767\":1}}],[\"加锁的方式通常会严重影响性能\",{\"1\":{\"1396\":1}}],[\"加锁\",{\"1\":{\"1379\":2,\"1431\":1}}],[\"加锁慢\",{\"1\":{\"672\":1}}],[\"加锁快\",{\"1\":{\"671\":1}}],[\"加上一个\",{\"1\":{\"622\":1}}],[\"加上此时文件系统压力大\",{\"1\":{\"618\":1}}],[\"加增量日志的方式了\",{\"1\":{\"622\":1}}],[\"加\",{\"1\":{\"619\":1,\"1431\":1}}],[\"加起来是14000字节\",{\"1\":{\"558\":1}}],[\"埋点\",{\"1\":{\"618\":2}}],[\"隐含了下面的三层意思\",{\"1\":{\"618\":1}}],[\"隐式字符编码转换\",{\"0\":{\"505\":1}}],[\"隐式类型转换\",{\"0\":{\"504\":1}}],[\"终止操作的数量并不是特别多\",{\"1\":{\"1500\":1}}],[\"终止操作对于给定的流源和中间操作一定要提供并行和串行的实现\",{\"1\":{\"1500\":1}}],[\"终止操作会对流中的每个元素执行action\",{\"1\":{\"1500\":1}}],[\"终止操作\",{\"1\":{\"1484\":1}}],[\"终止线程模式\",{\"0\":{\"1400\":1}}],[\"终止逻辑耗时较长\",{\"1\":{\"618\":1}}],[\"终止这条查询语句\",{\"1\":{\"617\":1}}],[\"终止条件\",{\"1\":{\"397\":1}}],[\"判读方法是否含有\",{\"1\":{\"1507\":1}}],[\"判定慢\",{\"1\":{\"615\":1}}],[\"判断对象已死\",{\"0\":{\"1591\":1}}],[\"判断beandefinition是否是一个bean\",{\"1\":{\"1524\":1}}],[\"判断流是否是并行流\",{\"1\":{\"1496\":1}}],[\"判断sizectl值是否小于0\",{\"1\":{\"1431\":1}}],[\"判断容器是否初始化\",{\"1\":{\"1431\":1}}],[\"判断链表长度是否大于8\",{\"1\":{\"1431\":1}}],[\"判断链表的长度是否大于8\",{\"1\":{\"1426\":1}}],[\"判断是否需要进行aop\",{\"1\":{\"1526\":1}}],[\"判断是否需要扩容\",{\"1\":{\"1430\":1,\"1431\":1}}],[\"判断是否写完如果没有继续写\",{\"1\":{\"1452\":1}}],[\"判断是否是连接请求\",{\"1\":{\"1451\":1}}],[\"判断是不可能为空的\",{\"1\":{\"536\":2}}],[\"判断实际存在的键值对数量size是否超过了最大容量\",{\"1\":{\"1426\":1}}],[\"判断table\",{\"1\":{\"1426\":2}}],[\"判断键值对数组table\",{\"1\":{\"1426\":1}}],[\"判断键是否存在\",{\"1\":{\"706\":2}}],[\"判断该链表为红黑树\",{\"1\":{\"1426\":1}}],[\"判断当前的spliterator是否包含传入的characteristics特性值\",{\"1\":{\"1497\":1}}],[\"判断当前执行环境是否为多处理器环境\",{\"1\":{\"1356\":1}}],[\"判断当前线程的中断标志位是否位true\",{\"1\":{\"1354\":1}}],[\"判断当前node的child\",{\"1\":{\"302\":1}}],[\"判断模式\",{\"0\":{\"911\":1}}],[\"判断可见性发现\",{\"1\":{\"634\":1}}],[\"判断这个数据是否可见的方法\",{\"1\":{\"634\":1}}],[\"判断同步位点的方案还有另外一个潜在的问题\",{\"1\":{\"609\":1}}],[\"判断主备无延迟方案\",{\"0\":{\"609\":1},\"1\":{\"606\":1}}],[\"判断a\",{\"1\":{\"605\":1}}],[\"判断备库b的seconds\",{\"1\":{\"595\":1}}],[\"判断备库b现在的seconds\",{\"1\":{\"595\":1}}],[\"判断条件的次数是1000\",{\"1\":{\"544\":1}}],[\"判断join是否满足的时候\",{\"1\":{\"544\":1}}],[\"判断join条件需要执行m\",{\"1\":{\"543\":1}}],[\"判断到有可能是null\",{\"1\":{\"536\":1}}],[\"判断到没有冲突\",{\"1\":{\"480\":1}}],[\"判断不能为null\",{\"1\":{\"536\":1}}],[\"判断出email的值不是\",{\"1\":{\"487\":1}}],[\"判断email的值是正确的\",{\"1\":{\"487\":1}}],[\"判断id值是不是10\",{\"1\":{\"459\":1}}],[\"判断输入的sql语句是否满足mysql语法\",{\"1\":{\"457\":1}}],[\"判断格子是否在网格中\",{\"1\":{\"435\":1}}],[\"判断坐标\",{\"1\":{\"435\":2}}],[\"判断\",{\"1\":{\"337\":1,\"435\":2}}],[\"判断奇偶\",{\"1\":{\"315\":1}}],[\"检测和修改其本身状态或行为的一种能力\",{\"1\":{\"1435\":1}}],[\"检测一条记录是否符合搜索条件的成本\",{\"1\":{\"694\":1}}],[\"检测一条记录是否符合搜索条件的成本默认是0\",{\"1\":{\"694\":1}}],[\"检测系统发现\",{\"1\":{\"615\":1}}],[\"检测命令\",{\"1\":{\"615\":1}}],[\"检查当前类加载器是否已经加载了该类\",{\"1\":{\"1540\":1}}],[\"检查通过name查找到的bean是否是requiredtype类型的bean\",{\"1\":{\"1524\":1}}],[\"检查spring容器中是否已经含有这个名字的bean\",{\"1\":{\"1524\":1}}],[\"检查map中是否存在该名字\",{\"1\":{\"1490\":1}}],[\"检查是否需要扩容\",{\"1\":{\"1431\":1}}],[\"检查是否为空\",{\"1\":{\"1379\":1}}],[\"检查是否有这个名字的临时表\",{\"1\":{\"549\":1}}],[\"检查慢日志记录是找出扫描行数过多的查询的好办法\",{\"1\":{\"524\":1}}],[\"遇到进程进入锁等待的情况时\",{\"1\":{\"613\":1}}],[\"选取其中成本更低的连接顺序去真正的执行查询\",{\"1\":{\"692\":1}}],[\"选出一个新的主库\",{\"1\":{\"625\":1}}],[\"选定一个从库执行查询语句\",{\"1\":{\"610\":1,\"611\":1}}],[\"选择一款mq学习就可以了\",{\"1\":{\"1863\":1}}],[\"选择发送的路由\",{\"0\":{\"1759\":1}}],[\"选择oneway形式发送\",{\"0\":{\"1733\":1}}],[\"选择并行流还是串行流\",{\"1\":{\"1494\":1}}],[\"选择正确的数据类型\",{\"1\":{\"664\":1}}],[\"选择了索引a\",{\"1\":{\"553\":1}}],[\"选择当前数字对应字符串的下一个值进行遍历\",{\"1\":{\"400\":1}}],[\"选择2\",{\"1\":{\"326\":1}}],[\"选择1\",{\"1\":{\"326\":1}}],[\"选择排序\",{\"0\":{\"318\":1},\"1\":{\"316\":1}}],[\"马上就可以获取对应位置的元素\",{\"1\":{\"1425\":1}}],[\"马上执行show\",{\"1\":{\"610\":1}}],[\"马上要返回主页面\",{\"1\":{\"607\":1}}],[\"仔细观察可以发现\",{\"1\":{\"609\":1}}],[\"严格地说\",{\"1\":{\"609\":1}}],[\"严谨地说\",{\"1\":{\"605\":1}}],[\"准确的说\",{\"1\":{\"1867\":1}}],[\"准确度确实提升了不少\",{\"1\":{\"609\":1}}],[\"准备\",{\"0\":{\"1666\":1},\"1\":{\"1540\":2}}],[\"准备一些资源\",{\"1\":{\"1528\":1}}],[\"准备唤醒阻塞在notfull上的线程\",{\"1\":{\"1380\":1}}],[\"准备唤醒阻塞在notempty上的线程\",{\"1\":{\"1380\":2}}],[\"准备唤醒一个阻塞在notfull条件上的线程\",{\"1\":{\"1380\":1}}],[\"准备唤醒生产者线程\",{\"1\":{\"1379\":1}}],[\"准备唤醒消费者线程\",{\"1\":{\"1379\":1}}],[\"准备数据\",{\"1\":{\"288\":1,\"1440\":1}}],[\"买家就可以通过这个现实\",{\"1\":{\"608\":1}}],[\"买家来逛商铺页面\",{\"1\":{\"607\":1}}],[\"商品发布后\",{\"1\":{\"608\":1}}],[\"商品类别\",{\"1\":{\"499\":1}}],[\"卖家发布商品后\",{\"1\":{\"607\":1}}],[\"过程描述如下\",{\"1\":{\"1524\":1}}],[\"过饱问题解决方案\",{\"0\":{\"1413\":1}}],[\"过于暴力\",{\"1\":{\"1354\":1}}],[\"过期策略可以设置\",{\"1\":{\"806\":1}}],[\"过期的key\",{\"1\":{\"706\":1}}],[\"过期读\",{\"1\":{\"606\":2}}],[\"过滤消息\",{\"0\":{\"1793\":1}}],[\"过滤类\",{\"0\":{\"1792\":1}}],[\"过滤服务器\",{\"0\":{\"1791\":1}}],[\"过滤阶段会消耗字符串集合\",{\"1\":{\"1500\":1}}],[\"过滤\",{\"1\":{\"1485\":1,\"1500\":1}}],[\"过滤掉不符合条件的记录之后再回表\",{\"1\":{\"655\":1}}],[\"过滤完成之后\",{\"1\":{\"540\":1}}],[\"过滤器和拦截器的区别\",{\"0\":{\"30\":1}}],[\"内容全面\",{\"1\":{\"1849\":1}}],[\"内容分别是\",{\"1\":{\"622\":1}}],[\"内核缓冲区和\",{\"1\":{\"1461\":1}}],[\"内核缓冲区后\",{\"1\":{\"1461\":1}}],[\"内核版本中\",{\"1\":{\"1459\":1,\"1460\":1,\"1461\":1}}],[\"内核空间总是驻留在内存中\",{\"1\":{\"1456\":1}}],[\"内核空间和用户空间\",{\"0\":{\"1456\":1}}],[\"内核模块运行在内核空间\",{\"1\":{\"1456\":1}}],[\"内核向进程返回一个文件描述符\",{\"1\":{\"1438\":1}}],[\"内核态\",{\"1\":{\"1360\":1}}],[\"内置锁的并发性能已经基本与lock持平\",{\"1\":{\"1360\":1}}],[\"内置复制\",{\"1\":{\"705\":1}}],[\"内建的resource实现\",{\"0\":{\"1200\":1}}],[\"内建可查找的依赖\",{\"0\":{\"1106\":1}}],[\"内联编程\",{\"0\":{\"793\":1}}],[\"内部迭代和外部迭代\",{\"0\":{\"1488\":1}}],[\"内部有一个先进先出的阻塞队列\",{\"1\":{\"1394\":1}}],[\"内部锁\",{\"1\":{\"1379\":1}}],[\"内部统计的方案主要是要利用磁盘利用率\",{\"1\":{\"616\":1}}],[\"内部统计\",{\"0\":{\"616\":1}}],[\"内部就已经自动完成了\",{\"1\":{\"605\":1}}],[\"内存屏障\",{\"0\":{\"1642\":1}}],[\"内存屏障在linux系统x86中的实现\",{\"1\":{\"1350\":1}}],[\"内存管理\",{\"0\":{\"1575\":1}}],[\"内存映射\",{\"1\":{\"1463\":1}}],[\"内存结构\",{\"1\":{\"1386\":1}}],[\"内存分页机制\",{\"0\":{\"790\":1}}],[\"内存是断电即失的\",{\"1\":{\"702\":1}}],[\"内存存储的数据结构服务器\",{\"1\":{\"705\":1}}],[\"内存存储\",{\"1\":{\"702\":1}}],[\"内存都不够用了\",{\"1\":{\"568\":1}}],[\"内存临时表排序的时候使用了rowid排序方法\",{\"1\":{\"558\":1}}],[\"内存临时表\",{\"0\":{\"557\":1}}],[\"内存临时表的大小是有限制的\",{\"1\":{\"553\":1}}],[\"内存可以放得下\",{\"1\":{\"553\":1}}],[\"内存里面也有一套机制区别不同的表\",{\"1\":{\"549\":1}}],[\"内存表\",{\"1\":{\"546\":1}}],[\"内存判断次数是不受选择哪个表作为驱动表影响的\",{\"1\":{\"540\":1}}],[\"内存判断是n\",{\"1\":{\"540\":1}}],[\"内存中的判断次数是m\",{\"1\":{\"540\":1}}],[\"内存中的行也比磁盘中的行的访问速度要快得多\",{\"1\":{\"526\":1}}],[\"内存和cpu的消耗\",{\"1\":{\"522\":1}}],[\"内存放不下\",{\"1\":{\"491\":1}}],[\"内存\",{\"1\":{\"482\":1,\"714\":1}}],[\"内存淘汰策略是怎么样的\",{\"0\":{\"153\":1}}],[\"内存溢出和内存泄漏的区别\",{\"0\":{\"125\":1}}],[\"内存模型的原子性\",{\"0\":{\"105\":1}}],[\"ƒsource\",{\"1\":{\"605\":1}}],[\"彻底解决了这个问题\",{\"1\":{\"605\":1}}],[\"跳过误操作的命令\",{\"1\":{\"623\":1}}],[\"跳过了表名自动补全的功能\",{\"1\":{\"619\":1}}],[\"跳过命令的写法是\",{\"1\":{\"604\":1}}],[\"跳表的问题\",{\"1\":{\"331\":1}}],[\"跳表\",{\"0\":{\"331\":1}}],[\"错误的订阅关系\",{\"0\":{\"1744\":1}}],[\"错误\",{\"1\":{\"604\":1}}],[\"指标监控等章节\",{\"1\":{\"1861\":1}}],[\"指针\",{\"1\":{\"1438\":2}}],[\"指针到数组尽头了\",{\"1\":{\"1379\":1}}],[\"指针指向的内存值是否和\",{\"1\":{\"1356\":1}}],[\"指向内核为每一个进程所维护的该进程打开文件的记录表\",{\"1\":{\"1438\":1}}],[\"指向了key\",{\"1\":{\"1428\":1}}],[\"指向了线程二重组后的链表\",{\"1\":{\"1428\":1}}],[\"指向的内存值交给exchange\",{\"1\":{\"1356\":1}}],[\"指向a\",{\"1\":{\"604\":1}}],[\"指令作为一种硬件原语\",{\"1\":{\"1356\":1}}],[\"指令的一层简单封装\",{\"1\":{\"1356\":1}}],[\"指令和\",{\"1\":{\"1356\":2}}],[\"指令\",{\"1\":{\"1356\":4}}],[\"指令是包含在\",{\"1\":{\"1356\":1}}],[\"指令添加\",{\"1\":{\"1356\":1}}],[\"指令队列\",{\"0\":{\"741\":1}}],[\"指同一时刻\",{\"1\":{\"1347\":2}}],[\"指定元空间触发full\",{\"1\":{\"1541\":1}}],[\"指定接口的时候\",{\"1\":{\"1531\":1}}],[\"指定\",{\"1\":{\"1527\":1}}],[\"指定下次扩容的大小\",{\"1\":{\"1431\":1}}],[\"指定异常处理器\",{\"1\":{\"1387\":1}}],[\"指定容量就是有界队列\",{\"1\":{\"1380\":1}}],[\"指定队列的大小创建有界队列\",{\"1\":{\"1380\":1}}],[\"指定多少毫秒之后\",{\"1\":{\"761\":1}}],[\"指定单位的参数\",{\"1\":{\"713\":1}}],[\"指定的字段是否存在\",{\"1\":{\"710\":1}}],[\"指定成本常数使用的存储引擎名称\",{\"1\":{\"694\":1}}],[\"指定为current\",{\"1\":{\"605\":1}}],[\"指的就是并发连接\",{\"1\":{\"613\":1}}],[\"指的就是sync\",{\"1\":{\"588\":1}}],[\"指的就是把日志写入到文件系统的page\",{\"1\":{\"587\":1}}],[\"指的是\",{\"1\":{\"1496\":1}}],[\"指的是将用户应用程序的缓冲区和操作系统的内核缓冲区进行映射处理\",{\"1\":{\"1458\":1}}],[\"指的是使用memory引擎的表\",{\"1\":{\"546\":1}}],[\"指的是查询从索引的最左前列开始并且不跳过索引中的字段\",{\"1\":{\"507\":1}}],[\"互不影响\",{\"1\":{\"1387\":1}}],[\"互斥同步\",{\"0\":{\"1694\":1}}],[\"互斥是保证临界区的竞态条件发生\",{\"1\":{\"1359\":1}}],[\"互斥量\",{\"1\":{\"1354\":1,\"1360\":1}}],[\"互斥问题\",{\"1\":{\"1347\":1}}],[\"互斥等待\",{\"1\":{\"518\":1}}],[\"互为主备\",{\"1\":{\"603\":1}}],[\"增加默认方法也可以看到\",{\"1\":{\"1484\":1}}],[\"增加默认方法的特性是java对于支持函数式编程一个非常重要的改变\",{\"1\":{\"1484\":1}}],[\"增加一个myinterface1的实现类\",{\"1\":{\"1484\":1}}],[\"增加了其他功能\",{\"1\":{\"1513\":1}}],[\"增加了多线程的支持\",{\"1\":{\"738\":1}}],[\"增加了一种完全耐久的持久化方式\",{\"1\":{\"729\":1}}],[\"增加了一个参数binlog\",{\"1\":{\"602\":1}}],[\"增强了程序的灵活性可移植性\",{\"1\":{\"1435\":1}}],[\"增大这个值会加重i\",{\"1\":{\"694\":1}}],[\"增大这个值可以让优化器倾向于使用索引而不是直接全表扫描\",{\"1\":{\"694\":1}}],[\"增删改\",{\"1\":{\"574\":1}}],[\"处\",{\"1\":{\"618\":1}}],[\"处于不能处理命令请求的状态\",{\"1\":{\"761\":1}}],[\"处于客户端已经收到提交确认\",{\"1\":{\"609\":1}}],[\"处于prepare状态的事务\",{\"1\":{\"602\":1}}],[\"处理socket连接\",{\"1\":{\"1561\":1}}],[\"处理spring容器的生命周期\",{\"1\":{\"1528\":1}}],[\"处理特定的host下客户请求\",{\"1\":{\"1561\":1}}],[\"处理桥接方法\",{\"1\":{\"1525\":1}}],[\"处理属性回调\",{\"1\":{\"1524\":1}}],[\"处理\",{\"1\":{\"1524\":1,\"1525\":2,\"1527\":1}}],[\"处理排除过滤器和包含过滤器\",{\"1\":{\"1524\":1}}],[\"处理后续的元素之前\",{\"1\":{\"1500\":1}}],[\"处理方式有两种\",{\"1\":{\"1484\":1}}],[\"处理完成通过输出流回应客户端\",{\"1\":{\"1450\":1}}],[\"处理完了继续过来轮询\",{\"1\":{\"740\":1}}],[\"处理的数据类型\",{\"1\":{\"1422\":1}}],[\"处理请求的方法\",{\"1\":{\"1534\":1}}],[\"处理请求\",{\"1\":{\"1410\":1,\"1411\":1}}],[\"处理查询结果集\",{\"1\":{\"806\":1}}],[\"处理其它事情\",{\"1\":{\"740\":1}}],[\"处理这种\",{\"1\":{\"606\":1}}],[\"处理正负号\",{\"1\":{\"388\":1}}],[\"处理下一个元素\",{\"1\":{\"362\":1}}],[\"处理散列冲突的方法\",{\"1\":{\"332\":1}}],[\"处理子问题\",{\"1\":{\"288\":1}}],[\"处理当前层逻辑\",{\"1\":{\"285\":1}}],[\"针对一个集合\",{\"1\":{\"1488\":1}}],[\"针对一个变量\",{\"1\":{\"1356\":1}}],[\"针对于int值的分割迭代器\",{\"1\":{\"1497\":1}}],[\"针对于iterable每一个元素去执行给定的动作\",{\"1\":{\"1472\":1}}],[\"针对于文档中提到相同的异常\",{\"1\":{\"1496\":1}}],[\"针对于之前的学生的集合\",{\"1\":{\"1493\":1}}],[\"针对于以上的例子\",{\"1\":{\"1480\":1}}],[\"针对于predicate可以定义\",{\"1\":{\"1476\":1}}],[\"针对于给定的t类型的参数t来计算\",{\"1\":{\"1476\":1}}],[\"针对这种场景\",{\"1\":{\"1375\":1}}],[\"针对重量级锁\",{\"1\":{\"1366\":1}}],[\"针对偏向锁\",{\"1\":{\"1366\":1}}],[\"针对的是主备切换时\",{\"1\":{\"604\":1}}],[\"针对并行度做了优化\",{\"1\":{\"602\":1}}],[\"针对所有的元素重复以上的步骤\",{\"1\":{\"317\":1}}],[\"强烈建议spliterator返回immutable\",{\"1\":{\"1498\":1}}],[\"强烈建议你不要这么做\",{\"1\":{\"455\":1}}],[\"强制将其发到主库上\",{\"1\":{\"607\":1}}],[\"强制走主库方案其实就是\",{\"1\":{\"607\":1}}],[\"强制走主库方案\",{\"0\":{\"607\":1},\"1\":{\"606\":1}}],[\"强行使用这个策略\",{\"1\":{\"600\":1}}],[\"耗时很长\",{\"1\":{\"618\":1}}],[\"耗费cpu\",{\"1\":{\"599\":1}}],[\"耗费内存\",{\"1\":{\"599\":1}}],[\"耗尽系统资源\",{\"1\":{\"530\":1}}],[\"级联更新的行不会记录在binlog中\",{\"1\":{\"599\":1}}],[\"里面实现了双亲委派机制\",{\"1\":{\"1540\":1}}],[\"里面的内容是实现者实现的类的完整的类限定名\",{\"1\":{\"1535\":1}}],[\"里面的流程却没有那么简单\",{\"1\":{\"1457\":1}}],[\"里面存的是部分属性为空的对象\",{\"1\":{\"1526\":1}}],[\"里面有大量的关于collector的实现\",{\"1\":{\"1495\":1}}],[\"里面有很多配置项\",{\"1\":{\"761\":1}}],[\"里面包含计划花费的成本\",{\"1\":{\"690\":1}}],[\"里面只放一行数据\",{\"1\":{\"614\":1}}],[\"里的\",{\"1\":{\"679\":1}}],[\"里的事务所涉及到的表\",{\"1\":{\"598\":1}}],[\"里取出满足条件的行\",{\"1\":{\"661\":1}}],[\"里创建一个表\",{\"1\":{\"614\":1}}],[\"里\",{\"1\":{\"598\":1}}],[\"待执行事务队列\",{\"1\":{\"598\":1}}],[\"待整个序列中的记录\",{\"1\":{\"320\":1}}],[\"各种协议和通信模型的组合有相应的具体实现类\",{\"1\":{\"1565\":1}}],[\"各种参数解释如下\",{\"1\":{\"1387\":1}}],[\"各种锁都会影响并发度\",{\"1\":{\"597\":1}}],[\"各个web项目之间可以提供共享的java类库\",{\"1\":{\"1571\":1}}],[\"各个web项目各自使用的java类库要相互隔离\",{\"1\":{\"1571\":1}}],[\"各个参数对应的含义\",{\"1\":{\"1541\":1}}],[\"各个字段的含义\",{\"1\":{\"695\":1}}],[\"各个字段的统计逻辑\",{\"1\":{\"616\":1}}],[\"各个变量的含义\",{\"1\":{\"675\":1}}],[\"各个版本的多线程复制\",{\"1\":{\"597\":1}}],[\"各走一步\",{\"1\":{\"377\":1}}],[\"切换次数\",{\"1\":{\"1459\":1,\"1460\":1,\"1461\":1}}],[\"切换数据库\",{\"1\":{\"704\":1}}],[\"切换的流程和结果\",{\"1\":{\"596\":1}}],[\"切到db1库\",{\"1\":{\"619\":1}}],[\"切分查询\",{\"0\":{\"530\":1}}],[\"试想\",{\"1\":{\"1484\":1}}],[\"试想如果一开始主备延迟就长达30分钟\",{\"1\":{\"595\":1}}],[\"试图插入临时表中\",{\"1\":{\"551\":1}}],[\"造成瞬时db请求量大\",{\"1\":{\"766\":1,\"769\":1}}],[\"造成数据库极大的压力\",{\"1\":{\"763\":1}}],[\"造成主备延迟\",{\"1\":{\"597\":1}}],[\"造成主备不一致\",{\"1\":{\"590\":1}}],[\"造成了主备延迟\",{\"1\":{\"594\":1}}],[\"死信队列\",{\"0\":{\"1717\":1}}],[\"死循环在这里就断掉了\",{\"1\":{\"592\":1}}],[\"死锁检测的时间复杂度与并发量正相关\",{\"1\":{\"581\":1}}],[\"死锁检测要耗费大量的cpu资源\",{\"1\":{\"581\":1}}],[\"死锁和死锁检测\",{\"0\":{\"581\":1}}],[\"死锁\",{\"1\":{\"568\":1}}],[\"死锁与饥饿的区别\",{\"0\":{\"66\":1}}],[\"死锁与活锁的区别\",{\"0\":{\"65\":1}}],[\"恢复的速度要快\",{\"1\":{\"733\":1}}],[\"恢复的时候就把这个文件全部再执行一遍\",{\"1\":{\"728\":1}}],[\"恢复速度\",{\"1\":{\"732\":1}}],[\"恢复时间不可控\",{\"1\":{\"623\":1}}],[\"恢复回主库\",{\"1\":{\"621\":1}}],[\"恢复出一个备份\",{\"1\":{\"621\":1}}],[\"恢复出来的这一行的c的值就是1\",{\"1\":{\"464\":1}}],[\"恢复出来的这一行c的值就是0\",{\"1\":{\"464\":1}}],[\"恢复gtid的默认分配行为\",{\"1\":{\"605\":1}}],[\"恢复并行模式\",{\"1\":{\"599\":1}}],[\"恢复数据集的速度也要比\",{\"1\":{\"733\":1}}],[\"恢复数据的思路主要就是通过备份\",{\"1\":{\"622\":1}}],[\"恢复数据的流程如下\",{\"1\":{\"622\":1}}],[\"恢复数据比较安全的做法是\",{\"1\":{\"621\":1}}],[\"恢复数据\",{\"1\":{\"591\":1}}],[\"却可以重复\",{\"1\":{\"711\":1}}],[\"却无法知道它为什么做这个决策\",{\"1\":{\"681\":1}}],[\"却使用了索引t\",{\"1\":{\"591\":1}}],[\"却不知道这条语句在mysql内部的执行过程\",{\"1\":{\"454\":1}}],[\"甚至可以\",{\"1\":{\"1494\":1}}],[\"甚至加锁的操作是出现在循环体中的\",{\"1\":{\"1363\":1}}],[\"甚至直接崩溃\",{\"1\":{\"737\":1}}],[\"甚至连注释也一并记录了\",{\"1\":{\"591\":1}}],[\"甚至join这样的操作\",{\"1\":{\"548\":1}}],[\"忠实\",{\"1\":{\"591\":1}}],[\"命令模式\",{\"0\":{\"1011\":1}}],[\"命令发送给频道\",{\"1\":{\"733\":1}}],[\"命令入队\",{\"1\":{\"716\":2}}],[\"命令相似\",{\"1\":{\"707\":1}}],[\"命令行查看数据库数量databases\",{\"1\":{\"704\":1}}],[\"命令并不是一个事务的起点\",{\"1\":{\"679\":1}}],[\"命令之后的delete语句\",{\"1\":{\"591\":1}}],[\"命令\",{\"0\":{\"734\":1},\"1\":{\"591\":1,\"608\":1,\"622\":1,\"627\":1,\"707\":1,\"708\":1,\"709\":1,\"710\":1,\"711\":1,\"713\":1,\"714\":1,\"715\":1,\"726\":1,\"734\":1}}],[\"密码后\",{\"1\":{\"590\":1}}],[\"密码\",{\"1\":{\"590\":1}}],[\"端口号\",{\"1\":{\"746\":1}}],[\"端口\",{\"1\":{\"590\":1,\"604\":1}}],[\"专门用于服务备库b的这个长连接\",{\"1\":{\"590\":1}}],[\"专门用来存放临时文件的数据\",{\"1\":{\"549\":1}}],[\"权限用户是无效的\",{\"1\":{\"590\":1}}],[\"拖时间\",{\"1\":{\"588\":1}}],[\"节省了很多计算量\",{\"1\":{\"602\":1}}],[\"节点key存在\",{\"1\":{\"1426\":1}}],[\"节点\",{\"1\":{\"1386\":1}}],[\"节点可用性的检测都应该包含主库和备库\",{\"1\":{\"615\":1}}],[\"节点b生成的binlog的server\",{\"1\":{\"592\":1}}],[\"节点b执行完这条更新语句后也会生成binlog\",{\"1\":{\"592\":1}}],[\"节点a和b之间总是互为主备关系\",{\"1\":{\"592\":1}}],[\"节点的定义\",{\"1\":{\"337\":1}}],[\"节约iops的效果就越好\",{\"1\":{\"588\":1}}],[\"节约磁盘iops效果越好\",{\"1\":{\"588\":1}}],[\"带来非常大的开销\",{\"1\":{\"1356\":1}}],[\"带有lock前缀的指令在执行期间会锁住总线\",{\"1\":{\"1350\":1}}],[\"带上距离\",{\"1\":{\"713\":1}}],[\"带上坐标\",{\"1\":{\"713\":1}}],[\"带权重进行判断\",{\"1\":{\"711\":1}}],[\"带proxy架构的整体就相对比较复杂\",{\"1\":{\"606\":1}}],[\"带proxy的结构\",{\"1\":{\"606\":1}}],[\"带的就是lsn=160\",{\"1\":{\"588\":1}}],[\"带头大哥不能死\",{\"1\":{\"507\":1}}],[\"顺带将这个事务的redo\",{\"1\":{\"588\":1}}],[\"顺序消费\",{\"0\":{\"1737\":1,\"1739\":1}}],[\"顺序不同\",{\"1\":{\"1359\":1}}],[\"顺序是从输出寄存器序列从左到右从上到下以\",{\"1\":{\"1356\":1}}],[\"顺序写磁盘上的日志文件的性能也是很高的\",{\"1\":{\"680\":1}}],[\"顺序扫描\",{\"1\":{\"554\":1}}],[\"顺序性\",{\"1\":{\"541\":1,\"715\":1}}],[\"顺序读取最后的12行数据放入join\",{\"1\":{\"540\":1}}],[\"顺序读取数据行放入join\",{\"1\":{\"540\":1}}],[\"物理上是在文件系统的page\",{\"1\":{\"588\":1}}],[\"物理上是在mysql进程内存中\",{\"1\":{\"588\":1}}],[\"物理结构可以分为顺序存储结构和链式存储结构\",{\"1\":{\"328\":1}}],[\"∞\",{\"1\":{\"585\":1}}],[\"影子分页\",{\"1\":{\"698\":1}}],[\"影院的账户总额等于这10个记录的值的总和\",{\"1\":{\"581\":1}}],[\"影响用户体验\",{\"1\":{\"1450\":1}}],[\"影响的是可用性\",{\"1\":{\"632\":1}}],[\"影响的是数据可靠性\",{\"1\":{\"632\":1}}],[\"影响了同步速度\",{\"1\":{\"594\":1}}],[\"影响执行速度\",{\"1\":{\"591\":1}}],[\"影响会更大\",{\"1\":{\"562\":1}}],[\"影响内存命中率\",{\"1\":{\"543\":1}}],[\"影响到性能外\",{\"1\":{\"488\":1}}],[\"顾客a要在影院b购买电影票\",{\"1\":{\"580\":1}}],[\"顾名思义指的就是总和\",{\"1\":{\"616\":1}}],[\"顾名思义\",{\"1\":{\"574\":1,\"585\":1}}],[\"防止出现链表成环\",{\"1\":{\"1431\":1}}],[\"防止切换逻辑有bug\",{\"1\":{\"590\":1}}],[\"防止数据丢失\",{\"0\":{\"586\":1}}],[\"防止记录插入\",{\"1\":{\"579\":1}}],[\"防止一个单词里面有多个char的时候hash是一样的\",{\"1\":{\"302\":1}}],[\"间隙\",{\"1\":{\"585\":1}}],[\"间隙锁只有在可重复读的隔离级别下才会生效的\",{\"1\":{\"673\":1}}],[\"间隙锁在某些情况下可以解决幻读的问题\",{\"1\":{\"673\":1}}],[\"间隙锁和行锁合称next\",{\"1\":{\"585\":1}}],[\"间隙锁之间不存在冲突关系\",{\"1\":{\"585\":1}}],[\"间隙锁\",{\"0\":{\"582\":1,\"585\":1,\"673\":1},\"1\":{\"579\":1,\"585\":1,\"673\":1}}],[\"间隙和加锁的状态其实是这样的\",{\"1\":{\"561\":1}}],[\"间隙和加锁状态应该如下图\",{\"1\":{\"561\":1}}],[\"拿回原库重放\",{\"1\":{\"621\":1}}],[\"拿不到也不要阻塞后面的业务语句\",{\"1\":{\"578\":1}}],[\"拿到合并后的beanfinition\",{\"1\":{\"1524\":1}}],[\"拿到sql语句\",{\"1\":{\"807\":1}}],[\"拿到事件后\",{\"1\":{\"740\":1}}],[\"拿到以后再取最后6个字节的话就是0\",{\"1\":{\"632\":1}}],[\"拿到的自增id就是3\",{\"1\":{\"628\":1}}],[\"拿到第一行id=1000\",{\"1\":{\"551\":1}}],[\"拿到分库的数据以后\",{\"1\":{\"548\":1}}],[\"删掉这被误插入的一行数据就可以了\",{\"1\":{\"591\":1}}],[\"删了一列\",{\"1\":{\"578\":1}}],[\"删除元素\",{\"1\":{\"1415\":1}}],[\"删除元素的时间复杂度也变为了o\",{\"1\":{\"1379\":1}}],[\"删除元素的时间复杂度o\",{\"1\":{\"329\":1,\"330\":1}}],[\"删除studentx\",{\"1\":{\"710\":1}}],[\"删除哈希表key中一个\",{\"1\":{\"710\":1}}],[\"删除\",{\"1\":{\"709\":1,\"1423\":1,\"1425\":1}}],[\"删除后\",{\"1\":{\"708\":2}}],[\"删除列表中所有的指定value\",{\"1\":{\"708\":1}}],[\"删除个数\",{\"1\":{\"706\":1}}],[\"删除键值对\",{\"1\":{\"706\":2}}],[\"删除表锁\",{\"1\":{\"671\":1}}],[\"删除表的动作必须通过管理系统执行\",{\"1\":{\"624\":1}}],[\"删除临时文件可能需要等待io资源\",{\"1\":{\"618\":1}}],[\"删除旧的数据就是一个很好的例子\",{\"1\":{\"530\":1}}],[\"删除book表的索引\",{\"1\":{\"499\":1}}],[\"删除刚才添加到末尾的元素\",{\"1\":{\"400\":1}}],[\"删除链表的倒数第n个节点\",{\"0\":{\"375\":1}}],[\"删除皆为o\",{\"1\":{\"333\":1,\"334\":1}}],[\"元空间无固定初始大小\",{\"1\":{\"1541\":1}}],[\"元本身管理并发修改\",{\"1\":{\"1497\":1}}],[\"元的结构是不能被修改的\",{\"1\":{\"1497\":1}}],[\"元的数据只有在需要的时候才会被消费\",{\"1\":{\"1496\":1}}],[\"元\",{\"1\":{\"1497\":1}}],[\"元中的元素可以是数组\",{\"1\":{\"1497\":1}}],[\"元数据读取器\",{\"1\":{\"1524\":1}}],[\"元数据指针\",{\"1\":{\"1361\":1}}],[\"元数据锁\",{\"0\":{\"578\":1}}],[\"元信息解析阶段\",{\"0\":{\"1156\":1}}],[\"元信息配置阶段\",{\"0\":{\"1155\":1}}],[\"元素如果可用的话会发送给任意一个线程\",{\"1\":{\"1500\":1}}],[\"元素在重新计算hash之后\",{\"1\":{\"1427\":1}}],[\"元素的添加\",{\"1\":{\"1497\":1}}],[\"元素的顺序与之前的保持一致\",{\"1\":{\"1497\":1}}],[\"元素的顺序不是很重要的话\",{\"1\":{\"1495\":1}}],[\"元素的特性值ordered\",{\"1\":{\"1497\":1}}],[\"元素的位置要么是在原来的位置\",{\"1\":{\"1427\":1}}],[\"元素的大小默认是通过元素本身的自然顺序\",{\"1\":{\"353\":1}}],[\"元素位置定位\",{\"1\":{\"1396\":1}}],[\"元素数量\",{\"1\":{\"1380\":1}}],[\"元素个数\",{\"1\":{\"1379\":1}}],[\"元素基本有序\",{\"1\":{\"316\":1}}],[\"风险较高\",{\"1\":{\"575\":1}}],[\"导入依赖\",{\"1\":{\"720\":1}}],[\"导入jredis的包\",{\"1\":{\"719\":1}}],[\"导入相关依赖\",{\"1\":{\"719\":1}}],[\"导数据之前就会启动一个事务\",{\"1\":{\"575\":1}}],[\"导致iscandidatecomponent只会认为接口是备选者component\",{\"1\":{\"1530\":1}}],[\"导致key\",{\"1\":{\"1428\":1}}],[\"导致任务不断堆积到阻塞队列中\",{\"1\":{\"1413\":1}}],[\"导致生产者\",{\"1\":{\"1413\":1}}],[\"导致内存溢出\",{\"1\":{\"1396\":1}}],[\"导致内存泄漏的原因是什么\",{\"0\":{\"82\":1}}],[\"导致\",{\"1\":{\"1356\":1}}],[\"导致在缓存在同一时刻全部失效\",{\"1\":{\"769\":1}}],[\"导致耗时较长\",{\"1\":{\"618\":1}}],[\"导致不能及时判断线程的状态\",{\"1\":{\"618\":1}}],[\"导致实例x的同步线程停止\",{\"1\":{\"605\":1}}],[\"导致主备延迟达到5秒\",{\"1\":{\"596\":1}}],[\"导致能集合到一起持久化的binlog比较少\",{\"1\":{\"588\":1}}],[\"导致打开表文件的个数超过了上限而报错\",{\"1\":{\"562\":1}}],[\"导致表t2会被扫描两次\",{\"1\":{\"540\":1}}],[\"导致了e指向了key\",{\"1\":{\"1428\":1}}],[\"导致了全索引扫描\",{\"1\":{\"503\":1}}],[\"导致了更长的执行时间\",{\"1\":{\"483\":1}}],[\"配合读写分离\",{\"1\":{\"744\":1}}],[\"配合semi\",{\"1\":{\"606\":1}}],[\"配置太繁琐了\",{\"1\":{\"1861\":1}}],[\"配置管理\",{\"0\":{\"1748\":1}}],[\"配置类\",{\"0\":{\"1751\":1}}],[\"配置类加载的主要的类\",{\"1\":{\"1529\":1}}],[\"配置类解析与扫描过程源码解析\",{\"0\":{\"1529\":1}}],[\"配置加载和缓存处理\",{\"1\":{\"806\":1}}],[\"配置当某一事件发生时所需要执行的脚本\",{\"1\":{\"761\":1}}],[\"配置所有slaves指向新的master所需的最大时间\",{\"1\":{\"761\":1}}],[\"配置redis\",{\"1\":{\"720\":1}}],[\"配置为logical\",{\"1\":{\"602\":1}}],[\"配置为database\",{\"1\":{\"602\":1}}],[\"配置\",{\"1\":{\"588\":1}}],[\"配套的提交语句是commit\",{\"1\":{\"572\":1}}],[\"配对问题\",{\"1\":{\"356\":1}}],[\"未知的\",{\"1\":{\"1497\":1}}],[\"未来可能会定义一些新的characteristics\",{\"1\":{\"1497\":1}}],[\"未满就唤醒其它notfull上的线程\",{\"1\":{\"1380\":1}}],[\"未正确同步的多线程程序\",{\"1\":{\"1351\":1}}],[\"未同步\",{\"1\":{\"1351\":1}}],[\"未设置默认是0\",{\"1\":{\"715\":1}}],[\"未提交变更对其它事务也是不可见的\",{\"1\":{\"570\":1}}],[\"未遍历过\",{\"1\":{\"435\":1}}],[\"隔离级别会依赖于数据库\",{\"1\":{\"1532\":1}}],[\"隔离级别下直接用加锁的方式来避免并行访问\",{\"1\":{\"570\":1}}],[\"隔离级别下直接返回记录上的最新值\",{\"1\":{\"570\":1}}],[\"隔离级别下\",{\"1\":{\"570\":2}}],[\"隔离级别越高\",{\"1\":{\"570\":1}}],[\"隔离级别\",{\"1\":{\"570\":1,\"669\":1}}],[\"隔离性和隔离级别\",{\"0\":{\"570\":1}}],[\"隔离性\",{\"1\":{\"569\":1}}],[\"持有锁的线程唤醒被因调用condition\",{\"1\":{\"1370\":1}}],[\"持久化aof\",{\"0\":{\"728\":1}}],[\"持久化功能有效避免因进程退出造成的数据丢失问题\",{\"1\":{\"721\":1}}],[\"持久化\",{\"1\":{\"702\":1,\"703\":1,\"729\":1,\"733\":2}}],[\"持久化到磁盘的过程\",{\"1\":{\"588\":1}}],[\"持久化到磁盘\",{\"1\":{\"588\":1}}],[\"持久性\",{\"1\":{\"569\":1}}],[\"持续这个压力的话\",{\"1\":{\"634\":1}}],[\"持续叠加\",{\"1\":{\"628\":1}}],[\"持续观察\",{\"1\":{\"604\":1}}],[\"持续时间\",{\"1\":{\"568\":1}}],[\"持续集成\",{\"0\":{\"237\":1}}],[\"危险\",{\"1\":{\"568\":1}}],[\"日期值\",{\"1\":{\"666\":1}}],[\"日期和时间\",{\"0\":{\"666\":1}}],[\"日常也都规定只使用只读账号\",{\"1\":{\"624\":1}}],[\"日常开发需要注意的结论\",{\"1\":{\"568\":1}}],[\"日志体系\",{\"0\":{\"1556\":1}}],[\"日志场景\",{\"0\":{\"905\":1}}],[\"日志文件名\",{\"1\":{\"746\":1}}],[\"日志是写在123这个位置之后的\",{\"1\":{\"604\":1}}],[\"日志从主库传给备库所需的时间是很短的\",{\"1\":{\"594\":1}}],[\"日志的执行流程就会变成这样\",{\"1\":{\"592\":1}}],[\"日志写入到redo\",{\"1\":{\"588\":1}}],[\"日志分析工具mysqldumpslow\",{\"1\":{\"566\":1}}],[\"日志分析工具\",{\"0\":{\"566\":1}}],[\"日志类的系统\",{\"1\":{\"481\":1}}],[\"诊断sql\",{\"1\":{\"568\":1}}],[\"观察有异常发生的情况\",{\"1\":{\"1496\":1}}],[\"观察结果\",{\"1\":{\"1494\":1}}],[\"观察不难发现\",{\"1\":{\"1475\":1}}],[\"观察者模式\",{\"0\":{\"894\":1,\"1009\":1},\"1\":{\"1396\":1}}],[\"观察一段时间\",{\"1\":{\"624\":1}}],[\"观察\",{\"1\":{\"567\":1}}],[\"希望能收集超过5秒钟的sql\",{\"1\":{\"565\":1}}],[\"希尔排序\",{\"0\":{\"320\":1},\"1\":{\"316\":1}}],[\"意向拍他锁\",{\"1\":{\"670\":1}}],[\"意向共享锁\",{\"1\":{\"670\":1}}],[\"意向锁主要分为\",{\"1\":{\"670\":1}}],[\"意向锁\",{\"1\":{\"670\":1}}],[\"意思是运行10秒以上的语句\",{\"1\":{\"565\":1}}],[\"意味着中间结果容器的类型和最终返回的结果类型相同\",{\"1\":{\"1495\":1}}],[\"意味着对应的成本常数使用于所有的存储引擎\",{\"1\":{\"694\":1}}],[\"意味着对应的成本常数会采用默认值\",{\"1\":{\"694\":1}}],[\"意味着对于某条记录应用只需要查询一次\",{\"1\":{\"531\":1}}],[\"意味着记录已被删除\",{\"1\":{\"679\":1}}],[\"意味着少了两个binlog文件\",{\"1\":{\"622\":1}}],[\"意味着如果采用第一个策略\",{\"1\":{\"581\":1}}],[\"意味着如果只执行一个select语句\",{\"1\":{\"572\":1}}],[\"意味着访问磁盘数据的次数越小\",{\"1\":{\"484\":1}}],[\"效果跟drop普通表类似\",{\"1\":{\"563\":1}}],[\"效率上的考量等等\",{\"1\":{\"1497\":1}}],[\"效率并不高\",{\"1\":{\"1464\":1}}],[\"效率更高\",{\"1\":{\"1462\":2}}],[\"效率相对较低\",{\"1\":{\"708\":1}}],[\"效率最高\",{\"1\":{\"708\":1,\"730\":1}}],[\"效率很高\",{\"1\":{\"533\":1,\"1464\":1}}],[\"效率不错\",{\"1\":{\"467\":1}}],[\"效率就会很高\",{\"1\":{\"456\":1}}],[\"必备技能\",{\"1\":{\"1844\":1}}],[\"必要\",{\"1\":{\"1375\":1}}],[\"必要的时候才使用有更新权限的账号\",{\"1\":{\"624\":1}}],[\"必要的分区\",{\"1\":{\"562\":1}}],[\"必须自己写代码去调用lucene的接口\",{\"1\":{\"1864\":1}}],[\"必须调用end方法\",{\"1\":{\"1500\":1}}],[\"必须在分割之后\",{\"1\":{\"1497\":1}}],[\"必须要保证其中一个不为空\",{\"1\":{\"1498\":1}}],[\"必须要保证cells数组只能被初始化一次\",{\"1\":{\"1357\":1}}],[\"必须要遵守下面的约定\",{\"1\":{\"1492\":1}}],[\"必须要联系他的上下文才能知道\",{\"1\":{\"1472\":1}}],[\"必须要等到无延迟才能查询的方案\",{\"1\":{\"609\":1}}],[\"必须是对于t类型的原生类型的特化\",{\"1\":{\"1497\":1}}],[\"必须是以下单位的其中一个\",{\"1\":{\"713\":1}}],[\"必须是一个可以被唤醒的等待\",{\"1\":{\"618\":1}}],[\"必须出现如下场景\",{\"1\":{\"633\":1}}],[\"必须等到一个事务执行完成并提交\",{\"1\":{\"628\":1}}],[\"必须先对表做改名操作\",{\"1\":{\"624\":1}}],[\"必须先判断在网格中\",{\"1\":{\"435\":1}}],[\"必须经过sql审计\",{\"1\":{\"621\":1}}],[\"必须这么设计\",{\"1\":{\"613\":1}}],[\"必须放到同一个worker中\",{\"1\":{\"597\":1}}],[\"必须被分发到同一个worker中\",{\"1\":{\"597\":1}}],[\"必须保证要有定期全量备份的能力\",{\"1\":{\"594\":1}}],[\"必须读取下一个数据页\",{\"1\":{\"479\":1}}],[\"必须做自平衡\",{\"1\":{\"345\":1}}],[\"目标对象\",{\"1\":{\"1531\":1}}],[\"目标文件\",{\"1\":{\"1465\":1}}],[\"目标函数单调\",{\"1\":{\"304\":1}}],[\"目的也是保证数据的可见性\",{\"1\":{\"1375\":1}}],[\"目的是为了返回一个效率更高的分割迭代器\",{\"1\":{\"1497\":1}}],[\"目的是为了保证只读事务显示的trx\",{\"1\":{\"634\":1}}],[\"目的是要让备库重新识别这两个日志文件\",{\"1\":{\"622\":1}}],[\"目录往往有更长的延迟\",{\"1\":{\"1351\":1}}],[\"目前企业里用的比较多的是rocketmq和kafka\",{\"1\":{\"1863\":1}}],[\"目前业界有很多mq产品\",{\"1\":{\"1863\":1}}],[\"目前在各大互联网公司基本不再使用\",{\"1\":{\"1856\":1}}],[\"目前使用最广泛的是druid\",{\"1\":{\"1852\":1}}],[\"目前只支持一下两种\",{\"1\":{\"1463\":1}}],[\"目前apache\",{\"1\":{\"1396\":1}}],[\"目前<state>总是\",{\"1\":{\"761\":1}}],[\"目前来看\",{\"1\":{\"562\":1}}],[\"明显只需要访问一个分区\",{\"1\":{\"562\":1}}],[\"明显就是回文串\",{\"1\":{\"428\":1}}],[\"手动清理threadlocal\",{\"1\":{\"1405\":1}}],[\"手动到自动\",{\"1\":{\"760\":1}}],[\"手动\",{\"1\":{\"748\":2}}],[\"手动增加表锁\",{\"1\":{\"671\":1}}],[\"手工分表的逻辑\",{\"1\":{\"561\":1}}],[\"手机\",{\"1\":{\"500\":1}}],[\"落到其它分区的查询时不受影响的\",{\"1\":{\"561\":1}}],[\"拼出\",{\"1\":{\"559\":1}}],[\"行为是调用的时候才动态的调用执行\",{\"1\":{\"1475\":1}}],[\"行为型模式\",{\"0\":{\"1006\":1}}],[\"行\",{\"1\":{\"558\":1}}],[\"行锁分析\",{\"0\":{\"675\":1}}],[\"行锁可能会变表锁\",{\"1\":{\"674\":1}}],[\"行锁的之间的冲突关系是\",{\"1\":{\"585\":1}}],[\"行锁只能锁住行\",{\"1\":{\"585\":1}}],[\"行锁是在需要的时候才加上的\",{\"1\":{\"580\":1}}],[\"行锁顾名思义\",{\"1\":{\"579\":1}}],[\"行锁\",{\"0\":{\"579\":1,\"672\":1},\"1\":{\"525\":1}}],[\"变更属性的内容和执行特定的方法的功能\",{\"1\":{\"1435\":1}}],[\"变长字符串\",{\"1\":{\"667\":1}}],[\"变长定长等\",{\"1\":{\"664\":1}}],[\"变成空队列\",{\"1\":{\"599\":1}}],[\"变成了worker线程\",{\"1\":{\"597\":1}}],[\"变成了20000\",{\"1\":{\"557\":1}}],[\"变色\",{\"1\":{\"343\":1}}],[\"磁盘临时表使用的引擎默认是innodb\",{\"1\":{\"558\":1}}],[\"磁盘临时表\",{\"0\":{\"558\":1}}],[\"磁盘临时表默认使用的引擎是innodb\",{\"1\":{\"553\":1}}],[\"磁盘文件名也不同\",{\"1\":{\"549\":1}}],[\"虚拟机\",{\"1\":{\"1870\":1}}],[\"虚拟机栈\",{\"0\":{\"1581\":1}}],[\"虚拟机采用cas分配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理\",{\"1\":{\"1545\":1}}],[\"虚拟机遇到一条new指令时\",{\"1\":{\"1543\":1}}],[\"虚拟机并不会立即升级为重量级锁\",{\"1\":{\"1362\":1}}],[\"虚拟机通过这个指针来确定这个对象是哪个类的实例\",{\"1\":{\"1361\":1}}],[\"虚拟机对compareandswapint\",{\"1\":{\"1356\":1}}],[\"虚拟机基础故障处理工具有哪些\",{\"0\":{\"128\":1}}],[\"虚线箭头表示的是主备关系\",{\"1\":{\"603\":1}}],[\"虚线框内表示临时表的排序过程\",{\"1\":{\"553\":1}}],[\"发帖\",{\"1\":{\"1865\":1}}],[\"发布消息\",{\"1\":{\"735\":1}}],[\"发布消息到sakura频道\",{\"1\":{\"735\":1}}],[\"发布订阅\",{\"1\":{\"733\":1}}],[\"发布订阅系统\",{\"1\":{\"702\":1}}],[\"发送事务消息\",{\"0\":{\"1754\":1,\"1817\":1}}],[\"发送普通消息\",{\"0\":{\"1753\":1}}],[\"发送消息\",{\"0\":{\"1752\":1},\"1\":{\"733\":1,\"1398\":1}}],[\"发送者\",{\"1\":{\"733\":1}}],[\"发生concurrentmodificationexception可能性就会增加\",{\"1\":{\"1497\":1}}],[\"发生当前对象的epoch值和class的epoch不想等\",{\"1\":{\"1362\":1}}],[\"发生锁冲突的概率最低\",{\"1\":{\"672\":1}}],[\"发生锁冲突的概率最高\",{\"1\":{\"671\":1}}],[\"发生了数据不一致\",{\"1\":{\"584\":1}}],[\"发一个信号的目的\",{\"1\":{\"618\":1}}],[\"发回给主库一个ack\",{\"1\":{\"609\":1}}],[\"发起了主备切换\",{\"1\":{\"596\":1}}],[\"发起死锁检测\",{\"1\":{\"581\":1}}],[\"发给b\",{\"1\":{\"590\":1,\"605\":1}}],[\"发给客户端\",{\"1\":{\"551\":1}}],[\"发现b和c的连接成本就已经大于10\",{\"1\":{\"693\":1}}],[\"发现并没有使用name字段的索引\",{\"1\":{\"659\":1}}],[\"发现执行时间太久\",{\"1\":{\"617\":1}}],[\"发现异常后\",{\"1\":{\"616\":1}}],[\"发现删错数据了\",{\"1\":{\"591\":1}}],[\"发现死锁后\",{\"1\":{\"581\":1}}],[\"发现内存临时表不够用了再转成磁盘临时表\",{\"1\":{\"555\":1}}],[\"发现不同线程可以创建同名的临时表\",{\"1\":{\"549\":1}}],[\"发现仍然是\",{\"1\":{\"487\":1}}],[\"发现已经不满足email=\",{\"1\":{\"487\":1}}],[\"违反了唯一性约束\",{\"1\":{\"551\":1}}],[\"备库和临时实例里面\",{\"1\":{\"629\":1}}],[\"备库各自的检测命令不会发生冲突\",{\"1\":{\"615\":1}}],[\"备库同步线程发生异常\",{\"1\":{\"610\":1}}],[\"备库从状态1到状态4都和主库a存在延迟\",{\"1\":{\"609\":1}}],[\"备库收到的日志都执行完成了\",{\"1\":{\"609\":1}}],[\"备库收到\",{\"1\":{\"609\":1}}],[\"备库指定哪个点位\",{\"1\":{\"605\":1}}],[\"备库上已经删除了临时实例需要的binlog的话\",{\"1\":{\"622\":1}}],[\"备库上的执行效果如下\",{\"1\":{\"601\":1}}],[\"备库上的查询耗费了大量的cpu资源\",{\"1\":{\"594\":1}}],[\"备库上也一定是可以并行执行的\",{\"1\":{\"601\":1}}],[\"备库上有一个查询\",{\"1\":{\"597\":1}}],[\"备库提供读能力\",{\"1\":{\"594\":1}}],[\"备库的检测也是要写bin\",{\"1\":{\"615\":1}}],[\"备库的压力大\",{\"1\":{\"594\":1}}],[\"备库的应用日志线程是共用的\",{\"1\":{\"550\":1}}],[\"备库随时可能变成主库\",{\"1\":{\"594\":1}}],[\"备库所在的机器的性能要比主库所在的机器性能差\",{\"1\":{\"594\":1}}],[\"备库消费中转日志\",{\"1\":{\"594\":1}}],[\"备库在执行seconds\",{\"1\":{\"594\":1}}],[\"备库在执行到insert\",{\"1\":{\"550\":1}}],[\"备库连接到主库的时候\",{\"1\":{\"594\":1}}],[\"备库取出当前正在执行的事务的时间字段的值\",{\"1\":{\"594\":1}}],[\"备库就能达到跟主库一致的状态\",{\"1\":{\"593\":1}}],[\"备库b要设置为新主库a\",{\"1\":{\"605\":1}}],[\"备库b的\",{\"1\":{\"596\":1}}],[\"备库b执行完成这个事务\",{\"1\":{\"594\":1}}],[\"备库b拿到binlog后\",{\"1\":{\"590\":1}}],[\"备库b和主库a之间维持了一个长连接\",{\"1\":{\"590\":1}}],[\"备库可以和主库保持同步更新\",{\"1\":{\"590\":1}}],[\"备库虽然设置了readonly\",{\"1\":{\"590\":1}}],[\"操作数栈\",{\"0\":{\"1679\":1},\"1\":{\"1541\":1}}],[\"操作都是类似的\",{\"1\":{\"1498\":1}}],[\"操作的时候不会将process阻塞\",{\"1\":{\"1444\":1}}],[\"操作的时候会将process阻塞\",{\"1\":{\"1444\":1}}],[\"操作上\",{\"1\":{\"1394\":1}}],[\"操作系统\",{\"1\":{\"1844\":1}}],[\"操作系统通过dma控制器从磁盘中读取数据\",{\"1\":{\"1457\":1}}],[\"操作系统会给应用程序分配一个单独的用户空间\",{\"1\":{\"1456\":1}}],[\"操作系统将虚拟内存划分为两个部分\",{\"1\":{\"1456\":1}}],[\"操作系统的核心是内核\",{\"1\":{\"1456\":1}}],[\"操作系统的发展史\",{\"0\":{\"774\":1}}],[\"操作系统层面的线程生命周期可以用\",{\"1\":{\"1354\":1}}],[\"操作系统分类\",{\"0\":{\"773\":1}}],[\"操作list\",{\"1\":{\"720\":1}}],[\"操作字符串\",{\"1\":{\"720\":1}}],[\"操作不同的数据类型\",{\"1\":{\"720\":1}}],[\"操作不慎的话\",{\"1\":{\"578\":1}}],[\"操作过程\",{\"0\":{\"716\":1}}],[\"操作\",{\"1\":{\"549\":1,\"1356\":1,\"1375\":2,\"1431\":2,\"1460\":1}}],[\"库可以自由的对输入元素分组与分区\",{\"1\":{\"1492\":1}}],[\"库迁移等操作的时候\",{\"1\":{\"606\":1}}],[\"库名\",{\"1\":{\"598\":1}}],[\"库名+t1+\",{\"1\":{\"550\":2}}],[\"库名+表名+索引名+值\",{\"1\":{\"602\":1}}],[\"库名+表名+索引a的名字+a的值\",{\"1\":{\"599\":1}}],[\"库名+表名+唯一键的值\",{\"1\":{\"599\":1}}],[\"库名+表名\",{\"1\":{\"549\":2}}],[\"库表结构优化需要多管齐下才能写出高效的sql\",{\"1\":{\"518\":1}}],[\"拆分成1024个分表\",{\"1\":{\"548\":1}}],[\"奇怪\",{\"1\":{\"546\":1}}],[\"提供的资料\",{\"1\":{\"1871\":1}}],[\"提供的filechannel\",{\"1\":{\"1465\":1}}],[\"提供了\",{\"1\":{\"1864\":1}}],[\"提供了一些创建和操作流的底层方法\",{\"1\":{\"1498\":1}}],[\"提供了一系列方便操作对象的方法\",{\"1\":{\"1415\":1}}],[\"提供了aio功能\",{\"1\":{\"1449\":2}}],[\"提供了新的nio类库\",{\"1\":{\"1449\":1}}],[\"提供了动态创建数组及访问数组元素的静态方法\",{\"1\":{\"1437\":1}}],[\"提供给外部使用的接口api\",{\"1\":{\"806\":1}}],[\"提交事务\",{\"1\":{\"1532\":1}}],[\"提交事务结果\",{\"1\":{\"1507\":1}}],[\"提交异步任务\",{\"1\":{\"1394\":1}}],[\"提交任务的源码\",{\"1\":{\"1353\":1}}],[\"提交日志\",{\"1\":{\"698\":1}}],[\"提前结束某种顺序的成本评估\",{\"1\":{\"693\":1}}],[\"提示\",{\"1\":{\"618\":1}}],[\"提示出现了主键冲突\",{\"1\":{\"604\":1}}],[\"提升消费速度\",{\"0\":{\"1736\":1}}],[\"提升数据拷贝效率\",{\"1\":{\"1453\":1}}],[\"提升并发度\",{\"1\":{\"580\":1}}],[\"提升查询性能\",{\"1\":{\"544\":1}}],[\"提高效率\",{\"1\":{\"1380\":1}}],[\"提高了安全性\",{\"1\":{\"1378\":1}}],[\"提高了系统的效率\",{\"1\":{\"1351\":1}}],[\"提高并发量\",{\"1\":{\"744\":1}}],[\"提高区间访问的性能\",{\"1\":{\"640\":1}}],[\"提高内存利用率\",{\"1\":{\"480\":1}}],[\"提高链表线性表查找的效率\",{\"1\":{\"330\":1}}],[\"给类的静态变量分配内存\",{\"1\":{\"1540\":1}}],[\"给子类扩展\",{\"1\":{\"1528\":1}}],[\"给子进程\",{\"1\":{\"1404\":1}}],[\"给字段赋值\",{\"1\":{\"1525\":1}}],[\"给出了一个具体的案例\",{\"1\":{\"1495\":1}}],[\"给新线程分配thread\",{\"1\":{\"635\":1}}],[\"给row\",{\"1\":{\"632\":1}}],[\"给session\",{\"1\":{\"584\":1,\"618\":1}}],[\"给影院b的账户余额增加这张电影票价\",{\"1\":{\"580\":1}}],[\"给小表添加字段比较合理的方案是\",{\"1\":{\"578\":1}}],[\"给一个表加字段或者修改字段\",{\"1\":{\"578\":1}}],[\"给临时表tmp\",{\"1\":{\"544\":1}}],[\"给被驱动表的join字段加上索引\",{\"1\":{\"543\":1}}],[\"给id=2这一行的c字段加1\",{\"1\":{\"462\":1}}],[\"业务线程池\",{\"0\":{\"878\":1}}],[\"业务代码逻辑又继续修改了其它数据\",{\"1\":{\"621\":1}}],[\"业务人员要继续在表t上执行两条插入语句的命令\",{\"1\":{\"596\":1}}],[\"业务开发人员要一次性地删掉大量历史数据\",{\"1\":{\"594\":1}}],[\"业务逻辑在节点a上更新了一条语句\",{\"1\":{\"592\":1}}],[\"业务逻辑出现异常怎么办\",{\"0\":{\"258\":1}}],[\"业务正常访问的数据页\",{\"1\":{\"543\":1}}],[\"尤其是找\",{\"1\":{\"1861\":1}}],[\"尤其是在多读少写的场景下\",{\"1\":{\"744\":1}}],[\"尤其是在大表上的join操作\",{\"1\":{\"540\":1}}],[\"尤其是用户信息之类的\",{\"1\":{\"710\":1}}],[\"尤其是当等待次数很高\",{\"1\":{\"675\":1}}],[\"尤其是有insert\",{\"1\":{\"629\":1}}],[\"尤其是很容易出现内存不够用和cpu瓶颈的问题\",{\"1\":{\"548\":1}}],[\"尤其是向底层存储引擎检索数据的调用操作\",{\"1\":{\"518\":1}}],[\"能在服务端具有统治地位的重要原因之一\",{\"1\":{\"1860\":1}}],[\"能避免线程频繁创建\",{\"1\":{\"1411\":1}}],[\"能否扩容\",{\"1\":{\"1386\":1}}],[\"能被多次调用\",{\"1\":{\"761\":1}}],[\"能写多少取决于内核为套接字分配的写缓冲区的空闲空间字节数\",{\"1\":{\"739\":1}}],[\"能写多少写多少\",{\"1\":{\"739\":1}}],[\"能读多少取决于内核为套接字分配的读缓冲区内部的数据字节数\",{\"1\":{\"739\":1}}],[\"能不能使用join语句\",{\"1\":{\"540\":1}}],[\"能够实现服务的远程调用\",{\"1\":{\"1868\":1}}],[\"能够优化汇聚操作\",{\"1\":{\"1492\":1}}],[\"能够通知程序进行相应的读写操作\",{\"1\":{\"1445\":1}}],[\"能够通过索引访问\",{\"1\":{\"304\":1}}],[\"能够把它保存的记录根据键排序\",{\"1\":{\"1421\":1}}],[\"能够让批量异步任务的管理更简单\",{\"1\":{\"1394\":1}}],[\"能够再次获取读锁\",{\"1\":{\"1375\":1}}],[\"能够在同一个组里提交的事务\",{\"1\":{\"601\":1}}],[\"能够提升读性能\",{\"1\":{\"541\":1}}],[\"能够十分有效的加快我们的查询效率\",{\"1\":{\"502\":1}}],[\"能够回退\",{\"1\":{\"293\":1}}],[\"λ∈\",{\"1\":{\"540\":1}}],[\"驱动表s2的扇出是321\",{\"1\":{\"692\":1}}],[\"驱动表和被驱动表的位置是可以互换的\",{\"1\":{\"692\":1}}],[\"驱动表扇出数\",{\"1\":{\"692\":1}}],[\"驱动表的扇出值也很明确\",{\"1\":{\"691\":1}}],[\"驱动表的数据行数是n\",{\"1\":{\"540\":1}}],[\"驱动表会被访问一次\",{\"1\":{\"691\":1}}],[\"驱动表是走全表扫描\",{\"1\":{\"538\":1}}],[\"调节成本常数\",{\"0\":{\"694\":1}}],[\"调换m和n的位置\",{\"1\":{\"540\":1}}],[\"调用处理程序之前调用\",{\"1\":{\"1534\":1}}],[\"调用了getsqlsession\",{\"1\":{\"1530\":1}}],[\"调用了另一个重载的groupingby方法\",{\"1\":{\"1495\":1}}],[\"调用getbean\",{\"1\":{\"1525\":1}}],[\"调用getbean方法才会调用factorybean\",{\"1\":{\"1524\":1}}],[\"调用完end方法之后\",{\"1\":{\"1500\":1}}],[\"调用的api分别是\",{\"1\":{\"1490\":1}}],[\"调用终止操作\",{\"1\":{\"1470\":1}}],[\"调用referencepipeline中的foreach方法\",{\"1\":{\"1499\":1}}],[\"调用read操作进行异步读取操作\",{\"1\":{\"1452\":1}}],[\"调用rand\",{\"1\":{\"557\":1}}],[\"调用servlet容器\",{\"1\":{\"1565\":1}}],[\"调用select函数会阻塞\",{\"1\":{\"1446\":1}}],[\"调用signal唤醒的时候会把条件队列中的线程节点移动到同步队列中\",{\"1\":{\"1367\":1}}],[\"调用方式\",{\"1\":{\"1430\":1}}],[\"调用map\",{\"1\":{\"1428\":1}}],[\"调用condition\",{\"1\":{\"1370\":2}}],[\"调用await方法进行阻塞\",{\"1\":{\"1369\":1}}],[\"调用await方法阻塞线程\",{\"1\":{\"1369\":1}}],[\"调用await\",{\"1\":{\"1367\":1}}],[\"调用wait\",{\"1\":{\"1360\":1}}],[\"调用write写入到文件系统的page\",{\"1\":{\"588\":1}}],[\"调用该脚本时\",{\"1\":{\"761\":1}}],[\"调用fsync持久化\",{\"1\":{\"588\":1}}],[\"调用引擎接口取\",{\"1\":{\"459\":1}}],[\"调用innodb引擎接口取这个表的第一行\",{\"1\":{\"459\":1}}],[\"调用库函数的方式\",{\"1\":{\"385\":1}}],[\"速度快\",{\"1\":{\"1354\":1}}],[\"速度最快\",{\"1\":{\"729\":1}}],[\"速度会快上很多\",{\"1\":{\"540\":1}}],[\"速度从慢到快\",{\"1\":{\"527\":1}}],[\"满足stream的特性\",{\"1\":{\"1496\":1}}],[\"满足匹配的条件的这行数据\",{\"1\":{\"545\":1}}],[\"满足join条件的\",{\"1\":{\"540\":2}}],[\"满足条件的下一行\",{\"1\":{\"459\":1}}],[\"满足条件就下一个孩子\",{\"1\":{\"422\":1}}],[\"走的是树搜索过程\",{\"1\":{\"538\":1}}],[\"跟我学springboot\",{\"1\":{\"1844\":1}}],[\"跟这种情况相同的\",{\"1\":{\"618\":1}}],[\"跟所有worker的冲突关系包含以下三种情况\",{\"1\":{\"598\":1}}],[\"跟第四行的commit对应\",{\"1\":{\"591\":1}}],[\"跟间隙锁存在冲突关系的\",{\"1\":{\"585\":1}}],[\"跟当前堆里面最大地r比较\",{\"1\":{\"558\":1}}],[\"跟join\",{\"1\":{\"540\":2}}],[\"跟r组成一行\",{\"1\":{\"538\":1}}],[\"跟查找操作的区别不大\",{\"1\":{\"345\":1}}],[\"往beanfactory工厂中添加如下对象\",{\"1\":{\"1528\":1}}],[\"往往需要写很多jdbc代码\",{\"1\":{\"1860\":1}}],[\"往往并不是独立的\",{\"1\":{\"1395\":1}}],[\"往往就会有根据时间删除历史数据的需求\",{\"1\":{\"563\":1}}],[\"往t2表插入100行记录\",{\"1\":{\"660\":1}}],[\"往t1表插入1万行记录\",{\"1\":{\"660\":1}}],[\"往后读文件\",{\"1\":{\"605\":1}}],[\"往这个间隙中插入一个记录\",{\"1\":{\"585\":1}}],[\"往磁盘上搬了\",{\"1\":{\"568\":1}}],[\"往表t2里面插入了1000行数据\",{\"1\":{\"537\":1}}],[\"往中间插入一条记录就必须得往后挪动所有的记录\",{\"1\":{\"470\":1}}],[\"≈\",{\"1\":{\"536\":1,\"690\":2}}],[\"进阶优化\",{\"0\":{\"1870\":1}}],[\"进程间通信方式\",{\"1\":{\"1354\":1}}],[\"进程发送信号给父进程表示完成\",{\"1\":{\"725\":1}}],[\"进程id\",{\"1\":{\"549\":1}}],[\"进而加快资源拷贝效率\",{\"1\":{\"1458\":1}}],[\"进而使得后面get的时候\",{\"1\":{\"1428\":1}}],[\"进而因为竞争导致性能下降\",{\"1\":{\"1396\":1}}],[\"进而通过调用future接口实现类的get方法获取最终的结果\",{\"1\":{\"1394\":1}}],[\"进而导致继续插入数据时报主键冲突的错误\",{\"1\":{\"636\":1}}],[\"进而导致所有从库的数据表也都一起被误删了\",{\"1\":{\"623\":1}}],[\"进而也就解决了过期读的问题\",{\"1\":{\"608\":1}}],[\"进入终止逻辑\",{\"1\":{\"618\":1}}],[\"进入等待状态\",{\"1\":{\"613\":1}}],[\"进入锁等待的线程已经不吃cpu了\",{\"1\":{\"613\":1}}],[\"进入old区域的数据页\",{\"1\":{\"543\":1}}],[\"进去\",{\"1\":{\"536\":1}}],[\"进行加法\",{\"1\":{\"1541\":1}}],[\"进行累积操作的集合中的元素\",{\"1\":{\"1494\":1}}],[\"进行二次排序\",{\"1\":{\"1491\":1}}],[\"进行addcount\",{\"1\":{\"1431\":1}}],[\"进行初始化\",{\"1\":{\"1431\":1}}],[\"进行扩容\",{\"1\":{\"1426\":1}}],[\"进行线程休眠\",{\"1\":{\"1397\":1}}],[\"进行下一步操作\",{\"1\":{\"1395\":1}}],[\"进行持久化的时候\",{\"1\":{\"725\":1}}],[\"进行位元操作\",{\"1\":{\"715\":1}}],[\"进行\",{\"1\":{\"669\":1}}],[\"进行mysql数据库服务器的参数调优\",{\"1\":{\"567\":1}}],[\"进行对比学习\",{\"1\":{\"515\":1}}],[\"进行转换的\",{\"1\":{\"505\":1}}],[\"进行了全表扫描\",{\"1\":{\"505\":1}}],[\"进行状态转移\",{\"1\":{\"326\":1}}],[\"放置在\",{\"1\":{\"1571\":1}}],[\"放开thread1的断点至transfer方法的entry\",{\"1\":{\"1428\":1}}],[\"放弃事务\",{\"1\":{\"716\":1,\"719\":1}}],[\"放弃了树搜索功能\",{\"1\":{\"503\":1}}],[\"放到bean工厂当中\",{\"1\":{\"1528\":1}}],[\"放到备库的日志目录下\",{\"1\":{\"622\":1}}],[\"放到mysql去执行\",{\"1\":{\"591\":1}}],[\"放入到join\",{\"1\":{\"542\":1}}],[\"放完第88行join\",{\"1\":{\"540\":1}}],[\"放一个数字\",{\"1\":{\"536\":1}}],[\"参看文档最后\",{\"1\":{\"665\":1}}],[\"参与排序的行\",{\"1\":{\"657\":1}}],[\"参与排序的是随机值r字段和rowid段组成的行\",{\"1\":{\"558\":1}}],[\"参考\",{\"1\":{\"654\":1,\"668\":1,\"677\":1,\"698\":1,\"1438\":1}}],[\"参考链接\",{\"1\":{\"446\":1,\"682\":1,\"800\":1,\"1540\":1}}],[\"参数设置\",{\"0\":{\"1633\":1}}],[\"参数设置非常不方便\",{\"1\":{\"806\":1}}],[\"参数解析转换核心api\",{\"1\":{\"1534\":1}}],[\"参数都是非空的\",{\"1\":{\"1496\":1}}],[\"参数before指的是在应用这个函数之前所要应用的当前的函数的函数\",{\"1\":{\"1475\":1}}],[\"参数binlog\",{\"1\":{\"587\":1}}],[\"参数可以接收行为的方法们就称这个方法为高阶函数\",{\"1\":{\"1470\":1}}],[\"参数file和pos指的是主库上的文件名和位置\",{\"1\":{\"610\":1}}],[\"参数处于关闭状态\",{\"1\":{\"568\":1}}],[\"参数tmp\",{\"1\":{\"553\":1}}],[\"参数\",{\"1\":{\"536\":1,\"619\":1,\"761\":1,\"1447\":1}}],[\"累加个各个线程自己的槽cell\",{\"1\":{\"1357\":1}}],[\"累计值就加1\",{\"1\":{\"536\":1}}],[\"累积计数\",{\"1\":{\"533\":1}}],[\"答案就是调用summarystatistics\",{\"1\":{\"1487\":1}}],[\"答案就是多路复用\",{\"1\":{\"738\":1}}],[\"答案是会在控制台打印出\",{\"1\":{\"1489\":1}}],[\"答案是否定的\",{\"1\":{\"1489\":1}}],[\"答案是什么都不会\",{\"1\":{\"1487\":1}}],[\"答案是为了性能\",{\"1\":{\"628\":1}}],[\"答案是\",{\"1\":{\"533\":1}}],[\"答案总共有n\",{\"1\":{\"393\":1}}],[\"应届生一般只要掌握热题100里面的题目即可\",{\"1\":{\"1850\":1}}],[\"应对这种情况\",{\"1\":{\"625\":1}}],[\"应用层协议解析\",{\"1\":{\"1565\":1}}],[\"应用类加载器\",{\"1\":{\"1540\":1}}],[\"应用分类器classifier\",{\"1\":{\"1495\":1}}],[\"应用程序开发框架\",{\"1\":{\"1860\":1}}],[\"应用程序从磁盘中读取文件内容的操作\",{\"1\":{\"1457\":1}}],[\"应用程序是不允许直接在该区域进行读写或者直接调用内核代码定义的函数\",{\"1\":{\"1456\":1}}],[\"应用上下文停止阶段\",{\"0\":{\"1335\":1}}],[\"应用上下文启动阶段\",{\"0\":{\"1334\":1}}],[\"应用场景\",{\"1\":{\"714\":1,\"715\":1,\"1395\":1}}],[\"应用案例\",{\"1\":{\"711\":1}}],[\"应用\",{\"0\":{\"738\":1},\"1\":{\"708\":1}}],[\"应用日志的过程就只能是单线程\",{\"1\":{\"622\":1}}],[\"应用中已经缓存了id为123\",{\"1\":{\"531\":1}}],[\"应该支持热插拔\",{\"1\":{\"1571\":1}}],[\"应该使服务器的类库与应用程序的类库相互独立\",{\"1\":{\"1571\":1}}],[\"应该使用这种方式来定义\",{\"1\":{\"1497\":1}}],[\"应该使用哪个表做驱动表呢\",{\"1\":{\"540\":1}}],[\"应该使用\",{\"1\":{\"525\":1}}],[\"应该确保了分割迭代器在某个时候一次只有一个线程使用\",{\"1\":{\"1497\":1}}],[\"应该尽量避免使用线程不安全的hashmap\",{\"1\":{\"1428\":1}}],[\"应该优先考虑使用truncate\",{\"1\":{\"621\":1}}],[\"应该把需要行锁的语句放在最后\",{\"1\":{\"580\":1}}],[\"应该作为驱动表\",{\"1\":{\"540\":1}}],[\"应该是两个表按照各自的条件过滤\",{\"1\":{\"540\":1}}],[\"应该选择小表做驱动表\",{\"1\":{\"540\":3}}],[\"应该选择大表做驱动表还是选择小表做驱动表\",{\"1\":{\"540\":1}}],[\"应该让小表当驱动表\",{\"1\":{\"540\":1}}],[\"应该用哪个表做驱动表\",{\"1\":{\"537\":1}}],[\"应该返回多少行\",{\"1\":{\"533\":1}}],[\"阻塞io的特点就是在io执行的两个阶段都被block了\",{\"1\":{\"1440\":1}}],[\"阻塞io模型\",{\"0\":{\"1440\":1}}],[\"阻塞io\",{\"1\":{\"1438\":1,\"1444\":1}}],[\"阻塞唤醒机制机制底层原理\",{\"1\":{\"1407\":1}}],[\"阻塞生产者线程\",{\"1\":{\"1380\":1}}],[\"阻塞特定时间\",{\"1\":{\"1378\":1}}],[\"阻塞等待队列\",{\"1\":{\"1367\":1}}],[\"阻塞式的解决方案\",{\"1\":{\"1359\":1}}],[\"阻塞1s\",{\"1\":{\"1356\":1}}],[\"阻塞队列无法继续处理\",{\"1\":{\"1450\":1}}],[\"阻塞队列已满\",{\"1\":{\"1379\":1}}],[\"阻塞队列出了阻塞外还有一个非常重要的属性\",{\"1\":{\"1378\":1}}],[\"阻塞队列的总结\",{\"1\":{\"1376\":1}}],[\"阻塞队列的实现原理是什么\",{\"0\":{\"71\":1}}],[\"阻塞队列\",{\"1\":{\"1353\":1}}],[\"阻塞客户端命令\",{\"1\":{\"726\":1}}],[\"阻塞发生在fock\",{\"1\":{\"726\":1}}],[\"阻塞\",{\"0\":{\"1444\":1},\"1\":{\"726\":1,\"1378\":2,\"1444\":1}}],[\"阻塞只发生在fork阶段\",{\"1\":{\"724\":1}}],[\"阻塞当前redis服务器\",{\"1\":{\"724\":1}}],[\"阻塞被解决\",{\"1\":{\"708\":1}}],[\"阻塞很多小的但重要的查询\",{\"1\":{\"530\":1}}],[\"占整个堆内存的1\",{\"1\":{\"1541\":1}}],[\"占位符的填充\",{\"1\":{\"1525\":1}}],[\"占有1g内存\",{\"1\":{\"1404\":1}}],[\"占据4字节\",{\"1\":{\"1361\":1}}],[\"占了3条记录\",{\"1\":{\"695\":1}}],[\"占满整个事务日志\",{\"1\":{\"530\":1}}],[\"占用几十个字节的空间\",{\"1\":{\"591\":1}}],[\"占用磁盘io资源\",{\"1\":{\"543\":1}}],[\"占用的磁盘空间就越大\",{\"1\":{\"489\":1}}],[\"占用8个字节\",{\"1\":{\"467\":1}}],[\"无同步方案\",{\"0\":{\"1696\":1}}],[\"无状态的中间操作\",{\"1\":{\"1501\":1}}],[\"无条件得循环遍历整个\",{\"1\":{\"1431\":1}}],[\"无返回值\",{\"1\":{\"1395\":2}}],[\"无界队列\",{\"1\":{\"1380\":1}}],[\"无界队列意味着里面可以容纳非常多的元素\",{\"1\":{\"1378\":1}}],[\"无意识的使用锁\",{\"1\":{\"1362\":1}}],[\"无锁设计\",{\"1\":{\"1396\":1}}],[\"无锁\",{\"1\":{\"1361\":1}}],[\"无需cpu拷贝\",{\"1\":{\"1453\":1}}],[\"无需改动外部数据结构和命令\",{\"1\":{\"706\":1}}],[\"无需担心表名重复导致建表失败的问题\",{\"1\":{\"547\":1}}],[\"无符号\",{\"1\":{\"665\":1}}],[\"无符号整型\",{\"1\":{\"630\":1}}],[\"无法访问子容器\",{\"1\":{\"1536\":1}}],[\"无法依赖注入\",{\"1\":{\"1525\":1}}],[\"无法分割\",{\"1\":{\"1497\":1}}],[\"无法组合多个任务\",{\"1\":{\"1393\":1}}],[\"无法对多个任务进行链式调用\",{\"1\":{\"1393\":1}}],[\"无法扩容\",{\"1\":{\"1386\":1}}],[\"无法很好的利用索引\",{\"1\":{\"655\":1}}],[\"无法断开这个连接\",{\"1\":{\"617\":1}}],[\"无法确定唯一一颗二叉树\",{\"1\":{\"339\":1}}],[\"无论使用哪种方式\",{\"1\":{\"1497\":1}}],[\"无论如何\",{\"1\":{\"1430\":1}}],[\"无论从微观还是宏观来看\",{\"1\":{\"1347\":1}}],[\"无论是http还是ajp\",{\"1\":{\"1565\":1}}],[\"无论是出于开发效率\",{\"1\":{\"1469\":1}}],[\"无论是传统的io方式\",{\"1\":{\"1462\":1}}],[\"无论是把mysqlbinlog工具解析出的binlog文件应用到临时库\",{\"1\":{\"622\":1}}],[\"无论是带宽还是延迟\",{\"1\":{\"529\":1}}],[\"无论怎样安排语句顺序\",{\"1\":{\"580\":1}}],[\"无论数据量大或小的group\",{\"1\":{\"555\":1}}],[\"换句话说\",{\"1\":{\"667\":1,\"1403\":1,\"1471\":1,\"1472\":1,\"1499\":1}}],[\"换句话说查询列要被所使用的索引覆盖\",{\"1\":{\"467\":1}}],[\"换成\",{\"1\":{\"558\":1}}],[\"换言之\",{\"1\":{\"527\":1,\"728\":1,\"1471\":1,\"1477\":1,\"1480\":1,\"1494\":1}}],[\"范围区间内的数量\",{\"1\":{\"686\":1}}],[\"范围区间的数量\",{\"1\":{\"686\":1}}],[\"范围区间数量\",{\"1\":{\"686\":2}}],[\"范围\",{\"1\":{\"665\":2,\"666\":1}}],[\"范围扫描\",{\"1\":{\"527\":1}}],[\"范围之后全失效\",{\"0\":{\"509\":1},\"1\":{\"509\":1,\"515\":1}}],[\"范围之后的索引会失效\",{\"1\":{\"498\":1}}],[\"服务的治理\",{\"1\":{\"1868\":1}}],[\"服务路由\",{\"1\":{\"1867\":1}}],[\"服务网关\",{\"1\":{\"1867\":1}}],[\"服务提供者接口\",{\"1\":{\"1535\":1}}],[\"服务端需要做两件事\",{\"1\":{\"1457\":1}}],[\"服务端\",{\"1\":{\"1450\":1,\"1451\":1,\"1452\":1}}],[\"服务端为每个客户端请求创建一个独立的线程\",{\"1\":{\"1410\":1}}],[\"服务模型\",{\"0\":{\"840\":1}}],[\"服务引入\",{\"0\":{\"802\":1}}],[\"服务导出\",{\"0\":{\"801\":1}}],[\"服务导出与服务引入的流程图\",{\"1\":{\"800\":1}}],[\"服务器中间件\",{\"0\":{\"1862\":1}}],[\"服务器进程都维持着一个表示服务器状态的\",{\"1\":{\"736\":1}}],[\"服务器必须要扫描多行才能生成结果集中的一行\",{\"1\":{\"526\":1}}],[\"服务恢复需要的时间就越短\",{\"1\":{\"596\":1}}],[\"服务时间是指数据库处理这个查询真正花了多长时间\",{\"1\":{\"525\":1}}],[\"服务时间和排队时间\",{\"1\":{\"525\":1}}],[\"美事\",{\"1\":{\"526\":1}}],[\"理论上\",{\"1\":{\"1351\":1}}],[\"理论上可以创建不同的db\",{\"1\":{\"600\":1}}],[\"理解每个泛型代表的含义以及每个参数的作用\",{\"1\":{\"1495\":1}}],[\"理解了三个参数具体的作用我们具体再往下看\",{\"1\":{\"1485\":1}}],[\"理解了函数式接口\",{\"1\":{\"1470\":1}}],[\"理解了change\",{\"1\":{\"480\":1}}],[\"理解条件配置spring\",{\"0\":{\"1308\":1}}],[\"理解事务传播\",{\"0\":{\"1022\":1}}],[\"理解platformtransactionmanager\",{\"0\":{\"1021\":1}}],[\"理解transactiondefinition\",{\"0\":{\"1020\":1}}],[\"理由如下\",{\"1\":{\"547\":1}}],[\"理想情况下\",{\"1\":{\"526\":1,\"1497\":1}}],[\"较短的性的访问速度更快\",{\"1\":{\"526\":1}}],[\"糟糕\",{\"1\":{\"526\":1}}],[\"法概括地说\",{\"1\":{\"525\":1}}],[\"法来估算这个时间是否是一个合理的值\",{\"1\":{\"525\":1}}],[\"遗憾的是\",{\"1\":{\"525\":1,\"533\":1}}],[\"排好序之后对于名称相同的再根据分数进行排序\",{\"1\":{\"1491\":1}}],[\"排他性\",{\"1\":{\"715\":1}}],[\"排他锁\",{\"1\":{\"674\":1,\"678\":1}}],[\"排行榜应用实现\",{\"1\":{\"711\":1}}],[\"排查问题更方便\",{\"1\":{\"606\":1}}],[\"排队时间是指服务器因为等待某些资源而没有真正地执行查询的时间\",{\"1\":{\"525\":1}}],[\"排序之后将其名字查找出来\",{\"1\":{\"1488\":1}}],[\"排序等\",{\"1\":{\"1485\":1}}],[\"排序规则又可以做出如下修改\",{\"1\":{\"1482\":1}}],[\"排序方式\",{\"1\":{\"657\":2}}],[\"排序缓存的大小\",{\"1\":{\"657\":1}}],[\"排序完后需要再次取回其它需要的字段\",{\"1\":{\"657\":1}}],[\"排序完成后\",{\"1\":{\"555\":1,\"557\":1}}],[\"排序后的id数组\",{\"1\":{\"541\":1}}],[\"排序字段若通过索引去访问将大大提高排序速度\",{\"1\":{\"495\":1}}],[\"排序是一个成本比较高的操作\",{\"1\":{\"493\":1}}],[\"排序的\",{\"1\":{\"1497\":1}}],[\"排序的过程结束后\",{\"1\":{\"558\":1}}],[\"排序的结果因为少了city和age字段的值\",{\"1\":{\"492\":1}}],[\"排序的性能会很差\",{\"1\":{\"492\":1}}],[\"排序过程中对字符串做了\",{\"1\":{\"491\":1}}],[\"排序过程中使用的临时的文件数\",{\"1\":{\"491\":1}}],[\"排序就在内存中完成\",{\"1\":{\"491\":1}}],[\"排序使用到了索引\",{\"1\":{\"467\":1}}],[\"排序没有使用索引\",{\"1\":{\"467\":1}}],[\"排序\",{\"1\":{\"366\":1,\"369\":1,\"711\":1}}],[\"排序算法\",{\"0\":{\"316\":1},\"1\":{\"316\":1}}],[\"很浅显易懂\",{\"1\":{\"1859\":1}}],[\"很少有公司需要前后端都掌握\",{\"1\":{\"1854\":1}}],[\"很容易采用索引统计数据而不是index\",{\"1\":{\"690\":1}}],[\"很容易出现这样的错误\",{\"1\":{\"523\":1}}],[\"很难保证操作和redis操作的事务的一致性\",{\"1\":{\"663\":1}}],[\"很显然使用idx\",{\"1\":{\"692\":1}}],[\"很显然对驱动表的单表查询可以使用idx\",{\"1\":{\"691\":1}}],[\"很显然对驱动表的单表查询只能使用全表扫描的方式执行\",{\"1\":{\"691\":1}}],[\"很显然驱动表的扇出值越小\",{\"1\":{\"691\":1}}],[\"很显然\",{\"1\":{\"662\":1,\"692\":1,\"693\":1,\"1350\":1}}],[\"很占空间\",{\"1\":{\"591\":1}}],[\"很可能出现从库上迟迟无法响应查询请求的情况\",{\"1\":{\"609\":1}}],[\"很可能会先遇到读性能的问题\",{\"1\":{\"603\":1}}],[\"很可能会出现主备数据不一致的情况\",{\"1\":{\"591\":1}}],[\"很可能这时的数据不一致已经不可查\",{\"1\":{\"596\":1}}],[\"很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间\",{\"1\":{\"553\":1}}],[\"很可能在1秒内就被淘汰了\",{\"1\":{\"543\":1}}],[\"很可能不是必须的\",{\"1\":{\"522\":1}}],[\"很多\",{\"1\":{\"1870\":1}}],[\"很多流操作\",{\"1\":{\"1485\":1}}],[\"很多时候一开始还没有到达\",{\"1\":{\"1440\":1}}],[\"很多时候也是能够接受的\",{\"1\":{\"1404\":1}}],[\"很多时候业务逻辑处理存在串行\",{\"1\":{\"1395\":1}}],[\"很多时候hash索引要比b+树索引更高效\",{\"1\":{\"641\":1}}],[\"很多时候小事务能够更高效\",{\"1\":{\"530\":1}}],[\"很多高性能的应用都会对关联查询进行分解\",{\"1\":{\"531\":1}}],[\"很长时间才会更新依次\",{\"1\":{\"456\":1}}],[\"典型的应用场景就是异步日志\",{\"1\":{\"1397\":1}}],[\"典型的单链表结构\",{\"1\":{\"1380\":1}}],[\"典型的场景是先使用select语句查询大量的结果\",{\"1\":{\"520\":1}}],[\"典型应用是用于统计和排序大量的字符串\",{\"1\":{\"301\":1}}],[\"离国内外i啊也会消耗应用服务器的cpu和内存资源\",{\"1\":{\"519\":1}}],[\"确保获取锁\",{\"1\":{\"1430\":1}}],[\"确保一致性的两种最常见的机制是窥探机制和基于目录的机制\",{\"1\":{\"1351\":1}}],[\"确保后续指令执行的原子性\",{\"1\":{\"1350\":1}}],[\"确保对业务无影响以后再删除这张表\",{\"1\":{\"624\":1}}],[\"确保seconds\",{\"1\":{\"595\":1}}],[\"确保业务一定不会出现死锁\",{\"1\":{\"581\":1}}],[\"确实很快就可以解开\",{\"1\":{\"581\":1}}],[\"确认是否使用bnl算法\",{\"1\":{\"543\":1}}],[\"确认mysql服务器层是否在分析大量超过需要的数据行\",{\"1\":{\"518\":1}}],[\"确认应用程序是否在检索大量超过需要的数据\",{\"1\":{\"518\":1}}],[\"确定合适的处理程序对象之后\",{\"1\":{\"1534\":1}}],[\"确定合适的大类型\",{\"1\":{\"664\":1}}],[\"确定大小的\",{\"1\":{\"1497\":1}}],[\"确定哈希桶数组索引位置\",{\"0\":{\"1425\":1}}],[\"确定具体的类型\",{\"1\":{\"664\":1}}],[\"确定选择\",{\"1\":{\"656\":1}}],[\"确定放入一个整型字段\",{\"1\":{\"555\":1}}],[\"确定放入两个字段\",{\"1\":{\"492\":1}}],[\"确定放入name\",{\"1\":{\"491\":1}}],[\"确定性和可行性\",{\"1\":{\"282\":1}}],[\"慢\",{\"1\":{\"732\":1}}],[\"慢sql分析\",{\"1\":{\"567\":2}}],[\"慢sql的优化思路\",{\"0\":{\"168\":1}}],[\"慢查询的开启并捕获\",{\"1\":{\"567\":1}}],[\"慢查询日志支持将日志记录写入文件\",{\"1\":{\"565\":1}}],[\"慢查询日志是什么\",{\"1\":{\"565\":1}}],[\"慢查询日志\",{\"0\":{\"564\":1}}],[\"慢查询基础\",{\"0\":{\"518\":1}}],[\"位初始是\",{\"1\":{\"1431\":1}}],[\"位是标识符\",{\"1\":{\"1431\":1}}],[\"位\",{\"1\":{\"1431\":1}}],[\"位图\",{\"0\":{\"715\":1},\"1\":{\"705\":1}}],[\"位置越靠前越好\",{\"1\":{\"517\":1}}],[\"位运算\",{\"0\":{\"312\":1}}],[\"避免类的重复加载\",{\"1\":{\"1540\":1,\"1570\":1}}],[\"避免哈希冲突\",{\"1\":{\"1430\":1}}],[\"避免共享有两种方案\",{\"1\":{\"1405\":1}}],[\"避免共享的设计模式\",{\"0\":{\"1402\":1}}],[\"避免select系统调用立即返回写事件\",{\"1\":{\"742\":1}}],[\"避免了资源被消耗尽造异常外和错误\",{\"1\":{\"1496\":1}}],[\"避免了两者之间的\",{\"1\":{\"1461\":1}}],[\"避免了频繁加锁互斥\",{\"1\":{\"677\":1}}],[\"避免了页分裂\",{\"1\":{\"626\":1}}],[\"避免间隙锁\",{\"1\":{\"676\":1}}],[\"避免无索引行锁升级为表锁\",{\"1\":{\"676\":1}}],[\"避免使用整数的显示宽度\",{\"1\":{\"665\":1}}],[\"避免使用null\",{\"1\":{\"664\":1}}],[\"避免两个库生成的主键发生冲突\",{\"1\":{\"628\":1}}],[\"避免写错命令\",{\"1\":{\"624\":1}}],[\"避免让mysql再自己去翻译一次\",{\"1\":{\"515\":1}}],[\"避免访问了表的数据行\",{\"1\":{\"467\":1}}],[\"题目\",{\"1\":{\"515\":1}}],[\"题目的状态树\",{\"1\":{\"400\":1}}],[\"题目的意思是\",{\"1\":{\"384\":1}}],[\"面对面试足够了\",{\"1\":{\"1870\":1}}],[\"面试中elasticsearch出现的概率也不高\",{\"1\":{\"1864\":1}}],[\"面试中会出现很多\",{\"1\":{\"1861\":1}}],[\"面试重点看索引部分就可以了\",{\"1\":{\"1852\":1}}],[\"面试题\",{\"0\":{\"921\":1,\"939\":1,\"990\":1,\"1013\":1,\"1025\":1,\"1062\":1,\"1074\":1,\"1084\":1,\"1096\":1,\"1108\":1,\"1129\":1,\"1140\":1,\"1151\":1,\"1175\":1,\"1194\":1,\"1207\":1,\"1218\":1,\"1227\":1,\"1238\":1,\"1255\":1,\"1265\":1,\"1288\":1,\"1302\":1,\"1319\":1,\"1337\":1}}],[\"面试题分析\",{\"0\":{\"515\":1}}],[\"面向对象的方式\",{\"1\":{\"1497\":1}}],[\"面向对象编程三⼤特性\",{\"0\":{\"16\":1}}],[\"面向块的io\",{\"1\":{\"1451\":1}}],[\"面向注解的事件\",{\"0\":{\"1271\":1}}],[\"面向接口的事件\",{\"0\":{\"1270\":1}}],[\"口诀\",{\"1\":{\"507\":1,\"508\":1,\"509\":1,\"510\":1,\"512\":2,\"513\":1}}],[\"$\",{\"1\":{\"1469\":1,\"1525\":1}}],[\"$0\",{\"1\":{\"1350\":1}}],[\"$r\",{\"1\":{\"538\":1}}],[\"$r4\",{\"1\":{\"505\":2}}],[\"$l2\",{\"1\":{\"505\":1}}],[\"类与对象\",{\"1\":{\"1847\":1}}],[\"类与类加载器\",{\"0\":{\"1670\":1}}],[\"类索引\",{\"0\":{\"1657\":1}}],[\"类文件结构\",{\"0\":{\"1577\":1}}],[\"类库可被tomcat和所有的web应用程序共同使用\",{\"1\":{\"1571\":1}}],[\"类被加载到方法区中后主要包含运行时常量池\",{\"1\":{\"1540\":1}}],[\"类加载机制\",{\"0\":{\"1578\":1}}],[\"类加载过程\",{\"0\":{\"1663\":1},\"1\":{\"1570\":1}}],[\"类加载检查\",{\"0\":{\"1543\":1}}],[\"类加载的引用\",{\"1\":{\"1540\":1}}],[\"类加载期间完成\",{\"1\":{\"1540\":1}}],[\"类加载\",{\"1\":{\"1524\":1}}],[\"类加载器在加载类信息放到方法区中后\",{\"1\":{\"1540\":1}}],[\"类加载器的引用\",{\"1\":{\"1540\":1}}],[\"类加载器\",{\"0\":{\"1669\":1},\"1\":{\"1513\":1}}],[\"类上的注解\",{\"1\":{\"1523\":1}}],[\"类中的方法\",{\"1\":{\"1523\":1}}],[\"类中的方法才表示具体的行为\",{\"1\":{\"1484\":1}}],[\"类的说明\",{\"1\":{\"1500\":2}}],[\"类的任意对象的实例方法引用\",{\"1\":{\"1479\":1}}],[\"类\",{\"1\":{\"1452\":3}}],[\"类unix的操作系统中创建进行的api是fork\",{\"1\":{\"1404\":1}}],[\"类bar中持有对foo的引用foo\",{\"1\":{\"1403\":1}}],[\"类和属性都是final的\",{\"1\":{\"1403\":1}}],[\"类似这样的代码\",{\"1\":{\"1486\":1}}],[\"类似于hashmap中的entry\",{\"1\":{\"1430\":1}}],[\"类似于执行一条select\",{\"1\":{\"608\":1}}],[\"类似list\",{\"1\":{\"720\":1}}],[\"类似string\",{\"1\":{\"720\":1}}],[\"类似上述的\",{\"1\":{\"690\":1}}],[\"类似insert\",{\"1\":{\"629\":1}}],[\"类似下面的命令\",{\"1\":{\"591\":1}}],[\"类似的对于分区的操作也可以进行二级分区\",{\"1\":{\"1493\":1}}],[\"类似的max\",{\"1\":{\"1487\":1}}],[\"类似的方法指定字段显示宽度\",{\"1\":{\"665\":1}}],[\"类似的\",{\"1\":{\"591\":1,\"597\":1,\"1476\":1,\"1491\":1,\"1525\":1}}],[\"类似地\",{\"1\":{\"505\":1}}],[\"类型信息\",{\"1\":{\"1540\":1}}],[\"类型转化注册器\",{\"1\":{\"1528\":1}}],[\"类型转换非常麻烦\",{\"1\":{\"806\":1}}],[\"类型转换\",{\"1\":{\"506\":1}}],[\"类型必须要是原生类型的包装类型\",{\"1\":{\"1497\":1}}],[\"类型可以是不相同的\",{\"1\":{\"1478\":1}}],[\"类型\",{\"0\":{\"1644\":1},\"1\":{\"557\":1,\"665\":1,\"666\":1,\"667\":1,\"1513\":1}}],[\"类型之外\",{\"1\":{\"467\":1}}],[\"等\",{\"1\":{\"1361\":1,\"1856\":1}}],[\"等高级语言也都是支持管程的\",{\"1\":{\"1360\":1}}],[\"等于a\",{\"1\":{\"1492\":1}}],[\"等于只要发一些指令给底层就可以了\",{\"1\":{\"1488\":1}}],[\"等于e\",{\"1\":{\"1356\":1}}],[\"等于系统表\",{\"1\":{\"467\":1}}],[\"等价于setx\",{\"1\":{\"709\":1}}],[\"等同于放弃了扩展性\",{\"1\":{\"607\":1}}],[\"等gtid方案\",{\"1\":{\"606\":1}}],[\"等主库位点方案\",{\"0\":{\"610\":1},\"1\":{\"606\":1}}],[\"等到着获取锁\",{\"1\":{\"1367\":1}}],[\"等到队列有数据了\",{\"1\":{\"742\":1}}],[\"等到服务器重启之后\",{\"1\":{\"695\":1}}],[\"等到卖家再刷新页面\",{\"1\":{\"608\":1}}],[\"等到主备间的同步关系建立完成\",{\"1\":{\"604\":1}}],[\"等到空间快满了\",{\"1\":{\"594\":1}}],[\"等待数据准备\",{\"1\":{\"1438\":1}}],[\"等待策略\",{\"1\":{\"1397\":1,\"1398\":1}}],[\"等待其他线程释放锁而唤醒\",{\"1\":{\"1396\":1}}],[\"等待其它线程唤醒\",{\"1\":{\"1380\":2}}],[\"等待消费者唤醒\",{\"1\":{\"1379\":1}}],[\"等待再次获得锁\",{\"1\":{\"1367\":1}}],[\"等待线程\",{\"1\":{\"1360\":1}}],[\"等待重新调度\",{\"1\":{\"1360\":1}}],[\"等待唤醒机制规范实现\",{\"1\":{\"1407\":1}}],[\"等待唤醒机制\",{\"1\":{\"1354\":1}}],[\"等待接收消息\",{\"1\":{\"735\":1}}],[\"等待总时长\",{\"1\":{\"675\":1}}],[\"等待总次数\",{\"1\":{\"675\":1}}],[\"等待平均时长\",{\"1\":{\"675\":1}}],[\"等待\",{\"1\":{\"611\":1,\"1431\":1}}],[\"等待新主库a\",{\"1\":{\"604\":1}}],[\"等待所有wroker都执行完成\",{\"1\":{\"599\":1}}],[\"等trx1要开始写盘的时候\",{\"1\":{\"588\":1}}],[\"等等\",{\"1\":{\"525\":1,\"1486\":1,\"1498\":1,\"1500\":1}}],[\"等操作\",{\"1\":{\"518\":1}}],[\"等字段\",{\"1\":{\"503\":1}}],[\"交友了\",{\"1\":{\"1859\":1}}],[\"交给后面的function\",{\"1\":{\"1395\":1}}],[\"交集\",{\"1\":{\"709\":1}}],[\"交易编号tradeid这个字段上\",{\"1\":{\"504\":1}}],[\"交易时间\",{\"1\":{\"503\":1}}],[\"交易员id\",{\"1\":{\"503\":1}}],[\"交换元素位置\",{\"1\":{\"317\":1,\"318\":1}}],[\"交换两个数\",{\"1\":{\"314\":1}}],[\"保持刷题的节奏感\",{\"1\":{\"1850\":1}}],[\"保持不变\",{\"1\":{\"584\":1}}],[\"保护性暂停模式\",{\"1\":{\"1407\":1}}],[\"保护这个间隙\",{\"1\":{\"585\":1}}],[\"保证加载类的唯一性\",{\"1\":{\"1540\":1}}],[\"保证内核安全\",{\"1\":{\"1456\":1}}],[\"保证了同时只有一个线程修改链表\",{\"1\":{\"1431\":1}}],[\"保证高峰期别把队列塞满就好\",{\"1\":{\"1413\":1}}],[\"保证可见性的方式有两种\",{\"1\":{\"1350\":1}}],[\"保证可见性的方法\",{\"1\":{\"1348\":1}}],[\"保证同时刻只有一个线程访问\",{\"1\":{\"767\":1}}],[\"保证读写的正确性\",{\"1\":{\"578\":1}}],[\"保证join语句中被驱动表上join条件字段已经被索引\",{\"1\":{\"501\":1}}],[\"保存局部变量的地方\",{\"1\":{\"1541\":1}}],[\"保存的必须为同一类型的元素\",{\"1\":{\"1415\":1}}],[\"保存的char\",{\"1\":{\"302\":1}}],[\"保存\",{\"1\":{\"491\":2,\"1513\":1}}],[\"尽管他们显著的功能在算法当中\",{\"1\":{\"1497\":1}}],[\"尽可能低级别事务隔离\",{\"1\":{\"676\":1}}],[\"尽可能控制事务大小\",{\"1\":{\"676\":1}}],[\"尽可能减少检索条件范围\",{\"1\":{\"676\":1}}],[\"尽可能减少join语句中的nestedloop\",{\"1\":{\"501\":1}}],[\"尽可能让所有数据检索都通过索引来完成\",{\"1\":{\"676\":1}}],[\"尽可能地只扫描需要的数据行\",{\"1\":{\"527\":1}}],[\"尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的\",{\"1\":{\"517\":1}}],[\"尽量避免直接挂起线程\",{\"1\":{\"1362\":1}}],[\"尽量将cas操作延迟\",{\"1\":{\"1357\":1}}],[\"尽量缩小锁的范围\",{\"1\":{\"676\":1}}],[\"尽量少用blob和text\",{\"1\":{\"667\":1}}],[\"尽量把字段定义为not\",{\"1\":{\"664\":1}}],[\"尽量用更小的数据类型\",{\"1\":{\"664\":1}}],[\"尽量减少热点冲突\",{\"1\":{\"1357\":1}}],[\"尽量减少驱动表的扇出\",{\"1\":{\"692\":1}}],[\"尽量减少扫描的数据量\",{\"1\":{\"533\":1}}],[\"尽量减少磁盘访问\",{\"1\":{\"493\":1}}],[\"尽量选择可以能够包含当前query中的where子句中更多字段的索引\",{\"1\":{\"517\":1}}],[\"尽量选择针对当前query过滤性更好的索引\",{\"1\":{\"517\":1}}],[\"尽量选择普通索引\",{\"1\":{\"481\":1}}],[\"尽量使用覆盖索引\",{\"1\":{\"506\":1}}],[\"尽量使用主键查询\",{\"1\":{\"472\":1}}],[\"书籍方面\",{\"1\":{\"1852\":1}}],[\"书籍\",{\"1\":{\"499\":1}}],[\"看了答案也不知道该怎么做\",{\"1\":{\"1850\":1}}],[\"看了这么几个例子\",{\"1\":{\"1470\":1}}],[\"看博客和源码精进学习\",{\"1\":{\"1846\":1}}],[\"看书学习\",{\"1\":{\"1846\":1}}],[\"看视频的好处就是有老师带着\",{\"1\":{\"1846\":1}}],[\"看视频系统学习\",{\"1\":{\"1846\":1}}],[\"看起来与上面的写法是完全等价的\",{\"1\":{\"1491\":1}}],[\"看起来只是增加了一步\",{\"1\":{\"1470\":1}}],[\"看上去是一个比较正常的数字\",{\"1\":{\"634\":1}}],[\"看看jdk是如何使用分割迭代器来构造流源的\",{\"1\":{\"1498\":1}}],[\"看看当前的mysql版本是否支持\",{\"1\":{\"568\":1}}],[\"看看生产的慢sql情况\",{\"1\":{\"567\":1}}],[\"看看sql的执行计划\",{\"1\":{\"498\":1}}],[\"看到这里还是比较难以理解的\",{\"1\":{\"1492\":1}}],[\"看到这里我们就明白了\",{\"1\":{\"1490\":1,\"1499\":1}}],[\"看到这条语句的command列显示的却是killed\",{\"1\":{\"617\":1}}],[\"看到\",{\"1\":{\"583\":1}}],[\"看到mysql需要扫描多少行和实际需要使用的行数需要先去理解这个查询背后的逻辑和思想\",{\"1\":{\"527\":1}}],[\"看到一个索引的基数\",{\"1\":{\"484\":1}}],[\"产生的代理对象一定是传入的接口的类型\",{\"1\":{\"1531\":1}}],[\"产生的原因是由于哈希碰撞导致的巧合而将不同的元素存储在相同的比特位上\",{\"1\":{\"307\":1}}],[\"产生这个问题的原因是session\",{\"1\":{\"629\":1}}],[\"产生幻读的原因是\",{\"1\":{\"585\":1}}],[\"产生了using\",{\"1\":{\"515\":1}}],[\"产生了文件内排序\",{\"1\":{\"498\":1}}],[\"案例\",{\"1\":{\"498\":1,\"507\":1,\"508\":1,\"509\":1,\"566\":1}}],[\"文件不可以完全存储消息\",{\"0\":{\"1764\":1}}],[\"文件可以完全存储消息\",{\"0\":{\"1763\":1}}],[\"文件资源等等\",{\"1\":{\"1514\":1}}],[\"文件描述符在形式上是一个非负整数\",{\"1\":{\"1438\":1}}],[\"文件描述符\",{\"1\":{\"1438\":1}}],[\"文件的读写\",{\"1\":{\"1387\":1}}],[\"文件的完整性会更加好\",{\"1\":{\"730\":1}}],[\"文件名可以在配置文件中进行自定义\",{\"1\":{\"723\":1}}],[\"文件名的后缀是\",{\"1\":{\"549\":1}}],[\"文件排序信息\",{\"1\":{\"657\":1}}],[\"文件也不会变小\",{\"1\":{\"571\":1}}],[\"文件内排序\",{\"1\":{\"467\":1}}],[\"文章\",{\"1\":{\"498\":1}}],[\"标签匹配\",{\"0\":{\"1782\":1}}],[\"标签\",{\"0\":{\"1710\":1}}],[\"标识为已经消费\",{\"1\":{\"1499\":1}}],[\"标识符左移\",{\"1\":{\"1431\":1}}],[\"标识拥有该monitor的线程\",{\"1\":{\"1360\":1}}],[\"标准工厂api\",{\"0\":{\"925\":1}}],[\"标记\",{\"0\":{\"1598\":1,\"1599\":1,\"1600\":1}}],[\"标记位为true\",{\"1\":{\"679\":1}}],[\"标记位写上true\",{\"1\":{\"679\":1}}],[\"标记了\",{\"1\":{\"307\":1}}],[\"标题\",{\"1\":{\"498\":1}}],[\"作用和beandefinitionreader类似\",{\"1\":{\"1512\":1}}],[\"作用是将输入元素累积到一个可变的结果容器当中\",{\"1\":{\"1492\":1}}],[\"作用于工作内存的变量\",{\"1\":{\"1350\":4}}],[\"作用于主内存变量\",{\"1\":{\"1350\":2}}],[\"作用于主内存的变量\",{\"1\":{\"1350\":2}}],[\"作用域简介\",{\"0\":{\"1144\":1}}],[\"作用域代理schema\",{\"0\":{\"989\":1}}],[\"作用\",{\"0\":{\"744\":1,\"756\":1,\"810\":1}}],[\"作者id\",{\"1\":{\"498\":1}}],[\"作为开发人员访问方法区中类定义的入口和切入点\",{\"1\":{\"1540\":1}}],[\"作为方法区这个类的各种数据的访问入口\",{\"1\":{\"1540\":1}}],[\"作为collect\",{\"1\":{\"1485\":1}}],[\"作为主节点的备份\",{\"1\":{\"758\":1}}],[\"作为主键并不合适\",{\"1\":{\"478\":1}}],[\"作为新的自增值\",{\"1\":{\"628\":1}}],[\"作为多用户共享的资源\",{\"1\":{\"573\":1}}],[\"作为结果集的一部分返回\",{\"1\":{\"540\":2}}],[\"作为结果集的一部分\",{\"1\":{\"538\":1}}],[\"作为结果集的一部分直接返回\",{\"1\":{\"493\":3}}],[\"假如我们要对一个字符串数据按照首字母进行排序\",{\"1\":{\"1491\":1}}],[\"假如是10\",{\"1\":{\"693\":1}}],[\"假如有人中午12点删了一个库\",{\"1\":{\"622\":1}}],[\"假如一个表有10万行记录\",{\"1\":{\"496\":1}}],[\"假设容量为2的n次幂的化\",{\"1\":{\"1425\":1}}],[\"假设此刻另一个线程\",{\"1\":{\"1375\":1}}],[\"假设此时同时有另外一个顾客c要在影院b买票\",{\"1\":{\"580\":1}}],[\"假设该class计数器继续增长\",{\"1\":{\"1362\":1}}],[\"假设使用idx\",{\"1\":{\"692\":2}}],[\"假设使用s1表作为驱动表\",{\"1\":{\"691\":1}}],[\"假设account表里的数据如下\",{\"1\":{\"673\":1}}],[\"假设xid是a\",{\"1\":{\"633\":1}}],[\"假设数据库的binlog\",{\"1\":{\"629\":1}}],[\"假设数据表t中只有一列\",{\"1\":{\"570\":1}}],[\"假设事务a申请到了id=2\",{\"1\":{\"628\":1}}],[\"假设某次要插入的值是x\",{\"1\":{\"628\":1}}],[\"假设误操作命令的gtid是gtid1\",{\"1\":{\"622\":1}}],[\"假设已经开启了redo\",{\"1\":{\"616\":1}}],[\"假设trx2是一个超大事务\",{\"1\":{\"601\":1}}],[\"假设了三组事务在主库的执行情况\",{\"1\":{\"601\":1}}],[\"假设hash\",{\"1\":{\"598\":1}}],[\"假设在t这个时刻\",{\"1\":{\"604\":1}}],[\"假设在上图的基础上\",{\"1\":{\"598\":1}}],[\"假设在redo\",{\"1\":{\"464\":1}}],[\"假设主库a和备库b的主备延迟是30分钟\",{\"1\":{\"596\":1}}],[\"假设binlog的格式设置为mixed\",{\"1\":{\"591\":1}}],[\"假设时序图如下\",{\"1\":{\"584\":1}}],[\"假设执行的场景序列如下\",{\"1\":{\"583\":1}}],[\"假设执行的查询语句是select\",{\"1\":{\"479\":1}}],[\"假设in语句20000个参数的话\",{\"1\":{\"690\":1}}],[\"假设index\",{\"1\":{\"514\":1}}],[\"假设id是表t的主键\",{\"1\":{\"580\":1}}],[\"假设4个id分别是1\",{\"1\":{\"559\":1}}],[\"假设有这样一个流\",{\"1\":{\"1487\":1}}],[\"假设有以下场景\",{\"1\":{\"629\":1}}],[\"假设有两个并行执行的事务\",{\"1\":{\"628\":1}}],[\"假设有如下bean\",{\"1\":{\"1515\":1}}],[\"假设有如下场景\",{\"1\":{\"613\":1}}],[\"假设有如下数据结构\",{\"1\":{\"554\":1}}],[\"假设有1000个并发线程要同时更新同一行\",{\"1\":{\"581\":1}}],[\"假设有一个类\",{\"1\":{\"1484\":1}}],[\"假设有一个表t\",{\"1\":{\"596\":1}}],[\"假设有一个英语学习app\",{\"1\":{\"556\":1}}],[\"假设有一张这样的表t\",{\"1\":{\"454\":1}}],[\"假设小表的行数是n\",{\"1\":{\"540\":1}}],[\"假设驱动表的行数是n\",{\"1\":{\"538\":1}}],[\"假设驱动表trade\",{\"1\":{\"505\":1}}],[\"假设被驱动表的行数是m\",{\"1\":{\"538\":1}}],[\"假设不使用join\",{\"1\":{\"538\":1}}],[\"假设表t里面已经有了\",{\"1\":{\"628\":1}}],[\"假设表t中现在有10000条记录\",{\"1\":{\"533\":1}}],[\"假设表中确实有一个唯一的字段\",{\"1\":{\"472\":1}}],[\"假设系统里面还有另外一张表trade\",{\"1\":{\"505\":1}}],[\"假设要实现一个电影票在线交易业务\",{\"1\":{\"580\":1}}],[\"假设要查询城市是\",{\"1\":{\"490\":1}}],[\"假设要执行select\",{\"1\":{\"482\":1}}],[\"假设维护的数据库是同一个市的公民信息系统\",{\"1\":{\"489\":1}}],[\"假设\",{\"1\":{\"486\":1,\"599\":1,\"605\":1,\"622\":1}}],[\"假设这里l6\",{\"1\":{\"487\":1}}],[\"假设这张表上包含了10万行的数据\",{\"1\":{\"483\":1}}],[\"假设这个库是一天一备\",{\"1\":{\"622\":1}}],[\"假设这个市民表的定义如下\",{\"1\":{\"475\":1}}],[\"假设这个时候要查id\",{\"1\":{\"469\":1}}],[\"假设一系列的连续操作都会对同一个对象反复加锁及解锁\",{\"1\":{\"1363\":1}}],[\"假设一个mysql实例的tps是每秒50万\",{\"1\":{\"634\":1}}],[\"假设一个日志盘的io利用率已经是100\",{\"1\":{\"615\":1}}],[\"假设一个事务更新了表t1和t2中的各一行\",{\"1\":{\"597\":1}}],[\"假设一个事务a执行到一半\",{\"1\":{\"588\":1}}],[\"假设一个值从1被顺序改成了2\",{\"1\":{\"571\":1}}],[\"假设一个业务的更新模式是写入之后马上会做查询\",{\"1\":{\"481\":1}}],[\"假设一共有n个房子\",{\"1\":{\"431\":1}}],[\"假设现在主库上有其他的数据表有大量的更新\",{\"1\":{\"596\":1}}],[\"假设现在已经记录了从2016年初到2018年底的所有数据\",{\"1\":{\"503\":1}}],[\"假设现在维护的是一个交易系统\",{\"1\":{\"503\":1}}],[\"假设现在维护着一个身份证信息和姓名的表\",{\"1\":{\"469\":1}}],[\"假设现在的需求是检索出表中\",{\"1\":{\"477\":1}}],[\"假设我们所使用的哈希算法就是简单的用key\",{\"1\":{\"1427\":1}}],[\"假设我们采用线程池+future的方案\",{\"1\":{\"1394\":1}}],[\"假设我们设置innodb\",{\"1\":{\"613\":1}}],[\"假设我们给扫描过程中碰到的所有行都加上写锁\",{\"1\":{\"584\":1}}],[\"假设我们的表结构如下\",{\"1\":{\"556\":1}}],[\"假设我们执行如下语句\",{\"1\":{\"549\":1,\"550\":1}}],[\"假设我们执行这样一条sql语句\",{\"1\":{\"504\":1}}],[\"假设我们要实现与这样的sql语句相同的功能\",{\"1\":{\"1490\":1}}],[\"假设我们要对一个集合中的元素提取出单词并去重\",{\"1\":{\"1486\":1}}],[\"假设我们要查询的语句如下\",{\"1\":{\"488\":1}}],[\"假设我们要判断\",{\"1\":{\"307\":1}}],[\"假设我们有一个主键列为id的表\",{\"1\":{\"472\":1}}],[\"假设字符串text1​和text2​的长度分别为m和n\",{\"1\":{\"427\":1}}],[\"假设另一个输入\",{\"1\":{\"307\":1}}],[\"频繁地互斥同步操作也会导致不必要的性能损耗\",{\"1\":{\"1363\":1}}],[\"频繁更新的字段不适合创建索引\",{\"1\":{\"496\":1}}],[\"频繁作为查询条件的字段应该创建索引\",{\"1\":{\"495\":1}}],[\"紧凑处理\",{\"1\":{\"491\":1}}],[\"外\",{\"1\":{\"692\":2}}],[\"外部化配置\",{\"0\":{\"1750\":1}}],[\"外部化配置作为依赖来源\",{\"0\":{\"1139\":1}}],[\"外部检测天然有一个问题\",{\"1\":{\"615\":1}}],[\"外部排序一般使用归并排序算法\",{\"1\":{\"491\":1}}],[\"外键约束\",{\"1\":{\"602\":1}}],[\"外键关系建立索引\",{\"1\":{\"495\":1}}],[\"外层select将被标记为derived\",{\"1\":{\"467\":1}}],[\"建议用date数据类型来保存日期\",{\"1\":{\"666\":1}}],[\"建议使用groupingbyconcurrent\",{\"1\":{\"1495\":1}}],[\"建议使用treemap\",{\"1\":{\"1421\":1}}],[\"建议使用tinyint代替enum\",{\"1\":{\"665\":1}}],[\"建议使用concurrenthashmap\",{\"1\":{\"1421\":1,\"1432\":1}}],[\"建议使用整形类型来运算和存储实数\",{\"1\":{\"665\":1}}],[\"建议指定为unsigned无符号类型\",{\"1\":{\"665\":1}}],[\"建议\",{\"1\":{\"665\":1,\"666\":1,\"667\":1}}],[\"建表sql\",{\"1\":{\"671\":1}}],[\"建表\",{\"1\":{\"574\":1}}],[\"建表语法是create\",{\"1\":{\"546\":1,\"547\":1}}],[\"建表语句如下\",{\"1\":{\"490\":1,\"503\":1}}],[\"建立连接\",{\"0\":{\"1810\":1}}],[\"建立连接的过程通常是比较复杂的\",{\"1\":{\"455\":1}}],[\"建立内存文件映射\",{\"1\":{\"1464\":1}}],[\"建立主备关系\",{\"1\":{\"622\":1}}],[\"建立返回父节点连接\",{\"1\":{\"395\":1}}],[\"建立一个新的并查集\",{\"1\":{\"356\":1}}],[\"算出set\",{\"1\":{\"605\":1}}],[\"算出来的值虽然有冲突的概率\",{\"1\":{\"489\":1}}],[\"算法是学习任何一门编程语言都绕不开的知识\",{\"1\":{\"1850\":1}}],[\"算法是解决特定问题求解步骤的描述\",{\"1\":{\"282\":1}}],[\"算法部分并不是要完全学完所有的题目才开始学下一个阶段\",{\"1\":{\"1850\":1}}],[\"算法训练营\",{\"1\":{\"1844\":1,\"1850\":2}}],[\"算法的要求并不算特别高\",{\"1\":{\"1848\":1}}],[\"算法的成熟以及硬件的发展\",{\"1\":{\"1404\":1}}],[\"算法的流程图如下\",{\"1\":{\"542\":1}}],[\"算法\",{\"0\":{\"1850\":1},\"1\":{\"542\":1,\"660\":2}}],[\"算法刷题\",{\"0\":{\"357\":1}}],[\"算法步骤\",{\"1\":{\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":1,\"323\":1}}],[\"算法设计的要求\",{\"1\":{\"282\":1}}],[\"算法具有五个基本特性\",{\"1\":{\"282\":1}}],[\"函数指针\",{\"1\":{\"1479\":1}}],[\"函数式的方式\",{\"1\":{\"1497\":1}}],[\"函数式接口扩展\",{\"0\":{\"1478\":1}}],[\"函数式接口定义\",{\"0\":{\"1471\":1}}],[\"函数式接口是函数式编程中最重要的概念\",{\"1\":{\"1470\":1}}],[\"函数式接口\",{\"1\":{\"1470\":2,\"1472\":1}}],[\"函数式编程又指的是什么\",{\"1\":{\"1484\":1}}],[\"函数式编程必须依附这样一类特殊的对象\",{\"1\":{\"1472\":1}}],[\"函数式编程与传统的编码方式相比最明显的区别就是\",{\"1\":{\"1470\":1}}],[\"函数式编程的意义\",{\"0\":{\"1468\":1}}],[\"函数式编程的基础是不可变性\",{\"1\":{\"1404\":1}}],[\"函数式编程概览\",{\"0\":{\"1467\":1}}],[\"函数返回\",{\"1\":{\"1446\":1}}],[\"函数就可以返回\",{\"1\":{\"1442\":1}}],[\"函数会创建父进程的一个完整副本\",{\"1\":{\"1404\":1}}],[\"函数来获取当前主库的系统时间\",{\"1\":{\"594\":1}}],[\"函数的参数是一个函数\",{\"1\":{\"1470\":1}}],[\"函数的返回时间\",{\"1\":{\"591\":1}}],[\"函数的话\",{\"1\":{\"503\":1}}],[\"函数生成一个大于0小于1的随机小数\",{\"1\":{\"557\":1}}],[\"函数对应的值\",{\"1\":{\"503\":1}}],[\"函数操作\",{\"0\":{\"503\":1},\"1\":{\"503\":1}}],[\"函数\",{\"1\":{\"489\":1,\"505\":1,\"506\":1}}],[\"函数得到的结果可能是相同的\",{\"1\":{\"489\":1}}],[\"倒序方式每次写和读的时候\",{\"1\":{\"489\":1}}],[\"倒序存储方式使用4个字节的前缀长度应该是不够的\",{\"1\":{\"489\":1}}],[\"倒序存储方式在主键索引上\",{\"1\":{\"489\":1}}],[\"倒序存储的字段上创建的索引是按照倒序字符串的方式排序的\",{\"1\":{\"489\":1}}],[\"倒序存储是指如果存储身份证号码的时候把它倒过来存\",{\"1\":{\"489\":1}}],[\"倒序存储和使用哈希字段\",{\"1\":{\"489\":1}}],[\"才将一系列的sink有机的串联了起来\",{\"1\":{\"1500\":1}}],[\"才将其发到从库上\",{\"1\":{\"607\":1}}],[\"才会对元数据的计算才会真正的进行执行\",{\"1\":{\"1496\":1}}],[\"才会真正的执行\",{\"1\":{\"1487\":1}}],[\"才会发挥其特性\",{\"1\":{\"1470\":1}}],[\"才会向mysql申请事务id\",{\"1\":{\"679\":1}}],[\"才会被删除\",{\"1\":{\"571\":1}}],[\"才只保证了自增id是递增的\",{\"1\":{\"628\":1}}],[\"才有了\",{\"1\":{\"627\":1}}],[\"才有可能发现为你\",{\"1\":{\"615\":1}}],[\"才断开了session\",{\"1\":{\"618\":1}}],[\"才开始进入语句终止逻辑\",{\"1\":{\"618\":1}}],[\"才是在实际应用中使用的最多的\",{\"1\":{\"1486\":1}}],[\"才是所谓的并发查询\",{\"1\":{\"613\":1}}],[\"才是将数据持久化到磁盘的操作\",{\"1\":{\"587\":1}}],[\"才可以使用方法引用\",{\"1\":{\"1480\":1}}],[\"才可以用的上零拷贝\",{\"1\":{\"1465\":1}}],[\"才可以设置slave\",{\"1\":{\"604\":1}}],[\"才可以这么做\",{\"1\":{\"485\":1}}],[\"才不会备库同步线程停止\",{\"1\":{\"550\":1}}],[\"才能效率最高\",{\"1\":{\"1489\":1}}],[\"才能lambda表达式真正的含义\",{\"1\":{\"1470\":1}}],[\"才能让mysql拥有较高的并发能力\",{\"1\":{\"680\":1}}],[\"才能避免整个系统锁死\",{\"1\":{\"613\":1}}],[\"才能给客户端返回\",{\"1\":{\"609\":1}}],[\"才能切换\",{\"1\":{\"596\":1}}],[\"才能继续执行\",{\"1\":{\"570\":1}}],[\"才能体现出\",{\"1\":{\"541\":1}}],[\"才能够满足区分度的要求\",{\"1\":{\"489\":1}}],[\"例如调用类的main\",{\"1\":{\"1540\":1}}],[\"例如使用java\",{\"1\":{\"1497\":1}}],[\"例如使用单独的汇总表\",{\"1\":{\"527\":1}}],[\"例如java\",{\"1\":{\"1497\":1}}],[\"例如foreachremaining\",{\"1\":{\"1497\":1}}],[\"例如一个员工构成的流的工资的总数\",{\"1\":{\"1492\":1}}],[\"例如一个语句要删除100万行数据\",{\"1\":{\"599\":1}}],[\"例如binaryoperator\",{\"1\":{\"1477\":1}}],[\"例如实现动态创建属性\",{\"1\":{\"1435\":1}}],[\"例如put新键值对\",{\"1\":{\"1423\":1}}],[\"例如程序执行如下代码\",{\"1\":{\"1423\":1}}],[\"例如引入了红黑树的数据结构和扩容优化等\",{\"1\":{\"1422\":1}}],[\"例如定时任务\",{\"1\":{\"1410\":1}}],[\"例如go语言\",{\"1\":{\"1410\":1}}],[\"例如父进程的地址空间用到了1g的内存\",{\"1\":{\"1404\":1}}],[\"例如常用的string\",{\"1\":{\"1403\":1}}],[\"例如第三方库在捕获到thread\",{\"1\":{\"1401\":1}}],[\"例如arrayblockingqueue如果容量满了\",{\"1\":{\"1378\":1}}],[\"例如antlr4\",{\"1\":{\"650\":1}}],[\"例如linkedblockingqueue的上限是integer\",{\"1\":{\"1378\":1}}],[\"例如赋值给类变量或可以在其它线程中访问的实例变量\",{\"1\":{\"1365\":1}}],[\"例如作为调用参数传递到其他方法中\",{\"1\":{\"1365\":1}}],[\"例如秒杀场景\",{\"1\":{\"763\":1}}],[\"例如当系统运行不正常时发邮件通知相关人员\",{\"1\":{\"761\":1}}],[\"例如myisam这种不支持事务的引擎\",{\"1\":{\"575\":1}}],[\"例如下面使用聚合函数count\",{\"1\":{\"527\":1}}],[\"例如在做一个关联查询时\",{\"1\":{\"526\":1}}],[\"例如在新闻网站中取出100条记录\",{\"1\":{\"520\":1}}],[\"例如\",{\"1\":{\"523\":1,\"527\":1,\"530\":1,\"531\":2,\"578\":1,\"594\":1,\"674\":1,\"1356\":1,\"1438\":1,\"1470\":1,\"1471\":1,\"1486\":1,\"1488\":1,\"1495\":3,\"1497\":2,\"1500\":1}}],[\"例如select\",{\"1\":{\"503\":1}}],[\"例如身份证号\",{\"1\":{\"489\":1}}],[\"例如邮箱\",{\"1\":{\"486\":1}}],[\"zookeeper视频\",{\"1\":{\"1869\":1}}],[\"zookeeper是一个高可用的分布式管理与协调框架\",{\"1\":{\"1869\":1}}],[\"zookeeper集群与watcher监听机制\",{\"0\":{\"1842\":1}}],[\"zookeeper集群leader选举\",{\"0\":{\"1841\":1}}],[\"zookeeper经典应用场景\",{\"0\":{\"1840\":1}}],[\"zookeeper特性与节点数据类型\",{\"0\":{\"1839\":1}}],[\"zookeeper\",{\"0\":{\"1838\":1,\"1869\":1}}],[\"zgc详解\",{\"0\":{\"1551\":1}}],[\"zero\",{\"1\":{\"1427\":1,\"1460\":1,\"1496\":1,\"1498\":1,\"1500\":1}}],[\"zunionstore\",{\"1\":{\"711\":3}}],[\"zinterstore\",{\"1\":{\"711\":3}}],[\"zincrby\",{\"1\":{\"711\":3}}],[\"zrevrank\",{\"1\":{\"711\":4}}],[\"zrevrangebyscore\",{\"1\":{\"711\":2}}],[\"zrevrangebyscorre\",{\"1\":{\"711\":1}}],[\"zrevrangebylex\",{\"1\":{\"711\":3}}],[\"zrevrange\",{\"1\":{\"711\":4}}],[\"zremrangbyrank\",{\"1\":{\"711\":1}}],[\"zremrangebyscore\",{\"1\":{\"711\":3}}],[\"zremrangebyrank\",{\"1\":{\"711\":2}}],[\"zremrangebylex\",{\"1\":{\"711\":3}}],[\"zrem\",{\"1\":{\"711\":3}}],[\"zrangebyscore\",{\"1\":{\"711\":4}}],[\"zrangebylex\",{\"1\":{\"711\":7}}],[\"zrange\",{\"1\":{\"711\":6}}],[\"zrank\",{\"1\":{\"711\":4}}],[\"zlexcount\",{\"1\":{\"711\":4}}],[\"zcount\",{\"1\":{\"711\":4}}],[\"zcard\",{\"1\":{\"711\":3}}],[\"zadd\",{\"1\":{\"711\":3}}],[\"zzz\",{\"1\":{\"656\":1,\"690\":2}}],[\"zh\",{\"1\":{\"1859\":1}}],[\"zhaoliu\",{\"1\":{\"1480\":2,\"1481\":2,\"1482\":1,\"1486\":1,\"1492\":1}}],[\"zhangsan=90\",{\"1\":{\"1490\":1}}],[\"zhangsan=2\",{\"1\":{\"1490\":1}}],[\"zhangsan\",{\"1\":{\"1475\":1,\"1477\":1,\"1480\":2,\"1481\":2,\"1482\":1,\"1486\":1,\"1490\":2,\"1492\":1}}],[\"zhangss\",{\"1\":{\"487\":1}}],[\"zhangssxyz\",{\"1\":{\"487\":3,\"488\":2}}],[\"zhangs\",{\"1\":{\"487\":4}}],[\"zhihu\",{\"1\":{\"1428\":1}}],[\"zhuanlan\",{\"1\":{\"1428\":1}}],[\"zhuge\",{\"1\":{\"655\":1,\"657\":8,\"673\":1}}],[\"z\",{\"1\":{\"554\":4,\"714\":1,\"761\":1}}],[\"zscan\",{\"1\":{\"711\":1}}],[\"zscore\",{\"1\":{\"711\":4}}],[\"zset\",{\"0\":{\"711\":1}}],[\"zs\",{\"1\":{\"467\":1}}],[\"逻辑队列\",{\"0\":{\"1834\":1}}],[\"逻辑\",{\"1\":{\"1492\":1}}],[\"逻辑或物理\",{\"1\":{\"1351\":1}}],[\"逻辑代码如下\",{\"1\":{\"635\":1}}],[\"逻辑上一致\",{\"1\":{\"485\":1}}],[\"逻辑结构又可以分为集合结构\",{\"1\":{\"328\":1}}],[\"改怎么办呢\",{\"1\":{\"1487\":1}}],[\"改变状态\",{\"1\":{\"1408\":1}}],[\"改变库表结构\",{\"1\":{\"527\":1}}],[\"改名为\",{\"1\":{\"706\":1}}],[\"改表名的时候\",{\"1\":{\"624\":1}}],[\"改成了5\",{\"1\":{\"584\":1}}],[\"改成\",{\"1\":{\"485\":1,\"584\":2}}],[\"改用除法\",{\"1\":{\"439\":1}}],[\"引导类加载器\",{\"1\":{\"1540\":1}}],[\"引导mysql使用我们期望的索引\",{\"1\":{\"485\":1}}],[\"引入\",{\"1\":{\"1460\":1}}],[\"引入了\",{\"1\":{\"1461\":1}}],[\"引入了一个系统调用方法\",{\"1\":{\"1459\":1}}],[\"引入了红黑树\",{\"1\":{\"1423\":1}}],[\"引用\",{\"1\":{\"1500\":1}}],[\"引用扩容前的entry数组\",{\"1\":{\"1427\":1}}],[\"引用类型\",{\"1\":{\"1357\":1}}],[\"引用计数算法\",{\"0\":{\"1592\":1}}],[\"引用计数\",{\"0\":{\"883\":1}}],[\"引起雪崩\",{\"1\":{\"769\":1}}],[\"引擎就会按照上面绿色箭头的路线\",{\"1\":{\"503\":1}}],[\"引擎把刚刚写入的redo\",{\"1\":{\"463\":1}}],[\"引擎将这行新数据更新到内存中\",{\"1\":{\"463\":1}}],[\"引擎直接用树搜索找到这一行\",{\"1\":{\"463\":1}}],[\"既费时\",{\"1\":{\"1484\":1}}],[\"既省去了重新计算hash值得时间\",{\"1\":{\"1427\":1}}],[\"既能提升并发性\",{\"1\":{\"629\":1}}],[\"既可以从表test1里面取出name=jyc记录的id值\",{\"1\":{\"651\":1}}],[\"既可以\",{\"1\":{\"602\":1}}],[\"既可以先从表里面取出c=10的记录的id值\",{\"1\":{\"458\":1}}],[\"既然调用并行流这么方便\",{\"1\":{\"1489\":1}}],[\"既然redis有可能挂掉\",{\"1\":{\"770\":1}}],[\"既然需要启动多个服务\",{\"1\":{\"746\":1}}],[\"既然是树\",{\"1\":{\"686\":1}}],[\"既然预先不知道要申请多少个自增id\",{\"1\":{\"629\":1}}],[\"既然要更新\",{\"1\":{\"615\":1}}],[\"既然备库没有请求\",{\"1\":{\"594\":1}}],[\"既然优化器放弃了使用索引a\",{\"1\":{\"485\":1}}],[\"迁移比较麻烦\",{\"1\":{\"485\":1}}],[\"三色标记算法\",{\"0\":{\"1621\":1}}],[\"三级缓存的示意图\",{\"1\":{\"1351\":1}}],[\"三种特殊数据类型\",{\"0\":{\"712\":1}}],[\"三种讨论的判断主备无延迟的逻辑\",{\"1\":{\"609\":1}}],[\"三个单点区间总共需要回表的记录数是58\",{\"1\":{\"686\":1}}],[\"三个并发事务\",{\"1\":{\"588\":1}}],[\"三个会话a\",{\"1\":{\"533\":1}}],[\"三表连接查询sql优化\",{\"1\":{\"500\":1}}],[\"三张表索引分析\",{\"0\":{\"500\":1}}],[\"三是这个语法并不是所有的数据库都支持\",{\"1\":{\"485\":1}}],[\"三次握手和四次挥手\",{\"0\":{\"100\":1}}],[\"依赖管理\",{\"0\":{\"1749\":1}}],[\"依赖\",{\"1\":{\"1395\":1}}],[\"依赖底层操作系统的互斥原语mutex\",{\"1\":{\"1360\":1}}],[\"依赖处理的过程\",{\"0\":{\"1124\":1}}],[\"依赖注入源码解析\",{\"0\":{\"1525\":1}}],[\"依赖注入底层实现原理\",{\"1\":{\"1507\":1}}],[\"依赖注入\",{\"0\":{\"1311\":1}}],[\"依赖注入environment\",{\"0\":{\"1309\":1}}],[\"依赖注入applicationeventpublisher\",{\"0\":{\"1281\":1}}],[\"依赖注入resourceloader\",{\"0\":{\"1206\":1}}],[\"依赖注入spring\",{\"0\":{\"1205\":1}}],[\"依赖注入和依赖查找的依赖来源是否相同\",{\"0\":{\"1141\":1}}],[\"依赖注入的判断条件\",{\"1\":{\"1525\":1}}],[\"依赖注入的来源\",{\"0\":{\"1134\":1}}],[\"依赖注入的模式和类型\",{\"0\":{\"1112\":1}}],[\"依赖注入类型选择\",{\"0\":{\"1119\":1}}],[\"依赖查找\",{\"0\":{\"1343\":1}}],[\"依赖查找environment\",{\"0\":{\"1310\":1}}],[\"依赖查找applicationeventmulticaster\",{\"0\":{\"1282\":1}}],[\"依赖查找的来源\",{\"0\":{\"1133\":1}}],[\"依赖查找中典型异常\",{\"0\":{\"1107\":1}}],[\"依赖查找简介\",{\"0\":{\"1100\":1}}],[\"依赖查找和依赖注入的区别\",{\"0\":{\"1076\":1}}],[\"依赖查找和依赖注入\",{\"0\":{\"1072\":1}}],[\"依赖于m和d的值\",{\"1\":{\"665\":2}}],[\"依然是\",{\"1\":{\"540\":1}}],[\"依然基于表t\",{\"1\":{\"484\":1}}],[\"依次判断事务t和每个worker队列的冲突关系\",{\"1\":{\"598\":1}}],[\"依次是\",{\"1\":{\"596\":1}}],[\"依次把它们的rowid取出来\",{\"1\":{\"558\":1}}],[\"依次到临时表中取出word值\",{\"1\":{\"557\":1}}],[\"依次到主键id索引中查记录\",{\"1\":{\"541\":1}}],[\"依次取出里面的id的值\",{\"1\":{\"555\":1}}],[\"依次取出叶子节点上id的值\",{\"1\":{\"553\":1}}],[\"依次累加\",{\"1\":{\"554\":1}}],[\"依次选取不同长度的前缀来看这个值\",{\"1\":{\"487\":1}}],[\"依次类推\",{\"1\":{\"340\":1,\"1492\":1}}],[\"采样的页面数量是\",{\"1\":{\"695\":1}}],[\"采样统计的时候\",{\"1\":{\"484\":1}}],[\"采样统计\",{\"1\":{\"484\":1}}],[\"采用约定大约配置的方式\",{\"1\":{\"1861\":1}}],[\"采用node数组加链表\",{\"1\":{\"1431\":1}}],[\"采用netty\",{\"1\":{\"720\":1}}],[\"采用thread\",{\"1\":{\"1410\":1}}],[\"采用的就是此模式\",{\"1\":{\"1407\":1}}],[\"采用的直连\",{\"1\":{\"720\":1}}],[\"采用死循环\",{\"1\":{\"1397\":1}}],[\"采用数组而非链表\",{\"1\":{\"1396\":1}}],[\"采用setnx\",{\"1\":{\"767\":1}}],[\"采用\",{\"1\":{\"720\":2}}],[\"采用不缓存的方式时\",{\"1\":{\"619\":1}}],[\"采用可靠性优先策略的话\",{\"1\":{\"596\":1}}],[\"采用force\",{\"1\":{\"485\":1}}],[\"采用采样统计的原因主要是\",{\"1\":{\"484\":1}}],[\"消费建议\",{\"0\":{\"1814\":1}}],[\"消费消息\",{\"0\":{\"1777\":1}}],[\"消费过程幂等\",{\"0\":{\"1735\":1}}],[\"消费者注册\",{\"0\":{\"1767\":1}}],[\"消费者组\",{\"0\":{\"1707\":1}}],[\"消费者一天的消费能力高于生产者\",{\"1\":{\"1413\":1}}],[\"消费者一天的消费能力已经高于生产者\",{\"1\":{\"1413\":1}}],[\"消费者加机器\",{\"1\":{\"1413\":1}}],[\"消费者每天能处理的量比生产者生产的多\",{\"1\":{\"1413\":2}}],[\"消费者每天能处理的量比生产者生产的少\",{\"1\":{\"1413\":1}}],[\"消费者每天只能消费5千条\",{\"1\":{\"1413\":1}}],[\"消费者处理任务\",{\"1\":{\"1412\":1}}],[\"消费者要实现workhandler接口\",{\"1\":{\"1398\":1}}],[\"消费者线程池\",{\"1\":{\"1412\":1}}],[\"消费者线程会尽最大努力监控缓冲区的变化\",{\"1\":{\"1397\":1}}],[\"消费者线程会不断地监控缓冲区变化\",{\"1\":{\"1397\":1}}],[\"消费者线程就会立刻消费\",{\"1\":{\"1396\":1}}],[\"消费者线程阻塞\",{\"1\":{\"1380\":1}}],[\"消费者时刻关注着队列里有没有消息\",{\"1\":{\"1396\":1}}],[\"消费者\",{\"0\":{\"1734\":1},\"1\":{\"1379\":1}}],[\"消费者模式可能出现过饱的问题\",{\"1\":{\"1413\":1}}],[\"消费者模式的核心是一个任务队列\",{\"1\":{\"1412\":1}}],[\"消费者模式的时候\",{\"1\":{\"1378\":1}}],[\"消费者模式\",{\"0\":{\"1412\":1}}],[\"消费者模型\",{\"1\":{\"1396\":1}}],[\"消费者模型中使用时\",{\"1\":{\"1379\":1}}],[\"消费者直接使用线程安全的队列就可以\",{\"1\":{\"1378\":1}}],[\"消耗资源比较多\",{\"1\":{\"1462\":1}}],[\"消耗性能\",{\"1\":{\"729\":1}}],[\"消耗内存\",{\"1\":{\"726\":1}}],[\"消耗的cpu资源越少\",{\"1\":{\"484\":1}}],[\"消息同步传输\",{\"0\":{\"1813\":1}}],[\"消息异步传输\",{\"0\":{\"1812\":1}}],[\"消息索引服务\",{\"0\":{\"1797\":1}}],[\"消息索引流程\",{\"0\":{\"1794\":1}}],[\"消息查询\",{\"0\":{\"1795\":1}}],[\"消息接收过程\",{\"0\":{\"1766\":1}}],[\"消息发送过程\",{\"0\":{\"1758\":1}}],[\"消息发布端\",{\"1\":{\"735\":1}}],[\"消息过滤类型\",{\"0\":{\"1781\":1}}],[\"消息过滤过程\",{\"0\":{\"1780\":1}}],[\"消息过滤\",{\"0\":{\"1728\":1,\"1789\":1}}],[\"消息刷盘\",{\"0\":{\"1724\":1,\"1765\":1}}],[\"消息存储过程\",{\"0\":{\"1761\":1}}],[\"消息存储整体架构\",{\"0\":{\"1722\":1}}],[\"消息存储\",{\"0\":{\"1721\":1}}],[\"消息重试\",{\"0\":{\"1715\":1,\"1806\":1}}],[\"消息顺序\",{\"0\":{\"1714\":1}}],[\"消息模型\",{\"0\":{\"1705\":1}}],[\"消息会被重复消费\",{\"1\":{\"1398\":1}}],[\"消息的广播\",{\"0\":{\"821\":1}}],[\"消息订阅\",{\"1\":{\"738\":1}}],[\"消息排队\",{\"1\":{\"708\":1}}],[\"消息队列\",{\"0\":{\"251\":1,\"1768\":1},\"1\":{\"708\":1,\"1354\":1}}],[\"扫描事务状态\",{\"0\":{\"1821\":1}}],[\"扫描处理的核心类\",{\"1\":{\"1529\":1}}],[\"扫描得到beandefinition\",{\"1\":{\"1528\":2}}],[\"扫描的整个过程说白了\",{\"1\":{\"1529\":1}}],[\"扫描的整体过程\",{\"1\":{\"1524\":1}}],[\"扫描的时候也会把bean的名字也存下来\",{\"1\":{\"1524\":1}}],[\"扫描的时候并不会解析\",{\"1\":{\"1524\":1}}],[\"扫描的核心方法\",{\"1\":{\"1524\":1}}],[\"扫描的行数是10000\",{\"1\":{\"557\":1}}],[\"扫描的行数中的大部分都很可能是被where条件过滤掉的\",{\"1\":{\"527\":1}}],[\"扫描的行数也从小到大\",{\"1\":{\"527\":1}}],[\"扫描的行数和访问类型\",{\"0\":{\"527\":1}}],[\"扫描的行数和返回的行数应该是相同的\",{\"1\":{\"526\":1}}],[\"扫描的行数和返回的行数\",{\"0\":{\"526\":1}}],[\"扫描的行数对返回的行数的比率通常很小\",{\"1\":{\"526\":1}}],[\"扫描的行数\",{\"1\":{\"524\":1}}],[\"扫描的行数的估计值依然不准确\",{\"1\":{\"484\":1}}],[\"扫描的行数越少\",{\"1\":{\"484\":1}}],[\"扫描100次t1表的索引\",{\"1\":{\"661\":1}}],[\"扫描100行\",{\"1\":{\"661\":1}}],[\"扫描完成后\",{\"1\":{\"555\":1,\"1530\":1}}],[\"扫描到的类上如果存在\",{\"1\":{\"1512\":1}}],[\"扫描到整个输入的数据结束\",{\"1\":{\"554\":1}}],[\"扫描到id=10的时候才插入m=0这一行\",{\"1\":{\"553\":1}}],[\"扫描表t1的索引a\",{\"1\":{\"553\":1,\"555\":1}}],[\"扫描表t1\",{\"1\":{\"540\":1,\"544\":1}}],[\"扫描表t2\",{\"1\":{\"540\":2,\"544\":1}}],[\"扫描额外的记录\",{\"0\":{\"524\":1}}],[\"扫描行数\",{\"1\":{\"656\":1}}],[\"扫描行数就会过多\",{\"1\":{\"540\":1}}],[\"扫描行数最少的方式找到需要的记录\",{\"1\":{\"527\":1}}],[\"扫描行数是n+λ\",{\"1\":{\"540\":1}}],[\"扫描行数是1\",{\"1\":{\"505\":1}}],[\"扫描行数是影响执行代价的因素之一\",{\"1\":{\"484\":1}}],[\"扫描行数成了影响决策的主要条件\",{\"1\":{\"485\":1}}],[\"来源\",{\"0\":{\"1643\":1}}],[\"来源于linux系统的sendfile方法逻辑\",{\"1\":{\"1453\":1}}],[\"来源于同一层兄弟节点的有序性\",{\"1\":{\"503\":1}}],[\"来分别做这两件事情\",{\"1\":{\"1561\":1}}],[\"来加深对于stream的理解\",{\"1\":{\"1485\":1}}],[\"来加深对于实例方法名引用的理解\",{\"1\":{\"1482\":1}}],[\"来加速整个数据恢复过程\",{\"1\":{\"622\":1}}],[\"来完成相同的功能\",{\"1\":{\"1480\":1}}],[\"来完成对数据库中数据的操作\",{\"1\":{\"706\":1}}],[\"来返回比较小的那一个\",{\"1\":{\"1478\":1}}],[\"来返回记录\",{\"1\":{\"527\":1}}],[\"来推测出\",{\"1\":{\"1472\":1}}],[\"来声明函数式接口\",{\"1\":{\"1471\":1}}],[\"来实现\",{\"1\":{\"1527\":1}}],[\"来实现各种各样的操作\",{\"1\":{\"1470\":1}}],[\"来实现的\",{\"1\":{\"588\":1}}],[\"来进行传输的\",{\"1\":{\"1460\":1}}],[\"来拷贝数据\",{\"1\":{\"1460\":1}}],[\"来找到就绪的描述符\",{\"1\":{\"1446\":1}}],[\"来得到该对象的保存位\",{\"1\":{\"1425\":1}}],[\"来定位该键值对的存储位置\",{\"1\":{\"1423\":1}}],[\"来定位记录\",{\"1\":{\"476\":1}}],[\"来选择合适的阻塞队列\",{\"1\":{\"1386\":1}}],[\"来描述\",{\"1\":{\"1354\":1}}],[\"来设置另一个短期key来锁住当前key的访问\",{\"1\":{\"767\":1}}],[\"来保证操作安全\",{\"1\":{\"1431\":1}}],[\"来保证每次只有一个slave\",{\"1\":{\"761\":1}}],[\"来保存中间结果\",{\"1\":{\"555\":1}}],[\"来保存身份证的校验码\",{\"1\":{\"489\":1}}],[\"来计算全表扫描成本\",{\"1\":{\"685\":1}}],[\"来表示当前记录已经被删除\",{\"1\":{\"679\":1}}],[\"来处理这个thd\",{\"1\":{\"618\":1}}],[\"来达到提升备库复制并发度的目的\",{\"1\":{\"602\":1}}],[\"来看具体的例子\",{\"1\":{\"1476\":1}}],[\"来看一个具体的例子\",{\"1\":{\"1478\":1}}],[\"来看一个输入参数与返回结果参数类型不一致的例子\",{\"1\":{\"1475\":1}}],[\"来看一下sql执行计划\",{\"1\":{\"498\":1}}],[\"来看这样一个例子\",{\"1\":{\"1472\":1}}],[\"来看看数据恢复的问题\",{\"1\":{\"591\":1}}],[\"来判断节点的角色\",{\"1\":{\"590\":1}}],[\"来解决\",{\"1\":{\"585\":1}}],[\"来解决这个问题\",{\"1\":{\"554\":1}}],[\"来确认产品已经发布成功了\",{\"1\":{\"608\":1}}],[\"来确认需要的数据被放在哪个分表上\",{\"1\":{\"548\":1}}],[\"来确保数据页不会被多次执行重复的redo\",{\"1\":{\"588\":1}}],[\"来确保拿到一致性视图\",{\"1\":{\"575\":1}}],[\"来查看当前的值\",{\"1\":{\"570\":1}}],[\"来查看mysqldumpslow的帮助信息\",{\"1\":{\"566\":1}}],[\"来查看以下具体的执行情况\",{\"1\":{\"483\":1}}],[\"来验证扫描行数是否是20003\",{\"1\":{\"557\":1}}],[\"来记录并统计结果\",{\"1\":{\"554\":1}}],[\"来举例\",{\"1\":{\"551\":1}}],[\"来显示实例的临时文件目录\",{\"1\":{\"549\":1}}],[\"来触发bka算法\",{\"1\":{\"544\":1}}],[\"来说\",{\"1\":{\"536\":3,\"690\":1}}],[\"来提供给优化器做选择\",{\"1\":{\"485\":1}}],[\"来和session\",{\"1\":{\"483\":1}}],[\"来让优化器强制使用索引a\",{\"1\":{\"483\":1}}],[\"转向步骤6\",{\"1\":{\"1426\":1}}],[\"转发\",{\"1\":{\"1351\":1}}],[\"转成顺序写\",{\"1\":{\"482\":1}}],[\"转为数字\",{\"1\":{\"388\":1}}],[\"完美地弥补了future上述的种种问题\",{\"1\":{\"1395\":1}}],[\"完美生效\",{\"1\":{\"720\":1}}],[\"完整的解析配置类流程图\",{\"1\":{\"1529\":1}}],[\"完整的哨兵模式配置文件\",{\"1\":{\"761\":1}}],[\"完整的演示过程如下\",{\"1\":{\"628\":1}}],[\"完整的执行序列如下\",{\"1\":{\"559\":1}}],[\"完整的排序的执行流程图如下\",{\"1\":{\"557\":1}}],[\"完成两个map的合并操作\",{\"1\":{\"1495\":1}}],[\"完成了1次dma拷贝\",{\"1\":{\"1457\":1}}],[\"完成第二次cpu切换\",{\"1\":{\"1457\":1}}],[\"完成第一次cpu切换\",{\"1\":{\"1457\":1}}],[\"完成的流程图\",{\"1\":{\"1371\":1}}],[\"完成failover所需的时间就越长\",{\"1\":{\"761\":1}}],[\"完成后对原有文件进行原子替换\",{\"1\":{\"725\":1}}],[\"完成后自动结束\",{\"1\":{\"724\":1}}],[\"完成\",{\"1\":{\"650\":1}}],[\"完成比较\",{\"1\":{\"558\":1}}],[\"完成上述操作之后\",{\"1\":{\"482\":1}}],[\"完全是够用的\",{\"1\":{\"1490\":1}}],[\"完全二叉树的节点个数\",{\"0\":{\"407\":1}}],[\"完全手写的方式\",{\"1\":{\"385\":1}}],[\"我最开始学习的是kafka\",{\"1\":{\"1863\":1}}],[\"我曾经看了三遍\",{\"1\":{\"1853\":1}}],[\"我先分享下自己对不同学习方式的理解\",{\"1\":{\"1846\":1}}],[\"我先把可能的数据先预先访问一遍\",{\"1\":{\"770\":1}}],[\"我再执行start\",{\"1\":{\"605\":1}}],[\"我设置的为1秒\",{\"1\":{\"565\":1}}],[\"我用下面的表\",{\"1\":{\"551\":1}}],[\"我要往page插入一行\",{\"1\":{\"482\":1}}],[\"我们已经具备实际项目的开发能力了\",{\"1\":{\"1862\":1}}],[\"我们目前只学习\",{\"1\":{\"1852\":1}}],[\"我们有必要了解一下有关分区和分组的实现\",{\"1\":{\"1495\":1}}],[\"我们打印一下\",{\"1\":{\"1494\":1}}],[\"我们去掉characteristics方法中的枚举项identity\",{\"1\":{\"1494\":1}}],[\"我们提到过characteristics这个内部枚举类\",{\"1\":{\"1494\":1}}],[\"我们才能体会到函数式编程带给我们巨大好处\",{\"1\":{\"1490\":1}}],[\"我们尝试实现一个稍微复杂的需求\",{\"1\":{\"1490\":1}}],[\"我们曾经在内部迭代与外部迭代的章节中提到过\",{\"1\":{\"1490\":1}}],[\"我们更多的是使用链式的写法\",{\"1\":{\"1487\":1}}],[\"我们猜想代码可能是这样的\",{\"1\":{\"1487\":1}}],[\"我们要想写出好的代码\",{\"1\":{\"1870\":1}}],[\"我们要用到map接口中所新增加的默认方法computeifabsent\",{\"1\":{\"1495\":1}}],[\"我们要找到长度为5的字符串\",{\"1\":{\"1489\":1}}],[\"我们要找出流中大于2的元素\",{\"1\":{\"1487\":1}}],[\"我们要考虑的原则就是空间了\",{\"1\":{\"476\":1}}],[\"我们不妨来看一下优化的时候调用的sourcestagespliterator方法\",{\"1\":{\"1499\":1}}],[\"我们不妨来看一下这个方法的源码\",{\"1\":{\"1484\":1}}],[\"我们不去了解\",{\"1\":{\"687\":1}}],[\"我们补充一些关于jdk8中默认方法的相关介绍\",{\"1\":{\"1484\":1}}],[\"我们增加一个方法\",{\"1\":{\"1482\":1}}],[\"我们依然使用排序这个例子\",{\"1\":{\"1481\":1}}],[\"我们依然可以用树搜索的方式定位到第一个满足city=\",{\"1\":{\"493\":1}}],[\"我们给定两个字符串\",{\"1\":{\"1478\":1}}],[\"我们定义了一个接口\",{\"1\":{\"1472\":1}}],[\"我们继续往下\",{\"1\":{\"1471\":1}}],[\"我们一直再说中间操作和终止操作\",{\"1\":{\"1488\":1}}],[\"我们一行一行来仔细阅读一下这段文档\",{\"1\":{\"1471\":1}}],[\"我们一般情况下只用配置从机就好了\",{\"1\":{\"747\":1}}],[\"我们非常有必要首来认识一下\",{\"1\":{\"1470\":1}}],[\"我们查看一下第二种方式\",{\"1\":{\"1470\":1}}],[\"我们都会给出lambda表达式的方式和方法引用的方式实现相同的功能\",{\"1\":{\"1479\":1}}],[\"我们都知道list本身继承了collection集合接口\",{\"1\":{\"1470\":1}}],[\"我们都是需要配合stream\",{\"1\":{\"1470\":1}}],[\"我们都将他投递给线程池处理\",{\"1\":{\"1450\":1}}],[\"我们首先需要理解collector泛型的含义\",{\"1\":{\"1492\":1}}],[\"我们首先需要了解我们为什么需要需要lambda表达式\",{\"1\":{\"1470\":1}}],[\"我们首先来看一下basestream类的定义\",{\"1\":{\"1496\":1}}],[\"我们首先来看一下这里面调用的counting\",{\"1\":{\"1490\":1}}],[\"我们首先来阅读一下binaryoperator这个函数式接口的文档\",{\"1\":{\"1478\":1}}],[\"我们首先创建了一个元素为5\",{\"1\":{\"1484\":1}}],[\"我们首先使用不同的方式来创建一个stream对象\",{\"1\":{\"1484\":1}}],[\"我们首先类阅读一下predicate的javadoc\",{\"1\":{\"1476\":1}}],[\"我们首先从遍历打印集合中元素这样非常常见的例子开始\",{\"1\":{\"1470\":1}}],[\"我们可能会写出如下代码\",{\"1\":{\"1475\":1}}],[\"我们可能会编写这样的代码\",{\"1\":{\"1468\":1}}],[\"我们可以看一些具体的例子\",{\"1\":{\"1493\":1}}],[\"我们可以看到\",{\"1\":{\"553\":1}}],[\"我们可以简单的看一下这个方法接收的参数以及它要完成的事情\",{\"1\":{\"1490\":1}}],[\"我们可以简单的了解一下他们之前的区别\",{\"1\":{\"1470\":1}}],[\"我们可以来了解一下这个range\",{\"1\":{\"1484\":1}}],[\"我们可以很轻松的写出如下代码\",{\"1\":{\"1483\":1}}],[\"我们可以给出例子\",{\"1\":{\"1476\":1}}],[\"我们可以换一种写法\",{\"1\":{\"1472\":1}}],[\"我们可以得出如下结论\",{\"1\":{\"1457\":1}}],[\"我们可以得到两个结论\",{\"1\":{\"538\":1}}],[\"我们可以注册op\",{\"1\":{\"1451\":1}}],[\"我们可以轻松地组织不同任务的运行顺序\",{\"1\":{\"1395\":1}}],[\"我们可以单独为某个表设置是否自动重新计算统计数的属性\",{\"1\":{\"696\":1}}],[\"我们可以单独设置某个表的采样页面的数量\",{\"1\":{\"695\":1}}],[\"我们可以计算order\",{\"1\":{\"690\":1}}],[\"我们可以针对索引列\",{\"1\":{\"690\":1}}],[\"我们可以从binlog备份系统中找到需要的binlog\",{\"1\":{\"622\":1}}],[\"我们可以检测出由于并发线程过多导致的数据库不可用的情况\",{\"1\":{\"614\":1}}],[\"我们可以将方法引用看作是一个\",{\"1\":{\"1479\":1}}],[\"我们可以将查询请求分为两类\",{\"1\":{\"607\":1}}],[\"我们可以将已经遍历过的格子进行标记\",{\"1\":{\"435\":1}}],[\"我们可以执行如下语句序列\",{\"1\":{\"605\":1}}],[\"我们可以把slave\",{\"1\":{\"604\":1}}],[\"我们可以用seconds\",{\"1\":{\"594\":1}}],[\"我们可以对分区表做以下总结\",{\"1\":{\"562\":1}}],[\"我们可以在mysql\",{\"1\":{\"615\":1}}],[\"我们可以在group\",{\"1\":{\"555\":1}}],[\"我们可以在该数组上二分找到目标元素\",{\"1\":{\"443\":1}}],[\"我们可以按照这个思路\",{\"1\":{\"545\":1}}],[\"我们可以知道λ=k\",{\"1\":{\"540\":1}}],[\"我们可以通过tomcat的server\",{\"1\":{\"1561\":1}}],[\"我们可以通过collector中的of方法实现自定的收集器\",{\"1\":{\"1492\":1}}],[\"我们可以通过匿名内部类的方式来操作\",{\"1\":{\"1474\":1}}],[\"我们可以通过lambda表达式来创建runnable接口的实例\",{\"1\":{\"1471\":1}}],[\"我们可以通过指定stats\",{\"1\":{\"695\":1}}],[\"我们可以通过如下的语句\",{\"1\":{\"690\":1}}],[\"我们可以通过下面的语句序列验证\",{\"1\":{\"631\":1}}],[\"我们可以通过修改参数\",{\"1\":{\"492\":1}}],[\"我们可以通过统计索引上有多少个不同的值来判断需要使用多长的前缀\",{\"1\":{\"487\":1}}],[\"我们可以通过慢查询日志\",{\"1\":{\"483\":1}}],[\"我们可以新建一个更合适的索引\",{\"1\":{\"485\":1}}],[\"我们可以使用这个方法将使用tolist收集的方法来转换为一个不可变的集合\",{\"1\":{\"1495\":1}}],[\"我们可以使用slaveof\",{\"1\":{\"748\":1}}],[\"我们可以使用show\",{\"1\":{\"484\":1}}],[\"我们可以使用analyze\",{\"1\":{\"484\":1}}],[\"我们实现客户端发送消息服务端将消息回传我们的功能\",{\"1\":{\"1450\":1}}],[\"我们每次扩容都会将长度扩容为原来的2倍\",{\"1\":{\"1427\":1}}],[\"我们生产者只需要从队列里取出它们就可以了\",{\"1\":{\"1378\":1}}],[\"我们主要的关注点\",{\"1\":{\"1371\":1}}],[\"我们主要关注event\",{\"1\":{\"616\":1}}],[\"我们优先考虑哨兵模式\",{\"1\":{\"756\":1}}],[\"我们这里是使用命令搭建\",{\"1\":{\"747\":1}}],[\"我们这里有两个索引\",{\"1\":{\"686\":1}}],[\"我们存什么都不会有乱码的担忧了\",{\"1\":{\"720\":1}}],[\"我们常用的方法都可以直接通过redistemplate操作\",{\"1\":{\"720\":1}}],[\"我们启动另外一个客户端模拟插队线程\",{\"1\":{\"718\":1}}],[\"我们连接另一个客户端向newlist中push了test\",{\"1\":{\"708\":1}}],[\"我们能对它们多增删改查操作\",{\"1\":{\"696\":1}}],[\"我们也尝试着自己实现了两个相对比较简单的例子\",{\"1\":{\"1495\":1}}],[\"我们也可以转化为set\",{\"1\":{\"1486\":1}}],[\"我们也可以看到\",{\"1\":{\"1470\":1}}],[\"我们也可以手动调用analyze\",{\"1\":{\"696\":1}}],[\"我们也需要计算使用idx\",{\"1\":{\"686\":1}}],[\"我们最常见的就是btree\",{\"1\":{\"690\":1}}],[\"我们通过一个具体的例子来说明\",{\"1\":{\"1497\":1}}],[\"我们通过使用collection的stream方法创建了一个widget对象的流\",{\"1\":{\"1496\":1}}],[\"我们通过这种方式就实现了上述sql的需求\",{\"1\":{\"1490\":1}}],[\"我们通过mysql看到使用idx\",{\"1\":{\"688\":1}}],[\"我们通过慢查询日志\",{\"1\":{\"557\":1}}],[\"我们假设区间最左记录在页b中\",{\"1\":{\"686\":1}}],[\"我们假设当前k索引树的状态\",{\"1\":{\"482\":1}}],[\"我们前面说过在b+树中定位到一条记录的过程是很快的\",{\"1\":{\"686\":1}}],[\"我们把这个死循环称为事件循环\",{\"1\":{\"740\":1}}],[\"我们把这条记录称之为区间最右记录\",{\"1\":{\"686\":1}}],[\"我们把这条记录称之为区间最左记录\",{\"1\":{\"686\":1}}],[\"我们把数据结构分为逻辑结构和物理结构\",{\"1\":{\"328\":1}}],[\"我们仍然使用如下查询语句来分析\",{\"1\":{\"684\":1}}],[\"我们必须首先了解一下\",{\"1\":{\"678\":1}}],[\"我们并不推荐它\",{\"1\":{\"666\":1}}],[\"我们再回到一开始的例子当中\",{\"1\":{\"1498\":1}}],[\"我们再回到遍历list集合的例子中\",{\"1\":{\"1472\":1}}],[\"我们再定义一个类\",{\"1\":{\"1484\":1}}],[\"我们再举一个例子\",{\"1\":{\"1482\":1,\"1490\":1}}],[\"我们再对比优化前后sql的执行计划\",{\"1\":{\"659\":1}}],[\"我们再来看一下comparator的类定义情况\",{\"1\":{\"1480\":1}}],[\"我们再来看看如果要在这张表中插入一个新记录\",{\"1\":{\"480\":1}}],[\"我们再来看执行器和innodb引擎在执行这个update语句时的内部流程\",{\"1\":{\"463\":1}}],[\"我们观察如下事务序列\",{\"1\":{\"634\":1}}],[\"我们对mysql相关的误删数据\",{\"1\":{\"620\":1}}],[\"我们感知到的连接过程慢\",{\"1\":{\"619\":1}}],[\"我们创建一个bean加入容器\",{\"1\":{\"720\":1}}],[\"我们创建一个表t\",{\"1\":{\"626\":1}}],[\"我们创建表t\",{\"1\":{\"613\":1}}],[\"我们创建两个表t1和t2\",{\"1\":{\"537\":1}}],[\"我们执行完事务后\",{\"1\":{\"611\":1}}],[\"我们执行如下语句\",{\"1\":{\"551\":1}}],[\"我们很好理解\",{\"1\":{\"1846\":1}}],[\"我们很清楚在主备切换过程中\",{\"1\":{\"604\":1}}],[\"我们很有可能碰到前缀的区分度不够好的情况\",{\"1\":{\"489\":1}}],[\"我们判断一个事务t和worker是否冲突\",{\"1\":{\"599\":1}}],[\"我们分别从delete\",{\"1\":{\"591\":1}}],[\"我们认为fsync才占磁盘的iops\",{\"1\":{\"587\":1}}],[\"我们直到\",{\"1\":{\"584\":1}}],[\"我们直接在被驱动表上建立索引\",{\"1\":{\"544\":1}}],[\"我们初始化如下数据\",{\"1\":{\"583\":1}}],[\"我们初始化表t的时候\",{\"1\":{\"561\":1}}],[\"我们以order\",{\"1\":{\"695\":1}}],[\"我们以下面的操作序列为例\",{\"1\":{\"580\":1}}],[\"我们以一个算count\",{\"1\":{\"533\":1}}],[\"我们先来学习项目管理利器maven和git\",{\"1\":{\"1857\":1}}],[\"我们先来读一下方法说明\",{\"1\":{\"1495\":1}}],[\"我们先创建一个学生类\",{\"1\":{\"1490\":1}}],[\"我们先创建表t\",{\"1\":{\"561\":1}}],[\"我们先分析idx\",{\"1\":{\"686\":1}}],[\"我们先把问题简化以下\",{\"1\":{\"559\":1}}],[\"我们得清楚\",{\"1\":{\"554\":1}}],[\"我们得从文章开头的那个问题说起\",{\"1\":{\"464\":1}}],[\"我们使用了临时表\",{\"1\":{\"546\":1}}],[\"我们使用p\",{\"1\":{\"428\":1}}],[\"我们的方法就是在这里被调用了\",{\"1\":{\"1494\":1}}],[\"我们的代码就变成了\",{\"1\":{\"1468\":1}}],[\"我们的程序肯定无法满足性能需求\",{\"1\":{\"1450\":1}}],[\"我们的表t初始以后\",{\"1\":{\"585\":1}}],[\"我们的思路都是让join语句能够用上被驱动表上的索引\",{\"1\":{\"544\":1}}],[\"我们的查询\",{\"1\":{\"475\":1}}],[\"我们回到本小节一开始的两个问题\",{\"1\":{\"540\":1}}],[\"我们将会看到jdk在底层到底是如何巧妙的实现函数式编程\",{\"1\":{\"1495\":1}}],[\"我们将会讨论自己计数的方法\",{\"1\":{\"533\":1}}],[\"我们将系统而全面的分析jdk是如何实现函数式编程\",{\"1\":{\"1490\":1}}],[\"我们将备库b接收完这个binlog的时刻记为t2\",{\"1\":{\"594\":1}}],[\"我们将这个时刻记为t3\",{\"1\":{\"594\":1}}],[\"我们将这个时刻记为t1\",{\"1\":{\"594\":1}}],[\"我们将这个算法暂时称作随机算法2\",{\"1\":{\"559\":1}}],[\"我们将这个算法暂时称作随机算法1\",{\"1\":{\"559\":1}}],[\"我们将tmp\",{\"1\":{\"558\":1}}],[\"我们将sql语句修改如下\",{\"1\":{\"539\":1}}],[\"我们将二叉树的左子树深度减去右子树深度的值称为平衡因子\",{\"1\":{\"341\":1}}],[\"我们删除索引后\",{\"1\":{\"527\":1}}],[\"我们无法把响应时间细分到上面这些部分\",{\"1\":{\"525\":1}}],[\"我们往交易日志表tradelog和交易详情表trade\",{\"1\":{\"505\":1}}],[\"我们现在知道范围之后的索引会失效\",{\"1\":{\"498\":1}}],[\"我们试试把sql修改为select\",{\"1\":{\"498\":1}}],[\"我们发现当前临时实例需要的binlog是从master\",{\"1\":{\"622\":1}}],[\"我们发现以上两条sql的执行结果都是一样的\",{\"1\":{\"508\":1}}],[\"我们发现\",{\"1\":{\"498\":1}}],[\"我们经常会碰到要存储字符串的场景\",{\"1\":{\"486\":1}}],[\"我们看一下修改之后的效果\",{\"1\":{\"485\":1}}],[\"我们看到的只是输入一条语句\",{\"1\":{\"454\":1}}],[\"我们应该如何处理呢\",{\"1\":{\"485\":1}}],[\"我们在扩充hashmap的时候\",{\"1\":{\"1427\":1}}],[\"我们在使用的时候建议手动传一个队列的大小\",{\"1\":{\"1380\":1}}],[\"我们在使用事务的时候\",{\"1\":{\"580\":1}}],[\"我们在很多场景下都可以利用线程安全的队列来优雅地解决我们业务自身的线程安全问题\",{\"1\":{\"1378\":1}}],[\"我们在讲解配置文件的时候\",{\"1\":{\"746\":1}}],[\"我们在学习springboot自动配置的原理时\",{\"1\":{\"720\":1}}],[\"我们在给所有行加锁的时候\",{\"1\":{\"584\":1}}],[\"我们在执行语句之前\",{\"1\":{\"543\":1}}],[\"我们在示例数据库sakila中的一个查询案例\",{\"1\":{\"527\":1}}],[\"我们在这个市民表上创建一个city和name的联合索引\",{\"1\":{\"493\":1}}],[\"我们在没有使用force\",{\"1\":{\"483\":1}}],[\"我们在字段\",{\"1\":{\"483\":1}}],[\"我们在应用中应该尽量使用主键查询\",{\"1\":{\"472\":1}}],[\"我们就能愉快地上\",{\"1\":{\"1859\":1}}],[\"我们就不得不先要理清楚一些及其重要的概念和几个核心类的作用\",{\"1\":{\"1490\":1}}],[\"我们就不得不定义一个新的函数\",{\"1\":{\"1475\":1}}],[\"我们就不应该使用二叉树\",{\"1\":{\"471\":1}}],[\"我们就更能直观的体会到\",{\"1\":{\"1472\":1}}],[\"我们就会围绕这两个问题展开\",{\"1\":{\"1484\":1}}],[\"我们就会遇到编译器无法自动推断\",{\"1\":{\"1470\":1}}],[\"我们就会使用消息中间件mq处理\",{\"1\":{\"738\":1}}],[\"我们就必须要编写很多个具体的方法\",{\"1\":{\"1476\":1}}],[\"我们就必须选择类似于priorityblockingqueue之类的有序排序能力的阻塞队列\",{\"1\":{\"1386\":1}}],[\"我们就必须先切换到备库b\",{\"1\":{\"596\":1}}],[\"我们就需要分析系统中为什么会有如此多的等待\",{\"1\":{\"675\":1}}],[\"我们就需要去binlog备份系统中找到这两个文件\",{\"1\":{\"622\":1}}],[\"我们就可能会设置auto\",{\"1\":{\"628\":1}}],[\"我们就可以独立完成一个小项目\",{\"1\":{\"1870\":1}}],[\"我们就可以重用\",{\"1\":{\"1492\":1}}],[\"我们就可以\",{\"1\":{\"1486\":1}}],[\"我们就可以定义一个通用的函数\",{\"1\":{\"1476\":1}}],[\"我们就可以把123这个作为$master\",{\"1\":{\"604\":1}}],[\"我们就可以按照随机算法2的思路\",{\"1\":{\"559\":1}}],[\"我们就可以通过分表规则\",{\"1\":{\"548\":1}}],[\"我们就算慢sql\",{\"1\":{\"565\":1}}],[\"我们就分别创建普通表t\",{\"1\":{\"561\":1}}],[\"我们就要把sql语句改成基于字段本身的范围查询\",{\"1\":{\"503\":1}}],[\"我们就从这两种索引对查询语句和更新语句的性能来进行分析\",{\"1\":{\"478\":1}}],[\"我们还要学习mq\",{\"1\":{\"1862\":1}}],[\"我们还可以这样创建stream\",{\"1\":{\"1484\":1}}],[\"我们还可以使用一种特殊的方式来创建supplier的实例\",{\"1\":{\"1477\":1}}],[\"我们还可以从存储空间的角度来看\",{\"1\":{\"472\":1}}],[\"我们还是应该在innodb表中主动创建自增主键\",{\"1\":{\"632\":1}}],[\"我们还是以市民表中的联合索引\",{\"1\":{\"477\":1}}],[\"我们还需要把这个参数设置为空\",{\"1\":{\"604\":1}}],[\"我们用limit\",{\"1\":{\"485\":1}}],[\"我们用\",{\"1\":{\"476\":1}}],[\"我们只给d=5这一行加了锁\",{\"1\":{\"584\":1}}],[\"我们只需要了解基本使用即可\",{\"1\":{\"1856\":1}}],[\"我们只需要\",{\"1\":{\"1486\":1}}],[\"我们只需要取r值最小的3个rowid\",{\"1\":{\"558\":1}}],[\"我们只需要输入待查找的值即key\",{\"1\":{\"469\":1}}],[\"我们只要在身份证号字段上建立索引就够了\",{\"1\":{\"475\":1}}],[\"我们知道一般情况下分割迭代器返回的是iteratorspliterator实现\",{\"1\":{\"1499\":1}}],[\"我们知道前面介绍的那几种阻塞队列\",{\"1\":{\"1386\":1}}],[\"我们知道\",{\"1\":{\"475\":1,\"1478\":1}}],[\"我们来阅读一下方法的说明\",{\"1\":{\"1497\":1}}],[\"我们来阅读一下reducing方法的说明\",{\"1\":{\"1495\":1}}],[\"我们来阅读一下collect方法的说明\",{\"1\":{\"1485\":1}}],[\"我们来举个例子\",{\"1\":{\"1487\":1}}],[\"我们来举一个具体的例子来说明\",{\"1\":{\"1485\":1}}],[\"我们来了解一些关于流的特性\",{\"1\":{\"1485\":1}}],[\"我们来新建一个测试类\",{\"1\":{\"1477\":1}}],[\"我们来具体看一个例子\",{\"1\":{\"1472\":1}}],[\"我们来看接收参数最多的这个\",{\"1\":{\"1485\":1}}],[\"我们来看具体例子\",{\"1\":{\"1476\":1}}],[\"我们来看一下iteratorspliterator中对于foreachremaining的实现\",{\"1\":{\"1499\":1}}],[\"我们来看一下这个方法的说明\",{\"1\":{\"1497\":1}}],[\"我们来看一下supplier函数式接口的文档\",{\"1\":{\"1477\":1}}],[\"我们来看一下执行效果\",{\"1\":{\"484\":1}}],[\"我们来看一个具体的例子\",{\"1\":{\"1475\":1}}],[\"我们来看下在不同的隔离级别下\",{\"1\":{\"570\":1}}],[\"我们来看看这个delete语句的binlog是怎么记录的\",{\"1\":{\"591\":1}}],[\"我们来看看这两种方式会有什么问题\",{\"1\":{\"464\":1}}],[\"我们来看看mysql是如何选择的\",{\"1\":{\"484\":1}}],[\"我们来讨论一个问题\",{\"1\":{\"475\":1}}],[\"我们称为通用分区策略\",{\"1\":{\"562\":1}}],[\"我们称为覆盖索引\",{\"1\":{\"475\":1}}],[\"我们称之为默认方法\",{\"1\":{\"1470\":1}}],[\"我们称之为\",{\"1\":{\"484\":1}}],[\"我们称它为伪异步io\",{\"1\":{\"1450\":1}}],[\"我们称它为3结点\",{\"1\":{\"347\":1}}],[\"我们称它为2结点\",{\"1\":{\"347\":1}}],[\"我们探讨一下索引的执行流程\",{\"1\":{\"473\":1}}],[\"我们从一个表的一条更新语句开始\",{\"1\":{\"460\":1}}],[\"我们会讨论到引擎的选择\",{\"1\":{\"454\":1}}],[\"我们需要先了解数据结构相关的内容\",{\"1\":{\"1848\":1}}],[\"我们需要搞清楚这里每一个泛型的含义\",{\"1\":{\"1495\":1}}],[\"我们需要提供分组的依据\",{\"1\":{\"1490\":1}}],[\"我们需要将某一个子类中的默认方法实现重写一遍\",{\"1\":{\"1484\":1}}],[\"我们需要根据任务数量来推算出合适的容量\",{\"1\":{\"1386\":1}}],[\"我们需要知道如何编写配置文件然后连接redis\",{\"1\":{\"720\":1}}],[\"我们需要尽量在被驱动表的连接列上建立索引\",{\"1\":{\"692\":1}}],[\"我们需要分别分析单独使用这些索引执行查询的成本\",{\"1\":{\"686\":1}}],[\"我们需要分析一下哪些场景应该使用自增主键\",{\"1\":{\"472\":1}}],[\"我们需要的两个统计项\",{\"1\":{\"685\":1}}],[\"我们需要把这条查询语句修改成更新语句\",{\"1\":{\"614\":1}}],[\"我们需要把这三个操作放在一个事务中\",{\"1\":{\"580\":1}}],[\"我们需要找一个访问innodb的场景\",{\"1\":{\"614\":1}}],[\"我们需要update两条记录\",{\"1\":{\"580\":1}}],[\"我们需要一个临时表\",{\"1\":{\"554\":1}}],[\"我们需要每个月运行一次下面的查询\",{\"1\":{\"530\":1}}],[\"我们需要在city字段加上索引\",{\"1\":{\"491\":1}}],[\"我们需要\",{\"1\":{\"367\":1}}],[\"反之写入的过程\",{\"1\":{\"1457\":1}}],[\"反射\",{\"1\":{\"1847\":1}}],[\"反射的作用\",{\"0\":{\"1436\":1}}],[\"反射的定义\",{\"0\":{\"1435\":1}}],[\"反射机制允许程序在执行时获取类自身的定义信息\",{\"1\":{\"1435\":1}}],[\"反射主要指程序可以访问\",{\"1\":{\"1435\":1}}],[\"反而没有那么重要了\",{\"1\":{\"1472\":1}}],[\"反而由于线程数量过多会导致性能下降\",{\"1\":{\"1387\":1}}],[\"反而会降低服务端的性能\",{\"1\":{\"619\":1}}],[\"反而忽视了备库的压力控制\",{\"1\":{\"594\":1}}],[\"反而增加了change\",{\"1\":{\"481\":1}}],[\"反过来加深我们使用的时候的理解\",{\"1\":{\"1490\":1}}],[\"反过来\",{\"1\":{\"481\":1}}],[\"反转字符串中k个字符\",{\"1\":{\"384\":1}}],[\"反转字符串ii\",{\"0\":{\"384\":1}}],[\"反转字符串\",{\"0\":{\"383\":1}}],[\"页缓存与内存映射\",{\"0\":{\"1723\":1}}],[\"页是磁盘和内存之间交互的基本单位\",{\"1\":{\"682\":1}}],[\"页面在写完以后马上被访问到的概率比较小\",{\"1\":{\"481\":1}}],[\"页分裂操作还影响数据页的利用率\",{\"1\":{\"472\":1}}],[\"唯一的区别在于\",{\"1\":{\"1521\":1}}],[\"唯一的区别就是省掉cpu参与环节的方式不同\",{\"1\":{\"1462\":1}}],[\"唯一键查询\",{\"0\":{\"1801\":1}}],[\"唯一键冲突\",{\"1\":{\"628\":1}}],[\"唯一键\",{\"1\":{\"599\":1}}],[\"唯一\",{\"1\":{\"495\":1}}],[\"唯一索引查询\",{\"1\":{\"527\":1}}],[\"唯一索引的更新就不能使用change\",{\"1\":{\"480\":1}}],[\"唯一索引和普通索引并没有性能上的差距\",{\"1\":{\"479\":1}}],[\"唯一性索引扫描\",{\"1\":{\"467\":1}}],[\"仍然可以学习这个项目\",{\"1\":{\"1865\":1}}],[\"仍然可能丢失更新\",{\"1\":{\"534\":1}}],[\"仍然会存在一个线程需要等待另外的线程完成后继续下一步操作\",{\"1\":{\"1407\":1}}],[\"仍然假设s1表是驱动表的话\",{\"1\":{\"691\":1}}],[\"仍然能够把数据恢复回来\",{\"1\":{\"464\":1}}],[\"仍可以认为这个操作成本对于现在的cpu来说可以忽略不计\",{\"1\":{\"479\":1}}],[\"又将这个部分结果传递给combiner\",{\"1\":{\"1492\":1}}],[\"又马上将其修改为a\",{\"1\":{\"1356\":1}}],[\"又会退化成链表结构\",{\"1\":{\"1352\":1}}],[\"又会连接上从机恢复原状\",{\"1\":{\"748\":1}}],[\"又不会用到collectorimpl\",{\"1\":{\"1493\":1}}],[\"又不会出现数据一致性问题\",{\"1\":{\"629\":1}}],[\"又不用额外增加太多的查询成本\",{\"1\":{\"487\":1}}],[\"又可以获取到主机的所有数据\",{\"1\":{\"748\":1}}],[\"又可以让备库执行得快些\",{\"1\":{\"602\":1}}],[\"又可以明确地直到每个语句是否处于事务中\",{\"1\":{\"572\":1}}],[\"又加入了\",{\"1\":{\"549\":1}}],[\"又调用idata这个存储过程\",{\"1\":{\"483\":1}}],[\"又有基于a\",{\"1\":{\"476\":1}}],[\"又称单词查找树或键树\",{\"1\":{\"301\":1}}],[\"张图\",{\"1\":{\"1843\":1}}],[\"张\",{\"1\":{\"476\":2,\"477\":3}}],[\"张三\",{\"1\":{\"476\":1,\"509\":1}}],[\"姓名\",{\"1\":{\"475\":1,\"647\":1,\"655\":1}}],[\"身份证号\",{\"1\":{\"475\":1}}],[\"身份证号是市民的唯一标识\",{\"1\":{\"475\":1}}],[\"`k1`\",{\"1\":{\"717\":1}}],[\"`georadius\",{\"1\":{\"713\":1}}],[\"`linsert\",{\"1\":{\"708\":1}}],[\"`s1`\",{\"1\":{\"692\":3}}],[\"`s2`\",{\"1\":{\"692\":3}}],[\"`staffs`\",{\"1\":{\"507\":6,\"508\":2,\"509\":2,\"510\":2,\"511\":2,\"512\":12,\"513\":3}}],[\"`step\",{\"1\":{\"505\":1}}],[\"`error`\",{\"1\":{\"717\":1}}],[\"`expire\",{\"1\":{\"690\":3,\"692\":4}}],[\"`employees`\",{\"1\":{\"647\":1,\"655\":1,\"656\":23,\"657\":2}}],[\"`emp`\",{\"1\":{\"568\":5}}],[\"`order\",{\"1\":{\"690\":10,\"692\":2}}],[\"`operator`\",{\"1\":{\"503\":1}}],[\"`optimizer\",{\"1\":{\"491\":1,\"558\":1}}],[\"`mysqladv`\",{\"1\":{\"690\":7,\"692\":6}}],[\"`mylock`\",{\"1\":{\"671\":5}}],[\"`hire\",{\"1\":{\"647\":1,\"655\":1,\"656\":2}}],[\"`health\",{\"1\":{\"615\":1}}],[\"`remark`\",{\"1\":{\"643\":1}}],[\"`film\",{\"1\":{\"643\":6}}],[\"`film`\",{\"1\":{\"643\":3}}],[\"`ftime`\",{\"1\":{\"561\":2}}],[\"`update\",{\"1\":{\"643\":2}}],[\"`d`\",{\"1\":{\"583\":1,\"626\":1,\"643\":1}}],[\"`word`\",{\"1\":{\"556\":1}}],[\"`words`\",{\"1\":{\"556\":1}}],[\"`\",{\"1\":{\"541\":1}}],[\"`position`\",{\"1\":{\"647\":2,\"655\":2,\"656\":6}}],[\"`pos`\",{\"1\":{\"507\":4,\"509\":2,\"510\":3,\"511\":1,\"512\":4}}],[\"`phone\",{\"1\":{\"500\":1}}],[\"`phone`\",{\"1\":{\"500\":2}}],[\"`balance`\",{\"1\":{\"672\":4}}],[\"`bookid`\",{\"1\":{\"499\":1}}],[\"`book`\",{\"1\":{\"499\":2}}],[\"`b`\",{\"1\":{\"483\":3,\"537\":1,\"599\":1,\"660\":1}}],[\"`views`\",{\"1\":{\"498\":6}}],[\"`c`\",{\"1\":{\"561\":1,\"583\":3,\"596\":1,\"605\":1,\"613\":1,\"626\":3}}],[\"`c5`\",{\"1\":{\"515\":10}}],[\"`c4`\",{\"1\":{\"515\":16}}],[\"`c3`\",{\"1\":{\"515\":18}}],[\"`c2`\",{\"1\":{\"515\":22}}],[\"`c1`\",{\"1\":{\"515\":22}}],[\"`card`\",{\"1\":{\"499\":2,\"500\":1}}],[\"`category\",{\"1\":{\"498\":6}}],[\"`class`\",{\"1\":{\"499\":2}}],[\"`content`\",{\"1\":{\"498\":6}}],[\"`comments`\",{\"1\":{\"498\":6}}],[\"`city`\",{\"1\":{\"490\":3}}],[\"`account`\",{\"1\":{\"672\":4}}],[\"`actor\",{\"1\":{\"643\":3}}],[\"`actor`\",{\"1\":{\"643\":3}}],[\"`add\",{\"1\":{\"512\":1}}],[\"`addr`\",{\"1\":{\"490\":1}}],[\"`author\",{\"1\":{\"498\":6}}],[\"`article`\",{\"1\":{\"498\":7}}],[\"`a`\",{\"1\":{\"483\":3,\"537\":3,\"591\":3,\"599\":3,\"660\":2}}],[\"`age`\",{\"1\":{\"475\":2,\"490\":1,\"507\":3,\"509\":2,\"510\":3,\"511\":1,\"512\":4,\"647\":2,\"655\":2,\"656\":2}}],[\"`test`\",{\"1\":{\"672\":3}}],[\"`test03`\",{\"1\":{\"515\":22}}],[\"`t1`\",{\"1\":{\"599\":1,\"660\":1}}],[\"`t2`\",{\"1\":{\"537\":1}}],[\"`t\",{\"1\":{\"503\":3,\"550\":2,\"591\":3,\"615\":1}}],[\"`trade\",{\"1\":{\"505\":2}}],[\"`tradeid`\",{\"1\":{\"503\":3,\"505\":3}}],[\"`tradelog`\",{\"1\":{\"503\":1}}],[\"`title`\",{\"1\":{\"498\":6}}],[\"`t`\",{\"1\":{\"483\":1,\"490\":1,\"561\":1,\"583\":1,\"591\":1,\"596\":1,\"605\":1,\"613\":1,\"626\":1,\"631\":1}}],[\"`tuser`\",{\"1\":{\"475\":1}}],[\"`name\",{\"1\":{\"475\":1}}],[\"`name`\",{\"1\":{\"475\":2,\"490\":1,\"507\":4,\"508\":2,\"509\":2,\"510\":3,\"511\":3,\"512\":16,\"513\":5,\"643\":5,\"647\":2,\"655\":2,\"656\":9,\"671\":5,\"672\":4}}],[\"`insert\",{\"1\":{\"690\":1}}],[\"`information\",{\"1\":{\"491\":1,\"558\":1}}],[\"`ismale`\",{\"1\":{\"475\":1}}],[\"`idx\",{\"1\":{\"643\":2,\"655\":1,\"660\":1}}],[\"`id\",{\"1\":{\"475\":3}}],[\"`id`\",{\"1\":{\"475\":2,\"483\":2,\"490\":2,\"498\":1,\"499\":1,\"503\":2,\"505\":2,\"512\":5,\"513\":2,\"515\":1,\"537\":2,\"556\":2,\"568\":5,\"583\":2,\"591\":2,\"596\":2,\"599\":2,\"605\":2,\"613\":2,\"615\":2,\"626\":2,\"631\":2,\"643\":8,\"647\":2,\"655\":2,\"656\":2,\"660\":2,\"671\":6,\"672\":2}}],[\"需同时满足下面的条件\",{\"1\":{\"1431\":1}}],[\"需求\",{\"1\":{\"475\":1}}],[\"需要自己写sql语句以及自己装配参数\",{\"1\":{\"1860\":1}}],[\"需要自己创建\",{\"1\":{\"565\":1}}],[\"需要配合具体的垃圾收集器一起使用\",{\"1\":{\"1546\":1}}],[\"需要添加\",{\"1\":{\"1507\":1}}],[\"需要添加的词\",{\"1\":{\"302\":1}}],[\"需要被关闭\",{\"1\":{\"1496\":1}}],[\"需要有一些预备的知识\",{\"1\":{\"1496\":1}}],[\"需要选择合适的方法\",{\"1\":{\"1489\":1}}],[\"需要两者配合使用\",{\"1\":{\"1486\":1}}],[\"需要主要的是\",{\"1\":{\"1462\":1}}],[\"需要dma控制器支持\",{\"1\":{\"1462\":1}}],[\"需要\",{\"1\":{\"1460\":1}}],[\"需要轮询pollfd来获取就绪的描述符\",{\"1\":{\"1447\":1}}],[\"需要避免内存泄漏和线程安全的问题\",{\"1\":{\"1405\":1}}],[\"需要注意以下两点\",{\"1\":{\"1403\":1}}],[\"需要注意两个关键点\",{\"1\":{\"1401\":1}}],[\"需要注意的是cmpxchg有个隐含操作数eax\",{\"1\":{\"1356\":1}}],[\"需要注意的是\",{\"1\":{\"419\":1,\"469\":1,\"475\":1,\"503\":1,\"530\":1,\"577\":1,\"581\":2,\"594\":1,\"597\":1,\"604\":1,\"621\":1,\"634\":1,\"659\":1,\"1427\":1,\"1471\":1,\"1486\":1,\"1493\":1,\"1523\":1}}],[\"需要谨慎评估这三个指标\",{\"1\":{\"1387\":1}}],[\"需要一个线程等待其它线程运行到某个点\",{\"1\":{\"1359\":1}}],[\"需要一定的时间间隔进行操作\",{\"1\":{\"727\":1}}],[\"需要拼接参数的\",{\"1\":{\"806\":1}}],[\"需要手动将一个从节点晋升为主节点\",{\"1\":{\"758\":1}}],[\"需要手动把一台从服务器切换为主服务器\",{\"1\":{\"756\":1}}],[\"需要进行配置才可以\",{\"1\":{\"729\":1}}],[\"需要fork子进程\",{\"1\":{\"726\":1}}],[\"需要对一些叶子节点页面进行采样\",{\"1\":{\"695\":1}}],[\"需要我们手动声明变量类型的情况\",{\"1\":{\"1470\":1}}],[\"需要我们手动来设置这个参数\",{\"1\":{\"565\":1}}],[\"需要我们去计算\",{\"1\":{\"690\":1}}],[\"需要回表的记录数\",{\"1\":{\"686\":2}}],[\"需要回表4次\",{\"1\":{\"477\":1}}],[\"需要先把数据或者索引加载到内存中然后再操作\",{\"1\":{\"682\":1}}],[\"需要先获取到意向排他锁\",{\"1\":{\"670\":1}}],[\"需要先获取到意向共享锁\",{\"1\":{\"670\":1}}],[\"需要先从磁盘读入内存\",{\"1\":{\"463\":1}}],[\"需要跳过12点误操作的那个语句的binlog\",{\"1\":{\"622\":1}}],[\"需要生成回滚日志\",{\"1\":{\"621\":1}}],[\"需要确保binlog\",{\"1\":{\"621\":1}}],[\"需要多做一些操作\",{\"1\":{\"619\":1}}],[\"需要做的事情就是tcp握手\",{\"1\":{\"619\":1}}],[\"需要删除中间过程的临时文件\",{\"1\":{\"618\":1}}],[\"需要删掉的node\",{\"1\":{\"302\":1}}],[\"需要发出信号的原因是\",{\"1\":{\"618\":1}}],[\"需要额外说明的是\",{\"1\":{\"613\":1}}],[\"需要执行一条change\",{\"1\":{\"604\":1}}],[\"需要执行几次树的搜索操作\",{\"1\":{\"473\":1}}],[\"需要消耗更多的计算资源\",{\"1\":{\"599\":1}}],[\"需要满足以下这两个基本要求\",{\"1\":{\"597\":1}}],[\"需要等到终止逻辑完成\",{\"1\":{\"618\":1}}],[\"需要等到主备延迟小于5秒的时候再启动切换\",{\"1\":{\"596\":1}}],[\"需要等到t6时刻session\",{\"1\":{\"584\":1}}],[\"需要等待两次刷盘\",{\"1\":{\"588\":1}}],[\"需要特殊处理\",{\"1\":{\"581\":1}}],[\"需要修改同一行数据\",{\"1\":{\"580\":1}}],[\"需要修改my\",{\"1\":{\"565\":1}}],[\"需要根据业务情况来定\",{\"1\":{\"570\":1}}],[\"需要根据身份证号查找对应的名字\",{\"1\":{\"469\":1}}],[\"需要访问所有的分区\",{\"1\":{\"562\":1}}],[\"需要在业务不是很繁忙的时候再运行\",{\"1\":{\"696\":1}}],[\"需要在my\",{\"1\":{\"565\":1}}],[\"需要在主库上再写一个drop\",{\"1\":{\"550\":1}}],[\"需要在执行sql语句之前\",{\"1\":{\"542\":1}}],[\"需要参与join的实际上只有2000行数据\",{\"1\":{\"544\":1}}],[\"需要通过理论分析和查看explain结果的方式\",{\"1\":{\"543\":1}}],[\"需要隔1秒后再次被访问到\",{\"1\":{\"543\":1}}],[\"需要设置`set\",{\"1\":{\"541\":1}}],[\"需要分k段才能完成算法流程\",{\"1\":{\"540\":1}}],[\"需要让小表做驱动表\",{\"1\":{\"538\":1}}],[\"需要把数据一行一行地从引擎里面读出来后\",{\"1\":{\"533\":1}}],[\"需要把page2从磁盘读入内存中\",{\"1\":{\"482\":1}}],[\"需要考虑一下从表中找到某一行数据的成本\",{\"1\":{\"527\":1}}],[\"需要优化sql\",{\"1\":{\"498\":1}}],[\"需要的资源很少\",{\"1\":{\"615\":1}}],[\"需要的开发工作量比较大\",{\"1\":{\"548\":1}}],[\"需要的时候从缓存中取出\",{\"1\":{\"523\":1}}],[\"需要的结果与原\",{\"1\":{\"659\":1}}],[\"需要的结果\",{\"1\":{\"503\":1}}],[\"需要的临时文件也相应地变少了\",{\"1\":{\"492\":1}}],[\"需要的分成的份数就越多\",{\"1\":{\"491\":1}}],[\"需要用到临时表\",{\"1\":{\"491\":1}}],[\"需要创建长度为12位以上的前缀索引\",{\"1\":{\"489\":1}}],[\"需要将事务的顺序调过来再执行\",{\"1\":{\"621\":1}}],[\"需要将mysql的参数设置为session\",{\"1\":{\"611\":1}}],[\"需要将隔离级别设置为\",{\"1\":{\"570\":1}}],[\"需要将数据页读入内存\",{\"1\":{\"480\":1}}],[\"需要将上一次的结果清理\",{\"1\":{\"415\":1}}],[\"需要说明的是\",{\"1\":{\"480\":1,\"492\":1,\"1495\":1}}],[\"需要首先了解change\",{\"1\":{\"480\":1}}],[\"需要查找下一个记录\",{\"1\":{\"479\":1}}],[\"需要查找的word\",{\"1\":{\"302\":1}}],[\"需要逻辑上挪动后面的数据\",{\"1\":{\"472\":1}}],[\"需要找回数据\",{\"1\":{\"464\":1}}],[\"需要走n\",{\"1\":{\"375\":1}}],[\"需要移除的word\",{\"1\":{\"302\":1}}],[\"覆盖\",{\"1\":{\"709\":3}}],[\"覆盖了\",{\"1\":{\"475\":1}}],[\"覆盖索引保两边\",{\"1\":{\"512\":1}}],[\"覆盖索引尽量用\",{\"0\":{\"510\":1}}],[\"覆盖索引\",{\"0\":{\"475\":1},\"1\":{\"467\":1}}],[\"步骤6\",{\"1\":{\"1426\":1}}],[\"步骤5\",{\"1\":{\"1426\":1}}],[\"步骤4\",{\"1\":{\"1426\":1}}],[\"步骤3\",{\"1\":{\"1426\":1}}],[\"步骤3直到不满足name=\",{\"1\":{\"657\":1}}],[\"步骤2\",{\"1\":{\"1426\":1}}],[\"步骤2和4\",{\"1\":{\"474\":1}}],[\"步骤1\",{\"1\":{\"474\":1,\"1426\":1}}],[\"上游的pipline\",{\"1\":{\"1498\":1}}],[\"上下文切换次数\",{\"1\":{\"1462\":1}}],[\"上下文切换相关开销\",{\"1\":{\"568\":1}}],[\"上锁\",{\"1\":{\"718\":1}}],[\"上边的查询语句可能用到的索引\",{\"1\":{\"684\":1}}],[\"上述代码每次调用buffer\",{\"1\":{\"1363\":1}}],[\"上述查询可能使用到idx\",{\"1\":{\"686\":1}}],[\"上述查询中涉及到几个搜索条件\",{\"1\":{\"684\":1}}],[\"上述sql的explain的结果如下\",{\"1\":{\"557\":1}}],[\"上述sql语句查询的执行流程\",{\"1\":{\"474\":1}}],[\"上一章节中\",{\"1\":{\"1486\":1}}],[\"上一条数据的历史版本指针\",{\"1\":{\"679\":1}}],[\"上一段我们说到满足最左前缀原则的时候\",{\"1\":{\"477\":1}}],[\"上限就是223\",{\"1\":{\"630\":1}}],[\"上次备份是当天0点\",{\"1\":{\"622\":1}}],[\"上\",{\"1\":{\"604\":1,\"715\":1,\"1378\":1}}],[\"上最新的file和position\",{\"1\":{\"604\":1}}],[\"上执行show\",{\"1\":{\"604\":1}}],[\"上图中每个黑色圆点就是一个node对象\",{\"1\":{\"1423\":1}}],[\"上图中备库b下的虚线框\",{\"1\":{\"609\":1}}],[\"上图中\",{\"1\":{\"597\":1}}],[\"上面那个查询在联合索引里匹配到名字是\",{\"1\":{\"655\":1}}],[\"上面session\",{\"1\":{\"583\":1}}],[\"上面这个group\",{\"1\":{\"554\":1}}],[\"上面查询中的tag已经被缓存了\",{\"1\":{\"531\":1}}],[\"上面的代码其实等价于\",{\"1\":{\"1494\":1}}],[\"上面的方法都是一次排序\",{\"1\":{\"1491\":1}}],[\"上面的方法也会导致两条sql的结果不一致\",{\"1\":{\"659\":1}}],[\"上面的例子当中\",{\"1\":{\"1500\":1}}],[\"上面的例子是一个串行的例子\",{\"1\":{\"1497\":1}}],[\"上面的例子创建stream的\",{\"1\":{\"1485\":1}}],[\"上面的例子看起来还是相对而言比较简陋的\",{\"1\":{\"1484\":1}}],[\"上面的例子中\",{\"1\":{\"674\":1}}],[\"上面的例子中where\",{\"1\":{\"562\":1}}],[\"上面的分析中\",{\"1\":{\"618\":1}}],[\"上面的图变成了这样\",{\"1\":{\"588\":1}}],[\"上面的group\",{\"1\":{\"554\":1}}],[\"上面的这个例子说明了好的索引多么重要\",{\"1\":{\"527\":1}}],[\"上面的sql等价于\",{\"1\":{\"505\":1}}],[\"上面的sql语句等价于\",{\"1\":{\"504\":1}}],[\"上面的排序算法\",{\"1\":{\"492\":1}}],[\"上建立了普通索引\",{\"1\":{\"483\":1}}],[\"上文中的例子\",{\"1\":{\"610\":1}}],[\"上文中提到的双m结构的主备切换流程图如下\",{\"1\":{\"593\":1}}],[\"上文中主备的结构实际上是m\",{\"1\":{\"592\":1}}],[\"上文我们提到\",{\"1\":{\"558\":1}}],[\"上文我们总结临时表的特性\",{\"1\":{\"549\":1}}],[\"上文我们说过\",{\"1\":{\"481\":1}}],[\"上文提到的一主多从的架构师客户端主动做负载均衡\",{\"1\":{\"606\":1}}],[\"上文提到的redo\",{\"1\":{\"462\":1}}],[\"上文提到过\",{\"1\":{\"464\":2}}],[\"该框架能够保证分布式环境中数据的一致性\",{\"1\":{\"1869\":1}}],[\"该类所依赖及引用的类也由这个classloader载入\",{\"1\":{\"1540\":1}}],[\"该类中的所有方法都是静态的\",{\"1\":{\"1437\":1}}],[\"该阶段会把一些静态方法\",{\"1\":{\"1540\":1}}],[\"该注解代理的功能就是向spring容器中添加了两个bean\",{\"1\":{\"1532\":1}}],[\"该简单的sql所要表达的意思是\",{\"1\":{\"1488\":1}}],[\"该判断表示已经有线程在进行扩容操作了\",{\"1\":{\"1431\":1}}],[\"该操作会更新size大小\",{\"1\":{\"1431\":1}}],[\"该操作也可以用于判断两个元素是否位于同一个集合\",{\"1\":{\"356\":1}}],[\"该节点是红黑树节点\",{\"1\":{\"1431\":1}}],[\"该链为链表\",{\"1\":{\"1426\":1}}],[\"该阻塞队列的大小为integer\",{\"1\":{\"1380\":1}}],[\"该计数器+1\",{\"1\":{\"1362\":1}}],[\"该缓存中的副本\",{\"1\":{\"1351\":1}}],[\"该变量记录着对该表进行增删改的记录条数\",{\"1\":{\"696\":1}}],[\"该成本已经超过当前最小的连接查询成本\",{\"1\":{\"693\":1}}],[\"该关键字对应的id号为1\",{\"1\":{\"690\":1,\"692\":1}}],[\"该索引列是否允许存储null值\",{\"1\":{\"690\":1}}],[\"该索引必须是唯一索引\",{\"1\":{\"472\":1}}],[\"该属性的值就是null\",{\"1\":{\"690\":1}}],[\"该表的聚簇索引的记录数为97\",{\"1\":{\"685\":1}}],[\"该表中的记录数\",{\"1\":{\"685\":1}}],[\"该值设置的越小\",{\"1\":{\"695\":1}}],[\"该值设置的越大\",{\"1\":{\"695\":1}}],[\"该值越大\",{\"1\":{\"693\":1}}],[\"该值就相当于聚簇索引占用的存储空间大小\",{\"1\":{\"685\":1}}],[\"该值就是数据文件的大小\",{\"1\":{\"685\":1}}],[\"该值是一个估计值\",{\"1\":{\"685\":1}}],[\"该值是准确的\",{\"1\":{\"685\":1}}],[\"该视图在事务结束之前都不会变化\",{\"1\":{\"679\":1}}],[\"该如何解决由这种热点行更新导致的性能的问题呢\",{\"1\":{\"581\":1}}],[\"该如何避免回表呢\",{\"1\":{\"474\":1}}],[\"显式启动事务语句\",{\"1\":{\"572\":1}}],[\"显著提升查询性能\",{\"1\":{\"475\":1}}],[\"显然只要将分组的key换成分数就可以了\",{\"1\":{\"1490\":1}}],[\"显然使用maxby\",{\"1\":{\"1478\":1}}],[\"显然它是做不到的\",{\"1\":{\"1475\":1}}],[\"显然bgsave命令是针对save阻塞问题做的优化\",{\"1\":{\"724\":1}}],[\"显然跟库里面表的个数无关\",{\"1\":{\"619\":1}}],[\"显然会出现主键冲突\",{\"1\":{\"605\":1}}],[\"显然是个体力活\",{\"1\":{\"566\":1}}],[\"显然是走了全表扫描\",{\"1\":{\"483\":1}}],[\"显然把\",{\"1\":{\"485\":1}}],[\"显然这样需要扫描1000行\",{\"1\":{\"484\":1}}],[\"显然\",{\"1\":{\"472\":1,\"480\":1,\"484\":2,\"533\":1,\"538\":1,\"540\":1,\"599\":1,\"629\":2,\"688\":1,\"690\":1,\"692\":1,\"1477\":1,\"1489\":1}}],[\"显示\",{\"1\":{\"711\":3}}],[\"显示线程id\",{\"1\":{\"634\":1}}],[\"显示的是redo\",{\"1\":{\"616\":1}}],[\"显示在页面上\",{\"1\":{\"608\":1}}],[\"显示交换次数相关开销的信息\",{\"1\":{\"568\":1}}],[\"显示和source\",{\"1\":{\"568\":1}}],[\"显示页面错误相关开销信息\",{\"1\":{\"568\":1}}],[\"显示内存相关开销信息\",{\"1\":{\"568\":1}}],[\"显示发送和接收相关开销信息\",{\"1\":{\"568\":1}}],[\"显示cpu相关开销信息\",{\"1\":{\"568\":1}}],[\"显示块io相关开销\",{\"1\":{\"568\":1}}],[\"显示所有的开销信息\",{\"1\":{\"568\":1}}],[\"显示索引的哪一列被使用了\",{\"1\":{\"467\":1}}],[\"显示可能应用在这张表中的索引\",{\"1\":{\"467\":1}}],[\"正式由于supplier这个函数式接口不接收参数\",{\"1\":{\"1477\":1}}],[\"正好是十个元素\",{\"1\":{\"1494\":1}}],[\"正好可以接收bifunction这个接口的返回的结果作为参数\",{\"1\":{\"1475\":1}}],[\"正好满足bifunction的定义\",{\"1\":{\"1475\":1}}],[\"正常执行\",{\"1\":{\"718\":1}}],[\"正常情况按照最左前缀原则\",{\"1\":{\"655\":1}}],[\"正常情况下就会区别于读事务的id\",{\"1\":{\"634\":1}}],[\"正常情况下\",{\"1\":{\"593\":1}}],[\"正如它的方法名称那样描述的\",{\"1\":{\"1490\":1}}],[\"正如图redis中list是可以进行双端操作的\",{\"1\":{\"708\":1}}],[\"正如我们预测的\",{\"1\":{\"527\":1}}],[\"正是因为将执行的结果传递给了方法参数的sink\",{\"1\":{\"1500\":1}}],[\"正是这两点\",{\"1\":{\"680\":1}}],[\"正是由于多了从库b\",{\"1\":{\"603\":1}}],[\"正无穷\",{\"1\":{\"673\":1}}],[\"正确的订阅关系\",{\"0\":{\"1743\":1}}],[\"正确的方式应该像下面这样只取需要的列\",{\"1\":{\"521\":1}}],[\"正确同步的多线程程序\",{\"1\":{\"1351\":1}}],[\"正确性\",{\"1\":{\"282\":1}}],[\"正文内容\",{\"1\":{\"498\":1}}],[\"正符合了我们前面提到的递增插入的场景\",{\"1\":{\"472\":1}}],[\"系统日志规范及最佳实践\",{\"1\":{\"1843\":1}}],[\"系统类加载器\",{\"1\":{\"1569\":1}}],[\"系统类初始化等等\",{\"1\":{\"1362\":1}}],[\"系统也存在一些相对稳定的部分\",{\"1\":{\"1565\":1}}],[\"系统就会给出警告\",{\"1\":{\"1497\":1}}],[\"系统调用\",{\"1\":{\"1462\":1}}],[\"系统调用方法\",{\"1\":{\"1461\":1}}],[\"系统方法做了优化升级\",{\"1\":{\"1460\":1}}],[\"系统\",{\"0\":{\"1461\":1},\"1\":{\"1459\":1,\"1460\":1,\"1461\":2}}],[\"系统将调用\",{\"1\":{\"1423\":1}}],[\"系统高峰期生产者速度太快\",{\"1\":{\"1413\":2}}],[\"系统崩坏概率大\",{\"1\":{\"745\":1}}],[\"系统变量innodb\",{\"1\":{\"696\":1}}],[\"系统变量\",{\"1\":{\"693\":1}}],[\"系统启动后到现在总共等待的次数\",{\"1\":{\"675\":1}}],[\"系统保存了一个全局变量thread\",{\"1\":{\"635\":1}}],[\"系统并发能力会大幅下降\",{\"1\":{\"628\":1}}],[\"系统管理员\",{\"1\":{\"625\":1}}],[\"系统正常\",{\"1\":{\"615\":1}}],[\"系统认为只要建立主备关系\",{\"1\":{\"605\":1}}],[\"系统的可用性更好\",{\"1\":{\"760\":1}}],[\"系统的状态是这样的\",{\"1\":{\"604\":1}}],[\"系统的不可用时间就会长达30分钟\",{\"1\":{\"595\":1}}],[\"系统已经处于完全不可用的状态\",{\"1\":{\"596\":1}}],[\"系统给binlog\",{\"1\":{\"587\":1}}],[\"系统重启的时候就会被清空\",{\"1\":{\"546\":1}}],[\"系统表空间\",{\"1\":{\"482\":1}}],[\"系统有后台线程也会定期merge\",{\"1\":{\"480\":1}}],[\"系统会获取当前id最大值作为下一条记录的id值\",{\"1\":{\"472\":1}}],[\"系统即使崩溃\",{\"1\":{\"464\":1}}],[\"自己写的java\",{\"1\":{\"1540\":1}}],[\"自然的\",{\"1\":{\"1486\":1}}],[\"自适应自旋\",{\"1\":{\"1366\":1}}],[\"自适应自旋等技术来减少锁操作的开销\",{\"1\":{\"1360\":1}}],[\"自适应缓冲区\",{\"0\":{\"868\":1}}],[\"自减\",{\"1\":{\"1359\":1}}],[\"自减并不是原子操作\",{\"1\":{\"1359\":1}}],[\"自旋锁与自适应自旋\",{\"0\":{\"1698\":1}}],[\"自旋等待\",{\"1\":{\"1431\":1}}],[\"自旋的目的是为了减少线程挂起的次数\",{\"1\":{\"1362\":1}}],[\"自旋会占用cpu时间\",{\"1\":{\"1362\":1}}],[\"自旋\",{\"1\":{\"1356\":1}}],[\"自定义匹配\",{\"0\":{\"1790\":1}}],[\"自定义类加载器\",{\"1\":{\"1540\":1,\"1569\":1}}],[\"自定义collector的过程帮助我们很好的理解了关于collector的基本概念\",{\"1\":{\"1495\":1}}],[\"自定义collector\",{\"0\":{\"1494\":1}}],[\"自定义spring事件\",{\"0\":{\"1280\":1}}],[\"自定义propertyeditor扩展\",{\"0\":{\"1245\":1}}],[\"自定义validator\",{\"0\":{\"1225\":1}}],[\"自定义bean作用域\",{\"0\":{\"1150\":1}}],[\"自定义依赖注入注解\",{\"0\":{\"1128\":1}}],[\"自定义编解码器\",{\"0\":{\"887\":1}}],[\"自定义redis工具类\",{\"0\":{\"721\":1}}],[\"自增\",{\"1\":{\"1359\":1}}],[\"自增锁直到语句执行结束才释放\",{\"1\":{\"629\":1}}],[\"自增锁还是要等语句结束后才被释放\",{\"1\":{\"629\":1}}],[\"自增锁在申请之后就马上释放\",{\"1\":{\"629\":1}}],[\"自增锁的范围是语句级别\",{\"1\":{\"629\":1}}],[\"自增锁的优化\",{\"0\":{\"629\":1},\"1\":{\"628\":1}}],[\"自增id锁并不是一个事务锁\",{\"1\":{\"629\":1}}],[\"自增值的变更结果也会有所不同\",{\"1\":{\"628\":1}}],[\"自增值的行为如下\",{\"1\":{\"628\":1}}],[\"自增值的修改\",{\"0\":{\"628\":1}}],[\"自增值保存在内存里\",{\"1\":{\"627\":1}}],[\"自增值持久化\",{\"1\":{\"627\":1}}],[\"自增值并不是保存在表结构定义里的\",{\"1\":{\"627\":1}}],[\"自增主键总结\",{\"0\":{\"636\":1}}],[\"自增主键为什么还是不能保证连续呢\",{\"1\":{\"628\":1}}],[\"自增主键的上限\",{\"0\":{\"630\":1}}],[\"自增主键的存储\",{\"0\":{\"627\":1}}],[\"自增主键的插入数据的模式\",{\"1\":{\"472\":1}}],[\"自增主键可以让主键索引尽量地保持递增顺序插入\",{\"1\":{\"626\":1}}],[\"自增主键\",{\"0\":{\"626\":1}}],[\"自增主键往往是更合理的选择\",{\"1\":{\"472\":1}}],[\"自增主键是指自增列上定义的主键\",{\"1\":{\"472\":1}}],[\"自动事务的大致实现过程\",{\"1\":{\"1507\":1}}],[\"自动销毁\",{\"1\":{\"1410\":1}}],[\"自动存盘操作\",{\"1\":{\"1408\":1}}],[\"自动绑定\",{\"0\":{\"1113\":1}}],[\"自动装配\",{\"0\":{\"1038\":1}}],[\"自动动态代理\",{\"0\":{\"937\":1}}],[\"自动选举\",{\"1\":{\"748\":1}}],[\"自动重新计算统计数据也不会立即发生\",{\"1\":{\"696\":1}}],[\"自动补全功能用得不多\",{\"1\":{\"619\":1}}],[\"自动or手动\",{\"1\":{\"506\":1}}],[\"自相似性\",{\"1\":{\"337\":1}}],[\"会有更好的连贯性\",{\"1\":{\"1860\":1}}],[\"会有一个容器将所有的操作保存下来\",{\"1\":{\"1488\":1}}],[\"会首先创建线程\",{\"1\":{\"1567\":1}}],[\"会发现连接器需要完成3个高内聚的功能\",{\"1\":{\"1565\":1}}],[\"会发现事务t跟worker\",{\"1\":{\"598\":1}}],[\"会创建一个对应的class类型的对象实例放到堆中\",{\"1\":{\"1540\":1}}],[\"会找不到对应的controller\",{\"1\":{\"1537\":1}}],[\"会按照自然排序进行执行\",{\"1\":{\"1531\":1}}],[\"会按照索引列的顺序来维护b+树\",{\"1\":{\"642\":1}}],[\"会再检查methodmatcher里带参数matches的方法是否返回true\",{\"1\":{\"1531\":1}}],[\"会再计算一次使用索引的成本\",{\"1\":{\"688\":1}}],[\"会通过annotationawareaspectjautoproxycreator将\",{\"1\":{\"1531\":1}}],[\"会通过执行select\",{\"1\":{\"594\":1}}],[\"会查找advisor类型的bean\",{\"1\":{\"1531\":1}}],[\"会生成代理类\",{\"1\":{\"1529\":1}}],[\"会生成cglib的代理对象\",{\"1\":{\"1527\":1}}],[\"会生成id=2\",{\"1\":{\"627\":1}}],[\"会根据earlyproxyreferences这个map来判断是否需要aop操作\",{\"1\":{\"1526\":1}}],[\"会根据分区表规则\",{\"1\":{\"562\":1}}],[\"会检查beandefinition的属性是否已经被赋值过了\",{\"1\":{\"1524\":1}}],[\"会调用销毁方法\",{\"1\":{\"1524\":1}}],[\"会调用每个单例bean的aftersingletonsinstantiated方法\",{\"1\":{\"1524\":1}}],[\"会调用父类的longaccumelate去初始化cell\",{\"1\":{\"1357\":1}}],[\"会保证处理一个元素一定是happens\",{\"1\":{\"1500\":1}}],[\"会保存下游的对象\",{\"1\":{\"1500\":1}}],[\"会接收这个操作的所对应的输入元素的类型并且执行这个操作\",{\"1\":{\"1500\":1}}],[\"会重新设置sink的状态并且刷新数据集\",{\"1\":{\"1500\":1}}],[\"会输出字符串的子集\",{\"1\":{\"1500\":1}}],[\"会直接转换类型\",{\"1\":{\"1494\":1}}],[\"会从流中的第一个元素开始应用所有对于流元素的操作\",{\"1\":{\"1489\":1}}],[\"会优化遍历并检测结构上的修改\",{\"1\":{\"1497\":1}}],[\"会优化调用顺序\",{\"1\":{\"1488\":1}}],[\"会优先选择全字段排序\",{\"1\":{\"493\":1}}],[\"会得到如下的输出\",{\"1\":{\"1487\":1}}],[\"会出现死循环\",{\"1\":{\"1428\":1}}],[\"会出现死锁\",{\"1\":{\"672\":1}}],[\"会在父容器查找bean\",{\"1\":{\"1538\":1}}],[\"会在初始化后步骤中去寻找advisor类型的bean\",{\"1\":{\"1532\":1}}],[\"会在每一批的最后执行selectimports方法\",{\"1\":{\"1529\":1}}],[\"会在循环中不断等待数据\",{\"1\":{\"1397\":1}}],[\"会在表上加mdl读锁\",{\"1\":{\"618\":1}}],[\"会执行一个策略\",{\"1\":{\"1397\":1}}],[\"会一直尝试唤醒后续节点\",{\"1\":{\"1373\":1}}],[\"会把接口扫描出来并且得到对应的beandefinition\",{\"1\":{\"1530\":1}}],[\"会把首节点唤醒\",{\"1\":{\"1368\":1}}],[\"会把主库执行的这个语句的线程id写到binlog中\",{\"1\":{\"550\":1}}],[\"会标记该class为不可偏向\",{\"1\":{\"1362\":1}}],[\"会释放对象锁\",{\"1\":{\"1354\":1}}],[\"会添加一个内存屏障\",{\"1\":{\"1350\":1}}],[\"会对节点但做下线标识\",{\"1\":{\"758\":1}}],[\"会对读取的记录进行枷锁\",{\"1\":{\"678\":1}}],[\"会占用大量的cpu资源\",{\"1\":{\"1387\":1}}],[\"会占用大量的系统资源\",{\"1\":{\"540\":1}}],[\"会占用一定的内存空间\",{\"1\":{\"727\":1}}],[\"会报错但是不影响后续命令入队\",{\"1\":{\"717\":1}}],[\"会维护一个全局变量\",{\"1\":{\"693\":1}}],[\"会为每个表维护一份统计数据\",{\"1\":{\"690\":1}}],[\"会分段放\",{\"1\":{\"662\":1}}],[\"会分配4个\",{\"1\":{\"629\":1}}],[\"会分配2个\",{\"1\":{\"629\":1}}],[\"会分配1个\",{\"1\":{\"629\":1}}],[\"会显示查询将访问的分区\",{\"1\":{\"643\":1}}],[\"会让整个mysql集群的所有节点都全军覆没\",{\"1\":{\"625\":1}}],[\"会让优化器无法完成索引覆盖扫描这类优化\",{\"1\":{\"522\":1}}],[\"会耗费较多的本地内存\",{\"1\":{\"619\":1}}],[\"会包含很多表\",{\"1\":{\"619\":1}}],[\"会看到command列显示为killed呢\",{\"1\":{\"618\":1}}],[\"会认为系统还是正常的\",{\"1\":{\"613\":1}}],[\"会认为有\",{\"1\":{\"596\":1}}],[\"会阻止其他语句进入引擎执行\",{\"1\":{\"613\":1}}],[\"会不断应用n\",{\"1\":{\"1486\":1}}],[\"会不断地循环执行这条更新语句\",{\"1\":{\"592\":1}}],[\"会不会很快就把128消耗完呢\",{\"1\":{\"613\":1}}],[\"会称为新的主库\",{\"1\":{\"603\":1}}],[\"会导致客户端连接超时\",{\"1\":{\"1450\":1}}],[\"会导致hashmap中的链表中出现循环节点\",{\"1\":{\"1428\":1}}],[\"会导致\",{\"1\":{\"1360\":1}}],[\"会导致结果不一致\",{\"1\":{\"659\":1}}],[\"会导致上下文切换的成本会过高\",{\"1\":{\"613\":1}}],[\"会导致主备不一致的问题\",{\"1\":{\"597\":1}}],[\"会导致索引失效而转向全表扫描\",{\"1\":{\"506\":1}}],[\"会导致索引数量激增\",{\"1\":{\"476\":1}}],[\"会记录插入的行的所有字段的值\",{\"1\":{\"596\":1}}],[\"会多记录set\",{\"1\":{\"591\":1}}],[\"会被封装成methodinterceptor\",{\"1\":{\"1531\":1}}],[\"会被自动delete\",{\"1\":{\"706\":1}}],[\"会被选为这组的leader\",{\"1\":{\"588\":1}}],[\"会被锁住\",{\"1\":{\"570\":1}}],[\"会丢失最近n的事务的binlog日志\",{\"1\":{\"587\":1}}],[\"会\",{\"1\":{\"570\":1}}],[\"会加锁\",{\"1\":{\"570\":1}}],[\"会自动跳转到student的无参构造的地方\",{\"1\":{\"1477\":1}}],[\"会自动注册一个workqueue到pool\",{\"1\":{\"1390\":1}}],[\"会自动将slave切换成master\",{\"1\":{\"757\":1}}],[\"会自动删除临时表\",{\"1\":{\"547\":1,\"550\":1}}],[\"会自动触发重新做一次索引统计\",{\"1\":{\"484\":1}}],[\"会扫描表t2的每一行\",{\"1\":{\"544\":1}}],[\"会扫描多少行\",{\"1\":{\"473\":1}}],[\"会先申请可以操作的元素在数组中的问题\",{\"1\":{\"1396\":1}}],[\"会先在缓存\",{\"1\":{\"763\":1}}],[\"会先放在old区域\",{\"1\":{\"543\":1}}],[\"会先到查询缓存看看\",{\"1\":{\"456\":1}}],[\"会话c先启动一个单独的语句\",{\"1\":{\"533\":1}}],[\"会话b启动事务\",{\"1\":{\"533\":1}}],[\"会话a先启动事务并查询一次表的总行数\",{\"1\":{\"533\":1}}],[\"会使用synchronized锁把头结点锁住\",{\"1\":{\"1431\":1}}],[\"会使用到覆盖索引\",{\"1\":{\"511\":1}}],[\"会使索引失效\",{\"1\":{\"508\":1}}],[\"会将执行的方法名称设置为事务的名称\",{\"1\":{\"1532\":1}}],[\"会将返回的对象放置到earlysingletonobjects中\",{\"1\":{\"1526\":1}}],[\"会将aop需要执行的方法缓存\",{\"1\":{\"1507\":1}}],[\"会将一个stream转换为另一个stream\",{\"1\":{\"1496\":1}}],[\"会将一个任务分解为多个子任务交给多分线程并行执行\",{\"1\":{\"1407\":1}}],[\"会将中间结果容器强制转换为最终的结果类型\",{\"1\":{\"1494\":1}}],[\"会将版本链上最新的数据复制一份\",{\"1\":{\"679\":1}}],[\"会将字符串转换成数字\",{\"1\":{\"504\":1}}],[\"会将数据页做合并\",{\"1\":{\"472\":1}}],[\"会影响排序效率\",{\"1\":{\"493\":1}}],[\"会立即触发merge过程\",{\"1\":{\"481\":1}}],[\"会怎么样呢\",{\"1\":{\"477\":1}}],[\"性能监控\",{\"0\":{\"1648\":1}}],[\"性能较低\",{\"1\":{\"1360\":1}}],[\"性能提升明显\",{\"1\":{\"1357\":1}}],[\"性能场景\",{\"0\":{\"908\":1}}],[\"性能\",{\"0\":{\"813\":1},\"1\":{\"1386\":1}}],[\"性能很高\",{\"1\":{\"663\":1}}],[\"性能会下降10\",{\"1\":{\"616\":1}}],[\"性能相对较差\",{\"1\":{\"541\":1}}],[\"性能也更好\",{\"1\":{\"540\":1}}],[\"性能比强行拆成多个单表执行sql语句的性能要好\",{\"1\":{\"538\":1}}],[\"性能上会快很多\",{\"1\":{\"493\":1}}],[\"性能自然也受收到影响\",{\"1\":{\"472\":1}}],[\"性质5\",{\"1\":{\"343\":3}}],[\"性质4\",{\"1\":{\"343\":1}}],[\"性质3\",{\"1\":{\"343\":1}}],[\"性质2\",{\"1\":{\"343\":1}}],[\"性质1\",{\"1\":{\"343\":1}}],[\"性质\",{\"0\":{\"314\":1}}],[\"基础之后\",{\"1\":{\"1848\":1}}],[\"基础教程\",{\"1\":{\"1847\":1}}],[\"基础\",{\"0\":{\"1847\":1},\"1\":{\"1847\":2}}],[\"基础故障处理工具\",{\"0\":{\"1649\":1}}],[\"基础类型注入\",{\"0\":{\"1120\":1}}],[\"基础部分\",{\"0\":{\"899\":1}}],[\"基础支撑层\",{\"1\":{\"806\":1}}],[\"基础知识\",{\"0\":{\"704\":1}}],[\"基数统计\",{\"0\":{\"714\":1}}],[\"基数\",{\"1\":{\"484\":1,\"1357\":1}}],[\"基于zab算法\",{\"1\":{\"1869\":1}}],[\"基于\",{\"1\":{\"1867\":1}}],[\"基于collector实现汇聚操作的库\",{\"1\":{\"1492\":1}}],[\"基于这种情况\",{\"1\":{\"1541\":1}}],[\"基于这两个阶段\",{\"1\":{\"1438\":1}}],[\"基于这个协议\",{\"1\":{\"580\":1}}],[\"基于这个查询\",{\"1\":{\"533\":1}}],[\"基于轻量级线程实现thread\",{\"1\":{\"1410\":1}}],[\"基于disruptor开发的系统但线程能支撑每秒600万订单\",{\"1\":{\"1396\":1}}],[\"基于链表结构实现的一个双端阻塞队列\",{\"1\":{\"1378\":1}}],[\"基于链表结构实现的一个无界阻塞队列\",{\"1\":{\"1378\":1}}],[\"基于链表结构实现的一个有界阻塞队列\",{\"1\":{\"1378\":1}}],[\"基于优先级队列\",{\"1\":{\"1378\":1}}],[\"基于数组结构实现的一个有界阻塞队列\",{\"1\":{\"1378\":1}}],[\"基于monitor机制实现\",{\"1\":{\"1360\":1}}],[\"基于等待唤醒机制\",{\"1\":{\"1354\":1}}],[\"基于协议的窥探往往会更快\",{\"1\":{\"1351\":1}}],[\"基于api扩展spring配置属性源\",{\"0\":{\"1317\":1}}],[\"基于注解扩展spring配置属性源\",{\"0\":{\"1316\":1}}],[\"基于注解的spring事件监听器\",{\"0\":{\"1274\":1}}],[\"基于接口的spring事件监听器\",{\"0\":{\"1273\":1}}],[\"基于java的所有socket通信都使用了同步阻塞模式\",{\"1\":{\"1449\":1}}],[\"基于javabeans接口的类型转换\",{\"0\":{\"1243\":1}}],[\"基于java注解配置spring\",{\"0\":{\"1190\":1}}],[\"基于java注解的spring\",{\"0\":{\"1184\":1}}],[\"基于yml资源装载外部化配置\",{\"0\":{\"1193\":1}}],[\"基于properties资源装载外部化配置\",{\"0\":{\"1192\":1}}],[\"基于properties资源装载spring\",{\"0\":{\"1183\":1}}],[\"基于extensible\",{\"0\":{\"1191\":1}}],[\"基于xml资源装载spring\",{\"0\":{\"1182\":1,\"1189\":1}}],[\"基于索引统计数据的成本\",{\"0\":{\"689\":1}}],[\"基于块的嵌套循环查询\",{\"0\":{\"662\":1}}],[\"基于块的嵌套循环连接\",{\"1\":{\"660\":1}}],[\"基于慢sql查询做优化\",{\"1\":{\"658\":1}}],[\"基于位点的协议\",{\"1\":{\"605\":1}}],[\"基于位点的主备切换\",{\"0\":{\"604\":1}}],[\"基于主从复制模式\",{\"1\":{\"760\":1}}],[\"基于主备协议建立连接\",{\"1\":{\"605\":1}}],[\"基于主键索引和普通索引的查询略有差别\",{\"1\":{\"472\":1}}],[\"基于行的策略\",{\"1\":{\"599\":1}}],[\"基于上面覆盖索引的说明\",{\"1\":{\"475\":1}}],[\"基于非主键索引的查询需要多扫描一棵索引树\",{\"1\":{\"472\":1}}],[\"基本没有什么理论的堆砌\",{\"1\":{\"1852\":1}}],[\"基本程序结构\",{\"1\":{\"1847\":1}}],[\"基本概念\",{\"0\":{\"1454\":1}}],[\"基本类型\",{\"1\":{\"1357\":1}}],[\"基本内联混编\",{\"0\":{\"792\":1}}],[\"基本思路\",{\"1\":{\"581\":1}}],[\"基本介绍\",{\"0\":{\"565\":1}}],[\"基本上就不是分区表本身的问题\",{\"1\":{\"563\":1}}],[\"基本流程如图所示\",{\"1\":{\"541\":1}}],[\"基本有序\",{\"1\":{\"320\":1}}],[\"基本性质\",{\"1\":{\"301\":1}}],[\"非公平\",{\"1\":{\"1367\":1,\"1379\":1}}],[\"非阻塞同步\",{\"0\":{\"1695\":1}}],[\"非阻塞i\",{\"1\":{\"1453\":1}}],[\"非阻塞io的特点是用户进行需要不断的主动询问kernel数据好了没有\",{\"1\":{\"1441\":1}}],[\"非阻塞io有个问题\",{\"1\":{\"740\":1}}],[\"非阻塞io在套接字对象上提供了一个线程non\",{\"1\":{\"739\":1}}],[\"非阻塞io\",{\"0\":{\"739\":1,\"1441\":1},\"1\":{\"1438\":1,\"1444\":1}}],[\"非阻塞说的是调用者\",{\"1\":{\"1444\":1}}],[\"非阻塞和同步\",{\"0\":{\"1444\":1}}],[\"非阻塞式的解决方案\",{\"1\":{\"1359\":1}}],[\"非竞态条件下\",{\"1\":{\"1357\":1}}],[\"非整数字型字段不可用\",{\"1\":{\"710\":1}}],[\"非永久性的统计数据\",{\"1\":{\"695\":1}}],[\"非串行隔离级别\",{\"1\":{\"672\":1}}],[\"非聚集\",{\"1\":{\"642\":1}}],[\"非叶子结点不存储data\",{\"1\":{\"640\":1}}],[\"非常推荐\",{\"1\":{\"1853\":1}}],[\"非常有深度\",{\"1\":{\"1852\":1}}],[\"非常适合入门\",{\"1\":{\"1849\":1,\"1852\":1}}],[\"非常适合初学者\",{\"1\":{\"1846\":1}}],[\"非常差\",{\"1\":{\"1453\":1}}],[\"非常难\",{\"1\":{\"1453\":1}}],[\"非常便于进行数据库备份\",{\"1\":{\"733\":1}}],[\"非常友好\",{\"1\":{\"605\":1}}],[\"非常耗费数据库性能\",{\"1\":{\"568\":1}}],[\"非双1\",{\"1\":{\"594\":1}}],[\"非空\",{\"1\":{\"495\":1}}],[\"非主键索引也被称为二级索引\",{\"1\":{\"472\":1}}],[\"非主键索引的叶子节点内容是主键的值\",{\"1\":{\"472\":1}}],[\"非唯一性索引扫描\",{\"1\":{\"467\":1}}],[\"主流框架\",{\"0\":{\"1857\":1}}],[\"主流大小是64个字节\",{\"1\":{\"1396\":1}}],[\"主内存与工作内存\",{\"0\":{\"1687\":1}}],[\"主程序阻塞在accept操作上\",{\"1\":{\"1450\":1}}],[\"主节点没有应答哨兵sentinel\",{\"1\":{\"761\":1}}],[\"主节点的存储能力收到单机的限制\",{\"1\":{\"758\":1}}],[\"主节点的写能力收到单机的限制\",{\"1\":{\"758\":1}}],[\"主节点不但负责数据读写\",{\"1\":{\"755\":1}}],[\"主节点以写为主\",{\"1\":{\"743\":1}}],[\"主机故障后\",{\"1\":{\"748\":1}}],[\"主机可读可写但是多用于写\",{\"1\":{\"748\":1}}],[\"主机掉电的时候会丢数据\",{\"1\":{\"588\":1}}],[\"主机掉电时会丢binlog日志\",{\"1\":{\"588\":1}}],[\"主从可以切换\",{\"1\":{\"760\":1}}],[\"主从切换技术的方法是\",{\"1\":{\"756\":1}}],[\"主从复制时最终一致性\",{\"1\":{\"758\":1}}],[\"主从复制还是哨兵和集群能够实施的基础\",{\"1\":{\"744\":1}}],[\"主从复制实现了数据的热备份\",{\"1\":{\"744\":1}}],[\"主从复制\",{\"1\":{\"743\":1}}],[\"主从\",{\"1\":{\"701\":1}}],[\"主备同步\",{\"0\":{\"1809\":1}}],[\"主备切换不是不需要找位点了\",{\"1\":{\"605\":1}}],[\"主备切换就变成了\",{\"1\":{\"605\":1}}],[\"主备切换的可用性优先策略会导致数据不一致\",{\"1\":{\"596\":1}}],[\"主备切换可能是一个主动运维动作\",{\"1\":{\"594\":1}}],[\"主备可能发生切换\",{\"1\":{\"594\":1}}],[\"主备延迟最直接的表现是\",{\"1\":{\"594\":1}}],[\"主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差\",{\"1\":{\"594\":1}}],[\"主备延迟及其来源\",{\"0\":{\"594\":1}}],[\"主备延迟\",{\"0\":{\"593\":1}}],[\"主备的基本原理\",{\"0\":{\"590\":1}}],[\"主备一致\",{\"0\":{\"589\":1}}],[\"主动跳过一个事务\",{\"1\":{\"604\":1}}],[\"主动死锁检测在发生死锁的时候\",{\"1\":{\"581\":1}}],[\"主动回滚锁链条的某一个事务\",{\"1\":{\"581\":1}}],[\"主库的位点或者gtid集合更新很快\",{\"1\":{\"609\":1}}],[\"主库的binlog格式必须是row\",{\"1\":{\"599\":1}}],[\"主库只要等到一个从库的ack\",{\"1\":{\"609\":1}}],[\"主库收到这个ack以后\",{\"1\":{\"609\":1}}],[\"主库把binlog发给从库\",{\"1\":{\"609\":1}}],[\"主库执行完成\",{\"1\":{\"609\":1}}],[\"主库就发哪个位点\",{\"1\":{\"605\":1}}],[\"主库故障后的主备切换流程如下\",{\"1\":{\"603\":1}}],[\"主库负责所有的写入和一部分读\",{\"1\":{\"603\":1}}],[\"主库上执行完成了三个事务trx1\",{\"1\":{\"609\":1}}],[\"主库上可以并行执行的事务\",{\"1\":{\"601\":1}}],[\"主库上不同的线程创建同名的临时表是没有关系的\",{\"1\":{\"550\":1}}],[\"主库和备库上都是3行数据\",{\"1\":{\"596\":1}}],[\"主库提供写能力\",{\"1\":{\"594\":1}}],[\"主库所在机器按计划下线等\",{\"1\":{\"594\":1}}],[\"主库a\",{\"1\":{\"605\":1}}],[\"主库a已经执行完成了一个insert语句插入了一行数据r\",{\"1\":{\"604\":1}}],[\"主库a和备库b上出现了两行不一致的数据\",{\"1\":{\"596\":1}}],[\"主库a和备库b都处于readonly的状态\",{\"1\":{\"595\":1}}],[\"主库a执行完成一个事务\",{\"1\":{\"594\":1}}],[\"主库a校验完用户名\",{\"1\":{\"590\":1}}],[\"主库a内部有一个线程\",{\"1\":{\"590\":1}}],[\"主库接收到客户端的更新请求后\",{\"1\":{\"590\":1}}],[\"主库m上的两个session创建了同名的临时表t1\",{\"1\":{\"550\":1}}],[\"主库在线程退出的时候\",{\"1\":{\"550\":1}}],[\"主键自增且连续\",{\"1\":{\"659\":1}}],[\"主键自动建立主键索引\",{\"1\":{\"495\":1}}],[\"主键空缺\",{\"1\":{\"659\":1}}],[\"主键冲突\",{\"1\":{\"628\":1}}],[\"主键值和唯一索引值\",{\"1\":{\"599\":1}}],[\"主键是m\",{\"1\":{\"553\":1}}],[\"主键id\",{\"1\":{\"536\":4}}],[\"主键\",{\"1\":{\"498\":1,\"499\":2,\"500\":1}}],[\"主键长度越小\",{\"1\":{\"472\":1}}],[\"主键索引\",{\"1\":{\"656\":1}}],[\"主键索引树的叶子节点是数据\",{\"1\":{\"533\":1}}],[\"主键索引也被称为聚簇索引\",{\"1\":{\"472\":1}}],[\"主键索引的叶子节点存储的是整行数据\",{\"1\":{\"472\":1}}],[\"主要就是加载自己写的那些类\",{\"1\":{\"1540\":1}}],[\"主要思路是利用三级缓存\",{\"1\":{\"1526\":1}}],[\"主要思想\",{\"1\":{\"1352\":1}}],[\"主要用于迭代的快速失败\",{\"1\":{\"1423\":1}}],[\"主要用于维护获取锁失败时的入队的线程\",{\"1\":{\"1367\":1}}],[\"主要表现在三个方面\",{\"1\":{\"1356\":1}}],[\"主要原因有两个\",{\"1\":{\"622\":1}}],[\"主要在以下三个方面\",{\"1\":{\"489\":1}}],[\"主要是为了解决\",{\"1\":{\"1529\":1}}],[\"主要是为了取模和扩容时做优化\",{\"1\":{\"1423\":1}}],[\"主要是加载properties资源\",{\"1\":{\"1528\":1}}],[\"主要是通过commonannotationbeanpostprocessor来实现\",{\"1\":{\"1525\":1}}],[\"主要是从速度\",{\"1\":{\"1425\":1}}],[\"主要是因为来一个请求就直接对磁盘文件进行随机读写\",{\"1\":{\"680\":1}}],[\"主要是基于一致性和节省存储空间的考虑\",{\"1\":{\"642\":1}}],[\"主要是对更新性能的影响\",{\"1\":{\"481\":1}}],[\"主要是用于区别\",{\"1\":{\"467\":1}}],[\"主要参考\",{\"1\":{\"342\":1}}],[\"儿子之间的大小保证从左到右递增\",{\"1\":{\"471\":1}}],[\"父类索引与接口索引集合\",{\"0\":{\"1657\":1}}],[\"父结点的键值总是小于或等于任何一个子结点的键值\",{\"1\":{\"1383\":1}}],[\"父结点的键值总是大于或等于任何一个子结点的键值\",{\"1\":{\"1383\":1}}],[\"父结点以上的结构还是保持不变的\",{\"1\":{\"343\":1}}],[\"父进程更新统计信息\",{\"1\":{\"725\":1}}],[\"父进程创建rdb文件\",{\"1\":{\"725\":1}}],[\"父进程fork完成后\",{\"1\":{\"725\":1}}],[\"父进程执行fork操作创建子进程\",{\"1\":{\"725\":1}}],[\"父节点又小于右儿子\",{\"1\":{\"471\":1}}],[\"成绩\",{\"1\":{\"1852\":1}}],[\"成为写锁\",{\"1\":{\"1375\":1}}],[\"成为myelemz\",{\"1\":{\"714\":1}}],[\"成为驱动表\",{\"1\":{\"661\":1}}],[\"成员的分数值\",{\"1\":{\"711\":1}}],[\"成功启动哨兵模式\",{\"1\":{\"758\":1}}],[\"成功\",{\"1\":{\"710\":1,\"1375\":1}}],[\"成功插入一行\",{\"1\":{\"631\":1}}],[\"成本分析的越精确\",{\"1\":{\"693\":1}}],[\"成本数据\",{\"1\":{\"692\":1}}],[\"成本非常高\",{\"1\":{\"470\":1}}],[\"成立\",{\"1\":{\"428\":1}}],[\"值得一提的是\",{\"1\":{\"1868\":1}}],[\"值类型的参数无法进行传递\",{\"1\":{\"1495\":1}}],[\"值为\",{\"1\":{\"1367\":3}}],[\"值为1\",{\"1\":{\"1367\":1}}],[\"值为0\",{\"1\":{\"1367\":1}}],[\"值为a时代表升序存放\",{\"1\":{\"690\":1}}],[\"值的变化能够及时地在整个系统中传播的规程\",{\"1\":{\"1351\":1}}],[\"值的方式来计算\",{\"1\":{\"508\":1}}],[\"值都是固定的\",{\"1\":{\"591\":1}}],[\"值\",{\"1\":{\"469\":1,\"559\":1,\"710\":1,\"1447\":1}}],[\"值有以下三种情况\",{\"1\":{\"467\":1}}],[\"搜索和分析海量数据\",{\"1\":{\"1864\":1}}],[\"搜索的效率也就会越低\",{\"1\":{\"489\":1}}],[\"搜索树\",{\"1\":{\"468\":1}}],[\"搜索引擎为什么mysql查询快\",{\"0\":{\"176\":1}}],[\"索引文件结构\",{\"0\":{\"1798\":1}}],[\"索引按照score排序\",{\"1\":{\"711\":1}}],[\"索引从左往右\",{\"1\":{\"708\":1}}],[\"索引名\",{\"1\":{\"695\":1}}],[\"索引注释信息\",{\"1\":{\"690\":1}}],[\"索引所属表的名称\",{\"1\":{\"690\":1}}],[\"索引后上\",{\"1\":{\"658\":1}}],[\"索引设计原则\",{\"0\":{\"658\":1}}],[\"索引使用成本\",{\"1\":{\"656\":1}}],[\"索引使用范围\",{\"1\":{\"656\":1}}],[\"索引扫描行数\",{\"1\":{\"656\":1}}],[\"索引实现\",{\"0\":{\"642\":1}}],[\"索引z上的数据就是类似上图中的有序数据了\",{\"1\":{\"554\":1}}],[\"索引让mysql以最高效\",{\"1\":{\"527\":1}}],[\"索引再合适\",{\"1\":{\"518\":1}}],[\"索引优化实践\",{\"0\":{\"654\":1}}],[\"索引优化\",{\"1\":{\"518\":1}}],[\"索引优化的一般性建议\",{\"1\":{\"517\":1}}],[\"索引优化几乎和order\",{\"1\":{\"515\":1}}],[\"索引相关题目\",{\"0\":{\"514\":1}}],[\"索引列注释信息\",{\"1\":{\"690\":1}}],[\"索引列如何被压缩\",{\"1\":{\"690\":1}}],[\"索引列中不重复值的数量\",{\"1\":{\"690\":1}}],[\"索引列中的值是按照何种排序方式存放的\",{\"1\":{\"690\":1}}],[\"索引列的个数\",{\"1\":{\"695\":1}}],[\"索引列的名称\",{\"1\":{\"690\":1}}],[\"索引列的值是否是唯一的\",{\"1\":{\"690\":1}}],[\"索引列在索引中的位置\",{\"1\":{\"690\":1}}],[\"索引列上不计算\",{\"0\":{\"508\":1},\"1\":{\"508\":1}}],[\"索引列和查询列一致\",{\"1\":{\"506\":1}}],[\"索引没用上\",{\"1\":{\"507\":2}}],[\"索引中范围条件右边的字段会全部失效\",{\"1\":{\"506\":1}}],[\"索引t\",{\"1\":{\"503\":1}}],[\"索引看起来非常美好\",{\"1\":{\"502\":1}}],[\"索引失效的总结\",{\"0\":{\"517\":1}}],[\"索引失效的原理分析\",{\"0\":{\"516\":1}}],[\"索引失效的场景\",{\"0\":{\"506\":1}}],[\"索引失效\",{\"0\":{\"502\":1},\"1\":{\"511\":1,\"512\":3,\"513\":1}}],[\"索引结构\",{\"1\":{\"487\":1}}],[\"索引占用的空间会更小\",{\"1\":{\"487\":1}}],[\"索引选择异常和处理\",{\"0\":{\"485\":1}}],[\"索引统计信息也不会固定不变\",{\"1\":{\"484\":1}}],[\"索引内部就判断了age是否等于10\",{\"1\":{\"477\":1}}],[\"索引下推会减少回表次数\",{\"1\":{\"655\":1}}],[\"索引下推\",{\"0\":{\"477\":1,\"655\":1}}],[\"索引项是按照索引定义里面出现的字段顺序排序的\",{\"1\":{\"476\":1}}],[\"索引字段的维护总是有代价的\",{\"1\":{\"475\":1}}],[\"索引k已经\",{\"1\":{\"475\":1}}],[\"索引类型分为主键索引和非主键索引\",{\"1\":{\"472\":1}}],[\"索引是帮助mysql高效获取数据的排好序的数据结构\",{\"1\":{\"638\":1}}],[\"索引是如此的重要\",{\"1\":{\"518\":1}}],[\"索引是否被使用\",{\"1\":{\"514\":1}}],[\"索引是创建在book表还是创建在class表呢\",{\"1\":{\"499\":1}}],[\"索引是在存储引擎层的实现的\",{\"1\":{\"471\":1}}],[\"索引是排好序的快速查找数据结构\",{\"1\":{\"468\":1}}],[\"索引不止在内存中\",{\"1\":{\"471\":1}}],[\"索引的2~4\",{\"1\":{\"711\":1}}],[\"索引的名称\",{\"1\":{\"690\":1}}],[\"索引的图示\",{\"1\":{\"638\":1}}],[\"索引的最佳实践\",{\"0\":{\"497\":1}}],[\"索引的创建时机\",{\"0\":{\"494\":1}}],[\"索引的示意图\",{\"1\":{\"493\":1}}],[\"索引的长度变成了4个字节\",{\"1\":{\"489\":1}}],[\"索引的区分度就越好\",{\"1\":{\"484\":1}}],[\"索引的选择性是指索引列中不同值的数目与表中记录数的比\",{\"1\":{\"496\":1}}],[\"索引的选择\",{\"0\":{\"483\":1}}],[\"索引的执行流程\",{\"0\":{\"473\":1}}],[\"索引的出现是为了提高查询效率\",{\"1\":{\"468\":1}}],[\"索引的维护比较困难\",{\"1\":{\"331\":1}}],[\"索引常见模型\",{\"0\":{\"468\":1}}],[\"常量池\",{\"0\":{\"1655\":1}}],[\"常常为了提高应用程序的并发性\",{\"1\":{\"1407\":1}}],[\"常用工具\",{\"1\":{\"1844\":1}}],[\"常用框架\",{\"1\":{\"1844\":1}}],[\"常用方法总结\",{\"1\":{\"1395\":1}}],[\"常用算法\",{\"0\":{\"282\":1}}],[\"常数\",{\"1\":{\"692\":2}}],[\"常数引用等\",{\"1\":{\"527\":1}}],[\"常在河边走\",{\"1\":{\"620\":1}}],[\"常见连接池包括\",{\"1\":{\"1852\":1}}],[\"常见且默认的等待测了\",{\"1\":{\"1397\":1}}],[\"常见编解码器总结\",{\"0\":{\"890\":1}}],[\"常见sql优化\",{\"0\":{\"657\":1}}],[\"常见索引的数据结构\",{\"1\":{\"638\":1}}],[\"常见的函数式接口\",{\"0\":{\"1473\":1}}],[\"常见的阻塞队列\",{\"1\":{\"1378\":1}}],[\"常见的导致自增主键的原因有\",{\"1\":{\"628\":1}}],[\"常见的做法是放一个timestamp字段\",{\"1\":{\"615\":1}}],[\"常见于排序order\",{\"1\":{\"467\":1}}],[\"包了\",{\"1\":{\"1858\":1}}],[\"包资源库\",{\"1\":{\"1858\":1}}],[\"包括它的源\",{\"1\":{\"1500\":1}}],[\"包括原来的就是spliterator就是空的\",{\"1\":{\"1497\":1}}],[\"包括父类的属性信息\",{\"1\":{\"1361\":1}}],[\"包括连接管理\",{\"1\":{\"806\":1}}],[\"包括主服务器和从服务器\",{\"1\":{\"757\":1}}],[\"包括元素成员和元素分值\",{\"1\":{\"711\":1}}],[\"包括间隙锁\",{\"1\":{\"613\":1}}],[\"包括\",{\"1\":{\"610\":1}}],[\"包括memory引擎\",{\"1\":{\"546\":1}}],[\"包括网络\",{\"1\":{\"518\":1}}],[\"包括排序\",{\"1\":{\"518\":1}}],[\"包括了4结点的使用\",{\"1\":{\"348\":1}}],[\"包含核心基础\",{\"1\":{\"1861\":1}}],[\"包含两个重要部件\",{\"1\":{\"1566\":1}}],[\"包含多组服务\",{\"1\":{\"1563\":1}}],[\"包含多个host\",{\"1\":{\"1561\":1}}],[\"包含一个终止操作\",{\"1\":{\"1496\":1}}],[\"包含0个或多个中间操作\",{\"1\":{\"1496\":1}}],[\"包含三个方面\",{\"1\":{\"1347\":1}}],[\"包含间隙行记录\",{\"1\":{\"673\":1}}],[\"包含了key和value以及next指针\",{\"1\":{\"1430\":1}}],[\"包含了一个hashentry数组\",{\"1\":{\"1430\":1}}],[\"包含了一个segment的数组\",{\"1\":{\"1430\":1}}],[\"包含了删掉的行的所有字段的值\",{\"1\":{\"591\":1}}],[\"包含了每个记录的整个字符串\",{\"1\":{\"487\":1}}],[\"包含不适合在其他列中显示但十分重要的额外信息\",{\"1\":{\"467\":1}}],[\"全文搜索属于最常见的需求\",{\"1\":{\"1864\":1}}],[\"全局有序\",{\"0\":{\"1740\":1}}],[\"全局锁对比\",{\"0\":{\"575\":1}}],[\"全局锁的典型使用场景是\",{\"1\":{\"574\":1}}],[\"全局锁的特点\",{\"0\":{\"574\":1}}],[\"全局锁就是对整个数据库实例加锁\",{\"1\":{\"574\":1}}],[\"全局锁\",{\"0\":{\"573\":1}}],[\"全盘负责是指当一个classloader装在一个类时\",{\"1\":{\"1540\":1}}],[\"全盘负责委托机制\",{\"1\":{\"1540\":1}}],[\"全程都没有通过\",{\"1\":{\"1460\":1}}],[\"全量复制\",{\"0\":{\"752\":1}}],[\"全部应用到临时库\",{\"1\":{\"622\":1}}],[\"全部同步完成\",{\"1\":{\"604\":1}}],[\"全库只读除了使用ftwrl\",{\"1\":{\"575\":1}}],[\"全值匹配\",{\"1\":{\"515\":1}}],[\"全值匹配我最爱\",{\"1\":{\"506\":1}}],[\"全字段排序和rowid排序对比\",{\"0\":{\"493\":1}}],[\"全字段排序\",{\"0\":{\"491\":1}}],[\"全表扫描tracer的输出\",{\"1\":{\"688\":1}}],[\"全表扫描的成本\",{\"1\":{\"688\":1}}],[\"全表扫描的成本低于索引扫描\",{\"1\":{\"656\":1}}],[\"全表扫描的意思就是把聚簇索引中的记录都一次和给定的搜索条件做一下比较\",{\"1\":{\"685\":1}}],[\"全表扫描情况\",{\"1\":{\"656\":1}}],[\"全表扫描\",{\"1\":{\"467\":1,\"499\":1,\"511\":1,\"512\":3,\"513\":1,\"656\":1}}],[\"全索引扫描\",{\"1\":{\"467\":1}}],[\"了\",{\"1\":{\"467\":1,\"515\":1,\"615\":1,\"1427\":1,\"1438\":1}}],[\"了解学习的重难点和掌握合适的学习方法非常重要\",{\"1\":{\"1850\":1}}],[\"了解它对于我们认识stream类有着及其关键的作用\",{\"1\":{\"1492\":1}}],[\"了解这些方法的使用以及实现细节\",{\"1\":{\"1493\":1}}],[\"了解这个查询需要哪些索引以及它的执行计划是什么\",{\"1\":{\"525\":1}}],[\"了解这两个日志的作用\",{\"1\":{\"463\":1}}],[\"了解每个组件的作用\",{\"1\":{\"454\":1}}],[\"读socket\",{\"1\":{\"1410\":1,\"1411\":1}}],[\"读多写少的场景\",{\"1\":{\"1404\":1}}],[\"读线程获取读锁后\",{\"1\":{\"1375\":1}}],[\"读读可以并发\",{\"1\":{\"1375\":1}}],[\"读方法和写方法都会通过返回值来告知程序实际读写了多少字节\",{\"1\":{\"739\":1}}],[\"读操作不记录\",{\"1\":{\"728\":1}}],[\"读取小文件\",{\"1\":{\"1464\":1}}],[\"读取\",{\"1\":{\"1350\":1}}],[\"读取message\",{\"0\":{\"831\":1}}],[\"读取一个页面花费的成本默认是1\",{\"1\":{\"694\":1}}],[\"读取的数据量\",{\"1\":{\"692\":1}}],[\"读取这些二级索引记录的cpu成本就是\",{\"1\":{\"686\":1}}],[\"读取并检测回表后聚簇索引记录的成本\",{\"1\":{\"686\":1}}],[\"读取并检测回表后聚簇索引的成本\",{\"1\":{\"686\":1}}],[\"读取并检测这些完整的用户记录是否符合其余的搜索条件的cpu成本如下\",{\"1\":{\"686\":1}}],[\"读取二级索引记录的成本\",{\"1\":{\"686\":2}}],[\"读取以及检测一条记录是否符合搜索条件的成本默认是0\",{\"1\":{\"682\":1}}],[\"读取以及检测记录是否满足对应的搜索条件\",{\"1\":{\"682\":1}}],[\"读取时还要保证其他并发事务不能修改当前记录\",{\"1\":{\"678\":1}}],[\"读取记录最新的版本\",{\"1\":{\"678\":1}}],[\"读取本表中和关联表表中的每行组合成的一行\",{\"1\":{\"467\":1}}],[\"读已提交\",{\"1\":{\"669\":1}}],[\"读出来就是什么\",{\"1\":{\"666\":1}}],[\"读一个处理一个\",{\"1\":{\"619\":1}}],[\"读从库之前先sleep一下\",{\"1\":{\"608\":1}}],[\"读写操作可以并发执行\",{\"1\":{\"1380\":1}}],[\"读写锁有一下三个重要的特性\",{\"1\":{\"1375\":1}}],[\"读写锁能够提供比拍他锁更好的并发性和吞吐量\",{\"1\":{\"1375\":1}}],[\"读写锁之间\",{\"1\":{\"578\":1}}],[\"读写\",{\"1\":{\"1375\":1}}],[\"读写可以瞬间完成然后程序可以继续干别的事了\",{\"1\":{\"739\":1}}],[\"读写方法不会阻塞\",{\"1\":{\"739\":1}}],[\"读写io的函数一致无法返回\",{\"1\":{\"618\":1}}],[\"读写分离的主要目标就是分摊主库的压力\",{\"1\":{\"606\":1}}],[\"读写分离\",{\"0\":{\"606\":1},\"1\":{\"807\":1}}],[\"读写分离是怎么做的\",{\"0\":{\"165\":1}}],[\"读锁是共享的\",{\"1\":{\"1375\":1}}],[\"读锁可以由多个reader线程同时持有\",{\"1\":{\"1375\":1}}],[\"读锁和写锁都支持线程重入\",{\"1\":{\"1375\":1}}],[\"读锁之间不互斥\",{\"1\":{\"578\":1}}],[\"读锁\",{\"1\":{\"570\":1,\"670\":1}}],[\"读\",{\"1\":{\"570\":1}}],[\"读提交是指\",{\"1\":{\"570\":1}}],[\"读提交\",{\"1\":{\"570\":5}}],[\"读未提交是指\",{\"1\":{\"570\":1}}],[\"读未提交\",{\"1\":{\"570\":3,\"669\":1}}],[\"读page1的时候\",{\"1\":{\"482\":1}}],[\"访问标志\",{\"0\":{\"1656\":1}}],[\"访问结束再删除该短期key\",{\"1\":{\"767\":1}}],[\"访问方法为range\",{\"1\":{\"692\":1}}],[\"访问的时候以视图的逻辑结果为准\",{\"1\":{\"570\":1}}],[\"访问次数\",{\"1\":{\"566\":1}}],[\"访问了表的三行数据\",{\"1\":{\"557\":1}}],[\"访问类型\",{\"1\":{\"656\":1}}],[\"访问类型变成了一个全表扫描\",{\"1\":{\"527\":1}}],[\"访问类型有很多中\",{\"1\":{\"527\":1}}],[\"访问类型排列\",{\"1\":{\"467\":1}}],[\"访问上\",{\"1\":{\"435\":2}}],[\"衍生\",{\"1\":{\"467\":1}}],[\"联合索引尽量覆盖条件\",{\"1\":{\"658\":1}}],[\"联合查询\",{\"1\":{\"467\":1}}],[\"联系与区别\",{\"0\":{\"13\":1}}],[\"联系我\",{\"0\":{\"10\":1}}],[\"普通公司也有可能会有算法的笔试环节\",{\"1\":{\"1848\":1}}],[\"普通对象是依赖注入的后的对象\",{\"1\":{\"1507\":1}}],[\"普通消息\",{\"1\":{\"711\":1}}],[\"普通二级索引该列值为1\",{\"1\":{\"690\":1}}],[\"普通insert语句\",{\"1\":{\"629\":1}}],[\"普通的方法接收的参数tryadvance\",{\"1\":{\"1497\":1}}],[\"普通的get是无法获取list值的\",{\"1\":{\"708\":1}}],[\"普通的set\",{\"1\":{\"707\":1}}],[\"普通的查询语句不需要申请trx\",{\"1\":{\"634\":1}}],[\"普通的查询是快照读\",{\"1\":{\"583\":1}}],[\"普通的insert语句里面包含多个value值的情况下\",{\"1\":{\"629\":1}}],[\"普通的栈\",{\"1\":{\"392\":1}}],[\"普通索引树比主键索引树小很多\",{\"1\":{\"533\":1}}],[\"普通索引和唯一索引\",{\"0\":{\"478\":1}}],[\"普通索引占用的空间也就越小\",{\"1\":{\"472\":1}}],[\"普通索引的叶子节点就越小\",{\"1\":{\"472\":1}}],[\"普通查询\",{\"1\":{\"467\":1}}],[\"越容易得到好的执行计划\",{\"1\":{\"693\":1}}],[\"越先被执行\",{\"1\":{\"467\":1}}],[\"越界处理\",{\"1\":{\"388\":1}}],[\"崩溃恢复以后这个事务无效\",{\"1\":{\"464\":1}}],[\"首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用\",{\"1\":{\"1543\":1}}],[\"首先将id\",{\"1\":{\"469\":1}}],[\"首先是定义在referencepipeline类当中的内部类head\",{\"1\":{\"1498\":1}}],[\"首先是tryadvance方法\",{\"1\":{\"1497\":1}}],[\"首先是通过二次哈希减小哈希冲突的可能性\",{\"1\":{\"1430\":1}}],[\"首先还是定义一个非常简单的例子\",{\"1\":{\"1497\":1}}],[\"首先stream是一个支持并行与串行聚合操作的元素的序列\",{\"1\":{\"1496\":1}}],[\"首先来查看reducing方法的定义\",{\"1\":{\"1495\":1}}],[\"首先来读一下方法的说明\",{\"1\":{\"1495\":1}}],[\"首先来看方法的说明\",{\"1\":{\"1497\":1}}],[\"首先来看这样一个例子\",{\"1\":{\"1487\":1,\"1489\":1}}],[\"首先来看一下groupingby方法的定义\",{\"1\":{\"1495\":1}}],[\"首先来看一下类的说明\",{\"1\":{\"1492\":1}}],[\"首先来看一下a\",{\"1\":{\"484\":1}}],[\"首先来看一个具体的例子\",{\"1\":{\"1486\":1}}],[\"首先来看minby\",{\"1\":{\"1478\":1}}],[\"首先来看类的说明\",{\"1\":{\"1477\":1,\"1478\":1}}],[\"首先来看第二行\",{\"1\":{\"1469\":1}}],[\"首先回到我们之前的例子当中\",{\"1\":{\"1492\":1}}],[\"首先可以看到这是一个函数式接口\",{\"1\":{\"1491\":1}}],[\"首先会通过supplier\",{\"1\":{\"1485\":1}}],[\"首先会应用当前的function\",{\"1\":{\"1475\":1}}],[\"首先会应用before这个function\",{\"1\":{\"1475\":1}}],[\"首先定义这样两个接口\",{\"1\":{\"1484\":1}}],[\"首先定义一个转换器\",{\"1\":{\"1516\":1}}],[\"首先定义一个这样的类\",{\"1\":{\"1481\":1}}],[\"首先定义一个类\",{\"1\":{\"1480\":1}}],[\"首先创建一个student类\",{\"1\":{\"1477\":1}}],[\"首先调用传入的function的apply\",{\"1\":{\"1475\":1}}],[\"首先它是从初始状态开始的\",{\"1\":{\"1500\":1}}],[\"首先它是一个默认方法\",{\"1\":{\"1472\":1}}],[\"首先它会立刻返回\",{\"1\":{\"1443\":1}}],[\"首先同样的是在collection接口中新增加了一个default\",{\"1\":{\"1470\":1}}],[\"首先需要考虑的就是功能层面\",{\"1\":{\"1386\":1}}],[\"首先比较它的内存值与某个期望值是否相同\",{\"1\":{\"1356\":1}}],[\"首先对表中的cost\",{\"1\":{\"694\":1}}],[\"首先分析一下server\",{\"1\":{\"694\":1}}],[\"首先看一下涉及s2表单表的搜索条件有s2\",{\"1\":{\"692\":1}}],[\"首先看一下涉及s1表单表的搜索条件有s1\",{\"1\":{\"692\":1}}],[\"首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行id\",{\"1\":{\"657\":1}}],[\"首先我们为接下来的部分提前定义好一个学生类作为我们分析源码的入口\",{\"1\":{\"1490\":1}}],[\"首先我们创建一个stream\",{\"1\":{\"1484\":1}}],[\"首先我们需要了解一些stream的基本概念\",{\"1\":{\"1484\":1}}],[\"首先我们需要把当前的max\",{\"1\":{\"634\":1}}],[\"首先我们来阅读以下这个方法的说明\",{\"1\":{\"1495\":1}}],[\"首先我们来分析一下我们使用过的最多的tolist方法\",{\"1\":{\"1495\":1}}],[\"首先我们来看一下reduceops的makeref方法\",{\"1\":{\"1494\":1}}],[\"首先我们来读一下它的javadoc\",{\"1\":{\"1475\":1}}],[\"首先我们来回顾一下nlj算法的执行流程\",{\"1\":{\"542\":1}}],[\"首先我们观察consumer这个接口的定义\",{\"1\":{\"1474\":1}}],[\"首先我们使用传统的匿名内部类的方式来实现myinterface中的test\",{\"1\":{\"1472\":1}}],[\"首先我们列表\",{\"1\":{\"708\":1}}],[\"首先在实例x中创建表t\",{\"1\":{\"605\":1}}],[\"首先要了解一条命令\",{\"1\":{\"610\":1}}],[\"首先要明确的一个概念是\",{\"1\":{\"594\":1}}],[\"首先要解决的是长事务\",{\"1\":{\"578\":1}}],[\"首先使用alter\",{\"1\":{\"561\":1}}],[\"首先计算这个列上有多少个不同的值\",{\"1\":{\"487\":1}}],[\"首先扫描索引b的最后50001个值\",{\"1\":{\"484\":1}}],[\"首先扫描索引a的前1000个值\",{\"1\":{\"484\":1}}],[\"首先先建一张表\",{\"1\":{\"483\":1}}],[\"首先\",{\"1\":{\"464\":1,\"489\":1,\"615\":1,\"618\":1,\"1356\":1,\"1482\":1,\"1846\":1}}],[\"随着我们不断的对表进行增删改操作\",{\"1\":{\"696\":1}}],[\"随机移除并返回2个成员\",{\"1\":{\"709\":1}}],[\"随机移除并返回集合中count个成员\",{\"1\":{\"709\":1}}],[\"随机返回1个成员\",{\"1\":{\"709\":1}}],[\"随机返回3个成员\",{\"1\":{\"709\":1}}],[\"随机返回集合中count个成员\",{\"1\":{\"709\":1}}],[\"随机选其中一条记录来加\",{\"1\":{\"581\":1}}],[\"随机排序法\",{\"0\":{\"559\":1}}],[\"随机数法\",{\"1\":{\"332\":1}}],[\"随时可以提交事务\",{\"1\":{\"463\":1}}],[\"另有一种是传递引用\",{\"1\":{\"1470\":1}}],[\"另一方面线程占用的内存也比较大\",{\"1\":{\"1410\":1}}],[\"另一方面\",{\"1\":{\"1351\":1}}],[\"另一方式时\",{\"1\":{\"604\":1}}],[\"另一好处是\",{\"1\":{\"634\":1}}],[\"另一类情况是\",{\"1\":{\"618\":1}}],[\"另一类表级的锁是mdl\",{\"1\":{\"578\":1}}],[\"另一个foreach方法是在referencepipeline当中\",{\"1\":{\"1499\":1}}],[\"另一个线程可能会进一步的分割\",{\"1\":{\"1497\":1}}],[\"另一个线程修改了我们的值\",{\"1\":{\"718\":1}}],[\"另一个用于写入操作\",{\"1\":{\"1375\":1}}],[\"另一个库的自增id都是偶数\",{\"1\":{\"628\":1}}],[\"另一个箭头代表的是备库上sql\",{\"1\":{\"597\":1}}],[\"另一个是仅检查线程的中断状态也是不够的\",{\"1\":{\"1401\":1}}],[\"另一个是无法指令唤醒的线程具体是哪一个\",{\"1\":{\"1354\":1}}],[\"另一个是共用mdl锁\",{\"1\":{\"563\":1}}],[\"另一个是整型\",{\"1\":{\"557\":1}}],[\"另一种是激活状态\",{\"1\":{\"1500\":1}}],[\"另一种是利用上下文切换\",{\"1\":{\"1350\":1}}],[\"另一种是不读缓存\",{\"1\":{\"619\":1}}],[\"另一种比较典型的大事务场景\",{\"1\":{\"594\":1}}],[\"另一种方法是控制并发度\",{\"1\":{\"581\":1}}],[\"另一种策略是\",{\"1\":{\"581\":1}}],[\"另一块是引擎层\",{\"1\":{\"462\":1}}],[\"另外是由于lambda表达式中的类型判断是需要结合具体的上下文的\",{\"1\":{\"1497\":1}}],[\"另外如果中间结果容器和最终结果的结果容器类型相同\",{\"1\":{\"1494\":1}}],[\"另外如果原sql是order\",{\"1\":{\"659\":1}}],[\"另外一种方案就是线程本地存储模式\",{\"1\":{\"1405\":1}}],[\"另外一个行锁\",{\"1\":{\"585\":1}}],[\"另外http协议非常通用\",{\"1\":{\"798\":1}}],[\"另外整型的存储空间也比较小\",{\"1\":{\"642\":1}}],[\"另外建议使用这些命令时结合|和more使用\",{\"1\":{\"566\":1}}],[\"另外\",{\"1\":{\"350\":1,\"439\":1,\"491\":1,\"531\":1,\"561\":1,\"563\":1,\"601\":1,\"609\":1,\"1386\":1,\"1518\":1}}],[\"擦除记录前要把记录更新到数据文件\",{\"1\":{\"461\":1}}],[\"写或者同时读写\",{\"1\":{\"1451\":1}}],[\"写socket\",{\"1\":{\"1410\":1,\"1411\":1}}],[\"写时复制模式\",{\"1\":{\"1404\":1}}],[\"写线程在获取写锁之后能够再次获取写锁\",{\"1\":{\"1375\":1}}],[\"写写互斥\",{\"1\":{\"1375\":1}}],[\"写读\",{\"1\":{\"1375\":1}}],[\"写必须被所有处理器以相同的顺序看到\",{\"1\":{\"1351\":1}}],[\"写传播\",{\"1\":{\"1351\":1}}],[\"写命令的发送过程是异步完成的\",{\"1\":{\"755\":1}}],[\"写不完\",{\"1\":{\"740\":1}}],[\"写也是一样\",{\"1\":{\"740\":1}}],[\"写锁是独占的\",{\"1\":{\"1375\":1}}],[\"写锁能够降级成为读锁\",{\"1\":{\"1375\":1}}],[\"写锁\",{\"1\":{\"670\":1}}],[\"写锁之间是互斥的\",{\"1\":{\"578\":1}}],[\"写redo\",{\"1\":{\"621\":1}}],[\"写回主库的命令是\",{\"1\":{\"621\":1}}],[\"写binlog其实是分成两步的\",{\"1\":{\"588\":1}}],[\"写到本地文件\",{\"1\":{\"590\":1}}],[\"写到磁盘\",{\"1\":{\"588\":1}}],[\"写到第3号文件末尾后就回到0号文件开头\",{\"1\":{\"461\":1}}],[\"写入文件\",{\"0\":{\"1762\":1}}],[\"写入表的row\",{\"1\":{\"632\":1}}],[\"写入\",{\"1\":{\"605\":1,\"1350\":1}}],[\"写入binlog\",{\"1\":{\"594\":1,\"609\":1}}],[\"写入了update\",{\"1\":{\"584\":1}}],[\"写入了两条语句\",{\"1\":{\"584\":2}}],[\"写入到binlog中的目的是为了主备复制\",{\"1\":{\"550\":1}}],[\"写\",{\"1\":{\"570\":1}}],[\"写数据的时候是写到磁盘上的\",{\"1\":{\"546\":1}}],[\"写屏障你了解吗\",{\"0\":{\"119\":1}}],[\"到时就产生一个代理对象作为bean\",{\"1\":{\"1532\":1}}],[\"到时候\",{\"1\":{\"1530\":1}}],[\"到目前这个阶段\",{\"1\":{\"1492\":1}}],[\"到底什么是lambda表达式呢\",{\"1\":{\"1470\":1}}],[\"到底应该怎么办呢\",{\"1\":{\"533\":1}}],[\"到整个操作序列的外部\",{\"1\":{\"1363\":1}}],[\"到备库执行的时候\",{\"1\":{\"629\":1}}],[\"到终止逻辑完全完成\",{\"1\":{\"618\":1}}],[\"到主库执行查询语句\",{\"1\":{\"610\":1,\"611\":1}}],[\"到主键索引上找出相应的记录\",{\"1\":{\"655\":1}}],[\"到主键索引上找出数据行\",{\"1\":{\"477\":1}}],[\"到主键id索引取出整行\",{\"1\":{\"491\":1,\"492\":1,\"493\":1}}],[\"到主键查找到主键是id1的行\",{\"1\":{\"487\":1}}],[\"到主键上查找到主键值是id2的行\",{\"1\":{\"487\":1}}],[\"到应用完file和pos表示的binlog位置\",{\"1\":{\"610\":1}}],[\"到本地执行\",{\"1\":{\"590\":1}}],[\"到这里\",{\"1\":{\"559\":1}}],[\"到此\",{\"1\":{\"557\":1}}],[\"到哈希表中寻找匹配的数据\",{\"1\":{\"545\":1}}],[\"到被驱动表上匹配一次\",{\"1\":{\"538\":1}}],[\"到50\",{\"1\":{\"533\":1}}],[\"到服务器\",{\"1\":{\"518\":1}}],[\"到\",{\"1\":{\"491\":1,\"666\":5}}],[\"到末尾又回到开头循环写入\",{\"1\":{\"461\":1}}],[\"到n+1\",{\"1\":{\"431\":1}}],[\"同步阻塞i\",{\"1\":{\"1453\":1}}],[\"同步io\",{\"1\":{\"1444\":1}}],[\"同步io和异步io的区别\",{\"1\":{\"1444\":1}}],[\"同步等待队列\",{\"0\":{\"1368\":1},\"1\":{\"1367\":1}}],[\"同步省略或锁消除\",{\"1\":{\"1365\":1}}],[\"同步代码块是通过monitorenter和monitorexit来实现\",{\"1\":{\"1360\":1}}],[\"同步方法是通过方法中的access\",{\"1\":{\"1360\":1}}],[\"同步是由于线程执行的先后\",{\"1\":{\"1359\":1}}],[\"同步问题\",{\"1\":{\"1347\":1}}],[\"同步和异步spring事件广播\",{\"0\":{\"1284\":1}}],[\"同步\",{\"1\":{\"701\":1,\"726\":1,\"761\":1,\"1444\":1}}],[\"同步延迟\",{\"1\":{\"594\":1}}],[\"同一性指的是\",{\"1\":{\"1492\":1}}],[\"同一性\",{\"1\":{\"1492\":1}}],[\"同一位置上的新元素总会被放在链表的头部位置\",{\"1\":{\"1427\":1}}],[\"同一时刻只能有一个线程执行临界区代码\",{\"1\":{\"1359\":1}}],[\"同一个web服务器里\",{\"1\":{\"1571\":2}}],[\"同一个数据连接\",{\"1\":{\"1532\":1}}],[\"同一个sentinel对同一个master两次failover之间的间隔时间\",{\"1\":{\"761\":1}}],[\"同一个只读事务查出来的trx\",{\"1\":{\"634\":1}}],[\"同一个binlog文件里\",{\"1\":{\"633\":1}}],[\"同一个语句去申请自增id\",{\"1\":{\"629\":1}}],[\"同一个事务不能被拆开\",{\"1\":{\"597\":1}}],[\"同一个事务的多个更新语句\",{\"1\":{\"597\":1}}],[\"同一行上的两个事务\",{\"1\":{\"597\":1}}],[\"同一行语句是在同一时刻执行的\",{\"1\":{\"533\":1}}],[\"同一条记录在系统中可以存在多个版本\",{\"1\":{\"571\":1}}],[\"同样\",{\"1\":{\"1870\":1}}],[\"同样取出这三个字段的值\",{\"1\":{\"493\":1}}],[\"同样地\",{\"1\":{\"489\":1}}],[\"同样的方式\",{\"1\":{\"1476\":1}}],[\"同样的我们可以举一个例子\",{\"1\":{\"1475\":1}}],[\"同样的也是一个名叫foreach的方法\",{\"1\":{\"1470\":1}}],[\"同样的key会被覆盖掉\",{\"1\":{\"1352\":1}}],[\"同样的更新语句也会按照sql语句的基本执行链路执行\",{\"1\":{\"460\":1}}],[\"同样的\",{\"1\":{\"403\":1,\"1471\":1,\"1475\":1,\"1477\":1,\"1490\":1,\"1491\":1,\"1495\":1,\"1496\":1}}],[\"同理\",{\"1\":{\"470\":1,\"621\":1}}],[\"同时使用前缀树实现敏感词过滤\",{\"1\":{\"1865\":1}}],[\"同时监听8005端口发过来的shutdown命令\",{\"1\":{\"1563\":1}}],[\"同时收集器会对该值进行调整\",{\"1\":{\"1541\":1}}],[\"同时因为classpathmapperscanner中重写了iscandidatecomponent方法\",{\"1\":{\"1530\":1}}],[\"同时你也可以通知sink需要处理的数据量是多少\",{\"1\":{\"1500\":1}}],[\"同时true\",{\"1\":{\"1497\":1}}],[\"同时其中的抽象方法apply\",{\"1\":{\"1478\":1}}],[\"同时内核缓冲区和用户缓冲区也无需建立内存映射\",{\"1\":{\"1459\":1}}],[\"同时也会创建standardenvironment对象\",{\"1\":{\"1528\":1}}],[\"同时也说明了characteristics就定义了中间结果容器和最终结果的结果容器类型的关系\",{\"1\":{\"1494\":1}}],[\"同时也是为了向后兼容的一种妥协\",{\"1\":{\"1484\":1}}],[\"同时也需要cpu响应中断\",{\"1\":{\"1457\":1}}],[\"同时也可以获取读锁\",{\"1\":{\"1375\":1}}],[\"同时上下文从内核态转为用户态\",{\"1\":{\"1457\":1}}],[\"同时处于用户态的进程不能访问内核空间中的数据\",{\"1\":{\"1456\":1}}],[\"同时处于prepare阶段的事务\",{\"1\":{\"602\":1}}],[\"同时处于prepare状态的事务\",{\"1\":{\"602\":1}}],[\"同时我们对线程创建也缺乏管理\",{\"1\":{\"1450\":1}}],[\"同时连接的大量客户端在同一时刻可能只有很少的处于就绪状态\",{\"1\":{\"1447\":1}}],[\"同时pollfd并没有最大数量限制\",{\"1\":{\"1447\":1}}],[\"同时不会有太大的开销\",{\"1\":{\"1425\":1}}],[\"同时为了减少冲突\",{\"1\":{\"1423\":1}}],[\"同时向condition队列尾部添加一个节点\",{\"1\":{\"1370\":1}}],[\"同时会阻塞当前线程\",{\"1\":{\"1368\":1}}],[\"同时会将这个变化实时通知给redis应用方\",{\"1\":{\"758\":1}}],[\"同时遍历jvm中所有线程的栈\",{\"1\":{\"1362\":1}}],[\"同时有大量的请求\",{\"1\":{\"766\":1}}],[\"同时需要修改应用方的主节点地址\",{\"1\":{\"758\":1}}],[\"同时将多个\",{\"1\":{\"710\":1}}],[\"同时将这个更新操作记录到redo\",{\"1\":{\"463\":1}}],[\"同时通过redis\",{\"1\":{\"705\":1}}],[\"同时在其基础上增加了阻塞功能\",{\"1\":{\"1378\":1}}],[\"同时在该条记录的头信息\",{\"1\":{\"679\":1}}],[\"同时在这个字段上创建索引\",{\"1\":{\"489\":1}}],[\"同时还提供了timeout参数\",{\"1\":{\"740\":1}}],[\"同时还能保证各种异常情况下的数据一致性\",{\"1\":{\"680\":1}}],[\"同时还会在索引里过滤age和position这两个字段\",{\"1\":{\"655\":1}}],[\"同时还可以减少mysql复制的延迟\",{\"1\":{\"530\":1}}],[\"同时设置binlog\",{\"1\":{\"629\":1}}],[\"同时执行向表t2中插入数据的操作\",{\"1\":{\"629\":1}}],[\"同时执在执行的语句超过了设置的innnodb\",{\"1\":{\"613\":1}}],[\"同时修改哈希表\",{\"1\":{\"598\":1}}],[\"同时又避免了数据不一致的风险\",{\"1\":{\"591\":1}}],[\"同时写binlog也要耗费io资源\",{\"1\":{\"591\":1}}],[\"同时写binlog\",{\"1\":{\"590\":1}}],[\"同时存在\",{\"1\":{\"467\":1}}],[\"同时\",{\"1\":{\"461\":1,\"482\":1,\"530\":1,\"541\":1,\"669\":1,\"1378\":1,\"1396\":1,\"1427\":1}}],[\"归档日志\",{\"0\":{\"462\":1},\"1\":{\"460\":1,\"462\":1}}],[\"归并排序\",{\"0\":{\"322\":1},\"1\":{\"316\":1}}],[\"至多删除2个\",{\"1\":{\"708\":1}}],[\"至多删除3个\",{\"1\":{\"708\":1}}],[\"至多删除count个\",{\"1\":{\"708\":1}}],[\"至于spring\",{\"1\":{\"1868\":1}}],[\"至于底层如何充分利用计算机资源帮助我们快速迭代\",{\"1\":{\"1489\":1}}],[\"至于具体选择哪一种\",{\"1\":{\"610\":1}}],[\"至于分区表的其它问题\",{\"1\":{\"563\":1}}],[\"至少跑1天\",{\"1\":{\"567\":1}}],[\"至此为止\",{\"1\":{\"1498\":1}}],[\"至此\",{\"1\":{\"459\":1,\"1490\":1}}],[\"至今\",{\"1\":{\"9\":1}}],[\"去\",{\"1\":{\"1535\":1}}],[\"去得到一个sqlsession对象\",{\"1\":{\"1530\":1}}],[\"去除不可能存在共享资源竞争的锁\",{\"1\":{\"1364\":1}}],[\"去查看商品的时候\",{\"1\":{\"608\":1}}],[\"去临时表里面拿到word字段\",{\"1\":{\"558\":1}}],[\"去重\",{\"1\":{\"551\":1}}],[\"去表t2查找满足条件的记录\",{\"1\":{\"538\":1}}],[\"去使用这个引擎提供的接口\",{\"1\":{\"459\":1}}],[\"去掉集合中重复的元素\",{\"1\":{\"1494\":1}}],[\"去掉没有参数的构造方法\",{\"1\":{\"1477\":1}}],[\"去掉\",{\"1\":{\"415\":1}}],[\"去掉重复情况\",{\"1\":{\"366\":2}}],[\"决定各个表的连接顺序\",{\"1\":{\"458\":1,\"651\":1}}],[\"决定使用哪个索引\",{\"1\":{\"458\":1,\"651\":2}}],[\"语言起源开始\",{\"1\":{\"1847\":1}}],[\"语言有一个初步的了解\",{\"1\":{\"1847\":1}}],[\"语言基础\",{\"1\":{\"1844\":2}}],[\"语义是把id=0\",{\"1\":{\"584\":1}}],[\"语义的逻辑是相同的\",{\"1\":{\"485\":1}}],[\"语义完全相同\",{\"1\":{\"354\":1}}],[\"语句返回\",{\"1\":{\"628\":1}}],[\"语句才算真正完成\",{\"1\":{\"618\":1}}],[\"语句从开始进入终止逻辑\",{\"1\":{\"618\":1}}],[\"语句处于锁等待的时候\",{\"1\":{\"617\":1}}],[\"语句在节点a执行\",{\"1\":{\"590\":1}}],[\"语句的执行流程如下\",{\"1\":{\"544\":1}}],[\"语句的执行速度会得到明显的提升\",{\"1\":{\"480\":1}}],[\"语句执行过程中\",{\"1\":{\"629\":1}}],[\"语句执行失败也不会回退自增id\",{\"1\":{\"628\":1}}],[\"语句执行就结束了\",{\"1\":{\"480\":1}}],[\"语句执行结束\",{\"1\":{\"480\":1}}],[\"语法解析\",{\"1\":{\"694\":1}}],[\"语法\",{\"1\":{\"466\":1}}],[\"语法分析由bison生成\",{\"1\":{\"650\":1}}],[\"语法分析器会根据语法规则\",{\"1\":{\"457\":1}}],[\"语法分析\",{\"1\":{\"457\":1}}],[\"做1\",{\"1\":{\"1850\":1}}],[\"做hash\",{\"1\":{\"1426\":1}}],[\"做hash使用\",{\"1\":{\"302\":1}}],[\"做以下分类\",{\"1\":{\"620\":1}}],[\"做一个sleep可以有很大概率拿到最新的数据\",{\"1\":{\"608\":1}}],[\"做全库逻辑备份\",{\"1\":{\"574\":1}}],[\"做了1000次带索引的查询\",{\"1\":{\"544\":1}}],[\"做自动类型转换的时候\",{\"1\":{\"505\":1}}],[\"做完上面这些\",{\"1\":{\"482\":1}}],[\"做完了这些识别以后\",{\"1\":{\"457\":1}}],[\"列表\",{\"0\":{\"708\":1},\"1\":{\"705\":1}}],[\"列id\",{\"1\":{\"457\":1}}],[\"列举一些spring当中用到的设计模式\",{\"0\":{\"271\":1}}],[\"列举一些jdk中用到的设计模式\",{\"0\":{\"270\":1}}],[\"识别成\",{\"1\":{\"457\":1}}],[\"识别成表名\",{\"1\":{\"457\":1}}],[\"识别出sql语句中的字符串分别是什么\",{\"1\":{\"457\":1}}],[\"代理对象在执行某个方法时\",{\"1\":{\"1532\":1}}],[\"代理模式\",{\"0\":{\"910\":1,\"1005\":1}}],[\"代表通信接口\",{\"1\":{\"1561\":1}}],[\"代表了每个红色widget的重量\",{\"1\":{\"1496\":1}}],[\"代表类的构造方法\",{\"1\":{\"1437\":1}}],[\"代表类的方法\",{\"1\":{\"1437\":1}}],[\"代表一个类\",{\"1\":{\"1437\":1}}],[\"代表它几乎没有界限\",{\"1\":{\"1380\":1}}],[\"代表组件有哪些\",{\"0\":{\"941\":1}}],[\"代表使用默认值\",{\"1\":{\"605\":1}}],[\"代表什么\",{\"1\":{\"457\":1}}],[\"代替关联查询\",{\"1\":{\"531\":1}}],[\"代码的可读性较差\",{\"1\":{\"1531\":1}}],[\"代码还相当冗余的\",{\"1\":{\"1488\":1}}],[\"代码变的异常简洁和优雅\",{\"1\":{\"1484\":1}}],[\"代码如下\",{\"1\":{\"1450\":1}}],[\"代码语法错误\",{\"1\":{\"717\":1}}],[\"代码线上\",{\"1\":{\"658\":1}}],[\"代码上线前\",{\"1\":{\"621\":1}}],[\"代码\",{\"1\":{\"429\":1}}],[\"代码模块\",{\"1\":{\"310\":1}}],[\"代码模板\",{\"0\":{\"285\":1,\"288\":1,\"291\":1,\"296\":1,\"299\":1,\"302\":1,\"305\":1,\"308\":1,\"311\":1,\"326\":1,\"338\":1}}],[\"代码随想录\",{\"1\":{\"6\":1,\"1850\":1}}],[\"那要不要跳过了\",{\"1\":{\"1861\":1}}],[\"那学习这部分会更快\",{\"1\":{\"1847\":1}}],[\"那必须先执行相应的类加载过程\",{\"1\":{\"1543\":1}}],[\"那使用并行就并没有带来多少的好处\",{\"1\":{\"1497\":1}}],[\"那最终的结果一定也是a类型\",{\"1\":{\"1492\":1}}],[\"那是不是所有的场景下\",{\"1\":{\"1489\":1}}],[\"那如何判断一个操作是中间操作还是终止操作呢\",{\"1\":{\"1488\":1}}],[\"那如果我们想分组的时候也统计分数的平均值\",{\"1\":{\"1490\":1}}],[\"那如果我们使用函数式的编程方式呢\",{\"1\":{\"1490\":1}}],[\"那如果既想求出最大值\",{\"1\":{\"1487\":1}}],[\"那如果要实现这个需求改怎么做呢\",{\"1\":{\"1486\":1}}],[\"那如果要包含最大值改怎么做呢\",{\"1\":{\"1484\":1}}],[\"那对于stream内部迭代的方式呢\",{\"1\":{\"1488\":1}}],[\"那对于想从jdk7升级到jdk8的人无疑是一场灾难\",{\"1\":{\"1484\":1}}],[\"那什么是外部迭代\",{\"1\":{\"1488\":1}}],[\"那stream是如何转变成我们常用的list集合呢\",{\"1\":{\"1485\":1}}],[\"那意味你需要重写所有的子类\",{\"1\":{\"1484\":1}}],[\"那意味着该列中没有重复的值\",{\"1\":{\"690\":1}}],[\"那只能限流生产者\",{\"1\":{\"1413\":1}}],[\"那说明一天之内肯定能处理完\",{\"1\":{\"1413\":1}}],[\"那还在对象头中还必须有一块数据用于记录数组长度\",{\"1\":{\"1361\":1}}],[\"那我多增设几台redis\",{\"1\":{\"770\":1}}],[\"那我们就只能用单表查询\",{\"1\":{\"538\":1}}],[\"那默认采用系统变量innodb\",{\"1\":{\"696\":1}}],[\"那就算当前已经偏向了其他线程\",{\"1\":{\"1362\":1}}],[\"那就是容量的大小\",{\"1\":{\"1378\":1}}],[\"那就是线程要读数据\",{\"1\":{\"740\":1}}],[\"那就是驱动表中有多少记录\",{\"1\":{\"691\":1}}],[\"那就不会对该连接顺序继续往下分析了\",{\"1\":{\"693\":1}}],[\"那就继续递归\",{\"1\":{\"686\":1}}],[\"那就可以精确统计出and\",{\"1\":{\"686\":1}}],[\"那就必须等待这个参数变为0才能执行查询请求\",{\"1\":{\"609\":1}}],[\"那些要用来计算的数字不要用varchar类型保存\",{\"1\":{\"667\":1}}],[\"那些情况不要建索引\",{\"0\":{\"496\":1}}],[\"那它就有上限\",{\"1\":{\"630\":1}}],[\"那为什么还会增加默认方法的机制呢\",{\"1\":{\"1484\":1}}],[\"那为什么执行show\",{\"1\":{\"618\":1}}],[\"那为什么innodb不跟myisam一样\",{\"1\":{\"533\":1}}],[\"那查询的压力都会跑到主库上\",{\"1\":{\"610\":1}}],[\"那也起不到并行的效果\",{\"1\":{\"600\":1}}],[\"那主备的数据不就不一致了吗\",{\"1\":{\"591\":1}}],[\"那怎么才能一次性地多穿些值给表t2呢\",{\"1\":{\"542\":1}}],[\"那直接更新内存会更快\",{\"1\":{\"480\":1}}],[\"那这个线程什么时候会退出呢\",{\"1\":{\"618\":1}}],[\"那这个联合索引就有意义了\",{\"1\":{\"475\":1}}],[\"那这张表上的查询才适合使用查询缓存\",{\"1\":{\"456\":1}}],[\"那应该用身份证号做主键\",{\"1\":{\"472\":1}}],[\"那么看是否需要进行对构造方法进行参数的依赖注入\",{\"1\":{\"1527\":1}}],[\"那么则构造一个代理对象并返回\",{\"1\":{\"1525\":1}}],[\"那么扫描的类是非常多的\",{\"1\":{\"1523\":1}}],[\"那么扫描行树为100\",{\"1\":{\"662\":1}}],[\"那么user这个属性就会按照stringtouserpropertyeditor中定义好的规则来进行属性赋值\",{\"1\":{\"1515\":1}}],[\"那么再根据名称查找\",{\"1\":{\"1507\":1}}],[\"那么再为这个语句在表t2的字段b上创建一个索引就很浪费了\",{\"1\":{\"544\":1}}],[\"那么实现的时候\",{\"1\":{\"1500\":1}}],[\"那么源在发送数据之前就可以根据判断是否要向sink发送数据\",{\"1\":{\"1500\":1}}],[\"那么使用流的方式效率还是比传统的方式要高的\",{\"1\":{\"1499\":1}}],[\"那么使用覆盖索引来编写sql\",{\"1\":{\"512\":1}}],[\"那么返回用于排序的比较器\",{\"1\":{\"1497\":1}}],[\"那么他就会根据树的深度返回2的指数次方\",{\"1\":{\"1497\":1}}],[\"那么他将会丢失所有在短线期间发布者发布的消息\",{\"1\":{\"737\":1}}],[\"那么estimate返回的就一定是一个精确的值\",{\"1\":{\"1497\":1}}],[\"那么最终也会被包装为一个sqlsessiontemplate对象\",{\"1\":{\"1530\":1}}],[\"那么最终的结果应该是个空字符串\",{\"1\":{\"386\":1}}],[\"那么最好这种传递是发生在任何元素在使用tryadvance方法消费之前完成\",{\"1\":{\"1497\":1}}],[\"那么遍历的时候就必须遵循遍历时候的顺序\",{\"1\":{\"1497\":1}}],[\"那么除了ized和subsized其他的特性值并不会简化客户端的计算\",{\"1\":{\"1497\":1}}],[\"那么抛出的第一个异常就会被抛给close方法的调用者\",{\"1\":{\"1496\":1}}],[\"那么iterator\",{\"1\":{\"1496\":1}}],[\"那么innodb会默认创建一个不可见的\",{\"1\":{\"632\":1}}],[\"那么innodb会自己生成一个长度为6字节的rowid来作为主键\",{\"1\":{\"557\":1}}],[\"那么combiner就会得到调用\",{\"1\":{\"1494\":1}}],[\"那么combiner就不会被调用\",{\"1\":{\"1494\":1}}],[\"那么多个线程就会操作操作同一个中间结果容器\",{\"1\":{\"1494\":1}}],[\"那么会返回正数\",{\"1\":{\"1480\":1}}],[\"那么会根据索引a找到第一个满足条件的行\",{\"1\":{\"591\":1}}],[\"那么后面的比较器就不会再调用\",{\"1\":{\"1491\":1}}],[\"那么后面的将不再会被计算\",{\"1\":{\"1476\":1}}],[\"那么后者也不会被计算\",{\"1\":{\"1476\":1}}],[\"那么动作就会按照迭代的顺序去执行\",{\"1\":{\"1472\":1}}],[\"那么编译器就会按照函数式接口的定义来要求该接口\",{\"1\":{\"1471\":1}}],[\"那么到底什么是函数式接口呢\",{\"1\":{\"1471\":1}}],[\"那么整个进程会被block\",{\"1\":{\"1442\":1}}],[\"那么它就需要提供完整的同步机制\",{\"1\":{\"1499\":1}}],[\"那么它就会报告sized的特性值\",{\"1\":{\"1497\":1}}],[\"那么它就再也不会被使用了\",{\"1\":{\"1492\":1}}],[\"那么它马上就将数据拷贝到了用户内存\",{\"1\":{\"1441\":1}}],[\"那么它并不会block用户进程\",{\"1\":{\"1441\":1}}],[\"那么它由一系列子任务组成\",{\"1\":{\"518\":1}}],[\"那么牧童的手的指向也就不同\",{\"1\":{\"1438\":1}}],[\"那么将\",{\"1\":{\"1431\":1}}],[\"那么将create\",{\"1\":{\"605\":1}}],[\"那么n\",{\"1\":{\"1427\":1}}],[\"那么table\",{\"1\":{\"1425\":1}}],[\"那么t1时刻\",{\"1\":{\"561\":1}}],[\"那么程序调用方法所计算得到的hash码值总是相同的\",{\"1\":{\"1425\":1}}],[\"那么本线程就无需再做了\",{\"1\":{\"1408\":1}}],[\"那么fork\",{\"1\":{\"1404\":1}}],[\"那么即便获取电商s2报价的耗时很短\",{\"1\":{\"1394\":1}}],[\"那么即使满足了条件\",{\"1\":{\"481\":1}}],[\"那么另外的线程边可以利用cpu去执行其他的任务\",{\"1\":{\"1387\":1}}],[\"那么生产者不需要关心具体的转账逻辑\",{\"1\":{\"1378\":1}}],[\"那么认为这次自旋成功的可能性高\",{\"1\":{\"1362\":1}}],[\"那么效率会比linkedlist高\",{\"1\":{\"1352\":1}}],[\"那么必须保证这个脚本存在于这个路径\",{\"1\":{\"761\":1}}],[\"那么意味着连接暂时处于空闲状态\",{\"1\":{\"742\":1}}],[\"那么久重新连接\",{\"1\":{\"748\":1}}],[\"那么久最多等待timeout时间\",{\"1\":{\"740\":1}}],[\"那么久可以加上\",{\"1\":{\"619\":1}}],[\"那么redis是如何使用单线程处理那么多的并发客户端连接的\",{\"1\":{\"738\":1}}],[\"那么redo\",{\"1\":{\"588\":1}}],[\"那么不断积压的消息会使redis输出缓冲区的体积变得越来越大\",{\"1\":{\"737\":1}}],[\"那么不符合最左前缀的部分\",{\"1\":{\"477\":1}}],[\"那么你可以只使用\",{\"1\":{\"733\":1}}],[\"那么服务器将丢失最近写入\",{\"1\":{\"729\":1}}],[\"那么服务器会重新进行一次统计数据的计算\",{\"1\":{\"696\":1}}],[\"那么优化器需要从全表扫描\",{\"1\":{\"692\":1}}],[\"那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条\",{\"1\":{\"691\":1}}],[\"那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条\",{\"1\":{\"691\":1}}],[\"那么计算group\",{\"1\":{\"554\":1}}],[\"那么扇出值就是多少\",{\"1\":{\"691\":1}}],[\"那么我们要计算区间最左记录和最右记录之间的页面数量就相当于计算页b和页c之间有多少页面\",{\"1\":{\"686\":1}}],[\"那么我们如果删除这个索引\",{\"1\":{\"498\":1}}],[\"那么产生的间隙就有id为\",{\"1\":{\"673\":1}}],[\"那么从理论上讲\",{\"1\":{\"634\":1}}],[\"那么mysql还会同时把query\",{\"1\":{\"633\":1}}],[\"那么mysql会自动释放这个全局锁\",{\"1\":{\"575\":1}}],[\"那么一定可以使用hyperloglog\",{\"1\":{\"714\":1}}],[\"那么一定不存在\",{\"1\":{\"307\":1}}],[\"那么一种直接的想法就是需要一个时申请一个\",{\"1\":{\"629\":1}}],[\"那么先记session\",{\"1\":{\"629\":1}}],[\"那么当我们使用哈希算法求得这个位置的时候\",{\"1\":{\"1425\":1}}],[\"那么当一部分线程正在等待io的时候\",{\"1\":{\"1387\":1}}],[\"那么当前线程无法感知线程t的数据更新\",{\"1\":{\"1375\":1}}],[\"那么当前结点的左子结点设置为当前结点\",{\"1\":{\"345\":1}}],[\"那么当出现唯一键冲突和事务回滚的时候\",{\"1\":{\"628\":1}}],[\"那么只需要执行set\",{\"1\":{\"622\":1}}],[\"那么备库也要进行更新检测\",{\"1\":{\"615\":1}}],[\"那么备份只能通过ftwrl方法\",{\"1\":{\"575\":1}}],[\"那么所有的更新语句和事务提交的commit语句就都会被堵住\",{\"1\":{\"614\":1}}],[\"那么1秒内master\",{\"1\":{\"610\":1}}],[\"那么上面的两个位点等值判断就会一直不成立\",{\"1\":{\"609\":1}}],[\"那么切换之后gtid集合的格式就变成了source\",{\"1\":{\"605\":1}}],[\"那么时候应该使用可用性优化策略呢\",{\"1\":{\"596\":1}}],[\"那么时间复杂度会变成o\",{\"1\":{\"339\":1}}],[\"那么系统几乎没有不可用时间了\",{\"1\":{\"596\":1}}],[\"那么删除的就是t\",{\"1\":{\"591\":1}}],[\"那么按照这个参数的逻辑\",{\"1\":{\"588\":1}}],[\"那么事务很有可能就会导致从库延迟10分钟\",{\"1\":{\"594\":1}}],[\"那么事务还没有提交的时候\",{\"1\":{\"588\":1}}],[\"那么事务隔离是怎么实现的呢\",{\"1\":{\"571\":1}}],[\"那么为什么我们将所有的记录都已经上了锁\",{\"1\":{\"584\":1}}],[\"那么死锁检测操作的时间复杂度就是百万量级的\",{\"1\":{\"581\":1}}],[\"那么查询线程拿到的结果就与表结构对应不上了\",{\"1\":{\"578\":1}}],[\"那么查询语句\",{\"1\":{\"490\":1}}],[\"那么手动分表和分区表有什么区别\",{\"1\":{\"561\":1}}],[\"那么sourcespliterator必须为空\",{\"1\":{\"1498\":1}}],[\"那么sourcesupplier必须是null\",{\"1\":{\"1498\":1}}],[\"那么sort\",{\"1\":{\"492\":1}}],[\"那么session\",{\"1\":{\"561\":1}}],[\"那么分区表有什么问题呢\",{\"1\":{\"560\":1}}],[\"那么取到id=4的这一行的概率是取到其它行的概率的两倍\",{\"1\":{\"559\":1}}],[\"那么内存临时表就会转成磁盘临时表\",{\"1\":{\"558\":1}}],[\"那么是不是所有的临时表都是内存表呢\",{\"1\":{\"558\":1}}],[\"那么group\",{\"1\":{\"554\":1}}],[\"那么binlog中就只能记录\",{\"1\":{\"550\":1}}],[\"那么与临时表有关的语句\",{\"1\":{\"550\":1}}],[\"那么在不超过\",{\"1\":{\"1541\":1}}],[\"那么在遍历的时候就会独立于流中输入的顺序\",{\"1\":{\"1500\":1}}],[\"那么在分割之前spliterator的estimatesize的值必须等于分割之后所剩下的estimatesize以及剩下的spliteratord的estimatesize加起来必须相等\",{\"1\":{\"1497\":1}}],[\"那么在计算为了说明h\",{\"1\":{\"1425\":1}}],[\"那么在future也没有办法做到\",{\"1\":{\"1393\":1}}],[\"那么在实例b上执行start\",{\"1\":{\"605\":1}}],[\"那么在备库应用的时候\",{\"1\":{\"601\":1}}],[\"那么在备库就只有create\",{\"1\":{\"550\":1}}],[\"那么在这个算法里\",{\"1\":{\"540\":1}}],[\"那么在这种情况下\",{\"1\":{\"540\":1}}],[\"那么在连接的时候\",{\"1\":{\"505\":1}}],[\"那么显然结果是false\",{\"1\":{\"1476\":1}}],[\"那么显然可能会出现冲突\",{\"1\":{\"550\":1}}],[\"那么显然\",{\"1\":{\"538\":1,\"540\":1,\"1472\":1}}],[\"那么执行过程是先往join\",{\"1\":{\"662\":1}}],[\"那么执行的时候\",{\"1\":{\"536\":1}}],[\"那么执行器的执行流程如下\",{\"1\":{\"459\":1}}],[\"那么基于该表的查询就可以重复利用查询缓存结果了\",{\"1\":{\"531\":1}}],[\"那么第三个查询的in\",{\"1\":{\"531\":1}}],[\"那么应用就可以跳过第一个查询\",{\"1\":{\"531\":1}}],[\"那么应该关闭change\",{\"1\":{\"481\":1}}],[\"那么通常可以尝试下面的技巧进行优化\",{\"1\":{\"527\":1}}],[\"那么解决的最好办法通常就是增加一个合适的索引\",{\"1\":{\"527\":1}}],[\"那么用户多次评论的时候\",{\"1\":{\"523\":1}}],[\"那么如果出现同一行热点更新的问题时\",{\"1\":{\"613\":1}}],[\"那么如果有一个页面经常要显示交易系统的操作记录总数\",{\"1\":{\"533\":1}}],[\"那么如果进行优化\",{\"1\":{\"499\":1}}],[\"那么如何给字符串添加合适的索引呢\",{\"1\":{\"486\":1}}],[\"那么对象的部分\",{\"1\":{\"1365\":1}}],[\"那么对于spliterator的任何计算都是不受保障\",{\"1\":{\"1497\":1}}],[\"那么对于这个lambda表达式而言\",{\"1\":{\"1472\":1}}],[\"那么对于这个对象的操作可以不考虑同步\",{\"1\":{\"1365\":1}}],[\"那么对于每个唯一索引\",{\"1\":{\"602\":1}}],[\"那么对a字段建索引一般不会提高数据库的查询速度\",{\"1\":{\"496\":1}}],[\"那么对应的状态转移方程\",{\"1\":{\"428\":1}}],[\"那么索引就会包含整个字符串\",{\"1\":{\"487\":1}}],[\"那么业务代码中一定会出现类似这样的语句\",{\"1\":{\"486\":1}}],[\"那么普通索引的所有场景\",{\"1\":{\"481\":1}}],[\"那么要取下一个记录\",{\"1\":{\"479\":1}}],[\"那么这时\",{\"1\":{\"761\":1}}],[\"那么这俩也不会例外\",{\"1\":{\"720\":1}}],[\"那么这部分日志就丢失了\",{\"1\":{\"588\":1}}],[\"那么这两个事务冲突的部分就是语句2了\",{\"1\":{\"580\":1}}],[\"那么这两个选择逻辑上都是正确的\",{\"1\":{\"478\":1}}],[\"那么这是怎么做到的呢\",{\"1\":{\"549\":1}}],[\"那么这个方法应该当被重写\",{\"1\":{\"1497\":1}}],[\"那么这个函数就会直接将a转型为r\",{\"1\":{\"1492\":1}}],[\"那么这个接口就被称为函数式接口\",{\"1\":{\"1471\":1}}],[\"那么这个接口就是函数式接口\",{\"1\":{\"1471\":1}}],[\"那么这个时候表t的自增值是4\",{\"1\":{\"628\":1}}],[\"那么这个表的自增值不变\",{\"1\":{\"628\":1}}],[\"那么这个mdl读锁就没有机会释放了\",{\"1\":{\"618\":1}}],[\"那么这个请求需要拿到最新的结果\",{\"1\":{\"607\":1}}],[\"那么这个事务t的分配流程如下\",{\"1\":{\"598\":1}}],[\"那么这个索引的选择性就是1980\",{\"1\":{\"496\":1}}],[\"那么这个语句就只能全表扫描\",{\"1\":{\"487\":1}}],[\"那么这个value就会被直接返回给客户端\",{\"1\":{\"456\":1}}],[\"那么建议创建一个\",{\"1\":{\"476\":1}}],[\"那么就无法再保证执行给定的lambda表达式的元素的顺序了\",{\"1\":{\"1499\":1}}],[\"那么就无法使用查询缓存了\",{\"1\":{\"531\":1}}],[\"那么就意味着我们可以使用lambda表达式的方式来创建myinterface的实例\",{\"1\":{\"1472\":1}}],[\"那么就不能选择arrrayblockingqueue\",{\"1\":{\"1386\":1}}],[\"那么就一定还存在一个redisproperties类\",{\"1\":{\"720\":1}}],[\"那么就继续穷举分析每一种连接顺序的成本\",{\"1\":{\"693\":1}}],[\"那么就把这个表当前的auto\",{\"1\":{\"628\":1}}],[\"那么就有两种可能\",{\"1\":{\"605\":1}}],[\"那么就是一个事务对应一次持久化操作了\",{\"1\":{\"588\":1}}],[\"那么就可以控制死锁检测的时间复杂度\",{\"1\":{\"581\":1}}],[\"那么就破坏了备份的一致性\",{\"1\":{\"575\":1}}],[\"那么就只能访问所有分区了\",{\"1\":{\"562\":1}}],[\"那么就会把这个类解析为一个beandefition\",{\"1\":{\"1512\":1}}],[\"那么就会被强转为intconsumer并传递给tryadvance\",{\"1\":{\"1497\":1}}],[\"那么就会报告sorted\",{\"1\":{\"1497\":1}}],[\"那么就会报告distinct\",{\"1\":{\"1497\":1}}],[\"那么就会操作不同的中间结果容器\",{\"1\":{\"1494\":1}}],[\"那么就会导致线程不能够正常终止\",{\"1\":{\"1401\":1}}],[\"那么就会使用所匹配的构造方法\",{\"1\":{\"1527\":1}}],[\"那么就会使用双路排序模式\",{\"1\":{\"657\":1}}],[\"那么就会使用单路排序模式\",{\"1\":{\"657\":1}}],[\"那么就会出现这样的情况\",{\"1\":{\"628\":1}}],[\"那么就会出现随机访问\",{\"1\":{\"541\":1}}],[\"那么就会落在p\",{\"1\":{\"562\":1}}],[\"那么就会在访问这个表的时候\",{\"1\":{\"562\":1}}],[\"那么就要确保从a类型到r类型的强制转换是可以成功的\",{\"1\":{\"1494\":1}}],[\"那么就要用f做分区键\",{\"1\":{\"548\":1}}],[\"那么就要优先考虑建立这样顺序的索引\",{\"1\":{\"476\":1}}],[\"那么就表示不能再执行新的更新操作了\",{\"1\":{\"461\":1}}],[\"那么每个二级索引的叶子节点占用约20个字节\",{\"1\":{\"472\":1}}],[\"那么访问磁盘的平均次数就更少了\",{\"1\":{\"471\":1}}],[\"那么\",{\"1\":{\"471\":1,\"474\":1,\"476\":1,\"477\":1,\"479\":1,\"480\":1,\"554\":1,\"581\":1,\"591\":1,\"592\":1,\"596\":1,\"604\":1,\"605\":1,\"607\":1,\"619\":1,\"628\":1,\"634\":1}}],[\"那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致\",{\"1\":{\"464\":1}}],[\"那么可以在使用mysqlbinlog命令时\",{\"1\":{\"622\":1}}],[\"那么可以在sql语句末尾增加order\",{\"1\":{\"553\":1}}],[\"那么可以采用可用性优先的策略\",{\"1\":{\"595\":1}}],[\"那么可以使用commit\",{\"1\":{\"572\":1}}],[\"那么可以用类似下面的方法来完成相同的工作\",{\"1\":{\"530\":1}}],[\"那么可以修改sql语句\",{\"1\":{\"505\":1}}],[\"那么可以给id\",{\"1\":{\"478\":1}}],[\"那么可以\",{\"1\":{\"464\":1}}],[\"那么总共就可以记录4gb的操作\",{\"1\":{\"461\":1}}],[\"那么偷k个房子有两种偷法\",{\"1\":{\"431\":1}}],[\"那么插入位置所在的子树黑色结点总是多1\",{\"1\":{\"345\":1}}],[\"那么插入结点作为根节点\",{\"1\":{\"345\":1}}],[\"那么把根结点作为当前结点\",{\"1\":{\"345\":1}}],[\"那么该函数就叫做高阶函数\",{\"1\":{\"1475\":1}}],[\"那么该接口就是一个函数式接口\",{\"1\":{\"1471\":1}}],[\"那么该线程也去帮扩容\",{\"1\":{\"1431\":1}}],[\"那么该脚本稍后将会被再次执行\",{\"1\":{\"761\":1}}],[\"那么该如何优化呢\",{\"1\":{\"556\":1,\"559\":1}}],[\"那么该key所在结点就是插入结点\",{\"1\":{\"345\":1}}],[\"那么该key就是查找目标\",{\"1\":{\"344\":1}}],[\"那么该结点肯定有两个子结点\",{\"1\":{\"343\":1}}],[\"那么平衡二叉树的所有结点的平衡因子只可能是\",{\"1\":{\"341\":1}}],[\"那么有可能在\",{\"1\":{\"307\":1}}],[\"那么贪心法一般是解决这个的最好办法\",{\"1\":{\"293\":1}}],[\"被代理的对象通常称为target\",{\"1\":{\"1531\":1}}],[\"被代理的方法通常被称为join\",{\"1\":{\"1531\":1}}],[\"被代理的方法\",{\"1\":{\"1531\":1}}],[\"被链接或者被消费\",{\"1\":{\"1499\":1}}],[\"被注解的类型满足函数式接口的定义\",{\"1\":{\"1471\":1}}],[\"被注解的是一个接口类型\",{\"1\":{\"1471\":1}}],[\"被唤醒的线程再次执行时可能条件又不满足了\",{\"1\":{\"1360\":1}}],[\"被阻塞的线程会被挂起\",{\"1\":{\"1360\":1}}],[\"被\",{\"1\":{\"720\":1}}],[\"被放弃事务中命令并未执行\",{\"1\":{\"716\":1}}],[\"被session\",{\"1\":{\"583\":1}}],[\"被称为\",{\"1\":{\"583\":1}}],[\"被驱动表s2的扇出是16\",{\"1\":{\"692\":1}}],[\"被驱动表可能会被访问多次\",{\"1\":{\"691\":1}}],[\"被驱动表的连接列最好是该表的主键或者唯一二级索引列\",{\"1\":{\"692\":1}}],[\"被驱动表的关联字段没有索引为什么会选择bnl算法而不是用nlj呢\",{\"1\":{\"662\":1}}],[\"被驱动表的数据行数是m\",{\"1\":{\"540\":1}}],[\"被驱动表\",{\"1\":{\"661\":1}}],[\"被驱动表t2的字段上有索引\",{\"1\":{\"538\":1}}],[\"被驱动表tradelog上执行的就是类似这样的sql语句\",{\"1\":{\"505\":1}}],[\"被查看的次数\",{\"1\":{\"498\":1}}],[\"被直接缓存到内存中\",{\"1\":{\"456\":1}}],[\"被系统强行杀掉\",{\"1\":{\"455\":1}}],[\"定时消息存储\",{\"0\":{\"1805\":1}}],[\"定时消息\",{\"0\":{\"1804\":1}}],[\"定时消息和重试消息\",{\"0\":{\"1803\":1}}],[\"定位到哈希桶数组的都是很关键的第一步\",{\"1\":{\"1425\":1}}],[\"定位到满足条件的记录\",{\"1\":{\"541\":1}}],[\"定位哈希桶索引位置时\",{\"1\":{\"1423\":1}}],[\"定制redistemplate的模板\",{\"1\":{\"720\":1}}],[\"定长字符串\",{\"1\":{\"667\":1}}],[\"定期地清除大量数据时\",{\"1\":{\"530\":1}}],[\"定期断开长连接\",{\"1\":{\"455\":1}}],[\"定义额外逻辑\",{\"1\":{\"1531\":1}}],[\"定义好行为之后我们再去调用\",{\"1\":{\"1475\":1}}],[\"定义threadlocal变量\",{\"1\":{\"1405\":1}}],[\"定义了一个内部cell类\",{\"1\":{\"1357\":1}}],[\"定义atomicstampedreference\",{\"1\":{\"1356\":1}}],[\"定义长度也是8个字节\",{\"1\":{\"634\":1}}],[\"定义允许为null\",{\"1\":{\"536\":1}}],[\"定义合理的长度\",{\"1\":{\"487\":1}}],[\"定义和性质\",{\"0\":{\"343\":1}}],[\"定义\",{\"0\":{\"284\":1,\"287\":1,\"290\":1,\"293\":1,\"295\":1,\"298\":1,\"301\":1,\"304\":1,\"307\":1,\"310\":1,\"313\":1,\"325\":1}}],[\"长整型等\",{\"1\":{\"1500\":1}}],[\"长时间地不成功\",{\"1\":{\"1356\":1}}],[\"长文本数据\",{\"1\":{\"667\":1}}],[\"长字符串我们可以采用前缀索引\",{\"1\":{\"658\":1}}],[\"长事务意味着系统里面会存在很老的事务视图\",{\"1\":{\"571\":1}}],[\"长度开始时必须指定\",{\"1\":{\"1415\":1}}],[\"长度\",{\"1\":{\"1380\":1,\"1425\":1}}],[\"长度为10\",{\"1\":{\"1412\":1}}],[\"长度为8字节\",{\"1\":{\"1361\":1}}],[\"长度为6个字节的row\",{\"1\":{\"632\":1}}],[\"长度越短越好\",{\"1\":{\"467\":1}}],[\"长度最小的子数组\",{\"0\":{\"363\":1}}],[\"长连接是指连接成功后\",{\"1\":{\"455\":1}}],[\"长连接和短连接\",{\"1\":{\"455\":1}}],[\"之间的关系\",{\"1\":{\"733\":1}}],[\"之间的成员\",{\"1\":{\"711\":1}}],[\"之间的的成员\",{\"1\":{\"711\":1}}],[\"之所以设置了父子容器\",{\"1\":{\"1536\":1}}],[\"之所以需要第三个map才能解决循环依赖的根本原因是存在代理\",{\"1\":{\"1526\":1}}],[\"之所以需要这么设置\",{\"1\":{\"629\":1}}],[\"之所以会支持\",{\"1\":{\"1525\":1}}],[\"之所以会有这个差异\",{\"1\":{\"1499\":1}}],[\"之所以只缓存beanname\",{\"1\":{\"1525\":1}}],[\"之所以这么做的原因是\",{\"1\":{\"1495\":1}}],[\"之所以出现这个现象\",{\"1\":{\"615\":1}}],[\"之所以v2还是1\",{\"1\":{\"570\":1}}],[\"之所以要有计算10亿次的操作\",{\"1\":{\"545\":1}}],[\"之所以是12个文件\",{\"1\":{\"491\":1}}],[\"之所以叫做选择排序\",{\"1\":{\"318\":1}}],[\"之前我们是对于分组中的元素个数进行统计\",{\"1\":{\"1490\":1}}],[\"之前我们举的例子要么是将集合转化为stream\",{\"1\":{\"1486\":1}}],[\"之前我们说springboot2\",{\"1\":{\"720\":1}}],[\"之前也是a的备库\",{\"1\":{\"605\":1}}],[\"之前的例子中\",{\"1\":{\"555\":1}}],[\"之前优化器选择使用索引b\",{\"1\":{\"485\":1}}],[\"之前提交的记录都不会丢失\",{\"1\":{\"461\":1}}],[\"之前执行过的语句及其结果可能会以key\",{\"1\":{\"456\":1}}],[\"之前是不是执行过这条语句\",{\"1\":{\"456\":1}}],[\"之后进行aop的操作的时候\",{\"1\":{\"1526\":1}}],[\"之后所有的操作都只针对cell\",{\"1\":{\"1357\":1}}],[\"之后所有在表上新申请mdl读锁的请求也会被session\",{\"1\":{\"578\":1}}],[\"之后才开始执行\",{\"1\":{\"1350\":1}}],[\"之后才会调用存储引擎提供的接口真正的执行查询\",{\"1\":{\"683\":1}}],[\"之后重新执行\",{\"1\":{\"761\":1}}],[\"之后的版本中innodb\",{\"1\":{\"695\":1}}],[\"之后的版本默认值为200\",{\"1\":{\"690\":1}}],[\"之后的join语句\",{\"1\":{\"544\":1}}],[\"之后继续执行\",{\"1\":{\"628\":1}}],[\"之后继续找索引a的下个记录\",{\"1\":{\"541\":1}}],[\"之后按顺序执行binlog的时候\",{\"1\":{\"622\":1}}],[\"之后这个系统就由新主库a\",{\"1\":{\"605\":1}}],[\"之后就从这个事务开始\",{\"1\":{\"605\":1}}],[\"之后传给备库b\",{\"1\":{\"594\":1}}],[\"之后开发人员或者dba再通过重试命令重复这个过程\",{\"1\":{\"578\":1}}],[\"之后session\",{\"1\":{\"578\":1}}],[\"之后其它线程的更新\",{\"1\":{\"574\":1}}],[\"之后备份日志的时候\",{\"1\":{\"464\":1}}],[\"之后循环取\",{\"1\":{\"459\":1}}],[\"之后要查询再重连\",{\"1\":{\"455\":1}}],[\"之后\",{\"1\":{\"455\":1,\"629\":2,\"1362\":1}}],[\"你需要做的就是过遍数\",{\"1\":{\"1850\":1}}],[\"你就不应该再去调用accept方法\",{\"1\":{\"1500\":1}}],[\"你就会收到一个\",{\"1\":{\"455\":1}}],[\"你只需要\",{\"1\":{\"1495\":1}}],[\"你也可以按照代码随想录整理的路线刷题\",{\"1\":{\"1850\":1}}],[\"你也可以\",{\"1\":{\"1494\":1}}],[\"你还可以这么做\",{\"1\":{\"1491\":1}}],[\"你好\",{\"1\":{\"1486\":1}}],[\"你偏好构造器注入还是setter注入\",{\"0\":{\"1131\":1}}],[\"你应该同时使用两种持久化功能\",{\"1\":{\"733\":1}}],[\"你可以使用collectors中的静态方法\",{\"1\":{\"1492\":1}}],[\"你可以添加一个元素到列表的头部\",{\"1\":{\"708\":1}}],[\"你可能会说\",{\"1\":{\"1489\":1}}],[\"你可能会发现\",{\"1\":{\"455\":1}}],[\"你可能很疑惑\",{\"1\":{\"1470\":1}}],[\"你存了什么\",{\"1\":{\"666\":1}}],[\"你不会在show\",{\"1\":{\"635\":1}}],[\"你要做的就是在这个节点上把数据恢复回来\",{\"1\":{\"625\":1}}],[\"你的sql语句的条件是\",{\"1\":{\"476\":1}}],[\"你了解分代理论吗\",{\"0\":{\"108\":1}}],[\"用java实现一个jvm框架\",{\"0\":{\"1553\":1}}],[\"用以指向下一个可用的元素\",{\"1\":{\"1397\":1}}],[\"用future获取结果还好\",{\"1\":{\"1395\":1}}],[\"用flashback工具解析binlog后\",{\"1\":{\"621\":1}}],[\"用较简单的方法解决\",{\"1\":{\"1387\":1}}],[\"用while不用if是为了防止虚假唤醒\",{\"1\":{\"1379\":1}}],[\"用nextwaiter来连接\",{\"1\":{\"1369\":1}}],[\"用链表是来解决数组小表覆盖的问题\",{\"1\":{\"1352\":1}}],[\"用指定的value\",{\"1\":{\"707\":1}}],[\"用版本对比来实现\",{\"1\":{\"670\":1}}],[\"用select的优势在于它可以同时处理多个connection\",{\"1\":{\"1442\":1}}],[\"用spring开发程序时\",{\"1\":{\"669\":1}}],[\"用statement格式的binlog来串行执行\",{\"1\":{\"629\":1}}],[\"用statement的话就是一个sql语句被记录到binlog中\",{\"1\":{\"591\":1}}],[\"用id关联\",{\"1\":{\"667\":1}}],[\"用incr或decr命令\",{\"1\":{\"663\":1}}],[\"用mysql的内建类型date\",{\"1\":{\"666\":1}}],[\"用mysqlbinlog解析出日志应用\",{\"1\":{\"622\":1}}],[\"用mysqlbinlog工具解析a\",{\"1\":{\"604\":1}}],[\"用mysqlbinlog工具解析出来\",{\"1\":{\"591\":1}}],[\"用途举例\",{\"1\":{\"707\":1}}],[\"用途\",{\"1\":{\"665\":1,\"666\":1,\"667\":1}}],[\"用bnl磁盘扫描次数少很多\",{\"1\":{\"662\":1}}],[\"用begin显式启动事务\",{\"1\":{\"572\":1}}],[\"用备份恢复出一个临时库\",{\"1\":{\"622\":1}}],[\"用ajax直接把客户端输入的内容作为\",{\"1\":{\"608\":1}}],[\"用的规则就不是\",{\"1\":{\"599\":1}}],[\"用的是索引a\",{\"1\":{\"591\":1}}],[\"用于传递消息\",{\"1\":{\"1863\":1}}],[\"用于关闭整个容器\",{\"1\":{\"1563\":1}}],[\"用于缓存aop对象\",{\"1\":{\"1526\":1}}],[\"用于创建sink的一个链\",{\"1\":{\"1500\":1}}],[\"用于创建执行任务的线程\",{\"1\":{\"1397\":1}}],[\"用于在整个流管道阶段处理值\",{\"1\":{\"1500\":1}}],[\"用于描述中间的管道阶段和管道源阶段的的类\",{\"1\":{\"1498\":1}}],[\"用于呈现流的数据视图\",{\"1\":{\"1498\":1}}],[\"用于完成字符串的拼接操作\",{\"1\":{\"1495\":1}}],[\"用于判断是否有序\",{\"1\":{\"1494\":1}}],[\"用于判断中间结果容器与最终返回的类型是否相同\",{\"1\":{\"1494\":1}}],[\"用于将一个额外的元素合并到结果容器当中\",{\"1\":{\"1485\":1}}],[\"用于表述指向文件的引用的抽象化概念\",{\"1\":{\"1438\":1}}],[\"用于表示当前备库延迟了多少秒\",{\"1\":{\"594\":1}}],[\"用于表示事务被正确地提交了\",{\"1\":{\"591\":1}}],[\"用于保存future对象\",{\"1\":{\"1394\":1}}],[\"用于保存已经执行完成的future\",{\"1\":{\"1394\":1}}],[\"用于保存当前正在这个worker的\",{\"1\":{\"598\":1}}],[\"用于区别使用非forkjoinworkthread线程提交task\",{\"1\":{\"1390\":1}}],[\"用于区分不同表的操作\",{\"1\":{\"591\":1}}],[\"用于控制线程池的并行数\",{\"1\":{\"1387\":1}}],[\"用于存储对象自身的运行时数据\",{\"1\":{\"1361\":1}}],[\"用于屏蔽掉各种硬件和操作系统内存访问差异\",{\"1\":{\"1350\":1}}],[\"用于高速缓冲\",{\"1\":{\"702\":1}}],[\"用于记录主库上写入的时间\",{\"1\":{\"594\":1}}],[\"用完再删除\",{\"1\":{\"568\":1}}],[\"用随机函数生成一个最大值和最小值之间的数x=\",{\"1\":{\"559\":1}}],[\"用到c1这一个字段\",{\"1\":{\"515\":1}}],[\"用到c1\",{\"1\":{\"515\":1}}],[\"用到索引c1\",{\"1\":{\"515\":5}}],[\"用到了c1\",{\"1\":{\"515\":3}}],[\"用到了c1一个字段\",{\"1\":{\"515\":1}}],[\"用到了索引c1\",{\"1\":{\"515\":4}}],[\"用到了覆盖索引\",{\"1\":{\"510\":1}}],[\"用到了idx\",{\"1\":{\"507\":4,\"509\":2}}],[\"用到了主键索引\",{\"1\":{\"467\":1}}],[\"用什么字段就查询什么字段\",{\"1\":{\"510\":1}}],[\"用它来连接时会索引失效\",{\"1\":{\"506\":1}}],[\"用来简化web应用程序开发的框架\",{\"1\":{\"1860\":1}}],[\"用来加载自定义路径下的类\",{\"1\":{\"1569\":1}}],[\"用来扫描mapper\",{\"1\":{\"1530\":1}}],[\"用来获取原始对象\",{\"1\":{\"1526\":1}}],[\"用来获取方法入参名称\",{\"1\":{\"1525\":1}}],[\"用来记录回到调用的地方继续执行程序的地方\",{\"1\":{\"1541\":1}}],[\"用来记录时间\",{\"1\":{\"1524\":1}}],[\"用来记录交易的操作细节\",{\"1\":{\"505\":1}}],[\"用来创建终止操作的实例\",{\"1\":{\"1500\":1}}],[\"用来完成向一个可变结果容器当中添加元素的\",{\"1\":{\"1492\":1}}],[\"用来避免自动拆箱装箱带来的性能的损耗\",{\"1\":{\"1484\":1}}],[\"用来根据objects类中的equals\",{\"1\":{\"1476\":1}}],[\"用来定位数组索引位置\",{\"1\":{\"1423\":1}}],[\"用来连接两个有依赖关系的任务\",{\"1\":{\"1395\":1}}],[\"用来决定槽数组的大小\",{\"1\":{\"1357\":1}}],[\"用来通知线程有一些事件已发生\",{\"1\":{\"1354\":1}}],[\"用来指定误删表所在的库\",{\"1\":{\"622\":1}}],[\"用来表示最后一次执行检测的时间\",{\"1\":{\"615\":1}}],[\"用来对应\",{\"1\":{\"605\":1}}],[\"用来对应redo\",{\"1\":{\"588\":1}}],[\"用来控制是否启动这个新策略\",{\"1\":{\"602\":1}}],[\"用来保证变更表结构操作的安全性\",{\"1\":{\"578\":1}}],[\"用来实现列数据的关联更新\",{\"1\":{\"554\":1}}],[\"用来存放数据文件\",{\"1\":{\"549\":1}}],[\"用来跟服务端建立连接\",{\"1\":{\"455\":1}}],[\"用户应用程序调用read方法\",{\"1\":{\"1457\":1}}],[\"用户空间的虚拟内存也会随之释放\",{\"1\":{\"1456\":1}}],[\"用户进程发起read操作之后\",{\"1\":{\"1443\":1}}],[\"用户进程判断结果是一个error时\",{\"1\":{\"1441\":1}}],[\"用户进程才解除block的状态\",{\"1\":{\"1440\":1}}],[\"用户态\",{\"1\":{\"1360\":1}}],[\"用户请求数据时\",{\"1\":{\"763\":1}}],[\"用户校验\",{\"1\":{\"619\":1}}],[\"用户名和密码\",{\"1\":{\"604\":1}}],[\"用户名\",{\"1\":{\"590\":1}}],[\"用户名等\",{\"1\":{\"486\":1}}],[\"用户每次访问首页的时候\",{\"1\":{\"556\":1}}],[\"用户表是这么定义的\",{\"1\":{\"486\":1}}],[\"用二分法就可以快速得到\",{\"1\":{\"470\":1}}],[\"用当前结点的key跟查找key作比较\",{\"1\":{\"344\":1}}],[\"连接\",{\"1\":{\"1852\":1}}],[\"连接点\",{\"1\":{\"1531\":1}}],[\"连接消耗大\",{\"1\":{\"806\":1}}],[\"连接主从的密码\",{\"1\":{\"761\":1}}],[\"连接工厂\",{\"1\":{\"720\":1}}],[\"连接右\",{\"1\":{\"692\":1}}],[\"连接查询成本占大头的其实是驱动表扇出数\",{\"1\":{\"692\":1}}],[\"连接查询来说\",{\"1\":{\"692\":1}}],[\"连接查询总成本\",{\"1\":{\"692\":1}}],[\"连接查询的总成本也就越低\",{\"1\":{\"691\":1}}],[\"连接查询的成本输出\",{\"1\":{\"692\":1}}],[\"连接查询的成本计算公式\",{\"1\":{\"692\":1}}],[\"连接查询的成本\",{\"0\":{\"691\":1}}],[\"连接起来就会很快\",{\"1\":{\"619\":1}}],[\"连接就会很慢\",{\"1\":{\"619\":1}}],[\"连接维护\",{\"1\":{\"606\":1}}],[\"连接建立完成后\",{\"1\":{\"456\":1}}],[\"连接可以分为两种\",{\"1\":{\"455\":1}}],[\"连接完成之后\",{\"1\":{\"455\":1}}],[\"连接命令中的mysql是客户端工具\",{\"1\":{\"455\":1}}],[\"连接命令通常如下\",{\"1\":{\"455\":1}}],[\"连接器通过适配器adapter调用容器\",{\"1\":{\"1566\":1}}],[\"连接器用protocolhandler接口来封装通信协议个i\",{\"1\":{\"1566\":1}}],[\"连接器用protocolhandler来处理网络连接和应用层协议\",{\"1\":{\"1566\":1}}],[\"连接器需要实现的功能\",{\"1\":{\"1565\":1}}],[\"连接器对servlet容器屏蔽了不同的应用层协议及i\",{\"1\":{\"1565\":1}}],[\"连接器connector组件\",{\"0\":{\"1565\":1}}],[\"连接器负责对外交流\",{\"1\":{\"1561\":1}}],[\"连接器负责跟客户端建立连接\",{\"1\":{\"455\":1}}],[\"连接器组件\",{\"1\":{\"1561\":1}}],[\"连接器就会自动将他断开\",{\"1\":{\"455\":1}}],[\"连接器就要开始认证你的身份\",{\"1\":{\"455\":1}}],[\"连接器会到权限表里面查出你拥有的权限\",{\"1\":{\"455\":1}}],[\"连接器\",{\"0\":{\"455\":1,\"649\":1}}],[\"梳理它执行的完整的流程\",{\"1\":{\"454\":1}}],[\"接着要考虑的就是能否扩容\",{\"1\":{\"1386\":1}}],[\"接入点接口joinpoint\",{\"0\":{\"944\":1}}],[\"接口\",{\"1\":{\"1847\":1}}],[\"接口中有同名的默认方法\",{\"1\":{\"1484\":1}}],[\"接口中的抽象方法是accept\",{\"1\":{\"1474\":1}}],[\"接口回调阶段\",{\"0\":{\"1166\":1}}],[\"接口回调注入\",{\"0\":{\"1118\":1}}],[\"接口层一接收到请求就会调用数据处理层来玩完成具体的数据处理\",{\"1\":{\"806\":1}}],[\"接口和抽象类的区别越来越小了\",{\"1\":{\"1484\":1}}],[\"接口和抽象类的区别\",{\"0\":{\"21\":1}}],[\"接收事务结束的消息\",{\"0\":{\"1820\":1}}],[\"接收事务准备消息\",{\"0\":{\"1819\":1}}],[\"接收事务消息\",{\"0\":{\"1757\":1,\"1818\":1}}],[\"接收普通消息\",{\"0\":{\"1756\":1}}],[\"接收网络连接请求\",{\"1\":{\"1565\":1}}],[\"接收的参数tointfunction<\",{\"1\":{\"1491\":1}}],[\"接收的参数类型是consumer\",{\"1\":{\"1472\":1}}],[\"接收两个参数并且返回一个结果\",{\"1\":{\"1475\":1}}],[\"接收客户端连接\",{\"1\":{\"1452\":1}}],[\"接收请求\",{\"1\":{\"1410\":1,\"1411\":1}}],[\"接收到来自sakura频道的消息\",{\"1\":{\"735\":2}}],[\"接收消息\",{\"0\":{\"1755\":1},\"1\":{\"733\":1}}],[\"接收服务端返回结果的方式有两种\",{\"1\":{\"619\":1}}],[\"接下来把扫描得到的beandefinition进行修改\",{\"1\":{\"1530\":1}}],[\"接下来就需要重点了解管道流相关的内容\",{\"1\":{\"1498\":1}}],[\"接下来就正式开始了解有关spliterator的内容\",{\"1\":{\"1497\":1}}],[\"接下来是abstractpipeline类中的一些属性\",{\"1\":{\"1498\":1}}],[\"接下来是八个特性值\",{\"1\":{\"1497\":1}}],[\"接下来是getcomparator方法\",{\"1\":{\"1497\":1}}],[\"接下来是getexactsizeifknown方法\",{\"1\":{\"1497\":1}}],[\"接下来是hascharacteristics方法\",{\"1\":{\"1497\":1}}],[\"接下来是characteristics方法\",{\"1\":{\"1497\":1}}],[\"接下来是estimatesize方法\",{\"1\":{\"1497\":1}}],[\"接下来是trysplit方法\",{\"1\":{\"1497\":1}}],[\"接下来是foreachremaining方法\",{\"1\":{\"1497\":1}}],[\"接下来spliterator接口本身提供的一些方法进行说明\",{\"1\":{\"1497\":1}}],[\"接下来还提供了一个并行的例子\",{\"1\":{\"1497\":1}}],[\"接下来的章节重点分析这个类\",{\"1\":{\"1492\":1}}],[\"接下来的时间\",{\"1\":{\"1470\":1}}],[\"接下来介绍iterate方法\",{\"1\":{\"1486\":1}}],[\"接下来介绍generate和iterate这两个特殊的方法\",{\"1\":{\"1486\":1}}],[\"接下来再通过一些实际的例子\",{\"1\":{\"1485\":1}}],[\"接下来三个步骤时哈希桶数组resize成4\",{\"1\":{\"1427\":1}}],[\"接下来三组数据\",{\"1\":{\"616\":1}}],[\"接下来观察innodb\",{\"1\":{\"695\":1}}],[\"接下来执行264次查询语句\",{\"1\":{\"633\":1}}],[\"接下来执行的这个事务会直接被系统忽略\",{\"1\":{\"605\":1}}],[\"接下来四列是具体的统计项\",{\"1\":{\"616\":1}}],[\"接下来这个fsync越晚调用\",{\"1\":{\"588\":1}}],[\"接下来按照r排序\",{\"1\":{\"557\":1}}],[\"接下来按顺序取\",{\"1\":{\"493\":1}}],[\"接下来应该看看查询为了返回结果是否扫描了过多的数据\",{\"1\":{\"524\":1}}],[\"接下来\",{\"1\":{\"478\":1,\"533\":1,\"557\":1,\"591\":1,\"596\":1,\"628\":1,\"634\":1,\"1470\":1,\"1490\":1,\"1544\":1}}],[\"接下来我们来查看一下foreach方法的说明\",{\"1\":{\"1499\":1}}],[\"接下来我们来看一个kill不掉的例子\",{\"1\":{\"618\":1}}],[\"接下来我们就完整的梳理一下关于sream类本身的内容\",{\"1\":{\"1496\":1}}],[\"接下来我们就围绕collectors为我们提供的诸多的静态方法展开\",{\"1\":{\"1493\":1}}],[\"接下来我们定义一个中间结果容器需要进行类型转换的例子\",{\"1\":{\"1494\":1}}],[\"接下来我们实现一个自定义的收集器\",{\"1\":{\"1494\":1}}],[\"接下来我们首先分析每一个枚举项代表的含义\",{\"1\":{\"1494\":1}}],[\"接下来我们讨论有关流的短路问题\",{\"1\":{\"1489\":1}}],[\"接下来我们再了解流的另一个特性\",{\"1\":{\"1487\":1}}],[\"接下来我们阅读一下iterate的文档\",{\"1\":{\"1486\":1}}],[\"接下来我们给出一个稍微复杂一点的示例\",{\"1\":{\"1484\":1}}],[\"接下来我们使用list集合中新增加的sort方法进行排序\",{\"1\":{\"1480\":1}}],[\"接下来我们重点分析consumer这个函数式接口\",{\"1\":{\"1472\":1}}],[\"接下来我们分析使用s2作为驱动表的情况\",{\"1\":{\"692\":1}}],[\"接下来我们分析使用s1作为驱动表的情况\",{\"1\":{\"692\":1}}],[\"接下来我们分析一下engine\",{\"1\":{\"694\":1}}],[\"接下来我们分析一下\",{\"1\":{\"594\":1}}],[\"接下来我们分别分析一下这两种情况\",{\"1\":{\"692\":1}}],[\"接下来我们分别计算这两个数据\",{\"1\":{\"686\":1}}],[\"接下来我们要在主库执行下面这两个事务\",{\"1\":{\"599\":1}}],[\"接下来我们看一下通过reducing来实现的例子\",{\"1\":{\"1495\":1}}],[\"接下来我们看一个之前使用的方法\",{\"1\":{\"1495\":1}}],[\"接下来我们看多次排序的方法\",{\"1\":{\"1491\":1}}],[\"接下来我们看看引入stream会为我们的编码带来什么样的改变\",{\"1\":{\"1484\":1}}],[\"接下来我们看看在myisam引擎中的情况\",{\"1\":{\"561\":1}}],[\"接下来我们看另外一种场景\",{\"1\":{\"505\":1}}],[\"接下来我们通过例子来说明这三点\",{\"1\":{\"628\":1}}],[\"接下来我们通过例子来说明这一点\",{\"1\":{\"605\":1}}],[\"接下来我们通过一个实例来说明这一点\",{\"1\":{\"580\":1}}],[\"接下来我们通过观察分区表加间隙锁的例子来说明对于innodb来说\",{\"1\":{\"561\":1}}],[\"接下来我们通过实例来说明它们之间的区别\",{\"1\":{\"482\":1}}],[\"接下来我们着重了解一些索引的实践部分\",{\"1\":{\"494\":1}}],[\"接下来我们说明为什么需要两阶段提交\",{\"1\":{\"464\":1}}],[\"接下来我们会从上文提到的sql语句\",{\"1\":{\"454\":1}}],[\"默认8表示一个survivor区占用1\",{\"1\":{\"1541\":1}}],[\"默认物理内存的1\",{\"1\":{\"1541\":1}}],[\"默认实现类为simplemetadatareader\",{\"1\":{\"1523\":1}}],[\"默认会有一个\",{\"1\":{\"1524\":1}}],[\"默认会添加一个annotationtypefilter给includefilters\",{\"1\":{\"1522\":1}}],[\"默认会采用系统变量innodb\",{\"1\":{\"695\":1}}],[\"默认方法\",{\"0\":{\"1484\":1}}],[\"默认超过8\",{\"1\":{\"1423\":1}}],[\"默认的实现是不断的调用tryadvance方法直到返回false\",{\"1\":{\"1497\":1}}],[\"默认的实现会从集合的迭代器创建一个延迟绑定的分割迭代器\",{\"1\":{\"1497\":1}}],[\"默认的实现应该要被子类所重写\",{\"1\":{\"1497\":1}}],[\"默认的负载因子0\",{\"1\":{\"1423\":1}}],[\"默认的n是8\",{\"1\":{\"484\":1}}],[\"默认的n是20\",{\"1\":{\"484\":1}}],[\"默认线程池是forkjoinpool\",{\"1\":{\"1395\":1}}],[\"默认偏向锁批量撤销阈值\",{\"1\":{\"1362\":1}}],[\"默认偏向锁批量重偏向阈值\",{\"1\":{\"1362\":1}}],[\"默认40\",{\"1\":{\"1362\":1}}],[\"默认20\",{\"1\":{\"1362\":2}}],[\"默认26379\",{\"1\":{\"761\":1}}],[\"默认策略\",{\"1\":{\"1360\":1}}],[\"默认\",{\"1\":{\"807\":1,\"1375\":1}}],[\"默认三分钟\",{\"1\":{\"761\":1}}],[\"默认30秒\",{\"1\":{\"761\":1}}],[\"默认它们是阻塞的\",{\"1\":{\"739\":1}}],[\"默认以米作为单位\",{\"1\":{\"713\":1}}],[\"默认使用db\",{\"1\":{\"704\":1}}],[\"默认使用的就是innodb\",{\"1\":{\"454\":1}}],[\"默认1024字节\",{\"1\":{\"657\":1}}],[\"默认页大小是16kb\",{\"1\":{\"640\":1}}],[\"默认值2代表新生代占老年代的1\",{\"1\":{\"1541\":1}}],[\"默认值\",{\"1\":{\"694\":2}}],[\"默认值都是1\",{\"1\":{\"628\":1}}],[\"默认值是1\",{\"1\":{\"629\":1}}],[\"默认值是16m\",{\"1\":{\"558\":1}}],[\"默认值是256k\",{\"1\":{\"540\":1,\"662\":1}}],[\"默认值是8小时\",{\"1\":{\"455\":1}}],[\"默认开启\",{\"1\":{\"581\":1}}],[\"默认是21m左右\",{\"1\":{\"1541\":1}}],[\"默认是\",{\"1\":{\"1541\":1}}],[\"默认是物理内存的1\",{\"1\":{\"1541\":1}}],[\"默认是app\",{\"1\":{\"1524\":1}}],[\"默认是引用类型\",{\"1\":{\"1500\":1}}],[\"默认是按键值的升序排列\",{\"1\":{\"1421\":1}}],[\"默认是lru\",{\"1\":{\"806\":1}}],[\"默认是使用rdb方式持久化的\",{\"1\":{\"729\":1}}],[\"默认是不开启aof模式的\",{\"1\":{\"729\":1}}],[\"默认是以4096字节作为一个块的\",{\"1\":{\"694\":1}}],[\"默认是关闭的\",{\"1\":{\"568\":1}}],[\"默认是10秒\",{\"1\":{\"565\":1}}],[\"默认是16m\",{\"1\":{\"553\":1}}],[\"默认情况下从机的角色不会发生变化\",{\"1\":{\"748\":1}}],[\"默认情况下long\",{\"1\":{\"565\":1}}],[\"默认情况下\",{\"1\":{\"565\":1,\"568\":1,\"723\":1,\"743\":1,\"747\":1,\"748\":1,\"1380\":1,\"1388\":1,\"1527\":1,\"1529\":1}}],[\"默认有序\",{\"1\":{\"319\":1}}],[\"现已废弃\",{\"1\":{\"1524\":1}}],[\"现代处理器指令集架构基本上都会提供\",{\"1\":{\"1356\":1}}],[\"现代操作系统的多路复用api已经不再使用使用select系统调用\",{\"1\":{\"740\":1}}],[\"现代的网络速度比以前要快很多\",{\"1\":{\"529\":1}}],[\"现在的服务器基本都是linux系统\",{\"1\":{\"1865\":1}}],[\"现在直接使用更强大的利器spring\",{\"1\":{\"1860\":1}}],[\"现在已经是最受欢迎的企业级\",{\"1\":{\"1860\":1}}],[\"现在可以不用再学\",{\"1\":{\"1857\":1}}],[\"现在假设说要求使用流的方式求出列表的长度改怎么做呢\",{\"1\":{\"1492\":1}}],[\"现在假设我们在维护一个市民系统\",{\"1\":{\"478\":1}}],[\"现在加了一个元素后立即唤醒阻塞在notempty上的线程\",{\"1\":{\"1380\":1}}],[\"现在广泛使用的是mesa模型\",{\"1\":{\"1360\":1}}],[\"现在我们使用bifunction来实现同样的功能\",{\"1\":{\"1475\":1}}],[\"现在我们回到redisautoconfiguration\",{\"1\":{\"720\":1}}],[\"现在我们就能来验证了\",{\"1\":{\"720\":1}}],[\"现在我们将join\",{\"1\":{\"540\":1}}],[\"现在就可以根据聚簇索引占用的页面数量以及该表记录数的估计值\",{\"1\":{\"685\":1}}],[\"现在就是n+1\",{\"1\":{\"463\":1}}],[\"现在还要再去主键索引树上判断id是否存在\",{\"1\":{\"628\":1}}],[\"现在不止是dba有自动化系统\",{\"1\":{\"625\":1}}],[\"现在这个备库上就有了临时库需要的所有binlog了\",{\"1\":{\"622\":1}}],[\"现在这个实例x是另外一个实例y的从库\",{\"1\":{\"605\":1}}],[\"现在要把数据库恢复到这个三个事务操作之前的状态\",{\"1\":{\"621\":1}}],[\"现在要查询`name`\",{\"1\":{\"508\":1}}],[\"现在worker\",{\"1\":{\"598\":2}}],[\"现在越来越多的场景要求将mysql的binlog格式设置为row\",{\"1\":{\"591\":1}}],[\"现在\",{\"1\":{\"539\":1,\"605\":1}}],[\"现在mysql预估需要扫描5073条记录来完成这个查询\",{\"1\":{\"527\":1}}],[\"现在有一个支持邮箱登录的系统\",{\"1\":{\"486\":1}}],[\"现在分到两个页中\",{\"1\":{\"472\":1}}],[\"现在常见的做法也是用全量备份加上应用binlog来实现的\",{\"1\":{\"464\":1}}],[\"现在最常用的存储引擎是innodb\",{\"1\":{\"454\":1}}],[\"现实生活中\",{\"1\":{\"337\":1}}],[\"比这个例子稍微复杂一点的例子\",{\"1\":{\"1495\":1}}],[\"比这个例子稍微复杂一个例子\",{\"1\":{\"1491\":1}}],[\"比起bio我们不需要频繁的创建线程来处理客户端连接\",{\"1\":{\"1451\":1}}],[\"比起bio客户端连接操作时异步的\",{\"1\":{\"1451\":1}}],[\"比起误删数据时候进行处理\",{\"1\":{\"621\":1}}],[\"比\",{\"1\":{\"1425\":1}}],[\"比主库生产binlog的速度要慢\",{\"1\":{\"594\":1}}],[\"比直接join多了100次交互\",{\"1\":{\"538\":1}}],[\"比原来小了很多\",{\"1\":{\"489\":1}}],[\"比优化器的选择快了40多倍\",{\"1\":{\"485\":1}}],[\"比如服务发现\",{\"1\":{\"1867\":1}}],[\"比如培训机构的课程\",{\"1\":{\"1846\":1}}],[\"比如abstractajpprotocol和abstracthttp11protocol\",{\"1\":{\"1565\":1}}],[\"比如arraylist\",{\"1\":{\"1485\":1}}],[\"比如http11nioprotocol和ajpnioprotocol\",{\"1\":{\"1565\":1}}],[\"比如hash码\",{\"1\":{\"1361\":1}}],[\"比如hashmap\",{\"1\":{\"545\":1}}],[\"比如hadoop这类系统\",{\"1\":{\"594\":1}}],[\"比如java\",{\"1\":{\"1561\":1}}],[\"比如jar类包\",{\"1\":{\"1540\":1}}],[\"比如rt\",{\"1\":{\"1540\":1}}],[\"比如read方法要传递进去一个参数n\",{\"1\":{\"739\":1}}],[\"比如类名\",{\"1\":{\"1523\":1}}],[\"比如短路\",{\"1\":{\"1500\":1}}],[\"比如汇聚等等\",{\"1\":{\"1500\":1}}],[\"比如过滤\",{\"1\":{\"1500\":1}}],[\"比如管理大小的信息\",{\"1\":{\"1500\":1}}],[\"比如int类型的包装类型integer\",{\"1\":{\"1497\":1}}],[\"比如int\",{\"1\":{\"1497\":1}}],[\"比如intstream\",{\"1\":{\"1496\":1}}],[\"比如统计元素个数的estimatesize方法\",{\"1\":{\"1497\":1}}],[\"比如可以帮助对元进行进一步的分割或者对于剩余的元素进行串行的遍历\",{\"1\":{\"1497\":1}}],[\"比如可以配置一组4个文件\",{\"1\":{\"461\":1}}],[\"比如ordered\",{\"1\":{\"1497\":1}}],[\"比如从files\",{\"1\":{\"1496\":1}}],[\"比如lambda表达式\",{\"1\":{\"1496\":1}}],[\"比如linkedblockingqueue\",{\"1\":{\"1386\":1}}],[\"比如刚才的widgets\",{\"1\":{\"1496\":1}}],[\"比如collection\",{\"1\":{\"1496\":1}}],[\"比如collector\",{\"1\":{\"1492\":1}}],[\"比如concurrenthashmap\",{\"1\":{\"1496\":1}}],[\"比如count\",{\"1\":{\"1496\":1}}],[\"比如文件\",{\"1\":{\"1496\":1}}],[\"比如要根据城市的名字对城市中每个人的姓进行分组\",{\"1\":{\"1495\":1}}],[\"比如要保存的是2017年某个城市的所有人口信息\",{\"1\":{\"470\":1}}],[\"比如set\",{\"1\":{\"1494\":1}}],[\"比如stream\",{\"1\":{\"1492\":1}}],[\"比如摘要\",{\"1\":{\"1493\":1}}],[\"比如你可以使用下面的方式将widget累积到treeset当中\",{\"1\":{\"1492\":1}}],[\"比如你执行下面的语句\",{\"1\":{\"651\":1}}],[\"比如无序的collector它累积元素到一个list当中\",{\"1\":{\"1492\":1}}],[\"比如计算卖方交易数量的最大值\",{\"1\":{\"1492\":1}}],[\"比如将元素累积到一个集合当中\",{\"1\":{\"1493\":1}}],[\"比如将集合中的元素添加到collection当中\",{\"1\":{\"1492\":1}}],[\"比如将n设置为3600\",{\"1\":{\"623\":1}}],[\"比如现根据名称排序\",{\"1\":{\"1491\":1}}],[\"比如filter\",{\"1\":{\"1496\":1}}],[\"比如f\",{\"1\":{\"1486\":1}}],[\"比如biconsumer\",{\"1\":{\"1478\":1}}],[\"比如面向函数式编程语言javascript中\",{\"1\":{\"1470\":1}}],[\"比如发邮件\",{\"1\":{\"1393\":1}}],[\"比如数据库\",{\"1\":{\"1387\":1}}],[\"比如是否需要阻塞队列帮我们排序\",{\"1\":{\"1386\":1}}],[\"比如说head是没有previousstage的\",{\"1\":{\"1498\":1}}],[\"比如说lamda表达式\",{\"1\":{\"1496\":1}}],[\"比如说我们开发一个银行转账的程序\",{\"1\":{\"1378\":1}}],[\"比如说\",{\"1\":{\"1378\":1,\"1497\":3}}],[\"比如说redis实例的主观失效和客观失效等等\",{\"1\":{\"761\":1}}],[\"比如如果计算发生错误\",{\"1\":{\"1373\":1}}],[\"比如等待队列\",{\"1\":{\"1367\":1}}],[\"比如装在配置\",{\"1\":{\"1362\":1}}],[\"比如流式调用\",{\"1\":{\"798\":1}}],[\"比如热搜排行上\",{\"1\":{\"766\":1}}],[\"比如事务和基本的crud\",{\"1\":{\"720\":1}}],[\"比如事务a更新了一行\",{\"1\":{\"579\":1}}],[\"比如我们上面给出的例子中的compute\",{\"1\":{\"1475\":1}}],[\"比如我们想把order\",{\"1\":{\"696\":1}}],[\"比如我们可以这样更新关于order\",{\"1\":{\"696\":1}}],[\"比如我们要获取两个集合的笛卡尔积\",{\"1\":{\"1486\":1}}],[\"比如我们要返回一个linkedlist\",{\"1\":{\"1486\":1}}],[\"比如我们要查看order\",{\"1\":{\"690\":1}}],[\"比如我们要看一下4~7个字节的前缀索引\",{\"1\":{\"487\":1}}],[\"比如u\",{\"1\":{\"695\":1}}],[\"比如有a\",{\"1\":{\"693\":1}}],[\"比如有2000个参数怎么办\",{\"1\":{\"690\":1}}],[\"比如表a\",{\"1\":{\"693\":1}}],[\"比如表a和表b连接\",{\"1\":{\"693\":1}}],[\"比如对象刚刚一次自旋操作成功过\",{\"1\":{\"1362\":1}}],[\"比如对某个key只允许一个线程查询数据和写缓存\",{\"1\":{\"770\":1}}],[\"比如对如下查询\",{\"1\":{\"692\":1}}],[\"比如对于integer的ofint\",{\"1\":{\"1497\":1}}],[\"比如对于integer的intconsumer\",{\"1\":{\"1497\":1}}],[\"比如对于idx\",{\"1\":{\"695\":1}}],[\"比如对于u\",{\"1\":{\"695\":1}}],[\"比如对于一个一万行记录的表来说\",{\"1\":{\"690\":1}}],[\"比如对于联合索引u\",{\"1\":{\"690\":1}}],[\"比如使用in语句就很容易产生非常多的单点区间\",{\"1\":{\"690\":1}}],[\"比如许多应用对\",{\"1\":{\"669\":1}}],[\"比如价格\",{\"1\":{\"665\":1}}],[\"比如t2表有1000行记录\",{\"1\":{\"662\":1}}],[\"比如优化器是怎么选择索引的\",{\"1\":{\"651\":1}}],[\"比如加密\",{\"1\":{\"1387\":1}}],[\"比如加\",{\"1\":{\"624\":1}}],[\"比如where\",{\"1\":{\"621\":1}}],[\"比如下面几个查询\",{\"1\":{\"691\":2}}],[\"比如下面这个查询\",{\"1\":{\"690\":1}}],[\"比如下面这个语句\",{\"1\":{\"544\":1}}],[\"比如下面三个事务\",{\"1\":{\"621\":1}}],[\"比如命名为health\",{\"1\":{\"614\":1}}],[\"比如通过set\",{\"1\":{\"605\":1}}],[\"比如一个dubbo服务要调用grpc服务\",{\"1\":{\"798\":1}}],[\"比如一个是业务逻辑库\",{\"1\":{\"600\":1}}],[\"比如一周一备的实例\",{\"1\":{\"623\":1}}],[\"比如一些金融类的业务\",{\"1\":{\"607\":1}}],[\"比如一条sql执行超过5秒钟\",{\"1\":{\"565\":1}}],[\"比如所有的更新事务都会涉及到一个表的时候\",{\"1\":{\"598\":1}}],[\"比如主库所在机器掉电\",{\"1\":{\"594\":1}}],[\"比如软件升级\",{\"1\":{\"594\":1}}],[\"比如切换过程中出现双写\",{\"1\":{\"590\":1}}],[\"比如本节中的表t\",{\"1\":{\"585\":1}}],[\"比如10个记录\",{\"1\":{\"581\":1}}],[\"比如用来判断一个库是主库还是备库\",{\"1\":{\"575\":1}}],[\"比如main\",{\"1\":{\"1540\":1}}],[\"比如mysql原生的myisam引擎就不支持事务\",{\"1\":{\"569\":1}}],[\"比如memcached及其他一些nosql引擎\",{\"1\":{\"469\":1}}],[\"比如超过5秒钟的就是慢sql\",{\"1\":{\"567\":1}}],[\"比如超过了1000个\",{\"1\":{\"562\":1}}],[\"比如查询需要跨多个分区取数据\",{\"1\":{\"563\":1}}],[\"比如group\",{\"1\":{\"548\":1}}],[\"比如nio+http或者nio2+ajp\",{\"1\":{\"1565\":1}}],[\"比如n\",{\"1\":{\"548\":1}}],[\"比如5秒\",{\"1\":{\"595\":1}}],[\"比如5\",{\"1\":{\"487\":1}}],[\"比如上文中的这个例子\",{\"1\":{\"591\":1}}],[\"比如上面例子中的select\",{\"1\":{\"613\":1}}],[\"比如上面的这个例子\",{\"1\":{\"591\":1}}],[\"比如上面这个市民表的情况\",{\"1\":{\"476\":1}}],[\"比如上述例子中表t中\",{\"1\":{\"459\":1}}],[\"比如字符串类型的身份证号\",{\"1\":{\"472\":1}}],[\"比如某天下午两点发现中午十二点有一次误删表\",{\"1\":{\"464\":1}}],[\"比如原来是n\",{\"1\":{\"463\":1}}],[\"比如执行下面的语句\",{\"1\":{\"458\":1}}],[\"比如\",{\"1\":{\"456\":1,\"462\":1,\"480\":1,\"485\":1,\"487\":1,\"531\":1,\"548\":1,\"561\":1,\"562\":1,\"563\":1,\"591\":2,\"594\":1,\"599\":2,\"607\":1,\"616\":1,\"617\":1,\"624\":2,\"628\":1,\"630\":1,\"1428\":1,\"1440\":1,\"1484\":1,\"1487\":1,\"1490\":1,\"1496\":1,\"1500\":1,\"1509\":1,\"1510\":1,\"1512\":2,\"1523\":1}}],[\"比如存储过程\",{\"1\":{\"454\":1}}],[\"比较出名的有以下四种\",{\"1\":{\"1863\":1}}],[\"比较器也可以进行复合\",{\"1\":{\"1491\":1}}],[\"比较完成之后还是会强转会原来的类型\",{\"1\":{\"1491\":1}}],[\"比较难\",{\"1\":{\"1453\":1}}],[\"比较常用的有\",{\"1\":{\"1397\":1}}],[\"比较常见的场景有以下几种\",{\"1\":{\"618\":1}}],[\"比较常见的是100~1000\",{\"1\":{\"588\":1}}],[\"比较常见的是将其设置为100~1000中的某个数值\",{\"1\":{\"587\":1}}],[\"比较常见的优化方法是\",{\"1\":{\"505\":1}}],[\"比较智能\",{\"1\":{\"1362\":1}}],[\"比较项\",{\"1\":{\"732\":1}}],[\"比较耗费时间的是步骤3\",{\"1\":{\"595\":1}}],[\"比较好的方案是\",{\"1\":{\"523\":1}}],[\"比较下标的位置\",{\"1\":{\"393\":1}}],[\"比较元素大小\",{\"1\":{\"317\":1,\"318\":1}}],[\"比较相邻的元素\",{\"1\":{\"317\":1}}],[\"涵盖mysql的大多数核心服务功能\",{\"1\":{\"454\":1}}],[\"表达式和\",{\"1\":{\"1856\":1}}],[\"表达的具体含义\",{\"1\":{\"1472\":1}}],[\"表达力更强\",{\"1\":{\"1468\":1}}],[\"表结构设计\",{\"0\":{\"697\":1}}],[\"表结构的定义是存放在后缀名为\",{\"1\":{\"627\":1}}],[\"表c进行连接\",{\"1\":{\"693\":1}}],[\"表b\",{\"1\":{\"693\":1}}],[\"表依赖详情\",{\"1\":{\"656\":1}}],[\"表数据文件本身就是按b+tree组织的一个索引结构文件\",{\"1\":{\"642\":1}}],[\"表定义的自增值达到上限后的逻辑是\",{\"1\":{\"631\":1}}],[\"表定义自增值id\",{\"0\":{\"631\":1}}],[\"表定义里面出现了auto\",{\"1\":{\"627\":1}}],[\"表的自增主键id达到上限后\",{\"1\":{\"636\":1}}],[\"表的自增值可以恢复为mysql重启前的值\",{\"1\":{\"627\":1}}],[\"表的方法\",{\"0\":{\"624\":1}}],[\"表的读取和加载顺序\",{\"1\":{\"467\":1}}],[\"表的读取顺序\",{\"1\":{\"466\":1}}],[\"表\",{\"0\":{\"622\":1}}],[\"表上没有主键\",{\"1\":{\"602\":1}}],[\"表上如果有外键\",{\"1\":{\"599\":1}}],[\"表必须有主键\",{\"1\":{\"599\":1}}],[\"表级别的锁\",{\"0\":{\"576\":1}}],[\"表级锁和行锁三类\",{\"1\":{\"573\":1}}],[\"表管理的实现上很粗糙\",{\"1\":{\"562\":1}}],[\"表t2的数据总量\",{\"1\":{\"662\":1}}],[\"表t1的数据总量\",{\"1\":{\"662\":1}}],[\"表t1中字段a是逆序的\",{\"1\":{\"541\":1}}],[\"表temp\",{\"1\":{\"550\":1}}],[\"表名称2\",{\"1\":{\"671\":1}}],[\"表名称\",{\"1\":{\"671\":1}}],[\"表名\",{\"1\":{\"549\":1,\"598\":1,\"695\":5,\"696\":2}}],[\"表锁的语法是lock\",{\"1\":{\"577\":1}}],[\"表锁\",{\"0\":{\"577\":1,\"671\":1},\"1\":{\"525\":1}}],[\"表面上是叫做分组\",{\"1\":{\"515\":1}}],[\"表索引列有1980个不同的值\",{\"1\":{\"496\":1}}],[\"表里面已经有了id=3的行\",{\"1\":{\"628\":1}}],[\"表里面多了一行\",{\"1\":{\"584\":1}}],[\"表里有两个字段m和c\",{\"1\":{\"553\":1}}],[\"表里有a\",{\"1\":{\"483\":1}}],[\"表里只有一个id字段\",{\"1\":{\"454\":1}}],[\"表中存放对象的信息\",{\"1\":{\"710\":1}}],[\"表中的数据也一直在变化\",{\"1\":{\"696\":1}}],[\"表中每一项的含义\",{\"1\":{\"694\":1}}],[\"表中t1中除了主键\",{\"1\":{\"599\":1}}],[\"表中有两个字段\",{\"1\":{\"557\":1}}],[\"表中有字段k\",{\"1\":{\"472\":1}}],[\"表中包含三个字段v\",{\"1\":{\"548\":1}}],[\"表中r1~r5的\",{\"1\":{\"472\":1}}],[\"表都是根据主键顺序以索引的形式存放的\",{\"1\":{\"472\":1}}],[\"表明cas失败\",{\"1\":{\"1356\":1}}],[\"表明cas成功\",{\"1\":{\"1356\":1}}],[\"表明不想让该表自动重新计算统计数据\",{\"1\":{\"696\":1}}],[\"表明我们想让该表自动重新计算统计数据\",{\"1\":{\"696\":1}}],[\"表明我们想把该表的统计数据临时的存储到内存中\",{\"1\":{\"695\":1}}],[\"表明我们想把该表的统计数据永久的存储到磁盘上\",{\"1\":{\"695\":1}}],[\"表明order\",{\"1\":{\"695\":3}}],[\"表明使用了where过滤\",{\"1\":{\"467\":1}}],[\"表明索引用来读取数据而非执行查找动作\",{\"1\":{\"467\":1}}],[\"表只有一行记录\",{\"1\":{\"467\":1}}],[\"表之间的引用\",{\"1\":{\"466\":1}}],[\"表示要增强这个配置类\",{\"1\":{\"1529\":1}}],[\"表示要获取的对象是factorybean本身的对象\",{\"1\":{\"1524\":1}}],[\"表示默认情况下spring扫描过程中会认为类上有\",{\"1\":{\"1522\":1}}],[\"表示扫描com\",{\"1\":{\"1522\":1}}],[\"表示stringtouserpropertyeditor可以将string转化成user类型\",{\"1\":{\"1515\":1}}],[\"表示可以指定某个类加载器进行类的加载\",{\"1\":{\"1513\":1}}],[\"表示bean销毁时要执行的方法\",{\"1\":{\"1509\":1}}],[\"表示bean初始化时要执行的方法\",{\"1\":{\"1509\":1}}],[\"表示bean是否是懒加载\",{\"1\":{\"1509\":1}}],[\"表示bean的作用域\",{\"1\":{\"1509\":1}}],[\"表示bean的类型\",{\"1\":{\"1509\":1}}],[\"表示需要进行aop\",{\"1\":{\"1507\":1}}],[\"表示需要排序\",{\"1\":{\"553\":1}}],[\"表示下游的操作\",{\"1\":{\"1500\":1}}],[\"表示下一次插入数时\",{\"1\":{\"627\":1}}],[\"表示流已经消费完成\",{\"1\":{\"1498\":1}}],[\"表示串行\",{\"1\":{\"1498\":1}}],[\"表示管道反向链接的头\",{\"1\":{\"1498\":1}}],[\"表示是有顺序的\",{\"1\":{\"1498\":1}}],[\"表示取前几个元素\",{\"1\":{\"1487\":1}}],[\"表示跳过\",{\"1\":{\"1487\":1}}],[\"表示一种映射关系\",{\"1\":{\"1486\":1}}],[\"表示返回当前predicate的逻辑非\",{\"1\":{\"1476\":1}}],[\"表示多了一个线程在帮助扩容\",{\"1\":{\"1431\":1}}],[\"表示该beanfactory支持bean的后置处理器\",{\"1\":{\"1513\":1}}],[\"表示该beanfactory可以进行类型转化\",{\"1\":{\"1513\":1}}],[\"表示该beanfactory可以解析el表达式\",{\"1\":{\"1513\":1}}],[\"表示该节点是链表\",{\"1\":{\"1431\":1}}],[\"表示该索引共占用多少页面\",{\"1\":{\"695\":1}}],[\"表示扩容后key1和key2两种key确定索引位置的示例\",{\"1\":{\"1427\":1}}],[\"表示扩容前key1和key2两种key确定索引位置的示例\",{\"1\":{\"1427\":1}}],[\"表示当前场景下后续的acquireshared能够得以执行\",{\"1\":{\"1367\":1}}],[\"表示当前节点在等待condition\",{\"1\":{\"1367\":1}}],[\"表示当前节点在sync队列中\",{\"1\":{\"1367\":1}}],[\"表示当前节点的后继节点包含的线程需要运行\",{\"1\":{\"1367\":1}}],[\"表示当前的线程被取消\",{\"1\":{\"1367\":1}}],[\"表示把eax中存的值写入exchange\",{\"1\":{\"1356\":1}}],[\"表示concurrenthashmap正在执行初始化\",{\"1\":{\"1431\":1}}],[\"表示compare\",{\"1\":{\"1356\":1}}],[\"表示change\",{\"1\":{\"480\":1}}],[\"表示读取这么多字节后再返回\",{\"1\":{\"739\":1}}],[\"表示60\",{\"1\":{\"724\":1}}],[\"表示300\",{\"1\":{\"724\":1}}],[\"表示900\",{\"1\":{\"724\":1}}],[\"表示单位为英尺\",{\"1\":{\"713\":1}}],[\"表示单位为英里\",{\"1\":{\"713\":1}}],[\"表示单位为千米\",{\"1\":{\"713\":1}}],[\"表示单位为米\",{\"1\":{\"713\":1}}],[\"表示参与运算的集合数\",{\"1\":{\"711\":1}}],[\"表示参与排序的只有name和id这两个字段\",{\"1\":{\"492\":1}}],[\"表示参与排序的行数是4000行\",{\"1\":{\"491\":1}}],[\"表示key过期\",{\"1\":{\"706\":1}}],[\"表示对应的索引列不重复的值有多少\",{\"1\":{\"695\":1}}],[\"表示在这个版本是由已提交的事务生成的\",{\"1\":{\"679\":1}}],[\"表示在对子查询的结果做union的时候\",{\"1\":{\"551\":1}}],[\"表示采用之前mysql5\",{\"1\":{\"629\":1}}],[\"表示断开这个线程的连接\",{\"1\":{\"617\":1}}],[\"表示终止这个线程中正在执行的语句\",{\"1\":{\"617\":1}}],[\"表示系统的io是正在工作的\",{\"1\":{\"615\":1}}],[\"表示不限制并发线程数量\",{\"1\":{\"613\":1}}],[\"表示从命令开始执行\",{\"1\":{\"610\":1}}],[\"表示从前k个房子\",{\"1\":{\"431\":1}}],[\"表示收到了\",{\"1\":{\"609\":1}}],[\"表示这对主备关系使用了gtid协议\",{\"1\":{\"609\":1}}],[\"表示这个版本已经提交了的事务生成的\",{\"1\":{\"679\":1}}],[\"表示这个版本是由还未提交的事务生成的\",{\"1\":{\"679\":1}}],[\"表示这个版本是由将来启动的事务生成的\",{\"1\":{\"679\":1}}],[\"表示这个日志是自己生成的\",{\"1\":{\"592\":1}}],[\"表示这个事务是在server\",{\"1\":{\"591\":1}}],[\"表示这个语句使用了覆盖索引\",{\"1\":{\"553\":1}}],[\"表示这个线程接下来的语句都会被记录入慢查询日志中\",{\"1\":{\"483\":1}}],[\"表示a\",{\"1\":{\"605\":1}}],[\"表示延迟多少微妙后才调用fsync\",{\"1\":{\"602\":1}}],[\"表示使用mysql5\",{\"1\":{\"602\":1}}],[\"表示使用了临时表\",{\"1\":{\"553\":1}}],[\"表示会影响到这个表a=1的行\",{\"1\":{\"599\":1}}],[\"表示会影响到这个表a=2的行\",{\"1\":{\"599\":1}}],[\"表示队列中有多少个事务修改这个表\",{\"1\":{\"598\":1}}],[\"表示中间是一个事务\",{\"1\":{\"591\":1}}],[\"表示累积多少次以后才调用fsync\",{\"1\":{\"588\":1,\"602\":1}}],[\"表示每次事务提交时都将redo\",{\"1\":{\"588\":1}}],[\"表示每次事务提交时都只是把redo\",{\"1\":{\"588\":2}}],[\"表示每次提交事务都write\",{\"1\":{\"587\":1}}],[\"表示每次提交事务都会执行fsync\",{\"1\":{\"587\":1}}],[\"表示每次提交事务都只write\",{\"1\":{\"587\":1}}],[\"表示只使用了覆盖索引\",{\"1\":{\"551\":1}}],[\"表示mysql将通过where条件来筛选存储引擎返回的记录\",{\"1\":{\"527\":1}}],[\"表示没有用上交易详情表trade\",{\"1\":{\"505\":1}}],[\"表示的就是a\",{\"1\":{\"604\":1}}],[\"表示的就是类似mariadb的策略\",{\"1\":{\"602\":1}}],[\"表示的就是使用了覆盖索引\",{\"1\":{\"493\":1}}],[\"表示的是中间结果容器的类型\",{\"1\":{\"1495\":1}}],[\"表示的是备库执行的最新位点\",{\"1\":{\"609\":1}}],[\"表示的是读到的主库的最新位点\",{\"1\":{\"609\":1}}],[\"表示的是需要使用临时表\",{\"1\":{\"557\":1}}],[\"表示的是只会取查询需要的字段\",{\"1\":{\"542\":1}}],[\"表示的是用上了mrr优化\",{\"1\":{\"541\":1}}],[\"表示的是使用了覆盖索引\",{\"1\":{\"503\":1}}],[\"表示的是\",{\"1\":{\"503\":1}}],[\"表示排序可以直接在内存中完成\",{\"1\":{\"491\":1}}],[\"表示就是需要排序\",{\"1\":{\"491\":1}}],[\"表示统计信息只存储在内存中\",{\"1\":{\"484\":1}}],[\"表示统计信息会持久化存储\",{\"1\":{\"484\":1}}],[\"表示索引列中不重复值的个数\",{\"1\":{\"690\":1}}],[\"表示索引被用来执行索引键值的查找\",{\"1\":{\"467\":1}}],[\"表示索引中使用的字节数\",{\"1\":{\"467\":1}}],[\"表示相应的select操作中使用了覆盖索引\",{\"1\":{\"467\":1}}],[\"表示通过索引一次就找到了\",{\"1\":{\"467\":1}}],[\"表示陆地格子\",{\"1\":{\"435\":2}}],[\"表示海洋格子\",{\"1\":{\"435\":1}}],[\"表示\",{\"1\":{\"428\":1,\"540\":1}}],[\"表示字符串s的第i到j个字母组成的串\",{\"1\":{\"428\":1}}],[\"表示text1​\",{\"1\":{\"427\":1}}],[\"表示位置\",{\"1\":{\"426\":1}}],[\"矩阵\",{\"0\":{\"442\":1}}],[\"通俗点说\",{\"1\":{\"1863\":1}}],[\"通俗易懂\",{\"1\":{\"1849\":1}}],[\"通信机制\",{\"0\":{\"1725\":1}}],[\"通信的\",{\"1\":{\"761\":1}}],[\"通道可以用户读\",{\"1\":{\"1451\":1}}],[\"通道是双向的\",{\"1\":{\"1451\":1}}],[\"通知相关的客户端关于master地址已经发生改变的信息\",{\"1\":{\"761\":1}}],[\"通知脚本\",{\"1\":{\"761\":1}}],[\"通知型脚本\",{\"1\":{\"761\":1}}],[\"通用类型转换接口\",{\"0\":{\"1247\":1}}],[\"通用\",{\"1\":{\"568\":2}}],[\"通用分区策略\",{\"1\":{\"562\":1}}],[\"通常都是由于永久代或元空间发生了大小调整\",{\"1\":{\"1541\":1}}],[\"通常都走else的逻辑\",{\"1\":{\"1532\":1}}],[\"通常情况都是一对一的\",{\"1\":{\"1531\":1}}],[\"通常情况下\",{\"1\":{\"550\":1,\"604\":1,\"607\":1,\"613\":1}}],[\"通常会先先执行postprocessbeandefinitionregistry方法\",{\"1\":{\"1529\":1}}],[\"通常用来高效的处理一些集合的运算\",{\"1\":{\"1470\":1}}],[\"通常通过一个独立的acceptor线程负责监听客户端的连接\",{\"1\":{\"1450\":1}}],[\"通常非常快\",{\"1\":{\"726\":1}}],[\"通常有三种做法\",{\"1\":{\"609\":1}}],[\"通常我们会定义一个类型转换器\",{\"1\":{\"1515\":1}}],[\"通常我们比较两个对象时\",{\"1\":{\"1482\":1}}],[\"通常我们可以从以下5个角度考虑\",{\"1\":{\"1386\":1}}],[\"通常我们在主动切换的时候\",{\"1\":{\"596\":1}}],[\"通常我们说的mysql的\",{\"1\":{\"588\":1}}],[\"通常我们使用分区表的一个重要原因就是单表过大\",{\"1\":{\"561\":1}}],[\"通常我们就会根据索引的复用能力来确定索引内的字段顺序\",{\"1\":{\"476\":1}}],[\"通常可以使用select\",{\"1\":{\"532\":1}}],[\"通常来说\",{\"1\":{\"518\":1,\"594\":1}}],[\"通常而言\",{\"1\":{\"435\":1}}],[\"通过java命令执行代码的大体流程如下\",{\"1\":{\"1540\":1}}],[\"通过aopcontext\",{\"1\":{\"1531\":1}}],[\"通过利用spring的扫描后\",{\"1\":{\"1530\":1}}],[\"通过\",{\"1\":{\"1530\":1}}],[\"通过getbean\",{\"1\":{\"1527\":1}}],[\"通过georadius就可以完成\",{\"1\":{\"713\":1}}],[\"通过编程式声明bean对象\",{\"1\":{\"1509\":1}}],[\"通过xml方式配置和使用注解等方式声明的bean\",{\"1\":{\"1509\":1}}],[\"通过事务管理器\",{\"1\":{\"1507\":1}}],[\"通过支持解耦\",{\"1\":{\"1497\":1}}],[\"通过特性值sized获取到的值就是之后遍历元素个数的值\",{\"1\":{\"1497\":1}}],[\"通过reducing方法来实现\",{\"1\":{\"1495\":1}}],[\"通过redis\",{\"1\":{\"705\":1}}],[\"通过管道的方式获取值\",{\"1\":{\"1485\":1}}],[\"通过lambda表达式我们可以将上述代码优雅的表示为\",{\"1\":{\"1470\":1}}],[\"通过lock保证可见性\",{\"1\":{\"1348\":1}}],[\"通过代码我们会发现\",{\"1\":{\"1451\":1}}],[\"通过代码我们可以发现bio的主要问题在于\",{\"1\":{\"1450\":1}}],[\"通过遍历文件描述符来获取已经就绪的socket\",{\"1\":{\"1447\":1}}],[\"通过打听\",{\"1\":{\"1438\":1}}],[\"通过unsafe\",{\"1\":{\"1431\":1}}],[\"通过设置断点让线程1和线程2同时debug到transfer方法的首行\",{\"1\":{\"1428\":1}}],[\"通过设置slave\",{\"1\":{\"604\":1}}],[\"通过重新计算索引位置后\",{\"1\":{\"1427\":1}}],[\"通过重构查询将关联当到应用程序中将会更加高效\",{\"1\":{\"531\":1}}],[\"通过hashcode\",{\"1\":{\"1425\":1}}],[\"通过cglib或者jdk的动态代理来实现aop\",{\"1\":{\"1531\":1}}],[\"通过cglib技术\",{\"1\":{\"1531\":1}}],[\"通过collectorimpl来实现\",{\"1\":{\"1495\":1}}],[\"通过copy\",{\"1\":{\"1404\":1}}],[\"通过change\",{\"1\":{\"623\":1}}],[\"通过位运算\",{\"1\":{\"1396\":1}}],[\"通过调用它的take方法或poll方法可以获取到一个已经执行完成的future\",{\"1\":{\"1394\":1}}],[\"通过任务窃取\",{\"1\":{\"1391\":1}}],[\"通过逃逸分析\",{\"1\":{\"1365\":1}}],[\"通过锁消除\",{\"1\":{\"1364\":1}}],[\"通过对比\",{\"1\":{\"1452\":1}}],[\"通过对运行上下文的扫描\",{\"1\":{\"1364\":1}}],[\"通过对多线程的串行化来访问公共资源或一段代码\",{\"1\":{\"1354\":1}}],[\"通过final关键字保证可见性\",{\"1\":{\"1348\":1}}],[\"通过内存屏障保障可见性\",{\"1\":{\"1348\":1}}],[\"通过volatile关键字保证可见性\",{\"1\":{\"1348\":1}}],[\"通过加锁或者队列来控制读数据库写缓存的线程数量\",{\"1\":{\"770\":1}}],[\"通过发送命令\",{\"1\":{\"757\":1}}],[\"通过多个从节点分担负载\",{\"1\":{\"744\":1}}],[\"通过info\",{\"1\":{\"725\":1}}],[\"通过使用这些template来间接操作组件\",{\"1\":{\"720\":1}}],[\"通过分数返回有序集合指定区间内的成员\",{\"1\":{\"711\":1}}],[\"通过分析两条sql的执行计划来分析性能\",{\"1\":{\"508\":1}}],[\"通过字典区间返回有序集合的成员\",{\"1\":{\"711\":1}}],[\"通过下标截取指定范围内的列表\",{\"1\":{\"708\":1}}],[\"通过索引\",{\"1\":{\"711\":1}}],[\"通过索引区间返回有序集合成指定区间内的成员\",{\"1\":{\"711\":1}}],[\"通过索引为元素设值\",{\"1\":{\"708\":1}}],[\"通过索引获取列表元素\",{\"1\":{\"708\":1}}],[\"通过ttl命令返回key的过期时间\",{\"1\":{\"706\":1}}],[\"通过进行对redis\",{\"1\":{\"706\":1}}],[\"通过data\",{\"1\":{\"685\":1}}],[\"通过statelessop创建饮水槽\",{\"1\":{\"1500\":1}}],[\"通过synchronized关键字保证线程安全\",{\"1\":{\"1432\":1}}],[\"通过sychronized关键字保证可见性\",{\"1\":{\"1348\":1}}],[\"通过signal或signalall将条件队列中的节点转移到同步队列\",{\"1\":{\"1368\":1}}],[\"通过sql\",{\"1\":{\"605\":1}}],[\"通过set\",{\"1\":{\"591\":1}}],[\"通过binlog输出到外部系统\",{\"1\":{\"594\":1}}],[\"通过上图还是不能看出详细的信息\",{\"1\":{\"591\":1}}],[\"通过显式语句的方式来启动事务\",{\"1\":{\"572\":1}}],[\"通过回滚操作\",{\"1\":{\"571\":1}}],[\"通过优先队列排序找到最小的三个r值的行的过程\",{\"1\":{\"558\":1}}],[\"通过优化器知道了该怎么做\",{\"1\":{\"459\":1}}],[\"通过这种元创建的spliterator会返回一个concurrent的特性值\",{\"1\":{\"1497\":1}}],[\"通过这种元创建的spliterator会返回一个immutable的特性值\",{\"1\":{\"1497\":1}}],[\"通过这种方式就可以得到一个不可变的集合列表\",{\"1\":{\"1495\":1}}],[\"通过这种方式就能保证这个数据逻辑的正确性\",{\"1\":{\"480\":1}}],[\"通过这个例子说明了lambda表达式与匿名内部类有着本质的区别\",{\"1\":{\"1469\":1}}],[\"通过这个设置就可以保证一定可以使用mrr优化\",{\"1\":{\"541\":1}}],[\"通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式\",{\"1\":{\"1350\":1}}],[\"通过以上的分析\",{\"1\":{\"538\":1}}],[\"通过以上两种情况的对比\",{\"1\":{\"487\":1}}],[\"通过如下两个步骤来分析总是非常有效\",{\"1\":{\"518\":1}}],[\"通过它们的执行过程能更加清楚看到这一点\",{\"1\":{\"487\":1}}],[\"通过explain命令可以这条语句执行的情况\",{\"1\":{\"483\":1}}],[\"通过查看表结构知道\",{\"1\":{\"467\":1}}],[\"通过执行mysql\",{\"1\":{\"455\":1}}],[\"通过观察不难发现\",{\"1\":{\"438\":1}}],[\"利用反射创建相应的组件\",{\"1\":{\"1561\":1}}],[\"利用cas去进行无锁线程安全操作\",{\"1\":{\"1431\":1}}],[\"利用红黑树快速增删改查的特点提高hashmap的性能\",{\"1\":{\"1423\":1}}],[\"利用缓存行填充解决伪共享的问题\",{\"1\":{\"1396\":1}}],[\"利用这个特性\",{\"1\":{\"1394\":1}}],[\"利用这个代码模板求接这个问题实际上就是求深度遍历的次数\",{\"1\":{\"435\":1}}],[\"利用reentrantlock实现线程安全\",{\"1\":{\"1379\":1}}],[\"利用率很低之后\",{\"1\":{\"472\":1}}],[\"利用中序遍历的性质\",{\"1\":{\"397\":1}}],[\"已满\",{\"1\":{\"1380\":1}}],[\"已经成为目前最主流的\",{\"1\":{\"1860\":1}}],[\"已经成为互联网企业的不二首选\",{\"1\":{\"1853\":1}}],[\"已经逐渐被\",{\"1\":{\"1857\":1}}],[\"已经被\",{\"1\":{\"1856\":1}}],[\"已经被广泛应用在数据库引擎中了\",{\"1\":{\"471\":1}}],[\"已经初始化但是冲突发生在cell单元内\",{\"1\":{\"1357\":1}}],[\"已经得到连接顺序abc时当前的最小连接成本\",{\"1\":{\"693\":1}}],[\"已经需要做主备切换了\",{\"1\":{\"615\":1}}],[\"已经把实例b需要的binlog给删掉了\",{\"1\":{\"605\":1}}],[\"已经存在于实例x的gtid集合中了\",{\"1\":{\"605\":1}}],[\"已经加入了这个gtid\",{\"1\":{\"605\":1}}],[\"已经写了一些redo\",{\"1\":{\"588\":1}}],[\"已经知道类及了y个1\",{\"1\":{\"554\":1}}],[\"已经知道累积了x个0\",{\"1\":{\"554\":1}}],[\"已经没有办法利用索引方式查出身份证号码在\",{\"1\":{\"489\":1}}],[\"已经是有序的了\",{\"1\":{\"485\":1}}],[\"已经遍历过了就设置为0\",{\"1\":{\"435\":1}}],[\"已遍历过\",{\"1\":{\"435\":2}}],[\"已知前序和后序遍历\",{\"1\":{\"339\":1}}],[\"已知前序遍历序列和中序遍历序列\",{\"1\":{\"339\":1}}],[\"已知中序遍历序列和后序遍历序列\",{\"1\":{\"339\":1}}],[\"超时了\",{\"1\":{\"708\":1}}],[\"超时返回1\",{\"1\":{\"611\":1}}],[\"超大事务执行期间被kill\",{\"1\":{\"618\":1}}],[\"超过最大索引值加1\",{\"1\":{\"1497\":1}}],[\"超过最大值就不再扩充\",{\"1\":{\"1427\":1}}],[\"超过最大容量就扩容\",{\"1\":{\"1426\":1}}],[\"超过阻塞时间\",{\"1\":{\"1378\":2}}],[\"超过n秒后还不返回\",{\"1\":{\"615\":1}}],[\"超过了sort\",{\"1\":{\"558\":1}}],[\"超过了16\",{\"1\":{\"492\":1}}],[\"超过int的最大值\",{\"1\":{\"360\":1}}],[\"超出了网格范围\",{\"1\":{\"435\":1}}],[\"网上也有一些不错的文档教程网站\",{\"1\":{\"1847\":1}}],[\"网页的访问量\",{\"1\":{\"714\":1}}],[\"网络编程\",{\"1\":{\"1847\":1}}],[\"网络通信\",{\"1\":{\"1565\":1}}],[\"网络通信等任务\",{\"1\":{\"1387\":1}}],[\"网络传输\",{\"1\":{\"1352\":1}}],[\"网络正常的情况下\",{\"1\":{\"594\":1}}],[\"网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击\",{\"1\":{\"763\":1}}],[\"网络安全\",{\"0\":{\"222\":1}}],[\"网格的遍历可能会遍历重复的节点\",{\"1\":{\"435\":1}}],[\"网格中的格子的相邻的格子节点分别是上下左右四个\",{\"1\":{\"435\":1}}],[\"岛屿问题是一类典型的网格问题\",{\"1\":{\"435\":1}}],[\"偷窃其中金额较高的房屋​\",{\"1\":{\"432\":1}}],[\"边界条件为\",{\"1\":{\"432\":1}}],[\"只需在项目的\",{\"1\":{\"1858\":1}}],[\"只需要一些配置文件\",{\"1\":{\"1860\":1}}],[\"只需要一个线程负责selector轮询\",{\"1\":{\"1451\":1}}],[\"只需要这一行代码就可以完成根据姓名对于学生的分组操作\",{\"1\":{\"1490\":1}}],[\"只需要看看原来的hash值新增的哪个bit是1还是0就好了\",{\"1\":{\"1427\":1}}],[\"只需要把转帐任务\",{\"1\":{\"1378\":1}}],[\"只需要把这个event前后的两行信息对调以下\",{\"1\":{\"591\":1}}],[\"只需要唤醒一个线程\",{\"1\":{\"1360\":1}}],[\"只需要库名\",{\"1\":{\"600\":1}}],[\"只需要扫描1000次\",{\"1\":{\"493\":1}}],[\"只需要回主键索引取一次数据\",{\"1\":{\"487\":1}}],[\"只需要遍历\",{\"1\":{\"485\":1}}],[\"只需要对id4\",{\"1\":{\"477\":1}}],[\"只需要往后追加\",{\"1\":{\"469\":1}}],[\"只需要记录前一个值即可\",{\"1\":{\"430\":1}}],[\"只描述其行为\",{\"1\":{\"1488\":1}}],[\"只返回对象的supplier函数式接口的要求\",{\"1\":{\"1477\":1}}],[\"只不过这里每次只是取出来数组中唯一的元素\",{\"1\":{\"1495\":1}}],[\"只不过在某些场景下\",{\"1\":{\"1469\":1}}],[\"只不过存储的时候value默认存储了一个object的静态变量\",{\"1\":{\"1434\":1}}],[\"只不过对于驱动表s1也多了一个order\",{\"1\":{\"691\":1}}],[\"只不过对于驱动表s1多了一个order\",{\"1\":{\"691\":1}}],[\"只保留了后面的n位\",{\"1\":{\"1425\":1}}],[\"只许追加文件但不可以改写文件\",{\"1\":{\"728\":1}}],[\"只显示前n个\",{\"1\":{\"713\":1}}],[\"只支持开区间\",{\"1\":{\"711\":1}}],[\"只变动key\",{\"1\":{\"710\":1}}],[\"只存储索引\",{\"1\":{\"640\":1}}],[\"只读事务不分配trx\",{\"1\":{\"634\":1}}],[\"只给业务开发dml权限\",{\"1\":{\"624\":1}}],[\"只打开需要的项进行统计即可\",{\"1\":{\"616\":1}}],[\"只负责读取中转日志和分发事务\",{\"1\":{\"597\":1}}],[\"只切换备库\",{\"1\":{\"596\":1}}],[\"只会进入初始化后的阶段\",{\"1\":{\"1521\":1}}],[\"只会head\",{\"1\":{\"1498\":2}}],[\"只会根据输入元素来计算基数\",{\"1\":{\"714\":1}}],[\"只会记录id=4这个信息\",{\"1\":{\"591\":1}}],[\"只会write到文件系统的page\",{\"1\":{\"588\":1}}],[\"只会堵住在这个分区上执行的查询\",{\"1\":{\"561\":1}}],[\"只锁记录\",{\"1\":{\"579\":1}}],[\"只访问必要的分区\",{\"1\":{\"562\":1}}],[\"只访问索引的查询\",{\"1\":{\"506\":1}}],[\"只允许创建已经实现了本地分区策略的引擎\",{\"1\":{\"562\":1}}],[\"只插入了两行数据\",{\"1\":{\"561\":1}}],[\"只完成一小部分\",{\"1\":{\"530\":1}}],[\"只用到a\",{\"1\":{\"514\":2}}],[\"只用了0\",{\"1\":{\"485\":1}}],[\"只对一主一备的场景是成立的\",{\"1\":{\"609\":1}}],[\"只对原表的数据读了一遍\",{\"1\":{\"492\":1}}],[\"只对本线程有效\",{\"1\":{\"491\":1,\"558\":1}}],[\"只扫描这一行就结束了\",{\"1\":{\"487\":1}}],[\"只是分割一个近似平衡的树\",{\"1\":{\"1497\":1}}],[\"只是为了说明问题\",{\"1\":{\"1497\":1}}],[\"只是根据collector接口的要求\",{\"1\":{\"1493\":1}}],[\"只是这里我们调用新的方法reversed\",{\"1\":{\"1491\":1}}],[\"只是把时间分成若干段\",{\"1\":{\"1347\":1}}],[\"只是针对其中某个key的缓存不可用而导致击穿\",{\"1\":{\"766\":1}}],[\"只是中心位置不是具体的经纬度\",{\"1\":{\"713\":1}}],[\"只是需要再根据主键回到原表取数据\",{\"1\":{\"657\":1}}],[\"只是显示用的\",{\"1\":{\"634\":1}}],[\"只是对于mysql的kill命令来说\",{\"1\":{\"618\":1}}],[\"只是将a的更新都同步过来\",{\"1\":{\"590\":1}}],[\"只是简单的锁等待也会释放\",{\"1\":{\"581\":1}}],[\"只是刚好在这个语句中有limit\",{\"1\":{\"485\":1}}],[\"只是按顺序把\",{\"1\":{\"477\":1}}],[\"只能够在程序运行期间调用方法的符号引用转换为直接引用\",{\"1\":{\"1541\":1}}],[\"只能在流的终止操作之前进行调用\",{\"1\":{\"1496\":1}}],[\"只能在应用到包含12点的binlog文件的时候\",{\"1\":{\"622\":1}}],[\"只能返回一个结果\",{\"1\":{\"1475\":1}}],[\"只能消费者加机器\",{\"1\":{\"1413\":1}}],[\"只能选择有界队列\",{\"1\":{\"1396\":1}}],[\"只能从head取元素\",{\"1\":{\"1380\":1}}],[\"只能从id3开始一个个回表\",{\"1\":{\"477\":1}}],[\"只能保证一个共享变量原子操作\",{\"1\":{\"1356\":1}}],[\"只能有一条执行执行\",{\"1\":{\"1347\":1}}],[\"只能由字母a\",{\"1\":{\"761\":1}}],[\"只能由主节点复制到从节点\",{\"1\":{\"743\":1}}],[\"只能通过explain语句查看到最后优化器决定使用的执行计划\",{\"1\":{\"681\":1}}],[\"只能尽量将备份跨机房\",{\"1\":{\"625\":1}}],[\"只能删除固定后缀的表\",{\"1\":{\"624\":1}}],[\"只能说明这个库的进程还在\",{\"1\":{\"613\":1}}],[\"只能取到一个大概位置\",{\"1\":{\"604\":1}}],[\"只能到所有的分区中去查找满足条件的所有行\",{\"1\":{\"548\":1}}],[\"只能自己计数\",{\"1\":{\"533\":1}}],[\"只能用\",{\"1\":{\"477\":1}}],[\"只有aspectj才有\",{\"1\":{\"1531\":1}}],[\"只有ab\",{\"1\":{\"693\":1}}],[\"只有finisher没有被调用\",{\"1\":{\"1494\":1}}],[\"只有无序的数据源才可以使用这个属性\",{\"1\":{\"1494\":1}}],[\"只有当流的元是一个io通道的时候\",{\"1\":{\"1496\":1}}],[\"只有当终止操作开始的时候\",{\"1\":{\"1496\":1}}],[\"只有当开启并行流\",{\"1\":{\"1494\":1}}],[\"只有当特性值设置为unordered的时候\",{\"1\":{\"1492\":1}}],[\"只有当表达式中具有reduce这样的终止操作的方法的时候\",{\"1\":{\"1484\":1}}],[\"只有当某一个已经存在的方法\",{\"1\":{\"1480\":1}}],[\"只有操作系统提供sendfile这样的零拷贝系统调用方法\",{\"1\":{\"1465\":1}}],[\"只有数组对象有\",{\"1\":{\"1361\":1}}],[\"只有从未出现过并发冲突的时候\",{\"1\":{\"1357\":1}}],[\"只有两个简单的bean\",{\"1\":{\"720\":1}}],[\"只有两种选择\",{\"1\":{\"610\":1}}],[\"只有在达到了线程池最大线程数的时候才会将任务放入到阻塞队列\",{\"1\":{\"1567\":1}}],[\"只有在激活状态下才可以接收数据\",{\"1\":{\"1500\":1}}],[\"只有在流源这个阶段才有效\",{\"1\":{\"1498\":1}}],[\"只有在父进程或者子进程需要写入的时候才会复制地址空间\",{\"1\":{\"1404\":1}}],[\"只有在字段\",{\"1\":{\"710\":1}}],[\"只有在串行化的隔离级别下\",{\"1\":{\"677\":1}}],[\"只有等到满足进入innodb的条件后\",{\"1\":{\"618\":1}}],[\"只有一个线程能执行\",{\"1\":{\"1367\":1}}],[\"只有一个worker线程在工作\",{\"1\":{\"601\":1}}],[\"只有一个索引\",{\"1\":{\"472\":1}}],[\"只有主键id还是不够的\",{\"1\":{\"599\":1}}],[\"只有最终一致性是不够的\",{\"1\":{\"593\":1}}],[\"只有sql的执行时间>10才会被记录\",{\"1\":{\"565\":1}}],[\"只有innodb和ndb这两个引擎支持了本地分区策略\",{\"1\":{\"562\":1}}],[\"只有要排序的列\",{\"1\":{\"492\":1}}],[\"只有再新建的连接才会使用新的权限设置\",{\"1\":{\"455\":1}}],[\"只检索给定范围的行\",{\"1\":{\"467\":1}}],[\"只要掌握最常用的数据结构以及一些经典的算法题目即可\",{\"1\":{\"1848\":1}}],[\"只要给定的bean对象\",{\"1\":{\"1529\":1}}],[\"只要是调用代理对象的方法\",{\"1\":{\"1507\":1}}],[\"只要还有元素\",{\"1\":{\"1500\":1}}],[\"只要它的hashcode方法返回值相同\",{\"1\":{\"1425\":1}}],[\"只要它的两个字母相同\",{\"1\":{\"428\":1}}],[\"只要r1\",{\"1\":{\"1394\":1}}],[\"只要有一个成功就返回结果\",{\"1\":{\"1394\":1}}],[\"只要有一个成功返回\",{\"1\":{\"1394\":1}}],[\"只要有对一个表的更新\",{\"1\":{\"456\":1}}],[\"只要没有writer线程\",{\"1\":{\"1375\":1}}],[\"只要没有也别大的索引\",{\"1\":{\"563\":1}}],[\"只要实体类进行了序列化\",{\"1\":{\"720\":1}}],[\"只要实现按行分发\",{\"1\":{\"599\":1}}],[\"只要相隔不大于10个页面即可\",{\"1\":{\"686\":1}}],[\"只要一个mysql服务跑得足够久\",{\"1\":{\"634\":1}}],[\"只要定义了表示这个数的字节长度\",{\"1\":{\"630\":1}}],[\"只要不是恶意地把整个集群删除\",{\"1\":{\"625\":1}}],[\"只要能够达到redo\",{\"1\":{\"602\":1}}],[\"只要主库执行更新生成的所有binlog\",{\"1\":{\"593\":1}}],[\"只要where条件后面有函数操作都会导致无法使用索引快速定位的功能\",{\"1\":{\"503\":1}}],[\"只要找到满足条件的前1000条记录就可以退出了\",{\"1\":{\"493\":1}}],[\"只要city的值是杭州\",{\"1\":{\"493\":1}}],[\"只要满足最左前缀\",{\"1\":{\"476\":1}}],[\"只要\",{\"1\":{\"428\":1}}],[\"只要将他们各自的代表比较一下就可以了\",{\"1\":{\"356\":1}}],[\"新特性\",{\"1\":{\"1844\":1}}],[\"新生代大小\",{\"1\":{\"1541\":1}}],[\"新建一个节点\",{\"1\":{\"1380\":1}}],[\"新建的对象也是不可偏向的\",{\"1\":{\"1362\":1}}],[\"新创建对象的mark\",{\"1\":{\"1362\":1}}],[\"新增\",{\"1\":{\"1431\":1}}],[\"新增内容\",{\"1\":{\"708\":1}}],[\"新增参数innodb\",{\"1\":{\"629\":1}}],[\"新写入的行就会覆盖原有的行\",{\"1\":{\"632\":1}}],[\"新加的这条update语句就是把它认为加上了锁的这一行的d的值修改成了100\",{\"1\":{\"584\":1}}],[\"新插入的行\",{\"1\":{\"583\":1}}],[\"新的spliterator可能可以进一步分割\",{\"1\":{\"1497\":1}}],[\"新的自增值的生成算法是\",{\"1\":{\"628\":1}}],[\"新的商品\",{\"1\":{\"608\":1}}],[\"新的算法放入sort\",{\"1\":{\"492\":1}}],[\"新的值变成当前值\",{\"1\":{\"429\":1}}],[\"新元素\",{\"1\":{\"307\":1}}],[\"原型bean的销毁方法并不会被spring所调用\",{\"1\":{\"1524\":1}}],[\"原型模式\",{\"0\":{\"998\":1}}],[\"原生的子类型的特化也提供了\",{\"1\":{\"1497\":1}}],[\"原始文件\",{\"1\":{\"1465\":1}}],[\"原索引+oldcap\",{\"1\":{\"1427\":1}}],[\"原索引放到bucket里\",{\"1\":{\"1427\":1}}],[\"原索引\",{\"1\":{\"1427\":3}}],[\"原子消息广播协议\",{\"1\":{\"1869\":1}}],[\"原子变量\",{\"1\":{\"1359\":1}}],[\"原子类型累加器\",{\"1\":{\"1357\":1}}],[\"原子性\",{\"0\":{\"1349\":1},\"1\":{\"1347\":1,\"1351\":1}}],[\"原理和功能都是类似的\",{\"1\":{\"1497\":1}}],[\"原理图如下所示\",{\"1\":{\"1397\":1}}],[\"原理分析\",{\"0\":{\"1391\":1}}],[\"原理\",{\"0\":{\"736\":1}}],[\"原来min\",{\"1\":{\"1487\":1}}],[\"原来使用的\",{\"1\":{\"720\":1}}],[\"原来节点b是a的从库\",{\"1\":{\"604\":1}}],[\"原来的方式创建线程\",{\"1\":{\"1468\":1}}],[\"原来的写法\",{\"1\":{\"1468\":1}}],[\"原来的索引idx\",{\"1\":{\"498\":1}}],[\"原来的值变成前一个元素\",{\"1\":{\"429\":1}}],[\"原因就在于groupingbyconcurrent使用的是concurrenthashmap\",{\"1\":{\"1495\":1}}],[\"原因就在于虽然我们采用的是链式的调用\",{\"1\":{\"1489\":1}}],[\"原因就在于\",{\"1\":{\"1487\":1,\"1491\":1}}],[\"原因就在于这里我们使用map返回的类型实际上变成了string\",{\"1\":{\"1486\":1}}],[\"原因是流本身就是无序的\",{\"1\":{\"1496\":1}}],[\"原因是显而易见的\",{\"1\":{\"1475\":1}}],[\"原因是当前binlog设置的是statement格式\",{\"1\":{\"591\":1}}],[\"原因\",{\"1\":{\"1413\":3}}],[\"原因与入队同理\",{\"1\":{\"1380\":1}}],[\"原因有二\",{\"1\":{\"575\":1}}],[\"原因在于数字是值类型的\",{\"1\":{\"1495\":1}}],[\"原因在于扫描整个索引并没有查找到没索引的行\",{\"1\":{\"659\":1}}],[\"原因在于\",{\"1\":{\"345\":1}}],[\"原本spring会在初始化后进行aop操作\",{\"1\":{\"1526\":1}}],[\"原本三行的代码现在仅仅需要一行就能实现\",{\"1\":{\"1470\":1}}],[\"原本语句需要执行2\",{\"1\":{\"485\":1}}],[\"原本放在一个页的数据\",{\"1\":{\"472\":1}}],[\"原则\",{\"1\":{\"472\":1}}],[\"实模式\",{\"0\":{\"787\":1}}],[\"实数乘以相应的倍数后再操作\",{\"1\":{\"665\":1}}],[\"实例方法名引用\",{\"0\":{\"1482\":1}}],[\"实例方法引用\",{\"0\":{\"1481\":1}}],[\"实例代码如下\",{\"1\":{\"1465\":1}}],[\"实例数据\",{\"1\":{\"1361\":2}}],[\"实例化懒加载的bean\",{\"1\":{\"1528\":1}}],[\"实例化bean对象\",{\"1\":{\"1527\":1}}],[\"实例化bean的方式\",{\"0\":{\"1091\":1}}],[\"实例化方法\",{\"1\":{\"1524\":1}}],[\"实例化前方法\",{\"1\":{\"1524\":1}}],[\"实例化前\",{\"1\":{\"1524\":1}}],[\"实例化前阶段\",{\"0\":{\"1161\":1}}],[\"实例化阶段\",{\"0\":{\"1162\":1}}],[\"实例化\",{\"0\":{\"1160\":1},\"1\":{\"1524\":2}}],[\"实例可以在多个线程中共享\",{\"1\":{\"720\":1}}],[\"实例a\",{\"1\":{\"605\":1}}],[\"实例b吧set\",{\"1\":{\"605\":1}}],[\"实例b指定主库a\",{\"1\":{\"605\":1}}],[\"实例b的gtid集合记为set\",{\"1\":{\"605\":1}}],[\"实例x作为y的从库\",{\"1\":{\"605\":1}}],[\"实现网站uv和dau统计\",{\"1\":{\"1865\":1}}],[\"实现java\",{\"1\":{\"1561\":1}}],[\"实现stw\",{\"0\":{\"1555\":1}}],[\"实现者必须按照servlet规范实现接口\",{\"1\":{\"1535\":1}}],[\"实现deferredimportselector接口的类\",{\"1\":{\"1529\":1}}],[\"实现应该对于spliterator方法所返回的spliterator特性值进行文档化\",{\"1\":{\"1497\":1}}],[\"实现collector\",{\"1\":{\"1495\":1}}],[\"实现是可以自由的实现\",{\"1\":{\"1492\":1}}],[\"实现runnable接口\",{\"1\":{\"1468\":1}}],[\"实现代码如下\",{\"1\":{\"1464\":1}}],[\"实现的拷贝\",{\"1\":{\"1460\":1}}],[\"实现的\",{\"1\":{\"1423\":1}}],[\"实现的无界阻塞队列\",{\"1\":{\"1378\":1}}],[\"实现了mergedbeandefinitionpostprocessor接口的beanpostprocessor的postprocessmergedbeandefinition会被放到最后再执行\",{\"1\":{\"1529\":1}}],[\"实现了map\",{\"1\":{\"1423\":1}}],[\"实现了configurablelistablebeanfactory接口和beandefinitionregistry接口\",{\"1\":{\"1513\":1}}],[\"实现了configurablebeanfactory接口\",{\"1\":{\"1513\":1}}],[\"实现了autowirecapablebeanfactory\",{\"1\":{\"1513\":1}}],[\"实现了aliasregistry接口中所定义的功能\",{\"1\":{\"1513\":1}}],[\"实现了singletonbeanregistry接口\",{\"1\":{\"1513\":1}}],[\"实现了基于事件驱动的生产者消费者模型\",{\"1\":{\"1396\":1}}],[\"实现了任务先完成可以优先获取到\",{\"1\":{\"1394\":1}}],[\"实现了隔离\",{\"1\":{\"1378\":1}}],[\"实现了union的语义\",{\"1\":{\"551\":1}}],[\"实现\",{\"0\":{\"1836\":1},\"1\":{\"1373\":1}}],[\"实现原理\",{\"0\":{\"884\":1}}],[\"实现与原理分析\",{\"0\":{\"824\":1}}],[\"实现哨兵模式的配置其实是很麻烦的\",{\"1\":{\"761\":1}}],[\"实现上\",{\"1\":{\"618\":1}}],[\"实现这个需求最简单的实现方式\",{\"1\":{\"556\":1}}],[\"实践中\",{\"1\":{\"548\":1}}],[\"实践中可以使用count\",{\"1\":{\"489\":1}}],[\"实际使用的时候\",{\"1\":{\"1486\":1,\"1487\":1,\"1492\":1}}],[\"实际使用的索引\",{\"1\":{\"467\":1}}],[\"实际使用时\",{\"1\":{\"559\":1}}],[\"实际场景中\",{\"1\":{\"489\":1}}],[\"实际上调用处理程序之后调用\",{\"1\":{\"1534\":1}}],[\"实际上指的就是中间操作返回的新的流对象\",{\"1\":{\"1496\":1}}],[\"实际上是一种设计上的考量\",{\"1\":{\"1493\":1}}],[\"实际上是把这些统计数据存储到了两个表里\",{\"1\":{\"695\":1}}],[\"实际上就是除了预先定义好的收集器\",{\"1\":{\"1492\":1}}],[\"实际上就是求深度遍历的次数\",{\"1\":{\"435\":1}}],[\"实际上这个是在并行中使用的\",{\"1\":{\"1492\":1}}],[\"实际上这两个静态方法放在任何一个类中\",{\"1\":{\"1482\":1}}],[\"实际上这两个概念是完全不同的\",{\"1\":{\"546\":1}}],[\"实际上并不是这样的\",{\"1\":{\"1488\":1}}],[\"实际上并不会起到很好的效果\",{\"1\":{\"1387\":1}}],[\"实际上在框架的底层就已经帮我们实现了\",{\"1\":{\"1489\":1}}],[\"实际上在stream出现之前的都称之为外部迭代\",{\"1\":{\"1488\":1}}],[\"实际上在collectors中有一种更为简洁的实现方案\",{\"1\":{\"1486\":1}}],[\"实际上在mysql中\",{\"1\":{\"504\":1}}],[\"实际上也可以n个的串联\",{\"1\":{\"1475\":1}}],[\"实际上也只有普通索引可以使用\",{\"1\":{\"480\":1}}],[\"实际上对于java这一门非常庞大臃肿的语言\",{\"1\":{\"1470\":1}}],[\"实际上程序运行过程中\",{\"1\":{\"1438\":1}}],[\"实际上表示cmpxchg\",{\"1\":{\"1356\":1}}],[\"实际上每种数据结构都有自己底层的内部编码实现\",{\"1\":{\"706\":1}}],[\"实际上每次只需要存储最近的两个结果即可\",{\"1\":{\"429\":1}}],[\"实际上插入的数据就是\",{\"1\":{\"629\":1}}],[\"实际上往表t2插入了4行数据\",{\"1\":{\"629\":1}}],[\"实际上使用innodb引擎并不会出现这个问题\",{\"1\":{\"562\":1}}],[\"实际上它表示的就是每个引擎用来唯一标识数据行的信息\",{\"1\":{\"557\":1}}],[\"实际上它是可以持久化的数据\",{\"1\":{\"480\":1}}],[\"实际上可以通过设置参数binlog\",{\"1\":{\"550\":1}}],[\"实际上mysql却是先返回全部结果集再进行计算\",{\"1\":{\"520\":1}}],[\"实际上mysql服务端从排序后的sort\",{\"1\":{\"492\":1}}],[\"实际上要优化其子任务\",{\"1\":{\"518\":1}}],[\"实际上\",{\"1\":{\"503\":2,\"505\":1,\"533\":1,\"534\":1,\"555\":1,\"558\":1,\"561\":1,\"562\":1,\"563\":1,\"571\":1,\"588\":1,\"613\":2,\"619\":1,\"627\":1,\"632\":1,\"1438\":1,\"1447\":1,\"1453\":1,\"1457\":1,\"1469\":1,\"1470\":3,\"1472\":1,\"1477\":1,\"1482\":1,\"1484\":1,\"1490\":1,\"1500\":1}}],[\"实际上我们无需记录所有的中间状态\",{\"1\":{\"430\":1}}],[\"实战技巧\",{\"0\":{\"315\":1}}],[\"还提供了\",{\"1\":{\"1535\":1}}],[\"还提供了国际化\",{\"1\":{\"1513\":1}}],[\"还提供了一些额外的信息\",{\"1\":{\"1500\":1}}],[\"还涉及到了另外一个及其重要的类sink\",{\"1\":{\"1499\":1}}],[\"还在打印集合中的元素\",{\"1\":{\"1494\":1}}],[\"还在这个数据基础上做了操作\",{\"1\":{\"669\":1}}],[\"还更差一些\",{\"1\":{\"1442\":1}}],[\"还没有的话\",{\"1\":{\"1524\":1}}],[\"还没有收到一个完整的udp包\",{\"1\":{\"1440\":1}}],[\"还没有使用\",{\"1\":{\"456\":1}}],[\"还负责把写命令同步给从节点\",{\"1\":{\"755\":1}}],[\"还给行两边的空袭\",{\"1\":{\"585\":1}}],[\"还同时加了7个间隙锁\",{\"1\":{\"585\":1}}],[\"还包含了数据和日志在逻辑上的一致性\",{\"1\":{\"584\":1}}],[\"还要经过优化器的处理\",{\"1\":{\"651\":1}}],[\"还要主动去主库执行show\",{\"1\":{\"611\":1}}],[\"还要有地方保存表数据\",{\"1\":{\"549\":1}}],[\"还要把值取出来再判断以下\",{\"1\":{\"536\":1}}],[\"还要写到磁盘上\",{\"1\":{\"471\":1}}],[\"还不只是丢失更新的问题\",{\"1\":{\"534\":1}}],[\"还会比较有成就感\",{\"1\":{\"1871\":1}}],[\"还会导致性能下降\",{\"1\":{\"1362\":1}}],[\"还会造成一段时间内服务不可用\",{\"1\":{\"756\":1}}],[\"还会影响并发插入的性能\",{\"1\":{\"629\":1}}],[\"还会返回一些其他结果\",{\"1\":{\"610\":1}}],[\"还会对系统有什么影响呢\",{\"1\":{\"543\":1}}],[\"还会为服务器带来额外的i\",{\"1\":{\"522\":1}}],[\"还会判断这个语句本身要扫描的行数\",{\"1\":{\"484\":1}}],[\"还需要学习设计模式\",{\"1\":{\"1870\":1}}],[\"还需要命令其他从节点去复制新的主节点\",{\"1\":{\"758\":1}}],[\"还需要做两件事儿\",{\"1\":{\"686\":1}}],[\"还需要根据成本和磁盘空间资源\",{\"1\":{\"622\":1}}],[\"还需要专门清理中间过程中生成的数据表\",{\"1\":{\"547\":1}}],[\"还需要合理的设计查询\",{\"1\":{\"518\":1}}],[\"还需要经过优化器的处理\",{\"1\":{\"458\":1}}],[\"还可能会导致覆盖索引失效\",{\"1\":{\"488\":1}}],[\"还可以很方便的协作开发\",{\"1\":{\"1859\":1}}],[\"还可以阅读\",{\"1\":{\"1847\":1}}],[\"还可以通过\",{\"1\":{\"1531\":1}}],[\"还可以通过sequential\",{\"1\":{\"1496\":1}}],[\"还可以拼接前缀和后缀\",{\"1\":{\"1493\":1}}],[\"还可以调用有参数的构造方法\",{\"1\":{\"1483\":1}}],[\"还可以使用逗号分隔\",{\"1\":{\"1493\":1}}],[\"还可以使用collector中的of方法\",{\"1\":{\"1492\":1}}],[\"还可以使用自旋来进行优化\",{\"1\":{\"1362\":1}}],[\"还可以使用set\",{\"1\":{\"575\":1}}],[\"还可以大大减少删除时锁的持有时间\",{\"1\":{\"530\":1}}],[\"还可以更进一步\",{\"1\":{\"493\":1}}],[\"还可以将语句修改为\",{\"1\":{\"485\":1}}],[\"还可以多开一维数组来存每次偷或者不偷的状态\",{\"1\":{\"431\":1}}],[\"还可以进一步优化\",{\"1\":{\"429\":1}}],[\"还是比较吃力的\",{\"1\":{\"1850\":1}}],[\"还是回到最开始的入口这里\",{\"1\":{\"1498\":1}}],[\"还是stream的方式更加简洁明了\",{\"1\":{\"1488\":1}}],[\"还是返回optional对象\",{\"1\":{\"1487\":1}}],[\"还是无法理解lambda表达式到底可以帮我们做哪些事情\",{\"1\":{\"1484\":1}}],[\"还是myinterface2中的默认方法mymethod\",{\"1\":{\"1484\":1}}],[\"还是只有一个抽象方法\",{\"1\":{\"1472\":1}}],[\"还是只需要\",{\"1\":{\"1386\":1}}],[\"还是代码的执行速度上来看\",{\"1\":{\"1469\":1}}],[\"还是使用传统的面向对象的编程方式\",{\"1\":{\"1468\":1}}],[\"还是使用表t1执行如下sql语句\",{\"1\":{\"553\":1}}],[\"还是引入零拷贝之后\",{\"1\":{\"1462\":1}}],[\"还是\",{\"1\":{\"1356\":1}}],[\"还是运行时\",{\"0\":{\"1266\":1}}],[\"还是可以间接找到它的\",{\"1\":{\"1438\":1}}],[\"还是可以加速查询的效率\",{\"1\":{\"541\":1}}],[\"还是可能达到这个上限的\",{\"1\":{\"632\":1}}],[\"还是4294967295\",{\"1\":{\"631\":1}}],[\"还是这个语句\",{\"1\":{\"629\":1}}],[\"还是把临时库接到备库上\",{\"1\":{\"622\":1}}],[\"还是要算进并发线程的计数的\",{\"1\":{\"613\":1}}],[\"还是要把两张表放在一起\",{\"1\":{\"598\":1}}],[\"还是会修改成功\",{\"1\":{\"1356\":1}}],[\"还是会存在缓存层和存储层的数据会有一段时间窗口的不一致\",{\"1\":{\"764\":1}}],[\"还是会出现同一个binlog里面出现相同xid的场景\",{\"1\":{\"633\":1}}],[\"还是会出现过期读\",{\"1\":{\"608\":1}}],[\"还是会继续等待\",{\"1\":{\"618\":1}}],[\"还是会很大\",{\"1\":{\"581\":1}}],[\"还是3天后用来恢复这个库的备库\",{\"1\":{\"591\":1}}],[\"还是阻止不了新插入的记录\",{\"1\":{\"584\":1}}],[\"还是阻止不了id=1这一行的插入和更新呢\",{\"1\":{\"584\":1}}],[\"还是应该使用ftwrl\",{\"1\":{\"575\":1}}],[\"还是一定要进行排序的操作\",{\"1\":{\"555\":1}}],[\"还是用有索引的临时表\",{\"1\":{\"544\":1}}],[\"还是用自增字段做主键呢\",{\"1\":{\"472\":1}}],[\"还是按照name字段的值递增排序的\",{\"1\":{\"493\":1}}],[\"还是以卖家发布商品为例\",{\"1\":{\"608\":1}}],[\"还是以后用binlog克隆\",{\"1\":{\"584\":1}}],[\"还是以市民表为例\",{\"1\":{\"493\":1}}],[\"还是以我们前面举例用过的市民表为例\",{\"1\":{\"490\":1}}],[\"还是上面根据身份证号查询名字的例子\",{\"1\":{\"470\":1}}],[\"还有阿里开源dubbo\",{\"1\":{\"1868\":1}}],[\"还有后端\",{\"1\":{\"1856\":1}}],[\"还有request\",{\"1\":{\"1524\":1}}],[\"还有可能会出现如下报错\",{\"1\":{\"1494\":1}}],[\"还有很多的其他的函数式接口\",{\"1\":{\"1478\":1}}],[\"还有很多一对多的数据结构\",{\"1\":{\"337\":1}}],[\"还有\",{\"1\":{\"1476\":1,\"1870\":1}}],[\"还有两个默认方法\",{\"1\":{\"1475\":1}}],[\"还有两种场景会让一个没有提交的事务的redo\",{\"1\":{\"588\":1}}],[\"还有最后一段话\",{\"1\":{\"1471\":1}}],[\"还有意向锁\",{\"1\":{\"670\":1}}],[\"还有由于io压力过大\",{\"1\":{\"618\":1}}],[\"还有其他唯一索引\",{\"1\":{\"602\":1}}],[\"还有唯一索引a\",{\"1\":{\"599\":1}}],[\"还有数据一致性的问题\",{\"1\":{\"584\":1}}],[\"还有一些连接池相关的配置\",{\"1\":{\"720\":1}}],[\"还有一个终止阶段\",{\"1\":{\"1500\":1}}],[\"还有一个例子\",{\"1\":{\"1485\":1}}],[\"还有一个default默认方法andthen\",{\"1\":{\"1471\":1}}],[\"还有一个\",{\"1\":{\"591\":1}}],[\"还有一个关键的参数λ\",{\"1\":{\"540\":1}}],[\"还有一种有序的遍历\",{\"1\":{\"1500\":1}}],[\"还有一种情况是\",{\"1\":{\"617\":1}}],[\"还有一种架构是\",{\"1\":{\"606\":1}}],[\"还有一种叫做mixed\",{\"1\":{\"591\":1}}],[\"还有一种相对比较简单的写法\",{\"1\":{\"386\":1}}],[\"还有什么方式可以保障线程安全\",{\"0\":{\"92\":1}}],[\"得保证查询至少达到range级别\",{\"1\":{\"467\":1}}],[\"得到servletresponse\",{\"1\":{\"1565\":1}}],[\"得到seconds\",{\"1\":{\"594\":1}}],[\"得到一个classmetadata\",{\"1\":{\"1523\":1}}],[\"得到一个平均值\",{\"1\":{\"484\":1}}],[\"得到数组下标\",{\"1\":{\"1423\":1}}],[\"得到数组里面的不同值\",{\"1\":{\"555\":1}}],[\"得到总共需要回表的记录数之后\",{\"1\":{\"686\":1}}],[\"得到t时刻的位点\",{\"1\":{\"604\":1}}],[\"得到当前a\",{\"1\":{\"604\":1}}],[\"得到按照时间排序的前10条里面含有左连接的查询语句\",{\"1\":{\"566\":1}}],[\"得到访问次数最多的10个sql\",{\"1\":{\"566\":1}}],[\"得到返回记录集最多的10个sql\",{\"1\":{\"566\":1}}],[\"得到结果集返回给客户端\",{\"1\":{\"553\":1}}],[\"得到1000这个值\",{\"1\":{\"551\":1}}],[\"得到的记录是排过序的\",{\"1\":{\"1421\":1}}],[\"得到的索引行里的age和position是无序的\",{\"1\":{\"655\":1}}],[\"得到的值保持不变\",{\"1\":{\"631\":1}}],[\"得到的就是预期结果了\",{\"1\":{\"609\":1}}],[\"得到的结果直接作为结果集的一部分\",{\"1\":{\"551\":1}}],[\"得到的\",{\"1\":{\"549\":1}}],[\"得到最新结果的过程称为merge\",{\"1\":{\"480\":1}}],[\"得到最低位的1\",{\"1\":{\"315\":1}}],[\"得到id的值为500\",{\"1\":{\"472\":1}}],[\"得到新的一行数据\",{\"1\":{\"463\":1}}],[\"得\",{\"1\":{\"428\":1}}],[\"枚举左边界\",{\"1\":{\"428\":1}}],[\"枚举类\",{\"0\":{\"278\":1}}],[\"∧\",{\"1\":{\"428\":1}}],[\"示意图如下\",{\"1\":{\"609\":1}}],[\"示意图如下所示\",{\"1\":{\"470\":1}}],[\"示意图\",{\"1\":{\"427\":1}}],[\"示例表\",{\"1\":{\"660\":1}}],[\"示例如下\",{\"1\":{\"549\":1}}],[\"示例\",{\"0\":{\"735\":1},\"1\":{\"313\":1,\"707\":1}}],[\"​只有一间房屋\",{\"1\":{\"432\":1}}],[\"​如果字串si​\",{\"1\":{\"428\":2}}],[\"​\",{\"1\":{\"427\":1}}],[\"​text1​\",{\"1\":{\"427\":1}}],[\"=text2​\",{\"1\":{\"427\":1}}],[\"由浅入深的学习就会轻松一些\",{\"1\":{\"1871\":1}}],[\"由这个动作抛出的异常会被传递给调用者\",{\"1\":{\"1497\":1}}],[\"由这个动作执行产生的任何的异常都会传递给调用者\",{\"1\":{\"1497\":1}}],[\"由内核程序来进行操作\",{\"1\":{\"1456\":1}}],[\"由条件队列转移到同步队列\",{\"1\":{\"1368\":1}}],[\"由主节点进行写操作\",{\"1\":{\"744\":1}}],[\"由proxy根据请求类型和上下文决定请求的分发路由\",{\"1\":{\"606\":1}}],[\"由客户端来选择后端数据库进行查询\",{\"1\":{\"606\":1}}],[\"由参数slave\",{\"1\":{\"602\":1}}],[\"由慢查询日志来查看哪些sql超出了我们的最大忍耐时间值\",{\"1\":{\"565\":1}}],[\"由定义\",{\"1\":{\"540\":1}}],[\"由\",{\"1\":{\"428\":1}}],[\"由此可知\",{\"1\":{\"509\":1}}],[\"由此可见\",{\"1\":{\"499\":1,\"508\":1}}],[\"由此\",{\"1\":{\"426\":1}}],[\"由于算法会用到数据结构的相关知识\",{\"1\":{\"1848\":1}}],[\"由于i\",{\"1\":{\"1565\":1}}],[\"由于innodb对buffer\",{\"1\":{\"543\":1}}],[\"由于调整元空间的大小需要full\",{\"1\":{\"1541\":1}}],[\"由于自动拆箱和自动装箱的原因存在\",{\"1\":{\"1497\":1}}],[\"由于中间结果类型一定是<k\",{\"1\":{\"1495\":1}}],[\"由于所有的匿名内部类又可以使用lambda表达式来进行替换\",{\"1\":{\"1474\":1}}],[\"由于所有线程处于等待状态\",{\"1\":{\"613\":1}}],[\"由于test\",{\"1\":{\"1472\":1}}],[\"由于table\",{\"1\":{\"550\":1}}],[\"由于函数式接口中只会有一个抽象方法\",{\"1\":{\"1472\":1}}],[\"由于客户端比较简单我这里使用了嵌套类部类\",{\"1\":{\"1452\":1}}],[\"由于新增的1bit是0还是1可以认为是随机的\",{\"1\":{\"1427\":1}}],[\"由于融入了红黑树\",{\"1\":{\"1427\":1}}],[\"由于length\",{\"1\":{\"1425\":1}}],[\"由于limit后面的参数不能直接跟变量\",{\"1\":{\"559\":1}}],[\"由于无锁\",{\"1\":{\"1404\":1}}],[\"由于拥有两把锁\",{\"1\":{\"1386\":1}}],[\"由于虚拟机要求对象起始地址必须是8字节的整数倍\",{\"1\":{\"1361\":1}}],[\"由于代码的执行序列不同而导致结果无法预测\",{\"1\":{\"1359\":1}}],[\"由于cpu的速度远高于主内存\",{\"1\":{\"1351\":1}}],[\"由于newlist空了\",{\"1\":{\"708\":1}}],[\"由于n叉树在读写上的性能优点\",{\"1\":{\"471\":1}}],[\"由于没有共享\",{\"1\":{\"1405\":1}}],[\"由于没有多余的表进行连接\",{\"1\":{\"692\":1}}],[\"由于没有其它索引\",{\"1\":{\"472\":1}}],[\"由于使用idx\",{\"1\":{\"686\":1}}],[\"由于该列上只有联合索引\",{\"1\":{\"684\":1}}],[\"由于磁盘随机读写的相比顺序读写的性能是非常差的\",{\"1\":{\"680\":1}}],[\"由于低水位值会持续增加\",{\"1\":{\"634\":1}}],[\"由于此时系统的max\",{\"1\":{\"634\":1}}],[\"由于只读事务不分配trx\",{\"1\":{\"634\":1}}],[\"由于global\",{\"1\":{\"633\":1}}],[\"由于已经存在c=1的记录\",{\"1\":{\"628\":1}}],[\"由于等行锁\",{\"1\":{\"613\":1}}],[\"由于要了解后端的部署细节\",{\"1\":{\"606\":1}}],[\"由于不需要找位点了\",{\"1\":{\"605\":1}}],[\"由于不同担心线程之间的重名冲突\",{\"1\":{\"548\":1}}],[\"由于找不到精确的同步位点\",{\"1\":{\"604\":1}}],[\"由于同步了binlog\",{\"1\":{\"604\":1}}],[\"由于备库的分发策略不依赖于binlog内容\",{\"1\":{\"602\":1}}],[\"由于事务t中涉及修改表t1\",{\"1\":{\"598\":1}}],[\"由于事务没有提交\",{\"1\":{\"588\":1}}],[\"由于采用了可用性优先策略\",{\"1\":{\"596\":1}}],[\"由于主备延迟的存在\",{\"1\":{\"594\":1}}],[\"由于主库a\",{\"1\":{\"605\":1}}],[\"由于主库上必须等事务执行完成才会写入binlog\",{\"1\":{\"594\":1}}],[\"由于主库直接影响业务\",{\"1\":{\"594\":1}}],[\"由于主键索引是一颗b+树\",{\"1\":{\"541\":1}}],[\"由于\",{\"1\":{\"594\":1}}],[\"由于set集合本身是无序的\",{\"1\":{\"1495\":1}}],[\"由于segment对象是一把锁\",{\"1\":{\"1430\":1}}],[\"由于segment对象本身就是一把锁\",{\"1\":{\"1430\":1}}],[\"由于session是同时执行插入数据命令的\",{\"1\":{\"629\":1}}],[\"由于session\",{\"1\":{\"578\":1,\"584\":1}}],[\"由于statement格式下\",{\"1\":{\"591\":1}}],[\"由于需要打开所有的文件\",{\"1\":{\"562\":1}}],[\"由于mysql规定了主库和备库的server\",{\"1\":{\"615\":1}}],[\"由于myisam引擎只支持表锁\",{\"1\":{\"561\":1}}],[\"由于mvcc的支持\",{\"1\":{\"575\":1}}],[\"由于merge的时候是真正进行数据更新的时刻\",{\"1\":{\"481\":1}}],[\"由于分区表的规则\",{\"1\":{\"561\":1}}],[\"由于每次操作数据库\",{\"1\":{\"616\":1}}],[\"由于每一行的id\",{\"1\":{\"554\":1}}],[\"由于每个事务都不知道其他事务的存在\",{\"1\":{\"669\":1}}],[\"由于每个分库的计算量都不饱和\",{\"1\":{\"548\":1}}],[\"由于每个非主键索引的叶子节点上都是主键的值\",{\"1\":{\"472\":1}}],[\"由于查询成本=i\",{\"1\":{\"685\":1}}],[\"由于查询条件里面没有用到分区字段f\",{\"1\":{\"548\":1}}],[\"由于查询结果所需要的数据只在主键索引上有\",{\"1\":{\"474\":1}}],[\"由于临时表只能被创建它的session访问\",{\"1\":{\"547\":1}}],[\"由于表t1中的id的值是从1开始的\",{\"1\":{\"553\":1}}],[\"由于表t1被分成了两次放入join\",{\"1\":{\"540\":1}}],[\"由于表t2的字段上没有索引\",{\"1\":{\"539\":1}}],[\"由于join\",{\"1\":{\"540\":1}}],[\"由于我们设置了线程池大小和阻塞队列大小\",{\"1\":{\"1450\":1}}],[\"由于我们通过范围区间获取到二级索引记录共39条\",{\"1\":{\"686\":1}}],[\"由于我们一般会把数据库a和b的主备关系设计为双m结构\",{\"1\":{\"615\":1}}],[\"由于我们的join语句在循环读磁盘和淘汰内存页\",{\"1\":{\"543\":1}}],[\"由于我们在read\",{\"1\":{\"541\":1}}],[\"由于我们这个语句中写的是select\",{\"1\":{\"540\":1}}],[\"由于我们构造的数据都是一一对应的\",{\"1\":{\"538\":1}}],[\"由于多版本并发控制\",{\"1\":{\"533\":1}}],[\"由于这种引用转换过程具备动态性\",{\"1\":{\"1541\":1}}],[\"由于这条语句实际只用上了4个id\",{\"1\":{\"629\":1}}],[\"由于这些事务随时可能访问数据库里面的任何数据\",{\"1\":{\"571\":1}}],[\"由于这里convert函数是加在输入参数上的\",{\"1\":{\"505\":1}}],[\"由于这个数值特别大\",{\"1\":{\"1380\":1}}],[\"由于这个原因\",{\"1\":{\"1351\":1}}],[\"由于这个索引并不是唯一二级索引\",{\"1\":{\"690\":1}}],[\"由于这个事务并没有提交\",{\"1\":{\"588\":1}}],[\"由于这个优化机制的存在\",{\"1\":{\"543\":1}}],[\"由于这个查询语句并没有涉及到临时表和排序\",{\"1\":{\"484\":1}}],[\"由于这个语句的binlog丢失\",{\"1\":{\"464\":1}}],[\"由于在t1时刻\",{\"1\":{\"584\":1}}],[\"由于在t\",{\"1\":{\"503\":1}}],[\"由于校验码可能存在冲突\",{\"1\":{\"489\":1}}],[\"由于身份证号码的最后6位没有地址码这样的重复逻辑\",{\"1\":{\"489\":1}}],[\"由于身份证号字段比较大\",{\"1\":{\"478\":1}}],[\"由于email\",{\"1\":{\"487\":1}}],[\"由于是采样统计\",{\"1\":{\"484\":1}}],[\"由于引擎是按页读写的\",{\"1\":{\"479\":1}}],[\"由于索引定义了唯一性\",{\"1\":{\"479\":1}}],[\"由于覆盖索引可以减少树的搜索次数\",{\"1\":{\"475\":1}}],[\"由于redo\",{\"1\":{\"464\":2}}],[\"由于最开始的mysql并没有innodb引擎\",{\"1\":{\"462\":1}}],[\"由于传递性\",{\"1\":{\"415\":1}}],[\"由于它是查找树\",{\"1\":{\"346\":1}}],[\"由于贪心法的高效性以及其所求得得答案比较接近最优结果\",{\"1\":{\"293\":1}}],[\"优雅的处理集合相关的问题\",{\"1\":{\"1484\":1}}],[\"优雅的方式是让java线程自己执行完run\",{\"1\":{\"1401\":1}}],[\"优雅的停止线程\",{\"1\":{\"1354\":1}}],[\"优点和缺点\",{\"0\":{\"727\":1,\"730\":1}}],[\"优点\",{\"0\":{\"760\":1},\"1\":{\"726\":1,\"727\":1,\"730\":1}}],[\"优势是速度快\",{\"1\":{\"563\":1}}],[\"优先考虑注入不是自己的那个bean\",{\"1\":{\"1525\":1}}],[\"优先级\",{\"1\":{\"1525\":1}}],[\"优先级队列采用二叉堆的数据结构\",{\"1\":{\"1383\":1}}],[\"优先优化nestedloop的内层循环\",{\"1\":{\"501\":1}}],[\"优先队列排序地示意图如下\",{\"1\":{\"558\":1}}],[\"优先队列的插入操作时间复杂度是\",{\"1\":{\"353\":1}}],[\"优先队列\",{\"0\":{\"352\":1},\"1\":{\"353\":1,\"393\":1}}],[\"优化了高位运算的算法\",{\"1\":{\"1425\":1}}],[\"优化genericconverter接口\",{\"0\":{\"1251\":1}}],[\"优化原则\",{\"1\":{\"662\":1}}],[\"优化为\",{\"1\":{\"662\":1}}],[\"优化总结\",{\"1\":{\"657\":1}}],[\"优化本篇一开始的语句\",{\"1\":{\"559\":1}}],[\"优化后的group\",{\"1\":{\"554\":1}}],[\"优化查询的目的就是减少和消除这些操作所花费的时间\",{\"1\":{\"518\":1}}],[\"优化的关键是让排序时返回的字段经可能少\",{\"1\":{\"659\":1}}],[\"优化的常见做法是\",{\"1\":{\"543\":1}}],[\"优化的方式通常有两种\",{\"1\":{\"505\":1}}],[\"优化的思路大致分为两种\",{\"1\":{\"429\":1}}],[\"优化order\",{\"1\":{\"493\":1}}],[\"优化器需要从符合二级索引范围内区间的记录中猜有多少条记录符合条件order\",{\"1\":{\"691\":1}}],[\"优化器需要计算二级索引的某个范围区间到底包含多少条记录\",{\"1\":{\"686\":1}}],[\"优化器阶段完成后\",{\"1\":{\"651\":1}}],[\"优化器会放弃走树搜索功能\",{\"1\":{\"504\":1,\"505\":1}}],[\"优化器会估算这两个选择的代价\",{\"1\":{\"484\":1}}],[\"优化器对比索引大小后发现\",{\"1\":{\"503\":1}}],[\"优化器可以选择遍历主键索引\",{\"1\":{\"503\":1}}],[\"优化器并不是要放弃使用这个索引\",{\"1\":{\"503\":1}}],[\"优化器还会结合是否使用临时表\",{\"1\":{\"484\":1}}],[\"优化器选择索引的目的\",{\"1\":{\"484\":1}}],[\"优化器逻辑\",{\"0\":{\"484\":1}}],[\"优化器也选择了索引a\",{\"1\":{\"483\":1}}],[\"优化器的阶段完成后\",{\"1\":{\"458\":1}}],[\"优化器是在表里面有多个索引的时候\",{\"1\":{\"458\":1,\"651\":1}}],[\"优化器\",{\"0\":{\"458\":1,\"651\":1},\"1\":{\"454\":1}}],[\"优化\",{\"0\":{\"532\":1,\"541\":1,\"556\":1},\"1\":{\"424\":1,\"601\":1}}],[\"饼干数组的下标\",{\"1\":{\"422\":1}}],[\"本节我们就分析jdk已经帮我们实现的collector的例子\",{\"1\":{\"1495\":1}}],[\"本质就是一个巨大的\",{\"1\":{\"1858\":1}}],[\"本质就是一个映射\",{\"1\":{\"1423\":1}}],[\"本质是函数式的\",{\"1\":{\"1485\":1}}],[\"本质上而言\",{\"1\":{\"1484\":1}}],[\"本质上这个其实\",{\"1\":{\"1476\":1}}],[\"本质上都是调用thread\",{\"1\":{\"1354\":1}}],[\"本身是可变的\",{\"1\":{\"1495\":1}}],[\"本身是不存储任何元素的\",{\"1\":{\"1380\":1}}],[\"本身接受的是可变参数\",{\"1\":{\"1484\":1}}],[\"本身不合法\",{\"1\":{\"428\":1}}],[\"本身不是一个回文串\",{\"1\":{\"428\":1}}],[\"本条记录最后更新时间\",{\"1\":{\"695\":1}}],[\"本查询和查询四类似\",{\"1\":{\"691\":1}}],[\"本查询和查询二类似\",{\"1\":{\"691\":1}}],[\"本查询和查询一类似\",{\"1\":{\"691\":1}}],[\"本例中sql语句不满足索引合并的条件\",{\"1\":{\"687\":1}}],[\"本例中使用idx\",{\"1\":{\"686\":1}}],[\"本来申请id是一个很快的操作\",{\"1\":{\"628\":1}}],[\"本来是有索引的\",{\"1\":{\"504\":1}}],[\"本小节我们要讨论的是\",{\"1\":{\"612\":1}}],[\"本地方法栈\",{\"0\":{\"1582\":1}}],[\"本地线程分配缓冲\",{\"1\":{\"1545\":1}}],[\"本地是否包含了这个差集需要的所有binlog事务\",{\"1\":{\"605\":1}}],[\"本地记录的也是a的微店\",{\"1\":{\"604\":1}}],[\"本地resource\",{\"0\":{\"239\":1}}],[\"本题要求每一步只能移动到下一行相邻的结点上\",{\"1\":{\"426\":1}}],[\"本题中股票值买卖一次\",{\"1\":{\"419\":1}}],[\"剪枝\",{\"1\":{\"415\":1}}],[\"括号生成的状态树\",{\"1\":{\"415\":1}}],[\"层次性的messagesource\",{\"0\":{\"1212\":1}}],[\"层次性依赖查找\",{\"0\":{\"1103\":1}}],[\"层次遍历\",{\"1\":{\"339\":1}}],[\"层序遍历\",{\"1\":{\"411\":1}}],[\"简洁\",{\"1\":{\"1484\":1}}],[\"简洁一点的写法\",{\"1\":{\"406\":1}}],[\"简化之后的图\",{\"1\":{\"1561\":1}}],[\"简化\",{\"1\":{\"1356\":1}}],[\"简而言之\",{\"1\":{\"542\":1,\"672\":1,\"1472\":1,\"1491\":1}}],[\"简称mdl\",{\"1\":{\"576\":1}}],[\"简称bnl\",{\"1\":{\"539\":1}}],[\"简称nlj\",{\"1\":{\"538\":1}}],[\"简介\",{\"0\":{\"466\":1,\"827\":1,\"835\":1,\"843\":1,\"1466\":1,\"1502\":1,\"1504\":1,\"1558\":1,\"1674\":1}}],[\"简单\",{\"1\":{\"1453\":2}}],[\"简单来讲\",{\"1\":{\"1403\":1}}],[\"简单来说\",{\"1\":{\"464\":1,\"468\":1,\"569\":1,\"1430\":1,\"1488\":1}}],[\"简单介绍spring\",{\"0\":{\"1320\":1}}],[\"简单地说\",{\"1\":{\"1868\":1}}],[\"简单地通过判空来检查是否成功返回\",{\"1\":{\"1394\":1}}],[\"简单地\",{\"1\":{\"531\":1}}],[\"简单查询\",{\"0\":{\"529\":1}}],[\"简单的任务\",{\"1\":{\"1395\":1}}],[\"简单的select查询\",{\"1\":{\"467\":1}}],[\"简单的静态初始化\",{\"1\":{\"329\":1}}],[\"翻转二叉树\",{\"0\":{\"405\":1}}],[\"翻转字符串里的单词\",{\"0\":{\"385\":1}}],[\"画出的树形图如下所示\",{\"1\":{\"399\":1}}],[\"qingdao\",{\"1\":{\"1482\":1}}],[\"qinjiang\",{\"1\":{\"706\":1}}],[\"qmode=0\",{\"1\":{\"1360\":1}}],[\"qualifier\",{\"1\":{\"1525\":1}}],[\"quorum\",{\"1\":{\"761\":1}}],[\"quit\",{\"1\":{\"735\":1}}],[\"quick呢\",{\"1\":{\"619\":1}}],[\"quick参数的意思\",{\"1\":{\"619\":1}}],[\"quick参数\",{\"1\":{\"619\":1}}],[\"quick是一个更容易引起误会的参数\",{\"1\":{\"619\":1}}],[\"quick\",{\"1\":{\"619\":1}}],[\"quey\",{\"1\":{\"617\":1}}],[\"queried\",{\"1\":{\"1496\":2,\"1498\":1}}],[\"queries\",{\"1\":{\"565\":3,\"566\":1}}],[\"query或者kill\",{\"1\":{\"618\":1}}],[\"query状态\",{\"1\":{\"618\":1}}],[\"query以后\",{\"1\":{\"617\":1}}],[\"query命令时\",{\"1\":{\"618\":1}}],[\"query命令\",{\"1\":{\"617\":1}}],[\"query\",{\"1\":{\"483\":1,\"530\":1,\"557\":1,\"565\":20,\"566\":3,\"568\":8,\"617\":1,\"618\":8,\"633\":5,\"656\":1,\"663\":2,\"690\":2,\"692\":2,\"1496\":1,\"1497\":1}}],[\"queery\",{\"1\":{\"455\":1}}],[\"queens\",{\"1\":{\"417\":10}}],[\"queue<e>\",{\"1\":{\"1377\":1}}],[\"queue<treenode>\",{\"1\":{\"396\":1,\"401\":1,\"402\":1,\"403\":1,\"404\":1,\"411\":1}}],[\"queue队列\",{\"0\":{\"1377\":1}}],[\"queued\",{\"1\":{\"716\":7,\"717\":7,\"718\":4}}],[\"queue\",{\"1\":{\"334\":1,\"335\":1,\"353\":1,\"393\":7,\"401\":7,\"402\":7,\"403\":7,\"404\":7,\"411\":7,\"558\":1,\"657\":4,\"1387\":2,\"1567\":3,\"1863\":1}}],[\"q4\",{\"1\":{\"550\":1}}],[\"q3读到id=1这一行的现象\",{\"1\":{\"583\":1}}],[\"q3\",{\"1\":{\"550\":1}}],[\"q2和q3\",{\"1\":{\"583\":1}}],[\"q2的rows的值是37116\",{\"1\":{\"484\":1}}],[\"q2扫描了10001行\",{\"1\":{\"483\":1}}],[\"q2是加了force\",{\"1\":{\"483\":1}}],[\"q2\",{\"1\":{\"483\":1,\"550\":1}}],[\"q1只返回id=5这一行\",{\"1\":{\"583\":1}}],[\"q1扫描了10万行\",{\"1\":{\"483\":1}}],[\"q1是session\",{\"1\":{\"483\":1}}],[\"q1\",{\"1\":{\"483\":1,\"550\":1}}],[\"qq\",{\"1\":{\"467\":1,\"710\":3}}],[\"q分属两侧\",{\"1\":{\"398\":1}}],[\"q在右子树\",{\"1\":{\"398\":1}}],[\"q在左子树\",{\"1\":{\"398\":1}}],[\"q为根节点\",{\"1\":{\"398\":1}}],[\"q\",{\"1\":{\"398\":7,\"417\":1,\"619\":1,\"714\":1}}],[\"q的最近公共祖先\",{\"1\":{\"398\":1}}],[\"q的公共祖先\",{\"1\":{\"398\":1}}],[\"q的某公共祖先\",{\"1\":{\"398\":1}}],[\"设定一个日志保留的天数\",{\"1\":{\"622\":1}}],[\"设置对象头\",{\"0\":{\"1546\":1}}],[\"设置元空间最大值\",{\"1\":{\"1541\":1}}],[\"设置堆的最大可用大小\",{\"1\":{\"1541\":1}}],[\"设置堆的初始可用大小\",{\"1\":{\"1541\":1}}],[\"设置dispatcherservlet的过滤器\",{\"1\":{\"1535\":1}}],[\"设置哪些方法不被代理\",{\"1\":{\"1531\":1}}],[\"设置classpathmapperscanner对象可以扫描到接口\",{\"1\":{\"1530\":1}}],[\"设置conn\",{\"1\":{\"1507\":1}}],[\"设置beanfactory的类加载器\",{\"1\":{\"1528\":1}}],[\"设置binlog\",{\"1\":{\"550\":1,\"588\":1}}],[\"设置一些基础属性\",{\"1\":{\"1528\":1}}],[\"设置类型转化服务\",{\"1\":{\"1513\":1}}],[\"设置连接模式为非阻塞模式\",{\"1\":{\"1451\":1}}],[\"设置多消费者\",{\"1\":{\"1398\":2}}],[\"设置消费者用于处理ringbuffer的事件\",{\"1\":{\"1398\":1}}],[\"设置队列的工作模式\",{\"1\":{\"1387\":1}}],[\"设置jvm参数\",{\"1\":{\"1362\":1}}],[\"设置不同的过期时间\",{\"1\":{\"770\":1}}],[\"设置热点数据永不过期\",{\"1\":{\"767\":1}}],[\"设置哨兵sentinel\",{\"1\":{\"761\":1}}],[\"设置余额\",{\"1\":{\"718\":1}}],[\"设置已存在的field\",{\"1\":{\"710\":1}}],[\"设置spring\",{\"1\":{\"1513\":1}}],[\"设置selector\",{\"1\":{\"1451\":1}}],[\"设置sex为1\",{\"1\":{\"710\":1}}],[\"设置sign的第2位为\",{\"1\":{\"715\":1}}],[\"设置sign的第0位为\",{\"1\":{\"715\":1}}],[\"设置studentx的age为20\",{\"1\":{\"710\":1}}],[\"设置name为sakura\",{\"1\":{\"710\":1}}],[\"设置哈希表字段的值\",{\"1\":{\"710\":1}}],[\"设置成功\",{\"1\":{\"706\":1}}],[\"设置成只读\",{\"1\":{\"590\":1}}],[\"设置键值对的过期时间\",{\"1\":{\"706\":2}}],[\"设置方式就是在创建或修改表的时候通过指定stats\",{\"1\":{\"696\":1}}],[\"设置方式就是在创建或修改表的时候通过stats\",{\"1\":{\"695\":1}}],[\"设置事务隔离级别\",{\"1\":{\"669\":1}}],[\"设置了这个参数\",{\"1\":{\"619\":1}}],[\"设置主库a的ip\",{\"1\":{\"590\":1}}],[\"设置阈值\",{\"1\":{\"567\":1}}],[\"设置为\",{\"1\":{\"1431\":1}}],[\"设置为正整数n表示这个函数最多等待n秒\",{\"1\":{\"610\":1}}],[\"设置为mixed\",{\"1\":{\"591\":1}}],[\"设置为只读可以防止误操作\",{\"1\":{\"590\":1}}],[\"设置为2的时候\",{\"1\":{\"588\":1}}],[\"设置为1的时候\",{\"1\":{\"588\":1}}],[\"设置为0的时候\",{\"1\":{\"588\":1}}],[\"设置为off的时候\",{\"1\":{\"484\":1}}],[\"设置为no的时候\",{\"1\":{\"484\":1}}],[\"设计与实现在线版\",{\"1\":{\"1853\":1}}],[\"设计了一个protocolhandler的接口来封装这两种变化点\",{\"1\":{\"1565\":1}}],[\"设计非常巧妙\",{\"1\":{\"1470\":1}}],[\"设计的精髓\",{\"1\":{\"1379\":2}}],[\"设计的线程都在等待别的线程释放资源时\",{\"1\":{\"581\":1}}],[\"设计注意点\",{\"1\":{\"1379\":1}}],[\"设计原则\",{\"0\":{\"877\":1}}],[\"设计查询的时候一个需要考虑的重要问题时\",{\"1\":{\"529\":1}}],[\"设计模式的书籍推荐\",{\"1\":{\"1870\":1}}],[\"设计模式\",{\"0\":{\"269\":1,\"901\":1},\"1\":{\"1844\":2}}],[\"设节点root为节点p\",{\"1\":{\"398\":1}}],[\"约束root的左子树的值不超过root的值\",{\"1\":{\"397\":1}}],[\"遍历切面中的每个方法\",{\"1\":{\"1507\":1}}],[\"遍历结束之前在结构上被修改了\",{\"1\":{\"1497\":1}}],[\"遍历的\",{\"1\":{\"1497\":1}}],[\"遍历和分割都会消耗元素\",{\"1\":{\"1497\":1}}],[\"遍历集合中的单个的字符串\",{\"1\":{\"1485\":1}}],[\"遍历执行累加器accumulator中的accept\",{\"1\":{\"1485\":1}}],[\"遍历这个集合\",{\"1\":{\"1472\":1}}],[\"遍历这个索引比主键索引来得更快\",{\"1\":{\"503\":1}}],[\"遍历该节点上的链表\",{\"1\":{\"1431\":1}}],[\"遍历过程中若发现key已经存在直接覆盖value即可\",{\"1\":{\"1426\":1}}],[\"遍历table\",{\"1\":{\"1426\":1}}],[\"遍历排序号的id和字段position\",{\"1\":{\"657\":1}}],[\"遍历排序结果\",{\"1\":{\"492\":1}}],[\"遍历完成后\",{\"1\":{\"553\":1}}],[\"遍历哪个索引树得到的结果逻辑上都是一样的\",{\"1\":{\"533\":1}}],[\"遍历求出所有的\",{\"1\":{\"430\":1}}],[\"遍历到左子树的最右侧节点\",{\"1\":{\"395\":1}}],[\"遍历数组的方式\",{\"1\":{\"329\":1}}],[\"记为线程t\",{\"1\":{\"1375\":1}}],[\"记为gtid1\",{\"1\":{\"611\":1}}],[\"记为c\",{\"1\":{\"559\":1}}],[\"记为字段w\",{\"1\":{\"557\":1}}],[\"记为字段r\",{\"1\":{\"557\":1}}],[\"记为m\",{\"1\":{\"555\":1}}],[\"记为x\",{\"1\":{\"553\":1}}],[\"记为log2m\",{\"1\":{\"538\":1}}],[\"记录resolvabledependency\",{\"1\":{\"1528\":1}}],[\"记录ignoredependencyinterface\",{\"1\":{\"1528\":1}}],[\"记录链表节点得个数\",{\"1\":{\"1431\":1}}],[\"记录条数少的时候可以做到精确计算\",{\"1\":{\"690\":1}}],[\"记录的主键id\",{\"1\":{\"657\":1}}],[\"记录的binlog还是statement格式\",{\"1\":{\"622\":1}}],[\"记录的是这个语句的原始逻辑\",{\"1\":{\"462\":1}}],[\"记录的是\",{\"1\":{\"462\":1}}],[\"记录binlog的时候\",{\"1\":{\"605\":1}}],[\"记录到binlog里的是语句原文\",{\"1\":{\"591\":1}}],[\"记录一条交易日志\",{\"1\":{\"580\":1}}],[\"记录上最新的值\",{\"1\":{\"571\":1}}],[\"记录太少的表\",{\"1\":{\"496\":1}}],[\"记录下来\",{\"1\":{\"1497\":1}}],[\"记录下\",{\"1\":{\"482\":1}}],[\"记录当前节点位置\",{\"1\":{\"395\":1}}],[\"记忆集与卡表\",{\"0\":{\"1639\":1}}],[\"记忆化搜索的递归树\",{\"1\":{\"429\":1}}],[\"记忆\",{\"1\":{\"310\":1}}],[\"莫里斯遍历\",{\"1\":{\"395\":1}}],[\"继续往下\",{\"1\":{\"1500\":1}}],[\"继续往下看\",{\"1\":{\"1471\":1}}],[\"继续接受其他客户端的连接请求\",{\"1\":{\"1452\":1}}],[\"继续执行的其它事务就会申请到id=3\",{\"1\":{\"628\":1}}],[\"继续执行插入数据的操作\",{\"1\":{\"628\":1}}],[\"继续执行第二步\",{\"1\":{\"540\":1}}],[\"继续分配transaction\",{\"1\":{\"605\":1}}],[\"继续分配事务\",{\"1\":{\"598\":1}}],[\"继续下一步\",{\"1\":{\"595\":1}}],[\"继续扫描表t1\",{\"1\":{\"540\":1}}],[\"继续第2步\",{\"1\":{\"540\":1}}],[\"继续上面整个过程\",{\"1\":{\"395\":1}}],[\"继承propertyeditorsupport\",{\"1\":{\"1515\":1}}],[\"继承了abstractautowirecapablebeanfactory\",{\"1\":{\"1513\":1}}],[\"继承了abstractbeanfactory\",{\"1\":{\"1513\":1}}],[\"继承了listablebeanfactory\",{\"1\":{\"1513\":1}}],[\"继承了factorybeanregistrysupport\",{\"1\":{\"1513\":1}}],[\"继承\",{\"0\":{\"16\":1}}],[\"迭代有序集合中的元素\",{\"1\":{\"711\":1}}],[\"迭代哈希表中的键值对\",{\"1\":{\"710\":1}}],[\"迭代法\",{\"1\":{\"410\":1}}],[\"迭代实现\",{\"1\":{\"395\":1}}],[\"迭代器和for循环遍历的区别\",{\"0\":{\"29\":1}}],[\"窗口的左边界为i\",{\"1\":{\"393\":1}}],[\"传播行为是spring事务管理中的难点\",{\"1\":{\"1532\":1}}],[\"传递到onstartup方法的第一个参数上面\",{\"1\":{\"1535\":1}}],[\"传递给container\",{\"1\":{\"1565\":1}}],[\"传递给提供的sink\",{\"1\":{\"1500\":1}}],[\"传递给accumulator方法的第一个参数\",{\"1\":{\"1492\":1}}],[\"传递行为\",{\"1\":{\"1497\":1}}],[\"传递的action如果是lambda表达式就既满足了consumer的要求\",{\"1\":{\"1497\":1}}],[\"传递的方式\",{\"1\":{\"1447\":1}}],[\"传输效率最佳\",{\"1\":{\"1460\":1}}],[\"传输速度总是不尽人意\",{\"1\":{\"1457\":1}}],[\"传输方式\",{\"0\":{\"839\":1}}],[\"传输格式\",{\"0\":{\"838\":1}}],[\"传统拷贝方式\",{\"1\":{\"1462\":1}}],[\"传统线程池threadpoolexecutor有两个明显的缺点\",{\"1\":{\"1387\":1}}],[\"传统ioc容器的实现\",{\"0\":{\"1070\":1}}],[\"传统实现\",{\"1\":{\"714\":1}}],[\"传统的fork\",{\"1\":{\"1404\":1}}],[\"传统的for循环方式\",{\"1\":{\"329\":1}}],[\"传统的模型\",{\"0\":{\"865\":1}}],[\"传统的io流程\",{\"0\":{\"854\":1}}],[\"传统的遍历方式\",{\"1\":{\"368\":1}}],[\"传入一个对象\",{\"1\":{\"1482\":1}}],[\"传入即可\",{\"1\":{\"1475\":1}}],[\"传入readcompletionhandler作为回调\",{\"1\":{\"1452\":1}}],[\"传入acceptcompletionhandler作为回调来接收连接消息\",{\"1\":{\"1452\":1}}],[\"传入的是\",{\"1\":{\"1431\":1}}],[\"传入的这一行的值是\",{\"1\":{\"628\":1}}],[\"传入新的容量\",{\"1\":{\"1427\":1}}],[\"传入比较器\",{\"1\":{\"393\":1}}],[\"传到备库应用的时候\",{\"1\":{\"601\":1}}],[\"传到节点b执行一次后\",{\"1\":{\"592\":1}}],[\"移出并获取列表的第一个\",{\"1\":{\"708\":1}}],[\"移到右子节点\",{\"1\":{\"395\":1}}],[\"移动匹配法\",{\"1\":{\"389\":1}}],[\"移除\",{\"1\":{\"1497\":1,\"1513\":1}}],[\"移除score在\",{\"1\":{\"711\":1}}],[\"移除排名0~1的所有成员\",{\"1\":{\"711\":1}}],[\"移除字典区间\",{\"1\":{\"711\":1}}],[\"移除成员abc\",{\"1\":{\"711\":1}}],[\"移除有序集合中给定的分数区间的所有成员\",{\"1\":{\"711\":1}}],[\"移除有序集合中给定的排名区间的所有成员\",{\"1\":{\"711\":1}}],[\"移除有序集合中给定的字典区间的所有成员\",{\"1\":{\"711\":1}}],[\"移除有序集合中一个\",{\"1\":{\"711\":1}}],[\"移除集合中一个\",{\"1\":{\"709\":1}}],[\"移除上一层的结点\",{\"1\":{\"396\":1}}],[\"移除空格\",{\"1\":{\"388\":1}}],[\"移除链表元素\",{\"0\":{\"371\":1}}],[\"移除元素\",{\"0\":{\"361\":1}}],[\"移除word\",{\"1\":{\"302\":1}}],[\"空链表\",{\"1\":{\"708\":1}}],[\"空洞\",{\"1\":{\"626\":1}}],[\"空出位置\",{\"1\":{\"472\":1}}],[\"空间分配担保\",{\"0\":{\"1641\":1}}],[\"空间局部性原理\",{\"1\":{\"1396\":1}}],[\"空间换时间\",{\"1\":{\"1352\":1}}],[\"空间固定会用完\",{\"1\":{\"462\":1}}],[\"空间复杂度为o\",{\"1\":{\"330\":1}}],[\"空字符串\",{\"1\":{\"388\":1}}],[\"下游收集器本身返回的是<a\",{\"1\":{\"1495\":1}}],[\"下次获得锁时\",{\"1\":{\"1362\":1}}],[\"下次查询再重新建立一个\",{\"1\":{\"455\":1}}],[\"下才会出现\",{\"1\":{\"583\":1}}],[\"下增加修改参数\",{\"1\":{\"565\":1}}],[\"下图为16扩充至32的过程的示意图\",{\"1\":{\"1427\":1}}],[\"下图展示了频道\",{\"1\":{\"733\":1}}],[\"下图表示了执行完这个空事务之后的show\",{\"1\":{\"605\":1}}],[\"下图表示的是基本主备切换流程\",{\"1\":{\"590\":1}}],[\"下图表示的是\",{\"1\":{\"588\":1}}],[\"下图中\",{\"1\":{\"601\":1}}],[\"下图是binlog\",{\"1\":{\"596\":1}}],[\"下图是创建的一个包含了很多分区的表t\",{\"1\":{\"562\":1}}],[\"下图所示是带change\",{\"1\":{\"482\":1}}],[\"下一个待添加元素索引\",{\"1\":{\"1379\":1}}],[\"下一个待取出元素索引\",{\"1\":{\"1379\":1}}],[\"下一个值就是0\",{\"1\":{\"632\":1}}],[\"下一个事务才能再申请自增id\",{\"1\":{\"628\":1}}],[\"下一组才能开始执行\",{\"1\":{\"601\":1}}],[\"下一组事务很快就会进入commit状态\",{\"1\":{\"601\":1}}],[\"下一组事务是同时处于\",{\"1\":{\"601\":1}}],[\"下一组就是commit\",{\"1\":{\"601\":1}}],[\"下一条记录\",{\"1\":{\"493\":1}}],[\"下一张图中\",{\"1\":{\"477\":1}}],[\"下一行\",{\"1\":{\"459\":1}}],[\"下面通过一个例子来说明\",{\"1\":{\"1469\":1}}],[\"下面通过具体的例子来说明扩容过程\",{\"1\":{\"1427\":1}}],[\"下面举例说明\",{\"1\":{\"1425\":1}}],[\"下面的sql问题经常出现在面试当中\",{\"1\":{\"1852\":1}}],[\"下面的例子使用了java\",{\"1\":{\"1497\":1}}],[\"下面的例子就是使用jdk预先定义好的方法来执行可变的汇聚任务\",{\"1\":{\"1493\":1}}],[\"下面的示例演示了如何让使用stream和intstream进行聚合操作\",{\"1\":{\"1496\":1}}],[\"下面的方式是groupingby真正执行的方法\",{\"1\":{\"1495\":1}}],[\"下面的计算是等价的\",{\"1\":{\"1492\":1}}],[\"下面的代码中\",{\"1\":{\"1403\":2}}],[\"下面的序列中实例s是m的备库\",{\"1\":{\"550\":1}}],[\"下面开始是多集合操作\",{\"1\":{\"709\":1}}],[\"下面学习的命令\",{\"1\":{\"706\":1}}],[\"下面比较各种可执行方案以及它们对应的成本\",{\"1\":{\"688\":1}}],[\"下面两张图分别是这个例子的操作序列和执行结果图\",{\"1\":{\"562\":1}}],[\"下面我们使用supplier来创建一个对象\",{\"1\":{\"1477\":1}}],[\"下面我们用具体的例子来说明\",{\"1\":{\"1477\":1}}],[\"下面我们以内连接为例来看看如何计算出最优的连接查询方案\",{\"1\":{\"692\":1}}],[\"下面我们来看一个稍微复杂一点的例子\",{\"1\":{\"1493\":1}}],[\"下面我们来举例来说明这一点\",{\"1\":{\"596\":1}}],[\"下面我们来分析整个语句的执行过程\",{\"1\":{\"491\":1}}],[\"下面我们通过具体的例子来说明\",{\"1\":{\"1475\":1}}],[\"下面我们通过代码对bio模型进行具体分析\",{\"1\":{\"1450\":1}}],[\"下面我们通过实例来说明\",{\"1\":{\"570\":1}}],[\"下面我们通过例子来说明\",{\"1\":{\"562\":1}}],[\"下面这个查询\",{\"1\":{\"531\":1}}],[\"下面是按照时间顺序执行两个事务的行为\",{\"1\":{\"570\":1}}],[\"下面是这个语句explain的结果\",{\"1\":{\"551\":1}}],[\"下面是这两个过程的执行流程图\",{\"1\":{\"477\":1}}],[\"下面是t\",{\"1\":{\"503\":1}}],[\"下面进行大胆的尝试\",{\"1\":{\"499\":1}}],[\"下面k个不反转\",{\"1\":{\"384\":1}}],[\"下\",{\"1\":{\"435\":2}}],[\"下文表示成s\",{\"1\":{\"428\":1}}],[\"下标采取递增的形式\",{\"1\":{\"1396\":1}}],[\"下标i正好是满足条件的孩子的个数\",{\"1\":{\"422\":1}}],[\"下标大的在前面\",{\"1\":{\"393\":1}}],[\"下探到下一层\",{\"1\":{\"285\":1}}],[\"字典的键为正在被订阅的频道\",{\"1\":{\"736\":1}}],[\"字典区间的成员\",{\"1\":{\"711\":2}}],[\"字典树实现\",{\"1\":{\"302\":1}}],[\"字典树不是二叉树\",{\"1\":{\"301\":1}}],[\"字典树\",{\"0\":{\"300\":1},\"1\":{\"301\":1}}],[\"字节码与数据类型\",{\"0\":{\"1662\":1}}],[\"字节码指令\",{\"0\":{\"1661\":1}}],[\"字节\",{\"1\":{\"665\":7,\"666\":1,\"667\":1}}],[\"字样\",{\"1\":{\"540\":1}}],[\"字符编码集\",{\"0\":{\"852\":1}}],[\"字符要加单引号\",{\"0\":{\"513\":1},\"1\":{\"513\":1}}],[\"字符串短\",{\"1\":{\"667\":1}}],[\"字符串的长度相差较大用varchar\",{\"1\":{\"667\":1}}],[\"字符串不加单引号索引失效\",{\"1\":{\"506\":1}}],[\"字符串和数字做比较的话\",{\"1\":{\"504\":1}}],[\"字符串添加索引\",{\"0\":{\"486\":1}}],[\"字符串总结\",{\"0\":{\"390\":1}}],[\"字符串\",{\"0\":{\"382\":1,\"667\":1,\"707\":1},\"1\":{\"664\":1}}],[\"字段表集合\",{\"0\":{\"1658\":1}}],[\"字段信息\",{\"1\":{\"1540\":1}}],[\"字段注入\",{\"0\":{\"1116\":1}}],[\"字段名\",{\"1\":{\"695\":1}}],[\"字段无索引\",{\"1\":{\"663\":1}}],[\"字段有索引\",{\"1\":{\"663\":1}}],[\"字段c有唯一约束\",{\"1\":{\"628\":1}}],[\"字段b上无索引\",{\"1\":{\"537\":1}}],[\"字段\",{\"0\":{\"467\":1},\"1\":{\"508\":1,\"536\":6,\"663\":1}}],[\"字段rows\",{\"1\":{\"459\":1}}],[\"找不到再委托上层父加载器加载\",{\"1\":{\"1570\":1}}],[\"找同步位点\",{\"1\":{\"604\":1}}],[\"找出所有的切面bean\",{\"1\":{\"1507\":1}}],[\"找出所有可能使用的索引\",{\"0\":{\"684\":1},\"1\":{\"683\":1}}],[\"找出成本最低的那一个\",{\"0\":{\"688\":1},\"1\":{\"683\":1}}],[\"找出第一个不在set\",{\"1\":{\"605\":1}}],[\"找出不小于l\",{\"1\":{\"487\":1}}],[\"找出最小值即可\",{\"1\":{\"426\":1}}],[\"找出出现次数为1次的数字\",{\"1\":{\"381\":1}}],[\"找树左下角的值\",{\"0\":{\"411\":1}}],[\"找到的是多个\",{\"1\":{\"1525\":1}}],[\"找到的第一个是id1\",{\"1\":{\"487\":1}}],[\"找到所有bean\",{\"1\":{\"1525\":1}}],[\"找到需要注入的字段的值\",{\"1\":{\"1525\":1}}],[\"找到被桥接的方法\",{\"1\":{\"1525\":1}}],[\"找到集合中所有大于5或者是偶数的数\",{\"1\":{\"1476\":1}}],[\"找到集合中所有大于5并且是偶数的数\",{\"1\":{\"1476\":1}}],[\"找到集合中所有大于5的数\",{\"1\":{\"1476\":2}}],[\"找到集合中所有小于3的数\",{\"1\":{\"1476\":2}}],[\"找到集合中所有的奇数\",{\"1\":{\"1476\":2}}],[\"找到集合中所有的偶数\",{\"1\":{\"1476\":2}}],[\"找到该class所有正在加锁状态的偏向锁\",{\"1\":{\"1362\":1}}],[\"找到满足expire\",{\"1\":{\"686\":1}}],[\"找到第一个满足city=\",{\"1\":{\"493\":2}}],[\"找到第一个满足条件的记录id3\",{\"1\":{\"477\":1}}],[\"找到user2\",{\"1\":{\"469\":1}}],[\"找到最近的一次全量备份\",{\"1\":{\"464\":1}}],[\"找到最近的匹配括号开始\",{\"1\":{\"386\":1}}],[\"找到大于等于当前柱形高度最右元素的下标\",{\"1\":{\"367\":2}}],[\"找到大于等于当前柱形高度最左元素的下标\",{\"1\":{\"367\":2}}],[\"找到元素x所在的集合的代表\",{\"1\":{\"356\":1}}],[\"找到比其小的数\",{\"1\":{\"319\":1}}],[\"找到数组中最小的那个元素\",{\"1\":{\"318\":1}}],[\"找到一个可能存在的正确的答案\",{\"1\":{\"290\":1}}],[\"证明有环\",{\"1\":{\"377\":1}}],[\"让线程2进行resize\",{\"1\":{\"1428\":1}}],[\"让高峰期塞队列的速度慢点\",{\"1\":{\"1413\":1}}],[\"让出cpu给别的线程执行时间\",{\"1\":{\"1397\":1}}],[\"让更多的线程参与执行\",{\"1\":{\"1391\":1}}],[\"让它们关联同一个guardedobject\",{\"1\":{\"1407\":1}}],[\"让它们支持并发\",{\"1\":{\"1360\":1}}],[\"让它们切换主机\",{\"1\":{\"757\":1}}],[\"让缓存失效的时间点尽量均匀\",{\"1\":{\"770\":1}}],[\"让缓存的效率更高\",{\"1\":{\"531\":1}}],[\"让redis服务器返回监控其运行状态\",{\"1\":{\"757\":1}}],[\"让优化器尽可能的更倾向于使用索引完成排序而不是filesort\",{\"1\":{\"694\":1}}],[\"让优化器选择全字段排序\",{\"1\":{\"657\":1}}],[\"让优化器选择使用双路排序算法\",{\"1\":{\"657\":1}}],[\"让他们在同一个事务里面操作\",{\"1\":{\"663\":1}}],[\"让global\",{\"1\":{\"633\":1}}],[\"让原库的批量插入数据语句\",{\"1\":{\"629\":1}}],[\"让一个库的自增id多是奇数\",{\"1\":{\"628\":1}}],[\"让主库提交得慢些\",{\"1\":{\"602\":1}}],[\"让外部系统提供统计类查询的能力\",{\"1\":{\"594\":1}}],[\"让这些从库来分担读的压力\",{\"1\":{\"594\":1}}],[\"让其它事务得以继续执行\",{\"1\":{\"581\":1}}],[\"让表t1和tmp\",{\"1\":{\"544\":1}}],[\"让mysql优化器能够以更优化的方式去执行这个查询\",{\"1\":{\"527\":1}}],[\"让mysql换成另外一种算法\",{\"1\":{\"492\":1}}],[\"让我们从最简单的情形开始\",{\"1\":{\"454\":1}}],[\"让慢指针异动到倒数第n个节点的地方\",{\"1\":{\"375\":1}}],[\"让快慢指针相距n个节点\",{\"1\":{\"375\":1}}],[\"两者是完全不同的\",{\"1\":{\"1469\":1}}],[\"两次\",{\"1\":{\"1431\":1}}],[\"两次操作合在一起写了一次磁盘\",{\"1\":{\"482\":1}}],[\"两条记录做比较操作的成本\",{\"1\":{\"694\":1}}],[\"两边的主备同步的应用线程会报错duplicate\",{\"1\":{\"596\":1}}],[\"两阶段终止模式是一种应用很广泛的并发设计模式\",{\"1\":{\"1401\":1}}],[\"两阶段终止模式\",{\"0\":{\"1401\":1},\"1\":{\"1401\":1}}],[\"两阶段锁\",{\"0\":{\"580\":1}}],[\"两阶段提交的示意图如下\",{\"1\":{\"588\":1}}],[\"两阶段提交为了让两份日志之间的逻辑一致\",{\"1\":{\"464\":1}}],[\"两阶段提交\",{\"0\":{\"464\":1},\"1\":{\"463\":1,\"464\":1}}],[\"两表连接的成本分析\",{\"0\":{\"692\":1}}],[\"两表连接查询的sql执行计划\",{\"1\":{\"499\":1}}],[\"两表索引分析\",{\"0\":{\"499\":1}}],[\"两棵树的示例示意图如下\",{\"1\":{\"472\":1}}],[\"两两交换链表中的节点\",{\"0\":{\"374\":1}}],[\"两个相同的lambda表达式\",{\"1\":{\"1497\":1}}],[\"两个相同对象没有重写equals方法放到hashmap覆盖吗\",{\"0\":{\"44\":1}}],[\"两个配合使用\",{\"1\":{\"1484\":1}}],[\"两个任务谁执行的快\",{\"1\":{\"1395\":2}}],[\"两个任务都执行完成后\",{\"1\":{\"1395\":1}}],[\"两个任务执行完成后\",{\"1\":{\"1395\":1}}],[\"两个态之间来回切换\",{\"1\":{\"1360\":1}}],[\"两个指令的执行是jvm通过调用操作系统的互斥源于meutex来实现\",{\"1\":{\"1360\":1}}],[\"两个指针\",{\"1\":{\"377\":1}}],[\"两个表都做一次全表扫描\",{\"1\":{\"540\":1}}],[\"两个要素\",{\"1\":{\"310\":1}}],[\"快照\",{\"1\":{\"733\":1}}],[\"快照功能\",{\"1\":{\"729\":1}}],[\"快照读\",{\"1\":{\"678\":1}}],[\"快\",{\"1\":{\"536\":1,\"732\":1}}],[\"快速失败\",{\"1\":{\"1497\":1}}],[\"快速上限估计\",{\"1\":{\"525\":2}}],[\"快速定位到t\",{\"1\":{\"503\":1}}],[\"快速排序是最佳的选择\",{\"1\":{\"316\":1}}],[\"快速排序\",{\"0\":{\"323\":1},\"1\":{\"316\":1}}],[\"快慢指针法\",{\"1\":{\"373\":1}}],[\"然而有些流操作可能会返回他们的接收者而并不是一个新的stream对象\",{\"1\":{\"1496\":1}}],[\"然而我想这是远远不够的\",{\"1\":{\"1490\":1}}],[\"然而即使搬了家\",{\"1\":{\"1438\":1}}],[\"然而\",{\"1\":{\"502\":1,\"1351\":1,\"1471\":1,\"1492\":1,\"1496\":1}}],[\"然而对于工程和生活中的问题\",{\"1\":{\"293\":1}}],[\"然后自己对结果集进行封装处理\",{\"1\":{\"1860\":1}}],[\"然后处理\",{\"1\":{\"1525\":1}}],[\"然后合并子类的beandifition\",{\"1\":{\"1524\":1}}],[\"然后下游收集器会对流中t类型的元素生成一个d类型的结果\",{\"1\":{\"1495\":1}}],[\"然后会对于给定的key所关联的值\",{\"1\":{\"1495\":1}}],[\"然后使用分组方法collectors\",{\"1\":{\"1492\":1}}],[\"然后使用combiner方法合并部分的结果执行一个并行的汇聚操作\",{\"1\":{\"1492\":1}}],[\"然后使用combiner方法将每个分区的结果容器当中的内容进行合并\",{\"1\":{\"1492\":1}}],[\"然后使用类似下面这条语句作为检测逻辑\",{\"1\":{\"616\":1}}],[\"然后来创建一些对象\",{\"1\":{\"1490\":1}}],[\"然后来实现对于student的排序\",{\"1\":{\"1481\":1}}],[\"然后求出流中元素的总和\",{\"1\":{\"1487\":1}}],[\"然后求和\",{\"1\":{\"1484\":1}}],[\"然后对流中的元素进行遍历\",{\"1\":{\"1485\":1}}],[\"然后对于每一行\",{\"1\":{\"538\":1}}],[\"然后调用consumer接口中的accept方法\",{\"1\":{\"1471\":1}}],[\"然后调用fsync持久化到磁盘\",{\"1\":{\"588\":1}}],[\"然后返回\",{\"1\":{\"1441\":1}}],[\"然后kernel返回结果\",{\"1\":{\"1440\":1}}],[\"然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间\",{\"1\":{\"1438\":1}}],[\"然后才有可能判断到线程的状态已经变成了kill\",{\"1\":{\"618\":1}}],[\"然后构造table\",{\"1\":{\"1431\":1}}],[\"然后是e\",{\"1\":{\"1428\":1}}],[\"然后放开线程2的断点\",{\"1\":{\"1428\":1}}],[\"然后所有的node重新rehash的过程\",{\"1\":{\"1427\":1}}],[\"然后线程会在合适的时机检查这个标志位\",{\"1\":{\"1401\":1}}],[\"然后线程会加入到条件队列\",{\"1\":{\"1367\":1}}],[\"然后唤醒因调用condition\",{\"1\":{\"1370\":1}}],[\"然后阻塞当前线程\",{\"1\":{\"1370\":1}}],[\"然后开始选举新的主机\",{\"1\":{\"758\":1}}],[\"然后主机上也能看到从机的状态\",{\"1\":{\"747\":1}}],[\"然后直接使用工具类来间接操作redis\",{\"1\":{\"721\":1}}],[\"然后按索引\",{\"1\":{\"711\":1}}],[\"然后删除指定的value\",{\"1\":{\"708\":1}}],[\"然后加到另一个列表的头部\",{\"1\":{\"708\":1}}],[\"然后选区成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划\",{\"1\":{\"692\":1}}],[\"然后分析对于被驱动表的成本最低的执行方案\",{\"1\":{\"692\":2}}],[\"然后分别为驱动表和被驱动表选择成本最低的访问方法\",{\"1\":{\"692\":1}}],[\"然后分布到32个数据库实例上\",{\"1\":{\"548\":1}}],[\"然后顺序写日志文件\",{\"1\":{\"680\":1}}],[\"然后顺序申请\",{\"1\":{\"628\":1}}],[\"然后基于最初选定的值更新该行时\",{\"1\":{\"669\":1}}],[\"然后情况buffer\",{\"1\":{\"662\":1}}],[\"然后从t1表里取数据跟join\",{\"1\":{\"662\":1}}],[\"然后从0开始的情况\",{\"1\":{\"634\":1}}],[\"然后扫描被驱动表\",{\"1\":{\"662\":1}}],[\"然后遍历每行数据中字段a的值\",{\"1\":{\"661\":1}}],[\"然后遍历map\",{\"1\":{\"381\":1}}],[\"然后取出两张表的结果合集\",{\"1\":{\"661\":1}}],[\"然后取到对应的id\",{\"1\":{\"484\":2}}],[\"然后通过哈希算法的后两步运算\",{\"1\":{\"1423\":1}}],[\"然后通过发布订阅模式通知其他的从服务器\",{\"1\":{\"757\":1}}],[\"然后通过主键回到原表查询需要的字段\",{\"1\":{\"657\":1}}],[\"然后通过api接口mysql\",{\"1\":{\"611\":1}}],[\"然后用这个平均值乘以区间最左记录和区间最右记录之间的页面数量就可以了\",{\"1\":{\"686\":1}}],[\"然后用这些索引对应的主键逐个回表\",{\"1\":{\"655\":1}}],[\"然后用过滤完剩下的索引对应的主键id再回表查整行数据\",{\"1\":{\"655\":1}}],[\"然后并将max\",{\"1\":{\"634\":1}}],[\"然后给这个变量加1\",{\"1\":{\"633\":1}}],[\"然后继续增加\",{\"1\":{\"635\":1}}],[\"然后继续循环\",{\"1\":{\"632\":1}}],[\"然后继续执行\",{\"1\":{\"551\":1}}],[\"然后不停地往上加步长\",{\"1\":{\"630\":1}}],[\"然后一次性申请\",{\"1\":{\"629\":1}}],[\"然后一起传给表t2\",{\"1\":{\"542\":1}}],[\"然后两个session\",{\"1\":{\"629\":1}}],[\"然后session\",{\"1\":{\"629\":1}}],[\"然后客户端就可以快速返回了\",{\"1\":{\"619\":1}}],[\"然后客户端程序结束执行\",{\"1\":{\"455\":1}}],[\"然后进程处理这个信号\",{\"1\":{\"618\":1}}],[\"然后进入执行器阶段\",{\"1\":{\"458\":1,\"651\":1}}],[\"然后定期执行\",{\"1\":{\"614\":1}}],[\"然后保持这个状态\",{\"1\":{\"613\":1}}],[\"然后到主库去查\",{\"1\":{\"610\":1}}],[\"然后停止同步\",{\"1\":{\"604\":1}}],[\"然后计算平均一个页面中主键值的记录数量乘以全部叶子结点的数量就算是该表n\",{\"1\":{\"695\":1}}],[\"然后计算哈希值\",{\"1\":{\"599\":1}}],[\"然后计算大概需要多少个顺序和随机i\",{\"1\":{\"525\":1}}],[\"然后节点a和b间\",{\"1\":{\"592\":1}}],[\"然后同步到节点b的完整示意图如下\",{\"1\":{\"590\":1}}],[\"然后关掉死锁检测\",{\"1\":{\"581\":1}}],[\"然后其它线程才有可能继续执行\",{\"1\":{\"581\":1}}],[\"然后依次执行更新\",{\"1\":{\"561\":1}}],[\"然后把dict\",{\"1\":{\"632\":1}}],[\"然后把解析结果整个发给mysql执行\",{\"1\":{\"591\":1}}],[\"然后把下一个记录作为返回结果\",{\"1\":{\"559\":1}}],[\"然后把这12个有序文件再合并成一个有序的大文件\",{\"1\":{\"491\":1}}],[\"然后统一进行排序\",{\"1\":{\"548\":1}}],[\"然后清空read\",{\"1\":{\"541\":1}}],[\"然后根据对应的mapper接口生成一个mapper接口代理对象\",{\"1\":{\"1530\":1}}],[\"然后根据分析结果着手制定优化计划\",{\"1\":{\"675\":1}}],[\"然后根据主键查到对应的记录\",{\"1\":{\"659\":1}}],[\"然后根据从表t1中取出的每行数据中a的值\",{\"1\":{\"538\":1}}],[\"然后根据字段b来过滤\",{\"1\":{\"484\":1}}],[\"然后redis异常重启了\",{\"1\":{\"534\":1}}],[\"然后将beanfactory关闭\",{\"1\":{\"1528\":1}}],[\"然后将结果传递给所提供的sink\",{\"1\":{\"1500\":1}}],[\"然后将结果在应用程序中进行关联\",{\"1\":{\"531\":1}}],[\"然后将它转换成int值的stream对象\",{\"1\":{\"1496\":1}}],[\"然后将映射之后的值放入到map当中\",{\"1\":{\"1495\":1}}],[\"然后将该student对象添加到list中\",{\"1\":{\"1490\":1}}],[\"然后将每个元素乘以2\",{\"1\":{\"1487\":1}}],[\"然后将所有的元素作为一个整体进行打印\",{\"1\":{\"1486\":1}}],[\"然后将内核中kernel\",{\"1\":{\"1459\":1}}],[\"然后将数据拷贝到用户内存\",{\"1\":{\"1443\":1}}],[\"然后将trx\",{\"1\":{\"679\":1}}],[\"然后将max\",{\"1\":{\"627\":1}}],[\"然后将statement语句直接拷贝出来执行\",{\"1\":{\"591\":1}}],[\"然后将checkpoint向后移动\",{\"1\":{\"461\":1}}],[\"然后过滤不满足条件的记录\",{\"1\":{\"527\":1}}],[\"然后每次进行比较\",{\"1\":{\"714\":1}}],[\"然后每次都返回完全相同的数据\",{\"1\":{\"523\":1}}],[\"然后每次插入新记录的时候\",{\"1\":{\"489\":1}}],[\"然后抛弃其中的大部分数据\",{\"1\":{\"520\":1}}],[\"然后获取前面n行后关闭结果集\",{\"1\":{\"520\":1}}],[\"然后这些多余的数据会被应用程序丢弃\",{\"1\":{\"519\":1}}],[\"然后原表查到city\",{\"1\":{\"492\":1}}],[\"然后让innodb\",{\"1\":{\"491\":1}}],[\"然后在mtea\",{\"1\":{\"1535\":1}}],[\"然后在segment这个类中\",{\"1\":{\"1430\":1}}],[\"然后在sort\",{\"1\":{\"657\":2}}],[\"然后在传完的瞬间主剧a的主机就掉电了\",{\"1\":{\"604\":1}}],[\"然后在z列上创建一个索引\",{\"1\":{\"554\":1}}],[\"然后在这个汇总实例上做逻辑操作\",{\"1\":{\"548\":1}}],[\"然后在服务器上进行解析\",{\"1\":{\"518\":1}}],[\"然后在返回的l4~l7中\",{\"1\":{\"487\":1}}],[\"然后在候选列表中依次判断每个索引需要扫描多少行\",{\"1\":{\"485\":1}}],[\"然后乘以这个索引的页面数\",{\"1\":{\"484\":1}}],[\"然后可以得到精确的结果\",{\"1\":{\"484\":1}}],[\"然后可以认为数据页内部通过二分法来定位记录\",{\"1\":{\"479\":1}}],[\"然后做如下操作\",{\"1\":{\"483\":1}}],[\"然后执行上述语句即可\",{\"1\":{\"694\":1}}],[\"然后执行\",{\"1\":{\"694\":1}}],[\"然后执行下面的序列\",{\"1\":{\"618\":1}}],[\"然后执行如下语句\",{\"1\":{\"591\":1}}],[\"然后执行如下序列\",{\"1\":{\"561\":1}}],[\"然后执行如下sql语句\",{\"1\":{\"483\":1}}],[\"然后执行change\",{\"1\":{\"480\":1}}],[\"然后应用change\",{\"1\":{\"482\":1}}],[\"然后写了一处磁盘\",{\"1\":{\"482\":1}}],[\"然后判断其它条件是否满足\",{\"1\":{\"477\":1}}],[\"然后判断返回的列表是否为升序\",{\"1\":{\"397\":1}}],[\"然后向后遍历\",{\"1\":{\"476\":1}}],[\"然后向后遍历得到所有需要的结果\",{\"1\":{\"476\":1}}],[\"然后向表中插入5条记录\",{\"1\":{\"472\":1}}],[\"然后挪动部分数据过去\",{\"1\":{\"472\":1}}],[\"然后就可以把表数据从临时库取出来\",{\"1\":{\"464\":1}}],[\"然后\",{\"1\":{\"464\":1,\"469\":1,\"483\":1,\"487\":1,\"551\":1,\"558\":1,\"624\":1,\"629\":1,\"1431\":1,\"1443\":1}}],[\"然后告知执行器执行完成了\",{\"1\":{\"463\":1}}],[\"然后再执行postprocessbeanfactory方法\",{\"1\":{\"1529\":1}}],[\"然后再执行切面的逻辑\",{\"1\":{\"1507\":1}}],[\"然后再执行请求了\",{\"1\":{\"455\":1}}],[\"然后再调用iterator中的新增加的foreachremaining方法\",{\"1\":{\"1499\":1}}],[\"然后再调用当前的function的apply\",{\"1\":{\"1475\":1}}],[\"然后再传递给tryadvance\",{\"1\":{\"1497\":1}}],[\"然后再去对应用当前的这个对象的function\",{\"1\":{\"1475\":1}}],[\"然后再去对这个结果应用当前的function\",{\"1\":{\"1475\":1}}],[\"然后再应用当前的function\",{\"1\":{\"1475\":1}}],[\"然后再看lettuce\",{\"1\":{\"720\":1}}],[\"然后再看使用idx\",{\"1\":{\"686\":1}}],[\"然后再加锁进行事务\",{\"1\":{\"718\":1}}],[\"然后再计算这两条记录之间有多少记录\",{\"1\":{\"690\":1}}],[\"然后再比较其他搜索条件是否成立\",{\"1\":{\"686\":1}}],[\"然后再检测其他搜索条件是否成立\",{\"1\":{\"686\":1}}],[\"然后再检测记录是否符合搜索条件\",{\"1\":{\"685\":1}}],[\"然后再根据expire\",{\"1\":{\"686\":1}}],[\"然后再用\",{\"1\":{\"622\":1}}],[\"然后再将确认过的临时库的数据\",{\"1\":{\"621\":1}}],[\"然后再通过判断跳过那些在从库b上已经执行过的事务\",{\"1\":{\"604\":1}}],[\"然后再把生成的binlog发给节点b\",{\"1\":{\"592\":1}}],[\"然后再取前3条记录\",{\"1\":{\"558\":1}}],[\"然后再返回\",{\"1\":{\"463\":1}}],[\"然后再更新\",{\"1\":{\"461\":1}}],[\"然后磁盘也要找到对应的那条记录\",{\"1\":{\"461\":1}}],[\"然后转向右边节点\",{\"1\":{\"395\":1}}],[\"然后得到一个矩形的面积\",{\"1\":{\"367\":1}}],[\"向broker发送消息\",{\"0\":{\"1760\":1}}],[\"向spring中注册conversionservice\",{\"1\":{\"1516\":1}}],[\"向spring中注册propertyeditor\",{\"1\":{\"1515\":1}}],[\"向sink发送任何数据之前一定要调用这个方法\",{\"1\":{\"1500\":1}}],[\"向一个已有的管道用于追加一个中间操作\",{\"1\":{\"1499\":1}}],[\"向操作系统发起io请求\",{\"1\":{\"1457\":1}}],[\"向不同的电商平台询价\",{\"1\":{\"1394\":1}}],[\"向指定频道发布消息\",{\"1\":{\"734\":1}}],[\"向指定的key的value后追加字符串\",{\"1\":{\"707\":1}}],[\"向有序集合myzset中添加成员m1\",{\"1\":{\"711\":1}}],[\"向有序集合添加一个或多个成员\",{\"1\":{\"711\":1}}],[\"向myset中增加成员\",{\"1\":{\"709\":1}}],[\"向mylist中\",{\"1\":{\"708\":1}}],[\"向集合中无序增加一个\",{\"1\":{\"709\":1}}],[\"向已存在的列名中push值\",{\"1\":{\"708\":1}}],[\"向基于内存的临时表写入或读取一条记录的成本\",{\"1\":{\"694\":1}}],[\"向基于磁盘的临时表写入或读取一条记录的成本\",{\"1\":{\"694\":1}}],[\"向右遍历\",{\"1\":{\"367\":2}}],[\"向左遍历\",{\"1\":{\"367\":2}}],[\"经典垃圾收集器\",{\"0\":{\"1601\":1}}],[\"经历过完整生命周期的bean对象\",{\"1\":{\"1526\":1}}],[\"经度\",{\"1\":{\"713\":1}}],[\"经常被缩写为cow\",{\"1\":{\"1404\":1}}],[\"经常变动的信息\",{\"1\":{\"710\":1}}],[\"经常可能需要计算一个表中\",{\"1\":{\"532\":1}}],[\"经常增删改的表\",{\"1\":{\"496\":1}}],[\"经常采用递归来解决树相关的问题的原因是\",{\"1\":{\"337\":1}}],[\"经过观察可以发现\",{\"1\":{\"1427\":1}}],[\"经过研究发现\",{\"1\":{\"1362\":1}}],[\"经过分析不难发现\",{\"1\":{\"584\":1}}],[\"经过t4时刻\",{\"1\":{\"584\":1}}],[\"经过t2时刻\",{\"1\":{\"584\":1}}],[\"经过t1时刻\",{\"1\":{\"584\":1}}],[\"经过了分析器\",{\"1\":{\"458\":1,\"651\":1}}],[\"经过排序之后的数组第一个数大于0\",{\"1\":{\"366\":1}}],[\"穷举法\",{\"1\":{\"366\":1}}],[\"螺旋矩阵ii\",{\"0\":{\"364\":1}}],[\"滑动窗口\",{\"1\":{\"363\":2}}],[\"更为通用的写法\",{\"1\":{\"1486\":1}}],[\"更为重要的是\",{\"1\":{\"1395\":1}}],[\"更加高效\",{\"1\":{\"1484\":1}}],[\"更加灵活\",{\"1\":{\"1372\":1}}],[\"更加健壮\",{\"1\":{\"760\":1}}],[\"更多的情况是\",{\"1\":{\"1482\":1}}],[\"更多的情况下\",{\"1\":{\"1470\":1}}],[\"更多时候\",{\"1\":{\"756\":1}}],[\"更多命令学习\",{\"1\":{\"706\":1}}],[\"更像是一个裹足前行的人\",{\"1\":{\"1484\":1}}],[\"更像nio模式\",{\"1\":{\"720\":1}}],[\"更像bio模式\",{\"1\":{\"720\":1}}],[\"更重要的是做到事前预防\",{\"1\":{\"621\":1}}],[\"更重要的是\",{\"1\":{\"613\":1}}],[\"更省内存\",{\"1\":{\"602\":1}}],[\"更进一步\",{\"1\":{\"531\":1}}],[\"更容易做到高性能和可扩展\",{\"1\":{\"531\":1}}],[\"更简单的做法是用set\",{\"1\":{\"381\":1}}],[\"更安全的写法是\",{\"1\":{\"360\":1}}],[\"更新已存在的key\",{\"1\":{\"1430\":1}}],[\"更新innodb\",{\"1\":{\"696\":1}}],[\"更新统计数据\",{\"0\":{\"696\":1}}],[\"更新内存的数据的性能是很高的\",{\"1\":{\"680\":1}}],[\"更新丢失或脏写\",{\"1\":{\"669\":1}}],[\"更新判断是一个相对比较常用的方案\",{\"1\":{\"615\":1}}],[\"更新判断\",{\"0\":{\"615\":1}}],[\"更新事务要写入binlog\",{\"1\":{\"614\":1}}],[\"更新同一行的事务\",{\"1\":{\"597\":1}}],[\"更新了一半的结果\",{\"1\":{\"597\":1}}],[\"更新请求对iops的压力\",{\"1\":{\"594\":1}}],[\"更新过程中也会触发大量的读操作\",{\"1\":{\"594\":1}}],[\"更新过程\",{\"0\":{\"480\":1}}],[\"更新的时间复杂度也是o\",{\"1\":{\"471\":1}}],[\"更新完成\",{\"1\":{\"463\":1}}],[\"更新语句执行流程\",{\"0\":{\"463\":1}}],[\"更新流程还设计两个重要的的日志模块\",{\"1\":{\"460\":1}}],[\"更新结果\",{\"1\":{\"363\":1}}],[\"更新结点的值\",{\"1\":{\"345\":1}}],[\"更新\",{\"1\":{\"310\":1,\"1431\":1}}],[\"模版方法\",{\"1\":{\"1528\":2,\"1535\":1}}],[\"模运算的消耗还是比较大的\",{\"1\":{\"1425\":1}}],[\"模板解释器\",{\"1\":{\"1350\":1}}],[\"模板方法模式\",{\"0\":{\"896\":1,\"1007\":1}}],[\"模板代码\",{\"1\":{\"360\":1,\"401\":1}}],[\"模拟处理请求\",{\"1\":{\"1410\":1,\"1411\":1}}],[\"模拟线程插队\",{\"1\":{\"718\":1}}],[\"模拟主库的并行模式\",{\"1\":{\"601\":1}}],[\"模式的一个最经典的应用场景是网络编程里服务端的实现\",{\"1\":{\"1410\":1}}],[\"模式有一个非常典型的应用场景就是单次初始化\",{\"1\":{\"1408\":1}}],[\"模式\",{\"1\":{\"590\":1}}],[\"模糊查询like语句该怎么写\",{\"0\":{\"202\":1}}],[\"力扣题目链接\",{\"1\":{\"360\":1,\"361\":1,\"362\":1,\"363\":1,\"364\":1,\"371\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"383\":1,\"384\":1,\"385\":1,\"389\":1,\"402\":1,\"403\":1,\"404\":1,\"407\":1,\"408\":1,\"409\":1,\"410\":1,\"411\":1,\"412\":1}}],[\"梦开始的地方\",{\"1\":{\"359\":1}}],[\"yieldingwaitstrategy\",{\"1\":{\"1398\":1}}],[\"yieldingwaitstrategy策略\",{\"1\":{\"1397\":1}}],[\"yield\",{\"1\":{\"1397\":2,\"1431\":1}}],[\"yichang\",{\"1\":{\"713\":1}}],[\"yyyymmddhhmmss\",{\"1\":{\"666\":1}}],[\"yyyy\",{\"1\":{\"666\":3,\"1405\":1}}],[\"yet\",{\"1\":{\"1497\":2,\"1524\":1}}],[\"year\",{\"1\":{\"561\":1,\"666\":1}}],[\"yes\",{\"1\":{\"467\":8,\"616\":2,\"729\":1}}],[\"y1\",{\"1\":{\"559\":3}}],[\"y3\",{\"1\":{\"559\":4}}],[\"y2\",{\"1\":{\"559\":4}}],[\"ynoteshare\",{\"1\":{\"446\":1,\"449\":1,\"654\":1,\"796\":1,\"800\":1}}],[\"y\",{\"1\":{\"356\":1,\"469\":1,\"489\":1,\"491\":1,\"492\":1,\"514\":5,\"554\":1,\"559\":5}}],[\"young\",{\"0\":{\"1629\":1}}],[\"young区域的数据页没有被合理地淘汰\",{\"1\":{\"543\":1}}],[\"youdao\",{\"1\":{\"446\":1,\"449\":1,\"654\":2,\"668\":1,\"677\":1,\"796\":1,\"800\":1,\"1540\":1}}],[\"your\",{\"1\":{\"1\":2,\"3\":1,\"392\":1,\"457\":1}}],[\"you\",{\"1\":{\"1\":1,\"2\":1,\"3\":3,\"4\":1,\"457\":1,\"748\":2,\"1492\":1,\"1500\":4}}],[\"组合注解\",{\"0\":{\"1296\":1}}],[\"组合模式\",{\"0\":{\"1002\":1}}],[\"组件\",{\"0\":{\"1289\":1}}],[\"组员可能越多\",{\"1\":{\"588\":1}}],[\"组员越多\",{\"1\":{\"588\":1}}],[\"组团\",{\"1\":{\"356\":1}}],[\"组成的双向循环链表\",{\"1\":{\"1360\":1}}],[\"组成集合writeset\",{\"1\":{\"602\":1}}],[\"组成\",{\"1\":{\"307\":1,\"679\":1,\"761\":1}}],[\"拓扑排序\",{\"0\":{\"356\":1}}],[\"图中binlog备份系统到线上备库有一条虚线\",{\"1\":{\"622\":1}}],[\"图中备库上sql\",{\"1\":{\"597\":1}}],[\"图中两个黑色的箭头\",{\"1\":{\"597\":1}}],[\"图中sbm是seconds\",{\"1\":{\"595\":1}}],[\"图中session\",{\"1\":{\"547\":1}}],[\"图中模拟了6个\",{\"1\":{\"558\":1}}],[\"图中的fsync\",{\"1\":{\"587\":1}}],[\"图中的write\",{\"1\":{\"587\":1}}],[\"图中的pos指的是位置信息\",{\"1\":{\"557\":1}}],[\"图中的步骤4和5表示清空join\",{\"1\":{\"540\":1}}],[\"图中的两个虚线箭头\",{\"1\":{\"482\":1}}],[\"图中number\",{\"1\":{\"491\":1}}],[\"图中3和4\",{\"1\":{\"482\":1}}],[\"图中四个id\",{\"1\":{\"469\":1}}],[\"图中\",{\"1\":{\"469\":1,\"491\":1,\"505\":1,\"542\":1,\"603\":1,\"604\":1,\"616\":1}}],[\"图论\",{\"0\":{\"434\":1}}],[\"图\",{\"0\":{\"355\":1},\"1\":{\"1427\":2}}],[\"图形结构等\",{\"1\":{\"328\":1}}],[\"后端\",{\"1\":{\"1856\":1}}],[\"后端信息维护等工作\",{\"1\":{\"606\":1}}],[\"后拦截器\",{\"1\":{\"1534\":1}}],[\"后续真正加载的时候会被替换为class对象\",{\"1\":{\"1524\":1}}],[\"后续的去重操作当然也都失败了\",{\"1\":{\"1486\":1}}],[\"后续的文章我们有专门的篇幅来介绍方法引用\",{\"1\":{\"1470\":1}}],[\"后续如果有需要\",{\"1\":{\"1386\":1}}],[\"后继节点\",{\"1\":{\"1380\":1}}],[\"后来\",{\"1\":{\"1360\":1}}],[\"后边我们会重点看这个属性的\",{\"1\":{\"690\":1}}],[\"后写入的数据会覆盖之前的数据\",{\"1\":{\"636\":1}}],[\"后台线程会主动写盘\",{\"1\":{\"588\":1}}],[\"后一次查询看到了前一次查询没有看到的行\",{\"1\":{\"583\":1}}],[\"后访问的事务必须等待前一个事务执行完成\",{\"1\":{\"570\":1}}],[\"后执行\",{\"1\":{\"559\":1}}],[\"后\",{\"1\":{\"479\":1,\"1361\":1,\"1362\":1}}],[\"后面会越轻松\",{\"1\":{\"1847\":1}}],[\"后面的将不会再被计算\",{\"1\":{\"1476\":1}}],[\"后面的表示类的哈希值\",{\"1\":{\"1469\":1}}],[\"后面的n刚好在0到length之间\",{\"1\":{\"1425\":1}}],[\"后面的1\",{\"1\":{\"685\":2}}],[\"后面的数都比它大\",{\"1\":{\"366\":1}}],[\"后面还有一个链表\",{\"1\":{\"469\":1}}],[\"后者称为从节点\",{\"1\":{\"743\":1}}],[\"后者会返回null\",{\"1\":{\"354\":2}}],[\"后者则返回false\",{\"1\":{\"354\":1}}],[\"后序\",{\"1\":{\"339\":1}}],[\"后序遍历\",{\"1\":{\"295\":1}}],[\"取中点\",{\"1\":{\"1497\":1}}],[\"取中间记录作为比较对象\",{\"1\":{\"304\":1}}],[\"取的时候也是只返回key\",{\"1\":{\"1434\":1}}],[\"取key的hashcode值\",{\"1\":{\"1425\":1}}],[\"取模运算\",{\"1\":{\"1425\":2}}],[\"取hashcode值\",{\"1\":{\"1425\":1}}],[\"取消所有任务\",{\"1\":{\"1394\":1}}],[\"取消事务\",{\"1\":{\"716\":1}}],[\"取top\",{\"1\":{\"711\":1}}],[\"取两个集合的成员score最小值作为结果的\",{\"1\":{\"711\":1}}],[\"取值范围\",{\"1\":{\"664\":1}}],[\"取最近一次全量备份\",{\"1\":{\"622\":1}}],[\"取到需要的信息\",{\"1\":{\"616\":1}}],[\"取到第二行id=999\",{\"1\":{\"551\":1}}],[\"取binlog的逻辑如下\",{\"1\":{\"605\":1}}],[\"取原主库a故障的时刻t\",{\"1\":{\"604\":1}}],[\"取决于具体的并行操作的类型\",{\"1\":{\"1492\":1}}],[\"取决于业务场景\",{\"1\":{\"610\":1}}],[\"取决于压力模型\",{\"1\":{\"600\":1}}],[\"取决于数据块的大小\",{\"1\":{\"471\":1}}],[\"取不小于x的第一个id的行\",{\"1\":{\"559\":1}}],[\"取下一个行\",{\"1\":{\"558\":1}}],[\"取下一个记录\",{\"1\":{\"493\":1}}],[\"取下一个记录主键id\",{\"1\":{\"493\":1}}],[\"取这两个子查询结果的并集\",{\"1\":{\"551\":1}}],[\"取得y=floor\",{\"1\":{\"559\":1}}],[\"取得整个表的行数\",{\"1\":{\"559\":2}}],[\"取得这个表的主键id最大值m和最小值n\",{\"1\":{\"559\":1}}],[\"取得表t1的全部1000行数据\",{\"1\":{\"545\":1}}],[\"取得id2的值\",{\"1\":{\"487\":1}}],[\"取得id=500\",{\"1\":{\"474\":1}}],[\"取得id=300\",{\"1\":{\"474\":1}}],[\"取前1000行\",{\"1\":{\"492\":1}}],[\"取name\",{\"1\":{\"491\":1,\"492\":1,\"493\":1}}],[\"取出pointcut\",{\"1\":{\"1531\":1}}],[\"取出学生的名字\",{\"1\":{\"1490\":1}}],[\"取出takeindex位置的元素\",{\"1\":{\"1379\":1}}],[\"取出所有字段的值\",{\"1\":{\"657\":1}}],[\"取出凌晨0点之后的日志\",{\"1\":{\"622\":1}}],[\"取出前三个结果的位置信息\",{\"1\":{\"557\":1}}],[\"取出每一行数据跟join\",{\"1\":{\"544\":1}}],[\"取出表t2中满足条件的行\",{\"1\":{\"538\":1}}],[\"取出字段到表t2里去查找\",{\"1\":{\"538\":1}}],[\"取出全部列\",{\"1\":{\"522\":1}}],[\"取出其中的city\",{\"1\":{\"493\":1}}],[\"取出id2\",{\"1\":{\"487\":1}}],[\"取出操作\",{\"1\":{\"353\":1}}],[\"取index2上刚刚查到的位置的下一条记录\",{\"1\":{\"487\":1}}],[\"取index1索引树上刚刚查到的位置的下一条记录\",{\"1\":{\"487\":1}}],[\"取满足条件的第一行\",{\"1\":{\"459\":1}}],[\"者\",{\"1\":{\"351\":1}}],[\"堆顶那个元素就是全局最小的那个\",{\"1\":{\"354\":1}}],[\"堆是具有下列性质的完全二叉树\",{\"1\":{\"351\":1}}],[\"堆\",{\"0\":{\"351\":1,\"1583\":1}}],[\"堆排序可以说是一种利用堆的概念来排序的选择排序\",{\"1\":{\"321\":1}}],[\"堆排序是指利用堆这种数据结构所设计的一种排序算法\",{\"1\":{\"321\":1}}],[\"堆排序\",{\"0\":{\"321\":1},\"1\":{\"316\":1}}],[\"叶子结点包含了完整的数据记录\",{\"1\":{\"642\":1}}],[\"叶子结点包含所有索引字段\",{\"1\":{\"640\":1}}],[\"叶子结点用指针连接\",{\"1\":{\"640\":1}}],[\"叶子结点的指针为空\",{\"1\":{\"639\":1}}],[\"叶子结点具有相同的深度\",{\"1\":{\"639\":1}}],[\"叶子结点\",{\"1\":{\"350\":1}}],[\"小伙伴们根据喜好或者项目需要\",{\"1\":{\"1863\":1}}],[\"小伙伴们可以根据自己情况选择\",{\"1\":{\"1846\":1}}],[\"小刚的英语成绩\",{\"1\":{\"711\":1}}],[\"小刚的数学成绩\",{\"1\":{\"711\":1}}],[\"小红\",{\"1\":{\"711\":2}}],[\"小明\",{\"1\":{\"711\":2}}],[\"小结\",{\"1\":{\"708\":1}}],[\"小数值\",{\"1\":{\"665\":1}}],[\"小整数值\",{\"1\":{\"665\":1}}],[\"小表驱动大表\",{\"1\":{\"662\":2}}],[\"小表\",{\"1\":{\"540\":1}}],[\"小\",{\"1\":{\"351\":1,\"732\":1}}],[\"小于会返回负数\",{\"1\":{\"1480\":1}}],[\"小于事务ta的低水位\",{\"1\":{\"634\":1}}],[\"小于r\",{\"1\":{\"558\":1}}],[\"小于word字段的长度定义\",{\"1\":{\"558\":1}}],[\"小于最低元素的元素\",{\"1\":{\"348\":1}}],[\"小于第二元素的元素\",{\"1\":{\"348\":1}}],[\"小顶堆\",{\"1\":{\"321\":1,\"1383\":1}}],[\"与面向切面编程\",{\"1\":{\"1860\":1}}],[\"与propertyeditor相比\",{\"1\":{\"1516\":1}}],[\"与propertyeditor类似\",{\"1\":{\"1516\":1}}],[\"与原生特定相关的类增加了用来处理结果集合添加到特定的特化的管道\",{\"1\":{\"1498\":1}}],[\"与原库的值不同\",{\"1\":{\"464\":2}}],[\"与之相反\",{\"1\":{\"1496\":1}}],[\"与之前介绍的consumer函数一样\",{\"1\":{\"1475\":1}}],[\"与groupingby相关联的另一个方法就是分区partitioningby\",{\"1\":{\"1495\":1}}],[\"与另一个比较器相比\",{\"1\":{\"1491\":1}}],[\"与分组相关的实际上还有一个概念叫做分区\",{\"1\":{\"1490\":1}}],[\"与map比较类似的还有一个flatmap\",{\"1\":{\"1486\":1}}],[\"与memcached一样\",{\"1\":{\"701\":1}}],[\"与传统的方式\",{\"1\":{\"1484\":1}}],[\"与静态方法引用的不同的是\",{\"1\":{\"1481\":1}}],[\"与大多数其他的函数式接口不同的是\",{\"1\":{\"1474\":1}}],[\"与普通的应用程序不同\",{\"1\":{\"1456\":1}}],[\"与h\",{\"1\":{\"1425\":1}}],[\"与hashmap不同的是\",{\"1\":{\"1421\":1}}],[\"与钱相关的业务\",{\"1\":{\"1356\":1}}],[\"与\",{\"1\":{\"1356\":1,\"1524\":1}}],[\"与key数量相关\",{\"1\":{\"704\":1}}],[\"与servletrequest\",{\"1\":{\"1565\":1}}],[\"与server\",{\"1\":{\"694\":1}}],[\"与synchronized一样\",{\"1\":{\"1371\":1}}],[\"与statement格式的binlog相比\",{\"1\":{\"591\":1}}],[\"与计算idx\",{\"1\":{\"686\":1}}],[\"与字符集相关\",{\"1\":{\"667\":1}}],[\"与字符集无关\",{\"1\":{\"667\":1}}],[\"与时区无关\",{\"1\":{\"666\":1}}],[\"与时区相关\",{\"1\":{\"666\":1}}],[\"与redo\",{\"1\":{\"616\":1}}],[\"与处于commit状态的事务之间\",{\"1\":{\"602\":1}}],[\"与数据同步有关的时间点主要包括以下三个\",{\"1\":{\"594\":1}}],[\"与ftwrl类似\",{\"1\":{\"577\":1}}],[\"与使用delete语句删除数据相比\",{\"1\":{\"563\":1}}],[\"与临时表相类似的还有内存表\",{\"1\":{\"546\":1}}],[\"与没有适用mrr的结果集顺序刚好相反\",{\"1\":{\"541\":1}}],[\"与前面的例子中的sql语句\",{\"1\":{\"488\":1}}],[\"与实际的10000相差较大\",{\"1\":{\"484\":1}}],[\"与查询流程不一样的是\",{\"1\":{\"460\":1}}],[\"与二叉树的深度遍历不同的是\",{\"1\":{\"435\":1}}],[\"与二叉排序树不同的是\",{\"1\":{\"347\":1}}],[\"与oauth2\",{\"0\":{\"228\":1}}],[\"且这些锁大多数都不是偏向锁\",{\"1\":{\"1362\":1}}],[\"且key还没有过期\",{\"1\":{\"706\":1}}],[\"且所有值都接近一个长度用char\",{\"1\":{\"667\":1}}],[\"且p在root的左或右子树中\",{\"1\":{\"398\":1}}],[\"且q在root的左或右子树中\",{\"1\":{\"398\":1}}],[\"且分列root的异侧即分别在左\",{\"1\":{\"398\":1}}],[\"且与二叉排序树类似\",{\"1\":{\"347\":1}}],[\"且每一个结点处可以存储多个元素\",{\"1\":{\"346\":1}}],[\"所需要的类型是obectfactory或objectprovider的\",{\"1\":{\"1525\":1}}],[\"所需要的类型是optional类型的\",{\"1\":{\"1525\":1}}],[\"所需的io成本就是\",{\"1\":{\"686\":1}}],[\"所返回的spliterator必须也是ordered\",{\"1\":{\"1497\":1}}],[\"所分割出来的每个块的大小是固定的\",{\"1\":{\"1497\":1}}],[\"所创建出来的spliterator还有一个额外的特性\",{\"1\":{\"1497\":1}}],[\"所生成的collector类型是map<k\",{\"1\":{\"1495\":1}}],[\"所能容纳的键值对个数就越多\",{\"1\":{\"1423\":1}}],[\"所能容纳的key\",{\"1\":{\"1423\":1}}],[\"所谓copy\",{\"1\":{\"1404\":1}}],[\"所谓不变性\",{\"1\":{\"1403\":1}}],[\"所谓备库延迟\",{\"1\":{\"594\":1}}],[\"所谓的状态转移方程或者说递推公式为\",{\"1\":{\"429\":1}}],[\"所在session\",{\"1\":{\"584\":1}}],[\"所索引结构\",{\"1\":{\"488\":1}}],[\"所有select负责的socket\",{\"1\":{\"1442\":1}}],[\"所有方法均是只读的\",{\"1\":{\"1403\":1}}],[\"所有等待线程被唤醒后\",{\"1\":{\"1360\":1}}],[\"所有等待线程拥有相同的等待条件\",{\"1\":{\"1360\":1}}],[\"所有主从复制的优点\",{\"1\":{\"760\":1}}],[\"所有索引元素不重复\",{\"1\":{\"639\":1}}],[\"所有无主键的innodb表\",{\"1\":{\"632\":1}}],[\"所有读压力都在主库\",{\"1\":{\"607\":1}}],[\"所有事务都会被分配到同一个worker中\",{\"1\":{\"598\":1}}],[\"所有lsn小于等于160的redo\",{\"1\":{\"588\":1}}],[\"所有\",{\"1\":{\"584\":2}}],[\"所有的请求都会经过dispatcherservlet\",{\"1\":{\"1534\":1}}],[\"所有的非懒加载的单例bean都创建完成之后\",{\"1\":{\"1524\":1}}],[\"所有的流管道处理器都会得到调用\",{\"1\":{\"1496\":1}}],[\"所有的关闭处理器都会得到调用而无论它之前的关闭处理器是否抛出了异常\",{\"1\":{\"1496\":1}}],[\"所有的方法一定会返回collectorimpl类型\",{\"1\":{\"1493\":1}}],[\"所有的类默认已经有了这个方法\",{\"1\":{\"1471\":1}}],[\"所有的数据都是通过\",{\"1\":{\"1460\":1}}],[\"所有的线程栈和堆都分布在主内存中\",{\"1\":{\"1350\":1}}],[\"所有的命令都不执行\",{\"1\":{\"717\":1}}],[\"所有的查询都会出现脏读的\",{\"1\":{\"634\":1}}],[\"所有的申请自增主键的动作都是申请后就释放锁\",{\"1\":{\"629\":1}}],[\"所有的检测逻辑都需要一个超时时间n\",{\"1\":{\"615\":1}}],[\"所有的多线程复制都符合下面的这个模型\",{\"1\":{\"597\":1}}],[\"所有的操作需要行锁的都是在事务提交的时候才会释放\",{\"1\":{\"580\":1}}],[\"所有的更新操作都要先判断这个操作是否违反唯一性约束\",{\"1\":{\"480\":1}}],[\"所有对表的增删改查都需要先申请mdl读锁\",{\"1\":{\"578\":1}}],[\"所有引擎都可以使用\",{\"1\":{\"462\":1}}],[\"所有跨存储引擎的功能都在这一层实现\",{\"1\":{\"454\":1}}],[\"所有长度为\",{\"1\":{\"428\":1}}],[\"所有滑动窗口的问题都可以使用队列来解决\",{\"1\":{\"393\":1}}],[\"所有元素之间存在某种特定的排序关系\",{\"1\":{\"346\":1}}],[\"所有可能的插入的情景\",{\"1\":{\"345\":1}}],[\"所以xml的标签和源码一一对应\",{\"1\":{\"1561\":1}}],[\"所以spring容器中要存在sqlsessionfactory类型的bean或者sqlsessiontemplate类型的bean\",{\"1\":{\"1530\":1}}],[\"所以spring会自动调用set方法\",{\"1\":{\"1530\":1}}],[\"所以spring在启动时会调用mapperscannerregistrar类中的registerbeandefinitions方法\",{\"1\":{\"1530\":1}}],[\"所以spring中对类的元数据做了抽象\",{\"1\":{\"1523\":1}}],[\"所以defaultlistablebeanfactory的功能很强大\",{\"1\":{\"1513\":1}}],[\"所以dubbo协议成为了dubbo框架中的默认协议\",{\"1\":{\"798\":1}}],[\"所以无需定义finisher\",{\"1\":{\"1495\":1}}],[\"所以无需说明item的类型\",{\"1\":{\"1474\":1}}],[\"所以直接进入到第二种情况\",{\"1\":{\"1494\":1}}],[\"所以直接更新磁盘文件里的数据性能会很差\",{\"1\":{\"680\":1}}],[\"所以设计者直接将这个类作为一个静态的内部类\",{\"1\":{\"1493\":1}}],[\"所以编译器没有办法准确的推断出类型\",{\"1\":{\"1491\":1}}],[\"所以后面的就不再执行了\",{\"1\":{\"1489\":1}}],[\"所以程序会无限的运行下去\",{\"1\":{\"1487\":1}}],[\"所以流会被正常的调用执行\",{\"1\":{\"1487\":1}}],[\"所以它的特性值是\",{\"1\":{\"1495\":1}}],[\"所以它每次返回的一定是一个新的结果容器\",{\"1\":{\"1485\":1}}],[\"所以它只能猜这10573记录里有多少条记录满足order\",{\"1\":{\"691\":1}}],[\"所以创建了student的实例\",{\"1\":{\"1477\":1}}],[\"所以左边的括号是空值\",{\"1\":{\"1472\":1}}],[\"所以满足函数式接口的定义\",{\"1\":{\"1471\":1}}],[\"所以第一步先校验key\",{\"1\":{\"1431\":1}}],[\"所以第二种方法就是\",{\"1\":{\"485\":1}}],[\"所以hashentry可以构成一个链表\",{\"1\":{\"1430\":1}}],[\"所以key3\",{\"1\":{\"1427\":1}}],[\"所以为什么是函数式接口呢\",{\"1\":{\"1472\":1}}],[\"所以为每个请求创建一个新的线程并不适合高并发场景\",{\"1\":{\"1410\":1}}],[\"所以为了避免队列过大造成机器负载或者内存爆满的情况出现\",{\"1\":{\"1380\":1}}],[\"所以自然也就没有并发问题\",{\"1\":{\"1405\":1}}],[\"所以函数式编程的所有的修改操作都需要copy\",{\"1\":{\"1404\":1}}],[\"所以将读操作的性能发挥到了极致\",{\"1\":{\"1404\":1}}],[\"所以将这个参数设置成2跟设置0的性能相差并不多\",{\"1\":{\"588\":1}}],[\"所以一般我们采用的方法是设置一个标志位\",{\"1\":{\"1401\":1}}],[\"所以一旦满了就无法再往里放数据了\",{\"1\":{\"1378\":1}}],[\"所以linkedblockingqueue也被称作无界队列\",{\"1\":{\"1380\":1}}],[\"所以生产者和消费者都可以是多线程的\",{\"1\":{\"1378\":1}}],[\"所以应该允许多个线程同时读取共享资源\",{\"1\":{\"1375\":1}}],[\"所以cyclicbarrier能处理更为复杂的业务场景\",{\"1\":{\"1373\":1}}],[\"所以count\",{\"1\":{\"536\":1}}],[\"所以调用condition\",{\"1\":{\"1370\":2}}],[\"所以循环校验条件\",{\"1\":{\"1360\":1}}],[\"所以jedis是无法生效的\",{\"1\":{\"720\":1}}],[\"所以事务中的命令在加入时都没有被执行\",{\"1\":{\"716\":1}}],[\"所以bitmaps是一串从左到右的二进制串\",{\"1\":{\"715\":1}}],[\"所以binlog里面对表t2的更新日志只有两种情况\",{\"1\":{\"629\":1}}],[\"所以binlog是statement格式也是可以的\",{\"1\":{\"602\":1}}],[\"所以binlog得write和fsync间的间隔时间端\",{\"1\":{\"588\":1}}],[\"所以zset命令也可以使用\",{\"1\":{\"713\":1}}],[\"所以添加\",{\"1\":{\"709\":1}}],[\"所以命令也就分为了lxxx和rlll两类\",{\"1\":{\"708\":1}}],[\"所以会返回\",{\"1\":{\"706\":2}}],[\"所以会直接把临时表temp\",{\"1\":{\"548\":1}}],[\"所以也非常的重要\",{\"1\":{\"1491\":1}}],[\"所以也不需要再统计一遍在索引列后加上主键值的不重复值有多少\",{\"1\":{\"695\":1}}],[\"所以也许一个批量下线机器的操作\",{\"1\":{\"625\":1}}],[\"所以该值默认是0\",{\"1\":{\"694\":1}}],[\"所以关于这些操作对应的成本常数就存储在了server\",{\"1\":{\"694\":1}}],[\"所以此时使用s1作为驱动表的总成本就是\",{\"1\":{\"692\":1}}],[\"所以想要得到最优的查询方案只需要分别为驱动表和被驱动表选择成本最低的访问方法\",{\"1\":{\"692\":1}}],[\"所以总共需要回表的记录数就是\",{\"1\":{\"690\":1}}],[\"所以总的扫描行数是m+n\",{\"1\":{\"540\":1}}],[\"所以提供了一个系统变量eq\",{\"1\":{\"690\":1}}],[\"所以选择idx\",{\"1\":{\"688\":1}}],[\"所以每个单点区间都需要查找一遍对应的二级索引记录数\",{\"1\":{\"686\":1}}],[\"所以访问这3个范围区间的二级索引付出的io成本就是\",{\"1\":{\"686\":1}}],[\"所以本例中使用idx\",{\"1\":{\"686\":1}}],[\"所以本例中使用id\",{\"1\":{\"686\":1}}],[\"所以回表操作带来的io成本就是\",{\"1\":{\"686\":1}}],[\"所以读取这39条二级索引记录需要付出的cpu成本就是\",{\"1\":{\"686\":1}}],[\"所以计算页b和页c之间有多少页面就相当于计算它们父节点\",{\"1\":{\"686\":1}}],[\"所以计算全表扫描的代价需要两个信息\",{\"1\":{\"685\":1}}],[\"所以相当于访问这个范围区间的二级索引付出的io成本就是\",{\"1\":{\"686\":1}}],[\"所以全表扫描的总成本\",{\"1\":{\"685\":1}}],[\"所以order\",{\"1\":{\"685\":1}}],[\"所以并没有什么用\",{\"1\":{\"692\":1}}],[\"所以并没有统一的索引标准\",{\"1\":{\"471\":1}}],[\"所以并不会对这个接口的抽象方法的总数有影响\",{\"1\":{\"1472\":1}}],[\"所以并不会使用索引合并\",{\"1\":{\"687\":1}}],[\"所以并不能确定一个单点区间对应的二级索引记录的条数有多少\",{\"1\":{\"690\":1}}],[\"所以并不能使用索引\",{\"1\":{\"684\":1}}],[\"所以内存中的判断次数是100\",{\"1\":{\"662\":1}}],[\"所以可以强转成功\",{\"1\":{\"1495\":2}}],[\"所以可以作为comparator这个lambda表达式的方法体\",{\"1\":{\"1480\":1}}],[\"所以可以完成调用\",{\"1\":{\"1470\":1}}],[\"所以可以让排序和分页操作先查出主键\",{\"1\":{\"659\":1}}],[\"所以可能在拿到io资源的时候就可以提交成功\",{\"1\":{\"615\":1}}],[\"所以优化器放弃使用索引\",{\"1\":{\"659\":1}}],[\"所以mysql简单的认为不管这个块有没有加载到内存中\",{\"1\":{\"694\":1}}],[\"所以mysql干脆提出了一些所谓的启发式规则\",{\"1\":{\"693\":1}}],[\"所以mysql最终选择索引扫描\",{\"1\":{\"656\":1}}],[\"所以mysql最终选择全表扫描\",{\"1\":{\"656\":1}}],[\"所以mysql选错索引肯定是在判断扫描行数的时候出现了问题\",{\"1\":{\"484\":1}}],[\"所以上文中脏读的例子就是一个必现的bug\",{\"1\":{\"636\":1}}],[\"所以只需从符合二级索引范围区间的记录中猜有多少条记录符合order\",{\"1\":{\"691\":1}}],[\"所以只要我们通过根节点获得了最左边的叶子节点\",{\"1\":{\"685\":1}}],[\"所以只读事务优化后\",{\"1\":{\"634\":1}}],[\"所以只能采用这种方法来创建从库和新主库的主备关系\",{\"1\":{\"604\":1}}],[\"所以只能选择\",{\"1\":{\"484\":1}}],[\"所以row\",{\"1\":{\"632\":1}}],[\"所以id=5到id=7就被浪费掉了\",{\"1\":{\"629\":1}}],[\"所以id=2这一行并没有插入成功\",{\"1\":{\"628\":1}}],[\"所以innodb在设计时\",{\"1\":{\"613\":1}}],[\"所以报duplicate\",{\"1\":{\"628\":1}}],[\"所以打开这个统计功能是有性能损耗的\",{\"1\":{\"616\":1}}],[\"所以系统可能已经出问题了\",{\"1\":{\"615\":1}}],[\"所以系统认为只扫描了一行\",{\"1\":{\"487\":1}}],[\"所以对于两表连接查询来说\",{\"1\":{\"691\":1}}],[\"所以对ha系统的开发人员来说\",{\"1\":{\"605\":1}}],[\"所以对更新性能的提升是会很明显的\",{\"1\":{\"480\":1}}],[\"所以实例x就会直接跳过这个事务\",{\"1\":{\"605\":1}}],[\"所以主备切换的复杂性也相应增加了\",{\"1\":{\"603\":1}}],[\"所以主备库选用相同规格的机器\",{\"1\":{\"594\":1}}],[\"所以按表分发\",{\"1\":{\"598\":1}}],[\"所以就需要根据实际情况确定哈希桶数组的大小\",{\"1\":{\"1423\":1}}],[\"所以就多扫描了一次t1表\",{\"1\":{\"662\":1}}],[\"所以就使用差一点儿的机器\",{\"1\":{\"594\":1}}],[\"所以就不用考虑其它索引叶子节点大小的问题了\",{\"1\":{\"472\":1}}],[\"所以要使用row格式\",{\"1\":{\"591\":1}}],[\"所以要简单地对比这两个机制在提升性能上地收益的话\",{\"1\":{\"482\":1}}],[\"所以速度比较快\",{\"1\":{\"587\":1}}],[\"所以q2和q3就是应该看到这两个事务的操作效果\",{\"1\":{\"583\":1}}],[\"所以v3的值也是2\",{\"1\":{\"570\":1}}],[\"所以插入失败\",{\"1\":{\"551\":1}}],[\"所以最后只会有一行不一致\",{\"1\":{\"596\":1}}],[\"所以最后得到的结果集也是按照主键id递增顺序的\",{\"1\":{\"541\":1}}],[\"所以最后这6位就提供了足够的区分度\",{\"1\":{\"489\":1}}],[\"所以我们可以自定义线程的终止标志位用于终止线程\",{\"1\":{\"1401\":1}}],[\"所以我们可以根据是否需要扩容来选择合适的队列\",{\"1\":{\"1386\":1}}],[\"所以我们可以认为\",{\"1\":{\"541\":1}}],[\"所以我们redis默认的配置就是rdb持久化\",{\"1\":{\"730\":1}}],[\"所以我们优化的重点就是下面两个部分\",{\"1\":{\"692\":1}}],[\"所以我们看到sort\",{\"1\":{\"558\":1}}],[\"所以我们称之为\",{\"1\":{\"538\":1}}],[\"所以我们叫红黑树这种平衡为黑色完美平衡\",{\"1\":{\"343\":1}}],[\"所以运行多个小查询现在已经不是大问题了\",{\"1\":{\"529\":1}}],[\"所以没有产生using\",{\"1\":{\"515\":1}}],[\"所以尝试在book表和phone表上添加索引\",{\"1\":{\"500\":1}}],[\"所以如果5\",{\"1\":{\"690\":1}}],[\"所以如果等待超时\",{\"1\":{\"610\":1}}],[\"所以如果要在同一个库下创建两个同名的临时表\",{\"1\":{\"549\":1}}],[\"所以如果单行很大\",{\"1\":{\"492\":1}}],[\"所以如果长连接累积下来\",{\"1\":{\"455\":1}}],[\"所以图中的examined\",{\"1\":{\"491\":1}}],[\"所以查询性能更好\",{\"1\":{\"606\":1}}],[\"所以查询语句where部分要判断id\",{\"1\":{\"489\":1}}],[\"所以查找跟二叉平衡树的查找无异\",{\"1\":{\"344\":1}}],[\"所以同一个县的人的身份证号前6位一般会是相同的\",{\"1\":{\"489\":1}}],[\"所以需要先等待一会\",{\"1\":{\"1431\":1}}],[\"所以需要持久化\",{\"1\":{\"702\":1}}],[\"所以需要将聚簇索引对应的页面加载到内存中\",{\"1\":{\"685\":1}}],[\"所以需要在从库b刚开始接到新主库a\",{\"1\":{\"604\":1}}],[\"所以需要找一个地方把这个值定期地持久化存储起来\",{\"1\":{\"534\":1}}],[\"所以需要做类型转换\",{\"1\":{\"504\":1}}],[\"所以需要预先设定一个可以接受的损失比例\",{\"1\":{\"487\":1}}],[\"所以需要扫描50001行\",{\"1\":{\"484\":1}}],[\"所以即使扫描的行数多\",{\"1\":{\"485\":1}}],[\"所以不要使用这些特性值之外的值\",{\"1\":{\"1497\":1}}],[\"所以不存在频繁创建对象的问题\",{\"1\":{\"1405\":1}}],[\"所以不同阻塞队列的容量是千差万别的\",{\"1\":{\"1386\":1}}],[\"所以不会对用户进程产生任何block\",{\"1\":{\"1443\":1}}],[\"所以不会用到索引\",{\"1\":{\"684\":1}}],[\"所以不会增加扫描行数\",{\"1\":{\"557\":1}}],[\"所以不论是在innodb\",{\"1\":{\"634\":1}}],[\"所以不需要这个额外的操作\",{\"1\":{\"547\":1}}],[\"所以不管是n是20还是8\",{\"1\":{\"484\":1}}],[\"所以不得不回表\",{\"1\":{\"474\":1}}],[\"所以当变更的数据行超过1\",{\"1\":{\"484\":1}}],[\"所以这里调用list的add\",{\"1\":{\"1485\":1}}],[\"所以这里使用了prepare+execute的方法\",{\"1\":{\"559\":1}}],[\"所以这段代码也可以这么写\",{\"1\":{\"1484\":1}}],[\"所以这就出现了triple协议\",{\"1\":{\"798\":1}}],[\"所以这套方案很有效地解决了redis高可用的问题\",{\"1\":{\"758\":1}}],[\"所以这时cpu的每个核心工作基本都是满负荷的\",{\"1\":{\"1387\":1}}],[\"所以这时候session\",{\"1\":{\"618\":1}}],[\"所以这时候加上这条update语句也很合理\",{\"1\":{\"584\":1}}],[\"所以这时日志丢了也不会有损失\",{\"1\":{\"588\":1}}],[\"所以这两个开源分支目前都支持ddl\",{\"1\":{\"578\":1}}],[\"所以这两个表在备库的应用线程里不会冲突\",{\"1\":{\"550\":1}}],[\"所以这条update语句会锁住整个表t上的读\",{\"1\":{\"561\":1}}],[\"所以这种改写得满足以下两个条件\",{\"1\":{\"659\":1}}],[\"所以这种join尽量不要使用\",{\"1\":{\"540\":1}}],[\"所以这种方式还能避免占用内存\",{\"1\":{\"480\":1}}],[\"所以这个类的主要作用就是开启自动代理的作用\",{\"1\":{\"1532\":1}}],[\"所以这个泛型是成立的\",{\"1\":{\"1496\":1}}],[\"所以这个条件一定会为true\",{\"1\":{\"1431\":1}}],[\"所以这个值无用\",{\"1\":{\"692\":1}}],[\"所以这个查询可能使用到idx\",{\"1\":{\"692\":1}}],[\"所以这个查询可能会用到idx\",{\"1\":{\"692\":1}}],[\"所以这个查询也不用把4000行全都读一遍\",{\"1\":{\"493\":1}}],[\"所以这个统计过程页不是很耗费性能\",{\"1\":{\"686\":1}}],[\"所以这个过程的性能消耗是可以忽略不计的\",{\"1\":{\"686\":1}}],[\"所以这个过程就被改写成\",{\"1\":{\"505\":1}}],[\"所以这个时候索引下推并不会减少查询全行数据的效果\",{\"1\":{\"655\":1}}],[\"所以这个命令可能是unsafe的\",{\"1\":{\"591\":1}}],[\"所以这个写盘的动作只是write\",{\"1\":{\"588\":1}}],[\"所以这一行c的值是0\",{\"1\":{\"464\":1}}],[\"所以在学习算法之前\",{\"1\":{\"1848\":1}}],[\"所以在定义函数式接口的时候\",{\"1\":{\"1471\":1}}],[\"所以在rehash的过程中\",{\"1\":{\"1430\":1}}],[\"所以在新增数据的时候\",{\"1\":{\"1430\":1}}],[\"所以在实际工作中\",{\"1\":{\"1404\":1}}],[\"所以在多线程竞争频繁的情况下\",{\"1\":{\"1362\":1}}],[\"所以在session\",{\"1\":{\"634\":1}}],[\"所以在备库b傻姑娘执行的检测命令\",{\"1\":{\"615\":1}}],[\"所以在出现主备切换\",{\"1\":{\"606\":1}}],[\"所以在确定位点的时候\",{\"1\":{\"604\":1}}],[\"所以在主备切换的时候\",{\"1\":{\"594\":1}}],[\"所以在t1时刻\",{\"1\":{\"561\":1}}],[\"所以在这个事务提交之前\",{\"1\":{\"571\":1}}],[\"所以在这个session结束的时候\",{\"1\":{\"547\":1}}],[\"所以在这种算法下\",{\"1\":{\"540\":1}}],[\"所以在被驱动表上查一行的时间复杂度是2\",{\"1\":{\"538\":1}}],[\"所以在不同类型的应用压力下\",{\"1\":{\"525\":1}}],[\"所以在一个数据页做merge之前\",{\"1\":{\"481\":1}}],[\"所以在计算平均性能差异的时候\",{\"1\":{\"479\":1}}],[\"所以在使用的过程中要尽量减少建立连接的动作\",{\"1\":{\"455\":1}}],[\"所以说redis单条指令保证原子性\",{\"1\":{\"717\":1}}],[\"所以说\",{\"1\":{\"479\":1,\"1438\":1}}],[\"所以使用覆盖索引是一个常用的性能优化手段\",{\"1\":{\"475\":1}}],[\"所以从库b\",{\"1\":{\"605\":1}}],[\"所以从结果里面可以看到各个字段的值\",{\"1\":{\"591\":1}}],[\"所以从性能和存储空间方面考量\",{\"1\":{\"472\":1}}],[\"所以从1开始\",{\"1\":{\"319\":1}}],[\"所以哈希索引做区间查询的速度是很慢的\",{\"1\":{\"469\":1}}],[\"所以长度就是8\",{\"1\":{\"467\":1}}],[\"所以很快\",{\"1\":{\"467\":1}}],[\"所以\",{\"1\":{\"464\":1,\"481\":1,\"484\":1,\"488\":1,\"498\":1,\"524\":1,\"525\":1,\"533\":1,\"538\":1,\"540\":1,\"547\":1,\"549\":1,\"550\":2,\"554\":1,\"559\":1,\"561\":1,\"570\":1,\"580\":1,\"581\":1,\"584\":1,\"588\":2,\"591\":3,\"592\":1,\"594\":4,\"599\":1,\"604\":1,\"605\":1,\"618\":2,\"619\":1,\"621\":2,\"628\":1,\"629\":1,\"634\":2,\"692\":1,\"714\":1,\"1380\":1,\"1387\":1,\"1393\":1,\"1427\":1,\"1442\":1,\"1469\":1,\"1474\":1,\"1477\":1,\"1483\":1,\"1484\":1}}],[\"所以恢复这一行c的值是1\",{\"1\":{\"464\":1}}],[\"所以是小于等于n\",{\"1\":{\"375\":1}}],[\"所以经常被搜索引擎系统用于文本词频统计\",{\"1\":{\"301\":1}}],[\"红色\",{\"1\":{\"1427\":1}}],[\"红色在父结点\",{\"1\":{\"345\":1}}],[\"红黑树是为了解决当哈希冲突比较多的时候\",{\"1\":{\"1352\":1}}],[\"红黑树是二叉查找树\",{\"1\":{\"343\":1}}],[\"红黑树来实现\",{\"1\":{\"1352\":1}}],[\"红黑树的黑色平衡没被破坏\",{\"1\":{\"345\":1}}],[\"红黑树的插入\",{\"0\":{\"345\":1}}],[\"红黑树的查找\",{\"0\":{\"344\":1}}],[\"红黑树并不是一个完美平衡二叉查找树\",{\"1\":{\"343\":1}}],[\"红黑树\",{\"0\":{\"342\":1},\"1\":{\"638\":1}}],[\"结构型模式\",{\"0\":{\"1000\":1}}],[\"结构的\",{\"1\":{\"736\":1}}],[\"结构\",{\"1\":{\"736\":1}}],[\"结合性指的是分割计算也会得到一个等价的结果\",{\"1\":{\"1492\":1}}],[\"结合性\",{\"1\":{\"1492\":1}}],[\"结合rows统计数据\",{\"1\":{\"690\":1}}],[\"结合前面关于位点的判断\",{\"1\":{\"609\":1}}],[\"结合之前explain进行全面分析\",{\"1\":{\"565\":1}}],[\"结合分区规则来实现的\",{\"1\":{\"562\":1}}],[\"结论\",{\"0\":{\"501\":1},\"1\":{\"656\":1}}],[\"结果不应该依赖于在流管道执行过程当中可能会修改的任意状态\",{\"1\":{\"1496\":1}}],[\"结果如下图\",{\"1\":{\"1428\":1}}],[\"结果由第二个任务返回\",{\"1\":{\"1395\":1}}],[\"结果发现没什么数据可以写\",{\"1\":{\"742\":1}}],[\"结果读了一部分就返回了\",{\"1\":{\"740\":1}}],[\"结果存放到sumscore\",{\"1\":{\"711\":1}}],[\"结果是无序的\",{\"1\":{\"709\":1}}],[\"结果是按照主键排序的\",{\"1\":{\"659\":1}}],[\"结果中包含两行数据分别是1000和999\",{\"1\":{\"551\":1}}],[\"结果集里的第一行就是\",{\"1\":{\"554\":2}}],[\"结果集\",{\"1\":{\"492\":1}}],[\"结果一定是下三角矩阵\",{\"1\":{\"426\":1}}],[\"结束\",{\"1\":{\"345\":3}}],[\"结点中的数据索引从左到右递增排列\",{\"1\":{\"639\":1}}],[\"结点最大的孩子数目称为b树的阶\",{\"1\":{\"349\":1}}],[\"结点的颜色由红变黑或由黑变红\",{\"1\":{\"343\":1}}],[\"结点本身不存完整单词\",{\"1\":{\"301\":1}}],[\"返回statelessop的匿名内部类对象\",{\"1\":{\"1499\":1}}],[\"返回spliterator和它的元素特性值的集合\",{\"1\":{\"1497\":1}}],[\"返回score在\",{\"1\":{\"711\":1}}],[\"返回对于遍历可能会遇到的元中的元素的数量的估算值\",{\"1\":{\"1497\":1}}],[\"返回流中元素的分割迭代器\",{\"1\":{\"1496\":1}}],[\"返回针对于流中元素的迭代器\",{\"1\":{\"1496\":1}}],[\"返回了supplier\",{\"1\":{\"1494\":1}}],[\"返回了流中student的姓名字段\",{\"1\":{\"1490\":1}}],[\"返回map对象\",{\"1\":{\"1490\":1}}],[\"返回r类型的结果\",{\"1\":{\"1486\":1}}],[\"返回值\",{\"1\":{\"1483\":1}}],[\"返回值的特性正好与构造方法的作用不谋而合\",{\"1\":{\"1483\":1}}],[\"返回值是另一个函数的情况是非常常见的\",{\"1\":{\"1470\":1}}],[\"返回值为0\",{\"1\":{\"1375\":2}}],[\"返回值为1\",{\"1\":{\"1375\":1}}],[\"返回原来的值\",{\"1\":{\"1380\":1,\"1431\":1}}],[\"返回原值\",{\"1\":{\"1380\":2}}],[\"返回头部\",{\"1\":{\"1379\":2}}],[\"返回特定值\",{\"1\":{\"1378\":1}}],[\"返回true\",{\"1\":{\"1378\":1}}],[\"返回队首元素\",{\"1\":{\"1377\":1}}],[\"返回并删除队首元素\",{\"1\":{\"1377\":2}}],[\"返回false\",{\"1\":{\"1377\":1,\"1378\":1}}],[\"返回内存中的value值\",{\"1\":{\"1356\":1}}],[\"返回期望值e\",{\"1\":{\"1356\":1}}],[\"返回字符串里面第一个被设置为1或者0的bit位\",{\"1\":{\"715\":1}}],[\"返回输入的各个元素\",{\"1\":{\"714\":1}}],[\"返回一个额外带有关闭处理器的流\",{\"1\":{\"1496\":1}}],[\"返回一个无序的流\",{\"1\":{\"1496\":1}}],[\"返回一个等价的并行流\",{\"1\":{\"1496\":1}}],[\"返回一个等价的串行流\",{\"1\":{\"1496\":1}}],[\"返回一个boolean值类型的函数式接口\",{\"1\":{\"1476\":1}}],[\"返回一个或多个位置元素的geohash表示\",{\"1\":{\"713\":1}}],[\"返回一个结果\",{\"1\":{\"454\":1,\"1475\":2}}],[\"返回两个给定位置之间的距离\",{\"1\":{\"713\":1}}],[\"返回成员m7索引\",{\"1\":{\"711\":1}}],[\"返回集合中\",{\"1\":{\"711\":1}}],[\"返回集合中分数在\",{\"1\":{\"711\":1}}],[\"返回集合中所有的成员\",{\"1\":{\"709\":1}}],[\"返回排序结果的\",{\"1\":{\"711\":1}}],[\"返回所有成员\",{\"1\":{\"711\":1}}],[\"返回所有集合的并集\",{\"1\":{\"709\":1}}],[\"返回所有集合的交集\",{\"1\":{\"709\":1}}],[\"返回所有集合的差集\",{\"1\":{\"709\":1}}],[\"返回有序集合中指定成员的排名\",{\"1\":{\"711\":1}}],[\"返回有序集合中指定成员的索引\",{\"1\":{\"711\":1}}],[\"返回有序集中指定字典区间内的成员\",{\"1\":{\"711\":1}}],[\"返回有序集中指定分数区间内的成员\",{\"1\":{\"711\":1}}],[\"返回有序集中指定区间内的成员\",{\"1\":{\"711\":1}}],[\"返回有序集中\",{\"1\":{\"711\":1}}],[\"返回1\",{\"1\":{\"709\":1}}],[\"返回0\",{\"1\":{\"611\":1,\"709\":1,\"710\":1}}],[\"返回前面多少条记录\",{\"1\":{\"566\":1}}],[\"返回记录\",{\"1\":{\"566\":1}}],[\"返回给定\",{\"1\":{\"714\":1}}],[\"返回给客户端\",{\"1\":{\"557\":1}}],[\"返回给server层\",{\"1\":{\"536\":1}}],[\"返回的sink会接收一个元素\",{\"1\":{\"1500\":1}}],[\"返回的sink\",{\"1\":{\"1500\":1}}],[\"返回的是k类型\",{\"1\":{\"1495\":1}}],[\"返回的是一个空的集合\",{\"1\":{\"1495\":1}}],[\"返回的是一个optional对象\",{\"1\":{\"1487\":1}}],[\"返回的collector是对流中的每一个元素执行传入的整型值函数\",{\"1\":{\"1495\":1}}],[\"返回的df是不同的\",{\"1\":{\"1405\":1}}],[\"返回的成功的行数值可以作为加锁成功的依据\",{\"1\":{\"1375\":1}}],[\"返回的结果如图所示\",{\"1\":{\"553\":1}}],[\"返回的行数\",{\"1\":{\"524\":1}}],[\"返回结果但不抛出异常\",{\"1\":{\"1378\":1}}],[\"返回结果的\",{\"1\":{\"711\":1}}],[\"返回结果给客户端\",{\"1\":{\"657\":1}}],[\"返回结果\",{\"1\":{\"551\":1,\"1394\":1}}],[\"返回结果中key字段显式\",{\"1\":{\"484\":1}}],[\"返回本表和关联表某个值匹配的所有行\",{\"1\":{\"467\":1}}],[\"返回当前结点的父结点\",{\"1\":{\"345\":1}}],[\"返回当前结点\",{\"1\":{\"344\":1}}],[\"返回null\",{\"1\":{\"344\":1,\"1378\":1,\"1497\":1}}],[\"若没找到即缓存未命中\",{\"1\":{\"763\":1}}],[\"若脚本执行后返回2\",{\"1\":{\"761\":1}}],[\"若脚本执行后返回1\",{\"1\":{\"761\":1}}],[\"若此时重新配置称为从机\",{\"1\":{\"748\":1}}],[\"若不是使用配置文件配置的从机\",{\"1\":{\"748\":1}}],[\"若row的trx\",{\"1\":{\"679\":2}}],[\"若root是p\",{\"1\":{\"398\":1}}],[\"若隔离级别是\",{\"1\":{\"570\":4}}],[\"若union包含在from子句的子查询中\",{\"1\":{\"467\":1}}],[\"若其左子节点root\",{\"1\":{\"398\":1}}],[\"若节点p在节点root的左\",{\"1\":{\"398\":1}}],[\"若根结点不为空\",{\"1\":{\"345\":1}}],[\"若根结点为空\",{\"1\":{\"345\":1}}],[\"若当前结点为null\",{\"1\":{\"345\":1}}],[\"若当前结点为空\",{\"1\":{\"344\":1}}],[\"若当前结点key等于查找key\",{\"1\":{\"345\":1}}],[\"若当前结点key小于查找key\",{\"1\":{\"344\":1,\"345\":1}}],[\"若当前结点key大于查找key\",{\"1\":{\"344\":1,\"345\":1}}],[\"若当前结点等于查找key\",{\"1\":{\"344\":1}}],[\"若当前结点不为空\",{\"1\":{\"344\":1}}],[\"若给定值大于中间记录的关键字\",{\"1\":{\"304\":1}}],[\"若给定值小于中间记录的关键字\",{\"1\":{\"304\":1}}],[\"若给定值与中间记录的关键字相等\",{\"1\":{\"304\":1}}],[\"因而具有很快的访问速度\",{\"1\":{\"1421\":1}}],[\"因a已被执行\",{\"1\":{\"1408\":1}}],[\"因为并不是所有的公司都有全文检索的需求\",{\"1\":{\"1864\":1}}],[\"因为并不是所有的行的访问代价都是相同的\",{\"1\":{\"526\":1}}],[\"因为做的项目中使用到了\",{\"1\":{\"1863\":1}}],[\"因为dogetbean方法的逻辑是\",{\"1\":{\"1538\":1}}],[\"因为handlemethod需要在spring\",{\"1\":{\"1537\":1}}],[\"因为如果遵循的话\",{\"1\":{\"1499\":1}}],[\"因为时间间隔增大了\",{\"1\":{\"1497\":1}}],[\"因为避免了在使用hasnext和next方法的竞争的出现\",{\"1\":{\"1497\":1}}],[\"因为某些保证实在执行之前才是有效的\",{\"1\":{\"1497\":1}}],[\"因为某些原因而造成故障停机\",{\"1\":{\"729\":1}}],[\"因为无需进行最后的合并操作\",{\"1\":{\"1494\":1}}],[\"因为无法保证与supplier\",{\"1\":{\"1494\":1}}],[\"因为无法再进行跳跃\",{\"1\":{\"421\":1}}],[\"因为其不接收参数\",{\"1\":{\"1483\":1}}],[\"因为行为总是被预先定义好的\",{\"1\":{\"1475\":1}}],[\"因为object类是所有类的父类\",{\"1\":{\"1471\":1}}],[\"因为编译器可以自动推断出当前遍历集合当前元素的类型\",{\"1\":{\"1470\":1}}],[\"因为一个异常不能压制它本身\",{\"1\":{\"1496\":1}}],[\"因为一个线程只能处理一个连接\",{\"1\":{\"1450\":1}}],[\"因为一个线程功能只能处理一个连接\",{\"1\":{\"1450\":1}}],[\"因为一条语句的执行其实是分为两层的\",{\"1\":{\"694\":1}}],[\"因为resize的过程\",{\"1\":{\"1427\":1}}],[\"因为row格式在记录binlog的时候\",{\"1\":{\"596\":1}}],[\"因为rowid其实就是数组的下标\",{\"1\":{\"557\":1}}],[\"因为n变为2倍\",{\"1\":{\"1427\":1}}],[\"因为要一天内处理完\",{\"1\":{\"1413\":1}}],[\"因为要能够从binlog里面解析出表名\",{\"1\":{\"599\":1}}],[\"因为使用了while循环去等待\",{\"1\":{\"1407\":1}}],[\"因为线程的状态可能处于休眠态\",{\"1\":{\"1401\":1}}],[\"因为写屏障即内存一致性协议会导致同一时间只能一个线程操作该缓存行\",{\"1\":{\"1396\":1}}],[\"因为io读写速度相比于cpu的速度是比较慢的\",{\"1\":{\"1387\":1}}],[\"因为id中间可能由空洞\",{\"1\":{\"559\":1}}],[\"因为计算任务非常重\",{\"1\":{\"1387\":1}}],[\"因为业务可能有高峰期\",{\"1\":{\"1386\":1}}],[\"因为唤醒是需要加putlock的\",{\"1\":{\"1380\":1}}],[\"因为可能有很多线程阻塞在notfull这个条件上\",{\"1\":{\"1380\":1}}],[\"因为可能会导致一些与计算相关的问题\",{\"1\":{\"667\":1}}],[\"因为入队了一个元素\",{\"1\":{\"1379\":1}}],[\"因为阻塞队列是线程安全的\",{\"1\":{\"1378\":1}}],[\"因为我们依赖的第三方库很可能没有正确处理中断一场\",{\"1\":{\"1401\":1}}],[\"因为我们几乎无法把这个容量装满\",{\"1\":{\"1378\":1}}],[\"因为我们通过select系统调用同时处理多个通道描述符的读写事件\",{\"1\":{\"740\":1}}],[\"因为消息是点对点的\",{\"1\":{\"1351\":1}}],[\"因为所有事务都是处理器看到的请求\",{\"1\":{\"1351\":1}}],[\"因为发一个dubbo协议的请求给一个grpc服务\",{\"1\":{\"798\":1}}],[\"因为定时生成\",{\"1\":{\"733\":1}}],[\"因为是使用子进程进行写操作\",{\"1\":{\"725\":1}}],[\"因为事务隔离实质上就是使事务在一定程度上\",{\"1\":{\"669\":1}}],[\"因为不用考虑timestamp将来的时间上限问题\",{\"1\":{\"666\":1}}],[\"因为不是有序的\",{\"1\":{\"469\":1}}],[\"因为myisam存储的引擎的表的总行数会被mysql存储在磁盘上\",{\"1\":{\"663\":1}}],[\"因为当表中某些记录被删后\",{\"1\":{\"659\":1}}],[\"因为当前正在运行的只读事务\",{\"1\":{\"634\":1}}],[\"因为根据name字段过滤完\",{\"1\":{\"655\":1}}],[\"因为同一个只读事务在执行期间\",{\"1\":{\"634\":1}}],[\"因为表自增id达到上限后\",{\"1\":{\"632\":1}}],[\"因为表t中没有c=7这个记录\",{\"1\":{\"585\":1}}],[\"因为碰到了唯一键c冲突\",{\"1\":{\"628\":1}}],[\"因为自增主键不能保证连续递增\",{\"1\":{\"626\":1}}],[\"因为外部检测都需要定时轮询\",{\"1\":{\"615\":1}}],[\"因为从库的延迟时间不可控\",{\"1\":{\"610\":1}}],[\"因为从引擎返回id会涉及到解析数据行\",{\"1\":{\"536\":1}}],[\"因为少了一层proxy转发\",{\"1\":{\"606\":1}}],[\"因为切换过程中\",{\"1\":{\"604\":1}}],[\"因为select系统调用的性能再描述符特别多时性能会非常差\",{\"1\":{\"740\":1}}],[\"因为session\",{\"1\":{\"578\":1}}],[\"因为statement格式的binlog也可以很容易拿到库名\",{\"1\":{\"600\":1}}],[\"因为数据是存储在表里的\",{\"1\":{\"598\":1}}],[\"因为这种整合方式目前也不在流行了\",{\"1\":{\"1860\":1}}],[\"因为这里需要使用两个system\",{\"1\":{\"1442\":1}}],[\"因为这个线程都阻塞在了f1\",{\"1\":{\"1394\":1}}],[\"因为这类语句在申请自增id的时候\",{\"1\":{\"629\":1}}],[\"因为这段时间内\",{\"1\":{\"596\":1}}],[\"因为这三个查询都是加了for\",{\"1\":{\"583\":1}}],[\"因为在spring中是不会扫描接口的\",{\"1\":{\"1530\":1}}],[\"因为在执行过程中\",{\"1\":{\"1494\":1}}],[\"因为在步骤2之后\",{\"1\":{\"595\":1}}],[\"因为在t3时刻\",{\"1\":{\"584\":1}}],[\"因为作为数据库系统\",{\"1\":{\"594\":1}}],[\"因为有时我们并不能在出事的时候很好的准确估计队列的大小\",{\"1\":{\"1386\":1}}],[\"因为有mvcc机制\",{\"1\":{\"663\":1}}],[\"因为有这个操作\",{\"1\":{\"618\":1}}],[\"因为有些语句的执行结果是依赖于上下文命令的\",{\"1\":{\"591\":1}}],[\"因为有些statement格式的binlog可能会导致主备不一致\",{\"1\":{\"591\":1}}],[\"因为有一个崩溃恢复逻辑是要依赖于prepare的redo\",{\"1\":{\"588\":1}}],[\"因为虽然每个客户端的并发量可能很小\",{\"1\":{\"581\":1}}],[\"因为它只需要\",{\"1\":{\"1386\":1}}],[\"因为它只需要开始于索引树的某一点\",{\"1\":{\"467\":1}}],[\"因为它的容量在创建时就确定了\",{\"1\":{\"1386\":1}}],[\"因为它速度快\",{\"1\":{\"665\":1}}],[\"因为它们都需要在读写事件就绪后自己负责进行读写\",{\"1\":{\"1445\":1}}],[\"因为它们通常有更好的性能\",{\"1\":{\"664\":1}}],[\"因为它们要更新同一个影院账户的余额\",{\"1\":{\"580\":1}}],[\"因为新的请求马上就会到\",{\"1\":{\"578\":1}}],[\"因为开启慢查询日志会或多或少带来一定的性能影响\",{\"1\":{\"565\":1}}],[\"因为\",{\"1\":{\"561\":1,\"594\":1,\"613\":1,\"628\":1,\"714\":1,\"1526\":1}}],[\"因为取max\",{\"1\":{\"559\":1}}],[\"因为将max\",{\"1\":{\"558\":1}}],[\"因为备库上并没有表tmp\",{\"1\":{\"550\":1}}],[\"因为目前的优化器会更倾向于不使用mrr\",{\"1\":{\"541\":1}}],[\"因为大多数的数据都是按照主键递增顺序插入得到的\",{\"1\":{\"541\":1}}],[\"因为之前c2这个字段已经确定了是\",{\"1\":{\"515\":1}}],[\"因为c在范围之后\",{\"1\":{\"514\":1}}],[\"因为crc32\",{\"1\":{\"489\":1}}],[\"因为b断了\",{\"1\":{\"514\":1}}],[\"因为系统并不确定前缀索引的定义是否截断了完整信息\",{\"1\":{\"488\":1}}],[\"因为只匹配一行数据\",{\"1\":{\"467\":1}}],[\"因为需要优化\",{\"1\":{\"429\":1}}],[\"因为括号都是成对出现的\",{\"1\":{\"415\":1}}],[\"因为arrays\",{\"1\":{\"387\":1}}],[\"因为红黑树也是一颗二叉平衡树\",{\"1\":{\"344\":1}}],[\"因此还是要学习\",{\"1\":{\"1861\":1}}],[\"因此它需要加载自己的类和依赖的jar包\",{\"1\":{\"1571\":1}}],[\"因此它也被称为\",{\"1\":{\"1356\":1}}],[\"因此也就被称之为动态链接\",{\"1\":{\"1541\":1}}],[\"因此也就不需要临时表了\",{\"1\":{\"551\":1}}],[\"因此beanclass是object类型的属性\",{\"1\":{\"1524\":1}}],[\"因此有两种情况\",{\"1\":{\"1499\":1}}],[\"因此有比较严重的性能问题\",{\"1\":{\"562\":1}}],[\"因此都会自动的调用close方法\",{\"1\":{\"1496\":1}}],[\"因此流并没有被真正的调用\",{\"1\":{\"1487\":1}}],[\"因此同样满足函数式接口的定义\",{\"1\":{\"1471\":1}}],[\"因此随着监视的描述符数量的增长\",{\"1\":{\"1447\":1}}],[\"因此新的index就会发生这样的变化\",{\"1\":{\"1427\":1}}],[\"因此空间利用率更高\",{\"1\":{\"1386\":1}}],[\"因此其实这个过程是线程安全的\",{\"1\":{\"1364\":1}}],[\"因此为了消除数据在无竞争情况下锁重入\",{\"1\":{\"1362\":1}}],[\"因此为了解决幻读问题\",{\"1\":{\"585\":1}}],[\"因此变量mark是boolean类型\",{\"1\":{\"1356\":1}}],[\"因此性能会更好\",{\"1\":{\"798\":1}}],[\"因此我们将这类系统调用称为多路复用api\",{\"1\":{\"740\":1}}],[\"因此我们可以将代码模板修改为\",{\"1\":{\"435\":1}}],[\"因此redis内部所有的涉及rdb的操作都采用bgsave的方式\",{\"1\":{\"724\":1}}],[\"因此项目中通常需要修改redistemplate的序列化方式\",{\"1\":{\"720\":1}}],[\"因此说redis所以不保证事务原子性\",{\"1\":{\"717\":1}}],[\"因此扫描的总行数为10000\",{\"1\":{\"662\":1}}],[\"因此整个过程扫描了200行\",{\"1\":{\"661\":1}}],[\"因此整个执行过程\",{\"1\":{\"538\":1}}],[\"因此达到232\",{\"1\":{\"635\":1}}],[\"因此认为这个数据可见\",{\"1\":{\"634\":1}}],[\"因此在java中\",{\"1\":{\"1472\":1}}],[\"因此在join的时候\",{\"1\":{\"539\":1}}],[\"因此在检查函数式接口的定义的时候\",{\"1\":{\"1471\":1}}],[\"因此在并发情况下都不会导致服务崩溃\",{\"1\":{\"1450\":1}}],[\"因此在建表的时候需要考察是否可能达到这个上限\",{\"1\":{\"631\":1}}],[\"因此索引更紧凑\",{\"1\":{\"626\":1}}],[\"因此会进行批量重偏向\",{\"1\":{\"1362\":1}}],[\"因此会让服务端变慢\",{\"1\":{\"619\":1}}],[\"因此会优先选择全字段排序\",{\"1\":{\"557\":1}}],[\"因此根本不会进入终止逻辑阶段\",{\"1\":{\"618\":1}}],[\"因此主库a\",{\"1\":{\"605\":1}}],[\"因此delete\",{\"1\":{\"591\":1}}],[\"因此可能会出现这样一种情况\",{\"1\":{\"591\":1}}],[\"因此可能会增加语句的响应时间\",{\"1\":{\"588\":1}}],[\"因此可以正常执行\",{\"1\":{\"578\":1}}],[\"因此可以有多个线程同时对一张表增删改查\",{\"1\":{\"578\":1}}],[\"因此可以并存\",{\"1\":{\"549\":1}}],[\"因此可以直接提供查询结果\",{\"1\":{\"475\":1}}],[\"因此可以通过分治的方式来处理\",{\"1\":{\"438\":1}}],[\"因此等trx1返回时\",{\"1\":{\"588\":1}}],[\"因此session\",{\"1\":{\"585\":1}}],[\"因此tomcat设计了一系列抽象基类来封装这些稳定的部分\",{\"1\":{\"1565\":1}}],[\"因此tomcat设计了两个核心组件连接器\",{\"1\":{\"1561\":1}}],[\"因此t5时刻q3查出来的是id=0\",{\"1\":{\"583\":1}}],[\"因此t3时刻q2查出来的是id=0和id=5这两行\",{\"1\":{\"583\":1}}],[\"因此业务设计的时候一般不会把死锁当做一个严重错误\",{\"1\":{\"581\":1}}],[\"因此只能被阻塞\",{\"1\":{\"578\":1}}],[\"因此只是一个估算值\",{\"1\":{\"533\":1}}],[\"因此很多时候\",{\"1\":{\"570\":1}}],[\"因此很有可能费劲的把结果存起来\",{\"1\":{\"456\":1}}],[\"因此mysql对于被驱动表的关联字段没有索引的关联查询\",{\"1\":{\"662\":1}}],[\"因此mysql认为扫描行数是2\",{\"1\":{\"475\":1}}],[\"因此mdl锁之后的执行过程\",{\"1\":{\"562\":1}}],[\"因此所有分区共用同一个mdl锁\",{\"1\":{\"562\":1}}],[\"因此加锁范围就是图中深绿色的部分\",{\"1\":{\"561\":1}}],[\"因此选择不同行的概率不一样\",{\"1\":{\"559\":1}}],[\"因此这里不做过多介绍\",{\"1\":{\"724\":1}}],[\"因此这一步需要扫描y+1行\",{\"1\":{\"559\":1}}],[\"因此这是一个最大堆\",{\"1\":{\"558\":1}}],[\"因此这个策略会产生比较高的平均延时\",{\"1\":{\"1397\":1}}],[\"因此这个策略用的并不多\",{\"1\":{\"600\":1}}],[\"因此这个时候选择大表或者小表做驱动表\",{\"1\":{\"540\":1}}],[\"因此这个语句的执行流程如下\",{\"1\":{\"538\":1}}],[\"因此当使用磁盘临时表的时候\",{\"1\":{\"558\":1}}],[\"因此全程只使用了内存临时表\",{\"1\":{\"553\":1}}],[\"因此结果集里最后一行才是m=0\",{\"1\":{\"553\":1}}],[\"因此返回的结果集中的第一行是id=1\",{\"1\":{\"553\":1}}],[\"因此对表t1中的每一行\",{\"1\":{\"662\":1}}],[\"因此对表t2中的每一行\",{\"1\":{\"540\":1}}],[\"因此对应的number\",{\"1\":{\"558\":1}}],[\"因此对于count\",{\"1\":{\"533\":1}}],[\"因此对于写多读少的业务来说\",{\"1\":{\"481\":1}}],[\"因此总的扫描行数是1100\",{\"1\":{\"540\":1}}],[\"因此是把整个表t1放入了内存\",{\"1\":{\"540\":1}}],[\"因此应该让小表做驱动表\",{\"1\":{\"538\":1}}],[\"因此每次的搜索过程都只扫描一行\",{\"1\":{\"538\":1}}],[\"因此执行count\",{\"1\":{\"533\":1}}],[\"因此最终还是会选择索引t\",{\"1\":{\"503\":1}}],[\"因此最适合求接的问题是查找与给定值相等的记录\",{\"1\":{\"332\":1}}],[\"因此优化器决定放弃走树搜索功能\",{\"1\":{\"503\":1}}],[\"因此不论这个事务多大\",{\"1\":{\"587\":1}}],[\"因此不会优先选择\",{\"1\":{\"493\":1}}],[\"因此不能无线增大\",{\"1\":{\"480\":1}}],[\"因此需要排序的总数据量就变小了\",{\"1\":{\"492\":1}}],[\"因此需要遍历的树的深度为n\",{\"1\":{\"415\":1}}],[\"因此如果有满足条件的记录\",{\"1\":{\"485\":1}}],[\"因此将会返回空集合\",{\"1\":{\"484\":1}}],[\"因此出现这种情况的概率会很低\",{\"1\":{\"479\":1}}],[\"因此引擎扫描行数跟rows\",{\"1\":{\"459\":1}}],[\"因此\",{\"1\":{\"349\":1,\"354\":1,\"428\":1,\"464\":1,\"469\":1,\"470\":1,\"472\":1,\"475\":1,\"476\":1,\"477\":1,\"480\":1,\"481\":1,\"485\":1,\"493\":1,\"505\":1,\"533\":2,\"540\":1,\"541\":1,\"543\":1,\"557\":1,\"561\":2,\"570\":1,\"572\":1,\"575\":2,\"578\":3,\"581\":1,\"583\":1,\"584\":1,\"587\":1,\"588\":1,\"590\":1,\"591\":2,\"596\":1,\"597\":1,\"599\":2,\"602\":1,\"603\":1,\"604\":2,\"605\":1,\"606\":1,\"614\":1,\"615\":1,\"616\":1,\"619\":1,\"628\":1,\"629\":2,\"633\":1,\"634\":1,\"1356\":1,\"1422\":1,\"1427\":1,\"1490\":1,\"1565\":1}}],[\"整理算法\",{\"0\":{\"1600\":1}}],[\"整合ssm框架还是比较繁琐的\",{\"1\":{\"1860\":1}}],[\"整合mybatis底层源码解析\",{\"0\":{\"1530\":1}}],[\"整合一个组件并进行配置一定会有一个自动配置类xxxautoconfiguration\",{\"1\":{\"720\":1}}],[\"整型\",{\"1\":{\"1500\":1}}],[\"整数通常是最佳的数据类型\",{\"1\":{\"665\":1}}],[\"整条语句的执行速度就可以加快\",{\"1\":{\"545\":1}}],[\"整体流程大致如下\",{\"1\":{\"1443\":1}}],[\"整体空间利用率降低大约50\",{\"1\":{\"472\":1}}],[\"整体的示意图如下\",{\"1\":{\"344\":1,\"345\":1}}],[\"整个完整的解析过程如下\",{\"1\":{\"1529\":1}}],[\"整个语句并没有告诉底层stream要如何去做\",{\"1\":{\"1488\":1}}],[\"整个拷贝过程\",{\"1\":{\"1459\":1,\"1460\":1,\"1461\":1}}],[\"整个拷贝的过程\",{\"1\":{\"1457\":1}}],[\"整个读取的数据的过程\",{\"1\":{\"1457\":1}}],[\"整个进程会被阻塞\",{\"1\":{\"1440\":1}}],[\"整个striped64\",{\"1\":{\"1357\":1}}],[\"整个查询的执行成本\",{\"1\":{\"692\":1}}],[\"整个查询的执行成本预计为55\",{\"1\":{\"690\":1}}],[\"整个查询语句只有1个select关键字\",{\"1\":{\"690\":1,\"692\":1}}],[\"整个系统的响应非常慢\",{\"1\":{\"615\":1}}],[\"整个系统被锁死\",{\"1\":{\"613\":1}}],[\"整个系统就阻塞了\",{\"1\":{\"613\":1}}],[\"整个过程省掉了数据在内核缓冲区和用户缓冲区之间的cpu拷贝环节\",{\"1\":{\"1458\":1}}],[\"整个过程完全时自动的\",{\"1\":{\"758\":1}}],[\"整个过程都需要人工干预\",{\"1\":{\"758\":1}}],[\"整个过程对表t1和t2都做了一次全表扫描\",{\"1\":{\"662\":1}}],[\"整个过程会读取t2表的所有数据\",{\"1\":{\"661\":1}}],[\"整个过程的流程图如下\",{\"1\":{\"611\":1}}],[\"整个过程io成本\",{\"1\":{\"461\":1}}],[\"整个库到可以正常更新的状态\",{\"1\":{\"575\":1}}],[\"整个事务存在期间都用这个视图\",{\"1\":{\"570\":1}}],[\"整个排序过程中\",{\"1\":{\"558\":1}}],[\"整个算式的结果会更小\",{\"1\":{\"540\":1}}],[\"整个执行流程\",{\"1\":{\"538\":1}}],[\"整个执行流程如下\",{\"1\":{\"492\":1}}],[\"整个数组即有序\",{\"1\":{\"323\":1}}],[\"把题目的解题思路和解法都写一下\",{\"1\":{\"1850\":1}}],[\"把autowiremode修改为bytype\",{\"1\":{\"1530\":1}}],[\"把beanclass修改为mapperfactorybean\",{\"1\":{\"1530\":1}}],[\"把bnl算法转成bka算法\",{\"1\":{\"543\":1}}],[\"把求出流中元素的总和改为求出流中元素的最小值\",{\"1\":{\"1487\":1}}],[\"把手的意思\",{\"1\":{\"1438\":1}}],[\"把每个bucket都移动到新的buckets中\",{\"1\":{\"1427\":1}}],[\"把每一行的id值都取出来\",{\"1\":{\"536\":1}}],[\"把数据房子啊对应下标元素的链表上\",{\"1\":{\"1423\":1}}],[\"把队列塞爆了\",{\"1\":{\"1413\":2}}],[\"把前面异步任务的结果\",{\"1\":{\"1395\":1}}],[\"把持读锁\",{\"1\":{\"1375\":1}}],[\"把工作内存中的一个变量的值传送到主内存中\",{\"1\":{\"1350\":1}}],[\"把工作内存中一个变量值传递给执行引擎\",{\"1\":{\"1350\":1}}],[\"把一个变量值从主内存传输到线程的工作内存中\",{\"1\":{\"1350\":1}}],[\"把一个变量标识为一条线程独占状态\",{\"1\":{\"1350\":1}}],[\"把一个处于锁定状态的变量释放出来\",{\"1\":{\"1350\":1}}],[\"把符合搜索条件的记录加入到结果集\",{\"1\":{\"685\":1}}],[\"把被驱动表的每一行取出来跟join\",{\"1\":{\"662\":1}}],[\"把被错删的数据插入回去就可以恢复了\",{\"1\":{\"591\":1}}],[\"把驱动表的数据读入到join\",{\"1\":{\"662\":1}}],[\"把需要的字段放到sort\",{\"1\":{\"657\":1}}],[\"把需要的字段都放到sort\",{\"1\":{\"493\":1}}],[\"把排序字段position和主键id这两个字段放到sort\",{\"1\":{\"657\":1}}],[\"把当前事务的trx变量的指针地址转成整数\",{\"1\":{\"634\":1}}],[\"把当前结点的右子结点设置为当前结点\",{\"1\":{\"344\":1,\"345\":1}}],[\"把当前结点的左子结点设置为当前结点\",{\"1\":{\"344\":1}}],[\"把自增id的锁范围扩大\",{\"1\":{\"628\":1}}],[\"把之前删掉的binlog放回备库的操作如下\",{\"1\":{\"622\":1}}],[\"把之前的统计信息清空\",{\"1\":{\"616\":1}}],[\"把它改成delete\",{\"1\":{\"621\":1}}],[\"把12号线程状态设置为kill\",{\"1\":{\"618\":1}}],[\"把sql\",{\"1\":{\"621\":1}}],[\"把session\",{\"1\":{\"618\":1}}],[\"把sort\",{\"1\":{\"558\":1}}],[\"把中转日志\",{\"1\":{\"604\":1}}],[\"把相同热度的表均匀分到这些不同的db中\",{\"1\":{\"600\":1}}],[\"把业务请求切换到备库b\",{\"1\":{\"595\":1}}],[\"把备库b改成可读写状态\",{\"1\":{\"595\":1}}],[\"把主库a改成只读状态\",{\"1\":{\"595\":1}}],[\"把redo\",{\"1\":{\"588\":1}}],[\"把内存中的临时表复制到磁盘\",{\"1\":{\"568\":1}}],[\"把内存临时表的大小限制为最大1024字节\",{\"1\":{\"553\":1}}],[\"把max\",{\"1\":{\"558\":1}}],[\"把这些undo日志串联起来形成一个历史记录版本链\",{\"1\":{\"679\":1}}],[\"把这些日志\",{\"1\":{\"622\":1}}],[\"把这两个命令的结果用于构建一个本地的哈希表\",{\"1\":{\"619\":1}}],[\"把这个事务的gtid返回给客户端\",{\"1\":{\"611\":1}}],[\"把这个gtid加到实例x的gtid集合中\",{\"1\":{\"605\":1}}],[\"把这个gtid加入本实例的gtid集合\",{\"1\":{\"605\":1}}],[\"把这个\",{\"1\":{\"558\":1}}],[\"把这个值加上1\",{\"1\":{\"463\":1}}],[\"把这2000行数据\",{\"1\":{\"545\":1}}],[\"把表t1的所有字段取出来\",{\"1\":{\"544\":1}}],[\"把t2中的每一行取出来\",{\"1\":{\"540\":2}}],[\"把trade\",{\"1\":{\"505\":1}}],[\"把返回的结果和r构成结果集的一行\",{\"1\":{\"538\":1}}],[\"把所有需要的列都放到索引中\",{\"1\":{\"527\":1}}],[\"把结果放在临时表中\",{\"1\":{\"467\":1}}],[\"把c从0改成1\",{\"1\":{\"464\":1}}],[\"把字符串\",{\"1\":{\"457\":1}}],[\"把元素x和元素y所在的集合合并\",{\"1\":{\"356\":1}}],[\"把根节点设置为当前结点\",{\"1\":{\"344\":1}}],[\"把左子树的结点往右子树挪了\",{\"1\":{\"343\":1}}],[\"把右子树的结点往左子树挪了\",{\"1\":{\"343\":1}}],[\"其类型转换的功能实际上委托给了内部的propertyeditor和conversionservice对象\",{\"1\":{\"1517\":1}}],[\"其余接口的主要功能如下\",{\"1\":{\"1513\":1}}],[\"其余的异常就会作为被压制的异常\",{\"1\":{\"1496\":1}}],[\"其地位与收集器相同\",{\"1\":{\"1498\":1}}],[\"其目的\",{\"1\":{\"1484\":1}}],[\"其过程不需要cpu的参与\",{\"1\":{\"1455\":1}}],[\"其效率也会线程下降\",{\"1\":{\"1447\":1}}],[\"其效率的提升主要得益于两个方面\",{\"1\":{\"1391\":1}}],[\"其良好跨平台支持也是它的一个优点\",{\"1\":{\"1446\":1}}],[\"其初始化过程也就是对node数组的初始化过程\",{\"1\":{\"1431\":1}}],[\"其初始值为创建该对象时class中的epoch的值\",{\"1\":{\"1362\":1}}],[\"其在线程二rehash后\",{\"1\":{\"1428\":1}}],[\"其内部是用数组存储元素的\",{\"1\":{\"1379\":1}}],[\"其共享资源为临界资源\",{\"1\":{\"1359\":1}}],[\"其缺点是窥探是不可扩展的\",{\"1\":{\"1351\":1}}],[\"其对每个指令都写了一段对应的汇编代码\",{\"1\":{\"1350\":1}}],[\"其成本都算是0\",{\"1\":{\"682\":1}}],[\"其他组件按照一定的格式要求配置在这个顶层容器中\",{\"1\":{\"1561\":1}}],[\"其他则交由spring管理\",{\"1\":{\"1536\":1}}],[\"其他竞争失败的线程会讲数值累加到base上\",{\"1\":{\"1357\":1}}],[\"其他要使用该资源的线程必须等待\",{\"1\":{\"1354\":1}}],[\"其他副本必须反映该更改\",{\"1\":{\"1351\":1}}],[\"其他线程无法对segment的hash表做操作\",{\"1\":{\"1430\":1}}],[\"其他线程同样可以完成操作a\",{\"1\":{\"1408\":1}}],[\"其他线程能够看到修改的值\",{\"1\":{\"1348\":1}}],[\"其他线程等待\",{\"1\":{\"770\":1}}],[\"其他的节点就可以手动连接到最新的主节点\",{\"1\":{\"748\":1}}],[\"其他的读请求则由从库分担\",{\"1\":{\"603\":1}}],[\"其他命令正常执行\",{\"1\":{\"717\":1}}],[\"其他命令可以正常执行\",{\"1\":{\"717\":1}}],[\"其他命令并没有被执行\",{\"1\":{\"717\":1}}],[\"其他级别都用到索引了\",{\"1\":{\"467\":1}}],[\"其它线程并不能操作这个segment对象\",{\"1\":{\"1430\":1}}],[\"其它行跟这个执行序列无关\",{\"1\":{\"584\":1}}],[\"其它方式\",{\"0\":{\"489\":1}}],[\"其次要\",{\"1\":{\"1386\":1}}],[\"其次\",{\"1\":{\"584\":1}}],[\"其原因是\",{\"1\":{\"471\":1}}],[\"其实大部分语言的基础知识都是大同小异\",{\"1\":{\"1847\":1}}],[\"其实大多数情况下\",{\"1\":{\"617\":1}}],[\"其实现的原理就是不同的类加载器实例加载的类被认为是不同的类\",{\"1\":{\"1571\":1}}],[\"其实还可以这样\",{\"1\":{\"1494\":1}}],[\"其实对于分组的操作还可以进行二级分组\",{\"1\":{\"1493\":1}}],[\"其实我们也可以这样调用\",{\"1\":{\"1491\":1}}],[\"其实我们也可以直接调用list的sort方法\",{\"1\":{\"1491\":1}}],[\"其实我们还可以使用方法引用的方式\",{\"1\":{\"1480\":1}}],[\"其实中间操作都会返回一个新的stream对象\",{\"1\":{\"1487\":1}}],[\"其实最常见的\",{\"1\":{\"1484\":1}}],[\"其实最简单的办法是让共享变量只有读操作\",{\"1\":{\"1403\":1}}],[\"其实在java\",{\"1\":{\"1478\":1}}],[\"其实这里最关键的就是consumer这个参数\",{\"1\":{\"1472\":1}}],[\"其实myinterface\",{\"1\":{\"1472\":1}}],[\"其实foreach\",{\"1\":{\"1471\":1}}],[\"其实本质上看起来和我们传统的使用迭代器的方式并没有区别\",{\"1\":{\"1470\":1}}],[\"其实际过程是先比较eax的值\",{\"1\":{\"1356\":1}}],[\"其实就是proxyfactory\",{\"1\":{\"1531\":1}}],[\"其实就是向beanfatory中添加各种各样的beandifinition\",{\"1\":{\"1529\":1}}],[\"其实就是myinterface的一个具体实现\",{\"1\":{\"1472\":1}}],[\"其实就是对\",{\"1\":{\"1460\":1}}],[\"其实就是一个用户独享的虚拟内存\",{\"1\":{\"1456\":1}}],[\"其实就是搭建的集群\",{\"1\":{\"770\":1}}],[\"其实就是innodb\",{\"1\":{\"629\":1}}],[\"其实除了这两个成本参数\",{\"1\":{\"694\":1}}],[\"其实相当于3\",{\"1\":{\"693\":1}}],[\"其实相当于2\",{\"1\":{\"693\":1}}],[\"其实直接使用我们前面说过的索引统计数据就可以了\",{\"1\":{\"692\":1}}],[\"其实也就是b+树索引\",{\"1\":{\"690\":1}}],[\"其实只要确保trx1已经执行完成就可以执行select语句了\",{\"1\":{\"609\":1}}],[\"其实已经过了一段时间\",{\"1\":{\"608\":1}}],[\"其实不用等到commit阶段\",{\"1\":{\"602\":1}}],[\"其实seconds\",{\"1\":{\"594\":1}}],[\"其实区别只是多了一条线\",{\"1\":{\"592\":1}}],[\"其实它就是前两种格式的混合\",{\"1\":{\"591\":1}}],[\"其实并不是连接慢\",{\"1\":{\"619\":1}}],[\"其实并不是\",{\"1\":{\"558\":1}}],[\"其实是没有意义的\",{\"1\":{\"1471\":1}}],[\"其实是没问题的\",{\"1\":{\"540\":1}}],[\"其实是保存在了内存里\",{\"1\":{\"627\":1}}],[\"其实是让客户端变得更快\",{\"1\":{\"619\":1}}],[\"其实是锁在分区p\",{\"1\":{\"561\":1}}],[\"其实是我们根据数据特征诱导了一下优化器\",{\"1\":{\"485\":1}}],[\"其实\",{\"1\":{\"464\":1,\"471\":1,\"588\":1,\"605\":2,\"618\":2,\"625\":1,\"629\":1}}],[\"其架构模式是插件式的\",{\"1\":{\"454\":1}}],[\"其通过堆实现\",{\"1\":{\"353\":1}}],[\"其左子结点变为旋转结点的父结点\",{\"1\":{\"343\":1}}],[\"其右子结点变为旋转结点的父结点\",{\"1\":{\"343\":1}}],[\"其中最外层的是server\",{\"1\":{\"1561\":1}}],[\"其中类加载过程有加载\",{\"1\":{\"1540\":1}}],[\"其中核心方法就是beanfactory的resolvedependency方法\",{\"1\":{\"1525\":1}}],[\"其中defaultlistablebeanfactory是最重要的实现之一\",{\"1\":{\"1513\":1}}],[\"其中dp\",{\"1\":{\"427\":1}}],[\"其中方法名叫test\",{\"1\":{\"1476\":1}}],[\"其中mappedbytebuffer的作用\",{\"1\":{\"1464\":1}}],[\"其中的a表示的是中间结果的容器类型\",{\"1\":{\"1495\":1}}],[\"其中的map\",{\"1\":{\"1486\":1}}],[\"其中的biconsumer是接收两个参数\",{\"1\":{\"1485\":1}}],[\"其中的\",{\"1\":{\"1484\":1}}],[\"其中的任意一个进入读就绪状态\",{\"1\":{\"1442\":1}}],[\"其中的哈希桶数组table的size等于2\",{\"1\":{\"1427\":1}}],[\"其中hash1是key1对应的哈希与高位运算的结果\",{\"1\":{\"1427\":1}}],[\"其中会运用到红黑树的插入\",{\"1\":{\"1423\":1}}],[\"其中node具体如下\",{\"1\":{\"1423\":1}}],[\"其中nn可以被替换为01\",{\"1\":{\"695\":1}}],[\"其中单例集合有list\",{\"1\":{\"1415\":1}}],[\"其中第一个阶段主要是线程t1向线程t2发送终止指令\",{\"1\":{\"1401\":1}}],[\"其中任意线程成功获取了写锁并更新了数据\",{\"1\":{\"1375\":1}}],[\"其中包含了若干个sentinel节点和redis数据节点\",{\"1\":{\"758\":1}}],[\"其中包含s个单元素集合\",{\"1\":{\"356\":1}}],[\"其中每一个有状态的都会标识一个段的结尾\",{\"1\":{\"1498\":1}}],[\"其中每一个结点都具有两个孩子\",{\"1\":{\"347\":1}}],[\"其中每一项成本的含义\",{\"1\":{\"694\":1}}],[\"其中39是待检测记录的条数\",{\"1\":{\"686\":1}}],[\"其中39是预计的二级索引记录数\",{\"1\":{\"686\":1}}],[\"其中39是需要读取的二级索引记录条数\",{\"1\":{\"686\":1}}],[\"其中比较重要的有innodb\",{\"1\":{\"675\":1}}],[\"其中iscandidatecomponent方法表示当前类是否是一个bean\",{\"1\":{\"1524\":1}}],[\"其中id是自增主键字段\",{\"1\":{\"626\":1}}],[\"其中io\",{\"1\":{\"590\":1}}],[\"其中步骤5到主库执行查询语句\",{\"1\":{\"610\":1}}],[\"其中可以直接看出来好处的就是\",{\"1\":{\"591\":1}}],[\"其中一种方式对将哈希值对数组长度取模运算\",{\"1\":{\"1425\":1}}],[\"其中一个要等另一个执行完才能开始执行\",{\"1\":{\"578\":1}}],[\"其中一行的值为1\",{\"1\":{\"570\":1}}],[\"其中k=λn\",{\"1\":{\"540\":1}}],[\"其中交易记录表tradelog包含交易流水号\",{\"1\":{\"503\":1}}],[\"其中前6位是地址码\",{\"1\":{\"489\":1}}],[\"其中write\",{\"1\":{\"461\":1}}],[\"其中command列显示为\",{\"1\":{\"455\":1}}],[\"其中c\",{\"1\":{\"426\":1}}],[\"其中\",{\"1\":{\"328\":1,\"518\":1,\"542\":1,\"548\":1,\"553\":1,\"557\":1,\"562\":1,\"583\":1,\"594\":1,\"604\":1,\"605\":3,\"609\":1,\"615\":1,\"616\":1,\"628\":1,\"695\":1,\"736\":1,\"1423\":1,\"1428\":1,\"1460\":1,\"1847\":1,\"1852\":2,\"1856\":1}}],[\"旋转结点\",{\"1\":{\"343\":2}}],[\"以实现对各种资源库的控制\",{\"1\":{\"1571\":1}}],[\"以实现让java程序在各种平台下都能达到一致的并发效果\",{\"1\":{\"1350\":1}}],[\"以字节为单位\",{\"1\":{\"1541\":1}}],[\"以之前我们使用foreach\",{\"1\":{\"1471\":1}}],[\"以往遍历集合通常的做法是\",{\"1\":{\"1470\":1}}],[\"以linux系统为例\",{\"1\":{\"1462\":1}}],[\"以客户端从服务器下载文件为例\",{\"1\":{\"1457\":1}}],[\"以read为例\",{\"1\":{\"1438\":1}}],[\"以保证数据的分散性\",{\"1\":{\"1430\":1}}],[\"以确保不占用太多的cpu资源\",{\"1\":{\"1397\":1}}],[\"以class为单位\",{\"1\":{\"1362\":1}}],[\"以达到内存屏障的效果\",{\"1\":{\"1356\":1}}],[\"以便aop操作\",{\"1\":{\"1521\":1}}],[\"以便能装入更多的元素\",{\"1\":{\"1427\":1}}],[\"以便随后的write的操作\",{\"1\":{\"1350\":1}}],[\"以便随后的load动作使用\",{\"1\":{\"1350\":1}}],[\"以便快速确定是否存在这个值\",{\"1\":{\"764\":1}}],[\"以便允许别的事务再申请\",{\"1\":{\"629\":1}}],[\"以满足更高的性能\",{\"1\":{\"738\":1}}],[\"以日志的形式来记录每个写的操作\",{\"1\":{\"728\":1}}],[\"以mysql为例\",{\"1\":{\"704\":1}}],[\"以order\",{\"1\":{\"690\":1}}],[\"以至于当客户端进行资源文件下载的时候\",{\"1\":{\"1457\":1}}],[\"以至于页b和页c对应的目录项记录都不在一个父页面中怎么办\",{\"1\":{\"686\":1}}],[\"以至于我们花费了不小的篇幅来介绍\",{\"1\":{\"518\":1}}],[\"以此类推\",{\"1\":{\"629\":1}}],[\"以此来估算元中元素的个数\",{\"1\":{\"1497\":1}}],[\"以此来对照学习\",{\"1\":{\"1479\":1}}],[\"以此来模拟大查询\",{\"1\":{\"613\":1}}],[\"以此来跳过可能涉及的所有事务\",{\"1\":{\"604\":1}}],[\"以此来减少binlog的写盘次数\",{\"1\":{\"602\":1}}],[\"以auto\",{\"1\":{\"628\":1}}],[\"以免之后真的出现了主从数据不一致\",{\"1\":{\"604\":1}}],[\"以影院的账户为例\",{\"1\":{\"581\":1}}],[\"以\",{\"1\":{\"549\":1}}],[\"以下是关于streamsupport这个类的说明\",{\"1\":{\"1498\":1}}],[\"以下参数将会在调用脚本时传给脚本\",{\"1\":{\"761\":1}}],[\"以下语句序列可以说明这一点\",{\"1\":{\"628\":1}}],[\"以下面的查询为例\",{\"1\":{\"657\":1}}],[\"以下面的查询语句为例\",{\"1\":{\"548\":1}}],[\"以下面的表t为例\",{\"1\":{\"473\":1}}],[\"以下列操作序列为例\",{\"1\":{\"547\":1}}],[\"以上是关于spliterator这个类本身的说明\",{\"1\":{\"1497\":1}}],[\"以上是jdk7的情况\",{\"1\":{\"1428\":1}}],[\"以上都是通过collectorimpl来实现的collector\",{\"1\":{\"1495\":1}}],[\"以上都是子串长度2的前提之上的\",{\"1\":{\"428\":1}}],[\"以上就是\",{\"1\":{\"1871\":1}}],[\"以上就是关于stream这个类的内容\",{\"1\":{\"1496\":1}}],[\"以上就是关于如何创建流的对象的例子\",{\"1\":{\"1484\":1}}],[\"以上就是几个最基础也是最重要的几个函数式接口\",{\"1\":{\"1477\":1}}],[\"以上图为例\",{\"1\":{\"598\":1}}],[\"以上这条查询语句的执行流程如下\",{\"1\":{\"548\":1}}],[\"以上结论告诉我们\",{\"1\":{\"540\":1}}],[\"以上面的图为例\",{\"1\":{\"472\":1}}],[\"以及jvm的内部原理等\",{\"1\":{\"1870\":1}}],[\"以及具体处理request请求\",{\"1\":{\"1561\":1}}],[\"以及一些附加的信息关于终止的有状态的操作\",{\"1\":{\"1500\":1}}],[\"以及传递给finisher的参数\",{\"1\":{\"1492\":1}}],[\"以及传递给combiner方法的两个参数\",{\"1\":{\"1492\":1}}],[\"以及我们之前使用的诸多的api在底层到底是如何实现的\",{\"1\":{\"1490\":1}}],[\"以及等待指定时长的获取\",{\"1\":{\"1372\":1}}],[\"以及在必须时如何同步的访问共享变量\",{\"1\":{\"1350\":1}}],[\"以及订阅这个频道的三个客户端\",{\"1\":{\"733\":1}}],[\"以及未保存到快照中的那些数据\",{\"1\":{\"729\":1}}],[\"以及成员m2\",{\"1\":{\"711\":1}}],[\"以及行记录所在的间隙里插入或修改任何数据\",{\"1\":{\"673\":1}}],[\"以及要从哪个位置开始请求binlog\",{\"1\":{\"590\":1}}],[\"以及每个值得出现次数\",{\"1\":{\"555\":1}}],[\"以及每种方法优缺点\",{\"1\":{\"533\":1}}],[\"以及增删改查语句访问的是临时表\",{\"1\":{\"547\":1}}],[\"以及拷贝字段值的操作\",{\"1\":{\"536\":1}}],[\"以及适配磁盘的访问模式\",{\"1\":{\"471\":1}}],[\"以及所有的内置函数\",{\"1\":{\"454\":1}}],[\"以innodb的一个整数字段为例\",{\"1\":{\"471\":1}}],[\"以求解\",{\"1\":{\"399\":1}}],[\"以某个结点作为支点\",{\"1\":{\"343\":2}}],[\"以加快查找的速度\",{\"1\":{\"332\":1}}],[\"每隔一秒扫描所有channel\",{\"1\":{\"1451\":1}}],[\"每台redis服务器都是主节点\",{\"1\":{\"743\":1,\"747\":1}}],[\"每秒执行一次\",{\"1\":{\"729\":1}}],[\"每秒一次后台轮询刷盘\",{\"1\":{\"588\":1}}],[\"每种自增id有各自的应用场景\",{\"1\":{\"636\":1}}],[\"每新建一个连接\",{\"1\":{\"635\":1}}],[\"每插入一行数据\",{\"1\":{\"632\":1}}],[\"每10毫秒判断一下是否可以进入innodb执行\",{\"1\":{\"618\":1}}],[\"每当有一种新的操作\",{\"1\":{\"1475\":1}}],[\"每当一个连接接入时我们都需要new一个线程进行处理\",{\"1\":{\"1450\":1}}],[\"每当一个事务被锁的时候\",{\"1\":{\"581\":1}}],[\"每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作\",{\"1\":{\"1350\":1}}],[\"每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作\",{\"1\":{\"1350\":1}}],[\"每当第一次访问一个分区表的时候\",{\"1\":{\"562\":1}}],[\"每条记录在更新的时候都会同时记录一条回滚操作\",{\"1\":{\"571\":1}}],[\"每年年底时再把下一年度的12个新分区创建上即可\",{\"1\":{\"563\":1}}],[\"每被删除一行redis计数就减1\",{\"1\":{\"534\":1}}],[\"每一种应用层协议都有自己的抽象基类\",{\"1\":{\"1565\":1}}],[\"每一种隔离级别都有自己的使用场景\",{\"1\":{\"570\":1}}],[\"每一块元素都有自己的分割迭代器\",{\"1\":{\"1497\":1}}],[\"每一次该class的对象发生偏向锁撤销操作时\",{\"1\":{\"1362\":1}}],[\"每一次修改都会同步\",{\"1\":{\"730\":1}}],[\"每一位所在的位置为偏移\",{\"1\":{\"715\":1}}],[\"每一条记录对应着一个索引的一个统计项的统计数据\",{\"1\":{\"695\":1}}],[\"每一条记录对应着一个表的统计数据\",{\"1\":{\"695\":1}}],[\"每一行数据都记录了更新它的trx\",{\"1\":{\"634\":1}}],[\"每一行的a=1001\",{\"1\":{\"541\":1}}],[\"每一行记录都要判断自己是否对这个会话可见\",{\"1\":{\"533\":1}}],[\"每一份单独排序后存在这些临时文件中\",{\"1\":{\"491\":1}}],[\"每一个叶子节点都会发送个这个类的同一个terminalsink实例\",{\"1\":{\"1500\":1}}],[\"每一个叶子结点都会保存一个指向叶子结点的指针\",{\"1\":{\"350\":1}}],[\"每一个单个的abstractpipeline通常称为stages\",{\"1\":{\"1498\":1}}],[\"每一个spliterator仅仅是对一个单块的计算是有用的\",{\"1\":{\"1497\":1}}],[\"每一个部分的操作都是独立的\",{\"1\":{\"1492\":1}}],[\"每一个crud操作最终都会解析为一个\",{\"1\":{\"806\":1}}],[\"每一个虚线箭头表示回表一次\",{\"1\":{\"477\":1}}],[\"每一个索引在innodb中对应一颗b+树\",{\"1\":{\"472\":1}}],[\"每一个元素在该树只出现一次\",{\"1\":{\"350\":1}}],[\"每一个结点的左子树和右子树的高度差至多等于1\",{\"1\":{\"341\":1}}],[\"每次依赖注入获取bean都应该是一个新的bean\",{\"1\":{\"1525\":1}}],[\"每次将流中的元素添加到的arraylist时都会新newarraylist\",{\"1\":{\"1485\":1}}],[\"每次被调用的结果可能是相同的\",{\"1\":{\"1477\":1}}],[\"每次修改都需要复制一个新的对象出来\",{\"1\":{\"1404\":1}}],[\"每次修改都会sync\",{\"1\":{\"729\":1}}],[\"每次操作都会上锁\",{\"1\":{\"1375\":1}}],[\"每次操作锁住一行数据\",{\"1\":{\"672\":1}}],[\"每次操作锁住整张表\",{\"1\":{\"671\":1}}],[\"每次发生批量重偏向时\",{\"1\":{\"1362\":1}}],[\"每次提交执行exec后都会自动释放锁\",{\"1\":{\"718\":1}}],[\"每次提交事务的时候分配给这个事务\",{\"1\":{\"605\":1}}],[\"每次遍历部分\",{\"1\":{\"709\":1}}],[\"每次遍历后\",{\"1\":{\"415\":1}}],[\"每次等待所花平均时间\",{\"1\":{\"675\":1}}],[\"每次执行语句的时候将它赋值给query\",{\"1\":{\"633\":1}}],[\"每次申请一个新的trx\",{\"1\":{\"634\":1}}],[\"每次申请到的自增id个数都是上一次的两倍\",{\"1\":{\"629\":1}}],[\"每次申请id之前\",{\"1\":{\"628\":1}}],[\"每次重启后\",{\"1\":{\"627\":1}}],[\"每次用客户端连接都会卡在下面这个界面上\",{\"1\":{\"619\":1}}],[\"每次从库执行查询请求前\",{\"1\":{\"609\":1}}],[\"每次从索引a上拿到一个值\",{\"1\":{\"484\":1}}],[\"每次碰到这些错误就停下来\",{\"1\":{\"604\":1}}],[\"每次写入长度为length的redo\",{\"1\":{\"588\":1}}],[\"每次访问分区都由server层控制\",{\"1\":{\"562\":1}}],[\"每次session内操作表的时候\",{\"1\":{\"549\":1}}],[\"每次都是匹配一个值\",{\"1\":{\"542\":1}}],[\"每次只需要将我们的所定义好的行为\",{\"1\":{\"1475\":1}}],[\"每次只能根据一个主键id查到一行数据\",{\"1\":{\"541\":1}}],[\"每次只返回一小部分查询结果\",{\"1\":{\"530\":1}}],[\"每次到t2做一次匹配\",{\"1\":{\"539\":1}}],[\"每次搜索一棵树近似复杂度是以2为底的m的对数\",{\"1\":{\"538\":1}}],[\"每次在被驱动表查一行数据\",{\"1\":{\"538\":1}}],[\"每次看到select\",{\"1\":{\"522\":1}}],[\"每次查询的时候\",{\"1\":{\"489\":1}}],[\"每次插入一条新记录\",{\"1\":{\"472\":1}}],[\"每张表有多少行被优化器查询\",{\"1\":{\"466\":1}}],[\"每走一次就将当前节点保存到栈中\",{\"1\":{\"395\":1}}],[\"每个executor都是一个线程池\",{\"1\":{\"1564\":1}}],[\"每个event都有crc32的值\",{\"1\":{\"591\":1}}],[\"每个service组件都包含了若干接收客户端消息的connector组件和处理请求的engine组件\",{\"1\":{\"1564\":1}}],[\"每个sentinel节点会对数据节点和其余sentinel节点进行监控\",{\"1\":{\"758\":1}}],[\"每个段都会被单独的执行\",{\"1\":{\"1498\":1}}],[\"每个普通的用户进程之间的用户空间是完全隔离的\",{\"1\":{\"1456\":1}}],[\"每个生产者或消费者线程\",{\"1\":{\"1396\":1}}],[\"每个处于偏向锁状态对象的mark\",{\"1\":{\"1362\":1}}],[\"每个处理器都有一个单独的缓存内存\",{\"1\":{\"1351\":1}}],[\"每个context容器负责创建和维护一个webappclassloader加载器实例\",{\"1\":{\"1571\":1}}],[\"每个class对象会有一个对应的epoch字段\",{\"1\":{\"1362\":1}}],[\"每个cell对象存有一个value值\",{\"1\":{\"1357\":1}}],[\"每个请求都创建一个线程\",{\"1\":{\"1410\":1}}],[\"每个请求都必须广播到系统中的所有节点\",{\"1\":{\"1351\":1}}],[\"每个请求都有机会获得io资源\",{\"1\":{\"615\":1}}],[\"每个配置文件对应修改以下信息\",{\"1\":{\"746\":1}}],[\"每个客户端套接字socket都有对应的读写文件描述符\",{\"1\":{\"740\":1}}],[\"每个\",{\"1\":{\"736\":1}}],[\"每个集合可存储40多亿个成员\",{\"1\":{\"709\":1}}],[\"每个列表超过40亿个元素\",{\"1\":{\"708\":1}}],[\"每个参数大约对应1\",{\"1\":{\"690\":1}}],[\"每个页可以放1170\",{\"1\":{\"640\":1}}],[\"每个非叶子结点可以放16kb\",{\"1\":{\"640\":1}}],[\"每个自增id都是定义了初始值\",{\"1\":{\"630\":1}}],[\"每个mysql实例都维护了一个gtid集合\",{\"1\":{\"605\":1}}],[\"每个事务trx变量的指针地址肯定不同\",{\"1\":{\"634\":1}}],[\"每个事务都会跟一个gtid一一对应\",{\"1\":{\"605\":1}}],[\"每个事务在分发的时候\",{\"1\":{\"598\":1}}],[\"每个事务的binlog里面都有一个时间字段\",{\"1\":{\"594\":1}}],[\"每个worker继续执行\",{\"1\":{\"598\":1}}],[\"每个worker线程对应一个哈希表\",{\"1\":{\"598\":1}}],[\"每个库在收到从自己的主库发过来的日志后\",{\"1\":{\"592\":1}}],[\"每个表都维护了一个变量\",{\"1\":{\"696\":1}}],[\"每个表都有一个对应的table\",{\"1\":{\"591\":1}}],[\"每个表都对应一个table\",{\"1\":{\"549\":1}}],[\"每个1秒\",{\"1\":{\"588\":1}}],[\"每个线程的栈大小\",{\"1\":{\"1541\":1}}],[\"每个线程只需要创建一个工具类的实例\",{\"1\":{\"1405\":1}}],[\"每个线程维护一个队列workqueue\",{\"1\":{\"1387\":1}}],[\"每个线程都想去利用cpu资源来执行自己的任务\",{\"1\":{\"1387\":1}}],[\"每个线程都维护了自己的临时表链表\",{\"1\":{\"549\":1}}],[\"每个线程有自己binlog\",{\"1\":{\"587\":1}}],[\"每个线程一个\",{\"1\":{\"587\":1}}],[\"每个next\",{\"1\":{\"585\":1}}],[\"每个新来的被堵住的线程\",{\"1\":{\"581\":1}}],[\"每个分区对应一个\",{\"1\":{\"561\":1}}],[\"每个查询功能完全一样\",{\"1\":{\"530\":1}}],[\"每个子任务都会消耗一定的时间\",{\"1\":{\"518\":1}}],[\"每个数据页的大小默认是16kb\",{\"1\":{\"479\":1}}],[\"每个数字出现的次数\",{\"1\":{\"381\":1}}],[\"每个人都有一个唯一的身份证号\",{\"1\":{\"478\":1}}],[\"每个节点的左儿子小于父节点\",{\"1\":{\"471\":1}}],[\"每个节点的值都小于或等于其子节点的值\",{\"1\":{\"321\":1}}],[\"每个节点的值都大于或等于其子节点的值\",{\"1\":{\"321\":1}}],[\"每个文件的大小是1gb\",{\"1\":{\"461\":1}}],[\"每个格子可能取三个值\",{\"1\":{\"435\":1}}],[\"每个房子的金额分别是h0​\",{\"1\":{\"431\":1}}],[\"每个红色结点的两个子节点一定都是黑色\",{\"1\":{\"343\":1}}],[\"每个叶子结点\",{\"1\":{\"343\":1}}],[\"每个结点的值都大于或等于其左右孩子结点的值\",{\"1\":{\"351\":1}}],[\"每个结点的所有子节点路径代表的字符都不相同\",{\"1\":{\"301\":1}}],[\"每个结点要么是黑色\",{\"1\":{\"343\":1}}],[\"右侧\",{\"1\":{\"708\":1}}],[\"右边的部分\",{\"1\":{\"1472\":1}}],[\"右边向列表中push值\",{\"1\":{\"708\":1}}],[\"右边\",{\"1\":{\"708\":1}}],[\"右连接将索引创建在左表上更合适\",{\"1\":{\"499\":1}}],[\"右表\",{\"1\":{\"499\":1}}],[\"右四个相邻结点\",{\"1\":{\"435\":2}}],[\"右旋只影响旋转结点和其左子树的结构\",{\"1\":{\"343\":1}}],[\"右旋的示意图\",{\"1\":{\"343\":1}}],[\"右旋\",{\"1\":{\"343\":1}}],[\"右旋和变色\",{\"1\":{\"343\":1}}],[\"右子结点保持不变\",{\"1\":{\"343\":1}}],[\"右子结点的左子结点变为旋转结点的右子结点\",{\"1\":{\"343\":1}}],[\"右子树中\",{\"1\":{\"398\":1}}],[\"右子树的值不小于root的值\",{\"1\":{\"397\":1}}],[\"右子树所有结点的值都要大于根节点的值\",{\"1\":{\"397\":1}}],[\"右子树包含大于最大元素的元素\",{\"1\":{\"348\":1}}],[\"右子树包含大于较大元素的元素\",{\"1\":{\"347\":1}}],[\"右子树包含的元素大于该元素\",{\"1\":{\"347\":1}}],[\"右子树也分别为二叉查找树\",{\"1\":{\"340\":1}}],[\"右子树上所有结点的值均大于它的根结点的值\",{\"1\":{\"340\":1}}],[\"右\",{\"1\":{\"339\":3,\"398\":1,\"708\":1}}],[\"右移\",{\"1\":{\"313\":1}}],[\"左侧\",{\"1\":{\"708\":1}}],[\"左边\",{\"1\":{\"708\":2}}],[\"左边界的上限设置可以宽松一些\",{\"1\":{\"428\":1}}],[\"左右\",{\"1\":{\"616\":1}}],[\"左右子树的高度差1\",{\"1\":{\"408\":1}}],[\"左连接需要在右表上添加索引\",{\"1\":{\"500\":1}}],[\"左连接将索引创建在右表上更合适\",{\"1\":{\"499\":1}}],[\"左表\",{\"1\":{\"499\":1}}],[\"左叶子之和\",{\"0\":{\"410\":1}}],[\"左节点为空\",{\"1\":{\"395\":1}}],[\"左子树上所有结点的值都要小于根节点的值\",{\"1\":{\"397\":1}}],[\"左子树上的所有结点的值均小于它的根节点的值\",{\"1\":{\"340\":1}}],[\"左子树建立了连接\",{\"1\":{\"395\":1}}],[\"左子树包含于最小元素的元素\",{\"1\":{\"348\":1}}],[\"左子树包含小于较小元素的元素\",{\"1\":{\"347\":1}}],[\"左子树包含的元素小于该元素\",{\"1\":{\"347\":1}}],[\"左子结点的右子结点变为旋转结点的左子结点\",{\"1\":{\"343\":1}}],[\"左子结点保持不变\",{\"1\":{\"343\":1}}],[\"左旋只影响旋转结点和其右子树的结构\",{\"1\":{\"343\":1}}],[\"左旋的示意图\",{\"1\":{\"343\":1}}],[\"左旋\",{\"1\":{\"343\":2}}],[\"左\",{\"1\":{\"339\":3,\"340\":1,\"435\":2}}],[\"左移\",{\"1\":{\"313\":1}}],[\"根搜索算法\",{\"0\":{\"1593\":1}}],[\"根本原因是上文中提到的所有方法\",{\"1\":{\"615\":1}}],[\"根据具体应用协议\",{\"1\":{\"1565\":1}}],[\"根据classfilter和methodmatcher来进行过滤\",{\"1\":{\"1531\":1}}],[\"根据beandefinition的autowirecandidate属性来判断是否可以用来依赖注入\",{\"1\":{\"1525\":1}}],[\"根据b+树的算法\",{\"1\":{\"472\":1}}],[\"根据双哈希之后的hash值找到数组对应的小标位置\",{\"1\":{\"1431\":1}}],[\"根据hash值以unsafe调用方式\",{\"1\":{\"1430\":1}}],[\"根据键值key计算hash值得到插入元素数组的索引i\",{\"1\":{\"1426\":1}}],[\"根据经验和实验\",{\"1\":{\"1387\":1}}],[\"根据偏移量\",{\"1\":{\"1356\":1}}],[\"根据策略决定\",{\"1\":{\"732\":1}}],[\"根据父进程内存生成临时快照文件\",{\"1\":{\"725\":1}}],[\"根据某些规则压根儿就不考虑某些连接顺序\",{\"1\":{\"693\":1}}],[\"根据这些记录里的主键值到聚簇索引中做回表操作\",{\"1\":{\"686\":1}}],[\"根据这些记录中的主键值到聚簇索引中做回表操作\",{\"1\":{\"686\":1}}],[\"根据搜索条件\",{\"0\":{\"684\":1},\"1\":{\"683\":1}}],[\"根据t2表中的值索引扫描t1表中的对应行\",{\"1\":{\"661\":1}}],[\"根据关联字段在另一张表\",{\"1\":{\"661\":1}}],[\"根据非主键字段排序的分页查询\",{\"1\":{\"659\":1}}],[\"根据主键id取出整行\",{\"1\":{\"657\":2}}],[\"根据要插入的值和当前自增值的大小关系\",{\"1\":{\"628\":1}}],[\"根据mysql5\",{\"1\":{\"616\":1}}],[\"根据上图\",{\"1\":{\"591\":1}}],[\"根据上面的分析\",{\"1\":{\"581\":1}}],[\"根据两阶段锁协议\",{\"1\":{\"580\":1}}],[\"根据两表查询优化的经验\",{\"1\":{\"500\":1}}],[\"根据加锁的范围\",{\"1\":{\"573\":1}}],[\"根据分区规则year函数算出来的值是2018\",{\"1\":{\"562\":1}}],[\"根据相同的随机方法得到y1\",{\"1\":{\"559\":1}}],[\"根据有序数组\",{\"1\":{\"555\":1}}],[\"根据索引a\",{\"1\":{\"541\":1}}],[\"根据a字段去表t2查找\",{\"1\":{\"538\":1}}],[\"根据存储引擎不同\",{\"1\":{\"518\":1}}],[\"根据叶子节点的内容\",{\"1\":{\"472\":1}}],[\"根据表统计信息及索引选用情况\",{\"1\":{\"467\":1}}],[\"根据词法分析的结果\",{\"1\":{\"457\":1}}],[\"根据以上定义\",{\"1\":{\"398\":1}}],[\"根据题意大于等于即可\",{\"1\":{\"363\":1}}],[\"根据下标关系\",{\"1\":{\"354\":1}}],[\"根据小顶堆的性质\",{\"1\":{\"354\":1}}],[\"根节点枚举\",{\"0\":{\"1636\":1}}],[\"根节点一定是堆中所有结点最大\",{\"1\":{\"351\":1}}],[\"根节点p的左子树显然比右子树高\",{\"1\":{\"343\":1}}],[\"根节点是黑色\",{\"1\":{\"343\":1}}],[\"根\",{\"1\":{\"339\":3}}],[\"方便查阅的\",{\"1\":{\"1859\":1}}],[\"方便在不同版本进行切换修改\",{\"1\":{\"1859\":1}}],[\"方便在面试复习之前刷过的题目\",{\"1\":{\"1850\":1}}],[\"方便gc\",{\"1\":{\"1380\":1}}],[\"方便计算机处理\",{\"1\":{\"337\":1}}],[\"方式是通过intconsumer的参数进行装箱操作\",{\"1\":{\"1497\":1}}],[\"方式二\",{\"1\":{\"1359\":1}}],[\"方式一\",{\"1\":{\"1359\":1}}],[\"方案\",{\"0\":{\"608\":1}}],[\"方框上面的数字表示month\",{\"1\":{\"503\":1}}],[\"方法调用\",{\"0\":{\"1683\":1}}],[\"方法返回地址\",{\"0\":{\"1681\":1}}],[\"方法返回的中间结果容器类型相同\",{\"1\":{\"1494\":1}}],[\"方法返回的也是optional对象\",{\"1\":{\"1487\":1}}],[\"方法表集合\",{\"0\":{\"1659\":1}}],[\"方法区\",{\"0\":{\"1584\":1}}],[\"方法区使用的直接内存\",{\"1\":{\"1541\":1}}],[\"方法出口\",{\"1\":{\"1541\":1}}],[\"方法信息\",{\"1\":{\"1540\":1}}],[\"方法形参名称获取\",{\"1\":{\"1525\":1}}],[\"方法就可以不用再去执行\",{\"1\":{\"1500\":1}}],[\"方法就是printstream中的一个方法\",{\"1\":{\"1482\":1}}],[\"方法就是高阶函数\",{\"1\":{\"1475\":1}}],[\"方法进行修改\",{\"1\":{\"1496\":1}}],[\"方法要完成的事情实际上就是要将downstream在收集的时候\",{\"1\":{\"1495\":1}}],[\"方法本身的参数并没有直接使用t和k\",{\"1\":{\"1495\":1}}],[\"方法本身接收两个参数\",{\"1\":{\"1495\":1}}],[\"方法获取到结果集\",{\"1\":{\"1485\":1}}],[\"方法并不会报错\",{\"1\":{\"1484\":1}}],[\"方法引用是lambda表达式的一种语法糖\",{\"1\":{\"1480\":1}}],[\"方法引用与lambda表达式完全等价\",{\"1\":{\"1480\":1}}],[\"方法引用共分为4类\",{\"1\":{\"1479\":1}}],[\"方法引用\",{\"0\":{\"1479\":1}}],[\"方法引用来创建\",{\"1\":{\"1471\":1}}],[\"方法会获得相反的结果\",{\"1\":{\"1478\":1}}],[\"方法会根据比较器comparator返回两个元素中比较小的那一个\",{\"1\":{\"1478\":1}}],[\"方法也就变成了\",{\"1\":{\"1478\":1}}],[\"方法判断两个参数是不是相等\",{\"1\":{\"1476\":1}}],[\"方法而言\",{\"1\":{\"1475\":1}}],[\"方法无法脱离类或者接口单独存在\",{\"1\":{\"1472\":1}}],[\"方法接收的函数式接口就是我们上面举得第一个例子consumer\",{\"1\":{\"1471\":1}}],[\"方法外\",{\"1\":{\"1471\":1}}],[\"方法存在本质的差别\",{\"1\":{\"1470\":1}}],[\"方法与之前的foreach\",{\"1\":{\"1470\":1}}],[\"方法可以参数的传递总共有两种\",{\"1\":{\"1470\":1}}],[\"方法逻辑拷贝\",{\"1\":{\"1461\":1}}],[\"方法不同的是\",{\"1\":{\"1461\":1}}],[\"方法和类的对象\",{\"1\":{\"1435\":1}}],[\"方法做了两个工作\",{\"1\":{\"1431\":1}}],[\"方法做个验证\",{\"1\":{\"489\":1}}],[\"方法里的\",{\"1\":{\"1431\":1}}],[\"方法中使用了cas策略执行初始化操作\",{\"1\":{\"1431\":1}}],[\"方法二\",{\"1\":{\"1425\":1}}],[\"方法一\",{\"1\":{\"1425\":1}}],[\"方法实现中将原来流中的identity\",{\"1\":{\"1495\":1}}],[\"方法实现本身并没有特别复杂的地方\",{\"1\":{\"1470\":1}}],[\"方法实现\",{\"0\":{\"1424\":1}}],[\"方法来查询流的类型\",{\"1\":{\"1496\":1}}],[\"方法来设置foo的属性age\",{\"1\":{\"1403\":1}}],[\"方法来获取结果\",{\"1\":{\"1393\":1}}],[\"方法抛出的中断异常后\",{\"1\":{\"1401\":1}}],[\"方法重置\",{\"1\":{\"1373\":1}}],[\"方法逃逸\",{\"1\":{\"1365\":1}}],[\"方法还有一个超时参数\",{\"1\":{\"1360\":1}}],[\"方法\",{\"1\":{\"1356\":2,\"1378\":1,\"1401\":3,\"1434\":1,\"1451\":2,\"1470\":1,\"1472\":2,\"1475\":5,\"1484\":5,\"1485\":2,\"1486\":2,\"1487\":1,\"1490\":1,\"1532\":1,\"1540\":2}}],[\"方法的说明\",{\"1\":{\"1495\":1,\"1496\":1,\"1497\":8,\"1498\":1,\"1499\":3,\"1500\":4}}],[\"方法的第一个参数是一个function类型\",{\"1\":{\"1495\":1}}],[\"方法的源码是这样的\",{\"1\":{\"1487\":1}}],[\"方法的参数是空值\",{\"1\":{\"1472\":1}}],[\"方法的时候\",{\"1\":{\"1404\":1}}],[\"方法的实现如下\",{\"1\":{\"1356\":1,\"1500\":1}}],[\"方法的语义也完全相同\",{\"1\":{\"354\":1}}],[\"方法注入\",{\"0\":{\"1117\":1}}],[\"方法是有几个重载的方法\",{\"1\":{\"1485\":1}}],[\"方法是基类object中的方法\",{\"1\":{\"1471\":1}}],[\"方法是\",{\"1\":{\"665\":1}}],[\"方法剖析\",{\"0\":{\"354\":1}}],[\"方法有什么区别\",{\"0\":{\"84\":1}}],[\"孩子数组的下标\",{\"1\":{\"422\":1}}],[\"孩子兄弟表示法\",{\"1\":{\"337\":1}}],[\"孩子表示法\",{\"1\":{\"337\":1}}],[\"树中的叶子节点包含了一两个元素\",{\"1\":{\"1497\":1}}],[\"树中地\",{\"1\":{\"471\":1}}],[\"树叶子结点上保存的是全行数据\",{\"1\":{\"655\":1}}],[\"树可以有二叉\",{\"1\":{\"471\":1}}],[\"树总结\",{\"0\":{\"413\":1}}],[\"树的第二层也有很大的概率在内存中\",{\"1\":{\"471\":1}}],[\"树的祖先的定义\",{\"1\":{\"398\":1}}],[\"树的遍历实际上就是将树中的结点编程某种意义上的线性序列\",{\"1\":{\"337\":1}}],[\"树的表示方法有\",{\"1\":{\"337\":1}}],[\"树\",{\"0\":{\"336\":1,\"394\":1},\"1\":{\"337\":1}}],[\"树形结构\",{\"1\":{\"328\":1}}],[\"双亲委派模型\",{\"0\":{\"1671\":1}}],[\"双亲委派机制简单来说就是\",{\"1\":{\"1540\":1}}],[\"双亲委托机制\",{\"0\":{\"1570\":1}}],[\"双亲表示法\",{\"1\":{\"337\":1}}],[\"双列集合有map\",{\"1\":{\"1415\":1}}],[\"双向链表\",{\"1\":{\"1367\":1}}],[\"双重检测\",{\"1\":{\"1353\":1}}],[\"双重检查锁\",{\"0\":{\"276\":1}}],[\"双精度浮点数值\",{\"1\":{\"665\":1}}],[\"双路排序的详细过程\",{\"1\":{\"657\":1}}],[\"双路排序\",{\"1\":{\"657\":1}}],[\"双m的主备结构里要求双写的时候\",{\"1\":{\"628\":1}}],[\"双m结构有一个显著的问题需要解决\",{\"1\":{\"592\":1}}],[\"双1\",{\"1\":{\"588\":1}}],[\"双指针的解法\",{\"1\":{\"372\":1}}],[\"双指针\",{\"1\":{\"369\":1,\"383\":1}}],[\"双指针法\",{\"1\":{\"366\":1}}],[\"双端队列等\",{\"1\":{\"708\":1}}],[\"双端队列\",{\"0\":{\"335\":1},\"1\":{\"335\":1}}],[\"队列又太小\",{\"1\":{\"1413\":1}}],[\"队列没法设置特别大\",{\"1\":{\"1413\":1}}],[\"队列没满的时候是正常的插入\",{\"1\":{\"1378\":1}}],[\"队列堆满只是时间问题\",{\"1\":{\"1413\":1}}],[\"队列长度加1\",{\"1\":{\"1380\":1}}],[\"队列不满\",{\"1\":{\"1380\":1}}],[\"队列可以随着元素的添加而动态增长\",{\"1\":{\"1380\":1}}],[\"队列满了\",{\"1\":{\"1379\":1}}],[\"队列它还能起到一个隔离的作用\",{\"1\":{\"1378\":1}}],[\"队列里有数据会正常取出数据并删除\",{\"1\":{\"1378\":1}}],[\"队列为空则返回null\",{\"1\":{\"1377\":2}}],[\"队列为空则抛出异常\",{\"1\":{\"1377\":2}}],[\"队列\",{\"0\":{\"334\":1,\"1711\":1},\"1\":{\"1378\":2}}],[\"就搞的懂这么难的东西\",{\"1\":{\"1850\":1}}],[\"就适当降低该值\",{\"1\":{\"1541\":1}}],[\"就实现层面来说\",{\"1\":{\"1536\":1}}],[\"就确定了哪些对象是需要生成代理对象的\",{\"1\":{\"1531\":1}}],[\"就确保了主库上执行的这个查询结果一定包含了trx1的数据\",{\"1\":{\"610\":1}}],[\"就注册到depentbeanmap中\",{\"1\":{\"1524\":1}}],[\"就正式进入的流源码的分析\",{\"1\":{\"1497\":1}}],[\"就执行mappingfunction\",{\"1\":{\"1495\":1}}],[\"就像reduce一样\",{\"1\":{\"1485\":1}}],[\"就像我们的第一个例子一样\",{\"1\":{\"485\":1}}],[\"就顺利的同时包含了较小的值和较大的值\",{\"1\":{\"1484\":1}}],[\"就变成了\",{\"1\":{\"1478\":1}}],[\"就变成单线程复制了\",{\"1\":{\"598\":1}}],[\"就通知用户进程\",{\"1\":{\"1442\":1}}],[\"就帮助其扩容\",{\"1\":{\"1431\":1}}],[\"就调用扩容方法\",{\"1\":{\"1431\":1}}],[\"就调用nanosleep函数进入sleep状态\",{\"1\":{\"618\":1}}],[\"就扩充为原来的2倍\",{\"1\":{\"1427\":1}}],[\"就进行扩容操作\",{\"1\":{\"1426\":1}}],[\"就停止处理\",{\"1\":{\"1408\":1}}],[\"就消耗那一个结果\",{\"1\":{\"1395\":1}}],[\"就入队\",{\"1\":{\"1380\":1}}],[\"就阻塞在notfull上等待被其它线程唤醒\",{\"1\":{\"1380\":1}}],[\"就使用唯一的构造方法\",{\"1\":{\"1527\":1}}],[\"就使用那一个结果\",{\"1\":{\"1395\":1}}],[\"就使用最大int值初始化其容量\",{\"1\":{\"1380\":1}}],[\"就使用set或者自己的数据类型即可\",{\"1\":{\"714\":1}}],[\"就少自旋身之不自旋\",{\"1\":{\"1362\":1}}],[\"就称之为源\",{\"1\":{\"1484\":1}}],[\"就称这段代码块为临界区\",{\"1\":{\"1359\":1}}],[\"就称为可用性优先流程\",{\"1\":{\"596\":1}}],[\"就称为回表\",{\"1\":{\"474\":1}}],[\"就给他赋一个新值\",{\"1\":{\"1356\":1}}],[\"就比较麻烦了\",{\"1\":{\"798\":1}}],[\"就比较适合来做备份\",{\"1\":{\"594\":1}}],[\"就在缓存中方一个空对象用于处理后续这个请求\",{\"1\":{\"764\":1}}],[\"就在内存中change\",{\"1\":{\"482\":1}}],[\"就被链接到对应频道的链表的尾部\",{\"1\":{\"736\":1}}],[\"就意味该列的值全部是重复的\",{\"1\":{\"690\":1}}],[\"就意味着越\",{\"1\":{\"761\":1}}],[\"就意味着数据丢失\",{\"1\":{\"632\":1}}],[\"就意味着使用这两个索引都需要排序\",{\"1\":{\"485\":1}}],[\"就必然会出现\",{\"1\":{\"634\":1}}],[\"就必须走主库\",{\"1\":{\"607\":1}}],[\"就必须保证主库发给备库的日志是完整的\",{\"1\":{\"605\":1}}],[\"就必须等到备库b的seconds\",{\"1\":{\"596\":1}}],[\"就必须将当前的值依次执行图中所有的回滚操作得到\",{\"1\":{\"571\":1}}],[\"就必须对语句做改写\",{\"1\":{\"550\":1}}],[\"就必须了解优化器选择索引的策略\",{\"1\":{\"483\":1}}],[\"就必须让查询过程访问尽量少地数据块\",{\"1\":{\"471\":1}}],[\"就必须全部扫描一遍了\",{\"1\":{\"469\":1}}],[\"就大大减少了并发事务申请trx\",{\"1\":{\"634\":1}}],[\"就获得max\",{\"1\":{\"634\":1}}],[\"就应该使用spliterator\",{\"1\":{\"1497\":1}}],[\"就应该创建成8个字节bigint\",{\"1\":{\"631\":1}}],[\"就应该放弃\",{\"1\":{\"610\":1}}],[\"就跳过这个id\",{\"1\":{\"628\":1}}],[\"就方便多了\",{\"1\":{\"622\":1}}],[\"就避免了在恢复数据时还要应用其它库日志的情况\",{\"1\":{\"622\":1}}],[\"就避免了被驱动表上的字符编码转换\",{\"1\":{\"505\":1}}],[\"就无法通过flashback来恢复了\",{\"1\":{\"622\":1}}],[\"就无须设置master\",{\"1\":{\"605\":1}}],[\"就导致已经在之前误操作的基础上\",{\"1\":{\"621\":1}}],[\"就导致了系统在这个时刻之后\",{\"1\":{\"634\":1}}],[\"就导致了第二个insert语句又拿到相同的自增id值\",{\"1\":{\"631\":1}}],[\"就导致了意外的长事务\",{\"1\":{\"572\":1}}],[\"就导致了session\",{\"1\":{\"562\":1}}],[\"就把command列线程成killed\",{\"1\":{\"618\":1}}],[\"就认为系统不可用\",{\"1\":{\"615\":1}}],[\"就已经执行过这个位置了\",{\"1\":{\"610\":1}}],[\"就返回0\",{\"1\":{\"1495\":1}}],[\"就返回\",{\"1\":{\"610\":1}}],[\"就开始给客户端返回确认\",{\"1\":{\"609\":1}}],[\"就算晚几秒看到最新发布的商品\",{\"1\":{\"607\":1}}],[\"就拒绝把日志发给b\",{\"1\":{\"605\":1}}],[\"就还是按照原来的分配方式\",{\"1\":{\"605\":1}}],[\"就将descriptor对应的类型所匹配的所有bean方法\",{\"1\":{\"1525\":1}}],[\"就将元素提供给consumer\",{\"1\":{\"1500\":1}}],[\"就将他放入到map里面\",{\"1\":{\"1495\":1}}],[\"就将特性值设置为空\",{\"1\":{\"1495\":1}}],[\"就将该值+1\",{\"1\":{\"1362\":1}}],[\"就将thread\",{\"1\":{\"635\":1}}],[\"就将这行数据写入表中\",{\"1\":{\"632\":1}}],[\"就将这个current\",{\"1\":{\"605\":1}}],[\"就将x这一行的c值加1\",{\"1\":{\"553\":1}}],[\"就暂时退化为单线程模式\",{\"1\":{\"599\":1}}],[\"就有两个特征\",{\"1\":{\"632\":1}}],[\"就有两种情况\",{\"1\":{\"609\":1}}],[\"就有可能修改元的大小\",{\"1\":{\"1497\":1}}],[\"就有可能导致数据库崩溃\",{\"1\":{\"763\":1}}],[\"就有可能读到刚刚的事务更新之前的状态\",{\"1\":{\"606\":1}}],[\"就有可能session\",{\"1\":{\"599\":1}}],[\"就有了批量重偏向与批量撤销的机制\",{\"1\":{\"1362\":1}}],[\"就有了mixed这种binlog格式存在的场景\",{\"1\":{\"591\":1}}],[\"就有了\",{\"1\":{\"570\":1}}],[\"就相应的有不同的策略\",{\"1\":{\"594\":1}}],[\"就相对麻烦了\",{\"1\":{\"472\":1}}],[\"就能够确定在从库上执行的查询请求吗\",{\"1\":{\"609\":1}}],[\"就能恢复这个更新操作了\",{\"1\":{\"591\":1}}],[\"就能确定将这条语句到哪个分表做查询\",{\"1\":{\"548\":1}}],[\"就用row格式\",{\"1\":{\"591\":1}}],[\"就肯定会删除id=4的行\",{\"1\":{\"591\":1}}],[\"就拥有超级线程\",{\"1\":{\"590\":1}}],[\"就切成状态2\",{\"1\":{\"590\":1}}],[\"就形成了7个next\",{\"1\":{\"585\":1}}],[\"就产生了7个间隙\",{\"1\":{\"585\":1}}],[\"就破坏了session\",{\"1\":{\"584\":1}}],[\"就只有\",{\"1\":{\"618\":1}}],[\"就只能等trx2完全执行完成\",{\"1\":{\"601\":1}}],[\"就只能使用ftwrl命令了\",{\"1\":{\"575\":1}}],[\"就只需要从左到右\",{\"1\":{\"554\":1}}],[\"就只需要一次指针寻找和一次计算\",{\"1\":{\"479\":1}}],[\"就只需要回表2次\",{\"1\":{\"477\":1}}],[\"就可能导致cpu资源的浪费\",{\"1\":{\"1387\":1}}],[\"就可能导致生产事故\",{\"1\":{\"578\":1}}],[\"就可能出现一些不确定的行为\",{\"1\":{\"1497\":1}}],[\"就可能出现max\",{\"1\":{\"634\":1}}],[\"就可能出现这样的情况\",{\"1\":{\"629\":1}}],[\"就可能出现对数据的二次破坏\",{\"1\":{\"621\":1}}],[\"就可能出现行冲入\",{\"1\":{\"615\":1}}],[\"就可能出现脏读\",{\"1\":{\"570\":1}}],[\"就可能会出现错误\",{\"1\":{\"1494\":1}}],[\"就可能会出现大量的超时\",{\"1\":{\"581\":1}}],[\"就可能会导致主备延迟了\",{\"1\":{\"594\":1}}],[\"就可以把这些技术整合起来做个项目\",{\"1\":{\"1865\":1}}],[\"就可以了\",{\"1\":{\"1852\":1}}],[\"就可以开始下一阶段的学习了\",{\"1\":{\"1850\":1}}],[\"就可以开始刷算法啦\",{\"1\":{\"1848\":1}}],[\"就可以做个图书管理系统\",{\"1\":{\"1847\":1}}],[\"就可以做到既节省空间\",{\"1\":{\"487\":1}}],[\"就可以获取到被代理的对象\",{\"1\":{\"1531\":1}}],[\"就可以获得一个大概参考值来判断当前响应时间是不是一个合理的值\",{\"1\":{\"525\":1}}],[\"就可以认为是配置类\",{\"1\":{\"1529\":1}}],[\"就可以通过factorybean来实现\",{\"1\":{\"1521\":1}}],[\"就可以通过max\",{\"1\":{\"616\":1}}],[\"就可以执行控制性的遍历\",{\"1\":{\"1496\":1}}],[\"就可以打印3到8的内容\",{\"1\":{\"1484\":1}}],[\"就可以支持成千上万的连接\",{\"1\":{\"1451\":1}}],[\"就可以\",{\"1\":{\"1394\":1}}],[\"就可以客观认为主机故障\",{\"1\":{\"758\":1}}],[\"就可以立即返回\",{\"1\":{\"740\":1}}],[\"就可以计算接近\",{\"1\":{\"714\":1}}],[\"就可以考虑是不是由于eq\",{\"1\":{\"690\":1}}],[\"就可以考虑搭建延迟复制的备库\",{\"1\":{\"623\":1}}],[\"就可以沿着叶子节点组成的双向链表把所有记录都查看一遍\",{\"1\":{\"685\":1}}],[\"就可以保证两点\",{\"1\":{\"634\":1}}],[\"就可以看到\",{\"1\":{\"1488\":1}}],[\"就可以看到这样一段javadoc\",{\"1\":{\"1471\":1}}],[\"就可以看到如下结果\",{\"1\":{\"627\":1}}],[\"就可以看到下面这个图\",{\"1\":{\"618\":1}}],[\"就可以恢复出数据的临时实例\",{\"1\":{\"623\":1}}],[\"就可以恢复出需要的数据\",{\"1\":{\"623\":1}}],[\"就可以正常同步了\",{\"1\":{\"622\":1}}],[\"就可以正式开始执行select语句了\",{\"1\":{\"456\":1}}],[\"就可以让临时库只同步误操作的表\",{\"1\":{\"622\":1}}],[\"就可以关掉这个自动不全的功能\",{\"1\":{\"619\":1}}],[\"就可以加入监控累积值了\",{\"1\":{\"616\":1}}],[\"就可以采用位点和gtid的方法来确保主备无延迟\",{\"1\":{\"609\":1}}],[\"就可以并行\",{\"1\":{\"602\":1}}],[\"就可以精确地只得到三个最小值\",{\"1\":{\"558\":1}}],[\"就可以告诉优化器\",{\"1\":{\"555\":1}}],[\"就可以拿到group\",{\"1\":{\"554\":1}}],[\"就可以得到结果\",{\"1\":{\"548\":1}}],[\"就可以直接从远程仓库同步到本地\",{\"1\":{\"1858\":1}}],[\"就可以直接对流源进行操作\",{\"1\":{\"1499\":1}}],[\"就可以直接通过alter\",{\"1\":{\"563\":1}}],[\"就可以直接转为bka算法了\",{\"1\":{\"544\":1}}],[\"就可以直接返回结果\",{\"1\":{\"456\":1}}],[\"就可以用上被驱动表上的索引\",{\"1\":{\"540\":1}}],[\"就可以用来记录新的操作\",{\"1\":{\"461\":1}}],[\"就可以大大降低对服务器的影响\",{\"1\":{\"530\":1}}],[\"就可以选择前缀长度为6\",{\"1\":{\"487\":1}}],[\"就可以少维护一个索引\",{\"1\":{\"476\":1}}],[\"就可以利用索引来加速检索\",{\"1\":{\"476\":1}}],[\"就可以存1200的3次方个值\",{\"1\":{\"471\":1}}],[\"就可以找到其对应的值即value\",{\"1\":{\"469\":1}}],[\"就可以退出当前循环\",{\"1\":{\"428\":1}}],[\"就可以使用方法引用来写出更加简洁的代码\",{\"1\":{\"1479\":1}}],[\"就可以使用tab键自动补全表名或者显示提示\",{\"1\":{\"619\":1}}],[\"就可以使用这个逻辑\",{\"1\":{\"610\":1}}],[\"就可以使用队列来解决\",{\"1\":{\"334\":1}}],[\"就可以使用栈来解决\",{\"1\":{\"333\":1}}],[\"就插入一条记录\",{\"1\":{\"553\":1}}],[\"就依次执行子查询\",{\"1\":{\"551\":1}}],[\"就没有必要子类加载器再加载一次\",{\"1\":{\"1540\":1}}],[\"就没有了\",{\"1\":{\"551\":1}}],[\"就没必要使用change\",{\"1\":{\"480\":1}}],[\"就作为结果集的一行\",{\"1\":{\"545\":1}}],[\"就作为结果集的一部分返回\",{\"1\":{\"544\":1}}],[\"就按行累加\",{\"1\":{\"536\":1}}],[\"就怎么用\",{\"1\":{\"515\":1}}],[\"就不用再做其他的操作来保证线程安全\",{\"1\":{\"1492\":1}}],[\"就不允许修改了\",{\"1\":{\"1403\":1}}],[\"就不允许创建myisam分区表了\",{\"1\":{\"562\":1}}],[\"就不需要移动它后面的元素\",{\"1\":{\"1379\":1}}],[\"就不应该允许其他线程对该资源进行读和写操作了\",{\"1\":{\"1375\":1}}],[\"就不再继续往后分析bca这个连接顺序的成本了\",{\"1\":{\"693\":1}}],[\"就不可避免的要设置位点的这两个参数\",{\"1\":{\"604\":1}}],[\"就不止是给数据库已有的6个记录加上了行锁\",{\"1\":{\"585\":1}}],[\"就不会被压制\",{\"1\":{\"1496\":1}}],[\"就不会使用index\",{\"1\":{\"690\":1}}],[\"就不会再看后面的字段\",{\"1\":{\"642\":1}}],[\"就不会再处理这个日志\",{\"1\":{\"592\":1}}],[\"就不会记录到binlog里\",{\"1\":{\"550\":1}}],[\"就不会移动到lru链表头部\",{\"1\":{\"543\":1}}],[\"就不会导致线上出现主从数据库不一致的情况\",{\"1\":{\"464\":1}}],[\"就不得不回到id索引再去判断email字段的值\",{\"1\":{\"488\":1}}],[\"就直接使用满足范围条件的索引记录条数作为扇出值\",{\"1\":{\"691\":1}}],[\"就直接使用表中记录的数量作为扇出值\",{\"1\":{\"691\":1}}],[\"就直接使用统计数据来估算这些参数需要单点区间对应的记录条数了\",{\"1\":{\"690\":1}}],[\"就直接使用语句里指定的值\",{\"1\":{\"628\":1}}],[\"就直接丢弃这个日志\",{\"1\":{\"592\":1}}],[\"就直接选择这个索引\",{\"1\":{\"485\":1}}],[\"就直接返回给执行器\",{\"1\":{\"463\":1}}],[\"就得从io拷贝机制说起\",{\"1\":{\"1453\":1}}],[\"就得到了最终的结果\",{\"1\":{\"558\":1}}],[\"就得到了一个有序数组\",{\"1\":{\"555\":1}}],[\"就得到了这个索引的基数\",{\"1\":{\"484\":1}}],[\"就得先停下来擦掉一些记录\",{\"1\":{\"461\":1}}],[\"就是直接进入这个方法\",{\"1\":{\"1499\":1}}],[\"就是可以传入自己本身以及父类的比较器\",{\"1\":{\"1491\":1}}],[\"就是可能出现数据不一致的情况\",{\"1\":{\"596\":1}}],[\"就是取决于是否可能会出现空指针的情况\",{\"1\":{\"1487\":1}}],[\"就是取整数部分\",{\"1\":{\"559\":1}}],[\"就是使用并发来加快运行的效率\",{\"1\":{\"1484\":1}}],[\"就是jdk8中新增的语法\",{\"1\":{\"1479\":1}}],[\"就是supplier函数式接口的一个实例\",{\"1\":{\"1477\":1}}],[\"就是select的数据列只用从索引中就能够取得\",{\"1\":{\"467\":1}}],[\"就是这两个lambda表达式的上下文\",{\"1\":{\"1472\":1}}],[\"就是这个10000行里面r值最小的三行\",{\"1\":{\"558\":1}}],[\"就是myinterface\",{\"1\":{\"1472\":1}}],[\"就是将内核缓冲区的内存和用户缓冲区的内存做了一个地址映射\",{\"1\":{\"1464\":1}}],[\"就是指数据从一个存储区域转移到另一个存储区域\",{\"1\":{\"1453\":1}}],[\"就是变量一旦被赋值\",{\"1\":{\"1403\":1}}],[\"就是对象一旦被创建之后\",{\"1\":{\"1403\":1}}],[\"就是允许空闲线程从繁忙的双端队列中窃取任务\",{\"1\":{\"1388\":1}}],[\"就是根据以往经验指定的一些规则\",{\"1\":{\"693\":1}}],[\"就是n的阶乘种连接顺序\",{\"1\":{\"693\":1}}],[\"就是先把获取索引对应的b+树的区间最左记录和区间最右记录\",{\"1\":{\"690\":1}}],[\"就是读锁会阻塞写\",{\"1\":{\"672\":1}}],[\"就是通过事务的一致性视图与这行数据的trx\",{\"1\":{\"634\":1}}],[\"就是为了效率上的考量\",{\"1\":{\"1499\":1}}],[\"就是为了更为方便的编写函数式的代码\",{\"1\":{\"1484\":1}}],[\"就是为了能够在innodb事务和server之间做关联\",{\"1\":{\"634\":1}}],[\"就是为了达到这个目的\",{\"1\":{\"629\":1}}],[\"就是为了要更新数据\",{\"1\":{\"584\":1}}],[\"就是让session\",{\"1\":{\"618\":1}}],[\"就是随机性\",{\"1\":{\"615\":1}}],[\"就是会多占一些内存\",{\"1\":{\"613\":1}}],[\"就是出现了过期读\",{\"1\":{\"609\":1}}],[\"就是大表ddl\",{\"1\":{\"594\":1}}],[\"就是一个先进先出的数据结构\",{\"1\":{\"1863\":1}}],[\"就是一个过滤阶段\",{\"1\":{\"1500\":1}}],[\"就是一个典型的大事务的场景\",{\"1\":{\"594\":1}}],[\"就是一个回文串\",{\"1\":{\"428\":1}}],[\"就是同一个事务\",{\"1\":{\"594\":1}}],[\"就是我们输入的sql原文\",{\"1\":{\"591\":1}}],[\"就是图中的这两个gtid\",{\"1\":{\"605\":1}}],[\"就是图中io\",{\"1\":{\"590\":1}}],[\"就是图中红色的部分\",{\"1\":{\"588\":1}}],[\"就是要被遍历的元素的个数\",{\"1\":{\"1497\":1}}],[\"就是要能读到所有已经提交的记录的最新值\",{\"1\":{\"583\":1}}],[\"就是要把一个逻辑上的大表分散到不同的数据库实例上\",{\"1\":{\"548\":1}}],[\"就是进入了死锁状态\",{\"1\":{\"581\":1}}],[\"就是针对数据表中行记录的锁\",{\"1\":{\"579\":1}}],[\"就是数据库的多版本并发控制\",{\"1\":{\"571\":1}}],[\"就是\",{\"1\":{\"540\":1}}],[\"就是看explain的结果里面\",{\"1\":{\"540\":1}}],[\"就是如果查询要返回的字段很多的话\",{\"1\":{\"492\":1}}],[\"就是写了两处内存\",{\"1\":{\"482\":1}}],[\"就打开表继续执行\",{\"1\":{\"459\":1}}],[\"就要将sourcesupplier置为null\",{\"1\":{\"1498\":1}}],[\"就要将进程切换到内核态\",{\"1\":{\"1456\":1}}],[\"就要考虑\",{\"1\":{\"686\":1}}],[\"就要放个有意义的字段\",{\"1\":{\"615\":1}}],[\"就要放弃读写分离\",{\"1\":{\"607\":1}}],[\"就要引入半同步复制\",{\"1\":{\"609\":1}}],[\"就要同步这个事务过来执行\",{\"1\":{\"605\":1}}],[\"就要执行change\",{\"1\":{\"604\":1}}],[\"就要把这10万条记录都写到binlog中\",{\"1\":{\"591\":1}}],[\"就要暂存到磁盘\",{\"1\":{\"587\":1}}],[\"就要看看它所依赖的线程有没有被别人锁住\",{\"1\":{\"581\":1}}],[\"就要访问p\",{\"1\":{\"562\":1}}],[\"就要使用手动分表的方式\",{\"1\":{\"561\":1}}],[\"就要等session\",{\"1\":{\"561\":1}}],[\"就要多利用内存\",{\"1\":{\"493\":1}}],[\"就要先判断现在表中是否已经存在k=4的记录\",{\"1\":{\"480\":1}}],[\"就要做一次全表扫描\",{\"1\":{\"539\":1}}],[\"就要做\",{\"1\":{\"457\":1}}],[\"就要真正开始执行语句了\",{\"1\":{\"457\":1}}],[\"就会额外会执行一些其他逻辑\",{\"1\":{\"1531\":1}}],[\"就会递归在父beanfactory中查找\",{\"1\":{\"1524\":1}}],[\"就会直接返回\",{\"1\":{\"1534\":1}}],[\"就会直接抛出异常\",{\"1\":{\"1524\":1}}],[\"就会直接拿新的值覆盖旧值\",{\"1\":{\"1434\":1}}],[\"就会使用该propertyeditor来做类型转化\",{\"1\":{\"1515\":1}}],[\"就会使用第二种不缓存的方式\",{\"1\":{\"619\":1}}],[\"就会进入到mybatis框架的底层执行流程\",{\"1\":{\"1530\":1}}],[\"就会进入短路逻辑的判断\",{\"1\":{\"1500\":1}}],[\"就会进入等待状态\",{\"1\":{\"613\":1}}],[\"就会牺牲并行的优势\",{\"1\":{\"1499\":1}}],[\"就会对\",{\"1\":{\"1847\":1}}],[\"就会对的下一个元素去执行action方法\",{\"1\":{\"1497\":1}}],[\"就会对元素执行给定的action方法\",{\"1\":{\"1497\":1}}],[\"就会在元创建的时候或者说第一次调用方法时候进行绑定\",{\"1\":{\"1497\":1}}],[\"就会在控制台打印字符5\",{\"1\":{\"1489\":1}}],[\"就会输出\",{\"1\":{\"1496\":1}}],[\"就会按照被添加进去的顺序得到调用\",{\"1\":{\"1496\":1}}],[\"就会两个list是相同的\",{\"1\":{\"1492\":1}}],[\"就会发现\",{\"1\":{\"1494\":1}}],[\"就会发现有问题\",{\"1\":{\"1491\":1}}],[\"就会发生丢失更新问题\",{\"1\":{\"669\":1}}],[\"就会返回jdk动态代理的对象\",{\"1\":{\"1531\":1}}],[\"就会返回并且销毁\",{\"1\":{\"1499\":1}}],[\"就会返回源阶段的分割迭代器\",{\"1\":{\"1499\":1}}],[\"就会返回long\",{\"1\":{\"1497\":1}}],[\"就会返回一个新的spliterator对象\",{\"1\":{\"1497\":1}}],[\"就会返回0\",{\"1\":{\"1490\":1}}],[\"就会返回没有权限的错误\",{\"1\":{\"459\":1}}],[\"就会顺利的再控制台打印出我们想要的结果了\",{\"1\":{\"1487\":1}}],[\"就会抛出concurrentmodificationexception的异常\",{\"1\":{\"1497\":1}}],[\"就会抛出illegalstateexception\",{\"1\":{\"1496\":1}}],[\"就会抛出stream已经被使用的异常\",{\"1\":{\"1487\":1}}],[\"就会抛出异常\",{\"1\":{\"1377\":1,\"1494\":1}}],[\"就会自动跳转到\",{\"1\":{\"1472\":1}}],[\"就会自动跳过误操作的语句\",{\"1\":{\"622\":1}}],[\"就会死循环在这里\",{\"1\":{\"1428\":1}}],[\"就会将其合并称一次范围更大的加锁和解锁操作\",{\"1\":{\"1363\":1}}],[\"就会将事务t分配给worker\",{\"1\":{\"598\":1}}],[\"就会多自旋几次\",{\"1\":{\"1362\":1}}],[\"就会占用部分空间\",{\"1\":{\"767\":1}}],[\"就会全部转移到数据库上\",{\"1\":{\"763\":1}}],[\"就会触发redistemplate上的条件注解使默认的redistemplate失效\",{\"1\":{\"720\":1}}],[\"就会继续从0开始计数\",{\"1\":{\"633\":1}}],[\"就会继续后面的执行阶段\",{\"1\":{\"456\":1}}],[\"就会出现问题\",{\"1\":{\"1359\":1}}],[\"就会出现这个情况\",{\"1\":{\"634\":1}}],[\"就会出现插入语句报错\",{\"1\":{\"628\":1}}],[\"就会出现另外一种情况\",{\"1\":{\"543\":1}}],[\"就会产生过期读的问题\",{\"1\":{\"609\":1}}],[\"就会涉及到一主多从的架构\",{\"1\":{\"603\":1}}],[\"就会报唯一键冲突\",{\"1\":{\"599\":1}}],[\"就会报错\",{\"1\":{\"550\":1}}],[\"就会从hash\",{\"1\":{\"598\":1}}],[\"就会看到这个事务\",{\"1\":{\"597\":1}}],[\"就会看到cpu利用率很高\",{\"1\":{\"581\":1}}],[\"就会记录为statement格式\",{\"1\":{\"591\":1}}],[\"就会记录为row格式\",{\"1\":{\"591\":1}}],[\"就会丢失数据\",{\"1\":{\"588\":1}}],[\"就会带上事务a在redo\",{\"1\":{\"588\":1}}],[\"就会把插入r这一行数据的binlog又同步到从库b去执行\",{\"1\":{\"604\":1}}],[\"就会把redo\",{\"1\":{\"588\":1}}],[\"就会把这100行数据分成多段执行上图的流程\",{\"1\":{\"542\":1}}],[\"就会导致轻量级锁膨胀为重量级锁\",{\"1\":{\"1362\":1}}],[\"就会导致服务端发送结果被阻塞\",{\"1\":{\"619\":1}}],[\"就会导致备库应用日志不够快\",{\"1\":{\"597\":1}}],[\"就会导致这几个线程都进入无限等待的状态\",{\"1\":{\"581\":1}}],[\"就会导致mysql实例的buffer\",{\"1\":{\"543\":1}}],[\"就会一直占着mdl锁\",{\"1\":{\"578\":1}}],[\"就会加上mdl写锁\",{\"1\":{\"578\":1}}],[\"就会加上mdl读锁\",{\"1\":{\"578\":1}}],[\"就会优先考虑使用临时表\",{\"1\":{\"555\":1}}],[\"就会利用磁盘临时文件辅助排序\",{\"1\":{\"555\":1}}],[\"就会执行步骤2和3\",{\"1\":{\"541\":1}}],[\"就会执行类似这样的sql语句\",{\"1\":{\"478\":1}}],[\"就会分段放置\",{\"1\":{\"540\":1}}],[\"就会不经意间导致整个数据库的压力变大\",{\"1\":{\"502\":1}}],[\"就会停止继续检索\",{\"1\":{\"479\":1}}],[\"就会收到\",{\"1\":{\"457\":1}}],[\"就会收到一个错误提示\",{\"1\":{\"455\":1}}],[\"就表示主库没有问题\",{\"1\":{\"613\":1}}],[\"就表示所有给客户端发送过确认的事务\",{\"1\":{\"609\":1}}],[\"就表示接收到的日志已经同步完成\",{\"1\":{\"609\":1}}],[\"就表示事务已经通过锁冲突的检验了\",{\"1\":{\"602\":1}}],[\"就表示使用了优先队列排序算法\",{\"1\":{\"558\":1}}],[\"就表示现在系统里面有一个空闲连接\",{\"1\":{\"455\":1}}],[\"就表示子串\",{\"1\":{\"428\":1}}],[\"就需要再调用一次begin方法\",{\"1\":{\"1500\":1}}],[\"就需要对于中间操作进行一般化的处理\",{\"1\":{\"1499\":1}}],[\"就需要显示的声明类型\",{\"1\":{\"1491\":1}}],[\"就需要调用flatmap方法\",{\"1\":{\"1486\":1}}],[\"就需要多个配置文件\",{\"1\":{\"746\":1}}],[\"就需要阅读redisproperties\",{\"1\":{\"720\":1}}],[\"就需要计算出驱动表的扇出值\",{\"1\":{\"691\":1}}],[\"就需要进行多少次回表操作\",{\"1\":{\"686\":1}}],[\"就需要把当前自增值修改为新的自增值\",{\"1\":{\"628\":1}}],[\"就需要恢复6天的日志\",{\"1\":{\"623\":1}}],[\"就需要使用全量备份\",{\"1\":{\"622\":1}}],[\"就需要一个按行并行复制的方案\",{\"1\":{\"599\":1}}],[\"就需要做优化\",{\"1\":{\"543\":1}}],[\"就需要扫描100亿行\",{\"1\":{\"539\":1}}],[\"就需要外部排序\",{\"1\":{\"491\":1}}],[\"就需要重连\",{\"1\":{\"455\":1}}],[\"就需要交互对话里面输入密码\",{\"1\":{\"455\":1}}],[\"就需要了解mysql的逻辑架构\",{\"1\":{\"454\":1}}],[\"就交换它们\",{\"1\":{\"317\":1}}],[\"栈帧\",{\"1\":{\"1541\":1}}],[\"栈与队列\",{\"0\":{\"391\":1}}],[\"栈中有左括号\",{\"1\":{\"386\":1}}],[\"栈\",{\"0\":{\"333\":1},\"1\":{\"708\":2,\"1541\":1}}],[\"链路追踪等\",{\"1\":{\"1867\":1}}],[\"链接\",{\"1\":{\"449\":1,\"796\":1}}],[\"链地址法是解决哈希冲突比较常见的做法\",{\"1\":{\"469\":1}}],[\"链地址法\",{\"1\":{\"332\":1}}],[\"链表长度大于8的时候转为红黑树\",{\"1\":{\"1431\":1}}],[\"链表长度大于8转换为红黑树进行处理\",{\"1\":{\"1426\":1}}],[\"链表优化重hash的代码块\",{\"1\":{\"1427\":1}}],[\"链表就转换为了红黑树\",{\"1\":{\"1423\":1}}],[\"链表的下一个node\",{\"1\":{\"1423\":1}}],[\"链表的查询时间时间复杂度o\",{\"1\":{\"330\":1}}],[\"链表尾\",{\"1\":{\"1380\":1}}],[\"链表头\",{\"1\":{\"1380\":1}}],[\"链表转红黑树的阈值\",{\"1\":{\"1352\":1}}],[\"链表插入方式\",{\"1\":{\"1352\":1}}],[\"链表中保存了所有订阅这个频道的客户端\",{\"1\":{\"736\":1}}],[\"链表总结\",{\"0\":{\"378\":1}}],[\"链表相交\",{\"0\":{\"376\":1}}],[\"链表\",{\"0\":{\"330\":1,\"370\":1},\"1\":{\"1352\":1}}],[\"开箱即用\",{\"1\":{\"1864\":1}}],[\"开源的\",{\"1\":{\"1864\":1}}],[\"开源项目\",{\"0\":{\"6\":1}}],[\"开发者必看的书\",{\"1\":{\"1870\":1}}],[\"开发的工作\",{\"1\":{\"1861\":1}}],[\"开发框架\",{\"1\":{\"1860\":1}}],[\"开发人员通过这些本地api来操作数据库\",{\"1\":{\"806\":1}}],[\"开销大\",{\"1\":{\"672\":1}}],[\"开销小\",{\"1\":{\"671\":1}}],[\"开头的索引之后\",{\"1\":{\"655\":1}}],[\"开头的索引\",{\"1\":{\"655\":1}}],[\"开始\",{\"1\":{\"1356\":1}}],[\"开始计数\",{\"1\":{\"706\":1}}],[\"开始按照备库b传过来的位置\",{\"1\":{\"590\":1}}],[\"开始执行的时候\",{\"1\":{\"459\":1}}],[\"开始执行语句\",{\"1\":{\"459\":1}}],[\"开启一个事务\",{\"1\":{\"1532\":1}}],[\"开启spring事务本质上就是增加了一个advisor\",{\"1\":{\"1532\":1}}],[\"开启show\",{\"1\":{\"568\":2}}],[\"开启了事务\",{\"1\":{\"1530\":1}}],[\"开启了慢查询日志后\",{\"1\":{\"565\":1}}],[\"开启并行流的方式除了之前我们使用过的parallelstream\",{\"1\":{\"1494\":1}}],[\"开启锁消除\",{\"1\":{\"1364\":1}}],[\"开启事务\",{\"1\":{\"716\":2,\"719\":1}}],[\"开启trace\",{\"1\":{\"656\":1,\"657\":1}}],[\"开启慢查询日志\",{\"1\":{\"565\":2,\"567\":1}}],[\"开放地址法\",{\"1\":{\"332\":1}}],[\"除特殊情况外\",{\"1\":{\"1496\":1}}],[\"除数组之外还有一个序列号\",{\"1\":{\"1397\":1}}],[\"除非显示的使用另外一个classloader\",{\"1\":{\"1540\":1}}],[\"除非其余的异常是与第一个异常相同的异常\",{\"1\":{\"1496\":1}}],[\"除非这个流被显示的设计成可以并发修改的\",{\"1\":{\"1496\":1}}],[\"除非内核为套接字分配的写缓冲区已经满了\",{\"1\":{\"739\":1}}],[\"除非有特殊需求\",{\"1\":{\"666\":1}}],[\"除非有什么办法能够逐个测量上面这些消耗\",{\"1\":{\"525\":1}}],[\"除非业务就是有一张静态表\",{\"1\":{\"456\":1}}],[\"除\",{\"1\":{\"467\":1}}],[\"除此之外\",{\"1\":{\"397\":1,\"484\":1,\"538\":1,\"696\":1,\"1471\":1,\"1847\":1,\"1852\":1}}],[\"除留余数法\",{\"1\":{\"332\":1}}],[\"除了增强某个类中的某个方法\",{\"1\":{\"1531\":1}}],[\"除了直接使用api的方式来生成代理对象\",{\"1\":{\"1531\":1}}],[\"除了上述的情况外\",{\"1\":{\"1529\":1}}],[\"除了上面追加中间操作的部分\",{\"1\":{\"1499\":1}}],[\"除了singleton和prototype\",{\"1\":{\"1524\":1}}],[\"除了spliterator涵盖的是一个无限元素的对象的情况\",{\"1\":{\"1497\":1}}],[\"除了可以通过beanpostprocessor来自定义spring创建bean的过程\",{\"1\":{\"1521\":1}}],[\"除了可以添加\",{\"1\":{\"619\":1}}],[\"除了ofint之外还有其他两种oflong\",{\"1\":{\"1497\":1}}],[\"除了以上非常核心的方法\",{\"1\":{\"1497\":1}}],[\"除了他还有一些原生的\",{\"1\":{\"1496\":1}}],[\"除了往集合中不断累加元素之外\",{\"1\":{\"1494\":1}}],[\"除了在collectors预先定义好的静态工厂方法可以创建一个收集器之外\",{\"1\":{\"1492\":1}}],[\"除了将他们再一次传递给accumulator\",{\"1\":{\"1492\":1}}],[\"除了将流转化为list\",{\"1\":{\"1486\":1}}],[\"除了无参构造\",{\"1\":{\"1483\":1}}],[\"除了通过这种方式创建实例外\",{\"1\":{\"1477\":1}}],[\"除了一个抽象方法accept\",{\"1\":{\"1471\":1}}],[\"除了抽象方法外还可以定义default\",{\"1\":{\"1471\":1}}],[\"除了等待没有其他方式\",{\"1\":{\"1393\":1}}],[\"除了java之外\",{\"1\":{\"1360\":1}}],[\"除了redis之外\",{\"1\":{\"738\":1}}],[\"除了基本的操作\",{\"1\":{\"720\":1}}],[\"除了传统的计算资源\",{\"1\":{\"670\":1}}],[\"除了bison外\",{\"1\":{\"650\":1}}],[\"除了显而易见的修改类语句外\",{\"1\":{\"634\":1}}],[\"除了误删数据的语句外\",{\"1\":{\"622\":1}}],[\"除了正常返回一个正整数m外\",{\"1\":{\"610\":1}}],[\"除了备库外\",{\"1\":{\"594\":1}}],[\"除了后台线程每秒一次的轮询操作外\",{\"1\":{\"588\":1}}],[\"除了物理上要有文件外\",{\"1\":{\"549\":1}}],[\"除了这些变化点\",{\"1\":{\"1565\":1}}],[\"除了这些常规的操作\",{\"1\":{\"1493\":1}}],[\"除了这两个特性看上去比较\",{\"1\":{\"546\":1}}],[\"除了这种做法\",{\"1\":{\"485\":1}}],[\"除了这种\",{\"1\":{\"386\":1}}],[\"除了会导致io压力大以外\",{\"1\":{\"543\":1}}],[\"除了访问这个数据页会触发merge外\",{\"1\":{\"480\":1}}],[\"除了考虑性能外\",{\"1\":{\"472\":1}}],[\"除了性能外\",{\"1\":{\"472\":1}}],[\"除了数据本身之外\",{\"1\":{\"468\":1}}],[\"除了all没有用到索引\",{\"1\":{\"467\":1}}],[\"除了第一列元素和最后一列元素都满足状态转移方程\",{\"1\":{\"426\":1}}],[\"除了前面的一对一的线性结构\",{\"1\":{\"337\":1}}],[\"除了最后一个\",{\"1\":{\"317\":1}}],[\"除了lock和synchronized\",{\"0\":{\"92\":1}}],[\"折叠法\",{\"1\":{\"332\":1}}],[\"平均分配轮询策略\",{\"0\":{\"1772\":1}}],[\"平均分配策略\",{\"0\":{\"1771\":1}}],[\"平均值等等\",{\"1\":{\"1493\":1}}],[\"平均值\",{\"1\":{\"1492\":1}}],[\"平均值和最大值\",{\"1\":{\"616\":1}}],[\"平均工作时间\",{\"1\":{\"1387\":1}}],[\"平均查询时间\",{\"1\":{\"566\":1}}],[\"平均返回记录数\",{\"1\":{\"566\":1}}],[\"平均锁定时间\",{\"1\":{\"566\":1}}],[\"平时没有注意删除历史数据\",{\"1\":{\"594\":1}}],[\"平时不会出现\",{\"1\":{\"467\":1}}],[\"平时项目里面表结构是如何进行设计的\",{\"0\":{\"171\":1}}],[\"平衡二叉树的查找\",{\"1\":{\"341\":1}}],[\"平衡二叉树的性质\",{\"1\":{\"341\":1}}],[\"平衡二叉树有时候也称为avl树\",{\"1\":{\"341\":1}}],[\"平衡二叉树是一种二叉排序树\",{\"1\":{\"341\":1}}],[\"平衡二叉树\",{\"0\":{\"341\":1,\"408\":1}}],[\"平法取中法\",{\"1\":{\"332\":1}}],[\"≠\",{\"1\":{\"332\":1,\"427\":1}}],[\"散列技术的记录之间不存在什么逻辑关系\",{\"1\":{\"332\":1}}],[\"散列技术即是一种存储方法\",{\"1\":{\"332\":1}}],[\"或是注解即可完成对数据库的查询以及结果的映射封装\",{\"1\":{\"1860\":1}}],[\"或其他\",{\"1\":{\"1541\":1}}],[\"或事务\",{\"1\":{\"1532\":1}}],[\"或别名获取某个bean对象\",{\"1\":{\"1513\":1}}],[\"或类型\",{\"1\":{\"1513\":1}}],[\"或服务端处理连接缓慢时\",{\"1\":{\"1450\":1}}],[\"或全部\",{\"1\":{\"1365\":1}}],[\"或未指定值\",{\"1\":{\"628\":1}}],[\"或简写为\",{\"1\":{\"619\":1}}],[\"或部分\",{\"1\":{\"532\":1}}],[\"或删掉误用的索引\",{\"1\":{\"485\":1}}],[\"或者刷了很多题目了\",{\"1\":{\"1850\":1}}],[\"或者判断某个方法上是否存在\",{\"1\":{\"1532\":1}}],[\"或者beandefinition\",{\"1\":{\"1527\":1}}],[\"或者只要一个构造方法的情况下\",{\"1\":{\"1527\":1}}],[\"或者执行一个终止操作\",{\"1\":{\"1498\":1}}],[\"或者spliterator是subsized的\",{\"1\":{\"1497\":1}}],[\"或者计算成本非常昂贵的时候\",{\"1\":{\"1497\":1}}],[\"或者对一个树\",{\"1\":{\"1497\":1}}],[\"或者对相同的元执行多次的遍历\",{\"1\":{\"1496\":1}}],[\"或者动作本身抛出了异常\",{\"1\":{\"1497\":1}}],[\"或者笫一次查询元素大小的时候绑定\",{\"1\":{\"1497\":1}}],[\"或者分割的不平衡或者效率非常低的方式\",{\"1\":{\"1497\":1}}],[\"或者parallel\",{\"1\":{\"1496\":1}}],[\"或者生成器函数\",{\"1\":{\"1496\":1}}],[\"或者foreach\",{\"1\":{\"1496\":1}}],[\"或者键映射为空\",{\"1\":{\"1495\":1}}],[\"或者数据源本身不要求有序\",{\"1\":{\"1492\":1}}],[\"或者数据库发生异常重启\",{\"1\":{\"547\":1}}],[\"或者返回一个函数作为返回值\",{\"1\":{\"1475\":1}}],[\"或者构造方法的引用来创建函数式接口的实例\",{\"1\":{\"1471\":1}}],[\"或者说只受限于本地内存的大小\",{\"1\":{\"1541\":1}}],[\"或者说\",{\"1\":{\"1487\":1}}],[\"或者说为什么需要函数式接口呢\",{\"1\":{\"1472\":1}}],[\"或者说表达式\",{\"1\":{\"1470\":1}}],[\"或者说对象的地址\",{\"1\":{\"1470\":1}}],[\"或者说是返回的map的key的类型\",{\"1\":{\"1495\":1}}],[\"或者说是一种语法糖\",{\"1\":{\"1469\":1}}],[\"或者说是否有存储的要求\",{\"1\":{\"1386\":1}}],[\"或者使用传统的for循环来遍历\",{\"1\":{\"1470\":1}}],[\"或者使用concurrenthashmap\",{\"1\":{\"1421\":1}}],[\"或者超时\",{\"1\":{\"1446\":1}}],[\"或者有except\",{\"1\":{\"1446\":1}}],[\"或者有其他考虑\",{\"1\":{\"522\":1}}],[\"或者默认值\",{\"1\":{\"1431\":1}}],[\"或者没必要执行这个操作\",{\"1\":{\"1408\":1}}],[\"或者cow\",{\"1\":{\"1404\":1}}],[\"或者是否正在扩容\",{\"1\":{\"1431\":1}}],[\"或者是队列空了无法移除元素时\",{\"1\":{\"1378\":1}}],[\"或者是不满足city=\",{\"1\":{\"493\":2}}],[\"或者比2更高的一个返回值\",{\"1\":{\"761\":1}}],[\"或者更新已存在成员的分数\",{\"1\":{\"711\":1}}],[\"或者尾部\",{\"1\":{\"708\":1}}],[\"或者最好是跨城市保存\",{\"1\":{\"625\":1}}],[\"或者误操作的时间距离上一个全量备份的时间较长\",{\"1\":{\"623\":1}}],[\"或者where条件里面没有包含索引字段的话\",{\"1\":{\"621\":1}}],[\"或者找一个从库作为临时库\",{\"1\":{\"621\":1}}],[\"或者连带造成了更多的数据逻辑不一致\",{\"1\":{\"596\":1}}],[\"或者kill掉这个长事务\",{\"1\":{\"578\":1}}],[\"或者断开连接\",{\"1\":{\"572\":1}}],[\"或者\",{\"1\":{\"514\":2,\"761\":1,\"1492\":1}}],[\"或者其它原因不能执行这个ddl\",{\"1\":{\"505\":1}}],[\"或者采用反过来的顺序\",{\"1\":{\"464\":1}}],[\"或者在一个语句有多表关联\",{\"1\":{\"458\":1,\"651\":2}}],[\"或者程序里面判断执行过一个占用内存的大查询后\",{\"1\":{\"455\":1}}],[\"或者每个结点的值都小于或等于其左右孩子结点的值\",{\"1\":{\"351\":1}}],[\"或\",{\"1\":{\"415\":2,\"487\":1}}],[\"或p=root\",{\"1\":{\"398\":1}}],[\"或没有孩子\",{\"1\":{\"347\":2,\"348\":1}}],[\"或三个孩子\",{\"1\":{\"347\":1}}],[\"或散列表\",{\"1\":{\"332\":1}}],[\"或所有查找区域无记录\",{\"1\":{\"304\":1}}],[\"这本书深入到jvm\",{\"1\":{\"1870\":1}}],[\"这本书是\",{\"1\":{\"1870\":1}}],[\"这本书是mysql领域的经典之作\",{\"1\":{\"1852\":1}}],[\"这本书实践性很强\",{\"1\":{\"1852\":1}}],[\"这本书\",{\"1\":{\"1849\":1}}],[\"这本书偏向实用\",{\"1\":{\"1847\":1}}],[\"这部分我们要学习的主流框架主要有\",{\"1\":{\"1857\":1}}],[\"这部分内容对于想要进好一点的公司的同学来说非常重要\",{\"1\":{\"1848\":1}}],[\"这部分可以先跳过\",{\"1\":{\"1847\":1}}],[\"这部分主要学习的内容有\",{\"1\":{\"1847\":1,\"1852\":1}}],[\"这部分数据的长度在32位和64位虚拟机中分别为32bit和64bit\",{\"1\":{\"1361\":1}}],[\"这可以强转的原因是如果参数是integer类型的\",{\"1\":{\"1497\":1}}],[\"这可以使用serial\",{\"1\":{\"1497\":1}}],[\"这可能是一个昂贵的操作\",{\"1\":{\"1495\":1}}],[\"这可能效率高\",{\"1\":{\"1492\":1}}],[\"这可能使得redis本身的速度变慢\",{\"1\":{\"737\":1}}],[\"这可能比随机的关联要更高效\",{\"1\":{\"531\":1}}],[\"这并不是绝对的\",{\"1\":{\"1496\":1}}],[\"这将导致\",{\"1\":{\"1494\":1}}],[\"这将返回这三表的全部数据列\",{\"1\":{\"521\":1}}],[\"这其实指的就是如果使用并行流\",{\"1\":{\"1499\":1}}],[\"这其实就是汇聚操作的整个过程\",{\"1\":{\"1492\":1}}],[\"这其中比较重要的是第二个tryadvance方法\",{\"1\":{\"1497\":1}}],[\"这其中最关键的地方在于\",{\"1\":{\"1475\":1}}],[\"这其中包含了大量为了检索数据到存储引擎的调用以及调用后的数据处理\",{\"1\":{\"518\":1}}],[\"这取决于accumulator和combiner消耗的成本和代价\",{\"1\":{\"1492\":1}}],[\"这取决于解决的实际问题\",{\"1\":{\"1489\":1}}],[\"这取决于排序所需要的内存和参数sort\",{\"1\":{\"491\":1}}],[\"这提示我们在使用流的使用后一定要注意编写的顺序和流的相关特性\",{\"1\":{\"1487\":1}}],[\"这实际上是一种比起tolist\",{\"1\":{\"1486\":1}}],[\"这实际上是jdk中的一个约定\",{\"1\":{\"1484\":1}}],[\"这几种创建stream的方式并没有什么区别\",{\"1\":{\"1484\":1}}],[\"这同一种实现\",{\"1\":{\"1472\":1}}],[\"这说明使用lambda表达式的这种方式与它所在的类是同一个作用域\",{\"1\":{\"1469\":1}}],[\"这说明在使用前缀索引的时候\",{\"1\":{\"487\":1}}],[\"这段代码会输出什么呢\",{\"1\":{\"1487\":1}}],[\"这段代码我们实际上需要的其实只有system\",{\"1\":{\"1468\":1}}],[\"这段文字的含义\",{\"1\":{\"1485\":1}}],[\"这段时间\",{\"1\":{\"601\":1}}],[\"这有助于编写出更为简洁\",{\"1\":{\"1468\":1}}],[\"这显然是不对的\",{\"1\":{\"1486\":1}}],[\"这显然是不行的\",{\"1\":{\"1475\":1}}],[\"这显然是不合适的\",{\"1\":{\"1450\":2,\"1484\":1}}],[\"这显然与\",{\"1\":{\"669\":1}}],[\"这块牌匾是不变的\",{\"1\":{\"1438\":1}}],[\"这儿是自旋\",{\"1\":{\"1431\":1}}],[\"这仅仅是为了保证序列化时的兼容性\",{\"1\":{\"1431\":1}}],[\"这与之前的面向对象的编程方式是完全不同的\",{\"1\":{\"1475\":1}}],[\"这与guard\",{\"1\":{\"1408\":1}}],[\"这与在一个关系型数据库实例\",{\"1\":{\"704\":1}}],[\"这项能力是它的核心能力\",{\"1\":{\"1395\":1}}],[\"这才是更重要的\",{\"1\":{\"1490\":1}}],[\"这才是重量级锁最大的开销\",{\"1\":{\"1362\":1}}],[\"这才会真正的唤醒生产者线程\",{\"1\":{\"1380\":1}}],[\"这意味着中间结果容器支持使用多线程进行并发访问\",{\"1\":{\"1494\":1}}],[\"这意味着\",{\"1\":{\"1491\":1,\"1492\":1}}],[\"这意味着加锁失败\",{\"1\":{\"1375\":1}}],[\"这意味着随着系统变大\",{\"1\":{\"1351\":1}}],[\"这意味着如果事务执行期间mysql发生异常重启\",{\"1\":{\"588\":1}}],[\"这不是一种推荐的方式\",{\"1\":{\"756\":1}}],[\"这主要是因为在mysql目前的实现中\",{\"1\":{\"694\":1}}],[\"这主要是由于mysql在可重复读的隔离级别下使用了mvcc机制\",{\"1\":{\"672\":1}}],[\"这主要是出于数据的一致性的考虑\",{\"1\":{\"629\":1}}],[\"这四种查询的效率比较\",{\"1\":{\"663\":1}}],[\"这四行数据是分三次申请的自增id\",{\"1\":{\"629\":1}}],[\"这会为后面我们能完整的看到流的整个调用顺序打下良好的基础\",{\"1\":{\"1490\":1}}],[\"这会与上面的代码得到相同的结果\",{\"1\":{\"1477\":1}}],[\"这会影响并发度\",{\"1\":{\"629\":1}}],[\"这会给mysql服务器带来额外的负担\",{\"1\":{\"519\":1}}],[\"这和数据传输可靠性有关\",{\"1\":{\"737\":1}}],[\"这和linux的kill命令类似\",{\"1\":{\"618\":1}}],[\"这和innodb的事务设计有关系\",{\"1\":{\"533\":1}}],[\"这类情况\",{\"1\":{\"618\":1}}],[\"这类请求就可以走从库\",{\"1\":{\"607\":1}}],[\"这类不会再修改的数据\",{\"1\":{\"470\":1}}],[\"这跟基于位点的主备协议不同\",{\"1\":{\"605\":1}}],[\"这跟事务的可见性规则并不矛盾\",{\"1\":{\"583\":1}}],[\"这句话的作用是\",{\"1\":{\"605\":1}}],[\"这一阶段的内容均以了解为主\",{\"1\":{\"1854\":1}}],[\"这一部分是整个函数式编程最核心的部分\",{\"1\":{\"1495\":1}}],[\"这一点在源代码中也有体现\",{\"1\":{\"1491\":1}}],[\"这一点\",{\"1\":{\"1488\":1,\"1489\":1}}],[\"这一点就保证了容器在扩容的时候并不会有其他的线程进行数据添加操作\",{\"1\":{\"1431\":1}}],[\"这一点对于我们实际书写连接查询语句时十分有用\",{\"1\":{\"692\":1}}],[\"这一步就会花比较长的时间\",{\"1\":{\"619\":1}}],[\"这一行统计的是redo\",{\"1\":{\"616\":1}}],[\"这一行\",{\"1\":{\"616\":2,\"1428\":1,\"1468\":1}}],[\"这一组全部执行完成后\",{\"1\":{\"601\":1}}],[\"这一个记录的值分别是1\",{\"1\":{\"571\":1}}],[\"这对于需要保持一致性的业务会有影响\",{\"1\":{\"764\":1}}],[\"这对于在线服务来说\",{\"1\":{\"581\":1}}],[\"这对于高性能来说是必不可少的\",{\"1\":{\"518\":1}}],[\"这往往是dba要求业务开发人员使用innodb替代myisam的原因之一\",{\"1\":{\"575\":1}}],[\"这正是因为myisam的表锁是在引擎层实现的\",{\"1\":{\"561\":1}}],[\"这么操作的前提是\",{\"1\":{\"604\":1}}],[\"这么以来\",{\"1\":{\"588\":1}}],[\"这么做实现了两个函数式接口的串联\",{\"1\":{\"1475\":1}}],[\"这么做可以在数组table的length比较小的时候\",{\"1\":{\"1425\":1}}],[\"这么做的理由是什么呢\",{\"1\":{\"1493\":1}}],[\"这么做的理由有很多\",{\"1\":{\"591\":1}}],[\"这么做的原因是\",{\"1\":{\"542\":1,\"621\":1}}],[\"这么做不如直接join\",{\"1\":{\"538\":1}}],[\"这么写的原因是极端情况下left\",{\"1\":{\"440\":1}}],[\"这在多处理系统中的cpu尤其如此\",{\"1\":{\"1351\":1}}],[\"这在mysql服务器层完成\",{\"1\":{\"527\":1}}],[\"这在一定程度上能够说明该查询找到需要的数据的效率高不高\",{\"1\":{\"526\":1}}],[\"这通常意味着访问了太多的行\",{\"1\":{\"518\":1}}],[\"这再次触发了本节开始时提到的原则\",{\"1\":{\"505\":1}}],[\"这条指令完成了整个\",{\"1\":{\"1356\":1}}],[\"这条update语句执行后生成的数据版本上的trx\",{\"1\":{\"634\":1}}],[\"这条记录\",{\"1\":{\"628\":1}}],[\"这条命令逻辑错误\",{\"1\":{\"717\":1}}],[\"这条命令的逻辑是\",{\"1\":{\"611\":1}}],[\"这条命令有6个参数\",{\"1\":{\"604\":1}}],[\"这条insert语句\",{\"1\":{\"562\":1}}],[\"这条查询语句在索引a上是一个范围查询\",{\"1\":{\"541\":1}}],[\"这条语句不像第一个例子的update语句一样退出呢\",{\"1\":{\"618\":1}}],[\"这条语句已经不需要继续执行了\",{\"1\":{\"618\":1}}],[\"这条语句在实例y上的gtid是\",{\"1\":{\"605\":1}}],[\"这条语句的执行就会报错\",{\"1\":{\"621\":1}}],[\"这条语句的执行流程如下\",{\"1\":{\"557\":1,\"628\":1}}],[\"这条语句的执行结果如下\",{\"1\":{\"553\":1}}],[\"这条语句的explain的结果如下\",{\"1\":{\"503\":1}}],[\"这条语句用到了union\",{\"1\":{\"551\":1}}],[\"这条语句会执行得越来越慢\",{\"1\":{\"532\":1}}],[\"这条语句触发了我们之前说到的过规则\",{\"1\":{\"504\":1}}],[\"这条语句需要走全表扫描\",{\"1\":{\"504\":1}}],[\"这条更新语句做了如下操作\",{\"1\":{\"482\":1}}],[\"这条更新语句\",{\"1\":{\"482\":1}}],[\"这体现了mysql的一个设计理念\",{\"1\":{\"493\":1}}],[\"这次我们顺利的打印出了stream对象\",{\"1\":{\"1487\":1}}],[\"这次我们使用另一种写法来完成这个功能\",{\"1\":{\"1481\":1}}],[\"这次的查询操作用上了被驱动表tradelog里的索引\",{\"1\":{\"505\":1}}],[\"这次值取对了\",{\"1\":{\"487\":1}}],[\"这次优化器选择了索引b\",{\"1\":{\"484\":1}}],[\"这行记录丢弃\",{\"1\":{\"487\":1}}],[\"这三种状态分别是\",{\"1\":{\"588\":1}}],[\"这三行的结果\",{\"1\":{\"584\":1}}],[\"这三个方法是java中管程技术的组成部分\",{\"1\":{\"1360\":1}}],[\"这三个字符\",{\"1\":{\"761\":1}}],[\"这三个区间\",{\"1\":{\"673\":1}}],[\"这三个指标都会记录到mysql的慢日志中\",{\"1\":{\"524\":1}}],[\"这三个索引的基数值并不同\",{\"1\":{\"484\":1}}],[\"这三条sql语句执行完成后的慢查询日志如下\",{\"1\":{\"483\":1}}],[\"这两表都位于mysql系统数据库下面\",{\"1\":{\"695\":1}}],[\"这两行数据\",{\"1\":{\"596\":1}}],[\"这两行记录分别落在p\",{\"1\":{\"561\":1}}],[\"这两种写法完全是等价的\",{\"1\":{\"1494\":1}}],[\"这两种写法的运行结果完全是等价的\",{\"1\":{\"1472\":1}}],[\"这两种累加的结果是等价的\",{\"1\":{\"1492\":1}}],[\"这两种方式的效果完全等价\",{\"1\":{\"1480\":1}}],[\"这两种方式也是没有差别的\",{\"1\":{\"561\":1}}],[\"这两种方案\",{\"1\":{\"1405\":1}}],[\"这两种机制各有优缺点\",{\"1\":{\"1351\":1}}],[\"这两种执行方法的逻辑是一样的\",{\"1\":{\"651\":1}}],[\"这两种执行方法的逻辑结果是一样的\",{\"1\":{\"458\":1}}],[\"这两种情况都会影响buffer\",{\"1\":{\"543\":1}}],[\"这两张表都有一个主键索引id和一个索引a\",{\"1\":{\"537\":1}}],[\"这两个filter是spring扫描过程中用来过滤的\",{\"1\":{\"1522\":1}}],[\"这两个缺点都会影响任务的执行效率\",{\"1\":{\"1387\":1}}],[\"这两个成本常数是我们最常用到的\",{\"1\":{\"682\":1}}],[\"这两个方案都要求备份系统定期备份全量日志\",{\"1\":{\"622\":1}}],[\"这两个方案的共同点是\",{\"1\":{\"622\":1}}],[\"这两个参数\",{\"1\":{\"602\":1}}],[\"这两个参数用于故意拉长binlog从write到fsync的时间\",{\"1\":{\"602\":1}}],[\"这两个事务要更新的行的主键值不同\",{\"1\":{\"599\":1}}],[\"这两个条件是或的关系\",{\"1\":{\"588\":1}}],[\"这两个记录之间的间隙是会被锁住的\",{\"1\":{\"561\":1}}],[\"这两个create\",{\"1\":{\"550\":1}}],[\"这两个在email字段上创建索引的语句\",{\"1\":{\"487\":1}}],[\"这两个索引\",{\"1\":{\"476\":1}}],[\"这两类索引在查询能力上没有差别\",{\"1\":{\"481\":1}}],[\"这已经17亿了\",{\"1\":{\"471\":1}}],[\"这棵树高是4的时候\",{\"1\":{\"471\":1}}],[\"这时当前线程就可以避免阻塞\",{\"1\":{\"1362\":1}}],[\"这时这个脚本应该通过邮件\",{\"1\":{\"761\":1}}],[\"这时因为在执行show\",{\"1\":{\"618\":1}}],[\"这时我们就可以使用kill\",{\"1\":{\"617\":1}}],[\"这时返回的结果如下\",{\"1\":{\"553\":1}}],[\"这时的内存临时表大小不够存下这100行数据\",{\"1\":{\"553\":1}}],[\"这时存储引擎层完成的\",{\"1\":{\"527\":1}}],[\"这时\",{\"1\":{\"480\":1,\"484\":2,\"493\":1,\"542\":1,\"548\":1,\"605\":3,\"609\":2,\"611\":1,\"622\":1,\"628\":1,\"629\":1}}],[\"这时也可以用上这个索引\",{\"1\":{\"476\":1}}],[\"这时只需要查id的值\",{\"1\":{\"475\":1}}],[\"这时候用户进程再调用read操作\",{\"1\":{\"1442\":1}}],[\"这时候操作系统自己同步数据\",{\"1\":{\"729\":1}}],[\"这时候就关系到存储对象的序列化问题\",{\"1\":{\"720\":1}}],[\"这时候系统其实已经不正常了\",{\"1\":{\"613\":1}}],[\"这时候innodb不能响应任何请求\",{\"1\":{\"613\":1}}],[\"这时候id=1的行的a的值还是1\",{\"1\":{\"599\":1}}],[\"这时候哈希表就要记录100万个项\",{\"1\":{\"599\":1}}],[\"这时候主库a掉电了\",{\"1\":{\"596\":1}}],[\"这时候需要借助mysqlbinlog工具\",{\"1\":{\"591\":1}}],[\"这时候需要申请一个新的数据页\",{\"1\":{\"472\":1}}],[\"这时候备库会启动两个线程\",{\"1\":{\"590\":1}}],[\"这时候客户端读写访问的都是节点b\",{\"1\":{\"590\":1}}],[\"这时候trx2和trx3就可以直接返回了\",{\"1\":{\"588\":1}}],[\"这时候lsn也变成了160\",{\"1\":{\"588\":1}}],[\"这时候会对表t加上一个mdl读锁\",{\"1\":{\"578\":1}}],[\"这时候事务b虽然还没有提交\",{\"1\":{\"570\":1}}],[\"这时候c2已经不用排序了\",{\"1\":{\"515\":1}}],[\"这时候\",{\"1\":{\"483\":1,\"488\":1,\"505\":1,\"581\":1,\"588\":1,\"613\":1,\"618\":3,\"619\":1}}],[\"这时候我们就需要优先考虑上一段提到的\",{\"1\":{\"472\":1}}],[\"这时候如果对身份证号长度为6的前缀索引的话\",{\"1\":{\"489\":1}}],[\"这时候如果要查询id\",{\"1\":{\"470\":1}}],[\"这时候如果你要继续\",{\"1\":{\"455\":1}}],[\"这时对应的哈希索引的示意图如下所示\",{\"1\":{\"469\":1}}],[\"这种结果用ored值来表示的\",{\"1\":{\"1497\":1}}],[\"这种修改就会在分割迭代器遍历的时候反映出来\",{\"1\":{\"1497\":1}}],[\"这种修改并不是通用的优化手段\",{\"1\":{\"485\":1}}],[\"这种执行模式的选择\",{\"1\":{\"1496\":1}}],[\"这种执行方式只是流里面的一个属性而已\",{\"1\":{\"1496\":1}}],[\"这种设置确保了可以适当的释放一些资源\",{\"1\":{\"1496\":1}}],[\"这种调用的机制被声明在资源的规范的头里面\",{\"1\":{\"1496\":1}}],[\"这种场景下\",{\"1\":{\"1481\":1}}],[\"这种场景只会存在于理论中\",{\"1\":{\"633\":1}}],[\"这种一请求一应答的通信模型简化了上层开发\",{\"1\":{\"1449\":1}}],[\"这种内存消耗已经渐渐可以接受了\",{\"1\":{\"1404\":1}}],[\"这种解决并发问题的设计模式被称为不变性模式\",{\"1\":{\"1403\":1}}],[\"这种隔离性能避免几个特别耗时的任务拖垮整个应用的风险\",{\"1\":{\"1394\":1}}],[\"这种集群模式下\",{\"1\":{\"1394\":1}}],[\"这种任务的特点是并不会特别消耗cpu资源\",{\"1\":{\"1387\":1}}],[\"这种模式会将所有的命令都记录下来\",{\"1\":{\"728\":1}}],[\"这种模式下一般会把数据库的连接信息放在客户端的连接层\",{\"1\":{\"606\":1}}],[\"这种工作方式使得\",{\"1\":{\"725\":1}}],[\"这种统计数据存储在内存中\",{\"1\":{\"695\":1}}],[\"这种统计数据存储在磁盘上\",{\"1\":{\"695\":1}}],[\"这种格式处理起来不太方便\",{\"1\":{\"666\":1}}],[\"这种申请自增id的策略\",{\"1\":{\"629\":1}}],[\"这种做法也存在一个问题\",{\"1\":{\"614\":1}}],[\"这种做法可行吗\",{\"1\":{\"591\":1}}],[\"这种直接跳过指定错误的方法\",{\"1\":{\"604\":1}}],[\"这种策略与按行分发的策略比较类似\",{\"1\":{\"602\":1}}],[\"这种策略的并行效果\",{\"1\":{\"600\":1}}],[\"这种\",{\"1\":{\"594\":1}}],[\"这种语句只需要访问一个分表\",{\"1\":{\"548\":1}}],[\"这种分库分表系统都有一个中间层proxy\",{\"1\":{\"548\":1}}],[\"这种表的数据都保存在内存里\",{\"1\":{\"546\":1}}],[\"这种情况只会走name字段索引\",{\"1\":{\"655\":1}}],[\"这种情况一般业务都是不可接受的\",{\"1\":{\"595\":1}}],[\"这种情况\",{\"1\":{\"594\":1,\"629\":1}}],[\"这种情况就需要mdl\",{\"1\":{\"578\":1}}],[\"这种情况更为常见\",{\"1\":{\"540\":1}}],[\"这种情况下是无法检测到被重用的\",{\"1\":{\"1496\":1}}],[\"这种情况下我们认为事务t和worker是冲突的\",{\"1\":{\"598\":1}}],[\"这种情况下\",{\"1\":{\"476\":1,\"548\":1,\"596\":1,\"622\":1,\"623\":1,\"1525\":1}}],[\"这种算法就被称为\",{\"1\":{\"539\":1}}],[\"这种方法在解决不可变对象的修改问题时经常用到\",{\"1\":{\"1404\":1}}],[\"这种方法\",{\"1\":{\"1388\":1}}],[\"这种方法并不适用\",{\"1\":{\"485\":1}}],[\"这种方式的弊端在于\",{\"1\":{\"1484\":1}}],[\"这种方式的优势是处理速度快\",{\"1\":{\"548\":1}}],[\"这种方式的缺点就在于\",{\"1\":{\"534\":1}}],[\"这种方式地效率很低\",{\"1\":{\"533\":1}}],[\"这种业务模型常见的就是账单类\",{\"1\":{\"481\":1}}],[\"这种存储方式的表称为索引组织表\",{\"1\":{\"472\":1}}],[\"这种数据结构就是索引\",{\"1\":{\"468\":1}}],[\"这种范围扫描索引比全表扫描要好\",{\"1\":{\"467\":1}}],[\"这种现象我们称为冲突\",{\"1\":{\"332\":1}}],[\"这些也是面试的必考点\",{\"1\":{\"1870\":1}}],[\"这些都可以称之为类的元数据\",{\"1\":{\"1523\":1}}],[\"这些都是对于这几个基础的函数式接口的有力的补充\",{\"1\":{\"1478\":1}}],[\"这些都是共用的东西\",{\"1\":{\"806\":1}}],[\"这些都是当前读\",{\"1\":{\"678\":1}}],[\"这些参数就会使用包装类型\",{\"1\":{\"1497\":1}}],[\"这些参数总是一个函数式接口的实例\",{\"1\":{\"1496\":1}}],[\"这些可以被spliterator的客户端使用\",{\"1\":{\"1497\":1}}],[\"这些要求确保了由stream和parallelstream方法生成的流从终止流操作开始发起的时候就反应出流的内容\",{\"1\":{\"1497\":1}}],[\"这些特性值并不要求去报告\",{\"1\":{\"1497\":1}}],[\"这些行为参数都要满足下面的这些条件特性\",{\"1\":{\"1496\":1}}],[\"这些操作会被聚合起来应用到他们的元上面\",{\"1\":{\"1496\":1}}],[\"这些对象的线程安全性都是靠不可变性来保证的\",{\"1\":{\"1403\":1}}],[\"这些子任务将由forkjoinpool内部的工作线程来并行执行\",{\"1\":{\"1387\":1}}],[\"这些java内置的使用者看不到的锁被称为内置锁\",{\"1\":{\"1359\":1}}],[\"这些请求都会击穿到db\",{\"1\":{\"766\":1}}],[\"这些微调的值是直接硬编码到代码里的\",{\"1\":{\"685\":1}}],[\"这些信息是恢复不出来数据的\",{\"1\":{\"622\":1}}],[\"这些信息可以用来精确定位刚刚被插入的那一行\",{\"1\":{\"591\":1}}],[\"这些数据最终存储在多个本地缓存中\",{\"1\":{\"1351\":1}}],[\"这些数据会恢复回来\",{\"1\":{\"596\":1}}],[\"这些数据结构以某种方式指向数据\",{\"1\":{\"468\":1}}],[\"这些redo\",{\"1\":{\"588\":1}}],[\"这些不同的方式按照效率排序\",{\"1\":{\"536\":1}}],[\"这些调用需要在内存操作\",{\"1\":{\"518\":1}}],[\"这些接口都是引擎中已经定义好的\",{\"1\":{\"459\":1}}],[\"这些资源会在连接断开的时候才释放\",{\"1\":{\"455\":1}}],[\"这样比较老的技术\",{\"1\":{\"1856\":1}}],[\"这样便可以防止核心api库被随意篡改\",{\"1\":{\"1540\":1}}],[\"这样产生的bean不会经过spring的生命周期步骤\",{\"1\":{\"1521\":1}}],[\"这样调用完之后就可以重用了\",{\"1\":{\"1500\":1}}],[\"这样并行计算的时候工作量是比较平均的\",{\"1\":{\"1497\":1}}],[\"这样先放一个索引上的元素会被放到entry链的尾部\",{\"1\":{\"1427\":1}}],[\"这样以后就不会扩容了\",{\"1\":{\"1427\":1}}],[\"这样部分可能大量访问的数据就会加载到缓存中\",{\"1\":{\"770\":1}}],[\"这样所有连接redis实例的客户端都要提供密码\",{\"1\":{\"761\":1}}],[\"这样从节点就可以起到两个作用\",{\"1\":{\"758\":1}}],[\"这样执行以后从机会独立出来成为一个主机\",{\"1\":{\"748\":1}}],[\"这样执行的时候\",{\"1\":{\"551\":1}}],[\"这样使用起来代码效率低下\",{\"1\":{\"721\":1}}],[\"这样设置以后你能get到的值是\",{\"1\":{\"715\":1}}],[\"这样一台挂掉之后其他的还可以继续工作\",{\"1\":{\"770\":1}}],[\"这样一旦开发出更优秀的内部编码\",{\"1\":{\"706\":1}}],[\"这样一来\",{\"1\":{\"489\":1,\"720\":1}}],[\"这样redis会在合适的场景选择合适的内部编码\",{\"1\":{\"706\":1}}],[\"这样其他session只能读这行数据\",{\"1\":{\"674\":1}}],[\"这样排序后就会直接从内存里返回查询结果了\",{\"1\":{\"657\":1}}],[\"这样排序后就会直接从内存里面返回查询结果了\",{\"1\":{\"493\":1}}],[\"这样写到数据表中只放了最后6个字节\",{\"1\":{\"632\":1}}],[\"这样写数据成本相对较高\",{\"1\":{\"472\":1}}],[\"这样依赖\",{\"1\":{\"621\":1}}],[\"这样线程1不能提交事务\",{\"1\":{\"613\":1}}],[\"这样等gtid的方案就可以减少一次查询\",{\"1\":{\"611\":1}}],[\"这样带来的问题是\",{\"1\":{\"610\":1}}],[\"这样被加入从库的gtid集合的\",{\"1\":{\"605\":1}}],[\"这样中间碰到这两个错误时就直接跳过\",{\"1\":{\"604\":1}}],[\"这样得到的$master\",{\"1\":{\"604\":1}}],[\"这样系统的吞吐量就不够\",{\"1\":{\"601\":1}}],[\"这样需要特地异动数据\",{\"1\":{\"600\":1}}],[\"这样冲突检测就不准备\",{\"1\":{\"599\":1}}],[\"这样corrdinator会发现跟事务t冲突的worker只有worker\",{\"1\":{\"598\":1}}],[\"这样binlog传到备库去的时候\",{\"1\":{\"591\":1}}],[\"这样也可以减少iops的消耗\",{\"1\":{\"588\":1}}],[\"这样也可以将服务器上原本一次性的压力分散到一个很长的时间段中\",{\"1\":{\"530\":1}}],[\"这样看起来\",{\"1\":{\"584\":1,\"1472\":1}}],[\"这样每次冲突概率变成原来的1\",{\"1\":{\"581\":1}}],[\"这样每次要给影院账户加金额的时候\",{\"1\":{\"581\":1}}],[\"这样在未达到最大线程数的时候\",{\"1\":{\"1567\":1}}],[\"这样在并发的情况下\",{\"1\":{\"1492\":1}}],[\"这样在使用java8的好处也仅仅停留在jvm带来的性能上的提升\",{\"1\":{\"1468\":1}}],[\"这样在用户空间和内核空间的copy只需要一次\",{\"1\":{\"1448\":1}}],[\"这样在备库执行的时候\",{\"1\":{\"602\":1}}],[\"这样在切换的时候就不用再修改主备关系\",{\"1\":{\"592\":1}}],[\"这样在innodb内部就不会有大量的死锁检测工作了\",{\"1\":{\"581\":1}}],[\"这样在排序过程中一次可以排序更多行\",{\"1\":{\"493\":1}}],[\"这样当出现死锁的时候\",{\"1\":{\"581\":1}}],[\"这样可以不关心修改过几次\",{\"1\":{\"1356\":1}}],[\"这样可以基于一个socket连接同时发送多个dubbo请求\",{\"1\":{\"798\":1}}],[\"这样可以极大的减少需要分析的连接顺序的数量\",{\"1\":{\"693\":1}}],[\"这样可以保持节点b和a的数据是相同的\",{\"1\":{\"590\":1}}],[\"这样可以最大程度减少事务之间的锁等待\",{\"1\":{\"580\":1}}],[\"这样可能要扫描被驱动表很多次\",{\"1\":{\"540\":1}}],[\"这样会把这些类全部加载进jvm\",{\"1\":{\"1523\":1}}],[\"这样会导致整库长时间处于不可写状态\",{\"1\":{\"575\":1}}],[\"这样会影响我们分析sql语句的执行过程\",{\"1\":{\"538\":1}}],[\"这样既省去了再次执行begin语句的开销\",{\"1\":{\"572\":1}}],[\"这样返回结果里有100行数据\",{\"1\":{\"553\":1}}],[\"这样只需要100万次的哈希查找\",{\"1\":{\"545\":1}}],[\"这样\",{\"1\":{\"543\":1,\"548\":1,\"549\":1,\"550\":1,\"554\":1,\"584\":1,\"585\":1,\"601\":1,\"605\":2,\"608\":1,\"609\":1,\"616\":1,\"622\":2,\"634\":1,\"1379\":1,\"1484\":1}}],[\"这样对锁的要求就十分高\",{\"1\":{\"767\":1}}],[\"这样对后端维护团队的要求会更高\",{\"1\":{\"606\":1}}],[\"这样对于id=0这一行\",{\"1\":{\"584\":1}}],[\"这样对于默认的sql语句都不使用查询缓存\",{\"1\":{\"456\":1}}],[\"这样对buffer\",{\"1\":{\"543\":1}}],[\"这样通过排序以后\",{\"1\":{\"541\":1}}],[\"这样优化器只会按照我们指定的方式去join\",{\"1\":{\"538\":1}}],[\"这样的模板引擎所替代\",{\"1\":{\"1856\":1}}],[\"这样的代码我们应该已经掌握的非常的熟练了\",{\"1\":{\"1492\":1}}],[\"这样的一个参数\",{\"1\":{\"1470\":1}}],[\"这样的数字\",{\"1\":{\"695\":1}}],[\"这样的优化策略并不实用\",{\"1\":{\"659\":1}}],[\"这样的话在工作队列中等待的任务就会减少\",{\"1\":{\"1387\":1}}],[\"这样的话就得到了一个最多只需要追加1个小时\",{\"1\":{\"623\":1}}],[\"这样的话\",{\"1\":{\"607\":1,\"1379\":1}}],[\"这样的操作\",{\"1\":{\"533\":1}}],[\"这样的场景有很多\",{\"1\":{\"531\":1}}],[\"这样的重构可能会减少网络和内存的消耗\",{\"1\":{\"531\":1}}],[\"这样做有一个缺陷\",{\"1\":{\"764\":1}}],[\"这样做性能损耗很大\",{\"1\":{\"690\":1}}],[\"这样做可以减少事务视图里面活跃事务数组的大小\",{\"1\":{\"634\":1}}],[\"这样做可以保证日志传到备库去执行的时候\",{\"1\":{\"591\":1}}],[\"这样做也可以用上并行复制技术\",{\"1\":{\"622\":1}}],[\"这样做\",{\"1\":{\"590\":1,\"591\":1,\"629\":1}}],[\"这样做相当于在应用中实现了哈希关联\",{\"1\":{\"531\":1}}],[\"这样做的好处是使用者无需关心内部转换细节\",{\"1\":{\"1517\":1}}],[\"这样做的好处是元素的分布会相对来说比较均匀\",{\"1\":{\"1425\":1}}],[\"这样做的好处是增加新的user时速度会很快\",{\"1\":{\"469\":1}}],[\"这样做的目的\",{\"1\":{\"624\":1}}],[\"这样做的目的是为了避免大对象分配内存时的复制操作而降低效率\",{\"1\":{\"1546\":1}}],[\"这样做的目的是为了保证数据的可见性\",{\"1\":{\"1375\":1}}],[\"这样做的目的是\",{\"1\":{\"624\":1}}],[\"这样做的结果就是\",{\"1\":{\"594\":1}}],[\"这样做的风险时\",{\"1\":{\"588\":1}}],[\"这样做的风险是\",{\"1\":{\"588\":1}}],[\"这样做的逻辑在于以前总是认为网络通信\",{\"1\":{\"529\":1}}],[\"这样存储引擎无需回表获取对应行就可以返回结果了\",{\"1\":{\"527\":1}}],[\"这样性能显然会更好\",{\"1\":{\"523\":1}}],[\"这样主动把l\",{\"1\":{\"505\":1}}],[\"这样整个查询语句的执行流程就变成了\",{\"1\":{\"493\":1}}],[\"这样整个查询过程的流程就变成了\",{\"1\":{\"493\":1}}],[\"这样内存里能够同时放下的行数就很少\",{\"1\":{\"492\":1}}],[\"这样随机访问io的次数不会减少\",{\"1\":{\"481\":1}}],[\"这样就有可能影响了性能上的优势\",{\"1\":{\"1497\":1}}],[\"这样就有128个线程处于等待状态\",{\"1\":{\"613\":1}}],[\"这样就保证了数据的安全性\",{\"1\":{\"1430\":1}}],[\"这样就实现了具体任务与执行任务类之间的结偶\",{\"1\":{\"1378\":1}}],[\"这样就不会出现热点数据过期的情况\",{\"1\":{\"767\":1}}],[\"这样就不需要从磁盘中读入这个数据页了\",{\"1\":{\"480\":1}}],[\"这样就达到了我们的预期\",{\"1\":{\"605\":1}}],[\"这样就增加了备库复制的并行度\",{\"1\":{\"602\":1}}],[\"这样就都是前开后闭区间了\",{\"1\":{\"585\":1}}],[\"这样就确保了无法再插入新的记录\",{\"1\":{\"585\":1}}],[\"这样就跳过了最后排序的阶段\",{\"1\":{\"553\":1}}],[\"这样就没有字符集转换问题了\",{\"1\":{\"505\":1}}],[\"这样就可以把访问被驱动表的成本见到更低了\",{\"1\":{\"692\":1}}],[\"这样就可以使用ref访问方法来降低访问被驱动表的成本了\",{\"1\":{\"692\":1}}],[\"这样就可以保证主\",{\"1\":{\"615\":1}}],[\"这样就可以用上被驱动表的tradeid索引了\",{\"1\":{\"505\":1}}],[\"这样就可以在这些数据结构的基础上实现高级查找算法\",{\"1\":{\"468\":1}}],[\"这样如果要查询id\",{\"1\":{\"471\":1}}],[\"这样临时库就跟误删之前的线上库一样了\",{\"1\":{\"464\":1}}],[\"这样我们就不需要针对于原生类型的特化版本\",{\"1\":{\"1500\":1}}],[\"这样我们就在控制台打印了3到7\",{\"1\":{\"1484\":1}}],[\"这样我们就可以得到一个json格式的执行计划\",{\"1\":{\"690\":1}}],[\"这样我们就得到了网格dfs遍历的框架代码\",{\"1\":{\"435\":1}}],[\"这样我们可以通过查找关键字而不需要比较就可以获取需要的记录的存储位置\",{\"1\":{\"332\":1}}],[\"这是项目使用到的相关技术\",{\"1\":{\"1865\":1}}],[\"这是正常现象\",{\"1\":{\"1850\":1}}],[\"这是非常昂贵的操作\",{\"1\":{\"1541\":1}}],[\"这是流管道中的一个操作\",{\"1\":{\"1500\":1}}],[\"这是流的终止操作\",{\"1\":{\"1496\":1}}],[\"这是我们了解整个流调用机制的最后一个类\",{\"1\":{\"1499\":1}}],[\"这是为什么呢\",{\"1\":{\"1487\":1}}],[\"这是为了减少锁的次数\",{\"1\":{\"1380\":1}}],[\"这是当使用bifunction运算对象与结果类型相同时候的一个特例\",{\"1\":{\"1478\":1}}],[\"这是从jdk1\",{\"1\":{\"1476\":1}}],[\"这是与非函数式编程最大的区别\",{\"1\":{\"1475\":1}}],[\"这是与hashmap有区别的地方\",{\"1\":{\"1431\":1}}],[\"这是最传统的io模型\",{\"1\":{\"1440\":1}}],[\"这是最好的联接类型\",{\"1\":{\"467\":1}}],[\"这是一本不错的\",{\"1\":{\"1870\":1}}],[\"这是一本图文并茂的书籍\",{\"1\":{\"1870\":1}}],[\"这是一种最简单的并发处理网络请求的方法\",{\"1\":{\"1410\":1}}],[\"这是一些基本的配置属性\",{\"1\":{\"720\":1}}],[\"这是一条语法错误命令\",{\"1\":{\"717\":1}}],[\"这是一个执行流管道的辅助类\",{\"1\":{\"1500\":1}}],[\"这是一个终止操作\",{\"1\":{\"1500\":1}}],[\"这是一个工厂\",{\"1\":{\"1500\":1}}],[\"这是一个针对原生值设定的spliterator\",{\"1\":{\"1497\":1}}],[\"这是一个通过递归解耦得到的自然的结果\",{\"1\":{\"1497\":1}}],[\"这是一个中间操作\",{\"1\":{\"1496\":3}}],[\"这是一个关闭之前可能持有一些资源\",{\"1\":{\"1496\":1}}],[\"这是一个相对比较复杂的例子\",{\"1\":{\"1495\":1}}],[\"这是一个可选的操作\",{\"1\":{\"1492\":1}}],[\"这是一个函数式接口\",{\"1\":{\"1474\":1}}],[\"这是一个时间复杂度是o\",{\"1\":{\"581\":1}}],[\"这是一个多指查询\",{\"1\":{\"541\":1}}],[\"这是一个常量\",{\"1\":{\"515\":1}}],[\"这是一个需要权衡的决定\",{\"1\":{\"493\":1}}],[\"这是一个查询语句\",{\"1\":{\"457\":1}}],[\"这是kill无效的第一类情况\",{\"1\":{\"618\":1}}],[\"这是由于在主库上\",{\"1\":{\"597\":1}}],[\"这是由于tradeid字段类型是varchar\",{\"1\":{\"504\":1}}],[\"这是\",{\"1\":{\"591\":1,\"625\":1}}],[\"这是mysql根据当前要操作的表所在的数据库自行添加的\",{\"1\":{\"591\":1}}],[\"这是mysql中两个核心概念\",{\"1\":{\"460\":1}}],[\"这是rr隔离级别用的最多的锁\",{\"1\":{\"579\":1}}],[\"这是1个表\",{\"1\":{\"561\":1}}],[\"这是4个表\",{\"1\":{\"561\":2}}],[\"这是在mysql服务器层完成的\",{\"1\":{\"527\":1}}],[\"这是属于全值匹配的情况\",{\"1\":{\"507\":1,\"509\":1}}],[\"这是因为需要将stringbuilder转为string类型\",{\"1\":{\"1495\":1}}],[\"这是因为设置了concurrent特性\",{\"1\":{\"1494\":1}}],[\"这是因为调用顺序的原因\",{\"1\":{\"1492\":1}}],[\"这是因为stream也是属于一种描述性的语句\",{\"1\":{\"1488\":1}}],[\"这是因为我们限制了只取流中的前六个元素\",{\"1\":{\"1487\":1}}],[\"这是因为我们不需要创建一个独立的io线程来处理读写操作\",{\"1\":{\"1452\":1}}],[\"这是因为前面在不断的迭代产生0\",{\"1\":{\"1487\":1}}],[\"这是因为iterate他是无限的\",{\"1\":{\"1486\":1}}],[\"这是因为对驱动表s1结果集中的每一条记录\",{\"1\":{\"692\":1}}],[\"这是因为此时的参数设置binlog\",{\"1\":{\"591\":1}}],[\"这是因为delete带limit\",{\"1\":{\"591\":1}}],[\"这是因为mysql设计了一个唯一数组的逻辑\",{\"1\":{\"635\":1}}],[\"这是因为mysql中使用了组提交\",{\"1\":{\"588\":1}}],[\"这是因为mysql在执行过程中临时使用的内存是管理在连接对象里面的\",{\"1\":{\"455\":1}}],[\"这是因为\",{\"1\":{\"550\":1,\"619\":1,\"622\":1,\"634\":1,\"1494\":1}}],[\"这是因为即使在同一个时刻的多个查询\",{\"1\":{\"533\":1}}],[\"这是因为这两张表的字符集不同导致的\",{\"1\":{\"505\":1}}],[\"这是因为如果使用的是innodb引擎的话\",{\"1\":{\"491\":1}}],[\"这是const类型的特例\",{\"1\":{\"467\":1}}],[\"这是模拟递归的调用\",{\"1\":{\"395\":1}}],[\"这也验证了我们之前的说法\",{\"1\":{\"1477\":1}}],[\"这也保证了容器的安全性\",{\"1\":{\"1431\":1}}],[\"这也就意味着生产者和消费者无法并行操作\",{\"1\":{\"1379\":1}}],[\"这也就意味着\",{\"1\":{\"1378\":1}}],[\"这也就是很多文章中建议不要使用长事务的原因之一\",{\"1\":{\"571\":1}}],[\"这也就是排序模式里面\",{\"1\":{\"557\":1}}],[\"这也就是说直接执行语句的结果可能是错误的\",{\"1\":{\"591\":1}}],[\"这也就是说\",{\"1\":{\"454\":1,\"1492\":1}}],[\"这也正是\",{\"1\":{\"1356\":1}}],[\"这也导致出现了自增id不连续的情况\",{\"1\":{\"629\":1}}],[\"这也体现出了这个算法名字中\",{\"1\":{\"540\":1}}],[\"这也是循环依赖的一种情况\",{\"1\":{\"1524\":1}}],[\"这也是一种可变操作\",{\"1\":{\"1492\":1}}],[\"这也是使用内部迭代给我们带来的另一个好处\",{\"1\":{\"1489\":1}}],[\"这也是流的另一个重要的特性\",{\"1\":{\"1487\":1}}],[\"这也是流式编程给我们带来的好处\",{\"1\":{\"1485\":1}}],[\"这也是面向对象带来限制\",{\"1\":{\"1484\":1}}],[\"这也是新增加的comparebyscore和comparebyname的作用\",{\"1\":{\"1482\":1}}],[\"这也是在jdk8中新增加的方法\",{\"1\":{\"1480\":1}}],[\"这也是在选择是否使用前缀索引时需要考虑的一个因素\",{\"1\":{\"488\":1}}],[\"这也是锁分离带来的代价\",{\"1\":{\"1380\":1}}],[\"这也是longadder设计的精妙之处\",{\"1\":{\"1357\":1}}],[\"这也是为什么需要在步骤1先做判断\",{\"1\":{\"595\":1}}],[\"这也是myisam被innodb取代的重要原因之一\",{\"1\":{\"569\":1}}],[\"这也是两个tradeied字段的join操作\",{\"1\":{\"505\":1}}],[\"这也意味着可以通过数组来作为priorityqueue的底层实现\",{\"1\":{\"353\":1}}],[\"这里用网络上一个台式电脑的比喻来说就是\",{\"1\":{\"1868\":1}}],[\"这里用的双路排序\",{\"1\":{\"657\":1}}],[\"这里用的单路排序\",{\"1\":{\"657\":1}}],[\"这里推荐个我做过的社区论坛项目\",{\"1\":{\"1865\":1}}],[\"这里我推荐极客时间的课程\",{\"1\":{\"1850\":1}}],[\"这里我们显然是串行流\",{\"1\":{\"1494\":1}}],[\"这里我们也是需要使用另一个collectors中的方法\",{\"1\":{\"1490\":1}}],[\"这里我们就要调用groupingby的一个重载的方式来实现\",{\"1\":{\"1490\":1}}],[\"这里我们首先对于流中的集合进行了平方的操作\",{\"1\":{\"1486\":1}}],[\"这里我们使用的静态的常量是\",{\"1\":{\"1491\":1}}],[\"这里我们使用的collectors类中的tocollection\",{\"1\":{\"1486\":1}}],[\"这里我们使用构方法引用的方式\",{\"1\":{\"1486\":1}}],[\"这里我们选择new一个arraylist作为返回的容器\",{\"1\":{\"1485\":1}}],[\"这里我们对于集合中的元素先乘以2\",{\"1\":{\"1484\":1}}],[\"这里我们对mysql使用内部临时表做如下总结\",{\"1\":{\"555\":1}}],[\"这里我们调用的是类实例的方法\",{\"1\":{\"1481\":1}}],[\"这里我们直接使用studentcomparator实例中的comparestudentbyscore来进行排序\",{\"1\":{\"1481\":1}}],[\"这里我们排序的时候直接调用的是list集合中的默认方法sort\",{\"1\":{\"1480\":1}}],[\"这里我们先不去考虑lambda表达式具体的语法\",{\"1\":{\"1470\":1}}],[\"这里我们以linux\",{\"1\":{\"1356\":1}}],[\"这里我们设置innodb\",{\"1\":{\"613\":1}}],[\"这里我们假设从上到下是按照时间顺序执行的\",{\"1\":{\"533\":1}}],[\"这里我们假设身份证号没有重复\",{\"1\":{\"470\":1}}],[\"这里我们这里讨论三种常见的数据结构\",{\"1\":{\"468\":1}}],[\"这里主要是通过autowiredannotationbeanpostprocessor查找构造方法\",{\"1\":{\"1527\":1}}],[\"这里主要是为了区分机械硬盘和固态硬盘\",{\"1\":{\"694\":1}}],[\"这里会拿到缓存好的构造方法入参\",{\"1\":{\"1527\":1}}],[\"这里会处理\",{\"1\":{\"1525\":1}}],[\"这里会处理循环依赖问题\",{\"1\":{\"1524\":1}}],[\"这里可以使用自定义的classloader\",{\"1\":{\"1524\":1}}],[\"这里对我们而言有三个阶段\",{\"1\":{\"1500\":1}}],[\"这里也可以看到这个构造方法与我们之前见过的有关构造流源的构造方法的作用完全不同\",{\"1\":{\"1499\":1}}],[\"这里也是由于一定是<a\",{\"1\":{\"1495\":1}}],[\"这里又调用了abstractpipeline的构造方法\",{\"1\":{\"1499\":1}}],[\"这里将集合中的迭代器找出来并且估算元素的大小\",{\"1\":{\"1499\":1}}],[\"这里调用的第一个stream方法\",{\"1\":{\"1499\":1}}],[\"这里调用的collection接口中的stream方法\",{\"1\":{\"1497\":1}}],[\"这里spliterator作为流的源\",{\"1\":{\"1498\":1}}],[\"这里引出了另外一个及其重要的类referencepipeline\",{\"1\":{\"1498\":1}}],[\"这里给出了一个例子\",{\"1\":{\"1497\":1}}],[\"这里程序并不会依次的调用\",{\"1\":{\"1494\":1}}],[\"这里就会开启多个线程\",{\"1\":{\"1494\":1}}],[\"这里就要说明一个及其重要的方法collect\",{\"1\":{\"1485\":1}}],[\"这里就要提到一个同步原理\",{\"1\":{\"748\":1}}],[\"这里不能调用hashset\",{\"1\":{\"1494\":1}}],[\"这里面用到了collectors这个类提供的静态方法groupingby\",{\"1\":{\"1490\":1}}],[\"这里之所以使用limit是因为如果不加限制\",{\"1\":{\"1486\":1}}],[\"这里之所以和我们计算有点不同的原因是\",{\"1\":{\"688\":1}}],[\"这里举了两个例子\",{\"1\":{\"1485\":1}}],[\"这里总共有三个步骤\",{\"1\":{\"1485\":1}}],[\"这里并不是object类\",{\"1\":{\"1476\":1}}],[\"这里并不是将值作为参数\",{\"1\":{\"1472\":1}}],[\"这里还需要简单提及一下高阶函数\",{\"1\":{\"1475\":1}}],[\"这里因为类型推断的原因\",{\"1\":{\"1474\":1}}],[\"这里因为这里mysql并没有使用归并排序算法\",{\"1\":{\"558\":1}}],[\"这里说\",{\"1\":{\"1471\":1,\"1476\":1}}],[\"这里涉及到相同的key进行put就会覆盖原先的value\",{\"1\":{\"1431\":1}}],[\"这里了\",{\"1\":{\"1427\":1}}],[\"这里所说的队列是系统内存的内存队列\",{\"1\":{\"1396\":1}}],[\"这里所指索引统计数据指的是这两个值\",{\"1\":{\"690\":1}}],[\"这里把head删除\",{\"1\":{\"1380\":1}}],[\"这里索性在放完元素就检测一下\",{\"1\":{\"1380\":1}}],[\"这里为什么不直接使用数字\",{\"1\":{\"1495\":1}}],[\"这里为什么会是t类型以及t类型以上的类型呢\",{\"1\":{\"1491\":1}}],[\"这里为啥要唤醒一下呢\",{\"1\":{\"1380\":1}}],[\"这里为了避免乘法溢出\",{\"1\":{\"439\":1}}],[\"这里设计成环形链表的原因是基于效率的考量\",{\"1\":{\"1379\":1}}],[\"这里设置innodb\",{\"1\":{\"613\":1}}],[\"这里假设负载因子loadfactor=1\",{\"1\":{\"1427\":1}}],[\"这里假设使用idx\",{\"1\":{\"692\":1}}],[\"这里假设这条select查询最多在主库上等待1秒\",{\"1\":{\"610\":1}}],[\"这里暂时不做探讨\",{\"1\":{\"691\":1}}],[\"这里无用\",{\"1\":{\"690\":1}}],[\"这里自动补全的效果是\",{\"1\":{\"619\":1}}],[\"这里connection可缺省\",{\"1\":{\"617\":1}}],[\"这里value=2是因为修改前后的行id值不变\",{\"1\":{\"599\":1}}],[\"这里有两个新的方法\",{\"1\":{\"1487\":1}}],[\"这里有一个问题\",{\"1\":{\"692\":1}}],[\"这里有一个误区是\",{\"1\":{\"594\":1}}],[\"这里有100行\",{\"1\":{\"538\":1}}],[\"这里只能是userinterface类型的\",{\"1\":{\"1531\":1}}],[\"这里只是提供了创建结果容器的入口\",{\"1\":{\"1495\":1}}],[\"这里只需要大概了解函数式接口实例创建的方式有这么三种\",{\"1\":{\"1471\":1}}],[\"这里只操作了一张表\",{\"1\":{\"591\":1}}],[\"这里只用到了cat\",{\"1\":{\"467\":1}}],[\"这里创建了一个表\",{\"1\":{\"591\":1}}],[\"这里需要注意的是\",{\"1\":{\"570\":1}}],[\"这里扫描的行数是100万\",{\"1\":{\"544\":1}}],[\"这里列的这些\",{\"1\":{\"527\":1}}],[\"这里name\",{\"1\":{\"513\":1}}],[\"这里的wrapsink方法如下\",{\"1\":{\"1500\":1}}],[\"这里的构造方法又调用了referencepipeline的构造方法\",{\"1\":{\"1499\":1}}],[\"这里的this表示的是当前集合的引用\",{\"1\":{\"1498\":1}}],[\"这里的transaction\",{\"1\":{\"605\":1}}],[\"这里的statelessop也是定义在referencepipeline当中的一个静态内部类\",{\"1\":{\"1499\":1}}],[\"这里的spliterator方法是定义collection接口当中的一个默认方法\",{\"1\":{\"1498\":1}}],[\"这里的suppressed就是压制的异常信息\",{\"1\":{\"1496\":1}}],[\"这里的session\",{\"1\":{\"585\":1}}],[\"这里的泛型s指的就是stream<t>\",{\"1\":{\"1496\":1}}],[\"这里的泛型t代表流中元素的类型\",{\"1\":{\"1496\":1}}],[\"这里的partition是用来定义分组结果的一个静态内部类\",{\"1\":{\"1495\":1}}],[\"这里的下游指的是\",{\"1\":{\"1495\":1}}],[\"这里的属性值是identity\",{\"1\":{\"1495\":1}}],[\"这里的第四个参数指的是\",{\"1\":{\"1495\":1}}],[\"这里的第四个参数是\",{\"1\":{\"1495\":1}}],[\"这里的第二个参数就是我们上面定义过的收集器\",{\"1\":{\"1492\":1}}],[\"这里的unaryoperator表示接收参数与返回结果类型相同的情况\",{\"1\":{\"1486\":1}}],[\"这里的map描述的是一种映射\",{\"1\":{\"1484\":1}}],[\"这里的副作用指的是可能会修改传入参数的值\",{\"1\":{\"1474\":1}}],[\"这里的foreach实际上表示一种终止操作\",{\"1\":{\"1470\":1}}],[\"这里的内部结构发生变化指的是强调的是结构发生变化\",{\"1\":{\"1423\":1}}],[\"这里的内存临时表起到了暂存数据的作用\",{\"1\":{\"551\":1}}],[\"这里的必要条件之一是读写\",{\"1\":{\"1403\":1}}],[\"这里的3是第四步中的query\",{\"1\":{\"568\":1}}],[\"这里的扫描行数是1000\",{\"1\":{\"544\":1}}],[\"这里的\",{\"1\":{\"527\":1,\"1470\":1,\"1495\":1}}],[\"这里的测试数据有10万行\",{\"1\":{\"503\":1}}],[\"这里的其它情况包含两种可能性\",{\"1\":{\"428\":1}}],[\"这里实际上存在两个问题\",{\"1\":{\"484\":1}}],[\"这里使用stringbuilder作为最终返回的结果容器\",{\"1\":{\"1485\":1}}],[\"这里使用的是可重复读隔离级别\",{\"1\":{\"634\":1}}],[\"这里使用的栈来解决\",{\"1\":{\"386\":1}}],[\"这里使用箭头的粗细来表示并行度\",{\"1\":{\"597\":1}}],[\"这里使用了force\",{\"1\":{\"483\":1}}],[\"这里\",{\"1\":{\"471\":1,\"482\":1,\"533\":1,\"541\":1}}],[\"这里由定义可知\",{\"1\":{\"351\":1}}],[\"这个项目作为spring\",{\"1\":{\"1865\":1}}],[\"这个论坛项目不仅实现了基本的注册\",{\"1\":{\"1865\":1}}],[\"这个作为学习的可选项\",{\"1\":{\"1864\":1}}],[\"这个跟早期jdk版本的\",{\"1\":{\"1541\":1}}],[\"这个代理对象就成为spring容器中的bean\",{\"1\":{\"1530\":1}}],[\"这个终止操作是无状态的\",{\"1\":{\"1500\":1}}],[\"这个实现会接收下游的sink\",{\"1\":{\"1500\":1}}],[\"这个实例执行过的所有事务\",{\"1\":{\"605\":1}}],[\"这个实例\",{\"1\":{\"604\":1}}],[\"这个构造方法完成的就是对于已经存在的管道追加一个中间操作\",{\"1\":{\"1499\":1}}],[\"这个管道在被调用之后\",{\"1\":{\"1499\":1}}],[\"这个action可能会在任意的时间或者库所选择的任意线程中去执行\",{\"1\":{\"1499\":1}}],[\"这个阶段要么描述的是流的源\",{\"1\":{\"1498\":1}}],[\"这个枚举是定义在collector这个接口当中的\",{\"1\":{\"1492\":1}}],[\"这个类到类加载器实例的引用\",{\"1\":{\"1540\":1}}],[\"这个类是给类库的编写者提供的\",{\"1\":{\"1498\":1}}],[\"这个类型必须是java\",{\"1\":{\"1497\":1}}],[\"这个类本身并没有做任何事情\",{\"1\":{\"1493\":1}}],[\"这个类本身就定义在string类当中\",{\"1\":{\"1491\":1}}],[\"这个类没有定义在一个单独的文件当中\",{\"1\":{\"1493\":1}}],[\"这个类继承myinterface1impl\",{\"1\":{\"1484\":1}}],[\"这个结果相当于下面这段代码\",{\"1\":{\"1485\":1}}],[\"这个单词本身的含义是双向的意思\",{\"1\":{\"1475\":1}}],[\"这个复合函数首先应用before这个function\",{\"1\":{\"1475\":1}}],[\"这个概念会贯穿整个函数式编程的全过程\",{\"1\":{\"1470\":1}}],[\"这个函数表示当前的predicate与另一个predicate的短路与\",{\"1\":{\"1476\":1}}],[\"这个函数返回的是一个复合函数\",{\"1\":{\"1475\":1}}],[\"这个函数总共接收三个参数\",{\"1\":{\"1470\":1}}],[\"这个函数得到校验码填到这个新字段\",{\"1\":{\"489\":1}}],[\"这个看似简单的操作\",{\"1\":{\"1457\":1}}],[\"这个名称\",{\"1\":{\"1438\":1}}],[\"这个设计非常的巧妙\",{\"1\":{\"1427\":1}}],[\"这个key的hashcode方法得到其哈希值\",{\"1\":{\"1423\":1}}],[\"这个公式的含义是\",{\"1\":{\"1387\":1}}],[\"这个对象甚至可能被其它线程访问到\",{\"1\":{\"1365\":1}}],[\"这个根据不同操作系统和不同cpu会有不同的实现\",{\"1\":{\"1356\":1}}],[\"这个五种状态分别是\",{\"1\":{\"1354\":1}}],[\"这个开销很大\",{\"1\":{\"1350\":1}}],[\"这个解决方案的思想是\",{\"1\":{\"770\":1}}],[\"这个思想的含义是\",{\"1\":{\"770\":1}}],[\"这个脚本应该是通用的\",{\"1\":{\"761\":1}}],[\"这个脚本将会被调用\",{\"1\":{\"761\":1}}],[\"这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行\",{\"1\":{\"761\":1}}],[\"这个字典就用于保存订阅频道的信息\",{\"1\":{\"736\":1}}],[\"这个消息就会被发送给订阅它的三个客户端\",{\"1\":{\"733\":1}}],[\"这个消耗跟额外这个哈希字段也差不多抵消了\",{\"1\":{\"489\":1}}],[\"这个最后一次修改的数据就没有了\",{\"1\":{\"727\":1}}],[\"这个最左前缀可以是联合索引的最左n个字段\",{\"1\":{\"476\":1}}],[\"这个变量表示当前最小的连接查询成本\",{\"1\":{\"693\":1}}],[\"这个属性我们暂时不了解\",{\"1\":{\"690\":1}}],[\"这个属性表示的就是那个n值\",{\"1\":{\"690\":1}}],[\"这个条件的第一条记录\",{\"1\":{\"686\":1}}],[\"这个条件访问id\",{\"1\":{\"686\":1}}],[\"这个范围区间内包含多少二级索引记录\",{\"1\":{\"686\":1}}],[\"这个选项表示表占用的存储空间字节数\",{\"1\":{\"685\":1}}],[\"这个选项表示表中的记录条数\",{\"1\":{\"685\":1}}],[\"这个选择并不是最优的\",{\"1\":{\"484\":1}}],[\"这个搜索条件的索引列由于没有和常数比较\",{\"1\":{\"684\":1}}],[\"这个搜索条件可以使用二级索引idx\",{\"1\":{\"684\":2}}],[\"这个成本最低的方案就是所谓的执行计划\",{\"1\":{\"683\":1}}],[\"这个成本比较高\",{\"1\":{\"599\":1}}],[\"这个功能可以让我们方便的查看优化器执行计划的整个过程\",{\"1\":{\"681\":1}}],[\"这个功能是mysql5\",{\"1\":{\"623\":1}}],[\"这个视图由执行查询时所有未提交事务id数组\",{\"1\":{\"679\":1}}],[\"这个视图是在每个sql语句开始执行的时候创建的\",{\"1\":{\"570\":1}}],[\"这个视图是在事务启动时创建的\",{\"1\":{\"570\":1}}],[\"这个年限自然也就更短了\",{\"1\":{\"634\":1}}],[\"这个beanfactory的功能已经很全面了\",{\"1\":{\"1513\":1}}],[\"这个bug是只要mysql实例服务时间够长\",{\"1\":{\"634\":1}}],[\"这个bug仍然存在\",{\"1\":{\"634\":1}}],[\"这个binlog在从库执行或者用来恢复临时实例\",{\"1\":{\"629\":1}}],[\"这个自增值得上限是264\",{\"1\":{\"633\":1}}],[\"这个不连续的id\",{\"1\":{\"629\":1}}],[\"这个库就发生了数据不一致\",{\"1\":{\"629\":1}}],[\"这个库的线程很快就会爆满\",{\"1\":{\"578\":1}}],[\"这个锁会等执行结束以后才释放\",{\"1\":{\"629\":1}}],[\"这个恢复时间可能是要按天来计算的\",{\"1\":{\"623\":1}}],[\"这个流程的示意图如下\",{\"1\":{\"622\":1}}],[\"这个线程的状态仍然是在等待中\",{\"1\":{\"618\":1}}],[\"这个等待状态可以被唤醒\",{\"1\":{\"618\":1}}],[\"这个等待时间往往是无法接受的\",{\"1\":{\"581\":1}}],[\"这个sleep方案确实解决了类似场景下的过期读问题\",{\"1\":{\"608\":1}}],[\"这个gtid有两种生成方式\",{\"1\":{\"605\":1}}],[\"这个逻辑里面包含了一个设计思想\",{\"1\":{\"605\":1}}],[\"这个逻辑\",{\"1\":{\"604\":1}}],[\"这个哈希值是通过\",{\"1\":{\"602\":1}}],[\"这个参数的值被设置为2时\",{\"1\":{\"629\":1}}],[\"这个参数的值被设置为1时\",{\"1\":{\"629\":1}}],[\"这个参数的值被设置为0时\",{\"1\":{\"629\":1}}],[\"这个参数的可选值有以下三种\",{\"1\":{\"602\":1}}],[\"这个参数设置为50的时候\",{\"1\":{\"480\":1}}],[\"这个目标\",{\"1\":{\"601\":1}}],[\"这个策略用于低延时的场合\",{\"1\":{\"1397\":1}}],[\"这个策略仍然是一个令人感到惊艳的创新\",{\"1\":{\"601\":1}}],[\"这个策略与其他策略不同的地方在于\",{\"1\":{\"601\":1}}],[\"这个策略就没有效果了\",{\"1\":{\"600\":1}}],[\"这个策略有两个优势\",{\"1\":{\"600\":1}}],[\"这个策略是在innodb内部自己管理打开分区的行为\",{\"1\":{\"562\":1}}],[\"这个模式要求binlog的格式必须是row\",{\"1\":{\"599\":1}}],[\"这个按表分发的方案\",{\"1\":{\"598\":1}}],[\"这个切换流程的代价\",{\"1\":{\"596\":1}}],[\"这个切换流程\",{\"1\":{\"596\":1}}],[\"这个切换流程中是有不可用时间的\",{\"1\":{\"595\":1}}],[\"这个切换过程就称为可靠性优先策略\",{\"1\":{\"595\":1}}],[\"这个insert语句插入的行\",{\"1\":{\"591\":1}}],[\"这个位置包含文件名和日志偏移量\",{\"1\":{\"590\":1}}],[\"这个组里面已经有了三个事务\",{\"1\":{\"588\":1}}],[\"这个操作并不会保证它会遵循流当中元素的顺序\",{\"1\":{\"1499\":1}}],[\"这个操作的行为是不确定的\",{\"1\":{\"1499\":1}}],[\"这个操作序列复现了一个自增主键id不连续的情况\",{\"1\":{\"628\":1}}],[\"这个操作\",{\"1\":{\"585\":1}}],[\"这个操作会稍微复杂一些\",{\"1\":{\"479\":1}}],[\"这个并发控制要做在数据库服务端\",{\"1\":{\"581\":1}}],[\"这个超时时间可以通过参数innodb\",{\"1\":{\"581\":1}}],[\"这个业务需要涉及以下的操作\",{\"1\":{\"580\":1}}],[\"这个事务是可见的\",{\"1\":{\"679\":1}}],[\"这个事务也不是只读事务\",{\"1\":{\"634\":1}}],[\"这个事务的xid也是a\",{\"1\":{\"633\":1}}],[\"这个事务的哈希表就有三个项\",{\"1\":{\"599\":1}}],[\"这个事务的binlog是从8900这个位置开始的\",{\"1\":{\"591\":1}}],[\"这个事务修改的行涉及到表t1和t3\",{\"1\":{\"598\":1}}],[\"这个事务将持续存在直到主动执行commit或rollback语句\",{\"1\":{\"572\":1}}],[\"这个事务就启动了\",{\"1\":{\"572\":1}}],[\"这个文件不存在的话\",{\"1\":{\"565\":1}}],[\"这个是针对于管道源的有过优化的实现\",{\"1\":{\"1499\":1}}],[\"这个是磁盘扫描\",{\"1\":{\"662\":1}}],[\"这个是脏读\",{\"1\":{\"634\":1}}],[\"这个是设置慢查询的时间\",{\"1\":{\"565\":1}}],[\"这个是由参数long\",{\"1\":{\"565\":1}}],[\"这个是存储慢查询的日志文件\",{\"1\":{\"565\":1}}],[\"这个是开启慢查询\",{\"1\":{\"565\":1}}],[\"这个是符合预期的\",{\"1\":{\"558\":1}}],[\"这个语法删掉分区\",{\"1\":{\"563\":1}}],[\"这个语句是执行两个表的join\",{\"1\":{\"651\":1}}],[\"这个语句第二次申请自增id\",{\"1\":{\"629\":1}}],[\"这个语句真正执行的时候\",{\"1\":{\"628\":1}}],[\"这个语句序列\",{\"1\":{\"584\":1}}],[\"这个语句涉及的数据量很大\",{\"1\":{\"555\":1}}],[\"这个语句的操作时直接删除分区文件\",{\"1\":{\"563\":1}}],[\"这个语句的逻辑是把表t1里的数据\",{\"1\":{\"553\":1}}],[\"这个语句的执行方法就确定下来了\",{\"1\":{\"651\":1}}],[\"这个语句的执行方案就确定下来了\",{\"1\":{\"458\":1}}],[\"这个语句的执行速度越来越慢\",{\"1\":{\"556\":1}}],[\"这个语句的执行没有再使用临时表\",{\"1\":{\"555\":1}}],[\"这个语句的执行流程如下\",{\"1\":{\"551\":1,\"553\":1}}],[\"这个语句的执行将会非常耗时\",{\"1\":{\"539\":1}}],[\"这个语句里trade\",{\"1\":{\"505\":1}}],[\"这个语句只要求返回id和email字段\",{\"1\":{\"488\":1}}],[\"这个语句也需要同步修改\",{\"1\":{\"485\":1}}],[\"这个语句在搜索索引树的时候\",{\"1\":{\"477\":1}}],[\"这个语句就执行完成了\",{\"1\":{\"459\":1}}],[\"这个分区表并没有实质的差别\",{\"1\":{\"561\":1}}],[\"这个例子中的\",{\"1\":{\"1479\":1}}],[\"这个例子中事务b的update语句会被阻塞\",{\"1\":{\"580\":1}}],[\"这个例子中由于临时表只有10行\",{\"1\":{\"553\":1}}],[\"这个例子里面\",{\"1\":{\"557\":1}}],[\"这个rowid就是由系统生成的\",{\"1\":{\"557\":1}}],[\"这个rowid就是主键id\",{\"1\":{\"557\":1}}],[\"这个临时表使用的是memory引擎\",{\"1\":{\"557\":1}}],[\"这个临时表只有一个整型字段f\",{\"1\":{\"551\":1}}],[\"这个临时库就会少了这一次更新\",{\"1\":{\"464\":1}}],[\"这个命令需要慎重使用\",{\"1\":{\"704\":1}}],[\"这个命令就还没有在这个延迟复制的备库执行\",{\"1\":{\"623\":1}}],[\"这个命令很快也会被发给所有从库\",{\"1\":{\"623\":1}}],[\"这个命令正常返回的结果是一个正整数m\",{\"1\":{\"610\":1}}],[\"这个命令的意思是\",{\"1\":{\"591\":1}}],[\"这个命令的输出结果也有一个table\",{\"1\":{\"533\":1}}],[\"这个命令会将这个线程的自动提交关掉\",{\"1\":{\"572\":1}}],[\"这个命令\",{\"1\":{\"550\":1,\"618\":1}}],[\"这个进程的进程号是4d2\",{\"1\":{\"549\":1}}],[\"这个frm文件放在临时文件目录下\",{\"1\":{\"549\":1}}],[\"这个方案要求线上有定期的全量备份\",{\"1\":{\"622\":1}}],[\"这个方案的假设是\",{\"1\":{\"608\":1}}],[\"这个方案的做法是\",{\"1\":{\"608\":1}}],[\"这个方案的缺点也很明显\",{\"1\":{\"548\":1}}],[\"这个方案最大的问题在于\",{\"1\":{\"607\":1}}],[\"这个方案很容易被大事务拖后腿\",{\"1\":{\"601\":1}}],[\"这个方法中就产生一个mapper接口代理对象\",{\"1\":{\"1530\":1}}],[\"这个方法就是对流中的中间操作进行串联的方法\",{\"1\":{\"1500\":1}}],[\"这个方法在abstractpipeline中有唯一的实现\",{\"1\":{\"1500\":1}}],[\"这个方法实际上在referencepipeline中是有两个实现的\",{\"1\":{\"1499\":1}}],[\"这个方法有可能会返回一个空值\",{\"1\":{\"1497\":1}}],[\"这个方法接口两个参数并且有返回值\",{\"1\":{\"1491\":1}}],[\"这个方法会统计流中元素的个数\",{\"1\":{\"1490\":1}}],[\"这个方法对于给定的输入元素进行了排序的操作\",{\"1\":{\"1490\":1}}],[\"这个方法本身是一个function的函数式接口\",{\"1\":{\"1490\":1}}],[\"这个方法返回无限的\",{\"1\":{\"1486\":1}}],[\"这个方法我们也可以用方法引用来完成\",{\"1\":{\"1485\":1}}],[\"这个方法刚好是反过来的\",{\"1\":{\"1475\":1}}],[\"这个方法其实是将两个function进行了组合\",{\"1\":{\"1475\":1}}],[\"这个方法将返回了一个新的对象stream\",{\"1\":{\"1470\":1}}],[\"这个方法非常巧妙\",{\"1\":{\"1425\":1}}],[\"这个方法的文档如下\",{\"1\":{\"1490\":1}}],[\"这个方法的问题是锁的粒度太大\",{\"1\":{\"628\":1}}],[\"这个方法的成本很高\",{\"1\":{\"628\":1}}],[\"这个方法的效率很高\",{\"1\":{\"559\":1}}],[\"这个方法是计算逻辑或的操作\",{\"1\":{\"1476\":1}}],[\"这个方法是基于\",{\"1\":{\"588\":1}}],[\"这个方法是通过查看optimizer\",{\"1\":{\"491\":1}}],[\"这个方法效率不够好\",{\"1\":{\"492\":1}}],[\"这个优化效果还是很明显的\",{\"1\":{\"544\":1}}],[\"这个判断的工作量很大\",{\"1\":{\"544\":1}}],[\"这个算法并不严格满足题目的随机要求\",{\"1\":{\"559\":1}}],[\"这个算法其实就是对nlj算法的优化\",{\"1\":{\"542\":1}}],[\"这个算法会将t1表的内容放入到join\",{\"1\":{\"540\":1}}],[\"这个问题的结论是\",{\"1\":{\"540\":1}}],[\"这个问题的状态转移方程\",{\"1\":{\"430\":1}}],[\"这个值可以大于1\",{\"1\":{\"1423\":1}}],[\"这个值的默认值是20\",{\"1\":{\"695\":1}}],[\"这个值的时间精度是秒\",{\"1\":{\"594\":1}}],[\"这个值也是一个估计值\",{\"1\":{\"695\":2}}],[\"这个值是估计值\",{\"1\":{\"695\":1}}],[\"这个值如果为0代表全部使用的sort\",{\"1\":{\"657\":1}}],[\"这个值还是逻辑上不精确的\",{\"1\":{\"534\":1}}],[\"这个值就是在执行器每次调用引擎获取数据行的时候累加的\",{\"1\":{\"459\":1}}],[\"这个指标可能还不够完美\",{\"1\":{\"526\":1}}],[\"这个步骤用上了主键索引\",{\"1\":{\"505\":1}}],[\"这个动作\",{\"1\":{\"491\":1}}],[\"这个索引的效率就越高\",{\"1\":{\"496\":1}}],[\"这个索引的区分度就非常低了\",{\"1\":{\"489\":1}}],[\"这个索引的区分度就越好\",{\"1\":{\"484\":1}}],[\"这个索引结构中每个邮箱的字段都只取6个字节\",{\"1\":{\"487\":1}}],[\"这个基数都是很容易不准的\",{\"1\":{\"484\":1}}],[\"这个基数越大\",{\"1\":{\"484\":1}}],[\"这个统计信息就是索引的\",{\"1\":{\"484\":1}}],[\"这个数字越小\",{\"1\":{\"761\":1}}],[\"这个数据页才会被读入内存\",{\"1\":{\"482\":1}}],[\"这个数组就是按照身份证号递增的顺序保存的\",{\"1\":{\"470\":1}}],[\"这个信息\",{\"1\":{\"482\":1}}],[\"这个记录要更新的目标在内存中\",{\"1\":{\"480\":1}}],[\"这个记录\",{\"1\":{\"480\":1}}],[\"这个查询用到的索引就是idx\",{\"1\":{\"690\":1}}],[\"这个查询只能在联合索引里匹配到名字是\",{\"1\":{\"655\":1}}],[\"这个查询需要读取几千行数据\",{\"1\":{\"527\":1}}],[\"这个查询将返回10行数据\",{\"1\":{\"527\":1}}],[\"这个查询过程不需要临时表\",{\"1\":{\"493\":1}}],[\"这个查询过程读了k索引树的3条记录\",{\"1\":{\"474\":1}}],[\"这个查询没有符合条件的记录\",{\"1\":{\"484\":1}}],[\"这个查询语句在索引树上的查找的过程\",{\"1\":{\"479\":1}}],[\"这个联合索引本身有序\",{\"1\":{\"493\":1}}],[\"这个联合索引的\",{\"1\":{\"476\":1}}],[\"这个联合索引来分析\",{\"1\":{\"476\":1}}],[\"这个过程被称之为零拷贝\",{\"1\":{\"1453\":1}}],[\"这个过程需要等待\",{\"1\":{\"1440\":1}}],[\"这个过程需要扫描100行\",{\"1\":{\"538\":1}}],[\"这个过程存在很大的开销\",{\"1\":{\"1396\":1}}],[\"这个过程会消耗一定的性能\",{\"1\":{\"1362\":1}}],[\"这个过程可能会很慢\",{\"1\":{\"696\":1}}],[\"这个过程可能会使用到索引\",{\"1\":{\"691\":1}}],[\"这个过程总结一下就是这样\",{\"1\":{\"683\":1}}],[\"这个过程的性能消耗也可以忽略不计的\",{\"1\":{\"686\":1}}],[\"这个过程的流程图如下\",{\"1\":{\"610\":1}}],[\"这个过程的示意图如下\",{\"1\":{\"551\":1,\"622\":1}}],[\"这个过程不需要临时文件\",{\"1\":{\"558\":1}}],[\"这个过程不需要重连和重新做权限验证\",{\"1\":{\"455\":1}}],[\"这个过程中数据是可以正常更新的\",{\"1\":{\"575\":1}}],[\"这个过程中\",{\"1\":{\"557\":1}}],[\"这个过程没有涉及到表操作\",{\"1\":{\"557\":1}}],[\"这个过程要对内存临时表做全表扫描\",{\"1\":{\"557\":1}}],[\"这个过程就跟我们写程序时的嵌套查询类似\",{\"1\":{\"538\":1}}],[\"这个过程就称为全字段排序\",{\"1\":{\"491\":1}}],[\"这个过程是很耗时的\",{\"1\":{\"1404\":1}}],[\"这个过程是同步的\",{\"1\":{\"696\":1}}],[\"这个过程是现遍历表t1\",{\"1\":{\"538\":1}}],[\"这个过程是通过遍历主键索引的方式\",{\"1\":{\"505\":1}}],[\"这个过程称为页分裂\",{\"1\":{\"472\":1}}],[\"这个过程称为回表\",{\"1\":{\"472\":1}}],[\"这个表的auto\",{\"1\":{\"631\":1}}],[\"这个表的自增值改成3\",{\"1\":{\"628\":1}}],[\"这个表的建表语句是\",{\"1\":{\"472\":1}}],[\"这个表会被从哈希表中去掉\",{\"1\":{\"598\":1}}],[\"这个表定义了一个字增逐渐id\",{\"1\":{\"596\":1}}],[\"这个表包含了一个\",{\"1\":{\"561\":1}}],[\"这个表没有建索引\",{\"1\":{\"557\":1}}],[\"这个表只有1000行\",{\"1\":{\"544\":1}}],[\"这个表每被插入一行redis计数就加1\",{\"1\":{\"534\":1}}],[\"这个表上的查询缓存都会被清空\",{\"1\":{\"456\":1}}],[\"这个n差不多是1200\",{\"1\":{\"471\":1}}],[\"这个区间的所有用户\",{\"1\":{\"469\":1}}],[\"这个也可以忽略不计\",{\"1\":{\"467\":1}}],[\"这个\",{\"1\":{\"464\":1,\"599\":1,\"619\":1}}],[\"这个日志\",{\"1\":{\"464\":1}}],[\"这个能力称为crash\",{\"1\":{\"461\":1}}],[\"这个接口是从jdk1\",{\"1\":{\"1474\":1}}],[\"这个接口中的抽象方法\",{\"1\":{\"1472\":1}}],[\"这个接口中唯一的抽象方法test\",{\"1\":{\"1472\":2}}],[\"这个接口中有两个抽象方法\",{\"1\":{\"1472\":1}}],[\"这个接口中看起来有两个抽象方法\",{\"1\":{\"1471\":1}}],[\"这个接口中只有一个抽象方法test\",{\"1\":{\"1471\":1}}],[\"这个接口\",{\"1\":{\"459\":2}}],[\"这个时间复杂度是o\",{\"1\":{\"471\":1}}],[\"这个时间是由参数wait\",{\"1\":{\"455\":1}}],[\"这个时候元就有一些风险\",{\"1\":{\"1497\":1}}],[\"这个时候如果再设置concurrent特性\",{\"1\":{\"1494\":1}}],[\"这个时候如果删除id=10的行\",{\"1\":{\"627\":1}}],[\"这个时候也要去掉identity\",{\"1\":{\"1494\":1}}],[\"这个时候我们再来分析一个这四个方法对应的泛型\",{\"1\":{\"1492\":1}}],[\"这个时候调用当前类的mymethod\",{\"1\":{\"1484\":1}}],[\"这个时候kernel就要等待足够的数据到来\",{\"1\":{\"1440\":1}}],[\"这个时候能不能选择出来一个老大呢\",{\"1\":{\"748\":1}}],[\"这个时候就变成了接收一个参数\",{\"1\":{\"1483\":1}}],[\"这个时候就发生了哈希碰撞\",{\"1\":{\"1423\":1}}],[\"这个时候就会导致事务执行失败\",{\"1\":{\"718\":1}}],[\"这个时候就可以考虑使用临时表\",{\"1\":{\"544\":1}}],[\"这个时候在备库上执行stop\",{\"1\":{\"623\":1}}],[\"这个时候另外一个线程的事务b提交\",{\"1\":{\"588\":1}}],[\"这个时候只kill掉可能未必管用了\",{\"1\":{\"578\":1}}],[\"这个时候的$r4\",{\"1\":{\"505\":1}}],[\"这个时候不得不维护另一个索引\",{\"1\":{\"476\":1}}],[\"这个时候\",{\"1\":{\"464\":1,\"492\":1,\"548\":1,\"549\":1,\"553\":1,\"563\":1,\"575\":1,\"599\":1,\"604\":1,\"615\":1,\"1430\":1,\"1482\":1,\"1484\":2,\"1527\":1}}],[\"这个时候binlog里面就没有记录这个语句\",{\"1\":{\"464\":1}}],[\"这个时候更新就算完成了\",{\"1\":{\"461\":1}}],[\"这个时候用的就是你输入的用户名和密码\",{\"1\":{\"455\":1}}],[\"这个连接就处于空闲状态\",{\"1\":{\"455\":1}}],[\"这个连接里面的权限判断逻辑\",{\"1\":{\"455\":1}}],[\"这个2结点要么没有孩子\",{\"1\":{\"347\":1}}],[\"这个映射函数f叫做散列函数或者哈希函数\",{\"1\":{\"332\":1}}],[\"这就要求spring事务管理器中的datasource和jdbc\",{\"1\":{\"1532\":1}}],[\"这就要求在在定义collector的是偶\",{\"1\":{\"1494\":1}}],[\"这就实现了收集器的复合\",{\"1\":{\"1492\":1}}],[\"这就解决了hashmap中由于put数据引起的闭环问题\",{\"1\":{\"1430\":1}}],[\"这就会造成不必要的上下文切换\",{\"1\":{\"1387\":1}}],[\"这就会导致切换慢的问题\",{\"1\":{\"615\":1}}],[\"这就会导致大量占用存储空间\",{\"1\":{\"571\":1}}],[\"这就需要人工干预\",{\"1\":{\"756\":1}}],[\"这就保证了\",{\"1\":{\"633\":1}}],[\"这就代表了如果主库上有数据被误删了\",{\"1\":{\"623\":1}}],[\"这就和redo\",{\"1\":{\"588\":1}}],[\"这就涉及到binlog\",{\"1\":{\"587\":1}}],[\"这就导致接下来的查询都在事务中\",{\"1\":{\"572\":1}}],[\"这就是双亲委托机制\",{\"1\":{\"1570\":1}}],[\"这就是所谓的静态链接过程\",{\"1\":{\"1540\":1}}],[\"这就是所谓的终止操作\",{\"1\":{\"1484\":1}}],[\"这就是因为我们的中间结果类型是set类型\",{\"1\":{\"1494\":1}}],[\"这就是操作系统真正意义上的零拷贝\",{\"1\":{\"1460\":1}}],[\"这就是典型一对一答模型\",{\"1\":{\"1450\":1}}],[\"这就是为什么说java的线程比较重的原因\",{\"1\":{\"1354\":1}}],[\"这就是缓存被击穿\",{\"1\":{\"766\":1}}],[\"这就是我们之前所说的槽\",{\"1\":{\"1357\":1}}],[\"这就是我们预期的结果\",{\"1\":{\"617\":1}}],[\"这就是我们为什么要设置innodb\",{\"1\":{\"613\":1}}],[\"这就是等主库位点方案\",{\"1\":{\"609\":1}}],[\"这就是一种比较典型的大事务的场景\",{\"1\":{\"594\":1}}],[\"这就是最终以执行\",{\"1\":{\"593\":1}}],[\"这就是两阶段锁协议\",{\"1\":{\"580\":1}}],[\"这就是这个命令会什么会出现在binlog的原因\",{\"1\":{\"550\":1}}],[\"这就是bka算法\",{\"1\":{\"542\":1}}],[\"这就是mrr优化的设计思路\",{\"1\":{\"541\":1}}],[\"这就是使用前缀索引的优势\",{\"1\":{\"487\":1}}],[\"这就是\",{\"1\":{\"463\":1,\"1396\":1}}],[\"这就是重复性\",{\"1\":{\"340\":1}}],[\"这就意味着集合中不能出现重复的数据\",{\"1\":{\"709\":1}}],[\"这就意味着我们可以手动更新某个表或者索引的统计数据\",{\"1\":{\"696\":1}}],[\"这就意味着mysql的查询优化器为了计算这些单点区间的索引记录条数\",{\"1\":{\"690\":1}}],[\"这就意味着\",{\"1\":{\"455\":1}}],[\"这就产生了误报\",{\"1\":{\"307\":1}}],[\"使其再次尝试获取同步状态\",{\"1\":{\"1368\":1}}],[\"使得zookeeper成为了解决分布式一致性问题的利器\",{\"1\":{\"1869\":1}}],[\"使得父容器\",{\"1\":{\"1536\":1}}],[\"使得其它处理器暂时无法通过总线访问内存\",{\"1\":{\"1350\":1}}],[\"使得多个进程快速交替的执行\",{\"1\":{\"1347\":1}}],[\"使得在宏观上具有多个进程同时执行的效果\",{\"1\":{\"1347\":1}}],[\"使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上的不同版本数据\",{\"1\":{\"679\":1}}],[\"使得这三个语句都处于\",{\"1\":{\"613\":1}}],[\"使得\",{\"1\":{\"332\":1}}],[\"使用示例\",{\"0\":{\"1826\":1}}],[\"使用proxyfactory获取代理对象\",{\"1\":{\"1531\":1}}],[\"使用put锁加锁\",{\"1\":{\"1380\":1}}],[\"使用无参构造方法\",{\"1\":{\"1527\":1}}],[\"使用end方法可以将它从激活状态转换成初始状态\",{\"1\":{\"1500\":1}}],[\"使用explain查看执行情况\",{\"1\":{\"491\":1}}],[\"使用explain关键字可以模拟优化器执行sql查询语句\",{\"1\":{\"466\":1}}],[\"使用他们来简化一些计算\",{\"1\":{\"1497\":1}}],[\"使用给定的下游收集器执行汇聚操作\",{\"1\":{\"1495\":1}}],[\"使用tocollection可以很方便的自定义返回结果容器的类型\",{\"1\":{\"1486\":1}}],[\"使用takelock加锁\",{\"1\":{\"1380\":1}}],[\"使用函数式的方式\",{\"1\":{\"1484\":1}}],[\"使用函数式编程\",{\"1\":{\"1468\":1}}],[\"使用相似的方式\",{\"1\":{\"1484\":1}}],[\"使用传统的iterator遍历的效率是要比流的方式效率要高的\",{\"1\":{\"1499\":1}}],[\"使用传统的方式\",{\"1\":{\"1475\":1,\"1488\":1}}],[\"使用传统的递归方式\",{\"1\":{\"395\":1}}],[\"使用通知性的annotation\",{\"1\":{\"1471\":1}}],[\"使用方法引用可以写出更加简洁优雅的代码\",{\"1\":{\"1470\":1}}],[\"使用lambda表达式所带来的好处其实远不止简化代码\",{\"1\":{\"1469\":1}}],[\"使用lambda表达式的新写法\",{\"1\":{\"1468\":1}}],[\"使用lambda创建了线程了\",{\"1\":{\"1468\":1}}],[\"使用匿名内部类编程\",{\"1\":{\"1468\":1}}],[\"使用比较方法\",{\"1\":{\"1415\":1}}],[\"使用集合的好处\",{\"1\":{\"1415\":1}}],[\"使用数组进行增加元素\",{\"1\":{\"1415\":1}}],[\"使用数组来保存\",{\"1\":{\"430\":1}}],[\"使用案例\",{\"1\":{\"1398\":1}}],[\"使用链表实现需要额外的\",{\"1\":{\"1386\":1}}],[\"使用notfull等待\",{\"1\":{\"1379\":1}}],[\"使用nacos配置中心\",{\"0\":{\"241\":1}}],[\"使用独占锁reentrantlock实现线程安全\",{\"1\":{\"1379\":1}}],[\"使用asm技术读取当前类的名称\",{\"1\":{\"1524\":1}}],[\"使用asm技术的原因是\",{\"1\":{\"1523\":1}}],[\"使用arrayblockingqueue是个不错的选择\",{\"1\":{\"1379\":1}}],[\"使用alpine镜像\",{\"0\":{\"1045\":1}}],[\"使用生产者\",{\"1\":{\"1378\":1}}],[\"使用逃逸分析\",{\"1\":{\"1365\":1}}],[\"使用场景\",{\"0\":{\"1242\":1},\"1\":{\"1394\":1}}],[\"使用简单\",{\"0\":{\"812\":1}}],[\"使用哨兵模式\",{\"1\":{\"748\":1}}],[\"使用规则\",{\"0\":{\"748\":1}}],[\"使用wkhtmltopdf生成长图和pdf\",{\"1\":{\"1865\":1}}],[\"使用watch可以当做redis的乐观锁操作\",{\"1\":{\"718\":1}}],[\"使用watch\",{\"1\":{\"718\":1}}],[\"使用while循环的双指针\",{\"1\":{\"361\":1}}],[\"使用位存储\",{\"1\":{\"715\":1}}],[\"使用geohash位置52点整数编码\",{\"1\":{\"713\":1}}],[\"使用经纬度定位地理坐标并用一个有序集合zset保存\",{\"1\":{\"713\":1}}],[\"使用此命令遍历集合中元素\",{\"1\":{\"709\":1}}],[\"使用语句flush\",{\"1\":{\"696\":1}}],[\"使用统计数据算出来的查询成本与所需的成本可能相差非常大\",{\"1\":{\"690\":1}}],[\"使用统计数据来计算单点区间对应的索引记录条数比index\",{\"1\":{\"690\":1}}],[\"使用iterators遍历元素通常需要两者搭配使用\",{\"1\":{\"1497\":1}}],[\"使用id\",{\"1\":{\"686\":1}}],[\"使用idx\",{\"1\":{\"686\":3,\"688\":5,\"692\":7}}],[\"使用index\",{\"1\":{\"690\":1}}],[\"使用in\",{\"1\":{\"531\":1}}],[\"使用临时文件的个数\",{\"1\":{\"657\":1}}],[\"使用临时表优化查询\",{\"0\":{\"551\":1}}],[\"使用临时表的步骤如下\",{\"1\":{\"544\":1}}],[\"使用该索引获取的记录是否按照主键排序\",{\"1\":{\"656\":1}}],[\"使用该方法开启mysql的慢查询日志只对当前数据库生效\",{\"1\":{\"565\":1}}],[\"使用整型的主键可以方便的比较大小\",{\"1\":{\"642\":1}}],[\"使用的putindex\",{\"1\":{\"1379\":1}}],[\"使用的成本都是1\",{\"1\":{\"694\":1}}],[\"使用的就不全是默认值\",{\"1\":{\"628\":1}}],[\"使用的是asm技术\",{\"1\":{\"1523\":1}}],[\"使用的是pthread\",{\"1\":{\"618\":1}}],[\"使用的是归并排序\",{\"1\":{\"316\":1}}],[\"使用的是三向切分的快速排序\",{\"1\":{\"316\":1}}],[\"使用reentrantlock+condition实现阻塞\",{\"1\":{\"1397\":1}}],[\"使用redistemplate需要频繁调用\",{\"1\":{\"721\":1}}],[\"使用redistemplate\",{\"1\":{\"720\":1}}],[\"使用ringbuffer来作为队列的数据结构\",{\"1\":{\"1397\":1}}],[\"使用rm命令误删整个mysql实例\",{\"1\":{\"620\":1}}],[\"使用row格式的binlog时\",{\"1\":{\"596\":1}}],[\"使用drop\",{\"1\":{\"620\":2}}],[\"使用delete语句误删数据行\",{\"1\":{\"620\":1}}],[\"使用delete语句删掉10万行数据\",{\"1\":{\"591\":1}}],[\"使用这种写法\",{\"1\":{\"1472\":1}}],[\"使用这种类型的缓存一致性\",{\"1\":{\"1351\":1}}],[\"使用这种方式是为了执行stream的close方法\",{\"1\":{\"1496\":1}}],[\"使用这种方式可以替换原来的需要人为的显示关闭各种流的操作\",{\"1\":{\"1496\":1}}],[\"使用这种方式\",{\"1\":{\"605\":1}}],[\"使用这个特点来实现数据拷贝\",{\"1\":{\"1460\":1}}],[\"使用这个临时表来辅助完成查询\",{\"1\":{\"694\":1}}],[\"使用这个算法\",{\"1\":{\"634\":1}}],[\"使用这个方法\",{\"1\":{\"614\":1}}],[\"使用这个策略的效果会很好\",{\"1\":{\"600\":1}}],[\"使用begin方法可以将它从初始状态转换成激活状态\",{\"1\":{\"1500\":1}}],[\"使用bio通信模型的服务端\",{\"1\":{\"1450\":1}}],[\"使用binlog来恢复数据的标准做法是\",{\"1\":{\"591\":1}}],[\"使用b索引的代价是很高的\",{\"1\":{\"485\":1}}],[\"使用\",{\"1\":{\"591\":1,\"1350\":1,\"1540\":1,\"1858\":1}}],[\"使用如下命令解析和查看binlog中的内容\",{\"1\":{\"591\":1}}],[\"使用如下语句查询超过60s的长事务\",{\"1\":{\"571\":1}}],[\"使用前需要开启\",{\"1\":{\"568\":1}}],[\"使用前缀索引后\",{\"1\":{\"487\":1}}],[\"使用分割迭代器来构造流源的这一步我们已经完成了\",{\"1\":{\"1499\":1}}],[\"使用分区别的业务代码更简洁\",{\"1\":{\"563\":1}}],[\"使用分解关联查询的优势如下\",{\"1\":{\"531\":1}}],[\"使用sink对于接收到的所有的元素进行包装成由pipelinehelper所描述的中间操作\",{\"1\":{\"1500\":1}}],[\"使用spliterator来遍历元素的成本是更低的\",{\"1\":{\"1497\":1}}],[\"使用sql语句进行分组的查询是一个很常见的需求\",{\"1\":{\"1490\":1}}],[\"使用sql语句\",{\"1\":{\"1488\":1}}],[\"使用select\",{\"1\":{\"1442\":1}}],[\"使用slaveof\",{\"1\":{\"747\":1}}],[\"使用sleep\",{\"1\":{\"561\":1}}],[\"使用s2作为驱动表的总成本就是\",{\"1\":{\"692\":1}}],[\"使用s2作为被驱动表与使用s1作为被驱动表有一个区别就是\",{\"1\":{\"692\":1}}],[\"使用show\",{\"1\":{\"613\":1,\"690\":3}}],[\"使用stream的api很像在使用sql语句\",{\"1\":{\"1490\":1}}],[\"使用stream的就称之为内部迭代\",{\"1\":{\"1488\":1}}],[\"使用straight\",{\"1\":{\"538\":1}}],[\"使用stringbuilder效率会有所提升\",{\"1\":{\"409\":1}}],[\"使用单表查询需要\",{\"1\":{\"538\":1}}],[\"使用jedis\",{\"1\":{\"720\":1}}],[\"使用java标准的\",{\"1\":{\"1525\":1}}],[\"使用java标准库中的arrays\",{\"1\":{\"329\":1}}],[\"使用java来操作redis\",{\"1\":{\"719\":1}}],[\"使用join\",{\"1\":{\"542\":1}}],[\"使用join语句\",{\"1\":{\"538\":1}}],[\"使用join有什么问题\",{\"1\":{\"537\":1}}],[\"使用缓存系统保存计数\",{\"0\":{\"534\":1}}],[\"使用尽可能少的查询当然是更好的\",{\"1\":{\"529\":1}}],[\"使用到类时才会加载\",{\"1\":{\"1540\":1}}],[\"使用到a\",{\"1\":{\"514\":5}}],[\"使用到了覆盖索引\",{\"1\":{\"512\":8,\"513\":2}}],[\"使用索引的类型\",{\"1\":{\"690\":1}}],[\"使用索引的成本会除去读取并检测回表后聚簇索引记录的成本\",{\"1\":{\"688\":1}}],[\"使用索引idx\",{\"1\":{\"681\":2}}],[\"使用索引优化group\",{\"0\":{\"554\":1}}],[\"使用索引覆盖扫描\",{\"1\":{\"527\":2}}],[\"使用索引范围查询\",{\"1\":{\"512\":1}}],[\"使用索引a\",{\"1\":{\"484\":1}}],[\"使用覆盖索引就不会全表扫描了\",{\"1\":{\"506\":1}}],[\"使用覆盖索引\",{\"1\":{\"493\":1}}],[\"使用倒序存储和使用哈希字段两种方式的异同点如下\",{\"1\":{\"489\":1}}],[\"使用普通索引需要把回表的代价算进去\",{\"1\":{\"484\":1}}],[\"使用collect\",{\"1\":{\"1492\":1}}],[\"使用competionservice实现先获取的报价先保存到数据库\",{\"1\":{\"1394\":1}}],[\"使用change\",{\"1\":{\"481\":1}}],[\"使用cat命令如何统计文件中一个字符串出现的频率\",{\"0\":{\"262\":1}}],[\"使用哈希字段方式的查询性能相对更稳定一些\",{\"1\":{\"489\":1}}],[\"使用哈希字段指的是可以在表上创建一个整数字段\",{\"1\":{\"489\":1}}],[\"使用哈希算法不可避免的就会遇到哈希冲突\",{\"1\":{\"469\":1}}],[\"使用哈希表\",{\"1\":{\"380\":1,\"387\":1}}],[\"使用哈希表来实现\",{\"1\":{\"373\":1}}],[\"使用了spliterators并行算法的实现\",{\"1\":{\"1497\":1}}],[\"使用了语句级的锁\",{\"1\":{\"629\":1}}],[\"使用了内存临时表\",{\"1\":{\"558\":1}}],[\"使用了临时表\",{\"1\":{\"551\":1}}],[\"使用了临时表保存中间结果\",{\"1\":{\"467\":1}}],[\"使用了t\",{\"1\":{\"503\":1}}],[\"使用了连接缓存\",{\"1\":{\"467\":1}}],[\"使用一个collector执行汇聚操作会生成的结果应该和下面的结果等价\",{\"1\":{\"1492\":1}}],[\"使用一段时间\",{\"1\":{\"455\":1}}],[\"使用一维数组的方式\",{\"1\":{\"431\":1}}],[\"使用二分查找\",{\"1\":{\"439\":1}}],[\"使用暴力解法\",{\"1\":{\"438\":1}}],[\"使用暴力法求解\",{\"1\":{\"367\":1}}],[\"使用记忆化搜索相当于剪枝\",{\"1\":{\"429\":1}}],[\"使用循环求解\",{\"1\":{\"424\":1}}],[\"使用贪心算法\",{\"1\":{\"419\":1,\"420\":1,\"421\":1,\"422\":1}}],[\"使用回溯法\",{\"1\":{\"400\":1}}],[\"使用回溯算法\",{\"1\":{\"399\":1}}],[\"使用递归\",{\"1\":{\"397\":1}}],[\"使用最大堆\",{\"1\":{\"393\":1}}],[\"使用排序\",{\"1\":{\"387\":1}}],[\"使用myisam存储引擎的表来说\",{\"1\":{\"685\":1}}],[\"使用mysqlbinlog方法恢复数据还是不够快\",{\"1\":{\"622\":1}}],[\"使用mysqlbinlog解析出日志\",{\"1\":{\"591\":1}}],[\"使用mysql内置的函数\",{\"1\":{\"508\":1}}],[\"使用map统计\",{\"1\":{\"381\":1}}],[\"使用mq如何保证分布式事务的最终一致性\",{\"0\":{\"259\":1}}],[\"使用虚拟的头节点\",{\"1\":{\"371\":1}}],[\"使用for循环的双指针\",{\"1\":{\"361\":1}}],[\"使用foreach循环\",{\"1\":{\"329\":1}}],[\"使用多个哈希函数产生多个哈希值\",{\"1\":{\"307\":1}}],[\"使用线程池有什么好处\",{\"0\":{\"83\":1}}],[\"使用可变类当hashmap的key有什么问题\",{\"0\":{\"42\":1}}],[\"总线的大小及其提供的带宽也必须增加\",{\"1\":{\"1351\":1}}],[\"总的来说在进行中间操作的时候\",{\"1\":{\"1500\":1}}],[\"总的来说分为两种情况\",{\"1\":{\"1495\":1}}],[\"总的来说\",{\"1\":{\"636\":1,\"1471\":1,\"1488\":1}}],[\"总结来看\",{\"1\":{\"1442\":1}}],[\"总结一下\",{\"1\":{\"691\":1,\"1494\":1}}],[\"总结\",{\"1\":{\"567\":1}}],[\"总扫描行数变成了20003\",{\"1\":{\"557\":1}}],[\"总扫描行数是200\",{\"1\":{\"538\":1}}],[\"总体会占用比较多的时间\",{\"1\":{\"1387\":1}}],[\"总体来看\",{\"1\":{\"544\":1}}],[\"总体介绍\",{\"0\":{\"337\":1,\"353\":1}}],[\"总是要找一个\",{\"1\":{\"604\":1}}],[\"总是取到最新的数据\",{\"1\":{\"575\":1}}],[\"总是取出全部列\",{\"0\":{\"522\":1}}],[\"总是跟这个事务在启动的时候看到的数据是一致的\",{\"1\":{\"570\":1}}],[\"总是保持最大值在堆顶\",{\"1\":{\"558\":1}}],[\"总是强调需要数据库层完成尽可能多的工作\",{\"1\":{\"529\":1}}],[\"总是会使用连接器连接到这个数据库上\",{\"1\":{\"455\":1}}],[\"总共从redo\",{\"1\":{\"616\":1}}],[\"总共需要扫描c+y+1行\",{\"1\":{\"559\":1}}],[\"总共需要在内存中做判断的次数是100\",{\"1\":{\"540\":1}}],[\"总共扫描100\",{\"1\":{\"539\":1}}],[\"总共18位\",{\"1\":{\"489\":1}}],[\"总共有这么多个元素\",{\"1\":{\"443\":1}}],[\"总数为log2n个索引\",{\"1\":{\"330\":1}}],[\"总而言之combiner被调用有两个条件\",{\"1\":{\"1494\":1}}],[\"总而言之\",{\"1\":{\"307\":1,\"479\":1,\"541\":1,\"581\":1,\"591\":1,\"596\":1,\"609\":1,\"657\":1,\"679\":1,\"1495\":1}}],[\"第八阶段\",{\"0\":{\"1870\":1}}],[\"第七阶段\",{\"0\":{\"1866\":1}}],[\"第六阶段\",{\"0\":{\"1862\":1}}],[\"第五阶段\",{\"0\":{\"1857\":1}}],[\"第四阶段\",{\"0\":{\"1854\":1}}],[\"第7\",{\"1\":{\"1847\":1}}],[\"第1次添加\",{\"1\":{\"1419\":1}}],[\"第三个map\",{\"1\":{\"1526\":1}}],[\"第三个是流的特性值\",{\"1\":{\"1499\":1}}],[\"第三个参数是下游收集器\",{\"1\":{\"1495\":1}}],[\"第三个条件是`table`的长度不能超过最大容量\",{\"1\":{\"1431\":1}}],[\"第三阶段\",{\"0\":{\"1851\":1},\"1\":{\"656\":1}}],[\"第三次被分配到id=4到id=7\",{\"1\":{\"629\":1}}],[\"第三次申请自增id\",{\"1\":{\"629\":1}}],[\"第三点\",{\"1\":{\"619\":1}}],[\"第三组六列\",{\"1\":{\"616\":1}}],[\"第三种情况是大事务\",{\"1\":{\"594\":1}}],[\"第三种方法是\",{\"1\":{\"485\":1,\"609\":1}}],[\"第三行是真实执行的语句\",{\"1\":{\"591\":1}}],[\"第三行的extra字段\",{\"1\":{\"551\":1}}],[\"第三步\",{\"1\":{\"505\":1,\"1425\":1}}],[\"第三句\",{\"1\":{\"483\":1}}],[\"第三大的正好是集合当中最小的元素\",{\"1\":{\"441\":1}}],[\"第三子树包含大于第二元素\",{\"1\":{\"348\":1}}],[\"第0位用来存储0的情况\",{\"1\":{\"431\":1}}],[\"第一本docker书\",{\"1\":{\"1844\":1}}],[\"第一阶段\",{\"0\":{\"1847\":1},\"1\":{\"656\":1}}],[\"第一点\",{\"1\":{\"619\":1}}],[\"第一组五列\",{\"1\":{\"616\":1}}],[\"第一列event\",{\"1\":{\"616\":1}}],[\"第一列的结果等于上一行的元素加上当前行的元素\",{\"1\":{\"426\":1}}],[\"第一行set\",{\"1\":{\"591\":1}}],[\"第一行显式优化器现在交易记录表tradelog上查到id=2的行\",{\"1\":{\"505\":1}}],[\"第一种确保主备无延迟的方法是\",{\"1\":{\"609\":1}}],[\"第一种思路是在proxy层的进程代码中实现排序\",{\"1\":{\"548\":1}}],[\"第一种情况是\",{\"1\":{\"480\":1,\"594\":1}}],[\"第一次申请到了id=1\",{\"1\":{\"629\":1}}],[\"第一次申请自增id\",{\"1\":{\"629\":1}}],[\"第一次打开表的时候\",{\"1\":{\"627\":1}}],[\"第一次从磁盘读入内存的数据页\",{\"1\":{\"543\":1}}],[\"第一次调用的是\",{\"1\":{\"459\":1}}],[\"第一步中\",{\"1\":{\"611\":1}}],[\"第一步\",{\"1\":{\"505\":1}}],[\"第一句是将查询日志的阈值设置为0\",{\"1\":{\"483\":1}}],[\"第一个参数是一个分类器\",{\"1\":{\"1495\":1}}],[\"第一个参数就是一个普通的变量\",{\"1\":{\"1470\":1}}],[\"第一个元素就已经满足了所有的操作\",{\"1\":{\"1489\":1}}],[\"第一个元素作为seed\",{\"1\":{\"1486\":1}}],[\"第一个条件是map\",{\"1\":{\"1431\":1}}],[\"第一个条件由于order\",{\"1\":{\"692\":1}}],[\"第一个insert语句插入数据成功后\",{\"1\":{\"631\":1}}],[\"第一个误解是\",{\"1\":{\"619\":1}}],[\"第一个箭头明显粗于第二个箭头\",{\"1\":{\"597\":1}}],[\"第一个事务写完redo\",{\"1\":{\"588\":1}}],[\"第一个被锁住的线程要过50s才会超时退出\",{\"1\":{\"581\":1}}],[\"第一个扫描地c行\",{\"1\":{\"559\":1}}],[\"第一个字段是double类型\",{\"1\":{\"557\":1}}],[\"第一个字是\",{\"1\":{\"477\":1}}],[\"第一个语句创建的index1索引里面\",{\"1\":{\"487\":1}}],[\"第一个循环\",{\"1\":{\"329\":1}}],[\"第一\",{\"1\":{\"397\":1}}],[\"第二条中提到\",{\"1\":{\"748\":1}}],[\"第二条语句才进入锁等待状态\",{\"1\":{\"561\":1}}],[\"第二阶段\",{\"0\":{\"1848\":1},\"1\":{\"656\":1}}],[\"第二次被分配了id=2和id=3\",{\"1\":{\"629\":1}}],[\"第二点\",{\"1\":{\"619\":1}}],[\"第二组六列\",{\"1\":{\"616\":1}}],[\"第二组事务才能开始执行\",{\"1\":{\"601\":1}}],[\"第二种方法是\",{\"1\":{\"609\":1}}],[\"第二种情况是\",{\"1\":{\"594\":1}}],[\"第二种思路的示意图如下\",{\"1\":{\"548\":1}}],[\"第二种思路是\",{\"1\":{\"548\":1}}],[\"第二个参数表示流的类型是引用类型的\",{\"1\":{\"1499\":1}}],[\"第二个参数是accumulator累加器的类型\",{\"1\":{\"1495\":1}}],[\"第二个参数是collector类型的\",{\"1\":{\"1495\":1}}],[\"第二个条件是`table`不为null\",{\"1\":{\"1431\":1}}],[\"第二个字段trx\",{\"1\":{\"634\":1}}],[\"第二个字段是varchar\",{\"1\":{\"557\":1}}],[\"第二个事务有可能比第一个事务先执行\",{\"1\":{\"597\":1}}],[\"第二个循环\",{\"1\":{\"329\":1}}],[\"第二行是一个begin\",{\"1\":{\"591\":1}}],[\"第二行的extra字段显示的是using\",{\"1\":{\"551\":1}}],[\"第二行的key=primary\",{\"1\":{\"551\":1}}],[\"第二行key=null\",{\"1\":{\"505\":1}}],[\"第二步\",{\"1\":{\"505\":1}}],[\"第二句\",{\"1\":{\"483\":1}}],[\"第二\",{\"1\":{\"397\":1,\"758\":2}}],[\"第二子树包含大于最小元素\",{\"1\":{\"348\":1}}],[\"896043488029600\",{\"1\":{\"1859\":1}}],[\"8904\",{\"1\":{\"531\":1}}],[\"8之前可以通过字节码的本地变量表来获取\",{\"1\":{\"1525\":1}}],[\"8以后可以获取方法的形参名称\",{\"1\":{\"1525\":1}}],[\"8提供的一个新的类\",{\"1\":{\"1495\":1}}],[\"8开始增加了若干个默认方法\",{\"1\":{\"1491\":1}}],[\"8才开始有的\",{\"1\":{\"1474\":1}}],[\"8新增的foreach方法\",{\"1\":{\"1470\":1}}],[\"8不会倒置\",{\"1\":{\"1427\":1}}],[\"8put方法的源代码如下\",{\"1\":{\"1426\":1}}],[\"8的eden内存\",{\"1\":{\"1541\":1}}],[\"8的concurrenthashmap的示意图如下\",{\"1\":{\"1431\":1}}],[\"8的实现\",{\"0\":{\"1431\":1}}],[\"8的实现中\",{\"1\":{\"1425\":1}}],[\"8的区别\",{\"1\":{\"1422\":1}}],[\"8在计算位置的时候采用方法一返回的哈希值\",{\"1\":{\"1425\":1}}],[\"8没有这个方法\",{\"1\":{\"1425\":1}}],[\"8中接口是又具体的方法实现\",{\"1\":{\"1470\":1}}],[\"8中concurrenthashmap放弃了hashentry结构而是采用了跟hashmap结构非常相似\",{\"1\":{\"1431\":1}}],[\"8中的concurrenthashmap放弃了jdk1\",{\"1\":{\"1431\":1}}],[\"8中对扩容做了一些优化\",{\"1\":{\"1427\":1}}],[\"8中\",{\"1\":{\"1423\":1,\"1425\":1,\"1427\":1}}],[\"8增加红黑树部分\",{\"1\":{\"1423\":1}}],[\"8增加的类\",{\"1\":{\"1357\":1}}],[\"8对hashmap底层的实现进行了优化\",{\"1\":{\"1422\":1}}],[\"8对hashmap有哪些优化\",{\"0\":{\"36\":1}}],[\"87\",{\"1\":{\"711\":2}}],[\"840\",{\"1\":{\"692\":2}}],[\"84\",{\"1\":{\"686\":1,\"688\":2}}],[\"8=\",{\"1\":{\"685\":1}}],[\"816f27d\",{\"1\":{\"1487\":1}}],[\"81\",{\"1\":{\"681\":1,\"686\":1,\"688\":1,\"747\":1}}],[\"838\",{\"1\":{\"666\":2}}],[\"850\",{\"1\":{\"1496\":2}}],[\"8575799808933029326l\",{\"1\":{\"1491\":1}}],[\"85\",{\"1\":{\"713\":1}}],[\"858\",{\"1\":{\"665\":3}}],[\"854\",{\"1\":{\"665\":2,\"1496\":1}}],[\"862\",{\"1\":{\"665\":3}}],[\"823\",{\"1\":{\"665\":3}}],[\"80\",{\"1\":{\"718\":1,\"747\":1,\"1490\":1,\"1492\":1,\"1493\":2}}],[\"807\",{\"1\":{\"665\":1}}],[\"8080\",{\"1\":{\"1410\":1,\"1411\":1}}],[\"808\",{\"1\":{\"665\":1}}],[\"8+6\",{\"1\":{\"640\":1}}],[\"8年后\",{\"1\":{\"634\":1}}],[\"88+12\",{\"1\":{\"540\":1}}],[\"8\",{\"1\":{\"329\":1,\"400\":1,\"467\":2,\"503\":3,\"505\":1,\"515\":1,\"629\":1,\"665\":4,\"666\":1,\"673\":1,\"685\":1,\"686\":1,\"688\":1,\"704\":7,\"710\":2,\"1352\":2,\"1425\":1,\"1451\":2,\"1452\":2,\"1471\":2,\"1472\":1,\"1474\":2,\"1475\":2,\"1476\":4,\"1477\":1,\"1478\":1,\"1482\":1,\"1484\":2,\"1497\":1}}],[\"9章讲述了\",{\"1\":{\"1847\":1}}],[\"93\",{\"1\":{\"711\":2}}],[\"94\",{\"1\":{\"692\":1}}],[\"98\",{\"1\":{\"685\":2}}],[\"9s\",{\"1\":{\"681\":1,\"684\":2,\"686\":2,\"690\":2,\"691\":2}}],[\"967\",{\"1\":{\"665\":1,\"667\":2}}],[\"9开始\",{\"1\":{\"562\":1}}],[\"90分以下的分成一组\",{\"1\":{\"1490\":1}}],[\"90分以上的分成一组\",{\"1\":{\"1490\":1}}],[\"90\",{\"1\":{\"710\":1,\"711\":2,\"1480\":2,\"1481\":2,\"1482\":1,\"1490\":3,\"1492\":2,\"1493\":1}}],[\"900\",{\"1\":{\"724\":1}}],[\"90000\",{\"1\":{\"659\":5}}],[\"900376\",{\"1\":{\"557\":1}}],[\"9098的内容\",{\"1\":{\"531\":1}}],[\"9098\",{\"1\":{\"531\":1}}],[\"97\",{\"1\":{\"556\":4,\"685\":2}}],[\"977\",{\"0\":{\"362\":1}}],[\"9999\",{\"1\":{\"666\":2}}],[\"99\",{\"1\":{\"496\":1,\"719\":1,\"720\":1}}],[\"95\",{\"1\":{\"487\":1,\"711\":1}}],[\"9\",{\"1\":{\"329\":4,\"388\":1,\"400\":1,\"467\":1,\"505\":1,\"515\":1,\"665\":2,\"681\":1,\"685\":1,\"688\":1,\"706\":1,\"707\":1,\"710\":1,\"711\":1,\"761\":1,\"1356\":1,\"1471\":2,\"1476\":2,\"1484\":1}}],[\"5f9512d5e401fd06fda0b2dd\",{\"1\":{\"1529\":1}}],[\"53d8d10a\",{\"1\":{\"1487\":1}}],[\"535字节\",{\"1\":{\"667\":2}}],[\"535\",{\"1\":{\"665\":1}}],[\"5倍\",{\"1\":{\"1419\":2}}],[\"5之后提供的sdk并发包也是以管程为基础的\",{\"1\":{\"1360\":1}}],[\"5之后版本做了重大的优化\",{\"1\":{\"1360\":1}}],[\"5之前\",{\"1\":{\"1360\":1}}],[\"5类型接口\",{\"0\":{\"1260\":1}}],[\"5efc2381f346fb1ae58925c1\",{\"1\":{\"806\":1}}],[\"5条记录\",{\"1\":{\"711\":1}}],[\"54s\",{\"1\":{\"708\":1}}],[\"541\",{\"0\":{\"384\":1}}],[\"58\",{\"1\":{\"686\":1}}],[\"58✖️1\",{\"1\":{\"686\":2}}],[\"58✖️0\",{\"1\":{\"686\":4}}],[\"55\",{\"1\":{\"686\":1,\"688\":2,\"690\":3}}],[\"551\",{\"1\":{\"665\":1}}],[\"5秒就可以在从库上拿到正确结果\",{\"1\":{\"608\":1}}],[\"5调整到最开始执行\",{\"1\":{\"596\":1}}],[\"5版本中引入了mdl\",{\"1\":{\"578\":1}}],[\"5版本开始称为了默认的存储引擎\",{\"1\":{\"454\":1}}],[\"5及以前的版本\",{\"1\":{\"571\":1}}],[\"520620\",{\"1\":{\"568\":1}}],[\"52105825\",{\"1\":{\"568\":1}}],[\"56\",{\"1\":{\"1482\":1}}],[\"56296725\",{\"1\":{\"568\":1}}],[\"567\",{\"1\":{\"531\":2}}],[\"507\",{\"1\":{\"665\":3}}],[\"5073\",{\"1\":{\"527\":1}}],[\"5061\",{\"1\":{\"656\":1}}],[\"50000000\",{\"1\":{\"1489\":1}}],[\"50000\",{\"1\":{\"484\":1,\"485\":1}}],[\"500\",{\"1\":{\"472\":2,\"473\":1,\"479\":1,\"713\":1,\"718\":1}}],[\"50\",{\"1\":{\"467\":2,\"672\":1,\"1480\":2,\"1481\":2,\"1482\":1}}],[\"51\",{\"1\":{\"692\":2}}],[\"516267\",{\"1\":{\"568\":1}}],[\"51279775\",{\"1\":{\"568\":1}}],[\"513\",{\"0\":{\"411\":1}}],[\"515\",{\"0\":{\"404\":1}}],[\"59\",{\"0\":{\"364\":1},\"1\":{\"666\":6,\"692\":5}}],[\"5\",{\"0\":{\"600\":1,\"602\":1,\"1267\":1},\"1\":{\"329\":3,\"400\":1,\"454\":1,\"472\":2,\"473\":2,\"475\":1,\"477\":2,\"479\":2,\"487\":1,\"498\":2,\"505\":1,\"508\":1,\"514\":4,\"515\":1,\"559\":1,\"567\":1,\"568\":3,\"583\":4,\"584\":33,\"585\":4,\"591\":2,\"596\":4,\"599\":3,\"629\":6,\"643\":2,\"659\":5,\"686\":1,\"690\":3,\"691\":2,\"692\":1,\"694\":1,\"704\":2,\"707\":2,\"708\":4,\"709\":2,\"710\":4,\"711\":5,\"715\":1,\"716\":1,\"1361\":1,\"1427\":1,\"1428\":2,\"1476\":8,\"1484\":3,\"1486\":1,\"1487\":1,\"1489\":2,\"1494\":3,\"1497\":1,\"1528\":1}}],[\"静态方法跳过\",{\"1\":{\"1525\":1}}],[\"静态方法引用\",{\"0\":{\"1480\":1},\"1\":{\"1479\":1}}],[\"静态属性跳过\",{\"1\":{\"1525\":1}}],[\"静态属性和静态方法会跳过\",{\"1\":{\"1525\":1}}],[\"静态初始化\",{\"1\":{\"329\":1}}],[\"静态内部类\",{\"0\":{\"277\":1}}],[\"数量少可能问题不大\",{\"1\":{\"763\":1}}],[\"数值没有被修改\",{\"1\":{\"718\":1}}],[\"数值类型\",{\"0\":{\"665\":1}}],[\"数字0\",{\"1\":{\"761\":1}}],[\"数字1表示\",{\"1\":{\"758\":1}}],[\"数字\",{\"1\":{\"664\":1}}],[\"数字分析法\",{\"1\":{\"332\":1}}],[\"数据访问\",{\"1\":{\"1861\":1}}],[\"数据传输\",{\"0\":{\"1811\":1}}],[\"数据和标签的个数应该相同\",{\"1\":{\"1497\":1}}],[\"数据实际上是存储在数组的偶数位置上\",{\"1\":{\"1497\":1}}],[\"数据透视图\",{\"1\":{\"1492\":1}}],[\"数据在内核缓冲区和用户缓冲区之间的cpu拷贝将其省略\",{\"1\":{\"1458\":1}}],[\"数据拷贝次数\",{\"1\":{\"1457\":1,\"1458\":1,\"1459\":1,\"1460\":1,\"1461\":1}}],[\"数据从通道读入缓冲区\",{\"1\":{\"1451\":1}}],[\"数据会先被拷贝到操作系统内核的缓冲区中\",{\"1\":{\"1438\":1}}],[\"数据元素数组\",{\"1\":{\"1379\":1}}],[\"数据\",{\"1\":{\"1351\":1}}],[\"数据绑定组件\",{\"0\":{\"1231\":1}}],[\"数据操作过程源码剖析\",{\"0\":{\"807\":1}}],[\"数据处理层\",{\"1\":{\"806\":1}}],[\"数据加热的含义就是在正式部署之前\",{\"1\":{\"770\":1}}],[\"数据预热\",{\"1\":{\"770\":1}}],[\"数据同步\",{\"0\":{\"751\":1}}],[\"数据冗余\",{\"1\":{\"744\":1}}],[\"数据的复制是单向的\",{\"1\":{\"743\":1}}],[\"数据的可靠性一般还是要优于可用性\",{\"1\":{\"596\":1}}],[\"数据安全性\",{\"1\":{\"732\":1}}],[\"数据集中不重复的元素的个数\",{\"1\":{\"714\":1}}],[\"数据是不能互通的\",{\"1\":{\"704\":1}}],[\"数据都是缓存在内存中\",{\"1\":{\"701\":1}}],[\"数据也是一种供需要用户共享的资源\",{\"1\":{\"670\":1}}],[\"数据状态的变更往往是有关联的\",{\"1\":{\"621\":1}}],[\"数据丢失\",{\"1\":{\"596\":1}}],[\"数据很可能悄悄地就不一致了\",{\"1\":{\"596\":1}}],[\"数据不一致的问题更容易被发现\",{\"1\":{\"596\":1}}],[\"数据本身是没有问题的\",{\"1\":{\"584\":1}}],[\"数据定义语句\",{\"1\":{\"574\":1}}],[\"数据总行数是10000\",{\"1\":{\"558\":1}}],[\"数据量小的那个表\",{\"1\":{\"540\":1}}],[\"数据准备如下\",{\"1\":{\"655\":1}}],[\"数据准备\",{\"1\":{\"498\":1,\"499\":1,\"500\":1,\"515\":1}}],[\"数据表空间\",{\"1\":{\"482\":1}}],[\"数据读入内存是需要占用buffer\",{\"1\":{\"480\":1}}],[\"数据读取操作的操作类型\",{\"1\":{\"466\":1}}],[\"数据库连接池是为了避免频繁地创建和销毁\",{\"1\":{\"1852\":1}}],[\"数据库特性和数据库连接池\",{\"1\":{\"1852\":1}}],[\"数据库\",{\"0\":{\"1851\":1}}],[\"数据库名\",{\"1\":{\"695\":1}}],[\"数据库中的情况\",{\"1\":{\"584\":1}}],[\"数据库需要合理地控制资源的访问规则\",{\"1\":{\"573\":1}}],[\"数据库锁的设计的初衷是处理并发问题\",{\"1\":{\"573\":1}}],[\"数据库里面它可能用到的回滚记录都必须保留\",{\"1\":{\"571\":1}}],[\"数据库里面会创建一个视图\",{\"1\":{\"570\":1}}],[\"数据库的crud操作\",{\"1\":{\"1852\":1}}],[\"数据库的事务隔离级别越严格\",{\"1\":{\"669\":1}}],[\"数据库的行为是有所不同的\",{\"1\":{\"570\":1}}],[\"数据库的慢查询日志中\",{\"1\":{\"459\":1}}],[\"数据库还维护着一个满足特定查找算法的数据结构\",{\"1\":{\"468\":1}}],[\"数据查询的类型\",{\"1\":{\"467\":1}}],[\"数据结构推荐大家看\",{\"1\":{\"1849\":1}}],[\"数据结构和算法\",{\"1\":{\"1844\":1}}],[\"数据结构上的限制\",{\"1\":{\"1497\":1}}],[\"数据结构如下\",{\"1\":{\"1379\":1}}],[\"数据结构优化的核心思路\",{\"1\":{\"328\":1}}],[\"数据结构\",{\"0\":{\"328\":1,\"1849\":1},\"1\":{\"328\":1,\"1380\":1}}],[\"数学和加密函数等\",{\"1\":{\"454\":1}}],[\"数学\",{\"0\":{\"436\":1}}],[\"数组本身也符合容器的定义\",{\"1\":{\"1495\":1}}],[\"数组对于处理器的缓存机制更加友好\",{\"1\":{\"1396\":1}}],[\"数组对象才有\",{\"1\":{\"1361\":1}}],[\"数组长度2n\",{\"1\":{\"1396\":1}}],[\"数组长度\",{\"1\":{\"1361\":2}}],[\"数组未初始化\",{\"1\":{\"1357\":1}}],[\"数组中的单元cell\",{\"1\":{\"1357\":1}}],[\"数组槽\",{\"1\":{\"1357\":1}}],[\"数组类型\",{\"1\":{\"1357\":1}}],[\"数组的缺点\",{\"1\":{\"1415\":1}}],[\"数组的内容\",{\"1\":{\"1404\":1}}],[\"数组的底层实现\",{\"1\":{\"1352\":1}}],[\"数组的查询的时间复杂度o\",{\"1\":{\"329\":1}}],[\"数组查找公式\",{\"1\":{\"1352\":1}}],[\"数组里最小的id为min\",{\"1\":{\"679\":1}}],[\"数组题目总结\",{\"0\":{\"369\":1}}],[\"数组\",{\"0\":{\"329\":1,\"358\":1},\"1\":{\"1357\":2,\"1431\":1,\"1496\":1}}],[\"线上环境不建议使用\",{\"1\":{\"724\":1}}],[\"线性结构\",{\"1\":{\"328\":1}}],[\"线程状态\",{\"0\":{\"1692\":1}}],[\"线程的实现\",{\"0\":{\"1690\":1}}],[\"线程上下文类加载器\",{\"0\":{\"1572\":1}}],[\"线程消耗\",{\"1\":{\"1450\":1}}],[\"线程一被调度回来执行\",{\"1\":{\"1428\":1}}],[\"线程本地存储模式本质上就是一种避免共享的方法\",{\"1\":{\"1405\":1}}],[\"线程本地存储模式\",{\"1\":{\"1405\":1}}],[\"线程安全性\",{\"0\":{\"1428\":1}}],[\"线程安全\",{\"0\":{\"1693\":1},\"1\":{\"1403\":1,\"1416\":1}}],[\"线程安全的实现方法有哪些\",{\"0\":{\"68\":1}}],[\"线程会因为竞争不到锁而被挂起\",{\"1\":{\"1396\":1}}],[\"线程会从其他繁忙线程双端队列的尾部中获取任务\",{\"1\":{\"1388\":1}}],[\"线程数就随之减少\",{\"1\":{\"1387\":1}}],[\"线程数就随之增加\",{\"1\":{\"1387\":1}}],[\"线程数=cpu核心线程数∗\",{\"1\":{\"1387\":1}}],[\"线程数计算方法\",{\"1\":{\"1387\":1}}],[\"线程数过高\",{\"1\":{\"613\":1}}],[\"线程t才能获取写锁进行数据更新\",{\"1\":{\"1375\":1}}],[\"线程进入写锁的前提条件\",{\"1\":{\"1375\":1}}],[\"线程进入读锁的前提条件\",{\"1\":{\"1375\":1}}],[\"线程竞争锁失败入队阻塞逻辑和获取锁的线程释放锁唤醒阻塞线程竞争锁的逻辑实现\",{\"1\":{\"1371\":1}}],[\"线程由原自旋机制改为阻塞机制\",{\"1\":{\"1368\":1}}],[\"线程逃逸\",{\"1\":{\"1365\":1}}],[\"线程持有的锁\",{\"1\":{\"1361\":1}}],[\"线程\",{\"1\":{\"1361\":1,\"1541\":1}}],[\"线程真正创建线程的过程如下\",{\"1\":{\"1354\":1}}],[\"线程互斥可以看成是一种特殊的线程同步\",{\"1\":{\"1354\":1}}],[\"线程互斥是指对于共享的进程系统资源\",{\"1\":{\"1354\":1}}],[\"线程同步\",{\"1\":{\"1354\":1}}],[\"线程是cpu调度的最小单位\",{\"1\":{\"1354\":1}}],[\"线程工厂模式\",{\"1\":{\"1411\":1}}],[\"线程工厂\",{\"1\":{\"1353\":1}}],[\"线程就可以继续挨个处理相应的事件\",{\"1\":{\"740\":1}}],[\"线程处于阻塞状态\",{\"1\":{\"740\":1}}],[\"线程处于空闲状态\",{\"1\":{\"613\":1}}],[\"线程也应该得到通知\",{\"1\":{\"740\":1}}],[\"线程如何得到通知\",{\"1\":{\"740\":1}}],[\"线程如何知道何时才应该继续\",{\"1\":{\"740\":1}}],[\"线程才能继续处理\",{\"1\":{\"739\":1}}],[\"线程2\",{\"1\":{\"718\":2}}],[\"线程2到线程129都执行update\",{\"1\":{\"613\":1}}],[\"线程1事务执行失败\",{\"1\":{\"718\":1}}],[\"线程1\",{\"1\":{\"718\":1}}],[\"线程1执行begin\",{\"1\":{\"613\":1}}],[\"线程没有执行到判断线程状态的逻辑\",{\"1\":{\"618\":1}}],[\"线程b并不知道这个状态变化\",{\"1\":{\"618\":1}}],[\"线程id\",{\"1\":{\"549\":1,\"617\":2}}],[\"线程池隔离\",{\"1\":{\"1394\":1}}],[\"线程池参数解析\",{\"1\":{\"1353\":1}}],[\"线程池执行过程示意图\",{\"1\":{\"1353\":1}}],[\"线程池底层原理\",{\"0\":{\"1353\":1},\"1\":{\"1353\":1}}],[\"线程池的原理等\",{\"1\":{\"1870\":1}}],[\"线程池的参数如何设置\",{\"0\":{\"89\":1}}],[\"线程池的拒绝策略\",{\"0\":{\"86\":1}}],[\"线程池中submit\",{\"0\":{\"84\":1}}],[\"线程有哪些状态\",{\"0\":{\"54\":1}}],[\"线程和进程的区别\",{\"0\":{\"50\":1}}],[\"道股票问题\",{\"1\":{\"327\":1}}],[\"股票问题\",{\"0\":{\"327\":1}}],[\"求最大值和最小值有可能为空\",{\"1\":{\"1487\":1}}],[\"求最值\",{\"1\":{\"326\":1}}],[\"求解\",{\"1\":{\"1387\":1}}],[\"求setx\",{\"1\":{\"709\":1}}],[\"求\",{\"1\":{\"709\":1}}],[\"求出他们的最大值\",{\"1\":{\"367\":1}}],[\"求图中的最小生成树\",{\"1\":{\"293\":1}}],[\"状态就不再发生变化\",{\"1\":{\"1403\":1}}],[\"状态模式\",{\"0\":{\"1012\":1}}],[\"状态统计\",{\"1\":{\"715\":1}}],[\"状态的\",{\"1\":{\"601\":1}}],[\"状态图如下\",{\"1\":{\"587\":1}}],[\"状态\",{\"1\":{\"463\":1,\"613\":1}}],[\"状态转移方程\",{\"1\":{\"432\":1}}],[\"状态转移方程为\",{\"1\":{\"431\":1}}],[\"状态转移方程如下\",{\"1\":{\"427\":1}}],[\"状态转移方程或者dp方程\",{\"1\":{\"325\":1}}],[\"状态2的所有取值\",{\"1\":{\"326\":1}}],[\"状态2\",{\"1\":{\"326\":2}}],[\"状态1的所有取值\",{\"1\":{\"326\":1}}],[\"状态1\",{\"1\":{\"326\":2}}],[\"递增\",{\"1\":{\"708\":1}}],[\"递推开始\",{\"1\":{\"428\":1}}],[\"递推公式\",{\"1\":{\"325\":1,\"425\":1}}],[\"递归查找合并\",{\"1\":{\"1524\":1}}],[\"递归方程为\",{\"1\":{\"426\":1}}],[\"递归是解决树的最重要的方法\",{\"1\":{\"413\":1}}],[\"递归法\",{\"1\":{\"410\":1}}],[\"递归即可\",{\"1\":{\"405\":1}}],[\"递归解法\",{\"1\":{\"396\":1,\"403\":1,\"411\":1}}],[\"递归等方式\",{\"1\":{\"337\":1}}],[\"递归的终止条件\",{\"1\":{\"285\":1,\"288\":1}}],[\"递归从某种意义上来说和循环是等价的\",{\"1\":{\"284\":1}}],[\"递归\",{\"0\":{\"283\":1},\"1\":{\"409\":1}}],[\"存放类的属性数据信息\",{\"1\":{\"1361\":1}}],[\"存放在进入或重新进入时被阻塞\",{\"1\":{\"1360\":1}}],[\"存放记录的数组叫做哈希表\",{\"1\":{\"332\":1}}],[\"存入beandefitionmap\",{\"1\":{\"1528\":1}}],[\"存入join\",{\"1\":{\"544\":1}}],[\"存入sort\",{\"1\":{\"491\":1,\"492\":1,\"657\":1}}],[\"存起来的binlog里面就没有这条语句\",{\"1\":{\"464\":1}}],[\"存储过程以及高级映射\",{\"1\":{\"1860\":1}}],[\"存储过程idata\",{\"1\":{\"537\":1}}],[\"存储系统\",{\"1\":{\"1853\":1}}],[\"存储位映射\",{\"0\":{\"1788\":1}}],[\"存储位置\",{\"1\":{\"332\":1}}],[\"存储在mergedbeandefinitions这个map中\",{\"1\":{\"1524\":1}}],[\"存储方式\",{\"0\":{\"1423\":1}}],[\"存储元素\",{\"1\":{\"1380\":1}}],[\"存储锁对象\",{\"1\":{\"1360\":1}}],[\"存储粒度上执行\",{\"1\":{\"1351\":1}}],[\"存储\",{\"1\":{\"1350\":1}}],[\"存储效率并不高\",{\"1\":{\"764\":1}}],[\"存储空对象也需要空间\",{\"1\":{\"764\":1}}],[\"存储用户的id\",{\"1\":{\"714\":1}}],[\"存储班级成绩表\",{\"1\":{\"711\":1}}],[\"存储结果到及和张\",{\"1\":{\"709\":1}}],[\"存储结果到集合中\",{\"1\":{\"709\":1}}],[\"存储引擎层\",{\"1\":{\"694\":1}}],[\"存储数据的结构\",{\"1\":{\"469\":1}}],[\"存储上一个节点的值\",{\"1\":{\"397\":1}}],[\"存储最小值的栈\",{\"1\":{\"392\":1}}],[\"存储中间状态\",{\"1\":{\"325\":1}}],[\"存在则将map中的list对象取出来\",{\"1\":{\"1490\":1}}],[\"存在守护条件\",{\"1\":{\"1408\":1}}],[\"存在用户态和内核态切换\",{\"1\":{\"1362\":1}}],[\"存在老版本redis服务无法兼容rdb格式的问题\",{\"1\":{\"727\":1}}],[\"存在\",{\"1\":{\"706\":1,\"710\":1}}],[\"存在两个问题\",{\"1\":{\"609\":1}}],[\"存在redo\",{\"1\":{\"588\":1}}],[\"存在比其小的数\",{\"1\":{\"319\":1}}],[\"存在上下界\",{\"1\":{\"304\":1}}],[\"存在返回不存在返回null\",{\"1\":{\"302\":1}}],[\"关闭这个流\",{\"1\":{\"1496\":1}}],[\"关闭通道\",{\"1\":{\"1464\":1,\"1465\":1}}],[\"关闭socket\",{\"1\":{\"1410\":1,\"1411\":1}}],[\"关闭锁消除\",{\"1\":{\"1364\":1}}],[\"关闭延迟开启偏向锁\",{\"1\":{\"1362\":1}}],[\"关闭连接\",{\"1\":{\"719\":1}}],[\"关闭trace\",{\"1\":{\"656\":1,\"657\":1}}],[\"关联字段加索引\",{\"1\":{\"662\":1}}],[\"关掉12号线程的网络连接\",{\"1\":{\"618\":1}}],[\"关于元空间的jvm参数\",{\"1\":{\"1541\":1}}],[\"关于关闭处理器可以举一个简单的例子\",{\"1\":{\"1496\":1}}],[\"关于分组的方法还有另外的说明\",{\"1\":{\"1495\":1}}],[\"关于predicate的三个默认方法\",{\"1\":{\"1476\":1}}],[\"关于函数式接口的定义如下\",{\"1\":{\"1471\":1}}],[\"关于lambda表达式的创建会在后续的文章中详细讲解\",{\"1\":{\"1471\":1}}],[\"关于句柄的解释\",{\"1\":{\"1438\":1}}],[\"关于hashmap的容量为什么是2的幂次方\",{\"1\":{\"1423\":1}}],[\"关于主内存和工作内存之间的具体交互协议\",{\"1\":{\"1350\":1}}],[\"关于georadius的参数\",{\"1\":{\"713\":1}}],[\"关于重命名rename和renamenx\",{\"1\":{\"706\":1}}],[\"关于ttl命令\",{\"1\":{\"706\":1}}],[\"关于这个过程的说明\",{\"1\":{\"622\":1}}],[\"关于幻读的两点说明\",{\"1\":{\"583\":1}}],[\"关于临时表中数据的存放方式\",{\"1\":{\"549\":1}}],[\"关于join语句使用的问题\",{\"1\":{\"537\":1}}],[\"关于我\",{\"0\":{\"5\":1}}],[\"关键的部分在于\",{\"1\":{\"1495\":1}}],[\"关键就在于需要执行的finisher方法\",{\"1\":{\"1495\":1}}],[\"关键字识别出来\",{\"1\":{\"457\":1}}],[\"关键字所对应的记录位置称为散列地址\",{\"1\":{\"332\":1}}],[\"关键字\",{\"1\":{\"332\":1}}],[\"关键点\",{\"1\":{\"325\":1}}],[\"插入完之后\",{\"1\":{\"1431\":1}}],[\"插入链表尾部\",{\"1\":{\"1431\":1}}],[\"插入成功后\",{\"1\":{\"1426\":1}}],[\"插入元素等相对复杂\",{\"1\":{\"1415\":1}}],[\"插入ins\",{\"1\":{\"708\":1}}],[\"插入空格进行补充保存\",{\"1\":{\"667\":1}}],[\"插入或删除表数据行的时候同时维护计数表\",{\"1\":{\"663\":1}}],[\"插入或删除数据行的时候同时维护redis里面的表总行数key的计数值\",{\"1\":{\"663\":1}}],[\"插入两条记录\",{\"1\":{\"629\":1}}],[\"插入了\",{\"1\":{\"629\":1}}],[\"插入了1000行数据\",{\"1\":{\"541\":1}}],[\"插入了10万行数据\",{\"1\":{\"483\":1}}],[\"插入的字符数不足n时不会补充空格\",{\"1\":{\"667\":1}}],[\"插入的行是\",{\"1\":{\"628\":1}}],[\"插入的结点都是红色\",{\"1\":{\"345\":1}}],[\"插入记录时使用\",{\"1\":{\"579\":1}}],[\"插入意向gap锁\",{\"1\":{\"579\":1}}],[\"插入一些示例数据\",{\"1\":{\"660\":1}}],[\"插入一部分数据后\",{\"1\":{\"555\":1}}],[\"插入一行数据\",{\"1\":{\"627\":1}}],[\"插入一行记录后\",{\"1\":{\"533\":1}}],[\"插入一行后记录后\",{\"1\":{\"533\":1}}],[\"插入临时表成功\",{\"1\":{\"551\":1}}],[\"插入数据\",{\"1\":{\"515\":1,\"671\":1}}],[\"插入这个值\",{\"1\":{\"480\":1}}],[\"插入新记录的时候可以不指定id的值\",{\"1\":{\"472\":1}}],[\"插入操作包括两部分工作\",{\"1\":{\"345\":1}}],[\"插入和删除的时间复杂度均为o\",{\"1\":{\"341\":1}}],[\"插入\",{\"1\":{\"319\":1,\"329\":1,\"330\":1}}],[\"插入排序\",{\"0\":{\"319\":1},\"1\":{\"316\":1}}],[\"解密\",{\"1\":{\"1387\":1}}],[\"解锁\",{\"1\":{\"1350\":1,\"1380\":1}}],[\"解锁获取最新值\",{\"1\":{\"718\":1}}],[\"解析字节流\",{\"1\":{\"1565\":1}}],[\"解析和初始化过\",{\"1\":{\"1543\":1}}],[\"解析和序列化\",{\"0\":{\"829\":1}}],[\"解析\",{\"0\":{\"1667\":1,\"1684\":1},\"1\":{\"1540\":2}}],[\"解析配置类\",{\"1\":{\"1528\":1}}],[\"解析spring表达式\",{\"1\":{\"1525\":1}}],[\"解析sql\",{\"1\":{\"806\":1}}],[\"解析到的所有对象的数据会存储到\",{\"1\":{\"806\":1}}],[\"解析过程\",{\"1\":{\"806\":1}}],[\"解析binlog\",{\"1\":{\"599\":1}}],[\"解析出日志里的命令\",{\"1\":{\"590\":1}}],[\"解决循环依赖\",{\"1\":{\"1526\":1}}],[\"解决事务失效的核心思路\",{\"1\":{\"1507\":1}}],[\"解决办法\",{\"1\":{\"1413\":3}}],[\"解决线程之间的协作不可避免会用到阻塞唤醒机制\",{\"1\":{\"1407\":1}}],[\"解决并发问题的方法\",{\"1\":{\"1545\":1}}],[\"解决并发问题\",{\"1\":{\"1403\":1}}],[\"解决并发扫描时对象消失问题的两种方案\",{\"0\":{\"120\":1}}],[\"解决这个缺陷的方式就是设置较短过期时间\",{\"1\":{\"764\":1}}],[\"解决这个问题通常来说有两种方式\",{\"1\":{\"489\":1}}],[\"解决这个问题通常有两种方案\",{\"1\":{\"455\":1}}],[\"解决方案\",{\"0\":{\"764\":1,\"767\":1,\"770\":1,\"893\":1}}],[\"解决此类问题也可以使用平方根法\",{\"1\":{\"439\":1}}],[\"解法3\",{\"1\":{\"319\":1}}],[\"解法2\",{\"1\":{\"319\":1}}],[\"解法1\",{\"1\":{\"319\":1}}],[\"将项目部署在服务器\",{\"1\":{\"1865\":1}}],[\"将响应字节流写会给浏览器\",{\"1\":{\"1565\":1}}],[\"将tomcat\",{\"1\":{\"1565\":2}}],[\"将template\",{\"1\":{\"720\":1}}],[\"将符号引用替换为直接引用\",{\"1\":{\"1540\":1}}],[\"将在处理程序执行的任何结果上调用\",{\"1\":{\"1534\":1}}],[\"将代理对象暴露在threadlocal中\",{\"1\":{\"1531\":1}}],[\"将代理对象的target属性赋值为ioc容器中的普通对象\",{\"1\":{\"1507\":1}}],[\"将扫描到的beanpostprocessors实例化并排序\",{\"1\":{\"1528\":1}}],[\"将扫描到的每个元素插入有序序列的适当位置\",{\"1\":{\"319\":1}}],[\"将value转化为descriptor所对应的类型\",{\"1\":{\"1525\":1}}],[\"将加载到的class对象设置给beanclass属性\",{\"1\":{\"1524\":1}}],[\"将父beandefinition的属性继承\",{\"1\":{\"1524\":1}}],[\"将beandefinition注册到beandefinitionmap中\",{\"1\":{\"1524\":1}}],[\"将binlog的格式修改为binlog\",{\"1\":{\"591\":1}}],[\"将user\",{\"1\":{\"1510\":1}}],[\"将从spliterator获取到元素推送到sink当中\",{\"1\":{\"1500\":1}}],[\"将pipelinehelper所描述的管道阶段应用到所提供的spliterator同时把结果发送给提供的sink\",{\"1\":{\"1500\":1}}],[\"将中间操作串联起来\",{\"1\":{\"1500\":1}}],[\"将尝试着计算他们的值使用给定的映射方法\",{\"1\":{\"1495\":1}}],[\"将要被映射的值\",{\"1\":{\"1495\":1}}],[\"将要解决的问题划分为若干规模较小的同类问题\",{\"1\":{\"1387\":1}}],[\"将接收的u类型映射为t类型\",{\"1\":{\"1495\":1}}],[\"将需要的属性和方法定义好\",{\"1\":{\"1493\":1}}],[\"将累积的结果转换为一个最终的表示\",{\"1\":{\"1492\":1}}],[\"将集合中的元素映射成后面表达式的结果的操作\",{\"1\":{\"1486\":1}}],[\"将集合中的字符串传化为大写并打印\",{\"1\":{\"1486\":1}}],[\"将流中的元素依次添加到我们新new出来的arraylist当中\",{\"1\":{\"1485\":1}}],[\"将list这个集合转化为了stream\",{\"1\":{\"1470\":1}}],[\"将文件内容通过网络传输给客户端\",{\"1\":{\"1457\":1}}],[\"将原来的nio类库进行了升级\",{\"1\":{\"1449\":2}}],[\"将用户关系的文件描述符的时间存放到内核的一个事件表中\",{\"1\":{\"1448\":1}}],[\"将请求处理任务提交给线程池\",{\"1\":{\"1411\":1}}],[\"将终止过程分成两个阶段\",{\"1\":{\"1401\":1}}],[\"将询价结果异步保存到数据库\",{\"1\":{\"1394\":1}}],[\"将大的任务分割为更小力度的小任务\",{\"1\":{\"1391\":1}}],[\"将大查询切分成小查询\",{\"1\":{\"530\":1}}],[\"将由设定的处理器处理\",{\"1\":{\"1387\":1}}],[\"将子问题的解逐层合并构成原问题的解\",{\"1\":{\"1387\":1}}],[\"将同步器所有调用都映射到sync对应的方法\",{\"1\":{\"1367\":1}}],[\"将堆分配转化为栈分配\",{\"1\":{\"1365\":1}}],[\"将会产生一个结果或者是有副作用的\",{\"1\":{\"1496\":1}}],[\"将会扩大加锁同步的范围\",{\"1\":{\"1363\":1}}],[\"将会去调用这个脚本\",{\"1\":{\"761\":1}}],[\"将线程的中断标志和设置为true\",{\"1\":{\"1354\":1}}],[\"将他们抽取出来作为最基础的组件\",{\"1\":{\"806\":1}}],[\"将传给脚本两个参数\",{\"1\":{\"761\":1}}],[\"将传入的行的值改成\",{\"1\":{\"628\":1}}],[\"将redis执行过的所有指令记录下来\",{\"1\":{\"728\":1}}],[\"将read\",{\"1\":{\"541\":1}}],[\"将多个\",{\"1\":{\"714\":1}}],[\"将具体经纬度的坐标存入一个有序集合\",{\"1\":{\"713\":1}}],[\"将成员m2的score\",{\"1\":{\"711\":1}}],[\"将哈希表\",{\"1\":{\"710\":1}}],[\"将结果交给thenacceptboth消耗\",{\"1\":{\"1395\":1}}],[\"将结果保存到集合中\",{\"1\":{\"709\":1}}],[\"将结果归并起来\",{\"1\":{\"322\":1}}],[\"将下标3的元素\",{\"1\":{\"708\":1}}],[\"将列表的尾部\",{\"1\":{\"708\":1}}],[\"将给定\",{\"1\":{\"707\":1}}],[\"将指定key的value数值进行+1\",{\"1\":{\"707\":1}}],[\"将\",{\"1\":{\"706\":1,\"1431\":1}}],[\"将键值对移动到指定数据库\",{\"1\":{\"706\":2}}],[\"将默认使用系统变量innodb\",{\"1\":{\"695\":1}}],[\"将controller交由spring\",{\"1\":{\"1536\":1}}],[\"将cost\",{\"1\":{\"694\":1}}],[\"将change\",{\"1\":{\"480\":1}}],[\"将上述中猜的过程称之为condition\",{\"1\":{\"691\":1}}],[\"将上述两个动作记入redo\",{\"1\":{\"482\":1}}],[\"将使用index\",{\"1\":{\"690\":1}}],[\"将score相加作为结果的score\",{\"1\":{\"711\":1}}],[\"将studentx哈希表作为一个对象\",{\"1\":{\"710\":1}}],[\"将set还原到\",{\"1\":{\"709\":1}}],[\"将source集合的成员member移动到destination集合\",{\"1\":{\"709\":1}}],[\"将sql改写如下\",{\"1\":{\"659\":1}}],[\"将sync\",{\"1\":{\"587\":2,\"588\":1}}],[\"将表的自增值改成3\",{\"1\":{\"628\":1}}],[\"将表t2中满足条件的数据放在临时表tmp\",{\"1\":{\"544\":1}}],[\"将表t1的数据读入线程内存join\",{\"1\":{\"540\":1}}],[\"将自增值的变更记录在了redo\",{\"1\":{\"627\":1}}],[\"将变量killed赋值为thd\",{\"1\":{\"618\":1}}],[\"将并发线程的计数减1的设计\",{\"1\":{\"613\":1}}],[\"将查询请求做分类\",{\"1\":{\"607\":1}}],[\"将查询分解后\",{\"1\":{\"531\":1}}],[\"将实例a\",{\"1\":{\"605\":1}}],[\"将20个主库放在4台机器上\",{\"1\":{\"594\":1}}],[\"将m类型强转为<k\",{\"1\":{\"1495\":1}}],[\"将map中的键值对替换\",{\"1\":{\"1495\":1}}],[\"将mathscore\",{\"1\":{\"711\":1}}],[\"将master\",{\"1\":{\"591\":1}}],[\"将myset中m3成员移动到newset集合\",{\"1\":{\"709\":1}}],[\"将mylist的最后一个值\",{\"1\":{\"708\":1}}],[\"将myisam分区表标记为deprecated\",{\"1\":{\"562\":1}}],[\"将int常量1压入操作数栈\",{\"1\":{\"1359\":2}}],[\"将innodb的并发线程上限设置为2\",{\"1\":{\"618\":1}}],[\"将innodb\",{\"1\":{\"588\":1}}],[\"将identity\",{\"1\":{\"1495\":1}}],[\"将id\",{\"1\":{\"555\":1}}],[\"将id值放入read\",{\"1\":{\"541\":1}}],[\"将启动参数transaction\",{\"1\":{\"570\":1}}],[\"将1改成2\",{\"1\":{\"570\":1}}],[\"将分库执行的结果插入到temp\",{\"1\":{\"548\":1}}],[\"将各个分库拿到的数据\",{\"1\":{\"548\":1}}],[\"将计数保存在缓存系统中的方式\",{\"1\":{\"534\":1}}],[\"将一个大表ht\",{\"1\":{\"548\":1}}],[\"将一个大的delete语句切分成多个较小的查询可以尽可能小地影响mysql性能\",{\"1\":{\"530\":1}}],[\"将一个大查询分解为多个小查询是很有必要的\",{\"1\":{\"529\":1}}],[\"将一个数组分成两个子数组分别进行排序\",{\"1\":{\"323\":1}}],[\"将这条语句的执行时间设置为100秒\",{\"1\":{\"561\":1}}],[\"将这个例子做如下修改\",{\"1\":{\"1489\":1}}],[\"将这个临时实例设置成线上备库的从库\",{\"1\":{\"622\":1}}],[\"将这个时间的值设置的很小也不行\",{\"1\":{\"581\":1}}],[\"将这个命令重写后再传到备库执行\",{\"1\":{\"550\":1}}],[\"将这个操作记录到磁盘里面\",{\"1\":{\"461\":1}}],[\"将这行记录加入结果集\",{\"1\":{\"487\":2}}],[\"将语句修改为order\",{\"1\":{\"485\":1}}],[\"将更新先记录在change\",{\"1\":{\"481\":1}}],[\"将其beanname缓存起来\",{\"1\":{\"1525\":1}}],[\"将其epoch字段改为新值\",{\"1\":{\"1362\":1}}],[\"将其整体读入内存\",{\"1\":{\"479\":1}}],[\"将其映射到原矩阵的行和列上\",{\"1\":{\"443\":1}}],[\"将数字转成字符串\",{\"1\":{\"513\":1}}],[\"将数据库连接conn放入threadlocal\",{\"1\":{\"1532\":1}}],[\"将数据库快照保存在名字为\",{\"1\":{\"723\":1}}],[\"将数据从kernel拷贝到用户进程\",{\"1\":{\"1442\":1}}],[\"将数据从内核拷贝至进程中\",{\"1\":{\"1438\":1}}],[\"将数据从磁盘读入内存涉及随机io的访问\",{\"1\":{\"480\":1}}],[\"将数据转移到新的entry数组里\",{\"1\":{\"1427\":1}}],[\"将数据页读入内存\",{\"1\":{\"480\":1}}],[\"将数据存储在了b+树中\",{\"1\":{\"472\":1}}],[\"将数组拆分成两半\",{\"1\":{\"322\":1}}],[\"将备份的binlog依次取出来\",{\"1\":{\"464\":1}}],[\"将矩阵每一行拼接在上一行的末尾\",{\"1\":{\"443\":1}}],[\"将格子标记为\",{\"1\":{\"435\":1}}],[\"将新元素加入优先队列\",{\"1\":{\"393\":1}}],[\"将第一次的答案添加到结果当中\",{\"1\":{\"393\":1}}],[\"将排序之后的字符串作为key\",{\"1\":{\"380\":1}}],[\"将非零数移动到index处\",{\"1\":{\"365\":1}}],[\"将它与数组的第二个元素交换\",{\"1\":{\"318\":1}}],[\"将它和数组的第一个元素交换位置\",{\"1\":{\"318\":1}}],[\"冒泡排序\",{\"0\":{\"317\":1},\"1\":{\"316\":1}}],[\"十大经典排序算法\",{\"1\":{\"316\":1}}],[\"清除算法\",{\"0\":{\"1598\":1}}],[\"清空所有数据库的键值对\",{\"1\":{\"704\":1}}],[\"清空当前数据库中的键值对\",{\"1\":{\"704\":1}}],[\"清空join\",{\"1\":{\"540\":1}}],[\"清楚了order\",{\"1\":{\"559\":1}}],[\"清零最低位的1\",{\"1\":{\"315\":1}}],[\"清理当前状态集\",{\"1\":{\"288\":1}}],[\"x最新完整教程\",{\"1\":{\"1864\":1}}],[\"xss\",{\"1\":{\"1541\":1}}],[\"xss512k\",{\"1\":{\"1541\":1}}],[\"x传入的是1\",{\"1\":{\"1431\":1}}],[\"x86\",{\"1\":{\"1356\":3}}],[\"x80\",{\"1\":{\"715\":1}}],[\"x后默认使用lettuce来替换jedis\",{\"1\":{\"720\":1}}],[\"x后\",{\"1\":{\"720\":1}}],[\"xx\",{\"1\":{\"719\":2,\"720\":1,\"1361\":1,\"1362\":5,\"1364\":2,\"1541\":11,\"1546\":2}}],[\"xxx\",{\"1\":{\"486\":1,\"487\":3,\"488\":2,\"719\":2,\"720\":1,\"758\":1,\"1515\":1}}],[\"xxxxxxxyyyyyyzzzzz\",{\"1\":{\"478\":1}}],[\"xa2\",{\"1\":{\"715\":1}}],[\"xor\",{\"1\":{\"715\":1}}],[\"xg\",{\"1\":{\"711\":4}}],[\"xh\",{\"1\":{\"711\":4}}],[\"xmn\",{\"1\":{\"1541\":1}}],[\"xmn1024m\",{\"1\":{\"1541\":1}}],[\"xmx\",{\"1\":{\"1541\":1}}],[\"xmx2048m\",{\"1\":{\"1541\":1}}],[\"xms\",{\"1\":{\"1541\":1}}],[\"xms2048m\",{\"1\":{\"1541\":1}}],[\"xm\",{\"1\":{\"711\":4}}],[\"xmlbeandefinitionreader可以用来解析\",{\"1\":{\"1511\":1}}],[\"xmlbeandefinitionreader\",{\"0\":{\"1511\":1},\"1\":{\"1511\":4}}],[\"xml元素\",{\"0\":{\"1191\":1}}],[\"xml资源的方式\",{\"0\":{\"1186\":1}}],[\"xml标签有哪些\",{\"0\":{\"991\":1}}],[\"xml配置文件来加深对tomcat架构的理解\",{\"1\":{\"1561\":1}}],[\"xml配置驱动实现\",{\"0\":{\"978\":1}}],[\"xml配置after\",{\"0\":{\"935\":1}}],[\"xml配置around\",{\"0\":{\"930\":1}}],[\"xml配置before\",{\"0\":{\"932\":1}}],[\"xml配置pointcut\",{\"0\":{\"927\":1}}],[\"xmlscriptbuilder\",{\"1\":{\"806\":1}}],[\"xmltags\",{\"1\":{\"806\":1}}],[\"xml\",{\"0\":{\"1191\":1,\"1197\":1},\"1\":{\"280\":1,\"1511\":1,\"1561\":1,\"1858\":1,\"1860\":1}}],[\"x这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分\",{\"1\":{\"694\":1}}],[\"xyz\",{\"1\":{\"691\":9}}],[\"xid只需要不在同一个binlog文件中出现重复值接口\",{\"1\":{\"636\":1}}],[\"xid是由server层维护的\",{\"1\":{\"634\":1}}],[\"xid和innodb的trx\",{\"1\":{\"634\":1}}],[\"xid一定是唯一的\",{\"1\":{\"633\":1}}],[\"xid\",{\"0\":{\"633\":1}}],[\"x=\",{\"1\":{\"559\":1}}],[\"x==1\",{\"1\":{\"438\":1}}],[\"x+n\",{\"1\":{\"491\":1}}],[\"x为常数\",{\"1\":{\"438\":1}}],[\"xnode\",{\"1\":{\"806\":2}}],[\"xn\",{\"1\":{\"438\":1}}],[\"x>>1\",{\"1\":{\"315\":1}}],[\"x^x\",{\"1\":{\"314\":1}}],[\"x^\",{\"1\":{\"314\":1}}],[\"x^1s\",{\"1\":{\"314\":1}}],[\"x^0\",{\"1\":{\"314\":1}}],[\"x\",{\"1\":{\"314\":1,\"315\":15,\"356\":2,\"430\":3,\"438\":16,\"439\":3,\"469\":1,\"489\":1,\"491\":2,\"492\":1,\"548\":1,\"553\":1,\"554\":1,\"559\":1,\"692\":1,\"1356\":6,\"1357\":4,\"1362\":2,\"1379\":4,\"1380\":7,\"1383\":2,\"1431\":4,\"1470\":4,\"1482\":2}}],[\"^=\",{\"1\":{\"437\":1}}],[\"^c\",{\"1\":{\"314\":1}}],[\"^\",{\"1\":{\"313\":2,\"1425\":3}}],[\"相信我\",{\"1\":{\"1850\":1}}],[\"相等再执行传入的比较器\",{\"1\":{\"1491\":1}}],[\"相等会返回0\",{\"1\":{\"1480\":1}}],[\"相等就移除节点\",{\"1\":{\"371\":1}}],[\"相对而言就比较复杂\",{\"1\":{\"1427\":1}}],[\"相对使用数组实现的阻塞队列\",{\"1\":{\"1386\":1}}],[\"相对于iterator\",{\"1\":{\"1497\":1}}],[\"相对于select和poll来说\",{\"1\":{\"1448\":1}}],[\"相对于只有一把锁的arrayblockingqueue性能会更好\",{\"1\":{\"1386\":1}}],[\"相对于数据文件来说\",{\"1\":{\"730\":1}}],[\"相对于用户分表来说\",{\"1\":{\"563\":1}}],[\"相反\",{\"1\":{\"1386\":1,\"1423\":1,\"1497\":1}}],[\"相关证书\",{\"1\":{\"1844\":1}}],[\"相关说明\",{\"1\":{\"1497\":2,\"1499\":1}}],[\"相关示例\",{\"0\":{\"844\":1}}],[\"相关的原理介绍和代码实现可以参考\",{\"1\":{\"316\":1}}],[\"相较于缓存穿透\",{\"1\":{\"766\":1}}],[\"相应地\",{\"1\":{\"602\":1}}],[\"相应的segment对象块是被锁住的\",{\"1\":{\"1430\":1}}],[\"相应的实现\",{\"1\":{\"432\":1}}],[\"相应的示例代码\",{\"1\":{\"428\":1}}],[\"相应的\",{\"1\":{\"307\":1}}],[\"相当于beanfactorytransactionattributesourceadvisor中的advice\",{\"1\":{\"1532\":1}}],[\"相当于beanfactorytransactionattributesourceadvisor中的pointcut\",{\"1\":{\"1532\":1}}],[\"相当于每个mapper对应一个factorybean\",{\"1\":{\"1530\":1}}],[\"相当于\",{\"1\":{\"1431\":1}}],[\"相当于舍弃了高位\",{\"1\":{\"1425\":1}}],[\"相当于getversion\",{\"1\":{\"718\":1}}],[\"相当于乐观锁加锁\",{\"1\":{\"718\":1}}],[\"相当于又把节点b新生成的binlog拿过来执行了一次\",{\"1\":{\"592\":1}}],[\"相当于给子树上所有的节点都添加了min和max的边界\",{\"1\":{\"397\":1}}],[\"相同的元会提供两个或多个流管道\",{\"1\":{\"1496\":1}}],[\"相同的方式\",{\"1\":{\"1478\":1}}],[\"相同的数据页能放下的索引值就越少\",{\"1\":{\"489\":1}}],[\"相同commit\",{\"1\":{\"601\":1}}],[\"相同为零不同为一\",{\"1\":{\"313\":1}}],[\"相比mmap方式\",{\"1\":{\"1462\":1}}],[\"相比mmap内存映射方式\",{\"1\":{\"1459\":1}}],[\"相比传统方法\",{\"1\":{\"1462\":1}}],[\"相比其他拷贝方式\",{\"1\":{\"1460\":1}}],[\"相比explain多了个partitions字段\",{\"1\":{\"643\":1}}],[\"相比于synchronized\",{\"1\":{\"1371\":1}}],[\"相比于sleep方法\",{\"1\":{\"609\":1}}],[\"相比于磁盘扫描\",{\"1\":{\"662\":1}}],[\"相比于一主一备的切换流程\",{\"1\":{\"603\":1}}],[\"相比于按表和按行分发\",{\"1\":{\"600\":1}}],[\"相比于按表并行分发策略\",{\"1\":{\"599\":1}}],[\"相比于优化前的join语句需要做10亿次条件判断来说\",{\"1\":{\"544\":1}}],[\"相比较而言\",{\"1\":{\"536\":1}}],[\"相比之下\",{\"1\":{\"529\":1}}],[\"相比\",{\"1\":{\"488\":1,\"559\":1}}],[\"相遇点即为环入口\",{\"1\":{\"377\":1}}],[\"~1\",{\"1\":{\"1497\":1}}],[\"~0\",{\"1\":{\"314\":1}}],[\"~0011\",{\"1\":{\"313\":1}}],[\"~x\",{\"1\":{\"314\":2}}],[\"~\",{\"1\":{\"313\":1,\"467\":41,\"1498\":1}}],[\"|\",{\"1\":{\"313\":2,\"467\":70,\"508\":24,\"565\":21,\"566\":1,\"568\":173,\"591\":1,\"1486\":1,\"1497\":3,\"1499\":1,\"1524\":1}}],[\"||\",{\"1\":{\"302\":1,\"363\":1,\"365\":1,\"366\":1,\"368\":1,\"373\":2,\"376\":1,\"383\":1,\"385\":2,\"386\":2,\"388\":3,\"395\":1,\"397\":2,\"398\":2,\"412\":1,\"415\":1,\"431\":2,\"435\":2,\"438\":1,\"806\":1,\"1357\":4,\"1426\":4,\"1430\":1,\"1431\":13,\"1471\":1,\"1476\":2,\"1494\":1,\"1524\":3,\"1525\":5,\"1527\":3,\"1531\":2,\"1532\":1}}],[\"按原问题的要求\",{\"1\":{\"1387\":1}}],[\"按距离递增排序\",{\"1\":{\"713\":1}}],[\"按字典倒序\",{\"1\":{\"711\":1}}],[\"按字典顺序倒序\",{\"1\":{\"711\":1}}],[\"按字典顺序排序\",{\"1\":{\"711\":1}}],[\"按score递减顺序\",{\"1\":{\"711\":2}}],[\"按score递减排序\",{\"1\":{\"711\":1}}],[\"按索引显示查询结果的\",{\"1\":{\"711\":1}}],[\"按起止位置获取字符串\",{\"1\":{\"707\":1}}],[\"按指定的步长对数值进行加减\",{\"1\":{\"707\":1}}],[\"按顺序取binlog发给b去执行\",{\"1\":{\"605\":1}}],[\"按顺序遍历\",{\"1\":{\"469\":1}}],[\"按行分发这种策略会设置一个阈值\",{\"1\":{\"599\":1}}],[\"按行分发的策略有两个问题\",{\"1\":{\"599\":1}}],[\"按行分发策略的并行度会更高\",{\"1\":{\"599\":1}}],[\"按行分发策略\",{\"0\":{\"599\":1}}],[\"按行并行策略在决定线程分发的时候\",{\"1\":{\"599\":1}}],[\"按行复制和按表复制的数据结构差不多\",{\"1\":{\"599\":1}}],[\"按行复制的核心思路是\",{\"1\":{\"599\":1}}],[\"按行累加\",{\"1\":{\"536\":2}}],[\"按表分发和按行分发策略并没有被合并到官方\",{\"1\":{\"599\":1}}],[\"按表分发事务的基本思路是\",{\"1\":{\"598\":1}}],[\"按表分发策略\",{\"0\":{\"598\":1}}],[\"按主键顺序取出所有word值\",{\"1\":{\"557\":1}}],[\"按数据长度增加地方向\",{\"1\":{\"505\":1}}],[\"按name排序\",{\"1\":{\"491\":1}}],[\"按层搜索到叶子节点\",{\"1\":{\"479\":1}}],[\"按需要恢复到线上库去\",{\"1\":{\"464\":1}}],[\"按照元素输入的顺序提供给consumer\",{\"1\":{\"1500\":1}}],[\"按照这种方式我们称之为\",{\"1\":{\"1497\":1}}],[\"按照这个逻辑的话就要申请10万次\",{\"1\":{\"629\":1}}],[\"按照这个逻辑\",{\"1\":{\"592\":1,\"598\":1}}],[\"按照这个逻辑执行的话\",{\"1\":{\"554\":1}}],[\"按照这个思路\",{\"1\":{\"429\":1}}],[\"按照如上定义\",{\"1\":{\"1444\":1}}],[\"按照插入顺序排序\",{\"1\":{\"708\":1}}],[\"按照一定算法选取几个叶子结点页面\",{\"1\":{\"695\":1}}],[\"按照上述思路我们计算idx\",{\"1\":{\"686\":1}}],[\"按照上面提到的判断方法\",{\"1\":{\"609\":1}}],[\"按照日志顺序执行\",{\"1\":{\"584\":1}}],[\"按照何种方式排序\",{\"1\":{\"566\":1}}],[\"按照时间分区的分区表\",{\"1\":{\"563\":1}}],[\"按照年份来划分\",{\"1\":{\"561\":1}}],[\"按照定义的分区的规则\",{\"1\":{\"561\":1}}],[\"按照id的值回到原表中取出所有字段的值返回给客户端\",{\"1\":{\"657\":1}}],[\"按照id\",{\"1\":{\"553\":1}}],[\"按照字段f\",{\"1\":{\"548\":1}}],[\"按照字符集转换规则\",{\"1\":{\"505\":1}}],[\"按照顺序使用\",{\"1\":{\"515\":1}}],[\"按照排序结果取前1000行返回给客户端\",{\"1\":{\"491\":1}}],[\"按照途中搜索的顺序就是按照usera\",{\"1\":{\"471\":1}}],[\"按照视点的不同\",{\"1\":{\"328\":1}}],[\"按照线程安全的强度来区分\",{\"0\":{\"67\":1}}],[\"按位异或\",{\"1\":{\"313\":1}}],[\"按位取反\",{\"1\":{\"313\":1}}],[\"按位与\",{\"1\":{\"313\":1}}],[\"按位或\",{\"1\":{\"313\":1}}],[\"运算的一块临时内存\",{\"1\":{\"1541\":1}}],[\"运算符\",{\"1\":{\"313\":1}}],[\"运行效果如下\",{\"1\":{\"1490\":1}}],[\"运行程序就会在控制台打印\",{\"1\":{\"1490\":1}}],[\"运行程序\",{\"1\":{\"1487\":1}}],[\"运行的结果就变成了\",{\"1\":{\"1494\":1}}],[\"运行的结果\",{\"1\":{\"1486\":1,\"1490\":1}}],[\"运行状态\",{\"1\":{\"1354\":1}}],[\"运行时栈帧结构\",{\"0\":{\"1677\":1}}],[\"运行时常量池\",{\"0\":{\"1585\":1}}],[\"运行时数据区域\",{\"0\":{\"1579\":1}}],[\"运行时数据区中包含哪些区域\",{\"0\":{\"102\":1}}],[\"运行时会封装成为interceptoranddynamicmethodmatcher\",{\"1\":{\"1531\":1}}],[\"运行时报错\",{\"1\":{\"717\":1}}],[\"运行时异常\",{\"1\":{\"717\":1}}],[\"运行这条delete命令产生了一个warning\",{\"1\":{\"591\":1}}],[\"运行sql\",{\"1\":{\"568\":1}}],[\"运维经理\",{\"1\":{\"567\":1}}],[\"含义如下\",{\"1\":{\"1361\":1}}],[\"含义\",{\"1\":{\"313\":1,\"694\":2}}],[\"含有则找到并设置为currnode\",{\"1\":{\"302\":1}}],[\"kotlindelegate\",{\"1\":{\"1532\":2}}],[\"kotlindetector\",{\"1\":{\"1532\":1}}],[\"know\",{\"1\":{\"1500\":1}}],[\"known\",{\"1\":{\"1497\":1,\"1500\":1}}],[\"k表示分类器返回的结果的类型\",{\"1\":{\"1495\":1}}],[\"k表示分类的时候的key的类型\",{\"1\":{\"1495\":1}}],[\"k类型以及k类型以下的类型\",{\"1\":{\"1495\":1}}],[\"k>\",{\"1\":{\"1490\":2,\"1495\":5}}],[\"klass\",{\"1\":{\"1361\":1}}],[\"kuangshen\",{\"1\":{\"719\":1,\"720\":1}}],[\"kb\",{\"1\":{\"714\":1}}],[\"km\",{\"1\":{\"713\":3}}],[\"k6\",{\"1\":{\"708\":4}}],[\"k5\",{\"1\":{\"708\":7}}],[\"kitchen\",{\"1\":{\"1500\":1}}],[\"kind\",{\"1\":{\"708\":1}}],[\"killed\",{\"1\":{\"618\":1}}],[\"kill并不是马上停止的意思\",{\"1\":{\"618\":1}}],[\"kill\",{\"1\":{\"617\":1,\"618\":6,\"675\":1}}],[\"kill命令的执行过程\",{\"0\":{\"618\":1}}],[\"kill命令\",{\"0\":{\"617\":1}}],[\"k4\",{\"1\":{\"707\":1,\"708\":12}}],[\"k3\",{\"1\":{\"707\":2,\"708\":8,\"716\":2}}],[\"k越小越好\",{\"1\":{\"540\":1}}],[\"kk\",{\"1\":{\"514\":4}}],[\"k2所在的数据页不在内存中\",{\"1\":{\"482\":1}}],[\"k2\",{\"1\":{\"482\":2,\"707\":2,\"708\":44,\"716\":3,\"717\":4}}],[\"k1所在的数据页在内存\",{\"1\":{\"482\":1}}],[\"k1\",{\"1\":{\"482\":2,\"707\":3,\"708\":14,\"716\":5,\"717\":5}}],[\"kv场景的特点如下\",{\"1\":{\"472\":1}}],[\"k−2\",{\"1\":{\"431\":1}}],[\"k−1\",{\"1\":{\"431\":1}}],[\"k+1个\",{\"1\":{\"393\":1}}],[\"k++\",{\"1\":{\"366\":1}}],[\"kernel会给用户进程发送一个signal\",{\"1\":{\"1443\":1}}],[\"kernel会等待数据准备完成\",{\"1\":{\"1443\":1}}],[\"kernel会\",{\"1\":{\"1442\":1}}],[\"kernel就开始io的第一个阶段\",{\"1\":{\"1440\":1}}],[\"keeping\",{\"1\":{\"1492\":1}}],[\"keepalivetime\",{\"1\":{\"1353\":2}}],[\"keep\",{\"1\":{\"385\":2}}],[\"key是datasource\",{\"1\":{\"1532\":1}}],[\"key是beanname\",{\"1\":{\"1525\":1,\"1526\":1}}],[\"key是查询的语句\",{\"1\":{\"456\":1}}],[\"keyextractor\",{\"1\":{\"1491\":4}}],[\"key已经存在直接覆盖value\",{\"1\":{\"1426\":1}}],[\"key已经存在了\",{\"1\":{\"549\":1}}],[\"key必须实现comparable接口或者在构造treemap传入自定义的comparator\",{\"1\":{\"1421\":1}}],[\"key可以为null\",{\"1\":{\"1352\":1}}],[\"key监控指定数据\",{\"1\":{\"718\":1}}],[\"key的操作\",{\"1\":{\"706\":1}}],[\"key的值是由\",{\"1\":{\"549\":1}}],[\"key字段对应的值为null\",{\"1\":{\"659\":1}}],[\"key`idx\",{\"1\":{\"647\":1}}],[\"key就是数据库名\",{\"1\":{\"600\":1}}],[\"key就是\",{\"1\":{\"550\":2}}],[\"key不同\",{\"1\":{\"549\":1,\"550\":1}}],[\"key在\",{\"1\":{\"549\":1}}],[\"key=hash\",{\"1\":{\"599\":3}}],[\"key=\",{\"1\":{\"503\":1}}],[\"key或者unique索引\",{\"1\":{\"467\":1}}],[\"keys的使用\",{\"0\":{\"1732\":1}}],[\"keys只有idx\",{\"1\":{\"684\":1}}],[\"keys\",{\"1\":{\"466\":2,\"467\":7,\"498\":1,\"527\":2,\"690\":1,\"692\":2,\"704\":3,\"706\":4,\"716\":1,\"1495\":1}}],[\"key1列就可能有很多重复的记录\",{\"1\":{\"695\":1}}],[\"key1\",{\"1\":{\"332\":1,\"707\":3,\"708\":5,\"709\":7,\"711\":2}}],[\"key2\",{\"1\":{\"332\":2,\"707\":3,\"708\":1,\"709\":7,\"711\":2}}],[\"key\",{\"0\":{\"542\":1,\"706\":1},\"1\":{\"311\":4,\"332\":4,\"380\":4,\"460\":1,\"466\":3,\"467\":17,\"469\":1,\"472\":2,\"473\":1,\"475\":3,\"483\":3,\"486\":1,\"490\":2,\"492\":1,\"498\":3,\"499\":2,\"500\":1,\"503\":3,\"505\":2,\"515\":1,\"527\":6,\"537\":2,\"541\":1,\"542\":2,\"544\":1,\"549\":2,\"550\":2,\"551\":1,\"556\":1,\"561\":1,\"579\":1,\"583\":2,\"585\":3,\"591\":3,\"596\":2,\"599\":2,\"604\":1,\"605\":1,\"613\":1,\"615\":2,\"626\":2,\"628\":1,\"631\":3,\"643\":5,\"647\":1,\"655\":2,\"656\":4,\"657\":2,\"660\":2,\"671\":1,\"672\":1,\"690\":4,\"692\":6,\"694\":1,\"701\":1,\"704\":1,\"706\":10,\"707\":15,\"708\":11,\"709\":8,\"710\":19,\"711\":21,\"713\":6,\"714\":3,\"715\":7,\"720\":1,\"724\":3,\"1352\":1,\"1383\":3,\"1423\":2,\"1425\":4,\"1426\":16,\"1430\":9,\"1431\":14,\"1451\":26,\"1495\":10,\"1497\":1,\"1532\":1,\"1853\":1}}],[\"k\",{\"1\":{\"366\":4,\"384\":4,\"393\":7,\"431\":2,\"472\":4,\"473\":4,\"475\":1,\"479\":1,\"482\":2,\"514\":1,\"548\":3,\"714\":2,\"1383\":6,\"1423\":3,\"1425\":1,\"1426\":8,\"1430\":6,\"1431\":4,\"1495\":9}}],[\"kafka和elasticsearch\",{\"1\":{\"1865\":1}}],[\"kafka\",{\"1\":{\"1863\":1}}],[\"kafka如何避免重复消费\",{\"0\":{\"260\":1}}],[\"kakuqo\",{\"1\":{\"307\":1}}],[\"大家可以搜索下\",{\"1\":{\"1868\":1}}],[\"大概了解每种技术有什么作用即可\",{\"1\":{\"1854\":1}}],[\"大概要经历如下的步骤\",{\"1\":{\"1490\":1}}],[\"大话数据结构\",{\"1\":{\"1844\":1,\"1849\":1}}],[\"大话设计模式\",{\"1\":{\"1844\":1}}],[\"大对象\",{\"1\":{\"1546\":1}}],[\"大体会经过以下几个流程\",{\"1\":{\"1457\":1}}],[\"大体来说\",{\"1\":{\"454\":1}}],[\"大于\",{\"1\":{\"1431\":1}}],[\"大于8就需要转换为红黑树\",{\"1\":{\"1431\":1}}],[\"大于8的话就把链表转换为红黑树\",{\"1\":{\"1426\":1}}],[\"大于64位处理器\",{\"1\":{\"1351\":1}}],[\"大量生产线程被阻塞\",{\"1\":{\"1379\":1}}],[\"大量的减少了配置文件的使用\",{\"1\":{\"1861\":1}}],[\"大量的key设置了相同的过期时间\",{\"1\":{\"769\":1}}],[\"大量的空对象会耗费一定的空间\",{\"1\":{\"764\":1}}],[\"大\",{\"1\":{\"732\":1}}],[\"大整数值\",{\"1\":{\"665\":3}}],[\"大查询回滚\",{\"1\":{\"618\":1}}],[\"大多数流的元都是集合\",{\"1\":{\"1496\":1}}],[\"大多数的流都会接收用户指定的一种行为\",{\"1\":{\"1496\":1}}],[\"大多数的互联网应用都是读多写少\",{\"1\":{\"603\":1}}],[\"大多数人都可能会碰到误删数据的场景\",{\"1\":{\"620\":1}}],[\"大多数情况下可以直接定位它的值\",{\"1\":{\"1421\":1}}],[\"大多数情况下主备延迟在1秒内\",{\"1\":{\"608\":1}}],[\"大多数情况下\",{\"1\":{\"316\":1,\"544\":1,\"596\":1}}],[\"大纲\",{\"1\":{\"567\":1}}],[\"大表的行数是m\",{\"1\":{\"540\":1}}],[\"大部分性能低下的查询都可以通过减少访问数据量的方式进行优化\",{\"1\":{\"518\":1}}],[\"大致有以下几种方案\",{\"1\":{\"606\":1}}],[\"大致估算出找到所需的记录需要读取的行数\",{\"1\":{\"467\":1}}],[\"大致可以分为两部分\",{\"1\":{\"462\":1}}],[\"大顶堆和小顶堆\",{\"1\":{\"1383\":1}}],[\"大顶堆\",{\"1\":{\"321\":1,\"1383\":1}}],[\"大小的等功能\",{\"1\":{\"1498\":1}}],[\"大小为2的次幂\",{\"1\":{\"1357\":1}}],[\"大小\",{\"1\":{\"310\":1,\"665\":1,\"666\":1,\"667\":1}}],[\"大数量分页查询该怎么优化\",{\"0\":{\"170\":1}}],[\"储物柜\",{\"1\":{\"310\":1}}],[\"钱包\",{\"1\":{\"310\":1}}],[\"说完这些\",{\"1\":{\"720\":1}}],[\"说明三个特性都不具备\",{\"1\":{\"1495\":1}}],[\"说明这个新的语法就是在调用student的无参构造来创建对象\",{\"1\":{\"1477\":1}}],[\"说明这条语句扫描了整个索引的所有值\",{\"1\":{\"503\":1}}],[\"说明存在\",{\"1\":{\"1431\":1}}],[\"说明正在扩容\",{\"1\":{\"1431\":1}}],[\"说明一天内能处理完\",{\"1\":{\"1413\":1}}],[\"说明此时处于可偏向但未偏向任何线程\",{\"1\":{\"1362\":1}}],[\"说明我们是可以对其进行定制化的\",{\"1\":{\"720\":1}}],[\"说明事务执行失败\",{\"1\":{\"718\":1}}],[\"说明如下\",{\"1\":{\"591\":2}}],[\"说明第二个子句用到了索引id\",{\"1\":{\"551\":1}}],[\"说明了这是一个被服务端改写过的命令\",{\"1\":{\"550\":1}}],[\"说明a还不够合适\",{\"1\":{\"485\":1}}],[\"说明mysql会对数据使用一个外部的索引排序\",{\"1\":{\"467\":1}}],[\"说明数组的元素不超过3个\",{\"1\":{\"441\":1}}],[\"说明是左侧节点\",{\"1\":{\"410\":1}}],[\"说明已经不是平衡树了\",{\"1\":{\"408\":1}}],[\"说明遍历完了\",{\"1\":{\"395\":1}}],[\"说明左边走到头了\",{\"1\":{\"395\":1}}],[\"说明没有满足的元素\",{\"1\":{\"363\":1}}],[\"说明它在集合中\",{\"1\":{\"307\":1}}],[\"说说你们公司的es集群架构\",{\"0\":{\"177\":1}}],[\"但只要按部就班\",{\"1\":{\"1871\":1}}],[\"但因为循环依赖的存在\",{\"1\":{\"1526\":1}}],[\"但存在一些属性是不同的\",{\"1\":{\"1498\":1}}],[\"但还没有被部分遍历\",{\"1\":{\"1497\":1}}],[\"但还是持有mdl读锁的\",{\"1\":{\"618\":1}}],[\"但还是查不到trx3的\",{\"1\":{\"609\":1}}],[\"但还是没有达到\",{\"1\":{\"609\":1}}],[\"但更多的时候无法达到理想状态\",{\"1\":{\"1497\":1}}],[\"但spliterator只需要通过一个方法tryadvance\",{\"1\":{\"1497\":1}}],[\"但select\",{\"1\":{\"1445\":1}}],[\"但ide却会提示\",{\"1\":{\"1491\":1}}],[\"但innodb并没有做相关的优化\",{\"1\":{\"536\":1}}],[\"但innodb还是要回到id索引再查一下\",{\"1\":{\"488\":1}}],[\"但程序并没有停止\",{\"1\":{\"1487\":1}}],[\"但总有种纸上谈兵的感觉\",{\"1\":{\"1484\":1}}],[\"但我们使用\",{\"1\":{\"1532\":1}}],[\"但我们还是非常振奋\",{\"1\":{\"1484\":1}}],[\"但我们并没有对该接口声明functionalinterface注解\",{\"1\":{\"1471\":1}}],[\"但tostring\",{\"1\":{\"1471\":1}}],[\"但其实在调用这些方法的时候并没有先后的顺序\",{\"1\":{\"1489\":1}}],[\"但其实每次打印的stream对象都是不同的\",{\"1\":{\"1487\":1}}],[\"但其实这里的foreach\",{\"1\":{\"1470\":1}}],[\"但其过程比较复杂\",{\"1\":{\"691\":1}}],[\"但却不得不编写很多没有实际意义的代码\",{\"1\":{\"1468\":1}}],[\"但优势同样明显\",{\"1\":{\"1451\":1}}],[\"但性能可能性存在巨大瓶颈\",{\"1\":{\"1449\":1}}],[\"但作为已经废弃的类\",{\"1\":{\"1432\":1}}],[\"但从上图可以看出\",{\"1\":{\"1427\":1}}],[\"但高并发场景下性能最差\",{\"1\":{\"1397\":1}}],[\"但需要注意的是\",{\"1\":{\"1494\":1}}],[\"但需要复杂的逻辑处理\",{\"1\":{\"1395\":1}}],[\"但需要额外的空间\",{\"1\":{\"316\":1}}],[\"但future没有提供这样的能力\",{\"1\":{\"1393\":1}}],[\"但locksupport可以解决这两个问题\",{\"1\":{\"1354\":1}}],[\"但使用更少的带宽\",{\"1\":{\"1351\":1}}],[\"但多个进程指令会被快速的轮换执行\",{\"1\":{\"1347\":1}}],[\"但每个从节点只能由一个主节点\",{\"1\":{\"743\":1}}],[\"但每个客户端在和服务端建立连接的时候\",{\"1\":{\"619\":1}}],[\"但自己读取消息的速度却不够快的话\",{\"1\":{\"737\":1}}],[\"但并不推荐这种方式\",{\"1\":{\"733\":1}}],[\"但并不是在所有的场景下\",{\"1\":{\"1470\":1}}],[\"但并不是不需要了就立刻释放\",{\"1\":{\"580\":1}}],[\"但并不是所有的存储引擎都支持一致性读的隔离级别\",{\"1\":{\"575\":1}}],[\"但并不是所有的引擎都支持事务\",{\"1\":{\"569\":1}}],[\"但仍然可以承受数分钟以内的数据丢失\",{\"1\":{\"733\":1}}],[\"但分数\",{\"1\":{\"711\":1}}],[\"但它们还是有区别的\",{\"1\":{\"1359\":1}}],[\"但它们大致反映了mysql在内部执行查询时需要访问多少数据\",{\"1\":{\"524\":1}}],[\"但它以毫秒为单位设置\",{\"1\":{\"707\":1}}],[\"但付出的代价也就越大\",{\"1\":{\"669\":1}}],[\"但事务a出现了唯一键冲突\",{\"1\":{\"628\":1}}],[\"但也没有将自增值再该回去\",{\"1\":{\"628\":1}}],[\"但也不是说增加索引就能让扫描的行数等于返回的行数\",{\"1\":{\"527\":1}}],[\"但业务设计不应该依赖于自增主键的连续性\",{\"1\":{\"626\":1}}],[\"但由于过于灵活\",{\"1\":{\"1524\":1}}],[\"但由于tostring\",{\"1\":{\"1472\":1}}],[\"但由于这个工作是自动的\",{\"1\":{\"605\":1}}],[\"但由于1000这个值已经存在于临时表了\",{\"1\":{\"551\":1}}],[\"但现在的情况比较严重\",{\"1\":{\"596\":1}}],[\"但readonly对超级\",{\"1\":{\"590\":1}}],[\"但没有丢失数据的风险\",{\"1\":{\"588\":1}}],[\"但累积n个事务才fsync\",{\"1\":{\"587\":1}}],[\"但\",{\"1\":{\"585\":1,\"634\":1}}],[\"但间隙锁不一样\",{\"1\":{\"585\":1}}],[\"但语句却无法执行\",{\"1\":{\"562\":1}}],[\"但在\",{\"1\":{\"1534\":2}}],[\"但在底层实现上是完全不同的\",{\"1\":{\"1489\":1}}],[\"但在起名字的时候\",{\"1\":{\"1472\":1}}],[\"但在java中\",{\"1\":{\"1470\":1}}],[\"但在微观上并不是同时执行的\",{\"1\":{\"1347\":1}}],[\"但在执行drop\",{\"1\":{\"550\":1}}],[\"但在性能上有所差别\",{\"1\":{\"478\":1}}],[\"但mysql的优化器和执行器并不支持哈希join\",{\"1\":{\"545\":1}}],[\"但即使这样\",{\"1\":{\"534\":1}}],[\"但拿到的结果却不同\",{\"1\":{\"533\":1}}],[\"但随着系统中记录数的不断增多\",{\"1\":{\"532\":1}}],[\"但无需再回表查询记录\",{\"1\":{\"527\":1}}],[\"但实际生产上使用比较多的是双m结构\",{\"1\":{\"592\":1}}],[\"但实际上\",{\"1\":{\"559\":1,\"594\":1}}],[\"但实际上并没有这么简单\",{\"1\":{\"483\":1}}],[\"但实际情况中这种\",{\"1\":{\"526\":1}}],[\"但有时候也可能是访问了太多的列\",{\"1\":{\"518\":1}}],[\"但如果一个select\",{\"1\":{\"629\":1}}],[\"但如果它在真正地执行查询\",{\"1\":{\"613\":1}}],[\"但如果是查询落到其他从库上\",{\"1\":{\"609\":1}}],[\"但如果表t1执行完成的瞬间\",{\"1\":{\"597\":1}}],[\"但如果使用的是索引t\",{\"1\":{\"591\":1}}],[\"但如果只有单线程压测\",{\"1\":{\"588\":1}}],[\"但如果要变更的表是一个热点表\",{\"1\":{\"578\":1}}],[\"但如果排序数据量太大\",{\"1\":{\"491\":1}}],[\"但如果插入结点是黑色\",{\"1\":{\"345\":1}}],[\"但同时\",{\"1\":{\"487\":1,\"584\":1}}],[\"但这几个操作\",{\"1\":{\"619\":1}}],[\"但这两种操作都很复杂\",{\"1\":{\"605\":1}}],[\"但这并不常见\",{\"1\":{\"518\":1}}],[\"但这些还不够\",{\"1\":{\"518\":1}}],[\"但这个时候已经别无选择了\",{\"1\":{\"596\":1}}],[\"但这个时候\",{\"1\":{\"492\":1}}],[\"但这个算法有一个问题\",{\"1\":{\"492\":1}}],[\"但这种方法并不完美\",{\"1\":{\"485\":1}}],[\"但这样可能会导致你的密码泄露\",{\"1\":{\"455\":1}}],[\"但之后由于马上要访问这个数据页\",{\"1\":{\"481\":1}}],[\"但缺点是\",{\"1\":{\"469\":1}}],[\"但不是一个bean的情况\",{\"1\":{\"1524\":1}}],[\"但不移除\",{\"1\":{\"1377\":2}}],[\"但不论是哪一种\",{\"1\":{\"629\":1}}],[\"但不保证是连续的\",{\"1\":{\"628\":1}}],[\"但不取值\",{\"1\":{\"536\":1}}],[\"但不能忘记这样做的代价是什么\",{\"1\":{\"522\":1}}],[\"但不一定被查询实际使用\",{\"1\":{\"467\":1}}],[\"但不限于字符串\",{\"1\":{\"301\":1}}],[\"但左子树和右子树的黑结点的层数是相等的\",{\"1\":{\"343\":1}}],[\"但是要解决些复杂的业务场景\",{\"1\":{\"1862\":1}}],[\"但是要删除一个小表的全部数据\",{\"1\":{\"621\":1}}],[\"但是希望spring自动找该构造方法的入参值\",{\"1\":{\"1527\":1}}],[\"但是排除userservice类\",{\"1\":{\"1522\":1}}],[\"但是必须要随着trysplit方法的调用次数不断减少\",{\"1\":{\"1497\":1}}],[\"但是可以重用一个空的\",{\"1\":{\"1497\":1}}],[\"但是可以通过调整查询的顺序\",{\"1\":{\"541\":1}}],[\"但是后面的关闭处理器依然得到了执行\",{\"1\":{\"1496\":1}}],[\"但是后面的指令依旧正常执行成功了\",{\"1\":{\"717\":1}}],[\"但是几乎所有的流实例在使用完成之后都不需要关闭\",{\"1\":{\"1496\":1}}],[\"但是jdk8对它做了一定程度的增强\",{\"1\":{\"1491\":1}}],[\"但是运行之后控制台的输出却不是我们想要的结果\",{\"1\":{\"1487\":1}}],[\"但是需要对于中间结果容器做一些处理才返回结果\",{\"1\":{\"1494\":1}}],[\"但是需要注意的是\",{\"1\":{\"1475\":1}}],[\"但是需要再回到原表去取数据\",{\"1\":{\"493\":1}}],[\"但是使用lambda表达式\",{\"1\":{\"1475\":1}}],[\"但是总的来说还是只有一个抽象方法\",{\"1\":{\"1471\":1}}],[\"但是总共执行了101条语句\",{\"1\":{\"538\":1}}],[\"但是两者的实现有着本质的区别\",{\"1\":{\"1470\":1}}],[\"但是我们无法将函数作为参数传递给一个方法\",{\"1\":{\"1470\":1}}],[\"但是我们看到的结果是\",{\"1\":{\"561\":1}}],[\"但是很多人在使用java8的时候\",{\"1\":{\"1468\":1}}],[\"但是读取大文件\",{\"1\":{\"1464\":1}}],[\"但是数量过大后性能也会下降\",{\"1\":{\"1447\":1}}],[\"但是用户进程会被select函数阻塞\",{\"1\":{\"1442\":1}}],[\"但是文件描述符这一概念往往只适用于unix\",{\"1\":{\"1438\":1}}],[\"但是会发生数据被覆盖的情况\",{\"1\":{\"1428\":1}}],[\"但是会将连接恢复到刚刚创建完成时的状态\",{\"1\":{\"455\":1}}],[\"但是某个key对应的value值被覆盖步属于结构变化\",{\"1\":{\"1423\":1}}],[\"但是遍历顺序却是不确定的\",{\"1\":{\"1421\":1}}],[\"但是类bar并不是线程安全的\",{\"1\":{\"1403\":1}}],[\"但是依然可以通过setage\",{\"1\":{\"1403\":1}}],[\"但是依然建议将节点b\",{\"1\":{\"590\":1}}],[\"但是采用数组实现引发另外一个问题false\",{\"1\":{\"1396\":1}}],[\"但是调用线程和持有锁的线程是同一个\",{\"1\":{\"1375\":1}}],[\"但是append方法中的stringbuffer属于一个局部变量\",{\"1\":{\"1364\":1}}],[\"但是还是存在一些缺陷的\",{\"1\":{\"1356\":1}}],[\"但是还没有传到从库中\",{\"1\":{\"609\":1}}],[\"但是dubbo协议一旦涉及到跨rpc框架\",{\"1\":{\"798\":1}}],[\"但是delete全表是很慢的\",{\"1\":{\"621\":1}}],[\"但是当有其他线程尝试获取锁时\",{\"1\":{\"1362\":1}}],[\"但是当redis内存空间满的时候也会清理部分数据\",{\"1\":{\"767\":1}}],[\"但是当comments\",{\"1\":{\"498\":1}}],[\"但是其他的key依然可以使用缓存响应\",{\"1\":{\"766\":1}}],[\"但是就不按parallel\",{\"1\":{\"761\":1}}],[\"但是就被更新操作清空掉了\",{\"1\":{\"456\":1}}],[\"但是主从复制也带来了以下问题\",{\"1\":{\"758\":1}}],[\"但是本质上都是差不多的\",{\"1\":{\"740\":1}}],[\"但是required属性为true\",{\"1\":{\"1525\":1}}],[\"但是reentrantlock可以通过reentrantlock\",{\"1\":{\"1372\":1}}],[\"但是redis事务不能保证原子性\",{\"1\":{\"715\":1,\"717\":1}}],[\"但是rows显示有10354条记录\",{\"1\":{\"685\":1}}],[\"但是统计耗时特别少\",{\"1\":{\"695\":1}}],[\"但是统计耗时也就最久\",{\"1\":{\"695\":1}}],[\"但是分析多个表不同连接顺序成本花费的时间还是会很长\",{\"1\":{\"693\":1}}],[\"但是分组之前必定排序\",{\"1\":{\"515\":1}}],[\"但是消耗的时间也就越长\",{\"1\":{\"693\":1}}],[\"但是有不同的目标\",{\"1\":{\"1496\":1}}],[\"但是有的阻塞队列是有界的\",{\"1\":{\"1378\":1}}],[\"但是有的时候扇出值的计算就变得很棘手\",{\"1\":{\"691\":1}}],[\"但是有时候时候\",{\"1\":{\"529\":1}}],[\"但是通过like操作符和以通配符开头的字符串做比较\",{\"1\":{\"684\":1}}],[\"但是通过select\",{\"1\":{\"613\":1}}],[\"但是update\",{\"1\":{\"672\":1}}],[\"但是像阿里这样的公司一般会用datetime\",{\"1\":{\"666\":1}}],[\"但是概率极小\",{\"1\":{\"636\":1}}],[\"但是概率非常小\",{\"1\":{\"489\":1}}],[\"但是trx\",{\"1\":{\"634\":1}}],[\"但是并不意味着引用这些不可变对象的对象就是线程安全的\",{\"1\":{\"1403\":1}}],[\"但是并不会保存自增值\",{\"1\":{\"627\":1}}],[\"但是并行提交多个异步任务\",{\"1\":{\"1395\":1}}],[\"但是并发查询过高会占用过多资源\",{\"1\":{\"613\":1}}],[\"但是一个系统不可能无限制的备份日志\",{\"1\":{\"622\":1}}],[\"但是session\",{\"1\":{\"618\":1}}],[\"但是却实际没有用到索引\",{\"1\":{\"690\":1}}],[\"但是却需要等到下一个检测发起执行语句的时候\",{\"1\":{\"615\":1}}],[\"但是却有f\",{\"1\":{\"332\":1}}],[\"但是io操作很耗时\",{\"1\":{\"1387\":1}}],[\"但是io利用率100\",{\"1\":{\"615\":1}}],[\"但是index是从索引中读的\",{\"1\":{\"467\":1}}],[\"但是查询表t的语句会被阻塞\",{\"1\":{\"613\":1}}],[\"但是也可能造成错失最优的执行计划\",{\"1\":{\"693\":1}}],[\"但是也存在两个问题\",{\"1\":{\"608\":1}}],[\"但是也有一些并不适合在被驱动表上建索引的情况\",{\"1\":{\"544\":1}}],[\"但是不能自动装配和获取beannames\",{\"1\":{\"1513\":1}}],[\"但是不够通用\",{\"1\":{\"798\":1}}],[\"但是不会阻塞读\",{\"1\":{\"672\":1}}],[\"但是不存在于set\",{\"1\":{\"605\":1}}],[\"但是不创建索引的话需要判断10亿次\",{\"1\":{\"544\":1}}],[\"但是相同的日志\",{\"1\":{\"604\":1}}],[\"但是设置成2\",{\"1\":{\"588\":1}}],[\"但是持久化到磁盘的速度就慢多了\",{\"1\":{\"588\":1}}],[\"但是共用同一份binlog文件\",{\"1\":{\"587\":1}}],[\"但是它们都是高性能服务器的典范\",{\"1\":{\"738\":1}}],[\"但是它的致命缺点就是\",{\"1\":{\"690\":1}}],[\"但是它可以保证每个更新请求都是更新内存中的bufferpool\",{\"1\":{\"680\":1}}],[\"但是它和之前介绍过的锁都不太一样\",{\"1\":{\"585\":1}}],[\"但是它也有额外的负担\",{\"1\":{\"581\":1}}],[\"但是新插入记录这个动作\",{\"1\":{\"585\":1}}],[\"但是汇总到数据库服务端以后\",{\"1\":{\"581\":1}}],[\"但是每秒却执行不了几个事务\",{\"1\":{\"581\":1}}],[\"但是每一行都变小了\",{\"1\":{\"492\":1}}],[\"但是检测期间要消耗大量的cpu资源\",{\"1\":{\"581\":1}}],[\"但是请求很频繁\",{\"1\":{\"578\":1}}],[\"但是语句结束后并不会马上释放\",{\"1\":{\"578\":1}}],[\"但是回滚段却有200gb\",{\"1\":{\"571\":1}}],[\"但是结果已经被a看到了\",{\"1\":{\"570\":1}}],[\"但是如果我们想要一个bean完全由我们自己来创造\",{\"1\":{\"1521\":1}}],[\"但是如果你这么写的话\",{\"1\":{\"1491\":1}}],[\"但是如果使用lambda表达式\",{\"1\":{\"1476\":1}}],[\"但是如果并发数大于阻塞队列大小\",{\"1\":{\"1450\":1}}],[\"但是如果没有剩余内存\",{\"1\":{\"1380\":1}}],[\"但是如果队列里无数据\",{\"1\":{\"1378\":1}}],[\"但是如果一个线程想去写这些共享资源\",{\"1\":{\"1375\":1}}],[\"但是如果一个mysql实例跑得足够久得话\",{\"1\":{\"632\":1}}],[\"但是如果这个数字越大\",{\"1\":{\"761\":1}}],[\"但是如果这个where条件改成where\",{\"1\":{\"562\":1}}],[\"但是如果global\",{\"1\":{\"633\":1}}],[\"但是如果马上重启实例\",{\"1\":{\"627\":1}}],[\"但是如果它们被分到不同的worker\",{\"1\":{\"599\":1}}],[\"但是如果row格式的binlog\",{\"1\":{\"591\":1}}],[\"但是如果不是死锁\",{\"1\":{\"581\":1}}],[\"但是如果是在普通的分表上操作的时候并不会出现这样的问题\",{\"1\":{\"562\":1}}],[\"但是如果执行drop\",{\"1\":{\"550\":1}}],[\"但是由于这两个接口中有同名的默认方法\",{\"1\":{\"1484\":1}}],[\"但是由于\",{\"1\":{\"605\":1}}],[\"但是由于cpu的调度策略\",{\"1\":{\"597\":1}}],[\"但是由于session\",{\"1\":{\"562\":1}}],[\"但是由于binlog没写完就crash了\",{\"1\":{\"464\":1}}],[\"但是从上面的实验效果可以看出\",{\"1\":{\"561\":1}}],[\"但是随着单词表的变大\",{\"1\":{\"556\":1}}],[\"但是传到备库执行时如何处理的呢\",{\"1\":{\"550\":1}}],[\"但是备库同步线程是持续在运行的\",{\"1\":{\"550\":1}}],[\"但是表结构还在\",{\"1\":{\"546\":1}}],[\"但是经过where条件过滤后\",{\"1\":{\"544\":1}}],[\"但是判断等值条件的次数还是不变的\",{\"1\":{\"540\":1}}],[\"但是bnl算法的这10万次判断是内存操作\",{\"1\":{\"540\":1}}],[\"但是binlog里面已经记录了\",{\"1\":{\"464\":1}}],[\"但是这还不足以写出好的代码\",{\"1\":{\"1870\":1}}],[\"但是这么做的缺点是\",{\"1\":{\"1531\":1}}],[\"但是这样也会造成效率的降低\",{\"1\":{\"1446\":1}}],[\"但是这样的想法对于mysql来说并不适用\",{\"1\":{\"529\":1}}],[\"但是这通常没有任何好处\",{\"1\":{\"666\":1}}],[\"但是这种方式可能不准\",{\"1\":{\"663\":1}}],[\"但是这种操作本身带有一定的风险\",{\"1\":{\"581\":1}}],[\"但是这个方案仍然存在\",{\"1\":{\"623\":1}}],[\"但是这个时候系统还是可以正常读取数据的\",{\"1\":{\"614\":1}}],[\"但是这个时候根据where条件\",{\"1\":{\"562\":1}}],[\"但是这个位点很难精确取到\",{\"1\":{\"604\":1}}],[\"但是这个算法会将1000行数据都排好序\",{\"1\":{\"558\":1}}],[\"但是这个sql请求需要扫描表t2多达100次\",{\"1\":{\"539\":1}}],[\"但是这里的number\",{\"1\":{\"558\":1}}],[\"但是仅返回200行结果\",{\"1\":{\"527\":1}}],[\"但是只是在页面上显示前面10条\",{\"1\":{\"520\":1}}],[\"但是group\",{\"1\":{\"515\":1}}],[\"但是没有参数\",{\"1\":{\"1527\":1}}],[\"但是没有持久化\",{\"1\":{\"588\":1}}],[\"但是没有用到c\",{\"1\":{\"514\":2}}],[\"但是没有关系\",{\"1\":{\"469\":1}}],[\"但是范围之后的索引字段会失效\",{\"1\":{\"509\":1}}],[\"但是执行show\",{\"1\":{\"617\":1}}],[\"但是执行代价要比随机算法1的代价要高\",{\"1\":{\"559\":1}}],[\"但是执行效率有没有差距呢\",{\"1\":{\"508\":1}}],[\"但是执行的效率会有所不同\",{\"1\":{\"458\":1,\"651\":1}}],[\"但是explain结果的第二行显示\",{\"1\":{\"505\":1}}],[\"但是explain结果却显式\",{\"1\":{\"504\":1}}],[\"但是mysql比较完成成本后\",{\"1\":{\"688\":1}}],[\"但是mysql在计算全表扫描成本时直接使用聚簇索引占用的页面数作为计算io成本的依据\",{\"1\":{\"685\":1}}],[\"但是mysql重启之后会生成新的binlog文件\",{\"1\":{\"633\":1}}],[\"但是mysqlbinlog工具并不能指定只解析一个表的日志\",{\"1\":{\"622\":1}}],[\"但是mysql并没有使用这个索引\",{\"1\":{\"503\":1}}],[\"但是myisam没有crash\",{\"1\":{\"462\":1}}],[\"但是性能却差异巨大的sql语句\",{\"1\":{\"502\":1}}],[\"但是在concurrenthashmap实现里保留了segment定义\",{\"1\":{\"1431\":1}}],[\"但是在使用decimal类型的时候\",{\"1\":{\"665\":1}}],[\"但是在计算机里\",{\"1\":{\"630\":1}}],[\"但是在备库上执行show\",{\"1\":{\"622\":1}}],[\"但是在这个等待进入innodb的循环过程中\",{\"1\":{\"618\":1}}],[\"但是在查询这条记录的时候\",{\"1\":{\"571\":1}}],[\"但是在order\",{\"1\":{\"498\":1}}],[\"但是在统计信息中\",{\"1\":{\"484\":1}}],[\"但是索引选取的越长\",{\"1\":{\"489\":1}}],[\"但是对于andthen\",{\"1\":{\"1475\":1}}],[\"但是对于内连接来说\",{\"1\":{\"692\":1}}],[\"但是对于一些业务来说\",{\"1\":{\"596\":1}}],[\"但是对于这个查询语句来说\",{\"1\":{\"487\":1}}],[\"但是对于mysql的server层来说\",{\"1\":{\"475\":1}}],[\"但是代价太高了\",{\"1\":{\"484\":1}}],[\"但是实现原理一样的\",{\"1\":{\"1425\":1}}],[\"但是实现索引的方式却有很多中\",{\"1\":{\"468\":1}}],[\"但是实例资源需要对资源的分配做出管理\",{\"1\":{\"1407\":1}}],[\"但是实际上服务端上这条语句还在执行过程中\",{\"1\":{\"618\":1}}],[\"但是实际上大多数的数据库存储却并不使用二叉树\",{\"1\":{\"471\":1}}],[\"但是实际情况更加复杂\",{\"1\":{\"525\":1}}],[\"但是\",{\"1\":{\"470\":1,\"543\":2,\"548\":2,\"550\":1,\"553\":2,\"554\":1,\"558\":1,\"581\":1,\"587\":1,\"591\":1,\"592\":1,\"593\":1,\"598\":1,\"599\":1,\"600\":1,\"609\":1,\"613\":1,\"614\":1,\"615\":2,\"618\":2,\"619\":1,\"628\":1,\"629\":1,\"632\":1,\"634\":3,\"635\":2,\"1388\":1,\"1425\":2,\"1442\":1,\"1490\":1,\"1864\":1}}],[\"但是大多数情况下不要使用查询缓存\",{\"1\":{\"456\":1}}],[\"但是全部使用长连接后\",{\"1\":{\"455\":1}}],[\"但是之前最大的可达步数是3\",{\"1\":{\"421\":1}}],[\"但是计算出的索引值均为1\",{\"1\":{\"307\":1}}],[\"虽然通过countdownlatch等工具类也可以实现任务的编排\",{\"1\":{\"1395\":1}}],[\"虽然java中互斥和同步都可以采用synchronized关键字来完成\",{\"1\":{\"1359\":1}}],[\"虽然高效地解决了原子操作\",{\"1\":{\"1356\":1}}],[\"虽然中间有一条命令报错了\",{\"1\":{\"717\":1}}],[\"虽然表中的记录其实都存储在聚簇索引对应b+树的叶子结点中\",{\"1\":{\"685\":1}}],[\"虽然mysql重启不会导致同一个binlog里面出现两个相同的xid\",{\"1\":{\"633\":1}}],[\"虽然248\",{\"1\":{\"632\":1}}],[\"虽然自然数是没有上限的\",{\"1\":{\"630\":1}}],[\"虽然可以通过利用并行复制来加速恢复数据的过程\",{\"1\":{\"623\":1}}],[\"虽然12号线程的状态已经设置成了kill\",{\"1\":{\"618\":1}}],[\"虽然说等锁的线程不算在并发线程计数里\",{\"1\":{\"613\":1}}],[\"虽然实例x还是会继续执行实例y传过来的事务\",{\"1\":{\"605\":1}}],[\"虽然都最终可以建立从库b和新主库a\",{\"1\":{\"605\":1}}],[\"虽然随着中转日志的继续应用\",{\"1\":{\"596\":1}}],[\"虽然节点b并没有被直接访问\",{\"1\":{\"590\":1}}],[\"虽然间隙锁也是一种锁\",{\"1\":{\"585\":1}}],[\"虽然最终的结果是主备一致的\",{\"1\":{\"597\":1}}],[\"虽然最终检测的结果是没有死锁\",{\"1\":{\"581\":1}}],[\"虽然最终也能得到前3个值\",{\"1\":{\"558\":1}}],[\"虽然能够快速发现并进行处理的\",{\"1\":{\"581\":1}}],[\"虽然数据量不大\",{\"1\":{\"578\":1}}],[\"虽然查询结果相同\",{\"1\":{\"562\":1}}],[\"虽然session\",{\"1\":{\"562\":1}}],[\"虽然解决了算法1里明显的概率不均匀的问题\",{\"1\":{\"559\":1}}],[\"虽然解决了全表扫描的问题\",{\"1\":{\"498\":1}}],[\"虽然还是按行查\",{\"1\":{\"541\":1}}],[\"虽然分成两次放入join\",{\"1\":{\"540\":1}}],[\"虽然也可以得到正确的结果\",{\"1\":{\"539\":1}}],[\"虽然主键id一定不为空\",{\"1\":{\"536\":1}}],[\"虽然在t\",{\"1\":{\"503\":1}}],[\"虽然index2已经包含了所有的信息\",{\"1\":{\"488\":1}}],[\"虽然从执行时间上来看\",{\"1\":{\"484\":1}}],[\"虽然这个表的每一行的三个字段值都是一样的\",{\"1\":{\"484\":1}}],[\"虽然名字叫做change\",{\"1\":{\"480\":1}}],[\"虽然密码也可以直接跟在\",{\"1\":{\"455\":1}}],[\"虽然\",{\"1\":{\"307\":1}}],[\"7开始增加了这样一个接口\",{\"1\":{\"1496\":1}}],[\"7之后新增加的类\",{\"1\":{\"1476\":1}}],[\"7之后\",{\"1\":{\"1449\":1}}],[\"7之前的版本中\",{\"1\":{\"691\":1}}],[\"7以后\",{\"1\":{\"1449\":1}}],[\"7的stream对象\",{\"1\":{\"1484\":1}}],[\"7的分段技术\",{\"1\":{\"1431\":1}}],[\"7的实现\",{\"0\":{\"1430\":1}}],[\"7的实现那样重新计算hash\",{\"1\":{\"1427\":1}}],[\"7的示例如下\",{\"1\":{\"1428\":1}}],[\"7的源码\",{\"1\":{\"1425\":1}}],[\"7的并行复制策略里\",{\"1\":{\"602\":1}}],[\"7的并行复制策略\",{\"0\":{\"600\":1,\"602\":1}}],[\"75=1\",{\"1\":{\"1428\":1}}],[\"75是对空间和时间效率的平衡选择\",{\"1\":{\"1423\":1}}],[\"75\",{\"1\":{\"1423\":1,\"1428\":1,\"1431\":1,\"1432\":1}}],[\"75f\",{\"1\":{\"311\":1,\"1352\":1,\"1428\":1}}],[\"7和jdk1\",{\"1\":{\"1422\":1}}],[\"7分段锁来实现\",{\"1\":{\"1352\":1}}],[\"79\",{\"1\":{\"747\":1}}],[\"797\",{\"1\":{\"665\":3}}],[\"7k\",{\"1\":{\"692\":1}}],[\"7中的concurrenthashmap扩容只是针对segment对象中的hashentry数组进行扩容\",{\"1\":{\"1430\":1}}],[\"7中的扩容过程\",{\"1\":{\"1427\":1}}],[\"7中rehash的时候\",{\"1\":{\"1427\":1}}],[\"7中\",{\"1\":{\"691\":1}}],[\"72\",{\"1\":{\"688\":1}}],[\"7这个版本里\",{\"1\":{\"686\":1}}],[\"7这个策略\",{\"1\":{\"602\":1}}],[\"7排1\",{\"1\":{\"681\":1,\"684\":1,\"690\":2}}],[\"744\",{\"1\":{\"665\":1}}],[\"775\",{\"1\":{\"665\":2}}],[\"777\",{\"1\":{\"665\":1,\"667\":2}}],[\"76\",{\"1\":{\"1843\":1}}],[\"76735726\",{\"1\":{\"1428\":1}}],[\"767\",{\"1\":{\"665\":1}}],[\"768\",{\"1\":{\"665\":1}}],[\"7手册\",{\"1\":{\"636\":1}}],[\"7及之前的版本\",{\"1\":{\"627\":1}}],[\"7处理备库延迟的时候\",{\"1\":{\"602\":1}}],[\"7并行复制的思想是\",{\"1\":{\"602\":1}}],[\"7版本也提供了类似的功能\",{\"1\":{\"602\":1}}],[\"7版本开始\",{\"1\":{\"549\":1}}],[\"7支持了generated\",{\"1\":{\"554\":1}}],[\"70<\",{\"1\":{\"719\":1}}],[\"70\",{\"1\":{\"711\":2}}],[\"709\",{\"1\":{\"665\":1}}],[\"700\",{\"1\":{\"473\":1}}],[\"704\",{\"0\":{\"360\":1}}],[\"7或更新的版本\",{\"1\":{\"455\":1}}],[\"7\",{\"1\":{\"307\":1,\"400\":1,\"473\":1,\"487\":2,\"498\":1,\"503\":5,\"505\":1,\"515\":1,\"562\":2,\"602\":1,\"611\":1,\"656\":1,\"665\":3,\"686\":1,\"688\":1,\"690\":3,\"694\":1,\"707\":1,\"710\":1,\"711\":5,\"1425\":1,\"1427\":2,\"1428\":5,\"1476\":2,\"1484\":2,\"1487\":1}}],[\"个\",{\"1\":{\"724\":3}}],[\"个不同元素的基数\",{\"1\":{\"714\":1}}],[\"个元素\",{\"1\":{\"708\":1}}],[\"个字符的二进制字符串\",{\"1\":{\"667\":1}}],[\"个索引值分别是\",{\"1\":{\"307\":1}}],[\"个人经历\",{\"0\":{\"9\":1}}],[\"对我面试帮助很大\",{\"1\":{\"1853\":1}}],[\"对类的静态变量初始化为指定的值\",{\"1\":{\"1540\":1}}],[\"对这两项技术做了一定程度的封装\",{\"1\":{\"1531\":1}}],[\"对这些语句使用不当的话\",{\"1\":{\"502\":1}}],[\"对扫描到的类进行解析\",{\"1\":{\"1512\":1}}],[\"对串行流进行优化\",{\"1\":{\"1499\":1}}],[\"对剩下的元素都执行action方法\",{\"1\":{\"1497\":1}}],[\"对原生的子类型进行装箱操作\",{\"1\":{\"1497\":1}}],[\"对照basestream的定义不难发现\",{\"1\":{\"1496\":1}}],[\"对数组中唯一的元素进行累加的操作\",{\"1\":{\"1495\":1}}],[\"对数据结构做了进一步的优化\",{\"1\":{\"1423\":1}}],[\"对数据的完整性要求不高\",{\"1\":{\"727\":1}}],[\"对流当中的元素进行可变的汇聚操作\",{\"1\":{\"1485\":1}}],[\"对流的操作会生成一个结果\",{\"1\":{\"1485\":1}}],[\"对流中的每一个元素执行打印的操作\",{\"1\":{\"1484\":1}}],[\"对集合中的每个元素执行consumer中的accept\",{\"1\":{\"1472\":1}}],[\"对sendfile的支持\",{\"0\":{\"1465\":1}}],[\"对sort\",{\"1\":{\"491\":1,\"492\":1,\"555\":1,\"657\":2}}],[\"对mmap的支持\",{\"0\":{\"1464\":1}}],[\"对mysql的查询缓存来说\",{\"1\":{\"531\":1}}],[\"对资源的拷贝性能提升不少\",{\"1\":{\"1459\":1}}],[\"对资源的拷贝速度性能提升不少\",{\"1\":{\"1458\":1}}],[\"对所有连接请求进行处理\",{\"1\":{\"1451\":1}}],[\"对所有可能查询的参数以hash的形式存储\",{\"1\":{\"764\":1}}],[\"对key进行处理\",{\"1\":{\"1451\":1}}],[\"对key的hashcode\",{\"1\":{\"1426\":1}}],[\"对高并发和低时延支持不好\",{\"1\":{\"1449\":1}}],[\"对\",{\"1\":{\"1431\":2,\"1460\":1}}],[\"对foo这个引用的修改在多线程中并不能保证可见性和原子性\",{\"1\":{\"1403\":1}}],[\"对齐填充\",{\"1\":{\"1361\":1}}],[\"对性能有较大影响\",{\"1\":{\"1360\":1}}],[\"对象的引用\",{\"0\":{\"1595\":1}}],[\"对象的回收\",{\"0\":{\"1594\":1}}],[\"对象的访问定位\",{\"0\":{\"1590\":1}}],[\"对象的内存布局\",{\"0\":{\"1589\":1}}],[\"对象的创建\",{\"0\":{\"1588\":1}}],[\"对象的所有属性都是final的\",{\"1\":{\"1403\":1}}],[\"对象序列化等\",{\"1\":{\"1543\":1}}],[\"对象克隆\",{\"1\":{\"1543\":1}}],[\"对象创建的过程\",{\"1\":{\"1542\":1}}],[\"对象就需要扩大数组的长度\",{\"1\":{\"1427\":1}}],[\"对象可能是栈分配的候选\",{\"1\":{\"1365\":1}}],[\"对象锁\",{\"1\":{\"1361\":1}}],[\"对象所属的年代\",{\"1\":{\"1361\":1}}],[\"对象在内存中存储的布局可以分为三块区域\",{\"1\":{\"1361\":1}}],[\"对象头的另一部分是klass类型指针\",{\"1\":{\"1361\":1}}],[\"对象头\",{\"0\":{\"1361\":1},\"1\":{\"1360\":1,\"1361\":3}}],[\"对象属性原子修改器\",{\"1\":{\"1357\":1}}],[\"对象存储缓存\",{\"1\":{\"707\":1}}],[\"对单个内存位置的读\",{\"1\":{\"1351\":1}}],[\"对单个事务做如下处理\",{\"1\":{\"621\":1}}],[\"对任何缓存中的数据的更改都必须传播到对等缓冲中的其他副本\",{\"1\":{\"1351\":1}}],[\"对应class实例的引用\",{\"1\":{\"1540\":1}}],[\"对应class实例的引用等信息\",{\"1\":{\"1540\":1}}],[\"对应上面例子中的hashmap\",{\"1\":{\"1495\":1}}],[\"对应info统计的rdb\",{\"1\":{\"725\":1}}],[\"对应的bean\",{\"1\":{\"1513\":1}}],[\"对应的binlog\",{\"1\":{\"621\":1}}],[\"对应的进程处于用户态\",{\"1\":{\"1456\":1}}],[\"对应的进程处于内核态\",{\"1\":{\"1456\":1}}],[\"对应的统计项的描述\",{\"1\":{\"695\":1}}],[\"对应的统计项的值\",{\"1\":{\"695\":1}}],[\"对应的就是collect方法的三个函数式接口\",{\"1\":{\"1485\":1}}],[\"对应的就是mysql\",{\"1\":{\"619\":2}}],[\"对应的就是一个没有显式索引的innodb表排序的过程\",{\"1\":{\"558\":1}}],[\"对应的也有等待gtid的方案\",{\"1\":{\"611\":1}}],[\"对应的lsn分别是50\",{\"1\":{\"588\":1}}],[\"对应的是hard\",{\"1\":{\"588\":1}}],[\"对应的风险是\",{\"1\":{\"587\":1}}],[\"对应的执行语句的序列\",{\"1\":{\"559\":2}}],[\"对应的流程图如下\",{\"1\":{\"538\":1,\"628\":1}}],[\"对应的sql语句是\",{\"1\":{\"493\":1}}],[\"对应的主键id也就是图中的id\",{\"1\":{\"491\":1}}],[\"对应的索引k上的记录项\",{\"1\":{\"475\":1}}],[\"对应的元素值\",{\"1\":{\"426\":1}}],[\"对字符串进行增量\",{\"1\":{\"717\":1}}],[\"对一个近似平衡的二叉树的sub\",{\"1\":{\"1497\":1}}],[\"对一个或多个保存二进制位的字符串\",{\"1\":{\"715\":1}}],[\"对一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性\",{\"1\":{\"677\":1}}],[\"对设置到哈希表\",{\"1\":{\"710\":1}}],[\"对被驱动表的访问成本尽量低\",{\"1\":{\"692\":1}}],[\"对被驱动表的全表扫描次数就越少\",{\"1\":{\"540\":1}}],[\"对驱动表进行查询后得到的记录条数称之为驱动表的扇出\",{\"1\":{\"691\":1}}],[\"对驱动表t1做了全表扫描\",{\"1\":{\"538\":1}}],[\"对结果集进行排序等这些操作损耗的时间称之为cpu成本\",{\"1\":{\"682\":1}}],[\"对整个表加拍他锁之前\",{\"1\":{\"670\":1}}],[\"对整个表加共享锁之前\",{\"1\":{\"670\":1}}],[\"对decimal\",{\"1\":{\"665\":1}}],[\"对调这两行的位置即可\",{\"1\":{\"621\":1}}],[\"对客户端比较友好\",{\"1\":{\"606\":1}}],[\"对比\",{\"0\":{\"732\":1}}],[\"对比各种方案\",{\"0\":{\"688\":1}}],[\"对比各种执行方案的代价\",{\"1\":{\"683\":1}}],[\"对比之后找出成本最低的方案\",{\"1\":{\"683\":1}}],[\"对比位点和对比gtid这两种方法\",{\"1\":{\"609\":1}}],[\"对比位点确保主备无延迟\",{\"1\":{\"609\":1}}],[\"对比gtid集合确保主备无延迟\",{\"1\":{\"609\":1}}],[\"对比按表分发和按行分发这两个方案\",{\"1\":{\"599\":1}}],[\"对比双m结构和m\",{\"1\":{\"592\":1}}],[\"对比statement和row的优缺点\",{\"1\":{\"591\":1}}],[\"对id=1这一行的修改\",{\"1\":{\"584\":1}}],[\"对系统影响小\",{\"1\":{\"563\":1}}],[\"对链表里的每个临时表\",{\"1\":{\"549\":1}}],[\"对proxy端的压力比较大\",{\"1\":{\"548\":1}}],[\"对中间层的开发能力要求比较高\",{\"1\":{\"548\":1}}],[\"对其填充\",{\"1\":{\"1361\":1}}],[\"对其它线程不可见\",{\"1\":{\"547\":1}}],[\"对其使用散列函数\",{\"1\":{\"307\":1}}],[\"对表t2做了全表扫描\",{\"1\":{\"544\":1}}],[\"对表t1和t2都做了一次全表扫描\",{\"1\":{\"540\":1}}],[\"对磁盘的读比较接近顺序读\",{\"1\":{\"541\":1}}],[\"对常见的做法就是使用缓存\",{\"1\":{\"534\":1}}],[\"对最终的结果集没有并没有贡献\",{\"1\":{\"527\":1}}],[\"对索引包含的所有字段先做判断\",{\"1\":{\"655\":1}}],[\"对索引的key进行一次hash计算就可以定位出数据存储的位置\",{\"1\":{\"641\":1}}],[\"对索引字段做函数操作\",{\"1\":{\"503\":1,\"504\":1,\"505\":1}}],[\"对索引中包含的字段先做判断\",{\"1\":{\"477\":1}}],[\"对角线上的元素等于上一个对角线元素加上当前元素\",{\"1\":{\"426\":1}}],[\"对称二叉树\",{\"0\":{\"406\":1}}],[\"对每一对相邻的元素作同样的动作\",{\"1\":{\"317\":1}}],[\"对于实习和校招的小伙伴来讲\",{\"1\":{\"1866\":1}}],[\"对于实习和校招的小伙伴来讲一定要好好学这部分的内容\",{\"1\":{\"1847\":1}}],[\"对于新手或者校招的小伙伴\",{\"1\":{\"1852\":1}}],[\"对于支持jsp的web服务器\",{\"1\":{\"1571\":1}}],[\"对于8g物理内存的机器来说\",{\"1\":{\"1541\":1}}],[\"对于原型bean\",{\"1\":{\"1525\":1}}],[\"对于简单的遍历\",{\"1\":{\"1499\":1}}],[\"对于任意给定的元素\",{\"1\":{\"1499\":1}}],[\"对于任意给定的对象\",{\"1\":{\"1425\":1}}],[\"对于串行流和中间操作都是无状态的并行流\",{\"1\":{\"1498\":1}}],[\"对于可变的元来说\",{\"1\":{\"1497\":1}}],[\"对于可以读到就数据的请求\",{\"1\":{\"607\":1}}],[\"对于元的操作也是很有用的\",{\"1\":{\"1497\":1}}],[\"对于并行计算\",{\"1\":{\"1500\":1}}],[\"对于并行流管道来说\",{\"1\":{\"1499\":1}}],[\"对于并行流管道\",{\"1\":{\"1495\":1}}],[\"对于并发的collectors\",{\"1\":{\"1492\":1}}],[\"对于toset方法\",{\"1\":{\"1495\":1}}],[\"对于tolist还有一个接受的更宽广的tocollection\",{\"1\":{\"1495\":1}}],[\"对于非并发的collectors\",{\"1\":{\"1492\":1}}],[\"对于具体的实现不应该对生成的supplier\",{\"1\":{\"1492\":1}}],[\"对于无序的要求就被放松了\",{\"1\":{\"1492\":1}}],[\"对于无序的字段\",{\"1\":{\"493\":1}}],[\"对于流的串行实现会创建一个单个的结果容器\",{\"1\":{\"1492\":1}}],[\"对于流中元素进行处理的时候\",{\"1\":{\"1489\":1}}],[\"对于joining方法\",{\"1\":{\"1495\":1}}],[\"对于jdk8中的重要的api全部都介绍完成\",{\"1\":{\"1490\":1}}],[\"对于java而言\",{\"1\":{\"1470\":1}}],[\"对于该sql所做的工作如果换成咱们的stream来实现那会是个什么样子呢\",{\"1\":{\"1488\":1}}],[\"对于该class的锁\",{\"1\":{\"1362\":1}}],[\"对于以上例子我们再做一个小的扩展\",{\"1\":{\"1484\":1}}],[\"对于其中的每一种\",{\"1\":{\"1479\":1}}],[\"对于前面list集合遍历的例子\",{\"1\":{\"1474\":1}}],[\"对于前面使用lambda表达式来实现集合遍历的例子还可以这样做\",{\"1\":{\"1470\":1}}],[\"对于变量前面的类型\",{\"1\":{\"1470\":1}}],[\"对于初学者而言\",{\"1\":{\"1469\":1}}],[\"对于网络io来说\",{\"1\":{\"1440\":1}}],[\"对于哈希算法而言\",{\"1\":{\"1423\":1}}],[\"对于上面注释中提到的为什么可以强转\",{\"1\":{\"1497\":1}}],[\"对于上面的例子而言\",{\"1\":{\"1488\":1}}],[\"对于上面的例子\",{\"1\":{\"1359\":1}}],[\"对于上述四种类型的类\",{\"1\":{\"1421\":1}}],[\"对于某些任务只能单线程执行\",{\"1\":{\"1387\":1}}],[\"对于mesa管程来说\",{\"1\":{\"1360\":1}}],[\"对于myisam存储引擎的表不做不带where条件的count查询性能是很高的\",{\"1\":{\"663\":1}}],[\"对于mysql\",{\"1\":{\"524\":1}}],[\"对于硬件\",{\"1\":{\"1350\":1}}],[\"对于脚本的运行结果有以下规则\",{\"1\":{\"761\":1}}],[\"对于内存比较大的示例会造成长时间则色\",{\"1\":{\"724\":1}}],[\"对于主键和唯一二级索引则没有这个问题\",{\"1\":{\"695\":1}}],[\"对于普通的二级索引\",{\"1\":{\"695\":1}}],[\"对于普通索引来说\",{\"1\":{\"479\":2,\"480\":1}}],[\"对于n个表的连接查询\",{\"1\":{\"693\":1}}],[\"对于n表连接的话\",{\"1\":{\"693\":1}}],[\"对于四表连接\",{\"1\":{\"693\":1}}],[\"对于三表连接\",{\"1\":{\"693\":1}}],[\"对于两表连接\",{\"1\":{\"693\":1}}],[\"对于左\",{\"1\":{\"692\":1}}],[\"对于被驱动表的查询次数也就越少\",{\"1\":{\"691\":1}}],[\"对于存储字符串或者字节串的列来说\",{\"1\":{\"690\":1}}],[\"对于本例来说就是要计算\",{\"1\":{\"686\":1}}],[\"对于使用innodb存储引擎的表来说\",{\"1\":{\"685\":2}}],[\"对于使用myisam存储引擎的表来说\",{\"1\":{\"685\":1}}],[\"对于删除的情况可以认为是update的特殊情况\",{\"1\":{\"679\":1}}],[\"对于性能至关重要\",{\"1\":{\"664\":1}}],[\"对于关联sql的优化策略\",{\"1\":{\"662\":1}}],[\"对于自增且连续的主键排序的分页查询\",{\"1\":{\"659\":1}}],[\"对于单例bean\",{\"1\":{\"1525\":1}}],[\"对于单路排序和双路排序两种模式\",{\"1\":{\"657\":1}}],[\"对于单值索引\",{\"1\":{\"517\":1}}],[\"对于辅助的联合索引\",{\"1\":{\"655\":1}}],[\"对于正在执行的事务\",{\"1\":{\"634\":1}}],[\"对于批量插入数据的语句\",{\"1\":{\"629\":1}}],[\"对于一次io访问\",{\"1\":{\"1438\":1}}],[\"对于一些并发度没那么高的异步场景\",{\"1\":{\"1410\":1}}],[\"对于一些从oracle迁移到mysql的应用\",{\"1\":{\"570\":1}}],[\"对于一个部分累积的结果a而言\",{\"1\":{\"1492\":1}}],[\"对于一个特定的lambda表达式是什么类型的\",{\"1\":{\"1472\":1}}],[\"对于一个频繁插入删除数据的表来说\",{\"1\":{\"631\":1}}],[\"对于一个有高可用机制的mysql集群来说\",{\"1\":{\"625\":1}}],[\"对于delete语句\",{\"1\":{\"621\":1}}],[\"对于innodb存储引擎来说是一个估计值\",{\"1\":{\"685\":1}}],[\"对于innodb存储引擎来说\",{\"1\":{\"682\":1,\"685\":1,\"690\":1,\"694\":1}}],[\"对于innodb存储引擎的表mysql不会存储表的总记录行数\",{\"1\":{\"663\":1}}],[\"对于innodb引擎的表索引下推只能用于二级索引\",{\"1\":{\"655\":1}}],[\"对于innodb表来说\",{\"1\":{\"493\":1,\"557\":1}}],[\"对于insert语句\",{\"1\":{\"621\":1}}],[\"对于必须要拿到最新结果的请求\",{\"1\":{\"607\":1}}],[\"对于\",{\"1\":{\"602\":1}}],[\"对于大事务\",{\"1\":{\"599\":1}}],[\"对于相同行的更新\",{\"1\":{\"581\":1}}],[\"对于read\",{\"1\":{\"571\":1}}],[\"对于没有unordered特性的collectors来说\",{\"1\":{\"1492\":1}}],[\"对于没有锁竞争的场合\",{\"1\":{\"1362\":1}}],[\"对于没有数据的历史分区\",{\"1\":{\"563\":1}}],[\"对于没有主键的innodb表磊说\",{\"1\":{\"557\":1}}],[\"对于现在的硬件能力来说都已经是小表了\",{\"1\":{\"563\":1}}],[\"对于分区表的使用有以下需要注意的点\",{\"1\":{\"563\":1}}],[\"对于引擎来说\",{\"1\":{\"561\":1}}],[\"对于引擎层来说\",{\"1\":{\"561\":1}}],[\"对于引用类型\",{\"1\":{\"316\":1}}],[\"对于这个例子的说明\",{\"1\":{\"1496\":1}}],[\"对于这个特定的lambda表达式\",{\"1\":{\"1472\":1}}],[\"对于这两个不同的函数式接口的实现都是\",{\"1\":{\"1472\":1}}],[\"对于这种极度不平衡的树\",{\"1\":{\"1497\":1}}],[\"对于这种任务最大线程数一般会大于cpu核心数很多倍\",{\"1\":{\"1387\":1}}],[\"对于这种业务模式来说\",{\"1\":{\"481\":1}}],[\"对于这样的任务最佳的线程数为cpu核心数的1～2倍\",{\"1\":{\"1387\":1}}],[\"对于这10000个准备排序的\",{\"1\":{\"558\":1}}],[\"对于有序的遍历而言\",{\"1\":{\"1500\":1}}],[\"对于有状态的并行流\",{\"1\":{\"1498\":1}}],[\"对于有多个列的联合索引来说\",{\"1\":{\"695\":1}}],[\"对于有主键的innodb表来说\",{\"1\":{\"557\":1}}],[\"对于有索引的表\",{\"1\":{\"459\":1}}],[\"对于sink来说\",{\"1\":{\"1500\":1}}],[\"对于stream的操作我们只能进行一次\",{\"1\":{\"1487\":1}}],[\"对于server层来说\",{\"1\":{\"561\":1}}],[\"对于session\",{\"1\":{\"547\":1}}],[\"对于sql其实是一个描述性的语言\",{\"1\":{\"1488\":1}}],[\"对于sql\",{\"1\":{\"505\":1}}],[\"对于表t2来说\",{\"1\":{\"542\":1}}],[\"对于第一种\",{\"1\":{\"1470\":1}}],[\"对于第一个问题\",{\"1\":{\"540\":1}}],[\"对于第二个问题\",{\"1\":{\"540\":1}}],[\"对于返回的结果集\",{\"1\":{\"536\":1}}],[\"对于collectors静态工厂来说\",{\"1\":{\"1495\":1}}],[\"对于count\",{\"1\":{\"533\":1,\"536\":3}}],[\"对于city字段的值相同的行来说\",{\"1\":{\"493\":1}}],[\"对于找出那些\",{\"1\":{\"526\":1}}],[\"对于低效的查询\",{\"1\":{\"518\":1}}],[\"对于全字段的排序流程图会发现\",{\"1\":{\"492\":1}}],[\"对于每一次的调用\",{\"1\":{\"1492\":1}}],[\"对于每一个分区都会创建一个结果容器\",{\"1\":{\"1492\":1}}],[\"对于每一个word值\",{\"1\":{\"557\":1}}],[\"对于每一个位置\",{\"1\":{\"367\":1}}],[\"对于每一行r\",{\"1\":{\"538\":1}}],[\"对于每个记录都是只取前6个字节\",{\"1\":{\"487\":1}}],[\"对于问题二\",{\"1\":{\"484\":1}}],[\"对于查询的场景来说\",{\"1\":{\"479\":1}}],[\"对于整型字段\",{\"1\":{\"479\":1}}],[\"对于唯一索引来说\",{\"1\":{\"479\":1,\"480\":2}}],[\"对于不等于10的记录\",{\"1\":{\"477\":1}}],[\"对于更新压力大的数据库来说\",{\"1\":{\"456\":1}}],[\"对于function接口中的apply\",{\"1\":{\"1475\":1}}],[\"对于f\",{\"1\":{\"438\":1}}],[\"对于长度为2的字串\",{\"1\":{\"428\":1}}],[\"对于长度为1的字串\",{\"1\":{\"428\":1}}],[\"对于数组中的每个元素平方后排序\",{\"1\":{\"362\":1}}],[\"对于计算机来说\",{\"1\":{\"337\":1}}],[\"对于值类型\",{\"1\":{\"316\":1}}],[\"对于测试元素\",{\"1\":{\"307\":1}}],[\"对于树这种数据结构而言\",{\"1\":{\"295\":1}}],[\"哈希算法基本步骤就是三步\",{\"1\":{\"1425\":1}}],[\"哈希桶数组table的长度length大小必须为2n\",{\"1\":{\"1423\":1}}],[\"哈希碰撞的概率就越小\",{\"1\":{\"1423\":1}}],[\"哈希冲突的问题\",{\"1\":{\"1352\":1}}],[\"哈希\",{\"0\":{\"710\":1}}],[\"哈希字段的方式也只能支持等值查询\",{\"1\":{\"489\":1}}],[\"哈希表为解决冲突\",{\"1\":{\"1423\":1}}],[\"哈希表的key就必须是\",{\"1\":{\"599\":1}}],[\"哈希表的key是\",{\"1\":{\"598\":1}}],[\"哈希表这种结构适用于只有等值查询的场景\",{\"1\":{\"469\":1}}],[\"哈希表是一种以键\",{\"1\":{\"469\":1}}],[\"哈希表是解决数组问题的常见手段\",{\"1\":{\"369\":1}}],[\"哈希表\",{\"0\":{\"332\":1,\"379\":1,\"469\":1},\"1\":{\"332\":1,\"468\":1,\"705\":1}}],[\"哈希函数输出3\",{\"1\":{\"307\":1}}],[\"哈夫曼编码等\",{\"1\":{\"293\":1}}],[\"628\",{\"1\":{\"806\":1}}],[\"62c441e80791293dccaebded\",{\"1\":{\"800\":1}}],[\"6380>\",{\"1\":{\"748\":1}}],[\"6381>\",{\"1\":{\"748\":1}}],[\"6379\",{\"1\":{\"704\":4,\"706\":2,\"719\":2,\"758\":1,\"761\":1}}],[\"6379>\",{\"1\":{\"704\":6,\"706\":17,\"707\":23,\"708\":33,\"709\":21,\"710\":19,\"711\":34,\"713\":2,\"714\":7,\"715\":9,\"716\":13,\"717\":13,\"718\":16,\"735\":4,\"746\":1,\"748\":2}}],[\"618ce3941e0853689b0818e2\",{\"1\":{\"1376\":1}}],[\"6191f070079129330ada1209\",{\"1\":{\"1371\":1}}],[\"61\",{\"1\":{\"681\":1,\"686\":5,\"688\":3,\"690\":3}}],[\"615ea79e1efad4070b2d6707\",{\"1\":{\"1534\":1}}],[\"6152cc385653bb6791db436c\",{\"1\":{\"1530\":1}}],[\"615\",{\"1\":{\"665\":1}}],[\"6s\",{\"1\":{\"681\":1,\"684\":2,\"686\":2,\"690\":2,\"691\":2}}],[\"693\",{\"1\":{\"665\":3}}],[\"65535\",{\"1\":{\"667\":1}}],[\"65\",{\"1\":{\"665\":1,\"667\":2}}],[\"6引入了索引下推优化\",{\"1\":{\"655\":1}}],[\"6内部每一次io请求的时间来判断数据库是否出现了问题会精确的多\",{\"1\":{\"616\":1}}],[\"6以后\",{\"1\":{\"666\":1}}],[\"6以后提供的preformance\",{\"1\":{\"616\":1}}],[\"6以及之前的版本里\",{\"1\":{\"549\":1}}],[\"6的版本中\",{\"1\":{\"600\":1}}],[\"6版本中提出的\",{\"1\":{\"1448\":1}}],[\"6版本引入的\",{\"1\":{\"623\":1}}],[\"6版本引入了gtid\",{\"1\":{\"605\":1}}],[\"6版本开始\",{\"1\":{\"611\":1}}],[\"6版本的按库并行策略\",{\"1\":{\"602\":1}}],[\"6版本之前\",{\"1\":{\"597\":1}}],[\"6版本后开始引入了batched\",{\"1\":{\"542\":1}}],[\"60c8c409\",{\"1\":{\"1469\":1}}],[\"607\",{\"1\":{\"665\":1}}],[\"6074\",{\"1\":{\"656\":1}}],[\"608\",{\"1\":{\"665\":1}}],[\"60\",{\"1\":{\"571\":1,\"690\":1,\"724\":1}}],[\"600\",{\"1\":{\"472\":1,\"473\":1,\"718\":2}}],[\"6及之前的版本\",{\"1\":{\"554\":1}}],[\"64位jvm下的对象结构描述\",{\"1\":{\"1361\":1}}],[\"64位开启指针压缩或最大堆内存<32g时4字节\",{\"1\":{\"1361\":1}}],[\"64x的为例\",{\"1\":{\"1356\":1}}],[\"647\",{\"1\":{\"665\":1}}],[\"648\",{\"1\":{\"665\":1}}],[\"64\",{\"1\":{\"486\":1,\"556\":1,\"557\":1,\"692\":1,\"1356\":2,\"1383\":1,\"1541\":1}}],[\"6之后的版本中\",{\"1\":{\"681\":1}}],[\"6之后引入的索引下推优化\",{\"1\":{\"477\":1}}],[\"6之前的版本来说\",{\"1\":{\"681\":1}}],[\"6之前的版本\",{\"1\":{\"655\":1}}],[\"6之前\",{\"1\":{\"477\":1,\"695\":1}}],[\"6\",{\"1\":{\"307\":1,\"327\":1,\"400\":1,\"472\":1,\"473\":1,\"487\":5,\"488\":1,\"498\":1,\"505\":1,\"515\":1,\"568\":1,\"656\":2,\"686\":2,\"688\":1,\"695\":1,\"708\":4,\"709\":1,\"710\":3,\"711\":5,\"738\":1,\"1461\":1,\"1476\":2,\"1484\":4,\"1486\":1,\"1487\":6,\"1497\":1,\"1864\":1}}],[\"4eec7777\",{\"1\":{\"1486\":1}}],[\"4次用户态和内核态的切换\",{\"1\":{\"1458\":1}}],[\"4次用户态和内核态切换\",{\"1\":{\"1457\":1}}],[\"4次上下文切换次数\",{\"1\":{\"1457\":1}}],[\"4次拷贝次数\",{\"1\":{\"1457\":1}}],[\"4内核中\",{\"1\":{\"1453\":1}}],[\"4之后\",{\"1\":{\"1449\":1}}],[\"4之前\",{\"1\":{\"1449\":1}}],[\"41629346\",{\"1\":{\"1486\":1}}],[\"4151\",{\"1\":{\"713\":1}}],[\"41\",{\"1\":{\"692\":1}}],[\"47\",{\"1\":{\"688\":1}}],[\"494\",{\"1\":{\"665\":3}}],[\"466\",{\"1\":{\"665\":3}}],[\"446\",{\"1\":{\"665\":1}}],[\"483\",{\"1\":{\"665\":2}}],[\"4294967295\",{\"1\":{\"631\":3,\"708\":1,\"709\":1}}],[\"42000\",{\"1\":{\"459\":1}}],[\"450\",{\"1\":{\"672\":1,\"692\":1}}],[\"45\",{\"1\":{\"643\":1}}],[\"456\",{\"1\":{\"531\":1}}],[\"459\",{\"0\":{\"389\":1}}],[\"4直到不满足name=\",{\"1\":{\"657\":1}}],[\"4直到不满足city=\",{\"1\":{\"492\":1}}],[\"4直到city的值不满足查询条件为止\",{\"1\":{\"491\":1}}],[\"40\",{\"1\":{\"686\":2,\"694\":1,\"1362\":1,\"1464\":1,\"1475\":1,\"1480\":2,\"1481\":2,\"1482\":1,\"1490\":1}}],[\"402\",{\"1\":{\"665\":3}}],[\"400000253193539\",{\"1\":{\"713\":1}}],[\"40000134706497\",{\"1\":{\"713\":1}}],[\"400\",{\"1\":{\"480\":2}}],[\"404b9385\",{\"1\":{\"1486\":1}}],[\"404\",{\"0\":{\"410\":1},\"1\":{\"1872\":1}}],[\"4树是4阶b树\",{\"1\":{\"349\":1}}],[\"4树都是b树的特例\",{\"1\":{\"349\":1}}],[\"4树实对2\",{\"1\":{\"348\":1}}],[\"4树\",{\"0\":{\"348\":1}}],[\"4这个位置已经被\",{\"1\":{\"307\":1}}],[\"4和7\",{\"1\":{\"307\":1}}],[\"4\",{\"1\":{\"307\":1,\"329\":6,\"400\":1,\"467\":1,\"480\":2,\"487\":1,\"498\":5,\"505\":4,\"514\":7,\"515\":1,\"559\":1,\"561\":8,\"562\":2,\"566\":1,\"567\":2,\"568\":3,\"571\":2,\"591\":2,\"596\":2,\"599\":3,\"629\":3,\"665\":6,\"666\":1,\"667\":2,\"671\":1,\"692\":1,\"704\":1,\"708\":5,\"709\":5,\"710\":3,\"711\":10,\"715\":2,\"716\":1,\"717\":1,\"761\":1,\"1356\":3,\"1460\":1,\"1462\":2,\"1471\":2,\"1476\":2,\"1482\":1,\"1484\":1,\"1486\":2,\"1494\":3,\"1497\":1,\"1528\":1,\"1541\":1,\"1861\":1}}],[\"时间紧张的小伙伴可以不用在整合这里花费时间\",{\"1\":{\"1860\":1}}],[\"时间有限的小伙伴\",{\"1\":{\"1847\":1}}],[\"时间单位\",{\"1\":{\"1353\":1}}],[\"时间过了之后还是没有任何事件到来\",{\"1\":{\"740\":1}}],[\"时间戳\",{\"1\":{\"666\":1}}],[\"时间值或持续时间\",{\"1\":{\"666\":1}}],[\"时间\",{\"1\":{\"454\":1,\"664\":1,\"1362\":1}}],[\"时间复杂度近似是n+n\",{\"1\":{\"538\":1}}],[\"时间复杂度为o\",{\"1\":{\"330\":1,\"368\":1,\"470\":1}}],[\"时间复杂度与数组长度无关\",{\"1\":{\"316\":1}}],[\"时间效率高和低存储\",{\"1\":{\"282\":1}}],[\"时\",{\"1\":{\"307\":1,\"320\":1,\"487\":1,\"604\":1,\"733\":1,\"1362\":1,\"1423\":1,\"1459\":1}}],[\"布隆过滤器的优点是空间效率和查询时间都远远超过一般的算法\",{\"1\":{\"307\":1}}],[\"布隆过滤器有一个可预测的误判率\",{\"1\":{\"307\":1}}],[\"布隆过滤器本质上是由长度为m的位向量或位列表\",{\"1\":{\"307\":1}}],[\"布隆过滤器由一个很长的二进制向量和一系列随机映射函数构成\",{\"1\":{\"307\":1}}],[\"布隆过滤器\",{\"0\":{\"306\":1},\"1\":{\"764\":1}}],[\"单元测试\",{\"1\":{\"1861\":1}}],[\"单元素的遍历迭代\",{\"1\":{\"1497\":1}}],[\"单从使用的角度而言\",{\"1\":{\"1489\":1}}],[\"单列集合\",{\"0\":{\"1416\":1}}],[\"单生产者\",{\"1\":{\"1397\":1,\"1398\":1}}],[\"单任务执行耗时以及并行数都会影响到fork\",{\"1\":{\"1387\":1}}],[\"单链表结构\",{\"1\":{\"1380\":1}}],[\"单向链表\",{\"1\":{\"1367\":1}}],[\"单核cpu自旋就是浪费\",{\"1\":{\"1362\":1}}],[\"单线程程序\",{\"1\":{\"1351\":1}}],[\"单例池\",{\"1\":{\"1528\":1}}],[\"单例或圆形\",{\"1\":{\"1509\":1}}],[\"单例集合和多列集合\",{\"1\":{\"1415\":1}}],[\"单例对象能在ioc容器启动后注册吗\",{\"0\":{\"1142\":1}}],[\"单例模式\",{\"0\":{\"999\":1}}],[\"单例模式有什么应用场景\",{\"0\":{\"279\":1}}],[\"单例模式有哪些实现方式\",{\"0\":{\"273\":1}}],[\"单体对象作为依赖来源\",{\"0\":{\"1137\":1}}],[\"单一类型依赖查找\",{\"0\":{\"1101\":1}}],[\"单机单个哨兵\",{\"0\":{\"757\":1}}],[\"单台服务器内存容量有限\",{\"1\":{\"745\":1}}],[\"单台服务器故障率高\",{\"1\":{\"745\":1}}],[\"单台服务器难以负载大量的请求\",{\"1\":{\"745\":1}}],[\"单次查询s2\",{\"1\":{\"692\":1}}],[\"单次查询驱动表的成本\",{\"1\":{\"691\":1}}],[\"单次访问被驱动表的成本\",{\"1\":{\"692\":2}}],[\"单次访问驱动表的成本\",{\"1\":{\"692\":1}}],[\"单次io请求时间超过200毫秒属于异常\",{\"1\":{\"616\":1}}],[\"单独查询表的成本\",{\"1\":{\"690\":1}}],[\"单精度浮点数值\",{\"1\":{\"665\":1}}],[\"单位是字节\",{\"1\":{\"1546\":1}}],[\"单位是皮秒\",{\"1\":{\"616\":1}}],[\"单位时间内\",{\"1\":{\"1413\":1}}],[\"单位为微秒\",{\"1\":{\"725\":1}}],[\"单位与半径单位相同\",{\"1\":{\"713\":1}}],[\"单位字节\",{\"1\":{\"690\":1}}],[\"单位byte\",{\"1\":{\"657\":1}}],[\"单路排序会把需要查询的字段都放到sort\",{\"1\":{\"657\":1}}],[\"单路排序的详细过程\",{\"1\":{\"657\":1}}],[\"单路排序\",{\"1\":{\"657\":2}}],[\"单个事务如果超过设置的行的阈值\",{\"1\":{\"599\":1}}],[\"单表查询的成本\",{\"0\":{\"683\":1}}],[\"单表或者单分区的数据一千万行\",{\"1\":{\"563\":1}}],[\"单表索引分析\",{\"0\":{\"498\":1}}],[\"单调递增或者单调递减\",{\"1\":{\"304\":1}}],[\"要对元素的结构上一些修改进行相应检测\",{\"1\":{\"1497\":1}}],[\"要掌握整个的流程\",{\"1\":{\"1490\":1}}],[\"要完成这样的一个sql的功能\",{\"1\":{\"1488\":1}}],[\"要完成这个交易\",{\"1\":{\"580\":1}}],[\"要实现这两个接口\",{\"1\":{\"1484\":1}}],[\"要实现上述相同的需求\",{\"1\":{\"538\":1}}],[\"要使指向该对象的指针永远不会逃逸\",{\"1\":{\"1365\":1}}],[\"要使用linkedlist\",{\"1\":{\"1495\":1}}],[\"要使用所谓的索引统计数据来进行估算\",{\"1\":{\"690\":1}}],[\"要使用二分查找的前题是\",{\"1\":{\"304\":1}}],[\"要比较的值\",{\"1\":{\"1356\":1}}],[\"要交换的值\",{\"1\":{\"1356\":1}}],[\"要进行2000次的index\",{\"1\":{\"690\":1}}],[\"要进入young区域\",{\"1\":{\"543\":1}}],[\"要出现这样得情况\",{\"1\":{\"633\":1}}],[\"要想深入了解这其中的原理\",{\"1\":{\"1453\":1}}],[\"要想恢复数据\",{\"1\":{\"622\":1}}],[\"要想更深入的了解\",{\"1\":{\"454\":1}}],[\"要理解等主库位点方案\",{\"1\":{\"610\":1}}],[\"要理解这个现象\",{\"1\":{\"483\":1}}],[\"要判断备库无延迟\",{\"1\":{\"609\":1}}],[\"要从主库的master\",{\"1\":{\"604\":1}}],[\"要保证相同的先后顺序\",{\"1\":{\"602\":1}}],[\"要等第一组事务完全执行完成后\",{\"1\":{\"601\":1}}],[\"要在表t1上执行update\",{\"1\":{\"599\":1}}],[\"要解决热点表的并行复制问题\",{\"1\":{\"599\":1}}],[\"要解决这个问题\",{\"1\":{\"592\":1,\"609\":1,\"629\":1}}],[\"要用到上文中提到的server\",{\"1\":{\"592\":1}}],[\"要更新的是记录之间的\",{\"1\":{\"585\":1}}],[\"要给d=5的语句加上锁\",{\"1\":{\"584\":1}}],[\"要把最可能造成锁冲突\",{\"1\":{\"580\":1}}],[\"要考虑先暂停ddl\",{\"1\":{\"578\":1}}],[\"要及时drop掉\",{\"1\":{\"563\":1}}],[\"要先主动跳过这些错误\",{\"1\":{\"604\":1}}],[\"要先搜索索引a\",{\"1\":{\"538\":1}}],[\"要先判断有没有对应的查询权限\",{\"1\":{\"459\":1}}],[\"要遵守最佳左前缀法则\",{\"1\":{\"507\":1}}],[\"要转成utf8mb4\",{\"1\":{\"505\":1}}],[\"要查询所有年份中7月份的交易记录总数\",{\"1\":{\"503\":1}}],[\"要换一个算法\",{\"1\":{\"492\":1}}],[\"要分成很多个临时文件\",{\"1\":{\"492\":1}}],[\"要回主键索引取4次数据\",{\"1\":{\"487\":1}}],[\"要读page2的时候\",{\"1\":{\"482\":1}}],[\"要插入\",{\"1\":{\"480\":1}}],[\"要多做的那一次\",{\"1\":{\"479\":1}}],[\"要根据市民的身份证号查询他的姓名\",{\"1\":{\"475\":1}}],[\"要求出集合中每一个元素的平方并打印\",{\"1\":{\"1486\":1}}],[\"要求映射种的key是不可变对象\",{\"1\":{\"1421\":1}}],[\"要求给表名加固定的后缀\",{\"1\":{\"624\":1}}],[\"要求按照b\",{\"1\":{\"485\":1}}],[\"要求建表语句里面一定要有自增主键\",{\"1\":{\"472\":1}}],[\"要求x和y所在的集合不相交\",{\"1\":{\"356\":1}}],[\"要写出具体的字段\",{\"1\":{\"467\":1}}],[\"要说明这个问题\",{\"1\":{\"464\":1}}],[\"要么一起回滚\",{\"1\":{\"1532\":1}}],[\"要么一起提交\",{\"1\":{\"1532\":1}}],[\"要么描述的是中间操作\",{\"1\":{\"1498\":1}}],[\"要么先记session\",{\"1\":{\"629\":1}}],[\"要么放弃继续查询\",{\"1\":{\"617\":1}}],[\"要么全部失败\",{\"1\":{\"569\":1}}],[\"要么全部成功\",{\"1\":{\"569\":1}}],[\"要么是将stream转化为集合\",{\"1\":{\"1486\":1}}],[\"要么是某些操作执行得太慢\",{\"1\":{\"518\":1}}],[\"要么是某些操作被额外地重复了很多次\",{\"1\":{\"518\":1}}],[\"要么是红色\",{\"1\":{\"343\":1}}],[\"要么让子任务运行得更快\",{\"1\":{\"518\":1}}],[\"要么减少子任务的执行次数\",{\"1\":{\"518\":1}}],[\"要么消除其中一些子任务\",{\"1\":{\"518\":1}}],[\"要么就是late\",{\"1\":{\"1497\":1}}],[\"要么就是在原位置再移动2次幂的位置\",{\"1\":{\"1427\":1}}],[\"要么就是先写完redo\",{\"1\":{\"464\":1}}],[\"要么就有两个\",{\"1\":{\"347\":1}}],[\"要么具有4个孩子\",{\"1\":{\"348\":1}}],[\"要么具有3个孩子\",{\"1\":{\"347\":1}}],[\"要如何进行优化\",{\"0\":{\"180\":1}}],[\"直至队列空出位置\",{\"1\":{\"1378\":1}}],[\"直译为\",{\"1\":{\"1360\":1}}],[\"直接去学习\",{\"1\":{\"1861\":1}}],[\"直接自己从开始学算法\",{\"1\":{\"1850\":1}}],[\"直接做\",{\"1\":{\"1847\":1}}],[\"直接内存\",{\"0\":{\"1586\":1}}],[\"直接引用\",{\"1\":{\"1540\":1}}],[\"直接新建一个rootbeandefinition\",{\"1\":{\"1524\":1}}],[\"直接新建节点添加\",{\"1\":{\"1426\":1}}],[\"直接抛出异常\",{\"1\":{\"1497\":1}}],[\"直接进行实例化\",{\"1\":{\"1527\":1}}],[\"直接进行强制类型转换\",{\"1\":{\"1494\":1}}],[\"直接进入等待\",{\"1\":{\"581\":1}}],[\"直接获取响应的segment\",{\"1\":{\"1430\":1}}],[\"直接获取相应的\",{\"1\":{\"1430\":1}}],[\"直接覆盖value\",{\"1\":{\"1426\":1}}],[\"直接value\",{\"1\":{\"1426\":1}}],[\"直接决定了哈希方法的离散性能\",{\"1\":{\"1425\":1}}],[\"直接结束返回\",{\"1\":{\"1408\":1}}],[\"直接在该位置写入或者读取数据\",{\"1\":{\"1396\":1}}],[\"直接在内存中参与计算\",{\"1\":{\"548\":1}}],[\"直接传递\",{\"1\":{\"1386\":2}}],[\"直接加到last后面\",{\"1\":{\"1380\":1}}],[\"直接走轻量级锁的逻辑\",{\"1\":{\"1362\":1}}],[\"直接累加到该变量上\",{\"1\":{\"1357\":1}}],[\"直接用int\",{\"1\":{\"665\":1}}],[\"直接跳过1032和1062这两类错误是无损的\",{\"1\":{\"604\":1}}],[\"直接设置跳过指定的错误\",{\"1\":{\"604\":1}}],[\"直接把连接切到备库b\",{\"1\":{\"596\":1}}],[\"直接把insert语句转成delete语句\",{\"1\":{\"591\":1}}],[\"直接访问内存得到数据\",{\"1\":{\"557\":1}}],[\"直接排序优化group\",{\"0\":{\"555\":1}}],[\"直接从\",{\"1\":{\"1360\":1}}],[\"直接从临时表中取数据返回\",{\"1\":{\"553\":1}}],[\"直接从索引中过滤不需要的记录并返回命中的结果\",{\"1\":{\"527\":1}}],[\"直接从内存返回\",{\"1\":{\"482\":1}}],[\"直接使用base累加数值\",{\"1\":{\"1357\":1}}],[\"直接使用kill命令也是有效的\",{\"1\":{\"617\":1}}],[\"直接使用磁盘临时表\",{\"1\":{\"555\":1}}],[\"直接使用\",{\"1\":{\"508\":1}}],[\"直接使用递归求接斐波那契数列\",{\"1\":{\"424\":1}}],[\"直接更新内存\",{\"1\":{\"482\":1}}],[\"直接判断并跳过\",{\"1\":{\"477\":1}}],[\"直接过滤掉不满足条件的记录\",{\"1\":{\"477\":1}}],[\"直接将这个索引设置为主键\",{\"1\":{\"472\":1}}],[\"直接暴力递归的时间复杂度是o\",{\"1\":{\"429\":1}}],[\"直接求解即可\",{\"1\":{\"425\":1,\"427\":1}}],[\"直接返回结果\",{\"1\":{\"1495\":1}}],[\"直接返回错误\",{\"1\":{\"605\":1}}],[\"直接返回\",{\"1\":{\"435\":2,\"1408\":1,\"1431\":1}}],[\"直接返回数组0下标处的那个元素即可\",{\"1\":{\"354\":1}}],[\"直接返回失败\",{\"1\":{\"302\":1}}],[\"直接定址法\",{\"1\":{\"332\":1}}],[\"直到找到唯一的bean\",{\"1\":{\"1507\":1}}],[\"直到找到第一个大于x的值\",{\"1\":{\"628\":1}}],[\"直到一个终止操作开始的时候\",{\"1\":{\"1498\":1}}],[\"直到有描述符就绪\",{\"1\":{\"1446\":1}}],[\"直到有线程退出\",{\"1\":{\"613\":1}}],[\"直到成功\",{\"1\":{\"1431\":1}}],[\"直到队列里有数据\",{\"1\":{\"1378\":1}}],[\"直到线程使用的数据并释放读锁之后\",{\"1\":{\"1375\":1}}],[\"直到占用资源者释放该资源\",{\"1\":{\"1354\":1}}],[\"直到消息到达时才被唤醒\",{\"1\":{\"1354\":1}}],[\"直到slave被纠正为向正确的master那里同步数据时\",{\"1\":{\"761\":1}}],[\"直到session\",{\"1\":{\"618\":1,\"634\":1}}],[\"直到缓存区中有空闲空间挪出来了\",{\"1\":{\"739\":1}}],[\"直到新的数据刀来或者连接关闭了\",{\"1\":{\"739\":1}}],[\"直到rdb过程完成为止\",{\"1\":{\"724\":1}}],[\"直到提交时才会开始执行\",{\"1\":{\"716\":1}}],[\"直到锁定行的session提交\",{\"1\":{\"674\":1}}],[\"直到这个库执行的事务中包含传入的gtid\",{\"1\":{\"611\":1}}],[\"直到这个值变成0为止\",{\"1\":{\"595\":1}}],[\"直到不再出现停下来的情况\",{\"1\":{\"604\":1}}],[\"直到不满足条件为止\",{\"1\":{\"476\":1}}],[\"直到和这个事务存在冲突关系的worker只剩下一个\",{\"1\":{\"598\":1}}],[\"直到步骤5完成后才能恢复\",{\"1\":{\"595\":1}}],[\"直到超时\",{\"1\":{\"581\":1}}],[\"直到事务a执行commit之后\",{\"1\":{\"580\":1}}],[\"直到事务a提交之后\",{\"1\":{\"570\":1}}],[\"直到第10000个\",{\"1\":{\"558\":1}}],[\"直到表t1的末尾循环结束\",{\"1\":{\"538\":1}}],[\"直到查到第1000条记录\",{\"1\":{\"493\":1}}],[\"直到查到1000条记录\",{\"1\":{\"493\":1}}],[\"直到查找成功\",{\"1\":{\"304\":1}}],[\"直到在index2上取到的值不是\",{\"1\":{\"487\":1}}],[\"直到需要读page2的时候\",{\"1\":{\"482\":1}}],[\"直到碰到第一个不满足k=5条件的记录\",{\"1\":{\"479\":1}}],[\"直到取到这个表的最后一行\",{\"1\":{\"459\":1}}],[\"直到相遇\",{\"1\":{\"377\":1}}],[\"直到将整个数组排序\",{\"1\":{\"318\":1}}],[\"直到没有任何一对数字需要比较\",{\"1\":{\"317\":1}}],[\"则回滚\",{\"1\":{\"1532\":2}}],[\"则提交事务\",{\"1\":{\"1532\":1}}],[\"则一级缓存生效\",{\"1\":{\"1530\":1}}],[\"则一直使用同一个连接\",{\"1\":{\"455\":1}}],[\"则表示要获取的对象是factory\",{\"1\":{\"1524\":1}}],[\"则表示返回满足条件的数据行里面\",{\"1\":{\"536\":1}}],[\"则判断对应的pointcut是否和当前bean对象的类是否匹配\",{\"1\":{\"1507\":1}}],[\"则修改链表为红黑树\",{\"1\":{\"1431\":1}}],[\"则进行链表操作或者红黑树操作\",{\"1\":{\"1431\":1}}],[\"则进行阻塞\",{\"1\":{\"1378\":1}}],[\"则基于cas策略抢占标记sizectl为\",{\"1\":{\"1431\":1}}],[\"则调用inittable方法初始化\",{\"1\":{\"1431\":1}}],[\"则使用cas无锁的方法将数据添加到容器中\",{\"1\":{\"1431\":1}}],[\"则使用\",{\"1\":{\"1431\":1}}],[\"则使用thread\",{\"1\":{\"1397\":1}}],[\"则初始化\",{\"1\":{\"1431\":1}}],[\"则初始elementdata容量为指定大小\",{\"1\":{\"1419\":1}}],[\"则初始elementdata容量为0\",{\"1\":{\"1419\":1}}],[\"则链表元素会倒置\",{\"1\":{\"1427\":1}}],[\"则直接抛出异常\",{\"1\":{\"1525\":1}}],[\"则直接无所插入\",{\"1\":{\"1431\":1}}],[\"则直接在树中插入键值对\",{\"1\":{\"1426\":1}}],[\"则直接扩容elementdata为1\",{\"1\":{\"1419\":1}}],[\"则扩容elementdata为1\",{\"1\":{\"1419\":1}}],[\"则扩容elementdata为10\",{\"1\":{\"1419\":1}}],[\"则中断处理\",{\"1\":{\"1408\":1}}],[\"则自动退出run\",{\"1\":{\"1401\":1}}],[\"则break\",{\"1\":{\"1394\":1}}],[\"则唤醒阻塞在notfull的线程\",{\"1\":{\"1380\":1}}],[\"则队列抛出oom错误\",{\"1\":{\"1380\":1}}],[\"则消费者挂起\",{\"1\":{\"1379\":1}}],[\"则阻塞在notempty条件上\",{\"1\":{\"1380\":1}}],[\"则阻塞\",{\"1\":{\"1378\":3}}],[\"则其对其他获取到读锁的线程是不可见的\",{\"1\":{\"1375\":1}}],[\"则线程t将会被阻塞\",{\"1\":{\"1375\":1}}],[\"则将生产者挂起\",{\"1\":{\"1379\":1}}],[\"则将cxq中的元素按原有顺序插入到entrylist\",{\"1\":{\"1360\":1}}],[\"则将待插入元素插入到相等元素的后面\",{\"1\":{\"319\":1}}],[\"则也调用父类的longaccumelate\",{\"1\":{\"1357\":1}}],[\"则双向交换\",{\"1\":{\"1356\":1}}],[\"则同返回值为1时的行为相同\",{\"1\":{\"761\":1}}],[\"则保存\",{\"1\":{\"724\":3}}],[\"则创建新的链表\",{\"1\":{\"708\":1}}],[\"则有n\",{\"1\":{\"693\":1}}],[\"则不返回数据\",{\"1\":{\"679\":1}}],[\"则不得不利用磁盘临时文件辅助排序\",{\"1\":{\"491\":1}}],[\"则在自己的类加载路径中查找并载入目标类\",{\"1\":{\"1570\":1}}],[\"则在这个从库执行查询语句\",{\"1\":{\"610\":1,\"611\":1}}],[\"则在中间记录的右搬去继续查找\",{\"1\":{\"304\":1}}],[\"则在中间记录的左搬去继续查找\",{\"1\":{\"304\":1}}],[\"则返回原始对象\",{\"1\":{\"1526\":1}}],[\"则返回代理对象\",{\"1\":{\"1526\":1}}],[\"则返回一个true\",{\"1\":{\"1476\":1}}],[\"则返回\",{\"1\":{\"1394\":1,\"1495\":1,\"1525\":1}}],[\"则返回false\",{\"1\":{\"1378\":1}}],[\"则返回null\",{\"1\":{\"1378\":1}}],[\"则返回nil\",{\"1\":{\"707\":1}}],[\"则返回nll\",{\"1\":{\"610\":1}}],[\"则返回0\",{\"1\":{\"610\":1}}],[\"则它们之间不能设定为主备关系\",{\"1\":{\"592\":1}}],[\"则必须等事务a的操作完成后才能进行更新\",{\"1\":{\"579\":1}}],[\"则数据库就会一致保持readonly状态\",{\"1\":{\"575\":1}}],[\"则事务b执行\",{\"1\":{\"570\":1}}],[\"则v1是1\",{\"1\":{\"570\":1}}],[\"则v1\",{\"1\":{\"570\":2}}],[\"则会判断新扫描的beandefinition与原来的beandefinition是否兼容\",{\"1\":{\"1524\":1}}],[\"则会严重影响hashmap的性能\",{\"1\":{\"1423\":1}}],[\"则会导致队列填满\",{\"1\":{\"1379\":1}}],[\"则会给\",{\"1\":{\"1356\":1}}],[\"则会有4\",{\"1\":{\"693\":1}}],[\"则会使用rowid来构建b+树\",{\"1\":{\"642\":1}}],[\"则会归0再重新递增\",{\"1\":{\"636\":1}}],[\"则会被记录到慢查询日志中\",{\"1\":{\"565\":1}}],[\"则会得到一个升序数组\",{\"1\":{\"443\":1}}],[\"则可能需要重复地访问一部分数据\",{\"1\":{\"531\":1}}],[\"则可能需要一次锁住很多数据\",{\"1\":{\"530\":1}}],[\"则是在启动的过程中\",{\"1\":{\"1531\":1}}],[\"则是默认的\",{\"1\":{\"1431\":1}}],[\"则是提交事务并自动启动下一个事务\",{\"1\":{\"572\":1}}],[\"则是将更新记录在change\",{\"1\":{\"480\":1}}],[\"则是8个字节\",{\"1\":{\"472\":1}}],[\"则往往不容易保证有序插入\",{\"1\":{\"472\":1}}],[\"则需要先搜索k索引树\",{\"1\":{\"472\":1}}],[\"则需要补乘一个x\",{\"1\":{\"438\":1}}],[\"则只会记录必要的信息\",{\"1\":{\"591\":1}}],[\"则只要4个字节\",{\"1\":{\"472\":1}}],[\"则只需要在r5的记录后面插入一个新记录\",{\"1\":{\"472\":1}}],[\"则只需要搜索id这颗b+树\",{\"1\":{\"472\":1}}],[\"则只可能为以下情况之一\",{\"1\":{\"398\":1}}],[\"则该索引仅仅出现在key列表中\",{\"1\":{\"467\":1}}],[\"则该索引将被列出\",{\"1\":{\"467\":1}}],[\"则没有使用索引\",{\"1\":{\"467\":1}}],[\"则被标记为union\",{\"1\":{\"467\":1}}],[\"则偷窃该房屋只有两件房屋\",{\"1\":{\"432\":1}}],[\"则公共祖先在右子树查找\",{\"1\":{\"398\":1}}],[\"则公共祖先在左子树查找\",{\"1\":{\"398\":1}}],[\"则公共祖先为根节点\",{\"1\":{\"398\":2}}],[\"则称root是\",{\"1\":{\"398\":1}}],[\"则称root是p的祖先\",{\"1\":{\"398\":1}}],[\"则反转前k个字符\",{\"1\":{\"384\":1}}],[\"则查找成功\",{\"1\":{\"304\":1}}],[\"则把isend置为false\",{\"1\":{\"302\":2}}],[\"则删掉此节点并朝\",{\"1\":{\"302\":2}}],[\"<context\",{\"1\":{\"1561\":1}}],[\"<connector\",{\"1\":{\"1561\":1}}],[\"<host>\",{\"1\":{\"1561\":1}}],[\"<k\",{\"1\":{\"1495\":1}}],[\"<engine>\",{\"1\":{\"1561\":1}}],[\"<end>\",{\"1\":{\"1493\":1}}],[\"<e\",{\"1\":{\"1498\":2}}],[\"<em>not<\",{\"1\":{\"1471\":2}}],[\"<begin>\",{\"1\":{\"1493\":1}}],[\"<u>\",{\"1\":{\"1475\":1}}],[\"<ul>\",{\"1\":{\"1471\":2}}],[\"<v>\",{\"1\":{\"1475\":12}}],[\"<version>1\",{\"1\":{\"719\":1}}],[\"<version>3\",{\"1\":{\"719\":1}}],[\"<li>\",{\"1\":{\"1471\":4}}],[\"<parent\",{\"1\":{\"1567\":1}}],[\"<password>\",{\"1\":{\"761\":1}}],[\"<p\",{\"1\":{\"1500\":5}}],[\"<pre>\",{\"1\":{\"1472\":1,\"1485\":3}}],[\"<p>like\",{\"1\":{\"1485\":1}}],[\"<p>any\",{\"1\":{\"1476\":4}}],[\"<p>this\",{\"1\":{\"1474\":1,\"1475\":3,\"1476\":2,\"1477\":1,\"1478\":1,\"1485\":1}}],[\"<p>there\",{\"1\":{\"1477\":1}}],[\"<p>the\",{\"1\":{\"1472\":1,\"1485\":1}}],[\"<p>however\",{\"1\":{\"1471\":3}}],[\"<p>if\",{\"1\":{\"1471\":2}}],[\"<p>note\",{\"1\":{\"1471\":2}}],[\"<i>functional\",{\"1\":{\"1471\":2}}],[\"<ip>\",{\"1\":{\"761\":1}}],[\"<t\",{\"1\":{\"1475\":1,\"1486\":1,\"1490\":1,\"1494\":1,\"1495\":8,\"1497\":2}}],[\"<t>\",{\"1\":{\"1383\":1,\"1471\":1,\"1474\":1,\"1475\":7,\"1476\":6,\"1477\":1,\"1478\":5,\"1484\":1,\"1485\":1,\"1486\":1,\"1490\":1,\"1491\":1,\"1492\":1,\"1495\":4,\"1497\":2,\"1498\":2,\"1500\":1,\"1524\":1}}],[\"<to\",{\"1\":{\"761\":2}}],[\"<a>\",{\"1\":{\"1492\":1}}],[\"<a\",{\"1\":{\"1474\":1,\"1475\":3,\"1476\":2,\"1477\":1,\"1478\":1,\"1485\":8}}],[\"<aop\",{\"0\":{\"979\":1,\"980\":1}}],[\"<artifactid>spring\",{\"1\":{\"720\":1}}],[\"<artifactid>fastjson<\",{\"1\":{\"719\":1}}],[\"<artifactid>jedis<\",{\"1\":{\"719\":1}}],[\"<from\",{\"1\":{\"761\":2}}],[\"<r\",{\"1\":{\"1492\":1,\"1494\":1}}],[\"<r>\",{\"1\":{\"1475\":3,\"1485\":3,\"1492\":1,\"1499\":1,\"1500\":1}}],[\"<role>是\",{\"1\":{\"761\":1}}],[\"<role>\",{\"1\":{\"761\":1}}],[\"<redis\",{\"1\":{\"761\":1}}],[\"<numslaves>\",{\"1\":{\"761\":1}}],[\"<milliseconds>\",{\"1\":{\"761\":2}}],[\"<master\",{\"1\":{\"761\":8}}],[\"<quorum>\",{\"1\":{\"761\":1}}],[\"<service>\",{\"1\":{\"1561\":1}}],[\"<server>\",{\"1\":{\"1561\":1}}],[\"<s>\",{\"1\":{\"1500\":2}}],[\"<state>\",{\"1\":{\"761\":1}}],[\"<string\",{\"1\":{\"720\":1}}],[\"<script\",{\"1\":{\"761\":2}}],[\"<sort\",{\"1\":{\"657\":2}}],[\"<groupid>org\",{\"1\":{\"720\":1}}],[\"<groupid>com\",{\"1\":{\"719\":1}}],[\"<groupid>redis\",{\"1\":{\"719\":1}}],[\"<dependency>\",{\"1\":{\"719\":2,\"720\":1}}],[\"<<\",{\"1\":{\"313\":1,\"1427\":2,\"1430\":1,\"1431\":1,\"1498\":1}}],[\"<=\",{\"1\":{\"305\":1,\"332\":1,\"360\":1,\"362\":1,\"364\":3,\"366\":1,\"368\":1,\"375\":1,\"384\":1,\"393\":1,\"397\":2,\"415\":1,\"422\":1,\"424\":2,\"428\":1,\"429\":3,\"435\":6,\"440\":1,\"537\":2,\"541\":3,\"544\":1,\"545\":1,\"546\":1,\"551\":1,\"681\":1,\"684\":1,\"686\":4,\"690\":2,\"692\":8,\"1380\":1,\"1431\":2,\"1478\":1,\"1567\":1}}],[\"<\",{\"1\":{\"302\":3,\"305\":1,\"317\":3,\"318\":3,\"319\":5,\"329\":3,\"359\":1,\"360\":1,\"361\":2,\"362\":1,\"363\":1,\"365\":2,\"366\":8,\"367\":2,\"368\":4,\"380\":1,\"383\":1,\"384\":2,\"385\":11,\"386\":1,\"387\":1,\"388\":4,\"389\":1,\"393\":2,\"399\":1,\"401\":1,\"402\":1,\"403\":1,\"411\":1,\"417\":2,\"419\":2,\"421\":1,\"422\":2,\"424\":2,\"425\":4,\"426\":3,\"427\":2,\"428\":4,\"429\":2,\"430\":1,\"431\":2,\"435\":8,\"438\":2,\"439\":1,\"443\":2,\"467\":1,\"530\":2,\"536\":2,\"556\":1,\"605\":4,\"656\":1,\"673\":1,\"708\":1,\"719\":4,\"720\":1,\"806\":2,\"1353\":1,\"1357\":1,\"1364\":1,\"1380\":1,\"1383\":1,\"1394\":2,\"1427\":4,\"1430\":1,\"1431\":4,\"1451\":1,\"1468\":1,\"1470\":1,\"1471\":2,\"1472\":1,\"1476\":2,\"1485\":3,\"1488\":1,\"1489\":1,\"1491\":1,\"1497\":4,\"1561\":4}}],[\"也难以形成自己的知识体系\",{\"1\":{\"1850\":1}}],[\"也满足了intconsumer的要求\",{\"1\":{\"1497\":1}}],[\"也想求出总和\",{\"1\":{\"1487\":1}}],[\"也想求出最小值\",{\"1\":{\"1487\":1}}],[\"也举出了不少的例子来展示了lambda表达式的应用\",{\"1\":{\"1484\":1}}],[\"也接收了两个不同类型的参数\",{\"1\":{\"1478\":1}}],[\"也已经不再map中了\",{\"1\":{\"1428\":1}}],[\"也能把这些题目都顺利的写出来\",{\"1\":{\"1850\":1}}],[\"也能保证考虑到高低bit都参与到hash的计算中\",{\"1\":{\"1425\":1}}],[\"也能够运行每秒超过10万的查询\",{\"1\":{\"529\":1}}],[\"也能够直接查到id2\",{\"1\":{\"487\":1}}],[\"也避免不了拉链过长的情况\",{\"1\":{\"1423\":1}}],[\"也加入例如高位参与运算的过程\",{\"1\":{\"1423\":1}}],[\"也加上了间隙锁\",{\"1\":{\"585\":1}}],[\"也被称为多线程版本的if\",{\"1\":{\"1407\":1}}],[\"也需要30万年才能用完\",{\"1\":{\"1396\":1}}],[\"也需要将where条件修改为where\",{\"1\":{\"503\":1}}],[\"也叫做匿名偏向状态\",{\"1\":{\"1362\":1}}],[\"也叫做监视器锁\",{\"1\":{\"1359\":1}}],[\"也叫重量级锁\",{\"1\":{\"1361\":1}}],[\"也叫膨胀锁\",{\"1\":{\"1361\":1}}],[\"也叫散列表\",{\"1\":{\"332\":1}}],[\"也只能算作一个人\",{\"1\":{\"714\":1}}],[\"也代表不存在\",{\"1\":{\"708\":1}}],[\"也即是说优化器就直接会把10573当作s1表的扇出值\",{\"1\":{\"691\":1}}],[\"也即任意一个结点到每个叶子结点的路径都包含数量相同的黑结点\",{\"1\":{\"343\":1}}],[\"也正是这样\",{\"1\":{\"628\":1}}],[\"也正是由于这个特性\",{\"1\":{\"547\":1}}],[\"也要发回给主库a\",{\"1\":{\"615\":1}}],[\"也要确保一次性写入\",{\"1\":{\"587\":1}}],[\"也表示备库接收到的日志都已经同步完成\",{\"1\":{\"609\":1}}],[\"也跳过了\",{\"1\":{\"604\":1}}],[\"也就缩短了整个数据恢复需要的时间\",{\"1\":{\"623\":1}}],[\"也就达到了sleep的目的\",{\"1\":{\"608\":1}}],[\"也就不会再出现主键冲突的错误\",{\"1\":{\"605\":1}}],[\"也就意味着\",{\"1\":{\"597\":1}}],[\"也就是一个beanpostprocessor\",{\"1\":{\"1532\":1}}],[\"也就是一个表中有多少条记录\",{\"1\":{\"690\":1}}],[\"也就是代理逻辑\",{\"1\":{\"1531\":1}}],[\"也就是变成一个负数\",{\"1\":{\"1431\":1}}],[\"也就是数组的长度\",{\"1\":{\"1427\":1}}],[\"也就是使用了单链表的头插入方式\",{\"1\":{\"1427\":1}}],[\"也就是等于h\",{\"1\":{\"1425\":1}}],[\"也就是保持了不变性\",{\"1\":{\"1403\":1}}],[\"也就是对于cpu密集型任务\",{\"1\":{\"1387\":1}}],[\"也就是对应着聚簇索引中39条完整的用户记录\",{\"1\":{\"686\":1}}],[\"也就是在condition队列中\",{\"1\":{\"1367\":1}}],[\"也就是在本地打开一片内存\",{\"1\":{\"619\":1}}],[\"也就是unpark\",{\"1\":{\"1367\":1}}],[\"也就是compare\",{\"1\":{\"1356\":1}}],[\"也就是将store\",{\"1\":{\"1350\":1}}],[\"也就是将整库的每个表都select出来存成文本\",{\"1\":{\"574\":1}}],[\"也就是可以将当前的客户端描述符write\",{\"1\":{\"742\":1}}],[\"也就是可能会导致主备同步停止\",{\"1\":{\"615\":1}}],[\"也就是当entrylist为空时\",{\"1\":{\"1360\":1}}],[\"也就是当数据到来时\",{\"1\":{\"740\":1}}],[\"也就是当系统里没有比这个回滚日志更早的read\",{\"1\":{\"571\":1}}],[\"也就是即使表中变动的记录数超过了10\",{\"1\":{\"696\":1}}],[\"也就是该功能默认是开启的\",{\"1\":{\"696\":1}}],[\"也就是组件\",{\"1\":{\"695\":1}}],[\"也就是统计数据默认被存储到磁盘中\",{\"1\":{\"695\":1}}],[\"也就是n\",{\"1\":{\"693\":1}}],[\"也就是s2作为驱动表\",{\"1\":{\"692\":1}}],[\"也就是s1作为驱动表\",{\"1\":{\"692\":1}}],[\"也就是session\",{\"1\":{\"634\":1}}],[\"也就是semi\",{\"1\":{\"609\":1}}],[\"也就是\",{\"1\":{\"690\":1}}],[\"也就是我们计算出来的值\",{\"1\":{\"688\":1}}],[\"也就是需要考虑最优的表连接顺序\",{\"1\":{\"692\":1}}],[\"也就是需要进行多少次页面io\",{\"1\":{\"686\":1}}],[\"也就是需要再多搭建一些备库来增加系统的读能力的时候\",{\"1\":{\"464\":1}}],[\"也就是页a\",{\"1\":{\"686\":1}}],[\"也就是possible\",{\"1\":{\"684\":1}}],[\"也就是总共t1表也扫描了100行\",{\"1\":{\"661\":1}}],[\"也就是总共扫描100行\",{\"1\":{\"538\":1}}],[\"也就是把表t的当前自增值改回2\",{\"1\":{\"628\":1}}],[\"也就是才实现了\",{\"1\":{\"627\":1}}],[\"也就是只需要猜39条记录中有多少符合order\",{\"1\":{\"691\":1}}],[\"也就是只重放这张表的操作\",{\"1\":{\"622\":1}}],[\"也就是只留在了文件系统的page\",{\"1\":{\"588\":1}}],[\"也就是所有存在于set\",{\"1\":{\"605\":1}}],[\"也就是全局事务id\",{\"1\":{\"605\":1}}],[\"也就是主库对应的文件名和日志偏移量\",{\"1\":{\"604\":1}}],[\"也就是a和a\",{\"1\":{\"603\":1}}],[\"也就是a=5这一行\",{\"1\":{\"591\":1}}],[\"也就是readonly=false\",{\"1\":{\"595\":1}}],[\"也就是t3\",{\"1\":{\"594\":1}}],[\"也就是循环复制了\",{\"1\":{\"592\":1}}],[\"也就是下图所展示的主备切换流程\",{\"1\":{\"592\":1}}],[\"也就是下面的这个过程\",{\"1\":{\"554\":1}}],[\"也就是mixed格式的binlog\",{\"1\":{\"591\":1}}],[\"也就是mvcc来实现的\",{\"1\":{\"533\":1}}],[\"也就是备库\",{\"1\":{\"590\":1}}],[\"也就是死锁\",{\"1\":{\"581\":1}}],[\"也就是超时后会再起一个新的session\",{\"1\":{\"578\":1}}],[\"也就是根据每个用户级别有一个单词表\",{\"1\":{\"556\":1}}],[\"也就是没有proxy这一层\",{\"1\":{\"548\":1}}],[\"也就是是否满足t2\",{\"1\":{\"544\":1}}],[\"也就是是否是word的解为\",{\"1\":{\"302\":1}}],[\"也就是扫描了200行\",{\"1\":{\"538\":1}}],[\"也就是扫描了4行\",{\"1\":{\"487\":1}}],[\"也就是不需要排序了\",{\"1\":{\"493\":1}}],[\"也就是步骤7\",{\"1\":{\"492\":1}}],[\"也就是图中绿色部分\",{\"1\":{\"588\":1}}],[\"也就是图中的黄色部分\",{\"1\":{\"588\":1}}],[\"也就是图中的id\",{\"1\":{\"491\":1,\"492\":2}}],[\"也就是图中右下角的这个数据页\",{\"1\":{\"479\":1}}],[\"也就是这个页面上要更新的次数越多\",{\"1\":{\"481\":1}}],[\"也就是尽量使用长连接\",{\"1\":{\"455\":1}}],[\"也就是从连接器到执行器的部分\",{\"1\":{\"454\":1}}],[\"也就是队列中权值最小的那个元素\",{\"1\":{\"354\":1}}],[\"也就是说无论对于串行操作还是并行操作\",{\"1\":{\"1492\":1}}],[\"也就是说数据被拷贝到操作系统内核的缓冲区是需要一个过程的\",{\"1\":{\"1440\":1}}],[\"也就是说需要扩容\",{\"1\":{\"1431\":1}}],[\"也就是说不存在哈希冲突\",{\"1\":{\"1431\":1}}],[\"也就是说当put第二个元素的时候\",{\"1\":{\"1428\":1}}],[\"也就是说linkedblockingqueue是读写分离的\",{\"1\":{\"1380\":1}}],[\"也就是说只能有一个线程可以进行入队或者出队操作\",{\"1\":{\"1379\":1}}],[\"也就是说只要有一个满足条件就会调用fsync\",{\"1\":{\"588\":1}}],[\"也就是说主节点自身处理完写命令后直接返回给客户端\",{\"1\":{\"755\":1}}],[\"也就是说innodb的统计数据默认是存储到内存的\",{\"1\":{\"695\":1}}],[\"也就是说in语句中的参数个数小于200的话\",{\"1\":{\"690\":1}}],[\"也就是说服务器重启之后这些统计数据还在\",{\"1\":{\"695\":1}}],[\"也就是说一条语句在server中执行的成本是和它操作的表使用的存储引擎是没有关系的\",{\"1\":{\"694\":1}}],[\"也就是说优化器需要猜在39条记录中有多少符合上述两个条件\",{\"1\":{\"691\":1}}],[\"也就是说相当于3个单点区间\",{\"1\":{\"686\":1}}],[\"也就是说二级索引范围区间有多少记录\",{\"1\":{\"686\":1}}],[\"也就是说对于任意的输入t1和t2\",{\"1\":{\"1492\":1}}],[\"也就是说对应的范围区间是\",{\"1\":{\"686\":1}}],[\"也就是说对与优化器来说\",{\"1\":{\"504\":1}}],[\"也就是说全表扫描这个过程其实有的b+树非叶子结点是不需要访问的\",{\"1\":{\"685\":1}}],[\"也就是说可以这样计算该值的大小\",{\"1\":{\"685\":1}}],[\"也就是说可以用上被驱动表上的索引\",{\"1\":{\"540\":1}}],[\"也就是说重启mysql\",{\"1\":{\"634\":1}}],[\"也就是说等行锁\",{\"1\":{\"613\":1}}],[\"也就是说在状态3执行查询请求\",{\"1\":{\"609\":1}}],[\"也就是说如果之后有新的事务再执行\",{\"1\":{\"605\":1}}],[\"也就是说它们的writeset没有交集\",{\"1\":{\"602\":1}}],[\"也就是说删除的是a=4这一行\",{\"1\":{\"591\":1}}],[\"也就是说这个读写过程是阻塞的\",{\"1\":{\"1445\":1}}],[\"也就是说这个时候系统处于不可写状态\",{\"1\":{\"595\":1}}],[\"也就是说这个sql需要临时表\",{\"1\":{\"557\":1}}],[\"也就是说这时候\",{\"1\":{\"585\":1}}],[\"也就是说幻读的问题还是没有解决\",{\"1\":{\"584\":1}}],[\"也就是说2017\",{\"1\":{\"561\":1}}],[\"也就是说要在应用线程里面先后执行这个create语句两次\",{\"1\":{\"550\":1}}],[\"也就是说还是会增加扫描行数\",{\"1\":{\"489\":1}}],[\"也就是说两个不同的身份证通过crc32\",{\"1\":{\"489\":1}}],[\"也就是说前缀索引就用不上覆盖索引对查询性能的优化了\",{\"1\":{\"488\":1}}],[\"也就是说取email字段的前7个字节来构建索引的话\",{\"1\":{\"487\":1}}],[\"也就是说必须同时维护\",{\"1\":{\"476\":1}}],[\"也就是说虽然all和index都是读全表\",{\"1\":{\"467\":1}}],[\"也就是说8\",{\"1\":{\"456\":1}}],[\"也就是说\",{\"1\":{\"337\":1,\"435\":1,\"472\":2,\"475\":2,\"479\":1,\"480\":1,\"483\":1,\"484\":2,\"487\":1,\"493\":1,\"503\":2,\"504\":1,\"540\":1,\"541\":2,\"542\":1,\"543\":1,\"549\":1,\"553\":2,\"561\":2,\"578\":1,\"580\":2,\"583\":1,\"584\":2,\"585\":1,\"588\":3,\"591\":1,\"594\":1,\"596\":2,\"598\":1,\"602\":1,\"606\":1,\"608\":1,\"609\":1,\"613\":2,\"618\":3,\"619\":2,\"621\":1,\"622\":1,\"627\":1,\"628\":1,\"629\":2,\"632\":1,\"634\":1,\"665\":1,\"685\":1,\"688\":1,\"1356\":2,\"1375\":1,\"1423\":1,\"1440\":1,\"1441\":1,\"1453\":1,\"1471\":2,\"1472\":1,\"1484\":1,\"1494\":1,\"1541\":1}}],[\"也减少了死锁检测的cpu消耗\",{\"1\":{\"581\":1}}],[\"也称为next\",{\"1\":{\"579\":1}}],[\"也称二叉搜索树\",{\"1\":{\"340\":1}}],[\"也限定了本线程接下来的操作对象\",{\"1\":{\"577\":1}}],[\"也许数据只有20gb\",{\"1\":{\"571\":1}}],[\"也许你想到show\",{\"1\":{\"533\":1}}],[\"也有注入方法的方法\",{\"1\":{\"1525\":1}}],[\"也有可能将底层的流修改为并行流\",{\"1\":{\"1496\":1}}],[\"也有可能会将底层的流修改为串行流\",{\"1\":{\"1496\":1}}],[\"也有可能是t类型以上的类型\",{\"1\":{\"1491\":1}}],[\"也有访问底层硬件设备的权限\",{\"1\":{\"1456\":1}}],[\"也有一些其他的成本常数\",{\"1\":{\"682\":1}}],[\"也有一些方案会让客户端直接连接数据\",{\"1\":{\"548\":1}}],[\"也有自动化系统\",{\"1\":{\"625\":1}}],[\"也有些访问方式可能无需扫描就能返回结果\",{\"1\":{\"527\":1}}],[\"也无法声明返回一个函数的方法\",{\"1\":{\"1470\":1}}],[\"也无法让保存s2报价的操作先执行\",{\"1\":{\"1394\":1}}],[\"也无法使用它来进行统计\",{\"1\":{\"533\":1}}],[\"也无法实现高性能\",{\"1\":{\"518\":1}}],[\"也把数字存起来呢\",{\"1\":{\"533\":1}}],[\"也都是\",{\"1\":{\"505\":1}}],[\"也不能直接调用内核函数的\",{\"1\":{\"1456\":1}}],[\"也不能分给多个不同的worker去执行\",{\"1\":{\"597\":1}}],[\"也不是服务端慢\",{\"1\":{\"619\":1}}],[\"也不需要再额外的排序\",{\"1\":{\"554\":1}}],[\"也不需要排序了\",{\"1\":{\"554\":1}}],[\"也不需要排序\",{\"1\":{\"493\":1}}],[\"也不具备通用性\",{\"1\":{\"485\":1}}],[\"也不会扩容\",{\"1\":{\"1378\":1}}],[\"也不会执行撤销操作\",{\"1\":{\"1362\":1}}],[\"也不会等语句执行完成才释放锁\",{\"1\":{\"629\":1}}],[\"也不会触发叶子节点的分裂\",{\"1\":{\"472\":1}}],[\"也不会影响已经存在连接的权限\",{\"1\":{\"455\":1}}],[\"也判定为代价更小\",{\"1\":{\"485\":1}}],[\"也会处理\",{\"1\":{\"1525\":1}}],[\"也会增加不确定的风险\",{\"1\":{\"1497\":1}}],[\"也会在内部为每个线程分配持有的存储空间的模式\",{\"1\":{\"1405\":1}}],[\"也会利用copy\",{\"1\":{\"1404\":1}}],[\"也会立即返回\",{\"1\":{\"740\":1}}],[\"也会等1秒\",{\"1\":{\"608\":1}}],[\"也会暂时退化为单线程模型\",{\"1\":{\"602\":1}}],[\"也会释放掉\",{\"1\":{\"581\":1}}],[\"也会将其记录到binlog中\",{\"1\":{\"550\":1}}],[\"也会执行merge操作\",{\"1\":{\"480\":1}}],[\"也会被写入到磁盘上\",{\"1\":{\"480\":1}}],[\"也是\",{\"1\":{\"1860\":1}}],[\"也是最有难度的知识\",{\"1\":{\"1850\":1}}],[\"也是用来遍历元当中的元素的\",{\"1\":{\"1497\":1}}],[\"也是这几个基础的函数式接口的特例\",{\"1\":{\"1478\":1}}],[\"也是函数式编程中一个及其重要的概念\",{\"1\":{\"1470\":1}}],[\"也是java8中新增的一个语法糖\",{\"1\":{\"1470\":1}}],[\"也是操作系统真正意义上的零拷贝\",{\"1\":{\"1461\":1}}],[\"也是存竞争锁失败的线程\",{\"1\":{\"1360\":1}}],[\"也是处理的最好的自增id逻辑\",{\"1\":{\"636\":1}}],[\"也是要对应一个只读事务的\",{\"1\":{\"634\":1}}],[\"也是要先停止正在执行的语句\",{\"1\":{\"617\":1}}],[\"也是将delete\",{\"1\":{\"621\":1}}],[\"也是关于客户端常见的一个误解\",{\"1\":{\"619\":1}}],[\"也是可以省略的\",{\"1\":{\"1470\":1}}],[\"也是可以接受的\",{\"1\":{\"607\":1}}],[\"也是可能持久化到磁盘的\",{\"1\":{\"588\":1}}],[\"也是为每个worker\",{\"1\":{\"599\":1}}],[\"也是不合适的\",{\"1\":{\"1386\":1}}],[\"也是不能被接受的\",{\"1\":{\"596\":1}}],[\"也是不确定的\",{\"1\":{\"533\":1}}],[\"也是一样的\",{\"1\":{\"1457\":1}}],[\"也是一起持久化的\",{\"1\":{\"588\":1}}],[\"也是一种查找方法\",{\"1\":{\"332\":1}}],[\"也是破坏了q1的加锁声明\",{\"1\":{\"584\":1}}],[\"也是找到需要更新的所有分表\",{\"1\":{\"561\":1}}],[\"也是往后推移并且循环的\",{\"1\":{\"461\":1}}],[\"也可能效率会变低\",{\"1\":{\"1492\":1}}],[\"也可能返回一个新的结果容器\",{\"1\":{\"1492\":1}}],[\"也可能返回其他类型的单个值\",{\"1\":{\"1488\":1}}],[\"也可能使用到统计数据\",{\"1\":{\"691\":1}}],[\"也可能收到io资源影响耗时较久\",{\"1\":{\"618\":1}}],[\"也可能是被动操作\",{\"1\":{\"594\":1}}],[\"也可能是等待行锁\",{\"1\":{\"525\":1}}],[\"也可能被分配到从库的同一个worker中执行\",{\"1\":{\"550\":1}}],[\"也可能需要使用外部排序\",{\"1\":{\"491\":1}}],[\"也可能在分支结点上\",{\"1\":{\"350\":1}}],[\"也可以用来以来注入\",{\"1\":{\"1525\":1}}],[\"也可以是接口的实现类或者内部类\",{\"1\":{\"1529\":1}}],[\"也可以是一个生成器函数\",{\"1\":{\"1497\":1}}],[\"也可以是字符串索引的最左m个字符\",{\"1\":{\"476\":1}}],[\"也可以调用另一个方法\",{\"1\":{\"1484\":1}}],[\"也可以指定排序的比较器\",{\"1\":{\"1421\":1}}],[\"也可以指定统计范围按字节\",{\"1\":{\"715\":1}}],[\"也可以自动扩容\",{\"1\":{\"1386\":1}}],[\"也可以简单的说\",{\"1\":{\"727\":1}}],[\"也可以将总数维护到redis里\",{\"1\":{\"663\":1}}],[\"也可以使用foreachremaining成块的遍历元素\",{\"1\":{\"1497\":1}}],[\"也可以使用方法引用的方式来实现\",{\"1\":{\"1491\":2}}],[\"也可以使用方法引用来替代\",{\"1\":{\"1481\":1}}],[\"也可以使用\",{\"1\":{\"1356\":1,\"1531\":1}}],[\"也可以使用show\",{\"1\":{\"663\":1}}],[\"也可以使用双指针来降低时间复杂度\",{\"1\":{\"362\":1}}],[\"也可以跳过这个阶段\",{\"1\":{\"619\":1}}],[\"也可以在mysql里面做\",{\"1\":{\"581\":1}}],[\"也可以在客户端断开的时候自动释放\",{\"1\":{\"577\":1}}],[\"也可以选择遍历索引t\",{\"1\":{\"503\":1}}],[\"也可以创建一个普通索引\",{\"1\":{\"478\":1}}],[\"也可以有多叉\",{\"1\":{\"471\":1}}],[\"也可以先从表t2里面取出d=20的记录的值\",{\"1\":{\"458\":1}}],[\"也可以先进行中序遍历\",{\"1\":{\"397\":1}}],[\"也可以直接dp求解\",{\"1\":{\"424\":1}}],[\"也可以采用双边收敛的方式\",{\"1\":{\"368\":1}}],[\"也可以通过构造时传入比较器\",{\"1\":{\"353\":1}}],[\"也可以认为是动态递归\",{\"1\":{\"325\":1}}],[\"也可以从表test2里面取出name=jyc的记录的id值\",{\"1\":{\"651\":1}}],[\"也可以从number\",{\"1\":{\"491\":1}}],[\"也可以从局部切入进行贪心\",{\"1\":{\"293\":1}}],[\"也可以从后往前\",{\"1\":{\"293\":1}}],[\"url\",{\"1\":{\"1524\":1}}],[\"uuid\",{\"1\":{\"1486\":1,\"1489\":1}}],[\"u>\",{\"1\":{\"1485\":1,\"1495\":5}}],[\"u分别是两个接收的参数的类型\",{\"1\":{\"1475\":1}}],[\"ul>\",{\"1\":{\"1471\":2}}],[\"uv\",{\"1\":{\"714\":1}}],[\"uid\",{\"1\":{\"707\":1}}],[\"u\",{\"1\":{\"695\":4,\"1431\":5,\"1475\":12,\"1478\":4,\"1485\":2,\"1494\":2,\"1495\":4,\"1499\":2}}],[\"utf\",{\"1\":{\"1451\":2,\"1452\":2}}],[\"utf8\",{\"1\":{\"505\":2,\"643\":3,\"671\":1}}],[\"utf8mb4是utf8的超集\",{\"1\":{\"505\":1}}],[\"utf8mb4\",{\"1\":{\"503\":1,\"505\":3}}],[\"utility\",{\"1\":{\"1497\":1,\"1498\":1}}],[\"util\",{\"1\":{\"302\":2,\"316\":1,\"329\":1,\"1356\":3,\"1357\":1,\"1375\":1,\"1416\":7,\"1417\":4,\"1474\":2,\"1475\":2,\"1478\":1,\"1487\":2,\"1494\":4,\"1496\":5,\"1497\":13}}],[\"unexpected\",{\"1\":{\"1524\":1}}],[\"unrelated\",{\"1\":{\"1497\":1}}],[\"unpredictable\",{\"1\":{\"1496\":1}}],[\"unpark\",{\"1\":{\"1354\":1,\"1407\":1}}],[\"unmodifiablelist\",{\"1\":{\"1495\":1}}],[\"unmodifiableset\",{\"1\":{\"1494\":5,\"1495\":3}}],[\"unordered意味着收集的操作并不确保保留输入元素的顺序\",{\"1\":{\"1494\":1}}],[\"unordered\",{\"1\":{\"1492\":6,\"1494\":10,\"1495\":3,\"1496\":1,\"1500\":2}}],[\"unaryoperator<t>\",{\"1\":{\"1486\":3}}],[\"unaryoperator\",{\"1\":{\"1478\":1}}],[\"until\",{\"1\":{\"1472\":2,\"1496\":1,\"1497\":3,\"1498\":1}}],[\"unlisted\",{\"1\":{\"1497\":1}}],[\"unlikely\",{\"1\":{\"1497\":1}}],[\"unlike\",{\"1\":{\"1474\":2}}],[\"unless\",{\"1\":{\"1471\":2,\"1472\":2,\"1495\":1,\"1496\":2,\"1497\":1}}],[\"unlocked\",{\"1\":{\"1361\":1}}],[\"unlock\",{\"1\":{\"671\":1,\"1350\":1,\"1379\":2,\"1380\":4,\"1407\":1,\"1430\":1}}],[\"unboundedqueue\",{\"1\":{\"1380\":1}}],[\"uncaughtexceptionhandler\",{\"1\":{\"1387\":1}}],[\"uncheckedioexception\",{\"1\":{\"1410\":1,\"1411\":1}}],[\"unchecked\",{\"1\":{\"1379\":1,\"1427\":1,\"1486\":1,\"1492\":1,\"1494\":1,\"1495\":3,\"1499\":2,\"1500\":1,\"1524\":1}}],[\"uncontended\",{\"1\":{\"1357\":3,\"1431\":3}}],[\"uncommitted\",{\"1\":{\"570\":1,\"669\":1}}],[\"unsatisfieddependencyexception\",{\"1\":{\"1525\":1}}],[\"unsafewrapper\",{\"1\":{\"1356\":1}}],[\"unsafe\",{\"1\":{\"1356\":5,\"1430\":2}}],[\"unsupportedoperationexception\",{\"1\":{\"1498\":2,\"1525\":1}}],[\"unsupportedencodingexception\",{\"1\":{\"1452\":2}}],[\"unsigned\",{\"1\":{\"486\":1,\"489\":1,\"498\":5,\"499\":4,\"500\":2,\"596\":2,\"630\":1,\"631\":3,\"632\":1,\"1447\":1}}],[\"unwatch进行解锁\",{\"1\":{\"718\":1}}],[\"undetermined\",{\"1\":{\"1497\":1}}],[\"undermine\",{\"1\":{\"1497\":1}}],[\"under\",{\"1\":{\"1495\":1,\"1535\":1}}],[\"undefined\",{\"1\":{\"656\":1,\"1497\":1}}],[\"undo日志版本链是指一行数据被多个事务依次修改过后\",{\"1\":{\"679\":1}}],[\"undo日志版本链与read\",{\"0\":{\"679\":1}}],[\"unknownhostexception\",{\"1\":{\"720\":1}}],[\"unknown\",{\"1\":{\"656\":1,\"717\":1,\"806\":1,\"1497\":1,\"1500\":1}}],[\"unique\",{\"1\":{\"599\":1,\"626\":1,\"635\":1,\"690\":1}}],[\"uniquepaths\",{\"1\":{\"425\":1}}],[\"unix\",{\"1\":{\"594\":1}}],[\"unit\",{\"1\":{\"467\":1,\"713\":2,\"1353\":2,\"1378\":4}}],[\"unioned\",{\"1\":{\"1497\":1}}],[\"union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表\",{\"1\":{\"694\":1}}],[\"union还需要用到唯一索引约束\",{\"1\":{\"555\":1}}],[\"union的执行就会使用临时表来完成\",{\"1\":{\"551\":1}}],[\"union\",{\"1\":{\"467\":2,\"551\":1}}],[\"unionset\",{\"1\":{\"356\":1}}],[\"usable\",{\"1\":{\"656\":3,\"657\":2}}],[\"usages\",{\"1\":{\"1497\":1}}],[\"usage\",{\"1\":{\"566\":1,\"1497\":1}}],[\"usr\",{\"1\":{\"566\":1}}],[\"using\",{\"1\":{\"458\":1,\"467\":13,\"491\":1,\"493\":1,\"498\":2,\"505\":3,\"521\":2,\"527\":2,\"551\":1,\"553\":3,\"557\":1,\"566\":1,\"647\":1,\"651\":1,\"655\":1,\"656\":1,\"1427\":1,\"1431\":1,\"1492\":5,\"1493\":1,\"1495\":3,\"1496\":1,\"1497\":8,\"1524\":1}}],[\"useful\",{\"1\":{\"1493\":1,\"1497\":4}}],[\"usebiasedlocking\",{\"1\":{\"1362\":1}}],[\"usecompressedoops\",{\"1\":{\"1361\":1}}],[\"usec选项\",{\"1\":{\"725\":1}}],[\"used\",{\"1\":{\"690\":2,\"692\":4,\"1357\":2,\"1471\":2,\"1491\":1,\"1492\":4,\"1496\":1,\"1497\":4,\"1498\":3,\"1500\":3,\"1524\":1,\"1525\":1}}],[\"uses\",{\"1\":{\"656\":2,\"1497\":1}}],[\"userinterface\",{\"1\":{\"1531\":4}}],[\"userinterface接口的代理对象\",{\"1\":{\"1531\":1}}],[\"username\",{\"1\":{\"1475\":2}}],[\"user1\",{\"1\":{\"719\":2}}],[\"userservice2\",{\"1\":{\"1531\":2}}],[\"userservice\",{\"1\":{\"1512\":1,\"1515\":1,\"1521\":5,\"1522\":2,\"1523\":1,\"1531\":14}}],[\"users\",{\"1\":{\"609\":1,\"616\":1,\"1498\":1}}],[\"user=$user\",{\"1\":{\"604\":1,\"605\":1}}],[\"user2\",{\"1\":{\"719\":2}}],[\"user2这个路径得到\",{\"1\":{\"471\":1}}],[\"user2和user4根据身份证号算出来的值都是n\",{\"1\":{\"469\":1}}],[\"userf\",{\"1\":{\"471\":1}}],[\"userc\",{\"1\":{\"471\":1}}],[\"user\",{\"1\":{\"455\":1,\"459\":1,\"493\":2,\"568\":1,\"609\":1,\"616\":1,\"1496\":1,\"1509\":3,\"1510\":2,\"1511\":1,\"1515\":9,\"1516\":7,\"1517\":3}}],[\"use\",{\"1\":{\"2\":1,\"3\":2,\"591\":2,\"619\":1,\"656\":1,\"718\":4,\"1350\":1,\"1485\":2,\"1491\":1,\"1492\":2,\"1496\":1,\"1497\":2,\"1500\":3,\"1524\":2,\"1527\":1}}],[\"u$user\",{\"1\":{\"455\":1,\"591\":1}}],[\"upstream表示上游元素的源\",{\"1\":{\"1499\":1}}],[\"upstream\",{\"1\":{\"1498\":2,\"1499\":5}}],[\"updating\",{\"1\":{\"1485\":2}}],[\"updated\",{\"1\":{\"1357\":1}}],[\"update和delete会更新版本号\",{\"1\":{\"672\":1}}],[\"updates参数设置为on\",{\"1\":{\"621\":1}}],[\"updates=on\",{\"1\":{\"592\":1,\"621\":1}}],[\"update命令没有超时\",{\"1\":{\"615\":1}}],[\"update要把整个表所有记录锁起来\",{\"1\":{\"585\":1}}],[\"update是一致的\",{\"1\":{\"584\":1}}],[\"update加锁的语义和select\",{\"1\":{\"584\":1}}],[\"update语句的执行如下图\",{\"1\":{\"463\":1}}],[\"update\",{\"1\":{\"460\":1,\"505\":5,\"583\":1,\"584\":9,\"585\":1,\"613\":1,\"615\":2,\"616\":1,\"621\":2,\"634\":1,\"672\":1,\"673\":1,\"674\":2,\"678\":2,\"695\":1,\"1356\":4,\"1375\":4}}],[\"upon\",{\"1\":{\"1478\":2,\"1487\":1,\"1497\":2,\"1499\":1,\"1500\":1}}],[\"upload\",{\"1\":{\"1470\":1}}],[\"up\",{\"1\":{\"385\":1,\"568\":1,\"1524\":2}}],[\"3与2\",{\"1\":{\"1861\":1}}],[\"3d494fbf\",{\"1\":{\"1490\":1}}],[\"3b07d329\",{\"1\":{\"1486\":1}}],[\"3b54deef5b7b7b7f7dd8acefa23be48879b4fcff\",{\"1\":{\"746\":1}}],[\"362872a1\",{\"1\":{\"1469\":1}}],[\"3611\",{\"1\":{\"713\":1}}],[\"3跳\",{\"1\":{\"1351\":1}}],[\"3以及之前的版本的话\",{\"1\":{\"690\":1}}],[\"3以及之前的版本中\",{\"1\":{\"690\":1}}],[\"3✖️1\",{\"1\":{\"686\":1}}],[\"35\",{\"1\":{\"681\":1,\"684\":2,\"686\":7,\"690\":2,\"691\":4,\"692\":15}}],[\"351\",{\"1\":{\"665\":4}}],[\"31\",{\"1\":{\"666\":2,\"713\":1}}],[\"315\",{\"1\":{\"665\":3}}],[\"386\",{\"1\":{\"692\":1}}],[\"38\",{\"1\":{\"665\":3}}],[\"388\",{\"1\":{\"665\":2}}],[\"372\",{\"1\":{\"665\":2}}],[\"39✖️1\",{\"1\":{\"686\":1}}],[\"39✖️0\",{\"1\":{\"686\":2}}],[\"39\",{\"1\":{\"508\":2,\"686\":3,\"690\":1,\"719\":1}}],[\"323\",{\"1\":{\"1496\":2}}],[\"32位jvm下的对象结构描述\",{\"1\":{\"1361\":1}}],[\"32位4字节\",{\"1\":{\"1361\":1}}],[\"325\",{\"1\":{\"692\":1}}],[\"321\",{\"1\":{\"692\":2}}],[\"32\",{\"1\":{\"475\":2,\"503\":1,\"504\":1,\"505\":3,\"665\":2}}],[\"3和5\",{\"1\":{\"474\":1}}],[\"308\",{\"1\":{\"665\":3}}],[\"30\",{\"1\":{\"508\":2,\"708\":5,\"713\":3,\"1475\":1,\"1490\":1}}],[\"3000\",{\"1\":{\"1450\":3,\"1451\":2,\"1452\":2}}],[\"30000\",{\"1\":{\"761\":1}}],[\"300\",{\"1\":{\"472\":1,\"473\":1,\"724\":1}}],[\"30张图带你彻底理解红黑树\",{\"1\":{\"342\":1}}],[\"34930488\",{\"1\":{\"467\":1}}],[\"344\",{\"0\":{\"383\":1}}],[\"3树是3阶的b树\",{\"1\":{\"349\":1}}],[\"3树是这样一颗多路查找树\",{\"1\":{\"347\":1}}],[\"3树和2\",{\"1\":{\"349\":1}}],[\"3树的概念扩展\",{\"1\":{\"348\":1}}],[\"3树种所有的叶子都在同一层次上\",{\"1\":{\"347\":1}}],[\"3树\",{\"0\":{\"347\":1}}],[\"3\",{\"0\":{\"348\":1},\"1\":{\"301\":1,\"302\":2,\"307\":2,\"329\":4,\"348\":1,\"349\":2,\"356\":1,\"366\":1,\"385\":1,\"399\":1,\"400\":1,\"424\":2,\"428\":1,\"441\":2,\"472\":1,\"473\":2,\"475\":1,\"493\":1,\"498\":11,\"499\":1,\"505\":5,\"514\":11,\"515\":1,\"530\":2,\"556\":1,\"557\":2,\"558\":1,\"565\":1,\"566\":1,\"567\":2,\"568\":3,\"571\":1,\"591\":2,\"596\":1,\"599\":3,\"613\":1,\"628\":1,\"629\":3,\"643\":3,\"657\":1,\"665\":4,\"666\":2,\"671\":1,\"673\":2,\"674\":1,\"686\":1,\"690\":1,\"692\":1,\"693\":1,\"704\":1,\"707\":2,\"708\":14,\"709\":6,\"710\":5,\"711\":26,\"713\":2,\"715\":2,\"716\":2,\"717\":1,\"735\":3,\"761\":1,\"1356\":5,\"1361\":1,\"1367\":1,\"1378\":2,\"1394\":5,\"1412\":1,\"1427\":1,\"1428\":5,\"1431\":1,\"1471\":3,\"1475\":5,\"1476\":4,\"1482\":1,\"1484\":4,\"1486\":2,\"1487\":1,\"1494\":8,\"1497\":1,\"1524\":1,\"1528\":1,\"1541\":1}}],[\"为特定的web应用处理所有的客户请求\",{\"1\":{\"1561\":1}}],[\"为beandefinition设置属性的初始值\",{\"1\":{\"1524\":1}}],[\"为用户所设计的大多数的静态的流的方法大多都在stream类中提的方法\",{\"1\":{\"1498\":1}}],[\"为我们方便的传递各种不同需求的行为提供了可能\",{\"1\":{\"1471\":1}}],[\"为空\",{\"1\":{\"1431\":1}}],[\"为第二步\",{\"1\":{\"1425\":1}}],[\"为第一步\",{\"1\":{\"1425\":1}}],[\"为每个class维护一个偏向锁撤销计数器\",{\"1\":{\"1362\":1}}],[\"为\",{\"1\":{\"1356\":1}}],[\"为控制一个具有有限数量用户资源而设计\",{\"1\":{\"1354\":1}}],[\"为协调共同对一个共享资源的单独访问而设计的\",{\"1\":{\"1354\":1}}],[\"为上层的数据层提供最基础的支撑\",{\"1\":{\"806\":1}}],[\"为指定key的offset位设置值\",{\"1\":{\"715\":1}}],[\"为哈希表\",{\"1\":{\"710\":2}}],[\"为数值加上浮点型数值\",{\"1\":{\"707\":1}}],[\"为生成统计数据而采样的页面数量\",{\"1\":{\"695\":1}}],[\"为null时代表降序存放\",{\"1\":{\"690\":1}}],[\"为m+2否则为d+2\",{\"1\":{\"665\":1}}],[\"为scan\",{\"1\":{\"656\":1}}],[\"为依据的\",{\"1\":{\"548\":1}}],[\"为例\",{\"1\":{\"477\":1,\"1471\":1}}],[\"为了使服务器不受web项目的影响\",{\"1\":{\"1571\":1}}],[\"为了节省重复创建bean的开销\",{\"1\":{\"1536\":1}}],[\"为了与spring划分边界\",{\"1\":{\"1536\":1}}],[\"为了保留stream\",{\"1\":{\"1497\":1}}],[\"为了保证是在源阶段\",{\"1\":{\"1499\":1}}],[\"为了保证最终结果的正确性\",{\"1\":{\"1496\":1}}],[\"为了保证线程安全\",{\"1\":{\"1375\":1}}],[\"为了保证效率\",{\"1\":{\"701\":1}}],[\"为了保证比较高的隔离性\",{\"1\":{\"677\":1}}],[\"为了保证交易的原子性\",{\"1\":{\"580\":1}}],[\"为了保证数据库隔离级别的一致\",{\"1\":{\"570\":1}}],[\"为了进行计算\",{\"1\":{\"1496\":1}}],[\"为了方便子容器的切换\",{\"1\":{\"1536\":1}}],[\"为了方便观察并行流和串行流的区别\",{\"1\":{\"1494\":1}}],[\"为了方便理解这条语句的索引选择过程\",{\"1\":{\"484\":1}}],[\"为了验证关于characteristics方法的调用逻辑\",{\"1\":{\"1494\":1}}],[\"为了确保串行与并行生成等价的结果\",{\"1\":{\"1492\":1}}],[\"为了升级jdk还需要入侵式的修改客户端的代码\",{\"1\":{\"1484\":1}}],[\"为了实现函数式编程\",{\"1\":{\"1470\":1}}],[\"为了实现这个功能\",{\"1\":{\"619\":1}}],[\"为了向函数式编程迈进\",{\"1\":{\"1470\":1}}],[\"为了改进这种模型我们可以通过消息队列和线程池技术对它加以优化\",{\"1\":{\"1450\":1}}],[\"为了防止生产者速度过快\",{\"1\":{\"1396\":1}}],[\"为了防止无穷无尽的分析各种连接顺序的成本\",{\"1\":{\"693\":1}}],[\"为了解决传统线程池的缺陷\",{\"1\":{\"1387\":1}}],[\"为了解决这个缺点\",{\"1\":{\"1410\":1}}],[\"为了解决这个问题\",{\"1\":{\"461\":1}}],[\"为了解决这些问题\",{\"1\":{\"570\":1}}],[\"为了减少初始化时间\",{\"1\":{\"1362\":1}}],[\"为了查看sql多次执行的真实时间\",{\"1\":{\"663\":1}}],[\"为了加速数据恢复\",{\"1\":{\"622\":1}}],[\"为了找到解决误删数据的更高效的方法\",{\"1\":{\"620\":1}}],[\"为了能够检测innodb并发线程数过多导致的系统不可用的情况\",{\"1\":{\"614\":1}}],[\"为了能够用上索引的快速定位能力\",{\"1\":{\"503\":1}}],[\"为了便于说明\",{\"1\":{\"626\":1}}],[\"为了便于描述\",{\"1\":{\"591\":1}}],[\"为了便于量化分析\",{\"1\":{\"537\":1,\"551\":1}}],[\"为了便于量化分析和复现\",{\"1\":{\"505\":1}}],[\"为了控制redo\",{\"1\":{\"588\":1}}],[\"为了更好的说明行锁\",{\"1\":{\"580\":1}}],[\"为了得到严格随机的结果\",{\"1\":{\"559\":1}}],[\"为了最快地拿到当前堆的最大值\",{\"1\":{\"558\":1}}],[\"为了复现这个过程\",{\"1\":{\"558\":1}}],[\"为了后面描述方便\",{\"1\":{\"557\":1}}],[\"为了让主备之间的更新不产生冲突\",{\"1\":{\"615\":1}}],[\"为了让一次fsync带的组员更多\",{\"1\":{\"588\":1}}],[\"为了让一个查询尽量少地读磁盘\",{\"1\":{\"471\":1}}],[\"为了让join使用bka算法\",{\"1\":{\"544\":1}}],[\"为了说明statement和row格式的区别\",{\"1\":{\"591\":1}}],[\"为了说明这个问题\",{\"1\":{\"584\":1,\"613\":1}}],[\"为了说明这一点\",{\"1\":{\"541\":1,\"550\":1,\"1487\":1}}],[\"为了说明幻读\",{\"1\":{\"583\":1}}],[\"为了说明分区表的组织形式\",{\"1\":{\"561\":1}}],[\"为了说明优化器选择的结果是否正确\",{\"1\":{\"483\":1}}],[\"为了说明普通索引和唯一索引对更新语句性能的影响\",{\"1\":{\"480\":1}}],[\"为了直观地说明这个概念\",{\"1\":{\"476\":1}}],[\"为了了解它的实现原理\",{\"1\":{\"460\":1}}],[\"为了避免装箱拆箱操作带来的性能消耗\",{\"1\":{\"1497\":1}}],[\"为了避免用户进程直接操作内核\",{\"1\":{\"1456\":1}}],[\"为了避免垃圾回收\",{\"1\":{\"1396\":1}}],[\"为了避免线程进入等待队列永久阻塞\",{\"1\":{\"1360\":1}}],[\"为了避免临界区的竞态条件发生\",{\"1\":{\"1359\":1}}],[\"为了避免两个事务申请到相同的自增id\",{\"1\":{\"628\":1}}],[\"为了避免数据在转换过程中由于截断导致数据错误\",{\"1\":{\"505\":1}}],[\"为了避免全表扫描\",{\"1\":{\"491\":1}}],[\"为了避免这样重复的遍历\",{\"1\":{\"435\":1}}],[\"为了避免\",{\"1\":{\"360\":1}}],[\"为黑色结点时\",{\"1\":{\"345\":1}}],[\"为该结点对应的字符串\",{\"1\":{\"301\":1}}],[\"为什么会只打印hello呢\",{\"1\":{\"1489\":1}}],[\"为什么会这样呢\",{\"1\":{\"591\":1}}],[\"为什么可以这样创建呢\",{\"1\":{\"1484\":1}}],[\"为什么是函数式接口\",{\"0\":{\"1472\":1}}],[\"为什么队列是满的才唤醒阻塞在notfull上的线程呢\",{\"1\":{\"1380\":1}}],[\"为什么说objectfactory提供的是延迟依赖查找\",{\"0\":{\"1342\":1}}],[\"为什么说elaticsearch是一个近实时的搜索引擎\",{\"1\":{\"449\":1}}],[\"为什么使用集群\",{\"0\":{\"745\":1}}],[\"为什么mysql不直接更新磁盘上的数据而是设计了这么复杂的一套机制来执行sql\",{\"1\":{\"680\":1}}],[\"为什么非主键索引结构的叶子结点存储的是主键值\",{\"1\":{\"642\":1}}],[\"为什么建议innodb表必须建主键\",{\"1\":{\"642\":1}}],[\"为什么这个参数要取名叫做\",{\"1\":{\"619\":1}}],[\"为什么这次能用上被驱动表的tradeied索引呢\",{\"1\":{\"505\":1}}],[\"为什么在执行kill\",{\"1\":{\"618\":1}}],[\"为什么执行group\",{\"1\":{\"554\":1}}],[\"为什么\",{\"1\":{\"498\":1}}],[\"为什么还要用redis\",{\"0\":{\"208\":1}}],[\"为什么springboot的\",{\"0\":{\"192\":1}}],[\"为什么要设计双亲委托机制\",{\"1\":{\"1540\":1,\"1570\":1}}],[\"为什么要用pipeline\",{\"0\":{\"151\":1}}],[\"为什么要将永久代改为元空间\",{\"0\":{\"131\":1}}],[\"为什么wait和notify方法要在同步块中调用\",{\"0\":{\"58\":1}}],[\"为什么阈值是8\",{\"0\":{\"39\":1}}],[\"为什么不直接使用红黑树\",{\"0\":{\"37\":1}}],[\"为什么hashmap不用linkedlist\",{\"0\":{\"35\":1}}],[\"从linux内核角度探秘jdk\",{\"1\":{\"1843\":1}}],[\"从一个分割迭代器对象创建一个串行或者并行的流\",{\"1\":{\"1498\":1}}],[\"从jdk1\",{\"1\":{\"1496\":1}}],[\"从泛型的角度就可以清楚的认识到\",{\"1\":{\"1492\":1}}],[\"从表现形式上而言\",{\"1\":{\"1488\":1}}],[\"从表t1里一次性地多拿些出来\",{\"1\":{\"542\":1}}],[\"从表t1中读入一行数据r\",{\"1\":{\"538\":1}}],[\"从supplier\",{\"1\":{\"1492\":1}}],[\"从student这张表中查询出年龄>20并且地址=北京的记录\",{\"1\":{\"1488\":1}}],[\"从show\",{\"1\":{\"618\":1}}],[\"从本节开始\",{\"1\":{\"1497\":1}}],[\"从本质上来说\",{\"1\":{\"1487\":1}}],[\"从本地读取binlog\",{\"1\":{\"590\":1}}],[\"从写模式切换到读模式\",{\"1\":{\"1451\":1}}],[\"从缓冲区写入到通道中\",{\"1\":{\"1451\":1}}],[\"从kernel的角度\",{\"1\":{\"1443\":1}}],[\"从用户进程角度讲\",{\"1\":{\"1441\":1}}],[\"从结构实现来讲\",{\"1\":{\"1423\":1}}],[\"从结果中可以看出\",{\"1\":{\"695\":1}}],[\"从某种程度上说\",{\"1\":{\"1395\":1}}],[\"从tail添加元素\",{\"1\":{\"1380\":1}}],[\"从同步队列转移到条件队列\",{\"1\":{\"1369\":1}}],[\"从偏向锁的加锁和解锁过程中可以看出\",{\"1\":{\"1362\":1}}],[\"从操作系统的视角来看\",{\"1\":{\"1354\":1}}],[\"从机手动执行命令slaveof\",{\"1\":{\"748\":1}}],[\"从机6380写入失败\",{\"1\":{\"748\":1}}],[\"从机6381写入失败\",{\"1\":{\"748\":1}}],[\"从机只能读\",{\"1\":{\"748\":1}}],[\"从机数量\",{\"1\":{\"746\":1}}],[\"从节点可以在以顶程度上帮助主节点分担读压力\",{\"1\":{\"758\":1}}],[\"从节点可以扩展主节点的读能力\",{\"1\":{\"758\":2}}],[\"从节点可以作为后备\",{\"1\":{\"758\":1}}],[\"从节点可以暂时替代主节点提供服务\",{\"1\":{\"744\":1}}],[\"从节点进行读操作\",{\"1\":{\"744\":1}}],[\"从节点以读为主\",{\"1\":{\"743\":1}}],[\"从节点a更新的事务\",{\"1\":{\"592\":1}}],[\"从不同步\",{\"1\":{\"730\":1}}],[\"从\",{\"1\":{\"729\":1,\"1847\":1}}],[\"从大到小\",{\"1\":{\"711\":1}}],[\"从newset中移除m3元素\",{\"1\":{\"709\":1}}],[\"从newlist中弹出第一个值\",{\"1\":{\"708\":1}}],[\"从mylist中弹出\",{\"1\":{\"708\":1}}],[\"从mysql的真正开始流行到现在\",{\"1\":{\"634\":1}}],[\"从mysql8\",{\"1\":{\"562\":1}}],[\"从mysql5\",{\"1\":{\"562\":2}}],[\"从尾部开始搜索\",{\"1\":{\"708\":2}}],[\"从最左边\",{\"1\":{\"708\":1}}],[\"从最好到最差依次是\",{\"1\":{\"467\":1}}],[\"从左边\",{\"1\":{\"708\":1}}],[\"从左到右\",{\"1\":{\"364\":1}}],[\"从内存中读取一个块对应的成本\",{\"1\":{\"694\":1}}],[\"从内存临时表中一行一行地取出r值和位置信息\",{\"1\":{\"557\":1}}],[\"从磁盘读取文件内容\",{\"1\":{\"1457\":1}}],[\"从磁盘上读取一个块对应的成本\",{\"1\":{\"694\":1}}],[\"从磁盘到内存这个加载的过程损耗的时间称之为io成本\",{\"1\":{\"682\":1}}],[\"从全表扫描和idx\",{\"1\":{\"692\":1}}],[\"从全表扫描和使用idx\",{\"1\":{\"692\":1}}],[\"从全表扫描到索引扫描\",{\"1\":{\"527\":1}}],[\"从1开始计数\",{\"1\":{\"690\":1}}],[\"从上图可以得出如下结论\",{\"1\":{\"1460\":1,\"1461\":1}}],[\"从上图\",{\"1\":{\"1457\":1}}],[\"从上面的io拷贝机制中可以看出\",{\"1\":{\"1462\":1}}],[\"从上面的表格可以看出\",{\"1\":{\"694\":1}}],[\"从上面的计算过程也可以看出来\",{\"1\":{\"692\":1}}],[\"从上一步分析我们可以得出\",{\"1\":{\"686\":1}}],[\"从上到下\",{\"1\":{\"364\":1}}],[\"从系统启动到现在等待最长的一次所花时间\",{\"1\":{\"675\":1}}],[\"从系统启动到现在锁定总时间长度\",{\"1\":{\"675\":1}}],[\"从对数据库操作的类型分\",{\"1\":{\"670\":1}}],[\"从对数据操作的粒度分\",{\"1\":{\"670\":1}}],[\"从理论上将\",{\"1\":{\"633\":1}}],[\"从并发插入数据性能的角度考虑\",{\"1\":{\"629\":1}}],[\"从auto\",{\"1\":{\"628\":1}}],[\"从a的角度来看\",{\"1\":{\"570\":1}}],[\"从备份系统下载master\",{\"1\":{\"622\":1}}],[\"从备份的时候点开始\",{\"1\":{\"464\":1}}],[\"从日志备份里面\",{\"1\":{\"622\":1}}],[\"从性能上分为乐观锁\",{\"1\":{\"670\":1}}],[\"从性能的角度考虑\",{\"1\":{\"621\":1}}],[\"从性质5又可以推出\",{\"1\":{\"343\":1}}],[\"从返回包获取这个事务的gtid\",{\"1\":{\"611\":1}}],[\"从返回包直接获取这个事务的gtid\",{\"1\":{\"611\":1}}],[\"从库收到binlog以后\",{\"1\":{\"609\":1}}],[\"从库会认为已经没有同步延迟\",{\"1\":{\"609\":1}}],[\"从库b的同步线程就会出现duplicate\",{\"1\":{\"604\":1}}],[\"从库b要切换的时候\",{\"1\":{\"604\":1}}],[\"从库b\",{\"1\":{\"603\":2}}],[\"从binlog在主备之间状态的分析中\",{\"1\":{\"609\":1}}],[\"从自己的binlog文件里面\",{\"1\":{\"605\":1}}],[\"从单线程复制到最新版本的多线程复制\",{\"1\":{\"597\":1}}],[\"从状态1到状态2切换的详细过程如下\",{\"1\":{\"595\":1}}],[\"从顾客a账余额中扣除电影票价\",{\"1\":{\"580\":1}}],[\"从引擎层来看\",{\"1\":{\"561\":1}}],[\"从堆中去掉\",{\"1\":{\"558\":1}}],[\"从words表中\",{\"1\":{\"557\":1}}],[\"从extra字段可以看到\",{\"1\":{\"555\":1}}],[\"从explain的结果来看\",{\"1\":{\"541\":1}}],[\"从explain的结果可以看到\",{\"1\":{\"527\":1}}],[\"从临时表按行取数据\",{\"1\":{\"551\":1}}],[\"从其它特征上看\",{\"1\":{\"546\":1}}],[\"从驱动表t1\",{\"1\":{\"542\":1}}],[\"从时间复杂度上来看\",{\"1\":{\"540\":1}}],[\"从每一行r取出字段a的值$r\",{\"1\":{\"538\":1}}],[\"从数据行r中\",{\"1\":{\"538\":1}}],[\"从数据表中返回数据\",{\"1\":{\"527\":1}}],[\"从这一个层面来说\",{\"1\":{\"1484\":1}}],[\"从这个版本开始\",{\"1\":{\"1468\":1}}],[\"从这个角度来看\",{\"1\":{\"632\":1}}],[\"从这个备份恢复到临时库\",{\"1\":{\"464\":1}}],[\"从这点看\",{\"1\":{\"531\":1}}],[\"从好到坏依次为\",{\"1\":{\"527\":1}}],[\"从客户端\",{\"1\":{\"518\":1}}],[\"从索引name取出下一个满足name=\",{\"1\":{\"657\":1}}],[\"从索引name找到下一个满足name=\",{\"1\":{\"657\":1}}],[\"从索引name找到第一个满足name=\",{\"1\":{\"657\":2}}],[\"从索引\",{\"1\":{\"493\":4}}],[\"从索引city取下一个记录的主键id\",{\"1\":{\"491\":1,\"492\":1}}],[\"从索引city找到第一个满足city=\",{\"1\":{\"491\":1,\"492\":1}}],[\"从索引的示意图中可以看出\",{\"1\":{\"491\":1}}],[\"从查询效率上看\",{\"1\":{\"489\":1}}],[\"从查询条件来看\",{\"1\":{\"484\":1}}],[\"从占用的额外空间来看\",{\"1\":{\"489\":1}}],[\"从index1查到结果后直接就返回了\",{\"1\":{\"488\":1}}],[\"从index1索引树找到满足索引值是\",{\"1\":{\"487\":1}}],[\"从index2索引树找到满足索引值是\",{\"1\":{\"487\":1}}],[\"从分析的结果来看\",{\"1\":{\"483\":1}}],[\"从union表获取结果的select\",{\"1\":{\"467\":1}}],[\"从而允许进行适当的资源清理\",{\"1\":{\"1534\":1}}],[\"从而可以进行排序\",{\"1\":{\"1518\":1}}],[\"从而实现收集器的映射\",{\"1\":{\"1495\":1}}],[\"从而实现真正的高可用\",{\"1\":{\"758\":1}}],[\"从而使开发人员不再需要定义样板化的配置\",{\"1\":{\"1861\":1}}],[\"从而使java具有动态语言的特性\",{\"1\":{\"1435\":1}}],[\"从而使父子进程拥有各自的地址空间\",{\"1\":{\"1404\":1}}],[\"从而提高了b的执行效率\",{\"1\":{\"1408\":1}}],[\"从而提升排序效率\",{\"1\":{\"657\":1}}],[\"从而去选择合适的blockingqueue\",{\"1\":{\"1386\":1}}],[\"从而启动后继任务的开始\",{\"1\":{\"1354\":1}}],[\"从而影响性能\",{\"1\":{\"642\":1}}],[\"从而保证整个集群的正常工作\",{\"1\":{\"625\":1}}],[\"从而删掉过期的历史数据\",{\"1\":{\"563\":1}}],[\"从而导致了索引失效\",{\"1\":{\"504\":1}}],[\"从而导致执行速度变得很慢\",{\"1\":{\"483\":1}}],[\"从而知道mysql是如何处理sql语句的\",{\"1\":{\"466\":1}}],[\"从而希望导致结果是全局最好或最优的算法\",{\"1\":{\"293\":1}}],[\"从头部开始搜索\",{\"1\":{\"708\":2}}],[\"从头开始写入\",{\"1\":{\"461\":1}}],[\"从头结点和相遇结点\",{\"1\":{\"377\":1}}],[\"从现象看就是mysql异常重启了\",{\"1\":{\"455\":1}}],[\"从图中的结果可以看到\",{\"1\":{\"591\":1}}],[\"从图中可以看到\",{\"1\":{\"482\":1,\"487\":1,\"588\":1}}],[\"从图中不难看出\",{\"1\":{\"454\":1,\"472\":1}}],[\"从图1可以看到\",{\"1\":{\"343\":1}}],[\"从第1位开始存储nums\",{\"1\":{\"431\":1}}],[\"从栈中弹出节点并保存\",{\"1\":{\"395\":1}}],[\"从下一章节开始\",{\"1\":{\"1490\":1}}],[\"从下一个元素开始朝朝\",{\"1\":{\"318\":1}}],[\"从下到上\",{\"1\":{\"364\":1}}],[\"从右到左\",{\"1\":{\"364\":1}}],[\"从根结点继续遍历\",{\"1\":{\"415\":1}}],[\"从根结点开始查找\",{\"1\":{\"345\":1}}],[\"从根结点到某一结点\",{\"1\":{\"301\":1}}],[\"从根节点开始查找\",{\"1\":{\"344\":1}}],[\"从已经排序的序列最右边的开始比较\",{\"1\":{\"319\":1}}],[\"从到尾依次扫描未排序序列\",{\"1\":{\"319\":1}}],[\"从开始第一对到最后\",{\"1\":{\"317\":1}}],[\"2道题目\",{\"1\":{\"1850\":1}}],[\"2次dma\",{\"1\":{\"1462\":1}}],[\"2次dma拷贝\",{\"1\":{\"1457\":1,\"1458\":1}}],[\"2次cpu拷贝\",{\"1\":{\"1457\":1}}],[\"2次cpu切换\",{\"1\":{\"1457\":1}}],[\"2以后冲突都在table\",{\"1\":{\"1427\":1}}],[\"2^31\",{\"1\":{\"1427\":1}}],[\"2^30\",{\"1\":{\"1427\":1}}],[\"2^64\",{\"1\":{\"714\":1}}],[\"2条记录\",{\"1\":{\"711\":1}}],[\"2种连接顺序\",{\"1\":{\"693\":1}}],[\"2是检测一条记录是否符合给定的搜索条件的成本常数\",{\"1\":{\"686\":1}}],[\"2是读取一条记录成本常数\",{\"1\":{\"686\":1}}],[\"2=7\",{\"1\":{\"686\":1}}],[\"2=4这些值\",{\"1\":{\"591\":1}}],[\"2指的是访问一条记录所需的cpu成本常数\",{\"1\":{\"685\":1}}],[\"2这些数字称之为成本常数\",{\"1\":{\"682\":1}}],[\"21中这个系统变量的默认值\",{\"1\":{\"690\":1}}],[\"21\",{\"1\":{\"686\":2,\"688\":2,\"692\":2,\"707\":1,\"710\":1,\"1496\":1}}],[\"2169\",{\"1\":{\"681\":1,\"685\":1,\"688\":1}}],[\"215字节\",{\"1\":{\"667\":2}}],[\"2155\",{\"1\":{\"666\":1}}],[\"215\",{\"1\":{\"665\":1}}],[\"28\",{\"1\":{\"681\":2,\"684\":4,\"686\":14,\"690\":4,\"691\":8,\"692\":10}}],[\"29\",{\"1\":{\"713\":1}}],[\"295字节\",{\"1\":{\"667\":2}}],[\"295\",{\"1\":{\"665\":1}}],[\"294\",{\"1\":{\"665\":1,\"667\":2}}],[\"26379\",{\"1\":{\"761\":1}}],[\"262136\",{\"1\":{\"657\":1}}],[\"262056\",{\"1\":{\"657\":1}}],[\"264这个值太大了\",{\"1\":{\"633\":1}}],[\"23设计模式和它的归类\",{\"0\":{\"1014\":1}}],[\"232\",{\"1\":{\"708\":1,\"709\":1}}],[\"233\",{\"1\":{\"665\":1}}],[\"23\",{\"1\":{\"647\":2,\"655\":2,\"666\":1,\"686\":2,\"1482\":1,\"1496\":1}}],[\"23秒\",{\"1\":{\"485\":1}}],[\"2个用完以后\",{\"1\":{\"629\":1}}],[\"2语句\",{\"1\":{\"599\":1}}],[\"2中把db1\",{\"1\":{\"598\":1}}],[\"2中有一个事务会更新到表t3的数据\",{\"1\":{\"598\":1}}],[\"2里面涉及到修改表t3的事务先执行完成\",{\"1\":{\"598\":1}}],[\"2也冲突\",{\"1\":{\"598\":1}}],[\"2表示\",{\"1\":{\"598\":1}}],[\"2log2m\",{\"1\":{\"538\":1}}],[\"2n\",{\"1\":{\"429\":1}}],[\"225\",{\"1\":{\"665\":3}}],[\"22\",{\"1\":{\"643\":3,\"647\":1,\"655\":2,\"681\":2,\"684\":4,\"686\":14,\"690\":4,\"691\":8,\"692\":20,\"1496\":1}}],[\"223\",{\"1\":{\"631\":1,\"665\":1}}],[\"22版本引入了一个新策略\",{\"1\":{\"629\":1}}],[\"22的版本里\",{\"1\":{\"602\":1}}],[\"222\",{\"0\":{\"407\":1}}],[\"226\",{\"0\":{\"405\":1}}],[\"2400\",{\"1\":{\"672\":1}}],[\"24\",{\"0\":{\"374\":1},\"1\":{\"647\":1,\"655\":1,\"690\":1,\"693\":1}}],[\"27\",{\"0\":{\"361\":1},\"1\":{\"643\":3}}],[\"255字节\",{\"1\":{\"667\":3}}],[\"255\",{\"1\":{\"467\":1,\"498\":2,\"643\":1,\"665\":1,\"667\":1,\"672\":1}}],[\"257\",{\"0\":{\"409\":1}}],[\"25\",{\"1\":{\"329\":2,\"583\":3,\"585\":2,\"707\":1,\"1475\":1}}],[\"2\",{\"0\":{\"347\":1,\"348\":1},\"1\":{\"301\":1,\"302\":2,\"305\":1,\"307\":1,\"315\":5,\"325\":1,\"329\":3,\"347\":1,\"348\":1,\"349\":3,\"356\":1,\"359\":1,\"360\":2,\"366\":1,\"368\":1,\"384\":1,\"385\":1,\"386\":1,\"399\":1,\"400\":1,\"409\":1,\"415\":2,\"424\":9,\"427\":2,\"428\":2,\"429\":7,\"431\":3,\"435\":2,\"438\":7,\"439\":1,\"440\":1,\"443\":1,\"472\":1,\"473\":1,\"498\":8,\"499\":1,\"500\":1,\"505\":6,\"508\":1,\"515\":1,\"527\":1,\"551\":1,\"559\":1,\"561\":1,\"565\":3,\"566\":6,\"567\":2,\"568\":2,\"571\":1,\"591\":2,\"596\":1,\"599\":3,\"618\":1,\"628\":7,\"629\":3,\"636\":1,\"643\":5,\"656\":1,\"657\":1,\"665\":6,\"671\":1,\"674\":1,\"682\":2,\"685\":1,\"686\":7,\"690\":1,\"693\":3,\"694\":4,\"704\":2,\"706\":4,\"707\":4,\"708\":19,\"709\":9,\"710\":6,\"711\":30,\"713\":6,\"715\":2,\"716\":2,\"717\":1,\"718\":1,\"719\":2,\"720\":1,\"735\":3,\"761\":1,\"770\":1,\"1356\":3,\"1357\":2,\"1361\":1,\"1367\":1,\"1378\":2,\"1383\":1,\"1412\":1,\"1428\":1,\"1431\":6,\"1450\":1,\"1453\":1,\"1459\":3,\"1460\":4,\"1461\":3,\"1462\":9,\"1471\":2,\"1472\":3,\"1475\":11,\"1476\":9,\"1482\":1,\"1484\":2,\"1486\":3,\"1487\":25,\"1491\":2,\"1494\":9,\"1495\":1,\"1496\":1,\"1497\":6,\"1524\":1,\"1528\":1,\"1541\":1}}],[\"2071\",{\"1\":{\"685\":2}}],[\"205\",{\"1\":{\"713\":1}}],[\"2052\",{\"1\":{\"656\":2}}],[\"2054\",{\"1\":{\"656\":1}}],[\"20003就表示这个语句执行过程中扫描了20003行\",{\"1\":{\"557\":1}}],[\"20003\",{\"1\":{\"557\":1}}],[\"2000在mysql中会发生强制类型转换\",{\"1\":{\"513\":1}}],[\"2000\",{\"1\":{\"513\":2,\"544\":2,\"545\":1,\"546\":1,\"1410\":1,\"1411\":1}}],[\"2000=0\",{\"1\":{\"496\":1}}],[\"20000249147415\",{\"1\":{\"713\":1}}],[\"20000就不会再选择索引a了\",{\"1\":{\"483\":1}}],[\"20000\",{\"1\":{\"483\":3,\"690\":1}}],[\"200\",{\"1\":{\"472\":1,\"473\":1,\"1411\":1}}],[\"20\",{\"1\":{\"467\":3,\"498\":1,\"568\":3,\"583\":3,\"585\":2,\"647\":1,\"655\":1,\"671\":1,\"673\":3,\"674\":1,\"692\":1,\"706\":2,\"707\":3,\"710\":4,\"718\":5,\"1362\":1,\"1475\":1,\"1477\":1,\"1482\":1,\"1488\":3,\"1490\":2}}],[\"2038\",{\"1\":{\"666\":1}}],[\"203\",{\"0\":{\"371\":1}}],[\"209\",{\"0\":{\"363\":1}}],[\"20252\",{\"1\":{\"690\":1}}],[\"20220327105108038\",{\"1\":{\"616\":2}}],[\"20220325100353640\",{\"1\":{\"609\":2}}],[\"2021\",{\"1\":{\"9\":1,\"681\":2,\"684\":4,\"686\":14,\"690\":4,\"691\":8,\"692\":20}}],[\"2020\",{\"1\":{\"9\":1,\"508\":2,\"1482\":1}}],[\"2017这个分区\",{\"1\":{\"562\":1}}],[\"2017\",{\"1\":{\"503\":2,\"561\":6,\"643\":3}}],[\"2016\",{\"1\":{\"503\":2}}],[\"2018上\",{\"1\":{\"561\":1}}],[\"2018分区的supermum\",{\"1\":{\"561\":1}}],[\"2018和p\",{\"1\":{\"561\":2}}],[\"2018\",{\"1\":{\"503\":4,\"561\":7,\"562\":2,\"591\":7}}],[\"201\",{\"1\":{\"467\":2,\"665\":3}}],[\"2019和p\",{\"1\":{\"562\":1}}],[\"2019这个分区\",{\"1\":{\"562\":1}}],[\"2019这两个分区上\",{\"1\":{\"561\":1}}],[\"2019等等\",{\"1\":{\"561\":1}}],[\"2019是两个不同的表\",{\"1\":{\"561\":1}}],[\"2019\",{\"1\":{\"9\":2,\"561\":2}}],[\"2015\",{\"1\":{\"9\":1}}],[\"注解等信息\",{\"1\":{\"1524\":1}}],[\"注解解析\",{\"0\":{\"1031\":1}}],[\"注入字段\",{\"1\":{\"1525\":1}}],[\"注入\",{\"0\":{\"1343\":1}}],[\"注册过滤信息\",{\"0\":{\"1784\":1}}],[\"注册时间监听器\",{\"1\":{\"1528\":1}}],[\"注册spring\",{\"0\":{\"1275\":1}}],[\"注册阶段\",{\"0\":{\"1157\":1}}],[\"注册中心\",{\"0\":{\"246\":1}}],[\"注意是具体的beanpostprocessor实例对象\",{\"1\":{\"1528\":1}}],[\"注意此时两个线程已经成功添加数据\",{\"1\":{\"1428\":1}}],[\"注意必须为主从设置一样的验证密码\",{\"1\":{\"761\":1}}],[\"注意到有一个replication模块\",{\"1\":{\"746\":1}}],[\"注意使用时一定使用lettuce的连接池\",{\"1\":{\"720\":1}}],[\"注意20也包含在内\",{\"1\":{\"673\":1}}],[\"注意长度设置\",{\"1\":{\"665\":1}}],[\"注意on需要大写\",{\"1\":{\"565\":1}}],[\"注意矩阵的下标从0开始算起\",{\"1\":{\"443\":1}}],[\"注意这里设置了唯一约束\",{\"1\":{\"626\":1}}],[\"注意这里并不是直接写入redo\",{\"1\":{\"463\":1}}],[\"注意这里的次序不能交换\",{\"1\":{\"435\":1}}],[\"注意这里的边界条件\",{\"1\":{\"367\":1}}],[\"注意这里从2开始\",{\"1\":{\"431\":1}}],[\"注意这里不需要判断\",{\"1\":{\"405\":1}}],[\"注意这里不能简写为\",{\"1\":{\"387\":1}}],[\"注意严格意义上讲\",{\"1\":{\"350\":1}}],[\"注意下标为0时只有一个元素\",{\"1\":{\"319\":1}}],[\"注意1s\",{\"1\":{\"314\":1}}],[\"注意\",{\"1\":{\"301\":1,\"318\":1,\"426\":1,\"439\":1,\"467\":1,\"588\":1,\"634\":1,\"682\":1,\"718\":1,\"1362\":1,\"1396\":1,\"1405\":1,\"1428\":2,\"1476\":1,\"1510\":1}}],[\"查表判断\",{\"0\":{\"614\":1}}],[\"查新慢查询日志的总记录条数\",{\"1\":{\"565\":1}}],[\"查出表t1的所有数据\",{\"1\":{\"538\":1}}],[\"查出来的trx\",{\"1\":{\"634\":1}}],[\"查出来有多条记录\",{\"1\":{\"467\":1}}],[\"查出来只有一条记录\",{\"1\":{\"467\":1}}],[\"查看是否有\",{\"1\":{\"1507\":1}}],[\"查看non\",{\"1\":{\"1498\":1}}],[\"查看atomic\",{\"1\":{\"1356\":1}}],[\"查看活跃的频道\",{\"1\":{\"735\":1}}],[\"查看订阅与发布系统状态\",{\"1\":{\"734\":1}}],[\"查看哈希表\",{\"1\":{\"710\":1}}],[\"查看mylist的长度\",{\"1\":{\"708\":1}}],[\"查看列表长度\",{\"1\":{\"708\":1}}],[\"查看key的过期剩余时间\",{\"1\":{\"706\":1}}],[\"查看value的数据类型\",{\"1\":{\"706\":2}}],[\"查看数据库大小\",{\"1\":{\"704\":1}}],[\"查看某个表索引的统计数据可以使用show\",{\"1\":{\"690\":1}}],[\"查看锁等待详细信息\",{\"1\":{\"675\":1}}],[\"查看锁等待\",{\"1\":{\"675\":1}}],[\"查看锁\",{\"1\":{\"675\":1}}],[\"查看事务\",{\"1\":{\"675\":1}}],[\"查看information\",{\"1\":{\"675\":1}}],[\"查看表上加过的锁\",{\"1\":{\"671\":1}}],[\"查看trace字段可知索引扫描的成本低于全表扫描\",{\"1\":{\"656\":1}}],[\"查看trace字段\",{\"1\":{\"656\":1}}],[\"查看商品是否发布成功\",{\"1\":{\"607\":1}}],[\"查看binlog中的内容\",{\"1\":{\"591\":1}}],[\"查看结果\",{\"1\":{\"568\":1}}],[\"查看system源码可以发现out实际上是printstream的一个对象\",{\"1\":{\"1482\":1}}],[\"查看studentx中所有的value\",{\"1\":{\"710\":1}}],[\"查看studentx中所有的field\",{\"1\":{\"710\":1}}],[\"查看studentx中的字段数量\",{\"1\":{\"710\":1}}],[\"查看show\",{\"1\":{\"568\":1}}],[\"查看sql执行计划\",{\"1\":{\"499\":2,\"500\":1}}],[\"查看long\",{\"1\":{\"565\":1}}],[\"查看慢查询日志是否开启\",{\"1\":{\"565\":2}}],[\"查看慢查询日志是否开以及如何开启\",{\"1\":{\"565\":1}}],[\"查看该查询扫描的行数是非常有帮助的\",{\"1\":{\"526\":1}}],[\"查看上述sql的执行计划\",{\"1\":{\"509\":1}}],[\"查看当前指定的所依赖的bean是否都已经注入完成\",{\"1\":{\"1524\":1}}],[\"查看当前库的信息\",{\"1\":{\"746\":1}}],[\"查看当前数据库所有key\",{\"1\":{\"706\":1}}],[\"查看当前数据库中所有的key\",{\"1\":{\"704\":1}}],[\"查看当前数据库的事务隔离级别\",{\"1\":{\"669\":1}}],[\"查看当前的索引\",{\"1\":{\"498\":1}}],[\"查看当前索引\",{\"1\":{\"498\":1}}],[\"查看现在sql语句的执行计划\",{\"1\":{\"498\":1}}],[\"查看\",{\"1\":{\"491\":1,\"558\":1}}],[\"查看所有容器的命令\",{\"0\":{\"266\":1}}],[\"查询redis命令的中文网站\",{\"1\":{\"1853\":1}}],[\"查询消息\",{\"0\":{\"1800\":1}}],[\"查询效率降低的问题\",{\"1\":{\"1352\":1}}],[\"查询效率比哈希表高\",{\"1\":{\"301\":1}}],[\"查询经纬度\",{\"1\":{\"713\":1}}],[\"查询m5是否是myset的成员\",{\"1\":{\"709\":1}}],[\"查询member元素是否是集合的成员\",{\"1\":{\"709\":1}}],[\"查询mysql自己维护的总行数\",{\"1\":{\"663\":1}}],[\"查询mysql页大小\",{\"1\":{\"640\":1}}],[\"查询s1表总共的成本\",{\"1\":{\"692\":1}}],[\"查询s2表大致需要扫描321条记录\",{\"1\":{\"692\":1}}],[\"查询五\",{\"1\":{\"691\":1}}],[\"查询四\",{\"1\":{\"691\":1}}],[\"查询二\",{\"1\":{\"691\":1}}],[\"查询一次s1表大致需要扫描1条记录\",{\"1\":{\"692\":1}}],[\"查询一\",{\"1\":{\"691\":1}}],[\"查询一定不用\",{\"1\":{\"510\":1}}],[\"查询count需要实时计算\",{\"1\":{\"663\":1}}],[\"查询category\",{\"1\":{\"498\":1}}],[\"查询不需要计算\",{\"1\":{\"663\":1}}],[\"查询不需要的记录\",{\"0\":{\"520\":1}}],[\"查询的sql如下\",{\"1\":{\"659\":1}}],[\"查询的生命周期可以按照顺序来看\",{\"1\":{\"518\":1}}],[\"查询可能使用的索引\",{\"1\":{\"656\":1}}],[\"查询成本\",{\"1\":{\"656\":1,\"690\":1}}],[\"查询到\",{\"1\":{\"596\":1}}],[\"查询结果太大\",{\"1\":{\"568\":1}}],[\"查询时间\",{\"1\":{\"566\":1}}],[\"查询性能就会比较慢\",{\"1\":{\"563\":1}}],[\"查询性能低下最基本的原因是访问的数据太多\",{\"1\":{\"518\":1}}],[\"查询表的总行数\",{\"1\":{\"533\":2}}],[\"查询本身效率也可能会有所提升\",{\"1\":{\"531\":1}}],[\"查询解析和优化是一件代价很高的事情\",{\"1\":{\"529\":1}}],[\"查询返回超过需要的数据也不总是坏事\",{\"1\":{\"522\":1}}],[\"查询需要在不同的地方花费时间\",{\"1\":{\"518\":1}}],[\"查询优化等操作\",{\"1\":{\"694\":1}}],[\"查询优化器需要分别考虑这两情况下的最优查询成本\",{\"1\":{\"692\":1}}],[\"查询优化器在计算驱动表扇出时\",{\"1\":{\"691\":1}}],[\"查询优化器又不会真正的去执行查询\",{\"1\":{\"691\":1}}],[\"查询优化器认为读取索引的一个范围区间的io成本和读取一个页面是相同的\",{\"1\":{\"686\":1}}],[\"查询优化器认为这种访问类型可以高效地完成查询\",{\"1\":{\"527\":1}}],[\"查询优化\",{\"0\":{\"663\":1},\"1\":{\"518\":1}}],[\"查询范围的字段使用到了索引\",{\"1\":{\"509\":1}}],[\"查询过程\",{\"0\":{\"479\":1}}],[\"查询条件里面只有b的语句\",{\"1\":{\"476\":1}}],[\"查询涉及到的字段上若存在索引\",{\"1\":{\"467\":1}}],[\"查询中统计或者分组字段\",{\"1\":{\"495\":1}}],[\"查询中排序的字段\",{\"1\":{\"495\":1}}],[\"查询中与其他表关联的字段\",{\"1\":{\"495\":1}}],[\"查询中如果使用了覆盖索引\",{\"1\":{\"467\":1}}],[\"查询中如果包含任何复杂的子部分\",{\"1\":{\"467\":1}}],[\"查询中不包含子查询或者union\",{\"1\":{\"467\":1}}],[\"查询缓存的命中率会非常低\",{\"1\":{\"456\":1}}],[\"查询缓存的失效非常频繁\",{\"1\":{\"456\":1}}],[\"查询缓存\",{\"0\":{\"456\":1},\"1\":{\"454\":1,\"456\":1,\"694\":1}}],[\"查询\",{\"0\":{\"1796\":1},\"1\":{\"310\":1,\"1498\":1}}],[\"查找注入点\",{\"1\":{\"1525\":1}}],[\"查找键值对\",{\"1\":{\"1425\":1}}],[\"查找等算法\",{\"1\":{\"1423\":1}}],[\"查找的复杂度都是o\",{\"1\":{\"709\":1}}],[\"查找\",{\"1\":{\"566\":1}}],[\"查找和判断下一条记录\",{\"1\":{\"479\":1}}],[\"查找到位置后\",{\"1\":{\"482\":1}}],[\"查找到第一个满足条件的记录后\",{\"1\":{\"479\":1}}],[\"查找到第一个符合条件的记录是id3\",{\"1\":{\"476\":1}}],[\"查找到满足条件的第一个记录\",{\"1\":{\"479\":1}}],[\"查找一个值最多只需要访问3次从盘\",{\"1\":{\"471\":1}}],[\"查找成本都很高\",{\"1\":{\"461\":1}}],[\"查找插入的父结点很简单\",{\"1\":{\"345\":1}}],[\"查找失败为止\",{\"1\":{\"304\":1}}],[\"查找没有child\",{\"1\":{\"302\":2}}],[\"查找是否含有\",{\"1\":{\"302\":1}}],[\"最开始要学习的是\",{\"1\":{\"1847\":1}}],[\"最典型的mvc就是jsp+servlet+javabean的模式\",{\"1\":{\"1534\":1}}],[\"最早零拷贝的定义\",{\"1\":{\"1453\":1}}],[\"最小都为0\",{\"1\":{\"1431\":1}}],[\"最小值\",{\"1\":{\"616\":1,\"1492\":1,\"1493\":1}}],[\"最节省cpu\",{\"1\":{\"1397\":1}}],[\"最右边移除值\",{\"1\":{\"708\":1}}],[\"最终就会进入到transactioninterceptor的invoke\",{\"1\":{\"1532\":1}}],[\"最终生成的结果必须是等价的\",{\"1\":{\"1492\":1}}],[\"最终返回一个整体\",{\"1\":{\"1486\":1}}],[\"最终将他们拼接起来\",{\"1\":{\"1485\":1}}],[\"最终将数据添加到容器中是由segment对象的put方法来完成\",{\"1\":{\"1430\":1}}],[\"最终输出时赋值给exchange\",{\"1\":{\"1356\":1}}],[\"最终eax存的compare\",{\"1\":{\"1356\":1}}],[\"最终肯定会解析不成功的\",{\"1\":{\"798\":1}}],[\"最终mysql使用了idx\",{\"1\":{\"681\":1}}],[\"最终选择的访问路径\",{\"1\":{\"656\":1}}],[\"最佳实践\",{\"0\":{\"647\":1,\"833\":1,\"837\":1}}],[\"最佳左前缀法则\",{\"0\":{\"507\":1},\"1\":{\"506\":1,\"507\":1}}],[\"最不怕的就是rm删除数据了\",{\"1\":{\"625\":1}}],[\"最花时间的就是第三步在本地构建哈希表的操作\",{\"1\":{\"619\":1}}],[\"最可能影响并发度的锁尽量完后放\",{\"1\":{\"580\":1}}],[\"最简单的方案就是避免共享\",{\"1\":{\"1405\":1}}],[\"最简单的事件轮询api是select函数\",{\"1\":{\"740\":1}}],[\"最简单的衡量查询开销的三个指标如下\",{\"1\":{\"524\":1}}],[\"最简单直接的方法就是执行select\",{\"1\":{\"613\":1}}],[\"最简单有效的解决方法就是在这样的查询后面加上limit\",{\"1\":{\"520\":1}}],[\"最好做笔记\",{\"1\":{\"1850\":1}}],[\"最好还是要有意义\",{\"1\":{\"1472\":1}}],[\"最好能通过模拟对比评估\",{\"1\":{\"1387\":1}}],[\"最好就是只恢复这张表\",{\"1\":{\"622\":1}}],[\"最好使用set\",{\"1\":{\"572\":1}}],[\"最好索引怎么创建的\",{\"1\":{\"515\":1}}],[\"最好达到ref\",{\"1\":{\"467\":1}}],[\"最根本的原因是没有能准确地判断出扫描行数\",{\"1\":{\"484\":1}}],[\"最左前缀可以用于在索引中定位记录\",{\"1\":{\"477\":1}}],[\"最左前缀\",{\"1\":{\"476\":1}}],[\"最左前缀原则\",{\"0\":{\"476\":1}}],[\"最外层查询则被标记为primary\",{\"1\":{\"467\":1}}],[\"最主要的就是元素映射到原矩阵的行和列上\",{\"1\":{\"443\":1}}],[\"最大作用就是对文件进行版本管理\",{\"1\":{\"1859\":1}}],[\"最大值\",{\"1\":{\"1492\":1,\"1493\":1}}],[\"最大限度地减少了线程竞争任务的可能性\",{\"1\":{\"1388\":1}}],[\"最大限度地减少无谓地字符串比较\",{\"1\":{\"301\":1}}],[\"最大线程数的存活时间\",{\"1\":{\"1353\":1}}],[\"最大线程数\",{\"1\":{\"1353\":1}}],[\"最大能跳跃到的地方\",{\"1\":{\"421\":1}}],[\"最近的公共祖先\",{\"1\":{\"398\":1}}],[\"最近公共祖先的定义\",{\"1\":{\"398\":1}}],[\"最近至少使用\",{\"1\":{\"310\":1}}],[\"最后再来看原理部分\",{\"1\":{\"1871\":1}}],[\"最后还会带大家做一个书城项目\",{\"1\":{\"1856\":1}}],[\"最后还要分析是否可能会使用到索引合并\",{\"1\":{\"686\":1}}],[\"最后创建一个新的beanfactory\",{\"1\":{\"1528\":1}}],[\"最后调用普通对象的方法\",{\"1\":{\"1507\":1}}],[\"最后将执行的结果\",{\"1\":{\"1500\":1}}],[\"最后进行汇聚操作\",{\"1\":{\"1500\":1}}],[\"最后流被汇总起来生成一个总的重量\",{\"1\":{\"1496\":1}}],[\"最后我们可以看一个jdk实现的一个例子\",{\"1\":{\"1485\":1}}],[\"最后我们来看一下对于参数的说明\",{\"1\":{\"1485\":1}}],[\"最后我们来看一下它唯一的static方法\",{\"1\":{\"1476\":1}}],[\"最后返回结果\",{\"1\":{\"1485\":1}}],[\"最后返回累计值\",{\"1\":{\"536\":1}}],[\"最后探究stream的实现原理\",{\"1\":{\"1484\":1}}],[\"最后这个方法就比较简单了\",{\"1\":{\"1475\":1}}],[\"最后利用dma将socket\",{\"1\":{\"1459\":1}}],[\"最后是concurrenthashmap的扩容过程\",{\"1\":{\"1431\":1}}],[\"最后释放读锁的过程\",{\"1\":{\"1375\":1}}],[\"最后优化器会比较这两种方式的最优访问成本\",{\"1\":{\"692\":1}}],[\"最后两个参数分别表示\",{\"1\":{\"604\":1}}],[\"最后一点是从性能的角度去考虑\",{\"1\":{\"1386\":1}}],[\"最后一次append方法结束后进行解锁\",{\"1\":{\"1363\":1}}],[\"最后一个元素\",{\"1\":{\"708\":1}}],[\"最后一个值弹出\",{\"1\":{\"708\":1}}],[\"最后一种方式是\",{\"1\":{\"663\":1}}],[\"最后一种方法是\",{\"1\":{\"581\":1}}],[\"最后一列sum\",{\"1\":{\"616\":1}}],[\"最后一行是一个commit\",{\"1\":{\"591\":1}}],[\"最后一行就是所有的结果\",{\"1\":{\"426\":1}}],[\"最后一行和最后一列都只有一种走法\",{\"1\":{\"425\":1}}],[\"最后判断是否出现了循环等待\",{\"1\":{\"581\":1}}],[\"最后把这些消耗都加起来\",{\"1\":{\"525\":1}}],[\"最后的更新覆盖了由其他事务所做的更新\",{\"1\":{\"669\":1}}],[\"最后的第四组数据\",{\"1\":{\"616\":1}}],[\"最后的xid\",{\"1\":{\"591\":1}}],[\"最后的\",{\"1\":{\"492\":1}}],[\"最后的查询select\",{\"1\":{\"491\":1}}],[\"最后剩下的不够k个字符时全部反转\",{\"1\":{\"384\":1}}],[\"最后从map中获取值并返回\",{\"1\":{\"380\":1}}],[\"最直观的做法\",{\"1\":{\"362\":1}}],[\"最优访问路径\",{\"1\":{\"656\":1}}],[\"最优子结构\",{\"1\":{\"325\":1}}],[\"最优判断\",{\"1\":{\"293\":1}}],[\"最初初始值均为0\",{\"1\":{\"307\":1}}],[\"是组装机\",{\"1\":{\"1868\":1}}],[\"是品牌机\",{\"1\":{\"1868\":1}}],[\"是基于\",{\"1\":{\"1859\":1}}],[\"是跨平台的非关系型数据库\",{\"1\":{\"1853\":1}}],[\"是目前应用最广泛的开源关系数据库\",{\"1\":{\"1852\":1}}],[\"是目前比较常见的做法\",{\"1\":{\"594\":1}}],[\"是针对于元的分割迭代器\",{\"1\":{\"1498\":1}}],[\"是整个流实现非常重要的一环\",{\"1\":{\"1497\":1}}],[\"是将中间的累积类型转换称为最终的结果类型\",{\"1\":{\"1492\":1}}],[\"是将当前线程插入到cxq的头部\",{\"1\":{\"1360\":1}}],[\"是collector类型的\",{\"1\":{\"1492\":1}}],[\"是jdk为我们提供的api\",{\"1\":{\"1486\":1}}],[\"是兼容的\",{\"1\":{\"1485\":1}}],[\"是采用下面的方式来创建流\",{\"1\":{\"1484\":1}}],[\"是需要上下文才能解读的\",{\"1\":{\"1472\":1}}],[\"是继承自obeject类中的方法\",{\"1\":{\"1472\":1}}],[\"是之前的select和poll的增强版本\",{\"1\":{\"1448\":1}}],[\"是你与操作系统打交道的东西\",{\"1\":{\"1438\":1}}],[\"是计算机科学中的一个术语\",{\"1\":{\"1438\":1}}],[\"是正在初始化的标识\",{\"1\":{\"1431\":1}}],[\"是1就表示索引变成了\",{\"1\":{\"1427\":1}}],[\"是没有并发问题的\",{\"1\":{\"1403\":1}}],[\"是高并发场景下一个底层细节问题\",{\"1\":{\"1396\":1}}],[\"是非常有效的\",{\"1\":{\"1468\":1}}],[\"是非常麻烦的\",{\"1\":{\"1395\":1}}],[\"是非常大的一个数\",{\"1\":{\"1378\":1}}],[\"是fifo先进先出线程等待队列\",{\"1\":{\"1368\":1}}],[\"是后来的线程先获取锁\",{\"1\":{\"1360\":1}}],[\"是后台操作\",{\"1\":{\"482\":1}}],[\"是用来将一个新的数据元素添加到结果容器当中\",{\"1\":{\"1492\":1}}],[\"是用来创建新的可变的结果容器\",{\"1\":{\"1492\":1}}],[\"是用来做基数\",{\"1\":{\"714\":1}}],[\"是用户态的\",{\"1\":{\"1354\":1}}],[\"是位于cpu与主存之间的一种容量较小但速度很高的存储器\",{\"1\":{\"1351\":1}}],[\"是暂时的\",{\"1\":{\"747\":1}}],[\"是持久化之外的一种数据冗余的方式\",{\"1\":{\"744\":1}}],[\"是0就表示索引没有变化\",{\"1\":{\"1427\":1}}],[\"是0\",{\"1\":{\"715\":1}}],[\"是常数级别的\",{\"1\":{\"686\":1}}],[\"是通过让线程等待来保护实例的安全性\",{\"1\":{\"1407\":1}}],[\"是通过将所有操作加锁互斥来实现的\",{\"1\":{\"677\":1}}],[\"是通过提交一个空事务\",{\"1\":{\"605\":1}}],[\"是当前读\",{\"1\":{\"672\":1}}],[\"是当内存放不下时\",{\"1\":{\"491\":1}}],[\"是快照读\",{\"1\":{\"672\":1}}],[\"是矛盾的\",{\"1\":{\"669\":1}}],[\"是为了说明这两次查询看到的事务对应的线程id都是5\",{\"1\":{\"634\":1}}],[\"是另外维护的\",{\"1\":{\"634\":1}}],[\"是插入失败\",{\"1\":{\"632\":1}}],[\"是更能被接受的\",{\"1\":{\"632\":1}}],[\"是可能会被用完的\",{\"1\":{\"631\":1}}],[\"是可以精确计算出需要多少个id的\",{\"1\":{\"629\":1}}],[\"是可以执行这两条update语句的\",{\"1\":{\"584\":1}}],[\"是4个字节\",{\"1\":{\"630\":1}}],[\"是执行不出来的\",{\"1\":{\"629\":1}}],[\"是在属性填充的时候会直接生成一个代理对象\",{\"1\":{\"1526\":1}}],[\"是在真正执行插入数据的操作之前\",{\"1\":{\"628\":1}}],[\"是在writeset的基础上多了一个约束\",{\"1\":{\"602\":1}}],[\"是避免写错要删除的表名\",{\"1\":{\"624\":1}}],[\"是指向对象的\",{\"1\":{\"1438\":1}}],[\"是指线程之间所具有的一种制约关系\",{\"1\":{\"1354\":1}}],[\"是指将一台redis服务器的数据\",{\"1\":{\"743\":1}}],[\"是指如果由于时间太久\",{\"1\":{\"622\":1}}],[\"是指binlog文件写到一定大小后会切换到写一个\",{\"1\":{\"462\":1}}],[\"是修改binlog的内容\",{\"1\":{\"621\":1}}],[\"是有一个过程的\",{\"1\":{\"618\":1}}],[\"是对计算密集型场景的加强\",{\"1\":{\"1387\":1}}],[\"是对其他类型数据的统计\",{\"1\":{\"616\":1}}],[\"是对资源的浪费\",{\"1\":{\"601\":1}}],[\"是读操作的统计\",{\"1\":{\"616\":1}}],[\"是所有io类型的统计\",{\"1\":{\"616\":1}}],[\"是最主要的问题\",{\"1\":{\"615\":1}}],[\"是合理而且必要的\",{\"1\":{\"613\":1}}],[\"是这类方案常用的退化机制\",{\"1\":{\"610\":1}}],[\"是这个事务的唯一标识\",{\"1\":{\"605\":1}}],[\"是能确保读到最新数据\",{\"1\":{\"609\":1}}],[\"是备库所有已经执行完成的gtid集合\",{\"1\":{\"609\":1}}],[\"是主备收到的所有日志的gtid集合\",{\"1\":{\"609\":1}}],[\"是由操作系统来决定的\",{\"1\":{\"1462\":1}}],[\"是由备库决定的\",{\"1\":{\"605\":1}}],[\"是由参数slave\",{\"1\":{\"597\":1}}],[\"是由参数sync\",{\"1\":{\"587\":1}}],[\"是由参数internal\",{\"1\":{\"558\":1}}],[\"是依赖于主备延迟的\",{\"1\":{\"596\":1}}],[\"是\",{\"1\":{\"585\":1,\"709\":1,\"726\":2,\"1360\":1,\"1453\":5,\"1864\":1}}],[\"是lock\",{\"1\":{\"579\":1}}],[\"是mysql一开始支持分区表的时候就存在的代码\",{\"1\":{\"562\":1}}],[\"是不安全的\",{\"1\":{\"720\":1}}],[\"是不区分非叶子结点和叶子结点的\",{\"1\":{\"685\":1}}],[\"是不可见的\",{\"1\":{\"679\":1}}],[\"是不影响数据的可见性判断的\",{\"1\":{\"634\":1}}],[\"是不会看到别的事务插入的数据的\",{\"1\":{\"583\":1}}],[\"是不需要额外内存的\",{\"1\":{\"555\":1}}],[\"是不是里面没有元素\",{\"1\":{\"1497\":1}}],[\"是不是抛出异常取决于调用者\",{\"1\":{\"1472\":1}}],[\"是不是真的需要返回全部的数据\",{\"1\":{\"522\":1}}],[\"是不是浪费空间\",{\"1\":{\"475\":1}}],[\"是定义为not\",{\"1\":{\"536\":1}}],[\"是数据库系统设计的通用法则之一\",{\"1\":{\"533\":1}}],[\"是数据库里面成本最高的操作之一\",{\"1\":{\"480\":1}}],[\"是根据库中key的个数\",{\"1\":{\"704\":1}}],[\"是根据b+树索引的结构来的\",{\"1\":{\"686\":1}}],[\"是根据sql语句中的where条件\",{\"1\":{\"562\":1}}],[\"是根据tradeid的值到trade\",{\"1\":{\"505\":1}}],[\"是根据id在tradelog表里找到l2这一行\",{\"1\":{\"505\":1}}],[\"是根据关键码值直接访问元素的数据结构\",{\"1\":{\"332\":1}}],[\"是直接继承了beanfactory\",{\"1\":{\"1513\":1}}],[\"是直接返回给客户端的\",{\"1\":{\"492\":1}}],[\"是直接在主键索引上扫描的\",{\"1\":{\"484\":1}}],[\"是从0到248\",{\"1\":{\"632\":1}}],[\"是从l2中取出tradeid字段的值\",{\"1\":{\"505\":1}}],[\"是从\",{\"1\":{\"491\":1}}],[\"是因为依赖注入的可能也是原型bean\",{\"1\":{\"1525\":1}}],[\"是因为\",{\"1\":{\"629\":1}}],[\"是因为在这个隔离级别下\",{\"1\":{\"570\":1}}],[\"是因为在join\",{\"1\":{\"545\":1}}],[\"是因为在不断地选择剩余元素中最小的元素\",{\"1\":{\"318\":1}}],[\"是因为这时候参与排序的行数虽然仍然是4000行\",{\"1\":{\"492\":1}}],[\"是因为它认为使用索引b可以避免排序\",{\"1\":{\"485\":1}}],[\"是找到一个最优的执行方案\",{\"1\":{\"484\":1}}],[\"是无法使用\",{\"1\":{\"476\":1}}],[\"是回文\",{\"1\":{\"428\":1}}],[\"是叶子节点\",{\"1\":{\"411\":1}}],[\"是黑色\",{\"1\":{\"343\":1}}],[\"是一系列框架的有序集合\",{\"1\":{\"1867\":1}}],[\"是一套完整的微服务解决方案\",{\"1\":{\"1867\":1}}],[\"是一款优秀的持久层框架\",{\"1\":{\"1860\":1}}],[\"是一本小册子\",{\"1\":{\"1852\":1}}],[\"是一批一批进行解析的\",{\"1\":{\"1529\":1}}],[\"是一次性去除满足条件行的所有字段\",{\"1\":{\"657\":1}}],[\"是一样的\",{\"1\":{\"540\":1}}],[\"是一个基于mvc架构\",{\"1\":{\"1860\":1}}],[\"是一个轻量级的\",{\"1\":{\"1860\":1}}],[\"是一个开源的分布式版本控制系统\",{\"1\":{\"1859\":1}}],[\"是一个开源的使用ansi\",{\"1\":{\"701\":1}}],[\"是一个项目管理工具\",{\"1\":{\"1858\":1}}],[\"是一个\",{\"1\":{\"1853\":1}}],[\"是一个string类型的field和value的映射表\",{\"1\":{\"710\":1}}],[\"是一个只读事务\",{\"1\":{\"634\":1}}],[\"是一个全局唯一的值\",{\"1\":{\"605\":1}}],[\"是一个事务在提交的时候生成的\",{\"1\":{\"605\":1}}],[\"是一个聚合函数\",{\"1\":{\"536\":1}}],[\"是一个逻辑概念\",{\"1\":{\"492\":1}}],[\"是一个常数\",{\"1\":{\"467\":1}}],[\"是一种跨进程的通信机制\",{\"1\":{\"1863\":1}}],[\"是一种栈结构\",{\"1\":{\"1541\":1}}],[\"是一种可以有效减少java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法\",{\"1\":{\"1365\":1}}],[\"是一种服务冗余的方式\",{\"1\":{\"744\":1}}],[\"是一种消息通信模式\",{\"1\":{\"733\":1}}],[\"是一种含有红黑结点并能自平衡的二叉查找树\",{\"1\":{\"343\":1}}],[\"是一种树形结构\",{\"1\":{\"301\":1}}],[\"是一棵空树或者具有下列性质的二叉树\",{\"1\":{\"340\":1}}],[\"是相互之间存在一种或多种特定关系的数据元素的集合\",{\"1\":{\"328\":1}}],[\"是否需要利用动态代理产生一个代理对象\",{\"1\":{\"1532\":1}}],[\"是否需要将一个复杂的查询分成多个简单的查询\",{\"1\":{\"529\":1}}],[\"是否可以把所有bean都交由spring\",{\"0\":{\"1538\":1}}],[\"是否可以把所有bean都通过spring容器来管理\",{\"0\":{\"1537\":1}}],[\"是否可以重复刷新的应用上下文\",{\"1\":{\"1528\":1}}],[\"是否可被\",{\"0\":{\"14\":1}}],[\"是否会直接返回值\",{\"1\":{\"1487\":1}}],[\"是否同步\",{\"1\":{\"1453\":1}}],[\"是否阻塞\",{\"1\":{\"1453\":1}}],[\"是否要求属性对象也具备不可变性\",{\"1\":{\"1403\":1}}],[\"是否有可能使用索引合并\",{\"0\":{\"687\":1}}],[\"是否有必要将身份证号和名字建立联合索引\",{\"1\":{\"475\":1}}],[\"是否选择该索引\",{\"1\":{\"656\":1}}],[\"是否使用覆盖索引\",{\"1\":{\"656\":1}}],[\"是否支持异步\",{\"1\":{\"1535\":1}}],[\"是否支持\",{\"1\":{\"568\":1}}],[\"是否排序等因素进行综合判断\",{\"1\":{\"484\":1}}],[\"是否在网格中\",{\"1\":{\"435\":2}}],[\"是否在集合中\",{\"1\":{\"307\":1}}],[\"是否是一个bean\",{\"1\":{\"1524\":1}}],[\"是否是红黑树\",{\"1\":{\"1426\":1}}],[\"是否是红点\",{\"1\":{\"302\":1}}],[\"是否是回文串\",{\"1\":{\"428\":1}}],[\"是否为treenode\",{\"1\":{\"1426\":1}}],[\"是否为回文串\",{\"1\":{\"428\":1}}],[\"是否为空或者为null\",{\"1\":{\"1426\":1}}],[\"是否为空\",{\"1\":{\"405\":1}}],[\"是否移除成功\",{\"1\":{\"302\":1}}],[\"是否存在\",{\"1\":{\"302\":1}}],[\"即先学会用这个技术\",{\"1\":{\"1871\":1}}],[\"即先遇到的先遍历\",{\"1\":{\"1500\":1}}],[\"即1\",{\"1\":{\"1541\":1}}],[\"即渲染视图后\",{\"1\":{\"1534\":1}}],[\"即按照around\",{\"1\":{\"1531\":1}}],[\"即不限制\",{\"1\":{\"1541\":1}}],[\"即不是通过链式调用\",{\"1\":{\"1498\":1}}],[\"即不同存储引擎的索引的工作方式并不一样\",{\"1\":{\"471\":1}}],[\"即只关心偶书位置上的数据\",{\"1\":{\"1497\":1}}],[\"即只有一个入口\",{\"1\":{\"1405\":1}}],[\"即只有一个线程能对cells初始化\",{\"1\":{\"1357\":1}}],[\"即执行的结果与执行的顺序是无关的\",{\"1\":{\"1496\":1}}],[\"即采用传统的方式来进行一些流的操作\",{\"1\":{\"1496\":1}}],[\"即map\",{\"1\":{\"1495\":1}}],[\"即流中的每一个元素的类型\",{\"1\":{\"1492\":1}}],[\"即identity\",{\"1\":{\"1492\":1}}],[\"即id在\",{\"1\":{\"673\":1}}],[\"即compare\",{\"1\":{\"1491\":1}}],[\"即对象引用\",{\"1\":{\"1477\":1}}],[\"即对象指向它的类元数据的指针\",{\"1\":{\"1361\":1}}],[\"即便uservice类上没有\",{\"1\":{\"1522\":1}}],[\"即便它上面有\",{\"1\":{\"1522\":1}}],[\"即便不是精确的知道待遍历元素的数量\",{\"1\":{\"1497\":1}}],[\"即便我们使用的不是终止操作\",{\"1\":{\"1487\":1}}],[\"即便我们没有给他加上\",{\"1\":{\"1471\":1}}],[\"即便有5秒钟延迟\",{\"1\":{\"1404\":1}}],[\"即便有上面两条规则的限制\",{\"1\":{\"693\":1}}],[\"即直接内存访问\",{\"1\":{\"1455\":1}}],[\"即网卡\",{\"1\":{\"1453\":1}}],[\"即会引起死循环\",{\"1\":{\"1428\":1}}],[\"即当键值对的实际大小size大于table的实际大小时进行扩容\",{\"1\":{\"1427\":1}}],[\"即数组加链表的方式\",{\"1\":{\"1423\":1}}],[\"即任一时刻可以有多个线程同时写hashmap\",{\"1\":{\"1421\":1}}],[\"即守护\",{\"1\":{\"1407\":1}}],[\"即记过按照完成先后顺序排序\",{\"1\":{\"1394\":1}}],[\"即遵循锁降级的步骤\",{\"1\":{\"1375\":1}}],[\"即在读写数据的过程中会阻塞\",{\"1\":{\"1440\":1}}],[\"即在第一次append方法时进行加锁\",{\"1\":{\"1363\":1}}],[\"即在主库上同一个线程先后执行的两个事务\",{\"1\":{\"602\":1}}],[\"即锁粗化\",{\"1\":{\"1363\":1}}],[\"即这时候线持有锁的线程已经退出了同步块\",{\"1\":{\"1362\":1}}],[\"即函数最终返回的值是原先的compare\",{\"1\":{\"1356\":1}}],[\"即一个变量如何才主内存拷贝到工作内存\",{\"1\":{\"1350\":1}}],[\"即一个线程如何和何时可以看到由其他线程修改过后的共享变量的值\",{\"1\":{\"1350\":1}}],[\"即旧的slave\",{\"1\":{\"761\":1}}],[\"即远程字典服务\",{\"1\":{\"701\":1}}],[\"即索引列平均一个值重复多少次\",{\"1\":{\"692\":1}}],[\"即无索引行锁会升级为表锁\",{\"1\":{\"674\":1}}],[\"即小的数据集驱动大的数据集\",{\"1\":{\"662\":1}}],[\"即语句执行结束后才释放锁\",{\"1\":{\"629\":1}}],[\"即由于主从可能存在延迟\",{\"1\":{\"606\":1}}],[\"即readonly=true\",{\"1\":{\"595\":1}}],[\"即table\",{\"1\":{\"1426\":1}}],[\"即takeindex++\",{\"1\":{\"1379\":1}}],[\"即t2\",{\"1\":{\"594\":1}}],[\"即trie树\",{\"1\":{\"301\":1}}],[\"即主动死锁检测\",{\"1\":{\"581\":1}}],[\"即主键查询方式\",{\"1\":{\"472\":1}}],[\"即原子性\",{\"1\":{\"569\":1}}],[\"即name和id\",{\"1\":{\"492\":1}}],[\"即name字段\",{\"1\":{\"492\":1}}],[\"即使没有学过这些技术\",{\"1\":{\"1865\":1}}],[\"即使没有出现线程竞争\",{\"1\":{\"1363\":1}}],[\"即使它们的类名相同\",{\"1\":{\"1571\":1}}],[\"即使负载因子和哈希算法设计的再合理\",{\"1\":{\"1423\":1}}],[\"即使再好的哈希算法也会出现较多碰撞\",{\"1\":{\"1423\":1}}],[\"即使较差的哈希算法也会比较分散\",{\"1\":{\"1423\":1}}],[\"即使100万qps的处理速度\",{\"1\":{\"1396\":1}}],[\"即使对空值设置了过期时间\",{\"1\":{\"764\":1}}],[\"即使过了这个超时\",{\"1\":{\"761\":1}}],[\"即使只是执行一个普通的select语句\",{\"1\":{\"634\":1}}],[\"即使innodb\",{\"1\":{\"629\":1}}],[\"即使我们配置了binlog\",{\"1\":{\"622\":1}}],[\"即使是dba团队成员\",{\"1\":{\"624\":1}}],[\"即使是客户端退出了\",{\"1\":{\"618\":1}}],[\"即使是一个千兆网卡也能轻松满足每秒超过2000次的查询\",{\"1\":{\"529\":1}}],[\"即使把所有的记录都加上锁\",{\"1\":{\"584\":1}}],[\"即使长事务最终提交\",{\"1\":{\"571\":1}}],[\"即使开了多线程复制\",{\"1\":{\"550\":1}}],[\"即使redis正常工作\",{\"1\":{\"534\":1}}],[\"即使在一个通用服务器上\",{\"1\":{\"529\":1}}],[\"即使库表结构再合理\",{\"1\":{\"518\":1}}],[\"即使不改变有序性\",{\"1\":{\"503\":1}}],[\"即使name字段的定义是varchar\",{\"1\":{\"491\":1}}],[\"即使将index2的定义修改为email\",{\"1\":{\"488\":1}}],[\"即使你使用管理员账号对这个用户的权限做了修改\",{\"1\":{\"455\":1}}],[\"即整个email字符串的索引结构\",{\"1\":{\"488\":1}}],[\"即满足前缀\",{\"1\":{\"487\":1}}],[\"即email\",{\"1\":{\"487\":1,\"488\":1}}],[\"即email整个字符串的索引结构\",{\"1\":{\"487\":1}}],[\"即普通索引查询方式\",{\"1\":{\"472\":1}}],[\"即key应该是\",{\"1\":{\"599\":1}}],[\"即key\",{\"1\":{\"467\":1}}],[\"即h0​\",{\"1\":{\"431\":1}}],[\"即可\",{\"1\":{\"430\":1,\"605\":1}}],[\"即\",{\"1\":{\"428\":1,\"487\":1,\"543\":1,\"584\":1,\"585\":1,\"592\":1,\"609\":1,\"618\":1,\"1857\":1}}],[\"即遍历字符串\",{\"1\":{\"386\":1}}],[\"即元素都在左子树上或者都在右子树上\",{\"1\":{\"339\":1}}],[\"即通过某个函数f\",{\"1\":{\"332\":1}}],[\"即x\",{\"1\":{\"315\":1}}],[\"即顺序存储\",{\"1\":{\"304\":1}}],[\"即最有利的选择\",{\"1\":{\"293\":1}}],[\"二次哈希\",{\"1\":{\"1430\":1}}],[\"二者在大部分属性的设定上都是类似的\",{\"1\":{\"1498\":1}}],[\"二者是不同的\",{\"1\":{\"1438\":1}}],[\"二者都是一起执行的\",{\"1\":{\"1347\":1}}],[\"二者的区别在于删除失败的情况的处理\",{\"1\":{\"354\":1}}],[\"二者的区别在于获取失败的情况的处理\",{\"1\":{\"354\":1}}],[\"二者的区别在于插入失败情况的处理\",{\"1\":{\"354\":1}}],[\"二从\",{\"1\":{\"747\":1}}],[\"二进制形式的极大文本数据\",{\"1\":{\"667\":1}}],[\"二进制形式的中等长度文本数据\",{\"1\":{\"667\":1}}],[\"二进制形式的长文本数据\",{\"1\":{\"667\":1}}],[\"二进制\",{\"1\":{\"664\":1}}],[\"二是工作线程从队列中获取任务时存在竞争情况\",{\"1\":{\"1387\":1}}],[\"二是如果索引改了名字\",{\"1\":{\"485\":1}}],[\"二是语句q2为什么优化器没有选择37116行的执行计划\",{\"1\":{\"484\":1}}],[\"二是用空间换时间\",{\"1\":{\"328\":1}}],[\"二叉排序树\",{\"1\":{\"340\":1}}],[\"二叉搜索树有两个重要性质\",{\"1\":{\"397\":1}}],[\"二叉搜索树的特点是\",{\"1\":{\"471\":1}}],[\"二叉搜索树的插入和查询时间复杂度都是o\",{\"1\":{\"340\":1}}],[\"二叉搜索树的性质\",{\"1\":{\"340\":1}}],[\"二叉搜索树\",{\"0\":{\"340\":1,\"471\":1},\"1\":{\"340\":1}}],[\"二叉树是搜索效率最高的\",{\"1\":{\"471\":1}}],[\"二叉树的所有路径\",{\"0\":{\"409\":1}}],[\"二叉树的右视图\",{\"0\":{\"403\":1}}],[\"二叉树的层次遍历\",{\"0\":{\"402\":1}}],[\"二叉树的遍历方法有以下几种\",{\"1\":{\"339\":1}}],[\"二叉树遍历遍历的性质\",{\"1\":{\"339\":1}}],[\"二叉树\",{\"0\":{\"339\":1},\"1\":{\"638\":1}}],[\"二叉树递归模板\",{\"1\":{\"296\":1}}],[\"二维数组的定义及遍历\",{\"1\":{\"329\":1}}],[\"二分查找的时间复杂度为o\",{\"1\":{\"304\":1}}],[\"二分查找的核心思想是\",{\"1\":{\"304\":1}}],[\"二分查找又称折半查找\",{\"1\":{\"304\":1}}],[\"二分查找\",{\"0\":{\"303\":1,\"360\":1}}],[\"二级缓存的实现采用了装饰器设计模式\",{\"1\":{\"806\":1}}],[\"二级缓存\",{\"0\":{\"207\":1}}],[\"前端有三大基础技术\",{\"1\":{\"1855\":1}}],[\"前一个表指explain中id值比当前表id值小的表\",{\"1\":{\"643\":1}}],[\"前三个session中的sleep\",{\"1\":{\"613\":1}}],[\"前三条语句的作用\",{\"1\":{\"605\":1}}],[\"前四个参数分别代表了a\",{\"1\":{\"604\":1}}],[\"前面学的越好\",{\"1\":{\"1847\":1}}],[\"前面提到过hashmap的数据结构是数组和链表的结合\",{\"1\":{\"1425\":1}}],[\"前面我们介绍过的supplier函数式接口其中一个很重要的应用就是构造方法引用\",{\"1\":{\"1483\":1}}],[\"前面我们提到过\",{\"1\":{\"1472\":1}}],[\"前面我们提到两个成本常数\",{\"1\":{\"694\":1}}],[\"前面我们了解了一些关于索引的理论知识\",{\"1\":{\"494\":1}}],[\"前面说过\",{\"1\":{\"690\":1}}],[\"前面的小节中我们介绍过mysql主备流程图\",{\"1\":{\"597\":1}}],[\"前后的begin和commit是一样的\",{\"1\":{\"591\":1}}],[\"前缀\",{\"1\":{\"1356\":1}}],[\"前缀sum\",{\"1\":{\"616\":1}}],[\"前缀是\",{\"1\":{\"549\":1}}],[\"前缀索引除了可能会增加扫描行数\",{\"1\":{\"488\":1}}],[\"前缀索引与覆盖索引\",{\"0\":{\"488\":1}}],[\"前缀索引很可能会损失区分度\",{\"1\":{\"487\":1}}],[\"前缀索引也可能会增加额外的记录扫描次数\",{\"1\":{\"487\":1}}],[\"前缀索引\",{\"0\":{\"487\":1}}],[\"前两个参数的作用是启用mrr\",{\"1\":{\"542\":1}}],[\"前者称为主节点\",{\"1\":{\"743\":1}}],[\"前者会抛出异常\",{\"1\":{\"354\":2}}],[\"前者插入失败是抛出异常\",{\"1\":{\"354\":1}}],[\"前序遍历的回溯算法\",{\"1\":{\"409\":1}}],[\"前序遍历所有节点\",{\"1\":{\"302\":1}}],[\"前序\",{\"1\":{\"339\":1}}],[\"前\",{\"1\":{\"295\":1,\"1534\":1}}],[\"一周学会linux视频\",{\"1\":{\"1865\":1}}],[\"一入java深似海\",{\"1\":{\"1845\":1}}],[\"一级缓存就会失效\",{\"1\":{\"1530\":1}}],[\"一部分是用户空间\",{\"1\":{\"1456\":1}}],[\"一部分是内核空间\",{\"1\":{\"1456\":1}}],[\"一些涉及底层的程序编写往往会围绕着文件描述符展开\",{\"1\":{\"1438\":1}}],[\"一些归档性的数据\",{\"1\":{\"594\":1}}],[\"一下表的大小\",{\"1\":{\"1427\":1}}],[\"一方面创建线程比较耗时\",{\"1\":{\"1410\":1}}],[\"一条消息只会被一个消费者消费\",{\"1\":{\"1398\":1}}],[\"一条查询语句的执行成本是由下面这两个方面组成的\",{\"1\":{\"682\":1}}],[\"一段代码块如果存在对共享资源的多线程读写操作\",{\"1\":{\"1359\":1}}],[\"一组规则\",{\"1\":{\"1350\":1}}],[\"一组事务在commit的时候\",{\"1\":{\"601\":1}}],[\"一主\",{\"1\":{\"747\":1}}],[\"一主二从配置\",{\"0\":{\"747\":1}}],[\"一主多从的时候\",{\"1\":{\"609\":1}}],[\"一主多从的切换场景下\",{\"1\":{\"605\":1}}],[\"一主多从的结构在切换完成后\",{\"1\":{\"603\":1}}],[\"一主多从的设置\",{\"1\":{\"603\":1}}],[\"一主多从的方式比较常用\",{\"1\":{\"594\":1}}],[\"一主多从\",{\"0\":{\"603\":1},\"1\":{\"594\":1}}],[\"一样只适用于整数型字段\",{\"1\":{\"710\":1}}],[\"一致\",{\"1\":{\"659\":1}}],[\"一致性哈希策略\",{\"0\":{\"1773\":1}}],[\"一致性机制\",{\"1\":{\"1351\":1}}],[\"一致性可以在加载\",{\"1\":{\"1351\":1}}],[\"一致性\",{\"1\":{\"569\":1}}],[\"一次请求若在缓存和数据库中都没找到\",{\"1\":{\"764\":1}}],[\"一次性完成\",{\"1\":{\"716\":1}}],[\"一次性\",{\"1\":{\"715\":1}}],[\"一次性地使用delete语句删除太多数据\",{\"1\":{\"594\":1}}],[\"一次一行循环地从第一张表\",{\"1\":{\"661\":1}}],[\"一次组提交里面\",{\"1\":{\"588\":1}}],[\"一次是binlog\",{\"1\":{\"588\":1}}],[\"一次是redo\",{\"1\":{\"588\":1}}],[\"一次删除一万行数据一般来说时一个比较高效而且对服务器影响也最小的做法\",{\"1\":{\"530\":1}}],[\"一旦有一个handler成功匹配\",{\"1\":{\"1534\":1}}],[\"一旦有新消息产生\",{\"1\":{\"1396\":1}}],[\"一旦一个结果被传递给了combiner或者finisher方法\",{\"1\":{\"1492\":1}}],[\"一旦一个问题可以通过贪心法来解决\",{\"1\":{\"293\":1}}],[\"一旦某个描述符就绪\",{\"1\":{\"1445\":1}}],[\"一旦kernel中的数据准备好了\",{\"1\":{\"1441\":1}}],[\"一旦拉链过长\",{\"1\":{\"1423\":1}}],[\"一旦出现了并发冲突\",{\"1\":{\"1357\":1}}],[\"一旦出现死锁\",{\"1\":{\"581\":1}}],[\"一旦热点数据多了起来\",{\"1\":{\"767\":1}}],[\"一旦主节点出现故障\",{\"1\":{\"758\":1}}],[\"一旦主节点出了故障不可达的情况\",{\"1\":{\"758\":1}}],[\"一旦主节点不能支撑住大并发量的读操作\",{\"1\":{\"758\":2}}],[\"一旦期间有任何事情刀来\",{\"1\":{\"740\":1}}],[\"一旦并发线程数达到这个值\",{\"1\":{\"613\":1}}],[\"一边直接得到结果\",{\"1\":{\"555\":1}}],[\"一边写一边后移\",{\"1\":{\"461\":1}}],[\"一行行地取到业务端\",{\"1\":{\"545\":1}}],[\"一行行地取出a的值\",{\"1\":{\"542\":1}}],[\"一行行地从记录里面读出这个字段\",{\"1\":{\"536\":1}}],[\"一行行地判断\",{\"1\":{\"536\":1}}],[\"一定要找一些题目练习一下\",{\"1\":{\"1852\":1}}],[\"一定要大于或者等于当前的和返回的新的spliterator的estimatesize方法所返回的值\",{\"1\":{\"1497\":1}}],[\"一定就是myinterface\",{\"1\":{\"1472\":2}}],[\"一定碰到过需要根据指定的字段排序来显示结果的需求\",{\"1\":{\"490\":1}}],[\"一定不会修改同一行\",{\"1\":{\"601\":1}}],[\"一定不能写select\",{\"1\":{\"467\":1}}],[\"一定不成立\",{\"1\":{\"366\":1}}],[\"一种理想的trysplit方法在没有进行遍历的情况下\",{\"1\":{\"1497\":1}}],[\"一种方式当然可以调整范围\",{\"1\":{\"1484\":1}}],[\"一种方案是将这个工具类作为局部变量使用\",{\"1\":{\"1405\":1}}],[\"一种方法是\",{\"1\":{\"485\":1,\"581\":1}}],[\"一种加速方式是\",{\"1\":{\"622\":1}}],[\"一种做法是\",{\"1\":{\"604\":1}}],[\"一种取位点的方法是这样的\",{\"1\":{\"604\":1}}],[\"一种场景就是一场切换\",{\"1\":{\"596\":1}}],[\"一种策略是\",{\"1\":{\"581\":1}}],[\"一种是初始状态\",{\"1\":{\"1500\":1}}],[\"一种是在实现类中重写方法\",{\"1\":{\"1484\":1}}],[\"一种是传递值\",{\"1\":{\"1470\":1}}],[\"一种是内存屏障\",{\"1\":{\"1350\":1}}],[\"一种是本地缓存\",{\"1\":{\"619\":1}}],[\"一种是转到主库查询\",{\"1\":{\"610\":1}}],[\"一种是超时放弃\",{\"1\":{\"610\":1}}],[\"一种是row\",{\"1\":{\"591\":1}}],[\"一种是statement\",{\"1\":{\"591\":1}}],[\"一种是\",{\"1\":{\"588\":1}}],[\"一种是元数据锁\",{\"1\":{\"576\":1}}],[\"一种是表锁\",{\"1\":{\"576\":1}}],[\"一种是动态规划\",{\"1\":{\"429\":1}}],[\"一种是记忆化搜索\",{\"1\":{\"429\":1}}],[\"一是无法对大任务进行拆分\",{\"1\":{\"1387\":1}}],[\"一是这么写不足够优雅\",{\"1\":{\"485\":1}}],[\"一是语句q1优化器为什么没有选择索引\",{\"1\":{\"484\":1}}],[\"一是升维\",{\"1\":{\"328\":1}}],[\"一般建议在jvm参数中将metaspacesize和maxmetaspacesize设置成一样的值\",{\"1\":{\"1541\":1}}],[\"一般翻译为饮水槽\",{\"1\":{\"1499\":1}}],[\"一般而言stream由3个部分组成\",{\"1\":{\"1484\":1}}],[\"一般这个时候\",{\"1\":{\"1484\":1}}],[\"一般是读就绪或者写就绪\",{\"1\":{\"1445\":1}}],[\"一般是通过一个内部类sync继承aqs\",{\"1\":{\"1367\":1}}],[\"一般会将这两个值设置成256m\",{\"1\":{\"1541\":1}}],[\"一般会将socket都设置为非阻塞\",{\"1\":{\"1442\":1}}],[\"一般会几种在以下两类\",{\"1\":{\"537\":1}}],[\"一般不要轻易修改\",{\"1\":{\"1423\":1}}],[\"一般不建议将这个参数设成0\",{\"1\":{\"587\":1}}],[\"一般不建议启动该参数\",{\"1\":{\"565\":1}}],[\"一般时间很短\",{\"1\":{\"724\":1}}],[\"一般来讲\",{\"1\":{\"692\":1}}],[\"一般来说有3种\",{\"1\":{\"706\":1}}],[\"一般来说\",{\"1\":{\"467\":1,\"733\":1,\"1850\":1}}],[\"一般用在整表数据迁移的场景\",{\"1\":{\"671\":1}}],[\"一般用于读写分离\",{\"1\":{\"603\":1}}],[\"一般应该遵循下面两步\",{\"1\":{\"664\":1}}],[\"一般都会使用bnl算法\",{\"1\":{\"662\":1}}],[\"一般都会选择第二种策略\",{\"1\":{\"581\":1}}],[\"一般在join语句中\",{\"1\":{\"661\":1}}],[\"一般在1\",{\"1\":{\"526\":1}}],[\"一般的公司建议使用timestamp\",{\"1\":{\"666\":1}}],[\"一般的主备复制结构存在的问题是\",{\"1\":{\"623\":1}}],[\"一般的做法是\",{\"1\":{\"614\":1}}],[\"一般情况下\",{\"1\":{\"548\":1,\"587\":1,\"692\":1}}],[\"一般分库分表的场景\",{\"1\":{\"548\":1}}],[\"一般mysql能够使用如下三种方式应用where条件\",{\"1\":{\"527\":1}}],[\"一般常见和重要的是等待是i\",{\"1\":{\"525\":1}}],[\"一般就是在where语句中出现了between\",{\"1\":{\"467\":1}}],[\"一块是server层\",{\"1\":{\"462\":1}}],[\"一直循环下去\",{\"1\":{\"386\":1}}],[\"一直移动到没有相同项\",{\"1\":{\"366\":1}}],[\"一颗简单的红黑树如下图所示\",{\"1\":{\"343\":1}}],[\"一个高并发项目到落地的心酸路\",{\"1\":{\"1843\":1}}],[\"一个engine组件处理service中的所有请求\",{\"1\":{\"1561\":1}}],[\"一个方法对应一块独立的栈帧内存区域\",{\"1\":{\"1541\":1}}],[\"一个方法团灭\",{\"1\":{\"327\":1}}],[\"一个advisor\",{\"1\":{\"1532\":1}}],[\"一个切面中\",{\"1\":{\"1531\":1}}],[\"一个名字可以对应多个别名\",{\"1\":{\"1513\":1}}],[\"一个终止操作描述了描述了流是如何处理流中元素的\",{\"1\":{\"1500\":1}}],[\"一个终止操作会拥有一个输入类型和一个流的类型\",{\"1\":{\"1500\":1}}],[\"一个具体的中间阶段通常是通过abstractpipeline构建出来的\",{\"1\":{\"1498\":1}}],[\"一个元在结构上的改变是可以通过如下的几种方式来进行管理的\",{\"1\":{\"1497\":1}}],[\"一个调用了trysplit的一个线程\",{\"1\":{\"1497\":1}}],[\"一个估算的值\",{\"1\":{\"1497\":1}}],[\"一个setsqlsessiontemplate\",{\"1\":{\"1530\":1}}],[\"一个setsqlsessionfactory\",{\"1\":{\"1530\":1}}],[\"一个selector可以注册多个channel\",{\"1\":{\"1451\":1}}],[\"一个sqlsession对象需要sqlsessionfactory来产生\",{\"1\":{\"1530\":1}}],[\"一个sink一定是处于两种状态之一的\",{\"1\":{\"1500\":1}}],[\"一个spliterator也可以对它的元素使用trysplit进行分区\",{\"1\":{\"1497\":1}}],[\"一个spliterator可以使用tryadvance单个的遍历元素\",{\"1\":{\"1497\":1}}],[\"一个流调用中间操作或者终止操作只能被操作一次\",{\"1\":{\"1496\":1}}],[\"一个流管道包含了0个或多个中间阶段\",{\"1\":{\"1500\":1}}],[\"一个流管道包含了一个元\",{\"1\":{\"1496\":1}}],[\"一个流管道\",{\"1\":{\"1496\":1}}],[\"一个i\",{\"1\":{\"1496\":1}}],[\"一个生成器法\",{\"1\":{\"1496\":1}}],[\"一个集合\",{\"1\":{\"1496\":1}}],[\"一个并发的结果容器在什么情况下使用呢\",{\"1\":{\"1492\":1}}],[\"一个多线程的汇聚操作指的是accumulator同时被多个线程调用\",{\"1\":{\"1492\":1}}],[\"一个正是我们前面举出的例子\",{\"1\":{\"1485\":1}}],[\"一个正常访问的数据页\",{\"1\":{\"543\":1}}],[\"一个可变的汇聚操作指的是将值汇聚到可变的结果容器\",{\"1\":{\"1485\":1}}],[\"一个函数式接口\",{\"1\":{\"1471\":1}}],[\"一个进程可以监视多个描述符\",{\"1\":{\"1445\":1}}],[\"一个典型的读操作流程大致如下\",{\"1\":{\"1440\":1}}],[\"一个典型的报错情况是这样的\",{\"1\":{\"562\":1}}],[\"一个服务提供方从上线到反馈到客户端的路由表里\",{\"1\":{\"1404\":1}}],[\"一个用于写入操作\",{\"1\":{\"1375\":1}}],[\"一个用于只读操作\",{\"1\":{\"1375\":2}}],[\"一个用户多次访问\",{\"1\":{\"714\":1}}],[\"一个用户成功建立连接后\",{\"1\":{\"455\":1}}],[\"一个程序运行多个线程本身是没有问题的\",{\"1\":{\"1359\":1}}],[\"一个cell\",{\"1\":{\"1357\":1}}],[\"一个线程处理一个任务\",{\"1\":{\"1410\":1}}],[\"一个线程的执行依赖于另一个线程的消息\",{\"1\":{\"1354\":1}}],[\"一个线程就是一个cpu可以执行的指令序列\",{\"1\":{\"1354\":1}}],[\"一个副本在请求它的每个处理器的本地缓存中\",{\"1\":{\"1351\":1}}],[\"一个副本在主内存中\",{\"1\":{\"1351\":1}}],[\"一个热点新闻被同时大量访问就可能导致缓存击穿\",{\"1\":{\"766\":1}}],[\"一个存在的key\",{\"1\":{\"766\":1}}],[\"一个脚本的最大执行时间为60s\",{\"1\":{\"761\":1}}],[\"一个主节点可以有0个或者多个从节点\",{\"1\":{\"743\":1}}],[\"一个循环为一个周期\",{\"1\":{\"740\":1}}],[\"一个列表最多可以包含\",{\"1\":{\"708\":1}}],[\"一个redis实例提供了多个用来存储数据的字典\",{\"1\":{\"704\":1}}],[\"一个页就是一个块\",{\"1\":{\"694\":1}}],[\"一个值的重复次数\",{\"1\":{\"690\":1}}],[\"一个自然而然的结果就是trx\",{\"1\":{\"634\":1}}],[\"一个好处是\",{\"1\":{\"634\":1}}],[\"一个在执行线上逻辑的主库\",{\"1\":{\"621\":1}}],[\"一个语句执行过程中有多处\",{\"1\":{\"618\":1}}],[\"一个机器的cpu核数有限\",{\"1\":{\"613\":1}}],[\"一个更新事务马上发起查询\",{\"1\":{\"606\":1}}],[\"一个箭头代表了客户端写入库\",{\"1\":{\"597\":1}}],[\"一个备库接到binlog并在重放的过程中\",{\"1\":{\"592\":1}}],[\"一个没有提交的事务的redo\",{\"1\":{\"588\":1}}],[\"一个查询正在遍历一个表中的数据\",{\"1\":{\"578\":1}}],[\"一个事务的binlog在主备之间流转的状态如下\",{\"1\":{\"609\":1}}],[\"一个事务的binlog是不能被拆开的\",{\"1\":{\"587\":1}}],[\"一个事务日志同步的完整过程如下\",{\"1\":{\"590\":1}}],[\"一个事务完整提交前\",{\"1\":{\"588\":1}}],[\"一个事务执行过程中看到的数据\",{\"1\":{\"570\":1}}],[\"一个事务提交之后\",{\"1\":{\"570\":1}}],[\"一个事务还没有提交时\",{\"1\":{\"570\":1}}],[\"一个分区表就只是一个表\",{\"1\":{\"562\":1}}],[\"一个是在它的静态内部类head中\",{\"1\":{\"1499\":1}}],[\"一个是没有设置concurrent特性\",{\"1\":{\"1494\":1}}],[\"一个是并行流\",{\"1\":{\"1494\":1}}],[\"一个是间接找到对象\",{\"1\":{\"1438\":1}}],[\"一个是直接找到对象\",{\"1\":{\"1438\":1}}],[\"一个是代表\",{\"1\":{\"1438\":1}}],[\"一个是指向\",{\"1\":{\"1438\":1}}],[\"一个是仅检查终止标志位是不够的\",{\"1\":{\"1401\":1}}],[\"一个是必须配合sychronized使用\",{\"1\":{\"1354\":1}}],[\"一个是事件的描述\",{\"1\":{\"761\":1}}],[\"一个是事件的类型\",{\"1\":{\"761\":1}}],[\"一个是kill\",{\"1\":{\"617\":2}}],[\"一个是系统配置库\",{\"1\":{\"600\":1}}],[\"一个是第一次访问的时候需要访问所有分区\",{\"1\":{\"563\":1}}],[\"一个是由应用层代码决定使用哪个分表\",{\"1\":{\"561\":1}}],[\"一个是由server层来决定使用哪个分区\",{\"1\":{\"561\":1}}],[\"一个是double类型\",{\"1\":{\"557\":1}}],[\"一个是查找插入的位置\",{\"1\":{\"345\":1}}],[\"一个普通表的table\",{\"1\":{\"549\":1}}],[\"一个临时表只能被创建它的session访问\",{\"1\":{\"547\":1}}],[\"一个常见的错误是常常会误以为mysql只会返回需要的数据\",{\"1\":{\"520\":1}}],[\"一个一个地判断tradeid的值是否匹配\",{\"1\":{\"505\":1}}],[\"一个索引的选择性越接近于1\",{\"1\":{\"496\":1}}],[\"一个索引上不同的值越多\",{\"1\":{\"484\":1}}],[\"一个数据页就可以放近千个key\",{\"1\":{\"479\":1}}],[\"一个10亿行的表上一个整数字段的索引\",{\"1\":{\"471\":1}}],[\"一个或者多个\",{\"1\":{\"467\":1,\"708\":2}}],[\"一个系统的配置表\",{\"1\":{\"456\":1}}],[\"一个4结点要么没有孩子\",{\"1\":{\"348\":1}}],[\"一个4结点包含小中大三个元素和四个孩子\",{\"1\":{\"348\":1}}],[\"一个3结点要么没有孩子\",{\"1\":{\"347\":1}}],[\"一个3结点包含一小一大两个元素和三个孩子\",{\"1\":{\"347\":1}}],[\"一个2结点包含一个元素和两个孩子\",{\"1\":{\"347\":1}}],[\"一个对象从加载到jvm\",{\"0\":{\"110\":1}}],[\"贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确得问题\",{\"1\":{\"293\":1}}],[\"贪心法一般不能得到我们所求的答案\",{\"1\":{\"293\":1}}],[\"贪心法可以解决一些最优化问题\",{\"1\":{\"293\":1}}],[\"贪心算法可以从前往后\",{\"1\":{\"293\":1}}],[\"贪心算法与动态规划的不同在于它对于每个子问题的解决方案都做出选择\",{\"1\":{\"293\":1}}],[\"贪心算法是一种在每一步选择中都采取在当前状态下最好或最有\",{\"1\":{\"293\":1}}],[\"贪心算法\",{\"0\":{\"292\":1,\"418\":1},\"1\":{\"293\":1}}],[\"回复功能\",{\"1\":{\"1865\":1}}],[\"回复客户端\",{\"1\":{\"1451\":1}}],[\"回收算法\",{\"0\":{\"1627\":1}}],[\"回调函数\",{\"1\":{\"1470\":1}}],[\"回顾一下sychronized的唤醒策略\",{\"1\":{\"1372\":1}}],[\"回到刚才的例子当中\",{\"1\":{\"1499\":1}}],[\"回到一开始的例子当中\",{\"1\":{\"1499\":1}}],[\"回到stream类的定义\",{\"1\":{\"1496\":1}}],[\"回到线程1\",{\"1\":{\"718\":1}}],[\"回到主键索引树搜索的过程\",{\"1\":{\"474\":1}}],[\"回滚操作需要对事务执行期间生成的所有新数据版本做回收操作\",{\"1\":{\"618\":1}}],[\"回滚语句是rollback\",{\"1\":{\"572\":1}}],[\"回滚段被清理\",{\"1\":{\"571\":1}}],[\"回滚日志是跟字典一起放在ibdata文件里的\",{\"1\":{\"571\":1}}],[\"回滚日志只有当没有事务需要用到这些回滚日志\",{\"1\":{\"571\":1}}],[\"回帖的备注\",{\"1\":{\"498\":1}}],[\"回表操作得到的完整用户记录\",{\"1\":{\"686\":1}}],[\"回表操作得到的完成用户记录\",{\"1\":{\"686\":1}}],[\"回表过程只是简单根据数据行的位置\",{\"1\":{\"557\":1}}],[\"回表肯定是一行行搜索主键索引的\",{\"1\":{\"541\":1}}],[\"回表是指\",{\"1\":{\"541\":1}}],[\"回表了两次\",{\"1\":{\"474\":1}}],[\"回表\",{\"0\":{\"474\":1}}],[\"回退\",{\"1\":{\"293\":1}}],[\"回溯算法\",{\"0\":{\"414\":1}}],[\"回溯法的典型应用\",{\"1\":{\"290\":1}}],[\"回溯法会导致一次复杂度为指数时间的计算\",{\"1\":{\"290\":1}}],[\"回溯法通常用最简的递归方法来实现\",{\"1\":{\"290\":1}}],[\"回溯法采用试错的思想\",{\"1\":{\"290\":1}}],[\"回溯\",{\"0\":{\"289\":1},\"1\":{\"293\":1}}],[\"八皇后问题和数独\",{\"1\":{\"290\":1}}],[\"在面试之前将常考的题目解题思路和代码印在脑子里\",{\"1\":{\"1850\":1}}],[\"在面对其他任何编程语言的函数式编程时\",{\"1\":{\"1468\":1}}],[\"在容器中获取到的都是一个标准的servletrequest对象\",{\"1\":{\"1565\":1}}],[\"在容器的安全上\",{\"1\":{\"1431\":1}}],[\"在加载阶段会在内存中生成一个代表这个类的java\",{\"1\":{\"1540\":1}}],[\"在硬盘上查找并通过io读入字节码文件\",{\"1\":{\"1540\":1}}],[\"在解析的时候\",{\"1\":{\"1529\":1}}],[\"在类加载检查通过后\",{\"1\":{\"1544\":1}}],[\"在类似数组的数据结构里存放局部变量\",{\"1\":{\"1541\":1}}],[\"在类\",{\"1\":{\"1529\":1}}],[\"在推断构造方法之后\",{\"1\":{\"1527\":1}}],[\"在第二次调用getbean方法的时候就会触发\",{\"1\":{\"1525\":1}}],[\"在第一组事务提交完成的时候\",{\"1\":{\"601\":1}}],[\"在第一张图中\",{\"1\":{\"477\":1}}],[\"在属性或set方法上使用了\",{\"1\":{\"1525\":1}}],[\"在单例池中查找单例bean\",{\"1\":{\"1524\":1}}],[\"在如下配置中\",{\"1\":{\"1522\":2}}],[\"在hierarchicalbeanfactory和singletonbeanregistry的基础上\",{\"1\":{\"1513\":1}}],[\"在hashmap中会调用方法二来计算对象应该保存在table数组的哪个索引处\",{\"1\":{\"1425\":1}}],[\"在hashmap中\",{\"1\":{\"1423\":1}}],[\"在hashmap的底层存储实现上是存储在\",{\"1\":{\"1423\":1}}],[\"在可用的任意的顺序\",{\"1\":{\"1500\":1}}],[\"在可重复读隔离级别下\",{\"1\":{\"583\":1}}],[\"在可重复读的隔离级别下\",{\"1\":{\"570\":1,\"674\":1,\"679\":1}}],[\"在调用完end方法\",{\"1\":{\"1500\":1}}],[\"在所有的beandefinition找到符合这个类型的所有bean的名称\",{\"1\":{\"1525\":1}}],[\"在所有的数据发送完成之后\",{\"1\":{\"1500\":1}}],[\"在所有的元素都遍历之后\",{\"1\":{\"1497\":1}}],[\"在首次调用sink的accept之前必须先调用begin方法来通知数据即将到达\",{\"1\":{\"1500\":1}}],[\"在流消费之后都要置为空\",{\"1\":{\"1498\":1}}],[\"在流准备进行计算的时候是有效的\",{\"1\":{\"1498\":1}}],[\"在管道被消费之后\",{\"1\":{\"1498\":1}}],[\"在管道被消费之前\",{\"1\":{\"1498\":2}}],[\"在管程的发展史上\",{\"1\":{\"1360\":1}}],[\"在分割之前estimatesize方法所估算的元的大小的值\",{\"1\":{\"1497\":1}}],[\"在分布解决问题的过程中\",{\"1\":{\"290\":1}}],[\"在合适的时候应该被重写\",{\"1\":{\"1497\":1}}],[\"在当前的线程是以串行的方式执行\",{\"1\":{\"1497\":1}}],[\"在遍历开始之后无法分割\",{\"1\":{\"1497\":1}}],[\"在遍历的时候会自增\",{\"1\":{\"1497\":1}}],[\"在遍历已经开始之后就可能发生一些不确定的行为\",{\"1\":{\"1497\":1}}],[\"在构造之后增加不确定的行为的可能\",{\"1\":{\"1497\":1}}],[\"在正式开始介绍之前\",{\"1\":{\"1496\":1}}],[\"在正式进入stream源码分析之前\",{\"1\":{\"1491\":1}}],[\"在了解了分割迭代器的相关内容之后\",{\"1\":{\"1498\":1}}],[\"在了解了有关收集器的内容之后\",{\"1\":{\"1495\":1}}],[\"在了解mvcc多版本并发控制之前\",{\"1\":{\"678\":1}}],[\"在整个方法的返回类型中\",{\"1\":{\"1495\":1}}],[\"在整个过程中\",{\"1\":{\"487\":1}}],[\"在查看之前首先需要了解一个jdk中新增加的方法\",{\"1\":{\"1495\":1}}],[\"在查询时按照上面的规则查到对应的记录如果delete\",{\"1\":{\"679\":1}}],[\"在查询表optimizer\",{\"1\":{\"491\":1}}],[\"在运行期间\",{\"1\":{\"1494\":1}}],[\"在运行时调用任意一个对象的方法\",{\"1\":{\"1436\":1}}],[\"在运行时判断任意一个类所具有的成员变量和方法\",{\"1\":{\"1436\":1}}],[\"在运行时判断任意一个对象所属的类型\",{\"1\":{\"1436\":1}}],[\"在运行时构造任意一个类的对象\",{\"1\":{\"1436\":1}}],[\"在完整的理解了收集器相关的概念之后\",{\"1\":{\"1493\":1}}],[\"在完成这些任务的时候\",{\"1\":{\"518\":1}}],[\"在完成经典的tcp握手后\",{\"1\":{\"455\":1}}],[\"在每一个分区上执行这种汇聚操作\",{\"1\":{\"1492\":1}}],[\"在每个数组元素上都加上一个链表结构\",{\"1\":{\"1423\":1}}],[\"在每个事务修改完后\",{\"1\":{\"679\":1}}],[\"在每个树行中找最大值\",{\"0\":{\"404\":1}}],[\"在函数式编程中非常的常见\",{\"1\":{\"1491\":1}}],[\"在长时间的练习和记忆中\",{\"1\":{\"1490\":1}}],[\"在控制台输出了\",{\"1\":{\"1487\":1}}],[\"在控制层先进行拦截校验\",{\"1\":{\"764\":1}}],[\"在并行情况下使用spliterator\",{\"1\":{\"1497\":1}}],[\"在并行流中可能会多次调用\",{\"1\":{\"1485\":1}}],[\"在并发环境下同时修改\",{\"1\":{\"1396\":1}}],[\"在并发处理计算型任务时有着显著的优势\",{\"1\":{\"1391\":1}}],[\"在并发程度高的时候\",{\"1\":{\"1386\":1}}],[\"在并发场景下\",{\"1\":{\"588\":1}}],[\"在初步了解了sream给我们来了些什么之后\",{\"1\":{\"1485\":1}}],[\"在初始化的时候用户可能会自定义\",{\"1\":{\"1431\":1}}],[\"在接下来的章节中\",{\"1\":{\"1484\":1}}],[\"在前面的章节我们花费了不少的章节整理了lambda表达式的相关特性\",{\"1\":{\"1484\":1}}],[\"在前面我们了解了函数式接口的概念之后\",{\"1\":{\"1472\":1}}],[\"在方法引用的最后\",{\"1\":{\"1484\":1}}],[\"在此基础上\",{\"1\":{\"1477\":1}}],[\"在回答这个问题之前\",{\"1\":{\"1470\":1}}],[\"在回滚日志里面就会有类似下面的记录\",{\"1\":{\"571\":1}}],[\"在后续分析源码的时候就可以看到\",{\"1\":{\"1489\":1}}],[\"在后续的文章中\",{\"1\":{\"1470\":1}}],[\"在后面源代码分析的时候\",{\"1\":{\"1488\":1}}],[\"在后面的文章中\",{\"1\":{\"454\":1}}],[\"在创建线程方面可以简化写法\",{\"1\":{\"1468\":1}}],[\"在创建事务的一致性视图时\",{\"1\":{\"634\":1}}],[\"在以往的java中\",{\"1\":{\"1470\":1}}],[\"在以往的使用传统面向对象的编程中\",{\"1\":{\"1468\":1}}],[\"在以上的例子中\",{\"1\":{\"550\":1}}],[\"在linux系统中\",{\"1\":{\"1456\":1}}],[\"在linux\",{\"1\":{\"1453\":1,\"1459\":1}}],[\"在linux上一般为1024\",{\"1\":{\"1446\":1}}],[\"在linux操作系统中\",{\"1\":{\"1407\":1}}],[\"在io多路复用模型中\",{\"1\":{\"1442\":1}}],[\"在innodb逻辑里\",{\"1\":{\"632\":1}}],[\"在innodb事务中\",{\"1\":{\"580\":1}}],[\"在innodb里\",{\"1\":{\"472\":1,\"634\":1}}],[\"在innodb中\",{\"1\":{\"472\":2,\"479\":1,\"557\":1,\"581\":1,\"613\":1}}],[\"在程序设计中\",{\"1\":{\"1438\":1}}],[\"在程序设计语言里面\",{\"1\":{\"505\":1}}],[\"在底层就是在hashmap的基础上包了一层\",{\"1\":{\"1434\":1}}],[\"在存储结构上\",{\"1\":{\"1431\":1}}],[\"在存储引擎层执行具体的数据存取操作\",{\"1\":{\"694\":1}}],[\"在扩容的时候也是这样的\",{\"1\":{\"1430\":1}}],[\"在下图中\",{\"1\":{\"1427\":1}}],[\"在下次查询需要访问这个数据页的时候\",{\"1\":{\"480\":1}}],[\"在旧数组中同一条entry链上的元素\",{\"1\":{\"1427\":1}}],[\"在向hashmap对象中不断地添加元素\",{\"1\":{\"1427\":1}}],[\"在红黑树中执行插入操作\",{\"1\":{\"1426\":1}}],[\"在红黑树中最主要的有三种操作\",{\"1\":{\"343\":1}}],[\"在数组定义好长度之后\",{\"1\":{\"1423\":1}}],[\"在数据库中都是以key\",{\"1\":{\"706\":1}}],[\"在数据库中\",{\"1\":{\"670\":1}}],[\"在数据库中保存计数\",{\"0\":{\"535\":1}}],[\"在数据库里的最终结果还是\",{\"1\":{\"584\":1}}],[\"在数据库里面的结果是\",{\"1\":{\"584\":1}}],[\"在数据库里面\",{\"1\":{\"484\":1}}],[\"在数据库正常关闭\",{\"1\":{\"480\":1}}],[\"在其他编程语言中\",{\"1\":{\"1470\":1}}],[\"在其他编程语言里\",{\"1\":{\"1410\":1}}],[\"在其他条件都相同的时候\",{\"1\":{\"529\":1}}],[\"在循环内部使用thread\",{\"1\":{\"1397\":1}}],[\"在稳定性要求特别高的系统中\",{\"1\":{\"1396\":1}}],[\"在考虑这一点的时候\",{\"1\":{\"1386\":1}}],[\"在高并发场景下会成为性能瓶颈\",{\"1\":{\"1379\":1}}],[\"在它内部\",{\"1\":{\"1375\":2}}],[\"在读多写少的情况下\",{\"1\":{\"1375\":1}}],[\"在没有写操作的时候\",{\"1\":{\"1375\":1}}],[\"在发生异常时synchronized会自动释放锁\",{\"1\":{\"1372\":1}}],[\"在发生慢查询的时候\",{\"1\":{\"518\":1}}],[\"在项目启动时即可输出jvm的默认参数值\",{\"1\":{\"1362\":1}}],[\"在64位的操作系统的内存中占几8\",{\"1\":{\"1361\":1}}],[\"在获取锁时\",{\"1\":{\"1360\":1}}],[\"在操作系统领域一般翻译为\",{\"1\":{\"1360\":1}}],[\"在两种情况下会使用\",{\"1\":{\"1357\":1}}],[\"在两边插入或者改动值\",{\"1\":{\"708\":1}}],[\"在jdk中有很多的方法都可以采用方法引用的方式\",{\"1\":{\"1485\":1}}],[\"在jdk8中的提供了大量的现成的函数式接口供我们使用\",{\"1\":{\"1471\":1}}],[\"在jdk8中\",{\"1\":{\"1471\":1}}],[\"在jdk1\",{\"1\":{\"1423\":1,\"1425\":2,\"1427\":1,\"1430\":1,\"1449\":3,\"1470\":1}}],[\"在java环境中\",{\"1\":{\"1435\":1}}],[\"在java中表示匿名内部类会使用类名称+\",{\"1\":{\"1469\":1}}],[\"在java中的线程是一个重量级的对象\",{\"1\":{\"1410\":1}}],[\"在java中\",{\"1\":{\"1404\":1,\"1405\":1,\"1415\":1,\"1472\":1}}],[\"在java语言中使用两阶段终止模式来优雅地终止线程\",{\"1\":{\"1401\":1}}],[\"在java6之后自旋是自适应的\",{\"1\":{\"1362\":1}}],[\"在java1\",{\"1\":{\"1360\":1}}],[\"在java\",{\"1\":{\"1357\":1}}],[\"在join语句优化的章节中\",{\"1\":{\"546\":1}}],[\"在join\",{\"1\":{\"540\":2}}],[\"在多线程使用场景中\",{\"1\":{\"1428\":1}}],[\"在多线程开发中\",{\"1\":{\"1407\":1}}],[\"在多个线程对共享资源读写操作时发生指令交错\",{\"1\":{\"1359\":1}}],[\"在多个表负载均衡的场景里应用效果很好\",{\"1\":{\"598\":1}}],[\"在多处理器环境下\",{\"1\":{\"1356\":1}}],[\"在各单个线程访问时的排他性\",{\"1\":{\"1354\":1}}],[\"在各个分库上执行select\",{\"1\":{\"548\":1}}],[\"在共享内存多处理器系统中\",{\"1\":{\"1351\":1}}],[\"在新的处理器中\",{\"1\":{\"1350\":1}}],[\"在新主库a\",{\"1\":{\"604\":1}}],[\"在变量被修改后\",{\"1\":{\"1350\":1}}],[\"在变量读取前从主内存刷新变量值这种依赖主内存作为传递没接的方法来实现可见性的\",{\"1\":{\"1348\":1}}],[\"在即将发生大并发访问前手动触发加载缓存不同的key\",{\"1\":{\"770\":1}}],[\"在缓存失效后\",{\"1\":{\"770\":1}}],[\"在缓存过期的一刻\",{\"1\":{\"766\":1}}],[\"在访问key之前\",{\"1\":{\"767\":1}}],[\"在访问一个表的时候会被自动加上\",{\"1\":{\"578\":1}}],[\"在默认情况下\",{\"1\":{\"763\":1}}],[\"在线程池中使用threadlocal\",{\"1\":{\"1405\":1}}],[\"在线程进入锁等待以后\",{\"1\":{\"613\":1}}],[\"在线扩容就十分麻烦\",{\"1\":{\"761\":1}}],[\"在主从复制的基础上\",{\"1\":{\"744\":1}}],[\"在主库更新后\",{\"1\":{\"608\":1}}],[\"在主库上\",{\"1\":{\"601\":1}}],[\"在主库和备库上的执行顺序相反\",{\"1\":{\"597\":1}}],[\"在主库和备库是无差别的\",{\"1\":{\"594\":1}}],[\"在主库故障的时候\",{\"1\":{\"596\":1}}],[\"在主库执行这条sql语句的时候\",{\"1\":{\"591\":1}}],[\"在从前的版本中\",{\"1\":{\"738\":1}}],[\"在从库上执行select\",{\"1\":{\"610\":1,\"611\":1}}],[\"在从库上执行查询请求\",{\"1\":{\"609\":1}}],[\"在从库b上执行change\",{\"1\":{\"604\":1}}],[\"在从库b上\",{\"1\":{\"604\":1}}],[\"在网络中传输的对象也是一样需要序列化\",{\"1\":{\"720\":1}}],[\"在网络正常的时候\",{\"1\":{\"594\":1}}],[\"在做好redis相关的配置并启动后就可以进行测试\",{\"1\":{\"719\":1}}],[\"在输入元素的数量或者体积非常非常大时\",{\"1\":{\"714\":1}}],[\"在大多数场景下可以与\",{\"1\":{\"1521\":1}}],[\"在大多数情况下都是一种无状态的操作\",{\"1\":{\"1496\":1}}],[\"在大多数情况下\",{\"1\":{\"1362\":1}}],[\"在大部分的情况下\",{\"1\":{\"729\":1}}],[\"在大量数据环境下\",{\"1\":{\"709\":1}}],[\"在大批量插入数据的情况下\",{\"1\":{\"629\":1}}],[\"在k2元素后\",{\"1\":{\"708\":1}}],[\"在k索引树取下一个值k=6\",{\"1\":{\"474\":1}}],[\"在k索引树取下一个值k=5\",{\"1\":{\"474\":1}}],[\"在k索引树上找到k=3的记录\",{\"1\":{\"474\":1}}],[\"在表中索引多或者采样页面也别多的时候\",{\"1\":{\"696\":1}}],[\"在表t的ftime索引上\",{\"1\":{\"561\":1}}],[\"在表t的ftime索引\",{\"1\":{\"561\":1}}],[\"在表t2的字段b上创建索引会浪费资源\",{\"1\":{\"544\":1}}],[\"在表t2中插入了100万行数据\",{\"1\":{\"541\":1}}],[\"在表t1里\",{\"1\":{\"541\":1}}],[\"在表t1插入的是100行数据\",{\"1\":{\"537\":1}}],[\"在计算某些索引列中包含多少不重复值时\",{\"1\":{\"695\":1}}],[\"在计算连接顺序bca时\",{\"1\":{\"693\":1}}],[\"在计算机中表现为指令的有限序列\",{\"1\":{\"282\":1}}],[\"在和全文扫描比较成本时\",{\"1\":{\"688\":1}}],[\"在通过二级索引获取到记录之后\",{\"1\":{\"686\":1}}],[\"在进行collector源码分析的时候\",{\"1\":{\"1494\":1}}],[\"在进行链表或者红黑树操作时\",{\"1\":{\"1431\":1}}],[\"在进行检索时\",{\"1\":{\"667\":1}}],[\"在进入引擎之前排队\",{\"1\":{\"581\":1}}],[\"在达到上限后的表现也不同\",{\"1\":{\"636\":1}}],[\"在17\",{\"1\":{\"634\":1}}],[\"在理论上还是可能出现一个读写事务于一个只读事务显示trx\",{\"1\":{\"634\":1}}],[\"在同一个数据库实例中\",{\"1\":{\"633\":1}}],[\"在代码实现时row\",{\"1\":{\"632\":1}}],[\"在代码上就是通过多版本并发控制\",{\"1\":{\"533\":1}}],[\"在生产者\",{\"1\":{\"1379\":1}}],[\"在生产上\",{\"1\":{\"629\":1}}],[\"在生产环境中\",{\"1\":{\"566\":1}}],[\"在申请自增值的时候\",{\"1\":{\"628\":1}}],[\"在删除数据表之前\",{\"1\":{\"624\":1}}],[\"在备份之后的第6天发生误操作\",{\"1\":{\"623\":1}}],[\"在备库执行binlog完成\",{\"1\":{\"609\":1}}],[\"在备库执行的时候\",{\"1\":{\"602\":1}}],[\"在备库执行时也是可以并行的\",{\"1\":{\"602\":1}}],[\"在备库执行时时可以并行的\",{\"1\":{\"602\":1}}],[\"在备库执行完成的时间和主库执行完成的时间之间的差值\",{\"1\":{\"594\":1}}],[\"在备库上执行的时候\",{\"1\":{\"601\":1}}],[\"在备库b上执行start\",{\"1\":{\"590\":1}}],[\"在备库b上通过change\",{\"1\":{\"590\":1}}],[\"在备库的table\",{\"1\":{\"550\":2}}],[\"在备库的应用线程就能够知道执行每个语句的主库线程id\",{\"1\":{\"550\":1}}],[\"在文件开头加入两行\",{\"1\":{\"622\":1}}],[\"在文件管理\",{\"1\":{\"562\":1}}],[\"在用备份恢复出临时实例之后\",{\"1\":{\"622\":1}}],[\"在用户评论的地方需要查询用户头像的url\",{\"1\":{\"523\":1}}],[\"在function接口中\",{\"1\":{\"1475\":1}}],[\"在file\",{\"1\":{\"616\":1}}],[\"在from子句中包含的子查询被标记为derived\",{\"1\":{\"467\":1}}],[\"在系统库\",{\"1\":{\"614\":1}}],[\"在等位点的方案中\",{\"1\":{\"611\":1}}],[\"在持续延迟的情况下\",{\"1\":{\"609\":1}}],[\"在引入gtid之后\",{\"1\":{\"605\":1}}],[\"在引擎层\",{\"1\":{\"562\":1}}],[\"在引擎内部使用覆盖索引在索引k上其实读了三条记录\",{\"1\":{\"475\":1}}],[\"在引擎内部扫描了多行\",{\"1\":{\"459\":1}}],[\"在基于gtid的主备关系里\",{\"1\":{\"605\":1}}],[\"在gtid模式下\",{\"1\":{\"605\":2}}],[\"在切换任务的时候\",{\"1\":{\"604\":1}}],[\"在registerbeandefinitions方法中定义了一个classpathmapperscanner对象\",{\"1\":{\"1530\":1}}],[\"在referencepipeline当中\",{\"1\":{\"1499\":1}}],[\"在redistemplate上也有一个条件注解\",{\"1\":{\"720\":1}}],[\"在redis中无论什么数据类型\",{\"1\":{\"706\":1}}],[\"在redo\",{\"1\":{\"602\":1,\"616\":1}}],[\"在row格式下\",{\"1\":{\"591\":1}}],[\"在root的子树中\",{\"1\":{\"398\":1}}],[\"在决定分发策略的哈希表中\",{\"1\":{\"600\":1}}],[\"在决定哪个表做驱动表的时候\",{\"1\":{\"540\":1}}],[\"在上面排序的例子中可以看到\",{\"1\":{\"1484\":1}}],[\"在上面的文档中\",{\"1\":{\"1471\":1}}],[\"在上面的这个语句序列中\",{\"1\":{\"605\":1}}],[\"在上面的例子中\",{\"1\":{\"527\":1}}],[\"在上面这个例子中\",{\"1\":{\"599\":1,\"642\":1}}],[\"在满足数据可靠性的前提下\",{\"1\":{\"596\":1}}],[\"在插入一行数据的时候\",{\"1\":{\"628\":1}}],[\"在插入一条c=4的语句后\",{\"1\":{\"596\":1}}],[\"在插入新值的时候需要做必要的维护\",{\"1\":{\"472\":1}}],[\"在双m的结构下\",{\"1\":{\"595\":1}}],[\"在真正执行的delete命令之前\",{\"1\":{\"591\":1}}],[\"在状态1中\",{\"1\":{\"590\":2}}],[\"在出现io瓶颈的场景里\",{\"1\":{\"587\":1}}],[\"在一段时间内只允许一个线程访问的资源就称为临界资源\",{\"1\":{\"1354\":1}}],[\"在一条单表查询语句真正执行之前\",{\"1\":{\"683\":1}}],[\"在一些场景下\",{\"1\":{\"628\":1}}],[\"在一主多从的场景中国呢\",{\"1\":{\"609\":1}}],[\"在一主多从的架构下\",{\"1\":{\"603\":1}}],[\"在一个页面中统计两条记录之间有几条记录的成本就很小了\",{\"1\":{\"686\":1}}],[\"在一个交易平台上\",{\"1\":{\"607\":1}}],[\"在一个市民信息表上\",{\"1\":{\"475\":1}}],[\"在一组里面一起提交的事务\",{\"1\":{\"601\":1}}],[\"在一行行扫描的过程中\",{\"1\":{\"585\":1}}],[\"在trysplit调用之前和调用当中重复地调用这个方法\",{\"1\":{\"1497\":1}}],[\"在t3时刻\",{\"1\":{\"634\":1}}],[\"在t1时刻\",{\"1\":{\"634\":2}}],[\"在t时刻写入新的binlog的位置\",{\"1\":{\"604\":1}}],[\"在t4时刻\",{\"1\":{\"583\":1}}],[\"在t2时刻\",{\"1\":{\"583\":1,\"634\":1}}],[\"在a\",{\"1\":{\"604\":1}}],[\"在alter\",{\"1\":{\"578\":1}}],[\"在autocommit为1的情况下\",{\"1\":{\"572\":1}}],[\"在给小表加字段的时候\",{\"1\":{\"578\":1}}],[\"在语句执行开始时申请\",{\"1\":{\"578\":1}}],[\"在异常处理机制上有差异\",{\"1\":{\"575\":1}}],[\"在视图a\",{\"1\":{\"571\":1}}],[\"在\",{\"1\":{\"565\":1,\"570\":2,\"591\":1,\"1460\":1,\"1461\":1,\"1534\":2}}],[\"在使用传统jdbc时\",{\"1\":{\"1860\":1}}],[\"在使用这个代理对象的方法的时候才会去创建属性的实例对象\",{\"1\":{\"1526\":1}}],[\"在使用java\",{\"1\":{\"1497\":1}}],[\"在使用并行流的时候\",{\"1\":{\"1494\":1}}],[\"在使用treemao的时候\",{\"1\":{\"1421\":1}}],[\"在使用不可变性模式的时候一定要确认保持不变性的边界在哪里\",{\"1\":{\"1403\":1}}],[\"在使用不变性模式的时候\",{\"1\":{\"1403\":1}}],[\"在使用kill命令的时候\",{\"1\":{\"617\":1}}],[\"在使用binlog恢复数据的时候\",{\"1\":{\"591\":1}}],[\"在使用之前预先创建即可\",{\"1\":{\"563\":1}}],[\"在使用create\",{\"1\":{\"454\":1}}],[\"在性能上\",{\"1\":{\"561\":1}}],[\"在应用日志的时候\",{\"1\":{\"622\":1}}],[\"在应用代码里面取\",{\"1\":{\"559\":1}}],[\"在应用层做关联查询\",{\"1\":{\"531\":1}}],[\"在应用层做关联\",{\"1\":{\"531\":1}}],[\"在我们之前的所有的例子当中\",{\"1\":{\"1491\":1}}],[\"在我们构造的堆里面\",{\"1\":{\"558\":1}}],[\"在我们这个例子中\",{\"1\":{\"477\":1}}],[\"在spring中\",{\"1\":{\"1531\":1}}],[\"在spring中需要去解析类的信息\",{\"1\":{\"1523\":1}}],[\"在spring的扫描逻辑中\",{\"1\":{\"1522\":1}}],[\"在spring内部使用\",{\"1\":{\"1517\":1}}],[\"在spring源码中\",{\"1\":{\"1515\":1}}],[\"在student类中\",{\"1\":{\"1482\":1}}],[\"在start\",{\"1\":{\"622\":1}}],[\"在sunion的基础上\",{\"1\":{\"709\":1}}],[\"在sinter的基础上\",{\"1\":{\"709\":1}}],[\"在sdiff的基础上\",{\"1\":{\"709\":1}}],[\"在sort\",{\"1\":{\"557\":1}}],[\"在selector上注册通道\",{\"1\":{\"1451\":2}}],[\"在select或者where子句中包含了子查询\",{\"1\":{\"467\":1}}],[\"在server层\",{\"1\":{\"562\":1}}],[\"在session\",{\"1\":{\"561\":1,\"613\":1}}],[\"在sessoin结束的时候\",{\"1\":{\"549\":1}}],[\"在优化group\",{\"1\":{\"554\":1}}],[\"在实践中\",{\"1\":{\"1351\":1}}],[\"在实现等行锁时\",{\"1\":{\"618\":1}}],[\"在实现上\",{\"1\":{\"549\":1,\"570\":1}}],[\"在实例a\",{\"1\":{\"605\":1}}],[\"在实际生产项目中会有些极端的情况\",{\"1\":{\"1413\":1}}],[\"在实际生产中\",{\"1\":{\"537\":1}}],[\"在实际使用中\",{\"1\":{\"619\":1,\"1470\":1}}],[\"在实际的应用中\",{\"1\":{\"1458\":1}}],[\"在实际的业务场景中\",{\"1\":{\"587\":1}}],[\"在实际的开发中\",{\"1\":{\"532\":1}}],[\"在实际工程中\",{\"1\":{\"337\":1}}],[\"在磁盘上的文件不会重名\",{\"1\":{\"549\":1}}],[\"在5\",{\"1\":{\"549\":1,\"597\":1}}],[\"在汇总库上创建一个临时表temp\",{\"1\":{\"548\":1}}],[\"在put方法中\",{\"1\":{\"1430\":1}}],[\"在pentium及之前的处理器中\",{\"1\":{\"1350\":1}}],[\"在proxyfactory筛选代理对象的被代理的方法\",{\"1\":{\"1531\":1}}],[\"在proxy这一层解析完sql语句以后\",{\"1\":{\"548\":1}}],[\"在prepare阶段\",{\"1\":{\"588\":1}}],[\"在phone表上创建索引\",{\"1\":{\"500\":1}}],[\"在业务不断发展的过程中\",{\"1\":{\"603\":1}}],[\"在业务端存入到哈希这种数据结构的实现\",{\"1\":{\"545\":1}}],[\"在业务端实现\",{\"1\":{\"545\":1}}],[\"在业务开发中\",{\"1\":{\"486\":1}}],[\"在判断要不要使用join语句时\",{\"1\":{\"540\":1}}],[\"在n确定的情况下\",{\"1\":{\"540\":1}}],[\"在n+λ\",{\"1\":{\"540\":1}}],[\"在mapperfactorybean中的getobject方法中\",{\"1\":{\"1530\":1}}],[\"在mariadb实现了并行复制之后\",{\"1\":{\"602\":1}}],[\"在mod\",{\"1\":{\"1427\":1}}],[\"在m和n大小确定的情况下\",{\"1\":{\"540\":1}}],[\"在mysql的实际计算中\",{\"1\":{\"688\":1}}],[\"在mysql的information\",{\"1\":{\"578\":1}}],[\"在mysql数据类型设置方面\",{\"1\":{\"664\":1}}],[\"在mysql里面\",{\"1\":{\"628\":1}}],[\"在mysql8\",{\"1\":{\"627\":1}}],[\"在mysql和客户端之间有一个中间代理层proxy\",{\"1\":{\"606\":1}}],[\"在mysql5\",{\"1\":{\"554\":1,\"571\":1,\"578\":1,\"600\":1,\"602\":3,\"616\":1,\"627\":1,\"629\":2,\"655\":1,\"681\":2,\"695\":1}}],[\"在mysql\",{\"1\":{\"477\":1,\"686\":1,\"691\":2}}],[\"在mysql中有两个kill命令\",{\"1\":{\"617\":1}}],[\"在mysql中有四种类型的行锁\",{\"1\":{\"579\":1}}],[\"在mysql中有很多看上去逻辑相同\",{\"1\":{\"502\":1}}],[\"在mysql中是支持前缀索引的\",{\"1\":{\"487\":1}}],[\"在mysql中\",{\"1\":{\"471\":1,\"484\":1,\"493\":1,\"569\":1,\"571\":1,\"664\":1}}],[\"在形式上\",{\"1\":{\"538\":1}}],[\"在保证逻辑正确的前题下\",{\"1\":{\"533\":1}}],[\"在最终构造返回的accumulator的时候\",{\"1\":{\"1495\":1}}],[\"在最后的同一个时刻\",{\"1\":{\"533\":1}}],[\"在最坏的情况下\",{\"1\":{\"290\":1}}],[\"在很多场景下\",{\"1\":{\"531\":1}}],[\"在某一个线程b被阻塞或者执行其他操作时\",{\"1\":{\"1408\":1}}],[\"在某些适当的场景下才会重新收集这些统计数据\",{\"1\":{\"695\":1}}],[\"在某些从库执行查询请求会存在过期读的现象\",{\"1\":{\"609\":1}}],[\"在某些版本的mysql上\",{\"1\":{\"529\":1}}],[\"在某个数据页上做了什么修改\",{\"1\":{\"462\":1}}],[\"在返回一个小的查询结果方面很高效\",{\"1\":{\"529\":1}}],[\"在传统的实现中\",{\"1\":{\"529\":1}}],[\"在传入7的时候已经无法定位记录了\",{\"1\":{\"503\":1}}],[\"在extra字段里面\",{\"1\":{\"553\":1}}],[\"在extra列中出现using\",{\"1\":{\"527\":1}}],[\"在extra列中出现了using\",{\"1\":{\"527\":1}}],[\"在explain语句中的type列反映了访问类型\",{\"1\":{\"527\":1}}],[\"在索引中使用where条件来过滤不匹配的记录\",{\"1\":{\"527\":1}}],[\"在索引列上进行计算\",{\"1\":{\"508\":1}}],[\"在评估查询开销的时候\",{\"1\":{\"527\":1}}],[\"在确定查询只返回需要的数据以后\",{\"1\":{\"524\":1}}],[\"在选择复合索引的时候\",{\"1\":{\"517\":2}}],[\"在写sql的不要使用select\",{\"1\":{\"510\":1}}],[\"在排序的过程中还是按照实际长度来分配空间的\",{\"1\":{\"491\":1}}],[\"在示例表中有4000条满足city=\",{\"1\":{\"491\":1}}],[\"在concurrenthashmap中不允许key\",{\"1\":{\"1431\":1}}],[\"在class表中有idx\",{\"1\":{\"499\":1}}],[\"在class表创建索引\",{\"1\":{\"499\":1}}],[\"在city字段上创建索引之后\",{\"1\":{\"491\":1}}],[\"在cpu消耗方面\",{\"1\":{\"489\":1}}],[\"在开发应用的时候\",{\"1\":{\"490\":1}}],[\"在开始执行之前\",{\"1\":{\"458\":1,\"651\":1}}],[\"在有了前面的基础之后\",{\"1\":{\"1495\":1}}],[\"在有序集合中计算指定字典区间内成员数量\",{\"1\":{\"711\":1}}],[\"在有序表中\",{\"1\":{\"304\":1}}],[\"在有些系统中\",{\"1\":{\"575\":1}}],[\"在有些公司的数据库规范中\",{\"1\":{\"560\":1}}],[\"在有些场景下\",{\"1\":{\"485\":1}}],[\"在不断的实践中\",{\"1\":{\"1484\":1}}],[\"在不同场景使用不同的排序模式\",{\"1\":{\"657\":1}}],[\"在不同的隔离级别下\",{\"1\":{\"570\":1}}],[\"在不同的mysql版本中有着不同的处理方式\",{\"1\":{\"549\":1}}],[\"在不同的mysql引擎中\",{\"1\":{\"533\":1}}],[\"在不允许过期读的要求下\",{\"1\":{\"610\":1}}],[\"在不影响数据一致性的前提下\",{\"1\":{\"480\":1}}],[\"在不损失精度的情况下\",{\"1\":{\"467\":1}}],[\"在beanfactory的基础上\",{\"1\":{\"1513\":3}}],[\"在bifunction中\",{\"1\":{\"1478\":1}}],[\"在bifunction中只有一个默认方法andthen\",{\"1\":{\"1475\":1}}],[\"在bitmap上可执行and\",{\"1\":{\"715\":1}}],[\"在binlog里面把插入数据的操作都如实记录进来\",{\"1\":{\"629\":1}}],[\"在binlog里面记录了整行的数据修改前各个字段的值\",{\"1\":{\"599\":1}}],[\"在binlog里面\",{\"1\":{\"584\":1}}],[\"在book表中有idx\",{\"1\":{\"499\":1}}],[\"在book表创建索引\",{\"1\":{\"499\":1,\"500\":1}}],[\"在b+树这种索引结构中\",{\"1\":{\"476\":1}}],[\"在b树中\",{\"1\":{\"350\":1}}],[\"在建立联合索引的时候\",{\"1\":{\"476\":1}}],[\"在建立冗余索引来支持索引覆盖时就需要权衡考虑了\",{\"1\":{\"475\":1}}],[\"在建表语句中一般是这么定义的\",{\"1\":{\"472\":1}}],[\"在这里被第一次调用\",{\"1\":{\"1494\":1}}],[\"在这里被第二次调用\",{\"1\":{\"1494\":1}}],[\"在这里的意思是把输入的字符串转成utf8mb4字符集\",{\"1\":{\"505\":1}}],[\"在这段代码中\",{\"1\":{\"1484\":1}}],[\"在这行数据中取到关联字段\",{\"1\":{\"661\":1}}],[\"在这之后\",{\"1\":{\"628\":1}}],[\"在这两个方法中都接受一个consumer<\",{\"1\":{\"1470\":1}}],[\"在这两个条件都具备的情况下\",{\"1\":{\"622\":1}}],[\"在这两个图里面\",{\"1\":{\"477\":1}}],[\"在这些操作中\",{\"1\":{\"619\":1}}],[\"在这些买点的地方判断线程状态\",{\"1\":{\"618\":1}}],[\"在这棵树上\",{\"1\":{\"541\":1}}],[\"在这条语句里\",{\"1\":{\"538\":1}}],[\"在这个场景下\",{\"1\":{\"1480\":1}}],[\"在这个接口中\",{\"1\":{\"1471\":1}}],[\"在这个空表里面执行insert\",{\"1\":{\"627\":1}}],[\"在这个临时库上执行这些操作\",{\"1\":{\"621\":1}}],[\"在这个交易平台上\",{\"1\":{\"607\":1}}],[\"在这个不可用状态中\",{\"1\":{\"595\":1}}],[\"在这个例子当中\",{\"1\":{\"1491\":1,\"1496\":1}}],[\"在这个例子里\",{\"1\":{\"591\":1}}],[\"在这个例子中\",{\"1\":{\"474\":1,\"485\":2,\"493\":1,\"503\":1,\"531\":1,\"613\":2,\"618\":1,\"629\":1}}],[\"在这个架构中\",{\"1\":{\"548\":1}}],[\"在这个算法里\",{\"1\":{\"540\":1}}],[\"在这个join语句的执行过程中\",{\"1\":{\"538\":1}}],[\"在这个查询过程\",{\"1\":{\"538\":1}}],[\"在这个查询里面\",{\"1\":{\"475\":1}}],[\"在这个流程里\",{\"1\":{\"538\":1}}],[\"在这个语句里\",{\"1\":{\"538\":1}}],[\"在这个索引里面\",{\"1\":{\"493\":1}}],[\"在这个过程中会使用大量synchronized关键字对对象加锁\",{\"1\":{\"1362\":1}}],[\"在这个过程中\",{\"1\":{\"474\":1,\"487\":1,\"540\":1,\"580\":1}}],[\"在这种情况下\",{\"1\":{\"472\":1,\"1482\":1}}],[\"在这类问题中\",{\"1\":{\"435\":1}}],[\"在需要更新数据的时候就麻烦了\",{\"1\":{\"470\":1}}],[\"在之前的这个例子中\",{\"1\":{\"1471\":1}}],[\"在之前的例子中\",{\"1\":{\"457\":1,\"545\":1,\"1482\":1}}],[\"在之后用binlog来恢复的时候就多了一个事务出来\",{\"1\":{\"464\":1}}],[\"在执行到它们之后的第一个修改innodb操作的语句\",{\"1\":{\"679\":1}}],[\"在执行update\",{\"1\":{\"672\":1}}],[\"在执行过程中\",{\"1\":{\"634\":1}}],[\"在执行查询请求之前\",{\"1\":{\"609\":1}}],[\"在执行主备切换时\",{\"1\":{\"604\":1}}],[\"在执行图5中第4步把binlog\",{\"1\":{\"588\":1}}],[\"在执行select\",{\"1\":{\"585\":1}}],[\"在执行流程过程中客户端发生了异常断开\",{\"1\":{\"547\":1}}],[\"在执行第三步的时候\",{\"1\":{\"505\":1}}],[\"在执行create\",{\"1\":{\"454\":1}}],[\"在执行下面这个查询语句时\",{\"1\":{\"454\":1}}],[\"在二叉树的层次遍历上稍做改动\",{\"1\":{\"402\":1,\"403\":1}}],[\"在堆排序算法中用于降序排列\",{\"1\":{\"321\":1}}],[\"在堆排序算法中用于升序排列\",{\"1\":{\"321\":1}}],[\"在剩下的元素中找到最小的元素\",{\"1\":{\"318\":1}}],[\"在布隆过滤器中是可以共用这个标记位的\",{\"1\":{\"307\":1}}],[\"在尝试了所有可能的分布方法后宣告该问题没有答案\",{\"1\":{\"290\":1}}],[\"在反复重复上述的步骤后可能出现两种情况\",{\"1\":{\"290\":1}}],[\"它利用\",{\"1\":{\"1867\":1}}],[\"它基于项目对象模型\",{\"1\":{\"1858\":1}}],[\"它负责加载servlet类\",{\"1\":{\"1571\":1}}],[\"它又定义了另外三个bean\",{\"1\":{\"1532\":1}}],[\"它存储在单例池中\",{\"1\":{\"1524\":1}}],[\"它比propertyeditor更加强大\",{\"1\":{\"1516\":1}}],[\"它比datetime更节约空间\",{\"1\":{\"666\":1}}],[\"它能解析的注解有\",{\"1\":{\"1510\":1}}],[\"它封装了一个流源和0个或者多个中间操作\",{\"1\":{\"1498\":1}}],[\"它与流的操作息息相关\",{\"1\":{\"1498\":1}}],[\"它描述了对于分割子任务的分割方法\",{\"1\":{\"1497\":1}}],[\"它对应的spliterator会忽略掉标签\",{\"1\":{\"1497\":1}}],[\"它对应的cardinality值是10225\",{\"1\":{\"690\":1}}],[\"它绝大部分的方法都是静态方法\",{\"1\":{\"1493\":1}}],[\"它要满足combiner\",{\"1\":{\"1492\":1}}],[\"它支持自定义\",{\"1\":{\"1860\":1}}],[\"它支持使用注解\",{\"1\":{\"1518\":1}}],[\"它支持串行与并行两种方式执行\",{\"1\":{\"1492\":1}}],[\"它支持字符串\",{\"1\":{\"705\":1}}],[\"它本身持有了元数据集合的引用\",{\"1\":{\"1498\":1}}],[\"它本身又调用一个重载的方法\",{\"1\":{\"1495\":1}}],[\"它本身接收一个参数叫做collector\",{\"1\":{\"1492\":1}}],[\"它本质上是一种copy\",{\"1\":{\"1404\":1}}],[\"它返回一个字典顺序的比较器\",{\"1\":{\"1491\":1}}],[\"它接受一个supplier参数\",{\"1\":{\"1486\":1}}],[\"它必须和accumulator\",{\"1\":{\"1485\":1}}],[\"它必须满足下面的性质\",{\"1\":{\"343\":1}}],[\"它每次被调用的时候无需保证返回不同的结果\",{\"1\":{\"1477\":1}}],[\"它总是返回输入的变量\",{\"1\":{\"1475\":1}}],[\"它取决于调用这个怎么去处理这个异常\",{\"1\":{\"1475\":1}}],[\"它满足函数式接口的定义\",{\"1\":{\"1472\":1}}],[\"它并不算数\",{\"1\":{\"1471\":1}}],[\"它并没有实现\",{\"1\":{\"601\":1}}],[\"它使用java语言规范定义\",{\"1\":{\"1471\":1}}],[\"它使用起来可能在形式上略有差异\",{\"1\":{\"740\":1}}],[\"它允许把函数\",{\"1\":{\"1470\":1}}],[\"它还调用了finisher方法\",{\"1\":{\"1495\":1}}],[\"它还可以为我们带来代码执行效率上的提升\",{\"1\":{\"1469\":1}}],[\"它还会尝试使用一种称为轻量级锁的优化手段\",{\"1\":{\"1362\":1}}],[\"它还会和其他sentinel节点进行\",{\"1\":{\"758\":1}}],[\"它表示要对于流中每个元素都执行action操作\",{\"1\":{\"1499\":1}}],[\"它表示将流中元素的界限打破\",{\"1\":{\"1486\":1}}],[\"它表示当前对象指的是lambdatest$1\",{\"1\":{\"1469\":1}}],[\"它表示拷贝数据的次数为0\",{\"1\":{\"1453\":1}}],[\"它将数据从磁盘读取到\",{\"1\":{\"1461\":1}}],[\"它将取消上一步甚至是上几步的计算\",{\"1\":{\"290\":1}}],[\"它提供了高速\",{\"1\":{\"1451\":1}}],[\"它发起一个read操作后\",{\"1\":{\"1441\":1}}],[\"它继承自dictionary类\",{\"1\":{\"1421\":1}}],[\"它根据键的hashcode值缓存数据\",{\"1\":{\"1421\":1}}],[\"它会接收pipelinehelper输出类型的元素\",{\"1\":{\"1500\":1}}],[\"它会接收一个流作为输入\",{\"1\":{\"1500\":1}}],[\"它会接收一个sink作为当前操作的结果\",{\"1\":{\"1500\":1}}],[\"它会在一个地方捕获关于流管道的所有信息\",{\"1\":{\"1500\":1}}],[\"它会计算一个流福安到并且将结果发送给自身作为一个terminalsink\",{\"1\":{\"1500\":1}}],[\"它会管理流管道的构建以及计算\",{\"1\":{\"1498\":1}}],[\"它会估算父亲节点的元素的一般\",{\"1\":{\"1497\":1}}],[\"它会恰好就元素分成等量的两部分\",{\"1\":{\"1497\":1}}],[\"它会使用try\",{\"1\":{\"1496\":1}}],[\"它会考虑到顺序上的区别带来的不相等性\",{\"1\":{\"1492\":1}}],[\"它会根据定义好的排序规则\",{\"1\":{\"1480\":1}}],[\"它会经历两个阶段\",{\"1\":{\"1438\":1}}],[\"它会从队列里取出来将要执行的具体任务\",{\"1\":{\"1378\":1}}],[\"它会首先比较\",{\"1\":{\"1356\":1}}],[\"它也会扫描成为一个bean\",{\"1\":{\"1522\":1}}],[\"它也有两个重载的方法\",{\"1\":{\"1495\":1}}],[\"它也是基于aqs来实现的\",{\"1\":{\"1373\":1}}],[\"它也要把字符串\",{\"1\":{\"457\":1}}],[\"它可能会有副作用\",{\"1\":{\"1474\":1}}],[\"它可能被外部方法所引用\",{\"1\":{\"1365\":1}}],[\"它可以快速地储存\",{\"1\":{\"1864\":1}}],[\"它可以管理项目的构建\",{\"1\":{\"1858\":1}}],[\"它可以为service内所有组件提供线程池执行任务\",{\"1\":{\"1564\":1}}],[\"它可以扫描某个包路径\",{\"1\":{\"1512\":1}}],[\"它可以将返回的spliterator交由另一个线程接管\",{\"1\":{\"1497\":1}}],[\"它可以被看成是一种对于流元的查询\",{\"1\":{\"1496\":1}}],[\"它可以提供更好的并发的性能\",{\"1\":{\"1495\":1}}],[\"它可以提高相同代码片段的复用性\",{\"1\":{\"522\":1}}],[\"它可以通过不同的枚举值来提高并发流的执行效率\",{\"1\":{\"1492\":1}}],[\"它可以在所有的元素都处理完毕后\",{\"1\":{\"1492\":1}}],[\"它可以看成是lambda表达式的一种语法糖\",{\"1\":{\"1479\":1}}],[\"它可以直接从内核空间缓冲区中将数据读取到网卡\",{\"1\":{\"1460\":1}}],[\"它可以访问受保护的内核空间\",{\"1\":{\"1456\":1}}],[\"它可以高频请求上用到覆盖索引\",{\"1\":{\"475\":1}}],[\"它通过h\",{\"1\":{\"1425\":1}}],[\"它通过把关键码值映射到表中一个位置来访问记录\",{\"1\":{\"332\":1}}],[\"它通常在缓存块的粒度上执行\",{\"1\":{\"1351\":1}}],[\"它把store操作从工作内存中一个变量的值传送到主内存的变量中\",{\"1\":{\"1350\":1}}],[\"它把一个从执行引擎接收到的值赋值给工作内存的变量\",{\"1\":{\"1350\":1}}],[\"它把read操作从主内存中得到的变量值放入工作内存的变量副本中\",{\"1\":{\"1350\":1}}],[\"它都有\",{\"1\":{\"760\":1}}],[\"它认为每次回表操作都相当于访问一个页面\",{\"1\":{\"686\":1}}],[\"它就不会再被accumulator方法使用了\",{\"1\":{\"1492\":1}}],[\"它就知道数据还没有准备好\",{\"1\":{\"1441\":1}}],[\"它就会将数据从kernel中拷贝到用户内存\",{\"1\":{\"1440\":1}}],[\"它就会重置为0\",{\"1\":{\"635\":1}}],[\"它就是代表这个资源的\",{\"1\":{\"1438\":1}}],[\"它就是一个正常表\",{\"1\":{\"546\":1}}],[\"它就是找引擎拿到了两条记录\",{\"1\":{\"475\":1}}],[\"它在mysql中是用来对应事务的\",{\"1\":{\"633\":1}}],[\"它是\",{\"1\":{\"1860\":1}}],[\"它是sink的一个抽象实现\",{\"1\":{\"1500\":1}}],[\"它是定义在abstractpipeline当中的\",{\"1\":{\"1499\":1}}],[\"它是根据提供的分类器来对元素进行分组的\",{\"1\":{\"1495\":1}}],[\"它是由迭代函数f对于初始值seed的不断迭代\",{\"1\":{\"1486\":1}}],[\"它是function接口的一种特殊形式\",{\"1\":{\"1475\":1}}],[\"它是java实现整个函数式编程的手段\",{\"1\":{\"1470\":1}}],[\"它是为操作系统的内核保留的\",{\"1\":{\"1456\":1}}],[\"它是一个类\",{\"1\":{\"1513\":2}}],[\"它是一个可变的汇聚操作\",{\"1\":{\"1492\":1}}],[\"它是一个相关的\",{\"1\":{\"1485\":1}}],[\"它是一个索引值\",{\"1\":{\"1438\":1}}],[\"它是一个重量级锁\",{\"1\":{\"1360\":1}}],[\"它是性能保证的关键之一\",{\"1\":{\"1388\":1}}],[\"它是对abstractexecutorservice类的扩展\",{\"1\":{\"1387\":1}}],[\"它是操作系统中pv操作的源语在java中的实现\",{\"1\":{\"1373\":1}}],[\"它是操作系统提供给用户程序的api\",{\"1\":{\"740\":1}}],[\"它是在从库执行的\",{\"1\":{\"610\":1}}],[\"它是加载数据行之间间隙上的\",{\"1\":{\"585\":1}}],[\"它由两部分组成\",{\"1\":{\"605\":1}}],[\"它用set\",{\"1\":{\"591\":1}}],[\"它用来记录在mysql中响应时间超过阈值的语句\",{\"1\":{\"565\":1}}],[\"它有三种可能取值\",{\"1\":{\"588\":1}}],[\"它做的变更才会被其它事务看到\",{\"1\":{\"570\":1}}],[\"它做的变更就能被别的事务看到\",{\"1\":{\"570\":1}}],[\"它的构成组件都是可配置的\",{\"1\":{\"1561\":1}}],[\"它的close方法会在退出\",{\"1\":{\"1496\":1}}],[\"它的相关说明\",{\"1\":{\"1490\":1}}],[\"它的参数unaryoperator可以简单的看一下\",{\"1\":{\"1486\":1}}],[\"它的抽象方法是apply\",{\"1\":{\"1475\":1}}],[\"它的底层时调用了linux内核的mmap的api\",{\"1\":{\"1464\":1}}],[\"它的主要作用就是和channel进行交互\",{\"1\":{\"1451\":1}}],[\"它的主要目的是根据调用的请求完成一次数据库操作\",{\"1\":{\"806\":1}}],[\"它的基本原来就是select\",{\"1\":{\"1442\":1}}],[\"它的put方法\",{\"1\":{\"1430\":1}}],[\"它的操作力度更细\",{\"1\":{\"1386\":1}}],[\"它的容量固定就是integer\",{\"1\":{\"1386\":1}}],[\"它的默认值是on\",{\"1\":{\"696\":1}}],[\"它的查询成本由下面两个部分构成\",{\"1\":{\"691\":1}}],[\"它的rows值是10354\",{\"1\":{\"690\":1}}],[\"它的指针地址是不会变的\",{\"1\":{\"634\":1}}],[\"它的算法是\",{\"1\":{\"634\":1}}],[\"它的逻辑如下\",{\"1\":{\"610\":1}}],[\"它的目标是\",{\"1\":{\"601\":1}}],[\"它的计算方式如下\",{\"1\":{\"594\":1}}],[\"它的返回结果里面会显示\",{\"1\":{\"594\":1}}],[\"它的explain结果如下\",{\"1\":{\"553\":1}}],[\"它的语义是\",{\"1\":{\"551\":1}}],[\"它的意思是\",{\"1\":{\"492\":1}}],[\"它的优点是\",{\"1\":{\"301\":1}}],[\"它所在的数据页就都在内存里了\",{\"1\":{\"479\":1}}],[\"它主要负责mysql功能层面的事情\",{\"1\":{\"462\":1}}],[\"它从mysql5\",{\"1\":{\"454\":1}}],[\"它其实已经不是之前所定义的树了\",{\"1\":{\"350\":1}}],[\"它只会分成两组\",{\"1\":{\"1490\":1}}],[\"它只接受一个参数\",{\"1\":{\"1475\":1}}],[\"它只有一个精确的抽象方法\",{\"1\":{\"1471\":1}}],[\"它只有循环\",{\"1\":{\"337\":1}}],[\"它只能处理线性序列\",{\"1\":{\"337\":1}}],[\"它只与关键字有关系\",{\"1\":{\"332\":1}}],[\"它们必须都是result\",{\"1\":{\"1492\":1}}],[\"它们背后的设计思想就是copy\",{\"1\":{\"1404\":1}}],[\"它们都严格遵守了不可变类的三点要求\",{\"1\":{\"1403\":1}}],[\"它们此时并不需要cpu来计算\",{\"1\":{\"1387\":1}}],[\"它们本质上都是对相应平台的\",{\"1\":{\"1356\":1}}],[\"它们本身就可以保证索引列值的不重复\",{\"1\":{\"695\":1}}],[\"它们会选举出一个sentinel节点来完成自动故障转移的工作\",{\"1\":{\"758\":1}}],[\"它们被存储到mysql的两个表中\",{\"1\":{\"694\":1}}],[\"它们可能还没有收到最新的日志\",{\"1\":{\"609\":1}}],[\"它们可以用来制造更多的\",{\"1\":{\"602\":1}}],[\"它们在备库上可以并行执行\",{\"1\":{\"599\":1}}],[\"它们就可以并行\",{\"1\":{\"598\":1}}],[\"它们之间的关系如下图\",{\"1\":{\"1430\":1}}],[\"它们之间的关系是\",{\"1\":{\"1423\":1}}],[\"它们之间的对比如下\",{\"1\":{\"316\":1}}],[\"它们之间是不冲突的\",{\"1\":{\"585\":1}}],[\"它们有共同的目标\",{\"1\":{\"585\":1}}],[\"它们的驱动表是固定的\",{\"1\":{\"692\":1}}],[\"它们的含义如下\",{\"1\":{\"570\":1}}],[\"它们的table\",{\"1\":{\"549\":1}}],[\"它们的区别\",{\"1\":{\"489\":1}}],[\"它们的相同点是\",{\"1\":{\"489\":1}}],[\"它们的示意图如下所示\",{\"1\":{\"487\":1}}],[\"它们分别是\",{\"1\":{\"280\":1}}],[\"它尝试分步的去解决一个问题\",{\"1\":{\"290\":1}}],[\"0x00004000\",{\"1\":{\"1497\":1}}],[\"0x00001000\",{\"1\":{\"1497\":1}}],[\"0x00000400\",{\"1\":{\"1497\":1}}],[\"0x00000100\",{\"1\":{\"1497\":1}}],[\"0x00000040\",{\"1\":{\"1497\":1}}],[\"0x00000004\",{\"1\":{\"1497\":1}}],[\"0x00000001\",{\"1\":{\"1497\":1}}],[\"0x00000010\",{\"1\":{\"1497\":1}}],[\"0的情况下\",{\"1\":{\"1491\":1}}],[\"0l\",{\"1\":{\"1490\":1}}],[\"0新特性\",{\"0\":{\"797\":1}}],[\"0终于发布了\",{\"1\":{\"738\":1}}],[\"0开始\",{\"1\":{\"738\":1}}],[\"0开始就彻底没有这个功能了\",{\"1\":{\"456\":1}}],[\"0<\",{\"1\":{\"719\":1}}],[\"0或1\",{\"1\":{\"715\":1}}],[\"05112878度\",{\"1\":{\"713\":1}}],[\"05112878度到85\",{\"1\":{\"713\":1}}],[\"05秒\",{\"1\":{\"485\":1}}],[\"0~3\",{\"1\":{\"711\":1}}],[\"0~1的成员\",{\"1\":{\"711\":1}}],[\"0~1部分\",{\"1\":{\"708\":1}}],[\"0~db\",{\"1\":{\"704\":1}}],[\"02\",{\"1\":{\"695\":1}}],[\"0时\",{\"1\":{\"693\":1}}],[\"0时一个页面的io成本常数\",{\"1\":{\"686\":1}}],[\"0=3\",{\"1\":{\"686\":1}}],[\"0=39\",{\"1\":{\"686\":1}}],[\"0是一个微调值\",{\"1\":{\"685\":2}}],[\"07\",{\"1\":{\"666\":1}}],[\"073\",{\"1\":{\"665\":4}}],[\"09之间大约有39条记录\",{\"1\":{\"686\":1}}],[\"09这个条件继续从id\",{\"1\":{\"686\":1}}],[\"09\",{\"1\":{\"591\":2,\"681\":1,\"684\":2,\"686\":5,\"690\":2,\"691\":4,\"692\":10}}],[\"0123passw0rd\",{\"1\":{\"761\":1}}],[\"012条记录\",{\"1\":{\"690\":1}}],[\"0126\",{\"1\":{\"690\":2}}],[\"01是微调\",{\"1\":{\"686\":1}}],[\"01\",{\"1\":{\"565\":1,\"666\":7,\"686\":4,\"690\":1}}],[\"0110\",{\"1\":{\"313\":2}}],[\"0版本的策略\",{\"1\":{\"629\":1}}],[\"0版本的时候\",{\"1\":{\"629\":1}}],[\"0版本\",{\"1\":{\"627\":1}}],[\"0版本后\",{\"1\":{\"627\":1}}],[\"0版本开始\",{\"1\":{\"562\":1}}],[\"0版本直接将查询缓存的整块功能删掉了\",{\"1\":{\"456\":1}}],[\"036\",{\"1\":{\"665\":2}}],[\"03\",{\"1\":{\"508\":2,\"666\":1,\"681\":2,\"684\":4,\"686\":14,\"690\":4,\"691\":8,\"692\":20,\"695\":1}}],[\"08\",{\"1\":{\"508\":4,\"692\":1}}],[\"001\",{\"1\":{\"1361\":1}}],[\"00156100\",{\"1\":{\"568\":1}}],[\"0011\",{\"1\":{\"313\":6}}],[\"000064\",{\"1\":{\"568\":1}}],[\"000060\",{\"1\":{\"568\":1}}],[\"000051\",{\"1\":{\"568\":1}}],[\"000053\",{\"1\":{\"568\":1}}],[\"000058\",{\"1\":{\"568\":1}}],[\"000041\",{\"1\":{\"568\":1}}],[\"000046\",{\"1\":{\"568\":2}}],[\"000032\",{\"1\":{\"568\":1}}],[\"000037\",{\"1\":{\"568\":1}}],[\"000039\",{\"1\":{\"568\":1}}],[\"000023\",{\"1\":{\"568\":1}}],[\"000019\",{\"1\":{\"568\":1}}],[\"000014\",{\"1\":{\"568\":1}}],[\"000011\",{\"1\":{\"568\":2}}],[\"000010\",{\"1\":{\"568\":1}}],[\"000007\",{\"1\":{\"622\":1}}],[\"000001文件里面从第2738字节到2973字节中间这段内容解析出来\",{\"1\":{\"591\":1}}],[\"000001\",{\"1\":{\"591\":3}}],[\"000004\",{\"1\":{\"568\":1}}],[\"000006这两个文件\",{\"1\":{\"622\":1}}],[\"000006\",{\"1\":{\"568\":2,\"622\":1}}],[\"000003\",{\"1\":{\"568\":1}}],[\"000005和master\",{\"1\":{\"622\":1}}],[\"000005开始的\",{\"1\":{\"622\":1}}],[\"000005\",{\"1\":{\"568\":2,\"622\":1}}],[\"000009\",{\"1\":{\"568\":2}}],[\"000002\",{\"1\":{\"568\":1}}],[\"0000000000000000000000000000000000000000\",{\"1\":{\"746\":1}}],[\"000000\",{\"1\":{\"565\":1,\"568\":30}}],[\"000090\",{\"1\":{\"568\":1}}],[\"000097\",{\"1\":{\"568\":1}}],[\"000347\",{\"1\":{\"557\":1}}],[\"00\",{\"1\":{\"466\":2,\"467\":10,\"498\":2,\"508\":2,\"565\":3,\"568\":4,\"666\":6,\"692\":1,\"1361\":1}}],[\"0表示不选当前元素\",{\"1\":{\"431\":1}}],[\"0和f\",{\"1\":{\"429\":1}}],[\"0下标处的那个元素即是堆顶元素\",{\"1\":{\"354\":1}}],[\"0\",{\"1\":{\"288\":3,\"302\":7,\"305\":1,\"311\":1,\"314\":1,\"315\":3,\"317\":2,\"318\":3,\"319\":5,\"326\":2,\"329\":3,\"341\":1,\"359\":1,\"360\":1,\"361\":4,\"362\":2,\"363\":6,\"364\":2,\"365\":5,\"366\":8,\"367\":5,\"368\":5,\"371\":1,\"375\":2,\"380\":1,\"381\":1,\"383\":2,\"384\":1,\"385\":7,\"386\":1,\"387\":3,\"388\":6,\"393\":8,\"395\":1,\"396\":4,\"399\":1,\"400\":2,\"401\":1,\"402\":2,\"403\":2,\"404\":1,\"407\":1,\"408\":1,\"410\":5,\"411\":6,\"415\":3,\"417\":3,\"419\":3,\"421\":2,\"422\":2,\"424\":1,\"425\":4,\"426\":8,\"427\":2,\"428\":3,\"429\":4,\"430\":5,\"431\":16,\"435\":17,\"437\":1,\"438\":5,\"439\":1,\"440\":1,\"443\":2,\"466\":1,\"467\":6,\"473\":1,\"498\":1,\"508\":2,\"530\":2,\"540\":1,\"554\":1,\"556\":1,\"557\":2,\"565\":5,\"568\":109,\"572\":2,\"583\":3,\"584\":11,\"585\":2,\"591\":2,\"621\":1,\"628\":1,\"647\":1,\"655\":1,\"656\":1,\"665\":9,\"667\":10,\"681\":1,\"682\":3,\"684\":2,\"685\":4,\"686\":23,\"690\":5,\"693\":1,\"694\":10,\"704\":24,\"706\":39,\"707\":49,\"708\":84,\"709\":43,\"710\":42,\"711\":82,\"713\":4,\"714\":14,\"715\":25,\"716\":26,\"717\":26,\"718\":35,\"735\":8,\"746\":7,\"748\":8,\"758\":2,\"761\":2,\"806\":1,\"1350\":1,\"1352\":1,\"1353\":1,\"1356\":6,\"1357\":1,\"1359\":1,\"1360\":8,\"1361\":1,\"1364\":1,\"1379\":3,\"1380\":3,\"1383\":2,\"1394\":3,\"1425\":1,\"1426\":2,\"1427\":7,\"1428\":2,\"1431\":13,\"1450\":2,\"1451\":5,\"1452\":2,\"1460\":1,\"1461\":1,\"1462\":2,\"1464\":1,\"1465\":1,\"1468\":1,\"1470\":1,\"1476\":7,\"1478\":4,\"1484\":2,\"1486\":2,\"1487\":6,\"1489\":1,\"1490\":4,\"1491\":3,\"1494\":1,\"1495\":11,\"1497\":7,\"1498\":2,\"1500\":3,\"1525\":2,\"1531\":1}}],[\"0有什么关系\",{\"0\":{\"228\":1}}],[\"=0\",{\"1\":{\"1468\":1}}],[\"=16个字节\",{\"1\":{\"1361\":1}}],[\"=10100\",{\"1\":{\"662\":1}}],[\"=a\",{\"1\":{\"1356\":2}}],[\"=起始地址+\",{\"1\":{\"1352\":1}}],[\"=或者<>的时候无法使用索引会导致全表扫描\",{\"1\":{\"506\":1}}],[\"=convert\",{\"1\":{\"505\":1}}],[\"=7\",{\"1\":{\"503\":1}}],[\"=nums\",{\"1\":{\"432\":1}}],[\"=max\",{\"1\":{\"430\":1,\"431\":1,\"432\":2}}],[\"=min\",{\"1\":{\"426\":1}}],[\"=true\",{\"1\":{\"428\":1}}],[\"=text2​\",{\"1\":{\"427\":1}}],[\"=p\",{\"1\":{\"428\":1}}],[\"=film1\",{\"1\":{\"643\":1}}],[\"=film0\",{\"1\":{\"643\":1}}],[\"=f\",{\"1\":{\"425\":1}}],[\"=>\",{\"1\":{\"314\":1,\"315\":2}}],[\"=======================\",{\"1\":{\"1489\":1}}],[\"====================================\",{\"1\":{\"1494\":1}}],[\"==================================\",{\"1\":{\"1480\":1,\"1481\":1}}],[\"==================\",{\"1\":{\"1489\":1}}],[\"================\",{\"1\":{\"1469\":1}}],[\"==present\",{\"1\":{\"1434\":1}}],[\"==null\",{\"1\":{\"1434\":1}}],[\"==这样的话是永久的\",{\"1\":{\"747\":1}}],[\"==真实开发中应该在从机的配置文件中进行配置\",{\"1\":{\"747\":1}}],[\"==\",{\"1\":{\"296\":1,\"302\":8,\"315\":4,\"360\":1,\"363\":3,\"365\":2,\"366\":6,\"367\":1,\"368\":1,\"371\":1,\"373\":4,\"376\":4,\"377\":1,\"381\":1,\"383\":2,\"385\":5,\"386\":4,\"388\":7,\"395\":4,\"396\":2,\"397\":1,\"398\":5,\"400\":2,\"401\":1,\"402\":1,\"403\":4,\"404\":1,\"405\":1,\"406\":10,\"407\":1,\"408\":3,\"409\":8,\"410\":7,\"411\":6,\"412\":4,\"415\":1,\"417\":1,\"424\":2,\"427\":1,\"428\":1,\"431\":4,\"435\":3,\"438\":2,\"440\":1,\"441\":1,\"443\":1,\"806\":4,\"1353\":2,\"1356\":4,\"1357\":2,\"1379\":4,\"1380\":5,\"1425\":1,\"1426\":10,\"1427\":7,\"1430\":4,\"1431\":20,\"1471\":1,\"1476\":8,\"1486\":1,\"1489\":2,\"1491\":2,\"1495\":2,\"1496\":1,\"1497\":2,\"1499\":3,\"1500\":1,\"1524\":18,\"1525\":8,\"1527\":2,\"1531\":1,\"1532\":2,\"1535\":1,\"1540\":2,\"1567\":1}}],[\"=\",{\"1\":{\"288\":6,\"296\":6,\"302\":29,\"305\":5,\"311\":1,\"314\":10,\"315\":5,\"317\":5,\"318\":7,\"319\":16,\"325\":1,\"326\":2,\"329\":10,\"332\":4,\"338\":3,\"359\":2,\"360\":4,\"361\":8,\"362\":8,\"363\":6,\"364\":15,\"365\":6,\"366\":10,\"367\":6,\"368\":12,\"371\":8,\"372\":7,\"373\":8,\"375\":10,\"376\":5,\"377\":11,\"380\":4,\"381\":3,\"383\":5,\"384\":6,\"385\":16,\"386\":8,\"387\":3,\"388\":6,\"389\":1,\"392\":2,\"393\":8,\"395\":22,\"396\":6,\"397\":8,\"398\":2,\"399\":2,\"400\":3,\"401\":10,\"402\":10,\"403\":10,\"404\":10,\"405\":3,\"406\":8,\"408\":3,\"409\":9,\"410\":13,\"411\":14,\"415\":2,\"417\":15,\"419\":5,\"421\":3,\"422\":2,\"424\":12,\"425\":8,\"426\":11,\"427\":11,\"428\":19,\"429\":17,\"430\":10,\"431\":13,\"435\":7,\"437\":1,\"438\":11,\"439\":5,\"440\":5,\"441\":1,\"443\":8,\"467\":2,\"472\":3,\"473\":1,\"475\":1,\"478\":1,\"479\":1,\"483\":1,\"486\":2,\"489\":1,\"490\":1,\"491\":2,\"492\":1,\"498\":5,\"503\":4,\"504\":2,\"505\":8,\"507\":11,\"508\":4,\"509\":5,\"510\":6,\"511\":2,\"513\":4,\"514\":21,\"515\":41,\"521\":1,\"527\":3,\"530\":2,\"531\":5,\"537\":3,\"538\":1,\"539\":1,\"541\":4,\"542\":1,\"544\":3,\"546\":2,\"551\":2,\"553\":1,\"556\":3,\"559\":5,\"561\":6,\"565\":2,\"570\":1,\"572\":3,\"575\":1,\"583\":1,\"584\":4,\"585\":1,\"591\":1,\"596\":1,\"599\":3,\"605\":1,\"613\":6,\"615\":2,\"616\":2,\"618\":2,\"622\":1,\"626\":1,\"635\":1,\"641\":1,\"643\":6,\"646\":2,\"655\":2,\"657\":3,\"659\":1,\"662\":1,\"671\":2,\"672\":2,\"673\":1,\"674\":1,\"681\":2,\"684\":2,\"685\":8,\"686\":11,\"688\":2,\"690\":4,\"692\":7,\"693\":2,\"695\":5,\"696\":2,\"708\":1,\"719\":6,\"720\":2,\"740\":1,\"806\":10,\"1352\":4,\"1353\":3,\"1356\":13,\"1357\":9,\"1359\":2,\"1360\":17,\"1361\":5,\"1362\":2,\"1363\":1,\"1364\":5,\"1375\":6,\"1379\":13,\"1380\":31,\"1383\":7,\"1394\":13,\"1398\":3,\"1405\":1,\"1408\":3,\"1410\":3,\"1411\":5,\"1412\":5,\"1425\":3,\"1426\":20,\"1427\":46,\"1428\":6,\"1430\":19,\"1431\":53,\"1434\":1,\"1450\":23,\"1451\":46,\"1452\":23,\"1464\":3,\"1465\":2,\"1468\":13,\"1469\":5,\"1470\":7,\"1471\":1,\"1472\":7,\"1474\":2,\"1475\":14,\"1476\":8,\"1477\":9,\"1478\":1,\"1479\":1,\"1480\":14,\"1481\":11,\"1482\":11,\"1483\":2,\"1484\":11,\"1485\":13,\"1486\":17,\"1487\":12,\"1488\":3,\"1489\":8,\"1490\":15,\"1491\":18,\"1492\":15,\"1493\":12,\"1494\":19,\"1495\":36,\"1496\":7,\"1497\":33,\"1498\":7,\"1499\":22,\"1500\":4,\"1509\":2,\"1510\":2,\"1511\":3,\"1512\":2,\"1515\":3,\"1516\":2,\"1517\":2,\"1521\":1,\"1522\":8,\"1523\":4,\"1524\":112,\"1525\":64,\"1526\":1,\"1527\":14,\"1528\":11,\"1529\":1,\"1531\":36,\"1532\":36,\"1535\":5,\"1540\":7}}],[\"1friic\",{\"1\":{\"1850\":1}}],[\"1ddc4ec2\",{\"1\":{\"1490\":1}}],[\"1dcb5644392c\",{\"1\":{\"565\":1,\"566\":1}}],[\"1之后就停止了\",{\"1\":{\"1487\":1}}],[\"1之间\",{\"1\":{\"526\":1}}],[\"1次迭代函数f\",{\"1\":{\"1486\":1}}],[\"1次cpu拷贝\",{\"1\":{\"1457\":1,\"1458\":1}}],[\"1次扫描可以认为最终只扫描t1表一行完整数据\",{\"1\":{\"661\":1}}],[\"1就是一个0后面n个1\",{\"1\":{\"1425\":1}}],[\"1l\",{\"1\":{\"1397\":1,\"1431\":2,\"1490\":1,\"1497\":1}}],[\"1+平均等待时间\",{\"1\":{\"1387\":1}}],[\"1|0\",{\"1\":{\"695\":2,\"696\":2}}],[\"1种连接顺序\",{\"1\":{\"693\":1}}],[\"1=6种连接顺序\",{\"1\":{\"693\":1}}],[\"1=4\",{\"1\":{\"591\":1}}],[\"1✖️\",{\"1\":{\"686\":1}}],[\"1指是加载一个页面的io成本常数\",{\"1\":{\"685\":1}}],[\"17\",{\"1\":{\"714\":1,\"1461\":1}}],[\"177\",{\"1\":{\"711\":1}}],[\"175\",{\"1\":{\"665\":3}}],[\"17开始\",{\"1\":{\"562\":1}}],[\"1后\",{\"1\":{\"635\":1}}],[\"1这个值本身已经很大了\",{\"1\":{\"632\":1}}],[\"1这个记录\",{\"1\":{\"561\":1}}],[\"1个用完以后\",{\"1\":{\"629\":1}}],[\"1版本之前\",{\"1\":{\"629\":1}}],[\"1来检测系统\",{\"1\":{\"613\":1}}],[\"1是检测不出问题的\",{\"1\":{\"613\":1}}],[\"1可以成功\",{\"1\":{\"613\":1}}],[\"1成功返回\",{\"1\":{\"613\":1}}],[\"1成功返回了\",{\"1\":{\"613\":1}}],[\"1判断\",{\"0\":{\"613\":1}}],[\"1执行\",{\"1\":{\"598\":1}}],[\"1了\",{\"1\":{\"598\":1}}],[\"1队列中有事务在修改表t1\",{\"1\":{\"598\":1}}],[\"1表示key未设置过期时间\",{\"1\":{\"706\":1}}],[\"1表示\",{\"1\":{\"598\":1}}],[\"1表示选择当前元素\",{\"1\":{\"431\":1}}],[\"1语句得到三行数据\",{\"1\":{\"559\":1}}],[\"1的mask范围在高位多1bit\",{\"1\":{\"1427\":1}}],[\"1的二进制前面都是0\",{\"1\":{\"1425\":1}}],[\"1的上限\",{\"1\":{\"634\":1}}],[\"1的\",{\"1\":{\"598\":1}}],[\"1的时候是可以成功的\",{\"1\":{\"561\":1}}],[\"1的时候order\",{\"1\":{\"498\":2}}],[\"1的下一个记录并不是2018\",{\"1\":{\"561\":1}}],[\"1的做法是按照顺序一个一个地读出来\",{\"1\":{\"559\":1}}],[\"1取得一行\",{\"1\":{\"559\":1}}],[\"1和10\",{\"1\":{\"526\":1}}],[\"1和order\",{\"1\":{\"485\":1}}],[\"15623667886\",{\"1\":{\"710\":4}}],[\"152\",{\"1\":{\"692\":1}}],[\"152k\",{\"1\":{\"692\":1}}],[\"1589248\",{\"1\":{\"685\":1}}],[\"150000\",{\"1\":{\"568\":3}}],[\"15\",{\"1\":{\"515\":1,\"583\":3,\"585\":2,\"643\":1,\"686\":2,\"704\":1,\"706\":1,\"707\":1,\"1496\":1}}],[\"151\",{\"0\":{\"385\":1}}],[\"147\",{\"1\":{\"665\":2}}],[\"14\",{\"1\":{\"515\":1,\"666\":1,\"1487\":1}}],[\"1425\",{\"1\":{\"466\":1,\"467\":1}}],[\"142\",{\"0\":{\"377\":1}}],[\"133314b\",{\"1\":{\"1490\":1}}],[\"134\",{\"1\":{\"665\":3}}],[\"13\",{\"1\":{\"515\":1,\"591\":1,\"690\":1,\"706\":1}}],[\"1252599548343744\",{\"1\":{\"1847\":1}}],[\"121239018\",{\"1\":{\"1526\":1}}],[\"121\",{\"1\":{\"713\":1}}],[\"12176\",{\"1\":{\"656\":1}}],[\"120\",{\"1\":{\"713\":3}}],[\"120和160\",{\"1\":{\"588\":1}}],[\"124556301\",{\"1\":{\"698\":1}}],[\"127\",{\"1\":{\"665\":1,\"704\":10,\"706\":19,\"707\":23,\"708\":33,\"709\":21,\"710\":19,\"711\":34,\"713\":2,\"714\":7,\"715\":9,\"716\":13,\"717\":13,\"718\":16,\"735\":4,\"746\":1,\"748\":4,\"758\":1,\"761\":1,\"1450\":1,\"1451\":1,\"1452\":1}}],[\"12号线程的等待逻辑是这样的\",{\"1\":{\"618\":1}}],[\"123666\",{\"1\":{\"707\":1}}],[\"123\",{\"1\":{\"531\":1,\"604\":1}}],[\"12345\",{\"1\":{\"710\":3}}],[\"1234\",{\"1\":{\"531\":1}}],[\"12\",{\"1\":{\"515\":1,\"561\":1,\"591\":1,\"643\":3,\"666\":2,\"708\":1,\"714\":1,\"718\":1}}],[\"128\",{\"1\":{\"490\":1,\"665\":1}}],[\"1才可以有效的用上索引\",{\"1\":{\"503\":1}}],[\"180000\",{\"1\":{\"761\":1}}],[\"180度到180度\",{\"1\":{\"713\":1}}],[\"188\",{\"1\":{\"711\":1}}],[\"18\",{\"1\":{\"488\":1,\"507\":3,\"508\":2,\"509\":2,\"510\":2,\"643\":3,\"665\":1,\"673\":1,\"681\":2,\"684\":4,\"686\":14,\"690\":4,\"691\":8,\"692\":20,\"1496\":2}}],[\"1都会返回b是最小的那一行\",{\"1\":{\"485\":1}}],[\"1190000022279128\",{\"1\":{\"1852\":1}}],[\"1170再乘以16kb约2000多万的数据\",{\"1\":{\"640\":1}}],[\"11\",{\"1\":{\"467\":4,\"475\":2,\"483\":3,\"490\":2,\"503\":2,\"505\":3,\"515\":1,\"537\":3,\"556\":1,\"561\":1,\"583\":3,\"591\":10,\"596\":2,\"599\":3,\"605\":2,\"613\":2,\"615\":1,\"626\":3,\"643\":5,\"647\":2,\"655\":2,\"660\":3,\"671\":1,\"672\":2,\"686\":2,\"688\":1,\"706\":1,\"707\":2,\"714\":2,\"1361\":1,\"1428\":1,\"1487\":1,\"1844\":1}}],[\"1142\",{\"1\":{\"459\":1}}],[\"112\",{\"0\":{\"412\":1}}],[\"110717\",{\"1\":{\"504\":2}}],[\"110\",{\"0\":{\"408\":1}}],[\"1100\",{\"1\":{\"313\":1}}],[\"1步\",{\"1\":{\"375\":1}}],[\"192\",{\"1\":{\"719\":1}}],[\"1970\",{\"1\":{\"666\":1}}],[\"1901\",{\"1\":{\"666\":1}}],[\"199999888333501\",{\"1\":{\"713\":1}}],[\"199\",{\"0\":{\"403\":1}}],[\"19\",{\"0\":{\"375\":1},\"1\":{\"666\":1}}],[\"168\",{\"1\":{\"719\":1}}],[\"16个数据库分别为\",{\"1\":{\"704\":1}}],[\"16000\",{\"1\":{\"672\":1}}],[\"160\",{\"0\":{\"376\":1},\"1\":{\"711\":1}}],[\"16\",{\"1\":{\"329\":2,\"472\":1,\"473\":1,\"490\":2,\"491\":1,\"492\":1,\"665\":1,\"667\":2,\"685\":1,\"692\":1,\"704\":1,\"1425\":3,\"1431\":4}}],[\"163\",{\"1\":{\"10\":1}}],[\"1s\",{\"1\":{\"314\":1}}],[\"10的新生代内存\",{\"1\":{\"1541\":1}}],[\"10的结果\",{\"1\":{\"553\":1}}],[\"1048576\",{\"1\":{\"746\":1}}],[\"10354值的统计数据中表的记录数\",{\"1\":{\"685\":1}}],[\"10354\",{\"1\":{\"685\":1}}],[\"1032\",{\"1\":{\"604\":1}}],[\"1032错误是删除数据时找不到行\",{\"1\":{\"604\":1}}],[\"10s\",{\"1\":{\"681\":1,\"684\":2,\"686\":2,\"690\":2,\"691\":2,\"708\":1}}],[\"1062\",{\"1\":{\"604\":1}}],[\"1062错误是插入数据时唯一键冲突\",{\"1\":{\"604\":1}}],[\"10进行分组统计\",{\"1\":{\"553\":1}}],[\"10225\",{\"1\":{\"690\":1}}],[\"1024字节\",{\"1\":{\"553\":1}}],[\"1024\",{\"1\":{\"548\":1,\"553\":1,\"685\":1,\"1398\":2,\"1410\":1,\"1411\":1,\"1451\":2,\"1452\":2,\"1464\":2}}],[\"102931490\",{\"1\":{\"467\":1}}],[\"100可以估算出将要和explain中前一个表进行连接的行数\",{\"1\":{\"643\":1}}],[\"100的值存入sort\",{\"1\":{\"555\":1}}],[\"100的结果是无序的\",{\"1\":{\"554\":1}}],[\"100万=10亿次\",{\"1\":{\"544\":1}}],[\"1001\",{\"1\":{\"541\":1}}],[\"100让优化器意识到\",{\"1\":{\"485\":1}}],[\"100\",{\"1\":{\"466\":1,\"467\":4,\"472\":1,\"473\":1,\"485\":2,\"537\":1,\"541\":1,\"548\":3,\"553\":2,\"554\":1,\"555\":1,\"556\":2,\"561\":1,\"584\":8,\"613\":2,\"656\":1,\"692\":1,\"718\":2,\"1375\":2,\"1380\":1,\"1490\":1,\"1492\":1,\"1497\":1,\"1850\":1}}],[\"1000=10万次\",{\"1\":{\"540\":2}}],[\"1000=10万行\",{\"1\":{\"539\":1}}],[\"10000=100万次\",{\"1\":{\"662\":2}}],[\"100000000\",{\"1\":{\"1364\":1}}],[\"1000000000l\",{\"1\":{\"1356\":1}}],[\"1000000\",{\"1\":{\"541\":1}}],[\"100000\",{\"1\":{\"484\":1,\"1468\":1}}],[\"10000\",{\"1\":{\"483\":4,\"503\":2,\"530\":1,\"556\":1,\"657\":4,\"724\":2}}],[\"1000\",{\"1\":{\"313\":1,\"484\":1,\"485\":1,\"490\":1,\"491\":1,\"505\":3,\"537\":1,\"541\":1,\"551\":2,\"556\":2,\"558\":1,\"666\":2,\"1450\":2,\"1451\":2}}],[\"10123\",{\"1\":{\"656\":5}}],[\"101\",{\"0\":{\"406\":1},\"1\":{\"1361\":1}}],[\"1011\",{\"1\":{\"313\":4}}],[\"107\",{\"0\":{\"402\":1}}],[\"10\",{\"1\":{\"388\":4,\"467\":1,\"498\":5,\"499\":4,\"500\":2,\"505\":1,\"515\":7,\"527\":1,\"553\":3,\"556\":2,\"565\":1,\"566\":4,\"568\":3,\"581\":1,\"583\":3,\"585\":3,\"591\":4,\"605\":3,\"631\":1,\"643\":1,\"657\":1,\"665\":1,\"673\":2,\"707\":2,\"710\":1,\"711\":2,\"724\":2,\"1361\":1,\"1394\":1,\"1412\":1,\"1476\":2,\"1480\":2,\"1481\":2,\"1482\":1,\"1486\":1,\"1487\":1,\"1494\":1}}],[\"1\",{\"1\":{\"285\":1,\"301\":1,\"302\":5,\"305\":4,\"310\":2,\"311\":1,\"315\":7,\"317\":2,\"318\":2,\"319\":10,\"325\":1,\"329\":7,\"330\":1,\"333\":1,\"334\":1,\"341\":2,\"343\":1,\"353\":1,\"356\":1,\"360\":2,\"362\":1,\"363\":1,\"364\":3,\"366\":9,\"367\":4,\"368\":3,\"375\":1,\"381\":1,\"383\":1,\"384\":3,\"385\":4,\"386\":1,\"387\":2,\"388\":4,\"389\":1,\"393\":5,\"396\":1,\"399\":3,\"400\":3,\"403\":3,\"407\":1,\"408\":8,\"409\":2,\"411\":2,\"415\":2,\"417\":3,\"424\":9,\"425\":8,\"426\":11,\"427\":19,\"428\":8,\"429\":12,\"430\":2,\"431\":15,\"435\":17,\"438\":5,\"439\":3,\"440\":2,\"443\":3,\"466\":4,\"467\":22,\"472\":1,\"473\":1,\"475\":1,\"484\":2,\"485\":5,\"498\":25,\"499\":1,\"500\":1,\"503\":9,\"505\":5,\"508\":5,\"515\":1,\"527\":7,\"536\":5,\"537\":2,\"540\":1,\"541\":5,\"544\":2,\"545\":1,\"546\":1,\"550\":2,\"551\":2,\"553\":1,\"554\":1,\"556\":1,\"559\":5,\"561\":9,\"562\":2,\"565\":6,\"566\":2,\"567\":2,\"568\":6,\"570\":1,\"572\":1,\"583\":2,\"584\":14,\"591\":6,\"596\":1,\"599\":4,\"605\":8,\"608\":1,\"610\":2,\"611\":2,\"613\":7,\"627\":2,\"628\":11,\"629\":4,\"630\":1,\"631\":1,\"632\":2,\"633\":1,\"634\":4,\"636\":1,\"643\":7,\"646\":2,\"656\":4,\"657\":2,\"662\":1,\"663\":2,\"665\":7,\"666\":1,\"671\":1,\"672\":1,\"682\":1,\"685\":7,\"686\":5,\"690\":3,\"692\":2,\"693\":3,\"694\":4,\"704\":12,\"706\":31,\"707\":26,\"708\":62,\"709\":39,\"710\":33,\"711\":67,\"713\":8,\"714\":9,\"715\":18,\"716\":15,\"717\":14,\"718\":17,\"724\":2,\"729\":2,\"735\":11,\"746\":2,\"748\":4,\"758\":2,\"761\":5,\"770\":1,\"1356\":13,\"1357\":2,\"1359\":2,\"1361\":1,\"1367\":1,\"1375\":2,\"1378\":2,\"1379\":1,\"1380\":5,\"1383\":3,\"1425\":5,\"1426\":2,\"1427\":5,\"1430\":2,\"1431\":14,\"1450\":1,\"1451\":1,\"1452\":2,\"1459\":2,\"1462\":2,\"1471\":2,\"1472\":4,\"1474\":2,\"1475\":9,\"1476\":4,\"1477\":1,\"1478\":1,\"1484\":1,\"1486\":4,\"1487\":14,\"1491\":1,\"1494\":7,\"1495\":2,\"1497\":6,\"1498\":1,\"1499\":1,\"1517\":1,\"1524\":1,\"1525\":4,\"1528\":1,\"1531\":1,\"1532\":1,\"1535\":1,\"1541\":1}}],[\"+useserialgc\",{\"1\":{\"1546\":1}}],[\"+usebiasedlocking\",{\"1\":{\"1362\":1}}],[\"+顺序的方式来表示\",{\"1\":{\"1469\":1}}],[\"+i1\",{\"1\":{\"1468\":1}}],[\"+i\",{\"1\":{\"1398\":1,\"1468\":1}}],[\"+inf分别表示最小最大值\",{\"1\":{\"711\":1}}],[\"++j\",{\"1\":{\"1427\":1}}],[\"++size\",{\"1\":{\"1426\":1}}],[\"++modcount\",{\"1\":{\"1426\":1,\"1430\":2}}],[\"++bincount\",{\"1\":{\"1426\":1,\"1431\":1}}],[\"++i\",{\"1\":{\"1394\":1,\"1497\":1}}],[\"++takeindex\",{\"1\":{\"1379\":1}}],[\"++putindex\",{\"1\":{\"1379\":1}}],[\"++count\",{\"1\":{\"381\":1}}],[\"+eliminatelocks\",{\"1\":{\"1364\":1}}],[\"+printflagsfinal\",{\"1\":{\"1362\":1}}],[\"+4\",{\"1\":{\"1361\":2}}],[\"+5\",{\"1\":{\"711\":1}}],[\"+2\",{\"1\":{\"599\":2}}],[\"+supremum\",{\"1\":{\"585\":1}}],[\"+n\",{\"1\":{\"559\":1}}],[\"+nums\",{\"1\":{\"430\":1,\"432\":1}}],[\"+100\",{\"1\":{\"662\":1}}],[\"+1作为这个表当前的自增值\",{\"1\":{\"627\":1}}],[\"+1\",{\"1\":{\"427\":1,\"599\":1}}],[\"+c\",{\"1\":{\"426\":1}}],[\"+f\",{\"1\":{\"425\":1}}],[\"+=\",{\"1\":{\"363\":1,\"384\":1,\"409\":2,\"410\":1,\"1495\":2,\"1497\":2}}],[\"+\",{\"1\":{\"285\":1,\"293\":1,\"302\":15,\"305\":2,\"310\":1,\"315\":2,\"318\":2,\"332\":1,\"360\":3,\"363\":1,\"366\":12,\"367\":2,\"368\":1,\"375\":1,\"384\":2,\"387\":1,\"388\":3,\"389\":1,\"393\":2,\"396\":1,\"399\":1,\"400\":2,\"403\":2,\"407\":2,\"408\":1,\"409\":1,\"410\":2,\"411\":2,\"415\":4,\"417\":2,\"421\":1,\"424\":4,\"425\":1,\"426\":3,\"427\":5,\"428\":6,\"429\":5,\"430\":2,\"431\":4,\"435\":6,\"439\":3,\"440\":3,\"443\":2,\"466\":1,\"467\":21,\"495\":1,\"503\":1,\"508\":36,\"537\":1,\"541\":2,\"549\":2,\"550\":2,\"551\":1,\"556\":5,\"559\":1,\"565\":27,\"567\":2,\"568\":42,\"613\":2,\"617\":2,\"685\":3,\"686\":14,\"690\":1,\"692\":4,\"711\":4,\"806\":2,\"1352\":2,\"1356\":18,\"1357\":2,\"1364\":2,\"1375\":1,\"1380\":1,\"1383\":2,\"1427\":3,\"1430\":2,\"1431\":8,\"1450\":2,\"1451\":2,\"1452\":2,\"1475\":5,\"1483\":1,\"1486\":3,\"1487\":9,\"1490\":6,\"1492\":1,\"1494\":3,\"1497\":1,\"1499\":1,\"1524\":38,\"1525\":3,\"1527\":1,\"1528\":3,\"1532\":2,\"1535\":3}}],[\">referencepipline\",{\"1\":{\"1501\":1}}],[\">abstractpipline\",{\"1\":{\"1501\":1}}],[\">associative<\",{\"1\":{\"1485\":2}}],[\">stream\",{\"1\":{\"1501\":1}}],[\">stateless<\",{\"1\":{\"1485\":2}}],[\">save\",{\"1\":{\"1394\":2}}],[\">non\",{\"1\":{\"1485\":2}}],[\">terminal\",{\"1\":{\"1485\":1}}],[\">mutable\",{\"1\":{\"1485\":1}}],[\">functional\",{\"1\":{\"1474\":1,\"1475\":3,\"1476\":2,\"1477\":1,\"1478\":1}}],[\">geocoderbys3\",{\"1\":{\"1394\":1}}],[\">geocoderbys2\",{\"1\":{\"1394\":1}}],[\">geocoderbys1\",{\"1\":{\"1394\":1}}],[\">getpricebys2\",{\"1\":{\"1394\":1}}],[\">getpricebys1\",{\"1\":{\"1394\":1}}],[\">=\",{\"1\":{\"363\":1,\"364\":2,\"367\":2,\"385\":1,\"397\":1,\"428\":1,\"503\":3,\"541\":1,\"544\":1,\"545\":1,\"546\":1,\"548\":2,\"559\":1,\"621\":1,\"1383\":1,\"1426\":1,\"1427\":2,\"1431\":4,\"1478\":1,\"1484\":1,\"1490\":1,\"1493\":1}}],[\">>>\",{\"1\":{\"1383\":1,\"1425\":3,\"1430\":1,\"1431\":2,\"1497\":1}}],[\">>\",{\"1\":{\"313\":1,\"315\":2,\"1383\":1,\"1498\":4}}],[\">\",{\"0\":{\"979\":1,\"980\":1},\"1\":{\"285\":1,\"302\":3,\"305\":1,\"311\":1,\"313\":6,\"315\":5,\"318\":1,\"319\":3,\"360\":1,\"362\":1,\"366\":3,\"367\":1,\"388\":1,\"393\":2,\"395\":1,\"396\":1,\"404\":1,\"408\":1,\"409\":3,\"411\":1,\"415\":6,\"421\":1,\"428\":1,\"438\":1,\"439\":1,\"440\":1,\"441\":1,\"443\":1,\"467\":1,\"471\":3,\"498\":3,\"509\":1,\"514\":1,\"515\":2,\"530\":1,\"571\":1,\"646\":1,\"656\":9,\"659\":1,\"673\":1,\"681\":2,\"684\":2,\"686\":4,\"690\":4,\"691\":9,\"692\":8,\"704\":4,\"706\":2,\"708\":1,\"719\":2,\"806\":1,\"1356\":2,\"1380\":1,\"1383\":1,\"1394\":4,\"1405\":2,\"1410\":1,\"1411\":1,\"1412\":2,\"1426\":1,\"1427\":2,\"1430\":1,\"1431\":2,\"1451\":2,\"1468\":2,\"1469\":1,\"1470\":3,\"1471\":7,\"1472\":9,\"1474\":2,\"1475\":26,\"1476\":29,\"1477\":5,\"1478\":4,\"1480\":5,\"1481\":4,\"1482\":4,\"1484\":2,\"1485\":5,\"1486\":11,\"1487\":27,\"1488\":6,\"1489\":3,\"1490\":2,\"1491\":7,\"1492\":1,\"1493\":7,\"1494\":9,\"1495\":21,\"1496\":10,\"1497\":4,\"1498\":2,\"1499\":4,\"1500\":2,\"1501\":2,\"1515\":1,\"1521\":1,\"1524\":14,\"1525\":13,\"1526\":1,\"1527\":3,\"1531\":4,\"1532\":7,\"1540\":2,\"1561\":2}}],[\"健壮性\",{\"1\":{\"282\":1}}],[\"可视化故障处理工具\",{\"0\":{\"1650\":1}}],[\"可终止的预清理\",{\"0\":{\"1613\":1}}],[\"可包含多个context\",{\"1\":{\"1561\":1}}],[\"可包含一个engine\",{\"1\":{\"1561\":1}}],[\"可变的元提供了延迟绑定并且快速失败的spliterator\",{\"1\":{\"1497\":1}}],[\"可变的元提供了延迟绑定但是非快速失败的spliterator\",{\"1\":{\"1497\":1}}],[\"可变的元提供了非延迟绑定但是快速失败的spliterator\",{\"1\":{\"1497\":1}}],[\"可变的元提供了一种延迟绑定和快速失败的spliterator\",{\"1\":{\"1497\":1}}],[\"可变的元\",{\"1\":{\"1497\":1}}],[\"可变对象虽然是线程安全的\",{\"1\":{\"1403\":1}}],[\"可关联的一个无状态的一个函数\",{\"1\":{\"1485\":1}}],[\"可维护性也比较差\",{\"1\":{\"1484\":1}}],[\"可靠性\",{\"1\":{\"1453\":1}}],[\"可靠性优于可用性\",{\"1\":{\"632\":1}}],[\"可靠性优先策略\",{\"0\":{\"595\":1}}],[\"可写\",{\"1\":{\"1446\":1}}],[\"可向下执行后续阶段\",{\"1\":{\"1395\":1}}],[\"可中断\",{\"1\":{\"1371\":1}}],[\"可重入锁的实现\",{\"1\":{\"1371\":1}}],[\"可重入\",{\"1\":{\"1367\":1,\"1375\":1}}],[\"可重复读是指\",{\"1\":{\"570\":1}}],[\"可重复读是它默认的隔离级别\",{\"1\":{\"533\":1}}],[\"可重复读\",{\"1\":{\"570\":4,\"669\":1}}],[\"可重复性\",{\"1\":{\"337\":1}}],[\"可运行状态\",{\"1\":{\"1354\":1}}],[\"可是一旦大量的请求数据\",{\"1\":{\"763\":1}}],[\"可是程序中可以正常输出\",{\"1\":{\"720\":1}}],[\"可用作数据库\",{\"1\":{\"705\":1,\"1853\":1}}],[\"可用性判断\",{\"0\":{\"612\":1}}],[\"可用性就越高\",{\"1\":{\"596\":1}}],[\"可用性优先策略\",{\"0\":{\"596\":1}}],[\"可基于内存亦可持久化的日志型\",{\"1\":{\"701\":1}}],[\"可就不能使用index\",{\"1\":{\"690\":1}}],[\"可串行化\",{\"1\":{\"669\":1}}],[\"可见性展开的\",{\"1\":{\"1350\":1}}],[\"可见性\",{\"0\":{\"1348\":1},\"1\":{\"1347\":1,\"1351\":1}}],[\"可见性和有序性是通过哪些操作实现的\",{\"0\":{\"105\":1}}],[\"可见\",{\"1\":{\"599\":1,\"609\":1}}],[\"可见的行才能够用于计算\",{\"1\":{\"533\":1}}],[\"可通过该列计算查询中使用的索引的长度\",{\"1\":{\"467\":1}}],[\"可能是t类型\",{\"1\":{\"1491\":1}}],[\"可能是等i\",{\"1\":{\"525\":1}}],[\"可能不返回值\",{\"1\":{\"1488\":1}}],[\"可能初学者并不能直观的认识到\",{\"1\":{\"1472\":1}}],[\"可能延迟还更大\",{\"1\":{\"1442\":1}}],[\"可能无法应对所有的情况\",{\"1\":{\"1386\":1}}],[\"可能存在的问题\",{\"0\":{\"1048\":1}}],[\"可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描\",{\"1\":{\"694\":1}}],[\"可能更关心数据并发访问的能力\",{\"1\":{\"669\":1}}],[\"可能\",{\"1\":{\"669\":6}}],[\"可能影响到计算的准确性和完整性\",{\"1\":{\"667\":1}}],[\"可能要遍历多个索引树\",{\"1\":{\"659\":1}}],[\"可能由于发现数据问题的时间晚了一点\",{\"1\":{\"621\":1}}],[\"可能第一次轮询还不能发现\",{\"1\":{\"615\":1}}],[\"可能出现过度等待的问题\",{\"1\":{\"609\":1}}],[\"可能需要耗费好几秒的时间\",{\"1\":{\"595\":1}}],[\"可能使用的时候会比较克制\",{\"1\":{\"594\":1}}],[\"可能就会反复查询这个数据\",{\"1\":{\"523\":1}}],[\"可能就是昨天晚上的一个备份\",{\"1\":{\"464\":1}}],[\"可能还会产生大量的上下文切换以及系统调用\",{\"1\":{\"518\":1}}],[\"可能会引起冲突\",{\"1\":{\"1497\":1}}],[\"可能会造成数据不一致的问题\",{\"1\":{\"1354\":1}}],[\"可能会丢失一秒的数据\",{\"1\":{\"730\":1}}],[\"可能会丢失这一秒的数据\",{\"1\":{\"729\":1}}],[\"可能会延迟几秒才会进行计算\",{\"1\":{\"696\":1}}],[\"可能会影响客户端本地机器的性能\",{\"1\":{\"619\":1}}],[\"可能会出现数据不一致的问题\",{\"1\":{\"1351\":1}}],[\"可能会出现\",{\"1\":{\"617\":1}}],[\"可能会不止重复执行一个事务\",{\"1\":{\"604\":1}}],[\"可能会导致数据的不一致\",{\"1\":{\"1421\":1}}],[\"可能会导致buffer\",{\"1\":{\"543\":1}}],[\"可能会导致查询语句读数据的次数变多\",{\"1\":{\"487\":1}}],[\"可能会多次扫描被驱动表\",{\"1\":{\"543\":1}}],[\"可能会破坏索引值的有序性\",{\"1\":{\"503\":1}}],[\"可能在内存中完成\",{\"1\":{\"491\":1}}],[\"可能你在一些建表规范里面见到过类似的描述\",{\"1\":{\"472\":1}}],[\"可能导致主备延迟出现的原因\",{\"1\":{\"594\":1}}],[\"可能导致内存占用太大\",{\"1\":{\"455\":1}}],[\"可能导致删除出错\",{\"1\":{\"302\":1}}],[\"可以学习微服务和分布式的内容\",{\"1\":{\"1866\":1}}],[\"可以再学习vue和react等前端技术\",{\"1\":{\"1855\":1}}],[\"可以再次调用这个方法来重置sink来进行其他的计算\",{\"1\":{\"1500\":1}}],[\"可以不用学的特别细致\",{\"1\":{\"1854\":1}}],[\"可以不用做这块的项目\",{\"1\":{\"1847\":1}}],[\"可以不存储在内存\",{\"1\":{\"1365\":1}}],[\"可以辅助学习\",{\"1\":{\"1847\":1}}],[\"可以包括多个service\",{\"1\":{\"1561\":1}}],[\"可以很方便的将spring\",{\"1\":{\"1536\":1}}],[\"可以很快进入输入命令的状态\",{\"1\":{\"619\":1}}],[\"可以重复调用refresh方法的applicationcontext的执行逻辑是\",{\"1\":{\"1528\":1}}],[\"可以重置计数器\",{\"1\":{\"1373\":1}}],[\"可以根据类型或者名称进行查找\",{\"1\":{\"1524\":1}}],[\"可以根据\",{\"1\":{\"1518\":1}}],[\"可以根据某个类型获取\",{\"1\":{\"1513\":1}}],[\"可以根据某个类型获取对应的beannames\",{\"1\":{\"1513\":1}}],[\"可以根据某个bean的名字\",{\"1\":{\"1513\":1}}],[\"可以一次性获取多个资源\",{\"1\":{\"1514\":1}}],[\"可以销毁某个bean等等功能\",{\"1\":{\"1513\":1}}],[\"可以合并beandefinition\",{\"1\":{\"1513\":1}}],[\"可以添加beanpostprocessor\",{\"1\":{\"1513\":1}}],[\"可以获取运行时环境\",{\"1\":{\"1514\":1}}],[\"可以获取所有beandefinition的beannames\",{\"1\":{\"1513\":1}}],[\"可以获取最近一个fork操作的耗时\",{\"1\":{\"725\":1}}],[\"可以注册\",{\"1\":{\"1513\":1}}],[\"可以是io通道\",{\"1\":{\"1497\":1}}],[\"可以是集合\",{\"1\":{\"1497\":1}}],[\"可以是一个数组\",{\"1\":{\"1496\":1}}],[\"可以帮助客户端来判断spliterator里面是不是没有元素\",{\"1\":{\"1497\":1}}],[\"可以为我们了解stream打下良好的基础\",{\"1\":{\"1495\":1}}],[\"可以增加前缀和后缀\",{\"1\":{\"1495\":1}}],[\"可以增加负载因子loadfactor的值\",{\"1\":{\"1423\":1}}],[\"可以被省略掉\",{\"1\":{\"1494\":1}}],[\"可以直接查找到\",{\"1\":{\"1538\":1}}],[\"可以直接注册\",{\"1\":{\"1513\":1}}],[\"可以直接调用\",{\"1\":{\"1493\":1}}],[\"可以直接把binlog中记录的delete语句转为insert\",{\"1\":{\"591\":1}}],[\"可以想象\",{\"1\":{\"1476\":1}}],[\"可以多省去一次\",{\"1\":{\"1460\":1}}],[\"可以多接几个从库\",{\"1\":{\"594\":1}}],[\"可以说\",{\"1\":{\"1470\":1}}],[\"可以说为高并发服务器的开发提供了很好的支撑\",{\"1\":{\"1451\":1}}],[\"可以说是效率做到了极致\",{\"1\":{\"1350\":1}}],[\"可以构成链表\",{\"1\":{\"1430\":1}}],[\"可以构建和遍历解析树\",{\"1\":{\"650\":1}}],[\"可以降低负载因子loadfactor的值\",{\"1\":{\"1423\":1}}],[\"可以采用开放地址法和链地址法等来解决问题\",{\"1\":{\"1423\":1}}],[\"可以按照插入的顺序使用iterator遍历\",{\"1\":{\"1421\":1}}],[\"可以按照如下流程\",{\"1\":{\"559\":1}}],[\"可以按照如下思路实现\",{\"1\":{\"559\":1}}],[\"可以动态保存任意多个对象\",{\"1\":{\"1415\":1}}],[\"可以归纳为多线程if模式\",{\"1\":{\"1408\":1}}],[\"可以尝试使用copy\",{\"1\":{\"1404\":1}}],[\"可以尝试将join\",{\"1\":{\"540\":1}}],[\"可以让线程从休眠状态转换到runnable状态\",{\"1\":{\"1401\":1}}],[\"可以让mysql按照id顺序进行查询\",{\"1\":{\"531\":1}}],[\"可以轻松实现后续处理的有序性\",{\"1\":{\"1394\":1}}],[\"可以更好地利用资源\",{\"1\":{\"1387\":1}}],[\"可以更容易对数据库进行拆分\",{\"1\":{\"531\":1}}],[\"可以优先考虑synchronousqueue\",{\"1\":{\"1386\":1}}],[\"可以优化为\",{\"1\":{\"659\":1}}],[\"可以继续入队\",{\"1\":{\"1380\":1}}],[\"可以继续响应其他命令\",{\"1\":{\"725\":1}}],[\"可以近似认为是无限容量\",{\"1\":{\"1378\":1}}],[\"可以设置范围是\",{\"1\":{\"1484\":1}}],[\"可以设置阻塞时间\",{\"1\":{\"1378\":2}}],[\"可以设置为公平锁\",{\"1\":{\"1371\":1}}],[\"可以设置超时时间\",{\"1\":{\"1371\":1}}],[\"可以节省毫无意义的请求锁时间\",{\"1\":{\"1364\":1}}],[\"可以手动判断线程的中断标识位\",{\"1\":{\"1354\":1}}],[\"可以自己命名的主节点名字\",{\"1\":{\"761\":1}}],[\"可以从写时复制\",{\"1\":{\"725\":1}}],[\"可以从infomation\",{\"1\":{\"634\":1}}],[\"可以经过规则定义将其变为队列\",{\"1\":{\"708\":1}}],[\"可以改进内部编码\",{\"1\":{\"706\":1}}],[\"可以这么做\",{\"1\":{\"696\":1}}],[\"可以选择的连接顺序有两种\",{\"1\":{\"692\":1}}],[\"可以先忽略掉\",{\"1\":{\"690\":1}}],[\"可以看极客时间的专栏\",{\"1\":{\"1852\":1}}],[\"可以看\",{\"1\":{\"1852\":1,\"1870\":1}}],[\"可以看出来这个n\",{\"1\":{\"695\":1}}],[\"可以看见全表扫描的成本\",{\"1\":{\"681\":1}}],[\"可以看到后续的异常都被压制了\",{\"1\":{\"1496\":1}}],[\"可以看到虽然抛出了异常\",{\"1\":{\"1496\":1}}],[\"可以看到supplier\",{\"1\":{\"1494\":1}}],[\"可以看到我们实际上使用的分割迭代器是iteratorspliterator\",{\"1\":{\"1498\":1}}],[\"可以看到我们在调用filter方法之后\",{\"1\":{\"1487\":1}}],[\"可以看到我们其实只定义了一个函数\",{\"1\":{\"1475\":1}}],[\"可以看到这两个成员变量可以认为是互斥的\",{\"1\":{\"1498\":1}}],[\"可以看到这是一个静态方法\",{\"1\":{\"1484\":1}}],[\"可以看到这是一个函数式接口\",{\"1\":{\"1480\":1}}],[\"可以看到这个方法返回的是包含最小值\",{\"1\":{\"1484\":1}}],[\"可以看到这个接口从jdk8开始就加上了\",{\"1\":{\"1471\":1}}],[\"可以看到这个接口上有一个\",{\"1\":{\"1471\":1}}],[\"可以看到这个语句的执行不再需要临时表\",{\"1\":{\"554\":1}}],[\"可以看到其接收comparator作为参数\",{\"1\":{\"1480\":1}}],[\"可以看到list\",{\"1\":{\"1470\":1}}],[\"可以看到每当有新的连接接入\",{\"1\":{\"1450\":1}}],[\"可以看到put方法本身也是调用putval方法\",{\"1\":{\"1431\":1}}],[\"可以看到还有一部分日志\",{\"1\":{\"609\":1}}],[\"可以看到实例x的executed\",{\"1\":{\"605\":1}}],[\"可以看到trx1\",{\"1\":{\"601\":1}}],[\"可以看到λ越小越好\",{\"1\":{\"540\":1}}],[\"可以看到extra字段里面多了\",{\"1\":{\"493\":1}}],[\"可以看到旋转操作不会影响旋转结点的父结点\",{\"1\":{\"343\":1}}],[\"可以看到\",{\"1\":{\"307\":1,\"456\":1,\"464\":1,\"474\":1,\"476\":2,\"482\":1,\"483\":1,\"484\":3,\"493\":2,\"505\":1,\"533\":1,\"538\":2,\"540\":2,\"547\":1,\"551\":3,\"554\":2,\"561\":1,\"562\":2,\"583\":1,\"584\":1,\"587\":1,\"590\":1,\"591\":6,\"594\":1,\"595\":1,\"596\":1,\"597\":1,\"599\":1,\"601\":1,\"602\":1,\"605\":1,\"609\":1,\"617\":1,\"618\":1,\"627\":1,\"628\":2,\"629\":1,\"631\":1,\"634\":1,\"695\":1,\"1468\":1,\"1471\":1,\"1472\":1,\"1474\":1,\"1486\":1,\"1487\":1,\"1488\":1,\"1492\":1}}],[\"可以基于以下实例来分析行锁\",{\"1\":{\"672\":1}}],[\"可以总结一下\",{\"1\":{\"662\":1}}],[\"可以适当增大max\",{\"1\":{\"657\":1}}],[\"可以适当将max\",{\"1\":{\"657\":1}}],[\"可以有效的减少索引下推优化后\",{\"1\":{\"655\":1}}],[\"可以有多个子节点\",{\"1\":{\"301\":1}}],[\"可以放更多的索引\",{\"1\":{\"640\":1}}],[\"可以忽略不计\",{\"1\":{\"636\":1}}],[\"可以指定这个备库持续保持跟主库有n秒的延迟\",{\"1\":{\"623\":1}}],[\"可以开始\",{\"1\":{\"618\":1}}],[\"可以执行\",{\"1\":{\"616\":1}}],[\"可以避免过期读\",{\"1\":{\"609\":1}}],[\"可以避免每次查询需要搜索两棵树\",{\"1\":{\"472\":1}}],[\"可以保证两个worker不会更新同一行\",{\"1\":{\"598\":1}}],[\"可以如下处理\",{\"1\":{\"594\":1}}],[\"可以提升性能\",{\"1\":{\"587\":1}}],[\"可以减少线程数据了\",{\"1\":{\"720\":1}}],[\"可以减少trx\",{\"1\":{\"634\":1}}],[\"可以减少锁等待的个数\",{\"1\":{\"581\":1}}],[\"可以减少冗余记录的查询\",{\"1\":{\"531\":1}}],[\"可以考虑这种策略\",{\"1\":{\"1397\":1}}],[\"可以考虑思路2\",{\"1\":{\"629\":1}}],[\"可以考虑调整这两个参数值\",{\"1\":{\"602\":1}}],[\"可以考虑放在多条记录上\",{\"1\":{\"581\":1}}],[\"可以考虑通过将一行改成逻辑上的多行来减少锁冲突\",{\"1\":{\"581\":1}}],[\"可以查询到当前执行中的事务\",{\"1\":{\"578\":1}}],[\"可以查看以下信息\",{\"1\":{\"466\":1}}],[\"可以创建普通列和索引\",{\"1\":{\"554\":1}}],[\"可以完全存入\",{\"1\":{\"544\":1}}],[\"可以得到足够多的主键id\",{\"1\":{\"541\":1}}],[\"可以分解成下面这些查询来代替\",{\"1\":{\"531\":1}}],[\"可以对每一个表进行一次单表查询\",{\"1\":{\"531\":1}}],[\"可以认为它们是对fsync的统计\",{\"1\":{\"616\":1}}],[\"可以认为它就是一个数组\",{\"1\":{\"557\":1}}],[\"可以认为就只扫描了3行\",{\"1\":{\"559\":1}}],[\"可以认为是每次中间结果容器的类型\",{\"1\":{\"1492\":1}}],[\"可以认为是生命周期中最重要的阶段\",{\"1\":{\"518\":1}}],[\"可以认为是分裂过程的逆过程\",{\"1\":{\"472\":1}}],[\"可以认为每次查询的平均扫描行数接近1\",{\"1\":{\"489\":1}}],[\"可以\",{\"1\":{\"489\":1,\"1538\":1}}],[\"可以利用覆盖索引\",{\"1\":{\"488\":1}}],[\"可以利用索引的\",{\"1\":{\"476\":1}}],[\"可以发现当变量被volitle关键字修饰后\",{\"1\":{\"1350\":1}}],[\"可以发现\",{\"1\":{\"487\":1,\"492\":1,\"505\":1,\"544\":1,\"1425\":1,\"1460\":1,\"1534\":1}}],[\"可以定义字符串的一部分作为索引\",{\"1\":{\"487\":1}}],[\"可以通过这个集合查找到正在创建的bean\",{\"1\":{\"1526\":1}}],[\"可以通过非常简单的方式\",{\"1\":{\"1484\":1}}],[\"可以通过lambda表达式来创建\",{\"1\":{\"1471\":1}}],[\"可以通过它读取和写入数据\",{\"1\":{\"1451\":1}}],[\"可以通过修改宏定义甚至重新编译内核的方式提升这一限制\",{\"1\":{\"1446\":1}}],[\"可以通过遍历fdset\",{\"1\":{\"1446\":1}}],[\"可以通过jvm参数xx\",{\"1\":{\"1362\":1}}],[\"可以通过unsafe来cas操作它的值\",{\"1\":{\"1357\":1}}],[\"可以通过脚本来通知管理员\",{\"1\":{\"761\":1}}],[\"可以通过将这个值设为\",{\"1\":{\"761\":1}}],[\"可以通过下面的sql语句查询数据的行锁的情况\",{\"1\":{\"675\":1}}],[\"可以通过开发管理系统得到支持\",{\"1\":{\"624\":1}}],[\"可以通过设定阈值\",{\"1\":{\"616\":1}}],[\"可以通过设置exposeproxy=true\",{\"1\":{\"1531\":1}}],[\"可以通过设置autowire=\",{\"1\":{\"1527\":1}}],[\"可以通过设置socket使其变为non\",{\"1\":{\"1441\":1}}],[\"可以通过设置binlog\",{\"1\":{\"588\":1}}],[\"可以通过设置参数innodb\",{\"1\":{\"484\":1}}],[\"可以通过哪些方法来提升性能呢\",{\"1\":{\"588\":1}}],[\"可以通过如下命令来查看\",{\"1\":{\"491\":1}}],[\"可以通过explain的rows列来查看\",{\"1\":{\"484\":1}}],[\"可以通过参数innodb\",{\"1\":{\"480\":1,\"581\":1}}],[\"可以在业务逻辑里面判断是否返回0\",{\"1\":{\"1375\":1}}],[\"可以在sort\",{\"1\":{\"657\":1}}],[\"可以在show\",{\"1\":{\"568\":1}}],[\"可以在索引遍历过程中\",{\"1\":{\"655\":1}}],[\"可以在索引遍历的过程中\",{\"1\":{\"477\":1}}],[\"可以在delete语句中加上where条件\",{\"1\":{\"621\":1}}],[\"可以在备库上执行show\",{\"1\":{\"594\":1}}],[\"可以在中间件中实现\",{\"1\":{\"581\":1}}],[\"可以在information\",{\"1\":{\"571\":1}}],[\"可以在每次执行一个比较大的操作后\",{\"1\":{\"455\":1}}],[\"可以快速定位到id4\",{\"1\":{\"476\":1}}],[\"可以将磁盘数据通过dma拷贝到内核态buffer后\",{\"1\":{\"1453\":1}}],[\"可以将锁消除\",{\"1\":{\"1364\":1}}],[\"可以将一个hash表作为一个对象进行存储\",{\"1\":{\"710\":1}}],[\"可以将其中的每个字典都理解成一个独立的数据库\",{\"1\":{\"704\":1}}],[\"可以将不可能用时间几乎降为0\",{\"1\":{\"595\":1}}],[\"可以将拼接sql语句的方法写在应用程序中\",{\"1\":{\"559\":1}}],[\"可以将参数query\",{\"1\":{\"456\":1}}],[\"可以将空间复杂度优化到o\",{\"1\":{\"429\":1}}],[\"可以使用flags来优化sink\",{\"1\":{\"1500\":1}}],[\"可以使用lambda表达式来替代匿名内部类完成相同的功能\",{\"1\":{\"1469\":1}}],[\"可以使用命令\",{\"1\":{\"591\":1}}],[\"可以使用这个命令\",{\"1\":{\"574\":1}}],[\"可以使用如下方法创建一个列z\",{\"1\":{\"554\":1}}],[\"可以使用如下sql语句\",{\"1\":{\"505\":1}}],[\"可以使用各种引擎类型\",{\"1\":{\"546\":1}}],[\"可以使用一个redis服务来保存这个表的总行数\",{\"1\":{\"534\":1}}],[\"可以使用synchroized来解决临界区资源共享的问题\",{\"1\":{\"1359\":1}}],[\"可以使用select\",{\"1\":{\"549\":1,\"704\":1}}],[\"可以使用sql\",{\"1\":{\"456\":1}}],[\"可以使用show\",{\"1\":{\"455\":1,\"570\":1}}],[\"可以使用暴力破解法\",{\"1\":{\"386\":1}}],[\"可以二分升序数组的下标\",{\"1\":{\"443\":1}}],[\"可以确定右边界\",{\"1\":{\"428\":1}}],[\"可以确定动态规划的边界条件\",{\"1\":{\"428\":1}}],[\"可以拆除连接\",{\"1\":{\"395\":1}}],[\"可以唯一确定一颗二叉树\",{\"1\":{\"339\":2}}],[\"可以用在结果容器不要求有序的场景下\",{\"1\":{\"1494\":1}}],[\"可以用在以下这些方面\",{\"1\":{\"761\":1}}],[\"可以用如下流程图来描述\",{\"1\":{\"1457\":1,\"1459\":1,\"1460\":1,\"1461\":1}}],[\"可以用collections的synchronizedmap方法使hashmap具有线程安全的能力\",{\"1\":{\"1421\":1}}],[\"可以用current\",{\"1\":{\"666\":1}}],[\"可以用来实现内存映射\",{\"1\":{\"1464\":1}}],[\"可以用来实现一个依赖状态的同步器\",{\"1\":{\"1367\":1}}],[\"可以用来重新统计索引信息\",{\"1\":{\"484\":1}}],[\"可以用flashback工具通过闪回把数据恢复回来\",{\"1\":{\"621\":1}}],[\"可以用readonly状态\",{\"1\":{\"590\":1}}],[\"可以用unlock\",{\"1\":{\"577\":1}}],[\"可以用于生产者\",{\"1\":{\"1396\":1}}],[\"可以用于sql的调优的测量\",{\"1\":{\"568\":1}}],[\"可以用于提高读写效率的数据结构有很多中\",{\"1\":{\"468\":1}}],[\"可以用于检索一个元素是否在一个集合中\",{\"1\":{\"307\":1}}],[\"可以用两个队列\",{\"1\":{\"334\":1}}],[\"可以用两个栈\",{\"1\":{\"333\":1}}],[\"可读性\",{\"1\":{\"282\":1}}],[\"输完命令之后\",{\"1\":{\"455\":1}}],[\"输出种类\",{\"1\":{\"1500\":1}}],[\"输出是\",{\"1\":{\"1356\":1}}],[\"输出是与之对应的可读可写事件\",{\"1\":{\"740\":1}}],[\"输出的eax是\",{\"1\":{\"1356\":1}}],[\"输出\",{\"1\":{\"282\":1,\"491\":1,\"558\":1}}],[\"输入类型是t\",{\"1\":{\"1495\":1}}],[\"输入你想说的话\",{\"1\":{\"1450\":1,\"1451\":1,\"1452\":1}}],[\"输入的exchange\",{\"1\":{\"1356\":1}}],[\"输入是\",{\"1\":{\"1356\":1}}],[\"输入是读写描述符列表read\",{\"1\":{\"740\":1}}],[\"输入前缀\",{\"1\":{\"619\":1}}],[\"输入\",{\"1\":{\"282\":1}}],[\"并赋予默认值\",{\"1\":{\"1540\":1}}],[\"并判断当前某个bean是否有匹配的advisor\",{\"1\":{\"1532\":1}}],[\"并添加到beanfactory的beanpostprocessors属性中去\",{\"1\":{\"1528\":1}}],[\"并获取类上的注解信息\",{\"1\":{\"1523\":1}}],[\"并获取了类名\",{\"1\":{\"1523\":1}}],[\"并提供了一些工具类\",{\"1\":{\"1523\":1}}],[\"并提供多种语言的api\",{\"1\":{\"701\":1}}],[\"并注册到applicationcontext中\",{\"1\":{\"1509\":1}}],[\"并设置得比初始值要大\",{\"1\":{\"1541\":1}}],[\"并设置beanclass为user\",{\"1\":{\"1509\":1}}],[\"并设置新的值\",{\"1\":{\"707\":1}}],[\"并放入spring容器中\",{\"1\":{\"1509\":1}}],[\"并放大的\",{\"1\":{\"1497\":1}}],[\"并生成构造方法\",{\"1\":{\"1490\":1}}],[\"并生成无参构造方法和setter及getter方法\",{\"1\":{\"1477\":1}}],[\"并流行并不一定就比串行流的效率高\",{\"1\":{\"1489\":1}}],[\"并与当前对象进行比较\",{\"1\":{\"1482\":1}}],[\"并更新sizectl的值\",{\"1\":{\"1431\":1}}],[\"并更新内存\",{\"1\":{\"461\":1}}],[\"并对null做处理\",{\"1\":{\"1426\":1}}],[\"并最终使用locksupport\",{\"1\":{\"1397\":1}}],[\"并让出cpu\",{\"1\":{\"1397\":1}}],[\"并让线程们重新执行一次\",{\"1\":{\"1373\":1}}],[\"并在此基础上进行了丰富地扩展\",{\"1\":{\"1395\":1}}],[\"并在java8中得到广泛应用\",{\"1\":{\"1387\":1}}],[\"并保存future到futures\",{\"1\":{\"1394\":1}}],[\"并保存价格\",{\"1\":{\"1394\":1}}],[\"并保存最近15次的运行结果\",{\"1\":{\"568\":1}}],[\"并期望它们全部执行结束后执行特定动作\",{\"1\":{\"1393\":1}}],[\"并减少竞争\",{\"1\":{\"1391\":1}}],[\"并根据设定将这些任务拆分为粒度更细的子任务\",{\"1\":{\"1387\":1}}],[\"并根据以前的结果对当前进行选择\",{\"1\":{\"293\":1}}],[\"并唤醒第一个线程\",{\"1\":{\"1360\":1}}],[\"并清除中断标志位\",{\"1\":{\"1354\":1}}],[\"并清空binlog\",{\"1\":{\"587\":1}}],[\"并通知应用方\",{\"1\":{\"758\":1}}],[\"并将用户头像等信息存于七牛云服务器\",{\"1\":{\"1865\":1}}],[\"并将container处理的结果返回给外部\",{\"1\":{\"1565\":1}}],[\"并将任务添加到任务队列中\",{\"1\":{\"1412\":1}}],[\"并将其加入到clh同步队列\",{\"1\":{\"1368\":1}}],[\"并将结果保存到\",{\"1\":{\"715\":1}}],[\"并将它抓取出来\",{\"1\":{\"567\":1}}],[\"并集\",{\"1\":{\"709\":1}}],[\"并返回一个结果\",{\"1\":{\"1475\":1,\"1477\":1}}],[\"并返回0\",{\"1\":{\"710\":1}}],[\"并返回增量后结果\",{\"1\":{\"710\":1}}],[\"并返回\",{\"1\":{\"707\":1,\"708\":2}}],[\"并返回结果给客户端\",{\"1\":{\"518\":1}}],[\"并发参考手册\",{\"1\":{\"1870\":1}}],[\"并发编程视频\",{\"1\":{\"1870\":1}}],[\"并发编程实战\",{\"1\":{\"1870\":1}}],[\"并发编程的艺术\",{\"1\":{\"1846\":1,\"1870\":1}}],[\"并发编程的三要素\",{\"0\":{\"49\":1}}],[\"并发框架\",{\"1\":{\"1870\":1}}],[\"并发方面\",{\"1\":{\"1870\":1}}],[\"并发消费\",{\"0\":{\"1738\":1,\"1778\":1}}],[\"并发的可达性分析\",{\"0\":{\"1640\":1}}],[\"并发的副作用就越小\",{\"1\":{\"669\":1}}],[\"并发重置\",{\"0\":{\"1616\":1}}],[\"并发清理\",{\"0\":{\"1615\":1}}],[\"并发标记\",{\"0\":{\"1611\":1}}],[\"并发流与串行流的区别并不是很大\",{\"1\":{\"1489\":1}}],[\"并发设计模式\",{\"0\":{\"1399\":1}}],[\"并发执行多任务\",{\"1\":{\"1393\":1}}],[\"并发安全的hashmap主要有两个\",{\"1\":{\"1352\":1}}],[\"并发要解决的三大问题\",{\"1\":{\"1347\":1}}],[\"并发三大特性\",{\"1\":{\"1347\":1}}],[\"并发与并行\",{\"1\":{\"1347\":1}}],[\"并发度最高\",{\"1\":{\"672\":1}}],[\"并发度最低\",{\"1\":{\"671\":1}}],[\"并发\",{\"1\":{\"669\":1,\"1347\":1}}],[\"并发事务处理带来的问题\",{\"1\":{\"669\":1}}],[\"并发线程的计数会减一\",{\"1\":{\"613\":1}}],[\"并发连接数达到几千个影响并不大\",{\"1\":{\"613\":1}}],[\"并发连接和并发查询并不是同一个概念\",{\"1\":{\"613\":1}}],[\"并反馈给客户端\",{\"1\":{\"609\":1}}],[\"并加1\",{\"1\":{\"605\":1}}],[\"并稳定执行一段时间之后\",{\"1\":{\"604\":1}}],[\"并行或者串行\",{\"1\":{\"1500\":1}}],[\"并行的方式\",{\"1\":{\"1500\":1}}],[\"并行的\",{\"1\":{\"1497\":1}}],[\"并行的事务提交的时候\",{\"1\":{\"588\":1}}],[\"并行操作\",{\"1\":{\"1492\":1}}],[\"并行执行\",{\"1\":{\"1395\":1}}],[\"并行执行以下3个查询服务\",{\"1\":{\"1394\":1}}],[\"并行\",{\"1\":{\"1347\":1,\"1395\":1}}],[\"并行复制\",{\"0\":{\"597\":1}}],[\"并初始化几行数据\",{\"1\":{\"591\":1}}],[\"并执行\",{\"1\":{\"590\":1}}],[\"并没有返回相同的类型的对象\",{\"1\":{\"1492\":1}}],[\"并没有结构上的用处\",{\"1\":{\"1431\":1}}],[\"并没有更改原字符串里面value\",{\"1\":{\"1404\":1}}],[\"并没有持久化\",{\"1\":{\"627\":1}}],[\"并没有去判断线程的状态\",{\"1\":{\"618\":1}}],[\"并没有数据持久化到磁盘\",{\"1\":{\"587\":1}}],[\"并没有给id=0这行加上锁\",{\"1\":{\"584\":1}}],[\"并没有使用trade\",{\"1\":{\"505\":1}}],[\"并insert一条记录\",{\"1\":{\"580\":1}}],[\"并记为c\",{\"1\":{\"559\":1}}],[\"并按照m的结果排序后输出\",{\"1\":{\"553\":1}}],[\"并按照id的值回到原表中取出city\",{\"1\":{\"492\":1}}],[\"并删除临时表\",{\"1\":{\"551\":1}}],[\"并存入临时表中\",{\"1\":{\"551\":1}}],[\"并利用这个线程id来构造临时表的table\",{\"1\":{\"550\":1}}],[\"并继续循环\",{\"1\":{\"541\":1}}],[\"并作为结果返回\",{\"1\":{\"541\":1}}],[\"并可以大概推算出查询运行的时间\",{\"1\":{\"524\":1}}],[\"并增加网络开销\",{\"1\":{\"519\":1}}],[\"并用最小的代价去执行语句\",{\"1\":{\"484\":1}}],[\"并分别建立索引\",{\"1\":{\"483\":1}}],[\"并非实际使用长度\",{\"1\":{\"467\":1}}],[\"并不具有实用性\",{\"1\":{\"1497\":1}}],[\"并不需要等待\",{\"1\":{\"1441\":1}}],[\"并不复制整个进程的地址空间\",{\"1\":{\"1404\":1}}],[\"并不等待从节点复制完成\",{\"1\":{\"755\":1}}],[\"并不影响我们大方向上的分析\",{\"1\":{\"685\":1}}],[\"并不敏感\",{\"1\":{\"669\":1}}],[\"并不能保证不可变性\",{\"1\":{\"1403\":1}}],[\"并不能保证它的索引列值是唯一的\",{\"1\":{\"695\":1}}],[\"并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中\",{\"1\":{\"694\":1}}],[\"并不能说明主库没问题\",{\"1\":{\"613\":1}}],[\"并不能精确地知道满足这个条件的记录有多少条\",{\"1\":{\"484\":1}}],[\"并不是所有的都需要实例化\",{\"1\":{\"1525\":1}}],[\"并不是所有场景中可以通过加索引来完成group\",{\"1\":{\"555\":1}}],[\"并不是对于集合中所有的元素先调用第一个filter方法\",{\"1\":{\"1488\":1}}],[\"并不是匿名内部类的语法糖或者另一种表达形式\",{\"1\":{\"1469\":1}}],[\"并不是非常耐久\",{\"1\":{\"729\":1}}],[\"并不是精确的\",{\"1\":{\"690\":1}}],[\"并不是这样的\",{\"1\":{\"629\":1}}],[\"并不是将这个记录本身从磁盘读出来\",{\"1\":{\"479\":1}}],[\"并不会触发这个缓存\",{\"1\":{\"1525\":1}}],[\"并不会导致主备延迟的值不准确\",{\"1\":{\"594\":1}}],[\"并不会导致过多的访问磁盘\",{\"1\":{\"557\":1}}],[\"并不会影响这个算法的时间复杂度\",{\"1\":{\"540\":1}}],[\"并不会覆盖以前的日志\",{\"1\":{\"462\":1}}],[\"并不多\",{\"1\":{\"526\":1}}],[\"并不只是误操作以后需要用这个过程来恢复数据\",{\"1\":{\"464\":1}}],[\"并把数据存储到内核缓冲区\",{\"1\":{\"1457\":1}}],[\"并把其值置空\",{\"1\":{\"1380\":1}}],[\"并把head下一个节点作为新的值\",{\"1\":{\"1380\":1}}],[\"并把语句改为id\",{\"1\":{\"553\":1}}],[\"并把binlog写入磁盘\",{\"1\":{\"463\":1}}],[\"并把key1和key2称为这个散列函数的同义词\",{\"1\":{\"332\":1}}],[\"并查集的操作\",{\"1\":{\"356\":1}}],[\"并查集\",{\"1\":{\"356\":1}}],[\"并且给每个web应用创建一个类加载器实例\",{\"1\":{\"1571\":1}}],[\"并且tomcat本身也是一个java程序\",{\"1\":{\"1571\":1}}],[\"并且检查这个符号引用代表的类是否已经被加载\",{\"1\":{\"1543\":1}}],[\"并且检测是否需要扩容\",{\"1\":{\"1431\":1}}],[\"并且赋值给sqlsession属性\",{\"1\":{\"1530\":1}}],[\"并且提供获取bean的api\",{\"1\":{\"1513\":1}}],[\"并且会解析该类上的注解\",{\"1\":{\"1510\":1}}],[\"并且会调用arrays中的stream方法\",{\"1\":{\"1484\":1}}],[\"并且将结果传递给提供的sink\",{\"1\":{\"1500\":1}}],[\"并且这部分内容面试也经常被问到\",{\"1\":{\"1847\":1}}],[\"并且这两种情况是互斥的\",{\"1\":{\"1499\":1}}],[\"并且这是一个终止操作\",{\"1\":{\"1499\":1}}],[\"并且这个集合不包含任何元素\",{\"1\":{\"1497\":1}}],[\"并且这个容器是通过更新结果的状态来进行合并的\",{\"1\":{\"1485\":1}}],[\"并且这个命令执行的速度较快\",{\"1\":{\"533\":1}}],[\"并且计算起来成本也不高\",{\"1\":{\"1497\":1}}],[\"并且还没有被分割或者迭代\",{\"1\":{\"1497\":1}}],[\"并且还可以通过isparallel\",{\"1\":{\"1496\":1}}],[\"并且使用spliterator的supplier重写stream和parallelstream方法\",{\"1\":{\"1497\":1}}],[\"并且使用哪个索引是由mysql来确定的\",{\"1\":{\"483\":1}}],[\"并且只接受一个参数\",{\"1\":{\"1495\":1}}],[\"并且只有当部分完成之后猜会进行合并的操作\",{\"1\":{\"1492\":1}}],[\"并且只有在mysql8\",{\"1\":{\"627\":1}}],[\"并且最终返回的结果也是set类型\",{\"1\":{\"1495\":1}}],[\"并且都是主线程的\",{\"1\":{\"1494\":1}}],[\"并且由于调用了reversed获取了新的比较器\",{\"1\":{\"1491\":1}}],[\"并且姓名这个字段会作为分组的key\",{\"1\":{\"1490\":1}}],[\"并且针对具体的操作\",{\"1\":{\"1488\":1}}],[\"并且流在调用的时候\",{\"1\":{\"1488\":1}}],[\"并且从易读性上而言\",{\"1\":{\"1488\":1}}],[\"并且对流中的每个元素都执行给定的动作\",{\"1\":{\"1500\":1}}],[\"并且对每个元素进行操作\",{\"1\":{\"1500\":1}}],[\"并且对于空的集合\",{\"1\":{\"1497\":1}}],[\"并且对于结果进行最终的转换\",{\"1\":{\"1492\":1}}],[\"并且对于流的操作也有短路的特性\",{\"1\":{\"1489\":1}}],[\"并且对年龄进行降序排序\",{\"1\":{\"1488\":1}}],[\"并且对延时有比较严格的要求\",{\"1\":{\"1397\":1}}],[\"并且也是一个终止操作\",{\"1\":{\"1485\":1}}],[\"并且没有设置过concurrent特性的时候才会创建和流中元素个数相同的中间结果容器\",{\"1\":{\"1494\":1}}],[\"并且没有返回值的函数式接口\",{\"1\":{\"1485\":1}}],[\"并且没有什么实质危害\",{\"1\":{\"634\":1}}],[\"并且调用foreach\",{\"1\":{\"1484\":1}}],[\"并且调用它的foreach\",{\"1\":{\"1484\":1}}],[\"并且调用了streamsupport这个类中的stream\",{\"1\":{\"1470\":1}}],[\"并且实现了操作的时候要使用的方法\",{\"1\":{\"1498\":1}}],[\"并且实现myinterface2\",{\"1\":{\"1484\":1}}],[\"并且实时备份binlog\",{\"1\":{\"622\":1}}],[\"并且接收两个相同类型的参数\",{\"1\":{\"1480\":1}}],[\"并且返回的结果要求带有排序的功能\",{\"1\":{\"1495\":1}}],[\"并且返回它们\",{\"1\":{\"1492\":1}}],[\"并且返回了一个map集合\",{\"1\":{\"1490\":1}}],[\"并且返回了不同类型的结果\",{\"1\":{\"1478\":1}}],[\"并且返回一个sink\",{\"1\":{\"1500\":1}}],[\"并且返回一个串行流\",{\"1\":{\"1497\":1}}],[\"并且返回一个结果\",{\"1\":{\"1480\":1,\"1500\":1}}],[\"并且返回一个int值\",{\"1\":{\"1480\":1}}],[\"并且返回一个泛型t类型的对象\",{\"1\":{\"1477\":1}}],[\"并且生成与运算对象相同类型的结果类型\",{\"1\":{\"1478\":1}}],[\"并且如果这个抽象方法是object类中的方法\",{\"1\":{\"1471\":1}}],[\"并且又再次收到了用户进程的system\",{\"1\":{\"1441\":1}}],[\"并且结束循环\",{\"1\":{\"1431\":1}}],[\"并且工作线程之间可以窃取彼此之间的任务\",{\"1\":{\"1387\":1}}],[\"并且根据缓存一执行协议\",{\"1\":{\"1350\":1}}],[\"并且所有缓冲的写操作写回内存\",{\"1\":{\"1350\":1}}],[\"并且保证数据尽量不丢失\",{\"1\":{\"758\":1}}],[\"并且redis事务没有隔离级别的概念\",{\"1\":{\"715\":1}}],[\"并且是线程安全的\",{\"1\":{\"1421\":1}}],[\"并且是阻塞的\",{\"1\":{\"1393\":1}}],[\"并且是可执行的\",{\"1\":{\"761\":1}}],[\"并且是很小的\",{\"1\":{\"714\":1}}],[\"并且是采用\",{\"1\":{\"464\":1}}],[\"并且dbsize\",{\"1\":{\"704\":1}}],[\"并且更新innodb\",{\"1\":{\"696\":1}}],[\"并且自动重新统计数据的功能是打开的\",{\"1\":{\"696\":1}}],[\"并且可以被并行的使用\",{\"1\":{\"1497\":1}}],[\"并且可以通过如下语句查询\",{\"1\":{\"685\":1}}],[\"并且可以用上被驱动表的索引\",{\"1\":{\"538\":1}}],[\"并且用两个隐藏字段trx\",{\"1\":{\"679\":1}}],[\"并且用a\",{\"1\":{\"615\":1}}],[\"并且能使用auto\",{\"1\":{\"665\":1}}],[\"并且join\",{\"1\":{\"662\":1}}],[\"并且推荐使用整型的自增主键\",{\"1\":{\"642\":1}}],[\"并且在绑定之后\",{\"1\":{\"1497\":1}}],[\"并且在这个类中\",{\"1\":{\"1491\":1}}],[\"并且在很多情况下能够利用并行运行的代码\",{\"1\":{\"1468\":1}}],[\"并且在此基础上设计好的哈希算法来减少哈希碰撞\",{\"1\":{\"1423\":1}}],[\"并且在此基础上实现了master\",{\"1\":{\"701\":1}}],[\"并且在spring\",{\"1\":{\"720\":1}}],[\"并且在1小时内发现了这个误操作命令\",{\"1\":{\"623\":1}}],[\"并且在超时时间n秒未达到之前就返回给了检测系统\",{\"1\":{\"615\":1}}],[\"并且在k上有索引\",{\"1\":{\"472\":1}}],[\"并且已经回复给客户端\",{\"1\":{\"609\":1}}],[\"并且已经执行完成了\",{\"1\":{\"609\":1}}],[\"并且已经将binlog传给了a\",{\"1\":{\"604\":1}}],[\"并且需要调整数据库连接信息\",{\"1\":{\"606\":1}}],[\"并且需要在临时表上排序\",{\"1\":{\"557\":1}}],[\"并且整体架构简单\",{\"1\":{\"606\":1}}],[\"并且此时在实例y上执行下面的这条插入语句\",{\"1\":{\"605\":1}}],[\"并且各个db的压力均衡\",{\"1\":{\"600\":1}}],[\"并且有返回值\",{\"1\":{\"1490\":1}}],[\"并且有以下限制\",{\"1\":{\"599\":1}}],[\"并且有三个用户并行的会话\",{\"1\":{\"533\":1}}],[\"并且设置备库breadonly=false\",{\"1\":{\"596\":1}}],[\"并且让备库可以读写\",{\"1\":{\"596\":1}}],[\"并且做对称部署\",{\"1\":{\"594\":1}}],[\"并且语句中有limit\",{\"1\":{\"591\":1}}],[\"并且记录了xid=61\",{\"1\":{\"591\":1}}],[\"并且并不是每次生成后都会持久化到磁盘中\",{\"1\":{\"588\":1}}],[\"并且把这个随机小数和word分别存入临时表的r和w字段中\",{\"1\":{\"557\":1}}],[\"并且\",{\"1\":{\"557\":1,\"583\":1,\"605\":1,\"624\":1,\"629\":1,\"664\":1,\"733\":1}}],[\"并且f是主键字段\",{\"1\":{\"551\":1}}],[\"并且查询语句如下\",{\"1\":{\"548\":1}}],[\"并且查找不会破坏树的平衡\",{\"1\":{\"344\":1}}],[\"并且每个元素会调用accumulator方法一次\",{\"1\":{\"1492\":1}}],[\"并且每个dubbo请求和响应中都有一个请求id\",{\"1\":{\"798\":1}}],[\"并且每个值的分布概率大约为50\",{\"1\":{\"496\":1}}],[\"并且每条指令表示一个或多个操作\",{\"1\":{\"282\":1}}],[\"并且额外确保了\",{\"1\":{\"493\":1}}],[\"并且按照姓名排序返回前1000个人的姓名\",{\"1\":{\"490\":1}}],[\"并且mysql又选错了索引\",{\"1\":{\"484\":1}}],[\"并且innodb使用了b+树索引模型\",{\"1\":{\"472\":1}}],[\"并且排序之后相同的字符串添加到列表中\",{\"1\":{\"380\":1}}],[\"并且2\",{\"1\":{\"347\":1}}],[\"并且里面值都为默认值\",{\"1\":{\"329\":1}}],[\"号称有十三种核心技术\",{\"1\":{\"280\":1}}],[\"饿汉式\",{\"0\":{\"275\":1}}],[\"ｍｑ有什么用\",{\"0\":{\"252\":1}}],[\"雪花算法有什么缺点\",{\"0\":{\"248\":1}}],[\"熔断和限流有什么区别\",{\"0\":{\"247\":1}}],[\"怎样让数据库恢复到半个月内任意一秒的状态\",{\"1\":{\"464\":1}}],[\"怎样设计出高内聚\",{\"0\":{\"235\":1}}],[\"怎么做取决于调用者\",{\"1\":{\"1476\":1}}],[\"怎么从内存中和从磁盘上读取一个块的默认成本是一样的\",{\"1\":{\"694\":1}}],[\"怎么衡量使用idx\",{\"1\":{\"692\":1}}],[\"怎么拆分微服务\",{\"0\":{\"235\":1}}],[\"怎么保证事务一致性\",{\"0\":{\"234\":1}}],[\"怎么保证线程安全\",{\"0\":{\"53\":1}}],[\"怎么注入\",{\"0\":{\"190\":1}}],[\"怎么解决\",{\"0\":{\"134\":1}}],[\"怎么查看一个java进程的jvm参数\",{\"0\":{\"129\":1}}],[\"怎么样确定一个对象不是垃圾\",{\"0\":{\"111\":1}}],[\"都采用它\",{\"1\":{\"1864\":1}}],[\"都放到子容器中\",{\"1\":{\"1538\":1}}],[\"都应该使用lambda表达式\",{\"1\":{\"1469\":1}}],[\"都应该选择可靠性策略\",{\"1\":{\"596\":1}}],[\"都能做到游刃有余\",{\"1\":{\"1468\":1}}],[\"都能够正确地更新到test库的表t\",{\"1\":{\"591\":1}}],[\"都支持可重入\",{\"1\":{\"1371\":1}}],[\"都属于悲观锁\",{\"1\":{\"670\":1}}],[\"都将当前的dict\",{\"1\":{\"632\":1}}],[\"都将依赖于此时读到的权限\",{\"1\":{\"455\":1}}],[\"都确保了备库已经收到了这个日志\",{\"1\":{\"609\":1}}],[\"都比判断seconds\",{\"1\":{\"609\":1}}],[\"都遵循了这两条基本原则\",{\"1\":{\"597\":1}}],[\"都已经被持久化磁盘\",{\"1\":{\"588\":1}}],[\"都写完redo\",{\"1\":{\"588\":1}}],[\"都变成了\",{\"1\":{\"584\":1}}],[\"都被锁住导致表完全不可读写\",{\"1\":{\"578\":1}}],[\"都可以使用并行流来代替串行流\",{\"1\":{\"1489\":1}}],[\"都可以使用上面的伪代码逻辑进行理解\",{\"1\":{\"740\":1}}],[\"都可以延迟实现\",{\"1\":{\"1485\":1}}],[\"都可以插入值\",{\"1\":{\"708\":1}}],[\"都可以传到备库并被正确地执行\",{\"1\":{\"593\":1}}],[\"都可以得到前一个状态的值\",{\"1\":{\"571\":1}}],[\"都可以采用这个方法来处理\",{\"1\":{\"484\":1}}],[\"都会调用urlclassloader的findclass方法在加载器的类路径里查找并加载该类\",{\"1\":{\"1540\":1}}],[\"都会被spring解析为对应的beandefinition对象\",{\"1\":{\"1509\":1}}],[\"都会进入这个方法\",{\"1\":{\"1499\":1}}],[\"都会去找自增量的最大值max\",{\"1\":{\"627\":1}}],[\"都会碰到\",{\"1\":{\"606\":1}}],[\"都会map到一个单独的数字\",{\"1\":{\"591\":1}}],[\"都会随机滚动显示三个单词\",{\"1\":{\"556\":1}}],[\"都会将sql语句原封不动的记录下来\",{\"1\":{\"550\":1}}],[\"都要判断会不会由于自己的加入导致了死锁\",{\"1\":{\"581\":1}}],[\"都要做100次判断\",{\"1\":{\"540\":1,\"662\":1}}],[\"都要回到主键索引上查出整行的数据\",{\"1\":{\"484\":1}}],[\"都表示返回满足条件的结果集的总行数\",{\"1\":{\"536\":1}}],[\"都暂停一会儿再做下一次删除\",{\"1\":{\"530\":1}}],[\"都需要操作系统的支持\",{\"1\":{\"1462\":1}}],[\"都需要进行一次被驱动表s2的访问\",{\"1\":{\"692\":1}}],[\"都需要经过\",{\"1\":{\"604\":1}}],[\"都需要扫描全表的数据\",{\"1\":{\"578\":1}}],[\"都需要在二者之间寻找一个平衡点\",{\"1\":{\"570\":1}}],[\"都需要手动将年份补齐\",{\"1\":{\"503\":1}}],[\"都需要额外调用一次reverse函数\",{\"1\":{\"489\":1}}],[\"都不会被对方执行\",{\"1\":{\"596\":1}}],[\"都不支持范围查询\",{\"1\":{\"489\":1}}],[\"都不设计到挪动其它记录\",{\"1\":{\"472\":1}}],[\"都同时用cr32\",{\"1\":{\"489\":1}}],[\"都马上伴随着对这个记录的查询\",{\"1\":{\"481\":1}}],[\"都有f\",{\"1\":{\"438\":1}}],[\"都是广受企业欢迎的数据库\",{\"1\":{\"1852\":1}}],[\"都是与stream相伴出现的\",{\"1\":{\"1484\":1}}],[\"都是可以调用的\",{\"1\":{\"1482\":1}}],[\"都是从jdk8开始提供的\",{\"1\":{\"1475\":1}}],[\"都是一个函数式接口\",{\"1\":{\"1475\":1}}],[\"都是基于aqs框架来实现的\",{\"1\":{\"1367\":1}}],[\"都是基于外部检测的\",{\"1\":{\"615\":1}}],[\"都是必要的字节\",{\"1\":{\"798\":1}}],[\"都是\",{\"1\":{\"609\":1}}],[\"都是由proxy完成\",{\"1\":{\"606\":1}}],[\"都是当前读\",{\"1\":{\"583\":1}}],[\"都是在commit的时候才释放的\",{\"1\":{\"580\":1}}],[\"都是不需要扫描索引的\",{\"1\":{\"559\":1}}],[\"都是追加操作\",{\"1\":{\"472\":1}}],[\"都是获取并删除队首元素\",{\"1\":{\"354\":1}}],[\"都是获取但不删除队首元素\",{\"1\":{\"354\":1}}],[\"都是向队列中插入元素\",{\"1\":{\"354\":1}}],[\"都解决了什么问题\",{\"0\":{\"232\":1}}],[\"都经历了什么过程\",{\"0\":{\"110\":1}}],[\"执行静态代码块\",{\"1\":{\"1540\":1}}],[\"执行被代理对象中的方法\",{\"1\":{\"1532\":1}}],[\"执行业务方法\",{\"1\":{\"1532\":1}}],[\"执行原始对象的方法\",{\"1\":{\"1531\":1}}],[\"执行原理是什么\",{\"0\":{\"205\":1}}],[\"执行目标方法\",{\"1\":{\"1507\":1}}],[\"执行到集合中所有的元素执行完或者抛出异常为止\",{\"1\":{\"1472\":1}}],[\"执行读操作时\",{\"1\":{\"1441\":1}}],[\"执行存盘操作\",{\"1\":{\"1408\":1}}],[\"执行存储引擎使用的设备类型\",{\"1\":{\"694\":1}}],[\"执行下一步操作\",{\"1\":{\"1395\":1}}],[\"执行某一个阶段\",{\"1\":{\"1395\":1}}],[\"执行相同的操作\",{\"1\":{\"1360\":1}}],[\"执行lastsave命令可以获取最后一次生成rdb的时间\",{\"1\":{\"725\":1}}],[\"执行bgsave命令\",{\"1\":{\"725\":1}}],[\"执行之前\",{\"1\":{\"718\":1}}],[\"执行之后就会发现这个sql语句会比预期的慢很多\",{\"1\":{\"503\":1}}],[\"执行报错\",{\"1\":{\"717\":1}}],[\"执行事务\",{\"1\":{\"716\":1,\"718\":1,\"719\":1}}],[\"执行事务之前就会先执行这两个set命令\",{\"1\":{\"605\":1}}],[\"执行任何查询sql时会生成当前事务的一致性视图read\",{\"1\":{\"679\":1}}],[\"执行时间\",{\"1\":{\"1364\":1}}],[\"执行时间减少了一半以上\",{\"1\":{\"659\":1}}],[\"执行时间是40毫秒\",{\"1\":{\"483\":1}}],[\"执行这个userservice的test方法时\",{\"1\":{\"1531\":1}}],[\"执行这三个命令时\",{\"1\":{\"622\":1}}],[\"执行这条更新语句的成本很低\",{\"1\":{\"482\":1}}],[\"执行停止的逻辑了\",{\"1\":{\"618\":1}}],[\"执行自己的任务\",{\"1\":{\"615\":1}}],[\"执行了十次累积的操作\",{\"1\":{\"1494\":1}}],[\"执行了多少事务\",{\"1\":{\"610\":1}}],[\"执行了21毫秒\",{\"1\":{\"483\":1}}],[\"执行一百千次\",{\"1\":{\"1468\":1}}],[\"执行一个终止的操作\",{\"1\":{\"1500\":1}}],[\"执行一个事务\",{\"1\":{\"633\":1}}],[\"执行一个查询的过程中\",{\"1\":{\"617\":1}}],[\"执行一条update语句\",{\"1\":{\"615\":1}}],[\"执行一条插入语句后报错的情况\",{\"1\":{\"562\":1}}],[\"执行一次跳过命令\",{\"1\":{\"604\":1}}],[\"执行中\",{\"1\":{\"601\":1}}],[\"执行队列\",{\"1\":{\"598\":1}}],[\"执行内部事务的更新逻辑\",{\"1\":{\"590\":1}}],[\"执行完这个lambda表达式\",{\"1\":{\"1526\":1}}],[\"执行完图中的语句之后\",{\"1\":{\"584\":1}}],[\"执行完成后\",{\"1\":{\"456\":1}}],[\"执行后就会提交\",{\"1\":{\"583\":1}}],[\"执行代价还是小很多\",{\"1\":{\"559\":1}}],[\"执行代价都是比较高的\",{\"1\":{\"554\":1}}],[\"执行全字段排序会会减少磁盘访问\",{\"1\":{\"557\":1}}],[\"执行过程中按顺序执行\",{\"1\":{\"715\":1}}],[\"执行过程中会发现内存临时表大小达到了上限\",{\"1\":{\"553\":1}}],[\"执行过程中会发现内存临时表大小不够存下这100行数据\",{\"1\":{\"553\":1}}],[\"执行过程类似\",{\"1\":{\"663\":1}}],[\"执行过程就要扫描驱动表n行\",{\"1\":{\"538\":1}}],[\"执行第二个子查询\",{\"1\":{\"551\":1}}],[\"执行第一个子查询\",{\"1\":{\"551\":1}}],[\"执行insert语句构造temp\",{\"1\":{\"544\":1}}],[\"执行流程如下\",{\"1\":{\"558\":1}}],[\"执行流程就变成了\",{\"1\":{\"540\":1,\"555\":1,\"611\":1}}],[\"执行流程的示意图如下所示\",{\"1\":{\"491\":1}}],[\"执行耗时都是一样的\",{\"1\":{\"540\":1}}],[\"执行set\",{\"1\":{\"618\":1}}],[\"执行select\",{\"1\":{\"538\":2,\"548\":1}}],[\"执行show\",{\"1\":{\"568\":1,\"619\":2}}],[\"执行sql语句的第一步\",{\"1\":{\"455\":1}}],[\"执行得要比count\",{\"1\":{\"536\":1}}],[\"执行单个查询可以减少锁的竞争\",{\"1\":{\"531\":1}}],[\"执行\",{\"1\":{\"518\":2,\"549\":1,\"613\":1,\"1431\":1}}],[\"执行语句\",{\"1\":{\"491\":1,\"558\":1}}],[\"执行顺序如下\",{\"1\":{\"487\":2}}],[\"执行顺序由上至下\",{\"1\":{\"467\":1}}],[\"执行速度明显会快很多\",{\"1\":{\"484\":1}}],[\"执行另外一个语句\",{\"1\":{\"484\":1}}],[\"执行的核心逻辑\",{\"1\":{\"1532\":1}}],[\"执行的结果\",{\"1\":{\"1494\":1}}],[\"执行的序列如下\",{\"1\":{\"584\":1}}],[\"执行的效率就会越低\",{\"1\":{\"570\":1}}],[\"执行的效果如下\",{\"1\":{\"485\":2,\"544\":1,\"591\":1}}],[\"执行的流程如下\",{\"1\":{\"544\":1}}],[\"执行的流程图如下\",{\"1\":{\"482\":1,\"540\":1,\"555\":1,\"595\":1}}],[\"执行的示意图如下\",{\"1\":{\"492\":1}}],[\"执行的逻辑也差不多\",{\"1\":{\"459\":1}}],[\"执行逻辑就会来到第二步\",{\"1\":{\"456\":1}}],[\"执行器不仅重用语句还会执行批量更新\",{\"1\":{\"807\":1}}],[\"执行器会重用preparestatement\",{\"1\":{\"807\":1}}],[\"执行器把binlog\",{\"1\":{\"587\":1}}],[\"执行器调用innodb引擎接口写入一行\",{\"1\":{\"628\":1}}],[\"执行器调用引擎的提交事务接口\",{\"1\":{\"463\":1}}],[\"执行器调用一次\",{\"1\":{\"459\":1}}],[\"执行器生成这个操作的binlog\",{\"1\":{\"463\":1}}],[\"执行器拿到引擎给的行数据\",{\"1\":{\"463\":1}}],[\"执行器先找引擎取id=2这一行\",{\"1\":{\"463\":1}}],[\"执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端\",{\"1\":{\"459\":1}}],[\"执行器就会根据表的引擎定义\",{\"1\":{\"459\":1}}],[\"执行器\",{\"0\":{\"459\":1,\"652\":1},\"1\":{\"454\":1}}],[\"执行结果会被存入查询缓存中\",{\"1\":{\"456\":1}}],[\"执行结果\",{\"1\":{\"409\":2}}],[\"执行插入语句后如何该数据的主键\",{\"0\":{\"201\":1}}],[\"当学完了这部分\",{\"1\":{\"1847\":1}}],[\"当父亲已经加载了该类时\",{\"1\":{\"1540\":1}}],[\"当执行该代理对象的某个方法时\",{\"1\":{\"1530\":1}}],[\"当找到多个对象的时候\",{\"1\":{\"1525\":1}}],[\"当找到k=5的时候\",{\"1\":{\"479\":1}}],[\"当命名出现重复\",{\"1\":{\"1524\":1}}],[\"当链接一个新的中间操作\",{\"1\":{\"1498\":1}}],[\"当链表长度太长\",{\"1\":{\"1423\":1}}],[\"当链表转为红黑树\",{\"0\":{\"40\":1}}],[\"当不为空的情况出现的时候\",{\"1\":{\"1497\":1}}],[\"当分割迭代器绑定到元上元素的时候\",{\"1\":{\"1497\":1}}],[\"当流的close方法被调用的时候\",{\"1\":{\"1496\":1}}],[\"当流程的执行顺序依赖于某个共享变量的场景\",{\"1\":{\"1408\":1}}],[\"当中\",{\"1\":{\"1496\":1}}],[\"当比较的结果不为0的时候直接返回\",{\"1\":{\"1491\":1}}],[\"当类型相同的时候\",{\"1\":{\"1478\":1}}],[\"当计算这个复合函数的时候\",{\"1\":{\"1476\":1}}],[\"当成参数传递给另一个函数\",{\"1\":{\"1470\":1}}],[\"当调用sendfile\",{\"1\":{\"1459\":1}}],[\"当启动某个应用程序时\",{\"1\":{\"1456\":1}}],[\"当任何一个socket中的数据准备好了\",{\"1\":{\"1442\":1}}],[\"当任务在运行中出错时\",{\"1\":{\"1387\":1}}],[\"当某个类中存在\",{\"1\":{\"1532\":1}}],[\"当某个类已经触发批量撤销机制后\",{\"1\":{\"1362\":1}}],[\"当某个socket有数据到达了\",{\"1\":{\"1442\":1}}],[\"当对于一个non\",{\"1\":{\"1441\":1}}],[\"当对一个表做增删改查操作时\",{\"1\":{\"618\":1}}],[\"当对一个表做增删改查操作的时候\",{\"1\":{\"578\":1}}],[\"当kernel一直等到数据准备好了\",{\"1\":{\"1440\":1}}],[\"当程序打开一个现有文件或者创建一个新文件时\",{\"1\":{\"1438\":1}}],[\"当超过threshold所能容纳的数量\",{\"1\":{\"1423\":1}}],[\"当用iterator遍历treemap时\",{\"1\":{\"1421\":1}}],[\"当用户进程结束的时候\",{\"1\":{\"1456\":1}}],[\"当用户进程调用了select\",{\"1\":{\"1442\":1}}],[\"当用户进程调用了recvfrom这个系统调用\",{\"1\":{\"1440\":1}}],[\"当用户进程发出read操作时\",{\"1\":{\"1441\":1}}],[\"当用户变多之后这种方式及其浪费空间\",{\"1\":{\"714\":1}}],[\"当用户执行kill\",{\"1\":{\"618\":1}}],[\"当创建arraylist对象时\",{\"1\":{\"1419\":1}}],[\"当线程处理完请求后\",{\"1\":{\"1410\":1}}],[\"当自己的任务为空时\",{\"1\":{\"1388\":1}}],[\"当使用fork\",{\"1\":{\"1387\":1}}],[\"当使用默认参数连接的时候\",{\"1\":{\"619\":1}}],[\"当子问题划分得足够小时\",{\"1\":{\"1387\":1}}],[\"当队列满了时\",{\"1\":{\"1380\":1}}],[\"当队列满了无法添加元素\",{\"1\":{\"1378\":1}}],[\"当队列无元素时\",{\"1\":{\"1380\":1}}],[\"当去除takeindex对应的元素之后\",{\"1\":{\"1379\":1}}],[\"当如果生产速度远远大于消费速度\",{\"1\":{\"1379\":1}}],[\"当同步状态释放时\",{\"1\":{\"1368\":1}}],[\"当撤销偏向锁阈值超过40次后\",{\"1\":{\"1362\":1}}],[\"当其达到批量撤销的阈值后\",{\"1\":{\"1362\":1}}],[\"当达到重偏向阈值\",{\"1\":{\"1362\":1}}],[\"当达到这个状态后\",{\"1\":{\"634\":1}}],[\"当只有一个线程反复进入同步块时\",{\"1\":{\"1362\":1}}],[\"当jvm启用了偏向锁模式\",{\"1\":{\"1362\":1}}],[\"当join\",{\"1\":{\"540\":1}}],[\"当在jvm参数中关闭指针压缩\",{\"1\":{\"1361\":1}}],[\"当在redis实例中开启了requirepass\",{\"1\":{\"761\":1}}],[\"当红黑树的元素小于6的时候\",{\"1\":{\"1352\":1}}],[\"当系统中的客户机维护公共内存资源的缓存时\",{\"1\":{\"1351\":1}}],[\"当cpu再次使用该部分数据时可以从cache中直接调用\",{\"1\":{\"1351\":1}}],[\"当comments\",{\"1\":{\"498\":1}}],[\"当spring容器关闭的时候\",{\"1\":{\"1524\":1}}],[\"当spliterator方法无法返回immutable\",{\"1\":{\"1497\":1}}],[\"当select函数返回后\",{\"1\":{\"1446\":1}}],[\"当sentinel有任何警告级别的事件发生时\",{\"1\":{\"761\":1}}],[\"当stats\",{\"1\":{\"695\":2,\"696\":2}}],[\"当进行failover时\",{\"1\":{\"761\":1}}],[\"当想要取消一个正在进行的failover所需要的时间\",{\"1\":{\"761\":1}}],[\"当大多数sentinel节点都认为主节点不可达时\",{\"1\":{\"758\":1}}],[\"当哨兵监测到master宕机\",{\"1\":{\"757\":1}}],[\"当从机断电宕机后\",{\"1\":{\"748\":1}}],[\"当主节点出现故障时\",{\"1\":{\"758\":1}}],[\"当主节点故障时\",{\"1\":{\"744\":1}}],[\"当主服务器宕机后\",{\"1\":{\"756\":1}}],[\"当主机恢复以后\",{\"1\":{\"748\":1}}],[\"当主机断电宕机后\",{\"1\":{\"748\":1}}],[\"当这一切都完成之后\",{\"1\":{\"1443\":1}}],[\"当这个队列满了\",{\"1\":{\"1397\":1}}],[\"当这个值达到重偏向阈值\",{\"1\":{\"1362\":1}}],[\"当这个选项打开时\",{\"1\":{\"739\":1}}],[\"当这些quorum个数sentinel哨兵认为master主节点失联\",{\"1\":{\"761\":1}}],[\"当这两个参数都设置为1的时候\",{\"1\":{\"628\":1}}],[\"当下次重启时利用之前持久化的文件即可实现数据恢复\",{\"1\":{\"721\":1}}],[\"当下做局部最优判断\",{\"1\":{\"293\":1}}],[\"当看到xxtemplate时可以对比resttemplat\",{\"1\":{\"720\":1}}],[\"当看到一个查询请求的响应时间的时候\",{\"1\":{\"525\":1}}],[\"当代码逻辑错误\",{\"1\":{\"717\":1}}],[\"当服务器关闭时这些统计数据就被清除掉了\",{\"1\":{\"695\":1}}],[\"当查询优化器想计算整个连接查询所使用的成本时\",{\"1\":{\"691\":1}}],[\"当查询中使用到了in查询\",{\"1\":{\"690\":1}}],[\"当查询中使用同一个数据表的时候\",{\"1\":{\"531\":1}}],[\"当in语句中的参数个数大于或等于系统变量eq\",{\"1\":{\"690\":1}}],[\"当我们修改这个类的默认构造方法\",{\"1\":{\"1477\":1}}],[\"当我们断开主机后\",{\"1\":{\"758\":1}}],[\"当我们调用套节字的读写方法\",{\"1\":{\"739\":1}}],[\"当我们选择把某个表以及该表索引的统计数据存放到磁盘上时\",{\"1\":{\"695\":1}}],[\"当我们想查询表中的记录时\",{\"1\":{\"682\":1}}],[\"当我们把节点b设置成节点a\",{\"1\":{\"604\":1}}],[\"当事务开启后\",{\"1\":{\"679\":1}}],[\"当事务被分发给worker以后\",{\"1\":{\"597\":1}}],[\"当插入的字符数不足n时\",{\"1\":{\"667\":1}}],[\"当插入的位置确定之后就是要确定插入结点的颜色\",{\"1\":{\"345\":1}}],[\"当数据被hash后\",{\"1\":{\"1423\":1}}],[\"当数据的一个副本发生更改时\",{\"1\":{\"1351\":1}}],[\"当数据格式为timestamp和datetime时\",{\"1\":{\"666\":1}}],[\"当数据库上有多个事务同时执行的时候\",{\"1\":{\"570\":1}}],[\"当dict\",{\"1\":{\"632\":1}}],[\"当一个read操作发生时\",{\"1\":{\"1438\":1}}],[\"当一个对象在方法中被定义后\",{\"1\":{\"1365\":1}}],[\"当一个线程修改了共享变量的值\",{\"1\":{\"1348\":1}}],[\"当一个master由于failover而发生改变时\",{\"1\":{\"761\":1}}],[\"当一个slave从一个错误的master那里同步数据开始计算时间\",{\"1\":{\"761\":1}}],[\"当一个哨兵主观认为主机断开\",{\"1\":{\"758\":1}}],[\"当一个事务读到一行数据的时候\",{\"1\":{\"634\":1}}],[\"当一个库中的表个数非常多的时候\",{\"1\":{\"619\":1}}],[\"当一部分行记录变成0的时候\",{\"1\":{\"581\":1}}],[\"当节点b要设置成a\",{\"1\":{\"604\":1}}],[\"当有多个构造方法和只有一个无参的构造方法都会返回null\",{\"1\":{\"1527\":1}}],[\"当有多个线程对一个原子类进行操作的时候\",{\"1\":{\"1356\":1}}],[\"当有中间操作的时候\",{\"1\":{\"1499\":1}}],[\"当有若干个线程都要使用某一共享资源时\",{\"1\":{\"1354\":1}}],[\"当有新消息通过\",{\"1\":{\"733\":1}}],[\"当有事务分配给worker的时候\",{\"1\":{\"598\":1}}],[\"当有一条记录需要更新的时候\",{\"1\":{\"461\":1}}],[\"当备库主机上的多个备库都在争抢资源的时候\",{\"1\":{\"594\":1}}],[\"当binlog所在磁盘的空间占用率达到100\",{\"1\":{\"614\":1}}],[\"当binlog\",{\"1\":{\"588\":1,\"591\":2}}],[\"当binlog是row格式的时候\",{\"1\":{\"550\":1}}],[\"当并发量很大的时候\",{\"1\":{\"581\":1}}],[\"当并发系统中不同线程出现循环资源以来\",{\"1\":{\"581\":1}}],[\"当所有事务都要更新同一行的场景时\",{\"1\":{\"581\":1}}],[\"当要对表结构做变更操作的时候\",{\"1\":{\"578\":1}}],[\"当mysql异常重启后就不会丢失数据了\",{\"1\":{\"588\":1}}],[\"当mysql本身异常重启的话\",{\"1\":{\"588\":1}}],[\"当mysqldump使用参数\",{\"1\":{\"575\":1}}],[\"当mysql认为内存足够大\",{\"1\":{\"493\":1}}],[\"当出现死锁以后\",{\"1\":{\"581\":2}}],[\"当出现并发访问的时候\",{\"1\":{\"573\":1}}],[\"当出现读写锁冲突的时候\",{\"1\":{\"570\":1}}],[\"当碰到第一个2的时候\",{\"1\":{\"554\":1}}],[\"当碰到第一个1的时候\",{\"1\":{\"554\":1}}],[\"当碰到优化器选择索引错误的时候\",{\"1\":{\"485\":1}}],[\"当参数设置为binlog\",{\"1\":{\"550\":1}}],[\"当能够使用in\",{\"1\":{\"531\":1}}],[\"当可以将数据分布到不同的mysql服务器上的时候\",{\"1\":{\"531\":1}}],[\"当应用能够方便地缓存单个查询结果的时候\",{\"1\":{\"531\":1}}],[\"当初次查询的时候将这个数据缓存起来\",{\"1\":{\"523\":1}}],[\"当无法保证被驱动表的join条件字段被索引且内存资源充足的前提下\",{\"1\":{\"501\":1}}],[\"当内存太小\",{\"1\":{\"493\":1}}],[\"当需要覆盖数据时\",{\"1\":{\"1397\":1}}],[\"当需要批量提交异步任务的时候建议使用completionservice\",{\"1\":{\"1394\":1}}],[\"当需要切换的时候\",{\"1\":{\"590\":1}}],[\"当需要让整个库处于只读状态的时候\",{\"1\":{\"574\":1}}],[\"当需要更新一个数据页的时候\",{\"1\":{\"480\":1}}],[\"当需要读一条记录的时候\",{\"1\":{\"479\":1}}],[\"当需要查到所有名字是\",{\"1\":{\"476\":1}}],[\"当需要恢复到指定的某一秒时\",{\"1\":{\"464\":1}}],[\"当然可以跳过\",{\"1\":{\"1861\":1}}],[\"当然这是因为我们是没有任何的中间操作\",{\"1\":{\"1499\":1}}],[\"当然这个结果最终是在t6时刻正式提交的\",{\"1\":{\"584\":1}}],[\"当然也可以调用统计的方法一次将这些特征值都求出来\",{\"1\":{\"1493\":1}}],[\"当然一开始这是不太容易能够理解的\",{\"1\":{\"1490\":1}}],[\"当然虽然这个函数的名字我们并不会直接去调用\",{\"1\":{\"1472\":1}}],[\"当然lambda表达式肯定不止只是能用来遍历集合这个简单\",{\"1\":{\"1470\":1}}],[\"当然了\",{\"1\":{\"625\":1}}],[\"当然如果这个线程有语句正在执行\",{\"1\":{\"617\":1}}],[\"当然为了唯一标识\",{\"1\":{\"602\":1}}],[\"当然\",{\"1\":{\"475\":1,\"479\":1,\"485\":1,\"489\":1,\"565\":1,\"602\":1,\"607\":1,\"610\":1,\"1485\":1,\"1489\":1,\"1491\":1,\"1847\":1}}],[\"当然事无绝对\",{\"1\":{\"472\":1}}],[\"当然有分裂就有合并\",{\"1\":{\"472\":1}}],[\"当相邻两个页由于删除了数据\",{\"1\":{\"472\":1}}],[\"当你需要扩容的时候\",{\"1\":{\"464\":1}}],[\"当两者的值相同时\",{\"1\":{\"393\":1}}],[\"当两个或多个事务选择同一行\",{\"1\":{\"669\":1}}],[\"当两个关键字key1\",{\"1\":{\"332\":1}}],[\"当两个子数组有序时\",{\"1\":{\"323\":1}}],[\"当它收到一个asynchronous\",{\"1\":{\"1443\":1}}],[\"当它没有得到另一个线程的消息时应等待\",{\"1\":{\"1354\":1}}],[\"当它发现节点不可达时\",{\"1\":{\"758\":1}}],[\"当它验证是否存在的时候\",{\"1\":{\"307\":1}}],[\"当它通过尝试发现现有的分布答案不能得到有效的正确的解答的时候\",{\"1\":{\"290\":1}}],[\"当布隆过滤器把元素都插入结束之后\",{\"1\":{\"307\":1}}],[\"当输入库名或者表名的时候\",{\"1\":{\"619\":1}}],[\"当输入\",{\"1\":{\"307\":1}}],[\"当前类是否\",{\"1\":{\"1525\":1}}],[\"当前集合的迭代器\",{\"1\":{\"1499\":1}}],[\"当前集合的引用就是在这个时候被传递进去的\",{\"1\":{\"1498\":1}}],[\"当前的管道对象和流元的管道对象的中间操作的个数\",{\"1\":{\"1498\":1}}],[\"当前的索引\",{\"1\":{\"1497\":1}}],[\"当前的自增值是y\",{\"1\":{\"628\":1}}],[\"当前传入的比较器就会发挥作用\",{\"1\":{\"1491\":1}}],[\"当前线程存在于同步队列的头结点\",{\"1\":{\"1369\":1}}],[\"当前线程如果获取同步状态失败时\",{\"1\":{\"1368\":1}}],[\"当前获取锁的线程\",{\"1\":{\"1360\":1}}],[\"当前未开启事务\",{\"1\":{\"716\":1}}],[\"当前key有设置过期时间\",{\"1\":{\"706\":2}}],[\"当前key没有设置过期时间\",{\"1\":{\"706\":1}}],[\"当前正在等待锁定的数量\",{\"1\":{\"675\":1}}],[\"当前正在执行\",{\"1\":{\"613\":1}}],[\"当前版本\",{\"1\":{\"672\":1}}],[\"当前读\",{\"1\":{\"583\":2,\"678\":1}}],[\"当前值是4\",{\"1\":{\"571\":1}}],[\"当前query中过滤性最好的字段在索引字段顺序中\",{\"1\":{\"517\":1}}],[\"当前索引是idx\",{\"1\":{\"498\":1}}],[\"当前节点的值与上一个节点的值进行比较\",{\"1\":{\"397\":1}}],[\"当前节点为空\",{\"1\":{\"395\":1}}],[\"当前节点后续节点\",{\"1\":{\"302\":1}}],[\"当前元素等于绝对值大的那个元素的平方和\",{\"1\":{\"362\":1}}],[\"当前位向量的标记状态为\",{\"1\":{\"307\":1}}],[\"当前结点到parent节点存储的字母\",{\"1\":{\"302\":1}}],[\"当实体类中的属性名和表中的字段名不一样怎么办\",{\"0\":{\"200\":1}}],[\"不作为学习的重点\",{\"1\":{\"1854\":1}}],[\"不行再由儿子自己加载\",{\"1\":{\"1540\":1}}],[\"不得不提前缓存aop的对象\",{\"1\":{\"1526\":1}}],[\"不相关的标签数据是存放在基数的位置上的\",{\"1\":{\"1497\":1}}],[\"不冲突的\",{\"1\":{\"1485\":1}}],[\"不包含最大值的intstream对象\",{\"1\":{\"1484\":1}}],[\"不妨查看一下stream这个类中的of\",{\"1\":{\"1484\":1}}],[\"不妨来读一下这段文档\",{\"1\":{\"1472\":1}}],[\"不一定都是抽象方法\",{\"1\":{\"1471\":1}}],[\"不一致\",{\"1\":{\"464\":1}}],[\"不共享的\",{\"1\":{\"1456\":1}}],[\"不存储元素的阻塞队列\",{\"1\":{\"1378\":1}}],[\"不存在则直接添加到该map中\",{\"1\":{\"1490\":1}}],[\"不存在线程不安全的情况\",{\"1\":{\"720\":1}}],[\"不存在时\",{\"1\":{\"706\":1,\"710\":1}}],[\"不存在\",{\"1\":{\"706\":1,\"710\":1}}],[\"不存在也就加不上锁\",{\"1\":{\"584\":1}}],[\"不支持\",{\"1\":{\"1378\":2}}],[\"不支持范围查询\",{\"1\":{\"641\":1}}],[\"不阻塞\",{\"1\":{\"1378\":2}}],[\"不阻塞客户端命令\",{\"1\":{\"726\":1}}],[\"不到最后万不得已\",{\"1\":{\"1357\":1}}],[\"不好设置缓存\",{\"1\":{\"806\":1}}],[\"不执行覆盖\",{\"1\":{\"1397\":1}}],[\"不执行\",{\"1\":{\"729\":1}}],[\"不但效率高并且易用\",{\"1\":{\"721\":1}}],[\"不但速度慢\",{\"1\":{\"629\":1}}],[\"不必修改\",{\"1\":{\"720\":1}}],[\"不必从数据表中读取\",{\"1\":{\"467\":2}}],[\"不管增加\",{\"1\":{\"1425\":1}}],[\"不管是\",{\"1\":{\"1356\":1}}],[\"不管是否成功\",{\"1\":{\"718\":1}}],[\"不管读取记录时需不需要检测是否满足搜索条件\",{\"1\":{\"682\":1}}],[\"不设置默认\",{\"1\":{\"715\":1}}],[\"不精确\",{\"1\":{\"690\":1}}],[\"不加锁的非阻塞读\",{\"1\":{\"678\":1}}],[\"不加任何索引\",{\"1\":{\"500\":1}}],[\"不符合隔离性\",{\"1\":{\"669\":2}}],[\"不符合一致性要求\",{\"1\":{\"669\":1}}],[\"不超过\",{\"1\":{\"667\":1}}],[\"不知道要预先申请多少个id\",{\"1\":{\"629\":1}}],[\"不再使用select\",{\"1\":{\"1447\":1}}],[\"不再需要像jdk1\",{\"1\":{\"1427\":1}}],[\"不再需要回表查整行记录\",{\"1\":{\"475\":1}}],[\"不再依赖于自增主键去生成\",{\"1\":{\"629\":1}}],[\"不算在并发线程里面\",{\"1\":{\"613\":1}}],[\"不限制并发线程数肯定是不行的\",{\"1\":{\"613\":1}}],[\"不做日志的完整性判断\",{\"1\":{\"605\":1}}],[\"不要不行吗\",{\"0\":{\"1536\":1}}],[\"不要冒然在生产环境中使用\",{\"1\":{\"1387\":1}}],[\"不要用int\",{\"1\":{\"665\":1}}],[\"不要在小基数字段上建立索引\",{\"1\":{\"658\":1}}],[\"不要直接在主库上执行这些操作\",{\"1\":{\"621\":1}}],[\"不要求binlog的格式\",{\"1\":{\"600\":1}}],[\"不要太吝惜join\",{\"1\":{\"501\":1}}],[\"不等则会把当前dest指针指向内存的值写入eax\",{\"1\":{\"1356\":1}}],[\"不等于e\",{\"1\":{\"1356\":1}}],[\"不等主备数据同步\",{\"1\":{\"596\":1}}],[\"不等有时会失效\",{\"0\":{\"511\":1}}],[\"不仅如此\",{\"1\":{\"1468\":1}}],[\"不仅耗费精力且难以维护\",{\"1\":{\"1395\":1}}],[\"不仅会占用更大的空间\",{\"1\":{\"591\":1}}],[\"不仅将给行加上了行锁\",{\"1\":{\"585\":1}}],[\"不论某个范围区间的二级索引到底占用了多少页面\",{\"1\":{\"686\":1}}],[\"不论采用哪种架构\",{\"1\":{\"606\":1}}],[\"不论这个binlog是1分钟之后被备库执行\",{\"1\":{\"591\":1}}],[\"不论当前的工作线程在哪个库里\",{\"1\":{\"591\":1}}],[\"不论是拿到备库去执行\",{\"1\":{\"584\":1}}],[\"不论是使用内存临时表还是磁盘临时表\",{\"1\":{\"554\":1}}],[\"不论是在原表上加索引\",{\"1\":{\"544\":1}}],[\"不fsync\",{\"1\":{\"587\":1}}],[\"不止是数据库内部数据状态在此刻的一致性\",{\"1\":{\"584\":1}}],[\"不止是索引的全部定义\",{\"1\":{\"476\":1}}],[\"不允许null元素\",{\"1\":{\"1380\":1}}],[\"不允许其他命令进行干扰\",{\"1\":{\"715\":1}}],[\"不允许插入值\",{\"1\":{\"585\":1}}],[\"不允许使用分区表\",{\"1\":{\"560\":1}}],[\"不允许放入null元素\",{\"1\":{\"353\":1}}],[\"不是接口或抽象类\",{\"1\":{\"1524\":1}}],[\"不是内部类或static类\",{\"1\":{\"1524\":1}}],[\"不是针对性的\",{\"1\":{\"761\":1}}],[\"不是\",{\"1\":{\"709\":1}}],[\"不是自增的主键在插入的时候\",{\"1\":{\"642\":1}}],[\"不是一个特别大的数\",{\"1\":{\"631\":1}}],[\"不是真正的随机\",{\"1\":{\"559\":1}}],[\"不是null才累加\",{\"1\":{\"536\":1}}],[\"不是通过表内检索出的\",{\"1\":{\"467\":1}}],[\"不为null的总个数\",{\"1\":{\"536\":1}}],[\"不为空的\",{\"1\":{\"1497\":1}}],[\"不为空\",{\"1\":{\"302\":1}}],[\"不幸的是\",{\"1\":{\"527\":1}}],[\"不应该按下面的写法编写查询\",{\"1\":{\"521\":1}}],[\"不在索引列上做任何操作\",{\"1\":{\"506\":1}}],[\"不在集合中\",{\"1\":{\"307\":1}}],[\"不创建索引的情况下\",{\"1\":{\"499\":1}}],[\"不用父子容器也可以完成所需功能\",{\"1\":{\"1536\":1}}],[\"不用进一步做筛选了\",{\"1\":{\"1525\":1}}],[\"不用担心index溢出的问题\",{\"1\":{\"1396\":1}}],[\"不用担心请求和响应对不上\",{\"1\":{\"798\":1}}],[\"不用再会到原表去取数据\",{\"1\":{\"493\":1}}],[\"不用扫描全部索引\",{\"1\":{\"467\":1}}],[\"不会执行\",{\"1\":{\"1540\":1}}],[\"不会再往下匹配了\",{\"1\":{\"1534\":1}}],[\"不会再有中间操作和终止操作添加到这个流实例上了\",{\"1\":{\"1498\":1}}],[\"不会再评估其它索引的执行代价了\",{\"1\":{\"485\":1}}],[\"不会被其他线程使用\",{\"1\":{\"1492\":1}}],[\"不会计入这个接口的抽象方法数量\",{\"1\":{\"1471\":1}}],[\"不会发生线程安全问题\",{\"1\":{\"1378\":1}}],[\"不会停止线程\",{\"1\":{\"1354\":1}}],[\"不会切换到内核态\",{\"1\":{\"1354\":1}}],[\"不会消耗额外的内存\",{\"1\":{\"726\":1}}],[\"不会消耗额外的存储空间\",{\"1\":{\"489\":1}}],[\"不会加锁\",{\"1\":{\"672\":1}}],[\"不会出现新的主机\",{\"1\":{\"748\":1}}],[\"不会出现死锁\",{\"1\":{\"671\":1}}],[\"不会出现需要构造100万个项这种情况\",{\"1\":{\"600\":1}}],[\"不会把执行命令记录到本地的命令历史文件\",{\"1\":{\"619\":1}}],[\"不会有主备删除不同行的问题\",{\"1\":{\"591\":1}}],[\"不影响更新的响应时间\",{\"1\":{\"482\":1}}],[\"不难想到\",{\"1\":{\"556\":1}}],[\"不难想象\",{\"1\":{\"539\":1}}],[\"不难发现\",{\"1\":{\"493\":1,\"596\":1,\"629\":1}}],[\"不难看出\",{\"1\":{\"482\":1,\"1468\":1,\"1484\":1}}],[\"不难写出\",{\"1\":{\"430\":1}}],[\"不需要硬件支持\",{\"1\":{\"1461\":1}}],[\"不需要拼接参数的\",{\"1\":{\"806\":1}}],[\"不需要人工来介入\",{\"1\":{\"758\":1}}],[\"不需要去获取写事件\",{\"1\":{\"742\":1}}],[\"不需要传信号量参数\",{\"1\":{\"618\":1}}],[\"不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker\",{\"1\":{\"602\":1}}],[\"不需要解析binlog里面的内容\",{\"1\":{\"602\":1}}],[\"不需要临时表\",{\"1\":{\"554\":1}}],[\"不需要担心数据删除问题\",{\"1\":{\"547\":1}}],[\"不需要在服务端再耗费内存存储结果\",{\"1\":{\"492\":1}}],[\"不需要回到id索引再查一次\",{\"1\":{\"488\":1}}],[\"不需要回表\",{\"1\":{\"475\":1,\"553\":1}}],[\"不需要再做排序\",{\"1\":{\"485\":1}}],[\"不需要做自平衡操作\",{\"1\":{\"345\":1}}],[\"不满足条件\",{\"1\":{\"474\":1}}],[\"不满足下一个饼干\",{\"1\":{\"422\":1}}],[\"不可以\",{\"1\":{\"1537\":1}}],[\"不可以使用索引\",{\"1\":{\"684\":1}}],[\"不可变的分割迭代器\",{\"1\":{\"1497\":1}}],[\"不可变的\",{\"1\":{\"1497\":2}}],[\"不可变对象可以保证该对象在创建后它的哈希值不会被改变\",{\"1\":{\"1421\":1}}],[\"不可变对象也需要正确发布\",{\"1\":{\"1403\":1}}],[\"不可见\",{\"1\":{\"679\":1}}],[\"不可能从该方法中逃逸出去\",{\"1\":{\"1364\":1}}],[\"不可能\",{\"1\":{\"669\":6}}],[\"不可能字段同时查到两个名字\",{\"1\":{\"467\":1}}],[\"不可重复读\",{\"0\":{\"157\":1},\"1\":{\"570\":1,\"669\":3}}],[\"不断的过遍数\",{\"1\":{\"1850\":1}}],[\"不断地重复执行相同的查询\",{\"1\":{\"523\":1}}],[\"不断往左子树方向走\",{\"1\":{\"395\":1}}],[\"不断重复上述过程\",{\"1\":{\"304\":1}}],[\"不能同时返回sized和concurrent\",{\"1\":{\"1497\":1}}],[\"不能更改\",{\"1\":{\"1415\":1}}],[\"不能写\",{\"1\":{\"748\":1}}],[\"不能按位\",{\"1\":{\"715\":1}}],[\"不能像集合那样\",{\"1\":{\"714\":1}}],[\"不能保存到其他类型key噢\",{\"1\":{\"709\":1}}],[\"不能无限等待\",{\"1\":{\"610\":1}}],[\"不能有外键\",{\"1\":{\"599\":1}}],[\"不能称为幻读\",{\"1\":{\"583\":1}}],[\"不能直接返回了\",{\"1\":{\"492\":1}}],[\"不能用来获取任何元组\",{\"1\":{\"467\":1}}],[\"不能只有一个孩子\",{\"1\":{\"347\":1}}],[\"不能回退\",{\"1\":{\"293\":1}}],[\"不过就是太厚了\",{\"1\":{\"1852\":1}}],[\"不过并不会修改底层的数据源\",{\"1\":{\"1485\":1}}],[\"不过从redis6\",{\"1\":{\"738\":1}}],[\"不过自动重新计算统计数据的过程是异步发生的\",{\"1\":{\"696\":1}}],[\"不过对于myisam存储引擎来说\",{\"1\":{\"694\":1}}],[\"不过因为本查询可以使用idx\",{\"1\":{\"691\":1}}],[\"不过需要注意的是\",{\"1\":{\"690\":1}}],[\"不过需要格外说明的是\",{\"1\":{\"540\":1}}],[\"不过还有一个问题\",{\"1\":{\"686\":1}}],[\"不过依然存在一些问题\",{\"1\":{\"615\":1}}],[\"不过这个概率很低\",{\"1\":{\"634\":1}}],[\"不过这个实现有以下优势\",{\"1\":{\"602\":1}}],[\"不过这种方案\",{\"1\":{\"606\":1}}],[\"不过这样需要每次执行依次\",{\"1\":{\"572\":1}}],[\"不过即使这样\",{\"1\":{\"622\":1}}],[\"不过即使如此\",{\"1\":{\"601\":1}}],[\"不过即使是使用业务分表的方式\",{\"1\":{\"562\":1}}],[\"不过现在它并不再直接更新数据\",{\"1\":{\"597\":1}}],[\"不过后来由于多线程复制方案的引入\",{\"1\":{\"590\":1}}],[\"不过将innodb\",{\"1\":{\"588\":1}}],[\"不过通常情况下第3步执行得会很快\",{\"1\":{\"588\":1}}],[\"不过如果要备份全库\",{\"1\":{\"575\":1}}],[\"不过于order\",{\"1\":{\"559\":1}}],[\"不过有时候这个值也可能非常大\",{\"1\":{\"526\":1}}],[\"不过很难做到\",{\"1\":{\"525\":1}}],[\"不过索引还是有维护代价的\",{\"1\":{\"493\":1}}],[\"不过在mysql\",{\"1\":{\"694\":1}}],[\"不过在驱动表s1选取idx\",{\"1\":{\"691\":1}}],[\"不过在这个例子中\",{\"1\":{\"485\":1}}],[\"不过在某些场景下\",{\"1\":{\"483\":1}}],[\"不过在典型的kv场景\",{\"1\":{\"472\":1}}],[\"不过在有些场景下\",{\"1\":{\"459\":1}}],[\"不过为了维持o\",{\"1\":{\"471\":1}}],[\"不过你可能会问\",{\"1\":{\"464\":1}}],[\"不过\",{\"1\":{\"347\":1,\"454\":1,\"479\":1,\"522\":1,\"533\":1,\"545\":1,\"548\":2,\"591\":1,\"594\":1,\"597\":1,\"598\":1,\"599\":1,\"600\":1,\"601\":1,\"602\":1,\"604\":1,\"606\":1,\"609\":1,\"633\":1,\"634\":1,\"761\":1,\"1423\":1,\"1497\":1}}],[\"不同类加载器实例加载的类是互相隔离的\",{\"1\":{\"1571\":1}}],[\"不同于select使用三个位图来表示三个fdset的方式\",{\"1\":{\"1447\":1}}],[\"不同于idx\",{\"1\":{\"692\":1}}],[\"不同线程执行下面代码\",{\"1\":{\"1405\":1}}],[\"不同数据库之间\",{\"1\":{\"704\":1}}],[\"不同事务的xid也是有可能相同的\",{\"1\":{\"633\":1}}],[\"不同时刻启动的事务会有不同的read\",{\"1\":{\"571\":1}}],[\"不同session的临时表是可以重名的\",{\"1\":{\"547\":1}}],[\"不同count的用法\",{\"0\":{\"536\":1}}],[\"不同案例的情况不同\",{\"1\":{\"525\":1}}],[\"不同的\",{\"1\":{\"1497\":1}}],[\"不同的是每个元素都会关联一个double类型的分数\",{\"1\":{\"711\":1}}],[\"不同的表作为驱动表最终的查询成本可能是不同的\",{\"1\":{\"692\":1}}],[\"不同的应用对读一致性和事务隔离程度的要求也是不同的\",{\"1\":{\"669\":1}}],[\"不同的并发只读事务\",{\"1\":{\"634\":1}}],[\"不同的引擎对于自增值的保存策略是不同的\",{\"1\":{\"627\":1}}],[\"不同的worker就独立执行了\",{\"1\":{\"597\":1}}],[\"不同的存储引擎共用一个server层\",{\"1\":{\"454\":1}}],[\"不同的存储引擎的表数据获取方式不同\",{\"1\":{\"454\":1}}],[\"不同的xml映射文件\",{\"0\":{\"198\":1}}],[\"不同排序算法之间的对比如下\",{\"1\":{\"316\":1}}],[\"不含有则添加并设为currnode\",{\"1\":{\"302\":1}}],[\"如需要再次扩容\",{\"1\":{\"1419\":1}}],[\"如生产者每天1万条\",{\"1\":{\"1413\":1}}],[\"如synchronousqueue\",{\"1\":{\"1386\":1}}],[\"如semaphore\",{\"1\":{\"1367\":1}}],[\"如linkedblockingqueue\",{\"1\":{\"1386\":1}}],[\"如arrayblockingqueue\",{\"1\":{\"1386\":1}}],[\"如优先级队列\",{\"1\":{\"1386\":1}}],[\"如账户和金额等信息放到队列中就可以\",{\"1\":{\"1378\":1}}],[\"如图所示\",{\"1\":{\"1378\":1}}],[\"如图中看到的\",{\"1\":{\"571\":1}}],[\"如立即返回是否成功的trylock\",{\"1\":{\"1372\":1}}],[\"如reentrantlock\",{\"1\":{\"1367\":1}}],[\"如rdb\",{\"1\":{\"725\":1}}],[\"如哈希码\",{\"1\":{\"1361\":1}}],[\"如锁粗化\",{\"1\":{\"1360\":1}}],[\"如定时任务等\",{\"1\":{\"740\":1}}],[\"如cpu\",{\"1\":{\"670\":1}}],[\"如id号\",{\"1\":{\"665\":1}}],[\"如将主键置于where列表中\",{\"1\":{\"467\":1}}],[\"如下图\",{\"1\":{\"609\":1}}],[\"如下图所示\",{\"1\":{\"307\":1,\"351\":1,\"461\":1,\"484\":1,\"548\":1,\"554\":1,\"706\":1,\"755\":1,\"1350\":1,\"1423\":1}}],[\"如下所示\",{\"1\":{\"459\":1}}],[\"如日期\",{\"1\":{\"454\":1}}],[\"如此循环\",{\"1\":{\"581\":1}}],[\"如此反复\",{\"1\":{\"384\":1}}],[\"如此往复\",{\"1\":{\"318\":1}}],[\"如上图所示\",{\"1\":{\"307\":1}}],[\"如\",{\"1\":{\"293\":1,\"563\":1,\"1846\":1}}],[\"如果跳过了不利于学习原理\",{\"1\":{\"1861\":1}}],[\"如果之前已经学习过其他语言如c\",{\"1\":{\"1847\":1}}],[\"如果之前从库b的gtid集合格式是source\",{\"1\":{\"605\":1}}],[\"如果应用在启动的时候发生大量full\",{\"1\":{\"1541\":1}}],[\"如果应用程序使用某种缓存机制\",{\"1\":{\"522\":1}}],[\"如果释放了很多空间\",{\"1\":{\"1541\":1}}],[\"如果释放了大量的空间\",{\"1\":{\"1541\":1}}],[\"如果交由spring管理\",{\"1\":{\"1537\":1}}],[\"如果抛出了异常\",{\"1\":{\"1532\":1}}],[\"如果确定了当前beandefinition的构造方法\",{\"1\":{\"1527\":1}}],[\"如果确认包含全部\",{\"1\":{\"605\":1}}],[\"如果确认优化器会使用bnl算法\",{\"1\":{\"543\":1}}],[\"如果制定了构造方法的入参值\",{\"1\":{\"1527\":1}}],[\"如果descriptor所对应的类型是数组\",{\"1\":{\"1525\":1}}],[\"如果delete语句使用的是索引a\",{\"1\":{\"591\":1}}],[\"如果传入的是普通名称\",{\"1\":{\"1524\":1}}],[\"如果传入的名称是\",{\"1\":{\"1524\":1}}],[\"如果能在mergedbeandefinitions找得到父beandifinition\",{\"1\":{\"1524\":1}}],[\"如果能够将无序数组替换为哈希表\",{\"1\":{\"545\":1}}],[\"如果能够将更新操作先记录在change\",{\"1\":{\"480\":1}}],[\"如果指定的包路径比较宽泛\",{\"1\":{\"1523\":1}}],[\"如果指数是奇数\",{\"1\":{\"438\":1}}],[\"如果匹配则表示当前bean对象有匹配的pointcut\",{\"1\":{\"1507\":1}}],[\"如果匹配就替换为空字符串\",{\"1\":{\"386\":1}}],[\"如果找到多个\",{\"1\":{\"1507\":1}}],[\"如果遍历是无序的\",{\"1\":{\"1500\":1}}],[\"如果输入一定是不同\",{\"1\":{\"1500\":1}}],[\"如果管道的阶段是源阶段的话\",{\"1\":{\"1499\":1}}],[\"如果库访问了共享的状态\",{\"1\":{\"1499\":1}}],[\"如果库里面的表特别多\",{\"1\":{\"619\":1}}],[\"如果action是intconsumer的一个实例\",{\"1\":{\"1497\":1}}],[\"如果arraylist没有指定初始容量\",{\"1\":{\"1352\":1}}],[\"如果arraylist指定了初始容量\",{\"1\":{\"1352\":1}}],[\"如果返回了不同的特性值的集合\",{\"1\":{\"1497\":1}}],[\"如果返回值是0\",{\"1\":{\"611\":1}}],[\"如果返回值是大于等于0的正整数\",{\"1\":{\"610\":1}}],[\"如果根spliterator没有保存正确的计算结果\",{\"1\":{\"1497\":1}}],[\"如果系统变量org\",{\"1\":{\"1497\":1}}],[\"如果分割的足够小的话\",{\"1\":{\"1497\":1}}],[\"如果分割迭代器中没有任何元素\",{\"1\":{\"1497\":1}}],[\"如果两个或者多个线程操作同一个spliterator\",{\"1\":{\"1497\":1}}],[\"如果两个事务没有操作相同的行\",{\"1\":{\"602\":1}}],[\"如果两个事务更新不同的表\",{\"1\":{\"598\":1}}],[\"如果绑定之后对元进行了修改\",{\"1\":{\"1497\":1}}],[\"如果元不是有序的\",{\"1\":{\"1497\":1}}],[\"如果元在自然序列下是sorted\",{\"1\":{\"1497\":1}}],[\"如果元在绑定了spliterator之后\",{\"1\":{\"1497\":1}}],[\"如果元的元素是无限的\",{\"1\":{\"1497\":1}}],[\"如果元素存在\",{\"1\":{\"1497\":1}}],[\"如果元素为空\",{\"1\":{\"1431\":1}}],[\"如果元是sortedset集合\",{\"1\":{\"1497\":1}}],[\"如果元是set集合\",{\"1\":{\"1497\":1}}],[\"如果元是collection集合\",{\"1\":{\"1497\":1}}],[\"如果任意的关闭处理器抛出了异常\",{\"1\":{\"1496\":1}}],[\"如果任务的平均等待时间长\",{\"1\":{\"1387\":1}}],[\"如果检测到流被重用了\",{\"1\":{\"1496\":1}}],[\"如果提供的流操作并没有所需要的功能\",{\"1\":{\"1496\":1}}],[\"如果它不为空的话\",{\"1\":{\"1495\":1}}],[\"如果它的前一个比较器返回是元素的相等的情况\",{\"1\":{\"1491\":1}}],[\"如果给定一个key与值没有关联起来\",{\"1\":{\"1495\":1}}],[\"如果流中没有元素\",{\"1\":{\"1495\":1}}],[\"如果流中没有元素返回0即可\",{\"1\":{\"1487\":1}}],[\"如果编写错误了\",{\"1\":{\"1494\":1}}],[\"如果包含了identity\",{\"1\":{\"1494\":1}}],[\"如果以向创建一个根据部门对于工资的总和表格化\",{\"1\":{\"1492\":1}}],[\"如果finisher\",{\"1\":{\"1492\":1}}],[\"如果force\",{\"1\":{\"485\":1}}],[\"如果前面的比较器返回的结果不是0\",{\"1\":{\"1491\":1}}],[\"如果前面的predicate的值为false\",{\"1\":{\"1476\":1}}],[\"如果修改成如下\",{\"1\":{\"1487\":1}}],[\"如果代码很多\",{\"1\":{\"1484\":1}}],[\"如果所有父加载器在自己的加载路径下都找不到目标类\",{\"1\":{\"1570\":1}}],[\"如果所有的从库都延迟超过1秒了\",{\"1\":{\"610\":1}}],[\"如果所有的更新后面\",{\"1\":{\"481\":1}}],[\"如果所使用的lambda表达式恰好被实现过的话\",{\"1\":{\"1479\":1}}],[\"如果点击student\",{\"1\":{\"1477\":1}}],[\"如果与predicate相匹配\",{\"1\":{\"1476\":1}}],[\"如果当中任何一个function抛出了异常\",{\"1\":{\"1475\":1}}],[\"如果当前加载器父加载器为空则委托引导类加载器加载该类\",{\"1\":{\"1540\":1}}],[\"如果当前加载器父加载器不为空则委托父加载器加载该类\",{\"1\":{\"1540\":1}}],[\"如果当前的predicate是true的话\",{\"1\":{\"1476\":1}}],[\"如果当前的predicate抛出了异常\",{\"1\":{\"1476\":1}}],[\"如果当前\",{\"1\":{\"1431\":1}}],[\"如果当前线程获取读锁\",{\"1\":{\"1375\":1}}],[\"如果当前线程不获取读锁而是直接释放写锁\",{\"1\":{\"1375\":1}}],[\"如果当前线程自旋成功\",{\"1\":{\"1362\":1}}],[\"如果当前语句是这个事务执行的第一条语句\",{\"1\":{\"633\":1}}],[\"如果算的话\",{\"1\":{\"1471\":1}}],[\"如果改用函数式风格编程\",{\"1\":{\"1468\":1}}],[\"如果立即返回设为null即可\",{\"1\":{\"1446\":1}}],[\"如果处理的连接数不是很高的话\",{\"1\":{\"1442\":1}}],[\"如果处于等待状态\",{\"1\":{\"618\":1}}],[\"如果处于锁状态的线程技术不减一\",{\"1\":{\"613\":1}}],[\"如果正在扩容\",{\"1\":{\"1431\":1}}],[\"如果链表树超过8\",{\"1\":{\"1431\":1}}],[\"如果哈希值和key都一样\",{\"1\":{\"1434\":1}}],[\"如果哈希冲突\",{\"1\":{\"1431\":1}}],[\"如果哈希桶的数组很小\",{\"1\":{\"1423\":1}}],[\"如果哈希桶的数组很大\",{\"1\":{\"1423\":1}}],[\"如果并未满足第三步\",{\"1\":{\"1431\":1}}],[\"如果并不需要对结果进行排序\",{\"1\":{\"553\":1}}],[\"如果其他线程初始化失败还可以顶替上去\",{\"1\":{\"1431\":1}}],[\"如果小于0表示concurrenthashmap正在执行初始化操作\",{\"1\":{\"1431\":1}}],[\"如果小于某个值\",{\"1\":{\"595\":1}}],[\"如果容器没有初始化\",{\"1\":{\"1431\":1}}],[\"如果上面这些都无法实现\",{\"1\":{\"1497\":1}}],[\"如果上面都不满足\",{\"1\":{\"1431\":1}}],[\"如果上面第二条sql使用nlj\",{\"1\":{\"662\":1}}],[\"如果同时触发了rehash操作\",{\"1\":{\"1428\":1}}],[\"如果同时出现using\",{\"1\":{\"467\":1}}],[\"如果多个线程访问元\",{\"1\":{\"1497\":1}}],[\"如果多个线程同时put时\",{\"1\":{\"1428\":1}}],[\"如果多个变量同属于一个缓存行\",{\"1\":{\"1396\":1}}],[\"如果内存紧张而对时间效率要求不高\",{\"1\":{\"1423\":1}}],[\"如果内存很多而又对时间效率要求很高\",{\"1\":{\"1423\":1}}],[\"如果内存足够\",{\"1\":{\"493\":1}}],[\"如果守护条件不满足\",{\"1\":{\"1408\":1}}],[\"如果写操作非常少\",{\"1\":{\"1404\":1}}],[\"如果获取电商s1报价的耗时很长\",{\"1\":{\"1394\":1}}],[\"如果运行了10个任务\",{\"1\":{\"1393\":1}}],[\"如果运气不够好的话\",{\"1\":{\"615\":1}}],[\"如果运气好\",{\"1\":{\"464\":1}}],[\"如果希望在计算任务完成后执行特定动作\",{\"1\":{\"1393\":1}}],[\"如果取之前队列长度等于容量\",{\"1\":{\"1380\":1}}],[\"如果取之前队列长度大于1\",{\"1\":{\"1380\":1}}],[\"如果原来的线程将spliterator交由另外一个线程处理的话\",{\"1\":{\"1497\":1}}],[\"如果原队列长度为0\",{\"1\":{\"1380\":1}}],[\"如果原实例没有使用gtid模式\",{\"1\":{\"622\":1}}],[\"如果现在不适合执行这个操作\",{\"1\":{\"1408\":1}}],[\"如果现在有一个高频请求\",{\"1\":{\"475\":1}}],[\"如果现队列长度小于容量\",{\"1\":{\"1380\":1}}],[\"如果没传容量\",{\"1\":{\"1380\":1}}],[\"如果没有开启事务\",{\"1\":{\"1530\":1}}],[\"如果没有找到bean\",{\"1\":{\"1525\":1}}],[\"如果没有的话\",{\"1\":{\"1499\":1}}],[\"如果没有设置这个特性\",{\"1\":{\"1494\":1}}],[\"如果没有元素\",{\"1\":{\"1490\":1}}],[\"如果没有默认方法\",{\"1\":{\"1484\":1}}],[\"如果没有被实现类所指定的话\",{\"1\":{\"1472\":1}}],[\"如果没有自定义\",{\"1\":{\"1431\":1}}],[\"如果没有数据\",{\"1\":{\"1378\":2}}],[\"如果没有老大了\",{\"1\":{\"748\":1}}],[\"如果没有任何事件到来\",{\"1\":{\"740\":1}}],[\"如果没有读够线程就会卡在那里\",{\"1\":{\"739\":1}}],[\"如果没有所有数据都不相等的列\",{\"1\":{\"642\":1}}],[\"如果没有主键\",{\"1\":{\"642\":1}}],[\"如果没有再操作普通表\",{\"1\":{\"549\":1}}],[\"如果没有where条件\",{\"1\":{\"533\":1}}],[\"如果没有合适的索引mysql就不得不使用一种更糟糕的访问类型\",{\"1\":{\"527\":1}}],[\"如果没有同时出现using\",{\"1\":{\"467\":1}}],[\"如果没有\",{\"1\":{\"459\":1,\"1543\":1}}],[\"如果没有命中查询缓存\",{\"1\":{\"457\":1}}],[\"如果没有cookie\",{\"0\":{\"224\":1}}],[\"如果生产速度和消费速度基本匹配的情况下\",{\"1\":{\"1379\":1}}],[\"如果队列无元素\",{\"1\":{\"1380\":1}}],[\"如果队列已满\",{\"1\":{\"1378\":3}}],[\"如果队列没满\",{\"1\":{\"1378\":1}}],[\"如果队列满了\",{\"1\":{\"1377\":2,\"1380\":1}}],[\"如果队列为空\",{\"1\":{\"742\":1,\"1379\":1}}],[\"如果读锁已被多个线程获取\",{\"1\":{\"1375\":1}}],[\"如果jvm检测到有一连串的对同一个对象的加锁和解锁的操作\",{\"1\":{\"1363\":1}}],[\"如果jvm检测到有一连串零碎的操作都是对同一对象的加锁\",{\"1\":{\"1363\":1}}],[\"如果join\",{\"1\":{\"542\":1}}],[\"如果join语句很慢\",{\"1\":{\"540\":1}}],[\"如果超过\",{\"1\":{\"1426\":1}}],[\"如果超过这个时间\",{\"1\":{\"761\":1}}],[\"如果超过了这个参数规定的大小\",{\"1\":{\"587\":1}}],[\"如果脚本在执行过程中由于收到系统中断信号被终止了\",{\"1\":{\"761\":1}}],[\"如果缓冲区满了\",{\"1\":{\"740\":1}}],[\"如果\",{\"1\":{\"729\":1,\"1431\":2}}],[\"如果允许容错\",{\"1\":{\"714\":1}}],[\"如果允许事务a把自增id回退\",{\"1\":{\"628\":1}}],[\"如果移除了所有值\",{\"1\":{\"708\":1}}],[\"如果kernel中的数据还没有准备好\",{\"1\":{\"1441\":1}}],[\"如果key存在\",{\"1\":{\"708\":1}}],[\"如果key不存在\",{\"1\":{\"708\":1,\"1495\":1}}],[\"如果k=5这个记录刚好是这个数据页的最后一个记录\",{\"1\":{\"479\":1}}],[\"如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\",{\"1\":{\"708\":2}}],[\"如果该位置未存放节点\",{\"1\":{\"1431\":1}}],[\"如果该值为default\",{\"1\":{\"694\":1}}],[\"如果该列的值为null的话\",{\"1\":{\"694\":1}}],[\"如果增大这个值的话会让优化器尽量少的创建基于内存的临时表\",{\"1\":{\"694\":2}}],[\"如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表\",{\"1\":{\"694\":2}}],[\"如果增大这个值的话会提升filesort的成本\",{\"1\":{\"694\":1}}],[\"如果连接表的个数小于该值\",{\"1\":{\"693\":1}}],[\"如果对于下游收集器而言\",{\"1\":{\"1495\":1}}],[\"如果对象的哈希值发生变化\",{\"1\":{\"1421\":1}}],[\"如果对象是一个数组\",{\"1\":{\"1361\":1}}],[\"如果对完整的列建立索引的话\",{\"1\":{\"690\":1}}],[\"如果对非索引字段更新\",{\"1\":{\"674\":1}}],[\"如果大于或等于200个的话\",{\"1\":{\"690\":1}}],[\"如果大部分的语句都会包含f的等值条件\",{\"1\":{\"548\":1}}],[\"如果页b和页c之间的页面实在太多\",{\"1\":{\"686\":1}}],[\"如果区间最左记录和区间最右记录相隔不太远\",{\"1\":{\"686\":1}}],[\"如果b事务回滚\",{\"1\":{\"669\":1}}],[\"如果bnl算法来join的话\",{\"1\":{\"544\":1}}],[\"如果实在要用可以考虑将blob和text字段单独存一张表\",{\"1\":{\"667\":1}}],[\"如果实例使用了gtid模式\",{\"1\":{\"622\":1}}],[\"如果实例b需要的日志已经不存在\",{\"1\":{\"605\":1}}],[\"如果实例x有从库\",{\"1\":{\"605\":1}}],[\"如果整形数据没有负数\",{\"1\":{\"665\":1}}],[\"如果值需要知道表的总行数的估计值可以用如下sql查询\",{\"1\":{\"663\":1}}],[\"如果放不下表t2的所有数据的话\",{\"1\":{\"662\":1}}],[\"如果放不下表t1的所有数据的话\",{\"1\":{\"540\":1}}],[\"如果被调用的方法在编译期无法被确定下来\",{\"1\":{\"1541\":1}}],[\"如果被流的源调用的话\",{\"1\":{\"1499\":1}}],[\"如果被标识的是主节点\",{\"1\":{\"758\":1}}],[\"如果被驱动表的关联字段没有索引\",{\"1\":{\"661\":1}}],[\"如果被kill\",{\"1\":{\"618\":1}}],[\"如果字段的总长度大于max\",{\"1\":{\"657\":1}}],[\"如果字段的总长度小于max\",{\"1\":{\"657\":1}}],[\"如果字段id被定义为auto\",{\"1\":{\"628\":1}}],[\"如果出现相同的row\",{\"1\":{\"636\":1}}],[\"如果table\",{\"1\":{\"1426\":1}}],[\"如果tps更高\",{\"1\":{\"634\":1}}],[\"如果t1和t2都是10万行的表\",{\"1\":{\"539\":1}}],[\"如果再使用map类描述的话并不是特别清晰\",{\"1\":{\"1495\":1}}],[\"如果再有插入数据的行为要来申请row\",{\"1\":{\"632\":1}}],[\"如果再长一点\",{\"1\":{\"489\":1}}],[\"如果x≥y\",{\"1\":{\"628\":1}}],[\"如果x<y\",{\"1\":{\"628\":1}}],[\"如果插入数据时id字段执行了具体的值\",{\"1\":{\"628\":1}}],[\"如果插入数据时id字段指定为0\",{\"1\":{\"628\":1}}],[\"如果插入新的行id值为700\",{\"1\":{\"472\":1}}],[\"如果发生了哈希冲突的话\",{\"1\":{\"1427\":1}}],[\"如果发生变动的记录数量超过了表的大小10\",{\"1\":{\"696\":1}}],[\"如果发生重启\",{\"1\":{\"627\":1}}],[\"如果发现当前对象是string\",{\"1\":{\"1515\":1}}],[\"如果发现符合终止条件\",{\"1\":{\"1401\":1}}],[\"如果发现线程状态是thd\",{\"1\":{\"618\":1}}],[\"如果发现查询需要扫描大量的数据但只返回少数的行\",{\"1\":{\"527\":1}}],[\"如果需要进行aop\",{\"1\":{\"1526\":1}}],[\"如果需要在线程安全的场合下使用\",{\"1\":{\"1421\":1}}],[\"如果需要在并发场景中使用一个线程不安全的工具类\",{\"1\":{\"1405\":1}}],[\"如果需要满足线程安全\",{\"1\":{\"1421\":1}}],[\"如果需要扩容\",{\"1\":{\"1419\":1,\"1431\":1}}],[\"如果需要一个高性能的系统\",{\"1\":{\"1397\":1}}],[\"如果需要自动生成自增值\",{\"1\":{\"627\":1}}],[\"如果需要用binlog来恢复临时库的话\",{\"1\":{\"464\":1}}],[\"如果设置了的话\",{\"1\":{\"1541\":1}}],[\"如果设置了这个特性值\",{\"1\":{\"1495\":1}}],[\"如果设置了这个属性\",{\"1\":{\"1494\":1}}],[\"如果设置了concurrent特性\",{\"1\":{\"1494\":3}}],[\"如果设置了identity\",{\"1\":{\"1492\":1}}],[\"如果设置了sql\",{\"1\":{\"621\":1}}],[\"如果设置过多的线程数\",{\"1\":{\"1387\":1}}],[\"如果设置binlog\",{\"1\":{\"596\":1}}],[\"如果忘记在delete或者update语句中写where条件\",{\"1\":{\"621\":1}}],[\"如果误删数据涉及到了多个事务的话\",{\"1\":{\"621\":1}}],[\"如果误操作不是一个\",{\"1\":{\"621\":1}}],[\"如果误执行了update语句的话\",{\"1\":{\"591\":1}}],[\"如果本地处理得慢\",{\"1\":{\"619\":1}}],[\"如果线程中断抛出异常\",{\"1\":{\"1379\":2}}],[\"如果线程直接被kill掉\",{\"1\":{\"618\":1}}],[\"如果线程不安全\",{\"0\":{\"184\":1}}],[\"如果打开redo\",{\"1\":{\"616\":1}}],[\"如果打开所有的preformance\",{\"1\":{\"616\":1}}],[\"如果刚开始执行的时候\",{\"1\":{\"610\":1}}],[\"如果刚刚在数据表中插入了一行\",{\"1\":{\"534\":1}}],[\"如果等待超过n秒\",{\"1\":{\"610\":1}}],[\"如果等于\",{\"1\":{\"363\":1}}],[\"如果启用了semi\",{\"1\":{\"609\":1}}],[\"如果m>d\",{\"1\":{\"665\":1}}],[\"如果master\",{\"1\":{\"609\":1}}],[\"如果mysql排序内存有条件可以配置的比较大\",{\"1\":{\"657\":1}}],[\"如果mysql排序内存sort\",{\"1\":{\"657\":1}}],[\"如果mysql出现了性能瓶颈\",{\"1\":{\"588\":1}}],[\"如果mysql重启后会失效\",{\"1\":{\"565\":1}}],[\"如果觉得精度不够\",{\"1\":{\"609\":1}}],[\"如果延迟超过1秒\",{\"1\":{\"608\":1}}],[\"如果channel上面有新的连接读写事件的时候就会被轮询出来\",{\"1\":{\"1451\":1}}],[\"如果cell\",{\"1\":{\"1357\":2}}],[\"如果cmpxchgl执行时compare\",{\"1\":{\"1356\":2}}],[\"如果cardinality属性是1的话\",{\"1\":{\"690\":1}}],[\"如果current\",{\"1\":{\"605\":2}}],[\"如果count函数的参数不是null\",{\"1\":{\"536\":1}}],[\"如果gtid\",{\"1\":{\"605\":2}}],[\"如果单个事务的行数超过10万行\",{\"1\":{\"599\":1}}],[\"如果单行的长度超过了这个值\",{\"1\":{\"492\":1}}],[\"如果碰到问题\",{\"1\":{\"1497\":1}}],[\"如果碰到热点表\",{\"1\":{\"598\":1}}],[\"如果碰到不适合创建索引的场景\",{\"1\":{\"555\":1}}],[\"如果跟多于一个worker冲突\",{\"1\":{\"598\":1}}],[\"如果跟所有worker都不冲突\",{\"1\":{\"598\":1}}],[\"如果跟自己的相同\",{\"1\":{\"592\":1}}],[\"如果过了很久才发现数据不一致的问题\",{\"1\":{\"596\":1}}],[\"如果将这个枚举值修改为\",{\"1\":{\"1494\":1}}],[\"如果将这个语句中的union改成union\",{\"1\":{\"551\":1}}],[\"如果将可靠性优先策略步骤的4\",{\"1\":{\"596\":1}}],[\"如果相等\",{\"1\":{\"1356\":1}}],[\"如果相同\",{\"1\":{\"592\":1,\"1356\":1,\"1426\":1}}],[\"如果相交则不合并\",{\"1\":{\"356\":1}}],[\"如果节点a同时是节点b的备库\",{\"1\":{\"592\":1}}],[\"如果操作的是多张彪\",{\"1\":{\"591\":1}}],[\"如果in语句里的参数过多\",{\"1\":{\"690\":1}}],[\"如果innodb\",{\"1\":{\"588\":1,\"696\":1}}],[\"如果id=2这一行所在的数据页本来就在内存中\",{\"1\":{\"463\":1}}],[\"如果主机断开了连接\",{\"1\":{\"748\":1}}],[\"如果主机发生异常重启\",{\"1\":{\"587\":1}}],[\"如果主库a和备库b都用相同的更新命令\",{\"1\":{\"615\":1}}],[\"如果主库上有个表被误删了\",{\"1\":{\"623\":1}}],[\"如果主库上的表都放在同一个db里面\",{\"1\":{\"600\":1}}],[\"如果主库上执行\",{\"1\":{\"550\":1}}],[\"如果主备库及其的系统时间设置不一致\",{\"1\":{\"594\":1}}],[\"如果还有时间和精力的小伙伴\",{\"1\":{\"1866\":1}}],[\"如果还有其它年份的数据\",{\"1\":{\"503\":1}}],[\"如果还想调用\",{\"1\":{\"1500\":1}}],[\"如果还不等于0\",{\"1\":{\"609\":1}}],[\"如果还要减少记录的值\",{\"1\":{\"581\":1}}],[\"如果事务中需要锁多个行\",{\"1\":{\"580\":1}}],[\"如果客户端发生异常\",{\"1\":{\"575\":1}}],[\"如果客户端持续有请求\",{\"1\":{\"455\":1}}],[\"如果备份过程中有更新\",{\"1\":{\"575\":1}}],[\"如果从server层看的话\",{\"1\":{\"562\":1}}],[\"如果按照这个算法\",{\"1\":{\"559\":1}}],[\"如果按照主键的递增顺序查询的话\",{\"1\":{\"541\":1}}],[\"如果只有identity\",{\"1\":{\"1495\":1}}],[\"如果只有读\",{\"1\":{\"1403\":1}}],[\"如果只是为了使用\",{\"1\":{\"1861\":1}}],[\"如果只是从使用的角度而言\",{\"1\":{\"1490\":1}}],[\"如果只是从这两个函数的计算复杂度来看的话\",{\"1\":{\"489\":1}}],[\"如果只是把session\",{\"1\":{\"618\":1}}],[\"如果只跟一个worker冲突\",{\"1\":{\"598\":1}}],[\"如果只随机选择1个word值\",{\"1\":{\"559\":1}}],[\"如果redis意外宕机了\",{\"1\":{\"727\":1}}],[\"如果row的trx\",{\"1\":{\"679\":5}}],[\"如果r\",{\"1\":{\"558\":1}}],[\"如果r5所在的数据页已经满了\",{\"1\":{\"472\":1}}],[\"如果临时表大小超过了tmp\",{\"1\":{\"558\":1}}],[\"如果临时表中没有主键为x的行\",{\"1\":{\"553\":1}}],[\"如果创建的innodb表没有指定主键\",{\"1\":{\"632\":1}}],[\"如果创建的表没有主键\",{\"1\":{\"557\":1}}],[\"如果创建索引的语句不指定前缀长度\",{\"1\":{\"487\":1}}],[\"如果扫描过程中可以保证出现的数据是有序的\",{\"1\":{\"554\":1}}],[\"如果表中已经存在row\",{\"1\":{\"632\":1}}],[\"如果表中有主键为x的行\",{\"1\":{\"553\":1}}],[\"如果表的数据量比较大\",{\"1\":{\"554\":1}}],[\"如果直接发起主备切换\",{\"1\":{\"596\":1}}],[\"如果直接执行\",{\"1\":{\"550\":1}}],[\"如果直接使用join语句\",{\"1\":{\"538\":1}}],[\"如果关于临时表的操作都不记录\",{\"1\":{\"550\":1}}],[\"如果关联中的某个表发生了变化\",{\"1\":{\"531\":1}}],[\"如果涉及到复杂的操作\",{\"1\":{\"548\":1}}],[\"如果仅需要order\",{\"1\":{\"548\":1}}],[\"如果仅仅看查询效率\",{\"1\":{\"470\":1}}],[\"如果这时候单独恢复这几行数据\",{\"1\":{\"621\":1}}],[\"如果这时候在从库b上执行查询请求\",{\"1\":{\"609\":1}}],[\"如果这时使用select\",{\"1\":{\"613\":1}}],[\"如果这两个集合相同\",{\"1\":{\"609\":1}}],[\"如果这两条更新语句被分到不同的worker的话\",{\"1\":{\"597\":1}}],[\"如果这条语句是一个低频的sql语句\",{\"1\":{\"544\":1}}],[\"如果这个流管道已经知道了拥有短路的阶段\",{\"1\":{\"1500\":1}}],[\"如果这个spliterator的元通过comparator是sorted\",{\"1\":{\"1497\":1}}],[\"如果这个spliterator是sized\",{\"1\":{\"1497\":1}}],[\"如果这个spliterator是可以被分割的\",{\"1\":{\"1497\":1}}],[\"如果这个spliterator是ordered\",{\"1\":{\"1497\":2}}],[\"如果这个spliterator报告了spliterator\",{\"1\":{\"1497\":1}}],[\"如果这个时候老大修复了\",{\"1\":{\"748\":1}}],[\"如果这个时候发现主库的系统时间与自己的不一致\",{\"1\":{\"594\":1}}],[\"如果这个临时库上有多个数据库\",{\"1\":{\"622\":1}}],[\"如果这个查询请求本来0\",{\"1\":{\"608\":1}}],[\"如果这个事务回滚了\",{\"1\":{\"605\":1}}],[\"如果这个binlog过了1分钟才传给备库的话\",{\"1\":{\"591\":1}}],[\"如果这个表上的查询语句频繁\",{\"1\":{\"578\":1}}],[\"如果这个表上还有另外一个索引k\",{\"1\":{\"548\":1}}],[\"如果这个表t1的数据量很大\",{\"1\":{\"553\":1}}],[\"如果这个冷表很大\",{\"1\":{\"543\":1}}],[\"如果这个被驱动表是一个大的冷数据表\",{\"1\":{\"543\":1}}],[\"如果这个\",{\"1\":{\"536\":2}}],[\"如果这个格子不是岛屿\",{\"1\":{\"435\":1}}],[\"如果满足t1\",{\"1\":{\"544\":1}}],[\"如果1秒之后这个数据也不再被访问了\",{\"1\":{\"543\":1}}],[\"如果想深入学习\",{\"1\":{\"1861\":1}}],[\"如果想做出更好的交互式效果\",{\"1\":{\"1855\":1}}],[\"如果想要深入学习\",{\"1\":{\"1852\":1}}],[\"如果想要稳定地使用mrr优化的话\",{\"1\":{\"541\":1}}],[\"如果想让spring自动选择构造方法以及构造方法的入参值\",{\"1\":{\"1527\":1}}],[\"如果想将学生的名字使用字符串拼接呢\",{\"1\":{\"1493\":1}}],[\"如果想输入两个参数并返回结果\",{\"1\":{\"1475\":1}}],[\"如果想达到足以媲美\",{\"1\":{\"733\":1}}],[\"如果想提升binlog组提交的效果\",{\"1\":{\"588\":1}}],[\"如果想查询所有在电影academy\",{\"1\":{\"521\":1}}],[\"如果步骤1中\",{\"1\":{\"541\":1}}],[\"如果随着a的值递增顺序查询的话\",{\"1\":{\"541\":1}}],[\"如果每个位置上的元素数量只有一个\",{\"1\":{\"1425\":1}}],[\"如果每次删除数据后\",{\"1\":{\"530\":1}}],[\"如果每一次的更新操作都需要写进磁盘\",{\"1\":{\"461\":1}}],[\"如果把binlog\",{\"1\":{\"591\":1}}],[\"如果把innodb\",{\"1\":{\"588\":1}}],[\"如果把查询看作是一个任务\",{\"1\":{\"518\":1}}],[\"如果把整张表取出来一行行统计\",{\"1\":{\"484\":1}}],[\"如果一旦在自己的代码实现过list\",{\"1\":{\"1484\":1}}],[\"如果一开始就固定一个容量\",{\"1\":{\"1386\":1}}],[\"如果一项业务跑的时间足够长\",{\"1\":{\"563\":1}}],[\"如果一定要使用\",{\"1\":{\"512\":1}}],[\"如果一个流确实需要关闭\",{\"1\":{\"1496\":1}}],[\"如果一个结果被传递给combiner或者finisher函数了\",{\"1\":{\"1492\":1}}],[\"如果一个结点存在黑子结点\",{\"1\":{\"343\":1}}],[\"如果一个函数接收一个函数作为参数\",{\"1\":{\"1475\":1}}],[\"如果一个接口只有一个抽象方法\",{\"1\":{\"1471\":1}}],[\"如果一个接口满足了函数式接口的定义\",{\"1\":{\"1471\":1}}],[\"如果一个接口上有\",{\"1\":{\"1471\":1}}],[\"如果一个接口上使用了\",{\"1\":{\"1471\":1}}],[\"如果一个对象在子程序中被分配\",{\"1\":{\"1365\":1}}],[\"如果一个对象被发现只能从一个线程被访问到\",{\"1\":{\"1365\":1}}],[\"如果一个客户端订阅了频道\",{\"1\":{\"737\":1}}],[\"如果一个语句申请了一个表自增锁\",{\"1\":{\"629\":1}}],[\"如果一个库的备份特别大\",{\"1\":{\"623\":1}}],[\"如果一个线程的状态是kill\",{\"1\":{\"618\":1}}],[\"如果一个表当前数据行里最大的id是10\",{\"1\":{\"627\":1}}],[\"如果一个表上除了有主键索引外\",{\"1\":{\"602\":1}}],[\"如果一个表中有2000条记录\",{\"1\":{\"496\":1}}],[\"如果一个主库上执行10分钟\",{\"1\":{\"594\":1}}],[\"如果一个分区表的分区很多\",{\"1\":{\"562\":1}}],[\"如果索引是多字段的复合索引\",{\"1\":{\"507\":1}}],[\"如果数据库中的键过多可能会造成卡顿\",{\"1\":{\"704\":1}}],[\"如果数据库开启了gtid模式\",{\"1\":{\"611\":1}}],[\"如果数据量比较大\",{\"1\":{\"505\":1}}],[\"如果数据页在内存中就直接更新\",{\"1\":{\"480\":1}}],[\"如果sourcesupplier是空的\",{\"1\":{\"1498\":1}}],[\"如果sourcespliterator是非空的话\",{\"1\":{\"1498\":1}}],[\"如果sort\",{\"1\":{\"491\":1,\"555\":1}}],[\"如果spring整合mybatis之后\",{\"1\":{\"1530\":1}}],[\"如果spring设置了就用已经设置的隔离级别\",{\"1\":{\"669\":1}}],[\"如果spliterator是sized就会返回estimatesize的值\",{\"1\":{\"1497\":1}}],[\"如果spliterator是subsized\",{\"1\":{\"1497\":1}}],[\"如果spliterator是ordered\",{\"1\":{\"1497\":1}}],[\"如果spliterator没有报告immutable或者concurrent\",{\"1\":{\"1497\":1}}],[\"如果sizectl值大于等于0\",{\"1\":{\"1431\":1}}],[\"如果sentinel\",{\"1\":{\"761\":1}}],[\"如果session\",{\"1\":{\"629\":1}}],[\"如果select\",{\"1\":{\"613\":1}}],[\"如果sql语句中条件是where\",{\"1\":{\"503\":1}}],[\"如果定义的index2不是email\",{\"1\":{\"487\":1}}],[\"如果entrylist为空\",{\"1\":{\"1360\":1}}],[\"如果email这个字段上没有索引\",{\"1\":{\"487\":1}}],[\"如果explain的结果预估的rows的值跟实际情况差距比较大\",{\"1\":{\"484\":1}}],[\"如果选择索引b的话\",{\"1\":{\"485\":1}}],[\"如果使用\",{\"1\":{\"1527\":1}}],[\"如果使用spliterator不能进行分割\",{\"1\":{\"1497\":1}}],[\"如果使用原来传统的方式又该怎么做呢\",{\"1\":{\"1488\":1}}],[\"如果使用方法引用甚至能够让代码变的更加简洁\",{\"1\":{\"1470\":1}}],[\"如果使用排序的映射\",{\"1\":{\"1421\":1}}],[\"如果使用了truncate\",{\"1\":{\"622\":1}}],[\"如果使用delete语句误删了数据行\",{\"1\":{\"621\":1}}],[\"如果使用api开发\",{\"1\":{\"619\":1}}],[\"如果使用api\",{\"1\":{\"619\":1}}],[\"如果使用上面提到的策略\",{\"1\":{\"609\":1}}],[\"如果使用归并算法就会浪费非常多的计算量\",{\"1\":{\"558\":1}}],[\"如果使用归并排序算法的话\",{\"1\":{\"558\":1}}],[\"如果使用普通表\",{\"1\":{\"547\":1}}],[\"如果使用inndb引擎或者myisam引擎的临时表\",{\"1\":{\"546\":1}}],[\"如果使用index1\",{\"1\":{\"488\":1}}],[\"如果使用block\",{\"1\":{\"540\":1}}],[\"如果使用join语句\",{\"1\":{\"540\":1}}],[\"如果使用join语句的话\",{\"1\":{\"538\":1}}],[\"如果使用的是指定大小的构造器\",{\"1\":{\"1419\":1}}],[\"如果使用的是无参构造器\",{\"1\":{\"1419\":1}}],[\"如果使用的是索引执行的单表扫描\",{\"1\":{\"691\":1}}],[\"如果使用的是全表扫描的方式执行的单表查询\",{\"1\":{\"691\":1}}],[\"如果使用的是index2\",{\"1\":{\"487\":1}}],[\"如果使用的是index1\",{\"1\":{\"487\":1}}],[\"如果使用的mysql5\",{\"1\":{\"455\":1}}],[\"如果使用索引的话\",{\"1\":{\"691\":1}}],[\"如果使用索引b进行查询\",{\"1\":{\"484\":1}}],[\"如果使用索引a进行查询\",{\"1\":{\"484\":1}}],[\"如果使用索引a\",{\"1\":{\"484\":1}}],[\"如果都已经读入到内存了\",{\"1\":{\"480\":1}}],[\"如果业务代码已经保证了不会写入重复的身份证号\",{\"1\":{\"478\":1}}],[\"如果市民系统需要按照身份证号查姓名\",{\"1\":{\"478\":1}}],[\"如果既有联合查询\",{\"1\":{\"476\":1}}],[\"如果可以使用特化版本就不要使用通用版本\",{\"1\":{\"1497\":1}}],[\"如果可以使用index\",{\"1\":{\"540\":1}}],[\"如果可以帮助扩容\",{\"1\":{\"1431\":1}}],[\"如果可以\",{\"1\":{\"692\":1}}],[\"如果可以控制并发量\",{\"1\":{\"581\":1}}],[\"如果可以确保输入的数据是有序的\",{\"1\":{\"554\":1}}],[\"如果可以通过调整联合索引的顺序\",{\"1\":{\"476\":1}}],[\"如果可能的话\",{\"1\":{\"467\":1}}],[\"如果执行成功\",{\"1\":{\"1532\":1}}],[\"如果执行下面的sql\",{\"1\":{\"673\":1}}],[\"如果执行计划extra中未出现using\",{\"1\":{\"661\":1}}],[\"如果执行期间\",{\"1\":{\"610\":1}}],[\"如果执行完一条delete语句以后\",{\"1\":{\"591\":1}}],[\"如果执行的次数过多\",{\"1\":{\"1494\":1}}],[\"如果执行的update语句\",{\"1\":{\"591\":1}}],[\"如果执行的是delete语句\",{\"1\":{\"591\":1}}],[\"如果执行的语句是select\",{\"1\":{\"475\":1}}],[\"如果执行ftwrl命令之后由于客户端发生异常断开\",{\"1\":{\"575\":1}}],[\"如果执行mmit\",{\"1\":{\"572\":1}}],[\"如果执行commit则提交事务\",{\"1\":{\"572\":1}}],[\"如果执行逻辑需要用到二维表特性\",{\"1\":{\"555\":1}}],[\"如果执行如下语句\",{\"1\":{\"553\":1}}],[\"如果执行select\",{\"1\":{\"473\":1}}],[\"如果新插入的id的值为400\",{\"1\":{\"472\":1}}],[\"如果语句执行过程可以一边读数据\",{\"1\":{\"555\":1}}],[\"如果语句是select\",{\"1\":{\"472\":2}}],[\"如果语句不对\",{\"1\":{\"457\":1}}],[\"如果语句不在查询缓存中\",{\"1\":{\"456\":1}}],[\"如果我们想求出学生分数的最小值\",{\"1\":{\"1493\":1}}],[\"如果我们想实现收集器的复合改怎么做呢\",{\"1\":{\"1492\":1}}],[\"如果我们想定义四则运算的话\",{\"1\":{\"1475\":1}}],[\"如果我们使用并行流\",{\"1\":{\"1494\":1}}],[\"如果我们使用传统的编码方式来实现对于名字的分组操作\",{\"1\":{\"1490\":1}}],[\"如果我们使用有序数组来实现的话\",{\"1\":{\"470\":1}}],[\"如果我们将刚才的操作反过来\",{\"1\":{\"1487\":1}}],[\"如果我们改一下需求\",{\"1\":{\"1487\":1}}],[\"如果我们在accumulator中打印当前线程的名称\",{\"1\":{\"1494\":1}}],[\"如果我们在某个接口上声明了functionalinterface注解\",{\"1\":{\"1471\":1}}],[\"如果我们在创建表的语句并没有制定stats\",{\"1\":{\"695\":1}}],[\"如果我们在创建表时未指定stats\",{\"1\":{\"695\":1,\"696\":1}}],[\"如果我们只需要最快的那一个结果\",{\"1\":{\"1394\":1}}],[\"如果我们设置过少的线程数\",{\"1\":{\"1387\":1}}],[\"如果我们设置了双m结构\",{\"1\":{\"592\":1}}],[\"如果我们的场景需要直接传递的话\",{\"1\":{\"1386\":1}}],[\"如果我们需要动态扩容的话\",{\"1\":{\"1386\":1}}],[\"如果我们删除对应的索引再来运行这个查询\",{\"1\":{\"527\":1}}],[\"如果我们用二叉搜索树来实现上述的例子\",{\"1\":{\"471\":1}}],[\"如果我们暂时忽略颜色\",{\"1\":{\"343\":1}}],[\"如果为null\",{\"1\":{\"467\":1}}],[\"如果为空直接添加\",{\"1\":{\"302\":1}}],[\"如果第一个参数大于第二个参数\",{\"1\":{\"1480\":1}}],[\"如果第一个比第二个大\",{\"1\":{\"317\":1}}],[\"如果第二个select出现在union之后\",{\"1\":{\"467\":1}}],[\"如果在当前的beanfactory中没有找到\",{\"1\":{\"1524\":1}}],[\"如果在操作原生子类型特化的时候\",{\"1\":{\"1497\":1}}],[\"如果在绑定元之前对元进行了修改的话\",{\"1\":{\"1497\":1}}],[\"如果在计算过程中\",{\"1\":{\"1476\":1}}],[\"如果在高并发的情况下\",{\"1\":{\"1450\":1}}],[\"如果在新表的数组索引位置相同\",{\"1\":{\"1427\":1}}],[\"如果在订阅方断线\",{\"1\":{\"737\":1}}],[\"如果在分析某个连接顺序的成本时\",{\"1\":{\"693\":1}}],[\"如果在select语句后面加上for\",{\"1\":{\"634\":1}}],[\"如果在实际使用中\",{\"1\":{\"619\":1}}],[\"如果在连接命令中加上\",{\"1\":{\"619\":1}}],[\"如果在连接被断开之后\",{\"1\":{\"455\":1}}],[\"如果在业务更新的高峰期\",{\"1\":{\"609\":1}}],[\"如果在主库上有多个db\",{\"1\":{\"600\":1}}],[\"如果在这个执行的等待时间里面能够拿到mdl写锁最好\",{\"1\":{\"578\":1}}],[\"如果在binlog写完之后crash\",{\"1\":{\"464\":1}}],[\"如果write\",{\"1\":{\"461\":1}}],[\"如果要深入学习mysql的使用和原理\",{\"1\":{\"1852\":1}}],[\"如果要指定构造方法\",{\"1\":{\"1507\":1}}],[\"如果要正常编译运行\",{\"1\":{\"1491\":1}}],[\"如果要按照长度来进行排序\",{\"1\":{\"1491\":1}}],[\"如果要根据年龄来分组呢\",{\"1\":{\"1490\":1}}],[\"如果要改用串行流改怎么做呢\",{\"1\":{\"1489\":1}}],[\"如果要改回默认值\",{\"1\":{\"694\":1}}],[\"如果要调用系统资源\",{\"1\":{\"1456\":1}}],[\"如果要我们手动用future实现\",{\"1\":{\"1395\":1}}],[\"如果要避免不安全\",{\"1\":{\"720\":1}}],[\"如果要避免切换过程中有不可用时间的这个问题\",{\"1\":{\"595\":1}}],[\"如果要修改上述参数\",{\"1\":{\"694\":1}}],[\"如果要操作多行的大事务的话\",{\"1\":{\"599\":1}}],[\"如果要在表中删除一行数据的话\",{\"1\":{\"591\":1}}],[\"如果要在id\",{\"1\":{\"478\":1}}],[\"如果要做ddl变更的表刚好有长事务在执行\",{\"1\":{\"578\":1}}],[\"如果要手工分析日志\",{\"1\":{\"566\":1}}],[\"如果要使慢查询日志永久开启\",{\"1\":{\"565\":1}}],[\"如果要使用串行流\",{\"1\":{\"1494\":1}}],[\"如果要使用传统的方式实现这些需求\",{\"1\":{\"1476\":1}}],[\"如果要使用bka优化算法的话\",{\"1\":{\"542\":1}}],[\"如果要使用邮箱登录\",{\"1\":{\"486\":1}}],[\"如果要使用覆盖索引\",{\"1\":{\"467\":1}}],[\"如果要优化查询\",{\"1\":{\"518\":1}}],[\"如果要排序的数据量小于sort\",{\"1\":{\"491\":1}}],[\"如果要为每一种查询都设计一个索引\",{\"1\":{\"476\":1}}],[\"如果要查询id=2的交易的所有操作步骤信息\",{\"1\":{\"505\":1}}],[\"如果要查询区间的时间复杂度也是o\",{\"1\":{\"470\":1}}],[\"如果要查的是所有名字第一个字的是\",{\"1\":{\"476\":1}}],[\"如果要查找身份证号在\",{\"1\":{\"469\":1}}],[\"如果要将id=2这一行的值加1\",{\"1\":{\"460\":1}}],[\"如果要用队列来实现栈\",{\"1\":{\"334\":1}}],[\"如果要用栈来实现队列\",{\"1\":{\"333\":1}}],[\"如果不需要\",{\"1\":{\"1526\":1}}],[\"如果不需要创建\",{\"1\":{\"1525\":1}}],[\"如果不满足以下情况编译器会报错\",{\"1\":{\"1471\":1}}],[\"如果不满足t1\",{\"1\":{\"544\":1}}],[\"如果不在扩容\",{\"1\":{\"1431\":1}}],[\"如果不成功\",{\"1\":{\"1397\":1}}],[\"如果不允许容错\",{\"1\":{\"714\":1}}],[\"如果不存在值\",{\"1\":{\"707\":1}}],[\"如果不设置隔离级别默认用mysql设置的隔离级别\",{\"1\":{\"669\":1}}],[\"如果不行\",{\"1\":{\"618\":1}}],[\"如果不加以限制\",{\"1\":{\"613\":1}}],[\"如果不加以小心\",{\"1\":{\"523\":1}}],[\"如果不包含\",{\"1\":{\"605\":1}}],[\"如果不同db的热点不同\",{\"1\":{\"600\":1}}],[\"如果不想每次都多\",{\"1\":{\"572\":1}}],[\"如果不是扫描出现的情况\",{\"1\":{\"1524\":1}}],[\"如果不是延迟绑定的spliterator\",{\"1\":{\"1497\":1}}],[\"如果不是调优需要的话\",{\"1\":{\"565\":1}}],[\"如果不是则跳过\",{\"1\":{\"459\":1}}],[\"如果不使用分区表的话\",{\"1\":{\"561\":1}}],[\"如果不使用\",{\"1\":{\"464\":1}}],[\"如果不用两阶段提交\",{\"1\":{\"464\":1}}],[\"如果不指定引擎类型\",{\"1\":{\"454\":1}}],[\"如果有一个bean有\",{\"1\":{\"1525\":1}}],[\"如果有一个字段可以排序\",{\"1\":{\"642\":1}}],[\"如果有\",{\"1\":{\"1507\":1}}],[\"如果有了一系列的中间操作\",{\"1\":{\"1499\":1}}],[\"如果有中间操作的话\",{\"1\":{\"1499\":1}}],[\"如果有长度为5的字符串\",{\"1\":{\"1489\":1}}],[\"如果有的话\",{\"1\":{\"1475\":1,\"1500\":1}}],[\"如果有的表使用了不支持事务的引擎\",{\"1\":{\"575\":1}}],[\"如果有结果不断从一个线程到另一个线程那么可以使用消息队列\",{\"1\":{\"1407\":1}}],[\"如果有这个需要\",{\"1\":{\"1386\":1}}],[\"如果有数据\",{\"1\":{\"1378\":1}}],[\"如果有足够的带宽可用\",{\"1\":{\"1351\":1}}],[\"如果有索引一般选择nlj算法\",{\"1\":{\"662\":1}}],[\"如果有并行的多个只读事务\",{\"1\":{\"634\":1}}],[\"如果有跨表的事务\",{\"1\":{\"598\":1}}],[\"如果有可能\",{\"1\":{\"591\":1,\"631\":1}}],[\"如果有多个\",{\"1\":{\"1525\":1}}],[\"如果有多个事务的binlog已经写完了\",{\"1\":{\"588\":1}}],[\"如果有多个session同时执行join优化\",{\"1\":{\"547\":1}}],[\"如果有两个线程要同时给一个表加字段\",{\"1\":{\"578\":1}}],[\"如果有两个大小不同的表做join\",{\"1\":{\"537\":1}}],[\"如果有就优先操作临时表\",{\"1\":{\"549\":1}}],[\"如果有根据身份证号查询市民信息的需求\",{\"1\":{\"475\":1}}],[\"如果有权限\",{\"1\":{\"459\":1}}],[\"如果有必要的话清理当前层不需要的全局变量或者其他东西\",{\"1\":{\"285\":1}}],[\"如果查询是基于分区表的话\",{\"1\":{\"643\":1}}],[\"如果查询是落在这个相应ack的从库上\",{\"1\":{\"609\":1}}],[\"如果查询结果太大\",{\"1\":{\"619\":1}}],[\"如果查询过程中生成了比较大的临时文件\",{\"1\":{\"618\":1}}],[\"如果查询选择的是从库的话\",{\"1\":{\"606\":1}}],[\"如果查询语句的where条件中没有分区key\",{\"1\":{\"562\":1}}],[\"如果查询没有办法找到合适的访问类型\",{\"1\":{\"527\":1}}],[\"如果查询写得很糟糕\",{\"1\":{\"518\":1}}],[\"如果查询命中缓存\",{\"1\":{\"456\":1}}],[\"如果查询能够直接这个缓存中找到key\",{\"1\":{\"456\":1}}],[\"如果你学的过程中\",{\"1\":{\"1850\":1}}],[\"如果你定义的是一个sqlsessionfactory类型的bean\",{\"1\":{\"1530\":1}}],[\"如果你非常关心你的数据\",{\"1\":{\"733\":1}}],[\"如果你还有一些疑问\",{\"1\":{\"651\":1}}],[\"如果你没有后续的动作\",{\"1\":{\"455\":1}}],[\"如果你连接的是生产服务器\",{\"1\":{\"455\":1}}],[\"如果用来检测主库的话\",{\"1\":{\"615\":1}}],[\"如果用select\",{\"1\":{\"585\":1}}],[\"如果用一个大的语句一次性完成的话\",{\"1\":{\"530\":1}}],[\"如果用身份证号做主键\",{\"1\":{\"472\":1}}],[\"如果用户名密码认证通过\",{\"1\":{\"455\":1}}],[\"如果用户名或密码不对\",{\"1\":{\"455\":1}}],[\"如果用数组来存储堆\",{\"1\":{\"354\":1}}],[\"如果坐标\",{\"1\":{\"435\":1}}],[\"如果右边界越界\",{\"1\":{\"428\":1}}],[\"如果p\",{\"1\":{\"398\":4}}],[\"如果栈中元素为空或者与map中括号不匹配\",{\"1\":{\"386\":1}}],[\"如果个数是奇数个直接返回\",{\"1\":{\"386\":1}}],[\"如果括号是匹配的\",{\"1\":{\"386\":1}}],[\"如果某个接口只有一个抽象方法\",{\"1\":{\"1471\":1}}],[\"如果某个表很少改变\",{\"1\":{\"531\":1}}],[\"如果某个4结点有孩子的话\",{\"1\":{\"348\":1}}],[\"如果某个3结点有孩子的话\",{\"1\":{\"347\":1}}],[\"如果存在相同的key\",{\"1\":{\"1431\":1}}],[\"如果存在同一时间多个线程访问同一把锁的场合\",{\"1\":{\"1362\":1}}],[\"如果存在bgsave命令直接返回\",{\"1\":{\"725\":1}}],[\"如果存在值\",{\"1\":{\"707\":1}}],[\"如果存在\",{\"1\":{\"345\":1,\"628\":1,\"1495\":1}}],[\"如果二叉树退化成了链表\",{\"1\":{\"339\":1}}],[\"如果问题具有公平性\",{\"1\":{\"334\":1}}],[\"如果问题具有最近相关性\",{\"1\":{\"333\":1}}],[\"如果待插入的元素与有序序列中的每个元素相等\",{\"1\":{\"319\":1}}],[\"如果验证位是1\",{\"1\":{\"307\":1}}],[\"如果是抽象的beandefinition不会创建bean\",{\"1\":{\"1524\":1}}],[\"如果是抽象类的话方法上面需要有\",{\"1\":{\"1524\":1}}],[\"如果是false\",{\"1\":{\"1498\":1}}],[\"如果是true表示并行\",{\"1\":{\"1498\":1}}],[\"如果是源阶段就是它自身\",{\"1\":{\"1498\":1}}],[\"如果是源阶段的话就是null\",{\"1\":{\"1498\":1}}],[\"如果是并行流\",{\"1\":{\"1494\":1,\"1499\":1}}],[\"如果是求出分数的总和呢\",{\"1\":{\"1493\":1}}],[\"如果是平均值呢\",{\"1\":{\"1493\":1}}],[\"如果是最大值呢\",{\"1\":{\"1493\":1}}],[\"如果是降序则\",{\"1\":{\"1491\":1}}],[\"如果是红黑树\",{\"1\":{\"1426\":1}}],[\"如果是使用全表扫描的话\",{\"1\":{\"691\":1}}],[\"如果是读已提交的隔离级别会在每次执行查询sql时都会重新生成\",{\"1\":{\"679\":1}}],[\"如果是误删表\",{\"1\":{\"622\":1}}],[\"如果是两个事务没有更新相同的行\",{\"1\":{\"599\":1}}],[\"如果是执行错了insert语句\",{\"1\":{\"591\":1}}],[\"如果是长连接\",{\"1\":{\"572\":1}}],[\"如果是长整型\",{\"1\":{\"472\":1}}],[\"如果是按月分区\",{\"1\":{\"563\":1}}],[\"如果是一个普通表的话\",{\"1\":{\"561\":1}}],[\"如果是mysql5\",{\"1\":{\"554\":1}}],[\"如果是大表就会占用非常多的cpu资源\",{\"1\":{\"543\":1}}],[\"如果是block\",{\"1\":{\"540\":1}}],[\"如果是index\",{\"1\":{\"540\":1}}],[\"如果是事务型引擎\",{\"1\":{\"530\":1}}],[\"如果是子查询\",{\"1\":{\"467\":1}}],[\"如果是则将这行存在结果集中\",{\"1\":{\"459\":1}}],[\"如果是第一个元素就是和它自己交换位置\",{\"1\":{\"318\":1}}],[\"如果是0\",{\"1\":{\"307\":1}}],[\"如果是\",{\"0\":{\"188\":1},\"1\":{\"544\":1}}],[\"如何判断当前bean对象需不需要进行aop\",{\"1\":{\"1507\":1}}],[\"如何判断一个主库出了问题\",{\"1\":{\"612\":1}}],[\"如何将子任务进行分割\",{\"1\":{\"1497\":1}}],[\"如何使用并行框架来尽心给计算\",{\"1\":{\"1497\":1}}],[\"如何使用反射获取私有属性\",{\"0\":{\"27\":1}}],[\"如何从工作内存到主内存之间的实现细节\",{\"1\":{\"1350\":1}}],[\"如何控制propertysource的优先级\",{\"0\":{\"1321\":1}}],[\"如何注册一个spring\",{\"0\":{\"1097\":1}}],[\"如何界定ioc容器是轻量级的\",{\"0\":{\"1071\":1}}],[\"如何选择合适的阻塞队列\",{\"0\":{\"1386\":1}}],[\"如何选择合适的索引\",{\"0\":{\"656\":1}}],[\"如何选择使用哪种持久化方式\",{\"0\":{\"733\":1}}],[\"如何查看一个应用的信息\",{\"0\":{\"263\":1}}],[\"如何手写一个注册中心\",{\"0\":{\"250\":1}}],[\"如何配置动态路由\",{\"0\":{\"249\":1}}],[\"如何通过服务名找到服务实例\",{\"0\":{\"246\":1}}],[\"如何实现配置自动更新messagesource\",{\"0\":{\"1221\":1}}],[\"如何实现单点登录系统\",{\"0\":{\"229\":1}}],[\"如何实现一个自定义的class作为hashmap的key\",{\"0\":{\"43\":1}}],[\"如何防止\",{\"0\":{\"225\":1}}],[\"如何设计一个权限认证框架\",{\"0\":{\"223\":1}}],[\"如何设计一个分布式锁\",{\"0\":{\"141\":1}}],[\"如何自己写一个springboot\",{\"0\":{\"195\":1}}],[\"如何处理\",{\"0\":{\"184\":1}}],[\"如何进行产品选型\",{\"0\":{\"253\":1}}],[\"如何进行中文分词\",{\"0\":{\"178\":1}}],[\"如何进行jvm调优\",{\"0\":{\"126\":1}}],[\"如何对锁性能进行优化\",{\"0\":{\"141\":1}}],[\"如何对一个字符串快速进行排序\",{\"0\":{\"88\":1}}],[\"如何回收方法区\",{\"0\":{\"117\":1}}],[\"如何访问对象\",{\"0\":{\"104\":1}}],[\"如何保证数据并发访问的一致性\",{\"1\":{\"670\":1}}],[\"如何保证消息的高效读写\",{\"0\":{\"257\":1}}],[\"如何保证消息不丢失\",{\"0\":{\"254\":1}}],[\"如何保证消费幂等性\",{\"0\":{\"255\":1}}],[\"如何保证线程安全\",{\"0\":{\"188\":1}}],[\"如何保证redis的高可用\",{\"0\":{\"154\":1}}],[\"如何保证redis与数据库的数据一致\",{\"0\":{\"138\":1}}],[\"如何保证接口的幂等性\",{\"0\":{\"91\":1}}],[\"如何保证三个线程有序交错进行\",{\"0\":{\"80\":1}}],[\"如何保证三个线程同时执行\",{\"0\":{\"80\":1}}],[\"如何获取子线程的执行结果\",{\"0\":{\"87\":1}}],[\"如何在并发情况下保证三个线程依次执行\",{\"0\":{\"80\":1}}],[\"如何停止一个正在运行的线程\",{\"0\":{\"55\":1}}],[\"多列集合\",{\"0\":{\"1417\":1}}],[\"多列索引的结构\",{\"1\":{\"642\":1}}],[\"多线程分工模式\",{\"0\":{\"1409\":1}}],[\"多线程版本的if模式\",{\"0\":{\"1406\":1}}],[\"多线程竞争锁会先存到这个单向链表中\",{\"1\":{\"1360\":1}}],[\"多生产者\",{\"1\":{\"1397\":1}}],[\"多核cpu自旋才能发挥优势\",{\"1\":{\"1362\":1}}],[\"多语言的支持\",{\"0\":{\"841\":1}}],[\"多协议消息\",{\"0\":{\"832\":1}}],[\"多的slave因为replication而不可用\",{\"1\":{\"761\":1}}],[\"多的时候只能估算\",{\"1\":{\"690\":1}}],[\"多哨兵模式\",{\"0\":{\"758\":1}}],[\"多路复用\",{\"0\":{\"740\":1},\"1\":{\"740\":1}}],[\"多路查找树的每一个结点的孩子树可以多于两个\",{\"1\":{\"346\":1}}],[\"多路查找树\",{\"0\":{\"346\":1}}],[\"多人在线聊天室\",{\"1\":{\"738\":1}}],[\"多个连接器\",{\"1\":{\"1561\":1}}],[\"多个线程就会操作同一个中间结果容器\",{\"1\":{\"1494\":1}}],[\"多个线程同时读写同一共享变量存在并发问题\",{\"1\":{\"1403\":1}}],[\"多个线程同时读一个资源没有任何问题\",{\"1\":{\"1375\":1}}],[\"多个线程可以同时执行\",{\"1\":{\"1367\":1}}],[\"多个线程在临界区内执行\",{\"1\":{\"1359\":1}}],[\"多个线程读共享其实也没有问题\",{\"1\":{\"1359\":1}}],[\"多个线程操作的话\",{\"1\":{\"720\":1}}],[\"多个field字段\",{\"1\":{\"710\":1}}],[\"多个成员坐标\",{\"1\":{\"713\":1}}],[\"多个成员\",{\"1\":{\"709\":2,\"711\":1}}],[\"多集合操作中若只有一个参数默认和自身进行运算\",{\"1\":{\"709\":1}}],[\"多种内部编码实现可以在不同场景下发挥各自的优势\",{\"1\":{\"706\":1}}],[\"多样的数据类型\",{\"1\":{\"703\":1}}],[\"多用在排序操作上\",{\"1\":{\"694\":1}}],[\"多表连接查询的成本分析首先要考虑多表连接时可能产生多少种连接顺序\",{\"1\":{\"693\":1}}],[\"多表连接的成本分析\",{\"0\":{\"693\":1}}],[\"多表关联时返回全部列\",{\"0\":{\"521\":1}}],[\"多次查询s1表总共的成本\",{\"1\":{\"692\":1}}],[\"多次查询被驱动表的成本\",{\"1\":{\"691\":1}}],[\"多一次交互\",{\"1\":{\"572\":1}}],[\"多叉树就是每个节点有多个儿子\",{\"1\":{\"471\":1}}],[\"多大数据量需要进行分库分表\",{\"0\":{\"166\":1}}],[\"多态\",{\"0\":{\"16\":1}}],[\"幻读会带来一些问题\",{\"1\":{\"584\":1}}],[\"幻读的问题\",{\"0\":{\"584\":1}}],[\"幻读专指\",{\"1\":{\"583\":1}}],[\"幻读在\",{\"1\":{\"583\":1}}],[\"幻读指的是一个事务在前后两次查询同一个范围的时候\",{\"1\":{\"583\":1}}],[\"幻读\",{\"0\":{\"157\":1,\"583\":1},\"1\":{\"570\":1,\"583\":1,\"669\":3}}],[\"谈一下redis事务的了解\",{\"0\":{\"150\":1}}],[\"谈谈你对微服务的理解\",{\"0\":{\"231\":1}}],[\"谈谈你对aqs的理解\",{\"0\":{\"76\":1}}],[\"谈谈你了解的jvm参数\",{\"0\":{\"129\":1}}],[\"子容器中找不到\",{\"1\":{\"1538\":1}}],[\"子类中有的属性设置会父类的属性\",{\"1\":{\"1524\":1}}],[\"子部分固定大小的\",{\"1\":{\"1497\":1}}],[\"子进程的时候\",{\"1\":{\"1404\":1}}],[\"子进程的时候要复制父进程整个进程的地址空间\",{\"1\":{\"1404\":1}}],[\"子进程会全部复制父进程的数据吗\",{\"0\":{\"143\":1}}],[\"子查询等的复杂查询\",{\"1\":{\"467\":1}}],[\"子问题f\",{\"1\":{\"431\":1}}],[\"子树中\",{\"1\":{\"398\":1}}],[\"子节点\",{\"1\":{\"302\":1}}],[\"子线程中如何获取父线程的\",{\"0\":{\"90\":1}}],[\"先找父亲加载\",{\"1\":{\"1540\":1}}],[\"先执行bean的销毁方法\",{\"1\":{\"1528\":1}}],[\"先执行完的先进入阻塞队列\",{\"1\":{\"1394\":1}}],[\"先合并父的beandefinition\",{\"1\":{\"1524\":1}}],[\"先使用cglib生成代理类\",{\"1\":{\"1507\":1}}],[\"先根据类型进行依赖查找\",{\"1\":{\"1507\":1}}],[\"先根据expire\",{\"1\":{\"686\":1}}],[\"先从直观的角度来感受函数式编程带来的好处\",{\"1\":{\"1470\":1}}],[\"先是执行newtable\",{\"1\":{\"1428\":1}}],[\"先是通过b+树从树根开始\",{\"1\":{\"479\":1}}],[\"先进行自旋等待\",{\"1\":{\"1397\":1}}],[\"先后出现过三种不同的管程模型\",{\"1\":{\"1360\":1}}],[\"先到先服务\",{\"1\":{\"741\":1}}],[\"先看jedis\",{\"1\":{\"720\":1}}],[\"先算哪个都可以\",{\"1\":{\"686\":1}}],[\"先通过执行change\",{\"1\":{\"622\":1}}],[\"先用\",{\"1\":{\"622\":1}}],[\"先判断表里面是否已经存在这个id\",{\"1\":{\"628\":1}}],[\"先判断从库是否同步完成的方法\",{\"1\":{\"609\":1}}],[\"先判断seconds\",{\"1\":{\"609\":1}}],[\"先判断server\",{\"1\":{\"592\":1}}],[\"先记录一行set\",{\"1\":{\"605\":1}}],[\"先把这个gtid加到临时实例的gtid集合\",{\"1\":{\"622\":1}}],[\"先把结果存起来\",{\"1\":{\"619\":1}}],[\"先把binlog从binlog\",{\"1\":{\"588\":1}}],[\"先把日志写到binlog\",{\"1\":{\"587\":1}}],[\"先放弃\",{\"1\":{\"578\":1}}],[\"先取前三行\",{\"1\":{\"558\":1}}],[\"先遍历链表\",{\"1\":{\"549\":1}}],[\"先设置\",{\"1\":{\"542\":1}}],[\"先插入两条数据\",{\"1\":{\"482\":1}}],[\"先写binlog后写redo\",{\"1\":{\"464\":1}}],[\"先写redo\",{\"1\":{\"464\":1}}],[\"先写日志\",{\"1\":{\"461\":1}}],[\"先写数据库\",{\"0\":{\"140\":1}}],[\"先枚举子串长度\",{\"1\":{\"428\":1}}],[\"先入先出\",{\"1\":{\"334\":1}}],[\"先入后出\",{\"1\":{\"333\":1}}],[\"先将整个待排序的记录序列分割成为若干子序列分别进行插入排序\",{\"1\":{\"320\":1}}],[\"先删缓存\",{\"0\":{\"139\":1}}],[\"guaranteed\",{\"1\":{\"1500\":1}}],[\"guarantee\",{\"1\":{\"1499\":1}}],[\"guarantees\",{\"1\":{\"1497\":2}}],[\"guard\",{\"1\":{\"1408\":1}}],[\"guarded\",{\"0\":{\"1407\":1},\"1\":{\"1407\":2}}],[\"g=g\",{\"1\":{\"1494\":4}}],[\"github\",{\"1\":{\"1859\":2,\"1864\":1}}],[\"git\",{\"0\":{\"1859\":1},\"1\":{\"1859\":8}}],[\"give\",{\"1\":{\"1524\":2}}],[\"given\",{\"1\":{\"1472\":2,\"1474\":1,\"1475\":2,\"1476\":2,\"1492\":1,\"1495\":2,\"1497\":4,\"1499\":1,\"1500\":2}}],[\"gid方案\",{\"0\":{\"611\":1}}],[\"gc过程\",{\"0\":{\"1626\":1}}],[\"gc进行类型卸载\",{\"1\":{\"1541\":1}}],[\"gc初始阈值\",{\"1\":{\"1541\":1}}],[\"gc\",{\"0\":{\"1629\":1,\"1630\":1},\"1\":{\"1404\":1,\"1541\":2}}],[\"gc标记\",{\"1\":{\"1361\":1}}],[\"gc分代年龄\",{\"1\":{\"1361\":1}}],[\"goals\",{\"1\":{\"1496\":1}}],[\"gof\",{\"0\":{\"1014\":1}}],[\"gof23\",{\"0\":{\"901\":1}}],[\"google\",{\"0\":{\"826\":1}}],[\"gyc\",{\"1\":{\"710\":6}}],[\"gtids=own\",{\"1\":{\"611\":1}}],[\"gtid1\",{\"1\":{\"611\":1}}],[\"gtid分配给接下来要执行\",{\"1\":{\"605\":1}}],[\"gtid没有存在于实例的gtid集合中\",{\"1\":{\"605\":1}}],[\"gtid已经存在于实例的gtid集合中\",{\"1\":{\"605\":1}}],[\"gtid模式的启动需要在启动mysql实例的时候\",{\"1\":{\"605\":1}}],[\"gtid=source\",{\"1\":{\"605\":1}}],[\"gtid的全称是global\",{\"1\":{\"605\":1}}],[\"gtid\",{\"0\":{\"605\":1},\"1\":{\"591\":1,\"605\":10,\"609\":2,\"611\":4,\"622\":1}}],[\"garbage\",{\"0\":{\"1617\":1}}],[\"gained\",{\"1\":{\"1497\":1}}],[\"gather\",{\"0\":{\"1460\":1},\"1\":{\"1460\":3,\"1462\":1}}],[\"gateway有哪些功能\",{\"0\":{\"249\":1}}],[\"gap的一种特例\",{\"1\":{\"579\":1}}],[\"gap\",{\"1\":{\"579\":2,\"585\":1}}],[\"globaladvisoradapterregistry\",{\"1\":{\"1531\":1}}],[\"global\",{\"0\":{\"1631\":1},\"1\":{\"565\":4,\"575\":1,\"604\":1,\"613\":1,\"618\":1,\"633\":1,\"640\":1,\"663\":2}}],[\"gg\",{\"1\":{\"473\":1}}],[\"greater\",{\"1\":{\"1478\":2,\"1497\":1}}],[\"grep\",{\"1\":{\"566\":1}}],[\"grow\",{\"1\":{\"1352\":1}}],[\"grouping\",{\"1\":{\"1490\":1,\"1495\":1}}],[\"groupingby方法返回的collector不是并发的\",{\"1\":{\"1495\":1}}],[\"groupingby方法返回了完成对于给定t类型的层叠的分组操作的collector\",{\"1\":{\"1495\":1}}],[\"groupingbyconcurrent\",{\"1\":{\"1495\":3}}],[\"groupingby和partitioningby是整个collectors类中比较难以理解的两部分\",{\"1\":{\"1495\":1}}],[\"groupingby\",{\"1\":{\"1490\":6,\"1492\":3,\"1493\":5,\"1495\":7}}],[\"groupid>\",{\"1\":{\"719\":2,\"720\":1}}],[\"groupanagrams\",{\"1\":{\"380\":1}}],[\"group\",{\"0\":{\"552\":1,\"553\":1},\"1\":{\"356\":1,\"495\":1,\"515\":4,\"527\":1,\"553\":3,\"554\":3,\"555\":2,\"568\":5,\"588\":9,\"601\":1,\"602\":2,\"656\":3,\"1490\":3,\"1493\":1,\"1495\":1}}],[\"grpc\",{\"0\":{\"842\":1}}],[\"grpc服务只会按照grpc的格式来解析字节流\",{\"1\":{\"798\":1}}],[\"grid\",{\"1\":{\"435\":38}}],[\"g\",{\"1\":{\"422\":4,\"466\":1,\"467\":5,\"491\":1,\"498\":1,\"527\":2,\"558\":1,\"566\":2,\"675\":1,\"714\":1,\"1494\":8,\"1498\":1}}],[\"ghi\",{\"1\":{\"400\":1}}],[\"geocoder\",{\"1\":{\"1394\":1}}],[\"georadius\",{\"1\":{\"713\":2}}],[\"georadiusbymember\",{\"1\":{\"713\":1}}],[\"geohash\",{\"1\":{\"713\":3}}],[\"geodist\",{\"1\":{\"713\":1}}],[\"geopos\",{\"1\":{\"713\":1}}],[\"geoadd\",{\"1\":{\"713\":1}}],[\"geospatial\",{\"0\":{\"713\":1}}],[\"generally\",{\"1\":{\"1496\":1,\"1497\":1,\"1498\":1}}],[\"generalization\",{\"1\":{\"1495\":1}}],[\"generating\",{\"1\":{\"1496\":1}}],[\"generator\",{\"1\":{\"1496\":1,\"1497\":1}}],[\"generatebeanname\",{\"1\":{\"1524\":1}}],[\"generateboard\",{\"1\":{\"417\":2}}],[\"generate\",{\"1\":{\"1471\":2,\"1486\":1}}],[\"generated\",{\"1\":{\"550\":3,\"554\":1,\"656\":2}}],[\"generateparenthesis\",{\"1\":{\"415\":1}}],[\"generatematrix\",{\"1\":{\"364\":1}}],[\"genericapplicationcontext\",{\"1\":{\"1528\":1}}],[\"genericbeandefinition\",{\"1\":{\"1509\":2}}],[\"genericconverter接口\",{\"0\":{\"1250\":1}}],[\"generic\",{\"1\":{\"562\":1}}],[\"getdeclaringclass\",{\"1\":{\"1531\":1}}],[\"getdependencytype\",{\"1\":{\"1525\":5}}],[\"getdependencycheck\",{\"1\":{\"1524\":1}}],[\"getdependentbeans\",{\"1\":{\"1524\":1}}],[\"getdependson\",{\"1\":{\"1524\":1}}],[\"getdepartment\",{\"1\":{\"1492\":1,\"1493\":2}}],[\"getdisplayname\",{\"1\":{\"1528\":1}}],[\"getid\",{\"1\":{\"1528\":1}}],[\"getinstance\",{\"1\":{\"1531\":1}}],[\"getinstancesupplier\",{\"1\":{\"1527\":1}}],[\"getinterceptors\",{\"1\":{\"1531\":3}}],[\"getinterceptorsanddynamicinterceptionadvice\",{\"1\":{\"1531\":2}}],[\"getintersectionnode\",{\"1\":{\"376\":1}}],[\"getinputstream\",{\"1\":{\"1450\":2}}],[\"getfindclasses\",{\"1\":{\"1540\":1}}],[\"getfindclasstime\",{\"1\":{\"1540\":1}}],[\"getfield\",{\"1\":{\"1525\":2}}],[\"getfactorymethodname\",{\"1\":{\"1527\":1}}],[\"getearlybeanreference\",{\"1\":{\"1524\":1,\"1526\":1}}],[\"getexactsizeifknown\",{\"1\":{\"1497\":1,\"1500\":1}}],[\"getwrappedclass\",{\"1\":{\"1524\":1}}],[\"getwrappedinstance\",{\"1\":{\"1524\":4}}],[\"getweight\",{\"1\":{\"1496\":3}}],[\"gettransactionstatus\",{\"1\":{\"1532\":1}}],[\"gettransactionattribute\",{\"1\":{\"1532\":1}}],[\"gettransactionattributesource\",{\"1\":{\"1532\":1}}],[\"gettarget\",{\"1\":{\"1532\":1}}],[\"gettypedescriptor\",{\"1\":{\"1525\":1}}],[\"gettypeconverter\",{\"1\":{\"1525\":2}}],[\"gettype\",{\"1\":{\"1516\":2,\"1525\":3}}],[\"getter方法\",{\"1\":{\"1490\":1}}],[\"getlazyresolutionproxyifnecessary\",{\"1\":{\"1525\":1}}],[\"getlastname\",{\"1\":{\"1495\":2}}],[\"getlength\",{\"1\":{\"806\":1}}],[\"getgrade\",{\"1\":{\"1493\":1}}],[\"getname\",{\"1\":{\"1477\":4,\"1480\":3,\"1481\":3,\"1482\":6,\"1488\":2,\"1490\":5,\"1493\":7,\"1494\":2,\"1524\":1,\"1527\":1,\"1529\":4,\"1531\":2,\"1532\":1}}],[\"getnodename\",{\"1\":{\"806\":1}}],[\"getnodetype\",{\"1\":{\"806\":3}}],[\"getnode\",{\"1\":{\"302\":4,\"806\":5}}],[\"getarguments\",{\"1\":{\"1532\":1}}],[\"getadapter\",{\"1\":{\"1532\":1}}],[\"getadvisors\",{\"1\":{\"1531\":1}}],[\"getaddress\",{\"1\":{\"1488\":2}}],[\"getautowirecandidateresolver\",{\"1\":{\"1525\":3}}],[\"getaccesscontrolcontext\",{\"1\":{\"1524\":2}}],[\"getapplicationstartup\",{\"1\":{\"1524\":2,\"1528\":1}}],[\"getannotation\",{\"1\":{\"1531\":1}}],[\"getannotationtypes\",{\"1\":{\"1523\":1}}],[\"getannotationmetadata\",{\"1\":{\"1523\":1}}],[\"getanddecrement\",{\"1\":{\"1380\":1}}],[\"getandincrement\",{\"1\":{\"1380\":1}}],[\"getage\",{\"1\":{\"1475\":1,\"1477\":1,\"1488\":2,\"1490\":1}}],[\"getusername\",{\"1\":{\"1475\":1}}],[\"getpoolsize\",{\"1\":{\"1567\":3}}],[\"getpointcut\",{\"1\":{\"1531\":2}}],[\"getparametertype\",{\"1\":{\"1532\":1}}],[\"getparameternamediscoverer\",{\"1\":{\"1525\":1}}],[\"getparametercount\",{\"1\":{\"1525\":1}}],[\"getparentdelegationtime\",{\"1\":{\"1540\":1}}],[\"getparentbeanfactory\",{\"1\":{\"1524\":2,\"1525\":1}}],[\"getparentname\",{\"1\":{\"1524\":3}}],[\"getpersonbyusername\",{\"1\":{\"1475\":1}}],[\"getpersonbyage\",{\"1\":{\"1475\":2}}],[\"getpreferredconstructors\",{\"1\":{\"1527\":1}}],[\"getprenode\",{\"1\":{\"302\":2}}],[\"getproxy\",{\"1\":{\"1531\":1}}],[\"getpropertyvalues\",{\"1\":{\"1524\":2}}],[\"getprobe\",{\"1\":{\"1357\":1,\"1431\":1}}],[\"getpricebys3\",{\"1\":{\"1394\":1}}],[\"getpricebys2\",{\"1\":{\"1394\":1}}],[\"getpricebys1\",{\"1\":{\"1394\":1}}],[\"getmostspecificmethod\",{\"1\":{\"1525\":1}}],[\"getmodifiers\",{\"1\":{\"1525\":2,\"1527\":1}}],[\"getmethodmatcher\",{\"1\":{\"1531\":1}}],[\"getmethodparameter\",{\"1\":{\"1525\":1}}],[\"getmetadata\",{\"1\":{\"1524\":1}}],[\"getmetadatareaderfactory\",{\"1\":{\"1524\":3}}],[\"getmetadatareader\",{\"1\":{\"1523\":1,\"1524\":1}}],[\"getmergedbeandefinition\",{\"1\":{\"1524\":3,\"1525\":1}}],[\"getmergedlocalbeandefinition\",{\"1\":{\"1524\":2,\"1525\":1}}],[\"getmessage\",{\"1\":{\"1464\":1,\"1465\":1,\"1524\":1}}],[\"getmaximumpoolsize\",{\"1\":{\"1567\":2}}],[\"getmax\",{\"1\":{\"1487\":1}}],[\"getmin\",{\"1\":{\"392\":1,\"1487\":1}}],[\"getoutputshape\",{\"1\":{\"1499\":1,\"1500\":1}}],[\"getoutputstream\",{\"1\":{\"1450\":2}}],[\"getopflags\",{\"1\":{\"1494\":1,\"1500\":3}}],[\"getobjectforbeaninstance\",{\"1\":{\"1524\":4}}],[\"getobject方法返回的对象\",{\"1\":{\"1524\":1}}],[\"getobject方法\",{\"1\":{\"1524\":1}}],[\"getobjecttype\",{\"1\":{\"1521\":1}}],[\"getobjectvolatile\",{\"1\":{\"1431\":1}}],[\"getobject\",{\"1\":{\"1430\":1,\"1521\":1}}],[\"getordefault\",{\"1\":{\"311\":1,\"381\":1,\"387\":2}}],[\"get等\",{\"1\":{\"1415\":1}}],[\"getreturntype\",{\"1\":{\"1532\":2}}],[\"getresolvabletype\",{\"1\":{\"1525\":3}}],[\"getresolvedautowiremode\",{\"1\":{\"1524\":1,\"1527\":1}}],[\"getresourcedescription\",{\"1\":{\"1524\":10,\"1527\":1}}],[\"getresources\",{\"1\":{\"1524\":1}}],[\"getresourcepatternresolver\",{\"1\":{\"1524\":1}}],[\"getringbuffer\",{\"1\":{\"1398\":1}}],[\"getruntime\",{\"1\":{\"1357\":1,\"1450\":1}}],[\"getrange\",{\"1\":{\"707\":2}}],[\"getbeanpostprocessorcache\",{\"1\":{\"1524\":2}}],[\"getbeannamesfortype\",{\"1\":{\"1524\":1}}],[\"getbeanname\",{\"1\":{\"1524\":1}}],[\"getbeanclassname\",{\"1\":{\"1524\":1}}],[\"getbean会首先创建所依赖的bean\",{\"1\":{\"1524\":1}}],[\"getbean\",{\"1\":{\"1509\":1,\"1510\":1,\"1511\":1,\"1512\":1,\"1524\":8}}],[\"getbeandefinition\",{\"1\":{\"1509\":1}}],[\"getbean操作是否线程安全\",{\"0\":{\"1110\":1}}],[\"getbytes\",{\"1\":{\"1451\":2,\"1452\":2}}],[\"getbit\",{\"1\":{\"715\":5}}],[\"getsubmittedcount\",{\"1\":{\"1567\":1}}],[\"getsuggestedvalue\",{\"1\":{\"1525\":1}}],[\"getsuperclass\",{\"1\":{\"1525\":1}}],[\"getsum\",{\"1\":{\"1487\":1}}],[\"getsingleton\",{\"1\":{\"1524\":4}}],[\"getservletfilters\",{\"1\":{\"1535\":1}}],[\"getservletmappings\",{\"1\":{\"1535\":1}}],[\"getservletapplicationcontextinitializers\",{\"1\":{\"1535\":1}}],[\"getservletname\",{\"1\":{\"1535\":2}}],[\"getsecuritymanager\",{\"1\":{\"1524\":2}}],[\"getset\",{\"1\":{\"707\":3}}],[\"getscope\",{\"1\":{\"1524\":3}}],[\"getscopename\",{\"1\":{\"1524\":1}}],[\"getscore\",{\"1\":{\"1480\":4,\"1481\":4,\"1482\":3,\"1490\":5,\"1493\":10}}],[\"getsalary\",{\"1\":{\"1492\":1,\"1493\":2}}],[\"getshort\",{\"1\":{\"1478\":3}}],[\"gets\",{\"1\":{\"1477\":1,\"1499\":1}}],[\"getstreamandopflags\",{\"1\":{\"1500\":1}}],[\"getstring2\",{\"1\":{\"1483\":2}}],[\"getstring\",{\"1\":{\"1483\":2}}],[\"getstringbody\",{\"1\":{\"806\":1}}],[\"getstate\",{\"1\":{\"1367\":1}}],[\"getstatic\",{\"1\":{\"1359\":2}}],[\"getcause\",{\"1\":{\"1532\":1}}],[\"getclassloadinglock\",{\"1\":{\"1540\":1}}],[\"getclassloader\",{\"1\":{\"1531\":1}}],[\"getclassfilter\",{\"1\":{\"1531\":2}}],[\"getclassname\",{\"1\":{\"1523\":1}}],[\"getclassmetadata\",{\"1\":{\"1523\":1}}],[\"getclass\",{\"1\":{\"1497\":2,\"1500\":1,\"1524\":1,\"1525\":3}}],[\"getcontinuation\",{\"1\":{\"1532\":1}}],[\"getconstructorargumentvalues\",{\"1\":{\"1527\":1}}],[\"getconvertibletypes\",{\"1\":{\"1516\":1}}],[\"getconnection\",{\"1\":{\"720\":1}}],[\"getconnectionfactory\",{\"1\":{\"720\":1}}],[\"getcomparator\",{\"1\":{\"1497\":1}}],[\"getcommonpoolparallelism\",{\"1\":{\"1497\":1}}],[\"getcolor\",{\"1\":{\"1496\":1}}],[\"getcity\",{\"1\":{\"1495\":2}}],[\"getchildnodes\",{\"1\":{\"806\":1}}],[\"get直接略过\",{\"1\":{\"707\":1}}],[\"getkey\",{\"1\":{\"381\":1,\"1423\":1,\"1525\":2}}],[\"getvalue\",{\"1\":{\"381\":1,\"1423\":1,\"1525\":2}}],[\"get\",{\"0\":{\"0\":1},\"1\":{\"311\":1,\"359\":1,\"380\":1,\"386\":1,\"387\":1,\"400\":1,\"426\":8,\"611\":1,\"704\":2,\"706\":1,\"707\":5,\"708\":1,\"716\":2,\"717\":3,\"718\":2,\"719\":2,\"720\":1,\"748\":1,\"806\":1,\"1353\":3,\"1356\":3,\"1380\":2,\"1394\":5,\"1405\":3,\"1428\":1,\"1451\":2,\"1452\":2,\"1464\":2,\"1465\":2,\"1470\":1,\"1477\":6,\"1483\":1,\"1485\":3,\"1488\":1,\"1492\":6,\"1493\":1,\"1494\":2,\"1495\":4,\"1499\":1,\"1500\":1,\"1524\":4,\"1525\":1}}],[\"g1特点\",{\"0\":{\"1632\":1}}],[\"g1简介\",{\"0\":{\"1618\":1}}],[\"g1有什么优缺点\",{\"0\":{\"123\":1}}],[\"g1垃圾收集器的步骤\",{\"0\":{\"123\":1}}],[\"再做个系统性的项目把技术融合起来\",{\"1\":{\"1871\":1}}],[\"再深入学习个技术点就可以了\",{\"1\":{\"1866\":1}}],[\"再也不用满世界搜索下载\",{\"1\":{\"1858\":1}}],[\"再以串行的方式去执行\",{\"1\":{\"1497\":1}}],[\"再以这个接口为例\",{\"1\":{\"1471\":1}}],[\"再调用其他方法\",{\"1\":{\"1488\":1}}],[\"再调用第二个filter方法\",{\"1\":{\"1488\":1}}],[\"再调用引擎接口写入这行新数据\",{\"1\":{\"463\":1}}],[\"再取出流中的前两个元素\",{\"1\":{\"1487\":1}}],[\"再举这样一个例子来加深对于flatmap理解的场景\",{\"1\":{\"1486\":1}}],[\"再举一个例子\",{\"1\":{\"1484\":1}}],[\"再来看一个例子\",{\"1\":{\"1487\":1}}],[\"再来看一个map和flatmap例子\",{\"1\":{\"1486\":1}}],[\"再来看一些具体的例子\",{\"1\":{\"1476\":1}}],[\"再回到集合遍历的例子当中\",{\"1\":{\"1482\":1}}],[\"再回到主键索引上取值再判断\",{\"1\":{\"484\":1}}],[\"再jdk中有这样一个函数式接口bifunction\",{\"1\":{\"1475\":1}}],[\"再比如使用stringbuilder将字符串拼接起来\",{\"1\":{\"1492\":1}}],[\"再比如\",{\"1\":{\"1471\":2,\"1486\":1}}],[\"再比如我们经常会用到的创建线程的例子\",{\"1\":{\"1468\":1}}],[\"再比较position\",{\"1\":{\"642\":1}}],[\"再比较age\",{\"1\":{\"642\":1}}],[\"再获取读锁最后释放写锁的次序\",{\"1\":{\"1375\":1}}],[\"再将偏向锁撤销为无锁状态或升级为轻量级锁\",{\"1\":{\"1362\":1}}],[\"再将描述符放进去\",{\"1\":{\"742\":1}}],[\"再在数据库中进行查找\",{\"1\":{\"763\":1}}],[\"再分析使用普通索引的成本\",{\"1\":{\"686\":1}}],[\"再放入t2表剩余200行记录\",{\"1\":{\"662\":1}}],[\"再放回备库中\",{\"1\":{\"622\":1}}],[\"再申请时它的值就不会改变\",{\"1\":{\"636\":1}}],[\"再申请下一个id时\",{\"1\":{\"631\":1}}],[\"再启动一个事务\",{\"1\":{\"633\":1}}],[\"再插入数据时报主键冲突错误\",{\"1\":{\"632\":1}}],[\"再插入新的数据行是\",{\"1\":{\"628\":1}}],[\"再试图执行插入语句\",{\"1\":{\"631\":1}}],[\"再接入整个集群\",{\"1\":{\"625\":1}}],[\"再进入终止逻辑阶段\",{\"1\":{\"618\":1}}],[\"再次运行\",{\"1\":{\"1494\":1}}],[\"再次启动后作为主机是无法获取之前主机的数据的\",{\"1\":{\"748\":1}}],[\"再次从t1表里取数据跟join\",{\"1\":{\"662\":1}}],[\"再次出现这个异常\",{\"1\":{\"616\":1}}],[\"再次执行sql的执行计划\",{\"1\":{\"500\":1}}],[\"再通过dma拷贝到nic\",{\"1\":{\"1453\":1}}],[\"再通过之前介绍的方法\",{\"1\":{\"623\":1}}],[\"再通过下面的这条语句\",{\"1\":{\"616\":1}}],[\"再通过其它的可能分布解答再次尝试寻找问题的答案\",{\"1\":{\"290\":1}}],[\"再传给备库\",{\"1\":{\"594\":1}}],[\"再传回给节点a\",{\"1\":{\"592\":1}}],[\"再把binlog\",{\"1\":{\"587\":1}}],[\"再观察执行效果\",{\"1\":{\"584\":1}}],[\"再请求的话\",{\"1\":{\"578\":1}}],[\"再加上248\",{\"1\":{\"634\":1}}],[\"再加上应用binlog的方式\",{\"1\":{\"622\":1}}],[\"再加上崩溃恢复这个逻辑\",{\"1\":{\"588\":1}}],[\"再加上binlog来恢复的\",{\"1\":{\"588\":1}}],[\"再加上\",{\"1\":{\"559\":1}}],[\"再用limit\",{\"1\":{\"559\":1}}],[\"再用其乘以在具体硬件下一次i\",{\"1\":{\"525\":1}}],[\"再去通过自己的各种方式来完成本次转账\",{\"1\":{\"1378\":1}}],[\"再去数据库里面执行\",{\"1\":{\"591\":1}}],[\"再去主键索引查数据\",{\"1\":{\"541\":1}}],[\"再去order\",{\"1\":{\"515\":1}}],[\"再根据名称进行过滤\",{\"1\":{\"1525\":1}}],[\"再根据字段m做排序\",{\"1\":{\"553\":1}}],[\"再根据一个个主键id的值到主键索引上去查整行数据的过程\",{\"1\":{\"541\":1}}],[\"再根据id值关联到test1\",{\"1\":{\"651\":1}}],[\"再根据id值关联到t1\",{\"1\":{\"458\":1}}],[\"再根据id值关联到表test2\",{\"1\":{\"651\":1}}],[\"再根据id值关联到表t2\",{\"1\":{\"458\":1}}],[\"再执行insert\",{\"1\":{\"629\":1}}],[\"再执行show\",{\"1\":{\"627\":1}}],[\"再执行三个limit\",{\"1\":{\"559\":1}}],[\"再执行\",{\"1\":{\"540\":1}}],[\"再搜索主键索引\",{\"1\":{\"538\":1}}],[\"再例如\",{\"1\":{\"531\":1}}],[\"再对map做索引位置为3的get操作\",{\"1\":{\"1428\":1}}],[\"再对比age和position这两个字段的值是否符合\",{\"1\":{\"655\":1}}],[\"再对比字段值\",{\"1\":{\"477\":1}}],[\"再对全体记录进行依次直接插入排序\",{\"1\":{\"320\":1}}],[\"再到被驱动表t2去做join\",{\"1\":{\"542\":1}}],[\"再到id索引上取整行然后判断\",{\"1\":{\"487\":1}}],[\"再到id索引树查到id=300对应的r3\",{\"1\":{\"474\":1}}],[\"再到id索引树搜索一次\",{\"1\":{\"472\":1}}],[\"再到主键索引上去查出每一行\",{\"1\":{\"484\":1}}],[\"再到gc清除\",{\"0\":{\"110\":1}}],[\"再写磁盘\",{\"1\":{\"461\":1}}],[\"再写数据库\",{\"0\":{\"139\":1}}],[\"再判断其它条件\",{\"1\":{\"544\":1}}],[\"再判断test1里面name的值是否等于jyc\",{\"1\":{\"651\":1}}],[\"再判断test2里面的name的值是否等于jyc\",{\"1\":{\"651\":1}}],[\"再判断t1里面c的值是否等于10\",{\"1\":{\"458\":1}}],[\"再判断t2里面d的值是否等于20\",{\"1\":{\"458\":1}}],[\"再判断元素是否等于\",{\"1\":{\"435\":1}}],[\"再散列函数法\",{\"1\":{\"332\":1}}],[\"再删缓存\",{\"0\":{\"140\":1}}],[\"再转红黑树\",{\"0\":{\"37\":1}}],[\"创建dispatcherservlet\",{\"1\":{\"1535\":1}}],[\"创建disruptor\",{\"1\":{\"1398\":1}}],[\"创建servlet容器\",{\"1\":{\"1535\":1}}],[\"创建数据库连接conn\",{\"1\":{\"1532\":1}}],[\"创建数组\",{\"1\":{\"1431\":1}}],[\"创建代理对象的核心方法\",{\"1\":{\"1531\":1}}],[\"创建读取器\",{\"1\":{\"1528\":1}}],[\"创建beanfactory的实例对象\",{\"1\":{\"1528\":1}}],[\"创建beanfactory实例对象\",{\"1\":{\"1528\":1}}],[\"创建bean的方法\",{\"1\":{\"1524\":1}}],[\"创建bean\",{\"1\":{\"1524\":1}}],[\"创建实现factorybean的实例对象\",{\"1\":{\"1524\":1}}],[\"创建非懒加载的单例bean\",{\"1\":{\"1524\":1}}],[\"创建流元的过程是由streamsupport这个类来完成的\",{\"1\":{\"1498\":1}}],[\"创建出来的分割迭代器具有\",{\"1\":{\"1497\":1}}],[\"创建出来的分割迭代器继承了集合迭代器的快速失败\",{\"1\":{\"1497\":1}}],[\"创建的就是并行流\",{\"1\":{\"1496\":1}}],[\"创建的就是串行流\",{\"1\":{\"1496\":1}}],[\"创建线程时需要用到的runnable接口\",{\"1\":{\"1471\":1}}],[\"创建线程池\",{\"1\":{\"1394\":3}}],[\"创建100000个花费的总毫秒值\",{\"1\":{\"1468\":1}}],[\"创建成本很高\",{\"1\":{\"1410\":1}}],[\"创建生产者\",{\"1\":{\"1398\":1}}],[\"创建ringbuffer容器\",{\"1\":{\"1398\":1}}],[\"创建事件\",{\"1\":{\"1397\":1}}],[\"创建completionservice\",{\"1\":{\"1394\":2}}],[\"创建型模式\",{\"0\":{\"994\":1}}],[\"创建基于内存的临时表写入或者读取一条记录的成本\",{\"1\":{\"694\":1}}],[\"创建基于磁盘的临时表的成本\",{\"1\":{\"694\":1}}],[\"创建临时表和对这个临时表进行写入和读取的操作代价还是很高的\",{\"1\":{\"694\":1}}],[\"创建临时表\",{\"1\":{\"568\":1}}],[\"创建临时表的语句会自动在备库执行\",{\"1\":{\"550\":1}}],[\"创建内存临时表\",{\"1\":{\"553\":1}}],[\"创建第二表的过程中就会发现table\",{\"1\":{\"549\":1}}],[\"创建复合索引\",{\"1\":{\"515\":1}}],[\"创建表t1和t2\",{\"1\":{\"541\":1}}],[\"创建表\",{\"1\":{\"515\":1}}],[\"创建索引\",{\"1\":{\"498\":1,\"499\":2}}],[\"创建索引idx\",{\"1\":{\"498\":1,\"499\":2}}],[\"创建idx\",{\"1\":{\"498\":1}}],[\"创建符合索引idx\",{\"1\":{\"498\":1}}],[\"创建好索引之后\",{\"1\":{\"473\":1}}],[\"创建m+1行n+1列的二维数组dp\",{\"1\":{\"427\":1}}],[\"创建虚拟的头节点和快慢指针是链表常见的解题思路\",{\"1\":{\"378\":1}}],[\"创建一个数据库连接\",{\"1\":{\"1507\":1}}],[\"创建一个针对于这个集合的元素分割迭代器\",{\"1\":{\"1497\":1}}],[\"创建一个临时表\",{\"1\":{\"557\":1}}],[\"创建一个内存临时表\",{\"1\":{\"551\":1}}],[\"创建一个3行4列的数组\",{\"1\":{\"329\":1}}],[\"创建一个对象的过程\",{\"0\":{\"103\":1}}],[\"创建对象有哪些方式\",{\"0\":{\"28\":1}}],[\"分派\",{\"0\":{\"1685\":1}}],[\"分代收集理论\",{\"0\":{\"1597\":1}}],[\"分开一半的范围\",{\"1\":{\"1497\":1}}],[\"分割\",{\"1\":{\"1498\":1}}],[\"分割迭代器无疑是函数式编程中一个相当核心的概念\",{\"1\":{\"1498\":1}}],[\"分割迭代器并不被要求是线程安全的\",{\"1\":{\"1497\":1}}],[\"分割之前和分割之后有可能特性值会不同\",{\"1\":{\"1497\":1}}],[\"分割左侧的\",{\"1\":{\"1497\":1}}],[\"分割以及遍历的行为是不确定的\",{\"1\":{\"1497\":1}}],[\"分割子问题\",{\"1\":{\"288\":1}}],[\"分解\",{\"1\":{\"1387\":1,\"1497\":1}}],[\"分解关联查询\",{\"0\":{\"531\":1}}],[\"分离对象或标量替换\",{\"1\":{\"1365\":1}}],[\"分配内存\",{\"0\":{\"1544\":1}}],[\"分配一个1024字节的缓冲区\",{\"1\":{\"1451\":1}}],[\"分配一个哈希表\",{\"1\":{\"599\":1}}],[\"分配资源的最小单位是进程\",{\"1\":{\"1354\":1}}],[\"分工问题\",{\"1\":{\"1347\":1}}],[\"分层构建镜像\",{\"0\":{\"1046\":1}}],[\"分布式锁\",{\"1\":{\"767\":1}}],[\"分布式事务如何处理\",{\"0\":{\"234\":1}}],[\"分担服务器的负载\",{\"1\":{\"744\":1}}],[\"分数从高到低排序\",{\"1\":{\"711\":1}}],[\"分数从高到底\",{\"1\":{\"711\":1}}],[\"分组和分区还可以互相嵌套\",{\"1\":{\"1493\":1}}],[\"分组\",{\"1\":{\"1490\":1}}],[\"分组查询\",{\"1\":{\"694\":1}}],[\"分组等\",{\"1\":{\"518\":1}}],[\"分页\",{\"1\":{\"711\":1,\"807\":1}}],[\"分页查询优化\",{\"0\":{\"659\":1}}],[\"分页插件的原理是什么\",{\"0\":{\"203\":1}}],[\"分区有序\",{\"0\":{\"1741\":1}}],[\"分区一定是固定的两组结果\",{\"1\":{\"1495\":1}}],[\"分区\",{\"1\":{\"1490\":1}}],[\"分区可以认为是特殊的分组\",{\"1\":{\"1490\":1}}],[\"分区与分组\",{\"0\":{\"1490\":1}}],[\"分区也不要提前预留太多\",{\"1\":{\"563\":1}}],[\"分区并不是越细越好\",{\"1\":{\"563\":1}}],[\"分区策略\",{\"0\":{\"562\":1}}],[\"分区表在使用的时候\",{\"1\":{\"563\":1}}],[\"分区表在做ddl的时候\",{\"1\":{\"562\":1}}],[\"分区表可以很方便的清理历史数据\",{\"1\":{\"563\":1}}],[\"分区表的一个显而易见的优势是对业务透明\",{\"1\":{\"563\":1}}],[\"分区表的应用场景\",{\"0\":{\"563\":1}}],[\"分区表最重要的问题在于\",{\"1\":{\"561\":1}}],[\"分区表和手工分表\",{\"1\":{\"561\":1}}],[\"分区表简介\",{\"0\":{\"561\":1}}],[\"分区表\",{\"0\":{\"560\":1}}],[\"分区key的选择是以\",{\"1\":{\"548\":1}}],[\"分成的段数也就越少\",{\"1\":{\"540\":1}}],[\"分块去join\",{\"1\":{\"540\":1}}],[\"分而治之\",{\"1\":{\"530\":1}}],[\"分析连接器的功能列表\",{\"1\":{\"1565\":1}}],[\"分析hashmap需要注意区别jdk1\",{\"1\":{\"1422\":1}}],[\"分析各个索引使用成本\",{\"1\":{\"656\":1}}],[\"分析步骤\",{\"1\":{\"568\":1}}],[\"分析\",{\"1\":{\"567\":1}}],[\"分析慢sql的步骤\",{\"0\":{\"567\":1}}],[\"分析sql\",{\"1\":{\"566\":1}}],[\"分析查询时\",{\"1\":{\"526\":1}}],[\"分析器\",{\"0\":{\"457\":1},\"1\":{\"454\":1}}],[\"分类器方法会将元素映射成某个k类型\",{\"1\":{\"1495\":1}}],[\"分类\",{\"1\":{\"499\":2,\"500\":1}}],[\"分类id\",{\"1\":{\"498\":1}}],[\"分为有界和无界两种\",{\"1\":{\"1378\":1}}],[\"分为读锁和写锁\",{\"1\":{\"670\":1}}],[\"分为表锁和行锁\",{\"1\":{\"670\":1}}],[\"分为两种方法\",{\"1\":{\"321\":1}}],[\"分为哪几类\",{\"0\":{\"67\":1}}],[\"分治从某种意义上和递归也是等价的\",{\"1\":{\"287\":1}}],[\"分治指的是将一个大问题分解为若干个小问题\",{\"1\":{\"287\":1}}],[\"分治\",{\"0\":{\"286\":1}}],[\"分库分表系统的跨库查询就是一个典型的使用场景\",{\"1\":{\"548\":1}}],[\"分库分表后\",{\"0\":{\"166\":1}}],[\"分库分表的方式和分片策略由哪些\",{\"0\":{\"166\":1}}],[\"分别记为\",{\"1\":{\"1356\":1}}],[\"分别用于操作redis和redis中的string数据类型\",{\"1\":{\"720\":1}}],[\"分别用来表示自增的初始值和步长\",{\"1\":{\"628\":1}}],[\"分别表示relay\",{\"1\":{\"609\":1}}],[\"分别是endpoint\",{\"1\":{\"1565\":1}}],[\"分别是readfds\",{\"1\":{\"1446\":1}}],[\"分别是hasen模型\",{\"1\":{\"1360\":1}}],[\"分别是\",{\"1\":{\"585\":1}}],[\"分别是q1\",{\"1\":{\"583\":1}}],[\"分别存入sort\",{\"1\":{\"557\":1}}],[\"分别对应f\",{\"1\":{\"429\":1}}],[\"分别进行排序\",{\"1\":{\"322\":1}}],[\"分别的特点是什么\",{\"0\":{\"109\":1}}],[\"分别有什么作用\",{\"0\":{\"97\":1,\"212\":1}}],[\"而infrastructureadvisorautoproxycreator继承了abstractadvisorautoproxycreator\",{\"1\":{\"1532\":1}}],[\"而id的值已经在k索引树上了\",{\"1\":{\"475\":1}}],[\"而需要的类型是user\",{\"1\":{\"1515\":1}}],[\"而无论这个阶段接收的类型\",{\"1\":{\"1500\":1}}],[\"而无需线程b再执行\",{\"1\":{\"1408\":1}}],[\"而无需再创建idb文件\",{\"1\":{\"549\":1}}],[\"而数组是引用类型的\",{\"1\":{\"1495\":1}}],[\"而数据表是会持续更新的\",{\"1\":{\"484\":1}}],[\"而尽量不要进行其他的操作\",{\"1\":{\"1494\":1}}],[\"而最终的结果类型是map类型\",{\"1\":{\"1494\":1}}],[\"而作为collector的工厂\",{\"1\":{\"1493\":1}}],[\"而作为银行这个类来讲\",{\"1\":{\"1378\":1}}],[\"而accumulator将流中待处理的元素添加到结果容器之后\",{\"1\":{\"1492\":1}}],[\"而终止操作则不会返回stream类型\",{\"1\":{\"1488\":1}}],[\"而流关注的则是对数据的计算\",{\"1\":{\"1488\":1}}],[\"而具体如何让db完成这个行为是没有暴露出来的\",{\"1\":{\"1488\":1}}],[\"而去重也并没有等待到新的值\",{\"1\":{\"1487\":1}}],[\"而foreach是终止操作\",{\"1\":{\"1487\":1}}],[\"而求和则不会\",{\"1\":{\"1487\":1}}],[\"而jdk在很多的接口中都增加了默认方法\",{\"1\":{\"1484\":1}}],[\"而jdk会在集合进行流操作的时候\",{\"1\":{\"1470\":1}}],[\"而接口更多的时候还是表示一种模板或者契约\",{\"1\":{\"1484\":1}}],[\"而println\",{\"1\":{\"1482\":1}}],[\"而put方法中有这样的逻辑\",{\"1\":{\"1434\":1}}],[\"而方法引用则需要满足一些条件才能使用\",{\"1\":{\"1480\":1}}],[\"而bifunction要求接收两个参数\",{\"1\":{\"1475\":1}}],[\"而事实上java8的新特性可以极大提升我们的开发效率\",{\"1\":{\"1468\":1}}],[\"而事务id从0开始计数\",{\"1\":{\"634\":1}}],[\"而事务b在等待事务a释放id=1的行锁\",{\"1\":{\"581\":1}}],[\"而实际io读写\",{\"1\":{\"1457\":1}}],[\"而用户程序运行在用户空间\",{\"1\":{\"1456\":1}}],[\"而用于同步更新的线程\",{\"1\":{\"590\":1}}],[\"而异步io则无需自己负责进行读写\",{\"1\":{\"1445\":1}}],[\"而另一方面\",{\"1\":{\"1443\":1}}],[\"而另外的128个线程又处于锁等待状态\",{\"1\":{\"613\":1}}],[\"而阻塞io值调用了一次system\",{\"1\":{\"1442\":1}}],[\"而同时\",{\"1\":{\"1442\":1}}],[\"而指针实质上是某个变量或者对象所在内存位置的首地址\",{\"1\":{\"1438\":1}}],[\"而hashset就是利用这个特性来保证唯一性的\",{\"1\":{\"1434\":1}}],[\"而hashentry存放的就是我们的键值对\",{\"1\":{\"1430\":1}}],[\"而hashentry也是concurrenthashmap的内部类\",{\"1\":{\"1430\":1}}],[\"而hashmap对象内部地数组无法装在更多地元素时\",{\"1\":{\"1427\":1}}],[\"而hashmap的长度length总是为2n\",{\"1\":{\"1425\":1}}],[\"而下一次循环的next\",{\"1\":{\"1428\":1}}],[\"而next指向了key\",{\"1\":{\"1428\":1}}],[\"而limit\",{\"1\":{\"1487\":1}}],[\"而linux中fork\",{\"1\":{\"1404\":1}}],[\"而length\",{\"1\":{\"1425\":1}}],[\"而消费者线程从任务队列中获取任务并执行\",{\"1\":{\"1412\":1}}],[\"而保护性暂停模式可以帮助我们解决上述的等待问题\",{\"1\":{\"1407\":1}}],[\"而多个线程之间相互协作时\",{\"1\":{\"1407\":1}}],[\"而线程本地存储方案\",{\"1\":{\"1405\":1}}],[\"而利用java线程中断机制的interrupt\",{\"1\":{\"1401\":1}}],[\"而过多的线程的也会消耗内存等其他资源\",{\"1\":{\"1387\":1}}],[\"而我们通过方法引用的方式\",{\"1\":{\"1490\":1}}],[\"而我们又设置了过多的线程\",{\"1\":{\"1387\":1}}],[\"而我们的目的只是计数\",{\"1\":{\"714\":1}}],[\"而有的里面没有任何容量\",{\"1\":{\"1386\":1}}],[\"而有业务逻辑的字段做主键\",{\"1\":{\"472\":1}}],[\"而取元素时只有取之前队列是满的才会唤醒notfull\",{\"1\":{\"1380\":1}}],[\"而负责放任务的线程是无法直接访问到我们银行具体实现转账操作的对象的\",{\"1\":{\"1378\":1}}],[\"而释放锁时\",{\"1\":{\"1360\":1}}],[\"而exchange\",{\"1\":{\"1356\":1}}],[\"而改用epoll\",{\"1\":{\"740\":1}}],[\"而write方法一般来说不会阻塞\",{\"1\":{\"739\":1}}],[\"而worker\",{\"1\":{\"598\":1}}],[\"而字典的值则是一个链表\",{\"1\":{\"736\":1}}],[\"而父进程依然可以接收来自客户端的请求\",{\"1\":{\"725\":1}}],[\"而stream<t>又正好继承了basestream\",{\"1\":{\"1496\":1}}],[\"而save命令已经废弃\",{\"1\":{\"724\":1}}],[\"而session\",{\"1\":{\"578\":1,\"585\":1}}],[\"而server层也有自己的日志\",{\"1\":{\"462\":1}}],[\"而value使用默认值填充\",{\"1\":{\"710\":1}}],[\"而对外的数据结构和命令没有影响\",{\"1\":{\"706\":1}}],[\"而对于并行实现将会对输入进行分区\",{\"1\":{\"1492\":1}}],[\"而对于thencomparing方法而言\",{\"1\":{\"1491\":1}}],[\"而对于n>0\",{\"1\":{\"1486\":1}}],[\"而对于delayqueue而言\",{\"1\":{\"1386\":1}}],[\"而对于只读事务\",{\"1\":{\"634\":1}}],[\"而对于临时内存表的排序来说\",{\"1\":{\"557\":1}}],[\"而对于临时表\",{\"1\":{\"549\":1}}],[\"而对于确定要使用查询缓存的语句\",{\"1\":{\"456\":1}}],[\"而依赖于存储引擎的一些操作对应的成本常数就存储在了engine\",{\"1\":{\"694\":1}}],[\"而它们父节点中记录的每一条目录项记录都对应一个数据页\",{\"1\":{\"686\":1}}],[\"而写锁组会把读和写都阻塞\",{\"1\":{\"672\":1}}],[\"而双路排序只会把主键和需要排序的字段放到sort\",{\"1\":{\"657\":1}}],[\"而一般情况下\",{\"1\":{\"632\":1}}],[\"而一个索引上不同的值的个数\",{\"1\":{\"484\":1}}],[\"而为了解决这个主键冲突\",{\"1\":{\"628\":1}}],[\"而又未经确认的话\",{\"1\":{\"621\":1}}],[\"而能够使用这个方案的前题是\",{\"1\":{\"621\":1}}],[\"而当线程b恢复执行或者执行操作a时\",{\"1\":{\"1408\":1}}],[\"而当前的自增id的值是2\",{\"1\":{\"628\":1}}],[\"而当前读的规则\",{\"1\":{\"583\":1}}],[\"而当session\",{\"1\":{\"618\":1}}],[\"而update语句\",{\"1\":{\"615\":1}}],[\"而备库还没收到日志的状态\",{\"1\":{\"609\":1}}],[\"而按照mariadb的并行复制策略\",{\"1\":{\"601\":1}}],[\"而mybatis则帮我们简化了以上功能\",{\"1\":{\"1860\":1}}],[\"而mysql5\",{\"1\":{\"611\":1}}],[\"而mysql启动的时候\",{\"1\":{\"562\":1}}],[\"而map是中间操作\",{\"1\":{\"1487\":1}}],[\"而map就称之为中间操作\",{\"1\":{\"1484\":1}}],[\"而mariadb的并行复制策略利用这个特性\",{\"1\":{\"601\":1}}],[\"而modcount主要记录hashmap内部结构发生变化的次数\",{\"1\":{\"1423\":1}}],[\"而不会操作里面的值\",{\"1\":{\"1494\":1}}],[\"而不会储存输入元素本身\",{\"1\":{\"714\":1}}],[\"而不再是传统的值\",{\"1\":{\"1475\":1}}],[\"而不需要遍历整个链表\",{\"1\":{\"1425\":1}}],[\"而不需要存储过程\",{\"1\":{\"1386\":1}}],[\"而不需要去关心银行这个类如何实现具体的转账业务\",{\"1\":{\"1378\":1}}],[\"而不需要自己去考虑更多的线程安全问题\",{\"1\":{\"1378\":1}}],[\"而不给truncate\",{\"1\":{\"624\":1}}],[\"而不设置备只读也是不行的\",{\"1\":{\"596\":1}}],[\"而不是对每个元素一次检测\",{\"1\":{\"1497\":1}}],[\"而不是在spliterator创建的时候绑定的\",{\"1\":{\"1497\":1}}],[\"而不是保持独立\",{\"1\":{\"1492\":1}}],[\"而不是通过替换结果进行合并的\",{\"1\":{\"1485\":1}}],[\"而不是一个普通的int\",{\"1\":{\"1487\":1}}],[\"而不是一个注解类型\",{\"1\":{\"1471\":1}}],[\"而不是一个哈希表\",{\"1\":{\"545\":1}}],[\"而不是kafka这样的分布式队列\",{\"1\":{\"1396\":1}}],[\"而不是堆分配\",{\"1\":{\"1365\":1}}],[\"而不是用户态的线程\",{\"1\":{\"1354\":1}}],[\"而不是广播的\",{\"1\":{\"1351\":1}}],[\"而不是页这个词\",{\"1\":{\"694\":1}}],[\"而不是使用字符串\",{\"1\":{\"666\":1}}],[\"而不是使用mysql的嵌套循环关联\",{\"1\":{\"531\":1}}],[\"而不是真正地去数据库查询\",{\"1\":{\"608\":1}}],[\"而不是按照表内的索引顺序进行读取\",{\"1\":{\"467\":1}}],[\"而不是两次\",{\"0\":{\"95\":1}}],[\"而使用lambda表达式就可以实现传递行为这种高阶函数\",{\"1\":{\"1470\":1}}],[\"而使用线程安全的concurrenthashmap\",{\"1\":{\"1428\":1}}],[\"而使用哪种方式取决于session变量gtid\",{\"1\":{\"605\":1}}],[\"而使用mixed或者statement格式的binlog时\",{\"1\":{\"596\":1}}],[\"而使用force\",{\"1\":{\"485\":1}}],[\"而没有compose\",{\"1\":{\"1475\":1}}],[\"而没有写操作\",{\"1\":{\"1403\":1}}],[\"而没有写\",{\"1\":{\"1403\":1}}],[\"而没有先做判断直接切换的话\",{\"1\":{\"595\":1}}],[\"而没有调用fsync\",{\"1\":{\"588\":1}}],[\"而从库\",{\"1\":{\"594\":1}}],[\"而从5\",{\"1\":{\"549\":1}}],[\"而把备库集中在一台机器上\",{\"1\":{\"594\":1}}],[\"而节点a是b的备库\",{\"1\":{\"590\":1}}],[\"而节点b是a的备库\",{\"1\":{\"590\":1}}],[\"而referencepipeline又实现了stream接口\",{\"1\":{\"1500\":1}}],[\"而referencepipeline的构造方法又调用了它的父类abstractpipeline的构造方法\",{\"1\":{\"1498\":1}}],[\"而referencepipeline则是存在previousstage的\",{\"1\":{\"1498\":1}}],[\"而reducing方法本身又是通过collectorimpl来实现的\",{\"1\":{\"1495\":1}}],[\"而reduce描述的一种聚合\",{\"1\":{\"1484\":1}}],[\"而redo\",{\"1\":{\"588\":1}}],[\"而reentrantlock对于已经在等待的线程是先来的线程先获得锁\",{\"1\":{\"1372\":1}}],[\"而reentrantlock需要开发者在finally块中显示释放锁\",{\"1\":{\"1372\":1}}],[\"而reentrantlock\",{\"1\":{\"1372\":1}}],[\"而rows字段显式需要扫描的行数是50198\",{\"1\":{\"484\":1}}],[\"而要了解组提交首先要了解日志逻辑序列号\",{\"1\":{\"588\":1}}],[\"而要写入2017\",{\"1\":{\"561\":1}}],[\"而根据binlog的执行结果是\",{\"1\":{\"584\":1}}],[\"而会等到整个事务提交后再释放\",{\"1\":{\"578\":1}}],[\"而执行期间另一个线程对这个表结构在做变更\",{\"1\":{\"578\":1}}],[\"而将整个库设置为readonly之后\",{\"1\":{\"575\":1}}],[\"而锁就是用来实现这些访问规则的重要数据结构\",{\"1\":{\"573\":1}}],[\"而\",{\"1\":{\"570\":1,\"613\":1,\"1525\":1}}],[\"而第一个lamda表达式所打印的就是当前类lambdatest的地址\",{\"1\":{\"1469\":1}}],[\"而第二阶段则是线程t2响应终止指令\",{\"1\":{\"1401\":1}}],[\"而第二条update语句的事务id就是0了\",{\"1\":{\"634\":1}}],[\"而第二个语句创建的index2索引里面\",{\"1\":{\"487\":1}}],[\"而第三步的select也可以用索引快速定位\",{\"1\":{\"559\":1}}],[\"而优化器的作用就是决定选择使用哪一个方案\",{\"1\":{\"651\":1}}],[\"而优化器的作用就是决定选择使用哪一种方案\",{\"1\":{\"458\":1}}],[\"而优先队列算法\",{\"1\":{\"558\":1}}],[\"而临时表由于会自动回收\",{\"1\":{\"547\":1}}],[\"而临时表\",{\"1\":{\"546\":1}}],[\"而考虑到扫描行数\",{\"1\":{\"540\":1}}],[\"而被驱动表是走树搜索\",{\"1\":{\"538\":1}}],[\"而characteristics执行了两次\",{\"1\":{\"1494\":1}}],[\"而change\",{\"1\":{\"481\":1,\"482\":1}}],[\"而collectingandthen方法的目的就在于转换最终的结果类型\",{\"1\":{\"1495\":1}}],[\"而collection接口又继承了iterable这个类\",{\"1\":{\"1470\":1}}],[\"而collectors本身实际上是一个工厂\",{\"1\":{\"1492\":1}}],[\"而countdownlatch则是通过aqs的\",{\"1\":{\"1373\":1}}],[\"而count\",{\"1\":{\"536\":1}}],[\"而cyclicbarrier的计数器可以使用reset\",{\"1\":{\"1373\":1}}],[\"而刚刚加1的这个计数操作却丢失了\",{\"1\":{\"534\":1}}],[\"而普通索引树的叶子节点是主键值\",{\"1\":{\"533\":1}}],[\"而拆分后\",{\"1\":{\"531\":1}}],[\"而只是一个中间操作\",{\"1\":{\"1487\":1}}],[\"而只是删掉了其中某一个节点的数据的话\",{\"1\":{\"625\":1}}],[\"而只会告诉我们生成结果时一共扫描了多少行数据\",{\"1\":{\"527\":1}}],[\"而只能根据统计信息来估算记录数\",{\"1\":{\"484\":1}}],[\"而输入的参数却是整型\",{\"1\":{\"504\":1}}],[\"而倒序存储方式毕竟还是用的前缀索引的方式\",{\"1\":{\"489\":1}}],[\"而哈希字段的方式需要额外调用一次crc32\",{\"1\":{\"489\":1}}],[\"而哈希字段方法需要增加一个字段\",{\"1\":{\"489\":1}}],[\"而这两个方法执行的前提是根据方法参数类型能找到对应的bean\",{\"1\":{\"1530\":1}}],[\"而这些文件描述符\",{\"1\":{\"1442\":1}}],[\"而这些行为的抽象就是基于abstractqueuedsynchronizer实现的\",{\"1\":{\"1367\":1}}],[\"而这明显不合\",{\"1\":{\"613\":1}}],[\"而这里transaction\",{\"1\":{\"605\":1}}],[\"而这个唯一的结果容器就是最终的结果容器\",{\"1\":{\"1494\":1}}],[\"而这个无参构造刚好满足不接受参数\",{\"1\":{\"1477\":1}}],[\"而这个很大的数\",{\"1\":{\"634\":1}}],[\"而这个位置就是我们所说的同步位点\",{\"1\":{\"604\":1}}],[\"而这个一致性\",{\"1\":{\"584\":1}}],[\"而这个时候\",{\"1\":{\"579\":1}}],[\"而这个更新往往是在系统比较空闲的时候做\",{\"1\":{\"461\":1}}],[\"而这必须要将数据页读入内存才能判断\",{\"1\":{\"480\":1}}],[\"而如果没有设置\",{\"1\":{\"1494\":1}}],[\"而如果传入的是父类型的比较器\",{\"1\":{\"1491\":1}}],[\"而如果平均工作时间长\",{\"1\":{\"1387\":1}}],[\"而如果我们设置更多的线程数\",{\"1\":{\"1387\":1}}],[\"而如果业务开发人员有ddl需求话\",{\"1\":{\"624\":1}}],[\"而如果是update\",{\"1\":{\"621\":1}}],[\"而如果加上\",{\"1\":{\"619\":1}}],[\"而如果db1这个库里表很少的话\",{\"1\":{\"619\":1}}],[\"而如果这时候刚好这两个事务更新的是同一行\",{\"1\":{\"597\":1}}],[\"而如果这个数据页还没有在内存中的话\",{\"1\":{\"480\":1}}],[\"而如果执行的语句去掉limit\",{\"1\":{\"591\":1}}],[\"而如果计算month\",{\"1\":{\"503\":1}}],[\"而如果使用index2\",{\"1\":{\"488\":1}}],[\"而如果选择扫描10万行\",{\"1\":{\"484\":1}}],[\"而如果用整型做主键\",{\"1\":{\"472\":1}}],[\"而且课程最后还会手把手教大家将项目部署在云服务器\",{\"1\":{\"1865\":1}}],[\"而且性能也可以得到保证\",{\"1\":{\"1451\":1}}],[\"而且map中还丢失了元素\",{\"1\":{\"1428\":1}}],[\"而且mysql查询优化器计算索引合并成本的算法也比较麻烦\",{\"1\":{\"687\":1}}],[\"而且一旦指定\",{\"1\":{\"1415\":1}}],[\"而且一个实例上db数也不会很多\",{\"1\":{\"600\":1}}],[\"而且能够限制线程的最大数量\",{\"1\":{\"1411\":1}}],[\"而且路由表对数据的一致性要求并不高\",{\"1\":{\"1404\":1}}],[\"而且存在死锁的隐患\",{\"1\":{\"1396\":1}}],[\"而且最好是非阻塞任务\",{\"1\":{\"1387\":1}}],[\"而且总是由同一线程多次获得\",{\"1\":{\"1362\":1}}],[\"而且每个段的执行结果会作为下一个段的输入\",{\"1\":{\"1498\":1}}],[\"而且每个条件变量都对应有一个等待队列\",{\"1\":{\"1360\":1}}],[\"而且每次等待时长也不小的时候\",{\"1\":{\"675\":1}}],[\"而且此种方案会占用空间\",{\"1\":{\"767\":1}}],[\"而且是多种实现\",{\"1\":{\"706\":1}}],[\"而且key已经过期\",{\"1\":{\"706\":1}}],[\"而且不符合最左前缀原则\",{\"1\":{\"684\":1}}],[\"而且用于计算的数据\",{\"1\":{\"665\":1}}],[\"而且需要确保binlog在被从本地删除之前已经做了备份\",{\"1\":{\"622\":1}}],[\"而且容易出错\",{\"1\":{\"605\":1}}],[\"而且瓶颈在io上\",{\"1\":{\"588\":1}}],[\"而且也看到了\",{\"1\":{\"583\":1}}],[\"而且客户端有重试机制\",{\"1\":{\"578\":1}}],[\"而且并不会自动提交\",{\"1\":{\"572\":1}}],[\"而且计算过程还用上了临时表主键id的唯一性约束\",{\"1\":{\"551\":1}}],[\"而且还会学习整合ssm框架\",{\"1\":{\"1860\":1}}],[\"而且还有很多额外的功能\",{\"1\":{\"798\":1}}],[\"而且还要保证索引不失效\",{\"1\":{\"512\":1}}],[\"而且还是顺序写的\",{\"1\":{\"482\":1}}],[\"而且由于\",{\"1\":{\"493\":1}}],[\"而且其实都不准确\",{\"1\":{\"484\":1}}],[\"而且\",{\"1\":{\"480\":1,\"541\":1,\"596\":1,\"606\":1,\"613\":1,\"615\":1,\"634\":1}}],[\"而且通过业务代码保证不会写入两个重复的身份证号\",{\"1\":{\"478\":1}}],[\"而且年龄是10岁所有男孩\",{\"1\":{\"477\":1}}],[\"而在sqlsessiontemplate类中就存在一个getmapper方法\",{\"1\":{\"1530\":1}}],[\"而在我们的程序中\",{\"1\":{\"1494\":1}}],[\"而在别的地方\",{\"1\":{\"1493\":1}}],[\"而在其他语言中\",{\"1\":{\"1470\":1}}],[\"而在其它情况下change\",{\"1\":{\"481\":1}}],[\"而在用户进程这边\",{\"1\":{\"1440\":1}}],[\"而在以往\",{\"1\":{\"1395\":1}}],[\"而在显示值里面加上248\",{\"1\":{\"634\":1}}],[\"而在数据层解决读性能问题\",{\"1\":{\"603\":1}}],[\"而在数据库中做关联查询\",{\"1\":{\"531\":1}}],[\"而在备库执行这条sql语句的时候\",{\"1\":{\"591\":1}}],[\"而在innodb引擎中会返回4001\",{\"1\":{\"491\":1}}],[\"而在mysql\",{\"1\":{\"477\":1}}],[\"而在b+树中\",{\"1\":{\"350\":1}}],[\"而再建立一个\",{\"1\":{\"475\":1}}],[\"而哪些场景下不应该\",{\"1\":{\"472\":1}}],[\"而更糟的情况是\",{\"1\":{\"472\":1}}],[\"而底层的实现也可能不同\",{\"1\":{\"471\":1}}],[\"而结束于另一点\",{\"1\":{\"467\":1}}],[\"而两阶段提交就是让这两个状态保持逻辑上的一致\",{\"1\":{\"464\":1}}],[\"而存储引擎层负责数据的存储和提取\",{\"1\":{\"454\":1}}],[\"而是刷个10来道题目之后\",{\"1\":{\"1850\":1}}],[\"而是向spring容器中添加了一个advisor\",{\"1\":{\"1526\":1}}],[\"而是拿出一个元素执行所有的中间操作\",{\"1\":{\"1498\":1}}],[\"而是通过声明式的方式来描述他们元以及操作\",{\"1\":{\"1496\":1}}],[\"而是通过一个selector处理多个客户端连接\",{\"1\":{\"1451\":1}}],[\"而是new了一个int类型的数组\",{\"1\":{\"1495\":1}}],[\"而是会调用最后指定的方式\",{\"1\":{\"1494\":1}}],[\"而是会查询出全部的结果集\",{\"1\":{\"520\":1}}],[\"而是定义在collectors当中\",{\"1\":{\"1493\":1}}],[\"而是在不停的运行\",{\"1\":{\"1487\":1}}],[\"而是在于能处理更多的连接\",{\"1\":{\"1442\":1}}],[\"而是这样的\",{\"1\":{\"1487\":1}}],[\"而是objects\",{\"1\":{\"1476\":1}}],[\"而是枚举或者类\",{\"1\":{\"1471\":1}}],[\"而是省掉了cpu拷贝环节\",{\"1\":{\"1453\":1}}],[\"而是马上就得到了一个结果\",{\"1\":{\"1441\":1}}],[\"而是立刻返回一个error\",{\"1\":{\"1441\":1}}],[\"而是采用了cas机制\",{\"1\":{\"1431\":1}}],[\"而是采用了优先队列排序算法\",{\"1\":{\"558\":1}}],[\"而是让父子进程共享同一个地址空间\",{\"1\":{\"1404\":1}}],[\"而是创建了一个新字符串\",{\"1\":{\"1404\":1}}],[\"而是阻塞等待\",{\"1\":{\"1397\":1}}],[\"而是存储在cpu寄存器中\",{\"1\":{\"1365\":1}}],[\"而是直接返回\",{\"1\":{\"1451\":1}}],[\"而是直接移动takeindex的指针\",{\"1\":{\"1379\":1}}],[\"而是直接通过cas操作将其mark\",{\"1\":{\"1362\":1}}],[\"而是直接使用了排序算法\",{\"1\":{\"555\":1}}],[\"而是能读多少读多少\",{\"1\":{\"739\":1}}],[\"而是将行为作为参数进行传递\",{\"1\":{\"1472\":1}}],[\"而是将这些常用的公共api抽取出来封装成为一个工具类\",{\"1\":{\"721\":1}}],[\"而是将redo\",{\"1\":{\"463\":1}}],[\"而是每次申请完就马上释放\",{\"1\":{\"629\":1}}],[\"而是多个\",{\"1\":{\"621\":1}}],[\"而是客户端慢\",{\"1\":{\"619\":1}}],[\"而是给进程发一个信号\",{\"1\":{\"618\":1}}],[\"而是告诉线程\",{\"1\":{\"618\":1}}],[\"而是找位点的这个工作\",{\"1\":{\"605\":1}}],[\"而是\",{\"1\":{\"599\":1}}],[\"而是替换成了两个event\",{\"1\":{\"591\":1}}],[\"而是要等到事务结束时才释放\",{\"1\":{\"580\":1}}],[\"而是要使用\",{\"1\":{\"471\":1}}],[\"而是数据量的问题或者说时使用方式的问题了\",{\"1\":{\"563\":1}}],[\"而是p\",{\"1\":{\"561\":1}}],[\"而是使用t类型以及t以上的类型\",{\"1\":{\"1495\":1}}],[\"而是使用结合中已有的成员作为中心点\",{\"1\":{\"713\":1}}],[\"而是使用索引统计数据\",{\"1\":{\"690\":1}}],[\"而是使用了另一个叫做\",{\"1\":{\"539\":1}}],[\"而是使用二叉查找树可以吗\",{\"0\":{\"38\":1}}],[\"而是email\",{\"1\":{\"487\":1}}],[\"而是不适用于唯一索引\",{\"1\":{\"481\":1}}],[\"而是以页为单位\",{\"1\":{\"479\":1}}],[\"而是插入后自平衡\",{\"1\":{\"345\":1}}],[\"而是选择扫描行数是100000的执行计划\",{\"1\":{\"484\":1}}],[\"而是选择先用链表\",{\"0\":{\"37\":1}}],[\"而是选用数组\",{\"0\":{\"35\":1}}],[\"的文章都是来自这本书\",{\"1\":{\"1870\":1}}],[\"的书籍推荐\",{\"1\":{\"1870\":1}}],[\"的开发便利性简化了分布式系统的开发\",{\"1\":{\"1867\":1}}],[\"的开销而引入偏向锁\",{\"1\":{\"1362\":1}}],[\"的封装\",{\"1\":{\"1864\":1}}],[\"的底层问题\",{\"1\":{\"1861\":1}}],[\"的一部分\",{\"1\":{\"1860\":1}}],[\"的一个实例\",{\"1\":{\"1472\":1}}],[\"的代码库托管站\",{\"1\":{\"1859\":1}}],[\"的gui开发使用并不多\",{\"1\":{\"1847\":1}}],[\"的gui编程\",{\"1\":{\"1847\":1}}],[\"的gtid的集合记为set\",{\"1\":{\"605\":1}}],[\"的危与机\",{\"1\":{\"1843\":1}}],[\"的部分技术规范\",{\"1\":{\"1561\":1}}],[\"的作用\",{\"1\":{\"1541\":1}}],[\"的作用是能保证每次取出的元素都是队列中权值最小的\",{\"1\":{\"353\":1}}],[\"的任意一个方法上面添加了\",{\"1\":{\"1529\":1}}],[\"的映射关系\",{\"1\":{\"1513\":1}}],[\"的属性\",{\"1\":{\"1497\":1}}],[\"的分割迭代器\",{\"1\":{\"1497\":1}}],[\"的流\",{\"1\":{\"1496\":1}}],[\"的对象\",{\"1\":{\"1496\":1}}],[\"的频率非常的高\",{\"1\":{\"1492\":1}}],[\"的说明\",{\"1\":{\"1478\":1}}],[\"的参数\",{\"1\":{\"1472\":1,\"1485\":1}}],[\"的使用\",{\"1\":{\"1470\":1}}],[\"的方式获取数组对应index上的元素\",{\"1\":{\"1431\":1}}],[\"的方式来代替关联查询的时候\",{\"1\":{\"531\":1}}],[\"的引用赋给了e\",{\"1\":{\"1427\":1}}],[\"的首个元素是否和key一样\",{\"1\":{\"1426\":1}}],[\"的高位异或低16位实现的\",{\"1\":{\"1425\":1}}],[\"的个数\",{\"1\":{\"1423\":1}}],[\"的意思\",{\"1\":{\"1408\":1}}],[\"的工厂类\",{\"1\":{\"1397\":1}}],[\"的奇数位\",{\"1\":{\"1390\":1}}],[\"的线程\",{\"1\":{\"1360\":1}}],[\"的线程时不算在128里面的\",{\"1\":{\"613\":1}}],[\"的jvm字节码指令\",{\"1\":{\"1359\":1}}],[\"的价值所在\",{\"1\":{\"1356\":1}}],[\"的bean会被缓存嘛\",{\"0\":{\"1343\":1}}],[\"的数据安全性\",{\"1\":{\"733\":1}}],[\"的数据结构\",{\"0\":{\"90\":1}}],[\"的基数估算值\",{\"1\":{\"714\":1}}],[\"的基础上\",{\"1\":{\"549\":1}}],[\"的成员\",{\"1\":{\"711\":1}}],[\"的成本比扫描全表的成本更高\",{\"1\":{\"659\":1}}],[\"的生存时间\",{\"1\":{\"707\":1}}],[\"的旧值\",{\"1\":{\"707\":1}}],[\"的名称\",{\"1\":{\"706\":1}}],[\"的搜索条件\",{\"1\":{\"691\":2}}],[\"的整个区间就可以叫做临键锁\",{\"1\":{\"674\":1}}],[\"的争用以外\",{\"1\":{\"670\":1}}],[\"的优点是\",{\"1\":{\"714\":1}}],[\"的优化常见优化方法有四种\",{\"1\":{\"663\":1}}],[\"的优势\",{\"1\":{\"541\":1}}],[\"的主键id\",{\"1\":{\"657\":1}}],[\"的主备关系\",{\"1\":{\"605\":1}}],[\"的能力\",{\"1\":{\"627\":1}}],[\"的结论\",{\"1\":{\"615\":1}}],[\"的语句\",{\"1\":{\"613\":1}}],[\"的语义\",{\"1\":{\"551\":1}}],[\"的语义相同\",{\"1\":{\"354\":1}}],[\"的确认\",{\"1\":{\"609\":1}}],[\"的程度\",{\"1\":{\"609\":1}}],[\"的自己生成的binlog中的gtid集合格式是\",{\"1\":{\"605\":1}}],[\"的file文件的123位置\",{\"1\":{\"604\":1}}],[\"的file\",{\"1\":{\"604\":1}}],[\"的\",{\"1\":{\"604\":1,\"1431\":1,\"1861\":1}}],[\"的位点是不同的\",{\"1\":{\"604\":1}}],[\"的位置上\",{\"1\":{\"375\":1}}],[\"的从库的语法如下\",{\"1\":{\"605\":1}}],[\"的从库的时候\",{\"1\":{\"604\":1}}],[\"的从库\",{\"1\":{\"604\":1}}],[\"的ip\",{\"1\":{\"604\":1}}],[\"的场景\",{\"1\":{\"602\":1}}],[\"的过程如果使用的是单线程的话\",{\"1\":{\"597\":1}}],[\"的过程中\",{\"1\":{\"480\":1}}],[\"的模式\",{\"1\":{\"594\":1}}],[\"的速度\",{\"1\":{\"594\":1}}],[\"的机制\",{\"1\":{\"588\":1}}],[\"的行\",{\"1\":{\"584\":2}}],[\"的行数\",{\"1\":{\"532\":1}}],[\"的概念\",{\"1\":{\"570\":1,\"1858\":1}}],[\"的问题\",{\"1\":{\"570\":1,\"606\":2,\"623\":1}}],[\"的特性\",{\"1\":{\"569\":1,\"1497\":1}}],[\"的执行过程\",{\"1\":{\"559\":1}}],[\"的由来\",{\"1\":{\"540\":1}}],[\"的算法\",{\"1\":{\"539\":1}}],[\"的表的总行数\",{\"1\":{\"533\":1}}],[\"的例子来说明\",{\"1\":{\"533\":1}}],[\"的原因\",{\"1\":{\"533\":1}}],[\"的实现\",{\"0\":{\"533\":1},\"1\":{\"1472\":1,\"1869\":1}}],[\"的查询\",{\"1\":{\"526\":1,\"527\":1}}],[\"的查询复杂度\",{\"1\":{\"471\":1}}],[\"的设置\",{\"1\":{\"501\":1}}],[\"的总次数\",{\"1\":{\"501\":1}}],[\"的遍历过程中\",{\"1\":{\"493\":1}}],[\"的当前值\",{\"1\":{\"491\":1}}],[\"的初始值\",{\"1\":{\"491\":1}}],[\"的大小和需要查询的字段的总大小来判断使用哪种排序模式\",{\"1\":{\"657\":1}}],[\"的大小\",{\"1\":{\"491\":1}}],[\"的所有字段和值\",{\"1\":{\"710\":1}}],[\"的所有数据\",{\"1\":{\"542\":1}}],[\"的所有人的名字\",{\"1\":{\"490\":1}}],[\"的所有市民了\",{\"1\":{\"489\":1}}],[\"的前缀索引\",{\"1\":{\"488\":1}}],[\"的记录下面有两种方式来查询\",{\"1\":{\"508\":1}}],[\"的记录只有一个\",{\"1\":{\"487\":1}}],[\"的记录\",{\"1\":{\"487\":1,\"491\":1,\"493\":1}}],[\"的记录一条条取出来回表\",{\"1\":{\"477\":1}}],[\"的条件了\",{\"1\":{\"487\":1}}],[\"的这三种格式间的区别\",{\"1\":{\"591\":1}}],[\"的这些记录\",{\"1\":{\"491\":1}}],[\"的这条记录\",{\"1\":{\"487\":1}}],[\"的这一行\",{\"1\":{\"455\":1}}],[\"的话\",{\"1\":{\"480\":1,\"488\":2,\"503\":1}}],[\"的操作接口\",{\"1\":{\"1864\":1}}],[\"的操作\",{\"1\":{\"479\":1,\"581\":1}}],[\"的单字段索引\",{\"1\":{\"476\":1}}],[\"的人\",{\"1\":{\"476\":1}}],[\"的人时\",{\"1\":{\"476\":1}}],[\"的联合索引和一个\",{\"1\":{\"476\":1}}],[\"的联合索引\",{\"1\":{\"475\":1}}],[\"的形式\",{\"1\":{\"464\":1,\"1431\":1}}],[\"的时候一些汇总信息\",{\"1\":{\"1492\":1}}],[\"的时候会释放锁\",{\"1\":{\"1367\":1}}],[\"的时候会直接返回这个数\",{\"1\":{\"533\":1}}],[\"的时候都需要用怀疑的眼光审视\",{\"1\":{\"522\":1}}],[\"的时候\",{\"1\":{\"458\":1,\"485\":1,\"533\":1,\"570\":1,\"585\":1,\"587\":1,\"651\":2}}],[\"的错误提醒\",{\"1\":{\"457\":1}}],[\"的错误\",{\"1\":{\"455\":1}}],[\"的值相等\",{\"1\":{\"1356\":1}}],[\"的值变化\",{\"1\":{\"724\":3}}],[\"的值设为\",{\"1\":{\"707\":1,\"710\":1}}],[\"的值分别为\",{\"1\":{\"472\":1}}],[\"的值\",{\"1\":{\"430\":1,\"487\":1}}],[\"的子串都是回文串\",{\"1\":{\"428\":1}}],[\"的子集为例\",{\"1\":{\"399\":1}}],[\"的最长公共序列的长度\",{\"1\":{\"427\":1}}],[\"的情况下\",{\"1\":{\"1541\":1}}],[\"的情况\",{\"1\":{\"415\":1}}],[\"的节点都删掉\",{\"1\":{\"302\":2}}],[\"的区别是什么\",{\"0\":{\"17\":1,\"199\":1}}],[\"中文手册\",{\"1\":{\"1859\":1}}],[\"中配置相关依赖后\",{\"1\":{\"1858\":1}}],[\"中需要接收的参数的类型\",{\"1\":{\"1472\":1}}],[\"中值得学习的地方\",{\"0\":{\"1052\":1}}],[\"中查找\",{\"1\":{\"763\":1}}],[\"中可以创建多个数据库类似\",{\"1\":{\"704\":1}}],[\"中有多少条记录\",{\"1\":{\"691\":1}}],[\"中有几种引用类型\",{\"0\":{\"109\":1}}],[\"中对应的目录项记录之间隔着几条记录\",{\"1\":{\"686\":1}}],[\"中等长度文本数据\",{\"1\":{\"667\":1}}],[\"中读取行\",{\"1\":{\"661\":1}}],[\"中转日志还没有应用完成\",{\"1\":{\"596\":1}}],[\"中就可以少几个id\",{\"1\":{\"531\":1}}],[\"中间件\",{\"1\":{\"1844\":1}}],[\"中间操作\",{\"1\":{\"1500\":2}}],[\"中间操纵都会返回一个stream对象\",{\"1\":{\"1488\":1}}],[\"中间结果容器的个数也是类似的\",{\"1\":{\"1494\":1}}],[\"中间演化经历多个版本\",{\"1\":{\"597\":1}}],[\"中间兄弟不能断\",{\"1\":{\"507\":1}}],[\"中间子树包含介于两元素之间的元素\",{\"1\":{\"347\":1}}],[\"中能偷盗的最大金额\",{\"1\":{\"431\":1}}],[\"中再次列出\",{\"1\":{\"350\":1}}],[\"中序遍历后的结果是一个递增的数列\",{\"1\":{\"397\":1}}],[\"中序遍历录入当前节点\",{\"1\":{\"395\":1}}],[\"中序遍历是递增序列\",{\"1\":{\"340\":1}}],[\"中序\",{\"1\":{\"339\":1}}],[\"中\",{\"1\":{\"295\":1,\"482\":1,\"710\":2,\"711\":2,\"714\":1,\"1357\":1,\"1453\":1}}],[\"中消费时\",{\"0\":{\"258\":1}}],[\"中的filechannel\",{\"1\":{\"1465\":1}}],[\"中的\",{\"1\":{\"1356\":2}}],[\"中的一个\",{\"1\":{\"761\":1}}],[\"中的所有成员\",{\"1\":{\"711\":1}}],[\"中的sex\",{\"1\":{\"710\":1}}],[\"中的指定字段的浮点数值加上增量\",{\"1\":{\"710\":1}}],[\"中的指定字段的整数值加上增量n\",{\"1\":{\"710\":1}}],[\"中的字段\",{\"1\":{\"710\":1}}],[\"中的n代表最大字符数\",{\"1\":{\"667\":1}}],[\"中的安全点和安全区各代表什么\",{\"0\":{\"118\":1}}],[\"中的值\",{\"0\":{\"90\":1}}],[\"中国矿业大学\",{\"1\":{\"9\":1}}],[\"有很多生产经常遇到的问题\",{\"1\":{\"1852\":1}}],[\"有很多用户都只使用\",{\"1\":{\"733\":1}}],[\"有以下四个注解之一\",{\"1\":{\"1529\":1}}],[\"有以下考虑\",{\"1\":{\"590\":1}}],[\"有\",{\"1\":{\"1527\":1,\"1531\":1}}],[\"有状态的中间操作\",{\"1\":{\"1501\":1}}],[\"有助于我们强化对于collector的理解\",{\"1\":{\"1495\":1}}],[\"有必要了解关于comparator比较器的内容\",{\"1\":{\"1491\":1}}],[\"有三个泛型\",{\"1\":{\"1475\":1}}],[\"有3个default默认方法\",{\"1\":{\"1471\":1}}],[\"有且仅有一个抽象方法\",{\"1\":{\"1471\":1}}],[\"有数据可读\",{\"1\":{\"1446\":1}}],[\"有界队列通常采用数组实现\",{\"1\":{\"1396\":1}}],[\"有返回值\",{\"1\":{\"1395\":2}}],[\"有自旋优化\",{\"1\":{\"1366\":1}}],[\"有批量重偏向\",{\"1\":{\"1366\":1}}],[\"有的默认是容量无限的\",{\"1\":{\"1386\":1}}],[\"有的是容量固定的\",{\"1\":{\"1386\":1}}],[\"有的对象可能不需要作为一个连续的内存结构存在也可以被访问到\",{\"1\":{\"1365\":1}}],[\"有的时候计算扇出值是很容易的\",{\"1\":{\"691\":1}}],[\"有着天然的原子性\",{\"1\":{\"1356\":1}}],[\"有多个advice会按照顺序进行执行\",{\"1\":{\"1531\":1}}],[\"有多种手段可以达到目的\",{\"1\":{\"1359\":1}}],[\"有多条指令在多个处理器上同时执行\",{\"1\":{\"1347\":1}}],[\"有多少种依赖注入的方式\",{\"0\":{\"1130\":1}}],[\"有了非阻塞io意味着线程在读写io时可以不必再阻塞了\",{\"1\":{\"739\":1}}],[\"有了redo\",{\"1\":{\"461\":1}}],[\"有效的纬度从\",{\"1\":{\"713\":1}}],[\"有效的经度从\",{\"1\":{\"713\":1}}],[\"有效经纬度\",{\"1\":{\"713\":1}}],[\"有效性是所有数据库必须解决的一个问题\",{\"1\":{\"670\":1}}],[\"有零星几个单点区间的话\",{\"1\":{\"690\":1}}],[\"有时两个key会定位到相同的问题\",{\"1\":{\"1423\":1}}],[\"有时人们把unix的时间戳保存为整数值\",{\"1\":{\"666\":1}}],[\"有时候需要进行io中断\",{\"1\":{\"1457\":1}}],[\"有时候l也表示list例如llen\",{\"1\":{\"708\":1}}],[\"有时候我们只想对这些串的前n个字符或字节建立索引\",{\"1\":{\"690\":1}}],[\"有时候使用索引执行查询时会有许多单点区间\",{\"1\":{\"690\":1}}],[\"有时候会碰到所有的查询都不能是过期读的需求\",{\"1\":{\"607\":1}}],[\"有时候一些运营类的查询语句会被放到备库上去查\",{\"1\":{\"590\":1}}],[\"有时候对于一个大查询我们需要\",{\"1\":{\"530\":1}}],[\"有时候还能避免某些列被修改带来的问题\",{\"1\":{\"522\":1}}],[\"有时候也成为fifo\",{\"1\":{\"334\":1}}],[\"有时候也称为filo\",{\"1\":{\"333\":1}}],[\"有符号\",{\"1\":{\"665\":1}}],[\"有无符号\",{\"1\":{\"664\":1}}],[\"有索引的情况下\",{\"1\":{\"662\":1}}],[\"有没有可能选择错等等\",{\"1\":{\"651\":1}}],[\"有没有了解通过ddd领域驱动设计\",{\"0\":{\"236\":1}}],[\"有可能筛选出来的是某个bean的类型\",{\"1\":{\"1525\":1}}],[\"有可能是beanclass\",{\"1\":{\"1525\":1}}],[\"有可能是内部类或其他虽然有\",{\"1\":{\"1524\":1}}],[\"有可能返回流本身\",{\"1\":{\"1496\":2}}],[\"有可能会返回流本身\",{\"1\":{\"1496\":1}}],[\"有可能会出现\",{\"1\":{\"626\":1}}],[\"有可能被放到了新数组的不同位置上\",{\"1\":{\"1427\":1}}],[\"有可能需要动态扩容\",{\"1\":{\"1386\":1}}],[\"有可能在叶子结点上\",{\"1\":{\"350\":1}}],[\"有新增了一个基于writeset的并行复制\",{\"1\":{\"602\":1}}],[\"有这样两个参数\",{\"1\":{\"602\":1}}],[\"有4个事务涉及到db1\",{\"1\":{\"598\":1}}],[\"有两个\",{\"1\":{\"1541\":1}}],[\"有两个set方法\",{\"1\":{\"1530\":1}}],[\"有两个比较常见的误解\",{\"1\":{\"619\":1}}],[\"有两个绕不开的问题\",{\"1\":{\"563\":1}}],[\"有两种方式可以产生新的主机\",{\"1\":{\"748\":1}}],[\"有两种方法\",{\"1\":{\"628\":1}}],[\"有两种思路\",{\"1\":{\"629\":1}}],[\"有两种比较常见的错误\",{\"1\":{\"604\":1}}],[\"有两种比较常用的思路\",{\"1\":{\"548\":1}}],[\"有两种常用的方法\",{\"1\":{\"604\":1}}],[\"有两种策略\",{\"1\":{\"581\":1}}],[\"有两种存储索引统计的方式\",{\"1\":{\"484\":1}}],[\"有不同的实现方式\",{\"1\":{\"533\":1}}],[\"有一些特性值会额外限制方法的行为\",{\"1\":{\"1497\":1}}],[\"有一些访问方式可能需要扫描很多行才能返回一行结果\",{\"1\":{\"527\":1}}],[\"有一个static方法\",{\"1\":{\"1471\":1}}],[\"有一个结果需要从一个线程传递到另一个线程\",{\"1\":{\"1407\":1}}],[\"有一个编程范式\",{\"1\":{\"1360\":1}}],[\"有一个特别的逻辑\",{\"1\":{\"618\":1}}],[\"有一个相同的commit\",{\"1\":{\"601\":1}}],[\"有一个事务涉及到db2\",{\"1\":{\"598\":1}}],[\"有一个字段a只有true和false两种值\",{\"1\":{\"496\":1}}],[\"有些地方也称这种io方式为event\",{\"1\":{\"1442\":1}}],[\"有些线上的库\",{\"1\":{\"619\":1}}],[\"有些部署条件下\",{\"1\":{\"594\":1}}],[\"有些客户端框架会默认连接成功后先执行set\",{\"1\":{\"572\":1}}],[\"有些查询会请求超过实际需要的数据\",{\"1\":{\"519\":1}}],[\"有些使用mysql占用内存涨的特别快\",{\"1\":{\"455\":1}}],[\"有序消费\",{\"0\":{\"1779\":1}}],[\"有序的执行\",{\"1\":{\"1500\":1}}],[\"有序的\",{\"1\":{\"1497\":1}}],[\"有序的一个stream\",{\"1\":{\"1486\":1}}],[\"有序性\",{\"0\":{\"1350\":1},\"1\":{\"1347\":1,\"1350\":1,\"1351\":1}}],[\"有序集成员按分数值递减\",{\"1\":{\"711\":1}}],[\"有序集合中对指定成员的分数加上增量\",{\"1\":{\"711\":1}}],[\"有序集合的成员是唯一的\",{\"1\":{\"711\":1}}],[\"有序集合\",{\"0\":{\"711\":1},\"1\":{\"705\":1}}],[\"有序\",{\"1\":{\"493\":1}}],[\"有序数组索引只适用于静态存储引擎\",{\"1\":{\"470\":1}}],[\"有序数组就是最好的数据结构了\",{\"1\":{\"470\":1}}],[\"有序数组在等值查询和范围查询场景中的性能就都非常优秀\",{\"1\":{\"470\":1}}],[\"有序数组\",{\"0\":{\"470\":1},\"1\":{\"468\":1}}],[\"有序数组的平方\",{\"0\":{\"362\":1}}],[\"有序二叉树\",{\"1\":{\"340\":1}}],[\"有child\",{\"1\":{\"302\":2}}],[\"有回退功能\",{\"1\":{\"293\":1}}],[\"有穷性\",{\"1\":{\"282\":1}}],[\"有哪些块还停留在磁盘上\",{\"1\":{\"694\":1}}],[\"有哪些具体的使用场景\",{\"0\":{\"252\":1}}],[\"有哪些实现\",{\"0\":{\"74\":1}}],[\"有哪几种认证方式\",{\"0\":{\"226\":1}}],[\"有什么好处\",{\"0\":{\"175\":1}}],[\"有什么缺点\",{\"0\":{\"122\":1}}],[\"有什么作用\",{\"0\":{\"106\":1}}],[\"有什么区别\",{\"0\":{\"96\":1},\"1\":{\"1868\":1}}],[\"有abc\",{\"1\":{\"693\":1}}],[\"有a\",{\"0\":{\"80\":1}}],[\"锁住链表或者红黑树的头结点\",{\"1\":{\"1431\":1}}],[\"锁住的是两个值之间的空隙\",{\"1\":{\"673\":1}}],[\"锁分离\",{\"1\":{\"1380\":1}}],[\"锁降级中的读锁获取是否必要呢\",{\"1\":{\"1375\":1}}],[\"锁降级\",{\"1\":{\"1375\":1}}],[\"锁粗化\",{\"0\":{\"1363\":1,\"1700\":1},\"1\":{\"1363\":1}}],[\"锁升级过程\",{\"1\":{\"1362\":1}}],[\"锁不仅不存在多线程竞争\",{\"1\":{\"1362\":1}}],[\"锁状态标志\",{\"1\":{\"1361\":2}}],[\"锁消除是java虚拟机在jit编译期间\",{\"1\":{\"1364\":1}}],[\"锁消除即删除不必要的加锁操作\",{\"1\":{\"1364\":1}}],[\"锁消除\",{\"0\":{\"1364\":1,\"1699\":1},\"1\":{\"1360\":1,\"1364\":1}}],[\"锁优化\",{\"0\":{\"1697\":1}}],[\"锁优化建议\",{\"0\":{\"676\":1}}],[\"锁优化技术你了解什么\",{\"0\":{\"69\":1}}],[\"锁主要是加在索引上\",{\"1\":{\"674\":1}}],[\"锁定\",{\"1\":{\"1350\":1}}],[\"锁定某一行还可以用lock\",{\"1\":{\"674\":1}}],[\"锁定粒度最小\",{\"1\":{\"672\":1}}],[\"锁定粒度大\",{\"1\":{\"671\":1}}],[\"锁定时间\",{\"1\":{\"566\":1}}],[\"锁冲突也是影响数据库并发访问性能的一个重要因素\",{\"1\":{\"670\":1}}],[\"锁是计算机协调多个进程或线程并发访问某一资源的机制\",{\"1\":{\"670\":1}}],[\"锁的粗化和锁的消除\",{\"1\":{\"1366\":1}}],[\"锁的重入次数\",{\"1\":{\"1360\":1}}],[\"锁的粒度更小了\",{\"1\":{\"1352\":1}}],[\"锁的就是两个值之间的空隙\",{\"1\":{\"585\":1}}],[\"锁的设计是为了保证数据的一致性\",{\"1\":{\"584\":1}}],[\"锁两个记录之间的gap\",{\"1\":{\"579\":1}}],[\"锁一条记录及其间隙\",{\"1\":{\"579\":1}}],[\"锁等待\",{\"1\":{\"518\":1}}],[\"锁机制是如何升级的\",{\"0\":{\"73\":1}}],[\"重要概念\",{\"0\":{\"1619\":1}}],[\"重要消息\",{\"1\":{\"711\":1}}],[\"重写的spliterator中的tryadvance方法\",{\"1\":{\"1497\":1}}],[\"重写的ofprimitive中的tryadvance方法\",{\"1\":{\"1497\":1}}],[\"重写的类需要文档化spliterator的绑定策略\",{\"1\":{\"1497\":1}}],[\"重写run方法\",{\"1\":{\"1468\":1}}],[\"重写这个复杂的查询\",{\"1\":{\"527\":1}}],[\"重新标记\",{\"0\":{\"1614\":1}}],[\"重新设置范围\",{\"1\":{\"1497\":1}}],[\"重新运行起来\",{\"1\":{\"1440\":1}}],[\"重新计时\",{\"1\":{\"1362\":1}}],[\"重量级锁竞争的时候\",{\"1\":{\"1362\":1}}],[\"重量级锁阻塞挂起的方法\",{\"1\":{\"1360\":1}}],[\"重量级锁有什么区别\",{\"0\":{\"73\":1}}],[\"重置为fasle\",{\"1\":{\"1354\":1}}],[\"重启也不会重置为0\",{\"1\":{\"634\":1}}],[\"重启之后就会清零\",{\"1\":{\"633\":1}}],[\"重启的时候依靠redo\",{\"1\":{\"627\":1}}],[\"重启后这个表的auto\",{\"1\":{\"627\":1}}],[\"重启后需要从存储redis数据的地方把这个值读回来\",{\"1\":{\"534\":1}}],[\"重启备库\",{\"1\":{\"622\":1}}],[\"重命名临时表\",{\"0\":{\"549\":1}}],[\"重构查询\",{\"0\":{\"528\":1}}],[\"重放到中午误删表之前的那个时刻\",{\"1\":{\"464\":1}}],[\"重做日志\",{\"0\":{\"461\":1},\"1\":{\"460\":1}}],[\"重复调用trysplit最终得到的结果一定是空\",{\"1\":{\"1497\":1}}],[\"重复次数目前默认为10\",{\"1\":{\"761\":1}}],[\"重复设置field进行覆盖\",{\"1\":{\"710\":1}}],[\"重复设置同一个field会覆盖\",{\"1\":{\"710\":1}}],[\"重复3\",{\"1\":{\"657\":1}}],[\"重复第二步\",{\"1\":{\"558\":1}}],[\"重复执行步骤1到3\",{\"1\":{\"538\":1}}],[\"重复执行步骤2\",{\"1\":{\"493\":1}}],[\"重复查询相同的数据\",{\"0\":{\"523\":1}}],[\"重复上一步\",{\"1\":{\"487\":1}}],[\"重复相同的判断逻辑\",{\"1\":{\"459\":1}}],[\"重复的子字符串\",{\"0\":{\"389\":1}}],[\"重复步骤3\",{\"1\":{\"491\":1,\"492\":1}}],[\"重复步骤4\",{\"1\":{\"345\":2}}],[\"重复步骤2\",{\"1\":{\"344\":2,\"493\":1,\"657\":1}}],[\"重载和重写的区别\",{\"0\":{\"15\":1}}],[\"轻量级锁所适应的场景是线程交替执行同步块的场合\",{\"1\":{\"1362\":1}}],[\"轻量级锁\",{\"0\":{\"73\":1,\"1701\":1},\"1\":{\"1360\":1,\"1361\":1}}],[\"v表示当前map的值的类型\",{\"1\":{\"1495\":1}}],[\"v>\",{\"1\":{\"1423\":5,\"1426\":4,\"1427\":9,\"1430\":7,\"1431\":16,\"1475\":8,\"1495\":1}}],[\"vector\",{\"1\":{\"1416\":1}}],[\"very\",{\"1\":{\"1497\":1,\"1525\":1}}],[\"version此时为101\",{\"1\":{\"1375\":1}}],[\"version>\",{\"1\":{\"719\":2}}],[\"version\",{\"1\":{\"677\":1,\"1375\":5,\"1524\":2}}],[\"verbose\",{\"1\":{\"566\":3}}],[\"vstart\",{\"0\":{\"781\":1,\"784\":1}}],[\"v4\",{\"1\":{\"707\":1}}],[\"v1\",{\"1\":{\"570\":1,\"707\":3,\"708\":2,\"716\":3,\"717\":2}}],[\"v3\",{\"1\":{\"707\":2,\"716\":1}}],[\"v3是2\",{\"1\":{\"570\":1}}],[\"v3的值是2\",{\"1\":{\"570\":1}}],[\"v3的值都是2\",{\"1\":{\"570\":1}}],[\"v3的返回值分别是什么\",{\"1\":{\"570\":1}}],[\"v2的值是1\",{\"1\":{\"570\":1}}],[\"v2的值是2\",{\"1\":{\"570\":1}}],[\"v2是1\",{\"1\":{\"570\":1}}],[\"v2\",{\"1\":{\"570\":2,\"707\":2,\"708\":1,\"716\":2,\"717\":3,\"1859\":1}}],[\"video\",{\"1\":{\"1847\":1,\"1852\":1,\"1853\":1,\"1856\":1,\"1858\":1,\"1859\":1,\"1860\":1,\"1861\":1,\"1863\":2,\"1864\":1,\"1865\":2,\"1867\":1,\"1868\":1,\"1869\":1,\"1870\":2}}],[\"via\",{\"1\":{\"1357\":2,\"1474\":2,\"1496\":1,\"1497\":3}}],[\"viewresoler的典型实现\",{\"1\":{\"1534\":1}}],[\"viewed\",{\"1\":{\"1496\":1}}],[\"view机制与undo版本链对比机制\",{\"1\":{\"679\":1}}],[\"view机制详解\",{\"0\":{\"679\":1}}],[\"view做比对从而得到最终的快照结果\",{\"1\":{\"679\":1}}],[\"view的时候\",{\"1\":{\"571\":1}}],[\"view\",{\"1\":{\"571\":2,\"679\":1,\"800\":1,\"806\":1,\"1371\":1,\"1376\":1,\"1529\":1,\"1530\":1,\"1534\":2}}],[\"views\",{\"1\":{\"498\":5,\"1498\":1}}],[\"views最多的article\",{\"1\":{\"498\":1}}],[\"visitnode\",{\"1\":{\"302\":3}}],[\"vavr\",{\"1\":{\"1532\":2}}],[\"vavrdelegate\",{\"1\":{\"1532\":4}}],[\"vavrpresent\",{\"1\":{\"1532\":2}}],[\"variants\",{\"1\":{\"1500\":1}}],[\"variables\",{\"1\":{\"565\":4,\"568\":2,\"570\":1,\"669\":1,\"690\":1,\"695\":1}}],[\"variable\",{\"1\":{\"491\":4,\"565\":3,\"568\":1}}],[\"various\",{\"1\":{\"1493\":2,\"1498\":1}}],[\"var\",{\"1\":{\"565\":2,\"566\":4,\"761\":2}}],[\"varchar\",{\"1\":{\"472\":1,\"473\":1,\"475\":2,\"486\":1,\"490\":3,\"498\":2,\"503\":1,\"505\":3,\"556\":1,\"643\":3,\"647\":2,\"655\":2,\"667\":2,\"671\":1,\"672\":1}}],[\"valid\",{\"1\":{\"1494\":1,\"1497\":1,\"1498\":4,\"1500\":1}}],[\"validation\",{\"0\":{\"1226\":1},\"1\":{\"1524\":1}}],[\"validator接口设计\",{\"0\":{\"1222\":1}}],[\"validate\",{\"1\":{\"397\":3}}],[\"val两个字段都不是null才继续往下走\",{\"1\":{\"1431\":1}}],[\"val字段为空\",{\"1\":{\"1431\":1}}],[\"val\",{\"1\":{\"338\":4,\"361\":4,\"371\":3,\"392\":3,\"395\":4,\"397\":6,\"398\":6,\"400\":2,\"401\":1,\"402\":1,\"403\":2,\"404\":1,\"406\":4,\"409\":5,\"410\":5,\"411\":2,\"412\":3,\"1431\":5}}],[\"value有可能是bean对象\",{\"1\":{\"1525\":1}}],[\"value注解\",{\"1\":{\"1525\":1}}],[\"value注解的方法\",{\"1\":{\"1525\":1}}],[\"valued\",{\"1\":{\"1476\":2,\"1492\":1,\"1495\":1}}],[\"value的值\",{\"1\":{\"1431\":1}}],[\"value的字符集是utf8\",{\"1\":{\"505\":1}}],[\"value和\",{\"1\":{\"1356\":1}}],[\"value和dest指针指向内存值相等则会使得dest指针指向内存值变成exchange\",{\"1\":{\"1356\":1}}],[\"value变量作为返回值\",{\"1\":{\"1356\":1}}],[\"value变量\",{\"1\":{\"1356\":1}}],[\"value变量中\",{\"1\":{\"1356\":1}}],[\"value赋值给了exchange\",{\"1\":{\"1356\":1}}],[\"value存入eax寄存器\",{\"1\":{\"1356\":1}}],[\"value存储\",{\"1\":{\"1352\":1}}],[\"value中的运用\",{\"0\":{\"1313\":1}}],[\"value`\",{\"1\":{\"708\":1}}],[\"value除了是字符串还可以是数字\",{\"1\":{\"707\":1}}],[\"value2\",{\"1\":{\"707\":2,\"708\":1,\"710\":1,\"1475\":10}}],[\"value1\",{\"1\":{\"707\":2,\"708\":1,\"710\":1,\"1475\":10}}],[\"value形式保存\",{\"1\":{\"706\":1}}],[\"value数据库\",{\"1\":{\"701\":1}}],[\"value字段值更新为null\",{\"1\":{\"694\":1}}],[\"value字段值进行update操作\",{\"1\":{\"694\":1}}],[\"value表示成本常数对应的值\",{\"1\":{\"694\":1}}],[\"value=1\",{\"1\":{\"599\":2}}],[\"value=2\",{\"1\":{\"599\":1}}],[\"value是conn连接\",{\"1\":{\"1532\":1}}],[\"value是一段lamda表达式\",{\"1\":{\"1526\":1}}],[\"value是一个数字\",{\"1\":{\"598\":1}}],[\"value是查询的结果\",{\"1\":{\"456\":1}}],[\"value对极限\",{\"1\":{\"1423\":1}}],[\"value对的形式\",{\"1\":{\"456\":1}}],[\"value对应的配置项如何动态更新\",{\"0\":{\"241\":1}}],[\"values\",{\"1\":{\"380\":1,\"473\":1,\"482\":1,\"498\":5,\"505\":14,\"515\":5,\"537\":1,\"541\":2,\"550\":1,\"551\":1,\"556\":1,\"561\":5,\"570\":1,\"583\":1,\"584\":2,\"591\":6,\"596\":3,\"599\":1,\"605\":2,\"613\":1,\"615\":1,\"627\":1,\"628\":4,\"629\":1,\"631\":2,\"643\":3,\"647\":3,\"655\":4,\"660\":2,\"671\":4,\"672\":3,\"1478\":2,\"1484\":2,\"1485\":2,\"1495\":2,\"1496\":1,\"1497\":13,\"1500\":2,\"1524\":3}}],[\"valueof\",{\"1\":{\"380\":1,\"1524\":1}}],[\"value\",{\"0\":{\"1311\":1},\"1\":{\"311\":2,\"363\":3,\"388\":5,\"392\":1,\"397\":1,\"404\":1,\"411\":1,\"469\":1,\"491\":2,\"505\":3,\"565\":3,\"568\":1,\"695\":1,\"707\":9,\"708\":4,\"710\":6,\"715\":1,\"717\":1,\"720\":1,\"1356\":37,\"1357\":2,\"1361\":4,\"1378\":2,\"1380\":2,\"1386\":1,\"1423\":2,\"1426\":9,\"1427\":3,\"1430\":9,\"1431\":10,\"1475\":22,\"1485\":4,\"1492\":1,\"1495\":2,\"1497\":6,\"1498\":2,\"1500\":1,\"1515\":1,\"1517\":2,\"1522\":2,\"1525\":12,\"1532\":1,\"1853\":1}}],[\"v\",{\"1\":{\"317\":2,\"318\":2,\"319\":2,\"548\":4,\"566\":1,\"714\":1,\"1357\":3,\"1423\":5,\"1426\":5,\"1430\":5,\"1431\":9,\"1475\":8,\"1495\":8}}],[\"void>\",{\"1\":{\"1500\":1}}],[\"void\",{\"1\":{\"285\":1,\"288\":1,\"296\":1,\"302\":5,\"311\":1,\"317\":2,\"318\":2,\"319\":4,\"329\":4,\"365\":1,\"383\":1,\"384\":1,\"385\":2,\"392\":2,\"395\":1,\"399\":1,\"400\":1,\"403\":1,\"409\":3,\"411\":1,\"415\":1,\"417\":1,\"435\":3,\"719\":2,\"720\":1,\"1353\":1,\"1356\":1,\"1357\":1,\"1359\":6,\"1362\":1,\"1363\":1,\"1364\":2,\"1379\":2,\"1380\":4,\"1383\":1,\"1398\":1,\"1403\":2,\"1408\":4,\"1412\":1,\"1427\":1,\"1428\":3,\"1431\":1,\"1450\":1,\"1451\":3,\"1452\":12,\"1464\":1,\"1465\":1,\"1468\":5,\"1469\":2,\"1470\":6,\"1471\":6,\"1472\":17,\"1474\":4,\"1475\":6,\"1476\":9,\"1477\":5,\"1478\":1,\"1479\":1,\"1480\":5,\"1481\":2,\"1482\":5,\"1483\":2,\"1484\":15,\"1485\":4,\"1486\":11,\"1487\":8,\"1489\":3,\"1490\":6,\"1491\":1,\"1492\":1,\"1494\":5,\"1496\":6,\"1497\":10,\"1498\":2,\"1499\":5,\"1500\":7,\"1515\":2,\"1523\":1,\"1524\":3,\"1525\":1,\"1528\":2,\"1531\":4,\"1534\":2,\"1535\":1}}],[\"volatile型变量\",{\"0\":{\"1688\":1}}],[\"volatile语义中的内存屏障\",{\"0\":{\"1646\":1}}],[\"volatile\",{\"1\":{\"1354\":1,\"1356\":2,\"1357\":2,\"1431\":2}}],[\"volatile的内存语义总结\",{\"1\":{\"1351\":1}}],[\"volatile关键字的c++实现源码\",{\"1\":{\"1350\":1}}],[\"volatile能不能保证线程安全\",{\"0\":{\"63\":1}}],[\"volatile变量和atomic变量什么不同\",{\"0\":{\"61\":1}}],[\"volatile和synchronized有什么区别\",{\"0\":{\"60\":1}}],[\"vue\",{\"1\":{\"2\":2,\"8\":1}}],[\"vuepress\",{\"1\":{\"0\":1,\"1\":1,\"2\":1,\"3\":3,\"4\":2}}],[\"什么样的sql才会被记录到慢查询日志里面呢\",{\"1\":{\"565\":1}}],[\"什么情况下会使用到change\",{\"1\":{\"480\":1}}],[\"什么情况下堆内存会溢出\",{\"0\":{\"130\":1}}],[\"什么情况方法区会内存溢出\",{\"0\":{\"130\":1}}],[\"什么是可变的汇聚操作呢\",{\"1\":{\"1492\":1}}],[\"什么是可重入锁\",{\"0\":{\"74\":1}}],[\"什么是内部迭代呢\",{\"1\":{\"1488\":1}}],[\"什么是函数式接口\",{\"1\":{\"1470\":1}}],[\"什么是ioc\",{\"0\":{\"1075\":1}}],[\"什么是操作系统\",{\"0\":{\"772\":1}}],[\"什么是aof\",{\"0\":{\"729\":1}}],[\"什么是rdb\",{\"0\":{\"723\":1}}],[\"什么是mysql\",{\"1\":{\"678\":1}}],[\"什么是spring\",{\"0\":{\"1063\":1,\"1085\":1,\"1098\":1}}],[\"什么是sso\",{\"0\":{\"228\":1}}],[\"什么是stw\",{\"0\":{\"114\":1}}],[\"什么是jwt令牌\",{\"0\":{\"227\":1}}],[\"什么是oauth2\",{\"0\":{\"226\":1}}],[\"什么是csrf攻击\",{\"0\":{\"225\":1}}],[\"什么是callable和future\",{\"0\":{\"72\":1}}],[\"什么是认证和授权\",{\"0\":{\"223\":1}}],[\"什么是倒排索引\",{\"0\":{\"175\":1}}],[\"什么是间隙锁\",{\"0\":{\"159\":1}}],[\"什么是脏读\",{\"0\":{\"157\":1}}],[\"什么是缓存穿透\",{\"0\":{\"134\":1}}],[\"什么是三色标记算法\",{\"0\":{\"116\":1}}],[\"什么是gc\",{\"0\":{\"112\":1}}],[\"什么是双亲委派机制\",{\"0\":{\"106\":1}}],[\"什么是executors框架\",{\"0\":{\"85\":1}}],[\"什么是指令重排序\",{\"0\":{\"81\":1}}],[\"什么是乐观锁\",{\"0\":{\"75\":1}}],[\"什么是悲观锁\",{\"0\":{\"75\":1}}],[\"什么是阻塞队列\",{\"0\":{\"71\":1}}],[\"什么是线程安全\",{\"0\":{\"52\":1}}],[\"什么时候退化为链表\",{\"0\":{\"40\":1}}],[\"守护线程和用户线程的区别\",{\"0\":{\"51\":1}}],[\"ljava\",{\"1\":{\"1486\":4}}],[\"ltrim\",{\"1\":{\"708\":3}}],[\"lpop\",{\"1\":{\"708\":4}}],[\"lpushx失败\",{\"1\":{\"708\":1}}],[\"lpushx\",{\"1\":{\"708\":5}}],[\"lpush\",{\"1\":{\"708\":8}}],[\"llen\",{\"1\":{\"708\":3}}],[\"lrem\",{\"1\":{\"708\":4}}],[\"lrange\",{\"1\":{\"708\":14}}],[\"lru收回\",{\"1\":{\"705\":1}}],[\"lrucache\",{\"1\":{\"311\":2}}],[\"lru\",{\"0\":{\"309\":1},\"1\":{\"310\":2,\"806\":1}}],[\"lucene\",{\"1\":{\"1864\":2}}],[\"lucy\",{\"1\":{\"647\":1,\"655\":1,\"672\":1}}],[\"lua脚本\",{\"1\":{\"705\":1}}],[\"l7都满足\",{\"1\":{\"487\":1}}],[\"l7\",{\"1\":{\"487\":1}}],[\"l6\",{\"1\":{\"487\":1}}],[\"l5\",{\"1\":{\"487\":1}}],[\"l4\",{\"1\":{\"487\":1}}],[\"lset\",{\"1\":{\"708\":3}}],[\"lsn也会写到innodb的数据页中\",{\"1\":{\"588\":1}}],[\"lsn的值就会加上length\",{\"1\":{\"588\":1}}],[\"lsn是单调递增的\",{\"1\":{\"588\":1}}],[\"lsn\",{\"1\":{\"588\":1}}],[\"ls\",{\"1\":{\"467\":1}}],[\"large\",{\"1\":{\"1497\":1}}],[\"larger\",{\"1\":{\"1497\":1}}],[\"largest\",{\"1\":{\"566\":1}}],[\"largestvalues\",{\"1\":{\"404\":1}}],[\"largestrectanglearea\",{\"1\":{\"367\":1}}],[\"laziness\",{\"1\":{\"1497\":1}}],[\"lazy注解的作用\",{\"1\":{\"1526\":1}}],[\"lazy注解\",{\"1\":{\"1525\":1}}],[\"lazyinit\",{\"1\":{\"1509\":1}}],[\"lazy\",{\"1\":{\"1431\":1,\"1496\":1,\"1510\":1,\"1524\":1}}],[\"lambda$main$1\",{\"1\":{\"1496\":1}}],[\"lambda$main$0\",{\"1\":{\"1496\":2}}],[\"lambdatest$1\",{\"1\":{\"1469\":1}}],[\"lambdatest\",{\"1\":{\"1469\":7,\"1470\":6,\"1471\":1,\"1472\":1,\"1474\":2}}],[\"lambda表达式在大多数的场景下\",{\"1\":{\"1484\":1}}],[\"lambda表达式在简化代码上\",{\"1\":{\"1468\":1}}],[\"lambda表达式其实是一种更为通用的形式\",{\"1\":{\"1480\":1}}],[\"lambda表达式需要依赖于函数式接口这样一种特殊的形式\",{\"1\":{\"1472\":1}}],[\"lambda表达式是对象\",{\"1\":{\"1470\":1}}],[\"lambda表达式的类型是函数\",{\"1\":{\"1470\":1}}],[\"lambda表达式往往与stream相互配合\",{\"1\":{\"1470\":1}}],[\"lambda表达式和stream\",{\"0\":{\"1470\":1}}],[\"lambda表达式和匿名内部类\",{\"0\":{\"1469\":1}}],[\"lambda表达式就是一种全新的语法\",{\"1\":{\"1469\":1}}],[\"lambda表达式看起来特别像是java中匿名内部类的一种特殊写法\",{\"1\":{\"1469\":1}}],[\"lambda创建100000个花费的总毫秒值\",{\"1\":{\"1468\":1}}],[\"lambda\",{\"1\":{\"1468\":2,\"1471\":2,\"1482\":1,\"1496\":2}}],[\"later\",{\"1\":{\"1524\":1}}],[\"late\",{\"1\":{\"1497\":12,\"1498\":1}}],[\"latch\",{\"1\":{\"1367\":1}}],[\"latitude\",{\"1\":{\"713\":2}}],[\"latin1\",{\"1\":{\"561\":1}}],[\"language\",{\"1\":{\"1471\":2,\"1561\":1}}],[\"lang\",{\"1\":{\"1354\":1,\"1421\":1,\"1437\":5,\"1471\":6,\"1486\":4,\"1487\":1,\"1494\":1,\"1496\":4,\"1540\":2}}],[\"lastnamesbycity\",{\"1\":{\"1495\":1}}],[\"last指向入队元素\",{\"1\":{\"1380\":1}}],[\"last\",{\"1\":{\"566\":1,\"695\":1,\"725\":1,\"1380\":4,\"1495\":1,\"1500\":1,\"1524\":1}}],[\"layout\",{\"1\":{\"4\":1}}],[\"layouts\",{\"0\":{\"4\":1}}],[\"l++\",{\"1\":{\"360\":1,\"364\":1,\"428\":1}}],[\"l\",{\"1\":{\"360\":6,\"364\":4,\"428\":7,\"487\":1,\"505\":9,\"566\":3}}],[\"lookup注解的时候\",{\"1\":{\"1527\":1}}],[\"lookup注解的方法\",{\"1\":{\"1524\":1}}],[\"lookup注解有关\",{\"1\":{\"1524\":1}}],[\"lookup\",{\"1\":{\"1524\":1}}],[\"loop\",{\"0\":{\"538\":1,\"539\":1,\"540\":1},\"1\":{\"538\":1,\"539\":3,\"540\":7,\"660\":2,\"661\":1,\"692\":1}}],[\"low\",{\"1\":{\"1498\":1}}],[\"lowestscore\",{\"1\":{\"711\":2}}],[\"lowestcommonancestor\",{\"1\":{\"398\":3}}],[\"lotail\",{\"1\":{\"1427\":6}}],[\"lohead\",{\"1\":{\"1427\":3}}],[\"lombok\",{\"1\":{\"1356\":1}}],[\"loader\",{\"1\":{\"1540\":2}}],[\"loadclass\",{\"1\":{\"1540\":2}}],[\"loadbeandefinitions\",{\"1\":{\"1511\":1,\"1528\":1}}],[\"loadfactor=0\",{\"1\":{\"1428\":1}}],[\"loadfactor\",{\"1\":{\"1423\":1,\"1427\":2}}],[\"load\",{\"1\":{\"1350\":1,\"1352\":1,\"1427\":1,\"1431\":1}}],[\"lo\",{\"1\":{\"707\":1,\"1497\":4}}],[\"local\",{\"1\":{\"1545\":1}}],[\"localvariabletableparameternamediscoverer\",{\"1\":{\"1525\":1}}],[\"localhost\",{\"1\":{\"459\":1}}],[\"locations\",{\"1\":{\"1497\":2}}],[\"lock模式\",{\"1\":{\"1407\":1}}],[\"lockinterruptibly\",{\"1\":{\"1379\":2,\"1380\":2}}],[\"lockinterruptibly方法是可以被中断的\",{\"1\":{\"1372\":1}}],[\"lockeliminationtest\",{\"1\":{\"1364\":3}}],[\"locked\",{\"1\":{\"568\":1,\"1357\":1,\"1361\":1}}],[\"lock前缀指令会等待它之前所有的指令完成\",{\"1\":{\"1350\":1}}],[\"lock前缀指令具有类似内存屏障的功能\",{\"1\":{\"1350\":1}}],[\"lock前缀指令的作用\",{\"1\":{\"1350\":1}}],[\"locksupport\",{\"1\":{\"1354\":1,\"1356\":2}}],[\"locks\",{\"1\":{\"675\":1,\"1356\":1,\"1375\":1}}],[\"locks表里\",{\"1\":{\"634\":1}}],[\"lock是前后闭区间\",{\"1\":{\"585\":1}}],[\"lock\",{\"1\":{\"557\":1,\"566\":3,\"568\":1,\"574\":1,\"576\":1,\"577\":1,\"578\":1,\"579\":5,\"581\":2,\"585\":3,\"629\":3,\"671\":1,\"674\":1,\"675\":10,\"678\":1,\"1350\":2,\"1356\":3,\"1359\":4,\"1361\":1,\"1379\":12,\"1380\":2,\"1407\":1,\"1431\":1,\"1524\":1}}],[\"lock与synchronized有什么区别\",{\"0\":{\"70\":1}}],[\"lost\",{\"1\":{\"455\":1,\"618\":1,\"1431\":1}}],[\"longs\",{\"1\":{\"1500\":2}}],[\"longstream\",{\"1\":{\"1496\":2}}],[\"longpipeline\",{\"1\":{\"1498\":1}}],[\"longpredicate\",{\"1\":{\"1478\":1}}],[\"long>\",{\"1\":{\"1490\":1}}],[\"longaccumulate的流程图如下\",{\"1\":{\"1357\":1}}],[\"longaccumulate\",{\"1\":{\"1357\":1}}],[\"longaccumulator\",{\"1\":{\"1357\":1}}],[\"longadder内部有一个base变量\",{\"1\":{\"1357\":1}}],[\"longadder和doubleadder在高并发的情况下\",{\"1\":{\"1357\":1}}],[\"longadder\",{\"1\":{\"1357\":2}}],[\"longitude\",{\"1\":{\"713\":1}}],[\"longitud\",{\"1\":{\"713\":1}}],[\"longtext\",{\"1\":{\"667\":1}}],[\"longblob\",{\"1\":{\"667\":1}}],[\"longeststringlengthstartingwitha\",{\"1\":{\"1500\":1}}],[\"longestpalindrome\",{\"1\":{\"428\":1}}],[\"longestcommonsubsequence\",{\"1\":{\"427\":1}}],[\"long\",{\"1\":{\"397\":2,\"438\":3,\"483\":1,\"565\":5,\"806\":8,\"1353\":1,\"1356\":1,\"1357\":3,\"1364\":2,\"1378\":2,\"1403\":1,\"1431\":4,\"1468\":6,\"1489\":3,\"1490\":1,\"1491\":1,\"1494\":1,\"1497\":10,\"1499\":1,\"1500\":2,\"1540\":2}}],[\"logger\",{\"1\":{\"1524\":7,\"1525\":6,\"1528\":2,\"1532\":2}}],[\"logging\",{\"1\":{\"461\":1,\"698\":1}}],[\"logic\",{\"1\":{\"1492\":1}}],[\"logically\",{\"1\":{\"1476\":4}}],[\"logical\",{\"1\":{\"1476\":12}}],[\"log4j在内的很多知名项目都应用了disruptor以获取高性能\",{\"1\":{\"1396\":1}}],[\"log归档\",{\"0\":{\"653\":1}}],[\"log恢复重启之前的值\",{\"1\":{\"627\":1}}],[\"log中\",{\"1\":{\"627\":1}}],[\"log和bin\",{\"1\":{\"621\":1}}],[\"log和binlog有一个共同的字段叫做xid\",{\"1\":{\"633\":1}}],[\"log和binlog有以下区别\",{\"1\":{\"462\":1}}],[\"log和binlog这两个统计信息\",{\"1\":{\"616\":1}}],[\"log和binlog中的事务\",{\"1\":{\"609\":1}}],[\"log和binlog都可以用于表示事务的提交状态\",{\"1\":{\"464\":1}}],[\"log和binlog时两个独立的逻辑\",{\"1\":{\"464\":1}}],[\"log对应的是event\",{\"1\":{\"616\":1}}],[\"log里\",{\"1\":{\"616\":1}}],[\"log里读了多少字节\",{\"1\":{\"616\":1}}],[\"log里面\",{\"1\":{\"461\":1,\"463\":1}}],[\"log操作的时间统计\",{\"1\":{\"616\":1}}],[\"log组提交\",{\"1\":{\"601\":1}}],[\"log其实有三种格式\",{\"1\":{\"591\":1}}],[\"log做fsync的时间拖到了步骤1之后\",{\"1\":{\"588\":1}}],[\"log在commit的时候就不需要fsync了\",{\"1\":{\"588\":1}}],[\"log在prepaer阶段就要持久化一次\",{\"1\":{\"588\":1}}],[\"log到buffer中\",{\"1\":{\"588\":1}}],[\"log也会被后台线程一起持久化到磁盘\",{\"1\":{\"588\":1}}],[\"log也就是直接写在redo\",{\"1\":{\"588\":1}}],[\"log写到文件系统的page\",{\"1\":{\"588\":1}}],[\"log写入到磁盘中\",{\"1\":{\"588\":1}}],[\"log写入到page\",{\"1\":{\"588\":1}}],[\"log写完之后\",{\"1\":{\"464\":1}}],[\"log写完\",{\"1\":{\"464\":1}}],[\"log直接持久化到磁盘\",{\"1\":{\"588\":1}}],[\"log留在redo\",{\"1\":{\"588\":1}}],[\"log的时间监控\",{\"1\":{\"616\":1}}],[\"log的各个字段完全相同\",{\"1\":{\"616\":1}}],[\"log的\",{\"1\":{\"615\":1}}],[\"log的两阶段提交中\",{\"1\":{\"602\":1}}],[\"log的三种格式\",{\"0\":{\"591\":1}}],[\"log的三种状态有关\",{\"1\":{\"588\":1}}],[\"log的效果那么好\",{\"1\":{\"588\":1}}],[\"log的一个个写入点\",{\"1\":{\"588\":1}}],[\"log的写入时间\",{\"1\":{\"616\":1}}],[\"log的写入策略\",{\"1\":{\"588\":1}}],[\"log的写入机制\",{\"0\":{\"587\":1,\"588\":1}}],[\"log的写入拆成了两个步骤\",{\"1\":{\"463\":1}}],[\"log会先写入到redo\",{\"1\":{\"588\":1}}],[\"logs\",{\"1\":{\"566\":1}}],[\"logstash与filebeat详解以及efk整合\",{\"0\":{\"450\":1}}],[\"log=on\",{\"1\":{\"565\":1}}],[\"log2m\",{\"1\":{\"538\":1}}],[\"log2n\",{\"1\":{\"330\":1}}],[\"log主要节省的是随机写磁盘的io消耗\",{\"1\":{\"482\":1}}],[\"log还没写\",{\"1\":{\"464\":1}}],[\"log后写binlog\",{\"1\":{\"464\":1}}],[\"log再写binlog\",{\"1\":{\"464\":1}}],[\"log改成提交\",{\"1\":{\"463\":1}}],[\"log处于prepare状态\",{\"1\":{\"463\":1}}],[\"log是两个比较容易混淆的概念\",{\"1\":{\"482\":1}}],[\"log是循环写的\",{\"1\":{\"462\":1}}],[\"log是物理日志\",{\"1\":{\"462\":1}}],[\"log是innodb引擎所特有的\",{\"1\":{\"462\":1}}],[\"log是innodb引擎特有的日志\",{\"1\":{\"462\":1}}],[\"log是固定大小的\",{\"1\":{\"461\":1}}],[\"log\",{\"0\":{\"482\":1},\"1\":{\"460\":1,\"461\":1,\"462\":1,\"463\":1,\"464\":1,\"482\":3,\"483\":1,\"557\":1,\"565\":9,\"566\":6,\"588\":27,\"590\":1,\"592\":1,\"594\":1,\"597\":1,\"602\":1,\"604\":10,\"605\":2,\"609\":8,\"616\":2,\"621\":1,\"1356\":7}}],[\"logn\",{\"1\":{\"304\":1,\"340\":1,\"341\":1,\"353\":1,\"470\":2,\"471\":3}}],[\"logutil\",{\"1\":{\"302\":3}}],[\"let\",{\"1\":{\"1524\":1}}],[\"lettuce\",{\"1\":{\"720\":2}}],[\"lettercombinations\",{\"1\":{\"400\":1}}],[\"lexicographic\",{\"1\":{\"1491\":1}}],[\"leaf\",{\"1\":{\"1497\":1,\"1500\":1}}],[\"lead\",{\"1\":{\"1532\":2}}],[\"leader\",{\"1\":{\"743\":1,\"761\":1}}],[\"leading\",{\"1\":{\"385\":1}}],[\"least\",{\"1\":{\"566\":1,\"1524\":1}}],[\"len中\",{\"1\":{\"515\":2}}],[\"len计算规则\",{\"1\":{\"467\":1}}],[\"len是根据表定义计算而得\",{\"1\":{\"467\":1}}],[\"len显示的值为索引字段的最大可能长度\",{\"1\":{\"467\":1}}],[\"len\",{\"1\":{\"428\":8,\"466\":1,\"467\":7,\"498\":1,\"527\":2}}],[\"length取余\",{\"1\":{\"1425\":1}}],[\"length的二进制就是一个1后面n个0\",{\"1\":{\"1425\":1}}],[\"length这两种运算结果式等价的\",{\"1\":{\"1425\":1}}],[\"lengthfieldbasedframedecoder\",{\"0\":{\"889\":1}}],[\"length可以聚簇索引的页面数量\",{\"1\":{\"685\":1}}],[\"length\",{\"1\":{\"302\":6,\"305\":1,\"317\":2,\"318\":2,\"319\":3,\"329\":3,\"359\":1,\"360\":1,\"361\":2,\"362\":3,\"363\":2,\"365\":3,\"366\":6,\"367\":3,\"368\":4,\"380\":1,\"383\":2,\"384\":1,\"385\":2,\"386\":2,\"388\":2,\"389\":1,\"393\":1,\"399\":1,\"400\":3,\"409\":2,\"415\":1,\"419\":1,\"421\":1,\"422\":2,\"427\":2,\"428\":1,\"430\":2,\"431\":4,\"435\":9,\"443\":2,\"492\":1,\"558\":3,\"657\":7,\"685\":2,\"690\":1,\"692\":2,\"1357\":1,\"1362\":1,\"1379\":3,\"1425\":5,\"1426\":2,\"1427\":2,\"1430\":2,\"1431\":5,\"1451\":2,\"1452\":2,\"1476\":1,\"1478\":2,\"1484\":1,\"1485\":2,\"1489\":8,\"1491\":17,\"1497\":3,\"1500\":1,\"1524\":1,\"1525\":1,\"1531\":1}}],[\"lesser\",{\"1\":{\"1478\":3}}],[\"less\",{\"1\":{\"317\":2,\"318\":2,\"319\":3,\"561\":4,\"1567\":1}}],[\"leftsssymmetric\",{\"1\":{\"406\":2}}],[\"left和右子节点root\",{\"1\":{\"398\":1}}],[\"left++\",{\"1\":{\"362\":1,\"363\":1,\"366\":3,\"383\":1}}],[\"left\",{\"1\":{\"296\":4,\"305\":4,\"315\":2,\"338\":2,\"362\":5,\"363\":3,\"366\":10,\"367\":5,\"383\":4,\"395\":6,\"396\":3,\"397\":2,\"398\":4,\"401\":4,\"402\":4,\"403\":5,\"404\":4,\"405\":4,\"406\":20,\"407\":1,\"408\":5,\"409\":7,\"410\":17,\"411\":6,\"412\":2,\"415\":5,\"439\":6,\"440\":5,\"443\":5,\"487\":4,\"508\":1,\"566\":1,\"646\":1,\"708\":1,\"1485\":3,\"1492\":3,\"1495\":9}}],[\"level来控制到底是不是用这些启发式规则\",{\"1\":{\"693\":1}}],[\"levelorderbottom\",{\"1\":{\"402\":1}}],[\"levelorder\",{\"1\":{\"401\":1}}],[\"level\",{\"1\":{\"285\":5,\"467\":3,\"1498\":1}}],[\"leetcode热题100\",{\"1\":{\"1850\":1}}],[\"leetcode\",{\"0\":{\"281\":1,\"1848\":1},\"1\":{\"1844\":1,\"1850\":1}}],[\"liaoxuefeng\",{\"1\":{\"1847\":1,\"1859\":1}}],[\"lifecycle\",{\"1\":{\"1524\":1}}],[\"lifo\",{\"1\":{\"1387\":1}}],[\"lisi=90\",{\"1\":{\"1490\":1}}],[\"lisi=1\",{\"1\":{\"1490\":1}}],[\"lisi\",{\"1\":{\"1475\":1,\"1480\":2,\"1481\":2,\"1482\":1,\"1486\":1,\"1490\":1,\"1492\":1}}],[\"list等类型\",{\"1\":{\"1525\":1}}],[\"listener\",{\"1\":{\"1524\":1,\"1856\":1}}],[\"listablebeanfactory\",{\"1\":{\"1513\":1,\"1514\":1}}],[\"lists\",{\"1\":{\"1492\":1}}],[\"list1\",{\"1\":{\"1486\":2}}],[\"list2\",{\"1\":{\"1486\":4}}],[\"list这样一个顶层的集合增加了排序的方法\",{\"1\":{\"1484\":1}}],[\"listiterator\",{\"1\":{\"1480\":1}}],[\"listiterator<e>\",{\"1\":{\"1480\":1}}],[\"list实际上是一个链表\",{\"1\":{\"708\":1}}],[\"list不存在\",{\"1\":{\"708\":1}}],[\"list中是允许value重复的\",{\"1\":{\"708\":1}}],[\"listnodes\",{\"1\":{\"373\":2}}],[\"listnode\",{\"1\":{\"371\":6,\"372\":5,\"373\":4,\"375\":6,\"376\":5,\"377\":6}}],[\"list<object>\",{\"1\":{\"1531\":3}}],[\"list<injectionmetadata\",{\"1\":{\"1525\":2}}],[\"list<integer>\",{\"1\":{\"366\":1,\"395\":7,\"401\":1,\"402\":1,\"403\":5,\"404\":2,\"409\":2,\"1476\":7,\"1484\":1,\"1486\":1}}],[\"list<t>就表示根据分类依据k分类之后的列表集合\",{\"1\":{\"1495\":1}}],[\"list<t>>>\",{\"1\":{\"1490\":1,\"1495\":2}}],[\"list<t>>\",{\"1\":{\"1485\":1,\"1495\":1}}],[\"list<employee>>\",{\"1\":{\"1493\":1}}],[\"list<person>>\",{\"1\":{\"1475\":1}}],[\"list<person>\",{\"1\":{\"1475\":7}}],[\"list<future<integer>>\",{\"1\":{\"1394\":1}}],[\"list<student>>\",{\"1\":{\"1493\":1}}],[\"list<student>\",{\"1\":{\"1480\":2,\"1481\":1,\"1482\":1,\"1490\":1,\"1492\":2}}],[\"list<string>\",{\"1\":{\"400\":3,\"409\":9,\"415\":3,\"417\":3,\"1470\":6,\"1471\":1,\"1472\":1,\"1474\":2,\"1479\":1,\"1482\":1,\"1484\":1,\"1485\":4,\"1486\":5,\"1487\":2,\"1489\":3,\"1491\":1,\"1493\":1,\"1494\":2,\"1495\":1,\"1496\":1,\"1497\":1,\"1524\":1}}],[\"list<string>>\",{\"1\":{\"380\":1}}],[\"list<sqlnode>\",{\"1\":{\"806\":1}}],[\"list<list<string>>\",{\"1\":{\"380\":1,\"417\":3}}],[\"list<list<integer>>\",{\"1\":{\"366\":4,\"399\":3,\"401\":2,\"402\":2,\"426\":1}}],[\"list\",{\"0\":{\"32\":1,\"708\":1,\"1352\":1,\"1418\":1},\"1\":{\"395\":3,\"401\":3,\"402\":3,\"489\":1,\"706\":1,\"708\":2,\"709\":1,\"806\":2,\"1416\":1,\"1470\":13,\"1471\":2,\"1472\":2,\"1474\":4,\"1476\":23,\"1479\":2,\"1484\":4,\"1485\":4,\"1486\":9,\"1487\":5,\"1488\":5,\"1489\":9,\"1491\":15,\"1492\":1,\"1493\":2,\"1494\":4,\"1495\":3,\"1496\":4,\"1497\":2,\"1499\":3}}],[\"lilei\",{\"1\":{\"647\":1,\"655\":4,\"672\":1}}],[\"libraries\",{\"1\":{\"1492\":1}}],[\"library\",{\"1\":{\"609\":1,\"616\":1,\"1492\":1,\"1498\":1,\"1499\":1}}],[\"lib\",{\"1\":{\"565\":2,\"566\":4}}],[\"limit的值太小导致的\",{\"1\":{\"690\":1}}],[\"limit的值的话\",{\"1\":{\"690\":1}}],[\"limit的默认值为10\",{\"1\":{\"690\":1}}],[\"limit参数使用的默认值是1024\",{\"1\":{\"562\":1}}],[\"limit\",{\"1\":{\"484\":1,\"485\":6,\"490\":1,\"491\":1,\"498\":3,\"530\":1,\"548\":3,\"551\":1,\"553\":1,\"556\":1,\"557\":1,\"558\":2,\"559\":5,\"568\":3,\"591\":1,\"657\":2,\"659\":5,\"690\":1,\"711\":2,\"1486\":1,\"1487\":10}}],[\"limit语句会扫描全表吗\",{\"0\":{\"169\":1}}],[\"liked\",{\"1\":{\"1850\":1}}],[\"likelihood\",{\"1\":{\"1497\":1}}],[\"like百分加右边\",{\"0\":{\"512\":1},\"1\":{\"512\":1}}],[\"like以通配符开头\",{\"1\":{\"506\":1}}],[\"like\",{\"1\":{\"476\":1,\"477\":1,\"512\":13,\"514\":4,\"537\":1,\"541\":1,\"546\":1,\"550\":1,\"565\":6,\"568\":2,\"570\":1,\"616\":1,\"640\":1,\"655\":1,\"660\":1,\"669\":1,\"675\":1,\"681\":1,\"684\":2,\"685\":1,\"690\":3,\"694\":1,\"695\":2,\"1485\":1,\"1496\":1,\"1497\":1,\"1524\":1}}],[\"lines返回对象\",{\"1\":{\"1496\":1}}],[\"lines\",{\"1\":{\"1496\":1}}],[\"linkplain\",{\"1\":{\"1471\":2}}],[\"link\",{\"1\":{\"800\":1,\"806\":1,\"1356\":1,\"1371\":1,\"1376\":1,\"1474\":2,\"1475\":4,\"1476\":6,\"1477\":1,\"1478\":4,\"1485\":1,\"1529\":1,\"1530\":1,\"1534\":1}}],[\"linked\",{\"1\":{\"1499\":3,\"1500\":1}}],[\"linkedorconsumed\",{\"1\":{\"1499\":4,\"1500\":2}}],[\"linkedblockingdeque的总结\",{\"1\":{\"1381\":1}}],[\"linkedblockingdeque\",{\"0\":{\"1381\":1},\"1\":{\"1378\":1}}],[\"linkedblockingqueue的总结\",{\"1\":{\"1380\":1}}],[\"linkedblockingqueue<>\",{\"1\":{\"1380\":2}}],[\"linkedblockingqueue使用\",{\"1\":{\"1380\":1}}],[\"linkedblockingqueue采用两把锁的锁分离技术实现入队出队互不阻塞\",{\"1\":{\"1380\":1}}],[\"linkedblockingqueue内存由单链表实现\",{\"1\":{\"1380\":1}}],[\"linkedblockingqueue是一个基于链表实现的阻塞队列\",{\"1\":{\"1380\":1}}],[\"linkedblockingqueue\",{\"0\":{\"1380\":1},\"1\":{\"1378\":2,\"1380\":2}}],[\"linkedtransferqueue\",{\"0\":{\"1384\":1},\"1\":{\"1378\":1}}],[\"linkedhashset<>\",{\"1\":{\"1524\":3,\"1525\":1}}],[\"linkedhashset<listnode>\",{\"1\":{\"373\":1}}],[\"linkedhashmap保存了记录的插入顺序\",{\"1\":{\"1421\":1}}],[\"linkedhashmap\",{\"1\":{\"1421\":1}}],[\"linkedhashmap<integer\",{\"1\":{\"311\":1}}],[\"linkedlist源码分析\",{\"0\":{\"1420\":1}}],[\"linkedlist是双向链表\",{\"1\":{\"1352\":1}}],[\"linkedlist<string>\",{\"1\":{\"1486\":1}}],[\"linkedlist<>\",{\"1\":{\"302\":1,\"366\":2,\"386\":2,\"392\":2,\"396\":1,\"397\":1,\"399\":1,\"401\":1,\"402\":1,\"403\":1,\"404\":1,\"411\":1,\"415\":1}}],[\"linkedlist<trienode>\",{\"1\":{\"302\":1}}],[\"linkedlist\",{\"1\":{\"302\":1,\"310\":1,\"1416\":1,\"1486\":1,\"1495\":1}}],[\"linux内核之旅\",{\"1\":{\"1844\":1}}],[\"linux提供的零拷贝技术\",{\"1\":{\"1463\":1}}],[\"linux系统sendfile拷贝流程\",{\"0\":{\"1459\":1}}],[\"linux下的异步io其实用的很少\",{\"1\":{\"1443\":1}}],[\"linux下\",{\"1\":{\"1441\":1}}],[\"linux网络编程io模型\",{\"0\":{\"1439\":1}}],[\"linux操作系统有以下四种io模型的方案\",{\"1\":{\"1438\":1}}],[\"linux这样的操作系统\",{\"1\":{\"1438\":1}}],[\"linux\",{\"0\":{\"1461\":1},\"1\":{\"740\":1,\"1356\":1,\"1438\":1,\"1459\":1,\"1460\":2,\"1461\":3,\"1844\":1,\"1865\":1}}],[\"linux命令在线查询\",{\"1\":{\"1865\":1}}],[\"linux命令\",{\"0\":{\"261\":1}}],[\"linsert\",{\"1\":{\"708\":2}}],[\"lindex\",{\"1\":{\"708\":4}}],[\"深度大于0说明有中间操作\",{\"1\":{\"1500\":1}}],[\"深度加1\",{\"1\":{\"1499\":1}}],[\"深度优先遍历的终止条件\",{\"1\":{\"435\":1}}],[\"深度优先具体指的就是\",{\"1\":{\"295\":1}}],[\"深度优先搜索\",{\"0\":{\"294\":1}}],[\"深入理解\",{\"1\":{\"1870\":1}}],[\"深入理解git\",{\"1\":{\"1844\":1}}],[\"深入理解java8\",{\"1\":{\"1844\":1}}],[\"深入理解java线程\",{\"0\":{\"1354\":1}}],[\"深入理解jvm\",{\"0\":{\"1574\":1},\"1\":{\"1844\":1}}],[\"深入理解netty\",{\"0\":{\"808\":1},\"1\":{\"1844\":1}}],[\"深拷贝和浅拷贝的区别\",{\"0\":{\"20\":1}}],[\"深圳\",{\"1\":{\"9\":1}}],[\"封装\",{\"0\":{\"16\":1}}],[\"和dubbo\",{\"1\":{\"1868\":1}}],[\"和dest地址所存的值是否相等\",{\"1\":{\"1356\":1}}],[\"和容器\",{\"1\":{\"1561\":1}}],[\"和一个结果类型\",{\"1\":{\"1500\":1}}],[\"和cancellationrequested方法都会链接起来\",{\"1\":{\"1500\":1}}],[\"和condition来实现一组线程的阻塞唤醒的\",{\"1\":{\"1373\":1}}],[\"和count\",{\"1\":{\"536\":1,\"663\":1}}],[\"和spliterator\",{\"1\":{\"1496\":1,\"1497\":1}}],[\"和select函数一样\",{\"1\":{\"1447\":1}}],[\"和产生的结果r1和r2\",{\"1\":{\"1492\":1}}],[\"和associativity\",{\"1\":{\"1492\":1}}],[\"和allof用于支持多个completablefuture并行执行\",{\"1\":{\"1395\":1}}],[\"和transfer\",{\"1\":{\"1431\":1}}],[\"和text2​\",{\"1\":{\"427\":1}}],[\"和公平的锁获取方式\",{\"1\":{\"1375\":1}}],[\"和对象无关\",{\"1\":{\"1362\":1}}],[\"和对其填充\",{\"1\":{\"1361\":1}}],[\"和kqueue\",{\"1\":{\"740\":1}}],[\"和rpoplpush功能相同\",{\"1\":{\"708\":1}}],[\"和roll\",{\"1\":{\"679\":1}}],[\"和order\",{\"1\":{\"691\":1}}],[\"和offer\",{\"1\":{\"354\":1}}],[\"和连接查询相关的数据量\",{\"1\":{\"690\":1}}],[\"和已创建的最大事务id\",{\"1\":{\"679\":1}}],[\"和for\",{\"1\":{\"674\":1}}],[\"和for循环一样\",{\"1\":{\"404\":1}}],[\"和悲观锁\",{\"1\":{\"670\":1}}],[\"和从库b的gtid集合是一样的\",{\"1\":{\"605\":1}}],[\"和b\",{\"1\":{\"604\":1}}],[\"和binlog\",{\"1\":{\"460\":1}}],[\"和修改后各个字段的值\",{\"1\":{\"599\":1}}],[\"和主库a的\",{\"1\":{\"596\":1}}],[\"和主键id\",{\"1\":{\"492\":1}}],[\"和更新类事务的提交语句都会被阻塞\",{\"1\":{\"574\":1}}],[\"和串行化\",{\"1\":{\"570\":1}}],[\"和min\",{\"1\":{\"559\":1}}],[\"和q\",{\"1\":{\"398\":1}}],[\"和poll\",{\"1\":{\"354\":1}}],[\"和peek\",{\"1\":{\"354\":1}}],[\"和普通令牌有什么区别\",{\"0\":{\"227\":1}}],[\"和exsits优化\",{\"1\":{\"662\":1}}],[\"和execute\",{\"0\":{\"84\":1}}],[\"和eventloop什么关系\",{\"0\":{\"213\":1}}],[\"和$\",{\"0\":{\"199\":1}}],[\"和\",{\"0\":{\"13\":1,\"17\":1,\"221\":1,\"732\":1},\"1\":{\"307\":1,\"428\":1,\"467\":2,\"515\":1,\"561\":2,\"584\":1,\"602\":1,\"622\":1,\"669\":1,\"707\":1,\"711\":1,\"715\":1,\"733\":1,\"1356\":1,\"1360\":1,\"1442\":1,\"1461\":1,\"1472\":1,\"1852\":2,\"1857\":2}}],[\"杭州\",{\"1\":{\"9\":1,\"490\":2,\"491\":4,\"492\":2,\"493\":5,\"558\":1}}],[\"北京\",{\"1\":{\"9\":1}}],[\"⭐⭐\",{\"1\":{\"8\":2}}],[\"⭐⭐⭐\",{\"1\":{\"8\":2}}],[\"⭐⭐⭐⭐⭐\",{\"1\":{\"8\":1}}],[\"jconsole\",{\"0\":{\"1652\":1}}],[\"jvisualvm\",{\"0\":{\"1651\":1}}],[\"jvm教程\",{\"1\":{\"1870\":1}}],[\"jvm类加载器\",{\"0\":{\"1569\":1}}],[\"jvm类加载机制\",{\"0\":{\"1540\":1}}],[\"jvm如何调用java方法\",{\"0\":{\"1554\":1}}],[\"jvm常量池\",{\"0\":{\"1550\":1}}],[\"jvm调优工具\",{\"0\":{\"1549\":1}}],[\"jvm对象创建与内存分配机制深度剖析\",{\"0\":{\"1542\":1}}],[\"jvm对synchronized做了如下优化\",{\"1\":{\"1366\":1}}],[\"jvm参数设置\",{\"1\":{\"1541\":1}}],[\"jvm参数有哪些\",{\"0\":{\"127\":1}}],[\"jvm整体架构及内存模型\",{\"1\":{\"1541\":1}}],[\"jvm内存模型\",{\"0\":{\"1541\":1}}],[\"jvm会默认当前类产生了严重的问题\",{\"1\":{\"1362\":1}}],[\"jvm会认为不该偏向\",{\"1\":{\"1362\":1}}],[\"jvm就认为该class的使用场景存在多线程竞争\",{\"1\":{\"1362\":1}}],[\"jvm就认为该class的偏向锁有问题\",{\"1\":{\"1362\":1}}],[\"jvm就需要等到安全点时\",{\"1\":{\"1362\":1}}],[\"jvm默认延时加载偏向锁\",{\"1\":{\"1362\":1}}],[\"jvm启动时会进行一系列的复杂活动\",{\"1\":{\"1362\":1}}],[\"jvm利用storeload\",{\"1\":{\"1350\":1}}],[\"jvm层面\",{\"1\":{\"1347\":1}}],[\"jvm有哪些垃圾回收器\",{\"0\":{\"115\":1}}],[\"jvm有哪些垃圾回收算法\",{\"0\":{\"113\":1}}],[\"jvm\",{\"0\":{\"13\":1,\"118\":1,\"1539\":1},\"1\":{\"1870\":2}}],[\"jfr\",{\"1\":{\"1524\":1}}],[\"jframe\",{\"1\":{\"1468\":18}}],[\"jycinterceptor\",{\"1\":{\"1534\":1}}],[\"jyc这个包下面所有的类\",{\"1\":{\"1522\":1}}],[\"jycfactorybean\",{\"1\":{\"1521\":1}}],[\"jyc\",{\"1\":{\"1512\":1,\"1522\":2,\"1523\":1}}],[\"jycoder\",{\"1\":{\"10\":1,\"1423\":2}}],[\"jls\",{\"1\":{\"1471\":3}}],[\"jlong\",{\"1\":{\"1356\":1}}],[\"jbutton\",{\"1\":{\"1468\":10}}],[\"jboolean\",{\"1\":{\"1356\":1}}],[\"juc下的队列大部分采用reentrantlock锁的方式保证线程安全\",{\"1\":{\"1396\":1}}],[\"juc包中的大多数同步器实现都是围绕着共同的基础行为\",{\"1\":{\"1367\":1}}],[\"just\",{\"1\":{\"566\":1,\"1431\":1,\"1500\":1,\"1567\":1}}],[\"jobject\",{\"1\":{\"1356\":2}}],[\"joined\",{\"1\":{\"1493\":1}}],[\"joining还有一个重载的方法\",{\"1\":{\"1495\":1}}],[\"joining方法与之前的方法不同的是\",{\"1\":{\"1495\":1}}],[\"joining\",{\"1\":{\"1486\":1,\"1493\":4,\"1495\":2}}],[\"join实现\",{\"1\":{\"1407\":1}}],[\"join的性能\",{\"1\":{\"1387\":1}}],[\"join框架时\",{\"1\":{\"1387\":1}}],[\"join框架的核心是forkjoinpool类\",{\"1\":{\"1387\":1}}],[\"join框架\",{\"1\":{\"1387\":1}}],[\"joinpointidentification\",{\"1\":{\"1532\":3}}],[\"joinpoint执行动作接口\",{\"0\":{\"949\":1}}],[\"joinpoint条件接口\",{\"0\":{\"945\":1}}],[\"join关联查询优化\",{\"0\":{\"660\":1}}],[\"join比较过程中\",{\"1\":{\"544\":1}}],[\"join和block\",{\"1\":{\"540\":1}}],[\"join算法是相同的\",{\"1\":{\"540\":1}}],[\"join算法\",{\"1\":{\"539\":1,\"540\":4,\"661\":1}}],[\"join过程用上了这个索引\",{\"1\":{\"538\":1}}],[\"join可以让mysql使用固定的连接方式执行查询\",{\"1\":{\"538\":1}}],[\"join语句的优化\",{\"0\":{\"537\":1},\"1\":{\"501\":1}}],[\"join\",{\"0\":{\"538\":1,\"539\":1,\"540\":1,\"545\":1},\"1\":{\"458\":2,\"467\":1,\"521\":2,\"531\":2,\"538\":2,\"539\":3,\"540\":2,\"542\":1,\"544\":3,\"546\":1,\"555\":1,\"566\":1,\"646\":1,\"651\":3,\"656\":6,\"657\":4,\"659\":1,\"660\":2,\"661\":2,\"662\":3,\"690\":2,\"691\":5,\"692\":6,\"1354\":1,\"1452\":2}}],[\"jnihandles\",{\"1\":{\"1356\":1}}],[\"jnienv\",{\"1\":{\"1356\":1}}],[\"jndi\",{\"0\":{\"1504\":1},\"1\":{\"280\":1,\"1504\":1}}],[\"jmx\",{\"0\":{\"1503\":1},\"1\":{\"1503\":1}}],[\"jmm的内存可见性保证\",{\"1\":{\"1351\":1}}],[\"jmm是围绕原子性\",{\"1\":{\"1350\":1}}],[\"jmm描述的是一种抽象的概念\",{\"1\":{\"1350\":1}}],[\"jmm规范了java虚拟机与计算机内存是如何协同工作的\",{\"1\":{\"1350\":1}}],[\"jmm即java多线程通信模型\",{\"1\":{\"1347\":1}}],[\"jmm实现原理\",{\"0\":{\"1347\":1}}],[\"jms\",{\"0\":{\"1502\":1},\"1\":{\"280\":1}}],[\"jint\",{\"1\":{\"1356\":11}}],[\"jib\",{\"0\":{\"1043\":1}}],[\"jiyongchao\",{\"1\":{\"609\":1,\"616\":1,\"1482\":1}}],[\"jedis是redis官方推荐使用的java连接redis的客户端\",{\"1\":{\"719\":1}}],[\"jedis\",{\"0\":{\"719\":1},\"1\":{\"719\":12,\"720\":2}}],[\"j−1\",{\"1\":{\"426\":1,\"427\":4,\"428\":1}}],[\"jkl\",{\"1\":{\"400\":1}}],[\"j++\",{\"1\":{\"317\":1,\"318\":1,\"329\":1,\"366\":1,\"368\":1,\"385\":4,\"422\":1,\"425\":2,\"426\":1,\"427\":1,\"1497\":2}}],[\"j\",{\"1\":{\"317\":7,\"318\":7,\"319\":27,\"329\":3,\"366\":5,\"368\":10,\"385\":20,\"422\":2,\"425\":8,\"426\":11,\"427\":14,\"428\":20,\"714\":2,\"1427\":7,\"1430\":3,\"1497\":1}}],[\"jta\",{\"1\":{\"280\":1}}],[\"jts\",{\"1\":{\"280\":1}}],[\"jdbc频繁的创建和关闭数据库连接\",{\"1\":{\"806\":1}}],[\"jdbc的缺点\",{\"1\":{\"806\":1}}],[\"jdbc\",{\"1\":{\"280\":1,\"1852\":2}}],[\"jdk的体系结构\",{\"1\":{\"1541\":1}}],[\"jdk的设计者匠心独具\",{\"1\":{\"1470\":1}}],[\"jdk会根据这个枚举项类判断他们之间的关系\",{\"1\":{\"1494\":1}}],[\"jdk从1\",{\"1\":{\"1491\":1}}],[\"jdk还为我们提供了一些其他的函数式接口\",{\"1\":{\"1477\":1}}],[\"jdk中举出的拼接字符串的例子\",{\"1\":{\"1486\":1}}],[\"jdk中\",{\"1\":{\"1407\":1}}],[\"jdk中很多类都具备不变性\",{\"1\":{\"1403\":1}}],[\"jdk中提供的大多数的同步器如lock\",{\"1\":{\"1367\":1}}],[\"jdk乐观锁的实现\",{\"1\":{\"1375\":1}}],[\"jdk6默认开启\",{\"1\":{\"1362\":1}}],[\"jdk默认开启指针压缩后位4字节\",{\"1\":{\"1361\":1}}],[\"jdk7之前\",{\"1\":{\"1352\":1}}],[\"jdk动态代理\",{\"0\":{\"918\":1},\"1\":{\"1531\":1}}],[\"jdk8使我们看到了java这门古老的语言的全新面貌\",{\"1\":{\"1484\":1}}],[\"jdk8或者说java8是目前企业开发中最常用的jdk版本\",{\"1\":{\"1468\":1}}],[\"jdk8虽然不会出现死循环的情况\",{\"1\":{\"1428\":1}}],[\"jdk8默认开启\",{\"1\":{\"1364\":1}}],[\"jdk8以后\",{\"1\":{\"1352\":1}}],[\"jdk8\",{\"0\":{\"131\":1},\"1\":{\"1352\":1}}],[\"jdk8有哪些新特性\",{\"0\":{\"25\":1}}],[\"jdk1\",{\"0\":{\"36\":1,\"1430\":1,\"1431\":1},\"1\":{\"1357\":1,\"1422\":1,\"1423\":1,\"1425\":5,\"1426\":1,\"1427\":4,\"1428\":1,\"1431\":2,\"1449\":1,\"1525\":1}}],[\"jdk\",{\"0\":{\"13\":1,\"109\":1,\"960\":1,\"1675\":1},\"1\":{\"1485\":2,\"1491\":1,\"1497\":1}}],[\"jams\",{\"1\":{\"1498\":1}}],[\"jackson\",{\"1\":{\"720\":1}}],[\"jar等\",{\"1\":{\"1540\":1}}],[\"jar\",{\"1\":{\"1540\":1,\"1541\":2,\"1858\":2}}],[\"jar包中同级目录的配置文件加载优先级\",{\"0\":{\"239\":1}}],[\"jar可以直接运行\",{\"0\":{\"192\":1}}],[\"java学习路线\",{\"0\":{\"1845\":1}}],[\"java高级编程\",{\"1\":{\"1844\":1}}],[\"java面向对象编程\",{\"1\":{\"1844\":1}}],[\"java面试题精选\",{\"0\":{\"11\":1}}],[\"java编程开发入门\",{\"1\":{\"1844\":1}}],[\"java与线程\",{\"0\":{\"1689\":1}}],[\"java内存屏障\",{\"0\":{\"1645\":1}}],[\"java内存模型\",{\"0\":{\"1686\":1}}],[\"java内存模型定义了以下八种操作来完成\",{\"1\":{\"1350\":1}}],[\"java内存模型和计算机硬件内存架构是一个交叉关系\",{\"1\":{\"1350\":1}}],[\"java内存模型与硬件内存架构之间存在差异\",{\"1\":{\"1350\":1}}],[\"java内存模型是通过在变量修改后将新值同步回主内存\",{\"1\":{\"1348\":1}}],[\"java监控简介\",{\"0\":{\"1557\":1}}],[\"java类加载器是有亲子层级结构的\",{\"1\":{\"1540\":1}}],[\"java类加载的全过程是怎么样的\",{\"0\":{\"107\":1}}],[\"javaserver\",{\"1\":{\"1561\":1}}],[\"javase\",{\"1\":{\"1504\":1}}],[\"javascript是一门非常典型的函数式语言\",{\"1\":{\"1470\":1}}],[\"java8为我们了提供了很多的函数式接口\",{\"1\":{\"1475\":1}}],[\"java8可谓java语言历史上变化最大的一个版本\",{\"1\":{\"1468\":1}}],[\"java是纯面向对象的语言\",{\"1\":{\"1472\":1}}],[\"java引入了一个全新的概念\",{\"1\":{\"1470\":1}}],[\"javaxinjectproviderclass\",{\"1\":{\"1525\":1}}],[\"javax\",{\"1\":{\"1468\":2}}],[\"java并不是全部支持\",{\"1\":{\"1463\":1}}],[\"java并发包里提供了线程池等工具类\",{\"1\":{\"1410\":1}}],[\"java并发包提供了读写锁reentrantreadwritelock\",{\"1\":{\"1375\":1}}],[\"java并发编程的艺术\",{\"1\":{\"1844\":1}}],[\"java并发编程之美\",{\"1\":{\"1844\":1}}],[\"java并发编程\",{\"0\":{\"1346\":1}}],[\"java并发\",{\"0\":{\"48\":1}}],[\"java开始支持非阻塞io\",{\"1\":{\"1449\":1}}],[\"java反射机制的主要用于实现以下功能\",{\"1\":{\"1436\":1}}],[\"java反射有哪些作用\",{\"0\":{\"26\":1}}],[\"java语言中可以直接使用线程池来实现worker\",{\"1\":{\"1411\":1}}],[\"java语言提供的唯一并发语言就是管程\",{\"1\":{\"1360\":1}}],[\"java7中引入了fork\",{\"1\":{\"1387\":1}}],[\"java7之后不能控制是否开启自旋功能\",{\"1\":{\"1362\":1}}],[\"java1\",{\"1\":{\"1360\":1}}],[\"java线程调度\",{\"0\":{\"1691\":1}}],[\"java线程进入终止状态的前提是线程进入runnable状态\",{\"1\":{\"1401\":1}}],[\"java线程间通信主要有两种\",{\"1\":{\"1354\":1}}],[\"java线程锁机制是怎样的\",{\"0\":{\"73\":1}}],[\"java的函数式编程并不是完美无暇的\",{\"1\":{\"1484\":1}}],[\"java的编程向着函数式风格迈进\",{\"1\":{\"1468\":1}}],[\"java的线程是内核级别的线程\",{\"1\":{\"1354\":1}}],[\"java的优先队列每次取得是最小元素\",{\"1\":{\"353\":1}}],[\"java中有以下几种类加载器\",{\"1\":{\"1540\":1}}],[\"java中使用会存在性能缺陷\",{\"1\":{\"1410\":1}}],[\"java中monitor的工作流程\",{\"1\":{\"1360\":1}}],[\"java中对静态变量的自增\",{\"1\":{\"1359\":1}}],[\"java中的零拷贝\",{\"0\":{\"1463\":1}}],[\"java中的io模型\",{\"0\":{\"1449\":1}}],[\"java中的string在实现replace\",{\"1\":{\"1404\":1}}],[\"java中的clh队列是原clh队列的一个变种\",{\"1\":{\"1368\":1}}],[\"java中的cas操作\",{\"1\":{\"1356\":1}}],[\"java中的每个对象都可以把它当作一个同步锁来使用\",{\"1\":{\"1359\":1}}],[\"java中的priorityqueue实现了queue接口\",{\"1\":{\"353\":1}}],[\"java中创建线程的方式\",{\"1\":{\"1354\":1}}],[\"java中\",{\"1\":{\"1350\":1}}],[\"java层面线程共有六种状态\",{\"1\":{\"1354\":1}}],[\"java层面\",{\"1\":{\"1347\":1}}],[\"java事件\",{\"0\":{\"1269\":1}}],[\"java泛型擦写是发生在编译时\",{\"0\":{\"1266\":1}}],[\"java泛型基础\",{\"0\":{\"1259\":1}}],[\"javabeans操作属性\",{\"0\":{\"1236\":1}}],[\"java文本格式化\",{\"0\":{\"1214\":1}}],[\"java国际化标准实现\",{\"0\":{\"1213\":1}}],[\"java标准资源管理扩展的步骤\",{\"0\":{\"1210\":1}}],[\"java标准资源管理\",{\"0\":{\"1198\":1}}],[\"java注解的方式\",{\"0\":{\"1188\":1}}],[\"java通用注解原理\",{\"0\":{\"1127\":1}}],[\"java当中也有开源的词法结构分析工具\",{\"1\":{\"650\":1}}],[\"javamail和jaf\",{\"1\":{\"280\":1}}],[\"java虚拟机规范中定义了java内存模型\",{\"1\":{\"1350\":1}}],[\"java虚拟机\",{\"0\":{\"101\":1}}],[\"java有哪几种io模型\",{\"0\":{\"96\":1}}],[\"java网络通信\",{\"0\":{\"93\":1}}],[\"java如何开启线程\",{\"0\":{\"53\":1}}],[\"java集合\",{\"0\":{\"31\":1}}],[\"java基础\",{\"0\":{\"12\":1}}],[\"java\",{\"0\":{\"97\":1,\"103\":1,\"105\":1,\"280\":1,\"281\":1,\"899\":1,\"909\":1,\"1260\":1,\"1464\":1,\"1465\":1,\"1556\":1,\"1847\":1,\"1854\":1},\"1\":{\"8\":1,\"280\":2,\"302\":1,\"316\":1,\"329\":1,\"711\":13,\"721\":1,\"1354\":1,\"1356\":4,\"1365\":1,\"1375\":1,\"1416\":7,\"1417\":4,\"1437\":5,\"1464\":1,\"1465\":2,\"1468\":6,\"1471\":8,\"1474\":2,\"1475\":2,\"1487\":3,\"1491\":1,\"1494\":5,\"1496\":20,\"1497\":8,\"1503\":1,\"1541\":1,\"1561\":3,\"1843\":1,\"1844\":1,\"1846\":1,\"1847\":16,\"1848\":2,\"1855\":1,\"1856\":5,\"1860\":3,\"1861\":1,\"1870\":7,\"1871\":2}}],[\"jre\",{\"0\":{\"13\":1}}],[\"jstl\",{\"1\":{\"1856\":1}}],[\"jsr330factory\",{\"1\":{\"1525\":1}}],[\"js与nginx也是单线程\",{\"1\":{\"738\":1}}],[\"jsonobject\",{\"1\":{\"719\":6}}],[\"json\",{\"1\":{\"690\":1,\"692\":1,\"720\":2}}],[\"json=on\",{\"1\":{\"656\":1,\"657\":1}}],[\"jsp\",{\"1\":{\"280\":1,\"1856\":2}}],[\"js\",{\"1\":{\"3\":2}}],[\"掘金\",{\"1\":{\"7\":1}}],[\"社区论坛项目\",{\"1\":{\"1865\":1}}],[\"社区\",{\"0\":{\"7\":1}}],[\"n1\",{\"1\":{\"1491\":3}}],[\"nfds\",{\"1\":{\"1447\":1}}],[\"nt\",{\"1\":{\"1431\":5}}],[\"n为table的长度\",{\"1\":{\"1427\":1}}],[\"n位table的长度\",{\"1\":{\"1425\":1}}],[\"ncpu\",{\"1\":{\"1357\":1}}],[\"n∗字节数\",{\"1\":{\"1352\":1}}],[\"n测试\",{\"1\":{\"711\":1}}],[\"n切换到db\",{\"1\":{\"704\":1}}],[\"n代表字符数\",{\"1\":{\"667\":1}}],[\"n>1\",{\"1\":{\"587\":1}}],[\"n这个语法\",{\"1\":{\"578\":1}}],[\"n+1\",{\"1\":{\"559\":1}}],[\"n分别是两张表的行数\",{\"1\":{\"543\":1}}],[\"n次对比\",{\"1\":{\"543\":1}}],[\"nlj算法比bnl算法性能更高\",{\"1\":{\"662\":1}}],[\"nlj算法执行的逻辑是\",{\"1\":{\"542\":1}}],[\"nlj和bnl都还有优化的空间\",{\"1\":{\"541\":1}}],[\"n小一些\",{\"1\":{\"540\":1}}],[\"n对扫描行数影响更大\",{\"1\":{\"538\":1}}],[\"n叉\",{\"1\":{\"471\":1}}],[\"n叉树\",{\"1\":{\"471\":1}}],[\"n的值并不是递增的\",{\"1\":{\"469\":1}}],[\"n2\",{\"1\":{\"1491\":3}}],[\"n2的话\",{\"1\":{\"471\":1}}],[\"n2对应的名字\",{\"1\":{\"470\":1}}],[\"n2对应的名字是什么\",{\"1\":{\"469\":1}}],[\"n2通过哈希函数算出n\",{\"1\":{\"469\":1}}],[\"n−1\",{\"1\":{\"425\":1}}],[\"n可以去掉\",{\"1\":{\"415\":1}}],[\"n^2\",{\"1\":{\"366\":1,\"368\":1}}],[\"nihao\",{\"1\":{\"1491\":1}}],[\"nil\",{\"1\":{\"343\":1,\"704\":1,\"706\":1,\"707\":1,\"716\":1,\"717\":1,\"718\":1}}],[\"nio文件读写本质\",{\"1\":{\"1843\":1}}],[\"nio有一个mappedbytebuffer的类\",{\"1\":{\"1464\":1}}],[\"nio虽然编码复杂\",{\"1\":{\"1451\":1}}],[\"nio比bio复杂很多\",{\"1\":{\"1451\":1}}],[\"nio中的一些概念\",{\"1\":{\"1451\":1}}],[\"nio弥补了同步阻塞io的不足\",{\"1\":{\"1451\":1}}],[\"nio\",{\"0\":{\"1451\":1,\"1464\":1,\"1465\":1},\"1\":{\"1453\":1,\"1465\":2}}],[\"nio网络编程\",{\"0\":{\"851\":1}}],[\"nioeventloopgroup默认的构造函数会起多少线程\",{\"0\":{\"215\":1}}],[\"nio的几个核心组件是什么\",{\"0\":{\"97\":1}}],[\"ns\",{\"1\":{\"329\":7}}],[\"numeric\",{\"1\":{\"1491\":1}}],[\"numkeys\",{\"1\":{\"711\":3}}],[\"numbers\",{\"1\":{\"566\":2}}],[\"number\",{\"1\":{\"491\":2,\"492\":1,\"588\":1,\"616\":1,\"657\":2,\"1357\":1,\"1490\":1,\"1497\":5,\"1498\":1}}],[\"numislands\",{\"1\":{\"435\":1}}],[\"num++\",{\"1\":{\"364\":4}}],[\"num\",{\"1\":{\"364\":2,\"381\":7,\"430\":1,\"437\":2,\"440\":4,\"566\":2}}],[\"nums\",{\"1\":{\"305\":4,\"329\":3,\"359\":5,\"360\":5,\"361\":10,\"362\":16,\"363\":6,\"365\":9,\"366\":35,\"381\":4,\"393\":4,\"399\":6,\"421\":3,\"430\":10,\"431\":12,\"432\":2,\"437\":2,\"441\":2}}],[\"nullbean\",{\"1\":{\"1524\":1,\"1525\":1}}],[\"nullable\",{\"1\":{\"1524\":6,\"1525\":10,\"1527\":1,\"1531\":1,\"1532\":2}}],[\"nullpointerexception\",{\"1\":{\"1353\":1,\"1380\":1,\"1430\":1,\"1431\":1,\"1472\":1,\"1474\":1,\"1475\":6,\"1476\":4,\"1478\":2,\"1496\":10,\"1499\":1}}],[\"null值表示未被压缩\",{\"1\":{\"690\":1}}],[\"null的话\",{\"1\":{\"536\":1}}],[\"null也无法使用索引\",{\"1\":{\"506\":1}}],[\"null\",{\"1\":{\"296\":3,\"302\":4,\"338\":2,\"363\":1,\"365\":1,\"366\":1,\"368\":1,\"371\":1,\"372\":2,\"373\":5,\"375\":1,\"376\":5,\"377\":3,\"383\":1,\"385\":4,\"395\":11,\"396\":4,\"397\":3,\"398\":3,\"401\":3,\"402\":3,\"403\":4,\"404\":3,\"405\":2,\"406\":14,\"407\":1,\"408\":1,\"409\":10,\"410\":11,\"411\":7,\"412\":3,\"431\":2,\"435\":1,\"466\":6,\"467\":26,\"472\":1,\"473\":2,\"475\":5,\"483\":3,\"490\":5,\"498\":12,\"499\":4,\"500\":2,\"503\":4,\"505\":5,\"506\":1,\"515\":1,\"527\":4,\"537\":3,\"553\":3,\"556\":2,\"561\":2,\"583\":3,\"591\":3,\"596\":2,\"599\":3,\"605\":2,\"613\":2,\"615\":2,\"626\":3,\"627\":1,\"628\":5,\"629\":1,\"631\":3,\"643\":9,\"647\":5,\"655\":5,\"656\":1,\"660\":3,\"664\":1,\"671\":2,\"672\":3,\"690\":1,\"806\":1,\"1353\":2,\"1357\":5,\"1360\":9,\"1379\":2,\"1380\":3,\"1394\":1,\"1425\":1,\"1426\":11,\"1427\":16,\"1430\":6,\"1431\":21,\"1450\":3,\"1451\":14,\"1452\":4,\"1471\":1,\"1472\":1,\"1474\":1,\"1475\":6,\"1476\":9,\"1478\":2,\"1482\":1,\"1495\":5,\"1496\":1,\"1497\":7,\"1498\":10,\"1499\":6,\"1500\":1,\"1524\":42,\"1525\":21,\"1527\":10,\"1531\":5,\"1532\":17,\"1535\":4,\"1540\":4}}],[\"n\",{\"1\":{\"302\":3,\"325\":3,\"329\":3,\"330\":2,\"339\":1,\"364\":7,\"375\":3,\"384\":4,\"385\":14,\"386\":2,\"393\":3,\"399\":2,\"415\":10,\"417\":11,\"424\":15,\"425\":7,\"426\":7,\"427\":4,\"429\":13,\"431\":9,\"438\":27,\"441\":2,\"471\":1,\"514\":1,\"540\":4,\"559\":3,\"566\":4,\"578\":1,\"581\":1,\"605\":2,\"618\":1,\"667\":2,\"693\":2,\"695\":2,\"704\":1,\"707\":2,\"710\":3,\"711\":2,\"713\":1,\"726\":2,\"1352\":1,\"1426\":4,\"1431\":11,\"1446\":1,\"1486\":3,\"1497\":1}}],[\"nearly\",{\"1\":{\"1496\":1}}],[\"needsdepcheck\",{\"1\":{\"1524\":2}}],[\"needs\",{\"1\":{\"1524\":1}}],[\"need\",{\"1\":{\"1496\":1,\"1500\":1,\"1524\":1,\"1528\":1,\"1567\":1}}],[\"needed\",{\"1\":{\"1496\":1}}],[\"needing\",{\"1\":{\"1492\":1}}],[\"never\",{\"1\":{\"1492\":2}}],[\"negation\",{\"1\":{\"1476\":4}}],[\"negate本身是否定的意思\",{\"1\":{\"1476\":1}}],[\"negate\",{\"1\":{\"1471\":1,\"1476\":3}}],[\"nex=automatic\",{\"1\":{\"605\":1}}],[\"nextstage\",{\"1\":{\"1499\":1}}],[\"nextline\",{\"1\":{\"1450\":1}}],[\"nexttable\",{\"1\":{\"1431\":1}}],[\"next已经指向了key\",{\"1\":{\"1428\":1}}],[\"next导致了next指向了key\",{\"1\":{\"1428\":1}}],[\"next命令\",{\"1\":{\"605\":1}}],[\"next是一个指定的gtid的值\",{\"1\":{\"605\":1}}],[\"next的值\",{\"1\":{\"605\":1}}],[\"next=gtid1\",{\"1\":{\"622\":1}}],[\"next=automatic\",{\"1\":{\"605\":2}}],[\"next=\",{\"1\":{\"591\":1,\"605\":3}}],[\"next\",{\"1\":{\"371\":5,\"372\":4,\"373\":8,\"375\":8,\"376\":2,\"377\":6,\"381\":1,\"1380\":4,\"1423\":2,\"1426\":2,\"1427\":10,\"1428\":4,\"1430\":1,\"1431\":3,\"1451\":3,\"1452\":1,\"1480\":1,\"1486\":1,\"1497\":2,\"1498\":1,\"1499\":1,\"1500\":1,\"1525\":2}}],[\"nested\",{\"0\":{\"538\":1,\"539\":1,\"540\":1},\"1\":{\"538\":1,\"539\":3,\"540\":7,\"660\":2,\"661\":1,\"692\":1,\"1419\":1}}],[\"net\",{\"1\":{\"467\":1,\"698\":1,\"1526\":1}}],[\"netty中的处理器\",{\"0\":{\"886\":1}}],[\"netty中的设计原则\",{\"0\":{\"876\":1}}],[\"netty中的reactor线程模型\",{\"0\":{\"867\":1}}],[\"netty中的future对象\",{\"0\":{\"857\":1}}],[\"netty与websocket\",{\"0\":{\"823\":1}}],[\"netty对socket的实现\",{\"0\":{\"819\":1}}],[\"netty整体执行流程分析\",{\"0\":{\"818\":1}}],[\"netty模块分析\",{\"0\":{\"817\":1}}],[\"netty的hello\",{\"0\":{\"816\":1}}],[\"netty的零拷贝了解么\",{\"0\":{\"219\":1}}],[\"netty架构实现\",{\"0\":{\"815\":1}}],[\"netty特点\",{\"0\":{\"809\":1}}],[\"netty长连接\",{\"0\":{\"218\":1}}],[\"netty服务端和客户端的启动过程了解么\",{\"0\":{\"217\":1}}],[\"netty线程模型了解么\",{\"0\":{\"216\":1}}],[\"netty核心组件有哪些\",{\"0\":{\"212\":1}}],[\"netty有哪些应用场景\",{\"0\":{\"211\":1}}],[\"netty面试题\",{\"0\":{\"210\":1}}],[\"new关键词\",{\"1\":{\"1543\":1}}],[\"new指令对应到语言层面上讲是\",{\"1\":{\"1543\":1}}],[\"newratio\",{\"1\":{\"1541\":1}}],[\"new对象等等\",{\"1\":{\"1540\":1}}],[\"newproxyinstance\",{\"1\":{\"1531\":1}}],[\"newpvs\",{\"1\":{\"1524\":4}}],[\"newparam\",{\"1\":{\"285\":1}}],[\"new也可以写成arraylist<t>\",{\"1\":{\"1495\":1}}],[\"new中的new的话\",{\"1\":{\"1477\":1}}],[\"newtime1\",{\"1\":{\"1468\":2}}],[\"newtime\",{\"1\":{\"1468\":2}}],[\"newtab\",{\"1\":{\"1427\":7}}],[\"newtable\",{\"1\":{\"1427\":4,\"1428\":1}}],[\"newthr\",{\"1\":{\"1427\":6}}],[\"newnode\",{\"1\":{\"1426\":2}}],[\"newfixedthreadpool\",{\"1\":{\"1394\":3,\"1411\":1,\"1412\":2}}],[\"newcap\",{\"1\":{\"1383\":1,\"1427\":8}}],[\"newcapacity\",{\"1\":{\"1352\":1,\"1427\":3}}],[\"newcondition\",{\"1\":{\"1379\":2,\"1380\":2}}],[\"newlinkedhashmap\",{\"1\":{\"1525\":1}}],[\"newline\",{\"1\":{\"1362\":1,\"1482\":1}}],[\"newlist\",{\"1\":{\"708\":9}}],[\"newvalue\",{\"1\":{\"1356\":1,\"1423\":1,\"1495\":4}}],[\"newxnode\",{\"1\":{\"806\":1}}],[\"newset\",{\"1\":{\"709\":4}}],[\"newkey\",{\"1\":{\"706\":2}}],[\"newkey仅当\",{\"1\":{\"706\":1}}],[\"newkey修改\",{\"1\":{\"706\":1}}],[\"new\",{\"1\":{\"296\":1,\"302\":6,\"329\":3,\"359\":3,\"362\":1,\"364\":1,\"366\":3,\"371\":1,\"373\":1,\"375\":1,\"380\":3,\"381\":3,\"384\":1,\"385\":2,\"386\":3,\"387\":1,\"392\":2,\"393\":4,\"395\":5,\"396\":1,\"397\":1,\"399\":3,\"400\":3,\"401\":3,\"402\":3,\"403\":3,\"404\":2,\"409\":7,\"410\":1,\"411\":1,\"415\":1,\"417\":8,\"424\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":1,\"431\":2,\"441\":1,\"635\":2,\"656\":1,\"719\":3,\"720\":1,\"806\":5,\"1353\":1,\"1356\":5,\"1361\":1,\"1363\":1,\"1364\":2,\"1379\":1,\"1380\":9,\"1394\":3,\"1398\":9,\"1405\":1,\"1410\":3,\"1411\":2,\"1412\":2,\"1427\":2,\"1428\":3,\"1430\":2,\"1431\":4,\"1434\":1,\"1450\":15,\"1451\":9,\"1452\":18,\"1468\":8,\"1469\":4,\"1472\":4,\"1474\":1,\"1475\":9,\"1476\":5,\"1477\":6,\"1478\":1,\"1480\":8,\"1481\":10,\"1482\":4,\"1483\":4,\"1484\":8,\"1485\":12,\"1486\":5,\"1488\":1,\"1489\":1,\"1490\":4,\"1491\":1,\"1492\":10,\"1493\":1,\"1494\":13,\"1495\":30,\"1496\":4,\"1497\":9,\"1498\":6,\"1499\":8,\"1500\":4,\"1509\":1,\"1510\":2,\"1511\":2,\"1512\":2,\"1515\":3,\"1516\":4,\"1517\":2,\"1521\":1,\"1523\":1,\"1524\":31,\"1525\":16,\"1527\":1,\"1528\":6,\"1531\":20,\"1532\":6,\"1535\":1,\"1567\":1}}],[\"nginx如何保证高可用\",{\"0\":{\"268\":1}}],[\"nginx\",{\"0\":{\"267\":1}}],[\"narrows\",{\"1\":{\"1497\":1}}],[\"natural\",{\"1\":{\"1497\":2}}],[\"nativedetector\",{\"1\":{\"1528\":1}}],[\"native\",{\"1\":{\"562\":1}}],[\"nanoseconds\",{\"1\":{\"1489\":1}}],[\"nanotime\",{\"1\":{\"1489\":2,\"1540\":2}}],[\"na\",{\"1\":{\"512\":1}}],[\"namematchmethodpointcut\",{\"1\":{\"1531\":2}}],[\"nametolookup\",{\"1\":{\"1524\":5}}],[\"name>\",{\"1\":{\"761\":8}}],[\"name字段在studentx中是否存在\",{\"1\":{\"710\":1}}],[\"name字段是比age字段大的\",{\"1\":{\"476\":1}}],[\"name具体的含义\",{\"1\":{\"695\":1}}],[\"name`\",{\"1\":{\"643\":1}}],[\"name表示统计的类型\",{\"1\":{\"616\":1}}],[\"name表里有很多行数据\",{\"1\":{\"616\":1}}],[\"name表里统计了每次io请求的时间\",{\"1\":{\"616\":1}}],[\"name文件的master\",{\"1\":{\"604\":1}}],[\"namesbycity\",{\"1\":{\"1495\":1}}],[\"names\",{\"1\":{\"566\":1,\"1493\":2,\"1495\":2}}],[\"name和age这三个字段的值\",{\"1\":{\"493\":1}}],[\"name和age这三个字段的结果\",{\"1\":{\"492\":1}}],[\"name的值就一定是有序的\",{\"1\":{\"493\":1}}],[\"name=jyc\",{\"1\":{\"651\":2}}],[\"name=\",{\"1\":{\"467\":2,\"616\":1,\"1403\":2,\"1490\":1}}],[\"name\",{\"1\":{\"467\":10,\"472\":1,\"476\":3,\"477\":4,\"478\":1,\"488\":1,\"490\":2,\"491\":4,\"492\":2,\"493\":7,\"507\":4,\"508\":2,\"509\":2,\"558\":2,\"565\":3,\"566\":2,\"568\":1,\"578\":2,\"604\":3,\"605\":2,\"616\":6,\"622\":1,\"647\":4,\"655\":7,\"656\":6,\"657\":2,\"659\":4,\"663\":1,\"673\":1,\"690\":3,\"692\":2,\"694\":1,\"695\":5,\"704\":3,\"706\":5,\"707\":3,\"710\":11,\"719\":1,\"748\":4,\"761\":1,\"1477\":8,\"1480\":5,\"1482\":8,\"1488\":1,\"1490\":19,\"1524\":17,\"1532\":1,\"1535\":2,\"1540\":6}}],[\"nacos服务注册的流程是怎么样的\",{\"0\":{\"244\":1}}],[\"nacos同一个namespace中的不同的group注册的服务可以相互访问吗\",{\"0\":{\"243\":1}}],[\"nacos中命名空间和分组的概念及区别\",{\"0\":{\"242\":1}}],[\"nacos的配置动态更新原理\",{\"0\":{\"240\":1}}],[\"nacos配置中心\",{\"0\":{\"239\":1}}],[\"nacos和eureka的区别\",{\"0\":{\"238\":1}}],[\"navbar\",{\"1\":{\"4\":1}}],[\"noop\",{\"1\":{\"1531\":1}}],[\"nosuchbeandefinitionexception\",{\"1\":{\"1524\":3,\"1525\":1}}],[\"noid\",{\"1\":{\"1495\":8}}],[\"no来说\",{\"1\":{\"695\":1}}],[\"no访问s1的成本\",{\"1\":{\"692\":1}}],[\"no进行对s1的访问\",{\"1\":{\"692\":1}}],[\"no=常数中的常数值我们是不知道\",{\"1\":{\"692\":1}}],[\"no可以进行ref方式访问\",{\"1\":{\"692\":1}}],[\"no`\",{\"1\":{\"690\":1,\"692\":1}}],[\"no列平均每个值的重复次数就是10354\",{\"1\":{\"690\":1}}],[\"no索引为例\",{\"1\":{\"690\":1}}],[\"no的tracer的输出\",{\"1\":{\"688\":1}}],[\"no的成本就是\",{\"1\":{\"688\":1}}],[\"no的成本\",{\"1\":{\"686\":1,\"688\":1}}],[\"no的成本为72\",{\"1\":{\"681\":1}}],[\"no执行查询的总成本就是\",{\"1\":{\"686\":1}}],[\"no执行查询的成本呢\",{\"1\":{\"692\":1}}],[\"no执行查询的成本就如下所示\",{\"1\":{\"686\":1}}],[\"no执行查询的成本\",{\"1\":{\"686\":1}}],[\"no执行查询时有3个单点区间\",{\"1\":{\"686\":1}}],[\"no时需要访问的范围区间数量以及需要回表的记录数\",{\"1\":{\"686\":1}}],[\"no对应的搜索条件是\",{\"1\":{\"686\":1}}],[\"nowait\",{\"1\":{\"578\":2}}],[\"now\",{\"1\":{\"505\":3,\"530\":2,\"571\":1,\"591\":1,\"615\":1,\"647\":3,\"655\":3,\"1524\":1}}],[\"no\",{\"1\":{\"467\":1,\"588\":4,\"602\":1,\"615\":1,\"657\":2,\"681\":1,\"684\":4,\"686\":3,\"690\":6,\"691\":2,\"692\":9,\"695\":1,\"729\":1,\"748\":2,\"1357\":1,\"1431\":1,\"1474\":2,\"1477\":2,\"1490\":1,\"1491\":1,\"1494\":1,\"1495\":1,\"1496\":1,\"1497\":4,\"1498\":1,\"1524\":3,\"1525\":3,\"1527\":2}}],[\"nondeterministic\",{\"1\":{\"1499\":1}}],[\"nonnull\",{\"1\":{\"1497\":4}}],[\"noninterference\",{\"1\":{\"1485\":2}}],[\"nonvolatile\",{\"1\":{\"1430\":1}}],[\"nonrepeatable\",{\"1\":{\"669\":1}}],[\"non\",{\"1\":{\"385\":2,\"570\":1,\"690\":1,\"1357\":1,\"1419\":1,\"1485\":2,\"1492\":2,\"1496\":2,\"1497\":11,\"1498\":5,\"1524\":2,\"1527\":1,\"1532\":2,\"1540\":1}}],[\"none\",{\"1\":{\"288\":1,\"1486\":2,\"1497\":1,\"1524\":1}}],[\"notnull\",{\"1\":{\"1535\":2}}],[\"notfull条件\",{\"1\":{\"1380\":1}}],[\"notfull条件队列转同步队列\",{\"1\":{\"1379\":1,\"1380\":2}}],[\"notfull\",{\"1\":{\"1379\":4,\"1380\":4}}],[\"notify和notifyall分别何时使用\",{\"1\":{\"1360\":1}}],[\"notify和notifyall有什么区别\",{\"0\":{\"56\":1}}],[\"notifyall\",{\"1\":{\"1360\":1,\"1407\":1}}],[\"notify主要两个缺陷\",{\"1\":{\"1354\":1}}],[\"notify\",{\"1\":{\"761\":1,\"1360\":1,\"1407\":1}}],[\"notification\",{\"1\":{\"761\":2}}],[\"not以及其它位操作\",{\"1\":{\"715\":1}}],[\"notempty条件\",{\"1\":{\"1380\":1}}],[\"notempty条件队列转同步队列\",{\"1\":{\"1379\":1,\"1380\":2}}],[\"notempty\",{\"1\":{\"1379\":4,\"1380\":4,\"1524\":1}}],[\"note没有用到索引\",{\"1\":{\"692\":1}}],[\"note`\",{\"1\":{\"690\":1,\"692\":1}}],[\"note即使有索引\",{\"1\":{\"684\":1}}],[\"noteshare\",{\"1\":{\"668\":1,\"677\":1,\"1540\":1}}],[\"note\",{\"1\":{\"446\":1,\"449\":1,\"654\":2,\"668\":1,\"677\":1,\"681\":1,\"684\":2,\"690\":2,\"691\":9,\"692\":6,\"796\":1,\"800\":1,\"1540\":1}}],[\"not\",{\"1\":{\"356\":1,\"381\":1,\"472\":2,\"473\":2,\"475\":1,\"483\":1,\"490\":4,\"498\":8,\"499\":6,\"500\":3,\"503\":1,\"505\":1,\"506\":1,\"515\":1,\"537\":1,\"556\":1,\"561\":1,\"579\":1,\"583\":1,\"591\":2,\"596\":1,\"599\":1,\"605\":1,\"613\":1,\"615\":2,\"626\":1,\"631\":1,\"643\":5,\"647\":5,\"655\":5,\"656\":2,\"657\":2,\"660\":1,\"671\":1,\"672\":1,\"710\":1,\"717\":1,\"767\":1,\"1471\":7,\"1474\":1,\"1476\":8,\"1492\":4,\"1494\":3,\"1495\":3,\"1496\":6,\"1497\":15,\"1498\":1,\"1499\":3,\"1500\":3,\"1524\":7,\"1525\":3,\"1527\":1,\"1528\":1,\"1532\":1,\"1535\":3,\"1540\":2,\"1872\":1}}],[\"nodes\",{\"1\":{\"1497\":2}}],[\"node节点设计如下\",{\"1\":{\"1431\":1}}],[\"node是hashmap的一个内部类\",{\"1\":{\"1423\":1}}],[\"node<\",{\"1\":{\"1431\":1}}],[\"node<k\",{\"1\":{\"1423\":4,\"1426\":3,\"1427\":8,\"1431\":14}}],[\"node<e>\",{\"1\":{\"1380\":10}}],[\"nodehandlermap\",{\"1\":{\"806\":1}}],[\"nodehandler\",{\"1\":{\"806\":1}}],[\"nodename\",{\"1\":{\"806\":3}}],[\"nodelist\",{\"1\":{\"806\":1}}],[\"node\",{\"1\":{\"296\":3,\"302\":15,\"396\":5,\"397\":12,\"401\":4,\"402\":4,\"403\":4,\"404\":4,\"410\":7,\"411\":4,\"708\":1,\"738\":1,\"806\":10,\"1368\":1,\"1380\":5,\"1423\":2,\"1427\":1,\"1430\":6,\"1431\":1}}],[\"normal`\",{\"1\":{\"550\":2}}],[\"normal的时候\",{\"1\":{\"550\":1}}],[\"normal和insert\",{\"1\":{\"550\":1}}],[\"normal\",{\"1\":{\"0\":1,\"550\":6,\"1532\":1}}],[\"o和多线程\",{\"1\":{\"1847\":1}}],[\"o和锁等待\",{\"1\":{\"525\":1}}],[\"o模型的差异\",{\"1\":{\"1566\":1}}],[\"o模型和应用层协议可以自由组合\",{\"1\":{\"1565\":1}}],[\"o模型\",{\"1\":{\"1565\":1}}],[\"our\",{\"1\":{\"1532\":2}}],[\"outer\",{\"1\":{\"1524\":2}}],[\"out表示这个阶段生成的元素类型\",{\"1\":{\"1498\":1}}],[\"out>>\",{\"1\":{\"1500\":2}}],[\"out>\",{\"1\":{\"1494\":1,\"1498\":6,\"1499\":9,\"1500\":7}}],[\"output\",{\"1\":{\"566\":1,\"1475\":6,\"1500\":3}}],[\"out\",{\"1\":{\"329\":5,\"568\":1,\"717\":1,\"719\":3,\"720\":1,\"1362\":1,\"1364\":1,\"1428\":2,\"1450\":3,\"1451\":3,\"1452\":3,\"1464\":1,\"1465\":1,\"1468\":6,\"1469\":3,\"1470\":7,\"1471\":1,\"1472\":13,\"1474\":2,\"1475\":12,\"1476\":7,\"1477\":5,\"1478\":2,\"1479\":1,\"1480\":4,\"1481\":4,\"1482\":5,\"1483\":2,\"1484\":9,\"1485\":2,\"1486\":10,\"1487\":17,\"1488\":2,\"1489\":6,\"1491\":1,\"1492\":2,\"1493\":8,\"1494\":19,\"1496\":12,\"1497\":3,\"1499\":7,\"1500\":6,\"1509\":1,\"1510\":1,\"1511\":1,\"1512\":1,\"1515\":1,\"1517\":1,\"1523\":2,\"1531\":4,\"1567\":1}}],[\"o表示的就是代理对象\",{\"1\":{\"1531\":1}}],[\"omnivorous\",{\"1\":{\"1500\":1}}],[\"odd\",{\"1\":{\"1497\":1}}],[\"o通道等等\",{\"1\":{\"1496\":1}}],[\"occurred\",{\"1\":{\"1497\":1}}],[\"occurs\",{\"1\":{\"1497\":1}}],[\"occur\",{\"1\":{\"1492\":1,\"1496\":1,\"1497\":3}}],[\"overloads\",{\"1\":{\"1497\":2}}],[\"overly\",{\"1\":{\"1497\":1}}],[\"overhead\",{\"1\":{\"1497\":1}}],[\"over\",{\"1\":{\"1497\":2,\"1524\":1}}],[\"overflow\",{\"1\":{\"1491\":1,\"1864\":1}}],[\"overridden\",{\"1\":{\"1497\":3,\"1532\":2}}],[\"overriding\",{\"1\":{\"1471\":2,\"1497\":1}}],[\"overrides\",{\"1\":{\"1524\":2}}],[\"overridefrom\",{\"1\":{\"1524\":1}}],[\"override\",{\"0\":{\"14\":1},\"1\":{\"302\":3,\"311\":1,\"1450\":1,\"1452\":10,\"1468\":2,\"1469\":1,\"1472\":5,\"1474\":1,\"1484\":3,\"1486\":2,\"1490\":1,\"1493\":5,\"1494\":17,\"1495\":3,\"1496\":2,\"1497\":7,\"1498\":4,\"1499\":6,\"1500\":8,\"1515\":1,\"1516\":3,\"1521\":2,\"1524\":2,\"1525\":2,\"1528\":1,\"1531\":6,\"1534\":3,\"1567\":1}}],[\"o2\",{\"1\":{\"1480\":1,\"1491\":1}}],[\"o1\",{\"1\":{\"1480\":1,\"1491\":1}}],[\"oop局限性\",{\"0\":{\"903\":1}}],[\"oop\",{\"0\":{\"900\":1},\"1\":{\"1356\":2}}],[\"oom\",{\"1\":{\"455\":1}}],[\"os\",{\"0\":{\"771\":1},\"1\":{\"1356\":1,\"1461\":1}}],[\"obtainfromsupplier\",{\"1\":{\"1527\":1}}],[\"obtainfreshbeanfactory\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"obtained\",{\"1\":{\"1500\":1}}],[\"obvious\",{\"1\":{\"1497\":1}}],[\"observer\",{\"1\":{\"761\":1}}],[\"obj\",{\"1\":{\"302\":3,\"1356\":2,\"1405\":1,\"1476\":2}}],[\"objectutils\",{\"1\":{\"1525\":1,\"1527\":1,\"1535\":1}}],[\"objectprovider\",{\"1\":{\"1525\":1}}],[\"objectfactory\",{\"1\":{\"1525\":1}}],[\"objectfactory与beanfactory的区别\",{\"0\":{\"1109\":1}}],[\"object类中方法并不会对函数式接口的方法的数量变化\",{\"1\":{\"1471\":1}}],[\"objects\",{\"1\":{\"1471\":6,\"1472\":1,\"1474\":2,\"1475\":9,\"1476\":11,\"1478\":2,\"1486\":1,\"1491\":2,\"1494\":1,\"1495\":2,\"1496\":1,\"1498\":3,\"1499\":2,\"1500\":6,\"1531\":3}}],[\"objectmonitor\",{\"1\":{\"1360\":1}}],[\"object>\",{\"1\":{\"720\":3,\"1525\":5}}],[\"object\",{\"1\":{\"302\":1,\"806\":4,\"1352\":2,\"1360\":1,\"1361\":1,\"1379\":3,\"1383\":2,\"1419\":1,\"1423\":1,\"1425\":1,\"1434\":4,\"1471\":8,\"1474\":2,\"1475\":4,\"1476\":22,\"1478\":4,\"1480\":2,\"1485\":2,\"1492\":1,\"1493\":1,\"1495\":1,\"1496\":5,\"1497\":6,\"1498\":1,\"1500\":1,\"1516\":2,\"1521\":1,\"1524\":18,\"1525\":15,\"1527\":1,\"1531\":15,\"1532\":5,\"1534\":3,\"1567\":1}}],[\"old收集器\",{\"0\":{\"1605\":1,\"1606\":1}}],[\"old1\",{\"1\":{\"1468\":2}}],[\"oldval\",{\"1\":{\"1431\":5}}],[\"oldvalue\",{\"1\":{\"1426\":3,\"1430\":4}}],[\"oldthr\",{\"1\":{\"1427\":4}}],[\"oldtab\",{\"1\":{\"1427\":7}}],[\"oldtable\",{\"1\":{\"1427\":2}}],[\"oldcap放到bucket里\",{\"1\":{\"1427\":1}}],[\"oldcapacity\",{\"1\":{\"1427\":2}}],[\"oldcap\",{\"1\":{\"1383\":4,\"1427\":10}}],[\"old\",{\"1\":{\"707\":1,\"1468\":2}}],[\"otherwise\",{\"1\":{\"1472\":2,\"1476\":2,\"1494\":1,\"1496\":2,\"1497\":3,\"1498\":2}}],[\"other\",{\"1\":{\"695\":1,\"1471\":6,\"1474\":2,\"1476\":32,\"1491\":4,\"1492\":2,\"1494\":2,\"1497\":2,\"1524\":3}}],[\"others这两个分区\",{\"1\":{\"562\":1}}],[\"others\",{\"1\":{\"561\":1,\"740\":1}}],[\"o成本\",{\"1\":{\"694\":1}}],[\"o成本+cpu成本\",{\"1\":{\"685\":1}}],[\"o等\",{\"1\":{\"670\":1}}],[\"ok\",{\"1\":{\"565\":1,\"568\":1,\"704\":4,\"706\":4,\"707\":4,\"708\":2,\"710\":1,\"714\":1,\"716\":6,\"717\":4,\"718\":6,\"748\":1}}],[\"o的消耗时间\",{\"1\":{\"525\":1}}],[\"o操作完成\",{\"1\":{\"525\":1}}],[\"o操作上消耗时间\",{\"1\":{\"518\":1}}],[\"opportunity\",{\"1\":{\"1524\":1}}],[\"opflags\",{\"1\":{\"1499\":7}}],[\"opforxxx然后才能进行对应的操作\",{\"1\":{\"721\":1}}],[\"opwrapsink是map等方法中实现的\",{\"1\":{\"1500\":1}}],[\"opwrapsink\",{\"1\":{\"1498\":1,\"1499\":1,\"1500\":2}}],[\"opisstateful\",{\"1\":{\"1498\":1,\"1499\":2}}],[\"op\",{\"1\":{\"1451\":5,\"1495\":6,\"1499\":1}}],[\"opsforhah\",{\"1\":{\"720\":1}}],[\"opsforlist\",{\"1\":{\"720\":1}}],[\"opsforvalue\",{\"1\":{\"720\":3}}],[\"ops\",{\"1\":{\"568\":2,\"1498\":2}}],[\"opevaluateparallel\",{\"1\":{\"1500\":1}}],[\"operands\",{\"1\":{\"1478\":9}}],[\"operating\",{\"1\":{\"1497\":1}}],[\"operation<\",{\"1\":{\"1485\":1}}],[\"operations\",{\"1\":{\"1485\":2,\"1492\":2,\"1493\":1,\"1496\":8,\"1497\":3,\"1498\":7,\"1500\":5}}],[\"operation\",{\"1\":{\"708\":1,\"1474\":14,\"1478\":2,\"1485\":3,\"1490\":1,\"1492\":7,\"1494\":1,\"1495\":3,\"1496\":4,\"1497\":1,\"1498\":7,\"1499\":6,\"1500\":12}}],[\"operates\",{\"1\":{\"1495\":2}}],[\"operated\",{\"1\":{\"1487\":1,\"1496\":1,\"1499\":1}}],[\"operate\",{\"1\":{\"1474\":2,\"1497\":1}}],[\"operator\",{\"1\":{\"503\":1,\"505\":3,\"1478\":1}}],[\"operration\",{\"1\":{\"715\":1}}],[\"openjdk\",{\"1\":{\"1497\":2}}],[\"opening\",{\"1\":{\"568\":1}}],[\"open\",{\"1\":{\"562\":1,\"671\":1,\"1410\":1,\"1411\":1,\"1451\":4,\"1452\":2,\"1464\":2,\"1465\":2}}],[\"optional\",{\"1\":{\"1492\":1,\"1493\":1,\"1525\":1}}],[\"optionally\",{\"1\":{\"1492\":2,\"1500\":1}}],[\"optionalint\",{\"1\":{\"1487\":2}}],[\"options\",{\"1\":{\"566\":1}}],[\"optimize\",{\"1\":{\"1492\":1,\"1497\":1,\"1500\":1}}],[\"optimizer\",{\"1\":{\"491\":3,\"541\":1,\"542\":1,\"558\":4,\"656\":6,\"657\":4,\"681\":2,\"694\":1}}],[\"optimization\",{\"1\":{\"656\":2,\"657\":4,\"1498\":1}}],[\"optimization这个部分的chosen=true\",{\"1\":{\"558\":1}}],[\"optimizing\",{\"1\":{\"568\":1}}],[\"opts\",{\"1\":{\"566\":1}}],[\"opt\",{\"1\":{\"325\":4}}],[\"onrefresh\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"onto\",{\"1\":{\"1499\":2}}],[\"onclose\",{\"1\":{\"1496\":7}}],[\"once\",{\"1\":{\"1492\":2,\"1496\":1}}],[\"ondata\",{\"1\":{\"1398\":1}}],[\"ongl表达式\",{\"1\":{\"807\":1}}],[\"on\",{\"0\":{\"1404\":1},\"1\":{\"498\":2,\"499\":2,\"500\":2,\"515\":1,\"531\":2,\"538\":1,\"539\":1,\"540\":1,\"544\":2,\"546\":1,\"568\":1,\"615\":1,\"646\":1,\"656\":2,\"659\":1,\"661\":1,\"662\":1,\"692\":2,\"725\":1,\"1357\":1,\"1404\":11,\"1468\":2,\"1471\":3,\"1474\":1,\"1476\":2,\"1485\":2,\"1490\":1,\"1492\":6,\"1495\":3,\"1496\":5,\"1497\":8,\"1498\":1,\"1500\":4,\"1524\":6,\"1525\":3,\"1567\":1}}],[\"one让自己变成主机\",{\"1\":{\"748\":1}}],[\"one\",{\"1\":{\"385\":1,\"748\":1,\"1471\":4,\"1475\":2,\"1476\":2,\"1485\":2,\"1492\":3,\"1495\":3,\"1496\":1,\"1497\":4,\"1500\":2,\"1524\":1,\"1525\":1}}],[\"onlyifabsent\",{\"1\":{\"1426\":2,\"1430\":2,\"1431\":3}}],[\"only\",{\"1\":{\"385\":1,\"566\":1,\"656\":1,\"728\":1,\"748\":2,\"1464\":1,\"1492\":2,\"1494\":2,\"1496\":5,\"1497\":4,\"1498\":4,\"1500\":1,\"1525\":1,\"1532\":2}}],[\"o\",{\"1\":{\"310\":2,\"353\":2,\"366\":1,\"429\":1,\"522\":1,\"525\":1,\"726\":2,\"1423\":1,\"1434\":4,\"1453\":4,\"1496\":1,\"1524\":1,\"1528\":1,\"1531\":1,\"1567\":5}}],[\"owneristhread\",{\"1\":{\"1360\":1}}],[\"owner\",{\"1\":{\"6\":1,\"1360\":2}}],[\"ofref<>\",{\"1\":{\"1500\":1}}],[\"ofdouble\",{\"1\":{\"1497\":1}}],[\"ofprimitive<integer\",{\"1\":{\"1497\":1}}],[\"ofprimitive<t\",{\"1\":{\"1497\":2}}],[\"ofint>\",{\"1\":{\"1497\":1}}],[\"ofint\",{\"1\":{\"1497\":11}}],[\"often\",{\"1\":{\"1492\":1,\"1496\":1,\"1497\":2,\"1498\":1,\"1524\":1}}],[\"offset\",{\"1\":{\"707\":1,\"715\":3,\"746\":3,\"1356\":3}}],[\"offset和auto\",{\"1\":{\"628\":1}}],[\"offset开始的值\",{\"1\":{\"707\":1}}],[\"offset开始\",{\"1\":{\"628\":1}}],[\"off\",{\"1\":{\"565\":1,\"568\":1,\"1497\":3,\"1524\":1}}],[\"offers\",{\"1\":{\"1500\":1}}],[\"offer方法则会返回false\",{\"1\":{\"1353\":1}}],[\"offer方法和add方法的区别在于\",{\"1\":{\"1353\":1}}],[\"offer\",{\"1\":{\"393\":2,\"396\":1,\"401\":3,\"402\":3,\"403\":3,\"404\":3,\"411\":3,\"1353\":1,\"1377\":1,\"1378\":5,\"1495\":1,\"1496\":1,\"1567\":6}}],[\"of\",{\"1\":{\"4\":1,\"325\":1,\"491\":4,\"492\":1,\"558\":2,\"566\":3,\"604\":1,\"605\":4,\"616\":1,\"657\":2,\"695\":1,\"708\":1,\"717\":2,\"1357\":3,\"1471\":16,\"1472\":4,\"1474\":2,\"1475\":39,\"1476\":26,\"1477\":3,\"1478\":19,\"1484\":6,\"1485\":10,\"1486\":6,\"1490\":3,\"1491\":1,\"1492\":26,\"1493\":5,\"1494\":6,\"1495\":14,\"1496\":15,\"1497\":74,\"1498\":17,\"1499\":4,\"1500\":27,\"1524\":16,\"1525\":2,\"1532\":2,\"1567\":1}}],[\"oracle\",{\"1\":{\"1504\":1,\"1852\":1}}],[\"oracle数据库的默认隔离级别是\",{\"1\":{\"570\":1}}],[\"origin\",{\"1\":{\"1497\":13}}],[\"originating\",{\"1\":{\"1492\":1}}],[\"originalbeanname\",{\"1\":{\"1524\":1}}],[\"original\",{\"1\":{\"656\":3,\"1497\":1,\"1524\":1}}],[\"ored\",{\"1\":{\"1476\":2,\"1497\":1}}],[\"org\",{\"1\":{\"806\":4,\"1497\":1,\"1509\":5,\"1514\":2,\"1525\":2,\"1529\":2,\"1532\":1,\"1534\":5,\"1535\":2}}],[\"ordinary\",{\"1\":{\"579\":1}}],[\"order来指定order的值\",{\"1\":{\"1518\":1}}],[\"order注解或实现ordered接口来执行值进行比较\",{\"1\":{\"1518\":1}}],[\"ordercomparator是spring所提供的一种比较器\",{\"1\":{\"1518\":1}}],[\"ordercomparator\",{\"0\":{\"1518\":1}}],[\"ordereventproducer\",{\"1\":{\"1398\":2}}],[\"ordereventhandler\",{\"1\":{\"1398\":5}}],[\"orderevent\",{\"1\":{\"1398\":1}}],[\"ordered\",{\"1\":{\"340\":1,\"656\":1,\"1486\":2,\"1494\":1,\"1497\":8,\"1500\":5}}],[\"ordering\",{\"1\":{\"656\":2,\"1497\":1}}],[\"order表示根据同时进入prepare和commit来判断是否可以并行的策略\",{\"1\":{\"602\":1}}],[\"order\",{\"0\":{\"490\":1,\"556\":1},\"1\":{\"339\":3,\"467\":2,\"484\":1,\"485\":4,\"490\":1,\"491\":1,\"498\":3,\"515\":8,\"548\":3,\"551\":1,\"553\":2,\"556\":1,\"557\":1,\"558\":3,\"566\":2,\"568\":2,\"656\":9,\"657\":2,\"659\":4,\"681\":5,\"684\":10,\"685\":2,\"686\":12,\"688\":3,\"690\":17,\"691\":14,\"692\":26,\"695\":6,\"696\":2,\"1472\":4,\"1488\":1,\"1491\":4,\"1492\":2,\"1494\":2,\"1495\":1,\"1497\":8,\"1499\":1,\"1500\":5,\"1524\":2,\"1540\":1}}],[\"or\",{\"0\":{\"529\":1},\"1\":{\"3\":2,\"356\":1,\"503\":2,\"567\":1,\"656\":1,\"706\":1,\"709\":1,\"715\":1,\"717\":1,\"1357\":1,\"1471\":10,\"1472\":2,\"1476\":8,\"1477\":2,\"1487\":1,\"1492\":12,\"1495\":1,\"1496\":14,\"1497\":27,\"1498\":10,\"1499\":2,\"1500\":8,\"1524\":1,\"1535\":1}}],[\"h5dpvd6sy8uw\",{\"1\":{\"1850\":1}}],[\"href=\",{\"1\":{\"1474\":1,\"1475\":3,\"1476\":2,\"1477\":1,\"1478\":1,\"1485\":8}}],[\"hpp\",{\"1\":{\"1356\":1}}],[\"hyperloglog底层使用string\",{\"1\":{\"714\":1}}],[\"hyperloglog就能帮助我们利用最小的空间完成\",{\"1\":{\"714\":1}}],[\"hyperloglog\",{\"0\":{\"714\":1},\"1\":{\"714\":8}}],[\"hyperloglogs等数据类型\",{\"1\":{\"705\":1}}],[\"hscan\",{\"1\":{\"710\":1}}],[\"hsetnx\",{\"1\":{\"710\":5}}],[\"hset\",{\"1\":{\"710\":5}}],[\"hdel\",{\"1\":{\"710\":3}}],[\"hvals\",{\"1\":{\"710\":3}}],[\"hlen\",{\"1\":{\"710\":3}}],[\"hkeys\",{\"1\":{\"710\":4}}],[\"hk−1​+f\",{\"1\":{\"431\":1}}],[\"hk−1​\",{\"1\":{\"431\":1}}],[\"hmget\",{\"1\":{\"710\":3}}],[\"hmset\",{\"1\":{\"710\":3}}],[\"hotswap\",{\"1\":{\"1571\":1}}],[\"hotspot的算法实现细节\",{\"0\":{\"1635\":1}}],[\"hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上\",{\"1\":{\"1365\":1}}],[\"hotspot虚拟机对象\",{\"0\":{\"1587\":1}}],[\"hotspot虚拟机在启动后有4s的延迟才会对每个新建的对象开启偏向锁模式\",{\"1\":{\"1362\":1}}],[\"hotspot虚拟机的对象头包括\",{\"1\":{\"1361\":1}}],[\"hotspot虚拟机中\",{\"1\":{\"1361\":1}}],[\"hotspot\",{\"1\":{\"1356\":2}}],[\"how\",{\"1\":{\"1497\":1,\"1500\":2}}],[\"however\",{\"1\":{\"1492\":1,\"1496\":2,\"1497\":3}}],[\"hold\",{\"1\":{\"1496\":1}}],[\"holding\",{\"1\":{\"708\":1}}],[\"hoare模型和mesa模型\",{\"1\":{\"1360\":1}}],[\"host>\",{\"1\":{\"1561\":1}}],[\"host\",{\"1\":{\"747\":1,\"1450\":2,\"1451\":2,\"1452\":2}}],[\"host=39\",{\"1\":{\"720\":1}}],[\"host=$host\",{\"1\":{\"604\":1,\"605\":1}}],[\"hostname\",{\"1\":{\"566\":2}}],[\"hh\",{\"1\":{\"666\":3,\"1405\":1}}],[\"hibernate\",{\"1\":{\"1857\":2}}],[\"hikaricp\",{\"1\":{\"1852\":1}}],[\"hierachicalbeanfactory\",{\"1\":{\"1514\":1}}],[\"hierarchicalbeanfactory\",{\"1\":{\"1513\":1}}],[\"highly\",{\"1\":{\"1497\":2}}],[\"hidden\",{\"1\":{\"1492\":1}}],[\"hi\",{\"1\":{\"1486\":1}}],[\"hitail\",{\"1\":{\"1427\":6}}],[\"hihead\",{\"1\":{\"1427\":3}}],[\"histlen\",{\"1\":{\"746\":1}}],[\"hincrbyfloat\",{\"1\":{\"710\":3}}],[\"hincrby\",{\"1\":{\"710\":4}}],[\"hints\",{\"1\":{\"1492\":1}}],[\"hint\",{\"1\":{\"555\":1}}],[\"hire\",{\"1\":{\"647\":3,\"655\":3}}],[\"h127\",{\"1\":{\"591\":1}}],[\"h1​\",{\"1\":{\"431\":2}}],[\"hao134838\",{\"1\":{\"1526\":1}}],[\"half\",{\"1\":{\"1497\":2}}],[\"having\",{\"1\":{\"1497\":1}}],[\"have\",{\"1\":{\"457\":1,\"1471\":4,\"1472\":2,\"1492\":3,\"1496\":2,\"1497\":4,\"1500\":2,\"1524\":2,\"1525\":1,\"1567\":2}}],[\"happens\",{\"1\":{\"1492\":1,\"1500\":1}}],[\"handling\",{\"1\":{\"1527\":1}}],[\"handles\",{\"1\":{\"1496\":1}}],[\"handle的本意是把柄\",{\"1\":{\"1438\":1}}],[\"handleeventswithworkerpool\",{\"1\":{\"1398\":1}}],[\"handleeventswith\",{\"1\":{\"1398\":2}}],[\"handlenode\",{\"1\":{\"806\":1}}],[\"handlertypes执行的接口的实现类\",{\"1\":{\"1535\":1}}],[\"handlertypes\",{\"1\":{\"1535\":1}}],[\"handleradapter\",{\"1\":{\"1534\":2}}],[\"handleradapter的典型实现\",{\"1\":{\"1534\":1}}],[\"handlermapping\",{\"1\":{\"1534\":1}}],[\"handlermapping的典型实现\",{\"1\":{\"1534\":1}}],[\"handlerinterceptor\",{\"1\":{\"1534\":4}}],[\"handlerkey代码如下\",{\"1\":{\"1451\":1}}],[\"handlerkey\",{\"1\":{\"1451\":2}}],[\"handler\",{\"1\":{\"806\":3,\"1353\":2,\"1387\":1,\"1470\":1,\"1534\":8}}],[\"handle\",{\"1\":{\"740\":3,\"1451\":3}}],[\"handoff\",{\"1\":{\"1497\":1}}],[\"hands\",{\"1\":{\"1497\":1}}],[\"hand\",{\"1\":{\"1497\":1}}],[\"hangzhou\",{\"1\":{\"713\":1}}],[\"hanmei\",{\"1\":{\"672\":1}}],[\"hanmeimei\",{\"1\":{\"647\":1,\"655\":1}}],[\"ha系统就会开始工作\",{\"1\":{\"625\":1}}],[\"ha系统要切换b作为主库\",{\"1\":{\"596\":1}}],[\"hassuspendingflowreturntype\",{\"1\":{\"1532\":3}}],[\"hasmatchingintroductions\",{\"1\":{\"1531\":1}}],[\"hasintroductions\",{\"1\":{\"1531\":4}}],[\"hasinstawarebpps\",{\"1\":{\"1524\":2}}],[\"hasinstantiationawarebeanpostprocessors\",{\"1\":{\"1524\":3}}],[\"hasbeanfactory\",{\"1\":{\"1528\":1}}],[\"hasbeanclass\",{\"1\":{\"1524\":1}}],[\"hasqualifier\",{\"1\":{\"1525\":1}}],[\"haspropertyvalues\",{\"1\":{\"1524\":2}}],[\"haspathsum\",{\"1\":{\"412\":3}}],[\"hasdependentbean\",{\"1\":{\"1524\":1}}],[\"haslength\",{\"1\":{\"1524\":2,\"1535\":1}}],[\"hasannotatedmethods\",{\"1\":{\"1524\":1}}],[\"hasconstructorargumentvalues\",{\"1\":{\"1527\":1}}],[\"hascharacteristics\",{\"1\":{\"1497\":1}}],[\"hascycle\",{\"1\":{\"373\":2}}],[\"has\",{\"1\":{\"1471\":2,\"1487\":1,\"1492\":1,\"1494\":1,\"1496\":1,\"1497\":7,\"1499\":1,\"1500\":4,\"1524\":2}}],[\"hasremaining\",{\"1\":{\"1452\":1}}],[\"hasnext\",{\"1\":{\"1451\":2,\"1486\":1,\"1497\":1,\"1499\":1}}],[\"hasword\",{\"1\":{\"302\":2}}],[\"hashentry<k\",{\"1\":{\"1430\":5}}],[\"hashentry中\",{\"1\":{\"1430\":1}}],[\"hash的value\",{\"1\":{\"720\":1}}],[\"hash的key\",{\"1\":{\"720\":1}}],[\"hash更适合于对象的存储\",{\"1\":{\"710\":1}}],[\"hash变更的数据user\",{\"1\":{\"710\":1}}],[\"hash特别适合用于存储对象\",{\"1\":{\"710\":1}}],[\"hash冲突问题\",{\"1\":{\"641\":1}}],[\"hash表\",{\"1\":{\"638\":1}}],[\"hashtable的默认构造函数\",{\"1\":{\"1432\":1}}],[\"hashtable底层基于数组与链表实现\",{\"1\":{\"1432\":1}}],[\"hashtable源码分析\",{\"0\":{\"1432\":1}}],[\"hashtable是历史遗留类\",{\"1\":{\"1421\":1}}],[\"hashtable是基于方法级别的synchronized的来实现的\",{\"1\":{\"1352\":1}}],[\"hashtable和concurrenthashmap\",{\"1\":{\"1352\":1}}],[\"hashtable\",{\"1\":{\"387\":6,\"1417\":1,\"1421\":1}}],[\"hashset是调用hashmap的put\",{\"1\":{\"1434\":1}}],[\"hashset实现了set接口\",{\"1\":{\"1434\":1}}],[\"hashset实现原理\",{\"0\":{\"45\":1}}],[\"hashset源码分析\",{\"0\":{\"1434\":1}}],[\"hashset\",{\"1\":{\"1416\":1,\"1494\":3,\"1495\":1}}],[\"hashset<integer>\",{\"1\":{\"417\":3}}],[\"hashset<>\",{\"1\":{\"381\":1,\"441\":1,\"1494\":1}}],[\"hash\",{\"0\":{\"545\":1,\"641\":1,\"710\":1},\"1\":{\"310\":1,\"332\":1,\"598\":2,\"710\":2,\"1423\":2,\"1425\":1,\"1426\":11,\"1427\":2,\"1430\":10,\"1431\":11}}],[\"hashcode\",{\"1\":{\"302\":1,\"1361\":1,\"1423\":1,\"1425\":3,\"1426\":1,\"1430\":1,\"1431\":1}}],[\"hashcode和equals的作用\",{\"0\":{\"24\":1}}],[\"hashmapinfiniteloop\",{\"1\":{\"1428\":1}}],[\"hashmap线程不安全的主要原因是在多线程的使用场景下可能会造成死循环\",{\"1\":{\"1428\":1}}],[\"hashmap定位数组索引位置的方法\",{\"1\":{\"1425\":1}}],[\"hashmap采用这种设计\",{\"1\":{\"1423\":1}}],[\"hashmap就需要重新resize\",{\"1\":{\"1423\":1}}],[\"hashmap就是采用了链地址法\",{\"1\":{\"1423\":1}}],[\"hashmap就是使用哈希表来存储的\",{\"1\":{\"1423\":1}}],[\"hashmap中实际存在的键值对数量\",{\"1\":{\"1423\":1}}],[\"hashmap中有几个非常重要的属性\",{\"1\":{\"1423\":1}}],[\"hashmap内部结构发生变化的次数\",{\"1\":{\"1423\":1}}],[\"hashmap是可以允许为空的\",{\"1\":{\"1431\":1}}],[\"hashmap是数组+链表+红黑树\",{\"1\":{\"1423\":1}}],[\"hashmap是java程序员使用频率最高的用于映射\",{\"1\":{\"1422\":1}}],[\"hashmap原理分析\",{\"0\":{\"1422\":1}}],[\"hashmap非线程安全\",{\"1\":{\"1421\":1}}],[\"hashmap最多只允许一条记录的键位null\",{\"1\":{\"1421\":1}}],[\"hashmap插入元素的方式\",{\"1\":{\"1352\":1}}],[\"hashmap的table属性引用新的entry数组\",{\"1\":{\"1427\":1}}],[\"hashmap的底层存储结构\",{\"1\":{\"1352\":1}}],[\"hashmap的特点\",{\"1\":{\"1352\":1}}],[\"hashmap底层原理\",{\"0\":{\"1352\":1}}],[\"hashmap\",{\"1\":{\"806\":2,\"1352\":2,\"1417\":1,\"1421\":1,\"1495\":1}}],[\"hashmap<integer\",{\"1\":{\"1428\":2}}],[\"hashmap<character\",{\"1\":{\"387\":1}}],[\"hashmap<string\",{\"1\":{\"380\":1}}],[\"hashmap<>\",{\"1\":{\"359\":1,\"380\":1,\"381\":1,\"386\":1,\"387\":1,\"400\":1,\"1494\":1,\"1515\":1}}],[\"hashmap在并发编程环境下有什么问题\",{\"0\":{\"41\":1}}],[\"hashmap不使用红黑树\",{\"0\":{\"38\":1}}],[\"hashmap为什么扩容为2倍\",{\"0\":{\"34\":1}}],[\"hashmap实现原理\",{\"0\":{\"33\":1}}],[\"h$ip\",{\"1\":{\"455\":1}}],[\"hn−1​\",{\"1\":{\"431\":1}}],[\"h\",{\"1\":{\"368\":2,\"566\":1,\"714\":1,\"736\":1,\"1380\":4,\"1425\":11}}],[\"hgetall\",{\"1\":{\"710\":3}}],[\"hget\",{\"1\":{\"710\":3}}],[\"hg\",{\"1\":{\"368\":2}}],[\"hexists\",{\"1\":{\"710\":4}}],[\"held\",{\"1\":{\"1497\":2}}],[\"hello=hello\",{\"1\":{\"1494\":4}}],[\"helloworld\",{\"1\":{\"1485\":3,\"1486\":3}}],[\"hellohello\",{\"1\":{\"1478\":2}}],[\"hello\",{\"1\":{\"684\":1,\"707\":6,\"719\":1,\"735\":6,\"1470\":12,\"1471\":2,\"1472\":2,\"1474\":4,\"1476\":1,\"1477\":2,\"1478\":2,\"1479\":2,\"1483\":1,\"1484\":8,\"1485\":3,\"1486\":14,\"1487\":4,\"1489\":5,\"1491\":1,\"1494\":20,\"1496\":10,\"1497\":2}}],[\"helper\",{\"1\":{\"1498\":1,\"1500\":11}}],[\"helping\",{\"1\":{\"1497\":1}}],[\"helptransfer\",{\"1\":{\"1431\":1}}],[\"help\",{\"1\":{\"566\":3}}],[\"health\",{\"1\":{\"614\":1,\"615\":4}}],[\"headfirst设计模式\",{\"1\":{\"1870\":1}}],[\"head类本身有两个泛型\",{\"1\":{\"1498\":1}}],[\"head<e\",{\"1\":{\"1498\":1}}],[\"head<>\",{\"1\":{\"1498\":1}}],[\"head是referencepipeline的一个静态内部类\",{\"1\":{\"1498\":1}}],[\"head节点本身是不存储任何元素的\",{\"1\":{\"1380\":1}}],[\"header\",{\"1\":{\"679\":1,\"1360\":1,\"1361\":1,\"1496\":1}}],[\"headb\",{\"1\":{\"376\":4}}],[\"heada\",{\"1\":{\"376\":4}}],[\"head\",{\"1\":{\"371\":3,\"372\":2,\"373\":10,\"375\":2,\"377\":4,\"1380\":4,\"1498\":5,\"1500\":1,\"1501\":1}}],[\"heap\",{\"1\":{\"353\":1,\"568\":1}}],[\"height\",{\"1\":{\"368\":13,\"408\":4}}],[\"heights\",{\"1\":{\"367\":9}}],[\"here\",{\"1\":{\"4\":1,\"392\":1,\"1496\":1,\"1497\":3,\"1500\":1,\"1524\":1,\"1567\":1}}],[\"ht放到32个分库中的某一个上\",{\"1\":{\"548\":1}}],[\"ht表中\",{\"1\":{\"548\":1}}],[\"ht\",{\"1\":{\"548\":5}}],[\"http服务器+serverlet容器\",{\"1\":{\"1561\":1}}],[\"httpmessageconverter\",{\"1\":{\"1534\":1}}],[\"httprequesthandleradapter\",{\"1\":{\"1534\":1}}],[\"http2可以支持同时发在一个socket上送多个请求\",{\"1\":{\"804\":1}}],[\"http2原理解析\",{\"0\":{\"804\":1}}],[\"http\",{\"1\":{\"668\":1,\"677\":1,\"1534\":1,\"1540\":1,\"1565\":1,\"1853\":1}}],[\"httpservletresponse\",{\"1\":{\"1534\":3}}],[\"httpservletrequest\",{\"1\":{\"1534\":3}}],[\"https\",{\"1\":{\"446\":1,\"449\":1,\"467\":1,\"654\":2,\"698\":1,\"796\":1,\"800\":2,\"806\":1,\"1371\":1,\"1376\":1,\"1428\":1,\"1503\":1,\"1504\":1,\"1526\":1,\"1529\":1,\"1530\":1,\"1534\":1,\"1847\":3,\"1850\":3,\"1852\":2,\"1853\":2,\"1856\":1,\"1858\":1,\"1859\":3,\"1860\":1,\"1861\":1,\"1863\":2,\"1864\":1,\"1865\":3,\"1867\":1,\"1868\":1,\"1869\":1,\"1870\":2}}],[\"http和https的区别\",{\"0\":{\"99\":1}}],[\"html\",{\"1\":{\"2\":1,\"446\":1,\"449\":1,\"654\":1,\"796\":1,\"800\":1,\"1474\":1,\"1475\":3,\"1476\":2,\"1477\":1,\"1478\":1,\"1485\":8,\"1504\":1,\"1847\":1,\"1853\":1,\"1855\":1}}],[\"pwd=h4v2\",{\"1\":{\"1850\":1}}],[\"ptm\",{\"1\":{\"1532\":5}}],[\"pthread\",{\"1\":{\"1360\":1,\"1407\":2}}],[\"pd\",{\"1\":{\"1525\":2}}],[\"pvstouse\",{\"1\":{\"1524\":5}}],[\"pvs\",{\"1\":{\"1524\":11,\"1525\":4}}],[\"pbd\",{\"1\":{\"1524\":4}}],[\"p=29\",{\"1\":{\"1858\":1}}],[\"p=p\",{\"1\":{\"1500\":1}}],[\"p=abstractpipeline\",{\"1\":{\"1500\":1}}],[\"platform\",{\"1\":{\"1561\":1}}],[\"platformtransactionmanager\",{\"1\":{\"1532\":1}}],[\"placed\",{\"1\":{\"1427\":1}}],[\"place\",{\"1\":{\"1357\":1,\"1500\":1}}],[\"plan\",{\"1\":{\"656\":8}}],[\"plans\",{\"1\":{\"656\":2}}],[\"plugin\",{\"0\":{\"1041\":1,\"1042\":1,\"1043\":1}}],[\"psubscribe\",{\"1\":{\"734\":1}}],[\"psetex\",{\"1\":{\"707\":1}}],[\"pfmerge\",{\"1\":{\"714\":3}}],[\"pfcount\",{\"1\":{\"714\":5}}],[\"pfadd\",{\"1\":{\"714\":4}}],[\"pfx04表示的是insert\",{\"1\":{\"695\":1}}],[\"pfx03表示的是insert\",{\"1\":{\"695\":1}}],[\"pfx02表示insert\",{\"1\":{\"695\":1}}],[\"pfx01表示的是统计insert\",{\"1\":{\"695\":1}}],[\"pfxnn\",{\"1\":{\"695\":1}}],[\"pct\",{\"1\":{\"656\":1}}],[\"pick\",{\"1\":{\"1524\":1}}],[\"pipelinehelper描述了一个流管道最开始的阶段\",{\"1\":{\"1500\":1}}],[\"pipelinehelper\",{\"1\":{\"1500\":10}}],[\"pipelinehelper<t>\",{\"1\":{\"1500\":2}}],[\"pipelinehelper<e\",{\"1\":{\"1500\":3}}],[\"pipeline起作用\",{\"1\":{\"1498\":2}}],[\"pipeline源码分析\",{\"0\":{\"1498\":1}}],[\"pipelines\",{\"1\":{\"1495\":1,\"1496\":2,\"1498\":1,\"1499\":1,\"1500\":1}}],[\"pipeline\",{\"1\":{\"1494\":2,\"1496\":5,\"1498\":18,\"1499\":4,\"1500\":14}}],[\"pipeline有什么好处\",{\"0\":{\"151\":1}}],[\"pid文件名\",{\"1\":{\"746\":1}}],[\"pid并不是让进程直接停止\",{\"1\":{\"618\":1}}],[\"ping\",{\"1\":{\"719\":1}}],[\"pivot\",{\"1\":{\"708\":1,\"1492\":1}}],[\"png\",{\"1\":{\"609\":1,\"616\":1}}],[\"p$pwd\",{\"1\":{\"591\":1}}],[\"p$port\",{\"1\":{\"455\":1}}],[\"phase\",{\"1\":{\"1524\":1}}],[\"phantom\",{\"1\":{\"570\":1,\"669\":1}}],[\"phone\",{\"1\":{\"500\":2}}],[\"pms\",{\"1\":{\"466\":2,\"467\":10}}],[\"p后面写在命令行中\",{\"1\":{\"455\":1}}],[\"pqrs\",{\"1\":{\"400\":1}}],[\"p2\",{\"1\":{\"393\":4}}],[\"p13000\",{\"1\":{\"591\":1}}],[\"p1\",{\"1\":{\"393\":4}}],[\"people\",{\"1\":{\"1493\":2,\"1495\":5}}],[\"peek\",{\"1\":{\"386\":1,\"392\":1,\"393\":3,\"1377\":1,\"1378\":2}}],[\"permsize代表永久带的初始容量\",{\"1\":{\"1541\":1}}],[\"permsize参数意思不一样\",{\"1\":{\"1541\":1}}],[\"permitted\",{\"1\":{\"1498\":1}}],[\"permissions\",{\"1\":{\"568\":1}}],[\"perfcounter\",{\"1\":{\"1540\":3}}],[\"perform\",{\"1\":{\"1474\":1,\"1492\":4,\"1493\":1,\"1495\":1,\"1496\":2,\"1497\":1,\"1500\":3}}],[\"performing\",{\"1\":{\"1474\":2,\"1492\":2,\"1495\":1}}],[\"performed\",{\"1\":{\"1472\":3,\"1474\":1,\"1492\":1,\"1496\":2,\"1497\":3,\"1499\":1}}],[\"performs\",{\"1\":{\"1472\":2,\"1474\":3,\"1485\":2,\"1495\":1,\"1497\":2,\"1499\":1,\"1500\":1}}],[\"performance\",{\"1\":{\"491\":2,\"616\":2,\"1492\":1,\"1495\":1,\"1497\":2}}],[\"personlist\",{\"1\":{\"1475\":2}}],[\"persons2\",{\"1\":{\"1475\":2}}],[\"persons\",{\"1\":{\"1475\":6}}],[\"person3\",{\"1\":{\"1475\":2}}],[\"person2\",{\"1\":{\"1475\":2}}],[\"person1\",{\"1\":{\"1475\":2}}],[\"person\",{\"1\":{\"1475\":10,\"1493\":2,\"1495\":4}}],[\"persontest\",{\"1\":{\"1475\":5}}],[\"persistent的值作为该属性的值\",{\"1\":{\"695\":1}}],[\"persistent的值来选择\",{\"1\":{\"484\":1}}],[\"persistent属性\",{\"1\":{\"695\":1}}],[\"persistent属性来指明该表的统计数据存储方式\",{\"1\":{\"695\":1}}],[\"persistent=0时\",{\"1\":{\"695\":1}}],[\"persistent=1时\",{\"1\":{\"695\":1}}],[\"persistent\",{\"1\":{\"695\":6}}],[\"perpetualcache\",{\"1\":{\"806\":1}}],[\"per\",{\"0\":{\"1410\":1},\"1\":{\"3\":1,\"690\":3,\"692\":6,\"1410\":4,\"1497\":2}}],[\"p\",{\"1\":{\"332\":2,\"398\":8,\"428\":4,\"455\":1,\"561\":5,\"714\":1,\"1356\":2,\"1426\":10,\"1428\":1,\"1431\":4,\"1476\":2,\"1494\":2,\"1499\":4,\"1500\":3}}],[\"pom\",{\"1\":{\"1858\":2}}],[\"poor\",{\"1\":{\"1497\":1}}],[\"pool连接池\",{\"1\":{\"720\":1}}],[\"pool在这段时间内\",{\"1\":{\"543\":1}}],[\"pool\",{\"1\":{\"482\":1}}],[\"pool里的内存\",{\"1\":{\"480\":1}}],[\"pool的热数据被淘汰\",{\"1\":{\"543\":1}}],[\"pool的正常运作\",{\"1\":{\"543\":1}}],[\"pool的命中率影响就不大\",{\"1\":{\"543\":1}}],[\"pool的lru算法做了优化\",{\"1\":{\"543\":1}}],[\"pool的50\",{\"1\":{\"480\":1}}],[\"pool的\",{\"1\":{\"480\":1}}],[\"policy\",{\"1\":{\"1497\":2}}],[\"poll返回后\",{\"1\":{\"1447\":1}}],[\"poll使用一个pollfd的指针实现\",{\"1\":{\"1447\":1}}],[\"pollfd结构包含了要监视的event和发生的event\",{\"1\":{\"1447\":1}}],[\"pollfd\",{\"1\":{\"1447\":2}}],[\"poll和epoll都是io多路复用的机制\",{\"1\":{\"1445\":1}}],[\"poll\",{\"0\":{\"98\":1,\"1445\":1,\"1447\":1},\"1\":{\"393\":1,\"396\":1,\"401\":1,\"402\":1,\"403\":1,\"404\":1,\"411\":1,\"1377\":1,\"1378\":5,\"1438\":1,\"1442\":2,\"1445\":1,\"1447\":1,\"1500\":1}}],[\"power\",{\"1\":{\"1357\":1,\"1497\":1}}],[\"points\",{\"1\":{\"1500\":1}}],[\"point\",{\"1\":{\"1497\":2,\"1498\":1,\"1500\":1,\"1524\":2,\"1527\":1,\"1531\":1}}],[\"pointcutadvisor\",{\"1\":{\"1531\":6}}],[\"pointcutadvisor接口\",{\"0\":{\"955\":1}}],[\"pointcut\",{\"0\":{\"948\":1,\"981\":1},\"1\":{\"1531\":3}}],[\"pointcut便利实现\",{\"0\":{\"947\":1}}],[\"pointcut组合实现\",{\"0\":{\"946\":1}}],[\"pointcut指令与表达式\",{\"0\":{\"926\":1}}],[\"pointer\",{\"1\":{\"679\":1,\"1361\":1,\"1479\":1}}],[\"portion\",{\"1\":{\"1498\":1}}],[\"port是用来和旧的master和新的master\",{\"1\":{\"761\":1}}],[\"port>\",{\"1\":{\"761\":3}}],[\"port\",{\"1\":{\"761\":3,\"1450\":6,\"1451\":4,\"1452\":4}}],[\"port就可以为从机配置主机了\",{\"1\":{\"747\":1}}],[\"port=6379\",{\"1\":{\"720\":1}}],[\"port=$port\",{\"1\":{\"604\":1,\"605\":1}}],[\"pong\",{\"1\":{\"719\":1}}],[\"potential\",{\"1\":{\"656\":2,\"1497\":1,\"1498\":1,\"1524\":1}}],[\"possibly\",{\"1\":{\"1497\":1}}],[\"possible\",{\"1\":{\"466\":2,\"467\":7,\"498\":1,\"527\":2,\"690\":1,\"692\":2,\"1496\":1,\"1497\":1}}],[\"position`\",{\"1\":{\"647\":1,\"655\":1}}],[\"position从误操作之后的日志继续执行\",{\"1\":{\"622\":1}}],[\"position参数执行到误操作之前的日志\",{\"1\":{\"622\":1}}],[\"position\",{\"1\":{\"610\":1,\"647\":3,\"655\":6,\"656\":5,\"657\":4,\"1486\":3}}],[\"position=1就表示这个主备关系使用的是gtid协议\",{\"1\":{\"605\":1}}],[\"position=1\",{\"1\":{\"605\":1,\"609\":1}}],[\"position=2973\",{\"1\":{\"591\":1}}],[\"position=2738\",{\"1\":{\"591\":1}}],[\"position=8900\",{\"1\":{\"591\":1}}],[\"pos这两组值完全相同\",{\"1\":{\"609\":1}}],[\"pos这两个参数了\",{\"1\":{\"605\":1}}],[\"pos这个位置的日志继续同步\",{\"1\":{\"604\":1}}],[\"pos的值并不精确\",{\"1\":{\"604\":1}}],[\"pos的值\",{\"1\":{\"604\":1}}],[\"pos后面的值\",{\"1\":{\"604\":1}}],[\"pos=$master\",{\"1\":{\"604\":1}}],[\"pos\",{\"1\":{\"508\":2,\"604\":1,\"609\":3,\"610\":4}}],[\"pos字段索引失效\",{\"1\":{\"507\":1,\"509\":1}}],[\"pos字段\",{\"1\":{\"507\":1,\"509\":1}}],[\"pos索引中的name\",{\"1\":{\"507\":2,\"509\":2}}],[\"pos索引中的name字段\",{\"1\":{\"507\":2}}],[\"pos追上了checkpoint\",{\"1\":{\"461\":1}}],[\"pos和checkpoint之间还空着的部分\",{\"1\":{\"461\":1}}],[\"pos是当前记录的位置\",{\"1\":{\"461\":1}}],[\"posthandle\",{\"1\":{\"1534\":2}}],[\"postprocesspropertyvalues\",{\"1\":{\"1524\":1}}],[\"postprocessproperties\",{\"1\":{\"1524\":2,\"1525\":1}}],[\"postprocessed\",{\"1\":{\"1524\":2}}],[\"postprocessinglock\",{\"1\":{\"1524\":1}}],[\"postprocessbeandefinition\",{\"1\":{\"1524\":1}}],[\"postprocessbeanfactory\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"postprocessbeforeinstantiation\",{\"1\":{\"1524\":1}}],[\"postprocessafterinstantiation\",{\"1\":{\"1524\":2}}],[\"postprocessmergedbeandefinition\",{\"1\":{\"1524\":1,\"1525\":1}}],[\"postgresql\",{\"1\":{\"733\":1}}],[\"post\",{\"1\":{\"339\":1,\"531\":9,\"1524\":4,\"1528\":1}}],[\"population\",{\"1\":{\"1524\":1}}],[\"populatebean\",{\"1\":{\"1524\":2}}],[\"pop\",{\"1\":{\"296\":1,\"386\":2,\"392\":4,\"395\":1,\"397\":1,\"410\":1}}],[\"punsubscribe\",{\"1\":{\"734\":1}}],[\"pubsub\",{\"1\":{\"734\":1,\"735\":1,\"736\":1}}],[\"publisher<\",{\"1\":{\"1532\":2}}],[\"publish\",{\"1\":{\"733\":1,\"734\":1,\"735\":2,\"1524\":1}}],[\"public\",{\"1\":{\"285\":1,\"288\":1,\"296\":1,\"302\":8,\"305\":1,\"311\":3,\"317\":4,\"318\":4,\"319\":6,\"329\":8,\"338\":5,\"359\":1,\"360\":1,\"361\":2,\"362\":2,\"363\":1,\"364\":1,\"365\":1,\"366\":2,\"367\":1,\"368\":1,\"371\":1,\"372\":1,\"373\":2,\"375\":1,\"376\":2,\"377\":2,\"380\":1,\"381\":2,\"383\":1,\"384\":1,\"385\":3,\"386\":2,\"387\":2,\"388\":1,\"389\":1,\"392\":5,\"393\":1,\"395\":4,\"396\":2,\"397\":2,\"398\":1,\"399\":2,\"400\":2,\"401\":1,\"402\":1,\"403\":2,\"404\":1,\"405\":1,\"406\":2,\"407\":1,\"408\":1,\"409\":3,\"410\":2,\"411\":2,\"412\":1,\"415\":2,\"417\":3,\"419\":1,\"420\":1,\"421\":1,\"422\":1,\"424\":3,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"429\":3,\"430\":2,\"431\":2,\"435\":2,\"437\":1,\"438\":2,\"439\":1,\"440\":1,\"441\":1,\"443\":1,\"719\":4,\"720\":2,\"806\":1,\"1353\":2,\"1356\":2,\"1357\":1,\"1359\":6,\"1362\":2,\"1363\":1,\"1364\":3,\"1377\":1,\"1378\":1,\"1379\":4,\"1380\":4,\"1397\":1,\"1398\":2,\"1412\":3,\"1423\":6,\"1426\":1,\"1428\":4,\"1430\":1,\"1431\":1,\"1434\":3,\"1450\":2,\"1452\":14,\"1464\":1,\"1465\":1,\"1468\":8,\"1469\":3,\"1470\":12,\"1471\":11,\"1472\":16,\"1474\":6,\"1475\":29,\"1476\":16,\"1477\":15,\"1478\":6,\"1479\":2,\"1480\":11,\"1481\":7,\"1482\":15,\"1483\":6,\"1484\":30,\"1485\":8,\"1486\":27,\"1487\":16,\"1489\":6,\"1490\":19,\"1491\":6,\"1492\":2,\"1493\":5,\"1494\":24,\"1495\":18,\"1496\":9,\"1497\":22,\"1498\":4,\"1499\":5,\"1500\":7,\"1515\":5,\"1516\":5,\"1521\":3,\"1522\":2,\"1523\":2,\"1524\":3,\"1525\":7,\"1527\":2,\"1528\":4,\"1531\":12,\"1534\":4,\"1567\":1}}],[\"pub\",{\"1\":{\"733\":2}}],[\"put顺序依次为5\",{\"1\":{\"1427\":1}}],[\"puttreeval\",{\"1\":{\"1426\":1,\"1431\":1}}],[\"putval\",{\"1\":{\"1426\":2,\"1431\":4}}],[\"put方法的整体执行过程如下图\",{\"1\":{\"1426\":1}}],[\"put方法\",{\"0\":{\"1426\":1}}],[\"putlock\",{\"1\":{\"1380\":10}}],[\"put锁会会阻塞在notfull上\",{\"1\":{\"1380\":1}}],[\"put锁\",{\"1\":{\"1380\":1}}],[\"putindex指针到数组尽头了\",{\"1\":{\"1379\":1}}],[\"putindex\",{\"1\":{\"1379\":3}}],[\"put的流程图\",{\"1\":{\"1352\":1}}],[\"put\",{\"1\":{\"311\":2,\"359\":1,\"380\":1,\"381\":1,\"386\":3,\"387\":2,\"400\":8,\"719\":2,\"1378\":3,\"1379\":1,\"1380\":1,\"1412\":1,\"1423\":1,\"1426\":1,\"1428\":3,\"1430\":3,\"1431\":1,\"1434\":1,\"1451\":2,\"1452\":2,\"1494\":1,\"1495\":1,\"1515\":1,\"1524\":2,\"1525\":1}}],[\"pushes\",{\"1\":{\"1500\":1}}],[\"pushdown\",{\"1\":{\"477\":1}}],[\"push\",{\"1\":{\"296\":3,\"386\":4,\"392\":4,\"397\":1,\"410\":3,\"708\":1}}],[\"pr\",{\"1\":{\"1532\":3}}],[\"practical\",{\"1\":{\"1497\":1}}],[\"prune\",{\"1\":{\"693\":1}}],[\"privilegedaction<object>\",{\"1\":{\"1524\":1}}],[\"privilegedaction<boolean>\",{\"1\":{\"1524\":1}}],[\"private\",{\"1\":{\"302\":2,\"311\":1,\"368\":1,\"384\":1,\"385\":1,\"398\":1,\"403\":1,\"406\":2,\"408\":1,\"409\":3,\"410\":1,\"411\":3,\"438\":1,\"720\":1,\"1352\":1,\"1359\":2,\"1379\":4,\"1380\":11,\"1383\":1,\"1412\":1,\"1419\":1,\"1428\":1,\"1431\":2,\"1434\":1,\"1450\":1,\"1451\":3,\"1452\":2,\"1477\":2,\"1480\":3,\"1482\":3,\"1490\":5,\"1491\":2,\"1493\":5,\"1494\":1,\"1495\":1,\"1497\":4,\"1498\":6,\"1515\":1,\"1524\":1,\"1525\":2}}],[\"prioritizedparameternamediscoverer\",{\"1\":{\"1525\":1}}],[\"priority注解\",{\"1\":{\"1525\":1}}],[\"priorityordered\",{\"1\":{\"1525\":1}}],[\"priorityblockingqueue即使在指定了初始容量之后\",{\"1\":{\"1386\":1}}],[\"priorityblockingqueue\",{\"0\":{\"1383\":1},\"1\":{\"1378\":2}}],[\"priorityqueue<>\",{\"1\":{\"393\":1}}],[\"priorityqueue<int\",{\"1\":{\"393\":1}}],[\"priority\",{\"1\":{\"353\":1,\"558\":1,\"657\":4,\"1525\":1}}],[\"prior\",{\"1\":{\"1497\":2}}],[\"primarily\",{\"1\":{\"1496\":1}}],[\"primary注解\",{\"1\":{\"1525\":2}}],[\"primary索引\",{\"1\":{\"695\":1}}],[\"primary\",{\"1\":{\"460\":1,\"467\":4,\"472\":2,\"473\":1,\"475\":1,\"483\":1,\"486\":1,\"490\":1,\"498\":1,\"499\":2,\"500\":1,\"503\":1,\"505\":1,\"515\":1,\"537\":1,\"541\":1,\"544\":1,\"549\":1,\"550\":1,\"551\":1,\"556\":1,\"583\":1,\"591\":1,\"596\":1,\"599\":2,\"604\":1,\"605\":1,\"613\":1,\"615\":1,\"626\":1,\"631\":3,\"643\":3,\"647\":1,\"655\":1,\"656\":1,\"660\":1,\"671\":1,\"672\":1,\"1497\":1,\"1510\":1,\"1525\":1}}],[\"primitive\",{\"1\":{\"1496\":1,\"1497\":14,\"1498\":1,\"1500\":1}}],[\"pri\",{\"1\":{\"467\":1}}],[\"prices\",{\"1\":{\"419\":6}}],[\"printstream\",{\"1\":{\"1482\":1}}],[\"printstacktrace\",{\"1\":{\"1412\":2,\"1450\":4,\"1451\":3,\"1452\":4}}],[\"printwriter\",{\"1\":{\"1450\":4}}],[\"print\",{\"1\":{\"329\":1,\"1362\":1,\"1482\":1}}],[\"println\",{\"1\":{\"329\":4,\"719\":3,\"720\":1,\"1362\":2,\"1364\":1,\"1428\":2,\"1450\":5,\"1451\":3,\"1452\":3,\"1464\":1,\"1465\":1,\"1468\":6,\"1469\":3,\"1470\":7,\"1471\":1,\"1472\":13,\"1474\":2,\"1475\":12,\"1476\":7,\"1477\":5,\"1478\":2,\"1479\":1,\"1480\":4,\"1481\":4,\"1482\":5,\"1483\":2,\"1484\":9,\"1485\":2,\"1486\":10,\"1487\":17,\"1488\":2,\"1489\":6,\"1491\":1,\"1492\":2,\"1493\":8,\"1494\":18,\"1496\":11,\"1497\":3,\"1499\":3,\"1509\":1,\"1510\":1,\"1511\":1,\"1512\":1,\"1515\":1,\"1517\":1,\"1523\":2,\"1531\":4}}],[\"pretenuresizethreshold=1000000\",{\"1\":{\"1546\":1}}],[\"prehandle\",{\"1\":{\"1534\":2}}],[\"preinstantiatesingletons\",{\"1\":{\"1524\":1}}],[\"pre>\",{\"1\":{\"1472\":1,\"1485\":3}}],[\"predefined\",{\"1\":{\"1492\":1,\"1493\":1}}],[\"predicate2\",{\"1\":{\"1476\":6}}],[\"predicate中除了抽象方法test\",{\"1\":{\"1476\":1}}],[\"predicate在集合与stream中有大量的应用\",{\"1\":{\"1476\":1}}],[\"predicatetest3\",{\"1\":{\"1476\":5}}],[\"predicatetest2\",{\"1\":{\"1476\":19}}],[\"predicatetest\",{\"1\":{\"1476\":1}}],[\"predicate代表了一个接收一个参数\",{\"1\":{\"1476\":1}}],[\"predicate这个单词本身是谓词\",{\"1\":{\"1476\":1}}],[\"predicate也是一个重要的函数式接口\",{\"1\":{\"1476\":1}}],[\"predicate\",{\"1\":{\"1476\":87,\"1495\":4,\"1496\":2}}],[\"predicate函数式接口\",{\"0\":{\"1476\":1}}],[\"predicate<date>\",{\"1\":{\"1476\":1}}],[\"predicate<integer>\",{\"1\":{\"1476\":8}}],[\"predicate<string>\",{\"1\":{\"1476\":1}}],[\"predicate<\",{\"1\":{\"1471\":2,\"1476\":4,\"1495\":2}}],[\"predicate<t>\",{\"1\":{\"1471\":5,\"1476\":9}}],[\"pred\",{\"1\":{\"1431\":2}}],[\"preserve\",{\"1\":{\"1496\":1,\"1497\":1}}],[\"preservation\",{\"1\":{\"1495\":1}}],[\"preserving\",{\"1\":{\"1494\":1}}],[\"presenting\",{\"1\":{\"1498\":1}}],[\"presented\",{\"1\":{\"1495\":1}}],[\"present\",{\"1\":{\"1434\":2,\"1471\":3,\"1490\":1,\"1495\":1}}],[\"presumed\",{\"1\":{\"1492\":1}}],[\"pressed\",{\"1\":{\"1468\":3}}],[\"press\",{\"1\":{\"735\":1}}],[\"presistent的值默认是on\",{\"1\":{\"695\":1}}],[\"presistent的值默认是off\",{\"1\":{\"695\":1}}],[\"presistent来控制到底采用哪种方式去存储统计数据\",{\"1\":{\"695\":1}}],[\"preferred\",{\"1\":{\"1527\":1}}],[\"preference\",{\"1\":{\"1497\":1}}],[\"preferable\",{\"1\":{\"1497\":1}}],[\"prefix\",{\"1\":{\"656\":2,\"690\":1,\"692\":2,\"1495\":2,\"1497\":1,\"1524\":2}}],[\"preformance\",{\"1\":{\"616\":1}}],[\"prepaer阶段\",{\"1\":{\"602\":1}}],[\"preparation\",{\"1\":{\"656\":2,\"1498\":1}}],[\"preparing\",{\"1\":{\"568\":1}}],[\"preparetransactioninfo\",{\"1\":{\"1532\":1}}],[\"preparemethodoverrides\",{\"1\":{\"1524\":1}}],[\"preparebeanfactory\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"preparerefresh\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"prepare阶段\",{\"1\":{\"588\":1}}],[\"prepare\",{\"1\":{\"559\":2,\"1524\":3}}],[\"prepare和commit\",{\"1\":{\"463\":1}}],[\"preparedata\",{\"1\":{\"288\":1}}],[\"previousinjectionpoint\",{\"1\":{\"1525\":2}}],[\"previously\",{\"1\":{\"1524\":1}}],[\"previousstage\",{\"1\":{\"1498\":2,\"1499\":9,\"1500\":2}}],[\"previous\",{\"1\":{\"717\":1,\"1360\":1,\"1492\":1,\"1498\":1,\"1524\":4}}],[\"prev\",{\"1\":{\"372\":4,\"395\":8,\"429\":3}}],[\"pre\",{\"1\":{\"339\":1,\"371\":3,\"430\":4}}],[\"prenode\",{\"1\":{\"302\":3}}],[\"programmercarl\",{\"1\":{\"1850\":1}}],[\"programming\",{\"1\":{\"325\":1}}],[\"providing\",{\"1\":{\"1499\":1}}],[\"provide\",{\"1\":{\"1492\":2,\"1496\":1,\"1497\":2,\"1500\":1}}],[\"provided\",{\"1\":{\"1486\":1,\"1496\":1,\"1497\":1,\"1500\":9}}],[\"provides\",{\"1\":{\"656\":1,\"1492\":1,\"1497\":4}}],[\"prompt\",{\"1\":{\"1496\":1}}],[\"promotion\",{\"1\":{\"1491\":1}}],[\"promise\",{\"0\":{\"860\":1}}],[\"proper\",{\"1\":{\"1524\":1}}],[\"properly\",{\"1\":{\"1492\":1}}],[\"properties\",{\"1\":{\"1492\":1,\"1497\":1,\"1524\":1}}],[\"properties资源的方式\",{\"0\":{\"1187\":1}}],[\"propertydescriptor\",{\"1\":{\"1524\":1,\"1525\":1}}],[\"propertyvalues\",{\"1\":{\"1524\":2,\"1525\":2}}],[\"propertyeditor仅仅支持string类型转换成其他的类型\",{\"1\":{\"1516\":1}}],[\"propertyeditormap\",{\"1\":{\"1515\":3}}],[\"propertyeditor>>\",{\"1\":{\"1515\":1}}],[\"propertyeditorsupport\",{\"1\":{\"1515\":1}}],[\"propertyeditor是jdk中提供的类型转化工具类\",{\"1\":{\"1515\":1}}],[\"propertyeditor\",{\"0\":{\"1515\":1}}],[\"propertyeditor的局限性\",{\"0\":{\"1246\":1}}],[\"property\",{\"1\":{\"1496\":1,\"1497\":1,\"1524\":4}}],[\"propertysource工作原理\",{\"0\":{\"1305\":1}}],[\"propagatecompletion\",{\"1\":{\"1497\":1}}],[\"propagate\",{\"1\":{\"1367\":1,\"1524\":1,\"1528\":1}}],[\"propagation\",{\"1\":{\"656\":2}}],[\"proxytransactionmanagementconfiguration是一个配置类\",{\"1\":{\"1532\":1}}],[\"proxytransactionmanagementconfiguration\",{\"1\":{\"1532\":2}}],[\"proxytest\",{\"1\":{\"1531\":1}}],[\"proxybeanmethods\",{\"1\":{\"1529\":1}}],[\"proxy\",{\"1\":{\"1524\":1,\"1531\":6}}],[\"proxyfactorybean\",{\"0\":{\"968\":1}}],[\"proxyfactory\",{\"0\":{\"967\":1},\"1\":{\"1531\":7}}],[\"proxycreatorsupport\",{\"0\":{\"965\":1}}],[\"proxy也需要有高可用架构\",{\"1\":{\"606\":1}}],[\"prototypeinstance\",{\"1\":{\"1524\":3}}],[\"prototype\",{\"1\":{\"1524\":1}}],[\"prototype作用域\",{\"0\":{\"1146\":1}}],[\"protocolhandler内部又分为endpoint和processor模块\",{\"1\":{\"1566\":1}}],[\"protocolhandler组件\",{\"0\":{\"1566\":1}}],[\"protocol\",{\"1\":{\"1497\":1}}],[\"proto文件\",{\"0\":{\"828\":1}}],[\"protobuf\",{\"0\":{\"826\":1}}],[\"protected\",{\"1\":{\"311\":1,\"806\":1,\"1500\":1,\"1524\":9,\"1525\":2,\"1527\":1,\"1528\":1,\"1532\":1,\"1535\":1,\"1540\":1}}],[\"producing\",{\"1\":{\"1478\":2,\"1486\":1}}],[\"producer消息发送重试\",{\"0\":{\"1807\":1}}],[\"producerthreads\",{\"1\":{\"1412\":2}}],[\"producertype\",{\"1\":{\"1397\":2,\"1398\":1}}],[\"produce\",{\"1\":{\"1492\":5,\"1495\":1,\"1496\":2,\"1497\":1,\"1500\":1}}],[\"produces\",{\"1\":{\"1475\":3,\"1485\":2,\"1495\":3,\"1496\":1,\"1500\":2}}],[\"produced\",{\"1\":{\"690\":1,\"692\":2,\"1486\":1,\"1495\":1,\"1497\":1,\"1498\":1}}],[\"producttype\",{\"1\":{\"1397\":1}}],[\"product\",{\"1\":{\"467\":2}}],[\"profiling=on\",{\"1\":{\"568\":1}}],[\"profiling\",{\"1\":{\"568\":3}}],[\"profile查询列表\",{\"1\":{\"568\":1}}],[\"profile查询参数备注\",{\"1\":{\"568\":1}}],[\"profile查询sql在mysql数据库中的执行细节和生命周期情况\",{\"1\":{\"567\":1}}],[\"profile中看到一条sql中完整的生命周期\",{\"1\":{\"568\":1}}],[\"profiles\",{\"0\":{\"1308\":1},\"1\":{\"568\":2}}],[\"profile功能\",{\"1\":{\"568\":2}}],[\"profile功能是否开启\",{\"1\":{\"568\":1}}],[\"profile是什么\",{\"1\":{\"568\":1}}],[\"profile\",{\"0\":{\"568\":1},\"1\":{\"567\":1,\"568\":3}}],[\"profit\",{\"1\":{\"419\":4}}],[\"proceedwithinvocation\",{\"1\":{\"1532\":2}}],[\"procedure\",{\"1\":{\"537\":2,\"541\":2,\"551\":1,\"556\":1,\"655\":2,\"660\":4}}],[\"processcommondefinitionannotations\",{\"1\":{\"1524\":1}}],[\"processor负责应用层协议解析\",{\"1\":{\"1566\":1}}],[\"processor负责提供tomcat\",{\"1\":{\"1565\":1}}],[\"processor和adapter\",{\"1\":{\"1565\":1}}],[\"processors\",{\"1\":{\"1524\":3}}],[\"processon\",{\"1\":{\"800\":1,\"806\":1,\"1371\":1,\"1376\":1,\"1529\":1,\"1530\":1,\"1534\":1}}],[\"processes\",{\"1\":{\"1500\":1}}],[\"processed\",{\"1\":{\"1472\":2,\"1492\":2,\"1497\":1}}],[\"processing\",{\"1\":{\"656\":4,\"1497\":2,\"1500\":2,\"1524\":2}}],[\"processlist里看到两个相同的thread\",{\"1\":{\"635\":1}}],[\"processlist结果上看也是command\",{\"1\":{\"618\":1}}],[\"processlist的时候\",{\"1\":{\"618\":2}}],[\"processlist的结果里看到的几千个连接\",{\"1\":{\"613\":1}}],[\"processlist\",{\"1\":{\"618\":1}}],[\"processlist命令\",{\"1\":{\"617\":1}}],[\"processlist命令中看到它\",{\"1\":{\"455\":1}}],[\"processresult\",{\"1\":{\"288\":1}}],[\"process\",{\"1\":{\"285\":2,\"1497\":1,\"1524\":2,\"1528\":1}}],[\"problem\",{\"1\":{\"288\":4}}],[\"pan\",{\"1\":{\"1850\":1}}],[\"padding\",{\"1\":{\"1361\":1}}],[\"pair\",{\"1\":{\"1356\":2}}],[\"payload事件\",{\"0\":{\"1279\":1}}],[\"passes\",{\"1\":{\"1500\":1}}],[\"passed\",{\"1\":{\"1492\":6,\"1496\":1,\"1497\":2,\"1500\":2}}],[\"passingfailing\",{\"1\":{\"1493\":1}}],[\"passing\",{\"1\":{\"1493\":1,\"1500\":1}}],[\"pass\",{\"1\":{\"761\":2,\"1492\":1,\"1493\":1,\"1498\":1,\"1525\":3,\"1532\":1}}],[\"password=$password\",{\"1\":{\"604\":1,\"605\":1}}],[\"paging\",{\"1\":{\"698\":1}}],[\"page2没有在内存中\",{\"1\":{\"482\":1}}],[\"page1在内存中\",{\"1\":{\"482\":1}}],[\"pages的值作为该属性的值\",{\"1\":{\"695\":1}}],[\"pages属性的话\",{\"1\":{\"695\":1}}],[\"pages属性来指明该表的统计数据存储方式\",{\"1\":{\"695\":1}}],[\"pages来控制使用永久性的统计数据时\",{\"1\":{\"695\":1}}],[\"pages\",{\"0\":{\"1\":1},\"1\":{\"695\":3,\"1561\":1}}],[\"page\",{\"1\":{\"0\":1,\"1\":1,\"3\":1,\"568\":1,\"640\":1}}],[\"pack\",{\"1\":{\"1468\":2}}],[\"packed\",{\"1\":{\"657\":1,\"690\":1}}],[\"packagesearchpath\",{\"1\":{\"1524\":2}}],[\"package\",{\"1\":{\"302\":1,\"1356\":1,\"1468\":1,\"1474\":2,\"1475\":4,\"1476\":2,\"1477\":1,\"1478\":1,\"1482\":1,\"1485\":8,\"1497\":2,\"1524\":1}}],[\"pattern\",{\"1\":{\"566\":1,\"709\":1,\"710\":1,\"711\":1,\"734\":4,\"1361\":1}}],[\"path>\",{\"1\":{\"761\":2}}],[\"paths\",{\"1\":{\"409\":11,\"415\":6,\"656\":4,\"1464\":2,\"1465\":2}}],[\"path\",{\"1\":{\"409\":11,\"656\":2,\"1496\":1}}],[\"parnew收集器\",{\"0\":{\"1603\":1}}],[\"parsing\",{\"1\":{\"1528\":1}}],[\"parsedynamictags\",{\"1\":{\"806\":1}}],[\"parse\",{\"1\":{\"566\":1}}],[\"pareach<>\",{\"1\":{\"1497\":1}}],[\"pareach<t>\",{\"1\":{\"1497\":2}}],[\"pareach\",{\"1\":{\"1497\":3}}],[\"parent==null\",{\"1\":{\"1567\":1}}],[\"parentbeanfactory\",{\"1\":{\"1524\":7}}],[\"parentbeanname\",{\"1\":{\"1524\":6}}],[\"parentcid\",{\"1\":{\"467\":4}}],[\"parent\",{\"1\":{\"302\":6,\"467\":2,\"1383\":3,\"1497\":3,\"1524\":10,\"1525\":6,\"1540\":3,\"1567\":5}}],[\"par\",{\"1\":{\"1495\":3}}],[\"parknanos\",{\"1\":{\"1356\":1,\"1397\":1}}],[\"partially\",{\"1\":{\"1492\":2,\"1497\":2}}],[\"partial\",{\"1\":{\"1492\":2}}],[\"partition<t>\",{\"1\":{\"1495\":1}}],[\"partition<>\",{\"1\":{\"1495\":3}}],[\"partitioned\",{\"1\":{\"1492\":1,\"1497\":1}}],[\"partitioningby\",{\"1\":{\"1490\":1,\"1493\":4,\"1495\":3}}],[\"partitioning\",{\"1\":{\"562\":2,\"1497\":1}}],[\"partition\",{\"1\":{\"561\":5,\"563\":1,\"1490\":1,\"1492\":5,\"1493\":1,\"1495\":1,\"1497\":1}}],[\"partitions\",{\"1\":{\"466\":1,\"467\":5,\"498\":1,\"1492\":2}}],[\"part\",{\"1\":{\"690\":1,\"1524\":1}}],[\"parts\",{\"1\":{\"656\":2,\"690\":1,\"692\":2}}],[\"parallelstream两个方法的延迟特性\",{\"1\":{\"1497\":1}}],[\"parallelstream\",{\"1\":{\"1489\":1,\"1494\":1,\"1496\":2,\"1497\":3,\"1499\":1}}],[\"parallelized\",{\"1\":{\"1485\":2}}],[\"parallelism\",{\"1\":{\"1387\":1,\"1497\":1,\"1499\":1,\"1500\":1}}],[\"parallel\",{\"0\":{\"1604\":1,\"1606\":1},\"1\":{\"597\":1,\"602\":1,\"761\":2,\"1485\":2,\"1492\":5,\"1494\":4,\"1495\":2,\"1496\":6,\"1497\":11,\"1498\":18,\"1499\":1,\"1500\":2}}],[\"parameter\",{\"1\":{\"1500\":1}}],[\"parameters\",{\"1\":{\"1496\":4,\"1525\":1}}],[\"param\",{\"1\":{\"302\":5,\"1364\":2,\"1472\":1,\"1474\":3,\"1475\":24,\"1476\":12,\"1477\":1,\"1478\":5,\"1485\":4}}],[\"param2\",{\"1\":{\"285\":1,\"288\":4}}],[\"param1\",{\"1\":{\"285\":1,\"288\":4}}],[\"python\",{\"1\":{\"8\":1}}],[\"eureka\",{\"1\":{\"1541\":1}}],[\"eager\",{\"1\":{\"1524\":1}}],[\"eagerly\",{\"1\":{\"1524\":5}}],[\"earlysingletonobjects\",{\"1\":{\"1526\":1}}],[\"earlysingletonreference\",{\"1\":{\"1524\":3}}],[\"earlysingletonexposure\",{\"1\":{\"1524\":3,\"1526\":2}}],[\"easy\",{\"1\":{\"1497\":1}}],[\"each\",{\"1\":{\"385\":1,\"1472\":3,\"1477\":2,\"1485\":2,\"1492\":3,\"1495\":2,\"1496\":1,\"1497\":2,\"1498\":3,\"1499\":1,\"1500\":7}}],[\"efficiency\",{\"1\":{\"1497\":1}}],[\"efficiently\",{\"1\":{\"1497\":1}}],[\"efficient\",{\"1\":{\"1496\":1,\"1497\":2}}],[\"effort\",{\"1\":{\"1497\":2}}],[\"effective\",{\"1\":{\"1497\":1}}],[\"effect\",{\"1\":{\"1496\":1,\"1500\":1}}],[\"effects\",{\"1\":{\"1474\":2}}],[\"e=e\",{\"1\":{\"1494\":4}}],[\"etc\",{\"1\":{\"1486\":1,\"1492\":1,\"1493\":1,\"1496\":1,\"1500\":3}}],[\"e>\",{\"1\":{\"1480\":1,\"1499\":1}}],[\"either\",{\"1\":{\"1474\":1,\"1475\":6,\"1476\":4,\"1492\":1,\"1496\":1,\"1497\":3,\"1498\":1}}],[\"epoll使用一个文件描述符管理多个描述符\",{\"1\":{\"1448\":1}}],[\"epoll更加灵活\",{\"1\":{\"1448\":1}}],[\"epoll是在linux内核2\",{\"1\":{\"1448\":1}}],[\"epoll本质上都是同步io\",{\"1\":{\"1445\":1}}],[\"epoll的优势并不是对于单个连接能处理得更快\",{\"1\":{\"1442\":1}}],[\"epoll的web\",{\"1\":{\"1442\":1}}],[\"epoll的好处在于单个process就可以同时处理多个网络连接的io\",{\"1\":{\"1442\":1}}],[\"epoll这个function会不断的轮询所负责的所有socket\",{\"1\":{\"1442\":1}}],[\"epoll\",{\"0\":{\"1445\":1,\"1448\":1},\"1\":{\"1442\":1}}],[\"epoll详解\",{\"1\":{\"1438\":1}}],[\"epoll有什么区别\",{\"0\":{\"98\":1}}],[\"ek\",{\"1\":{\"1431\":4}}],[\"e得到false\",{\"1\":{\"1356\":1}}],[\"e就是true\",{\"1\":{\"1356\":1}}],[\"erroneous\",{\"1\":{\"1496\":1}}],[\"errors的文案来源\",{\"0\":{\"1224\":1}}],[\"errors接口设计\",{\"0\":{\"1223\":1}}],[\"errors\",{\"1\":{\"717\":1,\"1496\":1}}],[\"errors忽略错误的方法\",{\"1\":{\"605\":1}}],[\"errors设置为\",{\"1\":{\"604\":1}}],[\"errors参数\",{\"1\":{\"604\":2}}],[\"error并停止\",{\"1\":{\"596\":1}}],[\"error\",{\"1\":{\"457\":1,\"459\":1,\"628\":1,\"708\":1,\"710\":1,\"716\":1,\"717\":4,\"748\":2,\"1471\":2,\"1528\":1,\"1532\":2}}],[\"err\",{\"1\":{\"710\":1,\"716\":1,\"717\":2}}],[\"eg\",{\"1\":{\"702\":1}}],[\"evict\",{\"1\":{\"1426\":2}}],[\"evaluating\",{\"1\":{\"1476\":4,\"1498\":1}}],[\"evaluation\",{\"1\":{\"1475\":6,\"1476\":8,\"1498\":3,\"1500\":1}}],[\"evaluatetryfailure\",{\"1\":{\"1532\":2}}],[\"evaluatebeandefinitionstring\",{\"1\":{\"1525\":1}}],[\"evaluateparallel\",{\"1\":{\"1500\":5}}],[\"evaluated\",{\"1\":{\"1476\":8,\"1494\":1,\"1498\":1}}],[\"evaluatesequential\",{\"1\":{\"1500\":5}}],[\"evaluates\",{\"1\":{\"1476\":2,\"1500\":1}}],[\"evaluate\",{\"1\":{\"694\":1,\"1494\":1,\"1499\":1,\"1500\":2}}],[\"eval\",{\"1\":{\"690\":2,\"692\":3}}],[\"ever\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"everysec\",{\"1\":{\"729\":1}}],[\"every\",{\"1\":{\"1\":1,\"2\":1,\"1500\":2}}],[\"even\",{\"1\":{\"1497\":3,\"1524\":1}}],[\"eventually\",{\"1\":{\"1497\":1,\"1524\":1}}],[\"eventproducer\",{\"1\":{\"1398\":2}}],[\"eventfactory\",{\"1\":{\"1397\":2}}],[\"eventfactory<t>\",{\"1\":{\"1397\":1}}],[\"eventlistener的工作原理\",{\"0\":{\"1291\":1,\"1304\":1}}],[\"eventloopgroup\",{\"0\":{\"856\":1}}],[\"eventloopgroup了解么\",{\"0\":{\"213\":1}}],[\"event改为write\",{\"1\":{\"621\":1}}],[\"event即可\",{\"1\":{\"621\":1}}],[\"event类型是write\",{\"1\":{\"621\":1}}],[\"event里的行数据\",{\"1\":{\"602\":1}}],[\"event里面\",{\"1\":{\"591\":1}}],[\"event\",{\"1\":{\"591\":2,\"616\":6,\"621\":2,\"740\":4,\"1468\":4,\"1524\":2}}],[\"event显示了接下来要打开的表\",{\"1\":{\"591\":1}}],[\"event用于定义删除的行为\",{\"1\":{\"591\":1}}],[\"event用于说明接下来要操作的表是test库的表t\",{\"1\":{\"591\":1}}],[\"events\",{\"1\":{\"591\":1,\"740\":4,\"1447\":3}}],[\"e+308\",{\"1\":{\"665\":3}}],[\"e+38\",{\"1\":{\"665\":3}}],[\"edition\",{\"1\":{\"1561\":1}}],[\"edit\",{\"1\":{\"1408\":1}}],[\"ed\",{\"1\":{\"659\":2}}],[\"emits\",{\"1\":{\"1500\":2}}],[\"em>\",{\"1\":{\"1471\":2}}],[\"emptiness\",{\"1\":{\"1497\":1}}],[\"emptyspliterator\",{\"1\":{\"1497\":1}}],[\"emptyset\",{\"1\":{\"1495\":1}}],[\"empty\",{\"1\":{\"706\":1,\"709\":1,\"1431\":1,\"1484\":2,\"1492\":1,\"1497\":2,\"1525\":1,\"1535\":1}}],[\"employed\",{\"1\":{\"1497\":1}}],[\"employee\",{\"1\":{\"1492\":2,\"1493\":5}}],[\"employees表所有字段长度总和肯定大于10字节\",{\"1\":{\"657\":1}}],[\"employees\",{\"1\":{\"647\":3,\"655\":4,\"656\":2,\"657\":2,\"659\":6,\"663\":4,\"1492\":1,\"1493\":4}}],[\"employess\",{\"1\":{\"655\":1}}],[\"emp\",{\"1\":{\"655\":3}}],[\"email=\",{\"1\":{\"488\":2}}],[\"email\",{\"1\":{\"486\":2,\"487\":7,\"488\":2,\"710\":4}}],[\"e执行kill\",{\"1\":{\"618\":1}}],[\"e执行了kill\",{\"1\":{\"618\":1}}],[\"e中执行show\",{\"1\":{\"618\":1}}],[\"e5\",{\"1\":{\"515\":1}}],[\"e4\",{\"1\":{\"515\":1}}],[\"e3\",{\"1\":{\"515\":1}}],[\"e2\",{\"1\":{\"515\":1}}],[\"e1\",{\"1\":{\"515\":1,\"1452\":2}}],[\"equivalence\",{\"1\":{\"1492\":1}}],[\"equivalent\",{\"1\":{\"1485\":2,\"1492\":8}}],[\"equal\",{\"1\":{\"1476\":4,\"1491\":1,\"1497\":2,\"1524\":1}}],[\"equality\",{\"1\":{\"656\":1,\"1476\":2,\"1492\":1}}],[\"equals\",{\"1\":{\"302\":2,\"385\":1,\"387\":1,\"1423\":1,\"1426\":3,\"1430\":1,\"1431\":1,\"1471\":1,\"1475\":1,\"1476\":7,\"1488\":2,\"1492\":2,\"1516\":2,\"1524\":3,\"1525\":2,\"1531\":1,\"1532\":1}}],[\"eq\",{\"1\":{\"467\":1,\"646\":1,\"656\":1,\"690\":1}}],[\"e\",{\"1\":{\"354\":4,\"566\":1,\"659\":2,\"665\":6,\"714\":1,\"719\":1,\"1356\":7,\"1377\":8,\"1378\":10,\"1379\":9,\"1380\":10,\"1383\":3,\"1410\":2,\"1411\":2,\"1412\":4,\"1426\":11,\"1427\":16,\"1428\":4,\"1430\":8,\"1431\":8,\"1434\":3,\"1450\":8,\"1451\":11,\"1452\":16,\"1464\":2,\"1465\":2,\"1468\":2,\"1480\":3,\"1490\":1,\"1491\":1,\"1494\":6,\"1498\":7,\"1499\":5,\"1500\":6,\"1540\":1}}],[\"ex2\",{\"1\":{\"1532\":5}}],[\"ex\",{\"1\":{\"1524\":37,\"1525\":7,\"1528\":6,\"1532\":11,\"1534\":2}}],[\"exhaust\",{\"1\":{\"1497\":1}}],[\"exhaustion\",{\"1\":{\"1496\":1}}],[\"exactly\",{\"1\":{\"1471\":2,\"1497\":3,\"1525\":1}}],[\"examples\",{\"1\":{\"1492\":1,\"1493\":1}}],[\"example\",{\"1\":{\"761\":1,\"1485\":1,\"1492\":3,\"1495\":2,\"1496\":6,\"1497\":13,\"1500\":1,\"1524\":2}}],[\"examined\",{\"1\":{\"557\":2,\"657\":2,\"690\":1,\"692\":2}}],[\"examined并不是完全相同的\",{\"1\":{\"459\":1}}],[\"examined表示这个语句执行过程中扫描了多少行\",{\"1\":{\"459\":1}}],[\"exiting\",{\"1\":{\"1496\":1}}],[\"exit\",{\"1\":{\"1452\":1,\"1468\":2}}],[\"existing\",{\"1\":{\"1426\":1,\"1485\":2,\"1499\":3}}],[\"exists\",{\"1\":{\"498\":2,\"499\":4,\"500\":2,\"643\":3,\"655\":1,\"660\":2,\"662\":1,\"706\":3,\"767\":1,\"1497\":1,\"1524\":1}}],[\"excludefilters\",{\"1\":{\"1522\":1,\"1524\":1}}],[\"excludefilter表示排除过滤器\",{\"1\":{\"1522\":1}}],[\"excludefilter和includefilter\",{\"0\":{\"1522\":1}}],[\"exclusive\",{\"1\":{\"1367\":1}}],[\"exc\",{\"1\":{\"1452\":5}}],[\"except\",{\"1\":{\"1497\":1}}],[\"exceptfds\",{\"1\":{\"1446\":1}}],[\"exceptions\",{\"1\":{\"1472\":2,\"1476\":4,\"1496\":1,\"1497\":2}}],[\"exception\",{\"1\":{\"719\":1,\"1398\":1,\"1410\":1,\"1411\":1,\"1450\":4,\"1451\":6,\"1452\":7,\"1464\":1,\"1465\":1,\"1472\":2,\"1474\":2,\"1475\":6,\"1476\":4,\"1487\":1,\"1494\":2,\"1496\":14,\"1497\":1,\"1521\":1,\"1524\":5,\"1528\":2,\"1532\":4,\"1534\":4}}],[\"exchange\",{\"1\":{\"1356\":8}}],[\"exch\",{\"1\":{\"317\":2,\"318\":2,\"319\":3}}],[\"execsave\",{\"1\":{\"1408\":1}}],[\"execabort\",{\"1\":{\"717\":1}}],[\"exec\",{\"1\":{\"716\":5,\"717\":2,\"718\":2,\"719\":1}}],[\"executorcompletionservice<>\",{\"1\":{\"1394\":2}}],[\"executors\",{\"1\":{\"1394\":3,\"1398\":1,\"1411\":1,\"1412\":2}}],[\"executorservice\",{\"1\":{\"1394\":3,\"1405\":1,\"1411\":1,\"1412\":2}}],[\"executor\",{\"1\":{\"1394\":10}}],[\"executor的实现类\",{\"1\":{\"807\":1}}],[\"executions\",{\"1\":{\"1492\":1}}],[\"execution\",{\"1\":{\"656\":4,\"657\":8,\"761\":1,\"1485\":2,\"1496\":4,\"1498\":1}}],[\"executing\",{\"1\":{\"568\":1,\"1498\":1,\"1500\":1}}],[\"executed\",{\"1\":{\"609\":1,\"611\":2}}],[\"execute\",{\"1\":{\"559\":1,\"1353\":1,\"1394\":3,\"1405\":1,\"1411\":1,\"1496\":1,\"1500\":1,\"1532\":1}}],[\"exposedobject\",{\"1\":{\"1524\":6}}],[\"expression\",{\"1\":{\"1496\":1,\"1561\":1}}],[\"expressions\",{\"1\":{\"1471\":2,\"1496\":1}}],[\"explicit\",{\"1\":{\"1524\":1}}],[\"explicitly\",{\"1\":{\"1496\":1,\"1499\":1,\"1524\":1}}],[\"explain中的列\",{\"0\":{\"644\":1}}],[\"explainpartitions\",{\"1\":{\"643\":1}}],[\"explain详解\",{\"0\":{\"643\":1}}],[\"explain的结果也显示mysql预估需要访问10行数据\",{\"1\":{\"527\":1}}],[\"explain的结果\",{\"1\":{\"505\":1,\"541\":1}}],[\"explain的结果第二行的key=null表示的就是\",{\"1\":{\"505\":1}}],[\"explain的结果如下\",{\"1\":{\"493\":2,\"538\":1,\"540\":1,\"544\":1,\"555\":1}}],[\"explain的详细过程如下\",{\"1\":{\"505\":1}}],[\"explain能干嘛\",{\"1\":{\"466\":1}}],[\"explain怎么使用\",{\"1\":{\"466\":1}}],[\"explain是什么\",{\"1\":{\"466\":1}}],[\"explain\",{\"0\":{\"466\":1,\"467\":1},\"1\":{\"466\":3,\"467\":5,\"498\":1,\"507\":6,\"509\":2,\"510\":2,\"511\":2,\"512\":12,\"513\":3,\"515\":15,\"527\":2,\"567\":2,\"646\":5,\"659\":1,\"661\":1,\"662\":1,\"663\":4,\"686\":2,\"690\":1,\"692\":1}}],[\"expensive\",{\"1\":{\"1495\":1,\"1497\":1}}],[\"expected\",{\"1\":{\"1474\":2,\"1497\":3,\"1500\":1}}],[\"expectedvalue\",{\"1\":{\"1356\":1}}],[\"exp让mysql查询优化器重新加载我们更改过的数据\",{\"1\":{\"696\":1}}],[\"exp2\",{\"1\":{\"691\":5,\"692\":2}}],[\"exp`\",{\"1\":{\"690\":7}}],[\"exp表关于行数的统计数据更改一下\",{\"1\":{\"696\":1}}],[\"exp表为例\",{\"1\":{\"695\":1}}],[\"exp表的统计数据\",{\"1\":{\"696\":1}}],[\"exp表的其他索引一共占用81个页面\",{\"1\":{\"695\":1}}],[\"exp表的聚簇索引占用97页面\",{\"1\":{\"695\":1}}],[\"exp表的idx\",{\"1\":{\"690\":1}}],[\"exp表中大约有10350条记录\",{\"1\":{\"695\":1}}],[\"exp表实际由10567条记录\",{\"1\":{\"685\":1}}],[\"exp的各个索引的统计数据可以这么写\",{\"1\":{\"690\":1}}],[\"exp使用默认16kb的页面大小\",{\"1\":{\"685\":1}}],[\"expire\",{\"1\":{\"681\":5,\"684\":8,\"686\":19,\"688\":5,\"690\":9,\"691\":9,\"692\":38,\"695\":3,\"706\":2}}],[\"exp\",{\"1\":{\"681\":1,\"684\":1,\"685\":1,\"686\":2,\"690\":5,\"691\":5,\"692\":2,\"695\":1,\"696\":1}}],[\"expanded\",{\"1\":{\"656\":1}}],[\"extclassloader\",{\"1\":{\"1569\":1}}],[\"extern\",{\"1\":{\"1356\":1}}],[\"extension\",{\"1\":{\"1500\":1}}],[\"extensions\",{\"1\":{\"2\":1}}],[\"extensible\",{\"0\":{\"1197\":1}}],[\"extended\",{\"1\":{\"646\":1}}],[\"extends\",{\"1\":{\"311\":1,\"1377\":1,\"1475\":6,\"1478\":2,\"1484\":1,\"1486\":2,\"1490\":1,\"1494\":1,\"1495\":11,\"1496\":3,\"1497\":4,\"1498\":8,\"1499\":3,\"1500\":4,\"1515\":2,\"1525\":1}}],[\"extra字段显示using\",{\"1\":{\"557\":1}}],[\"extra字段多了using\",{\"1\":{\"541\":1}}],[\"extra字段里面有没有出现\",{\"1\":{\"540\":1}}],[\"extra字段的using\",{\"1\":{\"503\":1}}],[\"extra字段中没有using\",{\"1\":{\"493\":1}}],[\"extra这个字段中的\",{\"1\":{\"491\":1}}],[\"extra\",{\"1\":{\"4\":1,\"466\":1,\"467\":8,\"498\":1,\"527\":2}}],[\"enhancer\",{\"1\":{\"1531\":7}}],[\"enforce\",{\"1\":{\"1524\":1}}],[\"encapsulating\",{\"1\":{\"1498\":1}}],[\"encountered\",{\"1\":{\"1497\":4,\"1524\":1,\"1528\":1}}],[\"encounter\",{\"1\":{\"1494\":1,\"1497\":2,\"1499\":1,\"1500\":4}}],[\"enough\",{\"1\":{\"1497\":1}}],[\"enterprise\",{\"1\":{\"1561\":1}}],[\"enters\",{\"1\":{\"1495\":1}}],[\"entries\",{\"1\":{\"1492\":1}}],[\"entryat\",{\"1\":{\"1430\":1}}],[\"entry<class<\",{\"1\":{\"1525\":1}}],[\"entry<string\",{\"1\":{\"1525\":1}}],[\"entry<boolean\",{\"1\":{\"1495\":5}}],[\"entry<k\",{\"1\":{\"1423\":1,\"1431\":1}}],[\"entry<integer\",{\"1\":{\"311\":1,\"381\":1}}],[\"entrylist中唤醒线程\",{\"1\":{\"1360\":1}}],[\"entrylist不为空\",{\"1\":{\"1360\":1}}],[\"entrylist\",{\"1\":{\"1360\":1}}],[\"entryset\",{\"1\":{\"381\":1,\"1495\":1,\"1525\":2}}],[\"entry\",{\"1\":{\"381\":3,\"604\":1,\"631\":1,\"1356\":1,\"1427\":3,\"1500\":2,\"1525\":3}}],[\"ensures\",{\"1\":{\"1496\":1}}],[\"ensuresegment\",{\"1\":{\"1430\":2}}],[\"ensure\",{\"1\":{\"1492\":1,\"1497\":2}}],[\"enscore进行合并\",{\"1\":{\"711\":1}}],[\"enscore\",{\"1\":{\"711\":2}}],[\"enscore=>\",{\"1\":{\"711\":1}}],[\"enrty接口\",{\"1\":{\"1423\":1}}],[\"enqueue\",{\"1\":{\"1379\":2,\"1380\":2}}],[\"enumset\",{\"1\":{\"1494\":5,\"1495\":3}}],[\"enum\",{\"1\":{\"1361\":1,\"1471\":2,\"1492\":1}}],[\"env\",{\"1\":{\"1356\":1}}],[\"environmentcapable\",{\"1\":{\"1514\":1}}],[\"environment完整的生命周期\",{\"0\":{\"1339\":1}}],[\"environment完整的生命周期是怎样的\",{\"0\":{\"1322\":1}}],[\"environment接口\",{\"0\":{\"1320\":1}}],[\"environment接口使用场景\",{\"0\":{\"1306\":1}}],[\"environment占位符处理\",{\"0\":{\"1307\":1}}],[\"enbaleaspectjautoproxy的原理\",{\"0\":{\"992\":1}}],[\"enabletransactionmanagement注解来开启spring事务是\",{\"1\":{\"1532\":1}}],[\"enabled\",{\"1\":{\"1497\":2,\"1500\":1}}],[\"enabled=off\",{\"1\":{\"656\":1,\"657\":1}}],[\"enabled=on\",{\"1\":{\"491\":1,\"558\":1,\"656\":1,\"657\":1,\"681\":1}}],[\"enabled=\",{\"1\":{\"616\":1}}],[\"enable\",{\"1\":{\"1497\":1}}],[\"enables\",{\"1\":{\"1492\":1,\"1497\":1}}],[\"enableautoconfiguration\",{\"0\":{\"1034\":1}}],[\"enable模块驱动\",{\"0\":{\"977\":1,\"1299\":1}}],[\"engine>\",{\"1\":{\"1561\":1}}],[\"engine将表t改成myisam表\",{\"1\":{\"561\":1}}],[\"engine来控制的\",{\"1\":{\"558\":1}}],[\"engine=innodb\",{\"1\":{\"544\":1,\"549\":1,\"550\":1,\"631\":1,\"647\":1,\"655\":1,\"660\":1,\"672\":1,\"695\":4,\"696\":2}}],[\"engine\",{\"1\":{\"472\":1,\"473\":1,\"475\":1,\"483\":1,\"486\":1,\"490\":1,\"503\":1,\"505\":1,\"537\":1,\"546\":1,\"556\":1,\"561\":6,\"570\":1,\"583\":1,\"591\":1,\"596\":1,\"599\":1,\"605\":1,\"613\":1,\"615\":1,\"626\":1,\"643\":3,\"671\":1,\"675\":1,\"694\":3}}],[\"endpoint负责底层sokcet通信\",{\"1\":{\"1566\":1}}],[\"endpoint负责提供字节流给processor\",{\"1\":{\"1565\":1}}],[\"endpoint和processor\",{\"1\":{\"1566\":1}}],[\"endtime\",{\"1\":{\"1489\":2}}],[\"endinclusive\",{\"1\":{\"1484\":3}}],[\"endexclusive\",{\"1\":{\"1484\":3}}],[\"end\",{\"0\":{\"1871\":1},\"1\":{\"335\":1,\"384\":5,\"537\":2,\"541\":3,\"551\":2,\"556\":2,\"568\":3,\"604\":1,\"655\":2,\"656\":1,\"657\":1,\"660\":4,\"707\":1,\"708\":2,\"711\":2,\"715\":2,\"1364\":2,\"1497\":1,\"1498\":2,\"1500\":9,\"1524\":5,\"1528\":3}}],[\"end=\",{\"1\":{\"302\":1}}],[\"el\",{\"1\":{\"1856\":1}}],[\"el表达式解析器\",{\"1\":{\"1513\":1,\"1528\":1}}],[\"elided\",{\"1\":{\"1494\":1}}],[\"eliminatelocks\",{\"1\":{\"1364\":1}}],[\"elememt2\",{\"1\":{\"714\":1}}],[\"elements\",{\"1\":{\"1472\":2,\"1478\":3,\"1485\":4,\"1490\":5,\"1491\":1,\"1492\":8,\"1493\":3,\"1494\":1,\"1495\":12,\"1496\":4,\"1497\":38,\"1498\":2,\"1500\":13,\"1525\":3}}],[\"elementtype\",{\"1\":{\"1471\":1}}],[\"elementdequeued\",{\"1\":{\"1379\":1}}],[\"elementdata\",{\"1\":{\"1352\":3,\"1419\":1}}],[\"element1\",{\"1\":{\"714\":1}}],[\"element\",{\"1\":{\"354\":1,\"443\":4,\"806\":2,\"1377\":1,\"1378\":2,\"1472\":3,\"1485\":6,\"1486\":4,\"1492\":2,\"1495\":2,\"1497\":8,\"1499\":2,\"1500\":5}}],[\"elastic\",{\"1\":{\"1864\":1}}],[\"elasticsearch7\",{\"1\":{\"1864\":1}}],[\"elasticsearch的底层是开源库\",{\"1\":{\"1864\":1}}],[\"elasticsearch是目前全文搜索引擎的首选\",{\"1\":{\"1864\":1}}],[\"elasticsearch这些中间件\",{\"1\":{\"1862\":1}}],[\"elasticsearch\",{\"0\":{\"174\":1,\"1864\":1}}],[\"elaticsearch集群架构实战及其原理\",{\"0\":{\"449\":1}}],[\"elaticsearch高阶功能\",{\"0\":{\"448\":1}}],[\"elaticsearch高级查询语法query\",{\"0\":{\"446\":1}}],[\"elaticsearch搜索技术与聚合查询\",{\"0\":{\"447\":1}}],[\"elaticsearch快速入门\",{\"0\":{\"445\":1}}],[\"elaticsearch\",{\"0\":{\"444\":1}}],[\"eldest\",{\"1\":{\"311\":1}}],[\"elsewhere\",{\"1\":{\"1471\":2}}],[\"else\",{\"1\":{\"302\":5,\"305\":2,\"319\":1,\"360\":2,\"362\":1,\"366\":2,\"368\":1,\"371\":1,\"381\":1,\"384\":1,\"386\":4,\"388\":1,\"395\":3,\"417\":1,\"419\":1,\"427\":1,\"428\":2,\"438\":1,\"439\":1,\"440\":2,\"443\":2,\"806\":2,\"1353\":2,\"1356\":1,\"1426\":3,\"1427\":8,\"1430\":3,\"1431\":6,\"1451\":4,\"1452\":1,\"1484\":2,\"1494\":1,\"1495\":3,\"1497\":6,\"1498\":2,\"1499\":3,\"1500\":2,\"1524\":17,\"1525\":8,\"1527\":1,\"1528\":1,\"1531\":5,\"1532\":3,\"1540\":1}}],[\"ejb\",{\"0\":{\"1466\":1},\"1\":{\"280\":1}}],[\"eeee\",{\"1\":{\"605\":3}}],[\"ee\",{\"1\":{\"280\":1,\"473\":1,\"1561\":1}}],[\"ee简介\",{\"0\":{\"280\":1}}],[\"est\",{\"1\":{\"1499\":1}}],[\"estimate方法估算的值通常而言也是有用的\",{\"1\":{\"1497\":1}}],[\"estimates\",{\"1\":{\"1497\":1}}],[\"estimatesize\",{\"1\":{\"1497\":12}}],[\"estimate估算就可能是不精确的\",{\"1\":{\"1497\":1}}],[\"estimate\",{\"1\":{\"1497\":6}}],[\"estimated\",{\"1\":{\"1497\":3,\"1498\":1}}],[\"estimation\",{\"1\":{\"656\":2}}],[\"essence\",{\"1\":{\"1472\":1}}],[\"es\",{\"1\":{\"1383\":4,\"1405\":2,\"1411\":3}}],[\"es部署时\",{\"0\":{\"180\":1}}],[\"es写入数据与查询数据的原理\",{\"0\":{\"179\":1}}],[\"es了解多少\",{\"0\":{\"177\":1}}],[\"rules\",{\"1\":{\"1496\":1,\"1532\":2}}],[\"runoob\",{\"1\":{\"1847\":1}}],[\"run\",{\"1\":{\"1428\":2,\"1450\":1,\"1468\":1,\"1469\":1,\"1471\":1,\"1496\":3}}],[\"runaftereither\",{\"1\":{\"1395\":1}}],[\"runafterbotheither\",{\"1\":{\"1395\":1}}],[\"runtimeexception\",{\"1\":{\"1451\":2,\"1452\":5,\"1532\":3}}],[\"runtime\",{\"1\":{\"1357\":1,\"1450\":1,\"1471\":1}}],[\"runnable接口现在变成了函数式接口\",{\"1\":{\"1471\":1}}],[\"runnable状态转换到终止状态\",{\"1\":{\"1401\":1}}],[\"runnable\",{\"1\":{\"1353\":1,\"1354\":1,\"1395\":1,\"1468\":1,\"1469\":3,\"1471\":1,\"1496\":1,\"1567\":1}}],[\"rr>\",{\"1\":{\"1495\":3}}],[\"r类型表示汇聚操作的结果类型\",{\"1\":{\"1492\":1}}],[\"r是返回的结果的类型\",{\"1\":{\"1475\":1}}],[\"r>分别表示输入参数的类型和返回结果的类型\",{\"1\":{\"1475\":1}}],[\"r>\",{\"1\":{\"1475\":4,\"1478\":1,\"1485\":2,\"1492\":2,\"1493\":5,\"1494\":1,\"1495\":4,\"1499\":3,\"1500\":2}}],[\"rset\",{\"0\":{\"1623\":1}}],[\"rs\",{\"1\":{\"1431\":5}}],[\"rsp\",{\"1\":{\"1350\":1}}],[\"rb\",{\"1\":{\"1410\":3,\"1411\":3}}],[\"r2\",{\"1\":{\"1394\":1,\"1469\":2,\"1486\":2,\"1492\":2,\"1495\":4}}],[\"r2=geocoderbys2\",{\"1\":{\"1394\":1}}],[\"r3有一个返回\",{\"1\":{\"1394\":1}}],[\"r3=geocoderbys3\",{\"1\":{\"1394\":1}}],[\"r3~r5\",{\"1\":{\"475\":1}}],[\"r1\",{\"1\":{\"1469\":2,\"1486\":3,\"1492\":2,\"1495\":6}}],[\"r1|r2|r3\",{\"1\":{\"1394\":1}}],[\"r1=geocoderbys1\",{\"1\":{\"1394\":1}}],[\"r1~r100\",{\"1\":{\"542\":1}}],[\"rpchook\",{\"0\":{\"1827\":1}}],[\"rpoplpush\",{\"1\":{\"708\":3}}],[\"rpop\",{\"1\":{\"708\":4}}],[\"rpushx\",{\"1\":{\"708\":2}}],[\"rpush\",{\"1\":{\"708\":4}}],[\"rdb文件名\",{\"1\":{\"746\":1}}],[\"rdb文件使用特定二进制格式保存\",{\"1\":{\"727\":1}}],[\"rdb和aop选择\",{\"0\":{\"731\":1}}],[\"rdb完全够用\",{\"1\":{\"729\":1}}],[\"rdb不适合实时持久化\",{\"1\":{\"727\":1}}],[\"rdb的自动触发只需要在配置文件redis\",{\"1\":{\"724\":1}}],[\"rdb的手动触发分别对应save和bgsave命令\",{\"1\":{\"724\":1}}],[\"rdb的二进制文件中\",{\"1\":{\"723\":1}}],[\"rdb持久化过程由子进程负责\",{\"1\":{\"724\":1}}],[\"rdb持久化是把当前进程数据生成快照保存到硬盘的过程\",{\"1\":{\"723\":1}}],[\"rdb持久化\",{\"0\":{\"722\":1}}],[\"rdb\",{\"0\":{\"732\":1},\"1\":{\"702\":1,\"729\":1,\"732\":1,\"733\":3}}],[\"rdb操作\",{\"0\":{\"143\":1}}],[\"rabbitmq教程\",{\"1\":{\"1863\":1}}],[\"rabbitmq\",{\"1\":{\"1844\":1}}],[\"raisenomatchingbeanfound\",{\"1\":{\"1525\":2}}],[\"rather\",{\"1\":{\"1485\":2,\"1492\":1,\"1496\":1,\"1497\":2}}],[\"race\",{\"1\":{\"1431\":1,\"1497\":1}}],[\"races\",{\"1\":{\"1357\":1}}],[\"rawtypes\",{\"1\":{\"1427\":1,\"1500\":1}}],[\"raw\",{\"1\":{\"806\":1,\"1524\":1}}],[\"raft维基百科\",{\"1\":{\"770\":1}}],[\"radius\",{\"1\":{\"713\":2}}],[\"ram\",{\"1\":{\"670\":1}}],[\"randomuuid\",{\"1\":{\"1486\":1,\"1489\":1}}],[\"rand\",{\"0\":{\"556\":1},\"1\":{\"556\":1,\"557\":1,\"558\":2,\"559\":9,\"704\":3}}],[\"rangeclosed\",{\"1\":{\"1484\":2}}],[\"rangeintspliterator\",{\"1\":{\"1484\":2}}],[\"ranges\",{\"1\":{\"656\":3}}],[\"range\",{\"0\":{\"541\":1},\"1\":{\"467\":2,\"541\":1,\"561\":1,\"646\":1,\"656\":12,\"690\":5,\"692\":1,\"717\":1,\"1484\":2}}],[\"rm删除数据\",{\"0\":{\"625\":1}}],[\"rmi\",{\"0\":{\"1558\":1},\"1\":{\"280\":1}}],[\"r这一行已经存在\",{\"1\":{\"604\":2}}],[\"r字段存放的随机值是8个字段\",{\"1\":{\"558\":1}}],[\"rnd\",{\"1\":{\"541\":6}}],[\"risk\",{\"1\":{\"1497\":1}}],[\"risks\",{\"1\":{\"1497\":1}}],[\"ringbuffer<orderevent>\",{\"1\":{\"1398\":1}}],[\"ringbuffersize\",{\"1\":{\"1397\":2}}],[\"ringbuffer就是一个可自定义大小的环形数组\",{\"1\":{\"1397\":1}}],[\"ringbuffer\",{\"0\":{\"1397\":1},\"1\":{\"1398\":2}}],[\"ringo\",{\"1\":{\"507\":4,\"508\":5,\"509\":1,\"510\":2,\"511\":2,\"513\":1}}],[\"rin\",{\"1\":{\"512\":1}}],[\"right相加的结果溢出\",{\"1\":{\"440\":1}}],[\"rightsssymmetric\",{\"1\":{\"406\":2}}],[\"rightsideview\",{\"1\":{\"403\":2}}],[\"right都不是p\",{\"1\":{\"398\":1}}],[\"right++\",{\"1\":{\"363\":1,\"367\":1}}],[\"right\",{\"1\":{\"296\":4,\"305\":4,\"315\":2,\"338\":2,\"362\":7,\"363\":4,\"366\":13,\"367\":4,\"383\":5,\"395\":11,\"396\":3,\"397\":2,\"398\":4,\"401\":4,\"402\":4,\"403\":5,\"404\":4,\"405\":3,\"406\":20,\"407\":1,\"408\":5,\"409\":7,\"410\":9,\"411\":6,\"412\":2,\"415\":4,\"439\":4,\"440\":4,\"443\":4,\"708\":1,\"1485\":2,\"1492\":2,\"1495\":7}}],[\"r++\",{\"1\":{\"435\":1}}],[\"r\",{\"1\":{\"360\":6,\"364\":5,\"435\":38,\"443\":2,\"558\":6,\"566\":5,\"604\":1,\"1356\":6,\"1394\":5,\"1475\":6,\"1478\":1,\"1485\":4,\"1492\":6,\"1494\":3,\"1495\":3,\"1500\":3}}],[\"rocketmq\",{\"1\":{\"1844\":1}}],[\"rocketmq通信类结构\",{\"0\":{\"1726\":1}}],[\"rocketmq从实践到原理\",{\"0\":{\"1703\":1}}],[\"role\",{\"1\":{\"746\":1,\"1510\":1}}],[\"rollbackon\",{\"1\":{\"1532\":1}}],[\"rollback\",{\"1\":{\"628\":1,\"1532\":5}}],[\"rob\",{\"1\":{\"431\":2}}],[\"roworder\",{\"1\":{\"656\":3}}],[\"row格式的binlog会把删掉的行的整行信息保存起来\",{\"1\":{\"591\":1}}],[\"row格式的binlog里没有了sql语句的原文\",{\"1\":{\"591\":1}}],[\"row格式的缺点是\",{\"1\":{\"591\":1}}],[\"rowid\",{\"1\":{\"558\":6,\"656\":1}}],[\"rowid是6个字节\",{\"1\":{\"558\":1}}],[\"rowid名字的来历\",{\"1\":{\"557\":1}}],[\"rowid>\",{\"1\":{\"492\":1,\"657\":1}}],[\"rowid排序会要求回表\",{\"1\":{\"493\":1}}],[\"rowid排序多访问了一次表t的主键索引\",{\"1\":{\"492\":1}}],[\"rowid排序\",{\"0\":{\"492\":1}}],[\"rows值越不精确\",{\"1\":{\"695\":1}}],[\"rows值越精确\",{\"1\":{\"695\":1}}],[\"rows值精确与否取决于统计时采样的页面数量\",{\"1\":{\"695\":1}}],[\"rows值\",{\"1\":{\"695\":1}}],[\"rows的值是10350\",{\"1\":{\"695\":1}}],[\"rows的话\",{\"1\":{\"621\":1}}],[\"rows是通过采样估算的来的\",{\"1\":{\"533\":1}}],[\"rows用于显示这个表当前有多少行\",{\"1\":{\"533\":1}}],[\"rows=1表示只扫描一行\",{\"1\":{\"505\":1}}],[\"rows=100335\",{\"1\":{\"503\":1}}],[\"rows=4000\",{\"1\":{\"491\":1}}],[\"rows\",{\"1\":{\"466\":2,\"467\":8,\"491\":6,\"498\":1,\"527\":2,\"530\":3,\"557\":3,\"565\":2,\"566\":2,\"568\":3,\"591\":2,\"621\":4,\"656\":7,\"657\":4,\"685\":1,\"690\":3,\"692\":4}}],[\"row\",{\"1\":{\"417\":11,\"466\":2,\"467\":10,\"498\":2,\"508\":2,\"527\":2,\"565\":2,\"568\":1,\"591\":3,\"621\":1,\"632\":5,\"636\":1,\"656\":1,\"675\":9,\"694\":3}}],[\"romve\",{\"1\":{\"354\":1}}],[\"rootbeandefinition\",{\"1\":{\"1509\":1,\"1524\":15,\"1525\":2,\"1527\":1}}],[\"root\",{\"0\":{\"112\":1},\"1\":{\"296\":3,\"302\":7,\"395\":19,\"396\":7,\"397\":7,\"398\":19,\"401\":3,\"402\":3,\"403\":5,\"404\":3,\"405\":10,\"406\":8,\"407\":4,\"408\":6,\"409\":30,\"410\":14,\"411\":13,\"412\":9,\"566\":1,\"707\":1,\"1497\":1}}],[\"routing\",{\"1\":{\"1\":1}}],[\"release\",{\"1\":{\"1496\":1}}],[\"relationship\",{\"1\":{\"1524\":1}}],[\"relative\",{\"1\":{\"1492\":1,\"1500\":1}}],[\"related\",{\"1\":{\"1492\":1}}],[\"relaxed\",{\"1\":{\"1492\":1}}],[\"relayed\",{\"1\":{\"1472\":2,\"1474\":1,\"1475\":6,\"1476\":4,\"1497\":2}}],[\"relay\",{\"1\":{\"590\":1,\"594\":1,\"597\":1,\"604\":1,\"609\":2}}],[\"region\",{\"0\":{\"1620\":1}}],[\"registration\",{\"1\":{\"1535\":6}}],[\"registry\",{\"1\":{\"1524\":3,\"1531\":4}}],[\"registerservletfilter\",{\"1\":{\"1535\":1}}],[\"registerdispatcherservlet\",{\"1\":{\"1535\":1}}],[\"registerdisposablebeanifnecessary\",{\"1\":{\"1524\":1}}],[\"registerdependentbeans\",{\"1\":{\"1525\":1}}],[\"registerdependentbean\",{\"1\":{\"1524\":1}}],[\"registerlisteners\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"registerbeanpostprocessors\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"registerbeandefinition\",{\"1\":{\"1509\":1,\"1524\":1}}],[\"registered\",{\"1\":{\"1524\":3,\"1535\":1}}],[\"registercustomeditor\",{\"1\":{\"1517\":1}}],[\"register\",{\"1\":{\"1451\":5,\"1510\":1,\"1524\":3,\"1535\":1}}],[\"registeralias\",{\"1\":{\"806\":50}}],[\"regardless\",{\"1\":{\"1471\":3}}],[\"requiring\",{\"1\":{\"1485\":2}}],[\"require\",{\"1\":{\"1496\":3}}],[\"requirement\",{\"1\":{\"1477\":2}}],[\"requirements\",{\"1\":{\"1471\":2,\"1497\":1}}],[\"requiredtype\",{\"1\":{\"1524\":7,\"1525\":9}}],[\"required\",{\"1\":{\"1471\":2,\"1492\":1,\"1495\":1,\"1497\":1,\"1499\":1,\"1525\":6}}],[\"requirenonnull\",{\"1\":{\"1471\":5,\"1472\":1,\"1474\":1,\"1475\":6,\"1476\":4,\"1478\":2,\"1486\":1,\"1491\":2,\"1494\":1,\"1495\":2,\"1498\":2,\"1499\":2,\"1500\":5}}],[\"request对象给adapter\",{\"1\":{\"1565\":1}}],[\"request对象转成标准的servlet\",{\"1\":{\"1565\":1}}],[\"request对象\",{\"1\":{\"1565\":1}}],[\"request\",{\"1\":{\"1534\":6,\"1565\":2}}],[\"requestmapping的完成流程\",{\"1\":{\"1534\":1}}],[\"requestingbeanname\",{\"1\":{\"1525\":6}}],[\"requested\",{\"1\":{\"1447\":1,\"1500\":1}}],[\"request作用域\",{\"0\":{\"1147\":1}}],[\"remain\",{\"1\":{\"1497\":1}}],[\"remaining\",{\"1\":{\"1451\":2,\"1452\":2,\"1497\":4,\"1524\":1}}],[\"remote\",{\"1\":{\"701\":1}}],[\"removal\",{\"1\":{\"656\":1}}],[\"removing\",{\"1\":{\"568\":1}}],[\"removesingletonifcreatedfortypecheckonly\",{\"1\":{\"1524\":1}}],[\"removed\",{\"1\":{\"1497\":1}}],[\"removenthfromend\",{\"1\":{\"375\":1}}],[\"removeelements\",{\"1\":{\"371\":1}}],[\"removeelement\",{\"1\":{\"361\":2}}],[\"removeeldestentry\",{\"1\":{\"311\":1}}],[\"removeword\",{\"1\":{\"302\":1}}],[\"remove\",{\"1\":{\"302\":1,\"381\":1,\"399\":1,\"409\":2,\"417\":3,\"441\":1,\"1353\":1,\"1377\":1,\"1378\":2,\"1405\":1,\"1415\":1,\"1434\":2,\"1495\":1,\"1524\":3}}],[\"removechild\",{\"1\":{\"302\":2}}],[\"revents\",{\"1\":{\"1447\":1}}],[\"reverseorder\",{\"1\":{\"1491\":2}}],[\"reversed\",{\"1\":{\"1491\":5}}],[\"reverse函数额外消耗的cpu的资源会更小一些\",{\"1\":{\"489\":1}}],[\"reversewords\",{\"1\":{\"385\":4}}],[\"reverse\",{\"1\":{\"384\":3,\"385\":7,\"489\":1,\"566\":1,\"621\":3}}],[\"reversestr\",{\"1\":{\"384\":1}}],[\"reversestring\",{\"1\":{\"383\":1}}],[\"reverselist\",{\"1\":{\"372\":1}}],[\"rehash\",{\"1\":{\"1430\":1}}],[\"reentrantreadwritelock不支持锁升级\",{\"1\":{\"1375\":1}}],[\"reentrantreadwritelock是可重入的读写锁实现类\",{\"1\":{\"1375\":1}}],[\"reentrantreadwritelock\",{\"0\":{\"1375\":1}}],[\"reentrantlock+condition\",{\"1\":{\"1407\":1}}],[\"reentrantlock\",{\"1\":{\"1379\":4,\"1380\":8}}],[\"reentrantlock获取锁的形式有多种\",{\"1\":{\"1372\":1}}],[\"reentrantlock是可以是公平也可以是非公平的\",{\"1\":{\"1372\":1}}],[\"reentrantlock是jdk层次的锁实现\",{\"1\":{\"1372\":1}}],[\"reentrantlock是一种互斥锁\",{\"1\":{\"1371\":1}}],[\"reentrantlock加锁解锁的逻辑\",{\"1\":{\"1371\":1}}],[\"reentrantlock具备如下特点\",{\"1\":{\"1371\":1}}],[\"reentrantlock详解\",{\"0\":{\"1371\":1}}],[\"reject\",{\"1\":{\"1353\":2}}],[\"rejectedexecutionhandler\",{\"1\":{\"1353\":1}}],[\"reached\",{\"1\":{\"1567\":1}}],[\"reactor线程设计\",{\"0\":{\"1727\":1}}],[\"reactor模式\",{\"0\":{\"864\":1,\"866\":1}}],[\"reactive\",{\"1\":{\"1532\":2}}],[\"reactiveadapter\",{\"1\":{\"1532\":1}}],[\"reactiveadapterregistry\",{\"1\":{\"1532\":2}}],[\"reactivetype\",{\"1\":{\"1532\":2}}],[\"reactivetransactionsupport\",{\"1\":{\"1532\":2}}],[\"reactivetransactionmanager\",{\"1\":{\"1532\":2}}],[\"reactivetransactionmanager用的比较少\",{\"1\":{\"1532\":1}}],[\"reason\",{\"1\":{\"1497\":1}}],[\"readchannel\",{\"1\":{\"1464\":3}}],[\"readcompletionhandler\",{\"1\":{\"1452\":4}}],[\"readbuffer\",{\"1\":{\"1452\":3}}],[\"readbytes\",{\"1\":{\"1451\":5}}],[\"readline\",{\"1\":{\"1450\":2}}],[\"reader\",{\"1\":{\"1450\":4,\"1524\":2,\"1528\":2}}],[\"readfds\",{\"1\":{\"1446\":1}}],[\"read之后\",{\"1\":{\"1443\":1}}],[\"read方法才会返回\",{\"1\":{\"739\":1}}],[\"reading\",{\"1\":{\"735\":1}}],[\"read统计的是\",{\"1\":{\"616\":1}}],[\"readonly的值会被用来做其它逻辑\",{\"1\":{\"575\":1}}],[\"readonly\",{\"1\":{\"575\":1,\"590\":1,\"748\":2}}],[\"read优化的主要目的是尽量使用顺序读盘\",{\"1\":{\"541\":1}}],[\"read的值加1\",{\"1\":{\"491\":1}}],[\"read\",{\"0\":{\"541\":1},\"1\":{\"491\":5,\"541\":2,\"570\":6,\"574\":1,\"577\":1,\"669\":6,\"671\":2,\"690\":3,\"692\":5,\"694\":2,\"740\":4,\"748\":2,\"1350\":1,\"1356\":3,\"1410\":1,\"1411\":1,\"1451\":5,\"1452\":2,\"1462\":1,\"1464\":2,\"1465\":1,\"1524\":1}}],[\"reused\",{\"1\":{\"1496\":1}}],[\"reuse\",{\"1\":{\"807\":1,\"1492\":1,\"1496\":1}}],[\"renamenx\",{\"1\":{\"706\":1}}],[\"rename\",{\"1\":{\"706\":1}}],[\"rendered\",{\"1\":{\"2\":1}}],[\"report\",{\"1\":{\"1497\":4,\"1498\":1}}],[\"reporting\",{\"1\":{\"1497\":1}}],[\"reports\",{\"1\":{\"1497\":7}}],[\"reported\",{\"1\":{\"1497\":5}}],[\"represent\",{\"1\":{\"1500\":1}}],[\"represented\",{\"1\":{\"1497\":1}}],[\"representing\",{\"1\":{\"1496\":1}}],[\"representation\",{\"1\":{\"1492\":1}}],[\"represents\",{\"1\":{\"1474\":2,\"1475\":3,\"1476\":14,\"1477\":2,\"1478\":2,\"1498\":1}}],[\"replaced\",{\"1\":{\"1497\":1}}],[\"replaceall\",{\"1\":{\"1495\":1}}],[\"replacing\",{\"1\":{\"1485\":2}}],[\"replayingdecoder\",{\"0\":{\"888\":1}}],[\"repl\",{\"1\":{\"746\":6}}],[\"replica\",{\"1\":{\"748\":2}}],[\"replicate\",{\"1\":{\"622\":1}}],[\"replication\",{\"1\":{\"609\":1,\"622\":1,\"746\":3}}],[\"replid2\",{\"1\":{\"746\":1}}],[\"replid\",{\"1\":{\"746\":1}}],[\"repeated\",{\"1\":{\"1497\":2}}],[\"repeatedly\",{\"1\":{\"1497\":1}}],[\"repeatedsubstringpattern\",{\"1\":{\"389\":1}}],[\"repeatableread\",{\"1\":{\"669\":1}}],[\"repeatable\",{\"1\":{\"570\":2,\"669\":1}}],[\"rethrow\",{\"1\":{\"1532\":1}}],[\"retval\",{\"1\":{\"1532\":13}}],[\"retentionpolicy\",{\"1\":{\"1471\":1}}],[\"retention\",{\"1\":{\"1471\":1}}],[\"retrieved\",{\"1\":{\"609\":1}}],[\"returnvalue\",{\"1\":{\"1531\":1}}],[\"returns\",{\"1\":{\"1474\":3,\"1475\":12,\"1476\":8,\"1478\":8,\"1486\":1,\"1490\":2,\"1491\":1,\"1492\":1,\"1495\":3,\"1497\":11,\"1499\":1}}],[\"returned\",{\"1\":{\"1447\":1,\"1477\":2,\"1492\":2,\"1495\":1,\"1496\":1,\"1497\":6}}],[\"returning\",{\"0\":{\"985\":1},\"1\":{\"1490\":1,\"1497\":1,\"1524\":2}}],[\"return\",{\"1\":{\"285\":1,\"288\":1,\"296\":1,\"302\":18,\"305\":2,\"311\":2,\"317\":1,\"318\":1,\"319\":1,\"359\":2,\"360\":2,\"361\":2,\"362\":2,\"363\":2,\"364\":1,\"365\":1,\"366\":3,\"367\":2,\"368\":3,\"371\":1,\"372\":1,\"373\":5,\"375\":1,\"376\":2,\"377\":2,\"380\":1,\"381\":2,\"383\":1,\"384\":1,\"385\":5,\"386\":5,\"387\":3,\"388\":3,\"389\":1,\"392\":2,\"393\":1,\"395\":5,\"396\":4,\"397\":5,\"398\":8,\"399\":1,\"400\":3,\"401\":2,\"402\":2,\"403\":4,\"404\":2,\"405\":2,\"406\":14,\"407\":2,\"408\":6,\"409\":8,\"410\":6,\"411\":5,\"412\":3,\"415\":4,\"417\":2,\"419\":1,\"421\":2,\"422\":1,\"424\":7,\"425\":1,\"426\":1,\"427\":1,\"428\":2,\"429\":5,\"430\":2,\"431\":4,\"435\":9,\"437\":1,\"438\":6,\"439\":1,\"440\":2,\"441\":2,\"443\":2,\"720\":1,\"806\":1,\"1352\":1,\"1353\":1,\"1356\":2,\"1362\":1,\"1379\":2,\"1380\":2,\"1394\":1,\"1405\":1,\"1408\":2,\"1425\":2,\"1426\":3,\"1427\":3,\"1430\":2,\"1431\":6,\"1434\":3,\"1471\":6,\"1474\":2,\"1475\":32,\"1476\":20,\"1477\":3,\"1478\":5,\"1480\":4,\"1481\":2,\"1482\":6,\"1483\":2,\"1484\":6,\"1485\":7,\"1486\":6,\"1487\":2,\"1489\":1,\"1490\":8,\"1491\":5,\"1492\":5,\"1493\":5,\"1494\":22,\"1495\":29,\"1496\":1,\"1497\":21,\"1498\":4,\"1499\":5,\"1500\":12,\"1515\":1,\"1516\":4,\"1521\":2,\"1524\":23,\"1525\":25,\"1527\":7,\"1531\":8,\"1532\":9,\"1534\":1,\"1535\":3,\"1540\":1,\"1567\":5}}],[\"received\",{\"1\":{\"1524\":1}}],[\"receive\",{\"1\":{\"1500\":3}}],[\"receiver\",{\"1\":{\"1496\":1}}],[\"recvfrom\",{\"1\":{\"1442\":1}}],[\"recvfrom分别调用一次\",{\"1\":{\"1442\":1}}],[\"recheck\",{\"1\":{\"1353\":3,\"1430\":1}}],[\"recalc系统变量的值为off的话\",{\"1\":{\"696\":1}}],[\"recalc的值作为该属性的值\",{\"1\":{\"696\":1}}],[\"recalc属性\",{\"1\":{\"696\":1}}],[\"recalc属性来指明该表的统计数据存储方式\",{\"1\":{\"696\":1}}],[\"recalc=0时\",{\"1\":{\"696\":1}}],[\"recalc=1时\",{\"1\":{\"696\":1}}],[\"recalc\",{\"1\":{\"696\":2}}],[\"recale决定着服务器是否自动重新计算统计数据\",{\"1\":{\"696\":1}}],[\"recommended\",{\"1\":{\"1498\":1}}],[\"reconfig\",{\"1\":{\"761\":3}}],[\"reconsidering\",{\"1\":{\"656\":2}}],[\"recorded\",{\"1\":{\"1431\":1}}],[\"record\",{\"1\":{\"679\":1,\"1540\":1}}],[\"rec\",{\"1\":{\"579\":1}}],[\"recursive\",{\"1\":{\"1497\":1}}],[\"recursions\",{\"1\":{\"1360\":1}}],[\"recursion\",{\"1\":{\"285\":2,\"403\":4,\"406\":4}}],[\"recusion\",{\"1\":{\"406\":4}}],[\"refreshbeanfactory\",{\"1\":{\"1528\":1}}],[\"refreshing\",{\"1\":{\"1524\":1}}],[\"refresh\",{\"1\":{\"1512\":1,\"1524\":4,\"1528\":3}}],[\"referred\",{\"1\":{\"1496\":1,\"1498\":1}}],[\"referencepipeline<e\",{\"1\":{\"1498\":1,\"1499\":1}}],[\"referencepipeline\",{\"1\":{\"1498\":2,\"1499\":1}}],[\"referencepipeline$2\",{\"1\":{\"1487\":1}}],[\"references\",{\"1\":{\"1471\":4,\"1485\":2,\"1496\":2,\"1524\":2,\"1525\":1}}],[\"reference值为1\",{\"1\":{\"1356\":1}}],[\"reference\",{\"1\":{\"4\":1,\"1476\":2,\"1494\":1,\"1499\":1,\"1500\":2,\"1524\":5}}],[\"reflectionutils\",{\"1\":{\"1525\":2}}],[\"reflected\",{\"1\":{\"1497\":2}}],[\"reflect\",{\"1\":{\"1437\":4,\"1471\":2,\"1497\":1}}],[\"ref的访问方式要比range成本更低\",{\"1\":{\"692\":1}}],[\"refine\",{\"1\":{\"656\":2}}],[\"ref>ref>range>index>all\",{\"1\":{\"467\":1}}],[\"ref\",{\"1\":{\"466\":2,\"467\":11,\"498\":1,\"527\":3,\"646\":1,\"656\":2,\"692\":2}}],[\"red\",{\"1\":{\"1496\":3}}],[\"reducing方法也是借助collectorimpl来实现的collector的\",{\"1\":{\"1495\":1}}],[\"reducingsink>\",{\"1\":{\"1494\":2}}],[\"reducingsink\",{\"1\":{\"1494\":4}}],[\"reducing\",{\"1\":{\"1490\":1,\"1495\":2,\"1500\":1}}],[\"reductions\",{\"1\":{\"1492\":1}}],[\"reduction\",{\"1\":{\"1485\":4,\"1492\":19,\"1493\":2,\"1495\":3,\"1500\":3}}],[\"reduction<\",{\"1\":{\"1485\":1}}],[\"reduceop\",{\"1\":{\"1501\":1}}],[\"reduceop<t\",{\"1\":{\"1494\":1}}],[\"reduceops\",{\"1\":{\"1494\":1}}],[\"reduced\",{\"1\":{\"1485\":2}}],[\"reduce\",{\"1\":{\"1484\":1,\"1485\":2,\"1498\":1}}],[\"redo日志\",{\"0\":{\"698\":1}}],[\"redo\",{\"0\":{\"588\":1},\"1\":{\"460\":1,\"462\":4,\"464\":2,\"482\":2,\"588\":2,\"633\":1}}],[\"redisbook\",{\"1\":{\"1853\":1}}],[\"redis作为当下主流的缓存技术\",{\"1\":{\"1853\":1}}],[\"redis设计与实现\",{\"1\":{\"1846\":1,\"1853\":1}}],[\"redis开发与运维\",{\"1\":{\"770\":1,\"1844\":1}}],[\"redis高可用\",{\"1\":{\"770\":1}}],[\"redis当中使用了raft算法实现领导者选举\",{\"1\":{\"761\":1}}],[\"redis不好在线扩容\",{\"1\":{\"761\":1}}],[\"redis服务器通过响应队列来将指令的返回结果回复给客户端\",{\"1\":{\"742\":1}}],[\"redis同样会为每个客户端套接字关联一个响应队列\",{\"1\":{\"742\":1}}],[\"redis会将每个客户端套接字都关联一个指令队列\",{\"1\":{\"741\":1}}],[\"redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作\",{\"1\":{\"728\":1}}],[\"redis启动之初会读取该文件重新构建数据\",{\"1\":{\"728\":1}}],[\"redis版本演进过程中有多个格式的rdb版本\",{\"1\":{\"727\":1}}],[\"redis加载rdb恢复数据远远快于aof的方式\",{\"1\":{\"727\":1}}],[\"redis父进程判断当前是否存在正在执行的子进程\",{\"1\":{\"725\":1}}],[\"redis还可以将继续响应客户端请求\",{\"1\":{\"725\":1}}],[\"redis进程执行fork操作创建子进程\",{\"1\":{\"724\":1}}],[\"redis持久化文件加载的流程\",{\"1\":{\"721\":1}}],[\"redis支持rdb和aof两种持久化机制\",{\"1\":{\"721\":1}}],[\"redis支持哪些数据类型\",{\"0\":{\"133\":1}}],[\"redisutils工具类很全\",{\"1\":{\"721\":1}}],[\"redisserver\",{\"1\":{\"736\":1}}],[\"redisserializer\",{\"1\":{\"720\":4}}],[\"redisson实现分布式锁的原理\",{\"0\":{\"148\":1}}],[\"redisconfig\",{\"1\":{\"720\":1}}],[\"redisconnectionfactory\",{\"1\":{\"720\":3}}],[\"redisconnection\",{\"1\":{\"720\":1}}],[\"redis02springbootapplicationtests\",{\"1\":{\"720\":1}}],[\"redistemplate<string\",{\"1\":{\"720\":2}}],[\"redistemplate\",{\"1\":{\"720\":9}}],[\"redis也不例外\",{\"1\":{\"720\":1}}],[\"redis<\",{\"1\":{\"720\":1}}],[\"redis正是通过分数来为集合中的成员进行从小到大的排序\",{\"1\":{\"711\":1}}],[\"redis中集合是通过哈希表实现的\",{\"1\":{\"709\":1}}],[\"redis中保存的值也加了1\",{\"1\":{\"534\":1}}],[\"redis列表是简单的字符串列表\",{\"1\":{\"708\":1}}],[\"redis这样设计有两个好处\",{\"1\":{\"706\":1}}],[\"redis命令大全\",{\"1\":{\"706\":1}}],[\"redis是个单线程的程序\",{\"1\":{\"738\":1}}],[\"redis是一个开源\",{\"1\":{\"705\":1}}],[\"redis是一个字典结构的存储服务器\",{\"1\":{\"704\":1}}],[\"redis是什么\",{\"0\":{\"701\":1}}],[\"redis能该干什么\",{\"0\":{\"702\":1}}],[\"redis入门到精通课程\",{\"1\":{\"1853\":1}}],[\"redis入门\",{\"0\":{\"699\":1},\"1\":{\"1844\":1}}],[\"redis在内存不足时\",{\"0\":{\"153\":1}}],[\"redis延迟队列怎么实现的\",{\"0\":{\"152\":1}}],[\"redis为什么能通过lua脚本保证并发的线程安全\",{\"0\":{\"149\":1}}],[\"redis如何实现消息队列\",{\"0\":{\"147\":1}}],[\"redis自增命令使用\",{\"0\":{\"146\":1}}],[\"redis使用单线程为什么速度这么快\",{\"0\":{\"145\":1}}],[\"redis的主从复制模式可以将主节点的数据改变同步给从节点\",{\"1\":{\"758\":1}}],[\"redis的单条命令是保证原子性的\",{\"1\":{\"715\":1}}],[\"redis的事务就是指一组命令的集合\",{\"1\":{\"715\":1}}],[\"redis的set是string类型的无序集合\",{\"1\":{\"709\":1}}],[\"redis的key\",{\"1\":{\"706\":1}}],[\"redis的数据不能永久地留在内存中\",{\"1\":{\"534\":1}}],[\"redis的哨兵模式能自动完成故障发现和故障转移\",{\"1\":{\"758\":1}}],[\"redis的哨兵模式\",{\"0\":{\"144\":1}}],[\"redis的过期删除策略\",{\"0\":{\"142\":1}}],[\"redis\",{\"0\":{\"132\":1,\"706\":1,\"1853\":1},\"1\":{\"701\":1,\"710\":1,\"711\":3,\"714\":1,\"720\":2,\"723\":1,\"725\":1,\"729\":2,\"733\":1,\"736\":2,\"758\":2,\"761\":2,\"763\":1,\"1853\":3}}],[\"rest\",{\"1\":{\"1864\":1}}],[\"restrictions\",{\"1\":{\"1496\":1}}],[\"respecting\",{\"1\":{\"1500\":1}}],[\"respect\",{\"1\":{\"1499\":1}}],[\"responsible\",{\"1\":{\"1360\":1,\"1499\":1}}],[\"response转成网络字节流\",{\"1\":{\"1565\":1}}],[\"responsebyte\",{\"1\":{\"1451\":3}}],[\"response\",{\"1\":{\"719\":2,\"1534\":6,\"1565\":1}}],[\"resizers\",{\"1\":{\"1431\":1}}],[\"resizestamp\",{\"1\":{\"1431\":1}}],[\"resize\",{\"1\":{\"1426\":2,\"1427\":2,\"1431\":2}}],[\"resizing\",{\"1\":{\"1357\":1}}],[\"resolution\",{\"1\":{\"1524\":1}}],[\"resolving\",{\"1\":{\"1524\":1}}],[\"resolveclass\",{\"1\":{\"1540\":1}}],[\"resolvecandidate\",{\"1\":{\"1525\":1}}],[\"resolver\",{\"1\":{\"1525\":5}}],[\"resolveautowiringvalue\",{\"1\":{\"1525\":1}}],[\"resolvenotunique\",{\"1\":{\"1525\":1}}],[\"resolvemultiplebeans\",{\"1\":{\"1525\":1}}],[\"resolveembeddedvalue\",{\"1\":{\"1525\":1}}],[\"resolveshortcut\",{\"1\":{\"1525\":1}}],[\"resolvescopemetadata\",{\"1\":{\"1524\":1}}],[\"resolvefieldvalue\",{\"1\":{\"1525\":1}}],[\"resolvebeforeinstantiation\",{\"1\":{\"1524\":2}}],[\"resolvebeanclass\",{\"1\":{\"1524\":1,\"1527\":1}}],[\"resolvebasepackage\",{\"1\":{\"1524\":1}}],[\"resolvedconstructororfactorymethod\",{\"1\":{\"1527\":1}}],[\"resolvedclass\",{\"1\":{\"1524\":3}}],[\"resolvedependency\",{\"1\":{\"1525\":2}}],[\"resolvedautowiremode\",{\"1\":{\"1524\":5}}],[\"resolvedtargettype\",{\"1\":{\"1524\":1}}],[\"resolved\",{\"1\":{\"1524\":4,\"1527\":4}}],[\"resolve\",{\"1\":{\"1356\":1,\"1491\":1,\"1524\":2,\"1540\":2}}],[\"resolvabledependencies\",{\"1\":{\"1525\":1}}],[\"resolvabletype\",{\"0\":{\"1264\":1}}],[\"resolvable\",{\"0\":{\"1138\":1}}],[\"resource注解可以在不修改源码的情况下完成迁移\",{\"1\":{\"1525\":1}}],[\"resource注解是因为\",{\"1\":{\"1525\":1}}],[\"resource是java规范支持的注解\",{\"1\":{\"1525\":1}}],[\"resource和\",{\"1\":{\"1525\":1}}],[\"resourcepattern\",{\"1\":{\"1524\":1}}],[\"resourcepatternresolver\",{\"1\":{\"1514\":1,\"1524\":1}}],[\"resources声明成一个资源\",{\"1\":{\"1496\":1}}],[\"resources代码块的时候自动得到调用\",{\"1\":{\"1496\":1}}],[\"resources\",{\"1\":{\"1496\":3,\"1524\":3,\"1528\":1}}],[\"resource\",{\"0\":{\"1205\":1},\"1\":{\"1496\":4,\"1524\":6}}],[\"resource接口扩展\",{\"0\":{\"1201\":1}}],[\"resource接口\",{\"0\":{\"1199\":1}}],[\"resetcommoncaches\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"resets\",{\"1\":{\"1500\":1}}],[\"reset\",{\"1\":{\"455\":1,\"1500\":1,\"1524\":2,\"1528\":2}}],[\"res\",{\"1\":{\"366\":7,\"367\":4,\"368\":2,\"395\":11,\"399\":6,\"400\":7,\"403\":8,\"415\":8,\"430\":4,\"1491\":3}}],[\"results\",{\"1\":{\"1477\":3,\"1490\":1,\"1492\":5,\"1497\":1,\"1498\":1,\"1500\":4}}],[\"resultset\",{\"1\":{\"806\":2}}],[\"resulting\",{\"1\":{\"656\":6,\"1495\":1}}],[\"result需要申请本地内存来缓存查询结果\",{\"1\":{\"619\":1}}],[\"result方法\",{\"1\":{\"619\":2}}],[\"result这个提示\",{\"1\":{\"555\":1}}],[\"result\",{\"1\":{\"285\":1,\"288\":1,\"302\":3,\"364\":6,\"467\":1,\"555\":1,\"568\":1,\"719\":4,\"1452\":7,\"1474\":2,\"1475\":18,\"1477\":4,\"1478\":5,\"1485\":20,\"1486\":1,\"1487\":6,\"1490\":1,\"1492\":32,\"1494\":3,\"1495\":5,\"1496\":3,\"1497\":3,\"1498\":1,\"1500\":4,\"1524\":2,\"1525\":17,\"1531\":5,\"1532\":7}}],[\"re\",{\"1\":{\"302\":3,\"1500\":1,\"1524\":3,\"1527\":1}}],[\"d表示map返回的值的类型\",{\"1\":{\"1495\":1}}],[\"d>类型的\",{\"1\":{\"1495\":1}}],[\"d>类型\",{\"1\":{\"1495\":1}}],[\"d>>\",{\"1\":{\"1495\":5}}],[\"d>\",{\"1\":{\"1495\":9}}],[\"dma将磁盘数据复制到内核缓冲区kernel\",{\"1\":{\"1459\":1}}],[\"dma本质上是主板上一块独立的芯片\",{\"1\":{\"1455\":1}}],[\"dma\",{\"0\":{\"1455\":1,\"1460\":1},\"1\":{\"1455\":1,\"1459\":1,\"1460\":8,\"1461\":1,\"1462\":1}}],[\"df\",{\"1\":{\"1405\":1}}],[\"dfsnumber++\",{\"1\":{\"435\":1}}],[\"dfsnumber\",{\"1\":{\"435\":2}}],[\"dfs\",{\"1\":{\"296\":1,\"399\":3,\"400\":3,\"409\":12,\"410\":4,\"411\":4,\"415\":4,\"435\":16}}],[\"druid\",{\"1\":{\"1852\":1}}],[\"driven\",{\"1\":{\"1442\":1}}],[\"dram\",{\"0\":{\"778\":1}}],[\"drop权限\",{\"1\":{\"624\":1}}],[\"drop语句\",{\"1\":{\"622\":1}}],[\"drop\",{\"1\":{\"498\":1,\"499\":2,\"500\":1,\"527\":2,\"537\":1,\"541\":1,\"549\":1,\"550\":5,\"563\":1,\"622\":1,\"643\":3,\"655\":1,\"660\":2}}],[\"dangling\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"day\",{\"1\":{\"690\":1,\"695\":2}}],[\"dateformat\",{\"1\":{\"1405\":2}}],[\"date\",{\"1\":{\"530\":2,\"666\":1,\"806\":4,\"1476\":2,\"1482\":1}}],[\"datetime的存储格式是一个yyyymmdd\",{\"1\":{\"666\":1}}],[\"datetime来存储时间\",{\"1\":{\"666\":1}}],[\"datetime=t\",{\"1\":{\"604\":2}}],[\"datetime\",{\"1\":{\"503\":1,\"561\":1,\"643\":1,\"666\":1}}],[\"datasource\",{\"1\":{\"1507\":1}}],[\"databinder是怎么完成属性类型转换的\",{\"0\":{\"1241\":1}}],[\"databinder数据校验\",{\"0\":{\"1237\":1}}],[\"databinder绑定控制参数\",{\"0\":{\"1233\":1}}],[\"databinder元数据\",{\"0\":{\"1232\":1}}],[\"database\",{\"1\":{\"695\":1}}],[\"database参数\",{\"1\":{\"622\":1}}],[\"database命令删除的数据\",{\"1\":{\"622\":1}}],[\"database语句误删数据库\",{\"1\":{\"620\":1}}],[\"databases\",{\"1\":{\"619\":1,\"704\":2}}],[\"data这个参数来控制排序\",{\"1\":{\"657\":1}}],[\"data的值\",{\"1\":{\"657\":1}}],[\"data配置小点\",{\"1\":{\"657\":1}}],[\"data=16\",{\"1\":{\"558\":1}}],[\"data设置成16\",{\"1\":{\"558\":2}}],[\"data\",{\"1\":{\"285\":1,\"288\":2,\"392\":1,\"492\":1,\"568\":1,\"576\":1,\"591\":1,\"597\":1,\"657\":4,\"685\":2,\"690\":1,\"692\":2,\"720\":1,\"806\":3,\"1361\":1,\"1464\":2,\"1492\":3,\"1494\":1,\"1496\":1,\"1497\":7,\"1498\":2,\"1500\":10}}],[\"dd00\",{\"1\":{\"681\":3,\"684\":6,\"686\":6,\"690\":6,\"691\":6}}],[\"dd\",{\"1\":{\"666\":3,\"1405\":1}}],[\"ddl命令执行到最后阶段\",{\"1\":{\"618\":1}}],[\"dddd\",{\"1\":{\"605\":3}}],[\"d执行kill\",{\"1\":{\"618\":1}}],[\"d中\",{\"1\":{\"613\":1}}],[\"d只需要分别执行change\",{\"1\":{\"605\":1}}],[\"d重新指向的这个过程\",{\"1\":{\"603\":1}}],[\"d也要改接到a\",{\"1\":{\"603\":1}}],[\"d指向的是主库a\",{\"1\":{\"603\":1}}],[\"db8中并不能获取db0中的键值对\",{\"1\":{\"704\":1}}],[\"dbsize\",{\"1\":{\"704\":3}}],[\"dbsize可以查看当前数据库的大小\",{\"1\":{\"704\":1}}],[\"db1+t1+\",{\"1\":{\"599\":3}}],[\"dba\",{\"1\":{\"567\":1}}],[\"dba不让使用join\",{\"1\":{\"537\":1}}],[\"db\",{\"1\":{\"566\":1,\"704\":2,\"706\":1}}],[\"d5\",{\"1\":{\"515\":1}}],[\"d4\",{\"1\":{\"515\":1}}],[\"d3\",{\"1\":{\"515\":1}}],[\"d2\",{\"1\":{\"515\":1}}],[\"d1\",{\"1\":{\"515\":1}}],[\"dubbo是一个基于spring的rpc\",{\"1\":{\"1868\":1}}],[\"dubbo一个高性能优秀的服务框架\",{\"1\":{\"1868\":1}}],[\"dubbo中有一种叫做forking的集群模式\",{\"1\":{\"1394\":1}}],[\"dubbo服务调用底层原理\",{\"0\":{\"803\":1}}],[\"dubbo服务注册与引入底层原理\",{\"0\":{\"800\":1}}],[\"dubbo协议虽好\",{\"1\":{\"798\":1}}],[\"dubbo协议由于请求中没有多余的无用的字节\",{\"1\":{\"798\":1}}],[\"dubbo协议\",{\"0\":{\"798\":1}}],[\"dubbo3\",{\"0\":{\"797\":1}}],[\"dubbo底层实现原理\",{\"0\":{\"796\":1}}],[\"dubbo\",{\"0\":{\"795\":1,\"1868\":1},\"1\":{\"1868\":2}}],[\"dump\",{\"1\":{\"723\":1}}],[\"dummy\",{\"1\":{\"371\":4,\"375\":5}}],[\"duplicate\",{\"1\":{\"615\":1,\"631\":1}}],[\"durable\",{\"1\":{\"729\":1}}],[\"durability\",{\"1\":{\"569\":1}}],[\"duration\",{\"1\":{\"568\":3,\"690\":1,\"692\":2}}],[\"during\",{\"1\":{\"455\":1,\"618\":1,\"1357\":1,\"1476\":4,\"1492\":1,\"1496\":1,\"1497\":1,\"1524\":3,\"1528\":1}}],[\"dsl\",{\"0\":{\"446\":1}}],[\"dp\",{\"1\":{\"326\":2,\"424\":7,\"425\":7,\"426\":11,\"427\":11,\"428\":9,\"429\":15,\"430\":5,\"431\":17,\"432\":5}}],[\"dynamically\",{\"1\":{\"1524\":1}}],[\"dynamic\",{\"1\":{\"325\":1,\"806\":1,\"1535\":1}}],[\"d\",{\"1\":{\"302\":2,\"505\":12,\"566\":1,\"584\":4,\"585\":1,\"665\":1,\"671\":1,\"714\":1,\"1494\":11,\"1495\":3}}],[\"d=d\",{\"1\":{\"1494\":4}}],[\"d=5\",{\"1\":{\"584\":6}}],[\"d=5这条语句\",{\"1\":{\"584\":1}}],[\"d=5这一行的c的值\",{\"1\":{\"584\":1}}],[\"d=100\",{\"1\":{\"584\":3}}],[\"d=20\",{\"1\":{\"458\":1}}],[\"d=\",{\"1\":{\"302\":1}}],[\"di\",{\"1\":{\"1860\":1}}],[\"diagnostic\",{\"1\":{\"1497\":1}}],[\"diagonal2\",{\"1\":{\"417\":4}}],[\"diagonal1\",{\"1\":{\"417\":4}}],[\"diagonals2\",{\"1\":{\"417\":7}}],[\"diagonals1\",{\"1\":{\"417\":7}}],[\"dictionary\",{\"1\":{\"701\":1}}],[\"different\",{\"1\":{\"1496\":1,\"1497\":1}}],[\"differences\",{\"1\":{\"1492\":1}}],[\"diff\",{\"1\":{\"695\":5}}],[\"dir\",{\"1\":{\"761\":1}}],[\"directly\",{\"1\":{\"1496\":1}}],[\"direction\",{\"1\":{\"656\":1,\"657\":2}}],[\"directory\",{\"1\":{\"1\":1}}],[\"dirty\",{\"1\":{\"570\":1,\"669\":1}}],[\"divided\",{\"1\":{\"1498\":1}}],[\"divides\",{\"1\":{\"1497\":1}}],[\"divideconquer\",{\"1\":{\"288\":4}}],[\"dive了\",{\"1\":{\"690\":1}}],[\"dive的方式来计算查询成本\",{\"1\":{\"690\":1}}],[\"dive的方式简单\",{\"1\":{\"690\":1}}],[\"dive的方式计算各个单点区间的索引记录条数\",{\"1\":{\"690\":1}}],[\"dive的方式计算各个单点区间对应的记录数\",{\"1\":{\"690\":1}}],[\"dive的方式去计算这些单点区间对应的记录数也不是什么问题\",{\"1\":{\"690\":1}}],[\"dive操作\",{\"1\":{\"690\":1}}],[\"dive\",{\"0\":{\"690\":1},\"1\":{\"690\":5}}],[\"dives\",{\"1\":{\"656\":1}}],[\"div\",{\"1\":{\"556\":3}}],[\"dinosaur\",{\"1\":{\"521\":1}}],[\"dinosaur中出现的演员\",{\"1\":{\"521\":1}}],[\"dispatcherservlet\",{\"1\":{\"1534\":1,\"1535\":4}}],[\"disposable\",{\"1\":{\"1524\":1}}],[\"disruptor<>\",{\"1\":{\"1398\":1}}],[\"disruptor<orderevent>\",{\"1\":{\"1398\":1}}],[\"disruptordemo\",{\"1\":{\"1398\":1}}],[\"disruptor实战\",{\"0\":{\"1398\":1}}],[\"disruptor\",{\"1\":{\"1397\":1,\"1398\":7}}],[\"disruptor的构造方法\",{\"1\":{\"1397\":1}}],[\"disruptor的核心概念\",{\"1\":{\"1397\":1}}],[\"disruptor会提供多种策略\",{\"1\":{\"1397\":1}}],[\"disruptor通过以下设计来解决队列速度慢的问题\",{\"1\":{\"1396\":1}}],[\"disruptor本质上是一个有界队列\",{\"1\":{\"1396\":1}}],[\"disruptor是一个高性能的队列\",{\"1\":{\"1396\":1}}],[\"discardpolicy\",{\"1\":{\"1353\":1}}],[\"discardoldestpolicy\",{\"1\":{\"1353\":1}}],[\"discarded\",{\"1\":{\"717\":1}}],[\"discard\",{\"1\":{\"716\":1,\"719\":1}}],[\"discurd\",{\"1\":{\"716\":1}}],[\"disk\",{\"1\":{\"558\":1,\"568\":1,\"588\":1,\"694\":2}}],[\"distinct\",{\"1\":{\"487\":5,\"489\":1,\"656\":1,\"1477\":2,\"1486\":2,\"1487\":5,\"1497\":5,\"1499\":1,\"1500\":3}}],[\"disjoint\",{\"1\":{\"356\":1}}],[\"digits\",{\"1\":{\"400\":7,\"566\":1}}],[\"digit\",{\"1\":{\"388\":5}}],[\"doresolvedependency\",{\"1\":{\"1525\":2}}],[\"dowithlocalmethods\",{\"1\":{\"1525\":1}}],[\"dowithlocalfields\",{\"1\":{\"1525\":1}}],[\"downstreamfinisher\",{\"1\":{\"1495\":2}}],[\"downstreamsupplier\",{\"1\":{\"1495\":2}}],[\"downstreamaccumulator\",{\"1\":{\"1495\":6}}],[\"downstream\",{\"1\":{\"1495\":34,\"1499\":1,\"1500\":13}}],[\"down\",{\"1\":{\"761\":2}}],[\"dogetbean\",{\"1\":{\"1524\":2}}],[\"dogetbean方法是创建bean的核心方法\",{\"1\":{\"1524\":1}}],[\"doprivileged\",{\"1\":{\"1524\":2}}],[\"doscan\",{\"1\":{\"1524\":1}}],[\"dosomething\",{\"1\":{\"1496\":4}}],[\"doing\",{\"1\":{\"1499\":1}}],[\"doinit\",{\"1\":{\"1408\":1}}],[\"doesn\",{\"1\":{\"1497\":1}}],[\"does\",{\"1\":{\"1471\":2,\"1494\":1,\"1496\":1,\"1497\":6,\"1499\":1,\"1500\":1}}],[\"done\",{\"1\":{\"1498\":1}}],[\"don\",{\"1\":{\"566\":2}}],[\"do\",{\"1\":{\"530\":2,\"537\":1,\"541\":2,\"551\":1,\"556\":1,\"622\":1,\"635\":1,\"655\":1,\"660\":2,\"1356\":1,\"1427\":1,\"1492\":2,\"1496\":4,\"1497\":4,\"1500\":1,\"1524\":1,\"1525\":1,\"1567\":1}}],[\"doubles\",{\"1\":{\"1500\":2}}],[\"doublestream\",{\"1\":{\"1496\":2}}],[\"doubleadder\",{\"1\":{\"1357\":1}}],[\"doubleaccumulator\",{\"1\":{\"1357\":1}}],[\"double\",{\"1\":{\"310\":1,\"335\":1,\"397\":2,\"438\":7,\"665\":1,\"806\":8,\"1427\":1,\"1482\":1,\"1497\":2}}],[\"docker\",{\"1\":{\"1844\":2}}],[\"docker常用的命令\",{\"0\":{\"265\":1}}],[\"docreatebean\",{\"1\":{\"1524\":2}}],[\"document\",{\"1\":{\"1497\":1}}],[\"documented\",{\"1\":{\"1471\":1,\"1497\":3}}],[\"docs\",{\"1\":{\"4\":1,\"1504\":1}}],[\"dokcer命令\",{\"0\":{\"264\":1}}],[\"dcl单例为什么加volatile\",{\"0\":{\"64\":1}}],[\"demo\",{\"1\":{\"1364\":2}}],[\"despite\",{\"1\":{\"1497\":1}}],[\"desirability\",{\"1\":{\"1497\":1}}],[\"desired\",{\"1\":{\"1496\":1}}],[\"designed\",{\"1\":{\"1492\":1,\"1496\":1,\"1497\":2}}],[\"destruction\",{\"1\":{\"1524\":1}}],[\"destroysingleton\",{\"1\":{\"1524\":1}}],[\"destroybeans\",{\"1\":{\"1524\":1,\"1528\":2}}],[\"destroy\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"destoremethodname\",{\"1\":{\"1509\":1}}],[\"destchannel\",{\"1\":{\"1465\":3}}],[\"dest\",{\"1\":{\"1356\":10}}],[\"destkey\",{\"1\":{\"714\":1,\"715\":2}}],[\"destination\",{\"1\":{\"708\":2,\"709\":4,\"711\":2}}],[\"describes\",{\"1\":{\"1498\":1,\"1500\":2}}],[\"describe\",{\"1\":{\"1496\":1,\"1497\":1}}],[\"described\",{\"1\":{\"1496\":1,\"1500\":3}}],[\"describing\",{\"1\":{\"1496\":1}}],[\"descriptor\",{\"1\":{\"1447\":1,\"1525\":47}}],[\"description\",{\"1\":{\"695\":1,\"1510\":1}}],[\"desc\",{\"1\":{\"467\":1,\"498\":3,\"548\":3,\"551\":1,\"695\":1,\"1488\":1,\"1525\":5}}],[\"decomposition\",{\"1\":{\"1497\":2}}],[\"declaratively\",{\"1\":{\"1496\":1}}],[\"declaration\",{\"1\":{\"1471\":5}}],[\"declareparents动态的为被代理对象增加接口和接口中定义的方法\",{\"1\":{\"1531\":1}}],[\"declared\",{\"1\":{\"1496\":2}}],[\"declares\",{\"1\":{\"1471\":2}}],[\"declare\",{\"1\":{\"537\":1,\"541\":1,\"551\":1,\"556\":1,\"655\":1,\"660\":2}}],[\"decrease\",{\"1\":{\"1497\":1}}],[\"decreasing\",{\"1\":{\"1497\":1}}],[\"decrement\",{\"1\":{\"1359\":3}}],[\"decrby\",{\"1\":{\"707\":2,\"718\":2}}],[\"decr\",{\"1\":{\"707\":2}}],[\"decimal最适合保存准确度要求高\",{\"1\":{\"665\":1}}],[\"decimal\",{\"1\":{\"665\":1,\"806\":2}}],[\"dep\",{\"1\":{\"1524\":6}}],[\"depensdon注解\",{\"1\":{\"1524\":1}}],[\"dependentbean\",{\"1\":{\"1524\":3}}],[\"dependentbeans\",{\"1\":{\"1524\":3}}],[\"dependencies\",{\"1\":{\"656\":2,\"1525\":1}}],[\"dependencyobjectprovider\",{\"1\":{\"1525\":1}}],[\"dependencydescriptor\",{\"1\":{\"1525\":7}}],[\"dependency作为依赖来源\",{\"0\":{\"1138\":1}}],[\"dependency>\",{\"1\":{\"719\":2,\"720\":1}}],[\"dependency\",{\"1\":{\"602\":1,\"1524\":1,\"1525\":1}}],[\"depend\",{\"1\":{\"1496\":1}}],[\"depending\",{\"1\":{\"1492\":2}}],[\"dependson\",{\"1\":{\"1510\":1,\"1524\":3}}],[\"depends\",{\"1\":{\"656\":2,\"1524\":2}}],[\"departures\",{\"1\":{\"1497\":1}}],[\"department\",{\"1\":{\"1492\":1,\"1493\":2}}],[\"depth值相同数量的表进行穷举分析\",{\"1\":{\"693\":1}}],[\"depth系统变量\",{\"1\":{\"693\":1}}],[\"depth++\",{\"1\":{\"396\":1}}],[\"depth\",{\"1\":{\"396\":2,\"411\":5,\"1497\":1,\"1498\":2,\"1499\":2,\"1500\":1}}],[\"dealing\",{\"1\":{\"1498\":1}}],[\"deallocate\",{\"1\":{\"559\":1}}],[\"deadlock\",{\"1\":{\"581\":1}}],[\"debug\",{\"1\":{\"566\":3,\"1356\":7}}],[\"delegate\",{\"1\":{\"1524\":1,\"1525\":1}}],[\"delegation\",{\"1\":{\"1524\":1}}],[\"delete操作会加行锁\",{\"1\":{\"672\":1}}],[\"delete操作会自动给涉及的表加写锁\",{\"1\":{\"672\":1}}],[\"deleted\",{\"1\":{\"624\":1,\"679\":1}}],[\"delete命令的执行效果如下\",{\"1\":{\"591\":1}}],[\"delete\",{\"1\":{\"409\":1,\"530\":2,\"591\":2,\"621\":2,\"678\":1}}],[\"deletecharat\",{\"1\":{\"400\":1}}],[\"delivering\",{\"1\":{\"1500\":1}}],[\"delimiter\",{\"1\":{\"537\":2,\"541\":2,\"551\":2,\"556\":2,\"655\":2,\"660\":4,\"1495\":2}}],[\"del\",{\"1\":{\"706\":2}}],[\"delayqueue\",{\"0\":{\"1385\":1},\"1\":{\"1378\":1}}],[\"delay=n命令\",{\"1\":{\"623\":1}}],[\"delay参数\",{\"1\":{\"602\":1}}],[\"delay设置为0的时候\",{\"1\":{\"588\":1}}],[\"delay表示延迟多少微妙后才调用fsync\",{\"1\":{\"588\":1}}],[\"delay\",{\"1\":{\"588\":4,\"602\":1}}],[\"delay和binlog\",{\"1\":{\"588\":2}}],[\"deviations\",{\"1\":{\"1497\":1}}],[\"device\",{\"1\":{\"694\":1}}],[\"dev\",{\"1\":{\"509\":1,\"647\":2,\"655\":3}}],[\"derived\",{\"1\":{\"467\":1}}],[\"denied\",{\"1\":{\"455\":1,\"459\":1}}],[\"defining\",{\"1\":{\"1540\":1}}],[\"definitionholder\",{\"1\":{\"1524\":5}}],[\"definition\",{\"1\":{\"1471\":3,\"1524\":9,\"1525\":1,\"1528\":1}}],[\"defined\",{\"1\":{\"1471\":2,\"1497\":1,\"1524\":1}}],[\"def\",{\"1\":{\"400\":1,\"549\":5,\"550\":4}}],[\"defaultadvisorautoproxycreator实际上是一个beanpostprocessor\",{\"1\":{\"1531\":1}}],[\"defaultadvisorautoproxycreator\",{\"1\":{\"1531\":6}}],[\"defaultpointcutadvisor\",{\"1\":{\"1531\":8}}],[\"defaultparameternamediscoverer\",{\"1\":{\"1525\":2}}],[\"defaultlistablebeanfactory的父类abstractautowirecapablebeanfactory的构造方法\",{\"1\":{\"1528\":1}}],[\"defaultlistablebeanfactory\",{\"1\":{\"1513\":1,\"1525\":3,\"1528\":3}}],[\"defaultsingletonbeanregistry\",{\"1\":{\"1513\":1,\"1524\":1}}],[\"defaults\",{\"1\":{\"1427\":1}}],[\"defaultthreadfactory\",{\"1\":{\"1398\":1}}],[\"default\",{\"1\":{\"4\":2,\"467\":1,\"473\":2,\"475\":4,\"483\":2,\"490\":1,\"503\":4,\"505\":5,\"537\":2,\"556\":1,\"561\":2,\"566\":2,\"583\":2,\"591\":2,\"596\":1,\"599\":2,\"605\":1,\"613\":1,\"615\":1,\"626\":2,\"643\":7,\"647\":5,\"655\":5,\"660\":3,\"671\":2,\"672\":3,\"1352\":1,\"1427\":4,\"1431\":1,\"1471\":8,\"1472\":2,\"1474\":1,\"1475\":6,\"1476\":6,\"1480\":1,\"1484\":2,\"1491\":1,\"1495\":1,\"1497\":14,\"1498\":2,\"1499\":1,\"1500\":5,\"1524\":1,\"1527\":1}}],[\"deque<treenode>\",{\"1\":{\"397\":1}}],[\"deque<integer>\",{\"1\":{\"392\":2}}],[\"deque<character>\",{\"1\":{\"386\":2}}],[\"dequeue\",{\"1\":{\"335\":1,\"1379\":2,\"1380\":2}}],[\"deterministic\",{\"1\":{\"1497\":4}}],[\"determinetransactionmanager\",{\"1\":{\"1532\":1}}],[\"determinetargettype\",{\"1\":{\"1524\":1}}],[\"determineconstructorsfrombeanpostprocessors\",{\"1\":{\"1527\":1}}],[\"determineautowirecandidate\",{\"1\":{\"1525\":1}}],[\"determinerequiredstatus\",{\"1\":{\"1525\":2}}],[\"determine\",{\"1\":{\"1491\":1,\"1497\":2}}],[\"detected\",{\"1\":{\"1497\":4,\"1524\":1}}],[\"detection\",{\"1\":{\"1497\":1}}],[\"detect\",{\"1\":{\"1496\":1}}],[\"detects\",{\"1\":{\"1496\":1,\"1497\":1}}],[\"detect=on来控制\",{\"1\":{\"581\":1}}],[\"detectcycle\",{\"1\":{\"377\":1}}],[\"detail里id=4的行记为r4\",{\"1\":{\"505\":1}}],[\"detail里的tradeied上的索引快速定位到等值的行\",{\"1\":{\"505\":1}}],[\"detail表上的tradeid字段的字符集也改成utf8mb4\",{\"1\":{\"505\":1}}],[\"detail表成了驱动表\",{\"1\":{\"505\":1}}],[\"detail表中查找条件匹配的行\",{\"1\":{\"505\":1}}],[\"detail上的tradeid索引\",{\"1\":{\"505\":1}}],[\"detail`\",{\"1\":{\"505\":1}}],[\"detail这两个表里插入一些数据\",{\"1\":{\"505\":1}}],[\"detail\",{\"1\":{\"505\":18,\"1492\":1}}],[\"details\",{\"1\":{\"1\":1,\"467\":1,\"698\":1,\"1497\":1,\"1498\":1,\"1526\":1}}],[\"deepin\",{\"1\":{\"1844\":1}}],[\"deep++\",{\"1\":{\"302\":3}}],[\"deep\",{\"1\":{\"302\":17}}],[\"mbdtouse\",{\"1\":{\"1524\":9}}],[\"mbd\",{\"1\":{\"1524\":72,\"1526\":2,\"1527\":18}}],[\"m本身是<k\",{\"1\":{\"1495\":1}}],[\"m>\",{\"1\":{\"1495\":2}}],[\"much\",{\"1\":{\"1500\":1}}],[\"must\",{\"1\":{\"1485\":4,\"1492\":9,\"1494\":1,\"1496\":3,\"1497\":10,\"1498\":2,\"1500\":6,\"1524\":1,\"1535\":3}}],[\"mutablepropertyvalues\",{\"1\":{\"1524\":2}}],[\"mutable\",{\"1\":{\"1485\":5,\"1492\":8,\"1493\":1,\"1497\":5}}],[\"mutablereduction\",{\"1\":{\"1485\":1}}],[\"mutex\",{\"1\":{\"1407\":1}}],[\"multielementdescriptor\",{\"1\":{\"1525\":1}}],[\"multicaster\",{\"1\":{\"1524\":1}}],[\"multi\",{\"0\":{\"541\":1},\"1\":{\"541\":1,\"677\":1,\"716\":4,\"717\":2,\"718\":2,\"719\":6}}],[\"multiplebeans\",{\"1\":{\"1525\":3}}],[\"multiple\",{\"1\":{\"385\":1,\"1485\":2,\"1492\":1,\"1494\":1,\"1496\":1,\"1497\":1,\"1525\":3}}],[\"mp分别是\",{\"1\":{\"1356\":1}}],[\"mp的值存入任意的通用寄存器\",{\"1\":{\"1356\":1}}],[\"mp\",{\"1\":{\"1356\":6}}],[\"m9\",{\"1\":{\"711\":2}}],[\"m7\",{\"1\":{\"711\":3}}],[\"m6\",{\"1\":{\"709\":7}}],[\"m5\",{\"1\":{\"709\":5}}],[\"m4\",{\"1\":{\"709\":11,\"711\":4}}],[\"m3\",{\"1\":{\"709\":11,\"711\":9}}],[\"m2\",{\"1\":{\"709\":11,\"711\":10}}],[\"m1~m4\",{\"1\":{\"709\":1}}],[\"m1\",{\"1\":{\"709\":10,\"711\":8}}],[\"mget\",{\"1\":{\"707\":2}}],[\"ms\",{\"1\":{\"1364\":1}}],[\"msetnx\",{\"1\":{\"707\":2}}],[\"mset\",{\"1\":{\"707\":2}}],[\"msg\",{\"1\":{\"707\":11,\"1499\":5,\"1500\":1}}],[\"mmu内存管理模型\",{\"1\":{\"1567\":1}}],[\"mmap\",{\"1\":{\"1462\":2,\"1463\":1}}],[\"mmap内存映射的拷贝\",{\"1\":{\"1458\":1}}],[\"mmap内存映射拷贝流程\",{\"0\":{\"1458\":1},\"1\":{\"1458\":1}}],[\"mm\",{\"1\":{\"666\":6,\"1405\":2,\"1531\":6}}],[\"m的serverid\",{\"1\":{\"550\":2}}],[\"m的时候\",{\"1\":{\"484\":1}}],[\"mdl的作用是\",{\"1\":{\"578\":1}}],[\"mdl不需要显式使用\",{\"1\":{\"578\":1}}],[\"md\",{\"1\":{\"541\":1}}],[\"mrr=on\",{\"1\":{\"542\":1}}],[\"mrr的优势就用不上了\",{\"1\":{\"542\":1}}],[\"mrr能够提升性能的核心在于\",{\"1\":{\"541\":1}}],[\"mrr\",{\"1\":{\"541\":2,\"542\":1,\"656\":1}}],[\"m中\",{\"1\":{\"540\":1}}],[\"m次\",{\"1\":{\"540\":1}}],[\"m是16\",{\"1\":{\"484\":1}}],[\"m是10\",{\"1\":{\"484\":1}}],[\"mechanism\",{\"1\":{\"1500\":1}}],[\"mechanics\",{\"1\":{\"1497\":1,\"1498\":1}}],[\"merging\",{\"1\":{\"1495\":1,\"1524\":1}}],[\"mergedannotation<\",{\"1\":{\"1525\":2}}],[\"merged\",{\"1\":{\"1524\":8}}],[\"mergedbeandefinitions\",{\"1\":{\"1524\":3}}],[\"mergedbeandefinitionpostprocessor\",{\"1\":{\"1524\":1,\"1525\":1}}],[\"merger\",{\"1\":{\"1495\":6}}],[\"merge\",{\"1\":{\"1492\":1,\"1495\":1}}],[\"merges\",{\"1\":{\"1492\":1}}],[\"means\",{\"1\":{\"1496\":1,\"1524\":1}}],[\"meanings\",{\"1\":{\"1497\":1}}],[\"meaning\",{\"1\":{\"1494\":1}}],[\"meanwhile\",{\"1\":{\"3\":1}}],[\"meeting\",{\"1\":{\"1471\":3}}],[\"methodidentification\",{\"1\":{\"1532\":1}}],[\"methodinterceptor\",{\"1\":{\"1531\":3}}],[\"methodparameter\",{\"1\":{\"1532\":1}}],[\"methodproxy\",{\"1\":{\"1531\":4}}],[\"methodnamecomparator\",{\"1\":{\"1531\":2}}],[\"methodmatcher\",{\"1\":{\"1531\":1}}],[\"methodbeforeadvice\",{\"1\":{\"1531\":1}}],[\"methodreferencedemo\",{\"1\":{\"1479\":1,\"1480\":2,\"1481\":2,\"1482\":2,\"1483\":10}}],[\"method3\",{\"1\":{\"1475\":1}}],[\"method2\",{\"1\":{\"1475\":1}}],[\"method1\",{\"1\":{\"1475\":1}}],[\"method和static\",{\"1\":{\"1471\":1}}],[\"methods\",{\"1\":{\"1471\":4,\"1492\":2,\"1496\":1,\"1497\":7,\"1498\":4,\"1500\":5,\"1525\":2}}],[\"method\",{\"1\":{\"1437\":1,\"1470\":1,\"1471\":12,\"1474\":2,\"1475\":3,\"1476\":2,\"1477\":1,\"1478\":2,\"1485\":2,\"1491\":1,\"1496\":4,\"1497\":10,\"1499\":1,\"1500\":12,\"1524\":3,\"1525\":11,\"1531\":21,\"1532\":13}}],[\"metaspacesize\",{\"1\":{\"1541\":1}}],[\"metaspacesize=n和\",{\"1\":{\"1541\":1}}],[\"metaspacesize=256m\",{\"1\":{\"1541\":1}}],[\"metadatareader表示类的元数据读取器\",{\"1\":{\"1523\":1}}],[\"metadatareader\",{\"0\":{\"1523\":1},\"1\":{\"1523\":4,\"1524\":9}}],[\"metadata\",{\"1\":{\"578\":1,\"1524\":7,\"1525\":4,\"1528\":1}}],[\"meta\",{\"1\":{\"576\":1}}],[\"mesa模型的wait\",{\"1\":{\"1360\":1}}],[\"message模式是完全没有问题的\",{\"1\":{\"1410\":1}}],[\"message模式就完全没有问题\",{\"1\":{\"1410\":1}}],[\"message模式作为一种最简单的分工方案\",{\"1\":{\"1410\":1}}],[\"message模式\",{\"0\":{\"1410\":1}}],[\"message的内建依赖\",{\"0\":{\"1216\":1}}],[\"message\",{\"1\":{\"734\":1,\"735\":2,\"1410\":1,\"1450\":5,\"1451\":9,\"1452\":11,\"1471\":2,\"1524\":2,\"1863\":1}}],[\"messagesource\",{\"1\":{\"1514\":1}}],[\"messagesource开箱实现\",{\"0\":{\"1215\":1}}],[\"messages\",{\"1\":{\"530\":2,\"735\":1}}],[\"member\",{\"1\":{\"709\":2,\"711\":4,\"713\":4}}],[\"member2\",{\"1\":{\"709\":2,\"711\":2,\"713\":2}}],[\"member1\",{\"1\":{\"709\":2,\"711\":2,\"713\":2}}],[\"memory引擎不是索引组织表\",{\"1\":{\"557\":1}}],[\"memory\",{\"1\":{\"546\":1,\"568\":1,\"694\":3,\"1356\":1}}],[\"memory等多个存储引擎\",{\"1\":{\"454\":1}}],[\"mediumtext\",{\"1\":{\"667\":1}}],[\"mediumblob\",{\"1\":{\"667\":1}}],[\"mediumint\",{\"1\":{\"665\":1}}],[\"m−1\",{\"1\":{\"425\":1}}],[\"mno\",{\"1\":{\"400\":1}}],[\"m\",{\"1\":{\"332\":1,\"425\":7,\"427\":4,\"540\":1,\"543\":1,\"548\":2,\"553\":6,\"555\":2,\"559\":3,\"605\":2,\"665\":1,\"713\":2,\"714\":1,\"1357\":3,\"1431\":3,\"1495\":5}}],[\"mooc的课程等\",{\"1\":{\"1846\":1}}],[\"mostly\",{\"1\":{\"1498\":1}}],[\"most\",{\"1\":{\"1474\":2,\"1496\":3,\"1498\":2}}],[\"moved\",{\"1\":{\"1431\":1}}],[\"move\",{\"1\":{\"706\":2}}],[\"movezeroes\",{\"1\":{\"365\":1}}],[\"mono\",{\"1\":{\"1532\":1}}],[\"monitor机制\",{\"0\":{\"1360\":1}}],[\"monitor\",{\"1\":{\"758\":1,\"761\":2,\"1360\":1,\"1361\":1}}],[\"money上锁\",{\"1\":{\"718\":1}}],[\"money\",{\"1\":{\"718\":7}}],[\"month\",{\"1\":{\"503\":1,\"530\":2}}],[\"mongodb入门\",{\"0\":{\"452\":1}}],[\"mongodb\",{\"0\":{\"451\":1}}],[\"modcount\",{\"1\":{\"1423\":1}}],[\"modifier\",{\"1\":{\"1525\":2,\"1527\":1}}],[\"modified<=\",{\"1\":{\"591\":1}}],[\"modified<\",{\"1\":{\"503\":3}}],[\"modified字段加上了month\",{\"1\":{\"503\":1}}],[\"modified字段上已经创建了索引\",{\"1\":{\"503\":1}}],[\"modified这个索引\",{\"1\":{\"503\":1}}],[\"modified更小\",{\"1\":{\"503\":1}}],[\"modified=now\",{\"1\":{\"615\":1}}],[\"modified=\",{\"1\":{\"503\":2,\"591\":1}}],[\"modified索引的示意图\",{\"1\":{\"503\":1}}],[\"modified`\",{\"1\":{\"503\":3,\"591\":3,\"615\":1}}],[\"modified\",{\"1\":{\"503\":8,\"548\":5,\"591\":2,\"615\":2,\"1496\":1}}],[\"modifications\",{\"1\":{\"1497\":2}}],[\"modification\",{\"1\":{\"1496\":1}}],[\"modifiable\",{\"1\":{\"1492\":1}}],[\"modifying\",{\"1\":{\"1496\":1}}],[\"modify\",{\"1\":{\"505\":1,\"1496\":1,\"1524\":2}}],[\"modelandview\",{\"1\":{\"1534\":3}}],[\"mode设置为1\",{\"1\":{\"629\":1}}],[\"mode设置为2\",{\"1\":{\"629\":1}}],[\"mode\",{\"1\":{\"629\":1,\"657\":2,\"678\":1,\"1496\":2}}],[\"mode=on和enforce\",{\"1\":{\"605\":1}}],[\"mode里面显式的是rowid排序\",{\"1\":{\"558\":1}}],[\"mode里面的packed\",{\"1\":{\"491\":1}}],[\"mode变成了<sort\",{\"1\":{\"492\":1}}],[\"mod\",{\"1\":{\"332\":1,\"1427\":1}}],[\"more\",{\"1\":{\"1\":1,\"566\":1,\"1496\":3,\"1497\":2,\"1498\":3,\"1500\":3}}],[\"microservice\",{\"1\":{\"1541\":1}}],[\"misc\",{\"1\":{\"1540\":3}}],[\"missing\",{\"1\":{\"1524\":1}}],[\"might\",{\"1\":{\"1494\":1,\"1496\":2,\"1500\":1,\"1524\":4,\"1528\":1,\"1532\":1}}],[\"millis\",{\"1\":{\"1489\":2}}],[\"milliseconds\",{\"1\":{\"707\":1,\"761\":2}}],[\"mi\",{\"1\":{\"713\":1}}],[\"mixed\",{\"0\":{\"1630\":1}}],[\"mixedsqlnode\",{\"1\":{\"806\":2}}],[\"mixed格式可以利用statement格式的优点\",{\"1\":{\"591\":1}}],[\"mixedde的时候\",{\"1\":{\"550\":1}}],[\"minby\",{\"1\":{\"1478\":3,\"1493\":2}}],[\"mincapacity\",{\"1\":{\"1352\":2}}],[\"minimumtotal\",{\"1\":{\"426\":1}}],[\"minstack\",{\"1\":{\"392\":8}}],[\"minsubarraylen\",{\"1\":{\"363\":1}}],[\"min\",{\"1\":{\"318\":3,\"319\":5,\"363\":1,\"368\":2,\"388\":1,\"392\":1,\"397\":3,\"404\":1,\"411\":1,\"419\":4,\"426\":6,\"441\":2,\"559\":1,\"616\":1,\"646\":1,\"711\":9,\"1487\":2,\"1491\":3,\"1492\":1}}],[\"mid\",{\"1\":{\"305\":6,\"315\":2,\"360\":6,\"439\":5,\"440\":7,\"443\":7,\"1497\":4}}],[\"mq有三大主要作用分别为解耦\",{\"1\":{\"1863\":1}}],[\"mq\",{\"0\":{\"258\":1,\"1863\":1},\"1\":{\"1863\":1}}],[\"mq如何保证消息顺序\",{\"0\":{\"256\":1}}],[\"mycomparatortest\",{\"1\":{\"1491\":1}}],[\"myclass2\",{\"1\":{\"1484\":5}}],[\"myclass\",{\"1\":{\"1484\":10}}],[\"myarray\",{\"1\":{\"1484\":4}}],[\"myatoi\",{\"1\":{\"388\":1}}],[\"mymethod2\",{\"1\":{\"1472\":1}}],[\"mymethod\",{\"1\":{\"1472\":1,\"1484\":9}}],[\"mymaster\",{\"1\":{\"758\":1,\"761\":7}}],[\"mytest\",{\"1\":{\"1472\":13}}],[\"myinterface2\",{\"1\":{\"1484\":5}}],[\"myinterface1impl\",{\"1\":{\"1484\":3}}],[\"myinterface1\",{\"1\":{\"1484\":7}}],[\"myinterface既然满足函数式接口的定义\",{\"1\":{\"1472\":1}}],[\"myinterface\",{\"1\":{\"1471\":1,\"1472\":18}}],[\"myisam在执行查询语句select前会给涉及的所有表加读锁\",{\"1\":{\"672\":1}}],[\"myisam索引文件和数据文件是分离的\",{\"1\":{\"642\":1}}],[\"myisam引擎的自增值保存在数据文件中\",{\"1\":{\"627\":1}}],[\"myisam引擎把一个表的总行数存在了磁盘上\",{\"1\":{\"533\":1}}],[\"myisam分区表使用的分区策略\",{\"1\":{\"562\":1}}],[\"myisam\",{\"1\":{\"454\":1,\"562\":1,\"568\":1,\"671\":1,\"682\":1}}],[\"mykey\",{\"1\":{\"720\":2}}],[\"myelemz\",{\"1\":{\"714\":2}}],[\"myelemy\",{\"1\":{\"714\":3}}],[\"myelemx\",{\"1\":{\"714\":4}}],[\"myzset=>\",{\"1\":{\"711\":1}}],[\"myzset\",{\"1\":{\"711\":19}}],[\"mysuper\",{\"1\":{\"761\":1}}],[\"mysetcollector2<>\",{\"1\":{\"1494\":6}}],[\"mysetcollector2<t>\",{\"1\":{\"1494\":1}}],[\"mysetcollector<>\",{\"1\":{\"1494\":1}}],[\"mysetcollector<t>\",{\"1\":{\"1494\":1}}],[\"myset\",{\"1\":{\"704\":1,\"709\":11}}],[\"mysqrt\",{\"1\":{\"439\":1}}],[\"mysql必知必会\",{\"1\":{\"1852\":1}}],[\"mysql高级教程\",{\"1\":{\"1844\":1}}],[\"mysql高可用系统的可用性\",{\"1\":{\"596\":1}}],[\"mysql还支持很多\",{\"1\":{\"694\":1}}],[\"mysql还有另一个优化\",{\"1\":{\"588\":1}}],[\"mysqladv\",{\"1\":{\"692\":1}}],[\"mysql引入了启发式规则\",{\"1\":{\"691\":1}}],[\"mysql引入了一个临时文件表空间\",{\"1\":{\"549\":1}}],[\"mysql考虑到这种情况\",{\"1\":{\"690\":1}}],[\"mysql把这种通过直接访问索引对应的b+树来计算某个范围区间对应的索引记录条数的方式称之为index\",{\"1\":{\"690\":1}}],[\"mysql评估回表操作的io成本依旧很简单粗暴\",{\"1\":{\"686\":1}}],[\"mysql根据上述算法得到索引项id\",{\"1\":{\"686\":1}}],[\"mysql计算这种查询的成本以来两个方面的数据\",{\"1\":{\"686\":1}}],[\"mysql查询优化器先分析使用唯一二级索引的成本\",{\"1\":{\"686\":1}}],[\"mysql查询成本\",{\"0\":{\"682\":1}}],[\"mysql规定读取一个页面花费的成本默认是1\",{\"1\":{\"682\":1}}],[\"mysql内核查询成本计算实战\",{\"1\":{\"682\":1}}],[\"mysql内部是严格按照事务的启动顺序来分配事务id的\",{\"1\":{\"679\":1}}],[\"mysql内部每秒能够扫描内存中上百万行的数据\",{\"1\":{\"529\":1}}],[\"mysql提出了optimizer\",{\"1\":{\"681\":1,\"693\":1}}],[\"mysql提供可以用来分析当前会话中语句执行的资源消耗情况\",{\"1\":{\"568\":1}}],[\"mysql提供了自动更新和手动更新两种更新统计数据的方式\",{\"1\":{\"696\":1}}],[\"mysql提供了一个系统变量optimizer\",{\"1\":{\"693\":1}}],[\"mysql提供了一个全局读锁的方法\",{\"1\":{\"574\":1}}],[\"mysql提供了日志分析工具mysqldumpslow\",{\"1\":{\"566\":1}}],[\"mysql提供了参数配置\",{\"1\":{\"456\":1}}],[\"mysql成本分析\",{\"0\":{\"681\":1}}],[\"mysql默认的事务隔离级别是可重复读\",{\"1\":{\"669\":1}}],[\"mysql事务与锁\",{\"0\":{\"668\":1}}],[\"mysql能存储的最小时间粒度为秒\",{\"1\":{\"666\":1}}],[\"mysql数据类型的选择\",{\"0\":{\"664\":1}}],[\"mysql数据库服务器的参数调优\",{\"1\":{\"567\":1}}],[\"mysql数据库没有开启慢查询日志\",{\"1\":{\"565\":1}}],[\"mysql通过系统变量innodb\",{\"1\":{\"695\":1}}],[\"mysql通过max\",{\"1\":{\"657\":1}}],[\"mysql通过比较系统变量max\",{\"1\":{\"657\":1}}],[\"mysql通过分析器知道了要做什么\",{\"1\":{\"459\":1}}],[\"mysql索引结构\",{\"0\":{\"638\":1}}],[\"mysql索引结构是什么样的\",{\"0\":{\"160\":1}}],[\"mysql性能优化\",{\"0\":{\"637\":1}}],[\"mysql性能分析工具\",{\"0\":{\"465\":1}}],[\"mysql实战45讲\",{\"1\":{\"636\":1,\"1844\":1,\"1852\":1}}],[\"mysql重启时max\",{\"1\":{\"634\":1}}],[\"mysql重启可能会修改一个表的auto\",{\"1\":{\"627\":1}}],[\"mysql为我们提供了系统变量innodb\",{\"1\":{\"695\":1}}],[\"mysql为每个表维护了一系列的统计信息\",{\"1\":{\"685\":1}}],[\"mysql为什么不会把表t的自增值改回去呢\",{\"1\":{\"628\":1}}],[\"mysql为了让组提交的效果更好\",{\"1\":{\"588\":1}}],[\"mysql客户端默认采用第一种方式\",{\"1\":{\"619\":1}}],[\"mysql客户端发送请求后\",{\"1\":{\"619\":1}}],[\"mysql客户端会提供一个本地库名和表名补全的功能\",{\"1\":{\"619\":1}}],[\"mysql里有很多自增的id\",{\"1\":{\"630\":1}}],[\"mysql里处理kill命令的线程做了两件事情\",{\"1\":{\"618\":1}}],[\"mysql里面表级别的锁有两种\",{\"1\":{\"576\":1}}],[\"mysql里面的锁大致可以分为全局锁\",{\"1\":{\"573\":1}}],[\"mysql库\",{\"1\":{\"614\":1}}],[\"mysql这样设计的原因是\",{\"1\":{\"613\":1}}],[\"mysql这时会选择rowid排序\",{\"1\":{\"557\":1}}],[\"mysql5\",{\"1\":{\"602\":3,\"605\":1,\"629\":1,\"636\":1,\"655\":1,\"666\":1}}],[\"mysql只支持单线程复制\",{\"1\":{\"597\":1}}],[\"mysql要提供高可用能力\",{\"1\":{\"593\":1}}],[\"mysql要给这个innodb表创建一个frm文件保存表结构定义\",{\"1\":{\"549\":1}}],[\"mysql此时使用的statement格式\",{\"1\":{\"591\":1}}],[\"mysql自己实现的\",{\"1\":{\"650\":1}}],[\"mysql自己会判断这条sql语句是否可能引起主备不一致\",{\"1\":{\"591\":1}}],[\"mysql自带的逻辑备份工具是mysqldump\",{\"1\":{\"575\":1}}],[\"mysql自带的引擎是myisam\",{\"1\":{\"462\":1}}],[\"mysqlbinlog工具查看执行的详情\",{\"1\":{\"591\":1}}],[\"mysqlbinlog\",{\"1\":{\"591\":2,\"604\":1}}],[\"mysql认为这样写是有风险的\",{\"1\":{\"591\":1}}],[\"mysqldumpslow\",{\"1\":{\"566\":7}}],[\"mysqld\",{\"1\":{\"565\":3}}],[\"mysql需要把所有的分区都访问一遍\",{\"1\":{\"562\":1}}],[\"mysql需要先从数据表读出记录然后过滤\",{\"1\":{\"527\":1}}],[\"mysql处理limit\",{\"1\":{\"559\":1}}],[\"mysql维护数据表\",{\"1\":{\"549\":1}}],[\"mysql并没有使用simple\",{\"1\":{\"539\":1}}],[\"mysql并不会只查出需要的10条数据\",{\"1\":{\"520\":1}}],[\"mysql优化器可能会选择表t1或t2作为驱动表\",{\"1\":{\"538\":1}}],[\"mysql优化器会找到最小的那棵树来遍历\",{\"1\":{\"533\":1}}],[\"mysql响应数据给客户端就慢得多了\",{\"1\":{\"529\":1}}],[\"mysql从设计上连接和断开连接都很轻量级\",{\"1\":{\"529\":1}}],[\"mysql从整体上来看\",{\"1\":{\"462\":1}}],[\"mysql不会告诉我们生成结果实际上需要扫描多少行数据\",{\"1\":{\"527\":1}}],[\"mysql不需要执行后面的复杂操作\",{\"1\":{\"456\":1}}],[\"mysql有两种情况需要猜出扇出的值\",{\"1\":{\"691\":1}}],[\"mysql有一个批量申请自增id的策略\",{\"1\":{\"629\":1}}],[\"mysql有一个折中的方案\",{\"1\":{\"591\":1}}],[\"mysql有好几种访问方式可以查找并返回一行结果\",{\"1\":{\"527\":1}}],[\"mysql有哪几种数据存储引擎\",{\"0\":{\"156\":1}}],[\"mysql居然还是用的using\",{\"1\":{\"498\":1}}],[\"mysql才会采用rowid排序算法\",{\"1\":{\"493\":1}}],[\"mysql将需要排序的数据分成12份\",{\"1\":{\"491\":1}}],[\"mysql选错索引\",{\"1\":{\"484\":1}}],[\"mysql在执行诸如distinct查询\",{\"1\":{\"694\":1}}],[\"mysql在server层进行连接管理\",{\"1\":{\"694\":1}}],[\"mysql在计算各种链接顺序的成本之前\",{\"1\":{\"693\":1}}],[\"mysql在真实计算成本时会进行一些微调\",{\"1\":{\"685\":1}}],[\"mysql在真正开始执行语句之前\",{\"1\":{\"484\":1}}],[\"mysql在读已提交和可重复读的隔离级别下的隔离性都依靠mvcc\",{\"1\":{\"677\":1}}],[\"mysql在内部维护了一个全局变量global\",{\"1\":{\"633\":1}}],[\"mysql在第一次打开分区表的时候\",{\"1\":{\"562\":1}}],[\"mysql在记录binlog的时候\",{\"1\":{\"550\":2}}],[\"mysql在5\",{\"1\":{\"542\":1}}],[\"mysql在索引idx\",{\"1\":{\"527\":1}}],[\"mysql在使用\",{\"1\":{\"506\":1}}],[\"mysql在対查询结果排序时使用了临时表\",{\"1\":{\"467\":1}}],[\"mysql用错了索引\",{\"1\":{\"483\":1}}],[\"mysql可能会选错索引\",{\"1\":{\"483\":1}}],[\"mysql可以借助重做日志和归档日志恢复到半个月内任意一秒的状态\",{\"1\":{\"460\":1}}],[\"mysql可以分为server层和存储引擎两部分\",{\"1\":{\"454\":1}}],[\"mysql中连接查询采用的是嵌套循环连接算法\",{\"1\":{\"691\":1}}],[\"mysql中的锁的分类\",{\"0\":{\"670\":1}}],[\"mysql中的临时表\",{\"0\":{\"546\":1}}],[\"mysql中默认的日期格式是yyyy\",{\"1\":{\"666\":1}}],[\"mysql中提供了一个类似的命令\",{\"1\":{\"611\":1}}],[\"mysql中查看long\",{\"1\":{\"565\":1}}],[\"mysql中一张表可以支持多个索引\",{\"1\":{\"483\":1}}],[\"mysql中无法利用索引完成的排序操作成为\",{\"1\":{\"467\":1}}],[\"mysql就知道你要做什么了\",{\"1\":{\"651\":1}}],[\"mysql就知道你想要做什么了\",{\"1\":{\"458\":1}}],[\"mysql就确保了主备数据的一致性\",{\"1\":{\"591\":1}}],[\"mysql就会持续出现一个脏读的bug\",{\"1\":{\"634\":1}}],[\"mysql就会把source\",{\"1\":{\"605\":1}}],[\"mysql就会把内存临时表转成磁盘临时表\",{\"1\":{\"553\":1}}],[\"mysql就会使用rowid排序\",{\"1\":{\"492\":1}}],[\"mysql就认为单行太大\",{\"1\":{\"492\":1}}],[\"mysql就能将该查询转化为一个常量\",{\"1\":{\"467\":1}}],[\"mysql异常重启\",{\"1\":{\"464\":1}}],[\"mysql>\",{\"1\":{\"459\":1,\"466\":1,\"467\":6,\"498\":1,\"508\":2,\"565\":4,\"568\":4,\"591\":3}}],[\"mysql会用一些办法减少计算连接顺序的成本的方法\",{\"1\":{\"693\":1}}],[\"mysql会保留修改前的数据undo回滚日志\",{\"1\":{\"679\":1}}],[\"mysql会自动返回记录插入的确切时间\",{\"1\":{\"666\":1}}],[\"mysql会block\",{\"1\":{\"661\":1}}],[\"mysql会直接使用数组来存储这些数据\",{\"1\":{\"555\":1}}],[\"mysql会在临时文件目录下创建一个相同前缀\",{\"1\":{\"549\":1}}],[\"mysql会给每个线程分配一块内存用于排序\",{\"1\":{\"491\":1}}],[\"mysql会根据词法解析的结果分析出可能可以使用的索引作为候选项\",{\"1\":{\"485\":1}}],[\"mysql会通过采样统计的方式来得到索引的基数\",{\"1\":{\"484\":1}}],[\"mysql会递归执行这些子查询\",{\"1\":{\"467\":1}}],[\"mysql会使用wal技术\",{\"1\":{\"461\":1}}],[\"mysql会使用分析器对sql语句做解析\",{\"1\":{\"457\":1}}],[\"mysql会从输入的\",{\"1\":{\"457\":1}}],[\"mysql8\",{\"1\":{\"456\":1}}],[\"mysql拿到一个查询请求后\",{\"1\":{\"456\":1}}],[\"mysql逻辑架构\",{\"0\":{\"454\":1}}],[\"mysql基础\",{\"0\":{\"453\":1}}],[\"mysql如何快速插入千万级数据\",{\"0\":{\"173\":1}}],[\"mysql如何进行分库分表\",{\"0\":{\"166\":1}}],[\"mysql集群是如何搭建的\",{\"0\":{\"165\":1}}],[\"mysql主键索引和普通索引有什么区别\",{\"0\":{\"163\":1}}],[\"mysql的查询优化器会找出执行该语句所有可能使用的方案\",{\"1\":{\"683\":1}}],[\"mysql的查询优化器会优化sql语句的顺序\",{\"1\":{\"515\":3}}],[\"mysql的这套机制看起来虽然复杂\",{\"1\":{\"680\":1}}],[\"mysql的乐观锁\",{\"1\":{\"672\":1}}],[\"mysql的表关联常见的有两种算法\",{\"1\":{\"660\":1}}],[\"mysql的词法分析由mysqllex\",{\"1\":{\"650\":1}}],[\"mysql的tps会高于磁盘的tps\",{\"1\":{\"588\":1}}],[\"mysql的事务启动方式有以下几种\",{\"1\":{\"572\":1}}],[\"mysql的innodb默认隔离级别是\",{\"1\":{\"570\":1}}],[\"mysql的慢查询日志是mysql提供的一种日志记录\",{\"1\":{\"565\":1}}],[\"mysql的优化器除了会统计索引的基数\",{\"1\":{\"484\":1}}],[\"mysql的三种删除方式的区别\",{\"0\":{\"167\":1}}],[\"mysql的索引类型\",{\"0\":{\"172\":1}}],[\"mysql的索引覆盖和回表是什么\",{\"0\":{\"164\":1}}],[\"mysql的索引结构为什么使用b+树\",{\"0\":{\"161\":1}}],[\"mysql的锁有哪些\",{\"0\":{\"159\":1}}],[\"mysql\",{\"0\":{\"155\":1,\"600\":1,\"602\":1,\"698\":1,\"1852\":1},\"1\":{\"455\":2,\"531\":2,\"565\":2,\"566\":6,\"591\":1,\"614\":1,\"615\":3,\"618\":1,\"619\":1,\"634\":1,\"675\":2,\"690\":3,\"694\":3,\"695\":4,\"1852\":4}}],[\"mylist作为候选\",{\"1\":{\"708\":1}}],[\"mylist=>\",{\"1\":{\"708\":3}}],[\"mylist\",{\"1\":{\"704\":1,\"708\":33}}],[\"my\",{\"1\":{\"565\":1,\"1468\":4}}],[\"mypow2helper\",{\"1\":{\"438\":6}}],[\"mypow2\",{\"1\":{\"438\":1}}],[\"mypow\",{\"1\":{\"438\":1}}],[\"mybtais动态sql有什么用\",{\"0\":{\"205\":1}}],[\"mybatis\",{\"1\":{\"1857\":1,\"1860\":1}}],[\"mybatisplus\",{\"1\":{\"1844\":1}}],[\"mybatis提供的默认的别名注册器\",{\"1\":{\"806\":1}}],[\"mybatis源码体系\",{\"0\":{\"806\":1}}],[\"mybatis源码分析\",{\"0\":{\"805\":1}}],[\"mybatis如何开启二级缓存\",{\"0\":{\"209\":1}}],[\"mybatis有二级缓存\",{\"0\":{\"208\":1}}],[\"mybatis有哪些动态sql标签\",{\"0\":{\"204\":1}}],[\"mybatis的功能架构可以分为三层\",{\"1\":{\"806\":1}}],[\"mybatis的体系结构如下\",{\"1\":{\"806\":1}}],[\"mybatis的一级\",{\"0\":{\"207\":1}}],[\"mybatis的xml映射文件中\",{\"0\":{\"198\":1}}],[\"mybatis时如何进行分页的\",{\"0\":{\"203\":1}}],[\"mybatis接口\",{\"0\":{\"197\":1}}],[\"mybatis面试题\",{\"0\":{\"196\":1}}],[\"mvc替换为struts\",{\"1\":{\"1536\":1}}],[\"mvc容器进行管理\",{\"0\":{\"1538\":1}}],[\"mvc容器中查找controller\",{\"1\":{\"1537\":1}}],[\"mvc容器\",{\"1\":{\"1536\":1}}],[\"mvc的容器管理\",{\"1\":{\"1536\":1}}],[\"mvc的请求执行过程\",{\"1\":{\"1534\":1}}],[\"mvc为什么需要父子容器\",{\"0\":{\"1536\":1}}],[\"mvc启动过程\",{\"0\":{\"1535\":1}}],[\"mvc\",{\"1\":{\"1534\":1,\"1857\":1,\"1860\":2}}],[\"mvc执行流程\",{\"0\":{\"1534\":1}}],[\"mvc本质上是基于servlet\",{\"1\":{\"1533\":1}}],[\"mvc源码分析\",{\"0\":{\"1533\":1}}],[\"mvcc机制的实现就是通过read\",{\"1\":{\"679\":1}}],[\"mvcc机制\",{\"0\":{\"678\":1},\"1\":{\"1843\":1}}],[\"mvcc与bufferpool缓冲机制\",{\"0\":{\"677\":1}}],[\"mvcc\",{\"1\":{\"533\":1,\"571\":1}}],[\"mvc原理\",{\"0\":{\"189\":1}}],[\"mvc中的控制器是不是单例模式\",{\"0\":{\"188\":1}}],[\"mask\",{\"1\":{\"1498\":1,\"1499\":1}}],[\"master是否为0更精确\",{\"1\":{\"609\":1}}],[\"master是否已经等于0\",{\"1\":{\"609\":1}}],[\"master=0之后\",{\"1\":{\"596\":1}}],[\"master的单位是秒\",{\"1\":{\"609\":1}}],[\"master的简称\",{\"1\":{\"595\":1}}],[\"master的值足够小\",{\"1\":{\"595\":1}}],[\"master的值\",{\"1\":{\"595\":1}}],[\"master计算的时候会自动扣掉这个差值\",{\"1\":{\"594\":1}}],[\"master来作为主备延迟的值\",{\"1\":{\"594\":1}}],[\"master这个参数计算的就是t3\",{\"1\":{\"594\":1}}],[\"master\",{\"1\":{\"591\":3,\"594\":2,\"595\":1,\"604\":8,\"605\":8,\"609\":7,\"610\":3,\"611\":1,\"622\":2,\"623\":2,\"743\":1,\"746\":4,\"761\":1}}],[\"master命令执行实例a\",{\"1\":{\"605\":1}}],[\"master命令\",{\"1\":{\"590\":1,\"604\":3}}],[\"made\",{\"1\":{\"1497\":2}}],[\"make\",{\"1\":{\"1524\":2,\"1527\":1}}],[\"makesink\",{\"1\":{\"1494\":1}}],[\"makeset\",{\"1\":{\"356\":1}}],[\"makeref方法的说明\",{\"1\":{\"1500\":1}}],[\"makeref\",{\"1\":{\"1494\":2,\"1499\":1,\"1500\":1}}],[\"manually\",{\"1\":{\"1524\":1}}],[\"manipulating\",{\"1\":{\"1498\":1}}],[\"manipulate\",{\"1\":{\"1496\":1}}],[\"manner\",{\"1\":{\"1497\":1}}],[\"mangledfactory\",{\"1\":{\"1495\":3}}],[\"manages\",{\"1\":{\"1497\":1,\"1498\":1}}],[\"managed\",{\"1\":{\"1497\":1}}],[\"management\",{\"1\":{\"1496\":2}}],[\"manage\",{\"1\":{\"1492\":1,\"1500\":1}}],[\"manager\",{\"1\":{\"507\":4,\"508\":2,\"509\":1,\"510\":2,\"647\":1,\"655\":2}}],[\"many\",{\"1\":{\"1485\":2,\"1492\":2,\"1497\":2}}],[\"maven中内置变量\",{\"0\":{\"1047\":1}}],[\"maven\",{\"0\":{\"1041\":1,\"1042\":1,\"1043\":1,\"1858\":1},\"1\":{\"1858\":3}}],[\"macosx\",{\"1\":{\"740\":1}}],[\"may\",{\"1\":{\"656\":1,\"1476\":2,\"1485\":2,\"1492\":4,\"1495\":1,\"1496\":9,\"1497\":16,\"1499\":1,\"1500\":4}}],[\"marking\",{\"0\":{\"1631\":1}}],[\"markbeanascreated\",{\"1\":{\"1524\":1}}],[\"marks\",{\"1\":{\"1498\":1}}],[\"marked\",{\"1\":{\"1361\":1}}],[\"markers\",{\"1\":{\"656\":1,\"657\":1}}],[\"mark\",{\"1\":{\"1361\":3}}],[\"markoop\",{\"1\":{\"1360\":1}}],[\"markdown\",{\"1\":{\"1\":2,\"2\":2}}],[\"mariadb中的并行复制策略\",{\"1\":{\"601\":1}}],[\"mariadb利用了redo\",{\"1\":{\"601\":1}}],[\"mariadb的并行复制策略\",{\"0\":{\"601\":1}}],[\"mairadb已经合并了alisql的这个功能\",{\"1\":{\"578\":1}}],[\"maintain\",{\"1\":{\"1497\":1}}],[\"maintains\",{\"1\":{\"1497\":1}}],[\"mainly\",{\"1\":{\"1357\":1}}],[\"main\",{\"1\":{\"329\":8,\"719\":2,\"1356\":1,\"1364\":1,\"1398\":1,\"1412\":1,\"1428\":1,\"1464\":1,\"1465\":1,\"1468\":3,\"1469\":1,\"1470\":6,\"1471\":1,\"1472\":6,\"1474\":2,\"1475\":6,\"1476\":4,\"1477\":4,\"1478\":1,\"1479\":1,\"1480\":2,\"1481\":2,\"1482\":2,\"1483\":2,\"1484\":10,\"1485\":3,\"1486\":11,\"1487\":9,\"1489\":3,\"1490\":1,\"1491\":1,\"1492\":1,\"1494\":17,\"1496\":8,\"1497\":2,\"1523\":1,\"1531\":2}}],[\"matter\",{\"1\":{\"1497\":1}}],[\"matchingbeans\",{\"1\":{\"1525\":7}}],[\"matching\",{\"1\":{\"1524\":1,\"1532\":2}}],[\"matchop\",{\"1\":{\"1501\":1}}],[\"matches\",{\"1\":{\"1476\":2,\"1516\":1,\"1525\":1,\"1531\":4}}],[\"match\",{\"1\":{\"566\":1,\"709\":1,\"710\":1,\"711\":1,\"1524\":2,\"1525\":1,\"1531\":4}}],[\"matrix\",{\"1\":{\"443\":4}}],[\"mathscore\",{\"1\":{\"711\":2}}],[\"mathscore=>\",{\"1\":{\"711\":1}}],[\"math\",{\"1\":{\"362\":2,\"363\":1,\"367\":1,\"368\":5,\"392\":1,\"396\":1,\"404\":1,\"408\":2,\"419\":1,\"421\":1,\"426\":2,\"427\":1,\"430\":4,\"431\":3,\"1491\":1}}],[\"maxed\",{\"1\":{\"1567\":1}}],[\"maxmetaspacesize\",{\"1\":{\"1541\":2}}],[\"maxmetaspacesize=n\",{\"1\":{\"1541\":1}}],[\"maxmetaspacesize=256m\",{\"1\":{\"1541\":1}}],[\"maximal\",{\"1\":{\"1500\":1}}],[\"maximum\",{\"1\":{\"1427\":5,\"1430\":1,\"1431\":1,\"1492\":1,\"1497\":1,\"1567\":1}}],[\"maximumpoolsize\",{\"1\":{\"1353\":2}}],[\"maxby\",{\"1\":{\"1478\":1,\"1493\":1}}],[\"maxvalue\",{\"1\":{\"561\":1}}],[\"maxans\",{\"1\":{\"430\":4}}],[\"maxarea\",{\"1\":{\"368\":2}}],[\"maxsubarray\",{\"1\":{\"430\":2}}],[\"maxslidingwindow\",{\"1\":{\"393\":1}}],[\"maxlen\",{\"1\":{\"428\":4}}],[\"maxjump\",{\"1\":{\"421\":4}}],[\"maxprofit\",{\"1\":{\"419\":1}}],[\"maxdepthbybfs\",{\"1\":{\"396\":1}}],[\"maxdepth\",{\"1\":{\"396\":3,\"411\":3}}],[\"max\",{\"1\":{\"285\":1,\"363\":3,\"367\":1,\"368\":10,\"388\":4,\"392\":1,\"396\":1,\"397\":4,\"404\":5,\"408\":1,\"419\":1,\"421\":1,\"427\":2,\"430\":4,\"431\":3,\"441\":1,\"480\":1,\"492\":1,\"558\":1,\"559\":1,\"616\":2,\"634\":1,\"657\":1,\"675\":1,\"679\":1,\"711\":8,\"1378\":2,\"1380\":2,\"1386\":1,\"1427\":3,\"1431\":1,\"1487\":1,\"1492\":1,\"1497\":2,\"1500\":1}}],[\"map方法只有唯一的实现\",{\"1\":{\"1499\":1}}],[\"maps\",{\"1\":{\"1495\":1}}],[\"mapfactory\",{\"1\":{\"1495\":2}}],[\"map是最终的结果类型\",{\"1\":{\"1495\":1}}],[\"maptoint\",{\"1\":{\"1487\":4,\"1489\":2,\"1496\":2,\"1500\":1}}],[\"map等\",{\"1\":{\"1486\":1}}],[\"mapmode\",{\"1\":{\"1464\":1}}],[\"map就需要进行resize了\",{\"1\":{\"1428\":1}}],[\"map初始化为一个长度为2的数组\",{\"1\":{\"1428\":1}}],[\"map的存取效率就会越高\",{\"1\":{\"1423\":1}}],[\"map对象很可能就定位不到映射的位置了\",{\"1\":{\"1421\":1}}],[\"map接口的不同实现之间的关系\",{\"1\":{\"1421\":1}}],[\"mapped\",{\"1\":{\"1495\":3}}],[\"mappedbytebuffer\",{\"1\":{\"1464\":1}}],[\"mappedstatement\",{\"1\":{\"806\":1}}],[\"mapperfactorybean的autowiremode为bytype\",{\"1\":{\"1530\":1}}],[\"mapperscannerregistrar类实现了importbeandefinitionregistrar接口\",{\"1\":{\"1530\":1}}],[\"mapperscan导入了mapperscannerregistrar类\",{\"1\":{\"1530\":1}}],[\"mapper\",{\"1\":{\"1495\":7,\"1499\":3}}],[\"mapper编写有哪几种方式\",{\"0\":{\"206\":1}}],[\"mapper内的方法为什么不能重载\",{\"0\":{\"197\":1}}],[\"mappingfunction\",{\"1\":{\"1495\":3}}],[\"mapping方法被用来在累积操作之前对每个输入元素都应用mapping方法\",{\"1\":{\"1495\":1}}],[\"mapping\",{\"1\":{\"806\":1,\"1426\":1,\"1495\":6,\"1500\":4}}],[\"map到数字226\",{\"1\":{\"591\":1}}],[\"map和delete\",{\"1\":{\"591\":1}}],[\"map<class<\",{\"1\":{\"1515\":1}}],[\"map<city\",{\"1\":{\"1495\":2}}],[\"map<character\",{\"1\":{\"386\":1}}],[\"map<t\",{\"1\":{\"1494\":3}}],[\"map<boolean\",{\"1\":{\"1493\":1,\"1495\":4}}],[\"map<department\",{\"1\":{\"1492\":1,\"1493\":2}}],[\"map<k\",{\"1\":{\"1490\":1,\"1495\":6}}],[\"map<string\",{\"1\":{\"400\":2,\"1494\":6,\"1525\":3}}],[\"map<integer\",{\"1\":{\"359\":1,\"381\":1}}],[\"map\",{\"0\":{\"1421\":1},\"1\":{\"311\":1,\"359\":4,\"380\":5,\"381\":5,\"400\":13,\"591\":3,\"656\":3,\"806\":2,\"1417\":1,\"1423\":2,\"1428\":6,\"1431\":2,\"1434\":3,\"1464\":1,\"1484\":1,\"1486\":6,\"1487\":3,\"1490\":1,\"1493\":6,\"1494\":11,\"1495\":5,\"1499\":2,\"1525\":3}}],[\"map三者的区别\",{\"0\":{\"32\":1}}],[\"f=f\",{\"1\":{\"1494\":4}}],[\"f=n\",{\"1\":{\"548\":1}}],[\"fh\",{\"1\":{\"1431\":4}}],[\"fd\",{\"1\":{\"740\":2,\"1446\":3,\"1447\":1}}],[\"fds里面移出来\",{\"1\":{\"742\":1}}],[\"fds\",{\"1\":{\"740\":4,\"1447\":1}}],[\"fence\",{\"1\":{\"1497\":8}}],[\"feeds\",{\"1\":{\"1496\":1}}],[\"few\",{\"1\":{\"656\":1}}],[\"features\",{\"1\":{\"2\":1}}],[\"fsync到磁盘时\",{\"1\":{\"588\":1}}],[\"fsync\",{\"1\":{\"588\":1}}],[\"ft\",{\"1\":{\"713\":1,\"1427\":3}}],[\"ftwrl\",{\"1\":{\"574\":1}}],[\"ftime>=\",{\"1\":{\"562\":1}}],[\"ftime=\",{\"1\":{\"562\":1}}],[\"ftime的值分别是\",{\"1\":{\"561\":1}}],[\"ftime\",{\"1\":{\"561\":1}}],[\"further\",{\"1\":{\"1497\":4}}],[\"future的实现\",{\"1\":{\"1407\":1}}],[\"future的局限性\",{\"1\":{\"1393\":1}}],[\"futures\",{\"1\":{\"1394\":5}}],[\"future<integer>\",{\"1\":{\"1394\":3}}],[\"future接口中没有关于异常处理的方法\",{\"1\":{\"1393\":1}}],[\"future只提供了get\",{\"1\":{\"1393\":1}}],[\"future\",{\"0\":{\"1393\":1},\"1\":{\"1497\":1}}],[\"func\",{\"1\":{\"599\":3}}],[\"functions\",{\"1\":{\"1492\":8,\"1496\":1}}],[\"function我们都知道它接收一个参数\",{\"1\":{\"1490\":1}}],[\"function这个函数式接口本身接口t类型的参数\",{\"1\":{\"1486\":1}}],[\"function这个包下面\",{\"1\":{\"1478\":1}}],[\"function2\",{\"1\":{\"1475\":4}}],[\"function1\",{\"1\":{\"1475\":4}}],[\"functiontest\",{\"1\":{\"1475\":19}}],[\"function提供了一个接收一个参数并且返回一个结果的函数\",{\"1\":{\"1475\":1}}],[\"function<partition<a>\",{\"1\":{\"1495\":1}}],[\"function<map<k\",{\"1\":{\"1495\":1}}],[\"function<r\",{\"1\":{\"1495\":1}}],[\"function<set<t>\",{\"1\":{\"1494\":2}}],[\"function<string\",{\"1\":{\"1483\":1}}],[\"function<a\",{\"1\":{\"1492\":1,\"1493\":3,\"1495\":2}}],[\"function<integer\",{\"1\":{\"1475\":7}}],[\"function<\",{\"1\":{\"1475\":6,\"1490\":1,\"1495\":7,\"1499\":1}}],[\"function<v\",{\"1\":{\"1475\":2}}],[\"function<t\",{\"1\":{\"1475\":5,\"1486\":1}}],[\"function就是其中一个\",{\"1\":{\"1475\":1}}],[\"function函数式接口\",{\"0\":{\"1475\":1}}],[\"functioninterface这个注解\",{\"1\":{\"1471\":3}}],[\"functioninterface的注解\",{\"1\":{\"1471\":1}}],[\"functionality\",{\"1\":{\"1496\":1}}],[\"functionalinterfacetest\",{\"1\":{\"1472\":17}}],[\"functionalinterface注解\",{\"1\":{\"1471\":1}}],[\"functionalinterface这个注解\",{\"1\":{\"1471\":2}}],[\"functionalinterface\",{\"1\":{\"1471\":9,\"1472\":3,\"1474\":1,\"1475\":2,\"1476\":1,\"1477\":1,\"1478\":1,\"1480\":1,\"1485\":1,\"1486\":1,\"1491\":1}}],[\"functional\",{\"1\":{\"1470\":1,\"1471\":13,\"1474\":5,\"1475\":3,\"1476\":2,\"1477\":1,\"1478\":3,\"1496\":1}}],[\"function\",{\"1\":{\"568\":1,\"1470\":1,\"1474\":1,\"1475\":108,\"1476\":2,\"1479\":1,\"1483\":2,\"1485\":10,\"1486\":2,\"1490\":1,\"1492\":19,\"1494\":4,\"1495\":10,\"1496\":2,\"1497\":2}}],[\"fully\",{\"1\":{\"1524\":1}}],[\"fulladdcount\",{\"1\":{\"1431\":1}}],[\"fullstack\",{\"1\":{\"307\":2}}],[\"full\",{\"1\":{\"4\":1,\"467\":2,\"1524\":1}}],[\"fly\",{\"1\":{\"1524\":1}}],[\"flip\",{\"1\":{\"1410\":1,\"1411\":1,\"1451\":4,\"1452\":4}}],[\"flatmap\",{\"1\":{\"1486\":3}}],[\"flags\",{\"1\":{\"1498\":1,\"1499\":1,\"1500\":5}}],[\"flags中设置acc\",{\"1\":{\"1360\":1}}],[\"flag\",{\"1\":{\"679\":2,\"1524\":2,\"1528\":1}}],[\"flashback恢复数据的原理\",{\"1\":{\"621\":1}}],[\"flow\",{\"1\":{\"1500\":1,\"1532\":1}}],[\"float\",{\"1\":{\"665\":1,\"806\":8,\"1352\":1,\"1423\":1,\"1427\":3}}],[\"floor函数在这里的作用\",{\"1\":{\"559\":1}}],[\"floor\",{\"1\":{\"559\":5}}],[\"flux\",{\"1\":{\"1532\":1}}],[\"flushall\",{\"1\":{\"704\":1,\"720\":1}}],[\"flushdb\",{\"1\":{\"704\":1,\"720\":1}}],[\"flush\",{\"1\":{\"574\":1,\"588\":6,\"694\":1}}],[\"flutter实战\",{\"1\":{\"1844\":1}}],[\"flutter\",{\"1\":{\"8\":1,\"1844\":1}}],[\"fresh\",{\"1\":{\"1485\":2,\"1500\":1}}],[\"freemark\",{\"1\":{\"1856\":1}}],[\"free\",{\"1\":{\"1492\":2}}],[\"freenext\",{\"1\":{\"1360\":1}}],[\"freebsd\",{\"1\":{\"740\":1}}],[\"freeing\",{\"1\":{\"568\":1}}],[\"framwork有哪些核心模块\",{\"0\":{\"1064\":1}}],[\"frameworkservlet\",{\"1\":{\"1535\":1}}],[\"framework的核心知识点\",{\"1\":{\"1507\":1}}],[\"framework的优势和不足是什么\",{\"0\":{\"1065\":1}}],[\"framework\",{\"0\":{\"1063\":1},\"1\":{\"1497\":2}}],[\"framework特性运用\",{\"0\":{\"1026\":1}}],[\"framework中使用设计模式的实现\",{\"0\":{\"1016\":1}}],[\"frm的文件中\",{\"1\":{\"627\":1}}],[\"frm文件和4个\",{\"1\":{\"561\":1}}],[\"frm\",{\"1\":{\"549\":1}}],[\"fromcharacteristics\",{\"1\":{\"1498\":1}}],[\"from表名的语法\",{\"1\":{\"690\":1}}],[\"from后面的是派生表查询\",{\"1\":{\"645\":1}}],[\"from\",{\"1\":{\"385\":1,\"454\":1,\"456\":1,\"458\":1,\"459\":1,\"466\":1,\"467\":5,\"472\":2,\"473\":1,\"475\":1,\"477\":1,\"478\":1,\"479\":1,\"482\":1,\"483\":4,\"484\":1,\"485\":2,\"486\":1,\"487\":2,\"488\":2,\"489\":1,\"490\":1,\"491\":4,\"498\":3,\"503\":3,\"504\":2,\"505\":7,\"507\":6,\"508\":2,\"509\":2,\"510\":2,\"511\":2,\"512\":12,\"513\":3,\"515\":15,\"521\":2,\"527\":4,\"530\":2,\"531\":4,\"532\":1,\"537\":1,\"538\":3,\"539\":1,\"540\":1,\"541\":1,\"544\":3,\"545\":2,\"546\":2,\"548\":4,\"550\":2,\"551\":1,\"553\":3,\"554\":1,\"555\":1,\"556\":1,\"557\":1,\"558\":3,\"559\":9,\"566\":1,\"568\":5,\"571\":1,\"585\":2,\"591\":1,\"613\":1,\"614\":1,\"616\":1,\"646\":6,\"651\":1,\"655\":1,\"656\":5,\"657\":4,\"659\":6,\"661\":1,\"662\":5,\"663\":4,\"674\":1,\"675\":3,\"681\":2,\"684\":1,\"686\":2,\"690\":4,\"691\":5,\"692\":2,\"694\":3,\"695\":3,\"761\":2,\"1356\":4,\"1375\":1,\"1471\":2,\"1488\":1,\"1490\":1,\"1491\":1,\"1492\":6,\"1494\":2,\"1495\":1,\"1496\":1,\"1497\":9,\"1498\":2,\"1500\":1,\"1524\":1,\"1540\":1}}],[\"frontmatter\",{\"1\":{\"3\":1}}],[\"fk\",{\"1\":{\"527\":5}}],[\"ffffffffffff\",{\"1\":{\"605\":3}}],[\"ff\",{\"1\":{\"473\":1}}],[\"f3\",{\"1\":{\"424\":4}}],[\"f2=\",{\"1\":{\"1394\":1}}],[\"f2\",{\"1\":{\"424\":4,\"486\":1,\"1394\":1}}],[\"f1\",{\"1\":{\"424\":3,\"486\":1,\"1394\":2}}],[\"fold\",{\"1\":{\"1492\":1}}],[\"folds\",{\"1\":{\"1492\":1}}],[\"follows\",{\"1\":{\"1500\":1}}],[\"following\",{\"1\":{\"1485\":2,\"1492\":2,\"1493\":1,\"1496\":1,\"1497\":1,\"1498\":1}}],[\"followed\",{\"1\":{\"1474\":2}}],[\"follower\",{\"1\":{\"743\":1}}],[\"follow\",{\"1\":{\"707\":1}}],[\"four\",{\"1\":{\"1492\":1}}],[\"found\",{\"1\":{\"381\":1,\"1524\":1,\"1525\":1,\"1540\":2,\"1872\":1}}],[\"foo=f\",{\"1\":{\"1403\":1}}],[\"foo线程安全\",{\"1\":{\"1403\":1}}],[\"foo具备不可变性\",{\"1\":{\"1403\":1}}],[\"foo\",{\"1\":{\"1403\":8}}],[\"foobared\",{\"1\":{\"761\":1}}],[\"fox\",{\"1\":{\"1398\":1}}],[\"forfallbackmatch\",{\"1\":{\"1525\":1}}],[\"forfalse\",{\"1\":{\"1495\":9}}],[\"fortrue\",{\"1\":{\"1495\":9}}],[\"forelements\",{\"1\":{\"1525\":1}}],[\"foreachtask<>\",{\"1\":{\"1500\":1}}],[\"foreachtask\",{\"1\":{\"1500\":1}}],[\"foreachop\",{\"1\":{\"1500\":1,\"1501\":1}}],[\"foreachops\",{\"1\":{\"1499\":1}}],[\"foreachorderedtask<>\",{\"1\":{\"1500\":1}}],[\"foreachordered\",{\"1\":{\"1498\":2}}],[\"foreachremaining\",{\"1\":{\"1497\":18,\"1498\":2,\"1499\":4,\"1500\":1}}],[\"foreach实际上是调用iterable这个类中jdk1\",{\"1\":{\"1470\":1}}],[\"foreach\",{\"1\":{\"1470\":5,\"1471\":2,\"1472\":2,\"1474\":2,\"1475\":1,\"1479\":1,\"1480\":3,\"1481\":3,\"1482\":3,\"1484\":4,\"1485\":2,\"1486\":9,\"1487\":4,\"1488\":1,\"1492\":1,\"1494\":2,\"1496\":4,\"1497\":2,\"1498\":2,\"1499\":6}}],[\"foreign\",{\"1\":{\"527\":1}}],[\"forked\",{\"1\":{\"1496\":1,\"1497\":1}}],[\"forkjoin是一种基于分治算法的模型\",{\"1\":{\"1391\":1}}],[\"forkjoinworkthread是用于执行任务的线程\",{\"1\":{\"1390\":1}}],[\"forkjoinworkthread\",{\"0\":{\"1390\":1}}],[\"forkjoinworkerthreadfactory\",{\"1\":{\"1387\":1}}],[\"forkjoinpool\",{\"1\":{\"1494\":27,\"1497\":1}}],[\"forkjoinpool引入了工作窃取设计\",{\"1\":{\"1388\":1}}],[\"forkjoinpool与threadpoolexecutor有个很大的不同之处在于\",{\"1\":{\"1388\":1}}],[\"forkjoinpool多个线程\",{\"1\":{\"1387\":1}}],[\"forkjoinpool中有四个核心参数\",{\"1\":{\"1387\":1}}],[\"forkjoinpool是threadpoolexecutor线程池的一种补充\",{\"1\":{\"1387\":1}}],[\"forkjoinpool最适合计算密集型任务\",{\"1\":{\"1387\":1}}],[\"forkjoinpool允许其他线程向它提交任务\",{\"1\":{\"1387\":1}}],[\"forkjoin的基本思想是分治\",{\"1\":{\"1387\":1}}],[\"forkjoin实现原理\",{\"0\":{\"1387\":1}}],[\"fork进程的时候\",{\"1\":{\"727\":1}}],[\"fork\",{\"1\":{\"725\":1,\"1387\":1,\"1497\":1}}],[\"fork操作过程中父进程会阻塞\",{\"1\":{\"725\":1}}],[\"format\",{\"1\":{\"690\":1,\"692\":1}}],[\"format=mixed时\",{\"1\":{\"596\":1}}],[\"format=\",{\"1\":{\"591\":1}}],[\"format=statement时\",{\"1\":{\"591\":1}}],[\"format=statment\",{\"1\":{\"550\":1,\"629\":1}}],[\"format=row和binlog\",{\"1\":{\"621\":1}}],[\"format=row情况又会如何呢\",{\"1\":{\"596\":1}}],[\"format=row的时候\",{\"1\":{\"591\":1}}],[\"format=row\",{\"1\":{\"550\":2,\"622\":1,\"629\":1}}],[\"force\",{\"1\":{\"483\":1,\"1567\":1}}],[\"for\",{\"1\":{\"1\":1,\"3\":1,\"4\":1,\"302\":3,\"317\":2,\"318\":2,\"319\":5,\"326\":3,\"329\":4,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"364\":4,\"365\":2,\"366\":4,\"367\":1,\"368\":2,\"375\":1,\"380\":1,\"381\":3,\"384\":1,\"385\":1,\"386\":2,\"387\":2,\"393\":2,\"399\":1,\"400\":1,\"401\":1,\"402\":1,\"403\":1,\"409\":1,\"411\":1,\"417\":2,\"419\":1,\"421\":1,\"424\":2,\"425\":4,\"426\":3,\"427\":2,\"428\":3,\"429\":3,\"430\":2,\"431\":2,\"435\":2,\"437\":1,\"441\":1,\"455\":1,\"459\":1,\"492\":1,\"558\":3,\"566\":1,\"568\":2,\"584\":1,\"585\":2,\"604\":1,\"611\":2,\"631\":1,\"656\":6,\"657\":7,\"674\":1,\"678\":1,\"740\":2,\"806\":1,\"1364\":1,\"1394\":3,\"1398\":1,\"1426\":2,\"1427\":1,\"1430\":1,\"1431\":2,\"1468\":2,\"1470\":2,\"1471\":1,\"1472\":5,\"1476\":7,\"1478\":4,\"1480\":1,\"1485\":11,\"1486\":1,\"1488\":2,\"1489\":1,\"1491\":2,\"1492\":15,\"1494\":1,\"1495\":3,\"1496\":5,\"1497\":45,\"1498\":13,\"1499\":6,\"1500\":21,\"1523\":1,\"1524\":27,\"1525\":4,\"1527\":1,\"1528\":2,\"1531\":2,\"1535\":1}}],[\"fair\",{\"1\":{\"1379\":2}}],[\"failing\",{\"1\":{\"1493\":1,\"1497\":2}}],[\"failure就是这个函数执行失败的回调函数\",{\"1\":{\"1470\":1}}],[\"failure\",{\"1\":{\"1470\":2,\"1496\":2,\"1524\":1,\"1532\":2}}],[\"failed\",{\"1\":{\"1452\":5,\"1496\":2,\"1524\":5,\"1525\":2,\"1535\":1}}],[\"fail\",{\"1\":{\"1356\":1,\"1497\":8,\"1524\":1}}],[\"failover\",{\"1\":{\"761\":4}}],[\"fallbackdescriptor\",{\"1\":{\"1525\":3}}],[\"fallback\",{\"1\":{\"1357\":1,\"1525\":1}}],[\"falseentry\",{\"1\":{\"1495\":2}}],[\"false=\",{\"1\":{\"1490\":1}}],[\"false\",{\"1\":{\"302\":8,\"373\":3,\"386\":3,\"387\":1,\"397\":2,\"398\":1,\"406\":8,\"412\":1,\"421\":1,\"428\":2,\"440\":1,\"443\":1,\"656\":10,\"657\":2,\"1353\":2,\"1379\":1,\"1408\":2,\"1426\":1,\"1430\":1,\"1431\":1,\"1451\":3,\"1476\":4,\"1484\":3,\"1486\":1,\"1495\":1,\"1497\":4,\"1498\":1,\"1499\":2,\"1524\":4,\"1527\":2,\"1540\":1,\"1567\":1}}],[\"factorybeaninstancecache\",{\"1\":{\"1524\":1}}],[\"factorybean<\",{\"1\":{\"1524\":2}}],[\"factorybean的处理逻辑\",{\"1\":{\"1524\":1}}],[\"factorybean\",{\"0\":{\"1521\":1},\"1\":{\"1521\":1,\"1524\":1}}],[\"factorybeanregistrysupport\",{\"1\":{\"1513\":1}}],[\"factory\",{\"1\":{\"1387\":1,\"1492\":1,\"1495\":1,\"1509\":4,\"1524\":11,\"1525\":3}}],[\"factor\",{\"1\":{\"1352\":1,\"1427\":1}}],[\"factories中也一定能找到这个类的完全限定名\",{\"1\":{\"720\":1}}],[\"fanout\",{\"1\":{\"691\":1}}],[\"faults\",{\"1\":{\"568\":1}}],[\"fastjson\",{\"1\":{\"719\":1}}],[\"fast指向null\",{\"1\":{\"375\":1}}],[\"fast++\",{\"1\":{\"361\":2}}],[\"fast\",{\"1\":{\"361\":8,\"373\":6,\"375\":6,\"377\":7,\"1497\":8}}],[\"fido\",{\"1\":{\"1387\":1}}],[\"fifo\",{\"1\":{\"806\":1}}],[\"finsher就得到了调用\",{\"1\":{\"1494\":1}}],[\"finishrefresh\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"finishbeanfactoryinitialization\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"finishing\",{\"1\":{\"1495\":1}}],[\"finish去掉\",{\"1\":{\"1495\":1}}],[\"finish特性去掉的原因在于\",{\"1\":{\"1495\":1}}],[\"finish特性\",{\"1\":{\"1495\":1}}],[\"finish这个枚举值\",{\"1\":{\"1494\":1}}],[\"finish这个特性\",{\"1\":{\"1494\":1}}],[\"finish表示finisher方法就是identity方法\",{\"1\":{\"1494\":1}}],[\"finish\",{\"1\":{\"1492\":1,\"1494\":5,\"1495\":7}}],[\"finisher方法就不会得到执行\",{\"1\":{\"1495\":1}}],[\"finisher\",{\"1\":{\"1492\":12,\"1493\":6,\"1494\":11,\"1495\":11}}],[\"finishconnect\",{\"1\":{\"1451\":1}}],[\"final语义中的内存屏障\",{\"0\":{\"1647\":1}}],[\"final\",{\"1\":{\"1352\":3,\"1357\":1,\"1379\":8,\"1380\":12,\"1397\":5,\"1403\":5,\"1405\":1,\"1410\":1,\"1411\":1,\"1423\":9,\"1425\":1,\"1426\":1,\"1427\":1,\"1430\":1,\"1431\":5,\"1434\":1,\"1482\":1,\"1486\":3,\"1491\":2,\"1492\":5,\"1493\":5,\"1494\":1,\"1495\":6,\"1497\":14,\"1498\":4,\"1499\":3,\"1500\":5,\"1524\":1,\"1525\":2,\"1528\":1,\"1532\":5}}],[\"finally\",{\"1\":{\"719\":1,\"1379\":2,\"1380\":4,\"1394\":1,\"1405\":1,\"1410\":1,\"1411\":1,\"1430\":1,\"1431\":1,\"1450\":1,\"1451\":2,\"1452\":2,\"1524\":4,\"1525\":1,\"1528\":1,\"1532\":2}}],[\"findloadedclass\",{\"1\":{\"1540\":1}}],[\"findaspectjannotationonmethod\",{\"1\":{\"1531\":1}}],[\"findautowirecandidates方法会返回class对象\",{\"1\":{\"1525\":1}}],[\"findautowirecandidates\",{\"1\":{\"1525\":2}}],[\"findautowiredannotation\",{\"1\":{\"1525\":2}}],[\"findautowiringmetadata\",{\"1\":{\"1525\":2}}],[\"findpropertyformethod\",{\"1\":{\"1525\":1}}],[\"findbootstrapclassornull\",{\"1\":{\"1540\":1}}],[\"findbottomleftvalue\",{\"1\":{\"411\":2}}],[\"findbridgedmethod\",{\"1\":{\"1525\":1}}],[\"findclass\",{\"1\":{\"1540\":2}}],[\"findcandidatecomponents\",{\"1\":{\"1524\":1}}],[\"findcontentchildren\",{\"1\":{\"422\":1}}],[\"findop\",{\"1\":{\"1501\":1}}],[\"findfirst\",{\"1\":{\"1486\":1,\"1489\":2}}],[\"find\",{\"1\":{\"356\":1,\"398\":7,\"1525\":1,\"1540\":1}}],[\"first收集器\",{\"0\":{\"1617\":1}}],[\"first从返回包解析出gtid的值即可\",{\"1\":{\"611\":1}}],[\"first\",{\"1\":{\"566\":1,\"746\":1,\"1380\":4,\"1430\":4,\"1475\":14,\"1486\":1,\"1492\":1,\"1496\":3,\"1497\":4,\"1500\":2,\"1525\":1}}],[\"field2\",{\"1\":{\"710\":3}}],[\"field1\",{\"1\":{\"710\":3}}],[\"fields\",{\"1\":{\"1525\":1}}],[\"fields>\",{\"1\":{\"657\":1}}],[\"fields的意思是\",{\"1\":{\"491\":1}}],[\"field\",{\"1\":{\"467\":1,\"489\":1,\"657\":2,\"710\":9,\"1356\":1,\"1524\":1,\"1525\":11}}],[\"fib\",{\"1\":{\"429\":3}}],[\"filo栈结构\",{\"1\":{\"1360\":1}}],[\"filters\",{\"1\":{\"1535\":3}}],[\"filterpropertydescriptorsfordependencycheck\",{\"1\":{\"1524\":2}}],[\"filtertype\",{\"1\":{\"1522\":2}}],[\"filtering代表的百分比\",{\"1\":{\"692\":2}}],[\"filtering可以让成本估算更精确\",{\"1\":{\"691\":1}}],[\"filtering\",{\"1\":{\"656\":1,\"691\":1,\"1500\":4}}],[\"filter\",{\"1\":{\"622\":1,\"1475\":2,\"1487\":7,\"1488\":2,\"1489\":2,\"1496\":3,\"1500\":1,\"1522\":2,\"1535\":4,\"1856\":1}}],[\"filteredpds\",{\"1\":{\"1524\":7}}],[\"filtered\",{\"1\":{\"466\":1,\"467\":5,\"498\":1,\"643\":1,\"690\":1,\"692\":2}}],[\"film2\",{\"1\":{\"643\":1}}],[\"film\",{\"1\":{\"521\":4,\"527\":17,\"643\":1,\"646\":8}}],[\"fill\",{\"1\":{\"417\":2}}],[\"filenotfoundexception\",{\"1\":{\"1524\":1}}],[\"filename\",{\"1\":{\"566\":1}}],[\"fileoutputstream\",{\"1\":{\"1468\":1}}],[\"filechannel\",{\"1\":{\"1464\":5,\"1465\":4}}],[\"file和exec\",{\"1\":{\"609\":2}}],[\"file和read\",{\"1\":{\"609\":2}}],[\"file和master\",{\"1\":{\"605\":1}}],[\"file=$master\",{\"1\":{\"604\":1}}],[\"file=\",{\"1\":{\"565\":1}}],[\"filex\",{\"1\":{\"482\":1}}],[\"file\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":1,\"565\":1,\"604\":1,\"610\":2,\"616\":9,\"728\":1,\"1447\":1,\"1496\":1}}],[\"files是0\",{\"1\":{\"558\":1}}],[\"files的值却是0\",{\"1\":{\"558\":1}}],[\"files的值就越大\",{\"1\":{\"491\":1}}],[\"files变成10了\",{\"1\":{\"492\":1}}],[\"files就是0\",{\"1\":{\"491\":1}}],[\"files表示的是\",{\"1\":{\"491\":1}}],[\"files中看到是否使用了临时文件\",{\"1\":{\"491\":1}}],[\"filesort文件排序方式\",{\"1\":{\"657\":1}}],[\"filesort表示的是需要执行排序操作\",{\"1\":{\"557\":1}}],[\"filesort说明排序没有用到c4字段\",{\"1\":{\"515\":1}}],[\"filesort了\",{\"1\":{\"493\":1}}],[\"filesort\",{\"1\":{\"467\":2,\"491\":1,\"498\":2,\"515\":4,\"553\":1,\"558\":1,\"657\":16}}],[\"files\",{\"1\":{\"1\":1,\"562\":1,\"657\":2,\"1496\":1}}],[\"f\",{\"1\":{\"332\":4,\"425\":1,\"426\":3,\"430\":4,\"431\":2,\"438\":2,\"551\":1,\"714\":1,\"1394\":2,\"1403\":1,\"1431\":9,\"1486\":10,\"1494\":14}}],[\"s>\",{\"1\":{\"1500\":1}}],[\"s>>\",{\"1\":{\"1496\":1,\"1500\":1}}],[\"s指的是实现了basestream类型的流对象\",{\"1\":{\"1496\":1}}],[\"sg\",{\"1\":{\"1460\":1}}],[\"snapshot\",{\"1\":{\"733\":1}}],[\"sdiffstore\",{\"1\":{\"709\":1}}],[\"sdiff\",{\"1\":{\"709\":5}}],[\"srcchannel\",{\"1\":{\"1465\":4}}],[\"sring更加适合字符串存储\",{\"1\":{\"710\":1}}],[\"srem\",{\"1\":{\"709\":3}}],[\"srandmember\",{\"1\":{\"709\":4}}],[\"smartinstantiationawarebeanpostprocessor\",{\"1\":{\"1525\":1}}],[\"smartinitialize\",{\"1\":{\"1524\":2}}],[\"smartinitializingsingleton\",{\"1\":{\"1524\":3}}],[\"smartsingleton\",{\"1\":{\"1524\":3}}],[\"smart\",{\"1\":{\"1524\":1}}],[\"smartfactorybean<\",{\"1\":{\"1524\":2}}],[\"smartfactorybean\",{\"1\":{\"1524\":2}}],[\"small\",{\"1\":{\"1497\":1}}],[\"smaller\",{\"1\":{\"1497\":1}}],[\"smallint\",{\"1\":{\"665\":1}}],[\"sms等方式去通知系统管理员关于系统不正常运行的信息\",{\"1\":{\"761\":1}}],[\"smove\",{\"1\":{\"709\":3}}],[\"smembers\",{\"1\":{\"709\":6}}],[\"s2表是驱动表\",{\"1\":{\"692\":1}}],[\"s2的扇出\",{\"1\":{\"692\":1}}],[\"s2连接s1\",{\"1\":{\"692\":1}}],[\"s2作为被驱动表\",{\"1\":{\"692\":1}}],[\"s2\",{\"1\":{\"691\":5,\"692\":14,\"1491\":3}}],[\"s1表是被驱动表\",{\"1\":{\"692\":1}}],[\"s1的扇出\",{\"1\":{\"692\":1}}],[\"s1作为被驱动表\",{\"1\":{\"692\":1}}],[\"s1连接s2\",{\"1\":{\"692\":1}}],[\"s1\",{\"1\":{\"691\":15,\"692\":14,\"1491\":3}}],[\"ssh\",{\"1\":{\"1857\":1}}],[\"sshift\",{\"1\":{\"1430\":1}}],[\"ssm\",{\"1\":{\"1857\":2,\"1861\":3}}],[\"ssm框架视频\",{\"1\":{\"1860\":1}}],[\"ssm框架\",{\"0\":{\"1860\":1},\"1\":{\"1844\":1}}],[\"ssc\",{\"1\":{\"1410\":2,\"1411\":3}}],[\"ssc=\",{\"1\":{\"1410\":1}}],[\"sscan\",{\"1\":{\"709\":1}}],[\"ss的整数\",{\"1\":{\"666\":1}}],[\"ss\",{\"1\":{\"666\":2,\"1405\":1}}],[\"s结构\",{\"1\":{\"592\":1}}],[\"s结果\",{\"1\":{\"592\":1}}],[\"swarm\",{\"1\":{\"1844\":1}}],[\"swaps\",{\"1\":{\"568\":1}}],[\"swing\",{\"1\":{\"1468\":2}}],[\"switches\",{\"1\":{\"568\":1}}],[\"switch\",{\"1\":{\"542\":1}}],[\"switch=\",{\"1\":{\"541\":1}}],[\"satb算法\",{\"0\":{\"1622\":1}}],[\"satisfy\",{\"1\":{\"1492\":1}}],[\"satisfies\",{\"1\":{\"1471\":2}}],[\"said\",{\"1\":{\"1524\":1}}],[\"sacrifice\",{\"1\":{\"1499\":1}}],[\"salaries\",{\"1\":{\"1492\":3,\"1493\":2}}],[\"says\",{\"1\":{\"1492\":2}}],[\"same\",{\"1\":{\"1478\":6,\"1492\":3,\"1494\":1,\"1496\":2,\"1497\":2,\"1500\":1,\"1524\":1,\"1525\":1,\"1527\":1,\"1535\":1}}],[\"sampe\",{\"1\":{\"695\":1}}],[\"sample\",{\"1\":{\"695\":8}}],[\"saving\",{\"1\":{\"725\":1}}],[\"save\",{\"1\":{\"724\":3,\"725\":1,\"726\":1,\"1394\":1}}],[\"save命令\",{\"1\":{\"724\":1}}],[\"sadd\",{\"1\":{\"709\":3}}],[\"sakura\",{\"1\":{\"704\":1,\"707\":1,\"710\":1,\"735\":10,\"748\":4}}],[\"sakila\",{\"1\":{\"521\":6,\"527\":6}}],[\"sa\",{\"1\":{\"625\":1}}],[\"safedateformat\",{\"1\":{\"1405\":2}}],[\"safe的能力\",{\"1\":{\"462\":1}}],[\"safe\",{\"1\":{\"461\":1,\"621\":2,\"1497\":1}}],[\"shift\",{\"1\":{\"1431\":2}}],[\"shiro有什么区别\",{\"0\":{\"221\":1}}],[\"should\",{\"1\":{\"1492\":3,\"1494\":1,\"1496\":2,\"1497\":13,\"1498\":1,\"1500\":1,\"1525\":1}}],[\"shortcut\",{\"1\":{\"1525\":3,\"1527\":1}}],[\"shortcutdependencydescriptor\",{\"1\":{\"1525\":1}}],[\"short\",{\"1\":{\"806\":8,\"1447\":2,\"1476\":8,\"1500\":4}}],[\"show\",{\"0\":{\"568\":1},\"1\":{\"467\":1,\"483\":1,\"547\":2,\"557\":1,\"565\":6,\"566\":1,\"567\":2,\"568\":9,\"591\":1,\"631\":1,\"640\":1,\"646\":1,\"669\":1,\"671\":1,\"675\":2,\"685\":1,\"690\":2,\"694\":1,\"695\":2}}],[\"sh\",{\"1\":{\"761\":2}}],[\"shape\",{\"1\":{\"1498\":3,\"1500\":4}}],[\"sharing\",{\"1\":{\"1396\":1}}],[\"sharedinstance\",{\"1\":{\"1524\":5}}],[\"shared\",{\"1\":{\"1497\":1,\"1499\":1,\"1524\":1}}],[\"share\",{\"1\":{\"654\":1,\"674\":1,\"678\":1,\"1367\":1}}],[\"shanghai\",{\"1\":{\"713\":2}}],[\"shadow\",{\"1\":{\"698\":1}}],[\"shutdown\",{\"1\":{\"480\":1,\"1398\":1,\"1411\":1,\"1450\":1}}],[\"sql经典练习题\",{\"1\":{\"1852\":1}}],[\"sql匹配\",{\"0\":{\"1783\":1}}],[\"sqlsession对象是mybatis中的\",{\"1\":{\"1530\":1}}],[\"sqlsession是一种门面设计模式\",{\"1\":{\"807\":1}}],[\"sqlsessiontemplate\",{\"1\":{\"720\":1}}],[\"sqlsource\",{\"1\":{\"806\":2}}],[\"sql对应的对象\",{\"1\":{\"806\":1}}],[\"sql解析\",{\"1\":{\"806\":1}}],[\"sql优化阶段\",{\"1\":{\"656\":1}}],[\"sql准备阶段\",{\"1\":{\"656\":1}}],[\"sql标准的事务隔离级别包括\",{\"1\":{\"570\":1}}],[\"sql执行和执行结果映射处理等\",{\"1\":{\"806\":1}}],[\"sql执行阶段\",{\"1\":{\"656\":1,\"657\":1}}],[\"sql执行底层原理\",{\"0\":{\"648\":1}}],[\"sql执行计划\",{\"1\":{\"498\":1}}],[\"sql执行流程\",{\"0\":{\"460\":1}}],[\"sql语句耦合在代码中\",{\"1\":{\"806\":1}}],[\"sql语句的分析分为词法分析与语法分析\",{\"1\":{\"650\":1}}],[\"sql语句可能如下\",{\"1\":{\"503\":1}}],[\"sql语句\",{\"1\":{\"498\":1}}],[\"sql语句是这么写的\",{\"1\":{\"477\":1}}],[\"sql语句执行流程是怎样的\",{\"0\":{\"166\":1}}],[\"sql的执行计划\",{\"1\":{\"466\":1,\"499\":1}}],[\"sql如下\",{\"1\":{\"460\":1}}],[\"sql\",{\"1\":{\"456\":1,\"457\":1,\"466\":1,\"549\":1,\"555\":1,\"559\":3,\"590\":2,\"604\":1,\"616\":1,\"659\":1,\"806\":1,\"1860\":1}}],[\"sliceops$1\",{\"1\":{\"1487\":1}}],[\"slf4j\",{\"1\":{\"1356\":3}}],[\"slaves依然会被正确配置为指向master\",{\"1\":{\"761\":1}}],[\"slaves\",{\"1\":{\"746\":1}}],[\"slave之前\",{\"1\":{\"622\":1}}],[\"slave\",{\"1\":{\"592\":1,\"594\":1,\"604\":2,\"605\":2,\"623\":1,\"701\":1,\"743\":1}}],[\"slave命令之前还有一行set\",{\"1\":{\"605\":1}}],[\"slave命令让同步线程执行起来的时候\",{\"1\":{\"605\":1}}],[\"slave命令\",{\"1\":{\"590\":1,\"605\":1}}],[\"sleepingwaitstrategy策略\",{\"1\":{\"1397\":1}}],[\"sleep方法会清除中断标识\",{\"1\":{\"1354\":1}}],[\"sleep方案\",{\"1\":{\"606\":1}}],[\"sleep\",{\"0\":{\"608\":1},\"1\":{\"455\":1,\"608\":1,\"613\":1,\"1401\":1,\"1410\":1,\"1411\":1}}],[\"slow++\",{\"1\":{\"361\":2}}],[\"slow\",{\"1\":{\"361\":6,\"373\":4,\"375\":6,\"377\":4,\"565\":13,\"566\":6}}],[\"sj​是回文串其它情况​\",{\"1\":{\"428\":2}}],[\"sbd\",{\"1\":{\"1524\":4}}],[\"sbase\",{\"1\":{\"1430\":1}}],[\"sb\",{\"1\":{\"409\":6}}],[\"scm\",{\"1\":{\"1859\":1}}],[\"scopenotactiveexception\",{\"1\":{\"1524\":1}}],[\"scopename\",{\"1\":{\"1524\":5}}],[\"scopedinstance\",{\"1\":{\"1524\":2}}],[\"scopes\",{\"1\":{\"1524\":1}}],[\"scopemetadataresolver\",{\"1\":{\"1524\":1}}],[\"scopemetadata\",{\"1\":{\"1524\":4}}],[\"scope\",{\"1\":{\"1498\":1,\"1509\":1,\"1510\":1,\"1524\":9}}],[\"score均为0\",{\"1\":{\"711\":2}}],[\"score=\",{\"1\":{\"1490\":1}}],[\"score=2\",{\"1\":{\"711\":1}}],[\"score=1\",{\"1\":{\"711\":1}}],[\"score2\",{\"1\":{\"711\":1}}],[\"score相同索引值按字典顺序顺序增加\",{\"1\":{\"711\":1}}],[\"score相同\",{\"1\":{\"711\":1}}],[\"score\",{\"1\":{\"711\":3,\"1480\":7,\"1482\":10,\"1490\":17}}],[\"sc\",{\"1\":{\"1410\":4,\"1411\":4,\"1431\":19}}],[\"scavenge收集器\",{\"0\":{\"1604\":1}}],[\"scatter\",{\"0\":{\"1460\":1},\"1\":{\"1460\":3,\"1462\":1}}],[\"scard\",{\"1\":{\"709\":3}}],[\"scanning\",{\"1\":{\"1524\":1}}],[\"scannedgenericbeandefinition\",{\"1\":{\"1509\":1,\"1524\":2}}],[\"scanner\",{\"1\":{\"1450\":2,\"1451\":2,\"1452\":2,\"1512\":2,\"1524\":1,\"1528\":1}}],[\"scancandidatecomponents\",{\"1\":{\"1524\":1}}],[\"scanandlockforput\",{\"1\":{\"1430\":1}}],[\"scanandlockforput会去查找是否有key相同node\",{\"1\":{\"1430\":1}}],[\"scans\",{\"1\":{\"656\":1}}],[\"scan\",{\"1\":{\"467\":2,\"656\":6,\"690\":1,\"692\":2,\"1512\":1}}],[\"scripting\",{\"1\":{\"806\":1}}],[\"scripts\",{\"1\":{\"761\":1}}],[\"script\",{\"1\":{\"566\":1,\"761\":4,\"1855\":1}}],[\"schema常见有哪些\",{\"0\":{\"1195\":1}}],[\"schema系统库锁相关数据表\",{\"1\":{\"675\":1}}],[\"schema项\",{\"1\":{\"616\":1}}],[\"schema都需要额外地统计这些信息\",{\"1\":{\"616\":1}}],[\"schema库\",{\"1\":{\"616\":1}}],[\"schema库的innodb\",{\"1\":{\"571\":1,\"578\":1}}],[\"schema`\",{\"1\":{\"491\":1,\"558\":1}}],[\"schema\",{\"0\":{\"979\":1,\"980\":1,\"981\":1,\"982\":1,\"983\":1,\"984\":1,\"985\":1,\"986\":1,\"987\":1,\"988\":1},\"1\":{\"491\":2,\"571\":1,\"616\":2,\"634\":1,\"656\":2,\"657\":2,\"675\":3,\"681\":1}}],[\"schars\",{\"1\":{\"387\":3}}],[\"scss\",{\"1\":{\"4\":1}}],[\"skip\",{\"1\":{\"385\":4,\"604\":4,\"605\":2,\"1487\":5,\"1524\":1}}],[\"s\",{\"1\":{\"356\":1,\"383\":8,\"384\":3,\"385\":6,\"386\":6,\"387\":5,\"389\":5,\"409\":5,\"422\":4,\"428\":8,\"473\":1,\"566\":6,\"714\":1,\"1430\":4,\"1431\":5,\"1471\":2,\"1474\":2,\"1493\":2,\"1496\":5,\"1497\":9,\"1499\":4,\"1500\":10,\"1524\":4,\"1528\":1,\"1532\":1,\"1850\":1}}],[\"sychronized+wait\",{\"1\":{\"1407\":1}}],[\"sychronized关键字和wait\",{\"1\":{\"1360\":1}}],[\"sys\",{\"1\":{\"632\":4}}],[\"system>const\",{\"1\":{\"646\":1}}],[\"system>const>eq\",{\"1\":{\"467\":1}}],[\"system\",{\"1\":{\"329\":5,\"467\":2,\"568\":2,\"719\":3,\"720\":1,\"1362\":1,\"1364\":3,\"1428\":2,\"1450\":4,\"1451\":4,\"1452\":5,\"1464\":1,\"1465\":1,\"1468\":9,\"1469\":3,\"1470\":7,\"1471\":1,\"1472\":13,\"1474\":2,\"1475\":12,\"1476\":7,\"1477\":5,\"1478\":2,\"1479\":1,\"1480\":4,\"1481\":4,\"1482\":4,\"1483\":2,\"1484\":9,\"1485\":2,\"1486\":10,\"1487\":17,\"1488\":2,\"1489\":8,\"1491\":1,\"1492\":2,\"1493\":8,\"1494\":18,\"1496\":11,\"1497\":4,\"1499\":3,\"1509\":1,\"1510\":1,\"1511\":1,\"1512\":1,\"1515\":1,\"1517\":1,\"1523\":2,\"1524\":2,\"1531\":4,\"1540\":2}}],[\"synchronization\",{\"1\":{\"1485\":2,\"1492\":1,\"1499\":1}}],[\"synchronized来保证并发安全性\",{\"1\":{\"1431\":1}}],[\"synchronized来实现的\",{\"1\":{\"1352\":1}}],[\"synchronized在特定的情况下对于已经在等待的线程是后来的线程先获得锁\",{\"1\":{\"1372\":1}}],[\"synchronized在jdk1\",{\"1\":{\"1360\":1}}],[\"synchronized是不可以被中断的\",{\"1\":{\"1372\":1}}],[\"synchronized是非公平锁\",{\"1\":{\"1372\":1}}],[\"synchronized是jvm层次的锁实现\",{\"1\":{\"1372\":1}}],[\"synchronized是jvm内置锁\",{\"1\":{\"1360\":1}}],[\"synchronized的锁状态是无法在代码中直接判断的\",{\"1\":{\"1372\":1}}],[\"synchronized的优化\",{\"0\":{\"1366\":1}}],[\"synchronized和reentrantlock\",{\"0\":{\"1372\":1}}],[\"synchronized标志来实现\",{\"1\":{\"1360\":1}}],[\"synchronized加锁方式\",{\"1\":{\"1359\":1}}],[\"synchronized同步块是java提供的一种原子性内置锁\",{\"1\":{\"1359\":1}}],[\"synchronized\",{\"1\":{\"1359\":5,\"1362\":2,\"1408\":3,\"1431\":2,\"1482\":1,\"1524\":3,\"1525\":1,\"1527\":1,\"1528\":1,\"1540\":1}}],[\"synchronized基础\",{\"0\":{\"1359\":1}}],[\"synchronized实现原理\",{\"0\":{\"1358\":1}}],[\"synchronizedmap和concurrenthashmap有什么区别\",{\"0\":{\"77\":1}}],[\"synchronousqueue性能往往优于其他实现\",{\"1\":{\"1386\":1}}],[\"synchronousqueue非常适合传递性场景做交换工作\",{\"1\":{\"1382\":1}}],[\"synchronousqueue\",{\"0\":{\"1382\":1},\"1\":{\"1378\":1}}],[\"syncs所配置的规则来了\",{\"1\":{\"761\":1}}],[\"syncs\",{\"1\":{\"761\":2}}],[\"sync配合判断主备无延迟的方案\",{\"1\":{\"609\":1}}],[\"sync+位点判断的方案\",{\"1\":{\"609\":1}}],[\"sync的设计如下\",{\"1\":{\"609\":1}}],[\"sync方案\",{\"1\":{\"606\":1}}],[\"sync\",{\"1\":{\"587\":3,\"588\":8,\"602\":2,\"609\":2,\"729\":2}}],[\"syntax\",{\"1\":{\"2\":1,\"457\":1}}],[\"soon\",{\"1\":{\"1500\":1}}],[\"so\",{\"1\":{\"1497\":2,\"1499\":1,\"1500\":1}}],[\"socket句柄\",{\"1\":{\"1496\":1}}],[\"socketpool\",{\"1\":{\"1450\":4}}],[\"socket\",{\"1\":{\"1441\":1,\"1450\":21,\"1451\":1,\"1453\":1,\"1461\":1,\"1496\":1}}],[\"socketchannel\",{\"1\":{\"1410\":1,\"1411\":1,\"1451\":15,\"1452\":7}}],[\"socket使用示例\",{\"0\":{\"820\":1}}],[\"soft\",{\"1\":{\"806\":1}}],[\"sourcetype\",{\"1\":{\"1516\":3}}],[\"sourceanystateful\",{\"1\":{\"1499\":1}}],[\"sourceoropflags\",{\"1\":{\"1498\":3,\"1499\":1}}],[\"sourceflags\",{\"1\":{\"1498\":8}}],[\"sourcespliterator\",{\"1\":{\"1498\":2,\"1499\":3,\"1500\":2}}],[\"sourcestage\",{\"1\":{\"1498\":2,\"1499\":10}}],[\"sourcestagespliterator\",{\"1\":{\"1498\":2,\"1499\":2}}],[\"sourcesupplier\",{\"1\":{\"1498\":3,\"1499\":3}}],[\"sources\",{\"1\":{\"1497\":1}}],[\"sourcekey\",{\"1\":{\"714\":2}}],[\"source\",{\"1\":{\"568\":1,\"605\":3,\"708\":2,\"709\":1,\"1494\":2,\"1496\":11,\"1497\":30,\"1498\":19,\"1499\":3,\"1500\":4,\"1516\":2,\"1524\":1,\"1528\":1}}],[\"solvenqueens\",{\"1\":{\"417\":1}}],[\"solutions\",{\"1\":{\"417\":6}}],[\"solution\",{\"1\":{\"360\":1,\"361\":2,\"362\":2,\"363\":1,\"364\":1,\"371\":1,\"375\":1,\"376\":1,\"377\":1,\"381\":2,\"383\":1,\"384\":1,\"385\":2,\"389\":1,\"398\":1,\"401\":1,\"402\":1,\"403\":2,\"404\":1,\"405\":1,\"406\":2,\"407\":1,\"408\":1,\"409\":3,\"410\":2,\"411\":2,\"412\":1,\"429\":1}}],[\"sorting\",{\"1\":{\"568\":1}}],[\"sort采用的就地排序\",{\"1\":{\"387\":1}}],[\"sortedset\",{\"1\":{\"1497\":1}}],[\"sortedsquares\",{\"1\":{\"362\":2}}],[\"sorted\",{\"1\":{\"340\":1,\"1488\":1,\"1489\":2,\"1495\":1,\"1497\":8,\"1499\":1}}],[\"sort3\",{\"1\":{\"319\":1}}],[\"sort2\",{\"1\":{\"319\":1}}],[\"sort\",{\"1\":{\"316\":1,\"317\":1,\"318\":1,\"319\":1,\"362\":1,\"366\":1,\"380\":1,\"387\":3,\"422\":2,\"467\":1,\"491\":4,\"492\":2,\"555\":1,\"557\":1,\"558\":4,\"566\":2,\"568\":1,\"656\":1,\"657\":11,\"1480\":5,\"1481\":3,\"1482\":3,\"1488\":1,\"1491\":13}}],[\"something\",{\"1\":{\"1356\":1}}],[\"some\",{\"1\":{\"2\":1,\"1495\":1,\"1496\":2,\"1497\":2,\"1500\":1}}],[\"spi\",{\"0\":{\"1675\":1,\"1676\":1}}],[\"spi机制\",{\"0\":{\"1673\":1},\"1\":{\"1535\":1}}],[\"spin\",{\"1\":{\"1407\":1,\"1431\":1}}],[\"spinclock\",{\"1\":{\"1360\":1}}],[\"spinfreq\",{\"1\":{\"1360\":1}}],[\"spinlock\",{\"1\":{\"1357\":1}}],[\"specialized\",{\"1\":{\"1497\":2,\"1500\":1}}],[\"specialize\",{\"1\":{\"1497\":2}}],[\"specializations\",{\"1\":{\"1496\":1,\"1497\":3,\"1498\":1}}],[\"specialization\",{\"1\":{\"1475\":1,\"1478\":2,\"1497\":2,\"1500\":1}}],[\"special\",{\"1\":{\"1496\":1,\"1524\":1,\"1527\":1}}],[\"specified\",{\"1\":{\"1472\":5,\"1478\":3,\"1492\":1,\"1495\":3,\"1496\":2,\"1497\":1,\"1524\":1}}],[\"specification\",{\"1\":{\"1471\":2,\"1496\":1}}],[\"specific\",{\"0\":{\"1405\":1},\"1\":{\"1492\":1,\"1498\":4,\"1524\":1}}],[\"splice\",{\"0\":{\"1461\":1},\"1\":{\"1461\":4,\"1462\":2}}],[\"splitr是原生的spliterator分割迭代器的类型\",{\"1\":{\"1497\":1}}],[\"splitr>\",{\"1\":{\"1497\":1}}],[\"splitr>>\",{\"1\":{\"1497\":1}}],[\"splitr\",{\"1\":{\"1497\":2}}],[\"splitting\",{\"1\":{\"1492\":1,\"1497\":8}}],[\"spliterator在流管道开启之后仅仅是完成遍历\",{\"1\":{\"1498\":1}}],[\"spliterator中还有两个接口ofprimitive和ofint\",{\"1\":{\"1497\":1}}],[\"spliterator的api设计为串行和高效的并行方式来进行元素的遍历\",{\"1\":{\"1497\":1}}],[\"spliterator还会报告它的结构\",{\"1\":{\"1497\":1}}],[\"spliterator是一个对于元中的元素进行遍历和分区的对象\",{\"1\":{\"1497\":1}}],[\"spliterator和spliterators的关系就好像collector和collectors的关系一样\",{\"1\":{\"1497\":1}}],[\"spliteratorcharacteristics\",{\"1\":{\"1497\":1}}],[\"spliterator<s>\",{\"1\":{\"1500\":2}}],[\"spliterator<p\",{\"1\":{\"1500\":6}}],[\"spliterator<e\",{\"1\":{\"1499\":4}}],[\"spliterator<e>\",{\"1\":{\"1497\":1,\"1498\":1}}],[\"spliterator<\",{\"1\":{\"1498\":6}}],[\"spliterator<t>\",{\"1\":{\"1496\":1,\"1497\":9,\"1498\":2}}],[\"spliterator被称之为分割迭代器\",{\"1\":{\"1497\":1}}],[\"spliterator源码分析\",{\"0\":{\"1497\":1}}],[\"spliterator\",{\"1\":{\"1486\":2,\"1496\":2,\"1497\":109,\"1498\":12,\"1499\":1,\"1500\":23}}],[\"spliteratorunknownsize\",{\"1\":{\"1486\":1}}],[\"spliterators中静态方法spliterator返回了一个spliterator实现\",{\"1\":{\"1498\":1}}],[\"spliterators就像iterators一样\",{\"1\":{\"1497\":1}}],[\"spliterators通过estimatesize方法来估算剩余元素的个数\",{\"1\":{\"1497\":1}}],[\"spliterators针对于spliterator提供了若干的静态方法\",{\"1\":{\"1497\":1}}],[\"spliterators的特性值要么是immutable或者concurrent\",{\"1\":{\"1497\":1}}],[\"spliterators\",{\"1\":{\"1486\":1,\"1497\":9,\"1498\":1}}],[\"split\",{\"1\":{\"385\":1,\"1427\":1,\"1486\":2,\"1497\":8,\"1498\":1}}],[\"splitarray\",{\"1\":{\"385\":4}}],[\"splitproblem\",{\"1\":{\"288\":1}}],[\"spread\",{\"1\":{\"1431\":1}}],[\"springmvc\",{\"1\":{\"1860\":1}}],[\"spring和spring\",{\"0\":{\"1536\":1}}],[\"springproxytest\",{\"1\":{\"1531\":1}}],[\"spring整合mybatis之后sql执行流程\",{\"1\":{\"1530\":1}}],[\"spring整合其他的框架本质上就是让其他的框架所产生的对象成为spring\",{\"1\":{\"1530\":1}}],[\"spring就会基于beandefinition去创建bean了\",{\"1\":{\"1530\":1}}],[\"spring启动的过程其实就是需要做一些准备工作\",{\"1\":{\"1528\":1}}],[\"spring启动的时候需要去扫描\",{\"1\":{\"1523\":1}}],[\"spring启动过程\",{\"0\":{\"1528\":1}}],[\"spring会优先使用无参的构造方法\",{\"1\":{\"1527\":1}}],[\"spring会在找到注入点之后\",{\"1\":{\"1525\":1}}],[\"spring使用构造方法的原则如下\",{\"1\":{\"1527\":1}}],[\"spring考虑到如果开发者要迁移到其他支持依赖注入的框架\",{\"1\":{\"1525\":1}}],[\"spring自带的依赖注入\",{\"1\":{\"1524\":1}}],[\"spring源码分析\",{\"0\":{\"1506\":1}}],[\"spring应用上下文生命周期有哪些阶段\",{\"0\":{\"1338\":1}}],[\"spring应用上下文关闭阶段\",{\"0\":{\"1336\":1}}],[\"spring应用上下文刷新完成阶段\",{\"0\":{\"1333\":1}}],[\"spring应用上下文刷新\",{\"0\":{\"1330\":1}}],[\"spring应用上下文启动准备阶段\",{\"0\":{\"1323\":1}}],[\"spring条件注解\",{\"0\":{\"1300\":1}}],[\"spring注解属性覆盖\",{\"0\":{\"1298\":1}}],[\"spring注解属性别名\",{\"0\":{\"1297\":1}}],[\"spring注解编程模型\",{\"0\":{\"1293\":1}}],[\"spring模式注解有哪些\",{\"0\":{\"1303\":1}}],[\"spring模式注解\",{\"0\":{\"1295\":1}}],[\"spring模块化设计\",{\"0\":{\"1059\":1}}],[\"spring元注解\",{\"0\":{\"1294\":1}}],[\"spring核心编程思想\",{\"1\":{\"1844\":1}}],[\"spring核心概念\",{\"0\":{\"1508\":1}}],[\"spring核心原理概览\",{\"0\":{\"1507\":1}}],[\"spring核心价值\",{\"0\":{\"1341\":1}}],[\"spring核心注解场景分类\",{\"0\":{\"1292\":1}}],[\"spring核心特性\",{\"0\":{\"1053\":1,\"1340\":1}}],[\"spring同步和异步事件处理的使用场景\",{\"0\":{\"1290\":1}}],[\"spring层次性上下文事件传播\",{\"0\":{\"1277\":1}}],[\"spring事件监听器注册\",{\"0\":{\"1331\":1}}],[\"spring事件核心接口\",{\"0\":{\"1289\":1}}],[\"spring事件\",{\"0\":{\"1286\":1}}],[\"spring事件异常处理\",{\"0\":{\"1285\":1}}],[\"spring事件发布器\",{\"0\":{\"1276\":1}}],[\"spring事务管理器\",{\"1\":{\"1532\":1}}],[\"spring事务源码解析\",{\"0\":{\"1532\":1}}],[\"spring事务底层原理\",{\"1\":{\"1507\":1}}],[\"spring事务传播的原理\",{\"0\":{\"1027\":1}}],[\"spring事务中的应用\",{\"0\":{\"1018\":1}}],[\"spring事务失效的场景有哪些\",{\"0\":{\"187\":1}}],[\"spring标准事件\",{\"0\":{\"1272\":1}}],[\"spring方法参数封装\",{\"0\":{\"1263\":1}}],[\"spring泛型类型辅助类\",{\"0\":{\"1261\":1}}],[\"spring类型转换在\",{\"0\":{\"1313\":1}}],[\"spring类型转换在environment中的运用\",{\"0\":{\"1312\":1}}],[\"spring类型转换器接口有哪些\",{\"0\":{\"1257\":1}}],[\"spring类型转换实现有哪些\",{\"0\":{\"1256\":1}}],[\"spring3\",{\"0\":{\"1247\":1}}],[\"spring内建事件\",{\"0\":{\"1278\":1}}],[\"spring内建类型转换器\",{\"0\":{\"1248\":1}}],[\"spring内建propertyeditor扩展\",{\"0\":{\"1244\":1}}],[\"spring内建的依赖注入\",{\"1\":{\"1524\":1}}],[\"spring内建的配置属性源\",{\"0\":{\"1315\":1}}],[\"spring内建的xml\",{\"0\":{\"1195\":1}}],[\"spring内建的bean的作用域有几种\",{\"0\":{\"1152\":1}}],[\"spring数据绑定api是什么\",{\"0\":{\"1239\":1}}],[\"spring数据存储\",{\"0\":{\"1054\":1}}],[\"spring底层java\",{\"0\":{\"1234\":1}}],[\"spring有哪些校验核心组件\",{\"0\":{\"1229\":1}}],[\"spring有哪些messagesource的内建实现\",{\"0\":{\"1220\":1}}],[\"spring校验接口是哪个\",{\"0\":{\"1228\":1}}],[\"spring国际化接口有哪些\",{\"0\":{\"1219\":1}}],[\"spring国际化接口\",{\"0\":{\"1211\":1}}],[\"spring配置属性源propertysource\",{\"0\":{\"1314\":1}}],[\"spring配置资源中有哪些常见类型\",{\"0\":{\"1208\":1}}],[\"spring配置元信息有哪些\",{\"0\":{\"1196\":1}}],[\"spring通配路径资源扩展\",{\"0\":{\"1204\":1}}],[\"spring通配路径资源加载器\",{\"0\":{\"1203\":1}}],[\"spring资源加载器\",{\"0\":{\"1202\":1}}],[\"spring容器\",{\"1\":{\"1536\":1}}],[\"spring容器生命周期处理\",{\"1\":{\"1528\":1}}],[\"spring容器配置元信息\",{\"0\":{\"1181\":1}}],[\"spring容器管理和游离对象\",{\"0\":{\"1135\":1}}],[\"spring容器是怎样管理注册bean\",{\"0\":{\"1099\":1}}],[\"spring依赖注入的来源有哪些\",{\"0\":{\"1132\":1,\"1143\":1}}],[\"spring依赖注入和依赖查找的来源\",{\"0\":{\"1080\":1}}],[\"spring的依赖查找和依赖注入在来源上有什么区别\",{\"0\":{\"1111\":1}}],[\"spring的核心价值\",{\"0\":{\"1061\":1}}],[\"spring作为ioc容器有什么优势\",{\"0\":{\"1077\":1}}],[\"spring编程模型\",{\"0\":{\"1060\":1}}],[\"spring版本特性\",{\"0\":{\"1058\":1}}],[\"spring测试\",{\"0\":{\"1057\":1}}],[\"spring技术整合\",{\"0\":{\"1056\":1}}],[\"spring特性总览\",{\"0\":{\"1051\":1}}],[\"springcloud\",{\"0\":{\"1049\":1},\"1\":{\"1867\":1}}],[\"springcloud和dubbo的区别\",{\"0\":{\"233\":1}}],[\"springcloud和springcloudalibaba有哪些组件\",{\"0\":{\"232\":1}}],[\"spring本地调度中的应用\",{\"0\":{\"1024\":1}}],[\"springframework\",{\"0\":{\"1050\":1},\"1\":{\"720\":1,\"1509\":5,\"1514\":2,\"1525\":2,\"1529\":2,\"1532\":1,\"1534\":5,\"1535\":2}}],[\"springboot2\",{\"1\":{\"1861\":1}}],[\"springboot与springcloud\",{\"1\":{\"1844\":1}}],[\"springboot程序的jvm参数设置格式\",{\"1\":{\"1541\":1}}],[\"springboot和springcloud注解\",{\"0\":{\"1301\":1}}],[\"springboot事件\",{\"0\":{\"1287\":1}}],[\"springboot为什么要新建messagesource\",{\"0\":{\"1217\":1}}],[\"springbootapplication\",{\"0\":{\"1030\":1}}],[\"springboottest\",{\"1\":{\"720\":1}}],[\"springboot\",{\"0\":{\"1029\":1},\"1\":{\"720\":1}}],[\"springboot整合\",{\"0\":{\"720\":1}}],[\"springboot如何防止表单重复提交\",{\"0\":{\"194\":1}}],[\"springboot自动装配过程及实现原理\",{\"0\":{\"193\":1}}],[\"springboot面试题\",{\"0\":{\"191\":1}}],[\"spring中还提供了ordercomparator的子类\",{\"1\":{\"1518\":1}}],[\"spring中的service有多个实现类\",{\"0\":{\"190\":1}}],[\"spring中bean的作用域\",{\"0\":{\"183\":1}}],[\"spring\",{\"0\":{\"188\":1,\"189\":1,\"220\":1,\"221\":1,\"897\":1,\"902\":1,\"913\":1,\"915\":1,\"916\":1,\"917\":1,\"922\":1,\"940\":1,\"941\":1,\"942\":1,\"991\":1,\"993\":1,\"1017\":1,\"1023\":1,\"1026\":1,\"1028\":1,\"1041\":1,\"1052\":1,\"1055\":1,\"1064\":1,\"1065\":1,\"1078\":1,\"1079\":1,\"1081\":1,\"1083\":1,\"1087\":1,\"1089\":1,\"1136\":1,\"1179\":1,\"1180\":1,\"1185\":1,\"1231\":1,\"1296\":1,\"1299\":1,\"1318\":1,\"1334\":1,\"1335\":1,\"1531\":1,\"1533\":1,\"1534\":1,\"1535\":1,\"1676\":1,\"1861\":1,\"1867\":1},\"1\":{\"720\":2,\"1507\":2,\"1511\":1,\"1524\":6,\"1528\":5,\"1531\":3,\"1533\":1,\"1534\":1,\"1536\":1,\"1843\":1,\"1844\":2,\"1857\":3,\"1860\":5,\"1861\":7,\"1867\":4,\"1868\":1}}],[\"spring如何处理事务\",{\"0\":{\"186\":1}}],[\"spring是如何处理循环依赖问题的\",{\"0\":{\"185\":1}}],[\"spring框架中的bean是线程安全的吗\",{\"0\":{\"184\":1}}],[\"spring框架中bean的创建过程是怎样的\",{\"0\":{\"182\":1}}],[\"spring面试题\",{\"0\":{\"181\":1}}],[\"spa\",{\"1\":{\"1850\":1}}],[\"sparc\",{\"1\":{\"1356\":1}}],[\"space\",{\"1\":{\"385\":1}}],[\"spaces\",{\"1\":{\"385\":7}}],[\"spotify\",{\"0\":{\"1042\":1}}],[\"spop\",{\"1\":{\"709\":3}}],[\"survivorratio\",{\"1\":{\"1541\":1}}],[\"sure\",{\"1\":{\"1524\":2,\"1527\":1}}],[\"sun\",{\"1\":{\"1540\":3}}],[\"sunionstore\",{\"1\":{\"709\":1}}],[\"sunion\",{\"1\":{\"709\":4}}],[\"suffix\",{\"1\":{\"1495\":2}}],[\"suited\",{\"1\":{\"1485\":2}}],[\"such\",{\"1\":{\"1485\":2,\"1492\":4,\"1493\":1,\"1494\":1,\"1496\":8,\"1497\":10,\"1500\":6}}],[\"succeed\",{\"1\":{\"1494\":1}}],[\"successfully\",{\"1\":{\"1499\":1}}],[\"successful\",{\"1\":{\"1497\":1}}],[\"success就是这个函数执行成功的回调函数\",{\"1\":{\"1470\":1}}],[\"success\",{\"1\":{\"1375\":2,\"1470\":2}}],[\"succ\",{\"1\":{\"1360\":1}}],[\"suspension模式在守护条件不满足的时候会一直等待至可以运行\",{\"1\":{\"1408\":1}}],[\"suspension模式不同\",{\"1\":{\"1408\":1}}],[\"suspension模式一样\",{\"1\":{\"1408\":1}}],[\"suspension模式也常被称为guarded\",{\"1\":{\"1407\":1}}],[\"suspension模式允许多个线程对实例资源进行访问\",{\"1\":{\"1407\":1}}],[\"suspension模式\",{\"0\":{\"1407\":1}}],[\"suser\",{\"1\":{\"486\":2,\"487\":4,\"488\":2}}],[\"summed\",{\"1\":{\"1496\":1}}],[\"summingint方法的说明\",{\"1\":{\"1495\":1}}],[\"summingint的实现\",{\"1\":{\"1495\":1}}],[\"summingint\",{\"1\":{\"1492\":1,\"1493\":3,\"1495\":1}}],[\"summingsalariesbydept\",{\"1\":{\"1492\":1}}],[\"summingsalaries\",{\"1\":{\"1492\":2}}],[\"summarizingint\",{\"1\":{\"1493\":1}}],[\"summarizing\",{\"1\":{\"1493\":1}}],[\"summarize\",{\"1\":{\"566\":1}}],[\"summaries\",{\"1\":{\"1492\":1}}],[\"summarystatistics\",{\"1\":{\"1487\":1}}],[\"summary\",{\"1\":{\"616\":4,\"656\":4,\"657\":4,\"1474\":1,\"1475\":3,\"1476\":2,\"1477\":1,\"1478\":1,\"1485\":8,\"1492\":1}}],[\"sumcount\",{\"1\":{\"1431\":2}}],[\"sumscore\",{\"1\":{\"711\":2}}],[\"sumofleftleaves\",{\"1\":{\"410\":2}}],[\"sum\",{\"1\":{\"363\":4,\"429\":2,\"695\":1,\"1484\":1,\"1487\":3,\"1490\":1,\"1492\":4,\"1493\":2,\"1495\":1,\"1496\":2,\"1497\":1}}],[\"suppressed\",{\"1\":{\"1496\":1}}],[\"suppresswarnings\",{\"1\":{\"1379\":1,\"1427\":1,\"1486\":1,\"1495\":3,\"1497\":2,\"1499\":2,\"1500\":2,\"1524\":1}}],[\"supplied\",{\"1\":{\"1477\":1,\"1478\":2,\"1495\":1}}],[\"supplier的元\",{\"1\":{\"1498\":1}}],[\"supplier提供的结果容器就会传递给accumulator\",{\"1\":{\"1492\":1}}],[\"supplier会创建一个新的结果容器\",{\"1\":{\"1485\":1}}],[\"supplier就是我们要返回的结果\",{\"1\":{\"1485\":1}}],[\"supplier2\",{\"1\":{\"1477\":2}}],[\"supplier更多的适用于工厂创建对象\",{\"1\":{\"1477\":1}}],[\"supplier<\",{\"1\":{\"1498\":4,\"1527\":1}}],[\"supplier<partition<a>>\",{\"1\":{\"1495\":1}}],[\"supplier<map<k\",{\"1\":{\"1495\":2}}],[\"supplier<m>\",{\"1\":{\"1495\":1}}],[\"supplier<i>\",{\"1\":{\"1494\":1}}],[\"supplier<set<t>>\",{\"1\":{\"1494\":2,\"1495\":1}}],[\"supplier<student>\",{\"1\":{\"1477\":3}}],[\"supplier<string>\",{\"1\":{\"1477\":1,\"1483\":1}}],[\"supplier<a>\",{\"1\":{\"1492\":1,\"1493\":4,\"1495\":1}}],[\"supplier<c>\",{\"1\":{\"1486\":1,\"1495\":1}}],[\"supplier<list<t>>\",{\"1\":{\"1485\":1,\"1495\":2}}],[\"supplier<r>\",{\"1\":{\"1485\":2}}],[\"supplier<t>\",{\"1\":{\"1477\":1}}],[\"supplierjyc\",{\"1\":{\"1477\":4}}],[\"supplier不接受参数\",{\"1\":{\"1477\":1}}],[\"supplier表示提供结果的供应者\",{\"1\":{\"1477\":1}}],[\"supplier\",{\"1\":{\"1477\":9,\"1483\":2,\"1485\":6,\"1492\":15,\"1493\":8,\"1494\":14,\"1495\":9,\"1497\":1,\"1498\":2}}],[\"supplier函数式接口\",{\"0\":{\"1477\":1}}],[\"supported\",{\"1\":{\"1500\":1,\"1525\":2,\"1532\":1}}],[\"supporting\",{\"1\":{\"1496\":1,\"1497\":1}}],[\"support\",{\"1\":{\"2\":1,\"609\":1,\"616\":1,\"1494\":1,\"1497\":1,\"1509\":3,\"1514\":1,\"1524\":1}}],[\"sup>\",{\"1\":{\"605\":4}}],[\"superficial\",{\"1\":{\"1496\":1}}],[\"super\",{\"1\":{\"311\":3,\"590\":1,\"1383\":2,\"1470\":1,\"1471\":5,\"1472\":1,\"1474\":1,\"1475\":6,\"1476\":4,\"1478\":2,\"1480\":1,\"1484\":1,\"1485\":2,\"1490\":1,\"1491\":3,\"1492\":1,\"1494\":4,\"1495\":18,\"1497\":8,\"1498\":7,\"1499\":8,\"1500\":3,\"1528\":1,\"1534\":3,\"1567\":4}}],[\"subtasks\",{\"1\":{\"1497\":2}}],[\"subtype\",{\"1\":{\"1497\":3}}],[\"subtract\",{\"1\":{\"566\":1,\"1475\":1}}],[\"subclass\",{\"1\":{\"1524\":1}}],[\"subclasses\",{\"1\":{\"1497\":1,\"1524\":2}}],[\"subcommand\",{\"1\":{\"734\":1}}],[\"submit\",{\"1\":{\"1394\":8,\"1412\":2,\"1450\":1}}],[\"sub=f6e1eb8e778044ec9bb87ba05dce5e4b\",{\"1\":{\"1540\":1}}],[\"sub=5a7459fe4b464ec896f9dd9a4eb64942\",{\"1\":{\"677\":1}}],[\"sub=9a8237e2b9b248b9a2f5fc5aed6cbcf1\",{\"1\":{\"668\":1}}],[\"sub\",{\"1\":{\"530\":2,\"690\":1,\"733\":2,\"1497\":4}}],[\"subquery\",{\"1\":{\"467\":1}}],[\"subsequent\",{\"1\":{\"1500\":1}}],[\"subset\",{\"1\":{\"1500\":1}}],[\"subsets\",{\"1\":{\"399\":1}}],[\"subsized\",{\"1\":{\"1497\":10}}],[\"subscribe\",{\"1\":{\"734\":2,\"735\":2}}],[\"substitute\",{\"1\":{\"656\":2}}],[\"substring\",{\"1\":{\"385\":1,\"400\":1,\"428\":1,\"1487\":6}}],[\"subresults\",{\"1\":{\"1492\":1}}],[\"subresult\",{\"1\":{\"1492\":1}}],[\"subresult3\",{\"1\":{\"288\":2}}],[\"subresult2\",{\"1\":{\"288\":2}}],[\"subresult1\",{\"1\":{\"288\":2}}],[\"subproblem\",{\"1\":{\"288\":4}}],[\"separately\",{\"1\":{\"1498\":1}}],[\"separate\",{\"1\":{\"1497\":1}}],[\"separated\",{\"1\":{\"1493\":1}}],[\"self\",{\"1\":{\"1498\":1,\"1525\":1}}],[\"seller\",{\"1\":{\"1492\":1}}],[\"selelct语句直到状态4都不能执行\",{\"1\":{\"609\":1}}],[\"selectedkeys\",{\"1\":{\"1451\":2}}],[\"selectionkeys\",{\"1\":{\"1451\":4}}],[\"selectionkey\",{\"1\":{\"1451\":9}}],[\"selectiontemplate\",{\"1\":{\"318\":1}}],[\"select和poll都需要在返回后\",{\"1\":{\"1447\":1}}],[\"select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制\",{\"1\":{\"1446\":1}}],[\"select的数据列只用从索引中就能够取得\",{\"1\":{\"467\":1}}],[\"select目前几乎在所有的平台上支持\",{\"1\":{\"1446\":1}}],[\"select函数监视的文件描述符分为3类\",{\"1\":{\"1446\":1}}],[\"select就会返回\",{\"1\":{\"1442\":1}}],[\"selector会不断的轮询注册在它上面的channel\",{\"1\":{\"1451\":1}}],[\"selector\",{\"0\":{\"850\":1},\"1\":{\"1451\":28}}],[\"select操作不会更新版本号\",{\"1\":{\"672\":1}}],[\"select后面的是子查询\",{\"1\":{\"645\":1}}],[\"select这种批量插入数据的场景时\",{\"1\":{\"629\":1}}],[\"select这样的批量插入数据的语句\",{\"1\":{\"629\":1}}],[\"select语句在默认设置下\",{\"1\":{\"629\":1}}],[\"select\",{\"0\":{\"98\":1,\"613\":1,\"1446\":1},\"1\":{\"454\":1,\"456\":1,\"457\":1,\"458\":1,\"459\":2,\"466\":3,\"467\":12,\"477\":1,\"478\":1,\"483\":3,\"484\":1,\"485\":2,\"486\":1,\"487\":2,\"488\":2,\"489\":1,\"490\":1,\"491\":5,\"498\":3,\"503\":2,\"504\":2,\"505\":7,\"507\":6,\"508\":2,\"509\":2,\"510\":2,\"511\":2,\"512\":12,\"513\":3,\"515\":15,\"521\":2,\"527\":6,\"531\":4,\"537\":1,\"538\":1,\"539\":1,\"540\":1,\"541\":1,\"544\":3,\"545\":2,\"546\":2,\"548\":2,\"550\":2,\"551\":2,\"553\":3,\"554\":1,\"555\":1,\"556\":1,\"557\":1,\"558\":3,\"559\":8,\"568\":5,\"571\":1,\"610\":1,\"611\":1,\"613\":2,\"614\":1,\"616\":1,\"629\":1,\"646\":6,\"651\":1,\"655\":1,\"656\":9,\"657\":6,\"659\":6,\"661\":1,\"662\":5,\"663\":4,\"674\":1,\"675\":3,\"678\":2,\"681\":2,\"684\":1,\"686\":2,\"690\":4,\"691\":5,\"692\":3,\"694\":2,\"695\":2,\"704\":3,\"706\":1,\"740\":1,\"1375\":1,\"1442\":4,\"1445\":1,\"1446\":1,\"1451\":2,\"1488\":1,\"1490\":1}}],[\"segmentfault\",{\"1\":{\"1852\":1}}],[\"segment对象的put方法源代码如下\",{\"1\":{\"1430\":1}}],[\"segments\",{\"1\":{\"1430\":1,\"1498\":1}}],[\"segmentshift\",{\"1\":{\"1430\":1}}],[\"segment\",{\"1\":{\"1430\":1,\"1498\":3,\"1500\":1}}],[\"segmentmask\",{\"1\":{\"1430\":1}}],[\"segment<k\",{\"1\":{\"1430\":2}}],[\"segment的数组结构为hashentry的数组\",{\"1\":{\"1430\":1}}],[\"segment是concurrenthashmap的内部类\",{\"1\":{\"1430\":1}}],[\"sex\",{\"1\":{\"710\":4}}],[\"sequentially\",{\"1\":{\"1492\":1,\"1496\":1,\"1497\":4}}],[\"sequential\",{\"1\":{\"1486\":1,\"1492\":2,\"1494\":5,\"1496\":5,\"1497\":2,\"1498\":4,\"1500\":1}}],[\"sequence\",{\"1\":{\"588\":1,\"1397\":1,\"1474\":2,\"1496\":1}}],[\"seq\",{\"1\":{\"690\":1}}],[\"semaphore与reentantlock的逻辑实现区别在于semaphore是共享锁\",{\"1\":{\"1373\":1}}],[\"semaphore与countdownlatch\",{\"0\":{\"1373\":1}}],[\"semaphore可以用于做流量控制\",{\"1\":{\"1373\":1}}],[\"semaphore\",{\"1\":{\"1373\":1}}],[\"semi\",{\"1\":{\"609\":3}}],[\"semlinker\",{\"1\":{\"307\":2}}],[\"send\",{\"1\":{\"1500\":2}}],[\"sends\",{\"1\":{\"1500\":3}}],[\"sendfile拷贝流程省掉了2次用户态和内核态的切换\",{\"1\":{\"1459\":1}}],[\"sendfile\",{\"0\":{\"1460\":1},\"1\":{\"1459\":2,\"1460\":3,\"1461\":1,\"1462\":4,\"1463\":1}}],[\"sendfile系统调用方法\",{\"1\":{\"1453\":1}}],[\"sending\",{\"1\":{\"568\":1,\"1500\":2}}],[\"sentinel\",{\"1\":{\"758\":3,\"761\":16}}],[\"sentinel是一个分布式架构\",{\"1\":{\"758\":1}}],[\"sentinel提供高可用\",{\"1\":{\"705\":1}}],[\"sent\",{\"1\":{\"557\":1,\"566\":2,\"1500\":3}}],[\"session作用域\",{\"0\":{\"1148\":1}}],[\"session\",{\"1\":{\"483\":2,\"491\":2,\"547\":1,\"549\":5,\"550\":4,\"561\":6,\"578\":1,\"583\":4,\"584\":9,\"591\":1,\"602\":1,\"605\":2,\"611\":1,\"617\":2,\"618\":4,\"629\":5,\"634\":5,\"656\":2,\"657\":2,\"806\":1,\"1524\":1,\"1856\":1}}],[\"section\",{\"0\":{\"781\":1,\"783\":1},\"1\":{\"806\":1}}],[\"secret\",{\"1\":{\"761\":1}}],[\"second\",{\"1\":{\"635\":1,\"706\":1,\"746\":1,\"1475\":2,\"1496\":1}}],[\"seconds\",{\"1\":{\"594\":1,\"609\":1,\"707\":1,\"1450\":1}}],[\"secondary\",{\"1\":{\"472\":1}}],[\"sec\",{\"1\":{\"466\":1,\"467\":6,\"498\":1,\"508\":2,\"565\":4,\"568\":4,\"571\":1}}],[\"searchmatrix\",{\"1\":{\"443\":1}}],[\"search\",{\"1\":{\"360\":1,\"693\":2}}],[\"series\",{\"1\":{\"1492\":1}}],[\"serial收集器\",{\"0\":{\"1602\":1}}],[\"serial\",{\"0\":{\"1605\":1},\"1\":{\"1497\":1,\"1500\":1}}],[\"serially\",{\"1\":{\"1492\":1}}],[\"serialversionuid\",{\"1\":{\"1491\":2}}],[\"serializable\",{\"1\":{\"570\":1,\"669\":1,\"1491\":3}}],[\"sermonlizhi\",{\"1\":{\"698\":1}}],[\"service组件还包含了若干executor组件\",{\"1\":{\"1564\":1}}],[\"service组件\",{\"0\":{\"1564\":1}}],[\"service>\",{\"1\":{\"1561\":1}}],[\"services目录下放置一个名称为javax\",{\"1\":{\"1535\":1}}],[\"service\",{\"1\":{\"1523\":1,\"1563\":1}}],[\"server检查事务状态\",{\"0\":{\"1823\":1}}],[\"server定时扫描\",{\"0\":{\"1822\":1}}],[\"server组件指的就是整个tomcat服务器\",{\"1\":{\"1563\":1}}],[\"server组件\",{\"0\":{\"1563\":1}}],[\"server>\",{\"1\":{\"1561\":1}}],[\"serversocket\",{\"1\":{\"1450\":8}}],[\"serversocketchannel\",{\"1\":{\"1410\":2,\"1411\":2,\"1451\":6}}],[\"server性能更好\",{\"1\":{\"1442\":1}}],[\"server不一定比使用mutli\",{\"1\":{\"1442\":1}}],[\"serverbootstrap\",{\"0\":{\"861\":1}}],[\"server层\",{\"1\":{\"694\":1}}],[\"server层对于返回的每一行\",{\"1\":{\"536\":1}}],[\"server层拿到id后\",{\"1\":{\"536\":1}}],[\"server层包括连接器\",{\"1\":{\"454\":1}}],[\"server\",{\"1\":{\"455\":1,\"549\":1,\"550\":3,\"566\":3,\"591\":1,\"615\":1,\"618\":1,\"694\":1,\"701\":1,\"1541\":1}}],[\"servletresponse的转化\",{\"1\":{\"1565\":1}}],[\"servletregistration\",{\"1\":{\"1535\":1}}],[\"servletappcontext\",{\"1\":{\"1535\":3}}],[\"servletname\",{\"1\":{\"1535\":4}}],[\"servletcontext\",{\"1\":{\"1535\":4}}],[\"servlet接口名\",{\"1\":{\"1535\":1}}],[\"servlet\",{\"1\":{\"280\":1,\"1534\":4,\"1535\":3,\"1561\":1,\"1856\":1}}],[\"sercuity\",{\"0\":{\"220\":1,\"221\":1}}],[\"setloadonstartup\",{\"1\":{\"1535\":1}}],[\"setpointcut\",{\"1\":{\"1531\":1}}],[\"setprenode\",{\"1\":{\"302\":2}}],[\"setinterfaces\",{\"1\":{\"1531\":1}}],[\"settarget\",{\"1\":{\"1531\":1}}],[\"setter\",{\"1\":{\"1490\":1}}],[\"setter注入\",{\"0\":{\"1114\":1}}],[\"setcallbackfilter\",{\"1\":{\"1531\":1}}],[\"setcallbacks\",{\"1\":{\"1531\":1}}],[\"setcurrentinjectionpoint\",{\"1\":{\"1525\":2}}],[\"setcustomeditors\",{\"1\":{\"1515\":1}}],[\"setcontextinitializers\",{\"1\":{\"1535\":1}}],[\"setcontainingclass\",{\"1\":{\"1525\":1}}],[\"setconverters\",{\"1\":{\"1516\":1}}],[\"setconnectionfactory\",{\"1\":{\"720\":1}}],[\"setasyncsupported\",{\"1\":{\"1535\":1}}],[\"setastext\",{\"1\":{\"1515\":1}}],[\"setadvice\",{\"1\":{\"1531\":1}}],[\"setage\",{\"1\":{\"1403\":1,\"1477\":1,\"1490\":1}}],[\"setbeanclass\",{\"1\":{\"1509\":1,\"1524\":1}}],[\"setbit\",{\"1\":{\"715\":6}}],[\"set2\",{\"1\":{\"1494\":4}}],[\"set1\",{\"1\":{\"1494\":6}}],[\"setsuperclass\",{\"1\":{\"1531\":1}}],[\"setserializationid\",{\"1\":{\"1528\":1}}],[\"setsource\",{\"1\":{\"1524\":1}}],[\"setscope\",{\"1\":{\"1524\":3}}],[\"setscore\",{\"1\":{\"1480\":1,\"1482\":1,\"1490\":2}}],[\"setstate\",{\"1\":{\"1367\":1}}],[\"setdefaultcloseoperation\",{\"1\":{\"1468\":2}}],[\"setvisible\",{\"1\":{\"1468\":2}}],[\"setvalue\",{\"1\":{\"1423\":1,\"1515\":1}}],[\"setvalueserializer\",{\"1\":{\"720\":1}}],[\"setentryat\",{\"1\":{\"1430\":1}}],[\"setex\",{\"1\":{\"707\":3}}],[\"setname\",{\"1\":{\"1477\":1,\"1480\":1,\"1482\":1,\"1490\":2,\"1515\":1,\"1516\":1}}],[\"setnext\",{\"1\":{\"1430\":1}}],[\"setnx\",{\"1\":{\"707\":3}}],[\"setfoo\",{\"1\":{\"1403\":1}}],[\"sethashvalueserializer\",{\"1\":{\"720\":1}}],[\"sethashkeyserializer\",{\"1\":{\"720\":1}}],[\"setkeyserializer\",{\"1\":{\"720\":1}}],[\"set排序\",{\"1\":{\"711\":1}}],[\"set就是一种简化的hash\",{\"1\":{\"710\":1}}],[\"setz的并集\",{\"1\":{\"709\":1}}],[\"setz\",{\"1\":{\"709\":4}}],[\"setz=>\",{\"1\":{\"709\":1}}],[\"sety的交集\",{\"1\":{\"709\":1}}],[\"sety\",{\"1\":{\"709\":13}}],[\"sety=>\",{\"1\":{\"709\":1}}],[\"setx的交集\",{\"1\":{\"709\":1}}],[\"setx\",{\"1\":{\"709\":12}}],[\"setx=>\",{\"1\":{\"709\":1}}],[\"set值为k6\",{\"1\":{\"708\":1}}],[\"setrange\",{\"1\":{\"707\":2}}],[\"setup\",{\"1\":{\"616\":1,\"656\":2}}],[\"set里面\",{\"1\":{\"605\":1}}],[\"set<beandefinition>\",{\"1\":{\"1524\":3}}],[\"set<beandefinitionholder>\",{\"1\":{\"1524\":2}}],[\"set<map\",{\"1\":{\"1495\":1}}],[\"set<convertiblepair>\",{\"1\":{\"1516\":1}}],[\"set<collector\",{\"1\":{\"1495\":4}}],[\"set<characteristics>\",{\"1\":{\"1493\":4,\"1494\":3}}],[\"set<t>>\",{\"1\":{\"1494\":2,\"1495\":1}}],[\"set<t>\",{\"1\":{\"1494\":2}}],[\"set<string>>\",{\"1\":{\"1495\":2}}],[\"set<string>\",{\"1\":{\"1493\":1,\"1494\":2,\"1524\":1,\"1525\":3}}],[\"set<selectionkey>\",{\"1\":{\"1451\":2}}],[\"set<integer>\",{\"1\":{\"381\":1,\"417\":6,\"441\":1}}],[\"set<listnode>\",{\"1\":{\"373\":1}}],[\"set\",{\"0\":{\"32\":1,\"709\":1,\"1352\":1,\"1433\":1},\"1\":{\"356\":1,\"381\":5,\"441\":8,\"460\":1,\"466\":1,\"467\":6,\"483\":1,\"491\":1,\"492\":1,\"498\":1,\"505\":1,\"508\":2,\"537\":2,\"541\":4,\"542\":1,\"551\":2,\"553\":1,\"556\":2,\"557\":1,\"558\":4,\"559\":6,\"565\":5,\"568\":4,\"572\":1,\"584\":11,\"599\":1,\"604\":1,\"605\":2,\"609\":2,\"611\":4,\"613\":3,\"615\":1,\"616\":1,\"655\":2,\"656\":2,\"657\":3,\"660\":4,\"663\":2,\"665\":1,\"669\":1,\"672\":1,\"673\":1,\"681\":1,\"704\":1,\"706\":5,\"707\":3,\"709\":1,\"716\":5,\"717\":4,\"718\":2,\"719\":2,\"720\":1,\"748\":3,\"767\":1,\"1375\":1,\"1405\":1,\"1415\":2,\"1416\":1,\"1446\":3,\"1480\":1,\"1486\":2,\"1492\":2,\"1493\":1,\"1494\":26,\"1495\":2,\"1497\":7,\"1498\":2,\"1500\":3,\"1524\":2,\"1532\":2}}],[\"seed\",{\"1\":{\"1486\":9}}],[\"seesion\",{\"1\":{\"483\":1}}],[\"seesion还能进行身份验证吗\",{\"0\":{\"224\":1}}],[\"see\",{\"1\":{\"1\":1,\"1475\":5,\"1478\":2,\"1497\":2,\"1498\":1,\"1500\":2}}],[\"studyplan\",{\"1\":{\"1850\":1}}],[\"studentlist\",{\"1\":{\"1492\":2}}],[\"studentcomparator\",{\"1\":{\"1481\":10}}],[\"student类中的静态方法comparestudentbyscore恰好是接收两个参数\",{\"1\":{\"1480\":1}}],[\"studentparam2\",{\"1\":{\"1480\":4,\"1481\":2}}],[\"studentparam1\",{\"1\":{\"1480\":4,\"1481\":2}}],[\"students\",{\"1\":{\"1480\":8,\"1481\":7,\"1482\":3,\"1488\":3,\"1490\":6,\"1492\":3,\"1493\":14}}],[\"student4\",{\"1\":{\"1480\":4,\"1481\":3,\"1482\":2,\"1490\":2,\"1492\":2}}],[\"student3\",{\"1\":{\"1480\":4,\"1481\":3,\"1482\":2,\"1490\":2,\"1492\":2}}],[\"student2\",{\"1\":{\"1480\":8,\"1481\":7,\"1482\":6,\"1490\":2,\"1492\":2}}],[\"student1\",{\"1\":{\"1480\":8,\"1481\":7,\"1482\":6,\"1490\":2,\"1492\":2}}],[\"studenttest\",{\"1\":{\"1477\":2}}],[\"student\",{\"1\":{\"1477\":8,\"1480\":30,\"1481\":26,\"1482\":23,\"1488\":15,\"1490\":25,\"1492\":8,\"1493\":18}}],[\"studentx的age字段数值+1\",{\"1\":{\"710\":1}}],[\"studentx\",{\"1\":{\"710\":19}}],[\"stl源码剖析\",{\"1\":{\"1844\":1}}],[\"still\",{\"1\":{\"1497\":1,\"1524\":1,\"1540\":1}}],[\"storm\",{\"1\":{\"1396\":1}}],[\"stored\",{\"1\":{\"1524\":1}}],[\"store\",{\"1\":{\"619\":2,\"1350\":1}}],[\"storage模式\",{\"0\":{\"1405\":1}}],[\"storage\",{\"1\":{\"558\":1}}],[\"stopping\",{\"1\":{\"1500\":1}}],[\"stop方法\",{\"1\":{\"1354\":1}}],[\"stop\",{\"1\":{\"591\":1,\"604\":1,\"622\":1,\"711\":1}}],[\"stmts\",{\"1\":{\"566\":1}}],[\"stmt\",{\"1\":{\"559\":3}}],[\"steps\",{\"1\":{\"656\":12,\"657\":4}}],[\"step`\",{\"1\":{\"505\":1}}],[\"step\",{\"1\":{\"385\":3,\"1524\":1}}],[\"struts2\",{\"1\":{\"1857\":2}}],[\"structurally\",{\"1\":{\"1497\":2}}],[\"structural\",{\"1\":{\"1497\":6}}],[\"structures\",{\"1\":{\"1498\":1}}],[\"structure\",{\"1\":{\"302\":1,\"392\":1,\"1497\":2}}],[\"struct\",{\"1\":{\"1446\":1,\"1447\":2}}],[\"strval\",{\"1\":{\"1525\":2}}],[\"strongly\",{\"1\":{\"1498\":1}}],[\"stream调用流程\",{\"0\":{\"1501\":1}}],[\"stream应该用于减少潜在的干扰\",{\"1\":{\"1498\":1}}],[\"stream方法的参数也是定义在collection集合中的默认方法\",{\"1\":{\"1497\":1}}],[\"stream方法会调用的将集合作为流的元\",{\"1\":{\"1497\":1}}],[\"stream会被组合成一个stream\",{\"1\":{\"1496\":1}}],[\"stream本身又继承了basestream类\",{\"1\":{\"1496\":1}}],[\"stream本身是一个对象引用流\",{\"1\":{\"1496\":1}}],[\"stream本身其实也提供了针对与特定数据类型的具化的stream对象\",{\"1\":{\"1484\":1}}],[\"stream源码分析\",{\"0\":{\"1496\":1}}],[\"streamopflag\",{\"1\":{\"1494\":1,\"1498\":5,\"1499\":4,\"1500\":3}}],[\"streamops\",{\"1\":{\"1485\":1}}],[\"stream的源码复杂而多变\",{\"1\":{\"1490\":1}}],[\"stream也对分组提供了强有力的支持\",{\"1\":{\"1490\":1}}],[\"stream也可以分为并行流和串行流\",{\"1\":{\"1484\":1}}],[\"stream和sql非常的类似\",{\"1\":{\"1488\":1}}],[\"stream和sql语句其实非常的相似\",{\"1\":{\"1488\":1}}],[\"stream只能使用一次\",{\"1\":{\"1487\":1}}],[\"stream实际上和文件系统中的io流有很多类似的性质\",{\"1\":{\"1487\":1}}],[\"stream实例剖析\",{\"0\":{\"1486\":1}}],[\"stream陷阱剖析\",{\"0\":{\"1487\":1}}],[\"stream<r>\",{\"1\":{\"1499\":1}}],[\"stream<e>\",{\"1\":{\"1497\":2,\"1498\":1}}],[\"stream<integer>\",{\"1\":{\"1487\":6}}],[\"stream<list<integer>>\",{\"1\":{\"1486\":1}}],[\"stream<string>\",{\"1\":{\"1485\":3,\"1486\":3,\"1496\":3}}],[\"stream<t>>\",{\"1\":{\"1496\":1}}],[\"stream<t>\",{\"1\":{\"1484\":2,\"1486\":1,\"1496\":1,\"1498\":1}}],[\"stream类源码解析\",{\"0\":{\"1485\":1}}],[\"streams$1\",{\"1\":{\"1496\":3}}],[\"streamshape\",{\"1\":{\"1494\":1,\"1499\":2,\"1500\":2}}],[\"streams\",{\"1\":{\"1484\":2,\"1486\":2,\"1496\":12,\"1497\":2,\"1498\":5}}],[\"streamsupport中的stream方法\",{\"1\":{\"1498\":1}}],[\"streamsupport\",{\"1\":{\"1484\":2,\"1486\":1,\"1497\":2,\"1498\":1}}],[\"stream3\",{\"1\":{\"1484\":1,\"1487\":2}}],[\"stream1\",{\"1\":{\"1484\":2}}],[\"streamtest9\",{\"1\":{\"1489\":1}}],[\"streamtest8\",{\"1\":{\"1487\":1}}],[\"streamtest7\",{\"1\":{\"1487\":2}}],[\"streamtest6\",{\"1\":{\"1486\":2,\"1487\":5}}],[\"streamtest1\",{\"1\":{\"1492\":1}}],[\"streamtest13\",{\"1\":{\"1490\":1}}],[\"streamtest10\",{\"1\":{\"1489\":2}}],[\"streamtest12\",{\"1\":{\"1486\":1}}],[\"streamtest11\",{\"1\":{\"1486\":2}}],[\"streamtest5\",{\"1\":{\"1486\":3}}],[\"streamtest4\",{\"1\":{\"1485\":3,\"1486\":3}}],[\"streamtest3\",{\"1\":{\"1484\":1,\"1497\":1}}],[\"streamtest2\",{\"1\":{\"1484\":3,\"1496\":13}}],[\"streamtest\",{\"1\":{\"1484\":3}}],[\"stream\",{\"1\":{\"1470\":1,\"1475\":2,\"1484\":16,\"1485\":16,\"1486\":27,\"1487\":24,\"1488\":1,\"1489\":3,\"1490\":9,\"1492\":4,\"1493\":19,\"1494\":6,\"1495\":5,\"1496\":49,\"1497\":15,\"1498\":18,\"1499\":11,\"1500\":21}}],[\"stream2\",{\"1\":{\"1469\":2,\"1484\":1,\"1487\":3,\"1496\":6}}],[\"str2\",{\"1\":{\"1364\":3}}],[\"str1\",{\"1\":{\"1364\":3}}],[\"strict\",{\"1\":{\"1497\":1}}],[\"striped64\",{\"1\":{\"1357\":1}}],[\"stringutils\",{\"1\":{\"1524\":3}}],[\"stringtouserconverter\",{\"1\":{\"1516\":2}}],[\"stringtouserpropertyeditor\",{\"1\":{\"1515\":2,\"1517\":1}}],[\"stringjoiner是jdk1\",{\"1\":{\"1495\":1}}],[\"stringjoiner\",{\"1\":{\"1495\":4}}],[\"stringarray\",{\"1\":{\"1485\":2}}],[\"string序列化方式\",{\"1\":{\"720\":1}}],[\"stringredistemplate\",{\"1\":{\"720\":1}}],[\"string类似的使用场景\",{\"1\":{\"707\":1}}],[\"string类为什么是不可变的\",{\"0\":{\"18\":1}}],[\"stringstream\",{\"1\":{\"1485\":4}}],[\"strings\",{\"1\":{\"566\":1,\"1470\":1,\"1485\":3,\"1492\":1,\"1493\":1,\"1500\":4}}],[\"string>\",{\"1\":{\"400\":2,\"1428\":2,\"1483\":1,\"1494\":6,\"1495\":3}}],[\"string中hashcode的实现\",{\"0\":{\"23\":1}}],[\"stringbuilder\",{\"0\":{\"17\":1},\"1\":{\"385\":2,\"400\":2,\"409\":4,\"1485\":6,\"1492\":1,\"1495\":4}}],[\"stringbuffer的append是个同步方法\",{\"1\":{\"1364\":1}}],[\"stringbuffer内部同步\",{\"1\":{\"1362\":1}}],[\"stringbuffer\",{\"0\":{\"17\":1},\"1\":{\"1363\":2,\"1364\":4}}],[\"string\",{\"0\":{\"17\":1,\"707\":1},\"1\":{\"302\":6,\"329\":4,\"380\":3,\"384\":3,\"385\":8,\"386\":2,\"387\":4,\"388\":1,\"389\":1,\"400\":3,\"409\":4,\"415\":1,\"417\":1,\"427\":2,\"428\":2,\"489\":1,\"566\":1,\"706\":1,\"714\":1,\"715\":1,\"719\":4,\"720\":2,\"806\":4,\"1356\":1,\"1359\":1,\"1362\":1,\"1364\":3,\"1398\":1,\"1403\":1,\"1412\":3,\"1423\":1,\"1428\":1,\"1450\":4,\"1451\":6,\"1452\":7,\"1464\":1,\"1465\":1,\"1468\":3,\"1469\":1,\"1470\":10,\"1471\":2,\"1472\":10,\"1474\":3,\"1475\":7,\"1476\":4,\"1477\":7,\"1478\":4,\"1479\":1,\"1480\":5,\"1481\":2,\"1482\":7,\"1483\":7,\"1484\":12,\"1485\":10,\"1486\":17,\"1487\":10,\"1489\":4,\"1490\":10,\"1491\":16,\"1492\":1,\"1493\":1,\"1494\":2,\"1496\":2,\"1497\":2,\"1500\":1,\"1515\":1,\"1516\":3,\"1523\":2,\"1524\":22,\"1525\":17,\"1527\":1,\"1531\":2,\"1532\":1,\"1535\":1,\"1540\":2}}],[\"strlen\",{\"1\":{\"707\":2}}],[\"straight\",{\"1\":{\"538\":1,\"539\":1,\"540\":1}}],[\"str\",{\"1\":{\"388\":8,\"400\":6,\"1483\":2,\"1486\":1}}],[\"strs\",{\"1\":{\"380\":4}}],[\"stale\",{\"1\":{\"1524\":1}}],[\"stages\",{\"1\":{\"1498\":1,\"1500\":5}}],[\"stage\",{\"1\":{\"1494\":1,\"1498\":6,\"1499\":4,\"1500\":12}}],[\"stampedlock\",{\"1\":{\"1375\":1}}],[\"stamp\",{\"1\":{\"1356\":15,\"1431\":2}}],[\"stampholder\",{\"1\":{\"1356\":8}}],[\"stamp为1\",{\"1\":{\"1356\":1}}],[\"star是所有io的总次数\",{\"1\":{\"616\":1}}],[\"startswith\",{\"1\":{\"1500\":1}}],[\"starts\",{\"1\":{\"1500\":1}}],[\"starttime\",{\"1\":{\"1489\":2}}],[\"startinclusive\",{\"1\":{\"1484\":6}}],[\"starting\",{\"1\":{\"568\":1}}],[\"start方法\",{\"1\":{\"1354\":1}}],[\"start和end只能按字节\",{\"1\":{\"715\":1}}],[\"startupshutdownmonitor\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"startupstep\",{\"1\":{\"1524\":5,\"1528\":3}}],[\"startup\",{\"1\":{\"566\":1}}],[\"start+1\",{\"1\":{\"432\":2}}],[\"start++\",{\"1\":{\"384\":1}}],[\"start\",{\"1\":{\"384\":4,\"432\":3,\"591\":2,\"604\":2,\"605\":2,\"622\":1,\"679\":1,\"707\":1,\"708\":2,\"711\":3,\"715\":2,\"1356\":2,\"1364\":2,\"1398\":1,\"1410\":1,\"1428\":2,\"1450\":1,\"1468\":2,\"1469\":2,\"1524\":5,\"1528\":3}}],[\"starter\",{\"0\":{\"195\":1},\"1\":{\"720\":1}}],[\"started\",{\"0\":{\"0\":1},\"1\":{\"571\":1,\"725\":1}}],[\"standardreflectionparameternamediscoverer\",{\"1\":{\"1525\":1}}],[\"standardopenoption\",{\"1\":{\"1464\":3,\"1465\":3}}],[\"standard\",{\"1\":{\"566\":1,\"1524\":1}}],[\"staffs\",{\"1\":{\"507\":4,\"509\":2}}],[\"states\",{\"1\":{\"1500\":1}}],[\"statefulop\",{\"1\":{\"1501\":1}}],[\"stateful\",{\"1\":{\"1498\":4,\"1500\":1}}],[\"statelessop继承了referencepipeline\",{\"1\":{\"1500\":1}}],[\"statelessop\",{\"1\":{\"1499\":1,\"1501\":1}}],[\"statelessop<e\",{\"1\":{\"1499\":1}}],[\"statelessop<p\",{\"1\":{\"1499\":1}}],[\"stateless\",{\"1\":{\"1485\":2,\"1496\":1,\"1499\":1,\"1500\":1}}],[\"statelessness\",{\"1\":{\"1485\":2}}],[\"state属性三种访问方式\",{\"1\":{\"1367\":1}}],[\"state表示资源的可用状态\",{\"1\":{\"1367\":1}}],[\"state\",{\"1\":{\"1367\":1,\"1485\":2,\"1492\":1,\"1494\":5,\"1496\":1,\"1499\":1,\"1500\":7,\"1524\":2,\"1525\":1,\"1532\":1}}],[\"statement\",{\"1\":{\"806\":1,\"1496\":1}}],[\"statu和idx\",{\"1\":{\"695\":1}}],[\"status这两个列组合起来不重复的值有多少\",{\"1\":{\"695\":1}}],[\"status来说\",{\"1\":{\"695\":1}}],[\"status来优化查询\",{\"1\":{\"663\":1}}],[\"status`\",{\"1\":{\"690\":1}}],[\"status展示出的rows的值\",{\"1\":{\"690\":1}}],[\"status得到当前主库执行到的file和position\",{\"1\":{\"610\":1}}],[\"status的结果\",{\"1\":{\"605\":1}}],[\"status的部分结果如下\",{\"1\":{\"561\":1}}],[\"status命令\",{\"1\":{\"533\":1,\"594\":1,\"604\":1}}],[\"status\",{\"1\":{\"467\":1,\"491\":2,\"565\":2,\"568\":1,\"611\":1,\"640\":1,\"675\":2,\"681\":1,\"684\":2,\"685\":1,\"690\":4,\"692\":2,\"695\":2,\"1524\":1,\"1532\":6}}],[\"stat\",{\"1\":{\"695\":4}}],[\"statistics\",{\"1\":{\"568\":1}}],[\"static<t\",{\"1\":{\"1495\":1}}],[\"static<t>\",{\"1\":{\"1484\":1,\"1486\":1}}],[\"statictextsqlnode\",{\"1\":{\"806\":1}}],[\"static\",{\"1\":{\"317\":3,\"318\":3,\"319\":5,\"329\":4,\"441\":1,\"719\":2,\"1352\":3,\"1356\":1,\"1357\":1,\"1359\":8,\"1364\":1,\"1380\":1,\"1383\":1,\"1398\":1,\"1405\":3,\"1412\":2,\"1423\":1,\"1425\":2,\"1428\":2,\"1431\":1,\"1434\":1,\"1464\":1,\"1465\":1,\"1468\":3,\"1469\":1,\"1470\":6,\"1471\":2,\"1472\":6,\"1474\":2,\"1475\":8,\"1476\":7,\"1477\":3,\"1478\":3,\"1479\":1,\"1480\":4,\"1481\":2,\"1482\":5,\"1483\":2,\"1484\":13,\"1485\":4,\"1486\":13,\"1487\":8,\"1489\":3,\"1490\":3,\"1491\":5,\"1492\":2,\"1493\":1,\"1494\":3,\"1495\":18,\"1496\":2,\"1497\":13,\"1498\":4,\"1499\":1,\"1500\":2,\"1523\":1,\"1525\":2,\"1529\":1,\"1531\":3}}],[\"stats命令查看latest\",{\"1\":{\"725\":1}}],[\"stats表就相当于一个普通的表一样\",{\"1\":{\"696\":1}}],[\"stats表\",{\"1\":{\"696\":2}}],[\"stats表里的统计数据也在变化\",{\"1\":{\"696\":1}}],[\"stats表的每条记录代表着一个索引的一个统计项\",{\"1\":{\"695\":1}}],[\"stats表的数据\",{\"1\":{\"695\":1}}],[\"stats和innodb\",{\"1\":{\"696\":3}}],[\"stats存储了关于索引的统计就数据\",{\"1\":{\"695\":1}}],[\"stats存储了关于表的统计数据\",{\"1\":{\"695\":1}}],[\"stats\",{\"1\":{\"484\":1,\"695\":15,\"696\":5,\"1540\":1}}],[\"stack<>\",{\"1\":{\"395\":1}}],[\"stack<treenode>\",{\"1\":{\"296\":2,\"395\":1,\"410\":2}}],[\"stack\",{\"1\":{\"296\":6,\"333\":1,\"386\":13,\"392\":5,\"395\":4,\"397\":4,\"410\":6,\"1864\":1}}],[\"styles\",{\"1\":{\"4\":1,\"1524\":1}}],[\"style\",{\"1\":{\"4\":1}}],[\"similarly\",{\"1\":{\"1500\":1}}],[\"similar\",{\"1\":{\"1497\":1}}],[\"similarities\",{\"1\":{\"1496\":1}}],[\"simply\",{\"1\":{\"1527\":1,\"1567\":1}}],[\"simplify\",{\"1\":{\"1419\":1,\"1497\":2}}],[\"simpleurlhandlermapping\",{\"1\":{\"1534\":1}}],[\"simpleinstantiationstrategy\",{\"1\":{\"1528\":1}}],[\"simpleimmutableentry<>\",{\"1\":{\"1495\":2}}],[\"simplemetadatareader去解析类时\",{\"1\":{\"1523\":1}}],[\"simplemetadatareaderfactory\",{\"1\":{\"1523\":4}}],[\"simpletypeconverter\",{\"1\":{\"1517\":2}}],[\"simplealiasregistry\",{\"1\":{\"1513\":1}}],[\"simpledateformat\",{\"1\":{\"1405\":1}}],[\"simple\",{\"0\":{\"539\":1},\"1\":{\"466\":1,\"467\":6,\"498\":1,\"527\":2,\"539\":1,\"540\":1,\"656\":1,\"807\":1,\"1497\":1}}],[\"siftupcomparable\",{\"1\":{\"1383\":1}}],[\"sinks\",{\"1\":{\"1500\":1}}],[\"sink中的方法说明\",{\"1\":{\"1500\":1}}],[\"sink会将值映射成整型值向下游发送\",{\"1\":{\"1500\":1}}],[\"sink对于accept有一个入口点\",{\"1\":{\"1500\":1}}],[\"sink实例是用来表示管道的每一个阶段\",{\"1\":{\"1500\":1}}],[\"sink本身可以通过cancellationrequested方法来发出不要再接收数据的信号\",{\"1\":{\"1500\":1}}],[\"sink是consumer接口的一个扩展\",{\"1\":{\"1500\":1}}],[\"sink源码分析\",{\"0\":{\"1500\":1}}],[\"sink<\",{\"1\":{\"1500\":2}}],[\"sink<t>\",{\"1\":{\"1500\":2}}],[\"sink<r>\",{\"1\":{\"1499\":1}}],[\"sink<p\",{\"1\":{\"1499\":1,\"1500\":7}}],[\"sink<e\",{\"1\":{\"1498\":2,\"1500\":4}}],[\"sink\",{\"1\":{\"1498\":1,\"1499\":3,\"1500\":48}}],[\"since\",{\"1\":{\"1471\":5,\"1472\":1,\"1474\":2,\"1475\":2,\"1476\":2,\"1477\":1,\"1478\":1,\"1496\":1,\"1497\":3,\"1524\":2,\"1528\":1}}],[\"singalall\",{\"1\":{\"1407\":1}}],[\"singal\",{\"1\":{\"1407\":2}}],[\"singletoncurrentlyincreation\",{\"1\":{\"1526\":1}}],[\"singletonfactories的主要逻辑\",{\"1\":{\"1526\":1}}],[\"singletonfactories\",{\"1\":{\"1526\":1}}],[\"singletonobjects\",{\"1\":{\"1526\":1}}],[\"singletoninstance\",{\"1\":{\"1524\":3}}],[\"singletons\",{\"1\":{\"1524\":4,\"1528\":1}}],[\"singletonbeanregistry\",{\"1\":{\"1513\":1}}],[\"singleton\",{\"0\":{\"1153\":1},\"1\":{\"1516\":2,\"1524\":11,\"1528\":1}}],[\"singleton作用域\",{\"0\":{\"1145\":1}}],[\"single\",{\"1\":{\"437\":3,\"575\":2,\"1398\":1,\"1474\":2,\"1485\":1,\"1492\":1,\"1497\":3,\"1498\":1}}],[\"singlenumber\",{\"1\":{\"381\":2,\"437\":1}}],[\"sinterstore\",{\"1\":{\"709\":1}}],[\"sinter\",{\"1\":{\"709\":4}}],[\"sismember\",{\"1\":{\"709\":5}}],[\"si​==si+1​\",{\"1\":{\"428\":1}}],[\"si​==sj​\",{\"1\":{\"428\":1}}],[\"signature\",{\"1\":{\"1524\":1}}],[\"signatures\",{\"1\":{\"1485\":2}}],[\"signalnotfull\",{\"1\":{\"1380\":2}}],[\"signalnotempty\",{\"1\":{\"1380\":2}}],[\"signal方法的时候必须持有锁\",{\"1\":{\"1370\":1}}],[\"signal方法会将condition队列的首节点移动到阻塞队列尾部\",{\"1\":{\"1370\":1}}],[\"signal\",{\"1\":{\"1367\":1,\"1379\":2,\"1380\":4,\"1500\":1}}],[\"signifies\",{\"1\":{\"1427\":1}}],[\"signed\",{\"1\":{\"504\":1}}],[\"sign\",{\"1\":{\"388\":4,\"715\":9}}],[\"sized特性值\",{\"1\":{\"1497\":1}}],[\"sized\",{\"1\":{\"1497\":16}}],[\"sizectl\",{\"1\":{\"1431\":9}}],[\"size这个字段的含义就是hashmap中实际存在的键值对数量\",{\"1\":{\"1423\":1}}],[\"size这个配置限制了内存临时表的大小\",{\"1\":{\"558\":1}}],[\"size和key个数相关\",{\"1\":{\"704\":1}}],[\"size列就表明了采样的页面数量是多少\",{\"1\":{\"695\":1}}],[\"sizes的值是81\",{\"1\":{\"695\":1}}],[\"size的值是97\",{\"1\":{\"695\":1}}],[\"size来设定的\",{\"1\":{\"662\":1}}],[\"size来动态设置\",{\"1\":{\"480\":1}}],[\"size一半的时候\",{\"1\":{\"588\":1}}],[\"size用于控制单个线程内binlog\",{\"1\":{\"587\":1}}],[\"size定义的32768字节\",{\"1\":{\"558\":1}}],[\"size=0\",{\"1\":{\"663\":1}}],[\"size=32768\",{\"1\":{\"558\":1}}],[\"size=1024\",{\"1\":{\"558\":1}}],[\"size设置成32768\",{\"1\":{\"558\":1}}],[\"size设置成1024\",{\"1\":{\"558\":1}}],[\"size设定的\",{\"1\":{\"540\":1}}],[\"size就是控制这个内存大小的\",{\"1\":{\"553\":1}}],[\"size就是mysql为排序开辟的内存\",{\"1\":{\"491\":1}}],[\"size默认值是256k\",{\"1\":{\"544\":1}}],[\"size不够大的时候\",{\"1\":{\"540\":1}}],[\"size足够大的时候\",{\"1\":{\"540\":1}}],[\"size改大\",{\"1\":{\"540\":1}}],[\"size改小\",{\"1\":{\"540\":1}}],[\"size越大的时候\",{\"1\":{\"540\":1}}],[\"size越小\",{\"1\":{\"491\":1}}],[\"size超过了需要排序的数据量的大小\",{\"1\":{\"491\":1}}],[\"size\",{\"1\":{\"302\":2,\"311\":1,\"395\":1,\"396\":4,\"399\":1,\"401\":3,\"402\":3,\"403\":5,\"404\":4,\"409\":2,\"411\":3,\"426\":1,\"441\":2,\"491\":2,\"553\":1,\"558\":1,\"640\":1,\"657\":2,\"695\":2,\"746\":1,\"1357\":2,\"1423\":1,\"1431\":4,\"1465\":1,\"1470\":1,\"1488\":1,\"1489\":1,\"1494\":1,\"1495\":2,\"1497\":6,\"1498\":1,\"1499\":1,\"1500\":5,\"1525\":2}}],[\"sidebar\",{\"1\":{\"4\":1}}],[\"side\",{\"1\":{\"3\":1,\"1474\":2,\"1496\":1,\"1500\":1}}],[\"site\",{\"1\":{\"1\":1,\"3\":2}}],[\"sfc\",{\"1\":{\"2\":1}}],[\"t0\",{\"1\":{\"1540\":2}}],[\"tm\",{\"1\":{\"1532\":4}}],[\"tmeplate中的datasource是同一个\",{\"1\":{\"1532\":1}}],[\"tmpdir命令\",{\"1\":{\"549\":1}}],[\"tmp\",{\"1\":{\"395\":3,\"491\":4,\"492\":1,\"553\":1,\"558\":5,\"568\":4,\"646\":1,\"656\":1,\"657\":2,\"761\":1}}],[\"tf\",{\"1\":{\"1524\":4}}],[\"t表示由当前的spliterator所返回的元素的类型\",{\"1\":{\"1497\":1}}],[\"t表示流中元素的类型\",{\"1\":{\"1495\":2}}],[\"t表并插入数据的过程中\",{\"1\":{\"544\":1}}],[\"t类型表示流中元素的类型\",{\"1\":{\"1495\":1}}],[\"t类型表示进行汇聚操作的输入元素的类型\",{\"1\":{\"1492\":1}}],[\"t实际上表示的就是流中的每个元素的类型\",{\"1\":{\"1490\":1}}],[\"two\",{\"1\":{\"1475\":2,\"1476\":4,\"1478\":7,\"1485\":2,\"1491\":1,\"1492\":4,\"1496\":1,\"1497\":3,\"1500\":1}}],[\"twosum\",{\"1\":{\"359\":1}}],[\"tlab\",{\"1\":{\"1545\":1}}],[\"tl\",{\"1\":{\"1405\":4}}],[\"tl=threadlocal\",{\"1\":{\"1405\":1}}],[\"t>>\",{\"1\":{\"1494\":2,\"1495\":3}}],[\"t>由于没有明确的上下文\",{\"1\":{\"1491\":1}}],[\"t>\",{\"1\":{\"1383\":2,\"1470\":1,\"1471\":5,\"1472\":1,\"1474\":1,\"1475\":4,\"1476\":4,\"1478\":4,\"1485\":2,\"1486\":1,\"1491\":2,\"1492\":1,\"1493\":4,\"1494\":6,\"1495\":11,\"1497\":5,\"1498\":1,\"1499\":2,\"1500\":1}}],[\"t3操作\",{\"1\":{\"1375\":1}}],[\"t3这一项去掉\",{\"1\":{\"598\":1}}],[\"ttl\",{\"1\":{\"706\":4}}],[\"txinfo\",{\"1\":{\"1532\":7}}],[\"txsupport\",{\"1\":{\"1532\":2}}],[\"txattr\",{\"1\":{\"1532\":12}}],[\"txt\",{\"1\":{\"1464\":2,\"1465\":2}}],[\"tx\",{\"1\":{\"669\":2}}],[\"typically\",{\"1\":{\"1497\":1}}],[\"typical\",{\"1\":{\"1497\":1}}],[\"typora\",{\"1\":{\"609\":1,\"616\":1}}],[\"typecheckonly\",{\"1\":{\"1524\":3}}],[\"typeconverter本身使用了委托的设计模式\",{\"1\":{\"1517\":1}}],[\"typeconverter整合了propertyeditor和conversionservice的功能\",{\"1\":{\"1517\":1}}],[\"typeconverter\",{\"0\":{\"1517\":1},\"1\":{\"1517\":3,\"1525\":12}}],[\"typefilter\",{\"1\":{\"1524\":2}}],[\"typedescriptor\",{\"1\":{\"1516\":4}}],[\"typedescriptor是如何处理泛型\",{\"0\":{\"1258\":1}}],[\"type类型的派生类或接口\",{\"0\":{\"1267\":1}}],[\"typealiasregistry\",{\"1\":{\"806\":1}}],[\"type=0\",{\"1\":{\"663\":1}}],[\"type=note\",{\"1\":{\"446\":1,\"449\":1,\"654\":2,\"796\":1,\"800\":1}}],[\"type列\",{\"0\":{\"646\":1}}],[\"type来控制并行复制策略\",{\"1\":{\"602\":1}}],[\"type\",{\"1\":{\"466\":3,\"467\":15,\"498\":2,\"527\":4,\"656\":1,\"690\":2,\"692\":2,\"694\":1,\"706\":2,\"714\":1,\"715\":1,\"1471\":17,\"1474\":1,\"1475\":15,\"1476\":4,\"1477\":1,\"1478\":9,\"1485\":1,\"1490\":2,\"1492\":5,\"1495\":6,\"1497\":9,\"1498\":2,\"1500\":7,\"1522\":4,\"1524\":4,\"1525\":11,\"1532\":1}}],[\"type设置成demand\",{\"1\":{\"456\":1}}],[\"t6时刻\",{\"1\":{\"584\":1}}],[\"t4时刻显示的trx\",{\"1\":{\"634\":1}}],[\"t4时刻\",{\"1\":{\"584\":1,\"634\":1}}],[\"tbl\",{\"1\":{\"578\":2,\"622\":1}}],[\"t不存在\",{\"1\":{\"550\":1}}],[\"t这两个语句的binlog日志\",{\"1\":{\"550\":1}}],[\"t做join操作\",{\"1\":{\"544\":1}}],[\"t的字段b加上索引\",{\"1\":{\"544\":1}}],[\"t中\",{\"1\":{\"544\":1}}],[\"t命令\",{\"1\":{\"484\":1}}],[\"tutorial\",{\"1\":{\"1504\":1,\"1847\":1,\"1853\":1}}],[\"turned\",{\"1\":{\"1524\":1}}],[\"turn\",{\"1\":{\"1497\":1,\"1500\":1}}],[\"tuser\",{\"1\":{\"477\":1}}],[\"tuv\",{\"1\":{\"400\":1}}],[\"tianjin\",{\"1\":{\"1482\":1}}],[\"tid\",{\"1\":{\"1360\":1}}],[\"timout\",{\"1\":{\"708\":1}}],[\"times\",{\"1\":{\"1485\":2}}],[\"timestamp是utc时间戳\",{\"1\":{\"666\":1}}],[\"timestamp作为默认\",{\"1\":{\"666\":1}}],[\"timestamp命令\",{\"1\":{\"591\":1}}],[\"timestamp命令约定了接下来now\",{\"1\":{\"591\":1}}],[\"timestamp=1546103491\",{\"1\":{\"591\":1}}],[\"timestamp=1541402277\",{\"1\":{\"557\":1}}],[\"timestamp\",{\"1\":{\"591\":2,\"594\":1,\"615\":2,\"647\":2,\"655\":2,\"666\":1}}],[\"timeval\",{\"1\":{\"1446\":1}}],[\"timeunit\",{\"1\":{\"1353\":1,\"1378\":2,\"1450\":1,\"1489\":1}}],[\"time选项\",{\"1\":{\"725\":1}}],[\"time这三个列组合起来不重复的值有多少\",{\"1\":{\"695\":1}}],[\"time这单单一列不重复的值有多少\",{\"1\":{\"695\":1}}],[\"time这几个方案里选出一个成本最低的方案\",{\"1\":{\"692\":1}}],[\"time这两个方案中选出成本最低的那个\",{\"1\":{\"692\":2}}],[\"time这两个索引\",{\"1\":{\"686\":1}}],[\"time可以使用range方式的访问\",{\"1\":{\"692\":1}}],[\"time访问s2的成本\",{\"1\":{\"692\":2}}],[\"time访问s1的成本\",{\"1\":{\"692\":1}}],[\"time两种\",{\"1\":{\"692\":1}}],[\"time索引占了6条记录\",{\"1\":{\"695\":1}}],[\"time索引\",{\"1\":{\"691\":1,\"692\":2}}],[\"time索引执行查询后\",{\"1\":{\"691\":1}}],[\"time索引执行查询\",{\"1\":{\"691\":1}}],[\"time成本将会是\",{\"1\":{\"688\":1}}],[\"time来执行查询\",{\"1\":{\"688\":1}}],[\"time时有3个单点区间\",{\"1\":{\"686\":1}}],[\"time执行查询的成本更低些\",{\"1\":{\"692\":2}}],[\"time执行查询的成本如下所示\",{\"1\":{\"686\":1}}],[\"time执行查询的总成本就是\",{\"1\":{\"686\":1}}],[\"time二级索引执行查询时\",{\"1\":{\"686\":1}}],[\"time在区间expire\",{\"1\":{\"686\":1}}],[\"time对应的位置分别是1\",{\"1\":{\"690\":1}}],[\"time对应的b+树索引中找出最后一条满足这个条件的记录\",{\"1\":{\"686\":1}}],[\"time对应的b+树索引\",{\"1\":{\"686\":1}}],[\"time对应的搜索条件是\",{\"1\":{\"686\":1}}],[\"time搜索会使用二级索引+回表方式的查询\",{\"1\":{\"686\":1}}],[\"time<=\",{\"1\":{\"684\":1,\"686\":1,\"691\":3,\"692\":2}}],[\"time>\",{\"1\":{\"684\":2,\"686\":1,\"691\":3,\"692\":2}}],[\"time作为这个sql查询过程中索引\",{\"1\":{\"681\":1}}],[\"timewait函数\",{\"1\":{\"618\":1}}],[\"timer\",{\"1\":{\"616\":1}}],[\"timer的值来判断数据库是否出问题了\",{\"1\":{\"616\":1}}],[\"timed=\",{\"1\":{\"616\":1}}],[\"timediff\",{\"1\":{\"571\":1}}],[\"timeout指定等待时间\",{\"1\":{\"1446\":1}}],[\"timeout可选\",{\"1\":{\"610\":1}}],[\"timeout\",{\"1\":{\"610\":1,\"708\":1,\"740\":1,\"761\":3,\"1378\":2,\"1446\":1,\"1447\":1}}],[\"timeout的默认值是50s\",{\"1\":{\"581\":1}}],[\"timeout来设置\",{\"1\":{\"581\":1}}],[\"timeout控制的\",{\"1\":{\"455\":1}}],[\"time的范围区间是确定的\",{\"1\":{\"692\":1}}],[\"time的范围区间只有一个\",{\"1\":{\"686\":1}}],[\"time的tracer的输出\",{\"1\":{\"688\":1}}],[\"time的情况类似\",{\"1\":{\"686\":1}}],[\"time的成本更小\",{\"1\":{\"692\":1}}],[\"time的成本最低\",{\"1\":{\"688\":1}}],[\"time的成本\",{\"1\":{\"686\":1,\"688\":1}}],[\"time的成本为47\",{\"1\":{\"681\":1}}],[\"time的时间\",{\"1\":{\"565\":2}}],[\"time的值为10秒\",{\"1\":{\"565\":1}}],[\"time的默认值为10\",{\"1\":{\"565\":1}}],[\"time控制的\",{\"1\":{\"565\":1}}],[\"time值的sql\",{\"1\":{\"565\":1}}],[\"time`\",{\"1\":{\"512\":1,\"643\":2,\"647\":1,\"655\":1,\"656\":2,\"690\":4,\"692\":4}}],[\"time\",{\"1\":{\"508\":2,\"557\":2,\"565\":4,\"566\":6,\"571\":1,\"647\":3,\"655\":3,\"666\":2,\"675\":5,\"681\":4,\"684\":7,\"686\":8,\"690\":10,\"692\":20,\"695\":4,\"1378\":2,\"1477\":2,\"1485\":2,\"1497\":3,\"1499\":1,\"1500\":1,\"1524\":1}}],[\"time=1685977459844\",{\"1\":{\"800\":1}}],[\"time=1685805324275\",{\"1\":{\"796\":1}}],[\"time=1684856471454\",{\"1\":{\"449\":1}}],[\"time=1684249060388\",{\"1\":{\"446\":1}}],[\"time=1678024153495\",{\"1\":{\"654\":1}}],[\"time=1\",{\"1\":{\"565\":1}}],[\"time=0\",{\"1\":{\"483\":1}}],[\"tinytext\",{\"1\":{\"667\":1}}],[\"tinyblob\",{\"1\":{\"667\":1}}],[\"tinyint\",{\"1\":{\"467\":1,\"475\":1,\"665\":1}}],[\"title\",{\"1\":{\"521\":1}}],[\"t2表\",{\"1\":{\"598\":1}}],[\"t2时刻这个数字是每次查询的时候由系统临时计算出来的\",{\"1\":{\"634\":1}}],[\"t2时刻显示的trx\",{\"1\":{\"634\":1}}],[\"t2时刻\",{\"1\":{\"584\":1}}],[\"t2是被驱动表\",{\"1\":{\"538\":1}}],[\"t2\",{\"1\":{\"458\":2,\"537\":3,\"538\":1,\"539\":2,\"540\":1,\"541\":2,\"544\":7,\"545\":1,\"546\":1,\"629\":1,\"660\":5,\"661\":2,\"662\":2,\"1375\":1,\"1469\":2,\"1492\":3}}],[\"t1表\",{\"1\":{\"598\":1}}],[\"t1的值是非常小的\",{\"1\":{\"594\":1}}],[\"t1语句都会被传到备库s上\",{\"1\":{\"550\":1}}],[\"t1是驱动表\",{\"1\":{\"538\":1}}],[\"t1\",{\"1\":{\"458\":2,\"537\":2,\"538\":3,\"539\":2,\"540\":2,\"541\":4,\"544\":4,\"545\":1,\"546\":3,\"551\":4,\"553\":3,\"554\":2,\"555\":1,\"594\":2,\"599\":2,\"660\":5,\"661\":2,\"662\":2,\"1375\":1,\"1469\":2,\"1492\":3,\"1540\":3}}],[\"tendency\",{\"1\":{\"1500\":1}}],[\"terminalsink是sink最终的形态\",{\"1\":{\"1500\":1}}],[\"terminalsink\",{\"1\":{\"1500\":2}}],[\"terminalop<e\",{\"1\":{\"1500\":2}}],[\"terminalop<t\",{\"1\":{\"1494\":1,\"1500\":1}}],[\"terminalop\",{\"1\":{\"1500\":15,\"1501\":1}}],[\"terminal\",{\"1\":{\"1485\":1,\"1496\":3,\"1497\":1,\"1498\":4,\"1499\":1,\"1500\":4}}],[\"tell\",{\"1\":{\"1524\":1}}],[\"tel字段\",{\"1\":{\"710\":1}}],[\"tel字段的value\",{\"1\":{\"710\":1}}],[\"tel为15623667886\",{\"1\":{\"710\":1}}],[\"tel\",{\"1\":{\"710\":5}}],[\"tehello\",{\"1\":{\"707\":1}}],[\"tests\",{\"1\":{\"1476\":4}}],[\"testset\",{\"1\":{\"711\":11}}],[\"testset=>\",{\"1\":{\"711\":2}}],[\"testtx\",{\"1\":{\"719\":1}}],[\"testping\",{\"1\":{\"719\":1}}],[\"test2\",{\"1\":{\"651\":2}}],[\"test1\",{\"1\":{\"651\":2}}],[\"test\",{\"1\":{\"591\":2,\"674\":1,\"707\":2,\"708\":1,\"720\":1,\"1412\":1,\"1468\":1,\"1471\":7,\"1472\":8,\"1476\":22,\"1483\":1,\"1486\":1,\"1495\":1,\"1497\":5,\"1515\":1,\"1523\":1,\"1531\":5}}],[\"test03\",{\"1\":{\"515\":1}}],[\"textsqlnode\",{\"1\":{\"806\":5}}],[\"text系列存储非二进制字符串\",{\"1\":{\"667\":1}}],[\"text\",{\"1\":{\"427\":4,\"566\":1,\"667\":1,\"806\":1,\"1515\":2}}],[\"text2\",{\"1\":{\"427\":3}}],[\"text1\",{\"1\":{\"427\":3}}],[\"text1​\",{\"1\":{\"427\":1}}],[\"templateinterpreter\",{\"1\":{\"1350\":1}}],[\"template\",{\"1\":{\"720\":8}}],[\"temptable\",{\"1\":{\"694\":4}}],[\"tempary\",{\"1\":{\"549\":1,\"550\":2}}],[\"temporary\",{\"1\":{\"467\":1,\"544\":1,\"546\":1,\"547\":1,\"549\":1,\"550\":2,\"551\":1,\"553\":1,\"557\":1,\"1524\":1}}],[\"temp\",{\"1\":{\"317\":2,\"318\":2,\"319\":2,\"383\":2,\"384\":2,\"399\":6,\"405\":2,\"544\":3,\"546\":5,\"548\":1,\"549\":1,\"550\":5}}],[\"tchars\",{\"1\":{\"387\":3}}],[\"tcp粘包与拆包\",{\"0\":{\"891\":1}}],[\"tcp为什么是三次握手\",{\"0\":{\"95\":1}}],[\"tcp和udp有什么区别\",{\"0\":{\"94\":1}}],[\"t++\",{\"1\":{\"364\":1}}],[\"t\",{\"1\":{\"364\":4,\"385\":2,\"387\":4,\"454\":1,\"456\":1,\"457\":2,\"459\":2,\"460\":2,\"472\":3,\"473\":3,\"475\":1,\"479\":1,\"482\":3,\"483\":3,\"484\":1,\"485\":1,\"489\":2,\"490\":1,\"491\":1,\"493\":2,\"503\":10,\"532\":1,\"544\":4,\"546\":5,\"548\":6,\"549\":1,\"550\":12,\"558\":1,\"559\":8,\"561\":4,\"563\":1,\"566\":10,\"570\":2,\"583\":1,\"584\":13,\"585\":1,\"591\":8,\"596\":4,\"605\":2,\"613\":4,\"615\":3,\"628\":4,\"631\":4,\"748\":2,\"1383\":2,\"1471\":25,\"1472\":6,\"1474\":7,\"1475\":23,\"1476\":20,\"1477\":1,\"1478\":8,\"1480\":2,\"1484\":2,\"1485\":4,\"1486\":10,\"1490\":3,\"1491\":2,\"1492\":4,\"1494\":4,\"1495\":29,\"1497\":15,\"1524\":3,\"1525\":1,\"1527\":1,\"1567\":1}}],[\"tas\",{\"1\":{\"1532\":3}}],[\"tasks\",{\"1\":{\"1493\":1,\"1497\":1}}],[\"taskname\",{\"1\":{\"1412\":4}}],[\"task\",{\"1\":{\"1412\":5,\"1477\":1,\"1497\":1}}],[\"taskqueue\",{\"1\":{\"1412\":3}}],[\"tabulate\",{\"1\":{\"1492\":1}}],[\"tabat\",{\"1\":{\"1431\":2}}],[\"tab\",{\"1\":{\"1426\":8,\"1430\":5,\"1431\":24}}],[\"table本质上就是一个node数组\",{\"1\":{\"1431\":1}}],[\"table位空则创建\",{\"1\":{\"1426\":1}}],[\"table的初始长度length默认值是16\",{\"1\":{\"1423\":1}}],[\"table和drop\",{\"1\":{\"622\":1}}],[\"table和insert语句的binlog同步过去执行的话\",{\"1\":{\"605\":1}}],[\"table或者drop\",{\"1\":{\"621\":1}}],[\"table或者truncate\",{\"1\":{\"620\":1}}],[\"table语句会立即重新计算统计数据\",{\"1\":{\"696\":1}}],[\"table语句来重新计算统计数据\",{\"1\":{\"696\":1}}],[\"table语句误删数据表\",{\"1\":{\"620\":1}}],[\"table语句里面设定等待时间\",{\"1\":{\"578\":1}}],[\"table语句中使用engine=memory来指定存储引擎的类型来创建表\",{\"1\":{\"454\":1}}],[\"tables语法除了会限制别的线程的读写外\",{\"1\":{\"577\":1}}],[\"tables主动释放锁\",{\"1\":{\"577\":1}}],[\"tables\",{\"1\":{\"568\":2,\"574\":1,\"577\":1,\"619\":1,\"656\":2,\"671\":2,\"694\":1,\"695\":1}}],[\"tables命令不显示临时表\",{\"1\":{\"547\":1}}],[\"table命令\",{\"1\":{\"621\":1}}],[\"table命令记录binlog的时候\",{\"1\":{\"550\":1}}],[\"table命令的时候\",{\"1\":{\"550\":1}}],[\"table是可以一次删除多个表的\",{\"1\":{\"550\":1}}],[\"table传给备库执行\",{\"1\":{\"550\":1}}],[\"table建表的时候\",{\"1\":{\"454\":1}}],[\"table\",{\"1\":{\"310\":1,\"332\":1,\"459\":1,\"460\":1,\"466\":1,\"467\":6,\"472\":1,\"473\":1,\"475\":1,\"483\":1,\"484\":1,\"486\":1,\"487\":2,\"489\":1,\"490\":1,\"493\":2,\"498\":3,\"499\":4,\"500\":2,\"503\":1,\"505\":2,\"515\":1,\"527\":4,\"533\":2,\"537\":2,\"541\":2,\"544\":1,\"546\":3,\"547\":1,\"549\":3,\"550\":8,\"551\":1,\"553\":2,\"554\":1,\"556\":1,\"558\":4,\"561\":2,\"563\":1,\"568\":4,\"570\":1,\"578\":2,\"583\":1,\"591\":4,\"596\":1,\"598\":4,\"599\":1,\"605\":1,\"613\":1,\"615\":1,\"616\":1,\"622\":1,\"626\":1,\"627\":1,\"631\":3,\"643\":6,\"647\":1,\"655\":1,\"656\":11,\"657\":2,\"660\":2,\"663\":1,\"671\":2,\"672\":1,\"685\":1,\"690\":4,\"692\":4,\"695\":8,\"696\":8,\"1357\":3,\"1375\":2,\"1423\":1,\"1425\":3,\"1426\":1,\"1427\":4,\"1430\":1,\"1431\":7,\"1492\":1}}],[\"takes\",{\"1\":{\"1500\":3}}],[\"takelock\",{\"1\":{\"1380\":10}}],[\"take锁会阻塞在notempty条件上\",{\"1\":{\"1380\":1}}],[\"take锁\",{\"1\":{\"1380\":1}}],[\"takeindex\",{\"1\":{\"1379\":5}}],[\"take\",{\"1\":{\"1378\":3,\"1379\":1,\"1380\":1,\"1394\":2,\"1412\":1,\"1485\":1,\"1492\":1}}],[\"tag中的数据不需要\",{\"1\":{\"1497\":1}}],[\"taggedarrayspliterator\",{\"1\":{\"1497\":1}}],[\"taggedarrayspliterator<t>\",{\"1\":{\"1497\":1}}],[\"taggedarrayspliterator<>\",{\"1\":{\"1497\":2}}],[\"taggedarray\",{\"1\":{\"1497\":1}}],[\"taggedarray<t>\",{\"1\":{\"1497\":2}}],[\"tags的使用\",{\"0\":{\"1731\":1}}],[\"tags\",{\"1\":{\"1497\":4}}],[\"tag\",{\"1\":{\"531\":12,\"1497\":1,\"1524\":5}}],[\"tangs\",{\"1\":{\"467\":2}}],[\"tar\",{\"1\":{\"364\":2}}],[\"target2\",{\"1\":{\"1531\":2}}],[\"target是被代理的对象爱过你\",{\"1\":{\"1531\":1}}],[\"targetclass\",{\"1\":{\"1525\":7,\"1531\":4,\"1532\":4}}],[\"targettype\",{\"1\":{\"1516\":3,\"1524\":3}}],[\"targetbatchsize\",{\"1\":{\"1497\":8}}],[\"targetref\",{\"1\":{\"1471\":3,\"1476\":8}}],[\"targetsource接口\",{\"0\":{\"964\":1}}],[\"targetsum\",{\"1\":{\"412\":4}}],[\"target\",{\"1\":{\"305\":3,\"359\":3,\"360\":4,\"363\":2,\"366\":2,\"443\":4,\"1471\":1,\"1524\":1,\"1531\":7}}],[\"trysplit\",{\"1\":{\"1497\":12}}],[\"tryadvance\",{\"1\":{\"1497\":21}}],[\"trylock\",{\"1\":{\"1430\":1}}],[\"try\",{\"1\":{\"719\":1,\"1379\":2,\"1380\":4,\"1394\":1,\"1405\":1,\"1410\":2,\"1411\":2,\"1412\":2,\"1430\":1,\"1431\":1,\"1450\":4,\"1451\":6,\"1452\":9,\"1464\":1,\"1465\":1,\"1496\":7,\"1524\":16,\"1525\":4,\"1528\":2,\"1532\":3,\"1540\":1}}],[\"truncate\",{\"1\":{\"616\":1}}],[\"trueentry\",{\"1\":{\"1495\":2}}],[\"true=\",{\"1\":{\"1490\":1}}],[\"true\",{\"1\":{\"302\":3,\"311\":1,\"373\":2,\"387\":1,\"397\":2,\"398\":1,\"406\":2,\"421\":1,\"428\":4,\"440\":1,\"443\":1,\"575\":1,\"656\":6,\"806\":2,\"1353\":1,\"1357\":1,\"1394\":1,\"1408\":1,\"1410\":1,\"1411\":1,\"1426\":1,\"1431\":1,\"1450\":4,\"1451\":2,\"1468\":2,\"1476\":4,\"1484\":1,\"1486\":1,\"1494\":2,\"1495\":1,\"1497\":4,\"1498\":1,\"1499\":3,\"1500\":1,\"1524\":1,\"1525\":3,\"1527\":1,\"1529\":1}}],[\"trx还是在innodb\",{\"1\":{\"634\":1}}],[\"trx表里查看到\",{\"1\":{\"675\":1}}],[\"trx表里查出来的两个字段\",{\"1\":{\"634\":1}}],[\"trx表中看到事务的trx\",{\"1\":{\"634\":1}}],[\"trx表中\",{\"1\":{\"578\":1}}],[\"trx5和trx6是在执行的\",{\"1\":{\"601\":1}}],[\"trx4\",{\"1\":{\"601\":1}}],[\"trx3在主库执行完成\",{\"1\":{\"609\":1}}],[\"trx3\",{\"1\":{\"588\":1}}],[\"trx2和trx3\",{\"1\":{\"609\":1}}],[\"trx2和trx3提交的时候\",{\"1\":{\"601\":1}}],[\"trx2\",{\"1\":{\"588\":1}}],[\"trx1事务更新完成后\",{\"1\":{\"610\":1,\"611\":2}}],[\"trx1和trx2已经传到从库\",{\"1\":{\"609\":1}}],[\"trx1和trx3执行完成后\",{\"1\":{\"601\":1}}],[\"trx1去写盘的时候\",{\"1\":{\"588\":1}}],[\"trx1是第一个到达得\",{\"1\":{\"588\":1}}],[\"trx1\",{\"1\":{\"588\":1}}],[\"trx\",{\"0\":{\"634\":1},\"1\":{\"571\":2,\"588\":6,\"634\":9,\"636\":1,\"675\":3,\"679\":1}}],[\"trx这个表中\",{\"1\":{\"571\":1}}],[\"traversed\",{\"1\":{\"1497\":4,\"1498\":1}}],[\"traverse\",{\"1\":{\"1497\":3}}],[\"traversetree\",{\"1\":{\"302\":1}}],[\"traversing\",{\"1\":{\"1497\":2}}],[\"traversals\",{\"1\":{\"1496\":1,\"1500\":1}}],[\"traversal\",{\"1\":{\"1496\":1,\"1497\":18,\"1500\":3}}],[\"transitions\",{\"1\":{\"1500\":2}}],[\"transient表示该属性不会被序列化\",{\"1\":{\"1419\":1}}],[\"transient\",{\"1\":{\"1352\":1,\"1357\":2,\"1380\":2,\"1419\":1,\"1423\":1}}],[\"transformedbeanname\",{\"1\":{\"1524\":2,\"1525\":1}}],[\"transformed\",{\"1\":{\"1497\":1}}],[\"transform这个特性\",{\"1\":{\"1492\":1}}],[\"transform\",{\"1\":{\"1492\":4,\"1496\":2}}],[\"transforming\",{\"1\":{\"1492\":1}}],[\"transformation\",{\"1\":{\"656\":3,\"1492\":1,\"1495\":2}}],[\"transferto并不保证一定能使用零拷贝\",{\"1\":{\"1465\":1}}],[\"transferto\",{\"1\":{\"1465\":1}}],[\"transferto方法\",{\"1\":{\"1465\":1}}],[\"transferindex\",{\"1\":{\"1431\":1}}],[\"transfer\",{\"1\":{\"1427\":1,\"1431\":2}}],[\"transactioncallback\",{\"1\":{\"1532\":1}}],[\"transactionsystemexception\",{\"1\":{\"1532\":1}}],[\"transactionstatus\",{\"1\":{\"1532\":1}}],[\"transactionsupportcache\",{\"1\":{\"1532\":1}}],[\"transactioninfo\",{\"1\":{\"1532\":2}}],[\"transactioninterceptor就是代理逻辑\",{\"1\":{\"1532\":1}}],[\"transactioninterceptor\",{\"1\":{\"1532\":2}}],[\"transactionmanager\",{\"1\":{\"1532\":1}}],[\"transactionattribute\",{\"1\":{\"1532\":1}}],[\"transactionattributesource\",{\"1\":{\"1532\":1}}],[\"transactional\",{\"1\":{\"1532\":1}}],[\"transactional注解时\",{\"1\":{\"1532\":1}}],[\"transactional注解的属性值\",{\"1\":{\"1532\":1}}],[\"transactional注解的\",{\"1\":{\"1532\":1}}],[\"transactional注解并不会注入一个新的beanpostprocessor\",{\"1\":{\"1526\":1}}],[\"transactional注解并不会影响循环依赖\",{\"1\":{\"1526\":1}}],[\"transactional注解\",{\"1\":{\"1507\":1,\"1532\":1}}],[\"transactionaspectsupport\",{\"1\":{\"1532\":19}}],[\"transaction只适用于所有的表使用事务引擎的数据库\",{\"1\":{\"575\":1}}],[\"transaction的时候\",{\"1\":{\"575\":1}}],[\"transaction\",{\"1\":{\"570\":1,\"572\":1,\"602\":1,\"605\":5,\"679\":1,\"717\":1,\"719\":1,\"1492\":1,\"1532\":3}}],[\"track\",{\"1\":{\"611\":2}}],[\"tracking\",{\"1\":{\"602\":1}}],[\"trace排序部分结果\",{\"1\":{\"657\":2}}],[\"trace结果中\",{\"1\":{\"558\":1}}],[\"trace的功能\",{\"1\":{\"681\":1}}],[\"trace的结果如下\",{\"1\":{\"492\":1}}],[\"trace的结果来确认的\",{\"1\":{\"491\":1}}],[\"trace的时候\",{\"1\":{\"491\":1}}],[\"trace`\",{\"1\":{\"491\":1,\"558\":1}}],[\"trace=\",{\"1\":{\"491\":1,\"558\":1,\"656\":2,\"657\":2}}],[\"trace\",{\"1\":{\"491\":2,\"558\":2,\"656\":2,\"657\":2,\"681\":2,\"1524\":3}}],[\"traideid\",{\"1\":{\"505\":3}}],[\"trailing\",{\"1\":{\"385\":1}}],[\"tradid\",{\"1\":{\"504\":1}}],[\"tradeied\",{\"1\":{\"505\":2}}],[\"tradeid转成utf8\",{\"1\":{\"505\":1}}],[\"tradeid=l\",{\"1\":{\"505\":2}}],[\"tradeid\",{\"1\":{\"503\":1,\"504\":1,\"505\":10}}],[\"trade\",{\"1\":{\"505\":17}}],[\"tradelog\",{\"1\":{\"503\":3,\"504\":2,\"505\":10}}],[\"treat\",{\"1\":{\"1471\":3}}],[\"treap\",{\"1\":{\"353\":1}}],[\"treebin<k\",{\"1\":{\"1431\":1}}],[\"treebin\",{\"1\":{\"1431\":1}}],[\"treemap实现sortedmap接口\",{\"1\":{\"1421\":1}}],[\"treemap\",{\"1\":{\"1417\":1,\"1421\":1,\"1495\":1}}],[\"treeset<widget>>\",{\"1\":{\"1492\":1}}],[\"treeset<string>\",{\"1\":{\"1486\":1}}],[\"treeset\",{\"1\":{\"1416\":1,\"1486\":1,\"1492\":3,\"1493\":2}}],[\"treeifybin\",{\"1\":{\"1426\":1,\"1431\":1}}],[\"treeify\",{\"1\":{\"1352\":2,\"1426\":1,\"1431\":1}}],[\"tree\",{\"0\":{\"639\":1},\"1\":{\"340\":2,\"638\":1,\"1497\":3}}],[\"treenode<k\",{\"1\":{\"1426\":1,\"1427\":1}}],[\"treenodequeue\",{\"1\":{\"396\":7}}],[\"treenode\",{\"1\":{\"296\":4,\"338\":4,\"395\":7,\"396\":3,\"397\":3,\"398\":6,\"401\":4,\"402\":4,\"403\":6,\"404\":4,\"405\":3,\"406\":6,\"407\":1,\"408\":2,\"409\":6,\"410\":6,\"411\":6,\"412\":1,\"1426\":1,\"1427\":1}}],[\"triggered\",{\"1\":{\"1524\":1}}],[\"triggering\",{\"1\":{\"1500\":1}}],[\"trip\",{\"1\":{\"1497\":2,\"1500\":1}}],[\"tripwire被设置成true的话\",{\"1\":{\"1497\":1}}],[\"tripwire\",{\"1\":{\"1497\":5,\"1500\":2}}],[\"triple协议\",{\"0\":{\"799\":1}}],[\"triple协议是基于http2\",{\"1\":{\"798\":1}}],[\"trivial\",{\"1\":{\"656\":1}}],[\"triangle\",{\"1\":{\"426\":6}}],[\"trim\",{\"1\":{\"302\":1,\"385\":4}}],[\"trienode\",{\"1\":{\"302\":25}}],[\"trietree\",{\"1\":{\"302\":1}}],[\"ts\",{\"1\":{\"3\":2}}],[\"thymeleaf\",{\"1\":{\"1856\":1}}],[\"those\",{\"1\":{\"1496\":1,\"1497\":1,\"1500\":2}}],[\"that\",{\"1\":{\"566\":1,\"1471\":6,\"1474\":4,\"1475\":19,\"1476\":20,\"1477\":2,\"1485\":2,\"1490\":1,\"1492\":24,\"1493\":1,\"1494\":5,\"1495\":1,\"1496\":6,\"1497\":25,\"1498\":3,\"1500\":12,\"1524\":4}}],[\"than\",{\"1\":{\"561\":4,\"1485\":2,\"1492\":2,\"1496\":1,\"1497\":4,\"1567\":1}}],[\"things\",{\"1\":{\"1493\":1}}],[\"thinking\",{\"0\":{\"771\":1}}],[\"thirdmax\",{\"1\":{\"441\":1}}],[\"this表示referencepipeline\",{\"1\":{\"1499\":1}}],[\"this\",{\"1\":{\"0\":1,\"302\":1,\"311\":1,\"338\":3,\"395\":1,\"566\":2,\"1362\":1,\"1378\":1,\"1379\":5,\"1380\":8,\"1403\":1,\"1408\":3,\"1412\":1,\"1426\":1,\"1427\":1,\"1431\":4,\"1450\":1,\"1452\":3,\"1469\":2,\"1471\":3,\"1472\":2,\"1474\":6,\"1475\":21,\"1476\":26,\"1477\":4,\"1478\":3,\"1480\":4,\"1482\":7,\"1485\":9,\"1490\":10,\"1491\":1,\"1492\":3,\"1493\":6,\"1494\":2,\"1495\":4,\"1496\":6,\"1497\":41,\"1498\":15,\"1499\":14,\"1500\":19,\"1515\":1,\"1524\":39,\"1525\":12,\"1526\":1,\"1527\":1,\"1528\":12,\"1531\":1,\"1532\":3,\"1540\":1}}],[\"through\",{\"1\":{\"1500\":1}}],[\"thrown\",{\"1\":{\"1472\":2,\"1476\":4,\"1497\":2,\"1540\":1}}],[\"throwableholderexception\",{\"1\":{\"1532\":2}}],[\"throwableholder\",{\"1\":{\"1532\":11}}],[\"throwable\",{\"1\":{\"1452\":5,\"1524\":5,\"1525\":1,\"1531\":4,\"1532\":13}}],[\"throwing\",{\"0\":{\"986\":1},\"1\":{\"1497\":1}}],[\"throws\",{\"1\":{\"720\":1,\"1364\":1,\"1379\":2,\"1380\":2,\"1398\":1,\"1451\":3,\"1468\":1,\"1472\":3,\"1474\":3,\"1475\":12,\"1476\":8,\"1478\":2,\"1496\":3,\"1497\":3,\"1515\":1,\"1521\":1,\"1523\":1,\"1524\":7,\"1525\":3,\"1528\":2,\"1531\":4,\"1532\":1,\"1534\":3,\"1540\":1}}],[\"throw\",{\"1\":{\"381\":1,\"806\":1,\"1353\":1,\"1380\":2,\"1410\":1,\"1411\":1,\"1430\":1,\"1431\":1,\"1451\":2,\"1452\":5,\"1496\":4,\"1497\":3,\"1498\":2,\"1499\":5,\"1500\":1,\"1524\":23,\"1525\":4,\"1527\":1,\"1528\":2,\"1532\":9,\"1535\":1}}],[\"thrift文件\",{\"0\":{\"836\":1}}],[\"thrift\",{\"0\":{\"834\":1}}],[\"three\",{\"1\":{\"1500\":1}}],[\"threesum\",{\"1\":{\"366\":2}}],[\"threshold=2\",{\"1\":{\"1428\":1}}],[\"threshold=length∗loadfactor\",{\"1\":{\"1423\":1}}],[\"threshold是hashmap所能容纳的最大数量的node\",{\"1\":{\"1423\":1}}],[\"threshold\",{\"1\":{\"1352\":2,\"1423\":1,\"1426\":2,\"1427\":8,\"1430\":1,\"1431\":1,\"1493\":1}}],[\"threads\",{\"1\":{\"1492\":1,\"1494\":1,\"1497\":1,\"1567\":3}}],[\"threadlambda\",{\"1\":{\"1468\":2}}],[\"threadlocalrandom\",{\"1\":{\"1431\":1}}],[\"threadlocal增加变量\",{\"1\":{\"1405\":1}}],[\"threadlocal\",{\"1\":{\"1405\":1}}],[\"threadlocal<dateformat>\",{\"1\":{\"1405\":1}}],[\"threadlocal类实现了该模式\",{\"1\":{\"1405\":1}}],[\"threadlocal的作用\",{\"0\":{\"82\":1}}],[\"threading+blocking的web\",{\"1\":{\"1442\":1}}],[\"thread模式\",{\"0\":{\"1411\":1},\"1\":{\"1411\":1}}],[\"threadfatory\",{\"1\":{\"1397\":1}}],[\"threadfactory\",{\"1\":{\"1353\":3,\"1397\":2}}],[\"thread2通过cas修改value值为1\",{\"1\":{\"1356\":1}}],[\"thread2通过cas修改value值为2\",{\"1\":{\"1356\":1}}],[\"thread2\",{\"1\":{\"1356\":5,\"1428\":1}}],[\"thread1的e指向了key\",{\"1\":{\"1428\":1}}],[\"thread1通过cas修改value值为3\",{\"1\":{\"1356\":1}}],[\"thread1\",{\"1\":{\"1356\":4,\"1428\":1}}],[\"threadname\",{\"1\":{\"1354\":1}}],[\"threadpoolexecutor的拒绝策略\",{\"1\":{\"1353\":1}}],[\"threadpoolexecutor\",{\"1\":{\"1353\":1,\"1450\":2}}],[\"thread更新数据\",{\"1\":{\"597\":1}}],[\"thread执行中转日志\",{\"1\":{\"597\":1}}],[\"thread演化成为了多个线程\",{\"1\":{\"590\":1}}],[\"thread读取中转日志\",{\"1\":{\"590\":1}}],[\"thread负责与主库建立连接\",{\"1\":{\"590\":1}}],[\"thread和sql\",{\"1\":{\"590\":1}}],[\"thread\",{\"0\":{\"635\":1,\"1405\":1,\"1410\":1},\"1\":{\"549\":1,\"590\":1,\"597\":1,\"613\":8,\"618\":2,\"634\":1,\"635\":4,\"636\":1,\"675\":2,\"1354\":4,\"1356\":2,\"1410\":4,\"1411\":1,\"1428\":2,\"1431\":1,\"1450\":1,\"1452\":2,\"1468\":6,\"1469\":4,\"1487\":1,\"1492\":1,\"1494\":4,\"1496\":3,\"1497\":9,\"1499\":1,\"1500\":2,\"1545\":1,\"1567\":1}}],[\"thread类中的yield方法有什么作用\",{\"0\":{\"59\":1}}],[\"these\",{\"1\":{\"1496\":2,\"1497\":4}}],[\"their\",{\"1\":{\"1496\":5,\"1497\":3}}],[\"thelist2\",{\"1\":{\"1485\":2}}],[\"thelist1\",{\"1\":{\"1485\":2}}],[\"thelist\",{\"1\":{\"1485\":2,\"1486\":2}}],[\"them\",{\"1\":{\"1485\":1,\"1492\":3,\"1493\":1,\"1524\":1}}],[\"theme\",{\"1\":{\"4\":2}}],[\"they\",{\"1\":{\"1471\":2,\"1492\":2,\"1496\":1,\"1500\":4}}],[\"there\",{\"1\":{\"1357\":1,\"1477\":1,\"1485\":2,\"1496\":1,\"1524\":1,\"1535\":1}}],[\"the\",{\"1\":{\"385\":2,\"566\":3,\"708\":1,\"1431\":1,\"1471\":24,\"1472\":16,\"1474\":11,\"1475\":89,\"1476\":48,\"1477\":3,\"1478\":37,\"1485\":18,\"1486\":7,\"1490\":3,\"1491\":1,\"1492\":76,\"1493\":2,\"1494\":11,\"1495\":23,\"1496\":28,\"1497\":123,\"1498\":44,\"1499\":11,\"1500\":94,\"1524\":28,\"1525\":4,\"1527\":1,\"1532\":2,\"1535\":1,\"1540\":4,\"1567\":3}}],[\"thenacceptboth\",{\"1\":{\"1395\":1}}],[\"thenapply\",{\"1\":{\"1395\":1}}],[\"thencomparing\",{\"1\":{\"1491\":6,\"1531\":1}}],[\"thencompose\",{\"1\":{\"1395\":1}}],[\"thencombine\",{\"1\":{\"1395\":1}}],[\"then\",{\"1\":{\"2\":1,\"1475\":12,\"1476\":4,\"1492\":2,\"1494\":1,\"1495\":1,\"1496\":2,\"1497\":5,\"1498\":4,\"1540\":1}}],[\"tomcat热加载和热部署\",{\"0\":{\"1573\":1}}],[\"tomcat提供了四组目录供用户存放第三方类库\",{\"1\":{\"1571\":1}}],[\"tomcat提供了webapplicationinitializer的接口\",{\"1\":{\"1535\":1}}],[\"tomcat主要用类加载器解决以下4个问题\",{\"1\":{\"1571\":1}}],[\"tomcat拥有不同的自定义类加载器\",{\"1\":{\"1571\":1}}],[\"tomcat中自定义了一个类加载器webappclassloader\",{\"1\":{\"1571\":1}}],[\"tomcat作为servlet容器\",{\"1\":{\"1571\":1}}],[\"tomcat类加载机制\",{\"0\":{\"1568\":1}}],[\"tomcat对jdk线程池的扩展taskqueue\",{\"1\":{\"1567\":1}}],[\"tomcat线程模型\",{\"0\":{\"1567\":1}}],[\"tomcat与外部世界的连接器\",{\"1\":{\"1565\":1}}],[\"tomcat核心组件\",{\"0\":{\"1562\":1}}],[\"tomcat要实现2个核心功能\",{\"1\":{\"1561\":1}}],[\"tomcat的类加载机制\",{\"0\":{\"1571\":1}}],[\"tomcat的设计者将网络通信和应用层协议解析放在一起考虑\",{\"1\":{\"1565\":1}}],[\"tomcat的设计者分别设计了3个组件来实现这3个功能\",{\"1\":{\"1565\":1}}],[\"tomcat的架构图如下\",{\"1\":{\"1561\":1}}],[\"tomcat的核心\",{\"1\":{\"1561\":1}}],[\"tomcat启动期间会通过解析server\",{\"1\":{\"1561\":1}}],[\"tomcat采用了组件化的设计\",{\"1\":{\"1561\":1}}],[\"tomcat是java\",{\"1\":{\"1561\":1}}],[\"tomcat整体架构\",{\"0\":{\"1561\":1}}],[\"tomcat\",{\"0\":{\"1560\":1},\"1\":{\"1565\":1}}],[\"tomcat自定义类加载器\",{\"1\":{\"1540\":1}}],[\"tomcat除了会帮我们实例化我们所实现的webapplicationinitializer的类以外\",{\"1\":{\"1535\":1}}],[\"tomillis\",{\"1\":{\"1489\":1}}],[\"toset\",{\"1\":{\"1495\":3}}],[\"tostring\",{\"1\":{\"302\":1,\"329\":2,\"385\":1,\"400\":1,\"409\":3,\"1423\":1,\"1471\":1,\"1472\":4,\"1485\":2,\"1486\":2,\"1489\":1,\"1490\":1,\"1493\":1,\"1495\":2,\"1524\":2}}],[\"together\",{\"1\":{\"1492\":1,\"1498\":1}}],[\"tolowercase\",{\"1\":{\"1491\":5}}],[\"tolist本身方法返回的是一个arraylist对象\",{\"1\":{\"1495\":1}}],[\"tolist\",{\"1\":{\"1475\":2,\"1485\":2,\"1486\":5,\"1490\":1,\"1492\":1,\"1493\":1,\"1495\":5}}],[\"tointfunction<\",{\"1\":{\"1491\":1,\"1495\":1}}],[\"touppercase\",{\"1\":{\"1486\":1,\"1487\":3,\"1491\":2}}],[\"toc\",{\"1\":{\"1504\":1}}],[\"tocollection\",{\"1\":{\"1486\":4,\"1493\":1,\"1495\":2}}],[\"tochararray\",{\"1\":{\"380\":1,\"384\":1,\"385\":1,\"386\":1,\"387\":5,\"400\":1,\"428\":1}}],[\"toarray\",{\"1\":{\"1480\":1,\"1485\":2}}],[\"toward\",{\"1\":{\"1471\":2}}],[\"tojsonstring\",{\"1\":{\"719\":1}}],[\"too\",{\"1\":{\"656\":1,\"1497\":1}}],[\"top\",{\"1\":{\"392\":1,\"566\":1,\"1850\":1}}],[\"totalbydept\",{\"1\":{\"1493\":1}}],[\"total\",{\"1\":{\"388\":6,\"566\":1,\"1493\":1,\"1496\":1}}],[\"to\",{\"1\":{\"1\":1,\"2\":2,\"3\":1,\"385\":1,\"455\":1,\"459\":1,\"566\":4,\"568\":2,\"571\":1,\"604\":1,\"605\":1,\"618\":1,\"623\":1,\"624\":1,\"656\":3,\"735\":1,\"761\":2,\"1356\":3,\"1357\":1,\"1419\":1,\"1431\":1,\"1447\":1,\"1471\":6,\"1472\":3,\"1474\":5,\"1475\":36,\"1476\":14,\"1478\":5,\"1485\":4,\"1486\":2,\"1490\":1,\"1491\":1,\"1492\":36,\"1493\":3,\"1494\":4,\"1495\":14,\"1496\":13,\"1497\":56,\"1498\":7,\"1499\":2,\"1500\":31,\"1524\":22,\"1525\":2,\"1528\":2,\"1532\":4,\"1535\":1,\"1540\":1,\"1567\":3}}],[\"bv1pj411n7xz\",{\"1\":{\"1870\":1}}],[\"bv16j411h7rd\",{\"1\":{\"1870\":1}}],[\"bv1m741137qy\",{\"1\":{\"1869\":1}}],[\"bv1gb411t7ha\",{\"1\":{\"1868\":1}}],[\"bv18e411x7et\",{\"1\":{\"1867\":1}}],[\"bv1sv411r7vd\",{\"1\":{\"1865\":1}}],[\"bv1az4y1u7n3\",{\"1\":{\"1865\":1}}],[\"bv1a4411b7v9\",{\"1\":{\"1863\":1}}],[\"bv17a4y1x7zq\",{\"1\":{\"1864\":1}}],[\"bv14a411q7pf\",{\"1\":{\"1863\":1}}],[\"bv19k4y1l7mt\",{\"1\":{\"1861\":1}}],[\"bv1tv411b7dp\",{\"1\":{\"1860\":1}}],[\"bv1fe411p7b3\",{\"1\":{\"1859\":1}}],[\"bv1dp4y1q7hf\",{\"1\":{\"1858\":1}}],[\"bv1y7411k7zz\",{\"1\":{\"1856\":1}}],[\"bv1cj411m7gc\",{\"1\":{\"1853\":1}}],[\"bv12b411k7zu\",{\"1\":{\"1852\":1}}],[\"bv1kb411w75n\",{\"1\":{\"1847\":1}}],[\"bp\",{\"1\":{\"1524\":5}}],[\"bw\",{\"1\":{\"1524\":10}}],[\"bdname\",{\"1\":{\"1525\":3}}],[\"bd\",{\"1\":{\"1524\":13,\"1525\":2}}],[\"bgsave和save对比\",{\"0\":{\"726\":1}}],[\"bgsave是异步进行\",{\"1\":{\"725\":1}}],[\"bgsave\",{\"0\":{\"725\":1},\"1\":{\"726\":1}}],[\"bgsave命令返回\",{\"1\":{\"725\":1}}],[\"bgsave命令\",{\"1\":{\"724\":1}}],[\"blpop\",{\"1\":{\"708\":6}}],[\"bloking\",{\"1\":{\"1449\":1}}],[\"blobinfo\",{\"1\":{\"1470\":1}}],[\"blob和text都不能有默认值\",{\"1\":{\"667\":1}}],[\"blob系列存储二进制字符串\",{\"1\":{\"667\":1}}],[\"blob\",{\"1\":{\"667\":1}}],[\"blocked\",{\"1\":{\"1360\":1}}],[\"blockingwaitstrategy策略\",{\"1\":{\"1397\":1}}],[\"blockingqueue<integer>\",{\"1\":{\"1380\":2}}],[\"blockingqueue<runnable>\",{\"1\":{\"1353\":1}}],[\"blockingqueue是线程安全的\",{\"1\":{\"1378\":1}}],[\"blockingqueue和jdk集合包中的queue接口兼容\",{\"1\":{\"1378\":1}}],[\"blockingqueue\",{\"0\":{\"1378\":1}}],[\"blockingqueue实现原理\",{\"0\":{\"1376\":1}}],[\"blocking\",{\"1\":{\"739\":1,\"1441\":2}}],[\"block\",{\"0\":{\"540\":1},\"1\":{\"539\":1,\"540\":2,\"568\":5,\"660\":1,\"690\":1,\"692\":1,\"694\":2,\"1496\":1}}],[\"blog\",{\"1\":{\"467\":1,\"698\":1,\"1526\":1}}],[\"bsd许可\",{\"1\":{\"705\":1}}],[\"bst\",{\"1\":{\"353\":1}}],[\"bca\",{\"1\":{\"693\":1}}],[\"b=b\",{\"1\":{\"1494\":4}}],[\"b=\",{\"1\":{\"662\":1}}],[\"b=temp\",{\"1\":{\"544\":1}}],[\"btree\",{\"1\":{\"647\":1,\"655\":1}}],[\"b大约1170个元素\",{\"1\":{\"640\":1}}],[\"b+tree\",{\"0\":{\"640\":1}}],[\"b+树的层级并不会很高\",{\"1\":{\"686\":1}}],[\"b+树可能会出现分裂和平衡的现象\",{\"1\":{\"642\":1}}],[\"b+树提供的这个快速定位能力\",{\"1\":{\"503\":1}}],[\"b+树为了维护索引的有序性\",{\"1\":{\"472\":1}}],[\"b+树是应文件系统所需而出的一种b树的变形树\",{\"1\":{\"350\":1}}],[\"b+树\",{\"0\":{\"350\":1,\"472\":1}}],[\"b执行第一条update语句的事务id就是248\",{\"1\":{\"634\":1}}],[\"b查到的这个trx\",{\"1\":{\"634\":1}}],[\"b中从innodb\",{\"1\":{\"634\":1}}],[\"b这个语句执行出来\",{\"1\":{\"629\":1}}],[\"b这两个索引的结构图\",{\"1\":{\"484\":1}}],[\"b继续执行\",{\"1\":{\"629\":1}}],[\"b先插入了两个记录\",{\"1\":{\"629\":1}}],[\"b是申请了自增值以后马上就释放自增锁\",{\"1\":{\"629\":1}}],[\"b创建了一个相同结构的表t2\",{\"1\":{\"629\":1}}],[\"b创建的两个临时表t1\",{\"1\":{\"549\":1}}],[\"b创建的临时表\",{\"1\":{\"549\":1}}],[\"b退出等待\",{\"1\":{\"618\":1}}],[\"b处于锁等待状态\",{\"1\":{\"618\":1}}],[\"b时\",{\"1\":{\"618\":1}}],[\"b虽然处于blocked状态\",{\"1\":{\"618\":1}}],[\"b几乎同时就提示了语句被中断\",{\"1\":{\"617\":1}}],[\"b发给主库a\",{\"1\":{\"605\":1}}],[\"b也是再这个间隙加的间隙锁\",{\"1\":{\"585\":1}}],[\"b并不会被阻塞\",{\"1\":{\"585\":1}}],[\"b才能继续执行\",{\"1\":{\"584\":1}}],[\"b在执行第一个update语句的时候就被锁住了\",{\"1\":{\"584\":1}}],[\"b在t2时刻\",{\"1\":{\"584\":1}}],[\"b事务提交\",{\"1\":{\"584\":1}}],[\"b和session\",{\"1\":{\"583\":1}}],[\"b把id=0这一行的d值改成了5\",{\"1\":{\"583\":1}}],[\"b把数据都删除后\",{\"1\":{\"483\":1}}],[\"b需要的也是mdl读锁\",{\"1\":{\"578\":1}}],[\"b只需要操作p\",{\"1\":{\"562\":1}}],[\"b要写入一行ftime是2018\",{\"1\":{\"561\":1}}],[\"b的insert语句\",{\"1\":{\"629\":1}}],[\"b的\",{\"1\":{\"629\":1}}],[\"b的连接\",{\"1\":{\"618\":1}}],[\"b的线程状态设置thd\",{\"1\":{\"618\":1}}],[\"b的线程id是5\",{\"1\":{\"549\":1}}],[\"b的执行线程发一个信号\",{\"1\":{\"618\":1}}],[\"b的运行状态改成thd\",{\"1\":{\"618\":1}}],[\"b的server\",{\"1\":{\"615\":1}}],[\"b的事务\",{\"1\":{\"605\":1}}],[\"b的gtid的集合\",{\"1\":{\"605\":1}}],[\"b的差集\",{\"1\":{\"605\":1}}],[\"b的语句先执行\",{\"1\":{\"599\":1}}],[\"b的第二条语句update\",{\"1\":{\"584\":1}}],[\"b的第一条查询语句是可以正常执行的\",{\"1\":{\"561\":1}}],[\"b的第一个insert语句是可以执行成功\",{\"1\":{\"561\":1}}],[\"b的修改结果\",{\"1\":{\"583\":1}}],[\"b的alter语句被堵住\",{\"1\":{\"562\":1}}],[\"b的两条插入语句应该都要进入锁等待状态\",{\"1\":{\"561\":1}}],[\"b的thread\",{\"1\":{\"550\":1}}],[\"b的临时表t1\",{\"1\":{\"550\":1}}],[\"b的查询语句select\",{\"1\":{\"483\":1}}],[\"b就是不可见的\",{\"1\":{\"547\":1}}],[\"b<=2000\",{\"1\":{\"544\":1}}],[\"b>=1\",{\"1\":{\"544\":1}}],[\"b∈\",{\"1\":{\"544\":1}}],[\"bnl的内存计算也会快得多\",{\"1\":{\"662\":1}}],[\"bnl的执行流程如下\",{\"1\":{\"540\":1}}],[\"bnl转bka\",{\"0\":{\"544\":1}}],[\"bnl算法对系统的影响主要包括三个方面\",{\"1\":{\"543\":1}}],[\"bnl算法的性能问题\",{\"0\":{\"543\":1}}],[\"bnl可能会对被驱动表做多次扫描\",{\"1\":{\"543\":1}}],[\"bka算法的优化要依赖于mrr\",{\"1\":{\"542\":1}}],[\"bka算法并没有默认开启\",{\"1\":{\"542\":1}}],[\"bka\",{\"1\":{\"542\":1}}],[\"b5\",{\"1\":{\"515\":1}}],[\"b4\",{\"1\":{\"515\":1}}],[\"b3\",{\"1\":{\"515\":1}}],[\"b22\",{\"1\":{\"515\":1}}],[\"b1bc7ed\",{\"1\":{\"1490\":1}}],[\"b1\",{\"1\":{\"515\":1}}],[\"b本身是索引\",{\"1\":{\"485\":1}}],[\"b原来的查询语句执行情况对比\",{\"1\":{\"483\":1}}],[\"b原来的查询\",{\"1\":{\"483\":1}}],[\"b两个字段\",{\"1\":{\"483\":1}}],[\"b各自的查询呢\",{\"1\":{\"476\":1}}],[\"bbb\",{\"1\":{\"1363\":1,\"1364\":1,\"1496\":7}}],[\"bb\",{\"1\":{\"473\":1}}],[\"built\",{\"1\":{\"1498\":1}}],[\"buildautowiringmetadata\",{\"1\":{\"1525\":1}}],[\"build\",{\"1\":{\"1496\":2}}],[\"builderexception\",{\"1\":{\"806\":1}}],[\"bulk\",{\"1\":{\"1497\":3}}],[\"busyspinwaitstrategy策略\",{\"1\":{\"1397\":1}}],[\"button\",{\"1\":{\"1468\":5}}],[\"but\",{\"1\":{\"1357\":1,\"1492\":1,\"1496\":1,\"1497\":2,\"1524\":1,\"1525\":1}}],[\"buffer通过网卡传输给客户端\",{\"1\":{\"1459\":1}}],[\"buffer直接拷贝到socket\",{\"1\":{\"1459\":1}}],[\"buffer用于和nio通道进行交互\",{\"1\":{\"1451\":1}}],[\"buffer用的是buffer\",{\"1\":{\"480\":1}}],[\"bufferedreader\",{\"1\":{\"1450\":4}}],[\"buffer对成本的影响\",{\"1\":{\"692\":1}}],[\"bufferpool缓存机制\",{\"0\":{\"680\":1}}],[\"buffer一次只能放800行数据\",{\"1\":{\"662\":1}}],[\"buffer则表示使用的join算法是nlj\",{\"1\":{\"661\":1}}],[\"buffer配置的比较小并且没有条件继续增加了\",{\"1\":{\"657\":1}}],[\"buffer内存排序\",{\"1\":{\"657\":1}}],[\"buffer以后\",{\"1\":{\"588\":1}}],[\"buffer里放800行记录\",{\"1\":{\"662\":1}}],[\"buffer里的数据是无序的\",{\"1\":{\"662\":1}}],[\"buffer里的日志全部持久化到磁盘\",{\"1\":{\"588\":1}}],[\"buffer里面维护的是一个无序数组\",{\"1\":{\"545\":1}}],[\"buffer里面要放的字段数太多\",{\"1\":{\"492\":1}}],[\"buffer里面的操作日志\",{\"1\":{\"482\":1}}],[\"buffer持久化到磁盘\",{\"1\":{\"588\":1}}],[\"buffer占用的空间即将达到innodb\",{\"1\":{\"588\":1}}],[\"buffer是很快的\",{\"1\":{\"588\":1}}],[\"buffer是有序数组\",{\"1\":{\"555\":1}}],[\"buffer是无序数组\",{\"1\":{\"555\":1}}],[\"buffer是以无序数组的方式组织的\",{\"1\":{\"540\":1}}],[\"buffer放不下\",{\"1\":{\"542\":1}}],[\"buffer放满了\",{\"1\":{\"541\":1}}],[\"buffer优化的nlj算法就是bka算法\",{\"1\":{\"542\":1}}],[\"buffer参数控制的\",{\"1\":{\"541\":1}}],[\"buffer复用\",{\"1\":{\"540\":1}}],[\"buffer满了\",{\"1\":{\"540\":1}}],[\"buffer和临时表中执行的\",{\"1\":{\"492\":1}}],[\"buffer和redo\",{\"0\":{\"482\":1},\"1\":{\"482\":1}}],[\"buffer主要节省的则是随机读磁盘的io消耗\",{\"1\":{\"482\":1}}],[\"buffer区域\",{\"1\":{\"482\":1}}],[\"buffer都能提升更新性能\",{\"1\":{\"481\":1}}],[\"buffer都可以起到加速的作用吗\",{\"1\":{\"481\":1}}],[\"buffer反而起到了副作用\",{\"1\":{\"481\":1}}],[\"buffer只限于用在普通索引的场景下\",{\"1\":{\"481\":1}}],[\"buffer详解\",{\"0\":{\"481\":1}}],[\"buffer因为减少了随机磁盘访问\",{\"1\":{\"480\":1}}],[\"buffer的操作会导致其他cache中的副本失效\",{\"1\":{\"1350\":1}}],[\"buffer的内存不够用\",{\"1\":{\"555\":1}}],[\"buffer的字段m做排序\",{\"1\":{\"555\":1}}],[\"buffer的字段\",{\"1\":{\"492\":1}}],[\"buffer的更新状态图\",{\"1\":{\"482\":1}}],[\"buffer的维护代价\",{\"1\":{\"481\":1}}],[\"buffer的使用效果最好\",{\"1\":{\"481\":1}}],[\"buffer的记录变更越多\",{\"1\":{\"481\":1}}],[\"buffer的主要目的就是将记录的变更动作缓存下来\",{\"1\":{\"481\":1}}],[\"buffer的机制\",{\"1\":{\"480\":1}}],[\"buffer的大小是由read\",{\"1\":{\"541\":1}}],[\"buffer的大小是由参数join\",{\"1\":{\"540\":1,\"662\":1}}],[\"buffer的大小最多只能占用buffer\",{\"1\":{\"480\":1}}],[\"buffer的大小\",{\"1\":{\"480\":1}}],[\"buffer了\",{\"1\":{\"480\":1}}],[\"buffer呢\",{\"1\":{\"480\":1}}],[\"buffer在内存中有拷贝\",{\"1\":{\"480\":1}}],[\"buffer中数据对比\",{\"1\":{\"662\":1}}],[\"buffer中一次排序更多的行\",{\"1\":{\"657\":1}}],[\"buffer中进行排序\",{\"1\":{\"657\":3}}],[\"buffer中根据r的值进行排序\",{\"1\":{\"557\":1}}],[\"buffer中有两个字段\",{\"1\":{\"557\":1}}],[\"buffer中放入的数据是r1~r100\",{\"1\":{\"542\":1}}],[\"buffer中按照id做了排序\",{\"1\":{\"541\":1}}],[\"buffer中依次取出id\",{\"1\":{\"492\":1}}],[\"buffer中的内容写入内存\",{\"1\":{\"1350\":1}}],[\"buffer中的字段position和主键id按照字段position进行排序\",{\"1\":{\"657\":1}}],[\"buffer中的\",{\"1\":{\"588\":1}}],[\"buffer中的日志一起持久化到磁盘\",{\"1\":{\"588\":1}}],[\"buffer中的日志\",{\"1\":{\"588\":1}}],[\"buffer中的部分日志有没有可能被持久化到磁盘呢\",{\"1\":{\"588\":1}}],[\"buffer中的两个字段里\",{\"1\":{\"557\":1}}],[\"buffer中的id进行递增排序\",{\"1\":{\"541\":1}}],[\"buffer中的数据对比得到部分结果\",{\"1\":{\"662\":1}}],[\"buffer中的数据按照字段position排序\",{\"1\":{\"657\":1}}],[\"buffer中的数据按照字段name进行排序\",{\"1\":{\"492\":1}}],[\"buffer中的数据按照字段name做快速排序\",{\"1\":{\"491\":1}}],[\"buffer中的数据进行对比\",{\"1\":{\"544\":1}}],[\"buffer中的数据做对比\",{\"1\":{\"540\":2,\"662\":1}}],[\"buffer中的操作应用到原数据页\",{\"1\":{\"480\":1}}],[\"buffer中与这个页有关的操作\",{\"1\":{\"480\":1}}],[\"buffer中\",{\"1\":{\"480\":1,\"491\":1,\"493\":1,\"540\":5,\"541\":1,\"544\":1,\"555\":1,\"588\":3,\"657\":4,\"662\":1}}],[\"buffer\",{\"0\":{\"848\":1},\"1\":{\"467\":1,\"480\":6,\"481\":2,\"482\":1,\"491\":8,\"492\":2,\"501\":1,\"540\":8,\"541\":1,\"542\":1,\"544\":1,\"555\":1,\"557\":1,\"558\":3,\"588\":2,\"657\":2,\"662\":1,\"1363\":2,\"1451\":1,\"1452\":4,\"1453\":2,\"1459\":2,\"1545\":1}}],[\"bubblesorttemplate\",{\"1\":{\"317\":1}}],[\"bydept\",{\"1\":{\"1493\":1}}],[\"bytebuffer>\",{\"1\":{\"1452\":3}}],[\"bytebuffer\",{\"1\":{\"1410\":4,\"1411\":4,\"1451\":22,\"1452\":31}}],[\"bytebuf数据结构\",{\"0\":{\"881\":1}}],[\"bytebuf使用示例\",{\"0\":{\"880\":1}}],[\"bytebuf实现原理\",{\"0\":{\"879\":1}}],[\"byte\",{\"1\":{\"746\":1,\"806\":8,\"1451\":6,\"1452\":6}}],[\"bytes1\",{\"1\":{\"1452\":3}}],[\"bytes\",{\"1\":{\"616\":1,\"1451\":9,\"1452\":9}}],[\"by非主键的字段\",{\"1\":{\"659\":1}}],[\"by冲突时优先where\",{\"1\":{\"658\":1}}],[\"by还需要用到另外一个字段来存累积计数\",{\"1\":{\"555\":1}}],[\"by还比较简单\",{\"1\":{\"548\":1}}],[\"by的逻辑\",{\"1\":{\"555\":1}}],[\"by的结果\",{\"1\":{\"554\":1}}],[\"by的时候\",{\"1\":{\"554\":1}}],[\"by的语义逻辑是统计不同的值出现的个数\",{\"1\":{\"554\":1}}],[\"by问题之前\",{\"1\":{\"554\":1}}],[\"by逻辑都需要构造一个带唯一索引的表\",{\"1\":{\"554\":1}}],[\"by语句中加入sql\",{\"1\":{\"555\":1}}],[\"by语句都要先放到内存临时表\",{\"1\":{\"555\":1}}],[\"by语句就可以改成\",{\"1\":{\"554\":1}}],[\"by语句就可以不再需要临时表\",{\"1\":{\"554\":1}}],[\"by语句需要临时表\",{\"1\":{\"554\":1}}],[\"by语句执行起来就会很慢\",{\"1\":{\"554\":1}}],[\"by语句\",{\"0\":{\"554\":1,\"555\":1}}],[\"by语句的explain结果\",{\"1\":{\"554\":1}}],[\"by语句的优化\",{\"0\":{\"552\":1}}],[\"by语句的一种方式就是让原来无序的数据变的\",{\"1\":{\"493\":1}}],[\"by执行流程\",{\"0\":{\"553\":1}}],[\"by会有临时表的产生\",{\"1\":{\"515\":1}}],[\"by一致\",{\"1\":{\"515\":1}}],[\"by基本上都需要进行排序\",{\"1\":{\"515\":1}}],[\"by排序views字段索引就可以用上\",{\"1\":{\"498\":1}}],[\"by排序views字段索引就用不上\",{\"1\":{\"498\":1}}],[\"by排序的时候没有用到索引\",{\"1\":{\"498\":1}}],[\"by也和索引有关\",{\"1\":{\"495\":1}}],[\"by与索引\",{\"0\":{\"490\":1}}],[\"by和分组查询group\",{\"1\":{\"467\":1}}],[\"by\",{\"0\":{\"556\":1},\"1\":{\"467\":3,\"485\":6,\"490\":1,\"491\":1,\"498\":3,\"515\":12,\"527\":1,\"548\":4,\"550\":3,\"551\":1,\"553\":6,\"554\":1,\"555\":1,\"556\":1,\"557\":1,\"558\":3,\"559\":2,\"561\":1,\"566\":1,\"568\":7,\"616\":4,\"656\":6,\"657\":2,\"659\":4,\"1471\":2,\"1472\":4,\"1474\":2,\"1477\":1,\"1485\":4,\"1486\":1,\"1488\":1,\"1490\":4,\"1492\":4,\"1493\":3,\"1495\":4,\"1496\":4,\"1497\":17,\"1498\":2,\"1499\":1,\"1500\":4,\"1524\":8,\"1532\":2}}],[\"bilibili\",{\"1\":{\"1847\":1,\"1852\":1,\"1853\":1,\"1856\":1,\"1858\":1,\"1859\":1,\"1860\":1,\"1861\":1,\"1863\":2,\"1864\":1,\"1865\":2,\"1867\":1,\"1868\":1,\"1869\":1,\"1870\":2}}],[\"biconsumer\",{\"1\":{\"1492\":1}}],[\"biconsumer<partition<a>\",{\"1\":{\"1495\":1}}],[\"biconsumer<map<k\",{\"1\":{\"1495\":1}}],[\"biconsumer<i\",{\"1\":{\"1494\":1}}],[\"biconsumer<set<t>\",{\"1\":{\"1494\":4}}],[\"biconsumer<a\",{\"1\":{\"1492\":1,\"1493\":4,\"1494\":1,\"1495\":3}}],[\"biconsumer<t\",{\"1\":{\"1485\":1}}],[\"biconsumer<r\",{\"1\":{\"1485\":4}}],[\"bifunction\",{\"1\":{\"1475\":6,\"1478\":4}}],[\"bifunction<integer\",{\"1\":{\"1475\":3}}],[\"bifunction<t\",{\"1\":{\"1475\":3,\"1478\":3}}],[\"bifunctiontest\",{\"1\":{\"1475\":14}}],[\"bifunction这个函数式接口的定义\",{\"1\":{\"1475\":1}}],[\"bi实际上是bidirectional的缩写\",{\"1\":{\"1475\":1}}],[\"bioexampleserverhandle\",{\"1\":{\"1450\":3}}],[\"bio\",{\"0\":{\"1450\":1},\"1\":{\"1453\":1}}],[\"bios\",{\"0\":{\"780\":1}}],[\"biasedlockingdecaytime=25000ms范围内没有达到40次\",{\"1\":{\"1362\":1}}],[\"biasedlockingbulkrevokethreshold来手动设置阈值\",{\"1\":{\"1362\":1}}],[\"biasedlockingbulkrevokethreshold\",{\"1\":{\"1362\":1}}],[\"biasedlockingbulkrebiasthreshold和xx\",{\"1\":{\"1362\":1}}],[\"biasedlockingbulkrebiasthreshold\",{\"1\":{\"1362\":1}}],[\"biasedlockingstartupdelay=0\",{\"1\":{\"1362\":1}}],[\"biased\",{\"1\":{\"1361\":1}}],[\"bitpos\",{\"1\":{\"715\":1}}],[\"bitop\",{\"1\":{\"715\":1}}],[\"bitcount\",{\"1\":{\"715\":3}}],[\"bitmap是一串连续的2进制数字\",{\"1\":{\"715\":1}}],[\"bitmaps\",{\"0\":{\"715\":1}}],[\"bitenum\",{\"1\":{\"665\":1}}],[\"bits\",{\"1\":{\"656\":2}}],[\"bit\",{\"1\":{\"656\":1,\"715\":1,\"1497\":1}}],[\"bigdecimal\",{\"1\":{\"806\":6}}],[\"big\",{\"1\":{\"555\":2}}],[\"biginteger\",{\"1\":{\"806\":4}}],[\"bigint\",{\"1\":{\"467\":2,\"472\":1,\"486\":1,\"632\":1,\"665\":1}}],[\"bincount\",{\"1\":{\"1426\":2,\"1431\":9}}],[\"binds\",{\"1\":{\"1497\":4}}],[\"binding这样一些特性\",{\"1\":{\"1498\":1}}],[\"binding\",{\"1\":{\"1497\":17,\"1498\":1}}],[\"bind\",{\"1\":{\"1410\":1,\"1411\":1,\"1451\":1,\"1452\":1}}],[\"bin\",{\"0\":{\"587\":1,\"591\":1,\"653\":1},\"1\":{\"566\":1,\"591\":1,\"616\":1,\"1431\":1}}],[\"binlogs显示的最小的binlog文件是master\",{\"1\":{\"622\":1}}],[\"binlog被从库发送给备库\",{\"1\":{\"609\":1}}],[\"binlog在记录event的时候\",{\"1\":{\"591\":1}}],[\"binlog里面就只有一个truncate\",{\"1\":{\"622\":1}}],[\"binlog里面记的都是a的server\",{\"1\":{\"592\":1}}],[\"binlog里面记录了数据行修改前和修改后的值\",{\"1\":{\"621\":1}}],[\"binlog里面记录了真实删除的行的主键id\",{\"1\":{\"591\":1}}],[\"binlog里面记录的就是sql语句的原文\",{\"1\":{\"591\":1}}],[\"binlog里面会记录修改前整行的数据和修改后的整行数据\",{\"1\":{\"591\":1}}],[\"binlog中的内容如下\",{\"1\":{\"591\":1}}],[\"binlog\",{\"1\":{\"588\":3,\"591\":4,\"602\":2,\"616\":1}}],[\"binlog也可以组提交了\",{\"1\":{\"588\":1}}],[\"binlog和innodb\",{\"1\":{\"588\":1}}],[\"binlog设置为大于1的值\",{\"1\":{\"588\":1}}],[\"binlog设置为n\",{\"1\":{\"587\":1}}],[\"binlog设置成一个比较大的值\",{\"1\":{\"587\":1}}],[\"binlog=n\",{\"1\":{\"587\":1}}],[\"binlog=1的时候\",{\"1\":{\"587\":1}}],[\"binlog=0的时候\",{\"1\":{\"587\":1}}],[\"binlog控制的\",{\"1\":{\"587\":1}}],[\"binlog的组提交中\",{\"1\":{\"602\":1}}],[\"binlog的组提交的效果通常不如redo\",{\"1\":{\"588\":1}}],[\"binlog的吸入逻辑比较简单\",{\"1\":{\"587\":1}}],[\"binlog的内容如下\",{\"1\":{\"584\":1}}],[\"binlog才会记录临时表的操作\",{\"1\":{\"550\":1}}],[\"binlog还没有写完的时候\",{\"1\":{\"464\":1}}],[\"binlog会记录所有的逻辑操作\",{\"1\":{\"464\":1}}],[\"binlog是可以追加写入的\",{\"1\":{\"462\":1}}],[\"binlog是逻辑日志\",{\"1\":{\"462\":1}}],[\"binlog是mysql的server层实现的\",{\"1\":{\"462\":1}}],[\"binlog日志只能用于归档\",{\"1\":{\"462\":1}}],[\"binaryoperator是因为合并的是两个部分的结果容器的类型\",{\"1\":{\"1492\":1}}],[\"binaryoperator<partition<a>>\",{\"1\":{\"1495\":1}}],[\"binaryoperator<map<k\",{\"1\":{\"1495\":1}}],[\"binaryoperator<u>\",{\"1\":{\"1495\":1}}],[\"binaryoperator<i>\",{\"1\":{\"1494\":1}}],[\"binaryoperator<set<t>>\",{\"1\":{\"1494\":2}}],[\"binaryoperator<a>\",{\"1\":{\"1492\":1,\"1493\":4,\"1495\":1}}],[\"binaryoperator<t>\",{\"1\":{\"1478\":4}}],[\"binaryoperatortest\",{\"1\":{\"1478\":6}}],[\"binaryoperator中还有两个静态方法\",{\"1\":{\"1478\":1}}],[\"binaryoperator表示针对于两个相同运算对象的操作\",{\"1\":{\"1478\":1}}],[\"binaryoperator\",{\"1\":{\"1478\":6,\"1485\":2,\"1492\":1,\"1495\":2}}],[\"binarytreepaths\",{\"1\":{\"409\":3}}],[\"binary\",{\"1\":{\"340\":2,\"1497\":1}}],[\"binarysearch\",{\"1\":{\"305\":1}}],[\"boxed\",{\"1\":{\"1497\":1}}],[\"boxing\",{\"1\":{\"1497\":5}}],[\"box\",{\"1\":{\"1497\":1}}],[\"boxsupplier\",{\"1\":{\"1495\":1}}],[\"box<i>\",{\"1\":{\"1494\":1}}],[\"both\",{\"1\":{\"1492\":1}}],[\"body\",{\"1\":{\"1471\":1}}],[\"boundedqueue\",{\"1\":{\"1380\":1}}],[\"bound\",{\"1\":{\"1357\":1}}],[\"board\",{\"1\":{\"417\":5}}],[\"boot框架\",{\"1\":{\"1867\":1}}],[\"boot实战练手很不错\",{\"1\":{\"1865\":1}}],[\"boot呢\",{\"1\":{\"1861\":1}}],[\"boot就可以了\",{\"1\":{\"1860\":1}}],[\"bootstrapclassloader\",{\"1\":{\"1569\":1}}],[\"bootstrap和serverbootstrap了解么\",{\"0\":{\"214\":1}}],[\"boot\",{\"0\":{\"1041\":1,\"1861\":1},\"1\":{\"720\":1,\"1861\":5,\"1867\":1}}],[\"boot<\",{\"1\":{\"720\":1}}],[\"book\",{\"1\":{\"499\":4,\"500\":2,\"1859\":1}}],[\"book表\",{\"1\":{\"499\":1}}],[\"book和class两张表都是没有使用索引\",{\"1\":{\"499\":1}}],[\"boolean\",{\"1\":{\"302\":4,\"311\":1,\"317\":1,\"318\":1,\"319\":1,\"373\":2,\"386\":2,\"387\":2,\"389\":1,\"397\":2,\"398\":1,\"406\":6,\"408\":1,\"412\":1,\"421\":1,\"428\":2,\"435\":3,\"440\":1,\"443\":1,\"806\":8,\"1357\":1,\"1377\":2,\"1379\":1,\"1387\":1,\"1408\":2,\"1423\":1,\"1426\":2,\"1430\":1,\"1431\":2,\"1434\":3,\"1471\":1,\"1476\":4,\"1486\":1,\"1494\":1,\"1496\":1,\"1497\":7,\"1498\":8,\"1499\":1,\"1500\":2,\"1516\":1,\"1524\":8,\"1525\":4,\"1526\":1,\"1527\":2,\"1531\":2,\"1532\":2,\"1534\":1,\"1540\":1,\"1567\":1}}],[\"baidu\",{\"1\":{\"1850\":1}}],[\"balking\",{\"1\":{\"1408\":1}}],[\"balking是\",{\"1\":{\"1408\":1}}],[\"balking模式和guard\",{\"1\":{\"1408\":1}}],[\"balking模式一种多个线程执行同一操作a时可以考虑的模式\",{\"1\":{\"1408\":1}}],[\"balking模式常用于一个线程发现另一个线程已经做了某一件相同的事\",{\"1\":{\"1408\":1}}],[\"balking模式\",{\"0\":{\"1408\":1}}],[\"balanced\",{\"1\":{\"1497\":3}}],[\"balance\",{\"1\":{\"672\":2,\"1497\":1}}],[\"bar线程不安全\",{\"1\":{\"1403\":1}}],[\"bar\",{\"1\":{\"1403\":2}}],[\"bar的属性foo虽然是final的\",{\"1\":{\"1403\":1}}],[\"barrier等\",{\"1\":{\"1367\":1}}],[\"batch\",{\"1\":{\"807\":1}}],[\"batched\",{\"0\":{\"542\":1},\"1\":{\"542\":1}}],[\"backlink\",{\"1\":{\"1498\":1}}],[\"backlog\",{\"1\":{\"746\":4}}],[\"backed\",{\"1\":{\"1496\":1}}],[\"background\",{\"1\":{\"725\":1}}],[\"back\",{\"1\":{\"711\":6,\"1500\":1}}],[\"backtrack\",{\"1\":{\"417\":3}}],[\"bac\",{\"1\":{\"693\":1}}],[\"ba两种连接顺序\",{\"1\":{\"693\":1}}],[\"basis\",{\"1\":{\"1497\":2}}],[\"basic\",{\"1\":{\"2\":1}}],[\"basics\",{\"1\":{\"0\":1}}],[\"basepackage\",{\"1\":{\"1524\":4}}],[\"basepackages\",{\"1\":{\"1524\":3}}],[\"basestream\",{\"1\":{\"1501\":1}}],[\"basestream<e\",{\"1\":{\"1500\":2}}],[\"basestream<t\",{\"1\":{\"1496\":3}}],[\"basestream定义了所有流\",{\"1\":{\"1496\":1}}],[\"basecount\",{\"1\":{\"1431\":2}}],[\"base基数才会使用到\",{\"1\":{\"1357\":1}}],[\"base变量\",{\"1\":{\"1357\":1}}],[\"based\",{\"1\":{\"1492\":1,\"1497\":2,\"1524\":2}}],[\"based实现\",{\"0\":{\"979\":1,\"980\":1,\"981\":1,\"982\":1,\"983\":1,\"984\":1,\"985\":1,\"986\":1,\"987\":1,\"988\":1,\"989\":1}}],[\"based=off\",{\"1\":{\"541\":1,\"542\":1}}],[\"base\",{\"1\":{\"326\":2,\"435\":2,\"1357\":3,\"1498\":1,\"1524\":1}}],[\"broker权限验证\",{\"0\":{\"1831\":1}}],[\"broker消费队列\",{\"0\":{\"1774\":1}}],[\"bridgemethodresolver\",{\"1\":{\"1525\":2}}],[\"bridgedmethod\",{\"1\":{\"1525\":4}}],[\"brpoplpush\",{\"1\":{\"708\":1}}],[\"brpop\",{\"1\":{\"708\":2}}],[\"bracket\",{\"1\":{\"386\":4}}],[\"break\",{\"1\":{\"302\":1,\"319\":1,\"366\":1,\"388\":1,\"428\":1,\"1383\":1,\"1394\":1,\"1426\":2,\"1430\":2,\"1431\":6,\"1525\":1}}],[\"b树是一种平衡的多路查找树\",{\"1\":{\"349\":1}}],[\"b树\",{\"0\":{\"349\":1}}],[\"bf\",{\"1\":{\"341\":1}}],[\"b均为常数\",{\"1\":{\"332\":1}}],[\"b^c\",{\"1\":{\"314\":2}}],[\"b\",{\"0\":{\"80\":1,\"639\":1},\"1\":{\"314\":1,\"332\":1,\"364\":5,\"376\":6,\"459\":1,\"476\":3,\"484\":2,\"485\":7,\"491\":4,\"514\":15,\"533\":1,\"539\":1,\"540\":1,\"541\":1,\"544\":11,\"545\":2,\"546\":5,\"551\":1,\"571\":1,\"605\":1,\"621\":2,\"638\":1,\"643\":1,\"660\":2,\"662\":4,\"671\":1,\"693\":1,\"714\":2,\"1357\":3,\"1427\":1,\"1428\":1,\"1431\":3,\"1464\":1,\"1465\":1,\"1475\":8,\"1478\":12,\"1491\":2,\"1494\":14,\"1495\":4}}],[\"become\",{\"1\":{\"1500\":2}}],[\"because\",{\"1\":{\"717\":1,\"1491\":1}}],[\"begun\",{\"1\":{\"1497\":1}}],[\"begins\",{\"1\":{\"1498\":1}}],[\"beginning\",{\"1\":{\"717\":1}}],[\"begin或start\",{\"1\":{\"572\":1}}],[\"begin\",{\"1\":{\"428\":4,\"537\":1,\"541\":1,\"551\":1,\"556\":1,\"572\":1,\"605\":1,\"622\":1,\"628\":1,\"655\":1,\"660\":2,\"679\":1,\"1494\":1,\"1500\":9}}],[\"benefit\",{\"1\":{\"1497\":1,\"1499\":1}}],[\"beyond\",{\"1\":{\"1497\":1}}],[\"bearing\",{\"1\":{\"1496\":1}}],[\"bean注解方法返回的单例对象的问题\",{\"1\":{\"1529\":1}}],[\"beanbostprocess\",{\"1\":{\"1528\":1}}],[\"bean对应的beandefinition\",{\"1\":{\"1527\":1}}],[\"beannotofrequiredtypeexception\",{\"1\":{\"1525\":1}}],[\"beannameviewresolver\",{\"1\":{\"1534\":1}}],[\"beannameurlhandlermapping\",{\"1\":{\"1534\":1}}],[\"beannameaware\",{\"1\":{\"1528\":1}}],[\"beannamesfortypeincludingancestors\",{\"1\":{\"1525\":1}}],[\"beannames\",{\"1\":{\"1524\":3}}],[\"beannamegenerator\",{\"1\":{\"1524\":1}}],[\"beanname\",{\"1\":{\"1524\":95,\"1525\":29,\"1526\":3,\"1527\":11}}],[\"beanutils\",{\"1\":{\"1525\":1}}],[\"bean销毁的逻辑\",{\"1\":{\"1524\":1}}],[\"beantype\",{\"1\":{\"1524\":5,\"1525\":2}}],[\"beanclassloaderaware\",{\"1\":{\"1528\":1}}],[\"beanclass\",{\"1\":{\"1527\":5}}],[\"beancreationexception\",{\"1\":{\"1524\":14,\"1525\":2,\"1527\":1}}],[\"beancreation\",{\"1\":{\"1524\":5}}],[\"beancurrentlyincreationexception\",{\"1\":{\"1524\":2}}],[\"beaninstance\",{\"1\":{\"1524\":8}}],[\"bean替换使用\",{\"1\":{\"1521\":1}}],[\"beanpostprocess\",{\"1\":{\"1524\":2,\"1528\":2}}],[\"beanpostprocessors\",{\"1\":{\"1524\":1}}],[\"beanpostprocessor\",{\"0\":{\"1519\":1},\"1\":{\"1524\":1}}],[\"beanpostprocess使用场景有哪些\",{\"0\":{\"1176\":1}}],[\"bean工厂\",{\"1\":{\"1513\":1}}],[\"beansexception\",{\"1\":{\"1524\":6,\"1525\":3,\"1528\":3}}],[\"beans\",{\"1\":{\"1509\":4,\"1524\":10,\"1525\":2,\"1528\":2}}],[\"beans替换实现\",{\"0\":{\"1234\":1}}],[\"beandefition中存在很多属性用来描述一个bean的特点\",{\"1\":{\"1509\":1}}],[\"beandefinition的autowirecandidate属性\",{\"1\":{\"1525\":1}}],[\"beandefinition的典型实现\",{\"1\":{\"1509\":1}}],[\"beandefinitionvalidationexception\",{\"1\":{\"1524\":2}}],[\"beandefinitionnames\",{\"1\":{\"1524\":1}}],[\"beandefinitionholder\",{\"1\":{\"1524\":2}}],[\"beandefinitionstoreexception\",{\"1\":{\"1524\":5}}],[\"beandefinitions\",{\"1\":{\"1524\":3}}],[\"beandefinitionregistrypostprocessor可以向beanfactory中注册beandefinition\",{\"1\":{\"1529\":1}}],[\"beandefinitionregistrypostprocessor与beanfactorypostprocessor的区别在于\",{\"1\":{\"1529\":1}}],[\"beandefinitionregistry\",{\"1\":{\"1513\":1}}],[\"beandefinitionbuilder\",{\"1\":{\"1509\":1}}],[\"beandefinition表示bean的元信息定义\",{\"1\":{\"1509\":1}}],[\"beandefinition合并阶段\",{\"0\":{\"1158\":1}}],[\"beandefinition作为依赖来源\",{\"0\":{\"1136\":1}}],[\"beandefinition注册到ioc容器\",{\"0\":{\"1090\":1}}],[\"beandefinition\",{\"0\":{\"1088\":1,\"1098\":1,\"1509\":1},\"1\":{\"1509\":3,\"1524\":6,\"1525\":3}}],[\"bean的方式代理对象\",{\"1\":{\"1531\":1}}],[\"bean的会覆盖掉\",{\"1\":{\"1529\":1}}],[\"bean的也是配置类\",{\"1\":{\"1529\":1}}],[\"bean的名称\",{\"1\":{\"1525\":1}}],[\"bean的生命周期\",{\"0\":{\"1524\":1}}],[\"bean的生命周期底层原理\",{\"1\":{\"1507\":1}}],[\"bean的处理流程是怎样的\",{\"0\":{\"1344\":1}}],[\"bean的校验\",{\"0\":{\"1230\":1}}],[\"beanwrapper\",{\"1\":{\"1524\":2,\"1527\":1}}],[\"beanwrapper与javabeans之间的关系是\",{\"0\":{\"1240\":1}}],[\"beanwrapper使用场景\",{\"0\":{\"1235\":1}}],[\"bean属性元信息\",{\"0\":{\"1180\":1}}],[\"bean配置元信息底层实现\",{\"0\":{\"1185\":1}}],[\"bean配置元信息\",{\"0\":{\"1179\":1,\"1182\":1,\"1183\":1,\"1184\":1}}],[\"bean垃圾收集\",{\"0\":{\"1174\":1}}],[\"bean实例化后阶段\",{\"0\":{\"1163\":1}}],[\"bean是否被其他方案他替代\",{\"0\":{\"1154\":1}}],[\"bean是否在一个应用中是唯一的\",{\"0\":{\"1153\":1}}],[\"beanfactorytransactionattributesourceadvisor\",{\"1\":{\"1532\":1}}],[\"beanfactoryutils\",{\"1\":{\"1525\":2}}],[\"beanfactoryaware\",{\"1\":{\"1524\":1,\"1525\":1,\"1528\":1}}],[\"beanfactorypostprocessor只可以拿到beandifinition\",{\"1\":{\"1529\":1}}],[\"beanfactorypostprocessor\",{\"0\":{\"1520\":1}}],[\"beanfactorypostprocess与beanpostprocess的区别\",{\"0\":{\"1177\":1}}],[\"beanfactory的类图如下\",{\"1\":{\"1513\":1}}],[\"beanfactory会负责创建bean\",{\"1\":{\"1513\":1}}],[\"beanfactory表示bean工厂\",{\"1\":{\"1513\":1}}],[\"beanfactory是如何处理循环依赖的\",{\"0\":{\"1345\":1}}],[\"beanfactory是怎样处理bean生命周期\",{\"0\":{\"1178\":1}}],[\"beanfactory初始化完成阶段\",{\"0\":{\"1332\":1}}],[\"beanfactory注册beanpostprocess\",{\"0\":{\"1327\":1}}],[\"beanfactory后置处理阶段\",{\"0\":{\"1326\":1}}],[\"beanfactory准备阶段\",{\"0\":{\"1325\":1}}],[\"beanfactory创建阶段\",{\"0\":{\"1324\":1}}],[\"beanfactory\",{\"0\":{\"1110\":1,\"1513\":1},\"1\":{\"1513\":1,\"1524\":8,\"1525\":7,\"1528\":13}}],[\"beanfactory和factorybean\",{\"0\":{\"1086\":1}}],[\"beanfactory和applicationcontext\",{\"0\":{\"1082\":1}}],[\"bean命名\",{\"0\":{\"1089\":1}}],[\"bean\",{\"0\":{\"1095\":1,\"1097\":1,\"1159\":1,\"1217\":1,\"1226\":1},\"1\":{\"720\":1,\"1515\":1,\"1516\":1,\"1524\":60,\"1525\":7,\"1526\":1,\"1527\":3,\"1528\":2,\"1531\":2}}],[\"being\",{\"1\":{\"1494\":1,\"1496\":2,\"1497\":1,\"1524\":1}}],[\"beijing\",{\"1\":{\"1482\":1,\"1488\":3}}],[\"below\",{\"1\":{\"1492\":1}}],[\"better\",{\"1\":{\"1492\":2,\"1495\":1}}],[\"between\",{\"1\":{\"467\":1,\"473\":1,\"475\":1,\"483\":4,\"484\":2,\"485\":2,\"1497\":2,\"1498\":1,\"1524\":1}}],[\"behaviour\",{\"1\":{\"1497\":1}}],[\"behavioral\",{\"1\":{\"1496\":1}}],[\"behavior\",{\"1\":{\"1496\":3,\"1497\":5,\"1499\":1}}],[\"behaves\",{\"1\":{\"1472\":1}}],[\"behind\",{\"1\":{\"594\":5,\"595\":4,\"596\":1,\"609\":3}}],[\"been\",{\"1\":{\"1472\":2,\"1487\":1,\"1492\":1,\"1496\":1,\"1497\":4,\"1499\":1,\"1500\":1,\"1524\":3}}],[\"beforeinstantiationresolved\",{\"1\":{\"1524\":2}}],[\"beforeprototypecreation\",{\"1\":{\"1524\":2}}],[\"before\",{\"0\":{\"950\":1,\"951\":1,\"983\":1},\"1\":{\"708\":2,\"1475\":18,\"1495\":2,\"1497\":4,\"1498\":2,\"1500\":5,\"1507\":1,\"1524\":3,\"1531\":6}}],[\"best\",{\"1\":{\"325\":1,\"656\":2,\"1497\":3}}],[\"be\",{\"1\":{\"1\":1,\"2\":1,\"566\":1,\"624\":1,\"656\":1,\"1471\":4,\"1472\":1,\"1474\":1,\"1476\":10,\"1477\":2,\"1485\":6,\"1486\":2,\"1492\":12,\"1494\":5,\"1495\":3,\"1496\":13,\"1497\":30,\"1498\":6,\"1499\":1,\"1500\":6,\"1524\":9,\"1525\":1}}],[\"wdbyte\",{\"1\":{\"1503\":1}}],[\"would\",{\"1\":{\"1492\":3,\"1497\":7,\"1499\":1}}],[\"worse\",{\"1\":{\"1492\":1}}],[\"worl\",{\"1\":{\"707\":1}}],[\"world=world\",{\"1\":{\"1494\":4}}],[\"world\",{\"0\":{\"816\":1},\"1\":{\"707\":5,\"719\":1,\"735\":3,\"1470\":12,\"1471\":2,\"1472\":2,\"1474\":4,\"1479\":2,\"1484\":8,\"1485\":3,\"1486\":7,\"1487\":4,\"1489\":4,\"1491\":1,\"1494\":13,\"1496\":10,\"1497\":2}}],[\"workqueue\",{\"1\":{\"1353\":3}}],[\"worker\",{\"0\":{\"1411\":1},\"1\":{\"1494\":27}}],[\"workercountof\",{\"1\":{\"1353\":2}}],[\"worker执行完成后\",{\"1\":{\"598\":1}}],[\"workers决定的\",{\"1\":{\"597\":1}}],[\"work线程的个数\",{\"1\":{\"597\":1}}],[\"work\",{\"1\":{\"572\":2,\"1492\":1,\"1497\":2}}],[\"word的thread\",{\"1\":{\"1362\":1}}],[\"word的结构也变为轻量级锁的结构\",{\"1\":{\"1362\":1}}],[\"word中也有该字段\",{\"1\":{\"1362\":1}}],[\"word中的thread\",{\"1\":{\"1362\":1}}],[\"word中锁标记枚举\",{\"1\":{\"1361\":1}}],[\"words\",{\"1\":{\"556\":2,\"557\":1,\"558\":1}}],[\"word最后一个char\",{\"1\":{\"302\":4}}],[\"word在list中不存在\",{\"1\":{\"302\":1}}],[\"word在map中是否存在\",{\"1\":{\"302\":1}}],[\"word\",{\"1\":{\"302\":18,\"385\":2,\"556\":2,\"557\":1,\"558\":1,\"1361\":2,\"1477\":2}}],[\"wb\",{\"1\":{\"1410\":2,\"1411\":2}}],[\"we\",{\"1\":{\"1492\":2,\"1496\":1,\"1497\":1,\"1500\":2,\"1524\":3,\"1525\":1,\"1528\":1,\"1567\":6}}],[\"welcome=welcome\",{\"1\":{\"1494\":4}}],[\"welcome\",{\"1\":{\"1486\":4,\"1491\":1,\"1494\":17}}],[\"well\",{\"1\":{\"1485\":2,\"1497\":1}}],[\"web原理\",{\"1\":{\"1861\":1}}],[\"web教程\",{\"1\":{\"1856\":1}}],[\"web后端\",{\"0\":{\"1856\":1}}],[\"web前端\",{\"0\":{\"1855\":1}}],[\"websocket等\",{\"1\":{\"1561\":1}}],[\"websocket生命周期分解\",{\"0\":{\"825\":1}}],[\"web应用服务器\",{\"1\":{\"1561\":1}}],[\"webmvcconfigurer\",{\"1\":{\"1535\":1}}],[\"webapplicationcontext\",{\"1\":{\"1535\":2}}],[\"webappinitializerclasses\",{\"1\":{\"1535\":1}}],[\"web\",{\"0\":{\"1854\":1},\"1\":{\"1534\":4,\"1535\":2,\"1847\":1,\"1856\":2}}],[\"web技术\",{\"0\":{\"1055\":1}}],[\"weak等\",{\"1\":{\"806\":1}}],[\"weight字段增加0\",{\"1\":{\"710\":1}}],[\"weight\",{\"1\":{\"710\":1,\"1496\":2}}],[\"www\",{\"1\":{\"800\":1,\"806\":1,\"1371\":1,\"1376\":1,\"1503\":1,\"1529\":1,\"1530\":1,\"1534\":1,\"1847\":3,\"1852\":1,\"1853\":2,\"1856\":1,\"1858\":1,\"1859\":2,\"1860\":1,\"1861\":1,\"1863\":2,\"1864\":1,\"1865\":2,\"1867\":1,\"1868\":1,\"1869\":1,\"1870\":2}}],[\"wtw6ds0y300\",{\"1\":{\"713\":1}}],[\"wmrjwbr5250\",{\"1\":{\"713\":1}}],[\"wrap\",{\"1\":{\"1500\":1}}],[\"wrapsink\",{\"1\":{\"1500\":5}}],[\"wrapandcopyinto\",{\"1\":{\"1500\":4}}],[\"wrapped\",{\"1\":{\"1524\":1}}],[\"wrappedsink\",{\"1\":{\"1500\":7}}],[\"wrapper\",{\"1\":{\"1497\":2}}],[\"wrapping\",{\"1\":{\"1500\":1}}],[\"wrong\",{\"1\":{\"708\":1}}],[\"wrongtype\",{\"1\":{\"708\":1}}],[\"writechannel\",{\"1\":{\"1464\":3}}],[\"writecompletionhandler\",{\"1\":{\"1452\":1}}],[\"writebuffer\",{\"1\":{\"1451\":4}}],[\"writers\",{\"1\":{\"1498\":1}}],[\"writer\",{\"1\":{\"1450\":4}}],[\"writefds和exceptfds\",{\"1\":{\"1446\":1}}],[\"writefds\",{\"1\":{\"1446\":1}}],[\"write设计思想维护服务路由表\",{\"1\":{\"1404\":1}}],[\"write来解决\",{\"1\":{\"1404\":1}}],[\"write最大的应用领域还是在函数式编程领域\",{\"1\":{\"1404\":1}}],[\"write在操作系统领域中也有广泛的应用\",{\"1\":{\"1404\":1}}],[\"write这两个容器实现读操作是无锁的\",{\"1\":{\"1404\":1}}],[\"write容器\",{\"1\":{\"1404\":1}}],[\"write缺点就是消耗内存\",{\"1\":{\"1404\":1}}],[\"write方法\",{\"1\":{\"1404\":1}}],[\"write方法就会阻塞\",{\"1\":{\"739\":1}}],[\"write模式\",{\"0\":{\"1404\":1}}],[\"writeset策略也是没法并行的\",{\"1\":{\"602\":1}}],[\"writeset是在主库生成后直接写入binlog里面的\",{\"1\":{\"602\":1}}],[\"writeset\",{\"1\":{\"602\":1}}],[\"writeset表示的对于事务涉及更新的每一行\",{\"1\":{\"602\":1}}],[\"write到page\",{\"1\":{\"588\":1}}],[\"write和fsync的时机\",{\"1\":{\"587\":1}}],[\"write\",{\"1\":{\"461\":2,\"566\":1,\"577\":1,\"588\":1,\"671\":2,\"725\":1,\"740\":5,\"748\":2,\"1350\":1,\"1404\":3,\"1410\":1,\"1411\":1,\"1451\":6,\"1452\":5,\"1462\":2,\"1464\":2,\"1465\":1}}],[\"w的参数是为了把内容都解析出来\",{\"1\":{\"591\":1}}],[\"warn\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"warnings\",{\"1\":{\"646\":1,\"1497\":1}}],[\"warning\",{\"1\":{\"466\":1,\"467\":5,\"498\":1,\"568\":3}}],[\"way\",{\"1\":{\"1497\":1}}],[\"ways\",{\"1\":{\"1497\":1}}],[\"wangchujiang\",{\"1\":{\"1865\":1}}],[\"wangwu=90\",{\"1\":{\"1490\":1}}],[\"wangwu=1\",{\"1\":{\"1490\":1}}],[\"wangwu\",{\"1\":{\"1475\":1,\"1480\":2,\"1481\":2,\"1482\":1,\"1486\":1,\"1490\":1,\"1492\":1}}],[\"wanted\",{\"1\":{\"1492\":1}}],[\"was\",{\"1\":{\"1427\":1,\"1496\":1,\"1497\":1,\"1500\":1}}],[\"watch\",{\"1\":{\"718\":2,\"719\":1,\"1447\":1}}],[\"wal\",{\"1\":{\"698\":1}}],[\"wait模式\",{\"1\":{\"1407\":1}}],[\"waiters\",{\"1\":{\"1360\":1}}],[\"wait和notify\",{\"1\":{\"1354\":1}}],[\"wait和sleep方法有什么区别\",{\"0\":{\"57\":1}}],[\"waitstrategy\",{\"1\":{\"1397\":3}}],[\"waitsetlock\",{\"1\":{\"1360\":1}}],[\"waitset是第一个节点\",{\"1\":{\"1360\":1}}],[\"waitset\",{\"1\":{\"1360\":1}}],[\"waits\",{\"1\":{\"675\":4}}],[\"wait返回一个大于等于0的整数\",{\"1\":{\"610\":1}}],[\"wait\",{\"1\":{\"578\":2,\"581\":2,\"610\":2,\"611\":2,\"616\":5,\"1360\":2,\"1407\":1}}],[\"wxyz\",{\"1\":{\"400\":1}}],[\"whose\",{\"1\":{\"1474\":2,\"1475\":3,\"1476\":2,\"1477\":1,\"1478\":2,\"1485\":2,\"1496\":1}}],[\"whole\",{\"1\":{\"385\":1}}],[\"whether\",{\"1\":{\"1471\":3,\"1497\":1,\"1500\":1}}],[\"whenever\",{\"1\":{\"1497\":1}}],[\"when\",{\"1\":{\"1357\":3,\"1431\":1,\"1476\":4,\"1496\":2,\"1497\":6,\"1524\":1,\"1527\":1}}],[\"where与order\",{\"1\":{\"658\":1}}],[\"where语句\",{\"1\":{\"514\":1}}],[\"where条件里用不到的字段不创建索引\",{\"1\":{\"496\":1}}],[\"where子句的值总是false\",{\"1\":{\"467\":1}}],[\"where\",{\"1\":{\"454\":1,\"456\":1,\"458\":1,\"459\":1,\"460\":1,\"467\":12,\"472\":2,\"473\":1,\"475\":1,\"476\":1,\"477\":1,\"478\":1,\"479\":1,\"482\":1,\"483\":4,\"484\":1,\"485\":1,\"486\":1,\"488\":2,\"489\":1,\"490\":1,\"491\":3,\"498\":4,\"503\":3,\"504\":2,\"505\":7,\"507\":6,\"508\":2,\"509\":2,\"510\":2,\"511\":2,\"512\":12,\"513\":3,\"514\":12,\"515\":15,\"521\":1,\"527\":6,\"530\":2,\"531\":4,\"537\":1,\"538\":1,\"541\":1,\"544\":2,\"545\":1,\"546\":1,\"548\":3,\"558\":1,\"559\":1,\"571\":1,\"584\":11,\"585\":1,\"591\":1,\"599\":1,\"613\":2,\"616\":2,\"646\":2,\"651\":1,\"655\":1,\"656\":4,\"657\":2,\"659\":1,\"662\":3,\"672\":1,\"673\":1,\"674\":1,\"681\":1,\"684\":1,\"686\":2,\"690\":3,\"691\":4,\"692\":2,\"695\":1,\"1375\":2,\"1478\":2,\"1488\":1,\"1492\":1,\"1495\":1,\"1496\":1,\"1498\":2,\"1500\":1}}],[\"whatever\",{\"1\":{\"1499\":2,\"1500\":3}}],[\"what\",{\"1\":{\"566\":1}}],[\"while\",{\"1\":{\"296\":1,\"302\":4,\"305\":1,\"319\":1,\"360\":1,\"361\":1,\"362\":1,\"363\":1,\"364\":1,\"366\":3,\"367\":2,\"368\":1,\"371\":1,\"372\":1,\"373\":2,\"375\":1,\"376\":1,\"377\":2,\"383\":1,\"384\":1,\"385\":8,\"388\":2,\"393\":1,\"395\":3,\"396\":2,\"397\":2,\"401\":1,\"402\":1,\"403\":1,\"404\":2,\"410\":1,\"411\":1,\"422\":1,\"438\":1,\"439\":1,\"440\":1,\"443\":1,\"530\":1,\"537\":2,\"541\":4,\"551\":2,\"556\":2,\"635\":1,\"655\":2,\"660\":4,\"1360\":1,\"1379\":2,\"1380\":2,\"1383\":1,\"1410\":1,\"1411\":1,\"1427\":1,\"1431\":2,\"1450\":2,\"1451\":4,\"1496\":2,\"1497\":4,\"1499\":1,\"1525\":1}}],[\"which\",{\"1\":{\"0\":1,\"1476\":4,\"1478\":5,\"1485\":4,\"1492\":1,\"1495\":5,\"1496\":8,\"1497\":6,\"1498\":4,\"1500\":10,\"1524\":2}}],[\"w\",{\"1\":{\"317\":2,\"318\":2,\"319\":2,\"591\":1,\"1496\":8}}],[\"wiki\",{\"1\":{\"1847\":1,\"1859\":1}}],[\"wired\",{\"1\":{\"1500\":1}}],[\"wish\",{\"1\":{\"1500\":1}}],[\"window\",{\"1\":{\"1497\":2}}],[\"widget\",{\"1\":{\"1496\":2}}],[\"widgets是widget类型的集合\",{\"1\":{\"1496\":1}}],[\"widgets\",{\"1\":{\"1492\":1,\"1496\":4}}],[\"width\",{\"1\":{\"367\":2}}],[\"witnessed\",{\"1\":{\"1447\":1}}],[\"without\",{\"1\":{\"716\":1,\"1485\":2,\"1492\":1,\"1497\":1,\"1498\":1,\"1500\":1,\"1524\":1}}],[\"withdist\",{\"1\":{\"713\":2}}],[\"withcoord\",{\"1\":{\"713\":2}}],[\"withscores\",{\"1\":{\"711\":2}}],[\"withinitial\",{\"1\":{\"1405\":1}}],[\"within\",{\"1\":{\"566\":1,\"1524\":1}}],[\"with\",{\"0\":{\"1460\":1},\"1\":{\"3\":1,\"4\":1,\"566\":1,\"574\":1,\"717\":2,\"1460\":2,\"1462\":1,\"1471\":4,\"1476\":6,\"1485\":4,\"1491\":1,\"1492\":5,\"1494\":1,\"1495\":4,\"1496\":10,\"1497\":4,\"1498\":3,\"1500\":4,\"1524\":6,\"1525\":1,\"1535\":1}}],[\"wildcard\",{\"1\":{\"566\":1}}],[\"will\",{\"1\":{\"1\":1,\"2\":1,\"1471\":5,\"1474\":1,\"1476\":8,\"1485\":2,\"1486\":2,\"1494\":1,\"1495\":1,\"1496\":2,\"1497\":3,\"1498\":1,\"1500\":4,\"1524\":1,\"1532\":2}}],[\"ignoredependencyinterface\",{\"1\":{\"1528\":3}}],[\"ignored\",{\"1\":{\"1524\":1}}],[\"ignores\",{\"1\":{\"1497\":1}}],[\"ignoring\",{\"1\":{\"1492\":1}}],[\"illustration\",{\"1\":{\"1497\":1}}],[\"illustrates\",{\"1\":{\"1496\":1,\"1497\":1}}],[\"illegal\",{\"1\":{\"1524\":1}}],[\"illegalstateexception\",{\"1\":{\"1487\":1,\"1496\":1,\"1497\":2,\"1499\":4,\"1500\":1,\"1524\":4,\"1528\":1,\"1532\":2,\"1535\":1}}],[\"illegalargumentexception\",{\"1\":{\"381\":1,\"1380\":1,\"1497\":1,\"1515\":1}}],[\"i>\",{\"1\":{\"1471\":2,\"1494\":2}}],[\"i>j\",{\"1\":{\"428\":1}}],[\"i1\",{\"1\":{\"1468\":1}}],[\"i<100\",{\"1\":{\"1398\":1}}],[\"i<=100\",{\"1\":{\"660\":1}}],[\"i<=10000\",{\"1\":{\"660\":1}}],[\"i<=100000\",{\"1\":{\"655\":1}}],[\"iadd\",{\"1\":{\"1359\":1}}],[\"ia\",{\"1\":{\"1356\":2,\"1531\":2}}],[\"ip>\",{\"1\":{\"761\":2}}],[\"ip\",{\"1\":{\"761\":3}}],[\"ipc\",{\"1\":{\"568\":1}}],[\"ix锁\",{\"1\":{\"670\":1}}],[\"i=0\",{\"1\":{\"1398\":1,\"1488\":1}}],[\"i=i+1\",{\"1\":{\"655\":1,\"660\":2}}],[\"i=1\",{\"1\":{\"655\":1,\"660\":2}}],[\"immediately\",{\"1\":{\"1497\":1}}],[\"immutable\",{\"1\":{\"1486\":1,\"1495\":1,\"1497\":11,\"1498\":1}}],[\"immutability模式即不变性模式\",{\"1\":{\"1403\":1}}],[\"immutability模式\",{\"0\":{\"1403\":1}}],[\"imbalanced\",{\"1\":{\"1497\":1}}],[\"implicitlyappearedsingletonexception\",{\"1\":{\"1524\":1}}],[\"implspec\",{\"1\":{\"1472\":1}}],[\"implementors\",{\"1\":{\"1497\":1}}],[\"implement\",{\"1\":{\"1492\":3,\"1493\":1,\"1496\":1,\"1497\":1,\"1500\":1}}],[\"implementing\",{\"1\":{\"1472\":2,\"1490\":1,\"1495\":1}}],[\"implementations\",{\"1\":{\"1492\":3,\"1493\":1,\"1497\":3,\"1498\":1,\"1500\":1}}],[\"implementation\",{\"1\":{\"1471\":6,\"1472\":1,\"1492\":7,\"1496\":1,\"1497\":3,\"1500\":6}}],[\"implements\",{\"1\":{\"1423\":1,\"1431\":1,\"1452\":3,\"1484\":4,\"1491\":1,\"1493\":1,\"1494\":3,\"1495\":1,\"1496\":1,\"1497\":1,\"1498\":1,\"1500\":3,\"1516\":1,\"1521\":1,\"1525\":1,\"1534\":1}}],[\"impl\",{\"1\":{\"806\":1}}],[\"impose\",{\"1\":{\"1497\":1}}],[\"impossible\",{\"1\":{\"467\":2}}],[\"import注解的处理过程如下\",{\"1\":{\"1529\":1}}],[\"importresource\",{\"1\":{\"1529\":1}}],[\"import\",{\"1\":{\"302\":2,\"329\":1,\"1356\":4,\"1468\":8,\"1474\":1,\"1475\":1,\"1529\":1}}],[\"image=full\",{\"1\":{\"621\":1}}],[\"images\",{\"1\":{\"609\":1,\"616\":1,\"1470\":1}}],[\"image\",{\"1\":{\"609\":2,\"616\":2}}],[\"image设置为minimal\",{\"1\":{\"591\":1}}],[\"image的默认配置是full\",{\"1\":{\"591\":1}}],[\"io拷贝机制对比\",{\"0\":{\"1462\":1}}],[\"io拷贝机制\",{\"0\":{\"1457\":1}}],[\"io模型对比\",{\"0\":{\"1453\":1}}],[\"io模式及select\",{\"1\":{\"1438\":1}}],[\"ioexception\",{\"1\":{\"1451\":3,\"1468\":2,\"1523\":1,\"1524\":2,\"1528\":1}}],[\"io多路复用就是通过一种机制\",{\"1\":{\"1445\":1}}],[\"io多路复用就是我们通常说的select\",{\"1\":{\"1442\":1}}],[\"io多路复用之select\",{\"0\":{\"1445\":1}}],[\"io多路复用均属于同步io\",{\"1\":{\"1444\":1}}],[\"io多路复用模型与阻塞io其实并没有太大的区别\",{\"1\":{\"1442\":1}}],[\"io多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符\",{\"1\":{\"1442\":1}}],[\"io多路复用\",{\"0\":{\"1442\":1},\"1\":{\"1438\":1}}],[\"io基础\",{\"0\":{\"1438\":1}}],[\"io密集型任务\",{\"1\":{\"1387\":2}}],[\"ioc配置元信息\",{\"0\":{\"1081\":1}}],[\"ioc依赖注入\",{\"0\":{\"1079\":1}}],[\"ioc依赖查找\",{\"0\":{\"1078\":1}}],[\"ioc的实现\",{\"0\":{\"1069\":1}}],[\"ioc的发展简介\",{\"0\":{\"1066\":1}}],[\"ioc容器中的bean\",{\"1\":{\"1530\":1}}],[\"ioc容器启动时做了哪些准备\",{\"0\":{\"1087\":1}}],[\"ioc容器\",{\"0\":{\"1085\":1}}],[\"ioc容器生命周期\",{\"0\":{\"1083\":1}}],[\"ioc容器的职责\",{\"0\":{\"1068\":1}}],[\"ioc容器自动代理标准实现\",{\"0\":{\"971\":1}}],[\"ioc主要实现策略\",{\"0\":{\"1067\":1}}],[\"io与nio的区别\",{\"0\":{\"847\":1}}],[\"io与nio\",{\"0\":{\"846\":1}}],[\"io类型\",{\"1\":{\"726\":1}}],[\"io成本\",{\"1\":{\"682\":1,\"685\":1,\"686\":2}}],[\"io\",{\"1\":{\"568\":3,\"616\":4,\"694\":1,\"1442\":1,\"1449\":1,\"1468\":2,\"1491\":1,\"1496\":1,\"1497\":1}}],[\"ibatis\",{\"1\":{\"806\":4}}],[\"ibd文件\",{\"1\":{\"561\":2}}],[\"ibd为后缀的文件\",{\"1\":{\"549\":1}}],[\"ibdata1\",{\"1\":{\"482\":1}}],[\"ibd\",{\"1\":{\"482\":1}}],[\"ib\",{\"1\":{\"482\":1}}],[\"iconst\",{\"1\":{\"1359\":2}}],[\"icon\",{\"1\":{\"467\":1}}],[\"i−2\",{\"1\":{\"432\":1}}],[\"i−1\",{\"1\":{\"426\":2,\"427\":4,\"430\":1,\"432\":1}}],[\"i+1\",{\"1\":{\"428\":2}}],[\"i++的jvm字节码指令\",{\"1\":{\"1359\":1}}],[\"i++\",{\"1\":{\"317\":1,\"318\":1,\"319\":3,\"329\":2,\"359\":1,\"362\":1,\"364\":2,\"365\":2,\"366\":2,\"367\":1,\"368\":2,\"375\":1,\"380\":1,\"385\":4,\"386\":1,\"393\":2,\"399\":1,\"401\":1,\"402\":1,\"403\":1,\"411\":1,\"417\":2,\"419\":1,\"421\":1,\"422\":1,\"424\":2,\"425\":2,\"426\":2,\"427\":1,\"428\":2,\"429\":3,\"430\":1,\"431\":2,\"806\":1,\"1364\":1,\"1394\":1,\"1398\":1,\"1470\":1,\"1488\":1,\"1489\":1,\"1491\":1}}],[\"ii\",{\"0\":{\"402\":1}}],[\"i\",{\"1\":{\"317\":7,\"318\":9,\"319\":17,\"325\":1,\"329\":7,\"359\":7,\"362\":5,\"364\":14,\"365\":7,\"366\":16,\"367\":7,\"368\":10,\"375\":2,\"380\":4,\"384\":7,\"385\":18,\"386\":3,\"393\":10,\"399\":4,\"401\":2,\"402\":2,\"403\":3,\"411\":3,\"417\":11,\"419\":5,\"421\":5,\"422\":5,\"424\":7,\"425\":8,\"426\":23,\"427\":14,\"428\":32,\"429\":15,\"430\":12,\"431\":14,\"432\":2,\"537\":8,\"541\":15,\"551\":8,\"556\":9,\"566\":2,\"655\":3,\"660\":6,\"670\":1,\"714\":2,\"735\":3,\"806\":3,\"1357\":1,\"1359\":3,\"1364\":2,\"1394\":4,\"1398\":1,\"1426\":9,\"1427\":1,\"1428\":2,\"1431\":5,\"1468\":1,\"1470\":3,\"1480\":3,\"1484\":2,\"1487\":4,\"1488\":2,\"1489\":2,\"1491\":5,\"1494\":3,\"1496\":1,\"1497\":8,\"1499\":4,\"1511\":1,\"1524\":1,\"1528\":1,\"1847\":1}}],[\"ifpresent\",{\"1\":{\"1486\":1,\"1487\":1,\"1489\":2,\"1493\":2}}],[\"if\",{\"1\":{\"285\":1,\"288\":1,\"296\":3,\"302\":12,\"305\":2,\"317\":1,\"318\":1,\"319\":2,\"359\":1,\"360\":3,\"361\":2,\"362\":1,\"363\":1,\"365\":2,\"366\":6,\"367\":1,\"368\":2,\"371\":1,\"373\":3,\"376\":1,\"377\":1,\"380\":1,\"381\":2,\"383\":1,\"384\":1,\"385\":4,\"386\":7,\"387\":1,\"388\":4,\"395\":7,\"396\":4,\"397\":3,\"398\":6,\"400\":2,\"401\":3,\"402\":3,\"403\":6,\"404\":3,\"405\":1,\"406\":10,\"407\":1,\"408\":4,\"409\":7,\"410\":7,\"411\":8,\"412\":2,\"415\":3,\"417\":4,\"419\":1,\"421\":1,\"422\":1,\"424\":4,\"427\":1,\"428\":5,\"429\":2,\"431\":2,\"435\":6,\"438\":5,\"439\":1,\"440\":2,\"441\":2,\"443\":3,\"498\":2,\"499\":4,\"500\":2,\"566\":1,\"643\":3,\"655\":1,\"660\":2,\"767\":1,\"806\":4,\"1353\":7,\"1356\":6,\"1357\":2,\"1379\":3,\"1380\":6,\"1383\":1,\"1394\":1,\"1408\":2,\"1426\":10,\"1427\":15,\"1430\":7,\"1431\":27,\"1451\":19,\"1452\":3,\"1471\":2,\"1472\":4,\"1474\":3,\"1475\":12,\"1476\":23,\"1478\":2,\"1484\":2,\"1488\":1,\"1490\":1,\"1491\":4,\"1492\":7,\"1494\":6,\"1495\":9,\"1496\":3,\"1497\":35,\"1498\":11,\"1499\":11,\"1500\":9,\"1524\":80,\"1525\":45,\"1526\":1,\"1527\":9,\"1528\":3,\"1531\":9,\"1532\":15,\"1535\":3,\"1540\":6,\"1567\":6}}],[\"idiom\",{\"1\":{\"1497\":1}}],[\"ideal\",{\"1\":{\"1497\":2}}],[\"ideally\",{\"1\":{\"1497\":1}}],[\"identitytostring\",{\"1\":{\"1525\":1}}],[\"identity本身的意思也就是同一性\",{\"1\":{\"1475\":1}}],[\"identity\",{\"1\":{\"1475\":2,\"1486\":1,\"1492\":5,\"1494\":7,\"1495\":8}}],[\"identifier\",{\"1\":{\"605\":1}}],[\"id改成当前线程id\",{\"1\":{\"1362\":1}}],[\"id为0\",{\"1\":{\"1362\":1}}],[\"id为1且comments大于1的情况下\",{\"1\":{\"498\":1}}],[\"id这四个列组合起来不重复的值有多少\",{\"1\":{\"695\":1}}],[\"id这两个字段\",{\"1\":{\"492\":1}}],[\"id修改成删除操作的trx\",{\"1\":{\"679\":1}}],[\"id不在视图数组中\",{\"1\":{\"679\":1}}],[\"id不同\",{\"1\":{\"467\":1}}],[\"id在视图数组中\",{\"1\":{\"679\":1}}],[\"id落在黄色部分\",{\"1\":{\"679\":1}}],[\"id落在红色部分\",{\"1\":{\"679\":1}}],[\"id落在绿色部分\",{\"1\":{\"679\":1}}],[\"id可以从innodb\",{\"1\":{\"675\":1}}],[\"id列\",{\"0\":{\"645\":1}}],[\"id递增值mysql每次重启都会被保存起来\",{\"1\":{\"636\":1}}],[\"ids\",{\"1\":{\"635\":1}}],[\"id也不会清0\",{\"1\":{\"634\":1}}],[\"id也是a的server\",{\"1\":{\"592\":1}}],[\"id设置成了248\",{\"1\":{\"634\":1}}],[\"id先修成248\",{\"1\":{\"634\":1}}],[\"id达到248\",{\"1\":{\"634\":1}}],[\"id达到上限后\",{\"1\":{\"633\":1,\"636\":1}}],[\"id会持久化存储\",{\"1\":{\"634\":1}}],[\"id有什么好处呢\",{\"1\":{\"634\":1}}],[\"id跟row\",{\"1\":{\"634\":1}}],[\"id值比较大\",{\"1\":{\"634\":1}}],[\"id值越大优先级越高\",{\"1\":{\"467\":1}}],[\"id就是当前自己的事务则是可见的\",{\"1\":{\"679\":1}}],[\"id就是当前自己的事务是可见的\",{\"1\":{\"679\":1}}],[\"id就是0\",{\"1\":{\"634\":1}}],[\"id就是不同的\",{\"1\":{\"634\":1}}],[\"id就是线程id\",{\"1\":{\"634\":1}}],[\"id就会是一样的\",{\"1\":{\"634\":1}}],[\"id做对比\",{\"1\":{\"634\":1}}],[\"id做主键\",{\"1\":{\"615\":1}}],[\"id加1\",{\"1\":{\"634\":1}}],[\"id时\",{\"1\":{\"634\":1}}],[\"id全局变量\",{\"1\":{\"634\":1}}],[\"id回到a\",{\"1\":{\"633\":1}}],[\"id定义的长度是8个字节\",{\"1\":{\"633\":1}}],[\"id赋值给这个事务的xid\",{\"1\":{\"633\":1}}],[\"id写入表中的值范围\",{\"1\":{\"632\":1}}],[\"id能写到数据表中的值\",{\"1\":{\"632\":1}}],[\"id留的只是6个字节的长度\",{\"1\":{\"632\":1}}],[\"id都是连续的\",{\"1\":{\"629\":1}}],[\"id分配给这个事务\",{\"1\":{\"605\":1}}],[\"id只有在事务提交的时候才会分配\",{\"1\":{\"605\":1}}],[\"id与我们通常讲的事务id有所区别\",{\"1\":{\"605\":1}}],[\"id与自己的相同\",{\"1\":{\"592\":1}}],[\"id直接写到binlog里面\",{\"1\":{\"601\":1}}],[\"id+1\",{\"1\":{\"601\":1}}],[\"id必须不同\",{\"1\":{\"592\":1,\"615\":1}}],[\"id的时候\",{\"1\":{\"635\":1}}],[\"id的逻辑是\",{\"1\":{\"635\":1}}],[\"id的逻辑类似\",{\"1\":{\"634\":1}}],[\"id的增加速度变慢了\",{\"1\":{\"634\":1}}],[\"id的锁冲突\",{\"1\":{\"634\":1}}],[\"id的申请次数\",{\"1\":{\"634\":1}}],[\"id的当前值\",{\"1\":{\"634\":1}}],[\"id的事务分到多个worker执行\",{\"1\":{\"601\":1}}],[\"id的值就是1289\",{\"1\":{\"634\":1}}],[\"id的值就变成随机的\",{\"1\":{\"541\":1}}],[\"id的值其实就是0\",{\"1\":{\"634\":1}}],[\"id的值加1\",{\"1\":{\"632\":1}}],[\"id的值作为要插入数据的row\",{\"1\":{\"632\":1}}],[\"id的值\",{\"1\":{\"541\":1,\"632\":1}}],[\"id的序号会递增\",{\"1\":{\"467\":1}}],[\"idata\",{\"1\":{\"537\":3,\"541\":3,\"551\":2,\"556\":2}}],[\"id上使用了ref访问类型来执行查询\",{\"1\":{\"527\":1}}],[\"id`\",{\"1\":{\"498\":12,\"500\":1,\"643\":7}}],[\"id2\",{\"1\":{\"482\":1}}],[\"id1\",{\"1\":{\"482\":1}}],[\"id5这两条记录回表取数据判断\",{\"1\":{\"477\":1}}],[\"id主键索引\",{\"1\":{\"467\":1}}],[\"id相等的时候顺序执行\",{\"1\":{\"467\":1}}],[\"id相同的情况\",{\"1\":{\"634\":1}}],[\"id相同的新的binlog\",{\"1\":{\"592\":1}}],[\"id相同不同\",{\"1\":{\"467\":1}}],[\"id相同\",{\"1\":{\"467\":1}}],[\"id是使用中最常见的\",{\"1\":{\"636\":1}}],[\"id是1289\",{\"1\":{\"634\":1}}],[\"id是两个容易混淆的概念\",{\"1\":{\"634\":1}}],[\"id是从0开始到248\",{\"1\":{\"632\":1}}],[\"id是一个很大的数\",{\"1\":{\"634\":1}}],[\"id是一个纯内存变量\",{\"1\":{\"633\":1}}],[\"id是一个长度为8字节的无符号长整型\",{\"1\":{\"632\":1}}],[\"id是一个整数\",{\"1\":{\"605\":1}}],[\"id是一个实例第一次启动时自动生成的\",{\"1\":{\"605\":1}}],[\"id是bigint类型\",{\"1\":{\"467\":1}}],[\"id是逐渐\",{\"1\":{\"463\":1}}],[\"id是否可以重复\",{\"0\":{\"198\":1}}],[\"id字段没有索引\",{\"1\":{\"459\":1}}],[\"id\",{\"0\":{\"632\":1,\"634\":1,\"635\":1,\"1796\":1},\"1\":{\"457\":1,\"458\":1,\"460\":1,\"466\":2,\"467\":11,\"469\":2,\"472\":3,\"473\":1,\"475\":1,\"478\":1,\"479\":1,\"482\":1,\"486\":1,\"488\":2,\"489\":6,\"491\":2,\"498\":13,\"503\":2,\"505\":2,\"508\":2,\"521\":2,\"527\":10,\"531\":6,\"537\":1,\"541\":1,\"544\":1,\"549\":3,\"550\":3,\"551\":3,\"553\":3,\"554\":1,\"555\":1,\"559\":5,\"568\":3,\"584\":1,\"591\":1,\"592\":4,\"599\":1,\"601\":1,\"604\":1,\"605\":9,\"613\":2,\"615\":2,\"618\":1,\"621\":1,\"627\":2,\"631\":1,\"632\":3,\"633\":2,\"634\":9,\"635\":7,\"636\":1,\"646\":5,\"651\":1,\"656\":1,\"659\":4,\"662\":4,\"663\":1,\"672\":1,\"673\":2,\"675\":1,\"679\":4,\"686\":1,\"690\":2,\"692\":3,\"1361\":1,\"1375\":2,\"1485\":1,\"1486\":1,\"1495\":7}}],[\"id=bbeb46c842c84cfcdbf1d1f040fe40c7\",{\"1\":{\"800\":1}}],[\"id=b36b975188fadf7bfbfd75c0d2d6b834\",{\"1\":{\"677\":1}}],[\"id=ca746f44f16b862e3189e5f24b3a8e64\",{\"1\":{\"796\":1}}],[\"id=df15aba3aa76c225090d04d0dc776dd9\",{\"1\":{\"654\":1}}],[\"id=d2e8a0ae8c9dc2a45c799b771a5899f6\",{\"1\":{\"654\":1}}],[\"id=n的行\",{\"1\":{\"632\":1}}],[\"id=n后\",{\"1\":{\"632\":1}}],[\"id=35faf7c95e69943cdbff4642fcfd5318\",{\"1\":{\"1540\":1}}],[\"id=354ae85f3519bac0581919a458278a59\",{\"1\":{\"668\":1}}],[\"id=3\",{\"1\":{\"605\":1}}],[\"id=0这一行的问题解决了\",{\"1\":{\"584\":1}}],[\"id=0这一行的最终结果也是\",{\"1\":{\"584\":1}}],[\"id=0这一行变成\",{\"1\":{\"584\":1}}],[\"id=0和id=1这两行\",{\"1\":{\"584\":1}}],[\"id=0\",{\"1\":{\"584\":4}}],[\"id=5这一行变成\",{\"1\":{\"584\":1}}],[\"id=248时\",{\"1\":{\"632\":1}}],[\"id=2\",{\"1\":{\"460\":1,\"505\":1}}],[\"id=12这个线程的command列显示的是killed\",{\"1\":{\"618\":1}}],[\"id=1的这个库上执行的\",{\"1\":{\"591\":1}}],[\"id=1这一行还不存在\",{\"1\":{\"584\":1}}],[\"id=1这一行\",{\"1\":{\"584\":1}}],[\"id=1\",{\"1\":{\"584\":2}}],[\"id=1和id=5的这三行\",{\"1\":{\"583\":1}}],[\"id=10\",{\"1\":{\"454\":1,\"456\":1,\"459\":1}}],[\"id=16ca3fcfcdda46a976cfd978e20df4be\",{\"1\":{\"449\":1}}],[\"id=924a9d435d78784455143b1dda4a874a\",{\"1\":{\"446\":1}}],[\"idx\",{\"1\":{\"389\":2,\"467\":4,\"498\":3,\"499\":2,\"500\":2,\"515\":1,\"527\":3,\"656\":2,\"684\":1,\"686\":3,\"688\":1,\"690\":4,\"692\":6,\"695\":3}}],[\"idle\",{\"1\":{\"1567\":1}}],[\"idl\",{\"1\":{\"280\":1}}],[\"it是spliterator中定义的迭代器\",{\"1\":{\"1499\":1}}],[\"itself\",{\"1\":{\"1500\":1,\"1524\":1,\"1525\":1}}],[\"its\",{\"1\":{\"1475\":10,\"1478\":2,\"1495\":2,\"1497\":9,\"1498\":1,\"1500\":2,\"1524\":1}}],[\"itrs\",{\"1\":{\"1379\":2}}],[\"iterative\",{\"1\":{\"1486\":1}}],[\"iteration\",{\"1\":{\"1472\":4,\"1497\":1}}],[\"iterate\",{\"1\":{\"1486\":2,\"1487\":6}}],[\"iteratorspliterator是实现了spliterator接口的一个实现类\",{\"1\":{\"1498\":1}}],[\"iteratorspliterator<>\",{\"1\":{\"1498\":1}}],[\"iterators\",{\"1\":{\"1497\":1}}],[\"iterator<\",{\"1\":{\"1499\":1}}],[\"iterator<map\",{\"1\":{\"1495\":1}}],[\"iterator<t>\",{\"1\":{\"1486\":2,\"1496\":1}}],[\"iterator<selectionkey>\",{\"1\":{\"1451\":2}}],[\"iterator\",{\"1\":{\"381\":1,\"806\":2,\"1451\":5,\"1486\":2,\"1495\":2,\"1496\":2,\"1497\":3,\"1499\":1,\"1525\":2}}],[\"iterable\",{\"1\":{\"1451\":3,\"1472\":2}}],[\"item1\",{\"1\":{\"1491\":6}}],[\"item2\",{\"1\":{\"1486\":2,\"1491\":6}}],[\"item\",{\"1\":{\"656\":1,\"806\":1,\"1380\":4,\"1470\":2,\"1471\":2,\"1472\":2,\"1474\":2,\"1476\":28,\"1485\":2,\"1486\":14,\"1487\":39,\"1489\":3,\"1491\":4,\"1494\":9,\"1499\":2}}],[\"items\",{\"1\":{\"568\":1,\"656\":2,\"1379\":11}}],[\"it\",{\"1\":{\"2\":1,\"3\":1,\"1474\":1,\"1475\":6,\"1492\":3,\"1494\":2,\"1495\":1,\"1496\":7,\"1497\":7,\"1498\":2,\"1499\":3,\"1500\":12,\"1524\":3,\"1532\":2,\"1567\":2}}],[\"inject\",{\"1\":{\"1525\":1}}],[\"injectionpoint\",{\"1\":{\"1525\":2}}],[\"injectionmetadata\",{\"1\":{\"1525\":5}}],[\"injection\",{\"1\":{\"1524\":1,\"1525\":1}}],[\"injectedelement>\",{\"1\":{\"1525\":2}}],[\"injected\",{\"1\":{\"1524\":1}}],[\"inject和\",{\"0\":{\"1126\":1}}],[\"in表示上游流源的元素类型\",{\"1\":{\"1498\":1}}],[\"in>\",{\"1\":{\"1498\":2,\"1500\":20}}],[\"inaccurate\",{\"1\":{\"1497\":1}}],[\"inability\",{\"1\":{\"1497\":1}}],[\"inarea\",{\"1\":{\"435\":6}}],[\"inherited\",{\"1\":{\"1524\":1}}],[\"inherits\",{\"1\":{\"1497\":1}}],[\"inherent\",{\"1\":{\"1497\":1}}],[\"inexpensive\",{\"1\":{\"1497\":1}}],[\"inexact\",{\"1\":{\"1497\":1}}],[\"inefficient\",{\"1\":{\"1497\":2}}],[\"inetsocketaddress\",{\"1\":{\"1410\":1,\"1411\":1,\"1451\":2,\"1452\":2}}],[\"invalid\",{\"1\":{\"1524\":1}}],[\"involved\",{\"1\":{\"1497\":1}}],[\"invoking\",{\"1\":{\"1496\":1}}],[\"invokewithintransaction\",{\"1\":{\"1532\":2}}],[\"invokebeanfactorypostprocessors\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"invokesuspendingfunction\",{\"1\":{\"1532\":1}}],[\"invokesuper\",{\"1\":{\"1531\":1}}],[\"invokes\",{\"1\":{\"1497\":1}}],[\"invoke\",{\"1\":{\"1492\":1,\"1497\":1,\"1500\":2,\"1524\":1,\"1531\":3,\"1540\":1}}],[\"invoked\",{\"1\":{\"1477\":2,\"1494\":49,\"1496\":4}}],[\"invocationcallback\",{\"1\":{\"1532\":2}}],[\"invocationhandler\",{\"1\":{\"1531\":1}}],[\"invocation\",{\"1\":{\"1492\":1,\"1497\":2,\"1532\":7}}],[\"invocations\",{\"1\":{\"1492\":1,\"1497\":2}}],[\"inverttree\",{\"1\":{\"405\":3}}],[\"independent\",{\"1\":{\"1500\":1}}],[\"indexfor\",{\"1\":{\"1425\":1}}],[\"index是long类型\",{\"1\":{\"1396\":1}}],[\"index语句展示出的cardinality属性\",{\"1\":{\"690\":1}}],[\"index语句展示出来的某个索引列的cardinality属性是一个估计值\",{\"1\":{\"690\":1}}],[\"indexes\",{\"1\":{\"656\":2}}],[\"index文件\",{\"1\":{\"622\":1}}],[\"index指定的索引在候选索引列表中\",{\"1\":{\"485\":1}}],[\"index强行选择一个索引\",{\"1\":{\"485\":1}}],[\"index方法\",{\"1\":{\"484\":1}}],[\"index的时候\",{\"1\":{\"483\":1}}],[\"index和all的区别为index类型只遍历索引树\",{\"1\":{\"467\":1}}],[\"indexof\",{\"1\":{\"389\":1}}],[\"index2\",{\"1\":{\"377\":4,\"487\":1}}],[\"index1\",{\"1\":{\"377\":5,\"487\":1}}],[\"index++\",{\"1\":{\"365\":1,\"388\":3}}],[\"index\",{\"0\":{\"538\":1,\"690\":1},\"1\":{\"4\":1,\"362\":4,\"365\":3,\"388\":7,\"400\":5,\"446\":1,\"449\":1,\"467\":8,\"472\":3,\"473\":1,\"477\":1,\"483\":3,\"485\":1,\"487\":2,\"489\":1,\"493\":3,\"498\":2,\"499\":2,\"500\":2,\"503\":1,\"515\":1,\"527\":1,\"538\":1,\"541\":1,\"544\":1,\"546\":1,\"551\":2,\"553\":1,\"554\":1,\"568\":1,\"646\":1,\"654\":1,\"656\":13,\"690\":10,\"692\":2,\"695\":8,\"696\":3,\"708\":2,\"796\":1,\"800\":1,\"1356\":1,\"1430\":3}}],[\"individual\",{\"1\":{\"1498\":1}}],[\"individually\",{\"1\":{\"1497\":1}}],[\"indicating\",{\"1\":{\"1492\":1}}],[\"indicatesmultiplebeans\",{\"1\":{\"1525\":2}}],[\"indicates\",{\"1\":{\"1494\":3}}],[\"indicate\",{\"1\":{\"1471\":2,\"1532\":1}}],[\"inline\",{\"1\":{\"1356\":2}}],[\"infinite\",{\"1\":{\"1486\":1,\"1497\":2}}],[\"inf\",{\"1\":{\"711\":1,\"1535\":1}}],[\"informing\",{\"1\":{\"1500\":1}}],[\"inform\",{\"1\":{\"1500\":1}}],[\"informative\",{\"1\":{\"1471\":2}}],[\"information\",{\"1\":{\"571\":1,\"656\":2,\"657\":6,\"675\":3,\"681\":1,\"1492\":1,\"1500\":4}}],[\"info\",{\"1\":{\"690\":2,\"692\":3,\"746\":2,\"1525\":3}}],[\"info`\",{\"1\":{\"505\":1}}],[\"initapplicationexception\",{\"1\":{\"1532\":1}}],[\"initapplicationeventmulticaster\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"initparameternamediscovery\",{\"1\":{\"1525\":1}}],[\"initmessagesource\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"initmethodname\",{\"1\":{\"1509\":1}}],[\"initiation\",{\"1\":{\"1497\":1}}],[\"initiated\",{\"1\":{\"1496\":1}}],[\"initial\",{\"1\":{\"1427\":5,\"1486\":1,\"1496\":1,\"1498\":3,\"1500\":4}}],[\"initialization\",{\"1\":{\"1357\":1,\"1431\":1,\"1524\":2,\"1528\":1}}],[\"initializebean\",{\"1\":{\"1524\":1}}],[\"initialized\",{\"1\":{\"1524\":1}}],[\"initializes\",{\"1\":{\"1431\":1}}],[\"initialize\",{\"1\":{\"392\":1,\"1524\":5}}],[\"inittable方法具体如下\",{\"1\":{\"1431\":1}}],[\"inittable\",{\"1\":{\"1431\":2}}],[\"inited=true\",{\"1\":{\"1408\":1}}],[\"inited\",{\"1\":{\"1408\":2}}],[\"init\",{\"1\":{\"568\":1,\"1408\":1,\"1524\":1}}],[\"inconsistent\",{\"1\":{\"1497\":1}}],[\"incorporate\",{\"1\":{\"1500\":1}}],[\"incorporated\",{\"1\":{\"1485\":2}}],[\"incorporating\",{\"1\":{\"1485\":2,\"1492\":1}}],[\"including\",{\"1\":{\"1497\":1,\"1500\":1}}],[\"includefilters\",{\"1\":{\"1522\":1,\"1524\":1}}],[\"includefilter表示包含过滤器\",{\"1\":{\"1522\":1}}],[\"include\",{\"1\":{\"566\":1,\"1492\":1,\"1500\":1}}],[\"increases\",{\"1\":{\"1497\":2}}],[\"increment没有改变\",{\"1\":{\"631\":1}}],[\"increment是两个系统参数\",{\"1\":{\"628\":1}}],[\"increment为步长\",{\"1\":{\"628\":1}}],[\"increment值填到自增字段\",{\"1\":{\"628\":1}}],[\"increment的值\",{\"1\":{\"627\":1}}],[\"increment就会变成10\",{\"1\":{\"627\":1}}],[\"increment还是11\",{\"1\":{\"627\":1}}],[\"increment=1\",{\"1\":{\"655\":1}}],[\"increment=11\",{\"1\":{\"627\":1}}],[\"increment=4\",{\"1\":{\"647\":1}}],[\"increment=4294967295\",{\"1\":{\"631\":2}}],[\"increment=2\",{\"1\":{\"627\":1,\"628\":1}}],[\"increment\",{\"1\":{\"467\":1,\"472\":1,\"498\":1,\"499\":2,\"500\":1,\"515\":1,\"556\":1,\"596\":1,\"626\":1,\"628\":6,\"631\":2,\"643\":1,\"647\":1,\"655\":1,\"660\":1,\"665\":1,\"671\":1,\"672\":1,\"1359\":3,\"1540\":1}}],[\"incrbyfloat\",{\"1\":{\"707\":2}}],[\"incrby\",{\"1\":{\"707\":2,\"718\":3}}],[\"incr\",{\"1\":{\"707\":2,\"717\":1}}],[\"innativeimage\",{\"1\":{\"1528\":1}}],[\"innod\",{\"1\":{\"616\":1}}],[\"innodb默认是以表为单位来收集和存储统计数据的\",{\"1\":{\"695\":1,\"696\":1}}],[\"innodb默认会选择n个数据页\",{\"1\":{\"484\":1}}],[\"innodb统计一个表中有多少行记录是这样的\",{\"1\":{\"695\":1}}],[\"innodb提供了两种存储统计数据的方式\",{\"1\":{\"695\":1}}],[\"innodb提供了innodb\",{\"1\":{\"588\":1}}],[\"innodb中的统计数据\",{\"0\":{\"695\":1}}],[\"innodb存储引擎都是将数据和索引都存储到磁盘上的\",{\"1\":{\"682\":1}}],[\"innodb下的当前读和快照读\",{\"1\":{\"678\":1}}],[\"innodb索引实现\",{\"1\":{\"642\":1}}],[\"innodb才真正分配了trx\",{\"1\":{\"634\":1}}],[\"innodb并不会分配trx\",{\"1\":{\"634\":1}}],[\"innodb并不会去看age的值\",{\"1\":{\"477\":1}}],[\"innodb数据可见性的核心思想是\",{\"1\":{\"634\":1}}],[\"innodb内部维护了一个max\",{\"1\":{\"634\":1}}],[\"innodb内部使用xid\",{\"1\":{\"634\":1}}],[\"innodb自己的trx\",{\"1\":{\"634\":1}}],[\"innodb维护了一个全局的dict\",{\"1\":{\"632\":1}}],[\"innodb系统自增row\",{\"0\":{\"632\":1}}],[\"innodb放弃了这个设计\",{\"1\":{\"628\":1}}],[\"innodb发现用户没有指定自增id的值\",{\"1\":{\"628\":1}}],[\"innodb就只需要拷贝读写事务的trx\",{\"1\":{\"634\":1}}],[\"innodb就会认为线程数用满了\",{\"1\":{\"613\":1}}],[\"innodb就认为redo\",{\"1\":{\"588\":1}}],[\"innodb就可以保证即使数据库发生异常重启\",{\"1\":{\"461\":1}}],[\"innodb有一个后台线程\",{\"1\":{\"588\":1}}],[\"innodb给每个索引加上了一个不存在得最大值supremum\",{\"1\":{\"585\":1}}],[\"innodb引入了间隙锁\",{\"1\":{\"585\":1}}],[\"innodb引擎的自增值\",{\"1\":{\"627\":1}}],[\"innodb引擎引入了本地分区策略\",{\"1\":{\"562\":1}}],[\"innodb引擎遍历整张表\",{\"1\":{\"536\":1}}],[\"innodb引擎会自动选择所有数据都不相等的列\",{\"1\":{\"642\":1}}],[\"innodb引擎会遍历整张表\",{\"1\":{\"536\":1}}],[\"innodb引擎会在适当的时候\",{\"1\":{\"461\":1}}],[\"innodb引擎在执行count\",{\"1\":{\"533\":1}}],[\"innodb引擎就会先把记录写到redo\",{\"1\":{\"461\":1}}],[\"innodb是索引组织表\",{\"1\":{\"533\":1}}],[\"innodb对这个语句也做个一定程度的优化\",{\"1\":{\"533\":1}}],[\"innodb只好把数据一行一行地读出依次判断\",{\"1\":{\"533\":1}}],[\"innodb表\",{\"1\":{\"533\":1}}],[\"innodb会先排好name\",{\"1\":{\"642\":1}}],[\"innodb会把数据从临时表取出来\",{\"1\":{\"491\":1}}],[\"innodb会将这些更新操作缓存在change\",{\"1\":{\"480\":1}}],[\"innodb的主键索引\",{\"1\":{\"655\":1}}],[\"innodb的max\",{\"1\":{\"636\":1}}],[\"innodb的处理流程如下\",{\"1\":{\"480\":1}}],[\"innodb的处理流程\",{\"1\":{\"480\":1}}],[\"innodb的数据是按数据页为到位来读写的\",{\"1\":{\"479\":1}}],[\"innodb的redo\",{\"1\":{\"461\":1}}],[\"innodb在执行查询语句select时\",{\"1\":{\"672\":1}}],[\"innodb在设计时\",{\"1\":{\"632\":1}}],[\"innodb在接收到新请求的时候\",{\"1\":{\"613\":1}}],[\"innodb在普通索引a上查到主键id的值后\",{\"1\":{\"541\":1}}],[\"innodb在\",{\"1\":{\"477\":1}}],[\"innodb\",{\"0\":{\"634\":1},\"1\":{\"472\":1,\"473\":1,\"475\":1,\"482\":1,\"483\":1,\"486\":1,\"490\":1,\"491\":5,\"503\":1,\"505\":1,\"537\":1,\"556\":1,\"561\":6,\"570\":1,\"571\":1,\"581\":1,\"583\":1,\"591\":1,\"596\":1,\"599\":1,\"605\":1,\"613\":4,\"615\":1,\"616\":5,\"618\":1,\"626\":1,\"634\":1,\"640\":1,\"643\":3,\"674\":1,\"675\":12,\"695\":10,\"696\":2}}],[\"inner\",{\"1\":{\"521\":2,\"659\":1,\"661\":1,\"662\":1,\"691\":5,\"692\":2,\"1524\":1}}],[\"ing\",{\"1\":{\"512\":2}}],[\"inputshape\",{\"1\":{\"1499\":2,\"1500\":2}}],[\"inputstreamreader\",{\"1\":{\"1450\":2}}],[\"input\",{\"1\":{\"489\":1,\"1450\":2,\"1474\":4,\"1475\":16,\"1476\":6,\"1478\":2,\"1490\":2,\"1492\":8,\"1494\":1,\"1495\":5,\"1498\":1,\"1500\":6}}],[\"in等的查询\",{\"1\":{\"467\":1}}],[\"inorder\",{\"1\":{\"395\":4,\"397\":3}}],[\"inordertraversal3\",{\"1\":{\"395\":1}}],[\"inordertraversal\",{\"1\":{\"395\":2}}],[\"insensitive\",{\"1\":{\"1491\":2}}],[\"insert语句要插入10万行数据\",{\"1\":{\"629\":1}}],[\"insert语句对应的writeset就要多增加一个哈希值\",{\"1\":{\"602\":1}}],[\"insert语句的binlog会记录所有的字段信息\",{\"1\":{\"591\":1}}],[\"insert和update这三种sql语句的角度\",{\"1\":{\"591\":1}}],[\"insert\",{\"1\":{\"473\":1,\"482\":1,\"498\":5,\"505\":15,\"515\":5,\"537\":2,\"541\":2,\"544\":1,\"546\":1,\"550\":2,\"551\":1,\"556\":1,\"561\":1,\"570\":1,\"579\":1,\"583\":1,\"584\":2,\"591\":6,\"596\":4,\"599\":1,\"605\":2,\"613\":1,\"615\":1,\"621\":2,\"628\":4,\"629\":2,\"631\":2,\"635\":1,\"643\":3,\"647\":3,\"655\":7,\"660\":8,\"671\":4,\"672\":6,\"678\":1,\"681\":1,\"684\":2,\"690\":3,\"692\":2}}],[\"insertiontemplate\",{\"1\":{\"319\":1}}],[\"ins\",{\"1\":{\"708\":3}}],[\"instantiationstrategy\",{\"1\":{\"1528\":2}}],[\"instantiationaware\",{\"1\":{\"1524\":2}}],[\"instantiationawarebeanpostprocessors\",{\"1\":{\"1524\":1}}],[\"instantiationawarebeanpostprocessor\",{\"1\":{\"1524\":5}}],[\"instantiation\",{\"1\":{\"1524\":1}}],[\"instantiatebean\",{\"1\":{\"1527\":2}}],[\"instantiateusingfactorymethod\",{\"1\":{\"1527\":1}}],[\"instantiate\",{\"1\":{\"1524\":3}}],[\"instancecomparator<>\",{\"1\":{\"1531\":1}}],[\"instancecandidate\",{\"1\":{\"1525\":7}}],[\"instancewrapper\",{\"1\":{\"1524\":7}}],[\"instancesupplier\",{\"1\":{\"1527\":3}}],[\"instances\",{\"1\":{\"1471\":2,\"1496\":2,\"1497\":1,\"1500\":1}}],[\"instance\",{\"1\":{\"566\":1,\"1361\":1,\"1497\":4,\"1498\":1,\"1500\":3,\"1524\":11,\"1531\":1}}],[\"instanceof\",{\"1\":{\"302\":1,\"1426\":1,\"1427\":1,\"1431\":1,\"1497\":2,\"1524\":10,\"1525\":6,\"1531\":3,\"1532\":4}}],[\"instruments\",{\"1\":{\"616\":1}}],[\"instead\",{\"1\":{\"566\":1,\"1496\":1,\"1497\":1,\"1524\":1}}],[\"intfunction\",{\"1\":{\"1500\":1}}],[\"intpipeline\",{\"1\":{\"1498\":2}}],[\"intconsumer和consumer类型并没有直接继承的关系\",{\"1\":{\"1497\":1}}],[\"intconsumer\",{\"1\":{\"1497\":28}}],[\"introspection\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"introductionadvisor\",{\"1\":{\"1531\":3}}],[\"introductionawaremethodmatcher\",{\"1\":{\"1531\":2}}],[\"introduction\",{\"0\":{\"988\":1}}],[\"intrinsic\",{\"1\":{\"1494\":1}}],[\"ints\",{\"1\":{\"1500\":4}}],[\"intsummarystatistics\",{\"1\":{\"1487\":5}}],[\"intsupplier等等\",{\"1\":{\"1478\":1}}],[\"intstream\",{\"1\":{\"1484\":7,\"1487\":2,\"1496\":2}}],[\"intx\",{\"1\":{\"1362\":2}}],[\"int或integer\",{\"1\":{\"665\":1}}],[\"intoset\",{\"1\":{\"1492\":1}}],[\"intorductionadvisor接口\",{\"0\":{\"956\":1}}],[\"into`test`\",{\"1\":{\"671\":4}}],[\"into\",{\"1\":{\"473\":1,\"482\":1,\"491\":2,\"498\":5,\"505\":15,\"515\":5,\"537\":2,\"541\":2,\"544\":1,\"546\":1,\"550\":4,\"551\":1,\"556\":1,\"559\":3,\"561\":1,\"570\":1,\"583\":1,\"584\":2,\"591\":6,\"596\":4,\"599\":1,\"605\":2,\"613\":1,\"615\":1,\"627\":1,\"628\":4,\"629\":1,\"631\":2,\"643\":3,\"647\":3,\"655\":4,\"660\":2,\"672\":3,\"1485\":4,\"1492\":11,\"1493\":4,\"1495\":2,\"1496\":3,\"1498\":2,\"1500\":5,\"1524\":1}}],[\"int\",{\"1\":{\"285\":1,\"302\":5,\"305\":6,\"311\":6,\"317\":4,\"318\":5,\"319\":8,\"329\":14,\"338\":2,\"359\":6,\"360\":6,\"361\":9,\"362\":10,\"363\":6,\"364\":10,\"365\":4,\"366\":8,\"367\":7,\"368\":12,\"371\":1,\"375\":2,\"380\":1,\"381\":7,\"383\":1,\"384\":5,\"385\":8,\"386\":2,\"388\":3,\"389\":1,\"392\":3,\"393\":10,\"396\":4,\"399\":4,\"400\":1,\"401\":2,\"402\":2,\"403\":3,\"404\":1,\"407\":1,\"408\":3,\"410\":7,\"411\":8,\"412\":1,\"415\":4,\"417\":12,\"419\":5,\"421\":3,\"422\":5,\"424\":11,\"425\":9,\"426\":8,\"427\":7,\"428\":7,\"429\":14,\"430\":10,\"431\":12,\"435\":20,\"437\":4,\"438\":2,\"439\":5,\"440\":4,\"441\":3,\"443\":8,\"460\":2,\"467\":3,\"472\":2,\"473\":2,\"475\":2,\"483\":3,\"489\":1,\"490\":2,\"498\":5,\"499\":4,\"500\":2,\"503\":2,\"504\":1,\"505\":2,\"515\":1,\"537\":4,\"541\":4,\"544\":3,\"549\":1,\"550\":2,\"551\":4,\"554\":1,\"556\":2,\"561\":1,\"570\":1,\"583\":3,\"591\":2,\"596\":2,\"599\":3,\"605\":2,\"613\":2,\"615\":1,\"626\":3,\"630\":1,\"631\":2,\"643\":5,\"647\":2,\"655\":3,\"660\":5,\"671\":1,\"672\":2,\"704\":3,\"806\":9,\"1352\":3,\"1353\":4,\"1356\":12,\"1357\":2,\"1359\":1,\"1362\":1,\"1364\":1,\"1367\":1,\"1379\":5,\"1380\":4,\"1383\":3,\"1387\":1,\"1394\":2,\"1397\":1,\"1398\":1,\"1403\":4,\"1423\":6,\"1425\":5,\"1426\":3,\"1427\":9,\"1430\":5,\"1431\":10,\"1446\":2,\"1447\":4,\"1450\":4,\"1451\":4,\"1452\":2,\"1468\":2,\"1470\":1,\"1475\":29,\"1477\":3,\"1480\":6,\"1481\":2,\"1482\":8,\"1484\":6,\"1487\":1,\"1488\":1,\"1489\":2,\"1490\":12,\"1491\":7,\"1493\":1,\"1494\":1,\"1495\":2,\"1496\":2,\"1497\":22,\"1498\":8,\"1499\":4,\"1500\":4,\"1511\":1,\"1524\":1,\"1531\":1}}],[\"integral\",{\"1\":{\"1500\":1}}],[\"integer和double等基础类型的包装类都具备不可变性\",{\"1\":{\"1403\":1}}],[\"integers\",{\"1\":{\"366\":2}}],[\"integer\",{\"1\":{\"363\":3,\"388\":5,\"392\":1,\"404\":2,\"409\":1,\"411\":1,\"704\":3,\"706\":9,\"707\":10,\"708\":10,\"709\":7,\"710\":11,\"711\":16,\"714\":5,\"715\":8,\"717\":1,\"718\":3,\"735\":3,\"806\":8,\"1378\":1,\"1380\":1,\"1394\":2,\"1427\":3,\"1452\":3,\"1475\":2,\"1476\":20,\"1484\":1,\"1491\":1,\"1495\":1,\"1497\":3}}],[\"integer>>\",{\"1\":{\"1492\":1}}],[\"integer>\",{\"1\":{\"311\":2,\"359\":1,\"381\":2,\"387\":1,\"1475\":9,\"1492\":1,\"1493\":1,\"1495\":1,\"1497\":2}}],[\"integer的缓存机制\",{\"0\":{\"19\":1}}],[\"intended\",{\"1\":{\"1471\":2,\"1498\":1}}],[\"intension\",{\"1\":{\"579\":1}}],[\"intel使用缓存锁定来保证指令执行的原子性\",{\"1\":{\"1350\":1}}],[\"interceptoranddynamicmethodmatcher\",{\"1\":{\"1531\":1}}],[\"interceptor\",{\"1\":{\"1531\":4}}],[\"interceptors\",{\"1\":{\"1531\":7}}],[\"interceptors只会有一个元素\",{\"1\":{\"1531\":1}}],[\"interceptorlist\",{\"1\":{\"1531\":6}}],[\"intercept\",{\"1\":{\"1524\":1,\"1531\":1}}],[\"internal\",{\"1\":{\"1524\":1}}],[\"intermediate\",{\"1\":{\"1492\":1,\"1495\":3,\"1496\":2,\"1498\":7,\"1499\":3,\"1500\":6}}],[\"interoperability\",{\"1\":{\"1491\":1}}],[\"interfered\",{\"1\":{\"1497\":2}}],[\"interference获取更多信息\",{\"1\":{\"1498\":1}}],[\"interference\",{\"1\":{\"1497\":11,\"1498\":2}}],[\"interfering\",{\"1\":{\"1485\":2,\"1496\":1}}],[\"interfering<\",{\"1\":{\"1485\":2}}],[\"interfacetestb\",{\"1\":{\"1472\":5}}],[\"interfacetesta\",{\"1\":{\"1472\":5}}],[\"interfaces\",{\"1\":{\"1471\":3,\"1474\":2,\"1524\":1}}],[\"interface<\",{\"1\":{\"1471\":2,\"1474\":1,\"1475\":3,\"1476\":2,\"1477\":1,\"1478\":1}}],[\"interface\",{\"1\":{\"1377\":1,\"1470\":1,\"1471\":33,\"1472\":6,\"1474\":2,\"1475\":2,\"1476\":1,\"1477\":1,\"1478\":2,\"1480\":1,\"1484\":2,\"1485\":1,\"1486\":1,\"1491\":1,\"1496\":4,\"1497\":2,\"1498\":1,\"1500\":2}}],[\"interruptedexception\",{\"1\":{\"1364\":1,\"1379\":2,\"1380\":2,\"1412\":2}}],[\"interrupted和isinterrupted方法的区别\",{\"0\":{\"62\":1}}],[\"interrupt\",{\"1\":{\"1354\":1}}],[\"intersect\",{\"1\":{\"656\":2}}],[\"interval\",{\"1\":{\"530\":2}}],[\"in\",{\"0\":{\"281\":1,\"771\":1},\"1\":{\"1\":2,\"2\":1,\"326\":2,\"339\":1,\"457\":1,\"466\":1,\"467\":6,\"482\":1,\"498\":1,\"508\":2,\"512\":8,\"531\":1,\"565\":3,\"568\":4,\"591\":1,\"641\":1,\"656\":1,\"657\":1,\"662\":1,\"674\":1,\"678\":1,\"681\":1,\"684\":2,\"686\":2,\"690\":5,\"691\":2,\"740\":2,\"806\":1,\"1427\":1,\"1430\":1,\"1431\":1,\"1450\":1,\"1451\":3,\"1452\":3,\"1472\":2,\"1474\":2,\"1485\":4,\"1486\":1,\"1487\":1,\"1490\":1,\"1492\":8,\"1494\":2,\"1495\":2,\"1496\":12,\"1497\":33,\"1498\":7,\"1499\":6,\"1500\":15,\"1524\":13,\"1525\":2,\"1528\":1,\"1532\":3,\"1540\":1}}],[\"isn\",{\"1\":{\"1527\":1}}],[\"isnonpublicaccessallowed\",{\"1\":{\"1527\":1}}],[\"isnull是一个静态方法的方法引用\",{\"1\":{\"1476\":1}}],[\"isnull\",{\"1\":{\"1471\":1,\"1476\":3}}],[\"istypematch\",{\"1\":{\"1525\":1}}],[\"istraceenabled\",{\"1\":{\"1524\":2}}],[\"isvavrtry\",{\"1\":{\"1532\":2}}],[\"isvalidbst\",{\"1\":{\"397\":1}}],[\"isvalid\",{\"1\":{\"386\":2,\"1451\":2}}],[\"isvisibilitybridgemethodpair\",{\"1\":{\"1525\":1}}],[\"isfactorybean\",{\"1\":{\"1524\":1}}],[\"islazyinit\",{\"1\":{\"1524\":1}}],[\"islocked判断\",{\"1\":{\"1372\":1}}],[\"isinstance\",{\"1\":{\"1525\":1}}],[\"isinfoenabled\",{\"1\":{\"1525\":3}}],[\"isindependent\",{\"1\":{\"1524\":1}}],[\"isinterrupted\",{\"1\":{\"1354\":1}}],[\"iscandidateclass\",{\"1\":{\"1525\":1}}],[\"iscandidatecomponent\",{\"1\":{\"1524\":4}}],[\"iscachebeanmetadata\",{\"1\":{\"1524\":1}}],[\"isconcrete\",{\"1\":{\"1524\":1}}],[\"isconditionmatch\",{\"1\":{\"1524\":1}}],[\"isconnectable\",{\"1\":{\"1451\":1}}],[\"iswarnenabled\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"isknown\",{\"1\":{\"1500\":1}}],[\"isordered\",{\"1\":{\"1494\":1}}],[\"isolated\",{\"1\":{\"1492\":1}}],[\"isolation=\",{\"1\":{\"669\":1}}],[\"isolation的值设置为read\",{\"1\":{\"570\":1}}],[\"isolation\",{\"1\":{\"569\":1,\"570\":1,\"669\":1,\"1492\":1}}],[\"isprefiltered\",{\"1\":{\"1531\":2}}],[\"isprototype\",{\"1\":{\"1524\":1}}],[\"isprototypecurrentlyincreation\",{\"1\":{\"1524\":1}}],[\"ispublic\",{\"1\":{\"1527\":1}}],[\"isparallel\",{\"1\":{\"1494\":1,\"1496\":2,\"1498\":2,\"1499\":1,\"1500\":1}}],[\"isperfectsquare\",{\"1\":{\"440\":1}}],[\"isdependent\",{\"1\":{\"1524\":1}}],[\"isdefault\",{\"1\":{\"1471\":2}}],[\"isdynamic\",{\"1\":{\"806\":3}}],[\"isruntime\",{\"1\":{\"1531\":1}}],[\"isrunning\",{\"1\":{\"1353\":2}}],[\"isrequired\",{\"1\":{\"1525\":3}}],[\"isreadable\",{\"1\":{\"1451\":2}}],[\"isasyncsupported\",{\"1\":{\"1535\":1}}],[\"isassignablefrom\",{\"1\":{\"1525\":1}}],[\"isassignablevalue\",{\"1\":{\"1525\":1}}],[\"isautowirecandidate方法的作用是用来判断给定的bean是否可以用来依赖注入\",{\"1\":{\"1525\":1}}],[\"isautowirecandidate\",{\"1\":{\"1525\":8}}],[\"isabstract\",{\"1\":{\"1524\":2}}],[\"isacceptable\",{\"1\":{\"1451\":1}}],[\"isanagram\",{\"1\":{\"387\":2}}],[\"isub\",{\"1\":{\"1359\":1}}],[\"issuspendingfunction\",{\"1\":{\"1532\":6}}],[\"issue\",{\"1\":{\"806\":1}}],[\"isselfreference\",{\"1\":{\"1525\":3}}],[\"isstatic\",{\"1\":{\"1525\":2}}],[\"issynthetic\",{\"1\":{\"1524\":2}}],[\"issymmetric\",{\"1\":{\"406\":2}}],[\"issingletoncurrentlyincreation\",{\"1\":{\"1524\":2,\"1526\":1}}],[\"issingleton\",{\"1\":{\"1524\":6,\"1526\":1}}],[\"is锁\",{\"1\":{\"670\":1}}],[\"ismale=1\",{\"1\":{\"477\":1}}],[\"isbalanced\",{\"1\":{\"408\":1}}],[\"iseager\",{\"1\":{\"1525\":1}}],[\"iseagerinit\",{\"1\":{\"1524\":6}}],[\"isequal\",{\"1\":{\"1471\":1,\"1476\":5}}],[\"isend=false\",{\"1\":{\"302\":2}}],[\"isend\",{\"1\":{\"302\":6}}],[\"isempty\",{\"1\":{\"296\":1,\"386\":4,\"396\":1,\"397\":1,\"401\":1,\"402\":1,\"403\":1,\"404\":1,\"410\":1,\"411\":1,\"1524\":1,\"1525\":3,\"1527\":1,\"1535\":1}}],[\"is\",{\"1\":{\"0\":1,\"506\":2,\"566\":2,\"656\":1,\"710\":1,\"717\":1,\"1356\":1,\"1357\":2,\"1471\":9,\"1472\":3,\"1474\":8,\"1475\":25,\"1476\":16,\"1477\":6,\"1478\":8,\"1485\":6,\"1490\":1,\"1491\":1,\"1492\":18,\"1494\":5,\"1495\":7,\"1496\":11,\"1497\":40,\"1498\":21,\"1499\":6,\"1500\":14,\"1524\":5,\"1525\":2,\"1527\":1,\"1532\":2,\"1535\":1,\"1540\":1}}],[\"cn\",{\"1\":{\"1850\":1,\"1853\":1}}],[\"cnf修改配置文件\",{\"1\":{\"565\":1}}],[\"cnf\",{\"1\":{\"565\":1}}],[\"cnf文件\",{\"1\":{\"565\":1}}],[\"certain\",{\"1\":{\"1497\":1}}],[\"cellvalue\",{\"1\":{\"1431\":1}}],[\"cells\",{\"1\":{\"1357\":4}}],[\"cell\",{\"1\":{\"1357\":4}}],[\"c>\",{\"1\":{\"1486\":1,\"1495\":1}}],[\"czxy\",{\"1\":{\"1468\":1}}],[\"cylicbarrier实现原理\",{\"0\":{\"1374\":1}}],[\"cyclicbarrier是通过reentranlock的\",{\"1\":{\"1373\":1}}],[\"cyclicbarrier与countdownlatch的区别\",{\"1\":{\"1373\":1}}],[\"cxq\",{\"1\":{\"1360\":1}}],[\"css和\",{\"1\":{\"1855\":1}}],[\"cset\",{\"0\":{\"1624\":1}}],[\"cs\",{\"1\":{\"1357\":5,\"1394\":10}}],[\"csdn\",{\"1\":{\"467\":1,\"698\":1,\"1526\":1}}],[\"cmpose\",{\"1\":{\"1475\":1}}],[\"cmpxchg这个函数最终返回值是exchange\",{\"1\":{\"1356\":1}}],[\"cmpxchgl的详细执行过程\",{\"1\":{\"1356\":1}}],[\"cmpxchgl\",{\"1\":{\"1356\":4}}],[\"cmpxchg的实现\",{\"1\":{\"1356\":1}}],[\"cmpxchg方法中\",{\"1\":{\"1356\":1}}],[\"cmpxchg\",{\"1\":{\"1356\":7}}],[\"cms详细步骤\",{\"0\":{\"1609\":1}}],[\"cms简介\",{\"0\":{\"1608\":1}}],[\"cms收集器\",{\"0\":{\"1607\":1}}],[\"cms\",{\"0\":{\"121\":1,\"122\":1}}],[\"cpp\",{\"1\":{\"1356\":1}}],[\"cpu层面讲解了\",{\"1\":{\"1870\":1}}],[\"cpu拷贝次数\",{\"1\":{\"1462\":2}}],[\"cpu切换次数\",{\"1\":{\"1457\":1,\"1458\":1}}],[\"cpu把内核缓冲区的数据\",{\"1\":{\"1457\":1}}],[\"cpu上下文从用户态转为内核态\",{\"1\":{\"1457\":1}}],[\"cpunum\",{\"1\":{\"1450\":3}}],[\"cpu成功达到100\",{\"1\":{\"1428\":1}}],[\"cpu成本\",{\"1\":{\"682\":1,\"685\":1,\"686\":2}}],[\"cpu缓存是以缓存行为最小数据单位\",{\"1\":{\"1396\":1}}],[\"cpu缓存即高速缓冲存储器\",{\"1\":{\"1351\":1}}],[\"cpu密集型任务也叫计算密集型任务\",{\"1\":{\"1387\":1}}],[\"cpu密集型任务\",{\"1\":{\"1387\":1}}],[\"cpu核数大于消费者线程数量\",{\"1\":{\"1397\":1}}],[\"cpu核数\",{\"1\":{\"1357\":1}}],[\"cpus\",{\"1\":{\"1357\":1}}],[\"cpu直接从内存中存取数据需要等待一定时间周期\",{\"1\":{\"1351\":1}}],[\"cpu的工作原理\",{\"0\":{\"786\":1}}],[\"cpu的实模式\",{\"0\":{\"785\":1}}],[\"cpu\",{\"0\":{\"776\":1},\"1\":{\"568\":5,\"1356\":1,\"1459\":2,\"1460\":4,\"1461\":3}}],[\"cpu操作和内存不足时导致的i\",{\"1\":{\"518\":1}}],[\"cpu计算\",{\"1\":{\"518\":1}}],[\"ctors\",{\"1\":{\"1527\":6}}],[\"ctl\",{\"1\":{\"1353\":3}}],[\"ctrl\",{\"1\":{\"735\":1}}],[\"cglib和jdk的动态代理示例\",{\"1\":{\"1531\":1}}],[\"cglibsubclassinginstantiationstrategy\",{\"1\":{\"1528\":1}}],[\"cglib提升与aop类代理的关系\",{\"0\":{\"993\":1}}],[\"cglib\",{\"0\":{\"961\":1}}],[\"cglib动态代理\",{\"0\":{\"919\":1},\"1\":{\"1531\":1}}],[\"cdata\",{\"1\":{\"806\":1}}],[\"c语言编写\",{\"1\":{\"701\":1}}],[\"c三个表进行连接\",{\"1\":{\"693\":1}}],[\"c三个线程\",{\"0\":{\"80\":1}}],[\"cba这6种连接顺序\",{\"1\":{\"693\":1}}],[\"c是唯一索引\",{\"1\":{\"626\":1}}],[\"c的查询语句继续执行\",{\"1\":{\"618\":1}}],[\"c收到了断开连接的提示\",{\"1\":{\"618\":1}}],[\"c命令没有效果\",{\"1\":{\"618\":1}}],[\"c执行的时候被阻塞了\",{\"1\":{\"618\":1}}],[\"c执行kill\",{\"1\":{\"617\":1}}],[\"c事务提交\",{\"1\":{\"584\":1}}],[\"c也是相同的道理\",{\"1\":{\"584\":1}}],[\"c两条语句\",{\"1\":{\"583\":1}}],[\"c又插入一行\",{\"1\":{\"583\":1}}],[\"c阻塞\",{\"1\":{\"578\":1}}],[\"c需要mdl写锁\",{\"1\":{\"578\":1}}],[\"c会被blocked\",{\"1\":{\"578\":1}}],[\"c会同时查询表t的总行数\",{\"1\":{\"533\":1}}],[\"c里面\",{\"1\":{\"571\":1}}],[\"c5\",{\"1\":{\"515\":1}}],[\"c4字段排序产生了using\",{\"1\":{\"515\":1}}],[\"c4字段失效\",{\"1\":{\"515\":2}}],[\"c4失效\",{\"1\":{\"515\":3}}],[\"c4全字段\",{\"1\":{\"515\":4}}],[\"c4\",{\"1\":{\"515\":1}}],[\"c3p0\",{\"1\":{\"1852\":1}}],[\"c3用于排序\",{\"1\":{\"515\":4}}],[\"c3和c2两个字段索引失效\",{\"1\":{\"515\":1}}],[\"c3三个字段\",{\"1\":{\"515\":7}}],[\"c3字段用于排序了但是没有统计到key\",{\"1\":{\"515\":2}}],[\"c3字段\",{\"1\":{\"515\":1}}],[\"c3\",{\"1\":{\"515\":9}}],[\"c都用到\",{\"1\":{\"514\":2}}],[\"cv\",{\"1\":{\"498\":3}}],[\"cv索引呢\",{\"1\":{\"498\":1}}],[\"circular\",{\"1\":{\"1524\":7}}],[\"circuit\",{\"1\":{\"1500\":2}}],[\"circuiting\",{\"1\":{\"1476\":8,\"1500\":2}}],[\"cities\",{\"1\":{\"1482\":5}}],[\"city2\",{\"1\":{\"1482\":2}}],[\"city1\",{\"1\":{\"1482\":2}}],[\"city这个索引的示意图如下\",{\"1\":{\"491\":1}}],[\"city=\",{\"1\":{\"490\":1,\"491\":2,\"558\":1}}],[\"city\",{\"1\":{\"490\":1,\"491\":3,\"492\":1,\"493\":10,\"558\":1,\"713\":2,\"1482\":4,\"1495\":2}}],[\"cid\",{\"1\":{\"467\":2}}],[\"criteria\",{\"1\":{\"1493\":1}}],[\"creation\",{\"1\":{\"1492\":1,\"1524\":4,\"1567\":1}}],[\"creating\",{\"1\":{\"568\":3,\"1357\":1,\"1498\":1,\"1500\":2,\"1524\":1,\"1527\":1}}],[\"createtransactionifnecessary\",{\"1\":{\"1532\":1}}],[\"createoptionaldependency\",{\"1\":{\"1525\":1}}],[\"createbeanfactory\",{\"1\":{\"1528\":1}}],[\"createbeaninstance\",{\"1\":{\"1524\":1,\"1527\":1}}],[\"createbean\",{\"1\":{\"1524\":4}}],[\"createannotatedbeandefreader\",{\"1\":{\"1524\":2,\"1528\":2}}],[\"createservletapplicationcontext\",{\"1\":{\"1535\":2}}],[\"creates\",{\"1\":{\"1485\":2,\"1492\":1,\"1496\":2,\"1497\":2,\"1498\":1}}],[\"create语句\",{\"1\":{\"547\":1}}],[\"createdispatcherservlet\",{\"1\":{\"1535\":2}}],[\"createdependencyprovider\",{\"1\":{\"1525\":1}}],[\"created\",{\"1\":{\"530\":2,\"1471\":2,\"1495\":1,\"1496\":1,\"1497\":5,\"1524\":1,\"1528\":1}}],[\"create\",{\"1\":{\"3\":1,\"460\":1,\"472\":1,\"473\":1,\"475\":1,\"483\":1,\"486\":1,\"490\":1,\"498\":3,\"499\":4,\"500\":3,\"503\":1,\"505\":1,\"515\":2,\"537\":3,\"541\":3,\"544\":1,\"546\":1,\"549\":1,\"550\":2,\"551\":2,\"556\":2,\"561\":1,\"570\":1,\"583\":1,\"591\":1,\"596\":1,\"599\":1,\"605\":1,\"613\":1,\"615\":1,\"626\":1,\"627\":1,\"631\":3,\"643\":3,\"647\":1,\"655\":2,\"660\":4,\"671\":1,\"672\":1,\"694\":2,\"695\":2,\"696\":1,\"1464\":1,\"1465\":1,\"1492\":4,\"1496\":1,\"1497\":1,\"1524\":3,\"1528\":1,\"1531\":1}}],[\"crc\",{\"1\":{\"489\":2}}],[\"ccc\",{\"1\":{\"1363\":1}}],[\"cccc\",{\"1\":{\"605\":3}}],[\"ccv最后一个字段views会失效\",{\"1\":{\"498\":1}}],[\"ccv之后\",{\"1\":{\"498\":1}}],[\"ccv\",{\"1\":{\"498\":2}}],[\"cc\",{\"1\":{\"473\":1,\"1356\":1}}],[\"c刚好是列数\",{\"1\":{\"443\":1}}],[\"c刚好是行数\",{\"1\":{\"443\":1}}],[\"c2和c3排序失效产生了using\",{\"1\":{\"515\":1}}],[\"c2和c3用于排序\",{\"1\":{\"515\":1}}],[\"c2用于查找\",{\"1\":{\"515\":3}}],[\"c2两个字段\",{\"1\":{\"515\":1}}],[\"c2\",{\"1\":{\"427\":2,\"515\":21,\"1491\":14}}],[\"c1用于查找\",{\"1\":{\"515\":3}}],[\"c1和c2两个字段用于查找\",{\"1\":{\"515\":3}}],[\"c1234\",{\"1\":{\"515\":1}}],[\"c1\",{\"1\":{\"427\":2,\"515\":4,\"1491\":14}}],[\"caching\",{\"1\":{\"1524\":1}}],[\"cachedfieldvalue\",{\"1\":{\"1525\":5}}],[\"cached\",{\"1\":{\"1524\":2,\"1525\":2}}],[\"caches\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"cache的速度也是很快的\",{\"1\":{\"588\":1}}],[\"cache的保存问题\",{\"1\":{\"587\":1}}],[\"cache中保存着cpu刚刚用过或循环使用的一部分数据\",{\"1\":{\"1351\":1}}],[\"cache中写到磁盘上的binlog文件\",{\"1\":{\"588\":1}}],[\"cache中就够了\",{\"1\":{\"588\":1}}],[\"cache也差不多\",{\"1\":{\"588\":1}}],[\"cache里面\",{\"1\":{\"588\":1}}],[\"cache里的完整事务写入到binlog中\",{\"1\":{\"587\":1}}],[\"cache所占内存的大小\",{\"1\":{\"587\":1}}],[\"cache分配了一片内存\",{\"1\":{\"587\":1}}],[\"cache写入到binlog文件中\",{\"1\":{\"587\":1}}],[\"cache显式指定\",{\"1\":{\"456\":1}}],[\"cache缓存\",{\"1\":{\"310\":1}}],[\"cache\",{\"0\":{\"309\":1},\"1\":{\"456\":2,\"587\":5,\"588\":3,\"663\":2,\"806\":1,\"1524\":4}}],[\"capturing\",{\"1\":{\"1500\":1}}],[\"capacity\",{\"1\":{\"311\":6,\"1379\":3,\"1380\":8,\"1427\":9,\"1430\":1,\"1431\":2}}],[\"calculation\",{\"1\":{\"1497\":1,\"1500\":1}}],[\"callbackpreferringplatformtransactionmanager\",{\"1\":{\"1532\":3}}],[\"callbackfilter\",{\"1\":{\"1531\":1}}],[\"callback\",{\"1\":{\"1531\":1,\"1532\":3}}],[\"calls\",{\"1\":{\"1497\":3}}],[\"calling\",{\"1\":{\"1497\":3,\"1500\":4}}],[\"called\",{\"1\":{\"1485\":2,\"1492\":1,\"1494\":1,\"1496\":1,\"1497\":1,\"1499\":1,\"1500\":2}}],[\"caller\",{\"1\":{\"1472\":2,\"1474\":1,\"1475\":6,\"1476\":4,\"1492\":1,\"1497\":2,\"1524\":1,\"1528\":1}}],[\"callerrunspolicy\",{\"1\":{\"1353\":1}}],[\"callable\",{\"1\":{\"1354\":1}}],[\"call\",{\"1\":{\"537\":1,\"541\":1,\"551\":1,\"556\":1,\"655\":1,\"660\":2,\"1441\":1,\"1442\":2,\"1500\":6}}],[\"camel\",{\"1\":{\"1396\":1}}],[\"cab\",{\"1\":{\"693\":1}}],[\"cause\",{\"1\":{\"656\":4,\"657\":2}}],[\"cascaded\",{\"1\":{\"1495\":1}}],[\"cas+park\",{\"1\":{\"1407\":1}}],[\"cas操作\",{\"1\":{\"1362\":1}}],[\"casbase\",{\"1\":{\"1357\":1}}],[\"casx\",{\"1\":{\"1356\":1}}],[\"cas失败\",{\"1\":{\"1356\":1}}],[\"cas成功\",{\"1\":{\"1356\":1}}],[\"cas逻辑\",{\"1\":{\"1356\":1}}],[\"cas的过程如下\",{\"1\":{\"1356\":1}}],[\"cas的伪代码如下\",{\"1\":{\"1356\":1}}],[\"cas通常指的是这样一种原子操作\",{\"1\":{\"1356\":1}}],[\"cas源码解析\",{\"0\":{\"1356\":1}}],[\"cas与atomic实现原理\",{\"0\":{\"1355\":1}}],[\"cas\",{\"1\":{\"1352\":1,\"1356\":9,\"1357\":3,\"1359\":1,\"1431\":2,\"1545\":1}}],[\"castresult\",{\"1\":{\"1495\":2}}],[\"castingidentity\",{\"1\":{\"1493\":1}}],[\"castabat\",{\"1\":{\"1431\":1}}],[\"cast\",{\"1\":{\"504\":1,\"1492\":1,\"1494\":2,\"1497\":1}}],[\"cases\",{\"1\":{\"1496\":2,\"1498\":1}}],[\"caseinsensitivecomparator\",{\"1\":{\"1491\":2}}],[\"case\",{\"1\":{\"326\":1,\"435\":2,\"1478\":2,\"1491\":2,\"1494\":1,\"1524\":2,\"1525\":1,\"1532\":2}}],[\"card索引的情况下\",{\"1\":{\"499\":2}}],[\"card的值是否精确相同\",{\"1\":{\"489\":1}}],[\"cardinality直译过来就是基数的意思\",{\"1\":{\"690\":1}}],[\"cardinality属性\",{\"1\":{\"690\":1}}],[\"cardinality\",{\"1\":{\"484\":1,\"690\":2}}],[\"card字段创建唯一索引\",{\"1\":{\"478\":1}}],[\"card字段上创建索引\",{\"1\":{\"478\":1}}],[\"card`\",{\"1\":{\"475\":3}}],[\"card\",{\"1\":{\"469\":5,\"470\":1,\"471\":1,\"478\":1,\"489\":4,\"499\":6,\"500\":4}}],[\"catch\",{\"1\":{\"719\":1,\"1410\":1,\"1411\":1,\"1412\":2,\"1450\":4,\"1451\":6,\"1452\":9,\"1464\":1,\"1465\":1,\"1524\":16,\"1525\":4,\"1528\":2,\"1532\":5,\"1540\":1}}],[\"catlevel\",{\"1\":{\"467\":4}}],[\"cat\",{\"1\":{\"467\":8}}],[\"category\",{\"1\":{\"466\":2,\"467\":10,\"498\":5}}],[\"candidateindicators\",{\"1\":{\"1529\":4}}],[\"candidatenames存的就是找到的和所给类型匹配的所有的bean\",{\"1\":{\"1525\":1}}],[\"candidatenames\",{\"1\":{\"1525\":5}}],[\"candidate\",{\"1\":{\"1524\":11,\"1525\":13}}],[\"candidates\",{\"1\":{\"1524\":5}}],[\"cannot\",{\"1\":{\"1491\":1,\"1494\":1,\"1495\":1,\"1497\":3,\"1524\":4,\"1532\":1}}],[\"cancelrefresh\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"cancelling\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"cancellation\",{\"1\":{\"1500\":1}}],[\"cancellationrequested\",{\"1\":{\"1500\":5}}],[\"cancelled\",{\"1\":{\"1367\":1}}],[\"cancel\",{\"1\":{\"1394\":1,\"1451\":3}}],[\"canjump\",{\"1\":{\"421\":1}}],[\"can\",{\"1\":{\"1\":1,\"2\":1,\"3\":3,\"4\":1,\"566\":1,\"748\":2,\"1471\":2,\"1485\":2,\"1492\":4,\"1494\":2,\"1495\":1,\"1496\":3,\"1497\":6,\"1500\":4,\"1524\":1,\"1525\":1,\"1567\":1}}],[\"c\",{\"1\":{\"302\":10,\"314\":1,\"386\":5,\"387\":7,\"398\":4,\"400\":2,\"435\":38,\"443\":4,\"460\":1,\"514\":10,\"550\":1,\"553\":3,\"554\":1,\"555\":1,\"559\":7,\"566\":3,\"570\":2,\"584\":1,\"596\":4,\"603\":3,\"605\":1,\"613\":4,\"621\":2,\"643\":1,\"671\":1,\"714\":2,\"735\":1,\"1353\":4,\"1357\":4,\"1360\":2,\"1380\":8,\"1428\":2,\"1430\":3,\"1480\":2,\"1486\":1,\"1494\":7,\"1495\":1,\"1498\":2,\"1540\":8,\"1844\":1}}],[\"c=c\",{\"1\":{\"1494\":4}}],[\"c=c+1\",{\"1\":{\"460\":1}}],[\"c=3这个数据版本的trx\",{\"1\":{\"634\":1}}],[\"c=5\",{\"1\":{\"584\":4}}],[\"c=10\",{\"1\":{\"458\":1}}],[\"c=\",{\"1\":{\"302\":2}}],[\"chooses\",{\"1\":{\"1499\":1}}],[\"choice\",{\"1\":{\"1496\":2}}],[\"chongqing\",{\"1\":{\"1482\":1}}],[\"chosen\",{\"1\":{\"656\":4}}],[\"china\",{\"1\":{\"713\":2}}],[\"childbeandefinition\",{\"1\":{\"1509\":1}}],[\"children\",{\"1\":{\"806\":3}}],[\"child中是否有此node\",{\"1\":{\"302\":1}}],[\"child中删掉某个node\",{\"1\":{\"302\":1}}],[\"child\",{\"1\":{\"302\":12,\"806\":7,\"1524\":2}}],[\"chatset\",{\"1\":{\"1540\":1}}],[\"chance\",{\"1\":{\"1524\":1}}],[\"channel的读写操作都是异步的\",{\"1\":{\"1451\":1}}],[\"channel的四大组件\",{\"0\":{\"870\":1}}],[\"channel是一个通道\",{\"1\":{\"1451\":1}}],[\"channel注册流程\",{\"0\":{\"875\":1}}],[\"channel选择器\",{\"0\":{\"874\":1}}],[\"channelhandler与channelhandlercontext\",{\"0\":{\"873\":1}}],[\"channeloption与attributekey\",{\"0\":{\"872\":1}}],[\"channel与channelpipeline\",{\"0\":{\"871\":1}}],[\"channel实现原理\",{\"0\":{\"869\":1}}],[\"channelfuture\",{\"0\":{\"858\":1}}],[\"channels\",{\"1\":{\"735\":1,\"736\":1}}],[\"channel\",{\"0\":{\"849\":1},\"1\":{\"734\":5,\"1451\":31,\"1452\":19,\"1496\":2,\"1497\":1}}],[\"channel1\",{\"1\":{\"733\":2}}],[\"changes\",{\"1\":{\"1524\":1}}],[\"changed=false\",{\"1\":{\"1408\":1}}],[\"changed\",{\"1\":{\"656\":1,\"1408\":3}}],[\"change\",{\"0\":{\"481\":1,\"482\":1},\"1\":{\"480\":5,\"481\":3,\"482\":1,\"604\":1,\"605\":1,\"1408\":2,\"1496\":1}}],[\"chains\",{\"1\":{\"1500\":1}}],[\"chainedreference\",{\"1\":{\"1500\":1}}],[\"chainedreference<t\",{\"1\":{\"1500\":1}}],[\"chainedreference<p\",{\"1\":{\"1499\":1}}],[\"chaining\",{\"1\":{\"1498\":1}}],[\"chain\",{\"1\":{\"572\":1,\"1498\":1,\"1500\":1,\"1531\":1}}],[\"chain语法\",{\"1\":{\"572\":1}}],[\"char和varchar适用于包括人名\",{\"1\":{\"667\":1}}],[\"charsequence\",{\"1\":{\"1495\":3}}],[\"charset=utf8\",{\"1\":{\"647\":1,\"655\":1,\"660\":1,\"672\":1}}],[\"charset\",{\"1\":{\"503\":1,\"505\":1,\"561\":1,\"643\":3,\"671\":1,\"1496\":1}}],[\"chars\",{\"1\":{\"380\":3}}],[\"chararray\",{\"1\":{\"428\":3}}],[\"charat\",{\"1\":{\"302\":3,\"386\":1,\"388\":5,\"427\":2,\"1478\":2,\"1491\":2}}],[\"characteristics会作为一个位操作来标识的\",{\"1\":{\"1497\":1}}],[\"characteristics>\",{\"1\":{\"1495\":4}}],[\"characteristics是collector的一个属性\",{\"1\":{\"1492\":1}}],[\"characteristics\",{\"1\":{\"1492\":8,\"1493\":8,\"1494\":38,\"1495\":21,\"1496\":1,\"1497\":16,\"1498\":2}}],[\"characteristic\",{\"1\":{\"1492\":2,\"1497\":7,\"1498\":1}}],[\"charactermap\",{\"1\":{\"386\":6}}],[\"character>\",{\"1\":{\"386\":1}}],[\"character\",{\"1\":{\"302\":4,\"505\":1,\"1491\":4}}],[\"char\",{\"1\":{\"302\":5,\"380\":1,\"383\":2,\"384\":3,\"385\":5,\"386\":2,\"387\":4,\"400\":1,\"417\":2,\"427\":2,\"428\":1,\"435\":3,\"467\":3,\"515\":5,\"556\":4,\"667\":2,\"1491\":2}}],[\"ch\",{\"1\":{\"384\":9,\"1485\":1,\"1486\":1,\"1495\":15}}],[\"checks\",{\"1\":{\"1567\":1}}],[\"checksum=crc32\",{\"1\":{\"591\":1}}],[\"checkconfigmembers\",{\"1\":{\"1525\":1}}],[\"checkcandidate\",{\"1\":{\"1524\":1}}],[\"checkdependencies\",{\"1\":{\"1524\":1}}],[\"checkmergedbeandefinition\",{\"1\":{\"1524\":1}}],[\"checked\",{\"1\":{\"1500\":1}}],[\"check就是bincount\",{\"1\":{\"1431\":1}}],[\"checknotnull\",{\"1\":{\"1379\":1}}],[\"check`\",{\"1\":{\"615\":1}}],[\"check表上存入多行数据\",{\"1\":{\"615\":1}}],[\"check这个表需要再加一行\",{\"1\":{\"615\":1}}],[\"checking\",{\"1\":{\"568\":1,\"1497\":1}}],[\"checkpoint是当前要擦除的位置\",{\"1\":{\"461\":1}}],[\"check\",{\"1\":{\"4\":1,\"614\":2,\"615\":2,\"1431\":4,\"1497\":1,\"1524\":6,\"1532\":1,\"1535\":1}}],[\"clh队列是一种基于双向链表数据结构的队列\",{\"1\":{\"1368\":1}}],[\"cluster提供自动分区\",{\"1\":{\"705\":1}}],[\"clustered\",{\"1\":{\"472\":1,\"695\":1}}],[\"clazz\",{\"1\":{\"1525\":6}}],[\"clause\",{\"1\":{\"656\":7}}],[\"class类文件的结构\",{\"0\":{\"1653\":1}}],[\"class类不会被加载\",{\"1\":{\"1540\":1}}],[\"class文件结构\",{\"0\":{\"1547\":1}}],[\"classnotfoundexception\",{\"1\":{\"1540\":3}}],[\"class对象\",{\"1\":{\"1540\":1}}],[\"classobjectentry\",{\"1\":{\"1525\":3}}],[\"classutils\",{\"1\":{\"1525\":2}}],[\"classloader的loadclass方法\",{\"1\":{\"1540\":1}}],[\"classloader\",{\"1\":{\"1524\":1}}],[\"classmetadata\",{\"0\":{\"1523\":1},\"1\":{\"1523\":3}}],[\"class<t>\",{\"1\":{\"1524\":1}}],[\"class<\",{\"1\":{\"1515\":1,\"1521\":1,\"1524\":3,\"1525\":6,\"1527\":1,\"1531\":2,\"1532\":2,\"1540\":2}}],[\"classpath\",{\"1\":{\"1524\":2}}],[\"classpathxmlapplicationcontext\",{\"1\":{\"1514\":1}}],[\"classpathbeandefinitionscanner是扫描器\",{\"1\":{\"1512\":1}}],[\"classpathbeandefinitionscanner\",{\"0\":{\"1512\":1},\"1\":{\"1512\":2,\"1524\":1,\"1528\":1}}],[\"class解析为beandefinition\",{\"1\":{\"1510\":1}}],[\"classcastexception\",{\"1\":{\"1494\":1}}],[\"classcastexception类型的异常\",{\"1\":{\"1421\":1}}],[\"classification\",{\"1\":{\"1490\":1,\"1495\":2}}],[\"classifier\",{\"1\":{\"1490\":2,\"1495\":8}}],[\"classes\",{\"1\":{\"1485\":2,\"1497\":1,\"1498\":3,\"1522\":2}}],[\"class加载阶段\",{\"0\":{\"1159\":1}}],[\"class表\",{\"1\":{\"499\":1}}],[\"class\",{\"0\":{\"993\":1},\"1\":{\"302\":2,\"311\":1,\"317\":1,\"318\":1,\"319\":1,\"329\":4,\"338\":1,\"360\":1,\"361\":2,\"362\":2,\"363\":1,\"364\":1,\"371\":1,\"375\":1,\"376\":1,\"377\":1,\"381\":2,\"383\":1,\"384\":1,\"385\":2,\"389\":1,\"392\":1,\"398\":1,\"401\":1,\"402\":1,\"403\":2,\"404\":1,\"405\":1,\"406\":2,\"407\":1,\"408\":1,\"409\":3,\"410\":2,\"411\":2,\"412\":1,\"429\":1,\"432\":1,\"499\":4,\"719\":2,\"720\":2,\"806\":50,\"1356\":1,\"1364\":1,\"1380\":1,\"1398\":1,\"1403\":4,\"1405\":1,\"1412\":2,\"1419\":1,\"1423\":1,\"1428\":1,\"1431\":1,\"1437\":1,\"1452\":3,\"1468\":3,\"1469\":1,\"1470\":6,\"1471\":4,\"1472\":8,\"1474\":2,\"1475\":8,\"1476\":4,\"1477\":4,\"1478\":1,\"1479\":1,\"1480\":3,\"1481\":3,\"1482\":3,\"1483\":2,\"1484\":11,\"1485\":3,\"1486\":11,\"1487\":8,\"1489\":3,\"1490\":3,\"1491\":2,\"1492\":2,\"1493\":1,\"1494\":3,\"1495\":1,\"1496\":2,\"1497\":8,\"1498\":5,\"1499\":1,\"1500\":4,\"1509\":4,\"1510\":2,\"1511\":1,\"1515\":4,\"1516\":5,\"1517\":2,\"1521\":2,\"1522\":4,\"1523\":1,\"1524\":6,\"1525\":7,\"1527\":2,\"1528\":3,\"1529\":4,\"1531\":12,\"1532\":3,\"1534\":1,\"1540\":4}}],[\"cloud\",{\"0\":{\"1867\":1},\"1\":{\"1867\":2,\"1868\":2}}],[\"cloud与docker微服务架构实战\",{\"1\":{\"1844\":1}}],[\"cloumn机制\",{\"1\":{\"554\":1}}],[\"clone\",{\"1\":{\"1524\":1}}],[\"clonebeandefinition\",{\"1\":{\"1524\":1}}],[\"closebeanfactory\",{\"1\":{\"1528\":1}}],[\"closehandler\",{\"1\":{\"1496\":1}}],[\"close方法会自动的得到调用\",{\"1\":{\"1496\":1}}],[\"closed\",{\"1\":{\"1487\":1,\"1496\":2,\"1499\":2}}],[\"close\",{\"1\":{\"719\":1,\"1410\":2,\"1411\":2,\"1451\":7,\"1452\":5,\"1464\":2,\"1465\":2,\"1468\":2,\"1496\":9}}],[\"closing\",{\"1\":{\"568\":1,\"1496\":2}}],[\"clock\",{\"1\":{\"602\":1}}],[\"climbstairs\",{\"1\":{\"424\":5}}],[\"clients\",{\"1\":{\"1497\":3}}],[\"clients<\",{\"1\":{\"719\":1}}],[\"client1\",{\"1\":{\"733\":1}}],[\"client5\",{\"1\":{\"733\":1}}],[\"client2\",{\"1\":{\"733\":1}}],[\"client\",{\"1\":{\"3\":2,\"761\":2}}],[\"cleanuptransactioninfo\",{\"1\":{\"1532\":2}}],[\"cleanupafterbeancreationfailure\",{\"1\":{\"1524\":1}}],[\"cleaning\",{\"1\":{\"568\":1}}],[\"cleanspaces\",{\"1\":{\"385\":2}}],[\"clean\",{\"1\":{\"385\":1}}],[\"customizeregistration\",{\"1\":{\"1535\":1}}],[\"customizebeanfactory\",{\"1\":{\"1528\":1}}],[\"customization\",{\"0\":{\"4\":1}}],[\"customeditorconfigurer\",{\"1\":{\"1515\":7}}],[\"cuser\",{\"1\":{\"478\":1}}],[\"cursor\",{\"1\":{\"710\":1,\"711\":1}}],[\"cur\",{\"1\":{\"395\":14}}],[\"currelements\",{\"1\":{\"1525\":4}}],[\"currentproxy\",{\"1\":{\"1531\":1}}],[\"currentthread\",{\"1\":{\"1452\":2,\"1494\":2}}],[\"currenttimemillis\",{\"1\":{\"1364\":2,\"1468\":4}}],[\"current\",{\"1\":{\"591\":1,\"605\":1,\"615\":1,\"647\":1,\"655\":1,\"675\":1,\"1497\":1}}],[\"currenthashmap的实现原理\",{\"0\":{\"46\":1}}],[\"currdepth\",{\"1\":{\"403\":4}}],[\"curr\",{\"1\":{\"371\":7,\"372\":6,\"403\":5,\"429\":5}}],[\"currnode\",{\"1\":{\"302\":22}}],[\"c++内存管理\",{\"1\":{\"1844\":1}}],[\"c++面向对象编程\",{\"1\":{\"1844\":1}}],[\"c++\",{\"1\":{\"8\":1,\"435\":1,\"1360\":1,\"1844\":2,\"1847\":1}}],[\"cover\",{\"1\":{\"1497\":1}}],[\"covering\",{\"1\":{\"1497\":1}}],[\"covered\",{\"1\":{\"1497\":2}}],[\"covers\",{\"1\":{\"1497\":3}}],[\"could\",{\"1\":{\"1492\":2,\"1495\":1,\"1497\":2,\"1500\":1,\"1524\":1}}],[\"countedcompleter<void>\",{\"1\":{\"1497\":1}}],[\"countedcompleter\",{\"1\":{\"1497\":2}}],[\"countercells\",{\"1\":{\"1431\":1}}],[\"countercell\",{\"1\":{\"1431\":2}}],[\"counter++\",{\"1\":{\"635\":1,\"1359\":3}}],[\"counter定义的大小是4个字节\",{\"1\":{\"635\":1}}],[\"counter赋值给这个新连接的线程变量\",{\"1\":{\"635\":1}}],[\"counter\",{\"1\":{\"635\":1,\"704\":1,\"1359\":4}}],[\"counter跳过事务和通过slave\",{\"1\":{\"605\":1}}],[\"counter=1\",{\"1\":{\"604\":1}}],[\"counts\",{\"1\":{\"1490\":1}}],[\"counting\",{\"1\":{\"1490\":2,\"1492\":1,\"1493\":1}}],[\"count++\",{\"1\":{\"1379\":1}}],[\"countdownlatch的计数器只能使用一次\",{\"1\":{\"1373\":1}}],[\"countdownlatch\",{\"1\":{\"1367\":1}}],[\"count缺省值为1\",{\"1\":{\"709\":2}}],[\"count也无效了\",{\"1\":{\"588\":1}}],[\"count参数\",{\"1\":{\"588\":2,\"602\":1}}],[\"count来实现\",{\"1\":{\"588\":1}}],[\"countnodes\",{\"1\":{\"407\":3}}],[\"count\",{\"0\":{\"532\":1,\"533\":1,\"663\":1},\"1\":{\"381\":1,\"467\":1,\"487\":5,\"503\":2,\"527\":1,\"532\":1,\"533\":1,\"536\":7,\"553\":3,\"554\":1,\"555\":1,\"559\":2,\"566\":1,\"616\":1,\"663\":6,\"708\":4,\"709\":4,\"710\":2,\"711\":2,\"713\":1,\"1360\":1,\"1362\":1,\"1375\":3,\"1379\":4,\"1380\":9,\"1430\":2,\"1471\":4,\"1489\":2,\"1490\":1,\"1492\":1,\"1496\":1,\"1497\":2}}],[\"code\",{\"1\":{\"1471\":7,\"1472\":3,\"1474\":8,\"1475\":18,\"1476\":22,\"1478\":8,\"1485\":7}}],[\"corinv\",{\"1\":{\"1532\":6}}],[\"coroutinesutils\",{\"1\":{\"1532\":1}}],[\"coroutinesinvocationcallback\",{\"1\":{\"1532\":3}}],[\"coroutines\",{\"1\":{\"1532\":2}}],[\"core\",{\"1\":{\"1498\":1,\"1524\":1,\"1528\":1}}],[\"corepoolsize\",{\"1\":{\"1353\":3}}],[\"corresponding\",{\"1\":{\"1497\":3,\"1500\":1,\"1524\":1}}],[\"corresponds\",{\"1\":{\"1497\":1}}],[\"correct\",{\"1\":{\"1496\":1,\"1500\":3,\"1524\":1}}],[\"corrdinator再去取下一批\",{\"1\":{\"601\":1}}],[\"corrdinator直接执行这个事务\",{\"1\":{\"599\":1}}],[\"corrdinator暂时先hold住这个事务\",{\"1\":{\"599\":1}}],[\"corrdinator在解析这个语句的binlog的时候\",{\"1\":{\"599\":1}}],[\"corrdinator线程就会把这个事务分配给这个存在冲突关系的worker\",{\"1\":{\"598\":1}}],[\"corrdinator线程就会把这个事务分配给最闲的worker\",{\"1\":{\"598\":1}}],[\"corrdinator线程就会进入等待状态\",{\"1\":{\"598\":1}}],[\"corrdinator线程就进入等待\",{\"1\":{\"598\":1}}],[\"corrdinator继续读下一个中转日志\",{\"1\":{\"598\":1}}],[\"corrdinator从中转日志中读入下一个新事务t\",{\"1\":{\"598\":1}}],[\"cookie\",{\"1\":{\"1856\":1}}],[\"cookie和session有什么区别\",{\"0\":{\"224\":1}}],[\"cooperatively\",{\"1\":{\"1500\":1}}],[\"coordinator在分发的时候\",{\"1\":{\"597\":1}}],[\"coordinator就是原来的sql\",{\"1\":{\"597\":1}}],[\"copyrelevantmergedbeandefinitioncaches\",{\"1\":{\"1524\":1}}],[\"copyintowithcancel\",{\"1\":{\"1500\":1}}],[\"copyinto\",{\"1\":{\"1500\":4}}],[\"copying\",{\"1\":{\"568\":1}}],[\"copy都是少不了的\",{\"1\":{\"1462\":1}}],[\"copyonwritearraylis就是一个不可变的元\",{\"1\":{\"1497\":1}}],[\"copyonwritearraylist\",{\"1\":{\"1497\":1}}],[\"copyonwritearraylist和copyonwritearrayset这两个copy\",{\"1\":{\"1404\":1}}],[\"copyonwritearraylist可以用于什么应用场景\",{\"0\":{\"79\":1}}],[\"copyof\",{\"1\":{\"1352\":1,\"1495\":1}}],[\"copy\",{\"0\":{\"1404\":1},\"1\":{\"725\":1,\"1404\":3,\"1460\":1}}],[\"cost多出了两列\",{\"1\":{\"694\":1}}],[\"costs\",{\"1\":{\"694\":1}}],[\"cost表相比\",{\"1\":{\"694\":1}}],[\"cost表\",{\"1\":{\"694\":2}}],[\"cost表中\",{\"1\":{\"694\":2}}],[\"cost\",{\"1\":{\"541\":1,\"542\":1,\"656\":7,\"690\":8,\"692\":12,\"694\":12,\"1492\":1}}],[\"collectingandthen\",{\"1\":{\"1493\":1,\"1495\":2}}],[\"collectionutils\",{\"1\":{\"1525\":1}}],[\"collectiontocommadelimitedstring\",{\"1\":{\"1524\":1}}],[\"collectionfactory\",{\"1\":{\"1486\":2,\"1495\":2}}],[\"collection<\",{\"1\":{\"1498\":1}}],[\"collection<widget>\",{\"1\":{\"1496\":1}}],[\"collection<t>\",{\"1\":{\"1486\":1,\"1495\":1}}],[\"collection<t>>\",{\"1\":{\"1486\":1,\"1495\":1}}],[\"collection<e>\",{\"1\":{\"1377\":1}}],[\"collection提供了新的stream\",{\"1\":{\"1485\":1}}],[\"collection\",{\"1\":{\"806\":2,\"1492\":2,\"1494\":1,\"1496\":5,\"1497\":8,\"1498\":1,\"1499\":2,\"1525\":1}}],[\"collections\",{\"1\":{\"441\":3,\"1482\":2,\"1488\":1,\"1491\":12,\"1493\":1,\"1494\":5,\"1495\":5,\"1496\":3,\"1497\":2,\"1516\":2}}],[\"collect本身的定义是这样的\",{\"1\":{\"1492\":1}}],[\"collector所使用的map是由supplied工厂函数提供的\",{\"1\":{\"1495\":1}}],[\"collectorimpl\",{\"1\":{\"1493\":2}}],[\"collectorimpl<charsequence\",{\"1\":{\"1495\":1}}],[\"collectorimpl<t\",{\"1\":{\"1493\":1}}],[\"collectorimpl<>\",{\"1\":{\"1485\":1,\"1486\":1,\"1495\":12}}],[\"collector接口有且仅有唯一的实现类collectorimpl\",{\"1\":{\"1493\":1}}],[\"collector实践\",{\"0\":{\"1493\":1}}],[\"collector必须满足两个条件\",{\"1\":{\"1492\":1}}],[\"collector是由以下四个方法构成\",{\"1\":{\"1492\":1}}],[\"collector<charsequence\",{\"1\":{\"1495\":2}}],[\"collector<employee\",{\"1\":{\"1492\":2}}],[\"collector<widget\",{\"1\":{\"1492\":1}}],[\"collector<\",{\"1\":{\"1492\":1,\"1494\":2,\"1495\":5}}],[\"collector<t\",{\"1\":{\"1485\":1,\"1486\":1,\"1490\":2,\"1493\":1,\"1494\":2,\"1495\":14}}],[\"collector无疑是整个stream源码中及其重要的一个类\",{\"1\":{\"1492\":1}}],[\"collector源码分析\",{\"0\":{\"1492\":1}}],[\"collector\",{\"1\":{\"1490\":2,\"1492\":25,\"1493\":1,\"1494\":19,\"1495\":21}}],[\"collectors作为生产collector的静态工厂类\",{\"1\":{\"1495\":1}}],[\"collectors源码分析\",{\"0\":{\"1495\":1}}],[\"collectors实现了collector接口并提供了很多很有用的汇聚操作\",{\"1\":{\"1493\":1}}],[\"collectors类被用来生产一些常见的方法\",{\"1\":{\"1493\":1}}],[\"collectors很多方法可以接收collector作为参数返回一个新的collector\",{\"1\":{\"1492\":1}}],[\"collectors还有一个描述特征的的集合\",{\"1\":{\"1492\":1}}],[\"collectors是collector的实现类\",{\"1\":{\"1492\":1}}],[\"collectors提供了很多对于常见的可变的汇聚操作的实现\",{\"1\":{\"1492\":1}}],[\"collectors\",{\"1\":{\"1475\":2,\"1485\":1,\"1486\":9,\"1490\":7,\"1492\":15,\"1493\":26,\"1495\":3}}],[\"collect无需其他操作就可以很好的支持并行流\",{\"1\":{\"1485\":1}}],[\"collect方法接收三个参数\",{\"1\":{\"1485\":1}}],[\"collect\",{\"1\":{\"1475\":2,\"1485\":14,\"1486\":9,\"1490\":5,\"1492\":5,\"1493\":19,\"1494\":8,\"1495\":4}}],[\"collation\",{\"1\":{\"690\":1}}],[\"column\",{\"1\":{\"554\":1,\"578\":2,\"690\":1}}],[\"columns\",{\"1\":{\"417\":7,\"656\":2,\"690\":1,\"692\":2}}],[\"coming\",{\"1\":{\"1500\":2}}],[\"combineopflags\",{\"1\":{\"1498\":1,\"1499\":1}}],[\"combine\",{\"1\":{\"1492\":1,\"1494\":1}}],[\"combinedflags\",{\"1\":{\"1498\":1,\"1499\":2,\"1500\":1}}],[\"combined\",{\"1\":{\"1492\":1}}],[\"combiner方法会将一个map的key合并到另一个当中\",{\"1\":{\"1495\":1}}],[\"combiner三个对象\",{\"1\":{\"1494\":1}}],[\"combiner分别执行了一次\",{\"1\":{\"1494\":1}}],[\"combiner中返回的结果都一定是线程封闭的\",{\"1\":{\"1492\":1}}],[\"combiner或者finisher方法\",{\"1\":{\"1492\":1}}],[\"combiner做任何的事情\",{\"1\":{\"1492\":1}}],[\"combiner上一次调用的结果\",{\"1\":{\"1492\":1}}],[\"combiner函数可以将状态从一个折叠成为另一个\",{\"1\":{\"1492\":1}}],[\"combiner函数接收两个部分的结果并且合并它们\",{\"1\":{\"1492\":1}}],[\"combiner用于合并两个值\",{\"1\":{\"1485\":1}}],[\"combiner是将上一次返回的结果\",{\"1\":{\"1485\":1}}],[\"combiner\",{\"1\":{\"1485\":4,\"1492\":16,\"1493\":8,\"1494\":12,\"1495\":5}}],[\"combining\",{\"1\":{\"1485\":2,\"1492\":3}}],[\"comxchgq\",{\"1\":{\"1356\":1}}],[\"computing\",{\"1\":{\"1492\":2}}],[\"computeifabsent\",{\"1\":{\"1495\":2,\"1532\":1}}],[\"computes\",{\"1\":{\"1492\":1,\"1500\":1}}],[\"compute2\",{\"1\":{\"1475\":2}}],[\"compute的function参数传递的是一种行为\",{\"1\":{\"1475\":1}}],[\"compute\",{\"1\":{\"1475\":15,\"1493\":2,\"1495\":2,\"1497\":3}}],[\"computational\",{\"1\":{\"1496\":1}}],[\"computation\",{\"1\":{\"656\":2,\"1492\":2,\"1496\":2,\"1497\":7}}],[\"component的beandefinition\",{\"1\":{\"1529\":1}}],[\"component\",{\"1\":{\"1515\":1,\"1521\":1,\"1524\":1,\"1529\":1}}],[\"component注解的包含过滤器\",{\"1\":{\"1524\":1}}],[\"component注解的就是bean\",{\"1\":{\"1522\":1}}],[\"component注解也不会注册为bean\",{\"1\":{\"1522\":1}}],[\"component注解\",{\"1\":{\"1512\":1,\"1522\":1,\"1524\":1}}],[\"componentscan\",{\"0\":{\"1033\":1},\"1\":{\"1522\":4,\"1529\":1}}],[\"compose与docker\",{\"1\":{\"1844\":1}}],[\"compose\",{\"1\":{\"1475\":6}}],[\"composed\",{\"1\":{\"1474\":3,\"1475\":24,\"1476\":12,\"1492\":1,\"1496\":1}}],[\"compiler\",{\"1\":{\"1471\":3}}],[\"compilers\",{\"1\":{\"1471\":2}}],[\"completetransactionafterthrowing\",{\"1\":{\"1532\":1}}],[\"complete\",{\"1\":{\"1492\":1,\"1497\":1}}],[\"completed\",{\"1\":{\"1452\":5}}],[\"completionhandler<void\",{\"1\":{\"1452\":1}}],[\"completionhandler<integer\",{\"1\":{\"1452\":3}}],[\"completionhandler<asynchronoussocketchannel\",{\"1\":{\"1452\":1}}],[\"completionstage接口\",{\"1\":{\"1395\":1}}],[\"completionservice支持自己创建线程池\",{\"1\":{\"1394\":1}}],[\"completionservice能够让异步任务的执行结果有序化\",{\"1\":{\"1394\":1}}],[\"completionservice将线程池和阻塞队列blockingqueue的功能融合在了一起\",{\"1\":{\"1394\":1}}],[\"completionservice的应用场景总结\",{\"1\":{\"1394\":1}}],[\"completionservice<integer>\",{\"1\":{\"1394\":2}}],[\"completionservice内部通过阻塞队列+futuretask\",{\"1\":{\"1394\":1}}],[\"completionservice\",{\"0\":{\"1394\":1}}],[\"completablefuture类自己也提供了anyof\",{\"1\":{\"1395\":1}}],[\"completablefuture实现了对任务的编排能力\",{\"1\":{\"1395\":1}}],[\"completablefuture实现了future接口\",{\"1\":{\"1395\":1}}],[\"completablefuture实现原理\",{\"0\":{\"1392\":1}}],[\"completablefuture是future接口的扩展和增强\",{\"1\":{\"1395\":1}}],[\"completablefuture\",{\"0\":{\"1395\":1}}],[\"compatible\",{\"1\":{\"1485\":2}}],[\"comparingint\",{\"1\":{\"1491\":11,\"1493\":3}}],[\"comparing\",{\"1\":{\"1478\":2,\"1491\":1}}],[\"comparator并不是jdk8新增加的内容\",{\"1\":{\"1491\":1}}],[\"comparator源码分析及实践\",{\"0\":{\"1491\":1}}],[\"comparator<method>\",{\"1\":{\"1531\":2}}],[\"comparator<t>\",{\"1\":{\"1480\":1,\"1491\":5}}],[\"comparator<string>\",{\"1\":{\"1478\":1,\"1491\":2}}],[\"comparator<\",{\"1\":{\"1478\":2,\"1480\":1,\"1491\":1,\"1497\":1}}],[\"comparator\",{\"1\":{\"1478\":19,\"1480\":1,\"1488\":1,\"1491\":16,\"1493\":3,\"1497\":2}}],[\"comparable<\",{\"1\":{\"318\":1,\"1383\":2}}],[\"comparable\",{\"1\":{\"317\":5,\"318\":4,\"319\":9}}],[\"comparebyname\",{\"1\":{\"1482\":2}}],[\"comparebyscore\",{\"1\":{\"1482\":1}}],[\"comparestudentbyname\",{\"1\":{\"1480\":1,\"1481\":2,\"1482\":1}}],[\"comparestudentbyscore与comparestudentbyname方法实际上是我们有意为之的\",{\"1\":{\"1482\":1}}],[\"comparestudentbyscore\",{\"1\":{\"1480\":4,\"1481\":3,\"1482\":1}}],[\"compareandswaplong\",{\"1\":{\"1431\":2}}],[\"compareandswapint的返回值\",{\"1\":{\"1356\":1}}],[\"compareandswapint\",{\"1\":{\"1356\":3,\"1431\":3}}],[\"compareandsetstate\",{\"1\":{\"1367\":1}}],[\"compareandset\",{\"1\":{\"1356\":3}}],[\"compare\",{\"1\":{\"694\":1,\"1356\":5,\"1476\":2,\"1478\":2,\"1480\":1,\"1491\":6}}],[\"comparetoignorecase\",{\"1\":{\"1480\":1,\"1481\":1,\"1482\":4,\"1491\":1}}],[\"compareto\",{\"1\":{\"317\":1,\"318\":1,\"319\":2,\"1383\":1}}],[\"companion\",{\"1\":{\"302\":2}}],[\"communicated\",{\"1\":{\"1524\":1}}],[\"commences\",{\"1\":{\"1498\":1}}],[\"commenced\",{\"1\":{\"1497\":3}}],[\"comment=\",{\"1\":{\"647\":1,\"655\":1}}],[\"comments\",{\"1\":{\"498\":4}}],[\"comment\",{\"1\":{\"498\":8,\"499\":6,\"500\":3,\"591\":1,\"647\":4,\"655\":4,\"690\":2}}],[\"commas\",{\"1\":{\"1493\":1}}],[\"command\",{\"1\":{\"459\":1,\"717\":1,\"1353\":8,\"1865\":1}}],[\"committransactionafterreturning\",{\"1\":{\"1532\":1}}],[\"committed\",{\"1\":{\"570\":2,\"669\":1}}],[\"commit都设置成1\",{\"1\":{\"588\":1}}],[\"commit设置成0\",{\"1\":{\"588\":1}}],[\"commit设置成1\",{\"1\":{\"588\":1}}],[\"commit设置为2\",{\"1\":{\"588\":1}}],[\"commit设置的是1\",{\"1\":{\"588\":1}}],[\"commit参数\",{\"1\":{\"588\":1}}],[\"commit\",{\"1\":{\"463\":1,\"505\":3,\"588\":9,\"601\":2,\"602\":3,\"605\":1,\"622\":1,\"698\":1,\"1494\":1,\"1532\":3}}],[\"common目录中\",{\"1\":{\"1571\":1}}],[\"commonpool\",{\"1\":{\"1395\":1,\"1494\":27}}],[\"common\",{\"1\":{\"4\":1,\"1492\":1,\"1493\":1,\"1524\":1,\"1528\":1}}],[\"com\",{\"1\":{\"10\":1,\"446\":1,\"449\":1,\"487\":3,\"488\":2,\"654\":2,\"668\":1,\"677\":1,\"710\":3,\"796\":1,\"800\":2,\"806\":1,\"1356\":1,\"1371\":1,\"1376\":1,\"1428\":1,\"1468\":1,\"1503\":1,\"1504\":1,\"1512\":1,\"1522\":2,\"1523\":1,\"1529\":1,\"1530\":1,\"1534\":1,\"1540\":1,\"1847\":3,\"1850\":2,\"1852\":2,\"1853\":3,\"1856\":1,\"1858\":1,\"1859\":3,\"1860\":1,\"1861\":1,\"1863\":2,\"1864\":1,\"1865\":3,\"1867\":1,\"1868\":1,\"1869\":1,\"1870\":2}}],[\"conn\",{\"1\":{\"1532\":1}}],[\"connet事件等待结果而不用像bio那样被同步阻塞\",{\"1\":{\"1451\":1}}],[\"connector\",{\"1\":{\"1561\":1}}],[\"connect\",{\"1\":{\"1451\":2,\"1452\":1}}],[\"connected\",{\"1\":{\"746\":1}}],[\"connection命令时\",{\"1\":{\"618\":1}}],[\"connection命令\",{\"1\":{\"618\":1}}],[\"connection命令是有效的\",{\"1\":{\"617\":1}}],[\"connection来重新初始化连接资源\",{\"1\":{\"455\":1}}],[\"connection\",{\"1\":{\"455\":1,\"617\":1,\"618\":4,\"720\":3}}],[\"convenience\",{\"1\":{\"1497\":1}}],[\"conversionservicefactorybean\",{\"1\":{\"1516\":6}}],[\"conversionservice可以自定义转换类型\",{\"1\":{\"1516\":1}}],[\"conversionservice是spring中提供的类型转化服务\",{\"1\":{\"1516\":1}}],[\"conversionservice\",{\"0\":{\"1516\":1},\"1\":{\"1516\":1}}],[\"conversionservice作为依赖\",{\"0\":{\"1254\":1}}],[\"convertifnecessary\",{\"1\":{\"1517\":1,\"1525\":3}}],[\"convertiblepair\",{\"1\":{\"1516\":1}}],[\"convertingcomparator<>\",{\"1\":{\"1531\":2}}],[\"converting\",{\"1\":{\"568\":1}}],[\"converter<method\",{\"1\":{\"1531\":1}}],[\"converter\",{\"1\":{\"1525\":4,\"1534\":1}}],[\"converter接口的局限性\",{\"0\":{\"1249\":1}}],[\"converted\",{\"1\":{\"1\":1,\"2\":1}}],[\"convert\",{\"1\":{\"505\":3,\"1475\":1,\"1493\":1,\"1516\":1}}],[\"conform\",{\"1\":{\"1496\":1,\"1497\":1}}],[\"confinement这种模式来实现\",{\"1\":{\"1497\":1}}],[\"confinement\",{\"1\":{\"1497\":1}}],[\"confined\",{\"1\":{\"1492\":1}}],[\"configured\",{\"1\":{\"1524\":1}}],[\"configureblocking\",{\"1\":{\"1451\":3}}],[\"configurablelistablebeanfactory\",{\"1\":{\"1513\":1,\"1524\":1,\"1525\":2,\"1528\":1}}],[\"configurablebeanfactory\",{\"1\":{\"1513\":2,\"1524\":3}}],[\"configurationclassparser\",{\"1\":{\"1529\":1}}],[\"configurationclasspostprocessor\",{\"1\":{\"1529\":1}}],[\"configuration\",{\"0\":{\"3\":1,\"993\":1,\"1032\":1},\"1\":{\"3\":3,\"4\":1,\"720\":1,\"806\":1,\"1529\":1}}],[\"config\",{\"0\":{\"979\":1},\"1\":{\"3\":2,\"704\":1,\"1531\":5,\"1535\":1}}],[\"conf配置文件中配置了这个脚本路径\",{\"1\":{\"761\":1}}],[\"conf\",{\"1\":{\"758\":1,\"761\":2}}],[\"conf中第8条\",{\"1\":{\"746\":1}}],[\"conf中开启相关配置即可\",{\"1\":{\"724\":1}}],[\"conduct\",{\"1\":{\"1500\":1}}],[\"cond\",{\"1\":{\"618\":1,\"1360\":1,\"1407\":1}}],[\"conditionalgenericconverter\",{\"1\":{\"1516\":1}}],[\"conditional\",{\"1\":{\"1510\":1}}],[\"conditionalonclass注解中有两个类是默认不存在的\",{\"1\":{\"720\":1}}],[\"conditionfilter4\",{\"1\":{\"1476\":2}}],[\"conditionfilter3\",{\"1\":{\"1476\":2}}],[\"conditionfilter2\",{\"1\":{\"1476\":2}}],[\"conditionfilter\",{\"1\":{\"1476\":10}}],[\"condition接口\",{\"0\":{\"1370\":1}}],[\"conditions\",{\"1\":{\"656\":8}}],[\"condition\",{\"1\":{\"477\":1,\"656\":10,\"690\":2,\"691\":1,\"692\":5,\"1367\":1,\"1379\":2,\"1380\":2,\"1524\":1}}],[\"cons是原生的consumer特化的类型\",{\"1\":{\"1497\":1}}],[\"cons>\",{\"1\":{\"1497\":1}}],[\"cons\",{\"1\":{\"1497\":4}}],[\"consequence\",{\"1\":{\"1497\":1,\"1524\":1}}],[\"consumes\",{\"1\":{\"1500\":3}}],[\"consumed\",{\"1\":{\"1496\":1,\"1497\":1,\"1498\":6,\"1499\":4}}],[\"consumer消息接收重试\",{\"0\":{\"1808\":1}}],[\"consumertest\",{\"1\":{\"1497\":8}}],[\"consumerthreads\",{\"1\":{\"1412\":2}}],[\"consumer原生类型的特化\",{\"1\":{\"1497\":1}}],[\"consumer代表了一种接收单个输入并且不返回结果的操作\",{\"1\":{\"1474\":1}}],[\"consumer这个单词本身的意思是消费者\",{\"1\":{\"1474\":1}}],[\"consumer\",{\"1\":{\"1474\":4,\"1496\":2,\"1497\":13,\"1500\":4}}],[\"consumer函数式接口\",{\"0\":{\"1474\":1}}],[\"consumer<integer>\",{\"1\":{\"1497\":3}}],[\"consumer<string>\",{\"1\":{\"1474\":1}}],[\"consumer<\",{\"1\":{\"1471\":3,\"1472\":1,\"1474\":1,\"1497\":6,\"1498\":2,\"1499\":4,\"1500\":1}}],[\"consumer<t>\",{\"1\":{\"1471\":4,\"1474\":2,\"1497\":3}}],[\"consists\",{\"1\":{\"1496\":1,\"1500\":1}}],[\"consisting\",{\"1\":{\"1486\":1}}],[\"consistency=on\",{\"1\":{\"605\":1}}],[\"consistency\",{\"1\":{\"569\":1}}],[\"considerations\",{\"1\":{\"1497\":1}}],[\"considers\",{\"1\":{\"1491\":1}}],[\"considered\",{\"1\":{\"656\":4,\"1498\":1}}],[\"consider\",{\"1\":{\"566\":1,\"1492\":1,\"1500\":1,\"1524\":1,\"1525\":2}}],[\"constrain\",{\"1\":{\"1497\":1}}],[\"constraint\",{\"1\":{\"1492\":2}}],[\"constraints\",{\"1\":{\"1492\":2,\"1497\":1}}],[\"constructs\",{\"1\":{\"1500\":1}}],[\"constructions\",{\"1\":{\"1497\":1}}],[\"construction\",{\"1\":{\"1496\":1,\"1497\":2,\"1498\":1,\"1527\":1}}],[\"construct\",{\"1\":{\"1492\":1,\"1499\":1}}],[\"constructors\",{\"1\":{\"1527\":1}}],[\"constructor<\",{\"1\":{\"1527\":1}}],[\"constructorargumentsresolved\",{\"1\":{\"1527\":1}}],[\"constructorargumentlock\",{\"1\":{\"1527\":1}}],[\"constructorresolver\",{\"1\":{\"1525\":2}}],[\"constructor\",{\"0\":{\"14\":1},\"1\":{\"1437\":1,\"1471\":2,\"1499\":2,\"1527\":3}}],[\"constant\",{\"1\":{\"656\":1}}],[\"const用于比较primary\",{\"1\":{\"467\":1}}],[\"const\",{\"1\":{\"467\":4,\"527\":1}}],[\"concreteness\",{\"1\":{\"1500\":1}}],[\"concrete\",{\"1\":{\"1498\":2}}],[\"concerning\",{\"1\":{\"1497\":1}}],[\"concerned\",{\"1\":{\"1496\":2}}],[\"conceptually\",{\"1\":{\"1471\":2}}],[\"concurrent或者late\",{\"1\":{\"1498\":1}}],[\"concurrentmap<k\",{\"1\":{\"1495\":1}}],[\"concurrentmodificationexception\",{\"1\":{\"1494\":2,\"1497\":3}}],[\"concurrent并不是unordered\",{\"1\":{\"1494\":1}}],[\"concurrent表示当前的收集器是并发的\",{\"1\":{\"1494\":1}}],[\"concurrently\",{\"1\":{\"1492\":3,\"1494\":2,\"1497\":2}}],[\"concurrent\",{\"0\":{\"1631\":1},\"1\":{\"1356\":4,\"1357\":1,\"1375\":1,\"1492\":7,\"1494\":5,\"1495\":1,\"1496\":1,\"1497\":18,\"1498\":1}}],[\"concurrenthashmap键的集合就是一个并发的元\",{\"1\":{\"1497\":1}}],[\"concurrenthashmap扩容采用的是多线程的方式\",{\"1\":{\"1431\":1}}],[\"concurrenthashmap新增的核心方法有两个\",{\"1\":{\"1431\":1}}],[\"concurrenthashmap\",{\"1\":{\"1430\":5,\"1431\":12,\"1495\":1,\"1496\":1,\"1497\":1}}],[\"concurrenthashmap数据结构为一个segment数组\",{\"1\":{\"1430\":1}}],[\"concurrenthashmap的成员变量中\",{\"1\":{\"1430\":1}}],[\"concurrenthashmap的并发度是什么\",{\"0\":{\"78\":1}}],[\"concurrenthashmap源码分析\",{\"0\":{\"1429\":1}}],[\"concurrenthashmap只是在链表的头结点加锁\",{\"1\":{\"1352\":1}}],[\"concurrenthashmap在jdk1\",{\"1\":{\"1352\":1}}],[\"concurrenthashmap是基于node\",{\"1\":{\"1352\":1}}],[\"concurrency的值\",{\"1\":{\"613\":1}}],[\"concurrency=128\",{\"1\":{\"613\":1}}],[\"concurrency=3表示innodb只允许3个线程并发执行\",{\"1\":{\"613\":1}}],[\"concurrency参数的原因\",{\"1\":{\"613\":1}}],[\"concurrency参数的目的是\",{\"1\":{\"613\":1}}],[\"concurrency可以设置为64～128之间的值\",{\"1\":{\"613\":1}}],[\"concurrency这个参数的默认值是0\",{\"1\":{\"613\":1}}],[\"concurrency\",{\"1\":{\"613\":1,\"618\":1,\"677\":1}}],[\"concatenate\",{\"1\":{\"1493\":1}}],[\"concatenates\",{\"1\":{\"1485\":1}}],[\"concatenating\",{\"1\":{\"1492\":1}}],[\"concat\",{\"1\":{\"556\":1,\"559\":1,\"655\":1,\"1485\":2}}],[\"contain\",{\"1\":{\"1497\":2}}],[\"containingbd\",{\"1\":{\"1524\":6}}],[\"containing\",{\"1\":{\"1496\":1}}],[\"contained\",{\"1\":{\"1492\":1,\"1524\":1}}],[\"containers\",{\"1\":{\"1492\":1,\"1498\":1}}],[\"container\",{\"1\":{\"1485\":4,\"1492\":15,\"1494\":9,\"1495\":2,\"1561\":1}}],[\"containssingleton\",{\"1\":{\"1525\":1}}],[\"containsbean\",{\"1\":{\"1525\":2}}],[\"containsbeandefinition\",{\"1\":{\"1524\":1,\"1525\":1}}],[\"containskey\",{\"1\":{\"359\":1,\"380\":1,\"386\":1,\"1434\":1}}],[\"contains\",{\"1\":{\"0\":1,\"302\":3,\"381\":1,\"417\":3,\"1434\":1,\"1494\":4,\"1495\":3,\"1497\":1,\"1498\":1}}],[\"contextloader\",{\"1\":{\"1535\":1}}],[\"contextloads\",{\"1\":{\"720\":1}}],[\"contextrefresh\",{\"1\":{\"1524\":2,\"1528\":2}}],[\"context\",{\"1\":{\"568\":1,\"1509\":4,\"1510\":3,\"1511\":3,\"1512\":4,\"1514\":2,\"1524\":12,\"1528\":4,\"1529\":2,\"1535\":1}}],[\"contention\",{\"1\":{\"1357\":1}}],[\"contents\",{\"1\":{\"806\":5,\"1492\":1,\"1497\":1}}],[\"content\",{\"0\":{\"2\":1},\"1\":{\"302\":14}}],[\"continue\",{\"1\":{\"366\":1,\"417\":3}}],[\"contrast\",{\"1\":{\"1496\":1}}],[\"controlled\",{\"1\":{\"1496\":1}}],[\"controlling\",{\"1\":{\"4\":1}}],[\"control\",{\"1\":{\"677\":1,\"1497\":2,\"1500\":1}}],[\"contributor\",{\"1\":{\"6\":1}}],[\"ajp\",{\"1\":{\"1565\":1}}],[\"aid\",{\"1\":{\"1497\":1}}],[\"aioclienthandler\",{\"1\":{\"1452\":3}}],[\"aio要比bio简单\",{\"1\":{\"1452\":1}}],[\"aio\",{\"0\":{\"1452\":1},\"1\":{\"1453\":1}}],[\"a表示下游收集器的中间结果容器类型\",{\"1\":{\"1495\":1}}],[\"a类型表示汇聚操作的可变的累积类型\",{\"1\":{\"1492\":1}}],[\"a>类型的\",{\"1\":{\"1495\":1}}],[\"a>类型\",{\"1\":{\"1495\":2}}],[\"a>>mapmerger\",{\"1\":{\"1495\":1}}],[\"a>>\",{\"1\":{\"1495\":3}}],[\"a>\",{\"1\":{\"1474\":1,\"1475\":3,\"1476\":2,\"1477\":1,\"1478\":1,\"1485\":8,\"1492\":1,\"1494\":1,\"1495\":5}}],[\"a>=4\",{\"1\":{\"591\":1}}],[\"a<100000\",{\"1\":{\"1468\":1}}],[\"a<sup>\",{\"1\":{\"605\":4}}],[\"a++\",{\"1\":{\"1468\":2}}],[\"awt\",{\"1\":{\"1468\":4}}],[\"awaitsingleornull\",{\"1\":{\"1532\":1}}],[\"await\",{\"1\":{\"1379\":2,\"1380\":2,\"1407\":1}}],[\"await方法而阻塞的线程\",{\"1\":{\"1370\":2}}],[\"await方法的时候必须持有锁\",{\"1\":{\"1370\":1}}],[\"await方法会释放当前持有的锁\",{\"1\":{\"1370\":1}}],[\"aqs中条件队列是使用单向列表保存的\",{\"1\":{\"1369\":1}}],[\"aqs中的await和signal\",{\"1\":{\"1354\":1}}],[\"aqs则会将当前线程已经等待状态信息构造成一个节点\",{\"1\":{\"1368\":1}}],[\"aqs依赖clh同步队列来完成同步状态的管理\",{\"1\":{\"1368\":1}}],[\"aqs当中的同步等待队列也称clh队列\",{\"1\":{\"1368\":1}}],[\"aqs定义了5个队列中节点的状态\",{\"1\":{\"1367\":1}}],[\"aqs定义两种资源共享方式\",{\"1\":{\"1367\":1}}],[\"aqs内部维护属性volatile\",{\"1\":{\"1367\":1}}],[\"aqs具备的特性\",{\"1\":{\"1367\":1}}],[\"aqs是一个抽象同步框架\",{\"1\":{\"1367\":1}}],[\"aqs的核心\",{\"1\":{\"1367\":1}}],[\"aqs与reentrantlock实现原理\",{\"0\":{\"1367\":1}}],[\"aqs如何实现可重入锁\",{\"0\":{\"76\":1}}],[\"advantages\",{\"1\":{\"1497\":1}}],[\"advised\",{\"1\":{\"1531\":2}}],[\"advisedsupportlistener\",{\"0\":{\"966\":1}}],[\"advisedsupport\",{\"0\":{\"962\":1}}],[\"advisors\",{\"1\":{\"1531\":4}}],[\"advisoradapterregistry\",{\"1\":{\"1531\":1}}],[\"advisoradapter接口\",{\"0\":{\"957\":1}}],[\"advisor\",{\"0\":{\"987\":1},\"1\":{\"1531\":10}}],[\"advisorchainfactory接口\",{\"0\":{\"963\":1}}],[\"advisor接口\",{\"0\":{\"954\":1}}],[\"advicemethodcomparator\",{\"1\":{\"1531\":1}}],[\"advicekindcomparator\",{\"1\":{\"1531\":2}}],[\"advice的底层是通过methodinterceptor来实现的\",{\"1\":{\"1531\":1}}],[\"advice标准实现\",{\"0\":{\"950\":1,\"952\":1}}],[\"advice\",{\"0\":{\"930\":1,\"932\":1,\"933\":1,\"935\":1,\"936\":1,\"951\":1,\"953\":1,\"982\":1,\"983\":1,\"984\":1,\"985\":1,\"986\":1,\"991\":1}}],[\"advice类型\",{\"0\":{\"916\":1}}],[\"adapter负责提供servletrequest对象给容器\",{\"1\":{\"1565\":1}}],[\"adapter\",{\"1\":{\"1532\":3}}],[\"adapted\",{\"1\":{\"1497\":1}}],[\"adaptbeaninstance\",{\"1\":{\"1524\":1}}],[\"adapt\",{\"1\":{\"1495\":1}}],[\"adapts\",{\"1\":{\"1495\":2}}],[\"adhere\",{\"1\":{\"1492\":1}}],[\"addelapsedtimefrom\",{\"1\":{\"1540\":1}}],[\"added\",{\"1\":{\"1497\":1}}],[\"addtime\",{\"1\":{\"1540\":1}}],[\"addtopendingcount\",{\"1\":{\"1497\":1}}],[\"addmapping\",{\"1\":{\"1535\":1}}],[\"addmethodname\",{\"1\":{\"1531\":1}}],[\"addservlet\",{\"1\":{\"1535\":1}}],[\"addsingletonfactory\",{\"1\":{\"1524\":1,\"1526\":1}}],[\"addcandidateentry\",{\"1\":{\"1525\":3}}],[\"addcount方法的源码如下\",{\"1\":{\"1431\":1}}],[\"addcount\",{\"1\":{\"1431\":3}}],[\"adddiscoverer\",{\"1\":{\"1525\":2}}],[\"addadvice\",{\"1\":{\"1531\":1}}],[\"addall\",{\"1\":{\"1485\":5,\"1486\":1,\"1492\":1,\"1494\":3,\"1495\":3,\"1525\":1,\"1531\":3}}],[\"addactionlistener\",{\"1\":{\"1468\":2}}],[\"addition\",{\"1\":{\"1492\":1,\"1496\":1,\"1497\":2}}],[\"additionally\",{\"1\":{\"1497\":2,\"1500\":1}}],[\"additional\",{\"1\":{\"491\":1,\"657\":1,\"1485\":4,\"1492\":1,\"1495\":1,\"1497\":1,\"1500\":1}}],[\"adding\",{\"1\":{\"1431\":1}}],[\"add方法的逻辑如下图\",{\"1\":{\"1357\":1}}],[\"add方法会抛出非法一场\",{\"1\":{\"1353\":1}}],[\"addworker\",{\"1\":{\"1353\":3}}],[\"addword\",{\"1\":{\"302\":1}}],[\"addl\",{\"1\":{\"1350\":1}}],[\"address\",{\"1\":{\"1488\":1}}],[\"addr\",{\"1\":{\"710\":1,\"1356\":5,\"1394\":4}}],[\"add\",{\"1\":{\"1\":1,\"3\":1,\"4\":1,\"302\":1,\"354\":1,\"366\":2,\"373\":1,\"380\":1,\"381\":1,\"395\":5,\"396\":2,\"399\":2,\"400\":1,\"401\":2,\"402\":2,\"403\":2,\"404\":1,\"409\":4,\"415\":1,\"417\":5,\"441\":1,\"487\":2,\"489\":2,\"493\":2,\"505\":3,\"508\":2,\"546\":1,\"554\":2,\"578\":2,\"711\":7,\"806\":2,\"1357\":1,\"1377\":1,\"1378\":2,\"1394\":3,\"1415\":1,\"1434\":1,\"1468\":2,\"1475\":1,\"1485\":5,\"1486\":1,\"1488\":1,\"1489\":1,\"1492\":1,\"1494\":5,\"1495\":4,\"1498\":1,\"1524\":5,\"1525\":3,\"1529\":4,\"1531\":1,\"1567\":2}}],[\"aop参照了aspectj的实现\",{\"1\":{\"1531\":1}}],[\"aop还有一种aspectj的实现\",{\"1\":{\"1531\":1}}],[\"aop源码解析\",{\"0\":{\"1531\":1}}],[\"aop大致的实现原理\",{\"1\":{\"1507\":1}}],[\"aop底层原理\",{\"1\":{\"1507\":1}}],[\"aop与ioc功能整合的设计模式\",{\"0\":{\"1028\":1}}],[\"aop在spring\",{\"0\":{\"1026\":1}}],[\"aoputils\",{\"0\":{\"976\":1}}],[\"aopcontext\",{\"0\":{\"974\":1}}],[\"aopinfrastructurebean接口\",{\"0\":{\"973\":1}}],[\"aopproxyutils\",{\"0\":{\"975\":1}}],[\"aopproxy实现\",{\"0\":{\"960\":1,\"961\":1}}],[\"aopproxyfactory\",{\"0\":{\"959\":1}}],[\"aopproxy接口\",{\"0\":{\"958\":1}}],[\"aop三种实现方式是如何进行设计的\",{\"0\":{\"942\":1}}],[\"aop支持哪些类型的advice\",{\"0\":{\"940\":1}}],[\"aop存在哪些差别\",{\"0\":{\"922\":1}}],[\"aop和aspectj\",{\"0\":{\"922\":1}}],[\"aop代理实现\",{\"0\":{\"917\":1}}],[\"aop编程模型有哪些\",{\"0\":{\"941\":1}}],[\"aop编程模型\",{\"0\":{\"915\":1}}],[\"aop设计核心\",{\"0\":{\"914\":1}}],[\"aop设计模式\",{\"0\":{\"909\":1}}],[\"aop常见使用场景\",{\"0\":{\"904\":1}}],[\"aop\",{\"0\":{\"897\":1,\"913\":1,\"916\":1,\"991\":1},\"1\":{\"1843\":1,\"1844\":1,\"1860\":1}}],[\"aof运行效率也要比rdb慢\",{\"1\":{\"730\":1}}],[\"aof远远大于rdb\",{\"1\":{\"730\":1}}],[\"aof默认是不开启的\",{\"1\":{\"729\":1}}],[\"aof表示append\",{\"1\":{\"728\":1}}],[\"aof子进程\",{\"1\":{\"725\":1}}],[\"aof\",{\"0\":{\"732\":1},\"1\":{\"702\":1,\"729\":2,\"732\":1,\"733\":2}}],[\"amount\",{\"1\":{\"1497\":1}}],[\"among\",{\"1\":{\"1497\":1}}],[\"am\",{\"1\":{\"735\":3}}],[\"amaze\",{\"1\":{\"711\":6}}],[\"apache\",{\"0\":{\"834\":1},\"1\":{\"806\":4}}],[\"api构建的原始web框架\",{\"1\":{\"1533\":1}}],[\"api\",{\"1\":{\"1497\":1,\"1852\":1,\"1864\":1}}],[\"apinote\",{\"1\":{\"1485\":1}}],[\"api整体设计\",{\"0\":{\"943\":1}}],[\"api实现after\",{\"0\":{\"936\":1}}],[\"api实现before\",{\"0\":{\"933\":1}}],[\"api实现pointcut\",{\"0\":{\"928\":1}}],[\"api接口层\",{\"1\":{\"806\":1}}],[\"api就是用来解决这个问题的\",{\"1\":{\"740\":1}}],[\"api和我们的指令是一样的\",{\"1\":{\"720\":1}}],[\"appclassloader\",{\"1\":{\"1569\":1}}],[\"appconfig\",{\"1\":{\"1509\":1,\"1510\":1,\"1511\":1,\"1522\":2}}],[\"appropriate\",{\"1\":{\"1498\":1}}],[\"approximately\",{\"1\":{\"1497\":3}}],[\"approximate\",{\"1\":{\"1497\":1}}],[\"applied\",{\"1\":{\"1475\":6,\"1492\":1,\"1494\":1,\"1495\":2}}],[\"applies\",{\"1\":{\"1475\":26,\"1500\":1}}],[\"applicable\",{\"1\":{\"656\":1,\"657\":2,\"1524\":2}}],[\"applicationstartup\",{\"1\":{\"1524\":3,\"1528\":2}}],[\"applicationcontextexception\",{\"1\":{\"1528\":1}}],[\"applicationcontext的典型实现\",{\"1\":{\"1514\":1}}],[\"applicationcontext提供了如下功能\",{\"1\":{\"1514\":1}}],[\"applicationcontext\",{\"0\":{\"1514\":1}}],[\"applicationcontext除了beanfactory提供的基础功能外\",{\"1\":{\"1513\":1}}],[\"applicationcontext继承了beanfactory\",{\"1\":{\"1513\":1}}],[\"applicationlistener\",{\"0\":{\"1275\":1}}],[\"applicationeventpublisher\",{\"1\":{\"1514\":1}}],[\"applicationeventpublisher底层实现\",{\"0\":{\"1283\":1}}],[\"applicationevent\",{\"0\":{\"1272\":1}}],[\"application作用域\",{\"0\":{\"1149\":1},\"1\":{\"1524\":1}}],[\"application\",{\"0\":{\"1154\":1},\"1\":{\"609\":1,\"616\":1,\"1486\":1,\"1532\":2}}],[\"applypropertyvalues\",{\"1\":{\"1524\":1}}],[\"applymergedbeandefinitionpostprocessors\",{\"1\":{\"1524\":1}}],[\"applybeanpostprocessorsafterinitialization\",{\"1\":{\"1524\":1}}],[\"applybeanpostprocessorsbeforeinstantiation\",{\"1\":{\"1524\":1}}],[\"applyscopedproxymode\",{\"1\":{\"1524\":1}}],[\"applyasint\",{\"1\":{\"1491\":2,\"1495\":1}}],[\"applying\",{\"1\":{\"1486\":1,\"1495\":1}}],[\"apply\",{\"1\":{\"1475\":30,\"1478\":6,\"1483\":1,\"1486\":1,\"1492\":10,\"1494\":2,\"1495\":11,\"1497\":1,\"1499\":1,\"1524\":1,\"1532\":1}}],[\"applytoeither\",{\"1\":{\"1395\":1}}],[\"apple\",{\"1\":{\"302\":1,\"711\":14}}],[\"appending\",{\"1\":{\"1499\":3}}],[\"append方法都需要加锁和解锁\",{\"1\":{\"1363\":1}}],[\"appendfsync\",{\"1\":{\"729\":3}}],[\"appendfilename\",{\"1\":{\"729\":1}}],[\"appendonly\",{\"1\":{\"729\":2}}],[\"append\",{\"1\":{\"385\":2,\"400\":1,\"409\":5,\"707\":2,\"1363\":4,\"1364\":4,\"1485\":4,\"1495\":2}}],[\"affect\",{\"1\":{\"1497\":2}}],[\"affected\",{\"1\":{\"530\":3,\"565\":1,\"568\":1}}],[\"aftercompletion\",{\"1\":{\"1534\":2}}],[\"afterthrowing的顺序进行执行\",{\"1\":{\"1531\":1}}],[\"afterthrowing\",{\"1\":{\"1531\":1}}],[\"afterreturning\",{\"1\":{\"1531\":3}}],[\"afterreturningadvice\",{\"1\":{\"1531\":1}}],[\"afterprototypecreation\",{\"1\":{\"1524\":2}}],[\"afterpropertiesset\",{\"1\":{\"720\":1}}],[\"aftersingletonsinstantiated\",{\"1\":{\"1524\":2}}],[\"after等注解\",{\"1\":{\"1507\":1}}],[\"after这个function类型的参数\",{\"1\":{\"1475\":1}}],[\"afternodeinsertion\",{\"1\":{\"1426\":1}}],[\"afternodeaccess\",{\"1\":{\"1426\":1}}],[\"after\",{\"0\":{\"952\":1,\"953\":1,\"984\":1,\"985\":1,\"986\":1},\"1\":{\"708\":3,\"761\":2,\"1471\":6,\"1474\":9,\"1475\":36,\"1492\":2,\"1496\":1,\"1497\":9,\"1498\":4,\"1499\":1,\"1500\":4,\"1531\":5}}],[\"a读取的数据无效\",{\"1\":{\"669\":1}}],[\"a=a\",{\"1\":{\"1494\":4}}],[\"a=\",{\"1\":{\"661\":1}}],[\"a=t2\",{\"1\":{\"538\":1,\"540\":1}}],[\"a`\",{\"1\":{\"660\":1}}],[\"a执行select语句的时候\",{\"1\":{\"634\":1}}],[\"a启动的事务ta的低水位就是248\",{\"1\":{\"634\":1}}],[\"a还没有涉及到更新\",{\"1\":{\"634\":1}}],[\"a还只是给id=5这一行加了行锁\",{\"1\":{\"584\":1}}],[\"a所在的线程\",{\"1\":{\"634\":1}}],[\"a来申请自增id得到id=3\",{\"1\":{\"629\":1}}],[\"a往表t1中插入了4行数据\",{\"1\":{\"629\":1}}],[\"available\",{\"1\":{\"1500\":3,\"1525\":1}}],[\"availableprocessors\",{\"1\":{\"1357\":1,\"1450\":1}}],[\"avoid\",{\"1\":{\"1497\":2,\"1524\":1,\"1528\":1}}],[\"avoiding\",{\"1\":{\"1496\":1}}],[\"averagingint\",{\"1\":{\"1493\":1}}],[\"averagingdouble\",{\"1\":{\"1490\":1}}],[\"average\",{\"1\":{\"566\":3,\"1492\":1}}],[\"avg\",{\"1\":{\"616\":1,\"675\":2}}],[\"a与set\",{\"1\":{\"605\":1}}],[\"a判断这个server\",{\"1\":{\"592\":1}}],[\"a加的是间隙锁\",{\"1\":{\"585\":1}}],[\"a加的表锁\",{\"1\":{\"561\":1}}],[\"a提交以后\",{\"1\":{\"584\":1}}],[\"a把所有的行都加上了写锁\",{\"1\":{\"584\":1}}],[\"a事务提交\",{\"1\":{\"584\":1}}],[\"a声明说\",{\"1\":{\"584\":1}}],[\"a在t3时刻执行insert语句的时候\",{\"1\":{\"634\":1}}],[\"a在t1时刻再加上一个更新语句\",{\"1\":{\"584\":1}}],[\"a在myisam引擎中返回的结果是4000\",{\"1\":{\"491\":1}}],[\"a之后的select语句用\",{\"1\":{\"583\":1}}],[\"a里q1语句要锁住所有d=5的行的加锁声明\",{\"1\":{\"584\":1}}],[\"a里执行了三次查询\",{\"1\":{\"583\":1}}],[\"a里面\",{\"1\":{\"561\":1}}],[\"a先启动\",{\"1\":{\"578\":1}}],[\"a要得到1\",{\"1\":{\"571\":1}}],[\"attribute\",{\"1\":{\"1532\":1}}],[\"attempt\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"attempts\",{\"1\":{\"1495\":1}}],[\"attain\",{\"1\":{\"1497\":1}}],[\"attachment\",{\"1\":{\"1452\":12}}],[\"attached\",{\"1\":{\"656\":5,\"690\":1,\"692\":1}}],[\"attaching\",{\"1\":{\"656\":2}}],[\"atomicstampedrerence\",{\"1\":{\"1357\":1}}],[\"atomicstampedreferencetest\",{\"1\":{\"1356\":1}}],[\"atomicstampedreference\",{\"1\":{\"1356\":10}}],[\"atomicreferencefieldupdater\",{\"1\":{\"1357\":1}}],[\"atomicreferencearray\",{\"1\":{\"1357\":1}}],[\"atomicreference\",{\"1\":{\"1357\":1}}],[\"atomicboolean\",{\"1\":{\"1357\":1}}],[\"atomiclongfieldupdater\",{\"1\":{\"1357\":1}}],[\"atomiclongarray\",{\"1\":{\"1357\":1}}],[\"atomiclong\",{\"1\":{\"1357\":1}}],[\"atomic包里提供了一组原子操作类\",{\"1\":{\"1357\":1}}],[\"atomic源码解析\",{\"0\":{\"1357\":1}}],[\"atomicmarkablereference\",{\"1\":{\"1356\":2,\"1357\":1}}],[\"atomic\",{\"1\":{\"1356\":10}}],[\"atomicintegerarray\",{\"1\":{\"1357\":1}}],[\"atomicinteger\",{\"1\":{\"1357\":1,\"1380\":4}}],[\"atomicintegerfieldupdater\",{\"0\":{\"885\":1},\"1\":{\"1357\":1}}],[\"atomicity\",{\"1\":{\"569\":1}}],[\"at\",{\"1\":{\"566\":4,\"588\":6,\"1486\":2,\"1496\":11,\"1497\":4,\"1498\":1,\"1499\":1,\"1524\":3,\"1527\":1}}],[\"a持有整个表t的mdl锁\",{\"1\":{\"562\":1}}],[\"a的\",{\"1\":{\"629\":1}}],[\"a的参数以外\",{\"1\":{\"619\":1}}],[\"a的参数\",{\"1\":{\"619\":2}}],[\"a的位点和a\",{\"1\":{\"604\":1}}],[\"a的mdl读锁还没有释放\",{\"1\":{\"578\":1}}],[\"a的间隙锁\",{\"1\":{\"561\":1}}],[\"a的select语句其实只操作了分区p\",{\"1\":{\"561\":1}}],[\"a的select语句对索引ftime上这两个记录之间的间隙加了锁\",{\"1\":{\"561\":1}}],[\"a的thread\",{\"1\":{\"550\":1}}],[\"a的临时表t1\",{\"1\":{\"550\":1}}],[\"a的线程id是4\",{\"1\":{\"549\":1}}],[\"a和session\",{\"1\":{\"549\":1}}],[\"a和\",{\"1\":{\"549\":1}}],[\"a内有同名的临时表和普通表的时候\",{\"1\":{\"547\":1}}],[\"a创建的临时表t\",{\"1\":{\"547\":1}}],[\"a5\",{\"1\":{\"515\":5}}],[\"a4\",{\"1\":{\"515\":9}}],[\"a3\",{\"1\":{\"515\":6,\"1492\":3}}],[\"a2\",{\"1\":{\"515\":13,\"1492\":6}}],[\"a1\",{\"1\":{\"515\":16,\"1492\":7}}],[\"aggregate\",{\"1\":{\"711\":1,\"1496\":3}}],[\"against\",{\"1\":{\"708\":1,\"748\":2}}],[\"again\",{\"1\":{\"505\":2,\"1492\":3,\"1500\":1}}],[\"ageofperson\",{\"1\":{\"1475\":1}}],[\"age=a\",{\"1\":{\"1403\":1}}],[\"age=0\",{\"1\":{\"1403\":2}}],[\"age=10\",{\"1\":{\"477\":1}}],[\"age字段\",{\"1\":{\"507\":1,\"509\":1}}],[\"age三个字段返回给客户端\",{\"1\":{\"492\":1}}],[\"age三个字段的值\",{\"1\":{\"491\":1,\"493\":1}}],[\"age这三个字段的定义总长度是36\",{\"1\":{\"492\":1}}],[\"age这三个字段\",{\"1\":{\"491\":1}}],[\"age\",{\"1\":{\"476\":3,\"477\":2,\"490\":1,\"491\":1,\"493\":4,\"507\":5,\"508\":2,\"509\":3,\"558\":1,\"647\":4,\"655\":7,\"656\":3,\"706\":13,\"707\":6,\"710\":8,\"1475\":3,\"1477\":5,\"1488\":2,\"1490\":8}}],[\"age`\",{\"1\":{\"475\":1}}],[\"auth\",{\"1\":{\"761\":2}}],[\"authoring的缺点\",{\"0\":{\"1197\":1}}],[\"authoring扩展spring\",{\"0\":{\"1191\":1}}],[\"author\",{\"1\":{\"498\":3,\"1482\":1}}],[\"autoproxyregistrar主要的作用是向spring容器中注册了一个infrastructureadvisorautoproxycreator的bean\",{\"1\":{\"1532\":1}}],[\"autoproxyregistrar\",{\"1\":{\"1532\":1}}],[\"autowried注解来实现\",{\"1\":{\"1507\":1}}],[\"autowiringvalue\",{\"1\":{\"1525\":6}}],[\"autowiringtype\",{\"1\":{\"1525\":2}}],[\"autowireconstructor\",{\"1\":{\"1527\":3}}],[\"autowirecandidateresolver\",{\"1\":{\"1525\":1}}],[\"autowirecapablebeanfactory\",{\"1\":{\"1513\":2}}],[\"autowirenecessary\",{\"1\":{\"1527\":3}}],[\"autowireutils\",{\"1\":{\"1525\":1}}],[\"autowirebytype\",{\"1\":{\"1524\":1}}],[\"autowirebyname\",{\"1\":{\"1524\":1}}],[\"autowire\",{\"1\":{\"1524\":6,\"1527\":1}}],[\"autowired注解制定了某个构造方法\",{\"1\":{\"1527\":1}}],[\"autowired注解的区别在于\",{\"1\":{\"1525\":1}}],[\"autowired注解的实现类\",{\"1\":{\"1525\":1}}],[\"autowired是spring的注解\",{\"1\":{\"1525\":1}}],[\"autowiredbeanname\",{\"1\":{\"1525\":12}}],[\"autowiredbeannames\",{\"1\":{\"1525\":11}}],[\"autowiredmethodelement\",{\"1\":{\"1525\":2}}],[\"autowiredfieldelement\",{\"1\":{\"1525\":1}}],[\"autowiredannotationtypes\",{\"1\":{\"1525\":1}}],[\"autowiredannotationbeanpostprocessor\",{\"1\":{\"1525\":3}}],[\"autowired联系\",{\"0\":{\"1126\":1}}],[\"autowired\",{\"1\":{\"720\":1,\"1525\":4}}],[\"autowird注入\",{\"0\":{\"1125\":1}}],[\"automatically\",{\"1\":{\"1496\":1}}],[\"autocloseabletest\",{\"1\":{\"1496\":5}}],[\"autocloseable\",{\"1\":{\"1496\":5}}],[\"autocommit=flase\",{\"1\":{\"1532\":1}}],[\"autocommit=false\",{\"1\":{\"1507\":1}}],[\"autocommit\",{\"1\":{\"572\":3}}],[\"autosave\",{\"1\":{\"1408\":1}}],[\"autoinc\",{\"1\":{\"629\":3}}],[\"auto\",{\"1\":{\"467\":1,\"472\":1,\"498\":1,\"499\":2,\"500\":1,\"515\":1,\"556\":1,\"596\":1,\"605\":2,\"609\":1,\"626\":1,\"627\":2,\"628\":1,\"631\":4,\"643\":1,\"647\":2,\"655\":2,\"660\":1,\"671\":1,\"672\":1,\"696\":9}}],[\"a排序\",{\"1\":{\"485\":1}}],[\"a开启一个事务\",{\"1\":{\"483\":1}}],[\"aaa\",{\"1\":{\"1363\":1,\"1364\":1,\"1496\":7}}],[\"aaaaaaac\",{\"1\":{\"505\":5}}],[\"aaaaaaab\",{\"1\":{\"505\":5}}],[\"aaaaaaaa\",{\"1\":{\"505\":4,\"605\":3}}],[\"aa3\",{\"1\":{\"690\":2}}],[\"aa2\",{\"1\":{\"690\":2}}],[\"aa1\",{\"1\":{\"690\":2}}],[\"aa\",{\"1\":{\"473\":1}}],[\"along\",{\"1\":{\"1525\":1}}],[\"algorithms\",{\"1\":{\"1497\":3}}],[\"already\",{\"1\":{\"1487\":1,\"1495\":1,\"1499\":2,\"1500\":1,\"1524\":3,\"1528\":1}}],[\"alibaba框架开发教程\",{\"1\":{\"1867\":1}}],[\"alibaba<\",{\"1\":{\"719\":1}}],[\"aliasregistry\",{\"1\":{\"1513\":1}}],[\"alias\",{\"1\":{\"485\":1}}],[\"al\",{\"1\":{\"566\":2}}],[\"always\",{\"1\":{\"554\":1,\"729\":1,\"1475\":4,\"1495\":1,\"1496\":1,\"1497\":1}}],[\"alternatives\",{\"1\":{\"656\":4}}],[\"alter\",{\"1\":{\"487\":2,\"489\":1,\"493\":2,\"505\":1,\"527\":2,\"546\":1,\"554\":1,\"578\":2,\"695\":2,\"696\":1}}],[\"allocation\",{\"1\":{\"1545\":1}}],[\"allocate\",{\"1\":{\"1451\":4,\"1452\":4}}],[\"allocatedirect\",{\"1\":{\"1410\":1,\"1411\":1}}],[\"allowed\",{\"1\":{\"1527\":1}}],[\"alloweagerinit\",{\"1\":{\"1524\":1}}],[\"allowcaching\",{\"1\":{\"1524\":2}}],[\"allowcircularreferences\",{\"1\":{\"1524\":1,\"1526\":1}}],[\"allowrawinjectiondespitewrapping\",{\"1\":{\"1524\":1}}],[\"allowing\",{\"1\":{\"1497\":1}}],[\"allows\",{\"1\":{\"1495\":1,\"1524\":1}}],[\"allow\",{\"1\":{\"1492\":1,\"1524\":3}}],[\"all的话\",{\"1\":{\"551\":1}}],[\"all全表扫描\",{\"1\":{\"507\":2}}],[\"all是从磁盘中读取的\",{\"1\":{\"467\":1}}],[\"all\",{\"1\":{\"466\":1,\"467\":1,\"498\":1,\"527\":2,\"566\":2,\"568\":1,\"1472\":2,\"1478\":2,\"1492\":1,\"1496\":3,\"1497\":3,\"1498\":2,\"1500\":3,\"1524\":2}}],[\"also\",{\"1\":{\"2\":1,\"3\":1,\"1357\":1,\"1471\":2,\"1492\":1,\"1494\":1,\"1497\":3,\"1498\":1,\"1500\":2,\"1524\":1}}],[\"ahead\",{\"1\":{\"461\":1}}],[\"acl权限管理器\",{\"0\":{\"1833\":1}}],[\"acl权限控制\",{\"0\":{\"1825\":1}}],[\"aclclientrpchook\",{\"0\":{\"1828\":1}}],[\"across\",{\"1\":{\"1497\":3}}],[\"achieve\",{\"1\":{\"1492\":1}}],[\"achild\",{\"1\":{\"302\":6}}],[\"actualclass\",{\"1\":{\"1531\":6}}],[\"actualdependentbeans\",{\"1\":{\"1524\":4}}],[\"actual\",{\"1\":{\"1497\":1}}],[\"actually\",{\"1\":{\"1496\":1,\"1524\":2,\"1527\":1}}],[\"action会被适配成intconsumer实例\",{\"1\":{\"1497\":1}}],[\"action会以遇到元素的顺序去执行\",{\"1\":{\"1497\":1}}],[\"actions\",{\"1\":{\"1472\":2,\"1497\":1}}],[\"action\",{\"1\":{\"1470\":1,\"1471\":3,\"1472\":13,\"1497\":39,\"1498\":6,\"1499\":14,\"1500\":5}}],[\"actionperformed\",{\"1\":{\"1468\":1}}],[\"actionlistener\",{\"1\":{\"1468\":3}}],[\"actionevent\",{\"1\":{\"1468\":3}}],[\"active\",{\"1\":{\"746\":1,\"1500\":3,\"1524\":1,\"1528\":1}}],[\"actory\",{\"1\":{\"1500\":1}}],[\"actor`\",{\"1\":{\"643\":3}}],[\"actor\",{\"1\":{\"521\":5,\"527\":11,\"643\":1,\"646\":3}}],[\"acb\",{\"1\":{\"693\":1}}],[\"accurate\",{\"1\":{\"1497\":2}}],[\"accuracy\",{\"1\":{\"1497\":1}}],[\"accumulation\",{\"1\":{\"1492\":4,\"1495\":1}}],[\"accumulatingsink<t\",{\"1\":{\"1494\":1}}],[\"accumulating\",{\"1\":{\"1492\":1,\"1493\":1}}],[\"accumulated\",{\"1\":{\"1492\":5}}],[\"accumulates\",{\"1\":{\"1492\":2}}],[\"accumulate\",{\"1\":{\"1485\":1,\"1492\":2,\"1493\":2}}],[\"accumulator方法只能进行累积的操作\",{\"1\":{\"1494\":1}}],[\"accumulator是我们要把流中的元素添加到要返回的结果容器当中\",{\"1\":{\"1485\":1}}],[\"accumulator\",{\"1\":{\"1485\":9,\"1492\":21,\"1493\":8,\"1494\":13,\"1495\":10}}],[\"accmulator\",{\"1\":{\"1494\":52}}],[\"according\",{\"1\":{\"1476\":4,\"1478\":5,\"1490\":1,\"1493\":1,\"1495\":1}}],[\"account\",{\"1\":{\"672\":1,\"673\":1}}],[\"accepting\",{\"1\":{\"1490\":1,\"1495\":2,\"1500\":1}}],[\"accepts\",{\"1\":{\"1474\":2,\"1475\":3,\"1492\":1,\"1500\":7}}],[\"acceptcompletionhandler\",{\"1\":{\"1452\":3}}],[\"accept\",{\"1\":{\"1410\":1,\"1411\":1,\"1450\":2,\"1451\":2,\"1452\":2,\"1471\":7,\"1472\":2,\"1474\":6,\"1485\":3,\"1492\":5,\"1494\":3,\"1495\":4,\"1496\":1,\"1497\":9,\"1499\":3,\"1500\":9,\"1531\":1}}],[\"accepteither\",{\"1\":{\"1395\":1}}],[\"accesscontroller\",{\"1\":{\"1524\":2}}],[\"accesses\",{\"1\":{\"1499\":1}}],[\"accessing\",{\"1\":{\"1497\":1}}],[\"access=on\",{\"1\":{\"542\":1}}],[\"access\",{\"0\":{\"542\":1},\"1\":{\"455\":1,\"656\":7,\"690\":1,\"692\":2,\"1419\":1,\"1496\":2,\"1500\":1,\"1527\":1}}],[\"acess\",{\"1\":{\"542\":1}}],[\"academy\",{\"1\":{\"521\":1}}],[\"able\",{\"1\":{\"1524\":1}}],[\"above\",{\"1\":{\"1496\":2}}],[\"about\",{\"1\":{\"1492\":1,\"1497\":1,\"1500\":3}}],[\"abortpolicy\",{\"1\":{\"1353\":1}}],[\"aba问题比较重要\",{\"1\":{\"1356\":1}}],[\"aba问题示例\",{\"1\":{\"1356\":1}}],[\"aba问题\",{\"1\":{\"1356\":1}}],[\"aba\",{\"1\":{\"1356\":1}}],[\"abc索引失效会变成全表扫描\",{\"1\":{\"506\":1}}],[\"abc\",{\"1\":{\"400\":1,\"711\":6,\"1403\":2}}],[\"abstractaspectjadvisorfactory\",{\"1\":{\"1531\":1}}],[\"abstractautowirecapablebeanfactory\",{\"1\":{\"1513\":1,\"1528\":1}}],[\"abstractautoproxycreator\",{\"0\":{\"970\":1}}],[\"abstractflag是beandefinition的内部属性\",{\"1\":{\"1524\":1}}],[\"abstractbeanfactory\",{\"1\":{\"1513\":1,\"1524\":2}}],[\"abstractbeandefinition\",{\"1\":{\"1509\":1,\"1524\":3}}],[\"abstract<p\",{\"1\":{\"1500\":3}}],[\"abstractpipeline<e\",{\"1\":{\"1500\":1}}],[\"abstractpipeline<\",{\"1\":{\"1499\":3}}],[\"abstractpipeline包含了大多数计算管道的机制\",{\"1\":{\"1498\":1}}],[\"abstractpipeline代表了流管道初始的阶段\",{\"1\":{\"1498\":1}}],[\"abstractpipeline是对于管道类抽象出来的一个父类\",{\"1\":{\"1498\":1}}],[\"abstractpipeline的说明如下\",{\"1\":{\"1498\":1}}],[\"abstractpipeline\",{\"1\":{\"1496\":4,\"1498\":7,\"1499\":1,\"1500\":2}}],[\"abstractset<map\",{\"1\":{\"1495\":1}}],[\"abstractmap<boolean\",{\"1\":{\"1495\":1}}],[\"abstract\",{\"1\":{\"566\":2,\"1471\":9,\"1498\":2,\"1499\":1,\"1500\":4}}],[\"abs\",{\"1\":{\"362\":2,\"368\":1,\"408\":1}}],[\"ab发布要怎么做\",{\"0\":{\"237\":1}}],[\"ann\",{\"1\":{\"1525\":6,\"1531\":3}}],[\"annotatedbeandefinition\",{\"1\":{\"1524\":3}}],[\"annotatedbeandefinitionreader可以直接把某个类转换为beandefition\",{\"1\":{\"1510\":1}}],[\"annotatedbeandefinitionreader\",{\"0\":{\"1510\":1},\"1\":{\"1510\":4,\"1524\":1,\"1528\":1}}],[\"annotatedgenericbeandefinition\",{\"1\":{\"1509\":1}}],[\"annotated\",{\"1\":{\"1471\":4,\"1524\":1,\"1528\":1}}],[\"annotationtransactionattributesource就是用来判断某个类上是否存在\",{\"1\":{\"1532\":1}}],[\"annotationtransactionattributesource\",{\"1\":{\"1532\":1}}],[\"annotationtype\",{\"1\":{\"1523\":2}}],[\"annotation>\",{\"1\":{\"1531\":1}}],[\"annotationutils\",{\"1\":{\"1525\":1}}],[\"annotationconfigutils\",{\"1\":{\"1524\":2}}],[\"annotationconfigapplicationcontext\",{\"1\":{\"1509\":2,\"1510\":2,\"1511\":2,\"1512\":2,\"1514\":1,\"1524\":1,\"1528\":1}}],[\"annotationmetadata\",{\"0\":{\"1523\":1},\"1\":{\"1523\":3,\"1524\":1}}],[\"annotationawareordercomparator\",{\"1\":{\"1518\":1}}],[\"annotation\",{\"1\":{\"1471\":9,\"1509\":2,\"1514\":1,\"1525\":5,\"1529\":2,\"1532\":1,\"1535\":1}}],[\"another\",{\"1\":{\"1476\":4,\"1491\":1,\"1495\":1,\"1496\":1,\"1497\":3,\"1500\":1,\"1535\":1}}],[\"anonymoustest\",{\"1\":{\"1468\":2}}],[\"anonymous\",{\"1\":{\"591\":1}}],[\"anymore\",{\"1\":{\"1524\":1,\"1528\":1}}],[\"anything\",{\"1\":{\"1492\":1,\"1525\":1}}],[\"any\",{\"1\":{\"1471\":5,\"1492\":6,\"1496\":1,\"1497\":5,\"1499\":1,\"1500\":3,\"1524\":2,\"1567\":1}}],[\"analyze\",{\"1\":{\"696\":2}}],[\"analyzing\",{\"1\":{\"656\":4}}],[\"analysis\",{\"1\":{\"656\":2}}],[\"antlr从语法生成一个解析器\",{\"1\":{\"650\":1}}],[\"an\",{\"1\":{\"457\":1,\"710\":1,\"717\":1,\"1471\":18,\"1472\":4,\"1474\":4,\"1475\":6,\"1476\":4,\"1478\":2,\"1485\":9,\"1486\":2,\"1492\":11,\"1494\":2,\"1495\":3,\"1496\":10,\"1497\":22,\"1498\":6,\"1499\":6,\"1500\":9}}],[\"answer\",{\"1\":{\"1450\":3,\"1451\":1,\"1452\":1}}],[\"ans\",{\"1\":{\"362\":4,\"363\":5,\"385\":4,\"393\":4,\"401\":4,\"402\":4,\"403\":4,\"404\":4,\"409\":21,\"410\":3,\"411\":7,\"438\":3}}],[\"anded\",{\"1\":{\"1476\":2}}],[\"andthen\",{\"1\":{\"1471\":2,\"1474\":1,\"1475\":9,\"1495\":1}}],[\"and\",{\"0\":{\"4\":1},\"1\":{\"2\":1,\"385\":1,\"458\":1,\"467\":2,\"473\":1,\"475\":1,\"477\":2,\"483\":4,\"484\":3,\"485\":3,\"498\":3,\"503\":3,\"505\":3,\"507\":5,\"509\":4,\"510\":4,\"514\":14,\"515\":28,\"541\":1,\"544\":2,\"545\":1,\"546\":1,\"566\":2,\"572\":2,\"591\":1,\"651\":1,\"655\":2,\"673\":1,\"681\":5,\"684\":6,\"686\":4,\"690\":9,\"691\":6,\"692\":12,\"1357\":1,\"1375\":1,\"1471\":3,\"1474\":2,\"1475\":23,\"1476\":15,\"1478\":3,\"1485\":5,\"1488\":1,\"1490\":1,\"1492\":18,\"1493\":2,\"1494\":1,\"1495\":4,\"1496\":19,\"1497\":46,\"1498\":11,\"1499\":2,\"1500\":30,\"1524\":3,\"1527\":1}}],[\"a^\",{\"1\":{\"314\":1}}],[\"a^c\",{\"1\":{\"314\":1}}],[\"a^b^c\",{\"1\":{\"314\":1}}],[\"a^b\",{\"1\":{\"314\":2}}],[\"arbitrarily\",{\"1\":{\"1497\":1}}],[\"arbitrary\",{\"1\":{\"1497\":4}}],[\"arity\",{\"1\":{\"1475\":1}}],[\"around等注解的方法\",{\"1\":{\"1531\":1}}],[\"around\",{\"0\":{\"982\":1},\"1\":{\"1531\":1}}],[\"arg\",{\"1\":{\"1527\":1}}],[\"arguments\",{\"1\":{\"1475\":2,\"1476\":6,\"1478\":2,\"1485\":2,\"1492\":1}}],[\"argument\",{\"1\":{\"734\":2,\"1474\":4,\"1475\":12,\"1476\":8,\"1478\":2,\"1492\":3,\"1497\":1}}],[\"args\",{\"1\":{\"329\":4,\"717\":1,\"719\":2,\"1356\":1,\"1364\":1,\"1398\":1,\"1412\":1,\"1428\":1,\"1464\":1,\"1465\":1,\"1468\":3,\"1469\":1,\"1470\":6,\"1471\":1,\"1472\":6,\"1474\":2,\"1475\":6,\"1476\":4,\"1477\":3,\"1478\":1,\"1479\":1,\"1480\":2,\"1481\":2,\"1482\":2,\"1483\":2,\"1484\":10,\"1485\":3,\"1486\":11,\"1487\":8,\"1489\":3,\"1490\":1,\"1491\":1,\"1492\":1,\"1494\":2,\"1496\":2,\"1497\":2,\"1523\":1,\"1524\":15,\"1527\":5,\"1531\":6}}],[\"artifactid>\",{\"1\":{\"719\":2,\"720\":1}}],[\"article\",{\"1\":{\"467\":1,\"498\":14,\"698\":1,\"1526\":1}}],[\"ar\",{\"1\":{\"566\":2}}],[\"arrayblockingqueue<runnable>\",{\"1\":{\"1450\":1}}],[\"arrayblockingqueue<task>\",{\"1\":{\"1412\":2}}],[\"arrayblockingqueue是典型的有界阻塞队列\",{\"1\":{\"1379\":1}}],[\"arrayblockingqueue\",{\"0\":{\"1379\":1},\"1\":{\"1378\":1,\"1379\":2}}],[\"arraylist中维护了一个object类型的数组elementdata\",{\"1\":{\"1419\":1}}],[\"arraylist源码分析\",{\"0\":{\"1419\":1}}],[\"arraylist的扩容机制\",{\"1\":{\"1352\":1}}],[\"arraylist的实现原理\",{\"0\":{\"47\":1}}],[\"arraylist\",{\"1\":{\"806\":2,\"1416\":1,\"1485\":13,\"1486\":1,\"1495\":2,\"1497\":1}}],[\"arraylist<string>\",{\"1\":{\"417\":1,\"1485\":1,\"1486\":1}}],[\"arraylist<list<string>>\",{\"1\":{\"417\":1}}],[\"arraylist<integer>\",{\"1\":{\"399\":1}}],[\"arraylist<>\",{\"1\":{\"366\":1,\"380\":2,\"395\":4,\"399\":2,\"400\":1,\"401\":2,\"402\":2,\"403\":2,\"404\":1,\"409\":4,\"806\":1,\"1394\":1,\"1488\":1,\"1489\":1,\"1524\":1,\"1525\":2,\"1531\":1}}],[\"array\",{\"1\":{\"329\":4,\"1437\":1,\"1484\":3,\"1496\":1,\"1497\":9}}],[\"arrays\",{\"1\":{\"316\":1,\"329\":2,\"362\":1,\"366\":3,\"380\":1,\"387\":4,\"417\":2,\"422\":2,\"1352\":1,\"1470\":6,\"1471\":1,\"1472\":1,\"1474\":2,\"1475\":1,\"1476\":2,\"1479\":1,\"1480\":3,\"1481\":1,\"1482\":2,\"1484\":4,\"1485\":1,\"1486\":10,\"1487\":2,\"1489\":2,\"1490\":1,\"1491\":1,\"1492\":1,\"1494\":2,\"1495\":1,\"1496\":2,\"1497\":1,\"1531\":3}}],[\"area\",{\"1\":{\"368\":2}}],[\"are\",{\"1\":{\"4\":1,\"566\":1,\"1471\":4,\"1472\":4,\"1476\":8,\"1478\":2,\"1485\":6,\"1490\":1,\"1492\":5,\"1493\":1,\"1495\":3,\"1496\":11,\"1497\":17,\"1498\":4,\"1500\":6,\"1524\":1,\"1567\":1}}],[\"asplatformtransactionmanager\",{\"1\":{\"1532\":1}}],[\"aspect注解扫描到spring容器中\",{\"1\":{\"1531\":1}}],[\"aspect\",{\"0\":{\"980\":1}}],[\"aspect后置动作\",{\"0\":{\"934\":1}}],[\"aspectjannotation<\",{\"1\":{\"1531\":1}}],[\"aspectjawareadvisorautoproxycreator\",{\"0\":{\"972\":1}}],[\"aspectj是在编译期间就增强了对应的方法\",{\"1\":{\"1531\":1}}],[\"aspectjproxyfactory\",{\"0\":{\"969\":1}}],[\"aspectj实现\",{\"0\":{\"948\":1,\"951\":1,\"953\":1}}],[\"aspectj的前置动作\",{\"0\":{\"931\":1}}],[\"aspectj拦截动作\",{\"0\":{\"929\":1}}],[\"aspectj\",{\"0\":{\"926\":1,\"977\":1,\"978\":1}}],[\"aspectj注解驱动\",{\"0\":{\"923\":1}}],[\"aspectj代理\",{\"0\":{\"920\":1,\"924\":1}}],[\"asflow\",{\"1\":{\"1532\":1}}],[\"assumably\",{\"1\":{\"1524\":1}}],[\"assume\",{\"1\":{\"1497\":1}}],[\"assert\",{\"1\":{\"1499\":1,\"1500\":1,\"1524\":1,\"1525\":1,\"1535\":3}}],[\"associated\",{\"1\":{\"1495\":2,\"1497\":1,\"1500\":1}}],[\"associative\",{\"1\":{\"1485\":2}}],[\"associativity\",{\"1\":{\"1485\":2,\"1492\":2}}],[\"assignable\",{\"1\":{\"1522\":2}}],[\"assign\",{\"1\":{\"1350\":1,\"1497\":1}}],[\"asynchronousserversocketchannel>\",{\"1\":{\"1452\":1}}],[\"asynchronousserversocketchannel\",{\"1\":{\"1452\":4}}],[\"asynchronousserversocketchannel由jdk底层线程池负责回调驱动读写操作\",{\"1\":{\"1452\":1}}],[\"asynchronoussocketchannel>\",{\"1\":{\"1452\":1}}],[\"asynchronoussocketchannel\",{\"1\":{\"1452\":8}}],[\"asyncmode\",{\"1\":{\"1387\":2}}],[\"asm\",{\"1\":{\"1356\":1}}],[\"asc\",{\"1\":{\"657\":2}}],[\"aslist\",{\"1\":{\"366\":2,\"1470\":6,\"1471\":1,\"1472\":1,\"1474\":2,\"1475\":1,\"1476\":2,\"1479\":1,\"1480\":2,\"1481\":1,\"1482\":2,\"1484\":2,\"1485\":3,\"1486\":9,\"1487\":2,\"1489\":2,\"1490\":1,\"1491\":1,\"1492\":1,\"1494\":2,\"1495\":1,\"1496\":1,\"1497\":1,\"1531\":3}}],[\"as\",{\"1\":{\"3\":1,\"487\":5,\"504\":1,\"551\":1,\"553\":6,\"554\":2,\"555\":2,\"656\":5,\"691\":10,\"1357\":1,\"1431\":5,\"1471\":5,\"1472\":1,\"1478\":2,\"1485\":4,\"1492\":5,\"1493\":1,\"1494\":1,\"1496\":11,\"1497\":18,\"1498\":2,\"1499\":1,\"1500\":10,\"1524\":3,\"1525\":1}}],[\"a\",{\"1\":{\"0\":1,\"1\":1,\"2\":1,\"3\":1,\"314\":1,\"317\":11,\"318\":11,\"319\":26,\"332\":2,\"376\":5,\"385\":25,\"476\":2,\"483\":8,\"484\":2,\"485\":5,\"491\":3,\"514\":12,\"538\":4,\"539\":1,\"541\":4,\"544\":1,\"551\":2,\"566\":1,\"599\":3,\"603\":1,\"605\":4,\"621\":2,\"643\":1,\"656\":9,\"660\":2,\"661\":1,\"662\":3,\"671\":1,\"674\":1,\"708\":1,\"714\":1,\"748\":2,\"1352\":1,\"1356\":2,\"1357\":2,\"1403\":1,\"1427\":1,\"1428\":1,\"1431\":4,\"1464\":1,\"1465\":1,\"1468\":3,\"1471\":17,\"1474\":6,\"1475\":48,\"1476\":28,\"1477\":7,\"1478\":25,\"1480\":3,\"1485\":22,\"1486\":2,\"1490\":5,\"1491\":3,\"1492\":56,\"1493\":4,\"1494\":16,\"1495\":51,\"1496\":32,\"1497\":80,\"1498\":12,\"1499\":3,\"1500\":44,\"1524\":15,\"1525\":2,\"1532\":7,\"1567\":1,\"1852\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
