<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SpringFramework</title>
    <url>/2020/07/16/SpringFramework/</url>
    <content><![CDATA[<p>Spring毫无疑问是当下Web开发的事实标准，修炼好Web开发中这一门最为重要的内功，对于框架原理的理解、视野的开拓以及学习周边技术栈是必不可少的。</p>
<span id="more"></span>
<h1 id="spring-基础"><a class="markdownIt-Anchor" href="#spring-基础"></a> Spring 基础</h1>
<h2 id="spring特性总览"><a class="markdownIt-Anchor" href="#spring特性总览"></a> Spring特性总览</h2>
<h3 id="spring-中值得学习的地方"><a class="markdownIt-Anchor" href="#spring-中值得学习的地方"></a> Spring 中值得学习的地方</h3>
<ol>
<li>Java语言特性，例如反射、动态代理、枚举、泛型、注解、ARM、Lambda语法</li>
<li>设计思想和模式的实现，如OOP，DDD，TDD，GoF23等</li>
<li>Java API的封装与简化，如JDBC，事务，Transaction，Servlet，JPA，JMX ，Bean Validation</li>
<li>JSR规范的适配与实现</li>
<li>第三方框架的整合，如MyBatis整合Hibernetes和Redis</li>
</ol>
<h3 id="spring核心特性"><a class="markdownIt-Anchor" href="#spring核心特性"></a> Spring核心特性</h3>
<ol>
<li>IOC容器（IOC Container）</li>
<li>Spring事件（Events）</li>
<li>资源管理（Resources）</li>
<li>国际化（i18n）</li>
<li>校验（Validation）</li>
<li>数据绑定（Data Binding）</li>
<li>类型转换（Type Conversion）</li>
<li>Spring表达式（Spring Express Language）</li>
<li>面向切面编程（AOP）</li>
</ol>
<h3 id="spring数据存储"><a class="markdownIt-Anchor" href="#spring数据存储"></a> Spring数据存储</h3>
<ol>
<li>JDBC</li>
<li>事务抽象（Transactions）</li>
<li>DAO支持（DAO Support）</li>
<li>O/R映射（O/R Mapping）</li>
<li>XML编列（XML Marshalling）</li>
</ol>
<h3 id="spring-web技术"><a class="markdownIt-Anchor" href="#spring-web技术"></a> Spring Web技术</h3>
<ol>
<li>Web Servlet技术栈
<ol>
<li>Spring MVC</li>
<li>WebSocket</li>
<li>SockJS</li>
</ol>
</li>
<li>Web Reactive技术栈
<ol>
<li>Spring WebFlux</li>
<li>WebClient</li>
<li>WebSocket</li>
</ol>
</li>
</ol>
<h3 id="spring技术整合"><a class="markdownIt-Anchor" href="#spring技术整合"></a> Spring技术整合</h3>
<ol>
<li>远程调用（Remoting）</li>
<li>Java消息服务（JMS）</li>
<li>Java连接架构（JCA）</li>
<li>Java管理扩展（JMX）</li>
<li>Java邮件客户端（Email）</li>
<li>本地任务（Taks）</li>
<li>本地调度（Scheduling）</li>
<li>缓存抽象（Caching）</li>
</ol>
<h3 id="spring测试"><a class="markdownIt-Anchor" href="#spring测试"></a> Spring测试</h3>
<ol>
<li>模拟对象（Mock Objects）</li>
<li>TestContext框架（TestContext Framework）</li>
<li>Spring MVC测试（Spring MVC Test）</li>
<li>Web 测试客户端（Web TestClient）</li>
</ol>
<h2 id="spring版本特性"><a class="markdownIt-Anchor" href="#spring版本特性"></a> Spring版本特性</h2>
<table>
<thead>
<tr>
<th>Spring Framework版本</th>
<th>Java标准版</th>
<th>Java企业版</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.x</td>
<td>1.3+</td>
<td>J2EE 1.3+</td>
</tr>
<tr>
<td>2.x</td>
<td>1.4.2+</td>
<td>J2EE 1.3+</td>
</tr>
<tr>
<td>3.x</td>
<td>5+</td>
<td>J2EE1.4和JavaEE5</td>
</tr>
<tr>
<td>4.x</td>
<td>6+</td>
<td>Java EE6和7</td>
</tr>
<tr>
<td>5.x</td>
<td>8+</td>
<td>Java EE7</td>
</tr>
</tbody>
</table>
<h2 id="spring模块化设计"><a class="markdownIt-Anchor" href="#spring模块化设计"></a> Spring模块化设计</h2>
<p><a href="https://github.com/spring-projects/spring-framework">仓库链接</a></p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210624205130273.png" alt="image-20210624205130273" /></p>
<h2 id="spring编程模型"><a class="markdownIt-Anchor" href="#spring编程模型"></a> Spring编程模型</h2>
<ol>
<li>
<p>面向对象编程</p>
<ol>
<li>锲约接口：Aware、BeanPostProcessor…</li>
<li>设计模式：观察者模式、组合模式、模板模式…</li>
<li>对象继承：Abstract类</li>
</ol>
</li>
<li>
<p>面向切面编程</p>
<ol>
<li>动态代理：JDKDynamicAopProxy</li>
<li>字节码提升：ASM、CGLib、AspectJ</li>
</ol>
</li>
<li>
<p>面向元编程</p>
<ol>
<li>注解：模式注解（@Component、@Service、@Respository…）</li>
<li>配置：Environment抽象、PropertySources、BeanDefinition…</li>
<li>泛型：Generic TypeResolver、Resolvable Type…</li>
</ol>
</li>
<li>
<p>函数驱动</p>
<ol>
<li>函数接口：ApplicationEventPublisher</li>
<li>Reactive：Spring WebFlux</li>
</ol>
</li>
<li>
<p>模块驱动</p>
<ol>
<li>Maven Artifacts</li>
<li>OSGI Bundies</li>
<li>Java 9 Automatic Modules</li>
<li>Spring @Enable*</li>
</ol>
<p>​</p>
</li>
</ol>
<h2 id="spring的核心价值"><a class="markdownIt-Anchor" href="#spring的核心价值"></a> Spring的核心价值</h2>
<ol>
<li>生态系统
<ol>
<li>Spring Boot</li>
<li>Spring Cloud</li>
<li>Spring Security</li>
<li>Spring Data</li>
<li>其他</li>
</ol>
</li>
<li>API抽象设计
<ol>
<li>AOP抽象</li>
<li>事务抽象</li>
<li>Environment抽象</li>
<li>生命周期</li>
</ol>
</li>
<li>编程模型
<ol>
<li>面向对象编程：契约接口</li>
<li>面向切面编程：动态代理、字节码提升</li>
<li>面向元编程：配置元信息、注解、配置</li>
<li>面向模块编程：Maven Artifacts、Java9 Automatic Modules</li>
<li>Spring @Enable*注解</li>
<li>面向函数式编程：Lambda、Reactive</li>
</ol>
</li>
<li>设计思想
<ol>
<li>Object-Oriented Programming（OOP）</li>
<li>Ioc/DI</li>
<li>Domain-Driven Development（DDD）</li>
<li>Test-Driven Development（TDD）</li>
<li>Event-Driven Programing（EDP）</li>
<li>Functional Programing（FP）</li>
</ol>
</li>
<li>设计模式
<ol>
<li>专属模式
<ol>
<li>前缀模式：Enable模式
<ol>
<li>Configurable模式</li>
</ol>
</li>
<li>后缀模式
<ol>
<li>处理器模式（Process、Resolver、Handler）</li>
<li>意识模式（Aware）</li>
<li>配置器模式（Configuror）</li>
<li>选择器模式（ImportSelector）</li>
</ol>
</li>
</ol>
</li>
<li>传统GoF23</li>
</ol>
</li>
<li>用户基础
<ol>
<li>Spring用户 Spring Framework、SpringBoot、Spring Cloud</li>
<li>传统用户 Java SE、Java EE</li>
</ol>
</li>
</ol>
<h2 id="面试题"><a class="markdownIt-Anchor" href="#面试题"></a> 面试题</h2>
<h3 id="什么是spring-framework"><a class="markdownIt-Anchor" href="#什么是spring-framework"></a> 什么是Spring Framework？</h3>
<p>Spring Framework提供一个完整性的编程或配置的一个现代化的基于Java的企业的应用，Spring的核心特点是在应用级别上的基础设施建设。</p>
<p>Spring使得你的应用开发变的更容易，它可以提供任何你想要的东西，并是拥抱企业环境的Java语言，并且支持可以运行在JVM上面的其他语言，比如Groovy或者Kotlin，同时也提供一些弹性，根据软件的需要提供不同的软件架构。</p>
<h3 id="spring-framwork有哪些核心模块"><a class="markdownIt-Anchor" href="#spring-framwork有哪些核心模块"></a> Spring Framwork有哪些核心模块？</h3>
<ol>
<li>Spring-core：Spring 基础API模块，如资源管理、泛型处理</li>
<li>Spring-beans：Spring Bean相关，如依赖查找，依赖注入</li>
<li>Spring-aop：Spring AOP处理，如动态代理，AOP字节码提升</li>
<li>Spring-context：事件驱动、注解驱动、模块驱动</li>
<li>Spring-expresson：Spring 表达式语言模块</li>
</ol>
<h3 id="spring-framework的优势和不足是什么"><a class="markdownIt-Anchor" href="#spring-framework的优势和不足是什么"></a> Spring Framework的优势和不足是什么？</h3>
<p>待定…</p>
<h1 id="ioc简介"><a class="markdownIt-Anchor" href="#ioc简介"></a> IoC简介</h1>
<h2 id="ioc的发展简介"><a class="markdownIt-Anchor" href="#ioc的发展简介"></a> IoC的发展简介</h2>
<ol>
<li>1983年，好莱坞原则</li>
<li>1988年，控制反转</li>
<li>1996年，Inversion of control -&gt; Hollywood principle</li>
<li>2004年，Martin Fowler提出了自己对IoC以及DI的理解</li>
<li>2005年，Martin Fowler对IoC做出了进一步的说明</li>
</ol>
<h2 id="ioc主要实现策略"><a class="markdownIt-Anchor" href="#ioc主要实现策略"></a> IoC主要实现策略</h2>
<ol>
<li>使用service locator pattern（服务定位模式）</li>
<li>通过依赖注入：
<ol>
<li>构造器注入</li>
<li>参数注入</li>
<li>Setter注入</li>
<li>接口注入</li>
</ol>
</li>
<li>上下文的依赖查询（beancontext）</li>
<li>模板方法设计模式（例如JDBC）</li>
<li>策略模式</li>
</ol>
<p>IoC主要的实现策略：依赖查找、依赖注入。</p>
<h2 id="ioc容器的职责"><a class="markdownIt-Anchor" href="#ioc容器的职责"></a> IoC容器的职责</h2>
<ol>
<li>依赖处理
<ol>
<li>依赖查找</li>
<li>依赖注入</li>
</ol>
</li>
<li>生命周期管理
<ol>
<li>容器</li>
<li>托管的资源（Java Beans或其他资源）</li>
</ol>
</li>
<li>配置
<ol>
<li>容器</li>
<li>外部化配置</li>
<li>托管的资源（Java Beans或其他资源）</li>
</ol>
</li>
</ol>
<h2 id="ioc的实现"><a class="markdownIt-Anchor" href="#ioc的实现"></a> IoC的实现</h2>
<ol>
<li>Java SE
<ul>
<li>Java Beans</li>
<li>Java ServiceLoader SPI</li>
<li>JNDI（Java Naming and Directory Interface）</li>
</ul>
</li>
<li>Java EE
<ul>
<li>EJB（Enterprise Java Beans）</li>
<li>Servlet</li>
</ul>
</li>
<li>开源
<ul>
<li>Apache Avalon</li>
<li>PicoContainer</li>
<li>Google Guice</li>
<li>Spring Framework</li>
</ul>
</li>
</ol>
<h2 id="传统ioc容器的实现"><a class="markdownIt-Anchor" href="#传统ioc容器的实现"></a> 传统IoC容器的实现</h2>
<p>Java Beans 作为IoC容器的特性：</p>
<ul>
<li>依赖查找</li>
<li>生命周期管理</li>
<li>配置元信息</li>
<li>事件</li>
<li>自定义</li>
<li>资源管理</li>
<li>持久化</li>
</ul>
<p>什么是Java Beans呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述人的POJO类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以打印这个Bean的元信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInfoDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanInfo beanInfo = Introspector.getBeanInfo(Person.class, Object.class);</span><br><span class="line">        Stream.of(beanInfo.getPropertyDescriptors()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.beans.PropertyDescriptor[name=age; propertyType=class java.lang.Integer; readMethod=public java.lang.Integer beans.Person.getAge(); writeMethod=public void beans.Person.setAge(java.lang.Integer)]</span><br><span class="line">java.beans.PropertyDescriptor[name=name; propertyType=class java.lang.String; readMethod=public java.lang.String beans.Person.getName(); writeMethod=public void beans.Person.setName(java.lang.String)]</span><br></pre></td></tr></table></figure>
<h2 id="如何界定ioc容器是轻量级的"><a class="markdownIt-Anchor" href="#如何界定ioc容器是轻量级的"></a> 如何界定IoC容器是轻量级的？</h2>
<p>以下观点出自于《J2EE Development without EJB》</p>
<ol>
<li>管理应用代码</li>
<li>能够快速启动</li>
<li>容器不需要一些特殊的配置来进行操作（主要是针对于EJB）</li>
<li>容器的内存占用小以及最小化API的一个依赖</li>
<li>容器需要一些可以管控的一个渠道，这个渠道能够帮助我们去部署和管理一些细粒度的对象，甚至是一些粗粒度的组件</li>
</ol>
<h2 id="依赖查找和依赖注入"><a class="markdownIt-Anchor" href="#依赖查找和依赖注入"></a> 依赖查找和依赖注入</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>依赖处理</th>
<th>实现便利性</th>
<th>代码入侵性</th>
<th>API依赖性</th>
<th>可读性</th>
</tr>
</thead>
<tbody>
<tr>
<td>依赖查找</td>
<td>主动获取</td>
<td>相对繁琐</td>
<td>侵入业务逻辑</td>
<td>依赖容器API</td>
<td>良好</td>
</tr>
<tr>
<td>依赖注入</td>
<td>被动提供</td>
<td>相对便利</td>
<td>低入侵性</td>
<td>不主动依赖容器API</td>
<td>一般</td>
</tr>
</tbody>
</table>
<h2 id="构造器注入和setter注入"><a class="markdownIt-Anchor" href="#构造器注入和setter注入"></a> 构造器注入和Setter注入</h2>
<p>Spring官方推荐使用构造器注入，这样可以确保在注入时，对象不为空，但是参数过多时会影响代码的整洁性，可能需要考虑重构。</p>
<p>Setter注入应该主要仅用于我们的可选性的注入，因为Setter的字段本身是可以为空的。</p>
<p>而《J2EE Development without EJB》认为应该使用Setter注入，原因在于：</p>
<ol>
<li>JavaBean属性能够获取更好的IDE支持</li>
<li>JavaBean属性通常是一个自文档的说明</li>
<li>在类型转换上有优势</li>
<li>大量的JavaBeans可能不经过任何修改就可以在JavaBean容器当中使用</li>
</ol>
<p>当然，Setter注入也有缺点，就是无法确定属性初始化的顺序。</p>
<h2 id="面试题-2"><a class="markdownIt-Anchor" href="#面试题-2"></a> 面试题</h2>
<h3 id="什么是ioc"><a class="markdownIt-Anchor" href="#什么是ioc"></a> 什么是IoC？</h3>
<p>简单地说，IoC是反转控制，类似于好莱坞原则，主要有依赖查找和依赖注入两种实现。按照IoC的定义，很多方面其实都是IoC，比如JavaBeans是IoC的一个容器实现，Servlet的容器也是IoC的实现，因为Servlet可以去依赖或者反向地通过JNDI的方式进行得到一些外部的一些资源，包括DataSource或者相关的EJB的组件，于此同时SpringFramework或者Peak Container的依赖注入的框架，也能帮助我们去实现IoC，除此之外，消息也可以看作是IoC的一种实现。</p>
<h3 id="依赖查找和依赖注入的区别"><a class="markdownIt-Anchor" href="#依赖查找和依赖注入的区别"></a> 依赖查找和依赖注入的区别？</h3>
<p>依赖查找是主动或手动的依赖查找方式，通常需要依赖容器或标准API实现。而依赖注入则是手动或自动依赖绑定的方式，无需依赖特定的容器和API。</p>
<h3 id="spring作为ioc容器有什么优势"><a class="markdownIt-Anchor" href="#spring作为ioc容器有什么优势"></a> Spring作为IoC容器有什么优势？</h3>
<p>典型的IoC管理，依赖查找和依赖注入，AOP抽象，事务抽象，事件机制，SPI扩展，强大的第三方整合，易测试性，更好的面向对象。</p>
<h1 id="ioc实践"><a class="markdownIt-Anchor" href="#ioc实践"></a> IoC实践</h1>
<h2 id="spring-ioc依赖查找"><a class="markdownIt-Anchor" href="#spring-ioc依赖查找"></a> Spring IoC依赖查找</h2>
<ol>
<li>根据Bean名称查找
<ul>
<li>实时查找</li>
<li>延迟查找</li>
</ul>
</li>
<li>根据Bean类型查找
<ul>
<li>单个Bean对象</li>
<li>集合Bean对象</li>
</ul>
</li>
<li>根据Bean名称+类型查找</li>
<li>根据Java注解查找</li>
</ol>
<p>新建一个用户类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个超级用户类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 超级用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Super</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperUser</span> <span class="keyword">extends</span> <span class="title">User</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SuperUser&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;&#125; &quot;</span> + <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 超级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Super &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>向容器中注入一些Bean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吉永超&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;SuperUser&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.overview.dependency.domain.SuperUser&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;user&quot;</span> <span class="attr">primary</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;深圳&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;objectFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>依赖查找的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyLookupDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置XML文件</span></span><br><span class="line">        <span class="comment">// 启动Spring应用上下文</span></span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 实时查找</span></span><br><span class="line">        lookupInRealTime(beanFactory);</span><br><span class="line">        <span class="comment">// 延迟查找</span></span><br><span class="line">        lookupInLazy(beanFactory);</span><br><span class="line">        <span class="comment">// 按照类型查找</span></span><br><span class="line">        lookupByType(beanFactory);</span><br><span class="line">        <span class="comment">// 按照类型查找集合对象</span></span><br><span class="line">        lookupCollectionType(beanFactory);</span><br><span class="line">        <span class="comment">// 通过注解查找</span></span><br><span class="line">        lookupByAnnotationType(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过注解查找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByAnnotationType</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">            ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;</span><br><span class="line">            Map&lt;String, User&gt; users = (Map)listableBeanFactory.getBeansWithAnnotation(Super.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;查找到的所有标注@Super的User集合对象：&quot;</span> + users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照类型查找集合对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupCollectionType</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">            ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;</span><br><span class="line">            Map&lt;String, User&gt; users = listableBeanFactory.getBeansOfType(User.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;查找到的所有的User集合对象：&quot;</span> + users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照类型查找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByType</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        User user = beanFactory.getBean(User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;按照类型查找 &quot;</span> + user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延迟查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupInLazy</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        ObjectFactory&lt;User&gt; objectFactory = (ObjectFactory&lt;User&gt;) beanFactory.getBean(<span class="string">&quot;objectFactory&quot;</span>);</span><br><span class="line">        User user = objectFactory.getObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;延迟查找 &quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实时查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupInRealTime</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        User user = (User) beanFactory.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;实时查找&quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring-ioc依赖注入"><a class="markdownIt-Anchor" href="#spring-ioc依赖注入"></a> Spring IoC依赖注入</h2>
<ol>
<li>根据Bean名称注入</li>
<li>根据Bean类型注入
<ul>
<li>单个Bean对象</li>
<li>集合Bean对象</li>
</ul>
</li>
<li>注入容器内建的Bean对象</li>
<li>注入非Bean对象</li>
<li>注入类型
<ul>
<li>实时注入</li>
<li>延迟注入</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户信息仓库</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRespository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;User&gt; users; <span class="comment">// 自定义Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory; <span class="comment">//内建的非Bean对象（对象）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;ApplicationContext&gt; objectFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsers</span><span class="params">(Collection&lt;User&gt; users)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.users = users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectFactory&lt;ApplicationContext&gt; <span class="title">getObjectFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objectFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObjectFactory</span><span class="params">(ObjectFactory&lt;ApplicationContext&gt; objectFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个类似的资源：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过导入复用   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;dependency-lookup-context.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--   Auto-wiring     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userRespository&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.overview.dependency.repository.UserRespository&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--   手动配置     --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;users&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;util:list&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;ref bean=&quot;user&quot;&gt;&lt;/ref&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;ref bean=&quot;SuperUser&quot;&gt;&lt;/ref&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;/util:list&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/property&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInjectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置XML文件</span></span><br><span class="line">        <span class="comment">// 启动Spring应用上下文</span></span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;META-INF/dependency-injection-context.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        UserRespository userRespository = beanFactory.getBean(<span class="string">&quot;userRespository&quot;</span>, UserRespository.class);</span><br><span class="line"><span class="comment">//        System.out.println(userRespository.getUsers());</span></span><br><span class="line">        System.out.println(userRespository.getBeanFactory());</span><br><span class="line"><span class="comment">//        System.out.println(userRespository.getBeanFactory() == beanFactory);</span></span><br><span class="line">        ObjectFactory&lt;ApplicationContext&gt; userFactory = userRespository.getObjectFactory();</span><br><span class="line">        System.out.println(userFactory.getObject() == beanFactory);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比结果可以发现依赖查找和依赖注入的来源并不一样。</p>
<h2 id="spring依赖注入和依赖查找的来源"><a class="markdownIt-Anchor" href="#spring依赖注入和依赖查找的来源"></a> Spring依赖注入和依赖查找的来源</h2>
<ol>
<li>自定义Bean</li>
<li>容器内建Bean对象</li>
<li>容器内建依赖</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInjectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置XML文件</span></span><br><span class="line">        <span class="comment">// 启动Spring应用上下文</span></span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;META-INF/dependency-injection-context.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 自定义的Bean</span></span><br><span class="line">        UserRespository userRespository = beanFactory.getBean(<span class="string">&quot;userRespository&quot;</span>, UserRespository.class);</span><br><span class="line">        <span class="comment">// 依赖注入（内建依赖）</span></span><br><span class="line">        System.out.println(userRespository.getBeanFactory());</span><br><span class="line">        <span class="comment">// 容器内建Bean对象</span></span><br><span class="line">        Environment environment = beanFactory.getBean(Environment.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;获取Enviroment类型的Bean&quot;</span> + environment);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring-ioc配置元信息"><a class="markdownIt-Anchor" href="#spring-ioc配置元信息"></a> Spring IoC配置元信息</h2>
<ol>
<li>Bean定义配置
<ul>
<li>基于XML文件</li>
<li>基于Properties文件</li>
<li>基于Java注解</li>
<li>基于Java API（专题讨论）</li>
</ul>
</li>
<li>IoC容器配置
<ul>
<li>基于XML文件</li>
<li>基于Java注解</li>
<li>基于Java API（专题讨论）</li>
</ul>
</li>
<li>外部化属性配置
<ul>
<li>基于Java注解</li>
</ul>
</li>
</ol>
<h2 id="beanfactory和applicationcontext"><a class="markdownIt-Anchor" href="#beanfactory和applicationcontext"></a> BeanFactory和ApplicationContext</h2>
<p>BeanFactory和ApplicationContext谁才是Spring IoC容器？</p>
<p>BeanFactory是一个具有基本功能的框架，而ApplicationContext添加了更多企业级的特性，总而言之，ApplicationContext是BeanFactory的超集，并且在实现上，ApplicationContext虽然继承了BeanFactory接口，但内部的BeanFactory是采用组合的方式进行的实现，默认的实现类为DefaultListableBeanFactory。</p>
<p>ApplicationContext除了IoC容器角色，还有提供：</p>
<ul>
<li>面向切面（AOP）</li>
<li>配置元信息（Configuration Metadata）</li>
<li>资源管理（Resources）</li>
<li>事件（Events）</li>
<li>国际化（i18n）</li>
<li>注解（Annotations）</li>
<li>Environment抽象（Environment Abstraction）</li>
</ul>
<p>BeanFactory的IoC容器的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanFactory作为IoC容器示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryAsIoCContainerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建BeanFactory容器</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 加载配置</span></span><br><span class="line">        XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        <span class="comment">// XML配置文件ClassPath路径</span></span><br><span class="line">        String location = <span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        <span class="comment">// 加载配置</span></span><br><span class="line">        <span class="keyword">int</span> beanDefinitions = reader.loadBeanDefinitions(location);</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean定义加载的数量: &quot;</span> + beanDefinitions);</span><br><span class="line">        <span class="comment">// 依赖查找集合对象....</span></span><br><span class="line">        lookupCollectionType(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照类型查找集合对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupCollectionType</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">            ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;</span><br><span class="line">            Map&lt;String, User&gt; users = listableBeanFactory.getBeansOfType(User.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;查找到的所有的User集合对象：&quot;</span> + users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Application的IoC容器使用：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ApplicationA作为IoC容器示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationApplicationAsIoCContainerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建BeanFactory容器</span></span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(AnnotationApplicationAsIoCContainerDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="comment">// 依赖查找集合对象....</span></span><br><span class="line">        lookupCollectionType(applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;吉永超&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照类型查找集合对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupCollectionType</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">            ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;</span><br><span class="line">            Map&lt;String, User&gt; users = listableBeanFactory.getBeansOfType(User.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;查找到的所有的User集合对象：&quot;</span> + users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，使用BeanFactory和ApplicationContext都可以完成依赖查找的功能。</p>
<h2 id="spring-ioc容器生命周期"><a class="markdownIt-Anchor" href="#spring-ioc容器生命周期"></a> Spring IoC容器生命周期</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line">			beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">			contextRefresh.end();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-3"><a class="markdownIt-Anchor" href="#面试题-3"></a> 面试题</h2>
<h3 id="什么是spring-ioc容器"><a class="markdownIt-Anchor" href="#什么是spring-ioc容器"></a> 什么是Spring IoC容器</h3>
<p>Spring Framework是IoC（控制反转）的一种具体的实现，主要包括了DI（dependency injection），和DL（dependency lookup）。</p>
<h3 id="beanfactory和factorybean"><a class="markdownIt-Anchor" href="#beanfactory和factorybean"></a> BeanFactory和FactoryBean</h3>
<p>BeanFactory是IoC底层容器，FactoryBean是创建Bean的一种方式，帮助实现复杂的初始化逻辑。</p>
<h3 id="spring-ioc容器启动时做了哪些准备"><a class="markdownIt-Anchor" href="#spring-ioc容器启动时做了哪些准备"></a> Spring IoC容器启动时做了哪些准备？</h3>
<p>IoC配置元信息读取和解析、IoC容器生命周期、Spring事件发布、国际化等。</p>
<h1 id="spring-bean基础"><a class="markdownIt-Anchor" href="#spring-bean基础"></a> Spring Bean基础</h1>
<h2 id="beandefinition"><a class="markdownIt-Anchor" href="#beandefinition"></a> BeanDefinition</h2>
<p>BeanDefinition时Spring Framework中定义Bean配置元信息接口，包含：</p>
<ol>
<li>Bean的类名（必须是全限定类名）</li>
<li>Bean行为配置元素，如作用域、自动绑定的模式、生命周期回调等</li>
<li>其他Bean引用，又可称合作者（collaborators）或者依赖（dependencies）</li>
<li>配置设置，比如Bean属性（Properties）</li>
</ol>
<p>BeanDefinition元信息</p>
<table>
<thead>
<tr>
<th>属性（Property）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Class</td>
<td>Bean全类名，必须是具体类，不能用抽象类或接口</td>
</tr>
<tr>
<td>Name</td>
<td>Bean的名称或者ID</td>
</tr>
<tr>
<td>Scope</td>
<td>Bean的作用域（如：singleton、prototype等）</td>
</tr>
<tr>
<td>Constructor arguments</td>
<td>Bean构造器参数（用于依赖注入）</td>
</tr>
<tr>
<td>Properties</td>
<td>Bean属性设置（用于依赖注入）</td>
</tr>
<tr>
<td>Autowiring mode</td>
<td>Bean自动绑定模式（如：通过名称byName）</td>
</tr>
<tr>
<td>Lazy initialization mode</td>
<td>Bean延迟初始化模式（延迟和非延迟）</td>
</tr>
<tr>
<td>Initialization method</td>
<td>Bean初始化回调方法名称</td>
</tr>
<tr>
<td>Destruction method</td>
<td>Bean销毁回调方法名称</td>
</tr>
</tbody>
</table>
<p>BeanDefinition的构建方式</p>
<ol>
<li>通过BeanDefinitionBuilder</li>
<li>通过AbstactBeanDefinition以及派生类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanDefinition构建示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionCreationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.通过BeanDefinitionBuilder</span></span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class);</span><br><span class="line">        <span class="comment">// 通过属性设置</span></span><br><span class="line">        beanDefinitionBuilder.addPropertyValue(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jyc&quot;</span>);</span><br><span class="line">        beanDefinitionBuilder.addPropertyValue(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取BeanDefinition实例</span></span><br><span class="line">        AbstractBeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line">        <span class="comment">// BeanDefinition并非Bean的终态，可以自定义修改</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.通过AbstactBeanDefinition以及派生类</span></span><br><span class="line">        GenericBeanDefinition genericBeanDefinition = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">        <span class="comment">// 设置Bean类型</span></span><br><span class="line">        genericBeanDefinition.setBeanClass(User.class);</span><br><span class="line">        <span class="comment">// 通过MutablePropertyValues批量操作属性</span></span><br><span class="line">        MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">        propertyValues.addPropertyValue(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        propertyValues.addPropertyValue(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jyc&quot;</span>);</span><br><span class="line">        genericBeanDefinition.setPropertyValues(propertyValues);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring-bean命名"><a class="markdownIt-Anchor" href="#spring-bean命名"></a> Spring Bean命名</h2>
<p>什么是Bean的名称？</p>
<p>每个Bean拥有一个或多个标识符（identifiers），这些标识符在Bean所在的容器必须是唯一的。通常，一个Bean仅有一个标识符，如果需要额外的，可考虑使用别名（Alias）来扩充。</p>
<p>在基于XML的配置元信息中，开发人员可用id或者name属性来规定Bean的标识符。通常Bean的标识符由字母组成，允许出现特殊字符，如果要想映入新的Bean的别名的话，可在name属性使用半角逗号（“,”）或分号（“;”）来间隔。</p>
<p>Bean的id或name属性并非必须制定，如果留空的话，容器回味Bean自动生成一个唯一的名称。Bean的名称尽管没有限制，不过官方建议采用驼峰的方式，更符合Java的命名约定。</p>
<p>Bean名称生成器（BeanNameGenerator）主要有两种实现：</p>
<ol>
<li>DefaultBeanNameGenerator（默认通用BeanNameGenerator实现）</li>
<li>AnnotationBeanNameGenerator</li>
</ol>
<p>默认实现的核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateBeanName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		BeanDefinition definition, BeanDefinitionRegistry registry, <span class="keyword">boolean</span> isInnerBean)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	String generatedBeanName = definition.getBeanClassName();</span><br><span class="line">	<span class="keyword">if</span> (generatedBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (definition.getParentName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			generatedBeanName = definition.getParentName() + <span class="string">&quot;$child&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (definition.getFactoryBeanName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			generatedBeanName = definition.getFactoryBeanName() + <span class="string">&quot;$created&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasText(generatedBeanName)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;Unnamed bean definition specifies neither &quot;</span> +</span><br><span class="line">				<span class="string">&quot;&#x27;class&#x27; nor &#x27;parent&#x27; nor &#x27;factory-bean&#x27; - can&#x27;t generate bean name&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isInnerBean) &#123;</span><br><span class="line">		<span class="comment">// Inner bean: generate identity hashcode suffix.</span></span><br><span class="line">		<span class="keyword">return</span> generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(definition);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Top-level bean: use plain class name with unique suffix if necessary.</span></span><br><span class="line">	<span class="keyword">return</span> uniqueBeanName(generatedBeanName, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是简单场景的Bean的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">uniqueBeanName</span><span class="params">(String beanName, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	String id = beanName;</span><br><span class="line">	<span class="keyword">int</span> counter = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Increase counter until the id is unique.</span></span><br><span class="line">	String prefix = beanName + GENERATED_BEAN_NAME_SEPARATOR;</span><br><span class="line">	<span class="keyword">while</span> (counter == -<span class="number">1</span> || registry.containsBeanDefinition(id)) &#123;</span><br><span class="line">		counter++;</span><br><span class="line">		id = prefix + counter;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解实现的核心源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">			String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line">				<span class="comment">// Explicit bean name found.</span></span><br><span class="line">				<span class="keyword">return</span> beanName;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Fallback: generate a unique default bean name.</span></span><br><span class="line">		<span class="keyword">return</span> buildDefaultBeanName(definition, registry);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>如果是一个普通的Bean就会调用Java Beans的API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">	String beanClassName = definition.getBeanClassName();</span><br><span class="line">	Assert.state(beanClassName != <span class="keyword">null</span>, <span class="string">&quot;No bean class name set&quot;</span>);</span><br><span class="line">	String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class="line">	<span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bean别名（Alias）的价值：</p>
<ol>
<li>
<p>复用现有的BeanDefinition</p>
</li>
<li>
<p>更具有场景化的命名方法，比如：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;myApp-dataSource&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;subsystemA-datasource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;myApp-dataSource&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;subsystemB-datasource&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="beandefinition注册到ioc容器"><a class="markdownIt-Anchor" href="#beandefinition注册到ioc容器"></a> BeanDefinition注册到IoC容器</h2>
<p>BeanDefinition注册的不同方式：</p>
<ol>
<li>XML配置元信息
<ul>
<li>&lt;bean name =&quot;…&quot; … /&gt;</li>
</ul>
</li>
<li>Java注解配置元信息
<ul>
<li>@Bean</li>
<li>@Component</li>
<li>@import</li>
</ul>
</li>
<li>Java API配置元信息
<ul>
<li>命名方式：BeanDefinitionRegistry#registerBeanDefinition（String，BeanDefinition）</li>
<li>非命名方式：BeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition，BeanDefinitionRegistry)</li>
<li>配置类方式：AnnotatedBeanDefinitionReader#register（Class）</li>
</ul>
</li>
</ol>
<p>通过Java注解配置元信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解BeanDefinition示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Import(AnnotationBeanDefinitionDemo.Config.class)</span> <span class="comment">// 3.通过@Import方式导入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationBeanDefinitionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册配置类（configuration class）</span></span><br><span class="line">        applicationContext.register(AnnotationBeanDefinitionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        System.out.println(<span class="string">&quot;Config类型的所有的Beans&quot;</span> + applicationContext.getBeansOfType(Config.class));</span><br><span class="line">        System.out.println(<span class="string">&quot;user类型的所有的Beans&quot;</span> + applicationContext.getBeansOfType(User.class));</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.通过Component方式</span></span><br><span class="line">    <span class="meta">@Component</span> <span class="comment">//定义当前类作为Spring Bean（组件）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.通过@Bean方式定义</span></span><br><span class="line">        <span class="meta">@Bean(&#123;&quot;user&quot;, &quot;jyc&quot;&#125;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            user.setName(<span class="string">&quot;吉永超&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java API配置元信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 命名Bean的注册方式</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerUserBeanDefinition</span><span class="params">(BeanDefinitionRegistry registry, String beanName)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class);</span><br><span class="line">        beanDefinitionBuilder.addPropertyValue(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;1&quot;</span>).addPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jiyongchao&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断如果beanName参数存在时</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            registry.registerBeanDefinition(beanName, beanDefinitionBuilder.getBeanDefinition());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非命名的Bean注册方法</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinitionBuilder.getBeanDefinition(), registry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例化bean的方式"><a class="markdownIt-Anchor" href="#实例化bean的方式"></a> 实例化Bean的方式</h2>
<p>Bean实例化：</p>
<ol>
<li>
<p>常规方式</p>
<ul>
<li>通过构造器（配置元信息：XML、Java注解和Java API）</li>
<li>通过静态工厂方法（配置元信息：XML和Java API）</li>
<li>通过Bean工厂方法（配置元信息：XML和Java API）</li>
<li>通过FactoryBean（配置元信息：XML、Java注解和Java API）</li>
</ul>
</li>
<li>
<p>特殊方式</p>
<ul>
<li>通过ServiceLoaderFactoryBean（配置元信息：XML、Java注解和Java API）</li>
<li>通过AutowireCapableBeanFactory#createBean（java.lang.Class，int，boolean）</li>
<li>通过BeanDefinitionResgistry#registerBeanDefinition（String，BeanDefinition）</li>
</ul>
<p>常规方式实例化的示例：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  静态方法实例化Bean  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user-by-static-method&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createUser&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  实例方法实例化Bean  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user-by-instance-method&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createUser&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  Bean工厂实例化Bean  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.bean.definition.factory.DefaultUserFactory&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  FactoryBean实例化Bean  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user-by-factory-bean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.bean.definition.factory.UserFactoryBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中UserFactoryBean为：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * User Bean的FactoryBean的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试输出：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bean实例化示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInstantiationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:/META-INF/bean-instantiation-context.xml&quot;</span>);</span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user-by-static-method&quot;</span>, User.class);</span><br><span class="line">        User userByInstanceMethod = beanFactory.getBean(<span class="string">&quot;user-by-instance-method&quot;</span>, User.class);</span><br><span class="line">        User userByFactoryBean = beanFactory.getBean(<span class="string">&quot;user-by-instance-method&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(userByInstanceMethod);</span><br><span class="line">        System.out.println(userByFactoryBean);</span><br><span class="line"></span><br><span class="line">        System.out.println(user == userByInstanceMethod);</span><br><span class="line">        System.out.println(user == userByFactoryBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特殊方式的示例：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactoryServiceLoader&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.serviceloader.ServiceLoaderFactoryBean&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.jyc.thinking.in.spring.bean.definition.factory.UserFactory&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试输出：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpecialBeanInstantiationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:/META-INF/special-bean-instantiation-context.xml&quot;</span>);</span><br><span class="line">        ServiceLoader serviceLoader = beanFactory.getBean(<span class="string">&quot;userFactoryServiceLoader&quot;</span>, ServiceLoader.class);</span><br><span class="line">        displayServiceLoader(serviceLoader);</span><br><span class="line">        demoServiceLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demoServiceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;UserFactory&gt; serviceLoader = ServiceLoader.load(UserFactory.class, Thread.currentThread().getContextClassLoader());</span><br><span class="line">        displayServiceLoader(serviceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayServiceLoader</span><span class="params">(ServiceLoader&lt;UserFactory&gt; serviceLoader)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;UserFactory&gt; iterator = serviceLoader.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            UserFactory userFactory = iterator.next();</span><br><span class="line">            System.out.println(userFactory.createUser());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过AutowireCapableBeanFactory实例化：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:/META-INF/special-bean-instantiation-context.xml&quot;</span>);</span><br><span class="line">     <span class="comment">// 通过ApplicationContext获取AutowireCapableBeanFactory</span></span><br><span class="line">     AutowireCapableBeanFactory beanFactory = applicationContext.getAutowireCapableBeanFactory();</span><br><span class="line">     <span class="comment">// 通过AutowireCapableBeanFactory创建UserFactory对象</span></span><br><span class="line">     UserFactory userFactory = beanFactory.createBean(DefaultUserFactory.class);</span><br><span class="line">     System.out.println(userFactory.createUser());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化bean的方式"><a class="markdownIt-Anchor" href="#初始化bean的方式"></a> 初始化Bean的方式</h2>
<p>Bean的初始化（Initialization）：</p>
<ol>
<li>@PostConstruct标注方法</li>
<li>实现InitializingBean接口的afterPropertiesSet()方法</li>
<li>自定义初始化方法
<ul>
<li>XML配置：&lt;bean init-method=“init” … /&gt;</li>
<li>Java注解：@Bean(initMethod=“init”)</li>
<li>Java API：AbstractBeanDefinition#setInitMethodName(String)</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>初始化的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultUserFactory</span> <span class="keyword">implements</span> <span class="title">UserFactory</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.基于@PostConstruct注解</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;@PostConstruct: UserFactory 初始化中....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterPropertiesSet: UserFactory 初始化中....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initUserFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自定义初始化方法： initUserFactory： UserFactory 初始化中....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInitializationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(BeanInitializationDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        UserFactory userFactory = applicationContext.getBean(UserFactory.class);</span><br><span class="line">        applicationContext.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;initUserFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserFactory <span class="title">userFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultUserFactory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终实际上都会调用的AbstractBeanDefinition的setInitMethodName</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInitMethodName</span><span class="params">(<span class="meta">@Nullable</span> String initMethodName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.initMethodName = initMethodName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三者的执行顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span>: UserFactory 初始化中....</span><br><span class="line">afterPropertiesSet: UserFactory 初始化中....</span><br><span class="line">自定义初始化方法： initUserFactory： UserFactory 初始化中....</span><br></pre></td></tr></table></figure>
<h2 id="延迟初始化bean"><a class="markdownIt-Anchor" href="#延迟初始化bean"></a> 延迟初始化Bean</h2>
<p>Bean延迟初始化（Lazy Initialization）</p>
<ol>
<li>XML配置：&lt;bean lazy-init=“true” …/&gt;</li>
<li>Java注解：@Lazy(true)</li>
</ol>
<p>Spring容器返回的对象和非延迟的对象存在怎样的差异？</p>
<p>非延迟初始化在Spring应用上下文启动完成后，被初始化。而延迟初始化是在依赖查找和依赖注入的时候才会进行初始化。</p>
<h2 id="销毁bean"><a class="markdownIt-Anchor" href="#销毁bean"></a> 销毁Bean</h2>
<p>Bean销毁（Destroy）</p>
<ol>
<li>@PreDestory标注方法</li>
<li>实现DisposableBean接口的destory()方法</li>
<li>自定义销毁方法
<ul>
<li>XML配置：&lt;bean destory=“destory” …/&gt;</li>
<li>Java注解：@Bean(destory=“destory”)</li>
<li>Java API: AbstractBeanDefinition#setDestoryMethodName(String)</li>
</ul>
</li>
</ol>
<p>销毁的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultUserFactory</span> <span class="keyword">implements</span> <span class="title">UserFactory</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;@PreDestroy: UserFactory 销毁中....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DisposableBean#destroy: UserFactory 销毁中....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自定义销毁方法：doDestory()： UserFactory 销毁中....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDestoryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(BeanDestoryDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="comment">// 非延迟初始化在Spring应用上下文启动完成后，被初始化。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;应用上下文已启动...&quot;</span>);</span><br><span class="line">        UserFactory userFactory = applicationContext.getBean(UserFactory.class);</span><br><span class="line">        System.out.println(userFactory);</span><br><span class="line">        System.out.println(<span class="string">&quot;应用上下文准备关闭...&quot;</span>);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;应用上下文已关闭...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;doDestory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserFactory <span class="title">userFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultUserFactory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过不同时机的打印，可以观察到Bean的销毁的时机就是在应用上下文关闭的时候。</p>
<p>三者不同方式的执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">应用上下文已启动...</span><br><span class="line">应用上下文准备关闭...</span><br><span class="line"><span class="meta">@PreDestroy</span>: UserFactory 销毁中....</span><br><span class="line">DisposableBean#destroy: UserFactory 销毁中....</span><br><span class="line">自定义销毁方法：doDestory()： UserFactory 销毁中....</span><br><span class="line">应用上下文已关闭...</span><br></pre></td></tr></table></figure>
<h2 id="垃圾回收spring-bean"><a class="markdownIt-Anchor" href="#垃圾回收spring-bean"></a> 垃圾回收Spring Bean</h2>
<p>Bean垃圾回收（GC）</p>
<ol>
<li>关闭Spring容器（应用上下文）</li>
<li>执行GC</li>
<li>Spring Bean覆盖的finalize()方法被回调</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bena垃圾回收的示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanGarbageCollectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(BeanInitializationDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        applicationContext.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;Spring 应用上下文已关闭&quot;</span>);</span><br><span class="line">        <span class="comment">// 强制触发GC</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重写了DefaultUserFactory中的finalize()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前DefaultUserFactory 对象正在被垃圾回收&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-4"><a class="markdownIt-Anchor" href="#面试题-4"></a> 面试题</h2>
<h3 id="如何注册一个spring-bean"><a class="markdownIt-Anchor" href="#如何注册一个spring-bean"></a> 如何注册一个Spring Bean？</h3>
<p>通过BeanDefinition和外部单体对象来注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单体Bean注册示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonBeanRegistrationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册外部单例对象</span></span><br><span class="line">        UserFactory userFactory = <span class="keyword">new</span> DefaultUserFactory();</span><br><span class="line">        <span class="comment">// 创建一个外部UserFactory对象</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory();</span><br><span class="line">        <span class="comment">// 注册外部单例对象</span></span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;userFactory&quot;</span>, userFactory);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        UserFactory userFactoryByLookup = beanFactory.getBean(<span class="string">&quot;userFactory&quot;</span>, UserFactory.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;userFactory == userFactoryByLookup: &quot;</span> + (userFactory == userFactoryByLookup));</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="什么是spring-beandefinition"><a class="markdownIt-Anchor" href="#什么是spring-beandefinition"></a> 什么是Spring BeanDefinition？</h3>
<p>BeanDefinition是关于Bean定义的元信息的接口，允许我们通过getter、setter方法方式来进行存储信息。</p>
<h3 id="spring容器是怎样管理注册bean"><a class="markdownIt-Anchor" href="#spring容器是怎样管理注册bean"></a> Spring容器是怎样管理注册Bean</h3>
<p>如IoC配置元信息读取和解析、依赖查找和注入以及Bean生命周期等。</p>
<h1 id="依赖查找"><a class="markdownIt-Anchor" href="#依赖查找"></a> 依赖查找</h1>
<h2 id="依赖查找简介"><a class="markdownIt-Anchor" href="#依赖查找简介"></a> 依赖查找简介</h2>
<ol>
<li>单一类型依赖查找
<ul>
<li>JNDI - javax.naming.Context#lookup(<a href="http://javax.naming.Name">javax.naming.Name</a>)</li>
<li>JavaBeans - java.beans.beancontext.BeanContext</li>
</ul>
</li>
<li>集合类型依赖查找
<ul>
<li>java.beans.beancontext.BeanContext</li>
</ul>
</li>
<li>层次性依赖查找
<ul>
<li>java.beans.beancontext.BeanContext</li>
</ul>
</li>
</ol>
<h2 id="单一类型依赖查找"><a class="markdownIt-Anchor" href="#单一类型依赖查找"></a> 单一类型依赖查找</h2>
<p>单一类型依赖查找接口-BeanFactory</p>
<ol>
<li>根据Bean名称查找
<ul>
<li>getBean(String)</li>
<li>Spring 2.5 覆盖默认参数：getBean(String,Object…)</li>
</ul>
</li>
<li>根据Bean类型查找
<ul>
<li>Bean实时查找
<ul>
<li>Spring 3.0 getBean(Class)</li>
<li>Spring 4.1 覆盖默认参数：getBean(Class,Object…)</li>
</ul>
</li>
<li>Spring 5.1 Bean延迟查找
<ul>
<li>getBeanProvider(Class)</li>
<li>getBeanProvider(ResolvableType)</li>
</ul>
</li>
</ul>
</li>
<li>根据Bean名称 + 类型查找：getBean(String,Class)</li>
</ol>
<p>利用ObejctProvider进行依赖查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过ObjectProvider进行依赖查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObejctProviderDemo</span> </span>&#123; <span class="comment">// @Configuration是非必须的注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(ObejctProviderDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        lookupByObejctProvider(applicationContext);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloworld</span><span class="params">()</span> </span>&#123; <span class="comment">// 方法名就是Bean名称 = “helloworld”</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByObejctProvider</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        ObjectProvider&lt;String&gt; beanProvider = applicationContext.getBeanProvider(String.class);</span><br><span class="line">        System.out.println(beanProvider.getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合类型依赖查找"><a class="markdownIt-Anchor" href="#集合类型依赖查找"></a> 集合类型依赖查找</h2>
<p>集合类型依赖查找接口-ListableBeanFactory</p>
<ol>
<li>根据Bean类型查找
<ul>
<li>根据同类型Bean名称列表
<ul>
<li>getBeanNamesForType（Class）</li>
<li>Spring 4.2 getBeanNamesForType（ResolvableType）</li>
</ul>
</li>
<li>获取同类型Bean实例列表
<ul>
<li>getBeanOfType（Class）以及重载方法</li>
</ul>
</li>
</ul>
</li>
<li>通过注解类型查找
<ul>
<li>Spring 3.0 获取标注类型Bean名称列表
<ul>
<li>getBeanNamesForAnnotation（Class&lt;? extends Annotation&gt;）</li>
</ul>
</li>
<li>Spring 3.0 获取标注类型Bean实例列表
<ul>
<li>getBeansWithAnnotation（Class&lt;? extends Annotation&gt;）</li>
</ul>
</li>
<li>Spring 3.0 获取指定名称 + 标注类型Bean 实例</li>
</ul>
</li>
</ol>
<p>相关的示例实际上在之前就已经提到过了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通过注解查找</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByAnnotationType</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">          ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;</span><br><span class="line">          Map&lt;String, User&gt; users = (Map)listableBeanFactory.getBeansWithAnnotation(Super.class);</span><br><span class="line">          System.out.println(<span class="string">&quot;查找到的所有标注@Super的User集合对象：&quot;</span> + users);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 按照类型查找集合对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupCollectionType</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">          ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;</span><br><span class="line">          Map&lt;String, User&gt; users = listableBeanFactory.getBeansOfType(User.class);</span><br><span class="line">          System.out.println(<span class="string">&quot;查找到的所有的User集合对象：&quot;</span> + users);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="层次性依赖查找"><a class="markdownIt-Anchor" href="#层次性依赖查找"></a> 层次性依赖查找</h2>
<p>层次性依赖查找接口-HierachicalBeanFactory</p>
<ol>
<li>双亲BeanFactory：getParentBeanFacotry</li>
<li>层次性查找：
<ul>
<li>根据Bean名称查找
<ul>
<li>基于containsLocalBean方法实现</li>
</ul>
</li>
<li>根据Bean类型查找实例列表
<ul>
<li>单一类型：BeanFactoryUtils#beanOfType</li>
<li>集合类型BeanFactoryUtils#beanOfTypeIncludingAncestors</li>
</ul>
</li>
<li>根据Java注解查找名称列表
<ul>
<li>BeanFactoryUtils#beanNamesForTypeIncludingAncestors</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="延迟依赖查找"><a class="markdownIt-Anchor" href="#延迟依赖查找"></a> 延迟依赖查找</h2>
<p>Bean延迟依赖查找接口</p>
<ol>
<li>org.springframework.beans.factory.ObjectFactory</li>
<li>org.springframwork.beans.factory.ObjecyProvider
<ul>
<li>Spring 5 对Java8特性扩展
<ul>
<li>函数式接口
<ul>
<li>getIfAvailable(Supplier)</li>
<li>ifAvailable(Consumer)</li>
</ul>
</li>
<li>Stream扩展-stream()</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>相关示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObejctProviderDemo</span> </span>&#123; <span class="comment">// @Configuration是非必须的注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(ObejctProviderDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        lookupByObejctProvider(applicationContext);</span><br><span class="line">        lookupIfAvailable(applicationContext);</span><br><span class="line">        lookupByStreamOps(applicationContext);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByStreamOps</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        ObjectProvider&lt;String&gt; beanProvider = applicationContext.getBeanProvider(String.class);</span><br><span class="line"><span class="comment">//        Iterable&lt;String&gt; stringIterable = beanProvider;</span></span><br><span class="line"><span class="comment">//        for (String string : stringIterable) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(string);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        beanProvider.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupIfAvailable</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// User对象并不存在</span></span><br><span class="line">        ObjectProvider&lt;User&gt; userObjectProvider = applicationContext.getBeanProvider(User.class);</span><br><span class="line">        User user = userObjectProvider.getIfAvailable(User::createUser);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前User对象: &quot;</span> + user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloworld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByObejctProvider</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        ObjectProvider&lt;String&gt; beanProvider = applicationContext.getBeanProvider(String.class);</span><br><span class="line">        System.out.println(beanProvider.getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="安全依赖查找"><a class="markdownIt-Anchor" href="#安全依赖查找"></a> 安全依赖查找</h2>
<p>安全性指的是没有查找到Bean的时候，是否会抛出异常。有关依赖查找安全性对比如下</p>
<table>
<thead>
<tr>
<th>依赖查找类型</th>
<th>代表实现</th>
<th>是否安全</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一类型查找</td>
<td>BeanFactory#getBean</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td>ObjectFactory#getObject</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td>ObjectProvider#getIfAvailable</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td></td>
<td>是</td>
</tr>
<tr>
<td>集合类型查找</td>
<td>ListableBeanFactory#getBeansOfType</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td>ObjectProvider#stream</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>注意：层次性依赖查找的安全性取决于其扩展的单一或集合类型的BeanFactory接口。</p>
<p>类型安全的依赖查找的相关示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类型安全的依赖查找示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeSafetyDependencyLookupDemp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(TypeSafetyDependencyLookupDemp.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="comment">// 演示BeanFactory#getBean方法的安全性</span></span><br><span class="line">        displayBeanFactoryGetBean(applicationContext);</span><br><span class="line">        <span class="comment">// 演示ObjectFactory#getObject方法的安全性</span></span><br><span class="line">        displayBeanFactoryGetObject(applicationContext);</span><br><span class="line">        <span class="comment">// 演示ObjectProvider#ifAvailable方法的安全性</span></span><br><span class="line">        displayObjectProviderIfAvailable(applicationContext);</span><br><span class="line">        <span class="comment">// 演示ListableBeanFactory#getBeansOfTYpe方法的安全性</span></span><br><span class="line">        displayListableBeanFactoryGetBeansType(applicationContext);</span><br><span class="line">        <span class="comment">// 演示ObjectProvider#stream方法的安全性</span></span><br><span class="line">        displayObjectProviderStreamOps(applicationContext);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayObjectProviderStreamOps</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        ObjectProvider&lt;User&gt; userObjectProvider = applicationContext.getBeanProvider(User.class);</span><br><span class="line">        printBeansException(<span class="string">&quot;displayObjectProviderStreamOps&quot;</span>, () -&gt; userObjectProvider.stream().forEach(System.out::println));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayListableBeanFactoryGetBeansType</span><span class="params">(ListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        printBeansException(<span class="string">&quot;displayListableBeanFactoryGetBeansType&quot;</span>,() -&gt; beanFactory.getBeanNamesForType(User.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayObjectProviderIfAvailable</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        ObjectProvider&lt;User&gt; objectProvider = applicationContext.getBeanProvider(User.class);</span><br><span class="line">        printBeansException(<span class="string">&quot;displayObjectProviderIfAvailable&quot;</span>, objectProvider::getIfAvailable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayBeanFactoryGetObject</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ObjectProvider is ObjectFactory</span></span><br><span class="line">        ObjectFactory&lt;User&gt; userObjectFactory = applicationContext.getBeanProvider(User.class);</span><br><span class="line">        printBeansException(<span class="string">&quot;displayBeanFactoryGetObject&quot;</span>, userObjectFactory::getObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayBeanFactoryGetBean</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        printBeansException(<span class="string">&quot;displayBeanFactoryGetBean&quot;</span>, () -&gt; beanFactory.getBean(User.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBeansException</span><span class="params">(String source, Runnable runnable)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Source from: &quot;</span> + source);</span><br><span class="line">        System.err.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内建可查找的依赖"><a class="markdownIt-Anchor" href="#内建可查找的依赖"></a> 内建可查找的依赖</h2>
<p>AbastractApplicationContext内建可查找的依赖：</p>
<table>
<thead>
<tr>
<th>Bean名称</th>
<th>Bena实例</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>environment</td>
<td>Environment对象</td>
<td>外部化配置以及Profiles</td>
</tr>
<tr>
<td>systemProperties</td>
<td>java.util.Properties对象</td>
<td>Java系统属性</td>
</tr>
<tr>
<td>systemEnvironment</td>
<td>java.util.Map对象</td>
<td>操作系统环境变量</td>
</tr>
<tr>
<td>messageSource</td>
<td>MessageSource对象</td>
<td>国际化文案</td>
</tr>
<tr>
<td>lifecycleProcessor</td>
<td>lifecycleProcessor对象</td>
<td>Lifecycle Bean处理器</td>
</tr>
<tr>
<td>applicationEventMulticaster</td>
<td>ApplicationEventMulticaster对象</td>
<td>Spring事件广播器</td>
</tr>
</tbody>
</table>
<p>注解驱动Spring应用上下文内建可查找的依赖（部分）：</p>
<table>
<thead>
<tr>
<th>Bean名称</th>
<th>Bean实例</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>org.springframework.context.event.internalConfigurationAnnotationProcessor</td>
<td>ConfigurationClassPostProcessor对象</td>
<td>处理Spring配置类</td>
</tr>
<tr>
<td>org.springframework.context.event.internalAutowiredAnnotationProcessor</td>
<td>AutowiredAnnotationBeanPostProcessor对象</td>
<td>处理@Autowired以及@Value注解</td>
</tr>
<tr>
<td>org.springframework.context.event.internalCommonAnnotationProcessor</td>
<td>CommonAnnotationBeanPostProcessor对象</td>
<td>（条件激活）处理JSR-250注解，如@PostConstruct等</td>
</tr>
<tr>
<td>org.springframework.context.event.internalEventListenerProcessor</td>
<td>EventListenerMethodProcessor对象</td>
<td>处理标注@EventListener的Spring事件监听方法</td>
</tr>
<tr>
<td>org.springframework.context.event.internalListenerFactory</td>
<td>DefaultEventListenerFactory对象</td>
<td>@EventListener事件监听方法适配为ApplicationListener</td>
</tr>
<tr>
<td>org.springframework.context.event.internalPersistenceAnnotationProcessor</td>
<td>PersistenceAnnotationProcessor对象</td>
<td>条件激活处理JPA注解场景</td>
</tr>
</tbody>
</table>
<p>这些内建的Bean的初始化都是在AnnotationConfigUtils中完成的。</p>
<h2 id="依赖查找中典型异常"><a class="markdownIt-Anchor" href="#依赖查找中典型异常"></a> 依赖查找中典型异常</h2>
<p>BeansException子类型</p>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>触发条件（举例）</th>
<th>场景举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>NoSuchBeanDefinitionException</td>
<td>当查找Bean不存在于IoC容器时</td>
<td>BeanFactory#getBean<br />ObjectFactory#getObject</td>
</tr>
<tr>
<td>NoUniqueBeanDefinitionException</td>
<td>类型查找时，IoC容器存在多个Bean实例</td>
<td>BeanFactory#getBean(Class)</td>
</tr>
<tr>
<td>BeanInstantiationException</td>
<td>当Bean所对应的类型非具体类时</td>
<td>BeanFactory#getBean</td>
</tr>
<tr>
<td>BeanCreationException</td>
<td>当Bean初始化过程中</td>
<td>Bean初始化方法执行异常时</td>
</tr>
<tr>
<td>BeanDefinitionStoreException</td>
<td>当BeanDefinition配置元信息非法时</td>
<td>XML配置资源无法打开时</td>
</tr>
</tbody>
</table>
<p>NoUniqueBeanDefinitionException示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NoUniqueBeanDefinitionException示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoUniqueBeanDefinitionExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(NoUniqueBeanDefinitionExceptionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            applicationContext.getBean(String.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoUniqueBeanDefinitionException e) &#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;Spring应用上下文存在%d 个 %s 类型的Bean,具体原因: %s%n&quot;</span>, e.getNumberOfBeansFound(),</span><br><span class="line">                    String.class.getName(), e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bean1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bean1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bean2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bean2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bean3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bean3&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeanInstantiationException示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanInstantiationException示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInstantiationExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册BeanDefinition</span></span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(CharSequence.class);</span><br><span class="line">        <span class="comment">// CharSequence是一个接口，所以实例化的时候会报错</span></span><br><span class="line">        applicationContext.registerBeanDefinition(<span class="string">&quot;errorBean&quot;</span>, beanDefinitionBuilder.getBeanDefinition());</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeanCreationException示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanCreationException示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanCreationExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册BeanDefinition</span></span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(POJO.class);</span><br><span class="line">        applicationContext.registerBeanDefinition(<span class="string">&quot;errorBean&quot;</span>, beanDefinitionBuilder.getBeanDefinition());</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">POJO</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Throwable(<span class="string">&quot;init(): For purposers...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;afterPropertiesSet(): For purposes...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-5"><a class="markdownIt-Anchor" href="#面试题-5"></a> 面试题</h2>
<h3 id="objectfactory与beanfactory的区别"><a class="markdownIt-Anchor" href="#objectfactory与beanfactory的区别"></a> ObjectFactory与BeanFactory的区别</h3>
<p>ObjectFactory与BeanFactory均提供依赖查找的能力，不过ObjectFactory仅关注一个或一种类型的Bean依赖查找，并且自身不具备依赖查找的能力，能力由BeanFactory输出。</p>
<p>BeanFactory则提供了单一类型、集合类型以及层次性等多种依赖查找方式。</p>
<h3 id="beanfactorygetbean操作是否线程安全"><a class="markdownIt-Anchor" href="#beanfactorygetbean操作是否线程安全"></a> BeanFactory.getBean操作是否线程安全？</h3>
<p>BeanFactory.getBean方法的执行是线程安全的，操作过程中会增加互斥锁。</p>
<h3 id="spring的依赖查找和依赖注入在来源上有什么区别"><a class="markdownIt-Anchor" href="#spring的依赖查找和依赖注入在来源上有什么区别"></a> Spring的依赖查找和依赖注入在来源上有什么区别？</h3>
<p>待定…</p>
<h1 id="依赖注入"><a class="markdownIt-Anchor" href="#依赖注入"></a> 依赖注入</h1>
<h2 id="依赖注入的模式和类型"><a class="markdownIt-Anchor" href="#依赖注入的模式和类型"></a> 依赖注入的模式和类型</h2>
<ol>
<li>手动模式-配置或者编程的方式，提前安排注入规则
<ul>
<li>XML资源配置元信息</li>
<li>Java注解配置元信息</li>
<li>API配置元信息</li>
</ul>
</li>
<li>自动模式-实现方提供依赖自动关联的方式，按照内建的注入规则
<ul>
<li>Autowring(自动绑定)</li>
</ul>
</li>
</ol>
<p>依赖注入类型：</p>
<table>
<thead>
<tr>
<th>依赖注入类型</th>
<th>配置元数据举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Setter方法</td>
<td><proepty name="user" ref="userBean" /></td>
</tr>
<tr>
<td>构造器</td>
<td><constructor-arg name="user" ref="userBean" /></td>
</tr>
<tr>
<td>字段</td>
<td>@Autowired<br />User user;</td>
</tr>
<tr>
<td>方法</td>
<td>@Autowired<br />public void user(User user) {…}</td>
</tr>
<tr>
<td>接口回调</td>
<td>class MyBean implements BeanFactoryAware{…}</td>
</tr>
</tbody>
</table>
<h2 id="自动绑定"><a class="markdownIt-Anchor" href="#自动绑定"></a> 自动绑定</h2>
<p>Autowiring modes:</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no</td>
<td>默认值，未激活Autowiring，需要手动指定依赖注入对象</td>
</tr>
<tr>
<td>byName</td>
<td>根据被注入属性的名称作为Bean名称进行依赖查找，并将对象设置到该属性</td>
</tr>
<tr>
<td>byType</td>
<td>根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性</td>
</tr>
<tr>
<td>constructor</td>
<td>特殊byType类型，用于构造器参数</td>
</tr>
</tbody>
</table>
<p>可以参考：org.springframework.beans.factory.annotation.Autowire。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Autowire</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Constant that indicates no autowiring at all.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	NO(AutowireCapableBeanFactory.AUTOWIRE_NO),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Constant that indicates autowiring bean properties by name.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	BY_NAME(AutowireCapableBeanFactory.AUTOWIRE_BY_NAME),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Constant that indicates autowiring bean properties by type.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	BY_TYPE(AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Autowire(<span class="keyword">int</span> value) &#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return whether this represents an actual autowiring value.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether actual autowiring was specified</span></span><br><span class="line"><span class="comment">	 * (either BY_NAME or BY_TYPE)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAutowire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span> == BY_NAME || <span class="keyword">this</span> == BY_TYPE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动绑定的不足之处：</p>
<ol>
<li>构造器参数以及property上面的设置通常会覆盖掉Autowiring，也不能绑定一些简单的类型，比如String、Classes、properties</li>
<li>Autowiring无法把控注入的时候的精确性，会导致一些不确定的情况发生。</li>
<li>wiring很难在工具上产生一些文档或者相关提示。</li>
<li>如果应用上下文中存在多个Bean的定义，会发生歧义性，可能会抛出NoUniqueBeanDefinitionException。</li>
</ol>
<h2 id="setter注入"><a class="markdownIt-Anchor" href="#setter注入"></a> Setter注入</h2>
<p>Setter注入实现方法：</p>
<ol>
<li>手动模式：
<ul>
<li>XML资源配置元信息</li>
<li>Java注解配置元信息</li>
<li>API配置元信息</li>
</ul>
</li>
<li>自动模式
<ul>
<li>byName</li>
<li>byType</li>
</ul>
</li>
</ol>
<p>这里我们新建一个UserHolder：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> User&#125; 的holder类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserHolder&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;user=&quot;</span> + user +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过XML的方式注入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.dependcy.injection.UserHolder&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;user&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过XML的方式注入演示的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于XML资源的依赖，Setter方法注入依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlDependencySetterInjectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/MTEA-INF/dependency-setter-injection.xml&quot;</span>;</span><br><span class="line">        <span class="comment">// 加载XML资源，解析并且生成BeanDefinition</span></span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line">        <span class="comment">//依赖查找并且创建Bean</span></span><br><span class="line">        UserHolder userHolder = beanFactory.getBean(UserHolder.class);</span><br><span class="line">        System.out.println(userHolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基于注解的依赖注入的演示示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于注解的Setter方法注入依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDependencySetterInjectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(AnnotationDependencySetterInjectionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line"></span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/MTEA-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line"></span><br><span class="line">        UserHolder userHolder = applicationContext.getBean(UserHolder.class);</span><br><span class="line">        System.out.println(userHolder);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserHolder <span class="title">userHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        UserHolder userHolder = <span class="keyword">new</span> UserHolder();</span><br><span class="line">        userHolder.setUser(user);</span><br><span class="line">        <span class="keyword">return</span> userHolder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于Api的依赖注入的演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于API的Setter方法注入依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiDependencySetterInjectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        BeanDefinition userBeanDefinition = createUserBeanDefinition();</span><br><span class="line">        <span class="comment">// 注册UserHolder的BeanDefinition</span></span><br><span class="line">        applicationContext.registerBeanDefinition(<span class="string">&quot;UserHolder&quot;</span>,userBeanDefinition);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/MTEA-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line"></span><br><span class="line">        UserHolder userHolder = applicationContext.getBean(UserHolder.class);</span><br><span class="line">        System.out.println(userHolder);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为&#123;<span class="doctag">@link</span> UserHolder&#125; 生成&#123;<span class="doctag">@link</span> BeanDefinition&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">createUserBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(UserHolder.class);</span><br><span class="line">        beanDefinitionBuilder.addPropertyReference(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;SuperUser&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动配置的主要应用场景在XML文件当中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--这里可以通过byType或者byName进行注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.dependcy.injection.UserHolder&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--        &lt;property name=&quot;user&quot; ref=&quot;user&quot; /&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="构造器注入"><a class="markdownIt-Anchor" href="#构造器注入"></a> 构造器注入</h2>
<p>构造器注入的实现方法：</p>
<ol>
<li>手动模式
<ul>
<li>XML资源配置元信息</li>
<li>Java注解配置元信息</li>
<li>API配置元信息</li>
</ul>
</li>
<li>自动模式
<ul>
<li>constructor</li>
</ul>
</li>
</ol>
<p>XML资源配置的方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.dependcy.injection.UserHolder&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;SuperUser&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>XML资源配置方式的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于XML资源的依赖，构造器注入依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlDependencyConstructorInjectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/META-INF/dependency-constructor-injection.xml&quot;</span>;</span><br><span class="line">        <span class="comment">// 加载XML资源，解析并且生成BeanDefinition</span></span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line">        <span class="comment">//依赖查找并且创建Bean</span></span><br><span class="line">        UserHolder userHolder = beanFactory.getBean(UserHolder.class);</span><br><span class="line">        System.out.println(userHolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java注解方式的核心部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserHolder <span class="title">userHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserHolder(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>API配置元信息的方式的核心部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为&#123;<span class="doctag">@link</span> UserHolder&#125; 生成&#123;<span class="doctag">@link</span> BeanDefinition&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">createUserBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(UserHolder.class);</span><br><span class="line">    beanDefinitionBuilder.addConstructorArgReference(<span class="string">&quot;SuperUser&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造器自动绑定的示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.dependcy.injection.UserHolder&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;constructor&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="字段注入"><a class="markdownIt-Anchor" href="#字段注入"></a> 字段注入</h2>
<p>实现方法：</p>
<ol>
<li>手动模式
<ul>
<li>@Autowird</li>
<li>@Resource</li>
<li>@inject（可选）</li>
</ul>
</li>
</ol>
<p>字段注入的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于注解的字段注入依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDependencyFiledInjectionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    <span class="comment">//static @Autowired会忽略掉静态字段</span></span><br><span class="line">    UserHolder userHolder;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserHolder userHolder2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 配置Class也是 Spring Bean</span></span><br><span class="line">        applicationContext.register(AnnotationDependencyFiledInjectionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line"></span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line"></span><br><span class="line">        AnnotationDependencyFiledInjectionDemo demo = applicationContext.getBean(AnnotationDependencyFiledInjectionDemo.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Autowired字段关联</span></span><br><span class="line">        UserHolder userHolder = demo.userHolder;</span><br><span class="line">        <span class="comment">// @Resource</span></span><br><span class="line">        UserHolder userHolder2 = demo.userHolder2;</span><br><span class="line">        System.out.println(userHolder);</span><br><span class="line">        System.out.println(userHolder2);</span><br><span class="line"></span><br><span class="line">        System.out.println(userHolder == userHolder2);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserHolder <span class="title">userHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserHolder(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法注入"><a class="markdownIt-Anchor" href="#方法注入"></a> 方法注入</h2>
<ol>
<li>手动模式
<ul>
<li>@Autowird</li>
<li>@Resource</li>
<li>@inject（可选）</li>
<li>@Bean</li>
</ul>
</li>
</ol>
<p>方法注入的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> UserHolder userHolder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> UserHolder userHolder2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initUserHolder</span><span class="params">(UserHolder userHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userHolder = userHolder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initUserHolder2</span><span class="params">(UserHolder userHolder2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userHolder2 = userHolder2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserHolder <span class="title">userHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserHolder(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口回调注入"><a class="markdownIt-Anchor" href="#接口回调注入"></a> 接口回调注入</h2>
<p>Aware系列接口回调</p>
<ol>
<li>
<p>自动模式</p>
<table>
<thead>
<tr>
<th>内建接口</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BeanFactoryAware</td>
<td>获取IoC容器-BeanFactory</td>
</tr>
<tr>
<td>ApplicationContextAware</td>
<td>获取Spring应用上下文-ApplicationConetxt对象</td>
</tr>
<tr>
<td>EnvironmentAware</td>
<td>获取Environment对象</td>
</tr>
<tr>
<td>ResourceLoaderAware</td>
<td>获取资源加载器对象-ResourceLoader</td>
</tr>
<tr>
<td>BeanClassLoaderAware</td>
<td>获取加载当前Bean Class的ClassLoader</td>
</tr>
<tr>
<td>BeanNameAware</td>
<td>获取当前Bean名称</td>
</tr>
<tr>
<td>MessageSourceAware</td>
<td>获取MessageSource对象，用于Spring国际化</td>
</tr>
<tr>
<td>ApplicationEventPublisherAware</td>
<td>获取ApplicationEventPublishAware对象，用于Spring事件</td>
</tr>
<tr>
<td>EmbeddedValueResolverAware</td>
<td>获取StringValueResolver对象，用占位符处理</td>
</tr>
</tbody>
</table>
<p>接口回调示例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于&#123;<span class="doctag">@link</span> org.springframework.beans.factory.Aware&#125; 接口回调的示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwareInterfaceDependencyInjectionDemo</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        AwareInterfaceDependencyInjectionDemo.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        AwareInterfaceDependencyInjectionDemo.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        context.register(AwareInterfaceDependencyInjectionDemo.class);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        System.out.println(beanFactory == context.getBeanFactory());</span><br><span class="line">        System.out.println(applicationContext == context);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="依赖注入类型选择"><a class="markdownIt-Anchor" href="#依赖注入类型选择"></a> 依赖注入类型选择</h2>
<p>注入选型</p>
<ol>
<li>低依赖：构造器注入</li>
<li>多以来：Setter方法注入</li>
<li>便利性：字段注入</li>
<li>声明类：方法注入</li>
</ol>
<h2 id="基础类型注入"><a class="markdownIt-Anchor" href="#基础类型注入"></a> 基础类型注入</h2>
<p>基础类型</p>
<ol>
<li>原生类型（Primitive）：boolean、byte、char、short、int、float、long、double</li>
<li>标量类型（Scalar）：Number、Character、Boolean、Enum、Locale、Charset、Currency、Properties、UUID</li>
<li>常规类型（General）：Object、String、TimeZone、Calendar、Optional等</li>
<li>Spring类型：Resource、InputSource、Formatter等。</li>
</ol>
<h2 id="集合类型注入"><a class="markdownIt-Anchor" href="#集合类型注入"></a> 集合类型注入</h2>
<p>集合类型</p>
<ol>
<li>数组类型（Array）：原生类型、标量类型、常规类型、Spring类型</li>
<li>集合类型（Collection）
<ul>
<li>Collection：List、Set（SortedSet、NavigableSet、EnumSet）</li>
<li>Map：Properties</li>
</ul>
</li>
</ol>
<h2 id="限定注入"><a class="markdownIt-Anchor" href="#限定注入"></a> 限定注入</h2>
<ol>
<li>使用注解@Qualifier限定
<ul>
<li>通过Bean名称限定</li>
<li>通过分组限定</li>
</ul>
</li>
<li>基于注解@Qualifier扩展限定
<ul>
<li>自定义注解，如Spring Cloud @LoadBalanced</li>
</ul>
</li>
</ol>
<p>使用注解@Qualifer限定Bean的名称的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.annotation.Qualifier&#125; 使用示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualifierAnnotationDependencyInjectionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// SuperUser -&gt; primary = true</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;user&quot;)</span> <span class="comment">// 指定Bean名称或者ID</span></span><br><span class="line">    <span class="keyword">private</span> User namedUser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(QualifierAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line">        QualifierAnnotationDependencyInjectionDemo demo = applicationContext.getBean(QualifierAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo.user = &quot;</span> + demo.user);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo.namedUser = &quot;</span> + demo.namedUser);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用@Qulifier对注入的Bean可以进行逻辑上的分组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.annotation.Qualifier&#125; 使用示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualifierAnnotationDependencyInjectionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// SuperUser -&gt; primary = true</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;user&quot;)</span> <span class="comment">// 指定Bean名称或者ID</span></span><br><span class="line">    <span class="keyword">private</span> User namedUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;User&gt; allUsers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;User&gt; qualifierUsers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier</span> <span class="comment">// 进行逻辑分组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(QualifierAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line">        QualifierAnnotationDependencyInjectionDemo demo = applicationContext.getBean(QualifierAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        <span class="comment">// 输出SuperUSer Bean</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.user = &quot;</span> + demo.user);</span><br><span class="line">        <span class="comment">// 输出 user Bean</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.namedUser = &quot;</span> + demo.namedUser);</span><br><span class="line">        <span class="comment">// 输出 SuperUSer、user,注意这里输出的不是所有的user对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.allUsers = &quot;</span> + demo.allUsers);</span><br><span class="line">        <span class="comment">// 输出 user1、user2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.qualifierUsers = &quot;</span> + demo.qualifierUsers);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过注解的定义我们可以看到@Qualifier注解还可以作用到注解上面，也就是说可以对这个注解进行一些自定义的扩展：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Qualifier &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们自定义一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UserGroup &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用自定义注解来进行分组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.annotation.Qualifier&#125; 使用示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualifierAnnotationDependencyInjectionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// SuperUser -&gt; primary = true</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;user&quot;)</span> <span class="comment">// 指定Bean名称或者ID</span></span><br><span class="line">    <span class="keyword">private</span> User namedUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;User&gt; allUsers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;User&gt; qualifierUsers;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@UserGroup</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;User&gt; groupedUsers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier</span> <span class="comment">// 进行逻辑分组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@UserGroup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@UserGroup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(QualifierAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line">        QualifierAnnotationDependencyInjectionDemo demo = applicationContext.getBean(QualifierAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        <span class="comment">// 输出SuperUSer Bean</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.user = &quot;</span> + demo.user);</span><br><span class="line">        <span class="comment">// 输出 user Bean</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.namedUser = &quot;</span> + demo.namedUser);</span><br><span class="line">        <span class="comment">// 输出 SuperUSer、user,注意这里输出的不是所有的user对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.allUsers = &quot;</span> + demo.allUsers);</span><br><span class="line">        <span class="comment">// 输出 user1、user2、user3和user4,这个时候这个集合元素也增加了,这种方式了类似继承</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.qualifierUsers = &quot;</span> + demo.qualifierUsers);</span><br><span class="line">        <span class="comment">// 输出 user3和user4</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.groupedUsers = &quot;</span> + demo.groupedUsers);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们来查看以下@LoadBalanced注解的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LoadBalanced &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="延迟依赖注入"><a class="markdownIt-Anchor" href="#延迟依赖注入"></a> 延迟依赖注入</h2>
<ol>
<li>使用API ObjectFactory延迟注入
<ul>
<li>单一类型</li>
<li>集合类型</li>
</ul>
</li>
<li>使用API ObjectProvider延迟注入（推荐，这里主要是基于安全性的考量）
<ul>
<li>单一类型</li>
<li>集合类型</li>
</ul>
</li>
</ol>
<p>使用ObjectProvider延迟注入的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.ObjectProvider&#125; 实现延迟依赖注入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyAnnotationDependencyInjectionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;  <span class="comment">// 实时注入</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectProvider&lt;User&gt; userObjectProvider; <span class="comment">//延迟注入</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectProvider&lt;Set&lt;User&gt;&gt; usersObjectFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(LazyAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line">        LazyAnnotationDependencyInjectionDemo demo = applicationContext.getBean(LazyAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo.user = &quot;</span> + demo.user);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo.userObjectProvider = &quot;</span> + demo.userObjectProvider);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo.usersObjectFactory&quot;</span> + demo.usersObjectFactory);</span><br><span class="line">        demo.userObjectProvider.forEach(System.out::println);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="依赖处理的过程"><a class="markdownIt-Anchor" href="#依赖处理的过程"></a> 依赖处理的过程</h2>
<p>基础知识：</p>
<ol>
<li>入口-DefaultListableBeanFactory#resolveDependency</li>
<li>依赖描述符-DependencyDescriptor</li>
<li>自定义绑定候选对象处理器-AutowireCandidateResolver</li>
</ol>
<p>首先观察以下依赖的描述类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyDescriptor</span> <span class="keyword">extends</span> <span class="title">InjectionPoint</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 被注入的容器类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; declaringClass;</span><br><span class="line">	<span class="comment">// 方法名称</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> String methodName;</span><br><span class="line">	<span class="comment">// 构造器参数</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line">	<span class="comment">// 参数索引</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> parameterIndex;</span><br><span class="line">	<span class="comment">// 属性名称</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> String fieldName;</span><br><span class="line">	<span class="comment">// 是不是必须的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> required;</span><br><span class="line">	<span class="comment">// 是不是饥饿的，@Lazy注解</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> eager;</span><br><span class="line">	<span class="comment">// 嵌入层次</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> nestingLevel = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 包含类</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> Class&lt;?&gt; containingClass;</span><br><span class="line">	<span class="comment">// 泛型处理</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> ResolvableType resolvableType;</span><br><span class="line">	<span class="comment">// 类型描述</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> TypeDescriptor typeDescriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先改造以下我们之前看到的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解驱动的依赖注入过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDependencyInjectionResolutionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;  <span class="comment">// DependencyDescriptor -&gt;</span></span><br><span class="line">                        <span class="comment">// 必须（required=true）</span></span><br><span class="line">                        <span class="comment">// 实时注入（eager=true）</span></span><br><span class="line">                        <span class="comment">// 通过类型查找（User.class）</span></span><br><span class="line">                        <span class="comment">// 字段名称（“user”）</span></span><br><span class="line">                        <span class="comment">// 是否首要（primary=true）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(AnnotationDependencyInjectionResolutionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line">        AnnotationDependencyInjectionResolutionDemo demo = applicationContext.getBean(AnnotationDependencyInjectionResolutionDemo.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo.user = &quot;</span> + demo.user);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在DefaultListableBeanFactory#resolveDependency处打个断点进行观察：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210624205345978.png" alt="image-20210624205345978" /></p>
<p>方法会继续往下执行到doResolveDependency方法：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210624205434583.png" alt="image-20210624205434583" /></p>
<p>集合注入和单个类型的注入略微有点差别，首先我们增加一个成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>          <span class="comment">// 集合类型的依赖注入</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String,User&gt; users;  <span class="comment">// user SuperUser</span></span><br></pre></td></tr></table></figure>
<p>这个时候在返回的时候就会进行判断，判断返回的类型是什么，然后然后把结果放进去进行返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">resolveMultipleBeans</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (descriptor <span class="keyword">instanceof</span> StreamDependencyDescriptor) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">		<span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">			autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">		&#125;</span><br><span class="line">		Stream&lt;Object&gt; stream = matchingBeans.keySet().stream()</span><br><span class="line">				.map(name -&gt; descriptor.resolveCandidate(name, type, <span class="keyword">this</span>))</span><br><span class="line">				.filter(bean -&gt; !(bean <span class="keyword">instanceof</span> NullBean));</span><br><span class="line">		<span class="keyword">if</span> (((StreamDependencyDescriptor) descriptor).isOrdered()) &#123;</span><br><span class="line">			stream = stream.sorted(adaptOrderComparator(matchingBeans));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> stream;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (type.isArray()) &#123;</span><br><span class="line">		Class&lt;?&gt; componentType = type.getComponentType();</span><br><span class="line">		ResolvableType resolvableType = descriptor.getResolvableType();</span><br><span class="line">		Class&lt;?&gt; resolvedArrayType = resolvableType.resolve(type);</span><br><span class="line">		<span class="keyword">if</span> (resolvedArrayType != type) &#123;</span><br><span class="line">			componentType = resolvableType.getComponentType().resolve();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (componentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, componentType,</span><br><span class="line">				<span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">		<span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">			autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">		&#125;</span><br><span class="line">		TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">		Object result = converter.convertIfNecessary(matchingBeans.values(), resolvedArrayType);</span><br><span class="line">		<span class="keyword">if</span> (result <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">			Comparator&lt;Object&gt; comparator = adaptDependencyComparator(matchingBeans);</span><br><span class="line">			<span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">				Arrays.sort((Object[]) result, comparator);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Collection.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) &#123;</span><br><span class="line">		Class&lt;?&gt; elementType = descriptor.getResolvableType().asCollection().resolveGeneric();</span><br><span class="line">		<span class="keyword">if</span> (elementType == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType,</span><br><span class="line">				<span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">		<span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">			autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">		&#125;</span><br><span class="line">		TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">		Object result = converter.convertIfNecessary(matchingBeans.values(), type);</span><br><span class="line">		<span class="keyword">if</span> (result <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">			<span class="keyword">if</span> (((List&lt;?&gt;) result).size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">				Comparator&lt;Object&gt; comparator = adaptDependencyComparator(matchingBeans);</span><br><span class="line">				<span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">					((List&lt;?&gt;) result).sort(comparator);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// Map类型</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Map.class == type) &#123;</span><br><span class="line">           <span class="comment">// 获取到users字段的Map的泛型信息</span></span><br><span class="line">		ResolvableType mapType = descriptor.getResolvableType().asMap();</span><br><span class="line">		Class&lt;?&gt; keyType = mapType.resolveGeneric(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (String.class != keyType) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Class&lt;?&gt; valueType = mapType.resolveGeneric(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (valueType == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, valueType,</span><br><span class="line">				<span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">		<span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">			autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> matchingBeans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当进行集合类型的注入时，定义Bean的顺序也就是加载Bean的顺序，也是初始化Bean的时候的顺序。</p>
<p>在Java8之后，也可以注入Optional类型的字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Optional&lt;User&gt; userOptional;</span><br></pre></td></tr></table></figure>
<p>当注入的类型时延迟查找时，实际上会返回一个代理对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Lazy</span></span><br><span class="line">   <span class="keyword">private</span> User lazyUser;</span><br></pre></td></tr></table></figure>
<p>总的来说，依赖注入的处理主要就是由以下两个方法来完成的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String requestingBeanName,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line">       <span class="comment">// 对于Optional类型的判断</span></span><br><span class="line">	<span class="keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">		<span class="keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||</span><br><span class="line">			ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DependencyObjectProvider(descriptor, requestingBeanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(</span><br><span class="line">				descriptor, requestingBeanName);</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">			result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object shortcut = descriptor.resolveShortcut(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span> (shortcut != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> shortcut;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">		Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">		<span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">				String strVal = resolveEmbeddedValue((String) value);</span><br><span class="line">				BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; containsBean(beanName) ?</span><br><span class="line">						getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</span><br><span class="line">				value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">			&#125;</span><br><span class="line">			TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (UnsupportedOperationException ex) &#123;</span><br><span class="line">				<span class="comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span></span><br><span class="line">				<span class="keyword">return</span> (descriptor.getField() != <span class="keyword">null</span> ?</span><br><span class="line">						converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">						converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">		<span class="keyword">if</span> (multipleBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> multipleBeans;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">		<span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">				raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		String autowiredBeanName;</span><br><span class="line">		Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">			<span class="keyword">if</span> (autowiredBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">					<span class="keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line">					<span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line">					<span class="comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We have exactly one match.</span></span><br><span class="line">			Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">			autowiredBeanName = entry.getKey();</span><br><span class="line">			instanceCandidate = entry.getValue();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">			autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (instanceCandidate <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">			instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Object result = instanceCandidate;</span><br><span class="line">		<span class="keyword">if</span> (result <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">				raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">			&#125;</span><br><span class="line">			result = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="autowird注入"><a class="markdownIt-Anchor" href="#autowird注入"></a> @Autowird注入</h2>
<p>@Autowired注入总体过程：</p>
<ol>
<li>元信息解析</li>
<li>依赖查找</li>
<li>依赖注入（字段、方法）</li>
</ol>
<p>核心处理方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object bean, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">             <span class="comment">// 标注了@Autowired注解的字段</span></span><br><span class="line">			Field field = (Field) <span class="keyword">this</span>.member;</span><br><span class="line">			Object value;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					value = resolvedCachedArgument(beanName, <span class="keyword">this</span>.cachedFieldValue);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">					<span class="comment">// Unexpected removal of target bean for cached argument -&gt; re-resolve</span></span><br><span class="line">					value = resolveFieldValue(field, bean, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				value = resolveFieldValue(field, bean, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 有可能时非public字段</span></span><br><span class="line">				ReflectionUtils.makeAccessible(field);</span><br><span class="line">                 <span class="comment">// 最终通过反射的方式将依赖注入的对象设置到属性上</span></span><br><span class="line">				field.set(bean, value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>在XML中配置信息解析的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">	InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		metadata.inject(bean, beanName, pvs);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法会在set方法执行之前就执行，并且这个时候还没有进行类型转换。当这个类有父类的时候，会进行属性合并的操作，并且是在postProcessProperties之前执行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">		InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">		metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>一直会找到所有父类中的属性的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> MergedAnnotation&lt;?&gt; findAutowiredAnnotation(AccessibleObject ao) &#123;</span><br><span class="line">	MergedAnnotations annotations = MergedAnnotations.from(ao);</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; type : <span class="keyword">this</span>.autowiredAnnotationTypes) &#123;</span><br><span class="line">		MergedAnnotation&lt;?&gt; annotation = annotations.get(type);</span><br><span class="line">		<span class="keyword">if</span> (annotation.isPresent()) &#123;</span><br><span class="line">			<span class="keyword">return</span> annotation;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用上述方法的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">			MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(field);</span><br><span class="line">			<span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 可以看到就是在这里排除掉了static的字段</span></span><br><span class="line">				<span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">						logger.info(<span class="string">&quot;Autowired annotation is not supported on static fields: &quot;</span> + field);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">				currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到在postProcessMergedBeanDefinition就完成了Bean的元信息的组装，并且在postProcessProperties执行的时候会包含调用DefaultListableBeanFactory#resolveDependency方法的过程。</p>
<h2 id="inject和autowired联系"><a class="markdownIt-Anchor" href="#inject和autowired联系"></a> @Inject和@Autowired联系</h2>
<p>@Inject注入过程</p>
<ul>
<li>如果JSR-330存在于ClassPath中，就直接复用AutowiredAnnotationBeanPostProcessor的实现。</li>
</ul>
<p>在源代码中可以看到相关的逻辑：</p>
<p>这里首先要关注一个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Class&lt;? extends Annotation&gt;&gt; autowiredAnnotationTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到autowiredAnnotationTypes实际上是一个有序的Set集合，接下来是具体处理的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AutowiredAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 依次插入Autowired、Value、inject</span></span><br><span class="line">	<span class="keyword">this</span>.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">	<span class="keyword">this</span>.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)</span><br><span class="line">				ClassUtils.forName(<span class="string">&quot;javax.inject.Inject&quot;</span>, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">		logger.trace(<span class="string">&quot;JSR-330 &#x27;javax.inject.Inject&#x27; annotation found and supported for autowiring&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">		<span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到实际上还可以进行复合注解，并且在处理的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> MergedAnnotation&lt;?&gt; findAutowiredAnnotation(AccessibleObject ao) &#123;</span><br><span class="line">	MergedAnnotations annotations = MergedAnnotations.from(ao);</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; type : <span class="keyword">this</span>.autowiredAnnotationTypes) &#123;</span><br><span class="line">		MergedAnnotation&lt;?&gt; annotation = annotations.get(type);</span><br><span class="line">		<span class="keyword">if</span> (annotation.isPresent()) &#123;</span><br><span class="line">			<span class="keyword">return</span> annotation;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，如果要使用@Inject注解，就需要引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以发现@Inject和@Autowired注解在处理的上完全一样的，都是使用AutowiredAnnotationBeanPostProcessor来处理依赖注入的过程。</p>
<h2 id="java通用注解原理"><a class="markdownIt-Anchor" href="#java通用注解原理"></a> Java通用注解原理</h2>
<p>CommonAnnotationBeanPostProcessor</p>
<ol>
<li>注入注解
<ul>
<li>javax.xml.ws.WebServiceRef</li>
<li>javax.ejb.EJB</li>
<li>javax.annotation.Resource</li>
</ul>
</li>
<li>生命周期注解
<ul>
<li>javax.annotation.PostConstruct</li>
<li>javax.annotation.PreDestory</li>
</ul>
</li>
</ol>
<p>CommonAnnotationBeanPostProcessor和AutowiredAnnotationBeanPostProcessor大概的实现逻辑是如出一辙的，只是在细微的地方略有差别。</p>
<p>CommonAnnotationBeanPostProcessor实现了InitDestroyAnnotationBeanPostProcessor接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InitDestroyAnnotationBeanPostProcessor</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>在InitDestroyAnnotationBeanPostProcessor中也可以看到postProcessMergedBeanDefinition这个方法：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210624205533354.png" alt="image-20210624205533354" /></p>
<p>这里只是元信息不太一样，这主要是LifecycleMetadata中包含了初始化和销毁两个阶段。</p>
<p>同样CommonAnnotationBeanPostProcessor也有postProcessProperties的方法：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210624205605481.png" alt="image-20210624205605481" /></p>
<p>对于生命周期的注解的处理，可以从构造方法中看出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommonAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 优先级是倒数第四位的</span></span><br><span class="line">		setOrder(Ordered.LOWEST_PRECEDENCE - <span class="number">3</span>);</span><br><span class="line">		setInitAnnotationType(PostConstruct.class);</span><br><span class="line">		setDestroyAnnotationType(PreDestroy.class);</span><br><span class="line">		ignoreResourceType(<span class="string">&quot;javax.xml.ws.WebServiceContext&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>CommonAnnotationBeanPostProcessor会在AutowiredAnnotationBeanPostProcessor之前进行处理，这一点，可以通过实现的PriorityOrdered接口，看到属性中定义的顺序来进行确认。</p>
<h2 id="自定义依赖注入注解"><a class="markdownIt-Anchor" href="#自定义依赖注入注解"></a> 自定义依赖注入注解</h2>
<ol>
<li>基于AutowiredAnnotationBeanPostProcessor实现</li>
<li>自定义实现
<ul>
<li>生命周期处理
<ul>
<li>InstantiationAwareBeanPostProcessor</li>
<li>MergedBeanDefinitionPostProcessor</li>
</ul>
</li>
<li>元数据
<ul>
<li>InjectedElement</li>
<li>InjectionMetadata</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>基于AutowiredAnnotationBeanPostProcessor实现自定义依赖注入相对比较容易，如果使用自定义实现，就比较麻烦。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAutowired &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里我们不对@Autowired做任何的扩展，仅仅使用它进行元标注，定义完成之后使用MyAutowired进行注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAutowired</span></span><br><span class="line">  <span class="keyword">private</span> Optional&lt;User&gt; userOptional;</span><br></pre></td></tr></table></figure>
<p>发现依然可以正常地工作，接下来我们自定义一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义依赖注入注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InjectedUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将我们自定义的注解类型添加到AutowiredAnnotationBeanPostProcessor中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean(name = AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)</span> <span class="comment">//注意这里是static方法，会提前初始化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AutowiredAnnotationBeanPostProcessor <span class="title">beanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AutowiredAnnotationBeanPostProcessor beanPostProcessor = <span class="keyword">new</span> AutowiredAnnotationBeanPostProcessor();</span><br><span class="line">        <span class="comment">// 替换原有注解处理，使用新注解@InjectedUser，原来的注解会失效</span></span><br><span class="line"><span class="comment">//        beanPostProcessor.setAutowiredAnnotationType(InjectedUser.class);</span></span><br><span class="line">        <span class="comment">// 保留原来的方式，添加新的注解，@Autowired + @InjectedUser</span></span><br><span class="line">        Set&lt;Class&lt;? extends Annotation&gt;&gt; autowiredAnnotationTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(Autowired.class, Inject.class, InjectedUser.class));</span><br><span class="line">        beanPostProcessor.setAutowiredAnnotationTypes(autowiredAnnotationTypes);</span><br><span class="line">        <span class="keyword">return</span> beanPostProcessor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>测试我们的注解是否生效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InjectedUser</span></span><br><span class="line">  <span class="keyword">private</span> User myInjectedUser;</span><br></pre></td></tr></table></figure>
<p>答案是肯定的。如何实现新老注解的兼容的注入方法呢？</p>
<p>首先注入一个AutowiredAnnotationBeanPostProcessor，并设置我们自定义的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Order(Ordered.LOWEST_PRECEDENCE - 3)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AutowiredAnnotationBeanPostProcessor <span class="title">beanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       AutowiredAnnotationBeanPostProcessor beanPostProcessor = <span class="keyword">new</span> AutowiredAnnotationBeanPostProcessor();</span><br><span class="line">       beanPostProcessor.setAutowiredAnnotationType(InjectedUser.class);</span><br><span class="line">       <span class="keyword">return</span> beanPostProcessor;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>​	在AnnotationConfigUtils#registerAnnotationConfigProcessors中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">			RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">			def.setSource(source);</span><br><span class="line">			beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到如果AutowiredAnnotationBeanPostProcessor这个Bean存在的话，就不注册，不存在的会注册一个默认的，因为我们这里注入AutowiredAnnotationBeanPostProcessor采用的static，就会首先使用我们注册的AutowiredAnnotationBeanPostProcessor来进行依赖注入，这时候，在应用上下文中有两个AutowiredAnnotationBeanPostProcessor来进行处理。</p>
<h2 id="面试题-6"><a class="markdownIt-Anchor" href="#面试题-6"></a> 面试题</h2>
<h3 id="有多少种依赖注入的方式"><a class="markdownIt-Anchor" href="#有多少种依赖注入的方式"></a> 有多少种依赖注入的方式</h3>
<p>构造器注入、Setter注入、字段注入、方法注入、接口回调注入</p>
<h3 id="你偏好构造器注入还是setter注入"><a class="markdownIt-Anchor" href="#你偏好构造器注入还是setter注入"></a> 你偏好构造器注入还是Setter注入?</h3>
<p>两种依赖注入的方式均可以使用，如果是必须依赖的话，那么推荐使用构造器注入，Setter注入用于可选依赖。</p>
<h3 id="spring依赖注入的来源有哪些"><a class="markdownIt-Anchor" href="#spring依赖注入的来源有哪些"></a> Spring依赖注入的来源有哪些？</h3>
<p>待续…</p>
<h1 id="spring-ioc依赖来源"><a class="markdownIt-Anchor" href="#spring-ioc依赖来源"></a> Spring IoC依赖来源</h1>
<h2 id="依赖查找的来源"><a class="markdownIt-Anchor" href="#依赖查找的来源"></a> 依赖查找的来源</h2>
<p>查找来源：</p>
<table>
<thead>
<tr>
<th>来源</th>
<th>配置元数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring BeanDefinition</td>
<td><code>&lt;bean id=&quot;user&quot; class=&quot;org...User&quot;&gt;</code></td>
</tr>
<tr>
<td></td>
<td>@Bean<br />public User user(){…}</td>
</tr>
<tr>
<td></td>
<td>BeanDefinitionBuilder</td>
</tr>
<tr>
<td>单例对象</td>
<td>API实现</td>
</tr>
</tbody>
</table>
<h2 id="依赖注入的来源"><a class="markdownIt-Anchor" href="#依赖注入的来源"></a> 依赖注入的来源</h2>
<p>注入来源：</p>
<table>
<thead>
<tr>
<th>来源</th>
<th>配置元数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring BeanDefinition</td>
<td><code>&lt;bean id=&quot;user&quot; class=&quot;org...User&quot;&gt;</code></td>
</tr>
<tr>
<td></td>
<td>@Bean<br />public User user(){…}</td>
</tr>
<tr>
<td></td>
<td>BeanDefinitionBuilder</td>
</tr>
<tr>
<td>单例对象</td>
<td>API实现</td>
</tr>
<tr>
<td>非Spring容器管理对象（游离对象）</td>
<td></td>
</tr>
</tbody>
</table>
<p>AbstractApplicationContext#refresh()方法会调用prepareBeanFactory(beanFactory)方法，这个方法中会注入一些Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line"><span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line"><span class="comment">// 注意接下来的都是当前ApplicationContext对象</span></span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>实际上，注入了四个类型，两个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 依赖来源示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencySourceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入在postProcessProperties方法执行，早于setter注入，也早于PostConstruct</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beanFactory == applicationContext: &quot;</span> + (beanFactory == applicationContext));</span><br><span class="line">        System.out.println(<span class="string">&quot;beanFactory == applicationContext.getBeanFactory: &quot;</span> + (beanFactory == applicationContext.getAutowireCapableBeanFactory()));</span><br><span class="line">        System.out.println(<span class="string">&quot;resourceLoader == applicationContext: &quot;</span> + (resourceLoader == applicationContext));</span><br><span class="line">        System.out.println(<span class="string">&quot;applicationEventMulticaster == applicationContext: &quot;</span> + (applicationEventPublisher == applicationContext));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initByLookup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getBean(BeanFactory.class);</span><br><span class="line">        getBean(ResourceLoader.class);</span><br><span class="line">        getBean(ApplicationContext.class);</span><br><span class="line">        getBean(ApplicationEventPublisher.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; beanType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> beanFactory.getBean(beanType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;当前类型&quot;</span> + beanType.getName() + <span class="string">&quot;无法在BeanFactory中查找&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(DependencySourceDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line"></span><br><span class="line">        DependencySourceDemo demo = applicationContext.getBean(DependencySourceDemo.class);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring容器管理和游离对象"><a class="markdownIt-Anchor" href="#spring容器管理和游离对象"></a> Spring容器管理和游离对象</h2>
<p>依赖对象：</p>
<table>
<thead>
<tr>
<th>来源</th>
<th>Spring Bean对象</th>
<th>生命周期管理</th>
<th>配置元信息</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring BeanDefinition</td>
<td>是</td>
<td>是</td>
<td>有</td>
<td>依赖查找、依赖注入</td>
</tr>
<tr>
<td>单体对象</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>依赖查找、依赖注入</td>
</tr>
<tr>
<td>Resolvable Dependency</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>依赖注入</td>
</tr>
</tbody>
</table>
<h2 id="spring-beandefinition作为依赖来源"><a class="markdownIt-Anchor" href="#spring-beandefinition作为依赖来源"></a> Spring BeanDefinition作为依赖来源</h2>
<p>要素：</p>
<ol>
<li>元数据：BeanDefinition</li>
<li>注册：BeanDefinitionRegistry#registerBeanDefinition</li>
<li>类型：延迟和非延迟</li>
<li>顺序：Bean生命周期顺序按照注册顺序</li>
</ol>
<p>BeanDefinitionRegistry有且仅有一个实现，就是DefaultListableBeanFactory，首先有这样两个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map of bean definition objects, keyed by bean name</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">// List of bean definition names, in registration order.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>
<p>在registerBeanDefinition方法中会这样保存数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br></pre></td></tr></table></figure>
<p>可以看到这里除了保存beanName和beanDefinition，还单独保存了beanName，这样做的原因就是ConcurrentHashMap是无序的，而ArrayList是有序的，后面在初始化的时候，会根据这个List里面的Bean的名称，按照次序依次进行初始化操作。</p>
<h2 id="单体对象作为依赖来源"><a class="markdownIt-Anchor" href="#单体对象作为依赖来源"></a> 单体对象作为依赖来源</h2>
<p>要素：</p>
<ol>
<li>来源：外部普通Java对象（不一定是POJO）</li>
<li>注册：SingletonBeanRegistry#registerSinleton</li>
</ol>
<p>限制：</p>
<ol>
<li>无生命周期管理</li>
<li>无法实现延迟初始化Bean</li>
</ol>
<h2 id="resolvable-dependency作为依赖来源"><a class="markdownIt-Anchor" href="#resolvable-dependency作为依赖来源"></a> Resolvable Dependency作为依赖来源</h2>
<p>要素：</p>
<ul>
<li>注册：ConfigurableListableBeanFactory#registerResolvableDependency</li>
</ul>
<p>限制：</p>
<ol>
<li>无生命周期管理</li>
<li>无法延迟初始化Bean</li>
<li>无法通过依赖查找</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ResolvableDependency作为依赖来源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResolvableDependencySourceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(ResolvableDependencySourceDemo.class);</span><br><span class="line">        <span class="comment">// 只能用于类型方面的依赖注入</span></span><br><span class="line">        applicationContext.addBeanFactoryPostProcessor(beanFactory -&gt; &#123;</span><br><span class="line">            beanFactory.registerResolvableDependency(String.class,<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="外部化配置作为依赖来源"><a class="markdownIt-Anchor" href="#外部化配置作为依赖来源"></a> 外部化配置作为依赖来源</h2>
<p>要素：</p>
<ul>
<li>类型：非常规Spring对象依赖来源</li>
</ul>
<p>限制：</p>
<ol>
<li>无生命周期管理</li>
<li>无法实现延迟初始化Bean</li>
<li>无法通过依赖查找</li>
</ol>
<p>外部化配置的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外部化配置作为依赖来源示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;META-INF/default.properties&quot;,encoding = &quot;GBK&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalConfigurationDependencySourceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;user.id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;user.resource&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Resource resource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是中文，这里会显示操作系统登录的用户名，而不是在配置文件中配置的信息。这是因为user.name是一个系统属性。</span></span><br><span class="line"><span class="comment">//    @Value(&quot;$&#123;user.name&#125;&quot;)</span></span><br><span class="line"><span class="comment">//    private String name;</span></span><br><span class="line">    <span class="comment">// 直接输出会显示乱码,需要设置编码</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;usr.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(ExternalConfigurationDependencySourceDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        ExternalConfigurationDependencySourceDemo demo = applicationContext.getBean(ExternalConfigurationDependencySourceDemo.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + demo.id);</span><br><span class="line">        System.out.println(<span class="string">&quot;resource: &quot;</span> + demo.resource);</span><br><span class="line">        System.out.println(<span class="string">&quot;name: &quot;</span> + demo.name);</span><br><span class="line"></span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现原理就是DefaultListableBeanFactory#doResolveDependency中：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210624205723539.png" alt="image-20210624205723539" /></p>
<p>会通过接下来的方法进行替换，将属性替换为配置文件中的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String strVal = resolveEmbeddedValue((String) value);</span><br></pre></td></tr></table></figure>
<h2 id="面试题-7"><a class="markdownIt-Anchor" href="#面试题-7"></a> 面试题</h2>
<h3 id="依赖注入和依赖查找的依赖来源是否相同"><a class="markdownIt-Anchor" href="#依赖注入和依赖查找的依赖来源是否相同"></a> 依赖注入和依赖查找的依赖来源是否相同？</h3>
<p>否，依赖查找的来源仅限于Spring BeanDefinition以及单例对象，而依赖注入的来源还包括了Resolvable Dependency以及@Value所标注的外部化配置。</p>
<h3 id="单例对象能在ioc容器启动后注册吗"><a class="markdownIt-Anchor" href="#单例对象能在ioc容器启动后注册吗"></a> 单例对象能在IoC容器启动后注册吗？</h3>
<p>可以的，单例对象注册与BeanDefinition不同，BeanDefinition会被ConfigurableListableBeanFactory#freezeConfiguration()方法影响，从而冻结注册，单例对象则没有这个限制。</p>
<h3 id="spring依赖注入的来源有哪些-2"><a class="markdownIt-Anchor" href="#spring依赖注入的来源有哪些-2"></a> Spring依赖注入的来源有哪些？</h3>
<p>Spring BeanDefinition、单例对象、Resolvable Dependency、@Value外部化配置</p>
<h1 id="spring-bean作用域"><a class="markdownIt-Anchor" href="#spring-bean作用域"></a> Spring Bean作用域</h1>
<h2 id="作用域简介"><a class="markdownIt-Anchor" href="#作用域简介"></a> 作用域简介</h2>
<table>
<thead>
<tr>
<th>来源</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton</td>
<td>默认Spring Bean作用域，一个BeanFactory有且仅有一个实例</td>
</tr>
<tr>
<td>prototype</td>
<td>原型作用域，每次依赖查找和依赖注入生成新Bean对象</td>
</tr>
<tr>
<td>request</td>
<td>将Spring Bean存储在ServletRequest上下文中</td>
</tr>
<tr>
<td>session</td>
<td>将Spring Bean存储在HttpSession中</td>
</tr>
<tr>
<td>application</td>
<td>将Spring Bean存储在ServletContext中</td>
</tr>
</tbody>
</table>
<p>笼统而言，我们只要记住单例和原型两种即可，其余三种主要是为了服务端模板引擎渲染，包括JSP、Velocity、FreeMarker。</p>
<h2 id="singleton作用域"><a class="markdownIt-Anchor" href="#singleton作用域"></a> singleton作用域</h2>
<p>单例模式是在一定范围内是全局共享的，但是这个范围是有限的。通过观察BeanDefinition源代码可以发现，其实只有singleton和prototype这两个作用域相关的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否是单例</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 是否是原型</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>单例模式的示例图：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210624205747975.png" alt="image-20210624205747975" /></p>
<p>这里有一个误区就是，singleton和prototype并没有互斥的关系，是可以同时存在的，当然，如果同时存在的话，可能行为会有一些问题。</p>
<h2 id="prototype作用域"><a class="markdownIt-Anchor" href="#prototype作用域"></a> prototype作用域</h2>
<p>多例模式的示意图：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210624205818521.png" alt="image-20210624205818521" /></p>
<p>多例和单例比较的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bean的作用域示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanScopeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 默认的scop就是“singleton”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">singletonUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">prototypeUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(String.valueOf(System.nanoTime()));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;singletonUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User singletonUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;singletonUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User singletonUser1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;prototypeUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User prototypeUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;prototypeUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User prototypeUser1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;prototypeUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User prototypeUser2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,User&gt; users;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scopedBeansByInjection</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        BeanScopeDemo beanScopeDemo = applicationContext.getBean(BeanScopeDemo.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;beanScopeDemo.singletonUser = &quot;</span> + beanScopeDemo.singletonUser);</span><br><span class="line">        System.out.println(<span class="string">&quot;beanScopeDemo.singletonUser1 = &quot;</span> + beanScopeDemo.singletonUser1);</span><br><span class="line">        System.out.println(<span class="string">&quot;beanScopeDemo.prototypeUser1 = &quot;</span> + beanScopeDemo.prototypeUser);</span><br><span class="line">        System.out.println(<span class="string">&quot;beanScopeDemo.prototypeUser2 = &quot;</span> + beanScopeDemo.prototypeUser1);</span><br><span class="line">        System.out.println(<span class="string">&quot;beanScopeDemo.prototypeUser3 = &quot;</span> + beanScopeDemo.prototypeUser2);</span><br><span class="line">        System.out.println(<span class="string">&quot;beanScopeDemo.users = &quot;</span> + beanScopeDemo.users);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scopedBeansByLookup</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            User singletonUser = applicationContext.getBean(<span class="string">&quot;singletonUser&quot;</span>, User.class);</span><br><span class="line">            <span class="comment">// singletonUser是共享的Bean对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;singletonUser = &quot;</span> + singletonUser.getId());</span><br><span class="line">            <span class="comment">// prototypeUser是每次依赖查找都会生成新的Bean对象</span></span><br><span class="line">            User prototypeUser = applicationContext.getBean(<span class="string">&quot;prototypeUser&quot;</span>, User.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;prototypeUser = &quot;</span> + prototypeUser.getId());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(BeanScopeDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="comment">// 结论一：</span></span><br><span class="line">        <span class="comment">// singleton Bean无论依赖查找还是依赖注入均为同一个对象</span></span><br><span class="line">        <span class="comment">// prototype Bean无论依赖查找还是依赖注入均为新生成的对象</span></span><br><span class="line">        <span class="comment">// 结论二：</span></span><br><span class="line">        <span class="comment">// 如果依赖注入集合类型的对象，singleton Bean和prototype Bean均会存在一个</span></span><br><span class="line">        <span class="comment">// prototype Bean有别于其他地方的依赖注入</span></span><br><span class="line">        scopedBeansByLookup(applicationContext);</span><br><span class="line">        scopedBeansByInjection(applicationContext);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<p>Spring容器没有办法管理prototype Bean的完整生命周期，也没有办法记录实例的存在。销毁回调方法将不会执行，可以利用BeanPostProcess进行清扫工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;createUser&quot;</span>);</span><br><span class="line">        user.setId(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User Bean [&quot;</span> + beanName + <span class="string">&quot;]初始化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User Bean [&quot;</span> + beanName + <span class="string">&quot;]销毁化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanName = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行刚才的例子不难看出，初始化的方法每次还是会被调用，但是销毁方法只有单例的Bean才会调用，那么如何销毁prototype的Bean呢？一种做法就是前面提到的BeanPostProcess：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">applicationContext.addBeanFactoryPostProcessor(beanFactory -&gt; &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s Bean名称: %s 在初始化后回调...%n&quot;</span>, bean.getClass().getName(), beanName);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个方法里面可以执行一些销毁的逻辑，但是使用这种方式，可能会有一些意想不到的结果，因为创建好的prototype的Bean通常而言都是马上要使用的，而不需要在它上面增加一些额外的操作，更为推荐的方式，是在维护prototype的Bean的类中，利用它的生命周期方法，对于所管理的prototype类型的类进行销毁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanScopeDemo</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 默认的scop就是“singleton”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">singletonUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">prototypeUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(String.valueOf(System.nanoTime()));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;singletonUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User singletonUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;singletonUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User singletonUser1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;prototypeUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User prototypeUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;prototypeUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User prototypeUser1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;prototypeUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User prototypeUser2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, User&gt; users;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(BeanScopeDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前BeanScopeDemo Bean 正在销毁中&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.prototypeUser.destory();</span><br><span class="line">        <span class="keyword">this</span>.prototypeUser1.destory();</span><br><span class="line">        <span class="keyword">this</span>.prototypeUser2.destory();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, User&gt; entry : <span class="keyword">this</span>.users.entrySet()) &#123;</span><br><span class="line">            String beanName = entry.getKey();</span><br><span class="line">            BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (beanDefinition.isPrototype()) &#123;</span><br><span class="line">                User user = entry.getValue();</span><br><span class="line">                user.destory();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前BeanScopeDemo Bean 销毁已完成...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="request作用域"><a class="markdownIt-Anchor" href="#request作用域"></a> request作用域</h2>
<ol>
<li>配置
<ul>
<li>XML - <code>&lt;bean class=&quot;...&quot; scope=&quot;request&quot;&gt;</code></li>
<li>Java注解 - @RequestScope或@Scope（WebApplicationContext.SCOPE_REQUEST）</li>
</ul>
</li>
<li>实现
<ul>
<li>API - RequestScope</li>
</ul>
</li>
</ol>
<h2 id="session作用域"><a class="markdownIt-Anchor" href="#session作用域"></a> session作用域</h2>
<ol>
<li>配置
<ul>
<li>XML - <code>&lt;bean class=&quot;...&quot; scope=&quot;session&quot;&gt;</code></li>
<li>Java注解 - @SessionScope或@Scope（WebApplicationContext.SCOPE_SESSION）</li>
</ul>
</li>
<li>实现
<ul>
<li>API - SessionScope</li>
</ul>
</li>
</ol>
<p>request作用域的对象，每次请求都会返回一个新的对象，并且对象会经历初始化和销毁两个过程，而session作用域，在同一个cookie的情况下，每次返回的都是同一个对象，这个时候对象只会经历初始化的过程，而不会对Bean进行销毁。无论是request还是session，返回的对象都是经过cglib代理的对象。</p>
<h2 id="application作用域"><a class="markdownIt-Anchor" href="#application作用域"></a> application作用域</h2>
<ol>
<li>配置
<ul>
<li>XML - <code>&lt;bean class=&quot;...&quot; scope=&quot;application&quot;&gt;</code></li>
<li>Java注解 - @ApplicationScope或@Scope（WebApplicationContext.APPLICATION）</li>
</ul>
</li>
<li>实现
<ul>
<li>API - ApplicationScope</li>
</ul>
</li>
</ol>
<p>application作用域的Bean可以在ServletContext中直接获取到。一个JavaWeb应用只创建一个ServletContext对象，应用在启动的时候创建ServletContext对象，在服务器关闭的时候销毁，使用ServletContext获取到的Bean对象也是经过cglib代理的对象，Bean的名称为<code>scopedTarget.beanName</code></p>
<h2 id="自定义bean作用域"><a class="markdownIt-Anchor" href="#自定义bean作用域"></a> 自定义Bean作用域</h2>
<ol>
<li>
<p>实现Scope</p>
<ul>
<li>org.springframework.beans.factory.config.Scope</li>
</ul>
</li>
<li>
<p>注册Scope</p>
<ul>
<li>
<p>API - org.springframework.beans.factory.config.ConfigurableBeanFactory#registerScope</p>
</li>
<li>
<p>配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.CustomScopeConfigurer&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;scopes&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>自定义作用的相关示例，首先进行定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalScope</span> <span class="keyword">implements</span> <span class="title">Scope</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCOP_NAME = <span class="string">&quot;thread-local&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NamedThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadLocal = <span class="keyword">new</span> NamedThreadLocal(<span class="string">&quot;thread-local-scope&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空</span></span><br><span class="line">        Map&lt;String, Object&gt; context = getContext();</span><br><span class="line">        Object object = context.get(name);</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            object = objectFactory.getObject();</span><br><span class="line">            context.put(name, object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; context = getContext();</span><br><span class="line">        <span class="keyword">return</span> context.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveContextualObject</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; context = getContext();</span><br><span class="line">        <span class="keyword">return</span> context.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConversationId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(thread.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来进行注册并且测试是否成功：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalScopeDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(ThreadLocalScope.SCOP_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(String.valueOf(System.nanoTime()));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(ThreadLocalScopeDemo.class);</span><br><span class="line">        applicationContext.addBeanFactoryPostProcessor(beanFactory -&gt; &#123;</span><br><span class="line">                    beanFactory.registerScope(ThreadLocalScope.SCOP_NAME, <span class="keyword">new</span> ThreadLocalScope());</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        scopedBeansByLookup(applicationContext);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scopedBeansByLookup</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单个线程下，返回的永远是同一个Bean</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; 3; i++) &#123;</span></span><br><span class="line"><span class="comment">//            User user = applicationContext.getBean(&quot;user&quot;, User.class);</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;user = &quot; + user.getId());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                User user = applicationContext.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">                System.out.printf(<span class="string">&quot;[Thread id: %d] user = %s%n&quot;</span>, Thread.currentThread().getId(), user);</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">            <span class="comment">// 强制线程执行完成</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-8"><a class="markdownIt-Anchor" href="#面试题-8"></a> 面试题</h2>
<h3 id="spring内建的bean的作用域有几种"><a class="markdownIt-Anchor" href="#spring内建的bean的作用域有几种"></a> Spring内建的Bean的作用域有几种？</h3>
<p>sington、prototype、request、session、application以及websocket</p>
<h3 id="singleton-bean是否在一个应用中是唯一的"><a class="markdownIt-Anchor" href="#singleton-bean是否在一个应用中是唯一的"></a> singleton Bean是否在一个应用中是唯一的？</h3>
<p>否，singleton bean仅在当前Spring IoC容器（BeanFactory）中是单例对象。</p>
<h3 id="application-bean是否被其他方案他替代"><a class="markdownIt-Anchor" href="#application-bean是否被其他方案他替代"></a> “application” Bean是否被其他方案他替代？</h3>
<p>可以的，实际上，“application” Bean与&quot;singleton&quot; Bean没有本质区别。</p>
<h1 id="spring-bean-生命周期"><a class="markdownIt-Anchor" href="#spring-bean-生命周期"></a> Spring Bean 生命周期</h1>
<h2 id="元信息配置阶段"><a class="markdownIt-Anchor" href="#元信息配置阶段"></a> 元信息配置阶段</h2>
<p>BeanDefinition的配置方式：</p>
<ol>
<li>面向资源
<ul>
<li>XML配置</li>
<li>Properties资源配置</li>
</ul>
</li>
<li>面向注解</li>
<li>面向API</li>
</ol>
<p>这里除了Properties资源配置我们没有见到过外，其他的都有相关的示例。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意这里必须这么写，不能写user.class</span></span><br><span class="line"><span class="meta">user.(class)</span> = <span class="string">org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User</span></span><br><span class="line"><span class="meta">user.id</span> = <span class="string">001</span></span><br><span class="line"><span class="meta">user.name</span> = <span class="string">吉永超</span></span><br><span class="line"><span class="meta">user.city</span> = <span class="string">HANGZHOU</span></span><br></pre></td></tr></table></figure>
<p>相关的演示示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanMetadataConfigurationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 实例化PropertiesBeanDefinitionReader</span></span><br><span class="line">        PropertiesBeanDefinitionReader propertiesBeanDefinitionReader = <span class="keyword">new</span> PropertiesBeanDefinitionReader(beanFactory);</span><br><span class="line">        String location = <span class="string">&quot;classpath:/META-INF/user.properties&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> beanNumbers = propertiesBeanDefinitionReader.loadBeanDefinitions(location);</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanNumbers);</span><br><span class="line">        <span class="comment">// 通过Bean ID和类型进行依赖查找</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="元信息解析阶段"><a class="markdownIt-Anchor" href="#元信息解析阶段"></a> 元信息解析阶段</h2>
<p>主要分为两种：</p>
<ol>
<li>面向资源BeanDefinition解析
<ul>
<li>BeanDefinitionReader</li>
<li>XML解析器 - BeanDefinitionParser</li>
</ul>
</li>
<li>面向注解BeanDefinition解析
<ul>
<li>AnnotatedBeanDefinitionReader</li>
</ul>
</li>
</ol>
<p>面向资源的情况我们在之前也有过相关的讨论，这里只介绍面向注解的BeanDefinition解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedBeanDefinitionParsingDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 基于Java 注解的 AnnotatedBeanDefinitionReader的实现</span></span><br><span class="line">        AnnotatedBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(beanFactory);</span><br><span class="line">        <span class="keyword">int</span> beanDefinitionCountBefore = beanFactory.getBeanDefinitionCount();</span><br><span class="line">        <span class="comment">// 注册当前类（非Componenet Class）</span></span><br><span class="line">        beanDefinitionReader.registerBean(AnnotatedBeanDefinitionParsingDemo.class);</span><br><span class="line">        <span class="keyword">int</span> beanDefinitionCountAfter = beanFactory.getBeanDefinitionCount();</span><br><span class="line">        <span class="keyword">int</span> beanDefinitionCount = beanDefinitionCountAfter - beanDefinitionCountBefore;</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanDefinitionCount);</span><br><span class="line">        <span class="comment">// 普通Class作为Component注册到Spring IoC容器后，通常Bean的名称为类名的首字母小写（annotatedBeanDefinitionParsingDemo）</span></span><br><span class="line">        <span class="comment">// Bean名称生成来自于BeanNameGenerator，注解实现AnnotationBeanNameGenerator</span></span><br><span class="line">        AnnotatedBeanDefinitionParsingDemo demo = beanFactory.getBean(<span class="string">&quot;annotatedBeanDefinitionParsingDemo&quot;</span>, AnnotatedBeanDefinitionParsingDemo.class);</span><br><span class="line">        System.out.println(demo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认生成Bean的名称的部分代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">	String beanClassName = definition.getBeanClassName();</span><br><span class="line">	Assert.state(beanClassName != <span class="keyword">null</span>, <span class="string">&quot;No bean class name set&quot;</span>);</span><br><span class="line">	String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class="line">	<span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="注册阶段"><a class="markdownIt-Anchor" href="#注册阶段"></a> 注册阶段</h2>
<p>BeanDefinition注册的核心接口：BeanDefinitionRegistry，它有且仅有一个实现类就是DefaultListableBeanFactory。DefaultListableBeanFactory#registerBeanDefinition的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">		Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    	<span class="comment">// 当已经存在BeanDefinition的时候</span></span><br><span class="line">		<span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 允许Bean重复注册</span></span><br><span class="line">			<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">				<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">				<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">							<span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">							existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">							<span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">							<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">							<span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">							<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 注册一个新的BeanDefinition</span></span><br><span class="line">			<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">				<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                      <span class="comment">// 这里的beanDefinitionMap的类型是Map&lt;String, BeanDefinition&gt;,key就是Bean的名称，value就是对应的BeanDefinition</span></span><br><span class="line">					<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                      <span class="comment">// 这里之所以还要维护一个beanDefinitionNames是为了记住注册时候的Bean的顺序。</span></span><br><span class="line">					List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">					updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">					updatedDefinitions.add(beanName);</span><br><span class="line">					<span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">					removeManualSingletonName(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Still in startup registration phase</span></span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">				removeManualSingletonName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">			resetBeanDefinition(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">			clearByTypeCache();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="beandefinition合并阶段"><a class="markdownIt-Anchor" href="#beandefinition合并阶段"></a> BeanDefinition合并阶段</h2>
<p>BeanDefinition合并：</p>
<ol>
<li>父子BeanDefinition合并
<ul>
<li>当前BeanFactory查找</li>
<li>层次性BeanFactory查找</li>
</ul>
</li>
</ol>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergedBeanDefinitionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 基于XML资源BeanDefinitionReader 实现</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        String location = <span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> ClassPathResource(location);</span><br><span class="line">        EncodedResource encodedResource = <span class="keyword">new</span> EncodedResource(resource, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(encodedResource);</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanNumbers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不需要合并BeanDefinition</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        <span class="comment">// 需要合并BeanDefinition</span></span><br><span class="line">        SuperUser superUser = beanFactory.getBean(<span class="string">&quot;SuperUser&quot;</span>, SuperUser.class);</span><br><span class="line">        System.out.println(superUser.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	String beanName = transformedBeanName(name);</span><br><span class="line">	<span class="comment">// Efficiently check whether bean definition exists in this factory.</span></span><br><span class="line">	<span class="keyword">if</span> (!containsBeanDefinition(beanName) &amp;&amp; getParentBeanFactory() <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((ConfigurableBeanFactory) getParentBeanFactory()).getMergedBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Resolve merged bean definition locally.</span></span><br><span class="line">       <span class="comment">// 当前的BeanFactory</span></span><br><span class="line">	<span class="keyword">return</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合并的核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		String beanName, BeanDefinition bd, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">		RootBeanDefinition mbd = <span class="keyword">null</span>;</span><br><span class="line">		RootBeanDefinition previous = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check with full lock now in order to enforce the same merged instance.</span></span><br><span class="line">		<span class="keyword">if</span> (containingBd == <span class="keyword">null</span>) &#123;</span><br><span class="line">			mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || mbd.stale) &#123;</span><br><span class="line">			previous = mbd;</span><br><span class="line">			<span class="keyword">if</span> (bd.getParentName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Use copy of given root bean definition.</span></span><br><span class="line">				<span class="keyword">if</span> (bd <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line">					mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					mbd = <span class="keyword">new</span> RootBeanDefinition(bd);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Child bean definition: needs to be merged with parent.</span></span><br><span class="line">				BeanDefinition pbd;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					String parentBeanName = transformedBeanName(bd.getParentName());</span><br><span class="line">					<span class="keyword">if</span> (!beanName.equals(parentBeanName)) &#123;</span><br><span class="line">						pbd = getMergedBeanDefinition(parentBeanName);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						BeanFactory parent = getParentBeanFactory();</span><br><span class="line">						<span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">							pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(parentBeanName,</span><br><span class="line">									<span class="string">&quot;Parent name &#x27;&quot;</span> + parentBeanName + <span class="string">&quot;&#x27; is equal to bean name &#x27;&quot;</span> + beanName +</span><br><span class="line">											<span class="string">&quot;&#x27;: cannot be resolved without a ConfigurableBeanFactory parent&quot;</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(bd.getResourceDescription(), beanName,</span><br><span class="line">							<span class="string">&quot;Could not resolve parent bean definition &#x27;&quot;</span> + bd.getParentName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Deep copy with overridden values.</span></span><br><span class="line">				mbd = <span class="keyword">new</span> RootBeanDefinition(pbd);</span><br><span class="line">				mbd.overrideFrom(bd);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Set default singleton scope, if not configured before.</span></span><br><span class="line">			<span class="keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;</span><br><span class="line">				mbd.setScope(SCOPE_SINGLETON);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// A bean contained in a non-singleton bean cannot be a singleton itself.</span></span><br><span class="line">			<span class="comment">// Let&#x27;s correct this on the fly here, since this might be the result of</span></span><br><span class="line">			<span class="comment">// parent-child merging for the outer bean, in which case the original inner bean</span></span><br><span class="line">			<span class="comment">// definition will not have inherited the merged outer bean&#x27;s singleton status.</span></span><br><span class="line">			<span class="keyword">if</span> (containingBd != <span class="keyword">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">				mbd.setScope(containingBd.getScope());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Cache the merged bean definition for the time being</span></span><br><span class="line">			<span class="comment">// (it might still get re-merged later on in order to pick up metadata changes)</span></span><br><span class="line">			<span class="keyword">if</span> (containingBd == <span class="keyword">null</span> &amp;&amp; isCacheBeanMetadata()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.mergedBeanDefinitions.put(beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">			copyRelevantMergedBeanDefinitionCaches(previous, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mbd;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bean-class加载阶段"><a class="markdownIt-Anchor" href="#bean-class加载阶段"></a> Bean Class加载阶段</h2>
<ol>
<li>ClassLoader类加载</li>
<li>Java Security安全控制</li>
<li>ConfigurableBeanFactory临时ClassLoader（场景比较有限）</li>
</ol>
<p>加载的核心代码代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; resolveBeanClass(<span class="meta">@Nullable</span> ClassLoader classLoader) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">	String className = getBeanClassName();</span><br><span class="line">	<span class="keyword">if</span> (className == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Class&lt;?&gt; resolvedClass = ClassUtils.forName(className, classLoader);</span><br><span class="line">	<span class="keyword">this</span>.beanClass = resolvedClass;</span><br><span class="line">	<span class="keyword">return</span> resolvedClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最开始的beanClass实际上是一个String类型，然后通过AppClassLoader加载到Class对象并赋值给beanClass这个属性，这个属性本身是一个Object类型的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Object beanClass;</span><br></pre></td></tr></table></figure>
<h2 id="实例化"><a class="markdownIt-Anchor" href="#实例化"></a> 实例化</h2>
<h3 id="实例化前阶段"><a class="markdownIt-Anchor" href="#实例化前阶段"></a> 实例化前阶段</h3>
<p>非主流生命周期-Bena实例化前阶段</p>
<ul>
<li>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</li>
</ul>
<p>首先我们给出这个接口的使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInstantiationLifecycleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 添加BeanPostProcesssor实现</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> MyInstantiationAwareBeanPostProcessor());</span><br><span class="line">        <span class="comment">// 基于XML资源BeanDefinitionReader 实现</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        String location = <span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> ClassPathResource(location);</span><br><span class="line">        EncodedResource encodedResource = <span class="keyword">new</span> EncodedResource(resource, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(encodedResource);</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanNumbers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不需要合并BeanDefinition</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        <span class="comment">// 需要合并BeanDefinition</span></span><br><span class="line">        SuperUser superUser = beanFactory.getBean(<span class="string">&quot;SuperUser&quot;</span>, SuperUser.class);</span><br><span class="line">        System.out.println(superUser.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;SuperUser&quot;</span>,beanName) &amp;&amp; SuperUser.class.equals(beanClass)) &#123;</span><br><span class="line">                <span class="comment">// 把配置好的SuperUser Bean覆盖</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SuperUser();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 保持Spring IoC容器的实例化操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码分析，可以看到postProcessBeforeInstantiation方法被调用之后返回了这个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">			Object result = bp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">			<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用关系，不难看出，在实例化Bean的时候，如果上述的方法返回的不是一个空对象，就直接返回，不在进行实例化的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例化阶段"><a class="markdownIt-Anchor" href="#实例化阶段"></a> 实例化阶段</h3>
<p>Spring中实例化方式：</p>
<ol>
<li>传统实例化方式
<ul>
<li>实例化策略 - InstantiationStrategy</li>
</ul>
</li>
<li>构造器注入</li>
</ol>
<p>传统的方式可以在AbstractAutowireCapableBeanFactory#instantiateBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>构造器注入，我们可以构造一个例子来进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserHolder&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;user=&quot;</span> + user +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在之前的例子上稍作修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInstantiationLifecycleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 添加BeanPostProcesssor实现</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> MyInstantiationAwareBeanPostProcessor());</span><br><span class="line">        <span class="comment">// 基于XML资源BeanDefinitionReader 实现</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        String[] locations = &#123;<span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>,<span class="string">&quot;META-INF/bean-constructor-dependency-injection.xml&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(locations);</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanNumbers);</span><br><span class="line">        <span class="comment">// 不需要合并BeanDefinition</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        <span class="comment">// 需要合并BeanDefinition</span></span><br><span class="line">        SuperUser superUser = beanFactory.getBean(<span class="string">&quot;SuperUser&quot;</span>, SuperUser.class);</span><br><span class="line">        System.out.println(superUser.toString());</span><br><span class="line">        <span class="comment">// 构造器注入式按照类型注入，底层resolveDependency</span></span><br><span class="line">        UserHolder userHolder = beanFactory.getBean(<span class="string">&quot;userHolder&quot;</span>, UserHolder.class);</span><br><span class="line">        System.out.println(userHolder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;SuperUser&quot;</span>,beanName) &amp;&amp; SuperUser.class.equals(beanClass)) &#123;</span><br><span class="line">                <span class="comment">// 把配置好的SuperUser Bean覆盖</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SuperUser();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 保持Spring IoC容器的实例化操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以总结一下，Bean的实例化主要有两种类型，并且使用构造器注入的时候，是按照类型来进行注入的，底层是使用的我们在依赖注入章节中介绍过的resolveDependency方法来实现的。</p>
<h3 id="bean实例化后阶段"><a class="markdownIt-Anchor" href="#bean实例化后阶段"></a> Bean实例化后阶段</h3>
<p>对于Spring Bean实例化后阶段，我们可以理解为是Bean属性赋值（Populate）的判断：InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation。可以结合Bean实例化前阶段一起对照查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;SuperUser&quot;</span>, beanName) &amp;&amp; SuperUser.class.equals(beanClass)) &#123;</span><br><span class="line">              <span class="comment">// 把配置好的SuperUser Bean覆盖</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> SuperUser();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 保持Spring IoC容器的实例化操作</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;user&quot;</span>, beanName) &amp;&amp; User.class.equals(bean.getClass())) &#123;</span><br><span class="line">              User user = (User) bean;</span><br><span class="line">              user.setId(<span class="string">&quot;33&quot;</span>);</span><br><span class="line">              user.setName(<span class="string">&quot;jjjjjj&quot;</span>);</span><br><span class="line">              <span class="comment">// &quot;user&quot;对象不允许属性赋值（填入）（配置元信息 -&gt; 属性值）</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里相当于可以拦截掉所有的属性赋值，并且可以进行一些自定义的赋值，此时Bean的实例化已经完成了，但是属性赋值还没进行。</p>
<h2 id="属性赋值前阶段"><a class="markdownIt-Anchor" href="#属性赋值前阶段"></a> 属性赋值前阶段</h2>
<p>Bean属性值信息的类：</p>
<ul>
<li>PropertyValues</li>
</ul>
<p>Bean属性赋值前回调</p>
<ul>
<li>Spring1.2-5.0：InstantiationAwareBeanPostProcessor#postProcessPropertyValues</li>
<li>Spring 5.1：InstantiationAwareBeanPostProcessor#postProcessProperties</li>
</ul>
<p>他们都是在BeanFactory赋值之前的回调操作，PropertyValues就是从配置文件里面读入的值，这个方法的作用就是可以修改从配置文件里面读入的值，默认情况下不做任何修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">			PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> pvs;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，这里的返回值是null。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>还在在我们之前的例子上稍作修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">       <span class="comment">// 要注意如果postProcessAfterInstantiation返回的是false的话，这个方法不会被调用，因为相当于返回的Bean已经被替换了。</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;userHolder&quot;</span>, beanName) &amp;&amp; UserHolder.class.equals(bean.getClass())) &#123;</span><br><span class="line">                <span class="comment">// 假设&lt;property name=&quot;number&quot; value=&quot;1&quot; /&gt;配置的话，那么在PropertyValues中就包含一个PropertyValues(number=1)</span></span><br><span class="line">                <span class="keyword">final</span> MutablePropertyValues propertyValues;</span><br><span class="line">                <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">                    propertyValues = (MutablePropertyValues) pvs;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    propertyValues = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 等价于&lt;property name=&quot;number&quot; value=&quot;1&quot; /&gt;</span></span><br><span class="line">                propertyValues.addPropertyValue(<span class="string">&quot;number&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> (propertyValues.contains(<span class="string">&quot;description&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// PropertyValue是不可变的</span></span><br><span class="line"><span class="comment">//                    PropertyValue description = propertyValues.getPropertyValue(&quot;description&quot;);</span></span><br><span class="line">                    propertyValues.removePropertyValue(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">                    propertyValues.addPropertyValue(<span class="string">&quot;description&quot;</span>, <span class="string">&quot;The user holder V2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> propertyValues;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们演示了两种情况，一种是number这个属性本来是没有值的，通过这个Api的拦截，我们手动给他赋上了值，而description这个属性，是我们在XML文件中，定义好了属性值，从结果来看，这个属性值也成功的被修改了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userHolder&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.bean.lifecycle.UserHolder&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;constructor&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;number&quot; value=&quot;1&quot;/&gt;--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">value</span>=<span class="string">&quot;The user holder&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改后的UserHolder类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserHolder&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;user=&quot;</span> + user +</span><br><span class="line">                <span class="string">&quot;, number=&quot;</span> + number +</span><br><span class="line">                <span class="string">&quot;, description=&#x27;&quot;</span> + description + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相应的源码：</p>
<p><img src="./SpringFramework.assets/image-20210614105732908.png" alt="image-20210614105732908" /></p>
<p>最后将准备好的pvs对象赋值给BeanWrapper：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">	applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h2>
<h3 id="接口回调阶段"><a class="markdownIt-Anchor" href="#接口回调阶段"></a> 接口回调阶段</h3>
<p>Spring Aware接口：</p>
<ul>
<li>BeanNameAware</li>
<li>BeanClassLoaderAware</li>
<li>BeanFactoryAware</li>
<li>EnvironmentAware</li>
<li>EmbeddedValueResolverAware</li>
<li>ResourceLoaderAware</li>
<li>ApplicationEventPublisherAware</li>
<li>MessageSourceAware</li>
<li>ApplicationContextAware</li>
</ul>
<blockquote>
<p>这里列出的顺序同时也是调用时候的顺序，这一点，源代码中也有体现：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(String beanName, Object bean)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">				((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">				ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">				<span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">					((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">				((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>另外一些相关的方法在ApplicationContextAwareProcessor#invokeAwareInterfaces：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">			((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">			((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">			((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">			((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">			((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationStartupAware) &#123;</span><br><span class="line">			((ApplicationStartupAware) bean).setApplicationStartup(<span class="keyword">this</span>.applicationContext.getApplicationStartup());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">			((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>但是第二部分的回调接口无法通过BeanFacotry的方式得到回调，我们需要对之前的代码进行一定的重构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInstantiationLifecycleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        executeBeanFactory();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 方法一：添加BeanPostProcesssor实现InstantiationAwareBeanPostProcessor</span></span><br><span class="line">        <span class="comment">// 方法二：将MyInstantiationAwareBeanPostProcessor作为Bean注册</span></span><br><span class="line"><span class="comment">//        beanFactory.addBeanPostProcessor(new MyInstantiationAwareBeanPostProcessor());</span></span><br><span class="line">        <span class="comment">// 基于XML资源BeanDefinitionReader 实现</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        String[] locations = &#123;<span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>, <span class="string">&quot;META-INF/bean-constructor-dependency-injection.xml&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(locations);</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanNumbers);</span><br><span class="line">        <span class="comment">// 不需要合并BeanDefinition</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        <span class="comment">// 需要合并BeanDefinition</span></span><br><span class="line">        SuperUser superUser = beanFactory.getBean(<span class="string">&quot;SuperUser&quot;</span>, SuperUser.class);</span><br><span class="line">        System.out.println(superUser.toString());</span><br><span class="line">        <span class="comment">// 构造器注入式按照类型注入，底层resolveDependency</span></span><br><span class="line">        UserHolder userHolder = beanFactory.getBean(<span class="string">&quot;userHolder&quot;</span>, UserHolder.class);</span><br><span class="line">        System.out.println(userHolder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext();</span><br><span class="line">        String[] locations = &#123;<span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>, <span class="string">&quot;META-INF/bean-constructor-dependency-injection.xml&quot;</span>&#125;;</span><br><span class="line">        applicationContext.setConfigLocations(locations);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        User user = applicationContext.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        SuperUser superUser = applicationContext.getBean(<span class="string">&quot;SuperUser&quot;</span>, SuperUser.class);</span><br><span class="line">        System.out.println(superUser.toString());</span><br><span class="line">        UserHolder userHolder = applicationContext.getBean(<span class="string">&quot;userHolder&quot;</span>, UserHolder.class);</span><br><span class="line">        System.out.println(userHolder.toString());</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在XML文件中，注入MyInstantiationAwareBeanPostProcessor：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.bean.lifecycle.MyInstantiationAwareBeanPostProcessor&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以在UserHolder中实现这些接口，进行观察：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHolder</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserHolder&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;user=&quot;</span> + user +</span><br><span class="line">                <span class="string">&quot;, number=&quot;</span> + number +</span><br><span class="line">                <span class="string">&quot;, description=&#x27;&quot;</span> + description + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, beanName=&#x27;&quot;</span> + beanName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难发现，通过BeanFacotry的方式，无法获取到EnvironmentAware对象的回调，而ApplicationContext则可以，这是因为在AbstractApplicationContext#prepareBeanFactory中，BeanFactory注册了ApplicationContextAwareProcessor这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<p>而我们前面提到过，第二部分的接口的回调，需要执行ApplicationContextAwareProcessor#invokeAwareInterfaces方法，而ApplicationContextAwareProcessor又是一个非public的类，因此，在我们创建的BeanFactory无法操作这个类。总来的来说，通过BeanFactory可以获取到BeanNameAware、BeanClassLoaderAware、BeanFactoryAware这三个接口的回调，而如果使用AppliactionContext来进行操作，就可以获取到更多的回调，这也从另一个角度说明了AppliacitonContext和BeanFactory的区别。</p>
<h3 id="初始化前阶段"><a class="markdownIt-Anchor" href="#初始化前阶段"></a> 初始化前阶段</h3>
<p>方法回调：</p>
<ul>
<li>BeanPostProcessor#postProcessBeforeInitialization</li>
</ul>
<p>因为InstantiationAwareBeanPostProcessor继承了BeanPostProcessor，因此我们还是调整MyInstantiationAwareBeanPostProcessor的方法来进行观察：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;userHolder&quot;</span>, beanName) &amp;&amp; UserHolder.class.equals(bean.getClass())) &#123;</span><br><span class="line">           UserHolder userHolder = (UserHolder) bean;</span><br><span class="line">           userHolder.setDescription(<span class="string">&quot;The user holder V3&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> userHolder;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>为了跟前面加以区别，这里我们增加一个调用的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInitilzationLifecycleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        executeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 方法一：添加BeanPostProcesssor实现InstantiationAwareBeanPostProcessor</span></span><br><span class="line">        <span class="comment">// 方法二：将MyInstantiationAwareBeanPostProcessor作为Bean注册</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> MyInstantiationAwareBeanPostProcessor());</span><br><span class="line">        <span class="comment">// 基于XML资源BeanDefinitionReader 实现</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        String[] locations = &#123;<span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>, <span class="string">&quot;META-INF/bean-constructor-dependency-injection.xml&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(locations);</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanNumbers);</span><br><span class="line">        <span class="comment">// 不需要合并BeanDefinition</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        <span class="comment">// 需要合并BeanDefinition</span></span><br><span class="line">        SuperUser superUser = beanFactory.getBean(<span class="string">&quot;SuperUser&quot;</span>, SuperUser.class);</span><br><span class="line">        System.out.println(superUser.toString());</span><br><span class="line">        <span class="comment">// 构造器注入式按照类型注入，底层resolveDependency</span></span><br><span class="line">        UserHolder userHolder = beanFactory.getBean(<span class="string">&quot;userHolder&quot;</span>, UserHolder.class);</span><br><span class="line">        System.out.println(userHolder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到userHolder的description属性成功的变成了v3，相关的源码的实现在AbstractAutowireCapableBeanFactory#pplyBeanPostProcessorsBeforeInitialization：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Object result = existingBean;</span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">		Object current = processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">            <span class="comment">// 可能返回的是一个代理对象，并不是原有的对象</span></span><br><span class="line">		result = current;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化阶段"><a class="markdownIt-Anchor" href="#初始化阶段"></a> 初始化阶段</h3>
<p>在之前，我们有提到过Bean初始化操作：</p>
<ul>
<li>@PostConstruct标注方法</li>
<li>实现InitializingBean接口的afterPropertiesSet()方法</li>
<li>自定义初始化方法</li>
</ul>
<blockquote>
<p>@PostConstruct标注方法需要注解驱动，因为这种方式需要依赖于ApplicationContext的，并且所依赖的ApplicationContext是需要有注解驱动能力的。</p>
</blockquote>
<p>我们在UserHolder中添加它的初始化方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 依赖于注解驱动，当前场景：BeanFactory，因此直接运行，并不会执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostConstruct</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initPostConstruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.description = <span class="string">&quot;The user holder V4&quot;</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;initPostConstruct() = &quot;</span> + description);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.description = <span class="string">&quot;The user holder V5&quot;</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;afterPropertiesSet() = &quot;</span> + description);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.description = <span class="string">&quot;The user holder V6&quot;</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;init() = &quot;</span> + description);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里因为我们是BeanFactory的场景，因此需要手动添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> CommonAnnotationBeanPostProcessor());</span><br></pre></td></tr></table></figure>
<p>相应的源码在AbstractAutowireCapableBeanFactory#invokeInitMethods方法当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// afterPropertiesSet方法：</span></span><br><span class="line">		<span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">		<span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">						((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">					<span class="keyword">throw</span> pae.getException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 自定义初始化方法</span></span><br><span class="line">		<span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">			String initMethodName = mbd.getInitMethodName();</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">					!(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">					!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">				invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化后阶段"><a class="markdownIt-Anchor" href="#初始化后阶段"></a> 初始化后阶段</h3>
<p>方法的回调：</p>
<ul>
<li>BeanPostProcessor#postProcessAfterInitialization</li>
</ul>
<p>还是对我们的MyInstantiationAwareBeanPostProcessor进行添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;userHolder&quot;</span>, beanName) &amp;&amp; UserHolder.class.equals(bean.getClass())) &#123;</span><br><span class="line">          UserHolder userHolder = (UserHolder) bean;</span><br><span class="line">          userHolder.setDescription(<span class="string">&quot;The user holder V7&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> userHolder;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，关于Bean的初始化操作，总共可以分为下面几个阶段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;, getAccessControlContext());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 接口回调</span></span><br><span class="line">		invokeAwareMethods(beanName, bean);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object wrappedBean = bean;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">           <span class="comment">// 初始化前方法</span></span><br><span class="line">		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 初始化方法</span></span><br><span class="line">		invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">				beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">           <span class="comment">// 初始化后方法</span></span><br><span class="line">		wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化完成阶段"><a class="markdownIt-Anchor" href="#初始化完成阶段"></a> 初始化完成阶段</h3>
<p>方法回调：</p>
<ul>
<li>SmartInitializingSingleton#afterSingletonsInstantiated</li>
</ul>
<p>同样的，还是操作Userholder类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.description = <span class="string">&quot;The user holder V8&quot;</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;afterSingletonsInstantiated() = &quot;</span> + description);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>直接去运行，发现并没有打印出我们预期的结果，这是因为这个方法调用的地方在DefaultListableBeanFactory#preInstantiateSingletons，而这个方法需要显示的调用才会执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SmartInitializingSingleton 通常在Spring AppliactionContext场景使用</span></span><br><span class="line"><span class="comment">// preInstantiateSingletons将已注册的BeanDefinition初始化成Spring Bean</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br></pre></td></tr></table></figure>
<p>在AbstractApplicationContext#finishBeanFactoryInitialization方法中，我们可以看到这里就调用了preInstantiateSingletons方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">		beanFactory.preInstantiateSingletons();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>提供这个方法的主要原因是之前的BeanPostProcessor接口提供的回调，可能Bean会存在初始化不完全的情况，使用这个方法的时候就不用担心有Bean初始化不完全的情况发生。</p>
<h2 id="销毁阶段"><a class="markdownIt-Anchor" href="#销毁阶段"></a> 销毁阶段</h2>
<h3 id="销毁前阶段"><a class="markdownIt-Anchor" href="#销毁前阶段"></a> 销毁前阶段</h3>
<p>方法回调：</p>
<ul>
<li>DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</li>
</ul>
<p>实现一下这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDestructionAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">DestructionAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeforeDestruction</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;userHolder&quot;</span>, beanName) &amp;&amp; UserHolder.class.equals(bean.getClass())) &#123;</span><br><span class="line">            UserHolder userHolder = (UserHolder) bean;</span><br><span class="line">            userHolder.setDescription(<span class="string">&quot;The user holder V9&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于Bean生命周期的完整的演示示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanLifeCycleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 方法一：添加BeanPostProcesssor实现InstantiationAwareBeanPostProcessor</span></span><br><span class="line">        <span class="comment">// 方法二：将MyInstantiationAwareBeanPostProcessor作为Bean注册</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> MyInstantiationAwareBeanPostProcessor());</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> CommonAnnotationBeanPostProcessor());</span><br><span class="line">        <span class="comment">// 添加MyDestructionAwareBeanPostProcessor执行销毁前回调</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> MyDestructionAwareBeanPostProcessor());</span><br><span class="line">        <span class="comment">// 基于XML资源BeanDefinitionReader 实现</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        String[] locations = &#123;<span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>, <span class="string">&quot;META-INF/bean-constructor-dependency-injection.xml&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(locations);</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanNumbers);</span><br><span class="line">        beanFactory.preInstantiateSingletons();</span><br><span class="line">        <span class="comment">// 不需要合并BeanDefinition</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        <span class="comment">// 需要合并BeanDefinition</span></span><br><span class="line">        SuperUser superUser = beanFactory.getBean(<span class="string">&quot;SuperUser&quot;</span>, SuperUser.class);</span><br><span class="line">        System.out.println(superUser.toString());</span><br><span class="line">        <span class="comment">// 构造器注入式按照类型注入，底层resolveDependency</span></span><br><span class="line">        UserHolder userHolder = beanFactory.getBean(<span class="string">&quot;userHolder&quot;</span>, UserHolder.class);</span><br><span class="line">        <span class="comment">// SmartInitializingSingleton 通常在Spring AppliactionContext场景使用</span></span><br><span class="line">        System.out.println(userHolder.toString());</span><br><span class="line"></span><br><span class="line">        beanFactory.destroyBean(<span class="string">&quot;userHolder&quot;</span>, userHolder);</span><br><span class="line">        <span class="comment">// Bean销毁并不意味这Bean垃圾回收了</span></span><br><span class="line">        System.out.println(userHolder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>特别需要注意的是，这里的销毁并不是这个对象被GC掉了，GC和Bean的销毁是两个不同的概念。</p>
</blockquote>
<h3 id="销毁阶段-2"><a class="markdownIt-Anchor" href="#销毁阶段-2"></a> 销毁阶段</h3>
<p>Bean销毁（Destory）：</p>
<ul>
<li>@PreDestory标注方法</li>
<li>实现DisposableBean接口的destory()方法</li>
<li>自定义销毁方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.description = <span class="string">&quot;The user holder V10&quot;</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;PreDestroy() = &quot;</span> + description);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.description = <span class="string">&quot;The user holder V11&quot;</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;PreDestroy() = &quot;</span> + description);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.description = <span class="string">&quot;The user holder V12&quot;</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;PreDestroy() = &quot;</span> + description);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在XML中指定自定义的销毁方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userHolder&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.bean.lifecycle.UserHolder&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;constructor&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;doDestory&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;number&quot; value=&quot;1&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">value</span>=<span class="string">&quot;The user holder&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在BeanFactory场景下还是需要手动进行调用，而在ApplicationContext中，是会自动调用的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanFactory.destroyBean(<span class="string">&quot;userHolder&quot;</span>, userHolder);</span><br></pre></td></tr></table></figure>
<h2 id="bean垃圾收集"><a class="markdownIt-Anchor" href="#bean垃圾收集"></a> Bean垃圾收集</h2>
<p>Bean垃圾回收（GC）的过程：</p>
<ol>
<li>关闭Spring容器（应用上下文）</li>
<li>执行GC</li>
<li>Spring Bean覆盖的finalize()方法被回调</li>
</ol>
<p>首先在UserHolder中重写finalize()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;UserHolder is finalized ...&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span>.finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后执行销毁方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁BeanFactory中的单例Bean</span></span><br><span class="line">   beanFactory.destroySingletons();</span><br><span class="line">   <span class="comment">// 强制GC</span></span><br><span class="line">   System.gc();</span><br><span class="line">   <span class="comment">// 等待一段时间</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException exception) &#123;</span><br><span class="line">       exception.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   System.gc();</span><br></pre></td></tr></table></figure>
<h2 id="面试题-9"><a class="markdownIt-Anchor" href="#面试题-9"></a> 面试题</h2>
<h3 id="beanpostprocess使用场景有哪些"><a class="markdownIt-Anchor" href="#beanpostprocess使用场景有哪些"></a> BeanPostProcess使用场景有哪些？</h3>
<p>BeanPostProcess提供了Spring Bean初始化前和初始化后的生命周期回调，分别对应postProcessBeforeInitialization以及postProcessAfterInitialization方法，允许对关心的Bean进行扩展，甚至是替换，</p>
<p>其中ApplicationContext相关的Aware回调也是基于BeanPostProcess实现，即ApplicationContextAwareProcessor。</p>
<h3 id="beanfactorypostprocess与beanpostprocess的区别"><a class="markdownIt-Anchor" href="#beanfactorypostprocess与beanpostprocess的区别"></a> BeanFactoryPostProcess与BeanPostProcess的区别</h3>
<p>BeanFactroyPostProcessor是Spring BeanFacrtory（实际为ConfigurableListableBeanFactory）的后置处理器，用于扩展BeanFacotry，或通过BeanFactory进行依赖查找和依赖注入。</p>
<p>BeanFactroyPostProcessor必须有Spring ApplicationContext执行，BeanFactory无法与其直接交互。而BeanPostProcess直接与BeanFactory关联，属于N对1的关系。</p>
<h3 id="beanfactory是怎样处理bean生命周期"><a class="markdownIt-Anchor" href="#beanfactory是怎样处理bean生命周期"></a> BeanFactory是怎样处理Bean生命周期？</h3>
<p>BeanFactory的默认实现为DefaultListableBeanFactory，其中Bean生命周期与方法映射如下：</p>
<ul>
<li>BeanDefinition注册阶段 - regsiterBeanDefinition</li>
<li>BeanDefinition合并阶段 - getMergedBeanDefinition</li>
<li>Bean实例化前阶段 - resolveBeforeInstantiation</li>
<li>Bean实例化阶段 - createBeanInstance</li>
<li>Bean实例化后阶段- populateBean</li>
<li>Bean属性赋值前阶段 - populateBean</li>
<li>Bean属性赋值阶段 - populateBean</li>
<li>Bean Aware接口回调阶段 - initializeBean</li>
<li>Bean初始化前阶段- initializeBean</li>
<li>Bean初始化阶段- initializeBean</li>
<li>Bean初始化后阶段- initializeBean</li>
<li>Bean初始化完成阶段 - preInstantiateSingtons</li>
<li>Bean销毁前阶段- destoryBean</li>
<li>Bean销毁阶段 - destoryBean</li>
</ul>
<h1 id="spring-配置元信息"><a class="markdownIt-Anchor" href="#spring-配置元信息"></a> Spring 配置元信息</h1>
<p>配置元信息主要可以分为以下五个方面：</p>
<ol>
<li>Spring Bean配置元信息 - BeanDefinition</li>
<li>Spring Bean属性元信息 - PropertyValues</li>
<li>Spring 容器配置元信息</li>
<li>Spring 外部化配置元信息 - PropertySource</li>
<li>Spring Profile 元信息 - @Profile</li>
</ol>
<h2 id="spring-bean配置元信息"><a class="markdownIt-Anchor" href="#spring-bean配置元信息"></a> Spring Bean配置元信息</h2>
<p>Bean的配置元信息 - BeanDefinition主要包括了：</p>
<ul>
<li>GenericBeanDefinition：通用型BeanDefinition</li>
<li>RootBeanDefinition：无parent的BeanDefinition或者合并后BeanDefinition</li>
<li>AnnotatedBeanDefinition：注解标注的BeanDefinition</li>
</ul>
<blockquote>
<p>AnnotatedBeanDefinition中的AnnotationMetadata有两种具体的实现，StandardAnnotationMetadata是基于Java注解实现的，SimpleAnnotationMetadata是基于ASM实现的。</p>
</blockquote>
<h2 id="spring-bean属性元信息"><a class="markdownIt-Anchor" href="#spring-bean属性元信息"></a> Spring Bean属性元信息</h2>
<ol>
<li>Bean属性元信息 - PropertyValues
<ul>
<li>可修改实现 - MutablePropertyValues</li>
<li>元素成员 - PropertyValue</li>
</ul>
</li>
<li>Bean属性上下文存储 - AttributeAccessor</li>
<li>Bean元信息元素 - BeanMetadataElement</li>
</ol>
<p>其中第一种我们已经见过很多次了，这里主要演示第二种和第三种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfigurationMetadataDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// BeanDefinition 的定义（声明）</span></span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class);</span><br><span class="line">        beanDefinitionBuilder.addPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jycoder&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取AbstractBeanDefinition</span></span><br><span class="line">        AbstractBeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line">        <span class="comment">// 声明BeanDefinition</span></span><br><span class="line">        <span class="comment">// 附件属性(不影响Bean 实例化、属性赋值、初始化)</span></span><br><span class="line">        beanDefinition.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jiyongchao&quot;</span>);</span><br><span class="line">        <span class="comment">// 当前BeanDefinition来自何方,也是起存储的作用</span></span><br><span class="line">        beanDefinition.setSource(BeanConfigurationMetadataDemo.class);</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;user&quot;</span>, beanName) &amp;&amp; User.class.equals(bean.getClass())) &#123;</span><br><span class="line">                    BeanDefinition bd = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (BeanConfigurationMetadataDemo.class.equals(bd.getSource())) &#123; <span class="comment">// 通过source来判断</span></span><br><span class="line">                        <span class="comment">// TODO</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 属性（存储）上下文</span></span><br><span class="line">                    String name = (String) bd.getAttribute(<span class="string">&quot;jiyongchao&quot;</span>); <span class="comment">// 这里的name就是jiyongchao</span></span><br><span class="line">                    User user = (User) bean;</span><br><span class="line">                    user.setName(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;user&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring容器配置元信息"><a class="markdownIt-Anchor" href="#spring容器配置元信息"></a> Spring容器配置元信息</h2>
<p>Spring XML配置元信息 - Beans元素相关</p>
<table>
<thead>
<tr>
<th>Beans元素属性</th>
<th>默认直</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>profile</td>
<td>null（留空）</td>
<td>Spring Profiles配置值</td>
</tr>
<tr>
<td>default-lazt-init</td>
<td>default</td>
<td>当outter beans “default-lazy-init&quot;属性存在时，继承该值，否则为&quot;false”</td>
</tr>
<tr>
<td>default-merge</td>
<td>default</td>
<td>当outter beans “default-merge&quot;属性存在时，继承该值，否则为&quot;false”</td>
</tr>
<tr>
<td>default-autowire</td>
<td>default</td>
<td>当outter beans “default-autowire&quot;属性存在时，继承该值，否则为&quot;false”</td>
</tr>
<tr>
<td>default-autowire-candidates</td>
<td>null（留空）</td>
<td>默认Spring Beans 名称pattern</td>
</tr>
<tr>
<td>default-init-method</td>
<td>null（留空）</td>
<td>默认Spring Beans 自定义初始化方法</td>
</tr>
<tr>
<td>default-destory-method</td>
<td>null（留空）</td>
<td>默认Spring Beans 自定义销毁方法</td>
</tr>
</tbody>
</table>
<blockquote>
<p>outter beans指的是在XML文件中通过import导入资源的方法注册Bean，导入方就是外部，被导入方就是内部。</p>
</blockquote>
<p>Spring XML配置元信息 - 应用上下文</p>
<table>
<thead>
<tr>
<th>XML元素</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;context:annotation-config /&gt;</td>
<td>激活Spring注解驱动</td>
</tr>
<tr>
<td>&lt;context:componenet-scan /&gt;</td>
<td>Spring@Component以及自定义注解扫描</td>
</tr>
<tr>
<td>&lt;context:load-time-weaver /&gt;</td>
<td>激活Spring LoadTimeWeaver</td>
</tr>
<tr>
<td>&lt;context:mbean-export /&gt;</td>
<td>暴露Spring Beans作为JMX Beans</td>
</tr>
<tr>
<td>&lt;context:mbean-server /&gt;</td>
<td>将当前平台作为MBeanServer</td>
</tr>
<tr>
<td>&lt;context:property-placeholder /&gt;</td>
<td>加载外部化配置资源作为Spring属性配置</td>
</tr>
<tr>
<td>&lt;context:property-override /&gt;</td>
<td>利用外部化配置资源覆盖Spring属性值</td>
</tr>
</tbody>
</table>
<blockquote>
<p>mbean：Java Management Extensions</p>
</blockquote>
<p>关于Beans的元素相关的配置可以在<code>BeanDefinitionParserDelegate#populateDefaults</code>中看到。</p>
<h2 id="基于xml资源装载spring-bean配置元信息"><a class="markdownIt-Anchor" href="#基于xml资源装载spring-bean配置元信息"></a> 基于XML资源装载Spring Bean配置元信息</h2>
<p>Spring Bean配置元信息</p>
<table>
<thead>
<tr>
<th>XML元素</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;beans:beans /&gt;</td>
<td>单XML资源下的多个Spring Beans配置</td>
</tr>
<tr>
<td>&lt;beans:bean /&gt;</td>
<td>单个Spring Bean定义（BeanDefinition）配置</td>
</tr>
<tr>
<td>&lt;beans:alias /&gt;</td>
<td>为Spring Bean定义（BeanDefinition）映射别名</td>
</tr>
<tr>
<td>&lt;beans:import /&gt;</td>
<td>加载外部Spring XML配置资源</td>
</tr>
</tbody>
</table>
<blockquote>
<p>通常情况下我们会使用默认的namespace，这里使用beans来更加明确的说明，这里的底层实现都是XmlBeanDefinitionReader。</p>
</blockquote>
<p>装在的核心方法在XmlBeanDefinitionReader#registerBeanDefinitions：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">		BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">		<span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">		<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于properties资源装载spring-bean配置元信息"><a class="markdownIt-Anchor" href="#基于properties资源装载spring-bean配置元信息"></a> 基于Properties资源装载Spring Bean配置元信息</h2>
<p>Spring Bean 配置元信息</p>
<table>
<thead>
<tr>
<th>Properties属性名</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>(class)</td>
<td>Bean类全称限定名</td>
</tr>
<tr>
<td>(abstract)</td>
<td>是否为抽象的BeanDefinition</td>
</tr>
<tr>
<td>(parent)</td>
<td>指定parent BeanDefinition名称</td>
</tr>
<tr>
<td>(lazy-init)</td>
<td>是否为延迟初始化</td>
</tr>
<tr>
<td>(ref)</td>
<td>应用其他Bean的名称</td>
</tr>
<tr>
<td>(scope)</td>
<td>设置Bean的scope属性</td>
</tr>
<tr>
<td>${n}</td>
<td>n表示第n+1个构造器参数</td>
</tr>
</tbody>
</table>
<blockquote>
<p>底层实现：PropertiesBeanDefinitionReader</p>
</blockquote>
<p>接下来我们定义一个properties文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># User BeanDefinition 定义</span><br><span class="line">user.(<span class="class"><span class="keyword">class</span>) </span>= org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User</span><br><span class="line">user.id = <span class="number">1</span></span><br><span class="line">user.name = jiyongchao</span><br><span class="line">user.city = HANGZHOU</span><br></pre></td></tr></table></figure>
<p>尝试获取解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesBeanDefinitionReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        PropertiesBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> PropertiesBeanDefinitionReader(beanFactory);</span><br><span class="line">        String location = <span class="string">&quot;classpath:/META-INF/users-config-definitions.properties&quot;</span>;</span><br><span class="line">        <span class="comment">// 默认通过ISO-8859-1</span></span><br><span class="line">        ResourceLoader resourceLoader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line">        <span class="comment">// 通过指定的Classpath获取Resource对象</span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        <span class="comment">// 转换成带字符编码的EncodedResource对象</span></span><br><span class="line">        EncodedResource encodedResource = <span class="keyword">new</span> EncodedResource(resource, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = beanDefinitionReader.loadBeanDefinitions(encodedResource);</span><br><span class="line">        System.out.printf(<span class="string">&quot;已加载%d 个BeanDefinition\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">        User user = beanFactory.getBean(User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关核心代码在PropertiesBeanDefinitionReader#loadBeanDefinitions：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource, <span class="meta">@Nullable</span> String prefix)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Loading properties bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> (InputStream is = encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				getPropertiesPersister().load(props, <span class="keyword">new</span> InputStreamReader(is, encodedResource.getEncoding()));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				getPropertiesPersister().load(props, is);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> count = registerBeanDefinitions(props, prefix, encodedResource.getResource().getDescription());</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;Could not parse properties from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用properties的方式读取BeanDefinition的时候，如果出现Bean重复定义的情况，Spring会忽略后面定义的Bean的相关信息。</p>
</blockquote>
<h2 id="基于java注解的spring-bean配置元信息"><a class="markdownIt-Anchor" href="#基于java注解的spring-bean配置元信息"></a> 基于Java注解的Spring Bean配置元信息</h2>
<p>Spring模式注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Repository</td>
<td>数据仓储模式注解</td>
<td>2.0</td>
</tr>
<tr>
<td>@Component</td>
<td>通用组件模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Service</td>
<td>服务模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Controller</td>
<td>Web控制器模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Configuration</td>
<td>配置类模式注解</td>
<td>3.0</td>
</tr>
</tbody>
</table>
<p>由于注解是不能集成的，所以采用元注解（元标注的方式来实现），其他注解都可以看成是<code>@Component</code>的&quot;派生&quot;注解。</p>
<p>Spring Bean依赖注入注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Autowired</td>
<td>Bean依赖注入，支持多种依赖查找的方式</td>
<td>2.5</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>细粒度的@Autowired依赖查找</td>
<td>2.5</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Java注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Resource</td>
<td>类似于@Autowired</td>
<td>2.5</td>
</tr>
<tr>
<td>@Inject</td>
<td>类似于@Autowired</td>
<td>2.5</td>
</tr>
</tbody>
</table>
<p>Spring Bean条件装配注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Profile</td>
<td>配置化条件装配</td>
<td>3.1</td>
</tr>
<tr>
<td>@Conditional</td>
<td>编程条件装配</td>
<td>4.0</td>
</tr>
</tbody>
</table>
<p>我们可以看一下@Profile注解的@Conditional：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">		MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class="line">		<span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Object value : attrs.get(<span class="string">&quot;value&quot;</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是Spring Bean声明周期回调注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>@PostConstruct</td>
<td>替换XML标签或者实现接口</td>
<td>2.5</td>
</tr>
<tr>
<td>@PreDestory</td>
<td>替换XML标签或者实现接口</td>
<td>2.5</td>
</tr>
</tbody>
</table>
<h2 id="spring-bean配置元信息底层实现"><a class="markdownIt-Anchor" href="#spring-bean配置元信息底层实现"></a> Spring Bean配置元信息底层实现</h2>
<p>Spring BeanDefinition解析与注册的方式：</p>
<table>
<thead>
<tr>
<th>实现场景</th>
<th>实现类</th>
<th>起始版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>XML资源</td>
<td>XmlBeanDefinitionReader</td>
<td>1.0</td>
</tr>
<tr>
<td>Properties</td>
<td>PropertiesBeanDefinitionReader</td>
<td>1.0</td>
</tr>
<tr>
<td>Java注解</td>
<td>AnnotatedBeanDefinitionReader</td>
<td>3.0</td>
</tr>
</tbody>
</table>
<blockquote>
<p>需要注意的是AnnotatedBeanDefinitionReader与BeanDefinition并没有任何直接的关系，而XmlBeanDefinitionReader和PropertiesBeanDefinitionReader都继承了AbstractBeanDefinitionReader。</p>
</blockquote>
<h3 id="xml资源的方式"><a class="markdownIt-Anchor" href="#xml资源的方式"></a> XML资源的方式</h3>
<p>Spring XML资源BeanDefinition解析与注册：</p>
<ul>
<li>核心API - XmlBeanDefinitionReader</li>
<li>底层 - BeanDefinitionDocumentReader
<ul>
<li>XML解析 - Java DOM Level 3 API</li>
<li>BeanDefinition 解析  - BeanDefinitionParserDelegate</li>
<li>BeanDefinition注册 - BeanDefinitionRegistry</li>
</ul>
</li>
</ul>
<blockquote>
<p>BeanDefinitionDocumentReader有且仅有一个实现，DefaultBeanDefinitionDocumentReader，它里面的preProcessXml和postProcessXml方法都是空实现，可以让我们在加载XML资源的前后做一些自定义的操作，使用的时候只需要继承DefaultBeanDefinitionDocumentReader，然后设置XmlBeanDefinitionReader所使用的加载类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;? extends BeanDefinitionDocumentReader&gt; documentReaderClass =</span><br><span class="line">			DefaultBeanDefinitionDocumentReader.class;</span><br></pre></td></tr></table></figure>
<h3 id="properties资源的方式"><a class="markdownIt-Anchor" href="#properties资源的方式"></a> Properties资源的方式</h3>
<p>Spring Properties资源BeanDefinition解析与注册：</p>
<ul>
<li>核心API - PropertiesBeanDefinitionReader
<ul>
<li>资源
<ul>
<li>字节流 - Resource</li>
<li>字符流 - EncodedResource</li>
</ul>
</li>
<li>底层
<ul>
<li>存储 - java.util.Properties</li>
<li>BeanDefinition解析 - API内部实现</li>
<li>BeanDefinition注册 - BeanDefinitionRegistry</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>通过这种方式装在的Bean的名称就是&quot;.&quot;之前的字符。</p>
</blockquote>
<h3 id="java注解的方式"><a class="markdownIt-Anchor" href="#java注解的方式"></a> Java注解的方式</h3>
<p>Spring Java注册BeanDefintiion解析与注册：</p>
<ul>
<li>核心API - AnnotatedBeanDefinitionReader
<ul>
<li>资源
<ul>
<li>类对象 - java.lang.Class</li>
</ul>
</li>
<li>底层
<ul>
<li>条件评估 - ConditionEvaluator</li>
<li>Bean范围解析 - ScopeMetadataResolver</li>
<li>BeanDefinition解析 - 内部API实现</li>
<li>BeanDefinition处理 - AnnotationConfigUtils.processCommonDefinitionAnnotations</li>
<li>BeanDefinition注册 - BeanDefinitionRegistry</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>实现的核心源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		abd.setInstanceSupplier(supplier);</span><br><span class="line">		ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">		abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">		String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line">		<span class="comment">// 如果Bean上面有@Lazy或者@Primary等等，这个方法会把相关的信息赋值给BeanDefinition</span></span><br><span class="line">		AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">		<span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">					abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">					abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">				customizer.customize(abd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">		definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于xml资源装载spring-容器配置元信息"><a class="markdownIt-Anchor" href="#基于xml资源装载spring-容器配置元信息"></a> 基于XML资源装载Spring 容器配置元信息</h2>
<p>Spring IoC容器相关XML配置：</p>
<table>
<thead>
<tr>
<th>命名空间</th>
<th>所属模块</th>
<th>Schema资源URL</th>
</tr>
</thead>
<tbody>
<tr>
<td>beans</td>
<td>spring-beans</td>
<td><a href="http://www.springframework.org/schema/beans/spring-beans.xsd">http://www.springframework.org/schema/beans/spring-beans.xsd</a></td>
</tr>
<tr>
<td>context</td>
<td>spring-context</td>
<td><a href="http://www.springframework.org/schema/context/beans/spring-context.xsd">http://www.springframework.org/schema/context/beans/spring-context.xsd</a></td>
</tr>
<tr>
<td>aop</td>
<td>spring-aop</td>
<td><a href="http://www.springframework.org/schema/aop/spring-aop.xsd">http://www.springframework.org/schema/aop/spring-aop.xsd</a></td>
</tr>
<tr>
<td>tx</td>
<td>spring-tx</td>
<td><a href="http://www.springframework.org/schema/tx/spring-tx.xsd">http://www.springframework.org/schema/tx/spring-tx.xsd</a></td>
</tr>
<tr>
<td>util</td>
<td>spring-util</td>
<td><a href="http://www.springframework.org/schema/util/spring-util.xsd">http://www.springframework.org/schema/util/spring-util.xsd</a></td>
</tr>
<tr>
<td>tool</td>
<td>spring-beans</td>
<td><a href="http://www.springframework.org/schema/tool/spring-tool.xsd">http://www.springframework.org/schema/tool/spring-tool.xsd</a></td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果需要支持事务，需要单独引入spring-tx。</p>
</blockquote>
<h2 id="基于java注解配置spring-容器配置元信息"><a class="markdownIt-Anchor" href="#基于java注解配置spring-容器配置元信息"></a> 基于Java注解配置Spring 容器配置元信息</h2>
<p>Spring IoC容器装配注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ImportResource</td>
<td>替换XML元素<import></td>
<td>3.0</td>
</tr>
<tr>
<td>@Import</td>
<td>导入Configuration Class</td>
<td>3.0</td>
</tr>
<tr>
<td>@ComponenetScan</td>
<td>扫描指定package下标注Spring模式注解的类</td>
<td>3.1</td>
</tr>
</tbody>
</table>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;)</span></span><br><span class="line"><span class="meta">@Import(User.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedSpringIoCContainerConfigurationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        context.register(AnnotatedSpringIoCContainerConfigurationDemo.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        Map&lt;String, User&gt; userMap = context.getBeansOfType(User.class);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, User&gt; entry : userMap.entrySet()) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;User Bean name:%s,content: %s \n&quot;</span>, entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring IoC配置属性注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>@PropertySource</td>
<td>配置属性抽象PropertySource注解</td>
<td>3.1</td>
</tr>
<tr>
<td>@PropertySources</td>
<td>@PropertySource集合注解</td>
<td>4.0</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:/META-INF/users-config-definitions.properties&quot;)</span> <span class="comment">//Java8 + @Repeatable</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/META-INF/users-config-definitions.properties&quot;)</span></span><br><span class="line"><span class="comment">//@PropertySources(@PropertySource(value = &quot;1&quot;))</span></span><br></pre></td></tr></table></figure>
<h2 id="基于extensible-xml-authoring扩展spring-xml元素"><a class="markdownIt-Anchor" href="#基于extensible-xml-authoring扩展spring-xml元素"></a> 基于Extensible XML authoring扩展Spring XML元素</h2>
<p>Spring XML扩展的步骤：</p>
<ol>
<li>编写XML Schema文件：定义XML结构</li>
<li>自定义NamespaceHandler实现：命名空间绑定</li>
<li>定义BeanDefinitionParser实现：XML元素与BeanDefinition解析</li>
<li>注册XML扩展：命名空间与XML Schema映射</li>
</ol>
<p>定义XML结构：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:users</span>=<span class="string">&quot;http://jycoder.org/schema/users&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://jycoder.org/schema/users&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">users:user</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;jiyongchao&quot;</span> <span class="attr">city</span>=<span class="string">&quot;SHANGHAI&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>命名空间绑定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将&quot;user&quot;元素注册对应的BeanDefinitionParser实现</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;user&quot;</span>,<span class="keyword">new</span> UserBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>XML元素与BeanDefinition解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">        setPropertyValue(<span class="string">&quot;id&quot;</span>, element, builder);</span><br><span class="line">        setPropertyValue(<span class="string">&quot;name&quot;</span>, element, builder);</span><br><span class="line">        setPropertyValue(<span class="string">&quot;City&quot;</span>, element, builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(String attributeName, Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">        String attributeValue = element.getAttribute(attributeName);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(attributeValue)) &#123;</span><br><span class="line">            builder.addPropertyValue(attributeName, attributeValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名空间与XML Schema映射：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义namespacehanlder</span></span><br><span class="line"><span class="meta">http\://jycoder.org/schema/users</span>=<span class="string">org.jyc.thinking.in.spring.bean.metadata.UsersNamespaceHandler</span></span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">http\://jycoder.org/schema/users.xsd</span>=<span class="string">org/jyc/thinking/in/spring/bean/metadata/users.xsd</span></span><br></pre></td></tr></table></figure>
<p>测试我们编写的案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtensibleXmlAuthoringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        reader.loadBeanDefinitions(<span class="string">&quot;classpath:/META-INF/users-context.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取User Bean对象</span></span><br><span class="line">        User user = beanFactory.getBean(User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于properties资源装载外部化配置"><a class="markdownIt-Anchor" href="#基于properties资源装载外部化配置"></a> 基于Properties资源装载外部化配置</h2>
<ol>
<li>注解驱动：
<ul>
<li>org.springframework.context.annotation.PropertySource</li>
<li>org.springframework.context.annotation.PropertySources</li>
</ul>
</li>
<li>API编程：
<ul>
<li>org.springframework.core.env.PropertySource</li>
<li>org.springframework.core.env.PropertySources</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:/META-INF/users-config-definitions.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertySourceDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">(<span class="meta">@Value(&quot;$&#123;user.id&#125;&quot;)</span> String id, <span class="meta">@Value(&quot;$&#123;user.name&#125;&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 扩展Environment中的PropertySources</span></span><br><span class="line">        <span class="comment">// 添加PropertySources操作必须在refresh方法之前完成</span></span><br><span class="line">        Map&lt;String, Object&gt; propertiesSource = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        propertiesSource.put(<span class="string">&quot;user.name&quot;</span>, <span class="string">&quot;xiao ji&quot;</span>);</span><br><span class="line">        org.springframework.core.env.PropertySource propertySource = <span class="keyword">new</span> MapPropertySource(<span class="string">&quot;first-property-source&quot;</span>, propertiesSource);</span><br><span class="line">        context.getEnvironment().getPropertySources().addFirst(propertySource);</span><br><span class="line">        context.register(AnnotatedSpringIoCContainerConfigurationDemo.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        Map&lt;String, User&gt; userMap = context.getBeansOfType(User.class);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, User&gt; entry : userMap.entrySet()) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;User Bean name:%s,content: %s \n&quot;</span>, entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(context.getEnvironment().getPropertySources());</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于yml资源装载外部化配置"><a class="markdownIt-Anchor" href="#基于yml资源装载外部化配置"></a> 基于yml资源装载外部化配置</h2>
<p>使用API编程：</p>
<ul>
<li>org.springframework.beans.factory.config.YamlProcessor
<ul>
<li>org.springframework.beans.factory.config.YamlMapFactoryBean</li>
<li>org.springframework.beans.factory.config.YamlPropertiesFactoryBean</li>
</ul>
</li>
</ul>
<p>定义YAML文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line">  <span class="attr">id:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">吉永超</span></span><br></pre></td></tr></table></figure>
<p>定义XML文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yamlMap&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.YamlMapFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;resources&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:/META-INF/user.yaml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试我们的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBasedYamlPropertySourceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        reader.loadBeanDefinitions(<span class="string">&quot;classpath:/META-INF/yaml-property-source-context.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取User Bean对象</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PropertySource默认是没有yaml格式的实现的，我们可以自己实现一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YamlPropertySourceFactory</span> <span class="keyword">implements</span> <span class="title">PropertySourceFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        YamlPropertiesFactoryBean yamlPropertiesFactoryBean = <span class="keyword">new</span> YamlPropertiesFactoryBean();</span><br><span class="line">        yamlPropertiesFactoryBean.setResources(resource.getResource());</span><br><span class="line">        Properties yamlProperties = yamlPropertiesFactoryBean.getObject();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertiesPropertySource(name, yamlProperties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用YAML的方式装载外部化配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(name = &quot;yamlPropertySource&quot;,</span></span><br><span class="line"><span class="meta">        value = &quot;classpath:/META-INF/user.yaml&quot;,</span></span><br><span class="line"><span class="meta">        factory = YamlPropertySourceFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedYamlPropertySourceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">(<span class="meta">@Value(&quot;$&#123;user.id&#125;&quot;)</span> String id, <span class="meta">@Value(&quot;$&#123;user.name&#125;&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        context.register(AnnotatedYamlPropertySourceDemo.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-10"><a class="markdownIt-Anchor" href="#面试题-10"></a> 面试题</h2>
<h3 id="spring内建的xml-schema常见有哪些"><a class="markdownIt-Anchor" href="#spring内建的xml-schema常见有哪些"></a> Spring内建的XML Schema常见有哪些？</h3>
<p>见基于XML资源装载Spring 容器配置元信息章节表格。</p>
<h3 id="spring配置元信息有哪些"><a class="markdownIt-Anchor" href="#spring配置元信息有哪些"></a> Spring配置元信息有哪些？</h3>
<ul>
<li>Bean配置元信息：通过媒介（如XML、Properties）等，解析BeanDefinition</li>
<li>IoC容器配置元信息：通过媒介（如XML、Properties等），控制IoC容器行为，比如注解驱动，AOP等</li>
<li>外部化配置：通过资源抽象（如Properties、YAML等），控制PropertySource</li>
<li>Spring Profile：通过外部化配置，提供条件分支流程</li>
</ul>
<h3 id="extensible-xml-authoring的缺点"><a class="markdownIt-Anchor" href="#extensible-xml-authoring的缺点"></a> Extensible XML authoring的缺点？</h3>
<ul>
<li>高复杂度：开发人员需要熟悉XML schema、Spring.handlers，Spring.schemas以及Spring API</li>
<li>嵌套元素支持较弱：通常需要使用方法递归或者嵌套解析的方式处理嵌套（子）元素</li>
<li>XML处理性能较差：Spring XML基于DOM Levels API 实现，该API便于理解，然而性能较差</li>
<li>XML框架移植性较差：很难适配高性能和便利性的XML框架，如JAXB。</li>
</ul>
<h1 id="spring-资源管理"><a class="markdownIt-Anchor" href="#spring-资源管理"></a> Spring 资源管理</h1>
<blockquote>
<p>为什么Spring不使用Java标准资源管理，而选择重新发明轮子？</p>
<ul>
<li>Java标准资源管理强大，然而扩展复杂，资源存储方式并不统一</li>
<li>Spring要自立门户</li>
<li>Spring “抄”、“超”、“潮”</li>
</ul>
</blockquote>
<h2 id="java标准资源管理"><a class="markdownIt-Anchor" href="#java标准资源管理"></a> Java标准资源管理</h2>
<p>Java标准资源定位：</p>
<table>
<thead>
<tr>
<th>职责</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向资源</td>
<td>文件系统、artifact（jar、war、ear文件）以及远程资源（HTTP、FTP等）</td>
</tr>
<tr>
<td>API整合</td>
<td>java.lang.ClassLoader#getResource、java.io.File或java.net.URL</td>
</tr>
<tr>
<td>资源定位</td>
<td>java.net.URL或java.net.URI</td>
</tr>
<tr>
<td>面向流失存储</td>
<td>java.net.URLConnection</td>
</tr>
<tr>
<td>协议扩展</td>
<td>java.net.URLStreamHandler或java.net.URLStreamHandleFactory</td>
</tr>
</tbody>
</table>
<h2 id="resource接口"><a class="markdownIt-Anchor" href="#resource接口"></a> Resource接口</h2>
<p>资源接口：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入流</td>
<td>org.springframework.core.io.InputStreamResource</td>
</tr>
<tr>
<td>只读资源</td>
<td>org.springframework.core.io.Resource</td>
</tr>
<tr>
<td>可写资源</td>
<td>org.springframework.core.io.WritableResource</td>
</tr>
<tr>
<td>编码资源</td>
<td>org.springframework.core.io.support.EncodedResource</td>
</tr>
<tr>
<td>上下文资源</td>
<td>org.springframework.core.io.ContextResource</td>
</tr>
</tbody>
</table>
<h2 id="内建的resource实现"><a class="markdownIt-Anchor" href="#内建的resource实现"></a> 内建的Resource实现</h2>
<p>内建实现：</p>
<table>
<thead>
<tr>
<th>资源来源</th>
<th>资源协议</th>
<th>实现类</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bean定义</td>
<td>无</td>
<td>org.springframework.beans.factory.support.BeanDefinitionResource</td>
</tr>
<tr>
<td>数组</td>
<td>无</td>
<td>org.springframework.core.io.ByteArrayResource</td>
</tr>
<tr>
<td>类路径</td>
<td>classpath:/</td>
<td>org.springframework.core.io.ClassPathResource</td>
</tr>
<tr>
<td>文件系统</td>
<td>file:/</td>
<td>org.springframework.core.io.FileSystemResource</td>
</tr>
<tr>
<td>URL</td>
<td>URL支持的协议</td>
<td>org.springframework.core.io.UrlResource</td>
</tr>
<tr>
<td>ServletContext</td>
<td>无</td>
<td>org.springframework.web.context.support.ServletContextResource</td>
</tr>
</tbody>
</table>
<h2 id="resource接口扩展"><a class="markdownIt-Anchor" href="#resource接口扩展"></a> Resource接口扩展</h2>
<ol>
<li>可写资源接口
<ul>
<li>org.springframework.core.io.WritableResource
<ul>
<li>org.springframework.core.io.FileSystemResource</li>
<li>org.springframework.core.io.FileUrlResource（@since 5.0.2）</li>
<li>org.springframework.core.io.PathResource（@since 4.0 &amp; @Deprecated）</li>
</ul>
</li>
</ul>
</li>
<li>编码资源接口
<ul>
<li>org.springframework.core.io.support.EncodedResource</li>
</ul>
</li>
</ol>
<p>使用编码资源接口进行操作的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodedFileSystemResourceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String currentJavaFilePath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/bean-resource/src/main/java/org/jyc/thinking/in/spring/resource/EncodedFileSystemResourceDemo.java&quot;</span>;</span><br><span class="line">        File currentJavaFile = <span class="keyword">new</span> File(currentJavaFilePath);</span><br><span class="line">        FileSystemResource fileSystemResource = <span class="keyword">new</span> FileSystemResource(currentJavaFile);</span><br><span class="line">        EncodedResource encodedResource = <span class="keyword">new</span> EncodedResource(fileSystemResource, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 字符输入流</span></span><br><span class="line">        <span class="keyword">try</span> (Reader reader = encodedResource.getReader()) &#123;</span><br><span class="line">            System.out.println(IOUtils.toString(reader));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring资源加载器"><a class="markdownIt-Anchor" href="#spring资源加载器"></a> Spring资源加载器</h2>
<p>Resource加载器：</p>
<ul>
<li>org.springframework.core.io.ResourceLoader
<ul>
<li>org.springframework.core.io.DefaultResourceLoader</li>
<li>org.springframework.core.io.FileSystemResourceLoader</li>
<li>org.springframework.core.io.ClassRelativeResourceLoader</li>
<li>org.springframework.context.support.AbstractApplicationContext</li>
</ul>
</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodedFileSystemResourceLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String currentJavaFilePath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/bean-resource/src/main/java/org/jyc/thinking/in/spring/resource/EncodedFileSystemResourceLoaderDemo.java&quot;</span>;</span><br><span class="line">        FileSystemResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line">        Resource fileSystemResource = resourceLoader.getResource(currentJavaFilePath);</span><br><span class="line">        EncodedResource encodedResource = <span class="keyword">new</span> EncodedResource(fileSystemResource, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 字符输入流</span></span><br><span class="line">        <span class="keyword">try</span> (Reader reader = encodedResource.getReader()) &#123;</span><br><span class="line">            System.out.println(IOUtils.toString(reader));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring通配路径资源加载器"><a class="markdownIt-Anchor" href="#spring通配路径资源加载器"></a> Spring通配路径资源加载器</h2>
<ol>
<li>通配路径ResourceLoader
<ul>
<li>org.springframework.core.io.support.ResourcePatternResolver</li>
<li>org.springframework.core.io.support.PathMatchingResourcePatternResolver</li>
</ul>
</li>
<li>路径匹配器
<ul>
<li>org.springframework.util.PathMatcher
<ul>
<li>Ant模式匹配实现 - org.springframework.util.AntPathMatcher</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="spring通配路径资源扩展"><a class="markdownIt-Anchor" href="#spring通配路径资源扩展"></a> Spring通配路径资源扩展</h2>
<ol>
<li>实现org.springframework.util.PathMatcher</li>
<li>重置PathMatcher
<ul>
<li>PathMatchingResourcePatternResolver#setPathMatcher</li>
</ul>
</li>
</ol>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedResourcePatternResolver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 读取当前package对应的所有的.java文件</span></span><br><span class="line">        <span class="comment">// *.java</span></span><br><span class="line">        String currentPackagePath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/bean-resource/src/main/java/org/jyc/thinking/in/spring/resource/&quot;</span>;</span><br><span class="line">        String locationPattern = currentPackagePath + <span class="string">&quot;*.java&quot;</span>;</span><br><span class="line">        PathMatchingResourcePatternResolver resourcePatternResolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">new</span> FileSystemResourceLoader());</span><br><span class="line"></span><br><span class="line">        resourcePatternResolver.setPathMatcher(<span class="keyword">new</span> JavaFilePathMatcher());</span><br><span class="line">        Resource[] resources = resourcePatternResolver.getResources(locationPattern);</span><br><span class="line">        Stream.of(resources).map(ResourceUtils::getContent).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaFilePathMatcher</span> <span class="keyword">implements</span> <span class="title">PathMatcher</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPattern</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> path.endsWith(<span class="string">&quot;.java&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String pattern, String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> path.endsWith(<span class="string">&quot;.java&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchStart</span><span class="params">(String pattern, String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">extractPathWithinPattern</span><span class="params">(String pattern, String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">extractUriTemplateVariables</span><span class="params">(String pattern, String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Comparator&lt;String&gt; <span class="title">getPatternComparator</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">combine</span><span class="params">(String pattern1, String pattern2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中使用到的工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getContent</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getContent(resource, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getContent</span><span class="params">(Resource resource, String encoding)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        EncodedResource encodedResource = <span class="keyword">new</span> EncodedResource(resource, encoding);</span><br><span class="line">        <span class="keyword">try</span> (Reader reader = encodedResource.getReader()) &#123;</span><br><span class="line">            <span class="keyword">return</span> IOUtils.toString(reader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="依赖注入spring-resource"><a class="markdownIt-Anchor" href="#依赖注入spring-resource"></a> 依赖注入Spring Resource</h2>
<p>可以基于@Value实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;classpath:/...&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Resource resource;</span><br></pre></td></tr></table></figure>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectResourceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;classpath:/META-INF/default.properties&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Resource defaultPropertiesResource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;classpath*:/META-INF/*.properties&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Resource[] PropertiesResources;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;user.dir&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String currentProjectRootPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(ResourceUtils.getContent(defaultPropertiesResource));</span><br><span class="line">        System.out.println(currentProjectRootPath);</span><br><span class="line">        Stream.of(PropertiesResources).map(ResourceUtils::getContent).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(InjectResourceDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="comment">// 关闭应用上下文</span></span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="依赖注入resourceloader"><a class="markdownIt-Anchor" href="#依赖注入resourceloader"></a> 依赖注入ResourceLoader</h2>
<p>有多种方式可以依赖注入ResourceLoader：</p>
<ol>
<li>实现ResourceLoaderAware回调</li>
<li>@Autowired注入ResourceLoader</li>
<li>注入ApplicationContext作为ResourceLoader</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectResourceLoaderDemo</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader awareResourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ResourceLoader autowiredResourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AbstractApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;awareResourceLoader == autowiredResourceLoader: &quot;</span> + (autowiredResourceLoader == awareResourceLoader));</span><br><span class="line">        System.out.println(<span class="string">&quot;autowiredResourceLoader == applicationContext: &quot;</span> + (awareResourceLoader == applicationContext));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(InjectResourceLoaderDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="comment">// 关闭应用上下文</span></span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.awareResourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这三种不同的方式最终注入的是相同的对象，都是AbstractApplicationContext。</p>
</blockquote>
<h2 id="面试题-11"><a class="markdownIt-Anchor" href="#面试题-11"></a> 面试题</h2>
<h3 id="spring配置资源中有哪些常见类型"><a class="markdownIt-Anchor" href="#spring配置资源中有哪些常见类型"></a> Spring配置资源中有哪些常见类型？</h3>
<p>XML资源、Properties资源、YAML资源。</p>
<h3 id="请举例不同类型的spring配置资源"><a class="markdownIt-Anchor" href="#请举例不同类型的spring配置资源"></a> 请举例不同类型的Spring配置资源</h3>
<p>XML资源：</p>
<ol>
<li>普通的BeanDefinition XML资源配置 - *.xml</li>
<li>Spring Schema资源 - *.xsd</li>
</ol>
<p>Properties资源：</p>
<ol>
<li>普通Properties格式资源 - *.properties</li>
<li>Spring Handler实现类映射文件 - META/spring.handlers</li>
<li>Spring Schema资源映射文件 - META-INF/spring.schemas</li>
</ol>
<p>YAML资源：</p>
<ol>
<li>普通YAML资源配置 - *.yaml或 *.yml</li>
</ol>
<h3 id="java标准资源管理扩展的步骤"><a class="markdownIt-Anchor" href="#java标准资源管理扩展的步骤"></a> Java标准资源管理扩展的步骤</h3>
<p>简易实现：</p>
<ul>
<li>实现URLStreamHandler并放置再sun.net.www.protocol.${protocol}.Handler包下</li>
</ul>
<p>自定义实现：</p>
<ul>
<li>实现URLStreamHandler</li>
<li>添加 -Djava.protocol.handler.pkgs启动参数，指向URLStreamHandler实现类的包下</li>
</ul>
<p>高级实现：</p>
<ul>
<li>实现URLStreamHandlerFactory并传递到URL之中</li>
</ul>
<h1 id="spring-国际化"><a class="markdownIt-Anchor" href="#spring-国际化"></a> Spring 国际化</h1>
<p>Spring国际化使用场景：</p>
<ul>
<li>普通国际化文案</li>
<li>Bean Validation校验国际化文案</li>
<li>Web站点页面渲染</li>
<li>Web MVC错误消息提示</li>
</ul>
<h2 id="spring国际化接口"><a class="markdownIt-Anchor" href="#spring国际化接口"></a> Spring国际化接口</h2>
<p>核心接口：</p>
<ul>
<li>org.springframework.context.MessageSource</li>
</ul>
<p>主要概念：</p>
<ul>
<li>文案模板编码（code）</li>
<li>文案模板参数（args）</li>
<li>区域（Locale）</li>
</ul>
<h2 id="层次性的messagesource"><a class="markdownIt-Anchor" href="#层次性的messagesource"></a> 层次性的MessageSource</h2>
<p>Spring层次性国际化接口：</p>
<ul>
<li>org.springframework.context.HierarchicalMessageSource</li>
</ul>
<h2 id="java国际化标准实现"><a class="markdownIt-Anchor" href="#java国际化标准实现"></a> Java国际化标准实现</h2>
<p>核心接口：</p>
<ul>
<li>抽象实现 - java.util.ResourceBundle</li>
<li>Properties资源实现 - java.util.PropertyResourceBundle</li>
<li>列举实现 - java.util.ListResourceBundle</li>
</ul>
<p>ResourceBundle核心特性：</p>
<ul>
<li>Key - Value设计</li>
<li>层次性设计</li>
<li>缓存设计</li>
<li>字符编码控制 - java.util.ResourceBundle.Control（@since 1.6）</li>
<li>Control SPI扩展 - java.util.spi.ResourceBundleControlProvider（@since 1.8）</li>
</ul>
<h2 id="java文本格式化"><a class="markdownIt-Anchor" href="#java文本格式化"></a> Java文本格式化</h2>
<p>核心接口：</p>
<ul>
<li>java.text.MessageFormat</li>
</ul>
<p>基本用法：</p>
<ul>
<li>设置消息格式模式 - new MessageFormat(…)</li>
<li>格式化 - format(new Objectp[]{…})</li>
</ul>
<p>消息格式模式：</p>
<ul>
<li>格式元素：{ArgumentIndex（,FormatType,（FormatStyle））}</li>
<li>FormatType：消息格式类型，可选项，每种类型在number、date、time和choice类型选其一</li>
<li>FormatStyle：消息格式风格，可选项，包括：short、medium、long、full、integer、currency、percent</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageFormatDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> planet = <span class="number">7</span>;</span><br><span class="line">        String event = <span class="string">&quot;a disturbance in the Force&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String result = MessageFormat.format(</span><br><span class="line">                <span class="string">&quot;At &#123;1,time,long&#125; on &#123;1,date&#125;, there was &#123;2&#125; on planet &#123;0,number,integer&#125;.&quot;</span>,</span><br><span class="line">                planet, <span class="keyword">new</span> Date(), event);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java文本格式化还有一些高级特性：</p>
<ul>
<li>重置消息格式模板</li>
<li>重置java.util.Locale</li>
<li>重置java.text.Format</li>
</ul>
<p>使用的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageFormatDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> planet = <span class="number">7</span>;</span><br><span class="line">        String event = <span class="string">&quot;a disturbance in the Force&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String messageFormatPattern = <span class="string">&quot;At &#123;1,time,long&#125; on &#123;1,date&#125;, there was &#123;2&#125; on planet &#123;0,number,integer&#125;.&quot;</span>;</span><br><span class="line">        MessageFormat messageFormat = <span class="keyword">new</span> MessageFormat(messageFormatPattern);</span><br><span class="line">        String result = messageFormat.format(<span class="keyword">new</span> Object[]&#123;planet, <span class="keyword">new</span> Date(), event&#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置MessageFormatPattern</span></span><br><span class="line">        messageFormatPattern = <span class="string">&quot;This is a text: &#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;</span>;</span><br><span class="line">        messageFormat.applyPattern(messageFormatPattern);</span><br><span class="line">        result = messageFormat.format(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;hello,world&quot;</span>, <span class="string">&quot;666&quot;</span>&#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置Locale</span></span><br><span class="line">        messageFormat.setLocale(Locale.ENGLISH);</span><br><span class="line">        messageFormatPattern = <span class="string">&quot;At &#123;1,time,long&#125; on &#123;1,date&#125;, there was &#123;2&#125; on planet &#123;0,number,integer&#125;.&quot;</span>;</span><br><span class="line">        messageFormat.applyPattern(messageFormatPattern);</span><br><span class="line">        result = messageFormat.format(<span class="keyword">new</span> Object[]&#123;planet, <span class="keyword">new</span> Date(), event&#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置Format</span></span><br><span class="line">        <span class="comment">// 根据参数索引来设置 Pattern</span></span><br><span class="line">        messageFormat.setFormat(<span class="number">1</span>, <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;YYYY-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        result = messageFormat.format(<span class="keyword">new</span> Object[]&#123;planet, <span class="keyword">new</span> Date(), event&#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="messagesource开箱实现"><a class="markdownIt-Anchor" href="#messagesource开箱实现"></a> MessageSource开箱实现</h2>
<p>基于ResourceBundle + MessageFormat组合MessageSource实现：</p>
<ul>
<li>org.springframework.context.support.ResourceBundleMessageSource</li>
</ul>
<p>可重载Properties + MessageFormat组合MessageSource实现：</p>
<ul>
<li>org.springframework.context.support.ReloadableResourceBundleMessageSource</li>
</ul>
<h2 id="message的内建依赖"><a class="markdownIt-Anchor" href="#message的内建依赖"></a> Message的内建依赖</h2>
<p>MessageSource内建Bean可能来源：</p>
<ul>
<li>预注册Bean名称为：“messageSource”，类型为：MessageSource Bean</li>
<li>默认内建实现 - DelegatingMessageSource
<ul>
<li>层次性查找MessageSource对象</li>
</ul>
</li>
</ul>
<p>相关的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">			<span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">				HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">				<span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">					<span class="comment">// registered already.</span></span><br><span class="line">					hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">			DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">			dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">			<span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">			beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">&quot;&#x27; bean, using [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="springboot为什么要新建messagesource-bean"><a class="markdownIt-Anchor" href="#springboot为什么要新建messagesource-bean"></a> SpringBoot为什么要新建MessageSource Bean?</h2>
<ol>
<li>AbstractApplicationContext的实现决定了MessageSource内建实现</li>
<li>Spring Boot通过外部化配置简化了MessageSource Bean构建</li>
<li>SPring Boot基于Bean Validation校验非常普遍</li>
</ol>
<p>实际上我们可以覆盖SpringBoot中自动装配的MessageSource Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedMessageSourceBeanDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Spring Boot场景中，Primary Configure Sources（Classes）高于*AutoConfiguration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReloadableResourceBundleMessageSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = SpringApplication.run(CustomizedMessageSourceBeanDemo.class, args);</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.containsBean(AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">            beanFactory.getBean(AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME);</span><br><span class="line">            <span class="comment">// 查找MessageSource Bean</span></span><br><span class="line">            MessageSource messageSource = applicationContext.getBean(AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">            System.out.println(messageSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-12"><a class="markdownIt-Anchor" href="#面试题-12"></a> 面试题</h2>
<h3 id="spring国际化接口有哪些"><a class="markdownIt-Anchor" href="#spring国际化接口有哪些"></a> Spring国际化接口有哪些？</h3>
<ol>
<li>核心接口 - MessageSource</li>
<li>层次性接口 - org.springframework.context.HierarchicalMessageSource</li>
</ol>
<h3 id="spring有哪些messagesource的内建实现"><a class="markdownIt-Anchor" href="#spring有哪些messagesource的内建实现"></a> Spring有哪些MessageSource的内建实现？</h3>
<ul>
<li>org.springframework.context.support.ResourceBundleMessageSource</li>
<li>org.springframework.context.support.ReloadableResourceBundleMessageSource</li>
<li>org.springframework.context.support.StaticMessageSource</li>
<li>org.springframework.context.support.DelegatingMessageSource</li>
</ul>
<h3 id="如何实现配置自动更新messagesource"><a class="markdownIt-Anchor" href="#如何实现配置自动更新messagesource"></a> 如何实现配置自动更新MessageSource？</h3>
<p>主要技术：</p>
<ul>
<li>Java NIO 2：java.nio.file.watchService</li>
<li>Java Concurrency：java.util.concurrent.ExecutorService</li>
<li>Spring：org.springframework.context.support.AbstractMessageSource</li>
</ul>
<h1 id="spring-校验"><a class="markdownIt-Anchor" href="#spring-校验"></a> Spring 校验</h1>
<p>Spring校验使用场景：</p>
<ul>
<li>Spring 常规校验（Validator）</li>
<li>Spring 数据绑定（DataBinder）</li>
<li>Spring Web参数绑定（WebDataBinder）</li>
<li>Spring WebMVC/WebFlux处理方法参数校验</li>
</ul>
<h2 id="validator接口设计"><a class="markdownIt-Anchor" href="#validator接口设计"></a> Validator接口设计</h2>
<p>接口职责：</p>
<ul>
<li>Spring内部校验接口，通过编程的方式校验目标对象</li>
</ul>
<p>核心方法：</p>
<ul>
<li>supports（Class）：校验目标类能否校验</li>
<li>validate（Object，Errors）：校验目标对象，并将校验失败的内容输出至Errors对象</li>
</ul>
<p>配套组件：</p>
<ul>
<li>错误收集器：org.springframework.validation.Errors</li>
<li>Validator工具类：org.springframework.validation.ValidationUtils</li>
</ul>
<p>在Java Doc中的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLoginValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINIMUM_PASSWORD_LENGTH = <span class="number">6</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> UserLogin.class.isAssignableFrom(clazz);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span> </span>&#123;</span><br><span class="line">         ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">&quot;userName&quot;</span>, <span class="string">&quot;field.required&quot;</span>);</span><br><span class="line">         ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;field.required&quot;</span>);</span><br><span class="line">         UserLogin login = (UserLogin) target;</span><br><span class="line">         <span class="keyword">if</span> (login.getPassword() != <span class="keyword">null</span></span><br><span class="line">               &amp;&amp; login.getPassword().trim().length() &lt; MINIMUM_PASSWORD_LENGTH) &#123;</span><br><span class="line">            errors.rejectValue(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;field.min.length&quot;</span>,</span><br><span class="line">                  <span class="keyword">new</span> Object[]&#123;Integer.valueOf(MINIMUM_PASSWORD_LENGTH)&#125;,</span><br><span class="line">                  <span class="string">&quot;The password must be at least [&quot;</span> + MINIMUM_PASSWORD_LENGTH + <span class="string">&quot;] characters in length.&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="errors接口设计"><a class="markdownIt-Anchor" href="#errors接口设计"></a> Errors接口设计</h2>
<p>接口职责：</p>
<ul>
<li>数据绑定和校验错误收集接口，与Java Bean和其属性有强关联性。</li>
</ul>
<p>核心方法：</p>
<ul>
<li>reject方法（重载）：收集错误文案</li>
<li>rejectValue方法（重载）：收集对象字段中的错误文案</li>
</ul>
<p>配套组件：</p>
<ul>
<li>Java Bean错误描述：org.springframework.validation.ObjectError</li>
<li>Java Bean属性错误描述：org.springframework.validation.FieldError</li>
</ul>
<h2 id="errors的文案来源"><a class="markdownIt-Anchor" href="#errors的文案来源"></a> Errors的文案来源</h2>
<p>Errors文案生成步骤：</p>
<ol>
<li>选择Errors实现（org.springframework.validation.BeanPropertyBindingResult）</li>
<li>调用reject方法或rejectValue方法</li>
<li>获取Errors对象中ObjectError或FieldError</li>
<li>将ObjectError或FieldError中的code和args，关联MessageSource实现（如：ResourceBundleMessageSource）</li>
</ol>
<p>使用的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorMessageDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建User对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 2.选择Errors - BeanPropertyBindingResult</span></span><br><span class="line">        Errors errors = <span class="keyword">new</span> BeanPropertyBindingResult(user, <span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.调用reject或者rejectValue</span></span><br><span class="line">        <span class="comment">// reject生成ObjectError</span></span><br><span class="line">        <span class="comment">// reject生成 FildError</span></span><br><span class="line">        errors.reject(<span class="string">&quot;user.properties.not.null&quot;</span>);</span><br><span class="line">        errors.rejectValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;name.required&quot;</span>);</span><br><span class="line">        <span class="comment">//4.FieldError is ObjectError</span></span><br><span class="line">        List&lt;ObjectError&gt; globalErrors = errors.getGlobalErrors();</span><br><span class="line">        FieldError fieldError = errors.getFieldError();</span><br><span class="line">        List&lt;ObjectError&gt; allErrors = errors.getAllErrors();</span><br><span class="line">        <span class="comment">// 5.通过ObjectError和FieldError中的code和args关联MessageSource实现</span></span><br><span class="line">        MessageSource messageSource = createMessageSource();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ObjectError error : allErrors) &#123;</span><br><span class="line">            messageSource.getMessage(error.getCode(), error.getArguments(), Locale.getDefault());</span><br><span class="line">            System.out.println(messageSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MessageSource <span class="title">createMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StaticMessageSource staticMessageSource = <span class="keyword">new</span> StaticMessageSource();</span><br><span class="line">        staticMessageSource.addMessage(<span class="string">&quot;user.properties.not.null&quot;</span>, Locale.getDefault(), <span class="string">&quot;User 属性不能为空&quot;</span>);</span><br><span class="line">        staticMessageSource.addMessage(<span class="string">&quot;name.required&quot;</span>, Locale.getDefault(), <span class="string">&quot;name is not null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> staticMessageSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义validator"><a class="markdownIt-Anchor" href="#自定义validator"></a> 自定义Validator</h2>
<p>实现org.springframework.validation.Validator接口，具体操作如下：</p>
<ul>
<li>实现supports方法</li>
<li>实现validate方法
<ul>
<li>通过Errors对象收集错误
<ul>
<li>ObjectError：对象（Bean）错误：</li>
<li>FieldError：对象（Bean）属性（Property）错误</li>
</ul>
</li>
<li>通过ObjectError和FieldError关联MessageSource实现获取最终文案</li>
</ul>
</li>
</ul>
<p>自定义Validator的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建Validator</span></span><br><span class="line">        Validator validator = <span class="keyword">new</span> UserValodator();</span><br><span class="line">        <span class="comment">// 2.判断是否支持目标对象的类型</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        System.out.println(validator.supports(user.getClass()));</span><br><span class="line">        <span class="comment">// 3.创建Errors对象</span></span><br><span class="line">        Errors errors = <span class="keyword">new</span> BeanPropertyBindingResult(user, <span class="string">&quot;user&quot;</span>);</span><br><span class="line">        validator.validate(user, errors);</span><br><span class="line">        <span class="comment">// 4.获取MessageSource对象</span></span><br><span class="line">        MessageSource messageSource = createMessageSource();</span><br><span class="line">        <span class="comment">// 5.输出所有的错误文案</span></span><br><span class="line">        <span class="keyword">for</span> (ObjectError error : errors.getAllErrors()) &#123;</span><br><span class="line">            String message = messageSource.getMessage(error.getCode(), error.getArguments(), Locale.getDefault());</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserValodator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> User.class.equals(clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span> </span>&#123;</span><br><span class="line">            User user = (User) target;</span><br><span class="line">            ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;id.required&quot;</span>);</span><br><span class="line">            ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;name.required&quot;</span>);</span><br><span class="line">            String name = user.getName();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bean-validation"><a class="markdownIt-Anchor" href="#bean-validation"></a> Bean Validation</h2>
<p>Bean Validation 与 Validator适配：</p>
<ul>
<li>核心组件 - org.springframework.validation.beanvalidation.LocalValidatorFactoryBean</li>
<li>依赖Bean Validation - JSR - 303 or JSR - 349 provider</li>
<li>Bean方法参数校验 - org.springframework.validation.beanvalidation.MethodValidationPostProcessor</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBeanValidationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:/META-INF/bean-validation-context.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Validator validator = applicationContext.getBean(Validator.class);</span></span><br><span class="line"><span class="comment">//        System.out.println(validator instanceof LocalValidatorFactoryBean);</span></span><br><span class="line">        UserProcessor userProcessor = applicationContext.getBean(UserProcessor.class);</span><br><span class="line">        userProcessor.processUser(<span class="keyword">new</span> User());</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="meta">@Validated</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProcessor</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processUser</span><span class="params">(<span class="meta">@Valid</span> User user)</span> </span>&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Validated</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的XML文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.jyc.thinking.in.spring.validation&quot;</span> /&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;validator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.validation.beanvalidation.MethodValidationPostProcessor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validator&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;validator&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到使用这种方式方便了很多，并且可以根据实际的需求对其进行扩展。</p>
<h2 id="面试题-13"><a class="markdownIt-Anchor" href="#面试题-13"></a> 面试题</h2>
<h3 id="spring校验接口是哪个"><a class="markdownIt-Anchor" href="#spring校验接口是哪个"></a> Spring校验接口是哪个？</h3>
<p>org.springframework.validation.Validator</p>
<h3 id="spring有哪些校验核心组件"><a class="markdownIt-Anchor" href="#spring有哪些校验核心组件"></a> Spring有哪些校验核心组件？</h3>
<ul>
<li>校验器：org.springframework.validation.Validator</li>
<li>错误收集器：org.springframework.validation.Errors</li>
<li>Java Bean错误描述：org.springframework.validation.ObjectError</li>
<li>Java Bean属性错误描述：org.springframework.validation.FieldError</li>
<li>Bean Validation适配：org.springframework.validation.beanvalidation.LocalValidatorFactoryBean</li>
</ul>
<h3 id="请通过示例演示spring-bean的校验"><a class="markdownIt-Anchor" href="#请通过示例演示spring-bean的校验"></a> 请通过示例演示Spring Bean的校验？</h3>
<p>// 待续…</p>
<h1 id="spring-数据绑定"><a class="markdownIt-Anchor" href="#spring-数据绑定"></a> Spring 数据绑定</h1>
<p>Spring数据绑定的使用场景：</p>
<ol>
<li>Spring BeanDefinition到Bean实例创建</li>
<li>Spring数据绑定（DataBinder）</li>
<li>Spring Web参数绑定（WebDataBinder）</li>
</ol>
<h2 id="spring-数据绑定组件"><a class="markdownIt-Anchor" href="#spring-数据绑定组件"></a> Spring 数据绑定组件</h2>
<ol>
<li>标准组件：
<ul>
<li>org.springframework.validation.DataBinder</li>
</ul>
</li>
<li>Web组件：
<ul>
<li>org.springframework.web.bind.WebDataBinder</li>
<li>org.springframework.web.bind.ServletRequestDataBinder</li>
<li>org.springframework.web.bind.support.WebRequestDataBinder</li>
<li>org.springframework.web.bind.support.WebExchangeDataBinder</li>
</ul>
</li>
</ol>
<p>DataBinder的核心属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>target</td>
<td>关联目标Bean</td>
</tr>
<tr>
<td>objectName</td>
<td>目标Bean名称</td>
</tr>
<tr>
<td>bindingResult</td>
<td>属性绑定结果</td>
</tr>
<tr>
<td>typeConverter</td>
<td>类型转化器</td>
</tr>
<tr>
<td>conversionService</td>
<td>类型转化服务</td>
</tr>
<tr>
<td>messageCodesResolver</td>
<td>校验错误文案Code处理器</td>
</tr>
<tr>
<td>validators</td>
<td>关联的Bean Validator实例集合</td>
</tr>
</tbody>
</table>
<p>DataBinder绑定方法bind（PropertyValues），会将PropertyValues key-Value内容映射到关联Bean（target）中的属性上。</p>
<h2 id="databinder元数据"><a class="markdownIt-Anchor" href="#databinder元数据"></a> DataBinder元数据</h2>
<p>DataBinder元数据 - PropertyValues：</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据来源</td>
<td>BeanDefinition，主要来源XML资源配置BeanDefinition</td>
</tr>
<tr>
<td>数据结构</td>
<td>由一个或多个PropertyValue组成</td>
</tr>
<tr>
<td>成员结构</td>
<td>PropertyValue包含属性名称，以及属性值（包括原始值、类型转换后的值）</td>
</tr>
<tr>
<td>常见实现</td>
<td>MutablePropertyValue</td>
</tr>
<tr>
<td>Web扩展实现</td>
<td>ServletConfigPropertyValue，ServletRequestParameterPropertyValues</td>
</tr>
<tr>
<td>相关生命周期</td>
<td>InstantiationAwareBeanPostProcessor#postProcessProperties</td>
</tr>
</tbody>
</table>
<h2 id="databinder绑定控制参数"><a class="markdownIt-Anchor" href="#databinder绑定控制参数"></a> DataBinder绑定控制参数</h2>
<p>DataBinder绑定特殊场景分析：</p>
<ul>
<li>当PropertyValues中包含名称的x的PropertyValue，目标对象B不存在x属性，当bind方法执行时，会发生什么？</li>
<li>当PropertyValues中包含名称的x的PropertyValue，目标对象B中存在x属性，当bind方法执行时，如何避免B属性x不被绑定？</li>
<li>当PropertyValues中包含x.y的PropertyValue，目标对象B中存在x属性（嵌套y属性），当bind方法执行时，会发生什么？</li>
</ul>
<p>相关的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBinderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建空白对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 1.创建DataBinder</span></span><br><span class="line">        DataBinder dataBinder = <span class="keyword">new</span> DataBinder(user, <span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建PropertyValues</span></span><br><span class="line">        HashMap&lt;String, Object&gt; source = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        source.put(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        source.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;吉永超&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a.PropertyValues存在user中不存在的属性值</span></span><br><span class="line">        <span class="comment">// DataBinder特性一：忽略了未知的属性</span></span><br><span class="line">        source.put(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.PropertyValues存在一个嵌套属性，company.name</span></span><br><span class="line">        <span class="comment">// DataBinder特性二：支持嵌套属性</span></span><br><span class="line">        source.put(<span class="string">&quot;company.name&quot;</span>,<span class="string">&quot;jjjj&quot;</span>);</span><br><span class="line"></span><br><span class="line">        MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues(source);</span><br><span class="line"></span><br><span class="line">        dataBinder.bind(propertyValues);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.输出user</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DataBinder绑定控制参数：</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ignoreUnknownFields</td>
<td>是否忽略未知字段，默认值：true</td>
</tr>
<tr>
<td>ignoreInvalidFields</td>
<td>是否忽略非法字段，默认值：false</td>
</tr>
<tr>
<td>autoGrowNestedPaths</td>
<td>是否自动增加嵌套路径，默认值：true</td>
</tr>
<tr>
<td>allowedFields</td>
<td>绑定字段白名单</td>
</tr>
<tr>
<td>disallowedFields</td>
<td>绑定字段黑名单</td>
</tr>
<tr>
<td>requiredFields</td>
<td>必须绑定字段</td>
</tr>
</tbody>
</table>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBinderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建空白对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 1.创建DataBinder</span></span><br><span class="line">        DataBinder dataBinder = <span class="keyword">new</span> DataBinder(user, <span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建PropertyValues</span></span><br><span class="line">        HashMap&lt;String, Object&gt; source = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        source.put(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        source.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;吉永超&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a.PropertyValues存在user中不存在的属性值</span></span><br><span class="line">        <span class="comment">// DataBinder特性一：忽略了未知的属性</span></span><br><span class="line">        source.put(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.PropertyValues存在一个嵌套属性，company.name</span></span><br><span class="line">        <span class="comment">// DataBinder特性二：支持嵌套属性</span></span><br><span class="line">        source.put(<span class="string">&quot;company.name&quot;</span>, <span class="string">&quot;jjjj&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        source.put(&quot;company&quot;, new Company());</span></span><br><span class="line"><span class="comment">//        source.put(&quot;company.name&quot;,&quot;jjjj&quot;);</span></span><br><span class="line"></span><br><span class="line">        MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues(source);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.调整ignoreUnknownFields true（默认） -&gt; false</span></span><br><span class="line"><span class="comment">//        dataBinder.setIgnoreUnknownFields(false);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.调整自动增加嵌套路径true（默认） -&gt; false</span></span><br><span class="line">        dataBinder.setAutoGrowNestedPaths(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.调整ignoreInvalidFields false（默认） -&gt; true</span></span><br><span class="line">        dataBinder.setIgnoreInvalidFields(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.白名单</span></span><br><span class="line">        dataBinder.setRequiredFields(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;city&quot;</span>);</span><br><span class="line"></span><br><span class="line">        dataBinder.bind(propertyValues);</span><br><span class="line">        <span class="comment">// 输出user</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.获取绑定结果（结果包含错误文案code，不会抛出异常）</span></span><br><span class="line">        BindingResult result = dataBinder.getBindingResult();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring底层java-beans替换实现"><a class="markdownIt-Anchor" href="#spring底层java-beans替换实现"></a> Spring底层Java Beans替换实现</h2>
<ol>
<li>Java Beans核心实现 - java.beans.BeanInfo
<ul>
<li>属性（Property）
<ul>
<li>java.beans.PropertyEditor</li>
</ul>
</li>
<li>方法（Method）</li>
<li>事件（Event）</li>
<li>表达式（Expression）</li>
</ul>
</li>
<li>Spring替代实现 - org.springframework.beans.BeanWrapper
<ul>
<li>属性（Property）
<ul>
<li>java.beans.PropertyEditor</li>
</ul>
</li>
<li>嵌套属性路径（nested path）</li>
</ul>
</li>
</ol>
<h2 id="beanwrapper使用场景"><a class="markdownIt-Anchor" href="#beanwrapper使用场景"></a> BeanWrapper使用场景</h2>
<ul>
<li>Spring底层JavaBeans基础设施的中心化接口</li>
<li>通常不会直接使用，间接用于BeanFactory和DataBinder</li>
<li>提供标准JavaBeans分析和操作，能够单独或批量存储Java Bean的属性（properties）</li>
<li>支持嵌套属性路径（nested path）</li>
<li>实现类 org.springframework.beans.BeanWrapperImpl</li>
</ul>
<h2 id="javabeans操作属性"><a class="markdownIt-Anchor" href="#javabeans操作属性"></a> JavaBeans操作属性</h2>
<p>标准的JavaBeans是如何操作属性的？</p>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>java.beans.Introspector</td>
<td>JavaBeans 内省API</td>
</tr>
<tr>
<td>java.beans.BeanInfo</td>
<td>Java Bean 元信息API</td>
</tr>
<tr>
<td>java.beans.BeanDescriptor</td>
<td>Java Bean 信息描述符</td>
</tr>
<tr>
<td>java.beans.PropertyDescriptor</td>
<td>Java Bean 属性描述符</td>
</tr>
<tr>
<td>java.beans.MethodDescriptor</td>
<td>Java Bean 方法描述符</td>
</tr>
<tr>
<td>java.beans.EventSetDescriptor</td>
<td>Java Bean 事件集合描述符</td>
</tr>
</tbody>
</table>
<blockquote>
<p>PropertyDescriptor并不要求setter、getter方法均存在。</p>
</blockquote>
<p>可以使用如下示例进行观察：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBeansDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// stopClass排除（截止）类</span></span><br><span class="line">        BeanInfo beanInfo = Introspector.getBeanInfo(User.class, Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 属性描述符 PropertyDescriptor</span></span><br><span class="line">        <span class="comment">// 所有的Java类均继承 java.lang.Object方法</span></span><br><span class="line">        <span class="comment">// Class属性来自于Object#getClass() 方法</span></span><br><span class="line">        Stream.of(beanInfo.getPropertyDescriptors()).forEach(propertyDescriptor -&gt; &#123;</span><br><span class="line">            propertyDescriptor.getReadMethod(); <span class="comment">// Getter方法</span></span><br><span class="line">            propertyDescriptor.getWriteMethod(); <span class="comment">// Setter方法</span></span><br><span class="line">            System.out.println(propertyDescriptor);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 输出User定义的方法 MethodDescriptor</span></span><br><span class="line">        Stream.of(beanInfo.getMethodDescriptors()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="databinder数据校验"><a class="markdownIt-Anchor" href="#databinder数据校验"></a> DataBinder数据校验</h2>
<p>DataBinder与BeanWrapper的联系：</p>
<ul>
<li>bind方法生成BeanPropertyBindingResult</li>
<li>BeanPropertyBindingResult关联BeanWrapper</li>
</ul>
<h2 id="面试题-14"><a class="markdownIt-Anchor" href="#面试题-14"></a> 面试题</h2>
<h3 id="spring数据绑定api是什么"><a class="markdownIt-Anchor" href="#spring数据绑定api是什么"></a> Spring数据绑定API是什么？</h3>
<p>org.springframework.validation.DataBinder</p>
<h3 id="beanwrapper与javabeans之间的关系是"><a class="markdownIt-Anchor" href="#beanwrapper与javabeans之间的关系是"></a> BeanWrapper与JavaBeans之间的关系是？</h3>
<p>BeanWrapper是Spring底层JavaBeans基础设施的中心化接口。</p>
<h3 id="databinder是怎么完成属性类型转换的"><a class="markdownIt-Anchor" href="#databinder是怎么完成属性类型转换的"></a> DataBinder是怎么完成属性类型转换的？</h3>
<p>// …</p>
<h1 id="spring-类型转换"><a class="markdownIt-Anchor" href="#spring-类型转换"></a> Spring 类型转换</h1>
<p>Spring类型转换的实现方案：</p>
<ol>
<li>基于JavaBeans接口的类型转换实现
<ul>
<li>基于java.beans.PropertyEditor扩展</li>
</ul>
</li>
<li>Spring 3.0+ 通用类型转换实现</li>
</ol>
<h2 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h2>
<p>场景分析：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>基于JavaBeans接口的类型转换实现</th>
<th>Spring 3.0+通用类型转换实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据绑定</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>BeanWrapper</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Bean属性类型转换</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>外部化属性类型转换</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody>
</table>
<h2 id="基于javabeans接口的类型转换"><a class="markdownIt-Anchor" href="#基于javabeans接口的类型转换"></a> 基于JavaBeans接口的类型转换</h2>
<ol>
<li>核心职责：
<ul>
<li>将String类型转化为目标类型的对象</li>
</ul>
</li>
<li>扩展原理：
<ul>
<li>Spring框架将文本内容传递到PropertyEditor实现的setAsText(String)方法</li>
<li>PropertyEditor#setAsText(String)方法实现将String类型转化为目标类型的对象</li>
<li>将目标类型的对象传入PropertyEditor#setAsValue(Object)方法</li>
<li>PropertyEditor#setAsValue(Object)方法实现需要临时存储传入对象</li>
<li>Spring框架将通过PropertyEditor#getValue()获取类型转换后的对象</li>
</ul>
</li>
</ol>
<p>我们可以模拟一下整个过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToPropertiesPropertyEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> <span class="keyword">implements</span> <span class="title">PropertyEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.实现setAsText方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">// 2.将String类型转换成Properties类型</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> StringReader(text));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.临时存储Properties对象</span></span><br><span class="line">        setValue(properties);</span><br><span class="line">        <span class="comment">// next 获取临时Properties对象 # getValue</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后观察输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyEditorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟Spring Framework的操作</span></span><br><span class="line">        <span class="comment">// 有一段文本name = &quot;吉永超&quot;;</span></span><br><span class="line">        String text = <span class="string">&quot;name = 吉永超&quot;</span>;</span><br><span class="line">        PropertyEditor propertyEditor = <span class="keyword">new</span> StringToPropertiesPropertyEditor();</span><br><span class="line">        propertyEditor.setAsText(text);</span><br><span class="line">        System.out.println(propertyEditor.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring内建propertyeditor扩展"><a class="markdownIt-Anchor" href="#spring内建propertyeditor扩展"></a> Spring内建PropertyEditor扩展</h2>
<p>内建扩展（org.springframework.beans.propertyeditors）：</p>
<table>
<thead>
<tr>
<th>转换场景</th>
<th>实现类</th>
</tr>
</thead>
<tbody>
<tr>
<td>String -&gt; Byte数组</td>
<td>org.springframework.beans.propertyeditors.ByteArrayPropertyEditor</td>
</tr>
<tr>
<td>String -&gt; Char</td>
<td>org.springframework.beans.propertyeditors.CharacterEditor</td>
</tr>
<tr>
<td>String -&gt; Char 数组</td>
<td>org.springframework.beans.propertyeditors.CharArrayPropertyEditor</td>
</tr>
<tr>
<td>String -&gt; Charset</td>
<td>org.springframework.beans.propertyeditors.CharsetEditor</td>
</tr>
<tr>
<td>String -&gt; Class</td>
<td>org.springframework.beans.propertyeditors.ClassEditor</td>
</tr>
<tr>
<td>String -&gt; Currency</td>
<td>org.springframework.beans.propertyeditors.CurrencyEditor</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<h2 id="自定义propertyeditor扩展"><a class="markdownIt-Anchor" href="#自定义propertyeditor扩展"></a> 自定义PropertyEditor扩展</h2>
<p>实现步骤如下：</p>
<ol>
<li>扩展模式：
<ul>
<li>扩展java.beans.PropertyEditorSupport类</li>
</ul>
</li>
<li>实现org.springframework.beans.PropertyEditorRegistrar
<ul>
<li>实现registerCustomEditor（org.springframework.beans.PropertyEditorRegistry）方法</li>
<li>将PropertyEditorRegistry实现注册为Spring Bean</li>
</ul>
</li>
<li>向org.springframework.beans.PropertyEditorRegistry注册自定义PropertyEditor实现
<ul>
<li>通用类型实现：registerCustomEditor(Class&lt;?&gt; requiredType, PropertyEditor propertyEditor);</li>
<li>Java Bean属性类型实现：registerCustomEditor(Class&lt;?&gt; requiredType,  String propertyPath, PropertyEditor propertyEditor);</li>
</ul>
</li>
</ol>
<p>相关的示例，第一步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToPropertiesPropertyEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> <span class="keyword">implements</span> <span class="title">PropertyEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.实现setAsText方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">// 2.将String类型转换成Properties类型</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> StringReader(text));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.临时存储Properties对象</span></span><br><span class="line">        setValue(properties);</span><br><span class="line">        <span class="comment">// next 获取临时Properties对象 # getValue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAsText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties properties = (Properties) getValue();</span><br><span class="line">        StringBuilder textBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">            textBuilder.append(entry.getKey()).append(<span class="string">&quot;=&quot;</span>).append(entry.getValue()).append(System.getProperty(<span class="string">&quot;line.separator&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> textBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步和第三步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Component // 3.将其声明为Spring Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedPropertyEditorRegistrar</span> <span class="keyword">implements</span> <span class="title">PropertyEditorRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerCustomEditors</span><span class="params">(PropertyEditorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.通用类型转换</span></span><br><span class="line">        <span class="comment">// 2.Java Bean属性类型转换</span></span><br><span class="line">        registry.registerCustomEditor(User.class, <span class="string">&quot;context&quot;</span>, <span class="keyword">new</span> StringToPropertiesPropertyEditor());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们不采用注解的方式，而是采用XML的方式进行配置，将CustomizedPropertyEditorRegistrar声明为Spring Bean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吉永超&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;context&quot;</span>&gt;</span> <span class="comment">&lt;!-- Properties类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">                id = 1</span><br><span class="line">                name = 吉永超</span><br><span class="line">            <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.conversion.CustomizedPropertyEditorRegistrar&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCustomizedPropertyEditorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:/META-INF/property-editors-context.xml&quot;</span>);</span><br><span class="line">        User user = applicationContext.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">// 关闭应用上下文</span></span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="propertyeditor的局限性"><a class="markdownIt-Anchor" href="#propertyeditor的局限性"></a> PropertyEditor的局限性</h2>
<ul>
<li>违反单一原则
<ul>
<li>java.beans.PropertyEditor接口职责太多，除了类型转换，还包括Java Beans事件和Java GUI交互</li>
</ul>
</li>
<li>java.beans.PropertyEditor实现类型局限
<ul>
<li>来源类型只能为java.lang.String类型</li>
</ul>
</li>
<li>java.beans.PropertyEditor实现缺少类型安全
<ul>
<li>除了实现类名可以表达语义，实现类无法感知目标转换类型</li>
</ul>
</li>
</ul>
<h2 id="spring3-通用类型转换接口"><a class="markdownIt-Anchor" href="#spring3-通用类型转换接口"></a> Spring3 通用类型转换接口</h2>
<ol>
<li>类型转换接口 - org.springframework.core.convert.converter.Converter&lt;S, T&gt;
<ul>
<li>泛型参数S：来源类型，参数T：目标类型</li>
<li>核心方法：T convert(S)</li>
</ul>
</li>
<li>通用类型转换接口 - org.springframework.core.convert.converter.GenericConverter
<ul>
<li>核心方法：convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);</li>
<li>配对类型：org.springframework.core.convert.converter.GenericConverter.ConvertiblePair</li>
<li>类型描述：org.springframework.core.convert.TypeDescriptor</li>
</ul>
</li>
</ol>
<h2 id="spring内建类型转换器"><a class="markdownIt-Anchor" href="#spring内建类型转换器"></a> Spring内建类型转换器</h2>
<table>
<thead>
<tr>
<th>转换场景</th>
<th>实现类所在包名(package)</th>
</tr>
</thead>
<tbody>
<tr>
<td>日期/时间相关</td>
<td>org.springframework.format.datetime</td>
</tr>
<tr>
<td>Java 8 日期/时间相关</td>
<td>org.springframework.format.datetime.standard</td>
</tr>
<tr>
<td>通用实现</td>
<td>org.springframework.core.convert.support</td>
</tr>
</tbody>
</table>
<h2 id="converter接口的局限性"><a class="markdownIt-Anchor" href="#converter接口的局限性"></a> Converter接口的局限性</h2>
<ul>
<li>局限一：缺少Source Type和Target Type前置判断
<ul>
<li>应对：增加org.springframework.core.convert.converter.ConditionalConverter实现</li>
</ul>
</li>
<li>局限二：仅能转换单一的Source Type和Target Type
<ul>
<li>应对：使用org.springframework.core.convert.converter.GenericConverter代替</li>
</ul>
</li>
</ul>
<h2 id="genericconverter接口"><a class="markdownIt-Anchor" href="#genericconverter接口"></a> GenericConverter接口</h2>
<p>org.springframework.core.convert.converter.GenericConverter的介绍：</p>
<table>
<thead>
<tr>
<th>核心要素</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用场景</td>
<td>用于&quot;复合&quot;类型转换场景，比如Collection、Map、数组等</td>
</tr>
<tr>
<td>转换范围</td>
<td>Set<ConvertiblePair> getConvertibleTypes()</td>
</tr>
<tr>
<td>配对类型</td>
<td>org.springframework.core.convert.converter.GenericConverter.ConvertiblePair</td>
</tr>
<tr>
<td>转换方法</td>
<td>convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</td>
</tr>
<tr>
<td>类型描述</td>
<td>org.springframework.core.convert.TypeDescriptor</td>
</tr>
</tbody>
</table>
<blockquote>
<p>&quot;复合&quot;类型在进行转换的时候，可以利用Converter接口，对集合（或其他类型）中的元素进行转换。</p>
</blockquote>
<h2 id="优化genericconverter接口"><a class="markdownIt-Anchor" href="#优化genericconverter接口"></a> 优化GenericConverter接口</h2>
<p>GenericConverter局限性：</p>
<ul>
<li>缺少Source TYpe和Target Type前置判断</li>
<li>单一类型转换实现复杂</li>
</ul>
<p>GenericConverter优化接口 - ConditionalGenericConverter</p>
<ul>
<li>复合类型转换 ：org.springframework.core.convert.converter.GenericConverter</li>
<li>类型条件判断：org.springframework.core.convert.converter.ConditionalConverter</li>
</ul>
<h2 id="扩展spring类型转换器"><a class="markdownIt-Anchor" href="#扩展spring类型转换器"></a> 扩展Spring类型转换器</h2>
<p>扩展的步骤：</p>
<ol>
<li>实现转换器接口
<ul>
<li>org.springframework.core.convert.converter.Converter</li>
<li>org.springframework.core.convert.converter.ConverterFatory</li>
<li>org.springframework.core.convert.converter.GenericConverter</li>
</ul>
</li>
<li>注册转换器实现
<ul>
<li>通过ConversionServiceFactoryBean（Spring Bean）</li>
<li>通过org.springframework.core.convert.ConversionService（API）</li>
</ul>
</li>
</ol>
<p>相关的示例如下，步骤一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesToStringConverter</span> <span class="keyword">implements</span> <span class="title">ConditionalGenericConverter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Properties.class.equals(sourceType.getObjectType()) &amp;&amp; String.class.equals(targetType.getObjectType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> ConvertiblePair(Properties.class, String.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">        Properties properties = (Properties) source;</span><br><span class="line">        StringBuilder textBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">            textBuilder.append(entry.getKey()).append(<span class="string">&quot;=&quot;</span>).append(entry.getValue()).append(System.getProperty(<span class="string">&quot;line.separator&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> textBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:util=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&#x27;</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/util</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;user&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;id&quot;</span> value=<span class="string">&quot;1&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;吉永超&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;context&quot;</span>&gt; &lt;!-- Properties类型 --&gt;</span><br><span class="line">            &lt;value&gt;</span><br><span class="line">                id = <span class="number">1</span></span><br><span class="line">                name = 吉永超</span><br><span class="line">            &lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;contextAsText&quot;</span> ref=<span class="string">&quot;context&quot;</span>/&gt; &lt;!--properties类型要转成String --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;util:properties id=<span class="string">&quot;context&quot;</span>&gt;</span><br><span class="line">        &lt;prop key=<span class="string">&quot;id&quot;</span>&gt;<span class="number">1</span>&lt;/prop&gt;</span><br><span class="line">        &lt;prop key=<span class="string">&quot;name&quot;</span>&gt;jiyongchao&lt;/prop&gt;</span><br><span class="line">    &lt;/util:properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 声明ConversionServiceFactoryBean--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;conversionService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;converters&quot;</span> value=<span class="string">&quot;org.jyc.thinking.in.spring.conversion.PropertiesToStringConverter&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要格外注意的是，在注册ConversionServiceFactoryBean的时候，一定要指定名称为conversionService，因为在beanFactory进行查找的时候，会根据名称和类型共同查找，名称固定为conversionService。</p>
</blockquote>
<h2 id="统一类型转换服务"><a class="markdownIt-Anchor" href="#统一类型转换服务"></a> 统一类型转换服务</h2>
<p>org.springframework.core.convert.ConversionService说明：</p>
<table>
<thead>
<tr>
<th>实现类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>GenericConversionService</td>
<td>通用ConversionService模板实现，不内置转化器实现</td>
</tr>
<tr>
<td>DefaultConversionService</td>
<td>基础ConversionService实现，内置常用转化器实现</td>
</tr>
<tr>
<td>FormattingConversionService</td>
<td>通用Formatter + GenericConversionService实现，不内置转化器和Formatter实现</td>
</tr>
<tr>
<td>DefaultFormattingConversionService</td>
<td>DefaultConversionService + 格式化 实现（如：JSR-354 Money &amp; Currency，JSR-310 Date-Time）</td>
</tr>
</tbody>
</table>
<h2 id="conversionservice作为依赖"><a class="markdownIt-Anchor" href="#conversionservice作为依赖"></a> ConversionService作为依赖</h2>
<p>类型转换器底层接口 - org.springframework.beans.TypeConverter</p>
<ul>
<li>起始版本：Spring 2.0</li>
<li>核心方法 - convertlfNecessary重载方法</li>
<li>抽象实现 - org.springframework.beans.TypeConverterSupport</li>
<li>简单实现 - org.springframework.beans.SimpleTypeConverter</li>
</ul>
<p>类型转换器底层抽象实现 - org.springframework.beans.TypeConverterSupport</p>
<ul>
<li>实现接口 - org.springframework.beans.TypeConverter</li>
<li>扩展实现 - org.springframework.beans.PropertyEditorRegistrySupport</li>
<li>委派实现 - org.springframework.beans.TypeConverterDelegate</li>
</ul>
<p>类型转换器底层委派实现 - org.springframework.beans.TypeConverterDelegate</p>
<ul>
<li>构造来源 - org.springframework.beans.AbstractNestablePropertyAccessor实现
<ul>
<li>org.springframework.beans.BeanWrapperImpl</li>
</ul>
</li>
<li>依赖 - java.beans.PropertyEditor实现
<ul>
<li>默认内建时间 - org.springframework.beans.PropertyEditorRegistrySupport#registerDefaultEditors</li>
</ul>
</li>
<li>可选依赖 - org.springframework.core.convert.ConversionService实现</li>
</ul>
<p>整体的流程关键节点如下：</p>
<blockquote>
<p>AbstractApplicationContext -&gt; “conversionService” ConversionService Bean -&gt; configurableBeanFactory#setConversionService(conversionService) -&gt; AbstractAutowireCapableBeanFactory#instantiateBean -&gt; AbstractBeanFactory#getConversionServicee -&gt; BeanDefinition -&gt; BeanWrapper -&gt; 属性转换(数据来源：PropertyValues) -&gt; setPropertyValues(PropertyValues) -&gt; TypeConvert#convertIfNecessnary -&gt; TypeConverterDelegate -&gt; PropertyEditor or ConversionService</p>
</blockquote>
<h2 id="面试题-15"><a class="markdownIt-Anchor" href="#面试题-15"></a> 面试题</h2>
<h3 id="spring类型转换实现有哪些"><a class="markdownIt-Anchor" href="#spring类型转换实现有哪些"></a> Spring类型转换实现有哪些？</h3>
<ol>
<li>基于JavaBeans PropertyEditor接口实现</li>
<li>Spring 3.0+通用类型转换实现</li>
</ol>
<h3 id="spring类型转换器接口有哪些"><a class="markdownIt-Anchor" href="#spring类型转换器接口有哪些"></a> Spring类型转换器接口有哪些？</h3>
<ul>
<li>类型转换接口 - org.springframework.core.convert.converter.Converter</li>
<li>通用类型转换接口 - org.springframework.core.convert.converter.GenericConverter</li>
<li>类型条件接口 - org.springframework.core.convert.converter.ConditionalConverter</li>
<li>综合类型转换接口 - org.springframework.core.convert.converter.ConditionalGenericConverter</li>
</ul>
<h3 id="typedescriptor是如何处理泛型"><a class="markdownIt-Anchor" href="#typedescriptor是如何处理泛型"></a> TypeDescriptor是如何处理泛型？</h3>
<p>// …</p>
<h1 id="spring-泛型"><a class="markdownIt-Anchor" href="#spring-泛型"></a> Spring 泛型</h1>
<h2 id="java泛型基础"><a class="markdownIt-Anchor" href="#java泛型基础"></a> Java泛型基础</h2>
<p>泛型类型：</p>
<ul>
<li>泛型类型是在类型上参数化的泛型类或接口</li>
</ul>
<p>泛型的使用场景：</p>
<ul>
<li>编译时强制类型检查</li>
<li>避免类型强转</li>
<li>实现通用算法</li>
</ul>
<p>泛型类型擦写：</p>
<ul>
<li>泛型被引入到Java语言中，以便在编译时提供更严格的类型检查并支持泛型编程。类型擦除确保不会为参数化类型创建新类；因此，泛型不会产生运行时开销。为了实现泛型，编译器将类型擦除应用于：
<ul>
<li>将泛型类型中的所有类型参数替换为其边界，如果类型参数是无边界的，则将其替换为&quot;Object&quot;。因为，生成的字节码只包含普通类、接口和方法</li>
<li>必要时插入类型转换以保持类型安全</li>
<li>生成桥方法以保留扩展泛型类中的多态性</li>
</ul>
</li>
</ul>
<h2 id="java-5类型接口"><a class="markdownIt-Anchor" href="#java-5类型接口"></a> Java 5类型接口</h2>
<p>Java 5类型接口 - java.lang.reflect.Type</p>
<table>
<thead>
<tr>
<th>派生类或接口</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>java.lang.Class</td>
<td>Java类API，如java.lang.String</td>
</tr>
<tr>
<td>java.lang.reflect.GenericArrayType</td>
<td>泛型数组类型</td>
</tr>
<tr>
<td>java.lang.reflect.ParameterizedType</td>
<td>泛型参数类型</td>
</tr>
<tr>
<td>java.lang.reflect.TypeVariable</td>
<td>泛型类型变量，如Collection<E> 中的E</td>
</tr>
<tr>
<td>java.lang.reflect.WildcardType</td>
<td>泛型统配类型</td>
</tr>
</tbody>
</table>
<p>Java泛型反射API：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>API</th>
</tr>
</thead>
<tbody>
<tr>
<td>泛型信息</td>
<td>java.lang.Class#getGenericInfo</td>
</tr>
<tr>
<td>泛型参数</td>
<td>java.lang.reflect#ParameterizedType</td>
</tr>
<tr>
<td>泛型父类</td>
<td>java.lang.Class#getGenericSuperclass</td>
</tr>
<tr>
<td>泛型接口</td>
<td>java.lang.Class#getGenericInterfaces</td>
</tr>
<tr>
<td>泛型声明</td>
<td>java.lang.reflect#GenericDeclaration</td>
</tr>
</tbody>
</table>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericAPIDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原生类型 int long float</span></span><br><span class="line">        Class intClass = <span class="keyword">int</span>.class;</span><br><span class="line">        <span class="comment">// 数组类型 int[],Object[]</span></span><br><span class="line">        Class objectArrayClass = Object[].class;</span><br><span class="line">        <span class="comment">// 原始类型 raw types: java.lang.String</span></span><br><span class="line">        Class rawClass = String.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 泛型参数类型 parameterized Type</span></span><br><span class="line">        ParameterizedType parameterizedType = (ParameterizedType) ArrayList.class.getGenericSuperclass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// parameterizedType.getRawType() = java.util.AbstractList;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//泛型类型变量 Type Variable</span></span><br><span class="line"></span><br><span class="line">        System.out.println(parameterizedType.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &lt;E&gt;</span></span><br><span class="line">        Type[] typeVariables = parameterizedType.getActualTypeArguments();</span><br><span class="line"><span class="comment">//        Stream.of(parameterizedType.getActualTypeArguments()).forEach(System.out::println);</span></span><br><span class="line">        Stream.of(typeVariables).map(TypeVariable.class::cast).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring泛型类型辅助类"><a class="markdownIt-Anchor" href="#spring泛型类型辅助类"></a> Spring泛型类型辅助类</h2>
<p>核心API - org.springframework.core.GenericTypeResolver</p>
<ul>
<li>
<p>版本支持[2.5.2,）</p>
</li>
<li>
<p>处理类型相关（Type）相关方法</p>
<ul>
<li>resolveReturnType</li>
<li>resolveType</li>
</ul>
</li>
<li>
<p>处理泛型参数类型（ParameterizedType）相关方法</p>
<ul>
<li>resolveReturnTypeArgument</li>
<li>resolveTypeArgument</li>
<li>resolveTypeArguments</li>
</ul>
</li>
<li>
<p>处理泛型类型变量（TypeVariable）相关方法</p>
<ul>
<li>getTypeVariableMap</li>
</ul>
</li>
</ul>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypeResolverDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String Comparable&lt;String&gt; 具体化</span></span><br><span class="line">        displayReturnTypeGenericInfo(GenericTypeResolverDemo.class, Comparable.class, <span class="string">&quot;getString&quot;</span>);</span><br><span class="line">        <span class="comment">// ArrayList&lt;Object&gt;是List泛型参数类型的具体化</span></span><br><span class="line">        displayReturnTypeGenericInfo(GenericTypeResolverDemo.class, List.class, <span class="string">&quot;getList&quot;</span>);</span><br><span class="line">        <span class="comment">// StringList也是List泛型类型的具体化</span></span><br><span class="line">        displayReturnTypeGenericInfo(GenericTypeResolverDemo.class, List.class, <span class="string">&quot;getStringList&quot;</span>);</span><br><span class="line">        <span class="comment">// 具备 ParameterizedType返回。否则null</span></span><br><span class="line">        <span class="comment">// TypeVariable</span></span><br><span class="line">        Map&lt;TypeVariable, Type&gt; typeVariableMap = GenericTypeResolver.getTypeVariableMap(StringList.class);</span><br><span class="line">        System.out.println(typeVariableMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringList <span class="title">getStringList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Object&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123; <span class="comment">// 泛型参数具体化（字节码有记录）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayReturnTypeGenericInfo</span><span class="params">(Class&lt;?&gt; containingClass, Class&lt;?&gt; generic, String methodName, Class... argumentTypes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Method method = containingClass.getMethod(methodName, argumentTypes);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; returnType = GenericTypeResolver.resolveReturnType(method, containingClass);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; returnTypeArgument = GenericTypeResolver.resolveReturnTypeArgument(method, generic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常规类作为方法返回值</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;GenericTypeResolver.resolveReturnType(%s,%s) = %s\n&quot;</span>, methodName, containingClass.getSimpleName(), returnType);</span><br><span class="line">        <span class="comment">// 常规类型不具备泛型参数类型List&lt;E&gt;</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;GenericTypeResolver.resolveReturnTypeArgument(%s,%s) = %s\n&quot;</span>, methodName, containingClass.getSimpleName(), returnTypeArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt; </span>&#123; <span class="comment">// 泛型参数具体化（字节码有记录）</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型集合类型辅助类"><a class="markdownIt-Anchor" href="#泛型集合类型辅助类"></a> 泛型集合类型辅助类</h2>
<p>核心API - org.springframework.core.GenericCollectionTypeSolver</p>
<ul>
<li>
<p>版本支持：[2.0,4.3]</p>
<ul>
<li>替换实现：org.springframework.core.ResolvableType</li>
</ul>
</li>
<li>
<p>处理Collection相关</p>
<ul>
<li>getCollection*Type</li>
<li>getMapValue*Type</li>
</ul>
<blockquote>
<p>GenericCollectionTypeSolver在高版本的Spring中已经移除，建议使用它的替换实现ResolvableType。</p>
</blockquote>
</li>
</ul>
<h2 id="spring方法参数封装"><a class="markdownIt-Anchor" href="#spring方法参数封装"></a> Spring方法参数封装</h2>
<p>核心API - org.springframework.core.MethodParameter</p>
<ul>
<li>
<p>起始版本：[2.0,)</p>
</li>
<li>
<p>元信息</p>
<ul>
<li>关联的方法 - Method</li>
<li>关联的构造器 - Constuctor</li>
<li>构造器或方法参数索引 - parameterIndex</li>
<li>构造器或方法参数类型 - parameterType</li>
<li>构造器或方法参数泛型类型 - genericParameterType</li>
<li>构造器或方法参数名称 - parameterName</li>
<li>所在的类 - containingClass</li>
</ul>
<blockquote>
<p>parameterName是java8之后才存在。</p>
</blockquote>
</li>
</ul>
<h2 id="resolvabletype"><a class="markdownIt-Anchor" href="#resolvabletype"></a> ResolvableType</h2>
<p>核心API - org.springframework.core.ResolvableType</p>
<ul>
<li>起始版本：[4.0,)</li>
<li>扮演角色：GenericTypeResolver和GenericCollectionTypeResolver替代者</li>
<li>工厂方法：for*方法</li>
<li>转换方法：as*方法</li>
<li>处理方法：resolve*方法</li>
</ul>
<p>官方给出的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;Integer, List&lt;String&gt;&gt; myMap;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ResolvableType t = ResolvableType.forField(getClass().getDeclaredField(<span class="string">&quot;myMap&quot;</span>));</span><br><span class="line">      t.getSuperType(); <span class="comment">// AbstractMap&lt;Integer, List&lt;String&gt;&gt;</span></span><br><span class="line">      t.asMap(); <span class="comment">// Map&lt;Integer, List&lt;String&gt;&gt;</span></span><br><span class="line">      t.getGeneric(<span class="number">0</span>).resolve(); <span class="comment">// Integer</span></span><br><span class="line">      t.getGeneric(<span class="number">1</span>).resolve(); <span class="comment">// List</span></span><br><span class="line">      t.getGeneric(<span class="number">1</span>); <span class="comment">// List&lt;String&gt;</span></span><br><span class="line">      t.resolveGeneric(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// String</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们来使用相关的API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResolvableTypeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 工厂创建</span></span><br><span class="line">        <span class="comment">// StringList &lt;- ArrayList &lt;- AbstractList &lt;- list</span></span><br><span class="line">        ResolvableType resolvableType = ResolvableType.forClass(GenericTypeResolverDemo.StringList.class);</span><br><span class="line">        resolvableType.getSuperType(); <span class="comment">//ArrayList</span></span><br><span class="line">        resolvableType.getSuperType().getSuperType(); <span class="comment">// AbstractList</span></span><br><span class="line"></span><br><span class="line">        System.out.println(resolvableType.asCollection().resolve()); <span class="comment">//获取Raw Type</span></span><br><span class="line">        System.out.println(resolvableType.asCollection().resolveGeneric(<span class="number">0</span>)); <span class="comment">// 获取泛型参数类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ResolvableType也有两个局限性，第一，ResolvableType无法处理泛型擦写，第二，ResolvableType无法处理非具体化的ParameterizedType。</p>
</blockquote>
<h2 id="面试题-16"><a class="markdownIt-Anchor" href="#面试题-16"></a> 面试题</h2>
<h3 id="java泛型擦写是发生在编译时还是运行时"><a class="markdownIt-Anchor" href="#java泛型擦写是发生在编译时还是运行时"></a> Java泛型擦写是发生在编译时，还是运行时？</h3>
<p>运行时。</p>
<h3 id="请介绍java-5-type类型的派生类或接口"><a class="markdownIt-Anchor" href="#请介绍java-5-type类型的派生类或接口"></a> 请介绍Java 5 Type类型的派生类或接口?</h3>
<p>见Java5 类型接口</p>
<h3 id="请说明resolvabletype的设计优势"><a class="markdownIt-Anchor" href="#请说明resolvabletype的设计优势"></a> 请说明ResolvableType的设计优势</h3>
<ul>
<li>简化Java5 Type API开发，屏蔽复杂API的运用，如ParameterizedType</li>
<li>不变性设计（Immutability）</li>
<li>Fluent API设计（Builder模式），链式（流式）编程</li>
</ul>
<h1 id="spring-事件"><a class="markdownIt-Anchor" href="#spring-事件"></a> Spring 事件</h1>
<h2 id="java事件监听器编程模型"><a class="markdownIt-Anchor" href="#java事件监听器编程模型"></a> Java事件/监听器编程模型</h2>
<ul>
<li>设计模式 - 观察者模式扩展
<ul>
<li>可观者对象（消息发送者） - java.util.Observable</li>
<li>观察者 -  java.util.Observer</li>
</ul>
</li>
<li>标准化接口
<ul>
<li>事件对象 - java.util.EventObject</li>
<li>事件监听器 - java.util.EventListener</li>
</ul>
</li>
</ul>
<p>使用的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable observable = <span class="keyword">new</span> EventObservable();</span><br><span class="line">        <span class="comment">// 添加观察者（监听者）</span></span><br><span class="line">        observable.addObserver(<span class="keyword">new</span> EventObserver());</span><br><span class="line">        observable.notifyObservers(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EventObservable</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">            setChanged();</span><br><span class="line">            <span class="keyword">super</span>.notifyObservers(<span class="keyword">new</span> EventObject(arg));</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EventObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span>, <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object event)</span> </span>&#123;</span><br><span class="line">            EventObject eventObject = (EventObject) event;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到事件&quot;</span> + eventObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里由于Observable的setChanged是protected，所以需要实现子类，重写这个方法，并且为了更方便的操作，我们一般也会扩充notifyObservers的实现逻辑。</p>
</blockquote>
<h2 id="面向接口的事件监听器设计模式"><a class="markdownIt-Anchor" href="#面向接口的事件监听器设计模式"></a> 面向接口的事件/监听器设计模式</h2>
<p>事件/监听器场景举例</p>
<table>
<thead>
<tr>
<th>Java技术规范</th>
<th>事件接口</th>
<th>监听器接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>JavaBeans</td>
<td>java.beans.PropertyChangeEvent</td>
<td>java.beans.PropertyChangeListener</td>
</tr>
<tr>
<td>Java AWT</td>
<td>java.awt.event.MouseEvent</td>
<td>java.awt.event.MouseListener</td>
</tr>
<tr>
<td>Java Swing</td>
<td>javax.swing.event.MenuEvent</td>
<td>javax.swing.event.MenuListener</td>
</tr>
<tr>
<td>Java Preference</td>
<td>java.util.prefs.PreferenceChangeEvent</td>
<td>java.util.prefs.PreferenceChangeListener</td>
</tr>
</tbody>
</table>
<h2 id="面向注解的事件监听器设计模式"><a class="markdownIt-Anchor" href="#面向注解的事件监听器设计模式"></a> 面向注解的事件/监听器设计模式</h2>
<p>事件/监听器注解场景举例</p>
<table>
<thead>
<tr>
<th>Java 技术规范</th>
<th>事件注解</th>
<th>监听器注解</th>
</tr>
</thead>
<tbody>
<tr>
<td>Servlet 3.0+</td>
<td></td>
<td>@javax.servlet.annotation.WebListener</td>
</tr>
<tr>
<td>JPA 1.0+</td>
<td>@javax.persistence.PostPersist</td>
<td></td>
</tr>
<tr>
<td>Java Common</td>
<td>@PostConstruct</td>
<td></td>
</tr>
<tr>
<td>EJB 3.0+</td>
<td>@javax.ejb.PrePassivate</td>
<td></td>
</tr>
<tr>
<td>JSF 2.0+</td>
<td>@javax.faces.event.ListenerFor</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="spring标准事件-applicationevent"><a class="markdownIt-Anchor" href="#spring标准事件-applicationevent"></a> Spring标准事件 ApplicationEvent</h2>
<p>Java标准事件 java.util.EventObject扩展：</p>
<ul>
<li>扩展特性：事件发生事件戳</li>
</ul>
<p>Spring应用上下文ApplicationEvent扩展 - ApplicationContextEvent</p>
<ul>
<li>Spring应用上下文（ApplicationContext作为事件源）</li>
<li>具体实现：
<ul>
<li>org.springframework.context.event.ContextClosedEvent</li>
<li>org.springframework.context.event.ContextRefreshedEvent</li>
<li>org.springframework.context.event.ContextStartedEvent</li>
<li>org.springframework.context.event.ContextStoppedEvent</li>
</ul>
</li>
</ul>
<h2 id="基于接口的spring事件监听器"><a class="markdownIt-Anchor" href="#基于接口的spring事件监听器"></a> 基于接口的Spring事件监听器</h2>
<p>Java标准事件监听器java.util.EventListener扩展</p>
<ul>
<li>扩展接口 - org.springframework.context.ApplicationListener</li>
<li>设计特点：单一类型事件处理</li>
<li>处理方法：onApplicationEvent(ApplicationEvent event);</li>
<li>事件类型：org.springframework.context.ApplicationEvent</li>
</ul>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationListenerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line">        <span class="comment">// 向Spring应用上下文注册事件</span></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> ApplicationListener&lt;ApplicationEvent&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到Spring事件： &quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        context.refresh();</span><br><span class="line">        context.start();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于注解的spring事件监听器"><a class="markdownIt-Anchor" href="#基于注解的spring事件监听器"></a> 基于注解的Spring事件监听器</h2>
<p>Spring注解 - @org.springframework.context.event.EventListener</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>设计特点</td>
<td>支持多ApplicationEvent类型，无需接口约束</td>
</tr>
<tr>
<td>注解目标</td>
<td>方法</td>
</tr>
<tr>
<td>是否支持异步执行</td>
<td>支持</td>
</tr>
<tr>
<td>是否支持泛型类型事件</td>
<td>支持</td>
</tr>
<tr>
<td>是指支持顺序控制</td>
<td>支持，配合@Order注解控制</td>
</tr>
</tbody>
</table>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationListenerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        GenericApplicationContext context = new GenericApplicationContext();</span></span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 将引导类作为配置类</span></span><br><span class="line">        context.register(ApplicationListenerDemo.class);</span><br><span class="line">        <span class="comment">// 方法一：基于Spring接口：向Spring应用上下文注册事件</span></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> ApplicationListener&lt;ApplicationEvent&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">                println(<span class="string">&quot;ApplicationListene接收到Spring事件： &quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 方法二：基于Spring注解@EventListener</span></span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line">        context.start();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Order(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">       println(<span class="string">&quot;@EventListener1接收到Spring事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Order(2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent1</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        println(<span class="string">&quot;@EventListener2接收到Spring事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextStartedEvent event)</span> </span>&#123;</span><br><span class="line">        println(<span class="string">&quot;@EventListener接收到Spring事件（异步）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">       println(<span class="string">&quot;@EventListener接收到Spring事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object printable)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[线程：%s] : %s\n&quot;</span>, Thread.currentThread(), printable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注册spring-applicationlistener"><a class="markdownIt-Anchor" href="#注册spring-applicationlistener"></a> 注册Spring ApplicationListener</h2>
<ol>
<li>方法一：ApplicationListener作为Spring Bean注册</li>
<li>方法二：通过ConfigurableApplicationContext API注册</li>
</ol>
<p>第二种方式在之前我们已经讨论过了，这里第一种方式也比较容易：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">           println(<span class="string">&quot;MyApplicationListener接收到Spring事件&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>然后将MyApplicationListener标注为Spring Bean即可。</p>
<h2 id="spring事件发布器"><a class="markdownIt-Anchor" href="#spring事件发布器"></a> Spring事件发布器</h2>
<ul>
<li>方法一：通过ApplicationEventPublisher发布Spring事件
<ul>
<li>获取ApplicationEventPublisher
<ul>
<li>依赖注入</li>
</ul>
</li>
</ul>
</li>
<li>方法二：通过ApplicationEventPublisher发布Spring事件
<ul>
<li>获取ApplicationEventMulticaster
<ul>
<li>依赖注入</li>
<li>依赖查找</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>使用ApplicationListenerDemo实现ApplicationEventPublisherAware接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">    applicationEventPublisher.publishEvent(<span class="keyword">new</span> ApplicationEvent(<span class="string">&quot;hello world&quot;</span>) &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    applicationEventPublisher.publishEvent(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring层次性上下文事件传播"><a class="markdownIt-Anchor" href="#spring层次性上下文事件传播"></a> Spring层次性上下文事件传播</h2>
<ul>
<li>
<p>发生说明</p>
<p>当Spring应用出现多层次Spring应用上下文（ApplicationContext）时，如Spring WebMVC、Spring Boot或Spring Cloud场景下，由子ApplicationContext发起Spring事件可能会传递到其Parent ApplicationContext（直到Root）的过程。</p>
</li>
<li>
<p>如何避免</p>
<p>定位Spring事件源（ApplicationContext）进行过滤处理</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HierarchicalSpringEventPropagateDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建parent Spring应用上下文</span></span><br><span class="line">        AnnotationConfigApplicationContext parentContent = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 2.创建current Spring应用上下文</span></span><br><span class="line">        parentContent.setId(<span class="string">&quot;parent-context&quot;</span>);</span><br><span class="line">        parentContent.register(MyListener.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.current -&gt; parent</span></span><br><span class="line">        AnnotationConfigApplicationContext currentContent = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        parentContent.setId(<span class="string">&quot;current-context&quot;</span>);</span><br><span class="line">        currentContent.setParent(parentContent);</span><br><span class="line">        currentContent.register(MyListener.class);</span><br><span class="line"></span><br><span class="line">        parentContent.refresh();</span><br><span class="line">        <span class="comment">// 这里会触发两次，因为会出发父应用上下文的事件</span></span><br><span class="line">        currentContent.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里的顺序，不能颠倒</span></span><br><span class="line">        currentContent.close();</span><br><span class="line">        parentContent.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationContextEvent</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 这里必须是静态字段</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;ApplicationEvent&gt; processedEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationContextEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (processedEvents.add(event)) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;监听到 Spring应用上下文[ID：%s]事件： %s\n&quot;</span>, event.getApplicationContext().getId(), event.getClass().getSimpleName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring内建事件"><a class="markdownIt-Anchor" href="#spring内建事件"></a> Spring内建事件</h2>
<p>ApplicationContextEvent派生事件：</p>
<ul>
<li>ContextRefreshedEvent：Spring应用上下文就绪事件</li>
<li>ContextStartedEvent：Spring应用上下文启动事件</li>
<li>ContextStoppedEvent：Spring应用上下文停止事件</li>
<li>ContextClosedEvent：Spring应用上下文关闭事件</li>
</ul>
<h2 id="payload事件"><a class="markdownIt-Anchor" href="#payload事件"></a> Payload事件</h2>
<p>Spring Payload事件 - org.springframework.context.PayloadApplicationEvent</p>
<ul>
<li>使用场景：简化Spring事件发送，关注事件源主体</li>
<li>发送方法：ApplicationEventPublisher#publishEvent(Object event)</li>
</ul>
<blockquote>
<p>这个事件使用的很少，并且对于泛型的处理还存在Bug，可以使用ApplicationEventPublisher#publishEvent方法。</p>
</blockquote>
<h2 id="自定义spring事件"><a class="markdownIt-Anchor" href="#自定义spring事件"></a> 自定义Spring事件</h2>
<ol>
<li>扩展 org.springframework.context.ApplicationEvent</li>
<li>实现 org.springframework.context.ApplicationListener</li>
<li>注册 org.springframework.context.ApplicationListener</li>
</ol>
<p>我们来实现一个自定义的Spring事件，第一步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpringEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySpringEvent</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String) <span class="keyword">super</span>.getSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，实现自定义的事件监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpringEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MySpringEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MySpringEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[线程：%s] :监听到事件 %s\n&quot;</span>, Thread.currentThread().getName(), event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步，注册自定义事件监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedSpringEventDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> MySpringEventListener());</span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MySpringEvent(<span class="string">&quot;hello,world&quot;</span>));</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="依赖注入applicationeventpublisher"><a class="markdownIt-Anchor" href="#依赖注入applicationeventpublisher"></a> 依赖注入ApplicationEventPublisher</h2>
<ol>
<li>通过ApplicationEventPublisherAware回调接口</li>
<li>通过@Autowired ApplicationEventPublisher</li>
</ol>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectingApplicationEventPublisherDemo</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// #3</span></span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> MySpringEvent(<span class="string">&quot;the event from @Autowired ApplicationEventPublisher&quot;</span>));</span><br><span class="line">        <span class="comment">// #4</span></span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> MySpringEvent(<span class="string">&quot;the event from @Autowired ApplicationContext&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.register(InjectingApplicationEventPublisherDemo.class);</span><br><span class="line"></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> MySpringEventListener());</span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> MySpringEvent(<span class="string">&quot;the event from ApplicationEventPublisher&quot;</span>)); <span class="comment">//#1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123; <span class="comment">//#2</span></span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="string">&quot;the event from ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="依赖查找applicationeventmulticaster"><a class="markdownIt-Anchor" href="#依赖查找applicationeventmulticaster"></a> 依赖查找ApplicationEventMulticaster</h2>
<p>查找条件：</p>
<ul>
<li>Bean名称：“applicationEventMulticaster”</li>
<li>Bean类型：org.springframework.context.event.ApplicationEventMulticaster</li>
</ul>
<p>依赖查找的细节可以在AbstractApplicationContext#initApplicationEventMulticaster中看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">					beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 如果不存在会直接new一个，也就是说初始化之后，ApplicationEventMulticaster不会为空</span></span><br><span class="line">			<span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">						<span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="applicationeventpublisher底层实现"><a class="markdownIt-Anchor" href="#applicationeventpublisher底层实现"></a> ApplicationEventPublisher底层实现</h2>
<p>底层实现：</p>
<ul>
<li>接口：org.springframework.context.event.ApplicationEventMulticaster</li>
<li>抽象类：org.springframework.context.event.AbstractApplicationEventMulticaster</li>
<li>实现类：org.springframework.context.event.SimpleApplicationEventMulticaster</li>
</ul>
<blockquote>
<p>早期的Spring，ApplicationEventPublisherAware与BeanPostProcessor不能同时使用，后面的版本采用了事件回放的机制修复了这个BUG。</p>
</blockquote>
<h2 id="同步和异步spring事件广播"><a class="markdownIt-Anchor" href="#同步和异步spring事件广播"></a> 同步和异步Spring事件广播</h2>
<p>基本实现类 - org.springframework.context.event.SimpleApplicationEventMulticaster</p>
<ul>
<li>模式切换： setTaskExecutor(Executor taskExecutor)
<ul>
<li>默认模式：同步</li>
<li>异步模式：如java.util.concurrent.ThreadPoolExecutor</li>
</ul>
</li>
<li>设计缺陷：非基于接口契约编程</li>
</ul>
<p>基于编码的同步和异步事件广播示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncEventHandlerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> MySpringEventListener());</span><br><span class="line"></span><br><span class="line">        context.refresh(); <span class="comment">// 初始化 ApplicationEventMulticaster</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依赖查找 ApplicationEventMulticaster</span></span><br><span class="line">        ApplicationEventMulticaster applicationEventMulticaster = context.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (applicationEventMulticaster <span class="keyword">instanceof</span> SimpleApplicationEventMulticaster) &#123;</span><br><span class="line">            SimpleApplicationEventMulticaster simpleApplicationEventMulticaster = (SimpleApplicationEventMulticaster) applicationEventMulticaster;</span><br><span class="line">            <span class="comment">//切换 taskExecutor</span></span><br><span class="line">            ExecutorService taskExecutor = Executors.newSingleThreadExecutor(<span class="keyword">new</span> CustomizableThreadFactory(<span class="string">&quot;my-spring-event-thread-pool&quot;</span>));</span><br><span class="line">            <span class="comment">// 同步 -&gt; 异步</span></span><br><span class="line">            simpleApplicationEventMulticaster.setTaskExecutor(taskExecutor);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加ContextClosedEvent事件处理</span></span><br><span class="line">            applicationEventMulticaster.addApplicationListener(<span class="keyword">new</span> ApplicationListener&lt;ContextClosedEvent&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!taskExecutor.isShutdown()) &#123;</span><br><span class="line">                        taskExecutor.shutdown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MySpringEvent(<span class="string">&quot;hello,world&quot;</span>));</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了这种编码的方式，还可以通过注解的方式。</p>
<p>基于注解 - org.springframework.context.event.EventListener</p>
<ul>
<li>模式切换
<ul>
<li>默认模式：同步</li>
<li>异步模式：标注@org.springframework.scheduling.annotation.Async</li>
</ul>
</li>
<li>实现限制：无法直接实现同步/异步动态切换</li>
</ul>
<p>基于注解方式的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">// 激活Spring异步特性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedAsyncEventHandlerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.register(AnnotatedAsyncEventHandlerDemo.class);</span><br><span class="line"></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> MySpringEventListener());</span><br><span class="line"></span><br><span class="line">        context.refresh(); <span class="comment">// 初始化 ApplicationEventMulticaster</span></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MySpringEvent(<span class="string">&quot;hello,world&quot;</span>));</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(MySpringEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[线程：%s] : %s\n&quot;</span>, Thread.currentThread().getName(), event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService taskExecutor = newSingleThreadExecutor(<span class="keyword">new</span> CustomizableThreadFactory(<span class="string">&quot;my-spring-event-thread-pool-a&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring事件异常处理"><a class="markdownIt-Anchor" href="#spring事件异常处理"></a> Spring事件异常处理</h2>
<p>Spring3.0错误处理接口 - org.springframework.util.ErrorHandler</p>
<p>使用场景：</p>
<ul>
<li>Spring事件（Events）
<ul>
<li>SimpleApplicationEventMulticaster Spring 4.1开始支持</li>
</ul>
</li>
<li>Spring本地调度（Scheduling）
<ul>
<li>org.springframework.scheduling.concurrent.ConcurrentTaskScheduler</li>
<li>org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler</li>
</ul>
</li>
</ul>
<p>实现的核心代码在SimpleApplicationEventMulticaster#invokeListener：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">		ErrorHandler errorHandler = getErrorHandler();</span><br><span class="line">		<span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				doInvokeListener(listener, event);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">				errorHandler.handleError(err);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			doInvokeListener(listener, event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring事件监听实现原理"><a class="markdownIt-Anchor" href="#spring事件监听实现原理"></a> Spring事件/监听实现原理</h2>
<p>核心类 - org.springframework.context.event.SimpleApplicationEventMulticaster</p>
<ul>
<li>设计模式：观察者模式扩展
<ul>
<li>被观察者 - org.springframework.context.ApplicationListener
<ul>
<li>API添加</li>
<li>依赖查找</li>
</ul>
</li>
<li>通知对象 - org.springframework.context.ApplicationEvent</li>
</ul>
</li>
<li>执行模式：同步/异步</li>
<li>异常处理：org.springframework.util.ErrorHandler</li>
<li>泛型处理：org.springframework.core.ResolvableType</li>
</ul>
<blockquote>
<p>监听事件的时候，Spring还会处理ApplicationEvent的子孙类，包含所有层次的事件。</p>
</blockquote>
<h2 id="springboot事件"><a class="markdownIt-Anchor" href="#springboot事件"></a> SpringBoot事件</h2>
<p>SpringBoot事件</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>发生时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>ApplicationStartingEvent</td>
<td>当SpringBoot应用已启动时</td>
</tr>
<tr>
<td>ApplicationStartedEvent</td>
<td>当SpringBoot应用已启动时</td>
</tr>
<tr>
<td>ApplicationEnvironmentPreparedEvent</td>
<td>当SpringBoot Environment实例已准备时</td>
</tr>
<tr>
<td>ApplicationPreparedEvent</td>
<td>当SpringBoot应用预备时</td>
</tr>
<tr>
<td>ApplicationReadyEvent</td>
<td>当SpringBoot应用完全可用时</td>
</tr>
<tr>
<td>ApplicationFailedEvent</td>
<td>当SpringBoot应用启动失败时</td>
</tr>
</tbody>
</table>
<p>SpringCloud事件</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>发生时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>EnvironmentChangeEvent</td>
<td>当Environment示例配置属性发生变化时</td>
</tr>
<tr>
<td>HeartbeatEvent</td>
<td>当DiscoveryClient客户端发送心跳时</td>
</tr>
<tr>
<td>InstancePreRegisteredEvent</td>
<td>当服务实例注册前</td>
</tr>
<tr>
<td>InstanceRegisteredEvent</td>
<td>当服务实例注册后</td>
</tr>
<tr>
<td>RefreshEvent</td>
<td>当RefreshEndpoint被调用时</td>
</tr>
<tr>
<td>RefreshScopedRefreshedEvent</td>
<td>当Refresh Scope Bean刷新后</td>
</tr>
</tbody>
</table>
<h2 id="面试题-17"><a class="markdownIt-Anchor" href="#面试题-17"></a> 面试题</h2>
<h3 id="spring事件核心接口组件"><a class="markdownIt-Anchor" href="#spring事件核心接口组件"></a> Spring事件核心接口/组件？</h3>
<ul>
<li>Spring事件 - org.springframework.context.ApplicationEvent</li>
<li>Spring事件监听器 -  org.springframework.context.ApplicationListener</li>
<li>Spring事件发布器 - org.springframework.context.ApplicationEventPublisher</li>
<li>Spring事件广播器 - org.springframework.context.event.ApplicationEventMulticaster</li>
</ul>
<h2 id="spring同步和异步事件处理的使用场景"><a class="markdownIt-Anchor" href="#spring同步和异步事件处理的使用场景"></a> Spring同步和异步事件处理的使用场景？</h2>
<ul>
<li>Spring同步事件 - 绝大部分Spring使用场景，如ContextRefreshedEvent</li>
<li>Spring异步事件 - 主要  @EventListener与@Async配合，实现异步处理，不阻塞主线程，比如长时间的数据计算任务等。不要轻易调整SimpleApplicationEventMulticaster中关联的taskExecutor对象，除非使用者非常了解Spring事件机制，否则容易出现异常行为。</li>
</ul>
<h2 id="eventlistener的工作原理"><a class="markdownIt-Anchor" href="#eventlistener的工作原理"></a> @EventListener的工作原理</h2>
<p>// …</p>
<h1 id="spring-注解驱动"><a class="markdownIt-Anchor" href="#spring-注解驱动"></a> Spring 注解驱动</h1>
<p>Spring注解驱动的编程发展的大概历程：</p>
<ol>
<li>注解驱动的启蒙时代：Spring Framework 1.x</li>
<li>注解驱动的过渡时代：Spring Framework 2.x</li>
<li>注解驱动的黄金时代：Spring Framework 3.x</li>
<li>注解驱动的完善时代：Spring Framework 4.x</li>
<li>注解驱动的当下时代：Spring Framework 5.x</li>
</ol>
<h2 id="spring核心注解场景分类"><a class="markdownIt-Anchor" href="#spring核心注解场景分类"></a> Spring核心注解场景分类</h2>
<p>Spring模式注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Repository</td>
<td>数据仓库模式注解</td>
<td>2.0</td>
</tr>
<tr>
<td>@Component</td>
<td>通用组件模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Service</td>
<td>服务模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Controller</td>
<td>Web控制器模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Configuration</td>
<td>配置类模式注解</td>
<td>3.0</td>
</tr>
</tbody>
</table>
<p>装配注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ImportResource</td>
<td>替换XML元素<import></td>
<td>2.5</td>
</tr>
<tr>
<td>@Import</td>
<td>导入Configuration类</td>
<td>2.5</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>扫描指定package下标注Spring模式注解的类</td>
<td>3.1</td>
</tr>
</tbody>
</table>
<p>依赖注入注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Autowired</td>
<td>Bean依赖注入，支持多种依赖查找方式</td>
<td>2.5</td>
</tr>
<tr>
<td>@Qualifer</td>
<td>细粒度的@Autowired依赖查找</td>
<td>2.5</td>
</tr>
</tbody>
</table>
<h2 id="spring注解编程模型"><a class="markdownIt-Anchor" href="#spring注解编程模型"></a> Spring注解编程模型</h2>
<p>编程模型概览：</p>
<ul>
<li>元注解（Meta-Annotations）</li>
<li>Spring模式注解（Stereotype Annotations）</li>
<li>Spring组合注解（Composed Annotations）</li>
<li>Spring注解属性别名和覆盖（Attribute Aliases and Overrides）</li>
</ul>
<h2 id="spring元注解"><a class="markdownIt-Anchor" href="#spring元注解"></a> Spring元注解</h2>
<p>除了直接使用JDK 定义好的注解，我们还可以自定义注解，在JDK 1.5中提供了4个标准的用来对注解类型进行注解的注解类，我们称之为 meta-annotation（元注解），他们分别是：</p>
<ul>
<li>@Target</li>
<li>@Retention</li>
<li>@Documented</li>
<li>@Inherited</li>
</ul>
<p>Target注解的作用是描述注解的使用范围。Reteniton注解的作用是，描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时）。Documented注解的作用是，描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。Inherited注解的作用是，使被它修饰的注解具有继承性（如果某个类使用了被@Inherited修饰的注解，则其子类将自动具有该注解）。</p>
<p>除了以上四种标准，还有我们之前提到过的@Repeatable。</p>
<h2 id="spring模式注解"><a class="markdownIt-Anchor" href="#spring模式注解"></a> Spring模式注解</h2>
<p>模式注解是一种注解，这种注解是用于去声明应用中扮演&quot;组件&quot;角色的类，@Component是一种通用的组件注解，标注这个注解的类会被Spring扫描。</p>
<blockquote>
<p>由于注解无法像接口或者类一样继承，因此只能采用使用注解描述注解的方式。</p>
</blockquote>
<p>@Component&quot;派生性&quot;原理：</p>
<ul>
<li>核心组件 - org.springframework.context.annotation.ClassPathBeanDefinitionScanner
<ul>
<li>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider</li>
</ul>
</li>
<li>资源处理 - org.springframework.core.io.support.ResourcePatternResolver</li>
<li>资源 - 类元信息
<ul>
<li>org.springframework.core.type.classreading.MetadataReaderFactory</li>
</ul>
</li>
<li>类元信息 - org.springframework.core.type.ClassMetadata
<ul>
<li>ASM实现 - org.springframework.core.type.classreading.ClassMetadataReadingVisitor</li>
<li>反射实现 - org.springframework.core.type.StandardAnnotationMetadata</li>
</ul>
</li>
<li>注解元信息 - org.springframework.core.type.AnnotationMetadata
<ul>
<li>ASM实现 - org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor</li>
<li>反射实现 - org.springframework.core.type.StandardAnnotationMetadata</li>
</ul>
</li>
</ul>
<p>我们定义一个测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个具有&quot;派生性&quot;的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 元注解，实现@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyComponent &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试是否生效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.jyc.thinking.in.spring.annotation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentScanDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.register(ComponentScanDemo.class);</span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 从Spring 4.0开始支持多层次@Component派生</span></span><br><span class="line">        TestClass bean = context.getBean(TestClass.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring-组合注解"><a class="markdownIt-Anchor" href="#spring-组合注解"></a> Spring 组合注解</h2>
<p>Spring组合注解（Composed Annotations）中的元注允许是Spring模式注解（Stereotype Annotation）与其他Spring功能性注解的任意组合。</p>
<p>比较典型的例子就是在SpringBoot场景中的SpringBootApplication：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring注解属性别名"><a class="markdownIt-Anchor" href="#spring注解属性别名"></a> Spring注解属性别名</h2>
<p>注解属性的别名实际上总共有两种，一种是显性的别名，一种是隐性的别名。</p>
<p>显性的别名比较容易理解，在@ComponentScan中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AliasFor(&quot;basePackages&quot;)</span></span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>此时basePackages和value就互为显性别名，下面是隐性别名的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyComponentScan &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐形别名,当被元标注的注解中的属性无法表达语义的时候，就需要额外增加attribute属性，如果没有attribute属性，就表示&quot;继承&quot; <span class="doctag">@AliasFor</span>中的注解的属性</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 是注解的一种&quot;多态&quot;，子注解提供了新的属性方法引用&quot;父&quot;（元）注解中的属性方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)</span></span><br><span class="line">    String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * scanBasePackages -&gt; <span class="doctag">@AliasFor</span> ComponentScan.basePackages.value(显性别名)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@AliasFor</span> ComponentScan.basePackages.value 传递隐形别名,而且这种方式是支持多层次的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @AliasFor(annotation = ComponentScan.class, attribute = &quot;value&quot;)</span></span><br><span class="line"><span class="comment">//    String[] scanBasePackages() default &#123;&#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring注解属性覆盖"><a class="markdownIt-Anchor" href="#spring注解属性覆盖"></a> Spring注解属性覆盖</h2>
<p>属性覆盖也有两种，一种是显性覆盖，一种是隐形覆盖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@MyComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyComponentScan2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = MyComponentScan.class, attribute = &quot;scanBasePackages&quot;)</span></span><br><span class="line">    String[] BasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐形覆盖</span></span><br><span class="line"><span class="comment">     * 在<span class="doctag">@MyComponentScan</span>中也有scanBasePackages属性，如果注解中存在同名的就会覆盖掉元标注注解中的属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显性覆盖</span></span><br><span class="line"><span class="comment">     * packages覆盖了scanBasePackages 同时覆盖了<span class="doctag">@MyComponentScan</span>.scanBasePackages</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;scanBasePackages&quot;)</span></span><br><span class="line">    String[] packages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring-enable模块驱动"><a class="markdownIt-Anchor" href="#spring-enable模块驱动"></a> Spring @Enable模块驱动</h2>
<p>@Eanable模块驱动是以@Enabke为前缀的注解驱动编程模型。所谓&quot;模块&quot;是指具备相同领域的功能组件的集合，组合形成一个独立的单元，比如Web MVC模块、AspectJ代理模块、Caching（缓存）模块、JMX（Java 扩展模块）、Async（异步处理）模块等。</p>
<p>举例说明：</p>
<ul>
<li>@EnableWebMvc</li>
<li>@EnableTranscationManagement</li>
<li>@EnableCaching</li>
<li>@EnableMBeanExport</li>
<li>@EnaleAsync</li>
</ul>
<p>除了框架内建的这些实现，我们还可以自定义@Eanable模块：</p>
<ol>
<li>驱动注解：@Enable***</li>
<li>导入注解：@Import具体实现</li>
<li>具体以下三种实现均可：
<ul>
<li>基于Configuration Class</li>
<li>基于@ImportSelector</li>
<li>基于@ImportBeanDefinitionRegistar接口实现</li>
</ul>
</li>
</ol>
<p>首先演示第一种基于配置类实现，首先定义一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(HelloWorldConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHelloWorld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后定义相对应的配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHelloWorld</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableModuleDemo</span> </span>&#123; <span class="comment">// 第一步：通过@Enable**命名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.register(EnableModuleDemo.class);</span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        String bean = context.getBean(<span class="string">&quot;helloWorld&quot;</span>, String.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种实现，首先定义ImportSelector的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;org.jyc.thinking.in.spring.annotation.HelloWorldConfiguration&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加到@Enable注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 第二步：通过@Import注解导入具体实现</span></span><br><span class="line"><span class="comment">//@Import(HelloWorldConfiguration.class)</span></span><br><span class="line"><span class="comment">// 方法二：通过@ImportSelector接口实现</span></span><br><span class="line"><span class="meta">@Import(HelloWorldImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHelloWorld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        AnnotatedGenericBeanDefinition beanDefinition = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(HelloWorldConfiguration.class);</span><br><span class="line">        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition,registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，添加到@Enable注解上面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 第二步：通过@Import注解导入具体实现</span></span><br><span class="line"><span class="comment">//@Import(HelloWorldConfiguration.class)</span></span><br><span class="line"><span class="comment">// 方法二：通过@ImportSelector接口实现</span></span><br><span class="line"><span class="comment">//@Import(HelloWorldImportSelector.class)</span></span><br><span class="line"><span class="comment">//方法三：通过 ImportBeanDefinitionRegistrar</span></span><br><span class="line"><span class="meta">@Import(HelloWorldImportBeanDefinitionRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHelloWorld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring条件注解"><a class="markdownIt-Anchor" href="#spring条件注解"></a> Spring条件注解</h2>
<p>Spring的条件注解主要有两种：</p>
<ul>
<li>基于配置条件注解 - @org.springframework.context.annotation.Profile
<ul>
<li>关联对象 - org.springframework.core.env.Environment</li>
<li>实现变化：从Spring 4.0开始，@Profile基于@Conditional实现</li>
</ul>
</li>
<li>基于编程条件注解 - org.springframework.context.annotation.Conditional
<ul>
<li>关联对象 - org.springframework.context.annotation.Condition具体实现</li>
</ul>
</li>
</ul>
<p>@Condtional实现原理大致如下：</p>
<ul>
<li>上下文对象 - org.springframework.context.annotation.ConditionContext</li>
<li>条件判断 - org.springframework.context.annotation.ConditionEvaluator</li>
<li>配置阶段 - org.springframework.context.annotation.ConfigurationCondition.ConfigurationPhase</li>
<li>判断入口 - org.springframework.context.annotation.ConfigurationClassPostProcessor
<ul>
<li>org.springframework.context.annotation.ConfigurationClassParser</li>
</ul>
</li>
</ul>
<p>Profile注解的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.register(ProfileDemo.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Environment对象</span></span><br><span class="line">        ConfigurableEnvironment environment = context.getEnvironment();</span><br><span class="line">        <span class="comment">// 默认的Profiles = [&quot;odd&quot;]</span></span><br><span class="line">        environment.setDefaultProfiles(<span class="string">&quot;odd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加活跃的Profiles</span></span><br><span class="line">        environment.setActiveProfiles(<span class="string">&quot;even&quot;</span>);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        Integer number = context.getBean(<span class="string">&quot;number&quot;</span>, Integer.class);</span><br><span class="line">        System.out.println(number);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;number&quot;)</span></span><br><span class="line">    <span class="meta">@Profile(&quot;odd&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">odd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;number&quot;)</span></span><br><span class="line"><span class="comment">//    @Profile(&quot;even&quot;)</span></span><br><span class="line">    <span class="meta">@Conditional(EventProfileCondition.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">even</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上@Conditional注解的使用也可能会用到Profile属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventProfileCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 条件上下文</span></span><br><span class="line">        Environment environment = context.getEnvironment();</span><br><span class="line">        <span class="keyword">return</span> environment.acceptsProfiles(<span class="string">&quot;even&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Profile在Spring 4当中的实现方式：</p>
<p>基于org.springframework.context.annotation.Condition接口实现：org.springframework.context.annotation.ProfileCondition，实现的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">		MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class="line">		<span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Object value : attrs.get(<span class="string">&quot;value&quot;</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="springboot和springcloud注解"><a class="markdownIt-Anchor" href="#springboot和springcloud注解"></a> SpringBoot和SpringCloud注解</h2>
<p>SpringBoot注解：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>@SpringBootConfiguration</td>
<td>Spring Boot配置类</td>
<td>1.4.0</td>
</tr>
<tr>
<td>@SpringBootApplication</td>
<td>Spring Boot应用引导注解</td>
<td>1.2.0</td>
</tr>
<tr>
<td>@EnableAutoConfiguration</td>
<td>Spring Boot激活自动装配</td>
<td>1.0.0</td>
</tr>
</tbody>
</table>
<p>SpringCloud注解：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>@SpringCloudApplication</td>
<td>Spring Cloud应用引导注解</td>
<td>1.0.0</td>
</tr>
<tr>
<td>@EnableDiscovertClient</td>
<td>Spring Cloud激活服务发现客户端注解</td>
<td>1.0.0</td>
</tr>
<tr>
<td>@EnableCircuitBreaker</td>
<td>Spring Cloud激活熔断注解</td>
<td>1.0.0</td>
</tr>
</tbody>
</table>
<h2 id="面试题-18"><a class="markdownIt-Anchor" href="#面试题-18"></a> 面试题</h2>
<h3 id="spring模式注解有哪些"><a class="markdownIt-Anchor" href="#spring模式注解有哪些"></a> Spring模式注解有哪些？</h3>
<ul>
<li>@Compenent</li>
<li>@Resository</li>
<li>@Service</li>
<li>@Controller</li>
<li>@Configuration</li>
</ul>
<h3 id="eventlistener的工作原理-2"><a class="markdownIt-Anchor" href="#eventlistener的工作原理-2"></a> @EventListener的工作原理？</h3>
<p>源码导读 - org.springframework.context.event.EventListenerMethodProcessor</p>
<h3 id="propertysource工作原理"><a class="markdownIt-Anchor" href="#propertysource工作原理"></a> @PropertySource工作原理</h3>
<p>// …</p>
<h1 id="spring-environment抽象"><a class="markdownIt-Anchor" href="#spring-environment抽象"></a> Spring Environment抽象</h1>
<p>Environment接口主要有以下两个作用：</p>
<ol>
<li>
<p>统一的Spring配置属性管理</p>
<p>SpringFramework 3.1开始引入Environment抽象，它统一Spring配置属性的存储，包括占位符处理和类型转换，不仅完整地替换PropertyPlaceholderConfigurer，而且还支持更丰富的配置属性源（PropertySource）</p>
</li>
<li>
<p>条件化Spring Bean装配管理</p>
<p>通过Environment Profiles信息，帮助Spring容器提供条件化地装配Bean</p>
</li>
</ol>
<h2 id="environment接口使用场景"><a class="markdownIt-Anchor" href="#environment接口使用场景"></a> Environment接口使用场景</h2>
<ul>
<li>用于属性占位符处理</li>
<li>用于转换Spring配置属性类型</li>
<li>用于存储Spring配置属性源（PropertySource）</li>
<li>用于Profiles状态维护</li>
</ul>
<h2 id="environment占位符处理"><a class="markdownIt-Anchor" href="#environment占位符处理"></a> Environment占位符处理</h2>
<p>不同Spring版本Environment对于占位符处理有所差异：</p>
<ul>
<li>Spring 3.1前占位符处理
<ul>
<li>组件：org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</li>
<li>接口：org.springframework.util.StringValueResolver</li>
</ul>
</li>
<li>Spring 3.1+占位符处理：
<ul>
<li>组件：org.springframework.context.support.PropertySourcesPlaceholderConfigurer</li>
<li>接口：org.springframework.beans.factory.config.EmbeddedValueResolver</li>
</ul>
</li>
</ul>
<p>我们可以来看以下具体地使用场景，首先定义一个properties文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">user.id</span>=<span class="string">11111</span></span><br><span class="line"><span class="meta">user.name</span>=<span class="string">jjjj</span></span><br><span class="line"><span class="meta">user.city</span>=<span class="string">HANGZHOU</span></span><br></pre></td></tr></table></figure>
<p>紧接着定义需要注入的Bean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;location&quot; value=&quot;classpath:/META-INF/default.properties&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;fileEncoding&quot; value=&quot;UTF-8&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:/META-INF/default.properties&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fileEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;user.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;user.city&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后观察输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyPlaceholderConfigurerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:/META-INF/placeholders-resolver.xml&quot;</span>);</span><br><span class="line">        User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到占位符已经被成功的替换。</p>
<h2 id="理解条件配置spring-profiles"><a class="markdownIt-Anchor" href="#理解条件配置spring-profiles"></a> 理解条件配置Spring Profiles</h2>
<p>Spring3.1的条件配置：</p>
<ul>
<li>API：org.springframework.core.env.ConfigurableEnvironment
<ul>
<li>修改：addActiveProfile(String)、SetActiveProfiles(String…)和setDefaultProfiles(String…)</li>
<li>获取：getActiveProfiles()和getDefaultProfiles</li>
<li>匹配：#acceptsProfiles(String…)和acceptsProfiles(Profiles)</li>
</ul>
</li>
<li>注解：org.springframework.context.annotation.Profile</li>
</ul>
<blockquote>
<p>在Spring当中，也可以通过<code>-Dspring.profiles.active</code>来修改当前的激活环境。</p>
</blockquote>
<h2 id="依赖注入environment"><a class="markdownIt-Anchor" href="#依赖注入environment"></a> 依赖注入Environment</h2>
<ol>
<li>注解注入：
<ul>
<li>通过EnvironmentAware接口回调</li>
<li>通过@Autowired注入Environment</li>
</ul>
</li>
<li>间接依赖注入：
<ul>
<li>通过ApplicationAware接口回调</li>
<li>通过@Autowired注入ApplicationContext</li>
</ul>
</li>
</ol>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectingEnvironmentDemo</span> <span class="keyword">implements</span> <span class="title">EnvironmentAware</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        context.register(InjectingEnvironmentDemo.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        InjectingEnvironmentDemo injectingEnvironmentDemo = context.getBean(InjectingEnvironmentDemo.class);</span><br><span class="line">        System.out.println(injectingEnvironmentDemo.environment);</span><br><span class="line"></span><br><span class="line">        System.out.println(injectingEnvironmentDemo.environment == injectingEnvironmentDemo.environment2);</span><br><span class="line"></span><br><span class="line">        System.out.println(context == injectingEnvironmentDemo.applicationContext);</span><br><span class="line"></span><br><span class="line">        System.out.println(injectingEnvironmentDemo.environment == context.getEnvironment());</span><br><span class="line">         </span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="依赖查找environment"><a class="markdownIt-Anchor" href="#依赖查找environment"></a> 依赖查找Environment</h2>
<ol>
<li>直接依赖查找
<ul>
<li>通过org.springframework.context.ConfigurableApplicationContext#ENVIRONMENT_BEAN_NAME</li>
</ul>
</li>
<li>直接查找
<ul>
<li>通过org.springframework.context.ConfigurableApplicationContext#getEnvironment</li>
</ul>
</li>
</ol>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LookupEnvironmentDemo</span> <span class="keyword">implements</span> <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.register(LookupEnvironmentDemo.class);</span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        LookupEnvironmentDemo injectingEnvironmentDemo = context.getBean(LookupEnvironmentDemo.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过Environment Bean名称依赖查找</span></span><br><span class="line">        Environment environment = context.getBean(ConfigurableApplicationContext.ENVIRONMENT_BEAN_NAME, Environment.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(injectingEnvironmentDemo.environment);</span><br><span class="line"></span><br><span class="line">        System.out.println(injectingEnvironmentDemo.environment == environment);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以发现依赖查找和依赖注入的Environment都是同一个，Environment对象本身隶属于ApplicationContext，但是在容器启动的时候，会注册一个单例的Environment对象到BeanFactory中。</p>
</blockquote>
<h2 id="依赖注入value"><a class="markdownIt-Anchor" href="#依赖注入value"></a> 依赖注入@Value</h2>
<p>@Value注解的实现类：org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</p>
<h2 id="spring类型转换在environment中的运用"><a class="markdownIt-Anchor" href="#spring类型转换在environment中的运用"></a> Spring类型转换在Environment中的运用</h2>
<p>Environment底层实现：</p>
<ul>
<li>底层实现 - org.springframework.core.env.PropertySourcesPropertyResolver
<ul>
<li>核心方法 - convertValueIfNecessary</li>
</ul>
</li>
<li>底层服务 - org.springframework.core.convert.ConversionService
<ul>
<li>默认实现 - org.springframework.core.convert.support.DefaultConversionService</li>
</ul>
</li>
</ul>
<p>相关的核心源代码：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210625173747553.png" alt="image-20210625173747553" style="zoom: 67%;" />
<h2 id="spring类型转换在value中的运用"><a class="markdownIt-Anchor" href="#spring类型转换在value中的运用"></a> Spring类型转换在@Value中的运用</h2>
<p>@Value底层实现：</p>
<ol>
<li>底层实现：org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
<ul>
<li>org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency</li>
</ul>
</li>
<li>底层服务：org.springframework.beans.TypeConverter
<ul>
<li>默认实现：org.springframework.beans.TypeConverterDelegate
<ul>
<li>java.beans.PropertyEditor</li>
<li>org.springframework.core.convert.ConversionService</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>相关的核心源代码：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210625174810362.png" alt="image-20210625174810362" style="zoom: 50%;" />
<h2 id="spring配置属性源propertysource"><a class="markdownIt-Anchor" href="#spring配置属性源propertysource"></a> Spring配置属性源PropertySource</h2>
<ul>
<li>
<p>API</p>
<ul>
<li>单配置属性源：org.springframework.core.env.PropertySource</li>
<li>多配置属性源：org.springframework.core.env.PropertySources</li>
</ul>
</li>
<li>
<p>注解</p>
<ul>
<li>单配置属性源：org.springframework.context.annotation.PropertySource</li>
<li>多配置属性源：org.springframework.context.annotation.PropertySources</li>
</ul>
</li>
<li>
<p>关联</p>
<ul>
<li>存储对象：org.springframework.core.env.MutablePropertySources</li>
<li>关联方法：org.springframework.core.env.ConfigurableEnvironment#getPropertySources</li>
</ul>
</li>
</ul>
<h2 id="spring内建的配置属性源"><a class="markdownIt-Anchor" href="#spring内建的配置属性源"></a> Spring内建的配置属性源</h2>
<p>内建的PropertySource:</p>
<table>
<thead>
<tr>
<th>PropertySource类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>org.springframework.core.env.CommandLinePropertySource</td>
<td>命令行配置属性源</td>
</tr>
<tr>
<td>org.springframework.jndi.JndiPropertySource</td>
<td>JNDI配置属性源</td>
</tr>
<tr>
<td>org.springframework.core.env.PropertiesPropertySource</td>
<td>Properties配置属性源</td>
</tr>
<tr>
<td>org.springframework.web.context.support.ServletConfigPropertySource</td>
<td>Servlet配置属性源</td>
</tr>
<tr>
<td>org.springframework.web.context.support.ServletContextPropertySource</td>
<td>ServletContext配置属性源</td>
</tr>
<tr>
<td>org.springframework.core.env.SystemEnvironmentPropertySource</td>
<td>环境变量配置属性源</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="基于注解扩展spring配置属性源"><a class="markdownIt-Anchor" href="#基于注解扩展spring配置属性源"></a> 基于注解扩展Spring配置属性源</h2>
<p>@org.springframework.context.annotation.PropertySource实现原理：</p>
<ul>
<li>入口 - org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass
<ul>
<li>org.springframework.context.annotation.ConfigurationClassParser#processPropertySource</li>
</ul>
</li>
<li>4.3新增语义
<ul>
<li>配置属性字符编码 - encoding</li>
<li>org.springframework.core.io.support.PropertySourceFactory</li>
</ul>
</li>
<li>适配对象 - org.springframework.core.env.CompositePropertySource</li>
</ul>
<blockquote>
<p>默认只支持properties格式的文件，可以通过PropertySourceFactory进行扩展。</p>
</blockquote>
<h2 id="基于api扩展spring配置属性源"><a class="markdownIt-Anchor" href="#基于api扩展spring配置属性源"></a> 基于API扩展Spring配置属性源</h2>
<p>PropertySource的配置实际上有两种类型：</p>
<ul>
<li>Spring应用上下文启动前装配PropertySource</li>
<li>Spring应用上下文启动后装配PropertySource</li>
</ul>
<p>基于API扩展的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentPropertySourceChangeDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;user.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String UserName; <span class="comment">// 不具备动态更新地能力</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// propertySource(“first-property-source”) &#123;user.name = 吉永超&#125;</span></span><br><span class="line">    <span class="comment">// propertySource(Java System Properties) &#123;user.name = jyc&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.register(EnvironmentPropertySourceChangeDemo.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在Spring应用上下文启动之前，调整Environment中的PropertySource</span></span><br><span class="line">        ConfigurableEnvironment environment = context.getEnvironment();</span><br><span class="line">        <span class="comment">// 获取MutablePropertySources 对象</span></span><br><span class="line">        MutablePropertySources propertySources = environment.getPropertySources();</span><br><span class="line">        <span class="comment">// 动态地插入PropertySource到PropertySources</span></span><br><span class="line">        HashMap&lt;String, Object&gt; source = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        source.put(<span class="string">&quot;user.name&quot;</span>, <span class="string">&quot;吉永超&quot;</span>);</span><br><span class="line">        MapPropertySource propertySource = <span class="keyword">new</span> MapPropertySource(<span class="string">&quot;first-property-source&quot;</span>, source);</span><br><span class="line">        propertySources.addFirst(propertySource);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        source.put(<span class="string">&quot;user.name&quot;</span>, <span class="string">&quot;007&quot;</span>);</span><br><span class="line">        EnvironmentPropertySourceChangeDemo environmentPropertySourceChangeDemo = context.getBean(EnvironmentPropertySourceChangeDemo.class);</span><br><span class="line">        System.out.println(environmentPropertySourceChangeDemo.UserName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (PropertySource ps : propertySources) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;PropertySource(name=%s),&#x27;user.name&#x27;属性=%s\n&quot;</span>, ps.getName(), ps.getProperty(<span class="string">&quot;user.name&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring-测试配置属性源"><a class="markdownIt-Anchor" href="#spring-测试配置属性源"></a> Spring 测试配置属性源</h2>
<p>Spring 4.1测试配置属性源 - @TestPropertySource</p>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = TestPropertySourceDemo.class)</span> <span class="comment">//Spring 注解驱动测试注解</span></span><br><span class="line"><span class="meta">@TestPropertySource(properties = &quot;user.name=吉永超&quot;)</span>  <span class="comment">// PropertySource(name=Inlined Test Properties)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPropertySourceDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;user.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> TestPropertySourceDemo().userName);</span><br><span class="line">        <span class="keyword">for</span> (PropertySource ps : environment.getPropertySources()) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;PropertySource(name=%s),&#x27;user.name&#x27;属性=%s\n&quot;</span>, ps.getName(), ps.getProperty(<span class="string">&quot;user.name&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到@TestPropertySource来源的优先级相当的高。</p>
<h2 id="面试题-19"><a class="markdownIt-Anchor" href="#面试题-19"></a> 面试题</h2>
<h3 id="简单介绍spring-environment接口"><a class="markdownIt-Anchor" href="#简单介绍spring-environment接口"></a> 简单介绍Spring Environment接口？</h3>
<ul>
<li>核心接口 - org.springframework.core.env.Environment</li>
<li>父接口 - org.springframework.core.env.PropertyResolver</li>
<li>可配置接口 - org.springframework.core.env.ConfigurableEnvironment</li>
<li>职责：
<ul>
<li>管理Spring配置属性源</li>
<li>管理Profiles</li>
</ul>
</li>
</ul>
<h3 id="如何控制propertysource的优先级"><a class="markdownIt-Anchor" href="#如何控制propertysource的优先级"></a> 如何控制PropertySource的优先级？</h3>
<p>可以通过相关的Spring相关的API进行操作</p>
<h3 id="environment完整的生命周期是怎样的"><a class="markdownIt-Anchor" href="#environment完整的生命周期是怎样的"></a> Environment完整的生命周期是怎样的？</h3>
<p>// …</p>
<h1 id="spring-应用上下文生命周期"><a class="markdownIt-Anchor" href="#spring-应用上下文生命周期"></a> Spring 应用上下文生命周期</h1>
<h2 id="spring应用上下文启动准备阶段"><a class="markdownIt-Anchor" href="#spring应用上下文启动准备阶段"></a> Spring应用上下文启动准备阶段</h2>
<p>org.springframework.context.support.AbstractApplicationContext#prepareRefresh方法：</p>
<ul>
<li>启动时间 - startupDate</li>
<li>状态标志 - closed(false)、active(true)</li>
<li>初始化 PropertySources - initPropertySources()</li>
<li>校验Environment中必须属性</li>
<li>初始化事件监听器集合</li>
<li>初始化早期Spring事件集合</li>
</ul>
<p>相关的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Switch to active.</span></span><br><span class="line">	<span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">	<span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">	initPropertySources();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">	<span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">	getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">		<span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">		<span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">	<span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">	<span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="beanfactory创建阶段"><a class="markdownIt-Anchor" href="#beanfactory创建阶段"></a> BeanFactory创建阶段</h2>
<p>AbstractApplicationContext#obtainFreshBeanFactory方法：</p>
<ul>
<li>刷新Spring应用上下文底层BeanFactory - refreshBeanFactory()
<ul>
<li>销毁或关闭BeanFactory，如果已存在的话</li>
<li>创建BeanFactory - createBeanFactory()</li>
<li>设置BeanFactory Id</li>
<li>设置&quot;是否允许BeanDefinition重复定义&quot; - customizeBeanFactory(DefaultListableBeanFactory)</li>
<li>设置&quot;是否允许循环应用（依赖）&quot; - customizeBeanFactory(DefaultListableBeanFactory)</li>
<li>加载BeanDefinition - loadBeanDefinitions(DefaultListableBeanFactory beanFactory)</li>
<li>关联新建BeanFactory到Spring应用上下文</li>
</ul>
</li>
<li>返回Spring应用上下文底层BeanFactory - getBeanFactory</li>
</ul>
<p>可以在AbstractRefreshableApplicationContext看到具体的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">		loadBeanDefinitions(beanFactory);</span><br><span class="line">		<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="beanfactory准备阶段"><a class="markdownIt-Anchor" href="#beanfactory准备阶段"></a> BeanFactory准备阶段</h2>
<p>AbstractApplicationContext#prepareBeanFactory(ConfigurableListableBeanFactory)方法：</p>
<ul>
<li>关联ClassLoader</li>
<li>设置Bean表达式处理器</li>
<li>添加PropertyEdittorRegistrar实现 - ResourceEditorRegistrar</li>
<li>添加Aware回调接口BeanPostProcessor实现 - ApplicationContextAwareProcessor</li>
<li>忽略Aware回调接口作为依赖注入接口</li>
<li>注册ResolvableDependency对象 - BeanFactory、ResourceLoader、ApplicationEventPublisher以及ApplicationContext</li>
<li>注册ApplicationListenerDetector对象</li>
<li>注册LoadTimeWeaverAwareProcessor对象</li>
<li>注册单例对象 - Environment、Java System Properties、以及OS环境变量</li>
</ul>
<p>相关的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line">	beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">	<span class="keyword">if</span> (!shouldIgnoreSpel) &#123;</span><br><span class="line">		beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">	&#125;</span><br><span class="line">	beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">	beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">	<span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">	beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">	beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">	beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">	beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">	<span class="keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">		<span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">		beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register default environment beans.</span></span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="beanfactory后置处理阶段"><a class="markdownIt-Anchor" href="#beanfactory后置处理阶段"></a> BeanFactory后置处理阶段</h2>
<p>AbstractApplicationContext#postProcessBeanFactory(ConfigurableListableBeanFactory)方法</p>
<ul>
<li>由子类覆盖该方法</li>
</ul>
<p>AbstractApplicationContext#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory)方法：</p>
<ul>
<li>调用BeanFactoryPostProcessor或BeanDefinitionPostProcessorRegistry后置处理方法</li>
<li>注册LoadTimeWeaverAwareProcessor对象</li>
</ul>
<blockquote>
<p>通常情况下，我们应该选择第二种方式，组合优先于继承。</p>
</blockquote>
<p>相关的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">		<span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">		<span class="keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">			beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="beanfactory注册beanpostprocess"><a class="markdownIt-Anchor" href="#beanfactory注册beanpostprocess"></a> BeanFactory注册BeanPostProcess</h2>
<p>AbstractApplicationContext#registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory)方法：</p>
<ul>
<li>注册PriorityOrdered类型的BeanPostProcessor Beans</li>
<li>注册Ordered类型的BeanPostProcessor Beans</li>
<li>注册普通BeanPostProcessor Beans</li>
<li>注册MergedBeanDefinitionPostProcessor Beans</li>
<li>注册ApplicationListenerDetector对象</li>
</ul>
<p>相应的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">		<span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">		<span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">		<span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">		<span class="comment">// Ordered, and the rest.</span></span><br><span class="line">		List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                    <span class="comment">// 特别要注意，这里会导致Bean的提前初始化</span></span><br><span class="line">				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">				priorityOrderedPostProcessors.add(pp);</span><br><span class="line">				<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">					internalPostProcessors.add(pp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">		List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">		<span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">               <span class="comment">// 这里也会初始化</span></span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			orderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">		List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">		<span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			nonOrderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">		sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">		<span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化内建messagesource"><a class="markdownIt-Anchor" href="#初始化内建messagesource"></a> 初始化内建MessageSource</h2>
<p>AbstractApplicationContext#initMessageSource方法：</p>
<ul>
<li>第十二章Spring国际化 - MessageSource内建依赖</li>
</ul>
<p>相应的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">		<span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">			HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">			<span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">				<span class="comment">// registered already.</span></span><br><span class="line">				hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">		DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">		dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">		<span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">		beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">&quot;&#x27; bean, using [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化内建spring事件广播器"><a class="markdownIt-Anchor" href="#初始化内建spring事件广播器"></a> 初始化内建Spring事件广播器</h2>
<p>AbstractApplicationContext#initApplicationEventMulticaster方法：</p>
<ul>
<li>第十七章Spring事件 - ApplicationEventMulticaster底层实现</li>
</ul>
<p>相应的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">					beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">						<span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到在Spring的应用上下文中，ApplicationEventMulticaster这个对象一定会存在，因此我们可以使用依赖注入的方式获取到唯一的对象ApplicationEventMulticaster的对象。</p>
</blockquote>
<h2 id="spring应用上下文刷新"><a class="markdownIt-Anchor" href="#spring应用上下文刷新"></a> Spring应用上下文刷新</h2>
<p>AbstractApplicationContext#onRefresh方法：</p>
<ul>
<li>org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#onRefresh</li>
<li>org.springframework.web.context.support.GenericWebApplicationContext#onRefresh</li>
<li>org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#onRefresh</li>
<li>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#onRefresh</li>
<li>org.springframework.web.context.support.StaticWebApplicationContext#onRefresh</li>
</ul>
<blockquote>
<p>onRefresh()方法只有在Web的场景下才会进行扩展。</p>
</blockquote>
<h2 id="spring事件监听器注册"><a class="markdownIt-Anchor" href="#spring事件监听器注册"></a> Spring事件监听器注册</h2>
<p>AbstractApplicationContext#registerListeners方法：</p>
<ul>
<li>添加当前应用上下文所关联的ApplicationListeners对象（集合）</li>
<li>添加BeanFactory所注册ApplicationListeners Beans</li>
<li>广播早期Spring事件</li>
</ul>
<p>相应的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Register statically specified listeners first.</span></span><br><span class="line">		<span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">			getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">		<span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">		String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">			getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">		Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">		<span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">				getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="beanfactory初始化完成阶段"><a class="markdownIt-Anchor" href="#beanfactory初始化完成阶段"></a> BeanFactory初始化完成阶段</h2>
<p>AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory)方法：</p>
<ul>
<li>BeanFactory关联ConversionService Bean，如果存在</li>
<li>添加StringValueResolver对象</li>
<li>依赖查找LoadTimeWeaverAware Bean</li>
<li>BeanFactory临时ClassLoader置为null</li>
<li>BeanFactory冻结配置</li>
<li>BeanFactory初始化非延迟单例Beans</li>
</ul>
<p>相应的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">		beanFactory.setConversionService(</span><br><span class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register a default embedded value resolver if no BeanFactoryPostProcessor</span></span><br><span class="line">	<span class="comment">// (such as a PropertySourcesPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">	<span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">		beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">	String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">		getBean(weaverAwareName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">	beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">	beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">	beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring应用上下文刷新完成阶段"><a class="markdownIt-Anchor" href="#spring应用上下文刷新完成阶段"></a> Spring应用上下文刷新完成阶段</h2>
<p>AbstractApplicationContext#finishRefresh方法：</p>
<ul>
<li>清除ResourceLoader缓存 - clearResourceCaches() @since 5.0</li>
<li>初始化LifecycleProcessor对象 - initLifecycleProcessor()</li>
<li>调用LifecycleProcessor().onRefresh()方法</li>
<li>发布Spring应用上下文已刷新事件 - ContextRefreshedEvent</li>
<li>向MBeanServer托管Live Beans</li>
</ul>
<p>相应的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">		clearResourceCaches();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">		initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">		getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Publish the final event.</span></span><br><span class="line">		publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">		<span class="keyword">if</span> (!NativeDetector.inNativeImage()) &#123;</span><br><span class="line">			LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring-应用上下文启动阶段"><a class="markdownIt-Anchor" href="#spring-应用上下文启动阶段"></a> Spring 应用上下文启动阶段</h2>
<p>AbstractApplicationContext#start方法</p>
<ul>
<li>启动LifecycleProcessor
<ul>
<li>依赖查找Lifecycle Beans</li>
<li>启动Lifecycle Beans</li>
</ul>
</li>
<li>发布Spring应用上下文已启动事件 - ContextStartedEvent</li>
</ul>
<p>相应的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		getLifecycleProcessor().start();</span><br><span class="line">		publishEvent(<span class="keyword">new</span> ContextStartedEvent(<span class="keyword">this</span>));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring-应用上下文停止阶段"><a class="markdownIt-Anchor" href="#spring-应用上下文停止阶段"></a> Spring 应用上下文停止阶段</h2>
<p>AbstractApplicationContext#stop方法</p>
<ul>
<li>停止LifecycleProcessor
<ul>
<li>依赖查找Lifecycle Beans</li>
<li>停止Lifecycle Beans</li>
</ul>
</li>
<li>发布Spring应用上下文已停止事件 - ContextStoppedEvent</li>
</ul>
<p>相应的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		getLifecycleProcessor().stop();</span><br><span class="line">		publishEvent(<span class="keyword">new</span> ContextStoppedEvent(<span class="keyword">this</span>));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以自定义一个Lifecycle：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLifecycle</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> running = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;org.jyc.thinking.in.spring.lifecycle.MyLifecycle 启动...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;org.jyc.thinking.in.spring.lifecycle.MyLifecycle 停止...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> running;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line">        <span class="comment">// 注册MyLifecycle成为一个Spring Bean</span></span><br><span class="line">        context.registerBeanDefinition(<span class="string">&quot;myLifecycle&quot;</span>, BeanDefinitionBuilder.rootBeanDefinition(MyLifecycle.class).getBeanDefinition());</span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 启动应用上下文</span></span><br><span class="line">        context.start();</span><br><span class="line">        <span class="comment">// 关闭Spring应用</span></span><br><span class="line">        context.stop();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring应用上下文关闭阶段"><a class="markdownIt-Anchor" href="#spring应用上下文关闭阶段"></a> Spring应用上下文关闭阶段</h2>
<p>AbstractApplicationContext#close方法:</p>
<ul>
<li>状态标识：active(false)、closed(true)</li>
<li>Live Beans JMX撤销托管
<ul>
<li>LiveBeansView.unregisterApplicationContext(ConfigurableApplicationContext)</li>
</ul>
</li>
<li>发布Spring应用上下文已关闭事件 - ContextClosedEvent</li>
<li>关闭LifecycleProcessor
<ul>
<li>依赖查找Lifecycle Beans</li>
<li>停止Lifecycle Beans</li>
</ul>
</li>
<li>销毁Lifecycle Beans</li>
<li>关闭BeanFactory</li>
<li>回调onClose()</li>
<li>注册Shutdown Hook线程（如果曾注册）</li>
</ul>
<p>相应的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Check whether an actual close attempt is necessary...</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.active.get() &amp;&amp; <span class="keyword">this</span>.closed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Closing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!NativeDetector.inNativeImage()) &#123;</span><br><span class="line">			LiveBeansView.unregisterApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Publish shutdown event.</span></span><br><span class="line">			publishEvent(<span class="keyword">new</span> ContextClosedEvent(<span class="keyword">this</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			logger.warn(<span class="string">&quot;Exception thrown from ApplicationListener handling ContextClosedEvent&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Stop all Lifecycle beans, to avoid delays during individual destruction.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleProcessor != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.lifecycleProcessor.onClose();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception thrown from LifecycleProcessor on context close&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Destroy all cached singletons in the context&#x27;s BeanFactory.</span></span><br><span class="line">		destroyBeans();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Close the state of this context itself.</span></span><br><span class="line">		closeBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Let subclasses do some final clean-up if they wish...</span></span><br><span class="line">		onClose();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">			<span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Switch to inactive.</span></span><br><span class="line">		<span class="keyword">this</span>.active.set(<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里补充一个关于ShutdownHook的示例，通过这种方式可以优雅的停止线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> ApplicationListener&lt;ContextClosedEvent&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[线程 %s] ContextClosedEvent 处理\n&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        context.refresh();</span><br><span class="line">        context.registerShutdownHook();</span><br><span class="line">        System.out.println(<span class="string">&quot;按任意键继续并且关闭Spring 应用上下文&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-20"><a class="markdownIt-Anchor" href="#面试题-20"></a> 面试题</h2>
<h3 id="spring应用上下文生命周期有哪些阶段"><a class="markdownIt-Anchor" href="#spring应用上下文生命周期有哪些阶段"></a> Spring应用上下文生命周期有哪些阶段？</h3>
<p>可以简单的回答为：</p>
<ul>
<li>刷新阶段 - ConfigurableApplicationContext#refresh()</li>
<li>启动阶段 - ConfigurableApplicationContext#start()</li>
<li>停止阶段 - ConfigurableApplicationContext#stop()</li>
<li>关闭阶段 - ConfigurableApplicationContext#close()</li>
</ul>
<h3 id="environment完整的生命周期"><a class="markdownIt-Anchor" href="#environment完整的生命周期"></a> Environment完整的生命周期？</h3>
<p>主要分为refresh()方法之前和refresh()方法之后，在refresh()方法之前可以主动填充自定义的Environment对象，在refresh()方法之后会创建默认的Environment对象。</p>
<h1 id="spring-总结"><a class="markdownIt-Anchor" href="#spring-总结"></a> Spring 总结</h1>
<h2 id="spring核心特性-2"><a class="markdownIt-Anchor" href="#spring核心特性-2"></a> Spring核心特性</h2>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210628202410655.png" alt="image-20210628202410655" /></p>
<h2 id="spring核心价值"><a class="markdownIt-Anchor" href="#spring核心价值"></a> Spring核心价值</h2>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210628202440062.png" alt="image-20210628202440062" /></p>
<h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1>
<h2 id="为什么说objectfactory提供的是延迟依赖查找"><a class="markdownIt-Anchor" href="#为什么说objectfactory提供的是延迟依赖查找"></a> 为什么说ObjectFactory提供的是延迟依赖查找？</h2>
<p>原因：</p>
<ul>
<li>ObjectFactory（或ObjectProvider）可关联某一类型Bean</li>
<li>ObjectFactory（或ObjectProvider）对象在被依赖注入和依赖查询时并未实时查找关联类型Bean</li>
<li>ObjectFactory（或ObjectProvider）调用getObject()方法时，目标Bean才被依赖查找</li>
</ul>
<p>总结：ObjectFactory（或ObjectProvider）相当于某一类型Bean依赖查找代理对象。</p>
<p>这里我们可以编写一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectFactoryLazyLookupDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        context.register(ObjectFactoryLazyLookupDemo.class);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        ObjectFactoryLazyLookupDemo demo = context.getBean(ObjectFactoryLazyLookupDemo.class);</span><br><span class="line">        <span class="comment">// 代理对象</span></span><br><span class="line">        ObjectProvider&lt;User&gt; objectProvider = demo.objectProvider;</span><br><span class="line">        ObjectFactory&lt;User&gt; userObjectFactory = demo.userObjectFactory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ObjectFactory和ObjectProvider</span></span><br><span class="line">        System.out.println(<span class="string">&quot;userObjectFactory == objectProvider: &quot;</span> +</span><br><span class="line">                (userObjectFactory == objectProvider));</span><br><span class="line">        <span class="comment">// 结果为true，说明两者的底层实现是一样的。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;userObjectFactory.getClass() == objectProvider.getClass(): &quot;</span> +</span><br><span class="line">                (userObjectFactory.getClass() == objectProvider.getClass()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实际对象(延迟查找)</span></span><br><span class="line">        System.out.println(userObjectFactory.getObject());</span><br><span class="line">        System.out.println(objectProvider.getObject());</span><br><span class="line">        System.out.println(context.getBean(User.class));</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;User&gt; userObjectFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectProvider&lt;User&gt; objectProvider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;吉永超&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在DefaultListableBeanFactory.DependencyObjectProvider中看到相关的原理，只有在调用getObject的时候，才会根据泛型的具体化进行依赖查找，创建对象，而不是直接去查找，也就是所谓的延迟依赖查找。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210629102005648.png" alt="image-20210629102005648" style="zoom:50%;" />
<h2 id="依赖查找注入的bean会被缓存嘛"><a class="markdownIt-Anchor" href="#依赖查找注入的bean会被缓存嘛"></a> 依赖查找（注入）的Bean会被缓存嘛？</h2>
<ul>
<li>单例Bean（Singleton）-  会
<ul>
<li>缓存位置：org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonObjects属性</li>
</ul>
</li>
<li>原型Bean（Prototype）- 不会
<ul>
<li>当依赖查询或依赖注入时，根据BeanDefinition每次创建</li>
</ul>
</li>
<li>其他Scope Bean
<ul>
<li>request：每个ServletRequest内部缓存，生命周期维持在每次HTTP请求</li>
<li>session：每个HttpSeesion内部缓存，生命周期维持在每个用户HTTP会话</li>
<li>application：当前Servlet应用内部缓存</li>
</ul>
</li>
</ul>
<p>相关的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanCachingDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        context.register(BeanCachingDemo.class);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        BeanCachingDemo beanCachingDemo = context.getBean(BeanCachingDemo.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// singletonBean会被缓存</span></span><br><span class="line">            System.out.println(beanCachingDemo == context.getBean(BeanCachingDemo.class));</span><br><span class="line">        &#125;</span><br><span class="line">        User user = context.getBean(User.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// prototype不会被缓存</span></span><br><span class="line">            System.out.println(user == context.getBean(User.class));</span><br><span class="line">        &#125;</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;吉永超&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中单例对象的最为复杂，在DefaultSingletonBeanRegistry#getSingleton中可以看到核心的逻辑：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210629104114854.png" style="zoom: 50%;" />
<p>在每次进行依赖查找（注入）的时候不是直接创建对象，而是会现在缓存的字段singletonObjects中进行获取。</p>
<p>原型作用域的Bean每次在依赖查找（注入）的时候都会根据BeanDefinition重新构建Bean。</p>
<p>总而言之，只有Prototype的Bean不会进行缓存，其他情况下均会进行缓存。Prototype的Bean在被容器创建之后就会与容器脱钩，不再有生命周期等特性。</p>
<h2 id="bean的处理流程是怎样的"><a class="markdownIt-Anchor" href="#bean的处理流程是怎样的"></a> @Bean的处理流程是怎样的？</h2>
<ul>
<li>解析范围 - Configuration Class中的@Bean方法</li>
<li>方法类型 - 静态@Bean方法和实例@Bean方法</li>
</ul>
<p>在找到标注了@Configuration Class的类之后，会获取到所有的@Bean的方法，根据标注的@Bean的方法解析出相应的BeanDefinition，然后创建对象，相关的逻辑在</p>
<p>ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod方法中，另外在解析静态方法和实例方法的时候，有一些差别：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210629112032376.png" alt="image-20210629112032376" style="zoom:50%;" />
<p>可以看到，如果是实例方法，那么首先要获取到实例方法所在的类的实例，静态方法的初始化会更早。</p>
<h2 id="beanfactory是如何处理循环依赖的"><a class="markdownIt-Anchor" href="#beanfactory是如何处理循环依赖的"></a> BeanFactory是如何处理循环依赖的？</h2>
<p>预备知识：</p>
<ul>
<li>循环依赖开关（方法）- AbstractAutowireCapableBeanFactory#setAllowCircularReferences</li>
<li>单例工程（属性）- DefaultSingletonBeanRegistry#singletonFactories</li>
<li>获取早期未处理Bean（方法） - AbstractAutowireCapableBeanFactory#getEarlyBeanReference</li>
<li>早期未处理Bean（属性） - DefaultSingletonBeanRegistry#earlySingletonObjects</li>
</ul>
<p>循环依赖的示例，首先定义一个学生类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClassRoom classRoom;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassRoom <span class="title">getClassRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classRoom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassRoom</span><span class="params">(ClassRoom classRoom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classRoom = classRoom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, classRoom.name=&quot;</span> + classRoom.getName() +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后定义一个教室类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassRoom</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;Student&gt; students;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudents</span><span class="params">(Collection&lt;Student&gt; students)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.students = students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ClassRoom&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, students=&quot;</span> + students +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularReferencesDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册 Configuration Class</span></span><br><span class="line">        context.register(CircularReferencesDemo.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果设置为 false，则抛出异常信息如：currently in creation: Is there an unresolvable circular reference?</span></span><br><span class="line">        <span class="comment">// 默认值为 true</span></span><br><span class="line">        context.setAllowCircularReferences(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 Spring 应用上下文</span></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Student : &quot;</span> + context.getBean(Student.class));</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassRoom : &quot;</span> + context.getBean(ClassRoom.class));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭 Spring 应用上下文</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setId(<span class="number">1L</span>);</span><br><span class="line">        student.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassRoom <span class="title">classRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassRoom classRoom = <span class="keyword">new</span> ClassRoom();</span><br><span class="line">        classRoom.setName(<span class="string">&quot;C122&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> classRoom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理循环依赖的核心代码：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210629152452981.png" alt="image-20210629152452981" style="zoom:50%;" />
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析</title>
    <url>/2022/01/12/STL/</url>
    <content><![CDATA[<p>经常听到这样一句话：基础很重要，然而什么是真正的基础却很没有一个标准答案，是JVM，亦或是并发编程？还是JDK的源码？每个人可能都有自己的答案，但在很多时候，native方法都成为了阻碍我们继续探索更为原理底层的知识的一座大山，因此，笔者选择C++这一门看起来足够“基础”，也足够具有代表性的编程语言，作为了解编程本质的钥匙。</p>
<span id="more"></span>
<h1 id="c编程基础"><a class="markdownIt-Anchor" href="#c编程基础"></a> C++编程基础</h1>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ从实践到原理</title>
    <url>/2021/10/24/RocketMQ/</url>
    <content><![CDATA[<p>RocketMQ是一个分布式消息和流数据平台，具有低延迟、高性能、高可靠性、万亿级容量和灵活的可扩展性。RcoketMQ是2012年阿里巴巴开源的第三代分布式消息中间，2017年2月20日，Apache软件基金会宣布Apache RocketMQ成为顶级项目。</p>
<span id="more"></span>
<h1 id="概念和特性"><a class="markdownIt-Anchor" href="#概念和特性"></a> 概念和特性</h1>
<h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2>
<h3 id="消息模型"><a class="markdownIt-Anchor" href="#消息模型"></a> 消息模型</h3>
<p>RocketMQ主要由Producer、Broker、Consumer三部分组成，其中Producer负责生产消息，Consumer负责消费消息，Broker负责存储消息，Broker在实际部署过程中对应一台服务器，每个Broker可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的Broker。Message Queue用于存储消息的物理地址，每个Topic中的消息地址存储于多个Message Queue中。ConsumerGroup由多个Consumer实例构成。</p>
<h3 id="生产者组"><a class="markdownIt-Anchor" href="#生产者组"></a> 生产者组</h3>
<p>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p>
<h3 id="消费者组"><a class="markdownIt-Anchor" href="#消费者组"></a> 消费者组</h3>
<p>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错变的容易。特别需要注意的是，<strong>消费者组的消费者实例必须订阅完全相同的Topic。</strong></p>
<div class="note info"><p>一个生产者可以同时发送多种Topic消息；而一个消费者只对某种特定的Topic感兴趣，即只可以订阅和消费一种Topic消息。</p></div>
<h3 id="集群消费"><a class="markdownIt-Anchor" href="#集群消费"></a> 集群消费</h3>
<p>集群消费模式下，相同的Consumer Group的每个Consumer实例平均分摊消息。</p>
<h3 id="广播消息"><a class="markdownIt-Anchor" href="#广播消息"></a> 广播消息</h3>
<p>广播消费模式下，相同的Consumer Group的每个Consumer实例都接收全量的消息。</p>
<h3 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h3>
<p>为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<h3 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h3>
<p>队列是存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。一个Topic的Queue也被称为一个Topic中消息的分区（Partition）。</p>
<p>一个Topic的Queue中的消息只能被一个消费者组中的一个消费者消费。一个Queue中的消息不允许同一个消费者组中的多个消费者同时消费。</p>
<p>与分区相关的还有一个概念：分片（Sharding）。分片不同于分区。在RocketMQ中，分片指的是存放相同Topic的Broker。每个分片中会创建相应数量的分区，即Queue，每个Queue的大小都是相同的。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211104235000.png" alt="分片" style="zoom: 67%;" />
<h3 id="协议"><a class="markdownIt-Anchor" href="#协议"></a> 协议</h3>
<p>常见MQ的实现都遵循一些常规性的协议，例如：JMS、STOMP、AMQP、MQTT，它们的具体含义如下：</p>
<ul>
<li>JMS（Java Messaging Service即Java消息服务），是Java平台上有关MOM（Message Oriented Middleware，面向消息的中间件PO/OO/AO）的技术规范，它便于消息系统中的Java应用程序进行消息交换，并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发，ActiveMQ是该协议的典型实现</li>
<li>STOMP（Streaming Text Oriented Message Protocol即面向流文本的消息协议），是一种MOM设计的简单文本协议，STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。ActiveMQ是该协议的典型实现，RabbitMQ通过插件可以支持该协议</li>
<li>AMQP（Advanced Message Queuing Protocol即高级消息队列协议），一个提供统一消息服务的应用层便准，是应用层协议的一个开放标准，是一种MOM设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。RabbitMQ是该协议的典型实现</li>
<li>MQTT（Message Queuing Telemetry Transport即消息队列遥测传输），是IBM开发的一个即时通讯协议，是一种二进制协议，主要用于服务器和低功耗IOT（物联网）设备间的通信。该协议支持所有平台，几乎可以把所有物联网物品和外部连接起来，被用来当作传感器和致动器的通信协议。RabbitMQ通过插件可以支持该协议</li>
</ul>
<h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2>
<h3 id="消息顺序"><a class="markdownIt-Anchor" href="#消息顺序"></a> 消息顺序</h3>
<p>消息有序指的是一类消息消费时，能按照发送来的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。</p>
<p>顺序消息分为全局顺序消息与分区顺序消息，全局顺序是指某个Topic下所有的消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可。</p>
<ul>
<li>全局顺序是指对于指定的一个Topic，所有消息按照严格的先入先出的顺序发布和消费，适用于性能要求不高，所有的消息严格按照FIFO原则进行消息发布和消费的场景</li>
<li>分区顺序对于指定一个Topic，所有的消息根据sharding key进行区块分区。同一个分区内的消息按照严格的FIFO顺序进行发布和消费</li>
</ul>
<h3 id="消息重试"><a class="markdownIt-Anchor" href="#消息重试"></a> 消息重试</h3>
<p>Consumer消费消息失败后，要提供一种重试机制，让消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p>
<ul>
<li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消息，也大概率不会成功，所以最好提供一种定时重试机制，即过10秒后再重试</li>
<li>由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其它消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力</li>
</ul>
<p>RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p>
<h3 id="延迟队列"><a class="markdownIt-Anchor" href="#延迟队列"></a> 延迟队列</h3>
<p>延迟队列（定时消息）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic，broker有配置项messageDelayLevel，默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18个level。可以配置自定义messageDelayLevel。注意，messageDelayLevel是broker的属性，不属于某个topic。</p>
<h3 id="死信队列"><a class="markdownIt-Anchor" href="#死信队列"></a> 死信队列</h3>
<p>死信队列用于处理无法被正常消费的消息，当一条消息初次消费失败，消费队列会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p>
<p>RocketMQ将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead Letter Queue）。在RocketMQ中，可以通过使用console控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。</p>
<h1 id="架构和设计"><a class="markdownIt-Anchor" href="#架构和设计"></a> 架构和设计</h1>
<h2 id="技术架构"><a class="markdownIt-Anchor" href="#技术架构"></a> 技术架构</h2>
<p>RocketMQ架构上主要分为四部分，如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211102235603.png" alt="RocketMQ架构" />
<p>其中各个部分的详细作用：</p>
<ul>
<li>
<p>Producer：消息发布的角色，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟</p>
</li>
<li>
<p>Consumer：消息消费的角色，支持分布式集群方式部署；支持以push、pull两种模块消费消息；同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求</p>
</li>
<li>
<p>NameServer：NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。主要包括两个功能：</p>
<ul>
<li>Broker管理：NameServer接收Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活</li>
<li>路由信息管理：每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Consumer通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费</li>
</ul>
<p>NameServer通常也是集群的方式部署，各实例间互相不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer，Consumer仍然可以动态感知Broker的路由信息</p>
</li>
<li>
<p>BrokerServer：Broker主要负责消息的存储、投递和查询以及服务高可用保证，为了实现这些功能，Broker包含了以下几个重要的子模块</p>
</li>
</ul>
<h3 id="集群工作流程"><a class="markdownIt-Anchor" href="#集群工作流程"></a> 集群工作流程</h3>
<p>集合部署架构图，描述集群工作流程：</p>
<ul>
<li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Conusmer连接上来，相当于一个路由控制中心</li>
<li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息（IP+端口等）以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系</li>
<li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic</li>
<li>Producer发送消息，启动时先跟NamerServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息</li>
<li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息</li>
</ul>
<h2 id="架构设计"><a class="markdownIt-Anchor" href="#架构设计"></a> 架构设计</h2>
<h3 id="消息存储"><a class="markdownIt-Anchor" href="#消息存储"></a> 消息存储</h3>
<h4 id="消息存储整体架构"><a class="markdownIt-Anchor" href="#消息存储整体架构"></a> 消息存储整体架构</h4>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211031234114.png" alt="RockeMQ消息存储" style="zoom:100%;" />
<p>消息存储的架构中主要由三个部分构成：</p>
<ul>
<li>CommitLog：消息主体以及元数据的存储主体，存储Producer端写入的消息主题内容，消息内容不是定长的。单个文件大小默认1G，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件；</li>
<li>ConsumeQueue：消息消费队列，引入的目的主要是提高消息消费的性能，由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历CommitLog文件中根据Topic检索消息是非常低效的。Conusmer即可根据ConsumerQueue来查找待消费的消息。其中，ConsumerQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。ConsumerQueue文件可以堪称是基于Topic的CommitLog索引文件，故ConsumerQueue文件夹的组织方式是：topic/queue/file三层组织结构，具体存储路径为：<code>$HOME/store/consumequeue/&#123;topic&#125;/&#123;queueId&#125;/&#123;fileName&#125;</code>。同样ConsumerQueue文件采取定长设计，每一个条目共20个字节，分别为8个字节的CommitLog物理偏移量，4字节的消息长度，8字节的tag hashcode，单个文件由30w个条目组成，可以像数组一样随机访问每一个条目，每个ConsumerQueue文件大小约5.72M；</li>
<li>IndexFile：IndexFile（索引文件）提供了一种可以通过key或者时间区间来查询消息的方法。Index文件的存储位置是：<code>$HOME \store\index$&#123;fileName&#125;</code>，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故RocketMQ的索引文件其底层实现为hash索引。</li>
</ul>
<p>从以上RocketMQ的消息存储整体架构图可以看出，RocketMQ采用的是混合型的存储结构，即单个实例下所有的队列共用一个日志数据文件（CommitLog）来存储。RocketMQ的混合型存储结构（多个Topic的消息实体内容都存储于一个CommitLog文件中）针对Producer和Consumer分别采用了数据和索引部分相分离的存储结构，Producer发送消息至Broker端，然后Broker端使用或者异步的方式对消息刷盘持久化，保存至CommitLog中。只要消息被刷盘持久化至磁盘文件CommitLog中，那么Producer发送的消息就不会丢失。正因为如此，Consumer也就肯定有机会去消费这条消息。当无法拉取到消息后，可以等下一次消息拉取，同时服务端也支持长轮询模式，如果一个消息拉取请求未拉取到消息，Broker允许等待30s的时间，只要这段时间内有新消息到达，将直接返回给消费端。这里，RocketMQ的具体做法是，使用Broker端的后台服务线程——ReputMessageService不停地分发请求并异步构建ConsumeQueue（逻辑消费队列）和IndexFile（索引文件）数据。</p>
<h4 id="页缓存与内存映射"><a class="markdownIt-Anchor" href="#页缓存与内存映射"></a> 页缓存与内存映射</h4>
<p>页缓存（PageCache）是OS对文件地缓存，用于加速对文件的读写。一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache。对于数据的读写，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其它相邻块的数据文件进行预读取。</p>
<p>在RocketMQ中，ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在PageCache机制的预读取作用下，ConsumeQueue文件的读性能几乎接近内存，即使在有消息堆积的情况下也不会影响性能，而对于CommitLog消息存储的日志数据来说，读取消息内容的时候会产生较多的随机访问读取，严重影响性能。如果选择合适的系统IO调度算法，比如设置调度算法为“Deadline”（此时块存储采用SSD的话），随机读的性能也会有所提升。</p>
<p>另外，RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（这种Mmap的方式减少了传统IO将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）。</p>
<h4 id="消息刷盘"><a class="markdownIt-Anchor" href="#消息刷盘"></a> 消息刷盘</h4>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211101233904.png" alt="RocketMQ消息刷盘" style="zoom:67%;" />
<p>刷盘的方式有以下两种：</p>
<ul>
<li>同步刷盘：如上图所示，只有在消息真正持久化至磁盘后RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应。同步刷盘时MQ消息可靠性来说是一种不错的保障，但是性能上会有较大的影响，一般适用于金融业务应用该模式较多</li>
<li>异步刷盘：能够充分利用OS的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量</li>
</ul>
<h3 id="通信机制"><a class="markdownIt-Anchor" href="#通信机制"></a> 通信机制</h3>
<p>RocketMQ消息队列集群主要包括NameServer、Broker（Master、Slave）、Producer、Consumer4个角色，基本通讯流程如下：</p>
<ul>
<li>Broker启动后需要完成一次将自己注册至NameServer的操作；随后每隔30s时间定时向NameServer上报Topic路由信息</li>
<li>消息生产者Producer作为客户端发送消息的时候，需要根据消息的Topic从本地缓存的TopicPublishInfoTable获取路由消息。如果没有则更新路由信息会从NameServer上重新拉取，同时Producer会默认每隔30s向NameServer拉取一次路由信息</li>
<li>消息生产者Producer会根据第二步中获取的路由信息选择一个队列（MessageQueue）进行消息发送；Broker作为消息的接收者接收消息并落盘存储</li>
<li>消息消费者Consumer会根据第二步中获取的路由信息，并在完成客户端的负载均衡后，选择其中的某一个或者几个消费队列来拉取消息并进行消费</li>
</ul>
<p>RoketMQ集群中的角色几乎都会进行通信，rocketmq-remoting模块是RocketMQ消息队列中负责网络通信的模块，它几乎被其它所有需要网络通信的模块（诸如rocketmq-client、rocketmq-broker、rocketmq-namesrv）所依赖和引用。为了实现客户端与服务器之间的高效的数据请求与结构，RocketMQ消息队列自定义了通信协议并在Netty的基础之上扩展了通信模块。</p>
<h4 id="rocketmq通信类结构"><a class="markdownIt-Anchor" href="#rocketmq通信类结构"></a> RocketMQ通信类结构</h4>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211102232119.png" alt="RocketMQ通信"  />
<p>在RocketMQ中使用了自定义协议，RemotingCommand这个类在消息传输过程中对所有数据内容的封装，不但包含了所有的数据结构，还包含了编解码的操作。</p>
<p>传输的内容主要分为4个部分：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211102232727.png" alt="传输内容" style="zoom:67%;" />
<p>详细含义如下：</p>
<ul>
<li>消息长度：总长度，四个字节存储，占用一个int类型</li>
<li>序列化类型&amp;消息长度：同样占用一个int类型，第一个字节表示序列化类型，后面三个字节表示消息头长度</li>
<li>消息头数据：经过序列化后的消息头数据</li>
<li>消息主体数据：消息主体的二进制字节数据内容</li>
</ul>
<h4 id="reactor线程设计"><a class="markdownIt-Anchor" href="#reactor线程设计"></a> Reactor线程设计</h4>
<p>RocketMQ的RPC通信采用Netty组件作为底层通信库，同样也遵循了Reactor线程模型，同时又在这之上做了一些扩展和优化。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211102233040.png" alt="Reactor线程模型"  />
<h3 id="消息过滤"><a class="markdownIt-Anchor" href="#消息过滤"></a> 消息过滤</h3>
<p>RocketMQ分布式消息队列的消息过滤方式有别于其它MQ中间件，是在Consumer端订阅消息时再做消息过滤的。RocketMQ这么做是在于其Producer端写入消息和Consumer订阅消息采用分离存储的机制来实现的。Consumer端订阅消息是需要通过ConsumerQueue这个消息消费的逻辑队列拿到一个索引，然后再从CommitLog里面读取真正的消息实体内容，所以说到底也还是绕不开其存储结构。其ConsumerQueue的存储结构如下，可以看到其中有8个字节存储的Message Tag的哈希值，基于Tag的消息过滤正是基于这个字段值的。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211102233703.png" alt="ConsumerQueue的存储结构" style="zoom:100%;" />
<p>主要支持如下两种的方式的过滤：</p>
<ul>
<li>Tag过滤方式：Consumer端在订阅消息时除了指定Topic还可以指定Tag，如果一个消息有多个TAG，可以用“||”分隔。其中，Conusmer端会将这个订阅请求构建成一个SubscriptionData，发送一个pull消息的请求给Broker端。Broker端从RocketMQ的文件存储层——Store读取数据之前，会用这些数据先构建一个MessageFilter，然后传给Store。Store从ConsumerQueue读取到一条记录后，会用它记录的消息tag hash值去做过滤，由于在服务端只是根据hashcode进行判断，无法精确对tag原始字符串进行过滤，故消息消费端拉取到消息后，还需要对消息的原始tag字符串进行比对，如果不同，则丢弃该消息，不进行消息消费</li>
<li>SQL92的过滤方式：这种方式的大致做法和上面Tag过滤方式一样，只是在Store层的具体过滤过程不太一样，真正的SQL expression的构建和执行由rocketmq-filter模块负责的。每次过滤都去执行SQL表达式会影响效率，所以RocketMQ使用了BloomFilter避免了每次都去执行。SQL92的表达式上下文为消息的属性</li>
</ul>
<h3 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h3>
<div class="note info"><p>消息消费队列在同一消费者组不同消费者之间的负载均衡，其核心设计理念是在一个消息队列时间在同一时间只允许被同一消费者组的一个消费者消费，一个消息消费者能同时消费多个消息队列。</p></div>
<h1 id="最佳实践"><a class="markdownIt-Anchor" href="#最佳实践"></a> 最佳实践</h1>
<h2 id="生产者"><a class="markdownIt-Anchor" href="#生产者"></a> 生产者</h2>
<h3 id="tags的使用"><a class="markdownIt-Anchor" href="#tags的使用"></a> Tags的使用</h3>
<p>一个应用尽可能用一个Topic，而消息子类型则可以用tags来标识。tags可以由应用自由设置，只有生产者在发送消息设置了tags，消费方在订阅消息时才可以利用tags通过broker做消息过滤：message.setTags(“TagsA||TagsB”)。</p>
<h3 id="keys的使用"><a class="markdownIt-Anchor" href="#keys的使用"></a> Keys的使用</h3>
<p>每个消息在业务层面的唯一标识码要设置到keys字段，方便来定位消息丢失问题。服务器会为每个消息创建索引（哈希索引），应用可以通过topic、key来查询这条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证key尽可能唯一，这样可以避免潜在的哈希冲突。</p>
<h3 id="选择oneway形式发送"><a class="markdownIt-Anchor" href="#选择oneway形式发送"></a> 选择oneway形式发送</h3>
<p>通常消息的发送时这样的一个过程：</p>
<ul>
<li>客户端发送请求到服务器</li>
<li>服务器处理请求</li>
<li>服务器向客户端返回应答</li>
</ul>
<p>所以，一次消息发送的耗时时间时上述三个步骤的总和，而某些场景要求耗时非常短，但是对可靠性要求并不高，例如日志收集类应用，此类应用可以采用oneway形式调用，oneway形式只发送请求不等待应答，而发送请求在客户端实现层面仅仅是一个操作系统调用的开销，即将数据写入客户端的socket缓冲区，此过程通常在微秒级。</p>
<h2 id="消费者"><a class="markdownIt-Anchor" href="#消费者"></a> 消费者</h2>
<h3 id="消费过程幂等"><a class="markdownIt-Anchor" href="#消费过程幂等"></a> 消费过程幂等</h3>
<p>RocketMQ无法避免消息重复（Exactly-Once），所以如果业务对消费重复非常敏感，务必要在业务层面进行去重处理。可以借助关系数据库进行去重。首先需要确定消息的唯一键，可以是msgId，也可以是消息内容中的唯一标识字段，例如订单id等。在消费之前判断唯一键是否在关系数据库中存在，如果不存在则插入，并消费，否则跳过（实际过程要考虑原子性问题，判断是否存在可以尝试插入，如果报主键冲突，则插入失败，直接跳过）。</p>
<p>msgId一定是全局唯一标识符，但是实际使用中，可能会存在相同的消息有两个不同的msgId的情况（消息主动重发、因客户端重投机制导致重复等），这种情况就需要业务字段进行重复消费。</p>
<h3 id="提升消费速度"><a class="markdownIt-Anchor" href="#提升消费速度"></a> 提升消费速度</h3>
<ul>
<li>
<p>提高消费并行度</p>
<p>绝大部分消息消费行为都属于IO密集型，即可能是操作数据库，或者调用RPC，这类消费行为的消费速度取决于后端数据库或者外部系统的吞吐量，通过增加消费并行度，可以提高总的消费吞吐量，但是并行度增加到一定程度，反而会下降。所以，应用必须设置合理的并行度，可以通过如下几种方式修改消费并行度的方法：</p>
<ul>
<li>同一个ConsumerGroup下，通过增加Consumer实例数量来提高并行度（需要注意的是超过订阅队列数的Consumer实例无效）。可以通过增加及其或者在已有机器启动多个进程的方式</li>
<li>提高单个Consumer的消费并行线程，通过修改参数consumerThreadMin、consumerThreadMax实现</li>
</ul>
</li>
<li>
<p>批量方式消费</p>
<ul>
<li>某些业务流程如果支持批量方式消费，则可以很大程度上提高消费吞吐量，例如订单扣款类应用，一次处理一个订单耗时1s，一次处理10个订单可能也只耗时2s，这样即可大幅度提高消费的吞吐量，通过设置consumer的consumerMessageBatchMaxSize参数，默认是1，即一次只消费一条消息，例如设置为N，那么每次消费的消息数小于等于N</li>
</ul>
</li>
<li>
<p>跳过非重要消息</p>
<p>发生消息堆积时，如果消费速度一直追不上发送的速度，如果业务对数据的要求不高的话，可以选择丢弃不重要的消息。例如，当队列的消息数堆积到100000条以上，则尝试丢弃部分或全部消息，这样就可以快速追上发送消息的速度，示例代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="params"><span class="function">        ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> offset = msgs.get(<span class="number">0</span>).getQueueOffset();</span><br><span class="line">    String maxOffset =</span><br><span class="line">            msgs.get(<span class="number">0</span>).getProperty(Message.PROPERTY_MAX_OFFSET);</span><br><span class="line">    <span class="keyword">long</span> diff = Long.parseLong(maxOffset) - offset;</span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="comment">// TODO 消息堆积情况的特殊处理</span></span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO 正常消费过程</span></span><br><span class="line">    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>优化每条消息消费过程</p>
<p>优化消息消费时的速度，可以优化消费流程，也可以将部分耗时的操作交由线程池处理</p>
</li>
</ul>
<h2 id="顺序消费"><a class="markdownIt-Anchor" href="#顺序消费"></a> 顺序消费</h2>
<h3 id="并发消费"><a class="markdownIt-Anchor" href="#并发消费"></a> 并发消费</h3>
<p>无序消息也指普通消息，Producer只管发送消息，Consumer只管接收消息，至于消息和消息之间的顺序并没有保证。</p>
<p>生产者并发消费的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">concurrentProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;op&quot;</span>);</span><br><span class="line">        producer.setNamespace(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] body = (<span class="string">&quot;Hi&quot;</span> + i).getBytes();</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicA&quot;</span>, <span class="string">&quot;TagA&quot;</span>, body);</span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            log.info(<span class="string">&quot;发送结果: &#123;&#125;&quot;</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者并发消费的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;op&quot;</span>);</span><br><span class="line">        consumer.setNamespace(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        consumer.start();</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt messageExt : list) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;并发消费: &#123;&#125;&quot;</span>, messageExt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺序消费-2"><a class="markdownIt-Anchor" href="#顺序消费-2"></a> 顺序消费</h3>
<p>顺序消息指的是，严格按照消息的发送顺序进行消费的消息（FIFO）。</p>
<p>默认情况下生产者会把消息以Round Robin轮询方式发送到不同的Queue分区队列；而消费消息时会从多个Queue上拉取消息，这种情况下的发送和消费是不能保证顺序的。如果将消息仅发送到同一个Queue中，消费时也只从这个Queue上拉取消息，就严格保证了消息的顺序性。</p>
<h4 id="全局有序"><a class="markdownIt-Anchor" href="#全局有序"></a> 全局有序</h4>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211104235910.png" alt="RocketMQ全局有序" style="zoom: 67%;" />
<p>当发送和消费参与的Queue只有一个时所保证的有序是整个Topic中消息的顺序，称为全局有序。创建Topic时指定Queue的数量有以下三种方式：</p>
<ul>
<li>在代码中创建Producer时，可以指定其自动创建的Topic的Queue的数量</li>
<li>在RocketMQ可视化控制台中手动创建Topic时指定Queue的数量</li>
<li>使用mqadmin命令手动创建Topic时指定Queue的数量</li>
</ul>
<h4 id="分区有序"><a class="markdownIt-Anchor" href="#分区有序"></a> 分区有序</h4>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211105000246.png" alt="RocketMQ分区有序" style="zoom:67%;" />
<p>如果有多个Queue参与，其仅可保证在该Queue分区队列上的消息顺序，则称为分区有序。那么我们该如何Queue的选择呢？在定义Producer的时候我们可以指定消息队列选择器，这个选择器是我们自己实现了MessageQueueSelector接口定义的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomMessageQueueSelector</span> <span class="keyword">implements</span> <span class="title">MessageQueueSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list    该Topic下所有可选的MessageQueue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 待发送的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o       send方法传入的第三个参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; list, Message message, Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义选择器的选择算法时，一般需要使用选择key。这个选择key可以是消息key也可以是其它数据。但无论谁做选择key，都不能重复，都是唯一的。</p>
<p>取模算法存在一个问题：不同选择key与Queue数量取模结果可能会是相同的，即不同选择key的消息可能会出现相同的Queue，即同一个Consumer可能会消费到不同选择key的消息。解决这个问题的一般性做法是，从消息中获取到选择key，对其进行判断，若是当前Consumer需要消费的消息，则直接消费。否则，什么也不做。这种做法要求选择key要能够随着消息一起被Consumer获取到，此时使用消息key作为选择key是比较好的做法。</p>
<p>以上做法会不会出现如下新的问题呢？不属于那个Consumer的消息被拉取走了，那么应该消费该消息的Consumer是否还能再消费该消息呢？同一个Queue中的消息不可能被同一个Group中的不同Consumer同时消费。所以，消费同一个Queue的不同选择key的消息的Consumer一定属于不同的Group，而不同的Group中的Consumer间的消费是相互隔离的，互不影响。</p>
<p>生产者顺序消费的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;op&quot;</span>);</span><br><span class="line">        producer.setNamespace(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Integer orderId = i;</span><br><span class="line">            <span class="keyword">byte</span>[] body = (<span class="string">&quot;Hi&quot;</span> + i).getBytes();</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicA&quot;</span>, <span class="string">&quot;TagA&quot;</span>, body);</span><br><span class="line">            <span class="comment">// 实现自定义的队列选择器</span></span><br><span class="line">            SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; list, Message message, Object o)</span> </span>&#123;</span><br><span class="line">                    Integer id = (Integer) o;</span><br><span class="line">                    <span class="keyword">int</span> index = id % list.size();</span><br><span class="line">                    <span class="keyword">return</span> list.get(index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, orderId);</span><br><span class="line">            log.info(<span class="string">&quot;发送结果: &#123;&#125;&quot;</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者顺序消费的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;op&quot;</span>);</span><br><span class="line">        consumer.setNamespace(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        consumer.start();</span><br><span class="line">        <span class="comment">// 这里必须是MessageListenerOrderly才会保证接收到的消息是有序的</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeOrderlyContext consumeOrderlyContext)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt messageExt : list) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;顺序消费: &#123;&#125;&quot;</span>, messageExt);</span><br><span class="line">                &#125;</span><br><span class="line">                consumeOrderlyContext.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="订阅关系的一致性"><a class="markdownIt-Anchor" href="#订阅关系的一致性"></a> 订阅关系的一致性</h2>
<p>在使用RocketMQ可能会出现消费者无法消费的情况，即<code>consume but filter</code>，这是因为订阅关系不一致导致的，订阅关系的一致性指的是，同一个消费者组（Group ID相同）下所有的Consumer实例所订阅的Topic与Tag及对消息的处理逻辑必须完全一致。否则，消息消费的逻辑就会混乱，甚至导致消息丢失。</p>
<h3 id="正确的订阅关系"><a class="markdownIt-Anchor" href="#正确的订阅关系"></a> 正确的订阅关系</h3>
<p>多个消费者组订阅了多个Topic，并且每个消费者组里的多个消费者实例的订阅关系保持了一致。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107115839.png" alt="正确的订阅关系" style="zoom:67%;" />
<h3 id="错误的订阅关系"><a class="markdownIt-Anchor" href="#错误的订阅关系"></a> 错误的订阅关系</h3>
<p>一个消费者组订阅了多个Topic，但是该消费者组里的多个Consumer实例的订阅关系并没有保持一致。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107120022.png" alt="错误的订阅关系" style="zoom:67%;" />
<h4 id="订阅了不同的topic"><a class="markdownIt-Anchor" href="#订阅了不同的topic"></a> 订阅了不同的Topic</h4>
<p>实例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">differentTopicConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;test_topic_A&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;消费消息: &#123;&#125;&quot;</span>, list);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">differentTopicConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;test_topic_B&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;消费消息: &#123;&#125;&quot;</span>, list);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上在同一个消费者组中的两个相同的Consumer实例订阅了不同的Topic，就会导致无法消费消息。</p>
<h4 id="订阅了不同tag"><a class="markdownIt-Anchor" href="#订阅了不同tag"></a> 订阅了不同Tag</h4>
<p>实例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">differentTagsConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group2&quot;</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;test_topic_A&quot;</span>, <span class="string">&quot;TagA&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;消费消息: &#123;&#125;&quot;</span>, list);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">differentTagsConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group2&quot;</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;test_topic_A&quot;</span>, <span class="string">&quot;TagB&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;消费消息: &#123;&#125;&quot;</span>, list);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同一个消费者组中的两个Consumer订阅了相同Topic的不同Tag也会导致无法消费，这也是实际开发中比较容易犯得错误。</p>
<h4 id="订阅不同数量的topic"><a class="markdownIt-Anchor" href="#订阅不同数量的topic"></a> 订阅不同数量的Topic</h4>
<p>实例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">differentNumberTopicConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;test_topic_B&quot;</span>, <span class="string">&quot;TagA&quot;</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;test_topic_B&quot;</span>, <span class="string">&quot;TagB&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;消费消息: &#123;&#125;&quot;</span>, list);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">differentNumberTopicConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;test_topic_B&quot;</span>, <span class="string">&quot;TagA&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;消费消息: &#123;&#125;&quot;</span>, list);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同一个消费者中的两个Consumer订阅了不同数量的Topic也会导致消费失败。</p>
<h1 id="springboot整合rocketmq"><a class="markdownIt-Anchor" href="#springboot整合rocketmq"></a> SpringBoot整合RocketMQ</h1>
<p>在之前的例子当中，我们都使用的是DefaultMQProducer/DefaultMQPushConsumer，通过设置一些参数来改变MQ的行为，但这种方式并没有那么的“Spring”，实际上，RocketMQ针对于SpringBoot也提供了相应的starter，使得RocketMQ可以做到“开箱即用”。</p>
<h2 id="配置管理"><a class="markdownIt-Anchor" href="#配置管理"></a> 配置管理</h2>
<h3 id="依赖管理"><a class="markdownIt-Anchor" href="#依赖管理"></a> 依赖管理</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.rocketmq/rocketmq-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>引入了这个依赖之后，就无需再引入rocketmq-client相应的依赖了。</p>
<h3 id="外部化配置"><a class="markdownIt-Anchor" href="#外部化配置"></a> 外部化配置</h3>
<p>在SpringBoot中，我们可以通过内置的配置项来改变Producer和Consumer的行为：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="comment"># 可以有多个，多个的情况使用;隔开</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">my-group</span></span><br><span class="line">    <span class="comment"># 开启消息轨迹，消费端需要在消费者中指定</span></span><br><span class="line">    <span class="attr">enable-msg-trace:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">customized-trace-topic:</span> <span class="string">my-trace-topic</span></span><br><span class="line">    <span class="comment"># ACL功能，消费端需要在消费者中指定</span></span><br><span class="line">    <span class="attr">access-key:</span> <span class="string">AK</span></span><br><span class="line">    <span class="attr">secret-key:</span> <span class="string">SK</span></span><br></pre></td></tr></table></figure>
<h3 id="配置类"><a class="markdownIt-Anchor" href="#配置类"></a> 配置类</h3>
<p>如果想要自定义更多的DefaultMQPushConsumer的其它配置，我们就需要采用如下的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;test-topic-1&quot;, consumerGroup = &quot;my-consumer_test-topic-1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer1</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">String</span>&gt;, <span class="title">RocketMQPushConsumerLifecycleListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;received message: &#123;&#125;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareStart</span><span class="params">(<span class="keyword">final</span> DefaultMQPushConsumer consumer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// set consumer consume message from now</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_TIMESTAMP);</span><br><span class="line">        	  consumer.setConsumeTimestamp(UtilAll.timeMillisToHumanString3(System.currentTimeMillis()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费消息的时候，除了获取消息payload外，还想获取RocketMQ消息的其它系统属性，那么我们在实现RocketMQListener接口时，只需要指定泛型为MessageExt即可，这样在onMessage方法就可以接收到RocketMQ原生的MessageExt消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;test-topic-1&quot;, consumerGroup = &quot;my-consumer_test-topic-1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer2</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">MessageExt</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;received messageExt: &#123;&#125;&quot;</span>, messageExt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送消息"><a class="markdownIt-Anchor" href="#发送消息"></a> 发送消息</h2>
<h3 id="发送普通消息"><a class="markdownIt-Anchor" href="#发送普通消息"></a> 发送普通消息</h3>
<p>发送消息的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerDemo</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 同步发送消息</span></span><br><span class="line">        rocketMQTemplate.convertAndSend(<span class="string">&quot;test-topic-1&quot;</span>, <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        <span class="comment">//send spring message</span></span><br><span class="line">        rocketMQTemplate.send(<span class="string">&quot;test-topic-1&quot;</span>, MessageBuilder.withPayload(<span class="string">&quot;Hello, World! I&#x27;m from spring message&quot;</span>).build());</span><br><span class="line">        <span class="comment">// 异步发送消息</span></span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;test-topic-2&quot;</span>, <span class="keyword">new</span> OrderPaidEvent(<span class="string">&quot;T_001&quot;</span>, <span class="keyword">new</span> BigDecimal(<span class="string">&quot;88.00&quot;</span>)), <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult var1)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;async onSucess SendResult=%s %n&quot;</span>, var1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable var1)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;async onException Throwable=%s %n&quot;</span>, var1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送单向消息</span></span><br><span class="line">        rocketMQTemplate.sendOneWay(<span class="string">&quot;springboot-topic:tag1&quot;</span>, <span class="string">&quot;这是一条单向消息&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步顺序发送</span></span><br><span class="line">        rocketMQTemplate.syncSendOrderly(<span class="string">&quot;orderly_topic&quot;</span>, MessageBuilder.withPayload(<span class="string">&quot;Hello, World&quot;</span>).build(), <span class="string">&quot;hashkey&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送多条</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            rocketMQTemplate.sendOneWayOrderly(<span class="string">&quot;springboot-topic:tag1&quot;</span>, <span class="string">&quot;这是一条顺序消息&quot;</span> + i, <span class="string">&quot;2673&quot;</span>);</span><br><span class="line">            rocketMQTemplate.sendOneWayOrderly(<span class="string">&quot;springboot-topic:tag1&quot;</span>, <span class="string">&quot;这是一条顺序消息&quot;</span> + i, <span class="string">&quot;2673&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 延迟发送</span></span><br><span class="line">        <span class="comment">// messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span></span><br><span class="line">        <span class="comment">// 这里设置4，即30s的延迟</span></span><br><span class="line">        Message&lt;String&gt; msg = <span class="keyword">new</span> GenericMessage&lt;&gt;(<span class="string">&quot;我是一条延迟消息&quot;</span>);</span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;topic-delay&quot;</span>, msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//发送成功</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//发送失败</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">100</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//rocketMQTemplate.destroy(); // notes: 一旦rocketMQTemplate被销毁了，就无法使用它来发送消息了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPaidEvent</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String orderId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> BigDecimal paidMoney;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发送事务消息"><a class="markdownIt-Anchor" href="#发送事务消息"></a> 发送事务消息</h3>
<p>发送事务消息的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Build a SpringMessage for sending in transaction</span></span><br><span class="line">        Message&lt;String&gt; msg = MessageBuilder.withPayload(<span class="string">&quot;...&quot;</span>).build();</span><br><span class="line">        <span class="comment">// In sendMessageInTransaction(), the first parameter transaction name (&quot;test&quot;)</span></span><br><span class="line">        <span class="comment">// must be same with the @RocketMQTransactionListener&#x27;s member field &#x27;transName&#x27;</span></span><br><span class="line">        rocketMQTemplate.sendMessageInTransaction(<span class="string">&quot;test&quot;</span>, msg, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define transaction listener with the annotation @RocketMQTransactionListener</span></span><br><span class="line">    <span class="meta">@RocketMQTransactionListener</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">RocketMQLocalTransactionListener</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RocketMQLocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ... local transaction process, return bollback, commit or unknown</span></span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.UNKNOWN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RocketMQLocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ... check transaction status and return bollback, commit or unknown</span></span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接收消息"><a class="markdownIt-Anchor" href="#接收消息"></a> 接收消息</h2>
<h3 id="接收普通消息"><a class="markdownIt-Anchor" href="#接收普通消息"></a> 接收普通消息</h3>
<p>接收普通消息的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="meta">@RocketMQMessageListener(topic = &quot;test-topic-1&quot;, consumerGroup = &quot;my-consumer_test-topic-1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer1</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;received message: &#123;&#125;&quot;</span>, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="meta">@RocketMQMessageListener(topic = &quot;test-topic-2&quot;, consumerGroup = &quot;my-consumer_test-topic-2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer2</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">OrderPaidEvent</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(OrderPaidEvent orderPaidEvent)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;received orderPaidEvent: &#123;&#125;&quot;</span>, orderPaidEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MessageModel：集群模式；广播模式</span></span><br><span class="line"><span class="comment">     * ConsumeMode：顺序消费；无序消费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="meta">@RocketMQMessageListener(topic = &quot;springboot-topic&quot;, consumerGroup = &quot;consumer-group&quot;,</span></span><br><span class="line"><span class="meta">            //selectorExpression = &quot;tag1&quot;,selectorType = SelectorType.TAG,</span></span><br><span class="line"><span class="meta">            messageModel = MessageModel.CLUSTERING, consumeMode = ConsumeMode.CONCURRENTLY)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;----------接收到rocketmq消息:&quot;</span> + message);</span><br><span class="line">            <span class="comment">// rocketmq会自动捕获异常回滚  (官方默认会重复消费16次)</span></span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收事务消息"><a class="markdownIt-Anchor" href="#接收事务消息"></a> 接收事务消息</h3>
<p>接收事务的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerApplication</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Build a SpringMessage for sending in transaction</span></span><br><span class="line">            Message msg = MessageBuilder.withPayload(..)...;</span><br><span class="line">            <span class="comment">// In sendMessageInTransaction(), the first parameter transaction name (&quot;test&quot;)</span></span><br><span class="line">            <span class="comment">// must be same with the @RocketMQTransactionListener&#x27;s member field &#x27;transName&#x27;</span></span><br><span class="line">            rocketMQTemplate.sendMessageInTransaction(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;test-topic&quot;</span>, msg, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            e.printStackTrace(System.out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define transaction listener with the annotation @RocketMQTransactionListener</span></span><br><span class="line">    <span class="meta">@RocketMQTransactionListener</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">RocketMQLocalTransactionListener</span> </span>&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> RocketMQLocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ... local transaction process, return bollback, commit or unknown</span></span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.UNKNOWN;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> RocketMQLocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ... check transaction status and return bollback, commit or unknown</span></span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rocketmq原理分析"><a class="markdownIt-Anchor" href="#rocketmq原理分析"></a> RocketMQ原理分析</h1>
<p>RocketMQ也遵循了模块化设计，其核心模块有：</p>
<ul>
<li>namesrv：命名发现服务，broker 服务的管理与路由</li>
<li>broker：核心组件，接收 producer发送的消息和消息的存储与consumer`的消息消费</li>
<li>client：客户端实现，producer和 consumer的实现模块</li>
<li>store：存储层实现，消息持久化、索引服务、高可用 HA 服务实现</li>
<li>remoting：通信层实现，基于 Netty 的底层封装，服务间的交互通讯都依赖此模块</li>
<li>filter：消息过滤服务，相当于在broker和consumer中间加入了一个 filter 代理</li>
<li>common：模块间通用的功能类、方法、配置文件、常量等</li>
<li>tools：命令管理工具，提供了消息查询、topic 管理等功能</li>
<li>example：官方提供的例子，对典型的功能比如 order message，push consumer，pull consumer 的用法进行了示范</li>
</ul>
<h2 id="消息发送过程"><a class="markdownIt-Anchor" href="#消息发送过程"></a> 消息发送过程</h2>
<p>首先创建一条即将发送的消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;Test&quot;</span>, <span class="string">&quot;Hello World&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>
<p>然后定义好消息的发送者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer();</span><br><span class="line">producer.start();</span><br></pre></td></tr></table></figure>
<p>发送消息的整体流程如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107223834.png" alt="image-20211107223834662" /></p>
<h3 id="选择发送的路由"><a class="markdownIt-Anchor" href="#选择发送的路由"></a> 选择发送的路由</h3>
<p>使用RocketMQ的时候通常我们都会使用集群部署：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107215834.png" style="zoom:67%;" />
<p>客户端在发送消息之前首先要询问NameServer才能确定一个合适的Broker以进行消息的发送：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107215941.png" alt="image-20211107215941618" style="zoom:67%;" />
<p>显然，所有的NameServer中的数据都是一致的，在Broker启动的时候，其会将自己在本地存储的Topic配置文件（默认位于<code>$HOME/store/config/topics.json</code>目录）中所有的Topic加载到内存中去，然后会将这些所有的Topic全部同步到所有的NameServer中，与此同时，Broker也会启动一个定时任务，默认每隔30s来执行一次Topic同步：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107220352.png" alt="image-20211107220352693" style="zoom:67%;" />
<p>由于NameServer服务去中每台机器存储的数据都是一致的，因为客户端任意选择一台服务器进行发送即可。客户端选择NameServer的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyRemotingClient</span> <span class="keyword">extends</span> <span class="title">NettyRemotingAbstract</span> <span class="keyword">implements</span> <span class="title">RemotingClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger namesrvIndex = <span class="keyword">new</span> AtomicInteger(initValueIndex());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">initValueIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> Math.abs(r.nextInt() % <span class="number">999</span>) % <span class="number">999</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Channel <span class="title">getAndCreateNameserverChannel</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String addr = <span class="keyword">this</span>.namesrvAddrChoosed.get();</span><br><span class="line">        <span class="keyword">if</span> (addr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ChannelWrapper cw = <span class="keyword">this</span>.channelTables.get(addr);</span><br><span class="line">            <span class="keyword">if</span> (cw != <span class="keyword">null</span> &amp;&amp; cw.isOK()) &#123;</span><br><span class="line">                <span class="keyword">return</span> cw.getChannel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; addrList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="keyword">this</span>.namesrvIndex.incrementAndGet();</span><br><span class="line">            index = Math.abs(index);</span><br><span class="line">            index = index % addrList.size();</span><br><span class="line">            String newAddr = addrList.get(index);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.namesrvAddrChoosed.set(newAddr);</span><br><span class="line">            Channel channelNew = <span class="keyword">this</span>.createChannel(newAddr);</span><br><span class="line">            <span class="keyword">if</span> (channelNew != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> channelNew;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以后，如果NamenamesrvAddrChoosed选择的服务器如果一直处于连接状态，那么客户端就会一直与这台服务器进行沟通。否则的话，如上源代码所示，就会自动轮询下一台可用的服务器。</p>
<p>在客户端发送消息的时候，其首先会尝试寻找话题路由信息，即这条消息应该被发送到哪个地方去。客户端在内存中维护了一份和Topic相关的路由信息表topicPublishInfoTable，当发送消息的时候，会首先尝试从表中获取信息。如果此表中不存在这条话题的话，那么便会从NameServer获取路由信息。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107221722.png" alt="image-20211107221722033" /></p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQProducerImpl</span> <span class="keyword">implements</span> <span class="title">MQProducerInner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TopicPublishInfo <span class="title">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">        TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">            topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当尝试从NameServer服务器获取路由的时候，其可能会返回两种情况：</p>
<ul>
<li>新建Topic</li>
<li>已存Topic</li>
</ul>
<p>当Topic是新建的，NameServer不存在和此Topic相关的信息：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107222224.png" alt="image-20211107222224495" /></p>
<p>Topic之前已经创建过，NameServer存在此Topic的信息：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107222435.png" alt="image-20211107222435046" /></p>
<p>服务器返回的Topic路由信息包括以下内容：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107222558.png" alt="image-20211107222558636" /></p>
<p>“Broker-1”、“Broker-2”分别为两个Broker服务器的名称，相同名称下可以有主从Broker，因此每个Broker又都有brokerId，默认情况下，BokerId如果为MixAll.Master_ID（值为0）的话，那么认为这个Broker为MASTER主机，其余位于相同名称下的Broker为这台MASTER主机的SLAVE从机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQClientInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findBrokerAddressInPublish</span><span class="params">(<span class="keyword">final</span> String brokerName)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Long<span class="comment">/* brokerId */</span>, String<span class="comment">/* address */</span>&gt; map = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span> &amp;&amp; !map.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(MixAll.MASTER_ID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个Broker上面可以绑定多个可写消息队列和多个可读消息队列，客户端根据返回的所有Broker地址列表和每个Broker的可写消息队列列表会在内存中构建一份所有的消息队列列表。之后客户端每次发送消息，都会在消息队列列表上轮询选择队列（这里我们假设返回了两个Broker，每个Broker均又4个可写消息队列）：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107223431.png" alt="image-20211107223431720" /></p>
<h3 id="向broker发送消息"><a class="markdownIt-Anchor" href="#向broker发送消息"></a> 向Broker发送消息</h3>
<p>在确定了Master Broker地址和这个Broker的消息队列之后，客户端才开始真正地发送消息给这个Broker，也是从这里客户端才开始与Broker进行交互：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107223723.png" alt="image-20211107223723904" style="zoom:67%;" />
<p>上节说到，如果Topic的信息在NameServer不存在的话，那么会使用默认的Topic信息进行消息的发送。然而一旦这条消息到来之后，Broker端还没有这个话题，所以Broker需要检查Topic的存在性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSendMessageProcessor</span> <span class="keyword">implements</span> <span class="title">NettyRequestProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RemotingCommand <span class="title">msgCheck</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">final</span> SendMessageRequestHeader requestHeader, <span class="keyword">final</span> RemotingCommand response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        TopicConfig topicConfig =</span><br><span class="line">            <span class="keyword">this</span>.brokerController</span><br><span class="line">                .getTopicConfigManager()</span><br><span class="line">                .selectTopicConfig(requestHeader.getTopic());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            topicConfig = <span class="keyword">this</span>.brokerController</span><br><span class="line">                .getTopicConfigManager()</span><br><span class="line">                .createTopicInSendMessageMethod( ... );</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果Topic不存在的话，那么便会创建一个Topic信息存储到本地，并将所有Topic同步给所有的NameServer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicConfigManager</span> <span class="keyword">extends</span> <span class="title">ConfigManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicConfig <span class="title">createTopicInSendMessageMethod</span><span class="params">(<span class="keyword">final</span> String topic, <span class="comment">/** params **/</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        topicConfig = <span class="keyword">new</span> TopicConfig(topic);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.topicConfigTable.put(topic, topicConfig);</span><br><span class="line">        <span class="keyword">this</span>.persist();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.brokerController.registerBrokerAll(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> topicConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Topic检查的整体的流程如下图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107224552.png" alt="Topic检查"  />
<p>当Broker对消息的一些字段做过一番必要的检查之后，便会存储到磁盘中去：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107223937.png" alt="消息存盘" style="zoom:67%;" />
<h2 id="消息存储过程"><a class="markdownIt-Anchor" href="#消息存储过程"></a> 消息存储过程</h2>
<h3 id="写入文件"><a class="markdownIt-Anchor" href="#写入文件"></a> 写入文件</h3>
<p>当有一条消息过来之后，Broker首先需要做的就是确定这条消息应该存储在哪个文件里面。在RokcetMQ中，这个用来存储消息的文件被称为MappedFile。这个文件默认创建的大小为1GB。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107225625.png" alt="image-20211107225625058" style="zoom:67%;" />
<p>一个文件为1GB大小，也即1024*1024*1024 = 1073741824字节，每个文件的命名是按照总的字节偏移量来命名的。例如一个第一个文件偏移量为0，那么它的名字为00000000000000000000，当这个1G文件被存储满了之后，就会创建下以恶搞文件，下一个文件的偏移量为1GB，那么它的名字为00000000001073741824，一次类推。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107230004.png" alt="image-20211107230004089" style="zoom:67%;" />
<p>默认情况下这些消息文件位于 <code>$HOME/store/commitlog</code> 目录下，如下图所示:</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107230106.png" alt="image-20211107230106222" /></p>
<p>当Broker启动的时候，其会将位于存储目录下的所有消息文件加载到一个列表中：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211107230237.png" alt="image-20211107230237636" /></p>
<p>当有新的消息到来的时候，其会默认选择列表中的最后一个文件来进行消息的保存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFileQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedFile <span class="title">getLastMappedFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MappedFile mappedFileLast = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.mappedFiles.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mappedFileLast = <span class="keyword">this</span>.mappedFiles.get(<span class="keyword">this</span>.mappedFiles.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                <span class="comment">//continue;</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;getLastMappedFile has exception.&quot;</span>, e);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mappedFileLast;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个Broker之前从未接收过消息的话，当有新的消息需要存储的时候，就需要立即创建一个MappedFile文件来存储消息。</p>
<p>RocketMQ提供了一个专门用来实例化MappedFile文件的服务类AllocateMappedFileService。在内存中，也同时也维护了一张请求表requestTable和一个优先级请求队列requestQueue。当需要创建文件的时候，Broker会创建一个AllocateRequest对象，其包含了文件的路径、大小等信息，然后将其存入requestTable表中，再将其放入优先级请求队列requestQueue中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocateMappedFileService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedFile <span class="title">putRequestAndReturnMappedFile</span><span class="params">(String nextFilePath,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    String nextNextFilePath,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="keyword">int</span> fileSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        AllocateRequest nextReq = <span class="keyword">new</span> AllocateRequest(nextFilePath, fileSize);</span><br><span class="line">        <span class="keyword">boolean</span> nextPutOK = <span class="keyword">this</span>.requestTable.putIfAbsent(nextFilePath, nextReq) == <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (nextPutOK) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">boolean</span> offerOK = <span class="keyword">this</span>.requestQueue.offer(nextReq);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务类会一直等待优先级队列是否有新的请求到来，如果有，便会从队列中取出请求，然后创建对应的MappedFile，并将请求表requestTable中AllocateRequest对象的字段mappedFile设置上值。最后将AllocateRequest对象上CountDownLatch的计数器减1，以表明此分配申请的MappedFile已经创建完毕了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocateMappedFileService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一直运行</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped() &amp;&amp; <span class="keyword">this</span>.mmapOperation()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">mmapOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        req = <span class="keyword">this</span>.requestQueue.take();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (req.getMappedFile() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            MappedFile mappedFile;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            mappedFile = <span class="keyword">new</span> MappedFile(req.getFilePath(), req.getFileSize());</span><br><span class="line">            <span class="comment">// 设置上值</span></span><br><span class="line">            req.setMappedFile(mappedFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 计数器减 1</span></span><br><span class="line">        req.getCountDownLatch().countDown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体流程如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211108233122.png" alt="image-20211108233122734" /></p>
<p>等待MappedFIle创建完毕之后，其便会从请求表requestTable中取出并删除表中记录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocateMappedFileService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedFile <span class="title">putRequestAndReturnMappedFile</span><span class="params">(String nextFilePath,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    String nextNextFilePath,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="keyword">int</span> fileSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        AllocateRequest result = <span class="keyword">this</span>.requestTable.get(nextFilePath);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待 MappedFile 的创建完成</span></span><br><span class="line">            <span class="keyword">boolean</span> waitOK = result.getCountDownLatch().await(waitTimeOut, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!waitOK) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 从请求表中删除</span></span><br><span class="line">                <span class="keyword">this</span>.requestTable.remove(nextFilePath);</span><br><span class="line">                <span class="keyword">return</span> result.getMappedFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再将其放到列表中去:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFileQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedFile <span class="title">getLastMappedFile</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startOffset, <span class="keyword">boolean</span> needCreate)</span> </span>&#123;</span><br><span class="line">        MappedFile mappedFile = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.allocateMappedFileService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建 MappedFile</span></span><br><span class="line">            mappedFile = <span class="keyword">this</span>.allocateMappedFileService</span><br><span class="line">                .putRequestAndReturnMappedFile(nextFilePath,</span><br><span class="line">                                               nextNextFilePath,</span><br><span class="line">                                               <span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 添加至列表中</span></span><br><span class="line">            <span class="keyword">this</span>.mappedFiles.add(mappedFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mappedFile;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211108233313.png" alt="image-20211108233313275" /></p>
<p>至此，<code>MappedFile</code> 已经创建完毕，也即可以进行下一步的操作了。</p>
<p>在MappedFile的构造函数中，其使用了FileChannel类提供的map函数来将磁盘上的这个文件映射到进程地址空间中。然后当通过MappedByteBuffer来读入或写入文件的时候，磁盘上也会有相应的改动。采用这种方式，通常比传统的基于文件IO流的方式读取效率高。</p>
<p>一旦我们获取到了MappedFile文件之后，便可以往这个文件里面写入消息了。写入消息可能会遇见如下两种情况，一种是这条消息可以完全追加到这个文件中，另一种是这条消息完全不能或者只有一小部分只能存放到这个文件中，其余的需要放到新的文件中，需要分为两种情况分别讨论。</p>
<h4 id="文件可以完全存储消息"><a class="markdownIt-Anchor" href="#文件可以完全存储消息"></a> 文件可以完全存储消息</h4>
<p>MappedFile类维护了一个用以标识当前写位置的指针wrotePosition，以及一个用来映射文件到进程地址空间的mappedByteBuffer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFile</span> <span class="keyword">extends</span> <span class="title">ReferenceResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> AtomicInteger wrotePosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> MappedByteBuffer mappedByteBuffer;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由这两个数据结构我们可以看出来，单个文件的消息写入过程其实非常简单，首先获取到这个文件的写位置，然后将消息内容追加到byteBuffer中，然后再更新写入位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFile</span> <span class="keyword">extends</span> <span class="title">ReferenceResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessagesInner</span><span class="params">(<span class="keyword">final</span> MessageExt messageExt, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentPos &lt; <span class="keyword">this</span>.fileSize) &#123;</span><br><span class="line">            ByteBuffer byteBuffer =</span><br><span class="line">                writeBuffer != <span class="keyword">null</span> ?</span><br><span class="line">                writeBuffer.slice() :</span><br><span class="line">                <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 byteBuffer 位置</span></span><br><span class="line">            byteBuffer.position(currentPos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写入消息内容</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 wrotePosition 指针的位置</span></span><br><span class="line">            <span class="keyword">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体的流程图如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211108235023.png" alt="image-20211108235023817" /></p>
<h4 id="文件不可以完全存储消息"><a class="markdownIt-Anchor" href="#文件不可以完全存储消息"></a> 文件不可以完全存储消息</h4>
<p>在写入消息之前，如果判断出文件已经满了的情况下，其会直接尝试创建一个新的MappedFile：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件为空 || 文件已经满了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">            mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果文件未满，那么在写入之前会先计算出消息长度msgLen，然后判断这个文件剩下的空间是否有能容纳这条消息。在这个地方我们还需要介绍下每条消息的存储方式。</p>
<p>每条消息的存储是按照一个4字节的长度来做界限的，这个长度本身就是整个消息体的长度，当读完这整条消息体的长度之后，下一次再取出来的一个4字节的数字，便又是下一条消息的长度：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211113112431.png" alt="image-20211113112431832" /></p>
<p>围绕一条消息，还会存储许多其它内容，我们这里只需要了解前两位是4字节的长度和4字节的MAGICCODE（魔数）即可：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211113112616.png" alt="image-20211113112616916" style="zoom: 80%;" />
<p>MAGICCODE的值可能会是：</p>
<ul>
<li><code>CommitLog.MESSAGE_MAGIC_CODE</code></li>
<li><code>CommitLog.BLANK_MAGIC_CODE</code></li>
</ul>
<p>当这个文件有能力容纳这条消息体的情况下，其便会存储CommitLog.MESSAGE_MAGIC_CODE值；当这个没有能力容纳这条消息的情况下，其便会存储CommitLog.BLANK_MAGIC_CODE值，所以这个MAGICCODE是用来界定这是空消息还是一条正常的消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CommitLog.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultAppendMessageCallback</span> <span class="keyword">implements</span> <span class="title">AppendMessageCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// File at the end of the minimum fixed length empty</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> END_FILE_MIN_BLANK_LENGTH = <span class="number">4</span> + <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">doAppend</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> fileFromOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">final</span> ByteBuffer byteBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">final</span> <span class="keyword">int</span> maxBlank,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">final</span> MessageExtBrokerInner msgInner)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 TOTALSIZE</span></span><br><span class="line">            <span class="keyword">this</span>.msgStoreItemMemory.putInt(maxBlank);</span><br><span class="line">            <span class="comment">// 2 MAGICCODE</span></span><br><span class="line">            <span class="keyword">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</span><br><span class="line">            <span class="comment">// 3 The remaining space may be any value</span></span><br><span class="line">            byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, maxBlank);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.END_OF_FILE,</span><br><span class="line">                                           <span class="comment">/** other params **/</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上述方法我们看出在这种情况下返回的结果是END_OF_FILE。当检测到这种返回结果的时候，CommitLog接着又会申请创建新的MappedFile并尝试写入消息：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211113114410.png" alt="image-20211113114410647" /></p>
<div class="note info"><p>在消息文件加载的过程中，其也是通过判断MAGICCODE的类型，来判断是否继续读取下一个MappedFile来计算整体消息偏移量的。</p></div>
<h3 id="消息刷盘-2"><a class="markdownIt-Anchor" href="#消息刷盘-2"></a> 消息刷盘</h3>
<p>当消息体追加到MappedFile以后，这条消息实际上还只是存储在内存中，因此还需要将内存中的内存刷到磁盘上才算真正的存储下来，才能确保消息不丢失。一般而言，刷盘有两种策略：异步刷盘和同步刷盘。</p>
<p>当配置为异步刷盘的时候，Broker会运行一个服务FlushRealTimeService用来刷新缓冲区的消息内容到磁盘，这个服务使用一个独立的线程来做刷盘这件事情，默认情况下每隔500ms来检查一次是否需要刷盘：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlushRealTimeService</span> <span class="keyword">extends</span> <span class="title">FlushCommitLogService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不停运行</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// interval 默认值是 500ms</span></span><br><span class="line">            <span class="keyword">if</span> (flushCommitLogTimed) &#123;</span><br><span class="line">                Thread.sleep(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.waitForRunning(interval);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 刷盘</span></span><br><span class="line">            CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在追加消息完毕之后，通过唤醒这个服务立即检查以下是否需要刷盘：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDiskFlush</span><span class="params">(AppendMessageResult result,</span></span></span><br><span class="line"><span class="params"><span class="function">                                PutMessageResult putMessageResult,</span></span></span><br><span class="line"><span class="params"><span class="function">                                MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Synchronization flush</span></span><br><span class="line">        <span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Asynchronous flush</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">                <span class="comment">// 消息追加成功后，立即唤醒服务</span></span><br><span class="line">                flushCommitLogService.wakeup();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当配置为同步刷盘策略的时候，Broker运行一个叫做GroupCommitService服务。在这个服务内部维护了写请求队列和一个读请求队列，其中这两个队列每隔10ms就交换一下“身份”，这么做的目的就是为了读写分离：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211108235940.png" alt="image-20211108235940275" style="zoom:67%;" />
<p>在这个服务内部，每隔10ms就会检查读请求队列是否不为空，如果不为空，则会将读队列中的所有请求执行刷盘，并清空读请求队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroupCommitService</span> <span class="keyword">extends</span> <span class="title">FlushCommitLogService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查所有读队列中的请求</span></span><br><span class="line">        <span class="keyword">for</span> (GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">            <span class="comment">// 每个请求执行刷盘</span></span><br><span class="line">            CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">            req.wakeupCustomer(flushOK);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.requestsRead.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在追加消息完毕之后，通常创建一个请求刷盘的对象，然后通过putRequest()方法放入写请求队列中，这个时候会立即唤醒这个服务，写队列和读队列的角色会进行交换，交换角色之后，读请求队列就不为空，继而可以执行所有刷盘请求了。而在这期间，Broker会一直阻塞等待最多5秒钟，在这期间如果完不成刷盘请求的话，那么视作刷盘超时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDiskFlush</span><span class="params">(AppendMessageResult result,</span></span></span><br><span class="line"><span class="params"><span class="function">                                PutMessageResult putMessageResult,</span></span></span><br><span class="line"><span class="params"><span class="function">                                MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Synchronization flush</span></span><br><span class="line">        <span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line">                GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">                service.putRequest(request);</span><br><span class="line">                <span class="comment">// 等待刷盘成功</span></span><br><span class="line">                <span class="keyword">boolean</span> flushOK = request.waitForFlush(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line">                <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">                    <span class="comment">// 刷盘超时</span></span><br><span class="line">                    putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Asynchronous flush</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过方法 <code>putRequest</code> 放入请求后的服务执行流程：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211109234713.png" alt="image-20211109234713144" style="zoom:67%;" />
<p>这里我们已经知道消息刷盘有同步刷盘和异步刷盘策略，对应的是GroupCommitService和FlushRealTimeService这两种不同的服务。这两种服务都有定时请求刷盘的机制，但是机制背后最终调用的方式都是flush方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFileQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">flush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再继续向下分析这个方法之前，我们先对照这这张图说明一下使用MappedByteBuffer来简要阐述读和写文件的简单过程：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211109235137.png" alt="image-20211109235137409" /></p>
<p>操作系统为了能够使多个进程同时使用内存，又保证各个进程访问内存互相独立，于是为每个进程引入了地址空间的概念，地址空间上的地址叫做虚拟地址，而程序想要运行必须放到物理地址上运行才可以。地址空间为进程营造了一种假象：“整台计算机只有我一个程序在运行，这台计算机内存很大”。一个地址空间内包含这个进程所需要的全部状态信息。通常一个进程的地址空间会按照逻辑分为好多段，比如代码段、堆段、栈段等。为了进一步有效利用内存，每一段又细分成了不同的页（Page）。与此相对对应，计算机的物理内存被切成了页帧（page frame），文件被分成了不同的页（Page）。与此相对应，计算机的物理内存被切成了页帧（Page frame），文件被分成了块（block）。既然程序实际运行的时候还是得依赖物理内存的地址，那么就需要将虚拟地址转换为物理地址，这个映射关系是由**页表（Page table）**来完成的。</p>
<p>另外在操作系统中，还有一层磁盘缓存（disk cache）的概念，它主要是用来减少对磁盘的I/O操作。磁盘缓存是以页为单位的，内容就是磁盘上的物理块，所以又称为页缓存（Page chae）。当进程发起一个读操作（比如，进行发起了一个read()系统调用），它首先会检查需要的数据是否在页缓存中。如果在，则放弃访问磁盘，而直接从页缓存中读取。如果数据没有在缓存中，那么内核必须调度块I/O操作从磁盘去读取数据，然后将读来的数据放入页缓冲中。系统并不一定要将整个文件都缓存，它可以只存储一个文件的一页或者几页。</p>
<p>如图所示，当调用FileChannel.map()方法的时候，会将这个文件映射进用户空间的地址空间中，注意，建立映射不会拷贝任何数据。我们前面提到过Broker启动的时候会有一个消息文件加载的过程，当第一次开始读取数据的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首次读取数据</span></span><br><span class="line"><span class="keyword">int</span> totalSize = byteBuffer.getInt();</span><br></pre></td></tr></table></figure>
<p>这个时候，操作系统通过查询页表，会发现文件的这部分数据还不在内存中。于是就会触发一个缺页异常（page faults），这个时候操作系统会开始从磁盘读取这一页数据，然后放入到页缓存中，然后再放入内存中。在第一次读取文件的时候，操作系统会读入所请求的页面，并读入紧随其后的少数几个页面（不少于一个页面，通常是三个页面），这时的预读称为同步预读（如下图所示，红色部分是需要读取的页面，蓝色的那三个框是操作系统预先读取的）：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211111233553.png" alt="image-20211111233552919" style="zoom:67%;" />
<p>当随着时间推移，预读命中的话，那么相应的预读页面数量也会增加，但是能够确认的是，一个文件至少有4个页面处于页缓存中。当文件一直处于顺序读取的情况下，那么基本上可以保证每次预读命中：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211111233846.png" alt="image-20211111233846690" style="zoom:67%;" />
<p>下面我们来说文件写，正常情况下，当尝试调用writeInt()写数据到文件里面的话，其写到页缓存层，这个方法就会返回了，这个时候数据还没有真正的保存到文件中去，Linux仅仅将页缓存中的这一页数据标记为“脏”，并且被加入到脏页链表中，然后由一群进程（flusher回写进程）周期性将脏页链表中的页写到磁盘，从而让磁盘中的数据和内存中保持一致，最后清理“脏”标识。在以下三种情况下，脏页会被写回磁盘：</p>
<ul>
<li>空闲内存低于一个特定阈值</li>
<li>脏页在内存中驻留超过一个特定的阈值时</li>
<li>当用户进程调用sync()和fsync系统调用时</li>
</ul>
<p>可见，在正常情况下，即使不采用刷盘策略，数据最终也是会被同步到磁盘中去的：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211111234937.png" alt="image-20211111234937867" style="zoom:67%;" />
<p>但是，即便由flusher线程来定时同步数据，如果此时机器断电的话，消息依然有可能丢失。RocketMQ为了保证消息尽可能的不丢失，为了最大的高可靠性，做了同步和异步刷盘策略，来手动进行同步：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211111235132.png" alt="image-20211111235132052" style="zoom:67%;" />
<p>在理解了消息刷盘背后的一些机制和理念后，我们再来分析刷盘的整个过程。首先，无论同步刷盘还是异步刷盘，其线程都在一直周期性的尝试执行刷盘，在真正执行刷盘函数的调用之前，Broker会检查文件的写位置是否大于flush位置，避免执行无意义的刷盘：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211111235433.png" alt="image-20211111235433232" style="zoom:67%;" />
<p>其次，对于异步刷盘来讲，Broker执行了更为严格的刷盘限制策略，当在某个时间点尝试执行刷盘之后，在接下来10秒内，如果想要继刷盘，那么脏页面数量必须不小于4页，如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211111235602.png" alt="image-20211111235602869" style="zoom:67%;" />
<p>下面时执行刷盘前最后检查的刷盘条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFile</span> <span class="keyword">extends</span> <span class="title">ReferenceResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAbleToFlush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flush = <span class="keyword">this</span>.flushedPosition.get();</span><br><span class="line">        <span class="keyword">int</span> write = getReadPosition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flushLeastPages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算当前脏页面算法</span></span><br><span class="line">            <span class="keyword">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= flushLeastPages;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wrotePosition &gt; flushedPosition</span></span><br><span class="line">        <span class="keyword">return</span> write &gt; flush;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当刷盘完毕之后，首先会更新这个文件的flush位置，然后再更新MappedFileQueue的整体的flush位置：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211111235758.png" alt="image-20211111235758236" style="zoom:67%;" />
<p>当刷盘完毕之后，便会将结果通知给客户端，告知发送消息成功，至此，整个存储过程完毕。</p>
<h2 id="消息接收过程"><a class="markdownIt-Anchor" href="#消息接收过程"></a> 消息接收过程</h2>
<h3 id="消费者注册"><a class="markdownIt-Anchor" href="#消费者注册"></a> 消费者注册</h3>
<p>生产者负责往服务器Broker发送消息，消费者则从Broker获取消息。消费者获取消息采用的订阅者模式，即消费者客户端可以订阅一个或者多个Topic来消费消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 订阅一个或者多个Topic</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当消费者客户端启动以后，其会每隔30s从命名服务器查询一次用户订阅的所有topic路由信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQClientInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 从命名服务器拉取话题信息</span></span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.updateTopicRouteInfoFromNameServer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们提到过，RocketMQ在发送消息的时候，每条消息会以轮询的方式均衡地分发到不同Broker的不同队列去。因此，消费者客户端从服务器获取下来的便是Topic的所有消息队列：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211113115530.png" alt="image-20211113115530436" style="zoom:67%;" />
<p>在获取话题路由信息的时候，客户端还会将Topic的路由信息中所有Broker地址保存到本地：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQClientInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateTopicRouteInfoFromNameServer</span><span class="params">(<span class="keyword">final</span> String topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="keyword">boolean</span> isDefault,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      DefaultMQProducer defaultMQProducer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            TopicRouteData cloneTopicRouteData = topicRouteData.cloneTopicRouteData();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 Broker 地址列表</span></span><br><span class="line">            <span class="keyword">for</span> (BrokerData bd : topicRouteData.getBrokerDatas()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.brokerAddrTable.put(bd.getBrokerName(), bd.getBrokerAddrs());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当消费者客户端获取到了Broker地址列表之后，其便会每隔30s给服务器发送一条心跳数据包，告知所有Broker服务器这台消费者客户端的存在。在每次发送心跳包的同时，其数据包内还会捎带这个客户端消息订阅的一些组信息，比如用户订阅了哪些topic等，与此相对应，每台Broker服务器会在内存中维护一份当前所有的消费者客户端列表信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerManager</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* Group */</span>, ConsumerGroupInfo&gt; consumerTable =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConsumerGroupInfo&gt;(<span class="number">1024</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者客户端与 Broker 服务器进行沟通的整体流程如下图所示：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211113120120.png" alt="image-20211113120120162" /></p>
<h3 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h3>
<p>我们知道无论发送消息还是接收消息都需要指定消息的topic，然后实际上消息在Broker服务器上并不是以topic为单位进行存储的，而是采用了比topic更细粒度的队列来进行存储的。当发送了10条相同topic的消息，这10条topic可能存储在了不同的Broker服务器的不同的队列中，因此，RokcetMQ管理消息的单位不是topic，而是队列。</p>
<p>当我们讨论消息队列负载均衡的时候，就是在讨论服务器端的所有队列如何给所有消费者消费的问题。在RocketMQ中，客户端有两种消费模式，一种是广播模式，另一种是集群模式。</p>
<p>我们现在假设总共有两台Broker服务器，假设用户使用Producer已经发送了8条消息，这8条消息现在均衡的分布在两台Broker服务器的8个队列中，每个队列中有一个消息。现在有3台都订阅了Test topic的消费者实例，我们来看在不同消费模式下，不同的消费者会收到那几条消息。</p>
<h4 id="广播模式"><a class="markdownIt-Anchor" href="#广播模式"></a> 广播模式</h4>
<p>广播模式是指所有消息队列中的消息都会广播给所有的消费者客户端，如下图所示，每一个消费者都能收到这8条消息：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114125450.png" alt="image-20211114125450124" style="zoom:67%;" />
<h4 id="集群模式"><a class="markdownIt-Anchor" href="#集群模式"></a> 集群模式</h4>
<p>集群模式是指所有的消息队列会按照某种分配策略来分配给不同的消费者客户端，比如消费者A消费前3个队列中的消息，消费者B消费中间3个队列中的消息等等。RocketMQ为我们提供了三个比较重要的消息队列分配策略：</p>
<ul>
<li>平均分配策略</li>
<li>平均分配轮询策略</li>
<li>一致性哈希策略</li>
</ul>
<h5 id="平均分配策略"><a class="markdownIt-Anchor" href="#平均分配策略"></a> 平均分配策略</h5>
<p>在平均分配策略下，三个消费者的消费情况如下所示：</p>
<ul>
<li>Consumer-1消费前3个消息队列中的消息</li>
<li>Consumer-2消费中间3个消息队列中的消息</li>
<li>Consumer-3消费最后2个消息队列中的消息</li>
</ul>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114130108.png" alt="image-20211114130108058" style="zoom:67%;" />
<h5 id="平均分配轮询策略"><a class="markdownIt-Anchor" href="#平均分配轮询策略"></a> 平均分配轮询策略</h5>
<p>平均分配轮询策略下，三个消费者的消费情况如下所示：</p>
<ul>
<li>Consumer-1消费1、4、7消息队列中的消息</li>
<li>Consumer-2消费2、5、8消息队列中的消息</li>
<li>Consumer-3消费3、6消息队列中的消息</li>
</ul>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114130507.png" alt="image-20211114130506983" style="zoom:67%;" />
<h5 id="一致性哈希策略"><a class="markdownIt-Anchor" href="#一致性哈希策略"></a> 一致性哈希策略</h5>
<p>一致性哈希算法是根据这三台消费者各自的某个有代表性的属性（我们假设就是客户端ID）来计算出Hash值，此处为了减少由于哈希函数选取不理想的情况，RocketMQ算法对于每个消费者通过在客户端ID后面添加1、2、3索引来使每一个消费者多生成几个哈希值。那么现在我们需要哈希的就是九个字符串：</p>
<ul>
<li>Consumer-1-1</li>
<li>Consumer-1-2</li>
<li>Consumer-1-3</li>
<li>Consumer-2-1</li>
<li>Consumer-2-2</li>
<li>Consumer-2-3</li>
<li>Consumer-3-1</li>
<li>Consumer-3-2</li>
<li>Consumer-3-3</li>
</ul>
<p>计算完这9个哈希值以后，我们按照从到大的顺序来排列成一个环（如图所示）。这个时候我们需要对这个8个消息队列也计算一下哈希值，当哈希值落在两个圈之间的时候，我们就选取沿着环的方向的那个结点作为这个消息队列的消费者。如下图所示（注意：图只是示例，并非真正的消费情况）：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114131458.png" alt="image-20211114131458279" style="zoom:67%;" />
<p>消息队列的负载均衡是由一个不停运行的均衡服务来定时执行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RebalanceService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认 20 秒一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> waitInterval =</span><br><span class="line">        Long.parseLong(System.getProperty(<span class="string">&quot;rocketmq.client.rebalance.waitInterval&quot;</span>, <span class="string">&quot;20000&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.waitForRunning(waitInterval);</span><br><span class="line">            <span class="comment">// 重新执行消息队列的负载均衡</span></span><br><span class="line">            <span class="keyword">this</span>.mqClientFactory.doRebalance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在广播模式下，当前这台消费者消费和Topic相关的所有消息队列，而集群模式会先按照某种分配策略来进行消息队列的分配，得到的结果就是当前这台消费者需要消费的消息队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RebalanceImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalanceByTopic</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (messageModel) &#123;</span><br><span class="line">            <span class="comment">// 广播模式</span></span><br><span class="line">        <span class="keyword">case</span> BROADCASTING: &#123;</span><br><span class="line">            <span class="comment">// 消费这个话题的所有消息队列</span></span><br><span class="line">            Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">            <span class="keyword">if</span> (mqSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// 集群模式</span></span><br><span class="line">        <span class="keyword">case</span> CLUSTERING: &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按照某种负载均衡策略进行消息队列和消费客户端之间的分配</span></span><br><span class="line">            <span class="comment">// allocateResult 就是当前这台消费者被分配到的消息队列</span></span><br><span class="line">            allocateResult = strategy.allocate(</span><br><span class="line">                                               <span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                                               <span class="keyword">this</span>.mQClientFactory.getClientId(),</span><br><span class="line">                                               mqAll,</span><br><span class="line">                                               cidAll);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="broker消费队列"><a class="markdownIt-Anchor" href="#broker消费队列"></a> Broker消费队列</h3>
<p>我们再来看Broker服务器端，首先我们应该知道，消息往Broker存储就是在向CommitLog消息文件中写入数据的一个过程。在Broker启动过程中，其会启动一个叫做ReputMessageService的服务，这个服务每隔1秒就会检查一下这个CommitLog是否有新的数据写入。ReputMessageService自身维护了一个偏移量reputFromOffset，用以对比和CommitLog文件中的消息总偏移量的差距。当这两个偏移量不同的时候，就代表有新的消息到来了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReputMessageService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> reputFromOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCommitLogAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 看当前有没有新的消息到来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.reputFromOffset &lt; DefaultMessageStore.<span class="keyword">this</span>.commitLog.getMaxOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">this</span>.doReput();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                DefaultMessageStore.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在有新的消息到来之后，doReput函数会取出新到来的所有消息，每一条消息都会封装为一个DispatchRequest请求，进行将这条请求分发给不同的请求消费者，这里我们只关注利用消息创建消息队列的服务CommitLogDispatcherBuildConsumeQueue：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReputMessageService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 部分代码有删减</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SelectMappedBufferResult result = DefaultMessageStore.<span class="keyword">this</span>.commitLog.getData(reputFromOffset);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reputFromOffset = result.getStartOffset();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> readSize = <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</span><br><span class="line">                <span class="comment">// 读取一条消息，然后封装为 DispatchRequest</span></span><br><span class="line">                DispatchRequest dispatchRequest =</span><br><span class="line">                    DefaultMessageStore.<span class="keyword">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">int</span> size = dispatchRequest.getMsgSize();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                    <span class="comment">// 分发这个 DispatchRequest 请求</span></span><br><span class="line">                    DefaultMessageStore.<span class="keyword">this</span>.doDispatch(dispatchRequest);</span><br><span class="line">                    <span class="keyword">this</span>.reputFromOffset += size;</span><br><span class="line">                    readSize += size;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CommitLogDispatcherBuildConsumeQueue服务会根据这条请求按照不同的队列ID创建不同的消费队列文件，并在内存中维护一份消费队列列表。然后将DispatchRequest请求中这条消息的消息偏移量、消息大小以及消息在发送的时候附带的标签的哈希值写入到相应的消费队列文件中去。</p>
<p>寻找消费队列的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMessageStore</span> <span class="keyword">implements</span> <span class="title">MessageStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* topic */</span>, ConcurrentMap&lt;Integer<span class="comment">/* queueId */</span>, ConsumeQueue&gt;&gt; consumeQueueTable;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfo</span><span class="params">(DispatchRequest dispatchRequest)</span> </span>&#123;</span><br><span class="line">        ConsumeQueue cq = <span class="keyword">this</span>.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId());</span><br><span class="line">        cq.putMessagePositionInfoWrapper(dispatchRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向消费队列文件中存储数据的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">putMessagePositionInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">int</span> size, <span class="keyword">final</span> <span class="keyword">long</span> tagsCode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">final</span> <span class="keyword">long</span> cqOffset)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储偏移量、大小、标签码</span></span><br><span class="line">        <span class="keyword">this</span>.byteBufferIndex.flip();</span><br><span class="line">        <span class="keyword">this</span>.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);</span><br><span class="line">        <span class="keyword">this</span>.byteBufferIndex.putLong(offset);</span><br><span class="line">        <span class="keyword">this</span>.byteBufferIndex.putInt(size);</span><br><span class="line">        <span class="keyword">this</span>.byteBufferIndex.putLong(tagsCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取消费队列文件</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> expectLogicOffset = cqOffset * CQ_STORE_UNIT_SIZE;</span><br><span class="line">        MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(expectLogicOffset);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> mappedFile.appendMessage(<span class="keyword">this</span>.byteBufferIndex.array());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上阐述了消费队列创建并存储消息的一个过程，但是消费队列中的消息是需要持久化到磁盘中去的。持久化的过程是通过后台服务FlushConsumeQueueService来定时持久化的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlushConsumeQueueService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doFlush</span><span class="params">(<span class="keyword">int</span> retryTimes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        ConcurrentMap&lt;String, ConcurrentMap&lt;Integer, ConsumeQueue&gt;&gt; tables = DefaultMessageStore.<span class="keyword">this</span>.consumeQueueTable;</span><br><span class="line">        <span class="keyword">for</span> (ConcurrentMap&lt;Integer, ConsumeQueue&gt; maps : tables.values()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ConsumeQueue cq : maps.values()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; retryTimes &amp;&amp; !result; i++) &#123;</span><br><span class="line">                    <span class="comment">// 刷新到磁盘</span></span><br><span class="line">                    result = cq.flush(flushConsumeQueueLeastPages);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述过程体现在磁盘文件的变化如下图所示，commitLog文件夹下面存放的是完整的消息，来一条消息，向文件中追加一条消息。同时，根据这一条消息属于TopicTest Topic下的哪一个队列，又会往相应的consumequeue文件下的相应消费队列文件中追加消息的偏移量、消息大小和标签码：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114151056.png" alt="image-20211114151056635" style="zoom:67%;" />
<p>总流程图如下所示：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114151124.png" alt="image-20211114151123921" /></p>
<p>Broker服务器存储了各个消息队列，客户端需要消费每隔消费队列中的消息。消费模式的不同，每个客户端所消费的消息队列也不同，那么客户端如何记录自己所消费得队列消费到哪里了呢？答案就是消费队列偏移量。</p>
<p>针对同一个Topic，在集群模式下，由于每个客户端所消费的消息队列不同，所以每个消息队列已经消费到哪里的消费偏移量是记录在Broker服务器端的。而在广播模式下，由于每个客户端分配消费这个Topic的所有消息队列，所以每个消息队列已经消费到哪里的消费偏移量是记录在客户端本地的。</p>
<p>下面分别讲述两种模式下偏移量是如何获取和更新的。</p>
<h4 id="集群模式-2"><a class="markdownIt-Anchor" href="#集群模式-2"></a> 集群模式</h4>
<p>在集群模式下，消费者客户端在内存中维护了一个offsetTable表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteBrokerOffsetStore</span> <span class="keyword">implements</span> <span class="title">OffsetStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;MessageQueue, AtomicLong&gt; offsetTable =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt;();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样在Broker服务器端也维护了一个偏移量表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerOffsetManager</span> <span class="keyword">extends</span> <span class="title">ConfigManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String<span class="comment">/* topic@group */</span>, ConcurrentMap&lt;Integer, Long&gt;&gt; offsetTable =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;Integer, Long&gt;&gt;(<span class="number">512</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在消费者客户端，RebalanceService服务会定时地（默认20秒）从Broker服务器获取当前客户端所需要消费的消息队列，并于当前消费客户端的消费队列进行对比，看是否有变化。对于每个消费队列，会从Broker服务器查询这个队列当前的消费偏移量。然后根据这几个消费队列，创建对应的拉取请求PullRequest准备从Broker服务器拉取消息，如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114152641.png" alt="image-20211114152641194" style="zoom:67%;" />
<p>当从Broker服务器拉取下来消息以后，只有当用户成功消费的时候，才会更新本地的偏移量表。本地的偏移量表再通过定时服务每隔5s同步到Broker服务器端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQClientInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.persistAllConsumerOffset();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而维护在 Broker 服务器端的偏移量表也会每隔 5 秒钟序列化到磁盘中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.consumerOffsetManager.persist();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存的格式如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114152848.png" alt="" /></p>
<p>上述整体流程如下所示，红框框住的是这个Topic下面的队列的id，箭头指向的分别是每个队列的消费偏移量：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114153026.png" alt="" /></p>
<h4 id="广播模式-2"><a class="markdownIt-Anchor" href="#广播模式-2"></a> 广播模式</h4>
<p>对于广播模式而言，每个消费队列的偏移量肯定不能存储在Broker服务器端，因为多个消费者对于同一个队列的消费可能是不一致的，偏移量会互相覆盖掉。因此，在广播模式下，每个客户端的消费偏移量是存储在本地的，然后每隔5将内存中的offsetTable持久化到磁盘中。当首次从服务器获取可消费队列的时候，偏移量不像集群模式下是从Broker服务器读取的，而是直接从本地文件读取的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalFileOffsetStore</span> <span class="keyword">implements</span> <span class="title">OffsetStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> ReadOffsetType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mq != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">             <span class="keyword">case</span> READ_FROM_STORE: &#123;</span><br><span class="line">                <span class="comment">// 本地读取</span></span><br><span class="line">                offsetSerializeWrapper = <span class="keyword">this</span>.readLocalOffset();</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114163325.png" alt="image-20211114163325520" /></p>
<p>当消息消费成功后，偏移量的更新也是持久化到本地，而非更新到Broker服务器中。在广播模式下，消息队列的偏移量默认是放在用户目录下的.rocketmq_offsets目录下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalFileOffsetStore</span> <span class="keyword">implements</span> <span class="title">OffsetStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistAll</span><span class="params">(Set&lt;MessageQueue&gt; mqs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        String jsonString = offsetSerializeWrapper.toJson(<span class="keyword">true</span>);</span><br><span class="line">        MixAll.string2File(jsonString, <span class="keyword">this</span>.storePath);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储格式如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114163639.png" alt="image-20211114163638987" style="zoom:67%;" />
<p>简要流程如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114163703.png" alt="image-20211114163703851" /></p>
<h3 id="消费消息"><a class="markdownIt-Anchor" href="#消费消息"></a> 消费消息</h3>
<p>RocketMQ在客户端运行着一个专门用来拉取消息的后台服务PullMessageService，其接受每个队列创建PullRequest拉取消息请求，然后拉取消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullMessageService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">            PullRequest pullRequest = <span class="keyword">this</span>.pullRequestQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (pullRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.pullMessage(pullRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个PullRequest都关联着一个MessageQueue和一个ProcessQueue，在ProcessQueue的内部还维护了一个用来等待用户消费的消息树，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageQueue messageQueue;</span><br><span class="line">    <span class="keyword">private</span> ProcessQueue processQueue;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class="keyword">new</span> TreeMap&lt;Long, MessageExt&gt;();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当真正尝试拉取消息之前，其会检查当前请求的内部缓存的消息数量、消息大小、消息阈值跨度是否超过了某个阈值，如果超过某个阈值，则推迟50毫秒重新执行这个请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQPushConsumerImpl</span> <span class="keyword">implements</span> <span class="title">MQConsumerInner</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</span><br><span class="line">        <span class="keyword">long</span> cachedMessageCount = processQueue.getMsgCount().get();</span><br><span class="line">        <span class="keyword">long</span> cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存消息数量阈值，默认为 1000</span></span><br><span class="line">        <span class="keyword">if</span> (cachedMessageCount &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存消息大小阈值，默认为 100 MB</span></span><br><span class="line">        <span class="keyword">if</span> (cachedMessageSizeInMiB &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.consumeOrderly) &#123;</span><br><span class="line">            <span class="comment">// 最小偏移量和最大偏移量的阈值跨度，默认为 2000 偏移量，消费速度不能太慢</span></span><br><span class="line">            <span class="keyword">if</span> (processQueue.getMaxSpan() &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行完一些必要的检查之后，客户端会将用户指定的过滤信息以及一些其它必要消费字段封装到请求信息体中，然后才开始从Broker服务器拉取这个请求从当前偏移量开始的消息，默认一次性最多拉取32条，服务器返回的响应会告诉客户端这个队列下次开始拉取时的偏移量。客户端每次都会注册一个PullCallback回调，用以接收服务器返回的响应信息，根据响应信息的不同状态信息，然后修正这个请求的偏移量，并进行下次请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    PullCallback pullCallback = <span class="keyword">new</span> PullCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(PullResult pullResult)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (pullResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                    <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> FOUND:</span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        </span><br><span class="line">                    <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        </span><br><span class="line">                    <span class="keyword">case</span> NO_MATCHED_MSG:</span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        </span><br><span class="line">                    <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        </span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述是客户端拉取消息时的一些机制，现在再说一下Broker服务器端于此相对应的逻辑。</p>
<p>服务器在收到客户端的请求之后，会根据Topic和队列ID定位到对应的消费队列。然后根据这条请求传入的offset消费队列偏移量，定位到对应的消费队列文件。偏移量指定的是消费队列文件的消费下限，而最大上限是由如下算法来进行约束的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxFilterMessageCount = Math.max(<span class="number">16000</span>, maxMsgNums * ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br></pre></td></tr></table></figure>
<p>有了上限和下限，客户端便会开始从消费队列文件中取出每个消息的偏移量和消息大小，然后再根据这两个值去CommitLog文件中寻找相应的完整的消息，并添加到最后的消息队列中，精简过的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMessageStore</span> <span class="keyword">implements</span> <span class="title">MessageStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GetMessageResult <span class="title">getMessage</span><span class="params">(<span class="keyword">final</span> String group, <span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">final</span> <span class="keyword">int</span> maxMsgNums,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">final</span> MessageFilter messageFilter)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (consumeQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 首先根据消费队列的偏移量定位消费队列</span></span><br><span class="line">            SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset);</span><br><span class="line">            <span class="keyword">if</span> (bufferConsumeQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 最大消息长度</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> maxFilterMessageCount = Math.max(<span class="number">16000</span>, maxMsgNums * ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">                    <span class="comment">// 取消息</span></span><br><span class="line">                    <span class="keyword">for</span> (; i &lt; bufferConsumeQueue.getSize() &amp;&amp; i &lt; maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">                        <span class="keyword">long</span> offsetPy = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line">                        <span class="keyword">int</span> sizePy = bufferConsumeQueue.getByteBuffer().getInt();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 根据消息的偏移量和消息的大小从 CommitLog 文件中取出一条消息</span></span><br><span class="line">                        SelectMappedBufferResult selectResult = <span class="keyword">this</span>.commitLog.getMessage(offsetPy, sizePy);</span><br><span class="line">                        getResult.addMessage(selectResult);</span><br><span class="line">                        </span><br><span class="line">                        status = GetMessageStatus.FOUND;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 增加下次开始的偏移量</span></span><br><span class="line">                    nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    bufferConsumeQueue.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端和 Broker 服务器端完整拉取消息的流程图如下所示：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114170044.png" alt="image-20211114170044849" /></p>
<p>根据用户指定的消息回调函数的不同，消息的消费方式可以分为两种：并发消费和有序消费。</p>
<p>并发消费没有考虑消息发送的顺序，客户端从服务器获取消息就会直接回调给用户。而有序消费会考虑每个队列消息发送的顺序，注意此处并不是每个Topic消息发送的顺序，一定要记住RocketMQ控制消息的最细粒度是消息队列。当我们讲有序消费的时候，就是在说对于某个Topic的某个队列，发往这个队列的消息，客户端接收消息的顺序与发送的顺序完全一致。</p>
<h4 id="并发消费-2"><a class="markdownIt-Anchor" href="#并发消费-2"></a> 并发消费</h4>
<p>当用户注册消息回调类的时候，如果注册的是MessageListenerConcurrently回调类，那么就认为用户不关心消息的顺序问题。上文提到，每个PullRequest都关联了一个处理队列ProcessQueue，而每个处理队列又都关联了一颗消息树msgTreeMap。当客户端拉取到新的消息以后，其先将消息放入到这个请求所关联的处理队列的消息树中，然后提交一个消息消费请求，用以回调用户端的代码消费消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQPushConsumerImpl</span> <span class="keyword">implements</span> <span class="title">MQConsumerInner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">        PullCallback pullCallback = <span class="keyword">new</span> PullCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(PullResult pullResult)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (pullResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> FOUND:</span><br><span class="line">                            <span class="comment">// 消息放入处理队列的消息树中</span></span><br><span class="line">                            <span class="keyword">boolean</span> dispathToConsume = processQueue</span><br><span class="line">                                .putMessage(pullResult.getMsgFoundList());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 提交一个消息消费请求</span></span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="keyword">this</span></span><br><span class="line">                                .consumeMessageService</span><br><span class="line">                                .submitConsumeRequest(</span><br><span class="line">                                                      pullResult.getMsgFoundList(),</span><br><span class="line">                                                      processQueue,</span><br><span class="line">                                                      pullRequest.getMessageQueue(),</span><br><span class="line">                                                      dispathToConsume);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当提交一个消息消费请求后，对于并发消费，其实现如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeMessageConcurrentlyService</span> <span class="keyword">implements</span> <span class="title">ConsumeMessageService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConsumeRequest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到msgs是直接从服务器端拿到的最新消息，直接喂给了客户端进行消费，并未做任何有序处理。当消费成功后，会从消息树中将这些消息再给删除掉：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeMessageConcurrentlyService</span> <span class="keyword">implements</span> <span class="title">ConsumeMessageService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConsumeResult</span><span class="params">(<span class="keyword">final</span> ConsumeConcurrentlyStatus status, <span class="comment">/** 其它参数 **/</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从消息树中删除消息</span></span><br><span class="line">        <span class="keyword">long</span> offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore()</span><br><span class="line">                .updateOffset(consumeRequest.getMessageQueue(), offset, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114171439.png" alt="image-20211114171439076" /></p>
<h4 id="有序消费"><a class="markdownIt-Anchor" href="#有序消费"></a> 有序消费</h4>
<p>RocketMQ的有序消费主要依靠两把锁，一把是维护在Broker端，一把维护在消费者客户端。Broker端有一个RebalanceLockManager服务，其内部维护了一个mqLockTable消息队列锁表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RebalanceLockManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* group */</span>, ConcurrentHashMap&lt;MessageQueue, LockEntry&gt;&gt; mqLockTable =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentHashMap&lt;MessageQueue, LockEntry&gt;&gt;(<span class="number">1024</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在有序消费的时候，Broekr需要确保任何一个队列在任何时候都只有一个客户端在消费它，都在被一个客户端所锁定。当客户端在本地根据消息队列构建PullRequest之前，会与Broker沟通尝试锁定这个队列，另外当进行有序消费的时候，客户端也会周期性地（默认是20s）锁定当前需要消费的消息队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeMessageOrderlyService</span> <span class="keyword">implements</span> <span class="title">ConsumeMessageService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        ConsumeMessageOrderlyService.<span class="keyword">this</span>.lockMQPeriodically();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">1000</span> * <span class="number">1</span>, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info"><p>只有在集群模式下才会周期性地锁定Broker端的消息队列，因此在广播模式下是不支持进行有序消费的。</p></div>
<p>在Broker这端，每个客户端所锁定的消息队列对应的锁项LogEntry有一个上次锁定是的时间戳，当超过锁定的超时时间（默认是60s）后，也会判定这个客户端已经不再持有这把锁，以让其它客户端能够有序消费这个队列。</p>
<p>前面我们说到RebalanceService均衡服务会定时地依据不同消费者数量分配消费队列。我们假设Consumer-1消费者客户端一开始需要3个消费队列，这个时候又加入了Consumer-2消费者客户端，并且分配到了MessageQueue-2消费队列。当Consumer-1内部的均衡服务检测到当前队列需要移除MessageQueue-2队列，这个时候，会首先解除Broker端的锁，确保新加入的Consumer-2消费者客户端能够成功锁住这个队列，以进行有序消费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RebalanceImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateProcessQueueTableInRebalance</span><span class="params">(<span class="keyword">final</span> String topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="keyword">final</span> Set&lt;MessageQueue&gt; mqSet,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (mq.getTopic().equals(topic)) &#123;</span><br><span class="line">                <span class="comment">// 当前客户端不需要处理这个消息队列了</span></span><br><span class="line">                <span class="keyword">if</span> (!mqSet.contains(mq)) &#123;</span><br><span class="line">                    pq.setDropped(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="comment">// 解锁</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114175130.png" alt="image-20211114175130250" /></p>
<p>RocketMQ的消息树是用TreeMap实现的，其内部基于消息偏移量维护了消息的有序性。每次消费请求都会从消息树中拿去偏移量最小的几条消息（默认为1条）给用户，以此来达到有序消费的目的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeMessageOrderlyService</span> <span class="keyword">implements</span> <span class="title">ConsumeMessageService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConsumeRequest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize =</span><br><span class="line">                ConsumeMessageOrderlyService.<span class="keyword">this</span></span><br><span class="line">                .defaultMQPushConsumer</span><br><span class="line">                .getConsumeMessageBatchMaxSize();</span><br><span class="line">            List&lt;MessageExt&gt; msgs = <span class="keyword">this</span>.processQueue.takeMessags(consumeBatchSize);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114175326.png" alt="image-20211114175326325" /></p>
<h2 id="消息过滤过程"><a class="markdownIt-Anchor" href="#消息过滤过程"></a> 消息过滤过程</h2>
<h3 id="消息过滤类型"><a class="markdownIt-Anchor" href="#消息过滤类型"></a> 消息过滤类型</h3>
<p>Producer在发送消息的时候可以指定消息的标签类型，还可以为每一个消息添加一个或者多个额外的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定标签</span></span><br><span class="line">Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagA&quot;</span>, (<span class="string">&quot;Hello RocketMQ&quot;</span>).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"><span class="comment">// 添加属性 a</span></span><br><span class="line">msg.putUserProperty(<span class="string">&quot;a&quot;</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>根据标签和属性的不同，RocketMQ客户端在消费消息的时候有三种消息过滤的类型：</p>
<ul>
<li>
<p>Tag过滤</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagA | TagB | TagC&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>SQL匹配</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">                MessageSelector.bySql(</span><br><span class="line">                    <span class="string">&quot;(TAGS is not null and TAGS in (&#x27;TagA&#x27;, &#x27;TagB&#x27;))&quot;</span> + </span><br><span class="line">                <span class="string">&quot;and (a is not null and a between 0  3)&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>自定义匹配</p>
<p>客户端实现 <code>MessageFilter</code> 类，自定义过滤逻辑:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">File classFile = <span class="keyword">new</span> File(classLoader.getResource(<span class="string">&quot;MessageFilterImpl.java&quot;</span>).getFile());</span><br><span class="line"></span><br><span class="line">String filterCode = MixAll.file2String(classFile);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;org.apache.rocketmq.example.filter.MessageFilterImpl&quot;</span>,filterCode);</span><br></pre></td></tr></table></figure>
<p>对于 <code>MessageFilter</code> 类实现 <code>match</code> 方法即可:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageFilterImpl</span> <span class="keyword">implements</span> <span class="title">MessageFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MessageExt msg, FilterContext context)</span> </span>&#123;</span><br><span class="line">        String property = msg.getProperty(<span class="string">&quot;SequenceId&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (property != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = Integer.parseInt(property);</span><br><span class="line">            <span class="keyword">if</span> (((id % <span class="number">10</span>) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                (id &gt; <span class="number">100</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="标签匹配"><a class="markdownIt-Anchor" href="#标签匹配"></a> 标签匹配</h3>
<p>当为消息指定消息标签类型的时候，实际上所指定的标签例如TagA是作为一个属性放入到了这条消息中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTags</span><span class="params">(String tags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.putProperty(MessageConst.PROPERTY_TAGS, tags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当这条消息到达Broker服务器端后，用户设置的标签会计算为标签码，默认的计算方式采用的标签字符串的hashCode()作为计算结果的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DispatchRequest <span class="title">checkMessageAndReturnSize</span><span class="params">(java.nio.ByteBuffer byteBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     <span class="keyword">final</span> <span class="keyword">boolean</span> checkCRC,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     <span class="keyword">final</span> <span class="keyword">boolean</span> readBody)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        String tags = propertiesMap.get(MessageConst.PROPERTY_TAGS);</span><br><span class="line">        <span class="keyword">if</span> (tags != <span class="keyword">null</span> &amp;&amp; tags.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tagsCode = MessageExtBrokerInner</span><br><span class="line">                .tagsString2tagsCode(MessageExt.parseTopicFilterType(sysFlag), tags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当计算出来标签码之后，这条消息的标签码会被存放到消息队列文件中，用来与消费者客户端消费队列的标签码进行匹配。消费者客户端订阅消费Topic的时候，会指定想要匹配的标签类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagA | TagB | TagC&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码在内部实现中利用FilterAPI构建了一个SubscriptionData对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQPushConsumerImpl</span> <span class="keyword">implements</span> <span class="title">MQConsumerInner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(String topic, String subExpression)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        SubscriptionData subscriptionData = FilterAPI</span><br><span class="line">            .buildSubscriptionData(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(),</span><br><span class="line">                                   topic,</span><br><span class="line">                                   subExpression);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当用户未指定标签或者指定为星号标签的时候，则代表用户接收所有标签的消息。如果用户指定了一个或者多个标签，那么会将每一个标签取其hashCode()放入到codeSet中。SubscriptionData还有一个expressionType字段，在使用标签匹配的时候，其不会设置这个字段的值，因此其保留为null。在这些信息设置好以后，当客户端发送心跳包的时候，会将这些Topic的注册信息一并上传至Broker服务器端，方便在Broker端进行匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriptionData</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">SubscriptionData</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String SUB_ALL = <span class="string">&quot;*&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; tagsSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; codeSet = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String expressionType;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 Broker 端服务器在取消息的时候，每取出来一条消息，都会执行两道过滤机制:</p>
<ul>
<li>ConsumeQueue文件匹配</li>
<li>CommitLog文件匹配</li>
</ul>
<p>任一检查没有通过后，绝不会放行这条消息给客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMessageStore</span> <span class="keyword">implements</span> <span class="title">MessageStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GetMessageResult <span class="title">getMessage</span><span class="params">(<span class="keyword">final</span> String group, <span class="comment">/** 其他参数 **/</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; bufferConsumeQueue.getSize() &amp;&amp; i &lt; maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ConsumeQueue 文件匹配</span></span><br><span class="line">            <span class="keyword">if</span> (messageFilter != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : <span class="keyword">null</span>, extRet ? cqExtUnit : <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                    status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// CommitLog 文件匹配</span></span><br><span class="line">            <span class="keyword">if</span> (messageFilter != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !messageFilter.isMatchedByCommitLog(selectResult.getByteBuffer().slice(), <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                    status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// release...</span></span><br><span class="line">                selectResult.release();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息过滤器的默认实现是ExpressionMessageFilter，消息过滤的默认实现策略就是看这个Topic的标签码集合中是否包含当前这条消息的标签码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressionMessageFilter</span> <span class="keyword">implements</span> <span class="title">MessageFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatchedByConsumeQueue</span><span class="params">(Long tagsCode, ConsumeQueueExt.CqExtUnit cqExtUnit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (ExpressionType.isTagType(subscriptionData.getExpressionType())) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tagsCode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (subscriptionData.getSubString().equals(SubscriptionData.SUB_ALL)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> subscriptionData.getCodeSet().contains(tagsCode.intValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatchedByCommitLog</span><span class="params">(ByteBuffer msgBuffer, Map&lt;String, String&gt; properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ExpressionType.isTagType(subscriptionData.getExpressionType())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是一幅标签匹配的简要流程图:</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114181150.png" alt="image-20211114181150764" /></p>
<h3 id="sql匹配"><a class="markdownIt-Anchor" href="#sql匹配"></a> SQL匹配</h3>
<p>在发送消息的时候，可以为每一条消息附带一个或者多个属性值，SQL匹配指的就是依据这些属性值和TAG标签是否满足一定的SQL语句条件，来过滤消息。用户如果想要开启SQL匹配，那么需要在Broker启动的时候，启用如下几个配置信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">brokerConfig.setEnablePropertyFilter(<span class="keyword">true</span>);</span><br><span class="line">brokerConfig.setEnableCalcFilterBitMap(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">messageStoreConfig.setEnableConsumeQueueExt(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<h5 id="注册过滤信息"><a class="markdownIt-Anchor" href="#注册过滤信息"></a> 注册过滤信息</h5>
<p>我们在消费者如何接收消息一文中提到过，消费者启动之后，会通过心跳包定时给Broker服务器汇报自己的信息。而Broker服务器在收到消费者的心跳包之后，会产生一个注册事件，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">registerConsumer</span><span class="params">(<span class="keyword">final</span> String group,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="comment">/** 其他参数 **/</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">this</span>.consumerIdsChangeListener.handle(ConsumerGroupEvent.REGISTER, group, subList);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultConsumerIdsChangeListener是默认的消费者列表注册事件通知器的实现类，其在收到注册事件以后，会将用户在消费者端订阅的Topic信息注册到ConsumerFilterManager中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultConsumerIdsChangeListener</span> <span class="keyword">implements</span> <span class="title">ConsumerIdsChangeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ConsumerGroupEvent event, String group, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> REGISTER:</span><br><span class="line">            Collection&lt;SubscriptionData&gt; subscriptionDataList = (Collection&lt;SubscriptionData&gt;) args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getConsumerFilterManager().register(group, subscriptionDataList);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114234506.png" alt="image-20211114234506442" /></p>
<p>ConsumerFilterData中包含了消费者客户端注册的SQL表达式，由上图可以看到对于每一个Topic所对应的FilterDataMapByTopic，可以注册多个SQL表达式。但是这里需要注意的是，这多个SQL表达式是按照组来做区分的，也就是说一个组只能有一个SQL表达式，那么后注册的会覆盖掉之前注册的。因此，如果想要对同一个组使用不同的SQL语句来过滤自己想要的信息，这些不同的SQL语句必须划分到不同的组里面才可行。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211114234934.png" alt="image-20211114234934592" /></p>
<h4 id="生成bloomfilterdata"><a class="markdownIt-Anchor" href="#生成bloomfilterdata"></a> 生成BloomFilterData</h4>
<p>在RocketMQ中实现的布隆过滤器，其有四个最关键的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大错误率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> f;</span><br><span class="line">    <span class="comment">// 可能插入 n 个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// k 个哈希函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="comment">// 数组总共 m 位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RocketMQ实现的布隆过滤器是根据错误率f和可能插入的元素数量n计算出来的k和m，在默认配置情况下，即如下n=32和f=20，计算出来需要k=3个哈希函数和m=112位的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expect num of consumers will use filter.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectConsumerNumUseFilter = <span class="number">32</span>;</span><br><span class="line">    <span class="comment">// Error rate of bloom filter, 1~100.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxErrorRateOfBloomFilter = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当客户端注册过滤新的时候，其会根据&quot;Group#Topic&quot;这个字符串计算出相应的位映射数据，也即这个字符串经过布隆过滤器中的若干个哈希函数得到的几个不同的哈希值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerFilterManager</span> <span class="keyword">extends</span> <span class="title">ConfigManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> String topic, <span class="comment">/** 其它参数 **/</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        BloomFilterData bloomFilterData =</span><br><span class="line">            bloomFilter.generate(consumerGroup + <span class="string">&quot;#&quot;</span> + topic);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConsumerFilterManager中的Topic过滤信息数据，每隔10秒进行一次磁盘持久化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.consumerFilterManager.persist();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">10</span>, TimeUnit.MILLISECONDS);   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>磁盘文件 <code>consumerFilter.json</code> 中保存的数据信息如下示例:</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211116232759.png" alt="image-20211116232759174" style="zoom:67%;" />
<p>上述流程图如下所示：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211116232920.png" alt="image-20211116232920420" /></p>
<h4 id="编译sql语句"><a class="markdownIt-Anchor" href="#编译sql语句"></a> 编译SQL语句</h4>
<p>JavaCC（Java Complier Complier）是一个能生成语法和词法分析的生成程序，它通过阅读一个自定义的语法标准文件（通常以jj为后缀名），然后就能生成能够解析该语法的扫描器和解析器的代码。</p>
<p>通过执行 <code>javacc SelectorParser.jj</code> 命令以后，其会生成如下七个 Java 文件，用以解析 SQL 语法:</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211116233413.png" alt="image-20211116233412898" style="zoom:67%;" />
<p>过滤器工厂FilterFactory在初次使用的时候，会注册一个SqlFilter类，这个类能够将消费者端指定的SQL语句编译解析为Expression表达式对象，方便后续消息的快速匹配于过滤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlFilter</span> <span class="keyword">implements</span> <span class="title">FilterSpi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Expression <span class="title">compile</span><span class="params">(<span class="keyword">final</span> String expr)</span> <span class="keyword">throws</span> MQFilterException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SelectorParser.parse(expr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算位映射"><a class="markdownIt-Anchor" href="#计算位映射"></a> 计算位映射</h4>
<p>当Broker服务器接收到新的消息到来之后，一直在后台运行的ReputMessageService会负责将这条消息封装位一个DispatchRequest分发请求，这个请求会传递给提前构建好的分发请求链。在DefaultMessageStore的构造函数中，我们看到依次添加了构建消费队列和构建索引的分发请求服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMessageStore</span> <span class="keyword">implements</span> <span class="title">MessageStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultMessageStore</span><span class="params">(<span class="keyword">final</span> MessageStoreConfig messageStoreConfig, <span class="comment">/** 其它参数 **/</span>)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.dispatcherList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.dispatcherList.addLast(<span class="keyword">new</span> CommitLogDispatcherBuildConsumeQueue());</span><br><span class="line">        <span class="keyword">this</span>.dispatcherList.addLast(<span class="keyword">new</span> CommitLogDispatcherBuildIndex());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在Broker初始化的时候，我们看到其又添加了计算位映射的分发请求服务，并且将此分发服务放在链表的第一个位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messageStore.getDispatcherList()</span><br><span class="line">            .addFirst(<span class="keyword">new</span> CommitLogDispatcherCalcBitMap(<span class="keyword">this</span>.brokerConfig, <span class="keyword">this</span>.consumerFilterManager));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，在每次接收到新的消息之后，分发请求的需要经过如下三个分发请求服务进行处理：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211116234137.png" alt="image-20211116234137312" style="zoom:67%;" />
<p>我们在这部分只介绍计算位映射的服务类实现。如下，dispatch方法用来分发请求里面的消息，对于这每一条消息，首先根据Topic取得所有的消费过滤数据。这每一条数据代表的就是一条SQL过滤语句信息。我们在这个地方，需要一一遍历这些过滤信息，从而完成计算位服务的需求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherCalcBitMap</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">        Collection&lt;ConsumerFilterData&gt; filterDatas = consumerFilterManager.get(request.getTopic());</span><br><span class="line">        Iterator&lt;ConsumerFilterData&gt; iterator = filterDatas.iterator();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            ConsumerFilterData filterData = iterator.next();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在拿到ConsumerFilterData信息之后，其会根据这条信息内的SQL语句编译后的表达式来对这条消息进行检查匹配（evaluate），看到这条消息是否满足SQL语句所设置的条件，如果满足，那么会将先前在客户端注册阶段计算好的BloomFilterData中的映射位信息设置到filterBitMap中，即将相应的位数组BitsArray中的相应位设置为1。在验证完所有的SQL语句之后，会将这些所有的字节数组放置到request请求之后，以便交由下一个请求分发服务进行使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherCalcBitMap</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">        Collection&lt;ConsumerFilterData&gt; filterDatas = consumerFilterManager.get(request.getTopic());</span><br><span class="line">        Iterator&lt;ConsumerFilterData&gt; iterator = filterDatas.iterator();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            ConsumerFilterData filterData = iterator.next();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="存储位映射"><a class="markdownIt-Anchor" href="#存储位映射"></a> 存储位映射</h4>
<p>MessageStore在开启扩展消息队列的配置之后，每一个消费队列在创建的时候，都会额外创建一个扩展消费队列。每一个扩展队列文件的大小默认为48MB：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumeQueue</span><span class="params">(<span class="keyword">final</span> String topic, <span class="comment">/** 其它参数 **/</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (defaultMessageStore.getMessageStoreConfig().isEnableConsumeQueueExt()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.consumeQueueExt = <span class="keyword">new</span> ConsumeQueueExt(topic, <span class="comment">/** 其它参数 **/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在计算位映射一节中，计算好位字节数组之后，我们这里需要通过第二个分发请求服务CommitLogDispatcherBuildConsumeQueue来存储这些字节信息。通过如下代码，我们知道它将请求中的位映射信息、消息存储事件、标签码这三条信息封装为ConsumeQueueExt.CqExtUnit，然后放入扩展消费队列文件中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfoWrapper</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> tagsCode = request.getTagsCode();</span><br><span class="line">        <span class="keyword">if</span> (isExtWriteEnable()) &#123;</span><br><span class="line">            ConsumeQueueExt.CqExtUnit cqExtUnit = <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit();</span><br><span class="line">            cqExtUnit.setFilterBitMap(request.getBitMap());</span><br><span class="line">            cqExtUnit.setMsgStoreTime(request.getStoreTimestamp());</span><br><span class="line">            cqExtUnit.setTagsCode(request.getTagsCode());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> extAddr = <span class="keyword">this</span>.consumeQueueExt.put(cqExtUnit);</span><br><span class="line">            <span class="keyword">if</span> (isExtAddr(extAddr)) &#123;</span><br><span class="line">                tagsCode = extAddr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，put方法返回的是一个long类型的扩展地址，当这个数值满足isExtAddr要求后，其会将当前的标签码设置为刚才返回的扩展地址，这是为什么呢？</p>
<p>我们首先来看ConsumeQueueExt文件在存放数据成功后是如何返回信息的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeQueueExt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_ADDR = Integer.MIN_VALUE - <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">put</span><span class="params">(<span class="keyword">final</span> CqExtUnit cqExtUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mappedFile.appendMessage(cqExtUnit.write(<span class="keyword">this</span>.tempContainer), <span class="number">0</span>, size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> decorate(wrotePosition + mappedFile.getFileFromOffset());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decorate</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isExtAddr(offset)) &#123;</span><br><span class="line">            <span class="keyword">return</span> offset + Long.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExtAddr</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address &lt;= MAX_ADDR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MAX_ADDR是一个很小很小的值，为-2147483649，即写入位置如果不小于这个值，那么我们就人顶它不是扩展地址，需要将修正后的写入偏移量+Long.MIN_VALUE确定为扩展地址。当读取信息的时候，其先读取ConsumeQueue文件中的最后的Hash标签码值，如果其通过isExtAddr()函数返回的是true，那么我们就可以使用这个地址，再通过一个unDecorate()函数将其修正为正确的ConsumerQueueExt文件的写入地址，从而接着读取想要的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">unDecorate</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> address)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isExtAddr(address)) &#123;</span><br><span class="line">        <span class="keyword">return</span> address - Long.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方，我们发现ConsumeQueue中的最后一个long型数值，可能存储的是标签Hash码，也可能存储的是扩展消费队列的写入地址，所以需要通过isExtAddr()来分情况判断。</p>
<p>下图为ConsumeQueue文件和ConsumeQueueExt文件中存取信息的不同：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211120115434.png" alt="image-20211120115434045" /></p>
<h4 id="消息过滤-2"><a class="markdownIt-Anchor" href="#消息过滤-2"></a> 消息过滤</h4>
<p>在上小节我们提到了有关扩展消息队列地址和标签Hash码存储的不同，所以在获取消息的时候，先得从消费队列文件中取出tagsCode，然后检查是否是扩展消费队列地址，如果是，那么就需要从扩展消费队列文件中读取正确的标签Hash码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMessageStore</span> <span class="keyword">implements</span> <span class="title">MessageStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GetMessageResult <span class="title">getMessage</span><span class="params">(<span class="keyword">final</span> String group, <span class="comment">/** 其它参数 **/</span>)</span> </span>&#123;</span><br><span class="line">        ConsumeQueueExt.CqExtUnit cqExtUnit = <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit();</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; bufferConsumeQueue.getSize() &amp;&amp; i &lt; maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">            <span class="keyword">long</span> tagsCode = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> extRet = <span class="keyword">false</span>, isTagsCodeLegal = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (consumeQueue.isExtAddr(tagsCode)) &#123;</span><br><span class="line">                extRet = consumeQueue.getExt(tagsCode, cqExtUnit);</span><br><span class="line">                <span class="keyword">if</span> (extRet) &#123;</span><br><span class="line">                    tagsCode = cqExtUnit.getTagsCode();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    isTagsCodeLegal = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当获取到这条消息在扩展消费队列文件中存取的信息后，就会和标签匹配一节所讲述的一致，会进行两道过滤机制，我们先来看第一道ConsumeQueue文件匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressionMessageFilter</span> <span class="keyword">implements</span> <span class="title">MessageFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatchedByConsumeQueue</span><span class="params">(Long tagsCode, ConsumeQueueExt.CqExtUnit cqExtUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] filterBitMap = cqExtUnit.getFilterBitMap();</span><br><span class="line">        BloomFilter bloomFilter = <span class="keyword">this</span>.consumerFilterManager.getBloomFilter();</span><br><span class="line">        BitsArray bitsArray = BitsArray.create(filterBitMap);</span><br><span class="line">        <span class="keyword">return</span> bloomFilter.isHit(consumerFilterData.getBloomFilterData(), bitsArray);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ExpressionMessageFilter依据CqExtUnit中存储的位数组重新创建了比特数组bitsArray，这个数组信息中已经存储了不同SQL表达式是否匹配这条消息的结果。isHit()函数会一一检查BloomFilterData中存储的位信息是否映射在BitsArray中。只要有任何一位没有映射，那么就可以立刻判断出这条消息肯定不符合SQL语句的条件。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211118232930.png" alt="image-20211118232929894" /></p>
<p>因为布隆过滤器有一定的错误率，其只能精确的判断消息是否一定不在集合中，返回成功的只能确定为消息可能在集合中。因此通过布隆过滤器检查后还需要经过第二道过滤机制，即SQL编译后的表达式亲自验证是否匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressionMessageFilter</span> <span class="keyword">implements</span> <span class="title">MessageFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatchedByCommitLog</span><span class="params">(ByteBuffer msgBuffer, Map&lt;String, String&gt; properties)</span> </span>&#123;</span><br><span class="line">        MessageEvaluationContext context = <span class="keyword">new</span> MessageEvaluationContext(tempProperties);</span><br><span class="line">        Object ret = realFilterData.getCompiledExpression().evaluate(context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="keyword">null</span> || !(ret <span class="keyword">instanceof</span> Boolean)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Boolean) ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在验证SQL表达式是否满足之前，提前验证是否命中布隆过滤器，可以有效的避免许多不必要的验证：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211118233425.png" alt="image-20211118233425627" style="zoom:67%;" />
<h3 id="自定义匹配"><a class="markdownIt-Anchor" href="#自定义匹配"></a> 自定义匹配</h3>
<p>消息的自定义匹配需要开启过滤服务器、上传过来类、过滤服务器委托过滤消息等步骤，下面我们一一进行说明。</p>
<h4 id="过滤服务器"><a class="markdownIt-Anchor" href="#过滤服务器"></a> 过滤服务器</h4>
<p>在启动Broker服务器的时候，如果指定了下面一行设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">brokerConfig.setFilterServerNums(<span class="keyword">int</span> filterServerNums);</span><br></pre></td></tr></table></figure>
<p>即将过滤的服务器的数量设定为大于0，那么Broker服务器在启动的时候，将会启动filterServerNums个过滤服务器。过滤服务器是通过调用shell命令的方式，启用独立进程进行启动的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterServerManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createFilterServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> more =</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getBrokerConfig().getFilterServerNums() -</span><br><span class="line">            <span class="keyword">this</span>.filterServerTable.size();</span><br><span class="line">        String cmd = <span class="keyword">this</span>.buildStartCommand();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; more; i++) &#123;</span><br><span class="line">            FilterServerUtil.callShell(cmd, log);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过滤服务器在初始化的时候，会启动定时器每个10秒注册一次到Broker服务器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FiltersrvController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    FiltersrvController.<span class="keyword">this</span>.registerFilterServerToBroker();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">3</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Broker服务器在收到来自过滤服务器的注册之后，会把过滤服务器的地址信息、注册事件等放到过滤服务器表中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterServerManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Channel, FilterServerInfo&gt; filterServerTable =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;Channel, FilterServerInfo&gt;(<span class="number">16</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，Broker服务器也需要定时地将过滤服务器地址信息同步给所有Namesrv命名服务器，上述整个流程如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211118234344.png" alt="image-20211118234344785" style="zoom:67%;" />
<h4 id="过滤类"><a class="markdownIt-Anchor" href="#过滤类"></a> 过滤类</h4>
<p>当消费者通过使用自定义匹配过滤消息的时候，会将存储订阅信息的SubscriptionData中的filterClassSource设置为true，用以表示这个客户端需要过滤类来进行消息的匹配和过滤。</p>
<p>消费者客户端在启动的过程中，会定时地上传本地的过滤类源码到过滤服务器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQClientInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span>, <span class="keyword">this</span>.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendHeartbeatToAllBrokerWithLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">this</span>.uploadFilterClassSource();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中过滤服务器的地址列表是在从Namesrv服务器获取Topic路由信息的时候取得的，Topic路由信息不光存储了消息队列数据，还存储了各个Broker所关联的服务器列表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRouteData</span> <span class="keyword">extends</span> <span class="title">RemotingSerializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当过滤服务器接收到来自消费者客户端的源码之后，其会首先生成一个键为Topic@Group的字符串来查阅过滤信息是否已经存在于内存里面的filterClassTable表中且文件通过CRC校验。如果没有存在或校验失败，那么就需要先编译并加载这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynaCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compileAndLoadClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String[] sourceFiles = <span class="keyword">this</span>.uploadSrcFile();</span><br><span class="line">        <span class="keyword">this</span>.compile(sourceFiles);</span><br><span class="line">        <span class="keyword">this</span>.loadClass(<span class="keyword">this</span>.loadClass.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，编译后的类存放于目录下，类的源文件和类的字节码文件名也会相应的加上当前时间戳来确定：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211118235708.png" alt="image-20211118235708088" /></p>
<p>上述流程图如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211118235741.png" alt="image-20211118235741454" /></p>
<h4 id="过滤消息"><a class="markdownIt-Anchor" href="#过滤消息"></a> 过滤消息</h4>
<p>当消费者客户端自定义匹配过滤消息后，发往服务器的数据中也包含了过滤标志位，这样每次拉取消息的服务器也由原来的Broker服务器变更为Filtersrv过滤服务器，其中过滤服务器地址的选择是随机确定的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullAPIWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PullResult <span class="title">pullKernelImpl</span><span class="params">(<span class="keyword">final</span> MessageQueue mq, <span class="comment">/** 其它参数 **/</span>)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (findBrokerResult != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (PullSysFlag.hasClassFilterFlag(sysFlagInner)) &#123;</span><br><span class="line">                <span class="comment">// 从过滤服务器拉取消息</span></span><br><span class="line">                brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>过滤服务器在启动的时候，内部还启动了一个PullConsumer客户端，用以从Broker服务器拉取消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FiltersrvController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultMQPullConsumer defaultMQPullConsumer =</span><br><span class="line">        <span class="keyword">new</span> DefaultMQPullConsumer(MixAll.FILTERSRV_CONSUMER_GROUP);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPullConsumer.start();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当过滤服务器收到真正的消费者发来的消息的请求之后，其会委托内部的PullConsumer使用包含在请求体内的偏移量去Broker服务器拉取所有消息，此时这些消息是完全没有过滤的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRequestProcessor</span> <span class="keyword">implements</span> <span class="title">NettyRequestProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">pullMessageForward</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="keyword">final</span> RemotingCommand request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        MessageQueue mq = <span class="keyword">new</span> MessageQueue();</span><br><span class="line">        </span><br><span class="line">        mq.setTopic(requestHeader.getTopic());</span><br><span class="line">        mq.setQueueId(requestHeader.getQueueId());</span><br><span class="line">        mq.setBrokerName(<span class="keyword">this</span>.filtersrvController.getBrokerName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置偏移量和最大数量</span></span><br><span class="line">        <span class="keyword">long</span> offset = requestHeader.getQueueOffset();</span><br><span class="line">        <span class="keyword">int</span> maxNums = requestHeader.getMaxMsgNums();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 委托内部消费者从 Broker 服务器拉取消息</span></span><br><span class="line">        pullConsumer.pullBlockIfNotFound(mq, <span class="keyword">null</span>, offset, maxNums, pullCallback);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过滤服务器从Broker服务器获取到完整的消息列表之后，会遍历消息列表，然后使用过滤类一一进行匹配，最终将匹配的消息列表返回给客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRequestProcessor</span> <span class="keyword">implements</span> <span class="title">NettyRequestProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">pullMessageForward</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="keyword">final</span> RemotingCommand request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PullCallback pullCallback = <span class="keyword">new</span> PullCallback() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(PullResult pullResult)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> FOUND:</span><br><span class="line">                        List&lt;MessageExt&gt; msgListOK = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;();</span><br><span class="line">                        <span class="keyword">for</span> (MessageExt msg : pullResult.getMsgFoundList()) &#123;</span><br><span class="line">                            <span class="comment">// 使用过滤类过滤消息</span></span><br><span class="line">                            <span class="keyword">boolean</span> match = findFilterClass.getMessageFilter().match(msg, filterContext);</span><br><span class="line">                            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                                msgListOK.add(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述流程如下图所示：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211120114300.png" alt="image-20211120114300366" /></p>
<h2 id="消息索引流程"><a class="markdownIt-Anchor" href="#消息索引流程"></a> 消息索引流程</h2>
<h3 id="消息查询"><a class="markdownIt-Anchor" href="#消息查询"></a> 消息查询</h3>
<p>对于Producer发送到Broker服务器的消息，RocketMQ支持多种方式来方便地查询消息：</p>
<ul>
<li>根据键查询消息</li>
<li>根据ID（偏移量）查询消息</li>
<li>根据唯一键查询消息</li>
<li>根据消息队列偏移量查询消息</li>
</ul>
<p>在构建消息的时候，指定了这条消息的键位“OrderID001”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message msg =</span><br><span class="line">    <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">                <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                <span class="string">&quot;OrderID001&quot;</span>, <span class="comment">// Keys</span></span><br><span class="line">                <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET))</span><br></pre></td></tr></table></figure>
<p>那么，当这条消息发送成功后，我们可以使用<code>queryMsgByKey</code>命令查询这条消息的详细信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MQAdminStartup.main(<span class="keyword">new</span> String[] &#123;</span><br><span class="line">        <span class="string">&quot;queryMsgByKey&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;localhost:9876&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-t&quot;</span>,</span><br><span class="line">        <span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-k&quot;</span>,</span><br><span class="line">        <span class="string">&quot;OrderID001&quot;</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>根据ID（偏移量）查询消息是指消息在发送成功后，其返回的SendResult类中包含了这条消息的唯一偏移量ID（注意此处指的是offsetMsgId）：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121222705.png" alt="image-20211121222705163" /></p>
<p>用户可以使用<code>queryMsgById</code>命令查询这条消息的详细信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MQAdminStartup.main(<span class="keyword">new</span> String[] &#123;</span><br><span class="line">        <span class="string">&quot;queryMsgById&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;localhost:9876&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-i&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0A6C73D900002A9F0000000000004010&quot;</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>根据唯一键查询消息指的是消息在发送成功之后，其返回的SendResult类包含了这条消息的唯一ID：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121223003.png" alt="" /></p>
<p>用户可以使用<code>queryMsgByUniqueKey</code>命令查询这条消息的详细信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MQAdminStartup.main(<span class="keyword">new</span> String[] &#123;</span><br><span class="line">        <span class="string">&quot;queryMsgByUniqueKey&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;localhost:9876&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-i&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0A6C73D939B318B4AAC20CBA5D920000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-t&quot;</span>,</span><br><span class="line">        <span class="string">&quot;TopicTest&quot;</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>根据消息队列偏移量查询消息指的是消息发送成功之后的SendResult中还包含了消息队列的其它信息，如消息队列ID、消息队列偏移量等信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SendResult [sendStatus=SEND_OK,</span><br><span class="line">            msgId=0A6C73D93EC518B4AAC20CC4ACD90000,</span><br><span class="line">            offsetMsgId=0A6C73D900002A9F000000000000484E,</span><br><span class="line">            messageQueue=MessageQueue [topic=TopicTest,</span><br><span class="line">                                    brokerName=zk-pc,</span><br><span class="line">                                    queueId=3],</span><br><span class="line">            queueOffset=24]</span><br></pre></td></tr></table></figure>
<p>根据这些信息，使用<code>queryMsgByOffset</code>命令也可以查询到这条消息的详细信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MQAdminStartup.main(<span class="keyword">new</span> String[] &#123;</span><br><span class="line">        <span class="string">&quot;queryMsgByOffset&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;localhost:9876&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-t&quot;</span>,</span><br><span class="line">        <span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-b&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zk-pc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-i&quot;</span>,</span><br><span class="line">        <span class="string">&quot;3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">        <span class="string">&quot;24&quot;</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="id-偏移量-查询"><a class="markdownIt-Anchor" href="#id-偏移量-查询"></a> ID (偏移量) 查询</h3>
<p>ID（偏移量）是在消息发送到Broker服务器存储的时候生成的，其包含如下几个字段：</p>
<ul>
<li>Broker服务器的IP地址</li>
<li>Broker服务器端口号</li>
<li>消息文件CommitLog写偏移量</li>
</ul>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121223534.png" alt="image-20211121223534356" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DefaultAppendMessageCallback</span> <span class="keyword">implements</span> <span class="title">AppendMessageCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">doAppend</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> fileFromOffset, <span class="comment">/** 其它参数 **/</span>)</span> </span>&#123;</span><br><span class="line">            String msgId = MessageDecoder</span><br><span class="line">                .createMessageId(<span class="keyword">this</span>.msgIdMemory,</span><br><span class="line">                                 msgInner.getStoreHostBytes(hostHolder),</span><br><span class="line">                                 wroteOffset);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Admin端查询的时候，首先对msgId进行解析，取出Broker服务器的IP、端口号和消息偏移量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MessageId <span class="title">decodeMessageId</span><span class="params">(<span class="keyword">final</span> String msgId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] ip = UtilAll.string2bytes(msgId.substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] port = UtilAll.string2bytes(msgId.substring(<span class="number">8</span>, <span class="number">16</span>));</span><br><span class="line">        <span class="comment">// offset</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = UtilAll.string2bytes(msgId.substring(<span class="number">16</span>, <span class="number">32</span>));</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到偏移量之后，Admin会对Broker服务器发送一个VIEW_MESSAGE_BY_ID的请求命令，Broker服务器在收到请求之后，会根据偏移量定位到CommitLog文件的相应位置然后取出位置，返回给Admin端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMessageStore</span> <span class="keyword">implements</span> <span class="title">MessageStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SelectMappedBufferResult <span class="title">selectOneMessageByOffset</span><span class="params">(<span class="keyword">long</span> commitLogOffset)</span> </span>&#123;</span><br><span class="line">        SelectMappedBufferResult sbr = <span class="keyword">this</span>.commitLog</span><br><span class="line">            .getMessage(commitLogOffset, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 1 TOTALSIZE</span></span><br><span class="line">        <span class="keyword">int</span> size = sbr.getByteBuffer().getInt();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.commitLog.getMessage(commitLogOffset, size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121224006.png" alt="image-20211121223857140" /></p>
<p>根据队列偏移量查询是最简单的一种查询方式，Admin会启动一个PullConsumer，然后利用用户传递给Admin的队列ID、队列偏移量等信息，从服务器拉取一条消息过来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryMsgByOffsetSubCommand</span> <span class="keyword">implements</span> <span class="title">SubCommand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(CommandLine commandLine, Options options, RPCHook rpcHook)</span> <span class="keyword">throws</span> SubCommandException </span>&#123;</span><br><span class="line">        <span class="comment">// 根据参数构建 MessageQueue</span></span><br><span class="line">        MessageQueue mq = <span class="keyword">new</span> MessageQueue();</span><br><span class="line">        mq.setTopic(topic);</span><br><span class="line">        mq.setBrokerName(brokerName);</span><br><span class="line">        mq.setQueueId(Integer.parseInt(queueId));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 Broker 服务器拉取消息</span></span><br><span class="line">        PullResult pullResult = defaultMQPullConsumer.pull(mq, <span class="string">&quot;*&quot;</span>, Long.parseLong(offset), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121224143.png" alt="image-20211121224143451" style="zoom:67%;" />
<h3 id="消息索引服务"><a class="markdownIt-Anchor" href="#消息索引服务"></a> 消息索引服务</h3>
<p>在继续讲解剩下两种查询方式之前，我们必须先介绍一下Broker端的消息索引服务。在之前提到过，每当一条消息发送过来之后，其会封装为一个DispatchRequest来下发给各个转发服务，而CommitLogDispatcherBuildIndex构建索引服务便是其中之一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildIndex</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.messageStoreConfig.isMessageIndexEnable()) &#123;</span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.indexService.buildIndex(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="索引文件结构"><a class="markdownIt-Anchor" href="#索引文件结构"></a> 索引文件结构</h4>
<p>消息的索引信息是存放到磁盘上的，文件以时间戳命名的，默认存在<code>$HOME/store/index</code>目录下。由下图来看，一个索引文件的结构被分成了三部分：</p>
<ul>
<li>前40个字节存放固定的索引头信息，包含了存放在这个索引文件中的消息的最小/大存储时间、最小/大偏移量等状况</li>
<li>中间一段存储了500万个哈希槽位，每个槽内部存储的是索引文件的地址（索引槽）</li>
<li>最后一段存储了2000万个索引内容信息，是实际的索引信息存储的地方。每一个槽位存储了这条消息的键哈希值、存储偏移量、存储时间戳与下一个索引槽地址</li>
</ul>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121231108.png" alt="image-20211121231107977" /></p>
<p>RocketMQ在内存中还维护一个索引文件列表，对于每一个索引文件，前一个文件的最大存储时间是下一个文件的最小存储时间，前一个文件的最大偏移量是下一个文件的最大偏移量。每一个索引文件都索引了某个时间段内、某个偏移量段内的所有消息，当文件满了，就会用前一个文件的最大偏移量和最大存储时间作为起始值，创建下一个索引文件：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121231323.png" alt="image-20211121231323420" /></p>
<h4 id="添加消息"><a class="markdownIt-Anchor" href="#添加消息"></a> 添加消息</h4>
<p>当有新的消息过来后，构建索引服务会取出这条消息的键，然后对字符串“Topic#键”构建索引，构建索引的步骤如下：</p>
<ul>
<li>找出哈希值：生成字符串的哈希码，取余落到500W个槽位之一，并取出其中的值，默认为0</li>
<li>找出索引槽：IndexHeader维护了indexCount，实际存储的索引槽就是直接依次顺延添加的</li>
<li>存储索引内容：找到索引槽后，放入键哈希值、存储偏移量、存储时间戳与下一个索引槽地址，下一个索引槽地址就是第一步哈希槽中取出的值，0代表这个槽位是第一次被索引，而不为0代表这个操作之前的索引槽地址。因此，通过索引槽地址可以将相同哈希槽的消息串联起来，就像单链表那样</li>
<li>更新哈希槽：更新原有哈希槽中存储的值</li>
</ul>
<p>我们以实际例子来说明。假设我们需要依次为键的哈希值为“{16，29，29，8，16，16}”这几条消息构建索引，我们在这个地方忽略了索引信息中存储的存储时间和便宜量字段，只是存储键哈希和下一索引槽信息，那么：</p>
<ul>
<li>放入 16: 将 “16|0” 存储在第 1 个索引槽中，并更新哈希槽为 16 的值为 1，即哈希槽为 16 的第一个索引块的地址为 1</li>
<li>放入 29: 将 “29|0” 存储在第 2 个索引槽中，并更新哈希槽为 29 的值为 2，即哈希槽为 29 的第一个索引块的地址为 2</li>
<li>放入 29: 取出哈希槽为 29 中的值 2，然后将 “29|2” 存储在第 3 个索引槽中，并更新哈希槽为 29 的值为 3，即哈希槽为 29 的第一个索引块的地址为 3。而在找到索引块为 3 的索引信息后，又能取出上一个索引块的地址 2，构成链表为： “[29]-&gt;3-&gt;2”</li>
<li>放入 8: 将 “8|0” 存储在第 4 个索引槽中，并更新哈希槽为 8 的值为 4，即哈希槽为 8 的第一个索引块的地址为 4</li>
<li>放入 16: 取出哈希槽为 16 中的值 1，然后将 “16|1” 存储在第 5 个索引槽中，并更新哈希槽为 16 的值为 5。构成链表为: “[16]-&gt;5-&gt;1”</li>
<li>放入 16: 取出哈希槽为 16 中的值 5，然后将 “16|5” 存储在第 6 个索引槽中，并更新哈希槽为 16 的值为 6。构成链表为: “[16]-&gt;6-&gt;5-&gt;1”</li>
</ul>
<p>整个过程如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121231418.png" alt="image-20211121231418459" style="zoom:67%;" />
<h4 id="查询消息"><a class="markdownIt-Anchor" href="#查询消息"></a> 查询消息</h4>
<p>当需要根据键来查询消息的时候，其会按照倒序回溯整个索引文件列表，对于每一个在时间上能够匹配用户传入的begin和end时间戳参数的索引文件，会一一进行消息查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryOffsetResult <span class="title">queryOffset</span><span class="params">(String topic, String key, <span class="keyword">int</span> maxNum, <span class="keyword">long</span> begin, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 倒序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.indexFileList.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 位于时间段内</span></span><br><span class="line">            <span class="keyword">if</span> (f.isTimeMatched(begin, end)) &#123;</span><br><span class="line">                <span class="comment">// 消息查询</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而具体到每一个索引文件，其查询匹配消息的过程如下所示：</p>
<ul>
<li>确定哈希槽：根据键生成哈希值，定位到哈希槽</li>
<li>定位索引槽：沿着索引槽地址，依次取出下一个索引槽地址，即沿着链表遍历，直至遇见下一个索引槽地址位非法地址0停止</li>
<li>收集偏移量：在遇到匹配的消息之后，会将相应的物理偏移量放到列表中，最后根据物理偏移量，从CommitLog文件中取出消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMessageStore</span> <span class="keyword">implements</span> <span class="title">MessageStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryMessageResult <span class="title">queryMessage</span><span class="params">(String topic, String key, <span class="keyword">int</span> maxNum, <span class="keyword">long</span> begin, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; queryOffsetResult.getPhyOffsets().size(); m++) &#123;</span><br><span class="line">            <span class="keyword">long</span> offset = queryOffsetResult.getPhyOffsets().get(m);</span><br><span class="line">            <span class="comment">// 根据偏移量从 CommitLog 文件中取出消息</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以查询哈希值 16 的消息为例，图示如下:</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121231905.png" alt="image-20211121231905163" /></p>
<h3 id="唯一键查询"><a class="markdownIt-Anchor" href="#唯一键查询"></a> 唯一键查询</h3>
<p>消息的唯一键是在客户端发送消息前构建的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQProducerImpl</span> <span class="keyword">implements</span> <span class="title">MQProducerInner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="comment">/** 其它参数 **/</span>)</span> <span class="keyword">throws</span> XXXException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">            MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建唯一ID的算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageClientIDSetter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createUniqID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(LEN * <span class="number">2</span>);</span><br><span class="line">        sb.append(FIX_STRING);</span><br><span class="line">        sb.append(UtilAll.bytes2string(createUniqIDBuffer()));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一键是根据客户端的进程ID、IP地址、ClassLoader哈希码、时间戳、计数器这几个值来生成的一个唯一的键，然后作为这条消息的附属属性发送到Broker服务器的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageClientIDSetter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUniqID</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            msg.putProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX, createUniqID());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当服务器收到客户端发送过来的消息之后，索引服务便会取出客户端生成的uniqKey并为之建立索引，放入到索引文件中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildIndex</span><span class="params">(DispatchRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (req.getUniqKey() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端在生成消息唯一键的时候，在ByteBuffer的第11位到第14位放置的是当前的时间与当月第一天的时间的毫秒差：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageClientIDSetter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] createUniqIDBuffer() &#123;</span><br><span class="line">        <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (current &gt;= nextStartTime) &#123;</span><br><span class="line">            setStartTime(current);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间差 [当前时间 - 这个月 1 号的时间]</span></span><br><span class="line">        <span class="comment">// putInt 占据的是第 11 位到第 14 位</span></span><br><span class="line">        buffer.putInt((<span class="keyword">int</span>) (System.currentTimeMillis() - startTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setStartTime</span><span class="params">(<span class="keyword">long</span> millis)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.setTimeInMillis(millis);</span><br><span class="line">        cal.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">        cal.set(Calendar.HOUR_OF_DAY, <span class="number">0</span>);</span><br><span class="line">        cal.set(Calendar.MINUTE, <span class="number">0</span>);</span><br><span class="line">        cal.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">        cal.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 开始时间设置为这个月的 1 号</span></span><br><span class="line">        startTime = cal.getTimeInMillis();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道消息索引服务的查询需要用户传入begin和end者两个时间值，以进行这段时间内的匹配。所以RocketMQ为了加速消息的查询，于是在Admin端对特定ID进行查询的时候，首先取出了这段时间差值，然后与当月时间进行相加得到的begin时间值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageClientIDSetter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">getNearlyTimeFromID</span><span class="params">(String msgID)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = UtilAll.string2bytes(msgID);</span><br><span class="line">        buf.put((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        buf.put((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        buf.put((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        buf.put((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 取出第 11 位到 14 位</span></span><br><span class="line">        buf.put(bytes, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        buf.position(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 得到时间差值</span></span><br><span class="line">        <span class="keyword">long</span> spanMS = buf.getLong();</span><br><span class="line">        </span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        <span class="keyword">long</span> now = cal.getTimeInMillis();</span><br><span class="line">        cal.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">        cal.set(Calendar.HOUR_OF_DAY, <span class="number">0</span>);</span><br><span class="line">        cal.set(Calendar.MINUTE, <span class="number">0</span>);</span><br><span class="line">        cal.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">        cal.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">long</span> monStartTime = cal.getTimeInMillis();</span><br><span class="line">        <span class="keyword">if</span> (monStartTime + spanMS &gt;= now) &#123;</span><br><span class="line">            cal.add(Calendar.MONTH, -<span class="number">1</span>);</span><br><span class="line">            monStartTime = cal.getTimeInMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置为这个月(或者上个月) + 时间差值</span></span><br><span class="line">        cal.setTimeInMillis(monStartTime + spanMS);</span><br><span class="line">        <span class="keyword">return</span> cal.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于发送消息的客户端和查询消息的Admin端可能不在一台服务器上，而且从函数的命名getNearlyTimeFromID与上述实现来看，Admin端的时间戳得到的是一个近似起始值，它尽可能地加速用户的查询。而且太旧的消息（超过一个月的消息）是查询不到的。</p>
<p>当begin时间戳确定以后，Admin便会将其它必要的信息，如Topic、key等信息封装答QUERY_MESSAGE的包中，然后向Broker服务器传递这个请求，来进行消息的查询。Broker服务器在获取到这个查询消息的请求后，便会根据key从索引文件中查询符合的消息，最终返回的Admin端。</p>
<h3 id="键查询消息"><a class="markdownIt-Anchor" href="#键查询消息"></a> 键查询消息</h3>
<p>上文提到过，在发送消息的时候，可以填充一个keys的值，这个值将会作为消息的一个属性被发送到Broker服务器上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeys</span><span class="params">(String keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.putProperty(MessageConst.PROPERTY_KEYS, keys);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当服务器收到客户端发送过来的消息之后，索引服务便会取出这条消息的keys并将其用空格进行分割，分割后的每一个字符串都会作为一个单独的键，创建索引，放入到索引文件中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildIndex</span><span class="params">(DispatchRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; keys.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用空格进行分割</span></span><br><span class="line">            String[] keyset = keys.split(MessageConst.KEY_SEPARATOR);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyset.length; i++) &#123;</span><br><span class="line">                String key = keyset[i];</span><br><span class="line">                <span class="keyword">if</span> (key.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    indexFile = putKey(indexFile, msg, buildKey(topic, key));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此我们也可以得知，keys键的设置通过使用空格分割字符串，一条消息可以指定多个键。</p>
<p>keys键查询的方式也是通过将参数封装为QUERY_MESSAGE请求包中去请求服务器返回相应的信息。由于键本身不能和时间戳相关联，因此begin值设置的是0，这是和第五节的不同之处：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryMsgByKeySubCommand</span> <span class="keyword">implements</span> <span class="title">SubCommand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queryByKey</span><span class="params">(<span class="keyword">final</span> DefaultMQAdminExt admin, <span class="keyword">final</span> String topic, <span class="keyword">final</span> String key)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// begin: 0</span></span><br><span class="line">        <span class="comment">// end: Long.MAX_VALUE</span></span><br><span class="line">        QueryResult queryResult = admin.queryMessage(topic, key, <span class="number">64</span>, <span class="number">0</span>, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定时消息和重试消息"><a class="markdownIt-Anchor" href="#定时消息和重试消息"></a> 定时消息和重试消息</h2>
<h3 id="定时消息"><a class="markdownIt-Anchor" href="#定时消息"></a> 定时消息</h3>
<p>RocketMQ支持Producer端发送定时消息，即该消息被发送之后，到一段时间之后才能被Consumer消费者端消费，不过，当前开源版本的RocketMQ所支持的定时时间是有限的、不同级别的精度的时间，并不是任意无限制的定时时间。因此在每条消息上设置定时时间的API叫做setDelayTimeLevel，而非setDelayTime这样的命名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message msg =</span><br><span class="line">    <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">&quot;TagA&quot;</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span>);</span><br><span class="line">msg.setDelayTimeLevel(i + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>默认Broekr服务器有18个定时级别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageStoreConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String messageDelayLevel = <span class="string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这18个定时级别在服务器端启动的时候，会被解析并放置列表delayLevelTable中。解析的过程就是上述字符串按照空格拆开后分开，然后根据时间单位的不同再进一步进行计算，得到最终的毫秒时间。级别就是根据这些毫秒时间的顺序而确定的，例如上述1s延迟就是级别1，5s延迟就是级别2，以此类推：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleMessageService</span> <span class="keyword">extends</span> <span class="title">ConfigManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseDelayLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelArray.length; i++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">int</span> level = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> delayTimeMillis = tu * num;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 级别:延迟时间</span></span><br><span class="line">            <span class="keyword">this</span>.delayLevelTable.put(level, delayTimeMillis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时消息存储"><a class="markdownIt-Anchor" href="#定时消息存储"></a> 定时消息存储</h3>
<p>客户端在为某条消息设置上定时级别的时候，实际上级别这个字段会被作为附属属性放到消息中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDelayTimeLevel</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.putProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL, String.valueOf(level));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与普通的消息一样，定时消息也会被存储到CommitLog消息文件中，将定时消息存储下来是为了保证消息最大程度地不丢失。不过毕竟定时消息和普通消息还是有所不同，在遇到定时消息后，CommitLog会将这条消息地Topic和队列ID替换成专门用于定时的Topic和相应级别对应的队列ID，真实的Topic的队列ID会作为属性值放置到这条消息中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Delay Delivery</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">            queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">            msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 替换 Topic 和 QueueID</span></span><br><span class="line">            msg.setTopic(topic);</span><br><span class="line">            msg.setQueueId(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后，这条消息会被存储在CommitLog消息文件中。我们知道后台重放消息服务RequestMessageService会一直监督CommitLog文件是否添加了新的消息。当有了新的消息后，重放消息服务会取出消息并封装为DispatchRequest请求，然后将其分发给不同的三个分发服务，建立消费队列文件服务就是这其中之一。而此处当取消息封装为DispatchRequest的时候，当遇到定时消息时，又多做了一些额外的事情。</p>
<p>当遇见定时消息时，CommitLOg计算tagsCode标签码与普通消息不同。对于定时消息，tagsCode值设置的是这条消息的投递时间，即建立消费队列文件的时候，文件中tagesCode存储的是这条消息未来在什么时候被投递：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DispatchRequest <span class="title">checkMessageAndReturnSize</span><span class="params">(java.nio.ByteBuffer byteBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     <span class="keyword">final</span> <span class="keyword">boolean</span> checkCRC,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     <span class="keyword">final</span> <span class="keyword">boolean</span> readBody)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Timing message processing</span></span><br><span class="line">        &#123;</span><br><span class="line">            String t = propertiesMap.get(MessageConst.PROPERTY_DELAY_TIME_LEVEL);</span><br><span class="line">            <span class="keyword">if</span> (ScheduleMessageService.SCHEDULE_TOPIC.equals(topic) &amp;&amp; t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> delayLevel = Integer.parseInt(t);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (delayLevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    tagsCode = <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService()</span><br><span class="line">                        .computeDeliverTimestamp(delayLevel,storeTimestamp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下是，发送了10条定时级别分别为1-10的消息以后，<code>$HOME/store/consumequeue</code>文件下消费队列文件的分布情况：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121190601.png" alt="image-20211121190601162" style="zoom:50%;" />
<p>不同的定时级别对应于不同的队列ID，定时级别减1得到的就是队列ID的值，因此级别1-10对应的是0-9的队列ID：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleMessageService</span> <span class="keyword">extends</span> <span class="title">ConfigManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">delayLevel2QueueId</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> delayLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delayLevel - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息重试-2"><a class="markdownIt-Anchor" href="#消息重试-2"></a> 消息重试</h3>
<p>消息重试分为消息发送重试和消息接收重试，消息发送重试是指消息从Producer端发送到Broker服务器的失败以后的重试情况，消息接收重试是指Consumer在消费消息的时候出现异常或者失败的重试情况。</p>
<p>Producer端通过配置如下两个API可以分别配置在同步发送和异步发送消息失败的时候的重试次数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">producer.setRetryTimesWhenSendAsyncFailed(<span class="number">3</span>);</span><br><span class="line">producer.setRetryTimesWhenSendFailed(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>Consumer端在消费的时候，如果接收消息的回调函数出现了如下几种情况：</p>
<ul>
<li>抛出异常</li>
<li>返回NULL状态</li>
<li>返回RECONSUME_LATER状态</li>
<li>超过15分钟没有响应</li>
</ul>
<p>那么Consumer便会将消费失败的消息重新调度直到成功消费：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 抛出异常</span></span><br><span class="line">            <span class="comment">// 返回 NULL 或者 RECONSUME_LATER 状态</span></span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="producer消息发送重试"><a class="markdownIt-Anchor" href="#producer消息发送重试"></a> Producer消息发送重试</h4>
<p>发送失败的重试方式，主要表现在发送消息的时候，会最多尝试getRetryTimesWhenSendFailed()次发送，当成功发送以后，会直接返回发送结果给调用者。当发送失败以后，会继续进行下一次发送尝试，核心代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQProducerImpl</span> <span class="keyword">implements</span> <span class="title">MQProducerInner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SendResult <span class="title">sendDefaultImpl</span><span class="params">(Message msg, <span class="comment">/** 其他参数 **/</span>)</span> <span class="keyword">throws</span> MQClientException,</span></span><br><span class="line"><span class="function">                                                                             RemotingException,</span></span><br><span class="line"><span class="function">                                                                             MQBrokerException,</span></span><br><span class="line"><span class="function">                                                                             InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> timesTotal = communicationMode ==</span><br><span class="line">            CommunicationMode.SYNC ?</span><br><span class="line">            <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() :</span><br><span class="line">            <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">            <span class="comment">// 尝试发送消息，发送成功 return，发送失败 continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="consumer消息接收重试"><a class="markdownIt-Anchor" href="#consumer消息接收重试"></a> Consumer消息接收重试</h4>
<p>Consumer在启动的时候，会指定一个copySubscription()，当用户注册的消息模型为集群模式的时候，会根据用户指定的Group创建重试Group Topic并放入到注册信息中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQPushConsumerImpl</span> <span class="keyword">implements</span> <span class="title">MQConsumerInner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">this</span>.copySubscription();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">copySubscription</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">        <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">            <span class="comment">// 重试话题组</span></span><br><span class="line">            <span class="keyword">final</span> String retryTopic = MixAll.getRetryTopic(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(),</span><br><span class="line">                                                                                retryTopic, SubscriptionData.SUB_ALL);</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设用户指定的组为“ORDER”，那么重试的Topic则为“%RETRY%ORDER”，即前面加上了“%RETRY”这个字符串。</p>
<p>Consumer在一开始启动的时候，就为用户自动注册了订阅组的重试Topic，即用户不单单只接收这个Group的Topic的消息，也接收这个Group的重试Topic的消息，这样以来，就为用户如何接收重试消息奠定了基础。</p>
<p>当Consumer客户端在消费消息的时候，抛出了异常、返回了非正确消费的状态等错误的时候，这时，ConsumeMessageConcurrentlyService会收集所有失败的消息，然后将每一条消息封装进CONSUMER_SEND_MSG_BACK的请求中，并将其发送到Broker服务器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeMessageConcurrentlyService</span> <span class="keyword">implements</span> <span class="title">ConsumeMessageService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConsumeResult</span><span class="params">(<span class="keyword">final</span> ConsumeConcurrentlyStatus status,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="comment">/** 其他参数 **/</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">        <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                <span class="comment">// 重新将消息发往 Broker 服务器</span></span><br><span class="line">                <span class="keyword">boolean</span> result = <span class="keyword">this</span>.sendMessageBack(msg, context);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当消费失败的消息重新发送到服务器后，Broker会为其指定新的Topic重试Topic，并根据当前这条消息的已有的重试次数来选择定时级别，即将这条消息变成定时消息投放到重试Topic消息队列中。可见消息消费失败后并不是立即进行新的投递，而是有一定的延迟时间的。延迟时间随着重试次数的增加而增加，也即投递的时间的间隔也越来越长：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageProcessor</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSendMessageProcessor</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NettyRequestProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">consumerSendMsgBack</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">final</span> RemotingCommand request)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定为重试话题</span></span><br><span class="line">        String newTopic = MixAll.getRetryTopic(requestHeader.getGroup());</span><br><span class="line">        <span class="keyword">int</span> queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % subscriptionGroupConfig.getRetryQueueNums();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定为延时信息，设定延时级别</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == delayLevel) &#123;</span><br><span class="line">            delayLevel = <span class="number">3</span> + msgExt.getReconsumeTimes();</span><br><span class="line">        &#125;</span><br><span class="line">        msgExt.setDelayTimeLevel(delayLevel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重试次数增加</span></span><br><span class="line">        msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新存储</span></span><br><span class="line">        PutMessageResult putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，消息如果一直消费不成功，那也不会一直无限次的尝试重新投递，当重试次数大于最大重试次数（默认为16次）的时候，该消息将会被送往死信队列，认定这条消息投递无门：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageProcessor</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSendMessageProcessor</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NettyRequestProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">consumerSendMsgBack</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">final</span> RemotingCommand request)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">        <span class="comment">// 重试次数大于最大重试次数</span></span><br><span class="line">        <span class="keyword">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes</span><br><span class="line">            || delayLevel &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 死信队列话题</span></span><br><span class="line">            newTopic = MixAll.getDLQTopic(requestHeader.getGroup());</span><br><span class="line">            queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % DLQ_NUMS_PER_GROUP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121203713.png" alt="image-20211121203713011" style="zoom:67%;" />
<p>上述客户端消费失败的流程图如下所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121203805.png" alt="image-20211121203805755" style="zoom:67%;" />
<h2 id="主备同步"><a class="markdownIt-Anchor" href="#主备同步"></a> 主备同步</h2>
<p>RocketMQ通过Master-Slave主备机制，来实现整个系统的高可用，具体表现在：</p>
<ul>
<li>Master磁盘坏掉，Slave依然保存了一份</li>
<li>Master宕机，不影响消费者继续消费</li>
</ul>
<p>假设我们在同一台机器上搭建了一个Master和一个Slave的环境：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121171339.png" alt="image-20211121171339365" style="zoom:67%;" />
<p>为了能够将Master和Slave搭建在同一台计算机上，我们除了需要将Broker的角色设置为SLAVE，还需要为其指定单独的brokerId、storePathRootDir、storePathCommitLog。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SLAVE 角色</span></span><br><span class="line">messageStoreConfig.setBrokerRole(BrokerRole.SLAVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个机器如果要启动多个 Broker，那么每个 Broker 的 store 根目录必须不同</span></span><br><span class="line">messageStoreConfig.setStorePathRootDir(storePathRootDir);</span><br><span class="line"><span class="comment">// 一个机器如果要启动多个 Broker，那么每个 Broker 的 storePathCommitLog 根目录必须不同</span></span><br><span class="line">messageStoreConfig.setStorePathCommitLog(storePathCommitLog);</span><br><span class="line"><span class="comment">// 设置 Slave 的 Master HA 地址</span></span><br><span class="line">messageStoreConfig.setHaMasterAddress(<span class="string">&quot;localhost:10912&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SLAVE 角色的 brokerId 必须大于 0</span></span><br><span class="line">brokerConfig.setBrokerId(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>注意Slave和Master的brokerName必须一致，即它们必须处于同一个BrokerData数据结构里面。实际上在做了如上的修改之后，Slave和Master依旧不能同时运行在同一台机器上，因为Slave本身也可以称为Master，接收来自其它Slave的请求，因此当运行Slave的时候，需要将HAService里面的启动AcceptSocketService运行的相关方法注释掉。</p>
<h3 id="建立连接"><a class="markdownIt-Anchor" href="#建立连接"></a> 建立连接</h3>
<p>当一个Broker在启动的时候，会调用HAService的start()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HAService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.acceptSocketService.beginAccept();</span><br><span class="line">        <span class="keyword">this</span>.acceptSocketService.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.groupTransferService.start();</span><br><span class="line">        <span class="keyword">this</span>.haClient.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AcceptSocketService服务的功能是Master等待接收来自其它客户端Slave的连接，当成功建立连接后，会将这条连接HAConnecion放入到connectionList连接列表里面，而HAClient服务的功能是Slave主动发起同其它Master的连接。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121173400.png" alt="image-20211121173400580" style="zoom:67%;" />
<h3 id="数据传输"><a class="markdownIt-Anchor" href="#数据传输"></a> 数据传输</h3>
<p>当启动HAService之后，一旦Master发现和Slave不同步，那么Master会自动开始同步消息到Slave，无需其它的触发机制。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121173514.png" alt="image-20211121173514012" style="zoom:67%;" />
<p>消息的传输方式主要分为两种：</p>
<ul>
<li>消息异步传输</li>
<li>消息同步传输</li>
</ul>
<h4 id="消息异步传输"><a class="markdownIt-Anchor" href="#消息异步传输"></a> 消息异步传输</h4>
<p>如果Mater Broker的角色是ASYNC_MASTER，那么消息等待从Master同步到Slave的方式是异步传输的方式。这意味当一条消息发送到Master Broker的时候，Master Broker在存储完这条消息到本地之后，并不会等待消息同步到Slave Broker才返回。这种方式会缩短发送消息的响应时间。</p>
<h4 id="消息同步传输"><a class="markdownIt-Anchor" href="#消息同步传输"></a> 消息同步传输</h4>
<p>如果Master Broker的角色是SYNC_MASTER，那么消息等待从Master同步到Slave的方式是同步传输方式。除此之外，进入同步方式还得满足另外两个条件：</p>
<ul>
<li>消息体的PROPERTY_WAIT_STORE_MSG_OK属性值为true，即这条消息允许等待</li>
<li>Slave相比Master落下的同步进度不能超过265MB</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHA</span><span class="params">(AppendMessageResult result, PutMessageResult putMessageResult, MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (BrokerRole.SYNC_MASTER == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">            HAService service = <span class="keyword">this</span>.defaultMessageStore.getHaService();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消息是否允许等待同步</span></span><br><span class="line">            <span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Slave 是否没有落下 Master 太多</span></span><br><span class="line">                <span class="keyword">if</span> (service.isSlaveOK(result.getWroteOffset() + result.getWroteBytes())) &#123;</span><br><span class="line">                    <span class="comment">// 等待同步完成</span></span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Slave problem</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Tell the producer, slave not available</span></span><br><span class="line">                    putMessageResult.setPutMessageStatus(PutMessageStatus.SLAVE_NOT_AVAILABLE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中isSlaveOK方法就是用来检测Slave和Master落下的同步进度是否太大的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HAService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSlaveOK</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> masterPutWhere)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">this</span>.connectionCount.get() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        result =</span><br><span class="line">            result</span><br><span class="line"></span><br><span class="line">            &amp;&amp; ((masterPutWhere - <span class="keyword">this</span>.push2SlaveMaxOffset.get()) &lt;</span><br><span class="line">                <span class="keyword">this</span>.defaultMessageStore</span><br><span class="line">                .getMessageStoreConfig()</span><br><span class="line">                .getHaSlaveFallbehindMax()); <span class="comment">// 默认 256 * 1024 * 1024 = 256 MB</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果上面两个条件不满足的话，那么Master便不会再等待消息同步到Slave之后再返回，能尽早返回便尽早返回了。</p>
<p>消息等待是否同步到Slave是借助CountDownLatch来实现的。当消息需要等待的时候便会构建一个GroupCommitRequest，每个请求在其内部都维护了一个CountDownLatch，然后通过调用await(timeout)方法来等待消息同步到Slave之后，或者超时之后自动返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupCommitRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeupCustomer</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> flushOK)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flushOK = flushOK;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">waitForFlush</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch.await(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.flushOK;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Interrupted&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要重点掌握几个循环体和唤醒点：</p>
<ul>
<li>
<p>GroupTransferService服务的是否处理请求的循环体和唤醒点：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroupTransferService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putRequest</span><span class="params">(<span class="keyword">final</span> CommitLog.GroupCommitRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 放入请求，唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (hasNotified.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            waitPoint.countDown(); <span class="comment">// notify</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 循环体</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// putRequest 会提前唤醒这句话</span></span><br><span class="line">                <span class="keyword">this</span>.waitForRunning(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">this</span>.doWaitTransfer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>HAConnection的是否进行消息传输的循环体和唤醒点：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteSocketService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 循环体</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">            SelectMappedBufferResult selectResult =</span><br><span class="line">                HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getCommitLogData(<span class="keyword">this</span>.nextTransferFromWhere);</span><br><span class="line">            <span class="keyword">if</span> (selectResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 传输（写入）消息</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 等待 100 毫秒或者提前被唤醒</span></span><br><span class="line">                HAConnection.<span class="keyword">this</span>.haService.getWaitNotifyObject().allWaitForRunning(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHA</span><span class="params">(AppendMessageResult result,</span></span></span><br><span class="line"><span class="params"><span class="function">                         PutMessageResult putMessageResult,</span></span></span><br><span class="line"><span class="params"><span class="function">                         MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">        GroupCommitRequest request =</span><br><span class="line">            <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() +</span><br><span class="line">                                   result.getWroteBytes());</span><br><span class="line">        service.putRequest(request);</span><br><span class="line">        <span class="comment">// 提前唤醒 WriteSocketService</span></span><br><span class="line">        service.getWaitNotifyObject().wakeupAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Slave汇报进度唤醒GroupTransferService，等待同步完成唤醒GroupCommitRequest的CountDownLatch：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadSocketService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">processReadEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 唤醒 GroupTransferService</span></span><br><span class="line">        HAConnection.<span class="keyword">this</span>.haService.notifyTransferSome(HAConnection.<span class="keyword">this</span>.slaveAckOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroupTransferService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyTransferSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.notifyTransferObject.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWaitTransfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (CommitLog.GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> transferOK = HAService.<span class="keyword">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 次重试</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; !transferOK &amp;&amp; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 等待被唤醒或者超时</span></span><br><span class="line">                <span class="keyword">this</span>.notifyTransferObject.waitForRunning(<span class="number">1000</span>);</span><br><span class="line">                transferOK = HAService.<span class="keyword">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 GroupCommitRequest 的 CountDownLatch</span></span><br><span class="line">            req.wakeupCustomer(transferOK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupCommitRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeupCustomer</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> flushOK)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flushOK = flushOK;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>完整的消息唤醒链：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121174957.png" alt="image-20211121174957641" style="zoom:67%;" />
<h3 id="消费建议"><a class="markdownIt-Anchor" href="#消费建议"></a> 消费建议</h3>
<p>当消费者在消费的时候，如果Master突然宕机，那么消费者会自动切换到Slave机器上继续进行消费。</p>
<p>RocketMQ提供了自动从Slave读取老数据的功能，这个功能主要由slaveReadEnable这个参数控制。默认是关的（slaveReadEnable=false）。推荐主从都打开，这个参数打开之后，在客户端消费数据时，会判断，当前读取消息的物理偏移量跟最新的位置的差值，是否超过了内存容量的一个百分比（<code>accessMessageInMemoryMaxRatio = 40</code> by default）。如果超过了，就会告诉客户端去备机上消费数据。如果采用异步主从，也就是broekrRole等于ASYNC_AMSTER的时候，备机IO爆了，其实影响不太大，但是如果采用同步主从，就会收到影响，这个时候，最好是有两个备机，因为RocketMQ的主从同步复制，只要一个备机响应了确认写入就可以了，另一台IO爆了，问题不是很大。</p>
<h3 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h3>
<p>一、Master（Slave）读取来自Slave（Master）的消息异常（IOException、read()返回-1等）的时候怎么处理？</p>
<p>答：打印日志+关闭这条连接。</p>
<p>二、Master（Slave）长时间没有收到来自Slave（Master）的进度汇报怎么处理？</p>
<p>答：每次读取之后更新lastReadTimeStamp或者lastWriteTimestamp，一旦发现在haHousekeepingInterval间隔内（默认20秒）这个时间戳没有改变的话，关闭这条连接。</p>
<p>三、Slave检测到来自Master汇报的本次传输偏移量和本地的传输偏移量不同时怎么处理？</p>
<p>答：打印日志+关闭这条连接。</p>
<p>四、Master如何知道Slave是否真正的存储了刚才发送过去的消息？</p>
<p>答：Slave存储完毕之后，通过向Master汇报进度来完成。相当于TCP的ACK机制。</p>
<p>五、Master宕机</p>
<p>答：无论Master是主动关闭Master，还是Master因为异常而退出，Slave都会每隔5秒重连一次Master。</p>
<h2 id="事务消息"><a class="markdownIt-Anchor" href="#事务消息"></a> 事务消息</h2>
<h3 id="发送事务消息-2"><a class="markdownIt-Anchor" href="#发送事务消息-2"></a> 发送事务消息</h3>
<p>发送事务大致分为三个步骤：</p>
<ul>
<li>初始化事务环境</li>
<li>发送消息并执行本地事务</li>
<li>结束事务</li>
</ul>
<p>初始化事务环境是为了构建checkExecutor线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionMQProducer</span> <span class="keyword">extends</span> <span class="title">DefaultMQProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQProducerImpl.initTransactionEnv();</span><br><span class="line">        <span class="keyword">super</span>.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送消息并执行本地事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionMQProducer</span> <span class="keyword">extends</span> <span class="title">DefaultMQProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> Object arg)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.sendMessageInTransaction(msg, <span class="keyword">null</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是DefaultMQProducerImpl类的发送事务消息的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> LocalTransactionExecuter localTransactionExecuter, <span class="keyword">final</span> Object arg)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标识这条消息的属性：TRANSACTION_PREPARED</span></span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    sendResult = <span class="keyword">this</span>.send(msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据消息的发送状态决定是否执行本地事务</span></span><br><span class="line">    <span class="keyword">switch</span> (sendResult.getSendStatus()) &#123;</span><br><span class="line">        <span class="comment">// 发送消息成功</span></span><br><span class="line">        <span class="keyword">case</span> SEND_OK: &#123;</span><br><span class="line">            <span class="comment">// 获取事务 ID</span></span><br><span class="line">            <span class="keyword">if</span> (sendResult.getTransactionId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                msg.putUserProperty(<span class="string">&quot;__transactionId__&quot;</span>, sendResult.getTransactionId());</span><br><span class="line">            &#125;</span><br><span class="line">            String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != transactionId &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(transactionId)) &#123;</span><br><span class="line">                msg.setTransactionId(transactionId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行本地事务</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != localTransactionExecuter) &#123;</span><br><span class="line">                localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transactionListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;Used new transaction API&quot;</span>);</span><br><span class="line">                localTransactionState = transactionListener.executeLocalTransaction(msg, arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息失败</span></span><br><span class="line">        <span class="keyword">case</span> FLUSH_DISK_TIMEOUT:</span><br><span class="line">        <span class="keyword">case</span> FLUSH_SLAVE_TIMEOUT:</span><br><span class="line">        <span class="keyword">case</span> SLAVE_NOT_AVAILABLE:</span><br><span class="line">            localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务结束</span></span><br><span class="line">    <span class="keyword">this</span>.endTransaction(sendResult, localTransactionState, localException);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出，RocketMQ是先发送消息，然后再执行本地事务。</p>
<p>在endTransaction内部，需要根据本地事务执行的状态，来决定是COMMIT还是ROLLBACK已经发送到服务器的消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (localTransactionState) &#123;</span><br><span class="line">    <span class="keyword">case</span> COMMIT_MESSAGE:</span><br><span class="line">        requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ROLLBACK_MESSAGE:</span><br><span class="line">        requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> UNKNOW:</span><br><span class="line">        requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 API: 只调用一次，不重试</span></span><br><span class="line"><span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark, <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br></pre></td></tr></table></figure>
<p>其中endTransactionOneway()发送的是到Server的END_TRANSACTION命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.END_TRANSACTION, requestHeader);</span><br></pre></td></tr></table></figure>
<h3 id="接收事务消息-2"><a class="markdownIt-Anchor" href="#接收事务消息-2"></a> 接收事务消息</h3>
<p>接收事务消息大致分为两个阶段：</p>
<ul>
<li>接收事务准备消息</li>
<li>接收事务结束消息</li>
</ul>
<h4 id="接收事务准备消息"><a class="markdownIt-Anchor" href="#接收事务准备消息"></a> 接收事务准备消息</h4>
<p>Broker检查收到的消息是否是PROPERTY_TRANCSACTION_PREPARED消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SendMessageProcessor</span></span><br><span class="line">String transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (transFlag != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(transFlag)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line">        <span class="comment">// 没有发送事务的权限</span></span><br><span class="line">        response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(response);</span><br><span class="line">    &#125;</span><br><span class="line">    putMessageResult = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步准备消息内部，其实就是存储half消息的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImpl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;PutMessageResult&gt; <span class="title">asyncPrepareMessage</span><span class="params">(MessageExtBrokerInner messageInner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transactionalMessageBridge.asyncPutHalfMessage(messageInner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将消息的Topic替换为了RMQ_SYS_TRANS_HALF_TOPIC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备份原来真正的 Topic</span></span><br><span class="line">MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic());</span><br><span class="line">msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildHalfTopic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是，刚发送完PREPARED消息后，consumequeue文件夹中存放的文件：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121205836.png" alt="image-20211121205835828" style="zoom:67%;" />
<p>PREPARED消息不会被消费吗？</p>
<p>PREPARED消息在存储到磁盘之前，会将Topic改为RMQ_SYS_TRANS_HALF_TOPIC，因此通过订阅该消息关联的原来的Topic，是消费不到该消息的。</p>
<p>另外就是在Broker分发消息的时候，正常情况下，当收到了一条消息，后台会根据消息，构建consume文件（下面代码中的putMessagePositionInfo()方法就是为了构建消费文件），以供消费者消费。但是在遇到PREPARED消息的时候，就不再构建consume文件了，即消费者根本看不到这条消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultMessageStore.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildConsumeQueue</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());</span><br><span class="line">        <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                DefaultMessageStore.<span class="keyword">this</span>.putMessagePositionInfo(request);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接收事务结束的消息"><a class="markdownIt-Anchor" href="#接收事务结束的消息"></a> 接收事务结束的消息</h4>
<p>对于END_TRANSACTION的请求，BrokerController注册了单独的处理器来处理事务结束的命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BrokerController</span></span><br><span class="line"><span class="keyword">this</span>.remotingServer.registerProcessor(RequestCode.END_TRANSACTION, <span class="keyword">new</span> EndTransactionProcessor(<span class="keyword">this</span>), <span class="keyword">this</span>.endTransactionExecutor);</span><br></pre></td></tr></table></figure>
<p>EndTransactionProcessor内部，处理命令的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SLAVE 不支持接受 END_TRANSACTION 命令</span></span><br><span class="line"><span class="keyword">if</span> (BrokerRole.SLAVE == brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">    response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">    <span class="comment">// COMMIT 消息</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">    <span class="comment">// ROLLBACK 消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>COMMIT消息的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().commitMessage(requestHeader);</span><br><span class="line"></span><br><span class="line">MessageExtBrokerInner msgInner = endMessageTransaction(result.getPrepareMessage());</span><br><span class="line">msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));</span><br><span class="line">MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line">RemotingCommand sendResult = sendFinalMessage(msgInner);</span><br><span class="line"><span class="keyword">if</span> (sendResult.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">this</span>.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码第一行commitMessage内部是根据commitLogOffset这个偏移量，从commitLog的MappedFile文件中查找消息的过程。</p>
<p>第二行的endMessageTransaction内部根据preparedMessage构建了新的Message，恢复了Topic、拷贝了这个消息上其它的属性信息，最重要的是清除了MessageConst、PROPERTY_TRANSACTION_PREPARED属性，以便这个消息可以构建消费队列文件，从而让消费者能够消费。</p>
<p>最后sendMessage内部就是将构建好的新的消息体，重新调用Broker端的发送消息的流程，来发送消息。所以消费端消费已经不是之前发送的PREPARED消息，而是根据PREPARED消息重新克隆出来的新的消息体，当然内容、属性等都是一样的。</p>
<p>最后deletePrepareMessage的过程，内部其实只是给这条消息打赏了一个TransactionMessageUtil.REMOVETAG标签，然后重新putMessage()。</p>
<p>下图展示的是，执行COMMIT之后的，consumequeue存放文件的情况：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121221847.png" alt="image-20211121221847599" style="zoom:67%;" />
<p>RollBack回滚消息的实现：</p>
<p>回滚消息第一步也是根据commitOffset查找消息，然后再给这条消息打上<code>TransactionalMessageUtil.REMOVETAG</code> 的过程。</p>
<p>下图是消息执行ROLLBACK之后的consumequeue所存储的文件的状态：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121222041.png" alt="image-20211121222041279" style="zoom:67%;" />
<h3 id="扫描事务状态"><a class="markdownIt-Anchor" href="#扫描事务状态"></a> 扫描事务状态</h3>
<p>加入Client执行本地事务，运行时间过长，或者发送了COMMIT消息或者ROLLBACK消息，但是这条消息由于网络原因等没有到达Server端，那么可能会导致PREPARED的消息越来越多。因此Broker会在后台定期给Client发送检查事务状态的消息，主要通过如下三种方式：</p>
<ul>
<li>Server定时扫描</li>
<li>Server检查事务状态</li>
<li>客户端检查事务状态</li>
</ul>
<h4 id="server定时扫描"><a class="markdownIt-Anchor" href="#server定时扫描"></a> Server定时扫描</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalMessageCheckService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> checkInterval = brokerController.getBrokerConfig().getTransactionCheckInterval();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.waitForRunning(checkInterval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onWaitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timeout = brokerController.getBrokerConfig().getTransactionTimeOut();</span><br><span class="line">        <span class="keyword">int</span> checkMax = brokerController.getBrokerConfig().getTransactionCheckMax();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查事务状态</span></span><br><span class="line">        <span class="keyword">this</span>.brokerController.getTransactionalMessageService().check(timeout, checkMax, <span class="keyword">this</span>.brokerController.getTransactionalMessageCheckListener());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>transactionCheckInterval = 60 * 1000：每隔60s执行一次check方法</li>
<li>transactionTimeOut = 6 * 1000：第一次检查事务消息的时间，一条消息只有大于这个时间还没有收到COMMIT或者ROLLBACK，那么就执行检查</li>
<li>transactionCheckMax = 15：最多执行多少次检查后，如果依然还没有收到这条消息是提交还是回滚，那么这条消息将被丢弃</li>
</ul>
<h4 id="server检查事务状态"><a class="markdownIt-Anchor" href="#server检查事务状态"></a> Server检查事务状态</h4>
<p>在check方法内部，Server端需要扫描是否有消息需要取检查事务的状态，如果需要，则会给Client发送CHECK_TRANSACTION_STATE命令。</p>
<p>首先，Broker将自己作为一个客户端来去订阅消费RMQ_SYS_TRANS_OP_HALF_TOPIC Topic中的消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TransactionalMessageBridge.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PullResult <span class="title">getOpMessage</span><span class="params">(<span class="keyword">int</span> queueId, <span class="keyword">long</span> offset, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">    String group = TransactionalMessageUtil.buildConsumerGroup();</span><br><span class="line">    String topic = TransactionalMessageUtil.buildOpTopic();</span><br><span class="line">    SubscriptionData sub = <span class="keyword">new</span> SubscriptionData(topic, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> getMessage(group, topic, queueId, offset, nums, sub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么每一次消费，我们怎么知道上一次消费到哪里了呢？实际上，最新的消息偏移量存储在了offsetTable中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConsumerOffsetManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">queryOffset</span><span class="params">(<span class="keyword">final</span> String group, <span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// topic@group</span></span><br><span class="line">    String key = topic + TOPIC_GROUP_SEPARATOR + group;</span><br><span class="line">    ConcurrentMap&lt;Integer, Long&gt; map = <span class="keyword">this</span>.offsetTable.get(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != map) &#123;</span><br><span class="line">        Long offset = map.get(queueId);</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>offsetTable在后台也会定时地将里面的信息保存到磁盘上的config/consumerOffset.json文件中（如下图所示）。0：9的0表示queueId，9表示最新的offset。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121215138.png" alt="image-20211121215138254" style="zoom:67%;" />
<p>在获取到上一轮offset到最新的offset之间的消息列表后，那么就需要逐一检查这些消息的事务状态了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);</span><br><span class="line"><span class="keyword">long</span> i = halfOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    GetResult getResult = getHalfMsg(messageQueue, i);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (isNeedCheck) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        listener.resolveHalfMsg(msgExt);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>msgExt的内部状态：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121215312.png" alt="image-20211121215312432" style="zoom:50%;" />
<p>那么在每一轮循环中，即每一条消息内部，逻辑又是怎么样执行的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TransactionalMessageServiceImpl</span></span><br><span class="line"><span class="keyword">if</span> (System.currentTimeMillis() - startTime &gt; MAX_PROCESS_TIME_LIMIT) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp();</span><br><span class="line"><span class="keyword">long</span> checkImmunityTime = transactionTimeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isNeedCheck = (opMsg == <span class="keyword">null</span> &amp;&amp; valueOfCurrentMinusBorn &gt; checkImmunityTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isNeedCheck) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!putBackHalfMsgQueue(msgExt, i)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listener.resolveHalfMsg(msgExt);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>我们可以看到：</p>
<ul>
<li>
<p>首先对于while(true)的时间设定了限制，不能超过MAX_PROCESS_TIME_LIMIT这个值</p>
</li>
<li>
<p>其次，needDiscard这个方法检查的就是从消息的MessageConst.PROPERTY_TRANSACTION_CHECK_TIMES属性中，获取到这个消息已经检查了多少次，如果超过transactionCheckMax，那么就需要丢弃</p>
</li>
<li>
<p>needSkip()函数判断的是这条消息自诞生以来，在Broker端放置的时间是否超过了3天，如果超过3天，这条消息也没有必要检查了，因此RocketMQ默认存储消息的最长时间就是3天</p>
</li>
<li>
<p>isNeedCheck看的主要就是消息诞生的时间是否超过了transactionTimeout</p>
</li>
<li>
<p>putBackHalfMsgQueue主要就是将当前的消息，最新修改的属性等，重新拷贝一份，然后将新的消息追加到MappedFile的末尾</p>
</li>
<li>
<p>resolveHalfMsg就是在线程池中执行发送检查事务状态的任务：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resolveHalfMsg</span><span class="params">(<span class="keyword">final</span> MessageExt msgExt)</span> </span>&#123;</span><br><span class="line">    executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendCheckMessage(msgExt);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;Send check message error!&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>sendCheckMessage的内部实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractTransactionalMessageCheckListener.java</span></span><br><span class="line">String groupId = msgExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP);</span><br><span class="line">Channel channel = brokerController.getProducerManager().getAvaliableChannel(groupId);</span><br><span class="line"><span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">    brokerController.getBroker2Client().checkProducerTransactionState(groupId, channel, checkTransactionStateRequestHeader, msgExt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211121220206.png" alt="image-20211121220206065" style="zoom:67%;" />
<p>checkProducerTransactionState的内部实现，就是发送了CHECK_TRANSACTION_STATE报文给Client：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broker2Client.java</span></span><br><span class="line">RemotingCommand request =</span><br><span class="line">    RemotingCommand.createRequestCommand(RequestCode.CHECK_TRANSACTION_STATE, requestHeader);</span><br><span class="line">request.setBody(MessageDecoder.encode(messageExt, <span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.brokerController.getRemotingServer().invokeOneway(channel, request, <span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Check transaction failed because invoke producer exception. group=&#123;&#125;, msgId=&#123;&#125;, error=&#123;&#125;&quot;</span>,</span><br><span class="line">            group, messageExt.getMsgId(), e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户端检查事务状态"><a class="markdownIt-Anchor" href="#客户端检查事务状态"></a> 客户端检查事务状态</h4>
<p>Producer也通过Netty监听了一个端口上，这样也能接收来自外界的命令了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientRemotingProcessor</span> <span class="keyword">extends</span> <span class="title">AsyncNettyRequestProcessor</span> <span class="keyword">implements</span> <span class="title">NettyRequestProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">        RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> RequestCode.CHECK_TRANSACTION_STATE:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.checkTransactionState(ctx, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当收到CHECK_TRANSACTION_STATE命令后，Client会解析出消息的事务ID、存放消息的Broker地址等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String transactionId = messageExt.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line"><span class="keyword">final</span> String group = messageExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP);</span><br><span class="line"><span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">    MQProducerInner producer = <span class="keyword">this</span>.mqClientFactory.selectProducer(group);</span><br><span class="line">    <span class="keyword">if</span> (producer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Broker 地址</span></span><br><span class="line">        <span class="keyword">final</span> String addr = RemotingHelper.parseChannelRemoteAddr(ctx.channel());</span><br><span class="line">        producer.checkTransactionState(addr, messageExt, requestHeader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后checkTransactionState内部则通过线程池提交了一个新的任务，检查事务的状态，并反馈给Broker。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localTransactionState = transactionListener.checkLocalTransaction(message);</span><br><span class="line"><span class="comment">// COMMIT_TYPE 或者 ROLLBACK_TYPE 等</span></span><br><span class="line">thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line">DefaultMQProducerImpl.<span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="acl权限控制"><a class="markdownIt-Anchor" href="#acl权限控制"></a> ACL权限控制</h2>
<p>RocketMQ从4.4.0版本引入了ACL权限控制功能，可以给Topic指定全选，只有拥有权限的消费者才可以进行消费。</p>
<h3 id="使用示例"><a class="markdownIt-Anchor" href="#使用示例"></a> 使用示例</h3>
<p>首先定义一个RPCHook：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACL_ACCESS_KEY = <span class="string">&quot;RocketMQ&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACL_SECRET_KEY = <span class="string">&quot;1234567&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> RPCHook <span class="title">getAclRPCHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AclClientRPCHook(<span class="keyword">new</span> SessionCredentials(ACL_ACCESS_KEY,ACL_SECRET_KEY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在发消息的时候指定RPCHook：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;ProducerGroupName&quot;</span>, getAclRPCHook());</span><br></pre></td></tr></table></figure>
<p>接收消息的时候也需要指定具有同样ACCESS_KEY和SECRET_KEY的RPCHook：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQPullConsumer consumer = <span class="keyword">new</span> DefaultMQPullConsumer(<span class="string">&quot;please_rename_unique_group_name_6&quot;</span>, getAclRPCHook());</span><br></pre></td></tr></table></figure>
<h3 id="rpchook"><a class="markdownIt-Anchor" href="#rpchook"></a> RPCHook</h3>
<p>从示例代码中，我们可以看出可以为Producer指定一个RPCHook，随后此RPCHook会被注册进来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.client.impl.MQClientAPIImpl.class</span></span><br><span class="line"><span class="keyword">this</span>.remotingClient.registerRPCHook(rpcHook);</span><br></pre></td></tr></table></figure>
<p>注册的实质就是将其放入了rpcHooks列表中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.remoting.netty.NettyRemotingAbstract.java</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;RPCHook&gt; rpcHooks = <span class="keyword">new</span> ArrayList&lt;RPCHook&gt;();</span><br></pre></td></tr></table></figure>
<p>在Producer端调用底层API发送命令的前后，调用RPCHook上面的doBeforeRequest和doAfterRequest方法，便于在发送命令的前后拦截：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">invokeSync</span><span class="params">(String addr, <span class="keyword">final</span> RemotingCommand request, <span class="keyword">long</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    doBeforeRpcHooks(addr, request);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    doAfterRpcHooks(RemotingHelper.parseChannelRemoteAddr(channel), request, response);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeforeRpcHooks</span><span class="params">(String addr, RemotingCommand request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rpcHooks.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (RPCHook rpcHook: rpcHooks) &#123;</span><br><span class="line">            rpcHook.doBeforeRequest(addr, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doAfterRpcHooks</span><span class="params">(String addr, RemotingCommand request, RemotingCommand response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rpcHooks.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (RPCHook rpcHook: rpcHooks) &#123;</span><br><span class="line">            rpcHook.doAfterResponse(addr, request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="aclclientrpchook"><a class="markdownIt-Anchor" href="#aclclientrpchook"></a> AclClientRPCHook</h3>
<p>下面来看AclClientRPCHook在发送命令的前后做了什么事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBeforeRequest</span><span class="params">(String remoteAddr, RemotingCommand request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成签名</span></span><br><span class="line">    <span class="keyword">byte</span>[] total = AclUtils.combineRequestContent(request,</span><br><span class="line">        parseRequestContent(request, sessionCredentials.getAccessKey(), sessionCredentials.getSecurityToken()));</span><br><span class="line">    String signature = AclUtils.calSignature(total, sessionCredentials.getSecretKey());</span><br><span class="line">    <span class="comment">// 添加扩展字段</span></span><br><span class="line">    request.addExtField(SIGNATURE, signature);</span><br><span class="line">    request.addExtField(ACCESS_KEY, sessionCredentials.getAccessKey());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The SecurityToken value is unneccessary,user can choose this one.</span></span><br><span class="line">    <span class="keyword">if</span> (sessionCredentials.getSecurityToken() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.addExtField(SECURITY_TOKEN, sessionCredentials.getSecurityToken());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterResponse</span><span class="params">(String remoteAddr, RemotingCommand request, RemotingCommand response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到doBeforeRequest主要完成了两件事情：</p>
<ul>
<li>生成签名</li>
<li>添加扩展字段</li>
</ul>
<h4 id="生成签名"><a class="markdownIt-Anchor" href="#生成签名"></a> 生成签名</h4>
<p>parseRequestContent方法内部将request的自定义头部上面的所有字段的name和value放入到了一个SortedMap中，同时将ACCESS_KEY和SECURITY_TOKEN（如果有）也放了进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(ACCESS_KEY, ak);</span><br><span class="line"><span class="keyword">if</span> (securityToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">    map.put(SECURITY_TOKEN, securityToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然获取类上面的所有字段是通过反射实现的，为了提高性能，也是使用了Map进行了缓存。缓存的只是Field字段，而非value。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConcurrentHashMap&lt;Class&lt;? extends CommandCustomHeader&gt;, Field[]&gt; fieldCache =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;? extends CommandCustomHeader&gt;, Field[]&gt;();</span><br></pre></td></tr></table></figure>
<p>之所以获取到所有字段的值，是为了计算签名，计算签名的方法如下：</p>
<ul>
<li>
<p>首先将上述所有的字段的值拼接成字段，然后获取字节数组，再与请求本身的body的字节数组拼接在一起，获取到最终的byte[]数组。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AclUtils.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] combineRequestContent(RemotingCommand request, SortedMap&lt;String, String&gt; fieldsMap) &#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : fieldsMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!SessionCredentials.SIGNATURE.equals(entry.getKey())) &#123;</span><br><span class="line">            sb.append(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> AclUtils.combineBytes(sb.toString().getBytes(CHARSET), request.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然后通过calSignature方法计算签名，在内部默认采用SigningAlgorithm.HmacSHA1算法获取到签名后的byte[]数组，再通过Base64.encodeBase64将其转为字符串，返回最终的签名。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AclClientRPCHook.java</span></span><br><span class="line">String signature = AclUtils.calSignature(total, sessionCredentials.getSecretKey());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="添加扩展字段"><a class="markdownIt-Anchor" href="#添加扩展字段"></a> 添加扩展字段</h4>
<p>生成签名以后，将签名、ACCESS_KEY、SECURITY_TOKEN（如果有）添加到请求的扩展字段中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.addExtField(SIGNATURE, signature);</span><br><span class="line">request.addExtField(ACCESS_KEY, sessionCredentials.getAccessKey());</span><br><span class="line"></span><br><span class="line"><span class="comment">// The SecurityToken value is unneccessary,user can choose this one.</span></span><br><span class="line"><span class="keyword">if</span> (sessionCredentials.getSecurityToken() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    request.addExtField(SECURITY_TOKEN, sessionCredentials.getSecurityToken());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="broker权限验证"><a class="markdownIt-Anchor" href="#broker权限验证"></a> Broker权限验证</h3>
<p>Broker在初始化ACL的时候会判断用户是否启用了ACL：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BrokerController.java</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.brokerConfig.isAclEnable()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用户开启了ACL，那么会从META-INF路径下去加载所有实现了AccessValidator接口的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ServiceProvider.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACL_VALIDATOR_ID = <span class="string">&quot;META-INF/service/org.apache.rocketmq.acl.AccessValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BrokerController.java</span></span><br><span class="line">List&lt;AccessValidator&gt; accessValidators = ServiceProvider.load(ServiceProvider.ACL_VALIDATOR_ID, AccessValidator.class);</span><br><span class="line"><span class="keyword">if</span> (accessValidators == <span class="keyword">null</span> || accessValidators.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有AccessValidator的实现，那么会注册到Server端的rpcHooks列表中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (AccessValidator accessValidator: accessValidators) &#123;</span><br><span class="line">    <span class="keyword">final</span> AccessValidator validator = accessValidator;</span><br><span class="line">    accessValidatorMap.put(validator.getClass(),validator);</span><br><span class="line">    <span class="keyword">this</span>.registerServerRPCHook(<span class="keyword">new</span> RPCHook() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBeforeRequest</span><span class="params">(String remoteAddr, RemotingCommand request)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//Do not catch the exception</span></span><br><span class="line">            validator.validate(validator.parse(request, remoteAddr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterResponse</span><span class="params">(String remoteAddr, RemotingCommand request, RemotingCommand response)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而Broker中的META-INF/service/org.apache.rocketmq.acl.AccessValidator文件存储的内容如下，即采用PlainAccessValidator作为默认的权限访问校验器。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.apache.rocketmq.acl.plain.PlainAccessValidator</span></span><br></pre></td></tr></table></figure>
<p>Broker端收到请求后，会将请求解析为AcessResource。解析的过程就是要将RemotingCommand中附带的ip地址、ACESS_KEY、签名、SECRET_TOKEN等添加到PlainAccessResource中，并根据不同的命令，给资源添加上不同的访问权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AccessResource <span class="title">parse</span><span class="params">(RemotingCommand request, String remoteAddr)</span> </span>&#123;</span><br><span class="line">    PlainAccessResource accessResource = <span class="keyword">new</span> PlainAccessResource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将远程的地址放到白名单里面</span></span><br><span class="line">    accessResource.setWhiteRemoteAddress(remoteAddr.substring(<span class="number">0</span>, remoteAddr.lastIndexOf(<span class="string">&#x27;:&#x27;</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ACCESS_KEY、SIGNATURE、SECRET_TOKEN 解析出来</span></span><br><span class="line">    accessResource.setAccessKey(request.getExtFields().get(SessionCredentials.ACCESS_KEY));</span><br><span class="line">    accessResource.setSignature(request.getExtFields().get(SessionCredentials.SIGNATURE));</span><br><span class="line">    accessResource.setSecretToken(request.getExtFields().get(SessionCredentials.SECURITY_TOKEN));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的请求，添加不同的资源访问权限</span></span><br><span class="line">    <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> RequestCode.SEND_MESSAGE:</span><br><span class="line">            accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;topic&quot;</span>), Permission.PUB);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> RequestCode.QUERY_MESSAGE:</span><br><span class="line">            accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;topic&quot;</span>), Permission.SUB);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中RocketMQ的Topic资源访问控制权限定义主要如下所示，分为以下四种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permission</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拒绝</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> DENY = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// PUB或者SUB权限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> ANY = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 发送权限，即从Producer端发送出来的命令，所具有的权限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> PUB = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 订阅权限，即从消费端发送出来的命令，所具有的权限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> SUB = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上述示例代码为例，SEND_MESSAGE命令只能是Producer端发送，因此它的权限PUB；而QUERY_MESSAGE命令只能是Consumer端查询，因此它的权限是SUB。</p>
<h4 id="校验权限"><a class="markdownIt-Anchor" href="#校验权限"></a> 校验权限</h4>
<p>生成AccessResource后，便需要对这个资源进行权限校验，校验的具体规则如下：</p>
<ul>
<li>
<p>（1）检查是否命中全局IP白名单；如果是，则认为校验通过；否则走2；</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PlainPermissionManager.java</span></span><br><span class="line"><span class="keyword">for</span> (RemoteAddressStrategy remoteAddressStrategy : globalWhiteRemoteAddressStrategy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (remoteAddressStrategy.match(plainAccessResource)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>（2）检查是否命中用户IP白名单；如果是，则认为校验通过；否则走3；</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PlainPermissionManager.java</span></span><br><span class="line">PlainAccessResource ownedAccess = plainAccessResourceMap.get(plainAccessResource.getAccessKey());</span><br><span class="line"><span class="keyword">if</span> (ownedAccess.getRemoteAddressStrategy().match(plainAccessResource)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>（3）校验签名，校验不通过，抛出异常；校验通过，则走4；</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PlainPermissionManager.java</span></span><br><span class="line">String signature = AclUtils.calSignature(plainAccessResource.getContent(), ownedAccess.getSecretKey());</span><br><span class="line"><span class="keyword">if</span> (!signature.equals(plainAccessResource.getSignature())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;Check signature failed for accessKey=%s&quot;</span>, plainAccessResource.getAccessKey()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>（4）对用户请求所需要的权限和用户所拥有的权限进行校验；不通过，则抛出异常；</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是 Admin 那么直接通过</span></span><br><span class="line"><span class="keyword">if</span> (ownedPermMap == <span class="keyword">null</span> &amp;&amp; ownedAccess.isAdmin()) &#123;</span><br><span class="line">    <span class="comment">// If the ownedPermMap is null and it is an admin user, then return</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Permission.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkPermission</span><span class="params">(<span class="keyword">byte</span> neededPerm, <span class="keyword">byte</span> ownedPerm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((ownedPerm &amp; DENY) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((neededPerm &amp; ANY) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ownedPerm &amp; PUB) &gt; <span class="number">0</span>) || ((ownedPerm &amp; SUB) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (neededPerm &amp; ownedPerm) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>用户所需要的权限校验需要注意以下内容：</p>
<ul>
<li>
<p>特殊的请求如UPDATE_AND_CREATE_TOPIC等，只能由admin账户进行操作；</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PlainPermissionManager.java</span></span><br><span class="line"><span class="keyword">if</span> (Permission.needAdminPerm(needCheckedAccess.getRequestCode()) &amp;&amp; !ownedAccess.isAdmin()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;Need admin permission for request code=%d, but accessKey=%s is not&quot;</span>, needCheckedAccess.getRequestCode(), ownedAccess.getAccessKey()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对于某个资源，如果由显性配置权限，则采用配置的权限；如果没有显性配置权限，则采用默认的权限；</p>
</li>
</ul>
<h4 id="acl权限管理器"><a class="markdownIt-Anchor" href="#acl权限管理器"></a> ACL权限管理器</h4>
<p>上述校验规则的validate方法是放在权限管理器PlainPermissionManager上面的，在新建该类实例的时候，其内部会首先加载YAML格式的权限配置文件，然后在监听这个文件的变化，做到运行时动态的更新权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PLAIN_ACL_FILE = <span class="string">&quot;/conf/plain_acl.yml&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> String fileName = System.getProperty(<span class="string">&quot;rocketmq.acl.plain.file&quot;</span>, DEFAULT_PLAIN_ACL_FILE);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JSONObject plainAclConfData = AclUtils.getYamlDataObject(fileHome + File.separator + fileName, JSONObject.class);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RocketMQ在distribution/conf目录下，给出了一个默认的权限配置文件plain_acl.yml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">globalWhiteRemoteAddresses:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">10.10</span><span class="number">.103</span><span class="string">.*</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="string">.*</span></span><br><span class="line"></span><br><span class="line"><span class="attr">accounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">RocketMQ</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="number">12345678</span></span><br><span class="line">  <span class="attr">whiteRemoteAddress:</span> <span class="number">192.168</span><span class="number">.0</span><span class="string">.*</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">defaultTopicPerm:</span> <span class="string">DENY</span></span><br><span class="line">  <span class="attr">defaultGroupPerm:</span> <span class="string">SUB</span></span><br><span class="line">  <span class="attr">topicPerms:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">topicA=DENY</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">topicB=PUB|SUB</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">topicC=SUB</span></span><br><span class="line">  <span class="attr">groupPerms:</span></span><br><span class="line">  <span class="comment"># the group should convert to retry topic</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">groupA=DENY</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">groupB=SUB</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">groupC=SUB</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">rocketmq2</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="number">12345678</span></span><br><span class="line">  <span class="attr">whiteRemoteAddress:</span> <span class="number">192.168</span><span class="number">.1</span><span class="string">.*</span></span><br><span class="line">  <span class="comment"># if it is admin, it could access all resources</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>对于此文件的监听，是通过FileWatchService进行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileWatchService fileWatchService = <span class="keyword">new</span> FileWatchService(<span class="keyword">new</span> String[] &#123;watchFilePath&#125;, <span class="keyword">new</span> FileWatchService.Listener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;The plain acl yml changed, reload the context&quot;</span>);</span><br><span class="line">        load();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">fileWatchService.start();</span><br></pre></td></tr></table></figure>
<p>在FileWatchService内部，其每隔WATCH_INTERVAL=500毫秒，扫描一次指定的所有文件列表。如果某个文件的MD5哈希值有变化，就会调用listener.onChanged方法来通知这个文件发生了变化。</p>
<h2 id="逻辑队列"><a class="markdownIt-Anchor" href="#逻辑队列"></a> 逻辑队列</h2>
<p>当前，MessageQueue和Broker耦合在一起，这意味着Broker数量变化之后，消息队列的数量也会发生变化，这会造成所有的队列都需要一个重新平衡的过程，这个过程可能需要数分钟才能恢复。增加逻辑队列之后，Broker数量的变化不会影响逻辑队列数量的变化，二者可以独立变化。</p>
<h3 id="架构实现"><a class="markdownIt-Anchor" href="#架构实现"></a> 架构实现</h3>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211120120210.png" alt="image-20211120120210815" style="zoom:67%;" />
<p>假设当前一个LogicalQueue从boker1迁移到了broker2，我们迁移仅仅是映射关系，而非实际的数据，所以broker1依然能够正常消费LogicalQueue-0这个逻辑队列里面的数据，我们会将这个队列的状态置为只读，故这个队列不能再写入消息：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211120120638.png" alt="image-20211120120638011" style="zoom:67%;" />
<p>当broker1从commit log和consume queue中清除了所有数据后，QueueStatus变为Expired（不可读也不可写）：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211120121405.png" alt="image-20211120121405761" style="zoom:67%;" />
<p>如果这个LogicQueue再次迁移回broker1,它会重用这个过期的MessageQueue：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211120121516.png" alt="image-20211120121516366" style="zoom:67%;" />
<p>如果这个LogicQueue再次迁移回broker1的时候，当前没有过期的MessageQueue，它会创建一个新的MessageQueue：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211120121640.png" alt="image-20211120121640261" style="zoom:67%;" />
<p>如果broker2下线了，那么上面的所有的LogicQueue都应该进行迁移：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211120121743.png" alt="image-20211120121743706" style="zoom:67%;" />
<p>当broker2上面的所有数据包括commit log和consume queue被消费完后，那么broker2可以被移除掉了：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211120121848.png" alt="image-20211120121848447" style="zoom:67%;" />
<p>当部署了新的broker后，我们可以使用命令来迁移一些LogicQueue到这个broker上，来分担一些流量：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211120121957.png" alt="image-20211120121957775" style="zoom:67%;" />
<h3 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogicalQueuesInfo</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">Integer</span>, <span class="title">List</span>&lt;<span class="title">LogicalQueueRouteData</span>&gt;&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * logical queue offset -&gt; message queue offset mapping</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogicalQueueRouteData</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">LogicalQueueRouteData</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> logicalQueueIndex = -<span class="number">1</span>; <span class="comment">/* -1 means not set */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> logicalQueueDelta = -<span class="number">1</span>; <span class="comment">/* inclusive, -1 means not set, occurred in writeOnly state */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageQueue messageQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> MessageQueueRouteState state = MessageQueueRouteState.Normal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> offsetDelta = <span class="number">0</span>; <span class="comment">// valid when Normal/WriteOnly/ReadOnly</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> offsetMax = -<span class="number">1</span>; <span class="comment">// exclusive, valid when ReadOnly</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Topic路由信息TopicRouteData中增加了和逻辑队列相关的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRouteData</span> <span class="keyword">extends</span> <span class="title">RemotingSerializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> LogicalQueuesInfo logicalQueuesInfo;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造器中，logicQueueIdx封装为了一个brokerName是__logical_queue_broker__，同时queueId是logicQueueIdx的MessageQueue：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendResultForLogicalQueue</span> <span class="keyword">extends</span> <span class="title">SendResult</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SendResultForLogicalQueue</span><span class="params">(SendResult sendResult, <span class="keyword">int</span> logicalQueueIdx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(sendResult.getSendStatus(), sendResult.getMsgId(), sendResult.getOffsetMsgId(),</span><br><span class="line">            	<span class="keyword">new</span> MessageQueue(sendResult.getMessageQueue().getTopic(), MixAll.LOGICAL_QUEUE_MOCK_BROKER_NAME, logicalQueueIdx),</span><br><span class="line">            	sendResult.getQueueOffset());</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullResultWithLogicalQueues</span> <span class="keyword">extends</span> <span class="title">PullResultExt</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rocketmq中的设计模式"><a class="markdownIt-Anchor" href="#rocketmq中的设计模式"></a> RocketMQ中的设计模式</h1>
<h2 id="监听者模式"><a class="markdownIt-Anchor" href="#监听者模式"></a> 监听者模式</h2>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>[1] <a href="https://rocketmq.apache.org/docs/quick-start/">RocketMQ官方文档</a></p>
<p>[2] <a href="https://kunzhao.org/docs/rocketmq/rocketmq-send-message-flow/">RocketMQ源码分析</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Netty</title>
    <url>/2021/09/10/Netty/</url>
    <content><![CDATA[<p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p>
<span id="more"></span>
<h1 id="netty特性总览"><a class="markdownIt-Anchor" href="#netty特性总览"></a> Netty特性总览</h1>
<p>Netty是一个基于NIO的服务端/客户端框架，整体的架构设计如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210910173546.png" alt="Netty架构示意图" style="zoom:50%;" />
<h2 id="netty特点"><a class="markdownIt-Anchor" href="#netty特点"></a> Netty特点</h2>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3>
<ul>
<li>做为RPC网络通讯框架，实现远程过程调用</li>
<li>做为长连接的服务器</li>
<li>做为Http的服务器</li>
</ul>
<h3 id="良好的设计"><a class="markdownIt-Anchor" href="#良好的设计"></a> 良好的设计</h3>
<ul>
<li>对于阻塞和非阻塞模型提供了统一的API</li>
<li>具有灵活、可扩展的模型</li>
<li>提供高度可定制的线程模型，例如单线程或者线程池（SEDA）</li>
<li>支持实现真正的无连接的socket协议</li>
</ul>
<h3 id="使用简单"><a class="markdownIt-Anchor" href="#使用简单"></a> 使用简单</h3>
<ul>
<li>完善的Javadoc以及示例</li>
<li>支持JDK5及以上版本</li>
</ul>
<h3 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h3>
<ul>
<li>更高的吞吐量，更低的延迟</li>
<li>功耗更小</li>
<li>将不必要的资源拷贝降到最低（零拷贝技术）</li>
</ul>
<h3 id="安全"><a class="markdownIt-Anchor" href="#安全"></a> 安全</h3>
<p>支持SSL/TLS</p>
<h2 id="netty架构实现"><a class="markdownIt-Anchor" href="#netty架构实现"></a> Netty架构实现</h2>
<h3 id="netty的hello-world"><a class="markdownIt-Anchor" href="#netty的hello-world"></a> Netty的Hello world</h3>
<p>定义好服务器端相关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.接收请求</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">// 2.处理请求</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 启动服务端的类，对启动Netty做的封装</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> TestServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义好初始化器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="comment">// 注意不要使用单例对象</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;httpServerCodec&quot;</span>, <span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        pipeline.addLast(<span class="string">&quot;testHttpServerHandler&quot;</span>,<span class="keyword">new</span> TestHttpServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义好处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;hello world&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">            FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1,</span><br><span class="line">                    HttpResponseStatus.OK, content);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就可以通过GET、POST、PUT等Http请求去调用，需要注意的是，如果是通过浏览器访问，浏览器会自动调用另外一个请求：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210913212924.png" alt="image-20210913212924732" /></p>
<p>因此对于处理器我们做如下修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">            HttpRequest httpRequest = (HttpRequest) msg;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;request method name: &quot;</span> + httpRequest.method().name());</span><br><span class="line"></span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(httpRequest.uri());</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;request favicon.ico&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;hello world&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">            FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1,</span><br><span class="line">                    HttpResponseStatus.OK, content);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一个基于Netty的Hello world就成功的运行了起来。</p>
<h2 id="netty模块分析"><a class="markdownIt-Anchor" href="#netty模块分析"></a> Netty模块分析</h2>
<h3 id="netty整体执行流程分析"><a class="markdownIt-Anchor" href="#netty整体执行流程分析"></a> Netty整体执行流程分析</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">            HttpRequest httpRequest = (HttpRequest) msg;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// System.out.println(&quot;request method name: &quot; + httpRequest.method().name());</span></span><br><span class="line"></span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(httpRequest.uri());</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;</span><br><span class="line">                <span class="comment">// System.out.println(&quot;request favicon.ico&quot;);</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;hello world&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">            FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1,</span><br><span class="line">                    HttpResponseStatus.OK, content);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channel active&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channel registered&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelRegistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channel unregistered&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelUnregistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channel inactive&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelInactive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channel added&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.handlerAdded(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子想要说明的是，在Servlet编程模型中，关闭连接都是自动完成的，而在Netty当中，关闭的时机是可以自定义的，这样每次调用之后就会关闭了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.channel().close();</span><br></pre></td></tr></table></figure>
<h2 id="netty对socket的实现"><a class="markdownIt-Anchor" href="#netty对socket的实现"></a> Netty对Socket的实现</h2>
<p>Netty不仅可以做为服务端，也可以作为客户端的基础设施。</p>
<h3 id="socket使用示例"><a class="markdownIt-Anchor" href="#socket使用示例"></a> Socket使用示例</h3>
<p>类似的，我们首先定义好服务端相关的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot;,&quot;</span> + msg);</span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">&quot;from server: &quot;</span> + UUID.randomUUID());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info"><p>在Netty中有两种发送消息的方式，可以直接写到Channel中，也可以写到与ChannelHandler所关联的那个ChannelHanderContext中。对于前一种方式来说，消息会从ChannelPipline的末尾开始流动，对于后一种方式来说，消息将从ChannelPipline中的下一个ChannelHandler开始流动。</p></div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是客户端的相关示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class).</span><br><span class="line">                    handler(<span class="keyword">new</span> MyClientInitializer()); <span class="comment">// 这里也可以使用匿名内部类</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.writeAndFlush(<span class="string">&quot;from client!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;client output: &quot;</span> + msg);</span><br><span class="line">        ctx.writeAndFlush(<span class="string">&quot;from client: &quot;</span> + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息的广播"><a class="markdownIt-Anchor" href="#消息的广播"></a> 消息的广播</h3>
<p>首先定义好服务端内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyChatServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">4096</span>, Delimiters.lineDelimiter()));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyChatServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.forEach(ch -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != ch) &#123;</span><br><span class="line">                channel.writeAndFlush(channel.remoteAddress() + <span class="string">&quot;send message: &quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;[mine]&quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[server] - &quot;</span> + channel.remoteAddress() + <span class="string">&quot;join\n&quot;</span>);</span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[server] - &quot;</span> + channel.remoteAddress() + <span class="string">&quot;remove\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(channelGroup.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        System.out.println(channel.remoteAddress() + <span class="string">&quot;online&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        System.out.println(channel.remoteAddress() + <span class="string">&quot;offline&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后定义好服务端示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class).</span><br><span class="line">                    handler(<span class="keyword">new</span> MyChatClientInitializer());</span><br><span class="line">            Channel channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8899</span>).sync().channel();</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                channel.writeAndFlush(br.readLine() + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">4096</span>, Delimiters.lineDelimiter()));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyChatClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="心跳机制"><a class="markdownIt-Anchor" href="#心跳机制"></a> 心跳机制</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO)).childHandler(<span class="keyword">new</span> MyServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="comment">// 空闲状态检测的处理器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>, TimeUnit.SECONDS));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">            String eventType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state()) &#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;read idle&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;write idle&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;all idle&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot;time out event: &quot;</span> + eventType);</span><br><span class="line"></span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="netty与websocket"><a class="markdownIt-Anchor" href="#netty与websocket"></a> Netty与WebSocket</h2>
<p>原来基于Http协议实现的长链接存在的问题：</p>
<ul>
<li>轮询机制下，消息还是无法实时传递</li>
<li>请求需要携带请求头</li>
<li>消耗资源</li>
</ul>
<p>WebSocket是基于Http协议的升级协议，是一种真正的全双工的协议。</p>
<h3 id="实现与原理分析"><a class="markdownIt-Anchor" href="#实现与原理分析"></a> 实现与原理分析</h3>
<p>WebSocket协议是基于Http的升级协议，所以浏览器在请求WebSocket的请求时实际上会请求两次。</p>
<h3 id="websocket生命周期分解"><a class="markdownIt-Anchor" href="#websocket生命周期分解"></a> WebSocket生命周期分解</h3>
<p>服务端示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO)).childHandler(<span class="keyword">new</span> WebSocketChannelInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8899</span>)).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</span><br><span class="line">        <span class="comment">// ws://server:port/context_path(localhost:9999/ws)</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/ws&quot;</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> TextWebSocketFrameHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;receive &quot;</span> + msg.text());</span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;server time: &quot;</span> + LocalDateTime.now()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded: &quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved: &quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;exception happen...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket客户端<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> socket;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(<span class="built_in">window</span>.WebSocket) &#123;</span></span><br><span class="line"><span class="javascript">        socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:8899/ws&quot;</span>);</span></span><br><span class="line"><span class="javascript">        socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ta = <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="javascript">            ta.value = ta.value + <span class="string">&quot;\n&quot;</span> + event.data;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ta = <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="javascript">            ta.value = <span class="string">&quot;连接开启&quot;</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ta = <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="javascript">            ta.value = ta.value + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;连接关闭&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&quot;not support&quot;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">message</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(!<span class="built_in">window</span>.WebSocket) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(socket.readyState == WebSocket.OPEN) &#123;</span></span><br><span class="line"><span class="javascript">            socket.send(message);</span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;连接尚未开启！&quot;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:400px;height:200px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;发送数据&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;send(this.form.message.value)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>服务端输出: <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;responseText&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:400px;height:300px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;javascript:document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清空内容&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210915235332.png" alt="image-20210915235325539" style="zoom:50%;" />
<h1 id="rpc框架分析"><a class="markdownIt-Anchor" href="#rpc框架分析"></a> RPC框架分析</h1>
<h2 id="google-protobuf"><a class="markdownIt-Anchor" href="#google-protobuf"></a> Google Protobuf</h2>
<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3>
<p>Google Protobuf的前身：rmi（remote method invocation），只有Java语言才可以使用，其中涉及到两个角色：</p>
<ul>
<li>client：stub</li>
<li>server：skeleton</li>
</ul>
<div class="note info"><p>序列化与反序列化，也叫做：编码与解码。</p></div>
<p>RPC：Romote Produre Call（远程过程调用），很多RPC框架都是跨语言的，RPC框架一般的使用规则如下：</p>
<ul>
<li>定义一个接口说明文件：描述了对象（结构体）、对象成员、接口方法等一系列信息</li>
<li>通过RPC框架所提供的编译器，将接口说明文件编译成具体的语言文件</li>
<li>在客户端与服务器端分别引入RPC编译器所生成的文件，即可像调用本地方法一样调用远程方法</li>
</ul>
<h3 id="proto文件"><a class="markdownIt-Anchor" href="#proto文件"></a> proto文件</h3>
<p>.proto文件的示例：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">syntax</span> = <span class="string">&quot;proto2&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">package</span> <span class="string">tutorial;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">option</span> <span class="string">java_multiple_files = true;</span></span><br><span class="line"><span class="attr">option</span> <span class="string">java_package = &quot;com.example.tutorial.protos&quot;;</span></span><br><span class="line"><span class="attr">option</span> <span class="string">java_outer_classname = &quot;AddressBookProtos&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">message</span> <span class="string">Person &#123;</span></span><br><span class="line">  <span class="attr">optional</span> <span class="string">string name = 1;</span></span><br><span class="line">  <span class="attr">optional</span> <span class="string">int32 id = 2;</span></span><br><span class="line">  <span class="attr">optional</span> <span class="string">string email = 3;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">enum</span> <span class="string">PhoneType &#123;</span></span><br><span class="line">    <span class="attr">MOBILE</span> = <span class="string">0;</span></span><br><span class="line">    <span class="attr">HOME</span> = <span class="string">1;</span></span><br><span class="line">    <span class="attr">WORK</span> = <span class="string">2;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">message</span> <span class="string">PhoneNumber &#123;</span></span><br><span class="line">    <span class="attr">optional</span> <span class="string">string number = 1;</span></span><br><span class="line">    <span class="attr">optional</span> <span class="string">PhoneType type = 2 [default = HOME];</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">repeated</span> <span class="string">PhoneNumber phones = 4;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">message</span> <span class="string">AddressBook &#123;</span></span><br><span class="line">  <span class="attr">repeated</span> <span class="string">Person people = 1;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
<p>构建一个message的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person john =</span><br><span class="line">  Person.newBuilder()</span><br><span class="line">    .setId(<span class="number">1234</span>)</span><br><span class="line">    .setName(<span class="string">&quot;John Doe&quot;</span>)</span><br><span class="line">    .setEmail(<span class="string">&quot;jdoe@example.com&quot;</span>)</span><br><span class="line">    .addPhones(</span><br><span class="line">      Person.PhoneNumber.newBuilder()</span><br><span class="line">        .setNumber(<span class="string">&quot;555-4321&quot;</span>)</span><br><span class="line">        .setType(Person.PhoneType.HOME))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>内置方法：</p>
<ul>
<li>isInitialized()</li>
<li>toString()</li>
<li>mergeFrom(Message other)</li>
<li>clear()</li>
</ul>
<h3 id="解析和序列化"><a class="markdownIt-Anchor" href="#解析和序列化"></a> 解析和序列化</h3>
<p>每一个protocol buffer都有读写二进制消息的方法：</p>
<ul>
<li>byte[] toByteArray()</li>
<li>static Person parseFrom(byte[] data)</li>
<li>void writeTo(OutputStream output)</li>
<li>static Person parseFrom(InputStream input)</li>
</ul>
<div class="note warning"><p>message对象并不支持继承。</p></div>
<h3 id="编写message"><a class="markdownIt-Anchor" href="#编写message"></a> 编写message</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.tutorial.protos.AddressBook;</span><br><span class="line"><span class="keyword">import</span> com.example.tutorial.protos.Person;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddPerson</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This function fills in a Person message based on user input.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Person <span class="title">PromptForAddress</span><span class="params">(BufferedReader stdin,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 PrintStream stdout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Person.Builder person = Person.newBuilder();</span><br><span class="line"></span><br><span class="line">    stdout.print(<span class="string">&quot;Enter person ID: &quot;</span>);</span><br><span class="line">    person.setId(Integer.valueOf(stdin.readLine()));</span><br><span class="line"></span><br><span class="line">    stdout.print(<span class="string">&quot;Enter name: &quot;</span>);</span><br><span class="line">    person.setName(stdin.readLine());</span><br><span class="line"></span><br><span class="line">    stdout.print(<span class="string">&quot;Enter email address (blank for none): &quot;</span>);</span><br><span class="line">    String email = stdin.readLine();</span><br><span class="line">    <span class="keyword">if</span> (email.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      person.setEmail(email);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      stdout.print(<span class="string">&quot;Enter a phone number (or leave blank to finish): &quot;</span>);</span><br><span class="line">      String number = stdin.readLine();</span><br><span class="line">      <span class="keyword">if</span> (number.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Person.PhoneNumber.Builder phoneNumber =</span><br><span class="line">        Person.PhoneNumber.newBuilder().setNumber(number);</span><br><span class="line"></span><br><span class="line">      stdout.print(<span class="string">&quot;Is this a mobile, home, or work phone? &quot;</span>);</span><br><span class="line">      String type = stdin.readLine();</span><br><span class="line">      <span class="keyword">if</span> (type.equals(<span class="string">&quot;mobile&quot;</span>)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.MOBILE);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;home&quot;</span>)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.HOME);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;work&quot;</span>)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.WORK);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stdout.println(<span class="string">&quot;Unknown phone type.  Using default.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      person.addPhones(phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> person.build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Main function:  Reads the entire address book from a file,</span></span><br><span class="line">  <span class="comment">//   adds one person based on user input, then writes it back out to the same</span></span><br><span class="line">  <span class="comment">//   file.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">      System.err.println(<span class="string">&quot;Usage:  AddPerson ADDRESS_BOOK_FILE&quot;</span>);</span><br><span class="line">      System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AddressBook.Builder addressBook = AddressBook.newBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the existing address book.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      addressBook.mergeFrom(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      System.out.println(args[<span class="number">0</span>] + <span class="string">&quot;: File not found.  Creating a new file.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add an address.</span></span><br><span class="line">    addressBook.addPerson(</span><br><span class="line">      PromptForAddress(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)),</span><br><span class="line">                       System.out));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write the new address book back to disk.</span></span><br><span class="line">    FileOutputStream output = <span class="keyword">new</span> FileOutputStream(args[<span class="number">0</span>]);</span><br><span class="line">    addressBook.build().writeTo(output);</span><br><span class="line">    output.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取message"><a class="markdownIt-Anchor" href="#读取message"></a> 读取message</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.tutorial.protos.AddressBook;</span><br><span class="line"><span class="keyword">import</span> com.example.tutorial.protos.Person;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListPeople</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Iterates though all people in the AddressBook and prints info about them.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(AddressBook addressBook)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person person: addressBook.getPeopleList()) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Person ID: &quot;</span> + person.getId());</span><br><span class="line">      System.out.println(<span class="string">&quot;  Name: &quot;</span> + person.getName());</span><br><span class="line">      <span class="keyword">if</span> (person.hasEmail()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;  E-mail address: &quot;</span> + person.getEmail());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Person.PhoneNumber phoneNumber : person.getPhonesList()) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (phoneNumber.getType()) &#123;</span><br><span class="line">          <span class="keyword">case</span> MOBILE:</span><br><span class="line">            System.out.print(<span class="string">&quot;  Mobile phone #: &quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> HOME:</span><br><span class="line">            System.out.print(<span class="string">&quot;  Home phone #: &quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> WORK:</span><br><span class="line">            System.out.print(<span class="string">&quot;  Work phone #: &quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(phoneNumber.getNumber());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Main function:  Reads the entire address book from a file and prints all</span></span><br><span class="line">  <span class="comment">//   the information inside.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">      System.err.println(<span class="string">&quot;Usage:  ListPeople ADDRESS_BOOK_FILE&quot;</span>);</span><br><span class="line">      System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the existing address book.</span></span><br><span class="line">    AddressBook addressBook =</span><br><span class="line">      AddressBook.parseFrom(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    Print(addressBook);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多协议消息"><a class="markdownIt-Anchor" href="#多协议消息"></a> 多协议消息</h3>
<p>一般来说有两种解决方案：</p>
<ul>
<li>自定义解码器</li>
<li>通过枚举指定所有可能出现的类型</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> com.jyc.protobuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> optimize_for = SPEED;</span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.jyc.netty.sixth.example&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;MyDataInfo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyMessage</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">DataType</span> </span>&#123;</span><br><span class="line">    PersonType = <span class="number">1</span>;</span><br><span class="line">    DogType = <span class="number">2</span>;</span><br><span class="line">    CatType = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> DataType data_type = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">oneof</span> dataBody &#123;</span><br><span class="line">    Person person = <span class="number">2</span>;</span><br><span class="line">    Dog dog = <span class="number">3</span>;</span><br><span class="line">    Cat cat = <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> address = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> city = <span class="number">2</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="最佳实践"><a class="markdownIt-Anchor" href="#最佳实践"></a> 最佳实践</h3>
<p>如何共享生成的对象是一个问题，那么实际项目中该如何共享呢？</p>
<ul>
<li>git submodule</li>
<li>git subtree</li>
<li>nexus（每次需要都发布，并且修改版本号）</li>
</ul>
<h2 id="apache-thrift"><a class="markdownIt-Anchor" href="#apache-thrift"></a> Apache Thrift</h2>
<h3 id="简介-2"><a class="markdownIt-Anchor" href="#简介-2"></a> 简介</h3>
<p>thrift最初由Facebook研发，主要用于各个服务之间的RPC通信，支持跨语言，常用的语言比如C++、Java、Python、PHP、Ruby、Erlang、Perl、Haskell、C#、Cocoa、JavaScript、Node.js、Smalltalk和OCaml都支持，与protobuf相比，支持的语言种类更多。</p>
<p>thrift是一个典型的CS（客户端/服务端）结构，客户端和服务端可以使用不同的语言开发，他们之间需要一种中间语言来关联，这种语言就是IDL（Interface Description Language）。</p>
<p>thrift不支持无符号类型。因为很多编程语言不存在无符号类型，比如Java，集合中的元素可以是除了service之外的任何类型，包括exception。</p>
<p>thrift中的容器类型：</p>
<ul>
<li>list：一系列由T类型的数据组成的有序列表，元素可以重复</li>
<li>set：一系列由T类型的数据组成的无序集合，元素不可重复</li>
<li>map：一个字典结构，key为K类型，value为V类型，相当于Java中的HashMap</li>
</ul>
<p>thrift数据传输使用socket（多种语言均支持），数据再以特定的格式（string等）发送，接收方语言进行解析。</p>
<p>安装命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> choco install thrift</span></span><br></pre></td></tr></table></figure>
<h3 id="thrift文件"><a class="markdownIt-Anchor" href="#thrift文件"></a> thrift文件</h3>
<p>.thrift文件的示例：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">namespace java thrift.generated</span><br><span class="line"></span><br><span class="line">typedef i64 short</span><br><span class="line">typedef i32 int</span><br><span class="line">typedef i64 long</span><br><span class="line">typedef <span class="built_in">bool</span> boolean</span><br><span class="line">typedef <span class="built_in">string</span> String</span><br><span class="line"></span><br><span class="line">struct Person &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">optional</span> String username,</span><br><span class="line">    <span class="number">2</span>: <span class="keyword">optional</span> int age,</span><br><span class="line">    <span class="number">3</span>: <span class="keyword">optional</span> boolean married</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exception DataException &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">optional</span> String <span class="class"><span class="keyword">message</span>,</span></span><br><span class="line"><span class="class">    2: <span class="title">optional</span> String callStack,</span></span><br><span class="line"><span class="class">    3: optional String date</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">service PersonService </span>&#123;</span><br><span class="line">    Person getPersonByUsername(<span class="number">1</span>:<span class="keyword">required</span> String username) throws(<span class="number">1</span>: DataException dataException),</span><br><span class="line">    void savePerson(<span class="number">1</span>:<span class="keyword">required</span> Person person) throws(<span class="number">1</span>: DataException dataException)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> thrift --gen java .\src\thrift\data.thrift</span></span><br></pre></td></tr></table></figure>
<h3 id="最佳实践-2"><a class="markdownIt-Anchor" href="#最佳实践-2"></a> 最佳实践</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPersonByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> DataException, TException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Got client param: &quot;</span> + username);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person().setUsername(username).setAge(<span class="number">20</span>).setMarried(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">savePerson</span><span class="params">(Person person)</span> <span class="keyword">throws</span> DataException, TException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Got client param: &quot;</span> + person);</span><br><span class="line">        System.out.println(person.getUsername());</span><br><span class="line">        System.out.println(person.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThriftServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TNonblockingServerSocket socket = <span class="keyword">new</span> TNonblockingServerSocket(<span class="number">8899</span>);</span><br><span class="line">        THsHaServer.Args arg = <span class="keyword">new</span> THsHaServer.Args(socket).minWorkerThreads(<span class="number">2</span>).maxWorkerThreads(<span class="number">4</span>);</span><br><span class="line">        PersonService.Processor&lt;PersonServiceImpl&gt; processor = <span class="keyword">new</span> PersonService.Processor&lt;&gt;(<span class="keyword">new</span> PersonServiceImpl());</span><br><span class="line">        arg.protocolFactory(<span class="keyword">new</span> TCompactProtocol.Factory());</span><br><span class="line">        arg.transportFactory(<span class="keyword">new</span> TFramedTransport.Factory());</span><br><span class="line">        arg.processorFactory(<span class="keyword">new</span> TProcessorFactory(processor));</span><br><span class="line"></span><br><span class="line">        TServer server = <span class="keyword">new</span> THsHaServer(arg);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;thrift server started!&quot;</span>);</span><br><span class="line">        server.serve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThriftClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TTransport transport = <span class="keyword">new</span> TFramedTransport(<span class="keyword">new</span> TSocket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8899</span>), <span class="number">600</span>);</span><br><span class="line">        TCompactProtocol protocol = <span class="keyword">new</span> TCompactProtocol(transport);</span><br><span class="line">        PersonService.Client client = <span class="keyword">new</span> PersonService.Client(protocol);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transport.open();</span><br><span class="line">            Person person = client.getPersonByUsername(<span class="string">&quot;jyc&quot;</span>);</span><br><span class="line">            System.out.println(person.getAge());</span><br><span class="line">            System.out.println(person.getUsername());</span><br><span class="line"></span><br><span class="line">            Person person2 = <span class="keyword">new</span> Person();</span><br><span class="line">            person2.setUsername(<span class="string">&quot;jjj&quot;</span>);</span><br><span class="line">            person2.setAge(<span class="number">30</span>);</span><br><span class="line">            person2.setMarried(<span class="keyword">true</span>);</span><br><span class="line">            client.savePerson(person2);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex.getMessage(), ex);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            transport.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传输格式"><a class="markdownIt-Anchor" href="#传输格式"></a> 传输格式</h3>
<ul>
<li>TBinaryProtocol - 二进制格式</li>
<li>TCompactProtocol - 压缩格式</li>
<li>TJSONProtocol - JSON格式</li>
<li>TSimpleJSONProtocol - 提供JSON只写协议，生成的文件很容易通过脚本语言解析</li>
<li>TDebugProtocol - 使用易懂的可读的文本格式，以便于debug</li>
</ul>
<h3 id="传输方式"><a class="markdownIt-Anchor" href="#传输方式"></a> 传输方式</h3>
<ul>
<li>TSocket - 阻塞式socket</li>
<li>TCompactProtocol 以frame为单位进行传输，非阻塞式服务中使用</li>
<li>TFileTransport - 以文件形式进行传输</li>
<li>TMemoryTransport - 将内存用于I/O，Java实现时内部实际使用了简单的ByteArrayOutputStream</li>
<li>TZlibTransport - 使用zlib进行压缩，与其他传输方式联合使用</li>
</ul>
<h3 id="服务模型"><a class="markdownIt-Anchor" href="#服务模型"></a> 服务模型</h3>
<ul>
<li>TSimpleServer - 简单的单线程服务模型，通常用于测试</li>
<li>TThreadPoolServer - 多线程服务模型，使用标准的阻塞式IO</li>
<li>TNonblockingServer - 多线程服务模型，使用非阻塞IO（需使用TFramedTransport数据传输方式）</li>
<li>THsHaServer - THsHa引入了线程池去处理，其模型把读写任务放到线程池中去处理；Half-sync/Half-sync的处理模式，Half-async是在处理IO事件上（accept/read/write io），Half-sync用于handler对rpc的同步处理</li>
</ul>
<h3 id="多语言的支持"><a class="markdownIt-Anchor" href="#多语言的支持"></a> 多语言的支持</h3>
<p>接下来的例子，我们将使用Python作为客户端，Java作为服务端。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__author__ = <span class="string">&#x27;作者&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> py.thrift.generated <span class="keyword">import</span> PersonService</span><br><span class="line"><span class="keyword">from</span> py.thrift.generated <span class="keyword">import</span> ttypes</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> thrift <span class="keyword">import</span> Thrift</span><br><span class="line"><span class="keyword">from</span> thrift <span class="keyword">import</span> transport</span><br><span class="line"><span class="keyword">from</span> thrift <span class="keyword">import</span> protocol</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TSocket</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TTransport</span><br><span class="line"><span class="keyword">from</span> thrift.protocol <span class="keyword">import</span> TCompactProtocol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    tSocket = TSocket.TSocket(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">8899</span>)</span><br><span class="line">    tSocket.setTimeout(<span class="number">600</span>)</span><br><span class="line"></span><br><span class="line">    transport = TTransport.TFramedTransport(tSocket)</span><br><span class="line">    protocol = TCompactProtocol.TCompactProtocol(transport)</span><br><span class="line">    client = PersonService.Client(protocol)</span><br><span class="line"></span><br><span class="line">    transport.<span class="built_in">open</span>()</span><br><span class="line"></span><br><span class="line">    person = client.getPersonByUsername(<span class="string">&quot;jyc&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(person.username)</span><br><span class="line">    <span class="built_in">print</span>(person.age)</span><br><span class="line">    <span class="built_in">print</span>(person.married)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    newPerson = ttypes.Person()</span><br><span class="line">    newPerson.username = <span class="string">&#x27;jjj&#x27;</span></span><br><span class="line">    newPerson.age = <span class="number">30</span></span><br><span class="line">    newPerson.married = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    client.savePerson(newPerson)</span><br><span class="line"></span><br><span class="line">    transport.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Thrift.TException <span class="keyword">as</span> tx:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s&#x27;</span> % tx.message)</span><br></pre></td></tr></table></figure>
<p>将python作为服务端，将Java作为客户端：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__author__ = <span class="string">&#x27;作者&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> py.thrift.generated <span class="keyword">import</span> ttypes</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPersonByUsername</span>(<span class="params">self,username</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Got Client param: &#x27;</span> + username)</span><br><span class="line"></span><br><span class="line">        person = ttypes.Person()</span><br><span class="line">        person.username = username</span><br><span class="line">        person.age = <span class="number">20</span></span><br><span class="line">        person.married = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> person</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">savePerson</span>(<span class="params">self, person</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Got Client param: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(person.username)</span><br><span class="line">        <span class="built_in">print</span>(person.age)</span><br><span class="line">        <span class="built_in">print</span>(person.married)</span><br></pre></td></tr></table></figure>
<p>服务端代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__author__ = <span class="string">&#x27;作者&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> thrift <span class="keyword">import</span> server</span><br><span class="line"><span class="keyword">from</span> PersonServiceImpl <span class="keyword">import</span> PersonServiceImpl</span><br><span class="line"><span class="keyword">from</span> py.thrift.generated <span class="keyword">import</span> PersonService</span><br><span class="line"><span class="keyword">from</span> thrift <span class="keyword">import</span> Thrift</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TSocket</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TTransport</span><br><span class="line"><span class="keyword">from</span> thrift.server <span class="keyword">import</span> TServer</span><br><span class="line"><span class="keyword">from</span> thrift.protocol <span class="keyword">import</span> TCompactProtocol</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    PersonServiceHandler = PersonServiceImpl()</span><br><span class="line">    processor = PersonService.Processor(PersonServiceHandler)</span><br><span class="line"></span><br><span class="line">    serverSocket = TSocket.TServerSocket(port=<span class="number">8899</span>)</span><br><span class="line">    transportFactory = TTransport.TFramedTransportFactory()</span><br><span class="line">    protocolFactory = TCompactProtocol.TCompactProtocolFactory()</span><br><span class="line"></span><br><span class="line">    server = TServer.TSimpleServer(processor, serverSocket, transportFactory, protocolFactory)</span><br><span class="line">    server.serve()</span><br><span class="line"><span class="keyword">except</span> Thrift.TException <span class="keyword">as</span> ex:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s&#x27;</span> % ex.message)</span><br></pre></td></tr></table></figure>
<p>可以看到，thrift在跨语言的时候的作用。</p>
<h2 id="grpc"><a class="markdownIt-Anchor" href="#grpc"></a> GRPC</h2>
<h3 id="简介-3"><a class="markdownIt-Anchor" href="#简介-3"></a> 简介</h3>
<p>GRPC是基于protobuf的RPC远程调用框架。</p>
<h3 id="相关示例"><a class="markdownIt-Anchor" href="#相关示例"></a> 相关示例</h3>
<p>所使用的protobuf的文件：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.jyc.proto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.jyc.proto&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;StudentProto&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetRealNameByUsername(MyRequest) <span class="keyword">returns</span> (MyResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> username = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyResponse</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> realname = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gradle配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;2.5.4&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="string">&#x27;1.0.11.RELEASE&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;com.google.protobuf&#x27;</span> version <span class="string">&#x27;0.8.17&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = <span class="string">&#x27;com.jyc.netty&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class="line">sourceCompatibility = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">targetCompatibility = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;io.netty:netty-all:4.1.66.Final&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.thrift:libthrift:0.14.2&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.google.protobuf:protobuf-java:4.0.0-rc-2&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;io.grpc:grpc-netty-shaded:1.40.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;io.grpc:grpc-protobuf:1.40.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;io.grpc:grpc-stub:1.40.1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protobuf &#123;</span><br><span class="line">    protoc &#123;</span><br><span class="line">        artifact = <span class="string">&quot;com.google.protobuf:protoc:3.17.3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    plugins &#123;</span><br><span class="line">        grpc &#123;</span><br><span class="line">            artifact = <span class="string">&#x27;io.grpc:protoc-gen-grpc-java:1.40.1&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    generateProtoTasks &#123;</span><br><span class="line">        all()*.plugins &#123;</span><br><span class="line">            grpc &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceImpl</span> <span class="keyword">extends</span> <span class="title">StudentServiceGrpc</span>.<span class="title">StudentServiceImplBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getRealNameByUsername</span><span class="params">(MyRequest request, StreamObserver&lt;MyResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;receive client info: &quot;</span> + request.getUsername());</span><br><span class="line">        <span class="comment">// 构造结果并返回</span></span><br><span class="line">        responseObserver.onNext(MyResponse.newBuilder().setRealname(<span class="string">&quot;jyc&quot;</span>).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Server server;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        server = ServerBuilder.forPort(<span class="number">8899</span>).addService(<span class="keyword">new</span> StudentServiceImpl()).build().start();</span><br><span class="line">        System.out.println(<span class="string">&quot;server started!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">            server.shutdown().awaitTermination(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">            System.out.println(<span class="string">&quot;server stop!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要手动设置阻塞</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">blockUntilShutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        GrpcServer server = <span class="keyword">new</span> GrpcServer();</span><br><span class="line">        server.start();</span><br><span class="line">        <span class="comment">// 如果不设置，启动就会退出</span></span><br><span class="line">        server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrpcClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8899</span>).usePlaintext().build();</span><br><span class="line">        StudentServiceGrpc.StudentServiceBlockingStub blockingStub = StudentServiceGrpc.newBlockingStub(managedChannel);</span><br><span class="line">        MyResponse myResponse = blockingStub.getRealNameByUsername(MyRequest.newBuilder().setUsername(<span class="string">&quot;zhangsan&quot;</span>).build());</span><br><span class="line">        System.out.println(myResponse.getRealname());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="流式调用"><a class="markdownIt-Anchor" href="#流式调用"></a> 流式调用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.jyc.proto;</span><br><span class="line"></span><br><span class="line">option java_package = <span class="string">&quot;com.jyc.proto&quot;</span>;</span><br><span class="line">option java_outer_classname = <span class="string">&quot;StudentProto&quot;</span>;</span><br><span class="line">option java_multiple_files = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">service StudentService &#123;</span><br><span class="line">  <span class="function">rpc <span class="title">GetRealNameByUsername</span><span class="params">(MyRequest)</span> <span class="title">returns</span> <span class="params">(MyResponse)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">rpc <span class="title">GetStudentsByAge</span><span class="params">(StudentRequest)</span> <span class="title">returns</span> <span class="params">(stream StudentResponse)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">rpc <span class="title">GetStudentsWrapperByAges</span><span class="params">(stream StudentRequest)</span> <span class="title">returns</span> <span class="params">(StudentResponseList)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">rpc <span class="title">BiTalk</span><span class="params">(stream StreamRequest)</span> <span class="title">returns</span> <span class="params">(stream StreamResponse)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MyRequest &#123;</span><br><span class="line">  string username = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MyResponse &#123;</span><br><span class="line">  string realname = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message StudentRequest &#123;</span><br><span class="line">  int32 age = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message StudentResponse &#123;</span><br><span class="line">  string name = <span class="number">1</span>;</span><br><span class="line">  int32 age = <span class="number">2</span>;</span><br><span class="line">  string city = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message StudentResponseList &#123;</span><br><span class="line">  repeated StudentResponse studentResponse = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message StreamRequest &#123;</span><br><span class="line">  string request_info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message StreamResponse &#123;</span><br><span class="line">  string response_info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jyc.grpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jyc.proto.*;</span><br><span class="line"><span class="keyword">import</span> io.grpc.stub.StreamObserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceImpl</span> <span class="keyword">extends</span> <span class="title">StudentServiceGrpc</span>.<span class="title">StudentServiceImplBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getRealNameByUsername</span><span class="params">(MyRequest request, StreamObserver&lt;MyResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;receive client info: &quot;</span> + request.getUsername());</span><br><span class="line">        <span class="comment">// 构造结果并返回</span></span><br><span class="line">        responseObserver.onNext(MyResponse.newBuilder().setRealname(<span class="string">&quot;jyc&quot;</span>).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStudentsByAge</span><span class="params">(StudentRequest request, StreamObserver&lt;StudentResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;receive client info: &quot;</span> + request.getAge());</span><br><span class="line">        responseObserver.onNext(StudentResponse.newBuilder().setName(<span class="string">&quot;jyc&quot;</span>).setAge(<span class="number">20</span>).setCity(<span class="string">&quot;shenzhen&quot;</span>).build());</span><br><span class="line">        responseObserver.onNext(StudentResponse.newBuilder().setName(<span class="string">&quot;zhangsan&quot;</span>).setAge(<span class="number">30</span>).setCity(<span class="string">&quot;beijing&quot;</span>).build());</span><br><span class="line">        responseObserver.onNext(StudentResponse.newBuilder().setName(<span class="string">&quot;lisi&quot;</span>).setAge(<span class="number">40</span>).setCity(<span class="string">&quot;hangzhou&quot;</span>).build());</span><br><span class="line">        responseObserver.onNext(StudentResponse.newBuilder().setName(<span class="string">&quot;wangwu&quot;</span>).setAge(<span class="number">50</span>).setCity(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StreamObserver&lt;StudentRequest&gt; <span class="title">getStudentsWrapperByAges</span><span class="params">(StreamObserver&lt;StudentResponseList&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StreamObserver&lt;StudentRequest&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(StudentRequest value)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;onNext: &quot;</span> + value.getAge());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(t.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                StudentResponse studentResponse = StudentResponse.newBuilder().setName(<span class="string">&quot;jyc&quot;</span>).setAge(<span class="number">18</span>).setCity(<span class="string">&quot;xian&quot;</span>).build();</span><br><span class="line">                StudentResponse studentResponse2 = StudentResponse.newBuilder().setName(<span class="string">&quot;jycoco&quot;</span>).setAge(<span class="number">18</span>).setCity(<span class="string">&quot;guangzhou&quot;</span>).build();</span><br><span class="line">                StudentResponseList studentResponseList = StudentResponseList.newBuilder().</span><br><span class="line">                        addStudentResponse(studentResponse).addStudentResponse(studentResponse2).build();</span><br><span class="line">                responseObserver.onNext(studentResponseList);</span><br><span class="line">                responseObserver.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StreamObserver&lt;StreamRequest&gt; <span class="title">biTalk</span><span class="params">(StreamObserver&lt;StreamResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StreamObserver&lt;StreamRequest&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(StreamRequest value)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;onNext: &quot;</span> + value.getRequestInfo());</span><br><span class="line">                responseObserver.onNext(StreamResponse.newBuilder().setResponseInfo(UUID.randomUUID().toString()).build());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(t.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                responseObserver.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jyc.grpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.grpc.Server;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ServerBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Server server;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        server = ServerBuilder.forPort(<span class="number">8899</span>).addService(<span class="keyword">new</span> StudentServiceImpl()).build().start();</span><br><span class="line">        System.out.println(<span class="string">&quot;server started!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// Use stderr here since the logger may have been reset by its JVM shutdown hook.</span></span><br><span class="line">            System.err.println(<span class="string">&quot;*** shutting down gRPC server since JVM is shutting down&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                GrpcServer.<span class="keyword">this</span>.stop();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace(System.err);</span><br><span class="line">            &#125;</span><br><span class="line">            System.err.println(<span class="string">&quot;*** server shut down&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">            server.shutdown().awaitTermination(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">            System.out.println(<span class="string">&quot;server stop!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要手动设置阻塞</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">blockUntilShutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        GrpcServer server = <span class="keyword">new</span> GrpcServer();</span><br><span class="line">        server.start();</span><br><span class="line">        <span class="comment">// 如果不设置，启动就会退出</span></span><br><span class="line">        server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jyc.grpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jyc.proto.*;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannel;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannelBuilder;</span><br><span class="line"><span class="keyword">import</span> io.grpc.stub.StreamObserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrpcClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8899</span>).usePlaintext().build();</span><br><span class="line">        StudentServiceGrpc.StudentServiceBlockingStub blockingStub = StudentServiceGrpc.newBlockingStub(managedChannel);</span><br><span class="line">        StudentServiceGrpc.StudentServiceStub stub = StudentServiceGrpc.newStub(managedChannel);</span><br><span class="line">        MyResponse myResponse = blockingStub.getRealNameByUsername(MyRequest.newBuilder().setUsername(<span class="string">&quot;zhangsan&quot;</span>).build());</span><br><span class="line">        System.out.println(myResponse.getRealname());</span><br><span class="line">        System.out.println(<span class="string">&quot;==========================&quot;</span>);</span><br><span class="line">        Iterator&lt;StudentResponse&gt; iter = blockingStub.getStudentsByAge(StudentRequest.newBuilder().setAge(<span class="number">20</span>).build());</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            StudentResponse studentResponse = iter.next();</span><br><span class="line">            System.out.println(studentResponse.getName() + <span class="string">&quot;,&quot;</span> + studentResponse.getAge() + <span class="string">&quot;,&quot;</span> + studentResponse.getCity());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        StreamObserver&lt;StudentResponseList&gt; studentResponseListStreamObserver = <span class="keyword">new</span> StreamObserver&lt;StudentResponseList&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(StudentResponseList value)</span> </span>&#123;</span><br><span class="line">                value.getStudentResponseList().forEach(studentResponse -&gt; &#123;</span><br><span class="line">                    System.out.println(studentResponse.getName());</span><br><span class="line">                    System.out.println(studentResponse.getAge());</span><br><span class="line">                    System.out.println(studentResponse.getCity());</span><br><span class="line">                    System.out.println(<span class="string">&quot;*******&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(t.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;completed()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 以流式的方式发送的请求都是异步的</span></span><br><span class="line">        StreamObserver&lt;StudentRequest&gt; studentRequestStreamObserver = stub.getStudentsWrapperByAges(studentResponseListStreamObserver);</span><br><span class="line">        studentRequestStreamObserver.onNext(StudentRequest.newBuilder().setAge(<span class="number">20</span>).build());</span><br><span class="line">        studentRequestStreamObserver.onNext(StudentRequest.newBuilder().setAge(<span class="number">30</span>).build());</span><br><span class="line">        studentRequestStreamObserver.onNext(StudentRequest.newBuilder().setAge(<span class="number">40</span>).build());</span><br><span class="line">        studentRequestStreamObserver.onNext(StudentRequest.newBuilder().setAge(<span class="number">50</span>).build());</span><br><span class="line">        studentRequestStreamObserver.onCompleted();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        StreamObserver&lt;StreamRequest&gt; requestStreamObserver = stub.biTalk(<span class="keyword">new</span> StreamObserver&lt;StreamResponse&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(StreamResponse value)</span> </span>&#123;</span><br><span class="line">                System.out.println(value.getResponseInfo());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(t.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;onCompleted!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            requestStreamObserver.onNext(StreamRequest.newBuilder().setRequestInfo(LocalDateTime.now().toString()).build());</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不休眠，会因为异步的原因而导致消息没有发送</span></span><br><span class="line">        Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="nio原理分析"><a class="markdownIt-Anchor" href="#nio原理分析"></a> NIO原理分析</h1>
<h2 id="io与nio"><a class="markdownIt-Anchor" href="#io与nio"></a> IO与NIO</h2>
<h3 id="io与nio的区别"><a class="markdownIt-Anchor" href="#io与nio的区别"></a> IO与NIO的区别</h3>
<p>java.io中最为核心的一个概念是流（Stream），面向流的编程。Java中，一个流要么是输入流，要么是输出流，不可能同时既是输入流又是输出流。</p>
<p>nio一种说法是new io，也可以认为是阻塞io，java.nio中拥有3个核心概念：Selector、Channel与Buffer。在java.nio中，我们是面向块（block）或是缓冲区（buffer）来编程的，nio的模型如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210922230347.png" alt="NIO示意图" style="zoom: 50%;" />
<p>nio的程序的简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个只能放置10个整数的缓冲区</span></span><br><span class="line">        IntBuffer buffer = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> randomNumber = <span class="keyword">new</span> SecureRandom().nextInt(<span class="number">20</span>);</span><br><span class="line">            buffer.put(randomNumber);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过这个方法可以实现读写的切换</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.println(buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="buffer"><a class="markdownIt-Anchor" href="#buffer"></a> Buffer</h3>
<p>Buffer本身就是一块内存，底层实现上，它实际上就是一个数组。数据的读、写都是通过Buffer来实现的。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210922230615.png" alt="Buffer示意图" style="zoom:50%;" />
<p>除了数组之外，Buffer还提供了对于数据的结构化访问方式，并且可以追踪到系统的读写过程。Java中的7种原生数据类型都有各自对应的Buffer类型，如IntBuffer、LongBuffer、ByteBuffer以及CharBuffer等。</p>
<p>关于NIO Buffer中的3个重要状态属性的含义：position、limit与capacity。</p>
<ul>
<li>capacity指的是它所包含的元素的个数，一个buffer的capacity永远不会是负数，也永远不会变化</li>
<li>limit指的是第一个不应该被读或写的元素的索引，limit也不会是负数，并且不会大于capacity</li>
<li>position指的是下一个将要读或写的元素的索引，position永远不会是负数，并且小于等于limit</li>
</ul>
<p>它们之间的大小关系如下所示：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>r</mi><mi>k</mi><mo>&lt;</mo><mo>=</mo><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>&lt;</mo><mo>=</mo><mi>l</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi><mo>&lt;</mo><mo>=</mo><mi>c</mi><mi>a</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></span></p>
<p>新创建的Buffer的position是0，mark是undefined，而limit的初始与Buffer的类型和创建方式有关。</p>
<p>Buffer中的核心API</p>
<ul>
<li>java.nio.Buffer#clear：将Buffer恢复成初始状态</li>
<li>java.nio.Buffer#flip：将limit设置成当前的position，将position设置成0</li>
<li>java.nio.Buffer#rewind：重新读取已经包含的数据，他会将position设置成0，limit保持不变</li>
</ul>
<div class="note info"><p>Buffer并不保证线程安全。</p></div>
<p>通过NIO读取文件涉及到三个步骤：</p>
<ul>
<li>从FileInpuStream获取到FileChannel对象</li>
<li>创建Buffer</li>
<li>将数据从Channel读取到Buffer中</li>
</ul>
<p>绝对方法与相对方法的含义：</p>
<ul>
<li>相对方法：limit的值与position的值会在操作的时候被考虑到</li>
<li>绝对方法：完全忽略掉limit与position的值</li>
</ul>
<p>除了支持常规的put的方法，ByteBuffer还提供了类型化的get与put方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ByteBuffer类型化的put与get方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">        buffer.putInt(<span class="number">15</span>);</span><br><span class="line">        buffer.putLong(<span class="number">500000L</span>);</span><br><span class="line">        buffer.putDouble(<span class="number">3.1415926</span>);</span><br><span class="line">        buffer.putChar(<span class="string">&#x27;你&#x27;</span>);</span><br><span class="line">        buffer.putShort((<span class="keyword">short</span>) <span class="number">2</span>);</span><br><span class="line">        buffer.putChar(<span class="string">&#x27;我&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        System.out.println(buffer.getInt());</span><br><span class="line">        System.out.println(buffer.getLong());</span><br><span class="line">        System.out.println(buffer.getDouble());</span><br><span class="line">        System.out.println(buffer.getChar());</span><br><span class="line">        System.out.println(buffer.getShort());</span><br><span class="line">        System.out.println(buffer.getChar());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Buffer中也提供了Slice方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            buffer.put((<span class="keyword">byte</span>) i);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.position(<span class="number">2</span>).limit(<span class="number">6</span>);</span><br><span class="line">        ByteBuffer slice = buffer.slice();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slice.capacity(); i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = slice.get(i);</span><br><span class="line">            b *= <span class="number">2</span>;</span><br><span class="line">            slice.put(i, b);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.position(<span class="number">0</span>);</span><br><span class="line">        buffer.limit(buffer.capacity());</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.println(buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新创建的Buffer和原来的Buffer共享相同的底层数组，这意味修改通过slice方法创建的Buffer也会修改原来的Buffer里面的值。</p>
<p>Buffer中也提供了只读Buffer的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            buffer.put((<span class="keyword">byte</span>) i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数据是和原来共享的，但是不允许修改</span></span><br><span class="line">        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();</span><br><span class="line">        System.out.println(readOnlyBuffer.getChar());</span><br><span class="line"></span><br><span class="line">        readOnlyBuffer.position(<span class="number">0</span>);</span><br><span class="line">        readOnlyBuffer.put((<span class="keyword">byte</span>) <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="channel"><a class="markdownIt-Anchor" href="#channel"></a> Channel</h3>
<p>Channel指的是向其写入数据或是从中读取数据的对象，它类似于java.io中的stream。</p>
<p>所有数据的读写都是通过Buffer来进行的，永远不会出现直接向Channel写入数据的情况，或是直接向Channel写入数据的情况，或是直接从Channel读取数据的情况。</p>
<p>与stream不同的是，channel是双向的，一个流只能是InputStream或是OutputStream，Channel打开则可以进行读取、写入或是读写。</p>
<p>由于Channel是双向的，因此它能更好地反映处底层操作系统的真实情况；在Linux系统中，底层操作系统的通道就是双向的。</p>
<h3 id="selector"><a class="markdownIt-Anchor" href="#selector"></a> Selector</h3>
<p>在NIO中，一个线程可以处理所有客户端的请求，相关示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ports = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        ports[<span class="number">0</span>] = <span class="number">5000</span>;</span><br><span class="line">        ports[<span class="number">1</span>] = <span class="number">5001</span>;</span><br><span class="line">        ports[<span class="number">2</span>] = <span class="number">5002</span>;</span><br><span class="line">        ports[<span class="number">3</span>] = <span class="number">5003</span>;</span><br><span class="line">        ports[<span class="number">4</span>] = <span class="number">5004</span>;</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        System.out.println(SelectorProvider.provider().getClass());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ports.length; i++) &#123;</span><br><span class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">            InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(ports[i]);</span><br><span class="line">            serverSocket.bind(address);</span><br><span class="line">            <span class="comment">// 当前状态下必须选择OP_ACCEPT类型</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(<span class="string">&quot;监听端口： &quot;</span> + ports[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> numbers = selector.select();</span><br><span class="line">            System.out.println(<span class="string">&quot;numbers: &quot;</span> + numbers);</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            System.out.println(<span class="string">&quot;selectedKeys: &quot;</span> + selectionKeys);</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                SelectionKey selectionKey = iter.next();</span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    iter.remove();</span><br><span class="line">                    System.out.println(<span class="string">&quot;获得客户端连接: &quot;</span> + socketChannel);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line">                        <span class="keyword">int</span> read = socketChannel.read(byteBuffer);</span><br><span class="line">                        <span class="keyword">if</span> (read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        socketChannel.write(byteBuffer);</span><br><span class="line">                        bytesRead += read;</span><br><span class="line">                        System.out.println(<span class="string">&quot;读取: &quot;</span> + bytesRead + <span class="string">&quot;,来自于: &quot;</span> + socketChannel);</span><br><span class="line">                        iter.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="nio网络编程"><a class="markdownIt-Anchor" href="#nio网络编程"></a> NIO网络编程</h3>
<p>服务端相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, SocketChannel&gt; clientMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8899</span>));</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 将serverSocketChannel注册到selector上面</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将开始阻塞，直到事件发生</span></span><br><span class="line">                selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                selectionKeys.forEach(selectionKey -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">final</span> SocketChannel client;</span><br><span class="line">                        <span class="comment">// 表示连接的事件</span></span><br><span class="line">                        <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                            ServerSocketChannel server = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                            client = server.accept();</span><br><span class="line">                            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            String key = <span class="string">&quot;[&quot;</span> + UUID.randomUUID().toString() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">                            clientMap.put(key, client);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                            client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                            ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                            <span class="keyword">int</span> count = client.read(readBuffer);</span><br><span class="line">                            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                readBuffer.flip();</span><br><span class="line">                                Charset charset = StandardCharsets.UTF_8;</span><br><span class="line">                                String receivedMessage = String.valueOf(charset.decode(readBuffer).array());</span><br><span class="line">                                System.out.println(client + <span class="string">&quot;: &quot;</span> + receivedMessage);</span><br><span class="line">                                String sendKey = <span class="keyword">null</span>;</span><br><span class="line">                                <span class="keyword">for</span> (Map.Entry&lt;String, SocketChannel&gt; entry : clientMap.entrySet()) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (client == entry.getValue()) &#123;</span><br><span class="line">                                        sendKey = entry.getKey();</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">for</span> (Map.Entry&lt;String, SocketChannel&gt; entry : clientMap.entrySet()) &#123;</span><br><span class="line">                                    SocketChannel value = entry.getValue();</span><br><span class="line">                                    ByteBuffer writeBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                                    writeBuffer.put((sendKey + <span class="string">&quot;: &quot;</span> + receivedMessage).getBytes());</span><br><span class="line">                                    writeBuffer.flip();</span><br><span class="line">                                    value.write(writeBuffer);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                selectionKeys.clear();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8899</span>));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; keySet = selector.selectedKeys();</span><br><span class="line">                <span class="keyword">for</span> (SelectionKey selectionKey : keySet) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isConnectable()) &#123;</span><br><span class="line">                        SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                        <span class="keyword">if</span> (client.isConnectionPending()) &#123;</span><br><span class="line">                            client.finishConnect();</span><br><span class="line">                            ByteBuffer writeBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                            writeBuffer.put((LocalDateTime.now() + <span class="string">&quot;连接成功&quot;</span>).getBytes());</span><br><span class="line">                            writeBuffer.flip();</span><br><span class="line">                            client.write(writeBuffer);</span><br><span class="line">                            ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">                            executorService.submit(() -&gt; &#123;</span><br><span class="line">                                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                                    <span class="keyword">try</span> &#123;</span><br><span class="line">                                        writeBuffer.clear();</span><br><span class="line">                                        InputStreamReader input = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">                                        BufferedReader br = <span class="keyword">new</span> BufferedReader(input);</span><br><span class="line">                                        String sendMessage = br.readLine();</span><br><span class="line">                                        writeBuffer.put(sendMessage.getBytes());</span><br><span class="line">                                        writeBuffer.flip();</span><br><span class="line">                                        client.write(writeBuffer);</span><br><span class="line">                                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                                        ex.printStackTrace();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                        SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                        ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="keyword">int</span> count = client.read(readBuffer);</span><br><span class="line">                        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            String receivedMessage = <span class="keyword">new</span> String(readBuffer.array(), <span class="number">0</span>, count);</span><br><span class="line">                            System.out.println(receivedMessage);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                keySet.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符编码集"><a class="markdownIt-Anchor" href="#字符编码集"></a> 字符编码集</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String inputFile = <span class="string">&quot;NioTest13_In.txt&quot;</span>;</span><br><span class="line">        String outputFile = <span class="string">&quot;NioTest13_Out.txt&quot;</span>;</span><br><span class="line">        RandomAccessFile inputRandomAccessFile = <span class="keyword">new</span> RandomAccessFile(inputFile, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        RandomAccessFile outputRandomAccessFile = <span class="keyword">new</span> RandomAccessFile(outputFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> inputLength = <span class="keyword">new</span> File(inputFile).length();</span><br><span class="line">        FileChannel inputFileChannel = inputRandomAccessFile.getChannel();</span><br><span class="line">        FileChannel outputFileChannel = outputRandomAccessFile.getChannel();</span><br><span class="line">        MappedByteBuffer inputData = inputFileChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, inputLength);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==================&quot;</span>);</span><br><span class="line">        Charset.availableCharsets().forEach((k,v) -&gt; &#123;</span><br><span class="line">            System.out.println(k + <span class="string">&quot;,&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Charset charset = StandardCharsets.UTF_8;</span><br><span class="line">        <span class="comment">// 解码</span></span><br><span class="line">        CharsetDecoder decoder = charset.newDecoder();</span><br><span class="line">        <span class="comment">// 编码</span></span><br><span class="line">        CharsetEncoder encoder = charset.newEncoder();</span><br><span class="line">        CharBuffer charBuffer = decoder.decode(inputData);</span><br><span class="line">        ByteBuffer outputData = encoder.encode(charBuffer);</span><br><span class="line">        outputFileChannel.write(outputData);</span><br><span class="line">        inputRandomAccessFile.close();</span><br><span class="line">        outputRandomAccessFile.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ASCII使用7bit来表示一个字符，共计可以表示128种字符，ISO-8859-1使用8bit表示一个字符，即一个字节来表示一个字符，它是完全兼容ASCII的。</p>
<p>GBK是对GB2312，使用两个字节表示一个汉字，GB18030可以表示的汉字的数量是最多的，对于繁体中文，台湾使用BIG5编码。</p>
<p>UNICODE可以表示全世界所有的字符，它统一采用了两个字节表示一个字符，但是会带来存储空间的浪费。</p>
<p>UTF（Unicode Translation Format），Unicode是一种编码方式，而utf则是一种存储方式：UTF-8是Unicode的实现方式之一。</p>
<p>UTF-16LE（little endian），UTF-BE（big endian），Zero Width No-Break Space，0XFEFF（BE），0XFFFE（LE），它们表示不同的BOM（Byte Order Mark）。</p>
<p>UTF-8，变长的表示形式，一般来说，UTF-8会通过1个字节表示一个英文字符，3个字节来表示一个中文，最多可能会使用6个字节来表示一个字符。</p>
<h2 id="零拷贝"><a class="markdownIt-Anchor" href="#零拷贝"></a> 零拷贝</h2>
<h3 id="传统的io流程"><a class="markdownIt-Anchor" href="#传统的io流程"></a> 传统的IO流程</h3>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211004213017.png" alt="image-20211004213017091" style="zoom:50%;" />
<h3 id="零拷贝实现原理"><a class="markdownIt-Anchor" href="#零拷贝实现原理"></a> 零拷贝实现原理</h3>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211004213138.png" alt="image-20211004213138652" style="zoom:50%;" />
<h1 id="netty原理分析"><a class="markdownIt-Anchor" href="#netty原理分析"></a> Netty原理分析</h1>
<h2 id="eventloopgroup"><a class="markdownIt-Anchor" href="#eventloopgroup"></a> EventLoopGroup</h2>
<p>EventLoopGroup底层就是一个死循环，然后不停的监听输入与输出的事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这样表示会启动一个线程来进行，如果没有在参数中指定，那么就会使用默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看系统属性io.netty.eventLoopThreads的值，如果没有就返回可用线程数*2，乘以2的原因是因为CPU的超频技术（如果CPU的核心数是4，那么这个方法返回的就是16）</span></span><br><span class="line">EFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(</span><br><span class="line">                <span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>接下来我们需要验证这一点，首先是NioEventLoopGroup的构造方法的调用：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211006155857.png" alt="image-20211006155857113" style="zoom:100%;" />
<p>一直找到最终调用的构造方法：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211006160311.png" alt="image-20211006160311773" /></p>
<p>在父类io.netty.channel.MultithreadEventLoopGroup的构造方法中我们可以看到：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211006160410.png" alt="image-20211006160410350" /></p>
<p>其中DEFAULT_EVENT_LOOP_THREADS：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211006160533.png" alt="image-20211006160533457" style="zoom:50%;" />
<p>还可以更近一步，再去寻找它的父类就会看到变量赋值的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">       checkPositive(nThreads, <span class="string">&quot;nThreads&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               children[i] = newChild(executor, args);</span><br><span class="line">               success = <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                       children[j].shutdownGracefully();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                       EventExecutor e = children[j];</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                               e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                           <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                           Thread.currentThread().interrupt();</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                   terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">           e.terminationFuture().addListener(terminationListener);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">       Collections.addAll(childrenSet, children);</span><br><span class="line">       readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>总而言之，通常我们仅需要一个线程来通过不断地循环监听事件的发生，因此通常我们都会指定线程的数量为1，需要注意的是，如果我们没有指定的话，程序会默认使用CPU超频之后的线程数乘以2。</p>
<h2 id="netty中的future对象"><a class="markdownIt-Anchor" href="#netty中的future对象"></a> Netty中的Future对象</h2>
<h3 id="channelfuture"><a class="markdownIt-Anchor" href="#channelfuture"></a> ChannelFuture</h3>
<p>netty当中的所有的I/O操作都是异步的，它使用了对于JDK的Future接口的扩展接口io.netty.util.concurrent.Future，更为具体的，在channel当中使用的是io.netty.channel.ChannelFuture。</p>
<p>传统JDK当中的Future接口，在功能上有些局限，例如，想要获取执行的接口，就需要调用get方法，而get方法本身是阻塞的，如果异步任务还没有执行完成，主程序就会陷入阻塞，而Netty当中的Futrue通过观察者模式的使用，巧妙地避免了这一点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Future&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt;... listeners)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt;... listeners)</span></span>;</span><br></pre></td></tr></table></figure>
<p>另外，在JDK中的Future接口中，对于任务执行完成的状态也没有进行细分，完成可能是成功执行，也可能抛出了异常，这一点，在Netty中也得到了增强：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211007111001.png" alt="Future状态" style="zoom: 67%;" />
<h3 id="异步读写架构"><a class="markdownIt-Anchor" href="#异步读写架构"></a> 异步读写架构</h3>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211017185947.png" alt="Future架构实现" style="zoom:67%;" />
<p>JDK所提供的Future只能通过手工的方式检查执行结果，而这个操作是会阻塞的，Netty则对ChannelFuture进行了增强，通过ChannelFutureListener以回调的方式来获取执行结果，去除了手工检查阻塞的操作，值得注意的是，io.netty.util.concurrent.GenericFutureListener#operationComplete方法是由I/O线程执行的，因此要注意的是不要在这里执行耗时的操作，否则需要通过另外的线程或线程池来执行。</p>
<h3 id="promise"><a class="markdownIt-Anchor" href="#promise"></a> Promise</h3>
<p>Promise本身继承了Future，在其基础之上增加了可写的功能（只能写一次），这其实也是一种编程模式，它们之间的关系：<a href="https://segmentfault.com/a/1190000023230662%E3%80%82">https://segmentfault.com/a/1190000023230662。</a></p>
<h2 id="serverbootstrap"><a class="markdownIt-Anchor" href="#serverbootstrap"></a> ServerBootStrap</h2>
<h3 id="核心方法"><a class="markdownIt-Anchor" href="#核心方法"></a> 核心方法</h3>
<p>ServerBootstrap中一些常用的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;childGroup set already&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">this</span>.childGroup = ObjectUtil.checkNotNull(childGroup, <span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(</span><br><span class="line">            ObjectUtil.checkNotNull(channelClass, <span class="string">&quot;channelClass&quot;</span>)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">childHandler</span><span class="params">(ChannelHandler childHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.childHandler = ObjectUtil.checkNotNull(childHandler, <span class="string">&quot;childHandler&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，它们只是完成了一些赋值操作，它们都是为了bind方法准备的，而bind方法实际执行的是doBind方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化和注册</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                    <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                    <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                    promise.registered();</span><br><span class="line"></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化和注册方法"><a class="markdownIt-Anchor" href="#初始化和注册方法"></a> 初始化和注册方法</h3>
<p>其中initAndRegister：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 作用类似于ThreadFatory，用于创建channel实例</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的初始化方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    setChannelOptions(channel, newOptionsArray(), logger);</span><br><span class="line">    setAttributes(channel, newAttributesArray());</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions = newOptionsArray(childOptions);</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = newAttributesArray(childAttrs);</span><br><span class="line">	<span class="comment">// 添加默认的初始化器</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            <span class="comment">// 添加处理器</span></span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 添加Acceptor</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="reactor模式"><a class="markdownIt-Anchor" href="#reactor模式"></a> Reactor模式</h2>
<p>在Netty使用了Reactor模式，Reactor模式也称为反应器模式（注意与响应式模式的区别），与Reactor模式不同的是Proactor模式。</p>
<p>Reactor是对于不同的IO事件使用它所恰当的handler来进行处理的一种编程模型，handlers会绑定到特定的事件上，然后执行一些非阻塞的动作。</p>
<h3 id="传统的模型"><a class="markdownIt-Anchor" href="#传统的模型"></a> 传统的模型</h3>
<p>经典的客户端与服务器处理模型：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211007195847.png" alt="经典模型" style="zoom:67%;" />
<p>其中每个handler都需要启动一个新的线程进行执行。</p>
<p>传统模型的优点：</p>
<ul>
<li>编程模型较为简单，适用于请求量不大的场景</li>
</ul>
<p>传统模型的缺点：</p>
<ul>
<li>服务端能够创建的线程是有限的，如果连接过多就会出现资源不够用的情况</li>
<li>当socket连接上之后，但没有数据传输的时候，线程必须持续等待，会造成资源的浪费</li>
</ul>
<h3 id="reactor模式-2"><a class="markdownIt-Anchor" href="#reactor模式-2"></a> Reactor模式</h3>
<p>Reactor模式的经典设计如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211010113404.png" alt="Reactor模式" style="zoom:67%;" />
<p>Reactor模式一共有5种角色构成，其含义分别如下：</p>
<ul>
<li>Handle（句柄或是描述符）：本质上表示一种资源，是由操作系统来提供的，该资源用于表示一个一个的事件，比如文件描述符，或是针对网络编程种的Socket描述符。事件既可以来自于外部，也可以来自于内部；外部事件比如说客户端的连接请求，客户端发送过来数据等；内部事件比如说操作系统产生的定时器事件等。它本质上就是一个文件描述符。Handle本身就是事件产生的发源地</li>
<li>Synchronous Event Demultiplexer（同步事件分离器）：它本身是一个系统调用，用于等待事件的发生（事件可能是一个，也可能是多个）。调用方在调用它的事件会被阻塞，直到同步事件分离器上有事件产生为止。对于Linux来说，同步事件分离器指的就是常用的I/O多路复用的机制，比如说select、poll、epoll等。同步事件分离器对应的组件就是Selector，对应的阻塞方法就是select方法</li>
<li>Event Handler（事件处理器）：本身由多个回调方法构成，这些回调方法构成了与应用相关的对于某个事件的反馈机制。在NIO当中需要自己实现，在Netty当中对应的就是各种内置的handler，为我们提供了大量的回调方法，供我们在特定事件产生时实现相应的回调方法进行业务逻辑的处理</li>
<li>Concrete Event Handler（具体事件处理器）：是事件处理器的实现。它本身实现了事件处理器所提供的各个回调方法，从而实现了特定于业务的逻辑，它本质上就是我们所编写的一个一个的处理器的实现</li>
<li>Initiation Dispatcher（初始分发器）：实际上就是Reactor角色。它本身定义了一些规范，这些规范用于控制事件的调度方式，同时又提供了应用进行事件处理器的注册、删除等设施。它本身是整个事件处理器的核心所在，Initiation Dispatcher会通过同步事件分离器来等待事件的发生，一旦事件发生，Initiation Dispatcher首先会分离出每一个事件，然后调用事件处理器，最后调用相关的回调方法来处理这些事件。</li>
</ul>
<p>Reactor模式的流程：</p>
<ul>
<li>当应用向Initiation Dispatcher注册具体的事件处理器时，应用会标识出该事件处理器希望Initiation Dispatcher在某个事件发生时向其通知的该事件，该事件与Handle关联</li>
<li>Initiation Dispatcher会要求每个事件处理器向其传递内部的Handle，该Handle向操作系统标识了事件处理器</li>
<li>当所有的事件处理器注册完毕后，应用会调用handle_event方法来启动Initiation Dispatcher的事件循环，这时，Initiation Dispatcher会将每个注册的事件管理器的handle合并起来，并使用同步事件分离器等待这些事件的发生，比如说，TCP协议层会使用select同步事件分离器操作来等待客户端发送的数据到达已经连接的socket handle上</li>
<li>当与某个事件源对应handle变为ready状态时（比如说TCP socket变为等待状态时），同步事件分离器就会通知Initiation Dispatcher</li>
<li>Initiation Dispatcher会触发事件处理器的回调方法，从而响应这个处于ready状态的handle，当事件发生时，Initiation Dispatcher会将被事件源激活的Handle作为【key】来寻找并分发恰当的事件处理器回调方法</li>
<li>Initiation Dispatcher会回调事件处理器的handle_events回调方法来执行特定于应用的功能（开发者自己所编写的功能），从而响应这个事件，所发生的事件类型可以作为该方法参数并被该方法内部使用执行额外的特定于服务的分离与分发</li>
</ul>
<h3 id="netty中的reactor线程模型"><a class="markdownIt-Anchor" href="#netty中的reactor线程模型"></a> Netty中的Reactor线程模型</h3>
<p>在Netty中，单线程的Reactor的整体设计如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211007201641.png" alt="单线程Reactor模型" style="zoom: 67%;" />
<div class="note info"><p>在netty中，EventLoop就是这里的Reactor。</p></div>
<p>使用线程池的版本：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211007203522.png" alt="线程池Reactor模型" style="zoom: 50%;" />
<p>使用多个Reactor的模型：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211007210842.png" alt="image-20211007210842204" style="zoom:67%;" />
<h2 id="自适应缓冲区"><a class="markdownIt-Anchor" href="#自适应缓冲区"></a> 自适应缓冲区</h2>
<p>在Netty中，分配的ByteBuffer大小并不是每个固定的，Netty会根据用户的行为，对分配缓冲区的大小进行一定程度的预测。</p>
<p>核心API - io.netty.channel.AdaptiveRecvByteBufAllocator</p>
<ul>
<li>io.netty.channel.AdaptiveRecvByteBufAllocator#SIZE_TABLE</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下一次分配的缓冲区的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] SIZE_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; sizeTable = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">16</span>; i &lt; <span class="number">512</span>; i += <span class="number">16</span>) &#123;</span><br><span class="line">           sizeTable.add(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Suppress a warning since i becomes negative when an integer overflow happens</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">512</span>; i &gt; <span class="number">0</span>; i &lt;&lt;= <span class="number">1</span>) &#123; <span class="comment">// lgtm[java/constant-comparison]</span></span><br><span class="line">           sizeTable.add(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       SIZE_TABLE = <span class="keyword">new</span> <span class="keyword">int</span>[sizeTable.size()];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE_TABLE.length; i ++) &#123;</span><br><span class="line">           SIZE_TABLE[i] = sizeTable.get(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>分配内存的方法：io.netty.buffer.AbstractByteBufAllocator#ioBuffer(int)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ioBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前是否包含sun.misc.Unsafe类</span></span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe() || isDirectBufferPooled()) &#123;</span><br><span class="line">        <span class="comment">// 直接内存</span></span><br><span class="line">        <span class="keyword">return</span> directBuffer(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 堆内存</span></span><br><span class="line">    <span class="keyword">return</span> heapBuffer(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="channel实现原理"><a class="markdownIt-Anchor" href="#channel实现原理"></a> Channel实现原理</h2>
<h3 id="channel的四大组件"><a class="markdownIt-Anchor" href="#channel的四大组件"></a> Channel的四大组件</h3>
<h3 id="channel与channelpipeline"><a class="markdownIt-Anchor" href="#channel与channelpipeline"></a> Channel与ChannelPipeline</h3>
<p>Channel可以作为网络套接字的连接点，也可以认为是一个提供了I/O操作（读、写、连接和绑定的）的组件，它提供了如下功能：</p>
<ul>
<li>当前channel的状态（是否已打开连接，是否已成功连接）</li>
<li>提供外部化配置功能（可以配置缓冲区的大小）</li>
<li>提供了I/O操作（读、写、连接、绑定）</li>
<li>ChannelPipeline可以处理所有的I/O事件以及与Channel所关联的请求</li>
</ul>
<p>Channel本身也可以具有层次性，根据Channel创建方式的不同，常见的Channel的类型：</p>
<ul>
<li>io.netty.channel.socket.SocketChannel</li>
<li>io.netty.channel.socket.ServerSocketChannel</li>
</ul>
<p>在创建Channel的时候，就会在Channel的构造方法中创建与之关联的ChannelPipline：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// AbstractChannelHandlerContext</span></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// AbstractChannelHandlerContext</span></span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 将前后连接在一起</span></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在ChannelPipeline中也维护了一个Channel对象，也就是说，在Channel中可以访问其对应的ChannelPipeline，在ChannelPipeline也可以访问到Channel。</p>
<p>ChannelPipeline是ChannelHander的列表，它用于处理Channel中入栈的事件以及出栈的操作，ChannelPipeline实际上实现了拦截过滤器模式，这里与传统的拦截器/过滤器不同的，对于请求和响应，它可以只处理其中的一个，如果只是入栈过滤器，那么只处理请求，如果只是出栈的处理器，那么只处理响应。</p>
<p>每一个Channel都会有自己的ChannelPipeline，ChannelPipeline的工作流程如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">                           I/O Request via Channel or ChannelHandlerContext</span></span><br><span class="line"><span class="code">                                                    |</span></span><br><span class="line"><span class="code">+---------------------------------------------------+---------------+</span></span><br><span class="line"><span class="code">|                           ChannelPipeline         |               |</span></span><br><span class="line"><span class="code">|                                                  \|/              |</span></span><br><span class="line"><span class="code">|    +---------------------+            +-----------+----------+    |</span></span><br><span class="line"><span class="code">|    | Inbound Handler  N  |            | Outbound Handler  1  |    |</span></span><br><span class="line"><span class="code">|    +----------+----------+            +-----------+----------+    |</span></span><br><span class="line"><span class="code">|              /|\                                  |               |</span></span><br><span class="line"><span class="code">|               |                                  \|/              |</span></span><br><span class="line"><span class="code">|    +----------+----------+            +-----------+----------+    |</span></span><br><span class="line"><span class="code">|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |</span></span><br><span class="line"><span class="code">|    +----------+----------+            +-----------+----------+    |</span></span><br><span class="line"><span class="code">|              /|\                                  .               |</span></span><br><span class="line"><span class="code">|               .                                   .               |</span></span><br><span class="line"><span class="code">| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span></span><br><span class="line"><span class="code">|        [ method call]                       [method call]         |</span></span><br><span class="line"><span class="code">|               .                                   .               |</span></span><br><span class="line"><span class="code">|               .                                  \|/              |</span></span><br><span class="line"><span class="code">|    +----------+----------+            +-----------+----------+    |</span></span><br><span class="line"><span class="code">|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |</span></span><br><span class="line"><span class="code">|    +----------+----------+            +-----------+----------+    |</span></span><br><span class="line"><span class="code">|              /|\                                  |               |</span></span><br><span class="line"><span class="code">|               |                                  \|/              |</span></span><br><span class="line"><span class="code">|    +----------+----------+            +-----------+----------+    |</span></span><br><span class="line"><span class="code">|    | Inbound Handler  1  |            | Outbound Handler  M  |    |</span></span><br><span class="line"><span class="code">|    +----------+----------+            +-----------+----------+    |</span></span><br><span class="line"><span class="code">|              /|\                                  |               |</span></span><br><span class="line"><span class="code">+---------------+-----------------------------------+---------------+</span></span><br><span class="line"><span class="code">                |                                  \|/</span></span><br><span class="line"><span class="code">+---------------+-----------------------------------+---------------+</span></span><br><span class="line"><span class="code">|               |                                   |               |</span></span><br><span class="line"><span class="code">|       [ Socket.read() ]                    [ Socket.write() ]     |</span></span><br><span class="line"><span class="code">|                                                                   |</span></span><br><span class="line"><span class="code">|  Netty Internal I/O Threads (Transport Implementation)            |</span></span><br><span class="line"><span class="code">+-------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<p>通常情况下，一个事件的传播是如下进行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Connected!&quot;</span>);</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOutboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Closing ..&quot;</span>);</span><br><span class="line">        ctx.close(promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前的示例中，我们都是直接在handler中编写业务的相关逻辑，然后这仅仅适用于我们的处理不耗时的情况，如果要防止程序阻塞，那么就需要使用ChannelPipeline中另一个重载的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EventExecutorGroup</span></span><br><span class="line">pipeline.addLast(group, <span class="string">&quot;handler&quot;</span>, <span class="keyword">new</span> MyBusinessLogicHandler());</span><br></pre></td></tr></table></figure>
<p>当然也可以在我们自己的处理器中使用线程池相关的技术来实现异步执行。</p>
<h3 id="channeloption与attributekey"><a class="markdownIt-Anchor" href="#channeloption与attributekey"></a> ChannelOption与AttributeKey</h3>
<p>ChannelOption可以让我们以类型安全的方式配置ChannelConfig。它主要通过ConstantPool来维护常量池。ChannelOption主要维护TCP等与协议相关的常量，而AttributeKey主要维护与业务相关的常量。</p>
<h3 id="channelhandler与channelhandlercontext"><a class="markdownIt-Anchor" href="#channelhandler与channelhandlercontext"></a> ChannelHandler与ChannelHandlerContext</h3>
<p>ChannelHandlerContext是ChannelHandler与ChannelPipeline之间交互的桥梁和纽带。</p>
<p>io.netty.channel.ChannelPipeline#addLast(io.netty.channel.ChannelHandler…)方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line">        addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the registered is false it means that the channel was not registered on an eventLoop yet.</span></span><br><span class="line">        <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">        <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">            callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChannelHandler既可以通知下一个ChannelHandler，也可以修改它所属的ChannelPipline对象，可以通过ChannelPipline中提供若干方法获取最近的ChannelHandler。</p>
<p>我们可以提前将ChannelHandlerContext保存起来，然后在需要的时候调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> ChannelHandlerContext ctx;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdd</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username, password)</span> </span>&#123;</span><br><span class="line">        ctx.write(<span class="keyword">new</span> LoginMessage(username, password));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个ChannelHandler可以拥有多个ChannelHandlerContext，一个ChannelHandler也可以被多次添加到一个ChannelPipline中。</p>
<p>在Netty4.1以后的版本中，ChannelHandlerContext#attr与Channel#attr方法的作用域是相同的：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211017141629.png" alt="attr方法"  />
<h3 id="channel选择器"><a class="markdownIt-Anchor" href="#channel选择器"></a> Channel选择器</h3>
<p>核心API - io.netty.util.concurrent.EventExecutorChooserFactory.EventExecutorChooser</p>
<p>EventExecutorChooserFactory使用round-robin来选择下一个EventExecutor，Netty会根据EventExecutor中数组的长度来选择不同的事件执行器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PowerOfTwoEventExecutorChooser(executors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericEventExecutorChooser(executors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中两个选择器的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerOfTwoEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">        PowerOfTwoEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executors = executors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 直接返回索引，如果是2的倍数，与的操作性能会更高</span></span><br><span class="line">            <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong idx = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">        GenericEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executors = executors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 取模</span></span><br><span class="line">            <span class="keyword">return</span> executors[(<span class="keyword">int</span>) Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="channel注册流程"><a class="markdownIt-Anchor" href="#channel注册流程"></a> Channel注册流程</h3>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211017144056.png" alt="注册方法" style="zoom:67%;" />
<p>首先来看config方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ServerBootstrapConfig <span class="title">config</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>group方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> EventLoopGroup <span class="title">group</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bootstrap.group();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>register方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看调用栈即可找到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(eventLoop, <span class="string">&quot;eventLoop&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;registered to an event loop already&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(</span><br><span class="line">                <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">    <span class="comment">// 这个判断的原因是防止产生并发问题，如果判断为假，会将任务提交给eventLoop中的Thread去执行</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                    <span class="string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,</span><br><span class="line">                    AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Netty当中几个重要的原则：</p>
<ul>
<li>一个EventLoopGroup当中会包含一个或多个EventLoop</li>
<li>一个EventLoop在它的整个生命周期中只会与唯一一个Thread进行绑定</li>
<li>所有由EventLoop所处理的各种I/O事件都将在它所关联的那个Thread上进行处理</li>
<li>一个Channel在它的整个生命周期中只会注册在一个EventLoop上</li>
<li>一个EventLoop在运行过程当中，会被分配给一个或者多个Channel</li>
</ul>
<p>真正的注册的方法实际上在io.netty.channel.nio.AbstractNioChannel#doRegister：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 真正的注册实际上就是对于Nio的处理（javaChannel就是SelectableChannel）</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                <span class="comment">// Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</span></span><br><span class="line">                <span class="comment">// cached and not removed because no Select.select(..) operation was called yet.</span></span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span></span><br><span class="line">                <span class="comment">// for whatever reason. JDK bug ?</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="netty中的设计原则"><a class="markdownIt-Anchor" href="#netty中的设计原则"></a> Netty中的设计原则</h2>
<h3 id="设计原则"><a class="markdownIt-Anchor" href="#设计原则"></a> 设计原则</h3>
<p>在Netty中，Channel的实现一定是线程安全的，基于此，我们可以存储一个Channel引用，并且在需要向远程端点发送数据时，通过这个引用来调用Channel相应的方法，即便当时有很多线程都在使用它也不会出现多线程问题，而且消息一定会按照顺序发送出去。</p>
<h3 id="业务线程池"><a class="markdownIt-Anchor" href="#业务线程池"></a> 业务线程池</h3>
<p>在业务开发中，不要将长时间执行的耗时任务放入到EventLoop的执行队列中，因为它将会一直阻塞该线程所对应的所有Channel上的其他执行任务，如果我们需要进行阻塞调用或是耗时的操作（实际开发中很常见），那么我们就需要使用一个专门的EventExecutor（业务线程池）。</p>
<p>业务线程池通过会有两种实现的方式：</p>
<ul>
<li>在ChannelHandler的回调方法中，使用自己定义的业务线程池，这样就可以实现异步的调用</li>
<li>借助Netty提供的向ChannelPipline添加Channel时调用的addLast方法来传递EventExecutor</li>
</ul>
<div class="note info"><p>默认情况下（调用addLast（handler），ChannelHandler中的回调方法都是由I/O线程所执行，如果调用了ChannelPipline#addLast（EventExectorGroup group，Channel...handlers）方法，那么ChannelHandler中的回调方法就是由参数中的group线程组来执行。</p></div>
<h2 id="bytebuf实现原理"><a class="markdownIt-Anchor" href="#bytebuf实现原理"></a> ByteBuf实现原理</h2>
<p>ByteBuffer的compact方法：</p>
<ul>
<li>将所有维度的数据复制到buffer的起始位置处</li>
<li>将position设为最后一个未读的元素的后面</li>
<li>将limit设置为capacity</li>
<li>现在buffer就准备好了，但是不会覆盖未读的数据</li>
</ul>
<h3 id="bytebuf使用示例"><a class="markdownIt-Anchor" href="#bytebuf使用示例"></a> ByteBuf使用示例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufTest0</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            byteBuf.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; byteBuf.capacity(); i++) &#123;</span><br><span class="line">            System.out.println(byteBuf.getByte(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心API的使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;吉hello world&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="comment">// 如果这个判断成立，说明创建的ByteBuf就是堆上的缓冲</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuf.hasArray()) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] content = byteBuf.array();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(content, StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">            System.out.println(byteBuf);</span><br><span class="line">            <span class="comment">// 第一个字节的偏移量，通常情况下为0</span></span><br><span class="line">            System.out.println(byteBuf.arrayOffset());</span><br><span class="line">            System.out.println(byteBuf.readerIndex());</span><br><span class="line">            System.out.println(byteBuf.writerIndex());</span><br><span class="line">            System.out.println(byteBuf.capacity());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> length = byteBuf.readableBytes();</span><br><span class="line">            System.out.println(length);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; byteBuf.readableBytes(); i++) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>) byteBuf.getByte(i));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(byteBuf.getCharSequence(<span class="number">0</span>, <span class="number">4</span>, StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bytebuf数据结构"><a class="markdownIt-Anchor" href="#bytebuf数据结构"></a> ByteBuf数据结构</h3>
<p>ByteBuf提供了两个指针变量来进行数据的读写，分别是readerIndex（读操作）和writerIndex（写操作），这两个指针将整个ByteBuf分为了三个部分：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211018235157.png" alt="ByteBuf" style="zoom:80%;" />
<p>核心API：</p>
<ul>
<li>io.netty.buffer.ByteBuf#discardReadBytes</li>
<li>io.netty.buffer.ByteBuf#clear</li>
</ul>
<p>使用Derived buffers生成的新的ByteBuf是一种浅拷贝，它们的readerIndex和writerIndex是独立，但是底层的数据是同一份，如果需要深拷贝，可以使用io.netty.buffer.ByteBuf#copy()。</p>
<p>ByteBuf可以和ByteBuffer互相进行转换，与JDK中的ByteBuffer不同的是，ByteBuf除了有Heap缓冲区和直接内存缓冲区，还有复合缓冲区。</p>
<div class="note info"><p>通过索引来访问Byte时并不会改变真实的读索引与写索引，我们可以通过ByteBuf的readerIndex()与writerIndex()方法分别直接修改读索引与写索引。</p></div>
<p>ByteBuf的底层实现：UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(ridx: 0, widx: 11, cap: 64)。</p>
<h3 id="复合缓冲区"><a class="markdownIt-Anchor" href="#复合缓冲区"></a> 复合缓冲区</h3>
<p>Netty ByteBuf所提供的3中缓冲区类型：</p>
<ul>
<li>heap buffer</li>
<li>direct buffer</li>
<li>composite buffer</li>
</ul>
<p>不同缓冲区之间的区别如下表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Heap Buffer（堆缓冲区）</td>
<td>这是最常用的类型，ByteBuf将数据存储到JVM的堆空间中，并且将实际的数据存放到byte array中来实现的</td>
<td>由于数据是存储在JVM堆中的，因此可以快速的创建于快速的释放，并且提供了直接访问内部字节数组的方法</td>
<td>每次读写数据时，都需要先将数据复制到直接缓冲区中再进行网络传输</td>
</tr>
<tr>
<td>Direct Buffer（直接缓冲区）</td>
<td>在堆之外直接分配的内存空间，直接缓冲区并不会占用堆的容量空间，因为它是由操作系统在本地内存进行的数据分配</td>
<td>在使用Socket进行数据传输时，性能非常好，因为数据直接位于操作系统的本地内存中，所以不需要从JVM将数据复制到直接缓冲区，性能很好</td>
<td>由于Direct Buffer是直接在操作系统内存中的，所以内存空间的分配与释放要比堆空间更加复杂，而且速度要慢一些</td>
</tr>
<tr>
<td>Composite buffer（复合缓冲区）</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<div class="note info"><p>直接缓冲区并不支持通过字节数组的方式来访问数据。对于后端的业务消息的编解码来说，推荐使用HeapByteBuf；对于I/O通信线程在读写缓冲区时，推荐使用DirectByteBuf。</p></div>
<p>JDK的ByteBuffer与Netty的ByteBuf之间的差异对比：</p>
<ul>
<li>Netty的ByteBuf采用了读写索引分离的策略（readerIndex和writerIndex），一个初始化（里面尚未有任何数据）的ByteBuf的readerIndex和writerIndex值都为0</li>
<li>当读索引与写索引处于同一个位置时，如果我们继续读取，那么就会抛出IndexOutOfBoundsException</li>
<li>对于ByteBuf的任何读写操作都会分别单独维护读索引和写索引。maxCapacity最大容量默认的限制就是Integer.MAX_VALUE。</li>
</ul>
<p>JDK的ByteBuffer的缺点：</p>
<ul>
<li><code>final byte[] bb;</code>这是JDK的ByteBuffer对象中用于存储数据的对象声明；可以看到，其字节数组是被声明为final的，也就是长度是固定不变的。一旦分配好不能动态扩容与收缩；而且当待存储的数据字节很大时就很有可能出现IndexOutOfBoundsException，如果要预防这个异常，那就需要存储之前确定好待存储的字节大小。如果ByteBuffer的空间不足，我们只有一种解决方案：创建一个全新的ByteBuffer对象，然后再将之前的ByteBuffer中的数据复制过去，这一切操作都需要由开发者自己来手动完成</li>
<li>ByteBuffer只使用一个position指针来标识位置信息，在进行读写切换时就需要调用flip方法就是rewind方法，使用起来很不方便</li>
</ul>
<p>Netty的ByteBuf的优点：</p>
<ul>
<li>存储字节的数组时动态的，其最大值默认是Integer.Max_VALUE。这里的动态性是体现在write方法中的，write方法在执行时会判断buffer容量，如果不足则自动扩容</li>
<li>ByteBuf的读写索引是完全分开的，使用起来相对方便</li>
</ul>
<h2 id="引用计数"><a class="markdownIt-Anchor" href="#引用计数"></a> 引用计数</h2>
<h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3>
<p>Netty为了性能的考虑，并没有直接使用JVM的GC技术，而是借助于引用计数来实现池化的管理。每一个新创建的对象的引用计数对象的数量就是1，对于池化的ByteBuf，使用完成之后，就会被放回到对象池中，对于非池化的ByteBuf在使用完成之后，就会被GC回收。</p>
<p>核心API - io.netty.util.ReferenceCounted</p>
<p>核心方法：</p>
<ul>
<li>io.netty.util.ReferenceCounted#retain</li>
<li>io.netty.util.ReferenceCounted#release</li>
</ul>
<p>如果觉得管理引用比较麻烦，可以使用工具类方法：</p>
<ul>
<li>io.netty.util.ReferenceCountUtil#retain</li>
<li>io.netty.util.ReferenceCountUtil#release</li>
</ul>
<p>引用计数的自旋锁的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(T obj, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get(obj);</span><br><span class="line">        next = prev + delta;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原子更新的底层实现：java.util.concurrent.atomic.AtomicIntegerFieldUpdater</p>
<h3 id="atomicintegerfieldupdater"><a class="markdownIt-Anchor" href="#atomicintegerfieldupdater"></a> AtomicIntegerFieldUpdater</h3>
<p>非原子性的更新int类型的字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicUpdaterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(person.age++);</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Task :AtomicUpdaterTest.main()</span></span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">2</span><br><span class="line">7</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p>可以看到更新并不是原子性的，接下来使用AtomicIntegerFieldUpdater：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicUpdaterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        AtomicIntegerFieldUpdater&lt;Person&gt; atomicIntegerFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Person.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(atomicIntegerFieldUpdater.getAndIncrement(person));</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意必须是volatile类型的</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AtomicIntegerFieldUpdater要点：</p>
<ul>
<li>更新器更新的必须是int类型的变量，不能是其包装类型</li>
<li>更新器所更新的必须是volatile类型变量，确保线程之间共享变量时立即可见性</li>
<li>变量不能是static的，必须是要是实例变量，因为Unsafe.objectFieldOffset()方法不支持静态变量（CAS操作本质上是通过对象实例的偏移量来直接进行赋值）</li>
<li>更新器只能修改它可见范围内的变量，因为更新器是通过反射来得到这个变量，如果变量不可见就会报错</li>
</ul>
<p>如果要更新的变量是包装类型，那么可以使用AtomicReferenceFieldUpdater来进行原子更新的操作。</p>
<p>Netty中并没有使用AtomicInteger的原因是，在Netty中会创建大量的ByteBuf，每一个ByteBuf都需要创建一个AtomicInteger对象，但是使用AtomicReferenceFieldUpdater仅需要创建一个实例，就可以对所有的ByteBuf进行原子更新，处于性能的考虑，就没有使用AtomicInteger了。</p>
<h2 id="netty中的处理器"><a class="markdownIt-Anchor" href="#netty中的处理器"></a> Netty中的处理器</h2>
<p>Netty中的处理器可以分为两类：入站处理器与出站处理器，入站处理器的顶层是ChannelInboundHandler，出战处理器的顶层是ChannelOutboundHandler。数据处理时常用的各种编解码器本质上都是处理器。</p>
<p>无论我们向网络中写入的数据是什么类型（int、char、String、二进制等），数据在网络中传递时，其都是以字节流的形式呈现的；将数据由原本的形式转换为字节流的操作称为编码（encode），将数据由字节转换为它原本的格式或是其他格式的操作称为解码（decode）。编解码统一称为codec。</p>
<p>对于编码来说本质上是一种出站处理器，因此，编码一定是ChannelOutboundHandler；对于解码本质上是一种入站处理器，因此，解码一定是一种ChannelInboundHandler。</p>
<div class="note info"><p>在Netty中，编码器通常以×××Encoder命名；解码器通常以×××Decoder命名。</p></div>
<p>无论是编码器还是解码器，其所接收的消息类型必须要与待处理的参数类型一致，否则该编码器或解码器并不会被执行。在解码器进行数据解码时，一定记得判断缓冲（ByteBuf）中的数据是否足够使用。</p>
<h3 id="自定义编解码器"><a class="markdownIt-Anchor" href="#自定义编解码器"></a> 自定义编解码器</h3>
<p>核心API - io.netty.handler.codec.ByteToMessageDecoder</p>
<p>自定义解码器的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义解码器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;decode invoked!&quot;</span>);</span><br><span class="line">        System.out.println(byteBuf.readableBytes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            list.add(byteBuf.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自定义编码器的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义编码器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Long msg, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;encode invoked!&quot;</span>);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        byteBuf.writeLong(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="replayingdecoder"><a class="markdownIt-Anchor" href="#replayingdecoder"></a> ReplayingDecoder</h3>
<p>ReplayingDecoder和ByteToMessageDecoder最主要的区别在于使用ReplayingDecoder的decode或者decodeLast方法的时候就好像所有的字节都已经被接收到了一样，而不必检查字节是否存在或者缺少，这在自定义协议的场景下非常的有用。</p>
<p>使用ReplayingDecoder也可以完成上面例子的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder2</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyByteToLongDecoder2 decode invoked&quot;</span>);</span><br><span class="line">        list.add(byteBuf.readLong());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lengthfieldbasedframedecoder"><a class="markdownIt-Anchor" href="#lengthfieldbasedframedecoder"></a> LengthFieldBasedFrameDecoder</h3>
<p>这个解码器会根据接收到的消息的长度，对ByteBuf动态的进行分割，如果要解码一个由header和body两部分组成的二进制的消息的时候，会非常有用，通常在自定义协议的时候，就可以使用这个类。</p>
<h3 id="常见编解码器总结"><a class="markdownIt-Anchor" href="#常见编解码器总结"></a> 常见编解码器总结</h3>
<ul>
<li>io.netty.handler.codec.MessageToMessageDecoder</li>
<li>io.netty.handler.codec.MessageToMessageEncoder</li>
<li>io.netty.handler.codec.MessageToMessageDncoder（编解码器）</li>
<li>io.netty.handler.codec.MessageToMessageEncoder（编解码器）</li>
<li>io.netty.channel.CombinedChannelDuplexHandler（组合的编解码器）</li>
<li>io.netty.handler.codec.LineBasedFrameDecoder</li>
<li>io.netty.handler.codec.FixedLengthFrameDecoder</li>
<li>io.netty.handler.codec.DelimiterBasedFrameDecoder</li>
<li>io.netty.handler.codec.LengthFieldBasedFrameDecoder</li>
</ul>
<h2 id="tcp粘包与拆包"><a class="markdownIt-Anchor" href="#tcp粘包与拆包"></a> TCP粘包与拆包</h2>
<h3 id="粘包与拆包"><a class="markdownIt-Anchor" href="#粘包与拆包"></a> 粘包与拆包</h3>
<p>TCP是面向连接的，面向字节流的，提供可靠交互。发送端为了提高发送效率，使用了Nagle算法，将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难以分辨出完整的数据包了，因为面向流的通信是无消息保护边界的。</p>
<p>TCP的粘包是指，将多个小的包封装成一个大的数据包发送，发送方发送的若干数据包到接收方时粘成了一个包。</p>
<p>TCP的拆包是指，将一个完整的包拆分成为多个小包进行发送，发送方发送一个数据包到接收方时被拆分为若干个小包。</p>
<h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h3>
<p>Netty会不断的从TCP缓冲区中读取数据，每次读取完都需要判断是否是一个完整的数据包：</p>
<ul>
<li>如果当前读取的数据不足以拼接成一个完整的业务数据包，那就保留该数据，继续从tcp缓冲区中读取，直到得到一个完整的数据包</li>
<li>如果当前读到的数据加上已经读取的数据足够拼接成一个数据包，那就将已经读取的数据拼接上本次读取的数据，构成一个完整的业务数据包传递到业务逻辑，多余的数据仍然保留，以便和下次读到的数据尝试拼接</li>
</ul>
<p>判断是一个完整的数据包的依据：</p>
<ul>
<li>设置定长消息（对应Netty提供的FixedLengthFrameDecoder解码器）</li>
<li>设置消息边界（分隔符，对应Netty提供的DelimiterBasedFrameDecoder解码器）</li>
<li>使用带消息头的协议，消息头存储消息开始标识及消息的长度信息Header+Body（使用Netty提供的LengthFieldBasedFrameDecoder）</li>
<li>发送消息长度，自定义消息编解码器</li>
</ul>
<h1 id="netty中的设计模式"><a class="markdownIt-Anchor" href="#netty中的设计模式"></a> Netty中的设计模式</h1>
<h2 id="观察者模式"><a class="markdownIt-Anchor" href="#观察者模式"></a> 观察者模式</h2>
<p>核心API：io.netty.util.concurrent.Future</p>
<p>实现原理：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211017190514.png" alt="观察者模式" style="zoom:100%;" />
<h2 id="适配器模式"><a class="markdownIt-Anchor" href="#适配器模式"></a> 适配器模式</h2>
<p>核心API - io.netty.channel.ChannelInboundHandlerAdapter</p>
<p>提供的实现类将我们所需要实现的接口中的方法全都实现出来，那么在实现具体的类的时候，就无须重写接口中的所有的方法。</p>
<p>常用的实现：</p>
<ul>
<li>io.netty.channel.SimpleChannelInboundHandler</li>
</ul>
<p>SimpleChannelInboundHandler会在消息消费完成之后自动的调用<code>ReferenceCountUtil.release(msg)</code>方法。</p>
<h2 id="模板方法模式"><a class="markdownIt-Anchor" href="#模板方法模式"></a> 模板方法模式</h2>
<p>核心API - io.netty.channel.SimpleChannelInboundHandler</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211017224849.png" alt="模板方法设计模式" style="zoom:100%;" />
<hr />
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>[1] <a href="https://developers.google.com/protocol-buffers/docs/javatutorial">protobuf官方文档</a></p>
<p>[2] <a href="https://thrift.apache.org/">thrift官网</a></p>
<p>[3] <a href="https://grpc.io/docs/languages/java/basics/">grpc官网</a></p>
<p>[4] <a href="https://www.cnblogs.com/binarylei/p/10053084.html">Netty零拷贝</a></p>
<p>[5] <a href="https://colobu.com/2015/08/18/netty-new-and-noteworthy-in-4-1/">Netty 4.1中的新变化和注意点</a></p>
<p>[6] <a href="https://www.zhihu.com/question/57374068">Java NIO中，关于DirectBuffer，HeapBuffer的疑问</a></p>
<p>[7] <a href="https://juejin.cn/post/6844904121309331469#heading-7">Netty编解码&amp;粘包拆包&amp;零拷贝</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL原理分析</title>
    <url>/2021/08/30/MySQL/</url>
    <content><![CDATA[<p>或许你正在使用MySQL，知道如何写出逻辑正确的SQL语句来实现业务目标，却不确定这个语句是不是最优的；或者你听说了一些使用数据库的最佳实践，但是更想了解为什么这么做；或许你使用的数据库偶尔会出问题，亟需了解如何更快速、更准确地定位问题，甚至自己解决问题。希望本文能够激发你对数据库原理的探索欲，对MySQL做到知其所以，知其所以然。</p>
<span id="more"></span>
<h1 id="mysql基础"><a class="markdownIt-Anchor" href="#mysql基础"></a> MySQL基础</h1>
<h2 id="mysql逻辑架构"><a class="markdownIt-Anchor" href="#mysql逻辑架构"></a> MySQL逻辑架构</h2>
<p>让我们从最简单的情形开始，假设有一张这样的表T，表里只有一个ID字段，在执行下面这个查询语句时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程，要想更深入的了解，就需要了解MySQL的逻辑架构：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211128225619.png" alt="MySQL存储引擎架构图" style="zoom: 67%;" />
<p>大体来说，MySQL可以分为Server层和存储引擎两部分。</p>
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>而存储引擎层负责数据的存储和提取，其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎，现在最常用的存储引擎是InnoDB，它从MySQL5.5.5版本开始称为了默认的存储引擎。</p>
<p>这也就是说，在执行<code>create table</code>建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不过，在使用<code>create table</code>语句中使用<code>engine=memory</code>来指定存储引擎的类型来创建表，不同的存储引擎的表数据获取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。</p>
<p>从图中不难看出，不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分。接下来我们会从上文提到的SQL语句，梳理它执行的完整的流程，了解每个组件的作用。</p>
<h3 id="连接器"><a class="markdownIt-Anchor" href="#连接器"></a> 连接器</h3>
<p>执行SQL语句的第一步，总是会使用连接器连接到这个数据库上。连接器负责跟客户端建立连接、获取权限、维持和管理连接，连接命令通常如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure>
<p>输完命令之后，就需要交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致你的密码泄露。如果你连接的是生产服务器，强烈建议你不要这么做。</p>
<p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>
<ul>
<li>如果用户名或密码不对，你就会收到一个“Access denied for user”的错误，然后客户端程序结束执行</li>
<li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限，之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限</li>
</ul>
<p>这就意味着，一个用户成功建立连接后，即使你使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p>
<p>连接完成之后，如果你没有后续的动作，这个连接就处于空闲状态，可以使用<code>show processlist</code>命令中看到它，其中Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211128232149.png" alt="image-20211128232149339" /></p>
<p>客户端如果太长时间没有动静，连接器就会自动将他断开，这个时间是由参数<code>wait_timeout</code>控制的，默认值是8小时。</p>
<p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提示：<code>Lost connection to MySQL Server during queery</code>。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
<p>连接可以分为两种：长连接和短连接。长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>
<p>建立连接的过程通常是比较复杂的，所以在使用的过程中要尽量减少建立连接的动作，也就是尽量使用长连接。但是全部使用长连接后，你可能会发现，有些使用MySQL占用内存涨的特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p>
<p>解决这个问题通常有两种方案：</p>
<ul>
<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连</li>
<li>如果使用的MySQL5.7或更新的版本，可以在每次执行一个比较大的操作后，通过执行<code>mysql_reset_connection</code>来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完成时的状态</li>
</ul>
<h3 id="查询缓存"><a class="markdownIt-Anchor" href="#查询缓存"></a> 查询缓存</h3>
<p>连接建立完成后，就可以正式开始执行select语句了，执行逻辑就会来到第二步：查询缓存。</p>
<p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句，之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存到内存中。key是查询的语句，value是查询的结果，如果查询能够直接这个缓存中找到key，那么这个value就会被直接返回给客户端。</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中，可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，效率就会很高。</p>
<p>但是大多数情况下不要使用查询缓存，查询缓存的失效非常频繁，只要有对一个表的更新，这个表上的查询缓存都会被清空。因此很有可能费劲的把结果存起来，还没有使用，但是就被更新操作清空掉了，对于更新压力大的数据库来说，查询缓存的命中率会非常低，除非业务就是有一张静态表，很长时间才会更新依次，比如，一个系统的配置表，那这张表上的查询才适合使用查询缓存。</p>
<p>MySQL提供了参数配置，可以将参数<code>query_cache_type</code>设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存，而对于确定要使用查询缓存的语句，可以使用SQL_CACHE显式指定：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span> ；</span><br></pre></td></tr></table></figure>
<div class = "note warning"><p>MySQL8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始就彻底没有这个功能了。</p></div>
<h3 id="分析器"><a class="markdownIt-Anchor" href="#分析器"></a> 分析器</h3>
<p>如果没有命中查询缓存，就要真正开始执行语句了。MySQL会使用分析器对SQL语句做解析，识别出SQL语句中的字符串分别是什么，代表什么。在之前的例子中，MySQL会从输入的“select”关键字识别出来，这是一个查询语句，它也要把字符串“T”识别成表名“T”，把字符串“ID”识别成“列ID”，做完了这些识别以后，就要做“语法分析”，根据词法分析的结果，语法分析器会根据语法规则，判断输入的SQL语句是否满足MySQL语法。</p>
<div class="note warning"><p>如果语句不对，就会收到“You have an error in your SQL syntax”的错误提醒。</p></div>
<h3 id="优化器"><a class="markdownIt-Anchor" href="#优化器"></a> 优化器</h3>
<p>经过了分析器，MySQL就知道你想要做什么了，在开始执行之前，还需要经过优化器的处理。</p>
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序，比如执行下面的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID) <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>既可以先从表里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20</li>
<li>也可以先从表t2里面取出d=20的记录的值，再根据ID值关联到t1，再判断t1里面c的值是否等于10</li>
</ul>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有所不同，而优化器的作用就是决定选择使用哪一种方案。优化器的阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p>
<h3 id="执行器"><a class="markdownIt-Anchor" href="#执行器"></a> 执行器</h3>
<p>MySQL通过分析器知道了要做什么。通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。开始执行的时候，要先判断有没有对应的查询权限，如果没有，就会返回没有权限的错误，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from T <span class="built_in">where</span> ID=10;</span></span><br><span class="line">ERROR 1142 (42000): SELECT command denied to user &#x27;b&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27;</span><br></pre></td></tr></table></figure>
<p>如果有权限，就打开表继续执行，打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口，比如上述例子中表T中，ID字段没有索引，那么执行器的执行流程如下：</p>
<ol>
<li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端</li>
</ol>
<p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>
<p>数据库的慢查询日志中，字段<code>rows_examined</code>表示这个语句执行过程中扫描了多少行，这个值就是在执行器每次调用引擎获取数据行的时候累加的。不过在有些场景下，执行器调用一次，在引擎内部扫描了多行，因此引擎扫描行数跟<code>rows_examined</code>并不是完全相同的。</p>
<h2 id="sql执行流程"><a class="markdownIt-Anchor" href="#sql执行流程"></a> SQL执行流程</h2>
<p>MySQL可以借助重做日志和归档日志恢复到半个月内任意一秒的状态。为了了解它的实现原理，我们从一个表的一条更新语句开始：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T(ID <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>如果要将ID=2这一行的值加1，SQL如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>同样的更新语句也会按照SQL语句的基本执行链路执行：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211129235536.png" alt="image-20211129235535854" style="zoom:67%;" />
<p>与查询流程不一样的是，更新流程还设计两个重要的的日志模块：redo log（重做日志）和binlog（归档日志），这是MySQL中两个核心概念。</p>
<h3 id="重做日志"><a class="markdownIt-Anchor" href="#重做日志"></a> 重做日志</h3>
<p>如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL会使用WAL技术（Write-Ahead Logging），先写日志，再写磁盘。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录到磁盘里面，而这个更新往往是在系统比较空闲的时候做。InnoDB的redo log是固定大小的，比如可以配置一组4个文件，每个文件的大小是1GB，那么总共就可以记录4GB的操作。从头开始写入，到末尾又回到开头循环写入，如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211130232906.png" alt="image-20211130232906506" style="zoom:67%;" />
<p>其中write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头，checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。write pos和checkpoint之间还空着的部分，就可以用来记录新的操作，如果write pos追上了checkpoint，那么就表示不能再执行新的更新操作了，就得先停下来擦掉一些记录，然后将checkpoint向后移动。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p>
<h3 id="归档日志"><a class="markdownIt-Anchor" href="#归档日志"></a> 归档日志</h3>
<p>MySQL从整体上来看，大致可以分为两部分，一块是Server层，它主要负责MySQL功能层面的事情，另一块是引擎层，负责存储相关的具体事宜。上文提到的redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为bin log（归档日志）。由于最开始的MySQL并没有InnoDB引擎，MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。</p>
<p>redo log和binlog有以下区别：</p>
<ul>
<li>redo log是InnoDB引擎所特有的，binlog是MySQL的Server层实现的，所有引擎都可以使用</li>
<li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”，binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1”</li>
<li>redo log是循环写的，空间固定会用完，binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到写一个，并不会覆盖以前的日志</li>
</ul>
<h3 id="更新语句执行流程"><a class="markdownIt-Anchor" href="#更新语句执行流程"></a> 更新语句执行流程</h3>
<p>了解这两个日志的作用，我们再来看执行器和InnoDB引擎在执行这个update语句时的内部流程。</p>
<ol>
<li>执行器先找引擎取ID=2这一行，ID是逐渐，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回</li>
<li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态，然后告知执行器执行完成了，随时可以提交事务</li>
<li>执行器生成这个操作的binlog，并把binlog写入磁盘</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成</li>
</ol>
<p>update语句的执行如下图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211130235424.png" alt="image-20211130235424315" style="zoom:67%;" />
<p>注意这里并不是直接写入redo log，而是将redo log的写入拆成了两个步骤：prepare和commit，这就是“两阶段提交”。</p>
<h3 id="两阶段提交"><a class="markdownIt-Anchor" href="#两阶段提交"></a> 两阶段提交</h3>
<p>两阶段提交为了让两份日志之间的逻辑一致，要说明这个问题，我们得从文章开头的那个问题说起：怎样让数据库恢复到半个月内任意一秒的状态？</p>
<p>上文提到过，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式，当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那么可以：</p>
<ul>
<li>首先，找到最近的一次全量备份，如果运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库</li>
<li>然后，从备份的时候点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻</li>
</ul>
<p>这样临时库就跟误删之前的线上库一样了，然后就可以把表数据从临时库取出来，按需要恢复到线上库去。</p>
<p>接下来我们说明为什么需要两阶段提交，由于redo log和binlog时两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序，我们来看看这两种方式会有什么问题：</p>
<ul>
<li>先写redo log后写binlog。假设在redo log写完，binlog还没有写完的时候，MySQL异常重启，上文提到过，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复这一行c的值是1，但是由于binlog没写完就crash了，这个时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句，这个时候，如果需要用binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同</li>
<li>先写binlog后写redo log，如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志，所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行的c的值就是1，与原库的值不同</li>
</ul>
<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致，不过你可能会问，碰到需要用日志恢复数据的场景是不是很少，其实，并不只是误操作以后需要用这个过程来恢复数据，当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就不会导致线上出现主从数据库不一致的情况。</p>
<p>简单来说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
<h2 id="mysql性能分析工具"><a class="markdownIt-Anchor" href="#mysql性能分析工具"></a> MySQL性能分析工具</h2>
<h3 id="explain-简介"><a class="markdownIt-Anchor" href="#explain-简介"></a> explain 简介</h3>
<blockquote>
<p>EXPLAIN是什么？</p>
</blockquote>
<p>EXPLAIN：SQL的执行计划，使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句的。</p>
<blockquote>
<p>EXPLAIN怎么使用？</p>
</blockquote>
<p>语法：<code>explain</code> + <code>SQL</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select * from pms_category \G;</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1425</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>EXPLAIN能干嘛？</p>
</blockquote>
<p>可以查看以下信息：</p>
<ul>
<li><code>id</code>：表的读取顺序。</li>
<li><code>select_type</code>：数据读取操作的操作类型。</li>
<li><code>possible_keys</code>：哪些索引可以使用。</li>
<li><code>key</code>：哪些索引被实际使用。</li>
<li><code>ref</code>：表之间的引用。</li>
<li><code>rows</code>：每张表有多少行被优化器查询。</li>
</ul>
<h3 id="explain-字段"><a class="markdownIt-Anchor" href="#explain-字段"></a> explain 字段</h3>
<blockquote>
<p>id</p>
</blockquote>
<p><code>id</code>：表的读取和加载顺序。</p>
<p>值有以下三种情况：</p>
<ul>
<li><code>id</code>相同，执行顺序由上至下。</li>
<li><code>id</code>不同，如果是子查询，id的序号会递增，<strong>id值越大优先级越高，越先被执行。</strong></li>
<li><code>id</code>相同不同，同时存在。<strong>永远是id大的优先级最高，id相等的时候顺序执行。</strong></li>
</ul>
<blockquote>
<p>select_type</p>
</blockquote>
<p><code>select_type</code>：数据查询的类型，主要是用于区别，普通查询、联合查询、子查询等的复杂查询。</p>
<ul>
<li><code>SIMPLE</code>：简单的<code>SELECT</code>查询，查询中不包含子查询或者<code>UNION</code>。</li>
<li><code>PRIMARY</code>：查询中如果包含任何复杂的子部分，最外层查询则被标记为<code>PRIMARY</code>。</li>
<li><code>SUBQUERY</code>：在<code>SELECT</code>或者<code>WHERE</code>子句中包含了子查询。</li>
<li><code>DERIVED</code>：在<code>FROM</code>子句中包含的子查询被标记为<code>DERIVED(衍生)</code>，MySQL会递归执行这些子查询，把结果放在临时表中。</li>
<li><code>UNION</code>：如果第二个<code>SELECT</code>出现在<code>UNION</code>之后，则被标记为<code>UNION</code>；若<code>UNION</code>包含在<code>FROM</code>子句的子查询中，外层<code>SELECT</code>将被标记为<code>DERIVED</code>。</li>
<li><code>UNION RESULT</code>：从<code>UNION</code>表获取结果的<code>SELECT</code>。</li>
</ul>
<blockquote>
<p>type</p>
</blockquote>
<p><code>type</code>：访问类型排列。</p>
<p><strong>从最好到最差依次是：</strong><code>system</code>&gt;<code>const</code>&gt;<code>eq_ref</code>&gt;<code>ref</code>&gt;<code>range</code>&gt;<code>index</code>&gt;<code>ALL</code>。除了<code>ALL</code>没有用到索引，其他级别都用到索引了。</p>
<p>一般来说，得保证查询至少达到<code>range</code>级别，最好达到<code>ref</code>。</p>
<ul>
<li>
<p><code>system</code>：表只有一行记录（等于系统表），这是<code>const</code>类型的特例，平时不会出现，这个也可以忽略不计。</p>
</li>
<li>
<p><code>const</code>：表示通过索引一次就找到了，<code>const</code>用于比较<code>primary key</code>或者<code>unique</code>索引。因为只匹配一行数据，所以很快。如将主键置于<code>where</code>列表中，MySQL就能将该查询转化为一个常量。</p>
</li>
<li>
<p><code>eq_ref</code>：唯一性索引扫描，读取本表中和关联表表中的每行组合成的一行，查出来只有一条记录。除 了 <code>system</code> 和<code>const</code> 类型之外, 这是最好的联接类型。</p>
</li>
<li>
<p><code>ref</code>：非唯一性索引扫描，返回本表和关联表某个值匹配的所有行，查出来有多条记录。</p>
</li>
<li>
<p><code>range</code>：只检索给定范围的行，一般就是在<code>WHERE</code>语句中出现了<code>BETWEEN</code>、<code>&lt; &gt;</code>、<code>in</code>等的查询。这种范围扫描索引比全表扫描要好，因为它只需要开始于索引树的某一点，而结束于另一点，不用扫描全部索引。</p>
</li>
<li>
<p><code>index</code>：<code>Full Index Scan</code>，全索引扫描，<code>index</code>和<code>ALL</code>的区别为<code>index</code>类型只遍历索引树。<strong>也就是说虽然<code>ALL</code>和<code>index</code>都是读全表，但是<code>index</code>是从索引中读的，<code>ALL</code>是从磁盘中读取的。</strong></p>
</li>
<li>
<p><code>ALL</code>：<code>Full Table Scan</code>，没有用到索引，全表扫描。</p>
</li>
</ul>
<blockquote>
<p>possible_keys 和 key</p>
</blockquote>
<p><code>possible_keys</code>：显示可能应用在这张表中的索引，一个或者多个。查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用。</strong></p>
<p><code>key</code>：实际使用的索引。如果为<code>NULL</code>，则没有使用索引。查询中如果使用了覆盖索引，则该索引仅仅出现在<code>key</code>列表中。</p>
<blockquote>
<p>key_len</p>
</blockquote>
<p><code>key_len</code>：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。<code>key_len</code>显示的值为索引字段的最大可能长度，并非实际使用长度，即<code>key_len</code>是根据表定义计算而得，不是通过表内检索出的。在不损失精度的情况下，长度越短越好。</p>
<p><code>key_len</code>计算规则：<strong><a href="https://blog.csdn.net/qq_34930488/article/details/102931490">https://blog.csdn.net/qq_34930488/article/details/102931490</a></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> desc pms_category;</span></span><br><span class="line">+---------------+------------+------+-----+---------+----------------+</span><br><span class="line">| Field         | Type       | Null | Key | Default | Extra          |</span><br><span class="line">+---------------+------------+------+-----+---------+----------------+</span><br><span class="line">| cat_id        | bigint(20) | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name          | char(50)   | YES  |     | NULL    |                |</span><br><span class="line">| parent_cid    | bigint(20) | YES  |     | NULL    |                |</span><br><span class="line">| cat_level     | int(11)    | YES  |     | NULL    |                |</span><br><span class="line">| show_status   | tinyint(4) | YES  |     | NULL    |                |</span><br><span class="line">| sort          | int(11)    | YES  |     | NULL    |                |</span><br><span class="line">| icon          | char(255)  | YES  |     | NULL    |                |</span><br><span class="line">| product_unit  | char(50)   | YES  |     | NULL    |                |</span><br><span class="line">| product_count | int(11)    | YES  |     | NULL    |                |</span><br><span class="line">+---------------+------------+------+-----+---------+----------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select cat_id from pms_category <span class="built_in">where</span> cat_id between 10 and 20 \G;</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY  # 用到了主键索引，通过查看表结构知道，cat_id是bigint类型，占用8个字节</span><br><span class="line">      key_len: 8        # 这里只用到了cat_id主键索引，所以长度就是8！</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 11</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ref</p>
</blockquote>
<p><code>ref</code>：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p>
<blockquote>
<p>rows</p>
</blockquote>
<p><code>rows</code>：根据表统计信息及索引选用情况，大致估算出找到所需的记录需要读取的行数。</p>
<blockquote>
<p>Extra</p>
</blockquote>
<p><code>Extra</code>：包含不适合在其他列中显示但十分重要的额外信息。</p>
<ul>
<li><code>Using filesort</code>：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<strong>MySQL中无法利用索引完成的排序操作成为&quot;文件内排序&quot;。</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 排序没有使用索引</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select name from pms_category <span class="built_in">where</span> name=<span class="string">&#x27;Tangs&#x27;</span> order by cat_level \G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: idx_name_parentCid_catLevel</span><br><span class="line">          key: idx_name_parentCid_catLevel</span><br><span class="line">      key_len: 201</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index; Using filesort</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 排序使用到了索引</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select name from pms_category <span class="built_in">where</span> name=<span class="string">&#x27;Tangs&#x27;</span> order by parent_cid,cat_level\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: idx_name_parentCid_catLevel</span><br><span class="line">          key: idx_name_parentCid_catLevel</span><br><span class="line">      key_len: 201</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>Using temporary</code>：使用了临时表保存中间结果，MySQL在対查询结果排序时使用了临时表。常见于排序<code>order by</code>和分组查询<code>group by</code>。<strong>临时表対系统性能损耗很大。</strong></p>
</li>
<li>
<p><code>Using index</code>：表示相应的<code>SELECT</code>操作中使用了覆盖索引，避免访问了表的数据行，效率不错！如果同时出现<code>Using where</code>，表示索引被用来执行索引键值的查找；如果没有同时出现<code>Using where</code>，表明索引用来读取数据而非执行查找动作。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 覆盖索引</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：如果要使用覆盖索引，一定不能写SELECT *，要写出具体的字段。</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select cat_id from pms_category \G;</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL       </span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1425</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index   # select的数据列只用从索引中就能够取得，不必从数据表中读取   </span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Using where</code>：表明使用了<code>WHERE</code>过滤。</li>
<li><code>Using join buffer</code>：使用了连接缓存。</li>
<li><code>impossible where</code>：<code>WHERE</code>子句的值总是false，不能用来获取任何元组。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select name from pms_category <span class="built_in">where</span> name = <span class="string">&#x27;zs&#x27;</span> and name = <span class="string">&#x27;ls&#x27;</span>\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: NULL</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">     filtered: NULL</span><br><span class="line">        Extra: Impossible WHERE   # 不可能字段同时查到两个名字</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<h1 id="mysql索引"><a class="markdownIt-Anchor" href="#mysql索引"></a> MySQL索引</h1>
<h2 id="索引常见模型"><a class="markdownIt-Anchor" href="#索引常见模型"></a> 索引常见模型</h2>
<p>除了数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。简单来说，索引是排好序的快速查找数据结构。</p>
<p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多中，可以用于提高读写效率的数据结构有很多中，这里我们这里讨论三种常见的数据结构：哈希表、有序数组、搜索树。</p>
<h3 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h3>
<p>哈希表是一种以键-值（key-value）存储数据的结构，我们只需要输入待查找的值即key，就可以找到其对应的值即value。使用哈希算法不可避免的就会遇到哈希冲突，链地址法是解决哈希冲突比较常见的做法。</p>
<p>假设现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211202233834.png" alt="image-20211202233834367" style="zoom:67%;" />
<p>图中，User2和User4根据身份证号算出来的值都是N，但是没有关系，后面还有一个链表。假设这个时候要查ID_card_n2对应的名字是什么，首先将ID_card_n2通过哈希函数算出N，然后，按顺序遍历，找到User2。</p>
<p>需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加，但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的，如果要查找身份证号在[ID_card_X,ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。因此，哈希表这种结构适用于只有等值查询的场景，比如Memcached及其他一些NoSQL引擎。</p>
<h3 id="有序数组"><a class="markdownIt-Anchor" href="#有序数组"></a> 有序数组</h3>
<p>有序数组在等值查询和范围查询场景中的性能就都非常优秀。还是上面根据身份证号查询名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211202234913.png" alt="image-20211202234913046" style="zoom:67%;" />
<p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果要查询ID_card_n2对应的名字，用二分法就可以快速得到，时间复杂度为O（logN）。同理，如果要查询区间的时间复杂度也是O（logN）。</p>
<p>如果仅仅看查询效率，有序数组就是最好的数据结构了，但是，在需要更新数据的时候就麻烦了。往中间插入一条记录就必须得往后挪动所有的记录，成本非常高。因此，有序数组索引只适用于静态存储引擎，比如要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。</p>
<h3 id="二叉搜索树"><a class="markdownIt-Anchor" href="#二叉搜索树"></a> 二叉搜索树</h3>
<p>如果我们用二叉搜索树来实现上述的例子：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211202235620.png" alt="image-20211202235620443" style="zoom:67%;" />
<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果要查询ID_card_n2的话，按照途中搜索的顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得到，这个时间复杂度是O（logN）。</p>
<p>不过为了维持O（logN）的查询复杂度，更新的时间复杂度也是O（logN）。</p>
<p>树可以有二叉，也可以有多叉，多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止在内存中，还要写到磁盘上。</p>
<p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少地数据块。那么，我们就不应该使用二叉树，而是要使用“N叉树”，这里，“N叉”树中地“N”取决于数据块的大小。以InnoDB的一个整数字段为例。这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次从盘。其实，树的第二层也有很大的概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<p>由于N叉树在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。在MySQL中，索引是在存储引擎层的实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而底层的实现也可能不同。</p>
<h3 id="b树"><a class="markdownIt-Anchor" href="#b树"></a> B+树</h3>
<p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表，并且InnoDB使用了B+树索引模型，将数据存储在了B+树中，每一个索引在InnoDB中对应一颗B+树。</p>
<p>假设我们有一个主键列为ID的表，表中有字段k，并且在k上有索引，这个表的建表语句是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> T (</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	k <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">	INDEX(k)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure>
<p>然后向表中插入5条记录，表中R1~R5的（ID，K）的值分别为（100，1）、（200，2）、（300，3）、（500，5）、（600，6），两棵树的示例示意图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211204115523.png" alt="image-20211204115523479" style="zoom:67%;" />
<p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。主键索引的叶子节点存储的是整行数据，在InnoDB中，主键索引也被称为聚簇索引（clustered index）。非主键索引的叶子节点内容是主键的值，在InnoDB里，非主键索引也被称为二级索引（secondary index）。</p>
<p>基于主键索引和普通索引的查询略有差别：</p>
<ul>
<li>如果语句是<code>select * from T where ID = 500</code>，即主键查询方式，则只需要搜索ID这颗B+树</li>
<li>如果语句是<code>select * from T where k = 5</code>，即普通索引查询方式，则需要先搜索K索引树，得到ID的值为500，再到ID索引树搜索一次，这个过程称为回表</li>
</ul>
<p>也就是说，基于非主键索引的查询需要多扫描一棵索引树，因此，我们在应用中应该尽量使用主键查询。</p>
<p>B+树为了维护索引的有序性，在插入新值的时候需要做必要的维护。以上面的图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID的值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然也受收到影响。</p>
<p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</p>
<p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并，合并的过程，可以认为是分裂过程的逆过程。</p>
<p>可能你在一些建表规范里面见到过类似的描述，要求建表语句里面一定要有自增主键。当然事无绝对，我们需要分析一下哪些场景应该使用自增主键，而哪些场景下不应该。</p>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的：NOT PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值作为下一条记录的ID值，也就是说，自增主键的插入数据的模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不设计到挪动其它记录，也不会触发叶子节点的分裂。而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>除了考虑性能外，我们还可以从存储空间的角度来看。假设表中确实有一个唯一的字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>不过在典型的KV场景，由于没有其它索引，所以就不用考虑其它索引叶子节点大小的问题了，KV场景的特点如下：</p>
<ul>
<li>只有一个索引</li>
<li>该索引必须是唯一索引</li>
</ul>
<p>这时候我们就需要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<h2 id="索引的执行流程"><a class="markdownIt-Anchor" href="#索引的执行流程"></a> 索引的执行流程</h2>
<p>创建好索引之后，我们探讨一下索引的执行流程，以下面的表T为例，如果执行<code>select * from T where k between 3 and 5</code>，需要执行几次树的搜索操作，会扫描多少行？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> T (</span><br><span class="line">	ID <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	k <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">	s <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	INDEX k(k)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">&#x27;bb&#x27;</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">&#x27;cc&#x27;</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">&#x27;ee&#x27;</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">&#x27;ff&#x27;</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">&#x27;gg&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>此时表中的索引结构如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211205110531.png" alt="image-20211205110530992" style="zoom:67%;" />
<h3 id="回表"><a class="markdownIt-Anchor" href="#回表"></a> 回表</h3>
<p>此时，上述SQL语句查询的执行流程：</p>
<ol>
<li>在k索引树上找到k=3的记录，取得ID=300</li>
<li>再到ID索引树查到ID=300对应的R3</li>
<li>在k索引树取下一个值k=5，取得ID=500</li>
<li>在k索引树取下一个值k=6，不满足条件，循环结束</li>
</ol>
<p>在这个过程中，回到主键索引树搜索的过程，就称为回表，可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）.</p>
<p>在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，该如何避免回表呢？</p>
<h3 id="覆盖索引"><a class="markdownIt-Anchor" href="#覆盖索引"></a> 覆盖索引</h3>
<p>如果执行的语句是<code>select ID from T where k between 3 and 5</code>，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询 需求，我们称为覆盖索引。</p>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
<p>需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三条记录，R3~R5（对应的索引k上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2。</p>
<p>基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？假设这个市民表的定义如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tuser` (</span><br><span class="line">	`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`id_card` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`ismale` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">	KEY `id_card` (`id_card`),</span><br><span class="line">	KEY `name_age` (`name`, `age`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br></pre></td></tr></table></figure>
<p>我们知道，身份证号是市民的唯一标识，也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p>
<p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，那这个联合索引就有意义了。它可以高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p>
<p>当然，索引字段的维护总是有代价的，因此，在建立冗余索引来支持索引覆盖时就需要权衡考虑了。</p>
<h3 id="最左前缀原则"><a class="markdownIt-Anchor" href="#最左前缀原则"></a> 最左前缀原则</h3>
<p>如果要为每一种查询都设计一个索引，会导致索引数量激增，在B+树这种索引结构中，可以利用索引的“最左前缀”来定位记录，为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211205113629.png" alt="image-20211205113628876" style="zoom:67%;" />
<p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。当需要查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p>
<p>如果要查的是所有名字第一个字的是“张”的人，你的SQL语句的条件是“<code>where name like 张%</code>”。这时也可以用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。</p>
<p>可以看到，不止是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。因此，在建立联合索引的时候，通常我们就会根据索引的复用能力来确定索引内的字段顺序，如果可以通过调整联合索引的顺序，就可以少维护一个索引，那么就要优先考虑建立这样顺序的索引。</p>
<p>那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用（a，b）这个联合索引的，这个时候不得不维护另一个索引，也就是说必须同时维护（a，b）、（b）这两个索引。这种情况下，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name字段是比age字段大的，那么建议创建一个（name，age）的联合索引和一个（age）的单字段索引。</p>
<h3 id="索引下推"><a class="markdownIt-Anchor" href="#索引下推"></a> 索引下推</h3>
<p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录，那么不符合最左前缀的部分，会怎么样呢？</p>
<p>我们还是以市民表中的联合索引（name，age）为例。假设现在的需求是检索出表中“名字第一个字是张，而且年龄是10岁所有男孩”，那么，SQL语句是这么写的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> ismale<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这个语句在搜索索引树的时候，只能用“张”，找到第一个满足条件的记录ID3，然后判断其它条件是否满足。在MySQL 5.6之前，只能从ID3开始一个个回表，到主键索引上找出数据行，再对比字段值，而在MySQL 5.6之后引入的索引下推优化（index condition pushdown），可以在索引遍历的过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，下面是这两个过程的执行流程图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211205173708.png" alt="image-20211205173708482" style="zoom:67%;" />
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211205173743.png" alt="image-20211205173743641" style="zoom:67%;" />
<p>在这两个图里面，每一个虚线箭头表示回表一次，在第一张图中，InnoDB并不会去看age的值，只是按顺序把“name”第一个字是“张”的记录一条条取出来回表，因此，需要回表4次。下一张图中，InnoDB在（name，age）索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在我们这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。</p>
<h2 id="普通索引和唯一索引"><a class="markdownIt-Anchor" href="#普通索引和唯一索引"></a> 普通索引和唯一索引</h2>
<p>现在假设我们在维护一个市民系统，每个人都有一个唯一的身份证号，而且通过业务代码保证不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> CUser <span class="keyword">where</span> id_card <span class="operator">=</span> <span class="string">&#x27;xxxxxxxyyyyyyzzzzz&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>如果要在id_card字段上创建索引，由于身份证号字段比较大，作为主键并不合适，那么可以给id_card字段创建唯一索引，也可以创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的，但在性能上有所差别。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211205224925.png" alt="image-20211205224925129" style="zoom:67%;" />
<p>接下来，我们就从这两种索引对查询语句和更新语句的性能来进行分析。</p>
<h3 id="查询过程"><a class="markdownIt-Anchor" href="#查询过程"></a> 查询过程</h3>
<p>假设执行的查询语句是<code>select id from T where k = 5</code>，这个查询语句在索引树上的查找的过程，先是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。</p>
<ul>
<li>对于普通索引来说，查找到满足条件的第一个记录（5，500）后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录</li>
<li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索</li>
</ul>
<p>InnoDB的数据是按数据页为到位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。由于引擎是按页读写的，所以说，当找到k=5的时候，它所在的数据页就都在内存里了，那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p>
<p>当然，如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些，不过，对于整型字段，一个数据页就可以放近千个key，因此出现这种情况的概率会很低，所以在计算平均性能差异的时候，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。</p>
<p>总而言之，对于查询的场景来说，唯一索引和普通索引并没有性能上的差距。</p>
<h3 id="更新过程"><a class="markdownIt-Anchor" href="#更新过程"></a> 更新过程</h3>
<p>为了说明普通索引和唯一索引对更新语句性能的影响，需要首先了解change buffer。</p>
<p>当需要更新一个数据页的时候，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>需要说明的是，虽然名字叫做change buffer，实际上它是可以持久化的数据，也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程也会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。</p>
<p>显然，如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能避免占用内存，提高内存利用率。</p>
<p>那么，什么情况下会使用到change buffer呢？</p>
<p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入（4，400）这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。</p>
<p>因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。</p>
<p>change buffer用的是buffer pool里的内存，因此不能无线增大。change buffer的大小，可以通过参数<code>innodb_change_buffer_max_size</code>来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p>
<p>理解了change buffer的机制，我们再来看看如果要在这张表中插入一个新记录（4，400）的话，InnoDB的处理流程。</p>
<p>第一种情况是，这个记录要更新的目标在内存中，这时，InnoDB的处理流程如下：</p>
<ul>
<li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束</li>
<li>对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了</li>
</ul>
<p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p>
<h3 id="change-buffer详解"><a class="markdownIt-Anchor" href="#change-buffer详解"></a> change buffer详解</h3>
<p>上文我们说过，change buffer只限于用在普通索引的场景下，而是不适用于唯一索引，那么普通索引的所有场景，使用change buffer都可以起到加速的作用吗？</p>
<p>由于merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer的记录变更越多（也就是这个页面上要更新的次数越多），收益就越大。因此对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。</p>
<p>此时我们再来分析普通索引和唯一索引选择的问题。这两类索引在查询能力上没有差别，主要是对更新性能的影响，因此，尽量选择普通索引。如果所有的更新后面，都马上伴随着对这个记录的查询，那么应该关闭change buffer，而在其它情况下change buffer都能提升更新性能。</p>
<h3 id="change-buffer和redo-log"><a class="markdownIt-Anchor" href="#change-buffer和redo-log"></a> change buffer和redo log</h3>
<p>change buffer和redo log是两个比较容易混淆的概念，接下来我们通过实例来说明它们之间的区别，先插入两条数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t (id, k) <span class="keyword">VALUES</span> (id1, k1), (id2, k2);</span><br></pre></td></tr></table></figure>
<p>这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存（InnoDB buffer pool）中，k2所在的数据页不在内存中。下图所示是带change buffer的更新状态图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211206231723.png" alt="image-20211206231723229" style="zoom:67%;" />
<p>这条更新语句，共涉及了四个部分：内存、redo log（ib_log_fileX）、数据表空间（t.ibd）、系统表空间（ibdata1）。</p>
<p>这条更新语句做了如下操作：</p>
<ol>
<li>Page1在内存中，直接更新内存</li>
<li>Page2没有在内存中，就在内存中change buffer区域，记录下“我要往Page插入一行”这个信息</li>
<li>将上述两个动作记入redo log（图中3和4）</li>
</ol>
<p>做完上面这些，事务就可以完成了，不难看出，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的，同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。</p>
<p>完成上述操作之后，假设要执行<code>select * from t where k in(k1, k2)</code>，执行的流程图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211206235019.png" alt="image-20211206235019581" style="zoom:67%;" />
<p>从图中可以看到：</p>
<ul>
<li>读Page1的时候，直接从内存返回</li>
<li>要读Page2的时候，需要把Page2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果</li>
</ul>
<p>可以看到，直到需要读Page2的时候，这个数据页才会被读入内存，所以要简单地对比这两个机制在提升性能上地收益的话，redo log主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。</p>
<h2 id="索引的选择"><a class="markdownIt-Anchor" href="#索引的选择"></a> 索引的选择</h2>
<p>MySQL中一张表可以支持多个索引，并且使用哪个索引是由MySQL来确定的，不过在某些场景下，MySQL可能会选错索引，从而导致执行速度变得很慢。</p>
<p>首先先建一张表，表里有a、b两个字段，并分别建立索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`), </span><br><span class="line">  KEY `a` (`a`), </span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB ；</span><br></pre></td></tr></table></figure>
<p>然后执行如下SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;</span><br></pre></td></tr></table></figure>
<p>通过explain命令可以这条语句执行的情况：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211165917.png" alt="image-20211211165917452" /></p>
<p>我们在字段‘a’上建立了普通索引，从分析的结果来看，优化器也选择了索引a，但实际上并没有这么简单，假设这张表上包含了10万行的数据，然后做如下操作：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211170335.png" alt="image-20211211170335749" /></p>
<p>session A开启一个事务，然后，seesion B把数据都删除后，又调用idata这个存储过程，插入了10万行数据。这时候，session B的查询语句<code>select * from where a between 10000 and 20000</code>就不会再选择索引a了。我们可以通过慢查询日志（show log）来查看以下具体的执行情况。为了说明优化器选择的结果是否正确，这里使用了<code>force index(a)</code>来让优化器强制使用索引a。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>; <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t force index(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;<span class="comment">/*Q2*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一句是将查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日志中</li>
<li>第二句，Q1是session B原来的查询</li>
<li>第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比</li>
</ul>
<p>这三条SQL语句执行完成后的慢查询日志如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211171316.png" alt="image-20211211171316832" /></p>
<p>可以看到，Q1扫描了10万行，显然是走了全表扫描，执行时间是40毫秒。Q2扫描了10001行，执行了21毫秒。也就是说，我们在没有使用force index的时候，MySQL用错了索引，导致了更长的执行时间，要理解这个现象，就必须了解优化器选择索引的策略。</p>
<h3 id="优化器逻辑"><a class="markdownIt-Anchor" href="#优化器逻辑"></a> 优化器逻辑</h3>
<p>优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越小，消耗的CPU资源越少。除此之外，优化器还会结合是否使用临时表、是否排序等因素进行综合判断，由于这个查询语句并没有涉及到临时表和排序，所以MySQL选错索引肯定是在判断扫描行数的时候出现了问题。</p>
<p>MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数，这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好，而一个索引上不同的值的个数，我们称之为“基数（cardinality）”。也就是说，这个基数越大，索引的区分度就越好。</p>
<p>我们可以使用<code>show index</code>方法，看到一个索引的基数，如下图所示：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211172623.png" alt="image-20211211172622989" /></p>
<p>可以看到，虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不同，而且其实都不准确。</p>
<p>MySQL会通过采样统计的方式来得到索引的基数，采用采样统计的原因主要是，如果把整张表取出来一行行统计，然后可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</p>
<p>采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。而数据表是会持续更新的，索引统计信息也不会固定不变，所以当变更的数据行超过1/M的时候，会自动触发重新做一次索引统计。</p>
<p>在MySQL中，有两种存储索引统计的方式，可以通过设置参数<code>innodb_stats_persistent</code>的值来选择：</p>
<ul>
<li>设置为no的时候，表示统计信息会持久化存储，这时，默认的N是20，M是10</li>
<li>设置为off的时候，表示统计信息只存储在内存中，这时，默认的N是8，M是16</li>
</ul>
<div class="note info"><p>由于是采样统计，所以不管是N是20还是8，这个基数都是很容易不准的。</p></div>
<p>MySQL的优化器除了会统计索引的基数，还会判断这个语句本身要扫描的行数，可以通过<code>explain</code>的rows列来查看：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211174403.png" alt="image-20211211174403746" /></p>
<p>可以看到，Q2的rows的值是37116，与实际的10000相差较大，这里实际上存在两个问题，一是语句Q1优化器为什么没有选择索引‘a’，二是语句Q2为什么优化器没有选择37116行的执行计划，而是选择扫描行数是100000的执行计划，</p>
<p>对于问题二，如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行的数据，而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价，优化器会估算这两个选择的代价，虽然从执行时间上来看，这个选择并不是最优的。</p>
<p>使用普通索引需要把回表的代价算进去，所以，MySQL选错索引，最根本的原因是没有能准确地判断出扫描行数，我们可以使用<code>analyze table t</code>命令，可以用来重新统计索引信息，我们来看一下执行效果。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211194056.png" alt="image-20211211180509121" /></p>
<p>如果explain的结果预估的rows的值跟实际情况差距比较大，都可以采用这个方法来处理。</p>
<p>依然基于表t，执行另外一个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>) <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> b limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>从查询条件来看，这个查询没有符合条件的记录，因此将会返回空集合。为了方便理解这条语句的索引选择过程，首先来看一下a、b这两个索引的结构图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211194001.png" alt="image-20211211181122391" style="zoom:67%;" />
<p>如果使用索引a进行查询，首先扫描索引a的前1000个值，然后取到对应的id，再到主键索引上去查出每一行，然后根据字段b来过滤，显然这样需要扫描1000行。如果使用索引b进行查询，首先扫描索引b的最后50001个值，然后取到对应的id，再回到主键索引上取值再判断，所以需要扫描50001行。显然，使用索引a，执行速度明显会快很多，我们来看看MySQL是如何选择的：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211193956.png" alt="image-20211211181647822" /></p>
<p>可以看到，返回结果中key字段显式，这次优化器选择了索引b，而rows字段显式需要扫描的行数是50198。也就是说，扫描的行数的估计值依然不准确，并且MySQL又选错了索引。</p>
<h3 id="索引选择异常和处理"><a class="markdownIt-Anchor" href="#索引选择异常和处理"></a> 索引选择异常和处理</h3>
<p>当碰到优化器选择索引错误的时候，我们应该如何处理呢？</p>
<p>一种方法是，就像我们的第一个例子一样，采用force index强行选择一个索引。MySQL会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不会再评估其它索引的执行代价了，执行的效果如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211195432.png" alt="image-20211211195432111" /></p>
<p>原本语句需要执行2.23秒，而使用force index（a）的时候，只用了0.05秒，比优化器的选择快了40多倍。但这种方法并不完美，一是这么写不足够优雅，二是如果索引改了名字，这个语句也需要同步修改，三是这个语法并不是所有的数据库都支持，迁移比较麻烦。</p>
<p>既然优化器放弃了使用索引a，说明a还不够合适，所以第二种方法就是，修改语句，引导MySQL使用我们期望的索引。比如，在这个例子中，显然把“order by b limit 1”改成“order by b，a limit 1”，语义的逻辑是相同的，我们看一下修改之后的效果：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211200251.png" alt="image-20211211200251618" /></p>
<p>之前优化器选择使用索引b，是因为它认为使用索引b可以避免排序（b本身是索引，已经是有序的了，如果选择索引b的话，不需要再做排序，只需要遍历），所以即使扫描的行数多，也判定为代价更小。将语句修改为order by b，a，要求按照b，a排序，就意味着使用这两个索引都需要排序。因此，扫描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描1000行的索引a。</p>
<p>当然，这种修改并不是通用的优化手段，只是刚好在这个语句中有limit 1，因此如果有满足条件的记录，order by b limit 1和order by b，a limit 1都会返回b是最小的那一行，逻辑上一致，才可以这么做，除了这种做法，还可以将语句修改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>) <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100</span>) <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">100</span>) alias limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>执行的效果如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211201036.png" alt="image-20211211201036594" /></p>
<p>在这个例子中，我们用limit 100让优化器意识到，使用b索引的代价是很高的，其实是我们根据数据特征诱导了一下优化器，也不具备通用性。</p>
<p>第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。不过在这个例子中，这种方法并不适用。</p>
<h2 id="字符串添加索引"><a class="markdownIt-Anchor" href="#字符串添加索引"></a> 字符串添加索引</h2>
<p>在业务开发中，我们经常会碰到要存储字符串的场景，例如邮箱、用户名等，那么如何给字符串添加合适的索引呢？</p>
<p>假设，现在有一个支持邮箱登录的系统，用户表是这么定义的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SUser (</span><br><span class="line">	ID <span class="type">bigint</span> UNSIGNED <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	email <span class="type">varchar</span>(<span class="number">64</span>),</span><br><span class="line">    ...</span><br><span class="line">) ENGINE <span class="operator">=</span> innodb;</span><br></pre></td></tr></table></figure>
<p>如果要使用邮箱登录，那么业务代码中一定会出现类似这样的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> f1, f2 <span class="keyword">from</span> SUser <span class="keyword">where</span> email <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="前缀索引"><a class="markdownIt-Anchor" href="#前缀索引"></a> 前缀索引</h3>
<p>如果email这个字段上没有索引，那么这个语句就只能全表扫描。在MySQL中是支持前缀索引的，也就是说，可以定义字符串的一部分作为索引，如果创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</p>
<p>比如，这两个在email字段上创建索引的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> index index1(email);</span><br><span class="line">或</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> index index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>
<p>第一个语句创建的index1索引里面，包含了每个记录的整个字符串，而第二个语句创建的index2索引里面，对于每个记录都是只取前6个字节，它们的示意图如下所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211208225514.png" alt="image-20211208225514256" style="zoom:67%;" />
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211208225549.png" alt="image-20211208225549732" style="zoom:67%;" />
<p>从图中可以看到，由于email(6)这个索引结构中每个邮箱的字段都只取6个字节（即：zhangs），索引占用的空间会更小，这就是使用前缀索引的优势，但同时，前缀索引也可能会增加额外的记录扫描次数，通过它们的执行过程能更加清楚看到这一点。</p>
<p>如果使用的是index1（即email整个字符串的索引结构），执行顺序如下：</p>
<ol>
<li>从index1索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得ID2的值</li>
<li>到主键上查找到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集</li>
<li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email='zhangssxyz@xxx.com’的条件了，循环结束</li>
</ol>
<p>在整个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p>
<p>如果使用的是index2（即email（6）索引结构），执行顺序如下：</p>
<ol>
<li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1</li>
<li>到主键查找到主键是ID1的行，判断出email的值不是’zhangssxyz@xxx.com’，这行记录丢弃</li>
<li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值取对了，将这行记录加入结果集</li>
<li>重复上一步，直到在index2上取到的值不是’zhangs’时，循环结束</li>
</ol>
<p>在这个过程中，要回主键索引取4次数据，也就是扫描了4行。</p>
<p>通过以上两种情况的对比，可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多，但是对于这个查询语句来说，如果定义的index2不是email(6)而是email(7)，也就是说取email字段的前7个字节来构建索引的话，即满足前缀’zhangss’的记录只有一个，也能够直接查到ID2，只扫描这一行就结束了。</p>
<div class="note info"><p>这说明在使用前缀索引的时候，定义合理的长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</p></div>
<p>我们可以通过统计索引上有多少个不同的值来判断需要使用多长的前缀，首先计算这个列上有多少个不同的值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure>
<p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>) ） <span class="keyword">as</span> L4,</span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>) ） <span class="keyword">as</span> L5,</span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>) ） <span class="keyword">as</span> L6,</span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>) ） <span class="keyword">as</span> L7,</span><br><span class="line"><span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure>
<p>前缀索引很可能会损失区分度，所以需要预先设定一个可以接受的损失比例，比如5%，然后在返回的L4~L7中，找出不小于L*95%的值，假设这里L6、L7都满足，就可以选择前缀长度为6。</p>
<h3 id="前缀索引与覆盖索引"><a class="markdownIt-Anchor" href="#前缀索引与覆盖索引"></a> 前缀索引与覆盖索引</h3>
<p>前缀索引除了可能会增加扫描行数，影响到性能外，还可能会导致覆盖索引失效。</p>
<p>假设我们要查询的语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>与前面的例子中的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>相比，这个语句只要求返回id和email字段，所以，如果使用index1（即整个email字符串的索引结构）的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再查一次。而如果使用index2（即email（6）所索引结构）的话，就不得不回到ID索引再去判断email字段的值。</p>
<p>即使将index2的定义修改为email（18）的前缀索引，这时候，虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。也就是说前缀索引就用不上覆盖索引对查询性能的优化了，这也是在选择是否使用前缀索引时需要考虑的一个因素。</p>
<h3 id="其它方式"><a class="markdownIt-Anchor" href="#其它方式"></a> 其它方式</h3>
<p>实际场景中，我们很有可能碰到前缀的区分度不够好的情况，例如身份证号，总共18位，其中前6位是地址码，所以同一个县的人的身份证号前6位一般会是相同的。假设维护的数据库是同一个市的公民信息系统，这时候如果对身份证号长度为6的前缀索引的话，这个索引的区分度就非常低了，需要创建长度为12位以上的前缀索引，才能够满足区分度的要求，但是索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。解决这个问题通常来说有两种方式：倒序存储和使用哈希字段。</p>
<p>倒序存储是指如果存储身份证号码的时候把它倒过来存，每次查询的时候，可以：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card <span class="operator">=</span> reverse(<span class="string">&#x27;input_id_card_string&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>由于身份证号码的最后6位没有地址码这样的重复逻辑，所以最后这6位就提供了足够的区分度，实践中可以使用count(distinct)方法做个验证。</p>
<p>使用哈希字段指的是可以在表上创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> id_card_crc <span class="type">int</span> unsigned, <span class="keyword">add</span> index(id_card_crc);</span><br></pre></td></tr></table></figure>
<p>然后每次插入新记录的时候，都同时用cr32（）这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证通过crc32（）函数得到的结果可能是相同的，所以查询语句where部分要判断id_card的值是否精确相同。这样一来，索引的长度变成了4个字节，比原来小了很多。</p>
<p>使用倒序存储和使用哈希字段两种方式的异同点如下：</p>
<p>首先，它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X,ID_Y]的所有市民了。同样地，哈希字段的方式也只能支持等值查询。</p>
<p>它们的区别，主要在以下三个方面：</p>
<ol>
<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而哈希字段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个哈希字段也差不多抵消了</li>
<li>在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而哈希字段的方式需要额外调用一次crc32()函数，如果只是从这两个函数的计算复杂度来看的话，reverse函数额外消耗的CPU的资源会更小一些</li>
<li>从查询效率上看，使用哈希字段方式的查询性能相对更稳定一些，因为crc32（）算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数</li>
</ol>
<h2 id="order-by与索引"><a class="markdownIt-Anchor" href="#order-by与索引"></a> order by与索引</h2>
<p>在开发应用的时候，一定碰到过需要根据指定的字段排序来显示结果的需求，还是以我们前面举例用过的市民表为例，假设要查询城市是“杭州”的所有人的名字，并且按照姓名排序返回前1000个人的姓名、年龄。</p>
<p>建表语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `city` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `addr` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`), </span><br><span class="line">  KEY `city` (`city`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure>
<p>那么查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27; 杭州 &#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<h3 id="全字段排序"><a class="markdownIt-Anchor" href="#全字段排序"></a> 全字段排序</h3>
<p>为了避免全表扫描，我们需要在city字段加上索引，city这个索引的示意图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211222605.png" alt="image-20211211222605665" style="zoom:67%;" />
<p>在city字段上创建索引之后，使用explain查看执行情况：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211222422.png" alt="image-20211211222422522" /></p>
<p>Extra这个字段中的“Using filesort”表示就是需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。</p>
<p>从索引的示意图中可以看出， city='杭州’条件的行，是从 ID_X 到 ID_(X+N) 的这些记录。下面我们来分析整个语句的执行过程：</p>
<ol>
<li>初始化sort_buffer，确定放入name、city、age这三个字段</li>
<li>从索引city找到第一个满足city='杭州’条件的主键id，也就是图中的ID_X</li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中</li>
<li>从索引city取下一个记录的主键id</li>
<li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y</li>
<li>对sort_buffer中的数据按照字段name做快速排序</li>
<li>按照排序结果取前1000行返回给客户端</li>
</ol>
<p>这个过程就称为全字段排序，执行流程的示意图如下所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211225315.png" alt="image-20211211225315510" style="zoom:67%;" />
<p>图中“按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需要的内存和参数sort_buffer_size。sort_buffer_size就是MySQL为排序开辟的内存（sort_buffer）的大小，如果要排序的数据量小于sort_buffer_size，排序就在内存中完成，但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。可以通过如下命令来查看</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 打开 optimizer_trace ，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>;</span><br><span class="line"><span class="comment">/* @a 保存 Innodb_rows_read 的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@a</span> <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27; 杭州 &#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>;</span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`\G</span><br><span class="line"><span class="comment">/* @b 保存 Innodb_rows_read 的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@b</span> <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"><span class="comment">/* 计算 Innodb_rows_read 差值 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@b</span><span class="operator">-</span><span class="variable">@a</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法是通过查看OPTIMIZER_TRACE的结果来确认的，也可以从number_of_tmp_files中看到是否使用了临时文件。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211214233110.png" alt="image-20211214233110080" /></p>
<p>图中number_of_tmp_files表示的是，排序过程中使用的临时的文件数，之所以是12个文件，是当内存放不下时，就需要外部排序，外部排序一般使用归并排序算法，MySQL将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中，然后把这12个有序文件再合并成一个有序的大文件。如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序可以直接在内存中完成，否则就需要放在临时文件中排序。sort_buffer_size越小，需要的分成的份数就越多，number_of_tmp_files的值就越大。</p>
<p>另外，在示例表中有4000条满足city='杭州’的记录，所以图中的examined_rows=4000，表示参与排序的行数是4000行。</p>
<p>sort_mode里面的packed_additional_fields的意思是，排序过程中对字符串做了“紧凑处理”，即使name字段的定义是varchar(16)，在排序的过程中还是按照实际长度来分配空间的。</p>
<p>最后的查询<code>select @b - @a</code>在MyISAM引擎中返回的结果是4000，而在InnoDB引擎中会返回4001，这是因为如果使用的是InnoDB引擎的话，在查询表optimizer_trace的时候，需要用到临时表，InnoDB会把数据从临时表取出来，然后让innodb_rows_read的值加1。</p>
<h3 id="rowid排序"><a class="markdownIt-Anchor" href="#rowid排序"></a> rowid排序</h3>
<p>上面的排序算法，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时表中执行的，但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数就很少，要分成很多个临时文件，排序的性能会很差，所以如果单行很大，这个方法效率不够好。</p>
<p>我们可以通过修改参数，让MySQL换成另外一种算法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> max_length_for_sort_data <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
<p>它的意思是，如果单行的长度超过了这个值，MySQL就认为单行太大，要换一个算法。city、name、age这三个字段的定义总长度是36，超过了16，这个时候，MySQL就会使用rowid排序。</p>
<p>新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id，但这个时候，排序的结果因为少了city和age字段的值，不能直接返回了，整个执行流程如下：</p>
<ol>
<li>初始化sort_buffer，确定放入两个字段，即name和id</li>
<li>从索引city找到第一个满足city=“杭州”条件的主键id，也就是图中的ID_X</li>
<li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer</li>
<li>从索引city取下一个记录的主键id</li>
<li>重复步骤3、4直到不满足city=“杭州”条件为止，也就是图中的ID_Y</li>
<li>对sort_buffer中的数据按照字段name进行排序</li>
<li>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name、age三个字段返回给客户端</li>
</ol>
<p>执行的示意图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211214235751.png" alt="image-20211214235751360" style="zoom:67%;" />
<p>对于全字段的排序流程图会发现，rowid排序多访问了一次表t的主键索引，也就是步骤7。需要说明的是，最后的“结果集”是一个逻辑概念，实际上MySQL服务端从排序后的sort_buffer中依次取出id，然后原表查到city、name和age这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的，此时的OPTIMIZER_TRACE的结果如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211215230833.png" alt="image-20211215230833238" /></p>
<p>可以发现：</p>
<ul>
<li>sort_mode变成了&lt;sort_key,rowid&gt;,表示参与排序的只有name和id这两个字段</li>
<li>number_of_tmp_files变成10了，是因为这时候参与排序的行数虽然仍然是4000行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了</li>
</ul>
<h3 id="全字段排序和rowid排序对比"><a class="markdownIt-Anchor" href="#全字段排序和rowid排序对比"></a> 全字段排序和rowid排序对比</h3>
<p>当MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再会到原表去取数据；当内存太小，会影响排序效率，MySQL才会采用rowid排序算法，这样在排序过程中一次可以排序更多行，但是需要再回到原表去取数据。这体现了MySQL的一个设计理念：如果内存足够，就要多利用内存，尽量减少磁盘访问，对于InnoDB表来说，rowid排序会要求回表，因此不会优先选择。</p>
<p>不难发现，在MySQL中，对于无序的字段，排序是一个成本比较高的操作，因此，优化order by语句的一种方式就是让原来无序的数据变的“有序”。还是以市民表为例，我们在这个市民表上创建一个city和name的联合索引，对应的SQL语句是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index city_user(city, name);</span><br></pre></td></tr></table></figure>
<p>索引的示意图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211215232534.png" alt="image-20211215232534687" style="zoom:67%;" />
<p>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city=&quot;杭州&quot;的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是有序的。这样整个查询过程的流程就变成了：</p>
<ol>
<li>从索引（city，name）找到第一个满足city=&quot;杭州&quot;条件的主键id</li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回</li>
<li>从索引（city，name）取下一个记录主键id</li>
<li>重复步骤2、3，直到查到1000条记录，或者是不满足city=&quot;杭州&quot;条件时循环结束</li>
</ol>
<p>可以看到，这个查询过程不需要临时表，也不需要排序，explain的结果如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211215233134.png" alt="image-20211215233134766" /></p>
<p>可以看到，Extra字段中没有Using filesort了，也就是不需要排序了，而且由于（city，name）这个联合索引本身有序，所以这个查询也不用把4000行全都读一遍，只要找到满足条件的前1000条记录就可以退出了，也就是说，在这个例子中，只需要扫描1000次。</p>
<p>还可以更进一步，使用覆盖索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index city_user_age(city, name, age);</span><br></pre></td></tr></table></figure>
<p>这时，对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询也就不再需要排序了，这样整个查询语句的执行流程就变成了：</p>
<ol>
<li>从索引（city，name，age）找到第一个满足city=&quot;杭州&quot;条件的记录，取出其中的city、name和age这三个字段的值，作为结果集的一部分直接返回</li>
<li>从索引（city，name，age）取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回</li>
<li>重复执行步骤2，直到查到第1000条记录，或者是不满足city=&quot;杭州&quot;条件时循环结束</li>
</ol>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211215234018.png" alt="image-20211215234018038" style="zoom:67%;" />
<p>explain的结果如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211215234056.png" alt="image-20211215234055979" /></p>
<p>可以看到Extra字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多，不过索引还是有维护代价的，这是一个需要权衡的决定。</p>
<h2 id="索引的创建时机"><a class="markdownIt-Anchor" href="#索引的创建时机"></a> 索引的创建时机</h2>
<p>前面我们了解了一些关于索引的理论知识，接下来我们着重了解一些索引的实践部分。</p>
<h3 id="哪些情况需要建索引"><a class="markdownIt-Anchor" href="#哪些情况需要建索引"></a> 哪些情况需要建索引</h3>
<ul>
<li>主键自动建立主键索引（唯一 + 非空）。</li>
<li>频繁作为查询条件的字段应该创建索引。</li>
<li>查询中与其他表关联的字段，外键关系建立索引。</li>
<li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。</li>
<li>查询中统计或者分组字段（group by也和索引有关）。</li>
</ul>
<h3 id="那些情况不要建索引"><a class="markdownIt-Anchor" href="#那些情况不要建索引"></a> 那些情况不要建索引</h3>
<ul>
<li>记录太少的表。</li>
<li>经常增删改的表。</li>
<li>频繁更新的字段不适合创建索引。</li>
<li>Where条件里用不到的字段不创建索引。</li>
<li>假如一个表有10万行记录，有一个字段A只有true和false两种值，并且每个值的分布概率大约为50%，那么对A字段建索引一般不会提高数据库的查询速度。索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。</li>
</ul>
<h2 id="索引的最佳实践"><a class="markdownIt-Anchor" href="#索引的最佳实践"></a> 索引的最佳实践</h2>
<h3 id="单表索引分析"><a class="markdownIt-Anchor" href="#单表索引分析"></a> 单表索引分析</h3>
<blockquote>
<p>数据准备</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `article`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `article`(</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">`author_id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;作者id&#x27;</span>,</span><br><span class="line">`category_id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类id&#x27;</span>,</span><br><span class="line">`views` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;被查看的次数&#x27;</span>,</span><br><span class="line">`comments` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;回帖的备注&#x27;</span>,</span><br><span class="line">`title` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;标题&#x27;</span>,</span><br><span class="line">`content` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;正文内容&#x27;</span></span><br><span class="line">) COMMENT <span class="string">&#x27;文章&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;4&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>案例：查询<code>category_id</code>为1且<code>comments</code>大于1的情况下，<code>views</code>最多的<code>article_id</code>。</p>
</blockquote>
<p>1、编写SQL语句并查看SQL执行计划。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、sql语句</span></span><br><span class="line">SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、sql执行计划</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: article</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 5</span><br><span class="line">     filtered: 20.00</span><br><span class="line">        Extra: Using where; Using filesort  # 产生了文件内排序，需要优化SQL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>2、创建索引<code>idx_article_ccv</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_article_ccv <span class="keyword">ON</span> article(category_id,comments,views);</span><br></pre></td></tr></table></figure>
<p>3、查看当前索引。</p>
<p><img src="https://img-blog.csdnimg.cn/20200803134154162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70" alt="show index" /></p>
<p>4、查看现在SQL语句的执行计划。</p>
<p><img src="https://img-blog.csdnimg.cn/20200803134549914.png" alt="explain" /></p>
<p>我们发现，创建符合索引<code>idx_article_ccv</code>之后，虽然解决了全表扫描的问题，但是在<code>order by</code>排序的时候没有用到索引，MySQL居然还是用的<code>Using filesort</code>，为什么？</p>
<p>5、我们试试把SQL修改为<code>SELECT id,author_id FROM article WHERE category_id = 1 AND comments = 1 ORDER BY views DESC LIMIT 1;</code>看看SQL的执行计划。</p>
<p><img src="https://img-blog.csdnimg.cn/20200803135228945.png" alt="explain" /></p>
<p>推论：当<code>comments &gt; 1</code>的时候<code>order by</code>排序<code>views</code>字段索引就用不上，但是当<code>comments = 1</code>的时候<code>order by</code>排序<code>views</code>字段索引就可以用上！！！<strong>所以，范围之后的索引会失效。</strong></p>
<p>6、我们现在知道<strong>范围之后的索引会失效</strong>，原来的索引<code>idx_article_ccv</code>最后一个字段<code>views</code>会失效，那么我们如果删除这个索引，创建<code>idx_article_cv</code>索引呢？？？？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建索引 idx_article_cv */</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_article_cv <span class="keyword">ON</span> article(category_id,views);</span><br></pre></td></tr></table></figure>
<p>查看当前的索引</p>
<p><img src="https://img-blog.csdnimg.cn/20200803140542912.png" alt="show index" /></p>
<p>7、当前索引是<code>idx_article_cv</code>，来看一下SQL执行计划。</p>
<p><img src="https://img-blog.csdnimg.cn/20200803140951803.png" alt="explain" /></p>
<h3 id="两表索引分析"><a class="markdownIt-Anchor" href="#两表索引分析"></a> 两表索引分析</h3>
<blockquote>
<p>数据准备</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `class`;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `book`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `class`(</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">`card` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类&#x27;</span> </span><br><span class="line">) COMMENT <span class="string">&#x27;商品类别&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `book`(</span><br><span class="line">`bookid` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">`card` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类&#x27;</span></span><br><span class="line">) COMMENT <span class="string">&#x27;书籍&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>两表连接查询的SQL执行计划</p>
</blockquote>
<p>1、不创建索引的情况下，SQL的执行计划。</p>
<p><img src="https://img-blog.csdnimg.cn/20200803143557187.png" alt="explain" /></p>
<p><code>book</code>和<code>class</code>两张表都是没有使用索引，全表扫描，那么如果进行优化，索引是创建在<code>book</code>表还是创建在<code>class</code>表呢？下面进行大胆的尝试！</p>
<p>2、左表(<code>book</code>表)创建索引。</p>
<p>创建索引<code>idx_book_card</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在book表创建索引 */</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_book_card <span class="keyword">ON</span> book(card);</span><br></pre></td></tr></table></figure>
<p>在<code>book</code>表中有<code>idx_book_card</code>索引的情况下，查看SQL执行计划</p>
<p><img src="https://img-blog.csdnimg.cn/20200803144429349.png" alt="explain" /></p>
<p>3、删除<code>book</code>表的索引，右表(<code>class</code>表)创建索引。</p>
<p>创建索引<code>idx_class_card</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在class表创建索引 */</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_class_card <span class="keyword">ON</span> class(card);</span><br></pre></td></tr></table></figure>
<p>在<code>class</code>表中有<code>idx_class_card</code>索引的情况下，查看SQL执行计划</p>
<p><img src="https://img-blog.csdnimg.cn/20200803145030597.png" alt="explain" /></p>
<p><strong>由此可见，左连接将索引创建在右表上更合适，右连接将索引创建在左表上更合适。</strong></p>
<h3 id="三张表索引分析"><a class="markdownIt-Anchor" href="#三张表索引分析"></a> 三张表索引分析</h3>
<blockquote>
<p>数据准备</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `phone`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `phone`(</span><br><span class="line">`phone_id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">`card` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类&#x27;</span> </span><br><span class="line">) COMMENT <span class="string">&#x27;手机&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三表连接查询SQL优化</p>
</blockquote>
<p>1、不加任何索引，查看SQL执行计划。</p>
<p><img src="https://img-blog.csdnimg.cn/20200803160631786.png" alt="explain" /></p>
<p>2、根据两表查询优化的经验，左连接需要在右表上添加索引，所以尝试在<code>book</code>表和<code>phone</code>表上添加索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在book表创建索引 */</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_book_card <span class="keyword">ON</span> book(card);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在phone表上创建索引 */</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_phone_card <span class="keyword">ON</span> phone(card);</span><br></pre></td></tr></table></figure>
<p>再次执行SQL的执行计划</p>
<p><img src="https://img-blog.csdnimg.cn/20200803161013880.png" alt="explain" /></p>
<h3 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h3>
<p><code>JOIN</code>语句的优化：</p>
<ul>
<li>尽可能减少<code>JOIN</code>语句中的<code>NestedLoop</code>（嵌套循环）的总次数：<strong>永远都是小的结果集驱动大的结果集</strong>。</li>
<li>优先优化<code>NestedLoop</code>的内层循环。</li>
<li>保证<code>JOIN</code>语句中被驱动表上<code>JOIN</code>条件字段已经被索引。</li>
<li>当无法保证被驱动表的<code>JOIN</code>条件字段被索引且内存资源充足的前提下，不要太吝惜<code>Join Buffer</code> 的设置。</li>
</ul>
<h2 id="索引失效"><a class="markdownIt-Anchor" href="#索引失效"></a> 索引失效</h2>
<p>索引看起来非常美好，能够十分有效的加快我们的查询效率，然而，在MySQL中有很多看上去逻辑相同，但是性能却差异巨大的SQL语句，对这些语句使用不当的话，就会不经意间导致整个数据库的压力变大，</p>
<h3 id="函数操作"><a class="markdownIt-Anchor" href="#函数操作"></a> 函数操作</h3>
<p>假设现在维护的是一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员id（operator）、交易时间（t_modified）等字段，建表语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tradelog` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `operator` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `t_modified` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`), </span><br><span class="line">  KEY `tradeid` (`tradeid`), </span><br><span class="line">  KEY `t_modified` (`t_modified`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br></pre></td></tr></table></figure>
<p>假设现在已经记录了从2016年初到2018年底的所有数据，要查询所有年份中7月份的交易记录总数，SQL语句可能如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)<span class="operator">=</span><span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<p>执行之后就会发现这个SQL语句会比预期的慢很多，虽然在t_modified字段上已经创建了索引，但是MySQL并没有使用这个索引。下面是t_modified索引的示意图，方框上面的数字表示month()函数对应的值：</p>
<img src="https://s2.loli.net/2022/01/11/5tWsbZfcvzUdlnp.png" alt="image-20220111234901523" style="zoom:67%;" />
<p>如果SQL语句中条件是where t_modified='2018-7-1’的话，引擎就会按照上面绿色箭头的路线，快速定位到t_modified='2018-7-1’需要的结果，而如果计算month()函数的话，在传入7的时候已经无法定位记录了。实际上，B+树提供的这个快速定位能力，来源于同一层兄弟节点的有序性，也就是说，对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器决定放弃走树搜索功能。</p>
<p>需要注意的是，优化器并不是要放弃使用这个索引，在这个例子中，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引t_modified，优化器对比索引大小后发现，索引t_modified更小，遍历这个索引比主键索引来得更快，因此最终还是会选择索引t_modified。</p>
<p>这条语句的explain的结果如下：</p>
<p><img src="https://s2.loli.net/2022/01/11/pxg3V6QXJ72ajO1.png" alt="image-20220111235919912" /></p>
<p>key=&quot;t_modified&quot;表示的是，使用了t_modified这个索引，这里的测试数据有10万行，rows=100335，说明这条语句扫描了整个索引的所有值，Extra字段的Using index，表示的是使用了覆盖索引，也就是说，由于在t_modified字段加上了month()函数操作，导致了全索引扫描。为了能够用上索引的快速定位能力，我们就要把SQL语句改成基于字段本身的范围查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span></span><br><span class="line">	(t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2016-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2016-8-1&#x27;</span>) <span class="keyword">or</span></span><br><span class="line">	(t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2017-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2017-8-1&#x27;</span>) <span class="keyword">or</span></span><br><span class="line">	(t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2018-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2018-8-1&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>如果还有其它年份的数据，都需要手动将年份补齐。实际上，只要where条件后面有函数操作都会导致无法使用索引快速定位的功能，即使不改变有序性，例如<code>select * from tradelog where id + 1 = 10000</code>,也需要将where条件修改为<code>where id = 10000 - 1</code>才可以有效的用上索引。</p>
<h3 id="隐式类型转换"><a class="markdownIt-Anchor" href="#隐式类型转换"></a> 隐式类型转换</h3>
<p>假设我们执行这样一条SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid <span class="operator">=</span> <span class="number">110717</span>;</span><br></pre></td></tr></table></figure>
<p>交易编号tradeid这个字段上，本来是有索引的，但是explain结果却显式，这条语句需要走全表扫描，这是由于tradeid字段类型是varchar（32），而输入的参数却是整型，所以需要做类型转换，从而导致了索引失效。实际上在MySQL中，字符串和数字做比较的话，会将字符串转换成数字，也就是说对与优化器来说，上面的SQL语句等价于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="built_in">CAST</span>(tradid <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">110717</span>;</span><br></pre></td></tr></table></figure>
<p>也就是说，这条语句触发了我们之前说到的过规则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p>
<h3 id="隐式字符编码转换"><a class="markdownIt-Anchor" href="#隐式字符编码转换"></a> 隐式字符编码转换</h3>
<p>假设系统里面还有另外一张表trade_detail，用来记录交易的操作细节。为了便于量化分析和复现，我们往交易日志表tradelog和交易详情表trade_detail这两个表里插入一些数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `trade_detail` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `trade_step` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `step_info` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`), </span><br><span class="line">  KEY `tradeid` (`tradeid`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8; <span class="keyword">insert</span> <span class="keyword">into</span> tradelog </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">6</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">8</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这时候，如果要查询id=2的交易的所有操作步骤信息，可以使用如下SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/01/12/f7srao8tkLSjIgJ.png" alt="image-20220112234657374" /></p>
<p>可以看到：</p>
<ol>
<li>第一行显式优化器现在交易记录表tradelog上查到id=2的行，这个步骤用上了主键索引，rows=1表示只扫描一行</li>
<li>第二行key=NULL，表示没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫描</li>
</ol>
<p>explain的详细过程如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220112235754324.png" alt="image-20220112235754324" style="zoom:67%;" />
<p>图中：</p>
<ul>
<li>第一步，是根据id在tradelog表里找到L2这一行</li>
<li>第二步，是从L2中取出tradeid字段的值</li>
<li>第三步，是根据tradeid的值到trade_detail表中查找条件匹配的行。explain的结果第二行的key=NULL表示的就是，这个过程是通过遍历主键索引的方式，一个一个地判断tradeid的值是否匹配</li>
</ul>
<p>可以发现，在执行第三步的时候，并没有使用trade_detail里的tradeied上的索引快速定位到等值的行。实际上，这是因为这两张表的字符集不同导致的，上面的SQL等价于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trade_detail <span class="keyword">where</span> <span class="keyword">CONVERT</span>(traideid <span class="keyword">USING</span> utf8mb4) <span class="operator">=</span> $L2.tradeid.value;</span><br></pre></td></tr></table></figure>
<p>CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集，这再次触发了本节开始时提到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p>
<div class="note info"><p>utf8mb4是utf8的超集，类似地，在程序设计语言里面，做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加地方向”进行转换的。</p></div>
<p>接下来我们看另外一种场景：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> l.operator <span class="keyword">from</span> tradelog l , trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> d.id <span class="operator">=</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>explain的结果：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220113234214053.png" alt="image-20220113234214053" /></p>
<p>这个语句里trade_detail表成了驱动表，但是explain结果的第二行显示，这次的查询操作用上了被驱动表tradelog里的索引（tradeied），扫描行数是1，这也是两个tradeied字段的join操作，为什么这次能用上被驱动表的tradeied索引呢？假设驱动表trade_detail里id=4的行记为R4，那么在连接的时候。被驱动表tradelog上执行的就是类似这样的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> operator <span class="keyword">from</span> tradelog <span class="keyword">where</span> traideid <span class="operator">=</span> $R4.tradeid.value;</span><br></pre></td></tr></table></figure>
<p>这个时候的$R4.tradeied.value的字符集是utf8，按照字符集转换规则，要转成utf8mb4，所以这个过程就被改写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> operator <span class="keyword">from</span> tradelog <span class="keyword">where</span> traideid <span class="operator">=</span><span class="keyword">CONVERT</span>($R4.tradeid.value <span class="keyword">USING</span> utf8mb4);</span><br></pre></td></tr></table></figure>
<p>由于这里CONVERT函数是加在输入参数上的，这样就可以用上被驱动表的tradeid索引了。</p>
<p>因此，对于SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid <span class="operator">=</span> l.tradeid <span class="keyword">and</span> l.id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>优化的方式通常有两种：</p>
<ul>
<li>
<p>比较常见的优化方法是，把trade_detail表上的tradeid字段的字符集也改成utf8mb4，这样就没有字符集转换问题了</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> trade_detail modify tradeid <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">default</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果数据量比较大，或者其它原因不能执行这个DDL，那么可以修改SQL语句：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid <span class="operator">=</span> <span class="keyword">CONVERT</span>(l.tradeid <span class="keyword">USING</span> utf8);</span><br></pre></td></tr></table></figure>
<p>这样主动把l.tradeid转成utf8，就避免了被驱动表上的字符编码转换。</p>
</li>
</ul>
<h3 id="索引失效的场景"><a class="markdownIt-Anchor" href="#索引失效的场景"></a> 索引失效的场景</h3>
<ul>
<li>全值匹配我最爱。</li>
<li>最佳左前缀法则。</li>
<li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描。</li>
<li>索引中范围条件右边的字段会全部失效。</li>
<li>尽量使用覆盖索引（只访问索引的查询，索引列和查询列一致），减少<code>SELECT *</code>。</li>
<li>MySQL在使用<code>!=</code>或者<code>&lt;&gt;</code>的时候无法使用索引会导致全表扫描。</li>
<li><code>is null</code>、<code>is not null</code>也无法使用索引。</li>
<li><code>like</code>以通配符开头<code>%abc</code>索引失效会变成全表扫描（使用覆盖索引就不会全表扫描了）。</li>
<li>字符串不加单引号索引失效。</li>
<li>少用<code>or</code>，用它来连接时会索引失效。</li>
</ul>
<h4 id="最佳左前缀法则"><a class="markdownIt-Anchor" href="#最佳左前缀法则"></a> 最佳左前缀法则</h4>
<blockquote>
<p>案例</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name字段 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name, age字段 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name，age，pos字段 这是属于全值匹配的情况！！！*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 索引没用上，ALL全表扫描 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 索引没用上，ALL全表扫描 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name字段，pos字段索引失效 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>最佳左前缀法则：如果索引是多字段的复合索引，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的字段。</strong></p>
<p><strong>口诀：带头大哥不能死，中间兄弟不能断。</strong></p>
<h4 id="索引列上不计算"><a class="markdownIt-Anchor" href="#索引列上不计算"></a> 索引列上不计算</h4>
<blockquote>
<p>案例</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 现在要查询`name` = <span class="string">&#x27;Ringo&#x27;</span>的记录下面有两种方式来查询！</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1、直接使用 字段 = 值的方式来计算</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM `staffs` WHERE `name` = <span class="string">&#x27;Ringo&#x27;</span>;</span></span><br><span class="line">+----+-------+-----+---------+---------------------+</span><br><span class="line">| id | name  | age | pos     | add_time            |</span><br><span class="line">+----+-------+-----+---------+---------------------+</span><br><span class="line">|  1 | Ringo |  18 | manager | 2020-08-03 08:30:39 |</span><br><span class="line">+----+-------+-----+---------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、使用MySQL内置的函数</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM `staffs` WHERE LEFT(`name`, 5) = <span class="string">&#x27;Ringo&#x27;</span>;</span></span><br><span class="line">+----+-------+-----+---------+---------------------+</span><br><span class="line">| id | name  | age | pos     | add_time            |</span><br><span class="line">+----+-------+-----+---------+---------------------+</span><br><span class="line">|  1 | Ringo |  18 | manager | 2020-08-03 08:30:39 |</span><br><span class="line">+----+-------+-----+---------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>我们发现以上两条SQL的执行结果都是一样的，但是执行效率有没有差距呢？？？</p>
<p>通过分析两条SQL的执行计划来分析性能。</p>
<p><img src="https://img-blog.csdnimg.cn/20200803171857325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70" alt="explain" /></p>
<p><strong>由此可见，在索引列上进行计算，会使索引失效。</strong></p>
<p><strong>口诀：索引列上不计算。</strong></p>
<h4 id="范围之后全失效"><a class="markdownIt-Anchor" href="#范围之后全失效"></a> 范围之后全失效</h4>
<blockquote>
<p>案例</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name，age，pos字段 这是属于全值匹配的情况！！！*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用到了idx_staffs_name_age_pos索引中的name，age字段，pos字段索引失效 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">&gt;</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;dev&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>查看上述SQL的执行计划</p>
<p><img src="https://img-blog.csdnimg.cn/20200803173357787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70" alt="explain" /></p>
<p><strong>由此可知，查询范围的字段使用到了索引，但是范围之后的索引字段会失效。</strong></p>
<p><strong>口诀：范围之后全失效。</strong></p>
<h4 id="覆盖索引尽量用"><a class="markdownIt-Anchor" href="#覆盖索引尽量用"></a> 覆盖索引尽量用</h4>
<p>在写SQL的不要使用<code>SELECT *</code>，用什么字段就查询什么字段。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 没有用到覆盖索引 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用到了覆盖索引 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `name`, `age`, `pos` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span> <span class="keyword">AND</span> `age` <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> `pos` <span class="operator">=</span> <span class="string">&#x27;manager&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200803213031893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70" alt="使用覆盖索引" /></p>
<p><strong>口诀：查询一定不用<code>*</code></strong>。</p>
<h4 id="不等有时会失效"><a class="markdownIt-Anchor" href="#不等有时会失效"></a> 不等有时会失效</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 会使用到覆盖索引 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `name`, `age`, `pos` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">!=</span> <span class="string">&#x27;Ringo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 索引失效 全表扫描 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">!=</span> <span class="string">&#x27;Ringo&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="like百分加右边"><a class="markdownIt-Anchor" href="#like百分加右边"></a> like百分加右边</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 索引失效 全表扫描 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%ing%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 索引失效 全表扫描 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%ing&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用索引范围查询 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;Rin%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>口诀：<code>like</code>百分加右边。</strong></p>
<p>如果一定要使用<code>%like</code>，而且还要保证索引不失效，那么使用覆盖索引来编写SQL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用到了覆盖索引 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `id` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%in%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用到了覆盖索引 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `name` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%in%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用到了覆盖索引 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `age` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%in%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用到了覆盖索引 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `pos` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%in%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用到了覆盖索引 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `id`, `name` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%in%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用到了覆盖索引 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `id`, `age` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%in%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用到了覆盖索引 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `id`,`name`, `age`, `pos` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%in&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用到了覆盖索引 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `id`, `name` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `pos` <span class="keyword">LIKE</span> <span class="string">&#x27;%na&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 索引失效 全表扫描 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `name`, `age`, `pos`, `add_time` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">&#x27;%in&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200803220743206.png" alt="模糊查询百分号一定加前边" /></p>
<p><strong>口诀：覆盖索引保两边。</strong></p>
<h4 id="字符要加单引号"><a class="markdownIt-Anchor" href="#字符要加单引号"></a> 字符要加单引号</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用到了覆盖索引 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `id`, `name` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;Ringo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用到了覆盖索引 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> `id`, `name` <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 索引失效 全表扫描 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `staffs` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure>
<p>这里name = 2000在MySQL中会发生强制类型转换，将数字转成字符串。</p>
<p><strong>口诀：字符要加单引号。</strong></p>
<h4 id="索引相关题目"><a class="markdownIt-Anchor" href="#索引相关题目"></a> 索引相关题目</h4>
<p><strong>假设index(a,b,c)</strong></p>
<table>
<thead>
<tr>
<th>Where语句</th>
<th>索引是否被使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>where a = 3</td>
<td>Y，使用到a</td>
</tr>
<tr>
<td>where a = 3 and b = 5</td>
<td>Y，使用到a，b</td>
</tr>
<tr>
<td>where a = 3 and b = 5</td>
<td>Y，使用到a，b，c</td>
</tr>
<tr>
<td>where b = 3 或者 where b = 3 and c = 4 或者 where c = 4</td>
<td>N，没有用到a字段</td>
</tr>
<tr>
<td>where a = 3 and c = 5</td>
<td>使用到a，但是没有用到c，因为b断了</td>
</tr>
<tr>
<td>where a = 3 and b &gt; 4 and c = 5</td>
<td>使用到a，b，但是没有用到c，因为c在范围之后</td>
</tr>
<tr>
<td>where a = 3 and b like ‘kk%’ and c = 4</td>
<td>Y，a，b，c都用到</td>
</tr>
<tr>
<td>where a = 3 and b like ‘%kk’ and c = 4</td>
<td>只用到a</td>
</tr>
<tr>
<td>where a = 3 and b like ‘%kk%’ and c = 4</td>
<td>只用到a</td>
</tr>
<tr>
<td>where a = 3 and b like ‘k%kk%’ and c = 4</td>
<td>Y，a，b，c都用到</td>
</tr>
</tbody>
</table>
<h4 id="面试题分析"><a class="markdownIt-Anchor" href="#面试题分析"></a> 面试题分析</h4>
<blockquote>
<p>数据准备</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建表 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test03`(</span><br><span class="line">`id` <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`c1` <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">`c2` <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">`c3` <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">`c4` <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">`c5` <span class="type">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;a1&#x27;</span>,<span class="string">&#x27;a2&#x27;</span>,<span class="string">&#x27;a3&#x27;</span>,<span class="string">&#x27;a4&#x27;</span>,<span class="string">&#x27;a5&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;b1&#x27;</span>,<span class="string">&#x27;b22&#x27;</span>,<span class="string">&#x27;b3&#x27;</span>,<span class="string">&#x27;b4&#x27;</span>,<span class="string">&#x27;b5&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>,<span class="string">&#x27;c4&#x27;</span>,<span class="string">&#x27;c5&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;d1&#x27;</span>,<span class="string">&#x27;d2&#x27;</span>,<span class="string">&#x27;d3&#x27;</span>,<span class="string">&#x27;d4&#x27;</span>,<span class="string">&#x27;d5&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) <span class="keyword">VALUES</span>(<span class="string">&#x27;e1&#x27;</span>,<span class="string">&#x27;e2&#x27;</span>,<span class="string">&#x27;e3&#x27;</span>,<span class="string">&#x27;e4&#x27;</span>,<span class="string">&#x27;e5&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建复合索引 */</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_test03_c1234 <span class="keyword">ON</span> `test03`(`c1`,`c2`,`c3`,`c4`);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>题目</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最好索引怎么创建的，就怎么用，按照顺序使用，避免让MySQL再自己去翻译一次 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.全值匹配 用到索引c1 c2 c3 c4全字段 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">=</span> <span class="string">&#x27;a3&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">=</span> <span class="string">&#x27;a3&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">=</span> <span class="string">&#x27;a3&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4.用到索引c1 c2 c3字段，c4字段失效，范围之后全失效 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">&gt;</span> <span class="string">&#x27;a3&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5.用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">&gt;</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">AND</span> `c3` <span class="operator">=</span> <span class="string">&#x27;a3&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   6.用到了索引c1 c2 c3三个字段, c1和c2两个字段用于查找,  c3字段用于排序了但是没有统计到key_len中，c4字段失效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c3`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7.用到了索引c1 c2 c3三个字段，c1和c2两个字段用于查找, c3字段用于排序了但是没有统计到key_len中*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c3`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   8.用到了索引c1 c2两个字段，c4失效，c1和c2两个字段用于查找，c4字段排序产生了Using filesort说明排序没有用到c4字段 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c4`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 9.用到了索引c1 c2 c3三个字段，c1用于查找，c2和c3用于排序 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c5` <span class="operator">=</span> <span class="string">&#x27;a5&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c2`, `c3`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 10.用到了c1一个字段，c1用于查找，c3和c2两个字段索引失效，产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c5` <span class="operator">=</span> <span class="string">&#x27;a5&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `c3`, `c2`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 11.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span>  `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c2, c3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 12.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span>  `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c5` <span class="operator">=</span> <span class="string">&#x27;a5&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c2, c3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   13.用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 没有产生Using filesort </span></span><br><span class="line"><span class="comment">      因为之前c2这个字段已经确定了是&#x27;a2&#x27;了，这是一个常量，再去ORDER BY c3,c2 这时候c2已经不用排序了！</span></span><br><span class="line"><span class="comment">      所以没有产生Using filesort 和(10)进行对比学习！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c2` <span class="operator">=</span> <span class="string">&#x27;a2&#x27;</span> <span class="keyword">AND</span> `c5` <span class="operator">=</span> <span class="string">&#x27;a5&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c3, c2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GROUP BY 表面上是叫做分组，但是分组之前必定排序。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 14.用到c1 c2 c3三个字段，c1用于查找，c2 c3用于排序，c4失效 */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> `c2`,`c3`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 15.用到c1这一个字段，c4失效，c2和c3排序失效产生了Using filesort */</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test03` <span class="keyword">WHERE</span> `c1` <span class="operator">=</span> <span class="string">&#x27;a1&#x27;</span> <span class="keyword">AND</span> `c4` <span class="operator">=</span> <span class="string">&#x27;a4&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> `c3`,`c2`;</span><br></pre></td></tr></table></figure>
<p><code>GROUP BY</code>基本上都需要进行排序，索引优化几乎和<code>ORDER BY</code>一致，但是<code>GROUP BY</code>会有临时表的产生。</p>
<h3 id="索引失效的原理分析"><a class="markdownIt-Anchor" href="#索引失效的原理分析"></a> 索引失效的原理分析</h3>
<h3 id="索引失效的总结"><a class="markdownIt-Anchor" href="#索引失效的总结"></a> 索引失效的总结</h3>
<p>索引优化的一般性建议：</p>
<ul>
<li>对于单值索引，尽量选择针对当前<code>query</code>过滤性更好的索引。</li>
<li>在选择复合索引的时候，当前<code>query</code>中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择复合索引的时候，尽量选择可以能够包含当前<code>query</code>中的<code>where</code>子句中更多字段的索引。</li>
<li>尽可能通过分析统计信息和调整<code>query</code>的写法来达到选择合适索引的目的。</li>
</ul>
<h1 id="mysql查询优化"><a class="markdownIt-Anchor" href="#mysql查询优化"></a> MySQL查询优化</h1>
<h2 id="慢查询基础"><a class="markdownIt-Anchor" href="#慢查询基础"></a> 慢查询基础</h2>
<p>索引是如此的重要，以至于我们花费了不小的篇幅来介绍，这对于高性能来说是必不可少的。但这些还不够，还需要合理的设计查询，如果查询写得很糟糕，即使库表结构再合理、索引再合适，也无法实现高性能。查询优化、索引优化、库表结构优化需要多管齐下才能写出高效的SQL。</p>
<p>如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行得更快。</p>
<p>通常来说，查询的生命周期可以按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中“执行”可以认为是生命周期中最重要的阶段，这其中包含了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。</p>
<p>在完成这些任务的时候，查询需要在不同的地方花费时间，包括网络，CPU计算，生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间。根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。</p>
<p>在发生慢查询的时候，要么是某些操作被额外地重复了很多次，要么是某些操作执行得太慢。优化查询的目的就是减少和消除这些操作所花费的时间。</p>
<p>查询性能低下最基本的原因是访问的数据太多，某些查询可能不可避免地需要筛选大量数据，但这并不常见。大部分性能低下的查询都可以通过减少访问数据量的方式进行优化，对于低效的查询，通过如下两个步骤来分析总是非常有效：</p>
<ol>
<li>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列</li>
<li>确认MySQL服务器层是否在分析大量超过需要的数据行</li>
</ol>
<h3 id="请求多余的数据"><a class="markdownIt-Anchor" href="#请求多余的数据"></a> 请求多余的数据</h3>
<p>有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃，这会给MySQL服务器带来额外的负担，并增加网络开销，离国内外i啊也会消耗应用服务器的CPU和内存资源。</p>
<h4 id="查询不需要的记录"><a class="markdownIt-Anchor" href="#查询不需要的记录"></a> 查询不需要的记录</h4>
<p>一个常见的错误是常常会误以为MySQL只会返回需要的数据，实际上MySQL却是先返回全部结果集再进行计算。典型的场景是先使用select语句查询大量的结果，然后获取前面N行后关闭结果集（例如在新闻网站中取出100条记录，但是只是在页面上显示前面10条）。MySQL并不会只查出需要的10条数据，而是会查询出全部的结果集，客户端的应用程序会接收全部的结果集数据，然后抛弃其中的大部分数据。最简单有效的解决方法就是在这样的查询后面加上LIMIT。</p>
<h4 id="多表关联时返回全部列"><a class="markdownIt-Anchor" href="#多表关联时返回全部列"></a> 多表关联时返回全部列</h4>
<p>如果想查询所有在电影Academy Dinosaur中出现的演员，不应该按下面的写法编写查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> </span><br><span class="line">	sakila.actor </span><br><span class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> sakila.film_actor <span class="keyword">USING</span>(actor_id) </span><br><span class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> sakila.film <span class="keyword">USING</span>(film_id) </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">  sakila.film.title <span class="operator">=</span> <span class="string">&#x27;Academy Dinosaur&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这将返回这三表的全部数据列，正确的方式应该像下面这样只取需要的列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sakila.actor.<span class="operator">*</span> <span class="keyword">FROM</span> sakila.actor...;</span><br></pre></td></tr></table></figure>
<h4 id="总是取出全部列"><a class="markdownIt-Anchor" href="#总是取出全部列"></a> 总是取出全部列</h4>
<p>每次看到<code>select *</code>的时候都需要用怀疑的眼光审视，是不是真的需要返回全部的数据？很可能不是必须的。取出全部列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的I/O、内存和CPU的消耗，有时候还能避免某些列被修改带来的问题。</p>
<p>不过，查询返回超过需要的数据也不总是坏事，它可以提高相同代码片段的复用性，如果应用程序使用某种缓存机制，或者有其他考虑，获取超过需要的数据也可能有其好处，但不能忘记这样做的代价是什么。</p>
<h4 id="重复查询相同的数据"><a class="markdownIt-Anchor" href="#重复查询相同的数据"></a> 重复查询相同的数据</h4>
<p>如果不加以小心，很容易出现这样的错误——不断地重复执行相同的查询，然后每次都返回完全相同的数据。例如，在用户评论的地方需要查询用户头像的URL，那么用户多次评论的时候，可能就会反复查询这个数据。比较好的方案是，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样性能显然会更好。</p>
<h3 id="扫描额外的记录"><a class="markdownIt-Anchor" href="#扫描额外的记录"></a> 扫描额外的记录</h3>
<p>在确定查询只返回需要的数据以后，接下来应该看看查询为了返回结果是否扫描了过多的数据。对于MySQL，最简单的衡量查询开销的三个指标如下：</p>
<ul>
<li>响应时间</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<p>没有哪个指标能够完美地衡量查询的开销，但它们大致反映了MySQL在内部执行查询时需要访问多少数据，并可以大概推算出查询运行的时间。这三个指标都会记录到MySQL的慢日志中，所以，检查慢日志记录是找出扫描行数过多的查询的好办法。</p>
<h4 id="响应时间"><a class="markdownIt-Anchor" href="#响应时间"></a> 响应时间</h4>
<p>响应时间是两个部分之和：服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正地执行查询的时间——可能是等I/O操作完成，也可能是等待行锁，等等。遗憾的是，我们无法把响应时间细分到上面这些部分，除非有什么办法能够逐个测量上面这些消耗，不过很难做到。一般常见和重要的是等待是I/O和锁等待，但是实际情况更加复杂。</p>
<p>所以在不同类型的应用压力下，响应时间并没有什么一致的规律或者公示。诸如存储引擎的锁（表锁、行锁）、高并发资源竞争、硬件响应等诸多因素都会影响响应时间。所以，响应时间既可能是一个问题的结果也可能是一个问题的原因，不同案例的情况不同。</p>
<p>当看到一个查询请求的响应时间的时候，应该使用“快速上限估计”法来估算这个时间是否是一个合理的值。“快速上限估计”法概括地说，了解这个查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机I/O，再用其乘以在具体硬件下一次I/O的消耗时间，最后把这些消耗都加起来，就可以获得一个大概参考值来判断当前响应时间是不是一个合理的值。</p>
<h4 id="扫描的行数和返回的行数"><a class="markdownIt-Anchor" href="#扫描的行数和返回的行数"></a> 扫描的行数和返回的行数</h4>
<p>分析查询时，查看该查询扫描的行数是非常有帮助的。这在一定程度上能够说明该查询找到需要的数据的效率高不高。</p>
<p>对于找出那些“糟糕”的查询，这个指标可能还不够完美，因为并不是所有的行的访问代价都是相同的。较短的性的访问速度更快，内存中的行也比磁盘中的行的访问速度要快得多。</p>
<p>理想情况下，扫描的行数和返回的行数应该是相同的。但实际情况中这种“美事”并不多。例如在做一个关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在1:1和10:1之间，不过有时候这个值也可能非常大。</p>
<h4 id="扫描的行数和访问类型"><a class="markdownIt-Anchor" href="#扫描的行数和访问类型"></a> 扫描的行数和访问类型</h4>
<p>在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySQL有好几种访问方式可以查找并返回一行结果。有一些访问方式可能需要扫描很多行才能返回一行结果，也有些访问方式可能无需扫描就能返回结果。</p>
<p>在explain语句中的type列反映了访问类型。访问类型有很多中，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。这里列的这些，速度从慢到快，扫描的行数也从小到大。如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引。索引让MySQL以最高效、扫描行数最少的方式找到需要的记录。</p>
<p>例如，我们在示例数据库Sakila中的一个查询案例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sakila.film_actor <span class="keyword">WHERE</span> film_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这个查询将返回10行数据，从explain的结果可以看到，MySQL在索引idx_fk_film_id上使用了ref访问类型来执行查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sakila.film actor <span class="keyword">WHERE</span> film id <span class="operator">=</span> <span class="number">1</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">roW</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                      id: <span class="number">1</span></span><br><span class="line">             select_type: SIMPLE</span><br><span class="line">                   <span class="keyword">table</span>: film_actor</span><br><span class="line">                    type: <span class="keyword">ref</span></span><br><span class="line">           possible_keys: idx_fk_film_id</span><br><span class="line">                     key: idx_fk_film_id</span><br><span class="line">                 key_len: <span class="number">2</span></span><br><span class="line">                     <span class="keyword">ref</span>: const</span><br><span class="line">                    <span class="keyword">rows</span>: <span class="number">10</span></span><br><span class="line">                   Extra:</span><br></pre></td></tr></table></figure>
<p>explain的结果也显示MySQL预估需要访问10行数据。换言之，查询优化器认为这种访问类型可以高效地完成查询。如果没有合适的索引MySQL就不得不使用一种更糟糕的访问类型。如果我们删除对应的索引再来运行这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sakila.film_actor <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_film_actor_film;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sakila.film_actor <span class="keyword">DROP</span> KEY idx_fk_film_id;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sakila.film_actor <span class="keyword">WHERE</span> film_id <span class="operator">=</span> <span class="number">1</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                    id: <span class="number">1</span></span><br><span class="line">           select_type: SIMPLE</span><br><span class="line">                 <span class="keyword">table</span>: film_actor</span><br><span class="line">                  type: <span class="keyword">ALL</span></span><br><span class="line">         possible_keys: <span class="keyword">NULL</span></span><br><span class="line">                   key: <span class="keyword">NULL</span></span><br><span class="line">               key_len: <span class="keyword">NULL</span></span><br><span class="line">                   <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">                  <span class="keyword">rows</span>: <span class="number">5073</span></span><br><span class="line">                 Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<p>正如我们预测的，访问类型变成了一个全表扫描（ALL），现在MySQL预估需要扫描5073条记录来完成这个查询。这里的“Using Where”表示MySQL将通过WHERE条件来筛选存储引擎返回的记录。</p>
<p>一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：</p>
<ul>
<li>在索引中使用WHERE条件来过滤不匹配的记录。这时存储引擎层完成的</li>
<li>使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无需再回表查询记录</li>
<li>从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤</li>
</ul>
<p>上面的这个例子说明了好的索引多么重要。好的索引可以让查询使用合适的访问类型，尽可能地只扫描需要的数据行。但也不是说增加索引就能让扫描的行数等于返回的行数。例如下面使用聚合函数COUNT（）的查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id, <span class="built_in">COUNT</span> (<span class="operator">*</span>) <span class="keyword">FROM</span> sakila.film_actor <span class="keyword">GROUP</span> <span class="keyword">BY</span> actor_id;</span><br></pre></td></tr></table></figure>
<p>这个查询需要读取几千行数据，但是仅返回200行结果。没有什么索引能够让这样的查询减少需要扫描的行数。</p>
<p>不幸的是，MySQL不会告诉我们生成结果实际上需要扫描多少行数据，而只会告诉我们生成结果时一共扫描了多少行数据。扫描的行数中的大部分都很可能是被WHERE条件过滤掉的，对最终的结果集没有并没有贡献。在上面的例子中，我们删除索引后，看到MySQL需要扫描多少行和实际需要使用的行数需要先去理解这个查询背后的逻辑和思想。</p>
<p>如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧进行优化：</p>
<ul>
<li>使用索引覆盖扫描，把所有需要的列都放到索引中，这样存储引擎无需回表获取对应行就可以返回结果了</li>
<li>改变库表结构，例如使用单独的汇总表</li>
<li>重写这个复杂的查询，让MySQL优化器能够以更优化的方式去执行这个查询</li>
</ul>
<h2 id="重构查询"><a class="markdownIt-Anchor" href="#重构查询"></a> 重构查询</h2>
<h3 id="复杂查询-or-简单查询"><a class="markdownIt-Anchor" href="#复杂查询-or-简单查询"></a> 复杂查询 or 简单查询</h3>
<p>设计查询的时候一个需要考虑的重要问题时，是否需要将一个复杂的查询分成多个简单的查询。在传统的实现中，总是强调需要数据库层完成尽可能多的工作，这样做的逻辑在于以前总是认为网络通信、查询解析和优化是一件代价很高的事情。</p>
<p>但是这样的想法对于MySQL来说并不适用，MySQL从设计上连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效。现代的网络速度比以前要快很多，无论是带宽还是延迟。在某些版本的MySQL上，即使在一个通用服务器上，也能够运行每秒超过10万的查询，即使是一个千兆网卡也能轻松满足每秒超过2000次的查询，所以运行多个小查询现在已经不是大问题了。</p>
<p>MySQL内部每秒能够扫描内存中上百万行的数据，相比之下，MySQL响应数据给客户端就慢得多了。在其他条件都相同的时候，使用尽可能少的查询当然是更好的。但是有时候时候，将一个大查询分解为多个小查询是很有必要的。</p>
<h3 id="切分查询"><a class="markdownIt-Anchor" href="#切分查询"></a> 切分查询</h3>
<p>有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。</p>
<p>删除旧的数据就是一个很好的例子。定期地清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。将一个大的DELETE语句切分成多个较小的查询可以尽可能小地影响MySQL性能，同时还可以减少MySQL复制的延迟。例如，我们需要每个月运行一次下面的查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> created <span class="operator">&lt;</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure>
<p>那么可以用类似下面的方法来完成相同的工作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rows</span> affected <span class="operator">=</span> <span class="number">0</span> do &#123; rows_affected <span class="operator">=</span> do_query(</span><br><span class="line">  &quot;DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(),INTERVAL 3 MONTH).</span><br><span class="line">LIMIT 10000&quot;</span><br><span class="line">) &#125; while rows_affected <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>一次删除一万行数据一般来说时一个比较高效而且对服务器影响也最小的做法（如果是事务型引擎，很多时候小事务能够更高效）。同时，需要注意的是，如果每次删除数据后，都暂停一会儿再做下一次删除，这样也可以将服务器上原本一次性的压力分散到一个很长的时间段中，就可以大大降低对服务器的影响，还可以大大减少删除时锁的持有时间。</p>
<h3 id="分解关联查询"><a class="markdownIt-Anchor" href="#分解关联查询"></a> 分解关联查询</h3>
<p>很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，例如，下面这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">  tag </span><br><span class="line">  <span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id <span class="operator">=</span> tag.id </span><br><span class="line">  <span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id <span class="operator">=</span> post.id</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">  tag.tag <span class="operator">=</span> <span class="string">&#x27;mysql&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>可以分解成下面这些查询来代替：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag <span class="operator">=</span> <span class="string">&#x27;mysql&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">in</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure>
<p>使用分解关联查询的优势如下：</p>
<ul>
<li>让缓存的效率更高。许多应用程序可以方便地缓存单表查询对应的结果对象。例如，上面查询中的tag已经被缓存了，那么应用就可以跳过第一个查询。再例如，应用中已经缓存了ID为123、567、9098的内容，那么第三个查询的IN（）中就可以少几个ID。另外，对MySQL的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了</li>
<li>将查询分解后，执行单个查询可以减少锁的竞争</li>
<li>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展</li>
<li>查询本身效率也可能会有所提升。在这个例子中，使用IN（）代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联要更高效</li>
<li>可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构可能会减少网络和内存的消耗</li>
<li>更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。某些场景哈希关联的效率要高很多</li>
</ul>
<p>在很多场景下，通过重构查询将关联当到应用程序中将会更加高效，这样的场景有很多，比如：当应用能够方便地缓存单个查询结果的时候，当可以将数据分布到不同的MySQL服务器上的时候，当能够使用IN（）的方式来代替关联查询的时候，当查询中使用同一个数据表的时候。</p>
<h2 id="count优化"><a class="markdownIt-Anchor" href="#count优化"></a> count（*）优化</h2>
<p>在实际的开发中，经常可能需要计算一个表中（或部分）的行数，通常可以使用<code>select count(*) from t</code>，但随着系统中记录数的不断增多，这条语句会执行得越来越慢。</p>
<h3 id="count的实现"><a class="markdownIt-Anchor" href="#count的实现"></a> count(*)的实现</h3>
<p>实际上，在不同的MySQL引擎中，count(*)有不同的实现方式：</p>
<ul>
<li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数（如果没有where条件），效率很高</li>
<li>InnoDB引擎在执行count（*）的时候，需要把数据一行一行地从引擎里面读出来后，累积计数，显然，这种方式地效率很低</li>
</ul>
<p>那为什么InnoDB不跟MyISAM一样，也把数字存起来呢？这是因为即使在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的，这里，我们以一个算count（*）的例子来说明，假设表t中现在有10000条记录，并且有三个用户并行的会话：</p>
<ul>
<li>会话A先启动事务并查询一次表的总行数</li>
<li>会话B启动事务，插入一行后记录后，查询表的总行数</li>
<li>会话c先启动一个单独的语句，插入一行记录后，查询表的总行数</li>
</ul>
<p>这里我们假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211211213023.png" alt="image-20211211213023360" /></p>
<p>可以看到，在最后的同一个时刻，三个会话A、B、C会同时查询表t的总行数，但拿到的结果却不同，这和InnoDB的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是MVCC来实现的，每一行记录都要判断自己是否对这个会话可见，因此对于count（*）请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p>
<p>不过，InnoDB对这个语句也做个一定程度的优化，InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于count(*)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的，因此，MySQL优化器会找到最小的那棵树来遍历，在保证逻辑正确的前题下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</p>
<p>也许你想到<code>show table status</code>命令，这个命令的输出结果也有一个TABLE_ROWS用于显示这个表当前有多少行，并且这个命令执行的速度较快，遗憾的是，TABLE_ROWS是通过采样估算的来的，因此只是一个估算值，官方文档显示误差可能达到40%到50%，因此，也无法使用它来进行统计。</p>
<p>那么如果有一个页面经常要显示交易系统的操作记录总数，到底应该怎么办呢？答案是，只能自己计数，接下来，我们将会讨论自己计数的方法，以及每种方法优缺点。</p>
<h3 id="使用缓存系统保存计数"><a class="markdownIt-Anchor" href="#使用缓存系统保存计数"></a> 使用缓存系统保存计数</h3>
<p>对常见的做法就是使用缓存，可以使用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。这种方式的缺点就在于，缓存系统可能会丢失更新。Redis的数据不能永久地留在内存中，所以需要找一个地方把这个值定期地持久化存储起来，但即使这样，仍然可能丢失更新，如果刚刚在数据表中插入了一行，Redis中保存的值也加了1，然后Redis异常重启了，重启后需要从存储Redis数据的地方把这个值读回来，而刚刚加1的这个计数操作却丢失了。</p>
<p>实际上，将计数保存在缓存系统中的方式，还不只是丢失更新的问题，即使Redis正常工作，这个值还是逻辑上不精确的。</p>
<h3 id="在数据库中保存计数"><a class="markdownIt-Anchor" href="#在数据库中保存计数"></a> 在数据库中保存计数</h3>
<h3 id="不同count的用法"><a class="markdownIt-Anchor" href="#不同count的用法"></a> 不同count的用法</h3>
<p>count（）是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加，最后返回累计值，所以count（*）、count（主键id）和count（1）都表示返回满足条件的结果集的总行数，而count（字段）,则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。</p>
<p>对于count（主键id）来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层，server层拿到id后，判断是不可能为空的，就按行累加；对于count（1）来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。相比较而言，count（1）执行得要比count（主键id）快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。</p>
<div class="note info"><p>虽然主键id一定不为空，但InnoDB并没有做相关的优化。</p></div>
<p>对于count（字段）来说：</p>
<ul>
<li>如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加</li>
<li>如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断以下，不是null才累加</li>
</ul>
<p>这些不同的方式按照效率排序：count（字段）&lt; count（主键id） &lt; count（1） ≈ count（*）。</p>
<h2 id="join语句的优化"><a class="markdownIt-Anchor" href="#join语句的优化"></a> join语句的优化</h2>
<p>在实际生产中，关于join语句使用的问题，一般会几种在以下两类：</p>
<ul>
<li>DBA不让使用join，使用join有什么问题？</li>
<li>如果有两个大小不同的表做join，应该用哪个表做驱动表？</li>
</ul>
<p>为了便于量化分析，我们创建两个表t1和t2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t2` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`), </span><br><span class="line">  KEY `a` (`a`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB; </span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> </span><br><span class="line">  <span class="keyword">procedure</span> idata; delimiter;; <span class="keyword">create</span> <span class="keyword">procedure</span> idata() <span class="keyword">begin</span> <span class="keyword">declare</span> i <span class="type">int</span>; </span><br><span class="line"><span class="keyword">set</span> </span><br><span class="line">  i <span class="operator">=</span> <span class="number">1</span>; while(i <span class="operator">&lt;=</span> <span class="number">1000</span>) do <span class="keyword">insert</span> <span class="keyword">into</span> t2 </span><br><span class="line"><span class="keyword">values</span> </span><br><span class="line">  (i, i, i); </span><br><span class="line"><span class="keyword">set</span> </span><br><span class="line">  i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; <span class="keyword">end</span> while; <span class="keyword">end</span>;; delimiter; <span class="keyword">call</span> idata(); </span><br><span class="line">  </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">like</span> t2; </span><br><span class="line">  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>这两张表都有一个主键索引id和一个索引a，字段b上无索引。存储过程idata()往表t2里面插入了1000行数据，在表t1插入的是100行数据。</p>
<h3 id="index-nested-loop-join"><a class="markdownIt-Anchor" href="#index-nested-loop-join"></a> Index Nested-Loop Join</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.a);</span><br></pre></td></tr></table></figure>
<p>如果直接使用join语句，MySQL优化器可能会选择表t1或t2作为驱动表，这样会影响我们分析SQL语句的执行过程，使用straight_join可以让MySQL使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去join，在这个语句里，t1是驱动表，t2是被驱动表，explain的结果如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211215235731.png" alt="image-20211215235731451" /></p>
<p>可以看到，在这条语句里，被驱动表t2的字段上有索引，join过程用上了这个索引，因此这个语句的执行流程如下：</p>
<ol>
<li>从表t1中读入一行数据R</li>
<li>从数据行R中，取出字段到表t2里去查找</li>
<li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分</li>
<li>重复执行步骤1到3，直到表t1的末尾循环结束</li>
</ol>
<p>这个过程是现遍历表t1，然后根据从表t1中取出的每行数据中a的值，去表t2查找满足条件的记录，在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“Index Nested-Loop Join”，简称NLJ。对应的流程图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211216233223.png" alt="image-20211216233222986" style="zoom:67%;" />
<p>在这个流程里：</p>
<ol>
<li>对驱动表t1做了全表扫描，这个过程需要扫描100行</li>
<li>对于每一行R，根据a字段去表t2查找，走的是树搜索过程，由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也就是总共扫描100行</li>
<li>所以，整个执行流程，总扫描行数是200</li>
</ol>
<p>假设不使用join，那我们就只能用单表查询，要实现上述相同的需求，使用单表查询需要：</p>
<ol>
<li>执行<code>select * from t1</code>，查出表t1的所有数据，这里有100行</li>
<li>循环遍历这100行数据
<ul>
<li>从每一行R取出字段a的值$R.a</li>
<li>执行<code>select * from where a = $R.a</code></li>
<li>把返回的结果和R构成结果集的一行</li>
</ul>
</li>
</ol>
<p>可以看到，在这个查询过程，也就是扫描了200行，但是总共执行了101条语句，比直接join多了100次交互，除此之外，客户端还要自己拼接SQL语句和结果，那么显然，这么做不如直接join。</p>
<p>在这个join语句的执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索，假设被驱动表的行数是M，每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引，每次搜索一棵树近似复杂度是以2为底的M的对数，记为log<sub>2</sub>M，所以在被驱动表上查一行的时间复杂度是2*log<sub>2</sub>M。假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次，因此整个执行过程，时间复杂度近似是N+N*2log<sub>2</sub>M，显然，N对扫描行数影响更大，因此应该让小表做驱动表。</p>
<p>通过以上的分析，我们可以得到两个结论：</p>
<ol>
<li>使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好</li>
<li>如果使用join语句的话，需要让小表做驱动表</li>
</ol>
<h3 id="simple-nested-loop-join"><a class="markdownIt-Anchor" href="#simple-nested-loop-join"></a> Simple Nested-Loop Join</h3>
<p>现在，我们将SQL语句修改如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a <span class="operator">=</span> t2.b);</span><br></pre></td></tr></table></figure>
<p>由于表t2的字段上没有索引，因此在join的时候，每次到t2做一次匹配，就要做一次全表扫描，这种算法就被称为“Simple Nested-Loop Join”。虽然也可以得到正确的结果，但是这个SQL请求需要扫描表t2多达100次，总共扫描100*1000=10万行。如果t1和t2都是10万行的表，就需要扫描100亿行，不难想象，这个语句的执行将会非常耗时。MySQL并没有使用Simple Nested-Loop Join算法，而是使用了另一个叫做“Block Nested-Loop Join”的算法，简称BNL。</p>
<h3 id="block-nested-loop-join"><a class="markdownIt-Anchor" href="#block-nested-loop-join"></a> Block Nested-Loop Join</h3>
<p>BNL的执行流程如下：</p>
<ol>
<li>将表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是<code>select *</code>，因此是把整个表t1放入了内存</li>
<li>扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回</li>
</ol>
<p>流程图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211219110609.png" alt="image-20211219110609522" style="zoom:67%;" />
<p>explain的结果如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211219110725.png" alt="image-20211219110725871" /></p>
<p>可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做判断的次数是100*1000=10万次。</p>
<p>从时间复杂度上来看，Simple Nested-Loop Join和Block Nested-Loop Join算法是相同的，但是BNL算法的这10万次判断是内存操作，速度会快上很多，性能也更好。</p>
<p>那么在这种情况下，应该使用哪个表做驱动表呢？假设小表的行数是N，大表的行数是M，那么在这个算法里：</p>
<ol>
<li>两个表都做一次全表扫描，所以总的扫描行数是M+N</li>
<li>内存中的判断次数是M*N</li>
</ol>
<p>可以看到，调换M和N的位置，并不会影响这个算法的时间复杂度，因此这个时候选择大表或者小表做驱动表，执行耗时都是一样的。</p>
<p>这个算法会将t1表的内容放入到join_buffer中，join_buffer的大小是由参数join_buffer_size设定的，默认值是256k。如果放不下表t1的所有数据的话，就会分段放置。现在我们将join_buffer_size改小，再执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.b);</span><br></pre></td></tr></table></figure>
<p>此时，执行流程就变成了：</p>
<ol>
<li>扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步</li>
<li>扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回</li>
<li>清空join_buffer</li>
<li>继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第二步</li>
</ol>
<p>执行的流程图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211219113254.png" alt="image-20211219113254308" style="zoom: 67%;" />
<p>图中的步骤4和5表示清空join_buffer复用，这也体现出了这个算法名字中“Block”的由来，表示“分块去join”。由于表t1被分成了两次放入join_buffer中，导致表t2会被扫描两次，虽然分成两次放入join_buffer，但是判断等值条件的次数还是不变的，依然是（88+12）*1000=10万次。</p>
<p>在这个算法里，驱动表的数据行数是N，需要分k段才能完成算法流程，其中<code>K=λN（λ∈（0,1））</code>，被驱动表的数据行数是M：</p>
<ol>
<li>扫描行数是N+λ*N*M</li>
<li>内存判断是N*M次</li>
</ol>
<p>显然，内存判断次数是不受选择哪个表作为驱动表影响的，而考虑到扫描行数，在M和N大小确定的情况下，N小一些，整个算式的结果会更小，所以在这种算法下，应该让小表当驱动表。</p>
<p>在N+λ*N*M中，还有一个关键的参数λ，可以看到λ越小越好，由定义，我们可以知道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi><mo>=</mo><mi>K</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">λ=K/N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，那么显然，在N确定的情况下，K越小越好，也就是说，当join_buffer_size越大的时候，分成的段数也就越少，对被驱动表的全表扫描次数就越少。</p>
<div class="note info"><p>以上结论告诉我们，如果join语句很慢，可以尝试将join_buffer_size改大。</p></div>
<p>我们回到本小节一开始的两个问题：</p>
<ol>
<li>能不能使用join语句？</li>
<li>如果使用join语句，应该选择大表做驱动表还是选择小表做驱动表？</li>
</ol>
<p>对于第一个问题：</p>
<ul>
<li>如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，就可以用上被驱动表上的索引，其实是没问题的</li>
<li>如果使用Block Nested-Loop Join算法，扫描行数就会过多，尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源，所以这种join尽量不要使用</li>
</ul>
<p>因此，在判断要不要使用join语句时，就是看explain的结果里面，extra字段里面有没有出现“Block Nested Loop”字样。</p>
<p>对于第二个问题：</p>
<ul>
<li>如果是Index Nested-Loop Join算法，应该选择小表做驱动表</li>
<li>如果是Block Nested-Loop Join算法：
<ul>
<li>在join_buffer_size足够大的时候，是一样的</li>
<li>在join_buffer_size不够大的时候（这种情况更为常见），应该选择小表做驱动表</li>
</ul>
</li>
</ul>
<p>所以，这个问题的结论是，应该选择小表做驱动表。不过需要格外说明的是，在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</p>
<h3 id="multi-range-read-优化"><a class="markdownIt-Anchor" href="#multi-range-read-优化"></a> Multi-Range Read 优化</h3>
<p>NLJ和BNL都还有优化的空间，为了说明这一点，创建表t1和t2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(</span><br><span class="line">  id <span class="type">int</span> <span class="keyword">primary</span> key, </span><br><span class="line">  a <span class="type">int</span>, </span><br><span class="line">  b <span class="type">int</span>, </span><br><span class="line">  index(a)</span><br><span class="line">); </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1; </span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> idata; delimiter;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata() <span class="keyword">begin</span> <span class="keyword">declare</span> i <span class="type">int</span>; </span><br><span class="line"><span class="keyword">set</span> </span><br><span class="line">  i <span class="operator">=</span> <span class="number">1</span>; while(i <span class="operator">&lt;=</span> <span class="number">1000</span>) do <span class="keyword">insert</span> <span class="keyword">into</span> t1 </span><br><span class="line"><span class="keyword">values</span> </span><br><span class="line">  (i, <span class="number">1001</span> <span class="operator">-</span> i, i); </span><br><span class="line"><span class="keyword">set</span> </span><br><span class="line">  i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; <span class="keyword">end</span> while; </span><br><span class="line"><span class="keyword">set</span> </span><br><span class="line">  i <span class="operator">=</span> <span class="number">1</span>; while(i <span class="operator">&lt;=</span> <span class="number">1000000</span>) do <span class="keyword">insert</span> <span class="keyword">into</span> t2 </span><br><span class="line"><span class="keyword">values</span> </span><br><span class="line">  (i, i, i); </span><br><span class="line"><span class="keyword">set</span> </span><br><span class="line">  i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; <span class="keyword">end</span> while; <span class="keyword">end</span>;; delimiter; <span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<p>在表t1里，插入了1000行数据，每一行的<code>a=1001-id</code>的值。也就是说，表t1中字段a是逆序的，同时，在表t2中插入了100万行数据。</p>
<p>Multi-Range Read优化的主要目的是尽量使用顺序读盘。回表是指，InnoDB在普通索引a上查到主键id的值后，再根据一个个主键id的值到主键索引上去查整行数据的过程。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> a <span class="operator">&lt;=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>由于主键索引是一颗B+树，在这棵树上，每次只能根据一个主键id查到一行数据。因此，回表肯定是一行行搜索主键索引的，基本流程如图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211219225104.png" alt="image-20211219225104477" style="zoom:67%;" />
<p>如果随着a的值递增顺序查询的话，id的值就变成随机的，那么就会出现随机访问，性能相对较差。虽然还是按行查，但是可以通过调整查询的顺序，还是可以加速查询的效率，因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。这就是MRR优化的设计思路，此时语句的执行流程就变成了这样：</p>
<ol>
<li>根据索引a，定位到满足条件的记录，将id值放入read_rnd_buffer中</li>
<li>将read_rnd_buffer中的id进行递增排序</li>
<li>排序后的id数组，依次到主键id索引中查记录，并作为结果返回</li>
</ol>
<p>这里，read_rnd_buffer的大小是由read_rnd_buffer参数控制的。如果步骤1中，read_rnd_buffer放满了，就会执行步骤2和3，然后清空read_rnd_buffer，之后继续找索引a的下个记录，并继续循环。</p>
<div class="note info"><p>如果想要稳定地使用MRR优化的话，需要设置`set optimizer_switch="mrr_cost_based=off"`，因为目前的优化器会更倾向于不使用MRR，通过这个设置就可以保证一定可以使用MRR优化。</p></div>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211219230645.png" alt="image-20211219230645249" style="zoom:67%;" />
<p>explain的结果：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211219230712.png" alt="image-20211219230712320" /></p>
<p>从explain的结果来看，Extra字段多了Using MRR，表示的是用上了MRR优化，而且，由于我们在read_md_buffer中按照id做了排序，所以最后得到的结果集也是按照主键id递增顺序的，与没有适用MRR的结果集顺序刚好相反。</p>
<p>总而言之，MRR能够提升性能的核心在于，这条查询语句在索引a上是一个范围查询（也就是说，这是一个多指查询），可以得到足够多的主键id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。</p>
<h3 id="batched-key-access"><a class="markdownIt-Anchor" href="#batched-key-access"></a> Batched Key Access</h3>
<p>MySQL在5.6版本后开始引入了Batched Key Acess（BKA）算法，这个算法其实就是对NLJ算法的优化。首先我们来回顾一下NLJ算法的执行流程：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211219232052.png" alt="image-20211219232052731" style="zoom:67%;" />
<p>NLJ算法执行的逻辑是：从驱动表t1，一行行地取出a的值，再到被驱动表t2去做join。也就是说，对于表t2来说，每次都是匹配一个值，这时，MRR的优势就用不上了。那怎么才能一次性地多穿些值给表t2呢？从表t1里一次性地多拿些出来，放入到join_buffer，然后一起传给表t2，这就是BKA算法，简而言之，使用join_buffer优化的NLJ算法就是BKA算法，算法的流程图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211219235052.png" alt="image-20211219235052154" style="zoom:67%;" />
<p>图中，join_buffer中放入的数据是R1~R100，表示的是只会取查询需要的字段，如果join_buffer放不下 R1~R100 的所有数据，就会把这100行数据分成多段执行上图的流程。BKA算法并没有默认开启，如果要使用BKA优化算法的话，需要在执行SQL语句之前，先设置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>其中，前两个参数的作用是启用MRR，这么做的原因是，BKA算法的优化要依赖于MRR。</p>
<h3 id="bnl算法的性能问题"><a class="markdownIt-Anchor" href="#bnl算法的性能问题"></a> BNL算法的性能问题</h3>
<p>BNL可能会对被驱动表做多次扫描，如果这个被驱动表是一个大的冷数据表，除了会导致IO压力大以外，还会对系统有什么影响呢？</p>
<p>由于InnoDB对Buffer Pool的LRU算法做了优化，即：第一次从磁盘读入内存的数据页，会先放在old区域。如果1秒之后这个数据也不再被访问了，就不会移动到LRU链表头部，这样对Buffer Pool的命中率影响就不大。但是，如果这个冷表很大，就会出现另外一种情况：业务正常访问的数据页，没有机会进入young区域。</p>
<p>由于这个优化机制的存在，一个正常访问的数据页，要进入young区域，需要隔1秒后再次被访问到。但是，由于我们的join语句在循环读磁盘和淘汰内存页，进入old区域的数据页，很可能在1秒内就被淘汰了。这样，就会导致MySQL实例的Buffer Pool在这段时间内，young区域的数据页没有被合理地淘汰，也就是说，这两种情况都会影响Buffer Pool的正常运作。</p>
<p>BNL算法对系统的影响主要包括三个方面：</p>
<ol>
<li>可能会多次扫描被驱动表，占用磁盘IO资源</li>
<li>判断join条件需要执行M*N次对比（M、N分别是两张表的行数），如果是大表就会占用非常多的CPU资源</li>
<li>可能会导致Buffer Pool的热数据被淘汰，影响内存命中率</li>
</ol>
<p>因此，我们在执行语句之前，需要通过理论分析和查看explain结果的方式，确认是否使用BNL算法。如果确认优化器会使用BNL算法，就需要做优化。优化的常见做法是，给被驱动表的join字段加上索引，把BNL算法转成BKA算法。</p>
<h3 id="bnl转bka"><a class="markdownIt-Anchor" href="#bnl转bka"></a> BNL转BKA</h3>
<p>大多数情况下，我们直接在被驱动表上建立索引，就可以直接转为BKA算法了，但是也有一些并不适合在被驱动表上建索引的情况，比如下面这个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> (t1.b <span class="operator">=</span> t2.b) <span class="keyword">where</span> t2.b <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> t2.b <span class="operator">&lt;=</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure>
<p>此时，如果BNL算法来join的话，语句的执行流程如下：</p>
<ol>
<li>把表t1的所有字段取出来，存入join_buffer中，这个表只有1000行，join_buffer_size默认值是256k，可以完全存入</li>
<li>扫描表t2，取出每一行数据跟join_buffer中的数据进行对比：
<ul>
<li>如果不满足<code>t1.b = t2.b</code></li>
<li>如果满足<code>t1.b = t2.b</code>，再判断其它条件，也就是是否满足<code>t2.b∈[1,2000]</code>，如果是，就作为结果集的一部分返回，否则跳过</li>
</ul>
</li>
</ol>
<p>explain的结果如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211221000258.png" alt="image-20211221000258809" /></p>
<p>可以发现，判断join是否满足的时候，会扫描表t2的每一行，判断条件的次数是1000*100万=10亿次，这个判断的工作量很大。但是经过where条件过滤后，需要参与join的实际上只有2000行数据。如果这条语句是一个低频的SQL语句，那么再为这个语句在表t2的字段b上创建一个索引就很浪费了。</p>
<p>在表t2的字段b上创建索引会浪费资源，但是不创建索引的话需要判断10亿次，这个时候就可以考虑使用临时表，使用临时表的步骤如下：</p>
<ol>
<li>将表t2中满足条件的数据放在临时表tmp_t中</li>
<li>为了让join使用BKA算法，给临时表tmp_t的字段b加上索引</li>
<li>让表t1和tmp_t做join操作</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(b))engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b<span class="operator">=</span>temp_t.b);</span><br></pre></td></tr></table></figure>
<p>执行的流程如下：</p>
<ol>
<li>执行insert语句构造temp_t表并插入数据的过程中，对表t2做了全表扫描，这里扫描的行数是100万</li>
<li>之后的join语句，扫描表t1，这里的扫描行数是1000，join比较过程中，做了1000次带索引的查询，相比于优化前的join语句需要做10亿次条件判断来说，这个优化效果还是很明显的</li>
</ol>
<p>执行的效果如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211221000900.png" alt="image-20211221000900031" style="zoom:67%;" />
<p>总体来看，不论是在原表上加索引，还是用有索引的临时表，我们的思路都是让join语句能够用上被驱动表上的索引，来触发BKA算法，提升查询性能。</p>
<h3 id="hash-join"><a class="markdownIt-Anchor" href="#hash-join"></a> hash join</h3>
<p>在之前的例子中，之所以要有计算10亿次的操作，是因为在join_buffer里面维护的是一个无序数组，而不是一个哈希表，如果能够将无序数组替换为哈希表，这样只需要100万次的哈希查找，整条语句的执行速度就可以加快，但MySQL的优化器和执行器并不支持哈希join。不过，我们可以按照这个思路，在业务端实现：</p>
<ol>
<li><code>select * from t1;</code>，取得表t1的全部1000行数据，在业务端存入到哈希这种数据结构的实现，比如HashMap</li>
<li><code>select * from t2 where b &gt;= 1 and b &lt;= 2000;</code>，获取表t2中满足条件的2000行数据</li>
<li>把这2000行数据，一行行地取到业务端，到哈希表中寻找匹配的数据，满足匹配的条件的这行数据，就作为结果集的一行</li>
</ol>
<h2 id="mysql中的临时表"><a class="markdownIt-Anchor" href="#mysql中的临时表"></a> MySQL中的临时表</h2>
<p>在join语句优化的章节中，我们使用了临时表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t <span class="keyword">like</span> t1;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> temp_t <span class="keyword">add</span> index(b);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> b <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">&lt;=</span> <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b <span class="operator">=</span> temp_t.b);</span><br></pre></td></tr></table></figure>
<p>与临时表相类似的还有内存表，实际上这两个概念是完全不同的。</p>
<ul>
<li>内存表，指的是使用Memory引擎的表，建表语法是<code>create table ...engine = memory</code>。这种表的数据都保存在内存里，系统重启的时候就会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”，从其它特征上看，它就是一个正常表</li>
<li>而临时表，可以使用各种引擎类型（包括Memory引擎），如果使用InnDB引擎或者MyISAM引擎的临时表，写数据的时候是写到磁盘上的</li>
</ul>
<h3 id="临时表的特性"><a class="markdownIt-Anchor" href="#临时表的特性"></a> 临时表的特性</h3>
<p>以下列操作序列为例：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211221234203.png" alt="image-20211221234203605" style="zoom:67%;" />
<p>可以看到，临时表有以下几个特点：</p>
<ol>
<li>建表语法是<code>create temporary table..</code></li>
<li>一个临时表只能被创建它的session访问，对其它线程不可见，所以，图中session A创建的临时表t，对于session B就是不可见的</li>
<li>临时表可以与普通表同名</li>
<li>session A内有同名的临时表和普通表的时候，<code>show create</code>语句，以及增删改查语句访问的是临时表</li>
<li><code>show tables</code>命令不显示临时表</li>
</ol>
<p>由于临时表只能被创建它的session访问，所以在这个session结束的时候，会自动删除临时表，也正是由于这个特性，临时表特别适合join优化的场景，理由如下：</p>
<ul>
<li>不同session的临时表是可以重名的，如果有多个session同时执行join优化，无需担心表名重复导致建表失败的问题</li>
<li>不需要担心数据删除问题。如果使用普通表，在执行流程过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作</li>
</ul>
<h3 id="临时表的应用"><a class="markdownIt-Anchor" href="#临时表的应用"></a> 临时表的应用</h3>
<p>由于不同担心线程之间的重名冲突，临时表经常会被用在复杂查询优化过程中，其中，分库分表系统的跨库查询就是一个典型的使用场景。</p>
<p>一般分库分表的场景，就是要把一个逻辑上的大表分散到不同的数据库实例上。比如，将一个大表ht，按照字段f，拆分成1024个分表，然后分布到32个数据库实例上，如下图所示：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211222000035.png" alt="image-20211222000035457" /></p>
<p>一般情况下，这种分库分表系统都有一个中间层proxy，不过，也有一些方案会让客户端直接连接数据，也就是没有proxy这一层。在这个架构中，分区key的选择是以“减少跨库和跨表查询”为依据的。如果大部分的语句都会包含f的等值条件，那么就要用f做分区键。这样，在proxy这一层解析完SQL语句以后，就能确定将这条语句到哪个分表做查询。</p>
<p>以下面的查询语句为例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> v <span class="keyword">from</span> ht <span class="keyword">where</span> f<span class="operator">=</span>N;</span><br></pre></td></tr></table></figure>
<p>这时，我们就可以通过分表规则（比如N%1024）来确认需要的数据被放在哪个分表上，这种语句只需要访问一个分表。但是，如果这个表上还有另外一个索引k，并且查询语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> v <span class="keyword">from</span> ht <span class="keyword">where</span> k <span class="operator">&gt;=</span> M <span class="keyword">order</span> <span class="keyword">by</span> t_modified <span class="keyword">desc</span> limit <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>这个时候，由于查询条件里面没有用到分区字段f，只能到所有的分区中去查找满足条件的所有行，然后统一进行排序，这种情况下，有两种比较常用的思路。</p>
<p>第一种思路是在proxy层的进程代码中实现排序。这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算，不过，这个方案的缺点也很明显：</p>
<ol>
<li>需要的开发工作量比较大。如果仅需要order by还比较简单，但是，如果涉及到复杂的操作，比如group by，甚至join这样的操作，对中间层的开发能力要求比较高</li>
<li>对proxy端的压力比较大，尤其是很容易出现内存不够用和CPU瓶颈的问题</li>
</ol>
<p>第二种思路是，将各个分库拿到的数据，汇总到一个MySQL实例的一个表中，然后在这个汇总实例上做逻辑操作，以上这条查询语句的执行流程如下：</p>
<ul>
<li>在汇总库上创建一个临时表temp_ht，表中包含三个字段v、t、t_modified</li>
<li>在各个分库上执行<code>select v,k,t_modified from ht_x where k &gt;= M order by t_modified desc limit 100;</code></li>
<li>将分库执行的结果插入到temp_ht表中</li>
<li>执行<code>select v from temp_ht order by t_modified desc limit 100;</code>就可以得到结果</li>
</ul>
<p>第二种思路的示意图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226130032.png" alt="image-20211226130031919" style="zoom:67%;" />
<div class="note info"><p>实践中，由于每个分库的计算量都不饱和，所以会直接把临时表temp_ht放到32个分库中的某一个上。</p></div>
<h3 id="重命名临时表"><a class="markdownIt-Anchor" href="#重命名临时表"></a> 重命名临时表</h3>
<p>上文我们总结临时表的特性，发现不同线程可以创建同名的临时表，那么这是怎么做到的呢？</p>
<p>假设我们执行如下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key)engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure>
<p>这个时候，MySQL要给这个InnoDB表创建一个frm文件保存表结构定义，还要有地方保存表数据，这个frm文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程id}_{线程id}_序列号”，可以使用<code>select @@tmpdir</code>命令，来显示实例的临时文件目录。</p>
<p>关于临时表中数据的存放方式，在不同的MySQL版本中有着不同的处理方式：</p>
<ul>
<li>在5.6以及之前的版本里，MySQL会在临时文件目录下创建一个相同前缀、以.ibd为后缀的文件，用来存放数据文件</li>
<li>而从5.7版本开始，MySQL引入了一个临时文件表空间，专门用来存放临时文件的数据，而无需再创建idb文件</li>
</ul>
<p>示例如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226131704.png" alt="image-20211226131648061" style="zoom:67%;" />
<p>这个进程的进程号是4d2，session A的线程id是4，session B的线程id是5，所以，session A和 session B创建的临时表，在磁盘上的文件不会重名。</p>
<p>MySQL维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个table_def_key。</p>
<ul>
<li>一个普通表的table_def_key的值是由“库名+表名”得到的，所以如果要在同一个库下创建两个同名的临时表，创建第二表的过程中就会发现table_def_key已经存在了</li>
<li>而对于临时表，table_def_key在“库名+表名”的基础上，又加入了“server_id + thread_id”，也就是说，session A和session B创建的两个临时表t1，它们的table_def_key不同，磁盘文件名也不同，因此可以并存。</li>
</ul>
<p>在实现上，每个线程都维护了自己的临时表链表。这样，每次session内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表，在sessoin结束的时候，对链表里的每个临时表，执行“DROP TEMPARY TABLE + 表名”操作。</p>
<h3 id="临时表和主备复制"><a class="markdownIt-Anchor" href="#临时表和主备复制"></a> 临时表和主备复制</h3>
<p>临时表只能在线程内自己访问，但在执行<code>DROP TEMPARY TABLE</code>命令的时候，也会将其记录到binlog中，写入到binlog中的目的是为了主备复制。为了说明这一点，假设我们执行如下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_normal(id <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>)engine<span class="operator">=</span>innodb;<span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t <span class="keyword">like</span> t_normal;<span class="comment">/*Q2*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">/*Q3*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_normal <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp_t;<span class="comment">/*Q4*/</span></span><br></pre></td></tr></table></figure>
<p>如果关于临时表的操作都不记录，那么在备库就只有<code>create table t_normal</code>和<code>insert into t_normal select * from temp_t</code>这两个语句的binlog日志，备库在执行到<code>insert into t_normal</code>的时候，就会报错“表temp_t不存在”。</p>
<p>实际上可以通过设置参数<code>binlog_format=row</code>,那么与临时表有关的语句，就不会记录到binlog里。当参数设置为<code>binlog_format=statment/mixedde</code>的时候，binlog才会记录临时表的操作。</p>
<p>当binlog是row格式的时候，创建临时表的语句会自动在备库执行，主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，需要在主库上再写一个<code>DROP TEMPARY TABLE</code>传给备库执行，这就是这个命令会什么会出现在binlog的原因。</p>
<p>通常情况下，MySQL在记录binlog的时候，都会将SQL语句原封不动的记录下来，但是如果执行<code>drop table_normal</code>，此时binlog会被记录成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> `t_normal` <span class="comment">/* generated by server */</span></span><br></pre></td></tr></table></figure>
<p>这是因为，<code>drop table</code>是可以一次删除多个表的。在以上的例子中，设置binlog_format=row，如果主库上执行“drop table t_normal, temp_t”这个命令，那么binlog中就只能记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> `t_normal` <span class="comment">/* generated by server */</span></span><br></pre></td></tr></table></figure>
<p>因为备库上并没有表tmp_t，将这个命令重写后再传到备库执行，才不会备库同步线程停止。所以，<code>drop table</code>命令记录binlog的时候，就必须对语句做改写， “/* generated by server */” 说明了这是一个被服务端改写过的命令。</p>
<p>主库上不同的线程创建同名的临时表是没有关系的，但是传到备库执行时如何处理的呢？下面的序列中实例S是M的备库：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226182104.png" alt="image-20211226182104322" style="zoom:67%;" />
<p>主库M上的两个session创建了同名的临时表t1，这两个<code>create temporary table t1</code>语句都会被传到备库S上，但是，备库的应用日志线程是共用的，也就是说要在应用线程里面先后执行这个create语句两次。（即使开了多线程复制，也可能被分配到从库的同一个worker中执行），如果直接执行，那么显然可能会出现冲突。MySQL在记录binlog的时候，会把主库执行的这个语句的线程id写到binlog中，这样，在备库的应用线程就能够知道执行每个语句的主库线程id，并利用这个线程id来构造临时表的table_def_key，具体流程下：</p>
<ol>
<li>session A的临时表t1，在备库的table_def_key就是：库名+t1+“M的serverid” + “session A的thread_id”</li>
<li>session B的临时表t1，在备库的table_def_key就是：库名+t1+“M的serverid” + “session B的thread_id”</li>
</ol>
<p>由于table_def_key不同，所以这两个表在备库的应用线程里不会冲突。</p>
<h3 id="使用临时表优化查询"><a class="markdownIt-Anchor" href="#使用临时表优化查询"></a> 使用临时表优化查询</h3>
<p>union的执行就会使用临时表来完成，为了便于量化分析，我用下面的表 t1 来举例。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(</span><br><span class="line">  id <span class="type">int</span> <span class="keyword">primary</span> key, </span><br><span class="line">  a <span class="type">int</span>, </span><br><span class="line">  b <span class="type">int</span>, </span><br><span class="line">  index(a)</span><br><span class="line">); </span><br><span class="line"></span><br><span class="line">delimiter;; </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata() <span class="keyword">begin</span> <span class="keyword">declare</span> i <span class="type">int</span>; </span><br><span class="line"><span class="keyword">set</span> </span><br><span class="line">  i <span class="operator">=</span> <span class="number">1</span>; while(i <span class="operator">&lt;=</span> <span class="number">1000</span>) do <span class="keyword">insert</span> <span class="keyword">into</span> t1 </span><br><span class="line"><span class="keyword">values</span> </span><br><span class="line">  (i, i, i); </span><br><span class="line"><span class="keyword">set</span> </span><br><span class="line">  i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; <span class="keyword">end</span> while; <span class="keyword">end</span>;; </span><br><span class="line">delimiter; </span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<p>然后，我们执行如下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> <span class="number">1000</span> <span class="keyword">as</span> f) <span class="keyword">union</span> (<span class="keyword">select</span> id <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> limit <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这条语句用到了union，它的语义是，取这两个子查询结果的并集，下面是这个语句explain的结果：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226185633.png" alt="image-20211226185633150" /></p>
<p>可以看到：</p>
<ul>
<li>第二行的key=PRIMARY，说明第二个子句用到了索引id</li>
<li>第三行的Extra字段，表示在对子查询的结果做UNION的时候，使用了临时表（Using temporary）。</li>
</ul>
<p>这个语句的执行流程如下：</p>
<ol>
<li>创建一个内存临时表，这个临时表只有一个整型字段f，并且f是主键字段</li>
<li>执行第一个子查询，得到1000这个值，并存入临时表中</li>
<li>执行第二个子查询：
<ul>
<li>拿到第一行id=1000，试图插入临时表中，但由于1000这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行</li>
<li>取到第二行id=999，插入临时表成功</li>
</ul>
</li>
<li>从临时表按行取数据，返回结果，并删除临时表，结果中包含两行数据分别是1000和999</li>
</ol>
<p>这个过程的示意图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226190524.png" alt="image-20211226190524454" style="zoom:67%;" />
<p>可以看到，这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键id的唯一性约束，实现了union的语义。如果将这个语句中的union改成union all的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端，因此也就不需要临时表了。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226190855.png" alt="image-20211226190854967" /></p>
<p>可以看到，第二行的Extra字段显示的是Using index，表示只使用了覆盖索引，没有用临时表了。</p>
<h2 id="group-by语句的优化"><a class="markdownIt-Anchor" href="#group-by语句的优化"></a> group by语句的优化</h2>
<h3 id="group-by执行流程"><a class="markdownIt-Anchor" href="#group-by执行流程"></a> group by执行流程</h3>
<p>还是使用表t1执行如下SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="operator">%</span> <span class="number">10</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure>
<p>这个语句的逻辑是把表t1里的数据，按照id%10进行分组统计，并按照m的结果排序后输出，它的explain结果如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226191521.png" alt="image-20211226191521497" /></p>
<p>在Extra字段里面，我们可以看到：</p>
<ul>
<li>Using index，表示这个语句使用了覆盖索引，选择了索引a，不需要回表</li>
<li>Using temporary，表示使用了临时表</li>
<li>Using filesort，表示需要排序</li>
</ul>
<p>这个语句的执行流程如下：</p>
<ol>
<li>创建内存临时表，表里有两个字段m和c，主键是m</li>
<li>扫描表t1的索引a，依次取出叶子节点上id的值，计算id%10的结果，记为x
<ul>
<li>如果临时表中没有主键为x的行，就插入一条记录（x，1）</li>
<li>如果表中有主键为x的行，就将x这一行的c值加1</li>
</ul>
</li>
<li>遍历完成后，再根据字段m做排序，得到结果集返回给客户端</li>
</ol>
<p>流程图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226204524.png" alt="image-20211226204524315" style="zoom:67%;" />
<p>其中，虚线框内表示临时表的排序过程：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226204657.png" alt="image-20211226204657634" style="zoom:67%;" />
<p>这条语句的执行结果如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226204808.png" alt="image-20211226204808711" style="zoom: 50%;" />
<p>如果并不需要对结果进行排序，那么可以在SQL语句末尾增加order by null：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="operator">%</span> <span class="number">10</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>这样就跳过了最后排序的阶段，直接从临时表中取数据返回，返回的结果如图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226205042.png" alt="image-20211226205042481" style="zoom:50%;" />
<p>由于表t1中的id的值是从1开始的，因此返回的结果集中的第一行是id=1，扫描到id=10的时候才插入m=0这一行，因此结果集里最后一行才是m=0。</p>
<p>这个例子中由于临时表只有10行，内存可以放得下，因此全程只使用了内存临时表。但是，内存临时表的大小是有限制的，参数tmp_table_size就是控制这个内存大小的，默认是16M。此时，如果执行如下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> tmp_table_size <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">select</span> id <span class="operator">%</span> <span class="number">100</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span> limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>把内存临时表的大小限制为最大1024字节，并把语句改为id%100，这样返回结果里有100行数据。但是，这时的内存临时表大小不够存下这100行数据，也就是说，执行过程中会发现内存临时表大小不够存下这100行数据，也就是说，执行过程中会发现内存临时表大小达到了上限（1024字节）。这个时候，MySQL就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是InnoDB，这时返回的结果如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226210055.png" alt="image-20211226210055235" style="zoom:50%;" />
<p>如果这个表t1的数据量很大，很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间。</p>
<h3 id="使用索引优化group-by语句"><a class="markdownIt-Anchor" href="#使用索引优化group-by语句"></a> 使用索引优化group by语句</h3>
<p>可以看到，不论是使用内存临时表还是磁盘临时表，group by逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的，如果表的数据量比较大，上面这个group by语句执行起来就会很慢。</p>
<p>在优化group by问题之前，我们得清楚，为什么执行group by语句需要临时表，group by的语义逻辑是统计不同的值出现的个数，但是，由于每一行的id%100的结果是无序的，所以，我们需要一个临时表，来记录并统计结果。那么，如果扫描过程中可以保证出现的数据是有序的，那么group by语句就可以不再需要临时表，假设有如下数据结构：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226223201.png" alt="image-20211226223201473" style="zoom:67%;" />
<p>可以看到，如果可以确保输入的数据是有序的，那么计算group by的时候，就只需要从左到右，顺序扫描，依次累加，也就是下面的这个过程：</p>
<ul>
<li>当碰到第一个1的时候，已经知道累积了X个0，结果集里的第一行就是（0，x）</li>
<li>当碰到第一个2的时候，已经知道类及了Y个1，结果集里的第一行就是（1，Y）</li>
</ul>
<p>按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到group by的结果，不需要临时表，也不需要再额外的排序。在MySQL5.7支持了generated cloumn机制，用来实现列数据的关联更新，可以使用如下方法创建一个列z，然后在z列上创建一个索引（如果是MySQL5.6及之前的版本，可以创建普通列和索引，来解决这个问题）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">column</span> z <span class="type">int</span> generated always <span class="keyword">as</span>(id <span class="operator">%</span> <span class="number">100</span>), <span class="keyword">add</span> index(z);</span><br></pre></td></tr></table></figure>
<p>这样，索引z上的数据就是类似上图中的有序数据了，此时，上面的group by语句就可以改成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> z, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> z;</span><br></pre></td></tr></table></figure>
<p>优化后的group by语句的explain结果，如下图所示：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226224059.png" alt="image-20211226224059201" /></p>
<p>可以看到这个语句的执行不再需要临时表，也不需要排序了。</p>
<h3 id="直接排序优化group-by语句"><a class="markdownIt-Anchor" href="#直接排序优化group-by语句"></a> 直接排序优化group by语句</h3>
<p>实际上，并不是所有场景中可以通过加索引来完成group by的逻辑，如果碰到不适合创建索引的场景，还是一定要进行排序的操作。无论数据量大或小的group by语句都要先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表，我们可以在group by语句中加入<code>SQL_BIG_RESULT</code>这个提示（hint），就可以告诉优化器 ，这个语句涉及的数据量很大，直接使用磁盘临时表，MySQL会直接使用数组来存储这些数据，此时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_BIG_RESULT id <span class="operator">%</span> <span class="number">100</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure>
<p>执行流程就变成了：</p>
<ol>
<li>初始化sort_buffer，确定放入一个整型字段，记为m</li>
<li>扫描表t1的索引a，依次取出里面的id的值，将id%100的值存入sort_buffer中</li>
<li>扫描完成后，对sort_buffer的字段m做排序（如果sort_buffer的内存不够用，就会利用磁盘临时文件辅助排序）</li>
<li>排序完成后，就得到了一个有序数组</li>
</ol>
<p>根据有序数组，得到数组里面的不同值，以及每个值得出现次数，执行的流程图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226225313.png" alt="image-20211226225313194" style="zoom:67%;" />
<p>explain的结果如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211226225353.png" alt="image-20211226225353695" /></p>
<p>从Extra字段可以看到，这个语句的执行没有再使用临时表，而是直接使用了排序算法。</p>
<p>这里我们对MySQL使用内部临时表做如下总结：</p>
<ol>
<li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果</li>
<li>join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构</li>
<li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表（之前的例子中，union还需要用到唯一索引约束，group by还需要用到另外一个字段来存累积计数）</li>
</ol>
<h2 id="order-by-rand-优化"><a class="markdownIt-Anchor" href="#order-by-rand-优化"></a> order by rand() 优化</h2>
<p>假设有一个英语学习APP，用户每次访问首页的时候，都会随机滚动显示三个单词，也就是根据每个用户级别有一个单词表，假设我们的表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `words` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">  `word` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB; </span><br><span class="line"></span><br><span class="line">delimiter;; </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata() <span class="keyword">begin</span> <span class="keyword">declare</span> i <span class="type">int</span>; </span><br><span class="line"><span class="keyword">set</span> </span><br><span class="line">  i <span class="operator">=</span> <span class="number">0</span>; while i <span class="operator">&lt;</span> <span class="number">10000</span> do <span class="keyword">insert</span> <span class="keyword">into</span> words(word) </span><br><span class="line"><span class="keyword">values</span> </span><br><span class="line">  (</span><br><span class="line">    concat(</span><br><span class="line">      <span class="type">char</span>(</span><br><span class="line">        <span class="number">97</span> <span class="operator">+</span>(i div <span class="number">1000</span>)</span><br><span class="line">      ), </span><br><span class="line">      <span class="type">char</span>(</span><br><span class="line">        <span class="number">97</span> <span class="operator">+</span>(i <span class="operator">%</span> <span class="number">1000</span> div <span class="number">100</span>)</span><br><span class="line">      ), </span><br><span class="line">      <span class="type">char</span>(</span><br><span class="line">        <span class="number">97</span> <span class="operator">+</span>(i <span class="operator">%</span> <span class="number">100</span> div <span class="number">10</span>)</span><br><span class="line">      ), </span><br><span class="line">      <span class="type">char</span>(</span><br><span class="line">        <span class="number">97</span> <span class="operator">+</span>(i <span class="operator">%</span> <span class="number">10</span>)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  ); </span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; <span class="keyword">end</span> while; <span class="keyword">end</span>;; </span><br><span class="line">delimiter; </span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<p>实现这个需求最简单的实现方式，不难想到：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>但是随着单词表的变大，这个语句的执行速度越来越慢，那么该如何优化呢？</p>
<h3 id="内存临时表"><a class="markdownIt-Anchor" href="#内存临时表"></a> 内存临时表</h3>
<p>上述SQL的explain的结果如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220116105216709.png" alt="image-20220116105216709" /></p>
<p>Extra字段显示Using temporary，表示的是需要使用临时表，Using filesort表示的是需要执行排序操作，也就是说这个SQL需要临时表，并且需要在临时表上排序。</p>
<p>对于InnoDB表来说，执行全字段排序会会减少磁盘访问，因此会优先选择全字段排序，而对于临时内存表的排序来说，回表过程只是简单根据数据行的位置，直接访问内存得到数据，并不会导致过多的访问磁盘，因此，MySQL这时会选择rowid排序。</p>
<p>这条语句的执行流程如下：</p>
<ol>
<li>创建一个临时表，这个临时表使用的是memory引擎，表中有两个字段，第一个字段是double类型，为了后面描述方便，记为字段R，第二个字段是varchar（64）类型，记为字段W，并且，这个表没有建索引</li>
<li>从words表中，按主键顺序取出所有word值，对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并且把这个随机小数和word分别存入临时表的R和W字段中，到此，扫描的行数是10000</li>
<li>接下来按照R排序</li>
<li>初始化sort_buffer，sort_buffer中有两个字段，一个是double类型，另一个是整型</li>
<li>从内存临时表中一行一行地取出R值和位置信息，分别存入sort_buffer中的两个字段里，这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，变成了20000</li>
<li>在sort_buffer中根据R的值进行排序（这个过程没有涉及到表操作，所以不会增加扫描行数）</li>
<li>排序完成后，取出前三个结果的位置信息，依次到临时表中取出word值，返回给客户端，这个过程中，访问了表的三行数据，总扫描行数变成了20003</li>
</ol>
<p>接下来，我们通过慢查询日志（<code>show log</code>）来验证扫描行数是否是20003：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># Query_time: <span class="number">0.900376</span> Lock_time: <span class="number">0.000347</span> Rows_sent: <span class="number">3</span> Rows_examined: <span class="number">20003</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">timestamp</span><span class="operator">=</span><span class="number">1541402277</span>;</span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行。完整的排序的执行流程图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220116112157514.png" alt="image-20220116112157514" style="zoom:67%;" />
<p>图中的pos指的是位置信息。在InnoDB中，如果创建的表没有主键，获取把一个表的主键删掉了，那么InnoDB会自己生成一个长度为6字节的rowid来作为主键，这也就是排序模式里面，rowid名字的来历，实际上它表示的就是每个引擎用来唯一标识数据行的信息。</p>
<ul>
<li>对于有主键的InnoDB表来说，这个rowid就是主键ID</li>
<li>对于没有主键的InnoDB表磊说，这个rowid就是由系统生成的</li>
<li>Memory引擎不是索引组织表，这个例子里面，可以认为它就是一个数组，因为rowid其实就是数组的下标</li>
</ul>
<h3 id="磁盘临时表"><a class="markdownIt-Anchor" href="#磁盘临时表"></a> 磁盘临时表</h3>
<p>上文我们提到，order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法，那么是不是所有的临时表都是内存表呢？其实并不是，<code>tmp_table_size</code>这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了<code>tmp_table_size</code>，那么内存临时表就会转成磁盘临时表。</p>
<div class="note info"><p>磁盘临时表使用的引擎默认是InnoDB，是由参数internal_tmp_disk_storage_engine来控制的，因此当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表排序的过程。</p></div>
<p>为了复现这个过程，我们将<code>tmp_table_size</code>设置成1024，把<code>sort_buffer_size</code>设置成32768，把<code>max_length_for_sort_data</code>设置成16。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> tmp_table_size<span class="operator">=</span><span class="number">1024</span>;</span><br><span class="line"><span class="keyword">set</span> sort_buffer_size<span class="operator">=</span><span class="number">32768</span>;</span><br><span class="line"><span class="keyword">set</span> max_length_for_sort_data<span class="operator">=</span><span class="number">16</span>;</span><br><span class="line"><span class="comment">/* 打开 optimizer_trace ，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>;</span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`\G</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220116114409076.png" alt="image-20220116114409076" style="zoom:67%;" />
<p>因为将<code>max_length_for_sort_data</code>设置成16，小于word字段的长度定义，所以我们看到sort_mode里面显式的是rowid排序，这个是符合预期的，参与排序的是随机值R字段和rowid段组成的行。</p>
<p>R字段存放的随机值是8个字段，rowid是6个字节，数据总行数是10000，加起来是14000字节，超过了sort_buffer_size定义的32768字节，但是这里的number_of_tmp_files的值却是0，这里因为这里MySQL并没有使用归并排序算法，而是采用了优先队列排序算法。实际上，我们只需要取R值最小的3个rowid，但是，如果使用归并排序算法的话，虽然最终也能得到前3个值，但是这个算法会将1000行数据都排好序，然后再取前3条记录，如果使用归并算法就会浪费非常多的计算量。而优先队列算法，就可以精确地只得到三个最小值，执行流程如下：</p>
<ol>
<li>对于这10000个准备排序的（R，rowid），先取前三行，构造成一个堆</li>
<li>取下一个行（R<sup>’</sup>，rowid<sup>’</sup>），跟当前堆里面最大地R比较，如果R<sup>’</sup>小于R，把这个（R，rowid）从堆中去掉，换成（R<sup>’</sup>，rowid<sup>’</sup>）</li>
<li>重复第二步，直到第10000个（R<sup>’</sup>，rowid<sup>’</sup>）完成比较</li>
</ol>
<p>优先队列排序地示意图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220116120330311.png" alt="image-20220116120330311" style="zoom: 80%;" />
<p>图中模拟了6个（R，rowid）行，通过优先队列排序找到最小的三个R值的行的过程。整个排序过程中，为了最快地拿到当前堆的最大值，总是保持最大值在堆顶，因此这是一个最大堆。</p>
<p>OPTIMIZER_TRACE结果中，<code>filesort_priority_queue_optimization</code>这个部分的<code>chosen=true</code>，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的<code>number_of_tmp_files</code>是0。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27; 杭州 &#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p>排序的过程结束后，在我们构造的堆里面，就是这个10000行里面R值最小的三行。然后，依次把它们的rowid取出来，去临时表里面拿到word字段，就得到了最终的结果。</p>
<h3 id="随机排序法"><a class="markdownIt-Anchor" href="#随机排序法"></a> 随机排序法</h3>
<p>清楚了order by rand（）的执行过程，那么该如何优化呢？</p>
<p>我们先把问题简化以下，如果只随机选择1个word值，可以按照如下思路实现：</p>
<ol>
<li>取得这个表的主键id最大值M和最小值N</li>
<li>用随机函数生成一个最大值和最小值之间的数<code>X=（M-N）*rand（）+N</code></li>
<li>取不小于X的第一个ID的行</li>
</ol>
<p>我们将这个算法暂时称作随机算法1，对应的执行语句的序列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(id),<span class="built_in">min</span>(id) <span class="keyword">into</span> <span class="variable">@M</span>,<span class="variable">@N</span> <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@X</span><span class="operator">=</span> <span class="built_in">floor</span>((<span class="variable">@M</span><span class="operator">-</span><span class="variable">@N</span><span class="operator">+</span><span class="number">1</span>)<span class="operator">*</span>rand() <span class="operator">+</span> <span class="variable">@N</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="variable">@X</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法的效率很高，因为取max（id）和min（id）都是不需要扫描索引的，而第三步的select也可以用索引快速定位，可以认为就只扫描了3行。但实际上，这个算法并不严格满足题目的随机要求，因为ID中间可能由空洞，因此选择不同行的概率不一样，不是真正的随机。假设4个id分别是1、2、4、5，如果按照这个算法，那么取到id=4的这一行的概率是取到其它行的概率的两倍。</p>
<p>所以，为了得到严格随机的结果，可以按照如下流程：</p>
<ol>
<li>取得整个表的行数，并记为C</li>
<li>取得<code>Y=floor(C*rand())</code>，floor函数在这里的作用，就是取整数部分</li>
<li>再用limit Y,1取得一行</li>
</ol>
<p>我们将这个算法暂时称作随机算法2，对应的执行语句的序列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@C</span> <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@sql</span> <span class="operator">=</span> concat(&quot;select * from t limit &quot;, <span class="variable">@Y</span>, &quot;,1&quot;);</span><br><span class="line"><span class="keyword">prepare</span> stmt <span class="keyword">from</span> <span class="variable">@sql</span>;</span><br><span class="line"><span class="keyword">execute</span> stmt;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">prepare</span> stmt;</span><br></pre></td></tr></table></figure>
<p>由于limit后面的参数不能直接跟变量，所以这里使用了prepare+execute的方法，实际使用时，可以将拼接SQL语句的方法写在应用程序中。</p>
<p>MySQL处理limit Y,1的做法是按照顺序一个一个地读出来，丢掉前Y个，然后把下一个记录作为返回结果，因此这一步需要扫描Y+1行，再加上，第一个扫描地C行，总共需要扫描C+Y+1行，虽然解决了算法1里明显的概率不均匀的问题，但是执行代价要比随机算法1的代价要高，不过于order by rand（）相比，执行代价还是小很多。</p>
<p>到这里，我们就可以按照随机算法2的思路，优化本篇一开始的语句：</p>
<ol>
<li>取得整个表的行数，记为C</li>
<li>根据相同的随机方法得到Y1、Y2、Y3</li>
<li>再执行三个limit Y,1语句得到三行数据</li>
</ol>
<p>完整的执行序列如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@C</span> <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y1</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y2</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y3</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y1</span> ， <span class="number">1</span> ； <span class="operator">/</span><span class="operator">/</span> 在应用代码里面取 Y1 、 Y2 、 Y3 值，拼出 <span class="keyword">SQL</span> 后执行</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y2</span> ， <span class="number">1</span> ；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y3</span> ， <span class="number">1</span> ；</span><br></pre></td></tr></table></figure>
<h2 id="分区表"><a class="markdownIt-Anchor" href="#分区表"></a> 分区表</h2>
<p>在有些公司的数据库规范中，不允许使用分区表，那么分区表有什么问题呢？</p>
<h3 id="分区表简介"><a class="markdownIt-Anchor" href="#分区表简介"></a> 分区表简介</h3>
<p>为了说明分区表的组织形式，我们先创建表t：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `ftime` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  KEY (`ftime`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> latin1</span><br><span class="line"></span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (</span><br><span class="line">  <span class="keyword">YEAR</span>(ftime)</span><br><span class="line">) (</span><br><span class="line">  <span class="keyword">PARTITION</span> p_2017 </span><br><span class="line">  <span class="keyword">VALUES</span> </span><br><span class="line">    LESS THAN (<span class="number">2017</span>) ENGINE <span class="operator">=</span> InnoDB, </span><br><span class="line">    <span class="keyword">PARTITION</span> p_2018 </span><br><span class="line">  <span class="keyword">VALUES</span> </span><br><span class="line">    LESS THAN (<span class="number">2018</span>) ENGINE <span class="operator">=</span> InnoDB, </span><br><span class="line">    <span class="keyword">PARTITION</span> p_2019 </span><br><span class="line">  <span class="keyword">VALUES</span> </span><br><span class="line">    LESS THAN (<span class="number">2019</span>) ENGINE <span class="operator">=</span> InnoDB, </span><br><span class="line">    <span class="keyword">PARTITION</span> p_others </span><br><span class="line">  <span class="keyword">VALUES</span> </span><br><span class="line">    LESS THAN MAXVALUE ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="string">&#x27;2017-4-1&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;2018-4-1&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220116181122059.png" alt="image-20220116181122059" /></p>
<p>此时表中有两行记录，按照定义的分区的规则，这两行记录分别落在p_2018和p_2019这两个分区上，可以看到，这个表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件，也就是说：</p>
<ul>
<li>对于引擎层来说，这是4个表</li>
<li>对于Server层来说，这是1个表</li>
</ul>
<p>接下来我们通过观察分区表加间隙锁的例子来说明对于InnoDB来说，这是4个表：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220116193146452.png" alt="image-20220116193146452" /></p>
<p>我们初始化表t的时候，只插入了两行数据，ftime的值分别是，‘2017-4-1’和’2018-4-1’，session A的select语句对索引ftime上这两个记录之间的间隙加了锁。如果是一个普通表的话，那么T1时刻，在表t的ftime索引，间隙和加锁状态应该如下图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220116193512618.png" alt="image-20220116193512618" style="zoom: 67%;" />
<p>也就是说，'2017-4-1’和’2018-4-1’这两个记录之间的间隙是会被锁住的，那么session B的两条插入语句应该都要进入锁等待状态。但是从上面的实验效果可以看出，session B的第一个insert语句是可以执行成功，因为，对于引擎来说，p_2018和p_2019是两个不同的表，也就是说2017-4-1的下一个记录并不是2018-4-1，而是p_2018分区的supermum，所以在T1时刻，在表t的ftime索引上，间隙和加锁的状态其实是这样的：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220116193910224.png" alt="image-20220116193910224" style="zoom:67%;" />
<p>由于分区表的规则，session A的select语句其实只操作了分区p_2018，因此加锁范围就是图中深绿色的部分，所以，session B要写入一行ftime是2018-2-1的时候是可以成功的，而要写入2017-12-1这个记录，就要等session A的间隙锁。</p>
<p>此时<code>show engine innodb status</code>的部分结果如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220116194133483.png" alt="image-20220116194133483" /></p>
<p>接下来我们看看在MyISAM引擎中的情况，首先使用<code>alter table t engine</code>将表t改成MyISAM表，然后执行如下序列：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220116194544996.png" alt="image-20220116194544996" /></p>
<p>在session A里面，使用sleep(100)将这条语句的执行时间设置为100秒，由于MyISAM引擎只支持表锁，所以这条update语句会锁住整个表t上的读，但是我们看到的结果是，session B的第一条查询语句是可以正常执行的，第二条语句才进入锁等待状态，这正是因为MyISAM的表锁是在引擎层实现的，session A加的表锁，其实是锁在分区p_2018上。因此，只会堵住在这个分区上执行的查询，落到其它分区的查询时不受影响的。</p>
<p>此时看起来使用分区表并没有什么不妥，通常我们使用分区表的一个重要原因就是单表过大，如果不使用分区表的话，就要使用手动分表的方式，那么手动分表和分区表有什么区别？比如，按照年份来划分，我们就分别创建普通表t_2017、t_2018、t_2019等等。手工分表的逻辑，也是找到需要更新的所有分表，然后依次执行更新，在性能上，这个分区表并没有实质的差别。另外，分区表和手工分表，一个是由server层来决定使用哪个分区，一个是由应用层代码决定使用哪个分表，因此，从引擎层来看，这两种方式也是没有差别的。</p>
<p>实际上，问题的关键在于server层，分区表最重要的问题在于：打开表的行为。</p>
<h3 id="分区策略"><a class="markdownIt-Anchor" href="#分区策略"></a> 分区策略</h3>
<p>每当第一次访问一个分区表的时候，MySQL需要把所有的分区都访问一遍。一个典型的报错情况是这样的：如果一个分区表的分区很多，比如超过了1000个，而MySQL启动的时候，<code>open_files_limit</code>参数使用的默认值是1024，那么就会在访问这个表的时候，由于需要打开所有的文件，导致打开表文件的个数超过了上限而报错。</p>
<p>下图是创建的一个包含了很多分区的表t_myisam，执行一条插入语句后报错的情况。：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220116191126999.png" alt="image-20220116191126999" /></p>
<p>可以看到，这条insert语句，明显只需要访问一个分区，但语句却无法执行。实际上使用InnoDB引擎并不会出现这个问题，MyISAM分区表使用的分区策略，我们称为通用分区策略（generic partitioning），每次访问分区都由server层控制，通用分区策略，是MySQL一开始支持分区表的时候就存在的代码，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题。</p>
<p>从MySQL5.7.9开始，InnoDB引擎引入了本地分区策略（native partitioning），这个策略是在InnoDB内部自己管理打开分区的行为。从MySQL5.7.17开始，将MyISAM分区表标记为Deprecated，从MySQL8.0版本开始，就不允许创建MyISAM分区表了，只允许创建已经实现了本地分区策略的引擎。目前来看，只有InnoDB和NDB这两个引擎支持了本地分区策略。</p>
<p>如果从server层看的话，一个分区表就只是一个表。下面我们通过例子来说明，下面两张图分别是这个例子的操作序列和执行结果图。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220116192048055.png" alt="image-20220116192048055" /></p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220116192111558.png" alt="image-20220116192111558" /></p>
<p>可以看到，虽然session B只需要操作p_2017这个分区，但是由于session A持有整个表t的MDL锁，就导致了session B的alter语句被堵住，实际上，分区表在做DDL的时候，影响会更大，但是如果是在普通的分表上操作的时候并不会出现这样的问题。</p>
<p>我们可以对分区表做以下总结：</p>
<ul>
<li>MySQL在第一次打开分区表的时候，需要访问所有的分区</li>
<li>在server层，认为这是同一张表，因此所有分区共用同一个MDL锁</li>
<li>在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必要的分区</li>
</ul>
<p>其中“必要的分区”是根据SQL语句中的where条件，结合分区规则来实现的。比如，上面的例子中<code>where ftime='2018-4-1'</code>，根据分区规则year函数算出来的值是2018，那么就会落在p_2019这个分区，但是如果这个where条件改成<code>where ftime&gt;='2018-4-1'</code>，虽然查询结果相同，但是这个时候根据where条件，就要访问p_2019和P_others这两个分区。如果查询语句的where条件中没有分区key，那么就只能访问所有分区了，不过即使是使用业务分表的方式，没有分区的key也需要访问所有的分区表。</p>
<h3 id="分区表的应用场景"><a class="markdownIt-Anchor" href="#分区表的应用场景"></a> 分区表的应用场景</h3>
<p>分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区别的业务代码更简洁，另外，分区表可以很方便的清理历史数据。如</p>
<p>如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求，这个时候，按照时间分区的分区表，就可以直接通过<code>alter table t drop partition...</code>这个语法删掉分区，从而删掉过期的历史数据，这个语句的操作时直接删除分区文件，效果跟drop普通表类似，与使用delete语句删除数据相比，优势是速度快、对系统影响小。</p>
<p>分区表在使用的时候，有两个绕不开的问题：一个是第一次访问的时候需要访问所有分区，另一个是共用MDL锁，对于分区表的使用有以下需要注意的点：</p>
<ol>
<li>分区并不是越细越好，实际上，单表或者单分区的数据一千万行，只要没有也别大的索引，对于现在的硬件能力来说都已经是小表了</li>
<li>分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时再把下一年度的12个新分区创建上即可，对于没有数据的历史分区，要及时drop掉</li>
</ol>
<p>至于分区表的其它问题，比如查询需要跨多个分区取数据，查询性能就会比较慢，基本上就不是分区表本身的问题，而是数据量的问题或者说时使用方式的问题了。</p>
<h2 id="慢查询日志"><a class="markdownIt-Anchor" href="#慢查询日志"></a> 慢查询日志</h2>
<h3 id="基本介绍"><a class="markdownIt-Anchor" href="#基本介绍"></a> 基本介绍</h3>
<blockquote>
<p>慢查询日志是什么？</p>
</blockquote>
<ul>
<li>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过<code>long_query_time</code>值的SQL，则会被记录到慢查询日志中。</li>
<li><code>long_query_time</code>的默认值为10，意思是运行10秒以上的语句。</li>
<li>由慢查询日志来查看哪些SQL超出了我们的最大忍耐时间值，比如一条SQL执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒钟的SQL，结合之前<code>explain</code>进行全面分析。</li>
</ul>
<blockquote>
<p>特别说明</p>
</blockquote>
<p>**默认情况下，MySQL数据库没有开启慢查询日志，**需要我们手动来设置这个参数。</p>
<p><strong>当然，如果不是调优需要的话，一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。</p>
<blockquote>
<p>查看慢查询日志是否开以及如何开启</p>
</blockquote>
<ul>
<li>
<p>查看慢查询日志是否开启：<code>SHOW VARIABLES LIKE '%slow_query_log%';</code>。</p>
</li>
<li>
<p>开启慢查询日志：<code>SET GLOBAL slow_query_log = 1;</code>。<strong>使用该方法开启MySQL的慢查询日志只对当前数据库生效，如果MySQL重启后会失效。</strong></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、查看慢查询日志是否开启</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW VARIABLES LIKE <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span></span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| Variable_name       | Value                                |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                  |</span><br><span class="line">| slow_query_log_file | /var/lib/mysql/1dcb5644392c-slow.log |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、开启慢查询日志</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SET GLOBAL slow_query_log = 1;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>如果要使慢查询日志永久开启，需要修改<code>my.cnf</code>文件，在<code>[mysqld]</code>下增加修改参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.这个是开启慢查询。注意ON需要大写</span></span><br><span class="line">slow_query_log=ON  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.这个是存储慢查询的日志文件。这个文件不存在的话，需要自己创建</span></span><br><span class="line">slow_query_log_file=/var/lib/mysql/slow.log</span><br></pre></td></tr></table></figure>
<blockquote>
<p>开启了慢查询日志后，什么样的SQL才会被记录到慢查询日志里面呢？</p>
</blockquote>
<p>这个是由参数<code>long_query_time</code>控制的，默认情况下<code>long_query_time</code>的值为10秒。</p>
<p>MySQL中查看<code>long_query_time</code>的时间：<code>SHOW VARIABLES LIKE 'long_query_time%';</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看long_query_time 默认是10秒</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只有SQL的执行时间&gt;10才会被记录</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW VARIABLES LIKE <span class="string">&#x27;long_query_time%&#x27;</span>;</span></span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>修改<code>long_query_time</code>的时间，需要在<code>my.cnf</code>修改配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个是设置慢查询的时间，我设置的为1秒</span></span><br><span class="line">long_query_time=1</span><br></pre></td></tr></table></figure>
<p>查新慢查询日志的总记录条数：<code>SHOW GLOBAL STATUS LIKE '%Slow_queries%';</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW GLOBAL STATUS LIKE <span class="string">&#x27;%Slow_queries%&#x27;</span>;</span></span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Slow_queries  | 3     |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="日志分析工具"><a class="markdownIt-Anchor" href="#日志分析工具"></a> 日志分析工具</h3>
<p>日志分析工具<code>mysqldumpslow</code>：在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具<code>mysqldumpslow</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、mysqldumpslow --<span class="built_in">help</span> 来查看mysqldumpslow的帮助信息</span></span><br><span class="line">root@1dcb5644392c:/usr/bin# mysqldumpslow --help</span><br><span class="line">Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]</span><br><span class="line"></span><br><span class="line">Parse and summarize the MySQL slow query log. Options are</span><br><span class="line"></span><br><span class="line">  --verbose    verbose</span><br><span class="line">  --debug      debug</span><br><span class="line">  --help       write this text to standard output</span><br><span class="line"></span><br><span class="line">  -v           verbose</span><br><span class="line">  -d           debug</span><br><span class="line">  -s ORDER     what to sort by (al, at, ar, c, l, r, t), &#x27;at&#x27; is default  # 按照何种方式排序</span><br><span class="line">                al: average lock time # 平均锁定时间</span><br><span class="line">                ar: average rows sent # 平均返回记录数</span><br><span class="line">                at: average query time # 平均查询时间</span><br><span class="line">                 c: count  # 访问次数</span><br><span class="line">                 l: lock time  # 锁定时间</span><br><span class="line">                 r: rows sent  # 返回记录</span><br><span class="line">                 t: query time  # 查询时间 </span><br><span class="line">  -r           reverse the sort order (largest last instead of first)</span><br><span class="line">  -t NUM       just show the top n queries  # 返回前面多少条记录</span><br><span class="line">  -a           don&#x27;t abstract all numbers to N and strings to &#x27;S&#x27;</span><br><span class="line">  -n NUM       abstract numbers with at least n digits within names</span><br><span class="line">  -g PATTERN   grep: only consider stmts that include this string  </span><br><span class="line">  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),</span><br><span class="line">               default is &#x27;*&#x27;, i.e. match all</span><br><span class="line">  -i NAME      name of server instance (if using mysql.server startup script)</span><br><span class="line">  -l           don&#x27;t subtract lock time from total time</span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、 案例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.1、得到返回记录集最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.2、得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/slow.log</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.3、得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/slow.log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.4、另外建议使用这些命令时结合|和more使用，否则出现爆屏的情况</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log | more</span><br></pre></td></tr></table></figure>
<h3 id="分析慢sql的步骤"><a class="markdownIt-Anchor" href="#分析慢sql的步骤"></a> 分析慢SQL的步骤</h3>
<p>分析：</p>
<p>1、观察，至少跑1天，看看生产的慢SQL情况。</p>
<p>2、开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来。</p>
<p>3、explain + 慢SQL分析。</p>
<p>4、show Profile。</p>
<p>5、运维经理 OR DBA，进行MySQL数据库服务器的参数调优。</p>
<p>总结（大纲）：</p>
<p>1、慢查询的开启并捕获。</p>
<p>2、explain + 慢SQL分析。</p>
<p>3、show Profile查询SQL在MySQL数据库中的执行细节和生命周期情况。</p>
<p>4、MySQL数据库服务器的参数调优。</p>
<h3 id="show-profile"><a class="markdownIt-Anchor" href="#show-profile"></a> Show Profile</h3>
<blockquote>
<p>Show Profile是什么？</p>
</blockquote>
<p><code>Show Profile</code>：MySQL提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量。<strong>默认情况下，参数处于关闭状态，并保存最近15次的运行结果。</strong></p>
<blockquote>
<p>分析步骤</p>
</blockquote>
<p>1、是否支持，看看当前的MySQL版本是否支持。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看Show Profile功能是否开启</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW VARIABLES LIKE <span class="string">&#x27;profiling&#x27;</span>;</span></span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| profiling     | OFF   |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>2、开启<code>Show Profile</code>功能，默认是关闭的，使用前需要开启。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启Show Profile功能</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SET profiling=ON;</span></span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>3、运行SQL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `emp` GROUP BY `id`%10 LIMIT 150000;</span><br><span class="line"></span><br><span class="line">SELECT * FROM `emp` GROUP BY `id`%20 ORDER BY 5;</span><br></pre></td></tr></table></figure>
<p>4、查看结果，执行<code>SHOW PROFILES;</code></p>
<p><code>Duration</code>：持续时间。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW PROFILES;</span></span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                             |</span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br><span class="line">|        1 | 0.00156100 | SHOW VARIABLES LIKE &#x27;profiling&#x27;                   |</span><br><span class="line">|        2 | 0.56296725 | SELECT * FROM `emp` GROUP BY `id`%10 LIMIT 150000 |</span><br><span class="line">|        3 | 0.52105825 | SELECT * FROM `emp` GROUP BY `id`%10 LIMIT 150000 |</span><br><span class="line">|        4 | 0.51279775 | SELECT * FROM `emp` GROUP BY `id`%20 ORDER BY 5   |</span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br><span class="line">4 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>5、诊断SQL，<code>SHOW PROFILE cpu,block io FOR QUERY Query_ID;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里的3是第四步中的Query_ID。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以在SHOW PROFILE中看到一条SQL中完整的生命周期。</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW PROFILE cpu,block io FOR QUERY 3;</span></span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |</span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">| starting             | 0.000097 | 0.000090 |   0.000002 |            0 |             0 |</span><br><span class="line">| checking permissions | 0.000010 | 0.000009 |   0.000000 |            0 |             0 |</span><br><span class="line">| Opening tables       | 0.000039 | 0.000058 |   0.000000 |            0 |             0 |</span><br><span class="line">| init                 | 0.000046 | 0.000046 |   0.000000 |            0 |             0 |</span><br><span class="line">| System lock          | 0.000011 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| optimizing           | 0.000005 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| statistics           | 0.000023 | 0.000037 |   0.000000 |            0 |             0 |</span><br><span class="line">| preparing            | 0.000014 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| Creating tmp table   | 0.000041 | 0.000053 |   0.000000 |            0 |             0 |</span><br><span class="line">| Sorting result       | 0.000005 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| executing            | 0.000003 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| Sending data         | 0.520620 | 0.516267 |   0.000000 |            0 |             0 |</span><br><span class="line">| Creating sort index  | 0.000060 | 0.000051 |   0.000000 |            0 |             0 |</span><br><span class="line">| end                  | 0.000006 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| query end            | 0.000011 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| removing tmp table   | 0.000006 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| query end            | 0.000004 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| closing tables       | 0.000009 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| freeing items        | 0.000032 | 0.000064 |   0.000000 |            0 |             0 |</span><br><span class="line">| cleaning up          | 0.000019 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">20 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p><code>Show Profile</code>查询参数备注：</p>
<ul>
<li><code>ALL</code>：显示所有的开销信息。</li>
<li><code>BLOCK IO</code>：显示块IO相关开销（通用）。</li>
<li><code>CONTEXT SWITCHES</code>：上下文切换相关开销。</li>
<li><code>CPU</code>：显示CPU相关开销信息（通用）。</li>
<li><code>IPC</code>：显示发送和接收相关开销信息。</li>
<li><code>MEMORY</code>：显示内存相关开销信息。</li>
<li><code>PAGE FAULTS</code>：显示页面错误相关开销信息。</li>
<li><code>SOURCE</code>：显示和Source_function。</li>
<li><code>SWAPS</code>：显示交换次数相关开销的信息。</li>
</ul>
<p>6、<code>Show Profile</code>查询列表，日常开发需要注意的结论：</p>
<ul>
<li><code>converting HEAP to MyISAM</code>：查询结果太大，内存都不够用了，往磁盘上搬了。</li>
<li><code>Creating tmp table</code>：创建临时表（拷贝数据到临时表，用完再删除），非常耗费数据库性能。</li>
<li><code>Copying to tmp table on disk</code>：把内存中的临时表复制到磁盘，危险！！！</li>
<li><code>locked</code>：死锁。</li>
</ul>
<h1 id="mysql中的事务和锁"><a class="markdownIt-Anchor" href="#mysql中的事务和锁"></a> MySQL中的事务和锁</h1>
<h2 id="事务隔离"><a class="markdownIt-Anchor" href="#事务隔离"></a> 事务隔离</h2>
<p>简单来说，事务就是要保证一组操作，要么全部成功，要么全部失败，事务具有ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）的特性。在MySQL中，事务支持是在引擎层实现的，但并不是所有的引擎都支持事务，比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。</p>
<h3 id="隔离性和隔离级别"><a class="markdownIt-Anchor" href="#隔离性和隔离级别"></a> 隔离性和隔离级别</h3>
<p>当数据库上有多个事务同时执行的时候，就可能出现藏独（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。隔离级别越高，执行的效率就会越低，因此很多时候，都需要在二者之间寻找一个平衡点。</p>
<p>SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable），它们的含义如下：</p>
<ul>
<li>读未提交是指，一个事务还没有提交时，它做的变更就能被别的事务看到</li>
<li>读提交是指，一个事务提交之后，它做的变更才会被其它事务看到</li>
<li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动的时候看到的数据是一致的。在可重复读的隔离级别下，未提交变更对其它事务也是不可见的</li>
<li>串行化是指对同一行记录，“写”会加锁，“读”会“读锁”。当出现读写锁冲突的时候，后访问的事务必须等待前一个事务执行完成，才能继续执行</li>
</ul>
<p>下面我们通过实例来说明，假设数据表T中只有一列，其中一行的值为1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T(c <span class="type">int</span>) engine <span class="operator">=</span> InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>下面是按照时间顺序执行两个事务的行为：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220103112251081.png" alt="image-20220103112251081" style="zoom: 50%;" />
<p>我们来看下在不同的隔离级别下，事务A会查询到的V1、V2、V3的返回值分别是什么：</p>
<ul>
<li>若隔离级别是“读未提交”，则V1、V2、V3的值都是2。这时候事务B虽然还没有提交，但是结果已经被A看到了</li>
<li>若隔离级别是“读提交”，则V1是1，V2的值是2，事务B的更新在提交后才能被A看到，所以V3的值也是2</li>
<li>若隔离级别是“可重复读”，则V1、V2是1，V3是2，之所以V2还是1，是因为在这个隔离级别下，事务在执行期间看到的数据前后必须是一致的</li>
<li>若隔离级别是“串行化”，则事务B执行“将1改成2”的时候，会被锁住，直到事务A提交之后，事务B才可以继续执行。所以，从A的角度来看，V1、V2的值是1，V3的值是2</li>
</ul>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的，这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p>
<p>在不同的隔离级别下，数据库的行为是有所不同的。Oracle数据库的默认隔离级别是“读提交”，MySQL的InnoDB默认隔离级别是“可重复读”。因此，对于一些从Oracle迁移到MySQL的应用，为了保证数据库隔离级别的一致，需要将隔离级别设置为“读提交”，将启动参数<code>transaction-isolation</code>的值设置为READ-COMMITTED，可以使用<code>show variables like 'transaction_isolation';</code>来查看当前的值。</p>
<div class="note info"><p>每一种隔离级别都有自己的使用场景，具体使用哪一种，需要根据业务情况来定。</p></div>
<h3 id="事务隔离的实现"><a class="markdownIt-Anchor" href="#事务隔离的实现"></a> 事务隔离的实现</h3>
<p>那么事务隔离是怎么实现的呢？实际上，在MySQL中，每条记录在更新的时候都会同时记录一条回滚操作，记录上最新的值，通过回滚操作，都可以得到前一个状态的值。假设一个值从1被顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220103115424619.png" alt="image-20220103115424619" style="zoom:50%;" />
<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A要得到1，就必须将当前的值依次执行图中所有的回滚操作得到。</p>
<p>回滚日志只有当没有事务需要用到这些回滚日志，也就是当系统里没有比这个回滚日志更早的read-view的时候，才会被删除，这也就是很多文章中建议不要使用长事务的原因之一。长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以在这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。在MySQL5.5及以前的版本，回滚日志是跟字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小，也许数据只有20GB，但是回滚段却有200GB。</p>
<p>可以在information_schema库的innodb_trx这个表中，使用如下语句查询超过60s的长事务：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(timediff(now(),trx_started)) <span class="operator">&gt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure>
<h3 id="事务的启动方式"><a class="markdownIt-Anchor" href="#事务的启动方式"></a> 事务的启动方式</h3>
<p>MySQL的事务启动方式有以下几种：</p>
<ol>
<li>显式启动事务语句：<code>begin或start transaction;</code>。配套的提交语句是commit，回滚语句是rollback</li>
<li><code>set autocommit = 0;</code>，这个命令会将这个线程的自动提交关掉，意味着如果只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务将持续存在直到主动执行commit或rollback语句，或者断开连接</li>
</ol>
<p>有些客户端框架会默认连接成功后先执行<code>set autocommit = 0;</code>，这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。因此，最好使用<code>set autocommit = 1</code>，通过显式语句的方式来启动事务，不过这样需要每次执行依次“begin”，如果不想每次都多“多一次交互”，那么可以使用<code>commit work and chain</code>语法。在autocommit为1的情况下，用begin显式启动事务，如果执行commit则提交事务，如果执行<code>mmit work and chain</code>，则是提交事务并自动启动下一个事务，这样既省去了再次执行begin语句的开销，又可以明确地直到每个语句是否处于事务中。</p>
<h2 id="全局锁"><a class="markdownIt-Anchor" href="#全局锁"></a> 全局锁</h2>
<p>数据库锁的设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则，而锁就是用来实现这些访问规则的重要数据结构。根据加锁的范围，MySQL里面的锁大致可以分为全局锁、表级锁和行锁三类。</p>
<h3 id="全局锁的特点"><a class="markdownIt-Anchor" href="#全局锁的特点"></a> 全局锁的特点</h3>
<p>顾名思义，全局锁就是对整个数据库实例加锁，MySQL提供了一个全局读锁的方法：<code>Flush tables with read lock</code>(FTWRL)。当需要让整个库处于只读状态的时候，可以使用这个命令，之后其它线程的更新（增删改）、数据定义语句（建表、修改表结构）和更新类事务的提交语句都会被阻塞。</p>
<p>全局锁的典型使用场景是，做全库逻辑备份，也就是将整库的每个表都select出来存成文本。</p>
<h3 id="全局锁对比"><a class="markdownIt-Anchor" href="#全局锁对比"></a> 全局锁对比</h3>
<p>MySQL自带的逻辑备份工具是mysqldump，当mysqldump使用参数<code>-single-transaction</code>的时候，导数据之前就会启动一个事务，来确保拿到一致性视图，由于MVCC的支持，这个过程中数据是可以正常更新的。但并不是所有的存储引擎都支持一致性读的隔离级别，例如MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是取到最新的数据，那么就破坏了备份的一致性，这个时候，就只能使用FTWRL命令了，因此<code>-single-transaction</code>只适用于所有的表使用事务引擎的数据库，如果有的表使用了不支持事务的引擎，那么备份只能通过FTWRL方法，这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一。</p>
<p>全库只读除了使用FTWRL，还可以使用<code>set global readonly = true</code>，不过如果要备份全库，还是应该使用FTWRL，原因有二：</p>
<ol>
<li>在有些系统中，readonly的值会被用来做其它逻辑，比如用来判断一个库是主库还是备库，因此，修改global变量的方式影响面更大</li>
<li>在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一致保持readonly状态，这样会导致整库长时间处于不可写状态，风险较高</li>
</ol>
<h2 id="表级别的锁"><a class="markdownIt-Anchor" href="#表级别的锁"></a> 表级别的锁</h2>
<p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，简称MDL）。</p>
<h3 id="表锁"><a class="markdownIt-Anchor" href="#表锁"></a> 表锁</h3>
<p>表锁的语法是<code>lock tables ... read/write</code>。与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意的是，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
<h3 id="元数据锁"><a class="markdownIt-Anchor" href="#元数据锁"></a> 元数据锁</h3>
<p>另一类表级的锁是MDL（metadata lock）。MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。例如，一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构在做变更，删了一列，那么查询线程拿到的结果就与表结构对应不上了，这种情况就需要MDL。在MySQL5.5版本中引入了MDL，当对一个表做增删改查操作的时候，就会加上MDL读锁；当要对表结构做变更操作的时候，就会加上MDL写锁。</p>
<ul>
<li>读锁之间不互斥，因此可以有多个线程同时对一张表增删改查</li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行</li>
</ul>
<p>给一个表加字段或者修改字段、添加索引，都需要扫描全表的数据，因此，操作不慎的话，就可能导致生产事故：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211228232542.png" alt="image-20211228232542111" style="zoom:50%;" />
<p>session A先启动，这时候会对表t加上一个MDL读锁，由于session B需要的也是MDL读锁，因此可以正常执行。之后session C会被blocked，因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。之后所有在表上新申请MDL读锁的请求也会被session C阻塞，也就是说，所有对表的增删改查都需要先申请MDL读锁，都被锁住导致表完全不可读写。如果这个表上的查询语句频繁，而且客户端有重试机制，也就是超时后会再起一个新的session 再请求的话，这个库的线程很快就会爆满。</p>
<p>事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。在给小表加字段的时候，首先要解决的是长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema库的innodb_trx表中，可以查询到当前执行中的事务，如果要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。但如果要变更的表是一个热点表，虽然数据量不大，但是请求很频繁，这个时候只kill掉可能未必管用了，因为新的请求马上就会到。</p>
<p>因此，给小表添加字段比较合理的方案是，在<code>alter table</code>语句里面设定等待时间，如果在这个执行的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃，之后开发人员或者DBA再通过重试命令重复这个过程。MairaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAIT n这个语法。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name NOWAIT <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name WAIT N <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br></pre></td></tr></table></figure>
<h2 id="行锁"><a class="markdownIt-Anchor" href="#行锁"></a> 行锁</h2>
<p>行锁顾名思义，就是针对数据表中行记录的锁，比如事务A更新了一行，而这个时候，事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。在MySQL中有四种类型的行锁：</p>
<ul>
<li>LOCK_ORDINARY：也称为Next-Key Lock，锁一条记录及其间隙，这是RR隔离级别用的最多的锁</li>
<li>LOCK_GAP：间隙锁，锁两个记录之间的GAP，防止记录插入</li>
<li>LOCK_REC_NOT_GAP：只锁记录</li>
<li>LOCK_INSERT_INTENSION：插入意向GAP锁，插入记录时使用，是LOCK_GAP的一种特例</li>
</ul>
<h3 id="两阶段锁"><a class="markdownIt-Anchor" href="#两阶段锁"></a> 两阶段锁</h3>
<p>为了更好的说明行锁，我们以下面的操作序列为例，假设id是表t的主键：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20211228234751.png" alt="image-20211228234751212" style="zoom:50%;" />
<p>这个例子中事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行，在这个过程中，事务A持有两个记录的行锁，都是在commit的时候才释放的，也就是说，在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放，这就是两阶段锁协议。基于这个协议，我们在使用事务的时候，如果事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁尽量完后放，接下来我们通过一个实例来说明这一点。</p>
<p>假设要实现一个电影票在线交易业务，顾客A要在影院B购买电影票，这个业务需要涉及以下的操作：</p>
<ol>
<li>从顾客A账余额中扣除电影票价</li>
<li>给影院B的账户余额增加这张电影票价</li>
<li>记录一条交易日志</li>
</ol>
<p>也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录，为了保证交易的原子性，我们需要把这三个操作放在一个事务中。假设此时同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了，因为它们要更新同一个影院账户的余额，需要修改同一行数据。根据两阶段锁协议，无论怎样安排语句顺序，所有的操作需要行锁的都是在事务提交的时候才会释放，所以，应该把需要行锁的语句放在最后，这样可以最大程度减少事务之间的锁等待，提升并发度。</p>
<h3 id="死锁和死锁检测"><a class="markdownIt-Anchor" href="#死锁和死锁检测"></a> 死锁和死锁检测</h3>
<p>当并发系统中不同线程出现循环资源以来，设计的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220102184417933.png" alt="image-20220102184417933" style="zoom:50%;" />
<p>这时候，事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时，这个超时时间可以通过参数<code>innodb_lock_wait_timeout</code>来设置</li>
<li>另一种策略是。发起死锁检测，发现死锁后，主动回滚锁链条的某一个事务，让其它事务得以继续执行，可以通过参数<code>innodb_deadlock_detect=on</code>来控制，默认开启</li>
</ul>
<p>在InnoDB中，<code>innodb_lock_wait_timeout</code>的默认值是50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其它线程才有可能继续执行。这对于在线服务来说，这个等待时间往往是无法接受的。但是，将这个时间的值设置的很小也不行，这样当出现死锁的时候，确实很快就可以解开，但是如果不是死锁，只是简单的锁等待也会释放，也会释放掉。所以，一般都会选择第二种策略，即主动死锁检测。</p>
<p>主动死锁检测在发生死锁的时候，虽然能够快速发现并进行处理的，但是它也有额外的负担，每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>
<p>当所有事务都要更新同一行的场景时，每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O（n）的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作的时间复杂度就是百万量级的，虽然最终检测的结果是没有死锁，但是检测期间要消耗大量的CPU资源，因此，当并发量很大的时候，就会看到CPU利用率很高，但是每秒却执行不了几个事务。</p>
<p>总而言之，死锁检测要耗费大量的CPU资源。那么，该如何解决由这种热点行更新导致的性能的问题呢？</p>
<ol>
<li>一种方法是，确保业务一定不会出现死锁，然后关掉死锁检测，但是这种操作本身带有一定的风险，因此业务设计的时候一般不会把死锁当做一个严重错误，一旦出现死锁，就可能会出现大量的超时</li>
<li>另一种方法是控制并发度，根据上面的分析，死锁检测的时间复杂度与并发量正相关，如果可以控制并发量，那么就可以控制死锁检测的时间复杂度。需要注意的是，这个并发控制要做在数据库服务端，因为虽然每个客户端的并发量可能很小，但是汇总到数据库服务端以后，还是会很大。可以在中间件中实现，也可以在MySQL里面做（基本思路：对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作了）。</li>
<li>最后一种方法是，可以考虑通过将一行改成逻辑上的多行来减少锁冲突。以影院的账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加，这样每次冲突概率变成原来的1/10，可以减少锁等待的个数，也减少了死锁检测的CPU消耗，需要注意的是，当一部分行记录变成0的时候，如果还要减少记录的值，需要特殊处理</li>
</ol>
<h2 id="间隙锁"><a class="markdownIt-Anchor" href="#间隙锁"></a> 间隙锁</h2>
<h3 id="幻读"><a class="markdownIt-Anchor" href="#幻读"></a> 幻读</h3>
<p>为了说明幻读，我们初始化如下数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">	`id` <span class="type">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`c` <span class="type">INT</span> (<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`d` <span class="type">INT</span> (<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">	KEY `c` (`c`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>), (<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>), (<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>), (<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>), (<span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure>
<p>假设执行的场景序列如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220103172302968.png" alt="image-20220103172302968" style="zoom: 67%;" />
<p>可以看到，session A里执行了三次查询，分别是Q1、Q2和Q3，具体的执行结果如下：</p>
<ol>
<li>Q1只返回id=5这一行</li>
<li>在T2时刻，session B把id=0这一行的d值改成了5，因此T3时刻Q2查出来的是id=0和id=5这两行</li>
<li>在T4时刻，session C又插入一行（1,1,5），因此T5时刻Q3查出来的是id=0、id=1和id=5的这三行</li>
</ol>
<p>其中，Q3读到id=1这一行的现象，被称为“幻读”。也就是说，幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行，关于幻读的两点说明：</p>
<ul>
<li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现</li>
<li>上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读，幻读专指“新插入的行”</li>
</ul>
<p>因为这三个查询都是加了for update，都是当前读。而当前读的规则，就是要能读到所有已经提交的记录的最新值，并且，session B和session C两条语句，执行后就会提交，所以Q2和Q3就是应该看到这两个事务的操作效果，而且也看到了，这跟事务的可见性规则并不矛盾。</p>
<h3 id="幻读的问题"><a class="markdownIt-Anchor" href="#幻读的问题"></a> 幻读的问题</h3>
<p>幻读会带来一些问题，假设时序图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220103174549152.png" alt="image-20220103174549152" style="zoom:67%;" />
<p>session B的第二条语句<code>update t set c = 5 where id = 0</code>，语义是把id=0、d=5这一行的c的值，改成了5。由于在T1时刻，session A还只是给id=5这一行加了行锁，并没有给id=0这行加上锁。因此，session B在T2时刻，是可以执行这两条update语句的，这样，就破坏了session A里Q1语句要锁住所有d=5的行的加锁声明。session C也是相同的道理，对id=1这一行的修改，也是破坏了Q1的加锁声明。</p>
<p>其次，还有数据一致性的问题，我们直到，锁的设计是为了保证数据的一致性，而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。为了说明这个问题，给session A在T1时刻再加上一个更新语句，即：<code>update t set d = 100 where d = 5;</code>，此时的序列图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220103215449655.png" alt="image-20220103215449655" style="zoom:67%;" />
<p>update加锁的语义和<code>select ... for update</code>是一致的，所以这时候加上这条update语句也很合理。session A声明说“要给d=5的语句加上锁”，就是为了要更新数据，新加的这条update语句就是把它认为加上了锁的这一行的d的值修改成了100。</p>
<p>执行完图中的语句之后，数据库中的情况：</p>
<ol>
<li>经过T1时刻，id=5这一行变成（5，5，100），当然这个结果最终是在T6时刻正式提交的</li>
<li>经过T2时刻，id=0这一行变成（0，5，5）</li>
<li>经过T4时刻，表里面多了一行（1，5，5）</li>
<li>其它行跟这个执行序列无关，保持不变</li>
</ol>
<p>这样看起来，数据本身是没有问题的，binlog的内容如下：</p>
<ol>
<li>T2时刻，session B事务提交，写入了两条语句</li>
<li>T4时刻，session C事务提交，写入了两条语句</li>
<li>T6时刻，session A事务提交，写入了<code>update t set d=100 where d=5</code>这条语句</li>
</ol>
<p>汇总后如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/* 所有 d=5 的行， d 改成 100*/</span></span><br></pre></td></tr></table></figure>
<p>这个语句序列，不论是拿到备库去执行，还是以后用binlog克隆，这三行的结果，都变成了（0，5，100）、（1，5，100）和（5，5，100）。也就是说，id=0和id=1这两行，发生了数据不一致，经过分析不难发现，我们只给d=5这一行加了锁，假设我们给扫描过程中碰到的所有行都加上写锁，再观察执行效果：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220103233722467.png" alt="image-20220103233722467" style="zoom:67%;" />
<p>由于session A把所有的行都加上了写锁，所在session B在执行第一个update语句的时候就被锁住了，需要等到T6时刻session A提交以后，session B才能继续执行，这样对于id=0这一行，在数据库里的最终结果还是（0，5，5）。在binlog里面，执行的序列如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/* 所有 d=5 的行， d 改成 100*/</span></span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，按照日志顺序执行，id=0这一行的最终结果也是（0，5，5）。所以，id=0这一行的问题解决了，但同时，id=1这一行，在数据库里面的结果是（1，5，5），而根据binlog的执行结果是（1，5，100），也就是说幻读的问题还是没有解决，那么为什么我们将所有的记录都已经上了锁，还是阻止不了id=1这一行的插入和更新呢？因为在T3时刻，我们在给所有行加锁的时候，id=1这一行还不存在，不存在也就加不上锁，也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录。</p>
<h3 id="间隙锁-2"><a class="markdownIt-Anchor" href="#间隙锁-2"></a> 间隙锁</h3>
<p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此为了解决幻读问题，InnoDB引入了间隙锁（Gap Lock）来解决。顾名思义，间隙锁，锁的就是两个值之间的空隙，比如本节中的表t，初始化插入6个记录，就产生了7个间隙。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220103220303233.png" alt="image-20220103220303233" style="zoom:67%;" />
<p>这样。在执行<code>select * from t where d = 5 for update;</code>的时候，就不止是给数据库已有的6个记录加上了行锁，还同时加了7个间隙锁，这样就确保了无法再插入新的记录，也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空袭，也加上了间隙锁。</p>
<p>虽然间隙锁也是一种锁，但是它和之前介绍过的锁都不太一样，它是加载数据行之间间隙上的，行锁的之间的冲突关系是“另外一个行锁”，但间隙锁不一样，跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作，间隙锁之间不存在冲突关系。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220103220843354.png" alt="image-20220103220843354" style="zoom:67%;" />
<p>这里的session B并不会被阻塞，因为表t中没有c=7这个记录，因此session A加的是间隙锁（5，10），而session B也是再这个间隙加的间隙锁，它们有共同的目标，即：保护这个间隙，不允许插入值，但，它们之间是不冲突的。</p>
<p>间隙锁和行锁合称next-key lock，每个next-key lock是前后闭区间。也就是说，我们的表t初始以后，如果用<code>select * from for update</code>要把整个表所有记录锁起来，就形成了7个next-key lock，分别是(-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20,25]、(25,+supremum]。InnoDB给每个索引加上了一个不存在得最大值supremum，这样就都是前开后闭区间了。</p>
<h1 id="mysql的高可用"><a class="markdownIt-Anchor" href="#mysql的高可用"></a> MySQL的高可用</h1>
<h2 id="防止数据丢失"><a class="markdownIt-Anchor" href="#防止数据丢失"></a> 防止数据丢失</h2>
<h3 id="bin-log的写入机制"><a class="markdownIt-Anchor" href="#bin-log的写入机制"></a> bin log的写入机制</h3>
<p>binlog的吸入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写入到binlog文件中。一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到binlog cache的保存问题，系统给binlog cache分配了一片内存，每个线程一个，参数<code>binlog_cache_size</code>用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。状态图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220210094732836.png" alt="image-20220210094732836" style="zoom:67%;" />
<p>可以看到，每个线程有自己binlog cache，但是共用同一份binlog文件。</p>
<ul>
<li>图中的write，指的就是把日志写入到文件系统的page cache，并没有数据持久化到磁盘，所以速度比较快</li>
<li>图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的IOPS</li>
</ul>
<p>write和fsync的时机，是由参数sync_binlog控制的：</p>
<ol>
<li><code>sync_binlog=0</code>的时候，表示每次提交事务都只write，不fsync</li>
<li><code>sync_binlog=1</code>的时候，表示每次提交事务都会执行fsync</li>
<li><code>sync_binlog=N（N&gt;1）</code>的时候，表示每次提交事务都write，但累积N个事务才fsync</li>
</ol>
<p>因此，在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N的事务的binlog日志。</p>
<h3 id="redo-log的写入机制"><a class="markdownIt-Anchor" href="#redo-log的写入机制"></a> redo log的写入机制</h3>
<p>事务在执行过程中，生成的redo log会先写入到redo log buffer中，并且并不是每次生成后都会持久化到磁盘中。这意味着如果事务执行期间MySQL发生异常重启，那么这部分日志就丢失了，由于事务没有提交，所以这时日志丢了也不会有损失，那么事务还没有提交的时候，redo log buffer中的部分日志有没有可能被持久化到磁盘呢？这就和redo log的三种状态有关：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220210225451762.png" alt="image-20220210225451762" style="zoom:67%;" />
<p>这三种状态分别是：</p>
<ol>
<li>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中红色的部分</li>
<li>写到磁盘（write），但是没有持久化（fsync），物理上是在文件系统的page cache里面，也就是图中的黄色部分</li>
<li>持久化到磁盘，对应的是hard disk，也就是图中绿色部分</li>
</ol>
<p>日志写入到redo log buffer是很快的，write到page cache也差不多，但是持久化到磁盘的速度就慢多了。为了控制redo log的写入策略，InnoDB提供了<code>innodb_flush_log_at_trx_commit</code>参数，它有三种可能取值：</p>
<ul>
<li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中</li>
<li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘</li>
<li>设置为2的时候，表示每次事务提交时都只是把redo log写入到page cache</li>
</ul>
<p>InnoDB有一个后台线程，每个1秒，就会把redo log buffer中的日志，调用write写入到文件系统的page cache，然后调用fsync持久化到磁盘。</p>
<div class="note warning"><p>事务执行中间过程中的redo log也就是直接写在redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的redo log，也是可能持久化到磁盘的。</p></div>
<p>实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中：</p>
<ul>
<li>一种是，redo log buffer占用的空间即将达到<code>innodb_log_buffer_size</code>一半的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘的动作只是write，而没有调用fsync，也就是只留在了文件系统的page cache</li>
<li>并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。假设一个事务A执行到一半，已经写了一些redo log到buffer中，这个时候另外一个线程的事务B提交，如果<code>innodb_flush_log_at_trx_commit</code>设置的是1，那么按照这个参数的逻辑，事务B要把redo log buffer里的日志全部持久化到磁盘。这时候，就会带上事务A在redo log buffer中的日志一起持久化到磁盘。</li>
</ul>
<p>如果把<code>innodb_flush_log_at_trx_commit</code>设置成1，那么redo log在prepaer阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于prepare的redo log，再加上binlog来恢复的。每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到文件系统的page cache中就够了。</p>
<p>通常我们说的MySQL的“双1”配置，指的就是<code>sync_binlog</code>和<code>innodb_flush_log_at_trx_commit</code>都设置成1，也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare阶段），一次是binlog。</p>
<p>MySQL的TPS会高于磁盘的TPS，这是因为MySQL中使用了组提交（group commit）的机制，而要了解组提交首先要了解日志逻辑序列号（log sequence number，LSN）。LSN是单调递增的，用来对应redo log的一个个写入点，每次写入长度为length的redo log，LSN的值就会加上length，LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。</p>
<p>下图表示的是，三个并发事务（trx1，trx2，trx3）在prepare阶段，都写完redo log buffer，持久化到磁盘的过程，对应的LSN分别是50、120和160。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220210234121462.png" alt="image-20220210234121462" style="zoom:67%;" />
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220210234201404.png" alt="image-20220210234201404" style="zoom:67%;" />
<p>从图中可以看到：</p>
<ol>
<li>trx1是第一个到达得，会被选为这组的leader</li>
<li>等trx1要开始写盘的时候，这个组里面已经有了三个事务，这时候LSN也变成了160</li>
<li>trx1去写盘的时候，带的就是LSN=160，因此等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化磁盘</li>
<li>这时候trx2和trx3就可以直接返回了</li>
</ol>
<p>所以，一次组提交里面，组员越多，节约磁盘IOPS效果越好，但如果只有单线程压测，那么就是一个事务对应一次持久化操作了。在并发场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能越多，节约IOPS的效果就越好，为了让一次fsync带的组员更多，MySQL还有另一个优化：拖时间。两阶段提交的示意图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220210235251648.png" alt="image-20220210235251648" style="zoom:67%;" />
<p>其实，写binlog其实是分成两步的：</p>
<ol>
<li>先把binlog从binlog cache中写到磁盘上的binlog文件</li>
<li>调用fsync持久化</li>
</ol>
<p>MySQL为了让组提交的效果更好，把redo log做fsync的时间拖到了步骤1之后。也就是说，上面的图变成了这样：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220210235504487.png" alt="image-20220210235504487" style="zoom:67%;" />
<p>这么以来，binlog也可以组提交了。在执行图5中第4步把binlog fsync到磁盘时，如果有多个事务的binlog已经写完了，也是一起持久化的，这样也可以减少IOPS的消耗。</p>
<p>不过通常情况下第3步执行得会很快，所以binlog得write和fsync间的间隔时间端，导致能集合到一起持久化的binlog比较少，因此，binlog的组提交的效果通常不如redo log的效果那么好，如果想提升binlog组提交的效果，可以通过设置<code>binlog_group_commit_sync_delay</code>和<code>binlog_group_commit_sync_no_delay_count</code>来实现。</p>
<ul>
<li><code>binlog_group_commit_sync_delay</code>表示延迟多少微妙后才调用fsync</li>
<li><code>binlog_group_commit_sync_no_delay_count</code>参数，表示累积多少次以后才调用fsync</li>
</ul>
<p>这两个条件是或的关系，也就是说只要有一个满足条件就会调用fsync，所以，当<code>binlog_group_commit_sync_delay</code>设置为0的时候，<code>binlog_group_commit_sync_no_delay_count</code>也无效了。</p>
<p>综上所述，如果MySQL出现了性能瓶颈，而且瓶颈在IO上，可以通过哪些方法来提升性能呢？</p>
<ul>
<li>设置<code>binlog_group_commit_sync_delay</code>和<code>binlog_group_commit_sync_no_delay_count</code>参数，减少binlog的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险</li>
<li>将<code>sync_binlog</code>设置为大于1的值（比较常见的是100~1000）。这样做的风险是，主机掉电时会丢binlog日志</li>
<li>将<code>innodb_flush_log_at_trx_commit</code>设置为2，这样做的风险时，主机掉电的时候会丢数据</li>
</ul>
<p>不过将<code>innodb_flush_log_at_trx_commit</code>设置成0，当MySQL本身异常重启的话，就会丢失数据。而redo log写到文件系统的page cache的速度也是很快的，所以将这个参数设置成2跟设置0的性能相差并不多，但是设置成2，当MySQL异常重启后就不会丢失数据了。</p>
<h2 id="主备一致"><a class="markdownIt-Anchor" href="#主备一致"></a> 主备一致</h2>
<h3 id="主备的基本原理"><a class="markdownIt-Anchor" href="#主备的基本原理"></a> 主备的基本原理</h3>
<p>下图表示的是基本主备切换流程：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220213170252460.png" alt="image-20220213170252460" style="zoom:67%;" />
<p>在状态1中，客户端的读写都直接访问节点A，而节点B是A的备库，只是将A的更新都同步过来，到本地执行，这样可以保持节点B和A的数据是相同的。当需要切换的时候，就切成状态2，这时候客户端读写访问的都是节点B，而节点A是B的备库。</p>
<p>在状态1中，虽然节点B并没有被直接访问，但是依然建议将节点B（也就是备库）设置成只读（readonly）模式，这样做，有以下考虑：</p>
<ul>
<li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作</li>
<li>防止切换逻辑有bug，比如切换过程中出现双写，造成主备不一致</li>
<li>可以用readonly状态，来判断节点的角色</li>
</ul>
<div class="note info"><p>备库虽然设置了readonly，但readonly对超级（super）权限用户是无效的，而用于同步更新的线程，就拥有超级线程，因此，备库可以和主库保持同步更新。</p></div>
<p>语句在节点A执行，然后同步到节点B的完整示意图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220213171430906.png" alt="image-20220213171430906" style="zoom:67%;" />
<p>可以看到：主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。备库B和主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连接，一个事务日志同步的完整过程如下：</p>
<ol>
<li>在备库B上通过<code>change master</code>命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量</li>
<li>在备库B上执行<code>start slave</code>命令，这时候备库会启动两个线程，就是图中io_thread和sql_thread。其中io_thread负责与主库建立连接</li>
<li>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B</li>
<li>备库B拿到binlog后，写到本地文件，称为中转日志（relay log）</li>
<li>sql_thread读取中转日志，解析出日志里的命令，并执行</li>
</ol>
<p>不过后来由于多线程复制方案的引入，sql_thread演化成为了多个线程。</p>
<h3 id="bin-log的三种格式"><a class="markdownIt-Anchor" href="#bin-log的三种格式"></a> bin log的三种格式</h3>
<p>bin log其实有三种格式：一种是statement，一种是row，还有一种叫做mixed，其实它就是前两种格式的混合。为了便于描述 binlog 的这三种格式间的区别，这里创建了一个表，并初始化几行数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `t_modified` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`), </span><br><span class="line">  KEY `a` (`a`), </span><br><span class="line">  KEY `t_modified`(`t_modified`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;2018-11-13&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">2</span>,<span class="string">&#x27;2018-11-12&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">3</span>,<span class="string">&#x27;2018-11-11&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">4</span>,<span class="number">4</span>,<span class="string">&#x27;2018-11-10&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">5</span>,<span class="string">&#x27;2018-11-09&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>如果要在表中删除一行数据的话，我们来看看这个delete语句的binlog是怎么记录的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> t <span class="comment">/*comment*/</span> <span class="keyword">where</span> a<span class="operator">&gt;=</span><span class="number">4</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;=</span><span class="string">&#x27;2018-11-10&#x27;</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>当<code>binlog_format=statement</code>时，binlog里面记录的就是SQL语句的原文，可以使用命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;master.000001&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>查看binlog中的内容：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220213173317686.png" alt="image-20220213173317686" /></p>
<p>说明如下：</p>
<ul>
<li>第一行<code>SET @@SESSION.GTID_NEXT='ANONYMOUS'</code></li>
<li>第二行是一个BEGIN，跟第四行的commit对应，表示中间是一个事务</li>
<li>第三行是真实执行的语句。可以看到，在真正执行的delete命令之前，还有一个“use test”命令，这是MySQL根据当前要操作的表所在的数据库自行添加的，这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确地更新到test库的表t。在“use test”命令之后的delete语句，就是我们输入的SQL原文，可以看到，binlog“忠实”地记录了SQL命令，甚至连注释也一并记录了</li>
<li>最后一行是一个COMMIT，并且记录了xid=61</li>
</ul>
<p>为了说明statement和row格式的区别，delete命令的执行效果如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220213202550075.png" alt="image-20220213202550075" /></p>
<p>可以看到，运行这条delete命令产生了一个warning，原因是当前binlog设置的是statement格式，并且语句中有limit，所以这个命令可能是unsafe的。为什么会这样呢？这是因为delete带limit，很可能会出现主备数据不一致的情况，比如上面的这个例子：</p>
<ul>
<li>如果delete语句使用的是索引a，那么会根据索引a找到第一个满足条件的行，也就是说删除的是a=4这一行</li>
<li>但如果使用的是索引t_modified，那么删除的就是t_modified='2018-11-09’也就是a=5这一行</li>
</ul>
<p>由于statement格式下，记录到binlog里的是语句原文，因此可能会出现这样一种情况：在主库执行这条SQL语句的时候，用的是索引a，而在备库执行这条SQL语句的时候，却使用了索引t_modified。因此，MySQL认为这样写是有风险的。</p>
<p>将binlog的格式修改为<code>binlog_format='row'</code>,此时，binlog中的内容如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220213203155674.png" alt="image-20220213203155674" /><br />
可以看到，与statement格式的binlog相比，前后的BEGIN和COMMIT是一样的。但是，row格式的binlog里没有了SQL语句的原文，而是替换成了两个event：Table_map和Delete_rows:</p>
<ul>
<li>Table_map event用于说明接下来要操作的表是test库的表t</li>
<li>Delete_rows event用于定义删除的行为</li>
</ul>
<p>通过上图还是不能看出详细的信息，这时候需要借助mysqlbinlog工具，使用如下命令解析和查看binlog中的内容：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog <span class="operator">-</span>w data<span class="operator">/</span>master<span class="number">.000001</span> <span class="comment">--start-position=8900; /** 根据上图，这个事务的binlog是从8900这个位置开始的。 */</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220213203942182.png" alt="image-20220213203942182" /></p>
<p>说明如下：</p>
<ul>
<li>server id 1，表示这个事务是在server_id=1的这个库上执行的</li>
<li>每个event都有CRC32的值，这是因为此时的参数设置<code>binlog_checksum=CRC32</code></li>
<li>Table_map event显示了接下来要打开的表，map到数字226。这里只操作了一张表，如果操作的是多张彪，每个表都有一个对应的Table_map event，都会map到一个单独的数字，用于区分不同表的操作</li>
<li>-w的参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1=4，@2=4这些值）</li>
<li>binlog_row_image的默认配置是FULL，因此Delete_event里面，包含了删掉的行的所有字段的值。如果把binlog_row_image设置为MINIMAL，则只会记录必要的信息，在这个例子里，只会记录<code>id=4</code>这个信息</li>
<li>最后的Xid event，用于表示事务被正确地提交了</li>
</ul>
<p>可以看到，当<code>binlog_format=row</code>的时候，binlog里面记录了真实删除的行的主键id，这样binlog传到备库去的时候，就肯定会删除id=4的行，不会有主备删除不同行的问题。</p>
<p>对比statement和row的优缺点，就有了mixed这种binlog格式存在的场景：</p>
<ul>
<li>因为有些statement格式的binlog可能会导致主备不一致，所以要使用row格式</li>
<li>row格式的缺点是，很占空间。比如，使用delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但是如果row格式的binlog，就要把这10万条记录都写到binlog中，这样做，不仅会占用更大的空间，同时写binlog也要耗费IO资源，影响执行速度</li>
<li>MySQL有一个折中的方案，也就是mixed格式的binlog。MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式</li>
</ul>
<p>总而言之，mixed格式可以利用statement格式的优点，同时又避免了数据不一致的风险。比如上文中的这个例子，设置为mixed，就会记录为row格式，而如果执行的语句去掉limit 1，就会记录为statement格式。</p>
<p>不过，现在越来越多的场景要求将MySQL的binlog格式设置为row，这么做的理由有很多，其中可以直接看出来好处的就是：恢复数据。接下来，我们分别从delete、insert和update这三种SQL语句的角度，来看看数据恢复的问题：</p>
<p>如果执行的是delete语句，row格式的binlog会把删掉的行的整行信息保存起来。所以，如果执行完一条delete语句以后，发现删错数据了，可以直接把binlog中记录的delete语句转为insert，把被错删的数据插入回去就可以恢复了，</p>
<p>类似的，如果是执行错了insert语句，在row格式下，insert语句的binlog会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行。这是，直接把insert语句转成delete语句，删掉这被误插入的一行数据就可以了。</p>
<p>如果执行的update语句，binlog里面会记录修改前整行的数据和修改后的整行数据。所以，如果误执行了update语句的话，只需要把这个event前后的两行信息对调以下，再去数据库里面执行，就能恢复这个更新操作了。</p>
<p>在使用binlog恢复数据的时候，使用mysqlbinlog解析出日志，然后将statement语句直接拷贝出来执行，这种做法可行吗？假设binlog的格式设置为mixed，然后执行如下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">10</span>,<span class="number">10</span>, now());</span><br></pre></td></tr></table></figure>
<p>执行的效果如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220213221234250.png" alt="image-20220213221234250" /></p>
<p>可以看到，MySQL此时使用的statement格式，那么，如果这个binlog过了1分钟才传给备库的话，那主备的数据不就不一致了吗？使用 mysqlbinlog工具查看执行的详情：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220213221344241.png" alt="image-20220213221344241" /></p>
<p>从图中的结果可以看到，binlog在记录event的时候，会多记录<code>SET TIMESTAMP=1546103491</code>，它用<code>SET TIMESTAMP</code>命令约定了接下来<code>now()</code>函数的返回时间。因此，不论这个binlog是1分钟之后被备库执行，还是3天后用来恢复这个库的备库，这个insert语句插入的行，值都是固定的。也就是说，通过<code>SET TIMESTAMP</code>命令，MySQL就确保了主备数据的一致性。</p>
<p>这也就是说直接执行语句的结果可能是错误的，因为有些语句的执行结果是依赖于上下文命令的，所以，使用binlog来恢复数据的标准做法是，用mysqlbinlog工具解析出来，然后把解析结果整个发给MySQL执行，类似下面的命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog master<span class="number">.000001</span> <span class="comment">--start-position=2738 --stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;</span></span><br></pre></td></tr></table></figure>
<p>这个命令的意思是，将master.000001文件里面从第2738字节到2973字节中间这段内容解析出来，放到MySQL去执行。</p>
<h3 id="循环复制问题"><a class="markdownIt-Anchor" href="#循环复制问题"></a> 循环复制问题</h3>
<p>上文中主备的结构实际上是M-S结果，但实际生产上使用比较多的是双M结构，也就是下图所展示的主备切换流程：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220213222320129.png" alt="image-20220213222320129" style="zoom:50%;" />
<p>对比双M结构和M-S结构，其实区别只是多了一条线，即：节点A和B之间总是互为主备关系，这样在切换的时候就不用再修改主备关系。但是，双M结构有一个显著的问题需要解决：</p>
<p>业务逻辑在节点A上更新了一条语句，然后再把生成的binlog发给节点B，节点B执行完这条更新语句后也会生成binlog（<code>log_slave_updates=on</code>），那么，如果节点A同时是节点B的备库，相当于又把节点B新生成的binlog拿过来执行了一次，然后节点A和B间，会不断地循环执行这条更新语句，也就是循环复制了，要解决这个问题，要用到上文中提到的server id：</p>
<ol>
<li>规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系</li>
<li>一个备库接到binlog并在重放的过程中，生成与binlog的server id相同的新的binlog</li>
<li>每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志</li>
</ol>
<p>按照这个逻辑，如果我们设置了双M结构，日志的执行流程就会变成这样：</p>
<ol>
<li>从节点A更新的事务，binlog里面记的都是A的server id</li>
<li>传到节点B执行一次后，节点B生成的binlog的server id也是A的server id</li>
<li>再传回给节点A，A判断这个server id与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了</li>
</ol>
<h2 id="主备延迟"><a class="markdownIt-Anchor" href="#主备延迟"></a> 主备延迟</h2>
<p>正常情况下，只要主库执行更新生成的所有binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终以执行，但是，MySQL要提供高可用能力，只有最终一致性是不够的，上文中提到的双M结构的主备切换流程图如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220313163317617.png" alt="image-20220313163317617" /></p>
<h3 id="主备延迟及其来源"><a class="markdownIt-Anchor" href="#主备延迟及其来源"></a> 主备延迟及其来源</h3>
<p>主备切换可能是一个主动运维动作，比如软件升级、主库所在机器按计划下线等，也可能是被动操作，比如主库所在机器掉电。</p>
<p>首先要明确的一个概念是“同步延迟”，与数据同步有关的时间点主要包括以下三个：</p>
<ul>
<li>主库A执行完成一个事务，写入binlog，我们将这个时刻记为T1</li>
<li>之后传给备库B，我们将备库B接收完这个binlog的时刻记为T2</li>
<li>备库B执行完成这个事务，我们将这个时刻记为T3</li>
</ul>
<p>所谓备库延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。可以在备库上执行<code>show slave status</code>命令，它的返回结果里面会显示：<code>seconds_behind_master</code>，用于表示当前备库延迟了多少秒。它的计算方式如下：</p>
<ul>
<li>每个事务的binlog里面都有一个时间字段，用于记录主库上写入的时间</li>
<li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到<code>seconds_behind_master</code></li>
</ul>
<p>可以看到，其实<code>seconds_behind_master</code>这个参数计算的就是T3-T1.所以，我们可以用<code>seconds_behind_master</code>来作为主备延迟的值，这个值的时间精度是秒。需要注意的是，如果主备库及其的系统时间设置不一致，并不会导致主备延迟的值不准确。因为，备库连接到主库的时候，会通过执行<code>SELECT UNIX_TIMESTAMP()</code>函数来获取当前主库的系统时间，如果这个时候发现主库的系统时间与自己的不一致，备库在执行<code>seconds_behind_master</code>计算的时候会自动扣掉这个差值。</p>
<p>在网络正常的时候，日志从主库传给备库所需的时间是很短的，即T2-T1的值是非常小的。也就是说，网络正常的情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。所以，主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产binlog的速度要慢。</p>
<p>接下来我们分析一下，可能导致主备延迟出现的原因。</p>
<p>第一种情况是，有些部署条件下，备库所在的机器的性能要比主库所在的机器性能差。这里有一个误区是，既然备库没有请求，所以就使用差一点儿的机器，例如，将20个主库放在4台机器上，而把备库集中在一台机器上。但实际上，更新请求对IOPS的压力，在主库和备库是无差别的，这种“非双1”的模式，更新过程中也会触发大量的读操作，所以，当备库主机上的多个备库都在争抢资源的时候，就可能会导致主备延迟了。不过，由于，主备可能发生切换，备库随时可能变成主库，所以主备库选用相同规格的机器，并且做对称部署，是目前比较常见的做法。</p>
<p>第二种情况是，备库的压力大。通常来说，主库提供写能力，备库提供读能力。由于主库直接影响业务，可能使用的时候会比较克制，反而忽视了备库的压力控制。这样做的结果就是，备库上的查询耗费了大量的CPU资源，影响了同步速度，造成了主备延迟。这种情况，可以如下处理：</p>
<ul>
<li>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力</li>
<li>通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力</li>
</ul>
<p>其中，一主多从的方式比较常用，因为作为数据库系统，必须保证要有定期全量备份的能力，而从库，就比较适合来做备份。</p>
<p>第三种情况是大事务。由于主库上必须等事务执行完成才会写入binlog，再传给备库。所以，如果一个主库上执行10分钟，那么事务很有可能就会导致从库延迟10分钟。一次性地使用delete语句删除太多数据，就是一个典型的大事务的场景，比如，一些归档性的数据，平时没有注意删除历史数据，等到空间快满了，业务开发人员要一次性地删掉大量历史数据，这就是一种比较典型的大事务的场景。另一种比较典型的大事务场景，就是大表DDL。</p>
<p>由于主备延迟的存在，所以在主备切换的时候，就相应的有不同的策略。</p>
<h3 id="可靠性优先策略"><a class="markdownIt-Anchor" href="#可靠性优先策略"></a> 可靠性优先策略</h3>
<p>在双M的结构下，从状态1到状态2切换的详细过程如下：</p>
<ol>
<li>判断备库B现在的<code>seconds_behind_master</code>，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步</li>
<li>把主库A改成只读状态，即<code>readonly=true</code></li>
<li>判断备库B的<code>seconds_behind_master</code>的值，直到这个值变成0为止</li>
<li>把备库B改成可读写状态，也就是<code>readonly=false</code></li>
<li>把业务请求切换到备库B</li>
</ol>
<p>这个切换过程就称为可靠性优先策略，执行的流程图如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220313213531273.png" alt="image-20220313213531273" /></p>
<div class="note info"><p>图中SBM是seconds_behind_master的简称</p></div>
<p>可以看到，这个切换流程中是有不可用时间的。因为在步骤2之后，主库A和备库B都处于readonly的状态，也就是说这个时候系统处于不可写状态，直到步骤5完成后才能恢复。在这个不可用状态中，比较耗费时间的是步骤3，可能需要耗费好几秒的时间。这也是为什么需要在步骤1先做判断，确保<code>seconds_behind_master</code>的值足够小。试想如果一开始主备延迟就长达30分钟，而没有先做判断直接切换的话，系统的不可用时间就会长达30分钟，这种情况一般业务都是不可接受的。</p>
<p>如果要避免切换过程中有不可用时间的这个问题，那么可以采用可用性优先的策略，可以将不可能用时间几乎降为0。</p>
<h3 id="可用性优先策略"><a class="markdownIt-Anchor" href="#可用性优先策略"></a> 可用性优先策略</h3>
<p>如果将可靠性优先策略步骤的4、5调整到最开始执行，也就是说，不等主备数据同步，直接把连接切到备库B，并且让备库可以读写，那么系统几乎没有不可用时间了，这个切换流程，就称为可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。下面我们来举例来说明这一点，假设有一个表t：</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB; <span class="keyword">insert</span> <span class="keyword">into</span> t(c) </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">1</span>),(<span class="number">2</span>),(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>这个表定义了一个字增逐渐id，初始化数据后，主库和备库上都是3行数据。接下来，业务人员要继续在表t上执行两条插入语句的命令，依次是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>假设现在主库上有其他的数据表有大量的更新，导致主备延迟达到5秒，在插入一条<code>c=4</code>的语句后，发起了主备切换。下图是<code>binlog_format=mixed</code>时，切换的流程和结果：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220313222405986.png" alt="image-20220313222405986" style="zoom:80%;" />
<p>可以看到，由于采用了可用性优先策略，主库A和备库B上出现了两行不一致的数据。那么，如果设置<code>binlog_format=row</code>情况又会如何呢？</p>
<p>因为row格式在记录binlog的时候，会记录插入的行的所有字段的值，所以最后只会有一行不一致。而且，两边的主备同步的应用线程会报错duplicate key error并停止。也就是说，这种情况下，备库B的（5，4）和主库A的（5，5）这两行数据，都不会被对方执行。详细过程如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220313223114222.png" alt="image-20220313223114222" style="zoom:80%;" />
<p>不难发现：</p>
<ul>
<li>使用row格式的binlog时，数据不一致的问题更容易被发现，而使用mixed或者statement格式的binlog时，数据很可能悄悄地就不一致了。如果过了很久才发现数据不一致的问题，很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致</li>
<li>主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，都应该选择可靠性策略，数据的可靠性一般还是要优于可用性</li>
</ul>
<p>那么时候应该使用可用性优化策略呢？一种场景就是一场切换。假设主库A和备库B的主备延迟是30分钟，这时候主库A掉电了，HA系统要切换B作为主库，通常我们在主动切换的时候，需要等到主备延迟小于5秒的时候再启动切换，但这个时候已经别无选择了。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220313224647402.png" alt="image-20220313224647402" /></p>
<p>采用可靠性优先策略的话，就必须等到备库B的<code>seconds_behind_master=0</code>之后，才能切换，但现在的情况比较严重，系统已经处于完全不可用的状态。我们就必须先切换到备库B，并且设置备库B<code>readonly=false</code>。只切换备库，而不设置备只读也是不行的，因为这段时间内，中转日志还没有应用完成，如果直接发起主备切换，客户端查询看不到之前执行完成的事务，会认为有“数据丢失”。虽然随着中转日志的继续应用，这些数据会恢复回来，但是对于一些业务来说，查询到“暂时丢失数据的状态”也是不能被接受的。</p>
<p>总而言之，在满足数据可靠性的前提下，MySQL高可用系统的可用性，是依赖于主备延迟的，延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。</p>
<h2 id="并行复制"><a class="markdownIt-Anchor" href="#并行复制"></a> 并行复制</h2>
<p>前面的小节中我们介绍过MySQL主备流程图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220315233013490.png" alt="image-20220315233013490" style="zoom:67%;" />
<p>图中两个黑色的箭头，一个箭头代表了客户端写入库，另一个箭头代表的是备库上sql_thread执行中转日志（relay log）。这里使用箭头的粗细来表示并行度，可以看到，第一个箭头明显粗于第二个箭头，这是由于在主库上，各种锁都会影响并发度。</p>
<p>图中备库上sql_thread更新数据（DATA）的过程如果使用的是单线程的话，就会导致备库应用日志不够快，造成主备延迟，在5.6版本之前，MySQL只支持单线程复制，从单线程复制到最新版本的多线程复制，中间演化经历多个版本，不过，所有的多线程复制都符合下面的这个模型：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220315233935209.png" alt="image-20220315233935209" style="zoom:67%;" />
<p>上图中，coordinator就是原来的sql_thread，不过现在它并不再直接更新数据，只负责读取中转日志和分发事务，真正更新日志的，变成了worker线程，work线程的个数，是由参数<code>slave_parallel_workers</code>决定的。</p>
<p>需要注意的是，事务并不能简单的按照轮询的方式分发给各个worker。当事务被分发给worker以后，不同的worker就独立执行了，但是由于CPU的调度策略，第二个事务有可能比第一个事务先执行，而如果这时候刚好这两个事务更新的是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不一致的问题。类似的，同一个事务的多个更新语句，也不能分给多个不同的worker去执行，假设一个事务更新了表t1和t2中的各一行，如果这两条更新语句被分到不同的worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的隔离性。</p>
<p>因此，coordinator在分发的时候，需要满足以下这两个基本要求：</p>
<ul>
<li>更新同一行的事务，必须被分发到同一个worker中</li>
<li>同一个事务不能被拆开，必须放到同一个worker中</li>
</ul>
<p>各个版本的多线程复制，都遵循了这两条基本原则。</p>
<h3 id="按表分发策略"><a class="markdownIt-Anchor" href="#按表分发策略"></a> 按表分发策略</h3>
<p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行，因为数据是存储在表里的，所以按表分发，可以保证两个worker不会更新同一行。不过，如果有跨表的事务，还是要把两张表放在一起，具体如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220316000412695.png" alt="image-20220316000412695" style="zoom:67%;" />
<p>每个worker线程对应一个哈希表，用于保存当前正在这个worker的“执行队列”里的事务所涉及到的表。哈希表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表，当有事务分配给worker的时候，事务里面涉及到的表会被加到对应的哈希表中。worker执行完成后，这个表会被从哈希表中去掉。以上图为例，hash_table_1表示，现在worker_1的“待执行事务队列”里，有4个事务涉及到db1.t1表，有一个事务涉及到db2.t2表，hash_table_2表示，现在worker_2中有一个事务会更新到表t3的数据。</p>
<p>假设在上图的基础上，corrdinator从中转日志中读入下一个新事务T，这个事务修改的行涉及到表t1和t3，那么这个事务T的分配流程如下：</p>
<ol>
<li>由于事务T中涉及修改表t1，而worker_1队列中有事务在修改表t1，事务T和队列中的某个事务要修改同一个表的数据，这种情况下我们认为事务T和worker是冲突的</li>
<li>按照这个逻辑，依次判断事务T和每个worker队列的冲突关系，会发现事务T跟worker_2也冲突</li>
<li>事务T跟多余一个worker冲突，corrdinator线程就进入等待</li>
<li>每个worker继续执行，同时修改哈希表，假设hash_table_2里面涉及到修改表t3的事务先执行完成，就会从hash_table_2中把db1.t3这一项去掉</li>
<li>这样corrdinator会发现跟事务T冲突的worker只有worker_1了，此时，就会将事务T分配给worker_1执行</li>
<li>corrdinator继续读下一个中转日志，继续分配事务</li>
</ol>
<p>也就是说，每个事务在分发的时候，跟所有worker的冲突关系包含以下三种情况：</p>
<ol>
<li>如果跟所有worker都不冲突，corrdinator线程就会把这个事务分配给最闲的worker</li>
<li>如果跟多于一个worker冲突，corrdinator线程就会进入等待状态，直到和这个事务存在冲突关系的worker只剩下一个</li>
<li>如果只跟一个worker冲突，corrdinator线程就会把这个事务分配给这个存在冲突关系的worker</li>
</ol>
<p>这个按表分发的方案，在多个表负载均衡的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到一个表的时候，所有事务都会被分配到同一个worker中，就变成单线程复制了。</p>
<h3 id="按行分发策略"><a class="markdownIt-Anchor" href="#按行分发策略"></a> 按行分发策略</h3>
<p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果是两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求binlog的格式必须是row。</p>
<p>这个时候，我们判断一个事务T和worker是否冲突，用的规则就不是“修改同一个表”，而是“修改同一行”。</p>
<p>按行复制和按表复制的数据结构差不多，也是为每个worker，分配一个哈希表，只要实现按行分发，此时，哈希表的key就必须是“库名+表名+唯一键的值”。但是，这个“唯一键”只有主键id还是不够的，表中t1中除了主键，还有唯一索引a：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`), </span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `a` (`a`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>假设，接下来我们要在主库执行下面这两个事务：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220319231335851.png" alt="image-20220319231335851" /></p>
<p>可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的worker，就有可能session B的语句先执行，这时候<code>id=1</code>的行的a的值还是1，就会报唯一键冲突。因此，基于行的策略，事务哈希表还需要考虑唯一键，即key应该是“库名+表名+索引a的名字+a的值”，比如，在上面这个例子中，要在表t1上执行<code>update t1 set a = 1 where id = 2</code>语句，在binlog里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。因此，corrdinator在解析这个语句的binlog的时候，这个事务的哈希表就有三个项：</p>
<ol>
<li><code>key=hash_func(db1+t1+'PRIMARY'+2), value=2</code>，这里<code>value=2</code>是因为修改前后的行id值不变，出现了两次</li>
<li><code>key=hash_func(db1+t1+'a'+2), value=1</code>，表示会影响到这个表<code>a=2</code>的行</li>
<li><code>key=hash_func(db1+t1+'a'+1), value=1</code>，表示会影响到这个表<code>a=1</code>的行</li>
</ol>
<p>可见，相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源，并且有以下限制：</p>
<ul>
<li>主库的binlog格式必须是row，因为要能够从binlog里面解析出表名、主键值和唯一索引值</li>
<li>表必须有主键</li>
<li>不能有外键，表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准备</li>
</ul>
<p>对比按表分发和按行分发这两个方案，按行分发策略的并行度会更高，不过，如果要操作多行的大事务的话，按行分发的策略有两个问题：</p>
<ol>
<li>耗费内存，例如一个语句要删除100万行数据，这时候哈希表就要记录100万个项</li>
<li>耗费CPU，解析binlog，然后计算哈希值，对于大事务，这个成本比较高</li>
</ol>
<p>所以，按行分发这种策略会设置一个阈值，单个事务如果超过设置的行的阈值（比如，如果单个事务的行数超过10万行），就暂时退化为单线程模式，退化的逻辑大概如下：</p>
<ol>
<li>corrdinator暂时先hold住这个事务</li>
<li>等待所有wroker都执行完成，变成空队列</li>
<li>corrdinator直接执行这个事务</li>
<li>恢复并行模式</li>
</ol>
<div class="note info"><p>按表分发和按行分发策略并没有被合并到官方。</p></div>
<h3 id="mysql-57的并行复制策略"><a class="markdownIt-Anchor" href="#mysql-57的并行复制策略"></a> MySQL 5.7的并行复制策略</h3>
<p>在MySQL5.6的版本中，支持了按库并行的复制策略，在决定分发策略的哈希表中，key就是数据库名。这种策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好。</p>
<p>相比于按表和按行分发，这个策略有两个优势：</p>
<ol>
<li>构造哈希值的时候很快，只需要库名，而且一个实例上DB数也不会很多，不会出现需要构造100万个项这种情况</li>
<li>不要求binlog的格式，因为statement格式的binlog也可以很容易拿到库名</li>
</ol>
<p>但是，如果主库上的表都放在同一个DB里面，这个策略就没有效果了。如果不同DB的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。理论上可以创建不同的DB，把相同热度的表均匀分到这些不同的DB中，强行使用这个策略，不过，这样需要特地异动数据，因此这个策略用的并不多。</p>
<h3 id="mariadb的并行复制策略"><a class="markdownIt-Anchor" href="#mariadb的并行复制策略"></a> MariaDB的并行复制策略</h3>
<p>MariaDB利用了redo log组提交（group commit）优化，而MariaDB的并行复制策略利用这个特性：</p>
<ul>
<li>能够在同一个组里提交的事务，一定不会修改同一行</li>
<li>主库上可以并行执行的事务，备库上也一定是可以并行执行的</li>
</ul>
<p>MariaDB中的并行复制策略：</p>
<ol>
<li>在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1</li>
<li>commit_id直接写到binlog里面</li>
<li>传到备库应用的时候，相同commit_id的事务分到多个worker执行</li>
<li>这一组全部执行完成后，corrdinator再去取下一批</li>
</ol>
<p>这个策略与其他策略不同的地方在于，它的目标是“模拟主库的并行模式”，不过，它并没有实现“真正模拟主库并发度”这个目标。在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。</p>
<p>下图中，假设了三组事务在主库的执行情况，可以看到trx1、trx2和trx3提交的时候，trx4、trx5和trx6是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进入commit状态。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220319234841629.png" alt="image-20220319234841629" style="zoom:67%;" />
<p>而按照MariaDB的并行复制策略，备库上的执行效果如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220319234944025.png" alt="image-20220319234944025" style="zoom:67%;" />
<p>可以看到，在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，这样系统的吞吐量就不够。另外，这个方案很容易被大事务拖后腿。假设trx2是一个超大事务，那么在备库应用的时候，trx1和trx3执行完成后，就只能等trx2完全执行完成，下一组才能开始执行，这段时间，只有一个worker线程在工作，是对资源的浪费，不过即使如此，这个策略仍然是一个令人感到惊艳的创新。</p>
<h3 id="mysql-57的并行复制策略-2"><a class="markdownIt-Anchor" href="#mysql-57的并行复制策略-2"></a> MySQL 5.7的并行复制策略</h3>
<p>在MariaDB实现了并行复制之后，MySQL5.7版本也提供了类似的功能，由参数<code>slave-parallel-type</code>来控制并行复制策略：</p>
<ul>
<li>配置为<code>DATABASE</code>，表示使用MySQL5.6版本的按库并行策略</li>
<li>配置为<code>LOGICAL_CLOCK</code>，表示的就是类似MariaDB的策略。不过，MySQL5.7这个策略，针对并行度做了优化</li>
</ul>
<p>在redo log的两阶段提交中，其实不用等到commit阶段，只要能够达到redo log prepaer阶段，就表示事务已经通过锁冲突的检验了。因此，MySQL5.7并行复制的思想是：</p>
<ul>
<li>同时处于prepare状态的事务，在备库执行时时可以并行的</li>
<li>处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的</li>
</ul>
<p>binlog的组提交中，有这样两个参数：</p>
<ul>
<li><code>binlog_group_commit_sync_delay</code>参数，表示延迟多少微妙后才调用fsync</li>
<li><code>binlog_group_commit_sync_no_delay_count</code>参数，表示累积多少次以后才调用fsync</li>
</ul>
<p>这两个参数用于故意拉长binlog从write到fsync的时间，以此来减少binlog的写盘次数，在MySQL5.7的并行复制策略里，它们可以用来制造更多的“同时处于prepare阶段的事务”，这样就增加了备库复制的并行度。也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些，在MySQL5.7处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。</p>
<p>在MySQL5.7.22的版本里，有新增了一个基于WRITESET的并行复制，相应地，增加了一个参数<code>binlog-transaction-dependency-tracking</code>，用来控制是否启动这个新策略，这个参数的可选值有以下三种：</p>
<ul>
<li><code>COMMIT_ORDER</code>表示根据同时进入prepare和commit来判断是否可以并行的策略</li>
<li><code>WRITESET</code>表示的对于事务涉及更新的每一行，计算出这一行的哈希值，组成集合writeset，如果两个事务没有操作相同的行，也就是说它们的writeset没有交集，就可以并行</li>
<li><code>WRITESET_SESSION</code>，是在writeset的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序</li>
</ul>
<p>当然为了唯一标识，这个哈希值是通过“库名+表名+索引名+值”计算出来的，如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert语句对应的writeset就要多增加一个哈希值。</p>
<p>可以看到，这种策略与按行分发的策略比较类似，不过这个实现有以下优势：</p>
<ul>
<li>writeset是在主库生成后直接写入binlog里面的，这样在备库执行的时候，不需要解析binlog里面的内容（event里的行数据），节省了很多计算量</li>
<li>不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker，更省内存</li>
<li>由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的</li>
</ul>
<p>当然，对于“表上没有主键”和“外键约束”的场景，writeset策略也是没法并行的，也会暂时退化为单线程模型。</p>
<h2 id="一主多从"><a class="markdownIt-Anchor" href="#一主多从"></a> 一主多从</h2>
<p>大多数的互联网应用都是读多写少，因此，在业务不断发展的过程中，很可能会先遇到读性能的问题，而在数据层解决读性能问题，就会涉及到一主多从的架构。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220320123410458.png" alt="image-20220320123410458" style="zoom:67%;" />
<p>图中，虚线箭头表示的是主备关系，也就是A和A<sup>’</sup>互为主备，从库B、C、D指向的是主库A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。</p>
<p>在一主多从的架构下，主库故障后的主备切换流程如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220320125816253.png" alt="image-20220320125816253" style="zoom:67%;" />
<p>相比于一主一备的切换流程，一主多从的结构在切换完成后，A<sup>’</sup>会称为新的主库，从库B、C、D也要改接到A<sup>’</sup>，正是由于多了从库B、C、D重新指向的这个过程，所以主备切换的复杂性也相应增加了。</p>
<h3 id="基于位点的主备切换"><a class="markdownIt-Anchor" href="#基于位点的主备切换"></a> 基于位点的主备切换</h3>
<p>当我们把节点B设置成节点A<sup>’</sup>的从库的时候，需要执行一条<code>change master</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$password </span><br><span class="line">MASTER_LOG_FILE=$master_log_name </span><br><span class="line">MASTER_LOG_POS=$master_log_pos</span><br></pre></td></tr></table></figure>
<p>这条命令有6个参数，其中：</p>
<ul>
<li>前四个参数分别代表了A<sup>’</sup>的IP、端口、用户名和密码</li>
<li>最后两个参数分别表示，要从主库的<code>master_log_name</code>文件的<code>master_log_pos</code>这个位置的日志继续同步，而这个位置就是我们所说的同步位点，也就是主库对应的文件名和日志偏移量。</li>
</ul>
<p>当节点B要设置成A<sup>’</sup>的从库，就要执行<code>change master</code>命令，就不可避免的要设置位点的这两个参数。原来节点B是A的从库，本地记录的也是A的微店，但是相同的日志，A的位点和A<sup>’</sup>的位点是不同的。因此，从库B要切换的时候，都需要经过”找同步位点“这个逻辑，但是这个位点很难精确取到，只能取到一个大概位置。</p>
<p>考虑到切换过程中不能丢失数据，所以在确定位点的时候，总是要找一个”稍微往前“的，然后再通过判断跳过那些在从库B上已经执行过的事务，一种取位点的方法是这样的：</p>
<ol>
<li>
<p>等待新主库A<sup>’</sup>把中转日志（relay log）全部同步完成</p>
</li>
<li>
<p>在A<sup>’</sup>上执行<code>show master status</code>命令，得到当前A<sup>’</sup>上最新的File和Position</p>
</li>
<li>
<p>取原主库A故障的时刻T</p>
</li>
<li>
<p>用mysqlbinlog工具解析A<sup>’</sup>的File，得到T时刻的位点</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog File <span class="comment">--stop-datetime=T --start-datetime=T</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220320131636375.png" alt="image-20220320131636375" /></p>
</li>
</ol>
<p>图中，end_log_pos后面的值“123”，表示的就是A<sup>’</sup>这个实例，在T时刻写入新的binlog的位置，那么，我们就可以把123这个作为$master_log_pos的值。</p>
<p>不过，这样得到的$master_log_pos的值并不精确。假设在T这个时刻，主库A已经执行完成了一个insert语句插入了一行数据R，并且已经将binlog传给了A<sup>’</sup>和B，然后在传完的瞬间主剧A的主机就掉电了。此时，系统的状态是这样的：</p>
<ol>
<li>在从库B上，由于同步了binlog，R这一行已经存在</li>
<li>在新主库A<sup>’</sup>上，R这一行已经存在，日志是写在123这个位置之后的</li>
<li>此时，在从库B上执行<code>change_master</code>命令，指向A<sup>’</sup>的File文件的123位置，就会把插入R这一行数据的binlog又同步到从库B去执行</li>
</ol>
<p>这个时候，从库B的同步线程就会出现Duplicate entry ‘id_of_R’ for key 'PRIMARY’错误，提示出现了主键冲突，然后停止同步。</p>
<p>所以，通常情况下，在切换任务的时候，要先主动跳过这些错误，有两种常用的方法，一种做法是，主动跳过一个事务，跳过命令的写法是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> sql_slave_skip_counter<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>
<p>因为切换过程中，可能会不止重复执行一个事务，所以需要在从库B刚开始接到新主库A<sup>’</sup>时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。</p>
<p>另一方式时，通过设置<code>slave_skip_errors</code>参数，直接设置跳过指定的错误，在执行主备切换时，有两种比较常见的错误：</p>
<ul>
<li>1062错误是插入数据时唯一键冲突</li>
<li>1032错误是删除数据时找不到行</li>
</ul>
<p>因此，我们可以把<code>slave_skip_errors</code>设置为“1032，1062”，这样中间碰到这两个错误时就直接跳过。</p>
<p>需要注意的是，这种直接跳过指定错误的方法，针对的是主备切换时，由于找不到精确的同步位点，所以只能采用这种方法来创建从库和新主库的主备关系。这么操作的前提是，我们很清楚在主备切换过程中，直接跳过1032和1062这两类错误是无损的，才可以设置<code>slave_skip_errors</code>参数，等到主备间的同步关系建立完成，并稳定执行一段时间之后，我们还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。</p>
<h3 id="gtid"><a class="markdownIt-Anchor" href="#gtid"></a> GTID</h3>
<p>通过<code>sql_slave_skip_counter</code>跳过事务和通过<code>slave_skip_errors</code>忽略错误的方法，虽然都最终可以建立从库B和新主库A<sup>’</sup>的主备关系，但这两种操作都很复杂，而且容易出错。所以，MySQL5.6版本引入了GTID，彻底解决了这个问题。</p>
<p>GTID的全称是Global Transaction Identifier，也就是全局事务ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">GTID<span class="operator">=</span>source_id:transaction_id</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>ƒsource_id是一个实例第一次启动时自动生成的，是一个全局唯一的值</li>
<li>transaction_id是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1</li>
</ul>
<div class="note info"><p>这里的transaction_id与我们通常讲的事务id有所区别，事务id是在事务执行过程中分配的，如果这个事务回滚了，事务id也会递增，而这里transaction_id只有在事务提交的时候才会分配。</p></div>
<p>GTID模式的启动需要在启动MySQL实例的时候，添加参数<code>gtid_mode=on</code>和<code>enforce_gtid_consistency=on</code>。在GTID模式下，每个事务都会跟一个GTID一一对应。这个GTID有两种生成方式，而使用哪种方式取决于session变量gtid_next的值：</p>
<ul>
<li>如果<code>gtid_nex=automatic</code>，代表使用默认值，这时，MySQL就会把<code>source_id:transaction_id</code>分配给这个事务
<ul>
<li>记录binlog的时候，先记录一行<code>SET@SESSION.GTID_NEXT='source_id:transaction_id'</code></li>
<li>把这个GTID加入本实例的GTID集合</li>
</ul>
</li>
<li>如果<code>gtid_next</code>是一个指定的GTID的值，比如通过<code>set gtid_next='current_gtid'</code>指定为current_gtid，那么就有两种可能：
<ul>
<li>如果current_gtid已经存在于实例的GTID集合中，接下来执行的这个事务会直接被系统忽略</li>
<li>如果current_gtid没有存在于实例的GTID集合中，就将这个current_gtid分配给接下来要执行</li>
</ul>
</li>
</ul>
<p>这样，每个MySQL实例都维护了一个GTID集合，用来对应“这个实例执行过的所有事务”，接下来我们通过例子来说明这一点。</p>
<p>首先在实例X中创建表t：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220320221847024.png" alt="image-20220320221847024" /></p>
<p>可以看到，事务的BEGIN之前有一条<code>SET SESSION.GTID_NEXT</code>命令。这时，如果实例X有从库，那么将<code>CREATE TABLE</code>和<code>insert</code>语句的binlog同步过去执行的话，执行事务之前就会先执行这两个SET命令，这样被加入从库的GTID集合的，就是图中的这两个GTID。假设，现在这个实例X是另外一个实例Y的从库，并且此时在实例Y上执行下面的这条插入语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>并且，这条语句在实例Y上的GTID是“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。那么，实例X作为Y的从库，就要同步这个事务过来执行，显然会出现主键冲突，导致实例X的同步线程停止，这时，我们可以执行如下语句序列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> gtid_next<span class="operator">=</span><span class="string">&#x27;aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10&#x27;</span>; <span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">set</span> gtid_next<span class="operator">=</span>automatic;</span><br><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>
<p>其中，前三条语句的作用，是通过提交一个空事务，把这个GTID加到实例X的GTID集合中。下图表示了执行完这个空事务之后的<code>show master status</code>的结果：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220320222841433.png" alt="image-20220320222841433" /></p>
<p>可以看到实例X的Executed_Gtid_set里面，已经加入了这个GTID，这样，我再执行<code>start slave</code>命令让同步线程执行起来的时候，虽然实例X还是会继续执行实例Y传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”已经存在于实例X的GTID集合中了，所以实例X就会直接跳过这个事务，也就不会再出现主键冲突的错误。</p>
<p>在上面的这个语句序列中，<code>start slave</code>命令之前还有一行<code>set gtid_next=automatic</code>。这句话的作用是“恢复GTID的默认分配行为”，也就是说如果之后有新的事务再执行，就还是按照原来的分配方式，继续分配<code>transaction_id=3</code>。</p>
<p>在GTID模式下，备库B要设置为新主库A<sup>’</sup>的从库的语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$password </span><br><span class="line">master_auto_position=1</span><br></pre></td></tr></table></figure>
<p>其中，<code>master_auto_position=1</code>就表示这个主备关系使用的是GTID协议，使用这种方式，就无须设置<code>MASTER_LOG_FILE</code>和<code>MASTER_LOG_POS</code>这两个参数了。</p>
<p>现在，将实例A<sup>’</sup>的GTID的集合记为set_a，实例B的GTID集合记为set_b，那么在实例B上执行<code>start slave</code>命令，取binlog的逻辑如下：</p>
<ol>
<li>实例B指定主库A<sup>’</sup>，基于主备协议建立连接</li>
<li>实例B吧set b发给主库A<sup>’</sup></li>
<li>实例A<sup>’</sup>算出set_a与set_b的差集，也就是所有存在于set_a，但是不存在于set_b的GTID的集合，判断A<sup>’</sup>本地是否包含了这个差集需要的所有binlog事务
<ul>
<li>如果不包含，表示A<sup>’</sup>已经把实例B需要的binlog给删掉了，直接返回错误</li>
<li>如果确认包含全部，A<sup>’</sup>从自己的binlog文件里面，找出第一个不在set_b的事务，发给B</li>
</ul>
</li>
<li>之后就从这个事务开始，往后读文件，按顺序取binlog发给B去执行</li>
</ol>
<p>其实，这个逻辑里面包含了一个设计思想：在基于GTID的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的，因此，如果实例B需要的日志已经不存在，A<sup>’</sup>就拒绝把日志发给B。这跟基于位点的主备协议不同，基于位点的协议，是由备库决定的，备库指定哪个点位，主库就发哪个位点，不做日志的完整性判断。</p>
<p>在引入GTID之后，一主多从的切换场景下，主备切换就变成了：由于不需要找位点了，所以从库B、C、D只需要分别执行<code>change master</code>命令执行实例A<sup>’</sup>即可。其实，严谨地说，主备切换不是不需要找位点了，而是找位点的这个工作，在实例A<sup>’</sup>内部就已经自动完成了，但由于这个工作是自动的，所以对HA系统的开发人员来说，非常友好。之后这个系统就由新主库A<sup>’</sup>写入，主库A<sup>’</sup>的自己生成的binlog中的GTID集合格式是：<code>source_id_of_A&lt;sup&gt;'&lt;/sup&gt;:1-M</code>。如果之前从库B的GTID集合格式是<code>source_id_of_A&lt;sup&gt;'&lt;/sup&gt;:1-N</code>，那么切换之后GTID集合的格式就变成了<code>source_id_of_A&lt;sup&gt;'&lt;/sup&gt;:1-N，source_id_of_A&lt;sup&gt;'&lt;/sup&gt;:1-M</code>。由于主库A<sup>’</sup>之前也是A的备库，因此主库A<sup>’</sup>和从库B的GTID集合是一样的。这样就达到了我们的预期。</p>
<h2 id="读写分离"><a class="markdownIt-Anchor" href="#读写分离"></a> 读写分离</h2>
<p>读写分离的主要目标就是分摊主库的压力，上文提到的一主多从的架构师客户端主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由客户端来选择后端数据库进行查询。还有一种架构是，在MySQL和客户端之间有一个中间代理层proxy，客户端只连接proxy，由proxy根据请求类型和上下文决定请求的分发路由。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220320232030366.png" alt="image-20220320232030366" /></p>
<p>客户端直连和带proxy的读写分离架构的优劣势：</p>
<ol>
<li>客户端直连方案，因为少了一层proxy转发，所以查询性能更好，并且整体架构简单，排查问题更方便。不过这种方案，由于要了解后端的部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。</li>
<li>带proxy的结构，对客户端比较友好。客户端无需关心后端的细节，连接维护、后端信息维护等工作，都是由proxy完成。不过，这样对后端维护团队的要求会更高，而且，proxy也需要有高可用架构，因此，带proxy架构的整体就相对比较复杂</li>
</ol>
<p>不论采用哪种架构，都会碰到“过期读”的问题，即由于主从可能存在延迟，客户端执行完 一个更新事务马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。</p>
<p>处理这种”过期读“的问题，大致有以下几种方案：</p>
<ul>
<li>强制走主库方案</li>
<li>sleep方案</li>
<li>判断主备无延迟方案</li>
<li>配合semi-sync方案</li>
<li>等主库位点方案</li>
<li>等GTID方案</li>
</ul>
<h3 id="强制走主库方案"><a class="markdownIt-Anchor" href="#强制走主库方案"></a> 强制走主库方案</h3>
<p>强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为两类：</p>
<ul>
<li>对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品后，马上要返回主页面，查看商品是否发布成功，那么这个请求需要拿到最新的结果，就必须走主库</li>
<li>对于可以读到就数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的，那么，这类请求就可以走从库</li>
</ul>
<p>当然，这个方案最大的问题在于，有时候会碰到所有的查询都不能是过期读的需求，比如一些金融类的业务。这样的话，就要放弃读写分离，所有读压力都在主库，等同于放弃了扩展性。</p>
<h3 id="sleep-方案"><a class="markdownIt-Anchor" href="#sleep-方案"></a> sleep 方案</h3>
<p>这个方案的做法是，在主库更新后，读从库之前先sleep一下。具体的方案就是，类似于执行一条<code>select sleep(1)</code>命令。这个方案的假设是，大多数情况下主备延迟在1秒内，做一个sleep可以有很大概率拿到最新的数据。</p>
<p>还是以卖家发布商品为例，商品发布后，用Ajax直接把客户端输入的内容作为“新的商品”显示在页面上，而不是真正地去数据库查询，这样，买家就可以通过这个现实，来确认产品已经发布成功了。等到卖家再刷新页面，去查看商品的时候，其实已经过了一段时间，也就达到了sleep的目的，进而也就解决了过期读的问题。</p>
<p>也就是说，这个sleep方案确实解决了类似场景下的过期读问题，但是也存在两个问题：</p>
<ul>
<li>如果这个查询请求本来0.5秒就可以在从库上拿到正确结果，也会等1秒</li>
<li>如果延迟超过1秒，还是会出现过期读</li>
</ul>
<h3 id="判断主备无延迟方案"><a class="markdownIt-Anchor" href="#判断主备无延迟方案"></a> 判断主备无延迟方案</h3>
<p>要判断备库无延迟，通常有三种做法。</p>
<p>第一种确保主备无延迟的方法是，每次从库执行查询请求前，先判断<code>seconds_behind_master</code>是否已经等于0，如果还不等于0，那就必须等待这个参数变为0才能执行查询请求。<code>seconds_behind_master</code>的单位是秒，如果觉得精度不够，就可以采用位点和GTID的方法来确保主备无延迟。</p>
<p>第二种方法是，对比位点确保主备无延迟：</p>
<ul>
<li><code>Master_Log_File</code>和<code>Read_Master_Log_Pos</code>，表示的是读到的主库的最新位点</li>
<li><code>Relay_Master_Log_File</code>和<code>Exec_Master_Log_Pos</code>，表示的是备库执行的最新位点</li>
</ul>
<p>如果<code>Master_Log_File</code>和<code>Read_Master_Log_Pos</code>，<code>Relay_Master_Log_File</code>和<code>Exec_Master_Log_Pos</code>这两组值完全相同，就表示接收到的日志已经同步完成。</p>
<p>第三种方法是，对比GTID集合确保主备无延迟：</p>
<ul>
<li><code>Auto_Position=1</code>，表示这对主备关系使用了GTID协议</li>
<li><code>Retrieved_Gtid_Set</code>，是主备收到的所有日志的GTID集合</li>
<li><code>Executed_Gtid_Set</code>，是备库所有已经执行完成的GTID集合</li>
</ul>
<p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。</p>
<p>可见，对比位点和对比GTID这两种方法，都比判断<code>seconds_behind_master</code>是否为0更精确。在执行查询请求之前，先判断从库是否同步完成的方法，相比于sleep方法，准确度确实提升了不少，但还是没有达到“精确”的程度。一个事务的binlog在主备之间流转的状态如下：</p>
<ol>
<li>主库执行完成，写入binlog，并反馈给客户端</li>
<li>binlog被从库发送给备库，备库收到</li>
<li>在备库执行binlog完成</li>
</ol>
<p>三种讨论的判断主备无延迟的逻辑，都是“备库收到的日志都执行完成了”。但是，从binlog在主备之间状态的分析中，可以看到还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态，如下图：</p>
<p>![image-20220325100353640](/Users/jiyongchao/Library/Application Support/typora-user-images/image-20220325100353640.png)</p>
<p>这时，主库上执行完成了三个事务trx1、trx2和trx3，其中：</p>
<ol>
<li>trx1和trx2已经传到从库，并且已经执行完成了</li>
<li>trx3在主库执行完成，并且已经回复给客户端，但是还没有传到从库中</li>
</ol>
<p>如果这时候在从库B上执行查询请求，按照上面提到的判断方法，从库会认为已经没有同步延迟，但还是查不到trx3的。严格地说，就是出现了过期读。</p>
<p>要解决这个问题，就要引入半同步复制，也就是semi-sync replication，semi-sync的设计如下：</p>
<ol>
<li>事务提交的时候，主库把binlog发给从库</li>
<li>从库收到binlog以后，发回给主库一个ack，表示收到了</li>
<li>主库收到这个ack以后，才能给客户端返回“事务完成”的确认</li>
</ol>
<p>也就是说，如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。这样，结合前面关于位点的判断，就能够确定在从库上执行的查询请求吗，可以避免过期读。</p>
<p>不过，semi-sync+位点判断的方案，只对一主一备的场景是成立的。在一主多从的场景中国呢，主库只要等到一个从库的ack，就开始给客户端返回确认，这时，在从库上执行查询请求，就有两种情况：</p>
<ol>
<li>如果查询是落在这个相应ack的从库上，是能确保读到最新数据</li>
<li>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题</li>
</ol>
<p>另外，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者GTID集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况，示意图如下：</p>
<p>上图中备库B下的虚线框，分别表示relay log和binlog中的事务，可以看到，备库从状态1到状态4都和主库A存在延迟，如果使用上面提到的策略，必须要等到无延迟才能查询的方案，selelct语句直到状态4都不能执行。</p>
<p>总而言之，semi-sync配合判断主备无延迟的方案，存在两个问题：</p>
<ul>
<li>一主多从的时候，在某些从库执行查询请求会存在过期读的现象</li>
<li>在持续延迟的情况下，可能出现过度等待的问题</li>
</ul>
<p>仔细观察可以发现，客户端是在发完trx1更新后发起的select语句，其实只要确保trx1已经执行完成就可以执行select语句了，也就是说在状态3执行查询请求，得到的就是预期结果了，这就是等主库位点方案。</p>
<h3 id="等主库位点方案"><a class="markdownIt-Anchor" href="#等主库位点方案"></a> 等主库位点方案</h3>
<p>要理解等主库位点方案，首先要了解一条命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> master_pos_wait(file, pos[,timeout]);</span><br></pre></td></tr></table></figure>
<p>它的逻辑如下：</p>
<ul>
<li>它是在从库执行的</li>
<li>参数file和pos指的是主库上的文件名和位置</li>
<li>timeout可选，设置为正整数N表示这个函数最多等待N秒</li>
</ul>
<p>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。当然，除了正常返回一个正整数M外，还会返回一些其他结果，包括：</p>
<ul>
<li>如果执行期间，备库同步线程发生异常，则返回NLL</li>
<li>如果等待超过N秒，就返回-1</li>
<li>如果刚开始执行的时候，就已经执行过这个位置了，则返回0</li>
</ul>
<p>上文中的例子，就可以使用这个逻辑：</p>
<ol>
<li>trx1事务更新完成后，马上执行<code>show master status</code>得到当前主库执行到的File和Position</li>
<li>选定一个从库执行查询语句</li>
<li>在从库上执行<code>select master_pos_wait(File,Position,1);</code></li>
<li>如果返回值是大于等于0的正整数，则在这个从库执行查询语句</li>
<li>否则，到主库执行查询语句</li>
</ol>
<p>这个过程的流程图如下：</p>
<p>这里假设这条select查询最多在主库上等待1秒，那么1秒内<code>master_pos_wait</code>返回一个大于等于0的整数，就确保了主库上执行的这个查询结果一定包含了trx1的数据。</p>
<p>其中步骤5到主库执行查询语句，是这类方案常用的退化机制，因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。这样带来的问题是，如果所有的从库都延迟超过1秒了，那查询的压力都会跑到主库上。在不允许过期读的要求下，只有两种选择，一种是超时放弃，一种是转到主库查询，至于具体选择哪一种，取决于业务场景。</p>
<h3 id="gid方案"><a class="markdownIt-Anchor" href="#gid方案"></a> GID方案</h3>
<p>如果数据库开启了GTID模式，对应的也有等待GTID的方案，MySQL中提供了一个类似的命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> wait_for_executed_gtid_set(gtid_set,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这条命令的逻辑是：</p>
<ol>
<li>等待，直到这个库执行的事务中包含传入的gtid_set，返回0</li>
<li>超时返回1</li>
</ol>
<p>在等位点的方案中，我们执行完事务后，还要主动去主库执行<code>show master status</code>。而MySQL5.7.6版本开始，允许在执行更新类事务，把这个事务的GTID返回给客户端，这样等GTID的方案就可以减少一次查询，这时，执行流程就变成了：</p>
<ol>
<li>trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1</li>
<li>选定一个从库执行查询语句</li>
<li>在从库上执行<code>select wait_for_executed_gtid_set(gtid1,1)</code></li>
<li>如果返回值是0，则在这个从库执行查询语句</li>
<li>否则，到主库执行查询语句</li>
</ol>
<p>整个过程的流程图如下：</p>
<p>第一步中，trx1事务更新完成后，从返回包获取这个事务的GTID，需要将MySQL的参数设置为<code>session_track_gtids=OWN_GTID</code>，然后通过API接口<code>mysql_session_track_get_first</code>从返回包解析出GTID的值即可。</p>
<h2 id="可用性判断"><a class="markdownIt-Anchor" href="#可用性判断"></a> 可用性判断</h2>
<p>本小节我们要讨论的是，如何判断一个主库出了问题。</p>
<h3 id="select-1判断"><a class="markdownIt-Anchor" href="#select-1判断"></a> select 1判断</h3>
<p>最简单直接的方法就是执行<code>select 1</code>，如果<code>select 1</code>成功返回了，就表示主库没有问题。实际上，<code>select 1</code>成功返回，只能说明这个库的进程还在，并不能说明主库没问题，为了说明这个问题，我们创建表t：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_thread_concurrency <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这里我们设置<code>innodb_thread_concurrency</code>参数的目的是，控制InnoDB的并发线程上限。也就是说，一旦并发线程数达到这个值，InnoDB在接收到新请求的时候，就会进入等待状态，直到有线程退出。</p>
<p>这里设置<code>innodb_thread_concurrency=3</code>表示InnoDB只允许3个线程并发执行。在这个例子中，前三个session中的sleep（100），使得这三个语句都处于“执行”状态，以此来模拟大查询。在session D中，<code>select 1</code>可以成功，但是查询表t的语句会被阻塞，也就是说，如果这时使用<code>select 1</code>是检测不出问题的。</p>
<p>在InnoDB中，<code>innodb_thread_concurrency</code>这个参数的默认值是0，表示不限制并发线程数量。但是，不限制并发线程数肯定是不行的，因为，一个机器的CPU核数有限，如果不加以限制，线程数过高，会导致上下文切换的成本会过高。通常情况下，<code>innodb_thread_concurrency</code>可以设置为64～128之间的值。</p>
<p>需要额外说明的是，并发连接和并发查询并不是同一个概念，使用<code>show processlist</code>的结果里看到的几千个连接，指的就是并发连接，而“当前正在执行”的语句，才是所谓的并发查询。并发连接数达到几千个影响并不大，就是会多占一些内存，但是并发查询过高会占用过多资源，这就是我们为什么要设置<code>innodb_thread_concurrency</code>参数的原因。</p>
<p>假设我们设置<code>innodb_thread_concurrency=128</code>，那么如果出现同一行热点更新的问题时，会不会很快就把128消耗完呢？实际上，在线程进入锁等待以后，并发线程的计数会减一，也就是说等行锁（包括间隙锁）的线程时不算在128里面的。MySQL这样设计的原因是，进入锁等待的线程已经不吃CPU了，更重要的是，必须这么设计，才能避免整个系统锁死，假设有如下场景：</p>
<ol>
<li>线程1执行<code>begin; update t set c = c + 1 where id = 1;</code>，启动了事务trx1，然后保持这个状态。这时候，线程处于空闲状态，不算在并发线程里面</li>
<li>线程2到线程129都执行<code>update t set c = c + 1 where id = 1;</code>，由于等行锁，进入等待状态，这样就有128个线程处于等待状态</li>
<li>如果处于锁状态的线程技术不减一，InnoDB就会认为线程数用满了，会阻止其他语句进入引擎执行，这样线程1不能提交事务。而另外的128个线程又处于锁等待状态，整个系统就阻塞了</li>
</ol>
<p>具体过程如下图：</p>
<p>这时候InnoDB不能响应任何请求，整个系统被锁死。而且，由于所有线程处于等待状态，此时占用的CPU却是0，而这明显不合。所以InnoDB在设计时，遇到进程进入锁等待的情况时，将并发线程的计数减1的设计，是合理而且必要的。</p>
<p>虽然说等锁的线程不算在并发线程计数里，但如果它在真正地执行查询，比如上面例子中的<code>select sleep(100) from t</code>，还是要算进并发线程的计数的。</p>
<p>在这个例子中，同时执在执行的语句超过了设置的<code>innnodb_thread_concurrency</code>的值，这时候系统其实已经不正常了，但是通过<code>select 1</code>来检测系统，会认为系统还是正常的。</p>
<h3 id="查表判断"><a class="markdownIt-Anchor" href="#查表判断"></a> 查表判断</h3>
<p>为了能够检测InnoDB并发线程数过多导致的系统不可用的情况，我们需要找一个访问InnoDB的场景。一般的做法是，在系统库（mysql库）里创建一个表，比如命名为health_check，里面只放一行数据，然后定期执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.health_check;</span><br></pre></td></tr></table></figure>
<p>使用这个方法，我们可以检测出由于并发线程过多导致的数据库不可用的情况。但是，这种做法也存在一个问题，更新事务要写入binlog，当binlog所在磁盘的空间占用率达到100%，那么所有的更新语句和事务提交的commit语句就都会被堵住，但是这个时候系统还是可以正常读取数据的，因此，我们需要把这条查询语句修改成更新语句。</p>
<h3 id="更新判断"><a class="markdownIt-Anchor" href="#更新判断"></a> 更新判断</h3>
<p>既然要更新，就要放个有意义的字段，常见的做法是放一个timestamp字段，用来表示最后一次执行检测的时间：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update mysql.health_check <span class="keyword">set</span> t_modified<span class="operator">=</span>now();</span><br></pre></td></tr></table></figure>
<p>节点可用性的检测都应该包含主库和备库。如果用来检测主库的话，那么备库也要进行更新检测。但是，备库的检测也是要写bin log的，由于我们一般会把数据库A和B的主备关系设计为双M结构，所以在备库B傻姑娘执行的检测命令，也要发回给主库A。</p>
<p>但是，如果主库A和备库B都用相同的更新命令，就可能出现行冲入，也就是可能会导致主备同步停止，因此，mysql.health_check这个表需要再加一行。为了让主备之间的更新不产生冲突，我们可以在mysql.health_check表上存入多行数据，并且用A、B的server_id做主键。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `health_check` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `t_modified` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检测命令 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql.health_check(id, t_modified) </span><br><span class="line"><span class="keyword">values</span> (@<span class="variable">@server</span>_id, now()) <span class="keyword">on</span> duplicate key update t_modified <span class="operator">=</span> <span class="keyword">no</span></span><br></pre></td></tr></table></figure>
<p>由于MySQL规定了主库和备库的server_id必须不同（否则创建主备关系的时候就会报错），这样就可以保证主、备库各自的检测命令不会发生冲突。</p>
<p>更新判断是一个相对比较常用的方案，不过依然存在一些问题，其中，“判定慢”是最主要的问题。</p>
<p>首先，所有的检测逻辑都需要一个超时时间N，执行一条update语句，超过N秒后还不返回，就认为系统不可用。假设一个日志盘的IO利用率已经是100%了，这个时候，整个系统的响应非常慢，已经需要做主备切换了。但是IO利用率100%表示系统的IO是正在工作的，每个请求都有机会获得IO资源，执行自己的任务。而update语句，需要的资源很少，所以可能在拿到IO资源的时候就可以提交成功，并且在超时时间N秒未达到之前就返回给了检测系统。检测系统发现，update命令没有超时，于是得到了“系统正常”的结论。</p>
<p>之所以出现这个现象，根本原因是上文中提到的所有方法，都是基于外部检测的。外部检测天然有一个问题，就是随机性。因为外部检测都需要定时轮询，所以系统可能已经出问题了，但是却需要等到下一个检测发起执行语句的时候，才有可能发现为你。而且，如果运气不够好的话，可能第一次轮询还不能发现，这就会导致切换慢的问题。</p>
<h3 id="内部统计"><a class="markdownIt-Anchor" href="#内部统计"></a> 内部统计</h3>
<p>内部统计的方案主要是要利用磁盘利用率，在MySQL5.6以后提供的preformance_schema库，在file_summary_by_event_name表里统计了每次IO请求的时间，根据MySQL5.6内部每一次IO请求的时间来判断数据库是否出现了问题会精确的多。</p>
<p>file_summary_by_event_name表里有很多行数据，我们主要关注event_name='wait/io/file/innodb/innodb_log_file’这一行：</p>
<p>![image-20220327105108038](/Users/jiyongchao/Library/Application Support/typora-user-images/image-20220327105108038.png)</p>
<p>图中，这一行统计的是redo log的写入时间，第一列EVENT_NAME表示统计的类型。接下来三组数据，显示的是redo log操作的时间统计。第一组五列，是所有IO类型的统计。其中，COUNT_STAR是所有IO的总次数，接下来四列是具体的统计项，单位是皮秒，前缀SUM、MIN、AVG、MAX，顾名思义指的就是总和、最小值、平均值和最大值。第二组六列，是读操作的统计，最后一列SUM_NUMBER_OF_BYTES_READ统计的是，总共从redo log里读了多少字节。第三组六列，统计的是写操作。最后的第四组数据，是对其他类型数据的统计。在redo log里，可以认为它们是对fsync的统计。</p>
<div class="note info"><p>bin log对应的是event_name = "wait/io/file/sql/binlog"这一行，各个字段的统计逻辑，与redo log的各个字段完全相同。</p></div>
<p>由于每次操作数据库，preformance_schema都需要额外地统计这些信息，所以打开这个统计功能是有性能损耗的。如果打开所有的preformance_schema项，性能会下降10%左右，因此，只打开需要的项进行统计即可。</p>
<p>如果打开redo log的时间监控，可以执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update setup_instruments <span class="keyword">set</span> ENABLED<span class="operator">=</span><span class="string">&#x27;YES&#x27;</span>, Timed<span class="operator">=</span><span class="string">&#x27;YES&#x27;</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%wait/io/file/innodb/innod</span></span><br></pre></td></tr></table></figure>
<p>假设已经开启了redo log和binlog这两个统计信息，就可以通过MAX_TIMER的值来判断数据库是否出问题了。比如，可以通过设定阈值，单次IO请求时间超过200毫秒属于异常，然后使用类似下面这条语句作为检测逻辑：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> event_name,MAX_TIMER_WAIT <span class="keyword">FROM</span> performance_schema.file_summary_by_event_name <span class="keyword">where</span> EVENT_NAME <span class="operator">=</span> <span class="string">&#x27;wait/io/file/innodb/innodb_log_file&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>发现异常后，取到需要的信息，再通过下面的这条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> performance_schema.file_summary_by_event_name;</span><br></pre></td></tr></table></figure>
<p>把之前的统计信息清空，这样，再次出现这个异常，就可以加入监控累积值了。</p>
<h1 id="mysql的最佳实践"><a class="markdownIt-Anchor" href="#mysql的最佳实践"></a> MySQL的最佳实践</h1>
<h2 id="kill命令"><a class="markdownIt-Anchor" href="#kill命令"></a> Kill命令</h2>
<p>在MySQL中有两个kill命令：一个是kill quey + 线程id，表示终止这个线程中正在执行的语句：一个是kill connection + 线程id，这里connection可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句。在使用kill命令的时候，可能会出现，无法断开这个连接，但是执行<code>show processlist</code>命令，看到这条语句的Command列显示的却是Killed。</p>
<p>其实大多数情况下，kill query/connection命令是有效的，比如，执行一个查询的过程中，发现执行时间太久，要么放弃继续查询，这时我们就可以使用kill query命令，终止这条查询语句。还有一种情况是，语句处于锁等待的时候，直接使用kill命令也是有效的：</p>
<p>可以看到，session C执行<code>kill query</code>以后，session B几乎同时就提示了语句被中断，这就是我们预期的结果。</p>
<h3 id="kill命令的执行过程"><a class="markdownIt-Anchor" href="#kill命令的执行过程"></a> kill命令的执行过程</h3>
<p>当对一个表做增删改查操作时，会在表上加MDL读锁，所以，session B虽然处于blocked状态，但还是持有MDL读锁的，如果线程直接被kill掉，那么这个MDL读锁就没有机会释放了。也就是说，kill并不是马上停止的意思，而是告诉线程，这条语句已经不需要继续执行了，可以开始“执行停止的逻辑了”。</p>
<div class="note info"><p>其实，这和Linux的kill命令类似。kill -N pid并不是让进程直接停止，而是给进程发一个信号，然后进程处理这个信号，进入终止逻辑。只是对于MySQL的kill命令来说，不需要传信号量参数，就只有“停止”这个命令。</p></div>
<p>实现上，当用户执行<code>kill query thread_id_B</code>时，MySQL里处理kill命令的线程做了两件事情：</p>
<ol>
<li>把session B的运行状态改成THD::KILL_QUERY（将变量killed赋值为THD::KILL_QUERY）</li>
<li>给session B的执行线程发一个信号</li>
</ol>
<p>需要发出信号的原因是，session B处于锁等待状态，如果只是把session B的线程状态设置THD::KILL_QUERY，线程B并不知道这个状态变化，还是会继续等待，发一个信号的目的，就是让session B退出等待，来处理这个THD::KILL_QUERY状态。</p>
<p>上面的分析中，隐含了下面的三层意思：</p>
<ul>
<li>一个语句执行过程中有多处“埋点”，在这些买点的地方判断线程状态，如果发现线程状态是THD::KILL_QUERY，才开始进入语句终止逻辑</li>
<li>如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处</li>
<li>语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的</li>
</ul>
<p>接下来我们来看一个kill不掉的例子。首先，执行<code>set global innodb_thread_concurrency = 2</code>，将InnoDB的并发线程上限设置为2，然后执行下面的序列：</p>
<p>可以看到：</p>
<ol>
<li>session C执行的时候被阻塞了</li>
<li>但是session D执行<code>kill query C</code>命令没有效果</li>
<li>直到session E执行了<code>kill connection</code>命令，才断开了session B的连接，提示“Lost connection to MySQL server during query”</li>
<li>但是，此时如果在session E中执行<code>show processlist</code>，就可以看到下面这个图：</li>
</ol>
<p>这时候，id=12这个线程的Command列显示的是Killed。也就是说，客户端虽然断开了连接，但是实际上服务端上这条语句还在执行过程中。</p>
<p>为什么在执行<code>kill query</code>命令时，这条语句不像第一个例子的update语句一样退出呢？在实现等行锁时，使用的是pthread_cond_timewait函数，这个等待状态可以被唤醒。但是，在这个例子中，12号线程的等待逻辑是这样的：每10毫秒判断一下是否可以进入InnoDB执行，如果不行，就调用nanosleep函数进入sleep状态。也就是说，虽然12号线程的状态已经设置成了KILL_QUERY，但是在这个等待进入InnoDB的循环过程中，并没有去判断线程的状态，因此根本不会进入终止逻辑阶段。而当session E执行<code>kill connection</code>命令时：</p>
<ol>
<li>把12号线程状态设置为KILL_CONNECTION</li>
<li>关掉12号线程的网络连接，因为有这个操作，所以这时候session C收到了断开连接的提示</li>
</ol>
<p>那为什么执行<code>show processlist</code>的时候，会看到Command列显示为killed呢？其实，这时因为在执行<code>show processlist</code>的时候，有一个特别的逻辑：如果一个线程的状态是KILL_CONNECTION，就把Command列线程成Killed，所以，即使是客户端退出了，这个线程的状态仍然是在等待中，那这个线程什么时候会退出呢？</p>
<p>只有等到满足进入InnoDB的条件后，session C的查询语句继续执行，然后才有可能判断到线程的状态已经变成了KILL_QUERY或者KILL_CONNECTION，再进入终止逻辑阶段。</p>
<p>这是kill无效的第一类情况，即：线程没有执行到判断线程状态的逻辑，跟这种情况相同的，还有由于IO压力过大，读写IO的函数一致无法返回，导致不能及时判断线程的状态。另一类情况是，终止逻辑耗时较长，这时候，从<code>show processlist</code>结果上看也是<code>Command = Killed</code>，需要等到终止逻辑完成，语句才算真正完成，这类情况，比较常见的场景有以下几种：</p>
<ol>
<li>超大事务执行期间被kill，这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长</li>
<li>大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待IO资源，导致耗时较长</li>
<li>DDL命令执行到最后阶段，如果被kill，需要删除中间过程的临时文件，也可能收到IO资源影响耗时较久。</li>
</ol>
<h3 id="客户端缓存"><a class="markdownIt-Anchor" href="#客户端缓存"></a> 客户端缓存</h3>
<p>在实际使用中，有两个比较常见的误解。</p>
<p>第一个误解是：如果库里面的表特别多，连接就会很慢。有些线上的库，会包含很多表，这时候，每次用客户端连接都会卡在下面这个界面上：</p>
<p>而如果db1这个库里表很少的话，连接起来就会很快，可以很快进入输入命令的状态。但每个客户端在和服务端建立连接的时候，需要做的事情就是TCP握手、用户校验、获取权限。但这几个操作，显然跟库里面表的个数无关。</p>
<p>实际上，当使用默认参数连接的时候，MySQL客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端在连接成功后，需要多做一些操作：</p>
<ol>
<li>执行<code>show databases;</code></li>
<li>切到db1库，执行<code>show tables;</code></li>
<li>把这两个命令的结果用于构建一个本地的哈希表</li>
</ol>
<p>在这些操作中，最花时间的就是第三步在本地构建哈希表的操作。所以，当一个库中的表个数非常多的时候，这一步就会花比较长的时间。也就是说，我们感知到的连接过程慢，其实并不是连接慢，也不是服务端慢，而是客户端慢。如果在连接命令中加上<code>-A</code>的参数，就可以关掉这个自动不全的功能，然后客户端就可以快速返回了。这里自动补全的效果是，当输入库名或者表名的时候，输入前缀，就可以使用Tab键自动补全表名或者显示提示。如果在实际使用中，自动补全功能用得不多，那么久可以加上<code>-A</code>的参数。</p>
<p>除了可以添加<code>-A</code>的参数以外，加<code>-quick（或简写为-q）参数</code>，也可以跳过这个阶段。但是，这个<code>-quick</code>是一个更容易引起误会的参数，也是关于客户端常见的一个误解。</p>
<p>MySQL客户端发送请求后，接收服务端返回结果的方式有两种：</p>
<ol>
<li>一种是本地缓存，也就是在本地打开一片内存，先把结果存起来。如果使用API，对应的就是mysql_store_result方法</li>
<li>另一种是不读缓存，读一个处理一个。如果使用API开发，对应的就是mysql_use_result方法</li>
</ol>
<p>MySQL客户端默认采用第一种方式，而如果加上<code>-quick</code>参数，就会使用第二种不缓存的方式。采用不缓存的方式时，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。也就是说，设置了这个参数，反而会降低服务端的性能。</p>
<p>那么，为什么这个参数要取名叫做<code>-quick</code>呢？这是因为：</p>
<ul>
<li>第一点，跳过了表名自动补全的功能</li>
<li>第二点，mysql_store_result需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能</li>
<li>第三点，不会把执行命令记录到本地的命令历史文件</li>
</ul>
<p>因此，<code>-quick</code>参数的意思，其实是让客户端变得更快。</p>
<h2 id="误删数据"><a class="markdownIt-Anchor" href="#误删数据"></a> 误删数据</h2>
<p>俗话说“常在河边走，哪有不湿鞋”，大多数人都可能会碰到误删数据的场景，为了找到解决误删数据的更高效的方法，我们对MySQL相关的误删数据，做以下分类：</p>
<ul>
<li>使用<code>delete</code>语句误删数据行</li>
<li>使用<code>drop table</code>或者<code>truncate table</code>语句误删数据表</li>
<li>使用<code>drop database</code>语句误删数据库</li>
<li>使用<code>rm</code>命令误删整个MySQL实例</li>
</ul>
<h3 id="误删行"><a class="markdownIt-Anchor" href="#误删行"></a> 误删行</h3>
<p>如果使用delete语句误删了数据行，可以用Flashback工具通过闪回把数据恢复回来，Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放，而能够使用这个方案的前题是，需要确保<code>binlog_format=row</code>和<code>binlog_row_image=FULL</code>。</p>
<p>具体恢复数据时，对单个事务做如下处理：</p>
<ol>
<li>对于insert语句，对应的<code>binlog event</code>类型是<code>Write_rows event</code>，把它改成<code>Delete_rows event</code>即可</li>
<li>同理，对于delete语句，也是将<code>Delete_rows event</code>改为<code>Write_rows event</code></li>
<li>而如果是<code>Update_rows</code>的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的位置即可</li>
</ol>
<p>如果误操作不是一个，而是多个，比如下面三个事务：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(A)<span class="keyword">delete</span> ...</span><br><span class="line">(B)<span class="keyword">insert</span> ...</span><br><span class="line">(C)update...</span><br></pre></td></tr></table></figure>
<p>现在要把数据库恢复到这个三个事务操作之前的状态，用Flashback工具解析binlog后，写回主库的命令是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(reverse C)update ...</span><br><span class="line">(reverse B)<span class="keyword">delete</span> ...</span><br><span class="line">(reverse A)insert...</span><br></pre></td></tr></table></figure>
<p>也就是说，如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。需要注意的是，不要直接在主库上执行这些操作，恢复数据比较安全的做法是，恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。这么做的原因是，一个在执行线上逻辑的主库，数据状态的变更往往是有关联的，可能由于发现数据问题的时间晚了一点，就导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其它数据，所以，如果这时候单独恢复这几行数据，而又未经确认的话，就可能出现对数据的二次破坏。</p>
<p>比起误删数据时候进行处理，更重要的是做到事前预防：</p>
<ol>
<li>把<code>sql_safe_updates</code>参数设置为on，这样依赖，如果忘记在delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错</li>
<li>代码上线前，必须经过SQL审计</li>
</ol>
<div class="note info"><p>如果设置了sql_safe_updates=on，但是要删除一个小表的全部数据，可以在delete语句中加上where条件，比如where id >= 0。但是delete全表是很慢的，需要生成回滚日志，写redo log和bin log，所以，从性能的角度考虑，应该优先考虑使用truncate table或者drop table命令。</p></div>
<h3 id="误删库表"><a class="markdownIt-Anchor" href="#误删库表"></a> 误删库/表</h3>
<p>如果使用了<code>truncate/drop table</code>和<code>drop database</code>命令删除的数据，就无法通过Flashback来恢复了，这是因为，即使我们配置了<code>binlog_format=row</code>，执行这三个命令时，记录的binlog还是statement格式。binlog里面就只有一个<code>truncate/drop</code>语句，这些信息是恢复不出来数据的。</p>
<p>这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份binlog，在这两个条件都具备的情况下，假如有人中午12点删了一个库，恢复数据的流程如下：</p>
<ol>
<li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点</li>
<li>用备份恢复出一个临时库</li>
<li>从日志备份里面，取出凌晨0点之后的日志</li>
<li>把这些日志，除了误删数据的语句外，全部应用到临时库</li>
</ol>
<p>这个流程的示意图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220208233711540.png" alt="image-20220208233711540" style="zoom:67%;" />
<p>关于这个过程的说明：</p>
<ol>
<li>为了加速数据恢复，如果这个临时库上有多个数据库，那么可以在使用mysqlbinlog命令时，加上一个-database参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其它库日志的情况</li>
<li>在应用日志的时候，需要跳过12点误操作的那个语句的binlog：
<ul>
<li>如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用-stop-position参数执行到误操作之前的日志，然后再用-start-position从误操作之后的日志继续执行</li>
<li>如果实例使用了GTID模式，就方便多了。假设误操作命令的GTID是gtid1，那么只需要执行<code>set gtid_next=gtid1;begin;commit;</code>，先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，就会自动跳过误操作的语句</li>
</ul>
</li>
</ol>
<p>不过即使这样，使用mysqlbinlog方法恢复数据还是不够快，主要原因有两个：</p>
<ol>
<li>如果是误删表，最好就是只恢复这张表，也就是只重放这张表的操作，但是mysqlbinlog工具并不能指定只解析一个表的日志</li>
<li>用mysqlbinlog解析出日志应用，应用日志的过程就只能是单线程。</li>
</ol>
<p>一种加速方式是，在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，这样：</p>
<ol>
<li>在start slave之前，先通过执行<code>change replication filter replicate_do_table = (tbl_name)</code>命令，就可以让临时库只同步误操作的表</li>
<li>这样做也可以用上并行复制技术，来加速整个数据恢复过程</li>
</ol>
<p>这个过程的示意图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220209234951355.png" alt="image-20220209234951355" style="zoom: 67%;" />
<p>图中binlog备份系统到线上备库有一条虚线，是指如果由于时间太久，备库上已经删除了临时实例需要的binlog的话，我们可以从binlog备份系统中找到需要的binlog，再放回备库中。假设，我们发现当前临时实例需要的binlog是从master.000005开始的，但是在备库上执行<code>show binlogs</code>显示的最小的binlog文件是master.000007，意味着少了两个binlog文件。这时，我们就需要去binlog备份系统中找到这两个文件，把之前删掉的binlog放回备库的操作如下：</p>
<ol>
<li>从备份系统下载master.000005和master.000006这两个文件，放到备库的日志目录下</li>
<li>打开日志目录下的master.index文件，在文件开头加入两行，内容分别是“./master.000005”和“.、master.000006”</li>
<li>重启备库，目的是要让备库重新识别这两个日志文件</li>
<li>现在这个备库上就有了临时库需要的所有binlog了，建立主备关系，就可以正常同步了</li>
</ol>
<p>无论是把mysqlbinlog工具解析出的binlog文件应用到临时库，还是把临时库接到备库上，这两个方案的共同点是：误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用binlog的方式。也就是说，这两个方案都要求备份系统定期备份全量日志，而且需要确保binlog在被从本地删除之前已经做了备份，但是一个系统不可能无限制的备份日志，还需要根据成本和磁盘空间资源，设定一个日志保留的天数。</p>
<h3 id="延迟复制备库"><a class="markdownIt-Anchor" href="#延迟复制备库"></a> 延迟复制备库</h3>
<p>虽然可以通过利用并行复制来加速恢复数据的过程，但是这个方案仍然存在“恢复时间不可控”的问题。如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的实例，在备份之后的第6天发生误操作，就需要恢复6天的日志，这个恢复时间可能是要按天来计算的。</p>
<p>这种情况下，就可以考虑搭建延迟复制的备库，这个功能是MySQL5.6版本引入的。一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。</p>
<p>延迟复制的备库是一种特殊的备库，通过<code>CHANGE MASTER TO MASTER_DELAY=N</code>命令，可以指定这个备库持续保持跟主库有N秒的延迟。比如将N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行，这个时候在备库上执行<code>stop slave</code>，再通过之前介绍的方法，跳过误操作的命令，就可以恢复出需要的数据，这样的话就得到了一个最多只需要追加1个小时，就可以恢复出数据的临时实例，也就缩短了整个数据恢复需要的时间。</p>
<h3 id="预防误删库表的方法"><a class="markdownIt-Anchor" href="#预防误删库表的方法"></a> 预防误删库/表的方法</h3>
<ol>
<li>账号分离。这样做的目的是，避免写错命令，比如：
<ul>
<li>只给业务开发DML权限，而不给<code>truncate/drop</code>权限，而如果业务开发人员有DDL需求话，可以通过开发管理系统得到支持</li>
<li>即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号</li>
</ul>
</li>
<li>制定操作规范。这样做的目的，是避免写错要删除的表名，比如：
<ul>
<li>在删除数据表之前，必须先对表做改名操作，然后，观察一段时间，确保对业务无影响以后再删除这张表</li>
<li>改表名的时候，要求给表名加固定的后缀（比如加_to_be_deleted），删除表的动作必须通过管理系统执行。并且，管理系统删除表的时候，只能删除固定后缀的表</li>
</ul>
</li>
</ol>
<h3 id="rm删除数据"><a class="markdownIt-Anchor" href="#rm删除数据"></a> rm删除数据</h3>
<p>其实，对于一个有高可用机制的MySQL集群来说，最不怕的就是rm删除数据了，只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作，这是，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。</p>
<p>当然了，现在不止是DBA有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批量下线机器的操作，会让整个MySQL集群的所有节点都全军覆没，应对这种情况，只能尽量将备份跨机房，或者最好是跨城市保存。</p>
<h2 id="自增主键"><a class="markdownIt-Anchor" href="#自增主键"></a> 自增主键</h2>
<p>自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑，但业务设计不应该依赖于自增主键的连续性，因为自增主键不能保证连续递增，有可能会出现“空洞”。为了便于说明，我们创建一个表t，其中id是自增主键字段，c是唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`), </span><br><span class="line">  <span class="comment">-- 注意这里设置了唯一约束</span></span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `c` (`c`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure>
<h3 id="自增主键的存储"><a class="markdownIt-Anchor" href="#自增主键的存储"></a> 自增主键的存储</h3>
<p>在这个空表里面执行<code>insert into values(null,1,1);</code>插入一行数据，再执行<code>show create table;</code>命令，就可以看到如下结果：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220117234809443.png" alt="image-20220117234809443" style="zoom:67%;" />
<p>可以看到，表定义里面出现了AUTO_INCREMENT=2，表示下一次插入数时，如果需要自动生成自增值，会生成id=2。实际上，自增值并不是保存在表结构定义里的，表结构的定义是存放在后缀名为.frm的文件中，但是并不会保存自增值。</p>
<p>不同的引擎对于自增值的保存策略是不同的：</p>
<ul>
<li>MyISAM引擎的自增值保存在数据文件中</li>
<li>InnoDB引擎的自增值，其实是保存在了内存里，并且只有在MySQL8.0版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的值”，具体情况是：
<ul>
<li>在MySQL5.7及之前的版本，自增值保存在内存里，并没有持久化，每次重启后，第一次打开表的时候，都会去找自增量的最大值max(id)，然后将max(id)+1作为这个表当前的自增值。举例来说，如果一个表当前数据行里最大的id是10，AUTO_INCREMENT=11,这个时候如果删除id=10的行，AUTO_INCREMENT还是11，但是如果马上重启实例，重启后这个表的AUTO_INCREMENT就会变成10，也就是说，MySQL重启可能会修改一个表的AUTO_INCREMENT的值</li>
<li>在MySQL8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值</li>
</ul>
</li>
</ul>
<h3 id="自增值的修改"><a class="markdownIt-Anchor" href="#自增值的修改"></a> 自增值的修改</h3>
<p>在MySQL里面，如果字段id被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p>
<ul>
<li>如果插入数据时id字段指定为0、null、或未指定值，那么就把这个表当前的AUTO_INCREMENT值填到自增字段</li>
<li>如果插入数据时id字段执行了具体的值，就直接使用语句里指定的值</li>
</ul>
<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同，假设某次要插入的值是X，当前的自增值是Y：</p>
<ul>
<li>如果X&lt;Y，那么这个表的自增值不变</li>
<li>如果X≥Y，就需要把当前自增值修改为新的自增值</li>
</ul>
<p>新的自增值的生成算法是：从<code>auto_increment_offset</code>开始，以<code>auto_increment_increment</code>为步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。其中，<code>auto_increment_offset</code>和<code>auto_increment_increment</code>是两个系统参数，分别用来表示自增的初始值和步长，默认值都是1。</p>
<div class="note info"><p>在一些场景下，使用的就不全是默认值。比如，双M的主备结构里要求双写的时候，我们就可能会设置auto_increment_increment=2，让一个库的自增id多是奇数，另一个库的自增id都是偶数，避免两个库生成的主键发生冲突。</p></div>
<p>那么，当这两个参数都设置为1的时候，自增主键为什么还是不能保证连续呢？常见的导致自增主键的原因有：</p>
<ul>
<li>唯一键冲突</li>
<li>事务回滚</li>
<li>自增锁的优化</li>
</ul>
<p>接下来我们通过例子来说明这三点，假设表t里面已经有了（1，1，1）这条记录，此时执行如下插入命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这条语句的执行流程如下：</p>
<ol>
<li>执行器调用InnoDB引擎接口写入一行，传入的这一行的值是（0，1，1）</li>
<li>InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2</li>
<li>将传入的行的值改成（2，1，1）</li>
<li>将表的自增值改成3</li>
<li>继续执行插入数据的操作，由于已经存在c=1的记录（字段c有唯一约束），所以报Duplicate key error，语句返回</li>
</ol>
<p>对应的流程图如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220118233718587.png" alt="image-20220118233718587" /></p>
<p>可以看到，这个表的自增值改成3，是在真正执行插入数据的操作之前，这个语句真正执行的时候，因为碰到了唯一键c冲突，所以id=2这一行并没有插入成功，但也没有将自增值再该回去，所以，在这之后，再插入新的数据行是，拿到的自增id就是3，也就是说，出现了自增主键不连续的情况。</p>
<p>完整的演示过程如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220118234714144.png" alt="image-20220118234714144" style="zoom:50%;" />
<p>可以看到，这个操作序列复现了一个自增主键id不连续的情况（没有id=2的行）。</p>
<p>事务回滚也会发生类似的情况，以下语句序列可以说明这一点：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 插入的行是 (<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>那么当出现唯一键冲突和事务回滚的时候，MySQL为什么不会把表t的自增值改回去呢？答案是为了性能，假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请：</p>
<ol>
<li>假设事务A申请到了id=2，事务B申请到id=3，那么这个时候表t的自增值是4，之后继续执行</li>
<li>事务B正确提交了，但事务A出现了唯一键冲突</li>
<li>如果允许事务A把自增id回退，也就是把表t的当前自增值改回2，那么就会出现这样的情况：表里面已经有了id=3的行，而当前的自增id的值是2</li>
<li>接下来，继续执行的其它事务就会申请到id=3，这时，就会出现插入语句报错“主键冲突”</li>
</ol>
<p>而为了解决这个主键冲突，有两种方法：</p>
<ol>
<li>每次申请id之前，先判断表里面是否已经存在这个id，如果存在，就跳过这个id。但是，这个方法的成本很高，因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断id是否存在</li>
<li>把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id，这个方法的问题是锁的粒度太大，系统并发能力会大幅下降</li>
</ol>
<p>因此，InnoDB放弃了这个设计，语句执行失败也不会回退自增id，也正是这样，才只保证了自增id是递增的，但不保证是连续的。</p>
<h3 id="自增锁的优化"><a class="markdownIt-Anchor" href="#自增锁的优化"></a> 自增锁的优化</h3>
<p>可以看到，自增id锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。其实，在MySQL5.1版本之前，并不是这样的，在MySQL5.0版本的时候，自增锁的范围是语句级别，也就是说，如果一个语句申请了一个表自增锁，这个锁会等执行结束以后才释放，显然，这会影响并发度。MySQL5.1.22版本引入了一个新策略，新增参数<code>innodb_autoinc_lock_mode</code>，默认值是1，并且：</p>
<ul>
<li>这个参数的值被设置为0时，表示采用之前MySQL5.0版本的策略，即语句执行结束后才释放锁</li>
<li>这个参数的值被设置为1时：
<ul>
<li>普通insert语句，自增锁在申请之后就马上释放</li>
<li>类似insert…select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放</li>
</ul>
</li>
<li>这个参数的值被设置为2时，所有的申请自增主键的动作都是申请后就释放锁</li>
</ul>
<p>不难发现，insert…select语句在默认设置下，使用了语句级的锁，这主要是出于数据的一致性的考虑，假设有以下场景：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220123115117649.png" alt="image-20220123115117649" /></p>
<p>在这个例子中，session A往表t1中插入了4行数据，然后session B创建了一个相同结构的表t2，然后两个session 同时执行向表t2中插入数据的操作，如果session B是申请了自增值以后马上就释放自增锁，就可能出现这样的情况：</p>
<ol>
<li>session B先插入了两个记录（1，1，1）、（2，2，2）</li>
<li>然后，session A来申请自增id得到id=3，插入了（3，5，5）</li>
<li>之后，session B继续执行，插入两条记录（4，3，3）、（5，4，4）</li>
</ol>
<p>假设数据库的<code>binlog_format=statment</code>，由于session是同时执行插入数据命令的，所以binlog里面对表t2的更新日志只有两种情况：要么先记session A的，那么先记session B的，但不论是哪一种，这个binlog在从库执行或者用来恢复临时实例，备库和临时实例里面，session B这个语句执行出来，生成的结果里面，id都是连续的，这时，这个库就发生了数据不一致。</p>
<p>产生这个问题的原因是session B的insert语句，生成的id不连续，这个不连续的id，用statement格式的binlog来串行执行，是执行不出来的，要解决这个问题，有两种思路：</p>
<ol>
<li>让原库的批量插入数据语句，固定生成连续的id的值，所以，自增锁直到语句执行结束才释放，就是为了达到这个目的</li>
<li>在binlog里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成，这种情况，其实就是<code>innodb_autoinc_lock_mode</code>设置为2，同时设置<code>binlog_format=row</code></li>
</ol>
<p>因此，在生产上，尤其是有insert…select这种批量插入数据的场景时，从并发插入数据性能的角度考虑，可以考虑思路2，这样做，既能提升并发性，又不会出现数据一致性问题。</p>
<p>普通的insert语句里面包含多个value值的情况下，即使<code>innodb_autoinc_lock_mode</code>设置为1，也不会等语句执行完成才释放锁，因为这类语句在申请自增id的时候，是可以精确计算出需要多少个id的，然后一次性申请，申请完成后锁就可以释放了。也就是说，批量插入数据的语句，之所以需要这么设置，是因为“不知道要预先申请多少个id”，既然预先不知道要申请多少个自增id，那么一种直接的想法就是需要一个时申请一个，但如果一个select…insert语句要插入10万行数据，按照这个逻辑的话就要申请10万次，显然，这种申请自增id的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。因此，对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：</p>
<ol>
<li>语句执行过程中，第一次申请自增id，会分配1个</li>
<li>1个用完以后，这个语句第二次申请自增id，会分配2个</li>
<li>2个用完以后，还是这个语句，第三次申请自增id，会分配4个</li>
<li>以此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍</li>
</ol>
<p>insert…select，实际上往表t2插入了4行数据，但是，这四行数据是分三次申请的自增id，第一次申请到了id=1，第二次被分配了id=2和id=3，第三次被分配到id=4到id=7，由于这条语句实际只用上了4个id，所以id=5到id=7就被浪费掉了，之后，再执行<code>insert into t2 values(null,5,)</code>，实际上插入的数据就是（8，5，5）,这也导致出现了自增id不连续的情况。</p>
<h3 id="自增主键的上限"><a class="markdownIt-Anchor" href="#自增主键的上限"></a> 自增主键的上限</h3>
<p>MySQL里有很多自增的id，每个自增id都是定义了初始值，然后不停地往上加步长，虽然自然数是没有上限的，但是在计算机里，只要定义了表示这个数的字节长度，那它就有上限。比如，无符号整型（unsigned int）是4个字节，上限就是2<sup>23</sup>-1。</p>
<h4 id="表定义自增值id"><a class="markdownIt-Anchor" href="#表定义自增值id"></a> 表定义自增值id</h4>
<p>表定义的自增值达到上限后的逻辑是：再申请下一个id时，得到的值保持不变，我们可以通过下面的语句序列验证：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(id <span class="type">int</span> unsigned auto_increment <span class="keyword">primary</span> key) auto_increment<span class="operator">=</span><span class="number">4294967295</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 成功插入一行 <span class="number">4294967295</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t;</span><br><span class="line"><span class="comment">/* CREATE TABLE `t` (</span></span><br><span class="line"><span class="comment">`id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="comment">PRIMARY KEY (`id`)</span></span><br><span class="line"><span class="comment">) ENGINE=InnoDB AUTO_INCREMENT=4294967295;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>Duplicate entry <span class="string">&#x27;4294967295&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;PRIMARY&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，第一个insert语句插入数据成功后，这个表的<code>AUTO_INCREMENT</code>没有改变（还是4294967295），就导致了第二个insert语句又拿到相同的自增id值，再试图执行插入语句，报主键冲突错误。2<sup>23</sup>-1（4294967295）不是一个特别大的数，对于一个频繁插入删除数据的表来说，是可能会被用完的，因此在建表的时候需要考察是否可能达到这个上限，如果有可能，就应该创建成8个字节bigint unsigned。</p>
<h4 id="innodb系统自增row_id"><a class="markdownIt-Anchor" href="#innodb系统自增row_id"></a> InnoDB系统自增row_id</h4>
<p>如果创建的InnoDB表没有指定主键，那么InnoDB会默认创建一个不可见的，长度为6个字节的row_id，InnoDB维护了一个全局的dict_sys.row_id的值，所有无主键的InnoDB表，每插入一行数据，都将当前的dict_sys.row_id的值作为要插入数据的row_id，然后把dict_sys.row_id的值加1。实际上，在代码实现时row_id是一个长度为8字节的无符号长整型（bigint unsigned），但是，InnoDB在设计时，给row_id留的只是6个字节的长度，这样写到数据表中只放了最后6个字节，所以row_id能写到数据表中的值，就有两个特征：</p>
<ol>
<li>row_id写入表中的值范围，是从0到2<sup>48</sup>-1</li>
<li>当dict_sys.row_id=2<sup>48</sup>时，如果再有插入数据的行为要来申请row_id，拿到以后再取最后6个字节的话就是0</li>
</ol>
<p>也就是说，写入表的row_id是从0开始到2<sup>48</sup>-1，达到上限后，下一个值就是0，然后继续循环，虽然2<sup>48</sup>-1这个值本身已经很大了，但是如果一个MySQL实例跑得足够久得话，还是可能达到这个上限的，在InnoDB逻辑里，申请row_id=N后，就将这行数据写入表中，如果表中已经存在row_id=N的行，新写入的行就会覆盖原有的行。</p>
<p>从这个角度来看，我们还是应该在InnoDB表中主动创建自增主键，因为表自增id达到上限后，再插入数据时报主键冲突错误，是更能被接受的，毕竟覆盖数据，就意味着数据丢失，影响的是数据可靠性，报主键冲突，是插入失败，影响的是可用性，而一般情况下，可靠性优于可用性。</p>
<h4 id="xid"><a class="markdownIt-Anchor" href="#xid"></a> Xid</h4>
<p>redo log和binlog有一个共同的字段叫做Xid，它在MySQL中是用来对应事务的。MySQL在内部维护了一个全局变量<code>global_query_id</code>，每次执行语句的时候将它赋值给Query_id，然后给这个变量加1。如果当前语句是这个事务执行的第一条语句，那么MySQL还会同时把query_id赋值给这个事务的Xid。<code>global_query_id</code>是一个纯内存变量，重启之后就会清零，因此，在同一个数据库实例中，不同事务的Xid也是有可能相同的。但是MySQL重启之后会生成新的binlog文件，这就保证了，同一个binlog文件里，Xid一定是唯一的。</p>
<p>虽然MySQL重启不会导致同一个binlog里面出现两个相同的Xid，但是如果<code>global_query_id</code>达到上限后，就会继续从0开始计数，从理论上将，还是会出现同一个binlog里面出现相同Xid的场景。由于<code>global_query_id</code>定义的长度是8个字节，这个自增值得上限是2<sup>64</sup>-1，要出现这样得情况，必须出现如下场景：</p>
<ol>
<li>执行一个事务，假设Xid是A</li>
<li>接下来执行2<sup>64</sup>次查询语句，让<code>global_query_id</code>回到A</li>
<li>再启动一个事务，这个事务的Xid也是A</li>
</ol>
<p>不过，2<sup>64</sup>这个值太大了，这种场景只会存在于理论中。</p>
<h4 id="innodb-trx_id"><a class="markdownIt-Anchor" href="#innodb-trx_id"></a> Innodb trx_id</h4>
<p>Xid和InnoDB的trx_id是两个容易混淆的概念。Xid是由server层维护的，InnoDB内部使用Xid，就是为了能够在InnoDB事务和server之间做关联。但是，InnoDB自己的trx_id，是另外维护的。InnoDB内部维护了一个max_trx_id全局变量，每次申请一个新的trx_id时，就获得max_trx_id的当前值，然后并将max_trx_id加1.</p>
<p>InnoDB数据可见性的核心思想是：每一行数据都记录了更新它的trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的trx_id做对比。对于正在执行的事务，可以从infomation_schema.innodb_trx表中看到事务的trx_id。</p>
<p>接下来，我们观察如下事务序列：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220123175439810.png" alt="image-20220123175439810" style="zoom:67%;" />
<p>session B中从innodb_trx表里查出来的两个字段，第二个字段<code>trx_mysql_thread_id</code>就是线程id。显示线程id，是为了说明这两次查询看到的事务对应的线程id都是5，也就是session A所在的线程。可以看到，T2时刻显示的trx_id是一个很大的数；T4时刻显示的trx_id是1289，看上去是一个比较正常的数字，这是因为，在T1时刻，session A还没有涉及到更新，是一个只读事务，而对于只读事务，InnoDB并不会分配trx_id，也就是说：</p>
<ul>
<li>在T1时刻，trx_id的值其实就是0，而这个很大的数，只是显示用的</li>
<li>直到session A在T3时刻执行insert语句的时候，InnoDB才真正分配了trx_id。所以，T4时刻，session B查到的这个trx_id的值就是1289</li>
</ul>
<div class="note warning"><p>需要注意的是，除了显而易见的修改类语句外，如果在select语句后面加上for update，这个事务也不是只读事务。</p></div>
<p>T2时刻这个数字是每次查询的时候由系统临时计算出来的。它的算法是：把当前事务的trx变量的指针地址转成整数，再加上2<sup>48</sup>，使用这个算法，就可以保证两点：</p>
<ul>
<li>因为同一个只读事务在执行期间，它的指针地址是不会变的，所以不论是在innodb_trx还是在innodb_locks表里，同一个只读事务查出来的trx_id就会是一样的</li>
<li>如果有并行的多个只读事务，每个事务trx变量的指针地址肯定不同。这样，不同的并发只读事务，查出来的trx_id就是不同的</li>
</ul>
<p>而在显示值里面加上2<sup>48</sup>，目的是为了保证只读事务显示的trx_id值比较大，正常情况下就会区别于读事务的id。但是trx_id跟row_id的逻辑类似，定义长度也是8个字节。因此，在理论上还是可能出现一个读写事务于一个只读事务显示trx_id相同的情况，不过这个概率很低，并且没有什么实质危害。</p>
<p>那么，只读事务不分配trx_id有什么好处呢？</p>
<ul>
<li>一个好处是，这样做可以减少事务视图里面活跃事务数组的大小。因为当前正在运行的只读事务，是不影响数据的可见性判断的。所以，在创建事务的一致性视图时，InnoDB就只需要拷贝读写事务的trx_id</li>
<li>另一好处是，可以减少trx_id的申请次数。在InnoDB里，即使只是执行一个普通的select语句，在执行过程中，也是要对应一个只读事务的。所以只读事务优化后，普通的查询语句不需要申请trx_id，就大大减少了并发事务申请trx_id的锁冲突</li>
</ul>
<p>由于只读事务不分配trx_id，一个自然而然的结果就是trx_id的增加速度变慢了。但是，max_trx_id会持久化存储，重启也不会重置为0，那么从理论上讲，只要一个MySQL服务跑得足够久，就可能出现max_trx_id达到2<sup>48</sup>-1的上限，然后从0开始的情况。当达到这个状态后，MySQL就会持续出现一个脏读的bug。</p>
<p>首先我们需要把当前的max_trx_id先修成2<sup>48</sup>-1。注意：这里使用的是可重复读隔离级别，具体的操作流程如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220123221738366.png" alt="image-20220123221738366" /></p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20220123221826819.png" alt="image-20220123221826819" style="zoom:67%;" />
<p>由于此时系统的max_trx_id设置成了2<sup>48</sup>-1，所以在session A启动的事务TA的低水位就是2<sup>48</sup>-1，在T2时刻，session B执行第一条update语句的事务id就是2<sup>48</sup>-1，而第二条update语句的事务id就是0了，这条update语句执行后生成的数据版本上的trx_id就是0，在T3时刻，session A执行select语句的时候，判断可见性发现，c=3这个数据版本的trx_id，小于事务TA的低水位，因此认为这个数据可见，但，这个是脏读，由于低水位值会持续增加，而事务id从0开始计数，就导致了系统在这个时刻之后，所有的查询都会出现脏读的。而且，MySQL重启时max_trx_id也不会清0，也就是说重启MySQL，这个bug仍然存在。</p>
<p>假设一个MySQL实例的TPS是每秒50万，持续这个压力的话，在17.8年后，就会出现这个情况。如果TPS更高，这个年限自然也就更短了。但是，从MySQL的真正开始流行到现在，恐怕都还没有实例跑到过这个上限。不过，这个bug是只要MySQL实例服务时间够长，就必然会出现。</p>
<h4 id="thread_id"><a class="markdownIt-Anchor" href="#thread_id"></a> thread_id</h4>
<p>thread_id的逻辑是，系统保存了一个全局变量thread_id_counter，每新建一个连接，就将thread_id_counter赋值给这个新连接的线程变量。thread_id_counter定义的大小是4个字节，因此达到2<sup>32</sup>-1后，它就会重置为0，然后继续增加。但是，但是，你不会在<code>show processlist</code>里看到两个相同的thread_id，这是因为MySQL设计了一个唯一数组的逻辑，给新线程分配thread_id的时候，逻辑代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	new_id = thread_id_counter++;</span><br><span class="line">&#125; <span class="keyword">while</span> (!thread_ids.<span class="built_in">insert_unique</span>(new_id).second);</span><br></pre></td></tr></table></figure>
<h4 id="自增主键总结"><a class="markdownIt-Anchor" href="#自增主键总结"></a> 自增主键总结</h4>
<p>总的来说，每种自增id有各自的应用场景，在达到上限后的表现也不同：</p>
<ul>
<li>表的自增主键id达到上限后，再申请时它的值就不会改变，进而导致继续插入数据时报主键冲突的错误</li>
<li>row_id达到上限后，则会归0再重新递增，如果出现相同的row_id，后写入的数据会覆盖之前的数据</li>
<li>Xid只需要不在同一个binlog文件中出现重复值接口，但是概率极小，可以忽略不计</li>
<li>InnoDB的max_trx_id递增值MySQL每次重启都会被保存起来，所以上文中脏读的例子就是一个必现的bug</li>
<li>thread_id是使用中最常见的，也是处理的最好的自增id逻辑</li>
</ul>
<hr />
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>[1] <a href="https://time.geekbang.org/column/intro/100020801?tab=catalog">MySQL实战45讲</a></p>
<p>[2] <a href="https://dev.mysql.com/doc/refman/5.7/en/">MySQL5.7手册</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术原理</title>
    <url>/2021/08/18/Topic/</url>
    <content><![CDATA[<p>“细节是魔鬼”，本文将彻底透彻的分析JDK中常见但是又忽略的细节，从而积跬步，致千里。</p>
<span id="more"></span>
<h1 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h1>
<h2 id="集合的优点"><a class="markdownIt-Anchor" href="#集合的优点"></a> 集合的优点</h2>
<p>数组的缺点：</p>
<ul>
<li>长度开始时必须指定，而且一旦指定，不能更改</li>
<li>保存的必须为同一类型的元素</li>
<li>使用数组进行增加元素、删除元素、插入元素等相对复杂</li>
</ul>
<p>使用集合的好处：</p>
<ul>
<li>可以动态保存任意多个对象，使用比较方法</li>
<li>提供了一系列方便操作对象的方法：add、remove、set、get等</li>
</ul>
<p>在Java中，集合主要分为两大类：单例集合和多列集合，其中单例集合有List、Set，双列集合有Map。</p>
<h2 id="单列集合"><a class="markdownIt-Anchor" href="#单列集合"></a> 单列集合</h2>
<p>核心API - java.util.List</p>
<ul>
<li>java.util.ArrayList</li>
<li>java.util.Vector（线程安全）</li>
<li>java.util.LinkedList</li>
</ul>
<p>核心API - java.util.Set</p>
<ul>
<li>java.util.HashSet</li>
<li>java.util.TreeSet</li>
</ul>
<h2 id="多列集合"><a class="markdownIt-Anchor" href="#多列集合"></a> 多列集合</h2>
<p>核心API - java.util.Map</p>
<ul>
<li>java.util.Hashtable</li>
<li>java.util.HashMap</li>
<li>java.util.TreeMap</li>
</ul>
<h2 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h2>
<h3 id="arraylist源码分析"><a class="markdownIt-Anchor" href="#arraylist源码分析"></a> ArrayList源码分析</h3>
<p>核心特点：</p>
<ul>
<li>
<p>ArrayList中维护了一个Object类型的数组elementData：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5倍</p>
</li>
<li>
<p>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍</p>
</li>
</ul>
<div class="note info"><p>transient表示该属性不会被序列化。</p></div>
<h3 id="linkedlist源码分析"><a class="markdownIt-Anchor" href="#linkedlist源码分析"></a> LinkedList源码分析</h3>
<h2 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h2>
<p>Map接口的不同实现之间的关系：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210820170511.png" alt="image-20210820170511315" style="zoom:50%;" />
<p>具体实现类特点的说明：</p>
<ul>
<li>HashMap：它根据键的hashCode值缓存数据，大多数情况下可以直接定位它的值，因而具有很快的访问速度，但是遍历顺序却是不确定的。HashMap最多只允许一条记录的键位null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致，如果需要满足线程安全，可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap</li>
<li>Hashtable：Hashtable是历史遗留类，官方建议使用HashMap替代它，与HashMap不同的是，它继承自Dictionary类，并且是线程安全的，如果需要在线程安全的场合下使用，建议使用ConcurrentHashMap</li>
<li>LinkedHashMap：LinkedHashMap保存了记录的插入顺序，可以按照插入的顺序使用Iterator遍历</li>
<li>TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排列，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap，在使用TreeMao的时候，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常</li>
</ul>
<div class="note warning"><p>对于上述四种类型的类，要求映射种的key是不可变对象。不可变对象可以保证该对象在创建后它的哈希值不会被改变，如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p></div>
<h3 id="hashmap原理分析"><a class="markdownIt-Anchor" href="#hashmap原理分析"></a> HashMap原理分析</h3>
<p>HashMap是Java程序员使用频率最高的用于映射（键值对）处理的数据类型。JDK1.8对HashMap底层的实现进行了优化，例如引入了红黑树的数据结构和扩容优化等，因此，分析HashMap需要注意区别JDK1.7和JDK1.8的区别。</p>
<h4 id="存储方式"><a class="markdownIt-Anchor" href="#存储方式"></a> 存储方式</h4>
<p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加红黑树部分）实现的，如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210820172615.png" alt="image-20210820172450491" style="zoom:33%;" />
<p>在HashMap的底层存储实现上是存储在：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<p>其中Node具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node是HashMap的一个内部类，实现了Map.Enrty接口，本质就是一个映射（键值对）。上图中每个黑色圆点就是一个Node对象。</p>
<p>HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，HashMap就是采用了链地址法，即数组加链表的方式，在每个数组元素上都加上一个链表结构，当数据被Hash后，得到数组下标，把数据房子啊对应下标元素的链表上，例如程序执行如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">&quot;jycoder&quot;</span>,<span class="string">&quot;吉永超&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>系统将调用“jycoder”这个key的hashCode方法得到其哈希值，然后通过哈希算法的后两步运算（高位运算和取模运算）来定位该键值对的存储位置，有时两个key会定位到相同的问题，这个时候就发生了哈希碰撞。对于哈希算法而言，计算的结果越分散，哈希碰撞的概率就越小，Map的存取效率就会越高。</p>
<p>如果哈希桶的数组很大，即使较差的哈希算法也会比较分散，如果哈希桶的数组很小，即使再好的哈希算法也会出现较多碰撞，所以就需要根据实际情况确定哈希桶数组的大小，并且在此基础上设计好的哈希算法来减少哈希碰撞。</p>
<p>HashMap中有几个非常重要的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;  <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">int</span> modCount;  <span class="comment">// HashMap内部结构发生变化的次数</span></span><br><span class="line"><span class="keyword">int</span> size;  <span class="comment">// HashMap中实际存在的键值对数量</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>Node[] table</code>的初始长度length默认值是16，负载因子loadFactor默认值是0.75，threshold是HashMap所能容纳的最大数量的Node（键值对）的个数。它们之间的关系是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi><mo>=</mo><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>a</mi><mi>d</mi><mi>F</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">threshold=length*loadFactor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>，也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数就越多。</p>
<p>当超过threshold所能容纳的数量，HashMap就需要重新resize（扩容），扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的平衡选择，一般不要轻易修改，如果内存很多而又对时间效率要求很高，可以降低负载因子loadFactor的值；相反，如果内存紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
<p>size这个字段的含义就是HashMap中实际存在的键值对数量，而modCount主要记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。这里的内部结构发生变化指的是强调的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖步属于结构变化。</p>
<p>在HashMap中，哈希桶数组table的长度length大小必须为2<sup>n</sup>，HashMap采用这种设计，主要是为了取模和扩容时做优化，同时为了减少冲突，具体可以参考：<a href="https://blog.csdn.net/LLF_1241352445/article/details/81321991HashMap">关于hashMap的容量为什么是2的幂次方</a>。定位哈希桶索引位置时，也加入例如高位参与运算的过程。</p>
<p>不过，即使负载因子和哈希算法设计的再合理，也避免不了拉链过长的情况，一旦拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8中，对数据结构做了进一步的优化，引入了红黑树，当链表长度太长（默认超过8）时，链表就转换为了红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会运用到红黑树的插入、删除、查找等算法。具体可以参考<a href="https://jycoder.club/2021/06/24/leetcode/">红黑树</a>。</p>
<h4 id="方法实现"><a class="markdownIt-Anchor" href="#方法实现"></a> 方法实现</h4>
<h5 id="确定哈希桶数组索引位置"><a class="markdownIt-Anchor" href="#确定哈希桶数组索引位置"></a> 确定哈希桶数组索引位置</h5>
<p>不管增加、删除、查找键值对，定位到哈希桶数组的都是很关键的第一步，前面提到过HashMap的数据结构是数组和链表的结合， 如果每个位置上的元素数量只有一个，那么当我们使用哈希算法求得这个位置的时候，马上就可以获取对应位置的元素，而不需要遍历整个链表。HashMap定位数组索引位置的方法，直接决定了哈希方法的离散性能，源码的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length - <span class="number">1</span>);  <span class="comment">//第三步 取模运算，JDK1.8在计算位置的时候采用方法一返回的哈希值 &amp; 长度-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，在JDK1.8中，哈希算法基本步骤就是三步：取key的hashCode值、高位运算、取模运算。</p>
<p>对于任意给定的对象，只要它的hashCode方法返回值相同，那么程序调用方法所计算得到的Hash码值总是相同的。其中一种方式对将哈希值对数组长度取模运算，这样做的好处是元素的分布会相对来说比较均匀，但是，模运算的消耗还是比较大的。在HashMap中会调用方法二来计算对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h&amp;(table.length-1)来得到该对象的保存位，而HashMap的长度length总是为2<sup>n</sup>，此时，h&amp;(table.length-1)与h%length这两种运算结果式等价的，但是&amp;比%具有更高的效率。</p>
<div class="note info"><p>假设容量为2的n次幂的化，那么table.length的二进制就是一个1后面n个0，而length - 1就是一个0后面n个1，那么在计算为了说明h & (table.length - 1)，由于length - 1的二进制前面都是0，相当于舍弃了高位，只保留了后面的n位，后面的n刚好在0到length之间，也就是等于h % length取余。</p></div>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高位异或低16位实现的：<code>(h = k.hashcode())^(h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>下面举例说明，n位table的长度：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210820191752.png" alt="image-20210820191752063" style="zoom: 50%;" />
<h5 id="put方法"><a class="markdownIt-Anchor" href="#put方法"></a> put方法</h5>
<p>put方法的整体执行过程如下图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210820192026.png" alt="image-20210820192026243" style="zoom: 67%;" />
<p>JDK1.8put方法的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    	<span class="comment">// 步骤1：table位空则创建</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">    	<span class="comment">// 步骤2：计算index，并对null做处理</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="comment">// 步骤3：节点key存在，直接value</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="comment">// 步骤4：判断该链表为红黑树</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="comment">// 步骤5：该链为链表</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">// 链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="comment">// 步骤6：超过最大容量就扩容</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>详细说明如下：</p>
<ul>
<li>判断键值对数组table[i]是否为空或者为null，否则执行resize()进行扩容</li>
<li>根据键值key计算hash值得到插入元素数组的索引i，如果<code>table[i] == null</code>，直接新建节点添加，转向步骤6，否则转向步骤3</li>
<li>判断table[i]的首个元素是否和key一样，如果相同（hashCode &amp;&amp; equals）直接覆盖value，否则转向步骤4</li>
<li>判断table[i]是否为treeNode，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向步骤5</li>
<li>遍历table[i]，判断链表的长度是否大于8，大于8的话就把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作，遍历过程中若发现key已经存在直接覆盖value即可</li>
<li>插入成功后，判断实际存在的键值对数量size是否超过了最大容量，如果超过，就进行扩容操作</li>
</ul>
<h5 id="扩容机制"><a class="markdownIt-Anchor" href="#扩容机制"></a> 扩容机制</h5>
<p>扩容就是重新计算容量。在向HashMap对象中不断地添加元素，而HashMap对象内部地数组无法装在更多地元素时，对象就需要扩大数组的长度，以便能装入更多的元素。</p>
<p>JDK1.7中的扩容过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">    Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">       threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上的新元素总会被放在链表的头部位置，这样先放一个索引上的元素会被放到Entry链的尾部（如果发生了哈希冲突的话），在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>下面通过具体的例子来说明扩容过程。假设我们所使用的哈希算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size等于2，所以key3、5、7，put顺序依次为5、7、3/在mod 2以后冲突都在table[1]这里了。这里假设负载因子loadFactor=1，即当键值对的实际大小size大于table的实际大小时进行扩容。接下来三个步骤时哈希桶数组resize成4，然后所有的Node重新rehash的过程。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210822172355.png" alt="image-20210822172315873" style="zoom: 67%;" />
<p>在JDK1.8中，由于融入了红黑树，相对而言就比较复杂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引 + oldCap放到bucket里 </span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK1.8中对扩容做了一些优化，经过观察可以发现，我们每次扩容都会将长度扩容为原来的2倍，所以，元素的位置要么是在原来的位置，要么就是在原位置再移动2次幂的位置。在下图中，n为table的长度，图（a）表示扩容前key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算的结果。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210822174738.png" alt="image-20210822173845756" /></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit（红色），因此新的index就会发生这样的变化：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210822175112.png" alt="image-20210822175112399" /></p>
<p>因此，我们在扩充HashMap的时候，不再需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的哪个bit是1还是0就好了，是0就表示索引没有变化，是1就表示索引变成了“原索引+oldCap”，下图为16扩充至32的过程的示意图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210822175500.png" alt="image-20210822175500642" style="zoom: 67%;" />
<p>这个设计非常的巧妙，既省去了重新计算hash值得时间，同时，由于新增的1bit是0还是1可以认为是随机的，因为resize的过程，均匀的把之前的冲突节点分散到新的bucket了。需要注意的是，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但从上图可以看出，JDK1.8不会倒置。</p>
<h5 id="线程安全性"><a class="markdownIt-Anchor" href="#线程安全性"></a> 线程安全性</h5>
<p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。HashMap线程不安全的主要原因是在多线程的使用场景下可能会造成死循环，如果多个线程同时put时，如果同时触发了rehash操作，会导致HashMap中的链表中出现循环节点，进而使得后面get的时候，会出现死循环。</p>
<p>JDK1.7的示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">&quot;C&quot;</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;Thread1&quot;</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">&quot;B&quot;</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;Thread2&quot;</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">&quot;A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个元素的时候，map就需要进行resize了。</p>
<p>通过设置断点让线程1和线程2同时debug到transfer方法的首行，注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的<code>Entry next = e.next</code>，这一行，然后放开线程2的断点，让线程2进行resize，结果如下图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210823212826.png" alt="image-20210823212826409" style="zoom:50%;" />
<p>注意，Thread1的e指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p>
<p>线程一被调度回来执行，先是执行newTable[i] = e，然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210823213103.png" alt="image-20210823213103782" style="zoom:50%;" />
<p>e.next = newTable[i]导致key(3)指向了key(7)。注意：此时的key(7).next已经指向了key(3)，环形链表就这样出现了。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210823213234.png" alt="image-20210823213234071" style="zoom:50%;" />
<p>此时，再对map做索引位置为3的get操作，就会死循环在这里，CPU成功达到100%，比如，调用map.get(11)，即会引起死循环，而且map中还丢失了元素，(5,“c”)也已经不再map中了。</p>
<p>以上是JDK7的情况，JDK8虽然不会出现死循环的情况，但是会发生数据被覆盖的情况。</p>
<p><a href="https://zhuanlan.zhihu.com/p/76735726">https://zhuanlan.zhihu.com/p/76735726</a></p>
<h3 id="concurrenthashmap源码分析"><a class="markdownIt-Anchor" href="#concurrenthashmap源码分析"></a> ConcurrentHashMap源码分析</h3>
<h4 id="jdk17的实现"><a class="markdownIt-Anchor" href="#jdk17的实现"></a> JDK1.7的实现</h4>
<p>ConcurrentHashMap的成员变量中，包含了一个Segment的数组，Segment是ConcurrentHashMap的内部类，然后在Segment这个类中，包含了一个HashEntry数组，而HashEntry也是ConcurrentHashMap的内部类。HashEntry中，包含了key和value以及next指针（类似于HashMap中的Entry），所以HashEntry可以构成一个链表。</p>
<p>简单来说，ConcurrentHashMap数据结构为一个Segment数组，Segment的数组结构为HashEntry的数组，而HashEntry存放的就是我们的键值对，可以构成链表，它们之间的关系如下图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210826161224.png" alt="image-20210826161224347" style="zoom:70%;" />
<p>它的put方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       Segment&lt;K,V&gt; s;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="comment">// 二次哈希，以保证数据的分散性，避免哈希冲突</span></span><br><span class="line">       <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">       <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">       <span class="comment">// Unsafe 调用方式，直接获取相应的 Segment</span></span><br><span class="line">       <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">           s = ensureSegment(j);</span><br><span class="line">       <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在put方法中，首先是通过二次哈希减小哈希冲突的可能性，根据hash值以Unsafe调用方式，直接获取响应的Segment，最终将数据添加到容器中是由segment对象的put方法来完成。Segment对象的put方法源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无论如何，确保获取锁 scanAndLockForPut会去查找是否有key相同Node</span></span><br><span class="line">    ConcurrentHashMap.HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">            scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ConcurrentHashMap.HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        ConcurrentHashMap.HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (ConcurrentHashMap.HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="comment">// 更新已存在的key</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                        (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> ConcurrentHashMap.HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Segment对象本身就是一把锁，所以在新增数据的时候，相应的Segment对象块是被锁住的，其它线程并不能操作这个Segment对象，这样就保证了数据的安全性，在扩容的时候也是这样的，在JDK1.7中的ConcurrentHashMap扩容只是针对Segment对象中的HashEntry数组进行扩容，这个时候，由于Segment对象是一把锁，所以在rehash的过程中，其他线程无法对Segment的hash表做操作，这就解决了HashMap中由于put数据引起的闭环问题。</p>
<h4 id="jdk18的实现"><a class="markdownIt-Anchor" href="#jdk18的实现"></a> JDK1.8的实现</h4>
<p>在容器的安全上，1.8中的ConcurrentHashMap放弃了JDK1.7的分段技术，而是采用了CAS机制 + synchronized来保证并发安全性，但是在ConcurrentHashMap实现里保留了Segment定义，这仅仅是为了保证序列化时的兼容性，并没有结构上的用处。</p>
<p>在存储结构上，JDK1.8中ConcurrentHashMap放弃了HashEntry结构而是采用了跟HashMap结构非常相似，采用Node数组加链表（链表长度大于8的时候转为红黑树）的形式，Node节点设计如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">        ...省略...</span><br><span class="line"> &#125;   </span><br></pre></td></tr></table></figure>
<p>JDK1.8的ConcurrentHashMap的示意图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210826163233.png" alt="ConcurrentHashMap示意图" style="zoom:67%;" />
<p>ConcurrentHashMap新增的核心方法有两个：putVal（新增）和transfer（扩容）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到put方法本身也是调用putVal方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 key 为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 两次 hash ，减少碰撞次数</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 记录链表节点得个数</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 无条件得循环遍历整个 node 数组，直到成功</span></span><br><span class="line">    <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// lazy-load 懒加载的方式，如果当前 tab 容器为空，则初始化 tab 容器</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过Unsafe.getObjectVolatile()的方式获取数组对应index上的元素，如果元素为空，则直接无所插入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//// 利用CAS去进行无锁线程安全操作</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 fh == -1 ，说明正在扩容，那么该线程也去帮扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 协作扩容操作</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果上面都不满足，说明存在 hash 冲突，则使用 synchronized 加锁。锁住链表或者红黑树的头结点，来保证操作安全</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;<span class="comment">// 表示该节点是链表</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历该节点上的链表</span></span><br><span class="line">                        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//这里涉及到相同的key进行put就会覆盖原先的value</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                            (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ConcurrentHashMap.Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;<span class="comment">//插入链表尾部</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                        value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ConcurrentHashMap.TreeBin) &#123;<span class="comment">// 该节点是红黑树节点</span></span><br><span class="line">                        ConcurrentHashMap.Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((ConcurrentHashMap.TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入完之后，判断链表长度是否大于8，大于8就需要转换为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">// 如果存在相同的key ，返回原来的值</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计 size，并且检测是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细说明：</p>
<ul>
<li>在ConcurrentHashMap中不允许key val字段为空，所以第一步先校验key value的值。key、val两个字段都不是null才继续往下走，否则直接抛出了NullPointerException异常，这是与HashMap有区别的地方，HashMap是可以允许为空的</li>
<li>判断容器是否初始化，如果容器没有初始化，则调用initTable方法初始化</li>
</ul>
<p>initTable方法具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 负数表示正在初始化或扩容，等待</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 自旋等待</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// 执行 CAS 操作，期望将 sizeCtl 设置为 -1，-1 是正在初始化的标识</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// CAS 抢到了锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 对 table 进行初始化，初始化长度为指定值，或者默认值 16</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// sc 在初始化的时候用户可能会自定义，如果没有自定义，则是默认的</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">// 创建数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 指定下次扩容的大小，相当于 0.75 × n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Table本质上就是一个Node数组，其初始化过程也就是对Node数组的初始化过程，方法中使用了CAS策略执行初始化操作。初始化流程为：</p>
<ol>
<li>判断sizeCtl值是否小于0，如果小于0表示ConcurrentHashMap正在执行初始化操作，所以需要先等待一会，如果其他线程初始化失败还可以顶替上去</li>
<li>如果sizeCtl值大于等于0，则基于CAS策略抢占标记sizeCtl为-1，表示ConcurrentHashMap正在执行初始化，然后构造table，并更新sizeCtl的值</li>
</ol>
<p>初始化号table之后继续添加元素：</p>
<ul>
<li>根据双哈希之后的hash值找到数组对应的小标位置，如果该位置未存放节点，也就是说不存在哈希冲突，则使用CAS无锁的方法将数据添加到容器中，并且结束循环</li>
<li>如果并未满足第三步，加入到扩容大军中（ConcurrentHashMap扩容采用的是多线程的方式），扩容时并未跳出死循环，这一点就保证了容器在扩容的时候并不会有其他的线程进行数据添加操作，这也保证了容器的安全性</li>
<li>如果哈希冲突，则进行链表操作或者红黑树操作（如果链表树超过8，则修改链表为红黑树），在进行链表或者红黑树操作时，会使用synchronized锁把头结点锁住，保证了同时只有一个线程修改链表，防止出现链表成环</li>
<li>进行addCount（1L，binCount）操作，该操作会更新size大小，判断是否需要扩容</li>
</ul>
<p>addCount方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// X传入的是1，check 传入的是 putVal 方法里的 binCount，没有hash冲突的话为0，冲突就会大于1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    ConcurrentHashMap.CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">// 统计ConcurrentHashMap里面节点个数</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">            !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        ConcurrentHashMap.CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                        U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check就是binCount，binCount 最小都为0，所以这个条件一定会为true</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 这儿是自旋，需同时满足下面的条件</span></span><br><span class="line">        <span class="comment">// 1. 第一个条件是map.size 大于 sizeCtl，也就是说需要扩容</span></span><br><span class="line">        <span class="comment">// 2. 第二个条件是`table`不为null</span></span><br><span class="line">        <span class="comment">// 3. 第三个条件是`table`的长度不能超过最大容量</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// 该判断表示已经有线程在进行扩容操作了</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                    (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>addCount 方法做了两个工作：</p>
<ul>
<li>对 map 的 size 加一</li>
<li>检查是否需要扩容，或者是否正在扩容。如果需要扩容，就调用扩容方法，如果正在扩容，就帮助其扩容。</li>
</ul>
<p>最后是ConcurrentHashMap的扩容过程：</p>
<h3 id="hashtable源码分析"><a class="markdownIt-Anchor" href="#hashtable源码分析"></a> HashTable源码分析</h3>
<p>HashTable底层基于数组与链表实现，通过synchronized关键字保证线程安全，但作为已经废弃的类，建议使用ConcurrentHashMap。</p>
<p>HashTable的默认构造函数，容量为11，加载因子为0.75，扩容大小2倍+1。</p>
<h2 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h2>
<h3 id="hashset源码分析"><a class="markdownIt-Anchor" href="#hashset源码分析"></a> HashSet源码分析</h3>
<p>HashSet实现了Set接口，在底层就是在HashMap的基础上包了一层，只不过存储的时候value默认存储了一个Object的静态变量，取的时候也是只返回key：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>核心方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>HashSet是调用HashMap的put()方法，而put方法中有这样的逻辑，如果哈希值和key都一样，就会直接拿新的值覆盖旧值，而HashSet就是利用这个特性来保证唯一性的。</p>
<h1 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h1>
<h2 id="反射的定义"><a class="markdownIt-Anchor" href="#反射的定义"></a> 反射的定义</h2>
<p>反射主要指程序可以访问、检测和修改其本身状态或行为的一种能力，在Java环境中，反射机制允许程序在执行时获取类自身的定义信息，例如实现动态创建属性、方法和类的对象、变更属性的内容和执行特定的方法的功能，从而使Java具有动态语言的特性，增强了程序的灵活性可移植性。</p>
<h2 id="反射的作用"><a class="markdownIt-Anchor" href="#反射的作用"></a> 反射的作用</h2>
<p>Java反射机制的主要用于实现以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类型</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时调用任意一个对象的方法，哪怕可以调用private方法</li>
</ul>
<h2 id="核心api"><a class="markdownIt-Anchor" href="#核心api"></a> 核心API</h2>
<p>核心包 - java.lang.reflect</p>
<ul>
<li>java.lang.Class：代表一个类</li>
<li>java.lang.reflect.Method：代表类的方法</li>
<li>java.lang.reflect.Constructor：代表类的构造方法</li>
<li>java.lang.reflect.Array：提供了动态创建数组及访问数组元素的静态方法。该类中的所有方法都是静态的</li>
</ul>
<h1 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h1>
<h2 id="由来"><a class="markdownIt-Anchor" href="#由来"></a> 由来</h2>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP</title>
    <url>/2021/06/29/Spring-AOP/</url>
    <content><![CDATA[<p>AOP（Aspect Oriented Programming）面向切面编程，是针对面向对象编程的一种补充，同时也是Spring中第二个最核心的功能。在学习AOP之前，可以首先了解有关于Spring IoC的相关内容：<a href="https://jycoder.club/2020/07/16/SpringFramework/">Spring Framework</a>。</p>
<span id="more"></span>
<h1 id="spring-aop总览"><a class="markdownIt-Anchor" href="#spring-aop总览"></a> Spring AOP总览</h1>
<h2 id="知识储备"><a class="markdownIt-Anchor" href="#知识储备"></a> 知识储备</h2>
<h3 id="java-基础部分"><a class="markdownIt-Anchor" href="#java-基础部分"></a> Java 基础部分</h3>
<ul>
<li>Java 类加载器</li>
<li>Java 动态代理</li>
<li>Java 反射</li>
<li>字节码框架：ASM、CGLB</li>
</ul>
<p>类加载器的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        ClassLoader parent = classLoader;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            parent = parent.getParent();</span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里我们使用的其实就是AppClassLoader，而AppClassLoader又继承了URLClassLoader，因此在使用loadClass方法加载类文件的时候，通过我们只需要传递类全名即可，而无需获取全路径。</p>
<p>关于字节码框架部分，Spring内连了ASM框架。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210712104931.png" alt="image-20210712104930912" /></p>
<h3 id="oop-部分"><a class="markdownIt-Anchor" href="#oop-部分"></a> OOP 部分</h3>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h3 id="gof23-设计模式"><a class="markdownIt-Anchor" href="#gof23-设计模式"></a> GOF23 设计模式</h3>
<p>创建模式：</p>
<ul>
<li>抽象工程模式</li>
<li>构建器模式</li>
<li>工厂方法模式</li>
<li>原型模式</li>
<li>单例模式</li>
</ul>
<p>结构模式：</p>
<ul>
<li>适配器模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>装饰器模式</li>
<li>门面模式</li>
<li>亨元模式</li>
<li>代理模式</li>
</ul>
<p>行为模式：</p>
<ul>
<li>模板方法模式</li>
<li>中继器模式</li>
<li>责任链模式</li>
<li>观察者模式</li>
<li>策略模式</li>
<li>命令模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>解释器模式、迭代器模式、备忘录模式</li>
</ul>
<h3 id="spring-核心基础"><a class="markdownIt-Anchor" href="#spring-核心基础"></a> Spring 核心基础</h3>
<ul>
<li>Spring IoC容器</li>
<li>Spring Bean生命周期</li>
<li>Spring 配置元信息</li>
<li>Spring 事件</li>
<li>Spring 注解</li>
</ul>
<h2 id="oop局限性"><a class="markdownIt-Anchor" href="#oop局限性"></a> OOP局限性</h2>
<p>Java OOP存在哪些局限性？</p>
<ul>
<li>静态化语言：类结构一旦定义，不容易被修改</li>
<li>侵入性扩展：通过继承和组合组织新的类结构</li>
</ul>
<blockquote>
<p>静态语言即强类型语言，是指在编译时变量的数据类型即可确定的语言，典型的代表有C++、Java、Delphi、C#等。</p>
</blockquote>
<h2 id="aop常见使用场景"><a class="markdownIt-Anchor" href="#aop常见使用场景"></a> AOP常见使用场景</h2>
<h3 id="日志场景"><a class="markdownIt-Anchor" href="#日志场景"></a> 日志场景</h3>
<ul>
<li>诊断上下文，如：log4j或logback中的MDC</li>
<li>辅助信息，如：方法执行时间</li>
</ul>
<h3 id="统计场景"><a class="markdownIt-Anchor" href="#统计场景"></a> 统计场景</h3>
<ul>
<li>方法调用次数</li>
<li>执行异常次数</li>
<li>数据抽样</li>
<li>数值累加</li>
</ul>
<h3 id="安防场景"><a class="markdownIt-Anchor" href="#安防场景"></a> 安防场景</h3>
<ul>
<li>熔断，如：Netflix Hystrix</li>
<li>限流和降级：如：Ablibba Sentinel</li>
<li>认证和授权，如：Spring Security</li>
<li>监控，如JMX</li>
</ul>
<h3 id="性能场景"><a class="markdownIt-Anchor" href="#性能场景"></a> 性能场景</h3>
<ul>
<li>缓存，如Spring Cache</li>
<li>超时控制</li>
</ul>
<h2 id="aop概念"><a class="markdownIt-Anchor" href="#aop概念"></a> AOP概念</h2>
<ul>
<li>切面（Aspect）：一个关注点的模块化，在Spring AOP中。</li>
<li>连接点（Join Point）：在程序执行过程中某个特定的点，比如方法调用的时候或异常处理的时候。</li>
<li>通知（Advice）：在切面的某个特定的连接点上执行的动作。</li>
<li>切入点（Pointcut）：匹配连接点的断言，通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行。</li>
<li>织入（Weaving）：把切面连接到其他应用程序类型或者对象上，并创建一个被通知的对象。</li>
</ul>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210718125653.jpeg" style="zoom:50%;" />
<h2 id="java-aop设计模式"><a class="markdownIt-Anchor" href="#java-aop设计模式"></a> Java AOP设计模式</h2>
<p>代理模式：静态和动态代理</p>
<p>判断模式：类、方法、注解、参数、异常…</p>
<p>拦截模式：前置、后置、返回、异常</p>
<h2 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h2>
<p>Java静态代理的实现方式：</p>
<ul>
<li>常用OOP继承和组合相结合</li>
</ul>
<p>Java动态代理的实现方式：</p>
<ul>
<li>JDK动态代理</li>
<li>字节码提升，如CGLIB</li>
<li>AspectJ</li>
</ul>
<p>无论是静态代理还是动态代理都是基于接口，首先定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EchoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">echo</span><span class="params">(String message)</span> <span class="keyword">throws</span> NullPointerException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编写这个接口的默认实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEchoService</span> <span class="keyword">implements</span> <span class="title">EchoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[ECHO]&quot;</span> + message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyEchoService</span> <span class="keyword">implements</span> <span class="title">EchoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EchoService echoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyEchoService</span><span class="params">(EchoService echoService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.echoService = echoService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        String result = echoService.echo(message);</span><br><span class="line">        <span class="keyword">long</span> costTime = System.currentTimeMillis() - startTime;</span><br><span class="line">        System.out.println(<span class="string">&quot;echo方法执行时间: &quot;</span> + costTime);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用静态代理类的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyEchoService proxyEchoService = <span class="keyword">new</span> ProxyEchoService(<span class="keyword">new</span> DefaultEchoService());</span><br><span class="line">        proxyEchoService.echo(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态代理的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        Object proxy = Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[]&#123;EchoService.class&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (EchoService.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">                    ProxyEchoService echoService = <span class="keyword">new</span> ProxyEchoService(<span class="keyword">new</span> DefaultEchoService());</span><br><span class="line">                    <span class="keyword">return</span> echoService.echo((String) args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        EchoService echoService = (EchoService) proxy;</span><br><span class="line">        echoService.echo(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断模式"><a class="markdownIt-Anchor" href="#判断模式"></a> 判断模式</h2>
<p>判断来源：</p>
<p>类型（Class）、方法（Method）、注解（Annotation）、参数（Parameter）、异常（Exception）</p>
<p>在EchoService#echo中抛出一个异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EchoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">echo</span><span class="params">(String message)</span> <span class="keyword">throws</span> NullPointerException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>判断模式的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetFilterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        String targetClassName = <span class="string">&quot;org.jyc.thinking.in.spring.aop.overview.EchoService&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取当前线程ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="comment">// 获取目标类</span></span><br><span class="line">        Class&lt;?&gt; targetClass = classLoader.loadClass(targetClassName);</span><br><span class="line">        <span class="comment">// 过滤名称</span></span><br><span class="line">        Method method = ReflectionUtils.findMethod(targetClass, <span class="string">&quot;echo&quot;</span>, String.class);</span><br><span class="line">        System.out.println(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找方法throws类型为 NullPointerException</span></span><br><span class="line">        ReflectionUtils.doWithMethods(targetClass, method1 -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;仅抛出NullPointerException的方法为：&quot;</span> + method1);</span><br><span class="line">        &#125;, method2 -&gt; &#123;</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method2.getParameterTypes();</span><br><span class="line">            Class&lt;?&gt;[] exceptionTypes = method2.getExceptionTypes();</span><br><span class="line">            <span class="comment">// 异常列表长度为1并且异常类型为NullPointerException，参数列表为1并且，参数类型为String的方法</span></span><br><span class="line">            <span class="keyword">return</span> exceptionTypes.length == <span class="number">1</span> &amp;&amp; NullPointerException.class.equals(exceptionTypes[<span class="number">0</span>])</span><br><span class="line">                    &amp;&amp; parameterTypes.length == <span class="number">1</span> &amp;&amp; String.class.equals(parameterTypes[<span class="number">0</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拦截模式"><a class="markdownIt-Anchor" href="#拦截模式"></a> 拦截模式</h2>
<p>拦截类型大致分为三种：</p>
<ul>
<li>前置拦截（Before）</li>
<li>后置拦截（After）</li>
<li>异常拦截（Exception）</li>
</ul>
<p>定义前置拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeforeInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">before</span><span class="params">(Object proxy, Method method,Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义后置拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FinallyInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnResult 方法的返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">finalize</span><span class="params">(Object proxy, Method method, Object[] args, Object returnResult)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义异常拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FinallyInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnResult 方法的返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">finalize</span><span class="params">(Object proxy, Method method, Object[] args, Object returnResult)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用以上拦截器的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopInterceptorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前置模式 + 后置模式</span></span><br><span class="line">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        Object proxy2 = Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[]&#123;EchoService.class&#125;, (proxy, method, args) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (EchoService.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">                <span class="comment">// 前置拦截器</span></span><br><span class="line">                BeforeInterceptor beforeInterceptor = <span class="keyword">new</span> BeforeInterceptor() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">before</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                Long startTime = <span class="number">0L</span>;</span><br><span class="line">                Long endTime = <span class="number">0L</span>;</span><br><span class="line">                Object result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 前置拦截</span></span><br><span class="line">                    startTime = (Long) beforeInterceptor.before(proxy, method, args);</span><br><span class="line">                    EchoService echoService = <span class="keyword">new</span> DefaultEchoService();</span><br><span class="line">                    result = echoService.echo((String) args[<span class="number">0</span>]);</span><br><span class="line">                    <span class="comment">// 方法执行后置拦截器</span></span><br><span class="line">                    AfterReturnInterceptor afterReturnInterceptor = <span class="keyword">new</span> AfterReturnInterceptor() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Object <span class="title">after</span><span class="params">(Object proxy, Method method, Object[] args, Object returnResult)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    endTime = (Long) afterReturnInterceptor.after(proxy, method, args, result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 异常拦截器</span></span><br><span class="line">                    ExceptionInterceptor exceptionInterceptor = <span class="keyword">new</span> ExceptionInterceptor() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">intercpt</span><span class="params">(Object proxy, Method method, Object[] args, Throwable throwable)</span> </span>&#123;</span><br><span class="line">                            <span class="comment">// ...</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// finally 后置拦截器</span></span><br><span class="line">                    FinallyInterceptor finallyInterceptor = <span class="keyword">new</span> TimeFinallyInterceptor(startTime, endTime);</span><br><span class="line">                    Long costTime = (Long) finallyInterceptor.finalize(proxy, method, args, result);</span><br><span class="line">                    System.out.println(<span class="string">&quot;echo方法执行时间: &quot;</span> + costTime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        EchoService echoService = (EchoService) proxy2;</span><br><span class="line">        echoService.echo(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeFinallyInterceptor</span> <span class="keyword">implements</span> <span class="title">FinallyInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long startTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long endTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeFinallyInterceptor</span><span class="params">(Long startTime, Long endTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startTime = startTime;</span><br><span class="line">        <span class="keyword">this</span>.endTime = endTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">finalize</span><span class="params">(Object proxy, Method method, Object[] args, Object returnResult)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> endTime - startTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring-aop-功能概述"><a class="markdownIt-Anchor" href="#spring-aop-功能概述"></a> Spring AOP 功能概述</h2>
<p>核心特性：</p>
<ul>
<li>纯Java实现、无编译时特殊处理，不修改和控制ClassLoader</li>
<li>仅支持方法级别的Join Points</li>
<li>非完整AOP实现框架</li>
<li>Spring IoC容器整合</li>
<li>AspectJ注解驱动整合（非竞争关系）</li>
</ul>
<h2 id="spring-aop编程模型"><a class="markdownIt-Anchor" href="#spring-aop编程模型"></a> Spring AOP编程模型</h2>
<p>Spring AOP编程模型也主要分为三种：注解驱动、XML配置驱动和底层API</p>
<p>注解驱动：</p>
<ul>
<li>实现：Enable模块驱动，@EnableAspectJAutpProxy</li>
<li>注解：
<ul>
<li>激活AspectJ自动代理：@EnableAspectJAutoProxy</li>
<li>Aspect：@Aspect</li>
<li>pointcut：@Pointcut</li>
<li>Advice：@Before、@AfterReturning、@AfterThrowing、@After、@Around</li>
<li>introduction：@DeclareParents</li>
</ul>
</li>
</ul>
<p>XML配置驱动：</p>
<ul>
<li>实现：Spring Extensble XML Authoring</li>
<li>XML元素
<ul>
<li>激活AspectJ自动代理：&lt;aop:aspectj-autoproxy /&gt;</li>
<li>配置：&lt;aop:config /&gt;</li>
<li>Aspect：&lt;aop:aspect /&gt;</li>
<li>Pointcut：&lt;aop:pointcut /&gt;</li>
<li>Advice：&lt;aop:around /&gt;、&lt;aop:before /&gt;、&lt;aop:after-returning /&gt;、&lt;aop:after-throwing /&gt;和&lt;aop:after /&gt;</li>
<li>introduction：&lt;aop:declare-parents /&gt;</li>
<li>代理Scope：&lt;aop:scoped-proxy /&gt;</li>
</ul>
</li>
</ul>
<p>底层API：</p>
<ul>
<li>
<p>实现：JDK动态代理、CGLIB以及AspectJ</p>
</li>
<li>
<p>API：</p>
<ul>
<li>代理：AopProxy</li>
<li>配置：ProxyConfig</li>
<li>Join Point：JoinPoint</li>
<li>Pointcut：Ponintcut</li>
<li>Advice：Advice、BeforeAdvice、AfterAdvice、AfterReturningAdvice、ThrowsAdvice</li>
</ul>
</li>
</ul>
<h2 id="spring-aop-advice类型"><a class="markdownIt-Anchor" href="#spring-aop-advice类型"></a> Spring AOP Advice类型</h2>
<p>Advice类型：环绕（Around）、前置（Before）、后置（After）、异常（Exception），其中后置又包括了方法执行和finally执行两种。</p>
<h2 id="spring-aop代理实现"><a class="markdownIt-Anchor" href="#spring-aop代理实现"></a> Spring AOP代理实现</h2>
<p>Spring AOP的代理实现主要有三种：</p>
<ul>
<li>JDK动态代理实现 - 基于接口代理
<ul>
<li>org.springframework.aop.framework.JdkDynamicAopProxy</li>
</ul>
</li>
<li>CGLIB动态代理实现 - 基于类代理（字节码提升）
<ul>
<li>org.springframework.aop.framework.CglibAopProxy</li>
</ul>
</li>
<li>AspectJ适配实现
<ul>
<li>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</li>
</ul>
</li>
</ul>
<p>无论是哪一种实现，都实现了AopProxy接口，并且实现类都是非public的。</p>
<h2 id="jdk动态代理"><a class="markdownIt-Anchor" href="#jdk动态代理"></a> JDK动态代理</h2>
<p>为什么Proxy.newProxyInstance会生成新的字节码？</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210714132854.png" alt="image-20210714132854720" /></p>
<p>JDK会操作字符数组，生成一个代理类的Class对象。</p>
<h2 id="cglib动态代理"><a class="markdownIt-Anchor" href="#cglib动态代理"></a> CGLIB动态代理</h2>
<p>在Java中，面向对象通常而言指的是面向接口编程，或者也可以认为是面向锲约编程，JDK的动态代理会依赖于接口的定义，在没有定义接口的情况，还要实现AOP的功能，就需要CGLIB动态代理来实现。</p>
<p>使用CGLIB动态代理的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibDynamicProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 指定super Class = DefaultEchoService.class</span></span><br><span class="line">        Class&lt;DefaultEchoService&gt; superClass = DefaultEchoService.class;</span><br><span class="line">        enhancer.setSuperclass(superClass);</span><br><span class="line">        <span class="comment">// 指定拦截接口</span></span><br><span class="line">        enhancer.setInterfaces(<span class="keyword">new</span> Class[]&#123;EchoService.class&#125;);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object source, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">// Source -&gt; CGLIB子类</span></span><br><span class="line">                <span class="comment">// 目标类 -&gt; DefaultEchoService</span></span><br><span class="line">                <span class="comment">// 错误使用</span></span><br><span class="line"><span class="comment">//                Object result = method.invoke(source, args);</span></span><br><span class="line">                Object result = methodProxy.invokeSuper(source, args);</span><br><span class="line">                <span class="keyword">long</span> costTime = System.currentTimeMillis() - startTime;</span><br><span class="line">                System.out.println(<span class="string">&quot;[CGLIB字节码提升]echo方法执行时间: &quot;</span> + costTime);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        EchoService echoService = (EchoService)enhancer.create();</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(echoService.echo(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="aspectj代理"><a class="markdownIt-Anchor" href="#aspectj代理"></a> AspectJ代理</h2>
<p>借助于AspectJ强大的编译器，AspectJ有一套自己的语法，AspectJ的主要语法有：Aspect、Join Points、Pointcuts、Advice、introduction。</p>
<p>在注解方面，Spring和AspectJ的注解名称是相同的，不过在具体处理的时候略有差异。</p>
<h2 id="面试题"><a class="markdownIt-Anchor" href="#面试题"></a> 面试题</h2>
<h3 id="spring-aop和aspectj-aop存在哪些差别"><a class="markdownIt-Anchor" href="#spring-aop和aspectj-aop存在哪些差别"></a> Spring AOP和AspectJ AOP存在哪些差别？</h3>
<ul>
<li>Aspect是AOP完整实现，Spring AOP则是部分实现</li>
<li>Spring AOP比AspectJ使用更简单</li>
<li>Spring AOP整合AspectJ注解与Spring IoC容器</li>
<li>Spring AOP仅支持基于代理模式的AOP</li>
<li>Spring AOP仅支持方法级别的Pointcuts</li>
</ul>
<h1 id="spring-aop基础"><a class="markdownIt-Anchor" href="#spring-aop基础"></a> Spring AOP基础</h1>
<h2 id="aspectj注解驱动"><a class="markdownIt-Anchor" href="#aspectj注解驱动"></a> @AspectJ注解驱动</h2>
<p>激活@AspectJ模块的方式：</p>
<ul>
<li>注解激活 - @EnableAspectJAutoProxy</li>
<li>XML配置 - &lt;aop:aspectj-autoproxy /&gt;</li>
</ul>
<blockquote>
<p>如果使用的是SpringBoot，直接引入相关依赖就会自动激活，无需上述操作。</p>
</blockquote>
<p>声明Aspect：</p>
<ul>
<li>@Aspect</li>
</ul>
<p>使用注解激活的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 声名为切面类</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">// 激活Aspect 注解自动代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAnnotationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        context.register(AspectJAnnotationDemo.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        AspectJAnnotationDemo aspectJAnnotationDemo = context.getBean(AspectJAnnotationDemo.class);</span><br><span class="line">        System.out.println(aspectJAnnotationDemo);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，使用XML方式激活：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试激活结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 声名为切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJXmlDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:/META-INF/spring-aop-context.xml&quot;</span>);</span><br><span class="line">        AspectJXmlDemo aspectJXmlDemo = context.getBean(AspectJXmlDemo.class);</span><br><span class="line">        System.out.println(aspectJXmlDemo);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编程方式创建aspectj代理"><a class="markdownIt-Anchor" href="#编程方式创建aspectj代理"></a> 编程方式创建@AspectJ代理</h2>
<p>实现类：org.springframework.aop.aspectj.annotation.AspectJProxyFactory</p>
<p>使用的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAnnotationUsingAPIDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过创建一个HashMap的缓存</span></span><br><span class="line">        Map&lt;String, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建proxy</span></span><br><span class="line">        AspectJProxyFactory proxyFactory = <span class="keyword">new</span> AspectJProxyFactory();</span><br><span class="line">        <span class="comment">// 增加Aspect 配置类</span></span><br><span class="line">        proxyFactory.addAspect(AspectConfiguration.class);</span><br><span class="line"></span><br><span class="line">        proxyFactory.addAdvice(<span class="keyword">new</span> MethodBeforeAdvice() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;put&quot;</span>.equals(method.getName()) &amp;&amp; args.length == <span class="number">2</span>) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;当前存放是key：%s，value：%s \n&quot;</span>, args[<span class="number">0</span>], args[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 直接存储</span></span><br><span class="line"><span class="comment">//        cache.put(&quot;1&quot;, &quot;A&quot;);</span></span><br><span class="line">        <span class="comment">// 通过代理对象存储</span></span><br><span class="line">        Map&lt;String, Object&gt; proxy = proxyFactory.getProxy();</span><br><span class="line">        proxy.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标准工厂api"><a class="markdownIt-Anchor" href="#标准工厂api"></a> 标准工厂API</h2>
<p>实现类：org.springframework.aop.framework.ProxyFactory</p>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactoryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultEchoService defaultEchoService = <span class="keyword">new</span> DefaultEchoService();</span><br><span class="line">        <span class="comment">// 注入目标对象（被代理）</span></span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(defaultEchoService);</span><br><span class="line">        <span class="comment">// 如果对象存在接口的话，生成的代理对象还是JDK动态代理的</span></span><br><span class="line">        proxyFactory.setTarget(DefaultEchoService.class);</span><br><span class="line">        <span class="comment">// 添加Advice</span></span><br><span class="line">        proxyFactory.addAdvice(<span class="keyword">new</span> EchoServiceMethodInterceptor());</span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        EchoService echoService = (EchoService)proxyFactory.getProxy();</span><br><span class="line">        System.out.println(echoService.echo(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="aspectj-pointcut指令与表达式"><a class="markdownIt-Anchor" href="#aspectj-pointcut指令与表达式"></a> @AspectJ Pointcut指令与表达式</h2>
<p>支持的指令：execution、within、this、target、args。</p>
<blockquote>
<p>pointcut只是用来筛选，而不会执行具体的动作，具体的动作由advice来执行，并且是一对多的关系。在Spring当中，pointcut的名称就是对应方法的名称。</p>
</blockquote>
<p>首先完善之前的Aspect的配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span>  <span class="comment">// 匹配Join Point</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyPublicMethod</span><span class="params">()</span> </span>&#123; <span class="comment">// 方法名即Pointcut名称</span></span><br><span class="line">        System.out.println(<span class="string">&quot;@Pointcut at any public method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;anyPublicMethod()&quot;)</span> <span class="comment">// Join Point拦截动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAnyPublicMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;@Before any public method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察配置类的起的作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAnnotatedPointcutDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        context.register(AspectJAnnotatedPointcutDemo.class, AspectConfiguration.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        AspectJAnnotatedPointcutDemo aspectJAnnotationDemo = context.getBean(AspectJAnnotatedPointcutDemo.class);</span><br><span class="line">        aspectJAnnotationDemo.execute();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Pointcut对应的方法并没有被执行，这也验证了我们前面的结论。通常情况下，我们会将这个Pointcut声明的方法定义为private，并且方法当中没有实现，然后再advice当中引用。</p>
<h2 id="xml配置pointcut"><a class="markdownIt-Anchor" href="#xml配置pointcut"></a> XML配置Pointcut</h2>
<p>XML配置的方式：&lt;aop:pointcut /&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;aspectXmlConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.aop.features.aspect.AspectXmlConfiguration&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;AspectXmlConfig&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aspectXmlConfig&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;anyPublicMethod&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(public * *(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforeAnyPublicMethod&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;anyPublicMethod&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;echoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.aop.overview.DefaultEchoService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>观察使用XML方式来实现Pointcut：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJSchemaBasedPointcutDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:/META-INF/spring-aop-context.xml&quot;</span>);</span><br><span class="line">        context.refresh();</span><br><span class="line">        EchoService echoService = context.getBean(EchoService.class);</span><br><span class="line">        System.out.println(echoService.echo(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用注解能够实现的，XML方式也都能实现。</p>
<h2 id="api实现pointcut"><a class="markdownIt-Anchor" href="#api实现pointcut"></a> API实现Pointcut</h2>
<p>核心API - org.springframework.aop.Pointcut，其中有两个方法：</p>
<ul>
<li>org.springframework.aop.ClassFilter</li>
<li>org.springframework.aop.MethodMatcher</li>
</ul>
<p>适配实现 - DefaultPointcutAdvisor</p>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointcutApiDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EchoServicePointcut pointcut = <span class="keyword">new</span> EchoServicePointcut(<span class="string">&quot;echo&quot;</span>, EchoService.class);</span><br><span class="line">        <span class="comment">// 将Pointcut适配成Advisor</span></span><br><span class="line">        DefaultPointcutAdvisor advisor = <span class="keyword">new</span> DefaultPointcutAdvisor(pointcut, <span class="keyword">new</span> EchoServiceMethodInterceptor());</span><br><span class="line">        DefaultEchoService defaultEchoService = <span class="keyword">new</span> DefaultEchoService();</span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(defaultEchoService);</span><br><span class="line">        <span class="comment">// 添加Advisor</span></span><br><span class="line">        proxyFactory.addAdvisor(advisor);</span><br><span class="line">        EchoService echoService = (EchoService) proxyFactory.getProxy();</span><br><span class="line">        System.out.println(echoService.echo(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意的是，不能直接创建Pointcut对象，而是要通过适配的方式间接实现。</p>
<h2 id="aspectj拦截动作"><a class="markdownIt-Anchor" href="#aspectj拦截动作"></a> @AspectJ拦截动作</h2>
<p>@Around 与@Before有什么区别呢？</p>
<p>首先我们在AspectConfiguration中定义一个@Around：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;anyPublicMethod()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroundAnyPublicMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;@Around any public method.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时会发现，除了这行输出外没有其他任何信息，修改这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;anyPublicMethod()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAnyPublicMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;@Around any public method.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到所有的信息均已成功打印，这是因为，@Around需要去显式的触发目标方法，而@Before则不用。</p>
<h2 id="xml配置around-advice"><a class="markdownIt-Anchor" href="#xml配置around-advice"></a> XML配置Around Advice</h2>
<p>XML配置方式：&lt;aop:around /&gt;</p>
<p>类似的，我们将之前的aroundAnyPublicMethod方法添加到AspectXmlConfiguration，然后在XML中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;aroundAnyPublicMethod&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;anyPublicMethod&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="aspectj的前置动作"><a class="markdownIt-Anchor" href="#aspectj的前置动作"></a> @AspectJ的前置动作</h2>
<p>Before Advice注解 - org.aspectj.lang.annotation.Before</p>
<p>@Before与@Around谁优先执行？</p>
<p>通过输出结果可以观察到，@Around先于@Before执行，这也是为什么Spring API里面没有提供@Around的Advice接口，因为它实际上都是通过拦截模式来操作的，只是@Before和@After以及@Around是不同的实现，所以不需要每一个单独有一个接口。</p>
<p>如果有多个@Before声明后，如何控制它们的顺序呢？答案是可以通过实现org.springframework.core.Ordered接口，或者使用@Order注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectConfiguration2</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyPublicMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;anyPublicMethod()&quot;)</span> <span class="comment">// Join Point拦截动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAnyPublicMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;@Before any public method.(2)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候程序执行的顺序就发生了变化，beforeAnyPublicMethod2优先于@Around方法执行了。要注意的是，这里不能定义最高优先级HIGHEST_PRECEDENCE。</p>
<h2 id="xml配置before-advice"><a class="markdownIt-Anchor" href="#xml配置before-advice"></a> XML配置Before Advice</h2>
<p>XML元素的标签 - &lt;aop:before &gt;</p>
<ul>
<li>
<p>声明规则</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>属性设置（来源于Spring AOP Schema类型basicAdviceType）</p>
<ul>
<li>pointcut：Pointcut表达式内容</li>
<li>pointcut-ref：Pointcut表达式名称</li>
</ul>
<h2 id="api实现before-advice"><a class="markdownIt-Anchor" href="#api实现before-advice"></a> API实现Before Advice</h2>
</li>
</ul>
<p>核心接口 - org.springframework.aop.BeforeAdvice</p>
<ul>
<li>类型：标记接口，与org.aopalliance.aop.Advice类似</li>
<li>方法JoinPoint扩展 - org.springframework.aop.MethodBeforeAdvice</li>
<li>接收对象 - org.springframework.aop.framework.AdvisedSupport
<ul>
<li>基础实现类 - org.springframework.aop.framework.ProxyCreatorSupport
<ul>
<li>常见实现类：
<ul>
<li>org.springframework.aop.framework.ProxyFactory</li>
<li>org.springframework.aop.framework.ProxyFactoryBean</li>
<li>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="aspect后置动作"><a class="markdownIt-Anchor" href="#aspect后置动作"></a> @Aspect后置动作</h2>
<p>After Advice注解：</p>
<ul>
<li>方法返回后：@org.aspectj.lang.annotation.AfterReturning</li>
<li>异常发生后：@org.aspectj.lang.annotation.AfterThrowing</li>
<li>finally执行：org.aspectj.lang.annotation.After</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@After(&quot;anyPublicMethod()&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalizeAnyPublicMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;@After any public method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@AfterReturning(&quot;anyPublicMethod()&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterAnyPublicMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;@AfterReturning any public method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@AfterThrowing(&quot;anyPublicMethod()&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingAnyPublicMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;@AfterThrowing any public method.&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中@After方法会最后会被执行， @AfterThrowing会在方法抛出异常的时候执行。</p>
<h2 id="xml配置after-advice"><a class="markdownIt-Anchor" href="#xml配置after-advice"></a> XML配置After Advice</h2>
<p>XML元素 - &lt;aop:after &gt;</p>
<ul>
<li>
<p>声明规则</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>属性设置（来源于Spring AOP Schema类型 basicAdviceType）</p>
<ul>
<li>pointcut：Pointcut表达式内容</li>
<li>pointcut-ref：Pointcut表达式名称</li>
</ul>
</li>
</ul>
<p>配置示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;finalizeAnyPublicMethod&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;anyPublicMethod&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterAnyPublicMethod&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;anyPublicMethod&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowingAnyPublicMethod&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;anyPublicMethod&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="api实现after-advice"><a class="markdownIt-Anchor" href="#api实现after-advice"></a> API实现After Advice</h2>
<p>核心接口 - org.springframework.aop.AfterAdvice</p>
<ul>
<li>类型：标记接口，与org.aopalliance.aop.Advice类似</li>
<li>扩展
<ul>
<li>org.springframework.aop.AfterReturningAdvice</li>
<li>org.springframework.aop.ThrowsAdvice</li>
</ul>
</li>
<li>接收对象 - org.springframework.aop.framework.AdvisedSupport
<ul>
<li>基础实现类 - org.springframework.aop.framework.ProxyCreatorSupport
<ul>
<li>常见实现类
<ul>
<li>org.springframework.aop.framework.ProxyFactory</li>
<li>org.springframework.aop.framework.ProxyFactoryBean</li>
<li>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">proxyFactory.addAdvice(<span class="keyword">new</span> AfterReturningAdvice() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;put&quot;</span>.equals(method.getName()) &amp;&amp; args.length == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;[AfterReturningAdvice]当前存放是key：%s，新存放的value：%s \n,之前关联的Value：%s&quot;</span>,</span><br><span class="line">                              args[<span class="number">0</span>], <span class="comment">// key</span></span><br><span class="line">                              args[<span class="number">1</span>], <span class="comment">// new value</span></span><br><span class="line">                              returnValue <span class="comment">// old value</span></span><br><span class="line">                             );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="自动动态代理"><a class="markdownIt-Anchor" href="#自动动态代理"></a> 自动动态代理</h2>
<p>代表实现</p>
<ul>
<li>org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator</li>
<li>org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator</li>
<li>org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</li>
</ul>
<p>相关的示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;echoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.aop.overview.DefaultEchoService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Advice Bean = MethodInterceptor Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;echoServiceMethodInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.aop.features.interceptor.EchoServiceMethodInterceptor&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;property name=&quot;beanNames&quot; value=&quot;*&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;property name=&quot;interceptorNames&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;value&gt;echoServiceMethodInterceptor&lt;/value&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  AutoProxy Bean  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Pointcut Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;echoServicePointcut&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.aop.features.pointcut.EchoServicePointcut&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;echo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.jyc.thinking.in.spring.aop.overview.EchoService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- PointcutAdvisor Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;echoServicePointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;echoServiceMethodInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="替换targetsource"><a class="markdownIt-Anchor" href="#替换targetsource"></a> 替换TargetSource</h2>
<p>TargetSource（目标源）是被代理的target（目标对象）实例的来源。TargetSource被用于获取当前MethodInvocation（方法调用）所需要的目标对象target。换句话说，proxy代理的并不是target，而是targetSource对象。</p>
<p>通常情况下，一个代理对象只能代理一个target，每次方法调用目标也是唯一的target。但是如果让proxy代理TargetSource，可以使得每次方法调用的target实例都不相同。采用这种机制，可以使得方法的调用更加灵活。</p>
<p>代表实现：</p>
<ul>
<li>org.springframework.aop.target.HotSwappableTargetSource</li>
<li>org.springframework.aop.target.AbstractPoolingTargetSource</li>
<li>org.springframework.aop.target.PrototypeTargetSource</li>
<li>org.springframework.aop.target.ThreadLocalTargetSource</li>
<li>org.springframework.aop.target.SingletonTargetSource</li>
</ul>
<h2 id="面试题-2"><a class="markdownIt-Anchor" href="#面试题-2"></a> 面试题</h2>
<h3 id="spring-aop支持哪些类型的advice"><a class="markdownIt-Anchor" href="#spring-aop支持哪些类型的advice"></a> Spring AOP支持哪些类型的Advice？</h3>
<ul>
<li>Around Advice</li>
<li>Before Advice</li>
<li>After Advice
<ul>
<li>After</li>
<li>AfterReturning</li>
<li>AfterThrowing</li>
</ul>
</li>
</ul>
<h3 id="spring-aop编程模型有哪些代表组件有哪些"><a class="markdownIt-Anchor" href="#spring-aop编程模型有哪些代表组件有哪些"></a> Spring AOP编程模型有哪些，代表组件有哪些？</h3>
<p>注解驱动：解释和整合AspectJ注解，如@EnableAspectJAutoProxy</p>
<p>XML配置：AOP与IoC Schema-Based相结合</p>
<p>API编程：如JoinPoint、Pointcut、Advice和ProxyFactory等</p>
<h3 id="spring-aop三种实现方式是如何进行设计的"><a class="markdownIt-Anchor" href="#spring-aop三种实现方式是如何进行设计的"></a> Spring AOP三种实现方式是如何进行设计的？</h3>
<p>// …</p>
<h1 id="spring-aop设计与实现"><a class="markdownIt-Anchor" href="#spring-aop设计与实现"></a> Spring AOP设计与实现</h1>
<h2 id="api整体设计"><a class="markdownIt-Anchor" href="#api整体设计"></a> API整体设计</h2>
<ul>
<li>Join Point - Joinpoint</li>
<li>Pointcut - Pointcut</li>
<li>Advice执行动作 - Advice</li>
<li>Advice容器 - Advisor</li>
<li>Introduction - IntroductionInfo</li>
<li>代理对象创建基础类 - ProxyCreatorSupport</li>
<li>代理工厂 - ProxyFactory、ProxyFactorySupport</li>
<li>IoC容器自动代理抽象 - AbstractAutoProxyCreator</li>
</ul>
<h2 id="接入点接口joinpoint"><a class="markdownIt-Anchor" href="#接入点接口joinpoint"></a> 接入点接口Joinpoint</h2>
<p>Interceptor执行上下文 - Invocation</p>
<ul>
<li>方法拦截器上下文 - MethodInvocation</li>
<li><s>构造器拦截器执行上下文 - ContructorInvocation</s></li>
</ul>
<p>MethodInvocation实现</p>
<ul>
<li>基于反射 - ReflectiveMethodInvocation</li>
<li>基于CGLIB实现 - CglibMethodInvocation</li>
</ul>
<blockquote>
<p>Spring AOP仅支持方法级别的拦截，构造器拦截只有在AspectJ中有相应的实现。</p>
</blockquote>
<h2 id="joinpoint条件接口"><a class="markdownIt-Anchor" href="#joinpoint条件接口"></a> Joinpoint条件接口</h2>
<p>核心组件：</p>
<ul>
<li>类过滤器 - ClassFilter</li>
<li>方法匹配器 - MethodMatcher</li>
</ul>
<p>可以直接实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServiceEchoMethodPointcut</span> <span class="keyword">implements</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EchoServiceEchoMethodPointcut INSTANCE = <span class="keyword">new</span> EchoServiceEchoMethodPointcut();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EchoServiceEchoMethodPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> EchoService.class.isAssignableFrom(clazz); <span class="comment">// 凡是EchoService接口或者子接口，子类均可</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodMatcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123; <span class="comment">// echo(String)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;echo&quot;</span>.equals(method.getName()) &amp;&amp;</span><br><span class="line">                        method.getParameterTypes().length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                        Objects.equals(String.class, method.getParameterTypes()[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试拦截的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointcutApiDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EchoServiceEchoMethodPointcut pointcut = EchoServiceEchoMethodPointcut.INSTANCE;</span><br><span class="line">        <span class="comment">// 将Pointcut适配成Advisor</span></span><br><span class="line">        DefaultPointcutAdvisor advisor = <span class="keyword">new</span> DefaultPointcutAdvisor(pointcut, <span class="keyword">new</span> EchoServiceMethodInterceptor());</span><br><span class="line">        DefaultEchoService defaultEchoService = <span class="keyword">new</span> DefaultEchoService();</span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(defaultEchoService);</span><br><span class="line">        <span class="comment">// 添加Advisor</span></span><br><span class="line">        proxyFactory.addAdvisor(advisor);</span><br><span class="line">        EchoService echoService = (EchoService) proxyFactory.getProxy();</span><br><span class="line">        System.out.println(echoService.echo(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pointcut组合实现"><a class="markdownIt-Anchor" href="#pointcut组合实现"></a> Pointcut组合实现</h2>
<p>组合实现 - org.springframework.aop.support.ComposablePointcut</p>
<p>这个API在实现的时候使用了一些工具类：</p>
<ul>
<li>ClassFilter工具类 - ClassFilters</li>
<li>MethodMatcher工具类 - MethodMatchers</li>
<li>Pointcut工具类 - Pointcuts</li>
</ul>
<p>其中有两个核心方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求并集</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComposablePointcut <span class="title">union</span><span class="params">(Pointcut other)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.methodMatcher = MethodMatchers.union(</span><br><span class="line">			<span class="keyword">this</span>.methodMatcher, <span class="keyword">this</span>.classFilter, other.getMethodMatcher(), other.getClassFilter());</span><br><span class="line">	<span class="keyword">this</span>.classFilter = ClassFilters.union(<span class="keyword">this</span>.classFilter, other.getClassFilter());</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求交集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComposablePointcut <span class="title">intersection</span><span class="params">(Pointcut other)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.classFilter = ClassFilters.intersection(<span class="keyword">this</span>.classFilter, other.getClassFilter());</span><br><span class="line">	<span class="keyword">this</span>.methodMatcher = MethodMatchers.intersection(<span class="keyword">this</span>.methodMatcher, other.getMethodMatcher());</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组合Pointcut的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointcutApiDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EchoServicePointcut echoServicePointcut = <span class="keyword">new</span> EchoServicePointcut(<span class="string">&quot;echo&quot;</span>, EchoService.class);</span><br><span class="line">        ComposablePointcut pointcut = <span class="keyword">new</span> ComposablePointcut(EchoServiceEchoMethodPointcut.INSTANCE);</span><br><span class="line">        <span class="comment">// 组合实现</span></span><br><span class="line">        pointcut.intersection(echoServicePointcut.getClassFilter());</span><br><span class="line">        pointcut.intersection(echoServicePointcut.getMethodMatcher());</span><br><span class="line">        <span class="comment">// 将Pointcut适配成Advisor</span></span><br><span class="line">        DefaultPointcutAdvisor advisor = <span class="keyword">new</span> DefaultPointcutAdvisor(pointcut, <span class="keyword">new</span> EchoServiceMethodInterceptor());</span><br><span class="line">        DefaultEchoService defaultEchoService = <span class="keyword">new</span> DefaultEchoService();</span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(defaultEchoService);</span><br><span class="line">        <span class="comment">// 添加Advisor</span></span><br><span class="line">        proxyFactory.addAdvisor(advisor);</span><br><span class="line">        EchoService echoService = (EchoService) proxyFactory.getProxy();</span><br><span class="line">        System.out.println(echoService.echo(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pointcut便利实现"><a class="markdownIt-Anchor" href="#pointcut便利实现"></a> Pointcut便利实现</h2>
<p>通常而言，有三种Pointcut便利实现：</p>
<ul>
<li>静态Pointcut - StaticMethodMatcherPointcut</li>
<li>正则表达式Pointcut - JdkRegexpMethodPointcut</li>
<li>控制流Pointcut - ControlFlowPointcut</li>
</ul>
<h2 id="pointcut-aspectj实现"><a class="markdownIt-Anchor" href="#pointcut-aspectj实现"></a> Pointcut AspectJ实现</h2>
<p>实现类 - org.springframework.aop.aspectj.AspectJExpressionPointcut</p>
<p>指令支持 - SUPPORTED_PRIMITIVES字段</p>
<p>表达式 - org.aspectj.weaver.tools.PointcutExpression</p>
<blockquote>
<p>Spring当中并没有定义新的AOP表达式，而是使用了AspectJ的实现。</p>
</blockquote>
<h2 id="joinpoint执行动作接口"><a class="markdownIt-Anchor" href="#joinpoint执行动作接口"></a> Joinpoint执行动作接口</h2>
<p>Around Advice - Interceptor</p>
<ul>
<li>方法拦截器 - MethodInterceptor</li>
<li>构造器拦截器 - ControInterceptor</li>
</ul>
<p>前置动作</p>
<ul>
<li>标准接口 - org.springframework.aop.BeforeAdvice</li>
<li>方法级别 - org.springframework.aop.MethodBeforeAdvice</li>
</ul>
<p>后置动作</p>
<ul>
<li>org.springframework.aop.AfterAdvice</li>
<li>org.springframework.aop.AfterReturningAdvice</li>
<li>org.springframework.aop.ThrowsAdvice</li>
</ul>
<blockquote>
<p>Interceptor就可以认为是AroundAdvice。</p>
</blockquote>
<h2 id="before-advice标准实现"><a class="markdownIt-Anchor" href="#before-advice标准实现"></a> Before Advice标准实现</h2>
<p>所谓标准实现，是指Spring在引入AspectJ之前的AOP实现。</p>
<ul>
<li>标准接口 - org.springframework.aop.BeforeAdvice</li>
<li>方法级别 - org.springframework.aop.MethodBeforeAdvice</li>
</ul>
<p>实现：org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor</p>
<blockquote>
<p>用户实现的BeforeAdvice和MethodBeforeAdvice会被包装成MethodBeforeAdviceInterceptor，在Spring AOP框架内部进行执行。</p>
</blockquote>
<h2 id="before-advice-aspectj实现"><a class="markdownIt-Anchor" href="#before-advice-aspectj实现"></a> Before Advice AspectJ实现</h2>
<p>实现类 - org.springframework.aop.aspectj.AspectJMethodBeforeAdvice</p>
<h2 id="after-advice标准实现"><a class="markdownIt-Anchor" href="#after-advice标准实现"></a> After Advice标准实现</h2>
<p>相关的接口：</p>
<ul>
<li>org.springframework.aop.AfterAdvice</li>
<li>org.springframework.aop.AfterReturningAdvice</li>
<li>org.springframework.aop.ThrowsAdvice</li>
</ul>
<p>实现类：</p>
<ul>
<li>org.springframework.aop.framework.adapter.ThrowsAdviceInterceptor</li>
<li>org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor</li>
</ul>
<p>我们可以自己实现一个ThrowsAdvice：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThrowsAdvice</span> <span class="keyword">implements</span> <span class="title">ThrowsAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法名称必须为afterThrowing</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(RuntimeException e)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Exception: %S/n&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Method method, Object[] args, Object target, Exception e)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;method : %s,args: %s,Exception: %S/n&quot;</span>,</span><br><span class="line">                method,</span><br><span class="line">                Arrays.asList(args),</span><br><span class="line">                target,</span><br><span class="line">                e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsAdviceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThrowsAdviceDemo instance = <span class="keyword">new</span> ThrowsAdviceDemo();</span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(instance);</span><br><span class="line">        proxyFactory.addAdvice(<span class="keyword">new</span> MyThrowsAdvice());</span><br><span class="line">        ThrowsAdviceDemo proxy = (ThrowsAdviceDemo) proxyFactory.getProxy();</span><br><span class="line">        proxy.execute();</span><br><span class="line">        proxy.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">if</span> (random.nextBoolean()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;For Purpose&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="after-advice-aspectj实现"><a class="markdownIt-Anchor" href="#after-advice-aspectj实现"></a> After Advice AspectJ实现</h2>
<p>实现的接口与Spring标准实现没有什么区别：</p>
<ul>
<li>org.springframework.aop.AfterAdvice</li>
<li>org.springframework.aop.AfterReturningAdvice</li>
<li>org.springframework.aop.ThrowsAdvice</li>
</ul>
<p>实现：</p>
<ul>
<li>org.springframework.aop.aspectj.AspectJAfterAdvice</li>
<li>org.springframework.aop.aspectj.AspectJAfterReturningAdvice</li>
<li>org.springframework.aop.aspectj.AspectJAfterThrowingAdvice</li>
</ul>
<h2 id="advisor接口"><a class="markdownIt-Anchor" href="#advisor接口"></a> Advisor接口</h2>
<p>Advisor是AOP概念中没有的，只在Spring当中有这个概念。</p>
<p>接口 - org.springframework.aop.Advisor</p>
<p>通用实现 - org.springframework.aop.support.DefaultPointcutAdvisor</p>
<blockquote>
<p>Advisor可以认为是Advice的容器，并且是一对一的关系，即一个Advisor持有一个Advice。实际上，在Spring内部传递Advice的时候都传递的是Advisor对象。</p>
</blockquote>
<h2 id="pointcutadvisor接口"><a class="markdownIt-Anchor" href="#pointcutadvisor接口"></a> PointcutAdvisor接口</h2>
<p>接口 - org.springframework.aop.PointcutAdvisor</p>
<p>通用实现 ：</p>
<ul>
<li>org.springframework.aop.support.DefaultPointcutAdvisor</li>
</ul>
<p>AspectJ实现：</p>
<ul>
<li>org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor</li>
<li>org.springframework.aop.aspectj.AspectJPointcutAdvisor</li>
</ul>
<p>静态方法实现：</p>
<ul>
<li>org.springframework.aop.support.StaticMethodMatcherPointcutAdvisor</li>
</ul>
<p>IoC容器实现：</p>
<ul>
<li>org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor</li>
</ul>
<p>基本所有的PointcutAdvisor实现可以看成是一个容器，其中包含了Pointcut与Advice，并且具备相对顺序的特性。</p>
<h2 id="intorductionadvisor接口"><a class="markdownIt-Anchor" href="#intorductionadvisor接口"></a> IntorductionAdvisor接口</h2>
<p>接口 - org.springframework.aop.IntroductionAdvisor</p>
<p>元信息：</p>
<ul>
<li>org.springframework.aop.IntroductionInfo</li>
</ul>
<p>通用实现：</p>
<ul>
<li>org.springframework.aop.support.DefaultIntroductionAdvisor</li>
</ul>
<p>AspectJ实现：</p>
<ul>
<li>org.springframework.aop.aspectj.DeclareParentsAdvisor</li>
</ul>
<p>IntroductionAdvisor只过滤类型，而不关心方法。其中IntroductionAdvisor实现了IntroductionInfo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntroductionInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the additional interfaces introduced by this Advisor or Advice.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the introduced interfaces</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Class&lt;?&gt;[] getInterfaces();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个类实现了多个接口，如果只想对其中部分接口进行代理，就可以使用IntroductionInfo来进行过滤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntroductionAdvisorDemo</span> <span class="keyword">implements</span> <span class="title">EchoService</span>, <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntroductionAdvisorDemo target = <span class="keyword">new</span> IntroductionAdvisorDemo();</span><br><span class="line">        <span class="comment">// 使用该都构造器会使得IntroductionInfo失效</span></span><br><span class="line">        <span class="comment">// ProxyFactory proxyFactory = new ProxyFactory(target);</span></span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        proxyFactory.setTarget(target);</span><br><span class="line">        <span class="comment">// 添加Advisor</span></span><br><span class="line">        proxyFactory.addAdvisor(<span class="keyword">new</span> DefaultIntroductionAdvisor(<span class="keyword">new</span> MethodBeforeAdvice() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;BeforeAdvice: &quot;</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> IntroductionInfo() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt;[] getInterfaces() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;EchoService.class, Map.class&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        Object proxy = proxyFactory.getProxy();</span><br><span class="line">        EchoService echoService = (EchoService) proxy;</span><br><span class="line">        echoService.echo(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map map = (Map)proxy;</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果IntroductionInfo#getInterfaces未传入Comparable,这里会无法转换</span></span><br><span class="line">        Comparable comparable = (Comparable) proxy;</span><br><span class="line">        comparable.compareTo(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(String message)</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;IntroductionAdvisorDemo: &quot;</span> + message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="advisoradapter接口"><a class="markdownIt-Anchor" href="#advisoradapter接口"></a> AdvisorAdapter接口</h2>
<p>AdvisorAdapter的作用是将Advice适配成MethodInterceptor。</p>
<p>接口 - org.springframework.aop.framework.adapter.AdvisorAdapter</p>
<p>MethodBeforeAdvice实现：</p>
<ul>
<li>org.springframework.aop.framework.adapter.MethodBeforeAdviceAdapter</li>
</ul>
<p>AfterReturningAdvice实现：</p>
<ul>
<li>org.springframework.aop.framework.adapter.AfterReturningAdviceAdapter</li>
</ul>
<p>ThrowsAdvice实现：</p>
<ul>
<li>org.springframework.aop.framework.adapter.ThrowsAdviceAdapter</li>
</ul>
<blockquote>
<p>除了使用默认的Advice，我们还可以使用DefaultAdvisorAdapterRegistry#registerAdvisorAdapter方法扩展自定义的Advice，于此同时，还需要实现一个Adapter。</p>
</blockquote>
<h2 id="aopproxy接口"><a class="markdownIt-Anchor" href="#aopproxy接口"></a> AopProxy接口</h2>
<p>AopProxy接口的作用是一个返回配置好的AOP代理对象。</p>
<p>接口 - org.springframework.aop.framework.AopProxy</p>
<p>实现方式：</p>
<ul>
<li>JDK动态代理
<ul>
<li>org.springframework.aop.framework.JdkDynamicAopProxy</li>
</ul>
</li>
<li>CGLIB字节码提升
<ul>
<li>org.springframework.aop.framework.CglibAopProxy
<ul>
<li>org.springframework.aop.framework.ObjenesisCglibAopProxy</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="aopproxyfactory"><a class="markdownIt-Anchor" href="#aopproxyfactory"></a> AopProxyFactory</h2>
<p>AopProxyFactory是AopProxy的工厂实现。</p>
<p>接口 - org.springframework.aop.framework.AopProxyFactory</p>
<p>默认实现：org.springframework.aop.framework.DefaultAopProxyFactory</p>
<blockquote>
<p>除了DefaultAopProxyFactory还可以通过扩展AopProxyFactory增加AOP代理的方式。</p>
</blockquote>
<h2 id="jdk-aopproxy实现"><a class="markdownIt-Anchor" href="#jdk-aopproxy实现"></a> JDK AopProxy实现</h2>
<p>实现 - org.springframework.aop.framework.JdkDynamicAopProxy</p>
<ul>
<li>配置 - org.springframework.aop.framework.AdvisedSupport</li>
<li>来源 - org.springframework.aop.framework.DefaultAopProxyFactory</li>
</ul>
<h2 id="cglib-aopproxy实现"><a class="markdownIt-Anchor" href="#cglib-aopproxy实现"></a> CGLIB AopProxy实现</h2>
<p>实现 - org.springframework.aop.framework.CglibAopProxy</p>
<ul>
<li>配置 - org.springframework.aop.framework.AdvisedSupport</li>
<li>来源 - org.springframework.aop.framework.DefaultAopProxyFactory</li>
</ul>
<blockquote>
<p>无论是JDK的动态代理还是CGLIB都用到了ReflectiveMethodInvocation。</p>
</blockquote>
<h2 id="advisedsupport"><a class="markdownIt-Anchor" href="#advisedsupport"></a> AdvisedSupport</h2>
<p>接口 - org.springframework.aop.framework.AdvisedSupport</p>
<ul>
<li>语义 - 代理配置</li>
<li>基类 - org.springframework.aop.framework.ProxyConfig</li>
<li>实现接口 - org.springframework.aop.framework.Advised</li>
<li>使用场景 - org.springframework.aop.framework.AopProxy实现</li>
</ul>
<blockquote>
<p>AdvisedSupport提供了诸多的能力，比如POJO的配置，添加Advisor等，之前在调用ProxyFactory的时候，实际上很多能力都是由AdvisedSupport来提供的。</p>
</blockquote>
<h2 id="advisorchainfactory接口"><a class="markdownIt-Anchor" href="#advisorchainfactory接口"></a> AdvisorChainFactory接口</h2>
<p>核心API - org.springframework.aop.framework.AdvisorChainFactory</p>
<ul>
<li>默认实现 - org.springframework.aop.framework.DefaultAdvisorChainFactory</li>
<li>特殊实现 - org.springframework.aop.framework.InterceptorAndDynamicMethodMatcher</li>
</ul>
<h2 id="targetsource接口"><a class="markdownIt-Anchor" href="#targetsource接口"></a> TargetSource接口</h2>
<p>核心API - org.springframework.aop.TargetSource</p>
<p>典型实现：</p>
<ul>
<li>org.springframework.aop.target.HotSwappableTargetSource</li>
<li>org.springframework.aop.target.AbstractPoolingTargetSource</li>
<li>org.springframework.aop.target.PrototypeTargetSource</li>
<li>org.springframework.aop.target.ThreadLocalTargetSource</li>
<li>org.springframework.aop.target.SingletonTargetSource</li>
</ul>
<blockquote>
<p>TargetSource实际上与BeanFactory有着密切的关系，在与Spring IoC容器进行整合的时候，目标对象的来源都是来自于BeanFactory。</p>
</blockquote>
<h2 id="proxycreatorsupport"><a class="markdownIt-Anchor" href="#proxycreatorsupport"></a> ProxyCreatorSupport</h2>
<p>这个类用来创建代理对象。</p>
<p>核心API - org.springframework.aop.framework.ProxyCreatorSupport</p>
<ul>
<li>语义 - 代理对象创建基类</li>
<li>基类 - org.springframework.aop.framework.AdvisedSupport</li>
</ul>
<blockquote>
<p>对于ProxyCreatorSupport而言，它更关心AopProxyFactory对象的创建，所以会关联一个AopProxyFactory对象。</p>
</blockquote>
<h2 id="advisedsupportlistener"><a class="markdownIt-Anchor" href="#advisedsupportlistener"></a> AdvisedSupportListener</h2>
<p>核心API - org.springframework.aop.framework.AdvisedSupportListener</p>
<ul>
<li>事件对象 - org.springframework.aop.framework.AdvisedSupport</li>
<li>事件来源 - org.springframework.aop.framework.ProxyCreatorSupport</li>
<li>激活事件触发 - ProxyCreatorSupport#createAopProxy</li>
<li>变更事件触发 - 代理接口变化时、Advisor变化时、配置复制</li>
</ul>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupportListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultEchoService defaultEchoService = <span class="keyword">new</span> DefaultEchoService();</span><br><span class="line">        <span class="comment">// 注入目标对象（被代理）</span></span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(defaultEchoService);</span><br><span class="line">        <span class="comment">// 如果对象存在接口的话，生成的代理对象还是JDK动态代理的</span></span><br><span class="line">        proxyFactory.setTarget(DefaultEchoService.class);</span><br><span class="line">        <span class="comment">// 添加Advice</span></span><br><span class="line">        proxyFactory.addAdvice(<span class="keyword">new</span> EchoServiceMethodInterceptor());</span><br><span class="line">        proxyFactory.addListener(<span class="keyword">new</span> AdvisedSupportListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activated</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;AOP配置对象：&quot;</span> + advised + <span class="string">&quot;已激活&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adviceChanged</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;AOP配置对象：&quot;</span> + advised + <span class="string">&quot;已变化&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        <span class="comment">// 激活事件触发 createAopProxy &lt;- getProxy()</span></span><br><span class="line">        EchoService echoService = (EchoService) proxyFactory.getProxy();</span><br><span class="line">        proxyFactory.addAdvice(<span class="keyword">new</span> Advice() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="proxyfactory"><a class="markdownIt-Anchor" href="#proxyfactory"></a> ProxyFactory</h2>
<p>ProxyFactory是ProxyCreatorSupport的标准实现。</p>
<p>核心API - org.springframework.aop.framework.ProxyFactory</p>
<ul>
<li>基类 - org.springframework.aop.framework.ProxyCreatorSupport</li>
<li>特性增强，提供一些便利操作</li>
</ul>
<blockquote>
<p>ProxyCreatorSupport#createAopProxy方法是一个典型的模板设计模式。</p>
</blockquote>
<p>ProxyFactory与ProxyCreatorSupport有三大特性：配置、产生代理对象、有事件关联。</p>
<h2 id="proxyfactorybean"><a class="markdownIt-Anchor" href="#proxyfactorybean"></a> ProxyFactoryBean</h2>
<p>核心API - org.springframework.aop.framework.ProxyFactoryBean</p>
<ul>
<li>基类 - org.springframework.aop.framework.ProxyCreatorSupport</li>
<li>特点，与Spring IoC容器整合：
<ul>
<li>org.springframework.beans.factory.BeanClassLoaderAware</li>
<li>org.springframework.beans.factory.BeanFactoryAware</li>
</ul>
</li>
<li>特性增强：
<ul>
<li>实现org.springframework.beans.factory.FactoryBean</li>
</ul>
</li>
</ul>
<h2 id="aspectjproxyfactory"><a class="markdownIt-Anchor" href="#aspectjproxyfactory"></a> AspectJProxyFactory</h2>
<p>核心API - org.springframework.aop.aspectj.annotation.AspectJProxyFactory</p>
<ul>
<li>基类 - org.springframework.aop.framework.ProxyCreatorSupport</li>
<li>特点：AspectJ注解整合</li>
<li>相关API：
<ul>
<li>AspectJ元数据 - org.springframework.aop.aspectj.annotation.AspectMetadata</li>
<li>AspectJ Advisor工厂 - org.springframework.aop.aspectj.annotation.AspectJAdvisorFactory</li>
</ul>
</li>
</ul>
<blockquote>
<p>AspectJ是通过反射找到Aspect Class，定位到它相关的注解上面的方法，通过注解上面的方法找到表达式，然后通过表达式筛选出对应的目标方法。</p>
</blockquote>
<h2 id="abstractautoproxycreator"><a class="markdownIt-Anchor" href="#abstractautoproxycreator"></a> AbstractAutoProxyCreator</h2>
<p>前面的API都是通过手动插入的方式创建代理对象，有没有自动创建代理对象的方式呢？</p>
<p>API - org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator</p>
<ul>
<li>基类 - org.springframework.aop.framework.ProxyProcessorSupport</li>
<li>特点：与Spring Bean生命周期整合
<ul>
<li>org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor</li>
</ul>
</li>
</ul>
<h2 id="ioc容器自动代理标准实现"><a class="markdownIt-Anchor" href="#ioc容器自动代理标准实现"></a> IoC容器自动代理标准实现</h2>
<p>基类 - org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator</p>
<ul>
<li>默认实现 - DefaultAdvisorAutoProxyCreator</li>
<li>Bean名称匹配实现 - BeanNameAutoProxyCreator</li>
<li>Infrastructure Bean实现 - InfrastructureAdvisorAutoProxyCreator</li>
</ul>
<blockquote>
<p>InfrastructureAdvisorAutoProxyCreator是跟Bean的Role有关。</p>
</blockquote>
<h2 id="aspectjawareadvisorautoproxycreator"><a class="markdownIt-Anchor" href="#aspectjawareadvisorautoproxycreator"></a> AspectJAwareAdvisorAutoProxyCreator</h2>
<p>AspectJAwareAdvisorAutoProxyCreator是IoC容器自动代理AspectJ的实现。</p>
<p>基类 - org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator</p>
<h2 id="aopinfrastructurebean接口"><a class="markdownIt-Anchor" href="#aopinfrastructurebean接口"></a> AopInfrastructureBean接口</h2>
<p>接口 - org.springframework.aop.framework.AopInfrastructureBean</p>
<ul>
<li>语义 - Spring AOP基础Bean标记接口</li>
<li>实现
<ul>
<li>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator</li>
<li>org.springframework.aop.scope.ScopedProxyFactoryBean</li>
</ul>
</li>
<li>判断逻辑
<ul>
<li>AbstractAutoProxyCreator#isInfrastructureClass</li>
<li>ConfigurationClassUtils#checkConfigurationClassCandidate</li>
</ul>
</li>
</ul>
<blockquote>
<p>AopInfrastructureBean是一个标记接口，如果实现了这个接口，表示这个Bean是Spring 基础建设的类，这个类就不会被自动代理。</p>
</blockquote>
<h2 id="aopcontext"><a class="markdownIt-Anchor" href="#aopcontext"></a> AopContext</h2>
<p>API - org.springframework.aop.framework.AopContext</p>
<ul>
<li>语义 - ThreadLocal的扩展，临时存储AOP对象</li>
</ul>
<blockquote>
<p>如果要使用AopContext，需要提前打开exposeProxy开关。</p>
</blockquote>
<h2 id="aopproxyutils"><a class="markdownIt-Anchor" href="#aopproxyutils"></a> AopProxyUtils</h2>
<p>这个工具类是AOP代理的工具类。</p>
<p>API - org.springframework.aop.framework.AopProxyUtils</p>
<p>代表方法：</p>
<ul>
<li>getSingletonTarget - 从实例中获取单例对象</li>
<li>ultimateTargetClass - 从实例中获取最终目标类</li>
<li>completeProxiedInterfaces - 计算AdvisedSupport配置中所有被代理的接口</li>
<li>proxiedUserInterfaces - 从代理对象中获取代理接口</li>
</ul>
<h2 id="aoputils"><a class="markdownIt-Anchor" href="#aoputils"></a> AopUtils</h2>
<p>API - org.springframework.aop.support.AopUtils</p>
<p>代表方法：</p>
<ul>
<li>isAopProxy - 判断对象是否为代理对象</li>
<li>isJdkDynamicProxy - 判断对象是否为JDK动态代理对象</li>
<li>isCglibProxy - 判断对象是否为CGLIB代理对象</li>
<li>getTargetClass - 从对象中获取目标类型</li>
<li>invokeJoinpointUsingReflection - 使用Java反射调用Joinpoint（目标方法）</li>
</ul>
<h2 id="aspectj-enable模块驱动"><a class="markdownIt-Anchor" href="#aspectj-enable模块驱动"></a> AspectJ Enable模块驱动</h2>
<p>注解 - org.springframework.context.annotation.EnableAspectJAutoProxy</p>
<ul>
<li>属性方法
<ul>
<li>proxyTargetClass - 默认情况下是JDK动态代理，如果为true就会变成CGLIB代理</li>
<li>exposeProxy - 是否将代理对象暴露在AopContext中</li>
</ul>
</li>
<li>设计模式 - @Enable模块驱动
<ul>
<li>org.springframework.context.annotation.AspectJAutoProxyRegistrar</li>
</ul>
</li>
<li>底层实现
<ul>
<li>org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</li>
</ul>
</li>
</ul>
<h2 id="aspectj-xml配置驱动实现"><a class="markdownIt-Anchor" href="#aspectj-xml配置驱动实现"></a> AspectJ XML配置驱动实现</h2>
<p>XML元素 - &lt;aop:aspectj-autoproxy /&gt;</p>
<ul>
<li>属性
<ul>
<li>proxy-target-class - 是否已类型代理</li>
<li>expose-proxy - 是否将代理对象暴露在AopContext中</li>
</ul>
</li>
<li>设计模式 - Extensible XML Authoring</li>
<li>底层实现
<ul>
<li>org.springframework.aop.config.AspectJAutoProxyBeanDefinitionParser</li>
</ul>
</li>
</ul>
<p>XML标签元素的Schema实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;aspectj-autoproxy&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:documentation</span> <span class="attr">source</span>=<span class="string">&quot;java:org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator&quot;</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">Enables the use of the @AspectJ style of Spring AOP.</span><br><span class="line"></span><br><span class="line">See org.springframework.context.annotation.EnableAspectJAutoProxy Javadoc</span><br><span class="line">for information on code-based alternatives to this XML element.</span><br><span class="line">		]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;include&quot;</span> <span class="attr">type</span>=<span class="string">&quot;includeType&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">Indicates that only @AspectJ beans with names matched by the (regex)</span><br><span class="line">pattern will be considered as defining aspects to use for Spring autoproxying.</span><br><span class="line">					]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;proxy-target-class&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:boolean&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">Are class-based (CGLIB) proxies to be created? By default, standard</span><br><span class="line">Java interface-based proxies are created.</span><br><span class="line">				]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:attribute</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;expose-proxy&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:boolean&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">Indicate that the proxy should be exposed by the AOP framework as a</span><br><span class="line">ThreadLocal for retrieval via the AopContext class. Off by default,</span><br><span class="line">i.e. no guarantees that AopContext access will work.</span><br><span class="line">				]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:attribute</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="aopconfig-schema-based实现"><a class="markdownIt-Anchor" href="#aopconfig-schema-based实现"></a> &lt;aop:config /&gt; Schema-based实现</h2>
<p>XML元素 - &lt;aop:config /&gt;</p>
<ul>
<li>属性
<ul>
<li>proxy-target-class - 是否已类型代理</li>
<li>expose-proxy - 是否将代理对象暴露在AopContext中</li>
</ul>
</li>
<li>嵌套元素
<ul>
<li>pointcut</li>
<li>advisor</li>
<li>aspect</li>
</ul>
</li>
<li>底层实现
<ul>
<li>org.springframework.aop.config.ConfigBeanDefinitionParser</li>
</ul>
</li>
</ul>
<p>Schema的定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;config&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">A section (compartmentalization) of AOP-specific configuration (including</span><br><span class="line">aspects, pointcuts, etc).</span><br><span class="line">		]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">type</span>=<span class="string">&quot;pointcutType&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">A named pointcut definition.</span><br><span class="line">					]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;advisor&quot;</span> <span class="attr">type</span>=<span class="string">&quot;advisorType&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">xsd:documentation</span> <span class="attr">source</span>=<span class="string">&quot;java:org.springframework.aop.Advisor&quot;</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">A named advisor definition.</span><br><span class="line">					]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;aspect&quot;</span> <span class="attr">type</span>=<span class="string">&quot;aspectType&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">A named aspect definition.</span><br><span class="line">					]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;proxy-target-class&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:boolean&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">Are class-based (CGLIB) proxies to be created? By default, standard</span><br><span class="line">Java interface-based proxies are created.</span><br><span class="line">				]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:attribute</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;expose-proxy&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:boolean&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">Indicate that the proxy should be exposed by the AOP framework as a</span><br><span class="line">ThreadLocal for retrieval via the AopContext class. Off by default,</span><br><span class="line">i.e. no guarantees that AopContext access will work.</span><br><span class="line">				]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:attribute</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="aopaspect-schema-based实现"><a class="markdownIt-Anchor" href="#aopaspect-schema-based实现"></a> &lt;aop:aspect /&gt; Schema-based实现</h2>
<p>XML元素 - &lt;aop:aspect /&gt;</p>
<ul>
<li>父元素 - &lt;aop:config /&gt;</li>
<li>属性
<ul>
<li>ref - Spring Bean引用的名称</li>
<li>order - Aspect顺序数</li>
</ul>
</li>
<li>嵌套元素
<ul>
<li>pointcut</li>
<li>declare-parents</li>
<li>before</li>
<li>after</li>
<li>after-returning</li>
<li>after-throwing</li>
<li>around</li>
</ul>
</li>
</ul>
<p>schema定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;aspect&quot;</span> <span class="attr">type</span>=<span class="string">&quot;aspectType&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">	A named aspect definition.</span><br><span class="line">			]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="pointcut-schema-based实现"><a class="markdownIt-Anchor" href="#pointcut-schema-based实现"></a> Pointcut Schema-based实现</h2>
<p>XML元素 - &lt;aop:pointcut /&gt;</p>
<ul>
<li>
<p>父元素 - &lt;aop:aspect /&gt;或&lt;aop:config /&gt;</p>
</li>
<li>
<p>属性</p>
<ul>
<li>id - Pointcut ID</li>
<li>expression - （必须）AspectJ表达式</li>
</ul>
</li>
<li>
<p>底层实现</p>
<ul>
<li>org.aspectj.lang.annotation.Pointcut</li>
</ul>
<p>schema定义：</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">&quot;pointcutType&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:appinfo</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tool:annotation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tool:exports</span> <span class="attr">type</span>=<span class="string">&quot;org.springframework.aop.Pointcut&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">tool:annotation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:appinfo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">The unique identifier for a pointcut.</span><br><span class="line">			]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:attribute</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;expression&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">The pointcut expression.</span><br><span class="line"></span><br><span class="line">For example : &#x27;execution(* com.xyz.myapp.service.*.*(..))&#x27;</span><br><span class="line">			]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:attribute</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="around-advice-schema-based实现"><a class="markdownIt-Anchor" href="#around-advice-schema-based实现"></a> Around Advice Schema-based实现</h2>
<p>XML元素 - &lt;aop:around /&gt;</p>
<ul>
<li>父元素- &lt;aop:aspect /&gt;</li>
<li>属性
<ul>
<li>pointcut - AspectJ Pointcut表达式</li>
<li>pointcut-ref - 引用的AspectJ Pointcut名称</li>
<li>method - 拦截目标方法</li>
<li>arg-names - 目标方法参数名称</li>
</ul>
</li>
</ul>
<p>schema定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;around&quot;</span> <span class="attr">type</span>=<span class="string">&quot;basicAdviceType&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span><br><span class="line"> An around advice definition.</span><br><span class="line">     ]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="before-advice-schema-based实现"><a class="markdownIt-Anchor" href="#before-advice-schema-based实现"></a> Before Advice Schema-based实现</h2>
<p>XML元素 - &lt;aop:before /&gt;</p>
<ul>
<li>父元素 - &lt;aop:aspect /&gt;</li>
<li>属性
<ul>
<li>pointcut - AspectJ pointcut表达式</li>
<li>pointcut-ref - 引用的AspectJ Pointcut名称</li>
<li>method - 拦截目标方法</li>
<li>arg-names - 目标方法参数名称</li>
</ul>
</li>
</ul>
<h2 id="after-advice-schema-based实现"><a class="markdownIt-Anchor" href="#after-advice-schema-based实现"></a> After Advice Schema-based实现</h2>
<p>XML元素 - &lt;aop:after /&gt;</p>
<ul>
<li>父元素 - &lt;aop:aspect /&gt;</li>
<li>属性
<ul>
<li>pointcut - AspectJ Pointcut表达式</li>
<li>pointcut-ref - 引用的AspectJ Pointcut名称</li>
<li>method - 拦截目标方法</li>
<li>arg-names - 目标方法参数名称</li>
</ul>
</li>
</ul>
<h2 id="after-returning-advice-schema-based实现"><a class="markdownIt-Anchor" href="#after-returning-advice-schema-based实现"></a> After Returning Advice Schema-based实现</h2>
<p>XML元素 - &lt;aop:after-returning /&gt;</p>
<ul>
<li>父元素 - &lt;aop:aspect /&gt;</li>
<li>属性
<ul>
<li>pointcut - AspectJ Pointcut表达式</li>
<li>pointcut-ref - 引用的AspectJ Pointcut名称</li>
<li>method - 拦截目标方法</li>
<li>arg-names - 目标方法参数名称</li>
<li>returning - 方法参数名称</li>
</ul>
</li>
</ul>
<p>schema定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">&quot;afterReturningAdviceType&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:complexContent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:extension</span> <span class="attr">base</span>=<span class="string">&quot;basicAdviceType&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;returning&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">The name of the method parameter to which the return value must</span><br><span class="line">be passed.</span><br><span class="line">					]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">xsd:attribute</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:extension</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:complexContent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="after-throwing-advice-schema-based实现"><a class="markdownIt-Anchor" href="#after-throwing-advice-schema-based实现"></a> After Throwing Advice Schema-based实现</h2>
<p>XML元素 - &lt;aop:after-throwing /&gt;</p>
<ul>
<li>父元素 - &lt;aop:aspect /&gt;</li>
<li>属性
<ul>
<li>pointcut - AspectJ Pointcut表达式</li>
<li>pointcut-ref - 引用的AspectJ Pointcut名称</li>
<li>method - 拦截目标方法</li>
<li>arg-names - 目标方法参数名称</li>
<li>throwing方法参数名称</li>
</ul>
</li>
</ul>
<p>schema定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">&quot;afterThrowingAdviceType&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xsd:complexContent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">xsd:extension</span> <span class="attr">base</span>=<span class="string">&quot;basicAdviceType&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;throwing&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">The name of the method parameter to which the thrown exception must</span><br><span class="line">be passed.</span><br><span class="line">					]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">xsd:attribute</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">xsd:extension</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">xsd:complexContent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="advisor-schema-based实现"><a class="markdownIt-Anchor" href="#advisor-schema-based实现"></a> Advisor Schema-based实现</h2>
<p>XML元素 - &lt;aop:advisor /&gt;</p>
<ul>
<li>父元素 - &lt;aop:config /&gt;</li>
<li>属性
<ul>
<li>advice-ref - Advice Bean引用</li>
<li>pointcut - AspectJ Pointcut表达式</li>
<li>pointcut-ref - AspectJ Pointcut Bean引用</li>
<li>order - Advisor顺序数</li>
</ul>
</li>
</ul>
<h2 id="introduction-schema-based实现"><a class="markdownIt-Anchor" href="#introduction-schema-based实现"></a> Introduction Schema-based实现</h2>
<p>XML元素 - &lt;aop:declare-parents /&gt;</p>
<ul>
<li>父元素 - &lt;aop:aspect /&gt;</li>
<li>属性
<ul>
<li>types-matching - 是否已类型代理</li>
<li>implement-interface - 实现接口全类名</li>
<li>default-impl - 默认实现全类名</li>
<li>delegate-ref - 委派实现Bean引用</li>
</ul>
</li>
</ul>
<h2 id="作用域代理schema-based实现"><a class="markdownIt-Anchor" href="#作用域代理schema-based实现"></a> 作用域代理Schema-based实现</h2>
<p>XML元素 - &lt;aop:scoped-proxy /&gt;</p>
<ul>
<li>属性
<ul>
<li>proxy-target-class - 是否已类型代理</li>
</ul>
</li>
</ul>
<h2 id="面试题-3"><a class="markdownIt-Anchor" href="#面试题-3"></a> 面试题</h2>
<h3 id="spring-aop-advice-xml标签有哪些"><a class="markdownIt-Anchor" href="#spring-aop-advice-xml标签有哪些"></a> Spring AOP Advice XML标签有哪些？</h3>
<ul>
<li>Around Advice：&lt;aop:around /&gt;</li>
<li>Before：&lt;aop:before /&gt;</li>
<li>After：&lt;aop:after/ &gt;</li>
<li>AfterReturning：&lt;aop:after-returning /&gt;</li>
<li>AfterThrowing：&lt;aop:after-throwing /&gt;</li>
</ul>
<h3 id="请解释spring-enbaleaspectjautoproxy的原理"><a class="markdownIt-Anchor" href="#请解释spring-enbaleaspectjautoproxy的原理"></a> 请解释Spring @EnbaleAspectJAutoProxy的原理？</h3>
<p>通过BeandefinitionRegistrar注册相应的Bean。</p>
<h3 id="spring-configuration-class-cglib提升与aop类代理的关系"><a class="markdownIt-Anchor" href="#spring-configuration-class-cglib提升与aop类代理的关系"></a> Spring Configuration Class CGLIB提升与AOP类代理的关系？</h3>
<p>@Configuration需要@ComponetScan才可以生效。</p>
<p>Spring Configuration Class CGLIB提升的原因是，方便Spring AOP的操作，无需显式的注册代理类，注入Advisor也比较容易，相当于天然的装配。</p>
<h1 id="spring-aop设计模式"><a class="markdownIt-Anchor" href="#spring-aop设计模式"></a> Spring AOP设计模式</h1>
<p>总的来说，设计模式没有绝对的标准，像雨像雾又像风。</p>
<h2 id="抽象工厂模式"><a class="markdownIt-Anchor" href="#抽象工厂模式"></a> 抽象工厂模式</h2>
<p>基本概念：抽象工厂模式（Abstract factory）提供了一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>接口 - org.springframework.aop.framework.AopProxyFactory</li>
<li>实现 - org.springframework.aop.framework.DefaultAopProxyFactory</li>
</ul>
<h2 id="构建器模式"><a class="markdownIt-Anchor" href="#构建器模式"></a> 构建器模式</h2>
<p>基本概念：构建器模式（Builder）又名建造模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>实现 - org.springframework.aop.aspectj.annotation.BeanFactoryAspectJAdvisorsBuilder</li>
</ul>
<blockquote>
<p>通常而言，构建器模式有两种实现，一种是线程安全的，一种是非线程安全的，不过大多数场景下，使用的都是非线程安全的，例如StringBuilder。</p>
</blockquote>
<h2 id="工厂方法模式"><a class="markdownIt-Anchor" href="#工厂方法模式"></a> 工厂方法模式</h2>
<p>基本概念：工厂方法模式（Factory method）就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>实现 - org.springframework.aop.framework.ProxyFactory</li>
</ul>
<blockquote>
<p>工厂方法也分为两种，静态工厂和动态工厂，也就是说类的工厂方法或者对象的工厂方法。抽象工厂与工厂方法的区别在于，抽象工厂要求必须是抽象的，也就是说它必须是抽象类或者接口，但工厂可以是一个具体的类。</p>
</blockquote>
<h2 id="原型模式"><a class="markdownIt-Anchor" href="#原型模式"></a> 原型模式</h2>
<p>基本概念：原型模式（Prototype）其特点在于通过<code>复制</code>一个已经存在的实例来返回新的实例，而不是新建实例。被复制的实例就是我们所称的<code>原型</code>，这个原型是可定制的。</p>
<p>原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>实现 - org.springframework.aop.target.PrototypeTargetSource</li>
</ul>
<h2 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h2>
<p>基本概念：单例模式（Singleton）属于创建型模式的一种。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务器进程中的其他对象再通过这个单例对象或者这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>实现 - org.springframework.aop.target.SingletonTargetSource</li>
</ul>
<blockquote>
<p>单例模式中需要注意对象存在的范围。</p>
</blockquote>
<h2 id="适配器模式"><a class="markdownIt-Anchor" href="#适配器模式"></a> 适配器模式</h2>
<p>基本概念：适配器模式（Adapter）有时候也称包装模式或者包装（Wrapper）。将一个类转换成另外一个类，通过适配器包装的方式可以使得本来不兼容的接口变得兼容。</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>实现 - org.springframework.aop.framework.adapter.AdvisorAdapter</li>
<li>适配对象 - org.aopalliance.aop.Advice</li>
<li>目标对象 - org.aopalliance.intercept.MethodInterceptor</li>
</ul>
<h2 id="组合模式"><a class="markdownIt-Anchor" href="#组合模式"></a> 组合模式</h2>
<p>基本概念：组合模式（Composite）是把一组对象当成一个实例来进行处理，这个实例和这组对象时相同类型的。</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>实现 - org.springframework.aop.support.ComposablePointcut</li>
<li>接口 - org.aspectj.lang.annotation.Pointcut</li>
<li>成员 - org.aspectj.lang.annotation.Pointcut</li>
</ul>
<h2 id="装饰器模式"><a class="markdownIt-Anchor" href="#装饰器模式"></a> 装饰器模式</h2>
<p>基本概念：装饰器模式（Decorator）是一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>实现 - org.springframework.aop.aspectj.annotation.LazySingletonAspectInstanceFactoryDecorator</li>
</ul>
<p>JDK举例实现：</p>
<ul>
<li>实现 - java.io.BufferedInputStream</li>
</ul>
<p>装饰器模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，以对客户端透明的方式动态的给一个对象附加更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。</p>
<p>装饰器模式可以在不创造更多子类的情况下，将对象的功能加以扩展，把客户端的调用委派到被装饰类，装饰器模式的关键在于这种扩展完全是透明的。</p>
<p>装饰器模式是不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>
<p>装饰器的角色：</p>
<ul>
<li>抽象构建角色</li>
<li>具体构建角色</li>
<li>装饰角色</li>
<li>具体装饰角色</li>
</ul>
<h2 id="享元模式"><a class="markdownIt-Anchor" href="#享元模式"></a> 享元模式</h2>
<p>基本概念：享元，即共享的单元。享元模式（Flyweight）使用对象来尽可能减少内存的使用量，便于分享更多的数据。常见的作法是对象放在数据结构外部，等需要的时候在将它们传递给享元。</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>实现 - org.springframework.aop.framework.adapter.AdvisorAdapterRegistry</li>
</ul>
<blockquote>
<p>享元模式与单例模式的区别在于，享元模式不一定是单例本身，它可能只是一个代理或者门面。</p>
</blockquote>
<h2 id="代理模式-2"><a class="markdownIt-Anchor" href="#代理模式-2"></a> 代理模式</h2>
<p>基本概念：代理模式（Proxy）是指一个类型可以作为其他东西的界面。代理者可以作任何东西的介面：网络连接、内存等资源。</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>实现 - org.springframework.aop.framework.AopProxy
<ul>
<li>JDK - org.springframework.aop.framework.JdkDynamicAopProxy</li>
<li>CGLIB - org.springframework.aop.framework.CglibAopProxy</li>
</ul>
</li>
</ul>
<blockquote>
<p>装饰器模式和代理模式的区别在于，通常装饰器模式是静态的一种（比如植入一些辅助性的代码去修饰一些行为），而代理模式既有动态的也有静态的。</p>
</blockquote>
<h2 id="模板方法模式"><a class="markdownIt-Anchor" href="#模板方法模式"></a> 模板方法模式</h2>
<p>基本概念：模板方法（Template Method）是一个定义在父类里面的方法，这个方法可能没有具体的实现，需要在子类中重写父类中这个方法，而父类已经安排好了这些抽象方法的执行顺序以及调用逻辑。</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>模板类 - org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator</li>
<li>模板方法 - getAdvicesAndAdvisorsForBean(Class, String,TargetSource)</li>
<li>子类实现：
<ul>
<li>org.springframework.aop.framework.autoproxy.InfrastructureAdvisorAutoProxyCreator</li>
<li>org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</li>
</ul>
</li>
</ul>
<h2 id="责任链模式"><a class="markdownIt-Anchor" href="#责任链模式"></a> 责任链模式</h2>
<p>基本概念：责任链模式（Chain of Responsibility）包含了一些命令对象和一系列的处理对象。每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个对象。该模式还描述了往该处理链的末尾添加新的处理对象的方法。</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>org.springframework.aop.framework.AdvisorChainFactory</li>
<li>org.springframework.aop.framework.DefaultAdvisorChainFactory</li>
</ul>
<blockquote>
<p>责任链模式有时候有称为Pipline。</p>
</blockquote>
<h2 id="观察者模式"><a class="markdownIt-Anchor" href="#观察者模式"></a> 观察者模式</h2>
<p>基本概念：观察者模式（Observer）是指一个目标对象管理所有依赖它的观察者对象，并且在它本身的状态改变时主动发出通知。通常伴随着事件或者消息的方式来进行传递。</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>观察者 - org.springframework.aop.framework.ProxyCreatorSupport</li>
<li>被观察者 - org.springframework.aop.framework.AdvisedSupportListener</li>
<li>通知对象 - org.springframework.aop.framework.AdvisedSupport</li>
</ul>
<h2 id="策略模式"><a class="markdownIt-Anchor" href="#策略模式"></a> 策略模式</h2>
<p>基本概念：策略模式（Strategy）是指对象具有某个行为，但是在不同的场景中，该行为有不同的实现算法。</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy</li>
<li>org.springframework.aop.config.ConfigBeanDefinitionParser#getAdviceClass</li>
</ul>
<blockquote>
<p>策略模式通常被认为是面向对象多态的体现。</p>
</blockquote>
<h2 id="命令模式"><a class="markdownIt-Anchor" href="#命令模式"></a> 命令模式</h2>
<p>基本概念：命令模式（Strategy）是以对象为代表实际行动，命令对象可以把方法及其参数封装起来，于是这些方法（动作）可以被：</p>
<ul>
<li>重复多次</li>
<li>取消</li>
<li>取消后又再重做</li>
</ul>
<p>Spring AOP举例实现：</p>
<ul>
<li>org.aopalliance.intercept.MethodInvocation</li>
<li>org.aspectj.lang.ProceedingJoinPoint</li>
</ul>
<h2 id="状态模式"><a class="markdownIt-Anchor" href="#状态模式"></a> 状态模式</h2>
<p>基本概念：状态模式（State）允许对象在内部状态发生变化时更改其行为。这种模式接近于有限状态机的概念，状态模式可以解释为策略模式，它能够通过调用模式接口中定义的方法来切换策略。</p>
<p>Spring AOP举例实现：</p>
<ul>
<li>状态对象 - org.springframework.aop.framework.ProxyConfig</li>
<li>影响对象 - org.springframework.aop.framework.AopProxy
<ul>
<li>org.springframework.aop.framework.JdkDynamicAopProxy</li>
<li>org.springframework.aop.framework.CglibAopProxy</li>
</ul>
</li>
</ul>
<blockquote>
<p>状态模式可以和策略模式相互配合。</p>
</blockquote>
<h2 id="面试题-4"><a class="markdownIt-Anchor" href="#面试题-4"></a> 面试题</h2>
<h3 id="gof-23设计模式和它的归类"><a class="markdownIt-Anchor" href="#gof-23设计模式和它的归类"></a> GOF 23设计模式和它的归类？</h3>
<ul>
<li>创建模式：抽象工厂、构建器模式、工厂方法、原型模式、单例模式</li>
<li>结构模式：适配器模式、桥接模式、组合模式、门面模式、轻量级模式、代理模式</li>
<li>行为模式：责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、策略模式、状态模式、模板方法模式、访问模式。</li>
</ul>
<h3 id="举例装饰器模式和代理模式的区别"><a class="markdownIt-Anchor" href="#举例装饰器模式和代理模式的区别"></a> 举例装饰器模式和代理模式的区别？</h3>
<p>代理模式不要求和被代理对象存在层次关系，装饰器模式则需要和被装饰者存在层次关系。装饰器模式通常会扩展一些行为，这些行为并不隶属于被装饰者之间，而代理模式的功能通常时被代理者的子集或者全集，不会超集。</p>
<p>装饰器模式：BufferedInputStream和InputStream；代理模式：Proxy</p>
<h3 id="请举例说明spring-framework中使用设计模式的实现"><a class="markdownIt-Anchor" href="#请举例说明spring-framework中使用设计模式的实现"></a> 请举例说明Spring Framework中使用设计模式的实现？</h3>
<p>ApplicationContext就是一种门面模式的实现…</p>
<h1 id="spring-aop内部应用"><a class="markdownIt-Anchor" href="#spring-aop内部应用"></a> Spring AOP内部应用</h1>
<p>Spring AOP在Spring Framework中的应用的实现都大同小异，大致都分为以下三个步骤：</p>
<ol>
<li>Enable模块驱动</li>
<li>注册Proxy的Configuration Class</li>
<li>实现PointcurAdvisor和MethodInterceptor</li>
</ol>
<h2 id="spring-事件中的应用"><a class="markdownIt-Anchor" href="#spring-事件中的应用"></a> Spring 事件中的应用</h2>
<p>核心API - org.springframework.context.event.EventPublicationInterceptor</p>
<p>特殊描述：当Spring AOP代理Bean中的JoinPoint方法执行后，Spring ApplicationContext将发布一个自定义事件（ApplicationEvent子类）</p>
<p>使用限制：</p>
<ul>
<li>EventPublicationInterceptor关联的ApplicationEvent子类必须存在单参数的构造器，参数类型必须是Object</li>
<li>EventPublicationInterceptor需要被声明为Spring Bean</li>
</ul>
<p>其中第一点是因为：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210723140848.png" alt="image-20210723140848060" /></p>
<p>需要被声明为Spring Bean的原因是：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210723140929.png" alt="image-20210723140929830" /></p>
<p>接下来我们通过实例的方式演示EventPublicationInterceptor这个API的使用，首先定义好事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutedEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutedEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了参照对比，这里使用传统的事务发送方式和AOP拦截的方式两种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticExecutor</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;StaticExecutor Executing...&quot;</span>);</span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> ExecutedEvent(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用AOP方式的执行器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executor</span> </span>&#123; <span class="comment">// ClassFilter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123; <span class="comment">// MethodMatcher：Join Point方法（需要Pointcut来匹配）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Executor Executing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// Configuration Class</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventPublicationInterceptorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        context.register(EventPublicationInterceptorDemo.class, Executor.class, StaticExecutor.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 5.执行目标方法</span></span><br><span class="line">        Executor executor = context.getBean(Executor.class);</span><br><span class="line">        StaticExecutor staticExecutor = context.getBean(StaticExecutor.class);</span><br><span class="line"><span class="comment">//        System.out.println(executor);</span></span><br><span class="line"><span class="comment">//        System.out.println(staticExecutor);</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.将EventPublicationInterceptor声明为Spring Bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventPublicationInterceptor <span class="title">eventPublicationInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventPublicationInterceptor eventPublicationInterceptor = <span class="keyword">new</span> EventPublicationInterceptor();</span><br><span class="line">        <span class="comment">// 关联目标（自定义）事件类型</span></span><br><span class="line">        eventPublicationInterceptor.setApplicationEventClass(ExecutedEvent.class);</span><br><span class="line">        <span class="keyword">return</span> eventPublicationInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.实现 Pointcut(这一步可以没有)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pointcut <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StaticMethodMatcherPointcut() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;execute&quot;</span>.equals(method.getName()) &amp;&amp; Executor.class.equals(targetClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.声明一个Advisor Bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PointcutAdvisor <span class="title">pointcutAdvisor</span><span class="params">(Pointcut pointcut, EventPublicationInterceptor eventPublicationInterceptor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// EventPublicationInterceptor is MethodInterceptor is Advice</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(pointcut, eventPublicationInterceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.处理事件</span></span><br><span class="line">    <span class="meta">@EventListener(ExecutedEvent.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(ExecutedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executed: &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring事务中的应用"><a class="markdownIt-Anchor" href="#spring事务中的应用"></a> Spring事务中的应用</h2>
<h3 id="核心api"><a class="markdownIt-Anchor" href="#核心api"></a> 核心API</h3>
<ul>
<li>Spring事务@Enanle模块驱动 - @EnableTranSactionManagement</li>
<li>Spring事务注解 - @Transactional</li>
<li>Spring事务事件监听器 - @TransactionalEventListener</li>
<li>Spring事务定义 - TransactionDefinition</li>
<li>Spring事务状态 - TransactionStatus</li>
<li>Spring平台事务管理 - PlatformTransactionManager</li>
<li>Spring事务代理配置 - ProxyTransactionManagementConfiguration</li>
<li>Spring事务PointcutAdvisor实现 - BeanFactoryTransactionAttrubuteSourceAdvisor</li>
<li>Spring事务MethodInterceptor实现 - TransactionInterceptor</li>
<li>Spring事务属性源 - TransactionAttributeSource</li>
</ul>
<h3 id="理解transactiondefinition"><a class="markdownIt-Anchor" href="#理解transactiondefinition"></a> 理解TransactionDefinition</h3>
<p>说明：Spring事务定义</p>
<p>核心方法：</p>
<ul>
<li>getIsolationLevel()：获取隔离级别，默认值ISOLATION_DEFAULT常量，参考org.springframework.transaction.annotation.Isolation</li>
<li>getPropagationBehavior()：获取事务传播，默认值：PROPAGATION_REQUIRED常量，参考org.springframework.transaction.annotation.Propagation</li>
<li>getTimeout()：获取事务执行超时事件，默认值：TIMEOUT_DEFAULT常量</li>
<li>isReadOnly：是否为只读事务，默认值：false</li>
</ul>
<h3 id="理解platformtransactionmanager"><a class="markdownIt-Anchor" href="#理解platformtransactionmanager"></a> 理解PlatformTransactionManager</h3>
<p>说明：平台事务管理器</p>
<p>核心方法：</p>
<ul>
<li>getTransaction(TransactionDefinition)：获取事务状态（逻辑事务）</li>
<li>commit(TransactionStatus)：提交事务</li>
<li>rollback(TransactionStatus)：回滚事务</li>
</ul>
<h3 id="理解事务传播"><a class="markdownIt-Anchor" href="#理解事务传播"></a> 理解事务传播</h3>
<p>官网链接：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#tx-propagation">Spring事务传播</a></p>
<h2 id="spring-缓存中的应用"><a class="markdownIt-Anchor" href="#spring-缓存中的应用"></a> Spring 缓存中的应用</h2>
<p>核心API：</p>
<ul>
<li>Spring缓存@Enable模块驱动 - @EnableCaching</li>
<li>缓存操作注解 - @Caching、@Cachable、@CachePut、@CacheEvict</li>
<li>缓存配置注解 - @CacheConfig</li>
<li>缓存注解操作数据源 - AnnotationCacheOperationSource</li>
<li>Spring缓存注解解析器 - SpringCacheAnnotationParser</li>
<li>Spring缓存管理器 - CacheManager</li>
<li>Spring缓存接口 - Cache</li>
<li>Spring缓存代理配置 - ProxyCachingConfiguration</li>
<li>Spring缓存PointcutAdvisor实现 - BeanFactoryCacheOperationSourceAdvisor</li>
<li>Spring缓存MethodInterceptor实现 - CacheInterceptor</li>
</ul>
<h2 id="spring本地调度中的应用"><a class="markdownIt-Anchor" href="#spring本地调度中的应用"></a> Spring本地调度中的应用</h2>
<p>核心API：</p>
<ul>
<li>Spring异步@Enable模块驱动 - @EnableAsync</li>
<li>Spring异步注解 - @Async</li>
<li>Spring异步配置器 - AsyncConfigurer</li>
<li>Spring异步代理配置 - ProxyAsyncConfiguration</li>
<li>Spring异步PointcurAdvisor实现 - AsyncAnnotationAdvisor</li>
<li>Spring异步MethodInterceptor实现 - AnnotationAsyncExecutionInterceptor</li>
</ul>
<h2 id="面试题-5"><a class="markdownIt-Anchor" href="#面试题-5"></a> 面试题</h2>
<h3 id="请举例说明spring-aop在spring-framework特性运用"><a class="markdownIt-Anchor" href="#请举例说明spring-aop在spring-framework特性运用"></a> 请举例说明Spring AOP在Spring Framework特性运用？</h3>
<ul>
<li>Spring 事件（Events）</li>
<li>Spring 事务（Transaction）</li>
<li>Spring 缓存（Caching）</li>
<li>Spring 本地调度（Scheduling）</li>
<li>Spring远程（Remoting）</li>
</ul>
<h3 id="请解释spring事务传播的原理"><a class="markdownIt-Anchor" href="#请解释spring事务传播的原理"></a> 请解释Spring事务传播的原理？</h3>
<p>/这里最主要的是要掌握逻辑事务和物理事务的区别。</p>
<h3 id="请总结spring-aop与ioc功能整合的设计模式"><a class="markdownIt-Anchor" href="#请总结spring-aop与ioc功能整合的设计模式"></a> 请总结Spring AOP与IoC功能整合的设计模式？</h3>
<ul>
<li>实现Advice或MethodInterceptor</li>
<li>实现PointcutAdvisor</li>
<li>实现Spring AOP代理配置类</li>
<li>（可选）实现注解和注解元信息的解析以及处理</li>
<li>（可选）实现XML与其元信息的解析以及处理</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode in Java</title>
    <url>/2021/06/24/leetcode/</url>
    <content><![CDATA[<p>算法是编程世界的核心内容，本文主要记录使用Java 语言实现leetcode题目的过程。相应的源代码可以参考：<a href="https://github.com/jiyongchao-qf/learn-leetcode"> 算法刷题示例 </a>。</p>
<span id="more"></span>
<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>如何精通一个领域？</p>
<ul>
<li>Chunk it up（切碎知识点）</li>
<li>Deliberate practicing（刻意练习）</li>
<li>Feedback（反馈）</li>
</ul>
<p>整个算法与数据结构需要掌握的内容大致有：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210708155818.png" alt="image-20210708155818510"  />
<h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1>
<p>数据结构，是相互之间存在一种或多种特定关系的数据元素的集合。按照视点的不同，我们把数据结构分为逻辑结构和物理结构。其中，逻辑结构又可以分为集合结构、线性结构、树形结构、图形结构等，物理结构可以分为顺序存储结构和链式存储结构。</p>
<p>数据结构优化的核心思路，一是升维 二是用空间换时间。</p>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<p>数组的查询的时间复杂度O(1)，插入/删除元素的时间复杂度O(n)。</p>
<p>初始化数组的方式：</p>
<ul>
<li>
<p>静态初始化：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>简单的静态初始化：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>动态初始化：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>遍历数组的方式：</p>
<ul>
<li>
<p>传统的for循环方式：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ns.length; i++) &#123;</span><br><span class="line">            System.out.println(ns[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用foreach循环：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用Java标准库中的Arrays.toString()：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h2>
<p>链表的查询时间时间复杂度O(n)，插入/删除元素的时间复杂度O(1)</p>
<p>提高链表线性表查找的效率？</p>
<ol>
<li>添加第一级索引</li>
<li>添加第二级索引</li>
<li>添加多级索引，总数为log2n个索引</li>
</ol>
<p>时间复杂度为O(log2n)，空间复杂度为O(n)</p>
<h2 id="跳表"><a class="markdownIt-Anchor" href="#跳表"></a> 跳表</h2>
<p>跳表的问题：索引的维护比较困难</p>
<h2 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h2>
<p>哈希表（Hash table），也叫散列表，是根据关键码值直接访问元素的数据结构，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，即通过某个函数f，使得：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存储位置 = f（关键字）</span><br></pre></td></tr></table></figure>
<p>这样我们可以通过查找关键字而不需要比较就可以获取需要的记录的存储位置，这个映射函数f叫做散列函数或者哈希函数，存放记录的数组叫做哈希表（或散列表），关键字所对应的记录位置称为散列地址。</p>
<p>散列技术即是一种存储方法，也是一种查找方法。散列技术的记录之间不存在什么逻辑关系，它只与关键字有关系，因此最适合求接的问题是查找与给定值相等的记录。</p>
<p>当两个关键字key<sub>1</sub> ≠ key<sub>2</sub>，但是却有f(key<sub>1</sub>) = f(key<sub>2</sub>)，这种现象我们称为冲突，并把key<sub>1</sub>和key<sub>2</sub>称为这个散列函数的同义词。</p>
<p>构造哈希函数的方法主要有：</p>
<ul>
<li>直接定址法：f(key) = a*key + b(a、b均为常数)</li>
<li>数字分析法</li>
<li>平法取中法</li>
<li>折叠法</li>
<li>除留余数法 ：f(key) = key mod p (p &lt;= m)</li>
<li>随机数法</li>
</ul>
<p>处理散列冲突的方法：</p>
<ul>
<li>开放地址法</li>
<li>再散列函数法</li>
<li>链地址法</li>
<li>公共区溢出法</li>
</ul>
<h2 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h2>
<p>stack：先入后出；添加，删除皆为O(1)，有时候也称为FILO</p>
<blockquote>
<ul>
<li>如果问题具有最近相关性，就可以使用栈来解决。</li>
<li>如果要用栈来实现队列，可以用两个栈。</li>
</ul>
</blockquote>
<h2 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h2>
<p>queue：先入先出；添加、删除皆为O(1)，有时候也成为FIFO</p>
<blockquote>
<ul>
<li>如果问题具有公平性，就可以使用队列来解决。</li>
<li>如果要用队列来实现栈，可以用两个队列</li>
</ul>
</blockquote>
<h2 id="双端队列"><a class="markdownIt-Anchor" href="#双端队列"></a> 双端队列</h2>
<p>双端队列（Dequeue） Double-End Queue</p>
<h2 id="树"><a class="markdownIt-Anchor" href="#树"></a> 树</h2>
<h3 id="总体介绍"><a class="markdownIt-Anchor" href="#总体介绍"></a> 总体介绍</h3>
<p>现实生活中，除了前面的一对一的线性结构，还有很多一对多的数据结构——“树”。</p>
<p>树的表示方法有：</p>
<ul>
<li>双亲表示法</li>
<li>孩子表示法</li>
<li>孩子兄弟表示法</li>
</ul>
<p>对于计算机来说，它只有循环、判断、递归等方式，也就是说，它只能处理线性序列，树的遍历实际上就是将树中的结点编程某种意义上的线性序列，方便计算机处理。</p>
<p>在实际工程中，经常采用递归来解决树相关的问题的原因是：</p>
<ul>
<li>
<p>节点的定义</p>
</li>
<li>
<p>可重复性（自相似性）</p>
</li>
</ul>
<h3 id="代码模板"><a class="markdownIt-Anchor" href="#代码模板"></a> 代码模板</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h2>
<p>二叉树的遍历方法有以下几种：</p>
<ul>
<li>前序（Pre-order）：根-左-右</li>
<li>中序（In-order）：左-根-右</li>
<li>后序（Post-order）：左-右-根</li>
<li>层次遍历</li>
</ul>
<p>二叉树遍历遍历的性质：</p>
<ul>
<li>已知前序遍历序列和中序遍历序列，可以唯一确定一颗二叉树</li>
<li>已知中序遍历序列和后序遍历序列，可以唯一确定一颗二叉树</li>
</ul>
<blockquote>
<p>已知前序和后序遍历，无法确定唯一一颗二叉树。</p>
</blockquote>
<p>如果二叉树退化成了链表（即元素都在左子树上或者都在右子树上），那么时间复杂度会变成O（n）</p>
<h2 id="二叉搜索树"><a class="markdownIt-Anchor" href="#二叉搜索树"></a> 二叉搜索树</h2>
<p>二叉搜索树，也称二叉搜索树、有序二叉树（Ordered Binary Tree）、二叉排序树（Sorted Binary Tree），是一棵空树或者具有下列性质的二叉树：</p>
<ul>
<li>左子树上的<code>所有结点</code>的值均小于它的根节点的值</li>
<li>右子树上<code>所有结点</code>的值均大于它的根结点的值</li>
<li>依次类推：左、右子树也分别为二叉查找树（这就是重复性）</li>
</ul>
<p>二叉搜索树的性质：</p>
<ul>
<li>中序遍历是递增序列</li>
</ul>
<p>二叉搜索树的插入和查询时间复杂度都是O(logn)。</p>
<h2 id="平衡二叉树"><a class="markdownIt-Anchor" href="#平衡二叉树"></a> 平衡二叉树</h2>
<p>平衡二叉树是一种二叉排序树，每一个结点的左子树和右子树的高度差至多等于1，平衡二叉树有时候也称为AVL树。</p>
<p>平衡二叉树的性质：</p>
<ul>
<li>我们将二叉树的左子树深度减去右子树深度的值称为平衡因子（BF），那么平衡二叉树的所有结点的平衡因子只可能是-1，0，1。</li>
<li>平衡二叉树的查找、插入和删除的时间复杂度均为O（logn）</li>
</ul>
<h2 id="红黑树"><a class="markdownIt-Anchor" href="#红黑树"></a> 红黑树</h2>
<p>主要参考：<a href="https://www.jianshu.com/p/e136ec79235c">30张图带你彻底理解红黑树</a></p>
<h3 id="定义和性质"><a class="markdownIt-Anchor" href="#定义和性质"></a> 定义和性质</h3>
<p>红黑树是二叉查找树，具体来说，是一种含有红黑结点并能自平衡的二叉查找树，它必须满足下面的性质：</p>
<ul>
<li>性质1：每个结点要么是黑色，要么是红色</li>
<li>性质2：根节点是黑色</li>
<li>性质3：每个叶子结点（NIL）是黑色</li>
<li>性质4：每个红色结点的两个子节点一定都是黑色</li>
<li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑节点</li>
</ul>
<p>从性质5又可以推出：</p>
<ul>
<li>性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li>
</ul>
<p>一颗简单的红黑树如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210829231754.png" alt="一颗简单的红黑树" style="zoom:50%;" />
<p>红黑树并不是一个完美平衡二叉查找树，从图1可以看到，根节点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到每个叶子结点的路径都包含数量相同的黑结点（性质5）。所以我们叫红黑树这种平衡为黑色完美平衡。</p>
<p>在红黑树中最主要的有三种操作：左旋、右旋和变色。</p>
<ul>
<li>左旋：以某个结点作为支点（旋转结点），其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变</li>
<li>右旋：以某个结点作为支点（旋转结点），其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变</li>
<li>变色：结点的颜色由红变黑或由黑变红</li>
</ul>
<p>左旋的示意图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210829233108.png" alt="左旋" style="zoom: 67%;" />
<p>右旋的示意图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210829233211.png" alt="右旋" style="zoom:67%;" />
<p>如果我们暂时忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。</p>
<ul>
<li>左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪了</li>
<li>右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪了</li>
</ul>
<h3 id="红黑树的查找"><a class="markdownIt-Anchor" href="#红黑树的查找"></a> 红黑树的查找</h3>
<p>整体的示意图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210829233651.png" alt="红黑树的查找" style="zoom:50%;" />
<p>因为红黑树也是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p>
<ul>
<li>从根节点开始查找，把根节点设置为当前结点</li>
<li>若当前结点为空，返回null</li>
<li>若当前结点不为空，用当前结点的key跟查找key作比较</li>
<li>若当前结点等于查找key，那么该key就是查找目标，返回当前结点</li>
<li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2</li>
<li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2</li>
</ul>
<h3 id="红黑树的插入"><a class="markdownIt-Anchor" href="#红黑树的插入"></a> 红黑树的插入</h3>
<p>整体的示意图如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210829233941.png" alt="红黑树的插入" style="zoom: 67%;" />
<p>插入操作包括两部分工作：一个是查找插入的位置，而是插入后自平衡。查找插入的父结点很简单，跟查找操作的区别不大：</p>
<ul>
<li>从根结点开始查找</li>
<li>若根结点为空，那么插入结点作为根节点，结束</li>
<li>若根结点不为空，那么把根结点作为当前结点</li>
<li>若当前结点为null，返回当前结点的父结点，结束</li>
<li>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束</li>
<li>若当前结点key大于查找key，那么当前结点的左子结点设置为当前结点，重复步骤4</li>
<li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4</li>
</ul>
<p>当插入的位置确定之后就是要确定插入结点的颜色，插入的结点都是红色，原因在于，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。</p>
<p>所有可能的插入的情景：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210830094135.png" alt="红黑树插入情景"/>
<h2 id="多路查找树"><a class="markdownIt-Anchor" href="#多路查找树"></a> 多路查找树</h2>
<p>多路查找树的每一个结点的孩子树可以多于两个，且每一个结点处可以存储多个元素，由于它是查找树，所有元素之间存在某种特定的排序关系。</p>
<h3 id="2-3树"><a class="markdownIt-Anchor" href="#2-3树"></a> 2-3树</h3>
<p>2-3树是这样一颗多路查找树：其中每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点）。</p>
<ul>
<li>一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个2结点要么没有孩子，要么就有两个，不能只有一个孩子</li>
<li>一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素</li>
</ul>
<p>并且2-3树种所有的叶子都在同一层次上。</p>
<h3 id="2-3-4树"><a class="markdownIt-Anchor" href="#2-3-4树"></a> 2-3-4树</h3>
<p>2-3-4树实对2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含于最小元素的元素，第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最低元素的元素；右子树包含大于最大元素的元素。</p>
<h3 id="b树"><a class="markdownIt-Anchor" href="#b树"></a> B树</h3>
<p>B树是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特里。结点最大的孩子数目称为B树的阶。因此，2-3树是3阶的B树，2-3-4树是4阶B树。</p>
<h3 id="b树-2"><a class="markdownIt-Anchor" href="#b树-2"></a> B+树</h3>
<p>B+树应文件系统所需而出的一种B树的变形树，注意严格意义上讲，它其实已经不是之前所定义的树了。在B树种，每一个元素在该树只出现一次，有可能在叶子结点上，也可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当做它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向叶子结点的指针。</p>
<h2 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h2>
<p>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆，如下图所示：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210707172409.png" alt="image-20210707172409423" /></p>
<p>这里由定义可知，根节点一定是堆中所有结点最大（小）者。</p>
<h2 id="优先队列"><a class="markdownIt-Anchor" href="#优先队列"></a> 优先队列</h2>
<h3 id="总体介绍-2"><a class="markdownIt-Anchor" href="#总体介绍-2"></a> 总体介绍</h3>
<p>优先队列(Priority Queue)的作用是能保证每次取出的元素都是队列中权值最小的（Java的优先队列每次取得是最小元素）。元素的大小默认是通过元素本身的自然顺序，也可以通过构造时传入比较器。</p>
<p>Java中的PriorityQueue实现了Queue接口，不允许放入null元素，其通过堆实现，具体是通过完全二叉树实现的小顶堆，这也意味着可以通过数组来作为PriorityQueue的底层实现。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210707223529.png" alt="PriorityQueue_base.png" style="zoom: 50%;" />
<p>优先队列的插入操作时间复杂度是：O(1)，取出操作：O(logN) ，底层具体实现的数据结构较为多样和复杂：heap、bst、treap…。</p>
<h3 id="方法剖析"><a class="markdownIt-Anchor" href="#方法剖析"></a> 方法剖析</h3>
<p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向队列中插入元素，二者的区别在于插入失败情况的处理，前者插入失败是抛出异常，后者则返回false。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210707224316.png" alt="PriorityQueue_offer.png" style="zoom:50%;" />
<p><code>element()</code>和<code>peek()</code>语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者的区别在于获取失败的情况的处理，前者会抛出异常，后者会返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个，如果用数组来存储堆，根据下标关系，<code>0</code>下标处的那个元素即是堆顶元素，因此，直接返回数组<code>0</code>下标处的那个元素即可。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210707225025.png" alt="PriorityQueue_peek.png" style="zoom:50%;" />
<p><code>romve()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，二者的区别在于删除失败的情况的处理，前者会抛出异常，后者会返回null。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210707225501.png" alt="PriorityQueue_poll.png" style="zoom: 50%;" />
<h2 id="图"><a class="markdownIt-Anchor" href="#图"></a> 图</h2>
<h2 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h2>
<h2 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h2>
<p>并查集（Disjoint-set）</p>
<p>适用的场景：</p>
<p>组团、配对问题</p>
<p>Group or not？</p>
<p>并查集的操作</p>
<p>1、makeSet（s）：建立一个新的并查集，其中包含s个单元素集合。</p>
<p>2、unionSet（x，y）：把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并。</p>
<p>3、find（x）：找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将他们各自的代表比较一下就可以了。</p>
<h1 id="常用算法"><a class="markdownIt-Anchor" href="#常用算法"></a> 常用算法</h1>
<p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p>
<p>算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。</p>
<p>算法设计的要求：正确性、可读性、健壮性、时间效率高和低存储。</p>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3>
<p>递归从某种意义上来说和循环是等价的。</p>
<h3 id="代码模板-2"><a class="markdownIt-Anchor" href="#代码模板-2"></a> 代码模板</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> level, param1, param2,...)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 递归的终止条件</span></span><br><span class="line">      <span class="keyword">if</span> (level &gt; MAX_LEVEL) &#123;</span><br><span class="line">          process_result;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理当前层逻辑</span></span><br><span class="line">      process(level, data...);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 下探到下一层</span></span><br><span class="line">      recursion(level + <span class="number">1</span>, newParam);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 如果有必要的话清理当前层不需要的全局变量或者其他东西</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="分治"><a class="markdownIt-Anchor" href="#分治"></a> 分治</h2>
<h3 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h3>
<p>分治指的是将一个大问题分解为若干个小问题，分治从某种意义上和递归也是等价的。</p>
<h3 id="代码模板-3"><a class="markdownIt-Anchor" href="#代码模板-3"></a> 代码模板</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">divideConquer</span><span class="params">(problem, param1, param2,...)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 递归的终止条件</span></span><br><span class="line">       <span class="keyword">if</span> (problem != None) &#123;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 准备数据</span></span><br><span class="line">       data = prepareData(problem);</span><br><span class="line">       <span class="comment">// 分割子问题</span></span><br><span class="line">       subProblem = splitProblem(problem, data);</span><br><span class="line">       <span class="comment">// 处理子问题</span></span><br><span class="line">       subResult1 = divideConquer(subProblem[<span class="number">0</span>], param1, param2,...);</span><br><span class="line">       subResult2 = divideConquer(subProblem[<span class="number">0</span>], param1, param2,...);</span><br><span class="line">       subResult3 = divideConquer(subProblem[<span class="number">0</span>], param1, param2,...);</span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">// 合并结果</span></span><br><span class="line">       processResult(subResult1, subResult2, subResult3,...);</span><br><span class="line">       <span class="comment">// 清理当前状态集</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h2>
<h3 id="定义-3"><a class="markdownIt-Anchor" href="#定义-3"></a> 定义</h3>
<p>回溯法采用试错的思想，它尝试分步的去解决一个问题。在分布解决问题的过程中，当它通过尝试发现现有的分布答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能分布解答再次尝试寻找问题的答案。</p>
<p>回溯法通常用最简的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ul>
<li>找到一个可能存在的正确的答案；</li>
<li>在尝试了所有可能的分布方法后宣告该问题没有答案。</li>
</ul>
<p>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。回溯法的典型应用：八皇后问题和数独。</p>
<h3 id="代码模板-4"><a class="markdownIt-Anchor" href="#代码模板-4"></a> 代码模板</h3>
<h2 id="贪心算法"><a class="markdownIt-Anchor" href="#贪心算法"></a> 贪心算法</h2>
<h3 id="定义-4"><a class="markdownIt-Anchor" href="#定义-4"></a> 定义</h3>
<p>贪心算法是一种在每一步选择中都采取在当前状态下最好或最有（即最有利的选择），从而希望导致结果是全局最好或最优的算法。</p>
<p>贪心算法与动态规划的不同在于它对于每个子问题的解决方案都做出选择，不能回退，动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p>
<blockquote>
<p>贪心算法：当下做局部最优判断</p>
<p>回溯：能够回退</p>
<p>动态规划：最优判断 + 回退</p>
</blockquote>
<p>贪心法可以解决一些最优化问题，如：求图中的最小生成树、哈夫曼编码等。然而对于工程和生活中的问题，贪心法一般不能得到我们所求的答案。</p>
<p>一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个的最好办法。由于贪心法的高效性以及其所求得得答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确得问题。</p>
<blockquote>
<p>贪心算法可以从前往后，也可以从后往前，也可以从局部切入进行贪心。</p>
</blockquote>
<h2 id="深度优先搜索"><a class="markdownIt-Anchor" href="#深度优先搜索"></a> 深度优先搜索</h2>
<h3 id="定义-5"><a class="markdownIt-Anchor" href="#定义-5"></a> 定义</h3>
<p>对于树这种数据结构而言，深度优先具体指的就是，前、中、后序遍历。</p>
<h3 id="代码模板-5"><a class="markdownIt-Anchor" href="#代码模板-5"></a> 代码模板</h3>
<h2 id="广度优先搜索"><a class="markdownIt-Anchor" href="#广度优先搜索"></a> 广度优先搜索</h2>
<h3 id="定义-6"><a class="markdownIt-Anchor" href="#定义-6"></a> 定义</h3>
<h3 id="代码模板-6"><a class="markdownIt-Anchor" href="#代码模板-6"></a> 代码模板</h3>
<h2 id="字典树"><a class="markdownIt-Anchor" href="#字典树"></a> 字典树</h2>
<h3 id="定义-7"><a class="markdownIt-Anchor" href="#定义-7"></a> 定义</h3>
<p>字典树，即Trie树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不限于字符串），所以经常被搜索引擎系统用于文本词频统计。</p>
<p>它的优点是：最大限度地减少无谓地字符串比较，查询效率比哈希表高。</p>
<p>注意：字典树不是二叉树，可以有多个子节点。</p>
<p>基本性质：</p>
<p>1、结点本身不存完整单词；</p>
<p>2、从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串；</p>
<p>3、每个结点的所有子节点路径代表的字符都不相同</p>
<h3 id="代码模板-7"><a class="markdownIt-Anchor" href="#代码模板-7"></a> 代码模板</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> structure;</span><br><span class="line"><span class="keyword">import</span> util.LogUtil;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字典树实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        TrieNode preNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isEnd = <span class="keyword">false</span>; <span class="comment">// 是否是红点，也就是是否是word的解为</span></span><br><span class="line">        <span class="keyword">int</span> deep = <span class="number">0</span>; <span class="comment">// 做hash使用，防止一个单词里面有多个char的时候hash是一样的，可能导致删除出错</span></span><br><span class="line">        <span class="keyword">char</span> content = <span class="number">0</span>; <span class="comment">// 当前结点到parent节点存储的字母</span></span><br><span class="line">        LinkedList&lt;TrieNode&gt; child = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 子节点，当前节点后续节点</span></span><br><span class="line"></span><br><span class="line">        TrieNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TrieNode(<span class="keyword">char</span> content) &#123;</span><br><span class="line">            <span class="keyword">this</span>.content = content;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;End=&quot;</span> + isEnd +</span><br><span class="line">                    <span class="string">&quot;, d=&quot;</span> + deep +</span><br><span class="line">                    <span class="string">&quot;, c=&quot;</span> + content +</span><br><span class="line">                    <span class="string">&quot;, c=&quot;</span> + child +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> content + deep;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> obj <span class="keyword">instanceof</span> TrieNode &amp;&amp; (((TrieNode) obj).content == content);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setPreNode</span><span class="params">(TrieNode node)</span> </span>&#123;</span><br><span class="line">            preNode = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">TrieNode <span class="title">getPreNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> preNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * child中删掉某个Node</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> node 需要删掉的node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(TrieNode node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TrieNode aChild : child) &#123;</span><br><span class="line">                <span class="keyword">if</span> (aChild.content == node.content) &#123;</span><br><span class="line">                    child.remove(aChild);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * child中是否有此Node</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> character 保存的char</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 存在返回不存在返回Null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">TrieNode <span class="title">getNode</span><span class="params">(Character character)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TrieNode aChild : child) &#123;</span><br><span class="line">                <span class="keyword">if</span> (aChild.content == character) &#123;</span><br><span class="line">                    <span class="keyword">return</span> aChild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个word</span></span><br><span class="line"><span class="comment">     * apple</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word 需要添加的词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> deep = <span class="number">0</span>;</span><br><span class="line">        TrieNode currNode = root;</span><br><span class="line">        <span class="keyword">while</span> (deep &lt; word.length()) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 判断当前node的child，如果为空直接添加，不为空，查找是否含有，不含有则添加并设为currNode，含有则找到并设置为currNode</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(deep);</span><br><span class="line">            <span class="keyword">if</span> (currNode.child.contains(<span class="keyword">new</span> TrieNode(c))) &#123;</span><br><span class="line">                currNode = currNode.getNode(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TrieNode node = <span class="keyword">new</span> TrieNode(c);</span><br><span class="line">                node.setPreNode(currNode);</span><br><span class="line">                node.deep = deep + <span class="number">1</span>;</span><br><span class="line">                currNode.child.add(node);</span><br><span class="line">                currNode = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (deep == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                currNode.isEnd = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            deep++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * word在map中是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word 需要查找的word</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> deep = <span class="number">0</span>;</span><br><span class="line">        TrieNode currNode = root;</span><br><span class="line">        <span class="keyword">while</span> (deep &lt; word.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(deep);</span><br><span class="line">            <span class="keyword">if</span> (currNode.child.contains(<span class="keyword">new</span> TrieNode(c))) &#123;</span><br><span class="line">                currNode = currNode.getNode(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (deep == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> currNode.isEnd;</span><br><span class="line">            &#125;</span><br><span class="line">            deep++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除word，几种情况：</span></span><br><span class="line"><span class="comment">     * 1、word在list中不存在，直接返回失败</span></span><br><span class="line"><span class="comment">     * 2、word最后一个char 没有child，则删掉此节点并朝 root 查找没有child &amp;&amp; isEnd=false 的节点都删掉</span></span><br><span class="line"><span class="comment">     * 3、word最后一个char 有child，则把isEnd置为false</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word 需要移除的word</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.trim().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasWord(word)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> deep = <span class="number">0</span>;</span><br><span class="line">        TrieNode currNode = root;</span><br><span class="line">        <span class="keyword">while</span> (deep &lt; word.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(deep);</span><br><span class="line">            <span class="keyword">if</span> (currNode.child.contains(<span class="keyword">new</span> TrieNode(c))) &#123;</span><br><span class="line">                currNode = currNode.getNode(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (deep == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currNode.child.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//3、word最后一个char 有child，则把isEnd置为false</span></span><br><span class="line">                    currNode.isEnd = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//2、word最后一个char 没有child，则删掉此节点并朝 root 查找没有child &amp;&amp; isEnd=false 的节点都删掉</span></span><br><span class="line">                    TrieNode parent = currNode.getPreNode();</span><br><span class="line">                    <span class="keyword">while</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (parent.child.size() == <span class="number">0</span> &amp;&amp; !parent.isEnd) &#123;</span><br><span class="line">                            parent.removeChild(currNode);</span><br><span class="line">                            currNode = parent;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            deep++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历所有节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverseTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        visitNode(root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visitNode</span><span class="params">(TrieNode node, String result)</span> </span>&#123;</span><br><span class="line">        LogUtil.Companion.d(<span class="string">&quot;node.content-&gt;&quot;</span> + node.content);</span><br><span class="line">        String re = result + node.content;</span><br><span class="line">        <span class="keyword">for</span> (TrieNode n : node.child) &#123;</span><br><span class="line">            visitNode(n, re);</span><br><span class="line">            LogUtil.Companion.d(<span class="string">&quot;result-&gt;&quot;</span> + re);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找"></a> 二分查找</h2>
<h3 id="定义-8"><a class="markdownIt-Anchor" href="#定义-8"></a> 定义</h3>
<p>二分查找又称折半查找，二分查找的核心思想是，在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功，若给定值小于中间记录的关键字，则在中间记录的左搬去继续查找；若给定值大于中间记录的关键字，则在中间记录的右搬去继续查找，不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。</p>
<p>要使用二分查找的前题是：</p>
<ul>
<li>目标函数单调（单调递增或者单调递减）</li>
<li>能够通过索引访问（即顺序存储）</li>
<li>存在上下界</li>
</ul>
<p>二分查找的时间复杂度为O（logn）</p>
<h3 id="代码模板-8"><a class="markdownIt-Anchor" href="#代码模板-8"></a> 代码模板</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="布隆过滤器"><a class="markdownIt-Anchor" href="#布隆过滤器"></a> 布隆过滤器</h2>
<h3 id="定义-9"><a class="markdownIt-Anchor" href="#定义-9"></a> 定义</h3>
<p>布隆过滤器由一个很长的二进制向量和一系列随机映射函数构成，可以用于检索一个元素是否在一个集合中。</p>
<p>布隆过滤器本质上是由长度为m的位向量或位列表（仅包含0或1位值的列表）组成，最初初始值均为0，如下图所示。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210705232804.webp" alt="img" style="zoom:67%;" />
<p>使用多个哈希函数产生多个哈希值：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210705232745.webp" alt="img" style="zoom:67%;" />
<p>如上图所示，当输入&quot;semlinker&quot;时，预设的3个哈希函数将输出2、4、6，假设另一个输入&quot;kakuqo&quot;，哈希函数输出3、4和7。4这个位置已经被&quot;semlinker&quot;标记了，在布隆过滤器中是可以共用这个标记位的，此时，当前位向量的标记状态为：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210706001503.webp" alt="img" style="zoom:67%;" />
<p>此时，假设我们要判断&quot;fullstack&quot;是否在集合中，对其使用散列函数，获取哈希函数输出的 3 个索引值分别是 2、3 和 7：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210706001722.webp" alt="img" style="zoom:67%;" />
<p>可以看到，虽然&quot;fullstack&quot;不在集合中，但是计算出的索引值均为1，说明它在集合中，这就产生了误报，产生的原因是由于哈希碰撞导致的巧合而将不同的元素存储在相同的比特位上。相应的，布隆过滤器有一个可预测的误判率。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210706001934.webp" alt="img" /></p>
<p>布隆过滤器的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误别率和删除困难。</p>
<p>总而言之，当布隆过滤器把元素都插入结束之后，对于测试元素（新元素）。当它验证是否存在的时候，如果验证位是1，那么有可能在，如果是0，那么一定不存在。</p>
<h3 id="代码模板-9"><a class="markdownIt-Anchor" href="#代码模板-9"></a> 代码模板</h3>
<h2 id="lru-cache"><a class="markdownIt-Anchor" href="#lru-cache"></a> LRU Cache</h2>
<h3 id="定义-10"><a class="markdownIt-Anchor" href="#定义-10"></a> 定义</h3>
<p>LRU Cache缓存</p>
<p>1、记忆</p>
<p>2、钱包 - 储物柜</p>
<p>3、代码模块</p>
<p>两个要素：大小、替换策略</p>
<p>Hash Table + Double LinkedList</p>
<p>O(1)查询</p>
<p>O(1)修改、更新</p>
<p>LRU（最近至少使用）</p>
<h3 id="代码模板-10"><a class="markdownIt-Anchor" href="#代码模板-10"></a> 代码模板</h3>
<h2 id="位运算"><a class="markdownIt-Anchor" href="#位运算"></a> 位运算</h2>
<h3 id="定义-11"><a class="markdownIt-Anchor" href="#定义-11"></a> 定义</h3>
<table>
<thead>
<tr>
<th style="text-align:center">含义</th>
<th style="text-align:center">运算符</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">左移</td>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">0011 -&gt; 0110</td>
</tr>
<tr>
<td style="text-align:center">右移</td>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:center">0110 -&gt; 0011</td>
</tr>
<tr>
<td style="text-align:center">按位或</td>
<td style="text-align:center">|</td>
<td style="text-align:center">0011 | 1011 -&gt; 1011</td>
</tr>
<tr>
<td style="text-align:center">按位与</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">0011 &amp; 1011 -&gt; 0011</td>
</tr>
<tr>
<td style="text-align:center">按位取反</td>
<td style="text-align:center">~</td>
<td style="text-align:center">~0011 -&gt; 1100</td>
</tr>
<tr>
<td style="text-align:center">按位异或（相同为零不同为一）</td>
<td style="text-align:center">^</td>
<td style="text-align:center">0011 ^ 1011 -&gt; 1000</td>
</tr>
</tbody>
</table>
<h3 id="性质"><a class="markdownIt-Anchor" href="#性质"></a> 性质</h3>
<ul>
<li>x^0 = x</li>
<li>x^1s = ~x   // 注意1s = ~0</li>
<li>x^(~x) = 1s</li>
<li>x^x = 0</li>
<li>c = a^b =&gt; a^c = b, b^c = a // 交换两个数</li>
<li>a<sup>b</sup>c = (a<sup>b)</sup>c = a<sup>(b</sup>c)</li>
</ul>
<h3 id="实战技巧"><a class="markdownIt-Anchor" href="#实战技巧"></a> 实战技巧</h3>
<ul>
<li>
<p>判断奇偶：</p>
<p>x%2 == 1 -&gt; (x&amp;1) == 1</p>
<p>x%2 == 0 -&gt; (x&amp;1) == 0</p>
</li>
<li>
<p>x &gt;&gt; 1 -&gt; x/2</p>
<p>即x = x/2; -&gt; x = x&gt;&gt;1; mid = (left + right)/2; -&gt; mid = (left + right) &gt;&gt; 1;</p>
</li>
<li>
<p>x = x&amp;(x-1) 清零最低位的1</p>
</li>
<li>
<p>x&amp;-x =&gt; 得到最低位的1</p>
</li>
<li>
<p>x&amp;-x =&gt; 0</p>
</li>
</ul>
<h2 id="排序算法"><a class="markdownIt-Anchor" href="#排序算法"></a> 排序算法</h2>
<p>排序算法主要分为两类：</p>
<ul>
<li>比较类排序（数值类型）：通过比较决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，依次也称为非线性时间比较类排序</li>
<li>非比较类排序（对象类型）：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序</li>
</ul>
<h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h3>
<p>嵌套循环，每次查看相邻的元素如果逆序，则交换。</p>
<h3 id="简单选择排序"><a class="markdownIt-Anchor" href="#简单选择排序"></a> 简单选择排序</h3>
<p>每次找最小值，然后放到待排序数组的起始位置。</p>
<h3 id="直接插入排序"><a class="markdownIt-Anchor" href="#直接插入排序"></a> 直接插入排序</h3>
<p>从前到后逐步构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h3 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h3>
<h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h3>
<h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h3>
<h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<h3 id="定义-12"><a class="markdownIt-Anchor" href="#定义-12"></a> 定义</h3>
<p>动态规划（Dynamic Programming）也可以认为是动态递归。</p>
<p>关键点：</p>
<ul>
<li>最优子结构：opt[n] = best_of(opt[n -1], opt[n - 2], …)</li>
<li>存储中间状态：opt[i]</li>
<li>递推公式（状态转移方程或者DP方程）</li>
</ul>
<h3 id="代码模板-11"><a class="markdownIt-Anchor" href="#代码模板-11"></a> 代码模板</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>
<h3 id="股票问题"><a class="markdownIt-Anchor" href="#股票问题"></a> 股票问题</h3>
<p><a href="https://www.cnblogs.com/hanyuhuang/p/11083384.html">https://www.cnblogs.com/hanyuhuang/p/11083384.html</a></p>
<h1 id="高频考题简单"><a class="markdownIt-Anchor" href="#高频考题简单"></a> 高频考题（简单）</h1>
<h2 id="1-两数之和"><a class="markdownIt-Anchor" href="#1-两数之和"></a> <a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h2>
<p>梦开始的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,map.get(target-nums[i])&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="283-移动零"><a class="markdownIt-Anchor" href="#283-移动零"></a> <a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将非零数移动到index处</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[index] = nums[i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="136-只出现一次的数字"><a class="markdownIt-Anchor" href="#136-只出现一次的数字"></a> <a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        single ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="70-爬楼梯"><a class="markdownIt-Anchor" href="#70-爬楼梯"></a> <a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯 </a></h2>
<p>直接使用递归求接斐波那契数列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用循环求解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>, f3 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        f3 = f1 + f2;</span><br><span class="line">        <span class="comment">// 优化</span></span><br><span class="line">        f1 = f2;</span><br><span class="line">        f2 = f3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以直接dp求解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n -<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="206-反转链表"><a class="markdownIt-Anchor" href="#206-反转链表"></a> <a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h2>
<p>双指针的解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="141-环形链表"><a class="markdownIt-Anchor" href="#141-环形链表"></a> <a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表 </a></h2>
<p>使用哈希表来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; listNodes = <span class="keyword">new</span> LinkedHashSet&lt;ListNode&gt;;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!listNodes.add(head.next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快慢指针法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="20-有效的括号"><a class="markdownIt-Anchor" href="#20-有效的括号"></a> <a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h2>
<p>可以使用暴力破解法，即遍历字符串，找到最近的匹配括号开始，如果匹配就替换为空字符串，一直循环下去，如果括号是匹配的，那么最终的结果应该是个空字符串。</p>
<p>这里使用的栈来解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// 如果个数是奇数个直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Character&gt; characterMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        characterMap.put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        characterMap.put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        characterMap.put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> bracket = s.charAt(i);</span><br><span class="line">            <span class="comment">// 栈中有左括号</span></span><br><span class="line">            <span class="keyword">if</span> (characterMap.containsKey(bracket)) &#123;</span><br><span class="line">                <span class="comment">// 如果栈中元素为空或者与Map中括号不匹配</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != characterMap.get(bracket)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(bracket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>除了这种，还有一种相对比较简单的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || c != stack.pop()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="155-最小栈"><a class="markdownIt-Anchor" href="#155-最小栈"></a> <a href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈 </a></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 存储最小值的栈</span></span><br><span class="line">    Deque&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="comment">// 普通的栈</span></span><br><span class="line">    Deque&lt;Integer&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        stack.push(val);</span><br><span class="line">        minStack.push(Math.min(val, minStack.pop()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="242-有效的字母异位词"><a class="markdownIt-Anchor" href="#242-有效的字母异位词"></a> <a href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a></h2>
<p>使用排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] sChars = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] tChars = t.toCharArray();</span><br><span class="line">    <span class="comment">// 注意这里不能简写为 Arrays.sort(s.toCharArray())，因为Arrays.sort采用的就地排序。</span></span><br><span class="line">    Arrays.sort(sChars);</span><br><span class="line">    Arrays.sort(tChars);</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(sChars, tChars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用哈希表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; hashTable = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        hashTable.put(c, hashTable.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">        hashTable.put(c, hashTable.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (hashTable.get(c) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="94-二叉树的中序遍历"><a class="markdownIt-Anchor" href="#94-二叉树的中序遍历"></a> <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2>
<p>使用传统的递归方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">     List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">this</span>.inorder(root, list);</span><br><span class="line">     <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">         inorder(root.left, res);</span><br><span class="line">     &#125;</span><br><span class="line">     res.add(root.val);</span><br><span class="line">     <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">         inorder(root.right, res);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>迭代实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">      <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span> || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 不断往左子树方向走，每走一次就将当前节点保存到栈中</span></span><br><span class="line">          <span class="comment">// 这是模拟递归的调用</span></span><br><span class="line">          <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">              stack.add(root);</span><br><span class="line">              root = root.left;</span><br><span class="line">              <span class="comment">// 当前节点为空，说明左边走到头了，从栈中弹出节点并保存</span></span><br><span class="line">              <span class="comment">// 然后转向右边节点，继续上面整个过程</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              TreeNode tmp = stack.pop();</span><br><span class="line">              res.add(tmp.val);</span><br><span class="line">              root = tmp.right;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>莫里斯遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal3</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode cur = root;    <span class="comment">// 记录当前节点位置</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;   <span class="comment">// 左节点为空，移到右子节点</span></span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode prev = cur.left;</span><br><span class="line">                <span class="keyword">while</span> (prev.right != <span class="keyword">null</span> &amp;&amp; prev.right != cur) &#123; <span class="comment">// 遍历到左子树的最右侧节点</span></span><br><span class="line">                    prev = prev.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (prev.right == <span class="keyword">null</span>) &#123;        <span class="comment">// 建立返回父节点连接</span></span><br><span class="line">                    prev.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                        <span class="comment">// 左子树建立了连接，说明遍历完了，可以拆除连接</span></span><br><span class="line">                    res.add(cur.val);           <span class="comment">// 中序遍历录入当前节点</span></span><br><span class="line">                    prev.right = <span class="keyword">null</span>;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="104-二叉树的最大深度"><a class="markdownIt-Anchor" href="#104-二叉树的最大深度"></a> <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2>
<p>递归解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>广度优先遍历解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepthByBFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; treeNodeQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        treeNodeQueue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!treeNodeQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = treeNodeQueue.size();</span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 移除上一层的结点</span></span><br><span class="line">                TreeNode node = treeNodeQueue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    treeNodeQueue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    treeNodeQueue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="455-分发饼干"><a class="markdownIt-Anchor" href="#455-分发饼干"></a> <a href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a></h2>
<p>使用贪心算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(g);</span><br><span class="line">    Arrays.sort(s);</span><br><span class="line">    <span class="comment">// 孩子数组的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 饼干数组的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; g.length &amp;&amp; j &lt; s.length) &#123;</span><br><span class="line">        <span class="comment">// 满足条件就下一个孩子</span></span><br><span class="line">        <span class="keyword">if</span> (g[i] &lt;= s[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不满足下一个饼干</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下标i正好是满足条件的孩子的个数</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="121-买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#121-买卖股票的最佳时机"></a> <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2>
<p>使用贪心算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; min) &#123;</span><br><span class="line">            min = prices[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            profit = Math.max(prices[i] - min, profit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，本题中股票值买卖一次。</p>
<h2 id="69-x-的平方根"><a class="markdownIt-Anchor" href="#69-x-的平方根"></a> <a href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a></h2>
<p>使用二分查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = x;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 注意：这里为了避免乘法溢出，改用除法</span></span><br><span class="line">        <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，解决此类问题也可以使用平方根法。</p>
<h2 id="367-有效的完全平方数"><a class="markdownIt-Anchor" href="#367-有效的完全平方数"></a> <a href="https://leetcode-cn.com/problems/valid-perfect-square/">367. 有效的完全平方数</a></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = num;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 这么写的原因是极端情况下left + right相加的结果溢出</span></span><br><span class="line">        <span class="keyword">int</span> mid =  left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid * mid &gt; num) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="509-斐波那契数"><a class="markdownIt-Anchor" href="#509-斐波那契数"></a> <a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h2>
<p>直接暴力递归的时间复杂度是O(2<sup>n</sup>)，因为需要优化，优化的思路大致分为两种，一种是记忆化搜索，一种是动态规划，使用记忆化搜索相当于剪枝，记忆化搜索的递归树：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210727102616.png" alt="image-20210727102609636" style="zoom: 67%;" />
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] mem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mem[n] == <span class="number">0</span>) &#123;</span><br><span class="line">        mem[n] = fib(n - <span class="number">1</span>, mem) + fib(n - <span class="number">2</span>, mem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mem[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只记录每次记忆化搜索的结果就变成了动态规划：</p>
<img src="C:/Users/jyc/AppData/Roaming/Typora/typora-user-images/image-20210727102754402.png" alt="image-20210727102754402" style="zoom:67%;" />
<p>所谓的状态转移方程或者说递推公式为：<code>dp[i] = dp[i - 1] + dp[i - 2]</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以进一步优化，实际上每次只需要存储最近的两个结果即可，按照这个思路，可以将空间复杂度优化到O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// 初始的时候，分别对应f(o) = 0和f(1) = 1</span></span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        <span class="comment">// 原来的值变成前一个元素</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        <span class="comment">// 新的值变成当前值</span></span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="53-最大子序和"><a class="markdownIt-Anchor" href="#53-最大子序和"></a> <a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h2>
<p>不难写出，这个问题的状态转移方程：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f(i) = max\{f(i - 1) + nums[i],num[i]\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">}</span></span></span></span></span></p>
<p>使用数组来保存 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> 的值，遍历求出所有的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> 即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        res = Math.max(dp[i], res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上我们无需记录所有的中间状态，只需要记录前一个值即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">        pre = Math.max(pre + x, x);</span><br><span class="line">        maxAns = Math.max(maxAns, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxAns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="409-最长回文串"><a class="markdownIt-Anchor" href="#409-最长回文串"></a> <a href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="414-第三大的数"><a class="markdownIt-Anchor" href="#414-第三大的数"></a> <a href="https://leetcode-cn.com/problems/third-maximum-number/">414. 第三大的数</a></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">        set.add(n);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            set.remove(Collections.min(set));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第三大的正好是集合当中最小的元素</span></span><br><span class="line">    <span class="keyword">if</span> (set.size() == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.min(set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明数组的元素不超过3个</span></span><br><span class="line">    <span class="keyword">return</span> Collections.max(set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="高频考题中等"><a class="markdownIt-Anchor" href="#高频考题中等"></a> 高频考题（中等）</h1>
<h2 id="5-最长回文子串"><a class="markdownIt-Anchor" href="#5-最长回文子串"></a> <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2>
<p>我们使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>表示字符串<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个字母组成的串（下文表示成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>:</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[i:j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>）是否为回文串：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left center left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">串</mi><msub><mi>S</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>S</mi><mi>j</mi></msub><mi mathvariant="normal">是</mi><mi mathvariant="normal">回</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">串</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">其</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">情</mi><mi mathvariant="normal">况</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">p(i,j)=\left\{
\begin{array}{lcl}
true, &amp; 如果字串S_i...S_j是回文串 \\
false, &amp; 其它情况
\end{array}\right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mpunct">,</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">串</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">回</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">串</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">情</span><span class="mord cjk_fallback">况</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>这里的其它情况包含两种可能性：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>本身不是一个回文串</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&gt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i&gt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，此时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>本身不合法</li>
</ul>
<p>那么对应的状态转移方程：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><msub><mi>S</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(i,j) = p(i+1,j-1)\wedge(S_i==S_j)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>以上都是子串长度2的前提之上的，对于长度为1的字串，明显就是回文串，对于长度为2的字串，只要它的两个字母相同，就是一个回文串，因此，可以确定动态规划的边界条件：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left center left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">串</mi><msub><mi>S</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>S</mi><mi>j</mi></msub><mi mathvariant="normal">是</mi><mi mathvariant="normal">回</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">串</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><msub><mi>S</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">其</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">情</mi><mi mathvariant="normal">况</mi></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{
\begin{array}{lcl}
p(i,i)=true, &amp; 如果字串S_i...S_j是回文串 \\
p(i,i+1)=(S_i==S_{i+1}), &amp; 其它情况
\end{array}\right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mpunct">,</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">串</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">回</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">串</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">情</span><span class="mord cjk_fallback">况</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>相应的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">    <span class="comment">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="comment">// 递推开始</span></span><br><span class="line">    <span class="comment">// 先枚举子串长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">2</span>; L &lt;= len; L++) &#123;</span><br><span class="line">        <span class="comment">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class="line">            <span class="keyword">int</span> j = L + i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= len) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                begin = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-offer-67-把字符串转换成整数"><a class="markdownIt-Anchor" href="#剑指-offer-67-把字符串转换成整数"></a> <a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, sign = <span class="number">1</span>, total = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 空字符串</span></span><br><span class="line">        <span class="keyword">if</span> (str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除空格</span></span><br><span class="line">        <span class="keyword">while</span> (str.charAt(index) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理正负号</span></span><br><span class="line">        <span class="keyword">if</span> (str.charAt(index) == <span class="string">&#x27;+&#x27;</span> || str.charAt(index) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = str.charAt(index) == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转为数字</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; str.length()) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = str.charAt(index) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (digit &lt; <span class="number">0</span> || digit &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 越界处理</span></span><br><span class="line">            <span class="keyword">if</span> (Integer.MAX_VALUE / <span class="number">10</span> &lt; total ||</span><br><span class="line">                    (Integer.MAX_VALUE / <span class="number">10</span> == total &amp;&amp; Integer.MAX_VALUE % <span class="number">10</span> &lt; digit)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sign == <span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                total = <span class="number">10</span> * total + digit;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total * sign;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-盛最多水的容器"><a class="markdownIt-Anchor" href="#11-盛最多水的容器"></a> <a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器 </a></h2>
<p>传统的遍历方式，时间复杂度为O(n^2)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">             <span class="keyword">int</span> hg = Math.min(height[i], height[j]);</span><br><span class="line">             <span class="keyword">int</span> area = Math.abs(j - i) * hg;</span><br><span class="line">             max = Math.max(max,area);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> max;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>也可以采用双边收敛的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.length - <span class="number">1</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = Math.min(height[i],height[j]);</span><br><span class="line">            <span class="keyword">int</span> res = h * (j - i);</span><br><span class="line">            max = Math.max(res,max);</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-三数之和"><a class="markdownIt-Anchor" href="#15-三数之和"></a> <a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h2>
<p>穷举法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; nums.length; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((nums[i] + nums[j] + nums[k]) == target) &#123;</span><br><span class="line">                    List&lt;Integer&gt; integers = Arrays.asList(nums[i],nums[j],nums[k]);</span><br><span class="line">                    res.add(integers);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双指针法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="comment">// O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 经过排序之后的数组第一个数大于0，后面的数都比它大，一定不成立</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉重复情况</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] + nums[right] + nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="comment">// 去掉重复情况，一直移动到没有相同项</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] + nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[left] + nums[right] + nums[i] &gt; 0</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="49-字母异位词分组"><a class="markdownIt-Anchor" href="#49-字母异位词分组"></a> <a href="https://leetcode-cn.com/problems/group-anagrams/">49. 字母异位词分组</a></h2>
<p>使用哈希表，将排序之后的字符串作为key，并且排序之后相同的字符串添加到列表中，最后从Map中获取值并返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = strs[i].toCharArray();</span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line">            String key = String.valueOf(chars);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">                map.put(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(key).add(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="22-括号生成"><a class="markdownIt-Anchor" href="#22-括号生成"></a> <a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h2>
<p>括号生成的状态树：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210712114808.png" alt="image.png" style="zoom:50%;" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="string">&quot;&quot;</span>, res, n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String paths, List&lt;String&gt; res, <span class="keyword">int</span> n, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 剪枝,去掉( &gt; n 或 ) &gt; n 或 ) &gt; (的情况，由于传递性，) &gt; n可以去掉</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; n || right &gt; left) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为括号都是成对出现的，因此需要遍历的树的深度为n*2</span></span><br><span class="line">    <span class="keyword">if</span> (paths.length() == n * <span class="number">2</span>) &#123;</span><br><span class="line">        res.add(paths);</span><br><span class="line">        <span class="comment">// 每次遍历后，需要将上一次的结果清理，从根结点继续遍历</span></span><br><span class="line">        paths = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(paths + <span class="string">&#x27;(&#x27;</span>, res, n, left + <span class="number">1</span>, right);</span><br><span class="line">    dfs(paths + <span class="string">&#x27;)&#x27;</span>, res, n, left, right + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="98-验证二叉搜索树"><a class="markdownIt-Anchor" href="#98-验证二叉搜索树"></a> <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2>
<blockquote>
<p>二叉搜索树有两个重要性质，第一，左子树上所有结点的值都要小于根节点的值，右子树所有结点的值都要大于根节点的值；第二，中序遍历后的结果是一个递增的数列。</p>
</blockquote>
<p>使用递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(TreeNode node, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.val &lt;= min || node.val &gt;= max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相当于给子树上所有的节点都添加了min和max的边界</span></span><br><span class="line">    <span class="comment">// 约束root的左子树的值不超过root的值，右子树的值不小于root的值</span></span><br><span class="line">    <span class="keyword">return</span> validate(node.left, min, node.val) &amp;&amp; validate(node.right, node.val, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用中序遍历的性质：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储上一个节点的值</span></span><br><span class="line">    <span class="keyword">double</span> inorder = -Double.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        <span class="comment">// 当前节点的值与上一个节点的值进行比较</span></span><br><span class="line">        <span class="keyword">if</span> (node.val &lt;= inorder) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder = node.val;</span><br><span class="line">        root = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，也可以先进行中序遍历，然后判断返回的列表是否为升序。</p>
<h2 id="236-二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#236-二叉树的最近公共祖先"></a> <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2>
<p>树的祖先的定义：若节点P在节点root的左（右）子树中，或P=root，则称root是p的祖先。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210713224143.png" alt="Picture1.png" style="zoom:50%;" />
<p>最近公共祖先的定义：设节点root为节点p，q的某公共祖先，若其左子节点root.left和右子节点root.right都不是p,q的公共祖先，则称root是&quot;最近的公共祖先&quot;。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210713224306.png" alt="Picture2.png" style="zoom:50%;" />
<p>根据以上定义，若root是p,q的最近公共祖先，则只可能为以下情况之一：</p>
<ul>
<li>p 和q 在root的子树中，且分列root的异侧即分别在左、右子树中）</li>
<li>p = root，且q在root的左或右子树中</li>
<li>q = root，且p在root的左或右子树中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果p,q为根节点，则公共祖先为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == p.val || root.val == q.val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 如果p,q在左子树，则公共祖先在左子树查找</span></span><br><span class="line">        <span class="keyword">if</span> (find(root.left, p) &amp;&amp; find(root.left, q)) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果p,q在右子树，则公共祖先在右子树查找</span></span><br><span class="line">        <span class="keyword">if</span> (find(root.right, p) &amp;&amp; find(root.right, q)) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果p,q分属两侧，则公共祖先为根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(TreeNode root, TreeNode c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val == c.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> find(root.left, c) || find(root.right, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="50-powx-n"><a class="markdownIt-Anchor" href="#50-powx-n"></a> <a href="https://leetcode-cn.com/problems/powx-n/">50. Pow(x, n)</a></h2>
<p>使用暴力解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        N = -n;</span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans = ans * x;</span><br><span class="line">        N--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过观察不难发现，对于f(n) = x<sup>n</sup>（x为常数）都有f(n) = f(n/2)* f(n/2)，因此可以通过分治的方式来处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow2</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || x==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            N = -N;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myPow2Helper(x, N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">myPow2Helper</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果指数是奇数，则需要补乘一个x</span></span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> myPow2Helper(x, N / <span class="number">2</span>) * myPow2Helper(x, N / <span class="number">2</span>) * x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> myPow2Helper(x, N / <span class="number">2</span>) * myPow2Helper(x, N / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="78-子集"><a class="markdownIt-Anchor" href="#78-子集"></a> <a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h2>
<p>以求解[1,2,3]的子集为例，画出的树形图如下所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210711180106.png" alt="image.png" style="zoom: 50%;" />
<p>使用回溯算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       dfs(nums, res, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> n, ArrayList&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">       res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; nums.length; i++) &#123;</span><br><span class="line">           temp.add(nums[i]);</span><br><span class="line">           dfs(nums, res, i + <span class="number">1</span>, temp);</span><br><span class="line">           temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-电话号码的字母组合"><a class="markdownIt-Anchor" href="#17-电话号码的字母组合"></a> <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h2>
<p>题目的状态树：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210712235154.png" alt="17. 电话号码的字母组合" style="zoom:50%;" />
<p>使用回溯法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;5&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;6&quot;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;7&quot;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;8&quot;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;9&quot;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">    dfs(digits, <span class="number">0</span>, map, res, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String digits, <span class="keyword">int</span> index, Map&lt;String, String&gt; map, List&lt;String&gt; res, StringBuilder str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">        res.add(str.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前数字对应的字符值</span></span><br><span class="line">    String val = map.get(digits.substring(index, index + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : val.toCharArray()) &#123;</span><br><span class="line">        str.append(c);</span><br><span class="line">        dfs(digits, index + <span class="number">1</span>, map, res, str);</span><br><span class="line">        <span class="comment">// 删除刚才添加到末尾的元素，选择当前数字对应字符串的下一个值进行遍历</span></span><br><span class="line">        str.deleteCharAt(str.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="102-二叉树的层序遍历"><a class="markdownIt-Anchor" href="#102-二叉树的层序遍历"></a> <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; num = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="comment">// 遍历当前层结点</span></span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode treeNode = queue.poll();</span><br><span class="line">                num.add(treeNode.val);</span><br><span class="line">                <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(treeNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(treeNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="200-岛屿数量"><a class="markdownIt-Anchor" href="#200-岛屿数量"></a> <a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h2>
<p>岛屿问题是一类典型的网格问题。通常而言，网格中的格子的相邻的格子节点分别是上下左右四个。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210713174441.jpeg" alt="网格结构中四个相邻的格子" style="zoom:50%;" />
<p>在这类问题中，深度优先遍历的终止条件：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210713174700.jpeg" alt="网格 DFS 的 base case" style="zoom:50%;" />
<p>这样我们就得到了网格DFS遍历的框架代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="comment">// 如果坐标 (r, c) 超出了网格范围，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与二叉树的深度遍历不同的是，网格的遍历可能会遍历重复的节点：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210713174948.gif" alt="DFS 遍历可能会兜圈子（动图）" style="zoom:50%;" />
<p>为了避免这样重复的遍历，我们可以将已经遍历过的格子进行标记，也就是说，每个格子可能取三个值：</p>
<ul>
<li>0 表示海洋格子</li>
<li>1 表示陆地格子（未遍历过）</li>
<li>2 表示陆地格子（已遍历过）</li>
</ul>
<p>因此我们可以将代码模板修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>; <span class="comment">// 将格子标记为「已遍历过」</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用这个代码模板求接这个问题实际上就是求深度遍历的次数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实际上就是求深度遍历的次数</span></span><br><span class="line">    <span class="keyword">int</span> dfsNumber = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; grid.length; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; grid[<span class="number">0</span>].length; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dfs(grid, r, c);</span><br><span class="line">                dfsNumber++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfsNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意这里的次序不能交换，必须先判断在网格中，再判断元素是否等于&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c) || grid[r][c] != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经遍历过了就设置为0</span></span><br><span class="line">    grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断格子是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length</span><br><span class="line">            &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="322-零钱兑换"><a class="markdownIt-Anchor" href="#322-零钱兑换"></a> <a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h2>
<p>使用贪心算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br></pre></td></tr></table></figure>
<h2 id="55-跳跃游戏"><a class="markdownIt-Anchor" href="#55-跳跃游戏"></a> <a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h2>
<p>使用贪心算法：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210719235247.png" alt="image-20210719235247657" /></p>
<p>此时0这个位置的下标是4，但是之前最大的可达步数是3，因为无法再进行跳跃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 最大能跳跃到的地方</span></span><br><span class="line">     <span class="keyword">int</span> maxJump = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (i &gt; maxJump) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         maxJump = Math.max(i + nums[i], maxJump);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="74-搜索二维矩阵"><a class="markdownIt-Anchor" href="#74-搜索二维矩阵"></a> <a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></h2>
<p>将矩阵每一行拼接在上一行的末尾，则会得到一个升序数组，我们可以在该数组上二分找到目标元素，可以二分升序数组的下标，将其映射到原矩阵的行和列上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> c = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 总共有这么多个元素</span></span><br><span class="line">    <span class="keyword">int</span> right = r * c - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 最主要的就是元素映射到原矩阵的行和列上</span></span><br><span class="line">        <span class="comment">// mid/c刚好是行数,mid%c刚好是列数,注意矩阵的下标从0开始算起</span></span><br><span class="line">        <span class="keyword">int</span> element = matrix[mid / c][mid % c];</span><br><span class="line">        <span class="keyword">if</span> (element == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="62-不同路径"><a class="markdownIt-Anchor" href="#62-不同路径"></a> <a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h2>
<p>递推公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(m,n) = f(m - 1, n) + f(m, n - 1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>直接求解即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">// 最后一行和最后一列都只有一种走法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="120-三角形最小路径和"><a class="markdownIt-Anchor" href="#120-三角形最小路径和"></a> <a href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和</a></h2>
<p>注意，本题要求每一步只能移动到下一行相邻的结点上，由此，递归方程为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">}</mo><mo>+</mo><mi>c</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i,j) = min \{f(i - 1, j),f(i-1, j-1) \} + c(i)(j)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c(i)(j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>表示位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>对应的元素值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="comment">// 结果一定是下三角矩阵</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 第一列的结果等于上一行的元素加上当前行的元素</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">// 除了第一列元素和最后一列元素都满足状态转移方程</span></span><br><span class="line">            dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + triangle.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对角线上的元素等于上一个对角线元素加上当前元素</span></span><br><span class="line">        dp[i][i] = dp[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一行就是所有的结果，找出最小值即可</span></span><br><span class="line">    <span class="keyword">int</span> min = dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = Math.min(min, dp[n - <span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1143-最长公共子序列"><a class="markdownIt-Anchor" href="#1143-最长公共子序列"></a> <a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2>
<p>假设字符串<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>e</mi><mi>x</mi><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">text_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>e</mi><mi>x</mi><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">text_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的长度分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，创建<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>列的二维数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>e</mi><mi>x</mi><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mn>0</mn><mo>:</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">text_1[0:i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>e</mi><mi>x</mi><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">[</mo><mn>0</mn><mo>:</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">text_2[0:j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>的最长公共序列的长度，状态转移方程如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left center left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>t</mi><mi>e</mi><mi>x</mi><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mi>e</mi><mi>x</mi><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>t</mi><mi>e</mi><mi>x</mi><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mi mathvariant="normal">≠</mi><mi>t</mi><mi>e</mi><mi>x</mi><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp[i][j]=\left\{
\begin{array}{lcl}
dp[i-1][j-1] + 1, &amp; text_1[i-1] = text_2[j-1] \\
max(dp[i-1][j],dp[i][j-1]), &amp; text_1[i-1] \neq text_2[j-1]
\end{array}\right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>示意图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210819120336.png" style="zoom:67%;" />
<p>直接求解即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = text1.length();</span><br><span class="line">    <span class="keyword">int</span> n = text2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = text1.charAt(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c2 = text2.charAt(j - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// text_1[i - 1] = text_2[j -1]</span></span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// text_1[i - 1] ≠ text_2[j -1]</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="198-打家劫舍"><a class="markdownIt-Anchor" href="#198-打家劫舍"></a> <a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h2>
<p>假设一共有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个房子，每个房子的金额分别是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>H</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>H</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">H_0,H_1,...H_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，子问题<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>表示从前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个房子（即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mi mathvariant="normal">，</mi><msub><mi>H</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">H_0，H_1,...,H_{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>）中能偷盗的最大金额。那么偷<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个房子有两种偷法：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210820105009.png" alt="image-20210820104524320" style="zoom:67%;" />
<p>状态转移方程为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f(k)=max\{ {f(k-1),H_{k-1} + f(k-2)} \}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span></span><span class="mclose">}</span></span></span></span></span></p>
<p>使用一维数组的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">// 第0位用来存储0的情况，从第1位开始存储nums[1]</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 注意这里从2开始，到n+1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], nums[i] + dp[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以多开一维数组来存每次偷或者不偷的状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 0表示不选当前元素，1表示选择当前元素</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="213-打家劫舍-ii"><a class="markdownIt-Anchor" href="#213-打家劫舍-ii"></a> <a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h2>
<p>状态转移方程：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i]=max(dp[i-2]+nums[i],dp[i-1])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>边界条件为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left center left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">只</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">房</mi><mi mathvariant="normal">屋</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">则</mi><mi mathvariant="normal">偷</mi><mi mathvariant="normal">窃</mi><mi mathvariant="normal">该</mi><mi mathvariant="normal">房</mi><mi mathvariant="normal">屋</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">只</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">两</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">房</mi><mi mathvariant="normal">屋</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">偷</mi><mi mathvariant="normal">窃</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">金</mi><mi mathvariant="normal">额</mi><mi mathvariant="normal">较</mi><mi mathvariant="normal">高</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">房</mi><mi mathvariant="normal">屋</mi></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{
\begin{array}{lcl}
dp[start] = nums[start] &amp; 只有一间房屋，则偷窃该房屋 \\
dp[start+1] = max(nums[start],nums[start+1]) &amp; 只有两件房屋，偷窃其中金额较高的房屋
\end{array}\right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">只</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">房</span><span class="mord cjk_fallback">屋</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">偷</span><span class="mord cjk_fallback">窃</span><span class="mord cjk_fallback">该</span><span class="mord cjk_fallback">房</span><span class="mord cjk_fallback">屋</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">只</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">两</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">房</span><span class="mord cjk_fallback">屋</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">偷</span><span class="mord cjk_fallback">窃</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">金</span><span class="mord cjk_fallback">额</span><span class="mord cjk_fallback">较</span><span class="mord cjk_fallback">高</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">房</span><span class="mord cjk_fallback">屋</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>相应的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="79-单词搜索"><a class="markdownIt-Anchor" href="#79-单词搜索"></a> <a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h2>
<h1 id="高频考题困难"><a class="markdownIt-Anchor" href="#高频考题困难"></a> 高频考题（困难）</h1>
<h2 id="84-柱状图中最大的矩形"><a class="markdownIt-Anchor" href="#84-柱状图中最大的矩形"></a> <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h2>
<p>使用暴力法求解：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210713190144.png" alt="image.png" style="zoom: 33%;" />
<p>对于每一个位置，我们需要：</p>
<ul>
<li>向左遍历，找到大于等于当前柱形高度最左元素的下标</li>
<li>向右遍历，找到大于等于当前柱形高度最右元素的下标</li>
</ul>
<p>然后得到一个矩形的面积，求出他们的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heights.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 向左遍历，找到大于等于当前柱形高度最左元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> left = i;</span><br><span class="line">        <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; heights[left - <span class="number">1</span>] &gt;= heights[i]) &#123;</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向右遍历，找到大于等于当前柱形高度最右元素的下标，注意这里的边界条件</span></span><br><span class="line">        <span class="keyword">int</span> right = i;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; heights.length - <span class="number">1</span> &amp;&amp; heights[right + <span class="number">1</span>] &gt;= heights[i]) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> width = right - left + <span class="number">1</span>;</span><br><span class="line">        res = Math.max(res, width * heights[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="239-滑动窗口最大值"><a class="markdownIt-Anchor" href="#239-滑动窗口最大值"></a> <a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2>
<div class="note info"><p>所有滑动窗口的问题都可以使用队列来解决。</p></div>
<p>暴力求解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用最大堆（优先队列）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">       <span class="keyword">int</span> n = nums.length;</span><br><span class="line">       <span class="comment">// 传入比较器，当两者的值相同时，比较下标的位置，下标大的在前面。</span></span><br><span class="line">       PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((p1, p2) -&gt; p1[<span class="number">0</span>] != p2[<span class="number">0</span>] ? p2[<span class="number">0</span>] - p1[<span class="number">0</span>] : p2[<span class="number">1</span>] - p1[<span class="number">1</span>]);</span><br><span class="line">       <span class="comment">// 初始化k前面的元素到堆中</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">           queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 答案总共有n-k+1个</span></span><br><span class="line">       <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">       <span class="comment">// 将第一次的答案添加到结果当中</span></span><br><span class="line">       ans[<span class="number">0</span>] = queue.peek()[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="comment">// 将新元素加入优先队列</span></span><br><span class="line">           queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">           <span class="comment">// 循环判断当前队首是否在窗口中，窗口的左边界为i-k</span></span><br><span class="line">           <span class="keyword">while</span> (queue.peek()[<span class="number">1</span>] &lt;= i - k) &#123;</span><br><span class="line">               queue.poll();</span><br><span class="line">           &#125;</span><br><span class="line">           ans[i - k + <span class="number">1</span>] = queue.peek()[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="51-n-皇后"><a class="markdownIt-Anchor" href="#51-n-皇后"></a> <a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">       List&lt;List&lt;String&gt;&gt; solutions = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">       <span class="keyword">int</span>[] queens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">       Arrays.fill(queens, -<span class="number">1</span>);</span><br><span class="line">       Set&lt;Integer&gt; columns = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">       Set&lt;Integer&gt; diagonals1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">       Set&lt;Integer&gt; diagonals2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">       backtrack(solutions, queens, n, <span class="number">0</span>, columns, diagonals1, diagonals2);</span><br><span class="line">       <span class="keyword">return</span> solutions;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; solutions, <span class="keyword">int</span>[] queens, <span class="keyword">int</span> n, <span class="keyword">int</span> row, Set&lt;Integer&gt; columns, Set&lt;Integer&gt; diagonals1, Set&lt;Integer&gt; diagonals2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">           List&lt;String&gt; board = generateBoard(queens, n);</span><br><span class="line">           solutions.add(board);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (columns.contains(i)) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">int</span> diagonal1 = row - i;</span><br><span class="line">               <span class="keyword">if</span> (diagonals1.contains(diagonal1)) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">int</span> diagonal2 = row + i;</span><br><span class="line">               <span class="keyword">if</span> (diagonals2.contains(diagonal2)) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               queens[row] = i;</span><br><span class="line">               columns.add(i);</span><br><span class="line">               diagonals1.add(diagonal1);</span><br><span class="line">               diagonals2.add(diagonal2);</span><br><span class="line">               backtrack(solutions, queens, n, row + <span class="number">1</span>, columns, diagonals1, diagonals2);</span><br><span class="line">               queens[row] = -<span class="number">1</span>;</span><br><span class="line">               columns.remove(i);</span><br><span class="line">               diagonals1.remove(diagonal1);</span><br><span class="line">               diagonals2.remove(diagonal2);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateBoard</span><span class="params">(<span class="keyword">int</span>[] queens, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; board = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="keyword">char</span>[] row = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">           Arrays.fill(row, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">           row[queens[i]] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">           board.add(<span class="keyword">new</span> String(row));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> board;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="212-单词搜索-ii"><a class="markdownIt-Anchor" href="#212-单词搜索-ii"></a> <a href="https://leetcode-cn.com/problems/word-search-ii/">212. 单词搜索 II</a></h2>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出Redis</title>
    <url>/2021/04/07/Redis/</url>
    <content><![CDATA[<p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
<span id="more"></span>
<h1 id="redis入门"><a class="markdownIt-Anchor" href="#redis入门"></a> Redis入门</h1>
<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<h3 id="redis是什么"><a class="markdownIt-Anchor" href="#redis是什么"></a> Redis是什么？</h3>
<p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
<p>与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<h3 id="redis能该干什么"><a class="markdownIt-Anchor" href="#redis能该干什么"></a> Redis能该干什么？</h3>
<ol>
<li>内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</li>
<li>高效率、用于高速缓冲</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器(eg：浏览量)</li>
</ol>
<h3 id="核心特性"><a class="markdownIt-Anchor" href="#核心特性"></a> 核心特性</h3>
<ul>
<li>多样的数据类型</li>
<li>持久化</li>
<li>集群</li>
<li>事务</li>
</ul>
<h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3>
<p>Redis是一个字典结构的存储服务器，一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将这数据存储在哪个字典中，这与在一个关系型数据库实例（以MySQL为例）中可以创建多个数据库类似，可以将其中的每个字典都理解成一个独立的数据库。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210828102202.png" alt="image-20210828102202300" style="zoom:50%;" />
<p>16个数据库分别为：DB 0~DB 15，默认使用DB 0 ，可以使用<code>select n</code>切换到DB n，<code>dbsize</code>可以查看当前数据库的大小，与key数量相关。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get databases <span class="comment"># 命令行查看数据库数量databases</span></span><br><span class="line">1) <span class="string">&quot;databases&quot;</span></span><br><span class="line">2) <span class="string">&quot;16&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; select 8 <span class="comment"># 切换数据库 DB 8</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; dbsize <span class="comment"># 查看数据库大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name sakura </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SELECT 8</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; get name <span class="comment"># db8中并不能获取db0中的键值对。</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379[8]&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[8]&gt; SELECT 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;counter:__rand_int__&quot;</span></span><br><span class="line">2) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">3) <span class="string">&quot;name&quot;</span></span><br><span class="line">4) <span class="string">&quot;key:__rand_int__&quot;</span></span><br><span class="line">5) <span class="string">&quot;myset:__rand_int__&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; DBSIZE <span class="comment"># size和key个数相关</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure>
<p><code>keys *</code> ：查看当前数据库中所有的key。</p>
<p><code>flushdb</code>：清空当前数据库中的键值对。</p>
<p><code>flushall</code>：清空所有数据库的键值对。</p>
<div class="note warining"><p>keys *这个命令需要慎重使用，如果数据库中的键过多可能会造成卡顿，生产环境中应该使用dbsize</p></div>
<h2 id="五大数据类型"><a class="markdownIt-Anchor" href="#五大数据类型"></a> 五大数据类型</h2>
<p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持<a href="https://www.redis.net.cn/tutorial/3508.html">字符串</a>、<a href="https://www.redis.net.cn/tutorial/3509.html">哈希表</a>、<a href="https://www.redis.net.cn/tutorial/3510.html">列表</a>、<a href="https://www.redis.net.cn/tutorial/3511.html">集合</a>、<a href="https://www.redis.net.cn/tutorial/3512.html">有序集合</a>，<a href="https://www.redis.net.cn/tutorial/3508.html">位图</a>，<a href="https://www.redis.net.cn/tutorial/3513.html">hyperloglogs</a>等数据类型。内置复制、<a href="https://www.redis.net.cn/tutorial/3516.html">Lua脚本</a>、LRU收回、<a href="https://www.redis.net.cn/tutorial/3515.html">事务</a>以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动<a href="https://www.redis.net.cn/tutorial/3524.html">分区</a>。</p>
<h3 id="redis-key"><a class="markdownIt-Anchor" href="#redis-key"></a> Redis-key</h3>
<p>在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。</p>
<p>下面学习的命令：</p>
<ul>
<li><code>exists key</code>：判断键是否存在</li>
<li><code>del key</code>：删除键值对</li>
<li><code>move key db</code>：将键值对移动到指定数据库</li>
<li><code>expire key second</code>：设置键值对的过期时间</li>
<li><code>type key</code>：查看value的数据类型</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 查看当前数据库所有key</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name qinjiang <span class="comment"># set key</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; move age 1 <span class="comment"># 将键值对移动到指定数据库</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS age <span class="comment"># 判断键是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不存在</span></span><br><span class="line">127.0.0.1:6379&gt; EXISTS name</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 存在</span></span><br><span class="line">127.0.0.1:6379&gt; SELECT 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379[1]&gt; del age <span class="comment"># 删除键值对</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 删除个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE age 15 <span class="comment"># 设置键值对的过期时间</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 设置成功 开始计数</span></span><br><span class="line">127.0.0.1:6379&gt; ttl age <span class="comment"># 查看key的过期剩余时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2 <span class="comment"># -2 表示key过期，-1表示key未设置过期时间</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get age <span class="comment"># 过期的key 会被自动delete</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name <span class="comment"># 查看value的数据类型</span></span><br><span class="line">string</span><br></pre></td></tr></table></figure>
<p>关于<code>TTL</code>命令</p>
<p>Redis的key，通过TTL命令返回key的过期时间，一般来说有3种：</p>
<ol>
<li>当前key没有设置过期时间，所以会返回-1.</li>
<li>当前key有设置过期时间，而且key已经过期，所以会返回-2.</li>
<li>当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</li>
</ol>
<p>关于重命名<code>RENAME</code>和<code>RENAMENX</code></p>
<ul>
<li><code>RENAME key newkey</code>修改 key 的名称</li>
<li><code>RENAMENX key newkey</code>仅当 newkey 不存在时，将 key 改名为 newkey 。</li>
</ul>
<p>更多命令学习：<a href="https://www.redis.net.cn/order/">Redis命令大全</a></p>
<p>实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样Redis会在合适的场景选择合适的内部编码，如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210828115030.png" alt="Redis内部编码实现" style="zoom:50%;" />
<p>Redis这样设计有两个好处：</p>
<ul>
<li>可以改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令</li>
<li>多种内部编码实现可以在不同场景下发挥各自的优势</li>
</ul>
<h3 id="string字符串"><a class="markdownIt-Anchor" href="#string字符串"></a> String(字符串)</h3>
<p>普通的set、get直接略过。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>APPEND key value</td>
<td>向指定的key的value后追加字符串</td>
<td>127.0.0.1:6379&gt; set msg hello OK 127.0.0.1:6379&gt; append msg &quot; world&quot; (integer) 11 127.0.0.1:6379&gt; get msg “hello world”</td>
</tr>
<tr>
<td>DECR/INCR key</td>
<td>将指定key的value数值进行+1/-1(仅对于数字)</td>
<td>127.0.0.1:6379&gt; set age 20 OK 127.0.0.1:6379&gt; incr age (integer) 21 127.0.0.1:6379&gt; decr age (integer) 20</td>
</tr>
<tr>
<td>INCRBY/DECRBY key n</td>
<td>按指定的步长对数值进行加减</td>
<td>127.0.0.1:6379&gt; INCRBY age 5 (integer) 25 127.0.0.1:6379&gt; DECRBY age 10 (integer) 15</td>
</tr>
<tr>
<td>INCRBYFLOAT key n</td>
<td>为数值加上浮点型数值</td>
<td>127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 “20.2”</td>
</tr>
<tr>
<td>STRLEN key</td>
<td>获取key保存值的字符串长度</td>
<td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; STRLEN msg (integer) 11</td>
</tr>
<tr>
<td>GETRANGE key start end</td>
<td>按起止位置获取字符串（闭区间，起止位置都取）</td>
<td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; GETRANGE msg 3 9 “lo worl”</td>
</tr>
<tr>
<td>SETRANGE key offset value</td>
<td>用指定的value 替换key中 offset开始的值</td>
<td>127.0.0.1:6379&gt; SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379&gt; get msg “tehello”</td>
</tr>
<tr>
<td>GETSET key value</td>
<td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
<td>127.0.0.1:6379&gt; GETSET msg test “hello world”</td>
</tr>
<tr>
<td>SETNX key value</td>
<td>仅当key不存在时进行set</td>
<td>127.0.0.1:6379&gt; SETNX msg test (integer) 0 127.0.0.1:6379&gt; SETNX name sakura (integer) 1</td>
</tr>
<tr>
<td>SETEX key seconds value</td>
<td>set 键值对并设置过期时间</td>
<td>127.0.0.1:6379&gt; setex name 10 root OK 127.0.0.1:6379&gt; get name (nil)</td>
</tr>
<tr>
<td>MSET key1 value1 [key2 value2…]</td>
<td>批量set键值对</td>
<td>127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 OK</td>
</tr>
<tr>
<td>MSETNX key1 value1 [key2 value2…]</td>
<td>批量设置键值对，仅当参数中所有的key都不存在时执行</td>
<td>127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 (integer) 0</td>
</tr>
<tr>
<td>MGET key1 [key2…]</td>
<td>批量获取多个key保存的值</td>
<td>127.0.0.1:6379&gt; MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”</td>
</tr>
<tr>
<td>PSETEX key milliseconds value</td>
<td>和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，</td>
<td></td>
</tr>
<tr>
<td>getset key value</td>
<td>如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值</td>
<td></td>
</tr>
</tbody>
</table>
<p>String类似的使用场景：value除了是字符串还可以是数字，用途举例：</p>
<ul>
<li>计数器</li>
<li>统计多单位的数量：uid:123666：follow 0</li>
<li>粉丝数</li>
<li>对象存储缓存</li>
</ul>
<h3 id="list列表"><a class="markdownIt-Anchor" href="#list列表"></a> List(列表)</h3>
<p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边），一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p>
<p>首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210828102958.png" alt="image-20210828102918813" style="zoom:50%;" />
<p>正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LPUSH/RPUSH key value1[value2..]</code></td>
<td>从左边/右边向列表中PUSH值(一个或者多个)。</td>
</tr>
<tr>
<td><code>LRANGE key start end</code></td>
<td>获取list 起止元素（索引从左往右 递增）</td>
</tr>
<tr>
<td><code>LPUSHX/RPUSHX key value</code></td>
<td>向已存在的列名中push值（一个或者多个）</td>
</tr>
<tr>
<td><code>LINSERT key BEFORE|AFTER pivot value</code></td>
<td>在指定列表元素的前/后 插入value</td>
</tr>
<tr>
<td><code>LLEN key</code></td>
<td>查看列表长度</td>
</tr>
<tr>
<td><code>LINDEX key index</code></td>
<td>通过索引获取列表元素</td>
</tr>
<tr>
<td><code>LSET key index value</code></td>
<td>通过索引为元素设值</td>
</tr>
<tr>
<td><code>LPOP/RPOP key</code></td>
<td>从最左边/最右边移除值 并返回</td>
</tr>
<tr>
<td><code>RPOPLPUSH source destination</code></td>
<td>将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部</td>
</tr>
<tr>
<td><code>LTRIM key start end</code></td>
<td>通过下标截取指定范围内的列表</td>
</tr>
<tr>
<td><code>LREM key count value</code></td>
<td>List中是允许value重复的 <code>count &gt; 0</code>：从头部开始搜索 然后删除指定的value 至多删除count个 <code>count &lt; 0</code>：从尾部开始搜索… <code>count = 0</code>：删除列表中所有的指定value。</td>
</tr>
<tr>
<td><code>BLPOP/BRPOP key1[key2] timout</code></td>
<td>移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td><code>BRPOPLPUSH source destination timeout</code></td>
<td>和<code>RPOPLPUSH</code>功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---------------------------LPUSH---RPUSH---LRANGE--------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k1 <span class="comment"># LPUSH mylist=&gt;&#123;1&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k2 <span class="comment"># LPUSH mylist=&gt;&#123;2,1&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist k3 <span class="comment"># RPUSH mylist=&gt;&#123;2,1,3&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; get mylist <span class="comment"># 普通的get是无法获取list值的</span></span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 4 <span class="comment"># LRANGE 获取起止位置范围内的元素</span></span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 2</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 1</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1 <span class="comment"># 获取全部元素</span></span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LPUSHX---RPUSHX-----------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 <span class="comment"># list不存在 LPUSHX失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 v2  </span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX mylist k4 k5 <span class="comment"># 向mylist中 左边 PUSH k4 k5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k5&quot;</span></span><br><span class="line">2) <span class="string">&quot;k4&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">4) <span class="string">&quot;k1&quot;</span></span><br><span class="line">5) <span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist after k2 ins_key1 <span class="comment"># 在k2元素后 插入ins_key1</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k5&quot;</span></span><br><span class="line">2) <span class="string">&quot;k4&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">4) <span class="string">&quot;ins_key1&quot;</span></span><br><span class="line">5) <span class="string">&quot;k1&quot;</span></span><br><span class="line">6) <span class="string">&quot;k3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LLEN mylist <span class="comment"># 查看mylist的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 3 <span class="comment"># 获取下标为3的元素</span></span><br><span class="line"><span class="string">&quot;ins_key1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 0</span><br><span class="line"><span class="string">&quot;k5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LSET mylist 3 k6 <span class="comment"># 将下标3的元素 set值为k6</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k5&quot;</span></span><br><span class="line">2) <span class="string">&quot;k4&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">4) <span class="string">&quot;k6&quot;</span></span><br><span class="line">5) <span class="string">&quot;k1&quot;</span></span><br><span class="line">6) <span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LPOP--RPOP--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPOP mylist <span class="comment"># 左侧(头部)弹出</span></span><br><span class="line"><span class="string">&quot;k5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP mylist <span class="comment"># 右侧(尾部)弹出</span></span><br><span class="line"><span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------RPOPLPUSH--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k4&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k6&quot;</span></span><br><span class="line">4) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH mylist newlist <span class="comment"># 将mylist的最后一个值(k1)弹出，加入到newlist的头部</span></span><br><span class="line"><span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE newlist 0 -1</span><br><span class="line">1) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k4&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k6&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LTRIM--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LTRIM mylist 0 1 <span class="comment"># 截取mylist中的 0~1部分</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k4&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2</span></span><br><span class="line">---------------------------LREM--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LREM mylist 3 k2 <span class="comment"># 从头部开始搜索 至多删除3个 k2</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment"># 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LREM mylist -2 k2 <span class="comment">#从尾部开始搜索 至多删除2个 k2</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># 删除后：mylist: k2,k2,k2,k4,k2,k2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------BLPOP--BRPOP--------------------------</span><br><span class="line"></span><br><span class="line">mylist: k2,k2,k2,k4,k2,k2</span><br><span class="line">newlist: k1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30 <span class="comment"># 从newlist中弹出第一个值，mylist作为候选</span></span><br><span class="line">1) <span class="string">&quot;newlist&quot;</span> <span class="comment"># 弹出</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30</span><br><span class="line">1) <span class="string">&quot;mylist&quot;</span> <span class="comment"># 由于newlist空了 从mylist中弹出</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30</span><br><span class="line">(30.10s) <span class="comment"># 超时了</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30 <span class="comment"># 我们连接另一个客户端向newlist中push了test, 阻塞被解决。</span></span><br><span class="line">1) <span class="string">&quot;newlist&quot;</span></span><br><span class="line">2) <span class="string">&quot;test&quot;</span></span><br><span class="line">(12.54s)</span><br></pre></td></tr></table></figure>
<p>小结：</p>
<ul>
<li>list实际上是一个链表，before Node after , left, right 都可以插入值</li>
<li>如果key不存在，则创建新的链表</li>
<li>如果key存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在</li>
<li>在两边插入或者改动值，效率最高！修改中间元素，效率相对较低</li>
</ul>
<p>应用：</p>
<ul>
<li>消息排队</li>
<li>消息队列（Lpush Rpop）</li>
<li>栈（Lpush Lpop）</li>
</ul>
<h3 id="set集合"><a class="markdownIt-Anchor" href="#set集合"></a> Set(集合)</h3>
<p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)，集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SADD key member1[member2..]</code></td>
<td>向集合中无序增加一个/多个成员</td>
</tr>
<tr>
<td><code>SCARD key</code></td>
<td>获取集合的成员数</td>
</tr>
<tr>
<td><code>SMEMBERS key</code></td>
<td>返回集合中所有的成员</td>
</tr>
<tr>
<td><code>SISMEMBER key member</code></td>
<td>查询member元素是否是集合的成员,结果是无序的</td>
</tr>
<tr>
<td><code>SRANDMEMBER key [count]</code></td>
<td>随机返回集合中count个成员，count缺省值为1</td>
</tr>
<tr>
<td><code>SPOP key [count]</code></td>
<td>随机移除并返回集合中count个成员，count缺省值为1</td>
</tr>
<tr>
<td><code>SMOVE source destination member</code></td>
<td>将source集合的成员member移动到destination集合</td>
</tr>
<tr>
<td><code>SREM key member1[member2..]</code></td>
<td>移除集合中一个/多个成员</td>
</tr>
<tr>
<td><code>SDIFF key1[key2..]</code></td>
<td>返回所有集合的差集 key1- key2 - …</td>
</tr>
<tr>
<td><code>SDIFFSTORE destination key1[key2..]</code></td>
<td>在SDIFF的基础上，将结果保存到集合中(覆盖)。不能保存到其他类型key噢！</td>
</tr>
<tr>
<td><code>SINTER key1 [key2..]</code></td>
<td>返回所有集合的交集</td>
</tr>
<tr>
<td><code>SINTERSTORE destination key1[key2..]</code></td>
<td>在SINTER的基础上，存储结果到集合中。覆盖</td>
</tr>
<tr>
<td><code>SUNION key1 [key2..]</code></td>
<td>返回所有集合的并集</td>
</tr>
<tr>
<td><code>SUNIONSTORE destination key1 [key2..]</code></td>
<td>在SUNION的基础上，存储结果到及和张。覆盖</td>
</tr>
<tr>
<td><code>SSCAN KEY [MATCH pattern] [COUNT count]</code></td>
<td>在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---------------SADD--SCARD--SMEMBERS--SISMEMBER--------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SADD myset m1 m2 m3 m4 <span class="comment"># 向myset中增加成员 m1~m4</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; SCARD myset <span class="comment"># 获取集合的成员数目</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers myset <span class="comment"># 获取集合中所有成员</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">4) <span class="string">&quot;m1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m5 <span class="comment"># 查询m5是否是myset的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不是，返回0</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m2</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 是，返回1</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">---------------------SRANDMEMBER--SPOP----------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 3 <span class="comment"># 随机返回3个成员</span></span><br><span class="line">1) <span class="string">&quot;m2&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset <span class="comment"># 随机返回1个成员</span></span><br><span class="line"><span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SPOP myset 2 <span class="comment"># 随机移除并返回2个成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m4&quot;</span></span><br><span class="line"><span class="comment"># 将set还原到&#123;m1,m2,m3,m4&#125;</span></span><br><span class="line"></span><br><span class="line">---------------------SMOVE--SREM----------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SMOVE myset newset m3 <span class="comment"># 将myset中m3成员移动到newset集合</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m2&quot;</span></span><br><span class="line">3) <span class="string">&quot;m1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">1) <span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SREM newset m3 <span class="comment"># 从newset中移除m3元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算</span></span><br><span class="line"><span class="comment"># setx=&gt;&#123;m1,m2,m4,m6&#125;, sety=&gt;&#123;m2,m5,m6&#125;, setz=&gt;&#123;m1,m3,m6&#125;</span></span><br><span class="line"></span><br><span class="line">-----------------------------SDIFF------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety setz <span class="comment"># 等价于setx-sety-setz</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety <span class="comment"># setx - sety</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SDIFF sety setx <span class="comment"># sety - setx</span></span><br><span class="line">1) <span class="string">&quot;m5&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------SINTER---------------------------------------</span><br><span class="line"><span class="comment"># 共同关注（交集）</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety setz <span class="comment"># 求 setx、sety、setx的交集</span></span><br><span class="line">1) <span class="string">&quot;m6&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety <span class="comment"># 求setx sety的交集</span></span><br><span class="line">1) <span class="string">&quot;m2&quot;</span></span><br><span class="line">2) <span class="string">&quot;m6&quot;</span></span><br><span class="line"></span><br><span class="line">-------------------------SUNION---------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety setz <span class="comment"># setx sety setz的并集</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m6&quot;</span></span><br><span class="line">3) <span class="string">&quot;m3&quot;</span></span><br><span class="line">4) <span class="string">&quot;m2&quot;</span></span><br><span class="line">5) <span class="string">&quot;m1&quot;</span></span><br><span class="line">6) <span class="string">&quot;m5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety <span class="comment"># setx sety 并集</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m6&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">4) <span class="string">&quot;m1&quot;</span></span><br><span class="line">5) <span class="string">&quot;m5&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="hash哈希"><a class="markdownIt-Anchor" href="#hash哈希"></a> Hash（哈希）</h3>
<p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象，Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HSET key field value</code></td>
<td>将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0</td>
</tr>
<tr>
<td><code>HMSET key field1 value1 [field2 value2..]</code></td>
<td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>
<tr>
<td><code>HSETNX key field value</code></td>
<td>只有在字段 field 不存在时，设置哈希表字段的值。</td>
</tr>
<tr>
<td><code>HEXISTS key field</code></td>
<td>查看哈希表 key 中，指定的字段是否存在。</td>
</tr>
<tr>
<td><code>HGET key field value</code></td>
<td>获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td><code>HMGET key field1 [field2..]</code></td>
<td>获取所有给定字段的值</td>
</tr>
<tr>
<td><code>HGETALL key</code></td>
<td>获取在哈希表key 的所有字段和值</td>
</tr>
<tr>
<td><code>HKEYS key</code></td>
<td>获取哈希表key中所有的字段</td>
</tr>
<tr>
<td><code>HLEN key</code></td>
<td>获取哈希表中字段的数量</td>
</tr>
<tr>
<td><code>HVALS key</code></td>
<td>获取哈希表中所有值</td>
</tr>
<tr>
<td><code>HDEL key field1 [field2..]</code></td>
<td>删除哈希表key中一个/多个field字段</td>
</tr>
<tr>
<td><code>HINCRBY key field n</code></td>
<td>为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段</td>
</tr>
<tr>
<td><code>HINCRBYFLOAT key field n</code></td>
<td>为哈希表 key 中的指定字段的浮点数值加上增量 n。</td>
</tr>
<tr>
<td><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code></td>
<td>迭代哈希表中的键值对。</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">------------------------HSET--HMSET--HSETNX----------------</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name sakura <span class="comment"># 将studentx哈希表作为一个对象，设置name为sakura</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name gyc <span class="comment"># 重复设置field进行覆盖，并返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx age 20 <span class="comment"># 设置studentx的age为20</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HMSET studentx sex 1 tel 15623667886 <span class="comment"># 设置sex为1，tel为15623667886</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx name gyc <span class="comment"># HSETNX 设置已存在的field</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 失败</span></span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx email 12345@qq.com</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 成功</span></span><br><span class="line"></span><br><span class="line">----------------------HEXISTS--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx name <span class="comment"># name字段在studentx中是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 存在</span></span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx addr</span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不存在</span></span><br><span class="line"></span><br><span class="line">-------------------HGET--HMGET--HGETALL-----------</span><br><span class="line">127.0.0.1:6379&gt; HGET studentx name <span class="comment"># 获取studentx中name字段的value</span></span><br><span class="line"><span class="string">&quot;gyc&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HMGET studentx name age tel <span class="comment"># 获取studentx中name、age、tel字段的value</span></span><br><span class="line">1) <span class="string">&quot;gyc&quot;</span></span><br><span class="line">2) <span class="string">&quot;20&quot;</span></span><br><span class="line">3) <span class="string">&quot;15623667886&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HGETALL studentx <span class="comment"># 获取studentx中所有的field及其value</span></span><br><span class="line"> 1) <span class="string">&quot;name&quot;</span></span><br><span class="line"> 2) <span class="string">&quot;gyc&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;age&quot;</span></span><br><span class="line"> 4) <span class="string">&quot;20&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;sex&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;1&quot;</span></span><br><span class="line"> 7) <span class="string">&quot;tel&quot;</span></span><br><span class="line"> 8) <span class="string">&quot;15623667886&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;email&quot;</span></span><br><span class="line">10) <span class="string">&quot;12345@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------HKEYS--HLEN--HVALS--------------</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx <span class="comment"># 查看studentx中所有的field</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">3) <span class="string">&quot;sex&quot;</span></span><br><span class="line">4) <span class="string">&quot;tel&quot;</span></span><br><span class="line">5) <span class="string">&quot;email&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HLEN studentx <span class="comment"># 查看studentx中的字段数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; HVALS studentx <span class="comment"># 查看studentx中所有的value</span></span><br><span class="line">1) <span class="string">&quot;gyc&quot;</span></span><br><span class="line">2) <span class="string">&quot;20&quot;</span></span><br><span class="line">3) <span class="string">&quot;1&quot;</span></span><br><span class="line">4) <span class="string">&quot;15623667886&quot;</span></span><br><span class="line">5) <span class="string">&quot;12345@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line">-------------------------HDEL--------------------------</span><br><span class="line">127.0.0.1:6379&gt; HDEL studentx sex tel <span class="comment"># 删除studentx 中的sex、tel字段</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">3) <span class="string">&quot;email&quot;</span></span><br><span class="line"></span><br><span class="line">-------------HINCRBY--HINCRBYFLOAT------------------------</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx age 1 <span class="comment"># studentx的age字段数值+1</span></span><br><span class="line">(<span class="built_in">integer</span>) 21</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx name 1 <span class="comment"># 非整数字型字段不可用</span></span><br><span class="line">(error) ERR <span class="built_in">hash</span> value is not an <span class="built_in">integer</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBYFLOAT studentx weight 0.6 <span class="comment"># weight字段增加0.6</span></span><br><span class="line"><span class="string">&quot;90.8&quot;</span></span><br></pre></td></tr></table></figure>
<p>Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！Hash更适合于对象的存储，Sring更加适合字符串存储！</p>
<h3 id="zset有序集合"><a class="markdownIt-Anchor" href="#zset有序集合"></a> Zset（有序集合）</h3>
<p>不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。score相同：按字典顺序排序，有序集合的成员是唯一的，但分数(score)却可以重复。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ZADD key score member1 [score2 member2]</code></td>
<td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td><code>ZCARD key</code></td>
<td>获取有序集合的成员数</td>
</tr>
<tr>
<td><code>ZCOUNT key min max</code></td>
<td>计算在有序集合中指定区间score的成员数</td>
</tr>
<tr>
<td><code>ZINCRBY key n member</code></td>
<td>有序集合中对指定成员的分数加上增量 n</td>
</tr>
<tr>
<td><code>ZSCORE key member</code></td>
<td>返回有序集中，成员的分数值</td>
</tr>
<tr>
<td><code>ZRANK key member</code></td>
<td>返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td><code>ZRANGE key start end</code></td>
<td>通过索引区间返回有序集合成指定区间内的成员</td>
</tr>
<tr>
<td><code>ZRANGEBYLEX key min max</code></td>
<td>通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td><code>ZRANGEBYSCORE key min max</code></td>
<td>通过分数返回有序集合指定区间内的成员-inf 和 +inf分别表示最小最大值，只支持开区间()</td>
</tr>
<tr>
<td><code>ZLEXCOUNT key min max</code></td>
<td>在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td><code>ZREM key member1 [member2..]</code></td>
<td>移除有序集合中一个/多个成员</td>
</tr>
<tr>
<td><code>ZREMRANGEBYLEX key min max</code></td>
<td>移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td><code>ZREMRANGEBYRANK key start stop</code></td>
<td>移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td><code>ZREMRANGEBYSCORE key min max</code></td>
<td>移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td><code>ZREVRANGE key start end</code></td>
<td>返回有序集中指定区间内的成员，通过索引，分数从高到底</td>
</tr>
<tr>
<td><code>ZREVRANGEBYSCORRE key max min</code></td>
<td>返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td><code>ZREVRANGEBYLEX key max min</code></td>
<td>返回有序集中指定字典区间内的成员，按字典顺序倒序</td>
</tr>
<tr>
<td><code>ZREVRANK key member</code></td>
<td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td><code>ZINTERSTORE destination numkeys key1 [key2 ..]</code></td>
<td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score</td>
</tr>
<tr>
<td><code>ZUNIONSTORE destination numkeys key1 [key2..]</code></td>
<td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
</tr>
<tr>
<td><code>ZSCAN key cursor [MATCH pattern\] [COUNT count]</code></td>
<td>迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-------------------ZADD--ZCARD--ZCOUNT--------------</span><br><span class="line">127.0.0.1:6379&gt; ZADD myzset 1 m1 2 m2 3 m3 <span class="comment"># 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2..</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCARD myzset <span class="comment"># 获取有序集合的成员数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 1 <span class="comment"># 获取score在 [0,1]区间的成员数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">----------------ZINCRBY--ZSCORE--------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINCRBY myzset 5 m2 <span class="comment"># 将成员m2的score +5</span></span><br><span class="line"><span class="string">&quot;7&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m1 <span class="comment"># 获取成员m1的score</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m2</span><br><span class="line"><span class="string">&quot;7&quot;</span></span><br><span class="line"></span><br><span class="line">--------------ZRANK--ZRANGE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m1 <span class="comment"># 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 1 <span class="comment"># 获取索引在 0~1的成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 -1 <span class="comment"># 获取全部成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#testset=&gt;&#123;abc,add,amaze,apple,back,java,redis&#125; score均为0</span></span><br><span class="line">------------------ZRANGEBYLEX---------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + <span class="comment"># 返回所有成员</span></span><br><span class="line">1) <span class="string">&quot;abc&quot;</span></span><br><span class="line">2) <span class="string">&quot;add&quot;</span></span><br><span class="line">3) <span class="string">&quot;amaze&quot;</span></span><br><span class="line">4) <span class="string">&quot;apple&quot;</span></span><br><span class="line">5) <span class="string">&quot;back&quot;</span></span><br><span class="line">6) <span class="string">&quot;java&quot;</span></span><br><span class="line">7) <span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 0 3 <span class="comment"># 分页 按索引显示查询结果的 0,1,2条记录</span></span><br><span class="line">1) <span class="string">&quot;abc&quot;</span></span><br><span class="line">2) <span class="string">&quot;add&quot;</span></span><br><span class="line">3) <span class="string">&quot;amaze&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 3 3 <span class="comment"># 显示 3,4,5条记录</span></span><br><span class="line">1) <span class="string">&quot;apple&quot;</span></span><br><span class="line">2) <span class="string">&quot;back&quot;</span></span><br><span class="line">3) <span class="string">&quot;java&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset (- [apple <span class="comment"># 显示 (-,apple] 区间内的成员</span></span><br><span class="line">1) <span class="string">&quot;abc&quot;</span></span><br><span class="line">2) <span class="string">&quot;add&quot;</span></span><br><span class="line">3) <span class="string">&quot;amaze&quot;</span></span><br><span class="line">4) <span class="string">&quot;apple&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset [apple [java <span class="comment"># 显示 [apple,java]字典区间的成员</span></span><br><span class="line">1) <span class="string">&quot;apple&quot;</span></span><br><span class="line">2) <span class="string">&quot;back&quot;</span></span><br><span class="line">3) <span class="string">&quot;java&quot;</span></span><br><span class="line"></span><br><span class="line">-----------------------ZRANGEBYSCORE---------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 10 <span class="comment"># 返回score在 [1,10]之间的的成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 5</span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line"></span><br><span class="line">--------------------ZLEXCOUNT-----------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset - +</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset [apple [java</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREM testset abc <span class="comment"># 移除成员abc</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYLEX testset [apple [java <span class="comment"># 移除字典区间[apple,java]中的所有成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK testset 0 1 <span class="comment"># 移除排名0~1的所有成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYSCORE myzset 0 3 <span class="comment"># 移除score在 [0,3]的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># testset=&gt; &#123;abc,add,apple,amaze,back,java,redis&#125; score均为0</span></span><br><span class="line"><span class="comment"># myzset=&gt; &#123;(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)&#125;</span></span><br><span class="line">----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX-----------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 0 3 <span class="comment"># 按score递减排序，然后按索引，返回结果的 0~3</span></span><br><span class="line">1) <span class="string">&quot;m9&quot;</span></span><br><span class="line">2) <span class="string">&quot;m7&quot;</span></span><br><span class="line">3) <span class="string">&quot;m4&quot;</span></span><br><span class="line">4) <span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 2 4 <span class="comment"># 返回排序结果的 索引的2~4</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE myzset 6 2 <span class="comment"># 按score递减顺序 返回集合中分数在[2,6]之间的成员</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYLEX testset [java (add <span class="comment"># 按字典倒序 返回集合中(add,java]字典区间的成员</span></span><br><span class="line">1) <span class="string">&quot;java&quot;</span></span><br><span class="line">2) <span class="string">&quot;back&quot;</span></span><br><span class="line">3) <span class="string">&quot;apple&quot;</span></span><br><span class="line">4) <span class="string">&quot;amaze&quot;</span></span><br><span class="line"></span><br><span class="line">-------------------------ZREVRANK------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m7 <span class="comment"># 按score递减顺序，返回成员m7索引</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m2</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mathscore=&gt;&#123;(xm,90),(xh,95),(xg,87)&#125; 小明、小红、小刚的数学成绩</span></span><br><span class="line"><span class="comment"># enscore=&gt;&#123;(xm,70),(xh,93),(xg,90)&#125; 小明、小红、小刚的英语成绩</span></span><br><span class="line">-------------------ZINTERSTORE--ZUNIONSTORE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINTERSTORE sumscore 2 mathscore enscore <span class="comment"># 将mathscore enscore进行合并 结果存放到sumscore</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sumscore 0 -1 withscores <span class="comment"># 合并后的score是之前集合中所有score的和</span></span><br><span class="line">1) <span class="string">&quot;xm&quot;</span></span><br><span class="line">2) <span class="string">&quot;160&quot;</span></span><br><span class="line">3) <span class="string">&quot;xg&quot;</span></span><br><span class="line">4) <span class="string">&quot;177&quot;</span></span><br><span class="line">5) <span class="string">&quot;xh&quot;</span></span><br><span class="line">6) <span class="string">&quot;188&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZUNIONSTORE lowestscore 2 mathscore enscore AGGREGATE MIN <span class="comment"># 取两个集合的成员score最小值作为结果的</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE lowestscore 0 -1 withscores</span><br><span class="line">1) <span class="string">&quot;xm&quot;</span></span><br><span class="line">2) <span class="string">&quot;70&quot;</span></span><br><span class="line">3) <span class="string">&quot;xg&quot;</span></span><br><span class="line">4) <span class="string">&quot;87&quot;</span></span><br><span class="line">5) <span class="string">&quot;xh&quot;</span></span><br><span class="line">6) <span class="string">&quot;93&quot;</span></span><br></pre></td></tr></table></figure>
<p>应用案例：</p>
<ul>
<li>set排序 存储班级成绩表 工资表排序！</li>
<li>普通消息，1.重要消息 2.带权重进行判断</li>
<li>排行榜应用实现，取Top N测试</li>
</ul>
<h2 id="三种特殊数据类型"><a class="markdownIt-Anchor" href="#三种特殊数据类型"></a> 三种特殊数据类型</h2>
<h3 id="geospatial地理位置"><a class="markdownIt-Anchor" href="#geospatial地理位置"></a> Geospatial(地理位置)</h3>
<p>使用经纬度定位地理坐标并用一个有序集合zset保存，所以zset命令也可以使用。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>geoadd key longitud(经度) latitude(纬度) member [..]</code></td>
<td>将具体经纬度的坐标存入一个有序集合</td>
</tr>
<tr>
<td><code>geopos key member [member..]</code></td>
<td>获取集合中的一个/多个成员坐标</td>
</tr>
<tr>
<td><code>geodist key member1 member2 [unit]</code></td>
<td>返回两个给定位置之间的距离。默认以米作为单位。</td>
</tr>
<tr>
<td><code>georadius key longitude latitude radius m|km|mi|ft [WITHCOORD][WITHDIST] [WITHHASH] [COUNT count]</code></td>
<td>以给定的经纬度为中心， 返回集合包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</td>
</tr>
<tr>
<td><code>GEORADIUSBYMEMBER key member radius...</code></td>
<td>功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。</td>
</tr>
<tr>
<td><code>geohash key member1 [member2..]</code></td>
<td>返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。</td>
</tr>
</tbody>
</table>
<p>有效经纬度</p>
<blockquote>
<ul>
<li>有效的经度从-180度到180度。</li>
<li>有效的纬度从-85.05112878度到85.05112878度。</li>
</ul>
</blockquote>
<p>指定单位的参数 <strong>unit</strong> 必须是以下单位的其中一个：</p>
<ul>
<li><strong>m</strong> 表示单位为米。</li>
<li><strong>km</strong> 表示单位为千米。</li>
<li><strong>mi</strong> 表示单位为英里。</li>
<li><strong>ft</strong> 表示单位为英尺。</li>
</ul>
<p>关于GEORADIUS的参数</p>
<blockquote>
<p>通过<code>georadius</code>就可以完成 附近的人功能</p>
<p>withcoord:带上坐标</p>
<p>withdist:带上距离，单位与半径单位相同</p>
<p>COUNT n : 只显示前n个(按距离递增排序)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">----------------georadius---------------------</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 120 30 500 km withcoord withdist <span class="comment"># 查询经纬度(120,30)坐标500km半径内的成员</span></span><br><span class="line">1) 1) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">   2) <span class="string">&quot;29.4151&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;120.20000249147415&quot;</span></span><br><span class="line">      2) <span class="string">&quot;30.199999888333501&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">   2) <span class="string">&quot;205.3611&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;121.40000134706497&quot;</span></span><br><span class="line">      2) <span class="string">&quot;31.400000253193539&quot;</span></span><br><span class="line">     </span><br><span class="line">------------geohash---------------------------</span><br><span class="line">127.0.0.1:6379&gt; geohash china:city yichang shanghai <span class="comment"># 获取成员经纬坐标的geohash表示</span></span><br><span class="line">1) <span class="string">&quot;wmrjwbr5250&quot;</span></span><br><span class="line">2) <span class="string">&quot;wtw6ds0y300&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="hyperloglog基数统计"><a class="markdownIt-Anchor" href="#hyperloglog基数统计"></a> Hyperloglog(基数统计)</h3>
<p>Redis HyperLogLog 是用来做基数（数据集中不重复的元素的个数）统计的数据结构，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p>
<p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>应用场景：网页的访问量（UV），一个用户多次访问，也只能算作一个人。</p>
<blockquote>
<p>传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是计数，Hyperloglog就能帮助我们利用最小的空间完成。</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PFADD key element1 [elememt2..]</code></td>
<td>添加指定元素到 HyperLogLog 中</td>
</tr>
<tr>
<td><code>PFCOUNT key [key]</code></td>
<td>返回给定 HyperLogLog 的基数估算值。</td>
</tr>
<tr>
<td><code>PFMERGE destkey sourcekey [sourcekey..]</code></td>
<td>将多个 HyperLogLog 合并为一个 HyperLogLog</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">----------PFADD--PFCOUNT---------------------</span><br><span class="line">127.0.0.1:6379&gt; PFADD myelemx a b c d e f g h i j k <span class="comment"># 添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> myelemx <span class="comment"># hyperloglog底层使用String</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemx <span class="comment"># 估算myelemx的基数</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; PFADD myelemy i j k z m c b v p q s</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemy</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line"></span><br><span class="line">----------------PFMERGE-----------------------</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE myelemz myelemx myelemy <span class="comment"># 合并myelemx和myelemy 成为myelemz</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemz <span class="comment"># 估算基数</span></span><br><span class="line">(<span class="built_in">integer</span>) 17</span><br></pre></td></tr></table></figure>
<p>如果允许容错，那么一定可以使用Hyperloglog !</p>
<p>如果不允许容错，就使用set或者自己的数据类型即可 ！</p>
<h3 id="bitmaps位图"><a class="markdownIt-Anchor" href="#bitmaps位图"></a> BitMaps(位图)</h3>
<p>使用位存储，信息状态只有 0 和 1，Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p>
<p>应用场景：签到统计、状态统计</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>setbit key offset value</code></td>
<td>为指定key的offset位设置值</td>
</tr>
<tr>
<td><code>getbit key offset</code></td>
<td>获取offset位的值</td>
</tr>
<tr>
<td><code>bitcount key [start end]</code></td>
<td>统计字符串被设置为1的bit数，也可以指定统计范围按字节</td>
</tr>
<tr>
<td><code>bitop operration destkey key[key..]</code></td>
<td>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</td>
</tr>
<tr>
<td><code>BITPOS key bit [start] [end]</code></td>
<td>返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">------------setbit--getbit--------------</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 0 1 <span class="comment"># 设置sign的第0位为 1 </span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 1 <span class="comment"># 设置sign的第2位为 1  不设置默认 是0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> sign</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getbit sign 2 <span class="comment"># 获取第2位的数值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 4 <span class="comment"># 未设置默认是0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">-----------bitcount----------------------------</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT sign <span class="comment"># 统计sign中为1的位数</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure>
<p>这样设置以后你能get到的值是：\xA2\x80，所以bitmaps是一串从左到右的二进制串</p>
<h1 id="redis事务"><a class="markdownIt-Anchor" href="#redis事务"></a> Redis事务</h1>
<p>Redis的事务就是指一组命令的集合，Redis的单条命令是保证原子性的，但是redis事务不能保证原子性，并且Redis事务没有隔离级别的概念。</p>
<p>事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。</p>
<ul>
<li>一次性</li>
<li>顺序性</li>
<li>排他性</li>
</ul>
<h2 id="操作过程"><a class="markdownIt-Anchor" href="#操作过程"></a> 操作过程</h2>
<ul>
<li>开启事务（<code>multi</code>）</li>
<li>命令入队</li>
<li>执行事务（<code>exec</code>）</li>
</ul>
<p>所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1 <span class="comment"># 命令入队</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2 <span class="comment"># ..</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 事务执行</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v1&quot;</span></span><br><span class="line">4) OK</span><br><span class="line">5) 1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">   2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">   3) <span class="string">&quot;k1&quot;</span></span><br></pre></td></tr></table></figure>
<p>取消事务(discurd)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD <span class="comment"># 放弃事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXEC </span><br><span class="line">(error) ERR EXEC without MULTI <span class="comment"># 当前未开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; get k1 <span class="comment"># 被放弃事务中命令并未执行</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h2 id="事务错误"><a class="markdownIt-Anchor" href="#事务错误"></a> 事务错误</h2>
<p>代码语法错误（编译时异常）所有的命令都不执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; error k1 <span class="comment"># 这是一条语法错误命令</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `error`, with args beginning with: `k1`, <span class="comment"># 会报错但是不影响后续命令入队 </span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors. <span class="comment"># 执行报错</span></span><br><span class="line">127.0.0.1:6379&gt; get k1 </span><br><span class="line">(nil) <span class="comment"># 其他命令并没有被执行</span></span><br></pre></td></tr></table></figure>
<p>当代码逻辑错误 (运行时异常) ，其他命令可以正常执行，因此说Redis所以不保证事务原子性：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCR k1 <span class="comment"># 这条命令逻辑错误（对字符串进行增量）</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range <span class="comment"># 运行时报错</span></span><br><span class="line">4) <span class="string">&quot;v2&quot;</span> <span class="comment"># 其他命令正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。</span></span><br><span class="line"><span class="comment"># 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。</span></span><br></pre></td></tr></table></figure>
<h2 id="监控"><a class="markdownIt-Anchor" href="#监控"></a> 监控</h2>
<p>使用<code>watch key</code>监控指定数据，相当于乐观锁加锁。</p>
<p>正常执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100 <span class="comment"># 设置余额:100</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> use 0 <span class="comment"># 支出使用:0</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视money (上锁)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 监视值没有被中途修改，事务正常执行</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure>
<p>测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion）：</p>
<p>我们启动另外一个客户端模拟插队线程。</p>
<p>线程1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># money上锁</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; 	<span class="comment"># 此时事务并没有执行</span></span><br></pre></td></tr></table></figure>
<p>模拟线程插队，线程2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBY money 500 <span class="comment"># 修改了线程一中监视的money</span></span><br><span class="line">(<span class="built_in">integer</span>) 600</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>回到线程1，执行事务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXEC <span class="comment"># 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败</span></span><br><span class="line">(nil) <span class="comment"># 没有结果，说明事务执行失败</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get money <span class="comment"># 线程2 修改生效</span></span><br><span class="line"><span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get use <span class="comment"># 线程1事务执行失败，数值没有被修改</span></span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure>
<p>解锁获取最新值，然后再加锁进行事务。<code>unwatch</code>进行解锁。注意：每次提交执行exec后都会自动释放锁，不管是否成功</p>
<h1 id="工具整合"><a class="markdownIt-Anchor" href="#工具整合"></a> 工具整合</h1>
<h2 id="jedis"><a class="markdownIt-Anchor" href="#jedis"></a> Jedis</h2>
<p>使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。</p>
<p>导入相关依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入jredis的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--fastjson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.70<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在做好Redis相关的配置并启动后就可以进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.xx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        String response = jedis.ping();</span><br><span class="line">        System.out.println(response); <span class="comment">// PONG</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;39.99.xxx.xx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;kuangshen&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        Transaction multi = jedis.multi();</span><br><span class="line">        String result = jsonObject.toJSONString();</span><br><span class="line">        <span class="comment">// jedis.watch(result)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">&quot;user1&quot;</span>, result);</span><br><span class="line">            multi.set(<span class="string">&quot;user2&quot;</span>, result);</span><br><span class="line">            <span class="comment">// 执行事务</span></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">// 放弃事务</span></span><br><span class="line">            multi.discard();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="springboot整合"><a class="markdownIt-Anchor" href="#springboot整合"></a> SpringBoot整合</h2>
<ol>
<li>导入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。</p>
<blockquote>
<p>jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式</p>
<p>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式</p>
</blockquote>
<p>我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214531573.png" alt="在这里插入图片描述" /></p>
<p>那么就一定还存在一个RedisProperties类</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214554661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>之前我们说SpringBoot2.x后默认使用Lettuce来替换Jedis，现在我们就能来验证了。</p>
<p>先看Jedis:</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214607475.png" alt="在这里插入图片描述" /></p>
<p>@ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的</p>
<p>然后再看Lettuce：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214618179.png" alt="在这里插入图片描述" /></p>
<p>完美生效。</p>
<p>现在我们回到RedisAutoConfiguration</p>
<p><img src="https://img-blog.csdnimg.cn/2020051321462777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img" /></p>
<p>只有两个简单的Bean</p>
<ul>
<li>RedisTemplate</li>
<li>StringRedisTemplate</li>
</ul>
<p>当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。</p>
<p>在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的</p>
<p>说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214638238.png" alt="在这里插入图片描述" /></p>
<p>这是一些基本的配置属性。</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214649380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>还有一些连接池相关的配置。注意使用时一定使用Lettuce的连接池。</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214700372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<ol>
<li>
<p>编写配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置redis</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">39.99.xxx.xx</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用RedisTemplate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis02SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span></span><br><span class="line">        <span class="comment">// opsForValue 操作字符串 类似String</span></span><br><span class="line">        <span class="comment">// opsForList 操作List 类似List</span></span><br><span class="line">        <span class="comment">// opsForHah</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接对象</span></span><br><span class="line">        <span class="comment">//RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span></span><br><span class="line">        <span class="comment">//connection.flushDb();</span></span><br><span class="line">        <span class="comment">//connection.flushAll();</span></span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;mykey&quot;</span>,<span class="string">&quot;kuangshen&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;mykey&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>测试结果</p>
<p>此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214734520.png" alt="在这里插入图片描述" /></p>
<p>这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。因此项目中通常需要修改RedisTemplate的序列化方式。</p>
</li>
<li>
<p>定制RedisTemplate的模板：</p>
<p>我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="comment">// 将template 泛型设置为 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        <span class="comment">// 连接工厂，不必修改</span></span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 序列化设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// key、hash的key 采用 String序列化方式</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// value、hash的value 采用 Jackson 序列化方式</span></span><br><span class="line">        template.setValueSerializer(RedisSerializer.json());</span><br><span class="line">        template.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，只要实体类进行了序列化，我们存什么都不会有乱码的担忧了。</p>
</li>
</ol>
<h2 id="自定义redis工具类"><a class="markdownIt-Anchor" href="#自定义redis工具类"></a> 自定义Redis工具类</h2>
<p>使用RedisTemplate需要频繁调用<code>.opForxxx</code>然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。</p>
<p>工具类参考博客：<a href="https://www.cnblogs.com/zhzhlong/p/11434284.html">java redisUtils工具类很全</a></p>
<h1 id="持久化策略"><a class="markdownIt-Anchor" href="#持久化策略"></a> 持久化策略</h1>
<p>Redis支持RDB和AOF两种持久化机制，持久化功能有效避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件即可实现数据恢复。</p>
<p>Redis持久化文件加载的流程：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210828174806.png" alt="Redis加载持久化文件" style="zoom:60%;" />
<h2 id="rdb持久化"><a class="markdownIt-Anchor" href="#rdb持久化"></a> RDB持久化</h2>
<h3 id="什么是rdb"><a class="markdownIt-Anchor" href="#什么是rdb"></a> 什么是RDB</h3>
<p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程可以分为手动触发和自动触发。默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p>
<h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3>
<p>RDB的手动触发分别对应save和bgsave命令：</p>
<ul>
<li>save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的示例会造成长时间则色，线上环境不建议使用。</li>
<li>bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</li>
</ul>
<p>显然bgsave命令是针对save阻塞问题做的优化。因此Redis内部所有的涉及RDB的操作都采用bgsave的方式，而save命令已经废弃，因此这里不做过多介绍。</p>
<p>RDB的自动触发只需要在配置文件redis.conf中开启相关配置即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存</span><br><span class="line">save 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存</span><br><span class="line">save 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存</span><br></pre></td></tr></table></figure>
<h4 id="bgsave"><a class="markdownIt-Anchor" href="#bgsave"></a> bgsave</h4>
<p>bgsave是异步进行，进行持久化的时候，Redis还可以将继续响应客户端请求 ；</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210828115659.png" alt="bgsave命令的运作方式" style="zoom:67%;" />
<p>详细具体步骤如下：</p>
<ul>
<li>执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB/AOF子进程，如果存在bgsave命令直接返回</li>
<li>父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通过<code>info stats</code>命令查看<code>latest_fork_usec</code>选项，可以获取最近一个fork操作的耗时，单位为微秒</li>
<li>父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令</li>
<li>父进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行<code>lastsave</code>命令可以获取最后一次生成RDB的时间，对应info统计的rdb_last_save_time选项</li>
<li>进程发送信号给父进程表示完成，父进程更新统计信息</li>
</ul>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求)。</p>
<h4 id="bgsave和save对比"><a class="markdownIt-Anchor" href="#bgsave和save对比"></a> bgsave和save对比</h4>
<table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody>
<tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞</td>
<td>是</td>
<td>是（阻塞发生在fock()，通常非常快）</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外的内存</td>
<td>不阻塞客户端命令</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端命令</td>
<td>需要fork子进程，消耗内存</td>
</tr>
</tbody>
</table>
<h3 id="优点和缺点"><a class="markdownIt-Anchor" href="#优点和缺点"></a> 优点和缺点</h3>
<p>优点：</p>
<ul>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性要求不高</li>
<li>Redis加载RDB恢复数据远远快于AOF的方式</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了</li>
<li>fork进程的时候，会占用一定的内存空间</li>
<li>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容RDB格式的问题</li>
</ul>
<div class="note info"><p>也可以简单的说，RDB不适合实时持久化。</p></div>
<h2 id="持久化aof"><a class="markdownIt-Anchor" href="#持久化aof"></a> 持久化AOF</h2>
<p>AOF表示Append Only File，这种模式会将所有的命令都记录下来，恢复的时候就把这个文件全部再执行一遍。</p>
<blockquote>
<p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
</blockquote>
<h3 id="什么是aof"><a class="markdownIt-Anchor" href="#什么是aof"></a> 什么是AOF</h3>
<p>快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210828174606.png" alt="image-20210828174605782" style="zoom:50%;" />
<p>AOF默认是不开启的，需要进行配置才可以：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly yes  <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always # 每次修改都会sync 消耗性能</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒执行一次 sync 可能会丢失这一秒的数据</span></span><br><span class="line"><span class="comment"># appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快</span></span><br></pre></td></tr></table></figure>
<h3 id="优点和缺点-2"><a class="markdownIt-Anchor" href="#优点和缺点-2"></a> 优点和缺点</h3>
<p>优点</p>
<ol>
<li>每一次修改都会同步，文件的完整性会更加好</li>
<li>没秒同步一次，可能会丢失一秒的数据</li>
<li>从不同步，效率最高</li>
</ol>
<p>缺点</p>
<ol>
<li>相对于数据文件来说，AOF远远大于RDB，修复速度比RDB慢</li>
<li>AOF运行效率也要比RDB慢，所以我们Redis默认的配置就是RDB持久化</li>
</ol>
<h2 id="rdb和aop选择"><a class="markdownIt-Anchor" href="#rdb和aop选择"></a> RDB和AOP选择</h2>
<h3 id="rdb-和-aof-对比"><a class="markdownIt-Anchor" href="#rdb-和-aof-对比"></a> RDB 和 AOF 对比</h3>
<table>
<thead>
<tr>
<th>比较项</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
</tbody>
</table>
<h3 id="如何选择使用哪种持久化方式"><a class="markdownIt-Anchor" href="#如何选择使用哪种持久化方式"></a> 如何选择使用哪种持久化方式？</h3>
<p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p>
<h1 id="redis发布与订阅"><a class="markdownIt-Anchor" href="#redis发布与订阅"></a> Redis发布与订阅</h1>
<p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215523258.png" alt="在这里插入图片描述" /></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="https://img-blog.csdnimg.cn/2020051321553483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<h2 id="命令"><a class="markdownIt-Anchor" href="#命令"></a> 命令</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PSUBSCRIBE pattern [pattern..]</code></td>
<td>订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td><code>PUNSUBSCRIBE pattern [pattern..]</code></td>
<td>退订一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td><code>PUBSUB subcommand [argument[argument]]</code></td>
<td>查看订阅与发布系统状态。</td>
</tr>
<tr>
<td><code>PUBLISH channel message</code></td>
<td>向指定频道发布消息</td>
</tr>
<tr>
<td><code>SUBSCRIBE channel [channel..]</code></td>
<td>订阅给定的一个或多个频道。</td>
</tr>
<tr>
<td><code>SUBSCRIBE channel [channel..]</code></td>
<td>退订一个或多个频道</td>
</tr>
</tbody>
</table>
<h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">------------订阅端----------------------</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE sakura <span class="comment"># 订阅sakura频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit) <span class="comment"># 等待接收消息</span></span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span> <span class="comment"># 订阅成功的消息</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 接收到来自sakura频道的消息 &quot;hello world&quot;</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello world&quot;</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 接收到来自sakura频道的消息 &quot;hello i am sakura&quot;</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello i am sakura&quot;</span></span><br><span class="line"></span><br><span class="line">--------------消息发布端-------------------</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH sakura <span class="string">&quot;hello world&quot;</span> <span class="comment"># 发布消息到sakura频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH sakura <span class="string">&quot;hello i am sakura&quot;</span> <span class="comment"># 发布消息</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">-----------------查看活跃的频道------------</span><br><span class="line">127.0.0.1:6379&gt; PUBSUB channels</span><br><span class="line">1) <span class="string">&quot;sakura&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p>
<p><img src="https://img-blog.csdnimg.cn/2020051321554964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p>
<h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2>
<ol>
<li>如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。</li>
<li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。</li>
</ol>
<h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2>
<ol>
<li>消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）</li>
<li>多人在线聊天室。</li>
</ol>
<p>稍微复杂的场景，我们就会使用消息中间件MQ处理。</p>
<h1 id="redis线程io模型"><a class="markdownIt-Anchor" href="#redis线程io模型"></a> Redis线程IO模型</h1>
<p>在从前的版本中，Redis是个单线程的程序，除了Redis之外，Node.js与Nginx也是单线程，但是它们都是高性能服务器的典范，不过从Redis6.0开始，增加了多线程的支持，以满足更高的性能，具体可以参考：<a href="https://stor.51cto.com/art/202005/616005.htm">支持多线程的Redis 6.0终于发布了</a>，那么Redis是如何使用单线程处理那么多的并发客户端连接的？答案就是多路复用。</p>
<h2 id="非阻塞io"><a class="markdownIt-Anchor" href="#非阻塞io"></a> 非阻塞IO</h2>
<p>当我们调用套节字的读写方法，默认它们是阻塞的，比如read方法要传递进去一个参数n，表示读取这么多字节后再返回，如果没有读够线程就会卡在那里，直到新的数据刀来或者连接关闭了，read方法才会返回，线程才能继续处理。而write方法一般来说不会阻塞，除非内核为套接字分配的写缓冲区已经满了，write方法就会阻塞，直到缓存区中有空闲空间挪出来了。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210827184844.png" alt="非阻塞IO示意图" style="zoom:87%;" />
<p>非阻塞IO在套接字对象上提供了一个线程<code>Non_Blocking</code>，当这个选项打开时，读写方法不会阻塞，而是能读多少读多少，能写多少写多少。能读多少取决于内核为套接字分配的读缓冲区内部的数据字节数，能写多少取决于内核为套接字分配的写缓冲区的空闲空间字节数。读方法和写方法都会通过返回值来告知程序实际读写了多少字节。</p>
<p>有了非阻塞IO意味着线程在读写IO时可以不必再阻塞了，读写可以瞬间完成然后程序可以继续干别的事了。</p>
<h2 id="多路复用"><a class="markdownIt-Anchor" href="#多路复用"></a> 多路复用</h2>
<p>非阻塞IO有个问题，那就是线程要读数据，结果读了一部分就返回了，线程如何知道何时才应该继续。也就是当数据到来时，线程如何得到通知。写也是一样，如果缓冲区满了，写不完，剩下的数据何时才应该续写，线程也应该得到通知。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210827185654.png" alt="事件轮询API示意图" style="zoom:67%;" />
<p>多路复用（事件轮询）API就是用来解决这个问题的，最简单的事件轮询API是select函数，它是操作系统提供给用户程序的API。输入是读写描述符列表read_fds &amp; write_fds，输出是与之对应的可读可写事件。同时还提供了timeout参数，如果没有任何事件到来，那么久最多等待timeout时间，线程处于阻塞状态。一旦期间有任何事情刀来，就可以立即返回。时间过了之后还是没有任何事件到来，也会立即返回。拿到事件后，线程就可以继续挨个处理相应的事件。处理完了继续过来轮询。于是线程就进入了一个死循环，我们把这个死循环称为事件循环，一个循环为一个周期。</p>
<p>每个客户端套接字socket都有对应的读写文件描述符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">read_events,write_events = select(read_fds,write_fds,timeout)</span><br><span class="line"><span class="keyword">for</span> event <span class="keyword">in</span> read_events:</span><br><span class="line">	handle_read(event.fd)</span><br><span class="line"><span class="keyword">for</span> event <span class="keyword">in</span> write_events:</span><br><span class="line">    handle_write(event.fd)</span><br><span class="line"><span class="comment"># 处理其它事情，如定时任务等</span></span><br><span class="line">handle_others()</span><br></pre></td></tr></table></figure>
<p>因为我们通过select系统调用同时处理多个通道描述符的读写事件，因此我们将这类系统调用称为多路复用API。现代操作系统的多路复用API已经不再使用使用select系统调用，而改用epoll(linux)和kqueue(freebsd &amp; macosx)，因为select系统调用的性能再描述符特别多时性能会非常差。它使用起来可能在形式上略有差异，但是本质上都是差不多的，都可以使用上面的伪代码逻辑进行理解。</p>
<h2 id="指令队列"><a class="markdownIt-Anchor" href="#指令队列"></a> 指令队列</h2>
<p>Redis会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务。</p>
<h2 id="响应队列"><a class="markdownIt-Anchor" href="#响应队列"></a> 响应队列</h2>
<p>Redis同样会为每个客户端套接字关联一个响应队列。Redis服务器通过响应队列来将指令的返回结果回复给客户端。如果队列为空，那么意味着连接暂时处于空闲状态，不需要去获取写事件，也就是可以将当前的客户端描述符<code>write_fds</code>里面移出来。等到队列有数据了，再将描述符放进去。避免select系统调用立即返回写事件，结果发现没什么数据可以写。出现这种情况的线程会飙高CPU。</p>
<h1 id="redis主从复制"><a class="markdownIt-Anchor" href="#redis主从复制"></a> Redis主从复制</h1>
<h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2>
<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p>
<p>默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p>
<h2 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h2>
<ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li>
<li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li>
<li>高可用基石：主从复制还是哨兵和集群能够实施的基础。</li>
</ol>
<h2 id="为什么使用集群"><a class="markdownIt-Anchor" href="#为什么使用集群"></a> 为什么使用集群</h2>
<ol>
<li>单台服务器难以负载大量的请求</li>
<li>单台服务器故障率高，系统崩坏概率大</li>
<li>单台服务器内存容量有限。</li>
</ol>
<h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h2>
<p>我们在讲解配置文件的时候，注意到有一个<code>replication</code>模块 (见Redis.conf中第8条)</p>
<p>查看当前库的信息：<code>info replication</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment"># 角色</span></span><br><span class="line">connected_slaves:0 <span class="comment"># 从机数量</span></span><br><span class="line">master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>
<p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：</p>
<ul>
<li>端口号</li>
<li>pid文件名</li>
<li>日志文件名</li>
<li>rdb文件名</li>
</ul>
<p>启动单机多服务集群：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215610163.png" alt="在这里插入图片描述" /></p>
<h2 id="一主二从配置"><a class="markdownIt-Anchor" href="#一主二从配置"></a> 一主二从配置</h2>
<p>默认情况下，每台Redis服务器都是主节点；我们一般情况下只用配置从机就好了！</p>
<p>认老大！一主（79）二从（80，81）</p>
<p>使用<code>SLAVEOF host port</code>就可以为从机配置主机了。</p>
<img src="https://img-blog.csdnimg.cn/20200513215637483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />
<p>然后主机上也能看到从机的状态：</p>
<img src="https://img-blog.csdnimg.cn/20200513215645778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />
<p>我们这里是使用命令搭建，是暂时的，==真实开发中应该在从机的配置文件中进行配置，==这样的话是永久的。</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215654634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<h2 id="使用规则"><a class="markdownIt-Anchor" href="#使用规则"></a> 使用规则</h2>
<ol>
<li>
<p>从机只能读，不能写，主机可读可写但是多用于写。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> 127.0.0.1:6381&gt; <span class="built_in">set</span> name sakura <span class="comment"># 从机6381写入失败</span></span><br><span class="line">(error) READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">127.0.0.1:6380&gt; set name sakura # 从机6380写入失败</span></span><br><span class="line"><span class="string">(error) READONLY You can&#x27;</span>t write against a <span class="built_in">read</span> only replica.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name sakura</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;sakura&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p>
</li>
<li>
<p>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p>
</li>
<li>
<p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p>
<ul>
<li>从机手动执行命令<code>slaveof no one</code>,这样执行以后从机会独立出来成为一个主机</li>
<li>使用哨兵模式（自动选举）</li>
</ul>
</li>
</ol>
<blockquote>
<p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p>
</blockquote>
<p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！</p>
<h2 id="复制原理"><a class="markdownIt-Anchor" href="#复制原理"></a> 复制原理</h2>
<h3 id="复制过程"><a class="markdownIt-Anchor" href="#复制过程"></a> 复制过程</h3>
<h3 id="数据同步"><a class="markdownIt-Anchor" href="#数据同步"></a> 数据同步</h3>
<h3 id="全量复制"><a class="markdownIt-Anchor" href="#全量复制"></a> 全量复制</h3>
<h3 id="部分复制"><a class="markdownIt-Anchor" href="#部分复制"></a> 部分复制</h3>
<h3 id="心跳"><a class="markdownIt-Anchor" href="#心跳"></a> 心跳</h3>
<h3 id="异步复制"><a class="markdownIt-Anchor" href="#异步复制"></a> 异步复制</h3>
<p>主节点不但负责数据读写，还负责把写命令同步给从节点。写命令的发送过程是异步完成的，也就是说主节点自身处理完写命令后直接返回给客户端，并不等待从节点复制完成，如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210828172159.png" alt="image-20210828172159313" style="zoom:50%;" />
<h1 id="哨兵模式"><a class="markdownIt-Anchor" href="#哨兵模式"></a> 哨兵模式</h1>
<h2 id="作用-2"><a class="markdownIt-Anchor" href="#作用-2"></a> 作用</h2>
<p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。</p>
<h2 id="单机单个哨兵"><a class="markdownIt-Anchor" href="#单机单个哨兵"></a> 单机单个哨兵</h2>
<p>哨兵的作用：</p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<h2 id="多哨兵模式"><a class="markdownIt-Anchor" href="#多哨兵模式"></a> 多哨兵模式</h2>
<p>Redis的主从复制模式可以将主节点的数据改变同步给从节点，这样从节点就可以起到两个作用：</p>
<ul>
<li>作为主节点的备份，一旦主节点出了故障不可达的情况，从节点可以作为后备“顶上来”，并且保证数据尽量不丢失（主从复制时最终一致性）。第二，从节点可以扩展主节点的读能力，一旦主节点不能支撑住大并发量的读操作</li>
<li>第二，从节点可以扩展主节点的读能力，一旦主节点不能支撑住大并发量的读操作，从节点可以在以顶程度上帮助主节点分担读压力</li>
</ul>
<p>但是主从复制也带来了以下问题：</p>
<ul>
<li>一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要人工干预</li>
<li>主节点的写能力收到单机的限制</li>
<li>主节点的存储能力收到单机的限制</li>
</ul>
<p>当主节点出现故障时，Redis的哨兵模式能自动完成故障发现和故障转移，并通知应用方，从而实现真正的高可用。Redis Sentinel是一个分布式架构，其中包含了若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当它发现节点不可达时，会对节点但做下线标识。如果被标识的是主节点，它还会和其他Sentinel节点进行“协商”，当大多数Sentinel节点都认为主节点不可达时，它们会选举出一个Sentinel节点来完成自动故障转移的工作，同时会将这个变化实时通知给Redis应用方。整个过程完全时自动的，不需要人工来介入，所以这套方案很有效地解决了Redis高可用的问题。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210828165734.png" alt="Redis Sentinel拓扑结构" style="zoom:50%;" />
<p>哨兵模式与主从复制的区别：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210828165535.png" alt="image-20210828165534966" style="zoom: 67%;" />
<p>哨兵的核心配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>
<ul>
<li>数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。</li>
</ul>
<blockquote>
<p>测试</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-sentinel xxx/sentinel.conf</span><br></pre></td></tr></table></figure>
<p>成功启动哨兵模式</p>
<img src="https://img-blog.csdnimg.cn/20200513215752444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />
<p>此时哨兵监视着我们的主机6379，当我们断开主机后：</p>
<img src="https://img-blog.csdnimg.cn/20200513215806972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />
<h2 id="哨兵模式优缺点"><a class="markdownIt-Anchor" href="#哨兵模式优缺点"></a> 哨兵模式优缺点</h2>
<h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3>
<ol>
<li>哨兵集群，基于主从复制模式，所有主从复制的优点，它都有</li>
<li>主从可以切换，故障可以转移，系统的可用性更好</li>
<li>哨兵模式是主从模式的升级，手动到自动，更加健壮</li>
</ol>
<h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h3>
<ol>
<li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li>
</ol>
<p>完整的哨兵模式配置文件 sentinel.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span></span><br><span class="line"><span class="comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span></span><br><span class="line"><span class="comment">#一个是事件的类型，</span></span><br><span class="line"><span class="comment">#一个是事件的描述。</span></span><br><span class="line"><span class="comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure>
<p>Redis当中使用了<a href="https://zhuanlan.zhihu.com/p/32052223">Raft算法</a>实现领导者选举。</p>
<h1 id="缓存穿透与雪崩"><a class="markdownIt-Anchor" href="#缓存穿透与雪崩"></a> 缓存穿透与雪崩</h1>
<h2 id="缓存穿透"><a class="markdownIt-Anchor" href="#缓存穿透"></a> 缓存穿透</h2>
<h3 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2"></a> 概念</h3>
<p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p>
<h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h3>
<p>布隆过滤器：对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210828162856.png" alt="image-20210828162856553" style="zoom:50%;" />
<p>缓存空对象:一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。</p>
<img src="https://img-blog.csdnimg.cn/20200513215836317.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />
<p>这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间</p>
<p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
<h2 id="缓存击穿"><a class="markdownIt-Anchor" href="#缓存击穿"></a> 缓存击穿</h2>
<h3 id="概念-3"><a class="markdownIt-Anchor" href="#概念-3"></a> 概念</h3>
<p>相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p>
<p>比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p>
<h3 id="解决方案-2"><a class="markdownIt-Anchor" href="#解决方案-2"></a> 解决方案</h3>
<ol>
<li>
<p>设置热点数据永不过期</p>
<p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p>
</li>
<li>
<p>加互斥锁(分布式锁)</p>
<p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p>
</li>
</ol>
<h2 id="缓存雪崩"><a class="markdownIt-Anchor" href="#缓存雪崩"></a> 缓存雪崩</h2>
<h3 id="概念-4"><a class="markdownIt-Anchor" href="#概念-4"></a> 概念</h3>
<p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p>
<img src="https://img-blog.csdnimg.cn/20200513215850428.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" />
<h3 id="解决方案-3"><a class="markdownIt-Anchor" href="#解决方案-3"></a> 解决方案</h3>
<ul>
<li>
<p>redis高可用</p>
<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p>
</li>
<li>
<p>限流降级</p>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
</li>
<li>
<p>数据预热</p>
<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
</li>
</ul>
<hr />
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>[1] <a href="https://www.52doc.com/detail/617">Redis开发与运维</a></p>
<p>[2] <a href="https://zh.wikipedia.org/zh/Raft">Raft维基百科</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>db</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解JVM</title>
    <url>/2020/12/06/jvm/</url>
    <content><![CDATA[<p>时至今日，JVM的重要性已经不言而喻，但是JVM本身的复杂性使得了解其原理与运作方式是一件极其困难的事情，本文主要结合张龙老师的视频：<a href="https://www.bilibili.com/video/BV187411B7iv">深入理解JVM虚拟机</a>与《深入理解Java虚拟机》，系统而全面的介绍Java虚拟机的方方面面。</p>
<span id="more"></span>
<h1 id="java-虚拟机总览"><a class="markdownIt-Anchor" href="#java-虚拟机总览"></a> Java 虚拟机总览</h1>
<h2 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h2>
<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</p>
<p>根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210729153802.png" alt="image" style="zoom:50%;" />
<p>主要部分的作用：</p>
<table>
<thead>
<tr>
<th>内存区域</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>程序计数器</td>
<td>当前线程所执行的字节码的行号指示器</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>Java方法执行的线程内存模型</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>本地方法（Native）服务</td>
</tr>
<tr>
<td>堆</td>
<td>存放对象实例</td>
</tr>
<tr>
<td>方法区</td>
<td>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等</td>
</tr>
</tbody>
</table>
<p>除此之外，还有直接内存，这部分并不属于运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，但这部分内存也被频繁的使用。</p>
<h2 id="垃圾回收"><a class="markdownIt-Anchor" href="#垃圾回收"></a> 垃圾回收</h2>
<p>垃圾收集器主要完成三件事情：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p>在Java内存运行时区域的各个部分中，程序计数器、虚拟机栈、本地方法栈3个区域需要使用的内存区域绝大部分可以由类结构确定，因此，这几个区域不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。</p>
<p>判断对象是否可以回收的方法主要有：</p>
<ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<p>垃圾回收的算法主要由：</p>
<ul>
<li>标记-清除算法</li>
<li>标记-复制算法</li>
<li>标记-整理算法</li>
</ul>
<p>不同垃圾回收算法的比较：</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>速度</th>
<th>空间开销</th>
<th>移动对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mark-Sweep</td>
<td>中等</td>
<td>少（但会堆积碎片）</td>
<td>否</td>
</tr>
<tr>
<td>Mark-Compact</td>
<td>最慢</td>
<td>少（不堆积碎片）</td>
<td>是</td>
</tr>
<tr>
<td>Copying</td>
<td>最快</td>
<td>通常需要活对象的2倍大小（不堆积碎片）</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>经典的垃圾收集器及对比：</p>
<table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行或并发</th>
<th>新生代、老年代</th>
<th>算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial</td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理</td>
</tr>
<tr>
<td>CMS</td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除</td>
</tr>
<tr>
<td>G1</td>
<td>并发</td>
<td>不区分</td>
<td>标记-整理+复制算法</td>
</tr>
</tbody>
</table>
<h2 id="类文件结构"><a class="markdownIt-Anchor" href="#类文件结构"></a> 类文件结构</h2>
<p>尽管不同版本的《Java虚拟机规范》对Class文件格式进行了多次更新，但基本上只是在原有结构基础上新增内容、扩充功能，并未对已定义的内容做出修改。</p>
<p>Class文件格式采用一种类似与C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：“无符号数”和“表”。</p>
<ul>
<li>无符号数数据基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引应用、数量值或者按照UTF-8编码构成字符串值。</li>
<li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视为是一张表，这张表由若干个数据项按严格顺序排列构成。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>magic(魔数)</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version(主版本号)</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version(次版本号)</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count(常量池数)</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool(常量池)</td>
<td>constant_pool_count - 1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags(访问标志)</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class(类索引)</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class(父类索引)</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count(接口数量)</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces(接口类索引信息)</td>
<td>interface_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count(字段数量)</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields(字段表索引信息)</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count(方法数量)</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods(方法表索引信息)</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count(属性表个数)</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes(属性表信息)</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<h2 id="类加载机制"><a class="markdownIt-Anchor" href="#类加载机制"></a> 类加载机制</h2>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终可以形成可以被虚拟机直接适用的Java类型，这个过程被称作虚拟机的类加载机制。与其他语言不同的是，Java语言中，类的加载、链接、初始化过程都是在程序运行期间完成的，这为Java应用提供了极高的扩展性和灵活性。</p>
<p>整个类加载的过程大致分为：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210729173029.png" alt="image-20210729173029886" /></p>
<p>JDK8以及之前的类加载器可以分为：</p>
<ul>
<li>启动类加载器</li>
<li>扩展类加载器</li>
<li>应用类加载器</li>
</ul>
<h1 id="内存管理-2"><a class="markdownIt-Anchor" href="#内存管理-2"></a> 内存管理</h1>
<h2 id="运行时数据区域"><a class="markdownIt-Anchor" href="#运行时数据区域"></a> 运行时数据区域</h2>
<h3 id="程序计数器"><a class="markdownIt-Anchor" href="#程序计数器"></a> 程序计数器</h3>
<p>程序计数器（Program Counter），当前线程所执行的字节码的行号指示器，字节码解释器需要依赖程序计数器完成分支、循环、递归等基础功能。</p>
<p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指定的地址；如果正在整形的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p>
<p>程序计数器为线程私有。</p>
<h3 id="虚拟机栈"><a class="markdownIt-Anchor" href="#虚拟机栈"></a> 虚拟机栈</h3>
<p>Java虚拟机栈：存储对象的引用，属于线程私有的内存空间，伴随着线程的生命周期；局部变量表中可以存储基本数据类型以及引用类型，每个方法执行的时候都会创建一个栈帧，栈用于存放局部变量表，操作栈，动态链接，方法出口等信息，一个方法的执行过程，就是这个方法对于栈帧的入栈、出栈过程；</p>
<blockquote>
<p>Java虚拟机栈的生命周期与线程相同。</p>
</blockquote>
<h3 id="本地方法栈"><a class="markdownIt-Anchor" href="#本地方法栈"></a> 本地方法栈</h3>
<p>本地方法栈（Native Method Stack）：主要用于处理本地方法，有的虚拟机实现会把本地方法栈和虚拟机栈合二为一，例如Hotspot虚拟机；</p>
<blockquote>
<p>本地方法栈的生命周期与线程相同。</p>
</blockquote>
<h3 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h3>
<p>堆（Heap）：存储真实的对象，JVM管理的最大的一块内存空间；堆空间的内存可以是连续的，也可以是不连续的，与堆相关的一个重要概念是垃圾收集器，现代几乎所有的垃圾收集器都是采用的分代收集算法，所以堆空间也基于这一点进行了相应的划分：新生代与老年代；Eden空间（80%），From Survivor空间（10%）与To Survivor空间（10%）。</p>
<h3 id="方法区"><a class="markdownIt-Anchor" href="#方法区"></a> 方法区</h3>
<p>方法区（Method Area）：存储元信息。永久代（Permanent Generation），从JDK1.8开始，已经彻底废弃了永久代，使用元空间（meta space），方法区里面的元信息是很少会被回收的，实例数据和元数据，元数据（Class对象）位于方法区。</p>
<p>在HotSpot虚拟机中，方法区也被称为永久区。</p>
<h3 id="运行时常量池"><a class="markdownIt-Anchor" href="#运行时常量池"></a> 运行时常量池</h3>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池表（Constant Pool Table），用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<h3 id="直接内存"><a class="markdownIt-Anchor" href="#直接内存"></a> 直接内存</h3>
<p>直接内存（Direct Memory），并非由Java虚拟机管理的内存区域，与Java NIO密切相关，JVM是通过DirectByteBuffer来操作直接内存的。</p>
<blockquote>
<p>总体而言，除了程序计数器之外都有可能发生OutOfMemoryError异常。</p>
</blockquote>
<h2 id="hotspot虚拟机对象"><a class="markdownIt-Anchor" href="#hotspot虚拟机对象"></a> HotSpot虚拟机对象</h2>
<h3 id="对象的创建"><a class="markdownIt-Anchor" href="#对象的创建"></a> 对象的创建</h3>
<p>Java通过new关键字创建对象的3个步骤：</p>
<ol>
<li>在堆内存中创建出对象的实例</li>
<li>为对象的成员变量赋初值</li>
<li>将对象的引用返回</li>
</ol>
<blockquote>
<p>此时，从虚拟机的视角来看，创建对象的工作已经完成了，但是构造方法中的代码还没有执行，所有的字段均为默认值，new指令执行之后，接着执行<code>&lt;init&gt;()</code>方法，一个真正可用的对象才算创建成功。</p>
</blockquote>
<p>在创建出对象的实例的之前，需要为对象分配内存，分配内存的策略却决于堆内存的实际情况，通常而言有两种策略：</p>
<ul>
<li>指针碰撞：如果堆内存是绝对规整的，那么通过一个指针对堆中的空间进行分割，一侧是已经被使用过的空间，另一侧是未被使用过的空间</li>
<li>空闲列表：前提是堆内存空间中已使用与未被使用的空间是交织在一起的，这时，虚拟机就需要通过一个列表来记录哪些空间是可以使用的，哪些空间是未被使用的，接下来找出可以容纳下新创建对象的且未被使用的空间，在此空间存放该对象，同时还要修改列表上的记录</li>
</ul>
<h3 id="对象的内存布局"><a class="markdownIt-Anchor" href="#对象的内存布局"></a> 对象的内存布局</h3>
<p>在HotSpot虚拟机中，对象在内存中的存储布局可以划分为三个部分：</p>
<ol>
<li>对象头（Header）</li>
<li>实例数据（Instance Data）</li>
<li>对齐填充（Padding）</li>
</ol>
<p>在对象头中，主要存储两类信息，第一类用于存储对象自身的运行时数据（Mark World），如哈希码，GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，具体如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">存储内容</th>
<th style="text-align:center">标志位</th>
<th style="text-align:center">状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">对象哈希码、对象分代年龄</td>
<td style="text-align:center">01</td>
<td style="text-align:center">未锁定</td>
</tr>
<tr>
<td style="text-align:left">指向锁记录的指针</td>
<td style="text-align:center">00</td>
<td style="text-align:center">轻量级锁定</td>
</tr>
<tr>
<td style="text-align:left">指向重量级锁的指针</td>
<td style="text-align:center">10</td>
<td style="text-align:center">重量级锁定</td>
</tr>
<tr>
<td style="text-align:left">空，不需要记录信息</td>
<td style="text-align:center">11</td>
<td style="text-align:center">GC标记</td>
</tr>
<tr>
<td style="text-align:left">偏向锁ID、偏向时间戳、对象分代年龄</td>
<td style="text-align:center">01</td>
<td style="text-align:center">可偏向</td>
</tr>
</tbody>
</table>
<p>对象头中存储的第二类是类型指针，即对象指向它的元数据的指针，Java虚拟机通过这个指针来去顶该对象是那个类的实例，不过这并不是所有的虚拟机实现都必须在对象数据上保留类型指针。</p>
<blockquote>
<p>此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，用于推断数组的大小。</p>
</blockquote>
<p>接下来，在实例数据的区域中，无论是从父类继承下来的，还是在子类中定义的字段全部都会被记录起来。</p>
<p>对象的第三部分是对象填充，这部分是可选的，也没有特别的含义，仅仅起着占位符的作用，由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<h3 id="对象的访问定位"><a class="markdownIt-Anchor" href="#对象的访问定位"></a> 对象的访问定位</h3>
<p>主要的访问方式：</p>
<ul>
<li>使用句柄的方式</li>
<li>使用直接指针的方式</li>
</ul>
<blockquote>
<p>句柄是用来标识被应用程序锁创建或使用的对象的整数。其本质相当于带有引用计数的智能指针。句柄与普通指针的区别在于，指针包含的是引用对象的内存地址，而句柄则是由系统所管理的应用标识，该标识可以被系统重新定位到一个内存地址上。</p>
</blockquote>
<p>如果使用句柄访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象的句柄地址，而句柄中包含了实例数据与类型数据各自具体的地址信息，其结构如下图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210729225700.png" alt="image" style="zoom:67%;" />
<p>如果使用直接指针访问的话，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要一次间接访问的开销。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210729225747.png" alt="image-20210729225747764" style="zoom:67%;" />
<p>使用句柄的好处是，在对象被移动的时候只会改变句柄中实例数据的指针，而reference本身不需要被修改。</p>
<p>使用直接指针的好处是速度更快。</p>
<h1 id="垃圾回收-2"><a class="markdownIt-Anchor" href="#垃圾回收-2"></a> 垃圾回收</h1>
<h2 id="判断对象已死"><a class="markdownIt-Anchor" href="#判断对象已死"></a> 判断对象已死</h2>
<h3 id="引用计数算法"><a class="markdownIt-Anchor" href="#引用计数算法"></a> 引用计数算法</h3>
<p>给对象添加一个引用计数器，当有一个地方引用它，计数器加1，当引用失效，计数器减1，任何时刻计数器为0的对象就是不可能再被使用的；</p>
<p>引用计数法原理比较简单，判定效率也很高，但是需要考虑很多例外情况，必须要配合大量额外的处理才能保证正确地工作。譬如单纯的引用计数就很难解决对象之间相互循环引用的问题，因此未被主流的Java虚拟机采用。</p>
<blockquote>
<p>对象循环引用：A引用B，B引用A，当A和B都是孤立的时候，这两个对象的计数器都是1，无法进行回收，但实际上已经没有作用了。</p>
</blockquote>
<h3 id="根搜索算法"><a class="markdownIt-Anchor" href="#根搜索算法"></a> 根搜索算法</h3>
<p>根搜索算法（Root Tracing）又叫做可达性分析算法（Reachability Analysis），通过一系列的称为“GC Roots”的点作为起始进行向下搜索，当某个对象到GC Roots没有任何引用链（Reference Chain）相连，或者说从GC Roots到这个对象不可达时，则证明此对象是不可用的。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210730101932.png" alt="image-20210730101932370" style="zoom:50%;" />
<p>在Java技术体系中，GC Roots主要包括：</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量</li>
<li>在方法区中常量引用的对象，譬如字符串常量池里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointException），还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
</ul>
<blockquote>
<p>除了这些固定的GC Roots集合以外，根据用户所选用的拦击收集器以及当前回收的内存区域不同，还可以又其他对象“临时性”地加入，共同构成GC Roots集合。</p>
</blockquote>
<h3 id="对象的回收"><a class="markdownIt-Anchor" href="#对象的回收"></a> 对象的回收</h3>
<p>方法区的垃圾收集器主要回收两部分的内容：废弃的常量和不再使用的类型。</p>
<p>判断常量需要被垃圾回收只要没有其他地方引用即可，但判断一个类型是否要被垃圾回收，需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被GC，也就是JVM中不存在改Class的任何实例；</li>
<li>加载该类的ClassLoader已经被GC；</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法。</li>
</ul>
<h3 id="对象的引用"><a class="markdownIt-Anchor" href="#对象的引用"></a> 对象的引用</h3>
<p>在JDK1.2之前，一个对象只有“被引用”或者“未被引用”两种状态，但这种描述方式不能满足所有的场景，譬如我们希望描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在垃圾收集器后仍然非常警长，那就可以抛弃这些对象，这个时候就需要对引用的概念进行扩充。</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>定义</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用（Strong Reference）</td>
<td>通过new关键赋值的引用</td>
<td>只要强引用关系还存在，垃圾收集器永远不会回收掉引用的对象</td>
</tr>
<tr>
<td>软引用（Soft Reference）</td>
<td>还有用，但非必须的对象</td>
<td>内存不够时一定会被GC，长期不用也会被GC</td>
</tr>
<tr>
<td>弱引用（Weak Reference）</td>
<td>非必须对象</td>
<td>被弱引用关联的对象只能生存到下一次垃圾收集发生为止。无论当前内存是否足够，都会回收</td>
</tr>
<tr>
<td>虚引用（Phantom Reference）</td>
<td>“幽灵引用”或者“幻影引用”</td>
<td>对象被垃圾收集器回收时收到一个系统通知</td>
</tr>
</tbody>
</table>
<h2 id="垃圾回收算法"><a class="markdownIt-Anchor" href="#垃圾回收算法"></a> 垃圾回收算法</h2>
<h3 id="分代收集理论"><a class="markdownIt-Anchor" href="#分代收集理论"></a> 分代收集理论</h3>
<p>从如何判定对象消亡的角度触发，垃圾回收算法可以划分为“引用计数式垃圾收集器”和“追踪式垃圾收集器”两大类，这两类也常称位“直接垃圾收集器”和“间接垃圾收集器”，不过本文介绍的所有算法均属于追踪式垃圾收集的范畴。</p>
<p>分代收集理论指的是根据不同的存活周期将内存划分为几块，Java一般将堆分作新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法，譬如新生代每次GC都有大批对象死去，只有少量存活，那么就可以选用复制算法只需要付出少量存活对象的复制成本就可以完成收集，而老年代存放了经过一次或者多次GC还存活的对象，一般采用标记-清除和标记-整理算法完成收集。</p>
<p>当代商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计，分代收集理论实际上建立在三个分代假说之上：</p>
<ul>
<li>弱分代假说：绝大数对象都是朝生夕灭的</li>
<li>强分代假说：熬过越多次数垃圾收集过程的对象就越难以消亡</li>
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数</li>
</ul>
<p>根据跨代引用假说，在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分为若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p>
<p>分代收集理论有一些垃圾收集行为：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>部分收集（Partial GC）</td>
<td>指目标不是完整收集整个Java堆的垃圾收集，又分为新生代、老年代、混合收集</td>
</tr>
<tr>
<td>新生代收集（Minor GC/Young GC）</td>
<td>指目标只是新生代的垃圾收集</td>
</tr>
<tr>
<td>老年代收集（Major GC/Old GC）</td>
<td>指目标只是老年代的垃圾收集，目前只有CMS收集器会有单独收集老年代的行为</td>
</tr>
<tr>
<td>混合收集（Mixed GC）</td>
<td>指目标收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为</td>
</tr>
<tr>
<td>整堆收集（Full GC）</td>
<td>收集整个Java堆和方法去区垃圾收集</td>
</tr>
</tbody>
</table>
<h3 id="标记-清除算法"><a class="markdownIt-Anchor" href="#标记-清除算法"></a> 标记-清除算法</h3>
<p>标记-清除算法（Mark-Sweep），分为“标记”和“清除”两个阶段要回收的对象，然后回收所有需要回收的对象，执行过程如图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210730113924.png" alt="image" style="zoom: 50%;" />
<p>缺点：</p>
<ul>
<li>效率问题，标记和清理两个过程效率都不高，需要扫描所有对象，堆越大，GC越慢</li>
<li>空间问题，标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能导致后续使用中无法找到足够的连续内存而提前触发另一次的垃圾搜集动作</li>
</ul>
<h3 id="标记-复制算法"><a class="markdownIt-Anchor" href="#标记-复制算法"></a> 标记-复制算法</h3>
<p>标记-复制算法（Copying），将可用内存划分为两块，每次只使用其中的一块，当半区内存用完之后，仅将还存活的对象复制到另一块上面，然后就把原来整块内存空间一次性清理掉。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210730114144.png" alt="image" style="zoom:50%;" />
<p>优点：</p>
<ul>
<li>这样使得每次内存回收都是对整个搬去的回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动过堆顶指针，按顺序分配内存就可以了，实现简单，运行高效。</li>
</ul>
<p>缺点：</p>
<ul>
<li>这种算法的代价是将内存缩小为原来的一半，代价高昂</li>
</ul>
<p>现在的虚拟机中都是采用此算法来回收新生代，不过新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1：1的比例来划分新生代的内存空间。</p>
<p>通常采用复制算法的垃圾收集其，会将内存分为一块较大的eden空间和两块较少的survivor空间，每次使用eden和其中一块survivor，当回收的时候会将eden和survivor还存活的对象一次性拷贝到另一块survivor空间上，然后清理掉eden和用过的survivor，用过的survivor称为From survivor，没有用过的survivor称为To survivor。</p>
<p>HotSpot虚拟机默认的eden和survivor的大小比例是8:1，也就是每次只有10%的内存是“浪费”的。</p>
<p>如果不想浪费50%的空间，就需要有额外的空间进行分配担保用于应付半区内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>总体来说，复制算法的特点如下：</p>
<ul>
<li>只需要扫描存活的对象，效率更高</li>
<li>不会产生碎片</li>
<li>需要浪费额外的内存作为复制区</li>
<li>复制算法非常适合生命周期比较短的对象，因为每次GC总能回收大部分的对象，复制的开销比较小</li>
<li>复制收集算法在对象存活率高的时候，效率有所下降</li>
</ul>
<h3 id="标记-整理算法"><a class="markdownIt-Anchor" href="#标记-整理算法"></a> 标记-整理算法</h3>
<p>标记-整理算法（Mark-Compact）标记过程仍然一样，但后续步骤不是进行直接清理，而是令所有存活的对象一端移动，然后直接清理掉这端边界以外的内存。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210730114926.png" alt="image" style="zoom:50%;" />
<p>特点：</p>
<ul>
<li>没有内存碎片，但是需要耗费更多的时间进行整理</li>
</ul>
<h2 id="经典垃圾收集器"><a class="markdownIt-Anchor" href="#经典垃圾收集器"></a> 经典垃圾收集器</h2>
<p>HotSpot虚拟机的垃圾收集器：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210730121740.png" alt="image-20210730121739924" style="zoom: 50%;" />
<p>在垃圾收集器中，并发和并行的含义：</p>
<ul>
<li>
<p>并行（Parallel）：指多个收集器的线程同时工作，但是用户线程处于等待状态</p>
</li>
<li>
<p>并发（Concurrent）：指收集器在工作的同时，可以允许用户线程工作。</p>
</li>
</ul>
<p>并发不代表解决了GC停顿的问题，在关键的步骤还是要停顿。比如在收集器标记垃圾的时候要停顿，但在清除垃圾的时候，用户线程可以和GC线程并发执行。</p>
<h3 id="serial收集器"><a class="markdownIt-Anchor" href="#serial收集器"></a> Serial收集器</h3>
<p>单线程收集器，收集时会暂停所有工作线程（Stop The World，简称STW），使用复制算法，虚拟机运行在客户端模式时的默认新生代收集器，运行示意图如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210730115205.png" alt="image-20210730115205713" /></p>
<p>特点：</p>
<ul>
<li>最早的收集器，单线程进行GC</li>
<li>New和Old Generation都可以使用</li>
<li>在新生代，采用复制算法；在老年代，采用Mark-Compact算法</li>
<li>因为是单线程GC，没有多线程切换的额外开销，简单使用。</li>
<li>Hotspot 客户端模式默认的垃圾收集器</li>
</ul>
<h3 id="parnew收集器"><a class="markdownIt-Anchor" href="#parnew收集器"></a> ParNew收集器</h3>
<p>ParNew收集器就是Serial的多线程版本，除了使用多个收集线程外，其余行为包括算法，STW，对象分配规则，回收策略等都与Serial收集器一摸一样。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210730115754.png" alt="image-20210730115727881" /></p>
<p>对应这种收集器是虚拟机运行在服务端模式的默认新生代收集器，在单CPU的环境中，ParNew收集器并不会比Serila收集器有更好的效果。</p>
<p>特点：</p>
<ul>
<li>使用复制算法</li>
<li>只有在多CPU的环境下，效率才会比Serial收集器高</li>
<li>可以通过-XX:ParallerlGCThreads来控制GC线程数的多少，需要结合具体的CPU的个数</li>
</ul>
<h3 id="parallel-scavenge收集器"><a class="markdownIt-Anchor" href="#parallel-scavenge收集器"></a> Parallel Scavenge收集器</h3>
<p>也是一个多线程收集器，也是使用复制算法，但它的对象分配规则与回收策略都ParNew收集器有所不同，它是以吞吐量最大化（即GC时间占总运行时间最小）为目标的收集器实现，它允许较长时间的STW换取总吞吐量最大化。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">吞</mi><mi mathvariant="normal">吐</mi><mi mathvariant="normal">量</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">户</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">码</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow><mrow><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">户</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">码</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mo>+</mo><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">垃</mi><mi mathvariant="normal">圾</mi><mi mathvariant="normal">收</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">吞吐量=\frac{运行用户代码时间}{运行用户代码时间 + 运行垃圾收集时间}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">吞</span><span class="mord cjk_fallback">吐</span><span class="mord cjk_fallback">量</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.4463300000000001em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">码</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">垃</span><span class="mord cjk_fallback">圾</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">码</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<blockquote>
<p>由于吞吐量关系密切，Parallel Scavenge收集器也经常被称为“吞吐量优先收集器”。</p>
</blockquote>
<h3 id="serial-old收集器"><a class="markdownIt-Anchor" href="#serial-old收集器"></a> Serial Old收集器</h3>
<p>Serial Old收集器是单线程收集器，使用标记-整理算法，是老年代的收集器。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210730121027.png" alt="image-20210730121027807" /></p>
<h3 id="parallel-old收集器"><a class="markdownIt-Anchor" href="#parallel-old收集器"></a> Parallel Old收集器</h3>
<p>Parallel Old收集器时Parallel Scavenge的老年代版本，使用多线程和标记-整理算法，从JDK1.6开始提供，在此之前，新生代使用了Parallel Scavenge收集器的话，老年代除了Serial Old别无选择，因为Parallel Scavenge无法与CMS收集器配合工作。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210730182344.png" alt="image-20210730182344292" /></p>
<p>特点：</p>
<ul>
<li>Parallel Scavenge + Parallel Old = 高吞吐量，但GC停顿可能不理想</li>
</ul>
<blockquote>
<p>JDK1.8使用的默认垃圾收集器就是Parallel Scavenge + Parallel Old</p>
</blockquote>
<h3 id="cms收集器"><a class="markdownIt-Anchor" href="#cms收集器"></a> CMS收集器</h3>
<h4 id="cms简介"><a class="markdownIt-Anchor" href="#cms简介"></a> CMS简介</h4>
<p>CMS收集器（Concurrent Mark Sweep）是一种以最短停顿时间为目标的收集器，使用CMS并不能达到GC效率最高（总体GC时间最小），但它能尽可能降低GC时服务的停顿时间，CMS收集器使用的是标记-清除算法。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210730182623.png" alt="image-20210730182623573" /></p>
<p>CMS（Concurrent Mark Sweep）收集器，以获取最短回收停顿时间（STW）为目标，多数应用于互联网站或者B/S系统的服务器端上。</p>
<p>CMS是基于“标记-清除“算法实现的，整个过程分为4个步骤：</p>
<ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<p>其中，初始标记和重新标记步骤仍然需要STW，初始标记只是标记一下GC Roots能直接关联到的对象，速度很快；</p>
<p>并发标记阶段就是进行GC Roots Tracing的过程；</p>
<p>重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的挺短时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>在整个过程中耗时最长的并发标记和并发清理的过程收集器线程都可以与用户线程一起工作，因此，从总体上看，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>CMS垃圾收集器的优点：</p>
<ul>
<li>并发收集、低停顿</li>
</ul>
<p>缺点：</p>
<ul>
<li>CMS收集器对CPU资源非常敏感</li>
<li>CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现”Concurrent Mode Failure“失败而导致另一次Full GC的产生 。如果在应用中老年代增长不是太快，可以适当调高参数<code>-XX:CMSInitiatingOccupanyFraction</code>的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，要是CMS运行期间预留的内存无法满足程序需要时，虚拟机将启动后备预案：临时启动Serial Old收集器来重新进行老年代的来及收集，这样停顿时间就很长了。所以说参数<code>-XX:CMSInitiatingOccupancyFraction</code>设置得太高了很容易导致大量”Concurrent Mode Failure“失败。性能反而降低。</li>
<li>收集结束时会有大量空间碎片产生，空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前进行一个Full GC。CMS收集器提供了一个<code>-XX:+UseCMSCompactAtFullCollection</code>开关参数（默认开启），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</li>
</ul>
<p>总的来看，CMS垃圾收集器的特点:</p>
<ul>
<li>只针对于追求最短停顿时间，非常适合web应用</li>
<li>只针对老年区，一般结合ParNew使用</li>
<li>Concurrent，GC线程和用户线程并发工作（尽量并发）</li>
<li>使用标记清除算法</li>
<li>只有在多CPU环境下才有意义</li>
<li>使用<code>-XX:+UseConcMarkSweepGC</code>打开</li>
<li>CMS以牺牲CPU资源的代价来减少用户线程的停顿。当CPU个数少于4的时候，有可能对吞吐量影响非常大</li>
<li>CMS在并发清理的过程中 ，用户线程还在跑，这时候需要预留一部分空间给用户线程</li>
<li>CMS用Mark-Sweep，会带来碎片问题。碎片过多的时候会容易频繁触发Full GC</li>
</ul>
<h4 id="cms详细步骤"><a class="markdownIt-Anchor" href="#cms详细步骤"></a> CMS详细步骤</h4>
<ol>
<li>初始标记(CMS-initial-mark) ，会导致swt；</li>
<li>并发标记(CMS-concurrent-mark)，与用户线程同时运行；</li>
<li>预清理（CMS-concurrent-preclean），与用户线程同时运行；</li>
<li>可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行；</li>
<li>重新标记(CMS-final remark) ，会导致swt；</li>
<li>并发清除(CMS-concurrent-sweep)，与用户线程同时运行；</li>
<li>并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；</li>
</ol>
<h4 id="初始标记"><a class="markdownIt-Anchor" href="#初始标记"></a> 初始标记</h4>
<p>标记老年代中所有的GC Roots对象，如下图节点1；</p>
<p>标记年轻代中活着的对象引用到的老年代的对象（指的是年轻带中还存活的引用类型对象，引用指向老年代中的对象）如下图节点2、3；</p>
<h4 id="并发标记"><a class="markdownIt-Anchor" href="#并发标记"></a> 并发标记</h4>
<p>从“初始标记”阶段标记的对象开始找出所有存活的对象;</p>
<p>为是并发运行的，在运行期间会发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况。为了提高重新标记的效率，该阶段会把上述对象所在的Card标识为Dirty，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代；</p>
<p>并发标记阶段只负责将引用发生改变的Card标记为Dirty状态，不负责处理；</p>
<p>如下图所示，也就是节点1、2、3，最终找到了节点4和5。并发标记的特点是和应用程序线程同时运行。并不是老年代的所有存活对象都会被标记，因为标记的同时应用程序会改变一些对象的引用等。</p>
<h4 id="预清理阶段"><a class="markdownIt-Anchor" href="#预清理阶段"></a> 预清理阶段</h4>
<p>前一个阶段已经说明，不能标记出老年代全部的存活对象，是因为标记的同时应用程序会改变一些对象引用，这个阶段就是用来处理前一个阶段因为引用关系改变导致没有标记到的存活对象的，它会扫描所有标记为Direty的Card</p>
<p>如下图所示，在并发清理阶段，节点3的引用指向了6；则会把节点3的card标记为Dirty；</p>
<p>最后将6标记为存活,如下图所示：</p>
<h4 id="可终止的预清理"><a class="markdownIt-Anchor" href="#可终止的预清理"></a> 可终止的预清理</h4>
<p>这个阶段尝试着去承担下一个阶段Final Remark（STW）阶段足够多的工作。这个阶段持续的时间依赖好多的因素，由于这个阶段是重复的做相同的事情直到发生aboart的条件（比如：重复的次数、多少量的工作、持续的时间等等）之一才会停止。</p>
<blockquote>
<p>此阶段最大持续时间为5秒，之所以可以持续5秒，另外一个原因也是为了期待这5秒内能够发生一次ygc，清理年轻代的引用，是的下个阶段的重新标记阶段，扫描年轻带指向老年代的引用的时间减少；</p>
</blockquote>
<h4 id="重新标记"><a class="markdownIt-Anchor" href="#重新标记"></a> 重新标记</h4>
<p>这个阶段会导致第二次stop the word，该阶段的任务是完成标记整个年老代的所有的存活对象。</p>
<p>这个阶段，重新标记的内存范围是整个堆，包含_young_gen和_old_gen。为什么要扫描新生代呢，因为对于老年代中的对象，如果被新生代中的对象引用，那么就会被视为存活对象，即使新生代的对象已经不可达了，也会使用这些不可达的对象当做cms的“gc root”，来扫描老年代； 因此对于老年代来说，引用了老年代中对象的新生代的对象，也会被老年代视作“GC ROOTS”:当此阶段耗时较长的时候，可以加入参数-XX:+CMSScavengeBeforeRemark，在重新标记之前，先执行一次ygc，回收掉年轻带的对象无用的对象，并将对象放入幸存带或晋升到老年代，这样再进行年轻带扫描时，只需要扫描幸存区的对象即可，一般幸存带非常小，这大大减少了扫描时间</p>
<p>由于之前的预处理阶段是与用户线程并发执行的，这时候可能年轻带的对象对老年代的引用已经发生了很多改变，这个时候，remark阶段要花很多时间处理这些改变，会导致很长stop the word，所以通常CMS尽量运行Final Remark阶段在年轻代是足够干净的时候。</p>
<p>另外，还可以开启并行收集：<code>-XX:+CMSParallelRemarkEnabled</code></p>
<h4 id="并发清理"><a class="markdownIt-Anchor" href="#并发清理"></a> 并发清理</h4>
<p>通过以上5个阶段的标记，老年代所有存活的对象已经被标记并且现在要通过Garbage Collector采用清扫的方式回收那些不能用的对象了。</p>
<p>这个阶段主要是清除那些没有标记的对象并且回收空间；</p>
<p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
<h4 id="并发重置"><a class="markdownIt-Anchor" href="#并发重置"></a> 并发重置</h4>
<p>这个阶段并发执行，重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用。</p>
<p>CMS将大量工作分散到并发处理阶段来减少STW时间。</p>
<p>吞吐量关注的是，在一个指定的时间内，最大化一个应用的工作量。</p>
<p>衡量一个系统吞吐量的好坏：</p>
<ul>
<li>在一个小时内同一个事务（或者任务、请求）完成的次数（tps）</li>
<li>数据库一小时可以完成多少次查询</li>
</ul>
<p>对于关注吞吐量的系统，卡顿是可以接收的，因为这个系统关注长时间的大量任务的执行能力，单次快速的响应并不值得考虑。</p>
<p>响应能力指的是一个程序或者系统对请求是否能够及时响应，比如：</p>
<ul>
<li>一个桌面UI能多快地影响一个时间</li>
<li>一个网站能够多块返回一个页面请求</li>
<li>数据库能够多快返回查询的数据</li>
</ul>
<p>对于这类对响应能力敏感的场景，长时间的停顿是无法接收的。</p>
<h3 id="garbage-first收集器"><a class="markdownIt-Anchor" href="#garbage-first收集器"></a> Garbage First收集器</h3>
<h4 id="g1简介"><a class="markdownIt-Anchor" href="#g1简介"></a> G1简介</h4>
<p>G1收集器是一个面向服务端的垃圾收集器，适用于多核处理器、大内存容量的服务端系统。满足短时间GC停顿的同时达到一个较高的吞吐量。G1最大的特点就是高效的执行回收，优先去执行那些大量对象可回收的区域。</p>
<p>G1收集器的设计目标</p>
<ul>
<li>与引用线程同时工作，几乎不需要STW</li>
<li>整理剩余空间，不产生内存碎片（CMS只能在发生Full GC时，用STW整理内存碎片）</li>
<li>GC停顿更加可控</li>
<li>不牺牲系统的吞吐量</li>
<li>GC不要求额外的内存空间（CMS需要预留空间存储浮动垃圾）</li>
</ul>
<h4 id="重要概念"><a class="markdownIt-Anchor" href="#重要概念"></a> 重要概念</h4>
<h5 id="region"><a class="markdownIt-Anchor" href="#region"></a> Region</h5>
<p>传统的垃圾收集器将连续的内存空间划分为新生代、老年代和永久代（JDK8去除了永久代，引入了元空间Metaspace），这种划分的特点是各代的存储地址是连续的。如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210804101940.png" alt="image-20210804101940161" style="zoom: 80%;" />
<p>而G1的各代存储地址是不连续的，每一代都使用了n个不连续的大小相同的Region，每个Region占有一块连续的虚拟内存地址。如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210804102450.png" alt="image-20210804102450160" style="zoom:50%;" />
<p>可以看到，每个region都有一个分代的角色：eden、survivor、old，对每个角色的数量并没有强制的限定，也就是说对每种分代内存的大小，可以动态变化，每个Region默认按照512Kb划分成多个Card。</p>
<p>每个分区都可能是年轻代也可能是老年代，但是在同一时刻只能属于某个代。年轻代、幸存区、老年代这些概念还存在，成为逻辑上的概念，这样方便复用之前分代框架的逻辑。</p>
<p>此外，还有一些Region标明了H，它代表Humongous，这表示这些Region存储的是巨大对象（humongous object），即大小大于或等于Region一半的对象。巨型对象默认直接会被分配在老年代，如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。</p>
<p>H-obj有如下几个特征：</p>
<ul>
<li>H-obj直接分配到了old gen，放置了反复拷贝移动</li>
<li>H-obj在global concurrent marking阶段的cleanup和full GC阶段回收</li>
</ul>
<p>为了减少连续H-objs分配对GC的影响，需要把大对象变为普通的对象，建议增大Region size。</p>
<p>Humongous（巨大的）：如果某一个对象的大小超过了region区域大小的50%，就被放置到  区域当中，humongous是eden、survivor、old generation其中一个，</p>
<p>在物理上不需要连续，则带来了额外的好处——有的分区内垃圾对象也别多，有的分区内垃圾对象很少，G1会优先回收垃圾对象特别多的分区，这样可以花费较少的时间来回收这些分区的垃圾，这也就是G1名字的由来，即首先收集垃圾最多的分区。</p>
<h5 id="三色标记算法"><a class="markdownIt-Anchor" href="#三色标记算法"></a> 三色标记算法</h5>
<p>三色标记算法是描述追踪式回收器的一种有效的方法，利用它可以推演回收器的正确性。</p>
<p>我们将对象分成三种类型：</p>
<ol>
<li>黑色：根对象，或者该对象与它的子对象都被扫描过（对象被标记了，且它的所有的field也被标记完了）</li>
<li>灰色：对象本身被扫描，但还没扫描完该对象中的子对象（它的field还没有被标记或标记完）</li>
<li>白色：未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象（对象没有被标记到）</li>
</ol>
<p>遍历了所有可达的对象后，所有可达的对象都变成了黑色，不可达的对象即为白色，需要被清理。</p>
<p>如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失问题</p>
<p>三色标记带来了两个问题，一个是新创建的对象的问题，另一个就是对象丢失的问题。</p>
<h5 id="satb算法"><a class="markdownIt-Anchor" href="#satb算法"></a> SATB算法</h5>
<p>SATB（Snapshot-At-The-Begining），由字面意思理解就是GC开始时活着的对象的一个快照，是G1在并发标记阶段使用的增量式的标记算法。</p>
<p>SATB的步骤：</p>
<ol>
<li>在开始标记的时候生成一个快照图，标记存活对象</li>
<li>在并发标记的时候所有被改变的对象入队（在write barrier里所有旧的引用所指向的对象都变成非白的）</li>
<li>可能存在浮动垃圾，将在下次被收集</li>
</ol>
<p>解决三色标记算法的两个问题的方式：</p>
<p>1、每个Region记录着两个top-at-mark-start（TAMS）指针，分别为prevTAMS和nextTAMS。在TAMS以上的对象就是新分配的，因而被视为隐式marked。通常这种方式我们就找到了在GC过程中新分配的对象，并把这些对象认为是活的对象。</p>
<p>2、G1通过Write Barrier对引用字段进行赋值做了额外处理。通过Write Barrier就可以了解到那些引用对象发生了什么样的变化。</p>
<ul>
<li>对black新引用了一个white对象，然后又从gray对象中删除了对改white对象的引用，这样会造成了该white对象漏标记</li>
<li>对black新引用了一个white对象，然后从gray对象删了一个引用该white对象的white对象，这样也会造成了该white对象漏标记</li>
<li>对black新引用了一个刚new出来的white对象，没有其他gray对象引用该white对象，这样也会造成了该white对象漏标记</li>
</ul>
<p>SATB在marking阶段中，对于从gray对象移除的目标引用对象标记为gray，对于black引用的新产生的对象标记为black，由于是在开始时进行的snapshot，因而可能存在浮动垃圾。</p>
<p>误标没什么关系，顶多造成浮动垃圾，在下次gc还是可以回收的，但是漏标的后果是致命的，把本应该存活的对象给回收了，从而影响程序的正确性。</p>
<p>漏标的情况只会发生在白色对象中，且满足以下任意一个条件：</p>
<ol>
<li>并发标记时，应用线程给一个黑色对象的引用类型字段赋值了该白色对象</li>
<li>并发标记时，应用线程删除所有灰色对象到该白色对象的引用（可能存在黑色对象引用的情况）</li>
</ol>
<p>解决方案：</p>
<ol>
<li>利用post-write barrier记录所有新增的引用关系，然后根据这些引用关系为根重新扫描一遍</li>
<li>利用post-write barrier将所有即将被删除的引用关系的旧引用记录下来，最后以这些旧引用为根重新扫描一遍</li>
</ol>
<h5 id="rset"><a class="markdownIt-Anchor" href="#rset"></a> RSet</h5>
<p>已记忆集合（Remembered Set），是辅助GC过程的一种结构，典型的空间换时间工具，和Card Table有些类似。Rset记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象），而Card Table则是一种points-out（我引用谁的对象）的结构，RSet的价值在于使得垃圾收集器不需要扫描整个堆到谁引用了当前分区中的对象，只需要扫描RSet即可。</p>
<p>RSet其实是一个hash table，key是别的Region的真实地址，value是一个集合，里面的元素是Card Table和index。举例来说，如果RegionA的RSet里面有一项的key是RegionB，value里有index为1234的card，它的意思就是region B的一个card里有引用指向region A。所以对RegionA来说，该RSet记录的是points-into的关系；而card table仍然记录了points-out的关系。</p>
<p>下图表示了RSet、Card和Region的关系：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210804110735.png" alt="image-20210804110522846" style="zoom:50%;" />
<h5 id="cset"><a class="markdownIt-Anchor" href="#cset"></a> CSet</h5>
<p>收集集合（Collection Set）：GC要收集的Region的集合。在CSet中存活的数据会在GC过程中被移动到另一个可用分区，CSet中的分区可以来自eden空间、survivor空间或者老年代。</p>
<ul>
<li>CSet里面总是具有所有年轻代里面的Region</li>
<li>CSet = 年轻代所有的Region + 全局并发阶段标记出来的收益高的老年代Region</li>
</ul>
<h5 id="停顿预测模型"><a class="markdownIt-Anchor" href="#停顿预测模型"></a> 停顿预测模型</h5>
<p>G1是一个响应时间优先的垃圾收集器，它与CMS最大的不同是，用户可以设定整个GC过程的期望停顿时间，默认是200ms，不过它不是硬性条件，只是期望值，G1会根据停顿预测模型（Pause Prediction Model）统计计算出来历史数据来预测本次收集需要选择的Region数量，从而尽量满足用户设定的目标停顿时间，停顿预测模型是以衰减标准偏差理论基础实现的。</p>
<h4 id="gc过程"><a class="markdownIt-Anchor" href="#gc过程"></a> GC过程</h4>
<h5 id="回收算法"><a class="markdownIt-Anchor" href="#回收算法"></a> 回收算法</h5>
<p>G1从多个region中复制存活的对象，然后集中放入一个region中，同时整理、清除内存（Copying收集算法）</p>
<p>特点：G1使用的copying算法不会造成内存碎片，并且只是针对特定的region进行整理，因此不会导致gc停顿的时间过长。</p>
<p>Mixed GC由一些参数控制，另外也控制着哪些老年代Region会被选入CSet（收集集合）</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>G1HeapWastePercent</td>
<td>在global concurrent marking结束之后，我们可以知道old gen regions中有多少空间要被回收，在每次YGC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生Mixed GC。</td>
</tr>
<tr>
<td>CLiveThresholdPercent</td>
<td>old genration region中存活对象的占比，只有在此参数之下，才会被选入CSet。</td>
</tr>
<tr>
<td>G1MixedGCCountTarget</td>
<td>一次gloal concurrent marking之后，最多执行Mixed GC的次数</td>
</tr>
<tr>
<td>G1OldCSetRegionThresholdPercent</td>
<td>一次Mixed GC中能被选入CSet的最多old generation region数量。</td>
</tr>
</tbody>
</table>
<p>每次GC时，所有新生代都会被扫描，所以无需记录新生代之间的记录引用，只需要记录老年代到新生代之间的引用即可。</p>
<p>如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这问题，在G1中又引入了另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组小标来标识每个分区的空间地址）</p>
<h5 id="收集过程"><a class="markdownIt-Anchor" href="#收集过程"></a> 收集过程</h5>
<p>G1垃圾收集活动时序图如下：</p>
<img src="C:/Users/jyc/AppData/Roaming/Typora/typora-user-images/image-20210804174604210.png" alt="image-20210804174604210" style="zoom:50%;" />
<p>从图中不难看出，G1的收大致可以分为四个阶段：</p>
<ul>
<li>Young GC（不同于CMS）</li>
<li>并发标记阶段</li>
<li>Mixed GC</li>
<li>full GC</li>
</ul>
<p>其中最主要的两个阶段：</p>
<ul>
<li>Young GC：选定所有年轻代里的Region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC的时间开销。</li>
<li>Mixed GC：选定所有年轻代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region</li>
</ul>
<p>Young GC和Mixed GC都需要STW。需要注意的是，Mixed GC不是Full GC，它只能回收部分老年代的Region，如果Mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用serial old GC（Full GC）来收集整个GC heap。所以本质上，G1是不提供Full GC的。</p>
<h5 id="young-gc"><a class="markdownIt-Anchor" href="#young-gc"></a> Young GC</h5>
<p>G1 YGC在Eden充满时触发，在回收之后所有之前属于Eden的区块全部变成空白，即不属于任何一个分区（Eden、Survivor、Old）。</p>
<p>Young GC的处理过程共分为以下五个阶段</p>
<ul>
<li>根扫描：静态和本地对象被扫描</li>
<li>更新RS：处理dirty card队列更新RS</li>
<li>处理RS：检测从年轻代指向老年代的对象</li>
<li>对象拷贝：拷贝存活的对象到survivor/old区域</li>
<li>处理引用队列：软引用、弱引用、虚引用处理</li>
</ul>
<h5 id="mixed-gc"><a class="markdownIt-Anchor" href="#mixed-gc"></a> Mixed GC</h5>
<ul>
<li>全局并发标记（global concurrent marking）</li>
<li>拷贝存活对象（evacuation）</li>
</ul>
<h5 id="global-concurrent-marking"><a class="markdownIt-Anchor" href="#global-concurrent-marking"></a> global concurrent marking</h5>
<p>global concurrent marking的执行过程类似CMS，但是不同的是，在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节</p>
<p>global concurrent marking共分为如下四个步骤：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210804125927.png" alt="image-20210730190157084" /></p>
<ul>
<li>初始标记（initial mark，STW）：它标记了从GC Root开始直接可达的对象</li>
<li>并发标记（Concuurent Marking）:这个阶段从GC Root开始对heap中的对象进行标记，标记线程与应用程序线程并发执行，并且收集各个Region的存活对象信息</li>
<li>重新标记：（Remark，STW）:标记那些在并发标记阶段发生变化的对象，将被回收</li>
<li>清理（Cleanup）:清除空Region（没有存活对象的），加入到free list。</li>
</ul>
<p>第一阶段initial mark是共用了Young GC的暂停，这是因为他们可以复用root scan操作，所以可以说global concurrent marking是伴随Young GC而发生的，第四阶段Cleanup只是回收了没有存活对象的Region，所以它并不需要STW。</p>
<h4 id="g1特点"><a class="markdownIt-Anchor" href="#g1特点"></a> G1特点</h4>
<p>G1并非一个实时的收集器，与PS一样，对gc停顿时间的设置并不是绝对生效，只是G1有较高的几率保证不超过设定的gc停顿时间。与之前的gc收集器对比，G1会根据用户设定的gc停顿时间，只能评估哪几个region需要被回收可以满足用户的设定。</p>
<p>依然是在新生代满了的时候，对整个新生代进行回收——整个新生代中的对象，要么被回收，要么晋升，至于新生代也采取分区机制的原因，则是因为这样跟老年代的策略统一，方便调整代的大小。</p>
<p>G1还是一种带压缩的收集器，在回收老年代的分区时，是将存活的对象从一个分区拷贝到另一个可用分区，这个拷贝的过程就实现了局部的压缩。</p>
<p>停顿时间不是越短越好，设置的时间越短意味着每次收集的CSet就越小，导致垃圾逐步积累变多，最终不得不退化程Serial GC，停顿时间设置的过长那么会导致每次都会产生长时间的停顿，影响了程序对外的响应时间。</p>
<p>当Mixed GC赶不上对象产生的速度的时候就退化成Full GC，这一点是需要重点调优的地方。</p>
<p>G1会在Young GC和Mixed GC之间不断地切换，同时定期地做全局并发标记，在实在赶不上对象创建速度的情况下使用Full GC（Serial GC）。</p>
<p>G1收集器在运行的时候会自动调整新生代和老年代的大小。通过改变代的大小来调整对象晋升的速度以及晋升年龄，从而达到我们为收集器设置的暂停时间的目标值。</p>
<p>设置了新生代大小相当于放弃了G1为我们做的自动调优，我们只需要设置整个堆内存大小即可。</p>
<p>Evacuation Failure：类似CMS晋升失败，堆空间的垃圾太多导致无法完成Region之间的拷贝，于是不得不退化成Full GC来做一次全局范围内的垃圾收集。</p>
<h4 id="参数设置"><a class="markdownIt-Anchor" href="#参数设置"></a> 参数设置</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> -verbose:gc -Xms10m -Xmx10m -XX:+UseG1GC   // 使用GC垃圾收集器</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:MaxGCPauseMillis=200m  // 最大停顿时间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> -XX:MaxGCPauseMillis=x    // 设置启动应用程序暂停时间，一般情况下是100ms-200ms</span> </span><br></pre></td></tr></table></figure>
<h3 id="垃圾收集器参数总结"><a class="markdownIt-Anchor" href="#垃圾收集器参数总结"></a> 垃圾收集器参数总结</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> -verbose:gc   // 表示输出详细的垃圾回收的日志</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> -Xms20M       // 堆内存初始大小</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> -Xmx20M       // 堆内存最大值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> -Xmn10M       // 新生代大小是10m</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> -XX:+PrintGCDetails     // 打印GC详细信息</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> -XX:SurvivorRatio=8    // 8:1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> -XX:PretenureSizeThreshold=4194304   // 新生代创建对象的阈值大小，单位为字节，只有串行收集器才会生效</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> -XX:+UseSerialGC -XX:MaxTenuringThreshold  // 在可以自动调节对象晋升（Promote）到老年代阈值的GC中，设置该阈值的最大值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> -XX:PrintTenuringDistribution // 每次新生代GC时，打印出幸存区中对象的年龄分布</span></span><br></pre></td></tr></table></figure>
<p>查看java虚拟机启动参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version </span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210730185108.png" alt="image-20210730185108404" /></p>
<p>其中含义：</p>
<ul>
<li>
<p>PretenureSizeThreshold：设置对象超过多大的时候直接在老年代进行分配</p>
</li>
<li>
<p>MaxTenuringThreshold：CMS中默认值为6，G1中默认值为15（该数值是由4个bit来表示的，所以最大值1111，即15）</p>
</li>
</ul>
<h2 id="hotspot的算法实现细节"><a class="markdownIt-Anchor" href="#hotspot的算法实现细节"></a> HotSpot的算法实现细节</h2>
<p>经历了多次GC后，存活的对象会在From Survivor与To Survivor之间来回存放，而这里面的一个前提则是这两个空间由足够的大小来存放这些数据，在GC算法中，会计算每个对象年龄的大小，如果达到某个年龄后发现总大小已经大于了Survivor空间的50%，那么这时候就需要调整阈值，不能再继续等到默认的15次GC后才开始晋升，因为这样会导致Survivor空间不足，所以需要调整阈值，让这些存活对象尽快完成晋升。</p>
<h3 id="根节点枚举"><a class="markdownIt-Anchor" href="#根节点枚举"></a> 根节点枚举</h3>
<p>当执行系统停顿下来后，并不需要一个不露地检查完所有执行上下文和全局的引用位置，虚拟机应该当是有办法直接得知哪些地方存放着对象引用。再HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的。</p>
<h3 id="安全点"><a class="markdownIt-Anchor" href="#安全点"></a> 安全点</h3>
<p>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得更高；</p>
<p>实际上，HotSpot并没有为每条指令都生成OopMap，而只是在“特定的位置”记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都能停顿下来开始GC，只有在达到安全点时才能暂停；</p>
<p>安全点的选定既不能太少以至于让GC等待时间太长，也不能过于频繁以至于过分增大运行时的负载，所以，安全点的选定基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显的特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生安全点；</p>
<p>对于安全点，另一个需要考虑的问题就是如何让在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来：抢占式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。</p>
<p>抢占式中断：它不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果有线程中断的地方不在安全点上，就恢复线程，让它执行到安全点上，再进行中断。</p>
<p>主动式中断：当GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p>
<p>现在几乎没有虚拟机采用抢占式中断来暂停线程从而相应GC事件。</p>
<h3 id="安全区域"><a class="markdownIt-Anchor" href="#安全区域"></a> 安全区域</h3>
<p>在使用安全点似乎已经完美解决了如何进入GC的问题，但实际情况却并不一定，安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的安全点，但如果程序在“不执行”的时候呢？所谓程序不执行就是没有分配CPU时间，典型的例子就是处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，JVM也显然不太可能等待线程重新弄分配CPU时间，对于这种情况，就需要安全区域（Safe Region）来解决了。</p>
<p>在线程执行到安全区域中的代码时，首先标识自己已经进入了安全区域，那样，当在这段时间里JVM要发去GC时，就不用管标识自己为安全区域状态的线程了。在线程要离开安全区域时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待知道收到可以安全离开安全区域的信号为止。</p>
<p>安全区域是指能够确保某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。</p>
<p>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当做没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p>
<h3 id="记忆集与卡表"><a class="markdownIt-Anchor" href="#记忆集与卡表"></a> 记忆集与卡表</h3>
<h3 id="并发的可达性分析"><a class="markdownIt-Anchor" href="#并发的可达性分析"></a> 并发的可达性分析</h3>
<h3 id="空间分配担保"><a class="markdownIt-Anchor" href="#空间分配担保"></a> 空间分配担保</h3>
<p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。当大量对象在Minor GC后仍然存活，就需要老年代进行空间分配担保，把Survivor无法容纳的对象直接进入老年代。如果老年代判断到剩余空间不足（根据以往每一次回收晋升到老年代对象容量的平均值作为经验值），则进行一次Full GC。</p>
<h3 id="内存屏障"><a class="markdownIt-Anchor" href="#内存屏障"></a> 内存屏障</h3>
<h4 id="来源"><a class="markdownIt-Anchor" href="#来源"></a> 来源</h4>
<p>每个CPU都会有自己的缓存（有的甚至L1、L2、L3），缓存的目的就是为了提高性能，避免每次都要想内存存取。但这样做的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存之不同。</p>
<p>使用volatile关键字修饰变量可以解决上述问题，那么volatile是如何做到这一点的呢？那就是内存屏障，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样的，java通过屏蔽这些差异，统一由jvm来生成内存屏障指令。</p>
<h4 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型</h4>
<p>硬件层的内存屏障分为两种：Load Barrier和Store Barrier即读屏障和写屏障。</p>
<p>内存屏障主要由两个作用：</p>
<ul>
<li>阻止屏障两侧的指令重排序</li>
<li>强制把缓冲区/告诉缓存中的脏数据等写回主内存，让缓存中相应的数据失效</li>
</ul>
<p>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新主内存加载数据；对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</p>
<h4 id="java内存屏障"><a class="markdownIt-Anchor" href="#java内存屏障"></a> Java内存屏障</h4>
<p>Java的内存屏障通常所谓的四种即LoadLoad，StoreStore，LoadStore，StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p>
<ul>
<li>LoadLoad屏障：对于这样的语句Load1；LoadLoad；Load2，在Load2以及后续读取操要读取的数据被访问之前，保证Load1要读取的数据被读取完毕</li>
<li>StoreStore屏障：对于这样的语句Store1；StoreStore；Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它线程处理器可见</li>
<li>LoadStore屏障：对于这样的语句Load1；LoadStore；Store2，在Store2及后续写入操作被刷出前，保证Store1的写入操作对其它处理器可见</li>
<li>StoreLoad屏障：对于这样的语句Store1；StoreLoad；Load2，在Load2及后续所有读操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数的处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</li>
</ul>
<h4 id="volatile语义中的内存屏障"><a class="markdownIt-Anchor" href="#volatile语义中的内存屏障"></a> volatile语义中的内存屏障</h4>
<p>volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：</p>
<ul>
<li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障</li>
<li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障</li>
</ul>
<p>正是由于内存屏障的作用，避免了volatile变量个其它指令重排序、线程之间实现了通信，是的volatile表现除了锁的特性。</p>
<h4 id="final语义中的内存屏障"><a class="markdownIt-Anchor" href="#final语义中的内存屏障"></a> final语义中的内存屏障</h4>
<ul>
<li>新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；</li>
<li>初次包含final域的对象引用和读取这个final域，这两个操作不能重排序（先赋值引用，再调用final的值）；</li>
</ul>
<p>总之，必须要保证一个对象的所有final域被写入完毕后才能引用和读取，这也是内存屏障起的作用。</p>
<h2 id="性能监控-故障处理工具"><a class="markdownIt-Anchor" href="#性能监控-故障处理工具"></a> 性能监控、故障处理工具</h2>
<p>Java内存泄漏的经典原因：</p>
<ol>
<li>对象定义在错误的范围（Wrong Scope）</li>
<li>异常（Exception）处理不当</li>
<li>集合数据管理不当（1、当使用基于数组的数据结构的时候，使用合适的初始值，减少resize的过程 2、如果List只需要顺序访问，不需要随机访问的话，使用LinkedList代替ArrayList）</li>
</ol>
<h3 id="基础故障处理工具"><a class="markdownIt-Anchor" href="#基础故障处理工具"></a> 基础故障处理工具</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xms5m -Xmx5m -xx:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure>
<p>元空间大小设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:MaxMetaspaceSize=10m -XX:+TraceClassLoading</span><br></pre></td></tr></table></figure>
<p>获取java进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -ef | grep java jps -mlvV jps -l</span></span><br></pre></td></tr></table></figure>
<p>打印类加载器数据命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jmap -clstats PID  // cl表示classloader</span> </span><br></pre></td></tr></table></figure>
<p>打印堆内存命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jmap -heap PID</span>  </span><br></pre></td></tr></table></figure>
<p>打印元空间的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jstat -gc LVMID</span> </span><br></pre></td></tr></table></figure>
<p>jcmd是从jdk1.7开始增加的命令，可以用来查看进程的JVM启动参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd PID VM.flags</span> </span><br></pre></td></tr></table></figure>
<p>当前运行java进程可以执行的操作列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd PID <span class="built_in">help</span></span></span><br></pre></td></tr></table></figure>
<p>查看具体命令的选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd PID <span class="built_in">help</span> JFR.dump</span> </span><br></pre></td></tr></table></figure>
<p>查看JVM性能相关的参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd PID PerfCounter.print</span> </span><br></pre></td></tr></table></figure>
<p>查看JVM启动的时长：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd PID VM.uptime</span> </span><br></pre></td></tr></table></figure>
<p>查看系统中的类的统计信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd PID GC.class_histogram</span> </span><br></pre></td></tr></table></figure>
<p>查看当前线程的堆栈信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd PID Thread.print</span> </span><br></pre></td></tr></table></figure>
<p>导出Head dump 文件，导出的文件可以通过jvisualvm查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd PID GC.head_dump file_name</span> </span><br></pre></td></tr></table></figure>
<p>查看JVM的属性信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd PID VM.system_properties</span> </span><br></pre></td></tr></table></figure>
<p>查看JVM启动命令行的参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd PID VM.command_line</span> </span><br></pre></td></tr></table></figure>
<p>jclasslib查看工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap -verbose -p ...</span></span><br></pre></td></tr></table></figure>
<p>除此之外，还有一些其他的工具：</p>
<ul>
<li>jstack：可以查看或是导出Java应用程序中的堆栈信息</li>
<li>jmc：Java Mission Control</li>
<li>jfr：Java Flight Recorder 实时到统计数据</li>
<li>OQL：JVM 对象查询语言</li>
<li>jhat file_name</li>
</ul>
<h3 id="可视化故障处理工具"><a class="markdownIt-Anchor" href="#可视化故障处理工具"></a> 可视化故障处理工具</h3>
<h4 id="jvisualvm"><a class="markdownIt-Anchor" href="#jvisualvm"></a> jvisualvm</h4>
<h4 id="jconsole"><a class="markdownIt-Anchor" href="#jconsole"></a> jconsole</h4>
<h1 id="类文件结构-2"><a class="markdownIt-Anchor" href="#类文件结构-2"></a> 类文件结构</h1>
<h2 id="class类文件的结构"><a class="markdownIt-Anchor" href="#class类文件的结构"></a> Class类文件的结构</h2>
<p>《Java虚拟机规范》中要求在Class文件必须应用许多强制性的语法和结构化约束，但是图灵完备的字节码格式，保证了任意一门功能性语言都可以表示一个能被虚拟机所接收的有效的Class文件，具体如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210730193726.png" alt="image-20210730193726096" style="zoom:50%;" />
<blockquote>
<p>在可计算性理论，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟任何图灵机，那么它是图灵完备的。这意味着这个系统也可以识别其他数据处理规则集，图灵完备性被用作表达这种数据处理规则集的一种属性</p>
</blockquote>
<p>使用<code>javap -verbose</code>命令分析一个字节码文件时，将会分析该字节码文件的魔数、版本号、常量池、类信息、类的构造方法，类中的方法信息、类变量与成员变量等信息。</p>
<blockquote>
<p><code>&lt;init&gt;</code>表示实例构造方法，<code>&lt;clint&gt;</code>表示静态构造方法。</p>
</blockquote>
<p>整个Class文件可以使用如下结构描述：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210802220940.png" alt="image-20210802220940252" /></p>
<p>Class字节码中有两种数据类型：</p>
<ul>
<li>字节数据直接量：这是基本数据类型。共细分为u1、u2、u4、u8四种，分别代表连续的1个字节、2个字节、4个字节、8个字节组成的整体数据。</li>
<li>表（数组）：表是由多个基本数据或其他表，按照既定顺序组成的大的数据集合。表是有结构的，它的结构体现在：组成表的成分所在的位置和顺序都是已经严格定义好的。</li>
</ul>
<h3 id="魔数与class文件的版本"><a class="markdownIt-Anchor" href="#魔数与class文件的版本"></a> 魔数与Class文件的版本</h3>
<p>所有的.class字节码文件前4个字节都是魔数，魔数值为固定值：oxCAFEBABE。</p>
<p>魔数之后的4个字节为版本信息，前两个字节表示minor version版本，后两个字节表表示major version。主版本号为52表示该文件的版本号为1.8.0。可以通过<code>java -version</code>命令来验证这一点。</p>
<h3 id="常量池"><a class="markdownIt-Anchor" href="#常量池"></a> 常量池</h3>
<p>常量池（constant pool）：紧接着主版本号之后的就是常量池入口。一个Java类中定义的很多信息都是由常量池来维护和描述的。可以将常量池看作是class文件的资源仓库，比如Java类中定义的方法与变量信息，都是存储在常量池中。</p>
<p>常量池中主要存储两类常量：字面量与符号引用，字面量如文本字符串，Java中声明为final的常量值等，而符号引用主要包括下面几类变量：</p>
<ul>
<li>被模块导出或者开放的包</li>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型</li>
<li>动态调用点和动态常量</li>
</ul>
<blockquote>
<p>Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话无法得到真正的内存入口地址，也就无法被虚拟机直接使用。当虚拟机进行类加载的时候，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
</blockquote>
<p>常量池的总体结构：Java类所对应的常量池主要由常量池数量与常量池数组这两部分共同构成。常量池数量紧跟在主版本号后面，占据2个字节，常量池数组紧跟在常量池数量之后。常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型、结构都是不同的，长度当然也就不同，但是每一种元素的第一个数据都是一个u1类型，该字节是个标志位，占据1个字节，JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。</p>
<p>值得注意的是，常量池数组中元素的个数 = 常量池数-1（其中0暂时不使用），目的是为了满足某些常量池索引值在特定情况下需要表达<em>不引用任何一个常量池</em>的含义；根本原因在于，索引为0也是一个常量（保留常量），只不过它不位于常量表中，这个常量就对应null值，所以，常量池的索引从1而非0开始。</p>
<h3 id="访问标志"><a class="markdownIt-Anchor" href="#访问标志"></a> 访问标志</h3>
<p>Access_Flag访问标志信息包括，该Class文件是类还是接口，是否被定位成public，是否是abstract，如果是类，是否被声明为final。</p>
<p>访问标志以及标志的含义如表：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210801115314.png" alt="image-20210801115314201" style="zoom: 67%;" />
<p>访问标志是0x0021的含义：0x0020和0x0001的并集，表示ACC_PUBLIC与ACC_SUPER的并集。</p>
<h3 id="类索引-父类索引与接口索引集合"><a class="markdownIt-Anchor" href="#类索引-父类索引与接口索引集合"></a> 类索引、父类索引与接口索引集合</h3>
<p>通过类索引可以得到类的全限定类名，通过父类索引可以得到父类的全限定类名，由于Java支持多接口，因此这里设计成了接口计数器和接口索引集合来实现，通过这三项就可以确定这个类的继承关系。</p>
<h3 id="字段表集合"><a class="markdownIt-Anchor" href="#字段表集合"></a> 字段表集合</h3>
<p>字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量以及实例变量，但是不包括方法内部声明的局部变量。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210802215541.png" alt="image-20210802215541429" style="zoom:67%;" />
<blockquote>
<p>字段表集合中不会列出从父类或者父接口中继承而来的字段。</p>
</blockquote>
<h3 id="方法表集合"><a class="markdownIt-Anchor" href="#方法表集合"></a> 方法表集合</h3>
<p>在JVM规范中，每个变量/字段都有描述信息，描述信息主要的作用是描述字段的数据类型、方法的参数列表（包括数量、类型与顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符来表示，对象类型则使用字符L加对象的全限定名称来表示。为了压缩字节码文件的体积，对于基本数据类型，JVM都只使用一个大写字母来表示，如下所示：B-byte，C-char，D-double，F-float，I-int，J-long，S-short，Z-boolean，V-void，L-对象类型，如Ljava/lang/String；</p>
<p>对于数组类型来说，每一个维度使用一个前置的[来表示，如int[]被记录为[I，String[][]，被记录为[[Ljava/lang/String；</p>
<p>用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组()之内，如方法：String getRealnamebyIdaAndNickname(int id,String name)的描述符为：（I，Ljava/lang/String;）Ljava/langString;</p>
<p>方法表结构如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210802215205.png" alt="image-20210802215205812" style="zoom:67%;" />
<blockquote>
<p>如果父类方法在子类中没有被重写，方法表集合就不会出现父类的方法。</p>
</blockquote>
<h3 id="属性表集合"><a class="markdownIt-Anchor" href="#属性表集合"></a> 属性表集合</h3>
<p>属性表的结构如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210802220825.png" alt="image-20210802220825871" /></p>
<p>属性表的类型较多，这里以字段表属性为例，Code attribute的作用是保存该方法的结构：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210802222155.png" alt="image-20210802222155363" style="zoom:67%;" />
<p>具体含义如下：</p>
<ul>
<li>attribute_length表示attribute所包含的字节数，不包含attribute_name_index和attribute_length字段；</li>
<li>max_stack表示这个方法进行的任何时刻所能达到的操作数栈的最大深度；</li>
<li>max_locals表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量；</li>
<li>code_length表示该方法所包含的字节码的字节数及具体的指令码；</li>
<li>code表示具体字节码，即是该方法被调用时，虚拟机所执行的字节码；</li>
<li>exception_table，这里存放的是处理异常的信息；</li>
</ul>
<p>除了方法属性表之外，还有异常属性表，在java字节码对于异常的处理方式：</p>
<ul>
<li>统一采用异常表的方式来对异常进行处理</li>
<li>在jdk1.4.2之前的版本中，并不是使用异常表的方式来对异常进行处理的，而是采用特定的指令的方式</li>
<li>当异常处理存在finally语句块时，现在化的JVM采取处理方式时将finally语句块的字节码拼接到每一个catch块后面。换句话说，程序中存在多少个catch块后面重复多少个finally语句块的字节码。</li>
</ul>
<blockquote>
<p>除了上述提到的方法属性表、异常属性表之外，实际上Java虚拟机中预定义的属性有20多个，除了JVM预定义的属性，编译器还自己可以实现自己的属性写入class文件里，供运行时使用，不同的属性通过attribute_name_index来区分。</p>
</blockquote>
<h2 id="字节码指令"><a class="markdownIt-Anchor" href="#字节码指令"></a> 字节码指令</h2>
<h3 id="字节码与数据类型"><a class="markdownIt-Anchor" href="#字节码与数据类型"></a> 字节码与数据类型</h3>
<p>JVM助记符：</p>
<ul>
<li>
<p>invokeinterface：调用接口中的方法，实际上是在运行期决定的，决定到底调用实现该接口中的哪个对象的特定的方法；</p>
</li>
<li>
<p>invokestatic：调用静态方法；</p>
</li>
<li>
<p>invokespecial：调用自己的私有方法、构造方法（<code>&lt;init&gt;</code>）以及父类的方法；</p>
</li>
<li>
<p>invokevirtual：调用虚方法，运行期间动态查找的过程；</p>
</li>
<li>
<p>invokedynamic：动态调用方法。</p>
</li>
</ul>
<p>静态解析的四种情形：</p>
<p>1、静态方法</p>
<p>2、父类方法</p>
<p>3、构造方法</p>
<p>4、私有方法（无法被重写）</p>
<p>以上四类方法称为非虚方法，他们是在类加载阶段就可以将符号引用换转为直接直接引用，这种情形就被称之为静态解析。</p>
<p>方法的静态分派：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Grandpa g1 = <span class="keyword">new</span> Father(); </span><br></pre></td></tr></table></figure>
<p>以上代码，g1的静态类型是Grandpa，而g1的实际类型（真正指向的类型）是Father。</p>
<p>结论：变量的静态类型是不会发生变化的，而变量的实际类型则是可以发生变化的（多态的一种体现）,实际类型是在运行期可确定。</p>
<p>方法重载对于JVM来讲是一种静态的行为，因此调用重载方法，变量类型是根据传入变量的静态类型来确定的。方法重载在编译期就可以完全确定的。</p>
<p>方法的动态分派：方法接收者指的是这个方法到底是由哪一个对象来的调用的，invokevirtual字节码指令的多态查找流程，在运行期间，首先找到操作数栈顶的第一个元素所指向的真正的类型，然后在实际的类型当中寻找到特定的方法，如果能找到，那就将符号引用转换为直接引用，如果找不到，就开始按照继承体系，在父类里面开始从下网上开始寻找，可以找到就转换为直接引用，如果没有找到，则抛出异常。</p>
<p>方法重载和方法重写的结论：方法重载是静态的，是编译期行为；方法重写是动态的，是运行期行为。</p>
<p>针对于方法调用的动态分派的过程，虚拟机在类的方法区简历一个虚方法表的数据结构（virtual method table，vtable）</p>
<p>针对于invokeinterface指令来说，虚拟机会建立一个接口方法表的数据结构（interface method table，itable）</p>
<p>编译执行，解释执行</p>
<p>现在JVM在执行java代码的时候，通常都会将解释执行与编译执行二者结合来进行。</p>
<p>所谓解释执行，就是通过解释器来读取字节码，遇到相应的指令就去执行该指令；</p>
<p>所谓编译执行，是通过即时编译器（Just In Time，JIT）将字节码转换为本地机器码来执行，现在JVM会根据代码热点来生成响应的本地机器码。</p>
<p>基于栈的指令集（内存当中执行），基于寄存器的指令集（CPU当中执行）的关系：</p>
<p>1、JVM执行指令时所采取的方式是基于栈的指令集；</p>
<p>2、基于栈的指令集主要的操作有入栈与出栈两种；</p>
<p>3、基于栈的指令集的优势在于它可以在不同平台之间一直，而基于寄存器的指令集是与硬件架构关联的，无法做到可移植；</p>
<p>4、基于栈的指令集的缺点在于完成相同的操作，指令数量通常要比基于寄存器的指令集数量要多；基于栈的指令集是在内存中完成操作的，而基于寄存器的指令集是直接由CPU来执行的，它是在高速缓冲区中进行执行的，速度要快很多。虽然虚拟机以采用一些优化手段，但总体来说，基于栈的指令集的执行速度要慢一些。</p>
<h1 id="类加载机制-2"><a class="markdownIt-Anchor" href="#类加载机制-2"></a> 类加载机制</h1>
<h2 id="类加载过程"><a class="markdownIt-Anchor" href="#类加载过程"></a> 类加载过程</h2>
<p>加载：查找并加载类的二进制数据</p>
<p>连接：</p>
<ul>
<li>验证：确保被加载的类的正确性</li>
<li>准备：为类的静态资源变量分配内存，并将其初始化为默认值</li>
<li>解析：把类中的符号引用转换为直接引用</li>
</ul>
<p>初始化：为类的静态变量赋予正确的初始值</p>
<h3 id="加载"><a class="markdownIt-Anchor" href="#加载"></a> 加载</h3>
<p>在类的加载阶段，Java虚拟机需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<p>加载.class文件的方式：</p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
<p>类加载器并不需要某个类被“首次主动使用”时再去加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误。</p>
<p>当一个类在初始化时，要求其父类全部都初始化完毕，当一个接口在初始化时，并不要求其父接口都完成了初始化。</p>
<h3 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h3>
<p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息复合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p>验证阶段大致会完成下面四个阶段的检验动作：</p>
<ul>
<li>
<p>文本格式验证</p>
<p>主要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</p>
</li>
<li>
<p>元数据验证</p>
<p>对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求</p>
</li>
<li>
<p>字节码验证</p>
<p>通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
</li>
<li>
<p>符号引用验证</p>
<p>确保符号引用转化为直接引用的时候可以正常执行。</p>
</li>
</ul>
<h3 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h3>
<p>准备阶段是正式为类中定义的变量（即静态变量，被static变量）分配内存并设置类变量初始值的阶段，这里所说的初始值“通常情况”下是数据类型的零值。</p>
<p>不同数据类型的零值如下：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210802181522.png" alt="image-20210802181522346" /></p>
<h3 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h3>
<p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3>
<p>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p>
<p>Java程序对类的使用方式可分为两种：主动使用、被动使用，所有的Java虚拟机实现必须在每个类或者接口被Java程序“首次主动使用”时才初始化他们，主动使用的情况有以下七种：</p>
<ol>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类（Java Test）</li>
<li>JDK1.7开始提供的动态语言支持：Java.lang.invoke.MethodHandle实例的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic句柄对应的类没有初始化则初始化</li>
</ol>
<p>除了以上其中情况，其他使用Java类的方式都被看作时对类的被动使用，都不会导致类的初始化。</p>
<h2 id="类加载器"><a class="markdownIt-Anchor" href="#类加载器"></a> 类加载器</h2>
<h3 id="类与类加载器"><a class="markdownIt-Anchor" href="#类与类加载器"></a> 类与类加载器</h3>
<p>自底向上检查类是否已经加载，自项向下尝试加载类。</p>
<p>启动类加载器：$JAVA_HOME中jre/lib/rt.jar里所有的class，由c++实现，不是classloader的子类；</p>
<p>扩展类加载器：加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包；</p>
<p>系统类加载器：负责加载classpath中指定的jar包及目录中class；</p>
<p>若有一个类加载器能够成功加载Test类，那么这个类加载器被称为定义类加载器，所有能成功返回Class对象引用的类加载器（包括定义类加载器）都成为初始类加载器。</p>
<p>加载器之间的父子关系实际上是包装关系。</p>
<h3 id="双亲委派模型"><a class="markdownIt-Anchor" href="#双亲委派模型"></a> 双亲委派模型</h3>
<p>站在Java虚拟机的角度看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），另一种是其他的类加载器，这些类都由Java语言实现，并且继承自抽象类java.lang.ClassLoader。</p>
<p>站在开发人员的角度来看，类加载会被划分的更加细致一些，不同类加载器之间的作用如下表：</p>
<table>
<thead>
<tr>
<th>类加载器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动类加载器</td>
<td>加载&lt;JAVA_HOME&gt;\lib目录，或者被<code>-Xbootclasspath</code>参数所执行的路径中存放的，并且能够被Java虚拟机能够识别的类</td>
</tr>
<tr>
<td>扩展类加载器</td>
<td>加载&lt;JAVA_HOME&gt;\lib\ext目录中，或者被<code>java.ext.dirs</code>系统变量所执行的路径中所有的类库</td>
</tr>
<tr>
<td>应用类加载器</td>
<td>加载用户类路径上所有的类库</td>
</tr>
</tbody>
</table>
<p>在双亲委派机制中，各个加载器按照父子关系形成了树形结构，除了根类加载器之外，其余的类加载器都有且只有一个父加载器。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210731161405.png" alt="image-20210731161405825" style="zoom:33%;" />
<p>双亲委派机制的有点是能够提高软件系统的安全性。因为在此机制下，用户自定义的类加载器不可能加载应该由父加载器加载的可靠类，从而防止不可靠甚至恶意的代码代替由父加载器的可靠代码。</p>
<p>每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成。</p>
<p>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类，在不同的命名空间中，有可能会出出现类的完整名字（包括类的包名）相同的两个类</p>
<p>同一个命名空间内的类是相互可见的。</p>
<p>子加载器的命名空间包含所有父加载器的命名空间。因此由子加载器加载的类能看见父加载器加载的类，由父加载器加载的类不能看见子加载器加载的类</p>
<p>如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类相互不可见。</p>
<p>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期</p>
<p>由JAVA虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。</p>
<h3 id="破坏双亲委派模型"><a class="markdownIt-Anchor" href="#破坏双亲委派模型"></a> 破坏双亲委派模型</h3>
<p>在Java的世界中，大部分的类加载器都遵循双亲委派模型，但也有例外情况：</p>
<ul>
<li>
<p>双亲委托模型之前的自定义类加载器：java.lang.ClassLoader#findClass</p>
</li>
<li>
<p>SPI场景：</p>
<ul>
<li>java.lang.Thread#setContextClassLoader</li>
<li>java.util.ServiceLoader以及META-INF/services</li>
</ul>
</li>
<li>
<p>模块化</p>
</li>
</ul>
<h2 id="spi机制"><a class="markdownIt-Anchor" href="#spi机制"></a> SPI机制</h2>
<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3>
<blockquote>
<p>SPI全称为Service Provider Interface，是一种服务发现机制。SPI的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取文件，加载实现类。这样可以在运行时，<em>动态为接口替换实现类</em>。正因此特性，我们可以很容易的通过SPI机制为我们的程序提供扩展功能。</p>
</blockquote>
<p>为了理解SPI的使用场景，这里假设我们设计了一款全新的日志框架，默认以XML文件作为这款日志框架的配置文件，并且设计了一个配置文件解析的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SuperLoggerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">configure</span><span class="params">(String configFile)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认是XML的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLConfiguration</span> <span class="keyword">implements</span> <span class="title">SuperLoggerConfiguration</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(String configFile)</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在初始化解析配置的时候，只需要调用XMLConfiguration这个来解析XML配置文件即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SuperLoggerConfiguration configuration = <span class="keyword">new</span> XMLConfiguration();</span><br><span class="line">        configuration.configure(configFile);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getLogger</span><span class="params">(Class clazz)</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设用户/使用方想增加一个yml文件的方式，作为日志配置文件，使用上述方式，在注入的时候，LoggerFactory就无法加载新的实现类YAMLConfiguration，这个时候就需要借助SPI机制完成。</p>
<h3 id="jdk-spi"><a class="markdownIt-Anchor" href="#jdk-spi"></a> JDK SPI</h3>
<p>JDK提供了一个SPI功能，核心类是java.util.ServiceLoader。其作用就是，可以通过类名获取在<code>META-INF/service</code>下的多个配置实现文件。</p>
<p>为了解决上面的扩展问题，现在在<code>META-INF/service</code>目录下创建一个com.github.kongwu.spisamples.SuperLoggerConfiguration文件（无后缀名）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">META-INF/services/com.github.kongwu.spisamples.SuperLoggerConfiguration:</span><br><span class="line"></span><br><span class="line">com.github.kongwu.spisamples.XMLConfiguration</span><br></pre></td></tr></table></figure>
<p>然后通过ServiceLoader 获取我们的 SPI 机制配置的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceLoader&lt;SuperLoggerConfiguration&gt; serviceLoader = ServiceLoader.load(SuperLoggerConfiguration.class);</span><br><span class="line">Iterator&lt;SuperLoggerConfiguration&gt; iterator = serviceLoader.iterator();</span><br><span class="line">SuperLoggerConfiguration configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    <span class="comment">//加载并初始化实现类</span></span><br><span class="line">    configuration = iterator.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对最后一个configuration类调用configure方法</span></span><br><span class="line">configuration.configure(configFile);</span><br></pre></td></tr></table></figure>
<p>最后在调整LoggerFactory中初始化配置的方式为现在的SPI方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ServiceLoader&lt;SuperLoggerConfiguration&gt; serviceLoader = ServiceLoader.load(SuperLoggerConfiguration.class);</span><br><span class="line">        Iterator&lt;SuperLoggerConfiguration&gt; iterator = serviceLoader.iterator();</span><br><span class="line">        SuperLoggerConfiguration configuration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            configuration = iterator.next();<span class="comment">//加载并初始化实现类</span></span><br><span class="line">        &#125;</span><br><span class="line">        configuration.configure(configFile);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getLogger</span><span class="params">(Class clazz)</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了支持 YAML 配置，现在在使用方/用户的代码里，增加一个YAMLConfiguration的 SPI 配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">META-INF/services/com.github.kongwu.spisamples.SuperLoggerConfiguration:</span><br><span class="line"></span><br><span class="line">com.github.kongwu.spisamples.ext.YAMLConfiguration</span><br></pre></td></tr></table></figure>
<p>此时通过iterator方法，就会获取到默认的XMLConfiguration和我们扩展的这个YAMLConfiguration两个配置实现类了。</p>
<p>在上面那段加载的代码里，我们遍历iterator，遍历到最后，我们**使用最后一个实现配置作为最终的实例，但是使用方/用户自定义的YAMLConfiguration是否是最后一个，这取决于运行时的ClassPath 配置，这就是JDK的SPI机制的一个明显的劣势，无法确认具体加载哪一个实现，也无法加载某个指定的实现，仅靠ClassPath的顺序是一个非常不严谨的方式。</p>
<h3 id="spring-spi"><a class="markdownIt-Anchor" href="#spring-spi"></a> Spring SPI</h3>
<p>Spring的SPI配置文件是一个固定的文件 - <code>META-INF/spring.factories</code>，功能上和JDK的类似，每个接口可以有多个扩展实现，使用起来非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有factories文件中配置的LoggingSystemFactory</span></span><br><span class="line">List&lt;LoggingSystemFactory&gt;&gt; factories = </span><br><span class="line">    SpringFactoriesLoader.loadFactories(LoggingSystemFactory.class, classLoader);</span><br></pre></td></tr></table></figure>
<p>SpringBoot中spring.factories示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Logging Systems</span><br><span class="line">org.springframework.boot.logging.LoggingSystemFactory=\</span><br><span class="line">org.springframework.boot.logging.logback.LogbackLoggingSystem.Factory,\</span><br><span class="line">org.springframework.boot.logging.log4j2.Log4J2LoggingSystem.Factory,\</span><br><span class="line">org.springframework.boot.logging.java.JavaLoggingSystem.Factory</span><br><span class="line"></span><br><span class="line"># PropertySource Loaders</span><br><span class="line">org.springframework.boot.env.PropertySourceLoader=\</span><br><span class="line">org.springframework.boot.env.PropertiesPropertySourceLoader,\</span><br><span class="line">org.springframework.boot.env.YamlPropertySourceLoader</span><br><span class="line"></span><br><span class="line"># ConfigData Location Resolvers</span><br><span class="line">org.springframework.boot.context.config.ConfigDataLocationResolver=\</span><br><span class="line">org.springframework.boot.context.config.ConfigTreeConfigDataLocationResolver,\</span><br><span class="line">org.springframework.boot.context.config.StandardConfigDataLocationResolver</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>Spring将所有的配置都放到了一个固定的文件中，并且支持Classpath中存在多个spring.factories文件的，加载时会按照classpath的顺序依次加载这些spring.factories文件，添加到一个ArrayList中。由于没有别名，所以也没有去重的概念，有多少就添加多少。</p>
<p>SpringBoot中的ClassLoader会优先加载项目中的文件，而不是依赖包中的文件。所以在项目中定义spring.factories文件，那么这个文件会被第一个加载，得到的Factories中，项目中spring.factories里配置的那个实现类也会排在第一个。</p>
<p>如果我们要扩展某个接口的话，只需要在项目里新建一个<code>META-INF/spring.factories</code>文件，只添加新的配置，不需要完整的复制一遍Spring Boot的spring.factories文件然后修改。</p>
<p>例如添加一个LoggingSystemFactory 实现，只需要新建<code>META-INF/spring.factories</code>文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.logging.LoggingSystemFactory=\</span><br><span class="line">com.example.log4j2demo.Log4J2LoggingSystem.Factory</span><br></pre></td></tr></table></figure>
<h1 id="虚拟机字节码执行引擎"><a class="markdownIt-Anchor" href="#虚拟机字节码执行引擎"></a> 虚拟机字节码执行引擎</h1>
<h2 id="运行时栈帧结构"><a class="markdownIt-Anchor" href="#运行时栈帧结构"></a> 运行时栈帧结构</h2>
<p>Java虚拟机方法作为最基本的执行单元，“栈帧”则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈中的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。</p>
<p>一个线程中的方法调用链可能会很长，以Java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈方法的所有方法都同时处于执行状态。而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”，与这个栈帧所关联的方法被称为“当前方法”。执行引擎所运行的所有字节码指令都针对当前栈帧进行操作，典型的栈帧结构表示如下图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210804235025.png" alt="栈帧的概念结构" style="zoom: 50%;" />
<h3 id="局部变量表"><a class="markdownIt-Anchor" href="#局部变量表"></a> 局部变量表</h3>
<p>局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。</p>
<p>局部变量表的容量以变量槽为最小单位，一个变量槽可以存放一个32以内的数据类型，Java中占用不超过32位存储空间的数据类型有boolean、byte、char、short、int、float、reference和returnAddress。其中，第7中reference类型标识对一个对象实例的引用，通过这个引用，虚拟机可以：</p>
<ul>
<li>根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引</li>
<li>根据引用直接或间接地查找到对象所属数据类型在方法区中地存储地类型信息</li>
</ul>
<p>第8中returnAddress在某些古老的Java虚拟机曾经用来实现异常处理时的跳转。</p>
<p>对于64位的数据类型，Java虚拟机会以高位对齐的方式为其分配两个连续的变量的槽空间。Java语言中明确64位的数据类型只有long和double两种。</p>
<p>Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位数据类型的变量，则说明会同时使用第N和N+1两个变量槽。对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机不允许采用任何方式单独访问其中一个。</p>
<p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果执行的是实例方法（非static方法），那局部变量表中第0位索引的变量槽默认就是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</p>
<p>为了尽可能节省栈帧耗用的内存空间，局部变量表中的变量槽是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。不过，这样的设计除了节省栈帧空间意外，还会伴随有少量额外的副作用。</p>
<h3 id="操作数栈"><a class="markdownIt-Anchor" href="#操作数栈"></a> 操作数栈</h3>
<p>操作数栈也常被称为操作数栈，它是一个后入先出的数据结构，同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所栈的栈容量为2。</p>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈式空的，在方法的执行过程中，会有各种字节码执行往操作数栈中写入和提取内容，也就是出栈和入栈操作。</p>
<p>举例来说，在JVM中 执行 a = b + c 的字节码执行过程中操作数栈以及局部变量表的变化如下图所示。</p>
<p>局部变量表中存储着a、b、c 三个局部变量，首先将b和c分别入栈：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210805170308.png" alt="image-20210805170308818" style="zoom: 67%;" />
<p>将栈顶的两个数出栈执行加法操作，并将结果保存至栈顶，之后将栈顶的数出栈赋值给a：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210805170345.png" alt="image-20210805170345449" style="zoom:67%;" />
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器必须要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。</p>
<p>另外在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但是在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样做不仅节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了，重叠的过程如图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210805170917.png" alt="image-20210805170917346" style="zoom:50%;" />
<h3 id="动态连接"><a class="markdownIt-Anchor" href="#动态连接"></a> 动态连接</h3>
<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符合引用作为参数。这些符号一部分在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另一部分将在每一次运行期间都转化为直接引用，这部分称为动态连接。</p>
<p>动态连接的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Cat(); </span><br><span class="line">a.sleep; </span><br><span class="line">a = <span class="keyword">new</span> Dog();</span><br><span class="line">a.sleep;</span><br><span class="line">a = <span class="keyword">new</span> Tiger();</span><br><span class="line">a.sleep;</span><br></pre></td></tr></table></figure>
<p>在程序编译期间，实际上调用的是Animal的sleep方法，执行期间会通过invokevirtual来检查真正的方法的指向。</p>
<h3 id="方法返回地址"><a class="markdownIt-Anchor" href="#方法返回地址"></a> 方法返回地址</h3>
<p>当一个方法开始执行后，只有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会返回值传递给上层的方法调用者（调用当前方法的方法称为调用者或者主调方法），方法是否有返回值以及返回值的类型根据遇到何种方法返回指令来决定，这种退出方法的方式称为“正常调用完成”。</p>
<p>另一种退出方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体没得到妥善处理。这种退出方法的方式称为“异常调用完成”。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者提供任何返回值的。</p>
<p>无论采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用时的为止，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。一般来说，方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p>
<p>方法退出的过程实际上等同于把当前栈帧出战，因此退出时可能执行的操作有：</p>
<ul>
<li>恢复上层方法的局部变量表和操作数栈</li>
<li>将返回值（如果有的话）压入调用者栈帧的操作数栈中</li>
<li>调整PC计数器的值以指向方法调用指令后面的一条指令</li>
</ul>
<p>可能还有一些其他操作，这取决于具体的虚拟机的实现。</p>
<h3 id="附加信息"><a class="markdownIt-Anchor" href="#附加信息"></a> 附加信息</h3>
<p>《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调用、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。</p>
<p>一般会把动态连接、方法返回地址与其他附件信息全部归为一类，称为栈帧信息。</p>
<h2 id="方法调用"><a class="markdownIt-Anchor" href="#方法调用"></a> 方法调用</h2>
<p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定调用哪一个方法，暂时还未涉及方法内部的具体的运行过程。一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（也就是直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变的相对复杂，某些调用需要在类加载期间，甚至知道运行期间才能确定目标方法的直接引用。</p>
<h3 id="解析-2"><a class="markdownIt-Anchor" href="#解析-2"></a> 解析</h3>
<p>所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前题是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析。</p>
<p>符合这种要求的方法主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。</p>
<p>调用不同类型的方法，字节码指令集里设计了不同的指令：</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">invokestatic</td>
<td>用于调用静态方法</td>
</tr>
<tr>
<td style="text-align:center">invokespecial</td>
<td>用于调用实例构造器<code>&lt;init&gt;()</code>方法、私有方法和父类中的方法</td>
</tr>
<tr>
<td style="text-align:center">invokevirtual</td>
<td>用于调用所有的虚方法</td>
</tr>
<tr>
<td style="text-align:center">invokeinterface</td>
<td>用于调用接口方法，会在运行时再确定一个实现该接口的对象</td>
</tr>
<tr>
<td style="text-align:center">invokedynamic</td>
<td>先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法</td>
</tr>
</tbody>
</table>
<p>可以在类加载的时候就把符号引用解析为直接引用的方法类型：</p>
<ul>
<li>静态方法</li>
<li>私有方法</li>
<li>实例构造器</li>
<li>父类方法</li>
<li>final修饰的方法</li>
</ul>
<blockquote>
<p>这些方法统称为“非虚方法”，除了这些方法外的其他方法就被称为“虚方法”。</p>
</blockquote>
<h3 id="分派"><a class="markdownIt-Anchor" href="#分派"></a> 分派</h3>
<p>解析调用一定是个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把设计的符号引用全部变为明确的直接引用，不必延迟到运行期再去完成。除了解析调用之外，还有分派，它可能是静态的也可能是动态的，根据分派依据的宗量数可分为单分派和多分派。这两类分两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4中分派组合情况。</p>
<p>不同分派之间的对比：</p>
<table>
<thead>
<tr>
<th>分派</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态分派</td>
<td>重载</td>
</tr>
<tr>
<td>动态分派</td>
<td>重写</td>
</tr>
<tr>
<td>单分派</td>
<td>根据一个宗量对目标方法进行选择，即为单分派</td>
</tr>
<tr>
<td>动态分派</td>
<td>根据多于一个宗量对目标方法进行选择，即为多分派</td>
</tr>
</tbody>
</table>
<blockquote>
<p>方法的接收者与方法的参数统称为方法的宗量。</p>
</blockquote>
<h1 id="java内存模型与线程"><a class="markdownIt-Anchor" href="#java内存模型与线程"></a> Java内存模型与线程</h1>
<h2 id="java内存模型"><a class="markdownIt-Anchor" href="#java内存模型"></a> Java内存模型</h2>
<h3 id="主内存与工作内存"><a class="markdownIt-Anchor" href="#主内存与工作内存"></a> 主内存与工作内存</h3>
<p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。</p>
<blockquote>
<p>此处的变量包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。</p>
</blockquote>
<p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有子集的工作内存，线程的工作内存中保存了该线程使用的变量的主内存副本，线程堆变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210805230911.png" alt="image-20210805230911338" style="zoom:50%;" />
<h3 id="volatile型变量"><a class="markdownIt-Anchor" href="#volatile型变量"></a> volatile型变量</h3>
<p>当一个变量被定义成volatile之后，它将具备两项特性：</p>
<ul>
<li>保证此变量对所有线程的可见性</li>
<li>禁止指令重排序优化</li>
</ul>
<h2 id="java与线程"><a class="markdownIt-Anchor" href="#java与线程"></a> Java与线程</h2>
<h3 id="线程的实现"><a class="markdownIt-Anchor" href="#线程的实现"></a> 线程的实现</h3>
<p>实现线程主要有三种方式：</p>
<ul>
<li>使用内核线程实现（1：1实现）</li>
<li>使用用户线程实现（1：N实现）</li>
<li>使用用户线程加轻量级进程混合实现（N：M实现）</li>
</ul>
<h3 id="java线程调度"><a class="markdownIt-Anchor" href="#java线程调度"></a> Java线程调度</h3>
<p>线程调度是指系统为线程分配处理器使用权的过程，调度方式主要有两种：</p>
<ul>
<li>协同式线程调度</li>
<li>抢占式线程调度</li>
</ul>
<p>Java线程调度是系统自动完成的，一共设置了10个级别的线程优先级，线程优先级并不是一项稳定的调节手段，例如windows中只有七种优先级，这意味着有几个线程的优先级会对应到同一个操作系统优先级。</p>
<h3 id="线程状态"><a class="markdownIt-Anchor" href="#线程状态"></a> 线程状态</h3>
<p>线程的不同状态可以转化，具体关系如下图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210805233636.png" alt="image-20210805233636533" style="zoom:50%;" />
<h1 id="线程安全与锁优化"><a class="markdownIt-Anchor" href="#线程安全与锁优化"></a> 线程安全与锁优化</h1>
<h2 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h2>
<p>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协同操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。</p>
<p>线程安全的实现方式：</p>
<ul>
<li>互斥同步</li>
<li>非阻塞同步</li>
<li>无同步方案</li>
</ul>
<h3 id="互斥同步"><a class="markdownIt-Anchor" href="#互斥同步"></a> 互斥同步</h3>
<p>互斥同步是指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。同步的实现方式是通过互斥来实现的，常见的互斥方式有：</p>
<ul>
<li>临界区（critical selection）</li>
<li>互斥量（mutex）</li>
<li>信号量（semaphore）</li>
</ul>
<p>java中最基本的互斥手段就是synchronized关键字，synchronized经过编译之后，会在同步块前后分别形成monitorenter和monitorexit两个字节码命令，这两个字节码指令都需要一个reference类型的参数来指明需要锁定和解锁的对象。如果synchronized明确指出了对象参数，那就是这个对象的引用，如果没有，那就根据所修饰的是实例方法还是类方法，去获取相应的对象实例或者Class对象作为锁对象。</p>
<p>synchronized对同一线程是可重入的，不会出现自己把自己锁死的情况。同步块在执行结束前，会阻塞其它线程的进入。由于java的线程是要映射到操作系统的原生线程的，如果阻塞或者一个线程，都需要操作系统来帮助完成，这就需要从用户态转换为内核态，这个转换需要消耗大量的CPU时间，对于代码简单的同步块，可能这个时间要大于执行时间，因此说，synchronized是一个重量级操作，一般只在确实必要的情况下使用。</p>
<p>除了使用synchronized，还可以使用ReentrantLock来实现同步。相比synchronized，ReentrantLock提供了一些比较灵活高级的功能，主要有：</p>
<ul>
<li>等待可中断：持有锁的线程长期不释放锁的时候，等待的线程可以选择放弃等待</li>
<li>公平锁：多个线程获取锁的时候，必须按照申请锁的时间来依次获取锁</li>
<li>绑定多个条件：一个ReentrantLock对象可以绑定多个Condition对象，而synchronized中，锁对象的wait()跟notify()可以实现一个隐含的条件，如果要和多余一个的条件关联时，就不得不额外加锁，而ReentrantLock只需要多次的new Condition就可以了</li>
</ul>
<p>性能上，1.5的时候ReentrantLock略好，JDK1.6以后两者持平，而且虚拟机在优化上偏向于synchronized，因此性能不再是两者的考虑因素。都可以实现的情况下，优先synchronized。</p>
<h3 id="非阻塞同步"><a class="markdownIt-Anchor" href="#非阻塞同步"></a> 非阻塞同步</h3>
<p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种实现方式也叫阻塞同步。从处理问题的方式上来说，互斥同步属于一种悲观的并发策略。</p>
<p>随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略。也就是先进行操作，如果没有其他线程使用共享数据，那就操作成功，如果有，那就再采取补偿措施。这种方式不需要把线程挂起，因此称为非阻塞同步。</p>
<p>这里所谓的“硬件指令集”，就是指现代指令集中新增的CAS指令（Compare-And-Swap，比较并交换）。不过这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是完美的，因为存在一个逻辑漏洞，那就是ABA问题。</p>
<blockquote>
<p>如果变量V初次读取的时候值是a，并且在准备赋值的时候还是a，其实这个时候无法判断变量V没有被其它线程修改过，如果在这个有线程把V修改为了b，又重新修改为了a，CAS就会认为没有被修改过。这个漏洞就是“ABA”问题，解决ABA问题可以为变量增加版本号或者修改的时间戳来解决。</p>
</blockquote>
<h3 id="无同步方案"><a class="markdownIt-Anchor" href="#无同步方案"></a> 无同步方案</h3>
<p>要保证线程安全，并不一定要进行同步。两者之间没有因果关系。同步只是一种保证共享数据争用时正确性的手段而已。有些代码是天生线程安全的，比如：</p>
<ul>
<li>可重入代码：这种代码也叫纯代码。可以在代码执行的任何时间中断它，转而执行另一端代码。而在控制权返回后，原程序不会有任何错误。可重入代码都有一些共同特征，比如：不依赖存储在对上的数据和公用的系统资源、用到的状态量都由参数传入、不调用非可重入的方法等</li>
<li>线程本地存储：如果一段代码中所需要的数据完全包含同一个线程中，如果能保证这一点，那就不会因为跟其他线程争抢修改资源而导致数据不一致，也就没有线程风险，是线程安全的。我们平常web开发中基本不考虑多线程干扰，就是因为web交互模型中的“一个请求对应一个服务器线程”的处理方式</li>
</ul>
<h2 id="锁优化"><a class="markdownIt-Anchor" href="#锁优化"></a> 锁优化</h2>
<h3 id="自旋锁与自适应自旋"><a class="markdownIt-Anchor" href="#自旋锁与自适应自旋"></a> 自旋锁与自适应自旋</h3>
<p>如果物理及其有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并发执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项计数就是所谓的自旋锁。</p>
<h3 id="锁消除"><a class="markdownIt-Anchor" href="#锁消除"></a> 锁消除</h3>
<p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作操作数栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</p>
<h3 id="锁粗化"><a class="markdownIt-Anchor" href="#锁粗化"></a> 锁粗化</h3>
<p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据得实际作用域中才进行同步，这样是为了使得需要同步得操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。</p>
<p>大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>锁的粗化就是指如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，就会把加锁同步的范围扩展（粗化）到整个操作序列的外部，这样只需要加锁一次就可以了。</p>
<h3 id="轻量级锁"><a class="markdownIt-Anchor" href="#轻量级锁"></a> 轻量级锁</h3>
<p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁的机制就被称为“重量级”锁。</p>
<p>HotSpot虚拟机对象头Mark Word示意图：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210806104948.png" alt="image-20210806104948711" /></p>
<p>在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前的Mark Word的拷贝（官方称为Displaced Mark Word），这时候线程堆栈与对象头的状态如图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210806105450.png" alt="image-20210806105450428" style="zoom:50%;" />
<p>然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新位为指向Lock Record的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如下图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210806110157.png" alt="image-20210806105747996" style="zoom:50%;" />
<p>如果这个更新操作失败了，那就意味着至少存在一个线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。</p>
<p>上述描述的是轻量级锁的加锁过程，解锁过程也同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。假设能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</p>
<p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。</p>
<h3 id="偏向锁"><a class="markdownIt-Anchor" href="#偏向锁"></a> 偏向锁</h3>
<p>偏向锁的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。</p>
<p>偏向锁中的“偏”，就是偏心的“偏”，偏袒的“偏”，它的意思是这个锁会偏向于第一个获取它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程永远不需要再进行同步。</p>
<p>假设虚拟机启用了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，标识进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录再对象的Mark World之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块是，虚拟机都可以不再进行任何同步操作。</p>
<p>一旦出现另一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照轻量级锁那样去执行。偏向锁、轻量级锁的状态转化及对象Mark Word的关系如图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210806102556.png" alt="image-20210806102556856" style="zoom:67%;" />
<hr />
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>[1] <a href="https://github.com/weolwo/jvm-learn.git">圣思源张龙的JVM学习笔记</a></p>
<p>[2] <a href="https://github.com/fuzhengwei/itstack-demo-jvm">使用java实现jvm</a></p>
<p>[3] <a href="https://blog.csdn.net/lijingyao8206/article/details/51225839">通过字节码分析JDK8中Lambda表达式编译及执行机制</a></p>
<p>[4] <a href="https://52doc.com/detail/155">深入理解Java虚拟机</a></p>
<p>[5] <a href="https://www.cnblogs.com/andy-zhou/p/5327288.html">JVM调优总结</a></p>
<p>[6] <a href="https://www.jianshu.com/p/870abddaba41">RSet</a></p>
<p>[7] <a href="https://openjdk.java.net">JDK网页</a></p>
<p>[8] <a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">G1官方文档</a></p>
<p>[9] <a href="https://www.cnblogs.com/duanxz/p/3520829.html">Metaspace</a></p>
<p>[10] <a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">新一代垃圾回收器ZGC的探索与实践</a></p>
<p>[11] <a href="https://www.infoq.cn/article/Java-PERMGEN-Removed">Java永久代去哪儿了</a></p>
<p>[12] <a href="https://blog.csdn.net/u011810352/article/details/80316870">深入理解Java字节码结构</a></p>
<p>[13] <a href="https://blog.csdn.net/zqz_zqz/article/details/70568819">CMS垃圾回收器详解</a></p>
<p>[14] <a href="https://www.cnblogs.com/jhxxb/p/11001238.html">栈帧</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾回收</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题精选</title>
    <url>/2020/10/07/Interview/</url>
    <content><![CDATA[<p>本文通过对于常见面试题的整理归纳，回顾Web开发中的各种方面知识点。</p>
<span id="more"></span>
<h1 id="java基础篇"><a class="markdownIt-Anchor" href="#java基础篇"></a> Java基础篇</h1>
<h2 id="java基础"><a class="markdownIt-Anchor" href="#java基础"></a> Java基础</h2>
<h3 id="java-语言有哪些特点"><a class="markdownIt-Anchor" href="#java-语言有哪些特点"></a> Java 语⾔有哪些特点?</h3>
<ul>
<li>简单易学</li>
<li>面向对象（封装、继承、多态）</li>
<li>跨平台</li>
<li>可靠性</li>
<li>安全性</li>
<li>支持多线程（C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程设计，Java提供了多线程支持）</li>
<li>支持网络编程</li>
<li>编译与解释并存</li>
</ul>
<h3 id="jvm-jdk-和-jre-联系与区别"><a class="markdownIt-Anchor" href="#jvm-jdk-和-jre-联系与区别"></a> JVM、JDK 和 JRE 联系与区别？</h3>
<p>JVM（Java虚拟机）是运行Java字节码的虚拟机，JVM针对于不同的操作系统有不同的实现（Windows,Linux,Mac os），在不同的操作系统上使用相同的字节码文件可以得到相同的结果。</p>
<p>Java程序从源代码到运行一般经历下面3个步骤：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210629231212350.png" alt="image-20210629231212350" /></p>
<p>JDK（Java Development Kit）是功能齐全的Java SDK，它不止有JRE，还有编译器（Javac）和工具（例如Java doc 和Jdb），它可以创建和编译程序。</p>
<p>JRE是Java运行时环境，它是运行已经编译的Java程序所需的内容的集合，包括Java虚拟机、Java类库、Java命令和其他的一些基础构件，但是，它不能用来创建新的程序。</p>
<h3 id="java-和-c的区别"><a class="markdownIt-Anchor" href="#java-和-c的区别"></a> Java 和 C++的区别?</h3>
<ul>
<li>都是面向对象的语言，都具有继承、封装、多态的特性</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，但接口可以多继承，C++支持多重继承</li>
<li>Java有自动内存管理机制，C++需要手动释放无用的内存</li>
</ul>
<h3 id="构造器-constructor-是否可被-override"><a class="markdownIt-Anchor" href="#构造器-constructor-是否可被-override"></a> 构造器 Constructor 是否可被 override?</h3>
<p>构造器无法被重写，但可以重载。</p>
<h3 id="重载和重写的区别"><a class="markdownIt-Anchor" href="#重载和重写的区别"></a> 重载和重写的区别？</h3>
<p>重载发生在同一个类中，方法名必须相同，参数类型、个数、顺序不同，方法返回值和修饰值可以不同。</p>
<h3 id="面向对象编程三大特性-封装-继承-多态"><a class="markdownIt-Anchor" href="#面向对象编程三大特性-封装-继承-多态"></a> 面向对象编程三⼤特性: 封装 继承 多态</h3>
<ul>
<li>
<p>封装</p>
<p>封装是把一个对象的属性私有化，根据需要提供一些可以被外界访问属性的方法</p>
</li>
<li>
<p>继承</p>
<p>继承是使用已经存在的类的定义作为基础建立新的类，新类的定义可以增加新的数据或功能，也可以使用父类的功能，子类拥有父类所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，子类可以拥有自己的属性和方法，即子类可以对父类进行扩展，子类也可以重写父类的方法。</p>
</li>
<li>
<p>多态</p>
<p>多态是值程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须是在程序运行期间才能决定。</p>
</li>
</ul>
<h3 id="string-stringbuffer-和-stringbuilder-的区别是什么"><a class="markdownIt-Anchor" href="#string-stringbuffer-和-stringbuilder-的区别是什么"></a> String StringBuffer 和 StringBuilder 的区别是什么?</h3>
<ul>
<li>String：不可变字符序列</li>
<li>StringBuffer：可变字符序列，效率低，线程安全</li>
<li>StringBuilder：可变字符序列，效率高，线程不安全</li>
</ul>
<h3 id="string类为什么是不可变的"><a class="markdownIt-Anchor" href="#string类为什么是不可变的"></a> String类为什么是不可变的?</h3>
<p>在Java中，String被设计成一个不可变的类，也就是常量对象，理由如下：</p>
<ul>
<li>
<p>String常量池需要</p>
<p>JVM为了提升性能和减少内存开销，设计了字符串常量池，字符串不可变的特性就是其设计基础。</p>
</li>
<li>
<p>缓存Hashcode</p>
<p>可以将Hash值存储起来，不用每次都计算，会给String作为key的数据结构，例如HashMap、HashTable等带来性能提升。</p>
</li>
<li>
<p>安全</p>
<p>可以防止通过反射机制等有意或者恶意修改，从而预防安全问题。</p>
</li>
<li>
<p>线程安全</p>
<p>不可变的对象意味着天生就是线程安全的，可以被多个线程共享。</p>
</li>
</ul>
<p>缺点：对于字符串拼接操作会带来极大的性能消耗，这种情况可以使用StringBuffer、StringBuilder来替代String。</p>
<h3 id="深拷贝和浅拷贝的区别"><a class="markdownIt-Anchor" href="#深拷贝和浅拷贝的区别"></a> 深拷贝和浅拷贝的区别？</h3>
<p>浅拷贝：对于基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝；</p>
<p>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p>
<h3 id="接口和抽象类的区别"><a class="markdownIt-Anchor" href="#接口和抽象类的区别"></a> 接口和抽象类的区别</h3>
<ul>
<li>接口的方法默认都是public，所有的方法在接口中不能有实现；</li>
<li>接口中除了static、final变量，不能有其他变量，而抽象类中则不一定；</li>
<li>一个类可以实现多个接口，但只能实现一个抽象类。但接口本身可以多继承。</li>
<li>接口方法的默认修饰符是public，抽象类的方法的修复可以是public、protected和default这些修饰符（不能是private）；</li>
<li>从设计的层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>
</ul>
<p>以上对JDK8之前的定义和规范，从JDK8开始接口的概念有了一些变化，在JDK7或更早的版本中，接口里面只能由常量、变量和抽象方法，实现接口类必须重写接口中的抽象方法，JDK8接口中增加了默认方法和静态方法，JDK9接口中增加了私有方法和私有静态方法。</p>
<h3 id="构造方法有哪些特性"><a class="markdownIt-Anchor" href="#构造方法有哪些特性"></a> 构造方法有哪些特性？</h3>
<ul>
<li>名称与类名相同</li>
<li>没有返回值，但不能用void声明构造方法</li>
<li>生成类的对象时自动执行，无需调用</li>
<li>默认有一个不带参数的构造方法</li>
<li>如果显式的指定了带参的构造方法，默认不再提供无参的构造方法</li>
</ul>
<p>总的来说构造方法与普通方法的区别如下：</p>
<table>
<thead>
<tr>
<th>Java构造函数</th>
<th>Java方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造器用于初始化对象的状态（状态）</td>
<td>方法用于暴露对象的行为</td>
</tr>
<tr>
<td>构造函数不能有返回类型</td>
<td>方法一般都有返回类型</td>
</tr>
<tr>
<td>构造函数隐式调用</td>
<td>方法要显式的调用</td>
</tr>
<tr>
<td>如果没有指定任何构造函数，java编译器提供一个默认的构造函数</td>
<td>在任何情况下编译器都不会提供默认的方法调用</td>
</tr>
<tr>
<td>构造函数名称必须与类名称相同</td>
<td>方法名称可以或可以不与类名称相同</td>
</tr>
</tbody>
</table>
<h3 id="string中hashcode的实现"><a class="markdownIt-Anchor" href="#string中hashcode的实现"></a> String中hashcode的实现？</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jdk8有哪些新特性"><a class="markdownIt-Anchor" href="#jdk8有哪些新特性"></a> JDK8有哪些新特性？</h3>
<ul>
<li>Lambda表达式</li>
<li>函数式接口</li>
<li>方法引用</li>
<li>Stream API</li>
<li>接口中的默认方法和静态</li>
<li>新的时间和日期API</li>
<li>Optional</li>
</ul>
<h3 id="java反射有哪些作用"><a class="markdownIt-Anchor" href="#java反射有哪些作用"></a> Java反射有哪些作用？</h3>
<p>Java的反射机制主要用于实现以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类型</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行判断任意一个类所具有的成员变量和方法</li>
<li>在运行时调用任意一个对象的方法，包括private方法</li>
</ul>
<h3 id="如何使用反射获取私有属性"><a class="markdownIt-Anchor" href="#如何使用反射获取私有属性"></a> 如何使用反射获取私有属性？</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.获取私有属性</span></span><br><span class="line">Field[] fields = clz.getDeclaredFields();</span><br><span class="line"><span class="comment">// 2.获取私有构造方法</span></span><br><span class="line">Constructor cons = clazz.getDeclaredConstructor(<span class="keyword">null</span>);  </span><br><span class="line"><span class="comment">// 必须要设置之后才可以访问</span></span><br><span class="line">cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">cons.newInstance(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="创建对象有哪些方式"><a class="markdownIt-Anchor" href="#创建对象有哪些方式"></a> 创建对象有哪些方式？</h3>
<ul>
<li>new关键字</li>
<li>反射API</li>
<li>Constructor.newInstance</li>
<li>Clone()方法</li>
<li>反序列化</li>
</ul>
<h3 id="迭代器和for循环遍历的区别"><a class="markdownIt-Anchor" href="#迭代器和for循环遍历的区别"></a> 迭代器和for循环遍历的区别？</h3>
<p>迭代器是一种设计模式，可以使得序列类型的数据结构的遍历行为与被遍历的对象分离，即我们无需关心该序列的底层结构是什么样子的。只要拿到这个对象，使用迭代器可以遍历这个对象的内部。</p>
<p>迭代器实现了Iterabale接口的集合都可以使用迭代器来遍历。使用迭代器遍历元素时，除了查看之外，只能做remove操作。</p>
<p>增强for循环，内部使用的是迭代器，所以它的操作对象是数组和可以迭代器的结合。遍历时只能查看，无法修改、删除、增加。</p>
<div class="note warning"><p>迭代出来的元素都是原来集合元素的拷贝，Java集合元素实质是对象的引用，而非对象本身，迭代出的对象也是引用的拷贝，结果还是引用。那么如果集合中保存的元素是可变类型的，那么可以通过迭代出的元素修改原集合中的对象</p></div>
<p>总的来说，两者的区别主要在于遍历和集合本身是否分离，从数据结构的角度分析，如果使用Iterator来遍历集合的元素，并不需要考虑集合类的内部实现（只要），而如果使用for循环进行遍历，那么遍历此集合的算法都得做相应的调整。</p>
<h3 id="过滤器和拦截器的区别"><a class="markdownIt-Anchor" href="#过滤器和拦截器的区别"></a> 过滤器和拦截器的区别？</h3>
<ul>
<li>过滤器指的是，在java web中，传入的request、response提前过滤一些信息，或者提前设置一些参数，然后传入servlet或者struts的action进行业务逻辑，比如过滤掉非法url。</li>
<li>拦截器指的是，是在面向切面编程的时候，使用动态代理拦截方法等。</li>
</ul>
<h2 id="java集合"><a class="markdownIt-Anchor" href="#java集合"></a> Java集合</h2>
<h3 id="list-set-map三者的区别"><a class="markdownIt-Anchor" href="#list-set-map三者的区别"></a> List、Set、Map三者的区别？</h3>
<p>List用来存储一组不唯一（可以重复），有序的对象；</p>
<p>Set用来存储不允许重复的集合，不会有多个元素引用相同集合的对象；</p>
<p>Map是用来存储键值对的，Map会维护与Key有关联的值，两个不同的Key可以引用相同的对象，Key不能重复。</p>
<h3 id="hashmap实现原理"><a class="markdownIt-Anchor" href="#hashmap实现原理"></a> HashMap实现原理？</h3>
<p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">Java 8系列之重新认识HashMap - 美团技术团队 (meituan.com)</a></p>
<h3 id="hashmap为什么扩容为2倍"><a class="markdownIt-Anchor" href="#hashmap为什么扩容为2倍"></a> HashMap为什么扩容为2倍？</h3>
<p>HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，使用的算法是：<code>hash &amp; (length - 1)</code>，实际上<code>hash &amp; (length - 1) = hash % length</code>，主要考虑到模运算的速度比位运算的的快。</p>
<h3 id="为什么hashmap不用linkedlist而是选用数组"><a class="markdownIt-Anchor" href="#为什么hashmap不用linkedlist而是选用数组"></a> 为什么HashMap不用LinkedList，而是选用数组？</h3>
<p>在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到，此时已知桶的位置，使用数组查询的效率会LinkedList大；不使用ArrayList的原因是，ArrayList的扩容机制是1.5倍扩容，无法自定义扩容机制。</p>
<h3 id="jdk18对hashmap有哪些优化"><a class="markdownIt-Anchor" href="#jdk18对hashmap有哪些优化"></a> JDK1.8对HashMap有哪些优化？</h3>
<ul>
<li>由数组 + 链表的结构改为了数组 + 链表 + 红黑树</li>
<li>优化了高位运算的hash算法：<code>h^(h &gt;&gt;&gt; 16)</code></li>
<li>扩容后，元素要么是在原来的位置，要么是在原位置再移动2次幂的位置，且链表顺序不变</li>
</ul>
<h3 id="为什么不直接使用红黑树而是选择先用链表再转红黑树"><a class="markdownIt-Anchor" href="#为什么不直接使用红黑树而是选择先用链表再转红黑树"></a> 为什么不直接使用红黑树，而是选择先用链表，再转红黑树？</h3>
<p>因为红黑树需要进行左旋、右旋、变色这些操作来保持平衡，而单链表不需要，当元素小于8个的时候，此时做查询操作，链表结构已经能保证查询性能，当元素大于8个的时候，此时需要红黑树来加速查询速度，但是新增节点的效率变慢了，因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p>
<h3 id="hashmap不使用红黑树而是使用二叉查找树可以吗"><a class="markdownIt-Anchor" href="#hashmap不使用红黑树而是使用二叉查找树可以吗"></a> HashMap不使用红黑树，而是使用二叉查找树可以吗？</h3>
<p>可以，但是二叉查找树在特殊情况下会变成一条线性结构，此时遍历查找会非常慢。</p>
<h3 id="为什么阈值是8"><a class="markdownIt-Anchor" href="#为什么阈值是8"></a> 为什么阈值是8？</h3>
<p>hashcode碰撞次数与泊松分布有关，选择8是根据概率统计而选择的。泊松分布的示意图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210823233913.png" alt="image-20210823233717518" style="zoom:50%;" />
<h3 id="当链表转为红黑树什么时候退化为链表"><a class="markdownIt-Anchor" href="#当链表转为红黑树什么时候退化为链表"></a> 当链表转为红黑树，什么时候退化为链表？</h3>
<p>等于6的时候退转为链表。中间有差值7可以防止链表和树之间频繁的转换。假设这个互相转换的界限都是8，那么如果一个HashMap不停的插入、删除元素，链表个数会在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p>
<h3 id="hashmap在并发编程环境下有什么问题"><a class="markdownIt-Anchor" href="#hashmap在并发编程环境下有什么问题"></a> HashMap在并发编程环境下有什么问题？</h3>
<ul>
<li>多线程扩容，引起的死循环问题</li>
<li>多线程put的时候可能导致元素丢失</li>
<li>put非null元素后get出来的却是null</li>
</ul>
<h3 id="使用可变类当hashmap的key有什么问题"><a class="markdownIt-Anchor" href="#使用可变类当hashmap的key有什么问题"></a> 使用可变类当HashMap的key有什么问题？</h3>
<p>hashCode可能发生改变，导致put进去的值，无法get出，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;List&lt;String&gt;, Object&gt; changeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        Object objectValue = <span class="keyword">new</span> Object();</span><br><span class="line">        changeMap.put(list, objectValue);</span><br><span class="line">        System.out.println(changeMap.get(list));</span><br><span class="line">        <span class="comment">//hashcode发生了改变</span></span><br><span class="line">        list.add(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        System.out.println(changeMap.get(list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何实现一个自定义的class作为hashmap的key"><a class="markdownIt-Anchor" href="#如何实现一个自定义的class作为hashmap的key"></a> 如何实现一个自定义的Class作为HashMap的key？</h3>
<ul>
<li>重写hashcode和equals</li>
<li>如何设计一个不可变类</li>
</ul>
<h3 id="hashset实现原理"><a class="markdownIt-Anchor" href="#hashset实现原理"></a> HashSet实现原理？</h3>
<p>底层使用HashMap实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hashMap的value是Object类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet添加元素的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HashSet删除元素的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="currenthashmap的实现原理"><a class="markdownIt-Anchor" href="#currenthashmap的实现原理"></a> CurrentHashMap的实现原理？</h3>
<p>JDK1.7分段锁的设计，JDK1.8：Node + CAS + Synchronized</p>
<h3 id="arraylist的实现原理"><a class="markdownIt-Anchor" href="#arraylist的实现原理"></a> ArrayList的实现原理？</h3>
<p>ArrayList底层使用一个支持自动扩容的数组来保存所有元素。ArrayList并不是线程安全的，只能在单线程环境下使用，多线程环境下可以使用<code>java.util.Collections.SynchronizedList</code>或<code>java.util.concurrent.CopyOnWriteArrayList</code>来代替。</p>
<h2 id="java并发"><a class="markdownIt-Anchor" href="#java并发"></a> Java并发</h2>
<h3 id="并发编程的三要素"><a class="markdownIt-Anchor" href="#并发编程的三要素"></a> 并发编程的三要素？</h3>
<p>线程安全性的问题主要体现在：</p>
<ul>
<li>原子性</li>
<li>有序性</li>
<li>可见性</li>
</ul>
<p>出现线程安全问题的原因：</p>
<ul>
<li>线程切换带来的原子性问题</li>
<li>缓存导致的可见性问题</li>
<li>编译优化带来的有序性问题</li>
</ul>
<p>解决办法：</p>
<ul>
<li>JDK Atomic开头的原子类、synchronized、Lock可以解决原子性的问题</li>
<li>synchronized、volatile、Lock可以解决可见性的问题</li>
<li>Happers-before规则可以解决有序性的问题</li>
</ul>
<h3 id="线程和进程的区别"><a class="markdownIt-Anchor" href="#线程和进程的区别"></a> 线程和进程的区别？</h3>
<p>进程是程序运行时的状态，是操作系统分配资源的最小单元，进程的主要作用是管理资源。线程是操作系统调度的最小的单元，一个程序至少有一个进程，一个进程至少有一个线程，线程是进程当中的一条执行流程。</p>
<h3 id="守护线程和用户线程的区别"><a class="markdownIt-Anchor" href="#守护线程和用户线程的区别"></a> 守护线程和用户线程的区别？</h3>
<p>Java中的线程分为两种：守护线程（Daemon）和用户线程（User），其中用户线程又称本地线程。守护线程可以理解为JVM自动创建的线程（通常），用户线程是程序创建的线程。一般情况下，两者的区别在于，当JVM中所有的线程都是守护线程的时候，JVM就可以退出，如果还有一个或以上的非守护线程则不会退出。</p>
<p>可以通过 <code>java.lang.Thread#setDaemon</code>方法设置线程为守护线程或者用户线程。</p>
<h3 id="什么是线程安全"><a class="markdownIt-Anchor" href="#什么是线程安全"></a> 什么是线程安全？</h3>
<p>指某个函数、函数库在多线程的环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p>
<h3 id="java如何开启线程怎么保证线程安全"><a class="markdownIt-Anchor" href="#java如何开启线程怎么保证线程安全"></a> Java如何开启线程？怎么保证线程安全？</h3>
<p>这里首先得明确一下线程和进程的区别，进程是操作系统进行资源分配的最小单位，线程是操作系统任务分配的最小单位，线程隶属于进程。</p>
<p>开启线程的具体方式：</p>
<ul>
<li>继承Thread类，重写run方法</li>
<li>实现Runnable接口，实现run方法</li>
<li>实现Callable接口，实现call方法，通过FutureTask创建一个线程，获取到线程执行的返回值</li>
<li>通过线程池来开启线程</li>
</ul>
<p>那么如何保证线程安全呢？</p>
<p>采用加锁的方式：使用JVM提供的Synchronized关键字或者JDK提供的各种锁Lock。</p>
<h3 id="线程有哪些状态"><a class="markdownIt-Anchor" href="#线程有哪些状态"></a> 线程有哪些状态？</h3>
<p>如图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210817203732.png" alt="线程状态示意图" style="zoom: 50%;" />
<h3 id="如何停止一个正在运行的线程"><a class="markdownIt-Anchor" href="#如何停止一个正在运行的线程"></a> 如何停止一个正在运行的线程？</h3>
<p>在java中有以下3种方法可以终止正在运行的线程：</p>
<ul>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li>
<li>使用stop方法强行终止，但是这个方法并不安全</li>
<li>使用interrupt方法中断线程</li>
</ul>
<h3 id="notify和notifyall有什么区别"><a class="markdownIt-Anchor" href="#notify和notifyall有什么区别"></a> notify和notifyAll有什么区别？</h3>
<p>notify会随机唤醒一个阻塞的线程，而notifyAll会唤醒所有线程。</p>
<h3 id="wait和sleep方法有什么区别"><a class="markdownIt-Anchor" href="#wait和sleep方法有什么区别"></a> wait和sleep方法有什么区别？</h3>
<p>调用wait方法之前，线程必须持有对象的锁，在调用wait方法之后，线程就会释放锁，而sleep方法则不会释放掉锁。</p>
<h3 id="为什么wait和notify方法要在同步块中调用"><a class="markdownIt-Anchor" href="#为什么wait和notify方法要在同步块中调用"></a> 为什么wait和notify方法要在同步块中调用？</h3>
<p>使用wait和notify方法首先要必须要获取到当前对象的锁，如果没有获取到锁会抛出异常，因为需要在同步块中调用。</p>
<h3 id="thread类中的yield方法有什么作用"><a class="markdownIt-Anchor" href="#thread类中的yield方法有什么作用"></a> Thread类中的yield方法有什么作用？</h3>
<p>当一个线程调用yield方法时，当前线程会让出CPU使用权，然后处于就绪状态，线程调度器会从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到刚刚让出CPU的那个线程来获取CPU执行权。</p>
<h3 id="volatile和synchronized有什么区别"><a class="markdownIt-Anchor" href="#volatile和synchronized有什么区别"></a> volatile和Synchronized有什么区别？</h3>
<p>Synchronized关键是用来加锁，volatile只是保持变量的线程可见性，通常适用于一个线程写，多个线程读的场景。</p>
<h3 id="volatile变量和atomic变量什么不同"><a class="markdownIt-Anchor" href="#volatile变量和atomic变量什么不同"></a> volatile变量和atomic变量什么不同？</h3>
<p>volatile变量可以确保写操作发生在后续的读操作之前，但它并不能保证原子性，例如，即便是使用volatile修饰，count++的操作也不是原子性的，而atomic变量可以让这种操作具有原子性。</p>
<h3 id="interrupted和isinterrupted方法的区别"><a class="markdownIt-Anchor" href="#interrupted和isinterrupted方法的区别"></a> interrupted和isInterrupted方法的区别？</h3>
<p>interrupted与isInterrupted方法不同是，interrupted方法会清除中断标志，而isInterrupted方法则不会，并且interrupted方法是static方法，可以通过Thread类直接调用。</p>
<h3 id="volatile能不能保证线程安全"><a class="markdownIt-Anchor" href="#volatile能不能保证线程安全"></a> volatile能不能保证线程安全？</h3>
<p>不能。volatile关键字只能保证线程可见性，不能保证原子性，相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private static boolean flag = true;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DCL(Double Check Lock)单例为什么加volatile？</p>
<p>volatile防止指令重排，在DCL中，防止高并发情况，指令重排造成的线程安全问题，相关示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> SingleDemo singleDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"><span class="comment">//        if (null == this.singleDemo) &#123;</span></span><br><span class="line"><span class="comment">//            synchronized (SingleDemo.class) &#123;</span></span><br><span class="line"><span class="comment">//                if (null == this.singleDemo) &#123;</span></span><br><span class="line"><span class="comment">//                    singleDemo = new SingleDemo();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        singleDemo = <span class="keyword">new</span> SingleDemo();</span><br><span class="line">        <span class="keyword">return</span> singleDemo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁与活锁的区别"><a class="markdownIt-Anchor" href="#死锁与活锁的区别"></a> 死锁与活锁的区别？</h3>
<p>死锁：线程1等待线程2互斥持有的资源，而线程2也在等待线程1互斥持有的资源，两个线程都无法继续执行。</p>
<p>活锁：线程持续重试一个总是失败的操作，导致无法继续执行；</p>
<h3 id="死锁与饥饿的区别"><a class="markdownIt-Anchor" href="#死锁与饥饿的区别"></a> 死锁与饥饿的区别？</h3>
<p>饥饿：线程一直被调度器延迟访问其赖以执行的资源，也许是调度器先于低优先级的线程而执行高优先级的线程，同时总是会有一个高优先级的线程可以执行，饿死也叫做无限延迟。</p>
<h3 id="按照线程安全的强度来区分分为哪几类"><a class="markdownIt-Anchor" href="#按照线程安全的强度来区分分为哪几类"></a> 按照线程安全的强度来区分，分为哪几类？</h3>
<table>
<thead>
<tr>
<th>分类</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>不可变</td>
<td>不可变的对象一定是线程安全的，并且永远也不需要额外的同步。Java类库中大多数基本数值类如Integer、String、BigInteger都是不可变的。</td>
</tr>
<tr>
<td>绝对线程安全</td>
<td>由类的规格说明所规定的约束在对象被多个线程访问时仍然有效，不管运行时环境如何排列，线程都不需要任何额外的同步。</td>
</tr>
<tr>
<td>相对线程安全</td>
<td>相对线程安全类对于单独的操作可以是线程安全的，但是某些操作序列可能需要外部同步。</td>
</tr>
<tr>
<td>线程兼容</td>
<td>线程兼容类不是线程安全的，但是可以通过正确使用同步而在并发环境中安全地使用，例如使用sychronized代码块。</td>
</tr>
<tr>
<td>线程对立</td>
<td>线程对立是那些不管是否采用了同步措施，都不能在多线程环境中并发使用的代码，这通常是有害的，应当尽量避免。</td>
</tr>
</tbody>
</table>
<h3 id="线程安全的实现方法有哪些"><a class="markdownIt-Anchor" href="#线程安全的实现方法有哪些"></a> 线程安全的实现方法有哪些？</h3>
<ol>
<li>互斥同步</li>
<li>非阻塞同步</li>
<li>无同步方案
<ul>
<li>可重入代码</li>
<li>线程本地存储</li>
</ul>
</li>
</ol>
<h3 id="锁优化技术你了解什么"><a class="markdownIt-Anchor" href="#锁优化技术你了解什么"></a> 锁优化技术你了解什么？</h3>
<p>锁优化技术主要有锁消除与锁粗化两种。</p>
<ul>
<li>通过逃逸分析技术判别程序中所使用的锁对象是否只被一个线程所使用，而没有散布到其他线程当中，如果情况就是这样的话，那么JIT编译器在编译这个同步代码时就不会生成synchronized关键字所标识的锁的申请与释放机器码，从而消除了锁的使用流程，这就是锁的消除。</li>
<li>JIT编译器在执行动态编译时，若发现前后相邻的synchronized块使用的是同一个锁对象，那么它就会把这几个synchronized块合并为一个较大的同步块，这就是锁的粗化。</li>
</ul>
<h3 id="lock与synchronized有什么区别"><a class="markdownIt-Anchor" href="#lock与synchronized有什么区别"></a> Lock与synchronized有什么区别？</h3>
<ul>
<li>锁的获取方式：Lock是通过程序代码的方式由开发者手工获取，而synchronized是通过JVM来获取的（无需开发者干预）。</li>
<li>具体的实现方式：Lock是通过Java代码的方式来实现，synchronized是通过JVM底层来实现（无需开发者关注）。</li>
<li>锁的释放方式：Lock务必通过unlock()方法在finally块中手工释放，synchronized是通过JVM来释放（无需开发者关注）。</li>
<li>锁的具体类型：Lock提供了多种，如公平锁、非公平锁，synchronized与Lock都提供了可重入锁。</li>
</ul>
<h3 id="什么是阻塞队列阻塞队列的实现原理是什么"><a class="markdownIt-Anchor" href="#什么是阻塞队列阻塞队列的实现原理是什么"></a> 什么是阻塞队列？阻塞队列的实现原理是什么？</h3>
<p>阻塞队列是一个支持两个附加操作的队列。这两个附加的操作是：</p>
<ul>
<li>当队列为空时，获取元素的线程会等待队列变为非空</li>
<li>当队列满时，存储的线程会等待队列可用</li>
</ul>
<p>阻塞队列一览：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayBlockingQueue</td>
<td>一个由数组结构组成的有界阻塞队列</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>一个由链表结构组成的有界阻塞队列</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>一个支持优先级排序的无界阻塞队列</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>一个使用优先级队列实现的无界阻塞队列</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>一个不存储元素的阻塞队列</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>一个由链表结构组成的无界阻塞队列</td>
</tr>
<tr>
<td>LinkedBlockingDeque</td>
<td>一个由链表结构组成的双向阻塞队列</td>
</tr>
</tbody>
</table>
<h3 id="什么是callable和future"><a class="markdownIt-Anchor" href="#什么是callable和future"></a> 什么是Callable和Future？</h3>
<p>Future接口标识异步任务，是还没有完成的任务给出的未来结果，Callable用于产生结果，Future用来获取结果。</p>
<h3 id="java线程锁机制是怎样的偏向锁-轻量级锁-重量级锁有什么区别锁机制是如何升级的"><a class="markdownIt-Anchor" href="#java线程锁机制是怎样的偏向锁-轻量级锁-重量级锁有什么区别锁机制是如何升级的"></a> Java线程锁机制是怎样的？偏向锁、轻量级锁、重量级锁有什么区别？锁机制是如何升级的？</h3>
<p>Java的锁就是在对象的MarkWord中记录一个锁状态、无锁、偏向锁、轻量级锁、重量级锁对应不同锁状态，Java的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程。</p>
<p>偏向锁、轻量级锁、重量级锁及锁机制具体如下图：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/%E9%94%81%E6%9C%BA%E5%88%B6.png" alt="1623338358489" /></p>
<h3 id="什么是可重入锁有哪些实现"><a class="markdownIt-Anchor" href="#什么是可重入锁有哪些实现"></a> 什么是可重入锁？有哪些实现？</h3>
<p>线程可以直接进入已经获取锁的同步代码块，而无需重复获取锁。代表实现：synchronized、ReentrantLock。</p>
<h3 id="什么是悲观锁什么是乐观锁"><a class="markdownIt-Anchor" href="#什么是悲观锁什么是乐观锁"></a> 什么是悲观锁？什么是乐观锁？</h3>
<p>悲观锁：总是假设最坏的情况，每次获取数据都认为其它线程会修改，所以都会加锁（读锁、写锁、行锁等），当其它线程想要访问数据时，都需要阻塞挂起，例如synchronized。</p>
<p>乐观锁：总是认为不会产生并发问题，每次获取数据的时候总认为不会有其它线程对数据进行修改，因此不会上锁，但是在更新是会判断其它线程在这之前有没有对数据进行修改，一般使用版本号机制或CAS操作实现。</p>
<h3 id="谈谈你对aqs的理解aqs如何实现可重入锁"><a class="markdownIt-Anchor" href="#谈谈你对aqs的理解aqs如何实现可重入锁"></a> 谈谈你对AQS的理解，AQS如何实现可重入锁？</h3>
<p>AQS是一个Java线程同步的框架，是JDK中很多锁工具的核心实现框架，在AQS中，维护了一个信号量state和一个线程组成的双向链表队列。其中，这个线程队列，  其中这个线程队列，就是用来给线程排队的，而state就像是一个红绿灯，用来控制线程排队或者放行的，在不同的场景下，有不用的意义。</p>
<p>在可重入锁这个场景下，state就用来表示枷锁的次数，0标识加锁的次数，每加一次锁，state就加1，释放锁state就减1。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630102031.png" alt="img" style="zoom:67%;" />
<h3 id="synchronizedmap和concurrenthashmap有什么区别"><a class="markdownIt-Anchor" href="#synchronizedmap和concurrenthashmap有什么区别"></a> SynchronizedMap和ConcurrentHashMap有什么区别？</h3>
<p>SynchronizedMap依次锁住整张表来保证线程安全，所以每次只能有一个线程来访问map，而ConcurrentHashMap使用分段锁来保证在多线程下的性能（JDK1.7）。</p>
<h3 id="concurrenthashmap的并发度是什么"><a class="markdownIt-Anchor" href="#concurrenthashmap的并发度是什么"></a> ConcurrentHashMap的并发度是什么？</h3>
<p>默认值是16，这样能在多线程情况下避免争用。</p>
<h3 id="copyonwritearraylist可以用于什么应用场景"><a class="markdownIt-Anchor" href="#copyonwritearraylist可以用于什么应用场景"></a> CopyOnWriteArrayList可以用于什么应用场景？</h3>
<p>读多写少，并且写入慢也没有关系的场景。</p>
<h3 id="有a-b-c三个线程如何保证三个线程同时执行如何在并发情况下保证三个线程依次执行如何保证三个线程有序交错进行"><a class="markdownIt-Anchor" href="#有a-b-c三个线程如何保证三个线程同时执行如何在并发情况下保证三个线程依次执行如何保证三个线程有序交错进行"></a> 有A、B、C三个线程，如何保证三个线程同时执行？如何在并发情况下保证三个线程依次执行？如何保证三个线程有序交错进行？</h3>
<p>可以使用三大工具：CountDownLatch，CylicBarrier，Semaphore</p>
<ul>
<li>保证三个线程同时执行的示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">        ThreadSafeDemo threadSafeDemo = <span class="keyword">new</span> ThreadSafeDemo();</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                    System.out.println(System.currentTimeMillis());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>保证三个线程依次执行的示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderThread2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> ticket = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;a&quot;</span> + i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ticket = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;b&quot;</span> + i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ticket = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket == <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;c&quot;</span> + i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>保证三个线程有序交错进行的示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderThread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用信号量来限制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s2 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s3 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s1.acquire();</span><br><span class="line">            s2.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s1.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                s2.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s2.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                s3.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s3.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">                s1.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="什么是指令重排序"><a class="markdownIt-Anchor" href="#什么是指令重排序"></a> 什么是指令重排序？</h3>
<p>为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入的代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，并确保这一结果和顺序执行的结果是一直的，但是这个过程并不保证各个语句计算的先后顺序和输入代码中的顺序一致，简单来说，就是指程序中写的代码，在执行时并不一定按照写的顺序就叫做指令重排序。</p>
<p>Java中的指令重排序有两次，第一次发生在将字节码编译成机器码的阶段，第二次发生在CPU执行的时候，也会适当对指令进行重排。</p>
<h3 id="threadlocal的作用导致内存泄漏的原因是什么"><a class="markdownIt-Anchor" href="#threadlocal的作用导致内存泄漏的原因是什么"></a> ThreadLocal的作用？导致内存泄漏的原因是什么？</h3>
<p>ThreadLocal可以为每一个线程拷贝变量的副本，让变量“私有化”，导致内存泄漏的主要原因是在内部维护的Map结构，当key被GC之后，value还存在，无法自动进行GC，就会导致内存泄漏。</p>
<h3 id="使用线程池有什么好处"><a class="markdownIt-Anchor" href="#使用线程池有什么好处"></a> 使用线程池有什么好处？</h3>
<ul>
<li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li>提高响应速度：当任务到达时，可以不需要等待线程创建就能立即执行</li>
<li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行同一的分配，监控和调优。</li>
</ul>
<h3 id="线程池中submit和execute方法有什么区别"><a class="markdownIt-Anchor" href="#线程池中submit和execute方法有什么区别"></a> 线程池中submit()和execute()方法有什么区别？</h3>
<p>execute和submit都属于线程池的方法，两者的区别在于：</p>
<ul>
<li>execute只能提交Runnable类型的任务，而submit既能提交Runnable类型的任务也能提交Callable类型任务</li>
<li>execute会直接抛出任务运行时的异常，submit会吃掉异常，可通过Future的get方法将任务执行时的异常重新抛出</li>
<li>execute所属顶层接口时Executor，submit所属顶层接口是ExecutorService，实现类ThreadPoolExecutor重写了execute方法，抽象类AbstractExecutorService重写了submit方法</li>
</ul>
<h3 id="什么是executors框架"><a class="markdownIt-Anchor" href="#什么是executors框架"></a> 什么是Executors框架？</h3>
<p>Executor工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</p>
<h4 id="线程池的拒绝策略"><a class="markdownIt-Anchor" href="#线程池的拒绝策略"></a> 线程池的拒绝策略？</h4>
<p>当提交的线程填满核心线程数，并且塞满了队列缓冲区，并且超过了最大线程数时，就会触发拒绝策略，具体有以下几种：</p>
<table>
<thead>
<tr>
<th>拒绝策略</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbortPolicy</td>
<td>当任务添加到线程池中被拒绝时，它将抛出RejectedExecutionException异常</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务</td>
</tr>
</tbody>
</table>
<p>什么时候触发拒绝策略，是三个参数总体协调的结果，当提交的任务大于corePoolSize时，会优化放到队列缓冲区，值由填满了缓冲区之后，才会判断当前任务是否大于maxPoolSize，小于的时候会创建新的线程进行处理，大于时就触发了拒绝策略。简单来说，当前提交任务数大于(maxPoolSize + queueCapacity)时就会触发线程的拒绝策略。</p>
<h3 id="如何获取子线程的执行结果"><a class="markdownIt-Anchor" href="#如何获取子线程的执行结果"></a> 如何获取子线程的执行结果？</h3>
<ul>
<li>使用join方法变量传递</li>
<li>FutureTask</li>
</ul>
<h3 id="如何对一个字符串快速进行排序"><a class="markdownIt-Anchor" href="#如何对一个字符串快速进行排序"></a> 如何对一个字符串快速进行排序？</h3>
<p>可以使用Fork/Join框架来完成，相关代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池的参数如何设置"><a class="markdownIt-Anchor" href="#线程池的参数如何设置"></a> 线程池的参数如何设置？</h3>
<p>详细参见：<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p>
<h2 id="java网络通信"><a class="markdownIt-Anchor" href="#java网络通信"></a> Java网络通信</h2>
<h3 id="tcp和udp有什么区别"><a class="markdownIt-Anchor" href="#tcp和udp有什么区别"></a> TCP和UDP有什么区别？</h3>
<p>TCP（Transfer Control Protocol）是一种面向连接的、可靠的、传输层通讯协议。</p>
<p>TCP的特点：类似打电话，面向连接的、点对点的通信、高可靠的，效率比较低，占用的系统资源比较多。</p>
<p>UDP（User Datagram Protocol）是一种无连接的、不可靠的、传输层的通讯协议。</p>
<p>UDP的特点：类似广播，不需要连接，发送方不管接受方有没有准备好，直接发消息，可以进行广播发送的，传输不可靠，有可能丢失消息，效率比较高，协议比较简单，占用的系统资源比较少。</p>
<h3 id="tcp为什么是三次握手而不是两次"><a class="markdownIt-Anchor" href="#tcp为什么是三次握手而不是两次"></a> TCP为什么是三次握手，而不是两次？</h3>
<p>TCP建立连接三次握手，断开连接四次挥手。 如果是两次握手，可能会造成连接资源浪费的情况，server端会建立通道一直等待连接，但是client端会认为连接失败，放弃本次通信。</p>
  <img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630005545.png" alt="img" style="zoom: 67%;" />
<h3 id="java有哪几种io模型有什么区别"><a class="markdownIt-Anchor" href="#java有哪几种io模型有什么区别"></a> Java有哪几种IO模型？有什么区别？</h3>
<p>有BIO 同步阻塞IO、NIO 同步非阻塞IO、AIO异步非阻塞IO模型。</p>
<p>这里的同步、异步针对请求，阻塞和非阻塞针对客户端。</p>
<p>在一个网络请求中，客户端会发一个请求到服务端：</p>
<ul>
<li>
<p>客户端发了请求后，就一直等着服务端响应，客户端：阻塞。请求：同步</p>
</li>
<li>
<p>客户端发了请求后，就去干别的事情了，是不是的过来检查服务端是否给出了响应，客户端：非阻塞，请求：同步</p>
</li>
<li>
<p>换成异步请求，客户端发了请求后，就坐在椅子上，等着服务端返回响应。客户端：阻塞，请求：异步。</p>
</li>
<li>
<p>客户端发了请求后，就去干别的事情了，等到服务端给出响应后，再来处理业务逻辑。客户端：非阻塞。请求：异步</p>
</li>
</ul>
<p>具体区别如下：</p>
<p>BIO模式：可靠性差，吞吐量低，适用于连接比较少且比较固定的场景，JDK1.4之前唯一的选择。编程模型最简单。</p>
  <img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630005609.png" alt="img" style="zoom: 67%;" />
<p>NIO模型：可靠性比较好，吞吐量比较高，适用于连接多，并且连接比较短（轻操作），例如聊天室，JDK1.4开始支持，变成模型最复杂。</p>
  <img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630005650.png" alt="img" style="zoom:67%;" />
<p>AIO模型：可靠性是最好的，吞吐量也是最高的，适用于连接比较多，并且连接比较长（重操作），例如相册服务器，JDK7开始支持的，变成模型相对简单，但是需要操作系统支持。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630005707.png" alt="img"  />
<h3 id="java-nio的几个核心组件是什么分别有什么作用"><a class="markdownIt-Anchor" href="#java-nio的几个核心组件是什么分别有什么作用"></a> Java NIO的几个核心组件是什么？分别有什么作用？</h3>
<p>Java NIO的几个核心组件有：Channel、Buffer、Selector</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630005725.png" alt="img" /></p>
<p>Channel类似于流，每个Channel对应一个Buffer缓冲区，Channel会注册到Selector，Selector会根据Channel上发生的读写时间，将请求交由某个空闲的线程处理，Selector对应一个或者多个线程。Buffer和Channel都是可读可写的。</p>
<h3 id="select-poll-epoll有什么区别"><a class="markdownIt-Anchor" href="#select-poll-epoll有什么区别"></a> select、poll、epoll有什么区别？</h3>
<p>他们是NIO中多路复用的三种实现机制，是由linux操作系统提供的。</p>
<p>用户空间和内核空间：操作系统为了保护系统安全，将内核划分为两个部分，一个是用户空间，一个是内核空间。用户空间不能直接访问底层的硬件设备，必须通过内核空间。</p>
<p>文件描述符 File Descriptor（FD）：是一个抽象的概念，形式上是一个整数，实际上是一个索引值。指向内核中为每个进程维护进程所打开的文件的记录表。当程序打开一个文件或者创建一个文件时，内核就会向进程返回一个FD，Unix、Linux。</p>
<ul>
<li>
<p>select机制：会维护一个FD的结合fd_set。将fd_set从用户空间复制到内核空间，激活socket。</p>
</li>
<li>
<p>poll机制：和select机制差不多的。把fd_set结构进行了优化，FD集合的大小就突破了操作系统的限制，poll fd结构来代替fd_set，通过链表实现</p>
</li>
<li>
<p>epoll(Event poll)：epoll中不再扫描所有的FD，而是只将用户关心的FD的事件存放到内核的一个事件表当中。这样就可以减少用户空间与内核空间之前需要拷贝的数据。</p>
</li>
</ul>
<p>总结如下表：</p>
<table>
<thead>
<tr>
<th></th>
<th>操作方式</th>
<th>底层实现</th>
<th>最大连接数</th>
<th>IO效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>select</td>
<td>遍历</td>
<td>数组</td>
<td>受限于内核</td>
<td>一般</td>
</tr>
<tr>
<td>poll</td>
<td>遍历</td>
<td>链表</td>
<td>无上限</td>
<td>一般</td>
</tr>
<tr>
<td>epoll</td>
<td>事件回调</td>
<td>红黑树</td>
<td>无上限</td>
<td>高</td>
</tr>
</tbody>
</table>
<p>那Java的NIO当中时使用的哪种机制呢？</p>
<p>与操作系统有关，在windows下，WindowsSelectorProvider。而linux下，根据linux的内核版本，2.6内核版本以上，就是EpollSelectorProvider，默认使用的是PollSelectorProvider</p>
<h3 id="描述下http和https的区别"><a class="markdownIt-Anchor" href="#描述下http和https的区别"></a> 描述下HTTP和HTTPS的区别？</h3>
<p>HTTP：是互联网上应用最为广泛的一种网络通信协议，基于TCP协议，可以使用浏览器工作更为高效，减少网络传输。</p>
<p>HTTPS：是HTTP的加强版，可以认为是HTTP + SSL（Secure Socket Layer）。在HTTP的基础上增加了一系列的安全机制，一方面保证数据传输安全，另一方面对访问者增加了验证机制。是目前现行架构下，最为安全的解决方案。</p>
<p>主要区别：</p>
<ol>
<li>HTTP的连接时简单无状态的，HTTPS的数据传输时经过证书加密的，安全性更高。</li>
<li>HTTP是免费的，而HTTPS需要申请证书，而证书通常是收费的，并且费用一般不低。</li>
<li>他们的传输协议不同，所以他们使用的端口也是不一样的，HTTP默认端口是80，而HTTPS默认是443端口</li>
</ol>
<p>HTTPS的缺点：</p>
<ol>
<li>HTTPS的握手协议比较费时，所以会影响服务的响应速度以及吞吐量。</li>
<li>HTTPS也并不是完全安全的，他的证书体系并不是完全安全的。  并且HTTPS在面对DDOS这样的攻击时，几乎起不到任何作用。</li>
<li>证书不免费，并且功能越强大的证书费用越高。</li>
</ol>
<h3 id="三次握手和四次挥手"><a class="markdownIt-Anchor" href="#三次握手和四次挥手"></a> 三次握手和四次挥手？</h3>
<p>所谓三次握手，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包，三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p>
<p>在socket编程中，客户端执行<code>connect</code>时，将触发三次握手：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210824102759.png" alt="三次握手示意图" style="zoom:50%;" />
<p>TCP的连接的拆除需要发送四个包，因此称为四次握手，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行<code>close()</code>操作即可产生挥手操作：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210824103028.png" alt="四次挥手示意图" style="zoom:50%;" />
<h2 id="jvm"><a class="markdownIt-Anchor" href="#jvm"></a> JVM</h2>
<h3 id="运行时数据区中包含哪些区域哪些线程共享哪些线程独享"><a class="markdownIt-Anchor" href="#运行时数据区中包含哪些区域哪些线程共享哪些线程独享"></a> 运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？</h3>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630004443.png" alt="img" /></p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630004452.png" alt="img" /></p>
<h3 id="java-创建一个对象的过程"><a class="markdownIt-Anchor" href="#java-创建一个对象的过程"></a> Java 创建一个对象的过程？</h3>
<ul>
<li>检查类是否已经被加载</li>
<li>为对象分配内存空间</li>
<li>为分配的内存空间初始化零值（为对象字段设置零值）</li>
<li>对对象进行其它设置（设置对象头）</li>
<li>执行构造方法</li>
</ul>
<h3 id="如何访问对象"><a class="markdownIt-Anchor" href="#如何访问对象"></a> 如何访问对象？</h3>
<ul>
<li>使用句柄的方式</li>
<li>使用直接指针的方式</li>
</ul>
<h3 id="java-内存模型的原子性-可见性和有序性是通过哪些操作实现的"><a class="markdownIt-Anchor" href="#java-内存模型的原子性-可见性和有序性是通过哪些操作实现的"></a> Java 内存模型的原子性、可见性和有序性是通过哪些操作实现的？</h3>
<ul>
<li>原子性：synchronized</li>
<li>可见性：volatile</li>
<li>有序性：volatile和synchronized</li>
</ul>
<h3 id="什么是双亲委派机制有什么作用"><a class="markdownIt-Anchor" href="#什么是双亲委派机制有什么作用"></a> 什么是双亲委派机制？有什么作用？</h3>
<p>Java的类加载器：AppClassLoader -&gt; ExtClassLoader -&gt; BootStrapClassLoader</p>
<p>每一种类加载器都有自己的加载目录，Java中的AppClassLoader、ExtClassLoader 都继承了URLClassLoader，URLClassLoader继承了SecureClassLoader，SecureClassLoader又继承了ClassLoader，每个类加载器对他加载过的类，都是有一个缓存的：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630004512.png" alt="img" style="zoom: 50%;" />
<p>双亲委派：向上委托查找，向下委托，作用：保护Java的层的类不会被应用程序覆盖</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="java类加载的全过程是怎么样的"><a class="markdownIt-Anchor" href="#java类加载的全过程是怎么样的"></a> Java类加载的全过程是怎么样的？</h3>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210727230233.png" alt="Java类加载过程" style="zoom: 67%;" />
<p>类加载过程：加载 -&gt; 连接 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p>
<ol>
<li>加载：把Java的字节码数据加载到JVM内存当中，并映射成JVM认可的数据结构</li>
<li>连接：可以分为三个小的阶段：
<ul>
<li>验证：检查加载到的字节码信息是否符合JVM规范</li>
<li>准备：创建类或接口的静态变量，并赋初始值，半初始化状态</li>
<li>解析：将符号引用转为直接引用</li>
</ul>
</li>
<li>初始化：创建对象</li>
</ol>
<h3 id="你了解分代理论吗"><a class="markdownIt-Anchor" href="#你了解分代理论吗"></a> 你了解分代理论吗？</h3>
<p>目前绝大部分的JJVM，在针对对象进行垃圾收集的时候，会将对象熬过垃圾收集的次数，视为对象的年龄，依次将对象至少划分为新生代和老年代。分代收集理论基于以下三种假说和经验法则：</p>
<ul>
<li>
<p>弱分代假说</p>
<p>绝大数对象，在第一次垃圾收集时就会被回收，按照经验法则，这个值高达百分之九十八</p>
</li>
<li>
<p>强分代假说</p>
<p>熬过越多次收集过程的对象就越难以消亡</p>
</li>
<li>
<p>跨代引用假说</p>
<p>该假说认为只会存在很少的跨代引用。因为只要经过一些次数的垃圾收集，即使还存在跨代引用，新生代会变成老年代，跨代引用也就自然小时了，所以跨代引用的数量不会多</p>
</li>
</ul>
<p>Java堆分为新生代和老年代，针对收集对象处于哪一代，一共有以下四种收集方式：</p>
<ul>
<li>部分收集</li>
<li>新生代收集（Minor GC/Young GC），只收集新生代垃圾对象</li>
<li>老年代收集（Major GC/Old GC），只收集老年代垃圾对象，目前只有CMS收集器会单独收集老年代对象</li>
<li>混合收集（Mixed GC），收集来自整个新生代以及部分老年代中的垃圾对象，目前只有G1会有这种行为</li>
<li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集</li>
</ul>
<h3 id="jdk-中有几种引用类型分别的特点是什么"><a class="markdownIt-Anchor" href="#jdk-中有几种引用类型分别的特点是什么"></a> JDK 中有几种引用类型？分别的特点是什么？</h3>
<p>在JDK1.2之前，一个对象只有“被引用”或者“未被引用”两种状态，但这种描述方式不能满足所有的场景，譬如我们希望描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在垃圾收集器后仍然非常警长，那就可以抛弃这些对象，这个时候就需要对引用的概念进行扩充。</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>定义</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用（Strong Reference）</td>
<td>通过new关键赋值的引用</td>
<td>只要强引用关系还存在，垃圾收集器永远不会回收掉引用的对象</td>
</tr>
<tr>
<td>软引用（Soft Reference）</td>
<td>还有用，但非必须的对象</td>
<td>内存不够时一定会被GC，长期不用也会被GC</td>
</tr>
<tr>
<td>弱引用（Weak Reference）</td>
<td>非必须对象</td>
<td>被弱引用关联的对象只能生存到下一次垃圾收集发生为止。无论当前内存是否足够，都会回收</td>
</tr>
<tr>
<td>虚引用（Phantom Reference）</td>
<td>“幽灵引用”或者“幻影引用”</td>
<td>对象被垃圾收集器回收时收到一个系统通知</td>
</tr>
</tbody>
</table>
<h3 id="一个对象从加载到jvm再到gc清除都经历了什么过程"><a class="markdownIt-Anchor" href="#一个对象从加载到jvm再到gc清除都经历了什么过程"></a> 一个对象从加载到JVM，再到GC清除，都经历了什么过程？</h3>
<p>详细步骤说明：</p>
<ol>
<li>
<p>用户创建一个对象，JVM首先需要到方法区去找对象的类型信息，然后再创建对象。</p>
</li>
<li>
<p>JVM要实例化一个对象，首先要在堆中先创建一个对象 -&gt; 半初始化状态</p>
</li>
<li>
<p>对象首先会分配在堆内存中新生代的Eden区，然后经过一次Minor GC，对象如果存活，就会进入S区，在后续的每次GC中，如果对象一直存活，就会在S区来回拷贝，每移动一次，年龄加1，年龄最大值是15，默认就是最大年龄是15。超过年龄先之后，对象转入老年代。</p>
</li>
<li>
<p>当方法执行结束后，栈中的指针会先移除掉。</p>
</li>
<li>
<p>堆中的对象，经过Full GC就会被标记为垃圾，然后被GC线程清理掉。</p>
</li>
</ol>
<h3 id="怎么样确定一个对象不是垃圾"><a class="markdownIt-Anchor" href="#怎么样确定一个对象不是垃圾"></a> 怎么样确定一个对象不是垃圾？</h3>
<p>有两种定位垃圾的方式：</p>
<ol>
<li>引用计数法：这种方式是给堆内存当中的每个对象记录一个引用个数，引用个数为0的就认为是垃圾。这是早期JDK采用的方式，引用计数无法解决循环引用的问题</li>
<li>根可达算法：这种方式是在内存中，从引用根对象向下一直找引用，找不到的对象就是垃圾。</li>
</ol>
<h3 id="什么是gc-root"><a class="markdownIt-Anchor" href="#什么是gc-root"></a> 什么是GC Root？</h3>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量</li>
<li>在方法区中常量引用的对象，譬如字符串常量池里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointException），还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
</ul>
<h3 id="jvm有哪些垃圾回收算法"><a class="markdownIt-Anchor" href="#jvm有哪些垃圾回收算法"></a> JVM有哪些垃圾回收算法？</h3>
<table>
<thead>
<tr>
<th>算法</th>
<th>速度</th>
<th>空间开销</th>
<th>移动对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mark-Sweep</td>
<td>中等</td>
<td>少（但会堆积碎片）</td>
<td>否</td>
</tr>
<tr>
<td>Mark-Compact</td>
<td>最慢</td>
<td>少（不堆积碎片）</td>
<td>是</td>
</tr>
<tr>
<td>Copying</td>
<td>最快</td>
<td>通常需要活对象的2倍大小（不堆积碎片）</td>
<td>是</td>
</tr>
</tbody>
</table>
<h3 id="什么是stw"><a class="markdownIt-Anchor" href="#什么是stw"></a> 什么是STW？</h3>
<p>STW：stop the world，是在垃圾回收算法执行过程当中，需要将JVM内存冻结的一种状态，在STW状态下，Java所有的线程都是停止执行的，GC线程除外，只有native方法可以执行，但是，不能与JVM交互，GC各种算法优化的重点，就是减少STW，同时这也是JVM调优的重点。</p>
<h3 id="jvm有哪些垃圾回收器"><a class="markdownIt-Anchor" href="#jvm有哪些垃圾回收器"></a> JVM有哪些垃圾回收器？</h3>
<table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行或并发</th>
<th>新生代、老年代</th>
<th>算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial</td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理</td>
</tr>
<tr>
<td>CMS</td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除</td>
</tr>
<tr>
<td>G1</td>
<td>并发</td>
<td>不区分</td>
<td>标记-整理+复制算法</td>
</tr>
</tbody>
</table>
<h3 id="什么是三色标记算法"><a class="markdownIt-Anchor" href="#什么是三色标记算法"></a> 什么是三色标记算法？</h3>
<p>CMS的核心算法就是三色标记。</p>
<p>三色标记：是一种逻辑上的抽象，将每个内存对象分成三种颜色：黑色：表示自己和成员变量都已经标记完毕。灰色：自己标记完了，但是成员变量还没有完全标记完。白色：自己未标记完。</p>
<p>CMS通过增量标记increment update的方式来解决漏标的问题。</p>
<p>在G1当中采用SATB的方式来避免错标和漏标的情况。</p>
<h3 id="如何回收方法区"><a class="markdownIt-Anchor" href="#如何回收方法区"></a> 如何回收方法区？</h3>
<p>方法区的垃圾回收主要有两种，废弃的常量和无用的类，其中要称为无用的类，要同时满足下面三个条件：</p>
<ul>
<li>Java堆中不存在该类的任何实例对象</li>
<li>加载该类的类加载器已经被回收</li>
<li>该类对应的java.lang.Class对象不在任何地方被引用，且无法在任何地方通过反射访问该类的方法</li>
</ul>
<h3 id="jvm-中的安全点和安全区各代表什么"><a class="markdownIt-Anchor" href="#jvm-中的安全点和安全区各代表什么"></a> JVM 中的安全点和安全区各代表什么？</h3>
<h3 id="写屏障你了解吗"><a class="markdownIt-Anchor" href="#写屏障你了解吗"></a> 写屏障你了解吗？</h3>
<h3 id="解决并发扫描时对象消失问题的两种方案"><a class="markdownIt-Anchor" href="#解决并发扫描时对象消失问题的两种方案"></a> 解决并发扫描时对象消失问题的两种方案？</h3>
<h3 id="cms-垃圾收集器的步骤"><a class="markdownIt-Anchor" href="#cms-垃圾收集器的步骤"></a> CMS 垃圾收集器的步骤？</h3>
<p>1、初始标记阶段：STW 只标记出根对象直接引用的对象</p>
<p>2、并发标记：继续标记其他对象，与应用程序时并发执行</p>
<p>3、重新标记：STW对并发执行阶段的对象进行重新标记</p>
<p>4、并发清除：并行。将产生的垃圾清除。清除过程中，应用程序又会不断的产生新的垃圾，叫做浮动垃圾。这些垃圾就要留到下一次GC过程中清除。</p>
<h3 id="cms-有什么缺点"><a class="markdownIt-Anchor" href="#cms-有什么缺点"></a> CMS 有什么缺点？</h3>
<ul>
<li>CMS收集器对CPU资源非常敏感</li>
<li>CMS处理器无法处理浮动垃圾</li>
<li>在收集结束的时候，会产生大量的空间碎片</li>
</ul>
<h3 id="g1垃圾收集器的步骤g1有什么优缺点"><a class="markdownIt-Anchor" href="#g1垃圾收集器的步骤g1有什么优缺点"></a> G1垃圾收集器的步骤，G1有什么优缺点？</h3>
<p>G1的优点：</p>
<ul>
<li>停顿时间短</li>
<li>用户可以指定最大的停顿时间</li>
<li>不会产生内存碎片：G1的内存布局并不是固定大小以及固定数量的分代区域划分</li>
</ul>
<p>缺点：</p>
<p>G1需要记忆集（卡表）来记录新生代和老年代之间的引用关系，这种数据结构在G1中需要占用大量的内存，可能达到整个堆内存容量的20%甚至更多。而且G1中维护记忆集的成本较高，带来了更高的执行负载，影响效率。</p>
<p>CMS在小内存应用上的表现要优于G1，而大内存应用上G1更有优化，大小内存的界限是6GB到8GB。</p>
<h3 id="讲一下内存分配策略"><a class="markdownIt-Anchor" href="#讲一下内存分配策略"></a> 讲一下内存分配策略？</h3>
<h3 id="内存溢出和内存泄漏的区别"><a class="markdownIt-Anchor" href="#内存溢出和内存泄漏的区别"></a> 内存溢出和内存泄漏的区别？</h3>
<ul>
<li>
<p>内存溢出（Out of Memory）是指程序在申请内存时，没有足够的空间供其使用</p>
</li>
<li>
<p>内存泄漏（Memory Leak）是指程序在申请内存后，无法释放已申请的内存空间</p>
</li>
</ul>
<h3 id="如何进行jvm调优"><a class="markdownIt-Anchor" href="#如何进行jvm调优"></a> 如何进行JVM调优？</h3>
<p>JVM调优主要是通过定制JVM运行参数来提高Java应用程序的运行速度。</p>
<h3 id="jvm参数有哪些"><a class="markdownIt-Anchor" href="#jvm参数有哪些"></a> JVM参数有哪些？</h3>
<p>JVM参数大致可以分为三类：</p>
<p>１、标准指令：-开头，这些是所有的HotSpot都支持的参数。可以用Java -help打印出来。</p>
<p>２、非标准指令：-开头，这些指令通常是跟特定的HotSpot版本对应的，可以用Java -X打印出来</p>
<p>３、不稳定参数：-XX开头，这一类参数是跟特定HotSpot版本对应的，并且变化非常大，详细的文档资料非常少，在JDK1.8版本下，有几个常用的不稳定指令：Java -XX:+PrintCommandLineFlags：查看当前命令的不稳定指令。</p>
<h3 id="虚拟机基础故障处理工具有哪些"><a class="markdownIt-Anchor" href="#虚拟机基础故障处理工具有哪些"></a> 虚拟机基础故障处理工具有哪些？</h3>
<table>
<thead>
<tr>
<th>工具</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td>虚拟机进程状况工具</td>
</tr>
<tr>
<td>jstat</td>
<td>虚拟机统计信息监视工具</td>
</tr>
<tr>
<td>jinfo</td>
<td>Java配置信息工具</td>
</tr>
<tr>
<td>jmap</td>
<td>Java内存映射工具</td>
</tr>
<tr>
<td>jstack</td>
<td>Java堆栈跟踪工具</td>
</tr>
<tr>
<td>JVisualVM</td>
<td>图形化展示</td>
</tr>
<tr>
<td>JConsole</td>
<td>远程控制</td>
</tr>
</tbody>
</table>
<h3 id="怎么查看一个java进程的jvm参数谈谈你了解的jvm参数"><a class="markdownIt-Anchor" href="#怎么查看一个java进程的jvm参数谈谈你了解的jvm参数"></a> 怎么查看一个Java进程的JVM参数，谈谈你了解的JVM参数</h3>
<p>打印出所有不稳定参数所有默认值：<code>java -XX:+PrintFlagsInitial</code></p>
<p>打印出所有最终生效的不稳定指令：<code>java -XX:+PrintFlagsFinal</code></p>
<h3 id="什么情况下堆内存会溢出什么情况方法区会内存溢出"><a class="markdownIt-Anchor" href="#什么情况下堆内存会溢出什么情况方法区会内存溢出"></a> 什么情况下堆内存会溢出，什么情况方法区会内存溢出？</h3>
<p>栈溢出的典型例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//递归，调用自己</span></span><br><span class="line">       fun();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="数据库面试题"><a class="markdownIt-Anchor" href="#数据库面试题"></a> 数据库面试题</h1>
<h2 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h2>
<h3 id="为什么使用缓存"><a class="markdownIt-Anchor" href="#为什么使用缓存"></a> 为什么使用缓存？</h3>
<p>1、高性能</p>
<p>2、高可用</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630004746.png" alt="img" /></p>
<h3 id="什么是缓存穿透缓存击穿缓存雪崩怎么解决"><a class="markdownIt-Anchor" href="#什么是缓存穿透缓存击穿缓存雪崩怎么解决"></a> 什么是缓存穿透？缓存击穿？缓存雪崩？怎么解决？</h3>
<p>1）缓存穿透：缓存中查不多，数据库中也查询不到。</p>
<p>解决方案：1.对参数进行合法性校验 2.将数据库中没有查到的结果的数据也写入到缓存，这时要注意为了防止Redis被无用的key占满，这一类缓存的有效期要设置得短一点。3.引入布隆过滤器，在访问Redis之前判断数据是否存在。要注意布隆过滤器存在一定的误判率，并且，不空过滤器只能加数据不能删数据。</p>
 <img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630102137.png" alt="img" style="zoom:67%;" />
<p>2）缓存击穿：缓存中没有，数据库中有，一般是出现在数据初始化以及key过期了的情况，他的问题在于，重新写入缓存需要一定的时间，如果是在高并发场景下，过多的请求就会瞬间写到DB上，给DB造成了很大的压力。</p>
<p>解决方案：1、设置这个热点缓存永不过期，这时要注意在value 当中包含一个逻辑上的过期时间，然后另起一个线程，定期重建这些缓存。2、在加载DB的时候，要防止并发，只通过一个线程将数据库中的数据加载到缓存当中，从而减少数据库的并发访问量。</p>
<p>3）缓存雪崩：缓存大面积过期，导致请求都被转发DB，</p>
<p>解决方案：1、把缓存的失效时间分散开，例如，在原有的统一失效时间基础上，增加一个随机值。</p>
<h3 id="如何保证redis与数据库的数据一致"><a class="markdownIt-Anchor" href="#如何保证redis与数据库的数据一致"></a> 如何保证Redis与数据库的数据一致？</h3>
<p>当我们对数据进行修改的时候，到底是先删缓存，还是先写数据库？</p>
<p>1）如果是先删缓存，再写数据库：在高并发场景下，当第一个线程删除了缓存，还没有来得及的写数据库，第二个线程来独去数据，会发现缓存中的数据为空，那就会去读数据库中的数据（旧值、脏数据）读完之后，把读到的结果写入缓存（此时，第一个线程已经将新的值写到缓存里面了），这样缓存中的值就会被覆盖为修改前的脏数据。</p>
<p>总结：在这种方式下，通常要求写操作不会太频繁。</p>
<p>解决方案：1、先操作缓存，但是不删除缓存，将缓存修改为一个特殊值（-999），客户端读缓存时，发现是默认直，就休眠一小会，再去查一次Redis，特殊值对业务有侵入，可能会多次重复</p>
<p>2、延时双删，先删除缓存，再写数据库，休眠一小会，再次删除缓存。如果数据写操作很频繁，同样还是会有脏数据的问题。</p>
<p>2）先写数据库，再删缓存，如果数据库写完了之后，缓存删除失败，数据就会不一致，</p>
<p>总结：始终只能保证一定时间内的最终一致性。</p>
<p>解决方案：1、给缓存设置一个过期时间，问题：过期时间内，缓存数据不会更新。</p>
<p>2、引入MQ，保证原子操作。将热点数据缓存设置为永不过期，但是在value当中写入一个逻辑上的过期时间，另起一个后台线程，扫描这些key，对于已逻辑上过期的缓存，进行删除。</p>
<h3 id="如何设计一个分布式锁如何对锁性能进行优化"><a class="markdownIt-Anchor" href="#如何设计一个分布式锁如何对锁性能进行优化"></a> 如何设计一个分布式锁？如何对锁性能进行优化？</h3>
<p>分布式锁的本质：就是在所有进程都能访问到的一个地方，设置一个锁资源，让这些进程都来竞争锁的资源，数据库、zookeeper、Redis，通常对于分布式锁，会要求响应快、性能高与业务无关。</p>
<p>Redis实现分布式锁：SETNX key value 当key不存在时，就将key设置为value，并返回1，如果key存在就返回0。EXPIRE key locktime 设置key的有效市场，DEL key 删除。 GETSET key value 先GET，再SET，先返回key对应的值，如果没有就返回空，然后再将key设置成value。</p>
<ul>
<li>最简单的分布式锁：SETNX 加锁。DEL解锁。问题：如果获取到锁的进程执行失败，他就永远不会主动解锁，那这个锁就被锁死了。</li>
<li>给锁设置过期时长。问题：SETNX和EXPIRE并不是原子性的，所以获取到锁的进程有可能还没有执行EXPIRE指令，就挂了，这时锁还是会被锁死。</li>
<li>将锁的内容设置为过期时间（客户端时间+过期时长），SETNX获取锁失败时，拿这个时间跟当前时间比对，如果是过期的锁，就先删除锁，再重新上锁。问题：在高并发场景下，会产生多个进程同时拿到锁的情况</li>
<li>setNX失败后，获取锁上的时间戳，然后用getset，将自己的过期时间更新上去，并获取旧值，如果这个旧值，跟之前获得的时间戳是不一致的，就表示这个锁已经被其他进程占用了，自己要放弃竞争锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(RedisConnection conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> newTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> expireTime = nowTime + <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(conn.SETNX(<span class="string">&quot;mykey&quot;</span>),<span class="string">&quot;1&quot;</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        conn.EXPIRE(<span class="string">&quot;mykey&quot;</span>,<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> oldVal = conn.get(<span class="string">&quot;mykey&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span>(oldVal == <span class="keyword">null</span> &amp;&amp; oldVal &lt; nowTime) &#123;</span><br><span class="line">            <span class="keyword">long</span> currentVal = conn.GETSET(<span class="string">&quot;mykey&quot;</span>,expireTime)</span><br><span class="line">            <span class="keyword">if</span>(oldVal == currentVal) &#123;</span><br><span class="line">                conn.EXPIRE(<span class="string">&quot;mykey&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就形成了一个比较高效的分布式锁。分析一下，上面优化的各种问题，在于SETNX和EXPIRE两个指令无法保证原子性。Redis2.6提供了直接执行lua脚本的方式，通过lua脚本来保证原子性，redission。</p>
<h3 id="redis如何让配置key的过期时间他的实现原理是什么"><a class="markdownIt-Anchor" href="#redis如何让配置key的过期时间他的实现原理是什么"></a> Redis如何让配置key的过期时间？他的实现原理是什么？</h3>
<p>redis设置key的过期时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> EXPIRE | SETEX</span></span><br></pre></td></tr></table></figure>
<p>实现原理：</p>
<ul>
<li>定期删除：每隔一段时间，执行一次删除过期key的操作，平衡执行效率和执行时长。定期删除会遍历每个database（默认16个），检查当前库中指定个数的key（默认是20个），随机抽查这些key，如果有过期的，就删除。程序中有一个全局变量扫描到了哪个数据库。</li>
<li>懒汉式删除：当使用get、getset等指令去获取数据时，判断key是否过期，过期后，就先把key删除，再执行后面的操作。</li>
</ul>
<p>Redis是将两种方式结合来使用的。</p>
<h3 id="海量数据下如何快速查找一条记录"><a class="markdownIt-Anchor" href="#海量数据下如何快速查找一条记录"></a> 海量数据下，如何快速查找一条记录？</h3>
<p>1、使用布隆过滤器，快速过滤不存在的记录，使用Redis的bitmap结构来实现布隆过滤器。</p>
<p>2、在Redis中建立缓存</p>
<p>3、查询优化。自己实现槽位计算，找到记录应该分配在哪台集器上，然后直接去目标机器上找。</p>
<h3 id="rdb操作子进程会全部复制父进程的数据吗"><a class="markdownIt-Anchor" href="#rdb操作子进程会全部复制父进程的数据吗"></a> RDB操作，子进程会全部复制父进程的数据吗？</h3>
<p>RDB快照是一次全量备份，当进行快照持久化的时候会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以快照持久化期间修改的数据不会保存，存在丢失数据的可能性。</p>
<h3 id="redis的哨兵模式"><a class="markdownIt-Anchor" href="#redis的哨兵模式"></a> Redis的哨兵模式？</h3>
<h3 id="redis使用单线程为什么速度这么快"><a class="markdownIt-Anchor" href="#redis使用单线程为什么速度这么快"></a> Redis使用单线程为什么速度这么快？</h3>
<p>严格意义上来说，Redis Server是多线程的，只是它的请求处理整个流程是单线程处理的，我们平常说的Redis单线程快是指它的请求处理非常地块。</p>
<p>Redis每秒可以承受10w+的QPS，它如此优秀的性能主要取决于以下几个方面：</p>
<ul>
<li>
<p>纯内存操作</p>
<p>所有的数据都存储在内存当中，这意味着读写数据都是在内存中完成，并且使用哈希表的数据结构，只需要O(1)的时间复杂度。</p>
</li>
<li>
<p>使用IO多路复用技术</p>
<p>Redis采用IO多路复用计数和非阻塞IO，Redis可以在单线程中监听多个Socket的请求，在任意一个Socket可读/可写时，Redis去读取客户端请求，在内存中操作对应的数据，然后再写回到Socket中。</p>
</li>
<li>
<p>非CPU密集型任务</p>
<p>Redis的大部分操作并不是CPU密集型任务，而Redis的瓶颈在于内存和网络带宽，如果单个Redis实例的性能不足以支撑业务，推荐部署多个Redis节点，组成集群的方式来利用多核CPU的能力。</p>
</li>
<li>
<p>单线程的优势</p>
<p>没有了线程上下文切换的性能耗损，也没有了访问共享资源加锁的性能损耗，开发和调试非常友好，可维护性高。</p>
</li>
</ul>
<h3 id="redis自增命令使用"><a class="markdownIt-Anchor" href="#redis自增命令使用"></a> Redis自增命令使用？</h3>
<p>每当有原子性自增的操作就可以使用INCR命令，主要在计数器场景使用，可以INCR和EXPIRE，来达到规定的生存时间内进行计数的目的，客户端也可以通过使用GETSET命令原子性地获取计数器的当前值并将计数器清零。</p>
<p>使用其他自增/自减操作，比如DECR和INCRBY，用户可以通过执行不同的操作增加或者减少计数器的值。</p>
<h3 id="高并发下如何保证接口的幂等性"><a class="markdownIt-Anchor" href="#高并发下如何保证接口的幂等性"></a> 高并发下，如何保证接口的幂等性？</h3>
<p><a href="https://segmentfault.com/a/1190000039737646">https://segmentfault.com/a/1190000039737646</a></p>
<h2 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> MySQL</h2>
<h3 id="mysql有哪几种数据存储引擎"><a class="markdownIt-Anchor" href="#mysql有哪几种数据存储引擎"></a> MySQL有哪几种数据存储引擎?</h3>
<p>可以使用SQL查看支持的数据存储引擎：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> ENGINES;</span><br></pre></td></tr></table></figure>
<p>其中最为常用的是InnoDB和MyISAM两种，</p>
<p>MyISAM和InnoDB的区别：</p>
<ul>
<li>存储文件，MyISAM每个表有两个文件，MYD和MyISAM文件，MYD是数据文件，MYI是索引文件，而InnoDB每个表只有一个文件，idb</li>
<li>InnoDB支持事务，支持行锁，支持外键。</li>
<li>InnoDB支持XA事务。</li>
<li>InnoDB支持事务的savePoints</li>
</ul>
<h3 id="什么是脏读-不可重复读-幻读"><a class="markdownIt-Anchor" href="#什么是脏读-不可重复读-幻读"></a> 什么是脏读、不可重复读、幻读？</h3>
<p>脏读、不可重复读、幻读的概念：</p>
<ul>
<li>脏读：在事务进行过程中，读到了其他事务未提交的数据。</li>
<li>不可重复读：在一个事务过程中，多次查询的结果不一致。（update）</li>
<li>幻读：在同一个事务中，用同样的操作查询数据，得到的记录数不相同。(insert)</li>
</ul>
<p>处理的方式有很多种：加锁、事务隔离、MVCC，这里只介绍使用加锁来解决这些问题：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>处理方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>脏读</td>
<td>在修改时加排他锁，直到事务提交提交才释放，读取时加共享锁，读完释放锁</td>
</tr>
<tr>
<td>不可重复读</td>
<td>读数据时加共享锁，写数据时加排他锁</td>
</tr>
<tr>
<td>幻读</td>
<td>加范围锁</td>
</tr>
</tbody>
</table>
<h3 id="事务的基本特性和隔离级别"><a class="markdownIt-Anchor" href="#事务的基本特性和隔离级别"></a> 事务的基本特性和隔离级别</h3>
<p>事务：表示多个数据操作组成一个完整的事务单元，这个事务内的所有数据操作要么同时成功，要么同时失败。</p>
<p>事务的特性：ACID</p>
<ul>
<li>原子性：事务是不可分割的，要么完全成功，要么完全失败。</li>
<li>一致性：事务无论是完成还是失败。都必须保持事务内操作的一致性。当失败是，都要对前面的操作进行会滚，不管中途是否成功。</li>
<li>隔离性：当多个事务操作一个数据的时候，为防止数据损坏，需要将每个事务进行隔离，互相不干扰</li>
<li>持久性：事务开始就不会终止，他的结果不受其他外在因素的影响</li>
</ul>
<p>在MySQL中可以设置事务的隔离级别：</p>
<table>
<thead>
<tr>
<th>SQL语句</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHOW VARIABLES like ‘%transaction’</td>
<td>显示事务的隔离级别</td>
</tr>
<tr>
<td>set transction level **</td>
<td>设置隔离级别</td>
</tr>
<tr>
<td>set session transaction level **</td>
<td>当前会话的事务隔离级别</td>
</tr>
<tr>
<td>set global transaction level **</td>
<td>当前全局的事务隔离级别</td>
</tr>
</tbody>
</table>
<p>MySQL当中有五种隔离级别：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>NONE</td>
<td>不使用事务</td>
</tr>
<tr>
<td>READ UNCOMMITED</td>
<td>允许脏读</td>
</tr>
<tr>
<td>READ COMMITED</td>
<td>防止脏读，是最常用的隔离级别</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>防止脏读和不可重复读，MySQL默认</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>事务串行，可以防止脏读、幻读、不可重复度</td>
</tr>
</tbody>
</table>
<p>五种隔离级别，级别越高，事务的安全性是更高的，但是，事务的并发性能也会越低。</p>
<h3 id="mysql的锁有哪些什么是间隙锁"><a class="markdownIt-Anchor" href="#mysql的锁有哪些什么是间隙锁"></a> MySQL的锁有哪些？什么是间隙锁？</h3>
<p>从锁的粒度来区分：</p>
<p>1）行锁：加锁粒度小，但是加锁的资源开销比较大。InnoDB支持</p>
<p>共享锁：读锁，表示多个事务可以对同一个数据共享同一把锁，持有锁的事务都可以访问数据，但是只读不能修改。 <code>select ** LOCK IN SHARE MODE</code></p>
<p>排他锁：写锁，只有一个事务能够获得排他锁，其他事务都不能获取该行的锁。InnoDB会对update，delete、insert语句自动添加排他锁。select ** for update。</p>
<p>自增锁：通常是针对MySQL当中的自增字段。如果有事务会滚这种情况，数据会回滚，但是自增序列不会回滚。</p>
<p>2）表锁：加锁粒度大，加锁资源开销比较小，MyIAM和InnoDB都支持。</p>
<p>表共享读锁，表排他写锁</p>
<p>意向锁：是InnoDB自动添加的一种锁，不需要用户干预。</p>
<p>3）全局锁：Flush tables with read lock，加锁之后整个数据库实例都处于只读状态，所有的数据变更操作都会被挂起，一般用于全库备份的时候。</p>
<p>常见的锁算法：</p>
<p>1、记录锁：锁一条具体的数据。</p>
<p>2、间隙锁：RR隔离级别下，会加间隙锁。锁一定的范围，而不是锁具体的记录，是为了防止产生幻读。</p>
<p>3、Next-key：间隙锁 + 右记录锁。</p>
<h3 id="mysql索引结构是什么样的"><a class="markdownIt-Anchor" href="#mysql索引结构是什么样的"></a> MySQL索引结构是什么样的？</h3>
<p>二叉树 -&gt; AVL树 -&gt; 红黑树 -&gt; B-树 -&gt; B+树</p>
<p>二叉树：每个节点最多只有两个子节点，左边的子节点都比当前节点小，右边的子节点都比当前节点大。</p>
<p>AVL:树中任意节点的两个子树的高度差最大为1.</p>
<p>红黑树：1、每个节点都是红色或者黑色 2、根节点是黑色 3、每个叶子节点都是黑色的空节点。4、红色节点的父子节点都必须是黑色。5、从任一节点到其中每个叶子节点的所有路径都包含相同的黑色节点。</p>
<p>B-树：1、B-树的每个非叶子节点的子节点个数都不会超过D（这个D就是B-树的阶）2、所有的叶子节点都在同一层 3、所有节点关键字都是按照递增顺序排列。</p>
<p>B+树：1、非叶子节点不存储数据，只进行数据索引 2、所有数据都存储在叶子节点当中 3、每个叶子节点都存有相邻叶子节点的指针 4、叶子节点按照本身关键字从小到大排序。</p>
<h3 id="聚簇索引和非聚簇索引有什么区别"><a class="markdownIt-Anchor" href="#聚簇索引和非聚簇索引有什么区别"></a> 聚簇索引和非聚簇索引有什么区别？</h3>
<p>聚簇索引：数据和索引是在一起。</p>
<p>非聚簇索引：数据和索引不在一起。</p>
<p>MyISAM使用的非聚簇索引，树的子节点上的data不是数据本身，而是数据存放的地址，InnoDB采用的是聚簇索引，树的叶子节点上的data就是数据本身。</p>
<p>聚簇索引的数据是物理存放顺序和索引顺序是一致的，所以一个表中只能有一个聚簇索引，而非聚簇索引可以有多个。</p>
<p>InnoDB中，如果表定义了PK，那PK就是聚簇索引，如果没有PK，就会找一个非空的unique列作为聚簇索引。否则，InnoDB会创建一个隐藏的row-id作为聚簇索引。</p>
<h3 id="mysql的索引覆盖和回表是什么"><a class="markdownIt-Anchor" href="#mysql的索引覆盖和回表是什么"></a> MySQL的索引覆盖和回表是什么？</h3>
<p>如果只需要在一颗索引树上就可以获取SQL所需要的所有列，就不需要再回表查询，这样查询速度就可以更快。</p>
<p>实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引当中。</p>
<h3 id="mysql集群是如何搭建的读写分离是怎么做的"><a class="markdownIt-Anchor" href="#mysql集群是如何搭建的读写分离是怎么做的"></a> MySQL集群是如何搭建的？读写分离是怎么做的？</h3>
<p>MySQL主从结构原理：</p>
  <img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630005801.png" alt="img" style="zoom:67%;" />
<p>MySQL通过将主节点的Binlog同步给从节点完成主从之间的数据同步。</p>
<p>MySQL的主从集群只会讲Binlog从主节点同步到从节点，而不会反过来同步问题。</p>
<p>因为要保证主从之间的数据一致，写数据的操作只能在主节点完成。而读数据的操作，可以在主节点或者从节点上完成。</p>
<p>这种方式有丢失数据的风险，可以采用半同步的方式：</p>
  <img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630005820.png" alt="img" style="zoom:67%;" />
<h3 id="mysql如何进行分库分表多大数据量需要进行分库分表分库分表的方式和分片策略由哪些分库分表后sql语句执行流程是怎样的"><a class="markdownIt-Anchor" href="#mysql如何进行分库分表多大数据量需要进行分库分表分库分表的方式和分片策略由哪些分库分表后sql语句执行流程是怎样的"></a> MySQL如何进行分库分表？多大数据量需要进行分库分表？分库分表的方式和分片策略由哪些？分库分表后，SQL语句执行流程是怎样的？</h3>
<p>什么是分库分表：就是当表中的数据量过大时，整个查询效率就会降低的非常明显，这是为了提升查询效率，就要将一个表中的数据分散到多个数据库的多个表当中。</p>
<p>数据分片的方式有垂直分片和水平分片。垂直分片就是从业务角度将不同的表拆分到不同的表中，能够解决数据库数据文件过大的问题，但是不能从根本上解决查询问题。水平分片就是从数据角度将一个表中的数据拆分到不同的库或者表中，这样可以从根本上解决数据量过大造成的查询效率低的问题。</p>
<p>常见的分片策略有：</p>
<ul>
<li>取余/取模：优点：均匀存放数据，缺点，扩容非常麻烦</li>
<li>按照范围分片：比较好扩容，数据分布不够均匀</li>
<li>按照时间分片：比较容易将热点数据区分出来</li>
<li>按照枚举值分片：例如按地区分片</li>
<li>按照目标字段前缀指定进行分区：自定义业务规则分片</li>
</ul>
<p>建议：一个表的数据量超过500W或者数据文件超过2G，就要考虑分库分表了，分库分表最常用的组件：MyCat、ShardingSphere</p>
<p>ShardingSphere分库分表的执行流程：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630005831.png" alt="img" style="zoom:50%;" />
<p>与之相关的会衍生出一系列的问题，例如一个user表，按照userid进行了分片，然后我需要按照sex字段去查，这样怎么查？强制指定只查一个数据库，要怎么做？查询结果按照userid来排序，要怎么排？</p>
<p>分库分表也并不是完美的，在解决了一些问题的同时，也带来了一定的缺点：</p>
<ul>
<li>事务一致性问题</li>
<li>跨节点关联查询问题</li>
<li>跨节点分页、排序函数</li>
<li>主键避重</li>
</ul>
<h3 id="mysql的索引结构为什么使用b树"><a class="markdownIt-Anchor" href="#mysql的索引结构为什么使用b树"></a> Mysql的索引结构为什么使用B+树？</h3>
<p>总体来说有以下好处：</p>
<ul>
<li>可以减少磁盘IO的次数</li>
<li>能够很好的同时支持等值查询和范围查询
<ul>
<li>等值查询：哈希表、跳表不适合范围查询</li>
<li>范围查询：二叉树/红黑树可以很好的满足范围查询，但当树过高时，会带来磁盘IO过高的问题；B树的范围查询，会一直到根节点再到叶子节点查询，B+树解决了范围查询的带来的问题</li>
</ul>
</li>
<li>B的查询效率不稳定，在O(1-logN)之前，而B+树可以稳定在O(logN)</li>
</ul>
<p>完整链接：<a href="https://juejin.cn/post/7081065180301361183">https://juejin.cn/post/7081065180301361183</a></p>
<h3 id="mysql的三种删除方式的区别"><a class="markdownIt-Anchor" href="#mysql的三种删除方式的区别"></a> Mysql的三种删除方式的区别？</h3>
<table>
<thead>
<tr>
<th>删除方式</th>
<th>区别</th>
</tr>
</thead>
<tbody>
<tr>
<td>delete</td>
<td>删除数据，保留表结构，可以有条件的删除，也可以回滚数据，删除数据时进行两个动作：删除与备份</td>
</tr>
<tr>
<td>truncate</td>
<td>删除所有数据，无条件选择删除，不可回滚，保留表结构</td>
</tr>
<tr>
<td>drop</td>
<td>删除数据和表结构 删除速度最快</td>
</tr>
</tbody>
</table>
<h3 id="mysql的sql优化思路"><a class="markdownIt-Anchor" href="#mysql的sql优化思路"></a> MySQL的SQL优化思路？</h3>
<p>SQL优化的思路：</p>
<ul>
<li>定位优化对象的性能瓶颈，确定时IO还是CPU瓶颈</li>
<li>从Explain入手，保证索引生效</li>
</ul>
<h3 id="mysql的索引类型"><a class="markdownIt-Anchor" href="#mysql的索引类型"></a> MySQL的索引类型？</h3>
<p>MySQL目前主要有以下几种索引类型：</p>
<ul>
<li>普通索引</li>
<li>唯一索引</li>
<li>主键索引</li>
<li>组合索引</li>
<li>全文索引</li>
</ul>
<h2 id="elasticsearch"><a class="markdownIt-Anchor" href="#elasticsearch"></a> Elasticsearch</h2>
<h3 id="什么是倒排索引有什么好处"><a class="markdownIt-Anchor" href="#什么是倒排索引有什么好处"></a> 什么是倒排索引？有什么好处？</h3>
<p>索引：从id到内容。</p>
<p>倒排索引：从内容到id。好处：比较适合做关键字检索。可以控制数据的总量。提高查询效率。</p>
<p>搜索引擎为什么MySQL查询快？lucence是es的底层框架</p>
<p>文章 -&gt; term -&gt;排序 term dictionary （这里类似新华字典 目录）-&gt; term index（a开头的拼音） -&gt; Posting List -&gt; 文章ID，[在文章中出现的偏移量]，权重（TFIDF）</p>
<h3 id="es了解多少说说你们公司的es集群架构"><a class="markdownIt-Anchor" href="#es了解多少说说你们公司的es集群架构"></a> ES了解多少？说说你们公司的ES集群架构。</h3>
<p>是一个基于Lucene框架（是一个非常高效的全文检索引擎框架）的搜索引擎产品，you know for search,提供了restful风格的操作接口。</p>
<p>ES包含了一些核心概念：</p>
<ul>
<li>
<p>索引 index：类似关系型数据库中的table</p>
</li>
<li>
<p>文档 document：row</p>
<ul>
<li>字段 field text\keyword\byte：列</li>
</ul>
</li>
<li>
<p>映射Mapping：Schema</p>
<ul>
<li>查询方式：DSL（ES的新版本也支持SQL）</li>
</ul>
</li>
<li>
<p>分片sharding和副本replicas：index都是由sharding组成的。每个sharding都有一个或者多个备份。</p>
</li>
</ul>
<p>另外关于ES的使用场景：ES可以用在大数量的搜索场景下，另外ES也有很强大的计算能力，可以用在用户画像等场景。</p>
<h3 id="如何进行中文分词"><a class="markdownIt-Anchor" href="#如何进行中文分词"></a> 如何进行中文分词？</h3>
<p>IK分词器。HanLp中文分词器。</p>
<h3 id="es写入数据与查询数据的原理"><a class="markdownIt-Anchor" href="#es写入数据与查询数据的原理"></a> ES写入数据与查询数据的原理。</h3>
<p>写入数据的原理：</p>
<ol>
<li>
<p>客户端发写数据的请求是，可以发往任意节点，这个节点就会成为coordinating node 协调节点</p>
</li>
<li>
<p>计算的点文档要写入的分片：计算时就采用hash取模的方式计算</p>
</li>
<li>
<p>协调节点就会进行路由，将请求转发给对应的primary sharding所在的datanode。</p>
</li>
<li>
<p>datanode节点上的primary sharding处理请求，写入数据到索引库，并且将数据同步到对应的replica sharding</p>
</li>
<li>
<p>等promary sharding 和 replica sharding都保存好文档了之后，返回客户端响应</p>
</li>
</ol>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630005849.png" alt="img" style="zoom: 67%;" />
<p>查询数据的原理：</p>
<ol>
<li>客户端发送请求可发给任意节点，这个节点就成为协调节点；</li>
<li>协调节点将查询请求广播到每一个数据节点，这些数据节点的分片就会处理该查询请求；</li>
<li>每个分片进行数据查询，将符合条件的数据放在一个队列当中，并将这些数据的文档ID、节点信息、分片信息都返回给协调节点；</li>
<li>由协调节点将所有的返回结果进行汇总，并排序；</li>
<li>协调节点向包含这些文档ID的分片发送get请求，对应的分片将文档数据返回给协调节点，最后协调节点将数据整合返回给客户端。</li>
</ol>
<h3 id="es部署时要如何进行优化"><a class="markdownIt-Anchor" href="#es部署时要如何进行优化"></a> ES部署时，要如何进行优化？</h3>
<ol>
<li>集群部署优化</li>
<li>调整ES的一些重要参数。path.data尽量使用固态硬盘，定制JVM堆内存大小，ES的参数，实际上大部分情况下是不需要调优的，如果有性能问题，最好的办法是安排更合里的sharding布局并且增加节点数据。</li>
<li>更合理的sharding布局，让sharding对应的replica sharding尽量在同一个机房。</li>
<li>Linux服务器上一些优化策略，不要用root用户：修改虚拟内存大小，修改普通用户可以创建的最大线程数。</li>
</ol>
<p>ES生态：ELK日志收集解决方案：filebeat -&gt; logstash -&gt; elaticsearch -&gt; kibana。</p>
<h1 id="常用框架"><a class="markdownIt-Anchor" href="#常用框架"></a> 常用框架</h1>
<h2 id="spring面试题"><a class="markdownIt-Anchor" href="#spring面试题"></a> Spring面试题</h2>
<h3 id="spring框架中bean的创建过程是怎样的"><a class="markdownIt-Anchor" href="#spring框架中bean的创建过程是怎样的"></a> Spring框架中Bean的创建过程是怎样的？</h3>
<p>首先，简单来说，Spring框架中的Bean经历过四个阶段：实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>
<p>然后，具体来说Spring中Bean经过了以下几个步骤：</p>
<ol>
<li>实例化：new **()两个时机，1、当客户端向容器申请一个Bean时，2、当容器在初始化一个Bean时还需要依赖一个Bean，BeanDefinition对象保存。</li>
<li>设置对象属性（依赖注入）：Spring通过BeanDefinition找到对象依赖的其他对象，并将这些对象赋予当前对象。</li>
<li>处理Aware接口，Spring会检测对象是否实现了***Aware接口，如果实现了，就会调用对应的方法。BeanNameAware、BeanClassLoaderAware、BeanFactoryAware、ApplicationContextAware。</li>
<li>BeanPostProcess，Bean创建的前置处理。调用BeanPostProcess的初始化前的方法。</li>
<li>InitializingBean：Spring检测对象如果实现了这个接口，就会执行afterPropertiesSet()方法</li>
<li>init-method：自定义的初始化回调方法</li>
<li>BeanPorcess的后处理的方法，到这里，这个Bean创建过程就完成了，Bean就可以正常使用了。</li>
<li>DisposableBean，当Bena实现了这个接口，在对象销毁前就会调用destory()方法。</li>
<li>destory-method：自定义Bean销毁的回调方法。</li>
</ol>
<h3 id="spring框架中的bean是线程安全的吗如果线程不安全如何处理"><a class="markdownIt-Anchor" href="#spring框架中的bean是线程安全的吗如果线程不安全如何处理"></a> Spring框架中的Bean是线程安全的吗？如果线程不安全，如何处理？</h3>
<p>Spring容器本身没有提供Bean的线程安全策略，因此，也可以说Spring容器中的Bean不是线程安全的。</p>
<p>要如何处理线程安全问题。就要分情况来分析。</p>
<p>Spring中的作用域：1、Sington 2、prototype：为每个Bean请求创建给实例。3、request为每一个请求创建一个实例，请求完成后失败 4、session：与request是类似的 5、global-session：全局作用域。</p>
<p>对于线程安全问题：</p>
<p>1、对于prototype作用域，每次都生成一个新的对象，所以不存在线程安全问题。</p>
<p>2、对于sington作用域，默认就是线程不安全的。但是对于开发中大部分的Bean，其实是无状态的，不需要保证线程安全</p>
<p>无状态表示这个实例没有属性对象，不能保存数据，是不变的，比如：controller、service、dao</p>
<p>有状态表示实例有属性对象，可以保存数据，是线程不安全的，比如POJO</p>
<p>如果要保证线程安全，可以将Bean的作用改为prototype。也可以采用ThreadLocal来解决线程安全的问题，ThreadLocal为每一个线程保存一个副本变量，每个线程只操作自己的副本变量。</p>
<h3 id="spring是如何处理循环依赖问题的"><a class="markdownIt-Anchor" href="#spring是如何处理循环依赖问题的"></a> Spring是如何处理循环依赖问题的？</h3>
<p>一种是使用@Lazy注解，另一种是使用三级缓存。</p>
<p>循环依赖：多个对象之间存在循环的引用关系。在初始化过程中，就会出现”先有蛋还是先有鸡“的问题。</p>
<p>@Lazy注解：解决构造方法造成的循环依赖问题</p>
<p>对于对象之前的普通引用，二级缓存会保存new出来的不完整对象，这样当单例池中找不到依赖的属性时，就可以先从二级缓存中获取到不完整对象，完成对象的创建，在后续的依赖注入过程中，将单例池中对象的引用关系调整完成。</p>
<p>三级缓存：如果引用的对象配置了AOP，那在单例池中最终就会需要注入动态代理对象，而不是原对象，而生成动态代理是要在对象初始化完成之后才开始的。于是Spring增加了三级缓存，保存所有对象的动态代理配置信息，在发现有循环依赖时，将这个对象的动态代理信息获取出来，提前进行AOP，生成动态代理。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630003757.png" alt="img" style="zoom:67%;" />
<h3 id="spring如何处理事务"><a class="markdownIt-Anchor" href="#spring如何处理事务"></a> Spring如何处理事务?</h3>
<p>Spring当中支持编程式事务管理和声明式事务管理两种方式。</p>
<p>1、编程式事务可以用TransactionTemlate</p>
<p>2、声明式事务：是Spring在AOP基础上提供的事务实现机制，他的最大优点是不需要在业务代码中添加事务管理的代码，只需要在配置文件中做相关的事务规则声明就可以了，但是声明式事务只能针对方法级别，无法控制代码级别的事务管理。Spring中对事务定义了不同的传播级别：Propagation</p>
<ul>
<li>PROPAGATION_REQUIRED：默认传播行为。如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入到事务中。</li>
<li>PROPAGATION_SUPPORTS：如果当前存在事务，就加入到该事务，如果当前不存在事务，就以非事务方式运行。</li>
<li>PROPAGATION_MANDATORY:如果当前存在事务，就加入到该事务，如果当前不存在事务，就抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW：无论当前存不存在事务，都创建新事务进行执行。</li>
<li>PROPAGATION_NOT_SUPPORTS：以非事务方式运行，如果当前存在事务，就将当前事务挂起。</li>
<li>PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，就抛出异常。</li>
<li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则按REQUIRED属性执行。</li>
</ul>
<p>Spring中事务的隔离级别：</p>
<ul>
<li>ISOLATIUON_DEFAULT：使用数据库默认的事务隔离级别。</li>
<li>ISOLATION_READ_UNCOMMITED：读未提交，允许事务在执行过程中，读取其他事务未提交的数据</li>
<li>ISOLATION_READ_COMMITED：读已提交，允许事务在执行过程中，独去其他事务已经提交的数据</li>
<li>ISOLATION_REPEATABLE_UNCOMMITED：可重复度，在同一个事务内，任意时刻的查询结果是一致的。</li>
<li>ISOLATION_READ_SERIALIZABLE：所有事务依次执行。</li>
</ul>
<h3 id="spring-mvc中的控制器是不是单例模式如果是如何保证线程安全"><a class="markdownIt-Anchor" href="#spring-mvc中的控制器是不是单例模式如果是如何保证线程安全"></a> Spring MVC中的控制器是不是单例模式？如果是，如何保证线程安全？</h3>
<p>控制器是单例模式，单例模式下就会有线程安全问题。</p>
<p>Spring中保证线程安全的方法</p>
<p>1、将scope设置成singleton，propotype，request。</p>
<p>2、最好的方式是将控制器设计成无状态模式。在控制器中不要携带数据，但是可以引用无状态的service和dao。</p>
<h3 id="spring-mvc原理"><a class="markdownIt-Anchor" href="#spring-mvc原理"></a> Spring MVC原理？</h3>
<p>核心原理的示意图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210825110153.png" alt="Spring MVC示意图" style="zoom:50%;" />
<p>过程描述：</p>
<ul>
<li>将Spring MVC处理的请求映射到DispatcherServlet的servlet上</li>
<li>DispatcherServlet通过HandlerMapping去查找当前请求URL对应的Handler（通常是Controller中对应的一个方法）</li>
<li>执行对应的Handler方法</li>
<li>执行的过程中可能会调用若干的Service来完成业务的处理</li>
<li>DispatcherServlet根据ModelAndView中的ViewResolver（视图解析器）中找到对应的视图</li>
<li>DispatcherServlet将ModelAndView中的Model交给对应的View进行视图的渲染</li>
<li>渲染后，将视图转为HTTP响应流返回给客户端</li>
</ul>
<p>详细的示意图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210825111017.png" alt="Spring MVC详细示意图" style="zoom:50%;" />
<h3 id="spring事务失效的场景有哪些"><a class="markdownIt-Anchor" href="#spring事务失效的场景有哪些"></a> Spring事务失效的场景有哪些？</h3>
<ul>
<li>注解@Transactional配置的方法并非public权限修饰</li>
<li>注解@Transactional所在类非Spring容器管理的Bean</li>
<li>注解@Transactional所在类中，注解修饰的方法被类内部方法调用</li>
<li>业务代码抛出异常类型非RuntimeException，事务失效</li>
<li>业务代码中存在异常时，使用try…catch…语句块捕获，而catch语句块没有throw new RuntimeException异常</li>
<li>注解@Transactional中Propagation属性值设置错误即Propagation.NOT_SUPPORTED（一般不会设置此种传播机制）</li>
</ul>
<h3 id="spring中的service有多个实现类怎么注入"><a class="markdownIt-Anchor" href="#spring中的service有多个实现类怎么注入"></a> Spring中的Service有多个实现类，怎么注入？</h3>
<ul>
<li>使用@Qualifier(“BeanId”)来指定注入哪一个</li>
<li>使用@Resource(type=“类名.class”)来指定注入哪一个</li>
<li>每个Service的impl都可以指定名称（使用@Service(“名称”)），在Controller中注入service的时候使用名称来指定注入哪一个（使用@Resource(name=“名称”)）</li>
</ul>
<h2 id="springboot面试题"><a class="markdownIt-Anchor" href="#springboot面试题"></a> SpringBoot面试题</h2>
<h3 id="为什么springboot的-jar可以直接运行"><a class="markdownIt-Anchor" href="#为什么springboot的-jar可以直接运行"></a> 为什么SpringBoot的 jar可以直接运行？</h3>
<p><a href="https://blog.fundebug.com/2019/01/09/how-does-springboot-start/">https://blog.fundebug.com/2019/01/09/how-does-springboot-start/</a></p>
<h3 id="springboot自动装配过程及实现原理"><a class="markdownIt-Anchor" href="#springboot自动装配过程及实现原理"></a> SpringBoot自动装配过程及实现原理？</h3>
<h3 id="springboot如何防止表单重复提交"><a class="markdownIt-Anchor" href="#springboot如何防止表单重复提交"></a> SpringBoot如何防止表单重复提交？</h3>
<div class="note info"><p>幂等性，通俗的说就是一个接口，多次发起同一个请求，必须保证操作只能执行一次。</p></div>
<p>需要幂等性的场景：</p>
<ul>
<li>订单接口，不能多次创建订单</li>
<li>支付接口，重复支付同一笔订单只能扣一次钱</li>
<li>支付宝回调接口，可能会多次回调，必须处理重复回调</li>
<li>普通表单提交接口，因为网络超时、卡顿等原因多次点击提交，只能成功一次等等</li>
</ul>
<p>常见的方案：</p>
<ul>
<li>
<p>从数据库方面考虑，数据设计的时候，如果有唯一性，考虑建立唯一索引</p>
</li>
<li>
<p>从应用层面考虑，首先判断是单机服务还是分布式服务</p>
<ul>
<li>单机服务：考虑一些缓存Cache，利用缓存，来保证数据的重复提交</li>
<li>分布式服务：考虑将用户的信息，例如token和请求的url进行组装在一起形成令牌，存储到缓存中，例如redis，并设置超时时间为**秒，如此来保证数据的唯一性（利用了redis的分布式锁）</li>
</ul>
</li>
</ul>
<p>解决方案大致总结如下：</p>
<ul>
<li>唯一索引：防止新增脏数据</li>
<li>token机制：防止页面重复提交，实现接口的幂等性校验</li>
<li>分布式锁：redis（jredis、redisson）或zookeeper实现</li>
<li>悲观锁：获取数据的时候加锁（锁表或锁行）</li>
<li>乐观锁：基于版本号version实现，在更新数据那一刻校验数据</li>
<li>状态机：状态变更，更新数据时判断状态</li>
</ul>
<p>其中，前三种最为常见，更多内容可以参考：<a href="https://blog.csdn.net/ITBigGod/article/details/105510980">SpringBoot/Web项目防止表单/请求重复提交（单体和分布式）</a></p>
<h2 id="mybatis面试题"><a class="markdownIt-Anchor" href="#mybatis面试题"></a> MyBatis面试题</h2>
<h3 id="mybatis接口-mapper内的方法为什么不能重载"><a class="markdownIt-Anchor" href="#mybatis接口-mapper内的方法为什么不能重载"></a> Mybatis接口 Mapper内的方法为什么不能重载？</h3>
<p>Mybatis在XML文件中寻找对应的SQL语句的时候，会根据StrictMap&lt;String, MappedStatement&gt;中查找对应的MappedStatement，这里Map的key就是根据Mapper的全类名 + “.” + 方法名。一方面，StrictMap如果出现重复的key会直接抛出异常，另一方面，如果允许key重复，也就是允许Mapper内的方法重载，则无法定位到XML文件内唯一的SQL语句。</p>
<p>更多内容可以参考：<a href="https://www.cnblogs.com/Chenjiabing/p/13671589.html">Mybatis接口 Mapper内的方法为什么不能重载？</a></p>
<h3 id="mybatis的xml映射文件中不同的xml映射文件id是否可以重复"><a class="markdownIt-Anchor" href="#mybatis的xml映射文件中不同的xml映射文件id是否可以重复"></a> Mybatis的XML映射文件中，不同的XML映射文件，id是否可以重复？</h3>
<p>同一个namespace下的id不能重复，原因是 namespace + id 会作为Map&lt;String，MapperStatement&gt;的key使用，如果id重复会导致数据互相覆盖。</p>
<h3 id="和的区别是什么"><a class="markdownIt-Anchor" href="#和的区别是什么"></a> #{}和${}的区别是什么？</h3>
<p>#{} 是预编译处理，${}是字符串替换。</p>
<ul>
<li>Mybatis在处理#{}时，会将sql中的#{}替换为“？”号，调用PreparedStatement的set方法来赋值</li>
<li>Mybatis在处理${}时，就是把${}替换程变量的值</li>
</ul>
<p>使用#{}可以有效的放置SQL注入，提高系统的安全性。</p>
<h3 id="当实体类中的属性名和表中的字段名不一样怎么办"><a class="markdownIt-Anchor" href="#当实体类中的属性名和表中的字段名不一样怎么办"></a> 当实体类中的属性名和表中的字段名不一样怎么办？</h3>
<ul>
<li>通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</li>
<li>通过<resultMap>来映射字段名和实体类属性名的一一对应的关系。</li>
</ul>
<h3 id="模糊查询like语句该怎么写"><a class="markdownIt-Anchor" href="#模糊查询like语句该怎么写"></a> 模糊查询like语句该怎么写？</h3>
<ul>
<li>在java代码中添加sql通配符</li>
<li>在sql语句中拼接通配符，会引起sql注入</li>
</ul>
<h3 id="mybatis时如何进行分页的分页插件的原理是什么"><a class="markdownIt-Anchor" href="#mybatis时如何进行分页的分页插件的原理是什么"></a> Mybatis时如何进行分页的？分页插件的原理是什么?</h3>
<p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。</p>
<h3 id="mybatis有哪些动态sql"><a class="markdownIt-Anchor" href="#mybatis有哪些动态sql"></a> Mybatis有哪些动态sql？</h3>
<p>tirm、where、set、foreach、if、choose、when、otherwise、bind。</p>
<h3 id="mybtais动态sql有什么用执行原理是什么"><a class="markdownIt-Anchor" href="#mybtais动态sql有什么用执行原理是什么"></a> Mybtais动态sql有什么用？执行原理是什么？</h3>
<p>MyBatis动态sql可以在XML映射文件内，以标签的形式编写动态sql，执行原理时根据表达式的值，完成逻辑判断并动态拼接sql的功能。</p>
<h3 id="mapper编写有哪几种方式"><a class="markdownIt-Anchor" href="#mapper编写有哪几种方式"></a> Mapper编写有哪几种方式？</h3>
<ul>
<li>接口实现类继承SqlSessionDaoSupport，需要编写mapper接口，mapper接口实现类、mapper.xml文件</li>
<li>使用org.mybatis.spring.mapper.MapperFactoryBean;</li>
<li>使用mapper扫描器</li>
</ul>
<h3 id="mybatis的一级-二级缓存"><a class="markdownIt-Anchor" href="#mybatis的一级-二级缓存"></a> Mybatis的一级、二级缓存？</h3>
<ul>
<li>一级缓存：基于PerpetuaCache的HashMap本地缓存，其存储作作用域为Session，默认打开一级缓存</li>
<li>二级缓存与一级缓存机制相同，不做其作用域为Sessionfactory，该缓存是以namespace为单位的（也就是一个Mapper.xml文件），不同namespace下的操作互不影响。</li>
</ul>
<blockquote>
<p>使用二级缓存需要实现序列化接口。</p>
</blockquote>
<h3 id="mybatis有二级缓存为什么还要用redis"><a class="markdownIt-Anchor" href="#mybatis有二级缓存为什么还要用redis"></a> Mybatis有二级缓存，为什么还要用redis？</h3>
<p>使用Mybatis的二级缓存可能会存在如下两个问题：</p>
<ul>
<li>所有对数据表的改变都会刷新缓存，但是一般不要使用二级缓存，例如在UserMappper.xml中有大多数针对user表的操作，但是在另一个***Mapper.xml中，还有针对user单表的操作，这会导致user在两个命名空间下的数据不一致</li>
<li>如果在UserMappper.xml做了刷新缓存的操作，在***Mapper.xml中缓存仍然有效，如果有针对user的单表查询，使用缓存的结果可能会不正确</li>
</ul>
<p>而Redis很好的解决了这个问题，并且还有其它的特性，例如可以搭建在其它服务器上，缓存的容量可扩展等。</p>
<h3 id="mybatis如何开启二级缓存"><a class="markdownIt-Anchor" href="#mybatis如何开启二级缓存"></a> Mybatis如何开启二级缓存？</h3>
<p><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">https://tech.meituan.com/2018/01/19/mybatis-cache.html</a></p>
<h2 id="netty面试题"><a class="markdownIt-Anchor" href="#netty面试题"></a> Netty面试题</h2>
<h3 id="netty有哪些应用场景"><a class="markdownIt-Anchor" href="#netty有哪些应用场景"></a> Netty有哪些应用场景？</h3>
<ul>
<li>作为RPC框架的网络通信工具</li>
<li>实现Http服务器</li>
<li>实现即时通讯系统</li>
<li>实现消息推送系统</li>
</ul>
<h3 id="netty核心组件有哪些分别有什么作用"><a class="markdownIt-Anchor" href="#netty核心组件有哪些分别有什么作用"></a> Netty核心组件有哪些？分别有什么作用？</h3>
<table>
<thead>
<tr>
<th style="text-align:center">核心组件</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Channel</td>
<td style="text-align:left">Channel接口是Netty对网络操作的抽象类，它包含了基本的I/O操作，如bind()、connect()、read()、write()等</td>
</tr>
<tr>
<td style="text-align:center">EventLoop</td>
<td style="text-align:left">EventLoop（事件循环）定义了Netty的核心抽象，用于处理连接的生命周期中所发生的事件，他的主要作用是负责监听网络事件并调用事件处理器进行相关I/O操作的处理</td>
</tr>
<tr>
<td style="text-align:center">ChannelFuture</td>
<td style="text-align:left">用于注册异步执行结果的监听器</td>
</tr>
<tr>
<td style="text-align:center">ChannelHandler</td>
<td style="text-align:left">消息的具体处理器，负责读写操作、客户端连接等事情</td>
</tr>
<tr>
<td style="text-align:center">ChannelPipeline</td>
<td style="text-align:left">ChannelPipeline为ChannelHandler的链，提供了一个容器并定义了用于沿着链传播入站和出战事件流的API。当Channel被创建时，它会被自动地分配到它专属的ChannelPipeline。使用者可以在ChannelPipeline上通过addLast()方法添加一个或者多个ChannelHandler，因为一个数据或事件可能需要多个ChannelHandler来进行处理，在ChannelPipeline中，当一个ChannelHandler处理完之后就会将数据交给下一个ChannelHandler</td>
</tr>
</tbody>
</table>
<h3 id="eventloopgroup了解么和eventloop什么关系"><a class="markdownIt-Anchor" href="#eventloopgroup了解么和eventloop什么关系"></a> EventLoopGroup了解么?和EventLoop什么关系?</h3>
<h3 id="bootstrap和serverbootstrap了解么"><a class="markdownIt-Anchor" href="#bootstrap和serverbootstrap了解么"></a> Bootstrap和ServerBootstrap了解么？</h3>
<p>BootStrap是客户端的启动引导类/辅助类，具体使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    <span class="comment">//指定线程模型</span></span><br><span class="line">    b.group(group).</span><br><span class="line">            ......</span><br><span class="line">    <span class="comment">// 尝试建立连接</span></span><br><span class="line">    ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 优雅关闭相关线程组资源</span></span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServerBootStrap是客户端的启动引导类/辅助类，具体使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">        b.group(bossGroup, workerGroup).</span><br><span class="line">               ......</span><br><span class="line">        <span class="comment">// 6.绑定端口</span></span><br><span class="line">        ChannelFuture f = b.bind(port).sync();</span><br><span class="line">        <span class="comment">// 等待连接关闭</span></span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//7.优雅关闭相关线程组资源</span></span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出：</p>
<ul>
<li>BootStrap通常使用connet()方法连接到远程的主机和端口，作为Netty TCP协议通信中的客户端。另外，Bootstrap也可以通过bind()方法绑定本地的一个端口，作为UDP协议通信中的一段</li>
<li>ServerBootStrap通常使用bind()方法绑定在本地的端口上，然后等待客户端的连接</li>
<li>BootStrap只需要配置一个事件循环组，而ServerBootStrap需要配置两个事件循环组，一个用于接收连接，一个用于具体的处理</li>
</ul>
<h3 id="nioeventloopgroup默认的构造函数会起多少线程"><a class="markdownIt-Anchor" href="#nioeventloopgroup默认的构造函数会起多少线程"></a> NioEventLoopGroup默认的构造函数会起多少线程？</h3>
<p>CPU核心线程数*2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从1，系统属性，CPU核心数*2 这三个值中取出一个最大的</span></span><br><span class="line"><span class="comment">//可以得出 DEFAULT_EVENT_LOOP_THREADS 的值为CPU核心数*2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当指定的线程数nThreads为0时，使用默认的线程数DEFAULT_EVENT_LOOP_THREADS</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="netty线程模型了解么"><a class="markdownIt-Anchor" href="#netty线程模型了解么"></a> Netty线程模型了解么？</h3>
<p>基于Reactor线程模型，Reactor采用多路复用将事件分发给相应的Handler处理，非常适合处理海量IO的场景。</p>
<h3 id="netty服务端和客户端的启动过程了解么"><a class="markdownIt-Anchor" href="#netty服务端和客户端的启动过程了解么"></a> Netty服务端和客户端的启动过程了解么？</h3>
<h3 id="netty长连接-心跳机制了解么"><a class="markdownIt-Anchor" href="#netty长连接-心跳机制了解么"></a> Netty长连接、心跳机制了解么？</h3>
<h3 id="netty的零拷贝了解么"><a class="markdownIt-Anchor" href="#netty的零拷贝了解么"></a> Netty的零拷贝了解么？</h3>
<p>零拷贝是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域，这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。在OS层面上的零拷贝技术通常指避免在用户态和内核态之间来回拷贝数据。在Netty中，零拷贝主要体现在：</p>
<ul>
<li>使用Netty提供的CompositeByteBuf类，可以将多个ByteBuf合并为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝</li>
<li>ByteBuf支持slice操作，因此可以将ByteBuf分为多个共享同一个存储区域的ByteBuf，避免了内存的拷贝</li>
<li>通过FileRegion包装的FileChannel.tranferTo实现文件传输，可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题</li>
</ul>
<h1 id="认证授权"><a class="markdownIt-Anchor" href="#认证授权"></a> 认证授权</h1>
<h2 id="网络安全"><a class="markdownIt-Anchor" href="#网络安全"></a> 网络安全</h2>
<h3 id="什么是认证和授权如何设计一个权限认证框架"><a class="markdownIt-Anchor" href="#什么是认证和授权如何设计一个权限认证框架"></a> 什么是认证和授权？如何设计一个权限认证框架？</h3>
<p>认证：就是对系统访问者的身份进行确认（用户名密码登录、二维码登录、指纹、刷脸…）。</p>
<p>授权：就是对系统访问者的行为进行控制，授权通常是在认证之后，对系统内的隐私数据进行保护，后台接口访问权限，前台控件的访问权限。</p>
<p>通常情况下我们通过RBAC模型，也就是用户关联角色 ，而角色访问不同的资源，从而控制用户访问系统的行为。</p>
<p>认证和授权也是对一个权限认证框架进行评估的两个主要的方面。</p>
<h3 id="cookie和session有什么区别如果没有cookie-seesion还能进行身份验证吗"><a class="markdownIt-Anchor" href="#cookie和session有什么区别如果没有cookie-seesion还能进行身份验证吗"></a> cookie和session有什么区别？如果没有Cookie、Seesion还能进行身份验证吗？</h3>
<p>当服务器tomcat第一次接收到客户端的请求时，会开辟一块独立的session空间，建立一个session对象，同时会生成session id，通过响应头的方式保存到客户端浏览器的cookie当中，以后客户端的每次请求，都会在请求头部带上这个session id，这样就可以对应上服务端的一些会话信息，比如用户的登录状态。</p>
<p>如果没有客户端的cookie，session是无法进行身份验证的。</p>
<p>当服务端从单体应用升级为分布式之后，cookie + session要如何扩展？</p>
<ul>
<li>session黏贴，在负载均衡中，通过某种机制，保证同一个客户端的所有请求都会转发到同一个tomcat实例当中。当这个tomcat实例出现问题之后，请求就会被转发到其他实例，这时候用户的session用户信息就丢失了。</li>
<li>session复制：当一个tomcat实例上保存了session信息后，主动将session复制到集群中的其他实例。问题：复制是需要时间的，在复制的过程中，容器产生session信息丢失。</li>
<li>session共享，就是将服务端的session信息保存到一个第三方中，比如Redis</li>
</ul>
<h3 id="什么是csrf攻击如何防止"><a class="markdownIt-Anchor" href="#什么是csrf攻击如何防止"></a> 什么是CSRF攻击？如何防止？</h3>
<p>CSRF：Cross Site Request Forgery 跨站请求伪造。</p>
<p>一个正常的请求会将合法用户的session id保存到浏览器的cookie，这时候，如果用户在浏览器中打开另一个Tab页，那这个tab页也是可以获得浏览器的cookie，黑客就可以利用这个cookie信息进行攻击</p>
<p>攻击过程：</p>
<ol>
<li>
<p>某银行网站A可以以GET请求的方式发起转账操作。<em><a href="http://www.xxx.com/transfor.do?accountNum=100&amp;money=1000">www.xxx.com/transfor.do?accountNum=100&amp;money=1000</a></em> accountNum表示目标账户，这个请求肯定是需要登录才可以正常访问的，</p>
</li>
<li>
<p>攻击者在某个论坛或者网站上上传一个图片，链接地址是 <em><a href="http://www.xxx.com/transfor.do?accountNum=100&amp;money=1000">www.xxx.com/transfor.do?accountNum=100&amp;money=1000</a></em>，其中accountNum就是攻击者自己的银行账户。</p>
</li>
<li>
<p>如果有一个用户，登录了银行网站，然后又打开浏览器的另一个Tab页，点击了这个图片，这时，银行就会受理到一个带了正确的cookie的请求，就会完成转账，用户的钱就被盗了。</p>
</li>
</ol>
<p>防止CSRF的方式：</p>
<ol>
<li>尽量使用POST请求，限制GET请求，POST请求可以带请求体，攻击者就不容易伪造出请求。</li>
<li>将cookie设置为HttpOnly：response.setHeader(“Set-Cookie”,“cookiename=cookievalue;HttpOnly”)。</li>
<li>增加token：在请求中放入一个攻击者无法伪造的信息，并且该信息不存在于cookie当中。</li>
<li>增加一个额外的隐藏信息<code>&lt;input type='hidden' value='demo'&gt;</code>这也是Spring Security框架中采用的防范方式。</li>
</ol>
<h3 id="什么是oauth2有哪几种认证方式"><a class="markdownIt-Anchor" href="#什么是oauth2有哪几种认证方式"></a> 什么是OAuth2？有哪几种认证方式？</h3>
<p>OAuth2.0是一个开放标准，允许用户授权在第三方应用程序访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方应用分享他们数据的所有内容。</p>
<p>OAuth2.0的协议认证流程，简单理解，就是允许我们将之前的授权和认证过程交给一个独立的第三方进行担保。</p>
<p>OAuth2.0协议有四种模式：</p>
<p>授权码模式：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630010003.png" alt="img" style="zoom:67%;" />
<p>简化模式：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630010013.png" alt="img" style="zoom:67%;" />
<p>密码模式：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630010023.png" alt="img" style="zoom:67%;" />
<p>客户端模式：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630010030.png" alt="img" style="zoom:67%;" />
<p>在梳理OAuth2.0协议流程的过程中，其实有一个主线，就是三方参与者的信任程度。</p>
<h3 id="什么是jwt令牌和普通令牌有什么区别"><a class="markdownIt-Anchor" href="#什么是jwt令牌和普通令牌有什么区别"></a> 什么是JWT令牌？和普通令牌有什么区别？</h3>
<p>普通令牌只是一个普通的字符串，没有特殊的意义，这就意味着，当客户端带上令牌去访问应用的接口时，应用本身无法判断这个令牌是否正确，他就需要到授权服务器上去拍段令牌是否有效，在高并发的场景下，检查令牌的网络请求就有可能成为一个性能瓶颈。</p>
<p>改良的方式就是JWT令牌，将令牌对应的相关信息全部冗余到令牌本身，这样资源服务器就不再需要发送求请给授权服务器去检查令牌了，他自己就可以读取到令牌的授权信息。JWT令牌的本质就是一个加密的字符串。</p>
<h3 id="什么是sso与oauth20有什么关系"><a class="markdownIt-Anchor" href="#什么是sso与oauth20有什么关系"></a> 什么是SSO？与OAuth2.0有什么关系？</h3>
<p>OAuth2.0的使用场景通常称为联合登录，一处注册，多处使用。</p>
<p>SSO：Single Sign ON：一处登录，多处同时登录。</p>
<p>SSO的实现关键是将Seesion信息几种存储，通常使用Spring Security实现</p>
<h3 id="如何设计一个开放授权平台"><a class="markdownIt-Anchor" href="#如何设计一个开放授权平台"></a> 如何设计一个开放授权平台？</h3>
<p>开发授权平台可以按照认证和授权两个方向来梳理。</p>
<ul>
<li>认证：可以按照OAuth2.0协议来规划认证的过程</li>
<li>授权：首先需要待接入的第三方应用在开放授权平台进行注册，注册需要提供几个必要的信息：clintID，消息推送地址（一堆公私钥），私钥由授权平台自己保存，公钥分发给第三方应用。然后，第三方应用引导可户发起请求时，采用公钥进行参数加密，然后授权开放平台使用对应的私钥解密。接下来，授权开放平台同步响应第三方应用的只是消息是否处理成功的结果，而真正的业务数据由授权开放平台异步推送给第三方应用预留的推送地址。</li>
</ul>
<h1 id="微服务分布式"><a class="markdownIt-Anchor" href="#微服务分布式"></a> 微服务/分布式</h1>
<h2 id="微服务"><a class="markdownIt-Anchor" href="#微服务"></a> 微服务</h2>
<h3 id="谈谈你对微服务的理解微服务有哪些优缺点"><a class="markdownIt-Anchor" href="#谈谈你对微服务的理解微服务有哪些优缺点"></a> 谈谈你对微服务的理解，微服务有哪些优缺点？</h3>
<p>微服务是由Martin Flowler大师提出的。微服务是一种架构风格，通过将大型的单体应用划分为比较小的服务单元，从而降低整个系统的复杂度。</p>
<p>具有以下优点：</p>
<ul>
<li>服务部署更灵活：每个应用都可以是一个独立的项目，可以独立部署，不依赖其他服务，耦合性降低。</li>
<li>技术选型更加灵活，在大型大体应用中，技术要进行更新，往往是非常困难的。而微服务可以根据业务特点，灵活选择技术栈。</li>
<li>应用的性能得到提高，大型单体应用中，往往启动就会成为一个很大的难关，而采用微服务之后，整个系统的性能是能够提高的。</li>
<li>更容易组合专门的团队，在单体应用中，团队成员往往需要对系统的各个部分都要有深入的了解，门槛是很高的。而采用微服务之后，可以给每个微服务组件专门的团队</li>
<li>代码复用：很多底层服务可以以REST API的方式对外提供统一的服务，所有基础服务可以在整个微服务系统中调用。</li>
</ul>
<p>对应的有以下缺点：</p>
<ul>
<li>服务调用的复杂性提高了，面临网络问题、容错问题、负载问题、高并发等等问题</li>
<li>分布式事务，尽量不要使用微服务的分布式事务</li>
<li>测试的难度提升了</li>
<li>运维的难度提升了，单体架构只要维护一个环节，而到了微服务是很多个环境，并且运维方式还都不一样。所以对部署、监控、告警等要求就会变得非常困难</li>
</ul>
<h3 id="springcloud和springcloudalibaba有哪些组件都解决了什么问题"><a class="markdownIt-Anchor" href="#springcloud和springcloudalibaba有哪些组件都解决了什么问题"></a> SpringCloud和SpringCloudAlibaba有哪些组件？都解决了什么问题？</h3>
<p>1、SpringCloud：提供了构建微服务系统所需要的一组通用开发模式以及一系列快速实现这些开发模式的工具。</p>
<p>通常所说的SpringCloud是指SpringCloud NetFlix，他和SpringCloudAlibaba都是SpringCloud这一系列开发模式的具体实现。</p>
<p>SpringCloud NetFlix:</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630003155.png" alt="img" style="zoom:67%;" />
<p>SpringCloudAlibaba:</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630003208.png" alt="img" style="zoom:67%;" />
<h3 id="springcloud和dubbo的区别"><a class="markdownIt-Anchor" href="#springcloud和dubbo的区别"></a> SpringCloud和Dubbo的区别？</h3>
<p>SpringCloud使用基于HTTP的REST方式，而Dubbo采用RPC通信。这两种方式各有优劣，前者牺牲了服务调用的性能，但也能避免原生RPC带来的问题，不存在代码级别的强依赖。</p>
<h3 id="分布式事务如何处理怎么保证事务一致性"><a class="markdownIt-Anchor" href="#分布式事务如何处理怎么保证事务一致性"></a> 分布式事务如何处理？怎么保证事务一致性？</h3>
<p>强一致性（刚性事务）。误区：分布式事务=Seata</p>
<p>分布式事务：就是要将不同节点上的事务操作，提供操作的原子性保证，同时成功或者同时失败。</p>
<p>分布式事务的第一个要点就是要在原本没有直接关联的事务之间建立联系。</p>
<p>1）HTTP连接：最大努力通知 --事后补偿</p>
<p>2）MQ：事务消息机制</p>
<p>3）Redis：也可以定制出分布式事务机制。</p>
<p>4）Seata：是通过TC来在多个事务之间建立联系的。</p>
<p>两阶段：AT XA 核心在于要锁资源，数据库提供了对于事务和锁良好的支持，因此使用AT模式的前题是要应用能够访问到数据库。</p>
<p>三阶段：TCC 在两阶段的基础上增加一个准备阶段，在准备阶段是不锁资源的，只是表示初始化连接。</p>
<p>SAGA模式：类似于熔断。业务自己实现正向操作和补偿的逻辑。只保证了事务的最终一致性</p>
<h3 id="怎么拆分微服务怎样设计出高内聚-低耦合的微服务"><a class="markdownIt-Anchor" href="#怎么拆分微服务怎样设计出高内聚-低耦合的微服务"></a> 怎么拆分微服务？怎样设计出高内聚、低耦合的微服务？</h3>
<p>拆分微服务的时候，为了保证微服务的稳定，会有一些基本的准则：</p>
<ul>
<li>微服务之间尽量不要有业务交叉。</li>
<li>微服务之间只能通过接口进行服务调用，而不能绕过接口直接访问对方的数据</li>
<li>高内聚，低耦合。</li>
</ul>
<blockquote>
<p>高内聚低耦合，是一种从上而下指导微服务设计的方法。·实现高内聚低耦合的工具主要有同步的接口调用和异步的事件驱动（MQ）两种方式。</p>
</blockquote>
<h3 id="有没有了解通过ddd领域驱动设计"><a class="markdownIt-Anchor" href="#有没有了解通过ddd领域驱动设计"></a> 有没有了解通过DDD领域驱动设计？</h3>
<p>什么是DDD：在2004年，由Eric Evans提出的，DDD是面对软件复杂之道。Domain-Driven-Design</p>
<p>Martin Flowler - 贫血模型 - 贫血失忆症 充血模型</p>
<p>MVC架构 -&gt; 领域优先的四层架构</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630002318.png" alt="img" style="zoom: 67%;" />
<p>大泥团：不利于微服务的拆分，大泥团结构拆分出来的微服务就是泥团结构，当服务业务逐渐复杂，这个泥团又会膨胀成为大泥团。</p>
<p>DDD只是一种方法论，没有一个稳定的技术框架。DDD要求领域是跟技术无关、跟存储无关、跟通信无关。</p>
<h3 id="什么是中台中台和微服务有什么关系"><a class="markdownIt-Anchor" href="#什么是中台中台和微服务有什么关系"></a> 什么是中台？中台和微服务有什么关系？</h3>
<p>中台这个概念是阿里在2015年提出“小前台、大中台”战略思想。</p>
<p>所谓中台，就是将各个业务线中可以复用的一些功能抽取出来，剥离个性，提取共性，形成一些可以可复用的组件，例如：盒马鲜生、团购。</p>
<p>大体上，中台可以分为三类：业务中台、数据中台和技术中台。数据中台、收银中台、支付风控中台。</p>
<p>中台跟DDD解合：DDD会通过限界上下文将系统拆分成一个一个领域，而这种限界上下文，天生就成了中台之间的逻辑屏障。</p>
<p>DDD在技术与资源调度方面都能够给中台建设提供不错的指导。上层的战略设计能够很好的指导中台划分，下层的战术设计能够很好的指导微服务搭建。</p>
<p>在目前阶段，DDD还大都处在小范围实验的阶段。</p>
<h3 id="你的项目中是怎么保证微服务敏捷开发的"><a class="markdownIt-Anchor" href="#你的项目中是怎么保证微服务敏捷开发的"></a> 你的项目中是怎么保证微服务敏捷开发的？</h3>
<p>开发运维一体化。</p>
<p>敏捷开发：目的就是为了提高团队的交付效率，快速迭代，快速试错。</p>
<p>每个月固定发布新版本，以分支的形式保存到代码仓库中，快速入职。任务面板、站立会议。团队人员灵活流动，同时形成各个专家代表。测试环境 -&gt; 开发测试环境 -&gt; 集成测试环境 -&gt; 压测环境 -&gt; 预投产环境 -&gt; 生产环境。文档优先。晨会、周会、需求拆分会。</p>
<h3 id="微服务的链路追踪-持续集成-ab发布要怎么做"><a class="markdownIt-Anchor" href="#微服务的链路追踪-持续集成-ab发布要怎么做"></a> 微服务的链路追踪、持续集成、AB发布要怎么做？</h3>
<p>链路追踪：1、基于日志，形成全局事务ID，落地到日志文件。filebeat -logstash- Elaticsearch形成大型报表。 2、基于MQ，往往需要架构支持，经过流式计算形成一些可视化的结果。</p>
<p>持续集成：SpringBoot maven pom -&gt; build -&gt; shell；jenkins。</p>
<p>AB发布：1、蓝绿发布、红黑发布。老版本和新版本是同时存在的。2、灰度发布。金丝雀发布。</p>
<h3 id="nacos和eureka的区别"><a class="markdownIt-Anchor" href="#nacos和eureka的区别"></a> Nacos和Eureka的区别？</h3>
<ul>
<li>Nacos提供了服务的注册与发现，同时也提供了配置中心，而Eureka只提供了服务注册与发现</li>
<li>Nacos本身支持负载均衡，而Eureka不支持</li>
<li>Nacos同时支持AP和CP模式，而Eureka只满足AP模式</li>
</ul>
<div class="note info"><p>CAP原则又称为CAP定理，指的是在一个分布式系统中，Consistency（一致性），Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p></div>
<h3 id="熔断和限流有什么区别"><a class="markdownIt-Anchor" href="#熔断和限流有什么区别"></a> 熔断和限流有什么区别？</h3>
<p><a href="https://zhuanlan.zhihu.com/p/61363959">https://zhuanlan.zhihu.com/p/61363959</a></p>
<h2 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h2>
<h3 id="mq有什么用有哪些具体的使用场景"><a class="markdownIt-Anchor" href="#mq有什么用有哪些具体的使用场景"></a> ＭＱ有什么用？有哪些具体的使用场景？</h3>
<p>队列是一种FIFO先进先出的数据结构，而MQ（Message Queue）即消息队列消息，主要作用就是由生产者发送到ＭＱ进行排队，然后由消费者对消息进行处理，具体使用场景如下：</p>
<ul>
<li>异步：作用能提高系统的响应速度和吞吐量。</li>
<li>解耦：服务之间解耦，可以减少服务之间的影响，提高系统的稳定性和可扩展性，另外，解耦之后可以实现数据分发，生产者发送一个消息后，可以由多个消费者来处理。</li>
<li>削峰：以稳定的系统资源应对突发的流量冲击。</li>
</ul>
<p>不过，ＭＱ也有一些缺点：</p>
<ul>
<li>系统的可用性降低：一旦ＭＱ宕机，整个服务就会产生影响。</li>
<li>系统的复杂度提高：引入ＭＱ之后，数据链路就会变得很复杂，并伴随着很多的问题，例如如何保证消息不丢失？消息不会重复调用？怎么保证消息的顺序性？等等</li>
<li>数据一致性：Ａ系统发消息，需要B、Ｃ两个系统一同处理。如果Ｂ系统处理成功，Ｃ系统处理失败，这就会造成数据一致性的问题。</li>
</ul>
<h3 id="如何进行产品选型"><a class="markdownIt-Anchor" href="#如何进行产品选型"></a> 如何进行产品选型？</h3>
<table>
<thead>
<tr>
<th></th>
<th>Kafka</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>吞吐量非常大，性能非常好，集群高可用</td>
<td>消息可靠性高，功能全面</td>
<td>高吞吐，高性能，高可用，功能非常全面</td>
</tr>
<tr>
<td>缺点</td>
<td>会丢数据，功能比较单一</td>
<td>吞吐量比较低，消息积累会严重影响性能</td>
<td>开源版功能不如云上商业版。官方文档和周边生态还不够成熟。客户端只支持Java</td>
</tr>
<tr>
<td>适用场景</td>
<td>日志分析、大数据采集</td>
<td>小规模场景</td>
<td>几乎是全场景</td>
</tr>
</tbody>
</table>
<h3 id="如何保证消息不丢失"><a class="markdownIt-Anchor" href="#如何保证消息不丢失"></a> 如何保证消息不丢失？</h3>
<p>这个问题主要分为两个方面，第一，哪些环节会造成消息丢失？第二，在这些可能会造成消息丢失的场景下，如何保证不丢失。</p>
<p>总的来说，消息传递过程中如果存在跨网络的请求，或者由IO操作，就有可能会造成消息丢失，具体如下图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630002742.png" alt="img" style="zoom:67%;" /> 
<p>那么如何保证消息不丢失呢？需要按照上面不同场景来单独处理</p>
<ol>
<li>生产者发送消息不丢失</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">产品类型</th>
<th>保证生产者发送消息不丢失策略</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">kafka</td>
<td>消息发送+回调</td>
</tr>
<tr>
<td style="text-align:center">RocketMQ</td>
<td>事务消息</td>
</tr>
<tr>
<td style="text-align:center">RabbitMQ</td>
<td>消息发送+回调</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>手动事务：Channel：txSelect()开启事务，Channel.txCommit()提交事务，Channel.txRollback()回滚事务，这种方式对channel是会产生阻塞的，造成吞吐量下降</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td>publisher confirms。整个处理流程跟RocketMQ的事务消息，基本是一样的。</td>
</tr>
</tbody>
</table>
<p>具体见下图：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630002758.png" alt="img" /></p>
<ol start="2">
<li>MQ主从消息同步不丢失</li>
</ol>
<table>
<thead>
<tr>
<th>产品类型</th>
<th>主从消息不丢失策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>RoctMQ</td>
<td>在普通集群中，同步同步、异步同步。异步同步效率更高，但是有丢消息的风险，同步同步就不会丢消息</td>
</tr>
<tr>
<td>Rabbit MQ</td>
<td>普通集群：消息是分散存储的，节点之间不会主动进行消息同步，是有可能丢失消息的</td>
</tr>
<tr>
<td></td>
<td>镜像集群：镜像集群会在节点之间主动进行数据同步，这样数据安全性得到提高。</td>
</tr>
<tr>
<td>Kafka</td>
<td>通常都是用在允许消息少量丢失的场景，可以通过参数配置：acks：0，1，all</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>MQ消息存盘不丢失</li>
</ol>
<ul>
<li>
<p>RocketMQ：同步刷盘、异步刷盘：异步刷盘效率更高，但是有可能丢消息，同步刷盘消息安全性更高，但是效率会降低。</p>
</li>
<li>
<p>RabbitMQ：将队列配置成持久化队列</p>
</li>
</ul>
<ol start="4">
<li>消费者消费消息不丢失</li>
</ol>
<ul>
<li>
<p>RocketMQ:使用默认的方式消费就行，不要采用异步方式</p>
</li>
<li>
<p>RabbitMQ：autoCommit</p>
</li>
<li>
<p>Kafka：手动提交offset</p>
</li>
</ul>
<h3 id="如何保证消费幂等性"><a class="markdownIt-Anchor" href="#如何保证消费幂等性"></a> 如何保证消费幂等性?</h3>
<p>其实就是要防止消费者重复消费的问题。</p>
<p>所有MQ产品都没有提供主动解决幂等性的机制，需要由消费者自行控制。</p>
<p>RocketMQ：给每个消息分配了MessagesID，这个MessagesID可以作为消费者判断幂等的依据，这种方式不太建议。</p>
<p>最好的方式就是自己带一个有业务标识的id，来进行幂等判断，例如在订单中OrderID</p>
<p>还可以统一ID分配。</p>
<h3 id="mq如何保证消息顺序"><a class="markdownIt-Anchor" href="#mq如何保证消息顺序"></a> MQ如何保证消息顺序?</h3>
<p>全局有序和局部有序，MQ只需要保证局部有序，不需要保证全局有序。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630003411.png" alt="img" /></p>
<p>Java当中对零拷贝进行了封装，Mmap方式通过MappedByteBuffer对象进行操作，而transfer通过FileChannel来进行操作。</p>
<p>Mmap适合比较小的文件，通常文件大小不要超过1.5G-2G，transfile没有文件大小限制。</p>
<p>RocketMQ当中使用Mmap方式对它的文件进行读写。</p>
<p>在Kafka当中，它的index日志文件也是通过Mmap的方式来读写的。在其他的日志文件当中，并没有使用零拷贝的方式，Kafka使用transfile方式将硬盘数据加载到网卡。</p>
<h3 id="如何保证消息的高效读写"><a class="markdownIt-Anchor" href="#如何保证消息的高效读写"></a> 如何保证消息的高效读写?</h3>
<p>零拷贝：Kafka和RocketMQ都是通过零拷贝技术来优化文件读写。</p>
<p>传统文件复制方式：需要对文件在内存中进行四次拷贝。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630003425.png" alt="img" style="zoom: 50%;" />
<p>零拷贝：有两种方式：mmap和   transfile</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210630003438.png" alt="img" style="zoom:50%;" />
<p>Java当中对零拷贝进行了封装，Mmap方式通过MappedByteBuffer对象进行操作，而transfer通过FileChannel来进行操作。</p>
<p>Mmap适合比较小的文件，通常文件大小不要超过1.5G-2G，transfile没有文件大小限制。</p>
<p>RocketMQ当中使用Mmap方式对它的文件进行读写。</p>
<p>在Kafka当中，它的index日志文件也是通过Mmap的方式来读写的。在其他的日志文件当中，并没有使用零拷贝的方式，Kafka使用transfile方式将硬盘数据加载到网卡。</p>
<h3 id="使用mq如何保证分布式事务的最终一致性"><a class="markdownIt-Anchor" href="#使用mq如何保证分布式事务的最终一致性"></a> 使用MQ如何保证分布式事务的最终一致性？</h3>
<p>分布式事务指的是业务相关的多个操作，保证他们同时成功或者同时失败。最终一致性指的是保证事务在最后阶段，能够达到一致性即可，与之对应的就是强一致性。</p>
<p>MQ中要保护事务的最终一致性，就需要做到两点：</p>
<ol>
<li>生产者要保证100%的消息投递（使用事务消息机制）</li>
<li>消费者这一段需要保证幂等消费（唯一ID + 业务自己实现幂等）</li>
</ol>
<p>分布式MQ的三种语义：at least once、at most once、exactly once</p>
<p>Rocket MQ并不能保证exactly once，商业版本中提供了exactly once的实现机制。</p>
<p>Kafka：在最新版本的饿源码当中，提供了exactly once的demo。</p>
<p>RabbitMQ：使用erlang语言天生就成为了一种屏障</p>
<h3 id="如何设计一个mq"><a class="markdownIt-Anchor" href="#如何设计一个mq"></a> 如何设计一个MQ？</h3>
<p>两个误区：1、放飞自我，漫无边际 2、纠结技术细节。</p>
<p>好的方式：1、从整理到细节，从业务场景到技术实现。2、以现产品为基础。</p>
<p>具体的设计思路：</p>
<ul>
<li>实现单机的队列的数据结构。高效，可扩展</li>
<li>将单机队列扩展成为分布式队列。分布式集群管理</li>
<li>基于Topic定制消息路由策略</li>
<li>实现高效的网络通信 netty - http</li>
<li>规划日志文件，实现文件告诉读写，零拷贝，顺序写，服务重启后，快速还原运行现场</li>
<li>定制高级功能，死信队列、延迟队列、事务消息等等，注意贴合实际。</li>
</ul>
<h3 id="kafka如何避免重复消费"><a class="markdownIt-Anchor" href="#kafka如何避免重复消费"></a> Kafka如何避免重复消费？</h3>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发编程</title>
    <url>/2020/10/05/Concurrency/</url>
    <content><![CDATA[<p>并发编程相比于Java中其他知识点的学习门槛要高很多，从而导致很多人望而却步，但无论是职场面试，还是高并发/高流量系统的实现，却都离不开并发编程。</p>
<span id="more"></span>
<p>全文大致共分为三个部分，第一部分为Java并发编程基础篇，主要讲解Java并发编程的基础知识、线程有关的知识和并发编程中的其他概念，这些知识在后续的章节中都会用到。第二部分为Java并发编程的高级篇，讲解Java并发包中的核心组件的实现原理。第三部分为Java并发编程实践篇，主要讲解并发组件的使用方法，以及一些注意事项。</p>
<p>本文主要结合张龙老师的视频：<a href="https://www.bilibili.com/video/BV1qK4y1t78Z?from=search&amp;seid=2031440298446612503">精通Java并发</a>，以及《Java并发编程之美》，系统而全面的介绍Java并发的方方面面。</p>
<h1 id="java并发编程基础"><a class="markdownIt-Anchor" href="#java并发编程基础"></a> Java并发编程基础</h1>
<h2 id="核心概念"><a class="markdownIt-Anchor" href="#核心概念"></a> 核心概念</h2>
<h3 id="线程简介"><a class="markdownIt-Anchor" href="#线程简介"></a> 线程简介</h3>
<p>进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。线程是进程中的一个实体，线程不会独立存在。</p>
<h3 id="并发和并行"><a class="markdownIt-Anchor" href="#并发和并行"></a> 并发和并行</h3>
<ul>
<li>并发是指同一时间段内多个任务同时都在执行，并且都没有执行结果</li>
<li>并行是指在单位时间内多个任务同时在执行</li>
</ul>
<blockquote>
<p>一个时间段由多个单位时间累计而成。</p>
</blockquote>
<h3 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h3>
<p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的方法都可以获得正确的结果，那这个对象是线程安全的。</p>
<blockquote>
<p>这意味着如若要实现线程安全，代码本身必须要封装所有必要的正确性保障手段（比如锁的实现），以确保程序无论在多线程环境下如何调用该方法，将始终保持返回正确的结果。</p>
</blockquote>
<h3 id="同步和异步"><a class="markdownIt-Anchor" href="#同步和异步"></a> 同步和异步</h3>
<ul>
<li>同步：就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回，也就是必须一件一件事做，等前一件事情做完了才能做下一件事</li>
<li>异步：当一个异步过程调用发出后，调用者不能立刻得到结果，实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者</li>
</ul>
<blockquote>
<p>同步是指请求方和响应方的状态是同步的，异步是请求方与响应方状态是异步的。同步和异步是线程对于第三方的状态，而不是对于自己的状态。</p>
</blockquote>
<h3 id="阻塞和非阻塞"><a class="markdownIt-Anchor" href="#阻塞和非阻塞"></a> 阻塞和非阻塞</h3>
<ul>
<li>阻塞：指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回</li>
<li>非阻塞：指在不能立刻得到结果之前，该调用不会阻塞当前线程</li>
</ul>
<blockquote>
<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</p>
</blockquote>
<h2 id="线程创建与运行"><a class="markdownIt-Anchor" href="#线程创建与运行"></a> 线程创建与运行</h2>
<h3 id="thread和runnable"><a class="markdownIt-Anchor" href="#thread和runnable"></a> Thread和Runnable</h3>
<p>如果不考虑线程池的情况，Java中有三种线程创建方法，分别为：</p>
<ul>
<li>实现Runnable接口的run方法</li>
<li>继承Thread类并重写run方法</li>
<li>使用FutureTask方式（Callable + Future）</li>
</ul>
<p>在实际项目中，通常使用的都是线程池而不是手动创建线程，不过Thread类和Runnable接口可以作为了解Java并发编程的入口，Thread类本身是实现了Runnable接口的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们来阅读以下Thread类的文档说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have </span><br><span class="line">multiple threads of execution running concurrently.</span><br></pre></td></tr></table></figure>
<p>一个thread指的是程序执行中的一个线程，Java虚拟机支持一个应用可以有多个并发执行的线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Every thread has a priority. Threads with higher priority are executed in preference to threads with </span><br><span class="line">lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread </span><br><span class="line">creates a new Thread object, the new thread has its priority initially set equal to the priority of the </span><br><span class="line">creating thread, and is a daemon thread if and only if the creating thread is a daemon.</span><br></pre></td></tr></table></figure>
<p>每一个线程都会有一个优先级，拥有高优先级的线程在执行的时候就会比低优先级的线程优先级要高，每一个线程也可以被标记为daemon（后台线程），当运行在某一个线程中的代码创建了一个新的线程，默认情况下，新的线程的优先级会和创建它的线程优先级相同，并且只有创建它的线程是daemon线程时，新的线程才会是daemon。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls </span><br><span class="line">the method named main of some designated class). The Java Virtual Machine continues to execute threads </span><br><span class="line">until either of the following occurs:</span><br></pre></td></tr></table></figure>
<p>当Java虚拟机启动的时候，通常会有一个单个的、非daemon线程（通常情况会调用某一个被指定类的main方法），Java虚拟机会继续执行线程，直到下面的两种情况发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The exit method of class Runtime has been called and the security manager has permitted the exit </span><br><span class="line">operation to take place.</span><br><span class="line">All threads that are not daemon threads have died, either by returning from the call to the run method or </span><br><span class="line">by throwing an exception that propagates beyond the run method.</span><br></pre></td></tr></table></figure>
<ul>
<li>类的Runtime方法被调用，并且安全管理器允许退出操作发生。</li>
<li>所有的非后台线程都已经消亡了，要么是通过run方法的调用返回了，要么是run方法外面抛出了异常。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are two ways to create a new thread of execution. One is to declare a class to be a subclass of </span><br><span class="line">Thread. This subclass should override the run method of class Thread. An instance of the subclass can </span><br><span class="line">then be allocated and started. For example, a thread that computes primes larger than a stated value </span><br><span class="line">could be written as follows:</span><br></pre></td></tr></table></figure>
<p>有两种方式来创建一个新的执行线程，一种是继承Thread类，这个子类应该重写Thread类的run方法，这个子类就可以创建实例并且执行，比如，一个线程计算大于某一个状态值的，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">           <span class="keyword">long</span> minPrime;</span><br><span class="line">           PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">               <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">                . . .</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>如下代码将会生成线程并且使用start方法开始执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure>
<p>接下来是另外一种创建线程的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The other way to create a thread is to declare a class that implements the Runnable interface. That class </span><br><span class="line">then implements the run method. An instance of the class can then be allocated, passed as an argument </span><br><span class="line">when creating Thread, and started. The same example in this other style looks like the following:</span><br></pre></td></tr></table></figure>
<p>另一种创建线程的方式就是声明一个类并且实现Runnable接口，在这个类实现了run方法之后，就可以创建实例。当创建Thread的时候把这个类作为一个参数传入并启动，相同的例子用这个方式来实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">          <span class="keyword">long</span> minPrime;</span><br><span class="line">          PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">              <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">               . . .</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>如下代码就会创建一个线程并执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Every thread has a name for identification purposes. More than one thread may have the same name. If a </span><br><span class="line">name is not specified when a thread is created, a new name is generated for it.</span><br><span class="line">Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a </span><br><span class="line">NullPointerException to be thrown.</span><br></pre></td></tr></table></figure>
<p>每个线程都有一个名称用于标识，不同的线程可能会有相同的名称，如果创建线程的时候没有指定名称，就会产生一个新的名称，如无特别说明，将null参数传递给构造方法或者这个类的其他方法就会导致空指针异常。</p>
<p>这里用到了start方法来启动线程，我们来阅读以下start方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Causes this thread to begin execution; the Java Virtual Machine calls the run method of this thread.</span><br><span class="line">The result is that two threads are running concurrently: the current thread (which returns from the call </span><br><span class="line">to the start method) and the other thread (which executes its run method).</span><br><span class="line">It is never legal to start a thread more than once. In particular, a thread may not be restarted once it</span><br><span class="line">has completed execution.</span><br></pre></td></tr></table></figure>
<p>当调用了start方法意味这个这个线程开始执行了，Java虚拟机会调用这个线程的run方法，结果是当前线程（调用start方法所返回的线程）和另外一个线程（执行run方法的线程）会并发的运行，多次启动一个线程是不合法的，特别的，一个线程已经执行完成之后不可以被重新启动。</p>
<p>Runnable接口本身是一个函数式接口，里面有且仅有一个抽象方法run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们阅读以下Runnable接口的文档说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The Runnable interface should be implemented by any class whose instances are intended to be executed by </span><br><span class="line">a thread. The class must define a method of no arguments called run.</span><br><span class="line">This interface is designed to provide a common protocol for objects that wish to execute code while they </span><br><span class="line">are active. For example, Runnable is implemented by class Thread. Being active simply means that a thread </span><br><span class="line">has been started and has not yet been stopped.</span><br></pre></td></tr></table></figure>
<p>任何一个执行线程的类都应该实现Runnable接口，这个类必须定义一个无参的run方法。设计这个接口是为了，给执行处在激活状态的代码的时候，提供一种公共的协议，比如说，Runnable是被Thread类所实现出来了。处于激活状态表示一个线程被启动了，而且没有停止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In addition, Runnable provides the means for a class to be active while not subclassing Thread. A class </span><br><span class="line">that implements Runnable can run without subclassing Thread by instantiating a Thread instance and </span><br><span class="line">passing itself in as the target. In most cases, the Runnable interface should be used if you are only </span><br><span class="line">planning to override the run() method and no other Thread methods. This is important because classes </span><br><span class="line">should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior</span><br><span class="line">of the class.</span><br></pre></td></tr></table></figure>
<p>此外，Runnable提供了让一个类处在激活状态同时又没有子类化的方式，一个类实现了Runnable可以不用通过子类化来运行，这是通过初始化一个Thread实例，然后将它自己作为目标传入，如果你只是计划重写run方法，而不打算重写Thread类其他的方法，一般情况下，都应该使用Runnable，这是非常重要的，除非程序员打算增强或修改一些基础的行为，因为类不应该被子类化。</p>
<p>接下来我们阅读以下run方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">When an object implementing interface Runnable is used to create a thread, starting the thread causes the </span><br><span class="line">object&#x27;s run method to be called in that separately executing thread.</span><br><span class="line">The general contract of the method run is that it may take any action whatsoever.</span><br></pre></td></tr></table></figure>
<p>当使用实现了Runnable接口的对象创建了一个线程，启动这个线程，就会在单独执行的线程上执行这个类的run方法，run方法一种通用的锲约是它可以接口任何的动作。</p>
<p>同样的在Thread类中也有一个run方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If this thread was constructed using a separate Runnable run object, then that Runnable object&#x27;s run </span><br><span class="line">method is called; otherwise, this method does nothing and returns.</span><br><span class="line">Subclasses of Thread should override this method.</span><br></pre></td></tr></table></figure>
<p>如果这个线程是通过单独的Runnable接口对象来构建的话，那么Runnable对象的run方法就会被调用，否则，这个方法什么都不做，直接返回。Thread的子类应该重写这个方法。</p>
<p>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// private Runnable target;</span></span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thread类的run方法会判断本地的Runnable对象是否已经被赋值，如果已经赋值了就执行里面的run方法。</p>
<p>Thread类的构造方法都会调用init方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们先了解以下这个init方法，方法的参数说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程组</span></span><br><span class="line">g – the Thread group</span><br><span class="line"><span class="comment">// 这个对象的run将会被调用</span></span><br><span class="line">target – the object whose run将会被调用() method gets called</span><br><span class="line"><span class="comment">// 新创建的线程的名称</span></span><br><span class="line">name – the name of the <span class="keyword">new</span> Thread</span><br><span class="line"><span class="comment">// 新的线程所需要的栈的大小，0表示这个参数会忽略掉</span></span><br><span class="line">stackSize – the desired stack size <span class="keyword">for</span> the <span class="keyword">new</span> thread, or zero to indicate that <span class="keyword">this</span> parameter is to be ignored.</span><br></pre></td></tr></table></figure>
<h3 id="futuretask"><a class="markdownIt-Anchor" href="#futuretask"></a> FutureTask</h3>
<p>Future就是对于具体的Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。FutureTask类是RunnableFuture的具体实现类。</p>
<p>使用FutureTask创建线程的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskCreateThreadDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> FutureTaskCreateThreadDemo());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String result = futureTask.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建线程总结"><a class="markdownIt-Anchor" href="#创建线程总结"></a> 创建线程总结</h3>
<p>不同方式创建线程的对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>创建方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Thread</td>
<td>继承Thread类并重写run方法，调用start方法</td>
<td>可以直接使用this获取当前线程对象</td>
<td>如果继承了Thread则无法继承其他类</td>
</tr>
<tr>
<td>Runnable</td>
<td>实现Runnable接口，重写run方法</td>
<td>可以多继承</td>
<td>需要使用Thread#currentThread获取当前线程对象</td>
</tr>
<tr>
<td>FutureTask</td>
<td>实现Callable接口，重写call方法</td>
<td>可以获取执行结果</td>
<td>使用相对复杂</td>
</tr>
</tbody>
</table>
<h2 id="线程的通知与等待"><a class="markdownIt-Anchor" href="#线程的通知与等待"></a> 线程的通知与等待</h2>
<h3 id="wait-sleep和notify"><a class="markdownIt-Anchor" href="#wait-sleep和notify"></a> wait、sleep和notify</h3>
<h4 id="方法简介"><a class="markdownIt-Anchor" href="#方法简介"></a> 方法简介</h4>
<p>在Object类中有几个与线程相关的方法：notify、notifyAll、wait，这几个方法非常的重要，接下来我们分析一下这个几个方法，首先从wait方法开始，wait方法又有几个重载的方法，首先来看不带参数的wait方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() </span><br><span class="line">method for this object. In other words, this method behaves exactly as if it simply performs the call </span><br><span class="line">wait(0).</span><br></pre></td></tr></table></figure>
<p>wait方法会导致当前的线程进入等待状态，直到另外一个线程调用了这个对象的notify或者notifyAll方法，换言之，这个方法的行为是与wait(0)是等价的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The current thread must own this object&#x27;s monitor. The thread releases ownership of this monitor and </span><br><span class="line">waits until another thread notifies threads waiting on this object&#x27;s monitor to wake up either through a </span><br><span class="line">call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership</span><br><span class="line">of the monitor and resumes execution.</span><br><span class="line">As in the one argument version, interrupts and spurious wakeups are possible, and this method should </span><br><span class="line">always be used in a loop:</span><br></pre></td></tr></table></figure>
<p>要调用当前对象wait方法，当前线程必须要拥有这个对象的锁，这个线程在调用了wait方法之后，就会释放掉锁的控制权，并且进行等待，直到另外的线程通知在这个锁上等待的所有线程。唤醒的方式要么是通过notify方法或者是notifyAll方法。接下来，这个线程还是会继续等待，直到它可以重新获取锁的有用权，并且恢复执行。对于一个参数的版本来说，终端和一些虚假的唤醒是可能发生的，这个方法应该只在循环当中使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">               <span class="keyword">while</span> (&lt;condition does not hold&gt;)</span><br><span class="line">                   obj.wait();</span><br><span class="line">               ... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This method should only be called by a thread that is the owner of this object&#x27;s monitor. See the notify </span><br><span class="line">method for a description of the ways in which a thread can become the owner of a monitor.</span><br></pre></td></tr></table></figure>
<p>这个方法应该只是被拥有了这个对象的锁的线程去调用，参考notify方法来查看什么情况下，一个线程可以成为锁的拥有者。</p>
<p>如果没有锁直接调用wait方法会怎么样呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序就会直接抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalMonitorStateException</span><br></pre></td></tr></table></figure>
<p>按照给出的示例，我们将程序改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            object.wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序并没有抛出异常，而是进入进入了一直等待的状态。在Thread类中有一个sleep方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of</span><br><span class="line">milliseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not </span><br><span class="line">lose ownership of any monitors.</span><br></pre></td></tr></table></figure>
<p>它会导致当前正在执行的线程进入到休眠的状态（临时的终止执行）一段指定的毫秒数，它会收到系统定时器和调度器的精度的限制，线程并不会失去任何锁的所有权。</p>
<p>这里其实就是wait方法和sleep方法的最明显的区别，调用wait方法之前，线程必须持有对象的锁，在调用wait方法之后，线程就会释放锁，而sleep方法则不会释放掉锁。</p>
<p>前面我们提到过，不带参数的wait方法会调用他的重载方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait方法本身又有两个重载的方法，我们首先来阅读一下只有一个参数的相关文档：</p>
<p>首先是方法的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Causes the current thread to wait until either another thread invokes the notify() method or the </span><br><span class="line">notifyAll() method for this object, or a specified amount of time has elapsed.</span><br><span class="line">The current thread must own this object&#x27;s monitor.</span><br></pre></td></tr></table></figure>
<p>这个方法会让当前的线程进入等待状态，除非对当前这个对象使用notify或者notifyAll方法，或者已经到了指定的超时时间，当前对象必须要拥有当前对象的锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This method causes the current thread (call it T) to place itself in the wait set for this object and </span><br><span class="line">then to relinquish any and all synchronization claims on this object. Thread T becomes disabled for </span><br><span class="line">thread scheduling purposes and lies dormant until one of four things happens:</span><br></pre></td></tr></table></figure>
<p>这个方法会导致当前的线程（T），将它自身放置到一个这个对象的等待集合当中，然后放弃任何同步的声明，线程T将无法再进行调度，处在休眠状态，直到下面的四种情况发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Some other thread invokes the notify method for this object and thread T happens to be arbitrarily chosen</span><br><span class="line">as the thread to be awakened.</span><br><span class="line">Some other thread invokes the notifyAll method for this object.</span><br><span class="line">Some other thread interrupts thread T.</span><br><span class="line">The specified amount of real time has elapsed, more or less. If timeout is zero, however, then real time</span><br><span class="line">is not taken into consideration and the thread simply waits until notified.</span><br></pre></td></tr></table></figure>
<ul>
<li>另外一个线程调用了这个对象的notify方法，当前的线程T碰巧是要被选择唤醒的线程；</li>
<li>其他的线程调用了这个对象的notifyAll方法；</li>
<li>其他的线程中断了T线程</li>
<li>指定的时间已经过去了，不过如果时间设置为0的话，线程会一直进入等待直到被通知，而不会再去计算时间。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The thread T is then removed from the wait set for this object and re-enabled for thread scheduling. It </span><br><span class="line">then competes in the usual manner with other threads for the right to synchronize on the object; once it </span><br><span class="line">has gained control of the object, all its synchronization claims on the object are restored to the status </span><br><span class="line">quo ante - that is, to the situation as of the time that the wait method was invoked. Thread T then </span><br><span class="line">returns from the invocation of the wait method. Thus, on return from the wait method, the synchronization </span><br><span class="line">state of the object and of thread T is exactly as it was when the wait method was invoked.</span><br></pre></td></tr></table></figure>
<p>接下来线程T会从对象等待集合中移除掉，然后，重新又可以进行线程的调度了。它会按照通常的方式与其他的线程竞争对于对象的同步权，一旦获得了对象的同步权，所有它的对这个对象同步的声明又会恢复到之前的同步声明状态，也就是说恢复到wait方法被调用的时候所处的状态，接下来线程T就会从wait方法的调用当中去返回，返回的时候，对象的同步状态以及线程T的同步状态与wait方法被调用的时候的状态是一模一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious </span><br><span class="line">wakeup. While this will rarely occur in practice, applications must guard against it by testing for the </span><br><span class="line">condition that should have caused the thread to be awakened, and continuing to wait if the condition is </span><br><span class="line">not satisfied. In other words, waits should always occur in loops, like this one:</span><br></pre></td></tr></table></figure>
<p>一个线程还可以被唤醒无需被通知、中断或者超时，这个称之为虚假的唤醒，虽然这种实际情况下很少发生，但是应用还是应该通过测试条件保证这一点，并且如果条件没有被满足的时候就持续处于等待状态，换句话说，等待总是应该发生在循环当中，就向下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">              <span class="keyword">while</span> (&lt;condition does not hold&gt;)</span><br><span class="line">                  obj.wait(timeout);</span><br><span class="line">              ... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If the current thread is interrupted by any thread before or while it is waiting, then an </span><br><span class="line">InterruptedException is thrown. This exception is not thrown until the lock status of this object has </span><br><span class="line">been restored as described above.</span><br></pre></td></tr></table></figure>
<p>如果当前的线程被别的线程在它等待之前或等待当中的时候被中断了，这个锁状态恢复之后才会被正常的抛出InterruptedException异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Note that the wait method, as it places the current thread into the wait set for this object, unlocks </span><br><span class="line">only this object; any other objects on which the current thread may be synchronized remain locked while </span><br><span class="line">the thread waits.</span><br></pre></td></tr></table></figure>
<p>wait方法会将当前的线程放置到它的等待的对象集合当中，只会解锁当前的对象，当这个线程等待的时候，任何其它的对象对象可能会依然处于锁定的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This method should only be called by a thread that is the owner of this object&#x27;s monitor. See the notify </span><br><span class="line">method for a description of the ways in which a thread can become the owner of a monitor.</span><br></pre></td></tr></table></figure>
<p>这个方法应该只被持有对象锁的线程所调用，请查看notify方法来查看如何让一个线程成为锁的拥有者。</p>
<p>接下来我们查看wait方法另外一个重载的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 底层实现还是调用wait(long timeout)方法</span></span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait方法和notify方法总是成对出现的，notify方法也是一个native方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们来了解一下notify方法的作用：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">Wakes up a single thread that is waiting on this object&#x27;s monitor. If any threads are waiting on this </span><br><span class="line">object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the</span><br><span class="line">implementation. A thread waits on an object&#x27;s monitor by calling one of the wait methods.</span><br></pre></td></tr></table></figure>
<p>它会唤醒正在等待这个对象的锁的单个线程，如果有多个线程都在等待这个对象的锁，那么就会选择其中的一个进行唤醒，选择是随机的，并且是根据实现来决定的，一个线程会通过调用某一个wait方法进入等待状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The awakened thread will not be able to proceed until the current thread relinquishes the lock on this</span><br><span class="line">object. The awakened thread will compete in the usual manner with any other threads that might be </span><br><span class="line">actively competing to synchronize on this object; for example, the awakened thread enjoys no reliable</span><br><span class="line">privilege or disadvantage in being the next thread to lock this object.</span><br><span class="line">This method should only be called by a thread that is the owner of this object&#x27;s monitor. A thread  </span><br><span class="line">becomes the owner of the object&#x27;s monitor in one of three ways:    </span><br></pre></td></tr></table></figure>
<p>被唤醒的线程是无法执行的，直到当前的线程放弃了这个对象的锁，被唤醒的线程会按照常规的方式与其他的线程进行对象同步的竞争，比如说，被唤醒的线程它是没有任何的特权，也没有任何不足的地方，都有可能会获得当前对象的锁。notify方法只能被这个对象的持有者来进行调用，一个线程获取对象锁有以下三种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">By executing a synchronized instance method of that object.</span><br><span class="line">By executing the body of a synchronized statement that synchronizes on the object.</span><br><span class="line">For objects of type Class, by executing a synchronized static method of that class.</span><br></pre></td></tr></table></figure>
<ul>
<li>通过执行对象的synchronized实例方法来获取</li>
<li>通过执行这个对象的synchronized语句块来获取</li>
<li>对于Class类型的对象，通过执行这个class中synchronized静态方法来获取</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Only one thread at a time can own an object&#x27;s monitor.  </span><br></pre></td></tr></table></figure>
<p>在某一个时刻只有一个线程拥有一个对象的锁。</p>
<p>同样的，notifyAll方法也是一个本地方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wakes up all threads that are waiting on this object&#x27;s monitor. A thread waits on an object&#x27;s monitor by</span><br><span class="line">calling one of the wait methods.</span><br></pre></td></tr></table></figure>
<p>notifyAll方法会唤醒在这个对象的锁上等待的所有的线程，线程可以通过调用这个对象的wait方法等待这个对象的锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The awakened threads will not be able to proceed until the current thread relinquishes the lock on this </span><br><span class="line">object. The awakened threads will compete in the usual manner with any other threads that might be </span><br><span class="line">actively competing to synchronize on this object; for example, the awakened threads enjoy no reliable </span><br><span class="line">privilege or disadvantage in being the next thread to lock this object.</span><br></pre></td></tr></table></figure>
<p>被唤醒的线程只有在当前对象释放掉锁的时候才能继续执行，它会按照通常的方式与其他的线程竞争对象的同步，既没有什么特权，也没有什么缺陷，都有可能是下一个给当前对象上锁的线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This method should only be called by a thread that is the owner of this object&#x27;s monitor. See the notify</span><br><span class="line">method for a description of the ways in which a thread can become the owner of a monitor.</span><br></pre></td></tr></table></figure>
<p>这个方法只能被持有锁的对象锁调用，查看notify方法获取对象锁的方式。</p>
<p>我们可以用一张表格来总结以下wait、notify、notifyAll方法的区别：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:left">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">wait</td>
<td style="text-align:left">1、当调用wait方法时，首先需要确保wait方法的线程已经持有了对象的锁<br>2、当调用wait后，该线程会释放掉这个对象的锁，然后进入到等待状态（wait set）<br>3、当线程调用了wait后进入等待状态时，它就可以等待线程调用相同对象的notify和notifyAll方法来使得自己被唤醒<br>4、一旦这个线程被其他线程唤醒后，该线程就会与其他线程一同开始竞争这个对象的锁（公平竞争）；只有当该线程获取到了这个对象的锁后，线程才会继续往下执行<br>5、调用wait方法的代码片段需要放在synchronize代码块或者synchronized方法中，这样才可以确保线程在调用wait方法前已经获取到了对象的锁</td>
</tr>
<tr>
<td style="text-align:center">notify</td>
<td style="text-align:left">1、当调用对象的notify方法时，它会随机唤醒该对象等待集合（wait set）中的任意一个线程，当某个线程被唤醒后，它就会与其他线程一同竞争对象的锁<br>2、在某一时刻只有唯一一个线程可以拥有对象的锁</td>
</tr>
<tr>
<td style="text-align:center">notifyAll</td>
<td style="text-align:left">1、当调用对象的notifyAll方法时，它会唤醒该对象集合（wait set）中所有的线程，这些线程被唤醒后，又会开始竞争对象的锁</td>
</tr>
</tbody>
</table>
<h4 id="方法实践"><a class="markdownIt-Anchor" href="#方法实践"></a> 方法实践</h4>
<p>我们来看一个需要运用并发编程的实际的需求：</p>
<p>1、存在一个对象，该对象有个int类型的成员变量counter，该成员变量的初始值为0；</p>
<p>2、创建两个线程，其中一个线程对该对象的成员变量counter加1，另一个线程对该对象的成员变量减1；</p>
<p>3、输出该对象成员变量counter每次变化后的值；</p>
<p>4、最终输出的结果应为：1010101010…。</p>
<p>首先是我们需要操作的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要操作的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (counter != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counter++;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (counter == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counter--;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加的线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncreaseThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyObject myObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IncreaseThread</span><span class="params">(MyObject myObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myObject = myObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">             myObject.increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>减少的线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecreaseThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyObject myObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecreaseThread</span><span class="params">(MyObject myObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myObject = myObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            myObject.decrease();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用客户端来进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyObject myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line">        Thread increaseThread = <span class="keyword">new</span> IncreaseThread(myObject);</span><br><span class="line">        Thread decreaseThread = <span class="keyword">new</span> DecreaseThread(myObject);</span><br><span class="line">        <span class="comment">// 这里先启动哪个线程结果都是相同的</span></span><br><span class="line">        increaseThread.start();</span><br><span class="line">        decreaseThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序也正如我们所愿，输出了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Task :client.main()</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>接下来我们尝试创建多个线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyObject myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line">        Thread increaseThread = <span class="keyword">new</span> IncreaseThread(myObject);</span><br><span class="line">        Thread increaseThread2 = <span class="keyword">new</span> IncreaseThread(myObject);</span><br><span class="line">        Thread decreaseThread = <span class="keyword">new</span> DecreaseThread(myObject);</span><br><span class="line">        Thread decreaseThread2 = <span class="keyword">new</span> DecreaseThread(myObject);</span><br><span class="line">        increaseThread.start();</span><br><span class="line">        increaseThread2.start();</span><br><span class="line">        decreaseThread.start();</span><br><span class="line">        decreaseThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Task :client.main()</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">-1</span><br><span class="line">-2</span><br><span class="line">-3</span><br><span class="line">-2</span><br><span class="line">-1</span><br><span class="line">-2</span><br><span class="line">-3</span><br><span class="line">-4</span><br></pre></td></tr></table></figure>
<p>可以看到这个时候，输入的结果其实已经是没有规律的了。这是因为在之前只有两个线程的时候，调用notify方法一定会唤醒唯一的另外一个方法，而在上面的这个例子中，被唤醒的线程实际上是随机的。</p>
<p>为了避免这种情况的发生，我们应该使用while来进行判断，而不是使用if：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (counter != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counter++;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (counter == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counter--;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="join方法"><a class="markdownIt-Anchor" href="#join方法"></a> join方法</h3>
<p>在项目实践中经常会遇到一个场景，就是需要等待某几件事情完成后才能继续往下执行，比如多个线程加载资源，需要等待多个线程全部加载完毕再汇总处理。Thread类中的join方法就可以在这种场景下使用。</p>
<p>join方法使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;child threadOne over!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadTwo = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;child threadTwo over!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动子线程</span></span><br><span class="line">        threadOne.start();</span><br><span class="line">        threadTwo.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;wait all child thread over!&quot;</span>);</span><br><span class="line">        <span class="comment">// 等待子线程执行完毕，返回</span></span><br><span class="line">        threadOne.join();</span><br><span class="line">        threadTwo.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;all child thread over!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子中，在主线程里面启动了两个子线程，然后分别调用了它们的join方法，那么主线程首先会在调用threadOne.join()方法后被阻塞，等待threadOne执行完毕后返回。threadOne执行完毕后threadOne.join()就会返回，然后主线程threadTwo.join()方法后再次被阻塞，等待threadTwo执行完毕后返回。</p>
<blockquote>
<p>使用CountDownLatch也可以实现相同的功能。</p>
</blockquote>
<h3 id="yield方法"><a class="markdownIt-Anchor" href="#yield方法"></a> yield方法</h3>
<p>Thread类中有一个静态的yield方法，当一个线程调用yield方法时，当前线程会让出CPU使用权，然后处于就绪状态，线程调度器会从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到刚刚让出CPU的那个线程来获取CPU执行权。</p>
<p>yield方法的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldMethodDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    YieldMethodDemo() &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 当i=0时让出CPU执行权，放弃时间片，进行下一轮调度</span></span><br><span class="line">            <span class="keyword">if</span> ((i % <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;yield cpu...&quot;</span>);</span><br><span class="line">                <span class="comment">// 当前线程让出CPU执行权，放弃时间片，进行下一轮调度</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;is over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> YieldMethodDemo();</span><br><span class="line">        <span class="keyword">new</span> YieldMethodDemo();</span><br><span class="line">        <span class="keyword">new</span> YieldMethodDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep方法与yield方法的区别在于，当线程调用sleep方法时调用线程会被阻塞挂起指定的时间，在这期间线程调度器不会去调度该线程。而调用yield方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到当前线程执行。</p>
<h2 id="线程中断"><a class="markdownIt-Anchor" href="#线程中断"></a> 线程中断</h2>
<h3 id="核心api"><a class="markdownIt-Anchor" href="#核心api"></a> 核心API</h3>
<p>Java中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。</p>
<ul>
<li><code>void interrupt()</code>方法：中断线程。设置标志并不意味着线程会被中断，它会继续往下执行。</li>
<li><code>boolean isInterrupted()</code>方法：检测当前线程是否被中断，如果是返回true，否则返回false</li>
<li><code>boolean interrupted</code>方法：检测当前线程是否被中断，如果是返回true，否则返回false</li>
</ul>
<p>interrupted方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isInterrupted方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests if some Thread has been interrupted.  The interrupted state</span></span><br><span class="line"><span class="comment">    * is reset or not based on the value of ClearInterrupted that is</span></span><br><span class="line"><span class="comment">    * passed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看出，interrupted与isInterrupted方法不同是，interrupted如果发现当前线程被中断，则会清除中断标志，并且该方法是static方法，可以通过Thread类直接调用。</p>
</blockquote>
<h3 id="使用方法及区别"><a class="markdownIt-Anchor" href="#使用方法及区别"></a> 使用方法及区别</h3>
<p>使用isInterrupted优雅退出的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">        <span class="comment">// do more work;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据中断标志判断线程是否终止的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsInterruptedThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动子线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程休眠1s，以便中断前让子线程输出</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中断子线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main thread interrupt thread&quot;</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待子线程执行完毕</span></span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;main is over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用interrupt方法，强制sleep方法抛出异常而返回，线程恢复到激活状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;threadOne begin sleep for 2000 seconds&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;threadOne awaking&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;threadOne is interrupted while sleeping&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;threadOne-leaving normally&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        threadOne.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保子线程进入休眠状态</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打断子线程的休眠，让子线程从sleep函数返回</span></span><br><span class="line">        threadOne.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待子线程执行完毕</span></span><br><span class="line">        threadOne.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main thread is over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Interrupted与IsInterrupted方法区别的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptedAndIsInterruptedDistinct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        threadOne.start();</span><br><span class="line">        <span class="comment">// 设置中断标志</span></span><br><span class="line">        threadOne.interrupt();</span><br><span class="line">        <span class="comment">// 获取中断标志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;isInterrupted: &quot;</span> + threadOne.isInterrupted()); <span class="comment">// true</span></span><br><span class="line">        <span class="comment">// 获取中断标志并重置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;isInterrupted: &quot;</span> + threadOne.interrupted()); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 获取中断标志并重置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;isInterrupted: &quot;</span> + Thread.interrupted()); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 获取中断标志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;isInterrupted: &quot;</span> + threadOne.isInterrupted()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        threadOne.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main thread is over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意的是，虽然调用的threadOne的interrupted方法，但是获取的是主线程的中断标志，因为主线程是当前线程，也就是说threadOne.interrupted和Thread.interrupted()作用是一样的，目的都是获取当前线程的中断标志。</p>
</blockquote>
<p>修改上面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptedAndIsInterruptedDistinct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 中断标志位true时会退出循环，并清除中断标志</span></span><br><span class="line">                <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread one is isInterrupted: &quot;</span> + Thread.currentThread().isInterrupted()); <span class="comment">// false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        threadOne.start();</span><br><span class="line">        <span class="comment">// 设置中断标志</span></span><br><span class="line">        threadOne.interrupt();</span><br><span class="line"></span><br><span class="line">        threadOne.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main thread is over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子说明调用interrupted方法会清除中断标志。</p>
<h2 id="threadlocal"><a class="markdownIt-Anchor" href="#threadlocal"></a> ThreadLocal</h2>
<h3 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h3>
<p>多线程访问同一个共享变量的时候特别容易出现并发问题，特别是多个线程需要对一个共享变量进行写入时。为了保证线程安全，一般使用者在访问共享变量时需要进行适当的同步，如下入所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210811150448.png" alt="image-20210811150420172" style="zoom: 67%;" />
<p>除了同步这种方式之外，还可以使用ThreadLocal来完成，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。创建一个ThreadLocal变量后，每个线程都会复制一个变量到自己的本地内存，如图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210811150805.png" alt="image-20210811150805565" style="zoom:67%;" />
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.print函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打印当前线程本地内存地中localVariable变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">&quot;:&quot;</span> + localVariable.get());</span><br><span class="line">        <span class="comment">// 清除当前线程本地内存中的localVariable变量</span></span><br><span class="line">        localVariable.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建ThreadLocal变量</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建线程one</span></span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 设置线程One中本地变量localVariable的值</span></span><br><span class="line">                localVariable.set(<span class="string">&quot;threadOne local variable&quot;</span>);</span><br><span class="line">                <span class="comment">// 调用打印函数</span></span><br><span class="line">                print(<span class="string">&quot;threadOne&quot;</span>);</span><br><span class="line">                <span class="comment">// 打印本地变量值</span></span><br><span class="line">                System.out.println(<span class="string">&quot;threadOne remove after&quot;</span> + <span class="string">&quot;:&quot;</span> + localVariable.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 4.创建线程two</span></span><br><span class="line">        Thread threadTwo = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 设置线程two中本地变量localVariable的值</span></span><br><span class="line">                localVariable.set(<span class="string">&quot;threadTwo local variable&quot;</span>);</span><br><span class="line">                <span class="comment">// 调用打印函数</span></span><br><span class="line">                print(<span class="string">&quot;threadTwo&quot;</span>);</span><br><span class="line">                <span class="comment">// 打印本地变量值</span></span><br><span class="line">                System.out.println(<span class="string">&quot;threadTwo remove after&quot;</span> + <span class="string">&quot;:&quot;</span> + localVariable.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadOne.start();</span><br><span class="line">        threadTwo.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadLoacal比较典型的使用场景有：</p>
<ul>
<li>实现单个线程单例以及单个线程上下文信息存储，比如交易id等</li>
<li>实现线程安全，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例</li>
<li>承载一些线程相关的数据，避免在方法中来回传递参数</li>
</ul>
<h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3>
<h4 id="整体结构"><a class="markdownIt-Anchor" href="#整体结构"></a> 整体结构</h4>
<p>ThreadLocal的核心API：</p>
<ul>
<li>java.lang.ThreadLocal#set</li>
<li>java.lang.ThreadLocal#get</li>
<li>java.lang.ThreadLocal#remove</li>
</ul>
<p>在Thread对象中维护着一个ThreadLocalMap对象，这个ThreadLocalMap管理着当前线程的多个ThreadLocal对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>ThreadLocalMap的核心属性和方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">        * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">        * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">        * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">        * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">        * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">           <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               <span class="keyword">super</span>(k);</span><br><span class="line">               value = v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">        * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> Entry[] table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在ThreadLocalMap中实际上是通过Entry数组来维护多个ThreadLocal的对象，而Entry对象本上是一个键值对的结构，key就是ThreadLocal对象，而value就是具体要使用ThreadLocal存储的值的对象，它们之间的关系如下图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210813111035.png" alt="image-20210813111035556" style="zoom:50%;" />
<p>通常情况下我们使用完这个对象就等待GC进行清理，但是对于ThreadLocal来说，即使我们使用结果，也会因为线程本身存在该对象引用，处理对象可达状态，垃圾回收器无法回收。这个时候当ThreadLocal太多的时候就会出现内存泄漏的问题。</p>
<p>对于Entry对象中的ThreadLocal而言，我们将ThreadLocal对象的引用作为弱引用，那么就很好的解决了这个问题。value还是强引用，但是我们无法判断除了map的引用还是否存在其他引用，所以只能将其设置为强引用，这个时候假设key已经被GC掉了，但是Entity还没有进行移除，还会引发内存泄漏的问题。</p>
<p>为了彻底解决内存泄漏的问题，ThreadLocalMap提供了expungeStaleEntry方法用来排除无效的Entity（Key为空的实体）。</p>
<blockquote>
<p>Entry的索引i的位置是通过将threadLocalHashCode进行一个位运算（取模）得到的。threadLocalHashCode的值为什么取0x61c88647呢？这点非常有趣，0x61c88647是斐波那契散列乘数,它的优点是通过它散列(hash)出来的结果分布会比较均匀，可以很大程度上避免hash冲突。</p>
</blockquote>
<p>多个线程使用ThreadLocal变量的时候的示意图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210813114932.png" alt="image-20210813114931970" style="zoom: 45%;" />
<p>通过这种方式，就做到了变量的“私有化”，每个线程都拥有了自己独立的一个变量。</p>
<h4 id="set方法"><a class="markdownIt-Anchor" href="#set方法"></a> set方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="get方法"><a class="markdownIt-Anchor" href="#get方法"></a> get方法</h4>
<p>方法的流程图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210813114704.png" alt="image-20210813114448736" style="zoom:65%;" />
<p>方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="remove方法"><a class="markdownIt-Anchor" href="#remove方法"></a> remove方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">     <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">         m.remove(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h3>
<p>不当的使用的ThreadLoacal可能会造成：</p>
<ul>
<li>内存泄漏</li>
<li>线程池中上下文丢失</li>
<li>并行流中线程上下文丢失</li>
</ul>
<p>通过上面的源码分析，不难发现set、get和remove方法都直接或者间接调用了expungeStaleEntry方法来将所有失效的Entity移除。</p>
<p>虽然ThreadMap提供了set、get和remove方法，可以在一些时机下对这些失效Entry项进行清理，但是这是不及时的，也不是每次都会执行，所以在一些情况下还是会发生内存泄漏，因此在使用完毕后一定要调用remove方法才可以彻底解决内存泄漏的问题。</p>
<h2 id="synchronized详解"><a class="markdownIt-Anchor" href="#synchronized详解"></a> synchronized详解</h2>
<h3 id="synchronized简介"><a class="markdownIt-Anchor" href="#synchronized简介"></a> synchronized简介</h3>
<p>进入synchronized块的语义是把在synchronized块内使用到的变量从线程的工作内存中清除，而这样在synchronized块使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存。</p>
<p>其实这也是加锁和释放锁的语义，当获取锁后会清空锁块内本地内存中将会被用到的共享变量，在使用这些共享变量时从主内存进行加载，在释放锁时将本地内存中修改的共享变量刷新到主内存。</p>
<p>除了可以解决共享变量内存可见性的问题外，synchronized经常被用来实现原子性操作。</p>
<p>我们首先来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 传入的是同一个Runnable实例，都可以访问到成员变量x</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;result: &quot;</span> + x++);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这个程序，实际上每次输出的结果都是不相同的，这两个线程实际上共享了成员变量x，如果一个对象有可以被修改的成员变量，我们就认为这个对象是可变的对象，或者称之为有状态的，反之，如果一个对象没有被修改的成员变量，那么我们称这个对象是无状态的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread1(myClass);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread2(myClass);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">700</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">400</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">world</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyClass myClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(MyClass myClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myClass = myClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myClass.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyClass myClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread2</span><span class="params">(MyClass myClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myClass = myClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myClass.world();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Task :MyThreadTest2.main()</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<p>如果一个对象有若个synchronized方法，在某一个时刻只会有唯一的一个synchronized方法会被某一个线程访问，原因就在于当前对象的锁只有一个。当方法是static的时候，获取的锁不再是当前对象的锁，而是当前对象的Class的锁。</p>
<h3 id="synchronized字节码分析"><a class="markdownIt-Anchor" href="#synchronized字节码分析"></a> synchronized字节码分析</h3>
<p>synchronized关键字一般来说可以作用在代码块和方法当中，当作用在代码块的中的时候，一般会使用如下的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到object对象的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用命令进行反编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -c MyTest2.class</span><br></pre></td></tr></table></figure>
<p>反编译的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">concurrency2</span>.<span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  <span class="keyword">public</span> concurrency2.MyTest2();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line">       <span class="number">8</span>: dup</span><br><span class="line">       <span class="number">9</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">12</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field object:Ljava/lang/Object;</span></span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="comment">// 获取当前对象的成员变量</span></span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">3</span>                  <span class="comment">// Field object:Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">4</span>: dup</span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="comment">// 锁进入</span></span><br><span class="line">       <span class="number">6</span>: monitorenter</span><br><span class="line">       <span class="comment">// 开始执行代码</span></span><br><span class="line">       <span class="number">7</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">10</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String hello world</span></span><br><span class="line">      <span class="number">12</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">15</span>: aload_1</span><br><span class="line">      <span class="comment">// 锁退出</span></span><br><span class="line">      <span class="number">16</span>: monitorexit</span><br><span class="line">      <span class="number">17</span>: goto          <span class="number">25</span></span><br><span class="line">      <span class="number">20</span>: astore_2</span><br><span class="line">      <span class="number">21</span>: aload_1</span><br><span class="line">      <span class="comment">// 处理异常退出锁的释放</span></span><br><span class="line">      <span class="number">22</span>: monitorexit</span><br><span class="line">      <span class="number">23</span>: aload_2</span><br><span class="line">      <span class="number">24</span>: athrow</span><br><span class="line">      <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">7</span>    <span class="number">17</span>    <span class="number">20</span>   any</span><br><span class="line">          <span class="number">20</span>    <span class="number">23</span>    <span class="number">20</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个monitorexit的原因是，无论代码执行是否抛出了异常，都会释放掉锁的对象，这部分是由Java编译器所做的工作。</p>
<p>当我们使用synchronized关键字来修饰代码块时，字节码层面上是通过monitor与monitorexit指令来实现的锁的获取与释放动作，一个monitor可能对应一个或者多个monitorexit，为了说明这一点，我们修改一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到object对象的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候反编译字节码就会得到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">concurrency2</span>.<span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> concurrency2.MyTest2();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line">       <span class="number">8</span>: dup</span><br><span class="line">       <span class="number">9</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">12</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field object:Ljava/lang/Object;</span></span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">3</span>                  <span class="comment">// Field object:Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">4</span>: dup</span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="number">6</span>: monitorenter</span><br><span class="line">       <span class="number">7</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">10</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String hello world</span></span><br><span class="line">      <span class="number">12</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">15</span>: <span class="keyword">new</span>           #<span class="number">7</span>                  <span class="comment">// class java/lang/RuntimeException</span></span><br><span class="line">      <span class="number">18</span>: dup</span><br><span class="line">      <span class="comment">// RuntimeException的构造方法</span></span><br><span class="line">      <span class="number">19</span>: invokespecial #<span class="number">8</span>                  <span class="comment">// Method java/lang/RuntimeException.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">22</span>: athrow</span><br><span class="line">      <span class="number">23</span>: astore_2</span><br><span class="line">      <span class="number">24</span>: aload_1</span><br><span class="line">      <span class="number">25</span>: monitorexit</span><br><span class="line">      <span class="number">26</span>: aload_2</span><br><span class="line">      <span class="number">27</span>: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">7</span>    <span class="number">26</span>    <span class="number">23</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么只有一个monitorexit呢？因为程序的出口只有一种，或者说程序运行的最终结果一定会抛出异常，这个时候athrow是一定会执行的，因此只有唯一的一个monitorexit。</p>
<p>当线程进入到monitorenter指令后，线程将会持有Monitor对象，退出monitorenter指令后，线程将会释放Moniter对象。</p>
<p>synchronized关键字除了可以作用在代码块上，还可以作用在方法上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样反编译之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;                                                                                                         </span><br><span class="line">  <span class="keyword">public</span> concurrency2.MyTest3();                                                                          </span><br><span class="line">    descriptor: ()V                                                                                       </span><br><span class="line">    flags: ACC_PUBLIC                                                                                     </span><br><span class="line">    Code:                                                                                                 </span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>                                                                      </span><br><span class="line">         <span class="number">0</span>: aload_0                                                                                       </span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V                     </span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span>                                                                                        </span><br><span class="line">      LineNumberTable:                                                                                    </span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span>                                                                                         </span><br><span class="line">      LocalVariableTable:                                                                                 </span><br><span class="line">        Start  Length  Slot  Name   Signature                                                             </span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lconcurrency2/MyTest3;                                                </span><br><span class="line">                                                                                                          </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;                                                                      </span><br><span class="line">    descriptor: ()V                                                                                       	<span class="comment">// ACC_SYNCHRONIZED表示这是一个synchronized方法</span></span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED                                                                   </span><br><span class="line">    Code:                                                                                                 	<span class="comment">//默认情况下参数的长度为1，是因为传入了当前对象</span></span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>                                                                      </span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;         </span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world                                       </span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V </span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span>                                                                                        </span><br><span class="line">      LineNumberTable:                                                                                    </span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span>                                                                                        </span><br><span class="line">        line <span class="number">11</span>: <span class="number">8</span>                                                                                        </span><br><span class="line">      LocalVariableTable:                                                                                 </span><br><span class="line">        Start  Length  Slot  Name   Signature                                                             </span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lconcurrency2/MyTest3;                                                </span><br><span class="line">&#125;                                                                                                       </span><br></pre></td></tr></table></figure>
<p>synchronized关键字修饰方法与代码块不同的地方是，并没有通过monitorenter与monitorexit指令来描述，而是使用ACC_SYNCHRONIZED表示该方法被synchronized修饰。当方法被调用的时候，JVM会检查该方法是否拥有ACC_SYNCHRONIZED标志，如果有，那么执行线程将会持有方法所在的Monitor对象，然后再去执行方法体，在该方法执行期间，其他线程均无法再获取到这个Monitor对象，当线程执行完该方法后，它会释放掉这个Monitor对象。</p>
<p>synchronized关键字还有可能作用在静态方法上面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;                                                                                                          </span><br><span class="line">  <span class="keyword">public</span> concurrency2.MyTest4();                                                                           </span><br><span class="line">    descriptor: ()V                                                                                        </span><br><span class="line">    flags: ACC_PUBLIC                                                                                      </span><br><span class="line">    Code:                                                                                                  </span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>                                                                       </span><br><span class="line">         <span class="number">0</span>: aload_0                                                                                        </span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V                      </span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span>                                                                                         </span><br><span class="line">      LineNumberTable:                                                                                     </span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span>                                                                                          </span><br><span class="line">      LocalVariableTable:                                                                                  </span><br><span class="line">        Start  Length  Slot  Name   Signature                                                              </span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lconcurrency2/MyTest4;                                                 </span><br><span class="line">                                                                                                           </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;                                                                </span><br><span class="line">    descriptor: ()V</span><br><span class="line">    <span class="comment">//  ACC_STATIC表示静态的同步方法</span></span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED                                                        </span><br><span class="line">    Code:                                                                                                  </span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span>                                                                       </span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;          </span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world                                        </span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V  </span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span>                                                                                         </span><br><span class="line">      LineNumberTable:                                                                                     </span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span>                                                                                         </span><br><span class="line">        line <span class="number">11</span>: <span class="number">8</span>                                                                                         </span><br><span class="line">&#125;                                                                                                          </span><br></pre></td></tr></table></figure>
<p>可以看到无论是修改实例方法还是静态方法，都是通过ACC_SYNCHRONIZED来实现的，静态方法还会增加ACC_STATIC来表示是静态方法。</p>
<h2 id="volatile关键字"><a class="markdownIt-Anchor" href="#volatile关键字"></a> Volatile关键字</h2>
<p>volatile本身的含义的是不稳定的意思，总体而言，volatile关键字主要有三方面的作用：</p>
<ol>
<li>实现long/double类型变量的原子操作</li>
<li>防止指令重排序</li>
<li>实现变量的可变性</li>
</ol>
<p>当一个变量被声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存的值。</p>
<p>volatile的内存语义与synchronized有相似之处，具体来说就是，读取volatile变量值时就相当于进入同步块（先清空本地内存变量值，再从主内存获取最新值），写入volatile变量值时就等价于线程退出synchronized同步块（把写入工作内存的变量值同步到主内存）。</p>
<h3 id="变量的可见性"><a class="markdownIt-Anchor" href="#变量的可见性"></a> 变量的可见性</h3>
<p>变量的可见性的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时value不是线程安全的，因为没有适当的同步措施。首先来看使用synchronized关键字进行同步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以使用volatile进行同步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里使用synchronized和使用volatile时等价的，都解决了共享变量value的内存可见性问题，但是前者是独占锁，同时只能有一个线程调用get方法，其他调用线程会被阻塞，同时会存在线程上下文切换和线程重新调度的开销，这也是使用锁方式不好的地方。而后者是非阻塞算法，不会造成线程上下文切换的凯西奥。</p>
<p>但并非所有情况下使用它们都是等价的，volatile虽然提供了可见性保证，但并不保证操作的原子性。</p>
<p>那么一般什么时候才使用volatile关键字呢？</p>
<ul>
<li>写入变量值不依赖变量的当前值时。因为如果依赖当前值，写入的过程就会变成获取-计算-写入三步操作，这三步操作不是原子性的，而volatile不保证原子性</li>
<li>读写变量值时没有加锁。因为加锁本身已经保证了内存可见性，这时候不需要把变量声明为volatile的。</li>
</ul>
<h3 id="指令重排序"><a class="markdownIt-Anchor" href="#指令重排序"></a> 指令重排序</h3>
<p>Java内存模型允许编译器和处理对指令重排序以提高运行性能，并且只会对不存在的数据依赖性的指令重排序。在单线程下重排序可以保证最终执行的结果与程序顺序执行的结果一致，但是在多线程下就会存在问题。</p>
<p>volatile除了保证内存的可见性之外，还可以防止指令重排序。在写入volatile变量时，可以确保volatile写之前的操作不会被编译器重排序到volatile写之后，可以确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileAtomicDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// private static volatile boolean ready = false;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">                    System.out.println(num + num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;read thread...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里可能会发生指令重排序，有可能先执行ready = true</span></span><br><span class="line">            <span class="comment">// 此时读线程可能已经获取到ready的值，那么输出的结果就是0，而不是4</span></span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">            ready = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;writeThread set over...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        ReadThread readThread = <span class="keyword">new</span> ReadThread();</span><br><span class="line">        readThread.start();</span><br><span class="line"></span><br><span class="line">        WriteThread writeThread = <span class="keyword">new</span> WriteThread();</span><br><span class="line">        writeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        readThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;main exit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重排序在多线程下会导致非预期的程序执行结果，而是用volatile修饰ready就可以避免重排序和内存可见性问题。</p>
<h2 id="monitor"><a class="markdownIt-Anchor" href="#monitor"></a> Monitor</h2>
<h3 id="自旋"><a class="markdownIt-Anchor" href="#自旋"></a> 自旋</h3>
<p>JVM中的同步是基于进入与退出监视器对象（管程对象）（Monitor）来实现的，每个对象实例都会有一个Monitor对象，Monitor对象会和Java对象一同创建，一同销毁，Monitor对象是由C++来实现的。</p>
<p>当多个线程同时访问一段同步代码时，这些线程会被方法一个EntryList集合当中，处于阻塞状态的线程都会被方法该列表中。接下来，当线程获取到对象的Monitor时，Monitor是依赖于底层操作系统的mutex lock（互斥锁）来实现互斥的，线程获取mutex成功，则会持有mutex，这时其他线程就无法再获取到该mutex。</p>
<p>如果线程调用了wait方法，那么该线程就会释放掉所持有的mutex，并且该线程会进入到WaitSet集合（等待集合）中，等待下一次被其他线程调用notify/notifyAll唤醒。如果当前线程顺利执行完毕方法，那么它也会释放掉所持有的mutex。</p>
<p>同步锁再这种实现方式当中，因为Monitor是依赖于底层的操作系统实现，因此存在用户态与内核态之间的切换，所以会增加性能开销，通过对象互斥锁的概念来保证共享数据操作的完整性。每个对象都对应于一个可称为互斥锁的标记，这个标记用于保证在任何时刻，只能有一个线程访问该对象。</p>
<p>那些处于EntryList与WaitSet中的线程均处于阻塞状态，阻塞操作是由操作系统来完成的，在linux下是通过pthread_ mutex_lock函数实现的。线程被阻塞之后便会进入到内核调度方法，这会导致系统在用户态与内核态之间来回切换，严重影响锁的性能。</p>
<p>解决上述问题的办法便是自旋（Spin），其原理是：当发生对Monitor的争用时，如果Owner能够在很短的时间内释放掉锁，则那些正在争用的线程就是稍微等待一下（即自旋），在Owner线程释放锁之后，争用线程就有可能会立刻获取到锁，从而避免了系统阻塞。不过，当Owner运行的时间超过了临界值后，争用线程自旋一段时间后依然无法获取到锁，这时争用线程则会停止自旋进入到阻塞状态，所的来说：先自旋，不成功再进入阻塞状态，尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说有极大的性能提升。显然，自旋在多核心处理器上才有意义。</p>
<h3 id="互斥锁"><a class="markdownIt-Anchor" href="#互斥锁"></a> 互斥锁</h3>
<p>互斥锁的属性：</p>
<ol>
<li>PTHREAD_MUTEX_TIME_NP：这是缺省值，也就是普通锁，当一个线程加锁以后，其余请求锁的线程将会形成一个等待队列，并且在解锁后按照优先级获取到锁。这种策略可以确保资源分配的公平性。</li>
<li>PTHREAD_MUTEX_RECURSIVE_NP：嵌套锁，允许一个线程对同一个锁成功获取多次，并且通过unlock解锁，如果是不同线程请求，则在加锁线程解锁时重新进行竞争。</li>
<li>PTHREAD_MUTEX_ERRORCHECK_NP：检错锁，如果一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIME_NP类型相同，这样就保证了当不允许多次加锁时出现最简单情况下的死锁。</li>
<li>PTHREAD_MUTEX_ADAPTIVE_NP：适应锁，动作最简单的锁类型，仅仅等待解锁后重新竞争。</li>
</ol>
<h3 id="monitor源码分析"><a class="markdownIt-Anchor" href="#monitor源码分析"></a> Monitor源码分析</h3>
<p>接下来我们通过<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/73f624a2488d/src/share/vm/runtime">openjdk</a>的源代码来分析Monitor底层的实现。</p>
<p>objectMonitor.hpp（头文件）和objectMonitor.cpp（具体的实现）这两个文件是关于Monitor的底层实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHARE_VM_RUNTIME_OBJECTMONITOR_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHARE_VM_RUNTIME_OBJECTMONITOR_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;runtime/os.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;runtime/park.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;runtime/perfData.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞在当前的Monitor上的线程的封装，是一种链表的结构：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectWaiter</span> :</span> <span class="keyword">public</span> StackObj &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">TStates</span> &#123;</span> TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ &#125; ;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Sorted</span>  &#123;</span> PREPEND, APPEND, SORTED &#125; ;</span><br><span class="line">  <span class="comment">// 前一个ObjectWaiter</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _next;</span><br><span class="line">  <span class="comment">// 后一个ObjectWaiter</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _prev;</span><br><span class="line">  Thread*       _thread;</span><br><span class="line">  jlong         _notifier_tid;</span><br><span class="line">  ParkEvent *   _event;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span>  _notified ;</span><br><span class="line">  <span class="keyword">volatile</span> TStates TState ;</span><br><span class="line">  Sorted        _Sorted ;           <span class="comment">// List placement disposition</span></span><br><span class="line">  <span class="keyword">bool</span>          _active ;           <span class="comment">// Contention monitoring is enabled</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ObjectWaiter</span>(Thread* thread);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_reenter_begin</span><span class="params">(ObjectMonitor *mon)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_reenter_end</span><span class="params">(ObjectMonitor *mon)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectMonitor</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    OM_OK,                    <span class="comment">// no error</span></span><br><span class="line">    OM_SYSTEM_ERROR,          <span class="comment">// operating system error</span></span><br><span class="line">    OM_ILLEGAL_MONITOR_STATE, <span class="comment">// IllegalMonitorStateException</span></span><br><span class="line">    OM_INTERRUPTED,           <span class="comment">// Thread.interrupt()</span></span><br><span class="line">    OM_TIMED_OUT              <span class="comment">// Object.wait() timed out</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">header_offset_in_bytes</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _header);     &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">object_offset_in_bytes</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _object);     &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">owner_offset_in_bytes</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _owner);      &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count_offset_in_bytes</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _count);      &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recursions_offset_in_bytes</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _recursions); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cxq_offset_in_bytes</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _cxq) ;       &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">succ_offset_in_bytes</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _succ) ;      &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">EntryList_offset_in_bytes</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _EntryList);  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FreeNext_offset_in_bytes</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, FreeNext);    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">WaitSet_offset_in_bytes</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _WaitSet) ;   &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Responsible_offset_in_bytes</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _Responsible);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Spinner_offset_in_bytes</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _Spinner);    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*SpinCallbackFunction)</span><span class="params">(<span class="keyword">intptr_t</span>, <span class="keyword">int</span>)</span> </span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">intptr_t</span> SpinCallbackArgument ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">markOop   <span class="title">header</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">set_header</span><span class="params">(markOop hdr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span> <span class="title">is_busy</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _count|_waiters|<span class="built_in">intptr_t</span>(_owner)|<span class="built_in">intptr_t</span>(_cxq)|<span class="built_in">intptr_t</span>(_EntryList ) ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">is_entered</span><span class="params">(Thread* current)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span>*     <span class="title">owner</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">set_owner</span><span class="params">(<span class="keyword">void</span>* owner)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">waiters</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">count</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">set_count</span><span class="params">(<span class="keyword">intptr_t</span> count)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">contentions</span><span class="params">()</span> <span class="keyword">const</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">recursions</span><span class="params">()</span> <span class="keyword">const</span>                                         </span>&#123; <span class="keyword">return</span> _recursions; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// JVM/DI GetMonitorInfo() needs this</span></span><br><span class="line">  <span class="function">ObjectWaiter* <span class="title">first_waiter</span><span class="params">()</span>                                         </span>&#123; <span class="keyword">return</span> _WaitSet; &#125;</span><br><span class="line">  <span class="function">ObjectWaiter* <span class="title">next_waiter</span><span class="params">(ObjectWaiter* o)</span>                           </span>&#123; <span class="keyword">return</span> o-&gt;_next; &#125;</span><br><span class="line">  <span class="function">Thread* <span class="title">thread_of_waiter</span><span class="params">(ObjectWaiter* o)</span>                            </span>&#123; <span class="keyword">return</span> o-&gt;_thread; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化Monitor对象，除了semaphore都是简单的对象或者指针</span></span><br><span class="line">  <span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;</span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 等待集合</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">     <span class="comment">// 等待集合</span></span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ;</span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> Add asserts ...</span></span><br><span class="line">   <span class="comment">// _cxq == 0 _succ == NULL _owner == NULL _waiters == 0</span></span><br><span class="line">   <span class="comment">// _count == 0 _EntryList  == NULL etc</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Recycle</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add stronger asserts ...</span></span><br><span class="line">    <span class="comment">// _cxq == 0 _succ == NULL _owner == NULL _waiters == 0</span></span><br><span class="line">    <span class="comment">// _count == 0 EntryList  == NULL</span></span><br><span class="line">    <span class="comment">// _recursions == 0 _WaitSet == NULL</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> assert (is_busy()|_recursions) == 0</span></span><br><span class="line">    _succ          = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList     = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq           = <span class="literal">NULL</span> ;</span><br><span class="line">    _WaitSet       = <span class="literal">NULL</span> ;</span><br><span class="line">    _recursions    = <span class="number">0</span> ;</span><br><span class="line">    _SpinFreq      = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock     = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread  = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span>*     <span class="title">object</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>*     <span class="title">object_addr</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">set_object</span><span class="params">(<span class="keyword">void</span>* obj)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span>      <span class="title">check</span><span class="params">(TRAPS)</span></span>;       <span class="comment">// true if the thread owns the monitor.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">check_slow</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sanity_checks</span><span class="params">()</span></span>;  <span class="comment">// public for -XX:+ExecuteInternalVMTests</span></span><br><span class="line">                                <span class="comment">// in PRODUCT for -XX:SyncKnobs=Verbose=1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRODUCT</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">verify</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span>      <span class="title">try_enter</span> <span class="params">(TRAPS)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">enter</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">exit</span><span class="params">(<span class="keyword">bool</span> not_suspended, TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">wait</span><span class="params">(jlong millis, <span class="keyword">bool</span> interruptable, TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">notify</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">notifyAll</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the following at your own risk</span></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">complete_exit</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">reenter</span><span class="params">(<span class="keyword">intptr_t</span> recursions, TRAPS)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">AddWaiter</span> <span class="params">(ObjectWaiter * waiter)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span>    <span class="keyword">void</span> <span class="title">DeferredInitialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">ObjectWaiter * <span class="title">DequeueWaiter</span> <span class="params">()</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">DequeueSpecificWaiter</span> <span class="params">(ObjectWaiter * waiter)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">EnterI</span> <span class="params">(TRAPS)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">ReenterI</span> <span class="params">(Thread * Self, ObjectWaiter * SelfNode)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">UnlinkAfterAcquire</span> <span class="params">(Thread * Self, ObjectWaiter * SelfNode)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">TryLock</span> <span class="params">(Thread * Self)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">NotRunnable</span> <span class="params">(Thread * Self, Thread * Owner)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">TrySpin_Fixed</span> <span class="params">(Thread * Self)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">TrySpin_VaryFrequency</span> <span class="params">(Thread * Self)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">TrySpin_VaryDuration</span>  <span class="params">(Thread * Self)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">ctAsserts</span> <span class="params">()</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">ExitEpilog</span> <span class="params">(Thread * Self, ObjectWaiter * Wakee)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span>      <span class="title">ExitSuspendEquivalent</span> <span class="params">(JavaThread * Self)</span> </span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSynchronizer</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectWaiter</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// WARNING: this must be the very first word of ObjectMonitor</span></span><br><span class="line">  <span class="comment">// This means this class can&#x27;t use any virtual member functions.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> markOop   _header;       <span class="comment">// displaced object header word - mark</span></span><br><span class="line">  <span class="keyword">void</span>*     <span class="keyword">volatile</span> _object;       <span class="comment">// backward object pointer - strong root</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> SharingPad [<span class="number">1</span>] ;           <span class="comment">// temp to reduce false sharing</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// All the following fields must be machine word aligned</span></span><br><span class="line">  <span class="comment">// The VM assumes write ordering wrt these fields, which can be</span></span><br><span class="line">  <span class="comment">// read from other threads.</span></span><br><span class="line"> <span class="comment">// 锁的持有者</span></span><br><span class="line"> <span class="keyword">protected</span>:                         <span class="comment">// protected for jvmtiRawMonitor</span></span><br><span class="line">  <span class="keyword">void</span> *  <span class="keyword">volatile</span> _owner;          <span class="comment">// pointer to owning thread OR BasicLock</span></span><br><span class="line">  <span class="keyword">volatile</span> jlong _previous_owner_tid; <span class="comment">// thread id of the previous owner of the monitor</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>  _recursions;   <span class="comment">// recursion count, 0 for first entry</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> OwnerIsThread ;               <span class="comment">// _owner is (Thread *) vs SP/BasicLock</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _cxq ;    <span class="comment">// LL of recently-arrived threads blocked on entry.</span></span><br><span class="line">                                    <span class="comment">// The list is actually composed of WaitNodes, acting</span></span><br><span class="line"> <span class="comment">// 没获取到锁的线程                                   // as proxies for Threads.</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _EntryList ;     <span class="comment">// Threads blocked on entry or reentry.</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Thread * <span class="keyword">volatile</span> _succ ;          <span class="comment">// Heir presumptive thread - used for futile wakeup throttling</span></span><br><span class="line">  Thread * <span class="keyword">volatile</span> _Responsible ;</span><br><span class="line">  <span class="keyword">int</span> _PromptDrain ;                <span class="comment">// rqst to drain cxq into EntryList ASAP</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _Spinner ;           <span class="comment">// for exit-&gt;spinner handoff optimization</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _SpinFreq ;          <span class="comment">// Spin 1-out-of-N attempts: success rate</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _SpinClock ;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _SpinDuration ;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span> _SpinState ;    <span class="comment">// MCS/CLH list of spinners</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO-<span class="doctag">FIXME:</span> _count, _waiters and _recursions should be of</span></span><br><span class="line">  <span class="comment">// type int, or int32_t but not intptr_t.  There&#x27;s no reason</span></span><br><span class="line">  <span class="comment">// to use 64-bit fields for these variables on a 64-bit JVM.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>  _count;        <span class="comment">// reference count to prevent reclaimation/deflation</span></span><br><span class="line">                                    <span class="comment">// at stop-the-world time.  See deflate_idle_monitors().</span></span><br><span class="line">                                    <span class="comment">// _count is approximately |_WaitSet| + |_EntryList|</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>  _waiters;      <span class="comment">// number of waiting threads</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 等待集合定义</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _WaitSet; <span class="comment">// LL of threads wait()ing on the monitor</span></span><br><span class="line">    <span class="comment">// 等待队列,简单的自旋锁</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _WaitSetLock;        <span class="comment">// protects Wait Queue - simple spinlock</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> _QMix ;                       <span class="comment">// Mixed prepend queue discipline</span></span><br><span class="line">  ObjectMonitor * FreeNext ;        <span class="comment">// Free list linkage</span></span><br><span class="line">  <span class="keyword">intptr_t</span> StatA, StatsB ;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Initialize</span> <span class="params">()</span> </span>;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_ContendedLockAttempts ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_FutileWakeups ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_Parks ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_EmptyNotifications ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_Notifications ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SlowEnter ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SlowExit ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SlowNotify ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SlowNotifyAll ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_FailedSpins ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SuccessfulSpins ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_PrivateA ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_PrivateB ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_MonInCirculation ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_MonScavenged ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_Inflations ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_Deflations ;</span><br><span class="line">  <span class="keyword">static</span> PerfLongVariable * _sync_MonExtant ;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> Knob_Verbose;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> Knob_SpinLimit;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AllocateHeap</span>(size, mtInternal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="keyword">size_t</span> size) <span class="built_in"><span class="keyword">throw</span></span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span> (size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">FreeHeap</span>(p, mtInternal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[] (<span class="keyword">void</span> *p) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> TEVENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEVENT(nom) &#123;<span class="meta-keyword">if</span> (SyncVerbose) FEVENT(nom); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FEVENT(nom) &#123; static volatile int ctr = 0 ; int v = ++ctr ; <span class="meta-keyword">if</span> ((v &amp; (v-1)) == 0) &#123; ::printf (#nom <span class="meta-string">&quot; : %d \n&quot;</span>, v); ::fflush(stdout); &#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span>  TEVENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEVENT(nom) &#123;;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>EntryList、WaitSet采用链表的方式是因为在这个链表中，要根据某一定的规则查找、删除、增加线程比较容易。只有经过wait方法调用的时候，才会进入到WaitSet集合当中。</p>
<h3 id="wait-notify源码分析"><a class="markdownIt-Anchor" href="#wait-notify源码分析"></a> wait、notify源码分析</h3>
<p>wait方法的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::wait</span><span class="params">(jlong millis, <span class="keyword">bool</span> interruptible, TRAPS)</span> </span>&#123;</span><br><span class="line">   Thread * <span class="keyword">const</span> Self = THREAD ;</span><br><span class="line">   <span class="built_in">assert</span>(Self-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;Must be Java thread!&quot;</span>);</span><br><span class="line">   JavaThread *jt = (JavaThread *)THREAD;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">DeferredInitialize</span> () ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Throw IMSX or IEX.</span></span><br><span class="line">   <span class="built_in">CHECK_OWNER</span>();</span><br><span class="line"></span><br><span class="line">   EventJavaMonitorWait event;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// check for a pending interrupt</span></span><br><span class="line">   <span class="keyword">if</span> (interruptible &amp;&amp; Thread::<span class="built_in">is_interrupted</span>(Self, <span class="literal">true</span>) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">     <span class="comment">// post monitor waited event.  Note that this is past-tense, we are done waiting.</span></span><br><span class="line">     <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_waited</span>()) &#123;</span><br><span class="line">        <span class="comment">// Note: &#x27;false&#x27; parameter is passed here because the</span></span><br><span class="line">        <span class="comment">// wait was not timed out due to thread interrupt.</span></span><br><span class="line">        JvmtiExport::<span class="built_in">post_monitor_waited</span>(jt, <span class="keyword">this</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In this short circuit of the monitor wait protocol, the</span></span><br><span class="line">        <span class="comment">// current thread never drops ownership of the monitor and</span></span><br><span class="line">        <span class="comment">// never gets added to the wait queue so the current thread</span></span><br><span class="line">        <span class="comment">// cannot be made the successor. This means that the</span></span><br><span class="line">        <span class="comment">// JVMTI_EVENT_MONITOR_WAITED event handler cannot accidentally</span></span><br><span class="line">        <span class="comment">// consume an unpark() meant for the ParkEvent associated with</span></span><br><span class="line">        <span class="comment">// this ObjectMonitor.</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">       <span class="built_in">post_monitor_wait_event</span>(&amp;event, <span class="keyword">this</span>, <span class="number">0</span>, millis, <span class="literal">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">TEVENT</span> (Wait - Throw IEX) ;</span><br><span class="line">     <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_InterruptedException</span>());</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">TEVENT</span> (Wait) ;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">assert</span> (Self-&gt;_Stalled == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   Self-&gt;_Stalled = <span class="built_in">intptr_t</span>(<span class="keyword">this</span>) ;</span><br><span class="line">   jt-&gt;<span class="built_in">set_current_waiting_monitor</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// create a node to be put into the queue</span></span><br><span class="line">   <span class="comment">// Critically, after we reset() the event but prior to park(), we must check</span></span><br><span class="line">   <span class="comment">// for a pending interrupt.</span></span><br><span class="line">   <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span></span>;</span><br><span class="line">   node.TState = ObjectWaiter::TS_WAIT ;</span><br><span class="line">   Self-&gt;_ParkEvent-&gt;<span class="built_in">reset</span>() ;</span><br><span class="line">   OrderAccess::<span class="built_in">fence</span>();          <span class="comment">// ST into Event; membar ; LD interrupted-flag</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Enter the waiting queue, which is a circular doubly linked list in this case</span></span><br><span class="line">   <span class="comment">// but it could be a priority queue or any data structure.</span></span><br><span class="line">   <span class="comment">// _WaitSetLock protects the wait queue.  Normally the wait queue is accessed only</span></span><br><span class="line">   <span class="comment">// by the the owner of the monitor *except* in the case where park()</span></span><br><span class="line">   <span class="comment">// returns because of a timeout of interrupt.  Contention is exceptionally rare</span></span><br><span class="line">   <span class="comment">// so we use a simple spin-lock instead of a heavier-weight blocking lock.</span></span><br><span class="line"></span><br><span class="line">   Thread::<span class="built_in">SpinAcquire</span> (&amp;_WaitSetLock, <span class="string">&quot;WaitSet - add&quot;</span>) ;</span><br><span class="line">    <span class="comment">// 将封装好的node对象放到队列中，通过双向链表实现的</span></span><br><span class="line">   <span class="built_in">AddWaiter</span> (&amp;node) ;</span><br><span class="line">   Thread::<span class="built_in">SpinRelease</span> (&amp;_WaitSetLock) ;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">intptr_t</span> save = _recursions; <span class="comment">// record the old recursion count</span></span><br><span class="line">   _waiters++;                  <span class="comment">// increment the number of waiters</span></span><br><span class="line">   _recursions = <span class="number">0</span>;             <span class="comment">// set the recursion level to be 1</span></span><br><span class="line">    <span class="comment">// 释放掉锁</span></span><br><span class="line">   <span class="built_in">exit</span> (<span class="literal">true</span>, Self) ;                    <span class="comment">// exit the monitor</span></span><br><span class="line">   <span class="built_in">guarantee</span> (_owner != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The thread is on the WaitSet list - now park() it.</span></span><br><span class="line">   <span class="comment">// On MP systems it&#x27;s conceivable that a brief spin before we park</span></span><br><span class="line">   <span class="comment">// could be profitable.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// TODO-<span class="doctag">FIXME:</span> change the following logic to a loop of the form</span></span><br><span class="line">   <span class="comment">//   while (!timeout &amp;&amp; !interrupted &amp;&amp; _notified == 0) park()</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> ret = OS_OK ;</span><br><span class="line">   <span class="keyword">int</span> WasNotified = <span class="number">0</span> ;</span><br><span class="line">   &#123; <span class="comment">// State transition wrappers</span></span><br><span class="line">     OSThread* osthread = Self-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">     <span class="function">OSThreadWaitState <span class="title">osts</span><span class="params">(osthread, <span class="literal">true</span>)</span></span>;</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="function">ThreadBlockInVM <span class="title">tbivm</span><span class="params">(jt)</span></span>;</span><br><span class="line">       <span class="comment">// Thread is in thread_blocked state and oop access is unsafe.</span></span><br><span class="line">       jt-&gt;<span class="built_in">set_suspend_equivalent</span>();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (interruptible &amp;&amp; (Thread::<span class="built_in">is_interrupted</span>(THREAD, <span class="literal">false</span>) || HAS_PENDING_EXCEPTION)) &#123;</span><br><span class="line">           <span class="comment">// Intentionally empty</span></span><br><span class="line">       &#125; <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">if</span> (node._notified == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (millis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span> () ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span> (millis) ;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// were we externally suspended while we were waiting?</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">ExitSuspendEquivalent</span> (jt)) &#123;</span><br><span class="line">          <span class="comment">// TODO-<span class="doctag">FIXME:</span> add -- if succ == Self then succ = null.</span></span><br><span class="line">          jt-&gt;<span class="built_in">java_suspend_self</span>();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="comment">// Exit thread safepoint: transition _thread_blocked -&gt; _thread_in_vm</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">// Node may be on the WaitSet, the EntryList (or cxq), or in transition</span></span><br><span class="line">     <span class="comment">// from the WaitSet to the EntryList.</span></span><br><span class="line">     <span class="comment">// See if we need to remove Node from the WaitSet.</span></span><br><span class="line">     <span class="comment">// We use double-checked locking to avoid grabbing _WaitSetLock</span></span><br><span class="line">     <span class="comment">// if the thread is not on the wait queue.</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">// Note that we don&#x27;t need a fence before the fetch of TState.</span></span><br><span class="line">     <span class="comment">// In the worst case we&#x27;ll fetch a old-stale value of TS_WAIT previously</span></span><br><span class="line">     <span class="comment">// written by the is thread. (perhaps the fetch might even be satisfied</span></span><br><span class="line">     <span class="comment">// by a look-aside into the processor&#x27;s own store buffer, although given</span></span><br><span class="line">     <span class="comment">// the length of the code path between the prior ST and this load that&#x27;s</span></span><br><span class="line">     <span class="comment">// highly unlikely).  If the following LD fetches a stale TS_WAIT value</span></span><br><span class="line">     <span class="comment">// then we&#x27;ll acquire the lock and then re-fetch a fresh TState value.</span></span><br><span class="line">     <span class="comment">// That is, we fail toward safety.</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (node.TState == ObjectWaiter::TS_WAIT) &#123;</span><br><span class="line">         Thread::<span class="built_in">SpinAcquire</span> (&amp;_WaitSetLock, <span class="string">&quot;WaitSet - unlink&quot;</span>) ;</span><br><span class="line">         <span class="keyword">if</span> (node.TState == ObjectWaiter::TS_WAIT) &#123;</span><br><span class="line">            <span class="built_in">DequeueSpecificWaiter</span> (&amp;node) ;       <span class="comment">// unlink from WaitSet</span></span><br><span class="line">            <span class="built_in">assert</span>(node._notified == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">            node.TState = ObjectWaiter::TS_RUN ;</span><br><span class="line">         &#125;</span><br><span class="line">         Thread::<span class="built_in">SpinRelease</span> (&amp;_WaitSetLock) ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// The thread is now either on off-list (TS_RUN),</span></span><br><span class="line">     <span class="comment">// on the EntryList (TS_ENTER), or on the cxq (TS_CXQ).</span></span><br><span class="line">     <span class="comment">// The Node&#x27;s TState variable is stable from the perspective of this thread.</span></span><br><span class="line">     <span class="comment">// No other threads will asynchronously modify TState.</span></span><br><span class="line">     <span class="built_in">guarantee</span> (node.TState != ObjectWaiter::TS_WAIT, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     OrderAccess::<span class="built_in">loadload</span>() ;</span><br><span class="line">     <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line">     WasNotified = node._notified ;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Reentry phase -- reacquire the monitor.</span></span><br><span class="line">     <span class="comment">// re-enter contended monitor after object.wait().</span></span><br><span class="line">     <span class="comment">// retain OBJECT_WAIT state until re-enter successfully completes</span></span><br><span class="line">     <span class="comment">// Thread state is thread_in_vm and oop access is again safe,</span></span><br><span class="line">     <span class="comment">// although the raw address of the object may have changed.</span></span><br><span class="line">     <span class="comment">// (Don&#x27;t cache naked oops over safepoints, of course).</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// post monitor waited event. Note that this is past-tense, we are done waiting.</span></span><br><span class="line">     <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_waited</span>()) &#123;</span><br><span class="line">       JvmtiExport::<span class="built_in">post_monitor_waited</span>(jt, <span class="keyword">this</span>, ret == OS_TIMEOUT);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (node._notified != <span class="number">0</span> &amp;&amp; _succ == Self) &#123;</span><br><span class="line">         <span class="comment">// In this part of the monitor wait-notify-reenter protocol it</span></span><br><span class="line">         <span class="comment">// is possible (and normal) for another thread to do a fastpath</span></span><br><span class="line">         <span class="comment">// monitor enter-exit while this thread is still trying to get</span></span><br><span class="line">         <span class="comment">// to the reenter portion of the protocol.</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="comment">// The ObjectMonitor was notified and the current thread is</span></span><br><span class="line">         <span class="comment">// the successor which also means that an unpark() has already</span></span><br><span class="line">         <span class="comment">// been done. The JVMTI_EVENT_MONITOR_WAITED event handler can</span></span><br><span class="line">         <span class="comment">// consume the unpark() that was done when the successor was</span></span><br><span class="line">         <span class="comment">// set because the same ParkEvent is shared between Java</span></span><br><span class="line">         <span class="comment">// monitors and JVM/TI RawMonitors (for now).</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="comment">// We redo the unpark() to ensure forward progress, i.e., we</span></span><br><span class="line">         <span class="comment">// don&#x27;t want all pending threads hanging (parked) with none</span></span><br><span class="line">         <span class="comment">// entering the unlocked monitor.</span></span><br><span class="line">         node._event-&gt;<span class="built_in">unpark</span>();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">       <span class="built_in">post_monitor_wait_event</span>(&amp;event, <span class="keyword">this</span>, node._notifier_tid, millis, ret == OS_TIMEOUT);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">assert</span> (Self-&gt;_Stalled != <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">assert</span> (_owner != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     ObjectWaiter::TStates v = node.TState ;</span><br><span class="line">     <span class="keyword">if</span> (v == ObjectWaiter::TS_RUN) &#123;</span><br><span class="line">         <span class="built_in">enter</span> (Self) ;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">guarantee</span> (v == ObjectWaiter::TS_ENTER || v == ObjectWaiter::TS_CXQ, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="built_in">ReenterI</span> (Self, &amp;node) ;</span><br><span class="line">         node.<span class="built_in">wait_reenter_end</span>(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Self has reacquired the lock.</span></span><br><span class="line">     <span class="comment">// Lifecycle - the node representing Self must not appear on any queues.</span></span><br><span class="line">     <span class="comment">// Node is about to go out-of-scope, but even if it were immortal we wouldn&#x27;t</span></span><br><span class="line">     <span class="comment">// want residual elements associated with this thread left on any lists.</span></span><br><span class="line">     <span class="built_in">guarantee</span> (node.TState == ObjectWaiter::TS_RUN, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span>    (_owner == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span>    (_succ != Self , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   &#125; <span class="comment">// OSThreadWaitState()</span></span><br><span class="line"></span><br><span class="line">   jt-&gt;<span class="built_in">set_current_waiting_monitor</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">guarantee</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   _recursions = save;     <span class="comment">// restore the old recursion count</span></span><br><span class="line">   _waiters--;             <span class="comment">// decrement the number of waiters</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Verify a few postconditions</span></span><br><span class="line">   <span class="built_in">assert</span> (_owner == Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   <span class="built_in">assert</span> (_succ  != Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   <span class="built_in">assert</span> (((oop)(<span class="built_in">object</span>()))-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">encode</span>(<span class="keyword">this</span>), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (SyncFlags &amp; <span class="number">32</span>) &#123;</span><br><span class="line">      OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// check if the notification happened</span></span><br><span class="line">   <span class="keyword">if</span> (!WasNotified) &#123;</span><br><span class="line">     <span class="comment">// no, it could be timeout or Thread.interrupt() or both</span></span><br><span class="line">     <span class="comment">// check for interrupt event, otherwise it is timeout</span></span><br><span class="line">     <span class="keyword">if</span> (interruptible &amp;&amp; Thread::<span class="built_in">is_interrupted</span>(Self, <span class="literal">true</span>) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">       <span class="built_in">TEVENT</span> (Wait - <span class="keyword">throw</span> IEX from epilog) ;</span><br><span class="line">       <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_InterruptedException</span>());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// <span class="doctag">NOTE:</span> Spurious wake up will be consider as timeout.</span></span><br><span class="line">   <span class="comment">// Monitor notify has precedence over thread interrupt.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>notify方法的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::notify</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">CHECK_OWNER</span>();</span><br><span class="line">    <span class="comment">// 等待集合为空</span></span><br><span class="line">  <span class="keyword">if</span> (_WaitSet == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">TEVENT</span> (Empty-Notify) ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DTRACE_MONITOR_PROBE</span>(notify, <span class="keyword">this</span>, <span class="built_in">object</span>(), THREAD);</span><br><span class="line">	<span class="comment">// 不同的调度策略（具体唤醒哪一个线程），使用调度策略将这个ObjectWaiter放置到EntryList</span></span><br><span class="line">  <span class="keyword">int</span> Policy = Knob_MoveNotifyee ;</span><br><span class="line"></span><br><span class="line">  Thread::<span class="built_in">SpinAcquire</span> (&amp;_WaitSetLock, <span class="string">&quot;WaitSet - notify&quot;</span>) ;</span><br><span class="line">  ObjectWaiter * iterator = <span class="built_in">DequeueWaiter</span>() ;</span><br><span class="line">  <span class="keyword">if</span> (iterator != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">TEVENT</span> (Notify1 - Transfer) ;</span><br><span class="line">     <span class="built_in">guarantee</span> (iterator-&gt;TState == ObjectWaiter::TS_WAIT, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">guarantee</span> (iterator-&gt;_notified == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="keyword">if</span> (Policy != <span class="number">4</span>) &#123;</span><br><span class="line">        iterator-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">     &#125;</span><br><span class="line">     iterator-&gt;_notified = <span class="number">1</span> ;</span><br><span class="line">     Thread * Self = THREAD;</span><br><span class="line">     iterator-&gt;_notifier_tid = <span class="built_in">JFR_THREAD_ID</span>(Self);</span><br><span class="line"></span><br><span class="line">     ObjectWaiter * List = _EntryList ;</span><br><span class="line">     <span class="keyword">if</span> (List != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">assert</span> (List-&gt;_prev == <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (List-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (List != iterator, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (Policy == <span class="number">0</span>) &#123;       <span class="comment">// prepend to EntryList</span></span><br><span class="line">         <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">             _EntryList = iterator ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             List-&gt;_prev = iterator ;</span><br><span class="line">             iterator-&gt;_next = List ;</span><br><span class="line">             iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">             _EntryList = iterator ;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">if</span> (Policy == <span class="number">1</span>) &#123;      <span class="comment">// append to EntryList</span></span><br><span class="line">         <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">             _EntryList = iterator ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// CONSIDER:  finding the tail currently requires a linear-time walk of</span></span><br><span class="line">            <span class="comment">// the EntryList.  We can make tail access constant-time by converting to</span></span><br><span class="line">            <span class="comment">// a CDLL instead of using our current DLL.</span></span><br><span class="line">            ObjectWaiter * Tail ;</span><br><span class="line">            <span class="keyword">for</span> (Tail = List ; Tail-&gt;_next != <span class="literal">NULL</span> ; Tail = Tail-&gt;_next) ;</span><br><span class="line">            <span class="built_in">assert</span> (Tail != <span class="literal">NULL</span> &amp;&amp; Tail-&gt;_next == <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            Tail-&gt;_next = iterator ;</span><br><span class="line">            iterator-&gt;_prev = Tail ;</span><br><span class="line">            iterator-&gt;_next = <span class="literal">NULL</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">if</span> (Policy == <span class="number">2</span>) &#123;      <span class="comment">// prepend to cxq</span></span><br><span class="line">         <span class="comment">// prepend to cxq</span></span><br><span class="line">         <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">             _EntryList = iterator ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            iterator-&gt;TState = ObjectWaiter::TS_CXQ ;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                ObjectWaiter * Front = _cxq ;</span><br><span class="line">                iterator-&gt;_next = Front ;</span><br><span class="line">                <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (iterator, &amp;_cxq, Front) == Front) &#123;</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">if</span> (Policy == <span class="number">3</span>) &#123;      <span class="comment">// append to cxq</span></span><br><span class="line">        iterator-&gt;TState = ObjectWaiter::TS_CXQ ;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            ObjectWaiter * Tail ;</span><br><span class="line">            Tail = _cxq ;</span><br><span class="line">            <span class="keyword">if</span> (Tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                iterator-&gt;_next = <span class="literal">NULL</span> ;</span><br><span class="line">                <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (iterator, &amp;_cxq, <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                   <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (Tail-&gt;_next != <span class="literal">NULL</span>) Tail = Tail-&gt;_next ;</span><br><span class="line">                Tail-&gt;_next = iterator ;</span><br><span class="line">                iterator-&gt;_prev = Tail ;</span><br><span class="line">                iterator-&gt;_next = <span class="literal">NULL</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ParkEvent * ev = iterator-&gt;_event ;</span><br><span class="line">        iterator-&gt;TState = ObjectWaiter::TS_RUN ;</span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">        ev-&gt;<span class="built_in">unpark</span>() ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (Policy &lt; <span class="number">4</span>) &#123;</span><br><span class="line">       iterator-&gt;<span class="built_in">wait_reenter_begin</span>(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// _WaitSetLock protects the wait queue, not the EntryList.  We could</span></span><br><span class="line">     <span class="comment">// move the add-to-EntryList operation, above, outside the critical section</span></span><br><span class="line">     <span class="comment">// protected by _WaitSetLock.  In practice that&#x27;s not useful.  With the</span></span><br><span class="line">     <span class="comment">// exception of  wait() timeouts and interrupts the monitor owner</span></span><br><span class="line">     <span class="comment">// is the only thread that grabs _WaitSetLock.  There&#x27;s almost no contention</span></span><br><span class="line">     <span class="comment">// on _WaitSetLock so it&#x27;s not profitable to reduce the length of the</span></span><br><span class="line">     <span class="comment">// critical section.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread::<span class="built_in">SpinRelease</span> (&amp;_WaitSetLock) ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iterator != <span class="literal">NULL</span> &amp;&amp; ObjectMonitor::_sync_Notifications != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     ObjectMonitor::_sync_Notifications-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="锁升级与偏向锁"><a class="markdownIt-Anchor" href="#锁升级与偏向锁"></a> 锁升级与偏向锁</h3>
<p>随着JDK版本的不断更迭，底层对于synchronized关键字的实现方式也不断地在进行调整。在JDK1.5之前，要实现线程同步，只能通过synchronized关键字来实现，Java底层也是通过synchronized关键字来做到数据的原子性维护，synchronized关键字是JVM实现的一种内置锁，从底层角度来说，这种锁的获取与释放都是由JVM帮助我们隐式实现的。从JDK1.5开始，并发包引入了Lock锁，Lock同步锁是基于Java来实现的，因此锁的获取与释放都是通过Java代码来实现与控制的，synchronized是基于底层操作系统Mutex Lock来实现的，每次对锁的获取与释放动作都会带来用户态与内核态之间的切换，这种切换会极大的增加系统的负担。在并发量较高时，也就是说锁的竞争比较激烈的时候，synchronized锁在性能上的表现就非常差。</p>
<p>从JDK1.6开始，synchronized锁的实现发生了很大的变化，JVM引入了相应的优化手段来提升synchronized锁的性能，这种提升涉及到偏向锁、轻量级锁、重量级锁等，从而减少锁的竞争锁带来的用户态与内核态之前的切换，这种锁的优化是通过Java对象头中的一些标志位来去实现的。对于锁的访问与改变，实际上都与Java对象头息息相关。</p>
<p>从JDK1.6开始，对象实例在堆当中会被划分为三个组成部分：对象头、实例数据与对齐填充。</p>
<p>对象头主要由3块内容来构成：</p>
<ol>
<li>Mark Word</li>
<li>指向类的指针</li>
<li>数组的长度</li>
</ol>
<p>其中Mark Word （它记录了对象、锁及垃圾回收相关的信息，在64位的JVM中，其长度也是64bit）的位信息包括了如下的组成部分：</p>
<ol>
<li>无锁标记</li>
<li>偏向锁标记</li>
<li>轻量级锁标记</li>
<li>重量级锁标记</li>
<li>GC标记</li>
</ol>
<p>对于synchronized锁来说，锁的升级主要是通过Mark Word中的锁的标志位与是否是偏向锁标志位来达成的；synchronized关键字锁对应的锁都是从偏向锁开始，随着锁竞争的不断升级，逐步演化至轻量级锁，最后则变成了重量级锁。</p>
<p>对于锁的演化来说，它会经历如下阶段：</p>
<p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>
<p>偏向锁：针对于一个线程来说，它的作用就是优化同一个线程多次获取一个锁的情况；如果一个synchronized方法被一个线程访问，那么这个方法所在的对象就会在其Mark Word中将偏向锁进行标记，同时还会有一个字段来存储该线程的ID；当这个线程再次访问同一个synchronized方法时，它会检查这个对象的Mark Word的偏向锁标记以及是否指向了其线程ID，如果是的话，那么该线程就无需进行管程（Monitor）了，而是直接进入到该方法体中。如果是另外一个线程访问这个synchronized方法，那么偏向锁的标记就会被去掉。</p>
<p>轻量级锁：若第一个线程已经获取到了当前对象的锁，这是第二个线程又开始尝试争抢该对象的锁，由于该对象的锁已经被第一个线程获取到，因此它是偏向锁，而第二个线程在争抢时，会发现该对象头中的Mark Word已经是偏向锁，但里面存储的线程ID不是自己（第一个线程），那么它会进行CAS（Compare and Swap），从而获取到锁，这里面存在两种情况：</p>
<ol>
<li>获取锁成功，那么它会直接将Mark Word中的线程ID由第一个线程变成自己（偏向锁标记位保持不变），这样该对象依然会保持偏向锁的状态</li>
<li>获取锁失败，表示这时可能会有多个线程同时在尝试争抢该对象的锁，那么这时偏向锁会进行升级，升级为轻量级锁</li>
</ol>
<p>自旋锁：若自旋失败（依然无法获取到锁），那么锁就会转化为重量级锁，在这种情况下，无法获取到锁的线程都会进入到Monitor（即内核态）。自旋最大的一个特点就是避免了线程从用户态进入到内核态。</p>
<p>重量级锁：线程最终从用户态进入到了内核态。</p>
<h3 id="锁粗化与锁消除"><a class="markdownIt-Anchor" href="#锁粗化与锁消除"></a> 锁粗化与锁消除</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器对于锁的优化措施：JIT编译器（Just In Time编译器）可以在动态编译同步代码时，使用一种叫做逃逸分析的技术，来通过该项技术判别程序中所使用的锁对象是否只被一个线程所使用，而没有散布到其他线程当中，如果情况就是这样的话，那么JIT编译器在编译这个同步代码时就不会生成synchronized关键字所标识的锁的申请与释放机器码，从而消除了锁的使用流程，这就是锁的消除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果object是成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest6</span> </span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下就发生了：锁粗化，JIT编译器在执行动态编译时，若发现前后相邻的synchronized块使用的是同一个锁对象，那么它就会把这几个synchronized块合并为一个较大的同步块，这样做的好处在于线程在执行这些代码的时候，就无需频繁的申请与释放锁了，从而达到申请与释放锁一次，就可以执行完全部的同步代码块，从而提升了性能。</p>
<h3 id="死锁及死锁检测"><a class="markdownIt-Anchor" href="#死锁及死锁检测"></a> 死锁及死锁检测</h3>
<ul>
<li>死锁：线程1等待线程2互斥持有的资源，而线程2也在等待线程1互斥持有的资源，两个线程都无法继续执行；</li>
<li>活锁：线程持续重试一个总是失败的操作，导致无法继续执行；</li>
<li>饿死：线程一直被调度器延迟访问其赖以执行的资源，也许是调度器先于低优先级的线程而执行高优先级的线程，同时总是会有一个高优先级的线程可以执行，饿死也叫做无限延迟。</li>
</ul>
<p>首先来看一下可能会发生死锁的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest7</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;myMethod1 invoked&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;myMethod2 invoked&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTest7 myTest7 = <span class="keyword">new</span> MyTest7();</span><br><span class="line">        Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                myTest7.method1();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable1, <span class="string">&quot;myThread1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                myTest7.method2();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable2, <span class="string">&quot;myThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序在运行一段时间之后就发生死锁的现象，发生死锁之后可以使用JVM自带的一些工具来进行检测。</p>
<p>首先是jvisualvm:</p>
<p><img src="./assets/1605541454922.png" alt="1605541454922" /></p>
<p>可以看到，已经检测到死锁的情况，点击线程Dump可以查看详情。</p>
<p><img src="./assets/1605541658677.png" alt="1605541658677" /></p>
<p>除了使用可视化界面之外，也可以使用命令行的工具来进行检测死锁：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\code\java8\jyc&gt;jps -l</span><br><span class="line">9104</span><br><span class="line">12212 concurrency2.MyTest7</span><br><span class="line">11656 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">16428 org.gradle.launcher.daemon.bootstrap.GradleDaemon</span><br><span class="line">3468 sun.tools.jps.Jps</span><br></pre></td></tr></table></figure>
<p>可以看到运行我们程序的进行号为12212，继续使用jstack来查看当前线程的执行详情：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\code\java8\jyc&gt;jstack 12212</span><br><span class="line">2020-11-16 23:50:41</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.212-b10 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;JMX server connection timeout 18&quot; #18 daemon prio=5 os_prio=0 tid=0x0000000019fca800 nid=0x25ec in Object.wait() [0x000000001b9de000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        at com.sun.jmx.remote.internal.ServerCommunicatorAdmin$Timeout.run(ServerCommunicatorAdmin.java:168)</span><br><span class="line">        - locked &lt;0x00000000d8408178&gt; (a [I)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;RMI Scheduler(0)&quot; #17 daemon prio=5 os_prio=0 tid=0x0000000019fc9800 nid=0x36a0 waiting on condition [0x000000001b8df000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait for  &lt;0x00000000d8410188&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)</span><br><span class="line">        at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1093)</span><br><span class="line">        at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;RMI TCP Accept-0&quot; #15 daemon prio=5 os_prio=0 tid=0x0000000019f5f000 nid=0x4270 runnable [0x000000001b6df000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.accept0(Native Method)</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.socketAccept(DualStackPlainSocketImpl.java:131)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)</span><br><span class="line">        at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:199)</span><br><span class="line">        - locked &lt;0x00000000d84182b0&gt; (a java.net.SocksSocketImpl)</span><br><span class="line">        at java.net.ServerSocket.implAccept(ServerSocket.java:545)</span><br><span class="line">        at java.net.ServerSocket.accept(ServerSocket.java:513)</span><br><span class="line">        at sun.management.jmxremote.LocalRMIServerSocketFactory$1.accept(LocalRMIServerSocketFactory.java:52)</span><br><span class="line">        at sun.rmi.transport.tcp.TCPTransport$AcceptLoop.executeAcceptLoop(TCPTransport.java:405)</span><br><span class="line">        at sun.rmi.transport.tcp.TCPTransport$AcceptLoop.run(TCPTransport.java:377)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;DestroyJavaVM&quot; #13 prio=5 os_prio=0 tid=0x0000000002a6e000 nid=0x19c0 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;myThread2&quot; #12 prio=5 os_prio=0 tid=0x000000001a17e000 nid=0x3290 waiting for monitor entry [0x000000001b58f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at concurrency2.MyTest7.method2(MyTest7.java:23)</span><br><span class="line">        - waiting to lock &lt;0x00000000d84202f0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d8420300&gt; (a java.lang.Object)</span><br><span class="line">        at concurrency2.MyTest7.lambda$main$1(MyTest7.java:44)</span><br><span class="line">        at concurrency2.MyTest7$$Lambda$2/1418481495.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;myThread1&quot; #11 prio=5 os_prio=0 tid=0x000000001a17d800 nid=0x3b8c waiting for monitor entry [0x000000001b48f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at concurrency2.MyTest7.method1(MyTest7.java:15)</span><br><span class="line">        - waiting to lock &lt;0x00000000d8420300&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d84202f0&gt; (a java.lang.Object)</span><br><span class="line">        at concurrency2.MyTest7.lambda$main$0(MyTest7.java:32)</span><br><span class="line">        at concurrency2.MyTest7$$Lambda$1/471910020.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;Service Thread&quot; #10 daemon prio=9 os_prio=0 tid=0x0000000019ebf000 nid=0x3194 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C1 CompilerThread3&quot; #9 daemon prio=9 os_prio=2 tid=0x0000000019e28800 nid=0x48c0 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread2&quot; #8 daemon prio=9 os_prio=2 tid=0x0000000019e28000 nid=0x219c waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread1&quot; #7 daemon prio=9 os_prio=2 tid=0x0000000019e26800 nid=0x39c waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread0&quot; #6 daemon prio=9 os_prio=2 tid=0x0000000019e1f800 nid=0x22c waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #5 daemon prio=5 os_prio=2 tid=0x0000000019e1d800 nid=0x898 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=2 tid=0x0000000019e1c800 nid=0x3174 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 tid=0x0000000019db1000 nid=0x40e4 in Object.wait() [0x000000001a38e000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)</span><br><span class="line">        - locked &lt;0x00000000d84385e8&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)</span><br><span class="line">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)</span><br><span class="line"></span><br><span class="line">&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 tid=0x0000000019db0800 nid=0x23e4 in Object.wait() [0x000000001a28e000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">        - locked &lt;0x00000000d8430758&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line">&quot;VM Thread&quot; os_prio=2 tid=0x0000000017fb8800 nid=0x1f84 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x0000000003008000 nid=0x2d74 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x0000000003009800 nid=0x5374 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#2 (ParallelGC)&quot; os_prio=0 tid=0x000000000300b000 nid=0x21ec runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#3 (ParallelGC)&quot; os_prio=0 tid=0x000000000300c800 nid=0x4064 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#4 (ParallelGC)&quot; os_prio=0 tid=0x000000000300f000 nid=0x234c runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#5 (ParallelGC)&quot; os_prio=0 tid=0x0000000003011000 nid=0x2ea8 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#6 (ParallelGC)&quot; os_prio=0 tid=0x0000000003014000 nid=0x14a0 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#7 (ParallelGC)&quot; os_prio=0 tid=0x0000000003015800 nid=0x39d4 runnable</span><br><span class="line"></span><br><span class="line">&quot;VM Periodic Task Thread&quot; os_prio=2 tid=0x0000000019ed4000 nid=0x1d40 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 232</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到一个Java级别的死锁</span></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;myThread2&quot;:</span><br><span class="line">  waiting to lock monitor 0x00000000030ee6c8 (object 0x00000000d84202f0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;myThread1&quot;</span><br><span class="line">&quot;myThread1&quot;:</span><br><span class="line">  waiting to lock monitor 0x00000000030ed228 (object 0x00000000d8420300, a java.lang.Object),</span><br><span class="line">  which is held by &quot;myThread2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;myThread2&quot;:</span><br><span class="line">        at concurrency2.MyTest7.method2(MyTest7.java:23)</span><br><span class="line">        - waiting to lock &lt;0x00000000d84202f0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d8420300&gt; (a java.lang.Object)</span><br><span class="line">        at concurrency2.MyTest7.lambda$main$1(MyTest7.java:44)</span><br><span class="line">        at concurrency2.MyTest7$$Lambda$2/1418481495.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;myThread1&quot;:</span><br><span class="line">        at concurrency2.MyTest7.method1(MyTest7.java:15)</span><br><span class="line">        - waiting to lock &lt;0x00000000d8420300&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d84202f0&gt; (a java.lang.Object)</span><br><span class="line">        at concurrency2.MyTest7.lambda$main$0(MyTest7.java:32)</span><br><span class="line">        at concurrency2.MyTest7$$Lambda$1/471910020.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>
<h1 id="java并发包核心"><a class="markdownIt-Anchor" href="#java并发包核心"></a> Java并发包核心</h1>
<h2 id="lock"><a class="markdownIt-Anchor" href="#lock"></a> Lock</h2>
<h3 id="锁的机制与原理"><a class="markdownIt-Anchor" href="#锁的机制与原理"></a> 锁的机制与原理</h3>
<p>Lock是非常重要的顶级接口，接下来我们阅读一下关于它的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock implementations provide more extensive locking operations than can be obtained using synchronized </span><br><span class="line">methods and statements. They allow more flexible structuring, may have quite different properties, and </span><br><span class="line">may support multiple associated Condition objects.</span><br></pre></td></tr></table></figure>
<p>Lock实现了要比使用synchronized关键字修饰的方法及语句用途更为广泛的锁的操作，它们支持更为灵活的结构化，拥有很多不同的属性，支持多种相关联的Condition对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A lock is a tool for controlling access to a shared resource by multiple threads. Commonly, a lock </span><br><span class="line">provides exclusive access to a shared resource: only one thread at a time can acquire the lock and all </span><br><span class="line">access to the shared resource requires that the lock be acquired first. However, some locks may allow </span><br><span class="line">concurrent access to a shared resource, such as the read lock of a ReadWriteLock.</span><br></pre></td></tr></table></figure>
<p>锁是一种多个线程对于一个共享资源的访问，通常情况下，一个锁会对共享资源提供一种排它性的访问，这意味着在同一个时刻，只能有一个线程获取到锁，其他线程必须要先获取到锁才能访问共享资源。然而，某些锁可以对于共享资源的并发访问，比如读锁中的ReadWriteLock（读写锁）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The use of synchronized methods or statements provides access to the implicit monitor lock associated </span><br><span class="line">with every object, but forces all lock acquisition and release to occur in a block-structured way: when </span><br><span class="line">multiple locks are acquired they must be released in the opposite order, and all locks must be released </span><br><span class="line">in the same lexical scope in which they were acquired.</span><br></pre></td></tr></table></figure>
<p>使用synchronized方法或者synchronized代码块提供了对于每一个对象的所关联的隐式的monitor对象的访问，但是它会强制所有锁的获取和释放都发生在块结构的方式中，当多个锁被获取的时候，必须要以相反的顺序释放，而且所有的锁必须以获取的相同的作用域释放掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">While the scoping mechanism for synchronized methods and statements makes it much easier to program with monitor locks, and helps avoid many common programming errors involving locks, there are occasions where you need to work with locks in a more flexible way. For example, some algorithms for traversing concurrently accessed data structures require the use of &quot;hand-over-hand&quot; or &quot;chain locking&quot;: you acquire the lock of node A, then node B, then release A and acquire C, then release B and acquire D and so on. Implementations of the Lock interface enable the use of such techniques by allowing a lock to be acquired and released in different scopes, and allowing multiple locks to be acquired and released in any order.</span><br></pre></td></tr></table></figure>
<p>虽然synchronized方法和代码块的作用域使得我们对于monitor锁的编程更加轻松，而且还会避免与锁相关的编码错误，但是存在一些场景，需要更加灵活的处理锁，比如某些算法需要并发的遍历被访问的数据结构，他们需要需要使用hand-over-hand或者chain locking：你需要首先获取到node A的锁，然后是node B的锁，紧接着释放A，然后获取到C，然后释放掉B，然后获取到D等等，Lock接口的实现使得这种技术的使用成为可能，它可以使得锁的获取和释放不在同一个作用域，也可以不再按照顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">With this increased flexibility comes additional responsibility. The absence of block-structured locking </span><br><span class="line">removes the automatic release of locks that occurs with synchronized methods and statements. In most </span><br><span class="line">cases, the following idiom should be used:</span><br></pre></td></tr></table></figure>
<p>但是如果我们不使用这种块结构的锁的话，就没法再使用synchronized提供的自动释放锁的功能，在大多数情况下按照如下的方式使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock l = ...;</span><br><span class="line"> l.lock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// access the resource protected by this lock</span></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   l.unlock();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">When locking and unlocking occur in different scopes, care must be taken to ensure that all code that is </span><br><span class="line">executed while the lock is held is protected by try-finally or try-catch to ensure that the lock is </span><br><span class="line">released when necessary.</span><br></pre></td></tr></table></figure>
<p>当加锁和解锁出现在不同的作用域当中，我们必须要非常小心的确保被执行的所有的代码都是在try-finally 或者try-catch的保护当中，从而保证锁在必要的时候可以被释放掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock implementations provide additional functionality over the use of synchronized methods and </span><br><span class="line">statements by providing a non-blocking attempt to acquire a lock (tryLock()), an attempt to acquire the </span><br><span class="line">lock that can be interrupted (lockInterruptibly, and an attempt to acquire the lock that can timeout </span><br><span class="line">(tryLock(long, TimeUnit)).</span><br></pre></td></tr></table></figure>
<p>Lock的实现相比于synchronized方法和语句的实现提供了一些额外的功能，它是通过一种非阻塞的方式获取到锁，并且还提供了获取锁的操作是可以被中断的，可以设置锁的超时时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Lock class can also provide behavior and semantics that is quite different from that of the implicit </span><br><span class="line">monitor lock, such as guaranteed ordering, non-reentrant usage, or deadlock detection. If an </span><br><span class="line">implementation provides such specialized semantics then the implementation must document those </span><br><span class="line">semantics.</span><br></pre></td></tr></table></figure>
<p>一个Lock的类还可以提供一些与隐式的monitor锁的完全不同的行为和语义，比如可以确保顺序性、可重入的使用或者死锁检测。如果一种实现实现了这种特殊的语气，那么实现就必须将这个语义清楚的记录下来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Note that Lock instances are just normal objects and can themselves be used as the target in a </span><br><span class="line">synchronized statement. Acquiring the monitor lock of a Lock instance has no specified relationship with</span><br><span class="line">invoking any of the lock methods of that instance. It is recommended that to avoid confusion you never</span><br><span class="line">use Lock instances in this way, except within their own implementation.</span><br></pre></td></tr></table></figure>
<p>Lock实例仅仅是一个普通的对象而已，它们本身也可以被synchronized语句修饰，因为每个对象都会有一个与之相关的monitor存在，对于Lock实例对象也不例外，获取到Lock实例的monitor锁，与调用这个Lock方法之间没有什么特殊的关联关系。换言之，我们如果将一个Lock实例作为synchronized使用的对象的话，JVM会获取到Lock实例的monitor对象，它与Lock是两个层面的东西，推荐的做法是避免这种混淆，除了在它们自己的底层实现当中，永远不要通过这种方式使用Lock实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">All Lock implementations must enforce the same memory synchronization semantics as provided by the built-in monitor lock, as described in The Java Language Specification (17.4 Memory Model) :</span><br></pre></td></tr></table></figure>
<p>所有的Lock的实现都必须强制与内建的monitor锁的内存同步语义是一致的，这一点是在Java语言规范中明确的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A successful lock operation has the same memory synchronization effects as a successful Lock action.</span><br><span class="line">A successful unlock operation has the same memory synchronization effects as a successful Unlock action.</span><br></pre></td></tr></table></figure>
<ul>
<li>一个成功的加锁的操作与成功的synchronization拥有相同的同步效果</li>
<li>一个成功的释放锁的操作与成功的synchronization拥有相同的释放锁的效果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unsuccessful locking and unlocking operations, and reentrant locking/unlocking operations, do not require any memory synchronization effects.</span><br></pre></td></tr></table></figure>
<p>（可重入的）加锁和释放锁不成功的操作，它们是不要求任何的内存同步的效果的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The three forms of lock acquisition (interruptible, non-interruptible, and timed) may differ in their performance </span><br><span class="line">characteristics, ordering guarantees, or other implementation qualities.</span><br></pre></td></tr></table></figure>
<p>获取lock的三种方式（可中断的，非可中断的，基于时间的）在性能上、顺序上的保证还有一些其他的特性上可能有所不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Further, the ability to interrupt the ongoing acquisition of a lock may not be available in a given Lock class. Consequently, </span><br><span class="line">an implementation is not required to define exactly the same guarantees or semantics for all three forms of lock acquisition, </span><br><span class="line">nor is it required to support interruption of an ongoing lock acquisition. An implementation is required to clearly document </span><br><span class="line">the semantics and guarantees provided by each of the locking methods. It must also obey the interruption semantics as defined </span><br><span class="line">in this interface, to the extent that interruption of lock acquisition is supported: which is either totally, or only on </span><br><span class="line">method entry.</span><br></pre></td></tr></table></figure>
<p>进一步而言，这种能力可以中断锁获取可能不在给定的lock类当中，因此一种实现并不要求精确的定义相同的这种语义针对于这三种实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor </span><br><span class="line">responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after </span><br><span class="line">another action may have unblocked the thread. An implementation should document this behavior.</span><br></pre></td></tr></table></figure>
<p>由于中断通常意味着取消，因此检查这个中断通常不是一个频繁的操作，实现可以对一个中断进行响应，而不是等待一个正常的方法的返回。即便中断可能出现在另外一个动作之后有可能解锁这个线程，实现应该将这种行为记录下来。</p>
<p>以上是Lock接口的说明，接下来我们了解一下其中部分的核心方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Acquires the lock.</span><br><span class="line">If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until </span><br><span class="line">the lock has been acquired.</span><br></pre></td></tr></table></figure>
<p>该方法用于获取到锁，如果获取不到锁，当前的线程将会无法被用于线程调度，线程会进入睡眠状态，直到获取到锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Lock implementation may be able to detect erroneous use of the lock, such as an invocation that would cause deadlock, and </span><br><span class="line">may throw an (unchecked) exception in such circumstances. The circumstances and the exception type must be documented by that</span><br><span class="line">Lock implementation.</span><br></pre></td></tr></table></figure>
<p>Lock实现可以检测锁的错误的使用，比如可能导致死锁的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Acquires the lock unless the current thread is interrupted.</span><br><span class="line">Acquires the lock if it is available and returns immediately.</span><br><span class="line">If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</span><br></pre></td></tr></table></figure>
<p>如果当前线程没有被中断就尝试获取到锁。如果锁是可以获取，就会立刻返回。如果这个锁是不可用的，那么当前线程也无法进行调度，而且会陷入到睡眠状态，直到下面两种情况发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The lock is acquired by the current thread; or</span><br><span class="line">Some other thread interrupts the current thread, and interruption of lock acquisition is supported.</span><br></pre></td></tr></table></figure>
<ul>
<li>当前线程获取到锁</li>
<li>其他的线程中断了当前线程，而且锁获取的过程的是支持的中断的</li>
</ul>
<p>如果当前线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">has its interrupted status set on entry to this method; or</span><br><span class="line">is interrupted while acquiring the lock, and interruption of lock acquisition is supported,</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个方法的入口中拥有自己的被中断的状态</li>
<li>在获取锁的过程被中断了，并且这种在获取锁的时候的中断是被支持的</li>
</ul>
<p>那么 InterruptedException 会被抛出，并且当前线程的状态会被清理掉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Acquires the lock only if it is free at the time of invocation.</span><br><span class="line">Acquires the lock if it is available and returns immediately with the value true. If the lock is not available then this </span><br><span class="line">method will return immediately with the value false.</span><br><span class="line">A typical usage idiom for this method would be:</span><br></pre></td></tr></table></figure>
<p>调用的时候，只有当可以获取的锁的时候，才获取到锁。如果获取可以获取到锁，就会立刻返回true，如果获取不到，就会立刻返回false，一中典型的使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"> <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// manipulate protected state</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// perform alternative actions</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This usage ensures that the lock is unlocked if it was acquired, and doesn&#x27;t try to unlock if the lock was not acquired.</span><br></pre></td></tr></table></figure>
<p>这种用法可以保证如果锁被获取了，那么锁是会被释放掉的，如果没有获取到锁，就不用去释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>这是另外一个重载的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Acquires the lock if it is free within the given waiting time and the current thread has not been interrupted.</span><br><span class="line">If the lock is available this method returns immediately with the value true. If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</span><br></pre></td></tr></table></figure>
<p>在给定的等待时间之内，如果线程没有被中断并且锁是可以获取的，那么就获取到锁。如果锁拿到了，就会立刻返回true，如果没有获取到，那么线程就无法再进行调度，进入睡眠状态，直到如下三种情况发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The lock is acquired by the current thread; or</span><br><span class="line">Some other thread interrupts the current thread, and interruption of lock acquisition is supported; or</span><br><span class="line">The specified waiting time elapses</span><br></pre></td></tr></table></figure>
<ul>
<li>当前线程获取到了锁</li>
<li>其他线程中断了当前的线程，并且在锁获取的过程中，中断是被支持的</li>
<li>指定的时间到了</li>
</ul>
<p>如果获取到了锁则立刻返回true，如果当前线程被中断了，并且这种中断是被允许的，那么：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">then InterruptedException is thrown and the current thread&#x27;s interrupted status is cleared.</span><br><span class="line">If the specified waiting time elapses then the value false is returned. If the time is less than or equal to zero, the method will not wait at all.</span><br></pre></td></tr></table></figure>
<p>当前线程就会抛出InterruptedException，并且当前线程的状态也会被清理掉。如果过了指定的时间，那么就会返回false，如果指定时间小于或者等于0，那么这个方法就会做任何的等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Lock implementation will usually impose restrictions on which thread can release a lock (typically only the holder of the lock can release it) and may throw an (unchecked) exception if the restriction is violated. Any restrictions and the exception type must be documented by that Lock implementation.</span><br></pre></td></tr></table></figure>
<p>该方法用来释放掉锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a new Condition instance that is bound to this Lock instance.</span><br><span class="line">Before waiting on the condition the lock must be held by the current thread. A call to Condition.await() will atomically release the lock before waiting and re-acquire the lock before the wait returns.</span><br></pre></td></tr></table></figure>
<p>它会返回一个新的绑定到当前Lock上的Condition实例，在等待condition之前，当前线程必须持有锁，调用Condition.await()会自动地释放掉锁。</p>
<p>接下来我们看一个有关于锁的使用的实际案例。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;myMethod1 invoked&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果注释掉这行代码，程序仍然可以访问到此线程的锁，即上一行的输出会打印，但myMethod2因为获取不到锁，因此不会执行。</span></span><br><span class="line">            <span class="comment">// lock.unlock();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;myMethod2 invoked&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTest1 myTest1 = <span class="keyword">new</span> MyTest1();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                myTest1.myMethod1();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                myTest1.myMethod2();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对myMethod2进行一定的改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.tryLock(<span class="number">800</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序就可以正常的往下执行，可以看出Lock为我们提供了一种更为优雅的方式来获取锁，本小节的最后，我们对于Lock和synchronized关键字的区别进行归纳总结。</p>
<ol>
<li>锁的获取方式：Lock是通过程序代码的方式由开发者手工获取，而synchronized是通过JVM来获取的（无需开发者干预）。</li>
<li>具体的实现方式：Lock是通过Java代码的方式来实现，synchronized是通过JVM底层来实现（无需开发者关注）。</li>
<li>锁的释放方式：Lock务必通过unlock()方法在finally块中手工释放，synchronized是通过JVM来释放（无需开发者关注）。</li>
<li>锁的具体类型：Lock提供了多种，如公平锁、非公平锁，synchronized与Lock都提供了可重入锁。</li>
</ol>
<h3 id="condition简介"><a class="markdownIt-Anchor" href="#condition简介"></a> Condition简介</h3>
<p>在Lock接口中，有一个方法的返回值是Condition，在之前的例子中，我们可以通过sychronized+wait+notify/notifyAll来实现多个线程之间的协调与通信，整个过程都是由JVM来帮助我们实现的，开发者无需（也无法）了解底层的实现细节，从JDK5开始，并发包提供了Lock，Condition(await与signal/signalAll)来实现多个线程之间的协调与通信，整个过程都是由开发者来控制的，相比于传统的方式，更加的灵活，功能也更加强大。接下来我们就来了解一下这个接口的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to </span><br><span class="line">give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary </span><br><span class="line">Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition</span><br><span class="line">replaces the use of the Object monitor methods.</span><br></pre></td></tr></table></figure>
<p>Condition本质上类似于Object对象的监控器的方法（wait,notify和notifyAll），可以让各种不同的对象拥有多个等待集合，是通过使用任意的一个Lock的实现将他们组合起来，我们会使用Lock来替代synchronized方法和代码块的使用，Condition来替换Object对象中的监控器方法的使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Conditions (also known as condition queues or condition variables) provide a means for one thread to </span><br><span class="line">suspend execution (to &quot;wait&quot;) until notified by another thread that some state condition may now be </span><br><span class="line">true. Because access to this shared state information occurs in different threads, it must be protected,</span><br><span class="line">so a lock of some form is associated with the condition. The key property that waiting for a condition</span><br><span class="line">provides is that it atomically releases the associated lock and suspends the current thread, just like </span><br><span class="line">Object.wait.</span><br></pre></td></tr></table></figure>
<p>Conditions(也叫做条件队列或者条件变量)提供了一种让一个线程可以挂起执行（让线程进入等待状态）直到另外一个condition为true的线程通知当前线程的方式，由于对于共享的状态信息的访问是发生在不同的线程当中的，因此它必须受到保护，即Lock就一定要关联到一个某个Condition上面，一个关键的属性是，它会自动的释放掉关联的锁然后挂起当前的线程，就行Object.wait方法一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Condition instance is intrinsically bound to a lock. To obtain a Condition instance for a particular Lock instance use its newCondition() method.</span><br></pre></td></tr></table></figure>
<p>一个Condition实例会被天然的绑定到一个lock上面，要想获得一个特定的Lock实例对应的Condition实例的话，需要使用newCondition()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">As an example, suppose we have a bounded buffer which supports put and take methods. If a take is </span><br><span class="line">attempted on an empty buffer, then the thread will block until an item becomes available; if a put is </span><br><span class="line">attempted on a full buffer, then the thread will block until a space becomes available. We would like to </span><br><span class="line">keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of </span><br><span class="line">only notifying a single thread at a time when items or spaces become available in the buffer. This can </span><br><span class="line">be achieved using two Condition instances.</span><br></pre></td></tr></table></figure>
<p>举个例子，加我们我们有一个有界的缓冲区，支持put和take方法，如果一个take尝试从空的缓冲区获取元素就会被阻塞，直到缓冲区中有新的元素，如果一个put尝试向一个满的缓冲区中添加元素，这个线程也会被阻塞，直到有可用的空闲空间为止，我们将会让等待的put线程和take线程放置在两个等待集合当中，这样我们就可以在条目存在或者空间存在的时候，只通知一个线程，这个是可以通过使用两个Condition实例来做到的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">  <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        notFull.await();</span><br><span class="line">      items[putptr] = x;</span><br><span class="line">      <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">      ++count;</span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      Object x = items[takeptr];</span><br><span class="line">      <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">      --count;</span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Condition implementation can provide behavior and semantics that is different from that of the Object </span><br><span class="line">monitor methods, such as guaranteed ordering for notifications, or not requiring a lock to be held when</span><br><span class="line">performing notifications. If an implementation provides such specialized semantics then the </span><br><span class="line">implementation must document those semantics.</span><br></pre></td></tr></table></figure>
<p>Condition实现可以提供与Object的monitor方法是不一样的行为，比如对于通知的确定性的排序，或者在执行通知的时候不要求持有锁，如果某一个实现提供了这样一些专门化的语义，在实现的时候，需要在文档当中记录下来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Note that Condition instances are just normal objects and can themselves be used as the target in a </span><br><span class="line">synchronized statement, and can have their own monitor wait and notification methods invoked. Acquiring</span><br><span class="line">the monitor lock of a Condition instance, or using its monitor methods, has no specified relationship </span><br><span class="line">with acquiring the Lock associated with that Condition or the use of its waiting and signalling methods. </span><br><span class="line">It is recommended that to avoid confusion you never use Condition instances in this way, except perhaps</span><br><span class="line">within their own implementation.</span><br></pre></td></tr></table></figure>
<p>注意Condition实例仅仅就是一个普通的obeject对象，它们自己也可以使用sychronized代码块当中，并且拥有自己的monitor方法，比如wait和notification方法。使用Condition实例获取锁对象，其中的waiting和signalling方法与monitor对象中的方法是没有任何关系的，推荐的做法是避免这种混淆，永远不应该在除了内部实现的地方外使用这种方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">When waiting upon a Condition, a &quot;spurious wakeup&quot; is permitted to occur, in general, as a concession to the underlying </span><br><span class="line">platform semantics. This has little practical impact on most application programs as a Condition should always be waited upon </span><br><span class="line">in a loop, testing the state predicate that is being waited for. An implementation is free to remove the possibility of </span><br><span class="line">spurious wakeups but it is recommended that applications programmers always assume that they can occur and so always wait in a </span><br><span class="line">loop.</span><br></pre></td></tr></table></figure>
<p>当我们在等待一个Condition为真的时候，一个假的唤醒是允许发生的，通常情况下，作为平台的一种底层的语义，这种对于大多数的程序不会产生什么实际的影响，因为Condition总是在一个while循环当中去等待，去测试这个被唤醒的条件是否被满足了。实现可以自由的移除这种假的唤醒的可能性，但是推荐的做法是开发者确保程序总是能够执行的并且总是放在循环当中的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The three forms of condition waiting (interruptible, non-interruptible, and timed) may differ in their ease of implementation</span><br><span class="line">on some platforms and in their performance characteristics. In particular, it may be difficult to provide these features and </span><br><span class="line">maintain specific semantics such as ordering guarantees. Further, the ability to interrupt the actual suspension of the thread </span><br><span class="line">may not always be feasible to implement on all platforms.</span><br></pre></td></tr></table></figure>
<p>三种Condition等待的方式（可中断的、不可中断的、基于时间的）在不同的平台上的实现和性能是不一样的，特别的，我们很难去提供这些特性，并且维护具体的语义，比如说排序的保证，更进一步，这种中断进程的挂起实际是要想在所有平台都实现是难做到非常灵活的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of </span><br><span class="line">waiting, nor is it required to support interruption of the actual suspension of the thread</span><br></pre></td></tr></table></figure>
<p>因此，一个实现针对于这几种方式的等待并不要求精确的定义相同的语义或者相同的保证，同样的，也不要求线程实际的挂起的中断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An implementation is required to clearly document the semantics and guarantees provided by each of the waiting methods, and when an implementation does support interruption of thread suspension then it must obey the interruption semantics as defined in this interface.</span><br></pre></td></tr></table></figure>
<p>实现可以被要求清晰的定义这些语义和保证由每一个等待方法，当一个实现并不支持线程中断的话，必须要遵循定义在这个接口中中断的语义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor </span><br><span class="line">responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after</span><br><span class="line">another action that may have unblocked the thread. An implementation should document this behavior.</span><br></pre></td></tr></table></figure>
<p>由于中断通常暗示着一种取消，因此检查这个中断不是一个频繁的操作，实现可以自由决定，它可以去响应中断，而非正常的这种方法返回，即便是中断是发生在另一个动作之后，实现需要把这个行为记录下来。</p>
<p>以上就是Condition类的所有的说明，接下来我们来阅读一下Condition接口中的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Causes the current thread to wait until it is signalled or interrupted.</span><br></pre></td></tr></table></figure>
<p>这个方法会使得当前线程进入等待状态，直到signal方法被调用或者被中断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling </span><br><span class="line">purposes and lies dormant until one of four things happens:</span><br></pre></td></tr></table></figure>
<p>调用了await方法之后，与Condition所关联的lock会被自动的释放，当前的线程将无法进行线程调度，并且进入休眠状态，直到下面的四种情况之一发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be </span><br><span class="line">awakened; or</span><br><span class="line">Some other thread invokes the signalAll method for this Condition; or</span><br><span class="line">Some other thread interrupts the current thread, and interruption of thread suspension is supported; or</span><br><span class="line">A &quot;spurious wakeup&quot; occurs.</span><br></pre></td></tr></table></figure>
<ul>
<li>另外一个线程调用了当前线程的signal方法，并且当前的线程恰好是被选中的线程；</li>
<li>另外一个线程调用了signalAll方法；</li>
<li>另外一个线程中断了当前的线程，并且线程是可以中断的；</li>
<li>虚假唤醒出现了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When </span><br><span class="line">the thread returns it is guaranteed to hold this lock.</span><br></pre></td></tr></table></figure>
<p>在以上的四种情况中，在调用了await方法能够返回之前，当前的线程必须要重新获取到与这个condition对应的lock。当线程返回的时候，我们可以保证获取到了lock。</p>
<p>如果当前的线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">has its interrupted status set on entry to this method; or</span><br><span class="line">is interrupted while waiting and interruption of thread suspension is supported,</span><br></pre></td></tr></table></figure>
<ul>
<li>当前的线程在进入到这个方法的时候，已经设置了中断的状态；</li>
<li>等待的时候被中断了，并且线程的中断是支持的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">then InterruptedException is thrown and the current thread&#x27;s interrupted status is cleared. It is not specified, in the first</span><br><span class="line">case, whether or not the test for interruption occurs before the lock is released.</span><br></pre></td></tr></table></figure>
<p>就会抛出InterruptedException异常，当前线程的状态也会被清理掉，在一种情况下，在释放锁之前，无论是否测试了中断，都是如此。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the </span><br><span class="line">implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as </span><br><span class="line">IllegalMonitorStateException) and the implementation must document that fact.</span><br></pre></td></tr></table></figure>
<p>当前线程在调用await方法的时候，被假定要持有与Condition相关联的锁，这个取决于具体的实现是否要满足这种条件，如果不满足，应该如何应对，典型的，可以抛出异常（IllegalMonitorStateException），实现必须要将这个情况记录下来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An implementation can favor responding to an interrupt over normal method return in response to a signal. In that case the </span><br><span class="line">implementation must ensure that the signal is redirected to another waiting thread, if there is one</span><br></pre></td></tr></table></figure>
<p>实现也可以选择去响应一个中断而不是通常的方法的返回，在这种情况下，如果有的另外一个线程，实现也必须signal会重定向到另外一个线程。</p>
<p>接下来是awaitUninterruptibly方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>awaitUninterruptibly方法会使得线程进入等待状态，直到下面三种情况之一发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or</span><br><span class="line">Some other thread invokes the signalAll method for this Condition; or</span><br><span class="line">A &quot;spurious wakeup&quot; occurs.</span><br></pre></td></tr></table></figure>
<p>与await方法唯一不同的是，这个方法并不回应中断。</p>
<p>接下来是awaitNanos方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses.</span><br></pre></td></tr></table></figure>
<p>调用awaitNanos，会导致当前的线程进入等待状态直到被signal或者被中断或者指定的时间已经过去了，直到下面五种情况有一个发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or</span><br><span class="line">Some other thread invokes the signalAll method for this Condition; or</span><br><span class="line">Some other thread interrupts the current thread, and interruption of thread suspension is supported; or</span><br><span class="line">The specified waiting time elapses; or</span><br><span class="line">A &quot;spurious wakeup&quot; occurs.</span><br></pre></td></tr></table></figure>
<p>可以看到与await方法不同的地方在于，指定的等待时间已经过去了，就会返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The method returns an estimate of the number of nanoseconds remaining to wait given the supplied nanosTimeout value upon</span><br><span class="line">return, or a value less than or equal to zero if it timed out. This value can be used to determine whether and how long to re-</span><br><span class="line">wait in cases where the wait returns but an awaited condition still does not hold. Typical uses of this method take the </span><br><span class="line">following form:</span><br></pre></td></tr></table></figure>
<p>这个方法会返回一个近似的纳秒的时间，这个时间是给定时间的剩余的时间，还有可能返回的是一个小于或者等于零的值，这意味着超时了。这个值可以用来是否以及多长时间重新的等待，典型的使用场景是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">aMethod</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!conditionBeingWaitedFor()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      nanos = theCondition.awaitNanos(nanos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This method requires a nanosecond argument so as to avoid truncation errors in reporting remaining times. Such precision loss </span><br><span class="line">would make it difficult for programmers to ensure that total waiting times are not systematically shorter than specified when </span><br><span class="line">re-waits occur.</span><br></pre></td></tr></table></figure>
<p>这个方法需要的是一个纳秒的参数来去避免一个截断上的错误再去返回剩余时间，使用它来确保整体的等待时间，这种精度的损失可能对于程序员而言是非常困难的。</p>
<p>接下来是另外一个await方法的重载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses. This method is behaviorally equivalent to:</span><br><span class="line">  awaitNanos(unit.toNanos(time)) &gt; 0</span><br></pre></td></tr></table></figure>
<p>这个方法实际上是awaitNanos方法的一个变形，实际上的实现等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">awaitNanos(unit.toNanos(time)) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>接下来是awaitUntil方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>一种典型的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">aMethod</span><span class="params">(Date deadline)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> stillWaiting = <span class="keyword">true</span>;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!conditionBeingWaitedFor()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!stillWaiting)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      stillWaiting = theCondition.awaitUntil(deadline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上都是针对于await方法的一些变形和衍生，本质上并没有什么差别。</p>
<p>接下来是signal方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wakes up one waiting thread.</span><br><span class="line">If any threads are waiting on this condition then one is selected for waking up. That thread must then re-acquire the lock </span><br><span class="line">before returning from await.</span><br></pre></td></tr></table></figure>
<p>该方法用于唤醒一个等待的线程，如果有多个线程在condition上等待，那么就会选择其中的一个进行唤醒，在返回await方法之前，被唤醒的线程必须获取到lock，而具体唤醒哪一个线程取决于具体的实现。</p>
<p>最后是signalAll方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wakes up all waiting threads.</span><br><span class="line">If any threads are waiting on this condition then they are all woken up. Each thread must re-acquire the lock before it can return from await.</span><br></pre></td></tr></table></figure>
<p>该方法会唤醒所有处于等待状态的线程，如果有多个线程在condition上等待，那么它们都会被唤醒。每个线程都要获取到lcok才能从awit方法返回。</p>
<h3 id="condition实践"><a class="markdownIt-Anchor" href="#condition实践"></a> Condition实践</h3>
<p>Thread.sleep与await（或是Object的wait方法）的本质区别：sleep方法本质上不会释放锁，而await会释放锁，并且在signal后，还需要重新获取到锁才能继续执行（该行为与Object的wait方法完全一致）。</p>
<p>接下来我们通过一个具体的例子来了解Condition的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedContainer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] elements = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition notEmptyCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition notFullCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组中已有元素的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放置元素索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取元素索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放置元素的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 需要放置的目标元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String element)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.elementCount == <span class="keyword">this</span>.elements.length) &#123;</span><br><span class="line">                notFullCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            elements[putIndex] = element;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (++putIndex == <span class="keyword">this</span>.elements.length) &#123;</span><br><span class="line">                putIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++elementCount;</span><br><span class="line">            System.out.println(<span class="string">&quot;put method: &quot;</span> + Arrays.toString(elements));</span><br><span class="line">            notEmptyCondition.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取元素的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmptyCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            String element = elements[takeIndex];</span><br><span class="line">            elements[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (++takeIndex == <span class="keyword">this</span>.elements.length) &#123;</span><br><span class="line">                takeIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --elementCount;</span><br><span class="line">            System.out.println(<span class="string">&quot;take method: &quot;</span> + Arrays.asList(elements));</span><br><span class="line">            notFullCondition.signal();</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写入口类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BoundedContainer boundedContainer = <span class="keyword">new</span> BoundedContainer();</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                boundedContainer.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start());</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                boundedContainer.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">put method: [hello, null, null, null, null, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, null, null, null, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, null, null, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, null, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, hello, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, hello, hello, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, hello, hello, hello, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, hello, hello, hello, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, hello, hello, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, hello, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, null, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, null, null, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, null, null, null, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, null, null, null, null]</span><br></pre></td></tr></table></figure>
<h2 id="aqs"><a class="markdownIt-Anchor" href="#aqs"></a> AQS</h2>
<h3 id="aqs简介"><a class="markdownIt-Anchor" href="#aqs简介"></a> AQS简介</h3>
<p>AbstractQueuedSynchronizer抽象类（AQS）是整个java.util.concurrent包的核心，AQS框架提供了一套通用的机制来管理同步状态、阻塞/唤醒线程、管理等待队列。</p>
<p>我们所熟知的ReentrantLock、CountDownLatch、CyclicBarrier等同步器，其实都是通过内部类实现了AQS框架暴露的API，以此实现个类同步器的功能。这些同步器的主要区别其实就是对同步状态（Synchronization state）来展开，并替用户解决了如下问题：</p>
<ul>
<li>资源是可以被同时访问，还是在同一时间只能被一个线程访问（共享/独占功能）</li>
<li>访问资源的线程如何进行并发管理（等待队列）</li>
<li>如果线程等不及资源了，如何从等待队列退出（超时/中断）</li>
</ul>
<p>这其实是一种典型的模板方法设计模式：父类（AQS框架）定义好骨架和内部操作细节，具体规则由子类去实现。</p>
<p>AQS框架只将剩下的一个问题留给用户：什么是资源？如何定义资源是否可以被访问？</p>
<p>常见的同步器对这一问题的定义：</p>
<table>
<thead>
<tr>
<th>同步器</th>
<th>资源的定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ReentranLock</td>
<td>资源表示独占锁。State为0表示锁可用，为1表示被占用，为N表示重入的次数</td>
</tr>
<tr>
<td>CountDownLatch</td>
<td>资源表示倒数计时器，state为0表示计数器归零，所有线程都可以访问资源，为N表示计数器未归零，所有线程都需要阻塞</td>
</tr>
<tr>
<td>Semaphore</td>
<td>资源表示信号量或者令牌，state ≤ 0 表示没有令牌可用，所有线程都需要阻塞，大于0表示有令牌可用，线程每获取一个令牌，state减1，线程每释放一个令牌，state加1</td>
</tr>
<tr>
<td>ReentranReadWriteLock</td>
<td>资源表示共享的读锁和独占的写锁。state逻辑上被分成为两个16位的unsigned short，分别记录读锁被多少线程使用和写锁被重入的次数</td>
</tr>
</tbody>
</table>
<p>AQS通过暴露以下API来让用户自己解决上面提到的“如何定义资源是否可以被访问”的问题：</p>
<table>
<thead>
<tr>
<th>钩子方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>tryAcquire</td>
<td>排它获取（资源数）</td>
</tr>
<tr>
<td>tryRelease</td>
<td>排它释放（资源数）</td>
</tr>
<tr>
<td>tryAcquireShared</td>
<td>共享获取（资源数）</td>
</tr>
<tr>
<td>tryReleaseShared</td>
<td>共享获取（资源数）</td>
</tr>
<tr>
<td>isHeldExclusively</td>
<td>是否排它状态</td>
</tr>
</tbody>
</table>
<h3 id="aqs方法"><a class="markdownIt-Anchor" href="#aqs方法"></a> AQS方法</h3>
<h4 id="cas操作"><a class="markdownIt-Anchor" href="#cas操作"></a> CAS操作</h4>
<p>CAS，即CompareAndSet，在Java中CAS操作的实现都委托给UnSafe类：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>compareAndSetState</td>
<td>protected final</td>
<td>CAS修饰同步状态值</td>
</tr>
<tr>
<td>compareAndSetHead</td>
<td>private final</td>
<td>CAS修改等待队列的头指针</td>
</tr>
<tr>
<td>compareAndSetTail</td>
<td>private final</td>
<td>CAS修改等待队列的尾指针</td>
</tr>
<tr>
<td>compareAndSetWaitStatus</td>
<td>private static final</td>
<td>CAS修改结点的等待状态</td>
</tr>
<tr>
<td>compareAndSetNext</td>
<td>private static final</td>
<td>CAS修改结点的next指针</td>
</tr>
</tbody>
</table>
<h4 id="等待队列的核心操作"><a class="markdownIt-Anchor" href="#等待队列的核心操作"></a> 等待队列的核心操作</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>enq</td>
<td>private</td>
<td>入队操作</td>
</tr>
<tr>
<td>addWaiter</td>
<td>private</td>
<td>入队操作</td>
</tr>
<tr>
<td>setHead</td>
<td>private</td>
<td>设置头结点</td>
</tr>
<tr>
<td>unparkSuccessor</td>
<td>private</td>
<td>唤醒后继结点</td>
</tr>
<tr>
<td>doReleaseShared</td>
<td>private</td>
<td>释放共享结点</td>
</tr>
<tr>
<td>setHeadAndPropagate</td>
<td>private</td>
<td>设置头结点并传播唤醒</td>
</tr>
</tbody>
</table>
<h4 id="资源的获取操作"><a class="markdownIt-Anchor" href="#资源的获取操作"></a> 资源的获取操作</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cancelAcquire</td>
<td>private</td>
<td>取消获取资源</td>
</tr>
<tr>
<td>shouldParkAfterFailedAcquire</td>
<td>private static</td>
<td>判断是否阻塞当前调用线程</td>
</tr>
<tr>
<td>acquireQueued</td>
<td>final</td>
<td>尝试获取资源，获取失败尝试阻塞线程</td>
</tr>
<tr>
<td>doAcquireInterruptibly</td>
<td>private</td>
<td>独占地获取资源（响应中断）</td>
</tr>
<tr>
<td>doAcquireNanos</td>
<td>private</td>
<td>独占地获取资源（限时等待）</td>
</tr>
<tr>
<td>doAcquireShared</td>
<td>private</td>
<td>共享地获取资源</td>
</tr>
<tr>
<td>doAcquireSharedInterruptibly</td>
<td>private</td>
<td>共享地获取资源（响应中断）</td>
</tr>
<tr>
<td>doAcquireSharedNanos</td>
<td>private</td>
<td>共享地获取资源（限时等待）</td>
</tr>
<tr>
<td>acquire</td>
<td>public final</td>
<td>独占地获取资源</td>
</tr>
<tr>
<td>acquireInterruptibly</td>
<td>public final</td>
<td>独占地获取资源（响应中断）</td>
</tr>
<tr>
<td>acquireInterruptibly</td>
<td>public final</td>
<td>独占地获取资源（限时等待）</td>
</tr>
<tr>
<td>acquireShared</td>
<td>public final</td>
<td>共享地获取资源</td>
</tr>
<tr>
<td>acquireSharedInterruptibly</td>
<td>public final</td>
<td>共享地获取资源（响应中断）</td>
</tr>
<tr>
<td>tryAcquireSharedNanos</td>
<td>public final</td>
<td>共享地获取资源（限时等待）</td>
</tr>
</tbody>
</table>
<h4 id="资源的释放"><a class="markdownIt-Anchor" href="#资源的释放"></a> 资源的释放</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>release</td>
<td>public final</td>
<td>释放独占资源</td>
</tr>
<tr>
<td>releaseShared</td>
<td>pubilc final</td>
<td>释放共享资源</td>
</tr>
</tbody>
</table>
<h3 id="aqs原理"><a class="markdownIt-Anchor" href="#aqs原理"></a> AQS原理</h3>
<p>AQS的所有操作都围绕着资源——同步状态（synchronization state）来展开，围绕着资源，衍生出三个基本问题：</p>
<ul>
<li>同步状态（synchronization state）的管理</li>
<li>阻塞/唤醒线程的操作</li>
<li>线程等待队列的管理</li>
</ul>
<h4 id="同步状态"><a class="markdownIt-Anchor" href="#同步状态"></a> 同步状态</h4>
<p>同步状态，其实就是资源。AQS使用单个int（32位）来保存同步状态，并且使用getState、setState以及compareAndSetState方法来读取和更新这个状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步状态.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子的方式更新同步状态.</span></span><br><span class="line"><span class="comment"> * 利用Unsafe类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程的阻塞唤醒"><a class="markdownIt-Anchor" href="#线程的阻塞唤醒"></a> 线程的阻塞/唤醒</h4>
<p>在JDK1.5之前，除了内置的监视器机制外，没有其它方法可以安全且便捷的阻塞和唤醒当前线程。JDK1.5以后，java.util.concurrent.locks包提供了LockSupport类来作为线程阻塞和唤醒的工具。</p>
<h4 id="等待队列"><a class="markdownIt-Anchor" href="#等待队列"></a> 等待队列</h4>
<p>等待队列是AQS框架的核心，整个框架的关键其实就是如何在并发状态下管理被阻塞的线程。等待队列是严格的FIFO队列，是Craig，Landin和Hagersten锁（CLH锁）的一种变种，采用双向链表实现，因此也叫CLH队列。</p>
<p>CLH锁是对自旋锁的一种改进，首先它将线程组织程一个队列，保证先请求的线程先获取锁，避免了饥饿问题。其次锁状态去中心化，让每个线程在不同的状态变量中自旋，这样当一个线程释放它的锁时，只能使其后续线程的高速缓存失效，缩小了影响范围，从而减少了CPU的开销。</p>
<p>CLH锁的数据结构类似一个链表队列，所有请求获取锁的线程会排列在链表队列中，自旋访问队列中前一个节点的状态。当一个节点释放锁时，只有它的后一个节点才可以得到锁。CLH锁本身有一个队尾指针Tail，它是一个原子变量，指向队列最末端的CLH节点。每一个CLH节点有两个属性：锁代表的线程和标识是否持有锁的状态变量。当一个线程要获取锁时，它会对Tail进行一个getAndSet的原子操作。该操作会返回Tail当前指向的阶段，也就是当前队尾节点，然后使Tail指向这个线程对应的CLH节点，成为新的队尾节点。入队成功后，该线程会轮询上一个队尾节点的状态变量，当一个节点释放锁后，它将得到这个锁。</p>
<p>下图展示了CLH锁从获取到释放锁的过程：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816122706.png" alt="CLH锁示意图" style="zoom:60%;" />
<p>详细说明：</p>
<ul>
<li>CLH锁初始化时Tail会指向一个状态为false的空节点，如图1所示</li>
<li>当Thread1（下称T1）请求获取锁时，Tail节点指向T1对应的节点，同时返回空节点。T1检查到上一个节点状态为false，就可以成功获取到锁，并且执行相应的逻辑，如图2所示</li>
<li>当Thread2（下称T2）请求获取锁时，Tail节点执行T2对应的节点，同时返回T1对应的节点。T2检查到上一个节点状态为true，无法获取到锁，于是开始轮询上一个节点的状态，如图3所示</li>
<li>当T1释放锁时，会将状态变量重置为false，如图4所示</li>
<li>当T2轮询到检查到上一个节点为false，则获取锁成功，如图5所示</li>
</ul>
<p>CLH锁是一种隐式的链表队列，没有显式的维护前驱或者后继指针。因为每个等待获取锁的线程只需要轮询前一个节点的状态就可够了，而不需要遍历整个队列。在这种情况下，只需要使用一个局部变量保存前驱节点，而不需要显式的维护前驱或后继指针。</p>
<p>可以在CLH锁的基础上，在节点中显式地维护前驱节点，CLH锁就可以处理“超时”和各种形式地“取消”：如果一个节点的前驱节点取消了，这个节点就可以滑动去使用前面一个节点的状态字段，对于通过自旋获取锁的CLH锁来说，只需要显式的维护前驱节点就可以实现取消功能，如下图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816121517.png" alt="image-20210816121517012" style="zoom:67%;" />
<p>CLH锁作为自旋锁的改进，有以下优点：</p>
<ul>
<li>性能优异，获取和释放锁开销小。CLH的锁状态不再是单一的原子变量，而是分散在每个节点的状态中，降低了自旋锁在竞争激烈时频繁同步的开销。在释放锁的开销也因为不需要使用CAS指令而降低了</li>
<li>公平锁，先入队的线程会先得到锁</li>
<li>实现简单，易于理解</li>
<li>扩展性强，AQS基于CLH锁实现了并发包下个类丰富的同步器</li>
</ul>
<p>在AQS的等待队列中，节点中的状态不再局限于true或者false，而是被定义为了：</p>
<table>
<thead>
<tr>
<th>结点的状态</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CANCELLED</td>
<td>1</td>
<td>取消。表示当前结点被中断或超时，需要移除队列</td>
</tr>
<tr>
<td>SIGNAL</td>
<td>-1</td>
<td>发信号。表示当前结点被阻塞了（当前结点在入队后，阻塞前，应确保将其prev结点类型改为SIGNAL，以便prev结点取消或释放时将当前结点唤醒）</td>
</tr>
<tr>
<td>CONDITION</td>
<td>-2</td>
<td>Condition专用。表示当前结点在Condition队列中，因为等待某个条件而被阻塞了</td>
</tr>
<tr>
<td>PROPAGATE</td>
<td>-3</td>
<td>传播，适用于共享模式（比如连续的读操作结点可以依次进入临界区，设为PROPAGATE有助于实现这种迭代操作）</td>
</tr>
<tr>
<td>INITIAL</td>
<td>0</td>
<td>默认。新阶段会处于这种状态</td>
</tr>
</tbody>
</table>
<p>相应的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 共享模式结点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 独占模式结点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱指针</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后驱指针</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点所包装的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Condition队列使用，存储condition队列中的后继节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123; </span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，与CLH锁不同的是，AQS显式的维护前驱节点和后驱节点，这是因为AQS用阻塞等待替换了自旋操作，线程会阻塞等待锁的释放，不能主动感知到前驱结点状态的变化信息。AQS中显式的维护前驱节点和后续节点，需要方式锁的节点会显式通知下一个节点解决阻塞，如下图所示，T1释放锁后主动唤醒T2，使T2检测到锁已释放，获取锁成功。</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816120319.png" alt="AQS队列示意图" style="zoom:60%;" />
<h2 id="reentrantlock"><a class="markdownIt-Anchor" href="#reentrantlock"></a> ReentrantLock</h2>
<h3 id="公平策略原理"><a class="markdownIt-Anchor" href="#公平策略原理"></a> 公平策略原理</h3>
<p>假设现在有3个线程：ThreadA、ThreadB、ThreadC，一个公平的独占锁，3个线程会依次尝试去获取锁：<code>ReentrantLock lock = new ReentrantLock(true)</code>，线程的操作时序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadA    lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadB    lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadC    lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadA    release</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadB    release</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadC    release</span></span><br></pre></td></tr></table></figure>
<p>ThreadA首先调用ReentrantLock的lock方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中sync定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本上所有基于AQS实现的同步器都在定义了这样的内部静态类，lock方法的最终实现是在：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          acquire(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>acquire来自于AQS：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中tryAcquire方法需要AQS的子类自己去实现，在FairSync类中的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123; <span class="comment">// 入参acquires = 1</span></span><br><span class="line">    <span class="comment">// 获取当先线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread(); </span><br><span class="line">    <span class="comment">// 获取同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// c == 0 表示锁未被占用</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果等待队列中，当前线程没有其它线程，则以CAS方式更新同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 更新成功，设置锁的占有线程为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否属于重入的情况，重入时，同步状态累加1，重入次数过大可能会移除</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在ReentrantLock中，同步状态State的含义如下：</p>
<table>
<thead>
<tr>
<th>State</th>
<th>资源的定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>表示锁可用</td>
</tr>
<tr>
<td>1</td>
<td>表示锁被占用</td>
</tr>
<tr>
<td>大于1</td>
<td>表示锁被占用，且值表示同一线程的重入次数</td>
</tr>
</tbody>
</table>
<p>ThreadA是首个获取锁的线程，所以上述方法会返回true，第一阶段结束。（ThreadA一直保持占有锁的状态），此时。AQS中的等待队列还是空：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816163854.png" alt="image-20210816163854093" style="zoom: 67%;" />
<p>接下来是ThreadB要调用lock方法，最终调用AQS的acquire方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时tryAcquire方法由于ThreadA占有着锁，所以会返回false，接下来是addWaiter方法，这个方法其实就是将当前调用线程包装称一个独占结点，然后添加到队列尾部：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将线程包装成结点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 先尝试一次直接添加到尾部，如果添加成功，就不用走下面的enq方法了</span></span><br><span class="line">    <span class="comment">// 这部分是为了优化效率</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结点插入到队尾</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中核心的方法就是enq方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为存在并发插入的情况的，所以该方法设计成了自旋操作，保证结点能成功插入，具体步骤如下：</p>
<ul>
<li>
<p>当队列为空的时候，先创建一个dummy头结点：</p>
  <img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816164745.png" alt="image-20210816164745147" style="zoom:50%;" />
</li>
<li>
<p>进入下一次循环，插入队尾结点：</p>
  <img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816164911.png" alt="image-20210816164911775" style="zoom: 50%;" />
</li>
</ul>
<p>此时，ThreadB已经被包装成结点插入队尾了，接下来会调用acquireQueued方法，这也是AQS中最重要的方法之一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 是否需要阻塞线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该方法用来从等待队列中选取队首线程，并尝试获取锁。如果获取不到，就要确保在前驱能唤醒自己的情况下（将前驱置为SIGNAL）进入阻塞状态，值得注意的是，正常情况下，该方法会一直阻塞当前线程，除非获取到锁才返回，但是如果执行过程中，抛出异常（tryAcquire方法），那么会将当前结点移除，继续上抛异常，如果线程阻塞过程中被中断，则返回true。</p>
</blockquote>
<p>上述方法中，将ThreadB包装成结点插入队尾后，先判断ThreadB是否时首结点（注意不是头结点，头结点是个dummy结点），发现确实是首结点，于是调用tryAcquire尝试获取锁，但是获取失败了（此时ThreadA占有着锁），就判断是否需要阻塞当前线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前驱结点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// SIGNAL：后续结点需要被唤醒（这个状态说明当前结点的前驱会唤醒当前结点（线程））</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">// CANCELED：取消（说明当前结点（线程）因意外被中断/取消，需要将其从等待队列移除）</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对于独占功能来说，这里表示结点的初始状态0</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，对于独占功能，只使用了3种结点状态：</p>
<table>
<thead>
<tr>
<th>结点状态</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CANCELLED</td>
<td>1</td>
<td>取消。表示后驱结点被中断或超时，需要移出队列</td>
</tr>
<tr>
<td>SIGNAL</td>
<td>-1</td>
<td>发信号。表示后驱结点被阻塞了（当前结点在入队后、阻塞前，应确保将其prev结点类型取消或释放时将当前结点唤醒）</td>
</tr>
<tr>
<td>CONDITION</td>
<td>-2</td>
<td>Condition专用。表示当前结点在Condition队列中，因为等待在Condition队列中，因为等待某个条件而被阻塞了</td>
</tr>
</tbody>
</table>
<p>对于在等待队列中的线程，如果要阻塞它，需要确保将来有线程可以唤醒它，AQS中通过将前驱结点的状态置为SIGNAL为-1来表示将来会唤醒当前线程，当前线程可以安心阻塞。</p>
<p>结合图形来理解这个过程：</p>
<ul>
<li>
<p>插入完成ThreadB后，队列的初始状态如下：</p>
  <img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816175853.png" alt="image-20210816175853692" style="zoom:60%;" />
</li>
<li>
<p>虽然ThreadB是队首结点，但是它拿不到锁（被ThreadA占有着），所以ThreadB会阻塞，但是在阻塞前需要设置下前驱的状态，以便将来可以被唤醒：</p>
  <img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816180059.png" alt="image-20210816180059755" style="zoom:60%;" />
</li>
</ul>
<blockquote>
<p>如果ThreadB阻塞过程中被中断，其实是不会抛出异常的，只会在acquireQueued方法返回时，告诉调用者在阻塞器件有没有被中断过，具体如何处理，要不要抛出异常，取决于调用者，这其实是一种延时中断机制。</p>
</blockquote>
<p>ThreadC的调用过程和ThreadB完成一样，同样拿不到锁，然后加入到等待队列队尾：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816180828.png" alt="image-20210816180827996" style="zoom:50%;" />
<p>然后，ThreadC在阻塞前需要把前驱结点的状态值SIGNAL置为-1，以确保将来可以被唤醒：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816181023.png" alt="image-20210816181023560" style="zoom:50%;" />
<p>至此，获取锁的阶段就结束了，现在假设ThreadA使用完了临界资源，要开始释放锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unlock调用了AQS的release方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">// 此时参数arg是1</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 尝试释放锁</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 释放成功，则唤醒首结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样的tryRelease需要RenntrantLock自己来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同步状态值减去1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 持有锁和释放锁的线程必须是同一个，否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果状态值为0，说明没有线程占用锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 清除占有线程</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新状态值</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放成功后，调用方法，唤醒队列中的首结点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// SIGNAL:-1</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"> <span class="comment">// 后继结点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 正常情况下，会直接唤醒后继结点</span></span><br><span class="line">    <span class="comment">// 但是如果后继结点处于CANCELLED（-1）状态时，会从队尾开始，向前找到第一个未被CANCELLED的结点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从tail开始向前查找时为了考虑并发入队（enq）的情况</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒结点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) </span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，队列的状态为：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816183415.png" alt="image-20210816183414910" style="zoom:67%;" />
<p>队首结点ThreadB被唤醒之后会从以下为止开始执行，先返回一个中断标识，用于标识ThreadB在阻塞期间有没有被中断过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后ThreadB又开始了自旋操作，被唤醒的是队首结点，所以可以尝试tryAcquire获取锁，此时获取成功（ThreadA已经释放了锁），获取成功后会调用setHead方法，将头结点设置为当前结点，并清除线程信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将头结点设置为当前结点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的队列状态如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816184310.png" alt="image-20210816184310249" style="zoom: 67%;" />
<p>ThreadB在使用完了临界资源之后开始释放锁，过程和ThreadA释放时一样，释放成功后，会调用unparkSucessor方法，唤醒队列中的首结点：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816214823.png" alt="image-20210816214823695" style="zoom:60%;" />
<p>队首结点（ThreadC）被唤醒后，继续从原来的阻塞处向下执行，并尝试获取锁，获取成功，最终队列的状态如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816214945.png" alt="image-20210816214945139" style="zoom: 67%;" />
<p>ThreadB在使用完了临界资源之后开始释放锁，释放成功之后，调用unparkSucessor方法，唤醒队列中的首结点，此时队列中只剩一个头结点（dummy），所以这个方法其实什么都不做。最终队列的状态就是只有一个dummy头结点。</p>
<h3 id="非公平策略原理"><a class="markdownIt-Anchor" href="#非公平策略原理"></a> 非公平策略原理</h3>
<p>非公平策略和公平策略的内部实现没有什么太大的区别，主要区别在于，公平锁获取锁时，会判断等待队列中是否有线程排在当前线程前面。只有没有的情况下，才会去获取锁：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816215900.png" alt="image-20210816215900560" style="zoom:50%;" />
<p>而非公平锁获取锁时，会立即尝试修改同步状态，失败后再调用AQS的acquire方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acquire方法转调非公平锁自身的tryAcquire方法，其实最终是调了nonfairTryAcquire方法，而该方法相对公平锁，只是少了“队列中是否具有其它线程排在当前线程前”这一判断：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816220515.png" alt="image-20210816220515041" style="zoom:60%;" />
<p>不过需要注意的时，这个方法并没有位于ReentrantLock.NonfairSync，而是位于ReentrantLock.Sync。</p>
<h3 id="等待"><a class="markdownIt-Anchor" href="#等待"></a> 等待</h3>
<p>ReentrantLock的lockInterruptibly方法是会响应中断的（线程如果在阻塞过程中被中断，会抛出InterruptedException异常）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会先尝试获取，如果失败，则会调用方法doAcquireInterruptibly：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 这里直接抛出了异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与acquireQueued唯一的区别就是，当调用线程获取锁失败，进入阻塞后，如果中途被中断，acquireQueued只是用一个标识记录线程被中断过，而doAcquireInterruptibly则是直接抛出异常。</p>
<h3 id="限时"><a class="markdownIt-Anchor" href="#限时"></a> 限时</h3>
<p>Lock接口中有一个方法：tryLock，用于指定的时间内尝试获取锁，获取不到就返回。ReentrantLock实现了该方法，可以看到，该方法内部调用了AQS的tryAcquireNanos方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryAcquireNanos方法是响应中断的，先尝试获取一次锁，失败则调用doAcquireNanos方法进行超时等待：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的关键是doAcquireNanos方法，和acquireQueued方法类似，又是一个自旋操作，在超时前不断尝试获取锁，获取不到则阻塞（加上了等待时间的判断）。该方法内部调用了<code>LockSupport.parkNanos</code>来超时阻塞线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LockSupport.parkNanos</code>内部其实通过Unsafe这个类来操作线程的阻塞，底层是一个native方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, nanos);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前线程在指定时间内获取不到锁，除了返回false之外，最终还会执行cancelAcquire方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过当前结点之前，所有已经取消的结点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)  <span class="comment">// CANCELLED:1</span></span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"><span class="comment">// preNext此时指向第一个CANCELLED结点</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前结点标记为CANCELLED:1</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前结点是尾结点，则尝试直接移除</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前结点不是尾结点或尝试移除失败（存在尾部的并发操作）</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了便于理解还是以3个线程为例，假设现在有3个线程：ThreadA、ThreadB、ThreadC，一个公平的独占锁，3个线程会依次尝试去获取锁，不过此时加上了限时等待：ThreadB等待10s，ThreadA等待20s。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadA    tryLock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadB    tryLock, 10s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadC    tryLock, 20s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadA    release</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadB    release</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadC    release</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>ThreadA首先获取到锁，ThreadB和ThreadC依次尝试去获取锁，ThreadB和ThreadC经过两轮自旋操作后，等待队列的情况如下：</p>
  <img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816223527.png" alt="image-20210816223527173" style="zoom:60%;" />
</li>
<li>
<p>ThreadB先到超时时间，调用了cancelAcquire方法取消操作，队列状态变成了：</p>
  <img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816223639.png" alt="image-20210816223639064" style="zoom:60%;" />
</li>
<li>
<p>ThreadC到达超时时间，调用了cancelAcquire方法取消操作，队列状态变成了：</p>
  <img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210816223745.png" alt="image-20210816223745229" style="zoom:60%;" />
<p>在退出cancelAcquire后，原来ThreadB和ThreadC对应的结点会被JVM垃圾回收器回收。</p>
</li>
</ul>
<blockquote>
<p>通常情况下，我们还会配合Condition对象一起使用。在AQS当中，当线程在指定Condition对象上等待的时候，会将线程包装成结点，加入到条件队列，然后阻塞。当线程被通知唤醒时，则是将条件队列的结点转换成等待队列的结点，然后就和上面的处理完全一样。</p>
</blockquote>
<h2 id="reentrantreadwirtelock"><a class="markdownIt-Anchor" href="#reentrantreadwirtelock"></a> ReentrantReadWirteLock</h2>
<p>使用ReentrantReadWriteLock可以解决线程安全的问题，但是ReentrantReadWriteLock是独占锁，某一时刻只能有一个线程可以获取该锁，而实际中会有写少读多的场景，所以ReentrantReadWriteLock应运而生，ReentrantReadWriteLock采取读写分离的策略，允许多个线程可以同时获取读锁。</p>
<h2 id="stampedlock"><a class="markdownIt-Anchor" href="#stampedlock"></a> StampedLock</h2>
<p>ReadWirteLock可以解决多线程同时读，但只有一个线程能写的问题，但是ReadWirteLock会有个潜在的问题，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁，为了进一步提升并发执行效率，Java8引入了新的读写锁：StampedLock。</p>
<p>StampedLock和ReadWriteLock相比，改进之处在于：读的过程中也允许获取写锁后写入，但是这样以来，读的数据就可能会不一致。因此，在读的过程中需要额外的代码来辅助判断读的过程是否有写入。</p>
<p>StampedLock的使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX,<span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取一个乐观读锁</span></span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead();</span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x;</span><br><span class="line">        <span class="comment">// 此处已读取到y，但x，y可能被线程修改为（300，400）</span></span><br><span class="line">        <span class="keyword">double</span> currentY = y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的（100，200）</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123;  <span class="comment">// 检查乐观读锁后是否有其它写锁发生</span></span><br><span class="line">            <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            stamp = stampedLock.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放悲观读锁</span></span><br><span class="line">                stampedLock.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和ReadWirteLock相比，写入的加锁是完全一样的，不同的是读取。注意到我们首先通过tryOptimisticRead获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，通过validate去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心的继续后续操作。如果读取过程中有写入，那么版本号就会发生变化，验证就会失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。</p>
<p>StampedLock把读锁细分为乐观锁和悲观锁，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，而是StampedLock是不可重入锁，不能在一个线程中反复获取同一个锁。</p>
<p>StampedLock还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。</p>
<h1 id="threadlocalrandom类"><a class="markdownIt-Anchor" href="#threadlocalrandom类"></a> ThreadLocalRandom类</h1>
<h2 id="random类及其局限性"><a class="markdownIt-Anchor" href="#random类及其局限性"></a> Random类及其局限性</h2>
<p>在JDK7之前包括现在，java.util.Random都是使用比较广泛的随机数生成工具类，下面使用的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建一个默认种子的随机数生成器</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">// 2.输出10个0~5（包含0，不包含5）之间的随机数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(random.nextInt(<span class="number">5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Random的实现原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件检查</span></span><br><span class="line">    <span class="keyword">if</span> (bound &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadBound);</span><br><span class="line"> <span class="comment">//根据老的种子生成新的种子，可能导致并发问题，多个线程可能都拿到同一个老的种子</span></span><br><span class="line">    <span class="keyword">int</span> r = next(<span class="number">31</span>);</span><br><span class="line">    <span class="keyword">int</span> m = bound - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 根据新的种子计算随机数</span></span><br><span class="line">    <span class="keyword">if</span> ((bound &amp; m) == <span class="number">0</span>)  <span class="comment">// i.e., bound is a power of 2</span></span><br><span class="line">        r = (<span class="keyword">int</span>)((bound * (<span class="keyword">long</span>)r) &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = r;</span><br><span class="line">             u - (r = u % bound) + m &lt; <span class="number">0</span>;</span><br><span class="line">             u = next(<span class="number">31</span>))</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，Random的缺点是多个线程会使用同一个原子性种子变量，从而导致对原子变量更新的竞争，如图所示：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210811222619.png" alt="image-20210811222618820" style="zoom: 67%;" />
<p>为了改进这一点，在Random中还有一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldseed, nextseed;</span><br><span class="line">    AtomicLong seed = <span class="keyword">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于原子变量的更新是CAS操作，同时只有一个线程会成功，所以会造成大量线程进行自旋重试，这会降低并发性能，因此在JUC包中增加了ThreadLocalRandom类来彻底解决这个问题。</p>
<h2 id="threadlocalrandom类-2"><a class="markdownIt-Anchor" href="#threadlocalrandom类-2"></a> ThreadLocalRandom类</h2>
<p>那么，如果每个线程都维护一个种子变量，则每个线程生成随机数时都根据自己老的种子计算新的种子，并使用新种子更新老的种子，再根据新种子计算随机数，就不会存在竞争问题了，这会大大提高并发性能。ThreadLocalRandom原理如图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210811222655.png" alt="image-20210811222654854" style="zoom:67%;" />
<p>ThreadLocalRandom的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bound &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadBound);</span><br><span class="line">    <span class="keyword">int</span> r = mix32(nextSeed());</span><br><span class="line">    <span class="keyword">int</span> m = bound - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((bound &amp; m) == <span class="number">0</span>) <span class="comment">// power of two</span></span><br><span class="line">        r &amp;= m;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// reject over-represented candidates</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = r &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">             u + m - (r = u % bound) &lt; <span class="number">0</span>;</span><br><span class="line">             u = mix32(nextSeed()) &gt;&gt;&gt; <span class="number">1</span>)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点是其中的nextSeed方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">nextSeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Thread t; <span class="keyword">long</span> r; <span class="comment">// read and update per-thread seed</span></span><br><span class="line">     UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class="line">                    r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class="line">     <span class="keyword">return</span> r;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在如上代码中，首先使用r = UNSAFE.getLong(t, SEED获取当前线程中的ThreadLocalRandomSeed变量的值，然后在种子的基础上累加GAMMA值作为新种子，而后使用UNSAFE的putLong方法把新种子放入当前线程的ThreadLocalRandomSeed变量中。</p>
<h1 id="线程池threadpoolexecutor"><a class="markdownIt-Anchor" href="#线程池threadpoolexecutor"></a> 线程池ThreadPoolExecutor</h1>
<h2 id="线程池概览"><a class="markdownIt-Anchor" href="#线程池概览"></a> 线程池概览</h2>
<p>使用线程池的好处：</p>
<ul>
<li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li>提高响应速度：当任务到达时，可以不需要等待线程创建就能立即执行</li>
<li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行同一的分配，监控和调优。</li>
<li>提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或者定期执行。</li>
</ul>
<p>线程池的API设计图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210813172202.png" alt="image-20210813172201839" style="zoom: 60%;" />
<p>各个接口/类的关系和作用：</p>
<ul>
<li>Executor：执行器接口，也是最顶层的抽象核心接口，分离了任务和任务的执行</li>
<li>ExecutorService：在Executor的基础上提供了执行器生命周期管理，任务异步执行等功能</li>
<li>ScheduledExecutorService：在ExecutorService基础上提供了任务的延迟执行/周期执行的功能</li>
<li>Executors：生产具体的执行器的静态工厂</li>
<li>ThreadFactory：线程工厂，用于创建单个线程，减少手工创建线程的繁琐工作，同时能够复用工厂的特性</li>
<li>AbstractExecutorService：ExecutorService的抽象实现，为各类执行器类的实现提供基础</li>
<li>ThreadPoolExecutor：线程池Executor，也是最常用的Executor，可以以线程池的方式管理线程</li>
<li>ScheduledThreadPoolExecutor：在ThreadPoolExecutor基础上，增加了对周期任务调度的支持</li>
<li>ForkJoinPool：Fork/Join线程池，在JDK1.7时引入，是实现Fork/Join框架的核心类</li>
</ul>
<h2 id="threadpoolexecutor"><a class="markdownIt-Anchor" href="#threadpoolexecutor"></a> ThreadPoolExecutor</h2>
<h3 id="核心参数"><a class="markdownIt-Anchor" href="#核心参数"></a> 核心参数</h3>
<p>接下来我们对最常用到的ThreadPoolExecutor进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // 第一个参数</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize, // 第二个参数</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime, // 第三个参数</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit, // 第四个参数</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue, // 第五个参数</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory, // 第六个参数</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123; <span class="comment">// 第七个参数</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第1个参数 ：corePoolSize 表示常驻核心线程数。如果等于0，则任务执行完成后，没有任何请求进入时销毁线程池的线程；如果大于0，即使本地任务执行完毕，核心线程也不会被销毁。这个值的设置非常关键，设置过大会浪费资源，设置的过小会导致线程频繁地创建或销毁。</li>
<li>第2个参数：maximumPoolSize 表示线程池能够容纳同时执行的最大线程数。从上方的示例代码中第一处来看，必须大于或等于1。如果待执行的线程数大于此值，需要借助第5个参数的帮助。缓存在队列中。如果maximumPoolSize 与corePoolSize 相等，即是固定大小线程池。</li>
<li>第3个参数：keepAliveTime 表示线程池中的线程空闲时间，当空闲时间达到KeepAliveTime 值时，线程被销毁，直到剩下corePoolSize 个线程为止，避免浪费内存和句柄资源。在默认情况下，当线程池的线程大于corePoolSize 时，keepAliveTime 才会起作用。但是ThreadPoolExecutor的allowCoreThreadTimeOut 变量设置为ture时，核心线程超时后也会被回收。</li>
<li>第4个参数：TimeUnit 表示时间单位。keepAliveTime 的时间单位通常是TimeUnit.SECONDS。</li>
<li>第5个参数:  workQueue 表示缓存队列。当请求的线程数大于maximumPoolSize时，线程进入BlockingQueue 阻塞队列。后续示例代码中使用的LinkedBlockingQueue 是单向链表，使用锁来控制入队和出对的原子性，两个锁分别控制元素的添加和获取，是一个生产消费模型队列。</li>
<li>第6个参数：threadFactory 表示线程工厂。它用来生产一组相同任务的线程。线程池的命名是通过给这个factory增加组名前缀来实现的。在虚拟机栈分析时，就可以知道线程任务是由哪个线程工厂产生的。</li>
<li>第7个参数：handler 表示执行拒绝策略的对象。当超过第5个参数workQueue的任务缓存区上限的时候，就可以通过该策略处理请求，这是一种简单的限流保护。友好的拒绝策略可以使如下三种：
<ul>
<li>保存到数据库进行削峰填谷。在空闲的时候再拿出来执行。</li>
<li>转向某个提示页面。</li>
<li>打印日志。</li>
</ul>
</li>
</ul>
<h3 id="线程池状态转换"><a class="markdownIt-Anchor" href="#线程池状态转换"></a> 线程池状态转换</h3>
<p>线程池的状态及含义：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>RUNNING</td>
<td>接受新任务并且处理阻塞队列里的任务</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>拒绝新任务但是处理阻塞队列里的任务</td>
</tr>
<tr>
<td>STOP</td>
<td>拒绝新任务并且抛弃阻塞队列里的任务，同时会中断正在处理的任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>所有任务都执行完（包含阻塞队列里面的任务）后当前线程池活动线程数为0，将要调用terminated方法</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，terminated方法调用完成以后的状态</td>
</tr>
</tbody>
</table>
<p>线程池状态转换列举如下：</p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：显式调用shutdown()方法，或者隐式调用了finalize()方法里面的shutdown()方法</li>
<li>RUNNING或SHUTDOWN -&gt; STOP：显式调用shutdownNow()方法时</li>
<li>SHUTDOWN -&gt; TIDYING：当线程池和任务队列都为空时</li>
<li>STOP -&gt; TIDYING：当线程池为空时</li>
<li>TIDYING -&gt; TERMINATED：当teminated() hook方法执行完成时</li>
</ul>
<p>具体如下图所示：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210826150648.png" alt="image-20210826150648498" /></p>
<h3 id="线程池的类型"><a class="markdownIt-Anchor" href="#线程池的类型"></a> 线程池的类型</h3>
<ul>
<li>
<p>newFixedThreadPool：创建一个核心线程个数和最大线程个数都为n的线程池，并且阻塞队列长度为Integer.MAX_VALUE。keepAliveTime=0说明只要线程个数比和核心线程个数多并且当前空闲则回收：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以自定义线程创建工厂：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建一个核心线程个数和最大线程个数都为1的线程池，并且阻塞队列长度为Integer.MAX_VALUE。keepAliveTime=0说明只要线程个数比核心线程个数多并且当前空间则回收。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，它也有一个重载的版本：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建一个按需创建线程的线程池，初始线程个数为0，最多线程个数为Integer.MAX_VALUE，并且阻塞队列为同步队列。keepAliveTime=60说明只要当前线程在60s内空闲则回收。这个类型的特殊之处在于，加入同步队列的任务会马上执行，同步队列里面最多只有一个任务。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，它也有一个重载的版本：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>除此之外，还有等JDK为我们内置了ScheduledExecutorService等线程池类型。</p>
<h2 id="阻塞队列"><a class="markdownIt-Anchor" href="#阻塞队列"></a> 阻塞队列</h2>
<h3 id="arrayblockingqueue"><a class="markdownIt-Anchor" href="#arrayblockingqueue"></a> ArrayBlockingQueue</h3>
<p>ArrayBlockingQueue是一个有边界的阻塞队列，它的内部实现是一个数组，所谓有边界的意思是它的容量是有限的，我们必须在初始化的时候就指定它的容量大小，容量大小一旦指定就不可变。ArrayBlockingQueue是先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。</p>
<h3 id="delayqueue"><a class="markdownIt-Anchor" href="#delayqueue"></a> DelayQueue</h3>
<p>DelayQueue阻塞的是其内部元素，DelayQueue中的元素必须实现java.util.concurrent.Delayed接口，Delayed接口继承了Comparable接口，这是因为DelayedQueue中的元素需要进行排序，一般情况下，我们都是按元素过期时间的优先级进行排序，典型的应用场景有定时关闭连接、缓存对象、超时处理等。</p>
<h3 id="linkedblockingqueue"><a class="markdownIt-Anchor" href="#linkedblockingqueue"></a> LinkedBlockingQueue</h3>
<p>LinkedBlockingQueue阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的，这里无边界是因为，它采用了默认大小为<code>Integer.MAX_VALUE</code>的容量。它的内部实现是一个链表。与ArrayBlockingQueue一样，也是采用先进先出的方式存储数据。</p>
<h3 id="priorityblockingqueue"><a class="markdownIt-Anchor" href="#priorityblockingqueue"></a> PriorityBlockingQueue</h3>
<p>PriorityBlockingQueue是一个没有边界的队列，它的排序规则和java.util.PriorityBlockingQueue一样。需要注意的是，PriorityBlockingQueue中允许插入null对象。</p>
<ul>
<li>所有插入PriorityBlockingQueue的对象必须实现java.lang.Comparable接口，队列优先级的排序规则就是按照我们对这个接口的实现来定义的。</li>
<li>从PriorityBlockingQueue获取一个迭代器Iterator，但这个迭代器并不保证按照优先级顺序进行迭代。</li>
</ul>
<h3 id="synchronousqueue"><a class="markdownIt-Anchor" href="#synchronousqueue"></a> SynchronousQueue</h3>
<p>synchronousQueue队列内部仅允许容纳一个元素，当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。</p>
<h2 id="拒绝策略"><a class="markdownIt-Anchor" href="#拒绝策略"></a> 拒绝策略</h2>
<p>当提交的线程填满核心线程数，并且塞满了队列缓冲区，并且超过了最大线程数时，就会触发拒绝策略。</p>
<p>核心API - java.util.concurrent.RejectedExecutionHandler</p>
<p>具体有以下几种：</p>
<table>
<thead>
<tr>
<th>拒绝策略</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbortPolicy</td>
<td>当任务添加到线程池中被拒绝时，它将抛出RejectedExecutionException异常</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>当任务添加到线程池中被拒绝时，会交由提交任务的线程处理</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务</td>
</tr>
</tbody>
</table>
<p>什么时候触发拒绝策略，是三个参数总体协调的结果，当提交的任务大于corePoolSize时，会优化放到队列缓冲区，值由填满了缓冲区之后，才会判断当前任务是否大于maxPoolSize，小于的时候会创建新的线程进行处理，大于时就触发了拒绝策略。简单来说，当前提交任务数大于(maxPoolSize + queueCapacity)时就会触发线程的拒绝策略。</p>
<h3 id="abortpolicy"><a class="markdownIt-Anchor" href="#abortpolicy"></a> AbortPolicy</h3>
<p>AbortPolicy又称为中止策略，源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                             <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能：当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程</p>
<p>使用场景：无特殊场景，但是要正确处理抛出的异常</p>
<p>ThreadPoolExecutor中默认的策略就是AbortPolicy，ExecutorService接口的系列ThreadPoolExecutor因为都没有显式的设置拒绝策略，所以默认都是这个，但是，但是ExecutorService中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛出的异常，因为它会打断当前的执行流程。</p>
<h3 id="discardpolicy"><a class="markdownIt-Anchor" href="#discardpolicy"></a> DiscardPolicy</h3>
<p>DiscardPolicy又称为丢失策略，源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能：直接静悄悄地丢弃这个任务，不触发任何动作。</p>
<p>使用场景：如果提交的任务无关紧要，可以使用，这种策略会悄无声息的吞噬掉任务，所以这个策略基本上不再使用。</p>
<h3 id="discardoldestpolicy"><a class="markdownIt-Anchor" href="#discardoldestpolicy"></a> DiscardOldestPolicy</h3>
<p>DiscardOldestPolicy又称为弃老策略，源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是丢弃的是老的未执行的任务，而是待执行优先级比较高的任务。</p>
<h3 id="callerrunspolicy"><a class="markdownIt-Anchor" href="#callerrunspolicy"></a> CallerRunsPolicy</h3>
<p>CallerRunsPolicy又称为调用者运行策略，源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能：当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。</p>
<p>使用场景：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下也不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。</p>
<h3 id="第三方实现"><a class="markdownIt-Anchor" href="#第三方实现"></a> 第三方实现</h3>
<p>除了JDK内部的实现，还有一些第三方的实现，例如在dubbo中的拒绝策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicyWithReport</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span>.<span class="title">AbortPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbortPolicyWithReport.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String threadName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastPrintTime = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore guard = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicyWithReport</span><span class="params">(String threadName, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        String msg = String.format(<span class="string">&quot;Thread pool is EXHAUSTED!&quot;</span> +</span><br><span class="line">                        <span class="string">&quot; Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d), Task: %d (completed: %d),&quot;</span> +</span><br><span class="line">                        <span class="string">&quot; Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s), in %s://%s:%d!&quot;</span>,</span><br><span class="line">                threadName, e.getPoolSize(), e.getActiveCount(), e.getCorePoolSize(), e.getMaximumPoolSize(), e.getLargestPoolSize(),</span><br><span class="line">                e.getTaskCount(), e.getCompletedTaskCount(), e.isShutdown(), e.isTerminated(), e.isTerminating(),</span><br><span class="line">                url.getProtocol(), url.getIp(), url.getPort());</span><br><span class="line">        logger.warn(msg);</span><br><span class="line">        dumpJStack();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dumpJStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//省略实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当dubbo的工作线程触发了线程拒绝策略后，主要做了三个事情：</p>
<ul>
<li>输出了一条警告级别的日志</li>
<li>输出当前线程堆栈详情</li>
<li>继续抛出拒绝执行异常，使本次任务失败</li>
</ul>
<p>Netty中的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThreadRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        NewThreadRunsPolicy() &#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread(r, <span class="string">&quot;Temporary task executor&quot;</span>);</span><br><span class="line">                t.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(</span><br><span class="line">                        <span class="string">&quot;Failed to start a new thread&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Netty中的实现很像JDK中的CallerRunsPolicy，舍不得丢弃任务。不同的是，CallerRunsPolicy是直接在调用者线程执行的任务，而Netty是新建了一个线程来处理的。</p>
<p>所以，Netty的实现相较于调用者执行策略的使用面就可以扩展到支持高效率高性能的场景了，但是也要注意一点，Netty的实现里，在创建线程时未做任何的判断约束，也就是说只要系统还有资源就会创建新的线程来处理，直到new不出新的线程了，才会抛创建线程失败的异常。</p>
<p>activeMq中的线程池拒绝策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(<span class="keyword">final</span> Runnable r, <span class="keyword">final</span> ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        executor.getQueue().offer(r, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Interrupted waiting for BrokerService.worker&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Timed Out while attempting to enqueue Task.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<p>activeMq中的策略属于最大努力执行类型，当触发拒绝策略时，在尝试一分钟重新将任务塞进任务队列，当一分钟超时还没由成功的时候，就抛出异常。</p>
<p>pinpoint中的线程池拒绝策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectedExecutionHandlerChain</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RejectedExecutionHandler[] handlerChain;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RejectedExecutionHandler <span class="title">build</span><span class="params">(List&lt;RejectedExecutionHandler&gt; chain)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(chain, <span class="string">&quot;handlerChain must not be null&quot;</span>);</span><br><span class="line">        RejectedExecutionHandler[] handlerChain = chain.toArray(<span class="keyword">new</span> RejectedExecutionHandler[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RejectedExecutionHandlerChain(handlerChain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RejectedExecutionHandlerChain</span><span class="params">(RejectedExecutionHandler[] handlerChain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handlerChain = Objects.requireNonNull(handlerChain, <span class="string">&quot;handlerChain must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (RejectedExecutionHandler rejectedExecutionHandler : handlerChain) &#123;</span><br><span class="line">            rejectedExecutionHandler.rejectedExecution(r, executor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pinpoint的拒绝策略实现很有特点，和其它的实现都不同。他定义了一个拒绝策略链，包装了一个拒绝策略列表，当触发拒绝策略时，会将策略链中的rejectedExecution依次执行一遍。</p>
<h2 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h2>
<p>总体过程如下图：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/20210826145615.png" alt="线程池运行示意图" style="zoom:50%;" />
<p>详细说明：</p>
<ul>
<li>如果线程还在运行的状态，就交由核心线程池执行</li>
<li>当线程池的核心线程数量用完，提交的任务会进入阻塞队列</li>
<li>当阻塞队列已满之后，要看是否大于最大线程数</li>
<li>如果阻塞队列已满，也超过了最大线程数量，就进入拒绝策略</li>
<li>如果阻塞队列已满，但是没有超过最大线程数量，就添加新的工作线程</li>
</ul>
<h1 id="java并发包中线程同步器"><a class="markdownIt-Anchor" href="#java并发包中线程同步器"></a> Java并发包中线程同步器</h1>
<h2 id="countdownlatch"><a class="markdownIt-Anchor" href="#countdownlatch"></a> CountDownLatch</h2>
<h3 id="案例介绍"><a class="markdownIt-Anchor" href="#案例介绍"></a> 案例介绍</h3>
<p>在日常开发中经常会遇到需要在主线程中开启多个线程去并行执行任务，并且主线程需要等待所有子线程执行完毕后再进行汇总的场景。在CountDownLatch出现之前一般都使用线程的join()方法来实现这一点，但是join方法不够灵活，不能够满足不同场景的需要，所以JDK提供了CountDownLatch这个类。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinCountDownLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;child threadOne over!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadTwo = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;child threadTwo over!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动子线程</span></span><br><span class="line">        threadOne.start();</span><br><span class="line">        threadTwo.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;wait all child thread over!&quot;</span>);</span><br><span class="line">        <span class="comment">// 等待所有子线程执行完毕，返回</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;all child thread over!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，主线程调用countDownLatch.await()方法会被阻塞，子线程执行完毕后调用countDownLatch.countDown()方法后计数器会变为0，这时候主线程的await()方法才会返回。</p>
<p>实际项目中，一般都避免直接操作线程，而是使用Executor线程池来管理。这个时候，无法直接调用这些线程的join()方法，必须要使用CountDownLatch：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinCountDownLatch2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;child threadOne over!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;child threadTwo over!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;wait all child thread over!&quot;</span>);</span><br><span class="line">        <span class="comment">// 等待所有子线程执行完毕，返回</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;all child thread over!&quot;</span>);</span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CountDownLatch和join方法的区别在于：</p>
<ul>
<li>调用子线程的join()方法，主线程会被一直阻塞直到子线程运行完毕，而CountDownLatch可以在子线程任何调用countDown()的地方返回，不一定要等到线程结束</li>
<li>使用线程池的时候，没有办法调用join方法，从这个角度而言，CountDownLatch相比join方法更加灵活</li>
</ul>
<h3 id="实现原理-2"><a class="markdownIt-Anchor" href="#实现原理-2"></a> 实现原理</h3>
<h2 id="cyclicbarrier"><a class="markdownIt-Anchor" href="#cyclicbarrier"></a> CyclicBarrier</h2>
<h3 id="案例介绍-2"><a class="markdownIt-Anchor" href="#案例介绍-2"></a> 案例介绍</h3>
<p>CountDownLatch的计数器是一次性的，也就是等到计数器值变为0后，在调用CountDownLatch的await和countdown方法都会立刻返回，这就起不到线程同步的效果了。为了满足计数器可以重置的需要，JDK提供了CyclicBarrier类，它可以让一组线程全部达到一个状态后再全部同时执行。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个CyclicBarrier实例，添加一个所有子线程全部达到屏障后执行的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;task1 merge result&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个线程个数固定为2的线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 将线程A添加到线程池</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;task1-1&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;enter in barrier&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;enter out barrier&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将线程B添加到线程池</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;task1-3&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;enter in barrier&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;enter out barrier&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码创建了一个CyclicBarrier对象，其第一个参数为计数器的初始值，第二个参数Runnable是当计数器值为0时需要执行的任务。在main函数里面首先创建了一个大小为2的线程池，然后添加两个子任务到线程池，每个子任务在执行完自己的逻辑后会调用await方法。一开始计数器值为2，当第一个线程调用await方法时，计数器值会递减为1。由于此时计数器值不为0，所以当前线程就到了屏障点而被阻塞。然后第二个线程调用await时，会进入屏障，计数器值也会递减，现在计数器值为0，这是就会去执行CyclicBarrier构造函数中的任务，执行完毕后退出屏障点，并且唤醒被阻塞的第二个线程，这时候第一个线程也会退出屏障点继续向下运行。</p>
<p>上述例子使用CountDownLatch也可以实现，但也有一些场景下，只能使用CyclicBarrier来完成。</p>
<p>假设一个任务由阶段1、阶段2和阶段2组成，每个线程都要串行地执行阶段1、阶段2和阶段3，当多个线程执行该任务时，必须要保证所有线程的阶段1全部完成后才能进入阶段2执行，当所有线程的阶段2全部完成后才能进入阶段3执行，使用CyclicBarrier的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StepCyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 将线程A添加到线程池</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;step1&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;step2&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;step3&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将线程B添加到线程池</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;step1&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;step2&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;step3&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在如上代码中，每个子线程在执行完成阶段1后都调用了await方法，等到所有线程都到达屏障点才会一块往下执行，这就保证了所有线程都完成了阶段1后才会开始执行阶段2。然后在阶段2后面调用了await方法，这保证了所有线程都完成了阶段2后，才能开始阶段3的执行。</p>
<h3 id="实现原理-3"><a class="markdownIt-Anchor" href="#实现原理-3"></a> 实现原理</h3>
<h2 id="semaphore"><a class="markdownIt-Anchor" href="#semaphore"></a> Semaphore</h2>
<h3 id="案例介绍-3"><a class="markdownIt-Anchor" href="#案例介绍-3"></a> 案例介绍</h3>
<p>Semaphore又称信号量，是操作系统中的一个概念，在Java并发编程中，信号量控制的是线程并发的数量。Semaphore可以控制某个资源可被同时访问的个数，acquire()获取一个许可，如果没有就等待，而release()释放了一个许可。比如在windows下可以设置共享文件的最大客户端访问个数。Semaphore维护了当前访问的个数，提供同步机制，控制同时访问的个数。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制某资源同时被访问的个数的类 控制同一时间最后只能有50个访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> timeout = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionTread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object connection = getConnection();</span><br><span class="line">                System.out.println(<span class="string">&quot;获取一个连接&quot;</span> + connection);</span><br><span class="line">                Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                releaseConnection(connection);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Object connection)</span> </span>&#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">            System.out.println(<span class="string">&quot;释放一个连接&quot;</span> + connection);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Object <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> getAcquire = semaphore.tryAcquire(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> (getAcquire) &#123;</span><br><span class="line">                    <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">500</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">new</span> ConnectionTread().start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="实现原理-4"><a class="markdownIt-Anchor" href="#实现原理-4"></a> 实现原理</h3>
<hr />
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>[1] <a href="https://segmentfault.com/a/1190000016586578">Java多线程进阶</a></p>
<p>[2] <a href="https://www.52doc.com/detail/3492">Java并发编程之美</a></p>
<p>[3] <a href="https://blog.csdn.net/sinat_36246371/article/details/53872412">Java并发编程中Semaphore的用法</a></p>
<p>[4] <a href="https://www.infoq.cn/article/bvpvyvxjkm8zstspti0l">Java AQS 核心数据结构 -CLH 锁</a></p>
<p>[5] <a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/2020/07/16/SpringCloud/</url>
    <content><![CDATA[<p>系统介绍SpringCloud的各种组件的使用和实现原理。</p>
<span id="more"></span>
<h1 id="feign中使用动态服务名"><a class="markdownIt-Anchor" href="#feign中使用动态服务名"></a> Feign中使用动态服务名</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicFeignClient</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FeignClientBuilder feignClientBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicFeignClient</span><span class="params">(<span class="meta">@Autowired</span> ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.feignClientBuilder = <span class="keyword">new</span> FeignClientBuilder(applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFeignClient</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; type, String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.feignClientBuilder.forType(type, serviceName).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依赖注入</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DynamicFeignClient&lt;ISysDictClient&gt; client;</span><br><span class="line"><span class="comment">// 获取到Feign客户端</span></span><br><span class="line">client.getFeignClient(ISysDictClient.class, serviceName).method(...);</span><br></pre></td></tr></table></figure>
<h1 id="feign的实现原理"><a class="markdownIt-Anchor" href="#feign的实现原理"></a> Feign的实现原理</h1>
<p><a href="https://www.cnblogs.com/binarylei/p/11563023.html">https://www.cnblogs.com/binarylei/p/11563023.html</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2020/07/16/SpringBoot/</url>
    <content><![CDATA[<p>SpringBoot是基于SpringFramework的企业级应用开发框架，有了SpringFramework的基础，相信理解SpringBoot并不是一件难事。</p>
<span id="more"></span>
<h1 id="springboot启动原理"><a class="markdownIt-Anchor" href="#springboot启动原理"></a> SpringBoot启动原理</h1>
<h2 id="springbootapplication"><a class="markdownIt-Anchor" href="#springbootapplication"></a> @SpringBootApplication</h2>
<p>在SpringBoot项目中，一般情况下都有且仅有一个启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中@SpringBootApplication注解是SpringBoot的核心注解，它其实是一个组合注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中重要的有三个Annotation：</p>
<ol>
<li>@Configuration（@SpringBootConfiguration也是应用了@Configuration）</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan</li>
</ol>
<p>即SpringBoot项目的启动类也可以这么写（优化SpringBoot项目的启动时间就可以将注解拆开来写，缩小包扫描的范围）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注解解析"><a class="markdownIt-Anchor" href="#注解解析"></a> 注解解析</h2>
<h3 id="configuration"><a class="markdownIt-Anchor" href="#configuration"></a> @Configuration</h3>
<p>这里的@Configuration与JavaConfig形式的Spring IoC容器的配置类使用的@Configuration注解作用相同，启动类加上这个注解之后，本身就变成了IoC容器的配置类。</p>
<p>@Configuration的注解类标识这个类可以使用Spring IoC容器作为Bean定义的来源。@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册为在Spring应用程序上下文中的Bean。</p>
<h3 id="componentscan"><a class="markdownIt-Anchor" href="#componentscan"></a> @ComponentScan</h3>
<p>@ComponentScan的功能是自动扫描并加载符合条件的组件（比如@Component和@Repository以及其他衍生注解）或者Bean定义，最终将这些Bean定义加载到IoC容器当中。</p>
<p>可以通过@ComponentScan的一些属性来进行细粒度的定制自动扫描的范围，如果不指定，Spring框架实现默认会从启动类所在的类的包进行扫描，所以启动类最好是放在所有的业务代码的外层，但如果要放在根目录（com包）下需要谨慎，低版本的SpringBoot会有一些兼容性的问题。</p>
<h3 id="enableautoconfiguration"><a class="markdownIt-Anchor" href="#enableautoconfiguration"></a> @EnableAutoConfiguration</h3>
<p>@EnableAutoConfiguration借助@Import的支持，收集和注册特定场景相关的Bean定义，在SpringBoot中还有一些与之类似的注解：</p>
<ul>
<li>@EnableScheduling是通过@Import将Spring调度框架相关的Bean定义都加载到IoC容器</li>
<li>@EnableMBeanExport是通过@Import将JMX相关的Bean定义加载到IoC容器</li>
<li>@EnableCaching是通过@Impotr将将缓存相关的Bean定义加载到IoC容器</li>
</ul>
<p>@EnableAutoConfiguration也是通过@Import将所有符合自动装配条件的Bean定义加载到IoC容器，会根据类路径中的jar依赖为项目进行自动配置，如：添加了spring-boot-starter-web依赖，会自动添加Tomcat和Spring MVC的依赖，SpringBoot会对Tomcat和Spring MVC进行自动配置。</p>
<p>@EnableAutoConfiguration作为一个组合注解，其自身定义关键信息如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借助AutoConfigurationImportSelector，SpringBoot可以将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器，借助Spring框架的一个工具类SpringFactoriesLoader，@EnableAutoConfiguration可以智能的完成自动配置的功能。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQzmAj46icFN8ATeAbRhibHNmvNLt8zniczDnVPEIvBHEDSv8WZ38hoSkXg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>在这其中，SpringFactoriesLoader扮演者十分重要的角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringFactoriesLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadFactories</span><span class="params">(Class&lt;T&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配合@EnableAutoConfiguration使用的话，它更多提供了一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名org.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找key，获取对应一组的@Configure类。</p>
<p>总的来说，@EnaleAutoConfiguration的作用是从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的配置项，通过反射实例化为标注了@Configuration的JavaConfig形式的IoC容器配置类，然后加载到IoC容器当中。</p>
<h2 id="启动执行流程"><a class="markdownIt-Anchor" href="#启动执行流程"></a> 启动执行流程</h2>
<h3 id="流程概览"><a class="markdownIt-Anchor" href="#流程概览"></a> 流程概览</h3>
<ol>
<li>使用SpringApplication的静态的run方法，而这个静态的run方法最终会调用SpringApplication实例的run方法，因此首先需要创建一个SpringApplication对象实例，然后调用这个创建号的SpringApplication的实例方法，在SpringApplication实例初始化的时候，它会提前做几件事情：
<ul>
<li>根据classpath里面是否存在某个特征类org.springframework.boot.ConfigurableWebApplicationContext来决定是否应该创建一个Web应用使用的ApplicationContext类型</li>
<li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可能的ApplicationContextInitializer</li>
<li>使用SpringFactories在应用的classpath中查找并加载所有可能的ApplicationListener</li>
<li>推断并设置main方法的定义类</li>
</ul>
</li>
<li>SpringApplication实例初始化完成并且完成设置后，就可以开始执行run方法的逻辑了，首先遍历执行所有通过SpringFactories可以查找到并加载的SpringApplicationRunListener，调用他们的started()方法</li>
<li>创建并配置当前SpringBoot应用将要使用的Environment（包括要使用的PropertySource以及Profile）、</li>
<li>调用所有的SpringApplicationRunListener的environmentPrepared()的方法</li>
<li>如果SpringApplication的showBanner属性被设置为true，则打印banner</li>
<li>根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，并且将之前准备好的Environment设置给创建好的ApplicationContext使用</li>
<li>ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理</li>
<li>遍历所有SpringApplicationRunListener的contextPrepared()方法</li>
<li>最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext</li>
<li>遍历调用所有SpringApplicationRunListener的contextLoaded()方法</li>
<li>调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序</li>
<li>查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们</li>
<li>正常情况下，遍历执行SpringApplicationListener的finished()方法（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将一场信息一并传入处理</li>
</ol>
<p>去掉事件通知点后，整体流程大体如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210624210942919.png" alt="image-20210624210942919" style="zoom:50%;" />
<p>简单一点，也可以将启动流程分为三个部分：</p>
<ol>
<li>第一部分进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器</li>
<li>第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块</li>
<li>第三部分是自动化配置模块，该模块是SpringBoot自动配置的核心。</li>
</ol>
<h3 id="启动详情"><a class="markdownIt-Anchor" href="#启动详情"></a> 启动详情</h3>
<p>首先进入run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource,</span></span></span><br><span class="line"><span class="params"><span class="function">		String... args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到调用了重载的run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources,</span></span></span><br><span class="line"><span class="params"><span class="function">		String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>依然是一个静态方法，这里首先要构造一个SpringApplication实例，然后再调用实例的run方法，这里的构造方法也有重载的版本，最终调用的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">   Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">   <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">   setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">         ApplicationContextInitializer.class));</span><br><span class="line">   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">   <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是为SpringApplication对象赋一些初值。构造函数执行完毕后，我们回到run方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">		StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">		stopWatch.start();</span><br><span class="line">		ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		configureHeadlessProperty();</span><br><span class="line">		SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">		listeners.starting();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">					args);</span><br><span class="line">			ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">					applicationArguments);</span><br><span class="line">			configureIgnoreBeanInfo(environment);</span><br><span class="line">			Banner printedBanner = printBanner(environment);</span><br><span class="line">			context = createApplicationContext();</span><br><span class="line">			exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">					SpringBootExceptionReporter.class,</span><br><span class="line">					<span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">			prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">					printedBanner);</span><br><span class="line">			refreshContext(context);</span><br><span class="line">			afterRefresh(context, applicationArguments);</span><br><span class="line">			stopWatch.stop();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">				<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">						.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">			&#125;</span><br><span class="line">			listeners.started(context);</span><br><span class="line">			callRunners(context, applicationArguments);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			listeners.running(context);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>该方法中有几个关键步骤：</p>
<ol>
<li>
<p>创建了应用的见同期SpringApplicationRunListeners并开始监听</p>
</li>
<li>
<p>加载SpringBoot配置环境（ConfigurableEnvironment），如果是通过Web容器发布，会加载StandardEnvironment，其最终也是集成了ConfigurableEnvironment，类图如下</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQurfYCoiaPsiaBBeBrCWOHMTHwl7mQ6iaYqKYMoRbT2bz6270LohsDndIg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
</li>
<li>
<p>配置环境（Environment）加入到监听器对象中（SpringApplicationRunListeners）</p>
</li>
<li>
<p>创建run方法的返回对象：ConfigurableApplicationContext（应用配置上下文），创建方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">	<span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line">			<span class="keyword">case</span> SERVLET:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> REACTIVE:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">					<span class="string">&quot;Unable create a default ApplicationContext, &quot;</span></span><br><span class="line">							+ <span class="string">&quot;please specify an ApplicationContextClass&quot;</span>,</span><br><span class="line">					ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法会先获取显示设置的应用上下文（appcationContextClass），如果不存在，再加载默认的环境配置（通过是否是web environment判断），默认选择AnnotationConfigApplicationContext注解上下文（通过扫描所有注解类来加载Bean），最后通过BeanUtils实例化上下文对象，并返回。</p>
</li>
<li>
<p>回到run方法内，prepareContext方法将listeners、enviroment、applicationArguments、banner等重要组件与上下文对象关联</p>
</li>
<li>
<p>加下来的refreshContext(context)方法（方法如下）是实现spring-boot-starter-*等自动化配置的关键，包括spring.factories的加载，bean的实例化等核心工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line">   </span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">   </span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">			initMessageSource();</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">			onRefresh();</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">			registerListeners();</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>配置结束后，SpringBoot做了一些基本的收尾工作，返回了应用环境上下文。总体而言，SpringBoot的启动，主要创建了配置环境（environment）、事件监听（listener）、应用上下文（applicationContex），并基于以上条件，在容器中开始实例化我们需要的Bean，最终完成SpringBoot的启动，这里面有一个核心就是自动化装配。</p>
<h3 id="自动装配"><a class="markdownIt-Anchor" href="#自动装配"></a> 自动装配</h3>
<p>在整个SpringBoot启动过程中，多出都调用了SpringBoot的自动装配模块</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQn8nK36PPIsEBpXXjQmX8ibniaohz5ahOYM5WnyicjgdYFa0Libxaztg6CQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>该配置模块主要使用到了SpringFactoriesLoader，即Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader，即需要传入上图中的工厂类名称对应的类加载器，方法会根据指定的classLoader，加载该类加载器搜索路径下的指定文件，即spring.factories文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为下入这种一对多的类型集合，或者到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQu9QicvqeO7RicwHibtCVtibnQHLmGxuKm0jw1ttR5mjBrqCIolBibRRo3icw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>自动配置流程如下：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210624211216303.png" alt="image-20210624211216303" style="zoom:50%;" />
<p><code>mybatis-spring-boot-starter</code>、<code>spring-boot-starter-web</code>等组件的META-INF文件下均含有<code>spring.factories</code>文件，自动配置模块中，<code>SpringFactoriesLoader</code>收集到文件中的类全名并返回一个类全名的数组，返回的类全名通过反射被实例化，就形成了具体的工厂实例，工厂实例来生成组件具体需要的bean。</p>
<p>之前我们提到了<code>EnableAutoConfiguration</code>注解，其类图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQr8IZpibDYUkTRzFA4j2WWw7YFiciaZevFuxH1oSxMd0Jr7drDmILq3YMw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>可以发现其最终实现了<code>ImportSelector</code>(选择器)和<code>BeanClassLoaderAware</code>(bean类加载器中间件)，重点关注一下<code>AutoConfigurationImportSelector</code>的<code>selectImports</code>方法。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQticdcJNNcF5hWVAA4a5xib1D3qhoRf1lW9xQibDxiavYj2Ieicvzq7od95w/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>该方法在springboot启动流程——bean实例化前被执行，返回要实例化的类信息列表。我们知道，如果获取到类信息，spring自然可以通过类加载器将类加载到jvm中，现在我们已经通过spring-boot的starter依赖方式依赖了我们需要的组件，那么这些组建的类信息在select方法中也是可以被获取到的，不要急我们继续向下分析。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQ7W4R5zDIcXoGv7Z12BlbAoqGQPGoR19rSFahPsiaqWfTLRqh7pZUQyA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>该方法中的<code>getCandidateConfigurations</code>方法，通过方法注释了解到，其返回一个自动配置类的类名列表，方法调用了<code>loadFactoryNames</code>方法，查看该方法</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQGplWq8vdg5cDrXzLPyKPUZxgG5f1mN7eDYFaqrPfygKGib9QCWsmFTQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>在上面的代码可以看到自动配置器会根据传入的<code>factoryClass.getName()</code>到项目系统路径下所有的<code>spring.factories</code>文件中找到相应的key，从而加载里面的类。我们就选取这个<code>mybatis-spring-boot-autoconfigure</code>下的<code>spring.factories</code>文件</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQBR85MD5HgVeib7Juia527ia5DedXvMDoZwibXtUvwIcIib3UsA1Z6eFKWgQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>进入<code>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</code>中，主要看一下类头：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQvDDF5STJSTOC9e5Nvou7NoyvgkdZHiam1ic8Hnz1cknuRM8lMLmVWicxw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>发现Spring的<code>@Configuration</code>，俨然是一个通过注解标注的springBean，继续向下看</p>
<ul>
<li><code>@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)</code>：当存在<code>SqlSessionFactory.class</code>, <code>SqlSessionFactoryBean.class</code>这两个类时才解析<code>MybatisAutoConfiguration</code>配置类，否则不解析这一个配置类，make sence，我们需要mybatis为我们返回会话对象，就必须有会话工厂相关类</li>
<li><code>@CondtionalOnBean(DataSource.class)</code>：只有处理已经被声明为bean的dataSource</li>
<li><code>@ConditionalOnMissingBean(MapperFactoryBean.class)</code>这个注解的意思是如果容器中不存在name指定的bean则创建bean注入，否则不执行（该类源码较长，篇幅限制不全粘贴）</li>
</ul>
<p>以上配置可以保证<code>sqlSessionFactory、sqlSessionTemplate、dataSource</code>等mybatis所需的组件均可被自动配置，<code>@Configuration</code>注解已经提供了Spring的上下文环境，所以以上组件的配置方式与Spring启动时通过mybatis.xml文件进行配置起到一个效果。</p>
<p>通过分析我们可以发现，只要一个基于SpringBoot项目的类路径下存在<code>SqlSessionFactory.class</code>, <code>SqlSessionFactoryBean.class</code>，并且容器中已经注册了dataSourceBean，就可以触发自动化配置，意思说我们只要在maven的项目中加入了mybatis所需要的若干依赖，就可以触发自动配置，但引入mybatis原生依赖的话，每集成一个功能都要去修改其自动化配置类，那就得不到开箱即用的效果了。</p>
<p>所以Spring-boot为我们提供了统一的starter可以直接配置好相关的类，触发自动配置所需的依赖(mybatis)如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQKZibKhZCCVt3rXV9LD20lGHnKkLVfVjicblW5KJUQJnjHicxDicjB1WGYQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>这里是截取的<code>mybatis-spring-boot-starter</code>的源码中pom.xml文件中所有依赖：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQTkmkxUoCMn3p5VBepEyVVA9YMKEiaJibrLsSDSeb1tibd20HiciauZx0S2w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>因为maven依赖的传递性，我们只要依赖starter就可以依赖到所有需要自动配置的类，实现开箱即用的功能。也体现出Springboot简化了Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。</p>
<h1 id="springboot打包"><a class="markdownIt-Anchor" href="#springboot打包"></a> SpringBoot打包</h1>
<h2 id="打包过程"><a class="markdownIt-Anchor" href="#打包过程"></a> 打包过程</h2>
<p>在Spring Boot应用中，我们可以约定不同的标识来定义不同的环境。例如 <code>dev</code> 表示开发环境、<code>test</code>表示测试环境，对应的配置文件为<code>application-dev.yaml</code>、<code>application-test.yaml</code>。我们通过声明<code>spring.profiles.active</code>来激活对应的环境配置，例如激活<code>dev</code>环境时<code>spring.profiles.active=dev</code>。完整的启动命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Djava.security.egd=file:/dev/./urandom  -Dspring.profiles.active=dev -jar spring-boot-app.jar </span><br></pre></td></tr></table></figure>
<p>根据上面的命令编写一个能够适应多环境的<strong>Dockerfile</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 引入 openjdk 镜像</span></span><br><span class="line">FROM adoptopenjdk/openjdk8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 声明作者</span></span><br><span class="line">LABEL AUTHOR=felord OG=felord.cn</span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载几个有用的文件夹 比如日志</span></span><br><span class="line">VOLUME [&quot;/tmp&quot;,&quot;/logs&quot;]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 声明一个环境参数用来动态启用配置文件 默认dev</span></span><br><span class="line">ENV ACTIVE=dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 暴露端口</span></span><br><span class="line">EXPOSE 8080</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制并修改应用打包后的jar文件名称</span></span><br><span class="line">ADD /target/flyway-spring-boot-1.0.0.jar app.jar</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器启动时第一个运行的命令 用来启动应用</span></span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-Dspring.profiles.active=$&#123;ACTIVE&#125;&quot;,&quot;-jar&quot;,&quot;app.jar&quot;]</span><br></pre></td></tr></table></figure>
<p>这样打包的Docker镜像就可以通过<code>docker run</code>添加额外的<code>--env ACTIVE=test</code> 来动态的改变环境。单纯的编写<strong>Dockerfile</strong>不方便我们DevOps。</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zuF5sJGRDCvwCLZQv6fq6zEjyuBXHd9C5licH3DdoibYfYXGaQOZMiaibyQdeoyHGibNRfiab5Z2Z9Es2jX8DickH4hJw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>我们需要能够自动地构建、推送到仓库、拉取镜像、运行一系列流水线操作。好在市面上有很多工具来帮助我们实现这一过程。</p>
<h2 id="构建工具"><a class="markdownIt-Anchor" href="#构建工具"></a> 构建工具</h2>
<h3 id="spring-boot-maven-plugin"><a class="markdownIt-Anchor" href="#spring-boot-maven-plugin"></a> spring-boot-maven-plugin</h3>
<p>这个是Spring Boot官方的插件，在2.x的某个版本提供了Docker镜像构建能力。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>docker.repo.com/library/$&#123;project.artifactId&#125;:$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">publish</span>&gt;</span>true<span class="tag">&lt;/<span class="name">publish</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">docker</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">publishRegistry</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">username</span>&gt;</span>user<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">password</span>&gt;</span>secret<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://docker.repo.com/v1/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">email</span>&gt;</span>user@example.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">publishRegistry</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">docker</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置好Docker私仓后就可以通过<code>mvn clean spring-boot:build-image</code> 进行构建镜像了，这种方式好处就是无额外依赖，缺点就是需要从github下载构建元件，网络如果不好就容易失败。</p>
<h3 id="spotify-maven-plugin"><a class="markdownIt-Anchor" href="#spotify-maven-plugin"></a> Spotify Maven Plugin</h3>
<p>Spotify Maven 插件是一个目前比较普遍的选择。它要求应用程序开发人员编写<strong>Dockerfile</strong>，并把<code>Dockerfile</code>放在项目<code>src/main/docker</code>目录下。然后你就可以通过引入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">repository</span>&gt;</span>repo.com/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个插件提供了<code>mvn dockerfile:build</code>、<code>mvn dockerfile:tag</code>、<code>mvn dockerfile:push</code>三个命令分别用来构建、打标签、发布到远端私有仓库，非常简单。</p>
<p>这个是一个非常容易上手的插件，唯一的要求就是需要会编写Dockerfile，对定制化要求高的可以使用这个。</p>
<h3 id="jib-maven-plugin"><a class="markdownIt-Anchor" href="#jib-maven-plugin"></a> Jib Maven Plugin</h3>
<p>它是谷歌开源的OCI镜像打包工具，可以用来打包Docker镜像，大部分情况下已经满足需要。但是如果你要定制化的话还是不容易的，需要阅读官方给的文档。最开始的<strong>Dockerfile</strong>如果使用<strong>JIb</strong>的话需要这样配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.cloud.tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jib-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">from</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">image</span>&gt;</span>adoptopenjdk/openjdk8<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">to</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">image</span>&gt;</span>docker.repo.com/library/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">auth</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">username</span>&gt;</span>felord<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxxxxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">auth</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tags</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tag</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tags</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extraDirectories</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">paths</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">from</span>&gt;</span>target/$&#123;project.artifactId&#125;-$&#123;project.version&#125;.jar<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">includes</span>&gt;</span>*.jar<span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">into</span>&gt;</span>/app.jar<span class="tag">&lt;/<span class="name">into</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extraDirectories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">containerizingMode</span>&gt;</span>packaged<span class="tag">&lt;/<span class="name">containerizingMode</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">volumes</span>&gt;</span>/tmp,/logs<span class="tag">&lt;/<span class="name">volumes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ports</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ports</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">environment</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entrypoint</span>&gt;</span></span><br><span class="line">                java,-Djava.security.egd=file:/dev/./urandom,-Dspring.profiles.active=$&#123;active&#125;,-jar,/app.jar</span><br><span class="line">            <span class="tag">&lt;/<span class="name">entrypoint</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">creationTime</span>&gt;</span>USE_CURRENT_TIMESTAMP<span class="tag">&lt;/<span class="name">creationTime</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>优点是不需要本地Docker环境，而且支持分层构建、镜像瘦身，上手容易；缺点是定制化比较困难。</p>
<h1 id="springboot项目docker打包体积优化"><a class="markdownIt-Anchor" href="#springboot项目docker打包体积优化"></a> SpringBoot项目docker打包体积优化</h1>
<h2 id="修改之前"><a class="markdownIt-Anchor" href="#修改之前"></a> 修改之前</h2>
<p>最开始使用的dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> WORK_PATH /home/project/cmp</span><br><span class="line"><span class="keyword">ENV</span> APP_NAME @project.build.finalName@.@project.packaging@</span><br><span class="line"><span class="keyword">ENV</span> APP_VERSION @project.version@</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#VOLUME</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;/home/project&quot;</span>, <span class="string">&quot;/tmp/data&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#COPY</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$APP_NAME</span> <span class="variable">$WORK_PATH</span>/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WORKDIR</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$WORK_PATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> SIMSUN.TTC  /usr/share/fonts/SIMSUN.TTC</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span>  /usr/share/fonts</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> fc-cache -fsv</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ENTRYPOINT</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;-Xmx512m&quot;</span>, <span class="string">&quot;@project.build.finalName@.@project.packaging@&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>由于这里直接使用java8的镜像，本身就有600多M，加上业务模块本身的大小，大约有了800多M，这样每次打包构建，非常的耗时，也很占用磁盘空间。</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210624210110566.png" alt="image-20210624210110566" /></p>
<h2 id="使用alpine镜像"><a class="markdownIt-Anchor" href="#使用alpine镜像"></a> 使用Alpine镜像</h2>
<p><code>Alpine Linux</code>操作系统是一个面向安全的轻型 <code>Linux</code> 发行版，<code>Alpine Docker</code> 镜像也继承了<code>Alpine Linux</code>发行版的这些优势，相比于其他Docker镜像，它的容量非常小，并且拥有自己的包管理机制，可以使用<code>apk</code> 包管理器替换 <code>apt</code> 工具，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apk add --no-cache &lt;package&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里我们使用Alpine提供的docker镜像：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210624210052799.png" alt="image-20210624210052799" /></p>
<p>因此这里我们使用<code>Alpine</code>镜像，并且将RUN的指令合并在一起，减少构建的层数，修改之后的dockerfile，：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> WORK_PATH /home/project/cmp</span><br><span class="line"><span class="comment"># 这里的都是maven内置的变量</span></span><br><span class="line"><span class="keyword">ENV</span> APP_NAME @project.build.finalName@.@project.packaging@</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$APP_NAME</span> <span class="variable">$WORK_PATH</span>/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WORKDIR</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$WORK_PATH</span></span></span><br><span class="line"><span class="comment"># 根据实际需求添加字体</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> simsun.ttc  /usr/share/fonts/simsun.ttc</span></span><br><span class="line"><span class="comment"># 为了解决docker容器内的时间和宿主机时间不一致的问题，并且安装了fontconfig，方便安装字体</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone &amp;&amp; apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ENTRYPOINT</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;-Xmx512m&quot;</span>, <span class="string">&quot;@project.build.finalName@.@project.packaging@&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<h2 id="分层构建镜像"><a class="markdownIt-Anchor" href="#分层构建镜像"></a> 分层构建镜像</h2>
<p>使用了<code>Alpine</code>镜像之后，项目的体积有了比较明显的改善，但是每次打包的时候还是会全量构建项目中的所有内容，构建的时间还是比较长，这里我们使用分层的机制来进行打包，这里要注意的是，使用的<code>SpringBoot</code>的版本必须要大于2.3.X。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine as builder</span><br><span class="line"><span class="keyword">ENV</span> APP_NAME @project.build.finalName@.@project.packaging@</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> application</span></span><br><span class="line"><span class="comment"># 注意这里对应的是编译后的dockerfile的目录，如果对应不上，可能会提示找不到文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$APP_NAME</span> application.jar</span></span><br><span class="line"><span class="comment"># 指定构建Jar的模式，并从Jar包中提取构建镜像所需的内容</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> java -Djarmode=layertools -jar application.jar extract</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> application</span></span><br><span class="line"><span class="comment"># 拷贝字体，这里安装宋体字体，alpine镜像会自动检测/usr/share/fonts是否含有字体</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> simsun.ttc  /usr/share/fonts/simsun.ttc</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/dependencies/ ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/snapshot-dependencies/ ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/spring-boot-loader/ ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/application/ ./</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=<span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 设置虚拟机参数</span></span><br><span class="line"><span class="keyword">ENV</span> JVM_OPTS=<span class="string">&quot;-XX:MaxRAMPercentage=80.0&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;java <span class="variable">$JVM_OPTS</span> <span class="variable">$JAVA_OPTS</span> org.springframework.boot.loader.JarLauncher&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>配置pom.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用本地Jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includeSystemScope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeSystemScope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layers</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span></span><br><span class="line">                true</span><br><span class="line">            <span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="maven中内置变量"><a class="markdownIt-Anchor" href="#maven中内置变量"></a> Maven中内置变量</h2>
<ul>
<li><code>$&#123;basedir&#125;</code> 项目根目录</li>
<li><code>$&#123;project.build.directory&#125;</code> 构建目录，缺省为target</li>
<li><code>$&#123;project.build.outputDirectory&#125;</code> 构建过程输出目录，缺省为target/classes</li>
<li><code>$&#123;project.build.finalName&#125;</code> 产出物名称，缺省为{project.artifactId}-${project.version}</li>
<li><code>$&#123;project.packaging&#125;</code> 打包类型，缺省为jar</li>
<li><code>$&#123;project.xxx&#125;</code> 当前pom文件的任意节点的内容</li>
</ul>
<h2 id="可能存在的问题"><a class="markdownIt-Anchor" href="#可能存在的问题"></a> 可能存在的问题</h2>
<ol>
<li>
<p>如果本身项目<code>SpringBoot</code>版本较低，不建议升级，推荐通过使用<code>Alpine</code>镜像以及优化dockerfile写法减少镜像体积，特别的，如果是使用的<code>Spring Cloud</code>，升级会出现组件版本不兼容的情况，可能需要升级诸多依赖的版本，并且需要投入精力进行测试验证。</p>
</li>
<li>
<p>如果项目不需要字体，可以跳过：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RUN apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/*</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果项目中只需要宋体，可以只复制字体文件到镜像内，而不需要安装fontconfig，<code>alpine</code>镜像会自动检测<code>/usr/share/fonts</code>是否含有字体：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">COPY simsun.ttc  /usr/share/fonts/simsun.ttc</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果项目中既需要宋体又需要其他字体（例如图片验证码），这是时候，拷贝宋体字体文件和安装fontconfig都需要：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">COPY simsun.ttc  /usr/share/fonts/simsun.ttc</span><br><span class="line">RUN apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/*</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果镜像打包的体积还是过大，可以使用<code>docker history image_name --no-trunc=true</code>命令来查看构建的详情。</p>
</li>
</ol>
<p>附完整的pom文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>application-$&#123;profiles.active&#125;.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>bootstrap.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>application.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--这里实我们的dockerfile文件所在的目录--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/docker<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/Dockerfile<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>../docker<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>static/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>bootstrap.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.json<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.ftl<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!--引用本地Jar包--&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">includeSystemScope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeSystemScope</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">layers</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span></span><br><span class="line">                          true</span><br><span class="line">                      <span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">layers</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 打包跳过测试 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 避免font文件的二进制文件格式压缩破坏 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>woff<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>woff2<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>eot<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>ttf<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>svg<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">delimiters</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">delimiter</span>&gt;</span>@<span class="tag">&lt;/<span class="name">delimiter</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">delimiters</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">useDefaultDelimiters</span>&gt;</span>false<span class="tag">&lt;/<span class="name">useDefaultDelimiters</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">id</span>&gt;</span>build-image<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">id</span>&gt;</span>push-image<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">goal</span>&gt;</span>push<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">imageName</span>&gt;</span></span><br><span class="line">                              $&#123;docker.repostory&#125;/$&#123;docker.registry.name&#125;/$&#123;project.artifactId&#125;:$&#123;profiles.active&#125;-$&#123;project.version&#125;</span><br><span class="line">                          <span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">serverId</span>&gt;</span>harbor<span class="tag">&lt;/<span class="name">serverId</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/docker<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">imageName</span>&gt;</span></span><br><span class="line">                      $&#123;docker.repostory&#125;/$&#123;docker.registry.name&#125;/$&#123;project.artifactId&#125;</span><br><span class="line">                  <span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">imageTags</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--docker的tag为项目版本号、latest--&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">imageTag</span>&gt;</span>$&#123;profiles.active&#125;-$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">imageTag</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">imageTags</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">rescource</span>&gt;</span><span class="comment">&lt;!-- 将打包文件放入dockerDirectory指定的位置 --&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">rescource</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2020/07/13/Functionalprogramming/</url>
    <content><![CDATA[<p>可以说，Java 8中新增功能是自Java发布以来，Java发生变化最大的一次，而函数式编程一直被认为是少数人的“游戏”，实际上函数式编程在近年来，在各个语言当中得到了大力的发展，掌握函数式编程的思想是必经的路途。本文希望在了解Java语言中函数式编程的核心思想之上，融会贯通，对函数式编程不再感到陌生和畏惧，而是变成编程兵器库的中的一把利器。</p>
<span id="more"></span>
<h1 id="函数式编程概览"><a class="markdownIt-Anchor" href="#函数式编程概览"></a> 函数式编程概览</h1>
<h2 id="函数式编程的意义"><a class="markdownIt-Anchor" href="#函数式编程的意义"></a> 函数式编程的意义</h2>
<p>JDK8或者说Java8是目前企业开发中最常用的JDK版本，Java8可谓Java语言历史上变化最大的一个版本，从这个版本开始，Java的编程向着函数式风格迈进，这有助于编写出更为简洁、表达力更强，并且在很多情况下能够利用并行运行的代码。但是很多人在使用Java8的时候，还是使用传统的面向对象的编程方式，这样在使用Java8的好处也仅仅停留在JVM带来的性能上的提升，而事实上Java8的新特性可以极大提升我们的开发效率。不仅如此，几乎所有的高级编程语言都支持了函数式编程的特性，掌握其中一门的设计理念与思想，在面对其他任何编程语言的函数式编程时，都能做到游刃有余。</p>
<p>在以往的使用传统面向对象的编程中，我们可能会编写这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">anonymousTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        JFrame jFrame = <span class="keyword">new</span> JFrame(<span class="string">&quot;My JFrame&quot;</span>);</span><br><span class="line">        JButton jButton = <span class="keyword">new</span> JButton(<span class="string">&quot;My Button&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用匿名内部类编程</span></span><br><span class="line">        jButton.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Button Pressed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        jFrame.add(jButton);</span><br><span class="line">        jFrame.pack();</span><br><span class="line">        jFrame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码我们实际上需要的其实只有System.out.println(“Button Pressed”)这一行，但却不得不编写很多没有实际意义的代码，如果改用函数式风格编程，我们的代码就变成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">anonymousTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        JFrame jFrame = <span class="keyword">new</span> JFrame(<span class="string">&quot;My JFrame&quot;</span>);</span><br><span class="line">        JButton jButton = <span class="keyword">new</span> JButton(<span class="string">&quot;My Button&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用函数式编程</span></span><br><span class="line">        jButton.addActionListener(e -&gt; System.out.println(<span class="string">&quot;Button Pressed&quot;</span>));</span><br><span class="line"></span><br><span class="line">        jFrame.add(jButton);</span><br><span class="line">        jFrame.pack();</span><br><span class="line">        jFrame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，瞬间代码的易读性提高了很多。再比如我们经常会用到的创建线程的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czxy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Lambda 在创建线程方面可以简化写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//原来的写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取执行前的毫秒值</span></span><br><span class="line">            <span class="keyword">long</span> old = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//执行一百千次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; <span class="number">100000</span>; a++) &#123;</span><br><span class="line">                <span class="comment">//原来的方式创建线程 实现Runnable接口 重写run方法</span></span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                thread.start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取执行后的毫秒值</span></span><br><span class="line">            <span class="keyword">long</span> newTime = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//获得消耗的时间</span></span><br><span class="line">            <span class="keyword">long</span> i = newTime - old;</span><br><span class="line">            System.out.println(<span class="string">&quot;创建100000个花费的总毫秒值&quot;</span>+i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用Lambda表达式的新写法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//获取执行前的毫秒值</span></span><br><span class="line">        <span class="keyword">long</span> old1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a =<span class="number">0</span>; a&lt;<span class="number">100000</span>; a++)&#123;</span><br><span class="line">            Thread threadLambda = <span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;使用Lambda创建了线程了&quot;</span>));</span><br><span class="line">            threadLambda.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取执行后的毫秒值</span></span><br><span class="line">        <span class="keyword">long</span> newTime1 = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//获得消耗的时间</span></span><br><span class="line">        <span class="keyword">long</span> i1 = newTime1 - old1;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda创建100000个花费的总毫秒值&quot;</span>+i1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出，Lambda表达式在简化代码上，是非常有效的。</p>
<h2 id="lambda表达式和匿名内部类"><a class="markdownIt-Anchor" href="#lambda表达式和匿名内部类"></a> Lambda表达式和匿名内部类</h2>
<p>Lambda表达式看起来特别像是Java中匿名内部类的一种特殊写法，对于初学者而言，暂时不妨可以认为Lambda表达式就是匿名内部类的一种新的写法，或者说是一种语法糖。下面通过一个例子来说明，Lambda表达式就是一种全新的语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    Runnable r1 = () -&gt; System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    Runnable r2 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LambdaTest lambdaTest = <span class="keyword">new</span> LambdaTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(lambdaTest.r1);</span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(lambdaTest.r2);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream2.LambdaTest@362872a1</span><br><span class="line">Stream2.LambdaTest$1@60c8c409</span><br></pre></td></tr></table></figure>
<p>首先来看第二行，它表示当前对象指的是LambdaTest$1，在Java中表示匿名内部类会使用类名称+&quot;$&quot;+顺序的方式来表示，&quot;@&quot;后面的表示类的哈希值，而第一个Lamda表达式所打印的就是当前类LambdaTest的地址，这说明使用Lambda表达式的这种方式与它所在的类是同一个作用域。</p>
<p>通过这个例子说明了Lambda表达式与匿名内部类有着本质的区别，两者是完全不同的，并不是匿名内部类的语法糖或者另一种表达形式，只不过在某些场景下，可以使用Lambda表达式来替代匿名内部类完成相同的功能。</p>
<p>实际上，使用Lambda表达式所带来的好处其实远不止简化代码，它还可以为我们带来代码执行效率上的提升，所以，无论是出于开发效率，还是代码的执行速度上来看，都应该使用Lambda表达式。</p>
<h2 id="lambda表达式和stream"><a class="markdownIt-Anchor" href="#lambda表达式和stream"></a> Lambda表达式和Stream</h2>
<p>在实际使用中，Lambda表达式往往与Stream相互配合，才会发挥其特性，通常用来高效的处理一些集合的运算。</p>
<p>我们首先从遍历打印集合中元素这样非常常见的例子开始，以往遍历集合通常的做法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>或者使用传统的for循环来遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Lambda表达式我们可以将上述代码优雅的表示为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;hello world&quot;</span>);\</span><br><span class="line">        </span><br><span class="line">        list.forEach((String x) -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，对于变量前面的类型，也是可以省略的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.forEach(x-&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为编译器可以自动推断出当前遍历集合当前元素的类型，但并不是在所有的场景下，编译器都可以自动推断类型，在后续的文章中，我们就会遇到编译器无法自动推断，需要我们手动声明变量类型的情况。</p>
<p>这里我们先不去考虑Lambda表达式具体的语法，先从直观的角度来感受函数式编程带来的好处，原本三行的代码现在仅仅需要一行就能实现，如果使用方法引用甚至能够让代码变的更加简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        strings.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">::</span><br></pre></td></tr></table></figure>
<p>也是java8中新增的一个语法糖。后续的文章我们有专门的篇幅来介绍方法引用，使用方法引用可以写出更加简洁优雅的代码。</p>
<p>看了这么几个例子，你可能很疑惑，到底什么是Lambda表达式呢？在回答这个问题之前，我们首先需要了解我们为什么需要需要Lambda表达式。</p>
<p>在以往的Java中，方法可以参数的传递总共有两种，一种是传递值，另有一种是传递引用，或者说对象的地址，但是我们无法将函数作为参数传递给一个方法，也无法声明返回一个函数的方法，而在其他语言中，比如面向函数式编程语言JavaScript中，函数的参数是一个函数，返回值是另一个函数的情况是非常常见的（回调函数），例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">images_upload_handler: <span class="function"><span class="keyword">function</span>(<span class="params">blobInfo, success, failure</span>) </span>&#123;</span><br><span class="line">       success(...)</span><br><span class="line">       failure(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数总共接收三个参数，第一个参数就是一个普通的变量，success就是这个函数执行成功的回调函数，failure就是这个函数执行失败的回调函数。可以说，JavaScript是一门非常典型的函数式语言。而使用Lambda表达式就可以实现传递行为这种高阶函数（参数可以接收行为的方法们就称这个方法为高阶函数）的使用。</p>
<p>当然Lambda表达式肯定不止只是能用来遍历集合这个简单，实际上，更多的情况下，我们都是需要配合Stream（流）来实现各种各样的操作。对于前面使用Lambda表达式来实现集合遍历的例子还可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.forEach(item-&gt; System.out.println(item));</span><br><span class="line">        </span><br><span class="line">        list.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来只是增加了一步，将list这个集合转化为了Stream，但是两者的实现有着本质的区别。我们可以简单的了解一下他们之前的区别。<br />
对于第一种：<br />
可以看到<code>list.forEach</code>实际上是调用Iterable这个类中jdk1.8新增的forEach方法，我们都知道List本身继承了Collection集合接口，而Collection接口又继承了Iterable这个类，所以可以完成调用，方法实现本身并没有特别复杂的地方，其实本质上看起来和我们传统的使用迭代器的方式并没有区别，接下来，我们查看一下第二种方式：<br />
首先同样的是在Collection接口中新增加了一个default method（我们称之为默认方法），在jdk1.8中接口是又具体的方法实现，实际上对于java这一门非常庞大臃肿的语言，为了向函数式编程迈进，jdk的设计者匠心独具，设计非常巧妙。这个方法将返回了一个新的对象Stream，并且调用了StreamSupport这个类中的stream（）方法：<br />
追踪下去，我们也可以看到，同样的也是一个名叫forEach的方法，但其实这里的forEach()方法与之前的forEach（）方法存在本质的差别，这里的forEach实际上表示一种终止操作，而jdk会在集合进行流操作的时候，调用终止操作。</p>
<p>在这两个方法中都接受一个<code>Consumer&lt;? super T&gt; action</code> 这样的一个参数，实际上，对于java而言，为了实现函数式编程，java引入了一个全新的概念：函数式接口，它是java实现整个函数式编程的手段，也是函数式编程中一个及其重要的概念，这个概念会贯穿整个函数式编程的全过程，理解了函数式接口，才能Lambda表达式真正的含义，接下来的时间，我们非常有必要首来认识一下，什么是函数式接口。</p>
<h1 id="函数式接口"><a class="markdownIt-Anchor" href="#函数式接口"></a> 函数式接口</h1>
<p>函数式接口是函数式编程中最重要的概念，函数式编程与传统的编码方式相比最明显的区别就是，它允许把函数（或者说表达式）当成参数传递给另一个函数，在其他编程语言中，Lambda表达式的类型是函数，但在Java中，Lambda表达式是对象，他们必须依附于一类特别的对象–函数式接口（functional interface）。</p>
<h2 id="函数式接口定义"><a class="markdownIt-Anchor" href="#函数式接口定义"></a> 函数式接口定义</h2>
<p>在之前的这个例子中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.forEach(item-&gt; System.out.println(item));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击箭头就会进入到一个接口当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个接口上有一个@FunctionInterface的注解，点击这个注解进入，就可以看到这样一段JavaDoc:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An informative annotation type used to indicate that an interface</span></span><br><span class="line"><span class="comment"> * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as</span></span><br><span class="line"><span class="comment"> * defined by the Java Language Specification.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Conceptually, a functional interface has exactly one abstract</span></span><br><span class="line"><span class="comment"> * method.  Since &#123;<span class="doctag">@linkplain</span> java.lang.reflect.Method#isDefault()</span></span><br><span class="line"><span class="comment"> * default methods&#125; have an implementation, they are not abstract.  If</span></span><br><span class="line"><span class="comment"> * an interface declares an abstract method overriding one of the</span></span><br><span class="line"><span class="comment"> * public methods of &#123;<span class="doctag">@code</span> java.lang.Object&#125;, that also does</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;not&lt;/em&gt; count toward the interface&#x27;s abstract method count</span></span><br><span class="line"><span class="comment"> * since any implementation of the interface will have an</span></span><br><span class="line"><span class="comment"> * implementation from &#123;<span class="doctag">@code</span> java.lang.Object&#125; or elsewhere.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that instances of functional interfaces can be created with</span></span><br><span class="line"><span class="comment"> * lambda expressions, method references, or constructor references.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a type is annotated with this annotation type, compilers are</span></span><br><span class="line"><span class="comment"> * required to generate an error message unless:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The type is an interface type and not an annotation type, enum, or class.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The annotated type satisfies the requirements of a functional interface.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;However, the compiler will treat any interface meeting the</span></span><br><span class="line"><span class="comment"> * definition of a functional interface as a functional interface</span></span><br><span class="line"><span class="comment"> * regardless of whether or not a &#123;<span class="doctag">@code</span> FunctionalInterface&#125;</span></span><br><span class="line"><span class="comment"> * annotation is present on the interface declaration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 4.3.2. The Class Object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.8 Functional Interfaces</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.4.3 Interface Method Body</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们一行一行来仔细阅读一下这段文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An informative annotation type used to indicate that an interface</span><br><span class="line">type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as</span><br><span class="line">defined by the Java Language Specification.</span><br></pre></td></tr></table></figure>
<p>这里说，@FunctionInterface这个注解，它使用Java语言规范定义，使用通知性的annotation,来声明函数式接口，换言之，如果一个接口上使用了@FunctionInterface这个注解，那么这个接口就是函数式接口。</p>
<p>那么到底什么是函数式接口呢？继续往下看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Conceptually, a functional interface has exactly one abstract</span><br><span class="line">method.  Since &#123;@linkplain java.lang.reflect.Method#isDefault()</span><br><span class="line">default methods&#125; have an implementation, they are not abstract.  If</span><br><span class="line">an interface declares an abstract method overriding one of the</span><br><span class="line">public methods of &#123;@code java.lang.Object&#125;, that also does &lt;em&gt;not&lt;/em&gt; count toward the interface&#x27;s abstract method count since any implementation of the interface will have an implementation from &#123;@code java.lang.Object&#125; or elsewhere.</span><br></pre></td></tr></table></figure>
<p>一个函数式接口，它只有一个精确的抽象方法，也就是说，有且仅有一个抽象方法，那么这个接口就被称为函数式接口（在jdk8中，除了抽象方法外还可以定义default method和static method，不一定都是抽象方法），并且如果这个抽象方法是Object类中的方法，不会计入这个接口的抽象方法数量。需要注意的是，可以通过Lambda表达式来创建，方法引用来创建，或者构造方法的引用来创建函数式接口的实例。</p>
<p>关于Lambda表达式的创建会在后续的文章中详细讲解，这里只需要大概了解函数式接口实例创建的方式有这么三种。我们继续往下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Note that instances of functional interfaces can be created with</span><br><span class="line">lambda expressions, method references, or constructor references.</span><br><span class="line"> </span><br><span class="line">&lt;p&gt;If a type is annotated with this annotation type, compilers are</span><br><span class="line">required to generate an error message unless:</span><br><span class="line"> </span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt; The type is an interface type and not an annotation type, enum, or class.</span><br><span class="line">&lt;li&gt; The annotated type satisfies the requirements of a functional interface.</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;p&gt;However, the compiler will treat any interface meeting the</span><br><span class="line">definition of a functional interface as a functional interface</span><br><span class="line">regardless of whether or not a &#123;@code FunctionalInterface&#125;</span><br><span class="line">annotation is present on the interface declaration.</span><br></pre></td></tr></table></figure>
<p>如果一个接口上有@FunctionInterface这个注解，如果不满足以下情况编译器会报错：</p>
<ul>
<li>被注解的是一个接口类型，而不是一个注解类型，而是枚举或者类；</li>
<li>被注解的类型满足函数式接口的定义；</li>
</ul>
<p>例如，创建线程时需要用到的Runnable接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个接口从JDK8开始就加上了@FunctionalInterface这个注解，换句话说，Runnable接口现在变成了函数式接口，我们可以通过Lambda表达式来创建Runnable接口的实例。</p>
<p>在上面的文档中，还有最后一段话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;However, the compiler will treat any interface meeting the</span><br><span class="line">definition of a functional interface as a functional interface</span><br><span class="line">regardless of whether or not a &#123;@code FunctionalInterface&#125;</span><br><span class="line">annotation is present on the interface declaration</span><br></pre></td></tr></table></figure>
<p>然而，编译器其实会自动为满足函数式接口定义的接口添加@FunctionalInterface注解，也就是说，如果一个接口满足了函数式接口的定义，即便我们没有给他加上@FunctionalInterface这个注解，编译器会自动将它看成是函数式接口。</p>
<p>总的来说，关于函数式接口的定义如下：</p>
<p>1.如果一个接口只有一个抽象方法，那么该接口就是一个函数式接口<br />
2.如果我们在某个接口上声明了FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口<br />
3.如果某个接口只有一个抽象方法，但我们并没有对该接口声明FunctionalInterface注解，编译器依旧会将该接口看作是函数式接口。</p>
<p>再以这个接口为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在这个接口中，除了一个抽象方法accept()方法外，还有一个default默认方法andThen()，但是总的来说还是只有一个抽象方法，所以满足函数式接口的定义。</p>
<p>再比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，这个接口中只有一个抽象方法test()，除此之外，有3个default默认方法，有一个static方法，因此同样满足函数式接口的定义。</p>
<p>再比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口中看起来有两个抽象方法，但toString()方法是基类Object中的方法，因此在检查函数式接口的定义的时候，它并不算数，因为Object类是所有类的父类，所有的类默认已经有了这个方法，如果算的话，其实是没有意义的，所以在定义函数式接口的时候，Object类中方法并不会对函数式接口的方法的数量变化。</p>
<p>在JDK8中的提供了大量的现成的函数式接口供我们使用，以之前我们使用forEach()为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实forEach()方法接收的函数式接口就是我们上面举得第一个例子Consumer，然后调用Consumer接口中的accept方法，诸多的函数式接口，为我们方便的传递各种不同需求的行为提供了可能。</p>
<h2 id="为什么是函数式接口"><a class="markdownIt-Anchor" href="#为什么是函数式接口"></a> 为什么是函数式接口？</h2>
<p>在前面我们了解了函数式接口的概念之后，我们来具体看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterfaceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个接口，MyInterface，这个接口中有两个抽象方法，但由于toString()是继承自Obeject类中的方法，所以并不会对这个接口的抽象方法的总数有影响，还是只有一个抽象方法，那么显然，它满足函数式接口的定义。</p>
<p>首先我们使用传统的匿名内部类的方式来实现MyInterface中的test()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterfaceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyTest</span><span class="params">(MyInterface myInterface)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        myInterface.test();</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionalInterfaceTest functionalInterfaceTest = <span class="keyword">new</span> FunctionalInterfaceTest();</span><br><span class="line">        functionalInterfaceTest.MyTest(<span class="keyword">new</span> MyInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;myTest&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyInterface既然满足函数式接口的定义，那么就意味着我们可以使用Lambda表达式的方式来创建MyInterface的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterfaceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyTest</span><span class="params">(MyInterface myInterface)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        myInterface.test();</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionalInterfaceTest functionalInterfaceTest = <span class="keyword">new</span> FunctionalInterfaceTest();</span><br><span class="line">        functionalInterfaceTest.MyTest(() -&gt; System.out.println(<span class="string">&quot;myTest&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种写法的运行结果完全是等价的，编译器会自动根据上下文，来推测出 functionalInterfaceTest.MyTest()中需要接收的参数的类型，也就是说，() -&gt; System.out.println(“myTest”)就是MyInterface 的一个实例，由于函数式接口中只会有一个抽象方法，那么对于这个Lambda表达式而言，箭头左边的部分，一定就是MyInterface 这个接口中唯一的抽象方法test()的参数，右边的部分，一定就是MyInterface 这个接口中唯一的抽象方法test()的实现，由于test()方法的参数是空值，所以左边的括号是空值。</p>
<p>这样看起来，其实MyInterface 这个接口中的抽象方法，具体叫什么名字，反而没有那么重要了，当然虽然这个函数的名字我们并不会直接去调用，但在起名字的时候，最好还是要有意义。</p>
<p>可能初学者并不能直观的认识到() -&gt; System.out.println(“myTest”)表达的具体含义，我们可以换一种写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterfaceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyTest</span><span class="params">(MyInterface myInterface)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        myInterface.test();</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionalInterfaceTest functionalInterfaceTest = <span class="keyword">new</span> FunctionalInterfaceTest();</span><br><span class="line">        MyInterface myInterface = () -&gt; System.out.println(<span class="string">&quot;myTest&quot;</span>)</span><br><span class="line">        functionalInterfaceTest.MyTest(myInterface);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行的效果是完全等价的，使用这种写法，我们就更能直观的体会到，() -&gt; System.out.println(“myTest”)其实就是MyInterface的一个具体实现。</p>
<p>前面我们提到过，在Java中，Lambda表达式需要依赖于函数式接口这样一种特殊的形式，所以为什么是函数式接口呢？或者说为什么需要函数式接口呢？简而言之，Java是纯面向对象的语言，方法无法脱离类或者接口单独存在，因此在Java中，函数式编程必须依附这样一类特殊的对象：函数式接口。</p>
<p>实际上，对于一个特定的Lambda表达式是什么类型的，是需要上下文才能解读的，来看这样一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Essence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        InterfaceTestA interfaceTestA = () -&gt; &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        InterfaceTestB interfaceTestB = () -&gt; &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceTestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceTestB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myMethod2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对于这两个不同的函数式接口的实现都是() -&gt; {}这同一种实现，对于这个特定的Lambda表达式，必须要联系他的上下文才能知道：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InterfaceTestA interfaceTestA</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InterfaceTestB interfaceTestB</span><br></pre></td></tr></table></figure>
<p>就是这两个Lambda表达式的上下文。</p>
<p>我们再回到遍历List集合的例子中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.forEach(item-&gt; System.out.println(item));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击forEach方法，就会自动跳转到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs the given action for each element of the &#123;<span class="doctag">@code</span> Iterable&#125;</span></span><br><span class="line"><span class="comment"> * until all elements have been processed or the action throws an</span></span><br><span class="line"><span class="comment"> * exception.  Unless otherwise specified by the implementing class,</span></span><br><span class="line"><span class="comment"> * actions are performed in the order of iteration (if an iteration order</span></span><br><span class="line"><span class="comment"> * is specified).  Exceptions thrown by the action are relayed to the</span></span><br><span class="line"><span class="comment"> * caller.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implSpec</span></span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation behaves as if:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *     for (T t : this)</span></span><br><span class="line"><span class="comment"> *         action.accept(t);</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action The action to be performed for each element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified action is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先它是一个默认方法，接收的参数类型是Consumer，遍历这个集合，对集合中的每个元素执行Consumer中的accept()方法。</p>
<p>不妨来读一下这段文档：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Performs the given action for each element of the &#123;@code Iterable&#125;</span><br><span class="line">until all elements have been processed or the action throws an</span><br><span class="line">exception.  Unless otherwise specified by the implementing class,</span><br><span class="line">actions are performed in the order of iteration (if an iteration order</span><br><span class="line">is specified).  Exceptions thrown by the action are relayed to the</span><br><span class="line">caller</span><br></pre></td></tr></table></figure>
<p>针对于Iterable每一个元素去执行给定的动作，换句话说，这里并不是将值作为参数，而是将行为作为参数进行传递，执行到集合中所有的元素执行完或者抛出异常为止，如果没有被实现类所指定的话，那么动作就会按照迭代的顺序去执行，是不是抛出异常取决于调用者。</p>
<p>其实这里最关键的就是Consumer这个参数，接下来我们重点分析Consumer这个函数式接口。</p>
<h2 id="常见的函数式接口"><a class="markdownIt-Anchor" href="#常见的函数式接口"></a> 常见的函数式接口</h2>
<h3 id="consumer函数式接口"><a class="markdownIt-Anchor" href="#consumer函数式接口"></a> Consumer函数式接口</h3>
<p>首先我们观察Consumer这个接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents an operation that accepts a single input argument and returns no</span></span><br><span class="line"><span class="comment"> * result. Unlike most other functional interfaces, &#123;<span class="doctag">@code</span> Consumer&#125; is expected</span></span><br><span class="line"><span class="comment"> * to operate via side-effects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #accept(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the operation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs, in sequence, this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation. If performing either</span></span><br><span class="line"><span class="comment">     * operation throws an exception, it is relayed to the caller of the</span></span><br><span class="line"><span class="comment">     * composed operation.  If performing this operation throws an exception,</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> after&#125; operation will not be performed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the operation to perform after this operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs in sequence this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> after&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@since 1.8</span><br></pre></td></tr></table></figure>
<p>这个接口是从JDK1.8才开始有的，consumer这个单词本身的意思是消费者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Represents an operation that accepts a single input argument and returns no</span><br><span class="line">result. Unlike most other functional interfaces, &#123;@code Consumer&#125; is expected</span><br><span class="line">to operate via side-effects.</span><br></pre></td></tr></table></figure>
<p>Consumer代表了一种接收单个输入并且不返回结果的操作，与大多数其他的函数式接口不同的是，它可能会有副作用。</p>
<div class="note info"><p>这里的副作用指的是可能会修改传入参数的值。</p></div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is a functional interface whose functional method is &#123;@link #accept(Object)&#125;.</span><br></pre></td></tr></table></figure>
<p>这是一个函数式接口，接口中的抽象方法是accept()。<br />
对于前面List集合遍历的例子，  我们可以通过匿名内部类的方式来操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.forEach(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于所有的匿名内部类又可以使用Lambda表达式来进行替换，所以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.forEach(item-&gt; System.out.println(item));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里因为类型推断的原因，编译器会自动推断Item的数据类型，所以无需说明item的类型。</p>
<h3 id="function函数式接口"><a class="markdownIt-Anchor" href="#function函数式接口"></a> Function函数式接口</h3>
<p>java8为我们了提供了很多的函数式接口，Function就是其中一个，首先我们来读一下它的javaDoc：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a function that accepts one argument and produces a result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #apply(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; the type of the result of the function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment">     * function to its input, and then applies this function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of input to the &#123;<span class="doctag">@code</span> before&#125; function, and to the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> before the function to apply before this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment">     * function and then applies this function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if before is null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #andThen(Function)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment">     * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment">     * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #compose(Function)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a function that always returns its input argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input and output objects to the function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a function that always returns its input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，与之前介绍的Consumer函数一样，都是一个函数式接口，都是从JDK8开始提供的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Represents a function that accepts one argument and produces a result.</span><br><span class="line"> </span><br><span class="line">&lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span><br><span class="line">whose functional method is &#123;@link #apply(Object)&#125;.</span><br><span class="line"> </span><br><span class="line">@param &lt;T&gt; the type of the input to the function</span><br><span class="line">@param &lt;R&gt; the type of the result of the function</span><br></pre></td></tr></table></figure>
<p>Function提供了一个接收一个参数并且返回一个结果的函数，它的抽象方法是apply()，&lt;T,R&gt;分别表示输入参数的类型和返回结果的类型。</p>
<p>我们来看一个具体的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionTest functionTest = <span class="keyword">new</span> FunctionTest();</span><br><span class="line">        System.out.println(functionTest.compute(<span class="number">1</span>, value -&gt; <span class="number">2</span> * value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = function.apply(a);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其中最关键的地方在于，compute的function参数传递的是一种行为，而不再是传统的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionTest functionTest = <span class="keyword">new</span> FunctionTest();</span><br><span class="line">        System.out.println(functionTest.compute(<span class="number">1</span>, value -&gt; <span class="number">2</span> * value));</span><br><span class="line">        System.out.println(functionTest.compute(<span class="number">2</span>, value -&gt; value * value));</span><br><span class="line">        System.out.println(functionTest.compute(<span class="number">3</span>, value -&gt; <span class="number">3</span> + value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = function.apply(a);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们其实只定义了一个函数，每次只需要将我们的所定义好的行为，传入即可，这是与非函数式编程最大的区别。</p>
<p>来看一个输入参数与返回结果参数类型不一致的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FunctionTest &#123;</span><br><span class="line"></span><br><span class="line">    public int method1(int a) &#123;</span><br><span class="line">        return 2 * a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int method2(int a) &#123;</span><br><span class="line">        return a * a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int method3(int a) &#123;</span><br><span class="line">        return 3 + a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当有一种新的操作，我们就不得不定义一个新的函数，因为行为总是被预先定义好的，定义好行为之后我们再去调用。但是使用Lambda表达式，行为是调用的时候才动态的调用执行，这与之前的面向对象的编程方式是完全不同的。</p>
<p>这里还需要简单提及一下高阶函数，如果一个函数接收一个函数作为参数，或者返回一个函数作为返回值，那么该函数就叫做高阶函数。</p>
<p>比如我们上面给出的例子中的compute()方法，convert()方法就是高阶函数。</p>
<p>在Function接口中，还有两个默认方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment"> * function to its input, and then applies this function to the result.</span></span><br><span class="line"><span class="comment"> * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment"> * the caller of the composed function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of input to the &#123;<span class="doctag">@code</span> before&#125; function, and to the</span></span><br><span class="line"><span class="comment"> *           composed function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> before the function to apply before this function is applied</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment"> * function and then applies this function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if before is null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #andThen(Function)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(before);</span><br><span class="line">    <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>compose()这个函数返回的是一个复合函数，这个复合函数首先应用before这个Function，然后再去对这个结果应用当前的Function，如果当中任何一个Function抛出了异常，它取决于调用这个怎么去处理这个异常。</p>
<p>参数before指的是在应用这个函数之前所要应用的当前的函数的函数，首先会应用before这个Function，然后再应用当前的Function。</p>
<p>cmpose()这个方法其实是将两个Function进行了组合，首先调用传入的Function的apply()方法，然后再调用当前的Function的apply()方法。这么做实现了两个函数式接口的串联，实际上也可以n个的串联。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment"> * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment"> * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment"> * the caller of the composed function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment"> *           composed function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment"> * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #compose(Function)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>andThen()这个方法刚好是反过来的，首先会应用当前的Function，然后再去对应用当前的这个对象的Function。</p>
<p>最后这个方法就比较简单了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a function that always returns its input argument.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt; the type of the input and output objects to the function</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> a function that always returns its input argument</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>它总是返回输入的变量。identity本身的意思也就是同一性，下面我们通过具体的例子来说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionTest functionTest = <span class="keyword">new</span> FunctionTest();</span><br><span class="line">        System.out.println(functionTest.compute(<span class="number">2</span>, value -&gt; value * <span class="number">3</span>, value -&gt; value * value));</span><br><span class="line">        System.out.println(functionTest.compute2(<span class="number">2</span>, value -&gt; value * <span class="number">3</span>, value -&gt; value * value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function1.compose(function2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute2</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function1.andThen(function2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Function接口中的apply()方法而言，它只接受一个参数，并返回一个结果，如果想输入两个参数并返回结果，显然它是做不到的，再JDK中有这样一个函数式接口BiFunction：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment">     * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment">     * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">BiFunction&lt;T, U, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; after.apply(apply(t, u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bi实际上是Bidirectional的缩写，这个单词本身的含义是双向的意思。BiFunction这个函数式接口的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Represents a function that accepts two arguments and produces a result.</span><br><span class="line"> * This is the two-arity specialization of &#123;@link Function&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span><br><span class="line"> * whose functional method is &#123;@link #apply(Object, Object)&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;T&gt; the type of the first argument to the function</span><br><span class="line"> * @param &lt;U&gt; the type of the second argument to the function</span><br><span class="line"> * @param &lt;R&gt; the type of the result of the function</span><br><span class="line"> *</span><br><span class="line"> * @see Function</span><br><span class="line"> * @since 1.8</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>接收两个参数并且返回一个结果，它是Function接口的一种特殊形式，有三个泛型，T，U分别是两个接收的参数的类型，R是返回的结果的类型。</p>
<p>如果我们想定义四则运算的话，使用传统的方式，我们可能会写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiFunctionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察不难发现，四则运算正好就是输入两个参数，返回一个结果，正好满足BiFunction的定义，现在我们使用BiFunction来实现同样的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiFunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BiFunctionTest biFunctionTest = <span class="keyword">new</span> BiFunctionTest();</span><br><span class="line">        System.out.println(biFunctionTest.compute(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 + value2));</span><br><span class="line">        System.out.println(biFunctionTest.compute(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 - value2));</span><br><span class="line">        System.out.println(biFunctionTest.compute(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 * value2));</span><br><span class="line">        System.out.println(biFunctionTest.compute(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 / value2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> biFunction.apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是需要注意的是，在Bifunction中只有一个默认方法andThen()，而没有compose()方法:</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment"> * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment"> * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment"> * the caller of the composed function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment"> *           composed function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment"> * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">BiFunction&lt;T, U, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t, U u) -&gt; after.apply(apply(t, u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因是显而易见的，如果有的话，只能返回一个结果，而Bifunction要求接收两个参数，返回一个结果，这显然是不行的，但是对于andThen()方法，after这个Function类型的参数，正好可以接收BiFunction这个接口的返回的结果作为参数。</p>
<p>同样的我们可以举一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiFunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BiFunctionTest biFunctionTest = <span class="keyword">new</span> BiFunctionTest();</span><br><span class="line">        System.out.println(biFunctionTest.compute(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 + value2, value -&gt; value * value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> biFunction.andThen(function).apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person(<span class="string">&quot;lisi&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        Person person3 = <span class="keyword">new</span> Person(<span class="string">&quot;wangwu&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; persons = Arrays.asList(person1, person2, person3);</span><br><span class="line">        PersonTest personTest = <span class="keyword">new</span> PersonTest();</span><br><span class="line">        List&lt;Person&gt; persons2 = personTest.getPersonByAge(<span class="number">25</span>, persons);</span><br><span class="line">        persons2.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPersonByUsername</span><span class="params">(String username, List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> persons.stream().filter(person -&gt; person.getUsername().equals(username)).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPersonByAge</span><span class="params">(<span class="keyword">int</span> age, List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        BiFunction&lt;Integer, List&lt;Person&gt;, List&lt;Person&gt;&gt; biFunction = (ageOfPerson, personList) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> personList.stream().filter(person -&gt; person.getAge() &gt; age).collect(Collectors.toList());</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> biFunction.apply(age, persons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="predicate函数式接口"><a class="markdownIt-Anchor" href="#predicate函数式接口"></a> Predicate函数式接口</h3>
<p>同样的方式，我们首先类阅读一下Predicate的JavaDoc：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a predicate (boolean-valued function) of one argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #test(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the predicate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> false&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ANDed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> true&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ORed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment">     * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of arguments to the predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetRef the object reference with which to compare for equality,</span></span><br><span class="line"><span class="comment">     *               which may be &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment">     * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Predicate也是一个重要的函数式接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Represents a predicate (boolean-valued function) of one argument.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span><br><span class="line"> * whose functional method is &#123;@link #test(Object)&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;T&gt; the type of the input to the predicate</span><br><span class="line"> *</span><br><span class="line"> * @since 1.8</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>predicate这个单词本身是谓词， 阐明， 断言的意思，这里说，Predicate代表了一个接收一个参数，返回一个boolean值类型的函数式接口，其中方法名叫test()。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Evaluates this predicate on the given argument.</span><br><span class="line">   *</span><br><span class="line">   * @param t the input argument</span><br><span class="line">   * @return &#123;@code true&#125; if the input argument matches the predicate,</span><br><span class="line">   * otherwise &#123;@code false&#125;</span><br><span class="line">   */</span><br></pre></td></tr></table></figure>
<p>针对于给定的T类型的参数t来计算，如果与predicate相匹配，则返回一个true,否则返回false。</p>
<p>针对于Predicate可以定义，我们可以给出例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; predicate = p -&gt; p.length() &gt; <span class="number">5</span>;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Predicate在集合与stream中有大量的应用，再来看一些具体的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        PredicateTest2 predicateTest2 = <span class="keyword">new</span> PredicateTest2();</span><br><span class="line">        <span class="comment">// 找到集合中所有的偶数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有的奇数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item % <span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有大于5的数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item &gt; <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有小于3的数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item &lt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionFilter</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(integer)) &#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以想象，如果要使用传统的方式实现这些需求，我们就必须要编写很多个具体的方法，但是如果使用Lambda表达式，我们就可以定义一个通用的函数，具体的行为在调用的时候再传入。</p>
<p>Predicate中除了抽象方法test()，还有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment"> * AND of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment"> * predicate, if this predicate is &#123;<span class="doctag">@code</span> false&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment"> * predicate is not evaluated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment"> * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other a predicate that will be logically-ANDed with this</span></span><br><span class="line"><span class="comment"> *              predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment"> * AND of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数表示当前的Predicate与另一个Predicate的短路与，当计算这个复合函数的时候，如果前面的Predicate的值为false,那么后面的将不再会被计算，如果在计算过程中，任何一个Predicate会抛出异常的话，怎么做取决于调用者，如果当前的Predicate抛出了异常，那么后者也不会被计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">  * predicate.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">  * predicate</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>negate本身是否定的意思，表示返回当前Predicate的逻辑非。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment"> * OR of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment"> * predicate, if this predicate is &#123;<span class="doctag">@code</span> true&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment"> * predicate is not evaluated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment"> * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other a predicate that will be logically-ORed with this</span></span><br><span class="line"><span class="comment"> *              predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment"> * OR of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，这个方法是计算逻辑或的操作，如果当前的Predicate是true的话，后面的将不会再被计算，关于Predicate的三个默认方法，我们来看具体例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        PredicateTest2 predicateTest2 = <span class="keyword">new</span> PredicateTest2();</span><br><span class="line">        <span class="comment">// 找到集合中所有的偶数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有的奇数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item % <span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有大于5的数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item &gt; <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有小于3的数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item &lt; <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有大于5并且是偶数的数</span></span><br><span class="line">        predicateTest2.conditionFilter2(list, item -&gt; item &gt; <span class="number">5</span>, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有大于5或者是偶数的数</span></span><br><span class="line">        predicateTest2.conditionFilter3(list, item -&gt; item &gt; <span class="number">5</span>, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        predicateTest2.conditionFilter4(list, item -&gt; item &gt; <span class="number">5</span>, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionFilter</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(integer)) &#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionFilter2</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 Predicate&lt;Integer&gt; predicate2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.and(predicate2).test(integer)) &#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionFilter3</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 Predicate&lt;Integer&gt; predicate2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.or(predicate2).test(integer)) &#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionFilter4</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 Predicate&lt;Integer&gt; predicate2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.or(predicate2).negate().test(integer)) &#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们来看一下它唯一的static方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment"> * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of arguments to the predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetRef the object reference with which to compare for equality,</span></span><br><span class="line"><span class="comment"> *               which may be &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment"> * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">            ? Objects::isNull</span><br><span class="line">            : object -&gt; targetRef.equals(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来根据Objects类中的equals()方法判断两个参数是不是相等，注意，这里并不是Object类，而是Objects，这是从JDK1.7之后新增加的类。<br />
Objects::isNull是一个静态方法的方法引用，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看具体的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PredicateTest3 predicateTest3 = <span class="keyword">new</span> PredicateTest3();</span><br><span class="line">        System.out.println(predicateTest3.isEqual(<span class="string">&quot;test&quot;</span>).test(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Predicate&lt;Date&gt; <span class="title">isEqual</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Predicate.isEqual(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上这个其实&quot;test&quot;.equals(new Date())，那么显然结果是false。</p>
<h3 id="supplier函数式接口"><a class="markdownIt-Anchor" href="#supplier函数式接口"></a> Supplier函数式接口</h3>
<p>同样的，我们来看一下Supplier函数式接口的文档：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a supplier of results.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There is no requirement that a new or distinct result be returned each</span></span><br><span class="line"><span class="comment"> * time the supplier is invoked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #get()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of results supplied by this supplier</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先来看类的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Represents a supplier of results.</span><br><span class="line">There is no requirement that a new or distinct result be returned each time the supplier is invoked.</span><br></pre></td></tr></table></figure>
<p>Supplier表示提供结果的供应者，它每次被调用的时候无需保证返回不同的结果，换言之，每次被调用的结果可能是相同的。</p>
<p>Supplier不接受参数，并返回一个结果。</p>
<p>我们来新建一个测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierJyc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;String&gt; supplierJyc = () -&gt; <span class="string">&quot;hello word&quot;</span>;</span><br><span class="line">        System.out.println(supplierJyc.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，控制台会打印出以下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Task :SupplierJyc.main()</span></span><br><span class="line">hello word</span><br></pre></td></tr></table></figure>
<p>实际上，Supplier更多的适用于工厂创建对象，下面我们用具体的例子来说明，首先创建一个Student类，并生成无参构造方法和setter及getter方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面我们使用Supplier来创建一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Student&gt; supplier = () -&gt; <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(supplier.get().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正式由于Supplier这个函数式接口不接收参数，并且返回一个泛型T类型的对象，所以() -&gt; new Student()就是Supplier函数式接口的一个实例。除了通过这种方式创建实例外，我们还可以使用一种特殊的方式来创建Supplier的实例，即对象引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Student&gt; supplier = () -&gt; <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(supplier.get().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Student&gt; supplier2 = Student::<span class="keyword">new</span>;</span><br><span class="line">        System.out.println(supplier2.get().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这会与上面的代码得到相同的结果，如果点击Student::new中的new的话，会自动跳转到Student的无参构造的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>说明这个新的语法就是在调用Student的无参构造来创建对象，而这个无参构造刚好满足不接受参数，只返回对象的Supplier函数式接口的要求，所以创建了Student的实例。</p>
<p>当我们修改这个类的默认构造方法，去掉没有参数的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器就会提示我们不能解析构造方法：</p>
<p><img src="D:%5C%E7%AC%94%E8%AE%B0%5Cjiyongchao-qf.github.io%5Cdocs%5Cviews%5Cimages%5CFunctionalprogramming.md" alt="1597851410941" /></p>
<p>这也验证了我们之前的说法。</p>
<p>以上就是几个最基础也是最重要的几个函数式接口，在此基础上，JDK还为我们提供了一些其他的函数式接口，例如BinaryOperator，他们可以看成是前面几个函数式接口的扩展。</p>
<h2 id="函数式接口扩展"><a class="markdownIt-Anchor" href="#函数式接口扩展"></a> 函数式接口扩展</h2>
<p>相同的方式，我们首先来阅读一下BinaryOperator这个函数式接口的文档：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents an operation upon two operands of the same type, producing a result</span></span><br><span class="line"><span class="comment"> * of the same type as the operands.  This is a specialization of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> BiFunction&#125; for the case where the operands and the result are all of</span></span><br><span class="line"><span class="comment"> * the same type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #apply(Object, Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the operands and result of the operator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BiFunction</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> UnaryOperator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BinaryOperator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>,<span class="title">T</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> BinaryOperator&#125; which returns the lesser of two elements</span></span><br><span class="line"><span class="comment">     * according to the specified &#123;<span class="doctag">@code</span> Comparator&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input arguments of the comparator</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> comparator a &#123;<span class="doctag">@code</span> Comparator&#125; for comparing the two values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> BinaryOperator&#125; which returns the lesser of its operands,</span></span><br><span class="line"><span class="comment">     *         according to the supplied &#123;<span class="doctag">@code</span> Comparator&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the argument is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BinaryOperator&lt;T&gt; <span class="title">minBy</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(comparator);</span><br><span class="line">        <span class="keyword">return</span> (a, b) -&gt; comparator.compare(a, b) &lt;= <span class="number">0</span> ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> BinaryOperator&#125; which returns the greater of two elements</span></span><br><span class="line"><span class="comment">     * according to the specified &#123;<span class="doctag">@code</span> Comparator&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input arguments of the comparator</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> comparator a &#123;<span class="doctag">@code</span> Comparator&#125; for comparing the two values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> BinaryOperator&#125; which returns the greater of its operands,</span></span><br><span class="line"><span class="comment">     *         according to the supplied &#123;<span class="doctag">@code</span> Comparator&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the argument is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BinaryOperator&lt;T&gt; <span class="title">maxBy</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(comparator);</span><br><span class="line">        <span class="keyword">return</span> (a, b) -&gt; comparator.compare(a, b) &gt;= <span class="number">0</span> ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看类的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Represents an operation upon two operands of the same type, producing a result of the same type as the operands. This is a specialization of BiFunction for the case where the operands and the result are all of the same type.</span><br><span class="line">This is a functional interface whose functional method is apply(Object, Object).</span><br></pre></td></tr></table></figure>
<p>BinaryOperator表示针对于两个相同运算对象的操作，并且生成与运算对象相同类型的结果类型，这是当使用BiFunction运算对象与结果类型相同时候的一个特例，我们知道，在BiFunction中，类型可以是不相同的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiFunction&lt;T, U, R&gt;</span><br></pre></td></tr></table></figure>
<p>同时其中的抽象方法apply()，也接收了两个不同类型的参数，并且返回了不同类型的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当类型相同的时候，就变成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt;</span><br></pre></td></tr></table></figure>
<p>apply()方法也就变成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">apply</span><span class="params">(T t, T u)</span></span>;</span><br></pre></td></tr></table></figure>
<p>BinaryOperator中还有两个静态方法，首先来看minBy()的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a BinaryOperator which returns the lesser of two elements according to the specified Comparator.</span><br></pre></td></tr></table></figure>
<p>minBy()方法会根据比较器Comparator返回两个元素中比较小的那一个，来看一个具体的例子，我们给定两个字符串，来返回比较小的那一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryOperatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryOperatorTest binaryOperatorTest = <span class="keyword">new</span> BinaryOperatorTest();</span><br><span class="line">        System.out.println(binaryOperatorTest.getShort(<span class="string">&quot;hellohello&quot;</span>, <span class="string">&quot;hello&quot;</span>, (a, b) -&gt; a.length() - b.length()));</span><br><span class="line">        System.out.println(binaryOperatorTest.getShort(<span class="string">&quot;hellohello&quot;</span>, <span class="string">&quot;hello&quot;</span>, (a, b) -&gt; a.charAt(<span class="number">0</span>) - b.charAt(<span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShort</span><span class="params">(String a, String b, Comparator&lt;String&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BinaryOperator.minBy(comparator).apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然使用maxBy()方法会获得相反的结果。</p>
<p>其实在java.util.function这个包下面，还有很多的其他的函数式接口，比如BiConsumer，BiFunction，LongPredicate，IntSupplier等等，这些都是对于这几个基础的函数式接口的有力的补充，也是这几个基础的函数式接口的特例。</p>
<h2 id="方法引用"><a class="markdownIt-Anchor" href="#方法引用"></a> 方法引用</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个例子中的::就是JDK8中新增的语法，叫做方法引用，它可以看成是Lambda表达式的一种语法糖，如果所使用的Lambda表达式恰好被实现过的话，就可以使用方法引用来写出更加简洁的代码，我们可以将方法引用看作是一个【函数指针（function pointer）】。</p>
<p>方法引用共分为4类：静态方法引用、构造方法引用、类的任意对象的实例方法引用、特定对象的实例方法引用，对于其中的每一种，我们都会给出Lambda表达式的方式和方法引用的方式实现相同的功能，以此来对照学习。</p>
<h3 id="静态方法引用"><a class="markdownIt-Anchor" href="#静态方法引用"></a> 静态方法引用</h3>
<p>首先定义一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareStudentByScore</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student1.score - student2.score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareStudentByName</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student1.getName().compareToIgnoreCase(student2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们使用List集合中新增加的sort方法进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line">        students.sort((studentParam1, studentParam2) -&gt; Student.compareStudentByScore(studentParam1, studentParam2));</span><br><span class="line"></span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getScore()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们排序的时候直接调用的是List集合中的默认方法sort（），这也是在JDK8中新增加的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">      Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">      Arrays.sort(a, (Comparator) c);</span><br><span class="line">      ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">      <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">          i.next();</span><br><span class="line">          i.set((E) e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到其接收Comparator作为参数，我们再来看一下Comparator的类定义情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这是一个函数式接口，并且接收两个相同类型的参数，并且返回一个Int值，它会根据定义好的排序规则，如果第一个参数大于第二个参数，那么会返回正数，相等会返回0，小于会返回负数，针对于以上的例子，Student类中的静态方法compareStudentByScore恰好是接收两个参数，并且返回一个结果，所以可以作为Comparator这个Lambda表达式的方法体，其实我们还可以使用方法引用的方式，来完成相同的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line">        <span class="comment">// students.sort((studentParam1, studentParam2) -&gt; Student.compareStudentByScore(studentParam1, studentParam2));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// students.forEach(student -&gt; System.out.println(student.getScore()));</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">        students.sort(Student::compareStudentByScore);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getScore()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种方式的效果完全等价，换言之，在这个场景下，方法引用与Lambda表达式完全等价，方法引用是Lambda表达式的一种语法糖，只有当某一个已经存在的方法，恰好满足了Lambda表达式的要求，才可以使用方法引用，Lambda表达式其实是一种更为通用的形式，而方法引用则需要满足一些条件才能使用。</p>
<h3 id="实例方法引用"><a class="markdownIt-Anchor" href="#实例方法引用"></a> 实例方法引用</h3>
<p>我们依然使用排序这个例子，这次我们使用另一种写法来完成这个功能，首先定义一个这样的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentComparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareStudentByScore</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student1.getScore() - student2.getScore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareStudentByName</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student1.getName().compareToIgnoreCase(student2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后来实现对于Student的排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">40</span>);</span><br><span class="line">        </span><br><span class="line">        StudentComparator studentComparator = <span class="keyword">new</span> StudentComparator();</span><br><span class="line">        students.sort((studentParam1, studentParam2) -&gt; studentComparator.</span><br><span class="line">                compareStudentByScore(studentParam1, studentParam2));</span><br><span class="line">        </span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getScore()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们直接使用StudentComparator实例中的compareStudentByScore来进行排序，事实上，这种场景下，也可以使用方法引用来替代：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line">        StudentComparator studentComparator = <span class="keyword">new</span> StudentComparator();</span><br><span class="line">        students.sort(studentComparator::compareStudentByScore);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getScore()));</span><br><span class="line">        System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">        students.sort(studentComparator::compareStudentByName);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与静态方法引用的不同的是，这里我们调用的是类实例的方法。</p>
<h3 id="实例方法名引用"><a class="markdownIt-Anchor" href="#实例方法名引用"></a> 实例方法名引用</h3>
<p>首先，在Student类中，我们增加一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2 * <span class="doctag">@Author</span>: jiyongchao</span></span><br><span class="line"><span class="comment"> * 3 * <span class="doctag">@Date</span>: 2020/8/20 23:56</span></span><br><span class="line"><span class="comment"> * 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareStudentByScore</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student1.score - student2.score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareStudentByName</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student1.getName().compareToIgnoreCase(student2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareByScore</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getScore() - student.getScore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareByName</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().compareToIgnoreCase(student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前的例子中，compareStudentByScore与compareStudentByName方法实际上是我们有意为之的，实际上这两个静态方法放在任何一个类中，都是可以调用的，通常我们比较两个对象时，更多的情况是，传入一个对象，并与当前对象进行比较，这也是新增加的compareByScore和compareByName的作用，在这种情况下，排序规则又可以做出如下修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line">        students.sort(Student::compareByName);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再举一个例子，来加深对于实例方法名引用的理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; cities = Arrays.asList(<span class="string">&quot;qingdao&quot;</span>, <span class="string">&quot;chongqing&quot;</span>, <span class="string">&quot;tianjin&quot;</span>, <span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">        Collections.sort(cities, (city1, city2) -&gt; city1.compareToIgnoreCase(city2));</span><br><span class="line">        cities.forEach(city -&gt; System.out.println(city));</span><br><span class="line">        Collections.sort(cities, String::compareToIgnoreCase);</span><br><span class="line">       	cities.forEach(city -&gt; System.out.println(city));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候，再回到集合遍历的例子当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out::println()</span><br></pre></td></tr></table></figure>
<p>实际上，查看System源码可以发现out实际上是PrintStream的一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>而println()方法就是PrintStream中的一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          print(x);</span><br><span class="line">          newLine();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法引用"><a class="markdownIt-Anchor" href="#构造方法引用"></a> 构造方法引用</h3>
<p>前面我们介绍过的Supplier函数式接口其中一个很重要的应用就是构造方法引用，因为其不接收参数，返回值的特性正好与构造方法的作用不谋而合，所以，我们可以很轻松的写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get() + <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MethodReferenceDemo methodReferenceDemo = <span class="keyword">new</span> MethodReferenceDemo();</span><br><span class="line">        System.out.println(methodReferenceDemo.getString(String::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了无参构造，还可以调用有参数的构造方法，这个时候就变成了接收一个参数，返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString2</span><span class="params">(String str, Function&lt;String, String&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function.apply(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MethodReferenceDemo methodReferenceDemo = <span class="keyword">new</span> MethodReferenceDemo();</span><br><span class="line">        System.out.println(methodReferenceDemo.getString2(<span class="string">&quot;hello&quot;</span>, String::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="默认方法"><a class="markdownIt-Anchor" href="#默认方法"></a> 默认方法</h3>
<p>在方法引用的最后，我们补充一些关于JDK8中默认方法的相关介绍，首先定义这样两个接口，接口中有同名的默认方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterface1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterface2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候，假设有一个类，要实现这两个接口，但是由于这两个接口中有同名的默认方法，所以，编译器无法自动推断出要继承哪一个接口中的默认方法，一般这个时候，处理方式有两种，一种是在实现类中重写方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyInterface1</span>, <span class="title">MyInterface2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterface1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        myClass.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式的弊端在于，我们需要将某一个子类中的默认方法实现重写一遍，如果代码很多，既费时，可维护性也比较差，好在JDK为我们提供了另一种方式来完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyInterface1</span>, <span class="title">MyInterface2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       MyInterface1.<span class="keyword">super</span>.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        myClass.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于以上例子我们再做一个小的扩展，增加一个MyInterface1的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterface1Impl</span> <span class="keyword">implements</span> <span class="title">MyInterface1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterface1Impl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个时候，我们再定义一个类，这个类继承MyInterface1Impl，并且实现MyInterface2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span> <span class="keyword">extends</span> <span class="title">MyInterface1Impl</span> <span class="keyword">implements</span> <span class="title">MyInterface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass2 myClass2 = <span class="keyword">new</span> MyClass2();</span><br><span class="line">        myClass2.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候调用当前类的myMethod()方法并不会报错，也就是说，编译器自动推断出了我们要想调用MyInterface1Impl中的myMethod()方法，还是MyInterface2中的默认方法myMethod()，这实际上是JDK中的一个约定，编译器会认为继承的优先级大于实现，类中的方法才表示具体的行为，而接口更多的时候还是表示一种模板或者契约。</p>
<p>增加默认方法的特性是Java对于支持函数式编程一个非常重要的改变，在上面排序的例子中可以看到，List这样一个顶层的集合增加了排序的方法，试想，如果没有默认方法，那对于想从JDK7升级到JDK8的人无疑是一场灾难，如果一旦在自己的代码实现过List，那意味你需要重写所有的子类，而JDK在很多的接口中都增加了默认方法，为了升级JDK还需要入侵式的修改客户端的代码，这显然是不合适的，那为什么还会增加默认方法的机制呢？其目的，就是为了更为方便的编写函数式的代码，同时也是为了向后兼容的一种妥协，从这一个层面来说，Java的函数式编程并不是完美无暇的，更像是一个裹足前行的人，这也是面向对象带来限制，但我们还是非常振奋，JDK8使我们看到了Java这门古老的语言的全新面貌。</p>
<p>增加默认方法也可以看到，接口和抽象类的区别越来越小了。</p>
<h1 id="stream实践"><a class="markdownIt-Anchor" href="#stream实践"></a> Stream实践</h1>
<p>在前面的章节我们花费了不少的章节整理了Lambda表达式的相关特性，也举出了不少的例子来展示了Lambda表达式的应用，但总有种纸上谈兵的感觉，还是无法理解Lambda表达式到底可以帮我们做哪些事情？函数式编程又指的是什么？在接下来的章节中，我们就会围绕这两个问题展开。</p>
<p>实际上，Lambda表达式在大多数的场景下，都是与Stream相伴出现的，两个配合使用，更加高效、简洁、优雅的处理集合相关的问题。</p>
<p>首先我们需要了解一些Stream的基本概念，学会新的API使用，在不断的实践中，最后探究Stream的实现原理。一般而言Stream由3个部分组成：</p>
<ol>
<li>源</li>
<li>零个或多个中间操作</li>
<li>终止操作</li>
</ol>
<p>流操作的分类又有两种：</p>
<ol>
<li>惰性求值</li>
<li>及早求值</li>
</ol>
<p>Stream也可以分为并行流和串行流，可以通过非常简单的方式，就是使用并发来加快运行的效率。</p>
<p>我们首先使用不同的方式来创建一个Stream对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream stream1 = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为什么可以这样创建呢？不妨查看一下Stream这个类中的of()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这是一个静态方法，本身接受的是可变参数，并且会调用Arrays中的stream方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> stream(array, <span class="number">0</span>, array.length);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中的&quot;hello&quot;, “world”, &quot;hello world&quot;就称之为源，源的意思就是要操作的数据对象，使用相似的方式，我们还可以这样创建Stream：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream stream1 = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        String[] myArray = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>&#125;;</span><br><span class="line">        Stream stream2 = Stream.of(myArray);</span><br><span class="line">        Stream stream3 = Arrays.stream(myArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上而言，这几种创建Stream的方式并没有什么区别，其实最常见的，是采用下面的方式来创建流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(myArray);</span><br><span class="line">        Stream stream = list.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是关于如何创建流的对象的例子，接下来我们看看引入Stream会为我们的编码带来什么样的改变，首先我们创建一个Stream，并且调用它的forEach（）方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.of(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们首先创建了一个元素为5，6，7的Stream对象，并且调用forEach()方法，对流中的每一个元素执行打印的操作。</p>
<p>Stream本身其实也提供了针对与特定数据类型的具化的Stream对象，用来避免自动拆箱装箱带来的性能的损耗，所以这段代码也可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.of(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>,&#125;).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再举一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">3</span>, <span class="number">8</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就在控制台打印了3到7，我们可以来了解一下这个range()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">range</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startInclusive &gt;= endExclusive) &#123;</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.intStream(</span><br><span class="line">                <span class="keyword">new</span> Streams.RangeIntSpliterator(startInclusive, endExclusive, <span class="keyword">false</span>), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个方法返回的是包含最小值，不包含最大值的IntStream对象，那如果要包含最大值改怎么做呢？一种方式当然可以调整范围，比如，可以设置范围是（3，9）就可以打印3到8的内容，也可以调用另一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.rangeClosed(<span class="number">3</span>, <span class="number">8</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>我们不妨来看一下这个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">rangeClosed</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endInclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startInclusive &gt; endInclusive) &#123;</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.intStream(</span><br><span class="line">                <span class="keyword">new</span> Streams.RangeIntSpliterator(startInclusive, endInclusive, <span class="keyword">true</span>), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，就顺利的同时包含了较小的值和较大的值。</p>
<p>上面的例子看起来还是相对而言比较简陋的，接下来我们给出一个稍微复杂一点的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(list.stream().map(i -&gt; <span class="number">2</span> * i).reduce(<span class="number">0</span>, Integer::sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们对于集合中的元素先乘以2，然后求和，这里的map描述的是一种映射，而reduce描述的一种聚合，只有当表达式中具有reduce这样的终止操作的方法的时候，流才会被真正的执行，这就是所谓的终止操作，而map就称之为中间操作。不难看出，与传统的方式，使用函数式的方式，代码变的异常简洁和优雅。</p>
<h2 id="stream类源码解析"><a class="markdownIt-Anchor" href="#stream类源码解析"></a> Stream类源码解析</h2>
<p>在初步了解了Sream给我们来了些什么之后，我们来了解一些关于流的特性：</p>
<ul>
<li>Collection提供了新的Stream()方法</li>
<li>流不存储值，通过管道的方式获取值</li>
<li>本质是函数式的，对流的操作会生成一个结果，不过并不会修改底层的数据源，集合可以作为流的底层数据源</li>
<li>延迟查找，很多流操作（过滤、映射、排序等）都可以延迟实现</li>
</ul>
<p>接下来再通过一些实际的例子，来加深对于Stream的理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        String[] stringArray = stream.toArray(length -&gt; <span class="keyword">new</span> String[length]);</span><br><span class="line">        String[] strings = stream.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        Arrays.asList(stringArray).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子创建Stream的，那Stream是如何转变成我们常用的List集合呢？这里就要说明一个及其重要的方法collect()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">         list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>collect()方法是有几个重载的方法，我们来看接收参数最多的这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs a &lt;a href=&quot;package-summary.html#MutableReduction&quot;&gt;mutable</span></span><br><span class="line"><span class="comment"> * reduction&lt;/a&gt; operation on the elements of this stream.  A mutable</span></span><br><span class="line"><span class="comment"> * reduction is one in which the reduced value is a mutable result container,</span></span><br><span class="line"><span class="comment"> * such as an &#123;<span class="doctag">@code</span> ArrayList&#125;, and elements are incorporated by updating</span></span><br><span class="line"><span class="comment"> * the state of the result rather than by replacing the result.  This</span></span><br><span class="line"><span class="comment"> * produces a result equivalent to:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *     R result = supplier.get();</span></span><br><span class="line"><span class="comment"> *     for (T element : this stream)</span></span><br><span class="line"><span class="comment"> *         accumulator.accept(result, element);</span></span><br><span class="line"><span class="comment"> *     return result;</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Like &#123;<span class="doctag">@link</span> #reduce(Object, BinaryOperator)&#125;, &#123;<span class="doctag">@code</span> collect&#125; operations</span></span><br><span class="line"><span class="comment"> * can be parallelized without requiring additional synchronization.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal</span></span><br><span class="line"><span class="comment"> * operation&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span> There are many existing classes in the JDK whose signatures are</span></span><br><span class="line"><span class="comment"> * well-suited for use with method references as arguments to &#123;<span class="doctag">@code</span> collect()&#125;.</span></span><br><span class="line"><span class="comment"> * For example, the following will accumulate strings into an &#123;<span class="doctag">@code</span> ArrayList&#125;:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *     List&lt;String&gt; asList = stringStream.collect(ArrayList::new, ArrayList::add,</span></span><br><span class="line"><span class="comment"> *                                                ArrayList::addAll);</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The following will take a stream of strings and concatenates them into a</span></span><br><span class="line"><span class="comment"> * single string:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *     String concat = stringStream.collect(StringBuilder::new, StringBuilder::append,</span></span><br><span class="line"><span class="comment"> *                                          StringBuilder::append)</span></span><br><span class="line"><span class="comment"> *                                 .toString();</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; type of the result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> supplier a function that creates a new result container. For a</span></span><br><span class="line"><span class="comment"> *                 parallel execution, this function may be called</span></span><br><span class="line"><span class="comment"> *                 multiple times and must return a fresh value each time.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accumulator an &lt;a href=&quot;package-summary.html#Associativity&quot;&gt;associative&lt;/a&gt;,</span></span><br><span class="line"><span class="comment"> *                    &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,</span></span><br><span class="line"><span class="comment"> *                    &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> *                    function for incorporating an additional element into a result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> combiner an &lt;a href=&quot;package-summary.html#Associativity&quot;&gt;associative&lt;/a&gt;,</span></span><br><span class="line"><span class="comment"> *                    &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,</span></span><br><span class="line"><span class="comment"> *                    &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> *                    function for combining two values, which must be</span></span><br><span class="line"><span class="comment"> *                    compatible with the accumulator function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the result of the reduction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">              BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="params"><span class="function">              BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>
<p>collect方法接收三个参数，其中的BiConsumer是接收两个参数，并且没有返回值的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface BiConsumer&lt;T, U&gt; </span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来阅读一下collect方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Performs a mutable reduction operation on the elements of this stream. A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList, and elements are incorporated by updating the state of the result rather than by replacing the result. This produces a result equivalent to:</span><br></pre></td></tr></table></figure>
<p>对流当中的元素进行可变的汇聚操作，一个可变的汇聚操作指的是将值汇聚到可变的结果容器，比如ArrayList，并且这个容器是通过更新结果的状态来进行合并的，而不是通过替换结果进行合并的，这个结果相当于下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">R result = supplier.get();</span><br><span class="line">    <span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">        accumulator.accept(result, element);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>首先会通过supplier.get()方法获取到结果集，然后对流中的元素进行遍历，遍历执行累加器accumulator中的accept，最后返回结果，这里总共有三个步骤，对应的就是collect方法的三个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">                 BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="params"><span class="function">                 BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们来举一个具体的例子来说明，这段文字的含义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = stream.collect(() -&gt; <span class="keyword">new</span> ArrayList&lt;String&gt;(), (theList, item) -&gt; theList.add(item),(theList1, theList2) -&gt; theList1.addAll(theList2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>supplier就是我们要返回的结果，这里我们选择new一个ArrayList作为返回的容器，accumulator是我们要把流中的元素添加到要返回的结果容器当中，所以这里调用List的add()方法，将流中的元素依次添加到我们新new出来的ArrayList当中，每次将流中的元素添加到的ArrayList时都会新newArrayList，combiner是将上一次返回的结果，添加到的最终的结果theList1当中，当然，这个方法我们也可以用方法引用来完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);</span><br></pre></td></tr></table></figure>
<p>理解了三个参数具体的作用我们具体再往下看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Like reduce(Object, BinaryOperator), collect operations can be parallelized without requiring additional synchronization.This is a terminal operation.</span><br></pre></td></tr></table></figure>
<p>就像reduce一样，collect无需其他操作就可以很好的支持并行流，并且也是一个终止操作，这也是流式编程给我们带来的好处。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are many existing classes in the JDK whose signatures are well-suited for use with method references as arguments to collect(). </span><br></pre></td></tr></table></figure>
<p>在JDK中有很多的方法都可以采用方法引用的方式，作为collect()的参数，这里举了两个例子，一个正是我们前面举出的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; asList = stringStream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add,</span><br><span class="line">                                               ArrayList::addAll);</span><br></pre></td></tr></table></figure>
<p>还有一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String concat = stringStream.collect(StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</span><br><span class="line">                                       StringBuilder::append).toString();</span><br></pre></td></tr></table></figure>
<p>这里使用StringBuilder作为最终返回的结果容器，遍历集合中的单个的字符串，最终将他们拼接起来。</p>
<p>最后我们来看一下对于参数的说明：</p>
<ul>
<li>supplier – a function that creates a new result container. For a parallel execution, this function may be called multiple times and must return a fresh value each time.</li>
<li>accumulator – an associative, non-interfering, stateless function for incorporating an additional element into a result</li>
<li>combiner – an associative, non-interfering, stateless function for combining two values, which must be compatible with the accumulator function</li>
</ul>
<p>supplier会创建一个新的结果容器，在并行流中可能会多次调用，所以它每次返回的一定是一个新的结果容器，accumulator，它是一个相关的，不冲突的，可关联的一个无状态的一个函数，用于将一个额外的元素合并到结果容器当中，combiner用于合并两个值，它必须和accumulator 是兼容的。</p>
<p>最后我们可以看一个JDK实现的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                               (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                               CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stream实例剖析"><a class="markdownIt-Anchor" href="#stream实例剖析"></a> Stream实例剖析</h2>
<p>首先来看一个具体的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用的Collectors类中的toCollection()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt;</span><br><span class="line">    Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(collectionFactory, Collection&lt;T&gt;::add,</span><br><span class="line">                                   (r1, r2) -&gt; &#123; r1.addAll(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">                                   CH_ID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，它接受一个Supplier参数，这里我们使用构方法引用的方式，这实际上是一种比起toList()更为通用的写法，使用toCollection可以很方便的自定义返回结果容器的类型，比如我们要返回一个LinkedList，我们只需要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = stream.collect(Collectors.toCollection(LinkedList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>
<p>除了将流转化为List，我们也可以转化为Set、Map等，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;String&gt; set = stream.collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line">        set.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上一章节中，JDK中举出的拼接字符串的例子，实际上在Collectors中有一种更为简洁的实现方案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        String str = stream.collect(Collectors.joining()).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前我们举的例子要么是将集合转化为Stream，要么是将Stream转化为集合，实际使用的时候，需要两者配合使用，举一个这样的例子，将集合中的字符串传化为大写并打印：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        list.stream().map(String::toUpperCase).collect(Collectors.toList()).</span><br><span class="line">                forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似这样的代码，才是在实际应用中使用的最多的，其中的map()是JDK为我们提供的API，表示一种映射关系，将集合中的元素映射成后面表达式的结果的操作，再比如，要求出集合中每一个元素的平方并打印：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list2 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        list2.stream().map(item -&gt; item * item).collect(Collectors.toList()).</span><br><span class="line">                forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与map比较类似的还有一个flatmap()方法，它表示将流中元素的界限打破，最终返回一个整体，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(<span class="number">1</span>), Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">                Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">        stream.flatMap(theList -&gt; theList.stream().map(item -&gt; item * item)).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们首先对于流中的集合进行了平方的操作，然后将所有的元素作为一个整体进行打印。</p>
<p>再来看一个map和flatMap例子，假设我们要对一个集合中的元素提取出单词并去重：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello welcome&quot;</span>, <span class="string">&quot;world hello&quot;</span>, <span class="string">&quot;hello world hello&quot;</span>, <span class="string">&quot;hello welcome&quot;</span>);</span><br><span class="line">        list.stream().map(item -&gt; item.split(<span class="string">&quot; &quot;</span>)).distinct().collect(Collectors.toList()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Ljava.lang.String;@4eec7777</span><br><span class="line">[Ljava.lang.String;@3b07d329</span><br><span class="line">[Ljava.lang.String;@41629346</span><br><span class="line">[Ljava.lang.String;@404b9385</span><br></pre></td></tr></table></figure>
<p>这显然是不对的，原因就在于这里我们使用map返回的类型实际上变成了String[]，自然的，后续的去重操作当然也都失败了，那如果要实现这个需求改怎么做呢？就需要调用flatMap方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello welcome&quot;</span>, <span class="string">&quot;world hello&quot;</span>, <span class="string">&quot;hello world hello&quot;</span>, <span class="string">&quot;hello welcome&quot;</span>);</span><br><span class="line">        list.stream().map(item -&gt; item.split(<span class="string">&quot; &quot;</span>)).flatMap(Arrays::stream).distinct().</span><br><span class="line">                collect(Collectors.toList()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再举这样一个例子来加深对于flatMap理解的场景，比如我们要获取两个集合的笛卡尔积，我们就可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list1 = Arrays.asList(<span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">        list1.stream().flatMap(item -&gt; list2.stream().map(item2 -&gt; item + <span class="string">&quot; &quot;</span> + item2)).</span><br><span class="line">                collect(Collectors.toList()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来介绍generate和iterate这两个特殊的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.generate(UUID.randomUUID()::toString);</span><br><span class="line">        stream.findFirst().ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来介绍iterate方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(f);</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;T&gt; iterator = <span class="keyword">new</span> Iterator&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T t = (T) Streams.NONE;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> t = (t == Streams.NONE) ? seed : f.apply(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(Spliterators.spliteratorUnknownSize(</span><br><span class="line">                iterator,</span><br><span class="line">                Spliterator.ORDERED | Spliterator.IMMUTABLE), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>它的参数UnaryOperator可以简单的看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UnaryOperator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">UnaryOperator&lt;T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Function这个函数式接口本身接口T类型的参数，返回R类型的结果，这里的UnaryOperator表示接收参数与返回结果类型相同的情况，接下来我们阅读一下iterate的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.</span><br><span class="line">The first element (position 0) in the Stream will be the provided seed. For n &gt; 0, the element at position n, will be the result of applying the function f to the element at position n - 1.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个方法返回无限的、串行的、有序的一个Stream，它是由迭代函数f对于初始值seed的不断迭代，第一个元素作为seed（种子）,而对于n&gt;0，会不断应用n-1次迭代函数f，比如f(seed)、f(f(seed))等等。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.iterate(<span class="number">1</span>, item -&gt; item + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这里之所以使用limit是因为如果不加限制，程序将一直运行下去，这是因为iterate他是无限的。</p>
<h2 id="stream陷阱剖析"><a class="markdownIt-Anchor" href="#stream陷阱剖析"></a> Stream陷阱剖析</h2>
<p>首先来看这样一个例子，假设有这样一个流，流中的元素为1，3，5，6，7，11，我们要找出流中大于2的元素，然后将每个元素乘以2，忽略掉流中的前两个元素之后，再取出流中的前两个元素，然后求出流中元素的总和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">1</span>, item -&gt; item + <span class="number">2</span>).limit(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = stream.filter(item -&gt; item &gt; <span class="number">2</span>).mapToInt(item -&gt; item * <span class="number">2</span>).skip(<span class="number">2</span>).limit(<span class="number">2</span>).sum();</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个新的方法，skip()表示跳过，而limit()表示取前几个元素。</p>
<p>如果我们改一下需求，把求出流中元素的总和改为求出流中元素的最小值，我们猜想代码可能是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.filter(item -&gt; item &gt; <span class="number">2</span>).mapToInt(item -&gt; item * <span class="number">2</span>).skip(<span class="number">2</span>).limit(<span class="number">2</span>).min();</span><br></pre></td></tr></table></figure>
<p>但是运行之后控制台的输出却不是我们想要的结果，而是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OptionalInt[14]</span><br></pre></td></tr></table></figure>
<p>原来min()方法的源码是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">OptionalInt <span class="title">min</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回的是一个Optional对象，而不是一个普通的Int，类似的max()方法返回的也是Optional对象，原因就在于，求最大值和最小值有可能为空，而求和则不会，如果流中没有元素返回0即可，从本质上来说，是否会直接返回值，还是返回Optional对象，就是取决于是否可能会出现空指针的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">1</span>, item -&gt; item + <span class="number">2</span>).limit(<span class="number">10</span>);</span><br><span class="line">        stream.filter(item -&gt; item &gt; <span class="number">2</span>).mapToInt(item -&gt; item * <span class="number">2</span>).skip(<span class="number">2</span>).limit(<span class="number">2</span>).max().ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那如果既想求出最大值，也想求出最小值，也想求出总和，改怎么办呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntSummaryStatistics intSummaryStatistics = stream.filter(item -&gt; item &gt; <span class="number">2</span>).mapToInt(item -&gt; item * <span class="number">2</span>).skip(<span class="number">2</span>).limit(<span class="number">2</span>).summaryStatistics();</span><br><span class="line">        System.out.println(intSummaryStatistics.getMax());</span><br><span class="line">        System.out.println(intSummaryStatistics.getMin());</span><br><span class="line">        System.out.println(intSummaryStatistics.getSum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案就是调用summaryStatistics()方法。</p>
<p>Stream实际上和文件系统中的IO流有很多类似的性质，比如，Stream只能使用一次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">1</span>, item -&gt; item + <span class="number">2</span>).limit(<span class="number">6</span>);</span><br><span class="line">        System.out.println(stream);</span><br><span class="line">        System.out.println(stream.filter(item -&gt; item &gt; <span class="number">2</span>));</span><br><span class="line">        System.out.println(stream.distinct());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，会得到如下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.util.stream.SliceOps$1@816f27d</span><br><span class="line">java.util.stream.ReferencePipeline$2@53d8d10a</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: stream has already been operated upon or closed</span><br></pre></td></tr></table></figure>
<p>可以看到我们在调用filter方法之后，就会抛出Stream已经被使用的异常，即便我们使用的不是终止操作，而只是一个中间操作，或者说，对于Stream的操作我们只能进行一次，其实中间操作都会返回一个新的Stream对象，为了说明这一点，我们来举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">1</span>, item -&gt; item + <span class="number">2</span>).limit(<span class="number">6</span>);</span><br><span class="line">        System.out.println(stream);</span><br><span class="line">        Stream&lt;Integer&gt; stream2 = stream.filter(item -&gt; item &gt; <span class="number">2</span>);</span><br><span class="line">        System.out.println(stream2);</span><br><span class="line">        Stream&lt;Integer&gt; stream3 = stream2.distinct();</span><br><span class="line">        System.out.println(stream3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次我们顺利的打印出了Stream对象，但其实每次打印的Stream对象都是不同的，实际使用的时候，我们更多的是使用链式的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.filter(item -&gt; item &gt; <span class="number">2</span>).distinct();</span><br></pre></td></tr></table></figure>
<p>接下来我们再了解流的另一个特性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.stream().map((item-&gt;&#123;</span><br><span class="line">            String result = item.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + item.substring(<span class="number">1</span>);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会输出什么呢？答案是什么都不会，如果修改成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.stream().map(item -&gt; item.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + item.substring(<span class="number">1</span>)).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        list.stream().map((item -&gt; &#123;</span><br><span class="line">            String result = item.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + item.substring(<span class="number">1</span>);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;)).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会顺利的再控制台打印出我们想要的结果了。</p>
<p>这也是流的另一个重要的特性——流是惰性的，流只有在遇到终止操作的时候，才会真正的执行，而map是中间操作，因此流并没有被真正的调用，而forEach是终止操作，所以流会被正常的调用执行。</p>
<p>再来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.iterate(<span class="number">0</span>, i -&gt; (i + <span class="number">1</span>) % <span class="number">2</span>).distinct().limit(<span class="number">6</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在控制台输出了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>但程序并没有停止，而是在不停的运行，这是为什么呢？这是因为前面在不断的迭代产生0，1，而去重也并没有等待到新的值，所以程序会无限的运行下去，如果我们将刚才的操作反过来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.iterate(<span class="number">0</span>, i -&gt; (i + <span class="number">1</span>) % <span class="number">2</span>).limit(<span class="number">6</span>).distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>可以看到，控制台在输出了0，1之后就停止了，这是因为我们限制了只取流中的前六个元素，这提示我们在使用流的使用后一定要注意编写的顺序和流的相关特性。</p>
<h2 id="内部迭代和外部迭代"><a class="markdownIt-Anchor" href="#内部迭代和外部迭代"></a> 内部迭代和外部迭代</h2>
<p>Stream和SQL语句其实非常的相似，例如，要完成这样的一个SQL的功能，使用SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name </span><br><span class="line"><span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> address <span class="operator">=</span> ‘beijing’ <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<p>该简单的sql所要表达的意思是：从student这张表中查询出年龄&gt;20并且地址=北京的记录，并且对年龄进行降序排序，排序之后将其名字查找出来。对于sql其实是一个描述性的语言，只描述其行为，而具体如何让db完成这个行为是没有暴露出来的，对于该sql所做的工作如果换成咱们的stream来实现那会是个什么样子呢，伪代码可能是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().filter(student -&gt; student.getAge() &gt; <span class="number">20</span>).filter(student -&gt; student.getAddress().equals(“beijing”))</span><br><span class="line">        .sorted(…).forEach(student -&gt; System.out.println(student.getName()));</span><br></pre></td></tr></table></figure>
<p>从表现形式上而言，Stream和SQL非常的类似，这是因为Stream也是属于一种描述性的语句， 整个语句并没有告诉底层Stream要如何去做，等于只要发一些指令给底层就可以了，具体底层怎么做完全不用关心。</p>
<p>如果使用原来传统的方式又该怎么做呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; students.size();i++)&#123;</span><br><span class="line">         Student student = students.get(i);</span><br><span class="line">         <span class="keyword">if</span>(student.getAge() &gt; <span class="number">20</span> &amp;&amp; student.getAddress().equals(“beijing”))&#123;</span><br><span class="line">             list.add(student);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     Collections.sort(list. Comparator()…);</span><br><span class="line">     <span class="keyword">for</span>(Student student : list)&#123;</span><br><span class="line">         System.out.println(student.getName());</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，使用传统的方式，代码还相当冗余的，并且从易读性上而言，还是Stream的方式更加简洁明了，那什么是外部迭代，什么是内部迭代呢？实际上在Stream出现之前的都称之为外部迭代，使用Stream的就称之为内部迭代。</p>
<p>针对一个集合：</p>
<p><img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210630100236383.png" alt="image-20210630100236383" /></p>
<p>对于上面的例子而言：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210630100257451.png" alt="image-20210630100257451" style="zoom: 67%;" />
<p>集合与我们编写的处理逻辑之间是有清晰的划分的：</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210630100312346.png" alt="image-20210630100312346" style="zoom:67%;" />
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210630100332734.png" alt="image-20210630100332734" style="zoom:67%;" />
<p>那对于Stream内部迭代的方式呢？</p>
<img src="https://gitee.com/ji_yong_chao/blog-img/raw/master/img/image-20210630100352583.png" alt="image-20210630100352583" style="zoom:67%;" />
<p>总的来说，集合关注的是数据与数据存储本身；而流关注的则是对数据的计算。流与迭代器类似的一点是：流是无法重复使用或消费的，并且流在调用的时候，并不是对于集合中所有的元素先调用第一个filter方法，再调用第二个filter方法，再调用其他方法，实际上并不是这样的，流会将执行的调用链的时候，会有一个容器将所有的操作保存下来，并且针对具体的操作，会优化调用顺序，这一点，在后面源代码分析的时候，就可以看到。</p>
<p>我们一直再说中间操作和终止操作，那如何判断一个操作是中间操作还是终止操作呢？简单来说，中间操纵都会返回一个Stream对象，而终止操作则不会返回Stream类型，可能不返回值，也可能返回其他类型的单个值。</p>
<h2 id="流的短路与并发流"><a class="markdownIt-Anchor" href="#流的短路与并发流"></a> 流的短路与并发流</h2>
<p>单从使用的角度而言，并发流与串行流的区别并不是很大，但在底层实现上是完全不同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">50000000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==================&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">        list.stream().sorted().count();</span><br><span class="line">        <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(endTime - startTime);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        System.out.println(millis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要改用串行流改怎么做呢？仅仅需要将我们调用的方法修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.parallelStream().sorted().count();</span><br></pre></td></tr></table></figure>
<p>这也是使用内部迭代给我们带来的另一个好处，至于底层如何充分利用计算机资源帮助我们快速迭代，实际上在框架的底层就已经帮我们实现了，复杂性永远都是存在的，区别在于框架帮助我们实现了多少。当然，你可能会说，既然调用并行流这么方便，那是不是所有的场景下，都可以使用并行流来代替串行流？答案是否定的，并流行并不一定就比串行流的效率高，这取决于解决的实际问题，需要选择合适的方法，才能效率最高，这一点，在后续分析源码的时候就可以看到。</p>
<p>接下来我们讨论有关流的短路问题，首先来看这样一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.stream().mapToInt(String::length).filter(length -&gt; length == <span class="number">5</span>).findFirst().ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，如果有长度为5的字符串，就会在控制台打印字符5，将这个例子做如下修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.stream().mapToInt(item -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> length = item.length();</span><br><span class="line">            System.out.println(item);</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;).filter(length -&gt; length == <span class="number">5</span>).findFirst().ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台会打印什么呢？答案是会在控制台打印出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>为什么会只打印hello呢？原因就在于虽然我们采用的是链式的调用，但其实在调用这些方法的时候并没有先后的顺序，对于流中元素进行处理的时候，会从流中的第一个元素开始应用所有对于流元素的操作，并且对于流的操作也有短路的特性，我们要找到长度为5的字符串，第一个元素就已经满足了所有的操作，所以后面的就不再执行了。</p>
<h2 id="分区与分组"><a class="markdownIt-Anchor" href="#分区与分组"></a> 分区与分组</h2>
<p>我们曾经在内部迭代与外部迭代的章节中提到过，使用Stream的API很像在使用SQL语句，使用SQL语句进行分组的查询是一个很常见的需求，实际上，Stream也对分组提供了强有力的支持。</p>
<p>同样的，我们先创建一个学生类，并生成构造方法、setter、getter方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后来创建一些对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">100</span>, <span class="number">20</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>, <span class="number">20</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">90</span>, <span class="number">30</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">80</span>, <span class="number">40</span>);</span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们使用传统的编码方式来实现对于名字的分组操作，大概要经历如下的步骤：</p>
<ol>
<li>循环列表</li>
<li>取出学生的名字</li>
<li>检查Map中是否存在该名字，不存在则直接添加到该Map中，存在则将Map中的List对象取出来，然后将该Student对象添加到List中</li>
<li>返回Map对象</li>
</ol>
<p>那如果我们使用函数式的编程方式呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.groupingBy(Student::getName));</span><br></pre></td></tr></table></figure>
<p>只需要这一行代码就可以完成根据姓名对于学生的分组操作，这里面用到了Collectors这个类提供的静态方法groupingBy()，我们可以简单的看一下这个方法接收的参数以及它要完成的事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</span><br><span class="line">groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法本身是一个Function的函数式接口，Function我们都知道它接收一个参数，并且有返回值，正如它的方法名称那样描述的，我们需要提供分组的依据，这个方法的文档如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a Collector implementing a &quot;group by&quot; operation on input elements of type T, grouping elements according to a classification function, and returning the results in a Map.</span><br></pre></td></tr></table></figure>
<p>这个方法对于给定的输入元素进行了排序的操作，并且返回了一个Map集合，看到这里我们就明白了，T实际上表示的就是流中的每个元素的类型，而我们通过方法引用的方式，返回了流中Student的姓名字段，流就会自动的为我们根据姓名来进行分类了,并且姓名这个字段会作为分组的key。</p>
<p>如果要根据年龄来分组呢，显然只要将分组的key换成分数就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.groupingBy(Student::getScore));</span><br></pre></td></tr></table></figure>
<p>接下来，我们尝试实现一个稍微复杂的需求，假设我们要实现与这样的SQL语句相同的功能：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure>
<p>这里我们就要调用groupingBy的一个重载的方式来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.counting()));</span><br></pre></td></tr></table></figure>
<p>我们首先来看一下这里面调用的counting()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt;</span><br><span class="line">counting() &#123;</span><br><span class="line">    <span class="keyword">return</span> reducing(<span class="number">0L</span>, e -&gt; <span class="number">1L</span>, Long::sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它的相关说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a Collector accepting elements of type T that counts the number of input elements. If no elements are present, the result is 0.</span><br></pre></td></tr></table></figure>
<p>这个方法会统计流中元素的个数，如果没有元素，就会返回0。</p>
<p>我们通过这种方式就实现了上述SQL的需求，运行程序就会在控制台打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;lisi=1, zhangsan=2, wangwu=1&#125;</span><br></pre></td></tr></table></figure>
<p>我们再举一个例子，之前我们是对于分组中的元素个数进行统计，那如果我们想分组的时候也统计分数的平均值，这里我们也是需要使用另一个Collectors中的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.averagingDouble(Student::getScore)));</span><br></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;lisi=90.0, zhangsan=90.0, wangwu=90.0&#125;</span><br></pre></td></tr></table></figure>
<p>与分组相关的实际上还有一个概念叫做分区，分区可以认为是特殊的分组，它只会分成两组，调用的Api分别是：</p>
<ul>
<li>分组：group by</li>
<li>分区：partition by</li>
</ul>
<p>比如，90分以上的分成一组，90分以下的分成一组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.partitioningBy(student -&gt; student.getScore() &gt;= <span class="number">90</span>));</span><br></pre></td></tr></table></figure>
<p>运行的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;false=[stream.Student@3d494fbf], true=[stream.Student@1ddc4ec2, stream.Student@133314b, stream.Student@b1bc7ed]&#125;</span><br></pre></td></tr></table></figure>
<p>至此，对于JDK8中的重要的API全部都介绍完成，学会使用是第一步也是非常重要的一步，在长时间的练习和记忆中，我们才能体会到函数式编程带给我们巨大好处，如果只是从使用的角度而言，掌握本章及之前的内容对于一般的开发者，完全是够用的，然而我想这是远远不够的，学习JDK中优秀的源码，反过来加深我们使用的时候的理解，达到相互促进的作用，这才是更重要的，因此，从下一章节开始，我们将系统而全面的分析JDK是如何实现函数式编程，以及我们之前使用的诸多的API在底层到底是如何实现的。</p>
<h1 id="collector接口"><a class="markdownIt-Anchor" href="#collector接口"></a> Collector接口</h1>
<p>Stream的源码复杂而多变，要掌握整个的流程，我们就不得不先要理清楚一些及其重要的概念和几个核心类的作用，当然一开始这是不太容易能够理解的，但是，这会为后面我们能完整的看到流的整个调用顺序打下良好的基础。</p>
<p>首先我们为接下来的部分提前定义好一个学生类作为我们分析源码的入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="comparator源码分析及实践"><a class="markdownIt-Anchor" href="#comparator源码分析及实践"></a> Comparator源码分析及实践</h2>
<p>Comparator并不是JDK8新增加的内容，但是JDK8对它做了一定程度的增强，在函数式编程中非常的常见，所以也非常的重要，在正式进入Stream源码分析之前，有必要了解关于Comparator比较器的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先可以看到这是一个函数式接口，拥有唯一的抽象方法compare，这个方法接口两个参数并且有返回值，并且在这个类中，JDK从1.8开始增加了若干个默认方法。</p>
<p>假如我们要对一个字符串数据按照首字母进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;nihao&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要按照长度来进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, (item1, item2) -&gt; item1.length() - item2.length());</span><br></pre></td></tr></table></figure>
<p>也可以使用方法引用的方式来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparingInt(String::length));</span><br></pre></td></tr></table></figure>
<p>如果是降序则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, (item1, item2) -&gt; item2.length() - item1.length());</span><br></pre></td></tr></table></figure>
<p>同样的，也可以使用方法引用的方式来实现，只是这里我们调用新的方法reversed：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparingInt(String::length).reversed());</span><br></pre></td></tr></table></figure>
<p>但是如果你这么写的话，就会发现有问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparingInt(item -&gt; item.length()).reversed());</span><br></pre></td></tr></table></figure>
<p>看起来与上面的写法是完全等价的，但IDE却会提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cannot resolve method &#x27;length()&#x27;</span><br></pre></td></tr></table></figure>
<p>原因就在于，编译器会认为此时的item是一个Object类型的对象，如果要正常编译运行，就需要显示的声明类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparingInt((String item) -&gt; item.length()).reversed());</span><br></pre></td></tr></table></figure>
<p>在我们之前的所有的例子当中，编译器都可以自动的推断出元素的类型，在这个例子当中，接收的参数ToIntFunction&lt;? super T&gt;由于没有明确的上下文（可能是T类型，也有可能是T类型以上的类型），并且由于调用了reversed获取了新的比较器，所以编译器没有办法准确的推断出类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Comparator&lt;T&gt; <span class="title">comparingInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(keyExtractor);</span><br><span class="line">      <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">          (c1, c2) -&gt; Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里为什么会是T类型以及T类型以上的类型呢？简而言之，就是可以传入自己本身以及父类的比较器，而如果传入的是父类型的比较器，比较完成之后还是会强转会原来的类型。</p>
<p>其实我们也可以直接调用list的sort方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.sort(Comparator.comparingInt(String::length).reversed());</span><br></pre></td></tr></table></figure>
<p>上面的方法都是一次排序，接下来我们看多次排序的方法，比如现根据名称排序，排好序之后对于名称相同的再根据分数进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparingInt(String::length).thenComparing((item1, item2) -&gt; item1.compareToIgnoreCase(item2)));</span><br></pre></td></tr></table></figure>
<p>其实我们也可以这样调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list,Comparator.comparingInt(String::length).thenComparing(String.CASE_INSENSITIVE_ORDER));</span><br></pre></td></tr></table></figure>
<p>这里我们使用的静态的常量是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class="line">                                     = <span class="keyword">new</span> CaseInsensitiveComparator();</span><br></pre></td></tr></table></figure>
<p>这个类本身就定义在String类当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveComparator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// use serialVersionUID from JDK 1.2.2 for interoperability</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8575799808933029326L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> n2 = s2.length();</span><br><span class="line">        <span class="keyword">int</span> min = Math.min(n1, n2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s1.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> c2 = s2.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                c1 = Character.toUpperCase(c1);</span><br><span class="line">                c2 = Character.toUpperCase(c2);</span><br><span class="line">                <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                    c1 = Character.toLowerCase(c1);</span><br><span class="line">                    c2 = Character.toLowerCase(c2);</span><br><span class="line">                    <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                        <span class="comment">// No overflow because of numeric promotion</span></span><br><span class="line">                        <span class="keyword">return</span> c1 - c2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1 - n2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>而对于thenComparing方法而言：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a lexicographic-order comparator with another comparator. If this Comparator considers two elements equal, i.e. compare(a, b) == 0, other is used to determine the order.</span><br></pre></td></tr></table></figure>
<p>与另一个比较器相比，它返回一个字典顺序的比较器，如果它的前一个比较器返回是元素的相等的情况，即compare(a, b) == 0的情况下，当前传入的比较器就会发挥作用，进行二次排序，这意味着，如果前面的比较器返回的结果不是0，那么后面的比较器就不会再调用，这一点在源代码中也有体现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparing</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> res = compare(c1, c2);</span><br><span class="line">        <span class="comment">// 当比较的结果不为0的时候直接返回，相等再执行传入的比较器。</span></span><br><span class="line">        <span class="keyword">return</span> (res != <span class="number">0</span>) ? res : other.compare(c1, c2);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，你还可以这么做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list,Comparator.comparingInt(String::length).thenComparing(Comparator.comparing(String::toLowerCase)));</span><br></pre></td></tr></table></figure>
<p>类似的，比较器也可以进行复合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparingInt(String::length).thenComparing(String::toLowerCase, Comparator.reverseOrder()));</span><br></pre></td></tr></table></figure>
<p>比这个例子稍微复杂一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list,Comparator.comparingInt(String::length).reversed().thenComparing(String::toLowerCase, Comparator.reverseOrder()));</span><br></pre></td></tr></table></figure>
<h2 id="collector源码分析"><a class="markdownIt-Anchor" href="#collector源码分析"></a> Collector源码分析</h2>
<p>Collector无疑是整个Stream源码中及其重要的一个类，了解它对于我们认识Stream类有着及其关键的作用，首先回到我们之前的例子当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line">        List&lt;Student&gt; studentList = students.stream().collect(Collectors.toList());</span><br><span class="line">        studentList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>毫无疑问，到目前这个阶段，这样的代码我们应该已经掌握的非常的熟练了，现在假设说要求使用流的方式求出列表的长度改怎么做呢？你可以使用Collectors中的静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;count: &quot;</span> + students.stream().collect(Collectors.counting()));</span><br></pre></td></tr></table></figure>
<p>可以看到，实际使用的时候，使用collect（收集器）的频率非常的高，collect本身的定义是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br></pre></td></tr></table></figure>
<p>它本身接收一个参数叫做collector，是Collector类型的，接下来的章节重点分析这个类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A mutable reduction operation that accumulates input elements into a mutable result container, optionally transforming the accumulated result into a final representation after all input elements have been processed. Reduction operations can be performed either sequentially or in parallel.</span><br><span class="line">Examples of mutable reduction operations include: accumulating elements into a Collection; concatenating strings using a StringBuilder; computing summary information about elements such as sum, min, max, or average; computing &quot;pivot table&quot; summaries such as &quot;maximum valued transaction by seller&quot;, etc. The class Collectors provides implementations of many common mutable reductions.</span><br></pre></td></tr></table></figure>
<p>它是一个可变的汇聚操作，作用是将输入元素累积到一个可变的结果容器当中。它可以在所有的元素都处理完毕后，将累积的结果转换为一个最终的表示（这是一个可选的操作），它支持串行与并行两种方式执行。什么是可变的汇聚操作呢？比如将集合中的元素添加到Collection当中，再比如使用StringBuilder将字符串拼接起来，计算关于元素的求和、最小值、最大值、平均值，这也是一种可变操作，计算“数据透视图”的时候一些汇总信息，比如计算卖方交易数量的最大值，Collectors提供了很多对于常见的可变的汇聚操作的实现（Collectors是Collector的实现类，而Collectors本身实际上是一个工厂）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Collector is specified by four functions that work together to accumulate entries into a mutable result container, and optionally perform a final transform on the result. They are:</span><br></pre></td></tr></table></figure>
<p>Collector是由以下四个方法构成，用来完成向一个可变结果容器当中添加元素的，并且对于结果进行最终的转换：</p>
<ul>
<li>creation of a new result container (supplier())</li>
<li>incorporating a new data element into a result container (accumulator())</li>
<li>combining two result containers into one (combiner())</li>
<li>performing an optional final transform on the container (finisher())</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A function that creates and returns a new mutable result container.</span><br></pre></td></tr></table></figure>
<p>supplier()是用来创建新的可变的结果容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A function that folds a value into a mutable result container.</span><br></pre></td></tr></table></figure>
<p>accumulator()是用来将一个新的数据元素添加到结果容器当中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A function that accepts two partial results and merges them. The combiner function may fold state from one argument into the other and return that, or may return a new result container.</span><br></pre></td></tr></table></figure>
<p>combiner函数接收两个部分的结果并且合并它们，combiner函数可以将状态从一个折叠成为另一个，并且返回它们，也可能返回一个新的结果容器，实际上这个是在并行中使用的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Perform the final transformation from the intermediate accumulation type A to the final result type R.</span><br><span class="line">If the characteristic IDENTITY_TRANSFORM is set, this function may be presumed to be an identity transform with an unchecked cast from A to R.</span><br></pre></td></tr></table></figure>
<p>是将中间的累积类型转换称为最终的结果类型，如果设置了IDENTITY_TRANSFORM这个特性，那么这个函数就会直接将A转型为R。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collectors also have a set of characteristics, such as Collector.Characteristics.CONCURRENT, that provide hints that can be used by a reduction implementation to provide better performance.</span><br></pre></td></tr></table></figure>
<p>Collectors还有一个描述特征的的集合，比如Collector.Characteristics.CONCURRENT，它可以通过不同的枚举值来提高并发流的执行效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Characteristics</span> </span>&#123;</span><br><span class="line">    CONCURRENT，</span><br><span class="line">    UNORDERED,</span><br><span class="line">    IDENTITY_FINISH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个枚举是定义在Collector这个接口当中的，首先来看一下类的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Characteristics indicating properties of a Collector, which can be used to optimize reduction implementations.</span><br></pre></td></tr></table></figure>
<p>Characteristics是Collector的一个属性，能够优化汇聚操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A sequential implementation of a reduction using a collector would create a single result container using the supplier function, and invoke the accumulator function once for each input element. A parallel implementation would partition the input, create a result container for each partition, accumulate the contents of each partition into a subresult for that partition, and then use the combiner function to merge the subresults into a combined result.</span><br></pre></td></tr></table></figure>
<p>对于流的串行实现会创建一个单个的结果容器，并且每个元素会调用accumulator方法一次，而对于并行实现将会对输入进行分区，对于每一个分区都会创建一个结果容器，然后使用combiner方法将每个分区的结果容器当中的内容进行合并。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To ensure that sequential and parallel executions produce equivalent results, the collector functions must satisfy an identity and an associativity constraints.</span><br></pre></td></tr></table></figure>
<p>为了确保串行与并行生成等价的结果，collector必须满足两个条件，即identity（同一性）和associativity（结合性）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The identity constraint says that for any partially accumulated result, combining it with an empty result container must produce an equivalent result. That is, for a partially accumulated result a that is the result of any series of accumulator and combiner invocations, a must be equivalent to combiner.apply(a, supplier.get()).</span><br></pre></td></tr></table></figure>
<p>同一性指的是，部分累积的结果与一个空的结果容器运算之后还是它本身，这也就是说，对于一个部分累积的结果a而言，它要满足combiner.apply(a, supplier.get())等于a。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The associativity constraint says that splitting the computation must produce an equivalent result. That is, for any input elements t1 and t2, the results r1 and r2 in the computation below must be equivalent:</span><br></pre></td></tr></table></figure>
<p>结合性指的是分割计算也会得到一个等价的结果，也就是说对于任意的输入t1和t2，和产生的结果r1和r2，下面的计算是等价的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 串行操作</span></span><br><span class="line">A a1 = supplier.get();</span><br><span class="line">   accumulator.accept(a1, t1);</span><br><span class="line">   accumulator.accept(a1, t2);</span><br><span class="line">   R r1 = finisher.apply(a1);</span><br><span class="line"><span class="comment">// 并行操作</span></span><br><span class="line">   A a2 = supplier.get();</span><br><span class="line">   accumulator.accept(a2, t1);</span><br><span class="line">   A a3 = supplier.get();</span><br><span class="line">   accumulator.accept(a3, t2);</span><br><span class="line">   R r2 = finisher.apply(combiner.apply(a2, a3)); </span><br></pre></td></tr></table></figure>
<p>也就是说无论对于串行操作还是并行操作，最终生成的结果必须是等价的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For collectors that do not have the UNORDERED characteristic, two accumulated results a1 and a2 are equivalent if finisher.apply(a1).equals(finisher.apply(a2)). For unordered collectors, equivalence is relaxed to allow for non-equality related to differences in order. (For example, an unordered collector that accumulated elements to a List would consider two lists equivalent if they contained the same elements, ignoring order.)</span><br></pre></td></tr></table></figure>
<p>对于没有UNORDERED特性的collectors来说，如果finisher.apply(a1).equals(finisher.apply(a2))，这两种累加的结果是等价的，对于无序的要求就被放松了，它会考虑到顺序上的区别带来的不相等性，比如无序的collector它累积元素到一个List当中，就会两个List是相同的，他们包含了相同的元素，忽略了顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Libraries that implement reduction based on Collector, such as Stream.collect(Collector), must adhere to the following constraints:</span><br></pre></td></tr></table></figure>
<p>基于Collector实现汇聚操作的库，比如Stream.collect(Collector)，必须要遵守下面的约定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The first argument passed to the accumulator function, both arguments passed to the combiner function, and the argument passed to the finisher function must be the result of a previous invocation of the result supplier, accumulator, or combiner functions.</span><br></pre></td></tr></table></figure>
<p>传递给accumulator方法的第一个参数，以及传递给combiner方法的两个参数，以及传递给finisher的参数，它们必须都是result supplier, accumulator, combiner上一次调用的结果。</p>
<p>看到这里还是比较难以理解的，我们首先需要理解Collector泛型的含义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; – the type of input elements to the reduction operation</span><br><span class="line">&lt;A&gt; – the mutable accumulation type of the reduction operation (often hidden as an implementation detail)</span><br><span class="line">&lt;R&gt; – the result type of the reduction operation</span><br></pre></td></tr></table></figure>
<p>T类型表示进行汇聚操作的输入元素的类型，即流中的每一个元素的类型，A类型表示汇聚操作的可变的累积类型，可以认为是每次中间结果容器的类型，R类型表示汇聚操作的结果类型，这个时候我们再来分析一个这四个方法对应的泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>BinaryOperator是因为合并的是两个部分的结果容器的类型，那最终的结果一定也是A类型，从泛型的角度就可以清楚的认识到，对于每一次的调用，supplier提供的结果容器就会传递给accumulator，而accumulator将流中待处理的元素添加到结果容器之后，又将这个部分结果传递给combiner，依次类推。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The implementation should not do anything with the result of any of the result supplier, accumulator, or combiner functions other than to pass them again to the accumulator, combiner, or finisher functions, or return them to the caller of the reduction operation.</span><br></pre></td></tr></table></figure>
<p>对于具体的实现不应该对生成的supplier、accumulator、combiner做任何的事情，除了将他们再一次传递给accumulator、combiner或者finisher方法，否则将他们返回给汇聚操作的调用者。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again.</span><br></pre></td></tr></table></figure>
<p>如果一个结果被传递给combiner或者finisher函数了，并没有返回相同的类型的对象，那么它就再也不会被使用了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Once a result is passed to the combiner or finisher function, it is never passed to the accumulator function again.</span><br></pre></td></tr></table></figure>
<p>一旦一个结果被传递给了combiner或者finisher方法，它就不会再被accumulator方法使用了（这是因为调用顺序的原因）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For non-concurrent collectors, any result returned from the result supplier, accumulator, or combiner functions must be serially thread-confined. This enables collection to occur in parallel without the Collector needing to implement any additional synchronization. The reduction implementation must manage that the input is properly partitioned, that partitions are processed in isolation, and combining happens only after accumulation is complete.</span><br></pre></td></tr></table></figure>
<p>对于非并发的collectors，从supplier, accumulator, 或者 combiner中返回的结果都一定是线程封闭的，不会被其他线程使用，这样在并发的情况下，就不用再做其他的操作来保证线程安全，每一个部分的操作都是独立的，并且只有当部分完成之后猜会进行合并的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For concurrent collectors, an implementation is free to (but not required to) implement reduction concurrently. A concurrent reduction is one where the accumulator function is called concurrently from multiple threads, using the same concurrently-modifiable result container, rather than keeping the result isolated during accumulation. A concurrent reduction should only be applied if the collector has the Collector.Characteristics.UNORDERED characteristics or if the originating data is unordered.</span><br></pre></td></tr></table></figure>
<p>对于并发的collectors，实现是可以自由的实现，一个多线程的汇聚操作指的是accumulator同时被多个线程调用，他们可以使用相同的可以并发修改的结果容器，而不是保持独立，一个并发的结果容器在什么情况下使用呢？只有当特性值设置为UNORDERED的时候，或者数据源本身不要求有序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In addition to the predefined implementations in Collectors, the static factory methods of(Supplier, BiConsumer, BinaryOperator, Characteristics...) can be used to construct collectors. For example, you could create a collector that accumulates widgets into a TreeSet with:</span><br></pre></td></tr></table></figure>
<p>除了在Collectors预先定义好的静态工厂方法可以创建一个收集器之外，还可以使用Collector中的of方法，比如你可以使用下面的方式将widget累积到TreeSet当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collector&lt;Widget, ?, TreeSet&lt;Widget&gt;&gt; intoSet =</span><br><span class="line">         Collector.of(TreeSet::<span class="keyword">new</span>, TreeSet::add,</span><br><span class="line">                      (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;);</span><br></pre></td></tr></table></figure>
<p>实际上就是除了预先定义好的收集器，我们可以通过Collector中的of方法实现自定的收集器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Performing a reduction operation with a Collector should produce a result equivalent to:</span><br></pre></td></tr></table></figure>
<p>使用一个Collector执行汇聚操作会生成的结果应该和下面的结果等价:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">R container = collector.supplier().get();</span><br><span class="line">     <span class="keyword">for</span> (T t : data)</span><br><span class="line">         collector.accumulator().accept(container, t);</span><br><span class="line">     <span class="keyword">return</span> collector.finisher().apply(container);</span><br></pre></td></tr></table></figure>
<p>这其实就是汇聚操作的整个过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">However, the library is free to partition the input, perform the reduction on the partitions, and then use the combiner function to combine the partial results to achieve a parallel reduction. (Depending on the specific reduction operation, this may perform better or worse, depending on the relative cost of the accumulator and combiner functions.)</span><br></pre></td></tr></table></figure>
<p>然而，库可以自由的对输入元素分组与分区，在每一个分区上执行这种汇聚操作，然后使用combiner方法合并部分的结果执行一个并行的汇聚操作（取决于具体的并行操作的类型，这可能效率高，也可能效率会变低，这取决于accumulator和combiner消耗的成本和代价）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collectors are designed to be composed; many of the methods in Collectors are functions that take a collector and produce a new collector. For example, given the following collector that computes the sum of the salaries of a stream of employees:</span><br></pre></td></tr></table></figure>
<p>收集器是被设计成可以组合的，这意味着，Collectors很多方法可以接收collector作为参数返回一个新的collector，例如一个员工构成的流的工资的总数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collector&lt;Employee, ?, Integer&gt; summingSalaries</span><br><span class="line">        = Collectors.summingInt(Employee::getSalary))</span><br></pre></td></tr></table></figure>
<p>如果我们想实现收集器的复合改怎么做呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If we wanted to create a collector to tabulate the sum of salaries by department, we could reuse the &quot;sum of salaries&quot; logic using Collectors.groupingBy(Function, Collector):</span><br></pre></td></tr></table></figure>
<p>如果以向创建一个根据部门对于工资的总和表格化，我们就可以重用“工资总和”逻辑，然后使用分组方法Collectors.groupingBy(Function, Collector):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collector&lt;Employee, ?, Map&lt;Department, Integer&gt;&gt; summingSalariesByDept</span><br><span class="line">        = Collectors.groupingBy(Employee::getDepartment, summingSalaries);</span><br></pre></td></tr></table></figure>
<p>这里的第二个参数就是我们上面定义过的收集器，这就实现了收集器的复合。</p>
<h2 id="collector实践"><a class="markdownIt-Anchor" href="#collector实践"></a> Collector实践</h2>
<p>Collector接口有且仅有唯一的实现类CollectorImpl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectorImpl</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;A&gt; supplier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BiConsumer&lt;A, T&gt; accumulator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BinaryOperator&lt;A&gt; combiner;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;A, R&gt; finisher;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Characteristics&gt; characteristics;</span><br><span class="line"></span><br><span class="line">    CollectorImpl(Supplier&lt;A&gt; supplier,</span><br><span class="line">                  BiConsumer&lt;A, T&gt; accumulator,</span><br><span class="line">                  BinaryOperator&lt;A&gt; combiner,</span><br><span class="line">                  Function&lt;A,R&gt; finisher,</span><br><span class="line">                  Set&lt;Characteristics&gt; characteristics) &#123;</span><br><span class="line">        <span class="keyword">this</span>.supplier = supplier;</span><br><span class="line">        <span class="keyword">this</span>.accumulator = accumulator;</span><br><span class="line">        <span class="keyword">this</span>.combiner = combiner;</span><br><span class="line">        <span class="keyword">this</span>.finisher = finisher;</span><br><span class="line">        <span class="keyword">this</span>.characteristics = characteristics;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CollectorImpl(Supplier&lt;A&gt; supplier,</span><br><span class="line">                  BiConsumer&lt;A, T&gt; accumulator,</span><br><span class="line">                  BinaryOperator&lt;A&gt; combiner,</span><br><span class="line">                  Set&lt;Characteristics&gt; characteristics) &#123;</span><br><span class="line">        <span class="keyword">this</span>(supplier, accumulator, combiner, castingIdentity(), characteristics);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> combiner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> finisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> characteristics;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这个类没有定义在一个单独的文件当中，而是定义在Collectors当中，这个类本身并没有做任何事情，只是根据Collector接口的要求，将需要的属性和方法定义好。这么做的理由是什么呢？实际上是一种设计上的考量，Collectors类被用来生产一些常见的方法，它绝大部分的方法都是静态方法，可以直接调用，而作为Collector的工厂，所有的方法一定会返回CollectorImpl类型，而在别的地方，又不会用到CollectorImpl，所以设计者直接将这个类作为一个静态的内部类。</p>
<p>接下来我们就围绕Collectors为我们提供的诸多的静态方法展开，了解这些方法的使用以及实现细节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Implementations of Collector that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc.</span><br></pre></td></tr></table></figure>
<p>Collectors实现了Collector接口并提供了很多很有用的汇聚操作，比如将元素累积到一个集合当中，比如摘要（最大值、最小值、平均值等等）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The following are examples of using the predefined collectors to perform common mutable reduction tasks:</span><br></pre></td></tr></table></figure>
<p>下面的例子就是使用JDK预先定义好的方法来执行可变的汇聚任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Accumulate names into a List</span></span><br><span class="line">List&lt;String&gt; list = people.stream().map(Person::getName).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accumulate names into a TreeSet</span></span><br><span class="line">Set&lt;String&gt; set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert elements to strings and concatenate them, separated by commas</span></span><br><span class="line">String joined = things.stream()</span><br><span class="line">                      .map(Object::toString)</span><br><span class="line">                      .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute sum of salaries of employee</span></span><br><span class="line"><span class="keyword">int</span> total = employees.stream()</span><br><span class="line">                     .collect(Collectors.summingInt(Employee::getSalary)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Group employees by department</span></span><br><span class="line">Map&lt;Department, List&lt;Employee&gt;&gt; byDept</span><br><span class="line">    = employees.stream()</span><br><span class="line">               .collect(Collectors.groupingBy(Employee::getDepartment));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute sum of salaries by department</span></span><br><span class="line">Map&lt;Department, Integer&gt; totalByDept</span><br><span class="line">    = employees.stream()</span><br><span class="line">               .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                                              Collectors.summingInt(Employee::getSalary)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partition students into passing and failing</span></span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing =</span><br><span class="line">    students.stream()</span><br><span class="line">            .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</span><br></pre></td></tr></table></figure>
<p>在完整的理解了收集器相关的概念之后，我们可以看一些具体的例子，针对于之前的学生的集合，如果我们想求出学生分数的最小值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.minBy(Comparator.comparingInt(Student::getScore))).ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>
<p>如果是最大值呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.maxBy(Comparator.comparingInt(Student::getScore))).ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>
<p>如果是平均值呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println( students.stream().collect(Collectors.averagingInt(Student::getScore)));</span><br></pre></td></tr></table></figure>
<p>如果是求出分数的总和呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(students.stream().collect(Collectors.summingInt(Student::getScore)));</span><br></pre></td></tr></table></figure>
<p>当然也可以调用统计的方法一次将这些特征值都求出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(students.stream().collect(Collectors.summarizingInt(Student::getScore)));</span><br></pre></td></tr></table></figure>
<p>如果想将学生的名字使用字符串拼接呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining()));</span><br></pre></td></tr></table></figure>
<p>还可以使用逗号分隔：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>还可以拼接前缀和后缀：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;&lt;begin&gt;&quot;</span>,<span class="string">&quot;&lt;end&gt;&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>除了这些常规的操作，其实对于分组的操作还可以进行二级分组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.groupingBy(Student::getScore,Collectors.groupingBy(Student::getName)));</span><br></pre></td></tr></table></figure>
<p>类似的对于分区的操作也可以进行二级分区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.partitioningBy(student -&gt; student.getScore() &gt; <span class="number">90</span>, Collectors.        partitioningBy(student -&gt; student.getScore() &gt; <span class="number">80</span>)));</span><br></pre></td></tr></table></figure>
<p>分组和分区还可以互相嵌套：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.partitioningBy(student -&gt; student.getScore() &gt; <span class="number">80</span>, Collectors.counting()));</span><br></pre></td></tr></table></figure>
<p>下面我们来看一个稍微复杂一点的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.groupingBy(Student::getName,Collectors.collectingAndThen(Collectors.minBy(Comparator.comparingInt(Student::getScore)), Optional::get)));</span><br></pre></td></tr></table></figure>
<h2 id="自定义collector"><a class="markdownIt-Anchor" href="#自定义collector"></a> 自定义Collector</h2>
<p>在进行Collector源码分析的时候，我们提到过Characteristics这个内部枚举类，接下来我们首先分析每一个枚举项代表的含义：</p>
<p>1、CONCURRENT</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Indicates that this collector is concurrent, meaning that the result container can support the accumulator function being called concurrently with the same result container from multiple threads.</span><br><span class="line">If a CONCURRENT collector is not also UNORDERED, then it should only be evaluated concurrently if applied to an unordered data source.</span><br></pre></td></tr></table></figure>
<p>CONCURRENT表示当前的收集器是并发的，这意味着中间结果容器支持使用多线程进行并发访问，CONCURRENT并不是UNORDERED，只有无序的数据源才可以使用这个属性。</p>
<p>2、UNORDERED</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Indicates that the collection operation does not commit to preserving the encounter order of input elements. (This might be true if the result container has no intrinsic order, such as a Set.)</span><br></pre></td></tr></table></figure>
<p>UNORDERED意味着收集的操作并不确保保留输入元素的顺序（可以用在结果容器不要求有序的场景下，比如Set）</p>
<p>3、IDENTITY_FINISH</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Indicates that the finisher function is the identity function and can be elided. If set, it must be the case that an unchecked cast from A to R will succeed.</span><br></pre></td></tr></table></figure>
<p>IDENTITY_FINISH表示finisher方法就是identity方法，可以被省略掉，如果设置了这个属性，那么就要确保从A类型到R类型的强制转换是可以成功的。</p>
<p>接下来我们实现一个自定义的收集器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetCollector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;supplier invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> HashSet::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;accmulator invoked!&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里不能调用HashSet::add，因为无法保证与supplier()方法返回的中间结果容器类型相同</span></span><br><span class="line">        <span class="keyword">return</span> Set::add;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;combiner invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (set1, set2) -&gt; &#123;</span><br><span class="line">            set1.addAll(set2);</span><br><span class="line">            <span class="keyword">return</span> set1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;Set&lt;T&gt;, Set&lt;T&gt;&gt; finisher() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finisher invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Function.identity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;characteristics invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH, Characteristics.UNORDERED));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; set = list.stream().collect(<span class="keyword">new</span> MySetCollector&lt;&gt;());</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">supplier invoked!</span><br><span class="line">accmulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">[world, hello, welcome]</span><br></pre></td></tr></table></figure>
<p>可以看到supplier、accumulator、combiner分别执行了一次，而characteristics执行了两次，只有finisher没有被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> P_OUT, A, R&gt; collector)</span> </span>&#123;</span><br><span class="line">    A container;</span><br><span class="line">    <span class="comment">// 如果是并行流</span></span><br><span class="line">    <span class="keyword">if</span> (isParallel()</span><br><span class="line">            &amp;&amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))</span><br><span class="line">            &amp;&amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &#123;</span><br><span class="line">        container = collector.supplier().get();</span><br><span class="line">        BiConsumer&lt;A, ? <span class="keyword">super</span> P_OUT&gt; accumulator = collector.accumulator();</span><br><span class="line">        forEach(u -&gt; accumulator.accept(container, u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        container = evaluate(ReduceOps.makeRef(collector));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// characteristics()在这里被第二次调用，用于判断中间结果容器与最终返回的类型是否相同,如果包含了IDENTITY_FINISH这个特性，直接进行强制类型转换，会将中间结果容器强制转换为最终的结果类型。</span></span><br><span class="line">    <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)</span><br><span class="line">           ? (R) container</span><br><span class="line">           : collector.finisher().apply(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们显然是串行流，所以直接进入到第二种情况，首先我们来看一下ReduceOps的makeRef方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, I&gt; <span class="function">TerminalOp&lt;T, I&gt;</span></span><br><span class="line"><span class="function">   <span class="title">makeRef</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, I, ?&gt; collector)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 我们的方法就是在这里被调用了，返回了supplier、accumulator、combiner三个对象。</span></span><br><span class="line">       Supplier&lt;I&gt; supplier = Objects.requireNonNull(collector).supplier();</span><br><span class="line">       BiConsumer&lt;I, ? <span class="keyword">super</span> T&gt; accumulator = collector.accumulator();</span><br><span class="line">       BinaryOperator&lt;I&gt; combiner = collector.combiner();</span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">ReducingSink</span> <span class="keyword">extends</span> <span class="title">Box</span>&lt;<span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">               <span class="keyword">implements</span> <span class="title">AccumulatingSink</span>&lt;<span class="title">T</span>, <span class="title">I</span>, <span class="title">ReducingSink</span>&gt; </span>&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">               state = supplier.get();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">               accumulator.accept(state, t);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(ReducingSink other)</span> </span>&#123;</span><br><span class="line">               state = combiner.apply(state, other.state);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ReduceOp&lt;T, I, ReducingSink&gt;(StreamShape.REFERENCE) &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> ReducingSink <span class="title">makeSink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> ReducingSink();</span><br><span class="line">           &#125;</span><br><span class="line">		<span class="comment">// Characteristics()在这里被第一次调用，用于判断是否有序</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOpFlags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.UNORDERED)</span><br><span class="line">                      ? StreamOpFlag.NOT_ORDERED</span><br><span class="line">                      : <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>为了验证关于Characteristics方法的调用逻辑，我们去掉characteristics方法中的枚举项IDENTITY_FINISH：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;characteristics invoked!&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of( Characteristics.UNORDERED));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>观察结果，finsher就得到了调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">supplier invoked!</span><br><span class="line">accmulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">finisher invoked!</span><br><span class="line">[world, hello, welcome]</span><br></pre></td></tr></table></figure>
<p>接下来我们定义一个中间结果容器需要进行类型转换的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetCollector2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;, <span class="title">Map</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;supplier invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> HashSet::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;accmulator invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (set, item) -&gt; set.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;combiner invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (set1, set2) -&gt; &#123;</span><br><span class="line">            set1.addAll(set2);</span><br><span class="line">            <span class="keyword">return</span> set1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;Set&lt;T&gt;, Map&lt;T, T&gt;&gt; finisher() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finisher invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> set -&gt; &#123;</span><br><span class="line">            Map&lt;T, T&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">            set.forEach(item -&gt; map.put(item, item));</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;characteristics invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;welcome&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.addAll(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;set: &quot;</span> + set);</span><br><span class="line">        Map&lt;String, String&gt; map = set.stream().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">supplier invoked!</span><br><span class="line">accmulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">finisher invoked!</span><br><span class="line">&#123;a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome&#125;</span><br></pre></td></tr></table></figure>
<p>如果将这个枚举值修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED,Characteristics.IDENTITY_FINISH));</span><br></pre></td></tr></table></figure>
<p>就会抛出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.util.HashSet cannot be cast to java.util.Map</span><br></pre></td></tr></table></figure>
<p>这就是因为我们的中间结果类型是Set类型，而最终的结果类型是Map类型，同时也说明了characteristics就定义了中间结果容器和最终结果的结果容器类型的关系，在运行期间，JDK会根据这个枚举项类判断他们之间的关系，如果编写错误了，就可能会出现错误。</p>
<p>另外如果中间结果容器和最终结果的结果容器类型相同，但是需要对于中间结果容器做一些处理才返回结果，这个时候也要去掉IDENTITY_FINISH这个枚举值，因为在执行过程中，会直接转换类型，而不会操作里面的值。</p>
<p>如果我们在accumulator中打印当前线程的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;accmulator invoked!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (set, item) -&gt; &#123;</span><br><span class="line">        set.add(item);</span><br><span class="line">        System.out.println(<span class="string">&quot;accmulator: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台就会打印十次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br></pre></td></tr></table></figure>
<p>去掉集合中重复的元素&quot;hello&quot;,正好是十个元素，执行了十次累积的操作，并且都是主线程的，如果我们使用并行流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = set.parallelStream().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br></pre></td></tr></table></figure>
<p>运行的结果就变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set: [a, b, world, c, d, e, f, g, hello, welcome]</span><br><span class="line">characteristics invoked!</span><br><span class="line">supplier invoked!</span><br><span class="line">accmulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-5</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-4</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-3</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-1</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-1</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-3</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-3</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-5</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">characteristics invoked!</span><br><span class="line">finisher invoked!</span><br><span class="line">&#123;a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便观察并行流和串行流的区别，我们打印一下，进行累积操作的集合中的元素，再次运行，就会发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set: [a, b, world, c, d, e, f, g, hello, welcome]</span><br><span class="line">characteristics invoked!</span><br><span class="line">supplier invoked!</span><br><span class="line">accmulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">[hello]</span><br><span class="line">[b]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">accmulator: main</span><br><span class="line">[f]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-3</span><br><span class="line">[d]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-1</span><br><span class="line">[d, e]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-1</span><br><span class="line">[welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-4</span><br><span class="line">[f, g]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-3</span><br><span class="line">[b, world]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">[b, world, c]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">[a]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-5</span><br><span class="line">characteristics invoked!</span><br><span class="line">finisher invoked!</span><br><span class="line">&#123;a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome&#125;</span><br></pre></td></tr></table></figure>
<p>这里就会开启多个线程，这个时候如果再设置CONCURRENT特性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED, Characteristics.CONCURRENT));</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set: [a, b, world, c, d, e, f, g, hello, welcome]</span><br><span class="line">characteristics invoked!</span><br><span class="line">supplier invoked!</span><br><span class="line">====================================</span><br><span class="line">accmulator invoked!</span><br><span class="line">[hello]</span><br><span class="line">accmulator: main</span><br><span class="line">[hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">[f, hello, welcome]</span><br><span class="line">[b, f, hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-3</span><br><span class="line">[a, b, f, hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-4</span><br><span class="line">[a, b, world, d, f, g, hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-3</span><br><span class="line">[a, b, world, d, f, hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">[a, b, d, f, hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-1</span><br><span class="line">[a, b, world, c, d, e, f, g, hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-1</span><br><span class="line">[a, b, world, c, d, f, g, hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">characteristics invoked!</span><br><span class="line">finisher invoked!</span><br><span class="line">&#123;a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome&#125;</span><br></pre></td></tr></table></figure>
<p>如果执行的次数过多，还有可能会出现如下报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.ConcurrentModificationException: java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure>
<p>这是因为设置了CONCURRENT特性，多个线程就会操作同一个中间结果容器，而在我们的程序中，除了往集合中不断累加元素之外，还在打印集合中的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;accmulator invoked!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (set, item) -&gt; &#123;</span><br><span class="line">        set.add(item);</span><br><span class="line">        System.out.println(<span class="string">&quot;accmulator: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将导致，偶发的情况下就会出现并发修改的异常，这就要求在在定义Collector的是偶，如果设置了CONCURRENT特性，accumulator方法只能进行累积的操作，而尽量不要进行其他的操作。</p>
<p>总结一下，在使用并行流的时候，如果设置了CONCURRENT特性，那么多个线程就会操作操作同一个中间结果容器，而这个唯一的结果容器就是最终的结果容器，如果没有设置这个特性，那么就会操作不同的中间结果容器，换言之，如果设置了CONCURRENT特性，那么combiner就不会被调用，因为无需进行最后的合并操作，而如果没有设置，那么combiner就会得到调用。</p>
<p>总而言之combiner被调用有两个条件，一个是并行流，一个是没有设置CONCURRENT特性，中间结果容器的个数也是类似的，只有当开启并行流，并且没有设置过CONCURRENT特性的时候才会创建和流中元素个数相同的中间结果容器。</p>
<p>开启并行流的方式除了之前我们使用过的parallelStream，其实还可以这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = set.stream().parallel().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br></pre></td></tr></table></figure>
<p>如果要使用串行流，你也可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = set.stream().sequential().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br></pre></td></tr></table></figure>
<p>甚至可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = set.stream().sequential().parallel().sequential().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br></pre></td></tr></table></figure>
<p>但需要注意的是，这里程序并不会依次的调用，而是会调用最后指定的方式，也就是说，上面的代码其实等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = set.stream().sequential().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br></pre></td></tr></table></figure>
<p>这两种写法完全是等价的，这是因为，选择并行流还是串行流，仅仅是由一个布尔值来控制的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * True if pipeline is parallel, otherwise the pipeline is sequential; only</span></span><br><span class="line"><span class="comment">  * valid for the source stage.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">boolean</span> parallel;</span><br></pre></td></tr></table></figure>
<h2 id="collectors源码分析"><a class="markdownIt-Anchor" href="#collectors源码分析"></a> Collectors源码分析</h2>
<p>自定义Collector的过程帮助我们很好的理解了关于Collector的基本概念，我们也尝试着自己实现了两个相对比较简单的例子，Collectors作为生产Collector的静态工厂类，里面有大量的关于Collector的实现，本节我们就分析JDK已经帮我们实现的Collector的例子，学习这些例子，有助于我们强化对于Collector的理解。</p>
<p>对于Collectors静态工厂来说，实现Collector，总的来说分为两种情况：</p>
<ol>
<li>通过CollectorImpl来实现</li>
<li>通过reducing方法来实现，而reducing方法本身又是通过CollectorImpl来实现的。</li>
</ol>
<p>首先我们来分析一下我们使用过的最多的toList方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                                (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                                CH_ID);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里的(Supplier&lt;List<T>&gt;) ArrayList::new也可以写成<code>ArrayList&lt;T&gt;::new</code>，这里的第四个参数是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Collector.Characteristics&gt; CH_ID</span><br><span class="line">        = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH));</span><br></pre></td></tr></table></figure>
<p>这里的属性值是IDENTITY_FINISH，意味着中间结果容器的类型和最终返回的结果类型相同，所以无需定义finisher。对于toList还有一个接受的更宽广的toCollection：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt;</span><br><span class="line"> Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(collectionFactory, Collection&lt;T&gt;::add,</span><br><span class="line">                                (r1, r2) -&gt; &#123; r1.addAll(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">                                CH_ID);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里只是提供了创建结果容器的入口，例如，要使用LinkedList，你只需要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().collect(Collectors.toCollection(LinkedList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>
<p>对于toSet方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"> Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet() &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;Set&lt;T&gt;&gt;) HashSet::<span class="keyword">new</span>, Set::add,</span><br><span class="line">                                (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                                CH_UNORDERED_ID);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>由于Set集合本身是无序的，并且最终返回的结果也是Set类型，所以它的特性值是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Collector.Characteristics&gt; CH_UNORDERED_ID</span><br><span class="line">        = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.UNORDERED,</span><br><span class="line">                                                 Collector.Characteristics.IDENTITY_FINISH));</span><br></pre></td></tr></table></figure>
<p>对于joining方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">            StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</span><br><span class="line">            (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">            StringBuilder::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>joining方法与之前的方法不同的是，它还调用了finisher方法，这是因为需要将StringBuilder转为String类型。这里的第四个参数指的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Collector.Characteristics&gt; CH_NOID = Collections.emptySet();</span><br></pre></td></tr></table></figure>
<p>返回的是一个空的集合，说明三个特性都不具备。</p>
<p>joining还有一个重载的方法，可以增加前缀和后缀：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,</span><br><span class="line">                                                         CharSequence prefix,</span><br><span class="line">                                                         CharSequence suffix) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> StringJoiner(delimiter, prefix, suffix),</span><br><span class="line">            StringJoiner::add, StringJoiner::merge,</span><br><span class="line">            StringJoiner::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StringJoiner是JDK1.8提供的一个新的类，用于完成字符串的拼接操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U, A, R&gt;</span><br><span class="line">Collector&lt;T, ?, R&gt; mapping(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper,</span><br><span class="line">                           Collector&lt;? <span class="keyword">super</span> U, A, R&gt; downstream) &#123;</span><br><span class="line">    BiConsumer&lt;A, ? <span class="keyword">super</span> U&gt; downstreamAccumulator = downstream.accumulator();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(downstream.supplier(),</span><br><span class="line">                               (r, t) -&gt; downstreamAccumulator.accept(r, mapper.apply(t)),</span><br><span class="line">                               downstream.combiner(), downstream.finisher(),</span><br><span class="line">                               downstream.characteristics());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个相对比较复杂的例子，我们先来读一下方法说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Adapts a Collector accepting elements of type U to one accepting elements of type T by applying a mapping function to each input element before accumulation.</span><br></pre></td></tr></table></figure>
<p>mapping方法被用来在累积操作之前对每个输入元素都应用mapping方法，将接收的U类型映射为T类型，从而实现收集器的映射。</p>
<p>方法本身接收两个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapper – a function to be applied to the input elements</span><br><span class="line">downstream – a collector which will accept mapped values</span><br></pre></td></tr></table></figure>
<p>这里的下游指的是，将要被映射的值，给出了一个具体的案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity</span><br><span class="line">        = people.stream().collect(groupingBy(Person::getCity,</span><br><span class="line">                                             mapping(Person::getLastName, toSet())));</span><br></pre></td></tr></table></figure>
<p>比这个例子稍微复杂一点的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T,A,R,RR&gt; Collector&lt;T,A,RR&gt; <span class="title">collectingAndThen</span><span class="params">(Collector&lt;T,A,R&gt; downstream,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                            Function&lt;R,RR&gt; finisher)</span> </span>&#123;</span><br><span class="line">    Set&lt;Collector.Characteristics&gt; characteristics = downstream.characteristics();</span><br><span class="line">    <span class="keyword">if</span> (characteristics.contains(Collector.Characteristics.IDENTITY_FINISH)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (characteristics.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 如果只有IDENTITY_FINISH特性，就将特性值设置为空</span></span><br><span class="line">            characteristics = Collectors.CH_NOID;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将IDENTITY_FINISH去掉</span></span><br><span class="line">            characteristics = EnumSet.copyOf(characteristics);</span><br><span class="line">            characteristics.remove(Collector.Characteristics.IDENTITY_FINISH);</span><br><span class="line">            characteristics = Collections.unmodifiableSet(characteristics);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(downstream.supplier(),</span><br><span class="line">                               downstream.accumulator(),</span><br><span class="line">                               downstream.combiner(),</span><br><span class="line">                               downstream.finisher().andThen(finisher),</span><br><span class="line">                               characteristics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先来读一下方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Adapts a Collector to perform an additional finishing transformation. For example, one could adapt the toList() collector to always produce an immutable list with:</span><br></pre></td></tr></table></figure>
<p>适配一个Collector来执行finisher方法的转换，例如，我们可以使用这个方法将使用toList收集的方法来转换为一个不可变的集合，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; people</span><br><span class="line">       = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList));</span><br></pre></td></tr></table></figure>
<p>toList本身方法返回的是一个ArrayList对象，本身是可变的，通过这种方式就可以得到一个不可变的集合列表，方法实现中将原来流中的IDENTITY_FINISH特性去掉的原因在于，如果设置了这个特性值，finisher方法就不会得到执行，而collectingAndThen方法的目的就在于转换最终的结果类型，关键就在于需要执行的finisher方法。</p>
<p>接下来我们看一个之前使用的方法，summingInt的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt;</span><br><span class="line">summingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>],</span><br><span class="line">            (a, t) -&gt; &#123; a[<span class="number">0</span>] += mapper.applyAsInt(t); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[<span class="number">0</span>] += b[<span class="number">0</span>]; <span class="keyword">return</span> a; &#125;,</span><br><span class="line">            a -&gt; a[<span class="number">0</span>], CH_NOID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>summingInt方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a Collector that produces the sum of a integer-valued function applied to the input elements. If no elements are present, the result is 0.</span><br></pre></td></tr></table></figure>
<p>返回的Collector是对流中的每一个元素执行传入的整型值函数，如果流中没有元素，就返回0。</p>
<p>需要说明的是，这里为什么不直接使用数字，而是new了一个int类型的数组，原因在于数字是值类型的，而数组是引用类型的，值类型的参数无法进行传递，数组本身也符合容器的定义，只不过这里每次只是取出来数组中唯一的元素，对数组中唯一的元素进行累加的操作。</p>
<p>以上都是通过CollectorImpl来实现的Collector，接下来我们看一下通过reducing来实现的例子，首先来查看reducing方法的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt;</span><br><span class="line">Collector&lt;T, ?, U&gt; reducing(U identity,</span><br><span class="line">                            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper,</span><br><span class="line">                            BinaryOperator&lt;U&gt; op) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">            boxSupplier(identity),</span><br><span class="line">            (a, t) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], mapper.apply(t)); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], b[<span class="number">0</span>]); <span class="keyword">return</span> a; &#125;,</span><br><span class="line">            a -&gt; a[<span class="number">0</span>], CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reducing方法也是借助CollectorImpl来实现的Collector的，我们来阅读一下reducing方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a Collector which performs a reduction of its input elements under a specified mapping function and BinaryOperator. This is a generalization of reducing(Object, BinaryOperator) which allows a transformation of the elements before reduction.</span><br></pre></td></tr></table></figure>
<p>groupingBy和partitioningBy是整个Collectors类中比较难以理解的两部分，关键的部分在于，理解每个泛型代表的含义以及每个参数的作用，在有了前面的基础之后，我们有必要了解一下有关分区和分组的实现。首先来看一下groupingBy方法的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</span><br><span class="line">groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T类型表示流中元素的类型，？表示的是中间结果容器的类型，Map是最终的结果类型，K表示分类的时候的key的类型，<code>List&lt;T&gt;</code>就表示根据分类依据K分类之后的列表集合，方法本身的参数并没有直接使用T和K，而是使用T类型以及T以上的类型，K类型以及K类型以下的类型，并且只接受一个参数，调用了另一个重载的groupingBy方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt;</span><br><span class="line">Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                                      Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的第一个参数是一个Function类型，第二个参数是Collector类型的，同样的，我们需要搞清楚这里每一个泛型的含义，T表示流中元素的类型，K表示分类器返回的结果的类型，或者说是返回的Map的key的类型，D表示Map返回的值的类型，方法要完成的事情实际上就是要将downstream在收集的时候，应用分类器classifier。它本身又调用一个重载的方法，在查看之前首先需要了解一个JDK中新增加的方法，在最终构造返回的accumulator的时候，我们要用到Map接口中所新增加的默认方法computeIfAbsent：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">computeIfAbsent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="params"><span class="function">            Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(mappingFunction);</span><br><span class="line">    	<span class="comment">// 	V表示当前map的值的类型</span></span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">if</span> ((v = get(key)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V newValue;</span><br><span class="line">            <span class="keyword">if</span> ((newValue = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                put(key, newValue);</span><br><span class="line">                <span class="keyword">return</span> newValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null.</span><br></pre></td></tr></table></figure>
<p>如果给定一个key与值没有关联起来（或者键映射为空），直接返回结果，如果它不为空的话，将尝试着计算他们的值使用给定的映射方法，就将他放入到map里面。总而言之，如果key不存在，则返回，如果存在，就执行mappingFunction，然后将映射之后的值放入到map当中。</p>
<p>下面的方式是groupingBy真正执行的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt;</span><br><span class="line">    Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                                  Supplier&lt;M&gt; mapFactory,</span><br><span class="line">                                  Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    	<span class="comment">// A表示下游收集器的中间结果容器类型</span></span><br><span class="line">        Supplier&lt;A&gt; downstreamSupplier = downstream.supplier();</span><br><span class="line">    	<span class="comment">// T表示流中元素的类型</span></span><br><span class="line">        BiConsumer&lt;A, ? <span class="keyword">super</span> T&gt; downstreamAccumulator = downstream.accumulator();</span><br><span class="line">    	<span class="comment">// 构造最终所返回的累加器对象</span></span><br><span class="line">        BiConsumer&lt;Map&lt;K, A&gt;, T&gt; accumulator = (m, t) -&gt; &#123;</span><br><span class="line">            K key = Objects.requireNonNull(classifier.apply(t), <span class="string">&quot;element cannot be mapped to a null key&quot;</span>);</span><br><span class="line">            A container = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get());</span><br><span class="line">            downstreamAccumulator.accept(container, t);</span><br><span class="line">        &#125;;</span><br><span class="line">    	<span class="comment">// 完成两个Map的合并操作</span></span><br><span class="line">        BinaryOperator&lt;Map&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, Map&lt;K, A&gt;&gt;mapMerger(downstream.combiner());</span><br><span class="line">    	<span class="comment">// 将M类型强转为&lt;K,A&gt;类型，M本身是&lt;K,D&gt;类型，由于中间结果类型一定是&lt;K,A&gt;类型，所以可以强转成功。</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Supplier&lt;Map&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;Map&lt;K, A&gt;&gt;) mapFactory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_ID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 下游收集器本身返回的是&lt;A,D&gt;类型的，这里也是由于一定是&lt;A,A&gt;类型的，所以可以强转成功。</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher();</span><br><span class="line">            <span class="comment">// 将Map中的键值对替换 </span></span><br><span class="line">            Function&lt;Map&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; &#123;</span><br><span class="line">                intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v));</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                M castResult = (M) intermediate;</span><br><span class="line">                <span class="keyword">return</span> castResult;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_NOID);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第一个参数是一个分类器，输入类型是T，返回的是K类型，第二个参数是accumulator累加器的类型，对应上面例子中的HashMap::new，第三个参数是下游收集器，其中的A表示的是中间结果的容器类型，在整个方法的返回类型中，泛型M的定义是M extends Map&lt;K, D&gt;。首先我们来阅读以下这个方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a Collector implementing a cascaded &quot;group by&quot; operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector. The Map produced by the Collector is created with the supplied factory function.</span><br></pre></td></tr></table></figure>
<p>groupingBy方法返回了完成对于给定T类型的层叠的分组操作的Collector，它是根据提供的分类器来对元素进行分组的，然后会对于给定的key所关联的值（即Map）使用给定的下游收集器执行汇聚操作，Collector所使用的Map是由supplied工厂函数提供的。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The classification function maps elements to some key type K. The downstream collector operates on elements of type T and produces a result of type D. The resulting collector produces a Map&lt;K, D&gt;.</span><br></pre></td></tr></table></figure>
<p>分类器方法会将元素映射成某个k类型，然后下游收集器会对流中T类型的元素生成一个D类型的结果，所生成的collector类型是Map&lt;K,D&gt;。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For example, to compute the set of last names of people in each city, where the city names are sorted:</span><br></pre></td></tr></table></figure>
<p>比如要根据城市的名字对城市中每个人的姓进行分组，并且返回的结果要求带有排序的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;City, Set&lt;String&gt;&gt; namesByCity</span><br><span class="line">       = people.stream().collect(groupingBy(Person::getCity, TreeMap::<span class="keyword">new</span>,</span><br><span class="line">                                            mapping(Person::getLastName, toSet())));</span><br></pre></td></tr></table></figure>
<p>关于分组的方法还有另外的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The returned Collector is not concurrent. For parallel stream pipelines, the combiner function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using groupingByConcurrent(Function, Supplier, Collector) may offer better parallel performance.</span><br></pre></td></tr></table></figure>
<p>groupingBy方法返回的Collector不是并发的，对于并行流管道，combiner方法会将一个map的key合并到另一个当中，这可能是一个昂贵的操作，如果对于下游收集器而言，元素的顺序不是很重要的话，建议使用groupingByConcurrent，它可以提供更好的并发的性能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt;</span><br><span class="line">Collector&lt;T, ?, ConcurrentMap&lt;K, D&gt;&gt; groupingByConcurrent(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                                                          Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingByConcurrent(classifier, ConcurrentHashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因就在于groupingByConcurrent使用的是ConcurrentHashMap。</p>
<p>与groupingBy相关联的另一个方法就是分区partitioningBy：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate) &#123;</span><br><span class="line">    <span class="keyword">return</span> partitioningBy(predicate, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它也有两个重载的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, D, A&gt;</span><br><span class="line">Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate,</span><br><span class="line">                                                Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    BiConsumer&lt;A, ? <span class="keyword">super</span> T&gt; downstreamAccumulator = downstream.accumulator();</span><br><span class="line">    BiConsumer&lt;Partition&lt;A&gt;, T&gt; accumulator = (result, t) -&gt;</span><br><span class="line">            downstreamAccumulator.accept(predicate.test(t) ? result.forTrue : result.forFalse, t);</span><br><span class="line">    BinaryOperator&lt;A&gt; op = downstream.combiner();</span><br><span class="line">    BinaryOperator&lt;Partition&lt;A&gt;&gt; merger = (left, right) -&gt;</span><br><span class="line">            <span class="keyword">new</span> Partition&lt;&gt;(op.apply(left.forTrue, right.forTrue),</span><br><span class="line">                            op.apply(left.forFalse, right.forFalse));</span><br><span class="line">    Supplier&lt;Partition&lt;A&gt;&gt; supplier = () -&gt;</span><br><span class="line">            <span class="keyword">new</span> Partition&lt;&gt;(downstream.supplier().get(),</span><br><span class="line">                            downstream.supplier().get());</span><br><span class="line">    <span class="keyword">if</span> (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(supplier, accumulator, merger, CH_ID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Function&lt;Partition&lt;A&gt;, Map&lt;Boolean, D&gt;&gt; finisher = par -&gt;</span><br><span class="line">                <span class="keyword">new</span> Partition&lt;&gt;(downstream.finisher().apply(par.forTrue),</span><br><span class="line">                                downstream.finisher().apply(par.forFalse));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(supplier, accumulator, merger, finisher, CH_NOID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的Partition是用来定义分组结果的一个静态内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Partition</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">Boolean</span>, <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">         <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">Boolean</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> T forTrue;</span><br><span class="line">     <span class="keyword">final</span> T forFalse;</span><br><span class="line"></span><br><span class="line">     Partition(T forTrue, T forFalse) &#123;</span><br><span class="line">         <span class="keyword">this</span>.forTrue = forTrue;</span><br><span class="line">         <span class="keyword">this</span>.forFalse = forFalse;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Set&lt;Map.Entry&lt;Boolean, T&gt;&gt; entrySet() &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> AbstractSet&lt;Map.Entry&lt;Boolean, T&gt;&gt;() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;Boolean, T&gt;&gt; iterator() &#123;</span><br><span class="line">                 Map.Entry&lt;Boolean, T&gt; falseEntry = <span class="keyword">new</span> SimpleImmutableEntry&lt;&gt;(<span class="keyword">false</span>, forFalse);</span><br><span class="line">                 Map.Entry&lt;Boolean, T&gt; trueEntry = <span class="keyword">new</span> SimpleImmutableEntry&lt;&gt;(<span class="keyword">true</span>, forTrue);</span><br><span class="line">                 <span class="keyword">return</span> Arrays.asList(falseEntry, trueEntry).iterator();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>之所以这么做的原因是，分区一定是固定的两组结果，如果再使用Map类描述的话并不是特别清晰。</p>
<h1 id="stream原理"><a class="markdownIt-Anchor" href="#stream原理"></a> Stream原理</h1>
<p>收集器是我们认识整个Stream的第一步，在了解了有关收集器的内容之后，可以为我们了解Stream打下良好的基础，这一部分是整个函数式编程最核心的部分，我们将会看到JDK在底层到底是如何巧妙的实现函数式编程。</p>
<h2 id="stream源码分析"><a class="markdownIt-Anchor" href="#stream源码分析"></a> Stream源码分析</h2>
<p>在正式开始介绍之前，需要有一些预备的知识，从JDK1.7开始增加了这样一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An object that may hold resources (such as file or socket handles) until it is closed. The close() method of an AutoCloseable object is called automatically when exiting a try-with-resources block for which the object has been declared in the resource specification header. This construction ensures prompt release, avoiding resource exhaustion exceptions and errors that may otherwise occur.</span><br></pre></td></tr></table></figure>
<p>这是一个关闭之前可能持有一些资源（比如文件、socket句柄）的对象，它的close方法会在退出 try-with-resources代码块的时候自动得到调用，这种调用的机制被声明在资源的规范的头里面，这种设置确保了可以适当的释放一些资源，避免了资源被消耗尽造异常外和错误。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoCloseableTest</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;close invoked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething invoked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (AutoCloseableTest autoCloseableTest = <span class="keyword">new</span> AutoCloseableTest()) &#123;</span><br><span class="line">            autoCloseableTest.doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种方式可以替换原来的需要人为的显示关闭各种流的操作，close方法会自动的得到调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doSomething invoked!</span><br><span class="line">close invoked!</span><br></pre></td></tr></table></figure>
<p>接下来我们就完整的梳理一下关于Sream类本身的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A sequence of elements supporting sequential and parallel aggregate operations. The following example illustrates an aggregate operation using Stream and IntStream:</span><br></pre></td></tr></table></figure>
<p>首先Stream是一个支持并行与串行聚合操作的元素的序列，下面的示例演示了如何让使用Stream和IntStream进行聚合操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = widgets.stream()</span><br><span class="line">                      .filter(w -&gt; w.getColor() == RED)</span><br><span class="line">                      .mapToInt(w -&gt; w.getWeight())</span><br><span class="line">                      .sum();</span><br></pre></td></tr></table></figure>
<p>对于这个例子的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this example, widgets is a Collection&lt;Widget&gt;. We create a stream of Widget objects via Collection.stream(), filter it to produce a stream containing only the red widgets, and then transform it into a stream of int values representing the weight of each red widget. Then this stream is summed to produce a total weight.</span><br></pre></td></tr></table></figure>
<p>在这个例子当中，widgets是Widget类型的集合，我们通过使用Collection的stream方法创建了一个Widget对象的流，生成了一个新的只包含红色的Widget的流，然后将它转换成int值的Stream对象，代表了每个红色Widget的重量，最后流被汇总起来生成一个总的重量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In addition to Stream, which is a stream of object references, there are primitive specializations for IntStream, LongStream, and DoubleStream, all of which are referred to as &quot;streams&quot; and conform to the characteristics and restrictions described here.</span><br></pre></td></tr></table></figure>
<p>Stream本身是一个对象引用流，除了他还有一些原生的、特化的版本。比如IntStream、LongStream、DoubleStream，他们都被称之为Stream，满足Stream的特性，遵循Stream的相关约束。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To perform a computation, stream operations are composed into a stream pipeline. A stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more intermediate operations (which transform a stream into another stream, such as filter(Predicate)), and a terminal operation (which produces a result or side-effect, such as count() or forEach(Consumer)). Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed.</span><br></pre></td></tr></table></figure>
<p>为了进行计算，Stream会被组合成一个Stream pipeline（流管道）当中，一个流管道包含了一个元（可以是一个数组，一个集合，一个生成器法，一个I/O通道等等），包含0个或多个中间操作（会将一个Stream转换为另一个Stream，比如filter(Predicate)），包含一个终止操作（将会产生一个结果或者是有副作用的，比如count() 或者forEach(Consumer)），流是延迟的，只有当终止操作开始的时候，才会对元数据的计算才会真正的进行执行，元的数据只有在需要的时候才会被消费。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collections and streams, while bearing some superficial similarities, have different goals. Collections are primarily concerned with the efficient management of, and access to, their elements. By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. However, if the provided stream operations do not offer the desired functionality, the iterator() and spliterator() operations can be used to perform a controlled traversal.</span><br></pre></td></tr></table></figure>
<p>集合与流，他们有一些相似性，但是有不同的目标，集合主要考虑的是高效的访问和管理他们的元素，与之相反，流并不会直接提供直接的去操作元素的方式，而是通过声明式的方式来描述他们元以及操作，这些操作会被聚合起来应用到他们的元上面，流关注的是元的计算。然而，如果提供的流操作并没有所需要的功能，那么iterator()和spliterator() 就可以执行控制性的遍历（即采用传统的方式来进行一些流的操作）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A stream pipeline, like the &quot;widgets&quot; example above, can be viewed as a query on the stream source. Unless the source was explicitly designed for concurrent modification (such as a ConcurrentHashMap), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried.</span><br></pre></td></tr></table></figure>
<p>一个流管道，比如刚才的widgets，它可以被看成是一种对于流元的查询，除非这个流被显示的设计成可以并发修改的（比如ConcurrentHashMap），否则一些错误的型为就可能会产生并发修改的异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Most stream operations accept parameters that describe user-specified behavior, such as the lambda expression w -&gt; w.getWeight() passed to mapToInt in the example above. To preserve correct behavior, these behavioral parameters:</span><br></pre></td></tr></table></figure>
<p>大多数的流都会接收用户指定的一种行为，比如Lambda表达式 w -&gt; w.getWeight()，为了保证最终结果的正确性，这些行为参数都要满足下面的这些条件特性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">must be non-interfering (they do not modify the stream source); and</span><br><span class="line">in most cases must be stateless (their result should not depend on any state that might change during execution of the stream pipeline).</span><br></pre></td></tr></table></figure>
<ul>
<li>他们必须是冲突非干扰的，</li>
<li>在大多数情况下都是一种无状态的操作（结果不应该依赖于在流管道执行过程当中可能会修改的任意状态）,即执行的结果与执行的顺序是无关的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Such parameters are always instances of a functional interface such as Function, and are often lambda expressions or method references. Unless otherwise specified these parameters must be non-null.</span><br></pre></td></tr></table></figure>
<p>这些参数总是一个函数式接口的实例。比如说Lamda表达式，除特殊情况外，参数都是非空的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stream should be operated on (invoking an intermediate or terminal stream operation) only once. This rules out, for example, &quot;forked&quot; streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream. A stream implementation may throw IllegalStateException if it detects that the stream is being reused. However, since some stream operations may return their receiver rather than a new stream object, it may not be possible to detect reuse in all cases.</span><br></pre></td></tr></table></figure>
<p>一个流调用中间操作或者终止操作只能被操作一次，这并不是绝对的，比如”派生“的流，相同的元会提供两个或多个流管道，或者对相同的元执行多次的遍历，如果检测到流被重用了，就会抛出IllegalStateException，然而有些流操作可能会返回他们的接收者而并不是一个新的Stream对象，这种情况下是无法检测到被重用的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Streams have a close() method and implement AutoCloseable, but nearly all stream instances do not actually need to be closed after use. Generally, only streams whose source is an IO channel (such as those returned by Files.lines(Path, Charset)) will require closing. Most streams are backed by collections, arrays, or generating functions, which require no special resource management. (If a stream does require closing, it can be declared as a resource in a try-with-resources statement.)</span><br></pre></td></tr></table></figure>
<p>流都实现了AutoCloseable接口，因此都会自动的调用close方法，但是几乎所有的流实例在使用完成之后都不需要关闭，只有当流的元是一个IO通道的时候（比如从Files.lines返回对象）需要被关闭，大多数流的元都是集合、数组、或者生成器函数，他们并不需要特殊的资源管理（如果一个流确实需要关闭，它会使用try-with-resources声明成一个资源）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream pipelines may execute either sequentially or in parallel. This execution mode is a property of the stream. Streams are created with an initial choice of sequential or parallel execution. (For example, Collection.stream() creates a sequential stream, and Collection.parallelStream() creates a parallel one.) This choice of execution mode may be modified by the sequential() or parallel() methods, and may be queried with the isParallel() method.</span><br></pre></td></tr></table></figure>
<p>流管道可以通过并行或者是串行的方式来去执行，这种执行方式只是流里面的一个属性而已，流初始被创建的时候就会选择串行还是并行的（比如Collection.stream() 创建的就是串行流，Collection.parallelStream()创建的就是并行流），这种执行模式的选择，还可以通过sequential()或者parallel() 方法进行修改，并且还可以通过isParallel() 方法来查询流的类型。</p>
<p>以上就是关于Stream这个类的内容，Stream本身又继承了BaseStream类，BaseStream定义了所有流、流的操作、流管道以及并行流的行为和种类，我们首先来看一下BaseStream类的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseStream</span>&lt;<span class="title">T</span>, <span class="title">S</span> <span class="keyword">extends</span> <span class="title">BaseStream</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回针对于流中元素的迭代器</span></span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 这是流的终止操作，返回流中元素的分割迭代器</span></span><br><span class="line">    <span class="function">Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 判断流是否是并行流，只能在流的终止操作之前进行调用</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isParallel</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 返回一个等价的串行流，有可能会返回流本身，也有可能会将底层的流修改为串行流，这是一个中间操作</span></span><br><span class="line">    <span class="function">S <span class="title">sequential</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 返回一个等价的并行流，有可能返回流本身，也有可能将底层的流修改为并行流，这是一个中间操作</span></span><br><span class="line">    <span class="function">S <span class="title">parallel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回一个无序的流，有可能返回流本身，原因是流本身就是无序的，这是一个中间操作</span></span><br><span class="line">    <span class="function">S <span class="title">unordered</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 返回一个额外带有关闭处理器的流，当流的close方法被调用的时候，就会按照被添加进去的顺序得到调用，所有的关闭处理器都会得到调用而无论它之前的关闭处理器是否抛出了异常，如果任意的关闭处理器抛出了异常，那么抛出的第一个异常就会被抛给close方法的调用者，其余的异常就会作为被压制的异常（除非其余的异常是与第一个异常相同的异常，因为一个异常不能压制它本身），同样的，他也有可能返回自己</span></span><br><span class="line">    <span class="function">S <span class="title">onClose</span><span class="params">(Runnable closeHandler)</span></span>;</span><br><span class="line">	<span class="comment">// 关闭这个流，所有的流管道处理器都会得到调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的泛型T代表流中元素的类型，S指的是实现了BaseStream类型的流对象，实际上指的就是中间操作返回的新的流对象，回到Stream类的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stream</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseStream</span>&lt;<span class="title">T</span>, <span class="title">Stream</span>&lt;<span class="title">T</span>&gt;&gt; </span></span><br></pre></td></tr></table></figure>
<p>对照BaseStream的定义不难发现，这里的泛型S指的就是<code>Stream&lt;T&gt;</code>,而<code>Stream&lt;T&gt;</code>又正好继承了BaseStream，所以这个泛型是成立的。</p>
<p>关于关闭处理器可以举一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用这种方式是为了执行Stream的close方法</span></span><br><span class="line">        <span class="keyword">try</span> (Stream&lt;String&gt; stream = list.stream()) &#123;</span><br><span class="line">            stream.onClose(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            &#125;).onClose(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">            &#125;).forEach(System.out::println);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello world</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br></pre></td></tr></table></figure>
<p>修改一下程序，观察有异常发生的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; stream = list.stream()) &#123;</span><br><span class="line">         stream.onClose(() -&gt; &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;first exception&quot;</span>);</span><br><span class="line">         &#125;).onClose(() -&gt; &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">         &#125;).forEach(System.out::println);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>就会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; hello</span><br><span class="line">world</span><br><span class="line">hello world</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">java.lang.NullPointerException: first exception</span><br><span class="line">	at Stream2.StreamTest2.lambda$main$0(StreamTest2.java:18)</span><br><span class="line">	at java.util.stream.Streams$1.run(Streams.java:850)</span><br><span class="line">	at java.util.stream.AbstractPipeline.close(AbstractPipeline.java:323)</span><br><span class="line">	at Stream2.StreamTest2.main(StreamTest2.java:22)</span><br><span class="line"></span><br><span class="line">FAILURE: Build failed with an exception.</span><br></pre></td></tr></table></figure>
<p>可以看到虽然抛出了异常，但是后面的关闭处理器依然得到了执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">Exception in thread &quot;main&quot; world</span><br><span class="line">hello world</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">java.lang.NullPointerException: first exception</span><br><span class="line">	at Stream2.StreamTest2.lambda$main$0(StreamTest2.java:18)</span><br><span class="line">	at java.util.stream.Streams$1.run(Streams.java:850)</span><br><span class="line">	at java.util.stream.AbstractPipeline.close(AbstractPipeline.java:323)</span><br><span class="line">	at Stream2.StreamTest2.main(StreamTest2.java:23)</span><br><span class="line">	Suppressed: java.lang.NullPointerException: second exception</span><br><span class="line">		at Stream2.StreamTest2.lambda$main$1(StreamTest2.java:21)</span><br><span class="line">		at java.util.stream.Streams$1.run(Streams.java:854)</span><br><span class="line">		... 2 more</span><br></pre></td></tr></table></figure>
<p>这里的Suppressed就是压制的异常信息，可以看到后续的异常都被压制了,针对于文档中提到相同的异常，就不会被压制，指的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   NullPointerException nullPointerException = <span class="keyword">new</span> NullPointerException(<span class="string">&quot;exception&quot;</span>);    </span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; stream = list.stream()) &#123;</span><br><span class="line">           stream.onClose(() -&gt; &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">               <span class="keyword">throw</span> nullPointerException;</span><br><span class="line">           &#125;).onClose(() -&gt; &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">               <span class="keyword">throw</span> nullPointerException;</span><br><span class="line">           &#125;).forEach(System.out::println);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">Exception in thread &quot;main&quot; world</span><br><span class="line">hello world</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">java.lang.NullPointerException: exception</span><br><span class="line">	at Stream2.StreamTest2.main(StreamTest2.java:15)</span><br><span class="line"></span><br><span class="line">FAILURE: Build failed with an exception.</span><br></pre></td></tr></table></figure>
<h2 id="spliterator源码分析"><a class="markdownIt-Anchor" href="#spliterator源码分析"></a> Spliterator源码分析</h2>
<p>Spliterator被称之为分割迭代器，是整个流实现非常重要的一环，从本节开始，就正式进入的流源码的分析。</p>
<p>首先还是定义一个非常简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用的Collection接口中的stream方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们来阅读一下方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a sequential Stream with this collection as its source.</span><br><span class="line">This method should be overridden when the spliterator() method cannot return a spliterator that is IMMUTABLE, CONCURRENT, or late-binding. (See spliterator() for details.)</span><br></pre></td></tr></table></figure>
<p>stream方法会调用的将集合作为流的元，并且返回一个串行流，当spliterator方法无法返回IMMUTABLE（不可变的）、CONCURRENT（并行的）、late-binding（延迟绑定的）的分割迭代器，那么这个方法应该当被重写。</p>
<p>stream方法的参数也是定义在Collection集合中的默认方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下这个方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creates a Spliterator over the elements in this collection. Implementations should document characteristic values reported by the spliterator. Such characteristic values are not required to be reported if the spliterator reports Spliterator.SIZED and this collection contains no elements.</span><br><span class="line">The default implementation should be overridden by subclasses that can return a more efficient spliterator. In order to preserve expected laziness behavior for the stream() and parallelStream()&#125; methods, spliterators should either have the characteristic of IMMUTABLE or CONCURRENT, or be late-binding. If none of these is practical, the overriding class should describe the spliterator&#x27;s documented policy of binding and structural interference, and should override the stream() and parallelStream() methods to create streams using a Supplier of the spliterator, as in:</span><br></pre></td></tr></table></figure>
<p>创建一个针对于这个集合的元素分割迭代器，实现应该对于spliterator方法所返回的Spliterator特性值进行文档化（记录下来），这些特性值并不要求去报告，如果这个Spliterator报告了Spliterator.SIZED，并且这个集合不包含任何元素，默认的实现应该要被子类所重写，目的是为了返回一个效率更高的分割迭代器，为了保留stream、parallelStream两个方法的延迟特性，spliterators的特性值要么是IMMUTABLE或者CONCURRENT，要么就是late-binding，如果上面这些都无法实现，重写的类需要文档化spliterator的绑定策略，并且使用spliterator的Supplier重写stream和parallelStream方法，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;E&gt; s = StreamSupport.stream(() -&gt; spliterator(), spliteratorCharacteristics)</span><br></pre></td></tr></table></figure>
<p>应该使用这种方式来定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">These requirements ensure that streams produced by the stream() and parallelStream() methods will reflect the contents of the collection as of initiation of the terminal stream operation.</span><br></pre></td></tr></table></figure>
<p>这些要求确保了由stream和parallelStream方法生成的流从终止流操作开始发起的时候就反应出流的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The default implementation creates a late-binding spliterator from the collections&#x27;s Iterator. The spliterator inherits the fail-fast properties of the collection&#x27;s iterator.</span><br><span class="line">The created Spliterator reports Spliterator.SIZED.</span><br></pre></td></tr></table></figure>
<p>默认的实现会从集合的迭代器创建一个延迟绑定的分割迭代器，创建出来的分割迭代器继承了集合迭代器的快速失败（如果碰到问题，程序不再往下执行，直接抛出异常）的属性，创建出来的分割迭代器具有 Spliterator.SIZED（固定大小）的特性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The created Spliterator additionally reports Spliterator.SUBSIZED.</span><br></pre></td></tr></table></figure>
<p>所创建出来的Spliterator还有一个额外的特性：Spliterator.SUBSIZED（所分割出来的每个块的大小是固定的）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If a spliterator covers no elements then the reporting of additional characteristic values, beyond that of SIZED and SUBSIZED, does not aid clients to control, specialize or simplify computation. However, this does enable shared use of an immutable and empty spliterator instance (see Spliterators.emptySpliterator()) for empty collections, and enables clients to determine if such a spliterator covers no elements.</span><br></pre></td></tr></table></figure>
<p>如果分割迭代器中没有任何元素，那么除了IZED和SUBSIZED其他的特性值并不会简化客户端的计算，但是可以重用一个空的、不可变的分割迭代器，是不是里面没有元素，并且对于空的集合，可以帮助客户端来判断spliterator里面是不是没有元素。</p>
<p>Spliterator和Spliterators的关系就好像Collector和Collectors的关系一样，Spliterators针对于Spliterator提供了若干的静态方法，接下来就正式开始了解有关Spliterator的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An object for traversing and partitioning elements of a source. The source of elements covered by a Spliterator could be, for example, an array, a Collection, an IO channel, or a generator function.</span><br></pre></td></tr></table></figure>
<p>Spliterator是一个对于元中的元素进行遍历和分区的对象，Spliterator 元中的元素可以是数组，可以是集合，可以是IO通道，也可以是一个生成器函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Spliterator may traverse elements individually (tryAdvance()) or sequentially in bulk (forEachRemaining()).</span><br></pre></td></tr></table></figure>
<p>一个Spliterator可以使用tryAdvance单个的遍历元素，也可以使用forEachRemaining成块的遍历元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Spliterator may also partition off some of its elements (using trySplit) as another Spliterator, to be used in possibly-parallel operations. Operations using a Spliterator that cannot split, or does so in a highly imbalanced or inefficient manner, are unlikely to benefit from parallelism. Traversal and splitting exhaust elements; each Spliterator is useful for only a single bulk computation.</span><br></pre></td></tr></table></figure>
<p>一个Spliterator也可以对它的元素使用trySplit进行分区，形成另外的Spliterator，并且可以被并行的使用。如果使用Spliterator不能进行分割，或者分割的不平衡或者效率非常低的方式，那使用并行就并没有带来多少的好处。遍历和分割都会消耗元素，每一个Spliterator仅仅是对一个单块的计算是有用的（每一块元素都有自己的分割迭代器）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Spliterator also reports a set of characteristics() of its structure, source, and elements from among ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, and SUBSIZED. These may be employed by Spliterator clients to control, specialize or simplify computation. For example, a Spliterator for a Collection would report SIZED, a Spliterator for a Set would report DISTINCT, and a Spliterator for a SortedSet would also report SORTED. Characteristics are reported as a simple unioned bit set. Some characteristics additionally constrain method behavior; for example if ORDERED, traversal methods must conform to their documented ordering. New characteristics may be defined in the future, so implementors should not assign meanings to unlisted values.</span><br></pre></td></tr></table></figure>
<p>Spliterator还会报告它的结构、元、元素的特性值ORDERED（有序的）、DISTINCT（不同的）、SORTED（排序的）、SIZED（确定大小的）、NONNULL（不为空的）、IMMUTABLE（不可变的）、CONCURRENT（并放大的）、SUBSIZED（子部分固定大小的），这些可以被Spliterator的客户端使用，使用他们来简化一些计算，比如说，如果元是Collection集合，那么它就会报告SIZED的特性值，如果元是Set集合，那么就会报告DISTINCT，如果元是SortedSet集合，那么就会报告SORTED，Characteristics会作为一个位操作来标识的，有一些特性值会额外限制方法的行为，比如ORDERED，那么遍历的时候就必须遵循遍历时候的顺序，未来可能会定义一些新的characteristics，所以不要使用这些特性值之外的值，可能会引起冲突。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Spliterator that does not report IMMUTABLE or CONCURRENT is expected to have a documented policy concerning: when the spliterator binds to the element source; and detection of structural interference of the element source detected after binding. A late-binding Spliterator binds to the source of elements at the point of first traversal, first split, or first query for estimated size, rather than at the time the Spliterator is created. A Spliterator that is not late-binding binds to the source of elements at the point of construction or first invocation of any method. Modifications made to the source prior to binding are reflected when the Spliterator is traversed. After binding a Spliterator should, on a best-effort basis, throw ConcurrentModificationException if structural interference is detected. Spliterators that do this are called fail-fast. The bulk traversal method (forEachRemaining()) of a Spliterator may optimize traversal and check for structural interference after all elements have been traversed, rather than checking per-element and failing immediately.</span><br></pre></td></tr></table></figure>
<p>当分割迭代器绑定到元上元素的时候，如果Spliterator没有报告IMMUTABLE或者CONCURRENT，期望可以文档化。并且在绑定之后，要对元素的结构上一些修改进行相应检测，延迟绑定的Spliterator会在元素第一次分割、遍历的，或者笫一次查询元素大小的时候绑定。而不是在Spliterator创建的时候绑定的，如果不是延迟绑定的Spliterator，就会在元创建的时候或者说第一次调用方法时候进行绑定。如果在绑定元之前对元进行了修改的话，这种修改就会在分割迭代器遍历的时候反映出来，如果绑定之后对元进行了修改，就会抛出ConcurrentModificationException的异常，按照这种方式我们称之为&quot;快速失败&quot;，块的遍历方法（例如forEachRemaining）会优化遍历并检测结构上的修改，在所有的元素都遍历之后，而不是对每个元素一次检测。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spliterators can provide an estimate of the number of remaining elements via the estimateSize method. Ideally, as reflected in characteristic SIZED, this value corresponds exactly to the number of elements that would be encountered in a successful traversal. However, even when not exactly known, an estimated value may still be useful to operations being performed on the source, such as helping to determine whether it is preferable to split further or traverse the remaining elements sequentially.</span><br></pre></td></tr></table></figure>
<p>Spliterators通过estimateSize方法来估算剩余元素的个数，理想情况下，通过特性值SIZED获取到的值就是之后遍历元素个数的值，不过，即便不是精确的知道待遍历元素的数量，一个估算的值，对于元的操作也是很有用的，比如可以帮助对元进行进一步的分割或者对于剩余的元素进行串行的遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Despite their obvious utility in parallel algorithms, spliterators are not expected to be thread-safe; instead, implementations of parallel algorithms using spliterators should ensure that the spliterator is only used by one thread at a time. This is generally easy to attain via serial thread-confinement, which often is a natural consequence of typical parallel algorithms that work by recursive decomposition. A thread calling trySplit() may hand over the returned Spliterator to another thread, which in turn may traverse or further split that Spliterator. The behaviour of splitting and traversal is undefined if two or more threads operate concurrently on the same spliterator. If the original thread hands a spliterator off to another thread for processing, it is best if that handoff occurs before any elements are consumed with tryAdvance(), as certain guarantees (such as the accuracy of estimateSize() for SIZED spliterators) are only valid before traversal has begun.</span><br></pre></td></tr></table></figure>
<p>尽管他们显著的功能在算法当中，分割迭代器并不被要求是线程安全的，相反，使用了spliterators并行算法的实现，应该确保了分割迭代器在某个时候一次只有一个线程使用，这可以使用serial thread-confinement这种模式来实现。这是一个通过递归解耦得到的自然的结果。一个调用了trySplit的一个线程，它可以将返回的Spliterator交由另一个线程接管，另一个线程可能会进一步的分割，分割以及遍历的行为是不确定的，如果两个或者多个线程操作同一个Spliterator，如果原来的线程将Spliterator交由另外一个线程处理的话，那么最好这种传递是发生在任何元素在使用tryAdvance方法消费之前完成，因为某些保证实在执行之前才是有效的（比如统计元素个数的estimateSize方法，SIZED特性值）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Primitive subtype specializations of Spliterator are provided for int, long, and double values. The subtype default implementations of tryAdvance(Consumer) and forEachRemaining(Consumer) box primitive values to instances of their corresponding wrapper class. Such boxing may undermine any performance advantages gained by using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, Spliterator.OfInt.tryAdvance(IntConsumer) and Spliterator.OfInt.forEachRemaining(IntConsumer) should be used in preference to Spliterator.OfInt.tryAdvance(Consumer) and Spliterator.OfInt.forEachRemaining(Consumer). Traversal of primitive values using boxing-based methods tryAdvance() and forEachRemaining() does not affect the order in which the values, transformed to boxed values, are encountered.</span><br></pre></td></tr></table></figure>
<p>原生的子类型的特化也提供了。比如int、long、double，普通的方法接收的参数tryAdvance(Consumer) and forEachRemaining(Consumer)，这些参数就会使用包装类型，这样就有可能影响了性能上的优势，为了避免装箱拆箱操作带来的性能消耗，就应该使用Spliterator.OfInt.tryAdvance(IntConsumer) 和Spliterator.OfInt.forEachRemaining(IntConsumer) ，如果可以使用特化版本就不要使用通用版本。无论使用哪种方式，元素的顺序与之前的保持一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spliterators, like Iterators, are for traversing the elements of a source. The Spliterator API was designed to support efficient parallel traversal in addition to sequential traversal, by supporting decomposition as well as single-element iteration. In addition, the protocol for accessing elements via a Spliterator is designed to impose smaller per-element overhead than Iterator, and to avoid the inherent race involved in having separate methods for hasNext() and next().</span><br></pre></td></tr></table></figure>
<p>Spliterators就像Iterators一样，也是用来遍历元当中的元素的，Spliterator的API设计为串行和高效的并行方式来进行元素的遍历，通过支持解耦、分解、单元素的遍历迭代，此外，相对于Iterator，使用Spliterator来遍历元素的成本是更低的，因为避免了在使用hasNext和next方法的竞争的出现（使用Iterators遍历元素通常需要两者搭配使用，但Spliterator只需要通过一个方法tryAdvance）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For mutable sources, arbitrary and non-deterministic behavior may occur if the source is structurally interfered with (elements added, replaced, or removed) between the time that the Spliterator binds to its data source and the end of traversal. For example, such interference will produce arbitrary, non-deterministic results when using the java.util.stream framework.</span><br></pre></td></tr></table></figure>
<p>对于可变的元来说，如果元在绑定了Spliterator之后，遍历结束之前在结构上被修改了（元素的添加、替换、移除）就可能出现一些不确定的行为，比如说，在使用java.util.stream 框架的这种修改可能出现这些不确定的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Structural interference of a source can be managed in the following ways (in approximate order of decreasing desirability):</span><br></pre></td></tr></table></figure>
<p>一个元在结构上的改变是可以通过如下的几种方式来进行管理的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The source cannot be structurally interfered with. For example, an instance of java.util.concurrent.CopyOnWriteArrayList is an immutable source. A Spliterator created from the source reports a characteristic of IMMUTABLE.</span><br></pre></td></tr></table></figure>
<p>1、元的结构是不能被修改的，例如，java.util.concurrent.CopyOnWriteArrayLis就是一个不可变的元，通过这种元创建的Spliterator会返回一个IMMUTABLE的特性值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The source manages concurrent modifications. For example, a key set of a java.util.concurrent.ConcurrentHashMap is a concurrent source. A Spliterator created from the source reports a characteristic of CONCURRENT.</span><br></pre></td></tr></table></figure>
<p>2、元本身管理并发修改，例如java.util.concurrent.ConcurrentHashMap键的集合就是一个并发的元，通过这种元创建的Spliterator会返回一个CONCURRENT的特性值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The mutable source provides a late-binding and fail-fast Spliterator. Late binding narrows the window during which interference can affect the calculation; fail-fast detects, on a best-effort basis, that structural interference has occurred after traversal has commenced and throws ConcurrentModificationException. For example, ArrayList, and many other non-concurrent Collection classes in the JDK, provide a late-binding, fail-fast spliterator.</span><br></pre></td></tr></table></figure>
<p>3、可变的元提供了一种延迟绑定和快速失败的Spliterator，延迟绑定会限制修改影响计算的时间间隔，可变的元</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The mutable source provides a non-late-binding but fail-fast Spliterator. The source increases the likelihood of throwing ConcurrentModificationException since the window of potential interference is larger.</span><br></pre></td></tr></table></figure>
<p>4、可变的元提供了非延迟绑定但是快速失败的Spliterator，发生ConcurrentModificationException可能性就会增加，因为时间间隔增大了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The mutable source provides a late-binding and non-fail-fast Spliterator. The source risks arbitrary, non-deterministic behavior after traversal has commenced since interference is not detected.</span><br></pre></td></tr></table></figure>
<p>5、可变的元提供了延迟绑定但是非快速失败的Spliterator，这个时候元就有一些风险，在遍历已经开始之后就可能发生一些不确定的行为。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The mutable source provides a non-late-binding and non-fail-fast Spliterator. The source increases the risk of arbitrary, non-deterministic behavior since non-detected interference may occur after construction.</span><br></pre></td></tr></table></figure>
<p>6、可变的元提供了延迟绑定并且快速失败的Spliterator，也会增加不确定的风险，在构造之后增加不确定的行为的可能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example. Here is a class (not a very useful one, except for illustration) that maintains an array in which the actual data are held in even locations, and unrelated tag data are held in odd locations. Its Spliterator ignores the tags.</span><br></pre></td></tr></table></figure>
<p>这里给出了一个例子（并不具有实用性，只是为了说明问题），数据实际上是存储在数组的偶数位置上，不相关的标签数据是存放在基数的位置上的，它对应的Spliterator会忽略掉标签，即只关心偶书位置上的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaggedArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 构造之后就是一个不可变的数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object[] elements;</span><br><span class="line">  TaggedArray(T[] data, Object[] tags) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = data.length;</span><br><span class="line">    <span class="comment">// 数据和标签的个数应该相同</span></span><br><span class="line">    <span class="keyword">if</span> (tags.length != size) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.elements = <span class="keyword">new</span> Object[<span class="number">2</span> * size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">      elements[j++] = data[i];</span><br><span class="line">      elements[j++] = tags[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TaggedArraySpliterator&lt;&gt;(elements, <span class="number">0</span>, elements.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TaggedArraySpliterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] array;</span><br><span class="line">    <span class="comment">// 当前的索引，在遍历的时候会自增</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> origin;</span><br><span class="line">    <span class="comment">// 超过最大索引值加1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fence;</span><br><span class="line"></span><br><span class="line">    TaggedArraySpliterator(Object[] array, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence) &#123;</span><br><span class="line">      <span class="keyword">this</span>.array = array; <span class="keyword">this</span>.origin = origin; <span class="keyword">this</span>.fence = fence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (; origin &lt; fence; origin += <span class="number">2</span>)</span><br><span class="line">        action.accept((T) array[origin]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (origin &lt; fence) &#123;</span><br><span class="line">        action.accept((T) array[origin]);</span><br><span class="line">        <span class="comment">// tag中的数据不需要</span></span><br><span class="line">        origin += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 分开一半的范围</span></span><br><span class="line">      <span class="keyword">int</span> lo = origin;</span><br><span class="line">      <span class="comment">// 取中点</span></span><br><span class="line">      <span class="keyword">int</span> mid = ((lo + fence) &gt;&gt;&gt; <span class="number">1</span>) &amp; ~<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 分割左侧的</span></span><br><span class="line">      <span class="keyword">if</span> (lo &lt; mid) &#123;</span><br><span class="line">        <span class="comment">// 重新设置范围</span></span><br><span class="line">        origin = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TaggedArraySpliterator&lt;&gt;(array, lo, mid);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>  <span class="comment">// 太小了，无法分割</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">long</span>)((fence - origin) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ORDERED | SIZED | IMMUTABLE | SUBSIZED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子是一个串行的例子，接下来还提供了一个并行的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">As an example how a parallel computation framework, such as the java.util.stream package, would use Spliterator in a parallel computation, here is one way to implement an associated parallel forEach, that illustrates the primary usage idiom of splitting off subtasks until the estimated amount of work is small enough to perform sequentially. Here we assume that the order of processing across subtasks doesn&#x27;t matter; different (forked) tasks may further split and process elements concurrently in undetermined order. This example uses a java.util.concurrent.CountedCompleter; similar usages apply to other parallel task constructions.</span><br></pre></td></tr></table></figure>
<p>如何使用并行框架来尽心给计算，例如使用java.util.stream package，在并行情况下使用Spliterator，它描述了对于分割子任务的分割方法，如何将子任务进行分割，如果分割的足够小的话，再以串行的方式去执行，下面的例子使用了java.util.concurrent.CountedCompleter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">parEach</span><span class="params">(TaggedArray&lt;T&gt; a, Consumer&lt;T&gt; action)</span> </span>&#123;</span><br><span class="line">   Spliterator&lt;T&gt; s = a.spliterator();</span><br><span class="line">   <span class="keyword">long</span> targetBatchSize = s.estimateSize() / (ForkJoinPool.getCommonPoolParallelism() * <span class="number">8</span>);</span><br><span class="line">   <span class="keyword">new</span> ParEach(<span class="keyword">null</span>, s, action, targetBatchSize).invoke();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParEach</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">CountedCompleter</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Spliterator&lt;T&gt; spliterator;</span><br><span class="line">   <span class="keyword">final</span> Consumer&lt;T&gt; action;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">long</span> targetBatchSize;</span><br><span class="line"></span><br><span class="line">   ParEach(ParEach&lt;T&gt; parent, Spliterator&lt;T&gt; spliterator,</span><br><span class="line">           Consumer&lt;T&gt; action, <span class="keyword">long</span> targetBatchSize) &#123;</span><br><span class="line">     <span class="keyword">super</span>(parent);</span><br><span class="line">     <span class="keyword">this</span>.spliterator = spliterator; <span class="keyword">this</span>.action = action;</span><br><span class="line">     <span class="keyword">this</span>.targetBatchSize = targetBatchSize;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Spliterator&lt;T&gt; sub;</span><br><span class="line">     <span class="keyword">while</span> (spliterator.estimateSize() &gt; targetBatchSize &amp;&amp;</span><br><span class="line">            (sub = spliterator.trySplit()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">       addToPendingCount(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">new</span> ParEach&lt;&gt;(<span class="keyword">this</span>, sub, action, targetBatchSize).fork();</span><br><span class="line">     &#125;</span><br><span class="line">     spliterator.forEachRemaining(action);</span><br><span class="line">     propagateCompletion();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If the boolean system property org.openjdk.java.util.stream.tripwire is set to true then diagnostic warnings are reported if boxing of primitive values occur when operating on primitive subtype specializations.</span><br></pre></td></tr></table></figure>
<p>如果系统变量org.openjdk.java.util.stream.tripwire被设置成true的话，如果在操作原生子类型特化的时候，对原生的子类型进行装箱操作，系统就会给出警告。</p>
<p>以上是关于Spliterator这个类本身的说明，接下来Spliterator接口本身提供的一些方法进行说明：</p>
<p>首先是tryAdvance方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If a remaining element exists, performs the given action on it, returning true; else returns false. If this Spliterator is ORDERED the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</span><br></pre></td></tr></table></figure>
<p>如果元素存在，就会对元素执行给定的action方法，同时true，否则返回false，如果这个Spliterator是ORDERED，就会对的下一个元素去执行action方法，由这个动作执行产生的任何的异常都会传递给调用者。</p>
<p>接下来是forEachRemaining方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123; &#125; <span class="keyword">while</span> (tryAdvance(action));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Performs the given action for each remaining element, sequentially in the current thread, until all elements have been processed or the action throws an exception. If this Spliterator is ORDERED, actions are performed in encounter order. Exceptions thrown by the action are relayed to the caller.The default implementation repeatedly invokes tryAdvance until it returns false. It should be overridden whenever possible.</span><br></pre></td></tr></table></figure>
<p>对剩下的元素都执行action方法，在当前的线程是以串行的方式执行，知道所有的元素都已经被处理了，或者动作本身抛出了异常，如果Spliterator是ORDERED，action会以遇到元素的顺序去执行，由这个动作抛出的异常会被传递给调用者。默认的实现是不断的调用tryAdvance方法直到返回false，在合适的时候应该被重写。</p>
<p>接下来是trySplit方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If this spliterator can be partitioned, returns a Spliterator covering elements, that will, upon return from this method, not be covered by this Spliterator.</span><br><span class="line">If this Spliterator is ORDERED, the returned Spliterator must cover a strict prefix of the elements.</span><br><span class="line">Unless this Spliterator covers an infinite number of elements, repeated calls to trySplit() must eventually return null. Upon non-null return:</span><br></pre></td></tr></table></figure>
<p>如果这个Spliterator是可以被分割的，就会返回一个新的Spliterator对象，新的Spliterator可能可以进一步分割，剩余的元素是由当前的Spliterator继续涵盖的。</p>
<p>如果这个Spliterator是ORDERED，所返回的Spliterator必须也是ORDERED，除了Spliterator涵盖的是一个无限元素的对象的情况，重复调用trySplit最终得到的结果一定是空，当不为空的情况出现的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the value reported for estimateSize() before splitting, must, after splitting, be greater than or equal to estimateSize() for this and the returned Spliterator; and</span><br></pre></td></tr></table></figure>
<p>1、在分割之前estimateSize方法所估算的元的大小的值，必须在分割之后，一定要大于或者等于当前的和返回的新的Spliterator的estimateSize方法所返回的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if this Spliterator is SUBSIZED, then estimateSize() for this spliterator before splitting must be equal to the sum of estimateSize() for this and the returned Spliterator after splitting.</span><br></pre></td></tr></table></figure>
<p>2、如果Spliterator是SUBSIZED，那么在分割之前Spliterator的estimateSize的值必须等于分割之后所剩下的estimateSize以及剩下的Spliteratord的estimateSize加起来必须相等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This method may return null for any reason, including emptiness, inability to split after traversal has commenced, data structure constraints, and efficiency considerations.</span><br></pre></td></tr></table></figure>
<p>这个方法有可能会返回一个空值，包括原来的就是Spliterator就是空的，在遍历开始之后无法分割，数据结构上的限制，效率上的考量等等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n ideal trySplit method efficiently (without traversal) divides its elements exactly in half, allowing balanced parallel computation. Many departures from this ideal remain highly effective; for example, only approximately splitting an approximately balanced tree, or for a tree in which leaf nodes may contain either one or two elements, failing to further split these nodes. However, large deviations in balance and/or overly inefficient trySplit mechanics typically result in poor parallel performance.</span><br></pre></td></tr></table></figure>
<p>一种理想的trySplit方法在没有进行遍历的情况下，它会恰好就元素分成等量的两部分，这样并行计算的时候工作量是比较平均的。但更多的时候无法达到理想状态，比如说，只是分割一个近似平衡的树，或者对一个树，树中的叶子节点包含了一两个元素，没法再对这些节点进行进一步的分割，对于这种极度不平衡的树，没有效率的trySplit会是的并发执行的效率急剧下降。</p>
<p>接下来是estimateSize方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns an estimate of the number of elements that would be encountered by a forEachRemaining traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute.</span><br></pre></td></tr></table></figure>
<p>返回对于遍历可能会遇到的元中的元素的数量的估算值，如果元的元素是无限的、未知的、或者计算成本非常昂贵的时候，就会返回Long.MAX_VALUE。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If this Spliterator is SIZED and has not yet been partially traversed or split, or this Spliterator is SUBSIZED and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of trySplit.</span><br></pre></td></tr></table></figure>
<p>如果这个Spliterator是SIZED，并且还没有被分割或者迭代，或者Spliterator是SUBSIZED的，但还没有被部分遍历，那么estimate返回的就一定是一个精确的值，就是要被遍历的元素的个数，否则，estimate估算就可能是不精确的，但是必须要随着trySplit方法的调用次数不断减少。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Even an inexact estimate is often useful and inexpensive to compute. For example, a sub-spliterator of an approximately balanced binary tree may return a value that estimates the number of elements to be half of that of its parent; if the root Spliterator does not maintain an accurate count, it could estimate size to be the power of two corresponding to its maximum depth.</span><br></pre></td></tr></table></figure>
<p>estimate方法估算的值通常而言也是有用的，并且计算起来成本也不高，对一个近似平衡的二叉树的sub-spliterator，它会估算父亲节点的元素的一般，如果根Spliterator没有保存正确的计算结果，那么他就会根据树的深度返回2的指数次方，以此来估算元中元素的个数。</p>
<p>接下来是getExactSizeIfKnown方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">long</span> <span class="title">getExactSizeIfKnown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (characteristics() &amp; SIZED) == <span class="number">0</span> ? -<span class="number">1L</span> : estimateSize();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Convenience method that returns estimateSize() if this Spliterator is SIZED, else -1.</span><br></pre></td></tr></table></figure>
<p>如果Spliterator是SIZED就会返回estimateSize的值，否则返回-1。</p>
<p>接下来是characteristics方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result.</span><br></pre></td></tr></table></figure>
<p>返回Spliterator和它的元素特性值的集合，这种结果用ORed值来表示的，共有八个，在trySplit调用之前和调用当中重复地调用这个方法，永远都会返回相同的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator.</span><br></pre></td></tr></table></figure>
<p>如果返回了不同的特性值的集合（分割之前和分割之后有可能特性值会不同），那么对于Spliterator的任何计算都是不受保障。</p>
<p>接下来是hasCharacteristics方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasCharacteristics</span><span class="params">(<span class="keyword">int</span> characteristics)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (characteristics() &amp; characteristics) == characteristics;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns true if this Spliterator&#x27;s characteristics contain all of the given characteristics.</span><br></pre></td></tr></table></figure>
<p>判断当前的Spliterator是否包含传入的characteristics特性值。</p>
<p>接下来是getComparator方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> Comparator&lt;? <span class="keyword">super</span> T&gt; getComparator() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If this Spliterator&#x27;s source is SORTED by a Comparator, returns that Comparator. If the source is SORTED in natural order, returns null. Otherwise, if the source is not SORTED, throws IllegalStateException.</span><br></pre></td></tr></table></figure>
<p>如果这个Spliterator的元通过Comparator是SORTED，那么返回用于排序的比较器，如果元在自然序列下是SORTED，返回null，如果元不是有序的，抛出IllegalStateException异常。</p>
<p>接下来是八个特性值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORDERED    = <span class="number">0x00000010</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISTINCT   = <span class="number">0x00000001</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SORTED     = <span class="number">0x00000004</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZED      = <span class="number">0x00000040</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NONNULL    = <span class="number">0x00000100</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMMUTABLE  = <span class="number">0x00000400</span>;</span><br><span class="line"><span class="comment">// 不能同时返回SIZED和CONCURRENT，如果多个线程访问元，就有可能修改元的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONCURRENT = <span class="number">0x00001000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUBSIZED = <span class="number">0x00004000</span>;</span><br></pre></td></tr></table></figure>
<p>除了以上非常核心的方法，Spliterator中还有两个接口OfPrimitive和OfInt。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OfPrimitive</span>&lt;<span class="title">T</span>, <span class="title">T_CONS</span>, <span class="title">T_SPLITR</span> <span class="keyword">extends</span> <span class="title">Spliterator</span>.<span class="title">OfPrimitive</span>&lt;<span class="title">T</span>, <span class="title">T_CONS</span>, <span class="title">T_SPLITR</span>&gt;&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">T_SPLITR <span class="title">trySplit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;overloads&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(T_CONS action)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;overloads&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(T_CONS action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">do</span> &#123; &#125; <span class="keyword">while</span> (tryAdvance(action));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>相关说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Spliterator specialized for primitive values.</span><br><span class="line">&lt;T&gt; – the type of elements returned by this Spliterator. The type must be a wrapper type for a primitive type, such as Integer for the primitive int type.</span><br><span class="line">&lt;T_CONS&gt; – the type of primitive consumer. The type must be a primitive specialization of Consumer for T, such as IntConsumer for Integer.</span><br><span class="line">&lt;T_SPLITR&gt; – the type of primitive Spliterator. The type must be a primitive specialization of Spliterator for T, such as Spliterator.OfInt for Integer.</span><br></pre></td></tr></table></figure>
<p>这是一个针对原生值设定的Spliterator，T表示由当前的Spliterator所返回的元素的类型，类型必须要是原生类型的包装类型，比如int类型的包装类型Integer。T_CONS是原生的consumer特化的类型，这个类型必须是java.util.function.Consumer原生类型的特化，比如对于Integer的IntConsumer，T_SPLITR是原生的Spliterator分割迭代器的类型，必须是对于T类型的原生类型的特化，比如对于Integer的OfInt。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OfInt</span> <span class="keyword">extends</span> <span class="title">OfPrimitive</span>&lt;<span class="title">Integer</span>, <span class="title">IntConsumer</span>, <span class="title">OfInt</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function">OfInt <span class="title">trySplit</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 重写的OfPrimitive中的tryAdvance方法</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(IntConsumer action)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(IntConsumer action)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">do</span> &#123; &#125; <span class="keyword">while</span> (tryAdvance(action));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 重写的Spliterator中的tryAdvance方法</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Integer&gt; action)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (action <span class="keyword">instanceof</span> IntConsumer) &#123;</span><br><span class="line">               <span class="comment">// IntConsumer和Consumer类型并没有直接继承的关系，这可以强转的原因是如果参数是Integer类型的，由于自动拆箱和自动装箱的原因存在，传递的action如果是Lambda表达式就既满足了Consumer的要求，也满足了IntConsumer的要求，另外是由于Lambda表达式中的类型判断是需要结合具体的上下文的。</span></span><br><span class="line">               <span class="keyword">return</span> tryAdvance((IntConsumer) action);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (Tripwire.ENABLED)</span><br><span class="line">                   Tripwire.trip(getClass(),</span><br><span class="line">                                 <span class="string">&quot;&#123;0&#125; calling Spliterator.OfInt.tryAdvance((IntConsumer) action::accept)&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> tryAdvance((IntConsumer) action::accept);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Integer&gt; action)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (action <span class="keyword">instanceof</span> IntConsumer) &#123;</span><br><span class="line">               forEachRemaining((IntConsumer) action);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (Tripwire.ENABLED)</span><br><span class="line">                   Tripwire.trip(getClass(),</span><br><span class="line">                                 <span class="string">&quot;&#123;0&#125; calling Spliterator.OfInt.forEachRemaining((IntConsumer) action::accept)&quot;</span>);</span><br><span class="line">               forEachRemaining((IntConsumer) action::accept);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>相关说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Spliterator specialized for int values.</span><br></pre></td></tr></table></figure>
<p>针对于int值的分割迭代器。</p>
<p>这其中比较重要的是第二个tryAdvance方法，首先来看方法的说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If the action is an instance of IntConsumer then it is cast to IntConsumer and passed to tryAdvance(IntConsumer); otherwise the action is adapted to an instance of IntConsumer, by boxing the argument of IntConsumer, and then passed to tryAdvance(IntConsumer).</span><br></pre></td></tr></table></figure>
<p>如果action是IntConsumer的一个实例，那么就会被强转为IntConsumer并传递给tryAdvance(IntConsumer)，否则，action会被适配成IntConsumer实例，方式是通过IntConsumer的参数进行装箱操作，然后再传递给tryAdvance(IntConsumer)。</p>
<p>对于上面注释中提到的为什么可以强转，我们通过一个具体的例子来说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Consumer&lt;Integer&gt; consumer)</span> </span>&#123;</span><br><span class="line">        consumer.accept(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConsumerTest consumerTest = <span class="keyword">new</span> ConsumerTest();</span><br><span class="line">        <span class="comment">// 两个相同的Lambda表达式</span></span><br><span class="line">        Consumer&lt;Integer&gt; consumer = i -&gt; System.out.println(i);</span><br><span class="line">        IntConsumer intConsumer = i -&gt; System.out.println(i);</span><br><span class="line">        <span class="comment">// 面向对象的方式</span></span><br><span class="line">        consumerTest.test(consumer);</span><br><span class="line">        <span class="comment">// 编译通过但执行报错</span></span><br><span class="line">        consumerTest.test((Consumer&lt;Integer&gt;) intConsumer);</span><br><span class="line">        <span class="comment">// 传递行为，函数式的方式</span></span><br><span class="line">        consumerTest.test(consumer::accept);</span><br><span class="line">        consumerTest.test(intConsumer::accept);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了OfInt之外还有其他两种OfLong、OfDouble，原理和功能都是类似的。</p>
<h2 id="pipeline源码分析"><a class="markdownIt-Anchor" href="#pipeline源码分析"></a> Pipeline源码分析</h2>
<p>分割迭代器无疑是函数式编程中一个相当核心的概念，其地位与收集器相同，在了解了分割迭代器的相关内容之后，我们再回到一开始的例子当中，看看JDK是如何使用分割迭代器来构造流源的，还是回到最开始的入口这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的spliterator方法是定义Collection接口当中的一个默认方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 这里的this表示的是当前集合的引用，当前集合的引用就是在这个时候被传递进去的</span></span><br><span class="line">       <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Spliterators中静态方法spliterator返回了一个Spliterator实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">(Collection&lt;? extends T&gt; c,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="keyword">int</span> characteristics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IteratorSpliterator&lt;&gt;(Objects.requireNonNull(c),</span><br><span class="line">                                     characteristics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们实际上使用的分割迭代器是IteratorSpliterator，IteratorSpliterator是实现了Spliterator接口的一个实现类，它本身持有了元数据集合的引用。</p>
<p>创建流元的过程是由StreamSupport这个类来完成的，以下是关于StreamSupport这个类的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Low-level utility methods for creating and manipulating streams.</span><br><span class="line">This class is mostly for library writers presenting stream views of data structures; most static stream methods intended for end users are in the various Stream classes.</span><br></pre></td></tr></table></figure>
<p>提供了一些创建和操作流的底层方法。这个类是给类库的编写者提供的，用于呈现流的数据视图，为用户所设计的大多数的静态的流的方法大多都在stream类中提的方法。</p>
<p>StreamSupport中的stream方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(Spliterator&lt;T&gt; spliterator, <span class="keyword">boolean</span> parallel)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(spliterator);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReferencePipeline.Head&lt;&gt;(spliterator,</span><br><span class="line">                                        StreamOpFlag.fromCharacteristics(spliterator),</span><br><span class="line">                                        parallel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creates a new sequential or parallel Stream from a Spliterator.</span><br><span class="line">The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences.</span><br><span class="line">It is strongly recommended the spliterator report a characteristic of IMMUTABLE or CONCURRENT, or be late-binding. Otherwise, stream(Supplier, int, boolean) should be used to reduce the scope of potential interference with the source. See Non-Interference for more details.</span><br></pre></td></tr></table></figure>
<p>从一个分割迭代器对象创建一个串行或者并行的流，spliterator在流管道开启之后仅仅是完成遍历、分割、查询、大小的等功能，强烈建议spliterator返回IMMUTABLE、CONCURRENT或者late-binding这样一些特性，否则，stream应该用于减少潜在的干扰，查看Non-Interference获取更多信息。</p>
<p>这里引出了另外一个及其重要的类ReferencePipeline，用于描述中间的管道阶段和管道源阶段的的类，它与流的操作息息相关，Head是ReferencePipeline的一个静态内部类，描述的是管道的源阶段，二者在大部分属性的设定上都是类似的，但存在一些属性是不同的，比如说Head是没有previousStage的，而ReferencePipeline则是存在previousStage的，等等。接下来就需要重点了解管道流相关的内容。</p>
<p>首先是定义在ReferencePipeline类当中的内部类Head：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span>&lt;<span class="title">E_IN</span>, <span class="title">E_OUT</span>&gt; <span class="keyword">extends</span> <span class="title">ReferencePipeline</span>&lt;<span class="title">E_IN</span>, <span class="title">E_OUT</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">      Head(Supplier&lt;? extends Spliterator&lt;?&gt;&gt; source,</span><br><span class="line">           <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">          <span class="keyword">super</span>(source, sourceFlags, parallel);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 这里Spliterator作为流的源</span></span><br><span class="line">      Head(Spliterator&lt;?&gt; source,</span><br><span class="line">           <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">          <span class="keyword">super</span>(source, sourceFlags, parallel);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">opIsStateful</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> Sink&lt;E_IN&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!isParallel()) &#123;</span><br><span class="line">              sourceStageSpliterator().forEachRemaining(action);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">super</span>.forEach(action);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachOrdered</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!isParallel()) &#123;</span><br><span class="line">              sourceStageSpliterator().forEachRemaining(action);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">super</span>.forEachOrdered(action);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Head类本身有两个泛型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;E_IN&gt; – type of elements in the upstream source</span><br><span class="line">&lt;E_OUT&gt; – type of elements in produced by this stage</span><br></pre></td></tr></table></figure>
<p>E_IN表示上游流源的元素类型，E_OUT表示这个阶段生成的元素类型。</p>
<p>真正在创建的时候又是调用了ReferencePipeline的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferencePipeline(Supplier&lt;? extends Spliterator&lt;?&gt;&gt; source,</span><br><span class="line">                   <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">     <span class="keyword">super</span>(source, sourceFlags, parallel);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>而ReferencePipeline的构造方法又调用了它的父类AbstractPipeline的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractPipeline(Supplier&lt;? extends Spliterator&lt;?&gt;&gt; source,</span><br><span class="line">                  <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">     <span class="keyword">this</span>.previousStage = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">this</span>.sourceSupplier = source;</span><br><span class="line">     <span class="keyword">this</span>.sourceStage = <span class="keyword">this</span>;</span><br><span class="line">     <span class="keyword">this</span>.sourceOrOpFlags = sourceFlags &amp; StreamOpFlag.STREAM_MASK;</span><br><span class="line">     <span class="comment">// The following is an optimization of:</span></span><br><span class="line">     <span class="comment">// StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);</span></span><br><span class="line">     <span class="keyword">this</span>.combinedFlags = (~(sourceOrOpFlags &lt;&lt; <span class="number">1</span>)) &amp; StreamOpFlag.INITIAL_OPS_VALUE;</span><br><span class="line">     <span class="keyword">this</span>.depth = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">this</span>.parallel = parallel;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>AbstractPipeline的说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Abstract base class for &quot;pipeline&quot; classes, which are the core implementations of the Stream interface and its primitive specializations. Manages construction and evaluation of stream pipelines.</span><br></pre></td></tr></table></figure>
<p>AbstractPipeline是对于管道类抽象出来的一个父类，管道类指的是流接口以及其原生特化的核心的实现，它会管理流管道的构建以及计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An AbstractPipeline represents an initial portion of a stream pipeline, encapsulating a stream source and zero or more intermediate operations. The individual AbstractPipeline objects are often referred to as stages, where each stage describes either the stream source or an intermediate operation.</span><br></pre></td></tr></table></figure>
<p>AbstractPipeline代表了流管道初始的阶段，它封装了一个流源和0个或者多个中间操作，每一个单个的AbstractPipeline通常称为stages（阶段），这个阶段要么描述的是流的源，要么描述的是中间操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A concrete intermediate stage is generally built from an AbstractPipeline, a shape-specific pipeline class which extends it (e.g., IntPipeline) which is also abstract, and an operation-specific concrete class which extends that. AbstractPipeline contains most of the mechanics of evaluating the pipeline, and implements methods that will be used by the operation; the shape-specific classes add helper methods for dealing with collection of results into the appropriate shape-specific containers.</span><br></pre></td></tr></table></figure>
<p>一个具体的中间阶段通常是通过AbstractPipeline构建出来的，特化的管道类（IntPipeline、LongPipeline）操作都是类似的，AbstractPipeline包含了大多数计算管道的机制，并且实现了操作的时候要使用的方法，与原生特定相关的类增加了用来处理结果集合添加到特定的特化的管道。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">After chaining a new intermediate operation, or executing a terminal operation, the stream is considered to be consumed, and no more intermediate or terminal operations are permitted on this stream instance.</span><br></pre></td></tr></table></figure>
<p>当链接一个新的中间操作，或者执行一个终止操作，流就会被认为被消费掉了，不会再有中间操作和终止操作添加到这个流实例上了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For sequential streams, and parallel streams without stateful intermediate operations, parallel streams, pipeline evaluation is done in a single pass that &quot;jams&quot; all the operations together. For parallel streams with stateful operations, execution is divided into segments, where each stateful operations marks the end of a segment, and each segment is evaluated separately and the result used as the input to the next segment. In all cases, the source data is not consumed until a terminal operation begins.</span><br></pre></td></tr></table></figure>
<p>对于串行流和中间操作都是无状态的并行流，管道的计算是在单个的过程中完成的（即不是通过链式调用，而是拿出一个元素执行所有的中间操作），对于有状态的并行流，管道的计算就会分成不同的段来执行，其中每一个有状态的都会标识一个段的结尾，每个段都会被单独的执行，而且每个段的执行结果会作为下一个段的输入（表示是有顺序的），直到一个终止操作开始的时候，源数据才会被消费。</p>
<p>接下来是AbstractPipeline类中的一些属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbstractPipeline previousStage;</span><br></pre></td></tr></table></figure>
<p>属性的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The &quot;upstream&quot; pipeline, or null if this is the source stage.</span><br></pre></td></tr></table></figure>
<p>上游的pipline，如果是源阶段的话就是null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbstractPipeline sourceStage;</span><br></pre></td></tr></table></figure>
<p>属性的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Backlink to the head of the pipeline chain (self if this is the source stage).</span><br></pre></td></tr></table></figure>
<p>表示管道反向链接的头（如果是源阶段就是它自身）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> depth;</span><br></pre></td></tr></table></figure>
<p>属性的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The number of intermediate operations between this pipeline object and the stream source if sequential, or the previous stateful if parallel. Valid at the point of pipeline preparation for evaluation.</span><br></pre></td></tr></table></figure>
<p>当前的管道对象和流元的管道对象的中间操作的个数，在流准备进行计算的时候是有效的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> parallel;</span><br></pre></td></tr></table></figure>
<p>属性的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">True if pipeline is parallel, otherwise the pipeline is sequential; only valid for the source stage.</span><br></pre></td></tr></table></figure>
<p>如果是true表示并行，如果是false，表示串行，只有在流源这个阶段才有效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Spliterator&lt;?&gt; sourceSpliterator;</span><br></pre></td></tr></table></figure>
<p>属性的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The source spliterator. Only valid for the head pipeline. Before the pipeline is consumed if non-null then sourceSupplier must be null. After the pipeline is consumed if non-null then is set to null.</span><br></pre></td></tr></table></figure>
<p>是针对于元的分割迭代器，只会head pipeline起作用，在管道被消费之前，如果sourceSpliterator是非空的话，那么sourceSupplier必须是null，管道被消费之后sourceSpliterator就要设置为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Supplier&lt;? extends Spliterator&lt;?&gt;&gt; sourceSupplier;</span><br></pre></td></tr></table></figure>
<p>属性的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The source supplier. Only valid for the head pipeline. Before the pipeline is consumed if non-null then sourceSpliterator must be null. After the pipeline is consumed if non-null then is set to null.</span><br></pre></td></tr></table></figure>
<p>supplier的元，只会head pipeline起作用，在管道被消费之前，如果sourceSupplier是空的，那么sourceSpliterator必须为空，在管道被消费之后，就要将sourceSupplier置为null。</p>
<p>可以看到这两个成员变量可以认为是互斥的，必须要保证其中一个不为空，在流消费之后都要置为空，表示流已经消费完成，至此为止，流源的对象也已经构造完成。</p>
<h2 id="流调用机制与原理"><a class="markdownIt-Anchor" href="#流调用机制与原理"></a> 流调用机制与原理</h2>
<p>回到一开始的例子当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>这里调用的第一个stream方法，使用分割迭代器来构造流源的这一步我们已经完成了，接下来我们来查看一下forEach方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Performs an action for each element of this stream.</span><br><span class="line">This is a terminal operation.</span><br></pre></td></tr></table></figure>
<p>它表示要对于流中每个元素都执行action操作，并且这是一个终止操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does not guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library chooses. If the action accesses shared state, it is responsible for providing the required synchronization.</span><br></pre></td></tr></table></figure>
<p>这个操作的行为是不确定的，对于并行流管道来说，这个操作并不会保证它会遵循流当中元素的顺序，因为如果遵循的话，就会牺牲并行的优势，对于任意给定的元素，这个action可能会在任意的时间或者库所选择的任意线程中去执行，如果库访问了共享的状态，那么它就需要提供完整的同步机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.parallelStream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>这其实指的就是如果使用并行流，那么就无法再保证执行给定的Lambda表达式的元素的顺序了，这个方法实际上在ReferencePipeline中是有两个实现的，一个是在它的静态内部类Head中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对串行流进行优化</span></span><br><span class="line">    <span class="keyword">if</span> (!isParallel()) &#123;</span><br><span class="line">        sourceStageSpliterator().forEachRemaining(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是并行流，调用ReferencePipeline中的forEach方法</span></span><br><span class="line">        <span class="keyword">super</span>.forEach(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是针对于管道源的有过优化的实现，换句话说，如果被流的源调用的话，就是直接进入这个方法，另一个forEach方法是在ReferencePipeline当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> P_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">     evaluate(ForEachOps.makeRef(action, <span class="keyword">false</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当有中间操作的时候，都会进入这个方法，之所以会有这个差异，就是为了效率上的考量，如果有中间操作的话，就需要对于中间操作进行一般化的处理，如果没有的话，就可以直接对流源进行操作。</p>
<p>我们不妨来看一下优化的时候调用的sourceStageSpliterator方法，它是定义在AbstractPipeline当中的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">final</span> Spliterator&lt;E_OUT&gt; <span class="title">sourceStageSpliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> != sourceStage)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"><span class="comment">// 被链接或者被消费，为了保证是在源阶段</span></span><br><span class="line">      <span class="keyword">if</span> (linkedOrConsumed)</span><br><span class="line">          <span class="comment">// MSG_STREAM_LINKED = &quot;stream has already been operated upon or closed&quot;;</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">      linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 流源可能通过两种方式来构建，因此有两种情况，并且这两种情况是互斥的</span></span><br><span class="line">      <span class="keyword">if</span> (sourceStage.sourceSpliterator != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">          Spliterator&lt;E_OUT&gt; s = sourceStage.sourceSpliterator;</span><br><span class="line">          sourceStage.sourceSpliterator = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (sourceStage.sourceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">          Spliterator&lt;E_OUT&gt; s = (Spliterator&lt;E_OUT&gt;) sourceStage.sourceSupplier.get();</span><br><span class="line">          sourceStage.sourceSupplier = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// MSG_CONSUMED = &quot;source already consumed or closed&quot;;</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_CONSUMED);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gets the source stage spliterator if this pipeline stage is the source stage. The pipeline is consumed after this method is called and returns successfully.</span><br></pre></td></tr></table></figure>
<p>如果管道的阶段是源阶段的话，就会返回源阶段的分割迭代器，这个管道在被调用之后，就会返回并且销毁。</p>
<p>我们知道一般情况下分割迭代器返回的是IteratorSpliterator实现，我们来看一下IteratorSpliterator中对于forEachRemaining的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Iterator&lt;? extends T&gt; i;</span><br><span class="line">    <span class="comment">// it是Spliterator中定义的迭代器</span></span><br><span class="line">    <span class="keyword">if</span> ((i = it) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前集合的迭代器</span></span><br><span class="line">        i = it = collection.iterator();</span><br><span class="line">        est = (<span class="keyword">long</span>)collection.size();</span><br><span class="line">    &#125;</span><br><span class="line">    i.forEachRemaining(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将集合中的迭代器找出来并且估算元素的大小，然后再调用Iterator中的新增加的forEachRemaining方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">while</span> (hasNext())</span><br><span class="line">        action.accept(next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里我们就明白了，对于简单的遍历，使用传统的Iterator遍历的效率是要比流的方式效率要高的，当然这是因为我们是没有任何的中间操作，如果有了一系列的中间操作，那么使用流的方式效率还是比传统的方式要高的。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().map(item -&gt; item).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>在ReferencePipeline当中，map方法只有唯一的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="comment">// 返回StatelessOp的匿名内部类对象，this表示ReferencePipeline，第二个参数表示流的类型是引用类型的，第三个是流的特性值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">                <span class="comment">// 真正执行传入Lambda表达式的地方</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    downstream.accept(mapper.apply(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的StatelessOp也是定义在ReferencePipeline当中的一个静态内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessOp</span>&lt;<span class="title">E_IN</span>, <span class="title">E_OUT</span>&gt;</span></span><br><span class="line"><span class="class">           <span class="keyword">extends</span> <span class="title">ReferencePipeline</span>&lt;<span class="title">E_IN</span>, <span class="title">E_OUT</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">       StatelessOp(AbstractPipeline&lt;?, E_IN, ?&gt; upstream,</span><br><span class="line">                   StreamShape inputShape,</span><br><span class="line">                   <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">           <span class="keyword">super</span>(upstream, opFlags);</span><br><span class="line">           <span class="keyword">assert</span> upstream.getOutputShape() == inputShape;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">opIsStateful</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>相关说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Construct a new Stream by appending a stateless intermediate operation to an existing stream.</span><br></pre></td></tr></table></figure>
<p>构造一个针对无状态的中间的阶段的流，这里的构造方法又调用了ReferencePipeline的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferencePipeline(AbstractPipeline&lt;?, P_IN, ?&gt; upstream, <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">    <span class="keyword">super</span>(upstream, opFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructor for appending an intermediate operation onto an existing pipeline.</span><br></pre></td></tr></table></figure>
<p>这个构造方法完成的就是对于已经存在的管道追加一个中间操作，upstream表示上游元素的源。</p>
<p>这里又调用了AbstractPipeline的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">        <span class="keyword">if</span> (previousStage.linkedOrConsumed)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">		<span class="comment">// 标识为已经消费</span></span><br><span class="line">        previousStage.linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line">        previousStage.nextStage = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.previousStage = previousStage;</span><br><span class="line">        <span class="keyword">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</span><br><span class="line">        <span class="keyword">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</span><br><span class="line">        <span class="keyword">this</span>.sourceStage = previousStage.sourceStage;</span><br><span class="line">        <span class="keyword">if</span> (opIsStateful())</span><br><span class="line">            sourceStage.sourceAnyStateful = <span class="keyword">true</span>;</span><br><span class="line">    	<span class="comment">// 深度加1</span></span><br><span class="line">        <span class="keyword">this</span>.depth = previousStage.depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructor for appending an intermediate operation stage onto an existing pipeline.</span><br></pre></td></tr></table></figure>
<p>向一个已有的管道用于追加一个中间操作。</p>
<p>这里也可以看到这个构造方法与我们之前见过的有关构造流源的构造方法的作用完全不同，回到刚才的例子当中，除了上面追加中间操作的部分，还涉及到了另外一个及其重要的类Sink，一般翻译为饮水槽，这是我们了解整个流调用机制的最后一个类。</p>
<h2 id="sink源码分析"><a class="markdownIt-Anchor" href="#sink源码分析"></a> Sink源码分析</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An extension of Consumer used to conduct values through the stages of a stream pipeline, with additional methods to manage size information, control flow, etc. Before calling the accept() method on a Sink for the first time, you must first call the begin() method to inform it that data is coming (optionally informing the sink how much data is coming), and after all data has been sent, you must call the end() method. After calling end(), you should not call accept() without again calling begin(). Sink also offers a mechanism by which the sink can cooperatively signal that it does not wish to receive any more data (the cancellationRequested() method), which a source can poll before sending more data to the Sink.</span><br></pre></td></tr></table></figure>
<p>Sink是Consumer接口的一个扩展，用于在整个流管道阶段处理值，还提供了一些额外的信息，比如管理大小的信息，控制流程，等等。在首次调用Sink的accept之前必须先调用begin方法来通知数据即将到达，同时你也可以通知Sink需要处理的数据量是多少，在所有的数据发送完成之后，必须调用end方法，在调用完end方法，你就不应该再去调用accept方法，如果还想调用，就需要再调用一次begin方法，Sink本身可以通过cancellationRequested方法来发出不要再接收数据的信号，那么源在发送数据之前就可以根据判断是否要向Sink发送数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A sink may be in one of two states: an initial state and an active state. It starts out in the initial state; the begin() method transitions it to the active state, and the end() method transitions it back into the initial state, where it can be re-used. Data-accepting methods (such as accept() are only valid in the active state.</span><br></pre></td></tr></table></figure>
<p>一个Sink一定是处于两种状态之一的，一种是初始状态，另一种是激活状态，首先它是从初始状态开始的，使用begin方法可以将它从初始状态转换成激活状态，使用end方法可以将它从激活状态转换成初始状态，这样调用完之后就可以重用了，对于Sink来说，只有在激活状态下才可以接收数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A stream pipeline consists of a source, zero or more intermediate stages (such as filtering or mapping), and a terminal stage, such as reduction or for-each. For concreteness, consider the pipeline:</span><br></pre></td></tr></table></figure>
<p>一个流管道包含了0个或多个中间阶段（比如过滤、映射），还有一个终止阶段，比如汇聚等等，具体考虑下面这个pipeline：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> longestStringLengthStartingWithA</span><br><span class="line">         = strings.stream()</span><br><span class="line">                  .filter(s -&gt; s.startsWith(<span class="string">&quot;A&quot;</span>))</span><br><span class="line">                  .mapToInt(String::length)</span><br><span class="line">                  .max();</span><br></pre></td></tr></table></figure>
<p>继续往下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Here, we have three stages, filtering, mapping, and reducing. The filtering stage consumes strings and emits a subset of those strings; the mapping stage consumes strings and emits ints; the reduction stage consumes those ints and computes the maximal value.</span><br></pre></td></tr></table></figure>
<p>这里对我们而言有三个阶段，过滤，映射，汇聚，过滤阶段会消耗字符串集合，会输出字符串的子集，映射阶段会消耗字符串集合，映射成整型值，汇聚阶段会消耗这个整型值并求出最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Sink instance is used to represent each stage of this pipeline, whether the stage accepts objects, ints, longs, or doubles. Sink has entry points for accept(Object), accept(int), etc, so that we do not need a specialized interface for each primitive specialization. (It might be called a &quot;kitchen sink&quot; for this omnivorous tendency.) The entry point to the pipeline is the Sink for the filtering stage, which sends some elements &quot;downstream&quot; -- into the Sink for the mapping stage, which in turn sends integral values downstream into the Sink for the reduction stage. The Sink implementations associated with a given stage is expected to know the data type for the next stage, and call the correct accept method on its downstream Sink. Similarly, each stage must implement the correct accept method corresponding to the data type it accepts.</span><br></pre></td></tr></table></figure>
<p>Sink实例是用来表示管道的每一个阶段，而无论这个阶段接收的类型，比如 ints, longs, or doubles，Sink对于accept有一个入口点，这样我们就不需要针对于原生类型的特化版本，上面的例子当中，就是一个过滤阶段，Sink会将值映射成整型值向下游发送，最后进行汇聚操作。</p>
<p>Sink中的方法说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling end(), you may call this method to reset the sink for another calculation.</span><br></pre></td></tr></table></figure>
<p>会重新设置Sink的状态并且刷新数据集，向Sink发送任何数据之前一定要调用这个方法，调用完end方法之后，可以再次调用这个方法来重置Sink来进行其他的计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainedReference</span>&lt;<span class="title">T</span>, <span class="title">E_OUT</span>&gt; <span class="keyword">implements</span> <span class="title">Sink</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     	<span class="comment">// 表示下游的操作</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">final</span> Sink&lt;? <span class="keyword">super</span> E_OUT&gt; downstream;</span><br><span class="line"><span class="comment">// 会保存下游的对象</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">ChainedReference</span><span class="params">(Sink&lt;? <span class="keyword">super</span> E_OUT&gt; downstream)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.downstream = Objects.requireNonNull(downstream);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">          downstream.begin(size);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          downstream.end();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancellationRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> downstream.cancellationRequested();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>类的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Abstract Sink implementation for creating chains of sinks. The begin, end, and cancellationRequested methods are wired to chain to the downstream Sink. This implementation takes a downstream Sink of unknown input shape and produces a Sink&lt;T&gt;. The implementation of the accept() method must call the correct accept() method on the downstream Sink.</span><br></pre></td></tr></table></figure>
<p>它是Sink的一个抽象实现，用于创建Sink的一个链，begin, end, 和cancellationRequested方法都会链接起来，这个实现会接收下游的Sink。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> Sink&lt;E_IN&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;E_OUT&gt; sink)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accepts a Sink which will receive the results of this operation, and return a Sink which accepts elements of the input type of this operation and which performs the operation, passing the results to the provided Sink.</span><br></pre></td></tr></table></figure>
<p>它会接收一个Sink作为当前操作的结果(E_OUT)，并且返回一个Sink，返回的Sink（E_IN）会接收这个操作的所对应的输入元素的类型并且执行这个操作，然后将结果传递给所提供的Sink。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a sink which accepts elements, perform the operation upon each element, and passes the results (if any) to the provided Sink.</span><br></pre></td></tr></table></figure>
<p>返回的Sink会接收一个元素，并且对每个元素进行操作，最后将执行的结果（如果有的话）传递给提供的Sink。</p>
<p>正是因为将执行的结果传递给了方法参数的Sink，才将一系列的Sink有机的串联了起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The implementation may use the flags parameter to optimize the sink wrapping. For example, if the input is already DISTINCT, the implementation for the Stream#distinct() method could just return the sink it was passed.</span><br></pre></td></tr></table></figure>
<p>可以使用flags来优化sink，例如，如果输入一定是不同，那么实现的时候，stream.distinct()方法就可以不用再去执行。</p>
<p>总的来说在进行中间操作的时候，StatelessOp继承了ReferencePipeline，而ReferencePipeline又实现了Stream接口，通过StatelessOp创建饮水槽，将中间操作串联起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">TerminalOp&lt;T, Void&gt; <span class="title">makeRef</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action,                                              <span class="keyword">boolean</span> ordered)</span> </span>&#123;    Objects.requireNonNull(action);    <span class="keyword">return</span> <span class="keyword">new</span> ForEachOp.OfRef&lt;&gt;(action, ordered);&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">actory for creating instances of TerminalOp that perform an action for every element of a stream. Supported variants include unordered traversal (elements are provided to the Consumer as soon as they are available), and ordered traversal (elements are provided to the Consumer in encounter order.)</span><br></pre></td></tr></table></figure>
<p>这是一个工厂，用来创建终止操作的实例，终止操作会对流中的每个元素执行action，支持的变化包括无序的遍历（只要还有元素，就将元素提供给Consumer）还有一种有序的遍历（按照元素输入的顺序提供给Consumer）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Elements are provided to the Consumer on whatever thread and whatever order they become available. For ordered traversals, it is guaranteed that processing an element happens-before processing subsequent elements in the encounter order.</span><br></pre></td></tr></table></figure>
<p>在可用的任意的顺序，任意线程都会将元素提供给Consumer ，对于有序的遍历而言，会保证处理一个元素一定是happens-before（某一件事情一定是发生在另外一件事情之前）处理后续的元素之前，即先遇到的先遍历。</p>
<p>makeRef方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructs a TerminalOp that perform an action for every element of a stream.</span><br></pre></td></tr></table></figure>
<p>构造了一个终止操作，并且对流中的每个元素都执行给定的动作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TerminalOp</span>&lt;<span class="title">E_IN</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 默认是引用类型</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> StreamShape <span class="title">inputShape</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> StreamShape.REFERENCE; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getOpFlags</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并行的方式</span></span><br><span class="line">    <span class="keyword">default</span> &lt;P_IN&gt; <span class="function">R <span class="title">evaluateParallel</span><span class="params">(PipelineHelper&lt;E_IN&gt; helper,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Tripwire.ENABLED)</span><br><span class="line">            Tripwire.trip(getClass(), <span class="string">&quot;&#123;0&#125; triggering TerminalOp.evaluateParallel serial default&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> evaluateSequential(helper, spliterator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 串行的方式</span></span><br><span class="line">    &lt;P_IN&gt; <span class="function">R <span class="title">evaluateSequential</span><span class="params">(PipelineHelper&lt;E_IN&gt; helper,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Spliterator&lt;P_IN&gt; spliterator)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An operation in a stream pipeline that takes a stream as input and produces a result or side-effect. A TerminalOp has an input type and stream shape, and a result type. A TerminalOp also has a set of operation flags that describes how the operation processes elements of the stream (such as short-circuiting or respecting encounter order; see StreamOpFlag).</span><br></pre></td></tr></table></figure>
<p>这是流管道中的一个操作，它会接收一个流作为输入，生成一个结果或者拥有副作用（修改传入参数的引用），一个终止操作会拥有一个输入类型和一个流的类型（引用、整型、长整型等）和一个结果类型，一个终止操作描述了描述了流是如何处理流中元素的（比如短路、有序的执行）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A TerminalOp must provide a sequential and parallel implementation of the operation relative to a given stream source and set of intermediate operations.</span><br></pre></td></tr></table></figure>
<p>终止操作对于给定的流源和中间操作一定要提供并行和串行的实现。</p>
<p>实际上，终止操作的数量并不是特别多。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A TerminalOp that evaluates a stream pipeline and sends the output to itself as a TerminalSink. Elements will be sent in whatever thread they become available. If the traversal is unordered, they will be sent independent of the stream&#x27;s encounter order.</span><br></pre></td></tr></table></figure>
<p>这是一个终止操作，它会计算一个流福安到并且将结果发送给自身作为一个TerminalSink，元素如果可用的话会发送给任意一个线程，如果遍历是无序的，那么在遍历的时候就会独立于流中输入的顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This terminal operation is stateless. For parallel evaluation, each leaf instance of a ForEachTask will send elements to the same TerminalSink reference that is an instance of this class.</span><br></pre></td></tr></table></figure>
<p>这个终止操作是无状态的，对于并行计算，每一个叶子节点都会发送个这个类的同一个TerminalSink实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Evaluate the pipeline with a terminal operation to produce a result.</span><br></pre></td></tr></table></figure>
<p>执行一个终止的操作，并且返回一个结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;R&gt; <span class="function">R <span class="title">evaluate</span><span class="params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">getOutputShape</span><span class="params">()</span> </span>== terminalOp.inputShape();</span><br><span class="line">    <span class="keyword">if</span> (linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isParallel()</span><br><span class="line">           ? terminalOp.evaluateParallel(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()))</span><br><span class="line">           : terminalOp.evaluateSequential(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>串行的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;S&gt; <span class="function">Void <span class="title">evaluateSequential</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Spliterator&lt;S&gt; spliterator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> helper.wrapAndCopyInto(<span class="keyword">this</span>, spliterator).get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Helper class for executing stream pipelines, capturing all of the information about a stream pipeline (output shape, intermediate operations, stream flags, parallelism, etc) in one place.</span><br></pre></td></tr></table></figure>
<p>这是一个执行流管道的辅助类，它会在一个地方捕获关于流管道的所有信息（输出种类，中间操作，特性值，并行或者串行）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A PipelineHelper describes the initial segment of a stream pipeline, including its source, intermediate operations, and may additionally incorporate information about the terminal (or stateful) operation which follows the last intermediate operation described by this PipelineHelper. The PipelineHelper is passed to the TerminalOp.</span><br><span class="line">evaluateParallel(PipelineHelper, Spliterator), TerminalOp.evaluateSequential(PipelineHelper, Spliterator), and AbstractPipeline.opEvaluateParallel(PipelineHelper, Spliterator, IntFunction), methods, which can use the PipelineHelper to access information about the pipeline such as head shape, stream flags, and size, and use the helper methods such as wrapAndCopyInto(Sink, Spliterator), copyInto(Sink, Spliterator), and wrapSink(Sink) to execute pipeline operations.</span><br></pre></td></tr></table></figure>
<p>PipelineHelper描述了一个流管道最开始的阶段，包括它的源，中间操作，以及一些附加的信息关于终止的有状态的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPipeline</span>&lt;<span class="title">E_IN</span>, <span class="title">E_OUT</span>, <span class="title">S</span> <span class="keyword">extends</span> <span class="title">BaseStream</span>&lt;<span class="title">E_OUT</span>, <span class="title">S</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">PipelineHelper</span>&lt;<span class="title">E_OUT</span>&gt; <span class="keyword">implements</span> <span class="title">BaseStream</span>&lt;<span class="title">E_OUT</span>, <span class="title">S</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> &lt;S&gt; <span class="function">Void <span class="title">evaluateParallel</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       Spliterator&lt;S&gt; spliterator)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (ordered)</span><br><span class="line">              <span class="keyword">new</span> ForEachOrderedTask&lt;&gt;(helper, spliterator, <span class="keyword">this</span>).invoke();</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">new</span> ForEachTask&lt;&gt;(helper, spliterator, helper.wrapSink(<span class="keyword">this</span>)).invoke();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span>&lt;P_IN, S extends Sink&lt;P_OUT&gt;&gt; <span class="function">S <span class="title">wrapAndCopyInto</span><span class="params">(S sink, Spliterator&lt;P_IN&gt; spliterator)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Applies the pipeline stages described by this PipelineHelper to the provided Spliterator and send the results to the provided Sink.</span><br></pre></td></tr></table></figure>
<p>将PipelineHelper所描述的管道阶段应用到所提供的Spliterator同时把结果发送给提供的Sink。</p>
<p>这个方法在AbstractPipeline中有唯一的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN, S extends Sink&lt;E_OUT&gt;&gt; <span class="function">S <span class="title">wrapAndCopyInto</span><span class="params">(S sink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);</span><br><span class="line">    <span class="keyword">return</span> sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的wrapSink方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span>&lt;P_IN&gt; Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;P_OUT&gt; sink)</span></span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Takes a Sink that accepts elements of the output type of the PipelineHelper, and wrap it with a Sink that accepts elements of the input type and implements all the intermediate operations described by this PipelineHelper, delivering the result into the provided Sink.</span><br></pre></td></tr></table></figure>
<p>它会接收PipelineHelper输出类型的元素，使用Sink对于接收到的所有的元素进行包装成由PipelineHelper所描述的中间操作，并且将结果传递给提供的Sink。</p>
<p>这个方法就是对流中的中间操作进行串联的方法，具体的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(sink);</span><br><span class="line"><span class="comment">// 深度大于0说明有中间操作。</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">          <span class="comment">// opWrapSink是map等方法中实现的</span></span><br><span class="line">          sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span>&lt;P_IN&gt; <span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span></span>;</span><br></pre></td></tr></table></figure>
<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pushes elements obtained from the Spliterator into the provided Sink. If the stream pipeline is known to have short-circuiting stages in it (see StreamOpFlag.SHORT_CIRCUIT), the Sink.cancellationRequested() is checked after each element, stopping if cancellation is requested.</span><br></pre></td></tr></table></figure>
<p>将从Spliterator获取到元素推送到Sink当中，如果这个流管道已经知道了拥有短路的阶段，就会进入短路逻辑的判断，方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(wrappedSink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">        wrappedSink.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TerminalSink是Sink最终的形态。</p>
<h2 id="stream调用流程"><a class="markdownIt-Anchor" href="#stream调用流程"></a> Stream调用流程</h2>
<p>BaseStream-&gt;Stream-&gt;AbstractPipline-&gt;ReferencePipline-&gt;(Head（流源）、StatelessOp（无状态的中间操作）、StatefulOp（有状态的中间操作））</p>
<p>Terminalop-&gt;(FindOp、ForeachOp、MatchOp、ReduceOp)</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
</search>
