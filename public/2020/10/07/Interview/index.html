<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jycoder.club","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="&#x3D;&#x3D;面试&#x3D;&#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题精选">
<meta property="og:url" content="https://jycoder.club/2020/10/07/Interview/index.html">
<meta property="og:site_name" content="吉永超">
<meta property="og:description" content="&#x3D;&#x3D;面试&#x3D;&#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/assets/1602514407754.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/assets/1602518952457.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/assets/20180209005040443.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623338377030.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623338441636.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623338572945.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623338605138.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623338629356.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623338646312.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623338667701.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340505687.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340525614.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340553847.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340629869.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340652710.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340685282.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340722723.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340748278.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340766008.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340788395.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623338875139.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/assets/1623338892939.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623338951040.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340880885.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340901903.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623339151379.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623339191238.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623339510473.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623339540507.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623339588730.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623339719343.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623339952421.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623339978966.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340013484.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340159941.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340322241.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340341140.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340368298.png">
<meta property="og:image" content="https://jycoder.club/2020/10/07/Interview/Interview.assets/1623340385478.png">
<meta property="article:published_time" content="2020-10-06T16:00:00.000Z">
<meta property="article:modified_time" content="2021-06-24T07:05:30.588Z">
<meta property="article:author" content="吉永超">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jycoder.club/2020/10/07/Interview/assets/1602514407754.png">

<link rel="canonical" href="https://jycoder.club/2020/10/07/Interview/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面试题精选 | 吉永超</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">吉永超</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/jiyongchao-qf" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jycoder.club/2020/10/07/Interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吉永超">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吉永超">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试题精选
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-10-07T00:00:00+08:00">2020-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-24 15:05:30" itemprop="dateModified" datetime="2021-06-24T15:05:30+08:00">2021-06-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>29k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>==面试==</p>
<span id="more"></span>
<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>Java 语⾔有哪些特点?</p>
<ul>
<li>简单易学</li>
<li>面向对象（封装、继承、多态）</li>
<li>跨平台</li>
<li>可靠性</li>
<li>安全性</li>
<li>支持多线程（C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程设计，Java提供了多线程支持）</li>
<li>支持网络编程</li>
<li>编译与解释并存</li>
</ul>
</li>
<li><p>JVM、JDK 和 JRE 联系与区别？</p>
<p> JVM（Java虚拟机）是运行Java字节码的虚拟机，JVM针对于不同的操作系统有不同的实现（Windows,Linux,Mac os），在不同的操作系统上使用相同的字节码文件可以得到相同的结果。</p>
<p> Java程序从源代码到运行一般经历下面3个步骤：</p>
<p> <img src="./assets/1602514407754.png" alt="1602514407754"></p>
<p> JDK（Java Development Kit）是功能齐全的Java SDK，它不止有JRE，还有编译器（Javac）和工具（例如Java doc 和Jdb），它可以创建和编译程序。</p>
<p> JRE是Java运行时环境，它是运行已经编译的Java程序所需的内容的集合，包括Java虚拟机、Java类库、Java命令和其他的一些基础构件，但是，它不能用来创建新的程序。</p>
</li>
<li><p>Java 和 C++的区别?</p>
<ul>
<li>都是面向对象的语言，都具有继承、封装、多态的特性</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，但接口可以多继承，C++支持多重继承</li>
<li>Java有自动内存管理机制，C++需要手动释放无用的内存</li>
</ul>
</li>
<li><p>构造器 Constructor 是否可被 override?</p>
<p> 构造器无法被重写，但可以重载。</p>
</li>
<li><p>重载和重写的区别</p>
<p> 重载发生在同一个类中，方法名必须相同，参数类型、个数、顺序不同，方法返回值和修饰值可以不同。下面是《Java核心技术》对于重载的介绍：</p>
<p> <img src="./assets/1602518952457.png" alt="1602518952457"></p>
</li>
<li><p>Java ⾯向对象编程三⼤特性: 封装 继承 多态</p>
<ul>
<li>封装</li>
</ul>
<p> 封装是把一个对象的属性私有化，根据需要提供一些可以被外界访问属性的方法。</p>
<ul>
<li>继承</li>
</ul>
<p> 继承是使用已经存在的类的定义作为基础建立新的类，新类的定义可以增加新的数据或功能，也可以使用父类的功能，子类拥有父类所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，子类可以拥有自己的属性和方法，即子类可以对父类进行扩展，子类也可以重写父类的方法。</p>
<ul>
<li>多态</li>
</ul>
<p> 多态是值程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须是在程序运行期间才能决定。</p>
</li>
<li><p>String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</p>
<ul>
<li>String：不可变字符序列</li>
<li>StringBuffer：可变字符序列，效率低，线程安全</li>
<li>StringBuilder：可变字符序列，效率高，线程不安全</li>
</ul>
</li>
<li><p>深拷贝和浅拷贝的区别？</p>
<p> 浅拷贝：对于基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝；</p>
<p> 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p>
</li>
<li><p>接口和抽象类的区别</p>
<ul>
<li><p>接口的方法默认都是public，所有的方法在接口中不能有实现；</p>
</li>
<li><p>接口中除了static、final变量，不能有其他变量，而抽象类中则不一定；</p>
</li>
<li><p>一个类可以实现多个接口，但只能实现一个抽象类。但接口本身可以多继承。</p>
</li>
<li><p>接口方法的默认修饰符是public，抽象类的方法的修复可以是public、protected和default这些修饰符（不能是private）；</p>
</li>
<li><p>从设计的层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</p>
<p>  以上对JDK8之前的定义和规范，从JDK8开始接口的概念有了一些变化：</p>
</li>
</ul>
<p> 在JDK7或更早的版本中，接口里面只能由常量、变量和抽象方法，实现接口类必须重写接口中的抽象方法，JDK8接口中增加了默认方法和静态方法，JDK9接口中增加了私有方法和私有静态方法。</p>
</li>
<li><p>构造方法有哪些特性？</p>
<ul>
<li><p>名称与类名相同</p>
</li>
<li><p>没有返回值，但不能用void声明构造方法</p>
</li>
<li><p>生成类的对象时自动执行，无需调用</p>
</li>
<li><p>默认有一个不带参数的构造方法</p>
</li>
<li><p>如果显式的指定了带参的构造方法，默认不再提供无参的构造方法</p>
<p>  <img src="./assets/20180209005040443.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>⾃动装箱与拆箱</p>
<p>装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p>
<p>在JDK5之前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>JDK5之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>基本数据类型对应的包装类型：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td>int(4字节)</td>
<td>Integer</td>
</tr>
<tr>
<td>byte(1字节)</td>
<td>Byte</td>
</tr>
<tr>
<td>short(2字节)</td>
<td>Short</td>
</tr>
<tr>
<td>long(8字节)</td>
<td>Long</td>
</tr>
<tr>
<td>float（4字节）</td>
<td>Float</td>
</tr>
<tr>
<td>double（8字节）</td>
<td>Double</td>
</tr>
<tr>
<td>char（2字节）</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ol>
<li><p>List、Set、Map三者的区别？</p>
<p> List用来存储一组不唯一（可以重复），有序的对象；</p>
<p> Set用来存储不允许重复的集合，不会有多个元素引用相同集合的对象；</p>
<p> Map是用来存储键值对的，Map会维护与Key有关联的值，两个不同的Key可以引用相同的对象，Key不能重复。</p>
</li>
</ol>
<h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><ol>
<li><p>Java如何开启线程？怎么保证线程安全？</p>
<p>  这里首先得明确一下线程和进程的区别，进程是操作系统进行资源分配的最小单位，线程是操作系统任务分配的最小单位，线程隶属于进程。</p>
<p>  开启线程的具体方式：</p>
<pre><code>1. 继承Thread类，重写run方法
2. 实现Runnable接口，实现run方法
3. 实现Callable接口，实现call方法，通过FutureTask创建一个线程，获取到线程执行的返回值
4. 通过线程池来开启线程
</code></pre>
<p> 那么如何保证线程安全呢？</p>
<p>采用加锁的方式：使用JVM提供的Synchronized关键字或者JDK提供的各种锁Lock。</p>
</li>
<li><p>volatile和Synchronized有什么区别？</p>
<p>Synchronized关键是用来加锁，volatile只是保持变量的线程可见性，通常适用于一个线程写，多个线程读的场景。</p>
</li>
<li><p>volatile能不能保证线程安全？</p>
<p>不能。volatile关键字只能保证线程可见性，不能保证原子性，相关的示例：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private static boolean flag = true;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>DCL(Double Check Lock)单例为什么加volatile？</p>
<p>volatile防止指令重排，在DCL中，防止高并发情况，指令重排造成的线程安全问题，相关示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> SingleDemo singleDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"><span class="comment">//        if (null == this.singleDemo) &#123;</span></span><br><span class="line"><span class="comment">//            synchronized (SingleDemo.class) &#123;</span></span><br><span class="line"><span class="comment">//                if (null == this.singleDemo) &#123;</span></span><br><span class="line"><span class="comment">//                    singleDemo = new SingleDemo();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        singleDemo = <span class="keyword">new</span> SingleDemo();</span><br><span class="line">        <span class="keyword">return</span> singleDemo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>Java线程锁机制是怎样的？偏向锁、轻量级锁、重量级锁有什么区别？锁机制是如何升级的？<ol start="2">
<li>Java的锁就是在对象的MarkWord中记录一个锁状态、无锁、偏向锁、轻量级锁、重量级锁对应不同锁状态<ol start="3">
<li>Java的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>  偏向锁、轻量级锁、重量级锁及锁机制具体如下图：</p>
<p>  <img src="./Interview.assets/1623338377030.png" alt="1623338377030"></p>
<ol start="6">
<li>谈谈你对AQS的理解，AQS如何实现可重入锁？</li>
</ol>
<p>  AQS是一个Java线程同步的框架，是JDK中很多锁工具的核心实现框架，在AQS中，维护了一个信号量state和一个线程组成的双向链表队列。其中，这个线程队列，  其中这个线程队列，就是用来给线程排队的，而state就像是一个红绿灯，用来控制线程排队或者放行的，在不同的场景下，有不用的意义。</p>
<p>  在可重入锁这个场景下，state就用来表示枷锁的次数，0标识加锁的次数，每加一次锁，state就加1，释放锁state就减1。</p>
<p>  <img src="./Interview.assets/1623338441636.png" alt="1623338441636"></p>
<ol start="7">
<li>有A、B、C三个线程，如何保证三个线程同时执行？如何在并发情况下保证三个线程依次执行？如何保证三个线程有序交错进行？</li>
</ol>
<p>  可以使用三大工具：CountDownLatch，CylicBarrier，Semaphore</p>
<ul>
<li>保证三个线程同时执行的示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">        ThreadSafeDemo threadSafeDemo = <span class="keyword">new</span> ThreadSafeDemo();</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                    System.out.println(System.currentTimeMillis());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>保证三个线程依次执行的示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderThread2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> ticket = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;a&quot;</span> + i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ticket = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;b&quot;</span> + i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ticket = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket == <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;c&quot;</span> + i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>保证三个线程有序交错进行的示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderThread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用信号量来限制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s2 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s3 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s1.acquire();</span><br><span class="line">            s2.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s1.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                s2.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s2.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                s3.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s3.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">                s1.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>如何对一个字符串快速进行排序？</li>
</ol>
<p>  可以使用Fork/Join框架来完成，相关示例：</p>
<h2 id="Java网络通信"><a href="#Java网络通信" class="headerlink" title="Java网络通信"></a>Java网络通信</h2><ol>
<li><p>TCP和UDP有什么区别？</p>
<p> TCP（Transfer Control Protocol）是一种面向连接的、可靠的、传输层通讯协议。</p>
<p> TCP的特点：类似打电话，面向连接的、点对点的通信、高可靠的，效率比较低，占用的系统资源比较多。</p>
<p> UDP（User Datagram Protocol）是一种无连接的、不可靠的、传输层的通讯协议。</p>
<p> UDP的特点：类似广播，不需要连接，发送方不管接受方有没有准备好，直接发消息，可以进行广播发送的，传输不可靠，有可能丢失消息，效率比较高，协议比较简单，占用的系统资源比较少。</p>
</li>
<li><p>TCP为什么是三次握手，而不是两次？</p>
</li>
</ol>
<p>  TCP建立连接三次握手，断开连接四次挥手。 如果是两次握手，可能会造成连接资源浪费的情况，server端会建立通道一直等待连接，但是client端会认为连接失败，放弃本次通信。</p>
<p>  <img src="./Interview.assets/1623338572945.png" alt="1623338572945"></p>
<ol start="3">
<li>Java有哪几种IO模型？有什么区别？</li>
</ol>
<p>  有BIO 同步阻塞IO、NIO 同步非阻塞IO、AIO异步非阻塞IO模型。</p>
<p>  这里的同步、异步针对请求，阻塞和非阻塞针对客户端。</p>
<p>  在一个网络请求中，客户端会发一个请求到服务端：</p>
<ul>
<li><p>客户端发了请求后，就一直等着服务端响应，客户端：阻塞。请求：同步</p>
</li>
<li><p>客户端发了请求后，就去干别的事情了，是不是的过来检查服务端是否给出了响应，客户端：非阻塞，请求：同步</p>
</li>
<li><p>换成异步请求，客户端发了请求后，就坐在椅子上，等着服务端返回响应。客户端：阻塞，请求：异步。 </p>
</li>
<li><p>客户端发了请求后，就去干别的事情了，等到服务端给出响应后，再来处理业务逻辑。客户端：非阻塞。请求：异步</p>
</li>
</ul>
<p>  具体区别如下：</p>
<p>  BIO模式：可靠性差，吞吐量低，适用于连接比较少且比较固定的场景，JDK1.4之前唯一的选择。编程模型最简单。</p>
<p>  <img src="./Interview.assets/1623338605138.png" alt="1623338605138"></p>
<p>  NIO模型：可靠性比较好，吞吐量比较高，适用于连接多，并且连接比较短（轻操作），例如聊天室，JDK1.4开始支持，变成模型最复杂。</p>
<p>  <img src="./Interview.assets/1623338629356.png" alt="1623338629356"></p>
<p>  AIO模型：可靠性是最好的，吞吐量也是最高的，适用于连接比较多，并且连接比较长（重操作），例如相册服务器，JDK7开始支持的，变成模型相对简单，但是需要操作系统支持。</p>
<p>  <img src="./Interview.assets/1623338646312.png" alt="1623338646312"></p>
<ol start="4">
<li>Java NIO的几个核心组件是什么？分别有什么作用？</li>
</ol>
<p>  Java NIO的几个核心组件有：Channel、Buffer、Selector</p>
<p>  <img src="./Interview.assets/1623338667701.png" alt="1623338667701"></p>
<p>  Channel类似于流，每个Channel对应一个Buffer缓冲区，Channel会注册到Selector，Selector会根据Channel上发生的读写时间，将请求交由某个空闲的线程处理，Selector对应一个或者多个线程。Buffer和Channel都是可读可写的。</p>
<ol start="5">
<li>select、poll、epoll有什么区别？</li>
</ol>
<p>  他们是NIO中多路复用的三种实现机制，是由linux操作系统提供的。</p>
<p>  用户空间和内核空间：操作系统为了保护系统安全，将内核划分为两个部分，一个是用户空间，一个是内核空间。用户空间不能直接访问底层的硬件设备，必须通过内核空间。</p>
<p>  文件描述符 File Descriptor（FD）：是一个抽象的概念，形式上是一个整数，实际上是一个索引值。指向内核中为每个进程维护进程所打开的文件的记录表。当程序打开一个文件或者创建一个文件时，内核就会向进程返回一个FD，Unix、Linux。</p>
<ul>
<li>select机制：会维护一个FD的结合fd_set。将fd_set从用户空间复制到内核空间，激活socket。</li>
</ul>
<ul>
<li>poll机制：和select机制差不多的。把fd_set结构进行了优化，FD集合的大小就突破了操作系统的限制，poll fd结构来代替fd_set，通过链表实现</li>
</ul>
<ul>
<li>epoll(Event poll)：epoll中不再扫描所有的FD，而是只将用户关心的FD的事件存放到内核的一个事件表当中。这样就可以减少用户空间与内核空间之前需要拷贝的数据。 </li>
</ul>
<p>  总结如下表：</p>
<table>
<thead>
<tr>
<th></th>
<th>操作方式</th>
<th>底层实现</th>
<th>最大连接数</th>
<th>IO效率</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>遍历</td>
<td>数组</td>
<td>受限于内核</td>
<td>一般</td>
</tr>
<tr>
<td>poll</td>
<td>遍历</td>
<td>链表</td>
<td>无上限</td>
<td>一般</td>
</tr>
<tr>
<td>epoll</td>
<td>事件回调</td>
<td>红黑树</td>
<td>无上限</td>
<td>高</td>
</tr>
</tbody></table>
<p>  那Java的NIO当中时使用的哪种机制呢？</p>
<p>  与操作系统有关，在windows下，WindowsSelectorProvider。而linux下，根据linux的内核版本，2.6内核版本以上，就是EpollSelectorProvider，默认使用的是PollSelectorProvider</p>
<ol start="6">
<li>描述下HTTP和HTTPS的区别？</li>
</ol>
<p>  HTTP：是互联网上应用最为广泛的一种网络通信协议，基于TCP协议，可以使用浏览器工作更为高效，减少网络传输。</p>
<p>  HTTPS：是HTTP的加强版，可以认为是HTTP + SSL（Secure Socket Layer）。在HTTP的基础上增加了一系列的安全机制，一方面保证数据传输安全，另一方面对访问者增加了验证机制。是目前现行架构下，最为安全的解决方案。</p>
<p>  主要区别：</p>
<ol>
<li>HTTP的连接时简单无状态的，HTTPS的数据传输时经过证书加密的，安全性更高。</li>
<li>HTTP是免费的，而HTTPS需要申请证书，而证书通常是收费的，并且费用一般不低。</li>
<li>他们的传输协议不同，所以他们使用的端口也是不一样的，HTTP默认端口是80，而HTTPS默认是443端口</li>
</ol>
<p>  HTTPS的缺点：</p>
<ol>
<li>HTTPS的握手协议比较费时，所以会影响服务的响应速度以及吞吐量。</li>
<li>HTTPS也并不是完全安全的，他的证书体系并不是完全安全的。  并且HTTPS在面对DDOS这样的攻击时，几乎起不到任何作用。</li>
<li>证书不免费，并且功能越强大的证书费用越高。</li>
</ol>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol>
<li><p>JVM内存模型</p>
<p> <img src="./Interview.assets/1623340505687.png" alt="1623340505687"></p>
<p> <img src="./Interview.assets/1623340525614.png" alt="1623340525614"></p>
</li>
<li><p>Java类加载的全过程是怎么样的？什么是双亲委派机制？有什么作用？一个对象从加载到JVM，再到GC清楚，都经历了什么过程？</p>
<p> Java的类加载器：AppClassLoader -&gt; ExtClassLoader -&gt; BootStrapClassLoader</p>
<p> 每一种类加载器都有自己的加载目录，</p>
<p> Java中的AppClassLoader、ExtClassLoader 都继承了URLClassLoader，URLClassLoader继承了SecureClassLoader，SecureClassLoader又继承了ClassLoader</p>
<p> 每个类加载器对他加载过的类，都是有一个缓存的</p>
<p> <img src="./Interview.assets/1623340553847.png" alt="1623340553847"></p>
<p> 双亲委派：向上委托查找，向下委托，作用：保护Java的层的类不会被应用程序覆盖</p>
<p> 核心代码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 类加载过程：加载 -&gt; 连接 -&gt; 初始化</p>
<ol>
<li>加载：把Java的字节码数据加载到JVM内存当中，并映射成JVM认可的数据结构</li>
<li>连接：分为三个小的阶段：1、验证：检查加载到的字节码信息是否符合JVM规范 2、准备：创建类或接口的静态变量，并赋初始值，半初始化状态 3、把符号引用转为直接引用</li>
<li>初始化：创建对象</li>
</ol>
<p>  详细步骤说明：</p>
<ol>
<li>用户创建一个对象，JVM首先需要到方法区去找对象的类型信息，然后再创建对象。</li>
<li>JVM要实例化一个对象，首先要在堆中先创建一个对象 -&gt; 半初始化状态</li>
<li>对象首先会分配在堆内存中新生代的Eden区，然后经过一次Minor GC，对象如果存活，就会进入S区，在后续的每次GC中，如果对象一直存活，就会在S区来回拷贝，每移动一次，年龄加1，年龄最大值是15，默认就是最大年龄是15。超过年龄先之后，对象转入老年代。</li>
<li>当方法执行结束后，栈中的指针会先移除掉。</li>
<li>堆中的对象，经过Full GC就会被标记为垃圾，然后被GC线程清理掉。</li>
</ol>
</li>
<li><p>怎么样确定一个对象不是垃圾？什么是GC Root？</p>
<p> 有两种定位垃圾的方式：</p>
<ol>
<li>引用计数法：这种方式是给堆内存当中的每个对象记录一个引用个数，引用个数为0的就认为是垃圾。这是早期JDK采用的方式，引用计数无法解决循环引用的问题</li>
<li>根可达算法：这种方式是在内存中，从引用根对象向下一直找引用，找不到的对象就是垃圾。</li>
</ol>
</li>
</ol>
<p>哪些是GC root？stack -&gt; JVM stack Native 、class类。run-time constant pool 常量池、static reference静态变量。</p>
<ol start="4">
<li><p>JVM有哪些垃圾回收算法？</p>
<p> MarkSweep 标记清除算法</p>
<p> <img src="./Interview.assets/1623340629869.png" alt="1623340629869"></p>
<p> 这个算法分为两个阶段，标记阶段：把垃圾内存表及出来，清楚阶段：直接将垃圾内存回收。存在为题：会产生大量的内存碎片。</p>
<p> Copying 拷贝算法</p>
<p> 为了解决标记清除算法的内存碎片问题，就产生了拷贝算法。</p>
<p> <img src="./Interview.assets/1623340652710.png" alt="1623340652710"></p>
<p> 拷贝算法将内存分为大小相等的两半，每次只使用其中的一半，垃圾回收时，将当前这一块的存活对象全部拷贝到另一半，然后当前这一半内存就可以直接清楚。</p>
<p> 这种算法没有内存碎片，但是浪费了内存的空间，并且效率与存活的对象个数有关。</p>
<p> MarkCompack 标记压缩算法</p>
<p> <img src="./Interview.assets/1623340685282.png" alt="1623340685282"></p>
<p> 这种算法在标记阶段跟标记清除算法是一样的，但是在完成标记之后，不是直接清理垃圾内存，而是将存活对象往一端移动，然后将端边界以外的所有内存直接清除。</p>
<p> 这三个算法各有利弊，各自有各自的适合场景。</p>
</li>
<li><p>JVM有哪些垃圾回收器？他们都是怎么工作的？什么是STW？他都发生在哪些阶段？什么是三色标记？</p>
<p> STW：stop the world，是在垃圾晖收算法执行过程当中，需要将JVM内存冻结的一种状态，在STW状态下，Java所有的线程都是停止执行的，GC线程除外，只有native方法可以执行，但是，不能与JVM交互，GC各种算法优化的重点，就是减少STW，同时这也是JVM调优的重点。</p>
<p> <img src="./Interview.assets/1623340722723.png" alt="1623340722723"></p>
<p> Serial 串行</p>
<p> <img src="./Interview.assets/1623340748278.png" alt="1623340748278"></p>
<p> 整体过程比较简单，需要GC时，直接暂停，GC完了再继续，这个垃圾收集器，时早期垃圾回收器，只有一个线程执行GC操作，在多CPU架构下，性能就会下降严重，只适用于几十兆的内存空间。</p>
<p>  parallel并行</p>
<p> <img src="./Interview.assets/1623340766008.png" alt="1623340766008"></p>
<p> 在串行基础上，增加多线程GC，PS + PO这种组合是JDK1.8默认的垃圾收集器，在多CPU架构下，性能会比Serial高很多。</p>
<p> CMS</p>
<p> 核心思想：就是将STW打散。让一部分GC线程与用户线程并发执行。</p>
<p> <img src="./Interview.assets/1623340788395.png" alt="1623340788395"></p>
<p> 整个GC过程分为四个阶段：</p>
<p> 1、初始标记阶段：STW 只标记出根对象直接引用的对象</p>
<p> 2、并发标记：继续标记其他对象，与应用程序时并发执行</p>
<p> 3、重新标记：STW对并发执行阶段的对象进行重新标记</p>
<p> 4、并发清楚：并行。将产生的垃圾清除。清除过程中，应用程序又会不断的产生新的垃圾，叫做浮动垃圾。这些垃圾就要留到下一次GC过程中清除。</p>
<p> G1 垃圾优先</p>
<p> 他的内存模型是实际不分代，但是逻辑上是分代的，对于堆内内存就不再区分老年代和新生代，而划分成一个一个的小内存块，叫做Region，每个Region可以隶属于不同的年代</p>
<p> 第一：初始标记，标记出GC　ROOT直接引用的对象，STW</p>
<p> 第二：标记Region，通过Rset标记出上一个阶段标记的Region引用到的OLD区Region</p>
<p> 第三：并发标记阶段：跟CMS的步骤是差不多的，只是遍历的范围不再是整个OLD区，而只需要遍历第二步标记出来的Region</p>
<p> 第四：重新标记，跟CMS中的重新标记过程是差不多的</p>
<p> 第五：垃圾清理：与CMS不同的是，G１可以采用拷贝算法，直接将整个Region中的对象拷贝到另一个Region，而这个阶段，G１只选择垃圾较多的Region来清理。并不是完全清理，</p>
<p> CMS的核心算法就是三色标记。</p>
<p> 三色标记：是一种逻辑上的抽象，将每个内存对象分成三种颜色：黑色：表示自己和成员变量都已经标记完毕。灰色：自己标记完了，但是成员变量还没有完全标记完。白色：自己未标记完。</p>
<p> CMS通过增量标记increment update的方式来解决漏标的问题。</p>
<p> 在G1当中采用SATB的方式来避免错标和漏标的情况。</p>
</li>
<li><p>如何进行JVM调优？JVM参数有哪些？怎么查看一个Java进程的JVM参数，谈谈你了解的JVM参数。如果一个Java程序每次运行一段时间后，就变得非常卡顿，你准备如何对他进行优化？</p>
</li>
</ol>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ol>
<li><p>ＭＱ有什么用？有哪些具体的使用场景？</p>
<p> 队列是一种FIFO先进先出的数据结构，而MQ（Message Queue）即消息队列消息，主要作用就是由生产者发送到ＭＱ进行排队，然后由消费者对消息进行处理，具体使用场景如下：</p>
<ol>
<li>异步：作用能提高系统的响应速度和吞吐量。</li>
</ol>
</li>
<li><p>解耦：服务之间解耦，可以减少服务之间的影响，提高系统的稳定性和可扩展性，另外，解耦之后可以实现数据分发，生产者发送一个消息后，可以由多个消费者来处理。</p>
<ol start="3">
<li>削峰：以稳定的系统资源应对突发的流量冲击。 </li>
</ol>
<p> ＭＱ也有一些缺点：</p>
<ol>
<li>系统的可用性降低：一旦ＭＱ宕机，整个服务就会产生影响。</li>
</ol>
</li>
<li><p>系统的复杂度提高：引入ＭＱ之后，数据链路就会变得很复杂，并伴随着很多的问题，例如如何保证消息不丢失？消息不会重复调用？怎么保证消息的顺序性？　．．．</p>
</li>
<li><p>数据一致性：Ａ系统发消息，需要B、Ｃ两个系统一同处理。如果Ｂ系统处理成功，Ｃ系统处理失败，这就会造成数据一致性的问题。</p>
</li>
<li><p>如何进行产品选型？</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Kafka</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>吞吐量非常大，性能非常好，集群高可用</td>
<td>消息可靠性高，功能全面</td>
<td>高吞吐，高性能，高可用，功能非常全面</td>
</tr>
<tr>
<td>缺点</td>
<td>会丢数据，功能比较单一</td>
<td>吞吐量比较低，消息积累会严重影响性能</td>
<td>开源版功能不如云上商业版。官方文档和周边生态还不够成熟。客户端只支持Java</td>
</tr>
<tr>
<td>适用场景</td>
<td>日志分析、大数据采集</td>
<td>小规模场景</td>
<td>几乎是全场景</td>
</tr>
</tbody></table>
<ol start="3">
<li>如何保证消息不丢失？</li>
</ol>
<p>  这个问题主要分为两个方面，第一，哪些环节会造成消息丢失？第二，在这些可能会造成消息丢失的场景下，如何保证不丢失。</p>
<p>  总的来说，消息传递过程中如果存在跨网络的请求，或者由IO操作，就有可能会造成消息丢失，具体如下图：</p>
<p>  <img src="./Interview.assets/1623338875139.png" alt="1623338875139"></p>
<p>  那么如何保证消息不丢失呢？需要按照上面不同场景来单独处理</p>
<ol>
<li><p>生产者发送消息不丢失</p>
<table>
<thead>
<tr>
<th>产品类型</th>
<th>保证生产者发送消息不丢失策略</th>
</tr>
</thead>
<tbody><tr>
<td>kafka</td>
<td>消息发送+回调</td>
</tr>
<tr>
<td>RocketMQ</td>
<td>事务消息</td>
</tr>
<tr>
<td>RabbitMQ</td>
<td>消息发送+回调</td>
</tr>
<tr>
<td></td>
<td>手动事务：Channel：txSelect()开启事务，Channel.txCommit()提交事务，Channel.txRollback()回滚事务，这种方式对channel是会产生阻塞的，造成吞吐量下降</td>
</tr>
<tr>
<td></td>
<td>publisher confirms。整个处理流程跟RocketMQ的事务消息，基本是一样的。</td>
</tr>
</tbody></table>
<p>具体如下图：</p>
<p><img src="assets/1623338892939.png" alt="1623338892939"></p>
</li>
<li><p>MQ主从消息同步不丢失</p>
<table>
<thead>
<tr>
<th>产品类型</th>
<th>主从消息不丢失策略</th>
</tr>
</thead>
<tbody><tr>
<td>RoctMQ</td>
<td>在普通集群中，同步同步、异步同步。异步同步效率更高，但是有丢消息的风险，同步同步就不会丢消息</td>
</tr>
<tr>
<td>Rabbit MQ</td>
<td>普通集群：消息是分散存储的，节点之间不会主动进行消息同步，是有可能丢失消息的</td>
</tr>
<tr>
<td></td>
<td>镜像集群：镜像集群会在节点之间主动进行数据同步，这样数据安全性得到提高。</td>
</tr>
<tr>
<td>Kafka</td>
<td>通常都是用在允许消息少量丢失的场景，可以通过参数配置：acks：0，1，all</td>
</tr>
</tbody></table>
</li>
<li><p>MQ消息存盘不丢失</p>
<p>RocketMQ：同步刷盘、异步刷盘：异步刷盘效率更高，但是有可能丢消息，同步刷盘消息安全性更高，但是效率会降低。</p>
<p>RabbitMQ：将队列配置成持久化队列</p>
</li>
<li><p>消费者消费消息不丢失</p>
<p>RocketMQ:使用默认的方式消费就行，不要采用异步方式</p>
<p>RabbitMQ：autoCommit</p>
<p>Kafka：手动提交offset</p>
</li>
<li><p>如何保证消费幂等性?</p>
<p>其实就是要防止消费者重复消费的问题。</p>
<p>所有MQ产品都没有提供主动解决幂等性的机制，需要由消费者自行控制。</p>
</li>
</ol>
<p>   RocketMQ：给每个消息分配了MessagesID，这个MessagesID可以作为消费者判断幂等的依据，这种方式不太建议。</p>
<p>  最好的方式就是自己带一个有业务标识的id，来进行幂等判断，例如在订单中OrderID</p>
<p>  还可以统一ID分配。</p>
<ol start="4">
<li>MQ如何保证消息顺序?</li>
</ol>
<p>  全局有序和局部有序，MQ只需要保证局部有序，不需要保证全局有序。</p>
<p>  <img src="./Interview.assets/1623338951040.png" alt="1623338951040"></p>
<p>  Java当中对零拷贝进行了封装，Mmap方式通过MappedByteBuffer对象进行操作，而transfer通过FileChannel来进行操作。</p>
<p>  Mmap适合比较小的文件，通常文件大小不要超过1.5G-2G，transfile没有文件大小限制。</p>
<p>  RocketMQ当中使用Mmap方式对它的文件进行读写。</p>
<p>  在Kafka当中，它的index日志文件也是通过Mmap的方式来读写的。在其他的日志文件当中，并没有使用零拷贝的方式，Kafka使用transfile方式将硬盘数据加载到网卡。</p>
<ol start="6">
<li><p>如何保证消息的高效读写?</p>
<p> 零拷贝：Kafka和RocketMQ都是通过零拷贝技术来优化文件读写。</p>
<p> 传统文件复制方式：需要对文件在内存中进行四次拷贝。</p>
<p> <img src="./Interview.assets/1623340880885.png" alt="1623340880885"></p>
<p> 零拷贝：有两种方式：mmap和   transfile</p>
<p> <img src="./Interview.assets/1623340901903.png" alt="1623340901903"></p>
<p> Java当中对零拷贝进行了封装，Mmap方式通过MappedByteBuffer对象进行操作，而transfer通过FileChannel来进行操作。</p>
<p> Mmap适合比较小的文件，通常文件大小不要超过1.5G-2G，transfile没有文件大小限制。</p>
<p> RocketMQ当中使用Mmap方式对它的文件进行读写。</p>
<p> 在Kafka当中，它的index日志文件也是通过Mmap的方式来读写的。在其他的日志文件当中，并没有使用零拷贝的方式，Kafka使用transfile方式将硬盘数据加载到网卡。</p>
</li>
<li><p>使用MQ如何保证分布式事务的最终一致性？</p>
<p> 分布式事务指的是业务相关的多个操作，保证他们同时成功或者同时失败。最终一致性指的是保证事务在最后阶段，能够达到一致性即可，与之对应的就是强一致性。</p>
<p> MQ中要保护事务的最终一致性，就需要做到两点：</p>
<ol>
<li>生产者要保证100%的消息投递（使用事务消息机制）</li>
</ol>
</li>
<li><p>消费者这一段需要保证幂等消费（唯一ID + 业务自己实现幂等）</p>
<p> 分布式MQ的三种语义：at least once、at most once、exactly once</p>
<p> Rocket MQ并不能保证exactly once，商业版本中提供了exactly once的实现机制。</p>
<p> Kafka：在最新版本的饿源码当中，提供了exactly once的demo。</p>
<p> RabbitMQ：使用erlang语言天生就成为了一种屏障</p>
</li>
<li><p>如何设计一个MQ？</p>
<p> 两个误区：1、放飞自我，漫无边际 2、纠结技术细节。</p>
<p> 好的方式：1、从整理到细节，从业务场景到技术实现。2、以现产品为基础。</p>
<p> 具体的设计思路：</p>
<ol>
<li>实现单机的队列的数据结构。高效，可扩展</li>
<li>将单机队列扩展成为分布式队列。分布式集群管理</li>
<li>基于Topic定制消息路由策略</li>
<li>实现高效的网络通信 netty - http</li>
<li>规划日志文件，实现文件告诉读写，零拷贝，顺序写，服务重启后，快速还原运行现场</li>
<li>定制高级功能，死信队列、延迟队列、事务消息等等，注意贴合实际。</li>
</ol>
</li>
</ol>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ol>
<li><p>为什么使用缓存？</p>
<p> 1、高性能</p>
<p> 2、高可用</p>
<p> ​    <img src="./Interview.assets/1623339151379.png" alt="1623339151379"></p>
</li>
<li><p>什么是缓存穿透？缓存击穿？缓存雪崩？怎么解决？</p>
</li>
</ol>
<p>  1）缓存穿透：缓存中查不多，数据库中也查询不到。</p>
<p>  解决方案：1.对参数进行合法性校验 2.将数据库中没有查到的结果的数据也写入到缓存，这时要注意为了防止Redis被无用的key占满，这一类缓存的有效期要设置得短一点。3.引入布隆过滤器，在访问Redis之前判断数据是否存在。要注意布隆过滤器存在一定的误判率，并且，不空过滤器只能加数据不能删数据。</p>
<p>  <img src="./Interview.assets/1623339191238.png" alt="1623339191238"></p>
<p>  2）缓存击穿：缓存中没有，数据库中有，一般是出现在数据初始化以及key过期了的情况，他的问题在于，重新写入缓存需要一定的时间，如果是在高并发场景下，过多的请求就会瞬间写到DB上，给DB造成了很大的压力。</p>
<p>  解决方案：1、设置这个热点缓存永不过期，这时要注意在value 当中包含一个逻辑上的过期时间，然后另起一个线程，定期重建这些缓存。2、在加载DB的时候，要防止并发，只通过一个线程将数据库中的数据加载到缓存当中，从而减少数据库的并发访问量。</p>
<p>  3）缓存雪崩：缓存大面积过期，导致请求都被转发DB，</p>
<p>  解决方案：1、把缓存的失效时间分散开，例如，在原有的统一失效时间基础上，增加一个随机值。</p>
<ol start="3">
<li><p>如何保证Redis与数据库的数据一致？</p>
<p> 当我们对数据进行修改的时候，到底是先删缓存，还是先写数据库？</p>
<p> 1）如果是先删缓存，再写数据库：在高并发场景下，当第一个线程删除了缓存，还没有来得及的写数据库，第二个线程来独去数据，会发现缓存中的数据为空，那就会去读数据库中的数据（旧值、脏数据）读完之后，把读到的结果写入缓存（此时，第一个线程已经将新的值写到缓存里面了），这样缓存中的值就会被覆盖为修改前的脏数据。</p>
<p> 总结：在这种方式下，通常要求写操作不会太频繁。</p>
<p> 解决方案：1、先操作缓存，但是不删除缓存，将缓存修改为一个特殊值（-999），客户端读缓存时，发现是默认直，就休眠一小会，再去查一次Redis，特殊值对业务有侵入，可能会多次重复</p>
<p> 2、延时双删，先删除缓存，再写数据库，休眠一小会，再次删除缓存。如果数据写操作很频繁，同样还是会有脏数据的问题。</p>
<p> 2）先写数据库，再删缓存，如果数据库写完了之后，缓存删除失败，数据就会不一致， </p>
<p> 总结：始终只能保证一定时间内的最终一致性。 </p>
<p> 解决方案：1、给缓存设置一个过期时间，问题：过期时间内，缓存数据不会更新。</p>
<p> 2、引入MQ，保证原子操作。将热点数据缓存设置为永不过期，但是在value当中写入一个逻辑上的过期时间，另起一个后台线程，扫描这些key，对于已逻辑上过期的缓存，进行删除。</p>
</li>
<li><p>如何设计一个分布式锁？如何对锁性能进行优化？</p>
<p> 分布式锁的本质：就是在所有进程都能访问到的一个地方，设置一个锁资源，让这些进程都来竞争锁的资源，数据库、zookeeper、Redis，通常对于分布式锁，会要求响应快、性能高与业务无关。</p>
<p> Redis实现分布式锁：SETNX key value 当key不存在时，就将key设置为value，并返回1，如果key存在就返回0。EXPIRE key locktime 设置key的有效市场，DEL key 删除。 GETSET key value 先GET，再SET，先返回key对应的值，如果没有就返回空，然后再将key设置成value。</p>
<p> 1）最简单的分布式锁：SETNX 加锁。DEL解锁。问题：如果获取到锁的进程执行失败，他就永远不会主动解锁，那这个锁就被锁死了。</p>
<p> 2）给锁设置过期时长。问题：SETNX和EXPIRE并不是原子性的，所以获取到锁的进程有可能还没有执行EXPIRE指令，就挂了，这时锁还是会被锁死。</p>
<p> 3）将锁的内容设置为过期时间（客户端时间+过期时长），SETNX获取锁失败时，拿这个时间跟当前时间比对，如果是过期的锁，就先删除锁，再重新上锁。问题：在高并发场景下，会产生多个进程同时拿到锁的情况</p>
<p> 4）setNX失败后，获取锁上的时间戳，然后用getset，将自己的过期时间更新上去，并获取旧值，如果这个旧值，跟之前获得的时间戳是不一致的，就表示这个锁已经被其他进程占用了，自己要放弃竞争锁。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(RedisConnection conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> newTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> expireTime = nowTime + <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(conn.SETNX(<span class="string">&quot;mykey&quot;</span>),<span class="string">&quot;1&quot;</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        conn.EXPIRE(<span class="string">&quot;mykey&quot;</span>,<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> oldVal = conn.get(<span class="string">&quot;mykey&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span>(oldVal == <span class="keyword">null</span> &amp;&amp; oldVal &lt; nowTime) &#123;</span><br><span class="line">            <span class="keyword">long</span> currentVal = conn.GETSET(<span class="string">&quot;mykey&quot;</span>,expireTime)</span><br><span class="line">            <span class="keyword">if</span>(oldVal == currentVal) &#123;</span><br><span class="line">                conn.EXPIRE(<span class="string">&quot;mykey&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 5）上面就形成了一个比较高效的分布式锁。分析一下，上面优化的各种问题，在于SETNX和EXPIRE两个指令无法保证原子性。Redis2.6提供了直接执行lua脚本的方式，通过lua脚本来保证原子性，redission。</p>
</li>
<li><p>Redis如何让配置key的过期时间？他的实现原理是什么？</p>
<p> redis设置key的过期时间 1、EXPIRE| 2、SETEX</p>
<p> 实现原理：1、定期删除：每隔一段时间，执行一次删除过期key的操作，平衡执行效率和执行时长。定期删除会遍历每个database（默认16个），检查当前库中指定个数的key（默认是20个），随机抽查这些key，如果有过期的，就删除。程序中有一个全局变量扫描到了哪个数据库。</p>
<p> 2、懒汉式删除：当使用get、getset等指令去获取数据时，判断key是否过期，过期后，就先把key删除，再执行后面的操作。</p>
<p> Redis是将两种方式结合来使用的。</p>
</li>
<li><p>海量数据下，如何快速查找一条记录？</p>
<p> 1、使用布隆过滤器，快速过滤不存在的记录，使用Redis的bitmap结构来实现布隆过滤器。</p>
<p> 2、在Redis中建立缓存 </p>
<p> 3、查询优化。自己实现槽位计算，找到记录应该分配在哪台集器上，然后直接去目标机器上找。</p>
</li>
</ol>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><ol>
<li>谈谈你对微服务的理解，微服务有哪些优缺点？</li>
</ol>
<p>  微服务是由Martin Flowler大师提出的。微服务是一种架构风格，通过将大型的单体应用划分为比较小的服务单元，从而降低整个系统的复杂度。</p>
<p>  具有以下优点：</p>
<ul>
<li>服务部署更灵活：每个应用都可以是一个独立的项目，可以独立部署，不依赖其他服务，耦合性降低。</li>
<li>技术选型更加灵活，在大型大体应用中，技术要进行更新，往往是非常困难的。而微服务可以根据业务特点，灵活选择技术栈。</li>
<li>应用的性能得到提高，大型单体应用中，往往启动就会成为一个很大的难关，而采用微服务之后，整个系统的性能是能够提高的。</li>
<li>更容易组合专门的团队，在单体应用中，团队成员往往需要对系统的各个部分都要有深入的了解，门槛是很高的。而采用微服务之后，可以给每个微服务组件专门的团队</li>
<li>代码复用：很多底层服务可以以REST API的方式对外提供统一的服务，所有基础服务可以在整个微服务系统中调用。 </li>
</ul>
<p>  对应的有以下缺点：</p>
<ul>
<li>服务调用的复杂性提高了，面临网络问题、容错问题、负载问题、高并发等等问题</li>
<li>分布式事务，尽量不要使用微服务的分布式事务</li>
<li>测试的难度提升了</li>
<li>运维的难度提升了，单体架构只要维护一个环节，而到了微服务是很多个环境，并且运维方式还都不一样。所以对部署、监控、告警等要求就会变得非常困难</li>
</ul>
<ol start="2">
<li><p>SpringCloud和SpringCloudAlibaba有哪些组件？都解决了什么问题？</p>
<p> 1、SpringCloud：提供了构建微服务系统所需要的一组通用开发模式以及一系列快速实现这些开发模式的工具。</p>
<p> 通常所说的SpringCloud是指SpringCloud NetFlix，他和SpringCloudAlibaba都是SpringCloud这一系列开发模式的具体实现。</p>
<p> SpringCloud NetFlix:</p>
<p> <img src="./Interview.assets/1623339510473.png" alt="1623339510473"></p>
<p> SpringCloudAlibaba:</p>
<p> <img src="./Interview.assets/1623339540507.png" alt="1623339540507"></p>
</li>
<li><p>分布式事务如何处理？怎么保证事务一致性？</p>
<p> 强一致性（刚性事务）。误区：分布式事务=Seata</p>
<p> 分布式事务：就是要将不同节点上的事务操作，提供操作的原子性保证，同时成功或者同时失败。</p>
<p> 分布式事务的第一个要点就是要在原本没有直接关联的事务之间建立联系。</p>
<p> 1）HTTP连接：最大努力通知 –事后补偿</p>
<p> 2）MQ：事务消息机制</p>
<p> 3）Redis：也可以定制出分布式事务机制。</p>
<p> 4）Seata：是通过TC来在多个事务之间建立联系的。</p>
<p> 两阶段：AT XA 核心在于要锁资源，数据库提供了对于事务和锁良好的支持，因此使用AT模式的前题是要应用能够访问到数据库。</p>
<p> 三阶段：TCC 在两阶段的基础上增加一个准备阶段，在准备阶段是不锁资源的，只是表示初始化连接。</p>
<p> SAGA模式：类似于熔断。业务自己实现正向操作和补偿的逻辑。只保证了事务的最终一致性</p>
</li>
<li><p>怎么拆分微服务？怎样设计出高内聚、低耦合的微服务？有没有了解通过DDD领域驱动设计？什么是中台？中台和微服务有什么关系？</p>
<p> 1）拆分微服务的时候，为了保证微服务的稳定，会有一些基本的准则：</p>
<p> 1、微服务之间尽量不要有业务交叉。</p>
<p> 2、微服务之间只能通过接口进行服务调用，而不能绕过接口直接访问对方的数据</p>
<p> 3、高内聚，低耦合。</p>
<p> 高内聚低耦合，是一种从上而下指导微服务设计的方法。·实现高内聚低耦合的工具主要有同步的接口调用和异步的事件驱动（MQ）两种方式。</p>
<p> 什么是DDD：在2004年，由Eric Evans提出的，DDD是面对软件复杂之道。Domain-Driven-Design</p>
<p> Martin Flowler - 贫血模型 - 贫血失忆症 充血模型</p>
<p> MVC架构 -&gt; 领域优先的四层架构</p>
<p> <img src="./Interview.assets/1623339588730.png" alt="1623339588730"></p>
<p> 大泥团：不利于微服务的拆分，大泥团结构拆分出来的微服务就是泥团结构，当服务业务逐渐复杂，这个泥团又会膨胀成为大泥团。</p>
<p> DDD只是一种方法论，没有一个稳定的技术框架。DDD要求领域是跟技术无关、跟存储无关、跟通信无关。</p>
<p> 2）中台这个概念是阿里在2015年提出“小前台、大中台”战略思想。</p>
<p> 所谓中台，就是将各个业务线中可以复用的一些功能抽取出来，剥离个性，提取共性，形成一些可以可复用的组件，例如：盒马鲜生、团购。</p>
<p> 大体上，中台可以分为三类：业务中台、数据中台和技术中台。数据中台、收银中台、支付风控中台。</p>
<p> 中台跟DDD解合：DDD会通过限界上下文将系统拆分成一个一个领域，而这种限界上下文，天生就成了中台之间的逻辑屏障。</p>
<p> DDD在技术与资源调度方面都能够给中台建设提供不错的指导。上层的战略设计能够很好的指导中台划分，下层的战术设计能够很好的指导微服务搭建。</p>
<p> 在目前阶段，DDD还大都处在小范围实验的阶段。</p>
</li>
<li><p>你的项目中是怎么保证微服务敏捷开发的？微服务的链路追踪、持续集成、AB发布要怎么做？</p>
<p> 开发运维一体化。</p>
<p> 敏捷开发：目的就是为了提高团队的交付效率，快速迭代，快速试错。</p>
<p> 每个月固定发布新版本，以分支的形式保存到代码仓库中，快速入职。任务面板、站立会议。团队人员灵活流动，同时形成各个专家代表。测试环境 -&gt; 开发测试环境 -&gt; 集成测试环境 -&gt; 压测环境 -&gt; 预投产环境 -&gt; 生产环境。文档优先。晨会、周会、需求拆分会。</p>
<p> 链路追踪：1、基于日志，形成全局事务ID，落地到日志文件。filebeat -logstash- Elaticsearch形成大型报表。 2、基于MQ，往往需要架构支持，经过流式计算形成一些可视化的结果。</p>
<p> 持续集成：SpringBoot maven pom -&gt; build -&gt; shell；jenkins。</p>
<p> AB发布：1、蓝绿发布、红黑发布。老版本和新版本是同时存在的。2、灰度发布。金丝雀发布。</p>
</li>
</ol>
<h2 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h2><ol>
<li><p>Spring框架中Bean的创建过程是怎样的？</p>
<p> 首先，简单来说，Spring框架中的Bean经历过四个阶段：实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>
<p> 然后，具体来说Spring中Bean经过了以下几个步骤：</p>
<ol>
<li>实例化：new **()两个时机，1、当客户端向容器申请一个Bean时，2、当容器在初始化一个Bean时还需要依赖一个Bean，BeanDefinition对象保存。</li>
</ol>
</li>
<li><p>设置对象属性（依赖注入）：Spring通过BeanDefinition找到对象依赖的其他对象，并将这些对象赋予当前对象。</p>
<ol start="3">
<li>处理Aware接口，Spring会检测对象是否实现了***Aware接口，如果实现了，就会调用对应的方法。BeanNameAware、BeanClassLoaderAware、BeanFactoryAware、ApplicationContextAware。</li>
</ol>
</li>
<li><p>BeanPostProcess，Bean创建的前置处理。调用BeanPostProcess的初始化前的方法。</p>
<ol start="5">
<li>InitializingBean：Spring检测对象如果实现了这个接口，就会执行afterPropertiesSet()方法</li>
</ol>
</li>
<li><p>init-method：自定义的初始化回调方法</p>
<ol start="7">
<li>BeanPorcess的后处理的方法，到这里，这个Bean创建过程就完成了，Bean就可以正常使用了。</li>
</ol>
</li>
<li><p>DisposableBean，当Bena实现了这个接口，在对象销毁前就会调用destory()方法。</p>
<ol start="9">
<li>destory-method：自定义Bean销毁的回调方法。</li>
</ol>
</li>
<li><p>Spring框架中的Bean是线程安全的吗？如果线程不安全，如何处理？</p>
<p> Spring容器本身没有提供Bean的线程安全策略，因此，也可以说Spring容器中的Bean不是线程安全的。</p>
<p> 要如何人处理线程安全问题。就要分情况来分析。</p>
<p> Spring中的作用域：1、Sington 2、prototype：为每个Bean请求创建给实例。3、request为每一个请求创建一个实例，请求完成后失败 4、session：与request是类似的 5、global-session：全局作用域。</p>
<p> 对于线程安全问题：</p>
<p> 1、对于prototype作用域，每次都生成一个新的对象，所以不存在线程安全问题。</p>
<p> 2、对于sington作用域，默认就是线程不安全的。但是对于开发中大部分的Bean，其实是无状态的，不需要保证线程安全</p>
<p> 无状态表示这个实例没有属性对象，不能保存数据，是不变的，比如：controller、service、dao</p>
<p> 有状态表示实例有属性对象，可以保存数据，是线程不安全的，比如POJO</p>
<p> 如果要保证线程安全，可以将Bean的作用改为prototype。也可以采用ThreadLocal来解决线程安全的问题，ThreadLocal为每一个线程保存一个副本变量，每个线程只操作自己的副本变量。</p>
</li>
<li><p>Spring是如何处理循环依赖问题的？</p>
<p> 一种是使用@Lazy注解，另一种是使用三级缓存。</p>
<p> 循环依赖：多个对象之间存在循环的引用关系。在初始化过程中，就会出现”先有蛋还是先有鸡“的问题。</p>
<p> @Lazy注解：解决构造方法造成的循环依赖问题</p>
<p> 对于对象之前的普通引用，二级缓存会保存new出来的不完整对象，这样当单例池中找不到依赖的属性时，就可以先从二级缓存中获取到不完整对象，完成对象的创建，在后续的依赖注入过程中，将单例池中对象的引用关系调整完成。</p>
<p> 三级缓存：如果引用的对象配置了AOP，那在单例池中最终就会需要注入动态代理对象，而不是原对象，而生成动态代理是要在对象初始化完成之后才开始的。于是Spring增加了三级缓存，保存所有对象的动态代理配置信息，在发现有循环依赖时，将这个对象的动态代理信息获取出来，提前进行AOP，生成动态代理。</p>
<p> <img src="./Interview.assets/1623339719343.png" alt="1623339719343"></p>
</li>
<li><p>Spring如何处理事务?</p>
<p> Spring当中支持编程式事务管理和声明式事务管理两种方式。</p>
<p> 1、编程式事务可以用TransactionTemlate</p>
<p> 2、声明式事务：是Spring在AOP基础上提供的事务实现机制，他的最大优点是不需要在业务代码中添加事务管理的代码，只需要在配置文件中做相关的事务规则声明就可以了，但是声明式事务只能针对方法级别，无法控制代码级别的事务管理。Spring中对事务定义了不同的传播级别：Propagation</p>
<p> 1、PROPAGATION_REQUIRED：默认传播行为。如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入到事务中。</p>
<p> 2、PROPAGATION_SUPPORTS：如果当前存在事务，就加入到该事务，如果当前不存在事务，就以非事务方式运行。</p>
<p> 3、PROPAGATION_MANDATORY:如果当前存在事务，就加入到该事务，如果当前不存在事务，就抛出异常。</p>
<p> 4、PROPAGATION_REQUIRES_NEW：无论当前存不存在事务，都创建新事务进行执行。</p>
<p> 5、PROPAGATION_NOT_SUPPORTS：以非事务方式运行，如果当前存在事务，就将当前事务挂起。</p>
<p> 6、PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，就抛出异常。</p>
<p> 7、PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则按REQUIRED属性执行。</p>
<p> Spring中事务的隔离级别：</p>
<p> 1）ISOLATIUON_DEFAULT：使用数据库默认的事务隔离级别。</p>
<p> 2）ISOLATION_READ_UNCOMMITED：读未提交，允许事务在执行过程中，读取其他事务未提交的数据</p>
<p> 3）ISOLATION_READ_COMMITED：读已提交，允许事务在执行过程中，独去其他事务已经提交的数据</p>
<p> 4）ISOLATION_REPEATABLE_UNCOMMITED：可重复度，在同一个事务内，任意时刻的查询结果是一致的。</p>
<p> 5）ISOLATION_READ_SERIALIZABLE：所有事务依次执行。</p>
</li>
<li><p>Spring MVC中的控制器是不是单例模式？如果是，如何保证线程安全？</p>
<p> 控制器是单例模式，单例模式下就会有线程安全问题。</p>
<p> Spring中保证线程安全的方法</p>
<p> 1、将scope设置成singleton，propotype，request。</p>
<p> 2、最好的方式是将控制器设计成无状态模式。在控制器中不要携带数据，但是可以引用无状态的service和dao。</p>
</li>
</ol>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ol>
<li>MySQL有哪几种数据存储引擎?</li>
</ol>
<p>  可以使用SQL查看支持的数据存储引擎：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> ENGINES;</span><br></pre></td></tr></table></figure>

<p>  其中最为常用的是InnoDB和MyISAM两种，</p>
<p>  MyISAM和InnoDB的区别：</p>
<ol>
<li><p>存储文件，MyISAM每个表有两个文件，MYD和MyISAM文件，MYD是数据文件，MYI是索引文件，而InnoDB每个表只有一个文件，idb</p>
</li>
<li><p>InnoDB支持事务，支持行锁，支持外键。</p>
</li>
<li><p>InnoDB支持XA事务。</p>
</li>
<li><p>InnoDB支持事务的savePoints</p>
</li>
<li><p>什么是脏读、不可重复读、幻读。</p>
</li>
</ol>
<p>  脏读、不可重复读、幻读的概念：</p>
<ol>
<li>脏读：在事务进行过程中，读到了其他事务未提交的数据。</li>
<li>不可重复读：在一个事务过程中，多次查询的结果不一致。（update）</li>
<li>幻读：在同一个事务中，用同样的操作查询数据，得到的记录数不相同。(insert)</li>
</ol>
<p>  处理的方式有很多种：加锁、事务隔离、MVCC，这里只介绍使用加锁来解决这些问题：</p>
<ol>
<li><p>脏读：在修改时加排他锁，直到事务提交提交才释放，读取时加共享锁，读完释放锁</p>
</li>
<li><p>不可重复读，读数据时加共享锁，写数据时加排他锁</p>
</li>
<li><p>幻读，加范围锁</p>
</li>
<li><p>事务的基本特性和隔离级别。</p>
</li>
</ol>
<p>  事务：表示多个数据操作组成一个完整的事务单元，这个事务内的所有数据操作要么同时成功，要么同时失败。</p>
<p>  事务的特性：ACID</p>
<ul>
<li>原子性：事务是不可分割的，要么完全成功，要么完全失败。</li>
<li>一致性：事务无论是完成还是失败。都必须保持事务内操作的一致性。当失败是，都要对前面的操作进行会滚，不管中途是否成功。</li>
<li>隔离性：当多个事务操作一个数据的时候，为防止数据损坏，需要将每个事务进行隔离，互相不干扰</li>
<li>持久性：事务开始就不会终止，他的结果不受其他外在因素的影响</li>
</ul>
<p>  在MySQL中可以设置事务的隔离级别：</p>
<table>
<thead>
<tr>
<th>SQL语句</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SHOW VARIABLES like ‘%transaction’</td>
<td>显示事务的隔离级别</td>
</tr>
<tr>
<td>set transction level **</td>
<td>设置隔离级别</td>
</tr>
<tr>
<td>set session transaction level **</td>
<td>当前会话的事务隔离级别</td>
</tr>
<tr>
<td>set global transaction level **</td>
<td>当前全局的事务隔离级别</td>
</tr>
</tbody></table>
<p>  MySQL当中有五种隔离级别：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>具体含义</th>
</tr>
</thead>
<tbody><tr>
<td>NONE</td>
<td>不使用事务</td>
</tr>
<tr>
<td>READ UNCOMMITED</td>
<td>允许脏读</td>
</tr>
<tr>
<td>READ COMMITED</td>
<td>防止脏读，是最常用的隔离级别</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>防止脏读和不可重复读，MySQL默认</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>事务串行，可以防止脏读、幻读、不可重复度</td>
</tr>
</tbody></table>
<p>  五种隔离级别，级别越高，事务的安全性是更高的，但是，事务的并发性能也会越低。</p>
<ol start="4">
<li>MySQL的锁有哪些？什么是间隙锁？</li>
</ol>
<p>  从锁的粒度来区分：</p>
<p>  1）行锁：加锁粒度小，但是加锁的资源开销比较大。InnoDB支持</p>
<p>  共享锁：读锁，表示多个事务可以对同一个数据共享同一把锁，持有锁的事务都可以访问数据，但是只读不能修改。 select ** LOCK IN SHARE MODE。</p>
<p>  排他锁：写锁，只有一个事务能够获得排他锁，其他事务都不能获取该行的锁。InnoDB会对update，delete、insert语句自动添加排他锁。select ** for update。</p>
<p>  自增锁：通常是针对MySQL当中的自增字段。如果有事务会滚这种情况，数据会回滚，但是自增序列不会回滚。</p>
<p>  2）表锁：加锁粒度大，加锁资源开销比较小，MyIAM和InnoDB都支持。</p>
<p>  表共享读锁，表排他写锁</p>
<p>  意向锁：是InnoDB自动添加的一种锁，不需要用户干预。</p>
<p>  3）全局锁：Flush tables with read lock，加锁之后整个数据库实例都处于只读状态，所有的数据变更操作都会被挂起，一般用于全库备份的时候。</p>
<p>  常见的锁算法：</p>
<p>  1、记录锁：锁一条具体的数据。</p>
<p>  2、间隙锁：RR隔离级别下，会加间隙锁。锁一定的范围，而不是锁具体的记录，是为了防止产生幻读。</p>
<p>  3、Next-key：间隙锁 + 右记录锁。 </p>
<ol start="5">
<li>MySQL索引结构是什么样的？聚簇索引和非聚簇索引又是什么</li>
</ol>
<p>  二叉树 -&gt; AVL树 -&gt; 红黑树 -&gt; B-树 -&gt; B+树</p>
<p>  二叉树：每个节点最多只有两个子节点，左边的子节点都比当前节点小，右边的子节点都比当前节点大。</p>
<p>  AVL:树中任意节点的两个子树的高度差最大为1.</p>
<p>  红黑树：1、每个节点都是红色或者黑色 2、根节点是黑色 3、每个叶子节点都是黑色的空节点。4、红色节点的父子节点都必须是黑色。5、从任一节点到其中每个叶子节点的所有路径都包含相同的黑色节点。</p>
<p>  B-树：1、B-树的每个非叶子节点的子节点个数都不会超过D（这个D就是B-树的阶）2、所有的叶子节点都在同一层 3、所有节点关键字都是按照递增顺序排列。</p>
<p>  B+树：1、非叶子节点不存储数据，只进行数据索引 2、所有数据都存储在叶子节点当中 3、每个叶子节点都存有相邻叶子节点的指针 4、叶子节点按照本身关键字从小到大排序。</p>
<p>  聚簇索引：数据和索引是在一起。</p>
<p>  非聚簇索引：数据和索引不在一起。</p>
<p>  MyISAM使用的非聚簇索引，树的子节点上的data不是数据本身，而是数据存放的地址，InnoDB采用的是聚簇索引，树的叶子节点上的data就是数据本身。</p>
<p>  聚簇索引的数据是物理存放顺序和索引顺序是一致的，所以一个表中只能有一个聚簇索引，而非聚簇索引可以有多个。</p>
<p>  InnoDB中，如果表定义了PK，那PK就是聚簇索引，如果没有PK，就会找一个非空的unique列作为聚簇索引。否则，InnoDB会创建一个隐藏的row-id作为聚簇索引。</p>
<p>  MySQL的索引覆盖和回表</p>
<p>  如果只需要在一颗索引树上就可以获取SQL所需要的所有列，就不需要再回表查询，这样查询速度就可以更快。</p>
<p>  实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引当中。</p>
<ol start="6">
<li>MySQL集群是如何搭建的？读写分离是怎么做的？</li>
</ol>
<p>  MySQL主从结构原理：</p>
<p>  <img src="./Interview.assets/1623339952421.png" alt="1623339952421"></p>
<p>  MySQL通过将主节点的Binlog同步给从节点完成主从之间的数据同步。</p>
<p>  MySQL的主从集群只会讲Binlog从主节点同步到从节点，而不会反过来同步问题。</p>
<p>  因为要保证主从之间的数据一致，写数据的操作只能在主节点完成。而读数据的操作，可以在主节点或者从节点上完成。</p>
<p>   这种方式有丢失数据的风险，可以采用半同步的方式：</p>
<p>  <img src="./Interview.assets/1623339978966.png" alt="1623339978966"></p>
<ol start="7">
<li>谈谈如何对MySQL进行分库分表？多大数据量需要进行分库分表？分库分表的方式和分片策略由哪些？分库分表后，SQL语句执行流程是怎样的？</li>
</ol>
<p>  什么是分库分表：就是当表中的数据量过大时，整个查询效率就会降低的非常明显，这是为了提升查询效率，就要将一个表中的数据分散到多个数据库的多个表当中。</p>
<p>  数据分片的方式有垂直分片和水平分片。垂直分片就是从业务角度将不同的表拆分到不同的表中，能够解决数据库数据文件过大的问题，但是不能从根本上解决查询问题。水平分片就是从数据角度将一个表中的数据拆分到不同的库或者表中，这样可以从根本上解决数据量过大造成的查询效率低的问题。</p>
<p>  常见的分片策略有：</p>
<ul>
<li><p>  取余/取模：优点：均匀存放数据，缺点，扩容非常麻烦</p>
</li>
<li><p>按照范围分片：比较好扩容，数据分布不够均匀</p>
</li>
<li><p>按照时间分片：比较容易将热点数据区分出来</p>
</li>
<li><p>按照枚举值分片：例如按地区分片</p>
</li>
<li><p>按照目标字段前缀指定进行分区：自定义业务规则分片</p>
<p>建议：一个表的数据量超过500W或者数据文件超过2G，就要考虑分库分表了。</p>
<p>分库分表最常用的组件：MyCat、ShardingSphere</p>
<p>ShardingSphere分库分表的执行流程：</p>
<p><img src="./Interview.assets/1623340013484.png" alt="1623340013484"></p>
<p>与之相关的会衍生出一系列的问题，例如一个user表，按照userid进行了分片，然后我需要按照sex字段去查，这样怎么查？强制指定只查一个数据库，要怎么做？查询结果按照userid来排序，要怎么排？</p>
</li>
</ul>
<p> 分库分表也并不是完美的，在解决了一些问题的同时，也带来了一定的缺点：</p>
<ul>
<li>  事务一致性问题</li>
<li>跨节点关联查询问题</li>
<li>跨节点分页、排序函数</li>
<li>主键避重</li>
</ul>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ol>
<li><p>什么是倒排索引？有什么好处？</p>
<p> 索引：从id到内容。</p>
<p> 倒排索引：从内容到id。好处：比较适合做关键字检索。可以控制数据的总量。提高查询效率。</p>
<p> 搜索引擎为什么MySQL查询快？lucence是es的底层框架</p>
<p> 文章 -&gt; term -&gt;排序 term dictionary （这里类似新华字典 目录）-&gt; term index（a开头的拼音） -&gt; Posting List -&gt; 文章ID，[在文章中出现的偏移量]，权重（TFIDF）</p>
</li>
<li><p>ES了解多少？说说你们公司的ES集群架构。</p>
<p> 是一个基于Lucene框架（是一个非常高效的全文检索引擎框架）的搜索引擎产品，you know for search,提供了restful风格的操作接口。</p>
<p> ES包含了一些核心概念：</p>
<ul>
<li>索引 index：类似关系型数据库中的table</li>
</ul>
</li>
</ol>
<ul>
<li>文档 document：row<ul>
<li>字段 field text\keyword\byte：列</li>
</ul>
</li>
<li>映射Mapping：Schema<ul>
<li>查询方式：DSL（ES的新版本也支持SQL）</li>
</ul>
</li>
<li>分片sharding和副本replicas：index都是由sharding组成的。每个sharding都有一个或者多个备份。</li>
</ul>
<p>另外关于ES的使用场景：ES可以用在大数量的搜索场景下，另外ES也有很强大的计算能力，可以用在用户画像等场景。</p>
<ol start="3">
<li><p>如何进行中文分词？</p>
<p> IK分词器。HanLp中文分词器。</p>
</li>
<li><p>ES写入数据与查询数据的原理。</p>
<p> 写入数据的原理：</p>
<ol>
<li>客户端发写数据的请求是，可以发往任意节点，这个节点就会成为coordinating node 协调节点</li>
</ol>
</li>
<li><p>计算的点文档要写入的分片：计算时就采用hash取模的方式计算</p>
<ol start="3">
<li>协调节点就会进行路由，将请求转发给对应的primary sharding所在的datanode。</li>
</ol>
</li>
<li><p>datanode节点上的primary sharding处理请求，写入数据到索引库，并且将数据同步到对应的replica sharding</p>
<ol start="5">
<li>等promary sharding 和 replica sharding都保存好文档了之后，返回客户端响应</li>
</ol>
<p> <img src="./Interview.assets/1623340159941.png" alt="1623340159941"></p>
<p> 查询数据的原理：</p>
<ol>
<li>客户端发送请求可发给任意节点，这个节点就成为协调节点；</li>
<li>协调节点将查询请求广播到每一个数据节点，这些数据节点的分片就会处理该查询请求；</li>
<li>每个分片进行数据查询，将符合条件的数据放在一个队列当中，并将这些数据的文档ID、节点信息、分片信息都返回给协调节点；</li>
<li>由协调节点将所有的返回结果进行汇总，并排序；</li>
<li>协调节点向包含这些文档ID的分片发送get请求，对应的分片将文档数据返回给协调节点，最后协调节点将数据整合返回给客户端。</li>
</ol>
</li>
<li><p>ES部署时，要如何进行优化？</p>
<ol>
<li>集群部署优化</li>
<li>调整ES的一些重要参数。path.data尽量使用固态硬盘，定制JVM堆内存大小，ES的参数，实际上大部分情况下是不需要调优的，如果有性能问题，最好的办法是安排更合里的sharding布局并且增加节点数据。</li>
<li>更合理的sharding布局，让sharding对应的replica sharding尽量在同一个机房。</li>
<li>Linux服务器上一些优化策略，不要用root用户：修改虚拟内存大小，修改普通用户可以创建的最大线程数。</li>
</ol>
</li>
</ol>
<p> ES生态：ELK日志收集解决方案：filebeat -&gt; logstash -&gt; elaticsearch -&gt; kibana。</p>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><ol>
<li><p>什么是认证和授权？如何设计一个权限认证框架？</p>
<p>  认证：就是对系统访问者的身份进行确认（用户名密码登录、二维码登录、指纹、刷脸…）。</p>
<p> 授权：就是对系统访问者的行为进行控制，授权通常是在认证之后，对系统内的隐私数据进行保护，后台接口访问权限，前台控件的访问权限。</p>
<p> 通常情况下我们通过RBAC模型，也就是用户关联角色 ，而角色访问不同的资源，从而控制用户访问系统的行为。</p>
<p> 认证和授权也是对一个权限认证框架进行评估的两个主要的方面。</p>
</li>
<li><p>cookie和session有什么区别？如果没有Cookie、Seesion还能进行身份验证吗？</p>
<p> 当服务器tomcat第一次接收到客户端的请求时，会开辟一块独立的session空间，建立一个session对象，同时会生成session id，通过响应头的方式保存到客户端浏览器的cookie当中，以后客户端的每次请求，都会在请求头部带上这个session id，这样就可以对应上服务端的一些会话信息，比如用户的登录状态。</p>
<p>   如果没有客户端的cookie，session时无法进行身份验证的。</p>
<p>   当服务端从单体应用升级为分布式之后，cookie + session要如何扩展？</p>
<ul>
<li>session黏贴，在负载均衡中，通过某种机制，保证同一个客户端的所有请求都会转发到同一个tomcat实例当中。当这个tomcat实例出现问题之后，请求就会被转发到其他实例，这时候用户的session用户信息就丢失了。</li>
<li>session复制：当一个tomcat实例上保存了session信息后，主动将session复制到集群中的其他实例。问题：复制是需要时间的，在复制的过程中，容器产生session信息丢失。</li>
<li>session共享，就是将服务端的session信息保存到一个第三方中，比如Redis</li>
</ul>
</li>
<li><p>什么是CSRF攻击？如何防止？</p>
<p> CSRF：Cross Site Request Forgery 跨站请求伪造。</p>
<p> 一个正常的请求会将合法用户的session id保存到浏览器的cookie，这时候，如果用户在浏览器中打开另一个Tab页，那这个tab页也是可以获得浏览器的cookie，黑客就可以利用这个cookie信息进行攻击</p>
<p> 攻击过程：</p>
<ol>
<li><p>某银行网站A可以以GET请求的方式发起转账操作。<a target="_blank" rel="noopener" href="http://www.xxx.com/transfor.do?accountNum=100&amp;money=1000">www.xxx.com/transfor.do?accountNum=100&amp;money=1000</a> accountNum表示目标账户，这个请求肯定是需要登录才可以正常访问的，</p>
</li>
<li><p>攻击者在某个论坛或者网站上上传一个图片，链接地址是<a target="_blank" rel="noopener" href="http://www.xxx.com/transfor.do?accountNum=100&amp;money=1000%EF%BC%8C%E5%85%B6%E4%B8%ADaccountNum%E5%B0%B1%E6%98%AF%E6%94%BB%E5%87%BB%E8%80%85%E8%87%AA%E5%B7%B1%E7%9A%84%E9%93%B6%E8%A1%8C%E8%B4%A6%E6%88%B7%E3%80%82">www.xxx.com/transfor.do?accountNum=100&amp;money=1000，其中accountNum就是攻击者自己的银行账户。</a></p>
</li>
<li><p>如果有一个用户，登录了银行网站，然后又打开浏览器的另一个Tab页，点击了这个图片，这时，银行就会受理到一个带了正确的cookie的请求，就会完成转账，用户的钱就被盗了。</p>
</li>
</ol>
<p>  防止CSRF的方式：</p>
<ol>
<li><p>尽量使用POST请求，限制GET请求，POST请求可以带请求体，攻击者就不容易伪造出请求。</p>
</li>
<li><p>将cookie设置为HttpOnly：response.setHeader(“Set-Cookie”,”cookiename=cookievalue;HttpOnly”)。</p>
</li>
<li><p>增加token：在请求中放入一个攻击者无法伪造的信息，并且该信息不存在于cookie当中。</p>
</li>
<li><p>增加一个额外的隐藏信息<code>&lt;input type=&#39;hidden&#39; value=&#39;demo&#39;&gt;</code>这也是Spring Security框架中采用的防范方式。</p>
</li>
</ol>
</li>
<li><p>什么是OAuth2？有哪几种认证方式？什么是JWT令牌？和普通令牌有什么区别？</p>
</li>
</ol>
<p>OAuth2.0是一个开放标准，允许用户授权在第三方应用程序访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方应用分享他们数据的所有内容。</p>
<p>OAuth2.0的协议认证流程，简单理解，就是允许我们将之前的授权和认证过程交给一个独立的第三方进行担保。</p>
<p>OAuth2.0协议有四种模式：</p>
<p>授权码模式：</p>
<p><img src="./Interview.assets/1623340322241.png" alt="1623340322241"></p>
<p>简化模式：</p>
<p><img src="./Interview.assets/1623340341140.png" alt="1623340341140"></p>
<p>密码模式：</p>
<p><img src="./Interview.assets/1623340368298.png" alt="1623340368298"></p>
<p>客户端模式：</p>
<p><img src="./Interview.assets/1623340385478.png" alt="1623340385478"></p>
<p>在梳理OAuth2.0协议流程的过程中，其实有一个主线，就是三方参与者的信任程度。</p>
<p>普通令牌只是一个普通的字符串，没有特殊的意义，这就意味着，当客户端带上令牌去访问应用的接口时，应用本身无法判断这个令牌是否正确，他就需要到授权服务器上去拍段令牌是否有效，在高并发的场景下，检查令牌的网络请求就有可能成为一个性能瓶颈。</p>
<p>改良的方式就是JWT令牌，将令牌对应的相关信息全部冗余到令牌本身，这样资源服务器就不再需要发送求请给授权服务器去检查令牌了，他自己就可以读取到令牌的授权信息。JWT令牌的本质就是一个加密的字符串。</p>
<ol>
<li>什么是SSO？与OAuth2.0有什么关系？</li>
</ol>
<p>  OAuth2.0的使用场景通常称为联合登录，一处注册，多处使用。</p>
<p>  SSO：Single Sign ON：一处登录，多处同时登录。</p>
<p>  SSO的实现关键是将Seesion信息几种存储，通常使用Spring Security实现</p>
<ol start="2">
<li>如何设计一个开放授权平台？</li>
</ol>
<p>  开发授权平台页可以按照认证和授权两个方向来梳理。</p>
<ol>
<li><p>认证：就可以按照OAuth2.0协议来规划认证的过程</p>
</li>
<li><p>授权，首先需要待接入的第三方应用在开放授权平台进行注册，注册需要提供几个必要的信息：clintID，消息推送地址（一堆公私钥），私钥由授权平台自己保存，公钥分发给第三方应用。然后，第三方应用引导可户发起请求时，采用公钥进行参数加密，然后授权开放平台使用对应的私钥解密。接下来，授权开放平台同步响应第三方应用的只是消息是否处理成功的结果，而真正的业务数据由授权开放平台异步推送给第三方应用预留的推送地址。</p>
</li>
</ol>

    </div>

    
    
    
        <div class="reward-container">
  <div>感谢您的支持！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="吉永超 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>吉永超
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://jycoder.club/2020/10/07/Interview/" title="面试题精选">https://jycoder.club/2020/10/07/Interview/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/05/Concurrency/" rel="prev" title="Java并发编程">
      <i class="fa fa-chevron-left"></i> Java并发编程
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/06/jvm/" rel="next" title="深入理解JVM">
      深入理解JVM <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="nav-number">1.</span> <span class="nav-text">基础篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.1.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.2.</span> <span class="nav-text">集合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%AF%87"><span class="nav-number">2.</span> <span class="nav-text">高级篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%B9%B6%E5%8F%91"><span class="nav-number">2.1.</span> <span class="nav-text">Java并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="nav-number">2.2.</span> <span class="nav-text">Java网络通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">2.3.</span> <span class="nav-text">JVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">2.4.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">2.5.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.6.</span> <span class="nav-text">微服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%A1%86%E6%9E%B6"><span class="nav-number">2.7.</span> <span class="nav-text">Spring框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL"><span class="nav-number">2.8.</span> <span class="nav-text">MySQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Elasticsearch"><span class="nav-number">2.9.</span> <span class="nav-text">Elasticsearch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="nav-number">2.10.</span> <span class="nav-text">网络安全</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">吉永超</p>
  <div class="site-description" itemprop="description"></div>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吉永超</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">618k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:22</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
