const e=JSON.parse('{"key":"v-07597218","path":"/java_basics/concurrent_programming/","title":"Java并发编程","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"JMM实现原理","slug":"jmm实现原理","link":"#jmm实现原理","children":[{"level":3,"title":"可见性","slug":"可见性","link":"#可见性","children":[]},{"level":3,"title":"原子性","slug":"原子性","link":"#原子性","children":[]},{"level":3,"title":"有序性","slug":"有序性","link":"#有序性","children":[]}]},{"level":2,"title":"List、Set、HashMap底层原理","slug":"list、set、hashmap底层原理","link":"#list、set、hashmap底层原理","children":[]},{"level":2,"title":"线程池底层原理","slug":"线程池底层原理","link":"#线程池底层原理","children":[]},{"level":2,"title":"深入理解Java线程","slug":"深入理解java线程","link":"#深入理解java线程","children":[]},{"level":2,"title":"CAS与Atomic实现原理","slug":"cas与atomic实现原理","link":"#cas与atomic实现原理","children":[{"level":3,"title":"CAS源码解析","slug":"cas源码解析","link":"#cas源码解析","children":[]},{"level":3,"title":"Atomic源码解析","slug":"atomic源码解析","link":"#atomic源码解析","children":[]}]},{"level":2,"title":"synchronized实现原理","slug":"synchronized实现原理","link":"#synchronized实现原理","children":[{"level":3,"title":"synchronized基础","slug":"synchronized基础","link":"#synchronized基础","children":[]},{"level":3,"title":"Monitor机制","slug":"monitor机制","link":"#monitor机制","children":[]},{"level":3,"title":"对象头","slug":"对象头","link":"#对象头","children":[]},{"level":3,"title":"偏向锁","slug":"偏向锁","link":"#偏向锁","children":[]},{"level":3,"title":"锁粗化","slug":"锁粗化","link":"#锁粗化","children":[]},{"level":3,"title":"锁消除","slug":"锁消除","link":"#锁消除","children":[]},{"level":3,"title":"逃逸分析","slug":"逃逸分析","link":"#逃逸分析","children":[]},{"level":3,"title":"synchronized的优化","slug":"synchronized的优化","link":"#synchronized的优化","children":[]}]},{"level":2,"title":"AQS与ReentrantLock实现原理","slug":"aqs与reentrantlock实现原理","link":"#aqs与reentrantlock实现原理","children":[{"level":3,"title":"同步等待队列","slug":"同步等待队列","link":"#同步等待队列","children":[]},{"level":3,"title":"条件等待队列","slug":"条件等待队列","link":"#条件等待队列","children":[]},{"level":3,"title":"Condition接口","slug":"condition接口","link":"#condition接口","children":[]},{"level":3,"title":"ReentrantLock详解","slug":"reentrantlock详解","link":"#reentrantlock详解","children":[]},{"level":3,"title":"synchronized和ReentrantLock","slug":"synchronized和reentrantlock","link":"#synchronized和reentrantlock","children":[]}]},{"level":2,"title":"Semaphore与CountDownLatch","slug":"semaphore与countdownlatch","link":"#semaphore与countdownlatch","children":[]},{"level":2,"title":"CylicBarrier实现原理","slug":"cylicbarrier实现原理","link":"#cylicbarrier实现原理","children":[]},{"level":2,"title":"ReentrantReadWriteLock","slug":"reentrantreadwritelock","link":"#reentrantreadwritelock","children":[]},{"level":2,"title":"BlockingQueue实现原理","slug":"blockingqueue实现原理","link":"#blockingqueue实现原理","children":[{"level":3,"title":"Queue队列","slug":"queue队列","link":"#queue队列","children":[]},{"level":3,"title":"BlockingQueue","slug":"blockingqueue","link":"#blockingqueue","children":[]},{"level":3,"title":"ArrayBlockingQueue","slug":"arrayblockingqueue","link":"#arrayblockingqueue","children":[]},{"level":3,"title":"LinkedBlockingQueue","slug":"linkedblockingqueue","link":"#linkedblockingqueue","children":[]},{"level":3,"title":"LinkedBlockingDeque","slug":"linkedblockingdeque","link":"#linkedblockingdeque","children":[]},{"level":3,"title":"SynchronousQueue","slug":"synchronousqueue","link":"#synchronousqueue","children":[]},{"level":3,"title":"PriorityBlockingQueue","slug":"priorityblockingqueue","link":"#priorityblockingqueue","children":[]},{"level":3,"title":"LinkedTransferQueue","slug":"linkedtransferqueue","link":"#linkedtransferqueue","children":[]},{"level":3,"title":"DelayQueue","slug":"delayqueue","link":"#delayqueue","children":[]},{"level":3,"title":"如何选择合适的阻塞队列","slug":"如何选择合适的阻塞队列","link":"#如何选择合适的阻塞队列","children":[]}]},{"level":2,"title":"ForkJoin实现原理","slug":"forkjoin实现原理","link":"#forkjoin实现原理","children":[{"level":3,"title":"工作窃取","slug":"工作窃取","link":"#工作窃取","children":[]},{"level":3,"title":"工作队列","slug":"工作队列","link":"#工作队列","children":[]},{"level":3,"title":"ForkJoinWorkThread","slug":"forkjoinworkthread","link":"#forkjoinworkthread","children":[]},{"level":3,"title":"原理分析","slug":"原理分析","link":"#原理分析","children":[]}]},{"level":2,"title":"CompletableFuture实现原理","slug":"completablefuture实现原理","link":"#completablefuture实现原理","children":[{"level":3,"title":"Future","slug":"future","link":"#future","children":[]},{"level":3,"title":"CompletionService","slug":"completionservice","link":"#completionservice","children":[]},{"level":3,"title":"CompletableFuture","slug":"completablefuture","link":"#completablefuture","children":[]}]},{"level":2,"title":"高性能队列Disruptor","slug":"高性能队列disruptor","link":"#高性能队列disruptor","children":[{"level":3,"title":"RingBuffer","slug":"ringbuffer","link":"#ringbuffer","children":[]},{"level":3,"title":"Disruptor实战","slug":"disruptor实战","link":"#disruptor实战","children":[]}]},{"level":2,"title":"并发设计模式","slug":"并发设计模式","link":"#并发设计模式","children":[{"level":3,"title":"终止线程模式","slug":"终止线程模式","link":"#终止线程模式","children":[]},{"level":3,"title":"避免共享的设计模式","slug":"避免共享的设计模式","link":"#避免共享的设计模式","children":[]},{"level":3,"title":"多线程版本的if模式","slug":"多线程版本的if模式","link":"#多线程版本的if模式","children":[]},{"level":3,"title":"多线程分工模式","slug":"多线程分工模式","link":"#多线程分工模式","children":[]}]}],"git":{"updatedTime":1711014681000,"contributors":[{"name":"jiyongchao","email":"jycoder@163.com","commits":1}]},"filePathRelative":"java_basics/concurrent_programming/README.md"}');export{e as data};
