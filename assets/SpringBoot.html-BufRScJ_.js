import{_ as n,r as i,o as l,c as a,a as o,b as e,d as t,e as s}from"./app-C2Koezm4.js";const p={},g=o("h2",{id:"springboot面试题",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#springboot面试题"},[o("span",null,"SpringBoot面试题")])],-1),h=o("h3",{id:"为什么springboot的-jar可以直接运行",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#为什么springboot的-jar可以直接运行"},[o("span",null,"为什么SpringBoot的 jar可以直接运行？")])],-1),c={href:"https://blog.fundebug.com/2019/01/09/how-does-springboot-start/",target:"_blank",rel:"noopener noreferrer"},d=s('<h3 id="springboot自动装配过程及实现原理" tabindex="-1"><a class="header-anchor" href="#springboot自动装配过程及实现原理"><span>SpringBoot自动装配过程及实现原理？</span></a></h3><h3 id="springboot如何防止表单重复提交" tabindex="-1"><a class="header-anchor" href="#springboot如何防止表单重复提交"><span>SpringBoot如何防止表单重复提交？</span></a></h3><div class="note info"><p>幂等性，通俗的说就是一个接口，多次发起同一个请求，必须保证操作只能执行一次。</p></div><p>需要幂等性的场景：</p><ul><li>订单接口，不能多次创建订单</li><li>支付接口，重复支付同一笔订单只能扣一次钱</li><li>支付宝回调接口，可能会多次回调，必须处理重复回调</li><li>普通表单提交接口，因为网络超时、卡顿等原因多次点击提交，只能成功一次等等</li></ul><p>常见的方案：</p><ul><li><p>从数据库方面考虑，数据设计的时候，如果有唯一性，考虑建立唯一索引</p></li><li><p>从应用层面考虑，首先判断是单机服务还是分布式服务</p><ul><li>单机服务：考虑一些缓存Cache，利用缓存，来保证数据的重复提交</li><li>分布式服务：考虑将用户的信息，例如token和请求的url进行组装在一起形成令牌，存储到缓存中，例如redis，并设置超时时间为**秒，如此来保证数据的唯一性（利用了redis的分布式锁）</li></ul></li></ul><p>解决方案大致总结如下：</p><ul><li>唯一索引：防止新增脏数据</li><li>token机制：防止页面重复提交，实现接口的幂等性校验</li><li>分布式锁：redis（jredis、redisson）或zookeeper实现</li><li>悲观锁：获取数据的时候加锁（锁表或锁行）</li><li>乐观锁：基于版本号version实现，在更新数据那一刻校验数据</li><li>状态机：状态变更，更新数据时判断状态</li></ul>',9),b={href:"https://blog.csdn.net/ITBigGod/article/details/105510980",target:"_blank",rel:"noopener noreferrer"},_=o("h3",{id:"如何自己写一个springboot-starter",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#如何自己写一个springboot-starter"},[o("span",null,"如何自己写一个SpringBoot Starter？")])],-1),u={href:"https://juejin.cn/post/7124603507025379365#heading-16",target:"_blank",rel:"noopener noreferrer"};function m(f,S){const r=i("ExternalLinkIcon");return l(),a("div",null,[g,h,o("p",null,[e("详细参见："),o("a",c,[e("SpringBoot的 jar可以直接运行"),t(r)]),e("。")]),d,o("p",null,[e("其中，前三种最为常见，更多内容可以参考："),o("a",b,[e("SpringBoot/Web项目防止表单/请求重复提交（单体和分布式）"),t(r)])]),_,o("p",null,[e("参见："),o("a",u,[e("手把手教你写一个 Starter"),t(r)]),e("。")])])}const k=n(p,[["render",m],["__file","SpringBoot.html.vue"]]),v=JSON.parse('{"path":"/interview/common_framework/SpringBoot.html","title":"","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"SpringBoot面试题","slug":"springboot面试题","link":"#springboot面试题","children":[{"level":3,"title":"为什么SpringBoot的 jar可以直接运行？","slug":"为什么springboot的-jar可以直接运行","link":"#为什么springboot的-jar可以直接运行","children":[]},{"level":3,"title":"SpringBoot自动装配过程及实现原理？","slug":"springboot自动装配过程及实现原理","link":"#springboot自动装配过程及实现原理","children":[]},{"level":3,"title":"SpringBoot如何防止表单重复提交？","slug":"springboot如何防止表单重复提交","link":"#springboot如何防止表单重复提交","children":[]},{"level":3,"title":"如何自己写一个SpringBoot Starter？","slug":"如何自己写一个springboot-starter","link":"#如何自己写一个springboot-starter","children":[]}]}],"git":{"updatedTime":1724812116000,"contributors":[{"name":"jiyongchao","email":"jycoder@163.com","commits":1}]},"filePathRelative":"interview/common_framework/SpringBoot.md","readingTime":{"minutes":1.72,"words":516},"excerpt":"<h2>SpringBoot面试题</h2>\\n<h3>为什么SpringBoot的 jar可以直接运行？</h3>\\n<p>详细参见：<a href=\\"https://blog.fundebug.com/2019/01/09/how-does-springboot-start/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">SpringBoot的 jar可以直接运行</a>。</p>\\n<h3>SpringBoot自动装配过程及实现原理？</h3>\\n<h3>SpringBoot如何防止表单重复提交？</h3>\\n<div class=\\"note info\\"><p>幂等性，通俗的说就是一个接口，多次发起同一个请求，必须保证操作只能执行一次。</p></div>"}');export{k as comp,v as data};
