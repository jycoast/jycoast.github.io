import{_ as t,o as a,c as e,e as l}from"./app-a5e8ecff.js";const d={},i=l('<h1 id="消息队列" tabindex="-1"><a class="header-anchor" href="#消息队列" aria-hidden="true">#</a> 消息队列</h1><h2 id="mq有什么用-有哪些具体的使用场景" tabindex="-1"><a class="header-anchor" href="#mq有什么用-有哪些具体的使用场景" aria-hidden="true">#</a> ＭＱ有什么用？有哪些具体的使用场景？</h2><p>队列是一种FIFO先进先出的数据结构，而MQ（Message Queue）即消息队列消息，主要作用就是由生产者发送到ＭＱ进行排队，然后由消费者对消息进行处理，具体使用场景如下：</p><ul><li>异步：作用能提高系统的响应速度和吞吐量。</li><li>解耦：服务之间解耦，可以减少服务之间的影响，提高系统的稳定性和可扩展性，另外，解耦之后可以实现数据分发，生产者发送一个消息后，可以由多个消费者来处理。</li><li>削峰：以稳定的系统资源应对突发的流量冲击。</li></ul><p>不过，ＭＱ也有一些缺点：</p><ul><li>系统的可用性降低：一旦ＭＱ宕机，整个服务就会产生影响。</li><li>系统的复杂度提高：引入ＭＱ之后，数据链路就会变得很复杂，并伴随着很多的问题，例如如何保证消息不丢失？消息不会重复调用？怎么保证消息的顺序性？等等</li><li>数据一致性：Ａ系统发消息，需要B、Ｃ两个系统一同处理。如果Ｂ系统处理成功，Ｃ系统处理失败，这就会造成数据一致性的问题。</li></ul><h2 id="如何进行产品选型" tabindex="-1"><a class="header-anchor" href="#如何进行产品选型" aria-hidden="true">#</a> 如何进行产品选型？</h2><table><thead><tr><th></th><th>Kafka</th><th>RabbitMQ</th><th>RocketMQ</th></tr></thead><tbody><tr><td>优点</td><td>吞吐量非常大，性能非常好，集群高可用</td><td>消息可靠性高，功能全面</td><td>高吞吐，高性能，高可用，功能非常全面</td></tr><tr><td>缺点</td><td>会丢数据，功能比较单一</td><td>吞吐量比较低，消息积累会严重影响性能</td><td>开源版功能不如云上商业版。官方文档和周边生态还不够成熟。客户端只支持Java</td></tr><tr><td>适用场景</td><td>日志分析、大数据采集</td><td>小规模场景</td><td>几乎是全场景</td></tr></tbody></table><h2 id="如何保证消息不丢失" tabindex="-1"><a class="header-anchor" href="#如何保证消息不丢失" aria-hidden="true">#</a> 如何保证消息不丢失？</h2><p>这个问题主要分为两个方面，第一，哪些环节会造成消息丢失？第二，在这些可能会造成消息丢失的场景下，如何保证不丢失。</p><p>总的来说，消息传递过程中如果存在跨网络的请求，或者由IO操作，就有可能会造成消息丢失，具体如下图：</p><img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210630002742.png" alt="img" style="zoom:67%;"><p>那么如何保证消息不丢失呢？需要按照上面不同场景来单独处理</p><ol><li>生产者发送消息不丢失</li></ol><table><thead><tr><th style="text-align:center;">产品类型</th><th>保证生产者发送消息不丢失策略</th></tr></thead><tbody><tr><td style="text-align:center;">kafka</td><td>消息发送+回调</td></tr><tr><td style="text-align:center;">RocketMQ</td><td>事务消息</td></tr><tr><td style="text-align:center;">RabbitMQ</td><td>消息发送+回调</td></tr><tr><td style="text-align:center;"></td><td>手动事务：Channel：txSelect()开启事务，Channel.txCommit()提交事务，Channel.txRollback()回滚事务，这种方式对channel是会产生阻塞的，造成吞吐量下降</td></tr><tr><td style="text-align:center;"></td><td>publisher confirms。整个处理流程跟RocketMQ的事务消息，基本是一样的。</td></tr></tbody></table><p>具体见下图：</p><p><img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210630002758.png" alt="img"></p><ol start="2"><li>MQ主从消息同步不丢失</li></ol><table><thead><tr><th>产品类型</th><th>主从消息不丢失策略</th></tr></thead><tbody><tr><td>RoctMQ</td><td>在普通集群中，同步同步、异步同步。异步同步效率更高，但是有丢消息的风险，同步同步就不会丢消息</td></tr><tr><td>Rabbit MQ</td><td>普通集群：消息是分散存储的，节点之间不会主动进行消息同步，是有可能丢失消息的</td></tr><tr><td></td><td>镜像集群：镜像集群会在节点之间主动进行数据同步，这样数据安全性得到提高。</td></tr><tr><td>Kafka</td><td>通常都是用在允许消息少量丢失的场景，可以通过参数配置：acks：0，1，all</td></tr></tbody></table><ol start="3"><li>MQ消息存盘不丢失</li></ol><ul><li><p>RocketMQ：同步刷盘、异步刷盘：异步刷盘效率更高，但是有可能丢消息，同步刷盘消息安全性更高，但是效率会降低。</p></li><li><p>RabbitMQ：将队列配置成持久化队列</p></li></ul><ol start="4"><li>消费者消费消息不丢失</li></ol><ul><li><p>RocketMQ:使用默认的方式消费就行，不要采用异步方式</p></li><li><p>RabbitMQ：autoCommit</p></li><li><p>Kafka：手动提交offset</p></li></ul><h2 id="如何保证消费幂等性" tabindex="-1"><a class="header-anchor" href="#如何保证消费幂等性" aria-hidden="true">#</a> 如何保证消费幂等性?</h2><p>其实就是要防止消费者重复消费的问题。</p><p>所有MQ产品都没有提供主动解决幂等性的机制，需要由消费者自行控制。</p><p>RocketMQ：给每个消息分配了MessagesID，这个MessagesID可以作为消费者判断幂等的依据，这种方式不太建议。</p><p>最好的方式就是自己带一个有业务标识的id，来进行幂等判断，例如在订单中OrderID</p><p>还可以统一ID分配。</p><h2 id="mq如何保证消息顺序" tabindex="-1"><a class="header-anchor" href="#mq如何保证消息顺序" aria-hidden="true">#</a> MQ如何保证消息顺序?</h2><p>消息的顺序分为全局有序和局部有序，通常来说，MQ只需要保证局部有序，不需要保证全局有序。</p><p><img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210630003411.png" alt="img"></p><p>Java当中对零拷贝进行了封装，Mmap方式通过MappedByteBuffer对象进行操作，而transfer通过FileChannel来进行操作。</p><p>Mmap适合比较小的文件，通常文件大小不要超过1.5G-2G，transfile没有文件大小限制。</p><p>RocketMQ当中使用Mmap方式对它的文件进行读写。</p><p>在Kafka当中，它的index日志文件也是通过Mmap的方式来读写的。在其他的日志文件当中，并没有使用零拷贝的方式，Kafka使用transfile方式将硬盘数据加载到网卡。</p><h2 id="如何保证消息的高效读写" tabindex="-1"><a class="header-anchor" href="#如何保证消息的高效读写" aria-hidden="true">#</a> 如何保证消息的高效读写?</h2><p>零拷贝：Kafka和RocketMQ都是通过零拷贝技术来优化文件读写。</p><p>传统文件复制方式：需要对文件在内存中进行四次拷贝。</p><img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210630003425.png" alt="img" style="zoom:50%;"><p>零拷贝：有两种方式：mmap和 transfile</p><img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210630003438.png" alt="img" style="zoom:50%;"><p>Java当中对零拷贝进行了封装，Mmap方式通过MappedByteBuffer对象进行操作，而transfer通过FileChannel来进行操作。</p><p>Mmap适合比较小的文件，通常文件大小不要超过1.5G-2G，transfile没有文件大小限制。</p><p>RocketMQ当中使用Mmap方式对它的文件进行读写。</p><p>在Kafka当中，它的index日志文件也是通过Mmap的方式来读写的。在其他的日志文件当中，并没有使用零拷贝的方式，Kafka使用transfile方式将硬盘数据加载到网卡。</p><h2 id="使用mq如何保证分布式事务的最终一致性" tabindex="-1"><a class="header-anchor" href="#使用mq如何保证分布式事务的最终一致性" aria-hidden="true">#</a> 使用MQ如何保证分布式事务的最终一致性？</h2><p>分布式事务指的是业务相关的多个操作，保证他们同时成功或者同时失败。最终一致性指的是保证事务在最后阶段，能够达到一致性即可，与之对应的就是强一致性。</p><p>MQ中要保护事务的最终一致性，就需要做到两点：</p><ol><li>生产者要保证100%的消息投递（使用事务消息机制）</li><li>消费者这一段需要保证幂等消费（唯一ID + 业务自己实现幂等）</li></ol><p>分布式MQ的三种语义：at least once、at most once、exactly once</p><p>Rocket MQ并不能保证exactly once，商业版本中提供了exactly once的实现机制。</p><p>Kafka：在最新版本的饿源码当中，提供了exactly once的demo。</p><p>RabbitMQ：使用erlang语言天生就成为了一种屏障</p><h2 id="如何设计一个mq" tabindex="-1"><a class="header-anchor" href="#如何设计一个mq" aria-hidden="true">#</a> 如何设计一个MQ？</h2><p>从整体到细节，从业务场景到技术实现，以现产品为基础。具体的设计思路：</p><ul><li>实现单机的队列的数据结构。高效，可扩展</li><li>将单机队列扩展成为分布式队列，分布式集群管理</li><li>基于Topic定制消息路由策略</li><li>实现高效的网络通信 netty - http</li><li>规划日志文件，实现文件告诉读写，零拷贝，顺序写，服务重启后，快速还原运行现场</li><li>定制高级功能，死信队列、延迟队列、事务消息等等，注意贴合实际</li></ul><h2 id="kafka如何避免重复消费" tabindex="-1"><a class="header-anchor" href="#kafka如何避免重复消费" aria-hidden="true">#</a> Kafka如何避免重复消费？</h2>',58),r=[i];function p(h,o){return a(),e("div",null,r)}const c=t(d,[["render",p],["__file","mq.html.vue"]]);export{c as default};
