import{_ as e,r as t,o as p,c,a,b as o,d as l,e as n}from"./app-6a04670c.js";const i={},u=n('<h1 id="java集合" tabindex="-1"><a class="header-anchor" href="#java集合" aria-hidden="true">#</a> Java集合</h1><h2 id="list、set、map三者的区别" tabindex="-1"><a class="header-anchor" href="#list、set、map三者的区别" aria-hidden="true">#</a> List、Set、Map三者的区别？</h2><p>List用来存储一组不唯一（可以重复），有序的对象；</p><p>Set用来存储不允许重复的集合，不会有多个元素引用相同集合的对象；</p><p>Map是用来存储键值对的，Map会维护与Key有关联的值，两个不同的Key可以引用相同的对象，Key不能重复。</p><h2 id="hashmap实现原理" tabindex="-1"><a class="header-anchor" href="#hashmap实现原理" aria-hidden="true">#</a> HashMap实现原理？</h2>',6),r={href:"https://tech.meituan.com/2016/06/24/java-hashmap.html",target:"_blank",rel:"noopener noreferrer"},d=n(`<h2 id="hashmap为什么扩容为2倍" tabindex="-1"><a class="header-anchor" href="#hashmap为什么扩容为2倍" aria-hidden="true">#</a> HashMap为什么扩容为2倍？</h2><p>HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，使用的算法是：<code>hash &amp; (length - 1)</code>，实际上<code>hash &amp; (length - 1) = hash % length</code>，主要考虑到模运算的速度比位运算的的快。</p><h2 id="为什么hashmap不用linkedlist-而是选用数组" tabindex="-1"><a class="header-anchor" href="#为什么hashmap不用linkedlist-而是选用数组" aria-hidden="true">#</a> 为什么HashMap不用LinkedList，而是选用数组？</h2><p>在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到，此时已知桶的位置，使用数组查询的效率会LinkedList大；不使用ArrayList的原因是，ArrayList的扩容机制是1.5倍扩容，无法自定义扩容机制。</p><h2 id="jdk1-8对hashmap有哪些优化" tabindex="-1"><a class="header-anchor" href="#jdk1-8对hashmap有哪些优化" aria-hidden="true">#</a> JDK1.8对HashMap有哪些优化？</h2><ul><li>由数组 + 链表的结构改为了数组 + 链表 + 红黑树</li><li>优化了高位运算的hash算法：<code>h^(h &gt;&gt;&gt; 16)</code></li><li>扩容后，元素要么是在原来的位置，要么是在原位置再移动2次幂的位置，且链表顺序不变</li></ul><h2 id="为什么不直接使用红黑树-而是选择先用链表-再转红黑树" tabindex="-1"><a class="header-anchor" href="#为什么不直接使用红黑树-而是选择先用链表-再转红黑树" aria-hidden="true">#</a> 为什么不直接使用红黑树，而是选择先用链表，再转红黑树？</h2><p>因为红黑树需要进行左旋、右旋、变色这些操作来保持平衡，而单链表不需要，当元素小于8个的时候，此时做查询操作，链表结构已经能保证查询性能，当元素大于8个的时候，此时需要红黑树来加速查询速度，但是新增节点的效率变慢了，因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p><h2 id="hashmap不使用红黑树-而是使用二叉查找树可以吗" tabindex="-1"><a class="header-anchor" href="#hashmap不使用红黑树-而是使用二叉查找树可以吗" aria-hidden="true">#</a> HashMap不使用红黑树，而是使用二叉查找树可以吗？</h2><p>可以，但是二叉查找树在特殊情况下会变成一条线性结构，此时遍历查找会非常慢。</p><h2 id="为什么阈值是8" tabindex="-1"><a class="header-anchor" href="#为什么阈值是8" aria-hidden="true">#</a> 为什么阈值是8？</h2><p>hashcode碰撞次数与泊松分布有关，选择8是根据概率统计而选择的。泊松分布的示意图：</p><img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210823233913.png" alt="image-20210823233717518" style="zoom:50%;"><h2 id="当链表转为红黑树-什么时候退化为链表" tabindex="-1"><a class="header-anchor" href="#当链表转为红黑树-什么时候退化为链表" aria-hidden="true">#</a> 当链表转为红黑树，什么时候退化为链表？</h2><p>等于6的时候退转为链表。中间有差值7可以防止链表和树之间频繁的转换。假设这个互相转换的界限都是8，那么如果一个HashMap不停的插入、删除元素，链表个数会在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p><h2 id="hashmap在并发编程环境下有什么问题" tabindex="-1"><a class="header-anchor" href="#hashmap在并发编程环境下有什么问题" aria-hidden="true">#</a> HashMap在并发编程环境下有什么问题？</h2><ul><li>多线程扩容，引起的死循环问题</li><li>多线程put的时候可能导致元素丢失</li><li>put非null元素后get出来的却是null</li></ul><h2 id="使用可变类当hashmap的key有什么问题" tabindex="-1"><a class="header-anchor" href="#使用可变类当hashmap的key有什么问题" aria-hidden="true">#</a> 使用可变类当HashMap的key有什么问题？</h2><p>hashCode可能发生改变，导致put进去的值，无法get出，如下所示：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMapDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> changeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> objectValue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        changeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> objectValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>changeMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//hashcode发生了改变</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>changeMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="如何实现一个自定义的class作为hashmap的key" tabindex="-1"><a class="header-anchor" href="#如何实现一个自定义的class作为hashmap的key" aria-hidden="true">#</a> 如何实现一个自定义的Class作为HashMap的key？</h2><ul><li>重写hashcode和equals</li><li>如何设计一个不可变类</li></ul><h2 id="hashset实现原理" tabindex="-1"><a class="header-anchor" href="#hashset实现原理" aria-hidden="true">#</a> HashSet实现原理？</h2><p>底层使用HashMap实现：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// hashMap的value是Object类型</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">PRESENT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// HashSet添加元素的方法</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// HashSet删除元素的方法</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token operator">==</span><span class="token constant">PRESENT</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="currenthashmap的实现原理" tabindex="-1"><a class="header-anchor" href="#currenthashmap的实现原理" aria-hidden="true">#</a> CurrentHashMap的实现原理？</h2><p>JDK1.7分段锁的设计，JDK1.8：Node + CAS + Synchronized</p><h2 id="arraylist的实现原理" tabindex="-1"><a class="header-anchor" href="#arraylist的实现原理" aria-hidden="true">#</a> ArrayList的实现原理？</h2><p>ArrayList底层使用一个支持自动扩容的数组来保存所有元素。ArrayList并不是线程安全的，只能在单线程环境下使用，多线程环境下可以使用<code>java.util.Collections.SynchronizedList</code>或<code>java.util.concurrent.CopyOnWriteArrayList</code>来代替。</p>`,29);function h(k,m){const s=t("ExternalLinkIcon");return p(),c("div",null,[u,a("p",null,[a("a",r,[o("Java 8系列之重新认识HashMap - 美团技术团队 (meituan.com)"),l(s)])]),d])}const b=e(i,[["render",h],["__file","Java_collections.html.vue"]]);export{b as default};
