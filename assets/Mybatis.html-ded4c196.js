import{_ as t,r,o as s,c as d,a as e,b as a,d as l,e as h}from"./app-8be72ab3.js";const p={},n=e("h1",{id:"mybatis面试题",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#mybatis面试题","aria-hidden":"true"},"#"),a(" MyBatis面试题")],-1),c=e("h2",{id:"mybatis接口-mapper内的方法为什么不能重载",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#mybatis接口-mapper内的方法为什么不能重载","aria-hidden":"true"},"#"),a(" Mybatis接口 Mapper内的方法为什么不能重载？")],-1),o=e("p",null,'Mybatis在XML文件中寻找对应的SQL语句的时候，会根据StrictMap<String, MappedStatement>中查找对应的MappedStatement，这里Map的key就是根据Mapper的全类名 + "." + 方法名。一方面，StrictMap如果出现重复的key会直接抛出异常，另一方面，如果允许key重复，也就是允许Mapper内的方法重载，则无法定位到XML文件内唯一的SQL语句。',-1),m={href:"https://www.cnblogs.com/Chenjiabing/p/13671589.html",target:"_blank",rel:"noopener noreferrer"},b=h('<h2 id="mybatis的xml映射文件中-不同的xml映射文件-id是否可以重复" tabindex="-1"><a class="header-anchor" href="#mybatis的xml映射文件中-不同的xml映射文件-id是否可以重复" aria-hidden="true">#</a> Mybatis的XML映射文件中，不同的XML映射文件，id是否可以重复？</h2><p>同一个namespace下的id不能重复，原因是 namespace + id 会作为<code>Map&lt;String，MapperStatement&gt;</code>的key使用，如果id重复会导致数据互相覆盖。</p><h2 id="和-的区别是什么" tabindex="-1"><a class="header-anchor" href="#和-的区别是什么" aria-hidden="true">#</a> #{}和${}的区别是什么？</h2><p><code>#{}</code> 是预编译处理，<code>${}</code>是字符串替换。</p><ul><li>Mybatis在处理<code>#{}</code>时，会将sql中的<code>#{}</code>替换为“？”号，调用PreparedStatement的set方法来赋值</li><li>Mybatis在处理<code>${}</code>时，就是把<code>\\${}</code>替换程变量的值</li></ul><p>使用<code>#{}</code>可以有效的放置SQL注入，提高系统的安全性。</p><h2 id="当实体类中的属性名和表中的字段名不一样怎么办" tabindex="-1"><a class="header-anchor" href="#当实体类中的属性名和表中的字段名不一样怎么办" aria-hidden="true">#</a> 当实体类中的属性名和表中的字段名不一样怎么办？</h2><ul><li>通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</li><li>通过<code>&lt;resultMap&gt;</code>来映射字段名和实体类属性名的一一对应的关系。</li></ul><h2 id="模糊查询like语句该怎么写" tabindex="-1"><a class="header-anchor" href="#模糊查询like语句该怎么写" aria-hidden="true">#</a> 模糊查询like语句该怎么写？</h2><ul><li>在java代码中添加sql通配符</li><li>在sql语句中拼接通配符，会引起sql注入</li></ul><h2 id="mybatis时如何进行分页的-分页插件的原理是什么" tabindex="-1"><a class="header-anchor" href="#mybatis时如何进行分页的-分页插件的原理是什么" aria-hidden="true">#</a> Mybatis时如何进行分页的？分页插件的原理是什么?</h2><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。</p><h2 id="mybatis有哪些动态sql" tabindex="-1"><a class="header-anchor" href="#mybatis有哪些动态sql" aria-hidden="true">#</a> Mybatis有哪些动态sql？</h2><p>tirm、where、set、foreach、if、choose、when、otherwise、bind。</p><h2 id="mybtais动态sql有什么用-执行原理是什么" tabindex="-1"><a class="header-anchor" href="#mybtais动态sql有什么用-执行原理是什么" aria-hidden="true">#</a> Mybtais动态sql有什么用？执行原理是什么？</h2><p>MyBatis动态sql可以在XML映射文件内，以标签的形式编写动态sql，执行原理时根据表达式的值，完成逻辑判断并动态拼接sql的功能。</p><h2 id="mapper编写有哪几种方式" tabindex="-1"><a class="header-anchor" href="#mapper编写有哪几种方式" aria-hidden="true">#</a> Mapper编写有哪几种方式？</h2><ul><li>接口实现类继承SqlSessionDaoSupport，需要编写mapper接口，mapper接口实现类、mapper.xml文件</li><li>使用org.mybatis.spring.mapper.MapperFactoryBean;</li><li>使用mapper扫描器</li></ul><h2 id="mybatis的一级、二级缓存" tabindex="-1"><a class="header-anchor" href="#mybatis的一级、二级缓存" aria-hidden="true">#</a> Mybatis的一级、二级缓存？</h2><ul><li>一级缓存：基于PerpetuaCache的HashMap本地缓存，其存储作作用域为Session，默认打开一级缓存</li><li>二级缓存与一级缓存机制相同，不做其作用域为Sessionfactory，该缓存是以namespace为单位的（也就是一个Mapper.xml文件），不同namespace下的操作互不影响。</li></ul><blockquote><p>使用二级缓存需要实现序列化接口。</p></blockquote><h2 id="mybatis有二级缓存-为什么还要用redis" tabindex="-1"><a class="header-anchor" href="#mybatis有二级缓存-为什么还要用redis" aria-hidden="true">#</a> Mybatis有二级缓存，为什么还要用redis？</h2><p>使用Mybatis的二级缓存可能会存在如下两个问题：</p><ul><li>所有对数据表的改变都会刷新缓存，但是一般不要使用二级缓存，例如在UserMappper.xml中有大多数针对user表的操作，但是在另一个***Mapper.xml中，还有针对user单表的操作，这会导致user在两个命名空间下的数据不一致</li><li>如果在UserMappper.xml做了刷新缓存的操作，在***Mapper.xml中缓存仍然有效，如果有针对user的单表查询，使用缓存的结果可能会不正确</li></ul><p>而Redis很好的解决了这个问题，并且还有其它的特性，例如可以搭建在其它服务器上，缓存的容量可扩展等。</p><h2 id="mybatis如何开启二级缓存" tabindex="-1"><a class="header-anchor" href="#mybatis如何开启二级缓存" aria-hidden="true">#</a> Mybatis如何开启二级缓存？</h2><p>https://tech.meituan.com/2018/01/19/mybatis-cache.html</p>',27);function u(y,M){const i=r("ExternalLinkIcon");return s(),d("div",null,[n,c,o,e("p",null,[a("更多内容可以参考："),e("a",m,[a("Mybatis接口 Mapper内的方法为什么不能重载？"),l(i)])]),b])}const f=t(p,[["render",u],["__file","Mybatis.html.vue"]]);export{f as default};
