# 数据结构

数据结构，是相互之间存在一种或多种特定关系的数据元素的集合。按照视点的不同，我们把数据结构分为逻辑结构和物理结构。其中，逻辑结构又可以分为集合结构、线性结构、树形结构、图形结构等，物理结构可以分为顺序存储结构和链式存储结构。

数据结构优化的核心思路，一是升维 二是用空间换时间。

## 数组

数组的查询的时间复杂度O(1)，插入/删除元素的时间复杂度O(n)。

初始化数组的方式：

- 静态初始化：

	```java
	int[] nums = new int[]{1, 2, 3, 4, 5, 9};
	```

- 简单的静态初始化：

	```java
	int[] nums = {1, 2, 3, 4, 5, 9};
	```

- 动态初始化：

	```java
	int[] nums = new int[4];
	```

遍历数组的方式：

- 传统的for循环方式：

	```java
	public class Main {
	    public static void main(String[] args) {
	        int[] ns = {1, 4, 9, 16, 25};
	        for (int i = 0; i < ns.length; i++) {
	            System.out.println(ns[i]);
	        }
	    }
	}
	```

- 使用foreach循环：

	```java
	public class Main {
	    public static void main(String[] args) {
	        int[] ns = {1, 4, 9, 16, 25};
	        for (int n : ns) {
	            System.out.println(n);
	        }
	    }
	}
	```

- 使用Java标准库中的Arrays.toString()：

	```java
	import java.util.Arrays;
	
	public class Main {
	    public static void main(String[] args) {
	        int[] ns = {1, 1, 2, 3, 5, 8};
	        System.out.println(Arrays.toString(ns));
	    }
	}
	```

二维数组的定义及遍历。
```java
public class Main {
    public static void main(String[] args) {
        int[][] array = new int[3][4]; //创建一个3行4列的数组，并且里面值都为默认值
        for (int i = 0; i < array.length; i++) { // 第一个循环，循环每一行
            for (int j = 0; j < array[i].length; j++) { //第二个循环，循环每行的每一列
                System.out.print(array[i][j]);
            }
            System.out.println();
        }
    }
}
```

## 链表

链表的查询时间时间复杂度O(n)，插入/删除元素的时间复杂度O(1)

提高链表线性表查找的效率？

- 添加第一级索引
- 添加第二级索引
- 添加多级索引，总数为log2n个索引

时间复杂度为O(log2n)，空间复杂度为O(n)



## 跳表

跳表的问题：索引的维护比较困难

## 哈希表

哈希表（Hash table），也叫散列表，是根据关键码值直接访问元素的数据结构，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，即通过某个函数f，使得：

```txt
存储位置 = f（关键字）
```

这样我们可以通过查找关键字而不需要比较就可以获取需要的记录的存储位置，这个映射函数f叫做散列函数或者哈希函数，存放记录的数组叫做哈希表（或散列表），关键字所对应的记录位置称为散列地址。

散列技术即是一种存储方法，也是一种查找方法。散列技术的记录之间不存在什么逻辑关系，它只与关键字有关系，因此最适合求接的问题是查找与给定值相等的记录。

当两个关键字key<sub>1</sub> ≠ key<sub>2</sub>，但是却有f(key<sub>1</sub>) = f(key<sub>2</sub>)，这种现象我们称为冲突，并把key<sub>1</sub>和key<sub>2</sub>称为这个散列函数的同义词。

构造哈希函数的方法主要有：

- 直接定址法：f(key) = a*key + b(a、b均为常数)
- 数字分析法
- 平法取中法
- 折叠法
- 除留余数法 ：f(key) = key mod p (p <= m)
- 随机数法

处理散列冲突的方法：

- 开放地址法
- 再散列函数法
- 链地址法
- 公共区溢出法

## 栈

stack：先入后出；添加，删除皆为O(1)，有时候也称为FILO

> - 如果问题具有最近相关性，就可以使用栈来解决。
> - 如果要用栈来实现队列，可以用两个栈。

## 队列

queue：先入先出；添加、删除皆为O(1)，有时候也成为FIFO

> - 如果问题具有公平性，就可以使用队列来解决。
> - 如果要用队列来实现栈，可以用两个队列



## 双端队列

双端队列（Dequeue） Double-End Queue

## 树

### 总体介绍

现实生活中，除了前面的一对一的线性结构，还有很多一对多的数据结构——“树”。

树的表示方法有：

- 双亲表示法
- 孩子表示法
- 孩子兄弟表示法

对于计算机来说，它只有循环、判断、递归等方式，也就是说，它只能处理线性序列，树的遍历实际上就是将树中的结点编程某种意义上的线性序列，方便计算机处理。

在实际工程中，经常采用递归来解决树相关的问题的原因是：

- 节点的定义

- 可重复性（自相似性）

### 代码模板

```java
public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;

    public TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}
```

## 二叉树

二叉树的遍历方法有以下几种：

- 前序（Pre-order）：根-左-右
- 中序（In-order）：左-根-右
- 后序（Post-order）：左-右-根
- 层次遍历

二叉树遍历遍历的性质：

- 已知前序遍历序列和中序遍历序列，可以唯一确定一颗二叉树
- 已知中序遍历序列和后序遍历序列，可以唯一确定一颗二叉树

>已知前序和后序遍历，无法确定唯一一颗二叉树。

如果二叉树退化成了链表（即元素都在左子树上或者都在右子树上），那么时间复杂度会变成O（n）

## 二叉搜索树

二叉搜索树，也称二叉搜索树、有序二叉树（Ordered Binary Tree）、二叉排序树（Sorted Binary Tree），是一棵空树或者具有下列性质的二叉树：

- 左子树上的`所有结点`的值均小于它的根节点的值
- 右子树上`所有结点`的值均大于它的根结点的值
- 依次类推：左、右子树也分别为二叉查找树（这就是重复性）

二叉搜索树的性质：

- 中序遍历是递增序列


二叉搜索树的插入和查询时间复杂度都是O(logn)。

## 平衡二叉树

平衡二叉树是一种二叉排序树，每一个结点的左子树和右子树的高度差至多等于1，平衡二叉树有时候也称为AVL树。

平衡二叉树的性质：

- 我们将二叉树的左子树深度减去右子树深度的值称为平衡因子（BF），那么平衡二叉树的所有结点的平衡因子只可能是-1，0，1。
- 平衡二叉树的查找、插入和删除的时间复杂度均为O（logn）

## 红黑树

主要参考：[30张图带你彻底理解红黑树](https://www.jianshu.com/p/e136ec79235c)

### 定义和性质

红黑树是二叉查找树，具体来说，是一种含有红黑结点并能自平衡的二叉查找树，它必须满足下面的性质：

- 性质1：每个结点要么是黑色，要么是红色
- 性质2：根节点是黑色
- 性质3：每个叶子结点（NIL）是黑色
- 性质4：每个红色结点的两个子节点一定都是黑色
- 性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑节点

从性质5又可以推出：

- 性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点

一颗简单的红黑树如下图所示：

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210829231754.png" alt="一颗简单的红黑树" style="zoom:50%;" />

红黑树并不是一个完美平衡二叉查找树，从图1可以看到，根节点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到每个叶子结点的路径都包含数量相同的黑结点（性质5）。所以我们叫红黑树这种平衡为黑色完美平衡。

在红黑树中最主要的有三种操作：左旋、右旋和变色。

- 左旋：以某个结点作为支点（旋转结点），其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变
- 右旋：以某个结点作为支点（旋转结点），其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变
- 变色：结点的颜色由红变黑或由黑变红

左旋的示意图：

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210829233108.png" alt="左旋" style="zoom: 67%;" />

右旋的示意图：

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210829233211.png" alt="右旋" style="zoom:67%;" />

如果我们暂时忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。

- 左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪了
- 右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪了

### 红黑树的查找

整体的示意图如下：

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210829233651.png" alt="红黑树的查找" style="zoom:50%;" />

因为红黑树也是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：

- 从根节点开始查找，把根节点设置为当前结点
- 若当前结点为空，返回null
- 若当前结点不为空，用当前结点的key跟查找key作比较
- 若当前结点等于查找key，那么该key就是查找目标，返回当前结点
- 若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2
- 若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2

### 红黑树的插入

整体的示意图如下：

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210829233941.png" alt="红黑树的插入" style="zoom: 67%;" />

插入操作包括两部分工作：一个是查找插入的位置，而是插入后自平衡。查找插入的父结点很简单，跟查找操作的区别不大：

- 从根结点开始查找
- 若根结点为空，那么插入结点作为根节点，结束
- 若根结点不为空，那么把根结点作为当前结点
- 若当前结点为null，返回当前结点的父结点，结束
- 若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束
- 若当前结点key大于查找key，那么当前结点的左子结点设置为当前结点，重复步骤4
- 若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4

当插入的位置确定之后就是要确定插入结点的颜色，插入的结点都是红色，原因在于，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。

所有可能的插入的情景：

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210830094135.png" alt="红黑树插入情景"/>



## 多路查找树

多路查找树的每一个结点的孩子树可以多于两个，且每一个结点处可以存储多个元素，由于它是查找树，所有元素之间存在某种特定的排序关系。

### 2-3树

2-3树是这样一颗多路查找树：其中每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点）。

- 一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个2结点要么没有孩子，要么就有两个，不能只有一个孩子
- 一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素

并且2-3树种所有的叶子都在同一层次上。

### 2-3-4树

2-3-4树实对2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含于最小元素的元素，第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最低元素的元素；右子树包含大于最大元素的元素。

### B树

B树是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶。因此，2-3树是3阶的B树，2-3-4树是4阶B树。

### B+树

B+树是应文件系统所需而出的一种B树的变形树，注意严格意义上讲，它其实已经不是之前所定义的树了。在B树中，每一个元素在该树只出现一次，有可能在叶子结点上，也可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当做它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向叶子结点的指针。

## 堆

堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆，如下图所示：

![image-20210707172409423](https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210707172409.png)

这里由定义可知，根节点一定是堆中所有结点最大（小）者。

## 优先队列

### 总体介绍

优先队列(Priority Queue)的作用是能保证每次取出的元素都是队列中权值最小的（Java的优先队列每次取得是最小元素）。元素的大小默认是通过元素本身的自然顺序，也可以通过构造时传入比较器。

Java中的PriorityQueue实现了Queue接口，不允许放入null元素，其通过堆实现，具体是通过完全二叉树实现的小顶堆，这也意味着可以通过数组来作为PriorityQueue的底层实现。

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210707223529.png" alt="PriorityQueue_base.png" style="zoom: 50%;" />

优先队列的插入操作时间复杂度是：O(1)，取出操作：O(logN) ，底层具体实现的数据结构较为多样和复杂：heap、bst、treap...。

### 方法剖析

`add(E e)`和`offer(E e)`的语义相同，都是向队列中插入元素，二者的区别在于插入失败情况的处理，前者插入失败是抛出异常，后者则返回false。

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210707224316.png" alt="PriorityQueue_offer.png" style="zoom:50%;" />

`element()`和`peek()`语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者的区别在于获取失败的情况的处理，前者会抛出异常，后者会返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个，如果用数组来存储堆，根据下标关系，`0`下标处的那个元素即是堆顶元素，因此，直接返回数组`0`下标处的那个元素即可。

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210707225025.png" alt="PriorityQueue_peek.png" style="zoom:50%;" />

`romve()`和`poll()`方法的语义也完全相同，都是获取并删除队首元素，二者的区别在于删除失败的情况的处理，前者会抛出异常，后者会返回null。

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/img/20210707225501.png" alt="PriorityQueue_poll.png" style="zoom: 50%;" />

## 图



## 拓扑排序



# 并查集

并查集（Disjoint-set）

适用的场景：

组团、配对问题

Group or not？

并查集的操作

1、makeSet（s）：建立一个新的并查集，其中包含s个单元素集合。

2、unionSet（x，y）：把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并。

3、find（x）：找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将他们各自的代表比较一下就可以了。